00:09:03 <masak> so, arrows are what you use instead of functions when you also need to weave in monads?
00:11:00 <Kaidelong> ...eh?
00:11:05 <Saizan> no
00:12:11 <Kaidelong> arrows are basically just functions + context, aren't they?
00:12:23 <Kaidelong> or just functions if you want
00:12:46 <Saizan> masak: it's true that for every monad M the type K a b = a -> M b is an Arrow
00:13:44 <masak> K as in Kleisli?
00:13:51 <Saizan> masak: but there are other kind of arrows too, in general they work like fancier functions, but the fancyness can take many forms
00:13:56 <Saizan> yep
00:13:59 <masak> \o/
00:14:15 <masak> so far, I think I'm following along.
00:14:43 <masak> could a regular function be seen as an arrow?
00:14:49 <Saizan> yes
00:15:00 <Saizan> in fact there's an instance Arrow (->)
00:16:11 <masak> huh :)
00:17:06 <Saizan> you could say that Arrow was invented because they wanted to work with structures that weren't as opaque as K a b
00:18:00 <Kaidelong> mmm, would it be fair to say that "(Arrow arr) => arr a b" is important because you cannot map an arrow over a functor the way you can map a function?
00:18:02 <Saizan> opaque in the sense that you can't take functions apart to gain information on what they do, you can only apply them
00:18:20 <Kaidelong> (except certain arrows)
00:19:52 <ddarius> You could define a Functor class for arbitrary Categories and then you could "fmap" an arrow just as much as a function.
00:20:17 <Kaidelong> how?
00:20:28 <Kaidelong> oh also
00:20:45 <Kaidelong> would all current functors be instances of that?
00:20:52 <Kaidelong> I'd imagine the answer is yes
00:46:34 * hackagebot edit-distance 0.2.0 - Levenshtein and restricted Damerau-Levenshtein edit distances  http://hackage.haskell.org/package/edit-distance-0.2.0 (MaxBolingbroke)
00:54:12 <Saizan> class Functor c d f where fmap :: c a b -> d (f a) (f b)
00:55:30 <c_wraith> that feels very arrow-esque.  As you're abstracting out functions.
00:57:29 <Saizan> yep, i should've added (Category c, Category d) =>
01:08:20 <Eduard_Munteanu> Saizan: hm, that's neat
01:09:29 <Eduard_Munteanu> I wonder if something like that makes sense for Monad too.
01:12:20 <Eduard_Munteanu> like...    class Functor c d m => Monad m where return :: c a (m a)  ...  -- unless I got them mixed up a bit
01:12:36 <Eduard_Munteanu> Wait... d = c
01:13:03 <Eduard_Munteanu> Since it must behave like an endofunctor.
01:14:05 <Saizan> sure
01:15:01 <Saizan> not that i'd change the canonical Functor and Monad classes like that, but it makes sense in general
01:16:14 <Saizan> you can e.g. do hoare triplets with monads over the category of (* -> *) types
01:16:25 <Eduard_Munteanu> I'm a bit rusty on arrows, I can't really tell how much sense it makes for other stuff, like (>>>). It does feel more categorical, but I keep wondering whether (->) suffices even for arrows.
01:16:30 <Eduard_Munteanu> :t (>>>)
01:16:30 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
01:16:47 <Eduard_Munteanu> Oh, nice.
01:25:48 <Itkovian> is there an easy way to automagically update one's cabal installation to the new platform?
01:28:06 <Eduard_Munteanu> I'd think not, since you shouldn't update base libs with cabal-install, if that's what you're asking.
01:32:58 <Kaidelong> :t (>=> return)
01:32:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> a -> m b
01:33:11 <Kaidelong> :t (>=> id)
01:33:12 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m (m c)) -> a -> m c
01:33:20 <Kaidelong> :t (return >=> id)
01:33:21 <lambdabot> forall (m :: * -> *) c. (Monad m) => m c -> m c
01:33:29 <Kaidelong> :t (id >=> id)
01:33:29 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
01:34:15 <Kaidelong> :t (id >>> id)
01:34:16 <lambdabot> forall a. a -> a
01:34:32 <Kaidelong> > (id >>> id) [[1,2],[3,4]]
01:34:33 <lambdabot>   [[1,2],[3,4]]
01:34:51 <Kaidelong> > (return >>> return) [[1,2],[3,4]]
01:34:52 <lambdabot>   No instance for (GHC.Show.Show (m (m1 [[t]])))
01:34:52 <lambdabot>    arising from a use of `M4...
01:40:03 * illissius wonders, per the recent -cafe discussion, whether there's some kind of useful analogy between iterators/enumerators/enumeratees and gstreamer pipelines
01:40:41 * hackagebot control-monad-queue 0.2 - Reusable corecursive queues, via continuations.  http://hackage.haskell.org/package/control-monad-queue-0.2 (LeonSmith)
01:40:45 <illissius> given that seemingly in both cases, the primary goal is to send information in one direction along the pipeline for processing, but the various elements in the pipeline also end up wanting to pass meta-information between each other in both directions
01:41:52 <illissius> though i have only a very superficial understanding of both iteratees and gstreamer so there's probably no there there, but reading about one happened to remind me of the other
02:15:06 <jonkri> how can i do something like this: http://hpaste.org/45101/parse_error_in_pattern
02:17:17 <Kaidelong> jonkri: You need a destructor in there, and pack is a function
02:17:32 <Kaidelong> perhaps what you are after is something like
02:17:45 <Kaidelong> Just x | x == DT.pack("foo")
02:18:20 <Kaidelong> or in that case, since it's a boolean
02:18:26 <Kaidelong> you could do even better and just say
02:19:08 <Kaidelong> Just x -> x == DT.pack("foo") || x == DT.pack("bar")
02:19:18 <jonkri> ohh, you can have guards in cases :)
02:19:27 <jonkri> oh ok
02:29:27 <Kaidelong> http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/src/Acme-Time-Now.html#now
02:29:34 <Kaidelong> when does "now" actually get bound?
02:29:40 <Kaidelong> err
02:29:49 <Kaidelong> to an actual time, more specifically
02:29:55 <Kaidelong> the first time it is evaluated?
02:30:02 <Kaidelong> when the program is compiled?
02:30:24 <Veinor> i assume when it gets evaluated
02:31:09 <quicksilver> or possibly every time it gets evaluated
02:31:18 <quicksilver> or possibly some of the times it gets evaluated
02:31:23 <quicksilver> that's the thing about unsafePerformIO
02:31:37 <Kaidelong> lovely
02:37:32 <jonkri> thanks Kaidelong :)
02:37:45 <Kaidelong> not a problem
03:13:17 <CADD> hi all, i have a question
03:13:29 <CADD> so, let me write this all out.. heh
03:14:23 <CADD> getRandomIndex :: Int -> Int
03:15:09 <CADD> getRandomIndex lengthofList = getStdRandom (randomR (0, lengthOfList)) >>= (\x -> return x)
03:15:18 <sipa> :t getStdRandom
03:15:19 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
03:15:32 <sipa> it's using IO
03:15:45 <sipa> there is no way to turn that into a pure function without using unsafePerformIO
03:16:00 <CADD> yup, thats why I am binding it with >>=, or am i doing it wrong?
03:16:07 <sipa> :t >>=
03:16:07 <lambdabot> parse error on input `>>='
03:16:10 <sipa> :t (>>=)
03:16:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:16:15 <sipa> read the types
03:16:26 <sipa> nowhere is there something without 'm' coming out
03:17:02 <CADD> not quite following you, sorry newbie here.
03:17:20 <sipa> long story short: once it's IO, it won't ever be anything without IO
03:18:11 <CADD> well crap, i thought binding made it temporarily a regular int, or atleast made it act like an int
03:18:17 <sipa> no
03:18:28 <sipa> binding allows you to do things with the int inside
03:18:44 <sipa> :t printLn
03:18:44 <lambdabot> Not in scope: `printLn'
03:18:45 <Eduard_Munteanu> CADD: it does but you can only bind to a function a -> IO b then
03:19:00 <sipa> exactly, and the result will be something of IO again
03:19:06 <CADD> hmm, well then is there any way that i can compare it to an int?
03:19:15 <sipa> yes, inside another IO action
03:19:29 <CADD> hmm..
03:19:32 <sipa> for example
03:20:03 <sipa> @let printHighLow n = if n < 10 then putStrLn "lower" else putStrLn "higher"
03:20:04 <lambdabot>  Defined.
03:20:10 <sipa> :t printHighLow
03:20:11 <lambdabot> forall a. (Num a, Ord a) => a -> IO ()
03:20:27 <sipa> this is something of type Int -> IO (), if you want it to
03:20:38 <sipa> so you could do getStdRandom ... >>= printHighLow
03:20:59 <sipa> and the result will be of type IO (), and it will generate a random number, compare it to 10, and print out a string
03:21:48 <CADD> ok, cool, but say i wanted to instead of puting out a string, maybe return something? like an int or a bool? or is that just plainly not possible?
03:22:10 <Eduard_Munteanu> CADD: you can only return an int wrapped in IO
03:22:34 <sipa> CADD: you can do whatever you want with that int, but eventually you'll need to turn it into an IO action
03:22:36 <Eduard_Munteanu> CADD: which can further be used by other IO actions. But you can't get rid of IO
03:22:48 <CADD> damn.. well i read somewhere about random streams, which i heard are purely funtional
03:23:01 <sipa> see it this way: (IO a) means a program that computes something of type a
03:23:13 <sipa> (a -> b) is a pure function for a to b
03:23:14 <Eduard_Munteanu> CADD: oh, I see what you mean.
03:23:31 <Eduard_Munteanu> Inside your IO action you can call pure functions and give them that list as an argument.
03:23:41 <Eduard_Munteanu> like...
03:23:50 <sipa> @undef printHighLow
03:24:03 <sipa> @let printHL n = n < 10
03:24:04 <lambdabot>  Defined.
03:24:07 <sipa> :t printHl
03:24:07 <lambdabot> Not in scope: `printHl'
03:24:08 <sipa> :t printHL
03:24:09 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
03:24:16 <sipa> CADD: this is a pure function, right?
03:24:28 <CADD> but im not sure how to go about using them.. im interested in using the random numbers for further things inside other funtions, not IO
03:24:31 <CADD> alright
03:24:37 <Eduard_Munteanu> a <- getRandomNumberList; let b = pureFunction a; doSomethingWith b ...
03:24:40 <sipa> :t (getStdRandom (randomR (0, 10)))
03:24:40 <lambdabot> forall t. (Num t, Random t) => IO t
03:25:08 <sipa> :t (getStdRandom (randomR (0, 10)) >>= \x -> print (printHL x))
03:25:09 <lambdabot> IO ()
03:25:17 <Eduard_Munteanu> It's a basic idiom to get an infinite list of random numbers at the beginning and pass that around into pure functions.
03:25:47 <sipa> CADD: i'm calling printHL with the result of getStdRandom, but using that inside an IO action again
03:26:58 <CADD> alright cool, but i think i want to stay away from IO, im interested in using the random numbers in other functions..
03:27:19 <Eduard_Munteanu> If you have IO at one level, you can use pure functions deeper inside, but you can't escape IO higher up.
03:27:31 <CADD> so i would pass the infinate list into other funtions?
03:27:41 <Eduard_Munteanu> Yep.
03:27:58 <Eduard_Munteanu> (you still need IO to get the list though)
03:28:13 <Eduard_Munteanu> Just initially.
03:29:11 <CADD> alright, so, if i instantiate the list, then later on the same function is called, instantiating the list again, will it have the same random numbers being pulled out of the list?
03:31:01 <CADD> or is that just a facepalm thing to say?
03:34:17 <Jafet> They're all streams of pseudorandom numbers, not random numbers.
03:34:56 <Eduard_Munteanu> You'll have to deal with 'consuming' the list yourself.
03:35:11 <Eduard_Munteanu> And discarding whatever's been used already.
03:36:44 <CADD> hmm.. alright, fair enough
03:37:25 <Jafet> You should understand how pseudorandomness works.
03:38:30 <Jafet> The type of random pretty much defines it:
03:38:34 <Jafet> :t random
03:38:34 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
03:39:02 <Jafet> A deterministic function that produces a new pseudorandom a from a state g and then updates the state g.
03:39:12 <Jafet> (Well, all functions are deterministic)
03:39:14 <Eduard_Munteanu> @src State    -- to compare with
03:39:14 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:39:14 <CADD> yup based on the seed
03:39:41 <Eduard_Munteanu> @vixen damn!
03:39:41 <lambdabot> i know, it's too bad
03:39:59 <CADD> and ive been looking around seems like i can get a new random seed like "a <- getStdGen"
03:40:08 * hackagebot edit-distance 0.2.1 - Levenshtein and restricted Damerau-Levenshtein edit distances  http://hackage.haskell.org/package/edit-distance-0.2.1 (MaxBolingbroke)
03:42:06 <CADD> and then use a in like "randList = randoms a :: [int]"
03:42:44 <CADD> and then something like "take 5 $ randList" Im not too sure on this one.. To ghci!!
03:42:53 <Eduard_Munteanu> @hoogle randoms
03:42:53 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
03:43:14 <CADD> cool, cool, no IO in sight
03:43:23 <Eduard_Munteanu> What about...
03:43:29 <Eduard_Munteanu> @hoogle getStdGen
03:43:29 <lambdabot> System.Random getStdGen :: IO StdGen
03:43:30 <Jafet> You just Follow The Types (tm) and you'll be fine
03:43:57 <CADD> hmm..
03:44:22 <CADD> but i thought that is for the seed?? will that make the numbers coming out of the list IO as well??
03:45:04 <Eduard_Munteanu> No, it won't, but it means you're still trapped in IO at some level.
03:45:47 <Eduard_Munteanu> Which isn't a problem, 'main' in fact must be IO ()
03:46:14 <CADD> well, if i just "myNumList =  take 5 $ randList" and then pass in myNumList, that shouldnt be a problem right?
03:46:45 <Eduard_Munteanu> Nope.
03:46:55 <Eduard_Munteanu> I mean, right.
03:47:08 <CADD> awesome
03:47:11 <CADD> haha :)
04:14:52 <Younder> let factorial n = product [1..n]
04:15:03 <mrcarrot> could anyone recommend a really good tutorial with exercises. i could probably find good tutorials and exercises separatly, but having them together is good as you get to practice on exactly what you read
04:15:23 <Younder> @let factorial n = product [1..n]
04:15:24 <lambdabot>  Defined.
04:15:43 <Younder> @length show (factorial 50)
04:15:43 <lambdabot> Unknown command, try @list
04:16:20 <Younder> mrcarrot, http://learnyouahaskell.com/
04:17:14 <CADD> AHH!! so close...
04:17:26 <CADD> so what I have so far..
04:17:52 <CADD> getRandomIndex lengthOfList = let seed <- newStdGen
04:18:17 <mauke> syntax errrrrr
04:18:29 <mauke> s/let/do/
04:18:40 <sipa> CADD: the <- notation is syntactic sugar, only defined within a do block
04:18:49 <CADD> hmm
04:18:53 <sipa> let can be confusing since it's used in two different ways
04:18:55 <Younder> mrcarrot, 'Real world Haskell' for more advanced stuff.
04:19:54 <CADD> ok, i put it in a now its asking fo an expression after it, and i do have one
04:20:10 <sipa> CADD: paste your full code somewhere (not here) ?
04:20:13 <mauke> but do you have ... syntax?
04:20:42 <CADD> (!!) 0 (take 1 ( randomRs (0, lengthOfList) seed))
04:20:52 <CADD> is the next line after that
04:20:57 <mauke> that's a type error
04:21:03 <mauke> :t randomRs
04:21:04 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
04:21:14 <kniu> ghc has been compiling for an hour now
04:21:23 <mauke> CADD: (!!) takes a list first and an index second
04:21:30 <mauke> CADD: (!! 0) better written as head
04:21:34 <mauke> head . take 1 == head
04:22:10 <CADD> alrighty, good stuff
04:22:42 <Younder> Incidentally why wouldn’t lambdabot accept @length show (factorial 50) ?
04:22:50 <mauke> Younder: because @length is not a command?
04:24:14 <kniu> > length $ show (factorial 50)
04:24:15 <lambdabot>   65
04:24:47 <Younder> ahh thanks
04:25:44 <CADD> gah.. still no dice..
04:25:56 <Younder> That $ seemed to have gone AWOL :)
04:26:07 <CADD> getRand lengthOfList = do seed <- newStdGen
04:26:29 <CADD> heas (randomRs (0, lengthOfList) seed)
04:26:35 <CADD> head, not heas
04:26:43 <mauke> CADD: broken indentation
04:26:58 <CADD> i have it right in the file
04:27:06 <mauke> if you don't use { }, the token after 'do' determines the base indentation of the following block
04:27:30 <CADD> but its saying that the last statement in a 'do' construct must be an expression
04:27:39 <mauke> so you don't have it right
04:27:58 <CADD> alright, so curly braces needed?
04:28:02 <mauke> no
04:28:26 <CADD> oh, ok, indentation..
04:28:52 <Younder> Provided you return (value, seed) and input the seed to you random number generator you don't need a state monad. (Probably obvious..)
04:29:51 <DRMacIver> Although the random API is dramatically less annoying if you do wrap it in a monad.
04:30:03 <CADD> im trying to grab the first value in randomRs with a new seed each time the function is called
04:30:17 <mauke> that's pretty weird
04:30:21 <mauke> why generate a new seed?
04:30:26 <DRMacIver> CADD: Haskell isn't really fond of functions that return a different value each time you call them...
04:30:28 <CADD> haha, im new to this
04:31:15 <CADD> im not passing in the seed though, thats where the do seed <- new StdGen comes in
04:31:21 <mauke> getRandomIndex xs = do { i <- randomRIO (0, length xs - 1); return (xs !! i) }
04:31:35 <mrcarrot> Younder: learnyouahaskell.com is not having any exercises bundled, as far as i know
04:31:38 <mauke> because I'm gangsta
04:31:51 <mrcarrot> Younder: do you know about any page with exercises for that tutorial
04:31:52 <CADD> haha, thanks much, ill try it out right now :D
04:33:49 <mrcarrot> Younder: thanks for "real world haskell", it is having exercises
04:36:01 <CADD> epic, haha, thaks mauke, you actually made my code even simpler
04:36:26 <CADD> aww damn, but its still an IO Integer..
04:37:21 <Eduard_Munteanu> CADD: I told you you can't get rid of IO completely ;)
04:37:32 <Eduard_Munteanu> Might as well get used to it :P
04:39:23 <CADD> haha, but im still not sure as how to use it in a way that will work inside the project... i guess ill just post my .hs on hpaste.org Im kinda lost on how to do all this monad stuff.. This is literatly the last part in my project and it has taken the longest..
04:39:38 <mauke> CADD: do you know javascript?
04:40:33 <CADD> haha, sadly, no
04:40:46 <sipa> or callback functions in C
04:40:53 <mauke> too bad
04:40:58 <CADD> i know c++, not c
04:41:07 <sipa> well, do you know callback functions? :)
04:41:18 <mauke> other languages don't force you this much to write continuation based code
04:42:27 <CADD> im not sure, i dont think so.
04:42:32 <CADD> pretty sure i dont
04:42:56 <mauke> "normal" functions: call function, get result back, do stuff with result
04:43:33 <mauke> continuation based: call function f with another function g as an argument, g gets called with f's "result", do stuff in g
04:43:48 <CADD> alright
04:43:52 <mauke> f's caller doesn't get anything back
04:44:24 <mauke> and that's mostly how >>= works
04:44:47 <mauke> and >>= is the operator that '<-' and ';' in 'do' end up calling
04:46:26 <mauke> actually, that's what I wanted to say in http://mauke.dyndns.org/stuff/haskell/how-to-io.html
04:48:37 <jonkri> i have run cabal update and installed tls and cryptohash but yet i get this error: "There are problems in package tls-0.3.2: dependency "cryptohash-0.6.2-b1feae52e36dd69b770a5e7965c19fde" doesn't exist" (tls-0.3.2). what can i do?
04:50:03 <dcoutts_> jonkri: try: cabal install cryptohash-0.6.2
04:51:01 <CADD> alright, time for my horrible code, this file is basically a mish-mash of failed attempts trying to understand monads.. http://hpaste.org/45102/yay_monads
04:51:30 <mauke> don't understand monads, understand IO
04:51:43 <CADD> working on it :)
04:51:55 <CADD> ill check out your link
04:58:25 <jonkri> dcoutts_: No packages to be installed. All the requested packages are already installed.
04:59:04 <jonkri> dcoutts_: same with "cryptohash-0.6.2-b1feae52e36dd69b770a5e7965c19fde"
04:59:26 <CADD> alright, read through your article, understand how this can be used for UI(my next step), but now so much on how it can help me with these damn random numbers...
04:59:55 <mauke> :t randomIO
04:59:56 <lambdabot> forall a. (Random a) => IO a
04:59:58 <mauke> :t randomRIO
04:59:59 <lambdabot> forall a. (Random a) => (a, a) -> IO a
05:00:18 <mauke> this is more or less equivalent to getChar except it returns random numbers, not user input
05:00:32 <jonkri> tls-0.3.2 is old...
05:01:12 <Eduard_Munteanu> CADD: start by writing a main, or something in IO.
05:01:24 <Eduard_Munteanu> Then work it out from there, calling your stuff and doing useful work.
05:02:22 <CADD> alright, I guess i am kind of working my way backwards (the imperative way) towards IO
05:02:22 <dcoutts_> jonkri: oh, sorry, I got it backwards, you need to install tls, the current tls is broken because of a missing dep.
05:02:31 <jonkri> removing tls-0.3.2 got rid of the error
05:02:44 <jonkri> ok
05:04:34 <Dae_> I'm having a dependency problem I think. The following code is not compiling: http://hpaste.org/45103/bytestring_problem
05:05:02 <dcoutts_> jonkri: oh, well if you don't need it, then that's the simpler solution :-)
05:05:04 <mauke> main has the wrong type
05:06:41 <Dae_> mauke: sorry, was too fast in writing a small example
05:08:03 <jonkri> dcoutts_: i do need it, but when i installed some 0.5.x it compiled, and now i just have to figure out which one to use... anyway, thanks :)
05:09:41 * Dae_ has once again proven that asking for help will lead you to figure out the problem 2 seconds later
05:10:11 <frerich> Dae_: http://en.wikipedia.org/wiki/Rubber_duck_debugging
05:11:08 <CADD> alright, well it looks like you cant compare two IO Ints against each other..
05:11:37 <CADD> or am i missing something?
05:11:42 <Dae_> frerich: heh, that was a new one
05:11:56 <Jafet> CADD: what kind of thing is an IO Int?
05:12:24 <jonkri> anyone know where ciphers like "cipher_AES256_SHA1" went in recent tls versions? :P
05:13:03 <jlouis> SHA1, the unsafe hash
05:13:38 <Jafet> Pot is safe
05:13:41 <jonkri> well, right now i'm happy to find _any_ cipher :)
05:14:02 <Jafet> What kind of cipher is AES256_SHA1 anyway
05:15:35 <jonkri> hmm... http://hackage.haskell.org/package/cryptocipher might be related :)
05:18:02 <osoleve> why does Haskell not use any non-null value as true?
05:18:13 * rothwell twitches
05:18:59 <Jafet> @src Bool
05:18:59 <lambdabot> data Bool = False | True deriving (Eq, Ord)
05:19:20 <Jafet> Wait, didn't we tell you yesterday that Haskell does not have this thing called "null"?
05:19:38 <osoleve> ...maybe >_>
05:20:21 <cubi> @where lyah
05:20:22 <lambdabot> http://www.learnyouahaskell.com/
05:20:24 <cubi> @ osoleve :)
05:20:26 <mm_freak> osoleve: because haskell is type-safe
05:20:36 <mm_freak> "any non-null = true" is a broken concept to start with
05:20:47 <mm_freak> and as noted, there is no "null" anyway for the same reason
05:20:55 <Jafet> It can't be broken, lisp uses it!
05:21:02 <rothwell> close friend of mine studies philosophy... refuses to believe how badly programmers have screwed up boolean logic
05:21:28 <mm_freak> please understand that haskell is not PHP, and if you try to write PHP in haskell, it won't make you happy
05:21:32 <cubi> lol
05:21:34 <Jafet> rothwell: "How many Prolog programmers does it take to screw in a lightbulb?"
05:21:48 <jonkri> Jafet: if you are curious: http://paste.pocoo.org/show/361433/
05:21:50 * rothwell waits
05:21:52 <osoleve> mm_freak: PHP makes me unhappy to start with :)
05:21:59 <Jafet> Answer: "No"
05:22:10 <mm_freak> osoleve: that's a good start into the haskell world ;)
05:22:13 <rothwell> Jafet: give me a minute...
05:22:24 * rothwell displays hourglass
05:22:37 <osoleve> uh oh, i think rothwell froze
05:22:42 <Jafet> jonkri: that makes a bit more sense
05:22:48 <mm_freak> osoleve: anyway, you couldn't express a comparison with "any non-null" in haskell
05:23:25 <rothwell> Jafet: harharhar
05:23:33 <osoleve> mm_freak: I think I understand. I'm going to keep reading and hope it clicks :3
05:24:04 <mm_freak> osoleve: it's related to types, so maybe the first thing to understand is the type system
05:38:02 <rostayob> I'm trying to use Text.JSON.Generic with a datatype like "Foo { bar :: Text }" but it doesn't work, trying to use toJSON gives "*** Exception: toJSON: not AlgRep NoRep(DataType {tycon = "Data.Text.Text", datarep = NoRep})"
05:38:41 <rostayob> maybe because Text is not an istance of JSON?
05:50:19 <hape01> m = do x <- [1,2]; y<-[10,20]; return x+y        does not work. Do you have a hint for me?
05:50:47 <mauke> yes, return x+y means (return x) + y
05:51:19 <hape01> mauke: yes
05:52:01 <hape01> mauke: how do I define m to get  [11,12,21,22]?
05:52:39 <mauke> > let m = do x <- [10,20]; y <- [1,2]; return (x + y) in m
05:52:40 <lambdabot>   [11,12,21,22]
05:52:40 <hape01> mauke: now I got it :-)
05:52:53 <hape01> mauke :thanks for helping
05:53:24 * RayNbow`TU wants to start a project in Haskell... but it seems he first has to learn some FFI first... (that, or some crypto...)
05:53:24 <lambdabot> RayNbow`TU: You have 1 new message. '/msg lambdabot @messages' to read it.
05:53:28 <RayNbow`TU> hmm
05:53:39 <hape01> mauke++
05:55:03 <RayNbow`TU> (the reason I need to learn some FFI or some crypto is because none of the functionality I need is in an existing hackage package)
05:55:26 <mauke> FFI is relatively straightforward if you know your C
05:56:45 * hackagebot reactive-banana 0.1.0.0 - Small but flexible  functional reactive programming (FRP) library.  http://hackage.haskell.org/package/reactive-banana-0.1.0.0 (HeinrichApfelmus)
05:57:38 <RayNbow`TU> I'm okay with C (I think), but I might be less confident in learning how to use the OpenSSL lib
05:57:45 * hackagebot reactive-banana-wx 0.1.0.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.1.0.0 (HeinrichApfelmus)
05:59:19 <Entroacceptor> base 4.2?
05:59:55 <RayNbow`TU> (but maybe I can learn some bits of OpenSSL by studying Python's M2Crypto package)
06:00:35 <Entroacceptor> don't try to write your own crypto library
06:01:26 <RayNbow`TU> Entroacceptor: I wasn't really on planning that... leveraging that was already done in OpenSSL seems easier *and* more secure
06:05:41 <rothwell> openssl is ... vile
06:05:55 <rothwell> think gnutls is likely less damaging to you and those around you
06:06:09 <rothwell> i dread to think what kind of horror is necessary to write bindings to openssl...
06:07:20 <RayNbow`TU> rothwell: does gnutls support NID_sect233k1? (it's an ECC curve)
06:07:21 <rtharper_> rothwell: what's vile about it?
06:07:35 <rothwell> RayNbow`TU: don't know
06:07:42 <rothwell> rtharper_: the API and the implementation
06:07:50 <rtharper_> lol so everything?
06:07:54 <rothwell>  \o/
06:09:32 <rothwell> rtharper_: for the full experience, you really have to try doing any simple crypto with it
06:09:45 <rothwell> rtharper_: but one of the openssl developers did a good writeup: http://www.peereboom.us/assl/assl/html/openssl.html
06:10:19 <rothwell> his experience pretty much mirrors the experience i have every time i'm forced to work with it
06:10:20 <rtharper_> rothwell: is it one of those situations where the twisted logic makes sense once you immerse yourself in it and loose objectivity?
06:10:23 <rtharper_> or is it always bad?
06:10:53 <rothwell> rtharper_: it makes the win32 api look clean
06:11:23 * mux seconds rothwell 
06:11:32 <mux> also, the implementation makes brainfuck code look intuitive
06:11:33 <rtharper_> rothwell: oh deer
06:11:49 <rothwell> i can't stand it... i'll take just about any other ssl/tls library
06:12:08 <copumpkin> rtharper_: I kind of miss the unpronounceable name!
06:12:21 <RayNbow`TU> hmm... Peereboom... looks like a Dutch surname
06:12:21 <rtharper_> haha I can always go back =)
06:12:26 <rtharper_> or come up with a new one
06:12:48 <rtharper_> I would have made it worse with something like an_tsioraiocht 
06:12:56 <rtharper_> *could have
06:13:10 <rtharper_> but that changes the meaning from "eternity" to "the afterlife", lol
06:13:12 <copumpkin> :O
06:13:25 <copumpkin> CAOILFHIONN
06:14:16 <rothwell> RayNbow`TU: doesn't support any kind of ECC, as far as i can tell
06:14:25 <rothwell> disappointing
06:16:16 <RayNbow`TU> rothwell: perhaps I should just FFI to Python's M2Crypto, which in its turn FFIs into OpenSSL! :p
06:16:51 <sipa> @pl \n -> unMemoStateT m n >>= \r -> unMemoStateT (f r) n
06:16:51 <lambdabot> ap ((>>=) . unMemoStateT m) (flip (unMemoStateT . f))
06:17:32 <rothwell> RayNbow`TU: ow
07:20:05 <dino-> hackage down, or having problems?
07:20:17 <kowey> hi all, I'm thinking of moving some Haskell code from GPL to LGPL. Do I understand correctly that I need to add a static linking exception to make this effective?
07:25:01 <aristid> dino-: seems like it. i was thinking it might be my ever shaky internet connection, but if you also have problems...
07:25:43 <dino-> aristid: Seems back now.
07:27:41 <aristid> dino-: hmm, but Recent Additions is missing packages
07:34:41 * hackagebot http-types 0.6.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.1 (AristidBreitkreuz)
07:34:43 * hackagebot aivika 0.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.1 (DavidSorokin)
07:43:03 <Saizan> http://apfelmus.nfshost.com/blog/2011/03/28-essence-frp.html <- i feel enlightened
07:44:45 <djahandarie> Oooh nice
07:46:29 <frerich> Oh, if that example of FRP using the counter is accurate, it finally made click for me.
07:51:35 <djahandarie> He should have explained accumulate there
07:51:42 <frerich> Hm, in fact, the whole blog looks ver nice
07:51:45 * frerich bookmarks
07:51:54 <djahandarie> Yeah apfelmus has a nice blog
07:55:33 --- mode: ChanServ set +o copumpkin
07:55:55 <norm2782> too bad his library doesn't seem to want to compile on HP 2011
07:56:15 <norm2782> not straight from hackage anyway
08:03:11 <ManateeLazyCat> I found ghc-7.0.3 release, looks i need upgrade again.
08:03:18 <aristid> \o/ nearlyfreespeech supports haskell (nfshost.com, which apfelmus uses, is nearlyfreespeech)
08:03:22 <aristid> sadly, only ghc 6.8.3
08:04:12 <thoughtpolice> they're quite receptive to feedback IMO, I used to use nearlyfreespeech
08:04:20 <ManateeLazyCat> Look http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/release-7-0-3.html , many problem just about OS-X
08:04:25 <thoughtpolice> you can probably file a support ticket for a more recent GHC install
08:04:27 <ManateeLazyCat> And x86
08:04:43 <norm2782> GHC 7.0.3 broke wxHaskell for me on OS X
08:04:49 <thoughtpolice> although i think their systems run freebsd, so it's whatever is in the freebsd ports tree (which is 6.12, iirc)
08:04:51 <ManateeLazyCat> Hmm, no need upgrade, since i use linux and x86-64
08:05:02 <norm2782> so you might want to hold off on upgrading if you're using that
08:05:17 <joe6> > :t combinations
08:05:18 <lambdabot>   <no location info>: parse error on input `:'
08:05:23 <joe6> > combinations
08:05:24 <lambdabot>   Not in scope: `combinations'
08:05:32 <thoughtpolice> well, there was a pretty bad floating point bug fixed in 7.0.3 it looks like
08:05:35 <joe6> :t combinations
08:05:36 <lambdabot> Not in scope: `combinations'
08:06:23 <azaq23> > subsequences [1, 2, 3]
08:06:24 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
08:09:03 <copumpkin> subsequences always seemed like the wrong name for that
08:09:05 <copumpkin> to me
08:09:44 <Jafet> It is the correct name
08:09:52 <copumpkin> yessir
08:10:09 <Jafet> Unless you're saying you don't like stuffy linguists calling it "subsequences"
08:10:35 <copumpkin> no, I'm saying that I think subsequences should be something like contiguous sublists of it
08:10:43 <copumpkin> and that is closer to being subsets, on lists
08:10:46 * hackagebot improve 0.3.0 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.3.0 (TomHawkins)
08:10:59 <copumpkin> except it's submultisets
08:11:35 <tromp__> @src subsequences
08:11:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:12:08 <Jafet> That's called substrings, not subsequencees
08:12:20 <Jafet> And [a] is not Set a, so it can't be called subsets either
08:12:38 <Jafet> So yeah, stuffy linguists
08:12:39 <copumpkin> [a] is not Sequence a, so it can't be called subsequences ;)
08:13:08 <Jafet> subSequences
08:13:25 <copumpkin> anyway, seems like wikipedia agrees with you
08:13:32 <copumpkin> still, seems dumb
08:14:26 <tromp__> (sub/super)(string/sequence) seems pretty clear. what would you prefer?
08:15:03 <mux> powerset?
08:15:07 <copumpkin> I don't see a fundamental difference between string and sequence, and I'm not sure one of them should be contiguous subunits and the other shouldn't
08:16:11 <copumpkin> "In computer science, string is often used as a synonym for sequence, but it is important to note that substring and subsequence are not synonyms. Substrings are consecutive parts of a string, while subsequences need not be. This means that a substring of a string is always a subsequence of the string, but a subsequence of a string is not always a substring of the string.[1]"
08:16:23 <copumpkin> just seems dumb and inconsistent
08:16:35 <mux> I seem to remember some scientific papers using sequences to denote finite lists
08:16:56 <Jafet> It's consistent, but a bit arbitrary
08:17:10 <Jafet> Wait a minute
08:17:22 <Jafet> Not sure about the synonym bit
08:17:23 * copumpkin waits a minute
08:17:36 <Jafet> > threadDelay 60000000
08:17:37 <lambdabot>   Not in scope: `threadDelay'
08:18:26 <aristid> :t inits <=< tails
08:18:26 <lambdabot> forall a. [a] -> [[a]]
08:18:35 <aristid> > (inits <=< tails) [1,2,3,4]
08:18:36 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[],[2],[2,3],[2,3,4],[],[3],[3,4],[],[4],[]]
08:18:52 <aristid> > (tail . inits <=< tails) [1,2,3,4]
08:18:54 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[2],[2,3],[2,3,4],[3],[3,4],[4]]
08:19:02 <copumpkin> that's the wrong order
08:19:06 <copumpkin> :P
08:19:09 <aristid> copumpkin: :P
08:19:10 <copumpkin> I prefer the other one
08:19:12 <Jafet> subsequences has a very nice lazy order
08:19:19 <copumpkin> if you flip inits and tails there
08:19:20 <aristid> > (tails <=< tail . inits) [1,2,3,4]
08:19:21 <lambdabot>   [[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[]]
08:19:24 <copumpkin> you get a nice lazy one too
08:19:28 <Jafet> The code is relatively terrible though
08:19:30 <copumpkin> not like that
08:19:34 <aristid> > (init . tails <=< inits) [1,2,3,4]
08:19:35 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4]]
08:19:40 <copumpkin> yeah
08:19:44 <copumpkin> that'll work nicely on infinite lists
08:19:47 <Jafet> That one's also ok
08:19:49 <aristid> the init is probably expensive :(
08:19:58 <aristid> > (init . tails <=< inits) [1..]
08:19:58 <copumpkin> not really
08:19:59 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
08:20:09 <aristid> copumpkin: why not? :)
08:20:16 <copumpkin> you're traversing the list anyway
08:20:46 <aristid> > tails [1,2,3,4]
08:20:47 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
08:21:03 <dmwit> copumpkin: Your ops are showing.
08:21:06 <Jafet> The inits is probably more expensive
08:21:10 <dmwit> (In case you'd forgotten.)
08:21:25 <copumpkin> dmwit: oh, it was a precaution cause #freenode was getting spammed like crazy
08:21:29 --- mode: copumpkin set -o copumpkin
08:21:31 <dmwit> right on
08:21:38 <copumpkin> yeah, inits is bad
08:22:12 <aristid> hmm.
08:22:27 <aristid> copumpkin: well, make a better substrings function! :)
08:22:31 <copumpkin> hah
08:22:36 <aristid> i challenge you :>
08:22:42 <copumpkin> can't really do it any more efficiently than inits is doing it
08:22:52 <copumpkin> if you have a flat array you can do it efficiently
08:23:06 <copumpkin> since you can avoid copying all the data and just use offsets into it with lengths
08:23:54 <quicksilver> optimal is just to make sure you only call inits once
08:23:59 <quicksilver> so that all that can be shared, is shared.
08:24:09 <copumpkin> fair enough
08:24:15 <quicksilver> so call tails on inits, not inits on tails.
08:24:23 <copumpkin> quicksilver: except that doesn't work for infinite lists
08:24:41 <quicksilver> > inits [1..]
08:24:42 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
08:24:43 <aristid> quicksilver: i only call inits once, so that's the case
08:24:48 <quicksilver> copumpkin: why not?
08:24:51 <quicksilver> aristid: yes, agreed.
08:24:52 <copumpkin> quicksilver: I mean in the compound 
08:26:02 <dmwit> > tails []
08:26:02 <lambdabot>   [[]]
08:26:08 <dmwit> Yes, of course.
08:26:14 <dmwit> I must need a bit more sleep.
08:26:28 <quicksilver> > iterate tails []
08:26:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:26:41 <quicksilver> type system too weak, please buy nother.
08:29:58 <manateeUser> Hello. :)
08:32:25 <manateeUser> Haha, use Manatee compile itself. :) http://www.flickr.com/photos/48809572@N02/5568421492/lightbox/
08:38:04 <aristid> @src tails
08:38:04 <lambdabot> tails []         = [[]]
08:38:04 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
08:38:43 * edwardk beats the bushes looking for summer of code mentors.
08:39:28 <edwardk> You, yes, you! I know you want to be a summer of code mentor this year. =)
08:40:07 <djahandarie> My friend was a summer of code mentor before he could actually participate in it
08:40:29 <edwardk> shapr was too
08:40:36 <djahandarie> Heh, really?
08:40:40 <djahandarie> Oh
08:40:41 <aristid> @index CReal
08:40:41 <lambdabot> bzzt
08:40:41 <djahandarie> Wait --
08:40:46 <aristid> @hoogle CReal
08:40:46 <lambdabot> No results found
08:40:54 <djahandarie> That was not due to age though, right? :p
08:41:02 <edwardk> due to not having been a student
08:41:06 <djahandarie> Yeah
08:41:07 <edwardk> well not being one
08:41:19 <edwardk> now he has gone back and started collecting bits of academic paper
08:41:37 <edwardk> so i need to tease him into applying as a student to an org he once mentored
08:41:46 <djahandarie> I'm thinking of Dark_Shikari who mentored for videolan/x264 when he was like 17
08:41:59 <edwardk> fair nuff
08:42:15 <djahandarie> I need to somehow convince him to stay in this channel
08:42:22 <djahandarie> He only pops in when he has questions then leaves :p
08:42:41 <gwern> rational behavior
08:42:50 <edwardk> i originally tried that, then cale hooked me on haskell code golf.
08:42:59 <gwern> free riding is the optimizing thing to do on a commons like this
08:43:01 <edwardk> it was all downhill from there
08:43:20 <djahandarie> gwern, I don't even have any Haskell questions unless I idle in here though
08:43:27 <jmcarthur> shapr has mentioned doing summer code this year, although i've already forgotten his ideas
08:43:34 <edwardk> sweet =)
08:43:41 <jmcarthur> *summer of code
08:43:43 <Cale> edwardk: what? :)
08:43:51 <djahandarie> edwardk, so you were code golfing one day and somehow ended up with category-extras as the result?
08:43:54 <edwardk> jake: you should sign up as his mentor ;)
08:43:57 <djahandarie> Everything suddenly makes sense...
08:43:59 <jmcarthur> haha
08:44:11 <beastaugh> wish I had time to do gsoc
08:44:21 <edwardk> djahandarie: more or less. that started out from a conversation with dolio on how to better encode the recursion schemes from menendez's version of category-extras
08:44:23 <beastaugh> unfortunately I need to spend my summer writing my dissertation
08:44:30 <jmcarthur> edwardk: i would probably be moving and starting a new job right in the middle of it though
08:44:47 <edwardk> 5 hours a week, you can do it! =)
08:45:07 <quicksilver> you probably spend 5 hours a week eating, anyway.
08:45:11 <quicksilver> mentor with your mouth full
08:45:15 <quicksilver> on the internet, no one can tell!
08:45:16 <jmcarthur> haha
08:45:28 <jmcarthur> quicksilver: shapr is local to me
08:45:31 <beastaugh> is that all it takes?
08:45:34 <quicksilver> possibly buy a cheap replacement keyboard.
08:45:47 <quicksilver> jmcarthur: adopt a psuedonym, he'll never know.
08:45:48 <edwardk> beastaugh: And preferably a good understanding of the problem domain.
08:46:04 <edwardk> it doesn't hurt to sign up, then vote on the proposals, and see if you want to mentor any of them
08:46:05 <jmcarthur> heh
08:46:12 <beastaugh> edwardk: that's more likely to be a difficulty for me :)
08:46:13 <ManateeLazyCat> Rest 10 mintues to write haskell code, bye all, good night. :)
08:46:37 <edwardk> heya dolio
08:46:54 <dolio> Yo.
08:46:56 <edwardk> btw- i haven't seen you since. congratulations ;)
08:47:06 <djahandarie> Manatee still talks in Chinese proverbs
08:47:07 <dolio> Oh, yeah, thanks.
08:48:30 <accel> djahandarie: as in it's incomprehensible?
08:51:59 <accel> in haskell, on osx
08:52:03 <accel> how do I open a window that ahs no border
08:52:05 <accel> and is always on top?
09:06:48 <aristid> @djinn (a -> a) -> a
09:06:48 <lambdabot> -- f cannot be realized.
09:06:54 <aristid> lambdabot: it can :)
09:07:33 <ion> :t const
09:07:34 <lambdabot> forall a b. a -> b -> a
09:07:41 <djahandarie> :t fix
09:07:42 <lambdabot> forall a. (a -> a) -> a
09:07:42 <ion> whoops
09:07:45 <djahandarie> :p
09:08:19 <hpc> i don't think djinn does recursion :P
09:08:24 <djahandarie> It doesn't.
09:09:10 <quicksilver> it wouldn't be interesting if it did.
09:09:24 <quicksilver> the logic with fix is inconsistent, you can prove everything.
09:09:44 <djahandarie> What? Not everything?
09:09:54 <ezyang> :t (fix id) 
09:09:54 <lambdabot> forall a. a
09:09:59 <quicksilver> yes, everything.
09:10:07 <jmcarthur> :t fix :: a -> b
09:10:07 <lambdabot>     Couldn't match expected type `a' against inferred type `b -> b'
09:10:07 <lambdabot>       `a' is a rigid type variable bound by
09:10:07 <lambdabot>           an expression type signature at <interactive>:1:7
09:10:11 <djahandarie> Ah
09:10:17 <jmcarthur> woop duh
09:10:27 <djahandarie> :t (fix id) :: a -> b
09:10:27 <Matt`> Guys: I'm looking for a haskell library for linear temporal logic (LTL). Any idea where I could find one?
09:10:27 <lambdabot> forall a b. a -> b
09:10:31 <jmcarthur> :t let x = x :: a -> b
09:10:32 <lambdabot> <no location info>: not an expression: `let x = x :: a -> b'
09:10:32 <quicksilver> (_|_ -> _|_) -> _|_
09:10:38 <jmcarthur> :t let x = x in x :: a -> b
09:10:39 <lambdabot> forall a b. a -> b
09:10:42 <quicksilver> there for you can prove _|_ therefore you can prove everything.
09:10:42 <jmcarthur> finally, good grief
09:10:45 <Saizan> it could do induction only though :)
09:11:48 <ezyang> This is why languages like Agda have termination checkers. 
09:13:07 <monochrom> this is why I don't use the curry-howard isomorphism
09:13:21 <hpc> this is why i love #haskell
09:13:27 <monochrom> haha
09:13:42 <djahandarie> This is why we can't have nice things
09:14:07 <hpc> but yeah, the curry-howard isomorphism isn't that useful in haskell
09:14:25 <hpc> it always seemed like a non-sequitur of a wikibook chapter
09:16:05 <Saizan> it's been quite relevant for my understanding of Cont and higher-rank types
09:16:05 <djahandarie> Would it be possible to write a verison of fix that requires things to get 'smaller' like Agda's termination checker requires?
09:16:48 <hpc> wouldn't it not be fix anymore?
09:16:52 <Saizan> you can use cata instead :)
09:16:57 <ezyang> djahandarie: Prolly, but it might be painful because GHC Haskell is not dependently typed. 
09:16:58 <hpc> :t foldr
09:16:59 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:17:17 <monochrom> you need dependent types for that
09:17:31 <djahandarie> So it would be possible to do this in Agda
09:17:31 <hpc> monochrom: for cata?
09:17:37 <monochrom> for "smaller"
09:17:40 <hpc> ah
09:21:29 <monochrom> I once ~ was lost ~ but now ~ well-founded ~
09:21:39 <monochrom> was loop ~ but now ~ I quit
09:22:26 <edwardk> djahandarie: you can do it, but you need some kind of type level shrinking index.
09:23:00 <longh_> Hi, I thought a mapAccumL for enumerators would be nice, any comments on following piece of code? http://hpaste.org/45107/a_mapaccuml_for_enumerator
09:23:28 <edwardk> djahandarie: look at ind in http://hackage.haskell.org/packages/archive/representable-tries/0.3.1.2/doc/html/Numeric-Nat-Zeroless.html
09:24:29 <edwardk> what you'd want for natural numbers is something like: ind :: Nat n => f Z -> (forall m. Nat m => f m -> f (S m)) -> f n
09:29:09 <djahandarie> edwardk, makes sense
09:30:29 <djahandarie> {P : Nat -> Set} -> P 0 -> (forall m -> P m -> P (s m)) -> (n : Nat) -> P n  -- in Agda
09:30:33 <djahandarie> I think
09:30:33 <edwardk> preflex: xseen heffalump
09:30:34 <preflex>  heffalump was last seen on freenode/#haskell 1 day, 16 hours, 53 minutes and 2 seconds ago, saying: jmcarthur: is the small business's name public?
09:30:47 <copumpkin> djahandarie: I wrote that a while back in haskell
09:30:56 <copumpkin> in fact, I think it's even in ryan ingram's email
09:31:10 <djahandarie> Hmmm
09:31:15 <copumpkin> http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html
09:31:20 <gwern> amazing `catch` (how sweet the type), that saved an exception like me! I once was thrown, but now am caught; was impure, but now pure be
09:31:21 <copumpkin> > induction :: forall p n. Nat n => n -> p Z -> (forall x. Nat x => p x -> p (S x)) -> p n
09:31:21 <lambdabot>   Not in scope: type constructor or class `Nat'Not in scope: type constructor...
09:31:27 <djahandarie> Could we make the guarentees of this stronger?
09:31:42 <copumpkin> what else do you want to guarantee?
09:31:49 <djahandarie> I don't know the name
09:31:53 <djahandarie> Hold on
09:33:37 <djahandarie> {P : Nat -> Set} -> P 0 -> (forall x -> (forall m -> m < x -> P m) -> P x) -> (x : Nat) -> P x
09:33:42 <djahandarie> Oh, wait
09:33:46 <djahandarie> {P : Nat -> Set} -> (forall x -> (forall m -> m < x -> P m) -> P x) -> (x : Nat) -> P x
09:33:53 <djahandarie> Erm
09:33:57 <djahandarie> I don't know if I did this right :p
09:34:57 <copumpkin> oh, that thing
09:35:17 <copumpkin> there's a less than or equal to typeclass
09:35:18 <djahandarie> Does it have a name?
09:35:29 <copumpkin> "strong induction"?
09:35:30 <copumpkin> I dunno
09:35:38 <dolio> Well-founded induction.
09:35:38 <djahandarie> lol okay
09:35:50 <djahandarie> Well I need to go before I'm late to class
09:35:52 <djahandarie> Thanks
09:45:25 <monochrom> @remember gwern amazing `catch` (how sweet the type), that saved an exception like me! I once was thrown, but now am caught; was impure, but now pure be
09:45:25 <lambdabot> Done.
09:48:36 <lpsmith> too bad gwern missed the poetry and fiction edition of the Monad Reader :)
09:48:59 <lpsmith> And I hate global variables
09:49:03 <lpsmith> I mean, I really hate them
09:49:11 <lpsmith> well, most of the time anyway :-P
09:50:18 <lpsmith> I still wish that GHC had a sane and robust way of dealing with top-level state
09:52:22 <Guest29597> Hi
09:52:47 <Guest29597> Is it possible that n+k patterns were removed in the newest haskell platform?
09:53:23 <Cale> Yes, it's possible
09:53:32 <Cale> I haven't checked.
09:53:48 <hpc> it's been deprecated for a while, iirc
09:53:51 <Cale> They are deprecated.
09:53:54 <Cale> yeah
09:54:01 <Guest29597> But not disabled?
09:54:04 <hpc> latest platform uses GHC 7, so that could be it
09:54:57 <Guest29597> Well I tried the following example:
09:54:58 <Guest29597> f (n+1) = n
09:54:59 <Cale> I still don't have GHC 7, but you might look through the output of  ghc --supported-languages   to see if there's a LANGUAGE pragma you could use to get support for them back.
09:55:19 <Guest29597> f 0 = 0
09:55:23 <hpc> might i suggest not using those patterns?
09:56:03 <Guest29597> No, i like them
09:56:10 <Cale> Also, that's a questionable order to put your definitions in. I forget if (n+k) patterns only match positive integers or not.
09:56:15 <edwardk> Guest29597: n+k was removed from the language in haskell 2010
09:56:27 <edwardk> Guest29597: perhaps the latest platform changed the default language to that?
09:56:58 <hpc> > let f (-5) = 0; f (n+1) = n in f 0
09:56:59 <lambdabot>   <no location info>: Parse error in pattern
09:57:02 <c_wraith> edwardk: That's not the default.  You need to enable it via -XHaskell2010 or the equivalent language pragma
09:57:28 <edwardk> c_wraith: wasn't sure hence why 'perhaps' =)
09:58:25 <Guest29597> I didn't set any flags and i get the same output from GHCi
09:59:08 <edwardk> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/syntax-extns.html says in section 7.3.7 that n+k patterns are still supported by default
09:59:11 <Younder> c_wraith,  do you have a web cite describing the features of Haskell 2010?
09:59:16 <Cale> {-# LANGUAGE NPlusKPatterns #-}
09:59:19 <Guest29597> Saw that, thx
09:59:21 <Cale> ^^ add that line to the top of your file
09:59:28 <Cale> and see if it helps
09:59:37 <Guest29597> Yes, it works with that, thanks!
10:02:28 <Younder> never mind.. http://www.haskell.org/onlinereport/haskell2010/
10:03:06 <herzen> hello, I've been trying to build a 7.x version of ghc on Solaris, and to do that, I've had to use a recent checkout from darcs HEAD. but it seems that some packages have not yet caught up with it.
10:03:54 <herzen> for example, xmonad builds, but I ran into a proble m with xmonad-contrib:
10:04:01 <herzen>     Ambiguous module name `Prelude':
10:04:01 <herzen>       it was found in multiple packages: base haskell98-1.1.0.0
10:04:13 <manateeUser> Haha, works! :)
10:04:25 <Yrogirg> Hello! How do I put ghc options into the file I want to compile?
10:05:11 <manateeUser> Yrogirg: Add ghc-options: your-options in .cabal file if you use cabal compile your project.
10:05:27 <kosmikus> Yrogirg: which option?
10:05:41 <herzen> Googling suggested that I should remove haskell98 as a dependency from X11-xft (the build of which was producing the above error), but when I did that, I got this:
10:05:49 <Yrogirg> -XTypeSynonymInstances
10:06:04 <herzen>     Could not find module `Monad'
10:06:04 <herzen>     It is a member of the hidden package `haskell98-1.1.0.0'.
10:06:18 <Cale> Yrogirg: {-# LANGUAGE TypeSynonymInstances #-}
10:06:24 <manateeUser> Wonderful 10 mintues, need sleep now. Bye all. :)
10:06:25 <Cale> Yrogirg: at the top of the file
10:06:37 <hpc> manateeUser: that's a pretty long 10 minutes
10:06:44 <kosmikus> Yrogirg: right, for -X use the LANGUAGE pragma as Cale said
10:07:04 <herzen> So how do I get X11-xft to know about module Monad, without having haskell-98 in build-depends in the cabal file?
10:07:10 <manateeUser> hpc: 10 minutes plan, then i use one hour modified haskell code. :)
10:07:31 <manateeUser> hpc: Good night, i have work tomorrow. :)
10:07:34 <manateeUser> Bye all. :) 
10:07:39 <Cale> herzen: That module exists in the haskell-98 package. You could switch it to the more modern Control.Monad
10:07:41 * hackagebot nehe-tuts 0.2.1 - Port of the NeHe OpenGL tutorials to Haskell.  http://hackage.haskell.org/package/nehe-tuts-0.2.1 (JasonDagit)
10:08:05 <hpc> s/could/should/ ?
10:08:12 <Yrogirg> ok, thank you guys
10:08:32 <herzen> Cale: thanks. I'll try substituting Control.Monad for haskell98 in X11-xft's cabal file.
10:08:54 * hpc wonders how old X11-xft is
10:09:01 <Saizan> herzen: no
10:09:23 <Saizan> herzen: you've to change "import Monad" into "import Control.Monad" in the source files
10:09:52 <Cale> herzen: Yeah, listen to Saizan. Control.Monad is a module in the base package.
10:09:53 <herzen> I can't just modify X11-xft.cabal?
10:10:16 <Cale> herzen: Not unless you want to add haskell-98 to get support for the old Monad module.
10:10:35 <herzen> Cale: X11-xft.cabal lists "base" in build-depends.
10:10:42 <Saizan> and then base's Prelude and haskell98's Prelude would conflict
10:10:52 <Cale> herzen: Right, so the Control.Monad module will be accessible
10:10:54 <herzen> yes, that was the original problem.
10:10:55 <Saizan> so there's no solution to this by only touching the .cabal
10:11:00 <Cale> herzen: But Monad won't be.
10:11:23 <herzen> ah, OK. thanks all.
10:12:16 <Younder> Is it true Americains don't have  diacritics on their keymaps?
10:12:27 <Cale> That's true
10:12:27 <hpc> Younder: yes
10:12:50 <Cale> Though people using X can bind a Compose key pretty easily.
10:12:57 <hpc> though there's plenty of us who have extra keyboards, like Î³ÏÎµÎµÎº :P
10:13:07 <hpc> *keymaps
10:13:14 <Cale> That too :)
10:13:20 <Cale> Î±Î²Î³Î´Îµ
10:13:50 <Cale> æ—¥æœ¬èªž
10:13:54 <homie> Îµ 
10:14:00 <rothwell> Î»!
10:14:03 <hpc> Ã˜
10:14:17 <hpc> i can't type most of my math keymap into putty :(
10:14:19 <homie> âˆ¬ Ï†Ï 
10:14:20 <Cale> âˆ«
10:14:27 <Younder> Now you are moving into page 4 of Unicode extensions.
10:14:28 <Cale> âˆ‚
10:14:41 <rothwell> â˜ƒ
10:14:49 <rothwell> alright, i didn't really type that one
10:14:53 <homie> lim âˆš x -> âˆž 
10:15:10 <hpc> â„µâˆ€âˆƒâˆˆdâˆ‚âˆ«âˆžâ„¦âˆ…â†â†’â‡â‡’â†”â‡”
10:15:11 <Cale> à®‡
10:15:24 <Younder> Yes,  yes I use that with MathML..
10:15:34 <Cale> ð‡
10:15:44 <Younder> oops ;)
10:15:45 <hpc> i should really make that tex keymap i always planned on
10:15:46 <Cale> (okay, I don't have keymaps for that :)
10:16:27 <Cale> ðƒŒ -- LINEAR B IDEOGRAM B240 WHEELED CHARIOT FTW
10:17:02 * Cale wonders if anyone else even has font support for that :P
10:17:13 <hpc> not here, using Droid
10:17:34 <Younder> Working on integrating MathML and WebKit to a interface to Formula. (A language I am working on)
10:17:52 <hpc> wait, wtf
10:17:57 <Cale> If you're using FreeType, just having a font on your system with the given character is sufficient for it to always be visible.
10:18:23 <hpc> i can type Ã˜ into putty, but i can also paste it, and the character looks differnet
10:18:39 <Cale> But I don't think you'd have a font with Linear B coverage unless you went looking for one online.
10:18:42 <hpc> nah, im on windows
10:18:51 <Cale> ah
10:19:17 <hpc> Droid fits remarkably well with the aero window decorations
10:19:28 <Younder> But I set here with a Norwegian keyboard and have just discovered that a couple of my keymaps only work on a western European keyboard..
10:19:31 <Cale> I don't know why Windows sucks so much about that. It seems like such an obvious idea to steal characters from other fonts if the one you're using doesn't have a glyph for the character in question.
10:19:45 <Younder> s/set/sit/
10:19:52 <hpc> Cale: it could be a correctness concern; which font do you steal from?
10:20:03 <Cale> hpc: anything is better than nothing
10:20:12 <Cale> hpc: But generally something with similar metadata
10:20:26 <Zao> Cale: You say "Windows" as if there were only a single text rendering framework on it.
10:20:31 <hpc> Cale: as long as it doesn't shove comic sans down my throat...
10:20:36 <Zao> Cale: You've got Uniscribe, GDI, DirectWrite, etc.
10:20:41 <Zao> Cale: Some have font linking, some don't.
10:20:59 <Zao> See Michael Kaplan on all the icky details :)
10:21:26 <Younder> There is no font that supports the full range of Unicode characters. Perhaps there should be one so you could display a reasonable default?
10:21:34 <hpc> actually, i think i am doing font linking, here
10:21:51 <Cale> Younder: I wish that the Unicode reference font could be made available.
10:21:53 <hpc> most of the unicode up above is subtly different from Droid style
10:22:14 <lispy> Cale: have you guys at ipwn made any bindings you guys can open source?  I'd like a binding to freetype2 and glew (currently trying to write themselves, but I like to reuse :)
10:22:16 <hpc> Cale: there's a reference font? no fair!
10:22:24 <c_wraith> Cale: there are issues with overloaded codepoints.  For instance, Chinese and Japanese have different glyphs for the same codepoint.
10:22:33 <c_wraith> ...  In some cases
10:22:36 <Cale> lispy: I don't think we use either of those libraries
10:22:56 <Cale> hpc: There are reference glyphs in the standard.
10:23:07 <lispy> Cale: Okay.  Bummer  :)  Well, I'll just go back to my plan of writing them.
10:23:07 <Cale> hpc: But most of them are copyrighted.
10:23:47 <herzen> Saizan, Cale: that did the trick. X11-xft and xmonad-contrib built. first time I asked for help here, btw. :-)
10:23:56 <herzen> somebody should update Xft.hsc.
10:24:07 <Cale> herzen: Feel free to ask any questions you might have.
10:24:22 <herzen> yes, I will.
10:30:52 * hackagebot unbounded-delays 0.1 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1 (BasVanDijk)
10:31:13 <Cin> tibbe: You've got a mug like this right? http://technotip.org/wp-content/uploads/google/mug.jpg
10:31:38 <Cin> tibbe: Where do I get one? The Google merch store only has â€˜normalâ€™-shaped mugs.
10:32:31 <Younder> It's strikes me as ironic that the creators of Google coudn't spell..
10:33:15 <jcreigh> Younder: You mean why isn't the company named "Googol"?
10:33:33 <Younder> And.. That the spelling mistake stuck!
10:33:38 <Cin> Pretty sure it was intentional and the â€˜misspellingâ€™ is a myth.
10:33:55 <jcreigh> yeah, might've been for trademark purposes.
10:34:12 <jcreigh> (or service mark or whatever it would be)
10:34:20 <tibbe> Cin: I don't actually!
10:34:28 <tibbe> Cin: never seen that one before
10:34:36 <tibbe> Cin: we have a different shape in the office
10:34:38 <Cin> tibbe: Oh. :-( I thought I saw one of a similar shape on your desk at Zurihac.
10:34:48 <Cin> tibbe: A shape that I can get my hands on? :-P
10:35:38 <Younder> Well the name googol came from a mathematician asking his infant daughter what to call hist greatest number ;)
10:35:45 <tibbe> Cin: I don't think they're for sale
10:35:58 * Cin shakes fist
10:36:22 <Cin> tibbe: Fair enough. /me interviews for Google with the sole purpose of getting a mug
10:36:36 <silver> that's nice
10:36:49 <tibbe> Cin: a good reason as any
10:41:21 <edwardk> woot. bas uploaded a version of concurrent-extras without all the cruft
10:43:43 <herzen> now I'm trying to build darcs, and I'm getting the following error in ShellHarness.hs:
10:43:47 <herzen>     Could not find module `System'
10:43:47 <herzen>     It is a member of the hidden package `haskell98-1.1.0.0'.
10:43:56 <herzen> Has "System" been renamed?
10:44:13 <Zao> I'm getting a slew of http://paste.pocoo.org/show/361639/ when building GHC.
10:44:16 * benmachine wonders how long haskell98 has been hidden
10:44:18 <silver> hmm
10:44:21 <Zao> Are those anything I should do anything about, or are they benign?
10:44:29 <silver> herzen, ghc version? darcs version?
10:44:47 <benmachine> Zao: I see them a lot, it doesn't break the build
10:44:57 <herzen> darcs-2.5.223567, ghc 7.1.
10:46:07 <herzen> ghc 7.0 doesn't build on Solaris.
10:46:55 <Skola> what datatype do I use for matrixes?
10:46:56 <silver> oh, don't know then, works fine on gentoo with ghc 7.0.2 and darcs 2.5.2, but may be gentoo have some extra patches to allow that to happen
10:47:01 <Skola> or to emulate those, w/e
10:47:38 <herzen> I think 7.1 may have gone further along in moving away from haskell98.
10:47:51 <benmachine> Skola: there are some matrix libraries out there that you can use
10:48:02 <benmachine> Skola: or you could just use arrays, depending on what you want to do with them
10:48:14 <Skola> ok
10:49:03 <edwardk> heya tibbe
10:49:11 <Apocalisp> IO seems to make less use of the type system than one would expect.
10:49:35 <Apocalisp> for example, I can open a Handle for reading and then proceed to write to it.
10:49:36 <silver> is there changes list for 7.1?
10:49:37 <edwardk> tibbe: kowey pointed out that i'm front and center in the group photo on http://socghop.appspot.com/gsoc/homepage/google/gsoc2011
10:49:42 <edwardk> was greatly amused
10:49:49 <c_wraith> Apocalisp: there are libraries available that prevent that.
10:49:56 <Apocalisp> great!
10:49:56 <herzen> silver: must be. I'll have a look.
10:50:52 <c_wraith> Apocalisp: in particular, check out the safer-file-handles* libs
10:51:01 <edwardk> Apocalisp: you can also keep using it after you close it. keep in mind IO came along _early_ and has to work in a world without MPTCs, etc.
10:51:02 <Apocalisp> thanks c_wraith 
10:51:10 <Apocalisp> edwardk
10:51:13 <Apocalisp> oops.
10:51:25 <Apocalisp> edwardk: monadic regions solve that problem handily :)
10:51:35 <edwardk> yeah but good luck getting them in haskell 98 ;)
10:51:47 <Apocalisp> I'm not writing any Haskell at the moment
10:51:49 <benmachine> yeah but http://hackage.haskell.org/package/explicit-iomodes-0.6.0.2 is probably h98
10:52:02 <herzen> silver: or maybe not. I got the ghc code from darcs HEAD.
10:52:38 <edwardk> benmachine: nah, unicode ;)
10:53:19 <edwardk> now i just need to tease bas about that one as well on the cafe. ;)
10:53:35 <herzen> anyway, this is not a high priority, since I've got an older version of darcs installed. I'll look through the darcs sources and reacquaint myself with Haskell modules.
10:53:55 <benmachine> edwardk: oh and it apparently uses GADTs. not sure that's essential though
10:54:40 <edwardk> yeah you can recode the initial GADT encoding to a final encoding without them
10:55:01 <Skola> benmachine have you worked with matrixes?
10:55:10 <benmachine> Skola: not much, but a little
10:55:16 <Skola> I'm looking in to them for educational (educating myself) purposes
10:55:22 <niteria> what was :set xxx option that shows time in ghci?
10:55:25 <benmachine> *matrices :)
10:55:26 <Skola> so I'd like to do it "the Haskell way"
10:55:28 <Skola> yes
10:55:30 <Skola> sry
10:55:31 <c_wraith> reactive-banana?  what a name
10:55:34 <Skola> *sorry
10:55:36 <Skola> >_>
10:55:38 <benmachine> c_wraith: :D
10:55:46 <benmachine> Skola: it's cool, just checking in case you didn't know
10:55:57 * hackagebot concurrent-extra 0.7 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7 (BasVanDijk)
10:56:19 <benmachine> Skola: I've never done any serious programming with matrices, but I tried out hmatrix once and it seemed nice
10:56:37 <Skola> my uses aren't very serious
10:56:53 <Skola> just want to explore what's out there
10:57:14 <Skola> and if there are "ways" that do not need extra libs
10:57:26 <benmachine> ah, hmatrix does need extra libs
10:57:45 <Skola> I'll have a look, thanks :)
10:57:57 <Skola> they are very simple matrices
10:58:03 <benmachine> you could look at the whole Math category of hackage
10:58:05 <edwardk> benmachine: sadly. there is discussion of refactoring it into two parts, so that the gpl'd bits can be divorced from the core
10:58:06 <benmachine> it's quite large though
10:58:15 <Skola> yeah I have looked at several packages
10:58:19 <Skola> there's real goodness in there
10:58:28 <edwardk> i should also get around to releasing blase.
10:59:06 <benmachine> this looks like fun http://hackage.haskell.org/package/Vec
10:59:15 <edwardk> (decent dsl bindings for BLAS based on observable sharing and observing thunk evaluation)
10:59:29 <Skola> sure does ben
10:59:50 <benmachine> but has a build failure :(
11:00:45 <Skola> :///////
11:01:23 <Skola> random thought: I'm still using ghc 6.8
11:01:39 <Skola> should I get 7.x working on my mac?
11:01:48 <Skola> or am I not missing out?
11:01:51 <silver> 7.0.3 probably
11:01:54 <mzero> you are missing out
11:02:00 <Skola> roger
11:02:07 <silver> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/release-7-0-3.html
11:02:08 <mzero> just install Haskell Platform 2011
11:02:16 <mzero> you'll get 7.0.2 for now - which is quite workable
11:02:51 <mzero> not sure you can compile 7.xxx GHC with 6.8.... so the Haskell Platform route might be easiest
11:03:05 <Skola> k but this requires 10.6x amirite?
11:03:21 <Skola> I have yet to waste money on snow leopard
11:03:35 <osoleve> :t (.|.)
11:03:36 <lambdabot> forall a. (Bits a) => a -> a -> a
11:03:38 <silver> oh the mac world
11:03:44 <Skola> yes
11:03:53 <Skola> the world of useless updates that cost boatloads
11:04:05 <Skola> the world of no backward compatibility 
11:04:10 <Skola> at all
11:04:19 <mzero> well then, you can at least update to 6.12 via HP 2010
11:04:45 <Skola> yes when I did that
11:04:49 <Skola> cabal install ANYTHING
11:04:51 <Skola> broke
11:04:59 <benmachine> broke how?
11:05:05 <mzero> make sure you are using the newer cabal that came with the platform
11:05:13 <Skola> in a way thaat nobody understood
11:05:16 <mzero> and not one that is in your ~/bin or elsewhere in the $PATH
11:05:19 <Skola> let me look up the hpaste
11:05:52 <mzero> Actually, the reason HP 2011 doesn't install on 10.5 has nothing to do with 10.6 backward compatibility -- it is the way the GHC is now using dtrace
11:06:22 <Skola> http://hpaste.org/44873/during_almost_any_cabal_instal
11:06:23 <Skola> this shit
11:06:25 <mzero> HP 2011 can be built on 10.5 for 10.5 and that works -- but I haven't done that yet
11:07:48 <Skola> and this was after fixing 4 other error messages
11:08:24 <Skola> I gave up at this
11:08:30 <Skola> and went with macports version
11:10:37 <tibbe> edwardk: yay!
11:11:15 <djahandarie> pumpkin, heh, just read that mailing list post. Interesting, mmorrow replied to it :p
11:11:21 <edwardk> tibbe: i learned my lesson. the previous year i was butting heads with the rafters. ;)
11:11:34 <tibbe> heh
11:11:58 <tibbe> edwardk: Is this you http://www.linkedin.com/in/ekmett ?
11:12:20 <edwardk> yep
11:13:55 <djahandarie> Oh, I see that it was sent long enough ago that it would make sense for mmorrow to reply to it
11:14:24 <hpc> preflex: seen mmorrow
11:14:24 <preflex>  mmorrow was last seen on #ghc 1 year, 69 days, 15 hours, 21 minutes and 51 seconds ago, saying: * mmorrow is rtfm'ing
11:14:33 <djahandarie> It's annoying how people have figured all this stuff out before I even started learning Haskell :p
11:14:45 <hpc> djahandarie: when did you start learning haskell>
11:14:46 <hpc> ?
11:15:05 <djahandarie> That's a good question. Not seriously until like 1.5 yrs ago? I think
11:15:11 <djahandarie> I think I first came in this channel like 2 years ago
11:15:26 <djahandarie> I should scrape the logs some time
11:15:29 <hpc> ah, so you predate me by just a little bit
11:15:47 <tibbe> edwardk: tried to do some more GSoC promotion today
11:16:04 <Saizan> which stuff?
11:16:14 <djahandarie> Saizan, http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html
11:16:29 <edwardk> tibbe: yeah. i saw the blog post. i tweeted something about applying and ran around beating the bushes on channel
11:16:59 <edwardk> i've been talking to 4-5 potential students by email
11:17:40 <djahandarie> Did chrisdone ever make that irc log scraper?
11:17:55 <edwardk> now trying to convince shapr to sign up, if only coz of the amusement factor of going mentor -> student
11:17:57 <tibbe> edwardk: great
11:18:16 <tibbe> edwardk: I have a feeling that we want get as many applications this year
11:18:35 <djahandarie> Heh, mmorrow is like the second person to talk in my #haskell.log which starts on Dec 2009
11:18:43 <kamaji> Hi haskellers, does anyone have a good tutorial for Data.Matrixd ?
11:18:49 <kamaji> Data.Matrix *
11:18:49 <edwardk> based on buzz, i'd guess down 30%
11:18:59 <Skola> lol how very relevant
11:19:21 <Skola> Google summer of code?
11:19:23 <edwardk> djahandarie: he was really active for a while
11:19:24 <edwardk> skola: yeah
11:19:42 <Skola> Wish I'd find an excuse/oppurtunity to Haskell away my summer
11:19:55 <IrishDuck> so just out of curiosity what format should we be submitting applications in?
11:20:09 <IrishDuck> the link to the google FAQ on submitting proposals is dead :(
11:20:55 <edwardk> IrishDuck: woops
11:21:41 <edwardk> IrishDuck: basically list what you want to accomplish, how it benefits the community, how you'll keep us updated about it as it goes
11:21:47 <c_wraith> Hmm.  I'd really love to play with reactive-banana...  But I'd like a sample app just to check if it's working.
11:22:20 <tux_mark_5> hello
11:22:22 <IrishDuck> edwardk: I have all that... I'm just wondering if we submit a pdf or html or what
11:22:45 <edwardk> there is a web form
11:23:08 <djahandarie> Okay yeah, seems like I really started doing Haskell at the very start of 2010
11:23:20 <IrishDuck> edwardk: ah ok so plaintext?
11:23:26 <edwardk> go through http://socghop.appspot.com/gsoc/homepage/google/gsoc2011 and sign up, then there is a form to submit to haskell.org
11:23:37 <tux_mark_5> i'd like to ask a question: what's the "best" structure to organize trees within haskell so they could be updated quickly enough?
11:23:38 <edwardk> its that gmail-ish rich text stuff
11:23:48 <edwardk> so you can basically paste in html if you want
11:24:01 <edwardk> but i wouldn't kill yourself with formatting
11:24:08 <tux_mark_5> because it seems that if i want to update a leaf node when using Data.Tree i have to update the whole tree
11:24:35 <c_wraith> tux_mark_5: not the whole tree, just the path to the element you're updating.  That's still O(log n)
11:24:41 <xplat> tux_mark_5: you really only have to update the nodes on a path from the root to the leaf
11:24:42 <IrishDuck> OK I have it in restructured text now and was going to use pandoc to just convert to whatever
11:24:51 <c_wraith> tux_mark_5: But if your keys are Int, use Data.IntMap
11:24:57 <tux_mark_5> still, if i have 50 levels that's not really acceptable
11:24:59 <xplat> the rest of the nodes (subtrees) are reused from the old tree
11:25:32 <c_wraith> tux_mark_5: if the tree is near balanced, having 50 levels implies more nodes than you have memory
11:25:55 <tux_mark_5> well, let's assume that tree isn't balanced
11:26:14 <xplat> tux_mark_5: well, then the best structure depends why it is unbalanced
11:26:33 <tux_mark_5> this is kind-of educational question, i don't really need it implemented anywhere, i'm just curiuos how to program such stuff for performance
11:27:02 <xplat> tux_mark_5: if there's no specific reason it would be unbalanced, it's best to just balance it
11:27:05 <c_wraith> For performance, you want to keep it balanced.
11:27:23 <c_wraith> There are lots of algorithms for keeping binary trees balanced well-enough.
11:27:38 <tux_mark_5> well, there are situations when it can't be balanced - like 3d programing - i mean octress & bsptrees
11:27:38 <c_wraith> Data.Map uses one optimized for functional settings.
11:27:47 <edwardk> c_wraith: under certain usage profiles, turns out most uses of structures like Data.Map run fastest if you avoid rebalancing because of reduced allocation
11:28:24 <edwardk> which is one reason why Data.IntMap tibbe's HashMaps are so fast
11:28:30 <edwardk> er IntMap and tibbe's
11:28:52 <gwern> tibbe is more machine than man now, low-level and evil
11:29:08 <tux_mark_5> the most primitive solution would be to have some mutable array or array of IORefs - then i wouldn't need to traverse the tree from leaf to root
11:29:20 <tux_mark_5> but this doesn't look well in FP
11:29:45 <tibbe> gwern: prepare to be assimilated
11:29:46 <c_wraith> tux_mark_5: You can do that, but you lose most of the hidden advantages of persistent data structures...  like free history.
11:29:53 <xplat> tux_mark_5: when you talk about an array of IORefs without having a specific application in mind, you have gone astray
11:29:58 <tibbe> edwardk: I think I'm beating IntMap nowadays actually
11:30:05 <c_wraith> tux_mark_5: and the performance increase is minor, at best.
11:30:07 <tibbe> edwardk: suggesting that IntMap could be improved
11:30:08 <gwern> @quote free.variable
11:30:08 <lambdabot> OlinShivers says: "I am not a Church numeral; I am a free variable!"
11:30:26 <tux_mark_5> say, i have 10000 updates per second - that should count for something
11:30:31 <edwardk> tibbe: yeah
11:30:34 <c_wraith> tibbe: your HAMT work is making progress, then?
11:30:43 <c_wraith> tux_mark_5: what makes you think a persistent data structure can't do that?
11:30:56 <c_wraith> tux_mark_5: 10k/s isn't really that fast.
11:31:28 <tux_mark_5> in "normal" (mutable) world i only would need to update one node - in pure FP i need to do that 50 times more often, assuming i have 50 levels in my tree
11:31:48 <tibbe> c_wraith: not really at the moment
11:31:51 <c_wraith> tux_mark_5: then use a zipper.
11:31:55 <tibbe> c_wraith: I need to find some more time to work on it
11:32:03 <tux_mark_5> zipper?
11:32:04 <tibbe> c_wraith: working on making Data.Binary.Builder 10x faster :)
11:32:28 <c_wraith> tibbe: is that ever going to merge with blaze-builder?
11:32:44 <tibbe> tux_mark_5: you'll never have 50 levels in your tree though, 10-20 perhaps
11:32:48 <c_wraith> tibbe: seems like they have the same use case.
11:32:56 <tibbe> c_wraith: 1-5 in a HAMT
11:33:03 <tibbe> c_wraith: in some manner
11:33:08 <tibbe> c_wraith: we'll see
11:33:11 <tibbe> c_wraith: once I'm done
11:33:21 <tibbe> c_wraith: I'd like to keep the simple API
11:33:24 <tux_mark_5> tibbe: true, but i'm still curious
11:33:57 <c_wraith> tux_mark_5: anyway.  A zipper is, in some sense, the derivative of a data structure.  It reformulates the data structure as a focus and context.  Updates at the focus are very cheap.
11:34:39 <xplat> presumably for a BSP tree you are going to be traversing it many more times than you update any given node, so a zipper wouldn't really make sense except for the occasional irregular bulk traversal and update
11:35:09 <c_wraith> though that's true.  BSPs were famously static, in most applications
11:35:33 <roconnor> a zipper is an inside out derivative
11:35:34 <xplat> zipper at the camera does make sense for some uses of octrees though
11:35:57 <edwardk> i actually used to produce them in realtime in an old engine of mine, but then i octreed the world down to where the bsps were typically around 50 polys
11:36:02 <edwardk> so i could generate them and cache them
11:36:13 <edwardk> but yes, for most people they are static ;)
11:37:52 <edwardk> roconnor: along with a value for the hole
11:39:00 <edwardk> lol, the old flipcode postmortem for that engine is still around: http://www.flipcode.com/harmless/issue04.htm
11:39:34 <xplat> in particular, a zipper is an expansion of (X,D (Mu (F X))) according to a specific formula for the derivative of Mu F in terms of D F, plus some extra operations
11:40:28 <danharaj> Is there a linear algebra library that is made to play nicely with openGL?
11:40:47 <edwardk> danharaj: not that i know of
11:41:17 <IrishDuck> tibbe (and/or edwardk): Do you think it would be possible to finish interactive support in cabal and implement parallel builds in one SoC project?
11:41:24 <Younder> danharaj, yes the one distributed by NVidea CUDA
11:41:34 <danharaj> Younder: Does it have Haskell bindings? :p
11:41:39 <TomMD> danharaj: If there is then I figure lispy would know of it.
11:41:42 <tibbe> IrishDuck: dcoutts thinks interactive support is no more than a week's project
11:41:43 <mercury^> xplat: that sounds interesting. Can you go into some more detail, maybe in #categorytheory because there is less noise there?
11:42:03 <Younder> danharaj, Not that I know of
11:42:04 <tibbe> IrishDuck: parallel builds is trickier, I'd start with that to not risk having it half finished by the end of the summer
11:42:04 <IrishDuck> tibbe: yeah I saw the ticket was fairly far along
11:42:25 <herzen> silver: changing import System( system ) to import System.Cmd( system ) in ShellHarness.hs made darcs build. So that file also should be updated.
11:42:41 <tibbe> IrishDuck: I'd combine repl support with a bunch of other small tasks, or take it on as another task after finishing something bigger, in case the summer isn't over yet
11:42:42 <silver> oh cool
11:43:50 <Younder> danharaj, guess we will just have to create some :)
11:43:53 <dcoutts> IrishDuck: but it's ok to have a project involving multiple week-long features/projects
11:44:18 <IrishDuck> OK. You also indicated that it might be nice to create a separate library for Distribution.Client so I wanted to do that too. 
11:44:36 <IrishDuck> Along with the parallel builds as the "main course" so to speak
11:45:22 <IrishDuck> On the trac ideas page someone mentioned that just parallel builds might be a bit small for the summer
11:45:35 <IrishDuck> So I'm trying to find other things to fill up time at the end
11:45:36 <Younder> danharaj, seriously, I need such a library and if someone would collaborate it would be great. I have enough on my plate.
11:45:56 <danharaj> Younder: If I weren't completely swamped with work I would consider it.
11:46:10 <danharaj> I told Lispy that I would be interested in working on some sort of big opengl support project.
11:46:23 <danharaj> Maybe some of us should get together and start that at some point.
11:47:12 <lispy> danharaj: I have to go right now.  but, there are vector libraries on hackage for opengl.  See for example this: http://nix-tips.blogspot.com/2011/03/how-to-choose-haskell-array-library.html
11:47:26 <danharaj> lispy: awesome I'll browse around
11:47:39 <lispy> danharaj: you may want to start with the haskell game task force.  #haskell-game and also on haskellers.com and the haskellwiki.
11:47:41 * lispy runs
11:48:17 <tibbe> IrishDuck: I think it might take the whole summer
11:48:25 <tibbe> IrishDuck: people always underestimate the time it takes
11:48:37 <tibbe> IrishDuck: cabal test was a full summer, I don't think parallel builds are any easier
11:49:04 <Younder> danharaj, perhaps
11:50:10 <Younder> danharaj, Have you tried IGDA?
11:50:46 <Younder> International Game Developers Association
11:51:06 <c_wraith> oh, nice.  reactive-banana-wx comes with a sample app.  It just doesn't build without a one-line change. :)
11:51:13 <aristid> is a characterisation of iteratees as "reverse coroutines" at least vaguely accurate?
11:51:51 <xplat> isn't a reverse coroutine just a coroutine?
11:52:04 <Younder> I am an old member...
11:52:38 <IrishDuck> tibbe: So should I mention I'll do the others if I have time? Or just leave them out entirely?
11:53:02 <aristid> xplat: well, meaning that it has a series of inputs and one output. a typical coroutine has one input and a series of outputs, AFAIK
11:53:28 <xplat> that's a generator, not a coroutine
11:53:38 <tibbe> IrishDuck: You can just give add a sentence in the end mentioning that you'd like to work on that afterwards, if you have time
11:53:47 <dcoutts> IrishDuck: it'd be good to look at a range of projects and discuss them with people on the cabal-devel mailing list. They can advice on how long things might take and how valuable the features are.
11:53:48 <c_wraith> xplat: aren't generators just a limited form of co-routine?
11:53:57 <tibbe> IrishDuck: if you can finish parallel builds in a summer people will be happy
11:54:06 <aristid> xplat: what IS a coroutine? :D
11:54:09 <tibbe> IrishDuck: i.e. I think it's a good enough project in itself to be ranked high
11:54:44 <tibbe> IrishDuck: my advice would be to spend a day looking into what you'll need to change, will make your application more believable
11:55:00 <xplat> aristid: a coroutine is a routine with the power to transfer control and a value to another coroutine
11:55:18 <tibbe> IrishDuck: you might also wants to send a proposal for a design to cabal-dev mailing list now
11:55:26 <IrishDuck> tibbe: I've already looked around a bit, sounds like I should focus on parallel builds and lay out a concrete plan
11:55:38 <tibbe> IrishDuck: to get some early feedback. Thomas did that for cabal test last year. I think that was a good idea
11:55:40 <xplat> after which it waits for control and a value to be transferred back to it
11:56:02 <tibbe> IrishDuck: (you don't necessarily have to act on all feedback, just collect it)
11:56:17 <danharaj> I wish hackage separated GPL libraries from the rest.
11:56:18 <IrishDuck> tibbe: I tried to start a conversation on how logging would get implemented on parallel builds but no responses...
11:56:21 <xplat> generators are a special case of that, but so are aggregators
11:56:51 <Younder> I've been looking into the book 'The art of Multiprocessor programming' by  Herlihy and Shavit
11:57:00 <IrishDuck> tibbe: I'll send out a plan for feedback before my proposal though, thanks for the input
11:57:09 <tibbe> IrishDuck: sounds goods
11:57:14 <tibbe> IrishDuck: and you're welcome
11:57:14 <Younder> and youare both wrong
11:57:29 <tibbe> IrishDuck: I must have missed that
11:57:45 <tibbe> IrishDuck: my advice would be to do what Gentoo does
11:57:48 <aristid> xplat: and in a more haskellish definition? :)
11:57:54 <tibbe> IrishDuck: cabal logging is too verbose as it is anyway
11:58:04 <IrishDuck> tibbe: good point
11:58:06 <Younder> What you need and indeed what you have is Transactional Memory
11:58:08 <tibbe> IrishDuck: so making it more compact would be nice. Just store everything in a file (or several)
11:58:12 <tibbe> IrishDuck: for debugging
11:58:19 <dcoutts> danharaj: the new hackage server has bsd and gpl as tags, so it should be possible to make filtered views later
11:58:26 <tibbe> IrishDuck: and if the build fails output the location of the log file(s)
11:58:39 <danharaj> dcoutts: yay.
11:59:10 <tibbe> IrishDuck: our parallel system at work has similar output to Gentoo, when you build on hundreds of machines (and thousands of files) you really don't want every single line of compilation to stdout
11:59:26 <tibbe> IrishDuck: think about how output scales to ten thousand file projects
11:59:46 <xplat> aristid: doesn't really make sense in haskell because haskell does not have linear control flow as the normal case
11:59:52 <IrishDuck> tibbe: OK... especially if logging was verbose that would be a nightmare
11:59:56 <tibbe> IrishDuck: also give a though about how things would look if the actual compilation could be run on different machines (in a distcc fashion). this might help inform your design
12:00:06 <Younder> I suggest you look at something similar in the postgreSQL database.
12:00:30 <tibbe> IrishDuck: so I'd suggest something like an inplace updating UI
12:00:30 <aristid> xplat: IO or State could be seen as models of linear flow, no?
12:00:42 <xplat> aristid: but dataflow-wise it's similar to the Cont monad(s)
12:00:55 <tibbe> IrishDuck: e.g.: Line 1: Building attoparsec (3 of 10) Line 2: Building binary (1 of 5)
12:01:01 <tibbe> IrishDuck: and the numbers would update
12:01:15 <IrishDuck> tibbe: kind of like how wget updates the progress of downloads in place?
12:01:23 <tibbe> IrishDuck: I think the Gentoo example is mentioned in the tickets
12:01:31 <tibbe> IrishDuck: something like that
12:01:35 <Younder> attoparec = meter :)
12:01:38 <tibbe> IrishDuck: maybe you don't need a progress bar
12:01:49 <tibbe> IrishDuck: as it's hard to predict the time
12:01:50 <IrishDuck> tibbe: Yeah I think load averages and status would be better
12:01:52 <tibbe> but maybe:
12:02:05 <tibbe> Building <lib> (Downloading)
12:02:15 <tibbe> Building <lib> (Compiling 1 of 10)
12:02:28 <tibbe> and have the thing in parenthesis update as the thing progresses
12:02:48 <tibbe> IrishDuck: initially just copy what Gentoo does or something
12:02:48 <IrishDuck> tibbe: right, and have that for each package being built in parallel right?
12:02:53 <tibbe> IrishDuck: we can tweak later
12:03:02 <tibbe> IrishDuck: yes, so several updating lines at once
12:03:51 <IrishDuck> tibbe: The other interesting problem is deciding which packages to build first
12:04:04 * hackagebot jmacro 0.4.6 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.4.6 (GershomBazerman)
12:04:15 <tibbe> IrishDuck: yes, cabal-install already computes a build plan with deps
12:04:33 <tibbe> IrishDuck: as it needs to build the things in the right order already
12:04:57 <IrishDuck> tibbe: Right, but if it was smart it would build packages with, for example, the most dependencies down the line first
12:05:12 <tibbe> IrishDuck: you just need to use that to compute which packages have all deps fulfilled and can be built
12:05:19 <Younder> parsec is the arc width of the orbit of the earth is less than 1000'th of a degre. Ca. 1.3 Lightyear
12:05:39 <tibbe> IrishDuck: you want to build in the order that maximizes parallelism
12:05:50 <tibbe> IrishDuck: doing it greedily might be ok though
12:05:59 <IrishDuck> tibbe: Right, is there a variant of topo-sort that would do that?
12:06:03 <tibbe> IrishDuck: if you have a spare CPU and something that can be built right now, build it
12:06:12 <tibbe> IrishDuck: it's something like topo sort
12:06:24 <tibbe> IrishDuck: I guess topo sort is what Cabal does right now
12:06:31 <IrishDuck> tibbe: But if you can build, say 16 packages, and only have enough CPU cycles to build 8...
12:06:38 <IrishDuck> tibbe: which 8 to build?
12:06:42 <Younder> Distance of nerby starts is often measured by taking the angle at oposites of the orbit and using the radius as a measure for the sin.
12:07:06 <jix> intuitively I'd say building the package that most packages depend on (including indirect depdendencies) and that has no dependencies left should be good
12:07:15 <dcoutts> IrishDuck: in cabal-install there is an InstallPlan data structure, this has exactly the info needed to do builds in parallel.
12:07:20 <tibbe> IrishDuck: right
12:07:23 <IrishDuck> Ah ok
12:07:31 <tibbe> IrishDuck: probably doesn't matter much in that case
12:07:32 <IrishDuck> Looks like I have some source diving to do
12:07:38 <dcoutts> the current code uses the InstallPlan but only executes it serially
12:07:47 <dcoutts> there is code to extract the next "ready" packages
12:07:54 <dcoutts> ie the ones that can be fired off now
12:08:01 <tibbe> IrishDuck: the tricky problem is, you have two packages to build, 8 CPU cores, and building one of the two would enable you to build 7 others
12:08:02 <dcoutts> so it's all set up to do parallel builds
12:08:18 <tibbe> IrishDuck: please read some source, will inform your design for the gsoc application
12:08:23 <IrishDuck> yup, that's what I was trying to say
12:08:28 <dcoutts> the bit that is missing, is what to do with the output, and how to manage the processes
12:08:37 <tibbe> IrishDuck: doing the naive thing first should probably be ok
12:08:45 <IrishDuck> tibbe: already have but I have more to do, I have some notes on this stuff already
12:09:02 <tibbe> IrishDuck: great
12:09:04 <byorgey> oooh, parallel builds, yummy =)
12:09:07 <Younder> Does dataflow help when discovering parallelism?
12:09:33 <Younder> It seems to, but I might be missing something.
12:09:43 <jmcarthur> pure functional programming helps :)
12:09:51 <Younder> duh!
12:10:15 <Younder> I was talking about on the compiler side.
12:10:29 <IrishDuck> dcoutts: I was thinking of modifying the Verbosity data type to manage the output because it's pervasive already... does that seem like a good idea?
12:11:23 <dcoutts> IrishDuck: the verbosity controls the level of output, but the big issue is how to manage the fact that you have multiple concurrent sources of info, from multiple builds
12:11:23 <Younder> I really should be directing this to Simon p. Jones.
12:11:48 <Younder> s/p/P/
12:12:20 <dcoutts> IrishDuck: your choices are to try to interleave it, to hide it, or to redirect each one to to a file and only present info at the end
12:12:23 <tibbe> dcoutts: is there a good way to measure the load factor?
12:12:43 <tibbe> dcoutts: I say hide it one line that updates
12:12:51 <dcoutts> tibbe: linux has some stat for that, gentoo's emerge makes uses of it
12:12:51 <IrishDuck> dcoutts: So I was thinking of modifying the Verbosity type to include the destination for the output
12:13:01 <tibbe> dcoutts: as projects grow larger you really need to, even if you're not building in parallel
12:13:16 <tibbe> dcoutts: 5k lines of junk to stdout doesn't really help the programmer much
12:13:19 <dcoutts> IrishDuck: no, you have to deal with the build system as a black box really. Packages are allowed to use custom build systems.
12:13:46 <IrishDuck> dcoutts: So would it be better to spawn a separate process and redirect output?
12:14:04 <dcoutts> tibbe: indeed, what gentoo does is to hide it all, only show how many are running now, how many are finished / remaining. If one fails then it presents the errors.
12:14:16 <dcoutts> IrishDuck: in general that's what you will have to do
12:14:45 <dcoutts> IrishDuck: for packages that use the simple build system there is the option to do something else, but it may not be worth it
12:14:52 <tibbe> dcoutts: right, that was what I had in mind
12:15:00 <tibbe> dcoutts: incidentally that's how cabal test should work
12:15:06 <dcoutts> tibbe: yes
12:15:09 <tibbe> dcoutts: just show progress and only output the test failures
12:15:14 <dcoutts> aye
12:15:36 <IrishDuck> I wasn't sold on the gentoo-style output at first but the more I think about it the more sense it makes
12:15:41 <IrishDuck> especially for large builds
12:15:47 <tibbe> yes
12:15:50 <tibbe> assume large
12:16:02 <tibbe> this feature is in fact for people who build a lot of stuff!
12:17:00 <tibbe> IrishDuck: http://blogs.gentoo.org/zmedico/2010/03/03/portage_parallel_builds/
12:17:05 <dcoutts> for a single or local build you revert to the usual style
12:17:25 <IrishDuck> Ok... you anticipated my next question dcoutts
12:18:11 <tibbe> dcoutts: what do you mean?
12:18:26 <niteria> which array datatype would be good to write prime sieve?
12:18:38 <IrishDuck> If the user doesn't specify a parallel build display the build output like it is already
12:18:54 <tibbe> niteria: a mutable or purely functional one
12:18:55 <IrishDuck> At least that's the way I interpreted it
12:19:06 <tibbe> IrishDuck: that would be reasonable I guess
12:19:15 <tibbe> IrishDuck: long term I want more compact output there too
12:19:24 <niteria> tibbe: It doesn't matter for me
12:19:37 <tibbe> niteria: The vector package has efficient mutable vectors
12:19:43 <tibbe> niteria: http://hackage.haskell.org/package/vector
12:20:14 <dcoutts> tibbe: for a normal "cabal build" we just do the normal thing, letting ghc display its usual output
12:20:34 <tibbe> niteria: http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector-Unboxed-Mutable.html
12:20:37 <tibbe> dcoutts: ok
12:20:38 <dcoutts> tibbe: when we move to a dep-based system and use ghc in single shot mode, we could do something more compact.
12:20:39 <osoleve> sorry if this is a stupid question, but do any of you have ideas for a decent project for a beginner to take on? I just finished writing a calculator that involved two parsers and an evaluator, I need to move on. :/
12:20:43 <tibbe> dcoutts: reasonable starting point I guess
12:20:56 <niteria> tibbe: thanks
12:21:03 <tibbe> osoleve: a binding to some small C library you care about?
12:21:16 <dcoutts> tibbe: but those two parts are in different layers of the system
12:21:18 <tibbe> niteria: no problem. A purely functional solution would use a heap I think
12:21:24 <tibbe> dcoutts: I know
12:21:43 <Saizan> osoleve: some do irc bots
12:21:44 <tibbe> dcoutts: that's an internal concern though, the user (i.e. me ;) ) doesn't care
12:21:52 <niteria> tibbe: there is diffarray but I have no idea how it works
12:22:00 <tibbe> niteria: it's super slow
12:22:11 <tibbe> niteria: use vector for mutable updates of arrays
12:22:22 <tibbe> niteria: you can try to immutable version too and compare the performance
12:22:22 <Saizan> osoleve: you could also look at exercises from RWM
12:22:32 <Saizan> osoleve: err, RWH, Real World Haskell
12:22:32 <tibbe> niteria: I don't quite remember the details of the sieve implementation
12:22:39 <tibbe> gotta go to bed
12:22:40 <tibbe> gnight!
12:22:43 <dcoutts> tibbe: I mean the compactness or otherwise of the normal output is not relevant when you're looking at cabal-install doing builds of independent packages in parallel
12:22:45 <osoleve> Saizan: okay, first RWH, then the world!
12:22:52 <tibbe> IrishDuck: good luck :)
12:22:59 <IrishDuck> tibbe: thanks, I'll be in touch
12:23:07 * hackagebot reactive-banana-wx 0.1.0.1 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.1.0.1 (HeinrichApfelmus)
12:23:09 <osoleve> I really want to contribute something to the community, but I feel like i'm not even close to being able to do that
12:23:14 <niteria> tibbe: point is updates depend on other updates, so I can't just map over it
12:23:28 <tibbe> niteria: ok
12:23:36 <c_wraith> heh.  I think Heinrich just fixed the compile error I pointed out :)
12:23:37 <tibbe> time to sleep off jetlag
12:23:38 <tibbe> gnight
12:25:26 <c_wraith> yes, he did.  Cool.
12:27:06 <niteria> I have offtopic question: anyone here internshipped in facebook recently?
12:28:45 <byorgey> osoleve: I remember feeling that way several years ago.  Have patience, you'll get there. =)
12:30:24 <c_wraith> osoleve: It's not that hard.  You don't need anything special...  Just find a library need that's not being properly served, anywhere, and put some work into it.
12:31:07 <c_wraith> osoleve: it doesn't even need to be coding work.  Just bringing a lack to attention can help
12:40:18 <dainanaki> If I have a C function that returns a void* and I'm marshaling it into Haskell, what would be the sensible type for it?
12:41:28 <benmachine> I think I'd map void* to Ptr a
12:41:42 <benmachine> might depend on what exactly you do with it
12:42:04 <dainanaki> Hmm, would there be any constraints on the type a?
12:43:23 <allbery_b> depending on how exactly it's used, you might want a (forall a. a) or a Data OpaqueWhatsit a
12:43:34 <allbery_b> or several other possible representations
12:44:12 <benmachine> dainanaki: in C, void* can be cast to any pointer type (cf. return type of malloc)
12:44:32 <benmachine> dainanaki: so I'd say no constraints are necessary, but some might be helpful
12:45:45 <allbery_b> but that's only one reason that (void *) gets used.  opaque pointers are another (C's version of (forall a. a))
12:46:25 <c_wraith> dainanaki: what do you expect to do with the value returned?  If it's just pass it to some other C function, I'd use Ptr MyType, where MyType is empty
12:46:31 <benmachine> frerich: btw, remember that random-enum function? someone pointed out to me that it should probably use fromEnum minBound instead of 0 http://code.google.com/p/ndmitchell/issues/detail?id=420&colspec=ID%20Status%20Proj%20Summary%20Priority%20Stars
12:46:43 <dainanaki> I'm working on a tool that autogenerates the necessary foreign interface to a C file and was testing it on a custom C memory manager that stores objects of the same size.
12:47:03 <Maxdamantus> benmachine: not necessarily any.
12:47:13 <Maxdamantus> Depends on the void * value.
12:47:32 <benmachine> Maxdamantus: ok fine, but the return value of malloc can be cast to anything
12:47:35 <Maxdamantus> malloc's return can.
12:47:54 <benmachine> so there are at least some cases where Ptr a is a correct translation
12:48:16 <allbery_b> C doesn't even begin to pretend to handle alignment in its so-called type system
12:48:28 <dainanaki> So in this case, I have a function :: void* GetMem(unsigned int objectSize);
12:48:32 <Maxdamantus> so-called?
12:48:37 <c_wraith> Some, yes.  But it really does depend on the expected usage.  Haskell's type system is more expressive than C's.  void * doesn't always mean the same thing in haskell.
12:48:41 <dainanaki> and I'm trying to figure out how to treat it
12:48:58 <c_wraith> dainanaki: what do you intend to do with the memory blocks?
12:49:17 <allbery_b> (void *) is a perfect example of "so-called".  it's not quite as bad as duck typing but is a far cry from a real type system
12:49:24 <dainanaki> c_wraith: store structs in them.
12:49:38 <c_wraith> dainanaki: from haskell, via the Storable interface?
12:49:55 <Maxdamantus> allbery_b: you mean a safe type system?
12:50:00 <allbery_b> I'm thinking that this is a Ptr a for unconstrained a, which will eventually be specified by its later usage
12:50:02 <allbery_b> yes
12:50:44 <allbery_b> dainanaki: see for example the type of alloca
12:50:52 <dainanaki> c_wraith: The structs will be generated in C but are encapsulated in a newtype and have functions that manipulate them in haskell
12:51:08 <c_wraith> dainanaki: sounds like Ptr a is what you want, then
12:52:18 <c_wraith> dainanaki: though if you're manipulating C structs from haskell, I sincerely recommend the Storable interface
12:52:48 <dainanaki> Well, I'm giving you the short version of the story.
12:52:57 <c_wraith> sure
12:53:24 <dainanaki> The structs are actually extern c++ classes, so peek and poke are not really viable from what I understand.
12:53:37 <c_wraith> ah, ok.  That does change things.  Carry on! :)
12:54:05 <allbery_b> Maxdamantus: consider that C's (void *) involves a forall at the outermost level or the innermost one or anything in between with no way to specify
12:54:07 <c_wraith> But yes, if you want the return type to be able to point to multiple different newtypes you've got, make it Ptr a
12:55:00 <dainanaki> Sounds great. Thanks for the help.
12:56:25 <benmachine> if you were really worried about safety, you could put all the safe return types in a class, don't export the class, and put a class constraint on the a
12:56:31 <benmachine> and then only your types can be used
13:01:31 <dainanaki> Alas, the whole point is that the memory manager can be used for anything with the same size in consecutive memory.
13:01:44 <dainanaki> So, it'll just be a Ptr a
13:35:17 * hackagebot nehe-tuts 0.2.2 - Port of the NeHe OpenGL tutorials to Haskell.  http://hackage.haskell.org/package/nehe-tuts-0.2.2 (JasonDagit)
13:39:22 <lispy> It's amazing how many problems other people can find in your .cabal files when you share your code :)
13:40:00 <dblhelix> a question about cabal: how to make the internal (i.e., nonexposed) modules of a library available to the code is a cabal test suite?
13:45:33 <lispy> dblhelix: I think you need flags
13:45:40 <int80_h> hi lispy!
13:45:42 <lispy> dblhelix: But, I don't know much about the cabal test stuff
13:45:50 <lispy> int80_h: hello
13:45:52 <dblhelix> lispy: thanks, I'll give it a try
13:45:53 <dino-> dblhelix: I either make functions and things exposed so that test code can see them, or write test functions in the modules themselves that some general test 'harness' code will use.
13:46:47 <dblhelix> dino-: but then the tests need to be exposed by the library, don't they?
13:46:49 <lispy> dino-: I think that's how we did it historically, but wasn't cabal test supposed to make all this easier?
13:47:02 <seydar> Would implementing the core of Rubinius (the C++ part) in Haskell be a worthy SOC project?
13:47:17 <seydar> just a bytecode interpreter
13:47:23 <seydar> but then you could hook it up to rubinius
13:47:27 <seydar> and run ruby
13:47:28 <seydar> in haskell
13:47:50 <lispy> seydar: one thing they look at for GSoC proposals for Haskell.org is the community impact.  Eg., how will the result make things better for the community.
13:48:03 <seydar> it will combine ruby and haskell into an intense lovemaking session
13:48:48 <seydar> am I the only one who cares about merging ruby and haskell
13:48:57 <dino-> lispy: If that's the case, then I'm way behind on things and should learn what's up lately.
13:49:18 <dino-> dblhelix: yes, and you can also suppress these functions from showing up in haddock docs.
13:49:41 <Aune> > > fmap (*2) (Maybe 3)
13:49:41 <lambdabot>   <no location info>: parse error on input `>'
13:49:47 <dblhelix> dino-: thanks, I'll consider that options as well
13:49:52 <Aune> > fmap (*2) (Maybe 3)
13:49:53 <lambdabot>   Not in scope: data constructor `Maybe'
13:50:03 <Aune> > fmap (*2) (Just 3)
13:50:03 <lambdabot>   Just 6
13:50:09 <dainanaki> seydar, look at hubris
13:50:17 <lispy> dino-: I don't know if cabal test makes things easier.  I just remember some chatter from last summer :)
13:50:40 <lispy> seydar: you should talk to blackdog, the author of hubris
13:50:51 <seydar> dainanaki: yeah, I was working with the guy but I need a new version of ghc that is currently only with the haskell platform
13:51:08 <seydar> lispy: I have been. That's more of a ruby project; i would suggest it to ruby SOC instead of google SOC
13:51:47 <jmcarthur> i just don't think there's much of a demand for a ruby interpreter in the haskell community
13:51:59 <jmcarthur> it sounds like an awesome project, IMO, but still
13:52:23 <Aune> > fmap (+ 1) (* 10) $ 1
13:52:23 <lambdabot>   11
13:52:34 <Aune> > fmap (+ 1) (* 10) $ 5
13:52:34 <lambdabot>   51
13:54:00 <dhun> hey, I am not prefectly sure what I need, but it seems it could be an interprocess communication mechanism between haskell and python 3. Have you got any ideas?
13:55:00 <dino-> Ah, it's: {-# OPTIONS_HADDOCK prune #-}
13:55:42 <dhun> well for now I consider abusing the filesystem, but that looks a little strange to me
13:55:50 <dino-> Combined with NOT using haddock style comments on the defs you'd like pruned.
13:56:28 <dainanaki> what's the easiest way to load a file with foreign imports in ghci?
13:56:39 <blackdog> lispy: it's not really aimed at haskellers
13:56:49 <benmachine> dainanaki: I think you can give .o files or -llib options to ghci
13:56:52 <jlouis> is the indents package the best option for parsing indentation based languages?
13:56:58 <jlouis> (with parsec)
13:57:03 <blackdog> although it wouldn't be a bad way to get a cheap sloppy glue language on top
13:57:22 <jlouis> I'll try it anyway and see where it takes me
13:57:24 <blackdog> it's more for ruby guys who don't particularly want to write C extensions (hubris, that is)
13:59:56 <benmachine> dhun: a socket with AF_UNIX or AF_LOCAL is a common way of doing IPC
14:01:19 <dhun> well ok, it also must work on windows, and with stupid users on windows, and even if we get crossplatform socket windows will give firewall warnings when opening them
14:02:08 <benmachine> tricky
14:03:04 <niteria> i have list if integers, and for each of them I'd like to do some operation on Data.Map (i.e add them and some of their multiples)
14:03:16 <dhun> yeah, but still sockets are a little to low level, so something like java remote procedure call, cross plaform cross programming language would be cool
14:03:22 <niteria> it looks like i'm trying to reinvent monads
14:03:45 <dhun> so well I think the filesytem will to a good job, although the code does not look really nice
14:04:33 <kuznero> Hi All! I have a small question - hope somebody could help. I'm declaring a new type class like this:
14:04:33 <kuznero> class Entity a where
14:04:34 <kuznero>   toDocument :: a -> Document   -- ^ Translates entity value into Data.Bson.Document
14:04:34 <kuznero>   fromDocument :: Document -> a -- ^ Translates Data.Bson.Document value into entity
14:04:34 <kuznero>   getCollectionName :: UString  -- ^ Gets collection name (table name)
14:04:34 <kuznero> But compiler is saying that the class method `getCollectionName' mentions none of the type variables of the class Entity a when checking the class method: getCollectionName :: UString in the class declaration for `Entity'
14:04:36 <mzero> niteria - when you say you want to add them, you mean like for each item in the list, you want to modify the map -- and return the result of all the modifications?
14:04:54 <kuznero> What should I do?
14:05:14 <mauke> kuznero: maybe this shouldn't be a class
14:05:31 <kuznero> But the result will be different for different instances
14:05:43 <kuznero> So, it should be a class (AFAIU)
14:05:49 <benmachine> kuznero: there are several ways you can progress. basically the problem is that some use of getCollectionName can't tell which instance to use
14:05:51 <mauke> why not a record of functions?
14:06:26 <kuznero> mauke: Because I want to make sure that each instance implementing this type class has this function implemented
14:06:51 <mauke> kuznero: how is that related to ... anything?
14:07:25 <mzero> niteria: you probably just need a fold,   
14:07:25 <kuznero> benmachine: I could simply make fake parameter in signature of getCollectionName like this: getCollectionName :: a -> UString
14:07:38 <benmachine> kuznero: that's one option. see also the tagged library on hackage
14:07:41 <kuznero> This will most likely work
14:07:47 <benmachine> kuznero: http://hackage.haskell.org/package/tagged
14:08:47 <kuznero> benmachine: thanks, description sounds promising... will look at it. Thanks!
14:08:48 <mzero> > foldr (\k -> insertWith (+++) k "*" Map.empty [3,1,4,1,5,9]
14:08:49 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:08:57 <mzero> > foldr (\k -> insertWith (+++) k "*") Map.empty [3,1,4,1,5,9]
14:08:58 <lambdabot>   Not in scope: `insertWith'Not in scope: `Map.empty'
14:09:01 <dino-> But I feel like this is trying to do it 'inside out'
14:09:11 <mzero> > foldr (\k -> insertWith (+++) k "*") M.empty [3,1,4,1,5,9]
14:09:12 <lambdabot>   Not in scope: `insertWith'
14:09:22 <mzero> > foldr (\k -> M.insertWith (+++) k "*") M.empty [3,1,4,1,5,9]
14:09:23 <lambdabot>   Occurs check: cannot construct the infinite type:
14:09:23 <lambdabot>    b = Data.Either.Either...
14:09:29 <mzero> bah
14:09:59 <ezyang> hey all, I'm looking for a paper that was along the line of "basic blocks considered harmful", but it's clearly not named that or I would have found it :-) 
14:10:21 <benmachine> > foldr (\k -> M.insertWith (++) k "*") M.empty [3,1,4,1,5,9]
14:10:22 <lambdabot>   fromList [(1,"**"),(3,"*"),(4,"*"),(5,"*"),(9,"*")]
14:10:34 <mzero> what he said!  :-)
14:10:54 <mzero> poor-man's histogram
14:12:19 <niteria> mzero: yes
14:12:40 <mzero> so yes, what you want is a fold - see the example benmachine just evaluated
14:13:02 <niteria> thanks
14:13:16 <mzero> you pass the map as the start value of the fold, then use the fold operation to transform the map one step
14:13:49 <quotemstr> What do you guys think of F#?
14:14:36 <edwardk> quotemstr: i try not to think of it. the pain is too great.
14:14:45 <jmcarthur> beats C++ :)
14:15:13 <olsner> Jon Harrop is an F# advocate, that's about all I know about F# :)
14:16:13 <quotemstr> I've been thinking of writing some tools in it at work.
14:16:26 <quotemstr> The only issue is that all my peers are hardcore C-only kernel hacker types. (I'm on the Windows team at MS.)
14:16:30 <edwardk> I _like_ C#, but F# pays all the additional costs of ML syntax, and only gets some pattern matching support and a little bit of extra type inference in exchange. If Don Syme grokked the need for ML's module system and F# offered something of the sort, the language could be salvaged, but it is difficult to see how that would run on the common language runtime
14:16:51 <quotemstr> edwardk: Doesn't F# also get cheap closures and functional data structures?
14:16:59 <edwardk> As it stands, almost none of the code I write in Haskell could be transliterated into F#.
14:17:26 <edwardk> quotemstr: we have those in c# these days
14:17:35 <quotemstr> edwardk: The latter?
14:18:04 <edwardk> quotemstr: i have a whole library of pure functional data structures in c# that lets me get by ;)
14:18:20 <quotemstr> That doesn't count. :-)
14:18:28 <edwardk> meh. there are others out there
14:18:33 <quotemstr> I have a library of pure functional data structures in elisp. That doesn't make elisp a good functional language. :-)
14:18:47 <edwardk> having ml syntax doesn't make f# a good functional language either ;)
14:18:48 <quotemstr> Fair enough. Thanks.
14:18:49 <aristid> could somebody please paste the output of cabal help install from a machine with ghc 7 and cabal-install 0.10.2?
14:19:26 <ezyang> is a Darcs checkout of ghc 7 ok? 
14:19:32 <edwardk> Out of this current generation of functional/imperative hybrids scala is the most palatable to me, if you stick to the portions of it that work.
14:19:35 <quotemstr> edwardk: Both Haskell and ML syntax are pretty ugly in my book.  Ah, to have a sexp-based language with a strict and static type system. That'd be a dream.
14:20:00 <jmcarthur> i'm really wanting to try out this cabal testing support
14:21:28 <aristid> ezyang: yes.
14:21:31 <jmcarthur> to me, sexps are great if you want a really nice macro system, but otherwise, i like my syntax sugar
14:22:29 <b0fh_ua> Hello! Can somebody please take a look at the problem, described at: http://www.haskell.org/pipermail/haskell-cafe/2011-March/090510.html ?
14:22:43 <ezyang> ok, lessee 
14:23:07 <Saizan> with a polished quotation syntax i don't think sexps or not would matter that much
14:23:17 <ezyang> oh, I have to install cabal-install, don't I ^_^ 
14:23:43 <aristid> ezyang: you probably already have cabal-install on your system :) type cabal --version to find out the version
14:23:54 <aristid> cabal-install contains the cabal binary
14:24:10 <ezyang> Yeah, but my cabal-install was not built with GHC7 
14:24:17 * ezyang has been lazy and hasn't upgraded his system yet 
14:24:22 <benmachine> I tried to install cabal-install to comply with this request and I got this http://hpaste.org/raw/45113/cabal_choosing_strange_depende
14:24:26 <benmachine> this is concerning
14:24:27 <jmcarthur> Saizan: yeah that would make sexps much more bearable to me
14:24:55 <aristid> benmachine: wait, what does cabal --version print?
14:25:00 * jmcarthur updates cabal-install
14:25:12 <benmachine> cabal-install version 0.9.5
14:25:12 <benmachine> using version 1.10.0.0 of the Cabal library 
14:25:15 * aristid fears his request will break people's machines :/
14:25:23 <benmachine> aristid: :P
14:25:35 <aristid> benmachine: 0.9.5 is outdated i think :)
14:25:43 <Saizan> jmcarthur: i meant the other way around, i.e. that you could have a really nice macro system without having your language based on sexps
14:25:44 <benmachine> aristid: I'm aware, hence attempting to update
14:25:56 <benmachine> aristid: and it chooses these silly versions!
14:25:57 <jmcarthur> Saizan: i think it helps either way
14:26:08 <aristid> benmachine: yes, it's weird
14:26:31 <benmachine> my guess it's doing some really strange flag combination
14:26:34 <benmachine> I wonder if it's a bug
14:27:08 * benmachine installs parsec because that will probably be useful anyways
14:27:36 <jmcarthur> it's installing Cabal... surely that's a bad thing
14:27:56 <benmachine> jmcarthur: I think installing Cabal is in principle ok, but here it's trying to install a version older than the one I have
14:28:07 * benmachine installs the sensible dependencies in the hope that this will change the install plan
14:28:19 <jmcarthur> benmachine: yeah i think it's doing the same thing to me
14:28:28 <Saizan> benmachine: if you want the latest cabal-install you've to specify > 0.10
14:28:43 <Saizan> benmachine: the default is still 0.8.5 or something
14:28:47 <benmachine> oh :|
14:29:02 <benmachine> that'd be why it says 0.8.2 at the bottom I guess
14:29:05 <jmcarthur> cabal install cabal-0.10.2
14:29:07 <benmachine> how irritating
14:29:25 <jmcarthur> i'm not a big fan of these "defaults"
14:29:39 <benmachine> yeah they could have broken my system if I was less together
14:30:02 * benmachine fix
14:30:50 <dainanaki> can someone remind me what to put at the top of a file to make it runnable as a shell script?
14:31:09 <benmachine> #!/path/to/shell
14:31:15 <jmcarthur> #!/usr/bin/whatever
14:31:17 <benmachine> #!/bin/bash probably
14:31:25 <jmcarthur> depends on what the language is
14:31:28 <dainanaki> I meant running a haskell file
14:31:29 <jmcarthur> doesn't have to be a shell
14:31:39 <jmcarthur> #!/usr/bun/runhaskell   probably
14:31:42 <jmcarthur> *bin
14:31:59 <aristid> lol /usr/bun would make a lovely symlink to /usr/bin
14:32:09 <dainanaki> thanks, forgot about runhaskell
14:32:22 <benmachine> delicious binaries
14:32:30 <Mathnerd314> how easy should it be to port over an imperative (Java) program to Haskell?
14:32:39 <dainanaki> how big is the program?
14:32:43 <dainanaki> what does it do>
14:32:45 <jmcarthur> Mathnerd314: depends on how nice you want the result to be
14:32:54 <benmachine> aristid: ok, crisis averted, installed 0.10.2, what was it you wanted?
14:33:03 <aristid> benmachine: cabal help install
14:33:07 <Mathnerd314> dainanaki: 7000 lines of code, just a data processing thing
14:33:08 * jmcarthur is still building :(
14:33:15 <benmachine> aristid: do you mean, cabal install --help?
14:33:16 <jmcarthur> i have profiling libs enabled though
14:33:24 <benmachine> oh wait
14:33:26 <jmcarthur> benmachine: those are equivalent i think
14:33:33 <benmachine> I got a usage message so assumed I'd done it wrong
14:33:40 <benmachine> but then worked out that that was what I was expecting :P
14:33:44 <jmcarthur> lol
14:33:46 <aristid> benmachine: i'm spoiled by git :)
14:34:18 <Mathnerd314> jmcarthur: I was thinking of "idiomatic Haskell code"
14:34:24 <jmcarthur> in what way, aristid?
14:34:32 <dainanaki> Mathnerd314: The difficulty will be determined by a number of factors: your skill at FP, the availability of libraries for your problem domain, etc. I find that Haskell is generally pretty great for data processing though.
14:34:36 <aristid> jmcarthur: git help foo
14:34:44 <jmcarthur> Mathnerd314: it could be easy or hard depending on the way it is written
14:34:51 <jmcarthur> aristid: that works with cabal too :)
14:34:54 <benmachine> aristid: http://hpaste.org/45114/cabal_help_install
14:35:01 <aristid> jmcarthur: it automatically loads the manpage for git-foo
14:35:05 <jmcarthur> aristid: and the superior version control system darcs ;)
14:35:09 <aristid> jmcarthur: which means that not only do you get help, you get it formatted and in a pager. lovely.
14:35:24 <Mathnerd314> jmcarthur: I'm asking how hard it *should* be.
14:35:52 <jmcarthur> Mathnerd314: what dainanaki says
14:35:56 <aristid> benmachine: thanks
14:36:37 <Mathnerd314> ok... so relatively easy if I'm good at FP and the program uses no libraries
14:36:49 <jmcarthur> yeah should be pretty easy
14:37:04 <jmcarthur> if you're good at FP you should know how hard it is in the first place though :P
14:37:25 <aristid> benmachine: so there's still no option for telling cabal where it should extract the tarballs :/
14:38:06 <Mathnerd314> jmcarthur: I'm trying to determine my skill at FP :p
14:38:13 <jmcarthur> ha
14:39:26 <benmachine> aristid: guess not. I have darcs head lying around somewhere if you want me to check with that :)
14:39:31 <digitteknohippi1> kewl
14:40:24 <jmcarthur> digitteknohippi1: indeed
14:40:34 <blackdog> Mathnerd314: it really does depend on how you translate it. you can do a line for line translation, and it'll be awful. a good translation will probably involve working out what the unstated constraints in the java program are
14:40:39 <digitteknohippi1> lol, even when it's in the wrong window. ^_^
14:41:04 <jmcarthur> i was wondering what the heck you were going on about ;)
14:41:47 <aristid> benmachine: no, not necessary
14:44:06 <aristid> benmachine: the reason i was asking is ... i was reading about somebody having problems with using cabal install in an environment where executing binaries in /tmp is not possible. so i thought: how about telling cabal to use $HOME/tmp instead?
14:44:19 <aristid> but it seems like that is just not possible :)
14:44:33 <benmachine> well, there's always unpack/install, but it is a hassle
14:44:37 <benmachine> is there a ticket for it?
14:46:47 <aristid> dunno, it's not really a problem that applies to me, i was just curious
14:48:35 <dcoutts_> aristid: should not be too hard if you've got time to work on a patch
14:51:06 <b0fh_ua> Hello! Can somebody please take a look at the problem, described at: http://www.haskell.org/pipermail/haskell-cafe/2011-March/090510.html ? Looks like either I am doing something wrong, or multipart support for Curl is broken in haskell binding.
14:53:08 <Bella> hello
14:53:18 <Bella> can anyone help me with haskell?
14:53:22 <Bella> im so new to this
14:53:33 <Bella> got homework on this and im stuck
14:53:40 <m3ga> Bella: don't ask to ask, just ask
14:53:46 <Bella> oh ok
14:53:47 <conal> does the new ghc-7.0.3 work with the previous haskell platform? i.e. can i safely install 7.0.3 and have it work with the haskell platform that had ghc 7.0.2?
14:53:53 <Bella> here goes
14:54:35 <Bella> the type is
14:54:38 <mzero> conal - and hand re-register everything to the new package db? or somehow hand merge the two package dbs?
14:54:48 <Bella> loop :: Table -> IO()
14:54:57 <Bella> Table is a list
14:54:57 <Bella> so
14:55:05 <int80_h> :t zipWith
14:55:06 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:55:18 <conal> mzero: oh -- i hadn't thought that far. sounds like more hassle than i'd like to deal with. thanks.
14:55:19 <Bella> i wanna do this
14:55:27 <mzero> conal - exactly!
14:55:42 <Bella> loop t = do putStrLn "Command: "
14:55:53 <Bella> answer <- getLine
14:56:07 <Bella> case answer of {"add" -> do
14:56:17 <benmachine> Bella: you might find it better to use hpaste.org
14:56:19 <edwardk> bella if you need more than one line for the code fragment go to hpaste.org and put it there
14:56:21 <benmachine> to put your code
14:56:23 <conal> hopefully new haskell platform releases are in the works.
14:56:23 <edwardk> then paste the link here
14:56:27 <m3ga> Bella: don't try and paste code here. use a paste.
14:56:28 <benmachine> otherwise it will get lost
14:56:39 <edwardk> that way conversation can continue around you and your code can be parsed by mere mortals ;)
14:56:39 <mzero> conal - I probably won't get to doing a new one for Mac until this coming weekend
14:56:56 <Bella> okay..
14:57:05 <Bella> this sounds silly but
14:57:06 <conal> mzero: oh, yeah. i forgot you do the mac platform releases. i'll wait for it.
14:57:10 <Bella> how am i gonna use paste?
14:57:35 <azaq23> should be obvious once you visit hpaste.org
14:58:03 <lpsmith> conal, I installed ghc-7.0.3 from binary,  and then downloaded the haskell platform source and wrote a quick-and-dirty shell script to compile all the packages in the order listed in the package.manifest.   (But I couldn't get OpenGL compiled,  so I couldn't use the make system provided anyway...)
14:58:12 <Bella> okay lemme visit that first
14:58:21 <RodneyMcDangerDa> so is Haskell based more in Category or based more in something else?
14:58:39 <RodneyMcDangerDa> Theory*
14:58:55 <benmachine> haskell is somewhat inspired by category theory
14:58:57 <monochrom> more like typed lambda calculus
14:59:04 <benmachine> but I've never learnt category theory and got along with haskell fine
14:59:18 <mzero> lpsmith & conal - if you've got a 7.0 compatible cabal command, you can just install 7.0.3 and cabal install haskell-platform
14:59:19 <monochrom> only a few type classes are from category theory
15:00:02 <conal> mzero: do you know whether the new ghc and/or platform will fix http://hackage.haskell.org/trac/hackage/ticket/791 ("Large libraries not installable on OS X")?
15:00:26 <lpsmith> mzero, yeah I didn't have a 7.0 cabal command :)
15:00:32 <lpsmith> good to know, though
15:00:35 <edwardk> haskell is an easier path to understanding category theory than category theory is a path to understand haskell. ;)
15:00:53 <mzero> there was some e-mail about that - I think the machinery to handle it is in 7.0.3 but I think there is also a needed cabal update to make it all work
15:01:36 <monochrom> the road to category theory is torturous. if you see buddha, kill buddha. if you see monad, kill monad.
15:01:58 <companion_cube> next step: the Haiku monad
15:02:22 <companion_cube> or rather, the Koan monad
15:02:42 <azaq23> there's no "return" haiku.
15:03:13 <monochrom> hahaha
15:03:23 <Bella> okay i just clicked 'paste' button
15:03:31 <Bella> then how am i gonna show my codes here?
15:03:46 <mzero> just paste the URL to the page here, Bella
15:04:14 <mzero> http://hpaste.org/45115/error_with_case_statements
15:04:16 <mzero> there
15:04:21 <Bella> ooh ok
15:04:32 <Bella> http://hpaste.org/45115/error_with_case_statements
15:04:39 <Bella> ooh how did u know my page?
15:04:50 <c_wraith> Bella: not many new posts :)
15:04:53 <benmachine> hpaste has a list of all recent pastes
15:04:55 <Bella> ooh
15:05:03 <Bella> so im trying to do case statements
15:05:21 <Bella> but keep giving me parse error on input key
15:05:54 <Bella> i am very new in this
15:05:55 <mzero> well, first - you don't need the { on line 22
15:05:59 <Bella> okay
15:06:02 <mzero> nor the closer on 28
15:06:07 <benmachine> Bella: are you using tabs? often mixing tabs and spaces can confuse ghc
15:06:09 <Bella> ok
15:06:16 <Bella> oh really?
15:06:17 <Bella> ooh
15:06:26 <mzero> (no brackets if you are using indent based layout)
15:06:32 <hpc> Bella: ghc says a tab is 8 spaces
15:06:33 <mzero> yes - use ONLY spaces
15:06:40 <Bella> ooh
15:06:42 <monochrom> tabs are fine in this file
15:07:12 <monochrom> I would rather say a mix of {} and layout is more confusing.
15:07:17 <conal> mzero: "cabal: There is no package named 'haskell-platform'."
15:07:55 <hpc> monochrom: it would be if anyone used {} as anything other than a golf trick
15:07:57 <hpc> ;)
15:07:58 <conal> mzero: what's a "7.0 compatible cabal command"? i had ghc 7.0.2.
15:08:05 <Bella> so..do my codes fine? only except spaces?
15:08:17 <Bella> *are my codes fine? only except spaces?
15:08:51 <dcoutts_> conal: cabal-install-0.8 or 0.10 will work with ghc-7, the haskell-platform package is not on hackage (since cabal-install cannot yet install all of it)
15:09:12 <mzero> where is it, dcoutts_ ? from the source installer?
15:09:19 <mzero> http://hackage.haskell.org/platform/linux.html
15:09:23 <monochrom> indeed, I don't get any parse error, only a type error. tabs, spaces, layouts, {}s not a problem here
15:09:31 <conal> dcoutts_: thx!
15:09:37 <Bella> ooh
15:09:42 <mzero> Bella - no, your final return is probably not what you want
15:09:49 <dcoutts_> mzero: right
15:10:01 <monochrom> if you "return(t2)" at the end, the type is IO Table not IO ().
15:10:14 <lpsmith> conal, haskell-platform package is available in the haskell platform source distro
15:10:22 <dcoutts_> mzero: when I generalise the dep solver to look at other kinds of deps, like build-tools, then we'll be able to cabal install haskell-platform
15:10:30 <mzero> Bella - ask yourself: What do you want to do with this new, modified Table after the "add key val t" has run?
15:10:55 <mzero> dcoutts_ is that the point at which cabal replaces every other make-tool on the planet?  :-)
15:11:44 <Bella> that's the problem because in the question paper it stated type loop :: Table -> IO()
15:11:55 <Bella> that's what im stuck
15:12:06 <conal> lpsmith: thx. do you know a url for the distro? not finding on http://hackage.haskell.org/platform/
15:12:17 <mzero> what do *you* think should happen here? just tell us in English
15:12:46 <mzero> so the user just entered "add", "apples", "red"
15:12:51 <mzero> now what comes next?
15:13:00 <monochrom> then don't "return(t2)".  return() instead.
15:13:09 <Bella> ooh
15:13:13 <Bella> but 
15:13:33 <Bella> doesn't that mean return() means zero or nil or something?
15:13:33 <monochrom> but you need to communicate t2? well find some other way.
15:13:43 <lpsmith> conal, http://lambda.galois.com/hp-tmp/2011.2.0.0/haskell-platform-2011.2.0.0.tar.gz
15:13:50 <monochrom> > "()" == "0"
15:13:51 <lambdabot>   False
15:13:52 <Bella> ooh i think i get it
15:13:53 <conal> lpsmith: thx much.
15:13:53 <monochrom> > "()" == "nil"
15:13:54 <lambdabot>   False
15:14:15 <mzero> Bella - what should happen next?
15:14:17 <EvanR-work> haskell is great because those answers make sense
15:14:18 <mzero> in your mind
15:14:42 <hpc> Bella: stylistic concern that could help this make more sense:
15:14:48 <conal> gotta run now. later, all.
15:14:49 <EvanR-work> i hate the bizarre logic of systems where everything equals everything else, sometimes
15:14:52 <hpc> Bella: instead of "return()" write "return ()
15:15:25 <hpc> Bella: () is its own value; the space makes it more clear, instead of it looking like return is a java function with no arguments or something
15:15:28 <hpc> > ()
15:15:29 <lambdabot>   ()
15:15:41 <lpsmith> conal,  it appears that link was only available under the "linux" option
15:15:50 <jmcarthur> > (0.0 == 0.0, 1.0/0.0 == 1.0/0.0)
15:15:51 <lambdabot>   (True,True)
15:15:59 <Bella> mzero - if im not wrong the next thing happens after adding then those values added in Table..
15:15:59 <monochrom> indeed there is no logic in "0 means empty, [] means empty, therefore 0=nil". only word games. word games are even worse than symbol games.
15:16:04 <jmcarthur> oh duh
15:16:10 <jmcarthur> > (0.0 == 0.0, 0.0/0.0 == 0.0/0.0)
15:16:10 <lambdabot>   (True,False)
15:16:15 <ion> > 1.0/0.0 == 2.0/0.0
15:16:15 <lambdabot>   True
15:16:15 <jmcarthur> EvanR-work: ^^
15:16:29 <monochrom> "meaningful word" does not exist. "plain english" is convoluted not plain.
15:16:32 <jmcarthur> EvanR-work: isn't floating point lovely :)
15:16:58 <EvanR-work> jmcarthur: well at least haskell genuinely reproduces the model known as floating point... i.e. ieee754
15:17:10 <Bella> what's the difference between return() and return ()? spaces matter as well here?
15:17:12 <EvanR-work> and its not some bizarre half assed reproduction
15:17:18 <jmcarthur> it violates properties that i like to depend on though
15:17:22 <monochrom> space does not matter there.
15:17:36 <jmcarthur> a = b  =>  forall f. f a = f b
15:17:37 <monochrom> I wrote return() because you liked to write return(x)
15:17:57 <dcoutts_> mzero: :-)
15:18:25 <jmcarthur> counterexample being   a = 0.0; b = 0.0; f = (1.0/)
15:18:31 <mzero> Bella - there is no difference between return() and return ()  --- but that is all a red herring
15:18:48 <EvanR-work> jmcarthur: yeah so == is weird ;0
15:18:52 <mzero> your sentence to me seems cut off: "... the next thing happens after adding then those values added in Table.."
15:19:31 <mzero> what should happen with t2?
15:24:52 <Bella> i only use spaces and still got error saying Parse error in pattern: putStrLn
15:25:33 <Cale> Bella: can you put your code on hpaste or something?
15:25:41 <ion> And the error message
15:25:56 <Cale> oh, it is...
15:26:07 <Cale> there are tab characters in this code
15:26:16 <ion> hpaste should say â€œplease donâ€™t forget to attach the error message with the codeâ€
15:26:16 <Bella> there were
15:26:20 <Cale> oh
15:26:21 <mtnviewmark> is putStrLn (line 23) more indented than the "add" of the line before it?
15:26:22 <Cale> okay...
15:26:33 <Bella> yes mtn
15:26:43 <Bella> should i not indent it?
15:26:53 <Bella> im so confused with these indetations thingy
15:26:57 <mzero> no, their should be
15:27:14 <mzero> Bella - don't you indent your code in other languages? 
15:27:18 <mzero> it is pretty much the same
15:27:24 <mzero> only - required
15:27:32 <mzero> (if you omit the curly-braces, that is)
15:27:33 <Bella> like in java? and c
15:27:34 <Bella> yeah
15:27:41 <Bella> but not much in haskell
15:27:51 <aristid> haskell is somewhat less strict than python
15:28:03 <Bella> my lecturer advised not try think of haskell like java or c
15:28:26 <Bella> trying not to here..hence..hard for me to grasp this new concept
15:28:35 <edwardk> bella: in haskell indentation after "where", "in", "of" and "let" has special meaning. the indentation of the next symbol after that keyword sets sort of the baseline, then anything else indented to precisely that depth acts like it as a semicolon in front it it, and outdenting more (indenting less) inserts a virtual closing brace.
15:29:06 <Cale> Bella: The basic idea is that the children of any construct should be indented more than it, and siblings should be on the same level
15:29:07 <edwardk> bella: but you need to be careful with tabs in your source code, because the haskell compiler will always act as if it has 8 character tabstops
15:30:27 <Bella> okay lemme paste it again but im sure i used spaces only
15:30:30 <Bella> umm..
15:31:49 <mzero> are you using GHC, Bella, or Hugs?
15:32:05 <Bella> http://hpaste.org/45116/parse_error_in_pattern_putstr
15:32:12 <Bella> ghci mzero
15:32:19 <Bella> ghc
15:32:33 <mauke> broken indentation in line 65
15:32:38 <ion> There are tabs all over the file.
15:32:50 <Axman6> Bella: save has a tab in it
15:33:01 <Axman6> so does load
15:33:06 <Bella> but save and load work..
15:33:12 <Axman6> and loop has a tonne
15:33:57 <Bella> i pressed spacebar keyboard only for spaces..not tab..
15:34:01 <Axman6> [(a',b) | a' /= a] doesn't make much sense
15:34:10 <Axman6> is that even legal?
15:34:18 <mzero> Bella - your editor may auto-tab -- you probably need to configure your editor to do away with tabs
15:34:20 <mzero> but that aside
15:34:30 <mzero> you've added tons of extra indenting here, which is a problem
15:34:42 <mauke> > ["Axman6" | True]
15:34:43 <lambdabot>   ["Axman6"]
15:34:53 <hpc> Axman6: do {guard a' /= a; return (a', b)}
15:35:01 <mauke> hpc: precedence
15:35:01 <mzero> lines 65 is indent and line 69 indent are wrong -- they a
15:35:04 <hpc> provided a, a', and b are in scope
15:35:18 <jmcarthur> > let a = 1; a' = 1; b = 2 in [(a', b) | a' /= a]
15:35:19 <lambdabot>   []
15:35:20 <mzero> think this: If you are indenting you are continuing the construct from the previous line
15:35:25 <hpc> mauke: eh, the Axman6 literate compiler can parse precedence without parens
15:35:26 <jmcarthur> > let a = 1; a' = 0; b = 2 in [(a', b) | a' /= a]
15:35:26 <lambdabot>   [(0,2)]
15:35:44 <mzero> indenting after "do" or after "of" makes sense -- the indentend lines are part of the "do" or the "case...of" construction
15:36:13 <mzero> indenting after pustStrLn "Key : " shouldn't make sense -- the following lines are part of the putStrLn function application
15:36:57 <Bella> oh thats weird cos when i pasted the code it became like that
15:37:16 <Bella> cos my is indented after putStrLn "Key"
15:37:23 <Bella> *cos mine
15:37:41 <Bella> not supposed to be like that in paste
15:37:41 <ion> Your editor may use a broken tab width.
15:37:49 <Bella> ok
15:38:03 <Bella> what editor is the best to use for writing haskell?
15:38:07 <Bella> cos im using notepadd++
15:38:39 <allbery_b> "the one you're most confortable and productive in"
15:38:40 <ion> 0) Donâ€™t use tabs. 1) Donâ€™t use any other tab width than 8.
15:39:03 <allbery_b> but yes, set it up right to avoid problems
15:40:20 <Bella> forget the paste it became like that when i pasted
15:40:25 <Bella> not supposed to be like that
15:40:39 <ion> Thatâ€™s probably how Haskell sees it, too.
15:42:31 <Bella> oh dear...
15:42:34 <Bella> nevermind...
15:43:56 <benmachine> iokl
15:50:08 <Bella> oh thank God
15:50:11 <Bella> it works now
15:50:24 <Bella> i extra carefully put spaces
15:50:42 <Bella> thanks everyone who helped me here
15:51:12 <Bella> thanks sooo much
15:51:15 <Cale> Bella: Which editor are you using? Most of them can be configured to replace tabs with spaces.
15:51:20 <Bella> i might be here again
15:51:30 <Bella> still notepad++
15:51:30 <niteria> is there an easy way to add memoization to recursive function?
15:51:32 <Cale> Yeah, feel free to ask any questions you might have
15:51:45 <Bella> okay i'm gonna resume my assignment
15:51:52 <Cale> niteria: The data-memocombinators package on Hackage provides some useful tools.
15:51:53 <Bella> wish me luck!
15:51:55 <Bella> lol
15:52:02 <Cale> Bella: yep :)
15:52:39 * Cale is trying to work out how to use the cairo and opengl bindings together.
15:53:44 <Cale> anyone have any information about doing that? You're apparently supposed to be able to use Cairo surfaces as OpenGL textures somehow.
15:54:07 <dcoutts_> Cale: I expect it's all via bitmaps, whichever direction you go
15:54:50 <dcoutts_> use cairo to render into a buffer with a known bitmap layout, convert that to a gl bitmap source
15:54:57 <hpc> this sounds like a job for unsafeCoerce? (if the types are sufficiently low-level)
15:55:04 <dcoutts_> see how they do it in C first
15:55:34 <hpc> i would think cairo surfaces just use the same memory layout as opengl textures
15:55:44 <dcoutts_> Cale: or there's also the rather experimental gl backend to cairo, but I'm not sure if that works
15:55:51 <dcoutts_> hpc: I would not assume that
15:56:00 <dcoutts_> there are lots of variables
15:56:07 <Cale> dcoutts_: Yeah, maybe that's what I heard about.
15:56:15 <glguy> byorgey: Are you around?
15:56:16 <dcoutts_> e.g. padding, pre-multiplied alpha etc
16:03:18 <alpounet> Cale, you may want to ask on #haskell-game
16:17:32 <kamaji> Is there a typeclass for Real numbers?
16:17:38 <kamaji> I always forget the answer to this question :\
16:17:49 <minh> Hi there! I just started coding in Haskell and use emacs (haskell-mode) for that. Syntax-Highlighting works fine in the source-file but I wondered how to get appropriate fonts in the REPL (inf-haskell)?
16:17:53 <kamaji> nevermind, Num is good...
16:18:13 <benmachine> kamaji: there are lots of type classes, one of which is called Real
16:18:24 <benmachine> but there is some agreement that they are generally poorly named :P
16:18:55 <ddarius> Real is perhaps the most ridiculously named.
16:19:31 <kamaji> Is it not real?
16:19:43 <Anpheus> It's a floating point isn't it?
16:19:50 <kamaji> I thought that was Floating
16:19:52 <ddarius> @src Real
16:19:52 <lambdabot> class  (Num a, Ord a) => Real a  where
16:19:52 <lambdabot>     toRational      ::  a -> Rational
16:20:25 <benmachine> > toRational pi
16:20:26 <lambdabot>   884279719003555 % 281474976710656
16:20:33 <Anpheus> Clearly pi is rational.
16:20:36 <Anpheus> :D
16:20:41 <kamaji> close enough for government work
16:20:51 <kamaji> it's 3 in some states :D
16:21:15 <Anpheus> Real does seem pretty ridiculous...
16:21:28 <Anpheus> In order to define an instance of Real, it has to implement toRational? That's nuts.
16:21:35 <Bella> http://hpaste.org/45117/parse_error_input
16:21:43 <Bella> under loop
16:21:52 <Bella> im trying to display the data that i add
16:21:58 <Bella> but it doesnt work
16:22:09 <mzero> get rid of your curly brackets
16:22:18 <Bella> ok
16:22:34 <ion> and tabs
16:22:35 <mzero> looks to me that after "add" the function loop returns
16:22:37 <Bella> but i google some of them they put curly brackets
16:22:42 * hackagebot hoopl 3.8.7.0 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.8.7.0 (NormanRamsey)
16:22:43 <kamaji> how do I get elements out of a record?
16:23:06 <kamaji> I only need 2 of them and there are 7
16:23:09 <hpc> kamaji: say you have data Foo = Bar {baz :: Quux}
16:23:15 <mzero> if you want the curlies, put them like    case answer of {       .....      } 
16:23:16 <hpc> kamaji: baz :: Foo -> Quux
16:23:29 <hpc> blah = Bar 5; baz blah = 5
16:23:31 <kamaji> hpc: oh, that happens automatically, right?
16:23:32 <mzero> I think "display" is aligned with the { , not the "add"
16:23:39 <mzero> but that isn't your problem here
16:23:41 <hpc> kamaji: yep
16:23:43 <kamaji> hpc: thanks!
16:23:56 <Bella> just removed the curly 
16:24:07 <mzero> Bella: look at the line    let ts = ......
16:24:12 <Bella> still not working saying ts not in scope? is it because if ts?
16:24:15 <mzero> ask yourself this: What uses ts?
16:24:16 <Bella> uhuh
16:24:40 <mzero> ts isn't in scope - it was only computed in the "add" branch of the code
16:24:47 <mzero> in the "display" branch there is no ts!
16:24:52 <Bella> ooh
16:25:05 <Bella> so how am i gonna display the list i added?
16:25:17 <mzero> so - what do you want to happen (in UI terms) after ts is computed?
16:25:24 <mzero> what should the user see next?
16:25:33 <Bella> in my question
16:25:38 <Bella> after add
16:25:51 <Bella> the program should prompts 'Command' again
16:25:58 <mzero> ah - what code does that?
16:26:10 <Bella> which means
16:26:11 <mzero> or rather ... what is the name of the function that does that?
16:26:43 <int80_h> :t liftIO
16:26:43 <lambdabot>     Ambiguous occurrence `liftIO'
16:26:43 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
16:26:43 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
16:27:01 <int80_h> :t Control.Monad.Error.liftIO
16:27:01 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
16:27:03 <Bella> is it recursion of loop function?
16:27:56 <mzero> try that -- what do you think this call to loop should take as an argument?
16:28:09 <Bella> loop ts..
16:28:11 <Bella> ?
16:28:13 <Bella> ooh
16:28:24 <mzero> ^..^
16:28:36 <Bella> okay i think i understand
16:28:41 <Bella> lemme fix my code
16:28:59 <mzero> and -- while you're at it ... what should the user see after "display" has printed the table? 
16:29:10 <Bella> umm..
16:29:26 <Bella> the data of table
16:29:31 <mzero> and after that?
16:29:52 <Bella> so thats why i type in display ts but ts is not in scope..
16:29:53 <Bella> so..
16:30:08 <mzero> display is in scope...
16:30:24 <Bella> soo
16:30:26 <mzero> but AFTER the table prints out --- what do you expect (want?) the user experience to be next?
16:30:32 <Bella> instead of return()
16:30:35 <mzero> should the program exit?
16:30:37 <Bella> i replace with loop ts..
16:30:49 <Bella> no..
16:30:51 <mzero> so ---- work with me
16:30:59 <Bella> i am i am hehe
16:31:02 <mzero> what did you replace the return() on line 65 with?
16:31:10 <Bella> i replace with..
16:31:13 <Bella> loop ts?
16:31:16 <mzero> good
16:31:18 <Bella> :D
16:31:35 <mzero> so what does that do? it recursively calls loop with ts, which is the modified table
16:31:38 <mzero> right?
16:31:49 <Bella> right!
16:31:50 <mzero> in *that* recursive call --- what is the table called?
16:32:03 <mzero> once *inside* that recurisve call I mean
16:32:14 <Bella> loop t..?
16:32:18 <mzero> right
16:32:23 <mzero> so what needs to be displayed?
16:32:30 <Bella> oooh
16:32:33 <Bella> so soo
16:32:36 <Bella> display t??
16:32:39 <mzero> right
16:32:42 <Bella> :D :D
16:32:45 <mzero> now - one more thing
16:32:51 <mzero> and you're almost home free
16:33:12 <mzero> after    display t    --- what should happen next? program exit or more "Command : " prompts?
16:33:19 <Bella> oh oh
16:33:29 <byorgey> glguy: ?
16:33:47 <Bella> more command prompts
16:33:51 <Bella> so i need to loop again
16:34:01 <Bella> i have some more commands left
16:34:18 <Bella> like value remove save clear load and quit
16:35:11 <Bella> but i think i get the flow now
16:35:11 <Bella> :D
16:35:18 <glguy> byorgey: I was curious if the species library could be used for things like enumerating labelled lists with conditions or if that was outside the scope of the library. Say: lists of elements where the third element wasn't '3'
16:35:51 <mzero> Bella: yay!
16:35:57 <Bella> :D :D
16:36:09 <Bella> I'm so happy I understand now
16:36:15 <kamaji> I'm not sure what the best way to represent a day is in haskell, Data.Time is a bit confusing
16:36:42 <Bella> Lemme code all these. Hope the rest goes well!
16:36:57 <Bella> Glad having u around mzero.
16:36:58 <Bella> :D
16:36:58 <benmachine> kamaji: confusing how?
16:36:59 <Rotaerk> kamaji, represent the time of day you mean?
16:37:19 <benmachine> also, time *is* confusing :P
16:37:22 <byorgey> glguy: You could probably do it but that sort of thing would be contrived and wouldn't scale at all.  So I think the answer is that it's outside the scope of the library.
16:37:28 <kamaji> benmachine: I know ^^
16:37:31 <kamaji> A specific day
16:37:37 <Rotaerk> benmachine, don't go on a rant about the philosophical mysteries of time, now
16:37:42 <byorgey> glguy: part of the point is that species "don't care" what labels you use
16:37:51 <Bella> might be back again if i have problem
16:37:59 <Bella> cheers mzero!
16:38:00 <benmachine> Rotaerk: http://hackage.haskell.org/package/acme-now
16:38:01 <Bella> :D
16:38:15 <Rotaerk> oh god..
16:38:16 <Rotaerk> lol
16:38:18 <kamaji> Well actually I think it was mostly to do with the Julian calendar
16:38:41 <kamaji> I guess I can just use Date.Time.Calendar.Day ?
16:43:10 <linusoleander> Does haskell have real threads?
16:43:37 <c_wraith> linusoleander: depends on what you mean by "real".  The answer is yes, but the details are more subtle.
16:43:53 <linusoleander> Is there anything more then green threads?
16:43:57 <hpc> haskell has GHC threads and OS threads
16:44:03 <hpc> er, GHC has
16:44:21 <c_wraith> linusoleander: there are two runtimes that ship with GHC.  If you compile with -threaded, you get a true threaded runtime...  That still multiplexes green threads.
16:44:47 <c_wraith> It just can execute more than one at a time.
16:45:01 <jmcarthur> linusoleander: if built with -threaded, ghc provides n green threads on m OS threads (where you would normmaly choose m to coincide with the number of cores in the system)
16:45:33 <linusoleander> Perfect, thanks!
16:45:35 <hpc> is the last core slowdown fixed?
16:45:46 <jmcarthur> hpc: not yet, afaik
16:46:18 <hpc> i would think devs would be jumping on that issue
16:46:23 <hpc> it sounds like a fun one to debug
16:46:24 <jmcarthur> but that's only a linux issue anyway
16:46:27 <jmcarthur> well, there is some progress
16:46:50 <hpc> ooh, how is it only a linux issue?
16:46:55 <jmcarthur> i've heard that the concurrent gc that marlow is working on will probably fix it (for reasons i was never told)
16:47:01 <copumpkin> djahandarie: you doing GSOC?
16:47:17 <jmcarthur> i'm pretty sure it's been demonstrated that it's not happening on OS X, at least
16:47:47 <c_wraith> are there many 16 core OS X machines to test on?
16:48:01 <hpc> c_wraith: there's definitely 12-core ones
16:51:47 <djahandarie> copumpkin, negative. Can't work two jobs :p
16:51:50 <Bella> uh uo
16:51:52 <Bella> uh oh
16:51:55 <Bella> problem
16:52:02 <kamaji> What's the best way to create a record from a list of strings?
16:52:20 <hpc> kamaji: what do you mean?
16:52:42 <kamaji> hpc: well I have a CSV file, and I want to read all the fields into a record
16:52:58 <kamaji> I can just split it on commas to get the individual values, do I have to convert each type individually?
16:53:28 <hpc> kamaji: it depends on how the data is organized in the file
16:53:47 <hpc> if it's a spreadsheet or something, [[Foo]] will suffice
16:54:09 <hpc> if it's columns Foo, Bar, Baz, you would probably make data Record = Row Foo Bar Baz
16:54:15 <hpc> and have [Record]
16:54:34 <Bella> http://hpaste.org/45117/parse_error_input
16:54:36 <kamaji> hpc: it's columns, but I don't know a good way to get Foo Bar and Baz out from the string values
16:54:40 <benmachine> kamaji: you may have to convert each type individually, yes
16:54:42 <hpc> kamaji: read
16:54:43 <hpc> :t read
16:54:44 <lambdabot> forall a. (Read a) => String -> a
16:54:53 <benmachine> using reads or your own awesome parser or whatever
16:55:04 <hpc> > read "123" :: Int
16:55:05 <lambdabot>   123
16:55:16 <hpc> > read "3.14159" :: Ratio Int Int
16:55:16 <lambdabot>   `GHC.Real.Ratio' is applied to too many type arguments
16:55:20 <hpc> > read "3.14159" :: Ratio
16:55:21 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
16:55:23 <hpc> > read "3.14159" :: Ratio Int
16:55:24 <lambdabot>   *Exception: Prelude.read: no parse
16:55:29 <ion> bella: Do you want â€˜display t loop tâ€™ or â€˜do display t; loop tâ€™?
16:55:29 <hpc> > read "3.14159" :: Rational
16:55:30 <lambdabot>   *Exception: Prelude.read: no parse
16:55:32 <benmachine> Bella: you seem to have missed out 'do' after "display" ->
16:55:33 <hpc> argh
16:55:38 <Bella> ooh
16:55:47 <hpc> kamaji: you get the point ;)
16:55:49 <Bella> i thought thats not necessary..
16:55:53 <benmachine> > read "3.14159" :: Double
16:55:54 <lambdabot>   3.14159
16:56:03 <benmachine> > read "7 % 2" :: Rational
16:56:04 <lambdabot>   7 % 2
16:56:18 <hpc> ah
16:56:18 <Bella> what does do really do actually? is it like do while in java?
16:56:38 <ion> bella: Itâ€™s syntactic sugar for expressions based on the >>= (bind) operator.
16:56:44 <Bella> ooh
16:56:45 <benmachine> Bella: do is a way of writing monadic code (e.g. IO code) that is more convenient
16:56:46 <kamaji> hpc: yeah, but i'm getting odd errors with read
16:57:31 <hpc> kamaji: type errors?
16:57:32 <ion> â€˜do a <- foo; barâ€™ means â€˜foo >>= \a -> barâ€™
16:57:35 <Bella> yay works now
16:57:39 <Bella> thanks ion!
16:57:42 <azaq23> @undo do { x <- y; p; return x }
16:57:42 <lambdabot> y >>= \ x -> p >> return x
16:57:47 <ion> â€˜do foo; barâ€™ means â€˜foo >>= \_ -> barâ€™ or just â€˜foo >> barâ€™
16:58:18 <pr> @do a >> b >> c
16:58:18 <lambdabot> do { do { a; b}; c}
16:58:22 <benmachine> kamaji: reads is better for handling errors
16:58:32 <hpc> haha pr
16:58:36 <benmachine> iiinteresting
16:58:54 <hpc> do do that voodoo that you do so well
16:58:57 <benmachine> @do doesn't know about associativity I guess (and this entire sentence parses as a valid expression)
16:58:57 <lambdabot> doesn't know about associativity I guess (and this entire sentence parses as a valid expression)
16:59:09 <azaq23> lol
16:59:14 <hpc> > let voodoo = "you do" in do do voodoo
16:59:15 <lambdabot>   "you do"
16:59:37 <hpc> benmachine: well played :D
16:59:42 <kamaji> hpc: yeah type errors :\
16:59:44 <benmachine> > do let in do let {}; do return ()
16:59:44 <lambdabot>   No instance for (GHC.Show.Show (m ()))
16:59:44 <lambdabot>    arising from a use of `M138269957...
16:59:47 <benmachine> aw
16:59:51 <benmachine> > do let in do let {}; do []
16:59:52 <lambdabot>   []
17:00:35 <hpc> kamaji: my guess would be you are reading things into stuff that isn't an instance of Read
17:00:38 <hpc> :t read
17:00:39 <lambdabot> forall a. (Read a) => String -> a
17:00:44 <hpc> note "Read a =>"
17:01:18 <kamaji> hpc: i'm just reading ints and floats
17:01:24 <hpc> kamaji: oh
17:01:33 <hpc> kamaji: well, pastebin some code then :D
17:01:49 <kamaji> will do
17:02:02 <azaq23> > let in 42
17:02:03 <lambdabot>   42
17:02:03 <benmachine> > do let in [] where
17:02:04 <lambdabot>   <no location info>: parse error on input `where'
17:02:07 <benmachine> aw
17:02:09 <benmachine> > do let in [] where{}
17:02:10 <lambdabot>   <no location info>: parse error on input `where'
17:02:12 <benmachine> aww
17:02:20 <hpc> where doesn't bind to expressions
17:02:25 <benmachine> hpc: good point
17:02:26 * benmachine silly
17:02:46 <niteria> let part k n = memo2 integral integral part' k n where part' k n = if n == k then 1 else if k > n then 0 else (part (k+1) n) + (part k (n-k))
17:02:53 <niteria> why won't it memoize
17:02:55 <benmachine> > let ()=() where in do []
17:02:55 <lambdabot>   []
17:03:03 <hpc> > do let foo=f where{} in let in "foof"
17:03:04 <lambdabot>   "foof"
17:03:09 <niteria> :module +Data.MemoCombinators
17:03:10 <hpc> > do let foo=f where in let in "foof"
17:03:11 <lambdabot>   "foof"
17:03:29 <hpc> [sudo password for niteria]
17:03:36 <niteria> abc
17:03:39 <hpc> :D
17:03:57 <niteria> but seriously
17:04:09 <niteria> what's wrong
17:04:38 <niteria> there is only an example for unary function
17:05:58 <mm_freak_> > let where x = () in ()
17:05:58 <lambdabot>   <no location info>: parse error on input `where'
17:06:22 <mikeg> Do has special pattern match failure - does that still work for the desugared lambda form?
17:06:27 <mauke> > let {} where {} in ()
17:06:28 <lambdabot>   <no location info>: parse error on input `where'
17:06:29 <hpc> mikeg: no
17:06:35 <azaq23> > let f = p where p = 10 in p
17:06:36 <lambdabot>   p
17:06:45 <mauke> > let {_ = ()} where {} in ()
17:06:46 <lambdabot>   <no location info>: parse error on input `where'
17:06:46 <azaq23> > let f = p where p = 10 in f
17:06:47 <lambdabot>   10
17:06:53 <shachaf> @undo do { Just x <- y; return x }
17:06:53 <lambdabot> y >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
17:07:01 <hpc> @undo do {Just x <- foo; return x}
17:07:01 <lambdabot> foo >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
17:07:03 <mauke> > let {_ = () where {}} in ()
17:07:03 <lambdabot>   ()
17:07:22 <hpc> mauke: what
17:07:37 <mauke> > let _ = () where in ()
17:07:37 <lambdabot>   ()
17:07:40 <manateeUser> Good morning!
17:07:45 <ion> > let a = b where b = 1; c = 2 in c -- is that where { b = 1; c = 2 } or where b = 1 }; â€¦
17:07:45 <lambdabot>   c
17:07:56 <hpc> manateeUser: good evening!
17:07:58 <mm_freak_> > let in find const empty
17:07:59 <lambdabot>   Ambiguous occurrence `empty'
17:07:59 <lambdabot>  It could refer to either `Control.Applicative...
17:08:06 <manateeUser> hpc: Haven't sleep? 
17:08:07 <manateeUser> :)
17:08:14 <mm_freak_> > let in find const Control.Applicative.empty
17:08:14 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:08:15 <lambdabot>         against inferred type ...
17:08:20 <benmachine> > let a = c where b = 1; c = 2 in a
17:08:21 <lambdabot>   2
17:08:39 <mm_freak_> > let in find id Control.Applicative.empty
17:08:40 <lambdabot>   Nothing
17:08:48 <niteria> let part = memo2 integral integral part' where part' k n = if n == k then 1 else if k > n then 0 else (part (k+1) n) + (part k (n-k))
17:08:55 <hpc> > let (a,b,c,d,e,f,g) = (b,c,e,f,d,1,f) in (a,b,c,d,e,f,g)
17:08:56 <lambdabot>   (1,1,1,1,1,1,1)
17:08:59 <hpc> aw yeah!
17:09:35 <hpc> :t find
17:09:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:09:45 <hpc> :t Control.Applicative.empty
17:09:46 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
17:10:03 <kamaji> hpc: http://pastebin.com/FgLzCWdg
17:10:04 <mm_freak_> > let in and (iterate id False)
17:10:04 <mm_freak_> lol
17:10:04 <lambdabot>   False
17:11:17 <hpc> kamaji: remove the type signatures inside fromList
17:11:24 <hpc> kamaji: it can infer them on its own
17:11:34 <kamaji> hpc: which bit is the type signature?
17:12:11 <hpc> http://pastebin.com/EZwUrqF4 -- kamaji 
17:12:14 <azaq23> > let (a, b, c) = (c : b, 'k' : [c], 'p') in (a, b, c)
17:12:14 <mm_freak_> haskell really helps with boredom
17:12:14 <lambdabot>   ("pkp","kp",'p')
17:12:35 <mm_freak_> > let x = 2 + 2 where 2 + 2 = 5 in x
17:12:36 <lambdabot>   5
17:13:04 <kamaji> hpc: it still has the type error though
17:13:14 <hpc> > let x = 1 / 0 where 1 / 0 = "oh god, why" in x
17:13:14 <lambdabot>   "oh god, why"
17:13:24 <azaq23> > const True "there are four lights"
17:13:25 <lambdabot>   True
17:14:08 <hpc> kamaji: oh, (Floating a, Read a)
17:14:30 <kamaji> hpc: oho, thanks
17:14:46 <kamaji> I thought I tried that too >_>
17:15:13 <ion> > let numLights = 4; (==) = const . const True in numLights == 5
17:15:15 <lambdabot>   True
17:15:37 <mm_freak_> > splitAt 7 . drop 27 . map head $ cake
17:15:39 <lambdabot>   ("TOOTOOT","ASCIICAT")
17:15:45 <mm_freak_> classic one
17:15:59 <int80_h> http://hpaste.org/45119/working_off_a_yesod_example_fi
17:16:15 <kamaji> ahh it's working ;_;
17:16:17 <kamaji> hpc: thanks again!
17:16:51 <hpc> > there are four lights
17:16:52 <lambdabot>   True
17:16:56 <hpc> > there are five lights
17:16:58 <lambdabot>   False
17:17:18 <niteria> is Int a word-sized integer?
17:17:23 <hpc> niteria: yes
17:17:31 <hpc> niteria: in GHC, at least
17:17:38 <mm_freak_> niteria: usually, but that assumption is not portable
17:17:40 <hpc> it is only guaranteed 30 bits?
17:17:46 <mm_freak_> niteria: if you want to be specific, use Data.Int or Data.Word
17:17:50 <azaq23> @type (there, are, four, lights)
17:17:50 <lambdabot> forall t t1 t2. (t -> t1 -> t2 -> t1, Bool, Bool, Bool)
17:17:59 <hpc> azaq23: blast!
17:18:37 <hpc> > there are 11 lights
17:18:37 <lambdabot>   11
17:18:37 <benmachine> > four
17:18:37 <lambdabot>   True
17:18:55 <benmachine> > lights
17:18:57 <lambdabot>   False
17:19:07 <ion> :t there
17:19:08 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> t1
17:19:08 <ion> :t are
17:19:09 <lambdabot> Bool
17:19:33 <hpc> are = lights = five = False
17:19:45 <hpc> there = \_ n _ -> n; four = True
17:20:00 <hpc> obvious implementation is obvious :P
17:20:02 <benmachine> @djinn t -> t1 -> t2 -> t1
17:20:02 <lambdabot> f _ a _ = a
17:20:04 <ion> Yes, that was already figured out. ;-)
17:20:08 <benmachine> woo
17:20:12 <benmachine> @djinn Bool
17:20:12 <lambdabot> f = False
17:22:44 <azaq23> somebody should write a bot that messages lambdabot repeatedly some @let commands for the first
17:24:50 <manateeUser> Bye, it's time to work, write Python code... :)
17:26:47 <int80_h> http://hpaste.org/45119/working_off_a_yesod_example_fi
17:27:13 <int80_h> If I was stuck in another language, Python would be a good place to be stuck.
17:27:37 <hpc> i think i would rather be stuck in lisp
17:27:51 <int80_h> ya ya. But that's just crazy dreaming.
17:27:56 <hpc> that is an easy language to write other languages in ;)
17:28:02 <int80_h> ah yes.
17:28:53 <ion> Iâ€™d hate being stuck in Python.
17:29:39 <int80_h> could be *Java*
17:29:41 <int80_h> could be worse
17:30:32 <hpc> eh, java isn't c++ at least
17:30:38 <hpc> you could switch to clojure
17:32:08 <int80_h> hpc: any chance I could get you to take a look at my problem I posted?
17:32:26 <hpc> i don't know yesod
17:34:35 <int80_h> oh, no worries.
17:34:49 <int80_h> I posted to beginners, and haskell-cafe
17:35:04 <int80_h> if that doesn't do anything, there's the web-developers mailing list as well.
17:35:27 <int80_h> I didn't want to *triple* post. I had a nagging feeling that cross-posting would be bad form.
17:35:35 <int80_h> but did it anyway
17:40:33 <Bella> http://hpaste.org/45120/save_problem_when_running_the
17:40:43 <Bella> problem when running 'save'
17:40:46 <Bella> saying
17:40:59 <Bella> ****Exception: text.txt openFile permission denied
17:41:02 <Bella> any idea guys?
17:41:40 <hpc> Bella: does it exist?
17:41:51 <hpc> does the current user have read priveledges?
17:42:03 <Bella> it doesn't.supposingly exist..
17:42:15 <Bella> tried in my school worked but at home says like that
17:42:49 <Bella> wait maybe it does exit..
17:42:51 <Bella> dunno
17:43:12 <Bella> its suppsed to display 'Saved' instead of that error
17:44:27 * int80_h waves
17:49:07 <Bella> nevermind think ive just fixed it
18:05:56 * hackagebot hslogger-template 2.0.0 - Automatic generation of hslogger functions  http://hackage.haskell.org/package/hslogger-template-2.0.0 (BrianLewis)
18:10:59 <roconnor> @type readInt
18:11:00 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
18:11:12 <roconnor> this is a retarded signature
18:11:27 <roconnor> should be: forall a. (Num a) => a -> (Char -> Maybe Int) -> String -> [(a, String)]
18:12:18 <roconnor> @type elemIndex
18:12:19 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
18:14:02 <mauke> rideEnt :: (Num a) => a -> (b -> Maybe a) -> [b] -> Maybe (a, [b])
18:14:40 <roconnor> ya
18:15:12 <roconnor> actually I don't know why the base parameter is the type of value being produce
18:15:24 <mauke> because you multiply by it
18:15:30 <roconnor> oh
18:15:30 <benmachine> roconnor: I think it's because isDigit and digitToInt fit nicely into it
18:15:43 <roconnor> benmachine: hmm
18:15:45 <benmachine> (the Char -> Bool and Char -> Int)
18:15:55 <roconnor> benmachine: clearly digitToInt is a big mistake
18:16:00 <benmachine> heh
18:16:07 <benmachine> mm, inclined to agree
18:16:19 <benmachine> apart from maybe with "clearly" and "big"
18:16:20 <benmachine> :P
18:16:25 <roconnor> :)
18:16:32 <accel> is there any project that compiles ahskell to the jvm?
18:16:55 <roconnor> what is the simplest way to do network stuff in Haskell?
18:17:06 <roconnor> still the ususal awful system.network stuff?
18:17:18 <benmachine> roconnor: what's your objection to network?
18:17:49 <roconnor> benmachine: no timeouts
18:18:12 <benmachine> System.Timeout?
18:18:17 <benmachine> or whatever it was
18:18:19 <JuanDaugherty> accel, bite your tongue, haskell is java for academics
18:18:41 <roconnor> benmachine: I don't see what that has to do with network
18:19:04 <benmachine> roconnor: I mean, surely you can implement timeouts yourself
18:19:12 <roconnor> ...
18:19:20 <roconnor> well, eventually perhaps
18:19:24 <roconnor> but then I have to get into threads
18:19:29 <roconnor> and forkIO vs forkOS
18:19:33 <roconnor> and whatnot
18:19:43 <roconnor> and all I want to do is time out if my connection fails after 60 seconds
18:19:51 <benmachine> there might be a socket option for it?
18:19:52 <roconnor> or I don't recieve anything
18:20:22 <roconnor> benmachine: last time I looked it either didn't exist or if it did exist it didn't worked
18:20:44 <benmachine> roconnor: it exists, but I offer no guarantees as to workingness, it might be that it's a connection timeout rather than a recv timeout
18:20:47 * benmachine checks some manpages
18:21:17 <roconnor> @hoogle RecvTimeOut
18:21:20 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
18:21:25 <roconnor> anyhow, that exists
18:21:29 <roconnor> but there is no way to use it
18:21:37 <roconnor> which is the most frustrating thing ever
18:21:44 <benmachine> no way to use it?
18:22:04 <benmachine> @hoogle setSocketOption
18:22:04 <lambdabot> Network.Socket setSocketOption :: Socket -> SocketOption -> Int -> IO ()
18:22:05 <roconnor> well you would use it in 
18:22:07 <roconnor> setSocketOption :: Socket -> SocketOption -> Int -> IO ()
18:22:15 <copumpkin> preflex: seen tibbe
18:22:16 <preflex>  tibbe was last seen on #haskell 5 hours, 58 minutes and 46 seconds ago, saying: gnight
18:22:27 <roconnor> but IIRC there Int is the wrong type 
18:22:32 <roconnor> I could be mistaken
18:22:59 * hackagebot improve 0.3.1 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.3.1 (TomHawkins)
18:23:03 <benmachine> roconnor: hmm. the manpage for setsockopt says SO_RCVTIMEO expects a timeval structure
18:23:15 <roconnor> http://www.haskell.org/pipermail/libraries/2005-October/004435.html
18:23:17 <roconnor> exactly
18:24:03 <roconnor> it's only been broken for the last 10 years
18:24:09 <roconnor> no one has fixed it yet
18:24:24 <roconnor> Google Summer of Code!!
18:24:36 <roconnor> fix the shitty Network interface
18:27:28 <benmachine> roconnor: I reckon setSocketOption would not be hard to fix, albeit in an API-breaking way
18:27:36 <Raynes> BONUS: Ping.
18:27:38 <benmachine> given, say, a couple of hours to faff about with things
18:27:48 <benmachine> I might give it a try tomorrow
18:29:06 <benmachine> roconnor: you could put a brief explanation up https://github.com/haskell/network/issues here
18:29:50 <lispy> ivan: the reason cabal doesn't know about gtk2hs-buildtools is because we don't have a good enterprise service bus in haskell :(
18:29:55 <osoleve> what does "Cannot construct the infinite type a0 = [a0]" mean?
18:30:14 <lispy> osoleve: it thinks that a0 is both a list of something and an element of type something
18:30:20 <ivan> I'm not ivanm
18:30:26 <lispy> ivan: ah thanks
18:30:31 <lispy> ivanm: ping?
18:30:43 <ivan> he's MIA
18:31:03 <lispy> osoleve: You can make type systems where infinite types are allowed, but it would break some properties we like about Haskell's type system
18:31:20 <osoleve> lispy: I'm not trying to break anything! I promise!
18:32:00 * lispy hopse that his comment about enterprise service buses in haskell is seen as the joke that it is
18:33:41 <lispy> osoleve: if your type errors are confusing you, then the usually the best thing you can do is start adding more where you do know what type you want
18:34:07 <lispy> osoleve: that will cause the type errors to move around.  Eventually you'll get good at getting GHC to pinpoint where the types went wrong
18:36:48 <Raynes> Man, you can never get a hold of that guy.
18:37:11 <roconnor> how do I do binary IO in haskell with handles?
18:38:57 <jix> roconnor: there are function to read/write handles in Data.ByteString
18:39:02 <Bella> http://hpaste.org/45121/ioerror_in_loop_function_valu
18:39:38 <Bella> im trying to output No Entry message if IO error occurs under loop function in value case
18:39:47 <Bella> please help anyone?
18:40:48 <copumpkin> a bytestring seems like the best fit for binary IO
18:43:10 <lispy> Raynes: which guy?
18:43:20 <Raynes> lispy: BONUS.
18:43:27 <lispy> Raynes: oh.
18:43:49 <osoleve> :t sortBy
18:43:49 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
18:43:57 <osoleve> @hoogle sortBy
18:43:57 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
18:43:59 <lispy> :t sortBy (comparing fst)
18:44:00 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
18:44:22 <lispy> :t sort `on` fst
18:44:22 <lambdabot>     Couldn't match expected type `[a] -> c' against inferred type `[a]'
18:44:22 <lambdabot>     In the first argument of `on', namely `sort'
18:44:22 <lambdabot>     In the expression: sort `on` fst
18:44:25 <mikeg> roconnor: I've had very buggy code trying to use setSocketOption and/or System.Timeout for both TCP and UDP sockets... On the other hand recv'ing into a TChan and pulling values from it in a non-blocking way works very well for me
18:44:39 <Bella> anyone?
18:56:02 <Axman6> Bella: add a case for _ when the input is incorrect, and print an error, and loop again?
18:56:11 <Axman6> or don't loop if you want to terminate
19:00:08 <mgsloan> is it possible to create a type of kind (* -> *), which yields (a, a) when given a?
19:00:28 <mgsloan> (I'm trying to define Functor instances for (a,a), (a,a,a), etc)
19:01:07 <benmachine> mgsloan: not exactly. you can use a newtype, though
19:01:26 <benmachine> (by not exactly I mean, not without a newtype)
19:02:06 <benmachine> (also, note that (,) t is already a Functor, so you'd need a newtype to avoid overlap anyway)
19:02:24 <Axman6> @src (,) fmap
19:02:24 <lambdabot> fmap f (x,y) = (x, f y)
19:02:41 <aavogt>  type Tuple a = (a,a)
19:03:04 <aavogt> if you were allowed instances on type synonyms....
19:04:06 <azaq23> even with -XTypeSynonymInstances and -XFlexibleInstances (added due to complaint) this doesn't work,     Type synonym `T' should have 1 argument, but has been given 0
19:05:05 * hackagebot hips 0.1 - an IPS patcher  http://hackage.haskell.org/package/hips-0.1 (PatrickPalka)
19:05:06 <mgsloan> yeah, I saw the instance on ((,) a).  good point about the overlap necessitating a newtype wrapper
19:05:44 <benmachine> azaq23: right, yeah. TypeSynonymInstances still needs them to be fully applied
19:06:12 <mgsloan> I'll just make my own "mapT" typeclass / function
19:06:35 <benmachine> mgsloan: well, the overlap concern is really secondary to the fact that you can't make arbitrary type functions except via newtypes
19:07:04 <mgsloan> or type families, right?
19:08:12 <mgsloan> I suppose data families in this case, if you want to define instances.  that route didn't seem to pan out for this task, though
19:08:19 <revenantphx> "...computer programming is an art, because it applies accumulated knowledge to the world, because it requires skill and ingenuity, and especially because it produces objects of beauty. A programmer who subconsciously views himself as an artist will enjoy what he does and will do it better."
19:08:23 <revenantphx> That is such a good quote.
19:08:33 <revenantphx> I agree with that so much ._.
19:08:52 * Axman6 is having fun being an artist in C at the moment
19:08:54 <revenantphx> I would add on also, that it's an art because it can be enjoyed and you can have fun with it ^_^.
19:09:25 <benmachine> mgsloan: you can't define type class instances for partially-applied type families, I'm pretty sure
19:09:28 <benmachine> that would be scary
19:09:31 <revenantphx> I just got around to reading Knuth's "Programming as an Art" speech.
19:09:32 <revenantphx> Quite nice.
19:09:37 <benmachine> I might be wrong
19:10:04 * roconnor has half a mind to make a HandleIO monad equal to ReaderT Handle IO
19:10:19 <revenantphx> why not.
19:10:24 <lispy> roconnor: hmm...what problem are you solving?
19:10:39 <benmachine> revenantphx: that's not how I'd categorise art exactly
19:10:43 <benmachine> but
19:10:48 <roconnor> lispy: passing my handle into each hGet-like function
19:10:53 <benmachine> defining art is somewhat inane so whatever
19:11:01 <revenantphx> benmachine: I think it depends on your definition, yes
19:11:10 <benmachine> revenantphx: if you want maths and science to be arts as well, good luck to you :P
19:11:15 <revenantphx> I think the word "art" is severely perverted today though.
19:11:36 <revenantphx> There's a difference between a creative art and skillful art, and indeed, they don't even have to be different things all the time.
19:11:38 <lispy> roconnor: oh.  Yeah, that would be handy.  Seems like you might also want to combine it with an ST-like rank-2 interface or a monadic region interface so you can't leak the handle
19:11:50 <benmachine> the english language is severely perverted, frequently for my amusement
19:11:56 <roconnor> any way to get Data.Binary to do littleendian decoding?
19:12:19 <roconnor> lispy: that sounds like a good idea
19:12:31 <lispy> roconnor: Not sure about Data.Binary but cereal has get/put for multiples of bytes that are in both be and le
19:12:37 <roconnor> oh
19:12:51 <benmachine> roconnor: as long as you want a Word16, Word32, or Word64, yes
19:13:00 <benmachine> is what I seem to conclude
19:13:13 <roconnor> benmachine: how?
19:13:23 <benmachine> http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Get.html#g:7
19:13:29 <roconnor> lispy: I just see encode and decode
19:13:40 <benmachine> or, that's what I guess getWord16le do
19:13:44 <benmachine> *does
19:14:31 <lispy> roconnor: yeah, you want things like getWord16le.  That reads a little endian word16
19:15:31 <roconnor> hGetWord32le h = runGet getWord32le `fmap` hGet h 4
19:17:09 <copumpkin> probably more efficient to build up gets
19:18:05 <roconnor> copumpkin: I don't know how much to hGet yet
19:18:15 <roconnor> this hGet gets the length of the rest :)
19:18:19 <mgsloan> there we go:  http://hpaste.org/45122/mapt
19:19:17 <mgsloan> any style suggestions / libraries to use instead of this?
19:20:00 <benmachine> mgsloan: for cases where a = b, Data.Generics.gmapT might do it
19:20:08 <benmachine> > gmapT (+1) (2,3,4,5)
19:20:09 <lambdabot>   Could not deduce (GHC.Num.Num b)
19:20:09 <lambdabot>    from the context (Data.Data.Data b)
19:20:09 <lambdabot>    ...
19:20:13 <benmachine> or might not
19:20:20 <benmachine> > gmapT (+1) (2,3,4,5 :: Integer)
19:20:20 <lambdabot>   Could not deduce (GHC.Num.Num b)
19:20:21 <lambdabot>    from the context (Data.Data.Data b)
19:20:21 <lambdabot>    ...
19:20:26 <benmachine> grr
19:20:30 * benmachine fiddles with ghci
19:20:41 <dmwit> > everywhere (+1) (2, 3, 4, 5) :: (Integer, Integer, Integer, Integer)
19:20:42 <lambdabot>   Could not deduce (GHC.Num.Num a)
19:20:42 <lambdabot>    from the context (Data.Data.Data a)
19:20:42 <lambdabot>    ...
19:21:22 <shachaf> > everywhere (mkT (+1)) (2, 3, 4, 5) :: (Integer, Integer, Integer, Integer)
19:21:23 <lambdabot>   (3,4,5,6)
19:21:23 <benmachine> it's mkT that is missing
19:21:24 <benmachine> yes
19:21:38 <lispy> :t mkT
19:21:39 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
19:21:40 <benmachine> > gmapT (mkT (+1)) (2,3,4,5) :: (Integer,Integer,Integer,Integer)
19:21:41 <lambdabot>   (3,4,5,6)
19:21:52 <benmachine> advantage of gmapT is it doesn't recurse more than you might expect
19:22:29 <shachaf> > everywhere (mkT (+1)) (2, 3, 4, [5,6,7]) :: (Integer, Integer, Integer, [Integer])
19:22:34 <lambdabot>   (3,4,5,[6,7,8])
19:23:07 <mgsloan> very nifty
19:23:28 <dmwit> > gmapT (mkT (+1)) (2, 3, 4, [5,6,7]) :: (Integer, Integer, Integer, [Integer])
19:23:29 <lambdabot>   (3,4,5,[5,6,7])
19:23:34 <dmwit> huh
19:32:49 <gwern> > 19900 - 7088
19:32:50 <lambdabot>   12812
19:35:53 <int80_h> http://hpaste.org/45119/working_off_a_yesod_example_fi
19:38:19 <int80_h> anyone here care to tackle a yesod problem?
19:42:37 <roconnor> big endian is network byte order, right?
19:44:47 <roconnor> > '\76'
19:44:48 <lambdabot>   'L'
19:45:07 <lispy> roconnor: I don't think so
19:45:41 <lispy> roconnor: oh, from wikipedia: The Internet Protocol defines big-endian as the standard network byte order
19:45:51 <Axman6> roconnor: pretty sure it is
19:45:52 <lispy> roconnor: So, um...sorry.  You were right.
19:45:53 <roconnor> thanks
19:46:04 <lispy> wikipedia++
19:57:58 <adskjdjk> do you think denis resembles penis?
20:14:36 <Bella> helloanyon
20:14:38 <Bella> hello
20:14:45 <Bella> anyone haskell expert please help
20:14:54 <Bella> my program after add some values
20:15:06 <Bella> and enter display it shud display values
20:16:04 <Bella> h
20:16:06 <quotemstr> Could a quantum computer run a backtracking algorithm in linear time?
20:16:07 <Bella> hi again
20:16:12 <Bella> i was disconnected
20:16:45 <Bella> http://hpaste.org/45123/display_problem
20:16:48 <Bella> in my code there
20:16:56 <Bella> after adding values
20:17:00 <Bella> and display
20:17:09 <Bella> it shud only display values i entered
20:17:21 <Bella> but it also shows the 'Empty' message
20:17:45 <Bella> not supposed to show that unless the list or Table is empty
20:18:11 <Bella> anyone pls help?
20:18:50 <dmwit> Bella: Yes, you'll need to have different clauses for empty lists called from the top-level and empty lists reached by recursion.
20:19:04 <dmwit> Bella: The simplest thing is to just use mapM_.
20:19:12 <Bella> different clause..?
20:19:23 <int80_h_> http://hpaste.org/45119/working_off_a_yesod_example_fi
20:19:25 <Bella> what does mapM do?
20:19:56 <int80_h_> Bella: it maps a monadic function over a list
20:20:28 <dmwit> Bella: Yes, a different clause, as in
20:20:29 <Bella> so its mapM?
20:20:33 <int80_h_> now that was the first time I tried to answer a haskell question, so let me know if ti helps
20:20:56 <dmwit> f [] = whatever; f xs = f' xs where f' [] = a different whatever; f' (x:xs) = yet another whatever
20:21:02 <aavogt> @ty mapM
20:21:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:21:18 <Bella> what is monad..? sounds advanced...
20:21:39 <aavogt> it could be IO for example
20:21:49 <int80_h> Bella: you'll help yourself greatly by not coming to monads thinking they are special or advanced.
20:22:02 <dmwit> int80_h: Have you definitely hit save in your editor?
20:22:13 * aavogt has the feeling Bella's code could be much shorter
20:22:14 <int80_h> dmwit: say what?
20:22:35 <Bella> im a newbie aavogt
20:22:38 <dmwit> int80_h: You pasted some code that didn't match the error message you were getting. That sounds like you didn't hit save.
20:22:43 <Bella> so 
20:22:47 <int80_h> eeps!
20:22:53 <tawe> @src foldr1
20:22:53 <lambdabot> foldr1 _ [x]    = x
20:22:53 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
20:22:53 <lambdabot> foldr1 _ []     = undefined
20:22:55 <int80_h> dmwit: okay let me look things over
20:23:23 <int80_h> one newb to another - monads are not special.
20:23:29 <tawe> @src foldl1
20:23:29 <lambdabot> foldl1 f (x:xs) = foldl f x xs
20:23:29 <lambdabot> foldl1 _ []     = undefined
20:23:44 <Bella> so dmwit
20:23:51 <Bella> i shud try these
20:23:52 <dmwit> Bella: mapM_ isn't so hard to understand, really. It takes a function that tells what to do for each element of a list, and does it.
20:23:57 <dmwit> :t mapM_
20:23:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:24:00 <aavogt> Bella: you want the output to look like    "x = 1\n y = 2\n Empty"?
20:24:04 <dmwit> :t mapM_ putStrLn -- for example
20:24:05 <lambdabot> [String] -> IO ()
20:24:06 <Bella>  f [] = whatever; f xs = f' xs where f' [] = a different whatever; f' (x:xs) = yet another whatever 
20:24:10 <Bella> into my code?
20:24:15 <geheimdienst> > mapM print [42, 37, 11]
20:24:16 <lambdabot>   <IO [()]>
20:24:18 <aavogt> or the trailing Empty should be missing?
20:24:31 <dmwit> Bella: That's one possible solution, but it's an ugly, manual solution.
20:24:33 <lispy> int80_h: I guess it's like Integers.   They have an interesting and deep mathematical background, but when it comes to programming you just use them.
20:24:36 <dmwit> Bella: mapM_ is the idiomatic way.
20:24:42 <tawe> @src foldl
20:24:42 <lambdabot> foldl f z []     = z
20:24:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:24:56 <Bella> ok so is there a better one?
20:25:06 <dmwit> aavogt: The trailing Empty should be missing.
20:25:09 <int80_h> lispy: Although I still stuggle with monads, I find the "they are not special" mantra to help me.
20:25:40 <aavogt> so like this: http://hpaste.org/45124/bella
20:26:22 <aavogt> you probably need         import Control.Monad  -- to get unless into scope
20:26:25 <dmwit> That's a nice solution, too!
20:26:44 <Bella> woa..u guys catch up really fast..
20:26:56 <Bella> im so new to these..
20:27:19 <int80_h> dmwit: my errors are the same. Code looks the same
20:27:36 <dmwit> (I was thinking something like 'display [] = putStrLn "Empty"; display xs = mapM_ (\(k, v) -> putStrLn (k ++ " = " ++ v)) xs'
20:27:39 <int80_h> dmwit: where are things not matching? Is it the "two arguments, only got one" error?
20:28:04 <dmwit> int80_h: Yes, the pretty-printed code doesn't match the code you claim you wrote.
20:28:53 <int80_h> dmwit: the "wants two parameters, only got one" is part of the problem. I did give it two parameters.
20:29:39 <dmwit> Oh, I didn't notice that there were further errors.
20:29:44 <aavogt> Bella: does the order of the variables you print matter?
20:30:04 <dmwit> For the next one, you probably meant (liftIO jsonScalar $ pageContent page) or so.
20:30:11 <int80_h> lispy: want to take a stab at this yesod problem?
20:30:23 <int80_h> dmwit: yeah let me try that
20:30:41 <Bella> and my last problem is
20:30:48 <Bella> after add values
20:31:03 <Bella> oh wait
20:31:05 <Bella> lemme test
20:31:06 <dmwit> int80_h: It will still be a type error, though, just looking at the previous line.
20:31:09 <lispy> int80_h: sorry, I don't know what yesod is for.  So I probably can't help much
20:31:46 <roconnor> @hoogle forever
20:31:46 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
20:31:47 <dmwit> int80_h: Oh, the first error isn't on the line you pasted above it.
20:31:56 <int80_h> dmwitL pageTitle is of type String. I don't know why that would cause a type error
20:32:02 <dmwit> int80_h: The error is actually in the declaration of "instance Yesod Tframe".
20:32:02 <Bella> back
20:32:06 <Bella> my last problem 
20:32:09 <int80_h> oooh!
20:32:09 <Bella> maybe
20:32:13 <Bella> anyways
20:32:16 <dmwit> int80_h: Because String /= IO String
20:32:18 <Bella> when i add values
20:32:46 <Bella> and value for a key it will retrieve the value (of course i need to add values)
20:33:09 <Bella> but after i remove one value and value a key again (more like search)
20:33:14 <int80_h> dmwit: okay got rid of the first error.
20:33:14 <Bella> it gives out error
20:33:22 <Bella> shud i use ioError?
20:33:41 <Bella> instead of displaying that ugly exception message?
20:34:09 <dmwit> int80_h: To expand on that a bit, what I mean is "liftIO jsonScalar $ pageContent page" is an IO action, whereas "jsonScalar $ Main.pageTitle page" presumably isn't. This is a problem, since lists are supposed to be homogeneous.
20:34:38 <int80_h> dmwit: they are. The list withg be a [Page]
20:34:44 <int80_h> will be I mean
20:34:50 <Bella> cos i wanna output 'No entry' if value searched not found in the Table
20:35:18 <dmwit> int80_h: Read my sentence again. The list will not be a [Page], because the second element and the first element don't have the same types -- so it will be a type error.
20:36:25 <int80_h> dmwit: so a record has to have all the same types if I want to have a list of those records?
20:36:27 <dmwit> Bella: I'm not sure I understood your complaint. Could you give an example of what you would type into your program, and what output you expect?
20:36:41 <dmwit> int80_h: I don't see any records there.
20:36:47 <dmwit> int80_h: Maybe we're not looking at the same place.
20:37:01 <Bella> hold on dmwit..lemme try fixing it myself 1st.
20:37:09 <Bella> ill get back here again if im rele stuck
20:37:15 <dmwit> Good idea, Bella.
20:37:33 <int80_h> dmwit: yeah pageTitle and pageContent come from the data type Page defined earlier. I htink. If that's not how it works I'm more confused than I thought
20:37:57 <dmwit> int80_h: Oh, yes, but that's irrelevant.
20:38:29 <dmwit> Look, it's like this.
20:38:32 <tawe> Where can I find all the infix functions in the prelude? (+, -, *, /, . , etc)
20:38:47 <dmwit> If f :: a -> b, then liftIO f :: a -> IO b.
20:39:10 <dmwit> So a list of the form [(_, f _), (_, liftIO f $ _)] can never work.
20:39:21 <dmwit> ?where report
20:39:21 <lambdabot> http://www.haskell.org/onlinereport/
20:39:24 <dmwit> tawe: In there.
20:39:37 <dmwit> http://www.haskell.org/onlinereport/standard-prelude.html in particular
20:39:58 <Axman6> isn't IO an instance of MonadIO?
20:40:15 <Axman6> :t listIO
20:40:15 <lambdabot> Not in scope: `listIO'
20:40:17 <Axman6> :t liftIO
20:40:17 <lambdabot>     Ambiguous occurrence `liftIO'
20:40:17 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
20:40:17 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
20:40:24 <tawe> dmwit, thanks
20:40:25 <dmwit> It surely is. Is jsonScalar a class function? If so, I'll surely have some egg on my face.
20:40:29 <Axman6> :t COntrol.Monad.Error.liftIO
20:40:30 <lambdabot> Couldn't find qualified module.
20:40:36 <Axman6> :t Control.Monad.Error.liftIO
20:40:36 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
20:40:51 <int80_h> dmwiot: so liftIO takes a value from a monadic context and *puts* into an IO monad?
20:41:06 <Axman6> int80_h: the other way around
20:41:09 <int80_h> I thought it took it out of the IO monad context and put it in another monad
20:41:21 <Axman6> takes something in IO and puts it in MonadIO
20:41:22 <int80_h> ah, good. that's what I thought
20:41:33 <tawe> @rem
20:41:33 <lambdabot> Incorrect arguments to quote
20:41:38 <tawe> @src rem
20:41:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:41:42 <int80_h> well my liftIO should work then. I wonder what I am missing.
20:42:14 <Axman6> rem x y = snd (divRem x y)
20:42:30 <tawe> What's the difference between 'rem' and 'mod'?
20:43:13 <dmwit> int80_h: Okay, ignore all my previous crap. It's nonsense. But the future crap I say should be partial sense.
20:43:48 <dmwit> int80_h: Are these jsonMap and jsonScalar functions the ones from Yesod.JSON?
20:44:27 <int80_h> dmwit: I believe so
20:44:36 <dmwit> Okay. Then they are pure functions.
20:44:55 <int80_h> dmwit: ah,
20:45:07 <int80_h> would =<< or >>= be more appropriate then?
20:45:09 <roconnor> @hoogle unless
20:45:09 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
20:45:12 <dmwit> liftIO (pageContent page) can work, but it returns an IO-like action.
20:45:27 <Bella> hey
20:45:32 <dmwit> So if you want to write this json function, you have to turn it from a pure function into a function that produces an IO-like value.
20:45:35 <Bella> i dun know..
20:45:59 <Bella> i was trying to use the idea about not null thingy
20:46:09 <Bella> but it doesn't seem to work logically to me
20:46:10 <int80_h> dmwit: then this is more than a tweak to one line
20:46:24 <dmwit> int80_h: For example, something like this: "json page = do { content <- pageContent page; return (jsonMap [("name", blah), ("content", jsonScalar content)]) }"
20:46:52 <dmwit> int80_h: Yes, very likely, since anything calling the json function will also have to be inside an IO-like type.
20:47:28 <dmwit> int80_h: Generally speaking, this is why it's not such an amazing idea to store IO actions in your data.
20:47:29 <Bella> http://hpaste.org/45125/bella_annotation
20:47:36 <Bella> my other problem is
20:47:44 <dmwit> int80_h: It's much more common to do a bit of IO, then store the results of that IO purely in the data.
20:47:53 <Bella> after adding values using add func
20:48:24 <Bella> and i search key using value function
20:48:35 <Bella> it works if the data existed (after adding)
20:49:15 <Bella> but it throws error if data doesnt exist. i want to output 'No entry' message
20:49:17 <dmwit> Bella: You might want to learn about the Maybe type constructor.
20:49:18 <dmwit> ?src Maybe
20:49:18 <lambdabot> data Maybe a = Nothing | Just a
20:49:24 <Bella> instead of the ugly exception error
20:49:34 <dmwit> You might also like this function:
20:49:35 <dmwit> :t lookup
20:49:36 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
20:49:48 <Bella> okay
20:49:49 <dmwit> :t deleteBy
20:49:50 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
20:50:03 <Bella> okay
20:50:24 <Bella> by based on my experience, can u suggest me which is easier to use and easier for me to understand?
20:51:01 <dmwit> What are the options that I'm choosing from when answering that question?
20:51:31 <lispy> alloca can return a null pointer right?
20:51:42 <lispy> But I never see anyone checking the result alloca
20:51:59 <Bella> amateur
20:52:00 <Bella> lol
20:52:57 <Bella> okay maybe im gonna try Maybe
20:54:14 <dmwit> lispy: Haskell's alloca? It doesn't really return a pointer at all, does it?
20:54:29 <geheimdienst> is alloca somewhat like malloc? cause when malloc gives a null pointer, i don't think there's much you can do except crash ...
20:54:36 <lispy> dmwit: "return".  It takes a function that should be applied to a pointer
20:54:49 <lispy> I'm just being lazy :)
20:54:51 <dmwit> lispy: I doubt that function ever gets called if alloca can't get enough space.
20:55:04 <lispy> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/base-4.3.1.0/Foreign-Marshal-Alloc.html
20:55:26 <geheimdienst> dmwit: i'd expect the same. the "if null" is probably in alloca, not in the client code
20:55:33 <dmwit> I can't find the implementation of newAlignedPinnedByteArray#, but my guess is it throws an exception when it's out of memory.
20:55:52 <int80_h> dmwit: eventually, I will need the pageContent to represent graph data. I cringed at the idea of storing it all at once. I thought it would be more efficient (and fancy) to store the action to read the file, only when the action is called.
20:56:23 <lispy> dmwit: "If any of the allocation functions fails, a value of nullPtr is produced. "
20:56:30 <dmwit> int80_h: If you want to do fancy things, you've got to do fancy things.
20:56:39 <dmwit> int80_h: I guess that's no surprise.
20:56:52 <geheimdienst> but how can they fail, except when out of memory?
20:57:02 <int80_h> dmwit: right now I'm picturing a web page with three links on it, and the content being displayed only when the link was clicked.
20:57:07 <dmwit> lispy: Huh, it does indeed say that.
20:57:42 <int80_h> int80_h: so is there a better way other than (1) populating a list with all possible data (2) storing an action to read that data when that action is called
20:57:54 * int80_h I am so ditzy
20:58:08 <int80_h> dmwit: so is there a better way other than (1) populating a list with all possible data (2) storing an action to read that data when that action is called
20:58:10 <lispy> Well, you could request way too much memory and have them fail for that reason
20:58:33 <lispy> So you'd still have memory to fail but not enough contiguous memory to succeed
20:58:46 <int80_h> lispy: was that for me?>
20:58:47 <lispy> and then start using an null pointer
20:58:52 <lispy> int80_h: nope
20:58:55 <int80_h> whew
20:58:56 <dmwit> int80_h: Sorry, I don't know enough about Yesod to answer that one.
20:59:03 <int80_h> cause I was confused
20:59:20 <int80_h> dmwit: well thanks for your help. You helped me get one of my errors.
20:59:42 <lispy> dmwit: maybe we should have an allocaOrBust version that calls error or throw when it gets a nullPtr
21:00:01 <lispy> I'd rather crash early than try to use a nullPtr
21:00:29 * lispy fires an email at the -Cafe
21:01:36 <geheimdienst> > nullPtr `minusPtr` 3
21:01:37 <lambdabot>   Not in scope: `nullPtr'Not in scope: `minusPtr'
21:02:26 <dmwit> lispy: Welp, from my test here, allocaArray actually throws an exception, it doesn't do any nullPtr nonsense.
21:03:51 <dmwit> lispy: Here's my test program:
21:03:56 <dmwit> main = allocaArray (2^30) (\ptr -> peekArray 1 ptr >>= (print :: [Double] -> IO ()))
21:03:58 * int80_h waves
21:04:10 * geheimdienst waves back
21:04:20 <dmwit> He's already gone, geheimdienst. =(
21:04:21 <geheimdienst> what would happen if you use a nullPtr in any way?
21:04:35 <lispy> dmwit: well, if you peek (int*)0 in C I think you get an exception too
21:05:02 <dmwit> The exception doesn't say null-dereference, it says out-of-memory.
21:05:09 <lispy> ah
21:05:09 <dmwit> Though what you say is fair, one second.
21:05:41 <dmwit> ?hoogle nullPtr
21:05:41 <lambdabot> Foreign.Ptr nullPtr :: Ptr a
21:06:24 <dmwit> Here's another test program that still throws an exception:
21:06:26 <lispy> dmwit: so now we should try plain alloca with a too big request
21:06:27 <dmwit> main = allocaArray (2^30) (\ptr -> print ((nullPtr :: Ptr Double) == ptr))
21:06:42 <geheimdienst> i still think there's not much you can do on nullPtr except crash. so if all the functions that use a Ptr do that "if (== nullPtr)", then you don't have to ...
21:06:58 <geheimdienst> *"if (== nullPtr) crash
21:07:17 <dmwit> geheimdienst: A sufficiently advanced program could recover from out-of-memory errors.
21:07:23 <dmwit> Say, by freeing up some memory.
21:07:31 <dmwit> Plenty of programs do this -- Gimp comes to mind.
21:08:08 <lispy> garbage collectors do tihs
21:08:19 <dmwit> lispy: alloca also throws an exception.
21:08:39 <dmwit> lispy: Or rather, allocaBytes throws an exception, and alloca is implemented in terms of allocaBytes, so I'm *guessing* that alloca throws an exception.
21:09:06 <lispy> ah
21:09:09 <geheimdienst> i don't know ... when does the kernel's oom-killer strike?
21:09:13 <lispy> So the haddocks are wrong?
21:09:39 <ion> Upstart does something like foo = NIH_MUST (nih_alloc (â€¦)); which means retry in loop until the allocation succeeds. Even thatâ€™s better than the init daemon crashing. :-)
21:09:50 <dmwit> lispy: Yes. Also, the exception doesn't seem to be catchable. =(
21:10:28 <ion> Throwing an exception may require allocating memory successfully as well.
21:11:09 <dmwit> Yes, it's probably not the usual exception mechanism.
21:12:28 <geheimdienst> so in java, when you get an out-of-memory exception, that's an issue between your program and the runtime, right? malloc is not involved usually
21:12:46 <geheimdienst> i recall the java vm has command line options to set heap size and such
21:13:10 <geheimdienst> as for gimp, i don't know
21:14:48 <lispy> dmwit: hmmm...I set sizeOf to be 2^50 and I still can't trigger the failure with a storable instance
21:15:12 <lispy> somehow ghc isn't actually allocating based on sizeOf
21:15:42 <thoughtpolice> geheimdienst: linux in particular will do overcommit. doing malloc(2tb) will return that memory, but you'll hit the OOM killer once you actually start to page it all in and can't
21:16:11 <geheimdienst> aha! interesting
21:16:14 <thoughtpolice> (and the OOM killer is rather finnicky on linux in that it "just kills stuff" to free memory, i don't really think it concerns itself with anything other than that)
21:16:45 <geheimdienst> so in that regard, you're more likely to be killed than to see malloc return NULL
21:17:44 <thoughtpolice> yeah. in java when you hit OOM errors, you generally have hit the limit of the GC's allocation arena, and that doesn't automatically expand - you have to set it on the command line.
21:17:53 <lispy> dmwit: I don't get this :)
21:18:03 <lispy> dmwit: I can't seem to make mine fail, even with allocaBytes
21:18:26 <geheimdienst> lispy, check what thoughtpolice just said :)
21:18:35 <lispy> dmwit: oh wait, I crashed ghci using maxBound for allocaBytes
21:18:39 <thoughtpolice> (that is to say, if you attempted to allocate n bytes, but that would go past the limit of the heap, you will do a GC and then try that allocation again. if it fails again, then you're out of heap space and you get an OOM)
21:18:41 <lispy> geheimdienst: does that apply to windows?
21:18:48 <geheimdienst> possibly dmwit is on a system that doesn't do that overcommitting
21:18:50 <thoughtpolice> i don't think windows does overcommit
21:18:59 <lispy> I'm on windows7
21:19:06 <Bella> hi dmwit
21:19:28 <Bella> ive just tried Maybe for my problem
21:19:59 <Bella> and as i compile i got parse error input '|'
21:20:06 <Bella> im using guarded
21:20:46 <geheimdienst> the malloc manpage on my linux is regrettably very short on the issue of returning NULL
21:21:12 <dmwit> geheimdienst: I'm not on such a system on purpose. It's just a usual Linux.
21:21:15 <lispy> Okay. So things are "weird" on my system I bet because I have a 64 bit system with more than 2^32 bytes of memory
21:21:30 <dmwit> lispy: Yeah, I had to hit a pretty high byte count before it crashed.
21:21:34 <dmwit> (64-bit here as well)
21:21:40 <geheimdienst> dmwit, you mean, you have oom-killing turned off?
21:21:47 <dmwit> geheimdienst: Not on purpose.
21:21:51 <dmwit> Okay, gotta run.
21:21:54 <lispy> dmwit: maxBound works pretty reliably for me to crash it.  But, I'm unable to get an allocation that fails without crashing ghci
21:21:56 <geheimdienst> cya
21:21:58 <dmwit> Leave me qeustions with ?ask if you like.
21:22:08 <lispy> I'm going to email -Cafe
21:22:47 <geheimdienst> sure, the topic is pretty interesting
21:22:51 <geheimdienst> and mysterious :)
21:23:09 <Bella> oh ok
21:23:25 <Bella> tata~lemme ask someone else then
21:24:05 <Bella> anyone. im trying to output "No entry" if the data i retrieved is not existed in list
21:24:14 <Bella> as suggested i used Maybe
21:24:32 <Bella> but it doesn't work
21:25:57 <Bella> http://hpaste.org/45126/value
21:26:08 <Bella> anyone. im trying to output "No entry" if the data i retrieved is not existed in list 
21:26:25 <Bella> as suggested i used Maybe 
21:26:32 <Bella> but aint workin
21:27:18 <napping> It doesn't look like you are using Maybe yet
21:27:37 <napping> try value :: Key -> Table -> Maybe Value
21:28:16 <Bella> im suing it at the bottom napping
21:28:24 <Bella> way down
21:28:29 <Bella> *using
21:28:56 <napping> I only see one program in the paste
21:29:17 <Bella> http://hpaste.org/45126/value
21:29:20 <Bella> did u see this one?
21:29:28 <Bella> it's under "value"
21:29:33 <napping> line 73 you wrote isNothing, but like 21 says the value function returns a Value
21:30:04 <Bella> but i cant edit the type to Maybe Value because that's the question says.
21:30:08 <Bella> i have to follow it
21:30:13 <Bella> so i cant use Maybe them?
21:30:19 <Bella> *then?
21:30:45 <napping> That sounds wrong
21:31:06 <napping> Are you sure you can't write your own little functions to use?
21:31:16 <Bella> u mean helper function?
21:31:30 <napping> like the function value
21:31:49 <Bella> u mean...
21:31:53 <Bella> helper function?
21:32:23 <napping> does anything actually say you have to write a value function with that type?
21:32:36 <Bella> yes
21:32:40 <Bella> it's my homework
21:32:46 <Bella> i have to follow that type
21:32:48 <napping> where is the homework?
21:33:10 <napping> that's stupid, what is value supposed to return if the key is not in the table?
21:34:12 <Bella> dunno
21:34:20 <Bella> im a newbie
21:34:45 <napping> if the assignment says you need to write that function with that type, it should says what it's supposed to do
21:35:13 <blueonyx> hi, can someone give me a quick start how to run a executable cabal build, after it build it?
21:35:42 <dobblego> blueonyx: it's in dist
21:35:56 <monochrom> you can find it under dist, several directories deep
21:36:03 <Bella> yeah it worked but when i test the program if i use value func to retrieve data not existed it gives error and it's suppsed to output 'no entry'
21:36:12 <monochrom> or you can "cabal install", and get it in ~/.cabal/bin
21:36:28 <blueonyx> no i mean, cabal should automaticly run it after it build it
21:36:30 <monochrom> if you "cabal install", it also gets stripped
21:36:37 <blueonyx> sure
21:36:47 <monochrom> then I don't know
21:36:56 <blueonyx> some crazy setup.hs i guess?
21:37:06 <dmwit> Bella: If the type of the "value" function is dictated by your assignment, then you are probably expected to write a separate function to explicitly check whether a key is in the list or not.
21:39:40 <lispy> ?tell dmwit http://www.haskell.org/pipermail/haskell-cafe/2011-March/090545.html  <-- hopefully someone will reply
21:39:40 <lambdabot> Consider it noted.
21:39:52 <Bella> seperate function..?
21:40:01 <Bella> like self-define function?
21:40:20 <monochrom> yes
21:40:57 <dmwit> lispy: Thanks, I'll keep a tab on it.
21:40:57 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
21:41:01 <dmwit> ?clear
21:41:01 <lambdabot> Messages cleared.
21:49:52 <lispy> dmwit: another data point.  The haskell platform installer for windows seems to be 32 bit only.  That explains why maxBound :: Int is so small
21:50:14 <lispy> dmwit: It would be nice to test with a 64bit version on windows, but I don't know how I'll install that
21:53:15 <blueonyx> what does "cabal: can't find source for MyLib/MyModule in ., dist/build/autogen" mean?
21:56:03 <lispy> and this data point:
21:56:03 <lispy> mallocBytes      :: Int -> IO (Ptr a)
21:56:04 <lispy> mallocBytes size  = failWhenNULL "malloc" (_malloc (fromIntegral size))
21:56:19 <lispy> dmwit: "failWhenNULL" looks pretty damning :)
21:58:01 <lispy> Still don't know what some of this stuff calls under the hood though.  mallocBytes is used by allocaBytes on some compilers but not GHC
21:59:01 <lispy> blueonyx: I'm not sure without knowing more about your build
21:59:10 <lispy> blueonyx: but...it looks like your .cabal file is not right
22:01:48 <blueonyx> lispy: yea i forget the hs-source-dirs
22:01:56 <blueonyx> thanks anyhow
22:02:10 <Anpheus> in the source for GHC.Real
22:02:17 <Anpheus> how do I parse:  data  (Integral a)      => Ratio a = !a :% !a
22:02:34 <Anpheus> I get that we're defining a data "Ratio a" where a is an instance of "Integral"
22:02:39 <Anpheus> but the !a :% !a
22:02:41 <Anpheus> is confusing
22:04:15 <lispy> Anpheus: :% is a data constructor
22:04:23 <lispy> the ! means that the a is strict
22:04:44 <Anpheus> ok
22:04:48 <lispy> data Ratio a = R a a, might look more familiar
22:04:58 <lispy> data Ratio a = R !a !a, would then be strict
22:05:05 <Anpheus> in which case to use it I'd do "R 5 3"
22:05:07 <Anpheus> right?
22:05:10 <lispy> yeah
22:05:13 <Anpheus> but they wanted an infix constructor
22:05:15 <Anpheus> hence the :%
22:05:16 <lispy> :t (:%)
22:05:17 <lambdabot> Not in scope: data constructor `:%'
22:05:32 <Anpheus> >:load Rational
22:05:36 <Anpheus> dunno if that works
22:05:40 <Anpheus> I haven't lambabotted much
22:07:53 <dmwit> :t (Data.Ratio.:%)
22:07:53 <lambdabot> Not in scope: data constructor `Data.Ratio.:%'
22:08:09 <lispy> :t let x = x in x
22:08:10 <lambdabot> forall t. t
22:08:34 <dmwit> I don't think Data.Ratio exports :%.
22:08:38 <dmwit> :t (Data.Ratio.%)
22:08:39 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
22:08:42 <blueonyx> sometimes (on other packages) i see ghc warnings from Setup.hs, so cabal runs them, but where does it store the compiled Setup and how to trigger recompiling it?
22:09:18 <dmwit> cabal clean; cabal configure
22:10:35 <lispy> blueonyx: it stores things is ./dist or else it uses tmp
22:11:48 <blueonyx> dmwit: i put a error "foo" in a hook which gets printed on ./Setup.hs build but not on cabal clean; cabal configure; cabal build :/
22:12:45 <ion> anpheus: Data constructors must begin with an upper-case letter or a colon. Ratio doesnâ€™t export :% but it defines the operator % that ends up using the :% constructor. A link about the exclamation mark: http://www.haskell.org/haskellwiki/Keywords#.21
22:12:54 <blueonyx> and i see nothing like a setup in dist
22:13:43 <dmwit> I've never been very clear on cabal-install's relationship with Setup.hs.
22:13:53 <dmwit> It's supposed to replace it, but... ?
22:13:57 <blueonyx> and why does cabal configure work but ./Setup.hs not O.o
22:14:11 <dmwit> You can't run source files.
22:14:25 <dmwit> You can run .lhs files if you chmod them and stick a #! line at the top for runhaskell or so.
22:14:36 <dmwit> Anything else is Right Out.
22:14:38 <blueonyx> #!/usr/bin/env runhaskell
22:14:41 <lispy> oh, Setup.hs is IGNORED with build-type: Simple
22:14:47 <blueonyx> aye
22:14:51 <ion> :t (GHC.Real.:%) -- GHC.Real seems to export :%
22:14:51 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
22:14:52 <blueonyx> thanks
22:15:28 <dmwit> ion: cheers
22:15:42 <ion> > (GHC.Real.:%) 1 0
22:15:43 <lambdabot>   Not in scope: data constructor `GHC.Real.:%'
22:15:51 <dmwit> Not that there's really a reason to use :% over %, I guess.
22:16:30 <ion> Oh, well. (GHC.Real.:%) 1 0 doesnâ€™t do any validity checks, nor does it reduce the number. % does both.
22:18:14 <applicative> > 1 % 0
22:18:15 <lambdabot>   *Exception: Ratio.%: zero denominator
22:18:38 <ion> > 4 % 2
22:18:39 <lambdabot>   2 % 1
22:20:52 <lispy> I'm all about smart constructors
22:21:09 <lispy> But, if this were agda, we could probably just set the type of :% to rule out things like divide by 0
22:21:15 <applicative> why are they called smart
22:21:49 <lispy> applicative: Just to make sure we're talking about the same thing.  I would call (:%) the constructor and (%) the smart constructor
22:22:09 <roconnor> what's the easiest way to turn an Integer into a ByteString?
22:22:12 <applicative> yes we're talking about the same.
22:22:15 <dmwit> applicative: Because they aren't instantly in WHNF.
22:22:17 <lispy> I would call it smart because it can do user defined validation and input transformations
22:22:17 <ion> lispy: Iâ€™m curious: would it be possible to make the constructor reduce the number as well in Agda?
22:22:50 <ion> lispy: Or at least rule out unreduced ones?
22:22:53 <dmwit> ion: No, but it would be possible to require you to provide a proof that they were reduced at constructor-application time.
22:22:59 <dmwit> Yeah, the latter.
22:23:02 <lispy> ion: I don't think so.  Maybe you could give it a type such that it only takes reduced arguments though.
22:23:03 <ion> alright
22:24:04 <lispy> dmwit: BTW, the allocation function used under the hood is defined GHC.Prim and I have no idea what the implementation does as it's not written in Haskell.
22:24:35 <lispy> Bascially, I'm of the mind that the docs are wrong.  Exceptions are thrown in some cases, in others the RTS just crashes.
22:24:40 <roconnor> and by turn an Integer into a ByteString I don't mean serialize
22:24:48 <roconnor> I don't want it to be self deliminating
22:25:00 <lispy> roconnor: You lost me :)
22:25:20 <roconnor> I don't want the length of the integer encoded in the bytestring as you would for self-deliminating serialization
22:25:33 <roconnor> I just want the Integer value as a bytestring
22:25:34 <lispy> Haskell-Cafe isn't really that useful anymore is it?  Has everyone moved to SO, reddit, and other mailing lists?
22:26:04 <Hasb45> what is the best way to learn haskell?
22:26:09 <lispy> roconnor: like, '\1234' ?
22:26:17 <Hasb45> im newbie
22:26:19 <applicative> Hasb45: struggle
22:26:19 <ion> hasb45: The same as any other language.
22:26:38 <Maxdamantus> Starting with IO?
22:26:38 <Hasb45> i see
22:26:40 <applicative> Hasb45: do you need something to read?  
22:26:45 <ion> Write stuff you find motivating in it.
22:26:47 <Hasb45> yes
22:26:50 <lispy> Hasb45: learn you a haskell is a good book to start with.  Then progress to Real-World Haskell in time.  Hang out here and ask questions.  Send emails to the Haskell-beginners list and read reddit/r/haskell and stackoverflow haskell
22:26:59 <ion> Read LYAH and then RWH.
22:27:01 <applicative> @where lyah
22:27:01 <lambdabot> http://www.learnyouahaskell.com/
22:27:08 <applicative> @where rwh
22:27:08 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:27:16 <Hasb45> Thank you guys
22:27:37 <applicative> Hasb45: do you have the ghc installed?
22:27:45 <Hasb45> yes i do
22:27:49 <applicative> excellent
22:28:06 <lispy> Every computer should have ghc installed ;)
22:28:38 <ion> Maybe SPJ could convince Ballmer to bundle it with Windowsâ„¢.
22:28:57 <applicative> see what happens with LYAH or RWH.  people here can explain difficulties. there is the paste hpaste.org for putting up problematic modules.
22:29:17 <ion> And remember to paste the error message along with the problematic code.
22:29:29 <Hasb45> applicative thanx
22:29:42 <Hasb45> ion in here you mean?
22:29:46 <ion> hpaste
22:29:51 <Hasb45> ok
22:30:03 <lispy> We don't normally paste more than 1-2 lines in here
22:30:13 <Hasb45> ok
22:30:19 <lispy> With 600+ people in one channel that would just be too much text :)
22:30:37 <Hasb45> true lol
22:30:59 <lispy> Hasb45: have you written fibonacci yet?
22:31:05 <lispy> That one's pretty easy
22:31:08 <applicative> hpaste also has hlint so it makes sensible recommendations 
22:31:36 <Hasb45> lispy no i haven't
22:31:55 <bant323> hi everyone
22:32:02 <Hasb45> hi bant
22:32:19 <Hasb45> applicative what is hlint?
22:32:30 <ion> It would be cool if hpaste also tried to parse and typecheck the code and print any error messages.
22:32:36 <lispy> > fibs -- figure out how to get this output
22:32:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:32:57 <Hasb45> i see 
22:34:00 <applicative> Hasb45: it just goes over the module and makes recommendations, "you don't need these parentheses". etc
22:34:17 <Hasb45> i see
22:34:24 <bant323> is there a haskell function that is the 'inverse' of map: something with a type signature [a] -> [b] -> (a -> b). i couldnt find anything in Hoogle. some possible uses for this function: create a map from lowercase to upper case; from a Char to a digit etc.
22:34:30 <lispy> Hasb45: the haskell wiki has articles on style if you care about that sort of thing
22:34:46 <Hasb45> lispy yes thanx
22:34:53 <lispy> bant323: Data.Map?
22:35:06 <bant323> ill take a look, thank you
22:35:23 <applicative> It is helpful for getting the precedence of infix operators straight.  It is a bother to think about, but when you see what you yourself wrote done right, it sticks
22:35:23 <dmwit> bant323: Assuming you meant ([a] -> [b]) -> (a -> b), then no, that function doesn't (and can't) exist.
22:35:49 <dmwit> bant323: And I'm not sure I understand how you would use such a function for the uses you gave, either.
22:35:56 <lispy> dmwit: I think what bant323 wants is a way to specify [(a, b)] and get (a -> b)
22:36:15 <dmwit> Oh, well, that's a tad easier, though you have to settle for a Maybe in there.
22:36:17 <dmwit> :t lookup
22:36:18 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
22:36:29 <dmwit> :t flip lookup
22:36:29 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> Maybe b
22:36:48 <lispy> :t flip Data.Map.lookup
22:36:49 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> Maybe a
22:37:04 <dmwit> Right.
22:37:32 <dmwit> bant323: I should point out that your use cases are covered by toUpper and digitToInt, in case that's all you wanted them for.
22:37:47 <bant323> dmwit: thank you
22:38:48 <bant323> dmwit: i was looking for a function that would return toUpper and similar functions: for example: pam [a..z] [A..Z] would return a function similar to toUpper
22:39:21 <bant323> the point of the function it to create a mapping from the elements of one list to the elements of another
22:39:36 <dmwit> > lookup 'a' (zip ['a'..'z'] ['A'..'Z'])
22:39:36 <lambdabot>   Just 'A'
22:39:47 <mgsloan> what's with www.haskell.org/gtk2hs being down? it seems like it's been that way for at least half a year or something..
22:40:00 <mgsloan> nigh impossible to find the haddock
22:40:02 <ion> What would pam ["aaa"] ["bcd"] return? What would pam ['a'..'z'] ['A'..'Z'] 'Ã…' return?
22:40:03 <dmwit> mgsloan: The community.haskell.org folks haven't set up MySQL for us yet.
22:40:10 <dmwit> mgsloan: But the haddocks are on Hackage...
22:40:12 <mgsloan> ah
22:40:22 <lispy> creating the mapping is easy (just make tuples).  The harder part is the lookup.  You basically have two ready-made choices.  using equality or ording.  Lists use equality and Data.Map uses orderings.
22:40:49 <ion> Whoops, extraneous [] in the first one.
22:41:05 <mgsloan> dmwit - where on hackage? I've definitely tried looking
22:41:12 <dmwit> ?hackage gtk
22:41:12 <lambdabot> http://hackage.haskell.org/package/gtk
22:41:17 <mgsloan> ahhhh
22:41:30 <lispy> I agree that the state of the community server is sad
22:41:40 <bant323> lispy: im a noob. to create tuples i use zip, right?
22:41:41 <lispy> We have too much home grown infrastructure to manage.
22:42:09 <lispy> bant323: that's how you turn 2 lists into a 1 list of tuples.  But to create just 1 tuple, you put them together with a comma.  (1,2)
22:42:20 <lispy> :t (,)
22:42:21 <lambdabot> forall a b. a -> b -> (a, b)
22:42:24 <mgsloan> it's totally understandable, but yeah, doesn't look too good.  here's to avoiding success :D
22:42:27 <lispy> > (1,2)
22:42:27 <lambdabot>   (1,2)
22:42:31 <dmwit> mgsloan: See also: gconf, gio, glade, glib, gnomevfs, gstreamer, gtkglext, gtksourceview2, pango, soegtk, sourceview, svgcairo, vte, webkit
22:42:39 <dmwit> ...and cairo
22:42:50 <lispy> > (,) 1 2 -- bant323 you can also use it in pre-fix form
22:42:51 <lambdabot>   (1,2)
22:42:52 <dmwit> Which I somehow missed, even though it's my favorite one.
22:43:04 <mgsloan> yup, I like cairo too
22:43:28 <mgsloan> mostly using gtk as a way to get a cairo canvas and IO
22:43:29 <bant323> lispy: thanx
22:44:01 <lispy> I wish we had something better than gtk and wx, but I'm not sure how to approach that.
22:44:31 <lispy> On windows/osx I think we could make a binding relatively easily to some gui library.  On linux I'm not sure what you have to do.
22:44:50 <lispy> I suspect that on linux you end up binding to gtk anyway
22:45:49 <lispy> And by better I mean, less encumbered with technical limitations, easier to install, etc.  And I'm not sure about the licenses on those two bindings.  Can you use them in proprietary programs?
22:46:46 <mgsloan> I'm no expert, but I think you could use Graphics.X11.Xlib to get pretty raw control over your window, and avoid the Gtk layer
22:47:01 <jmcarthur> yeah, just have to make your own widgets and junk
22:47:28 <mgsloan> yup, just have cairo write directly to your output buffer
22:47:36 <jmcarthur> or use opengl even
22:47:41 <lispy> making my own widgets is the part where I go, "Eh.  Maybe someone else will do it."
22:47:46 * Maxdamantus wouldn't mind that for applications he uses.
22:48:02 * Maxdamantus uses few windowed applications.
22:48:21 <Maxdamantus> urxvt, mplayer, conkeror, xpdf, etc
22:48:30 <dmwit> Yeah, and it really shows.
22:48:45 <dmwit> mplayer has the worst interface, and xpdf is damn near unusable in terms of focus problems.
22:49:05 * Maxdamantus likes GUIs transparent enough such that the user wouldn't care whether it's using Gtk or whatever.
22:49:08 <dmwit> Gtk apps are worlds better with much less effort.
22:49:25 <Maxdamantus> mplayer has the perfect movie playing interface.
22:49:32 <dmwit> WRONG
22:49:34 <Maxdamantus> RIGHT
22:49:38 <dmwit> It opens a *new window* for every window.
22:49:45 <Hasb45> lÃ¶l
22:49:46 <Maxdamantus> Why would you want to shove ugly buttons next to your movie?
22:49:49 <dmwit> This makes consistent sizing damn near impossible.
22:49:56 <dmwit> Seamless playback is also impossible.
22:49:57 <Maxdamantus> You can fix that for some VO drivers.
22:50:00 <ion> Making my own UI toolkit functionality is the part where i would go â€œeh. this UI will have an awful (i.e. non-native) look and feel on all platformsâ€
22:50:07 <dmwit> I don't want ugly buttons, I want a smooth experience.
22:50:11 <Maxdamantus> -vofix or something, can't remember.
22:50:38 <Maxdamantus> -fixed-vo
22:50:53 <Maxdamantus> Works with "gl, gl2, mga, svga, x11, xmga, xv, xvidix and dfbmga"
22:51:15 * Maxdamantus tries with vdpau
22:51:21 <jmcarthur> i prefer apps to open new windows for everything. it works so much better with my tiling window manager
22:51:32 <jmcarthur> i hate it when apps think they can handle their windows better than i can
22:51:51 <lispy> I know understand that if the C library is LGPL and the haskell binding is BSD3, then your Haskell program isn't subject to viral licensing constraints.  But, in the case of gtk2hs the Haskell bindings are LGPL :(
22:52:05 <Maxdamantus> I hate it when apps want to have open more than one window at a time, when not explicitly told to do so.
22:53:41 <Maxdamantus> Yeah, fixed-vo works for vdpau too.
22:54:00 <Maxdamantus> So that covers your issue, with all the non-obscure outputs.
22:54:05 <dmwit> Windows still resize with fixed-vo.
22:54:55 <dmwit> Don't get me wrong.
22:55:03 <dmwit> mplayer has the best GUI of any movie player I know of.
22:55:22 <Maxdamantus> If you mean gmplayer, that's basically the worst.
22:55:30 <dmwit> I don't mean gmplayer.
22:55:39 * Maxdamantus wouldn't consider mplayer to be a "GUI"
22:55:41 <jmcarthur> i like straight up mplayer
22:55:42 <monochrom> I disagree. ghc is a better movie player.
22:56:02 <Maxdamantus> Since most of the UI is nongraphical.
22:56:39 <Maxdamantus> Other than a few OSD things the only graphics is the content itself.
22:56:45 <monochrom> perhaps dmwit also sets mplayer to play through the ascii art driver! :)
22:56:48 <dmwit> You're the one that listed it as one of the paragons of raw X11 programming leading to good GUIs.
22:56:55 <tlonim> mplayer is the most minimal of the players.. easily controllable with slave mode 
22:57:02 <tlonim> good for writing wrappers around it
22:57:23 <dmwit> Another gripe: the OSD is not rendered at the size of the window, it's rendered at the size of the video, and then scaled. BLECH
22:57:36 <Maxdamantus> Yes, the GUI is as minimal as it needs to be - non-existant in this case.
22:57:39 <lispy> Haskell gui libraries seems to be a hard topic to bring up.
22:57:48 <tlonim> btw, there is also a mplayer2 now 
22:58:01 <ion> dmwit: Except when using the gl video output driver at least.
22:58:04 <lispy> Leads to lots of discussions I don't particularly care about.
22:58:15 * Maxdamantus would quite like a better alternative to xpdf though.
22:58:24 <tlonim> Maxdamantus: mupdf is nice 
22:58:27 <tlonim> and fast
22:58:34 <dmwit> I like evince a lot.
22:58:40 <dmwit> The only thing I don't use it for these days is printing.
22:59:20 <dmwit> lispy: Well, people have tried a whole bunch of non-bindings, and they inevitably find very little use.
23:01:15 <lispy> dmwit: Yeah.  I don't really know what the solution is.  It seems like we need a non-viral license binding to gtk for linux.  And we can probably use a native library on other platforms, but then we have to do the cross platform bits ourselves.
23:01:17 <tlonim> i use vdpau vo most of the time.. vpdau is nice  and with xmonad + fixed-vo i can queue stuff etc. 
23:02:01 <lispy> dmwit: I'm one of those people who doesn't like the way gtk looks on osx and windows.
23:02:26 <dmwit> I'm a Linux guy, so that definitely wouldn't scratch my itch.
23:02:55 <lispy> I seem to use all 3
23:03:15 <lispy> I have a macbook that I use a lot, the desktop in my living room is a windows machine, and my work computer runs linux
23:03:44 <DRMacIver> There's a reasonable argument to be made that making the GUI part of your software cross-platform should be a non-goal. 
23:04:05 <DRMacIver> And that what you really need are good bindings to each of the relevant platform toolkits.
23:04:42 <lispy> DRMacIver: so, if you go that route (and I'm mostly okay with that), what packages from hackage would you use if you started on such an application *today* ?
23:05:21 <lispy> The Win32 bindings are maybe a bit too low level.
23:05:30 <lispy> I don't know of any OSX GUI bindings
23:05:38 <lispy> And then you have gtk2hs for linux
23:05:53 <lispy> But then gtk2hs has a viral license, near as I can tell?
23:06:34 <DRMacIver> lispy: Err. I'm the wrong person to ask due to not really being all that interested in doing GUI dev in Haskell. :) But I'd be happy with either GTK or QT bindings for linux (yes, I know both of those are cross-platform, but that doesn't mean you have to use them that way)
23:07:17 <DRMacIver> Writing Haskell bindings to gtk-server is probably relatively easy to do in a non-viral manner. I don't know how good the results of gtk-server are though - never used it in anger.
23:07:20 <lispy> I think what I want is a reimplemenation of wx in haskell using the native bindings on each platform :)
23:08:55 <Maxdamantus> Maybe someone should invent a portable GUI interface system interface.
23:09:39 <Maxdamantus> Like a global view thing, as in MVC
23:10:10 <Maxdamantus> Well, a global view interface.
23:10:23 <Maxdamantus> The view itself will change depending on the environment.
23:10:59 <lispy> Maxdamantus: that sounds like some research that UW did
23:11:07 <Maxdamantus> UW?
23:11:09 <lispy> I forgot the name of the 'thing' they created
23:11:13 <lispy> university of washington
23:11:35 <Maxdamantus> Do they have a reason for mitting the o?
23:13:00 <lispy> Maxdamantus: yeah.  That's what everyone calls them around here.  So I mmit it by cnventin
23:13:19 <lispy> Oh, I misread your question
23:13:22 <lispy> I don't know why _they_ do it
23:13:34 * hackagebot libgit 0.3.0 - Simple Git Wrapper  http://hackage.haskell.org/package/libgit-0.3.0 (VincentHanquez)
23:14:03 <Maxdamantus> Actually, my uni omits the o
23:14:11 <Maxdamantus> But it's three letters long still.
23:14:26 <Maxdamantus> VU[o]W
23:15:15 <lispy> So, wx uses a modified LGPL that supposedly allows you to not be covered by the GPL
23:15:24 <lispy> I wonder if that's what the wx bindings also use
23:15:28 <lispy> That must be the case
23:15:35 <lispy> So I guess you can use it in closed-source stuff?
23:16:10 <lispy> But, does that really work when we are talking about Haskell?
23:16:13 <lispy> I hate this licensing stuff :)
23:17:37 * lispy goes to bed confused about LGPL nuances
23:30:45 <Maxdamantus> Mm, mupdf is really nice.
23:32:56 <tlonim> Maxdamantus: yeah..it is by same people who wrote gs ..  
23:33:56 * Maxdamantus isn't very familiar with gs' UI
23:34:04 <Maxdamantus> All I know is <enter>
23:34:56 <Maxdamantus> I can't tell any speed difference from xpdf though .. everything I open in xpdf even on my netbook renders instantly.
23:35:41 <Maxdamantus> Unless it's stuffed massive images in, in which case it seems the same.
23:35:54 <siplux> Did something change with mtl between ghc6 and 7 ? (preface:I'm a total noob) On ghc6 "let a = Writer (1,2)" works, but on ghc7 it says its not a constructor?
