00:00:27 <ski> accepted
00:01:49 <adu> so how many people here are in Japan?
00:12:47 <Ptival> is it legal to write something like "do (x:xs) <- sthgReturnsList"?
00:13:20 <c_wraith> yep
00:13:22 <Ptival> or do I have to use a case or a head/tail after binding it to a single variable?
00:13:31 <Ptival> ok, thanks :)
00:13:45 <c_wraith> You don't actually need the parens there, either.
00:14:07 <c_wraith> Since there's only one syntactic group between the start of a line and the <-, it's not ambiguous
00:16:01 <Ptival> ok, even better then
00:16:44 <Ptival> feels nice when you want to write something and it's legit :D
00:18:07 <c_wraith> Just be aware that when you do that, the behavior on a pattern match failure varies between monads.
00:18:16 <c_wraith> in IO, you get an exception on a pattern-match failure.
00:18:38 <c_wraith> in [], it just skips ahead to the next case
00:18:44 <c_wraith> in Maybe, you get a Nothing out of it.  etc
00:18:51 <Ptival> right
00:19:20 <c_wraith> I think most people would rather get rid of that behavior now...  But it's kind of too late
00:24:53 <Skola> I keep running into this http://hpaste.org/44873/during_almost_any_cabal_instal on a Mac
00:48:50 <phreak> if i said "show me all objects with a foo property of 14, plus or minus 3, what would 3 be classified as?
00:49:00 <phreak> "margin" is the best i can think up, but there must be a more precise term
00:49:14 <opqdonut> tolerance?
00:49:30 <phreak> wow, tolerance is actually quite good
00:49:37 <Kaidelong> range?
00:50:18 <phreak> different type of value, but similar idea
00:50:36 <phreak> range is the entire deviation, im looking for the term for the amount variation may be in either direction
00:50:46 <phreak> technically, the term for the value 1/2 of the range
00:51:10 <phreak> tolerance ftw, thanks opqdonut 
00:51:38 <opqdonut> I have a function within-tolerance? :)
00:57:50 <ski> c_wraith : i would rather a use of a refutable pattern there would generate a `MonadZero' constraint
01:01:25 * hackagebot xenstore 0.1.0 - Xenstore client access  http://hackage.haskell.org/package/xenstore-0.1.0 (VincentHanquez)
01:04:54 <Gilly> Can anyone give an intuitive picture of the second derivative of a data structure? The first derivative is something that carries information about where you are in the structure, right?
01:07:16 <cizra> Gilly: Derivative of a data structure? Now this sounds nonsensical. Care to explain where you got the idea?
01:08:27 * hackagebot timeplot 0.2.20 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.20 (EugeneKirpichov)
01:08:38 <ski> cizra : there's a paper by Conor McBride (et al. ?), iirc
01:09:22 <ski> (and probably this is based partially on older math work in combinatorics/species .. i suppose byorgey might know more of the history)
01:09:44 <Ptival> is it possible for fields of a data constructor to be at the same time positional (data Foo = Bar A B C) and named (like in records)?
01:09:51 <Gilly> cizra: when you read about zippers, it is quite often at least referenced to.. there's a short discussion at http://en.wikipedia.org/wiki/Zipper_(data_structure) but there should be better sources as well
01:09:57 <ski> cizra : anyway, consider e.g. the type `data Tree a = Leaf a | Branch a'
01:10:33 <c_wraith> Ptival: record data types can be constructed and pattern-matched positionally
01:10:43 <cizra> What a novel concept.
01:10:56 <Ptival> c_wraith: ok
01:10:59 <ski> er, sorry, `data Tree a = Leaf a | Branch (Tree a) (Tree a)', of course
01:11:35 <ski> cizra : the derivative `d (Tree a) / d a' is the type `Context a', defined by `data Context a = Hole | InLeftBranch (Context a) (Tree a) | InRightBranch (Tree a) (Context a)'
01:12:22 <cizra> ski: Okay, sounds logical so far.. what can I do with it?
01:12:41 <cizra> ski: .. and what is a Hole?
01:12:45 <ski> cizra : the intuition of the type `d (Tree a) / d a' is that values of this type is like values of the type `Tree a', but one `a'-value has been removed from the tree (but the location it was removed from is kept, so there is still a hole, a position, left)
01:13:33 <ski> so, if you have a value `Leaf a0', then if you lift out the element `a0', then you should get `Hole'
01:13:33 <zenzike> á
01:14:07 <cizra> ski: Okay, sounds logical. Why is it called "derivative"? It doesn't (intuitively) resemble calculus.
01:14:18 <ski> if you have `Branch (Leaf a0) (Leaf a1)', then you can either lift out `a0', or `a1', yielding possible values `InLeftBranch Hole (Leaf a1)' and `InRightBranch (Leaf a0) Hole'
01:14:53 <cizra> ski: Can you lift out non-leaf nodes? I Sounds like yes?
01:15:32 <ski> similarly, to `Branch (Branch (Leaf a0) (Leaf a1)) (Leaf a2)' corresponds the three context-values `InLeftBranch (InLeftBranch Hole (Leaf a1)) (Leaf a2)',`InLeftBranch (InRightBranch (Leaf a0) Hole) (Leaf a2)',`InRightBranch (Branch (Leaf a0) (Leaf a1)) Hole'
01:15:38 <cizra> ski: .. or should I take the time to read the articles instead? (;
01:16:25 <ski> no, you can't lift out sub-trees (but you can express that operation, *in*terms* of this derivative)
01:16:49 <cizra> ski: okay, is this good for (for example) marking where you are in the tree, while still preserving the full tree?
01:17:03 <ski> you must have a parametric type `..a..', with a type variable `a', which you differentiate wrt that type variable : `d (..a..) / d a'
01:17:29 * hackagebot splot 0.1.12 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.12 (EugeneKirpichov)
01:17:38 <ski> so `a' is the "(so to speak, collection-) elements", which in an instance can be of any type, because it's a parametric type
01:17:55 <ski> (hence it can't be restricted to always be sub-trees, when thinking of derivative alone)
01:19:08 <ski> cizra : yes, and also for making `O(1)' modifications to a tree, based on being able to modify things at the current place you have marked, as well as being able to move in `O(1)' to a neighbouring node of the tree
01:19:31 <Gilly> Hmm... it seems like the second derivative just got two holes (with order)... Too bad, I was looking for something else.
01:19:33 <ski> (but this is now more properly about zippers in general, rather that derivatives specifically)
01:19:50 <ski> about calling this "derivative" and "differentiating a type (wrt a tyvar)" :
01:20:04 <ski> let's write `data Tree a = Leaf a | Branch (Tree a) (Tree a)' as
01:20:06 <cizra> ski: Where's the resemblance to the derivatives from calculus?
01:20:14 <ski>   Tree a = a + Tree a * Tree a
01:20:22 <ski> now, let's compute
01:20:43 <ski>      d (Tree a) / d a
01:20:55 <ski>   =  d (a + Tree a * Tree a) / d a
01:21:06 <ski>   =  d a / d a  + d (Tree a * Tree a) / d a
01:21:34 <ski>   =  1 + d (Tree a) / d a * Tree a + Tree a * d (Tree a) / d a
01:21:59 <ski>   =  1 + Context a * Tree a + Tree a * Context a
01:22:08 <ski>   =  Context a
01:22:45 <ski> (the last step is more or less the definition of `Context a', and the previous step is like an inductive step, assuming the whole equality chain already holds for the two subtrees)
01:22:46 <cizra> Why does the last equality hold?
01:23:20 <Gilly> One could have written Context a = d (Tree a) / d a at the start (could have been more logical that way).
01:23:24 <cizra> The next-to-last step is the definition of `Context a', but the last one is much more hazy
01:23:32 <cizra> Gilly: Actually ski did
01:23:51 <kosmikus> we define "Context a" to be "d (Tree a) / d a"
01:24:00 <cizra> < ski> cizra : the derivative `d (Tree a) / d a' is the type `Context a',
01:24:30 <ski> yeah, it would maybe have been better if i had started by explicitly defining `Context a  =  d (Tree a) / d a', and then making a proof that `d (Tree a) / d a  =  1 + Context a * Tree a + Tree a * Context a'
01:24:33 <Gilly> cizra: ah, missed that... But anyway, you started with Context a so it's still Context a in the end.
01:24:46 <cizra> ahhhh. hehe
01:25:03 <cizra> Sneaky
01:25:19 <ski> (what i did is more like letting how the proof naturally unfolded guide which definition of `Context a' was sensible, and then conceptually "backpatching" by saying that this is what we "originally" wanted to define `Context a' as)
01:26:08 <ski> so, this is called derivative, because the rules for computing with is look like the familiar rules for continuous analysis
01:26:25 <cizra> *nod* I see now, thanks
01:26:33 <zenzike> has there been any work into type integration?
01:28:28 <ski> (btw, cf. with proving that a recursively defined sequence is equivalent to a "closed" formula, not by "by oracle" "guessing" the correct formula at the start, and then proving that it's correct -- but rather more similar to only guessing the main algebraic form of the formula (a second degree polynomial, or something with an exponential with some unknown factors, &c.), and then using the search for proof to derive what the parameters of the pa
01:29:25 <ski> so, another example is that `d [a] / d a  =  ([a],[a])'
01:29:59 <ski> i.e., if you take a list, and consider the things you get if you remove one element, then you effectively get two lists, the prefix, and the suffix, of the removed element
01:30:09 <cizra> A LOT of math causes indigestion to me especially because of that reason. Some guy pulls a very complex solution out of his arse and then proves it.
01:30:19 <ski> (so we get two lists, nott one list, because we have to remember the position of the hole)
01:30:28 <cizra> *nod*
01:31:09 <Ptival> Is there some way to define a synonym of Int with a different show without using a data constructor?
01:31:23 <ski> cizra : yeah, i'm in favour of presenting proofs and reasoning in a style, and order, so that "each step flows naturally from the already presented ones (especially the closest previous step)"
01:32:20 <cizra> ski: Another thing mathematicians ought to do is to present the historical background. Why was the problem solved. What can be done with it.
01:32:40 <ski> monochrom has some similar remarks about epsilon-delta proofs at <http://www.vex.net/~trebla/homework/epsilon-delta.html>
01:33:02 <Gilly> Anyway... I would need something like this: I got a list of "files" in a "filesystem", which is just a tree. Each file should know their location in the filesystem and on the other hand each folder should know its subfolders and files. Now problems arise when I want to change the name of a folder for example: I'll have to change the names of the folders in each of those files' location info as well as the filesystem. Is there some neat/efficient solut
01:33:14 <ski> yeah, for motivation, and "why was this generalization needed / considered interesting ?"
01:36:18 <c_wraith> Gilly: one traditional solution in that case is a layer of indirection - internal links use an internal name that isn't ever changes, external views use external names that have a mapping to internal names.  This is very similar to how filesystems work.
01:36:29 <c_wraith> err, isn't ever *changed
01:37:15 <ski> cizra : as you may suppose, one can imagine functions `select :: Differentiable f => f a -> [(D f a,a)]' and `plug :: Differentiable f => D f a -> a -> f a', such that `forall fa. all (fa ==) (map (uncurry plug) (select fa)) = True' and `forall dfa a. elem (dfa,a) (select (plug dfa a)) = True'
01:37:30 <Gilly> hm, might do.. on the other hand I wouldn't like to go for anything overly complicated because the number of files/folders here is relatively small
01:37:58 <Gilly> What I'm actually doing is an extension to xmonad which would let me to arrange my workspaces under folders.
01:38:36 <c_wraith> If it's reasonably small, you could just traverse the whole structure and rename as appropriate.
01:40:27 <ski> cizra : an alternate way, which seems to work in at least some cases is `unplug :: (Differentiable f,Naperian f) => E f a -> f a -> (D f a,a)' and `plug :: (Differentiable f,Naperian f) => D f a -> a -> (E f a,f a)' such that `uncurry unplug' and `uncurry plug' are inverses
01:40:29 <Gilly> Yea. I guess this is no time for premature optimization.
01:40:51 <ski> and where `E f a' represents the possible *paths* to `a'-elements in a value of type `f a'
01:42:19 <cizra> ski: I think that goes a bit above my head right now, sorry.
01:42:29 <cizra> ski: Also, you've satisfied my curiosity, thank you (=
01:43:57 <ski> `E' stands for "elasticity of demand" (a concept used in economics), which is defined as `E f x = D f x * x / f x' (such that `E (^n) x = n * x^(n-1) * x / x^n = n), which is basically saying just `E f x * f x = D f x * x', which is our `unplug'/`plug' isomorphism
01:45:09 <ski> the isomorpism says that a collection of elements, together with a path to one of the elements, is isomorphic to the collection of elements with the element removed (leaving a hole), together with the element, separated on the side
01:45:32 <ski> however, `E' only works when you have paths which work in *all* collections
01:45:42 <ski> so, if you consider infinite streams, paths are natural numbers
01:46:02 <ski> but for finite lists, it doesn't work, since for some lists, there is no element at index `i'
01:46:21 <ski> cizra : anyway, look into Conor McBride's papers on this :)
01:46:47 <ski> (and i've also heard the Zipper chapter at wikibooks for Haskell recommended)
01:48:11 <ski> Gilly : under two conditions, you can do this easily with a zipper
01:48:20 <btutt> the zipper chapter was pretty cool. 
01:49:06 <ski> the conditions are : (a) you can't have cycles in your filesystem (no hard links), it must be a tree (not necessarily with a unique root, though)
01:49:34 <ski> and (b) you can't allow concurrent access, only a single access
01:50:06 <ski> Gilly : i implemented a small text adventure map like this, it was quite fun :)
01:50:47 <ski> at any time, the current room was the room at the root of the current map tree
01:51:03 <ski> every room only pointed to later rooms, no back-references
01:51:55 <ski> whenever i followed a passage to another room, i would "reverse" that passage, and at that as a passage from the new room to the old room (obv. minus the old un-reversed passage)
01:52:19 <ski> one-way passages of course just discarded the old room (and other room it was connected to), instead
01:52:50 <Gilly> ski: here I have the problem that I have to know the locations of individual files
01:52:55 <ski> so, each room in the map contained the state associated with it, its items, &c.
01:53:24 <ski> (and, at the side, i have the inventory of the player)
01:54:47 <ski> Gilly : istr xmonad already uses zippers to structure various things with a current focus, so probably it would not only make sense, but fit it, to use zippers for what you want (assuming it fits the conditions)
01:55:12 <ski> Gilly : what do you mean by "locations of individual files" ?
01:55:23 <Gilly> In this case the files are the workspaces.
01:55:34 <ski> and "locations" are ?
01:55:42 <Gilly> And now if the user wants to switch to a certain workspace, I'd like to update my location in the tree.
01:55:50 <ski> coordinates and display&screen ?
01:55:55 <Gilly> The locations are some categories or folders I want to arrange my workspaces to.
01:56:12 <Gilly> So for example under programming folder I might want to put workspaces "haskell", "python" and "C".
01:56:28 <accel> is it possible to instead of "myAdd :: Double -> Double -> Double" define "myStrictAdd :: Double -> Double -> !Double"; where myStrictAdd, instead of creating a thunk, executes it on the spot?
01:56:39 <Gilly> These folders will also remember the last visited workspace etc... but that's not important now.
01:57:15 <anincog> What am I missing if criterion gives me "ERROR: output type PNG 400 200 not supported on this platform" when asked to produce a PNG?
01:57:21 <ski> accel : that doesn't make sense. `myStrictAdd x y' would only every actually call `myStrictAdd' because the result was demanded/forced
01:57:52 <ski> accel : so, whenever `myAdd' get the control (and two arguments), we already know that the result should be evaluated
01:58:27 <accel> whoa
01:58:34 <accel> damn; my mental model of how haskell executes code sucks
01:58:41 <ski> accel : notice that this is different from `myAddLazy :: Double -> Double -> Thunk Double', where `data Thunk a = MkT a' (*not* `newtype' or strict `data')
01:58:55 <ski> so, this only applies to the *top-level* result
01:59:30 <accel> so the way to think of ! is as:
01:59:40 <accel> "when my immedaite top-level is needed; execute me too" ?
02:00:00 <ski> i suppose, yes
02:03:22 <ski> (`!' is used in two difference circumstances (apart from as an operator) : (a) in `data' declarations; and (b) in patterns -- i suppose one might think of `data Foo = MkF !Bar' as defining `MkF !bar = reallyConstructFoo bar' .. i.e. more or less `data Foo = MkF# Bar' and `MkF !bar = MkF# bar')
02:04:14 <ski> Gilly : do you want to also use a type `Folder', which doesn't have a selected workspace ?
02:06:21 <ski> i suppose relevant here is something that i only mentioned very briefly above
02:07:11 <ski> cizra : recall the correspondence between a tree value and its "context" (i.e. the rest of the tree, except a particular element which we have marked / in focus)
02:07:18 <ski> a larger example is
02:07:58 <ski>   B (B (L 0) (B (L 1) (L 2))) (B (L 3) (L 4))
02:08:16 <ski> let's say we want to mark / focus on the `1', then the corresponding context is
02:08:56 <ski>   InL (InR (L 0) (InL H (L 2))) (B (L 3) (L 4))
02:09:14 <ski> this might be called a "top-down context" of the `1' element, in this tree
02:09:56 <Gilly> ski: All folders have a selected workspace unless they don't have any workspaces attached to them.
02:09:57 <ski> in practical uses of zippers and derivatives, one usually uses instead the "bottom-up context" version, which in this particular case is
02:11:26 <ski>   FromL (FromR (L 0) (FromL R (B (L 3) (L 4)))) (L 2)
02:11:34 <ski> where the corresponding type definition now is
02:12:10 <ski>   data Context a = Root | FromLeftBranch (Context a) (Tree a) | FromRightBranch (Tree a) (Context a)
02:12:24 <ski> the idea is that we invert the path from the root to the hole
02:12:41 <ski> we can also think of this as a list of levels, and then we just reverse the list
02:13:02 <ski> the point of doing this is that then the local movement operations becomes `O(1)'
02:13:47 <ski>   up :: Context a -> Maybe (Context a)
02:14:18 <ski>   up  Root                = Nothing
02:14:21 <accel> err; just to be clear
02:14:25 <accel> all this is answering Gilly's question right?
02:14:34 <accel> I'm kinda lost if this is in reference to !
02:14:58 <ski> accel : it is elaborating on zippers re Gilly's question, as well as cizra's ponderings about zippers
02:15:03 <accel> noted; thanks
02:15:39 <ski> hm, oh i realize i missed a thing here
02:16:17 <ski> i inadvertently went from marking an element (in this case a leaf, because it was a leaf-tree), to marking a sub-tree
02:16:41 <ski> this is a natural step to take, but one should be aware of the difference
02:16:50 <ski> markings of elements is related to derivative
02:17:30 <ski> markings of sub-trees falls under the more general fuzzy "zipper" concept (but i thinkn derivatives also do .. it's not clear to me, at least)
02:18:05 <ski> (and marking a sub-tree can be expressed in *terms* of derivatives, but isn't *directly* a derivative of the type)
02:18:48 <ski> anyway, since we had a leaf-tree, we can now reinterpret `Hole' in a context to stand for a removed sub-tree, rather than an element removed from a `leaf' node
02:19:09 <ski> and then a tree with a marked / *forcussed* subtree is
02:19:30 <ski>   type FocusTree a = (Context a,Tree a)
02:19:35 <ski> and we get
02:19:50 <ski>   up :: FocusTree a -> Maybe (FocusTree a)
02:20:28 <ski>   up (Root               ,subTree) = Nothing
02:21:11 <ski>   up (FromL parent right,subTree) = Just (parent,Branch subTree right)
02:21:30 <ski>   up (FromR left  parent,subTree) = Just (parent,Branch left  subTree)
02:21:59 <Xilon> oh a zipper
02:22:44 <ski> and similar `O(1)' operations for `downLeft',`downRight' and `currentElement :: FocusTree a -> Maybe a' (`Maybe' since the elements was only in leaves, instead of in internal nodes, in this case)
02:23:05 <ski> (accel : and no, not in reference to `!')
02:23:39 <ski> Gilly : ok
02:23:58 <Gilly> ski: And this workspace might also belong to one of the subfolders.
02:24:00 <ski> so, conceptually, we can consider types `Folder' and `FocusFolder'
02:24:57 <ski>   type Folder = [FolderItem]
02:25:26 <ski>   data FolderItem = Workspace Workspace
02:25:26 <ski>                   | SubFolder Folder
02:25:31 <ski> something like that, i assume
02:25:50 <ski> (possibly with more information attached to the nodes in the "file system")
02:26:27 <ski> we can abstract this to
02:26:53 <ski>   type Folder a = [FolderItem a]
02:27:08 <ski>   data FolderItem a = Element a
02:27:17 <ski>                     | SubFolder (Folder a)
02:27:56 <ski> and then corresponding contexts are
02:27:59 <Gilly> ski: Let's say that we have some type FileMap = Map String File, data File = File { fileLocation :: Zipper }. In addition I have some currentLocation :: Zipper. Now if I go and remove the folder at currentLocation, I have to refresh the zipper of every one of those files.
02:29:16 <ski> ok, `Map String' is probably more sensible than `[]', yes
02:29:18 <Ptival> what is the common way to create an exception? -XDeriveDataTypeable or writing your instance Typeable?
02:29:31 <Gilly> With this system it's easy to move around, though... So maybe calculating the zippers from currentLocation wouldn't be too painful.
02:29:49 <ski> Ptival : i thought you were to make an instance of `Exception' ?
02:30:05 <quicksilver> Ptival: (as an aside, never write your own Typeable instance)
02:30:09 <ski> @hoogle catch
02:30:09 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
02:30:09 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
02:30:09 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
02:31:06 <quicksilver> ski: well Typeable is a superclass of Exception
02:31:15 <Ptival> ski: but to make an instance of Exception, I have to derive Typeable, don't I?
02:31:29 <Gilly> Obvious pitfall of this is that I'm holding #{of files} copies of the tree, each containing at least #{of files} nodes, but I don't think this is very bad until there are hundreds of workspaces.
02:31:32 <quicksilver> Ptival: Yes. Just derive it. As the docs instruct.
02:31:54 <ski> yeah (i just objected to it sounding like you thought `Typable' was the main issue here .. but i probably misunderstood, it seems)
02:31:58 <Ptival> quicksilver: but then it yells I have to -XDeriveDataTypeable, so that's what I should do?
02:32:10 <Gilly> Another option would be to store just path from root as the location and always start from the root and move along the path to arrive at the file.
02:32:37 <ski> Gilly : i can't say i understand your reasoning for `data File = ...' and `currentLocation :: Zipper'
02:33:05 <siracusa> Ptival: Add {-# LANGUAGE DeriveDataTypeable #-} at the very top of your module.
02:33:17 <ski> Gilly : i was above more or less trying to *derive*, from the basic unfocused concepts, what a zipper / focused folder should look like, in your case
02:33:57 <Gilly> ski: oh, well, I don't think I have trouble doing that... it's just that I'm not sure if this is the most logical way to do this.
02:34:35 <Ptival> siracusa: ok
02:35:12 <ski> Gilly : yeah, i can't follow your logic above, after the `type FileMap = Map String File' part
02:35:29 <ski> (i suspect you have some misunderstanding of how zippers work)
02:36:21 <Gilly> Ok, so in that FileMap the String is just the name of the workspace. Now I want to store the location of every file in the system, so that I can instantly jump into the given file when the user asks to change the workspace.
02:36:37 <Gilly> This would mean replacing currentLocation with fileLocation.
02:37:16 <ski> hm, ok, so you want a global map from some global "pet"-names to paths in the filesystem ?
02:37:25 <Gilly> yes
02:37:57 <ski> (i though your `type FileMap = Map String File' was supposed to be the mapping that maps each name inside a folder to the item (workspace or subfolder), which the name refers to)
02:38:20 <Gilly> No. That map actually contains every file in the system.
02:38:46 <ski> but you still presumably want to be able to navigate in the file-system explicitly, as well (otherwise, why have the filesystem ?) ?
02:38:58 <Gilly> exactly
02:41:08 <Gilly> Maybe it would be better to just store paths in that map and use zipper for the navigation part.
02:42:46 <Ptival> can I write an "instance Show (Maybe Something)" ?
02:43:25 <mauke> Ptival: no, that already exists
02:47:17 <anincog> What optimization parameters should I pass when benchmarking with criterion?
02:47:35 <anincog> Some sources say -O, some say -Odph (the latter I don't even know what means)
02:47:39 <ski> (hm, back)
02:48:16 <anincog> (talking about GHC here, btw)
02:49:46 <ski> Gilly : ok, so i was trying to ponder how to describe the "file system" alone, together with "current folders"
02:50:28 <ski> so, assuming
02:51:04 <ski>   type Folder a = Map Name (FolderItem a)
02:51:14 <ski>   data FolderItem a = Element a
02:51:19 <ski>                     | SubFolder (Folder a)
02:52:30 <ski> and assuming that we already have a suitable `MapContext' type (if `Map k v' is `[(k,v)]', then `MapContext k v' is `([(k,v)],k,[(k,v)])')
02:53:39 <ski> we could describe contexts around a currently focussed sub-folder as
02:53:55 <ski>   type FolderContext a = MapContext Name (FolderItemContext a)
02:54:11 <ski>   data FolderItemContext a = Root
02:54:43 <ski> hm, no
02:54:55 <Ptival> showTop (Just c{n=n})     = " " ++ show n ++ "  "   -- what's wrong in this pattern matching?
02:55:25 <ski> Ptival : you must use a constructor in place of `c'
02:55:41 <Ptival> oh right :)
02:55:48 <Ptival> thanks
02:56:43 * ski imagines Gilly is busy actually trying to implement some idea, while ski is flailing around, trying to find the right ideas
02:57:14 <ski> (anincog : sorry, i don't know)
02:57:16 <Veinor> haha
02:57:51 <quicksilver> ski: that makes Gilly an engineer and you a poet, right?
02:58:21 <ski> well, that might be a correct description i suppose
02:59:10 <Gilly> I'm actually a math guy.. :) That's why nowadays I ponder too much about things trying to reach perfection. But yea, I'm actually trying something already.
02:59:27 <ski> *nod*
03:00:11 <ski> anyway, you go on trying out what you have in mind, reporting back then, while i try to ponder this some more
03:00:47 <ski> (of course i can't just check a source for how to do these kinds of zippers -- that would spoil all the fun :)
03:01:55 <ski> so i suppose i was first confusing two different things, here
03:02:23 <ski> (a) we want to have a currently focussed workspace in the foldersystem
03:02:52 <ski> (b) we probably want to have a currently focussed *folder* in the foldersystem, as well, for purposes of navigating to another workspace
03:03:11 <ski> the former is the derivative `d (Folder a) / d a'
03:03:36 <ski> the latter is a zipper, where we mark/focus/remove sub-*trees/folders*
03:05:34 <ski> very loosely speaking, the latter (b) is `d (Folder a) / d (Folder a)' and `d (FolderItem a) / d (Folder a)' (where in the "numerator" we are considering a sub-folder of a folder or a folder-item)
03:06:40 <ski> ah, now i think i see
03:06:42 <Gilly> ski: Here the thing however is that xmonad itself tells us which workspace is focused. So we need a map from the workspaces to the foldersystem sending each workspace to its folder.
03:07:15 <ski> oh .. so the workspaces already exists (in some flat list/map) in xmonad ?
03:07:24 <Gilly> yes
03:07:25 * ski obviously has never tried xmonad :)
03:07:34 <Gilly> aso :)
03:08:20 <ski> (i suppose i ought to have known that, since i "knew" that xmonad already used zippers for workspace)
03:10:21 <ski> ok. i think i'll first imagine that workspaces don't already exist in a separate structure, and then later take that into account
03:10:36 * ski trods on
03:11:00 <ski> so
03:11:52 <ski>   type FolderContext a = (Map Name (FolderItem a),Name,FolderItemContext a)
03:14:14 <ski>   data FolderItemContext a = Root
03:14:14 <ski>                            | InFolder (FolderContext a)
03:17:05 <ski> so, i suppose `FolderItem a' is maybe the more "primitive concept", i.e. the root of the foldersystem is then a folderitem, i.e. either a single workspace, or a folder
03:17:30 <ski> the alternative would be to say that the root is always a folder
03:19:02 <ski> so, the idea being that in `Folder a = Map Name (FolderItem a)', if we remove a `FolderItem a', then either one of the values in the direct key->value (name->folder-item) associations are removed, or a (proper) sub-folder-item is removed from that folder item
03:19:43 <ski> in any case, the "broken" association is `(Name,FolderItemContext a)' above, and `Map Name (FolderItem a)' is the remaining associations
03:20:22 <ski> (i inverted the contexts above, to get a bottom-up zipper, for efficiency, hence `Root' instead of `Hole')
03:20:41 <ski> (oh, and i suppose s/InFolder/FromFolder/)
03:21:40 <ski> so, now we can define a context, together with the part which was removed to yield the context
03:21:56 <ski>   type FolderFocus a = (FolderContext a,FolderItem a)
03:22:24 <ski>   type FolderItemFocus a = (FolderItemContext a,FolderItem a)
03:22:56 <ski> (and these are probably really the more interesting types, the contexts are just a means to get to this end)
03:24:02 * ski doubts
03:25:04 <ski> hm, maybe i should consider a picture
03:26:10 <ski>   /- a -/- w0
03:26:40 <ski>   |     +- b -/- *w1*
03:27:09 <ski>   |     |     \- w2
03:27:16 <augur> ski
03:27:17 <ski>   |     \- w3
03:27:21 <augur> i will murder your hands so hard
03:27:33 <ski>   \- w4
03:27:56 <augur> are you doing this with fregean logical notation?
03:27:57 * ski 's hands feel just fine, atm, tyvm
03:27:57 <augur> wtf is this
03:28:18 <ski> no, this is not Begriffsschrift :)
03:28:25 <olsner> hmm, ski has written almost every message since 11.30
03:28:30 <augur> well it LOOKS it!
03:28:37 <augur> oh god its invasion of the esoterics
03:28:39 <ski> it's just supposed to be a picture of a folder-system/tree
03:28:39 <augur> BACK I SAY
03:28:41 <olsner> it's unusual to manage a monologe in #haskell
03:28:43 <augur> BACK TO THE OTHER CHANNEL
03:29:02 <olsner> augur: ski is not even in #esoteric
03:29:12 <augur> so?
03:29:34 <augur> alcopop! \o/
03:29:39 <augur> no myndzi :(
03:30:13 <olsner> so it's not an invasion of the esoterics if ski does it... well, at least not the #esoterics
03:30:32 <augur> bah
03:30:35 <augur> hes an esotericist
03:32:27 * ski . o ( "I say to you againe, doe not call up Any that you can not put downe; by the Which I meane, Any that can in Turne call up Somewhat against you, whereby your Powerfullest Devices may not be of use." )
03:33:18 * hackagebot tabular 0.2.2.3 - Two-dimensional data tables with rendering functions  http://hackage.haskell.org/package/tabular-0.2.2.3 (EricKow)
03:34:46 <ski> (olsner : yeah, sometimes i have a tendency to ramble / ponder aloud .. if you think it's inappropriate in this case, just tell)
03:35:39 <augur> ski: im kidding ofcourse
03:36:37 <ski> yeah, i surmised that :)
03:37:05 <augur> no im really not, diaf
03:37:39 <ski> anyway, the intent above is that `w1', as a folder item, is marked in the folder tree
03:38:02 <ski> hm, i suppose i should have had a subfolder focussed instead .. nvm that now
03:38:36 <ski> so, following the path from `w1' up to the root, we get the context of `w1'
03:40:13 <ski> the first step is a `FromFolder', and we're now supposed to specify the remaining items in this folder, before we continue upward
03:40:19 <ski> which means that
03:41:01 <ski>                            | InFolder (FolderContext a)
03:41:04 <ski> ought to have been
03:41:35 <ski>                            | FromFolder (Map Name (FolderItem a)) (FolderContext a)
03:42:08 <ski> no, we also need the name of the folder item we came from, so
03:42:13 <ski>                            | FromFolder (Map Name (FolderItem a)) Name (FolderContext a)
03:42:33 <ski> and then we need the context of the folder, so
03:43:47 <ski> hmhm
03:46:28 <ski> something is still wrong, here
03:47:37 <ski> a `FolderItemContext a' is supposed to represent a `FolderItem a', with a single sub-`FolderItem a' removed
03:47:50 <ski> in case that's the whole shabang, we have `Root'
03:50:01 <ski> otherwise, the only position here an item can occur is in the map inside a folder, so the other constructor should have a "parent/context" argument of type `FolderContext a' for the rest, and also arguments which decsribe the contexts of this specific folder, except the item we came from
03:50:16 <Ptival> say I have data A = A { foo::T }, data B = B { foo::T }, why is it ambiguous when I write pattern (B{foo=foo}) = ... ?
03:51:05 <parcs> what is the type of foo?
03:51:54 <ski> Ptival : it's not, in itself, however writing e.g. `foo (x,y) = bar x (foo y)' is ambiguous. the current solution/approach is to disallow such multiple declaration of `foo' as in `data A = A { foo :: T }; data B = B { foo :: T }' completely
03:52:04 <ski> (and what parcs said)
03:52:40 <Ptival> actually the types are even different in both data
03:52:52 <Ptival> in one it's a Maybe C, in the other it's an Int
03:53:18 <Ptival> so all my record elements have to have a unique name?
03:53:28 <Ptival> seems strange
03:54:03 <ski> the point is that a declaration `data A = A { foo :: T }' does two things : (a) binds an *ordinary* variable name `foo' to a particular function of type `T -> A'; and (b) says that there's a "field-name" `foo' in scope, which is to be used in pattern-matching, and record construction/update
03:54:33 <ski> and it's the (a) part here which does jibe well with having both `data A = A { foo :: T }' and `data B = B { foo :: T }'
03:54:49 <Ptival> ok
03:55:00 <ski> (s/it's/it's mainly/)
03:55:09 <parcs> you mean A -> T
03:55:21 <ski> er, yes of course
03:55:54 <ski> (you *can* reuse the same field name in different constructors, if the type of the field is the same, however)
03:56:08 <Ptival> in my case it's not
03:56:12 <ski> (s/different constructors/different constructors of the same type declaration/)
03:56:13 <ski> right
03:56:29 <Ptival> it's not even the same declaration
03:57:25 <Ptival> just, something like "id" or "name" that different types share
03:57:55 <ski> if Haskell had polymorphic records (as Hugs has), one could say `#foo :: (r \ foo) => Rec { foo :: a | r } -> a'
03:58:25 <ski> i.e. `#foo' would be the polymorphic selector function that accepts *any* record at all which has a field named `foo'
03:58:58 <ski> (OCaml also has basically this, in its object system)
03:59:36 <quicksilver> you can encode that kind of thing with some typeclasses around fclabels or data.accessor
03:59:46 <quicksilver> you end up with a class called 'HasFoo' or suchlike.
04:00:29 <ski> Ptival : *nod* .. sometimes i wish for declaring a small module inside the main module for this, so that we have types `A.A',`B.B' and field names `A.id' and `B.id'
04:00:54 <ski> *nod*
04:01:35 <Ptival> yes, I can definitely see how you might rapidly have a conflict with common field names like this...
04:01:38 <ski> (or types `A.T',`B.T', if we prefer MLism)
04:02:24 <quicksilver> yes, nested modules would be a convenience
04:02:26 <ski> Ptival : in some cases, one can generalize the common parts, and factor out .. but in other cases, it's conceptually different things, which just happen to want to use the same names
04:02:28 <quicksilver> (for namespacing only)
04:02:38 <quicksilver> I just namespace manually
04:02:56 <quicksilver> data A = A { aFoo :: T }; data B = B { bFoo :: T }
04:03:13 <quicksilver> and, if it seems to merit it, "class HasFoo a where foo :: a -> T"
04:03:22 <Ptival> quicksilver: that's what I'll do
04:04:07 <ski> Ptival : i recall defining `data Named a = WithName {name :: String,obj :: a}', and then using `Named Foo' and `Named Bar' inside other things like e.g. `[Named Foo]'
04:05:00 * ski wonders whether a GADT (or `type'/`data' family ?) might be sensible as well, here
04:06:56 <Ptival> tiens un franÃ§ais :)
04:08:25 <ski> hm, no a type class (possibly with associated type) would be more sensible
04:08:56 <ski>   class HasFoo a
04:08:57 <companion_cube> et oui, c'est plein de franÃ§ais ici :)
04:08:58 <ski>     where
04:09:09 <ski>     type FooField a
04:09:24 <ski>     foo :: Lens a (FooField a)
04:09:29 <ski> something like that
04:09:46 <Ptival> how to pattern match against the value of a record field? By naming it with { field=binding } then guarding against the binding?
04:09:59 <ski> (that enables having different types `T' of the fields `foo' in different "record" types)
04:10:54 <ski> > case Node {rootLabel = 0,subForest = []} of Node {rootLabel = x} -> x
04:10:55 <lambdabot>   0
04:11:02 <ski> > case Node {rootLabel = 0,subForest = []} of Node {rootLabel} -> rootLabel
04:11:02 <lambdabot>   Illegal use of punning for field `rootLabel'
04:11:02 <lambdabot>  Use -XNamedFieldPuns to permi...
04:11:17 <ski> > case Node {rootLabel = 0,subForest = []} of Node {rootLabel = x , ..} -> x
04:11:18 <lambdabot>   Illegal `..' in record pattern
04:11:18 <lambdabot>  Use -XRecordWildCards to permit this
04:11:52 * ski isn't sure why omitting fields in the pattern, as well as omitting fields, while using `..', both works (given extensions)
04:14:34 <ski> so, to be very explicit, we get
04:14:38 <zygoloid> (omitting fields is allowed in H'98)
04:14:43 <ski>                            | FromItemInFolder (Map Name (FolderItem a)) Name (FolderContext a)
04:15:11 <ski> (ok, i can't recall seeing that before)
04:16:30 <zygoloid> > let isJust Nothing = False; isJust Just {} = True in isJust (Just 123)
04:16:31 <lambdabot>   True
04:16:53 <ski> oh .. that's right, i recall seeing that
04:17:21 <Ptival> f c d b@(B {bN=n}) | n == Nothing = b {bN = Just c} -- can I merge the guard in the pattern somehow?
04:17:49 <ski> so, after a use of `FromItemInFolder', we have stepped from an item to a folder containing it. now since the root is an item, the only way we could have reached a folder is if an item was a folder (as opposed to a workspace)
04:18:02 <parcs> Ptival: {bN=Nothing} = ...
04:18:03 <ski> Ptival : of course ! :)
04:18:14 <Ptival> ok
04:18:28 <ski> > case Node {rootLabel = False,subForest = []} of Node {rootLabel = False} -> ()
04:18:29 <lambdabot>   ()
04:19:51 <ski> (patterns are supposed to, imnsho, to be "like expressions, but backwards", i.e expressions which make sense as patterns ought to be allowed, and vice versa (and converting back and forth between a value to match and an environment of bindings should yield more or less an isomorphism)
04:19:56 <Ptival> parcs: so what I put on the right of the '=' will either be a new name, which will get the value of bN, or something already bound, in which case it checks that it matches with the value of bN?
04:20:10 <ski> )
04:20:17 <parcs> Ptival: what you put on the right is a pattern
04:20:57 <ski> `Con {field = <expr>,...}' is an expression. `Con {field = <pat>,...}' is a pattern
04:21:14 <Ptival> it's either already bound, in which case it checks type consistency, or it is unbound, and then it binds it?
04:21:30 <ski> Ptival : no, it matches recursively
04:21:30 <Ptival> ski: ok
04:21:53 <parcs> Ptival: no, you can't do something like f x x = x
04:21:57 <ski> it matches the value of the field of the given input record value, with the sub-pattern you have specified after `field = '
04:23:29 <ski> so you can have a pattern `A {isFoo = False,t = Node {rootLabel = "hello",subForest = children}}' e.g.
04:24:17 <ski> compare this with the pattern `A False (Node "hello" children)'
04:24:24 <matthew-_> right, in "pure" code (i.e. outside IO or probably even things like STM), can you construct a datastructure that, in the RTS, is actually represented by a circular structure?
04:24:25 <ski> it's basically the same thing
04:24:35 <matthew-_> i.e. does the GC actually need to do cycle detection?
04:24:52 <opqdonut> matthew-_: let x = 1:x in x
04:24:57 <ski> matthew-_ : yes, you typically get that by using recursive definitions
04:25:13 <hpc> > let x = 1:x in x
04:25:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:25:27 <opqdonut> ^ that is actually cyclic
04:25:28 <hpc> > let x = 1:x in sum . take 10 $ x
04:25:29 <lambdabot>   10
04:25:30 <matthew-_> opqdonut: surely that is a function
04:25:31 <ski> matthew-_ : so in `repeat x = xs where xs = x : xs', `xs = xs : xs' is a recursive definition, which typically defines `xs' cyclically
04:25:48 <opqdonut> matthew-_: no, that is a list
04:25:59 <matthew-_> ahh, but only because you've evaluated it
04:26:13 <matthew-_> this might be a false distinction to amke in haskell
04:26:21 <ski> matthew-_ : similarly, in `repeat x = x : repeat xs', *`repeat'* is a cyclic value (a cyclic *closure*) -- but typically `repeat x' here won't return a cyclic value
04:27:01 <ski> matthew-_ : functions must take arguments -- if it doesn't take an argument, it's not a function
04:27:22 <matthew-_> ski: ahh ok
04:27:43 <hpc> if the body of the value is a lambda, GHC still doesn't see a function
04:27:48 <ski> iow, functions have types which look like `... -> ...'
04:27:54 <hpc> leading to some odd behavior with the monomorphism restriction
04:28:30 <ski> (where the `...'s are any types whatsoever)
04:28:41 <matthew-_> ski: but something like let x = 1:x in x - by lazy evaluation, that is only potentially an infinite list. Thus it is a "function" - ok, it's not a "haskell" function, but it's a bit of code that is only evaluated to spit out values as they're actually required
04:28:45 <rostayob> is there any documentation on hsp?
04:28:47 <rostayob> e
04:28:53 <matthew-_> now sure, that's a property of lazy evaluation...
04:29:00 <matthew-_> yes/no?
04:29:08 <opqdonut> matthew-_: that is actually a cyclic structure in memory
04:29:25 <ski> matthew-_ : you have to distinguish between what it is, on the level of the syntax and declarative semantics of Haskell; and what it could be implemented in terms of, in a lower level
04:29:36 <ion> > let (==') a a = True; (==') _ _ = False in 42 ==' 42
04:29:36 <lambdabot>   <no location info>:
04:29:36 <lambdabot>      lexical error in string/character literal at chara...
04:29:39 <matthew-_> ski: I'm specifically asking about the RTS
04:29:41 <opqdonut> matthew-_: but of course pure code cannot distinguish between a cyclic list of ones and a (potentially) infinite list of ones
04:29:59 <ion> Erlang: > fun (X,X) -> true; (_,_) -> false end (42, 43).
04:29:59 <ion> false
04:30:03 <rostayob> the the website linked here is down: http://hackage.haskell.org/package/hsp
04:30:10 <matthew-_> opqdonut: ok, so the RTS GC does need to do cycle detection then when traversing that structure?
04:30:11 <ski> matthew-_ : yes, typically all lazy thunks are implemented in terms of *procedures* (a snippet of code which you can jump to, to begin an execution) .. but this is not the Haskell concept of `function'
04:30:12 <quicksilver> opqdonut: heresy!
04:30:17 <quicksilver> opqdonut: there *is* no difference :)
04:30:23 <opqdonut> matthew-_: yes
04:30:27 <quicksilver> matthew-_: cycle detection for what purpose?
04:30:33 <matthew-_> quicksilver: GC
04:30:37 <quicksilver> matthew-_: it doesn't confuse the garbage collector
04:30:44 <quicksilver> yeah, the GC keeps seen-sets or similar.
04:30:55 <matthew-_> quicksilver: right indeed. Cool. Many thanks for all your help
04:31:05 <ion> The first X is an assignment, the second one is a pattern match against the former one.
04:31:40 <ski> matthew-_ : another implementation is to do graph-reduction, where the thunks are just non-reduced nodes in a graph, and there's a separate interpreter, which reduces the graph
04:32:27 <ski> ion : you can't use a "prime" in an operator name
04:32:46 <ion> ski: Yeah, but it doesnât work without that error either. :-)
04:33:01 <ion> > let a == a = True; _ == _ = False in 42 == 43
04:33:01 <lambdabot>   Conflicting definitions for `a'
04:33:01 <lambdabot>  Bound at: <interactive>:1:4
04:33:01 <lambdabot>            <in...
04:33:02 <ski> *nod*
04:33:23 <ski> in Mercury it does, though .. and in Erlang as you say
04:33:30 <ski> in fact, Erlang inherited this from Prolog
04:35:05 <ski> (ion : also nitpick s/assignment/instantiation\/initialization/)
04:35:20 <ion> :-)
04:36:09 <ski> (sometimes confusingly called "binding", which usually refers to a different concept ("bound variable" and "scope"))
04:36:30 <JuanDaugherty> prolog is nearly 40
04:37:23 <JuanDaugherty> but no lang is yet 60
04:37:51 <ion> Lambda calculus!
04:38:19 <pozic> The first programmable computer is older. 
04:38:46 <JuanDaugherty> oh sure, but it's was more than a decade before fortran
04:39:05 <JuanDaugherty> *it
04:39:35 <JuanDaugherty> (discounting assembler)
04:39:50 <ski> hm, recently i was suprised by a book claiming Prolog was invented by Alain Colmerauer and Philippe Roussel (in 1972). i've always heard it before as being invented by Alain Colmerauer and Robert Kowalski (Kowalski presented "Predicate Logic as Programming Language" at IFIP conference in Stockholm in 1974)
04:39:52 <pozic>  PlankalkÃ¼l
04:39:59 <JuanDaugherty> (which isn't a lang as such any more than the lambda calcul)
04:40:44 <pozic> ski: once you have unification (which is a trivial idea), Prolog is a trival idea too. 
04:41:30 <JuanDaugherty> pozic, your trivial is my ball-buster
04:42:03 <pozic> JuanDaugherty: what other people find trivial, I might find difficult. It just depends on background. 
04:42:12 * JuanDaugherty kneels down before pozic
04:42:24 <ski> pozic : well, higher-order unification is hard :)
04:42:34 <ski> (in general undecidable)
04:42:39 <pozic> ski: semi-decidable hard, yes.
04:42:41 <aristid> ski: does prolog do that? :)
04:43:09 <ski> aristid : no, but lambdaProlog does, to some approximation (i.e. conservative approximation)
04:43:16 <pozic> I don't really see things being undecidable as a problem myself.
04:43:27 <pozic> All what should matter is whether or not the user is right. 
04:43:35 <ski> (Mercury just throws an exception if you try to unify function terms, iirc)
04:44:05 <pozic> E.g. "I know really really sure that this thing is correct", then you can run your undecidable algorithm, and if you are right, the compiler tells you you are.
04:44:34 <pozic> The point of view of most compiler writers is that users do not want potentially non-terminating systems. 
04:44:54 <pozic> (because the users are stupid and must be protected from evil or so goes the argument)
04:46:39 <JuanDaugherty> the opposite of here
04:46:47 <hpc> isn't part of the idea of services and servers that they are non-terminating?
04:47:30 <ski> yeah, i think you're talking about `affirmative' properties with corresponding algorithms
04:48:17 <Tomsik> hpc: "terminating" is "halts after a finite time on a finite input"
04:48:33 <Tomsik> you want the server to halt prefix of your input
04:48:43 <Tomsik> on prefix*
04:49:06 <ski> the intent of `Phi' being `assertative' is that we have a semi-algorithm that when run, if `Phi' is true in an ideal sense (i.e. *knowable*), then it terminates in the affirmative, otherwise it (at least usually) doesn't terminate
04:49:37 <ski> similarly `Phi' is `refutative' if the semi-algorithm terminates whenever `Phi' is false
04:50:19 <pozic> hpc: you can use coinduction to show that the server generates responses in finite time. 
04:50:20 <ski> if `P' is a decidable property of e.g. natural numbers, then `exists n. P n' is assertative, and `forall n. P n' is refutative
04:51:05 <pozic> ski: I have never seen that terminology used.
04:51:32 * ski can't recall atm where he heard these terms
04:51:47 <pozic> ski: (the meaning is perfectly clear)
04:51:57 <JuanDaugherty> it's just one nomenclature for a standard logical duality
04:52:59 <ski> i'm not sure if it's identical to, but it's at least related to hierachies `Pi^n' and `Sigma^n' of formulae
04:54:00 <ski> <http://en.wikipedia.org/wiki/Arithmetic_hierarchy>
04:58:54 <ski> (when thinking of semi-algorithms in a topological way, one can consider open subsets of a space `X' (or equivalently, continuous maps from `X' to `Sierinski', the "half-boolean space") as assertative properties on `X', while closed subsets are refutative properties on `X'
04:58:58 <ski> )
05:02:44 <ScotTJ> Hi, I'm new to haskell. Could someone explain what's wrong with this: http://hpaste.org/44875/mean
05:02:53 <ScotTJ> It compiles, but doesn't work (error included in paste)
05:03:12 <opqdonut> ski: intersting, what space do you mean by sier[p]inski?
05:03:58 <alpounet> ScotTJ, doMyAvg takes a list as its first parameter
05:04:01 <alpounet> and you give it an integer
05:04:13 <alpounet> well
05:04:15 <alpounet> a number
05:05:05 <ScotTJ> Ah, thanks. I thought [x] meant "a list of x" but I should've been just using 'x' i guess
05:06:01 <alpounet> [x] pattern matches a list with one element, that you'll refer to as x
05:06:16 <ski> opqdonut : concretely over `Set', the carrier is `{true,false}' and the set of open subsets are `{{},{true},{true,false}}'
05:06:42 <ScotTJ> alpounet: thanks :) works now
05:06:47 <opqdonut> ski: ah, thanks
05:06:53 <ScotTJ> http://hpaste.org/44878/mean
05:06:53 <ScotTJ> Is there a better way to write it than that?
05:07:29 <ScotTJ> Is there a way to match "a non-empty list" so i don't need to provide the first case? 
05:07:52 <companion_cube> _:_
05:08:05 <ScotTJ> and then how do i refer to that?
05:08:12 <ScotTJ> (_:_)@x ?
05:08:16 <ScotTJ> and then i use 'x' or something?
05:08:18 <sipa> x@(_:_)
05:08:23 <ScotTJ> ah
05:08:23 <sipa> and yes
05:08:28 <ski> opqdonut : <13:42 < JuanDaugherty> it's just one nomenclature for a standard logical duality
05:08:30 <sipa> x will be the whole list then
05:08:32 <ski> argh
05:08:34 <ScotTJ> cool
05:08:44 <ski> opqdonut : <http://en.wikipedia.org/wiki/Sierpi%C5%84ski_space>
05:08:49 <ski> also
05:08:53 <ski> @where topology
05:08:53 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
05:08:53 <lambdabot> dvi|ps)> by Martín Escardó
05:09:46 <ScotTJ> Is there a better "pattern" for doing what I do? Where I have a "interface" function that calls another function that does the work (and has different params?)
05:10:36 <ScotTJ> http://hpaste.org/44880/mean
05:10:36 <ScotTJ> (That's my latest version)
05:10:59 <ski> ScotTJ : next time, don't make a new paste when you mean to make an annotation of the original paste
05:11:27 <ScotTJ> Ah sorry, thought it'd be cleaner that way
05:13:13 <ski> note that if you match with `xs@(_:_)', but don't have a `[]' case, then your program will abort if you pass an empty list (so an explicit error message can in some cases be more informative as to the reason (and meaning) of this run-time error)
05:14:43 <ski> ScotTJ : typically i use that "wrapper-worker" pattern quite often .. though often i call the worker function simply `loop' if i can't (or is too lazy to) think of a better name (sometimes i use an abbreviation of the wrapper name)
05:15:22 <ScotTJ> :) Well good to see i'm not going too far wrong
05:15:27 <ski> @where impossible
05:15:27 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
05:15:35 <ski> opqdonut : ^ those are also a bit related
05:16:40 <ski> ScotTJ : in many typical "accumulator" situations, one can come up with (more or less) sensible, standalone, names though
05:16:43 <ski> e.g.
05:16:55 <ski>   reverse xs = reverseAppend xs []
05:17:11 <ski>   reverseAppend [    ] acc = acc
05:17:28 <ski>   reverseAppend (x:xs) acc = reverseAppend xs (x:acc)
05:17:48 <ski> the intent of `reverseAppend xs ys' is that it should mean `reverse xs ++ ys'
05:18:43 <ScotTJ> ski: makes sense, thanks 
05:19:59 <ski> (in fact, one can derive this efficient definition, by stating an abstract specification/definition `reverseAppend xs ys = reverse xs ++ ys' and then use this to rewrite the naÃ¯ve `reverse' defining equation into the defining equations above)
05:24:59 * ski , to his amusement, has noted that it is possible to say `_*_ : N -> N -> N; m * n = m * n + Z; _*_+_ : N -> N -> N -> N; Z   * q + r = r; S d * q + r = d * q + (q + r)', in Agda2
05:26:27 <zygoloid> how does it distinguish _*_+_ from _+_ . _*_ ?
05:27:01 <ski> i'm not sure, but i would suspect that the "compound" definition takes precedence
05:27:08 <ski> s/suspect/assume/
05:27:32 <ski> (so brackets to use the "split" version)
05:30:03 <ScotTJ> Ok -- I need hulp again. What's this compile error mean: http://hpaste.org/44881/palindrome
05:30:39 <ScotTJ> (Grrr it pasted with the fancy symbols, but it's actual normal ascii)
05:31:12 <Veinor> you want palindrome xs ++ [x]
05:31:20 <Veinor> because ++ takes two lists, not a list and a single element :)
05:31:20 <mauke> ScotTJ: palindrome xs :: [a]; x :: a
05:31:28 <mauke> (++) :: [a] -> [a] -> [a]
05:31:36 <ski> (ideally, one should only be able to define `_*_',`_+_',`_*_+_' (with usual precedence and fixity) if it was known that `forall d q r. d * q + r = (d * q) + r' .. but i don't think Agda2 tries to enforce anything like this)
05:31:39 <mauke> therefore the compiler concludes a = [a]
05:32:07 <ski> > [False,True] ++ False
05:32:08 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
05:32:08 <lambdabot>         against inferred typ...
05:32:24 <ScotTJ> mauke, veinor: Thanks both! compiles fine now
05:32:24 <ski> s/.../e `Bool'/
05:32:36 <mauke> > \x -> [x] ++ x
05:32:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
05:32:44 <ScotTJ> Man, haskell errors could be slightly more inuitive :P
05:32:58 <ScotTJ> intuitive* 
05:33:00 <mauke> they're perfectly intuitive once you develop the right intuitions
05:33:35 <ScotTJ> mauke: Really? I would've thought for it to be readable it should've mentioned that it was the function ++ that was mismatching
05:33:40 <aristid> ScotTJ: just be glad this is not a c++ compiler :P
05:33:40 <ski> yeah .. but it's hard to make them "smart enough" .. with time, one gets a feeling for usual causes of various errors
05:33:59 <mauke> ScotTJ: it didn't know it was ++
05:34:25 <ski> well, i think a great improvement would be if it used type error slicing
05:34:32 <ScotTJ> What else could've it been? 
05:34:32 <mauke> ScotTJ: it just saw conflicting information in your program
05:34:43 <mauke> ScotTJ: the type signature of palindrome could have been wrong
05:34:51 <ski> i.e. reported all and only the possible relevant program positions, which contributed to the type error
05:35:15 <mauke> :t let palindrome (x : xs) = x : (palindrome xs ++ x) in palindrome
05:35:16 <lambdabot>     Occurs check: cannot construct the infinite type: m = [m]
05:35:16 <lambdabot>       Expected type: [m]
05:35:16 <lambdabot>       Inferred type: m
05:35:18 <mauke> aww
05:35:38 <mauke> ok, that's actually caused by (:)
05:36:30 <mauke> :t let palindrome (x : xs) = head x : (palindrome xs ++ x) in palindrome
05:36:31 <lambdabot> forall a. [[a]] -> [a]
05:36:46 <ski> see <http://www2.macs.hw.ac.uk/~rahli/cgi-bin/slicer/> for a type error slicer prototype for SML (there's an online demo to try !)
05:37:28 <ScotTJ> Is there any way to see if my palindrome function is "efficient" ?
05:37:41 <ScotTJ> (Without resorting to turning into assembly)
05:37:42 <dino-> Hm, seems like whenever I run something with Process.runCommand it becomes a zombie.
05:37:47 <ski> @where+ type_error_slicer <http://www2.macs.hw.ac.uk/~rahli/cgi-bin/slicer/> for SML
05:37:47 <lambdabot> Good to know.
05:37:57 <mauke> ScotTJ: dunno, but it looks more complicated than necessary
05:37:58 <ScotTJ> As in, does it use constant space
05:38:09 <ScotTJ> mauke: how would you define palindrome?
05:38:18 <mauke> palindrome xs = xs ++ reverse xs
05:38:40 <ScotTJ> nice :)
05:38:55 <mauke> palindrome = ap (++) reverse
05:39:21 <ScotTJ> ap? 
05:39:31 <ScotTJ> :t ap "not in scope `ap' 
05:39:32 <lambdabot>     lexical error in string/character literal at end of input
05:39:38 <ScotTJ> :t ap
05:39:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:39:57 <mauke> > ap (f :: Expr -> Expr -> Expr) g x
05:39:58 <lambdabot>   f x (g x)
05:40:14 <ScotTJ> Where's it defined? I don't have it in Prelude in ghci 
05:40:22 <mux> Control.Monad
05:40:30 <mauke> @index ap
05:40:30 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
05:40:30 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
05:40:34 <mauke> whoa
05:41:13 <ski> > let makePalindrome = (`loop` id) where loop [    ] k = k []; loop (a:as) k = a : loop as (\as -> k (a:as)) in makePalindrome "abcd"
05:41:13 <lambdabot>   "abcdabcd"
05:41:16 <ski> > let makePalindrome = (`loop` id) where loop [    ] k = k []; loop (a:as) k = loop as (\as -> a : k (a:as)) in makePalindrome "abcd"
05:41:17 <lambdabot>   "dcbaabcd"
05:41:23 <ski> hm
05:41:29 <ski> oh, right
05:41:40 <dino-> hm, maybe I just need to waitForProcess for them, should be super quick anyway
05:42:49 <mauke> processes become zombies when they _exit()
05:43:23 <mauke> zombies disappear when their parent wait()s for them or _exit()s
05:44:58 <ski> > let frobnicate = (`loop` id) where loop [    ] k = k []; loop (a:as) k = loop as (\as -> k (a : k as)) in frobnicate [0,1,2,3]
05:44:59 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
05:46:51 <ski> > (fix $ \loop i -> case i `divMod` 2 of (i,0) -> 1 + loop i; _ -> 0) `map` [1 ..]
05:46:52 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
05:48:10 <Veinor> nice
05:48:55 <ski> now i'd like to define an infinite stream, but using fixpoint iteration over something like the former
05:48:58 <ski> there's also
05:49:30 <dino-> mauke: this is being done by a long long running thing, I wonder how it ever worked.
05:49:34 <dino-> Maybe it always made zombies
05:49:48 <dino-> Or allowed them to continue shuffling around.
05:50:27 <ski> @let (/\/) :: [a] -> [a] -> [a]; [      ] /\/ evens = evens; (a:odds) /\/ evens = a : (evens /\/ odds)
05:50:28 <lambdabot>  Defined.
05:50:38 <ski> > fix $ \ns -> repeat 0 /\/ map (1 +) ns
05:50:39 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
05:52:12 <Veinor> whats (/\/)?
05:52:35 <mauke> (/\/) :: [a] -> [a] -> [a]; [      ] /\/ evens = evens; (a:odds) /\/ evens = a : (evens /\/ odds)
05:52:41 <ski> the interleaving operation
05:52:54 <sipa> :t frobnicate
05:52:55 <lambdabot> Not in scope: `frobnicate'
05:53:26 <ski> @type let frobnicate = (`loop` id) where loop [    ] k = k []; loop (a:as) k = loop as (\as -> k (a : k as)) in frobnicate
05:53:27 <lambdabot> forall a. [a] -> [a]
05:53:34 <Tomsik> what the heck is [   ]?
05:53:37 <ski> @type let loop [    ] k = k []; loop (a:as) k = loop as (\as -> k (a : k as)) in loop
05:53:38 <lambdabot> forall a. [a] -> ([a] -> [a]) -> [a]
05:53:42 <ski> Tomsik : the empty list
05:53:47 <Tomsik> Why the spaces?
05:53:58 <ski> @type let loop [    ] k = k []; loop (a:as) k = loop as (\as -> a : k as)) in loop
05:53:59 <lambdabot> parse error on input `)'
05:54:02 <ski> @type let loop [    ] k = k []; loop (a:as) k = loop as (\as -> a : k as) in loop
05:54:02 <lambdabot> forall t a. [t] -> ([a] -> [t]) -> [t]
05:54:09 <ski> @type let loop [    ] k = k []; loop (a:as) k = loop as (\as -> k (a : as)) in loop
05:54:10 <lambdabot> forall a t. [a] -> ([a] -> t) -> t
05:54:26 <ski> Tomsik : for alignment with `(a:odds)'
05:55:01 <Tomsik> Heh
05:55:19 <ski> (the types of those differing versions of `loop' show to which degree it uses (delimited) continuation effects)
05:55:35 <ski> @type let loop [    ] k = k []; loop (a:as) k = loop as (\as -> a : k as)) in Cont . loop
05:55:35 <lambdabot> parse error on input `)'
05:55:42 <ski> arg
05:55:52 <ski> @type let loop [    ] k = k []; loop (a:as) k = loop as (\as -> k (a : k as)) in Cont . loop
05:55:52 <lambdabot> Not in scope: data constructor `Cont'
05:55:58 <ski> @index Cont
05:55:58 <lambdabot> Control.Monad.Cont, Control.Monad.Cont
05:56:08 <ski> @type Control.Monad.Cont.Cont
05:56:09 <lambdabot>     Not in scope: data constructor `Control.Monad.Cont.Cont'
05:56:11 <ski> bah
05:56:18 <ski> anyway
05:56:21 * Xilon needs to look into the Cont monad
05:56:44 <dino-> :t (>=>)
05:56:44 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:56:46 <Xilon> Still haven't grasped the usefulness of CPS
05:56:53 <ski>   loop :: [a] -> Cont [a] a  -- or `[a] -> ContT a [] a'
05:56:58 <ski>   loop :: [a] -> Cont [t] a  -- or `[a] -> ContT t [] a'
05:57:04 <ski>   loop :: [a] -> Cont t a
05:57:07 <ski> respectively
05:57:14 <Jafet> @quote klein
05:57:14 <lambdabot> heatsink says: If monads are containers, the Cont monad is a klein bottle.
05:57:17 <dino-> Is it correct to think of that as composition for monadic actions?
05:57:25 <ski> Xilon : strange/powerful control structures
05:58:00 <byorgey> dino-: yes.
05:58:12 <ski> dino- : more or less (the correct terminology is "composition of kleisli arrows/morphisms for a monad")
05:58:20 <Xilon> ski: really? seems a lot like iteratees actually
05:58:52 <ski> @type \a b -> Kleisli (runKleisli a >=> runKleisli)
05:58:52 <lambdabot> forall t a (m :: * -> *) a1 b. Kleisli ((->) a1) a (Kleisli m a1 b) -> t -> Kleisli ((->) a1) a (m b)
05:59:11 <ski> hm, no
05:59:21 <ski> @type \a b -> Kleisli (runKleisli a >=> runKleisli b)
05:59:22 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => Kleisli m a b -> Kleisli m b b1 -> Kleisli m a b1
06:00:18 <ski> Xilon : (not knowing iteratees very well, i still think it's safe to say that) iteratees are (/ can be) one *application* of continuations
06:01:10 <ski> Xilon : you can e.g. use continuations to implement cooperative multithreading
06:01:46 <ski> in SML (specifically CML), they implement preemptive multithreading with (first-class) continuations and a timer interrupt
06:02:48 <ski> (or, well, CML is not *exactly* traditional threads .. but they could have done more traditional threads, using the same primitives)
06:08:56 <ski> so, considering a folder item context, wrt a sub-folder, it could only occur as a folder item (being a folder), and then we only need to encode where that folder item occurs within the root folder item
06:09:00 <ski> i.e.
06:09:01 <ski>    type FolderContext a = (Map Name (FolderItem a),Name,FolderItemContext a)
06:09:05 <ski> is to be changed to
06:09:13 <ski>    type FolderContext a = FolderItemContext a
06:09:19 <ski> or, if being more explicit
06:09:43 <ski>    data FolderContext a = FromFolderInItem (FolderItemContext a)
06:10:01 <ski> the definition of `FolderItemContext' now was
06:11:11 <Jesin> hmm
06:11:22 <Jesin> if a module uses LANGUAGE UndecidableInstances
06:11:29 <ski>   data FolderItemContext a = Root
06:11:29 <ski>                            | FromItemInFolder (Map Name (FolderItem a)) Name (FolderContext a)
06:11:39 <Jesin> does that stay local to that module?
06:12:14 <Jesin> or, in what ways does it extend to any modules that import it?
06:12:15 <ski> (the definition i had before was wrong, because i was partly thinking of top-down, rather than bottom-up contexts)
06:13:12 <ski> Jesin : i think that only "attaches" to the instances (obligatory exported) defined in the modulo, but i'm not sure
06:13:31 <Jesin> hmm...
06:13:34 <Jesin> ok
06:13:41 <Jesin> I was just a bit worried about mtl because of that
06:13:43 <Jesin> :p
06:14:00 <ski> (presumably the fine GHC User Manual tells which)
06:14:05 <Jesin> -- All of these instances need UndecidableInstances,
06:14:07 <Jesin> -- because they do not satisfy the coverage condition.
06:14:08 <Jesin> instance (MonadState s m) => MonadState s (ContT r m) where
06:14:10 <Jesin>     get = lift get
06:14:11 <Jesin>     put = lift . put
06:14:13 <Jesin> etc
06:18:53 * ski idly wonders whether these bottom-up contexts/zippers are related to `magic sets' in deductive databases
06:19:00 * hackagebot html2hamlet 0.1.0 - HTML to Hamlet converter  http://hackage.haskell.org/package/html2hamlet-0.1.0 (HideyukiTanaka)
06:19:23 <ski> anyway, we define
06:20:17 <dino-> mauke: thanks for that info about zombies much earlier. Very helpful. I should read the Stevens book more as well.
06:20:24 <ski>   type FolderFocusItem a = (FolderContext a,FolderItem a)
06:20:30 <Cin> How do you pad a number with zeros with printf?
06:20:47 <ski> hm, no
06:20:51 <Cin> The docs in Text.Printf don't seem to indicate.
06:21:02 <dino-> Cin: On the left? I believe %03d or %05.2f
06:21:14 <Cin> > printf "%03d" 23 :: String
06:21:14 <byorgey> > printf "%03d" 2
06:21:14 <lambdabot>   "023"
06:21:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:21:15 <lambdabot>    `Text.Printf.PrintfType ...
06:21:29 <Cin> Hm, I see. I was writing %000d. Thanks.
06:21:33 <dino-> Cin: Sometimes I go to man 3 printf if the Text.Printf docs aren't detailed enough on this
06:21:49 <aristid> hah
06:21:59 <aristid> you could also read the source code :D
06:22:22 * Cin would prefer complete docs
06:22:29 <mauke> Cin: http://hackage.haskell.org/packages/archive/printf-mauke/0.5.0.1/doc/html/Text-Printf-Mauke.html - better?
06:23:05 <Cin> mauke: Yes, actually.
06:23:16 <Cin> Thanks.
06:27:02 * hackagebot aws 0.0.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.0.1 (AristidBreitkreuz)
06:27:36 <Cin> If a package name ever contains % it'll kill hackabot.
06:27:49 <aristid> ^ aws is totally not ready, but i felt the urge to bring something to hackage :D
06:28:19 <Cin> I've never heard of the Amazon Web Services. Sounds interesting.
06:28:43 <Cin> aristid: What's the idea behind it?
06:32:36 <aristid> Cin: well, it's a multitude of services which you can access with HTTP APIs
06:34:09 <Cin> I see.
06:34:16 <Cin> ManateeLazyCat: Hey man, how are you?
06:34:46 <ManateeLazyCat> Cin: I'm fine, thanks! :)
06:34:46 <aristid> Cin: you can launch servers, store files, create databases, stuff like that.
06:34:52 <ManateeLazyCat> Cin: We meet before? Sorry, i can't remember so much people. :)
06:35:04 * hackagebot pgm 0.1.3 - Pure Haskell implementation of PGM image format  http://hackage.haskell.org/package/pgm-0.1.3 (SergeyAstanin)
06:35:15 <aristid> Cin: see http://aws.amazon.com/
06:36:34 <Cin> aristid: Ah, I see. I suppose that would be a nice way to provide Haskell hosting? Give people a domain and web server and then everything else db/files/etc is stored and accessed via amazon?
06:36:42 <ManateeLazyCat> I perhaps ask many times before, can i generate function name as String at compile time? Don't use hacking way. :)
06:36:57 <ManateeLazyCat> I wonder someone can give me perfect answer. :)
06:37:02 <Cin> ManateeLazyCat: Yeah, I know you via Emacs.
06:37:10 <ManateeLazyCat> Cin: Hehe. :)
06:37:19 <Jafet> You want to get the name of a function as a String?
06:37:29 <aristid> Cin: yes.
06:37:58 * ManateeLazyCat pasted "ugly Map" at http://paste2.org/get/1309778
06:37:59 <ManateeLazyCat> Jafet: Yes, i don't want write code like above, easy to break.
06:38:11 <Cin> aristid: Are you planning such a thing?
06:38:24 <quicksilver> ManateeLazyCat: pre-process. Meta-compile.
06:38:30 <aristid> Cin: no, but it would be very cool :)
06:38:53 <ManateeLazyCat> quicksilver: Hmm, haven't better solution?
06:39:06 <ManateeLazyCat> quicksilver: GHC can't help me?
06:39:06 <Cin> aristid: I suppose one could use a mueval-type thing to make it sandboxed, and then give it access to Amazon.
06:39:46 * ManateeLazyCat I'm improve keymap tooltip in new version Manatee, user can hit C-? to get keymap of current module.
06:39:55 <quicksilver> ManateeLazyCat: no. Obviously not. GHC supports alpha-conversion.
06:40:13 <quicksilver> ManateeLazyCat: it is an important property of a language that changing names doesn't affect semantics.
06:40:16 <aristid> Cin: you can also have everybody use their own amazon account
06:40:20 <quicksilver> you need some kind of metaprogramming here.
06:40:28 <Cin> aristid: Indeed.
06:40:30 <quicksilver> template haskell or a pre-processor.
06:40:35 <quicksilver> it doesn't have to be heavyweight.
06:40:39 <Cin> aristid: I have a Linode VPS. I could try this.
06:41:29 <ManateeLazyCat> quicksilver: Any exist lightweight pre-processor tool I can use?
06:41:38 <ManateeLazyCat> quicksilver: I try to avoid TH
06:41:42 <aristid> Cin: if you only need a server, linode is cheaper
06:41:44 <Ptival> can I pass the constructor of a record field to a function?
06:41:46 <ManateeLazyCat> quicksilver: TH make compile time too long.
06:42:14 <dino-> aristid: More distro choices too, I believe, with linode
06:43:02 <Cin> aristid: Cheaper than Amazon? Hm, sucks then. Perhaps it would be easier for me to provide such a sandboxed web dev environment with restricted/vetted provided libraries.
06:43:38 <luite> hmm, I think an amazon micro instance is cheaper than linode
06:43:51 <quicksilver> ManateeLazyCat: I wouldn't have thought using TH in one single file would affect compile times much. Surely it depends what you do with the TH?
06:44:00 <quicksilver> you could also just write some simple haskell to output the file.
06:44:06 <aristid> luite: yes, but less powerful
06:44:13 <Cin> At any rate, doubtless it would be good to have free Haskell web dev hosting that's as easy as those "PHP+MySQL+FOO" solutions.
06:44:31 <Cin> I thought I heard about people already doing this. Anyone heard of anything like that?
06:44:34 <aristid> free?
06:44:40 <aristid> i think paid would be okay too :)
06:44:41 <Cin> Fuhhree!
06:45:04 <aristid> Cin: but i think the coolest thing in this space is heroku (unfortunately ruby)
06:45:43 <luite> aristid: hm, unfortunately you don't get much RAM at linode
06:45:52 <ManateeLazyCat> quicksilver: Ok, thanks for help, let me think a neat solution.
06:45:54 <Cin> I think I have 512.
06:45:56 * Cin checks
06:45:58 <aristid> luite: yes but they don't throttle your CPU if you actually use it
06:46:12 <quicksilver> ManateeLazyCat: there is also, DrIFT, Derive, preprocessor-tools
06:46:21 <quicksilver> ManateeLazyCat: but I haven't used any of these, can't comment on them really.
06:46:29 <luite> 512 is a bit a bit low for running ghc on complex programs
06:46:43 <aristid> luite: but it's OK for running pre-built executables.
06:47:01 <ManateeLazyCat> quicksilver: Thanks, Derive is base on TH for auto-derive, i haven't heard DrIFT before
06:47:06 <ManateeLazyCat> @hackage DrIFT
06:47:06 <lambdabot> http://hackage.haskell.org/package/DrIFT
06:47:46 <luite> yeah that should probably be ok. but I think a good haskell based web hosting service should be able to compile the programs as well
06:47:46 <Cin> A nontrivial Haskell server will be using 100-200MB, I would expect.
06:48:01 <quicksilver> ManateeLazyCat: but you don't need to use auto-derive. You could just run it explicitly in your build sequence.
06:48:16 <quicksilver> (but I still don't believe you when you say TH is slow :P)
06:48:29 <Cin> I dunno, it slows down my builds.
06:49:28 <ManateeLazyCat> quicksilver: When you write TH in root file (such as Types.hs), and many module depend on Types.hs, so it's slow down your compile when you touch Types.hs
06:49:53 <quicksilver> don't do that then.
06:50:04 <quicksilver> use TH in a simple leaf file like in your example there :)
06:50:49 <Ptival> is it possible to achieve what I want to do in the pasted code? http://hpaste.org/44883/
06:51:05 <ManateeLazyCat> quicksilver: I use TH auto generate derive 'makeBinary` code in my *protocol* module (Types.hs), so other modules can follow protocol. 
06:51:16 * quicksilver nods
06:52:02 * ManateeLazyCat pasted "Types.hs" at http://paste2.org/get/1309796
06:52:03 <ManateeLazyCat> quicksilver: Something like above
06:52:05 <aristid> luite: well i think there should be separate build and web servers
06:52:15 <ManateeLazyCat> quicksilver: Many TH code in Types.hs
06:52:25 <aristid> luite: when you upload new source code, it would immediately be built and deployed as soon as possible
06:53:36 * ManateeLazyCat Use ugly Map test logic, then use pre-process technology remove ugly Map.
06:53:39 <ManateeLazyCat> Thanks all! :)
06:54:16 <quicksilver> ManateeLazyCat: well, maybe it's a GHC interaction, maybe it's better to call TH manually and then have a static file for the rest of the build
06:54:21 <quicksilver> mind you I don't understand the issue.
06:58:10 <Cin> http://skillsmatter.com/podcast/scala/talk-by-haskell-expert-simon-peyton-jones
06:58:15 <Cin> Will this podcast be a video?
06:58:16 <freiksenet> I wonder if max. num of fingers in finger tree and node-arity was decided experimentally
06:58:28 <Cin> (Can videos be podcasts?)
06:58:28 <freiksenet> I mean, why it's 4 and 2-3, not, I dunno, 3 and always binary?
07:02:52 <byorgey> freiksenet: no, if I recall correctly there are good theoretical reasons
07:03:02 <kosmikus> freiksenet: a finger tree is a variant of a 2-3 tree; 2-3 trees are a variant of perfect binary trees. perfect binary trees cannot store an arbitrary number of elements.
07:03:15 <freiksenet> okay
07:03:49 <byorgey> freiksenet: I don't remember off the top of my head what they are.  but I think it's explained in the Hinze-Paterson fingertree paper
07:03:57 <kosmikus> the step moving from 2-3 trees to finger trees is the inserting of the "finger", which gives you efficient access to the left and right end
07:04:18 <byorgey> freiksenet: also edwardk has some slides somewhere where he explains it
07:04:23 <kosmikus> the 1-4 generalization is iirc mainly to be able to represent intermediate overflow/underflow states
07:04:24 <freiksenet> ok, thanks
07:04:36 <freiksenet> also, what papers describe eager finger trees?
07:05:03 <quicksilver> ManateeLazyCat: TH really shouldn't be any slower than writing the code by hand (w.r.t compiling modules which depend on it)
07:05:08 <quicksilver> ManateeLazyCat: if it is, something odd is happening.
07:05:43 <ManateeLazyCat> quicksilver: Yes, i love TH sometimes, i don't need write code.
07:07:15 <kmc> TH is so cumbersome though
07:07:53 <ManateeLazyCat> quicksilver: I just want better solution than TH, auto generate code, but much much clean and easy to understand
07:08:09 <ManateeLazyCat> But looks haven't better solution now. :)
07:08:23 <c_wraith> quicksilver: well, TH is slower because it has to invoke the interpreter, which sometimes is slow
07:08:25 <kmc> http://www.liskell.org/
07:08:26 <kmc> http://chrisdone.com/posts/2010-11-25-lisk-lisp-haskell.html
07:08:33 <quicksilver> c_wraith: not when compiling dependent modules.
07:08:56 <quicksilver> c_wraith: ManateeLazyCat's allegation was that if Foo.hs uses TH then all the other modules which *depend on* Foo get slower.
07:08:59 <quicksilver> that shouldn't be.
07:09:04 <kmc> if you regularize syntax then your metaprogramming becomes a lot easier
07:09:07 <c_wraith> Oh.  yeah, that shouldn't be.
07:09:33 <c_wraith> Unless the TH results in such a huge interface to the module that just loading it is a pain
07:11:44 <Cin> kmc: What does regularize mean?
07:11:50 <Cin> kmc: Oh, I didn't see the links. N/m.
07:12:20 <roconnor> Cale: In the Caleskell report, can we reintroduce the Eval class for seq?
07:13:48 <djahandarie> Lambdabot HasCale.
07:15:25 <Ptival> http://hpaste.org/paste/44883/reconstruct_after_deconstruct < anyone? :(
07:16:07 <quicksilver> Ptival: record selectors are not first class.
07:16:19 <quicksilver> this is my main criticism of haskell's "records".
07:16:28 <Ptival> ouch
07:16:32 <quicksilver> the solutions are to use something like fclabels or data.accessor instead.
07:16:44 <Cin> Hehe, does *everyone* encounter this problem more or less immediately?
07:17:47 <quicksilver> everyone who tries to use records in a complex way, I expect.
07:18:28 <Tomsik> I liked OCaml's records
07:18:48 <Tomsik> and when I came to haskell that was the first thing that threw me off
07:21:33 <xplat> 22:09 < kmc> istr at Galois (<$>) and (<*>) are pronounced "money" and "splat"  respectively
07:21:41 <kmc> Hugs has some kind of record system as an extension
07:21:49 <xplat> i call them 'gold' and 'gem'
07:21:59 * Cin calls them fmap and ap :p
07:22:08 <aristid> kmc: TRex or something like that? i think i read about it in the original haskelldb paper
07:22:09 <cathper> Any good argument why lhs2tex convers <- to \leftarrow rather than \in?
07:22:13 <confound> xplat: ha
07:22:17 <aristid> Cin: crazy you.
07:22:20 <cathper> s/convers/converts/
07:22:27 <Cin> aristid: I know wild right?
07:22:54 <kmc> this is one of the reasons why i wish we wouldn't advise people to ignore implementations other than GHC
07:22:56 <Cin> Hug's TRex is cool. If that was in GHC I'd be very happy.
07:23:29 <aristid> kmc: well sadly GHC is the only realistic choice either way.
07:23:39 <kmc> you may not want to use Hugs or JHC for production code, but it's worth taking a look at how they do things
07:23:41 <quicksilver> xplat: angband/moria player?
07:23:45 <Cin> You can just construct arbitrary records on the fly a la JavaScript's object literals.
07:23:57 <kmc> maybe i should stop whining and implement ACIO for GHC
07:24:05 <Cin> Which is a maintainability nightmare for JS, but great in Haskell.
07:25:33 <kmc> think i'll wait until they gitulate the GHC repo ;P
07:25:44 <Cin> kmc: ACIO?
07:25:51 <kmc> "affine central IO"
07:26:01 <kmc> i.e. IO actions at top level of a file
07:27:07 <Cin> Ah, ok, though it might be a record system.
07:28:03 <kmc> so you can say Â«x <- newIORef 0Â» instead of Â«{-# NOINLINE x #-} x = unsafePerformIO $ newIORef 0Â»
07:28:37 <aristid> that would be a good extension.
07:28:44 <aristid> at least for IORef
07:28:44 <kmc> yep, JHC has it
07:28:45 <quicksilver> it's quite controversial
07:28:49 <aristid> not sure if real I/O is good there
07:28:52 <quicksilver> much heat and light has been expended.
07:28:55 <aristid> but IORef all the way
07:29:11 <quicksilver> it gives a more concrete 'lifetime' or even 'instance' to a module.
07:29:12 <kmc> ideally you'd avoid needing global IORefs, but empirically a lot of code does use them, and ACIO would be valuable harm reduction
07:29:25 <kmc> i think it's even more valuable for MVar
07:29:29 <quicksilver> which has implications about things like manage code frameworks
07:29:51 <kmc> if i'm FFI importing a thread-unsafe C library I usually want a hidden global MVar to synchronize access
07:29:55 <quicksilver> imagine a haskell app server which runs many independent clients
07:30:10 <cathper> Well, for do-notation, but I don't have any of that so I think \in will just do fine.
07:30:12 <quicksilver> if several of them use that module do they get one IORef or many?
07:30:29 <kmc> quicksilver, *nod* these are valid questions, but the story today is at least as bad
07:30:54 <quicksilver> the answer to that varies from module to module I guess
07:31:14 <quicksilver> more pragmatically, how will GHCi reload such modules?
07:31:30 <quicksilver> (I suppose in a way the answer to that gives us a practical framework for answering the other)
07:31:49 <quicksilver> GHCi is rather like a haskell server.
07:31:53 <kmc> i don't think ACIO has any story about instantiating modules like that, but it does at least have a solution for the problem of how top-level IO code is ordered between modules
07:32:11 <quicksilver> what is that solution?
07:32:25 <kmc> top-level actions are ACIO actions, not IO actions
07:32:35 <quicksilver> so ordering isn't supposed to matter?
07:32:42 <kmc> the ACIO type only allows things for which order shouldn't matter
07:32:59 <quicksilver> except for unsafeACIOtoIO, I imagine? :)
07:33:03 <quicksilver> erm
07:33:08 <quicksilver> /ACIOtoIO/IOtoACIO/
07:33:29 <kmc> there's a safe version of that
07:33:48 <quicksilver> safeIOtoACIO?
07:33:54 <kmc> yeah (forgot the name)
07:34:00 <quicksilver> how can it be safe?
07:34:09 <quicksilver> it lets you run order-dependent actions in an undefined order?
07:34:14 <zygoloid> accio IORef!
07:34:16 <ManateeLazyCat> :t floor . fromIntegral
07:34:16 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
07:34:40 <kmc> it gives you an ACIO action that when executed (at top level) gives you an IO action which when executed (explicitly) does the stuff iff it hasn't been done before, and yields the old or new result
07:34:54 <kosmikus> cathper: I don't quite see why <- should be converted to \in. It makes sense for list comprehensions, perhaps, but not for other monads.
07:35:10 <quicksilver> kmc: possiblySafeDeferIO. Interesting.
07:35:10 <kosmikus> cathper: but as always, if you don't like it, change it.
07:35:15 <kmc> it's always safe
07:35:25 <kmc> it has well-defined semantics
07:35:33 <quicksilver> sure but not a sensible one
07:35:39 <kmc> in fact i think you can build this using ACIO-declared IORefs
07:35:55 <quicksilver> executed on first demand is not very different from executed in undefined order.
07:36:02 <quicksilver> which is exactly the problem we started with.
07:36:14 <quicksilver> it's rather like unsafeInterleaveIO
07:36:22 <kmc> no
07:36:28 <kmc> unsafeInterleaveIO is "execute on first evaluation"
07:36:33 <kmc> this is "execute on first execution"
07:36:46 <quicksilver> oh, I see.
07:36:53 <quicksilver> IO a -> ACIO (IO a)
07:36:57 <kmc> yeah
07:36:57 <quicksilver> not IO a -> ACIO a
07:36:58 <jmcarthur> given that IO is not tightly specified anyway, i'd say this sounds safe
07:37:05 <quicksilver> I didn't read you carefully enough.
07:37:07 <jmcarthur> or at least as safe as anything else in IO
07:37:09 <kmc> and i'm pretty sure you can build that out of IORefs
07:37:46 <jmcarthur> yeah it's basically a side-effecting thunk that you can only force in IO
07:39:42 <quicksilver> bit like a Future, actually.
07:40:32 <zygoloid> sounds like the /only/ primitive ACIO needs is 'deferIO' (or 'newACIORef')
07:41:51 <zygoloid> ('deferIO' is exactly as powerful as ACIO, since if your IO is affine and central then you can't tell whether it's deferred, and it can be built from 'full' ACIO)
07:42:01 <ManateeLazyCat> Haha, i success, press C-/ or C-? will popup *opacity* window to show keymap. :)
07:42:27 <ManateeLazyCat> You can starting to hacking Manatee from next version, don't need wiki page. :)
07:43:09 <quicksilver> zygoloid: although slightly more fiddly to use :)
07:43:28 <quicksilver> zygoloid: since you have to unwrap before use each time.
07:43:43 <kmc> and operationally you might not want to defer it
07:43:43 <quicksilver> although clearly you can write joinACIO :: ACIO (IO a) -> IO a
07:43:47 <zygoloid> not if your interface is simply allowing any IO action at the top level
07:44:01 <zygoloid> kmc: that's a good point
07:44:14 <quicksilver> anyhow, kudos to JHC for JFDI'ing.
07:44:28 <quicksilver> that beats arguing about it on haskell-cafe as we have been doing for 10 years.
07:44:43 <zygoloid> syntax? x <- someACIOAction?
07:50:56 <kmc> yep, at top level
07:51:28 <kmc> heh, you could implement this on top of the existing hack with a TH decl splice
07:52:03 <zygoloid> kmc: the only way i know to make that work is to have the TH code generate a file which defines 'main' ;(
07:53:05 <mathijs> Hi all, I'm a bit confused about StaticArrow in the arrows package. I just read http://blog.downstairspeople.org/2010/06/14/a-brutal-introduction-to-arrows where they stick some static info about IO actions to the type. How can this be "ported" to StaticArrow? 
07:53:37 <cathper> kosmikus: Right. I'm really just asking if there's something that I completely overlooks. I'm a Haskell n00b.
07:54:15 <mathijs> it seems staticarrow only wraps another arrow (like Kleisli) with an applicative. it's not clear to me how applicative helps to stick static info to the computation
07:54:20 <cathper> kosmikus: In other words, I don't have any monads using <-, just list comprehensions, so converting <- to \in should be fine.
07:58:59 <kmc> cathper, i'm not totally happy with that because i think it confuses "x <- xs" with "x `elem` xs"
07:59:14 <kmc> cathper, also GHC will soon (re-)support monad comprehensions, confusing the matter even further
07:59:29 <revenantphx> kmc: what is that?
07:59:39 <revenantphx> generalization of list comp to all monads?
07:59:42 <revenantphx> or something?
08:00:46 <kmc> yep revenantphx
08:00:50 <kmc> it was in Haskell 1.4
08:00:56 <kmc> but was removed in order to not confuse beginners
08:01:06 <kmc> (cause, you know, Haskell is so accessible otherwise)
08:01:10 <revenantphx> kmc: Haha I know
08:01:13 <Cin> :]
08:01:14 <revenantphx> how would that work with likeâ¦ Either?
08:01:21 <revenantphx> Could I see an example :|
08:01:28 <kmc> it's a pretty straightforward translation to "do"
08:01:41 <revenantphx> ah right, but it uses guard right?
08:01:44 <kmc> [ e | x <- xs, y <- ys, p ]  â  do { x <- xs; y <- ys; guard p; return e }
08:01:46 <monochrom> [ x+1 | x <- Right 4 ]
08:01:47 <kmc> yes
08:02:01 <revenantphx> monochrom: what does that convert too?
08:02:02 <kmc> presumably if you use a predicate your type ends up requiring MonadPlus
08:02:18 <monochrom> [ x+1 | x <- Right 4 ] = do { x <- Right 4; return (x+1) }
08:02:28 <revenantphx> > [ x+1 | x <- Right 4 ]
08:02:29 <lambdabot>   Couldn't match expected type `[t]'
08:02:29 <lambdabot>         against inferred type `Data.Eith...
08:02:31 <revenantphx> aw
08:02:36 <monochrom> not supported yet
08:02:43 <revenantphx> which version supports it?
08:02:48 <revenantphx> or, via extension?
08:02:50 <monochrom> a future version
08:02:52 <kmc> some patches
08:02:55 <kmc> maybe it's in HEAD by now
08:02:58 <revenantphx> not even 7.0.2 yet D:
08:03:17 <kmc> maybe it's not clear what's in HEAD while they're in the middle of DarcsdÃ¤mmerung
08:03:18 * ManateeLazyCat I have give up to persuade my colleague to use Haskell, Haskell for them, like Alien language.
08:03:26 <revenantphx> kmc: lol wut
08:03:37 <kmc> revenantphx, the GHC developers are switching from darcs to git
08:03:41 <revenantphx> D:
08:03:48 <revenantphx> Didn't expect that.
08:03:49 <revenantphx> why?
08:03:56 <kmc> because darcs doesn't scale to their needs
08:04:01 <revenantphx> Ah, too bad.
08:04:06 <revenantphx> I use git anyways >_>.
08:04:17 <monochrom> haha DarcsdÃ¤mmerung
08:04:18 <kmc> "git blame" on the linux-2.6 repo takes a fraction of a second,  "darcs annotate" on the GHC repo spins for a minute or two and then dies with a stack overflow
08:04:26 <revenantphx> hm thats an issue
08:04:32 <revenantphx> monochrom: great name is it
08:04:34 <revenantphx> isn't it*
08:04:46 <ManateeLazyCat> kmc: Why darcs so slow?
08:04:52 <monochrom> I'm glad I watched Wagner's Ring cycle
08:05:00 <ManateeLazyCat> kmc: I don't want switch, but many people use git.
08:05:05 <kmc> also git is vastly more popular and will make development more accessible
08:05:22 <revenantphx> monochrom: Just remember, if you ever discover yourself to have an identical twin sister
08:05:25 <revenantphx> you must conceive a child.
08:05:27 <revenantphx> that is all.
08:05:30 <monochrom> @vixen ä½ æä¸­æå
08:05:30 <lambdabot> I have a goldfish named Ernie
08:05:34 <kmc> ManateeLazyCat, i don't know; I've only used darcs a little bit (and it failed by being too slow)
08:05:57 <monochrom> today lambdabot doesn't know chinese. but I swear she did a few days ago.
08:06:03 <ManateeLazyCat> Ernie ?
08:06:19 <cathper> kmc: I don't see the problem with confusing "x <- xs" and "x `elem` xs"; this is exactly what we do in mathematics. The other consern is more intricate I think.
08:06:25 <ManateeLazyCat> monochrom: What's the @vixen?
08:06:31 <kmc> cathper, mathematical notation has a lot of bugs
08:06:44 <revenantphx> @vixen How's Ernie doing.
08:06:44 <lambdabot> help help!
08:07:40 <monochrom>  @vixen is how you chat with lambdabot in natural languages
08:08:30 <cathper> kmc: { variable | condition about variable } notation makes perfectly sense since "x `elem` xs" is a condition; "x <- xs" is something more; it specifices an ordering which is not necessary if we think of lists as sets.
08:08:46 <ManateeLazyCat> @vixen ä½ å¥½
08:08:46 <lambdabot> Crazy little wanker!
08:08:55 <monochrom> haha
08:09:05 <cathper> :-D
08:09:12 <ManateeLazyCat> Who build @vixen ?
08:09:30 <ManateeLazyCat> @vixen ä½ è¿ä¸ªç¬¨è
08:09:30 <lambdabot> you sir are no gentleman
08:09:44 <monochrom> now she begins to know chinese
08:09:44 <ManateeLazyCat> Oh no
08:10:04 <ManateeLazyCat> @vixen ä¸æä¸è¦è£æ
08:10:04 <lambdabot> girls masturbate too you know... probably more than guys. we can do it anywhere discretely
08:10:05 <monochrom> do not think of lists as sets
08:10:27 <revenantphx> How is vixen built? I mean, where is it getting its source from?
08:11:08 <ManateeLazyCat> rude vixen
08:12:00 <Jafet> Oh, she has the hots for chinese. We never knew.
08:12:31 <ManateeLazyCat> @vixen rude idiot
08:12:31 <lambdabot> amuse me please! (and don't ask
08:12:37 <cathper> monochrom: Since I should use Data.Set then?
08:12:47 <ManateeLazyCat> Not funny.
08:13:08 <monochrom> depends
08:14:05 <kmc> cathper, "x <- xs" is a binding occurrence of x; "x `elem` xs" is not
08:14:32 * hackagebot CSPM-Frontend 0.6.8.0 - A CSP-M parser compatible with FDR-2.91  http://hackage.haskell.org/package/CSPM-Frontend-0.6.8.0 (MarcFontaine)
08:15:32 * hackagebot CSPM-ToProlog 0.3.1.0 - some modules specific for the ProB tool  http://hackage.haskell.org/package/CSPM-ToProlog-0.3.1.0 (MarcFontaine)
08:15:33 <cathper> monochrom: I use map a lot (so I win log(n)) and other operations I've written myself to be as fast (or faster since I know my data) as Data.Set.
08:15:34 * hackagebot CSPM-CoreLanguage 0.2.0.3 - Definition of a FDR-compatible CSP core-language.  http://hackage.haskell.org/package/CSPM-CoreLanguage-0.2.0.3 (MarcFontaine)
08:16:21 <cathper> kmc: Semantically, yes, but if I write to mathematicians that has never seen Haskell code, <- is more mysterious than \in.
08:16:35 <kmc> well ok
08:16:48 <monochrom> mathematicians understand >>= fine
08:16:55 <kmc> if you're writing maths that's sort of based on Haskell code, go ahead and do whatever
08:17:24 <kmc> but i think it would be wrong for lhs2TeX to produce â in contexts where the reader is expected to understand Haskell
08:17:32 * hackagebot CSPM-FiringRules 0.3.0.3 - Firing rules semantic of CSPM  http://hackage.haskell.org/package/CSPM-FiringRules-0.3.0.3 (MarcFontaine)
08:17:34 * hackagebot CSPM-Interpreter 0.4.4.1 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.4.4.1 (MarcFontaine)
08:17:36 * hackagebot CSPM-cspm 0.4.4.0 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.4.4.0 (MarcFontaine)
08:17:44 <cathper> I'm writing some .lhs files that will be part of the appendix to my thesis.
08:17:52 <cathper> kmc: I agree.
08:19:18 <roelvandijk> kmc: I use stuff like "n â [1,8]" in normal code
08:20:45 <roelvandijk> kmc: I'm also a big fan of the UnicodeSyntax extension
08:21:35 * hackagebot Bitly 0.0.6 - A library to access bit.ly URL shortener.  http://hackage.haskell.org/package/Bitly-0.0.6 (SergeyAstanin)
08:21:37 * hackagebot bitly-cli 0.1 - A command line tool to access bit.ly URL shortener.  http://hackage.haskell.org/package/bitly-cli-0.1 (SergeyAstanin)
08:21:46 <monochrom> do { n â getLine; xs â readIO n; i â mapM putStrLn (replicate xs ()); return (length i) }
08:22:42 <roelvandijk> monochrom: That looks a bit weird. I prefer "foo â bar".
08:23:17 <djahandarie> monochrom, is n :: IO or n :: String? ;)
08:23:27 <djahandarie> Are monads sets?!?!
08:23:41 <monochrom> I'm just extending your "do { n â [1,8] ..." to all do's.
08:24:06 <roelvandijk> Ah ok
08:24:12 <djahandarie> @quote monochrom IO.out
08:24:12 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
08:24:17 <djahandarie> Damn
08:24:22 <monochrom> it has been lost.
08:24:42 <kmc> roelvandijk, but you use it for `elem`, right?
08:24:49 <roelvandijk> kmc: yes
08:25:02 <monochrom> oh oops
08:25:10 <kmc> yeah, that's fine :)
08:25:15 <kmc> djahandarie, only small monads
08:25:19 <kmc> ;P
08:25:37 <djahandarie> I have pretty big nads here so that might not work out for me.
08:27:32 <Tomsik> I wonder when somebody creates a theory-categoric concept of gonads.
08:27:34 <kmc> there's some attempts to use category theory as foundations rather than set theory
08:27:59 <kmc> but usually you think of categories as classes, and a small category is a set
08:28:27 <kmc> (with a set of hom's also)
08:29:05 <Apocalisp> @hoogle (a -> b) -> f a -> m (f b)
08:29:05 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
08:29:05 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:29:05 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
08:29:49 <Apocalisp> @hoogle (a -> b) -> f s a -> m s (f s a)
08:29:49 <lambdabot> No results found
08:30:34 <Apocalisp> @hoogle (a -> b) -> STRef s a -> ST s (STRef s b)
08:30:34 <lambdabot> No results found
08:30:37 <Apocalisp> boo
08:30:42 * hackagebot CSPM-cspm 0.4.4.1 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.4.4.1 (MarcFontaine)
08:32:53 <gwern> aaahhh... my ridiculously big local collection of haskell repos comes in handy again - I can see how many packages are using the new Cabal test syntax
08:34:12 <aristid> :t sequence
08:34:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:36:32 <dcoutts_> gwern: probably not many yet
08:36:53 <siracusa> :t  return .: fmap
08:36:54 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
08:36:54 <djahandarie> I feel like it hasn't been advertised well enough
08:37:00 <siracusa> Apocalisp: ^
08:37:08 <djahandarie> Haha, Apocalisp isn't interested!
08:38:56 <gwern> dcoutts_: nope, although my first run was too small because apparently 'test-suite' is case-insensitive
08:39:19 <dcoutts_> gwern: yeah, all the sections/fields are case-insensitive
08:43:11 <gwern> dcoutts_: this is what I have so far: './angle/angle.cabal, ./cabal/Cabal.cabal, ./concurrent-extra/concurrent-extra.cabal, ./hashable/hashable.cabal, ./rrt/rrt.cabal, ./safeint/safeint.cabal, ./spatialIndex/spatialIndex.cabal, ./unordered-containers/unordered-containers.cabal, ./wai-app-static/wai-app-static.cabal'
08:43:25 <gwern> 8 packages, excluding cabal
08:44:40 <djahandarie> dons just needs to post on his blog about it or something
08:45:21 <dcoutts_> hmm, maybe I should do that
08:45:26 <dcoutts_> unless gwern wants to
08:45:39 <djahandarie> gwern might be a little more critical about things than you though ;)
08:45:40 <dcoutts_> but I should get the user guide bits sorted out first
08:45:45 <dcoutts_> heh
08:46:09 <gwern> my search command if anyone is curious is 'find . -name "*.cabal" -exec fgrep --files-with-matches --ignore-case 'test-suite ' {} \; | fgrep -v share | fgrep -v 'abal/tests/' | sort'
08:47:18 <dcoutts_> gwern: and another check would be looking at the .cabal files for packages on hackage
08:47:44 <gwern> (yeah, but I haven't written a script to get the repos of everything with repo metadata on hackage)
09:08:43 <Cin> Ah, forgot.
09:08:53 <Cin> http://skillsmatter.com/podcast/scala/talk-by-haskell-expert-simon-peyton-jones â anyone know if this will be a video podcast or audio podcast with slides?
09:11:57 <Itkovian> Just hearing SPJ state this is a friendly channel :-)
09:12:25 <Cin> Itkovian: You're at the skillsmatter thingie?
09:12:37 <Itkovian> No, waqtching the video on vimeo
09:12:45 <Itkovian> http://skillsmatter.com/podcast/scala/talk-by-haskell-expert-simon-peyton-jones
09:13:06 <Cin> Oh. Ignore my question. It's been updated. That was fast. Before it said "coming soon".
09:13:09 <Itkovian> reminds me on the talk he gave when he was stranded in the Us when the Eyawhateveritsnamewas burst in Iceland
09:23:42 <deech> Hi all, can anyone recommend "Pearls Of Functional Design"?
09:26:21 <joe6> what is the best tutorial/guide to understand monad-transformers or stacked monads?
09:27:00 <joe6> is there a haskell source code viewer that can show the source as a type-class graph or something similar?
09:27:21 <joe6> any thoughts, please?
09:28:20 <deech> joe6: No, but that would be awesome.
09:28:51 <deech> For monad-transformers, the best tutorial is "Real World Haskell"
09:30:10 <kmc> joe6, All About Monads was helpful to me, though it can be confusing or even wrong in some places
09:31:19 <joe6> kmc, ok, thanks.
09:31:49 <joe6> deech, yes, i am getting confused with more than one level of stacked monads.
09:35:16 <sm> joe6: like SourceGraph ?
09:37:10 * hackagebot value-supply 0.6 - A library for generating values without having to thread state.  http://hackage.haskell.org/package/value-supply-0.6 (IavorDiatchki)
09:43:20 <warrenharris> I uploaded a package to hackage, but it's missing a native library it needs. Is there any way to get this installed on the hackage build machine?
09:44:22 <Ke> sounds quite unlikely
09:48:26 <joe6> sm, thanks, will check it out.
09:54:30 <joe6> sm, i think that is what i was looking for.. Thanks..
09:54:35 <sm> np
09:58:11 <joe6> kmc, the "All about monads" tutorial is awesome.
09:58:56 <spirit> how would i go about parsing a string? i.e. with '_' as delimiter i'd like to retrieve 'foo' and/or 'bar' from foo_bar
10:00:22 <kmc> spirit, look at the 'split' package on hackage
10:00:34 <siracusa> warrenharris: Have you specified extra-libraries or pkgconfig-depends?
10:02:22 <warrenharris> siracusa: I have the lib listed as an extra-library, but don't have pkgconfig-depends
10:03:57 <siracusa> warrenharris: Ok. Not sure if Hackage is clever enough to install theses automatically or if it needs manual intervention. You'd better ask on haskell-cafe for this.
10:05:16 <warrenharris> siracusa: will do. thx
10:07:57 <joe6> is there a mechanism to update the ghc frequently? or, will it mess up my cabal installed packages if I do that?
10:12:42 * hackagebot Decimal 0.2.0 - Decimal numbers with variable precision  http://hackage.haskell.org/package/Decimal-0.2.0 (PaulJohnson)
10:15:00 <spirit> how do i add 'split' to the build-depends in my cabal file?
10:15:23 <igorgue> hi, Im getting a ld: library not found for -lcrt1.10.5.o
10:15:30 <kmc> spirit, examine any cabal file with more than one build depend
10:15:38 <kmc> igorgue, with GHC?
10:15:41 <igorgue> when compiling with The Glorious Glasgow Haskell Compilation System, version 7.0.2, on osx
10:15:46 <igorgue> kmc: yes
10:15:53 <kmc> are you passing -lcrt1.10.5.o yourself?
10:15:58 <igorgue> no
10:16:09 <spirit> where would i find such a cabal file? is split just like a module?
10:16:17 <kmc> split is a package
10:16:22 <kmc> http://hackage.haskell.org/package/split
10:16:25 <kmc> packages are collections of modules
10:16:33 <spirit> pkgconfig-depends?
10:17:13 <kmc> here's one of my cabal files: http://hackage.haskell.org/packages/archive/rowrecord/0.1/rowrecord.cabal
10:17:17 <kmc> see build-depends at the bottom
10:18:44 <spirit> cheers!
10:18:53 <igorgue> kmc: do you think it's because I updated to xcode4?
10:19:20 <kmc> i'm not sure igorgue
10:19:40 <djahandarie> There is some issue with xcode4 and the latest HP/GHC
10:19:43 <djahandarie> I don't know if this is it
10:27:57 <igorgue> kmc, djahandarie: I found the ticket: http://hackage.haskell.org/trac/ghc/ticket/5011
10:28:16 <djahandarie> Yeah. It's fixed alreayd, I just don't think the new HP has been released yet
10:28:27 <djahandarie> I think they are planning on releasing it ASAP though.
10:32:15 <igorgue> djahandarie: that's cool meanwhile, ghc 6 :/
10:32:29 <djahandarie> :(
10:32:51 <igorgue> djahandarie: where is that libcrt? maybe I can just symlink it
10:34:19 <djahandarie> igorgue, there is a solution of some sort here: http://www.reddit.com/r/haskell/comments/g5ouj/a_warning_to_mac_using_haskellers_xcode_4_seems/
10:34:22 <djahandarie> In the comments.
10:34:34 <jfischoff> does anyone know if there is a webserver that would work on halvm?
10:34:57 <jfischoff> I am assuming it would be possible to write one, but maybe I guess...
10:35:00 <igorgue> djahandarie: cool, thanks!
10:35:09 <djahandarie> :)
10:36:01 <beastaugh> jfischoff: warp and snap-server are both Haskell web servers, maybe you could test them
10:36:21 <djahandarie> jfischoff, anything that interacts with the FS won't work
10:36:35 <djahandarie> So, I imagine that rules out any server that does logging in any usual fashion
10:36:41 <jfischoff> yeah that was why I assumed the current ones might not work
10:36:53 <jfischoff> but there might be a way to fork one to make it work
10:36:56 <djahandarie> Yeah
10:37:05 <jfischoff> I think would be pretty neat
10:37:16 <djahandarie> It definitely would, I got excited reading your sentence ;)
10:37:19 <beastaugh> djahandarie: that's unfortunate
10:37:36 <beastaugh> I didn't realise it was so limited still
10:37:45 <beastaugh> but yes, a neat idea
10:37:49 <jfischoff> I'm excited about a haskell like heroku running on the halvm somehow
10:38:09 <jfischoff> you could push snap apps, and it would use some forked version
10:38:23 <beastaugh> that would be extremely cool
10:38:43 <djahandarie> beastaugh, a lot is planned for it, though I'm not sure how much the galois folks work on it
10:39:04 <djahandarie> A completely compatible base is one of the bigger things I think.
10:39:05 <jfischoff> beastaugh: one day ...
10:39:36 <jfischoff> djahandarie: right then you get more of hackage etc.
10:39:43 <beastaugh> djahandarie: looks like it, http://halvm.org/wiki/ticket/8
10:40:13 <jfischoff> I wonder how hard it would be to port snap, a week, a month more?
10:40:26 <djahandarie> Probably a good amount of time.
10:40:32 <djahandarie> Faster than starting from scratch though! ;)
10:40:38 <jfischoff> :)
10:40:48 <kmc> does HaLVM have a TCP/IP stack?
10:40:56 <kmc> what about network interface drivers?
10:41:05 <jfischoff> kmc: it has some networking support
10:41:11 <jfischoff> supposedly
10:41:15 <jfischoff> I have not used it
10:41:21 <dons> kmc: it does now, yes. but not released.
10:41:31 <dons> we have a prototype web server running on halvm as of this week
10:41:44 <jfischoff> sweet
10:41:44 <djahandarie> Oh wow, heh
10:41:46 <dons> based on http://hackage.haskell.org/package/tcp 
10:42:02 <jfischoff> haskell heroku here we come!
10:42:08 <dons> well, halvm on ec2
10:42:12 <dons> at least that's a goal
10:42:16 <jfischoff> what works
10:42:17 <kmc> oh very cool
10:42:22 <djahandarie> Have you considered making the development of halvm more transparent?
10:42:25 <kmc> i didn't know ec2 gives you enough flexibility
10:42:28 <jfischoff> dons: what is the speed like?
10:42:31 <kmc> will they let you run arbitrary xen dom0's?
10:42:31 <djahandarie> I imagine quite a few people would be interested in contributing
10:42:43 <dons> djahandarie: well, its in an open git repo and people are sending patches
10:42:47 <dons> it certainly could be even more public
10:42:59 <jfischoff> dons: the web server is public?
10:43:10 <dons> not yet. its in a branch
10:43:15 <dons> http://halvm.org/wiki/wiki/DownloadAndInstall 
10:43:31 <aristid> dons: how about putting the git repository on github?
10:43:39 <djahandarie> Ah, I see the git repo now.
10:44:03 <djahandarie> http://code.galois.com/cgi-bin/gitweb?p=HaLVM.git;a=summary For those who are interested
10:44:33 <jfischoff> very cool
10:45:24 <dons> if people are interested in helping, please email adam wick, and that will help push more of the development into the public. once the tcp stack is merged in, it should be a free for all to e.g. port snap
10:45:25 <aristid> djahandarie: lol the initial commit is huge
10:52:44 <ion> âObject-oriented programming is eliminated entirely from the introductory curriculum [at CMU], because it is both anti-modular and anti-parallel by its very nature, and hence unsuitable for a modern CS curriculum.â http://existentialtype.wordpress.com/2011/03/15/teaching-fp-to-freshmen/
10:53:02 <monochrom> eh, interesting
10:55:02 <monochrom> actually my first impression of oop was modular and parallel. the book I read made it sound like each object is yet another thread, threads send messages to each other.
10:55:40 <jystic> monochrom: sounds like erlang
10:56:21 <mzero> I hate blogs that don't say who the author is
10:56:23 <mzero> who wrote that?
10:56:29 <sm> are folks using haskelldb in production ?
10:56:43 <monochrom> I guess over time people moved towards tightly coupling the objects to the point 1000 objects are 1 monolith again.
10:58:43 <gwern> @quote weekends
10:58:43 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
10:58:46 <gwern> @quote weekend
10:58:46 <lambdabot> ndm says: I was browsing through the Yhc standard libraries, as one does on the weekend, and was drawn to Yhc's sort function.
10:59:02 <monochrom> It seems to me people are anti-modular, and no language, paradigm, or education will stop it. Dijkstra and Hoare etc have been crying "separate the concerns" for decades (and whoever still lives, such as Hoare, still cries). The very fact that it is cried tells you that the cry has no effect; people anti-separate concerns.
10:59:10 <gwern> one of my favorite quotes. it's the 'as one does on the weekend' clause that really gets me
11:01:33 <Saizan> concurrency in OOP doesn't get thaught as "one thread per object" more like "multiple threads are going to be in this object at once, good luck!"
11:02:26 <sm> another haskelldb question: given withDb â· (Database â IO â) â IO â, can I reshape that so I can just type individual sql statements at the ghci prompt ?
11:02:34 * monochrom contemplates suggesting to mzero this McLuhan-inspired sentence: "the blog is not written by the author. the blog is the author." :)
11:04:06 <sm> ie I'd like my ghci prompt to be as if inside the withDb block
11:05:32 <joe6> is there a "darcs send" equivalent with git? I have a patch that I want to submit to the HTTP module folks.
11:05:53 <ray> monochrom: that always seems like how it's described
11:05:53 <joe6> and git complains "ERROR: Permission to haskell/HTTP.git denied to joe6."
11:05:54 <lispy> joe6: yes
11:06:03 <ray> if i just read oop advocacy i'd think java was erlang
11:06:20 <ion> See git-send-email(1)
11:06:21 <lispy> joe6: but I don't know what the command is actually called.  git patch?
11:06:27 <yip> joe6: if you're going to be patching HTTP, do you mind also bumping the version number in it's default user agent string? thanks :)
11:06:40 <joe6> yip, to what?
11:06:50 <companion_cube> ray, you mean "oop as message-passing" ?
11:06:57 <ray> yes, that sort of thing
11:07:23 <ion> Uh. I mean, git-format-patch(1).
11:07:44 <yip> joe6: to the current version of the library, right now it is stuck at 4000.0.9
11:07:46 <yip> joe6: http://hackage.haskell.org/packages/archive/HTTP/4000.1.1/doc/html/src/Network-HTTP-Base.html#libUA
11:08:03 <Saizan> there's Paths_HTTP.version for that sort of thing
11:10:13 <joe6> yip, will do..
11:10:55 <yip> joe6: cool thanks :) ideally this would be linked somehow to the cabal vesion so that it would be updated automatically
11:15:41 <joe6> yip, the file says that it will disappear soon. Do you still want me to patch it?
11:16:00 <joe6> yip, maybe they left it lower, for that reason?
11:16:20 <yip> joe6: maybe... do what you think is best :)
11:16:43 <joe6> yip, will update it, anyway, if it keeps you happy..
11:17:19 <yip> joe6: ok, it's just kind of confusing that right now the library reports the wrong version in the user agent
11:18:52 <Palmik> Hmm, is not there a more elegant way to do this http://codepad.org/6FYePt2k ?
11:25:59 <joe6> ion, git format-patch worked well, but I cannot seem to find git send-email?
11:26:04 <joe6> or git-send-email?
11:26:37 <joe6> needed the git-core package.
11:26:45 <joe6> ion, forget it, I am good..
11:27:44 <ion> You can just send the file generated by git format-patch using any means. git-send-email is just one of the methods one can use.
11:33:18 * hackagebot uacpid 1.0.3.0 - Userspace Advanced Configuration and Power Interface  event daemon  http://hackage.haskell.org/package/uacpid-1.0.3.0 (DinoMorelli)
11:37:46 <gwern> > 38.56 / 100
11:37:46 <lambdabot>   0.3856
11:39:59 <gwern> > 42.68 / 144
11:39:59 <lambdabot>   0.29638888888888887
11:55:55 <joe6> ion, yes, that is what I ended up doing. though git-send-email says that "OK", I was not receiving any emails.. Thanks.
11:56:26 <frerich_> Hmm, as part of my first real Haskell project (a text-mode tic tac toe game), I just hit a little problem; at runtime, I eventually get the error 'Maybe.fromJust: Nothing'. Now, the thing is that quite a few fromJust calls in my code might be responsible for this. Is it possible to get some more detailed diagnostics (maybe including a line number) than this?
11:56:38 <frerich_> My first idea was that maybe a core file (I'm on Mac OS X) is generated, but apparently not so.
11:57:42 <monochrom> Control.Exception.assert has line numbers.
11:58:16 <monochrom> assert (isJust x) (fromJust x)
11:58:35 <mercury^> Hmm, why are you using so many fromJusts?
11:59:26 <frerich_> mercury^: In my current code, the tic tac toe fields are of type 'Maybe Player' (and Player is 'Circle | Cross'). In some places, I need to compare a 'Player' with 'Maybe Player' - and that's where I use fromJust.
11:59:39 <Eduard_Munteanu> frerich_: you shouldn't be using fromJust that often.
11:59:40 <frerich_> (Nothing would be an empty field)
11:59:47 <monochrom> fromJust is fine after you have completely debugged and proved correct.
12:00:02 <Eduard_Munteanu> frerich_: you could use 'maybe' instead
12:00:04 <Eduard_Munteanu> :t maybe
12:00:05 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:00:39 <Eduard_Munteanu> > maybe (error "fubar") (+1) $ Just 5
12:00:40 <lambdabot>   6
12:00:44 <Eduard_Munteanu> > maybe (error "fubar") (+1) $ Nothing
12:00:45 <lambdabot>   *Exception: fubar
12:01:17 <mercury^> frerich_: A better solution would be to have a datatype Empty | Circle | Cross.
12:02:01 <dino-> monochrom: I don't think I really agree with that so much. Use Maybe specifically because you've designed something constructive to be done with the Nothing.
12:02:19 <dino-> Or you've just basically made yourself null pointer hell.
12:02:20 <Phantom_Hoover> Is there a type for ordered lists without duplication?
12:02:27 <frerich_> mercury^: Hm interesting idea
12:02:37 <Eduard_Munteanu> Phantom_Hoover: sets?
12:02:47 <Eduard_Munteanu> @hoogle Set
12:02:47 <lambdabot> module Data.Set
12:02:47 <lambdabot> Data.Set data Set a
12:02:47 <lambdabot> Network.Browser setAllowBasicAuth :: Bool -> BrowserAction t ()
12:02:51 <Phantom_Hoover> Eduard_Munteanu, unordered, no?
12:03:02 <Eduard_Munteanu> @hoogle asclist
12:03:02 <lambdabot> Data.IntMap fromAscList :: [(Key, a)] -> IntMap a
12:03:02 <lambdabot> Data.IntSet fromAscList :: [Int] -> IntSet
12:03:02 <lambdabot> Data.Map fromAscList :: Eq k => [(k, a)] -> Map k a
12:03:10 <monochrom> if I wrote all the libraries of the world, sure, I would skip Maybe's to begin with.
12:03:19 <mercury^> Phantom_Hoover: They can be converted to ordered lists.
12:03:45 <Phantom_Hoover> Wait, surely someone's already implemented a graph type?
12:03:46 <Eduard_Munteanu> @hoogle fromList
12:03:46 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
12:03:46 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
12:03:46 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
12:04:03 <mercury^> (which is `free' given their internal structure)
12:04:08 <Eduard_Munteanu> IIRC there was a way to use an arbitrary Ord instance, if that's suitable for you.
12:04:54 <Eduard_Munteanu> i.e. if there's a natural ordering for that type; it's probably not ok if you want to actually change that ordering
12:05:12 <monochrom> there are situations â most involving other people's paranoidly written libraries full of pompous Maybe's â when I know it has to be a Just, when I know there is absolutely nothing I could do about Nothing, when fromJust is just.
12:07:40 <Phantom_Hoover> @hoogle Graph
12:07:41 <lambdabot> module Data.Graph
12:07:41 <lambdabot> module Data.Graph.Inductive.Graph
12:07:41 <lambdabot> Data.Graph type Graph = Table [Vertex]
12:08:07 <frerich_> I just noticed that when comparing e.g. a 'cell :: Maybe Player' with some given 'player :: Player', I shouldn't do 'player == fromJust cell' but 'Just player == cell' to avoid this problem.
12:08:11 <frerich_> Not beautiful, but oh well.
12:08:14 <monochrom> the only different between "Maybe (X | O)" and "Empty | X | O" is just a few more bottoms.
12:08:53 <monochrom> it still begs the question "what to do with Empty? or do you prove that it doesn't happen under this condition, therefore ignore it?"
12:09:43 <Eduard_Munteanu> frerich_: not if that pattern-match is partial
12:09:49 <Eduard_Munteanu> That'd be just like fromJust.
12:10:02 <monochrom> you can combine pattern matching with comparison
12:10:03 <Twey> It's not a pattern match
12:10:09 <Twey> That's the constructor
12:10:43 <monochrom> f (Just x) | player==x = "case 1"
12:10:57 <monochrom> f _ = "case 2"
12:11:10 <ceii> frerich_: as for your question "how can I tell where the exception comes from?", you can get basic stack traces on exceptions by compiling your program with -prof -auto-all, and running it with +RTS -xc
12:11:26 <Twey> f (Just ((== player) -> True)) = "case 1"
12:11:27 <Twey> ;)
12:11:30 <ceii> If you need more details, see the section from the GHC manual about the GHCi debugger
12:11:42 <frerich_> ceii: Ah! That's useful to know, I guess I will want to do that by default for the next few projects :)
12:11:47 <Eduard_Munteanu> ghci also has something that breaks on exceptions
12:11:50 <dino-> I think there must be a bigger design issue going on here, though.
12:11:55 <Eduard_Munteanu> -fbreak-on-exception IIRC
12:14:20 <orbitz> Is there a forum or subreddit or any place one can ask general "how should one model this?" that is fairly language agnostic? 
12:14:25 <monochrom> I hope my example does not lead to call sites like: if f y == "case 1" then ... else if f y == "case 2" then ...
12:14:42 <orbitz> like tips on where to make the separation of logic and yadda
12:14:48 <Eduard_Munteanu> orbitz: mm, StackOverflow?
12:14:58 <orbitz> Hrm that's not bad idea
12:15:07 <monochrom> you could ask on the main programming reddit and have fun
12:15:12 <Eduard_Munteanu> orbitz: just be sure to tag your question properly
12:15:32 <monochrom> fun on a fine friday afternoon starting a flame war
12:15:58 <Eduard_Munteanu> Or on #haskell-blah :P
12:16:05 <monochrom> not your fault; readers in friday afternoons have no life
12:16:17 <orbitz> I'll try #haskell-blah first perhaps
12:18:54 <monochrom> oh, but I know the answer to all design and modelling questions. Jackson structured design.
12:28:27 <apoliiton> hi. I'm building an app with wxhaskell. Is there a way to link wxwidgets statically to the app so I dont have to bundle the wxmsw28u_gcc.dll ?
12:31:44 <Eduard_Munteanu> apoliiton: you'd need a static wxWidgets lib (perhaps compile it yourself) but I'm not sure how that works on Windows.
12:33:13 <Eduard_Munteanu> Last time I tried, it was really easy even to cross-compile wxWidgets under mingw (on Linux in my case), but I don't remember about static stuff.
12:35:42 <apoliiton> Eduard_Munteanu: I tried static compilation, however when I was building the app. with ghc it reported some wx libraries could not be found. I made sure they were built correctly. Is there a path issue?
12:39:15 <Eduard_Munteanu> apoliiton: you might want to try -optc-static and supplying the complete path to the wxWidgets .lib
12:39:20 <siracusa> Eduard_Munteanu: When was that last time? I tried to compile the latest version about half a year ago, it was a huge mess :-S
12:39:59 <Eduard_Munteanu> siracusa: hm, like 4 years ago or so :). But I used a cross-gcc toolchain on Gentoo.
12:40:10 <Eduard_Munteanu> (targetted for MinGW)
12:40:26 <siracusa> Oh, so not Windows.
12:41:02 <Eduard_Munteanu> IIRC it was merely a matter of doing ./configure --host=i386-pc-mingw32   or something like that
12:41:21 <Eduard_Munteanu> siracusa: but the resulting executable ran on Windows.
12:42:14 <Eduard_Munteanu> IMO it was way easier than achieving the same thing for other libs, like GTK, that was a mess I couldn't sort out :)
12:42:41 <edwardk> preflex: xseen ddarius
12:42:42 <preflex>  ddarius was last seen on freenode/#haskell 20 hours, 39 minutes and 30 seconds ago, saying: Stop compiling things.
12:43:00 <apoliiton> I plan to do this on windows though. I'll try the hint -optc-static with the path to wxWidgets\libs
12:43:40 <Eduard_Munteanu> Yeah, also -optl-l/path/to/static/lib might be worth trying.
12:43:52 <Eduard_Munteanu> YMMV
12:44:33 <apoliiton> And setting WXCFG=gcc_lib\mswu
12:45:58 <siracusa> Eduard_Munteanu: Strange, from my experience installing gtk2hs was way easier :-)
12:46:24 <Eduard_Munteanu> Well yeah, if you're not trying to cross-compile that stuff :)
12:53:21 <djahandarie> edwardk, oh dear
12:54:22 <copumpkin> djahandarie: problem? http://bit.ly/8dhBaI
12:54:26 <edwardk> djahandarie: don't worry. you'll pick up agda in no time
12:55:26 <djahandarie> copumpkin, no officer. :(
12:55:35 <edwardk> What is bad is how much of that email is actually not a joke ;)
12:55:56 <djahandarie> Yeah, especially how gentle copumpkin's proofs are
12:56:11 <edwardk> actually those _aren't_ the longest proofs in his lib
12:56:26 <djahandarie> The highest number of universes though :(
12:56:37 <djahandarie> Unless he recently found something else...
12:57:28 <djahandarie> I'm still not used to reading this setoid reasoning
12:57:49 <djahandarie> Well, I can read it... it just is incredibly unclear to me what is actually operationally happening
12:59:00 <edwardk> it helps a lot with encoding harder category theory concepts though
12:59:50 <edwardk> like dddarius i think ti'd be more fun to just describe kan extensions, then define everything else in terms of them, but it wouldn't have the easy pedagogy of pumpkin's approach
13:01:40 <apoliiton> Eduard_Munteanu: Built the new library: wxwidgets\lib\gcc_lib\mswu with "shared=0 monolithic=0 unicode=1 build=release". Should I reinstall the wx packages to use the new library?
13:02:37 <Eduard_Munteanu> apoliiton: what do you mean by reinstall? 'make install'? Maybe.
13:02:52 <Eduard_Munteanu> Or you could simply try to supply paths into that dir
13:03:11 <apoliiton> Eduard_Munteanu: No. The cabal wx and wxcore packages
13:06:01 <Eduard_Munteanu> apoliiton: hm I'm not sure, it's worth trying compiling those against the static libs you now have as well.
13:07:12 <frerich_> Hmm, what's a good way to model an integer type with a limited range? I'd like a type which behaves like 'Int' except that it just takes the values '[0..2]'. That way, I could get rid of some functions checking that the 'Int' I'm using is >= 0 && < 3
13:07:23 * frerich_ tries to express more using types
13:08:00 <mreh> frerich_: hide the constructor from the user and use functions to make them
13:08:01 <frerich_> Unfortunately '0', '1', '2' are not valid identifiers :-}
13:08:20 <Eduard_Munteanu> frerich_: for small stuff, data YourInt = One | Two | Three deriving Enum   might do
13:08:20 <mreh> throw and error if they try to make three
13:08:32 <mreh> that's even better
13:09:53 <frerich_> Eduard_Munteanu: Hm yes, that's my current approach. I was just wondering whether there's maybe something like 'subranges' in Pascal (where you can do something like 'type Index = 1 .. 3').
13:09:55 <Eduard_Munteanu> And a Integral instance might be useful too.
13:11:24 <Eduard_Munteanu> Not that I know of.
13:11:55 <Eduard_Munteanu> Though some sugar for that might be nice.
13:13:47 <imc> hello. I'm trying to get into Arrows. Is there something like a multiplex and demultiplex arrows (i.e. some generalized (&&&)) defined somewhere ?
13:16:21 <Cale> imc: What is the type of the operation you're looking for?
13:18:27 <imc> i have a function returning an arrow. i want a new arrow that, given a list, returns an arrow that process in parallel all the arrows built by that function 
13:19:09 <imc> i'm doing something like : \list -> proc inp -> do out <- map f list -< def ...
13:19:33 <imc> (working with "FG", functional/arrow thingy over gtk2hs)
13:20:36 <imc> but the plain map just creates n arrows
13:21:03 <Cale> so... f :: t -> A b c, and you have a list xs :: [t]
13:21:22 <Cale> and you want to do something with map f xs :: [A b c] to run all the arrows?
13:24:45 <imc> Cale: that's it
13:24:50 <Eduard_Munteanu> @hoogle mapA
13:24:50 <lambdabot> Data.IntMap mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
13:24:50 <lambdabot> Data.Map mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
13:24:50 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
13:24:53 <Eduard_Munteanu> Grr.
13:24:55 <imc> and, more important, a way to collect the result
13:25:21 <Eduard_Munteanu> I suppose mapM/mapM_ works for Kleisli arrows.
13:25:25 <jmcarthur> frerich_: if you make your type an instance of Num then you can use the integer literals for it
13:25:25 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
13:25:27 <joe6> monochrom, is it possible to upgrade ghc without messing up the cabal installation?
13:25:44 <imc> but what about the syntax?
13:25:48 <imc> i mean 
13:25:59 <imc> out <- mapM_ f xs
13:26:00 <imc> ?
13:26:39 <imc> w
13:26:40 <Cale> That doesn't typecheck
13:26:41 <monochrom> yes. in fact new ghc ignores libs built against old ghc anyway.
13:26:45 <Cale> Arrows aren't monads :)
13:26:46 <imc> well, mapM
13:27:03 <Eduard_Munteanu> Yeah, not all Arrows can be Monads.
13:27:44 <imc> so i'm stuck
13:28:09 <apoliiton> Eduard_Munteanu: Building wx and wxcore them against the static gcc_lib\mswu gives an error. It cant find the libs even providing the path to the libs. I suppose I have to build them with the dll version.
13:29:20 <imc> oh.. actually i can peek at how the "Container" is built (as it indeed take a list of widget and build a new one...)
13:32:38 <Cale> sequenceArr :: Arrow a => [a b c] -> a b [c]
13:32:38 <Cale> sequenceArr [] = proc u -> do returnA -< []
13:32:38 <Cale> sequenceArr (x:xs) = proc u -> do v <- x -< u
13:32:38 <Cale>                                   vs <- sequenceArr xs -< u
13:32:38 <Cale>                                   returnA -< (v:vs)
13:32:51 <Cale> You could use something like that
13:33:14 <Cale> I'm not sure why this sort of thing is not in Control.Arrow, but it probably has to do with almost nobody using Arrows.
13:35:25 <Cale> sequenceArr = foldr (\x xs -> proc u -> do v <- x -< u; vs <- xs -< u; returnA -< (v:vs))
13:35:25 <Cale>                     (proc u -> do returnA -< [])
13:35:26 <apoliiton> does anyone have a sugestion for a haskell forum?
13:36:25 <Cale> sequenceArr = foldr (\x xs -> proc u -> (v,vs) <- x &&& xs -< u; returnA -< (v:vs))
13:36:25 <Cale>                     (proc u -> do returnA -< [])
13:36:31 <Cale> apoliiton: a haskell forum?
13:36:34 <edwardk> cale: can't you just exploit the WrapArrow applicative and traverse with that?
13:36:38 <Cale> apoliiton: The mailing lists are pretty active
13:36:51 <Cale> edwardk: Possibly :)
13:37:31 <edwardk> :t unwrapArrow . traverse WrapArrow
13:37:32 <lambdabot> Not in scope: `traverse'
13:37:56 <Cale> sequenceArr = foldr (\x xs -> arr (uncurry (:)) <<< x &&& xs)
13:37:56 <Cale>                     (arr (const []))
13:38:39 <edwardk> @type Control.Applicative.unwrapArrow . Data.Traversable.traverse Control.Applicative.WrapArrow
13:38:40 <lambdabot> forall (a :: * -> * -> *) b b1 (t :: * -> *). (Data.Traversable.Traversable t, Arrow a) => t (a b b1) -> a b (t b1)
13:39:07 <edwardk> blechy qualified imports
13:39:25 <edwardk> but unwrapArrow . traverse WrapArrow subsumes what you gave ;)
13:39:52 <Eduard_Munteanu> apoliiton: well doing the static linking won't save space anyway, you might as well bundle the DLL.
13:40:24 <edwardk> you can probably use djahandarie's ala stuff and get something like ala WrapArrow traverse
13:40:33 <Eduard_Munteanu> Apart from that, I'm not sure exactly how you could fix it.
13:41:07 <Cale> imc: Does my solution make sense? Edward's suggestion to use WrapArrow is also good, but you should know how to write it the way that I did too :)
13:41:19 <xplat> @. unpl pl let deep = (. flip) . (.) in (deep $ id, deep . deep $ id, deep . deep . deep $ id, deep . deep . deep . deep $ id)
13:41:19 <lambdabot> ((\ a b c -> a c b), (\ am bf e f -> am f bf e), (\ aq bi bl l m -> aq m bi bl l), (\ aw bo br bu w x -> aw x bo br bu w))
13:41:59 <apoliiton> Eduard_Munteanu: I see. I was hoping to simplify distribution. Thanks for the tips tough. I'll try to build the packages with dynamic linking and the app with static.
13:42:34 <xplat> @. unpl pl let dÉÉp = (flip .) . (.) in (dÉÉp $ id, dÉÉp . dÉÉp $ id, dÉÉp . dÉÉp . dÉÉp $ id, dÉÉp . dÉÉp . dÉÉp . dÉÉp $ id)
13:42:34 <lambdabot> ((line 1, column 7) : unexpected "\153" expecting letter or digit, pattern or "=")
13:42:47 <Taslem> Is it possible to implement graphics without having to download graphics libraries?
13:43:14 <Eduard_Munteanu> Taslem: what sort of graphics?
13:43:46 <Taslem> Basically the ability to draw pixels on the screen, in some form of window, relatively quickly.
13:44:16 <xplat> @. unpl pl let daap = (flip .) . (.) in (daap $ id, daap . daap $ id, daap . daap . daap $ id, daap . daap . daap . daap $ id)
13:44:17 <lambdabot> ((\ a b c -> a c b), (\ am e f i -> am f i e), (\ aq l m p s -> aq m p s l), (\ aw w x aa ad ag -> aw x aa ad ag w))
13:44:54 <pastorn> xplat: are you making an instance of MonadInception here?
13:45:13 <xplat> pastorn: MonadInception?
13:45:15 <Taslem> Any suggestions? I'm looking at lists of libraries, and most of them don't make sense, or go to broken links.
13:45:29 <pastorn> xplat: http://donsbot.wordpress.com/2010/12/05/control-monad-inception/
13:45:37 <pastorn> xplat: WE NEED TO GO DEEPER!
13:46:07 <pastorn> Taslem: are you talking clickabel buttons or 3D stuff?
13:46:27 <Eduard_Munteanu> Taslem: there's a variety of libs you could use, Gtk2Hs with cairo/OpenGL stuff, Chart etc.
13:46:32 <Eduard_Munteanu> Those do work.
13:46:47 <Eduard_Munteanu> (chart is better for plotting)
13:46:56 <Taslem> Like graphs and things?
13:47:04 <Cale> Taslem: Maybe something like gloss would do?
13:47:08 <Cale> http://hackage.haskell.org/package/gloss
13:47:17 <xplat> pastorn: i have no idea!
13:48:06 <pastorn> xplat: all i saw was consecutive applications of "dÉÉp" so i instantly thought of inception :)
13:48:07 <Cale> Taslem: You'll need to download some kind of library, as GHC itself doesn't come with any particular graphics libraries.
13:48:15 <Taslem> Ah, well, okay.
13:48:25 <pastorn> Taslem: or are you using haskell platform?
13:48:31 <Taslem> GHC, I think.
13:48:41 <Cale> But that's easy enough if you've installed cabal-install :)
13:48:52 <xplat> what i'm sure i am doing, though, is creating a pair of polymorphic combinators that when iterated on id generate sequences of n-ary left and right rotation combinators
13:48:55 <pastorn> Cale: still needs the -dev packages...
13:48:58 <Cale> "cabal install gloss" will install the package
13:49:08 <Cale> Well, sure.
13:49:32 <Taslem> I do not have Cabal.
13:49:43 <pastorn> Taslem: what OS are you running?
13:49:50 <Taslem> Windows.
13:49:51 <xplat> i wish i could eliminate the need for nesting like (deep (deep (deep (deep id))))
13:49:54 <Taslem> (Vista)
13:50:13 <Cale> http://www.haskell.org/cabal/release/cabal-install-0.8.2/cabal.exe
13:50:17 <Taslem> xplat? Can't you do:  deep $ deep $ deep $ deep $ x
13:50:19 <pastorn> xplat: runN :: Int -> (a -> a) -> a -> a
13:50:42 <imc> Cale: it makes sense, thank you very much!
13:50:43 <pastorn> runN n f x = if n==0 then x else runN f (f x)
13:50:51 <xplat> but then it would have to somehow know the id is special
13:50:58 <imc> (was: arrow sequencing question)
13:51:07 <pastorn> xplat: you could fold with z
13:51:10 <Taslem> Why? Why do you need to nest it?
13:51:10 <pastorn> *z=id
13:51:17 <xplat> pastorn: the input and output types of deep are compatible, but they are not the same
13:51:18 <hpc> pastorn: i assume there's an (n-1) in there somewhere
13:51:25 <hpc> otherwise it won't typecheck
13:51:32 <pastorn> hpc: NEVAR
13:51:59 <Taslem> So, now what? Has Cabal just installed itself?
13:52:00 <xplat> so i cannot use runN or iterate
13:52:02 <Taslem> Or did it crash?
13:52:21 <pastorn> Taslem: if you're on windows you should use the haskell platform
13:52:25 <sm> I'm getting a Convertible error converting SqlLocalDate to ZonedTime from haskelldb or hdbc.. perhaps because my postgres doesn't know it's time zone ? Any tips for fixing this ?
13:52:41 <pastorn> Taslem: makes your life so much easier :)
13:52:48 <xplat> i could make a custom nested list type and make my own iterate with polymorphic recursion, i guess
13:52:52 <Cale> I think that's the commandline program you use... I don't use Windows though.
13:53:02 <Taslem> Oh, wait a moment.
13:53:05 <Taslem> I think I DO have it.
13:53:13 <pastorn> Taslem: HP?
13:53:24 <Taslem> I think. it looks outdated though.
13:53:28 <Cale> You almost certainly have Cabal the library. The cabal.exe I linked you to is cabal-install, the program.
13:54:00 <pastorn> Taslem: which version?
13:54:04 <Cale> If you get that, you should be able to run it like  cabal update  and then  cabal install gloss  to try to install that library.
13:54:10 <xplat> but then i would have the same problem when i went to extract an element, i would have to write myHead (myTail . myTail . myTail . myTail $ rots)
13:54:26 <Taslem> 2010.2.0.0
13:54:51 <Cale> That sounds like maybe a Haskell Platform version...
13:55:01 <Cale> HP comes with cabal-install
13:55:09 <Cale> So you may have it indeed
13:55:17 <Taslem> I see.
13:55:22 <xplat> and rotls and rotrs would have different types anyway, and probably need their own extractors ...
13:55:26 <Taslem> So... How exactly do I USE Cabal?
13:56:03 <mzero> in a command shell.  try     cabal --version
13:56:12 <pastorn> Taslem: have you found "cabal.exe"?
13:56:29 <pastorn> mzero: we're on winlolz here
13:56:30 <Taslem> I have no idea where to look.
13:56:40 <xplat> i guess i could write a generic polymorphic-recursive iteration thingy with type families
13:56:42 <freedrull> anyone used the midi library before?
13:56:44 <pastorn> Taslem: search where the HP got installed
13:56:46 <mzero> which does have a command shell, no?
13:56:48 <Taslem> Found it.
13:56:50 <xplat> and TypeNats
13:56:59 <pastorn> Taslem: open up cmd and go there
13:57:04 <pastorn> then from there
13:57:19 <pastorn> HP\> cabal.exe update
13:57:26 <freedrull> doesnt seem to have been updated in a year
13:57:31 * pastorn guesses...
13:57:59 <Taslem> Agh, I don't use Command line enough to know about this stuff.
13:58:16 <pastorn> freedrull: do you have any idea on how to make sounds? i want to try out timing stuff, and graphics isn't as clear as sounds (i think)
13:58:48 <pastorn> Taslem: > cd C:\Program<press TAB here>...\Haskell>
13:59:03 <freedrull> pastorn: i'm just trying to parse information from midi files, not make sounds, but have you checked out haskore?
13:59:08 <xplat> then i could write something like nest (undefined :: Church 12) deep id
13:59:09 <pastorn> *Haskell<TAB>\directory_to_cabal\
13:59:17 <Taslem> Right. From what it looks like, while I HAVE HP, I've never used it.
13:59:40 <pastorn> freedrull: does it have a simple API for just playing a random cowbell and snare drum or piano?
13:59:50 <Taslem> How memeory/space efficient are lambda expressions?
13:59:52 <pastorn> i just want different sounds, easily playable
14:00:02 <freedrull> pastorn: i've yet to run into a haskell API i'd call "simple" :[
14:00:07 <pastorn> Taslem: as much as any function
14:00:10 <freedrull> *haskell library
14:00:19 <Taslem> Right, well, I mean, how much is it?
14:00:21 <pastorn> hahaha
14:00:53 <xplat> are TypeNats in 7.0.2?
14:01:12 <Taslem> That is to say, how slow would the use of a lambda expression nested with 10^5 others be to use?
14:01:13 <pastorn> Taslem: are we talking on-disk or when running?
14:01:17 <Taslem> Running.
14:01:25 <freedrull> pastorn: if you just want to play sounds, maybe the easiest option would be to use a binding to an existing sound lib, like SDL or portaudio
14:01:27 <tieTYT> hm, I was kinda hoping hpaste would print something in this channel, what's the point of knowing the channel?
14:01:41 <tieTYT> anyway, i'm looking at this: http://hpaste.org/44888/tree
14:01:42 <pastorn> freedrull: ah, SDL, the finest :)
14:01:46 <freedrull> pastorn: http://www.haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound#Wrappers
14:01:48 <pastorn> i totally forgot it has sounds
14:02:02 <freedrull> yeah i've used SDL for sounds in C...
14:02:24 <tieTYT> and I'm wondering, are the (Tree a)'s in the Node construtor referring to the Tree type constructor or the tree value constructor?
14:02:32 <pastorn> Taslem: well, that totally depends on the complexity... you know that (\x -> (\y -> e)) === (\x y -> e), right?
14:02:43 <Taslem> Yeah, I do.
14:03:09 <Taslem> Lets assume that it takes 10^5 arguments, and all of them are added up.
14:03:30 <pastorn> Taslem: then you're doing it wrong...
14:03:30 <Taslem> WOuld it be any slower than taking a list that size and performing a tail-recursive "sum"?
14:03:40 <freedrull> bleh...there's nothing here http://hackage.haskell.org/packages/archive/SDL/0.6.2/doc/html/Graphics-UI-SDL-Audio.html
14:03:51 <Taslem> @Pastorn I'm using this as an example, I'm not stupid enough to try to do that.
14:04:00 <lambdabot> No match for "I'm".
14:04:00 <lambdabot> No match for "using".
14:04:00 <lambdabot> No match for "this".
14:04:00 <lambdabot> No match for "as".
14:04:01 <lambdabot> No match for "an".
14:04:02 <lambdabot> [17 @more lines]
14:04:08 <Taslem> Gr...
14:04:14 <kmc> irc â  twitter
14:04:14 <Taslem> Hush, lambdabot.
14:04:18 <hpc> @help pastorn
14:04:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:04:25 <hpc> @help @pastorn
14:04:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:04:26 <xplat> so Nest (undefined :: Church 9999) (+) ?
14:04:36 <xplat> *nest
14:04:39 <hpc> @help Pastorn
14:04:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:04:42 <hpc> @help @Pastorn
14:04:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:04:44 <hpc> :(
14:04:48 <pastorn> Taslem: perhaps, since you'd have to iterate over the structure, but on the other hand lazy evaluation might cause (10^5 - 1) arguments to just be ignored
14:05:02 <tieTYT> can someone help me with my newb question?  Scroll about a page up
14:05:02 <pastorn> ==> no stack allocation
14:05:13 <Taslem> Yeah, I figured. So it shouldn't be any slower than the sum of the list of them?
14:05:32 <freedrull> oh here we go http://hackage.haskell.org/package/SDL-mixer
14:05:45 <byorgey> tieTYT: they are referring to the Tree type constructor.
14:05:51 <pastorn> Taslem: if you're actually conserned about performance here - use DPH
14:06:06 <byorgey> tieTYT: after each constructor is a list of the *types* of the constructor's arguments
14:06:22 <Taslem> And DPH is what, exactly?
14:06:27 <tieTYT> byorgey: I'm confused because earlier in the book, I saw something like this: data BookInfo = BookInfo ...
14:06:37 <tieTYT> is that a recursive type too?
14:06:55 <freedrull> i really think i could write my own midi parser faster than getting the midi library to do what i want...
14:06:58 <byorgey> tieTYT: yes, that's common but confusing at first.  values and types have different namespaces, so you can use the same name for a type constructor and a value constructor
14:07:10 <pastorn> tieTYT: just as you would write "data RGB = RGB Int Int Int", all words but the first are types
14:07:12 <byorgey> tieTYT: no, it is not recursive.  It just means that the type BookInfo has a constructor which is also called BookInfo
14:07:26 <pastorn> tieTYT: meaning that in this case each node holds two subtrees
14:07:38 <pastorn> *sub-(Tree a):s
14:07:45 <tieTYT> i think I'm understanding.  In the case of Tree, the constructor is called Node, the rest are the arguments
14:07:50 <byorgey> tieTYT: exactly.
14:07:56 <tieTYT> basically regurgitating what byorgey originally said
14:08:09 <pastorn> tieTYT: an example tree: Node 0 Empty (Node 1 Empty Empty)
14:08:26 <tieTYT> k
14:08:27 <tieTYT> thanks
14:08:47 <pastorn> tieTYT: Empty :: Tree Int; (Node 1 Empty Empty) :: Tree Int
14:08:57 <freedrull> oh no why didnt i find this before http://hackage.haskell.org/packages/archive/HCodecs/0.0.3/doc/html/Codec-Midi.html
14:09:01 <pastorn> *the-whole-thing* :: Tree Int
14:09:05 <djahandarie> edwardk, ala is in \bot now too :)
14:09:17 <pastorn> freedrull: is it awesome?
14:09:22 <djahandarie> @typ ala WrapArrow Data.Traversable.traverse
14:09:23 <lambdabot> forall (a :: * -> * -> *) b c (t :: * -> *). (Arrow a, Data.Traversable.Traversable t) => t (a b c) -> a b (t c)
14:09:36 <freedrull> this library looks waaay simpler than the other midi lib
14:10:14 <tieTYT> so if I did something like: data BookInfo = BookInfo BookInfo, it knows by the position that I'm saying that the type BookInfo has a constructor called BookInfo that recusively takes another BookInfo as an argument?
14:10:28 <tieTYT> not sure if this is legal, but, I think that's the gist
14:10:45 <djahandarie> This is illegal. I'm the online Haskell police.
14:11:01 <djahandarie> Just kidding though, that's fine :)
14:11:08 <tieTYT> ok
14:11:10 <djahandarie> Though not very useful
14:11:10 <edwardk> djahandarie: =)
14:11:51 <edwardk> woot, i guessed the right implementation
14:12:02 <Taslem> How long does updating cabal take?
14:12:17 <pastorn> @faq Can haskell have nonsense recursive types? -- tieTYT 
14:12:17 <lambdabot> The answer is: Yes! Haskell can do that.
14:12:42 <pastorn> Taslem: first time, maybe a minuter
14:12:50 <Taslem> Mkay, good.
14:13:07 <kmc> tieTYT, there's an infinite number of distinguishable values of that type
14:13:12 <Taslem> Gloss appears to be rather massive.
14:13:19 <pastorn> Taslem: but since you're on windows, any C library bindings you want to use you'll have to get manually
14:13:32 <djahandarie> I wonder if it IS possible to run a factorial in the kind system...
14:13:34 <pastorn> Taslem: you did > cabal install gloss ?
14:13:38 <Taslem> Yeah.
14:13:41 <tieTYT> that's fine if i'm just understanding that i use positions of the words to figure out what i'm seeing
14:13:48 <pastorn> djahandarie: when types are not enough?
14:13:59 <djahandarie> Indeed.
14:14:17 <kmc> imo the type-declaration syntax is bad for this reason
14:14:22 <pastorn> djahandarie: aren't there like different kinds of kinds?
14:14:30 <pastorn> *, ?* or whatever, and then some?
14:14:34 <djahandarie> Yes, there is sub...kinding in the kind system
14:14:34 <kmc> as a GADT you would write:  data BookInfo where { BookInfo :: BookInfo -> BookInfo }
14:14:59 <Taslem> Who here thinks a standardised pipeline for data for all languages + platforms would be good?
14:15:09 <kmc> still confusing, but the :: operator indicates (as always) whether something is a type or a value
14:15:11 <pastorn> djahandarie: is this true? "Maybe :: * -> *"?
14:15:18 <pastorn> or is there a better kind-syntax?
14:15:25 <djahandarie> This is true.
14:15:36 <pastorn> so it's "::" as well?
14:15:43 <kmc> subkinding â  different sorts of kinds
14:15:59 <kmc> but iirc GHC also has two sorts of kinds -- normal ones and coercion kinds
14:16:01 <kyagrd> pastorn: you can ask GHC with the :k command
14:16:02 <djahandarie> That isn't a standalone decleration
14:16:03 <kmc> that's an internal detail though
14:16:11 <pastorn> StateT :: * -> * -> * ?
14:16:16 <kmc> :k StateT
14:16:17 <lambdabot> * -> (* -> *) -> * -> *
14:16:26 <pastorn> whut?
14:16:27 <kyagrd> :info State
14:16:34 <pastorn> StateT env monad result
14:16:41 <pastorn> right?
14:16:53 <kmc> yeah
14:16:56 <pastorn> oh, it takes the result and THEN forms the final *
14:17:16 <kmc> :k Mu
14:17:17 <lambdabot> (* -> *) -> *
14:17:19 <kyagrd> type State s = StateT s Data.Functor.Identity.Identity
14:17:26 <hpc> Mu is the coolest
14:17:27 <pastorn> and (* -> *) since it's the monad but not applied to any 'a'
14:17:31 <pastorn> right?
14:17:34 <kmc> yes
14:17:37 <yvemath> I want to know a few good facts about haskell :D that really would help me promote Haskell :-)
14:17:39 * pastorn is getting thsi
14:18:04 <pastorn> yvemath: 
14:18:05 <hpc> yvemath: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
14:18:05 <pastorn> http://cdsmith.wordpress.com/2011/03/13/haskells-niche-hard-problems/
14:18:09 <hpc> nuf said
14:18:31 <pastorn> hpc: mine's BETTAR :p
14:18:36 <Taslem> I ran " cabal install gloss " and it completed, so now how do I use it?
14:18:49 <kmc> Taslem, what modules does that package expose?
14:18:52 <kmc> you can now import those modules
14:18:56 <kmc> see: http://hackage.haskell.org/package/gloss
14:19:15 <hpc> pastorn: pshaw
14:19:21 <kmc> if you're building your code with cabal, you will also have to add 'gloss' to your build-depends
14:19:25 <hpc> pastorn: i understood yours ;)
14:20:27 <Taslem> I cannot import Gloss.
14:20:31 <kyagrd> yvemath: a bit dated but this one is a interesting story http://bayern.stanford.edu/~brant/lightning/
14:20:41 <kmc> Taslem, did you go to the link I sent you?
14:20:46 <kmc> see where it says "Modules"?
14:20:47 <Taslem> I was already at it.
14:20:51 <kmc> the things under there are the things you can import
14:20:54 <Taslem> Graphics was not found.
14:21:02 <kmc> import Graphics.Gloss
14:21:03 <Taslem> Neither was Graphics.Gloss
14:21:19 <Taslem> Oh, wait a minute.
14:21:21 <Taslem> That is not good.
14:21:29 * hackagebot riak 0.3.1.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.3.1.0 (BryanOSullivan)
14:23:00 <Taslem> Haskell says I'm missing one of the DLL's for Gloss.
14:23:06 <kmc> GHC says that?
14:23:16 <kmc> are you compiling your code, or running in ghci?
14:23:23 <Taslem> WinGHCi, though I assume there's no difference.
14:23:38 <kmc> ok, i know nothing about windows
14:23:44 <Taslem> The Module loaded correctly, but one of the DLL's it requires is missing.
14:23:48 <Taslem> How do I fix that?
14:23:58 <kmc> all i know is that if you are compiling your code with command-line "ghc" you should pass --make
14:24:19 <pastorn> Taslem: you need glut32.dll
14:24:24 <pastorn> would be my guess
14:24:38 <thoughtpolice> kmc: at least up until GHC 7, --make is now the default compilation mode
14:24:42 <Taslem> Yeah, I think. Where can I find that, and where do I need to put/do with it?
14:24:57 <pastorn> Taslem: www.lmgtfy.com
14:25:29 <Taslem> Nothing useful came up.
14:26:52 <kmc> pastorn, that's not really how that site works ;P
14:26:56 <djahandarie> I will never get used to not adding --make to my command line.
14:27:07 <djahandarie> Since that has screwed me so many times it's impossible to reverse the behavior
14:27:13 <kyagrd> Is http://trac.haskell.org/ working?
14:27:35 <djahandarie> kyagrd, yes
14:27:46 <kyagrd> Maybe my DNS problem then
14:28:13 <pastorn> kmc: i know, but i had to kill my browser due to weird performance stuff
14:28:25 <pastorn> kmc: help wanted in #haskell-blah
14:29:23 <kyagrd> oh, what is the purpose of #haskel-blah by the way by the way?
14:29:41 <Zao> kyagrd: Discussing everything that's not on topic here.
14:30:34 <pastorn> kyagrd: to remind people in there to stop talking haskel
14:30:39 <pastorn> it happends way too ofter
14:30:45 * pastorn can't spell for shit today
14:31:38 * hackagebot text 0.11.0.6 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.0.6 (BryanOSullivan)
14:38:34 <accel> window 2
14:39:58 <lispy> Taslem: yes, you need to download freeglut and put glut32.dll in the same path as your binary
14:40:34 <lispy> I've already suggested to the Gloss author that he switch to the GLFW-b bindings which won't have this problem
14:46:12 <kmc> or you could switch to a platform which doesn't require developers to jump through these ridiculous hoops
14:47:56 <pastorn> i think the haskell platform should switch from GLUT to SDL
14:48:13 <pastorn> SDL has a much nicer API
14:48:15 <djahandarie> Don't make me glut you
14:48:20 <pastorn> <3 <3 <3 callback-less <3 <3 <3
14:48:22 <hpc> you can still do arbitrary GL in SDL yes?
14:48:29 <pastorn> hpc: yes
14:48:37 <hpc> so why haven't they already?
14:48:38 <djahandarie> Main issue with SDL is the extra work win and mac users need to do, I think
14:48:55 <hpc> but the platform can do that work
14:49:26 <pastorn> djahandarie: the only *real* problem is that for windows, when initializing OpenGL, you need to run a special initialization sequence twice
14:50:01 <pastorn> the spec says to run the code blocks as A;B;, but on windows you need A;B;A;, and it doesn't even matter
14:50:20 <accel> sup haskell
14:50:25 <pastorn> that's all the hassle that SDL has given me (never compiled any programs on windows, though...)
14:50:29 <accel> i ahve figured out what I want to do as my first main contribution back to the haskell community
14:50:33 <olsner> on Mac and Windows, I think the HP would need to bundle SDL
14:50:34 <accel> I want to write a midi player on osx in haskell
14:50:44 <accel> so I'm looking at this; and realize I have no idea how to write a midi player
14:50:52 <accel> anyone have suggeestion for what library I should bind to haskell to make this happen?
14:50:56 <accel> this is urgen
14:52:38 <pastorn> accel: freedrull was messing with this 3 minutes ago... you might want to ask him :)
14:52:49 <accel> freedrull: yo; let's team up
14:53:20 <accel> pastorn: hmm; I don't see hiw comments in my irssi log
14:53:51 <pastorn> accel: http://hackage.haskell.org/packages/archive/HCodecs/0.0.3/doc/html/Codec-Midi.html
14:54:08 <pastorn> accel: http://www.haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound#Wrappers
14:54:18 <accel> ah; hcodecs
14:54:19 <accel> found it
14:54:22 <accel> ah, nice; thanks pastorn
14:54:27 <accel> pastorn++
14:54:28 <pastorn> those were some of the things he linked
14:54:43 <accel> map (\x -> pastorm++) [1..]
14:54:48 <pastorn> accel: lambdabot has a thing for that, i think
14:54:58 <pastorn> @help karma
14:54:58 <lambdabot> karma <polynick>. Return a person's karma value
14:55:05 <pastorn> @karma pastorn
14:55:05 <lambdabot> You have a karma of -1
14:55:07 <pastorn> awwww
14:55:08 <djahandarie> Haha
14:55:11 <djahandarie> pastorn++
14:55:12 <pastorn> @karma ivanm
14:55:12 <lambdabot> ivanm has a karma of 23
14:55:15 <djahandarie> @karama pastorn
14:55:15 <lambdabot> pastorn has a karma of 0
14:55:31 <accel> pastorn: sheesh, you overflowed the karma counter once already?
14:55:33 <pastorn> me and ivanm were battling it out a while ago
14:55:39 <djahandarie> @karma djahandarie
14:55:40 <lambdabot> You have a karma of 5
14:55:48 <djahandarie> ivanm is superior...
14:55:56 <hpc> @karma hpc
14:55:56 <lambdabot> You have a karma of 3
14:56:03 <pastorn> @karma lambdabot 
14:56:03 <lambdabot> lambdabot has a karma of 3
14:56:51 <ddarius> monochrom: In my opinion, the kind of "object oriented programming" that arises naturally when programming concurrent message passing systems is the "real" object oriented programming.
14:57:07 <pastorn> ddarius: erlang?
14:58:52 <ddarius> It happens in Erlang but isn't restricted to Erlang.
15:04:10 <pastorn> jlouis++
15:04:27 <pastorn> ddarius: haskell with channels?
15:04:45 <pastorn> ddarius: have you seen "JR"?
15:05:08 <pastorn> the compiler is a giant macro expander with a java backend
15:05:22 <pastorn> specifically for concurrency problems
15:30:26 <accel> does haskell have libraries for writing out numbers in big endian format?
15:30:31 <accel> I'd prefer to not be munging the characters around myself
15:31:00 <pastorn> accel: look at Text.Printf
15:31:05 <pastorn> there migth be something useful there
15:31:24 <kmc> 'big endian format'?
15:31:38 <kmc> can you be more specific? is this a text or binary format?
15:31:49 <kmc> Haskell's Char is not a suitable type for binary data
15:32:24 <monochrom> does "cereal" do big-endian?
15:32:37 <pastorn> "binary" does :)
15:32:50 <kmc> do 'binary'/'cereal' guarantee anything about the serialized data format?
15:32:53 <accel> kmc: this is for midi; binary format
15:33:03 <monochrom> no, "binary" promises machine-endian.
15:33:05 <accel> kmc: I'm writing  ahskell library for writing out midi
15:33:28 <accel> oh shit; haskell chars are unicode
15:33:29 <accel> hmmm
15:33:33 <pastorn> kmc: "binary" provides something like 'getWord32be' and 'getWord32le' :: Get Word32
15:33:34 <kmc> accel, use Data.Word.Word8
15:33:42 <accel> if I just want to write out a char with a value of X for 0 <= X < 256; how do I do that in hasekll?
15:33:50 <kmc> you don't; you use Data.Word.Word8
15:34:08 <accel> noted; thanks
15:34:10 <kmc> and for storing multiple bytes together use ByteString
15:34:14 <kmc> (which has its own IO module)
15:34:18 <kmc> or just [Word8] if you like
15:34:23 <monochrom> oh, "binary" has big-endian too. I'll try to remember that.
15:34:24 <kmc> but ByteString is much more efficient for most operations
15:34:44 <pastorn> monochrom: "binary" is friggin awesome :)
15:34:54 <pastorn> especially the class Binary
15:35:58 <kmc> accel, also, did you look at the many existing midi libraries?
15:37:51 <accel> kmc: I saw hCodec
15:37:57 <accel> that's about all I saw on hackage.haskell.org
15:38:01 <accel> plus, the midi file format looks very easy
15:38:14 <accel> it doesn't seem to contain the complicated stuff (like how the sound is actually synthesized)
15:38:17 <kmc> accel, http://hackage.haskell.org/packages/archive/pkg-list.html
15:38:19 <kmc> Control-F midi
15:38:26 <accel> kmc: yeah; and you only find hcodecs
15:38:30 <accel> kmc: did you find anything else?
15:38:37 <accel> kmc: if you did; I'll stop bugging haskell for 24 hours
15:38:45 <rostayob> ok, I just upgraded to GHC 7
15:38:51 <rostayob> is there a way to have base 3 as well?
15:39:03 <accel> fuck
15:39:07 <accel> there's more than hcodecs
15:39:17 <accel> hmm; see everyone on saturday
15:39:24 <kmc> accel, i see: alsa-midi alsa-seq midi midi-alsa zmidi-core hmidi midi PortMidi supercollider-midi synthesizer-alsa
15:39:27 <kmc> heh
15:40:00 <kmc> that was puzzling
15:40:08 <pastorn> i want to have a function like this
15:40:39 <pastorn> playSound :: Instrument -> Pitch -> Length -> IO ()
15:41:36 <gienah> rostayob: no but you might be able to sed the dependencies in .cabal files so that ghc7 will try to compile it, then fix the breakages
15:42:04 <rostayob> gienah: so you mean remove the dependency that enforces base 3?
15:43:53 <gienah> rostayob: yes stuff like: sed -e 's@base <=4.0.0.0@base <=4.4.0.0@' -i something.cabal
15:44:14 <rostayob> gienah: I'm trying now, thanks
15:44:19 <gienah> rostayob: sed -e 's@import qualified Control.Exception as Ex@import qualified Control.OldException as Ex@' -i something.hs
15:48:32 <gienah> rostayob: it is mtl-1 to mtl-2 breakages that are more difficult to fix, hope you do not hit any of those with whatever you are compiling
15:48:39 <rostayob> gienah: yeah... I'm having problems with Exception: "Class `Exception' used as a type"
15:49:21 <gienah> rostayob: hopefully changing the import to Control.OldException might help?
15:49:52 <rostayob> gienah: yep it seems to help
15:50:02 <gienah> rostayob: great
15:50:04 <rostayob> but I still have other problems
15:50:51 <rostayob> gienah: http://pastebin.com/3HDRfU5t this
15:53:26 <gienah> rostayob: not really sure that is causing that, is this an open source package you are compiling?
15:53:56 <ian_mi> suppose I have f :: a -> m a. Is there a better way of writing foldM (flip (const f)) x (repeat ())?
15:54:16 <rostayob> gienah: it is, Extra
15:54:24 <rostayob> gienah: http://hackage.haskell.org/package/Extra
15:56:17 <ian_mi> I would think such a function would be in Control.Monad somewhere but I can't find it.
15:56:58 <kmc> :t foldM (flip (const ?f)) x (repeat ())
15:56:58 <lambdabot> forall (m :: * -> *). (?f::Expr -> m Expr, Monad m) => m Expr
15:57:01 <kmc> :t foldM (flip (const ?f)) ?x (repeat ())
15:57:01 <lambdabot> forall a (m :: * -> *). (?f::a -> m a, ?x::a, Monad m) => m a
15:57:11 <rostayob> gienah: anyway, sadly I have to run now, and I think it has to do with TH looking at the error
15:57:16 <rostayob> thanks for the help
15:58:09 <gienah> @tell rostayob: the QuickCheck (<2) dependency will also be difficult to upgrade to QuickCheck 2.4
15:58:09 <lambdabot> Consider it noted.
16:17:32 <tieTYT> does ghci have a shortcut for, "reload the last file you loaded"?
16:17:53 <Saizan> :r
16:18:06 <tieTYT> thanks
16:24:13 <micahjohnston> what does ::: mean?
16:24:25 <kmc> nothing in particular
16:24:34 <micahjohnston> so it's just a function if I see it somewhere?
16:24:38 <Axman6> it's not a predefined thing in haskell
16:24:41 <Axman6> yes
16:24:41 <kmc> a library can define that operator
16:24:41 <micahjohnston> ok
16:24:50 <kmc> since it starts with a colon, it would be a data constructor rather than a function
16:24:54 <kmc> data Foo = Char ::: Bool
16:24:56 <micahjohnston> I thought it might be in some compiler extension because they were using existential quantification etc.
16:25:09 <micahjohnston> oh, data constructors need to start with colons?
16:25:15 <kmc> if they're operators
16:25:19 <micahjohnston> ok
16:25:20 <kmc> colons are 'upper case'
16:25:21 <micahjohnston> thanks
16:25:27 <kmc> i think Data.Record uses (:::)
16:25:32 <kmc> http://hackage.haskell.org/package/records
16:26:26 <micahjohnston> it was in some llvm binding tutorial
16:28:37 <Pumpkin> Kmc you there?
16:29:12 <Saizan> a grown up pumpkin?
16:29:15 <shachaf> Pumpkin: What's with the uppercase?
16:29:45 <tieTYT> why won't this compile? http://hpaste.org/44889/ispalindrome
16:29:49 <Pumpkin> I'm on webchat on iPhone and trying to find kmc :P
16:29:56 <tieTYT> please don't tell me about logic errors, I want to figure those out on my own
16:30:22 <kmc> hi Pumpkin
16:30:32 <aristid> Pumpkin: kmc was saying something 3 minutes before you asked whether he was here ;)
16:30:33 <kmc> waht's u?
16:30:36 <kmc> what's up gah
16:30:54 <Saizan> tieTYT: you should have annotated with the error
16:30:58 <Pumpkin> Yo come to lizard lounge!
16:31:05 <Tomsik> > True && False
16:31:06 <lambdabot>   False
16:31:18 <tieTYT> http://hpaste.org/paste/44889/ispalindrome_annotation#p44890
16:31:19 <Tomsik> Woah, I've always used "and"
16:31:35 <sbahra> :t and
16:31:36 <lambdabot> [Bool] -> Bool
16:31:38 <shachaf> tieTYT: Oh. Well, it's logic errors.
16:31:44 <sbahra> :t (&&)
16:31:45 <lambdabot> Bool -> Bool -> Bool
16:31:45 <Eduard_Munteanu> > 1 == 2 && True
16:31:46 <lambdabot>   False
16:31:46 <shachaf> > and [True, False]
16:31:47 <lambdabot>   False
16:31:47 <tieTYT> shachaf: but it won't compile
16:31:53 <sbahra> Tomsik: They're totally different. :)
16:32:02 <Saizan> tieTYT: the type signature you've given for ispalindrome is wrong
16:32:25 <kmc> Pumpkin, maybe, but i didn't sleep much last night so instead i think i'll work for a bit more and then pass out
16:32:31 <kmc> thanks for pinging me though
16:32:33 <edwardk> bah
16:32:35 <tieTYT> Saizan: how?
16:32:39 <Saizan> tieTYT: you could just omit it and let ghci infer one for you
16:32:41 <frerich_> tieTYT: The problem with 'myreverse' is that on the last recursion step, 'xs' will be an empty list. However, the empty list doesn't match the '(x:xs)' part (which only works with lists with at least one element)
16:32:53 <Pumpkin> weak!!!
16:33:11 <edwardk> come hang out!
16:33:22 <Pumpkin> Peer pressure!!!
16:33:23 <edwardk> *peer pressure*
16:33:37 <shachaf> Lizard lounge?
16:35:01 <tieTYT> Saizan: oh... i wouldn't have figured that out on my own
16:35:15 <edwardk> http://www.yelp.com/biz/lizard-lounge-cambridge with a bunch of fp people
16:35:25 <edwardk> and music
16:35:27 <Saizan> tieTYT: you need the Eq a becuase you're using (==)
16:35:43 <tieTYT> Saizan: yep, sorta get what's going on
16:36:55 <tieTYT> frerich_: this extra pattern didn't seem to fix the problem: ispalindrome [] = True
16:37:35 <tieTYT> ispalindrome "abccba" is returning False.  I'll look into it for a while, thanks
16:37:49 <frerich_> tieTYT: No, I mean - you need it for myreverse. Imagine what happens if you call 'myreverse' l ike 'myreverse [1] []'. In the beginning, 'x' will be '1', 'xs' will be '[]' and 'ys' will be '[]'.
16:38:41 <frerich_> tieTYT: Now myreverse recurses, using 'xs' as the first argument. So it calls itself like '[] [1]'. However, the only pattern you give doesn't match the first argument, since the empty list does no match '(x:xs)' (which matches only lists with at least one element).
16:38:43 <tieTYT> so? that returns [1] still, which is right
16:38:53 <Saizan> > let reverse (x:xs) ys = reverse xs (x:ys); reverse [] ys = ys in reverse [1] []
16:38:54 <lambdabot>   [1]
16:39:17 <frerich_> tieTYT: Oh sorry I misread, I thought you had to *add* that second pattern and wanted to know why
16:39:40 <tieTYT> so, myreverse is ok?
16:41:03 <frerich_> tieTYT: Depends; if you consider it on its own, it's strange that a reverse function takes two arguments.
16:41:26 <tieTYT> agreed
16:41:42 <tieTYT> but it works with what i've tested.  ispalindrome on the other hand...
16:41:59 <tieTYT> ispalindrome "abccba" is returning false
16:42:17 <frerich_> tieTYT: 'myreverse' should return the reverse of the first argument? E.g. 'myreverse [1,2,3] []' should yield [3,2,1]'?
16:42:29 <tieTYT> frerich_: yes
16:42:53 <frerich_> tieTYT: Hm well, 'myreverse [] [1,2,3]' doesn't behave like that. It doesn't return '[]' but '[1,2,3]'
16:43:20 <frerich_> tieTYT: The second argument is a bit of an ugly duckling :)
16:43:51 <tieTYT> yeah I know, i guess I could define the whole thing as a helper method inside of a let/where 
16:44:02 <tieTYT> but I don't really care about that detail, i can't figure out why palindrome doesn't work
16:44:32 <sipa> where's the code?
16:45:21 <frerich_> tieTYT: Hm well, ispalindrome for '[1,2,3,3,2,1]' checks whether the first and the last element are equal (which is true) *and* whether '[2,3,3,2,1]' is a palindrome - which is false.
16:45:24 <tieTYT> oh i think I see the problem
16:45:42 <frerich_> tieTYT: The recursion step only skips the first element, but not the last.
16:46:22 <tieTYT> gotcha, I'll think about this more, thanks
16:46:54 <sipa> seems like you need to pass the number of elements to skip in the recursion
16:51:24 <spirit> would [String] stand for list of strings?
16:51:36 <hpc> spirit: yes
16:52:27 <spirit> i get an error message for this signature:
16:52:37 <spirit> splitString :: String -> [String]
16:52:40 <spirit> Illegal operator `â' in type `String â [String]'
16:52:40 <spirit>       Use -XTypeOperators to allow operators in types
16:52:40 <spirit> Failed, modules loaded: none.
16:52:50 <tieTYT> ok i figured it out, it's way easier this way: ispalindrome xs = xs == myreverse xs []
16:53:47 <Saizan> spirit: is your editor transforming -> into â for you?
16:53:48 <sipa> spirit: -> or â ?
16:53:56 <Peaker> spirit, not quite that signature, you have â there, don't you?
16:53:58 <aristid> > zipWith (==) <*> reverse $ [1,2,3,3,2,1]
16:53:59 <lambdabot>   [True,True,True,True,True,True]
16:54:18 <aristid> > and $ zipWith (==) <*> reverse $ [1,2,3,3,2,1]
16:54:18 <lambdabot>   True
16:54:31 <spirit> cheers! that was it!
16:54:34 <frerich_> tieTYT: True; here's a brain teaser: that new simplified function will perform 'n' comparisons (where n is the length of the string). You actually only need to perform n/2 though.
16:54:39 <xplat> let reverse = foldl' (:) [] in join ((==) . reverse) "madam" 
16:54:44 <aristid> > (==) <*> reverse $ [1,2,3,3,2,1]
16:54:44 <lambdabot>   True
16:54:44 <xplat> > let reverse = foldl' (:) [] in join ((==) . reverse) "madam" 
16:54:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:55:17 <Saizan> spirit: btw you can use â but you've to {-# LANGUAGE UnicodeSyntax #-} at the top of your file
16:55:20 <xplat> :t foldl'
16:55:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:55:38 <frerich_> tieTYT: One idea to fix this: consider reversing one half of the list (e.g. the first half) and then comparing that with the other half.
16:55:45 <aristid> > (==) =<< reverse $ [1,2,1]
16:55:46 <lambdabot>   True
16:56:04 <hpc> > foldl (:) [] [1..5]
16:56:04 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:56:08 <aristid> xplat: this version is equivalent to yours :)
16:56:27 <hpc> :t foldr
16:56:28 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:56:33 <xplat> > let reverse = foldl' (flip (:)) [] in (==) <*> reverse $ "madam" 
16:56:34 <lambdabot>   True
16:56:51 <hpc> oh right, the function is flipped
16:56:56 <Saizan> the ' of foldl' is not that useful here
16:57:01 <xplat> > let reverse = foldl' (flip (:)) [] in (==) <*> reverse $ "madame" 
16:57:03 <lambdabot>   False
16:58:48 <xplat> Saizan: true, the thunks don't eat the stack when you evaluate to whnf
16:59:23 <dolio> It does a little work sooner rather than later.
16:59:36 <mekeor> hi.
16:59:36 <mekeor> I want to continue writing following haskell-source-code in such way, that it should print out all prime numbers:
16:59:36 <mekeor> prime = sieb [2 ..]
16:59:36 <mekeor>              where sieb (x:xs) = x:sieb [n|n<-xs, mod n x > 0]
16:59:36 <mekeor> so, I just need a main function which puts this list output! -- how to implement that?
16:59:54 <dolio> By reducing from 'flip (:) xs x' to 'x:xs' immediately instead of thunking.
17:00:21 <Saizan> i hope the inliner would catch that anyway
17:00:27 <mekeor> dolio, is that an answer to my question?
17:00:36 <mekeor> ??
17:00:47 <dolio> mekeor: It would be an amazing coincidence if it were.
17:00:50 <hpc> mekeor: that's not really a sieve since it uses mod
17:00:58 <mekeor> :)
17:01:37 <mekeor> hpc: my only problem is printing an infinite list out; how to do that?
17:01:42 <mekeor> which function to use?
17:01:43 <dolio> main = print prime
17:01:43 <Peaker> @type [(=<<), (<*>)]
17:01:44 <lambdabot> forall a b. [(a -> a -> b) -> (a -> a) -> a -> b]
17:01:52 <dolio> Assuming you want to print it all out.
17:01:52 <hpc> mekeor: the same you normally would
17:02:10 <mekeor> thx!!!
17:02:20 <Peaker> A bit peculiar how (=<<) and (<*>) turn out the same in one of the instances :)
17:02:21 <dolio> It's going to take a while, though.
17:02:27 <Mormegil> hello
17:02:29 <mekeor> thank you very much, in particular: dolio
17:02:56 <Mormegil> the "try haskell in your browser" is a lot like ruby.
17:03:03 <aristid> Peaker: they don't.
17:03:11 <aristid> Peaker: it's just that (==) is commutative for lists
17:03:21 <Peaker> aristid, well, up to a flip, anyhow
17:03:34 <Peaker> aristid, a well-behaving (==) should be cummutative for everything...
17:03:50 <aristid> :t (=<<) . flip
17:03:51 <lambdabot> forall a (m :: * -> *) b. (Monad m, Functor m) => m (a -> b) -> m a -> m b
17:04:02 <aristid> :t (=<<) . Prelude.flip
17:04:03 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
17:04:35 <aristid> Peaker: right, i guess it's a law for Eq :)
17:05:02 <hpc> it's a law of any equivalence relation
17:05:03 <hpc> :P
17:05:15 <aristid> hpc: it does not hold for Double
17:05:19 <aristid> evil evil
17:05:22 <hpc> nothing holds for Double
17:06:19 <xplat> wait, commutativity of == doesn't hold for Double?  i thought that was one of the few things that does hold :(
17:06:36 <hpc> > (0 / 0) = (0 / 0)
17:06:36 <lambdabot>   <no location info>: parse error on input `='
17:06:41 <hpc> > (0 / 0) == (0 / 0)
17:06:42 <lambdabot>   False
17:06:57 <hpc> wait, that reflexivity
17:07:02 <xplat> hpc: that's reflexivity failing, not s...
17:07:15 <hpc> yeah
17:07:19 <aristid> hmmm
17:07:27 <hpc> commutativity is (x * y) = (y * x)
17:07:37 <hpc> which equality definitely follows for doubles
17:07:45 <xplat> in this case it's (x == y) iff (y == x)
17:08:03 <hpc> some other language would have noticed before now if that wasn't the case
17:08:10 <aristid> > compare (0/0) (0/0)
17:08:10 <lambdabot>   GT
17:08:19 <hpc> ha!
17:08:31 <hpc> default definitions fail
17:08:44 <xplat> well, compare isn't commutative ...
17:09:04 <aristid> hpc: well it has to return SOMETHING, eh? it could bottom out, but that might break stuff
17:09:17 <hpc> xplat: actually, it is in the case of (0/0)
17:09:38 <hpc> if you take it to be (x * y) = (y * x)
17:09:38 <aristid> lol
17:09:50 <xplat> > let x = 0/0; y = 0/0 in x `seq` (y `seq` (compare x y, compare y x))
17:09:50 <lambdabot>   (GT,GT)
17:09:53 <aristid> NaN is the most commutative value.
17:10:02 <shachaf> > (0/0) == (0/0)
17:10:03 <lambdabot>   False
17:10:14 <aristid> > (0/0) != (0/0)
17:10:15 <lambdabot>   Not in scope: `!='
17:10:20 <xplat> > let x = 0/0; y = 0/0 in x `seq` (y `seq` (x > y, y > x))
17:10:20 <aristid> > (0/0) /= (0/0)
17:10:20 <lambdabot>   (False,False)
17:10:21 <lambdabot>   True
17:10:24 <hpc> ITC: we troll logic IEEE floats into following the laws of math
17:10:30 <xplat> > let x = 0/0; y = 0/0 in x `seq` (y `seq` (x < y, y < x))
17:10:31 <lambdabot>   (False,False)
17:11:12 <shachaf> (==) isn't reflexive or symmetric.
17:11:23 <shachaf> Er, isn't reflexive or transitive.
17:11:27 <shachaf> It seems to be symmetric.
17:11:40 <hpc> is it anti-symmetric?
17:11:53 <spirit> in this line of code...
17:11:54 <spirit> newtype SetObj = SetObj {toSet:: ObjType} deriving Eq
17:12:09 <xplat> @src compare
17:12:09 <lambdabot> compare x y | x == y    = EQ
17:12:09 <lambdabot>             | x <= y    = LT
17:12:09 <lambdabot>             | otherwise = GT
17:12:33 <spirit> is toSet a constructor? or something like that?
17:12:39 <hpc> spirit: no
17:12:40 <xplat> oh, so that's where that oddness comes from ...
17:13:06 <hpc> spirit: the {blahblah ::..} is accessors; it is the same as writing
17:13:09 <Eduard_Munteanu> hpc: yes! if a == b and b != a then a == b  !
17:13:18 <hpc> data SetObj = SetObj ObjType
17:13:26 <hpc> toSet (SetObj x) = x
17:13:26 <aristid> data Ordering = EQ | LT | GT | NT
17:13:41 <hpc> data Bool = False | True | FILE_NOT_FOUND ;)
17:13:45 <spirit> great!
17:13:59 <dolio> xplat: NaN == NaN is False, and so is NaN <= NaN.
17:14:13 <xplat> yeah, figured that out
17:14:16 <aristid> hpc: yes, it's a grave bug that ghc does not support FILE_NOT_FOUND
17:14:42 <Peaker> Why does "compare" use (<=) and not (<) there?
17:14:54 <Peaker> (no difference, except it is slightly more confusing, perhaps?)
17:15:09 <dolio> (<=) is one of the two options for primitive definition in Ord, I think.
17:15:12 <dolio> compare or (<=).
17:15:25 <xplat> data Bool = False | True | Null | Mu | What | WhatIsTruth | MyHovercraftIsFullOfEels
17:15:29 <shachaf> @src (<=)
17:15:29 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
17:16:05 <shachaf> @ty compare compare compare
17:16:06 <lambdabot> Ordering
17:16:21 <Eduard_Munteanu> @ty all
17:16:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:16:34 <aristid> > compare compare compare
17:16:35 <lambdabot>   *Exception: (==): No overloading for function
17:16:41 <aristid> wtf?
17:17:01 <shachaf> aristid: lambdabot has a Num instance for functions.
17:17:21 <aristid> @info Num
17:17:21 <lambdabot> Num
17:17:28 <aristid> lambdabot: thank you.
17:17:42 <aristid> shachaf: Num has no Ord constraint
17:17:44 <xplat> @slap lambdabot
17:17:44 * lambdabot pulls lambdabot through the Evil Mangler
17:17:47 <shachaf> @src Num
17:17:47 <lambdabot> class  (Eq a, Show a) => Num a  where
17:17:47 <lambdabot>     (+), (-), (*)           :: a -> a -> a
17:17:47 <lambdabot>     negate, abs, signum     :: a -> a
17:17:47 <lambdabot>     fromInteger             :: Integer -> a
17:17:50 <shachaf> Oh.
17:17:53 <Eduard_Munteanu> > fromIntegral id :: Int   -- :P
17:17:53 <lambdabot>   No instance for (GHC.Real.Integral (a -> a))
17:17:53 <lambdabot>    arising from a use of `GHC....
17:17:55 <shachaf> Not sure why that's there, then.
17:18:04 <shachaf> @info [x | x <- xs]
17:18:04 <lambdabot> concatMap (\ x -> [x]) xs
17:18:15 <xplat> > id <= id
17:18:16 <lambdabot>   *Exception: (==): No overloading for function
17:18:36 <xplat> @instances Ord
17:18:37 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:18:52 <Eduard_Munteanu> I wonder is there anything known about the cardinality (or an equivalent type-theoretic concept) of various types?
17:19:00 <xplat> @instances Num
17:19:01 <lambdabot> Double, Float, Int, Integer
17:19:11 <xplat> hm, obviously not complete
17:19:30 <Eduard_Munteanu> I presume Rational ~ Int as in set theory.
17:19:42 <Eduard_Munteanu> (erm... Integer)
17:20:05 <xplat> Eduard_Munteanu: infinite types all have cardinality Alephâ as sets
17:20:30 <Eduard_Munteanu> Was that aleph null / zero?
17:20:42 <Eduard_Munteanu> (sorry, I just switched to urxvt, might have issues)
17:20:45 <aristid> what's the cardinality of [Integer]?
17:20:59 <xplat> yes.  however if you use internal set theory in the category of types for your language, they might have different cardinalities
17:21:46 <Eduard_Munteanu> Hrm, so is there no type that's isomorphic to the reals?
17:21:47 <xplat> aristid: Alephâ.  its denotation has cardinality c, however :)
17:22:40 <aristid> xplat: isn't the set of [Integer] values equivalent to the powerset of Integer values?
17:22:40 <xplat> but the interpretation function is not onto
17:22:58 <aristid> and what is c?
17:23:07 <Eduard_Munteanu> aristid: I expect it to, but isn't 2^{aleph_0} ~ aleph_0 ?
17:23:16 <xplat> c is 2^Alephâ, the power of the continuum
17:23:36 <pastorn> c = |R| ?
17:23:39 <sipa> 2^(aleph 0) = (aleph 1), no?
17:23:46 <Eduard_Munteanu> Hrm.
17:24:06 <Eduard_Munteanu> I might be forgetting stuff, but I didn't expect 2^N ~ R
17:24:23 <xplat> which is a different infinite cardinal.  according to the usual axioms of set theory, there's very little else you can say about which aleph it is, besides that it's not the zeroth one
17:24:28 <pastorn> i think that that is one of those things that are suspected but hasn't been proven
17:24:36 <pastorn> "hypothesis"?
17:24:38 <xplat> 2^N ~ R is true
17:24:44 <aristid> Eduard_Munteanu: every number in R can be viewed as a sequence of rational approximations :)
17:24:51 <pastorn> xplat: are you sure about that?
17:24:59 <Eduard_Munteanu> A-ha, Dedekind construction, I remember.
17:25:10 <xplat> 2^N ~ Alephâ is independent of the usual axioms of set theory
17:26:20 <xplat> (and yes, it is meaningful to state that as an iso with no bars)
17:26:57 <Eduard_Munteanu> IIRC, if CH is false (which is independent anyway) you have nothing between Aleph_0 and c=Aleph_1
17:27:08 <Eduard_Munteanu> But what about cardinals greater than Aleph_1?
17:27:32 <xplat> no, if CH is true you have no cardinals between Aleph_0 and Aleph_1
17:27:53 <aristid> Eduard_Munteanu: you got it wrong way round! shame corner!
17:27:55 <xplat> if CH is false you have at least one other between
17:28:01 <Eduard_Munteanu> Oh.
17:28:03 <dolio> The case for higher cardinalities is called the generalized continuum hypothesis.
17:28:21 <dolio> 2^Aleph_n = Aleph_(n+1)
17:28:26 <Eduard_Munteanu> I presume that's still independent of ZFC.
17:28:30 <dolio> Yes.
17:28:43 <xplat> people have actually constructed a bunch of subsets of the reals that can have cardinalities between Aleph_0 and c if CH is false
17:29:33 <Eduard_Munteanu> Grrr, math suddenly gets boring if reals are all there is wrt cardinality :)
17:29:51 <dolio> Do the constructions depend only on CH being false?
17:31:11 <xplat> dolio: i think they depend on some more specific forcing conditions or something
17:31:13 <Eduard_Munteanu> Is this situation similar to saying the existence of Aleph_1 is independent of ZFC if we didn't postulate the existence of reals?
17:31:47 <Eduard_Munteanu> Or, IOW, is there any useful construction that could mandate picking CH/GCH as true/false?
17:32:21 <Eduard_Munteanu> s/ZFC/set theory/
17:32:22 <xplat> and you can construct (for a set-theorist's notion of 'construct') most of those subsets anyway, it's just that they are equinumerous with either R or N if the CH is true
17:32:34 <dolio> Yeah.
17:32:37 <Eduard_Munteanu> Oh.
17:33:12 <xplat> Eduard_Munteanu: there are otherwise-useful axioms that imply either CH or !CH, like L=R or Determinacy
17:33:14 <Eduard_Munteanu> So the analogy with reals can't exist? Like R ~ N if we chose another definition for reals (and could still do stuff like sqrt(2))
17:33:30 <dolio> Eduard_Munteanu: The existence of Aleph_1 isn't independent of ZFC, and the reals aren't postulated.
17:33:46 <xplat> and reals can always be constructed in a set theory with the naturals
17:33:47 <Eduard_Munteanu> dolio: in the sense some things require reals
17:33:50 <dolio> The only postulated infinite set is the naturals.
17:34:16 <dolio> (Usually)
17:34:17 <xplat> and, yeah, Aleph_1 always exists too
17:34:28 <Eduard_Munteanu> Like defining sqrt() as a total function over [0; +inf)
17:34:32 <xplat> you'd have to have a very weak set theory to not get all this stuff out
17:34:33 <dolio> The question is whether Aleph_1 is the reals or something else.
17:34:54 <Eduard_Munteanu> (that pretty much requires reals)
17:35:02 <xplat> there are things that definitely are Aleph_1 cardinality too
17:35:08 <wavewave> hi, I have a question on HTTP library. 
17:35:08 <xplat> like the set of countable ordinals
17:35:55 <xplat> i can't remember if the definable-powerset of Aleph_0 is or not
17:36:28 <wavewave> is it normal to get "connect: does not exist (Connection refused)" if I use simpleHTTP to connect to some invalid web address?
17:36:31 <Eduard_Munteanu> xplat: the axiom of determinacy?
17:36:38 <Eduard_Munteanu> (about what you said earlier)
17:36:53 <xplat> Eduard_Munteanu: you don't need reals to define sqrt as a total function over positive numbers, though, you can do that in the algebraic closure of the rationals
17:37:06 <wavewave> I mean that the program simply stops there.
17:37:14 <xplat> which is a countable set
17:37:54 <xplat> now defining sin as a total function ...
17:38:12 <Eduard_Munteanu> xplat: yes, granted you can add a countable subset of the reals
17:38:13 <xplat> or pretty much as any function at all, in radians :)
17:38:19 <wavewave>  I imagine that it should give a Left (error) not stop with an exception. 
17:38:42 <wavewave> since return type of simpleHTTP is Either type. 
17:38:48 <xplat> Eduard_Munteanu: the algebraic closure of the rationals is not a subset of the reals
17:39:41 <dolio> You should be able to define sin as a total function into the computable reals. :)
17:39:52 <xplat> hm, good point
17:39:53 <dolio> Which are countable.
17:40:07 <Eduard_Munteanu> Ok, that's a good one.
17:40:38 <xplat> you really just need the reals to have LUBs for every bounded set and such
17:40:44 <Eduard_Munteanu> Would it be possible to make a set theory that only required CR for "most" operations?
17:40:45 <dolio> That should work for most functions you practically care about, too, inasmuch as in practice you want to compute them.
17:40:49 <frerich_> Hm, it must be too late for me. I've been staring at this for some time now - does anybody know why http://hpaste.org/paste/44891/2d_array_annotation#p44892 yields "Error in array index" on the console when executing the program?
17:41:19 <Botje> frerich_: did you mean ((1,1),(3,3)) ?
17:41:25 <xplat> like the LUB of 'fraction of turing machines that stop after n steps'
17:41:40 <xplat> for every n
17:41:59 <Eduard_Munteanu> I'm trying to think of a situation similar to deciding upon CH, but for reals :)
17:42:08 <xplat> all the members of that set are CReals, but there is no least CReal upper bound
17:42:20 <frerich_> Botje: Ah, yes, good idea, I guess I do!
17:43:39 <Eduard_Munteanu> Hrm yes. Or some sort of epsilon definition for every operation you'd do.
17:44:06 <Eduard_Munteanu> xplat: does this construction have a name?
17:44:13 * hackagebot aws 0.0.2 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.0.2 (AristidBreitkreuz)
17:44:17 <xplat> Chaitin's Omega
17:44:33 <Eduard_Munteanu> Hrm, I remember that was merely related :/
17:44:35 <Eduard_Munteanu> Lemme look it up.
17:45:22 <Eduard_Munteanu> Erm, yeah, not exactly there.
17:45:24 <xplat> well, specifically i constructed a set of CReals that has Omega as LUB when injected into the reals
17:45:38 <xplat> but it's a pretty obvious construction
17:46:12 <xplat> and an almost identical construction is used in some of the proofs
17:46:17 <Eduard_Munteanu> Ok, so if I get this straight... ZF(C) amounts to reals?
17:46:38 <xplat> nonono ... the powerset of the reals is larger yet
17:46:47 <Eduard_Munteanu> *sigh*
17:46:47 <xplat> and so on
17:46:51 <Eduard_Munteanu> Oh!
17:46:57 <Eduard_Munteanu> That makes sense then.
17:47:54 <xplat> the powerset is always going to be another aleph, too (in ZFC all the cardinals are alephs, but there can be other ones in ZF)
17:47:58 <Eduard_Munteanu> So the existence of ever larger cardinals is actually the existence of ever larger powersets.
17:48:19 <xplat> but powerset can skip over insanely large numbers of the alephs
17:48:19 <wavewave> hmm, I just found http-enumerator package. probably this is better than HTTP package.
17:48:35 <Eduard_Munteanu> Are those taken to be independent assertions or derivable from ZFC?
17:49:31 <Eduard_Munteanu> So if one considers (G)CH it's all about non-integral Alephs, right?
17:50:03 <dolio> Non-integral?
17:50:22 <xplat> Eduard_Munteanu: it's derivable from ZFC + Con(ZFC) that there are models of ZFC with powersets coming arbitrarily far into the sequence compared to their base sets
17:50:30 <sipa> more than aleph 0 but less than aleph 1
17:50:31 <Eduard_Munteanu> dolio: say, between Aleph_0 and Aleph_1
17:50:34 <xplat> there are no 'non-integral' alephs
17:50:54 <dolio> The aleph numbers are indexed by ordinals.
17:50:57 <xplat> Alephs are the cardinals that are equinumerous with at least one ordinal
17:51:22 <Eduard_Munteanu> xplat: erm, but I thought CH concerned with stuff between Aleph_0 and Aleph_1
17:51:25 <xplat> they are indexed by ordinals and they inherit a well-ordering from their ordinal representatives
17:51:45 <Eduard_Munteanu> (well, yes, my bad for introducing that word)
17:51:49 <dolio> Alephs are all the cardinals. 0 is the smallest (a countable set), 1 is next largest, etc.
17:52:02 <xplat> no, CH concerns whether 2^{Aleph_0} is Aleph_1 or Aleph_{something higher than 1}
17:52:15 <Eduard_Munteanu> Oh.
17:52:15 <dolio> There's another sequence, the Beth numbers where Beth_0 is countable, and Beth_(n+1) = 2^Beth_n.
17:52:26 <dolio> The generalized continuum hypothesis is that Aleph_n = Beth_n.
17:53:01 <dolio> The regular continuum hypothesis is that Aleph_1 = Beth_1.
17:53:20 <Eduard_Munteanu> I see.
17:53:27 <dolio> Denything that would mean that Beth_1 = Aleph_k for some k > 1.
17:53:38 <dolio> And Beth_1 is the cardinality of the reals.
17:53:51 <xplat> of course, some people, including roconnor and myself, suspect the powerset axiom might be inconsistent with the other axioms of set theory which would make a lot of this meaningless :)
17:54:03 <Eduard_Munteanu> dolio: Beth_1 = c  for purpose of definition?
17:54:16 <xplat> Beth_1 = c by definition
17:54:28 <xplat> well, almost by definition
17:54:41 <dolio> They're in bijection, at least.
17:54:52 <frerich_> Would anybody here willing to review the 89 lines of source code for my first Haskell project, an ASCII tic tac toe game? I'd be interested in style improvements but also more elegant ways to express things. The source code is available at http://hpaste.org/44893/tictactoe
17:55:11 <Eduard_Munteanu> Hrm, it'd be confusing if 'c', 'Beth_1' and 'Aleph_1' were defined differently (no matter if they're isomorphic).
17:56:08 <xplat> technically, 'c' and 'Beth_1' are defined differently, but it's very simple to see that they MUST be isomorphic for reasons that are very simple and highly portable among set theories
17:56:10 <dolio> Beth_1 is defined to be the power set of Beth_0, or something similar.
17:56:27 <Eduard_Munteanu> What's Beth_0 really?
17:56:36 <Eduard_Munteanu> Aleph_0 = |N|
17:56:42 <xplat> ('c' is defined to be |R|, Beth_1 = 2^|N|)
17:56:49 <dolio> Beth_0 is the same as Aleph_0.
17:57:22 <xplat> but if Beth_1 == Aleph_1 that's true by some sort of very involved 'happenstance'
17:57:22 <Eduard_Munteanu> But if Aleph_{k+1} = 2^Aleph_k, that's a bit trivial to wrap my head around it :/
17:57:54 <Eduard_Munteanu> (I mean by definition)
17:58:24 <xplat> Eduard_Munteanu: Aleph_{k+1} is not defined to be 2^{Aleph_k}, it's defined to be the cardinality of the first ordinal that has a cardinality higher than Aleph_k
17:58:26 <Eduard_Munteanu> erm, take that exponentiation liberally
17:58:54 <dolio> Beth is defined the way you want Aleph to be defined.
17:59:08 <xplat> so Aleph_1 is the cardinality of the first uncountable ordinal
17:59:29 <Eduard_Munteanu> By the way, how do you define a ordering between cardinals, really now? The theory I know is a bit too specific to naturals vs reals and such and isomorphisms.
18:00:03 <xplat> cardinals are ordered by the ability to define an injection
18:00:13 <Eduard_Munteanu> Oh!
18:00:45 <Cale> The axiom of choice is required for cardinals to be totally ordered.
18:00:52 <Eduard_Munteanu> So if you can define an injection A -> B then A >= B, and for a surjection A <= B
18:00:57 <xplat> A < B if there's some sets a and b where A = |a| and B = |b| and a function that maps every element of a to a different element of b
18:01:00 <Eduard_Munteanu> (if I didn't get it the other way around)
18:01:12 <xplat> er, *A <= B if
18:01:39 <Cale> (in fact, it's equivalent to the axiom of choice that the ordering on cardinals is total)
18:01:40 <xplat> surjections don't really come into it at the definitional level
18:02:52 <Eduard_Munteanu> Ah, I thought it had something to do with bijection implying equality of cardinality.
18:03:01 <xplat> the cardinals in the aleph sequence are totally ordered, though, regardless.  but without choice there might be cardinals that don't show up in the aleph sequence and are incomparable with some of the alephs
18:03:13 <Cale> Bijection implies equality of cardinality regardless
18:03:26 <Eduard_Munteanu> (so |a| <= |b| and |b| <= |a|   ->   |a|  =  |b|)
18:03:46 <Cale> Oh, that, well, yes. :)
18:04:20 <xplat> the stuff where bijection and surjection have something to say about the ordering of cardinals all comes in as theorems, though, not at the definitional level
18:04:40 <amindfv> is it possible to use variables to represent data constructors with variables in pattern-matching?
18:04:42 <Eduard_Munteanu> Ew, it's kinda tough to think about partial ordering in cardinals.
18:04:52 <xplat> in my set theory class they left it as exercises to prove those things
18:04:59 <Cale> amindfv: If you mean what I think you do, then no.
18:05:14 <amindfv> so, if I have: data A = A Float | B Float
18:05:27 <Eduard_Munteanu> xplat: ok, so surjection has nothing to do with ordering, right?
18:06:01 <xplat> Eduard_Munteanu: it has nothing to do with the definition of ordering, but it can have to do with actual facts of ordering
18:06:14 <amindfv> is there ANY way to write a function with the functionality f (_ b) = B b :: A -> A?
18:06:26 <Cale> Eduard_Munteanu: It would mean that infinite sets have different "shapes" such that you can have a pair where neither one fits inside the other.
18:06:26 <Eduard_Munteanu> Well, assuming AC and any sorts of theorems you could bring in.
18:06:55 <Cale> amindfv: f x = case x of A v -> v; B v -> v
18:07:03 <Cale> Or f (A v) = v; f (B v) = v
18:07:08 <Cale> er
18:07:08 <Eduard_Munteanu> Cale: hm, nice. And since these are infinites anyway, you can't really say anything about their sizes, not even compare them :/
18:07:17 <Cale> amindfv: Oh, missed the re-tagging
18:07:21 <Cale> amindfv: But you get the idea.
18:07:54 <Cale> amindfv: You might be better off with data T = A | B; data S = S T Float
18:08:27 <Cale> Eduard_Munteanu: Well, you can *sometimes* compare them
18:08:33 <Eduard_Munteanu> This discussion does make me wonder if there's a type theory that includes AC and still lets you prove things via Curry-Howard :)
18:08:41 <xplat> Cale: come to think of it, are the beths even guaranteed to be alephs?  that would mean that the reals could provably be well-ordered in ZF
18:08:52 <Eduard_Munteanu> (probably not since programs are necessarily constructive)
18:09:10 <xplat> is it even known whether that requires choice?
18:09:22 <amindfv> Cale: hmmm, that last example might be exactly what I'm looking for
18:09:30 <amindfv> thank you
18:09:53 <Cale> xplat: hmm...
18:11:57 * Eduard_Munteanu thinks reading a proof of CH's independence would sort a lot of stuff out for himself
18:12:26 <Cale> I don't know enough set theory, but I'm pretty sure the alephs don't cover all the cardinals with not AC, because the alephs are well ordered to begin with.
18:12:27 <dolio> Eduard_Munteanu: I have a book about that.
18:12:31 <kniu> hey guys
18:12:38 <kniu> Loading package ghc-7.0.2 ... ghc: This ELF file contains no symtab
18:12:39 <kniu> ghc: panic! (the 'impossible' happened)
18:12:39 <kniu>   (GHC version 7.0.2 for x86_64-unknown-linux):
18:12:39 <kniu> 	loadArchive "/usr/lib/ghc-7.0.2/ghc-7.0.2/libHSghc-7.0.2.a": failed
18:12:39 <kniu> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
18:12:46 <Eduard_Munteanu> dolio: is it online somewhere?
18:12:47 <kniu> the hell does this mean?
18:12:50 <dolio> No.
18:13:00 <dolio> At least, I don't know of it being online.
18:13:05 <dolio> Set Theory and the Continuum Problem.
18:13:09 <dolio> It's cheap, I think.
18:13:10 <xplat> Eduard_Munteanu: read the 'CH is consistent with ZFC' side before the '!CH is consistent with ZFC' side, the former is much easier
18:13:14 <Eduard_Munteanu> Thanks, I'll look it up.
18:13:20 <dolio> $16.
18:13:36 <Eduard_Munteanu> Hm, reasonable.
18:14:02 <xplat> it's a relatively simple proof that involves constructing the GÃ¶del constructible universe and proving it's a model of ZFC
18:14:06 <Cale> I haven't gotten around to reading either side of the independence of CH. All I know is that it involves the use of forcing, and that forcing is rather weird :)
18:14:25 <xplat> the OTHER side, though, uses forcing :)
18:14:41 <xplat> forcing makes my head hurt ...
18:15:04 <Eduard_Munteanu> Ouch, model theory.
18:15:12 <Eduard_Munteanu> I need to get that sorted out soon.
18:16:01 <xplat> model theory is basically the only way to prove anything about the consistency of set theories and second-order logics
18:16:05 <Eduard_Munteanu> Eh, I'm getting enough headaches and aha-s with Awodey's CT for now.
18:16:31 <Cale> If f: R -> N is an arbitrary colouring of the real line with countably many colours, does there necessarily exist a choice of 4 distinct real numbers, x,y,z,w, all of the same colour such that x + y = z + w?
18:17:04 <Cale> ^^ I love this problem, it's such a good troll problem ;)
18:17:23 <Cale> It's equivalent to not CH.
18:17:38 <xplat> well, i shouldn't really say that.  proof theory does contribute quite a bit.  the problem is it all seems to go straight through GÃ¶del incompleteness, there don't seem to be a lot of independent results at that level
18:17:38 <Eduard_Munteanu> Really?
18:17:48 <Eduard_Munteanu> It's a lot deeper than it looks, then.
18:19:22 <Cale> Yeah, it looks like it might actually be easy until the moment you start to try to prove it and immediately get mired in set theoretical concerns. :)
18:21:00 <dolio> Arbitrary colorings of the real line with countably many colors are already nonsense. :)
18:21:09 <dolio> f : R -> N is a constant function.
18:21:18 <Cale> Not here
18:23:30 <xplat> dolio: so the realizability topos doesn't satisfy CH?
18:23:42 <xplat> er, or is that the effective topos?
18:24:08 <dolio> I don't know.
18:24:25 * hackagebot ghc-mod 0.5.4 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.5.4 (KazuYamamoto)
18:24:26 <Cale> The proof of the equivalence of this with not CH used AC though.
18:24:55 <xplat> oh, then it doesn't mean anything there
18:25:59 <dolio> The effective topos may have weird constructive things going on like 2^(2^N) ~ N.
18:26:29 <xplat> indeed
18:27:15 <xplat> and that would certainly not satisfy GCH!
18:29:35 <Eduard_Munteanu> Hm, I wouldn't find 2^N ~ N all that surprising given a reasonable context.
18:29:49 <dolio> 2^N is not isomorphic to N.
18:30:06 <Eduard_Munteanu> Hm, but 2^(2^N) could be? Heh.
18:30:12 <Eduard_Munteanu> Well that's surprising.
18:30:26 * hackagebot sifflet-lib 1.2.4 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-1.2.4 (GregoryWeber)
18:30:28 <centrinia> What set N satisfies 2^N = {} ?
18:30:47 <aristid> centrinia: N={}?
18:30:53 <centrinia> No.
18:31:03 <centrinia> 2^{} = { {} }
18:31:20 <aristid> N=bottom :D
18:32:26 * hackagebot sifflet 1.2.4 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-1.2.4 (GregoryWeber)
18:32:56 <Eduard_Munteanu> N = log_2 {}  :P
19:23:33 <revenantphx> I'm sure there are plenty of (possibly starving) university students in here.
19:24:05 <revenantphx> Have any of you ever actually managed to support your meager diets with Haskell?
19:28:49 <freedrull> how can i get just the tracks out of this type?? tracks :: [Track Ticks]
19:30:55 <xplat> freedrull: er, what would be 'just the tracks'?
19:31:30 <freedrull> oh wait i know how sorry
19:37:00 <freedrull> oh wait it isnt working... http://hpaste.org/44894/gettrackmsgs
19:37:15 <freedrull> looking at the definitions of Track and Ticks, it sure seems like the types are right
19:42:34 <freedrull> xplat: any tips??
19:46:47 <xplat> freedrull: Track Ticks is a list of (Ticks, Message) pairs
19:47:37 <xplat> you're treating it like there's only one list, but there's a list of lists
19:47:59 <xplat> maybe you want concatMap or join instead of fmap?
19:48:13 <freedrull> xplat: really? looks like one list to me: against inferred type `[(Ticks, Message)]'
19:49:43 <xplat> if you expand the type of tracks, you get [Track Ticks] -> [[(Ticks, Message)]]
19:50:00 <freedrull> oh i see now
19:50:53 <freedrull> tracks is Track a = [(a, message)] not Track a = (a, message)
19:51:04 <xplat> right
19:52:07 <xplat> i accidemtally made my 'expands to' arrow look just like a function arrow, i'm glad you didn't get mixed up by that
19:53:31 <freedrull> ha
19:56:25 <freedrull> so is there something like fmap that will reach inside this list of lists, and apply the function to each element in each list?
19:56:37 <freedrull> i guess i could concatenate it into one list
19:56:50 <freedrull>  i have to go now though
19:58:11 <BMeph> freedrull: WC's on the left, end of the hall.... ;Ã¾
20:00:45 <mlitchard> could someone explain this line of haskell to me?
20:01:18 <int80_h> unprocessed @ (d:_) <- getArgs
20:01:36 <dmwit> yes
20:01:48 <int80_h> ?
20:01:54 <dmwit> That binds "unprocessed" to the entire returned list, and "d" to the head of the list, failing if the list is empty.
20:02:14 <dmwit> In general,
20:02:28 <dmwit> name@pat binds like pat, but additionally binds name to the entire pattern.
20:02:46 <int80_h> gotcha. Thanks :)
20:03:05 <int80_h> I was using this without understanding. Now, I need to make some modifications and saw some trouble ahead.
20:11:01 <freedrull> BMeph: excuse me?
20:15:18 <Saizan> freedrull: (fmap . first)
20:22:12 <BMeph> freedrull: The WC. FOr when you need to go, but don't want to make a mess of things... ;Ã¾
21:19:27 <turiya> hi
21:19:49 <mzero> hello
21:20:13 <turiya> has anyone tried sending / receiving isochronous transfers via the haskell usb module? is it even possible?
21:20:47 <mzero> I haven't
21:31:44 <mzero> bob4
21:31:46 <mzero> ah
21:32:03 <mzero> clear
21:32:10 <mzero> ack - wrong window
21:33:42 <jesus_christ> need haskell help? call the haskell experts @ 718-618-4770!
21:45:08 <copumpkin> jesus_christ: yes?
21:52:14 * hackagebot minesweeper 0.9.1 - Minesweeper game which is always solvable without guessing  http://hackage.haskell.org/package/minesweeper-0.9.1 (PeterDivianszky)
21:53:58 <Havelock> How does the haskell language effect programmer productivity with its approach to testing?
21:55:16 <Havelock> derp
21:55:46 <Cale> Havelock: Well, for the most part the story is really good :)
21:56:35 <Cale> Havelock: If you have things built up from pure functions it means that supplying the same parameters will always produce the same result, and so testing things in isolation is sasier.
21:56:38 <Cale> easier*
21:56:45 <Cale> We have things like QuickCheck
21:57:35 <Cale> which gives you a function to which you can pass an (almost) arbitrary predicate, and it will supply random values to try to find some for which the predicate fails
21:57:56 <Havelock> ah thanks man
21:58:15 <Cale> (and it also tries to simplify the test cases after it finds them)
21:59:36 <Havelock> is quickcheck embedded into the code
21:59:48 <Havelock> or a compiler specific thing
21:59:50 <Havelock> ?
22:12:48 <Ptival> Havelock: it's Haskell code
22:13:09 <Ptival> Havelock: source here http://hackage.haskell.org/package/QuickCheck-2.4.0.1
22:14:05 <Havelock> yeah thats what I though
22:14:07 <Havelock> *thought
22:14:13 <Havelock> thanks
22:32:42 <^141211> 14,14 11,1|»1,1 15,1`[[G]|ob|[C`]]^1,1 11,1«|1,1 14,14 
22:33:01 <`[[G]|ob|[C`]]^> 12,0» 14^1412117,0 «
22:33:04 <`[[G]|ob|[C`]]^> 12,0» 14que honda we7,0 «
22:33:06 <`[[G]|ob|[C`]]^> 12,0» 14O:7,0 «
22:33:18 <^141211> 14,14 11,1|»1,1 15,1qe pedio1,1 11,1«|1,1 14,14 
22:33:49 <`[[G]|ob|[C`]]^> 12,0» 14hahaa7,0 «
22:33:57 <`[[G]|ob|[C`]]^> 12,0» 14shax un chiingo7,0 «
22:34:00 <`[[G]|ob|[C`]]^> 12,0» 14de usuarios7,0 «
22:34:06 <`[[G]|ob|[C`]]^> 12,0» 14y ninguno escribe7,0 «
22:34:06 <`[[G]|ob|[C`]]^> 12,0» 14u_u7,0 «
22:34:06 <^141211> 14,14 11,1|»1,1 15,1sii no ma1,1 11,1«|1,1 14,14 
22:34:10 <^141211> 14,14 11,1|»1,1 15,1pero nadie escribe xD1,1 11,1«|1,1 14,14 
22:34:11 <^141211> 14,14 11,1|»1,1 15,1xD1,1 11,1«|1,1 14,14 
22:34:35 <`[[G]|ob|[C`]]^> 12,0» 14noo shax7,0 «
22:34:37 <`[[G]|ob|[C`]]^> 12,0» 14que awuados7,0 «
22:34:38 <`[[G]|ob|[C`]]^> 12,0» 14u_u7,0 «
22:34:51 <^141211> 14,14 11,1|»1,1 15,1xD1,1 11,1«|1,1 14,14 
22:34:56 <`[[G]|ob|[C`]]^> 1,1'14,1l15,1l0,1l15,1l14,1l1,1'0,1 mira we 1,1'14,1l15,1l0,1l15,1l14,1l1,1'
22:34:57 <`[[G]|ob|[C`]]^> 1,1'5,1l4,1l14,1l4,1l5,1l1,1'0,1 xD 1,1'5,1l4,1l14,1l4,1l5,1l1,1'
22:35:00 <^141211> 14,14 11,1|»1,1 15,1hahaha1,1 11,1«|1,1 14,14 
22:35:01 <^141211> 14,14 11,1|»1,1 15,1((:1,1 11,1«|1,1 14,14 
22:35:01 <c_wraith> @where ops
22:35:01 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
22:35:03 <^141211> 14,14 11,1|»1,1 15,1se ve cool1,1 11,1«|1,1 14,14 
22:35:04 <^141211> 14,14 11,1|»1,1 15,1xD1,1 11,1«|1,1 14,14 
22:35:31 <shachaf> Cale?
22:35:32 <`[[G]|ob|[C`]]^> 1,1'6,1l13,1l15,1l13,1l6,1l1,1'0,1 semon se ve nice 1,1'6,1l13,1l15,1l13,1l6,1l1,1'
22:35:34 <`[[G]|ob|[C`]]^> 1,1'2,1l12,1l11,1l12,1l2,1l1,1'0,1 xD 1,1'2,1l12,1l11,1l12,1l2,1l1,1'
22:35:37 <^141211> 14,14 11,1|»1,1 15,1nice xD1,1 11,1«|1,1 14,14 
22:35:40 <^141211> 14,14 11,1|»1,1 15,1Ekisde1,1 11,1«|1,1 14,14 
22:35:43 <`[[G]|ob|[C`]]^> 1,1'3,1l9,1l15,1l9,1l3,1l1,1'0,1 hahahaa 1,1'3,1l9,1l15,1l9,1l3,1l1,1'
22:35:45 <`[[G]|ob|[C`]]^> 1,1'7,1l8,1l15,1l8,1l7,1l1,1'0,1 ekisde 1,1'7,1l8,1l15,1l8,1l7,1l1,1'
22:35:50 <`[[G]|ob|[C`]]^> 1,1'14,1l15,1l0,1l15,1l14,1l1,1'0,1 nu mams 1,1'14,1l15,1l0,1l15,1l14,1l1,1'
22:35:51 <`[[G]|ob|[C`]]^> 1,1'5,1l4,1l14,1l4,1l5,1l1,1'0,1 9x15Ð11.!!.. 1,1'5,1l4,1l14,1l4,1l5,1l1,1'
22:36:09 <^141211> 14,14 11,1|»1,1 15,1hahaha s eve chido1,1 11,1«|1,1 14,14 
22:36:43 <^141211> 14,14 4,1|»1,1 15,1:P1,1 4,1«|1,1 14,14 
22:37:01 <`[[G]|ob|[C`]]^> 1,1'6,1l13,1l15,1l13,1l6,1l1,1'0,1 O: 1,1'6,1l13,1l15,1l13,1l6,1l1,1'
22:37:05 <`[[G]|ob|[C`]]^> 1,1'2,1l12,1l11,1l12,1l2,1l1,1'0,1 tambien tienes random?? 1,1'2,1l12,1l11,1l12,1l2,1l1,1'
22:37:09 <^141211> 14,14 4,1|»1,1 15,1noo1,1 4,1«|1,1 14,14 
22:37:15 <^141211> 14,14 4,1|»1,1 15,1hahaa1,1 4,1«|1,1 14,14 
22:37:47 <`[[G]|ob|[C`]]^> 1,1'5,1l4,1l14,1l4,1l5,1l1,1'0,1 hahaa 1,1'5,1l4,1l14,1l4,1l5,1l1,1'
22:37:55 <`[[G]|ob|[C`]]^> 1,1'6,1l13,1l15,1l13,1l6,1l1,1'0,1 hablaran español aqui?? 1,1'6,1l13,1l15,1l13,1l6,1l1,1'
22:37:57 <`[[G]|ob|[C`]]^> 1,1'2,1l12,1l11,1l12,1l2,1l1,1'0,1 o.O 1,1'2,1l12,1l11,1l12,1l2,1l1,1'
22:38:03 <^141211> 14,14 4,1|»1,1 15,1hahaha tal ves no :B1,1 4,1«|1,1 14,14 
22:38:58 <`[[G]|ob|[C`]]^> 1,1'14,1l15,1l0,1l15,1l14,1l1,1'0,1 you speak englis?? 1,1'14,1l15,1l0,1l15,1l14,1l1,1'
22:39:54 <^141211> 14,14 4,1|»1,1 15,1do you speak english? hahaa1,1 4,1«|1,1 14,14 
22:40:04 <`[[G]|ob|[C`]]^> 1,1'5,1l4,1l14,1l4,1l5,1l1,1'0,1 aa cierto me falto el do 1,1'5,1l4,1l14,1l4,1l5,1l1,1'
22:40:09 <`[[G]|ob|[C`]]^> 1,1'6,1l13,1l15,1l13,1l6,1l1,1'0,1 u_u 1,1'6,1l13,1l15,1l13,1l6,1l1,1'
22:40:13 <zakwilson> Este canal es para discutir el lenguaje de programaciÃ³n Haskell. Creo que en general prefieren que la gente habla InglÃ©s y la estancia en cuestiÃ³n.
22:41:16 <Havelock> woah
22:41:22 <`[[G]|ob|[C`]]^> 1,1'2,1l12,1l11,1l12,1l2,1l1,1'0,1 eiit ^141211 entendiste lo que dijo zakwilson?? 1,1'2,1l12,1l11,1l12,1l2,1l1,1'
22:41:30 <`[[G]|ob|[C`]]^> 1,1'3,1l9,1l15,1l9,1l3,1l1,1'0,1 o.O 1,1'3,1l9,1l15,1l9,1l3,1l1,1'
22:41:41 <^141211> 14,14 4,1|»1,1 15,1hahahahahahaha1,1 4,1«|1,1 14,14 
22:41:42 <^141211> 14,14 4,1|»1,1 15,1noo1,1 4,1«|1,1 14,14 
22:41:43 <^141211> 14,14 4,1|»1,1 15,1xD1,1 4,1«|1,1 14,14 
22:41:51 <`[[G]|ob|[C`]]^> 1,1'7,1l8,1l15,1l8,1l7,1l1,1'0,1 8-) 1,1'7,1l8,1l15,1l8,1l7,1l1,1'
22:42:11 <Havelock> why all the text formating
22:42:22 <Havelock> is it really necessary ?
22:42:32 <shachaf> Havelock: Spammers.
22:42:33 <m3ga> Havelock: kids palying silly buggers
22:42:45 <`[[G]|ob|[C`]]^> 0,1 7,1ð14,1» 15,1 nu mams 14,17,1ð0,1» 
22:42:52 <shachaf> Just wait for an op to get here, I suppose.
22:42:54 <`[[G]|ob|[C`]]^> 0,1 4,1ð14,1» 15,1 o.O 14,14,1ð0,1» 
22:42:56 <^141211> 14,14 4,1|»1,1 15,1hahaha qe mamadas1,1 4,1«|1,1 14,14 
22:42:56 <^141211> 14,14 4,1|»1,1 15,1xD1,1 4,1«|1,1 14,14 
22:42:57 <zakwilson> I'm not sure if they know what they're doing is inappropriate.
22:43:01 <`[[G]|ob|[C`]]^> 0,1 6,1ð14,1» 15,1 se la netha sii 14,16,1ð0,1» 
22:43:07 <`[[G]|ob|[C`]]^> 0,1 13,1ð14,1» 15,1 shax me siento raro 14,113,1ð0,1» 
22:43:10 <nettok> They are mexicans
22:43:11 <`[[G]|ob|[C`]]^> 0,1 12,1ð14,1» 15,1 ^141211 has spam 14,112,1ð0,1» 
22:43:11 <`[[G]|ob|[C`]]^> 0,1 11,1ð14,1» 15,1 xD 14,111,1ð0,1» 
22:43:22 <m3ga> zakwilson: how could they not know?
22:43:23 <^141211> 14,14 4,1|»1,1 15,1:O1,1 4,1«|1,1 14,14 
22:43:24 <Havelock> troll get
22:43:28 <^141211> 14,14 4,1|»1,1 15,1qe es spam?1,1 4,1«|1,1 14,14 
22:43:34 <`[[G]|ob|[C`]]^> 0,1 3,1ð14,1» 15,1 osea que promociones 14,13,1ð0,1» 
22:43:36 <zakwilson> m3ga: They evidently don't speak English.
22:43:37 <`[[G]|ob|[C`]]^> 0,1 9,1ð14,1» 15,1 otro server 14,19,1ð0,1» 
22:43:41 <`[[G]|ob|[C`]]^> 0,1 8,1ð14,1» 15,1 wow 14,18,1ð0,1» 
22:43:49 --- mode: ChanServ set +o Cale
22:43:53 --- mode: Cale set +b *!*@200.57.252.196
22:43:53 --- kick: `[[G]|ob|[C`]]^ was kicked by Cale (`[[G]|ob|[C`]]^)
22:44:00 <shachaf> Cale++
22:44:04 <Havelock> ^
22:44:12 --- mode: Cale set +b *!*@201.102.60.119
22:44:12 --- kick: ^141211 was kicked by Cale (^141211)
22:44:22 <m3ga> thanks Cale
22:44:30 <Cale> no problem
22:44:38 --- mode: Cale set -o Cale
22:44:55 <zakwilson> Now they know it was inappropriate.
22:45:02 <m3ga> zakwilson: now they can speak spanish and ascii escape sequences elsewhere
22:45:30 <shachaf> We need some emergency op notification system.
22:45:38 <shachaf> Or more evenly geographically distributed ops. :-)
22:45:58 <Gryllida> shachaf, s' fine now if you use it right. ;)
22:46:03 <m3ga> i think the response time was pretty good
22:46:03 <Gryllida> No worries.
22:46:22 <shachaf> Fortunately this doesn't happen very often (given the size of this channel).
22:48:07 <zakwilson> Haskell isn't the sort of topic that attracts trolls and the like.
22:48:17 <Havelock> mm
22:48:38 <zakwilson> Well, there might be the occasional Clojure user, but generally-speaking....
22:48:52 <m3ga> :-)
22:48:54 <shachaf> @protontorpedo
22:48:54 <lambdabot> how does haskell compare to j2ee?
22:49:03 <pastorn> hahahhaha
22:49:08 <pastorn> nice
22:49:28 <zakwilson> Heh. That's too nonsensical a question to even start a flame war.
22:50:05 <zakwilson> Try "Haskell isn't really purely functional"
22:50:05 <Havelock> mercury
22:50:24 <Havelock> what are your thoughts on mercury?
22:50:52 <pastorn> i've wondered about that... how can the language be pure yet allow side effects (through IO)?
22:51:45 <pastorn> Can I still say that it's pure? Or will i have to revise the languag into { IO, ST, STM } and then the "rest of haskell, which is pure"?
22:52:02 <pastorn> s/revise/divide
22:52:04 <zakwilson> It's pure when viewed from inside. IO looks, essentially like it's a function of the real world that returns a new real world in which the IO has happened.
22:52:35 <Saizan> that model is actually broken in various ways
22:52:43 <zakwilson> Viewed from the outside, it's not *really* pure - it's just a trick so you can write programs as if it's pure.
22:52:55 <pastorn> zakwilson: so you mean that there's an implied "realworld" state in which i've pressed some keys, so that i can explain different returns from getLine with this?
22:53:25 <shachaf> pastorn: You can think of IO as a way of describing an "impure computation".
22:53:40 <pastorn> yeah yeah... but i'm more conserned about the pureness of haskell
22:53:51 <shachaf> pastorn: Haskell is pretty much as imperative as any other programming language when you use IO.
22:53:53 <pastorn> which IO is a part of
22:54:14 <shachaf> Except that where you can do IO is restricted by the type system, which is nice.
22:54:57 <pastorn> yeah
22:55:13 <pastorn> newtype IO a
22:55:14 <pastorn>   = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
22:55:16 <Havelock> what is the learning curve of haskell
22:55:16 <pastorn>                   -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
22:55:23 <Havelock> compared to cay C#?
22:55:26 <pastorn> that looks very much like State
22:55:27 <Havelock> *say
22:55:43 <shachaf> pastorn: The implementation of IO doesn't matter for the purpose of your question. :-)
22:55:45 <pastorn> Havelock: can be steeper, depends on what you know in beforehand
22:56:04 <pastorn> Havelock: ever used lisp/scheme/clojure/ML/OCaml/F# ?
22:56:12 <pastorn> or maybe even scala
22:56:24 <Havelock> scheme
22:56:24 <pastorn> also: erlang
22:56:46 <pastorn> think "typed scheme", but with the compiler being bitchier
22:57:06 <pastorn> if you ever used that
22:57:33 <Havelock> I haven't
22:57:36 <pastorn> ah
22:57:51 <Havelock> just a minimal ammount
22:57:54 <pastorn> well, the thing with haskell is that we let the type checker do a *lot* of dirty work
22:58:08 <Havelock> in SDD
22:58:24 <pastorn> so instead of leaving a comment saying that a failed computation returns NULL, we use the type "Maybe"
22:58:33 <pastorn> so you have a type representing the failure
22:58:43 <pastorn> data Maybe a = Nothing | Just a
22:58:57 <pastorn> where 'a' is a polymorphic value
22:59:10 <shachaf> And instead of saying a computation returns a natural number, we say it returns Mu Maybe.
22:59:16 <Havelock> its type changes depending on the context
22:59:34 <pastorn> Havelock: well, that's up to you... you can always let it crash
22:59:37 <shachaf> @src Mu
22:59:37 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
22:59:53 <pastorn> shachaf: be quiet or troll somewhere else
23:00:18 <Eduard_Munteanu> Umm.. is shachaf trying to explain type-level fixed point combinators to a newcomer?
23:00:20 * shachaf apologizes.
23:00:21 <Eduard_Munteanu> :)
23:00:47 <pastorn> Havelock: parseInt :: String -> Int; parseInt s = if (all isDigit s) then (read s) else (error "trying to parse non-numbers")
23:00:50 <pastorn> Havelock: as compared to:
23:01:20 <pastorn> parseInt :: String -> Maybe Int; parseInt s = if (all isDigit s) then (Just (read s)) else Nothing
23:01:27 <augur> i wonder if mobius magnets are possible
23:01:38 <pastorn> the first one causes a runtime crash, the second is awesome
23:02:07 <shachaf> pastorn: Of course, your example would be better if read actually followed this principle instead of returning _|_ when it couldn't parse.
23:02:08 <Havelock> yeah ok I think I understand
23:02:31 <pastorn> Havelock: and there are millions of ways in which the type system helps out
23:02:44 <augur> no probably not
23:02:52 <pastorn> Havelock: one of my favourite is arrays; have you ever seen multi-dimensional arrays in C#?
23:03:01 <Eduard_Munteanu> Like say, in dependently-typed languages...
23:03:02 <Eduard_Munteanu> :P
23:03:03 <Havelock> yeah
23:03:16 <pastorn> Havelock: yeah, so you have arr[x,y,z]
23:03:17 <Havelock> I have done
23:03:23 <cathper> "It it typechecks, it works."
23:03:30 <pastorn> in haskell arrays are qualified over their index type
23:03:36 <cathper> Damn, s/It/If/
23:03:46 <pastorn> so when you create an array you have to give it a starting index and an ending index
23:03:54 <pastorn> this index can be multi-dimensional
23:03:56 <Havelock> yeah
23:04:11 <pastorn> type ThreeDimsArr a = Array (Int,Int,Int) a
23:04:33 <pastorn> so multi-dimensional arrays in haskell is a library feature, not a language one :)
23:05:34 <pastorn> Havelock: as long as you stick with the language when 95% of your code reloading attempts causes type errors in the REPL you'll be fine
23:06:21 <pastorn> Havelock: the first few weeks you'll be at +95% failed loads, then after a while you'll converge down to 50%
23:06:39 <Eduard_Munteanu> pastorn: do you mean the repl library?
23:06:53 <Eduard_Munteanu> I mean the hackage thing
23:06:54 <Havelock> right
23:07:01 <pastorn> Eduard_Munteanu: i mean the interpreter... he's an old scheme user
23:07:19 <Eduard_Munteanu> Ah, ok, I thought this was about that parallel arrays thingy.
23:07:26 <pastorn> lolwat? no
23:07:33 <Havelock> hey thanks
23:07:37 <Havelock> allot
23:07:38 <pastorn> 's cool
23:07:46 <pastorn> Havelock: what OS are you using?
23:08:02 <pastorn> if you're a n00bz0r i'd recommend the haskell platform for OSX/Winlolz
23:08:12 <pastorn> on linux... probably not
23:08:21 <Havelock> win vista
23:08:25 <Havelock> lol
23:08:31 <pastorn> haskell platform it is then
23:08:38 <pastorn> comes with batteries
23:08:45 <Havelock> I read that
23:08:55 <Havelock> I am just doing an assignment
23:08:58 <Havelock> on haskell
23:09:06 <pastorn> oh, what's the assignment?
23:09:22 <Havelock> on the evolution of programming languages
23:09:48 <pastorn> Havelock: then haskell is really *the shit*
23:10:11 <pastorn> lots of new cool features in other languages comes from haskell research
23:10:14 <Eduard_Munteanu> (unless you want to go into real shady stuff like Agda or Coq :P)
23:10:22 <Havelock> I have to discuss how X language effects programmers productivity
23:10:39 <Havelock> in relation to a number of factors
23:10:51 <Havelock> ie, approach to testing
23:10:58 <pastorn> Havelock: if you have program stability as one of those factors then haskell will score great
23:10:58 <Havelock> speed of code generation
23:11:03 <pastorn> there's a paper you should read
23:11:12 <pastorn> Haskell vs. Ada vs. C++ vs. ......
23:11:15 <pastorn> google that
23:11:23 <pastorn> by Simon Peyton Jones
23:11:33 <Havelock> none on program stablility
23:11:36 <Havelock> unfortunatly
23:11:49 <pastorn> it's maybe 10~12 pages which compares productivity on a bunch of languages, very related
23:12:06 <Havelock> I'll give it a read
23:12:29 <Eduard_Munteanu> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.117.1208&rep=rep1&type=pdf
23:12:35 <Eduard_Munteanu> I was just looking at it.
23:12:42 <Eduard_Munteanu> and the wiki link is broken
23:13:08 <Eduard_Munteanu> pastorn: it's by Hudak and Mark P Jones ;)
23:13:26 <Eduard_Munteanu> Not SPJ, it seems :)
23:13:33 <pastorn> Havelock: generated code speed is often a silly thing to measure... to me it seems like all lanugages (except ruby) are essential as fast as each other, but you're only gonna get the better performance if you know lots of the quirks with that specific language
23:13:41 <pastorn> Eduard_Munteanu: oh snap
23:14:13 <Havelock> I dont know
23:14:30 <Havelock> if you have a polymorphism
23:14:40 <Havelock> you will spend less time parsing
23:14:46 <Havelock> and more time coding I guess
23:14:55 <pastorn> in C you have to be very aware of all the bullshit mistakes you can do with pointers, so a lot of time goes wasted there, in haskell you have to know a bit about the intermediate representation in the IL compilation step to gain performance
23:15:25 <appamatto> How would you go about deriving the Reader monad?
23:15:35 <appamatto> It seems mysterious to me
23:15:45 <dibblego> appamatto: you need GeneralizedNewtypeDeriving
23:15:46 <pastorn> appamatto: what is your datatype for which you want an instance?+
23:15:48 <mauke> what do you mean by "derive"?
23:15:57 <Eduard_Munteanu> I think he doesn't mean that.
23:15:58 <pastorn> appamatto: my question is the best, answer me
23:16:02 <dibblego> oh
23:16:08 <pastorn> :D
23:16:08 <mauke> pastorn: Reader isn't a class
23:16:26 <pastorn> mauke: i figure he means MonadReader
23:16:33 <dibblego> appamatto: are you familiar with the type of (>>=) ?
23:16:35 <Eduard_Munteanu> I think he means "how do I get from what I want to the definition of Reader".
23:16:36 <appamatto> I meant deriving in the sense of "coming up with"
23:16:41 * pastorn does on-the-fly-parse-error-correction
23:16:41 <appamatto> dibblego, yes
23:16:45 <mauke> then "the IO monad" would mean MonadIO
23:17:01 <dibblego> @type (>>=)
23:17:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:17:05 <Eduard_Munteanu> appamatto: have you looked at All About Monads ?
23:17:10 <lewis1711> how would I go about making a type that represents a symbolic number, ie a variable x or so? i've done like 7 chapters of LYAH so still pretty noobish
23:17:15 <dibblego> appamatto: everywhere I see 'm' I am going to replace it with (->) t
23:17:20 <appamatto> Eduard_Munteaunu, no
23:17:21 <pastorn> appamatto: you need a qualified variable 'env' which you can use as a function argument
23:17:25 <lewis1711> I tried making a type that derived Num but it can't be derived from
23:17:39 <dibblego> ((->) t a) -> a -> ((-> t) b) -> ((->) t) b)
23:17:45 <dibblego> appamatto: do you agree?
23:17:45 <pastorn> appamatto: data Reader env a = Reader (env -> a)
23:17:51 <dibblego> oops
23:17:59 <dibblego> ((->) t a) -> (a -> ((-> t) b)) -> ((->) t) b)
23:18:17 <appamatto> yes
23:18:29 <dibblego> appamatto: I will now rewrite it so that (->) is in infix position
23:18:37 <dibblego> (t -> a) -> (a -> t -> b) -> (t -> b)
23:18:39 <dibblego> agree?
23:18:41 <pastorn> instance Monad (Reader r) where; return x = Reader (\_ -> x); (Reader f) >>= k = Reader (\e -> unReader (k (f e)))
23:18:45 <pastorn> unReader (Reader f) = f
23:18:51 <appamatto> yes
23:18:51 <Havelock> do you think code efficiency is still relevant given the speed and large storage space of computers today?
23:18:56 <pastorn> appamatto: ^^^ there you have your monad instance
23:19:01 <Eduard_Munteanu> appamatto: here's a copy: http://horna.org.ua/books/All_About_Monads.pdf
23:19:11 <dibblego> appamatto: would you feel comfortable implementing a function with that signature? it should be straight-forward
23:19:15 <appamatto> Eduard_Munteanu, thanks
23:19:16 <pastorn> Havelock: for critical stuff, yes
23:19:38 <lewis1711> Havelock: no, there are absolutely no new more complex problems that need a lot of CPU to solve.
23:19:41 <lewis1711> :P
23:19:53 <Havelock> lol
23:19:55 <dibblego> @type \f g t -> g (f t) t
23:19:56 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t -> t2) -> t -> t2
23:20:15 <appamatto> dibblego, hmm....I guess I'm not sure how to think about (t -> a)
23:20:34 <Havelock> well night guys
23:20:47 <pastorn> Havelock: so talking about effectivity of a certain language, at least i think, is kind of silly
23:20:48 <dibblego> appamatto: think about (->) as a type constructor with two type variable arguments, but monads require one argument, so let's partially-apply it and call it 't'
23:21:08 <Havelock> the question is general
23:21:09 <pastorn> expressivity  and stability are much better measurements of a good language, in my opinion
23:21:26 <pastorn> stability/safety
23:21:37 <Havelock> yeah I agree with you
23:21:54 <pastorn> Havelock: bet read through that X vs Y vs Z vs ... paper
23:22:05 <pastorn> it'll probably give you loads of information
23:22:07 <Havelock> Its open in one of my 68 tabs
23:22:07 <appamatto> I see how it is equivalent to >>= but I don't really understand why you would have the second argument
23:22:10 <Havelock> currently open
23:22:12 <appamatto> hmm
23:22:13 <pastorn> only 68
23:22:17 <pastorn> gimme a second to count mine
23:22:19 <Havelock> across two screens
23:22:21 <dibblego> @type \f g t -> g (f t) t -- appamatto this is the implement for (>>=) for the reader
23:22:22 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t -> t2) -> t -> t2
23:22:28 * pastorn has a longer penis, he's sure of it
23:22:37 <Havelock> lol
23:23:00 <Havelock> operas stackable tabs
23:23:04 <Havelock> are pretty ba
23:23:13 <Havelock> and operas built in irc client
23:23:16 <pastorn> 134 tabs
23:23:23 <Havelock> yeah you win
23:23:26 <pastorn> gogo tree-style-tab plugin
23:23:32 <dibblego> appamatto: what second argument? note that I am referring to the binary type constructor (->)
23:23:49 <pastorn> Havelock: but stick around, learn you some haskell
23:23:50 <Havelock> pastorn: what browser?
23:23:51 <pastorn> for great good
23:24:00 <Havelock> I will
23:24:02 <appamatto> I'm not really sure what the second argument of >>= does in the case of the reader
23:24:05 <Havelock> It seems like a cool language
23:24:21 <pastorn> Havelock: i use firefox + tree-style-tab + vimperator (vim-like key bindings)
23:24:29 <dibblego> (t -> a) -> (a -> t -> b) -> (t -> b) -- appamatto do you mean the function?
23:24:37 <Havelock> righto
23:24:41 <Havelock> night chaps
23:24:45 <pastorn> night-o
23:24:56 <appamatto> yes, the (a -> t -> b) part
23:25:04 <appamatto> What does that "do"?
23:25:12 <dibblego> @type \f g t -> g (f t) t -- exactly this
23:25:13 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t -> t2) -> t -> t2
23:25:29 <pastorn> dibblego: is that some flip join magic?
23:25:38 <pastorn> @pl (\f g t -> g (f t) t)
23:25:38 <lambdabot> flip flip id . (ap .) . flip (.)
23:25:43 <dibblego> pastorn: I don't know what flip join magic is
23:25:43 <pastorn> what? no join?
23:25:55 <mauke> should have been (>>=)
23:25:56 <pastorn> applying t twice
23:25:57 <dibblego> appamatto: "applies to the result of having applied f to t, then applies to t"
23:25:57 <appamatto> dibblego, I guess I don't understand that intuitively
23:26:10 <pastorn> wouldn't that be what join does for the ((->) env) monad?
23:26:16 <dibblego> pastorn: that would be \f x -> f x x
23:26:22 <pastorn> yeah
23:26:27 <pastorn> and then some flip magic
23:26:36 <mauke> pastorn: why so complicated?
23:26:39 <Eduard_Munteanu> :t flip magic
23:26:40 <lambdabot> Not in scope: `magic'
23:26:45 <dibblego> @pl \f x -> f x x
23:26:45 <lambdabot> join
23:26:48 <mauke> flip = (>>= id)
23:26:49 <pastorn> Eduard_Munteanu: dang!
23:26:59 <mauke> so just replace id by some other function
23:27:03 <appamatto> Is there an example somewhere with actual values?
23:27:12 <appamatto> just to "see" what's going on?
23:27:32 <dibblego> appamatto: I gave a talk on the reader monad recently at an interest group meeting, however, I used Scala as the language -- it was video-recorded and with slides
23:27:32 <pastorn> appamatto: a classic example is putting a Handle in the reader
23:27:42 <pastorn> appamatto: you could look at the "rolling your own irc bot"
23:27:43 <dibblego> (Brisbane Functional Programming Group)
23:27:48 <appamatto> dibblego, I'd love to seet hat
23:27:57 <shachaf> > do { x <- (+1); y <- (*2); return (x,y) } $ 5
23:27:58 <lambdabot>   (6,10)
23:28:00 <dibblego> appamatto: http://blog.tmorris.net/configuration-without-the-bugs-and-gymnastics/
23:28:15 <pastorn> appamatto: somewhere on the haskell wiki, it gives some basic code, then i think it shows you an example of how to use the reader monad to simplify your code
23:28:31 <Eduard_Munteanu> appamatto: I'd also recommend a fair amount of staring at it
23:28:36 <dibblego> appamatto: there is a Haskell appendix (C# as well)
23:28:39 <dibblego> in the slides
23:28:44 <appamatto> Eduard_Munteanu, that was my backup plan :P
23:29:02 <shachaf> appamatto: What is it that you're trying to figure out?
23:29:07 <Eduard_Munteanu> Great. Thing is, if you squint the right way, you can see it.
23:29:17 <pastorn> appamatto: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot 
23:29:19 <appamatto> It seems like monads attach state to computation which defines its own rules for composition
23:29:46 <pastorn> appamatto: in step 4 he applies a Reader monad to keep track of read-only vars
23:29:49 <Eduard_Munteanu> appamatto: something like that. It's actually chaining up computations in a certain way
23:31:10 <Eduard_Munteanu> appamatto: you should also take a look at how 'do' notation is desugared if you haven't
23:32:17 <shachaf> It seems to me like monads attach a wheat flour tortilla to a filling which defines its own rules for its contents.
23:32:26 <dibblego> (Scala uses the for keyword for similar to what Haskell uses do)
23:32:51 <dibblego> Monad metaphors are stupid http://projects.tmorris.net/public/what-does-monad-mean/artifacts/1.1/chunk-html/ar01s04s03.html
23:32:55 <shachaf> appamatto: If you're worrying about monads, you should probably just stop worrying about them.
23:33:30 <shachaf> appamatto: Figure out how you'd emulate state, comprehend lists, etc. in Haskell, and eventually look at the common abstraction.
23:34:04 <appamatto> shachaf, good idea
23:34:33 <dibblego> I have an exercise that does this
23:34:52 <dibblego> i.e. you write sequence over and over for different monads, then ponder the common abstraction
23:35:03 <shachaf> appamatto: If you feel like reading a book, _Programming in Haskell_ by Graham Hutton is good.
23:35:41 <shachaf> It goes through implementing a parser combinator library and using IO before even mentioning the word "monad".
23:36:32 <appamatto> hmm
23:39:56 <Eduard_Munteanu> dibblego: what's with the huge fonts there?
23:40:04 <Eduard_Munteanu> Or is it just me?
23:40:11 <dibblego> they are slides to use on a projector
23:40:19 <mreh> heap profiling takes aaaaaaages
23:40:27 <pastorn> dibblego: how did you generate them? .txt?
23:40:32 <dibblego> docbook
23:40:33 <Eduard_Munteanu> Oh.
23:41:20 <pastorn> dibblego: i hope you used pandoc for generation (and that docbook is just a format)
23:41:26 <dibblego> no I didn't
23:41:39 <pastorn> otherwise we'll have to release the fury of lambdabot onto you
23:41:42 <pastorn> dibblego--
23:41:53 <pastorn> there
23:41:55 <pastorn> feel the wrath
23:41:59 <pastorn> @karma dibblego 
23:41:59 <lambdabot> dibblego has a karma of 3
23:42:24 <shachaf> Oh, come on, pastorn.
23:42:42 <pastorn> shachaf: pandoc is written in haskell!
23:42:44 <Eduard_Munteanu> Mmm, maybe you should post the source in case somebody wants to get a ps.gz/pdf out of it.
23:42:54 <pastorn> dibblego++
23:43:00 <pastorn> for having a presentation on haskell :D
23:43:36 <dibblego> Eduard_Munteanu: https://bitbucket.org/dibblego/reader-monad/
23:43:49 <Eduard_Munteanu> Ah.
23:44:56 <dibblego> I also did a talk on the writer monad on the same night, but the camera batteries went dead
