00:03:50 <manateeUser> 好吧，让我告诉我的很酷的功能。
00:26:01 <johnw> I'm using cmdArgs.  How do I just print out the help that --help would have displayed?  I used to use cmdArgsHelp, but that appears to do something different in the latest version
00:28:58 * hackagebot pool 0.0.1.1 - Thread-safe resource pools.  http://hackage.haskell.org/package/pool-0.0.1.1 (MichaelSnoyman)
01:11:04 * hackagebot xml-enumerator 0.2.1.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.2.1.1 (MichaelSnoyman)
01:14:35 <btutt> @hoogle identifier
01:14:35 <lambdabot> Text.Html identifier :: String -> HtmlAttr
01:14:35 <lambdabot> Text.Parsec.Token identifier :: GenTokenParser s u m -> ParsecT s u m String
01:14:35 <lambdabot> Text.XHtml.Frameset identifier :: String -> HtmlAttr
01:36:58 <Kaidelong> ddarius: in the paper, he mentions not having runtime errors, but since it relies on arbitrary functions C and C# I don't think this is actually true?
01:38:18 <Kaidelong> also (|>) and (||>) themselves could just hit runtime failures
01:42:30 <Jonno_FTW> :t (<*>)
01:42:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:42:40 <Jonno_FTW> @src (<*>)
01:42:40 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:18:33 <akamaus> does anybody know any ssh client haskell library?
02:23:12 <rtharper> akamaus: there's the ssh library...
02:24:44 <ManateeLazyCat> Hi all. :)
02:24:44 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
02:24:54 <akamaus> rtharper, are you speaking about http://hackage.haskell.org/package/ssh? Package description says it's a library for ssh servers
02:25:07 <rtharper> akamaus: Aye, that's all I know of
02:26:00 <ManateeLazyCat> BONUS: Are you there?
02:27:32 <rtharper> Speaking of which, see I see there's two xmpp libs
02:27:36 <rtharper> anyone written a server with them?
02:27:43 <rtharper> there are*
02:34:04 <BONUS> ManateeLazyCat: hey! you caught me at the right time, i just turned on my computer
02:34:04 <lambdabot> BONUS: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:38:37 <ManateeLazyCat> BONUS: Can i build-in your "Learn You A Haskell For Great Food!.pdf" in my pdf viewer?
02:39:01 <sipa> ManateeLazyCat: it's for great "Good", not great "Food"
02:39:16 <BONUS> haha great food
02:39:17 <ManateeLazyCat> sipa: Oh, typo.
02:39:21 <BONUS> what do you mean build-in?
02:39:54 <ManateeLazyCat> BONUS: I have integrated system (Manatee), have a pdfviewer, just like this : http://www.flickr.com/photos/48809572@N02/5496671763/lightbox/
02:40:18 <ManateeLazyCat> BONUS: Now, when user click "Real World Haskell" 's snapshot, will open pdfviewer to read "Real World Haskell"
02:40:38 <BONUS> oh!
02:40:39 <BONUS> yeah sure
02:41:02 <ManateeLazyCat> BONUS: But i want to use your book instead "Real World Haskell", your book is small and easy to understand for haskell newbie.
02:41:18 <BONUS> haha very cool, yeah sure
02:42:01 <ManateeLazyCat> BONUS: Do you have any book cover? I want to use it as snapshot.
02:42:21 <BONUS> yeah it's on www.nostarch.com/lyah.htm
02:43:05 <ManateeLazyCat> BONUS: Have Bigger one?
02:46:41 <ManateeLazyCat> Hmm, i have a "Learn You A Haskell For Great Good!.pdf" but no cute iconography in book.
02:47:20 <ManateeLazyCat> BONUS: Free version pdf haven't iconography?
02:48:43 <BONUS> ManateeLazyCat: if you click on the preview it opens up a really big
02:48:48 <BONUS> image
02:49:02 <BONUS> http://nostarch.com/sites/default/files/imagecache/product_full/lyah.png
02:49:15 <BONUS> iconography? what do you mean?
02:49:23 <BONUS> you mean like pictures?
02:49:56 <ManateeLazyCat> BONUS: Yes
02:50:36 <ManateeLazyCat> BONUS: I download pdf from http://nostarch.com/download/haskell_toc.pdf , it just have text, haven't picture like http://learnyouahaskell.com/introduction
02:56:08 <ManateeLazyCat> BONUS: PDF just have 10 chapters? 
02:56:57 <BONUS> ManateeLazyCat: i sent you a private msg <.9
02:57:00 <BONUS> :)
03:09:44 <nff> BONUS! I just bought your book, it is awesome. I'm glad the PDF has color illustrations, the preview only shows black & white images.
03:13:01 <accel> what book?
03:13:33 <nff> www.nostarch.com/lyah.htm
03:13:44 <accel> for great good!
03:17:33 <Jonno_FTW> I should really get around to finishing reading lyah
03:23:39 <jpcooper> hello
03:24:02 <jpcooper> could anyone tell me how to connect to domain sockets with the Network library?
03:25:24 <jpcooper> also is UnixSocket meant to work on Windows?
03:26:06 <jpcooper> aah I see that the hostname should be the path and the port number should be -1
03:34:59 <ezyang> Is there an easy way to get the binary representation of a Double? 
03:35:57 <ziman> Data.Binary, I suppose?
03:36:30 <ezyang> doesn't seem to support doubles 
03:36:44 <ezyang> I guess I'll bust out GDB or something... 
03:36:47 <Jafet> Easy for the computer or easy for the programmer?
03:37:05 <ezyang> Both. 
03:37:30 <Jafet> No cutting knots here
03:37:39 <Jafet> What about Storable?
03:39:24 <ezyang> I got it with GDB, thanks though :_) 
03:40:24 <Jafet> That sounds like a "neither" to me
03:41:32 <ezyang> There is a certain advantage to C's ability to cast willy-nilly :-) 
03:41:59 <sipa> unsafeCoerce does the same
03:42:18 <maurer_> sipa: Not if the Double happens to be boxed.
03:43:07 <mauke> ezyang: that can be done with Storable
03:44:12 <ezyang> I didn't feel like allocating 8 bytes of memory to poke the value into, though ^_^ 
03:44:35 <maurer_> ezyang: What are you trying to do with the double's binary form?
03:44:40 <Saizan>  /win 23
03:46:55 <ezyang> I wanted to verify that my double was, in fact, accidentally overwritten by a pointer. 
03:47:20 <ezyang> which is hard to see if you get 2.477224917334285e-269, but very easy to see if you have 0x0 0x82a2c91 
03:48:22 <maurer_> ezyang: Why were you writing pointers manually? Other than the FFI, there's no real reason to be mucking about with them.
03:48:36 <ezyang> Bug in the code generator :-) 
03:51:10 <mauke> % perl -wle 'printf "%v02X\n", pack "d", 2.477224917334285e-269'
03:51:10 <mauke> FC.FF.FF.FF.90.2C.2A.08
03:53:52 <Jafet> That's perl high on C's ability to cast willy-nilly.
03:53:56 <ezyang> mmm endianness 
04:08:19 <ManateeLazyCat> @tell BONUS: I have build-in "Learn You A Haskell" in my pdf viewer, I just include first 20 pages (Content and Introduction), if Manatee user like your book, they will buy it. :)
04:08:19 <lambdabot> Consider it noted.
04:10:44 <rsuniev__> Noob question: In this function divide x ys = foldM (./.) x ys what "(./.)" means. Why division operation wrapped in "."?
04:11:06 <sipa> :t (./.)
04:11:06 <lambdabot> Not in scope: `./.'
04:11:24 <ziman> rsuniev__, it is a completely new operator called ./., not a slash wrapped in dots
04:12:44 <rsuniev__> It's hard to g/hoogle. What's this operator?
04:14:02 <sipa> rsuniev__: where did you get that code?
04:14:21 <Saizan> try hayoo
04:14:23 <rsuniev__> http://members.chello.nl/hjgtuyl/tourdemonad.html
04:14:33 <demolithion> > let (b,c) = (1,c)
04:14:33 <lambdabot>   not an expression: `let (b,c) = (1,c)'
04:14:45 <rsuniev__> foldM defnintion
04:14:52 <Saizan> rsuniev__: it's defined there
04:15:32 <Saizan> rsuniev__: the three lines of code above the definition of divide are defining the (./.) operator
04:16:24 <demolithion> > let (b,c) = (\(x,y)->(y,x)) (1,c)
04:16:25 <lambdabot>   not an expression: `let (b,c) = (\(x,y)->(y,x)) (1,c)'
04:16:42 <rsuniev__> Saizan: Ah I see. I though it's part of the lang.
04:17:31 <sipa> rsuniev__: the language defines no operators
04:17:42 <ManateeLazyCat> @tell BONUS Here is screenshot : http://www.flickr.com/photos/48809572@N02/5576791304/lightbox/ .
04:17:42 <lambdabot> Consider it noted.
04:18:43 <Saizan> sipa: it defines (:) 
04:19:53 <Jafet> That's not an operator!
04:20:36 <quicksilver> Num is part of the language, and therefore the language defines (+),(-) etc.
04:20:51 <sipa> if you consider the prelude part of the language, yes
04:20:56 <ManateeLazyCat> Hmm, BONUS's book is really good stuff, i will read it again.
04:21:28 <ManateeLazyCat> Ok, eat some food, and watch "Battlestar Galactica S2"
04:21:29 <quicksilver> sipa: no.
04:21:36 <quicksilver> sipa: even if you don't Num must be part of the language.
04:21:48 <quicksilver> sipa: it's required to interpret "f 0 = 1"
04:22:19 <quicksilver> however, personally, I consider the haskell report to define the language and that makes it pretty clear than Num is in scope anyway.
04:22:38 <sipa> ok
04:23:13 <DRMacIver> And of course the language defines >>= and >> in order for do notation to make sense.
04:23:13 <demolithion> > let (a,b) = (\(x,y)->(y,x)) (1,b) in a
04:23:14 <lambdabot>   1
04:24:18 <demolithion> i tottaly don't get how this is evaluated, could someone point me to something to read? 
04:24:29 <Saizan> (:) has the additional property that you can't even define another operator with the same name
04:35:50 <frerich> demolithion : Hm, that's strange.
04:36:48 <frerich> > let (a,b) = (\(x,y)->(y,x)) (1,b) in a
04:36:49 <lambdabot>   1
04:36:53 <frerich> > let (a,b) = (\(x,y)->(y,x)) (1,2) in a
04:36:54 <lambdabot>   2
04:37:00 * frerich blinks
04:38:26 <Jafet> Since (a,b) = (b,a) = (1,b), to evaluate a, evaluate b.
04:39:06 <Jafet> @where stepeval
04:39:06 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
04:40:17 * frerich bookmarks
04:40:30 <Jafet> Hm, not implemented.
04:41:00 <demolithion> Jafet: Wow that was easier than expecteded. :(
04:41:25 <Jafet> Eh, what did you expetect?
04:41:26 <adorablepuppy> How do I get data from an IO [Word8]?
04:42:10 <Jafet> There's no data, just a recipe for getting data
04:42:13 <demolithion> Jafet: I don't know i've just been thinking about that way to long i guess. 
04:42:26 <Jafet> Run the recipe and it might provide data.
04:45:58 <applicative> adorablepuppy: what data do you want.  
04:46:01 <applicative> @type Data.ByteString.pack
04:46:01 <lambdabot> [Word8] -> BSC.ByteString
04:46:17 <Saizan> adorablepuppy: if (m :: IO [Word8]) you can compose that with another function ([Word8] -> IO Something) with (>>=) 
04:46:37 <Saizan> adorablepuppy: so that in "m >>= \x -> .." x has type [Word8]
04:46:45 <applicative> @type fmap Data.ByteString.pack
04:46:45 <lambdabot> forall (f :: * -> *). (Functor f) => f [Word8] -> f BSC.ByteString
04:46:57 * hackagebot regex-pderiv 0.1.0 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pderiv-0.1.0 (KennyLu)
04:47:10 <Jafet> @quote IO.String
04:47:10 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
04:47:14 <Saizan> adorablepuppy: or you could use do notation, which is just syntax sugar for the above: "do x <- m; ..."
04:47:37 <Saizan> adorablepuppy: http://www.haskell.org/haskellwiki/Monads_as_computation <- for more
04:48:00 <applicative> adorablepuppy: It isn't clear whether the problem is the IO-ness or the [Word8]-ness
04:51:37 <adorablepuppy> sorry, gtg. Can't elaborate
04:51:40 <ezyang> Huh, you can use <- in guards. 
04:51:44 <ezyang> useful. 
04:52:26 <Twey> Only in pattern guards
04:52:33 <Twey> {-XPatternGuards}
04:52:53 <Twey> {don't know why I used flower brackets there — maybe I meant to write a pragma}
04:53:04 <Twey> {-# LANGUAGE PatternGuards #-}
04:53:40 <Jafet> {You call these "flower" brackets?}
04:53:48 <mercury^> I was about to comment on that.
04:53:53 <mercury^> It's a beautiful name for them.
04:54:02 <Jafet> {Must have a nicer font than I do.}
04:54:24 <flux> I render all IRC with LaTeX.
04:54:25 <applicative> (these are flower brackets) , {these are meat brackets}
04:54:42 <flux> (well, not really, but maybe someone does!)
04:57:55 <cNoNim> hi all
04:58:34 <kstt> hello !
04:59:42 <rdnflaneur> \quit
05:01:37 <kstt> Does anybody here believe that a simple Haskell program can proxy a TCP connection with a bandwith of 100MB/s without loading the CPU ?
05:02:13 <kstt> Such a simple TCP proxy is the cornerstone of my new project, and I'm currently stuck at this point.
05:02:24 <flux> I would believe that. most of the work (copying bytes) would be done with system calls anyway.
05:02:44 <flux> maybe you could try with a simpler server
05:02:49 <quicksilver> 100MB/s without loading the CPU at all, I doubt.
05:02:50 <flux> say, an echo server
05:03:27 <kstt> quicksilver: flux: hi. A few cycles a acceptable. But CPU saturation is not :)
05:03:44 <maurer_> kstt: Look into TCP offload engines.
05:04:01 <maurer_> kstt: 100 MB/s is a large amount of traffic to be able to push without loading a core.
05:04:34 <maurer_> kstt: Though there is some kernel fuckery you could do to make this work if you had a card with a TCP offload engine
05:04:51 <maurer_> Cards can be told to DMA incoming packets for certain connections to certain areas of memory, to act as a queue for the process to read
05:04:57 <maurer_> Cards can have packets DMA'd into them
05:05:06 <kstt> I managed to get a TCP proxy, based on EventMachine, to proxy 100Mb/s without loading too much the cpu
05:05:28 <maurer_> How much is "too much"?
05:05:33 <kstt> ( without saturation )
05:05:49 <maurer_> Oh sure, you're going to avoid saturation, but you're still going to get load
05:05:59 <Jafet> That's a whole gigabit link, none-stop
05:06:05 <kstt> But with my haskell implementation, I can't avoid saturation, even at a few MB/s.
05:06:11 <Jafet> Or did you mean 100Mb/s?
05:06:18 <maurer_> If you want this load free, you have to trick the card into DMAing into itself and handling the TCP for you, which is a tricky proposition
05:06:20 <Jafet> Er, non-stop
05:06:34 <kstt> This implementation is highly based on Chris Done throttle package : https://github.com/chrisdone/throttle/blob/master/src/Main.hs
05:06:37 <maurer_> kstt: Using ByteStrings?
05:06:43 <maurer_> err, Bytestring
05:06:44 <kstt> Just simplified, no option, no switch.
05:06:57 <kstt> No throtling
05:07:32 <kstt> maurer_: TCP offload is interesting indeed ! 
05:08:01 <kstt> But I'd rather go as far as possible with a software (haskell) solution.
05:08:02 <beate> Hello! Is there a way to do _qualified_ imports in an interactive _ghci_ session?
05:08:09 <maurer_> kstt: But if the load given by another program is good enough, why not just use that?
05:08:22 <maurer_> kstt: Alternatively, build your haskell app with profiling, and give us a profiling dump
05:10:11 <kstt> maurer_: EventMachine requires explicit asynchronous programming, in Ruby. And like everybody sane in this world, I prefer preemptive concurrency handled by the RTS and forkIOs directives.
05:11:00 * hackagebot constructive-algebra 0.3.0 - A library of constructive algebra.  http://hackage.haskell.org/package/constructive-algebra-0.3.0 (AndersMortberg)
05:11:03 <kstt> profiling is definitly on my todo_list but I'm not experienced with that, and it seems to require to rebuild a large part of my cabal packages with appropriate flags. Any comprehensive tutorial around here ?
05:12:12 <DeeKay> hi! I'm a haskell n00b facing some difficulty with ghci - is this the right place to ask?
05:13:37 <aristid> DeeKay: this, or #haskell-beginners (i think that's the name)
05:14:07 <Botje> DeeKay: ask away
05:15:05 <jlouis> kstt: it is essentially just asking GHC to give profiling output and then staring at it 
05:15:33 <dcoutts> kstt: mainly, you just need to build packages with the -p / --enable-library-profiling flag
05:15:54 <kstt> Packages, and dependencies I guess ?
05:17:01 <DeeKay> Okay... I'll just ask here: this is the paste of the code I'm trying
05:17:06 <DeeKay> http://hpaste.org/45174/pattern_matching_basics
05:17:40 <DeeKay> The first 2 lines get loaded cleanly by ghci but when I try putting in the general case, I get an error stating pattern failed to compile
05:17:46 <alex_____> hi
05:18:13 <DeeKay> the intent is to convert a list like [1,2,3,4] to [(1,2), (3,4)]
05:18:25 <kstt> DeeKay: use parens around your pattern
05:20:20 <DeeKay> it worked!
05:20:21 <DeeKay> thanks
05:21:13 <DeeKay> Q2: Is there a place where I can get the operator precedence table for Haskell? Q3: If I had to create a groupn version of this code, I'd not be able to create the tuple via pattern matching
05:21:19 <DeeKay> How do I go about doing that?
05:22:29 <beate> Can someone please help me out on doing QUALIFIED module-imports in ghci?
05:22:42 <aristid> Q2: just type the operator names into :info
05:22:43 <aristid> :info +
05:22:45 <aristid> :info *
05:23:07 <jix> DeeKay: also in haskell application binds stronger than any operator
05:23:15 <aristid> all in ghci. then you could numbers in lines like infixl 1 $
05:23:24 <kstt> DeeKay: you'd do that like in any language that can't pattern match structure : you would count elements and accumulate tham.
05:23:31 <aristid> these numbers specify the precedence :)
05:25:08 <DeeKay> okay - just tried out the :info code 
05:25:34 <aristid> > (\n -> unfoldr (\s -> case splitAt n s of (a,s') | length a == n -> Just (a, s'); _ -> Nothing)) 3 [1..10]
05:25:35 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
05:25:52 <DeeKay> @kstt - when you say accumulate them - how can I do that since I can't append to tuples?
05:25:52 <lambdabot> Unknown command, try @list
05:26:11 <aristid> DeeKay: use lists instead of tuples?
05:26:22 <DeeKay> kstt - when you say accumulate them - how can I do that since I can't append to tuples?
05:26:27 <Axman6> DeeKay: we tend to use name: instead of @name on irc
05:27:12 <DeeKay> Axman6: okay. Thanks for the tip
05:27:12 <jix> DeeKay: you can't use tuples if you don't know the length in advance, but as aristid already said you can use lists
05:29:04 <kstt> DeeKay: indeed, I missed that point. You can probably consider that tuples are for pattern matching only, and pattern matching is a compile-time feature. IOW, its size is handled by the programmer. For structures whose size are handled by the program, use lists.
05:30:10 <Axman6> I'm not sure i agree with any of that...
05:30:29 <aristid> Axman6: consider it all a useful lie ;)
05:30:40 <frerich> DeeKay: I'm a Haskell beginner myself, too, but two things came to my mind while looking at your 'group2' function. First, you could  actually simplify the 'group []' and 'group [x1]' definitions to 'group _ = []' since if 'group x1:x2:xs' does not match then it means that the list has less than two elements. Second, you could simplify '[(x1,x2)] ++ (group2 xs)' to '(x1,x2) : group2 xs' (and that's a tiny bit more efficient, too, I believe).
05:31:12 <aristid> frerich: group _ = [] has to be the last definition :)
05:31:14 <DeeKay> I'm trying to grok artistid's code... it's probably going to take some time since I'm not yet comfortable with Just and Nothing but thanks for the code fragment
05:31:20 <kstt> dcoutts: I got that immediatly :  Could not find module `Data.ByteString.Char8', Perhaps you haven't installed the profiling libraries for package `bytestring-0.9.1.5'?
05:31:43 <kstt> I really don't know how to build from end to end a profiling-enabled executable
05:31:54 <frerich> DeeKay: Oh yeah, and what aristid said - if you use 'group _' then it has to be the last defintiion so that it's only considered after the 'x1:x2:xs' pattern was tested.
05:31:55 <kstt> without handling dependencies manually
05:32:05 <dcoutts> kstt: so then the annoying bit is chasing down the packages that need to be rebuilt with profiling
05:32:09 <DeeKay> frerich: okay. Got your point. The base case would initiate the list building process and I can use cons to build the list.
05:32:36 <dcoutts> kstt: if you're using ghc from a distro, e.g. debian, you can get the profiling versions of the library packages
05:33:01 <kstt> dcoutts: so the Right Thing To Do is : cabal install bytestring -p  ?
05:33:02 <dcoutts> kstt: ones installed via cabal need to be reinstalled, cabal install foo bar -p --reinstall
05:33:21 <maurer_> kstt: Otherwise, set the flag "library-profiling" in your .cabal/config to True and reinstall it
05:33:38 <maurer_> kstt: You might want to keep that flag set, so you automatically have profiling stuff available in the future
05:33:38 <kstt> ok, thanks both !
05:33:40 <frerich> DeeKay: Yep
05:34:14 <applicative> > let preDeeKay n xs = case splitAt n xs of (a,xs') | length a == n -> Just (a, xs'); _ -> Nothing in let deeKay n xs = unfoldr (preDeeKay n) xs in deeKay 3 "Margaret, are you grieving?"
05:34:15 <lambdabot>   ["Mar","gar","et,"," ar","e y","ou ","gri","evi","ng?"]
05:34:57 <aristid> > (\n -> unfoldr (\s -> case splitAt n s of (a,[]) | length a == n -> Just (a, []) | otherwise -> Nothing; (a,s') -> Just (a, s'))) 3 [1..10]
05:34:57 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
05:35:12 <aristid> (the check is only necessary on the last element)
05:37:12 <__yhvh__> so I'm reading Problem 38 http://www.haskell.org/haskellwiki/Euler_problems/31_to_40
05:37:35 <__yhvh__> and got a type error from read
05:38:11 <__yhvh__> I fixed it by defining rInt::String ->Int, is there a better or more inline way?
05:39:56 <hpc> __yhvh__: change read to (read :: String -> Int)
05:40:17 <luite_> __yhvh__: you could also add a type sig to problem_38 :: Integer
05:40:23 <hpc> or that
05:40:24 <aristid> applicative: but i wonder if there's a nicer way to do this. :)
05:40:30 <DeeKay> artistid and applicative: I'm getting what you're trying to do, but I don't get how you're skipping the n elements consumed in unfoldr
05:40:45 <applicative> __yhvh__ that's the best way.  it needed a bit some type information.   you can also shut off the monomorphism restriction.  
05:41:09 <aristid> monomorphism restriction :(
05:41:18 <__yhvh__> luite_'s way is 'best'
05:41:19 <applicative> ... a bit more type information ...
05:41:21 <__yhvh__> ?
05:41:31 * hpc doesn't recommend getting hooked on extensions this early in your haskell career
05:41:51 <aristid> the monomorphism was introduced as a dirty way to address shortcomings in compilers, and i do not think it was ever really worth it :)
05:41:56 <aristid> +restriction
05:41:58 <applicative> luite_ 's way is best
05:42:19 <hpc> aristid: does that shortcoming still exist?
05:42:36 <hpc> aristid: or is the restriction now totally obsolete?
05:42:41 <aristid> hpc: i'm not sure. maybe. i don't really know how ghc deals with polymorphic constants these days.
05:43:28 <quicksilver> well it's about expectations of sharing.
05:43:49 <aristid> quicksilver: and the compiler COULD do sharing, with a few tricks :)
05:43:52 <quicksilver> the point is that x = (...very complicated expression with most general type Num a => a ... )
05:44:21 <quicksilver> would not be shared in the GHC implementation of typeclasse.s
05:44:39 <aristid> so said shortcoming is not addressed
05:44:40 <quicksilver> it's definitely strange to link a language feature to a very specific implementation choice
05:45:03 <quicksilver> especialyl when the haskell report doesn't actually mandate sharing anyway.
05:45:11 <applicative> _yhvh_ the type of problem_38, without further information is problem_38 :: (Read c, Ord c) => c  which is a bit abstract ... 
05:45:15 <quicksilver> although parts of the report imply sharing.
05:45:56 <applicative> _yhvh_ so if you add the more specific "problem_38 :: Integer", suddenly ghci will know what you're up to
05:47:22 <__yhvh__> applicative: :: Int worked, is Integer more specific?
05:47:33 <applicative> they are equally specific
05:47:41 <applicative> > maxBound :: Int
05:47:42 <lambdabot>   9223372036854775807
05:47:42 <hpc> __yhvh__: Integer is the set of integers; Int is machine integers
05:47:52 <__yhvh__> k
05:47:58 <applicative> > 9223372036854775807 + 9223372036854775807 :: Integer
05:47:58 <lambdabot>   18446744073709551614
05:48:04 <applicative> > 9223372036854775807 + 9223372036854775807 :: Int
05:48:04 <lambdabot>   -2
05:48:06 * hackagebot xml-enumerator 0.2.1.2 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.2.1.2 (MichaelSnoyman)
05:48:35 <Axman6> > 2^10283 :: Int
05:48:36 <lambdabot>   0
05:48:39 <Axman6> > 2^10283 :: Integer
05:48:40 <lambdabot>   310059764415292250518479069183133458709471656376918753535818607107764652052...
05:49:21 <applicative> inside ghci, the tendency is to default to Integer when it is clueless what you are talking about. 
05:50:31 <Dudleyy> hi, does anybody here works with HXT?
05:51:11 <Veinor> occasionally, what's your question?
05:51:24 <Dudleyy> i'm having a weird problem
05:51:25 <__yhvh__> and I take it Int is 32/63 bit sensitive, and internally Integers are Ints until they go beyond the maxbound?
05:51:31 <Dudleyy> i can't import one of the modules
05:51:35 <Veinor> which?
05:51:36 <Dudleyy> (the core module)
05:51:42 <Dudleyy> and i gess that wasn't suppose to happen
05:52:01 <Veinor> how are you importing it, and what error are you getting? could you pastebin/hpaste it?
05:52:17 <opqdonut> __yhvh__: actually, an Int is only guaranteed to be ~29 bits or so
05:52:31 <applicative> __yhvh__ yes, I have a much bigger maxBound :: Int this week than last :)
05:52:34 <opqdonut> __yhvh__: (to leave implementations the option of using tag bits)
05:52:44 <Dudleyy>  Could not find module `Text.XML.HXT.Core'
05:52:47 <Veinor> how big are ghc's ints?
05:53:09 <Veinor> Dudleyy: are you sure hxt is installed?
05:53:14 <Botje> "grow your maxBound in WEEKS! I tried $SPAMMY_PRODUCT and enlarged by maxBound by 3 bits!"
05:53:27 <ezyang> Veinor: machine-size 
05:53:37 <opqdonut> > logBase 2 . fromIntegral $ (maxBound :: Int)
05:53:39 <lambdabot>   63.0
05:53:41 <opqdonut> yep
05:53:43 * vegai is immediately jealous to Botje for getting to Haskell Weekly
05:54:06 <applicative> for a while I had my old ghci still running, and opened the new one, and had two different answers to maxBound :: Int.  A crime against 'referential transparency'!
05:55:35 <aristid> applicative: did you call the functional police?
05:56:01 <applicative> aristid no, I just enjoyed it while it lasted
05:57:23 <applicative> I considered that maxBound :: Int was a 'refreshing desert in the oasis of referential transparency'
05:57:28 <applicative> @quote oasis
05:57:28 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
05:58:20 <DRMacIver> Quote very much endorsed. I've found Debug.trace invaluable recently.
06:01:51 <Veinor> Debug.trace is very nice, yes
06:02:02 <Daerim> Would you consider haskell suited as a scripting language? Or, rather, do you use it as such yourself?
06:02:15 <hpc> Daerim: do CGI scripts count?
06:02:24 <applicative> @type Debug.Trace.trace "This definitions is terrible"
06:02:25 <lambdabot> forall a. a -> a
06:02:32 <applicative> awesome
06:02:47 <hpc> > Debug.Trace.trace "this is silly" 5
06:02:48 <lambdabot>   Not in scope: `Debug.Trace.trace'
06:02:50 <hpc> :(
06:02:58 <hpc> @let trace = const id
06:02:59 <lambdabot>  Defined.
06:03:01 <Veinor> trace uses unsafeperformio, I believe
06:03:09 <hpc> > trace 
06:03:10 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a -> a)
06:03:10 <lambdabot>    arising from a use...
06:03:12 <hpc> er
06:03:12 <Daerim> seems every time I use it as such, I end up with a hulking monster of code that does way more than what I needed. But also took me longer, than, say a python script
06:03:19 <hpc> > trace "oh look at me!" 5
06:03:21 <lambdabot>   5
06:03:38 <Daerim> hpc, I'm not sure? Do they? 
06:03:41 <applicative> "oh look at me"
06:04:23 <hpc> Daerim: as far as shell scripts go, i prefer .sh files
06:04:27 <hpc> or in a pinch, perl
06:04:49 <swarmer_ab> i wonder why people consider using static strongly typed language as script language
06:05:03 <applicative> whats wrong with runhaskell ? It makes me so happy.  
06:05:17 <Daerim> swarmer_ab, lambdabot told me it was suitable ;)
06:05:17 <opqdonut> swarmer_ab: why not? with type inference it's quite painless
06:05:21 <swarmer_ab> haskell is cool , of course, but different instruments are for different purposes
06:05:47 <opqdonut> lines + words + read will get you a long way
06:05:48 <byorgey> and untyped languages are for scripting? no thanks.
06:06:01 <hpc> opqdonut: yep
06:06:13 <opqdonut> but I've gone back to using awk, lately
06:06:18 <applicative> swarmer_ab:  http://donsbot.wordpress.com/2010/08/17/practical-haskell/
06:06:30 <opqdonut> or rather, I've bumped into problems that have very natural awk solution
06:06:31 <opqdonut> s
06:06:37 <opqdonut> and I've forgotten my perl :)
06:06:42 <swarmer_ab> um
06:06:51 <swarmer_ab> well, 'strongly' was a mistake
06:07:01 <opqdonut> explicitly?
06:07:08 <Daerim> swarmer_ab, on a more serious note, I need to go from scripting to something larger with reasonable performance quite often. Nice when you don't have to start from scratch
06:08:33 <Dudleyy> Hello, does anybody works with HXT?
06:09:43 <Veinor> it's not an hxt problem, it's a problem with cabal, i think
06:10:47 <Dudleyy> i see
06:14:42 <applicative> Dudleyy: does "ghc-pkg list HXT" show anything?
06:17:17 <Peaker> What replaces datetime for base>=4 ?
06:17:23 <DeeKay> aristid and applicative: groupn n l = unfoldr (\s -> let (a, s') = splitAt n s  in if length a == n then Just (a, s') else Nothing) l
06:18:01 <DeeKay> is this faster or slower than your versions?
06:18:03 <aristid> DeeKay: have you tried writing a recursive version first?
06:18:16 <aristid> it's probably slower than my version, but i did not test.
06:18:32 <DeeKay> aristid: recursive version of?
06:19:11 * hackagebot tls-extra 0.1.4 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.1.4 (VincentHanquez)
06:20:03 <Daerim> hpc, but is this because of haskell, or because of missing libraries to make it effective?
06:20:24 <hpc> Daerim: i think libraries
06:20:31 <chris_> hey, does anyone know how to quit ghci when im in termianl
06:20:36 <chris_> terminal*
06:20:41 <ezyang> :quit 
06:20:45 <sipa> ctrl-d
06:20:45 <ezyang> ^D 
06:21:00 <hpc> Daerim: the language is extremely flexible; if you want a script that does X, you can write it in so many styles
06:21:01 <Guest57869> thats a lot
06:21:03 <Guest57869> :quit worked
06:21:18 <Axman6> who uses ^D o.O
06:21:31 <hpc> i only use ^D to detach screen
06:22:08 <Daerim> hpc, heh yes. That's what makes mastering it so difficult. 
06:22:24 <aristid> DeeKay: instead of using unfoldr.
06:23:14 <Dudleyy> applicative: do you work with HXT?
06:23:56 <Daerim> hpc, but thanks. I'll try giving the whole thing more thought.
06:25:03 <applicative> Dudleyy, no, but it seems plain that HXT either isn't installed or maybe you have more than one ghc, so the one you're getting doesn't know about it, or something like that
06:25:11 * hackagebot xml-enumerator 0.2.1.3 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.2.1.3 (MichaelSnoyman)
06:25:55 <applicative> Dudleyy: how else to explain the error Could not find module `Text.XML.HXT.Core'  Or is that still the problem?
06:26:15 <Dudleyy> the problem is that the packages are correctly installed
06:26:24 <DeeKay> aristid: I'm trying right now
06:26:26 <Dudleyy> i could import any module of HXT
06:26:31 <Dudleyy> (arrow module, for example)
06:26:53 <applicative> wait, maybe it is not exported
06:27:10 <Veinor> applicative: http://pastebin.com/t61Aeqc0
06:27:22 <applicative> no that's nonsense
06:27:53 <Veinor> his problem is that he has 8.5.2, 9.0, and 9.1 installed, and only 8.5.2 is importable for whatever reason, and 8.5.2 doesn't have Text.XML.HXT.Core
06:28:05 <aristid> DeeKay: and optimally, you'd also try a version without splitAt. just so you understand every piece of the puzzle :)
06:28:47 <applicative> Oh i see.  Has he over written the original network package?  
06:29:11 <Dudleyy> applicative: i don't know
06:29:45 <applicative> Dudleyy: when you do 'cabal install' is it installing globally? 
06:29:57 <Dudleyy> applicative: yes
06:30:25 <Dudleyy> applicative: i think i have done something wrong here, i'll try to rebot my machine and brb
06:30:27 <applicative> Dudleyy: I see, this is dangerous, at least if you are as inept at keeping track of things as I am
06:31:08 <Dudleyy> applicative: my problem was that i couldn't import the Core module, but all the other modules was ok to import
06:31:44 <Dudleyy> applicative: now i unregistered some HXT packages and installed different versions
06:32:22 <Dudleyy> applicative: but i think i made something wrong when i remove the 8.5.2 version
06:32:23 <DeeKay> aristid: groupn' n l  | length l < n = []  | otherwise = let (a, s') = splitAt n l in [a] ++ groupn' n s'
06:32:50 <DeeKay> I guess a cons based modification to the "otherwise" case could also be done
06:33:03 <aristid> DeeKay: that's probably a lot slower :)
06:34:46 <DeeKay> aristid: Okay. On second evaluation, I understand why (multiple length checks) - but I don't see how to speed it up
06:35:47 <aristid> DeeKay: you always check the length of the ENTIRE list. this is unnecessary.
06:39:55 <DeeKay> aristid: groupn'' n l len  | len < n = []  | otherwise = let (a, s') = splitAt n l in a:(groupn'' n s' (len-n)) - using my old C/C++ instincts
06:40:14 <DeeKay> where the call is groupn'' n l length l
06:40:41 <Axman6> (length l)
06:40:51 <Axman6> the length is unnecessary though
06:41:05 <DeeKay> Axman6: Yes - (length l)
06:41:29 <aristid> DeeKay: if you DIRECTLY translate your old unfoldr version, you should get a relatively reasonable version
06:41:43 <aristid> (still not optimal, but better)
06:41:51 <aristid> @src unfoldr
06:41:51 <lambdabot> unfoldr f b  = case f b of
06:41:51 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
06:41:51 <lambdabot>    Nothing        -> []
06:42:37 <Peaker> The email of Malcolm Wallace at york (specifies in the cpphs metadata) is not working.. any idea how to contact him or send a patch?
06:42:40 <randomwords> Is this an acceptable place to get help with cabal package build failures, or is there a more suitable channel?
06:45:13 * hackagebot base-unicode-symbols 0.2.1.4 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.1.4 (RoelVanDijk)
06:45:18 <randomwords> If anyone has any ideas: http://hpaste.org/45177/hmp3_build_failure , it would be appreciated.
06:46:20 <aristid> random thought of the hour: i think haskell might make a good basis to develop a next-generation database</end of randomness>
06:46:36 <mercury^> What is the reason for unfoldr not really saving you any typing while foldr does?
06:47:01 <kalven> aristid: why?
06:47:23 <hpc> @src unfoldr
06:47:23 <lambdabot> unfoldr f b  = case f b of
06:47:23 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
06:47:23 <lambdabot>    Nothing        -> []
06:47:33 <hpc> mercury^: i don't know either
06:47:35 <aristid> kalven: because you can express concepts like Monoids more easily than in other languages :)
06:48:04 <aristid> mercury^: probably because you first need to convert your stuff into a Maybe?
06:51:01 <mercury^> aristid: yes, but that is not a satisfying answer.
06:52:29 <doserj> mercury^: because you have to provide a function that does 3 things at once?
06:52:34 <DeeKay> aristid: You're talking about: groupn n l = unfoldr (\s -> let (a, s') = splitAt n s  in if length a == n then Just (a, s') else Nothing) l
06:52:45 <aristid> DeeKay: yes.
06:53:09 <mercury^> doserj: still not satisfying.
06:53:43 <DeeKay> So, you're asking me to remove the unfoldr from this definition to optimize?
06:53:49 <Saizan> (Maybe (a,b) -> b) ~ (() -> b , (a,b) -> b) ~ (b , a -> b -> b); does (b -> Maybe (a,b)) simplify that nicely?
06:55:04 <aristid> :t let unfoldr2 f b = f (\a new_b -> a : unfoldr f new_b) b in unfoldr2
06:55:05 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b -> [a]
06:55:05 <lambdabot>     Probable cause: `f' is applied to too many arguments
06:55:05 <lambdabot>     In the expression: f (\ a new_b -> a : unfoldr f new_b) b
06:55:17 <aristid> :t let unfoldr2 f b = f (\a new_b -> a : unfoldr2 f new_b) b in unfoldr2
06:55:18 <lambdabot> forall a t. ((a -> t -> [a]) -> t -> [a]) -> t -> [a]
06:57:19 <kstt> hi !
06:58:01 <brisbin> would if (foldl (||) False [True, False, False]) then... "short circuit"?
06:58:13 <Layla_91> helo community ^_^
06:58:18 <brisbin> wait i think i know how to test
06:58:19 <Axman6> no, foldl can't short circuit
06:58:24 <kstt> dcoutts: you advised me to profile my tiny proxy. It is now done and both the code and the figures are here : http://hpaste.org/45178/proxy_tcp_and_profile
06:58:24 <Veinor> right
06:58:36 <Axman6> if you need short circuiting, you have to use foldr
06:58:39 <Axman6> @src foldl
06:58:39 <lambdabot> foldl f z []     = z
06:58:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:58:41 <Axman6> @src foldr
06:58:41 <lambdabot> foldr f z []     = z
06:58:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:58:46 <brisbin> cool, i can use fldr
06:58:49 <brisbin> foldr, that will?
06:58:58 <brisbin> oic
06:59:22 <kstt> I would appreciate some help reading these profiling figures : http://hpaste.org/45178/proxy_tcp_and_profile . In particular, I'd like to understand if the cost associated to ignore reveals a problem, or not. 
07:00:13 <brisbin> > foldr (||) False [True, undefined, undefined]
07:00:13 <lambdabot>   True
07:00:15 <brisbin> noice
07:00:31 <Axman6> you're not an aussie are you?
07:00:38 <brisbin> no, i'm not from brisbane
07:01:00 <Axman6> shame
07:01:20 <brisbin> indeed
07:01:22 <Axman6> kstt: why not just use _ <- to ignore the returned value?
07:01:35 <gspr> I'm wondering a bit about how to think about functional memoization. http://stackoverflow.com/questions/4980102/how-does-data-memocombinators-work/4980838#4980838 seems to be a very clear explanation, but as far as I can tell it involves being able to "open up"/"get inside" the data structure that stores the memoized values. In my situation, I'd like to memoize functions over Int. Thus, I feel I should use an array to store the memoized values. 
07:01:35 <gspr> However, I don't want to re-implement arrays or vectors - I'd like to wrap them instead. How should I attack memoization then? Does anybody have any good starting points?
07:01:35 <hpc> or just not use <- at all
07:01:43 <hpc> _ <- is a noop
07:01:50 <Axman6> but then ghc whinges!
07:01:53 <Axman6> annoyingly
07:01:57 <Eliel> kstt: is that ignore necessary there at all?
07:02:21 <hpc> also, notice the number of times "ignore" is entered
07:02:44 <gspr> (By "open up" and "get inside" in the above, I essentially mean that the SO answer effectively re-implements the storage structure when implementing the memoization. I'd like to re-use a preexisting array structure)
07:03:25 <kstt> Axman6: Eliel : this code is not from me actually, I just annotated it with SCC, trying to understand why this simple TCP proxy eats all my CPU. I'm rewriting it as you advised, thanks, more figures soon.
07:03:43 <kstt> (and thx hpc)
07:04:20 <kstt> and I somewhat missed that this 'ignore' was not from a 3rd party library ... sorry.
07:06:01 * Axman6 -> sleep
07:07:06 <Athas> I an writing an evaluator for a standard C-ish imperative, procedural language.  What would be a good way to handle returns such as return/break/continue?  Execution in the Error monad?
07:07:14 <Athas> Writing the evaluator in CPS?
07:07:57 <DeeKay> aristid: groupni n [] = [] groupni n l = let (a,s) = splitAt n l in a : (groupni n s) groupn''' n l = let r = groupni n l in if ((length $ last r) == n) then r else init r
07:08:15 <aristid> DeeKay: woah, getting ever more complex
07:08:25 <DeeKay> (idea being - test just the last element produced from the splitAt list)
07:08:42 <aristid> DeeKay: but yeah, that avoids unnecessary length checks and in that way is similar to my version
07:08:45 <DeeKay> (for the size == or /= n)
07:09:00 <aristid> > (\n -> unfoldr (\s -> case splitAt n s of (a,[]) | length a == n -> Just (a, []) | otherwise -> Nothing; (a,s') -> Just (a, s'))) 3 [1..10]
07:09:00 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
07:09:32 <aristid> DeeKay: i use the fact that splitAt returns [] in the second tuple element when the list is exhausted
07:10:01 <aristid> @src splitAT
07:10:01 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:10:01 <kstt> Eliel: hpc: now it is simpler  : http://hpaste.org/paste/45178/proxy_tcp_and_profile_annotat#p45179 . Now, 100% of cost is associated to 'start'. But it is not broken down into pieces, so I don't know where to go from here :)
07:10:02 <aristid> @src splitAt
07:10:02 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
07:10:24 <DeeKay> aristid: okay... actually this was the first task I'd put myself to on Haskell. I didn't understand the case structure you were using, so I started off creating my own bits
07:12:17 <DeeKay> aristid: okay!! Now I'm starting to get the pattern matching you've used.
07:12:24 <aristid> DeeKay: that's actually better. :) this way you understand it all better
07:13:01 <Peaker> datetime is not available for GHC 7 (base<4), what replaces it?
07:13:25 <Peaker> datetime depends on base<4 that is
07:15:11 <aristid> @let let unfoldr2 f b = f (\a new_b -> a : unfoldr2 f new_b) b
07:15:11 <lambdabot>   Parse error: ;
07:15:18 <aristid> @let unfoldr2 f b = f (\a new_b -> a : unfoldr2 f new_b) b
07:15:19 <lambdabot>  Defined.
07:15:44 <aristid> > (\n -> unfoldr2 (\f s -> case splitAt n s of (a,[]) | length a == n -> f a [] | otherwise -> []; (a,s') -> f a s')) 3 [1..10]
07:15:46 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
07:16:09 <aristid> mercury^: what do you think, is this better than the original unfoldr version?
07:16:25 <Saizan> ?type unfoldr2
07:16:26 <lambdabot> forall a t. ((a -> t -> [a]) -> t -> [a]) -> t -> [a]
07:17:56 <aristid> what's the name of that? is this a CPS transformation?
07:18:20 <Peaker> how do I convert seconds to UTC time?
07:18:57 <aristid> Peaker: time can do that.
07:19:31 <aristid> Peaker: http://hackage.haskell.org/packages/archive/time/1.2.0.4/doc/html/Data-Time-Clock-POSIX.html
07:20:56 <Peaker> aristid, thanks!
07:23:22 * hackagebot AspectAG 0.3.2 - Attribute Grammars in the form of an EDSL  http://hackage.haskell.org/package/AspectAG-0.3.2 (MarcosViera)
07:24:18 <Eliel> kstt: the time is most likely going into the functions inside start.
07:24:32 <Eliel> those are not included in the profiling by default.
07:24:37 <kstt> Eliel: yes, I got some more details with SCCs
07:24:53 <kstt> recv and send consumes all the time
07:25:42 <kstt> which is expected actually, but there is a bug somewhere that I'm trying to fix
07:26:30 <kstt> namely, after proxying a connection, it enters into an infinite loop and eats all the cpu
07:26:35 <Saizan> aristid: it's related to church encoding the Maybe (a,t) of the original unfoldr, and church encoding is a CPS version of datatypes
07:26:50 <Saizan> (t -> Maybe (a,t)) ~ (t -> forall r. r -> ((a,t) -> r) -> r) ~ (forall r. t -> r -> (a -> t -> r) -> r), you can instantiate that to r = [a], and get (t -> [a] -> (a -> t -> [a]) -> [a]), then instead of returning the second argument in a "stop now" case you can just produce a [], so you can remove the second argument
07:27:26 <aristid> Saizan: that's what i did :)
07:28:32 <kstt> ok I got it, when the remote hangs up, it enters into an infinite loop
07:28:37 <Saizan> the part that instantiates r to [a] is allowing more power to the callback ofcourse
07:31:00 <lpsmith> if a thread blocks forever on an empty MVar,  can it be garbage collected if the MVar becomes otherwise unreachable outside that thread?
07:31:12 <ezyang> That's my understanding. 
07:32:13 <lpsmith> ezyang, thanks
07:32:17 <Skola> Any Dutch folks about here _that know where to order Haskell books (FP in hs, etc), where I can pay with iDeal_ ?
07:32:30 <Baughn> lpsmith: With many caveats. For instance, this is disabled if there are any signal handlers.
07:33:17 <Baughn> Or at least it was a year ago
07:34:46 <lpsmith> Baughn, any signal handlers anywhere in the program?
07:35:13 <Baughn> Sadly, yes.
07:35:44 <nazgjunk> Skola: the Dutch programming book market is rather useless, I've found
07:36:12 <Skola> Thought so, might try bol.com
07:36:26 <nazgjunk> That's probably your best guess, I was about to check 
07:37:04 <nazgjunk> oh wow, they do have a bunch of Haskell/FP books
07:37:09 <Skola> lol
07:37:21 <Skola> hardcover programming in haskell for 110,-
07:37:27 <t3eblinder> Has anyone here played around with the dbus-client library?
07:37:32 <Skola> look at those prices
07:38:11 <Skola> cheapest hard cover @ 85,-
07:38:29 <nazgjunk> There's a reason I never get hardcover books.  
07:38:43 <Skola> I always get them when I can
07:38:50 <Skola> but no way I'm paying that much for those
07:39:24 <aristid> Skola: can't you use amazon?
07:39:42 <aristid> hmm, no dutch amazon
07:39:43 <Skola> ya but I don't have a creditcard
07:39:54 <Skola> yes, no Dutch Amazon
07:40:03 <Skola> closest is UK Amazon
07:40:06 <aristid> www.amazon.de also allows non-credit card payments :)
07:40:16 <Skola> ah ok
07:40:19 <aristid> but you probably don't have a german bank account :D
07:40:23 <Skola> lol no
07:40:26 <Skola> but friends do
07:40:34 <nazgjunk> Amazon is the only reason I *have* a credit card 
07:40:37 <luite> ordering from the US amazon might be cheaper, with the weak dollar... but you'd probably need a cc
07:40:38 <aristid> Skola: man it's probably easiest to get a credit card
07:40:49 <Skola> I know yeah
07:40:57 <Skola> but it would just be for those books
07:40:58 <Daerim> Why not have a credit card?
07:41:07 <koala_man> you don't even need a credit card, just a debit card with visa
07:41:09 <Skola> just started working
07:41:17 <nazgjunk> koala_man: no debit cards over here do
07:41:36 <koala_man> where?
07:41:36 <Skola> have an income for half a year now, and never needed it
07:41:42 <nazgjunk> The Netherlands.
07:42:10 <Skola> I know great specialist shops in Amsterdam for philosophy, art etc
07:42:15 <Skola> I bet there are some for programming
07:42:21 <aristid> Skola: as long as you only buy stuff from dutch merchants, you probably don't need a credit card. but the netherlands are tiny, why limit yourself to those few merchants?
07:42:29 <Daerim> Here everything is bought with debit cards.... I almost only have cash when I go out of the country
07:42:38 <Skola> aristid you're right
07:42:54 <koala_man> nazgjunk: eh? you can't get visa to charge a debit account?
07:44:02 <bgmrao> exit
07:44:07 <Skola> I can let my boss order the books for me
07:44:17 <Skola> but then I have to wait longer
07:44:18 <quicksilver> koala_man: international debit cards are quite a new thing, and don't have anything remotely like global support.
07:44:18 <Skola> :[
07:44:36 <quicksilver> most debit card brands are still local.
07:45:04 <aristid> quicksilver: huh? VISA debit cards work internationally, almost like a credit card.
07:45:06 <Daerim> quicksilver, wait what? Visa has been working with debit cards for at least the last 15 years
07:45:11 <Berengal> What's the prefered monad transformer lib these days?
07:45:17 <quicksilver> yes, but they are not available in most countries.
07:45:18 <aristid> Berengal: mtl 2.0
07:45:24 <koala_man> craziest thing I ever heard
07:45:39 <aristid> quicksilver: most countries are third-world countries
07:45:45 <quicksilver> sure.
07:46:08 <Skola> nazgjunk
07:46:10 <quicksilver> However, even in most developed countries, VISA debit is not so widely available.
07:46:12 <Skola> I forgot http://www.boekwinkeltjes.nl/
07:46:22 <dominik> hey guys, suppose, I have a type a that belongs to the Typeclass Integral and two values v,w :: a. Do you know how to do something like the following: floor (v / w) ?
07:46:23 <Skola> I found some rare philosophy books through there
07:46:29 <Skola> must have Haskell books
07:46:47 <quicksilver> dominik: v `div` w
07:47:00 <Skola> yes, win
07:47:01 <dominik> quicksilver: oh, ok. Thx :-)
07:47:09 <aristid> quicksilver: where is it not available, for example?
07:48:40 <mac_wooster1> Help with xmobar.  I recently moved to Ubuntu and have got pretty much everything working - but for the battery monitor with Xmobar. Could someone please provide a xmobarrc template which includes the battery monitor? 
07:49:07 <quicksilver> aristid: I don't know. In many european countries only some banks issue them; if you're with the wrong bank you're out of luck.
07:49:11 <quicksilver> aristid: I don't have the complete list.
07:49:38 <aristid> quicksilver: you CAN have more than one bank relationship.
07:49:42 <quicksilver> sure.
07:49:48 <quicksilver> this is not a very interesting conversation.
07:50:02 <Daerim> Indeed
07:50:13 <quicksilver> it is a fact that in many developed countries it's not that easy to get an internationally accepted debit card. You can either believe me, or go do your own research.
07:50:20 <quicksilver> I don't mind either way.
07:50:57 <aristid> there's a third option: not fully believe you, and not do my own research.
07:51:09 <osfameron> heh
07:51:31 <Daerim> aristid, I guess that would be the haskell way?
07:51:38 <Skola> lazy..?
07:51:44 <Daerim> bingo
07:51:49 <Skola> <- genius
07:52:08 <Athas> Is there a general early-stopping monad?  Sort of like Error, but... with another name.
07:52:17 <aristid> Athas: Maybe?
07:52:36 <hpc> Maybe is the quintessential early failure monad
07:52:48 <Athas> Hm!  Actually, Either is better, as I also need error information.
07:53:00 <aristid> yeah, Either would be fine too
07:53:09 <hpc> @unmtl Error a  
07:53:09 <lambdabot> Error a
07:53:12 <aristid> either Either or maybe Maybe *lame joke*
07:53:15 <hpc> @unmtl Error a b
07:53:15 <lambdabot> Error a b
07:53:15 <Daerim> Athas, Either is whats used in most of the parsing libs
07:53:19 <hpc> bleh
07:53:24 <aristid> @unmtl Either a b
07:53:24 <lambdabot> Either a b
07:53:27 <aristid> lol
07:53:39 <hpc> aristid: i could Cont, but i would be listing irrelevant monads
07:53:54 <aristid> hpc: :P
07:54:17 <hpc> i suppose mtl only works on the tranformers
07:54:24 <lpsmith> hpc, I don't see why Cont would be irrelevant here :)
07:54:39 <hpc> lpsmith: it wouldn't, but Cont is kinda cheating
07:54:55 <lpsmith> cheating?
07:55:12 <hpc> Cont can trivially encode any monad
07:55:33 <lpsmith> hpc, I've got some counterexamples for you :-P
07:55:49 <hpc> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
07:57:01 <lpsmith> http://blog.melding-monads.com/2009/12/20/are-continuations-really-the-mother-of-all-monads/
07:57:11 <lpsmith> http://blog.melding-monads.com/2009/12/30/fun-with-the-lazy-state-monad/
07:57:25 <lpsmith> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
07:59:36 <lpsmith> In my honest opinion,  I think the issue is somewhat unresolved in the context of lazy evaluation
08:00:14 <lpsmith> It might be that you can generalize Representing Monads to lazy evaluation,  but I don't think it's "trivial"  :)
08:02:10 <t3eblinder> Anyone around who has used the dbus-client library? http://hackage.haskell.org/package/dbus-client
08:05:42 <lpsmith> t3eblinder, what about it?
08:06:23 <t3eblinder> lpsmith:  I've tried to implement an dbus tutorial example but I can't get it to work...
08:06:49 <t3eblinder> lpsmith: it just seems to do nothing.. 
08:09:48 <Peaker> are there ghc download mirrors? downloading directly from haskell.org is might slow
08:17:55 * hpc read that mindfuck link
08:18:03 <hpc> it lived up to its name
08:19:40 <hape01> somebody here who did dispaly a opengl output in an emacs buffer aside to the source code?
08:24:13 <Peaker> @index (</>)
08:24:13 <lambdabot> Text.Html
08:24:21 <Peaker> Where's the path one?
08:24:23 <lpsmith> t3eblinder, ahh.  I haven't used dbus,  but giving more details can help in getting an answer.    Does the library come with it's own examples?
08:24:52 <lpsmith> hpc, yeah;  I didn't even believe it was a monad until I checked that it was.   I have no idea what it might be useful for though.
08:25:05 <hpc> lpsmith: the comments say it makes a very fast writer
08:25:26 <t3eblinder> lpsmith: I recognized some minutes ago that there are examples in the tar.gz file ;) and I got my mistake
08:25:34 * hackagebot mvclient 0.4 - Client library for metaverse systems like Second Life  http://hackage.haskell.org/package/mvclient-0.4 (ChrisSmith)
08:26:03 <dataangel> Cabal question: I've changed my global prefix to be /export/home/me/opt. When I try to cabal install --global xmonad it gets stuck on X11 saying it can't install because /usr/local/share doesn't exist. But I don't specify that folder anywhere in my cabal config. Is the package broken or am I doing something wrong?
08:27:13 <dcoutts_> dataangel: did you remember to uncomment the line in your .cabal/config ?
08:27:49 <lpsmith> t3eblinder, yeah,  cabal unpack is a handy
08:27:56 <dataangel> dcouts_: Oh, I didn't realize those were comment lines
08:28:00 <lpsmith> t3eblinder, yeah,  "cabal unpack" is a handy command to know
08:28:01 <dataangel> dcouts: Oh it's haskell!
08:29:32 <lpsmith> hpc, the continuation monad also makes for a fast writer...
08:30:06 <Athas> Darn, EitherT isn't in monads-fd...
08:35:34 <t3eblinder> lpsmith: oh I didn't know this command - much easer then unpacking by hand!
08:36:40 <lpsmith> :)
08:40:04 <Berengal> Does Cont and ContT have any early-exit functions appart from the constructors themselves?
08:40:37 <aristid> Athas: http://hackage.haskell.org/packages/archive/EitherT/0.0.1/doc/html/Control-Monad-Either.html ?
08:41:19 <Athas> aristid: indeed, but I'm just going to copy the source - I don't want another package dependency.
08:43:01 <Athas> Actually, now that I think about it, what I need is a proper continuation monad... what's the fashionable package to use for that?
08:43:15 <aristid> Cont is right in transformers
08:43:28 <aristid> or ContT actually
08:44:24 <Athas> Oh, yes yes yes.  This is more like it.
08:49:43 <tarrasch> Hello, do anyone know if there is a EDSL for statistical image analysis? I'm thinking of morphological functions. Like erosions and dilations. Anyone haskeller who've worked with that? Morphology: http://en.wikipedia.org/wiki/Mathematical_morphology
08:50:38 * hackagebot splot 0.1.13 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.13 (EugeneKirpichov)
08:50:39 <tarrasch> I know matlab and such are also perfect for that. But those languages aren't functional. :) (that I know of)
08:51:19 <kstt> I'm working with Network.ByteString. I need to raise an IOError to exit a forever loop. How should I construct the IOError please ?
08:51:36 <hpc> from what i have used of matlab, it's about as useful for theory work as java
08:53:08 <pastorn> kstt: you want ContT for that
08:53:10 <tarrasch> hpc, hmm. May be so, I've used it quite little. It's to my knowledge quite a bad langauge from a programmers eye. (hard to get code reuse and so)
08:53:16 <aristid> kstt: you can actually raise any error. use Control.Exception.
08:53:39 <aristid> pastorn: isn't ContT on IO a bit dangerous?
08:53:51 <pastorn> aristid: bah! nonsense!
08:54:01 <monochrom> hpc: in System.IO.Error, userError "hi there!"
08:54:20 <aristid> monochrom: i really would use a fresh exception type for that.
08:54:25 <pastorn> kstt: but sure, error/catch is probably a nicer way to do it
08:54:29 <aristid> and then catch just that one.
08:54:46 <tarrasch> aristid, pastorn . I'm not a experienced haskeller, but raising an exception deliberetly to alter code flow seems awful. No?
08:55:10 <monochrom> hpc: in fact, it's in Prelude as well!
08:55:19 <pastorn> tarrasch: usually, but it depends
08:55:24 <aristid> monochrom: Control.Exception! :P
08:55:28 <tarrasch> You're basically crafting gotos from a langauge feature that ain't meant for that at all...
08:55:33 <hpc> :t userError
08:55:33 <lambdabot> String -> IOError
08:55:38 <hpc> :D
08:55:38 <pastorn> tarrasch: how much "recovery" can you do from the exception?
08:55:49 <aristid> tarrasch: well, haskell is certainly meant for ContT. ;)
08:55:51 <kstt> oh, nice userError, what I was looking for
08:56:03 <aristid> tarrasch: and exceptions are just a special case of continuations ;)
08:56:06 <tarrasch> pastorn, what?
08:56:07 <monochrom> oh oops, mix. s/hpc/kstt/
08:56:17 <pastorn> nevermind...
08:56:27 * pastorn goes back to play some more xbomb
08:56:37 <monochrom> xbomb is da bomb
08:57:55 <tarrasch> aristid, Yes. But still, you are crafting gotos by using exceptions. That's not good code practice afaik
08:58:22 <aristid> tarrasch: so you would use ContT?
08:58:31 <aristid> actually
08:58:38 <tarrasch> aristid, I'm not saying weather ContT or Exceptions are better. I mean they are bad options if there are more alternatives
08:58:43 <aristid> right
08:58:47 <aristid> best is not to use forever
08:59:01 <DRMacIver> tarrasch: I stand by http://www.drmaciver.com/2009/03/exceptions-for-control-flow-considered-perfectly-acceptable-thanks-very-much/
08:59:11 <pastorn> kstt: do you have a meaningful way to do error recovery?
08:59:29 <aristid> :t let notForever m = go where go = do a -> m; if a then go else return () in notForever
08:59:29 <lambdabot> parse error on input `->'
08:59:35 <aristid> :t let notForever m = go where go = do a <- m; if a then go else return () in notForever
08:59:36 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m ()
08:59:39 <tarrasch> DRMacIver, Thanks, I'll surely read through that, always good with new ways to look at things.
08:59:42 <monochrom> I don't buy "throw is goto".
08:59:44 <aristid> tarrasch: that better?
08:59:53 <kstt> pastorn: absolutly : I'm in IO doing network transfert, forever, until peer closes connection unexpectidly
09:00:03 <monochrom> "throw is break", sure.
09:00:19 <tarrasch> aristid, Is that like a while-loop?
09:00:27 <aristid> tarrasch: yeah. but in IO
09:00:36 <aristid> actually in Monad m => m
09:00:53 <aristid> Monad is an awesome typeclass btw :)
09:01:16 <pastorn> kstt: i'd use 'catch' for that :)
09:01:17 <tarrasch> aristid, Well, I think that's better. But again, I should read through DRMacIvers article first, maybe he changes my mind :) 
09:01:37 <aristid> :)
09:01:40 <DRMacIver> Probably not. I don't think I've ever changed anyone's mind with that article.
09:02:55 <monochrom> David Parnas invented exception throwing for better structuring, not worse.
09:03:05 <kstt> pastorn: the forever loop wrapped into a catch is not an option, as the inner content (Network.Bytestring operations) are designed to throw exceptions .
09:03:10 <Peaker> is there an easy way to get a standalone ghci executable, to import .hi files?  I want to place Haskell stuff on my embedded machine and play in it
09:03:15 <kstt> So I'm just adding a special case
09:03:48 <pastorn> kstt: or you could stop using forever
09:04:40 <pastorn> kstt: is there really so much to gain by using it? couldn't you get a nicer design with a bool and a recursive function?
09:05:00 <tarrasch> DRMacIver, is there any example where exceptions are more expressive than gotos? Or is your argumentation equivelent with arguing for gotos?
09:05:06 <aristid> :t let notForever m = go where go = do a <- m; if a then go else return () in notForever - kstt
09:05:07 <lambdabot> Not in scope: `kstt'
09:05:09 <aristid> :t let notForever m = go where go = do a <- m; if a then go else return () in notForever -- kstt
09:05:10 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m ()
09:05:12 <kstt> I could probably indeed, thanks for your idea
09:05:56 <tarrasch> why not call it whileM?
09:06:29 <aristid> um i did not actually think about the name
09:06:38 <tarrasch> ah ok, doesn't matter. :)
09:06:40 <pastorn> kstt: when doing loops like that i usually stop using a state monad, and instead collect/modify my state at the end of the function
09:06:40 <DRMacIver> tarrasch: No
09:07:03 <monochrom> exception is less expressive than goto, I would think.
09:07:04 * pastorn has stopped using the State monad when possible...
09:07:08 <aristid> pastorn: ContT + State? :D
09:08:13 <DRMacIver> monochrom: Indeed.
09:08:24 <tarrasch> From every place you do a `throw` you most likely know at which handler you're ending up in, but with gotos you can take any arbitary place. ==> gotos more expressive?
09:08:27 <monochrom> 10 PRINT "HELLO"
09:08:29 <pastorn> aristid: yeah, cause that's readable code...
09:08:33 <DRMacIver> And the whole point of sensible control structures is that you want things that are less expressive than goto.
09:08:34 <monochrom> 20 PRINT "HI"
09:08:38 <monochrom> 30 GOTO 20
09:08:46 <monochrom> you can't rewrite that goto into throw.
09:09:10 <hpc> 40 ???
09:09:13 <hpc> 50 PROFIT
09:09:20 <Berengal> monochrom: You can't unwind the stack using goto either
09:09:26 <monochrom> or you can, if you plan to do infinite unrolling
09:09:59 <Jafet> I wrote something like unfoldr, except its signature is (b -> Maybe (a,b)) -> a -> ([a],b) (it returns the last b). What should I call it?
09:10:20 <Axman6> unfoldr++
09:10:52 <Jafet> Okay, what should I name it?
09:11:35 <tarrasch> DRMacIver, Yes, less expressive makes loops and recursion more safe. With gotos you have little human understanding of where you end up. With exceptions it's way worse, you have no idea where you end up at all. You don't even give labels, editing code using your code works will be catastrophical.
09:12:00 <monochrom> "unwind the stack" seems to be an optimization rather than a must.
09:12:10 <Jafet> If anything, goto is less expressive than for.
09:12:31 <FUZxxl> I cloned GHC's brand new git repo, and tried to use darcs-all to get the remaining libs etc. But the script fails with some error message. Whom should I ask for help?
09:12:33 <tarrasch> Jafet, eh... No?
09:12:47 <DRMacIver> tarrasch: With higher order functions you also have no idea where your code will end up, but it was probably still where the caller intended it to.
09:12:54 <monochrom> "with return it's way worse, you have no idea where you return to at all".
09:13:04 <Jafet> That is, if by for you mean something like forM, a loop in the classic sense
09:13:23 <\yrlnry> What's the name of the theorem that says that fixed points such as µx.Sx+1 exist?
09:13:34 <monochrom> a case againt gosub and return?
09:13:39 <ezyang> I think the migration is still in progress? 
09:13:50 <Jafet> I guess I'll just call it something lame, like unfoldr2.
09:14:21 <tarrasch> monochrom, I think that's silly. The user of a function has the function under control, it's encapsulated. The implementer can put return whereever he wants, Not same with excpeptions.
09:14:44 <kstt> pastorn: the use case is a TCP proxy. I really *want* to do IO in the inner loop :)  http://hpaste.org/45178/proxy_tcp_and_profile
09:15:36 <monochrom> The user of a function has the function's exceptions caught, it's encapsulated. The implementer can throw whereever he wants, same with returns.
09:15:52 <monochrom> typo
09:15:53 <tarrasch> DRMacIver, pretty much the same thing as what I said to monochrom. You've both somehow inversed the view of encapsulation.
09:15:54 <\yrlnry> I think what I'm looking for might turn out to be "Knaster–Tarski theorem"
09:16:02 <monochrom> The user of a function has the function's exceptions either caught or rethrown, it's encapsulated. The implementer can throw whereever he wants, same with returns.
09:16:33 <tarrasch> monochrom, you're right about that I must admit ...
09:17:08 <Jafet> kstt: notice that the program has to allocate new buffers like heck
09:17:12 <monochrom> this is why throwing is structured. call-graph hierarchy.
09:17:24 <DRMacIver> tarrasch: You're overvaluing encapsulation. The ultimate encapsulation is to never let any data ever escape from your function.
09:17:25 <Berengal> Exceptions are just a very convenient way of unwinding the stack, optionally performing cleanup on the way on any level
09:17:35 <kstt> Jafet: indeed
09:17:51 <monochrom> "I call f, it throws X, but I don't catch X" is just sugar for "I rethrow f's X"
09:18:15 <Jafet> kstt: it might be significantly more efficient to allocate your own buffers and reuse them, using unboxed arrays or Foreign
09:18:30 <Jafet> Though if you resort to Foreign, you might as well be writing the program in C
09:18:31 <kstt> Jafet: I'm crying for a better implementation, reallly !!
09:18:32 <monochrom> this is also why "unwind the stack" is just compiler's optimization if it sees you "don't catch" ie you rethrow.
09:18:53 <kstt> Jafet: I'm just *too new* to haskell, and need to get started 
09:19:00 <monochrom> in principle, throw unwinds just as much as return unwinds.
09:19:27 <Berengal> monochrom: You need the stack unwinding, or your exception handlers could be anywhere in the stack when they get to run
09:19:38 <Berengal> So it's not just an optimization
09:19:43 <kstt> Jafet: if you have some spare cycles to point me to a better implementation, I'd be really glad to read it !
09:19:53 <DRMacIver> Berengal: 'though that can be a feature too. 
09:20:03 <Jafet> kstt: have you tried tweaking the settings in your program, like buffer size?
09:20:18 <DRMacIver> Berengal: e.g. if you have a conditions system (though there you ultimately do want to be able to unwind as well - you just want to do it after the handlers have been called)
09:20:38 <Berengal> DRMacIver: It could. I actually think I'd like to see what that would look like. But it wouldn't be exceptions as we're used to them
09:20:48 <Berengal> Well, finally kinda-sorta works that way
09:20:52 <monochrom> Berengal: that is not my impression from Graham Hutton's paper on exceptions.
09:20:57 <Jafet> kstt: you say you're new, so it might not be useful for you to read ghc core. But try anyway.
09:21:07 <DRMacIver> Berengal: Depends what sort of exceptions you're used to. :) It's how they work in common lisp I think.
09:21:52 <DRMacIver> 'though I've not actually used a language with a real condition system
09:21:57 <kstt> Jafet: 4016 is the buffer size recommanded for that usage. Tweaking didn't improve much. But now performance became acceptable, because the time actualy consumed tranfering data was really acceptable. But the peer closed the connection without notice, putting the proxy into a mad loop. 
09:22:35 <Berengal> I like continuations anyway...
09:22:50 <kstt> I didn't know that « client closed unexpectedly » was signaled by an empty buffer.
09:23:03 <kstt> Now things are better performance-wise
09:23:48 <kstt> Jafet: But I still beleive that this buffer should be allocated once (per connection) and for all.
09:24:23 <kstt> I just don't know how to allocate a bytestring and reuse it
09:24:36 <Axman6> > 2^15
09:24:37 <lambdabot>   32768
09:24:46 <kstt> I'd rather just teach the compiler that it can safely reuse it if I could
09:26:03 <Jafet> You can't, because they're not the same bytestrings.
09:26:15 <pastorn> kstt: heyo
09:26:30 <Peaker> damn, ghc is so big :-(
09:26:32 <Jafet> It might not be as expensive as you think, because the same memory area should be reused when the old bytestrings get collected.
09:26:40 <TomMD> Peaker: Is JHC sufficiently small?
09:26:53 <TomMD> Or coughyhccough?
09:27:15 <FUZxxl> what is a solid library for drawing simple graphics in Haskell?
09:27:26 <Peaker> TomMD, not sure, is any non-ghc compatible with ghc?
09:27:42 <TomMD> FUZxxl: Cairo, or are you looking for higher level + simpler?  Or are you looking for pure Haskell?
09:27:57 <TomMD> Peaker: No compiler has all of GHCs extensions.
09:28:03 <TomMD> except for GHC - funny enough.
09:28:22 <TomMD> FUZxxl: For learning purposes the gloss library is fun.
09:28:22 <Jafet> fuz: drawing graphics onto what?
09:28:32 <TomMD> But it isn't quite what you asked for.
09:28:40 <FUZxxl> TomMD: Just something simple. I want to draw some lines and circles onto a canvas and save the result as an image file. 
09:28:56 <Berengal> FUZxxl: Cairo should be good enough for that
09:29:15 <TomMD> I'm not sure about saving the results, but it took something like 10 minutes to learn gloss and make a really simple/ugly drawing program (using the mouse to make simple lines)
09:29:28 <TomMD> Cairo would be the more acceptable solution for something with utility.
09:29:57 <Jafet> Print postscript programs?
09:31:03 <FUZxxl> TomMD: Berengal: IMO it seems to be a bit complicated. (It's for codegolf) Maybe I just try to output plain SVG by tricky use of fprint.
09:31:52 <Peaker> TomMD, I wish GHC didn't statically link the entire planet
09:32:16 <pastorn> FUZxxl: have you looked at the classic "type Shape = (Double,Double) -> Bool
09:32:37 <Jafet> That's terrible.
09:33:11 <pastorn> Jafet: NO U!
09:33:51 <FUZxxl> pastorn: Ah!
09:33:56 <Jafet> Unless all you really want to do is rasterize a shape to a pixel grid.
09:33:56 <FUZxxl> Have to go offline. Bye
09:34:20 <Jafet> And bump into the nyquist-shannon limit.
09:36:12 * edwardk waves hello.
09:36:12 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
09:36:39 <edwardk> @tell djahandarie because i overlooked it ;)
09:36:39 <lambdabot> Consider it noted.
09:38:06 <djahandarie> Ah :)
09:38:06 <lambdabot> djahandarie: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:38:48 <djahandarie> I overlooked Kleisli somehow for newtype
09:43:05 <Peaker> how do I configure haddock to create documentation for everything such that inter-package links work?  enough to set doc-index-file to ~/.cabal/doc or such?
09:43:48 <dcoutts_> Peaker: inter-package links work by default
09:44:04 <dcoutts_> the doc-index-file is for an index of all the haddock docs for all your packages
09:44:09 <Peaker> dcoutts, I don't get any docs at all by default
09:44:31 <Peaker> is it enough to just set documentation to true?
09:44:39 <dcoutts_> right
09:45:18 <Peaker> thanks
09:46:18 <Peaker> It's a bit annoying to have to delete my ~/.ghc after I do that :)
09:46:27 <Peaker> (otherwise I have no sane way to generate the docs "transitively")
09:51:33 <Peaker> even after reinstalling everything with config saying documentation=true, I get "cabal: Can't find transitive deps for haddock"
09:51:38 <Peaker> and no docs, apparently
09:51:59 <Peaker> (for other packages it worked, not for mine)
09:52:20 <dcoutts> Peaker: sorry, what exactly? What command did you run, what was the error message?
09:52:38 <Peaker> dcoutts, "cabal install" on the package when documentation is set to true. Though I got the same message from "cabal haddock"
09:53:45 <dcoutts> Peaker: apparently that is due to having broken installed packages
09:53:56 <dcoutts> Peaker: use ghc-pkg check
09:54:09 <Peaker> check says all is OK (empty output)
09:54:24 <Peaker> dcoutts, in other instances I got "Warning: The documentation for the following packages are not installed. No links will be generated to these packages: ffi-1.0, rts-1.0"
09:54:32 <dcoutts> those are ok
09:55:09 <Peaker> I just removed ~/.ghc, and reinstalled everything for this package with documentation=true, so I don't expect anything to be broken
09:55:10 <dcoutts> Peaker: does your package use intra-package deps? The exe depending on the lib?
09:55:24 <Peaker> yeah
09:55:27 <dcoutts> ah
09:56:51 <Peaker> so, get rid of that?
09:57:09 <dcoutts> Peaker: there's a bug currently where the haddock step fails for such packages
09:57:14 * dcoutts is looking for the ticket
09:57:14 <Peaker> ah..
09:59:10 <dcoutts> Peaker: http://hackage.haskell.org/trac/hackage/ticket/656
10:03:54 <Peaker> dcoutts, thanks
10:09:54 <sharonbhanu> hi
10:10:01 <sharonbhanu> i am new to this
10:10:07 <sharonbhanu> how do i proceed
10:10:44 <yitz> sharonbhanu: you haven't said what you want to do
10:10:47 <monochrom> I suggest beginning with http://tryhaskell.org
10:11:10 <sharonbhanu> is this language case sensitive?
10:12:09 <dmwit> sharonbhanu: Oh yes.
10:12:19 <dmwit> It's everything-sensitive.
10:12:20 <sharonbhanu> thanks
10:12:35 <yitz> > let yay = 5; yAY = 10 in yay == yAY
10:12:35 <lambdabot>   False
10:12:36 <monochrom> most importantly, it is type-sensitive.
10:13:07 <sharonbhanu> can u explain type sensitive in detail i do not quite get u
10:13:12 <dmwit> sharonbhanu: There's a few good intros; LYAH, RWH, and the Gentle Introduction come highly recommended.
10:13:15 <dmwit> ?where lyah
10:13:15 <lambdabot> http://www.learnyouahaskell.com/
10:13:16 <dmwit> ?where rwh
10:13:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:13:20 <dmwit> ?where gentle
10:13:20 <lambdabot> http://www.haskell.org/tutorial/
10:13:26 <sharonbhanu> am sorry
10:14:42 <monochrom> type-sensitive means for example you cannot pretend that a number is a string. different types.
10:14:50 <sharonbhanu> oh ok
10:14:57 <Peaker> how do I make the haddock documentation include "source" links?
10:15:14 <dmwit> Upgrade.
10:15:30 <sharonbhanu> what is a good ide for haskell and what is the link to get it?
10:15:45 <Axman6> you don't need an IDE to write haskell
10:15:55 <sharonbhanu> then
10:16:22 <Peaker> dmwit, upgrade the haddock package?
10:16:29 <Axman6> only poor languages need IDE's ;)
10:17:20 <Peaker> dmwit, I'm on 2.9.2 which appears to be the newest
10:17:50 <Peaker> Axman6, Nobody "needs" IDE's, but it can be useful for the editor to provide type-aware features, structural editing commands that can use knowledge of what constitutes the project files, etc.
10:18:07 <Peaker> I use emacs, because I haven't yet found a good IDE, but I think a good IDE would kick emacs's ass
10:18:16 <monochrom> 2.6.1 is new enough. you just need the right options, regardless of version.
10:18:25 <c_wraith> sharonbhanu: there are some IDE options, though.  Leksah, Yi, EclipseFP.  I don't know offhand where to get any of them
10:19:01 <monochrom> if you call haddock through cabal, use --hyperlink-source. I cannot find a setting in .cabal/config
10:19:15 <Peaker> monochrom, thanks!
10:19:22 <sharonbhanu> thank you all
10:19:50 <monochrom> if you call haddock yourself, good luck, the right options are non-trivial
10:20:35 <Peaker> I don't have hscolour installed, maybe that's why it didn't work... hmm
10:20:59 <Peaker> it gives no errors but generates no source links
10:21:28 <monochrom> ah
10:21:44 <monochrom> hrm, haskell platform didn't come with hscolour
10:21:55 <Peaker> It doesn't work after installing hscolour either
10:22:18 <byorgey> c_wraith: Yi is not an IDE.
10:22:33 <c_wraith> Oh, just an editor?
10:22:37 <byorgey> yep.
10:22:58 <byorgey> a pretty awesome one that's configurable with a Haskell EDSL though.
10:22:59 <Peaker> monochrom, oh, wait, it seems "cabal haddock" puts it in dist/* and "cabal install" puts it in ~/.cabal/doc, and I was looking at ~/.cabal/doc
10:23:20 <Peaker> Does Yi let you write new code and load it on-the-fly like elisp in emacs?
10:23:25 <byorgey> yes.
10:23:52 * hackagebot SyntaxMacros 1.0 - Syntax Macros in the form of an EDSL  http://hackage.haskell.org/package/SyntaxMacros-1.0 (MarcosViera)
10:25:13 <Peaker> how do I get "cabal install" to give an option to the haddock process?
10:25:44 <byorgey> --haddock-options="..." ?
10:26:30 <Peaker> ah, thanks
10:26:44 <byorgey> in general --PROG-options will pass options to PROG
10:27:57 <Peaker> any config option to do this?
10:28:05 <Peaker> ~/.cabal/config that gives options to haddock?
10:34:32 <monochrom> I don't think there is one.
10:38:02 <RichardO> Does anyone know the best way to produce ascending permutations in haskell? Like this sequence: http://hpaste.org/45187/ascending_permutations
10:38:40 <RichardO> I'm trying to use the list monad, but that doesn't seem to work
10:39:08 <edwardk> byorgey: unbound is pretty neat
10:41:37 <mzero> what does the syntax     TypeName{..}   in a pattern mean?  
10:42:39 <mzero> er, perhaps that is    ConstructorName{..}   --- and it matches all the fields with pattern variables of the same name?
10:42:48 <dmwit> mzero: No, it matches none of the fields.
10:42:55 <dmwit> err
10:43:01 <dmwit> Didn't notice the ".." there.
10:43:09 <edwardk> foo (Bar{..}) = ... opens all of the fields as variables of the same name
10:43:13 <dmwit> What extensions are enabled? Perhaps the docs for one of them will say.
10:43:34 <lispy> That's record punning, IIRC
10:43:37 <edwardk> so if newtype Bar = Bar { quux :: Int, quaffle :: Int -> Double } -- you would have quux and quaffle in scope
10:44:11 <edwardk> {-# LANGUAGE NamedFieldPuns #-} IIRC
10:44:41 <mzero> okay - got it - so, convenient, but perhaps a little dangerous -- names you didn't expect could leak in!
10:45:00 <Berengal> mzero: It can also be used in construction of records
10:45:50 <Berengal> If you have, say 'data Foo = Foo {x, y ::Int}' then 'let x = 3; y = 5 in Foo{..}' makes a Foo with x = 3 and y = 5
10:46:29 <mzero> got it, thanks all!
10:47:49 <monochrom> eww
10:52:58 * hackagebot Pathfinder 0.5.6 - Relational optimiser and code generator  http://hackage.haskell.org/package/Pathfinder-0.5.6 (GeorgeGiorgidze)
10:58:13 <lispy> mzero: yeah.  It's an extension that I avoid personally, but I can see why people like it
10:58:48 <copumpkin> it's RecordWildCards iirc
10:58:49 <lispy> Then again, I'm a curmudgeon, and I would have avoided ($) if it weren't part of the prelude.  Now I use it all the time :)
10:59:07 * copumpkin rejoices in all the safe extensions
10:59:12 <copumpkin> fuck standards
10:59:29 <radicalpumpkin> REVOLUTION
10:59:54 <djahandarie> √pumpkin
11:00:25 <Berengal> I like every extension that cannot change the meaning of my code based on code somewhere else
11:01:37 <monochrom> ROTATION
11:01:49 <radicalpumpkin> ROUND
11:01:53 <mzero> you say you want a revolution... well, you know.... we all want -XRelaxedPolyRec.....
11:02:07 <radicalpumpkin> isn't that option still undocumented?
11:02:32 <mzero> But when you start talking about -XIncoherentInstances you that you can COUNT ME OUT.....
11:02:50 <mzero> You know it's gonna be.... all . rights 
11:02:56 <djahandarie> radicalpumpkin, it's documented in great detail right here: http://www.haskell.org/ghc/docs/7.0.2/html/libraries/Cabal-1.10.1.0/Language-Haskell-Extension.html#v:RelaxedPolyRec
11:02:57 <mzero> You know it's gonna be.... all . rights
11:03:23 <radicalpumpkin> wtf is that xmlsyntax
11:03:33 <mzero> You all know the fab-four were really Haskell pioneers, right?
11:03:40 <aristid> :t rights
11:03:41 <lambdabot> forall a b. [Either a b] -> [b]
11:03:47 <aristid> :t all.rights
11:03:48 <lambdabot>     Couldn't match expected type `a -> Bool'
11:03:48 <lambdabot>            against inferred type `[b]'
11:03:48 <lambdabot>     Probable cause: `rights' is applied to too many arguments
11:03:58 <aristid> :t and.rights
11:03:59 <lambdabot> forall a. [Either a Bool] -> Bool
11:04:19 <mzero> d'oh!
11:05:05 <Berengal> radicalpumpkin: php syntax for haskell
11:05:33 <radicalpumpkin> I hope it's nothing like scala's xml syntax
11:05:43 <mzero> does that introduce super-globals?   
11:05:59 * hackagebot DSH 0.5.5 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.5.5 (GeorgeGiorgidze)
11:06:18 <Jafet> What's wrong with incoherent instances?
11:06:22 <Jafet> You know the rules and so do I.
11:07:28 <monochrom> No, you know there are no rules, and so do I.
11:07:36 <mzero> perhaps that's -X  ML syntax?
11:07:43 <mzero> as in enabling ML style syntax?
11:09:23 <Berengal> I want RegularPatterns
11:10:22 <Jafet> Why does ByteString.readFile use fileSize?
11:10:27 <monochrom> "extension MLSyntax: this extension swaps : and :: "
11:10:32 <Jafet> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/bytestring-0.9.1.10/src/Data-ByteString.html#readFile
11:11:52 <Berengal> -XLispSyntax
11:21:29 <argiopeweb> Howdy folks. I've got a data type Message which has multiple (200+) type constructors, all of which need to be declared as instances of Binary. The only way I can see of doing this without breaking every type constructor under Message into its own newtype is to have a single gigantic instance declaration with pattern matching. Is there a better way?
11:22:26 <monochrom> no
11:22:52 <argiopeweb> That's incredibly sad.
11:22:54 <dmwit> 200 *type* constructors?
11:22:57 <burp> no template haskell magic?
11:23:11 <dmwit> If you meant data constructors, it might be possible to refactor the type to have fewer constructors.
11:23:15 <argiopeweb> burp: Hmm, hadn't thought of that... I'll check into it.
11:23:18 <dmwit> But yeah, you need to handle all the cases you've set up.
11:23:59 <argiopeweb> dmwit: Each represents a separate type of message sent over the network by a legacy app. Not much I can do about the number.
11:24:08 <monochrom> I'm pretty sure the 200 constructors are really there for a reason, cannot be simplified, no amount of metaprogramming or generic programming can reduce it.
11:24:52 <olsner> doesn't binary come with a tool to generate binary instances? ISTR having used such a thing
11:24:59 <Zao> Generate a source file from a nice intermediary representation.
11:25:08 <magicman> Sounds like a job for the derive package.
11:25:15 <magicman> (or something similar)
11:25:48 <olsner> ah, derive does have it: http://hackage.haskell.org/packages/archive/derive/0.1.1/doc/html/Data-Derive-Binary.html
11:25:58 <argiopeweb> I'll look into Derive as well. Just because it can't be beautiful doesn't mean that I have to write it by hand. :P
11:26:25 <Zao> argiopeweb: There's always Perl and friends for codegen :D
11:26:29 <Jafet> @ask dons (If you're still maintaining ByteString) Shouldn't BS.readFile not use hFileSize?
11:26:29 <lambdabot> Consider it noted.
11:27:25 <argiopeweb> Zao: I prefer Haskell for codegen over Perl.  Perl's evil. :P
11:27:45 <Jafet> It's just eval.
11:27:51 <argiopeweb> Badum dum.
11:28:10 <mauke> perl is not evil
11:28:12 <argiopeweb> Though I can't deny its use for in-place regex-based search and replace on multiple files.
11:32:25 <byorgey> edwardk: thanks =)
11:34:23 <lispy> Jafet: what's wrong with hFileSize?
11:37:13 <lispy> Jafet: I suspect I know what dons will say.  Send a patch with your proposed change
11:37:14 <Jafet> It won't work on anything that isn't a regular file.
11:37:28 <Jafet> Nah, I think I know what he will say. Use BS.Lazy
11:37:34 <lispy> it is named readFile instead of, say, read :)
11:37:45 <mauke> there are irregular files
11:37:46 <poucet> lispy: Do you use linux often? :)
11:37:57 <poucet> sockets, pipes are all files
11:39:19 <Jafet> It seems that BS.Lazy does IO sanely, but it's a bigger hassle to convert from and to Text.
11:39:36 <lispy> Hmm...I thought files were different than file descriptors.  I think of files as being blobs of bytes stored on disk.  I think of a file descriptor has a handle that lets you use certain file operations on file-like things.
11:40:32 <Jafet> Someday we will all use plan9 and these inequalities will be purged from the world
11:40:57 <lispy> Jafet: is plan9 webscale?  Does it support sharding?
11:41:15 <shachaf> lispy: It's from outer space.
11:41:17 <Cale> lol
11:41:23 <Cale> webscale
11:41:36 <mauke> lispy: file descriptors are even more general
11:42:41 <shachaf> Anything that you can open() is considered a file, including things like /dev/null and /proc/stat (and maybe directories).
11:42:49 <shachaf> But you can get an fd for other things.
11:48:43 <monochrom> what is sharding?
11:51:33 <byorgey> monochrom: I think it refers to splitting a single logical database over multiple physical machines
11:51:45 <Jafet> Hm, my bendecoder is still taking quadratic time on one of the test inputs
11:56:22 <lispy> monochrom: http://www.xtranormal.com/watch/6995033/
12:00:41 <wjt> soooo. it seems like the last bullet point of <http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/profiling.html#prof-rules> is biting me pretty badly: I've got a Gtk2HS program that's … a bit memory-hungry, and the .prof output tells me that 100% of time and allocations are in MAIN, and … nothing elsewhere :D
12:02:45 <wjt> i wonder if I'm misinterpreting how to drive the profiler (or whether the many gigabytes of memory allocations really are all in C code). i should get reasonable results by just building with -rtsopts (and passing --enable-executable-profiling to cabal configure) and then running with +RTS -p, right?
12:03:44 <dmwit> wjt: Hm. I haven't done it with cabal before, but I seem to recall needing to specify some cost centers (e.g. with -auto-all).
12:04:04 <dmwit> wjt: If you're only seeing one cost center, maybe that's your problem?
12:04:31 * dmwit freely admits that he has done almost no successful profiling
12:04:47 <wjt> dmwit: hmm, i tried -caf-all but not -auto-all
12:06:06 <wjt> dmwit: you win a prize, thanks :)
12:06:29 <kamaji> should I pass functions as pointers to functions?
12:06:38 <kamaji> herp derp, wrong channel
12:06:38 <kamaji> :D
12:10:35 <edwardk> argiopeweb: template haskell is your friend
12:10:49 <edwardk> woops, was scrolled back
12:12:42 <argiopeweb> edwardk: lol, no problem. It reminded me to look it up anyway. Template Haskell is one of the many areas in which I have so far had no experience. Got any good resources?
12:13:23 <djahandarie> I've been meaning to figure out how the hell to use template haskell to generate these instances for me, but when I did awhile ago it just gave me a headache so I haven't tried again
12:13:32 <tg_> #haskell: from #math: what's the class of functions that have closed-form roots called?
12:13:50 <sipa> algebraic functions?
12:14:47 <edwardk> argiopeweb: i abuse it here and there in my code, but i'm not quite sure what would stand as canonical documentation for it
12:15:03 <edwardk> http://www.haskell.org/haskellwiki/Template_Haskell is a good start
12:15:54 <argiopeweb> I really should use the word canonical more... It's just a great word...
12:16:16 <edwardk> http://hackage.haskell.org/packages/archive/ad/0.45.0/doc/html/src/Numeric-AD-Internal-Classes.html makes a fair bit of use of template haskell at the bottom
12:16:19 <argiopeweb> edwardk: Thanks, I'll check it out. Abuse or not, it can't make my life any worse. ;)
12:29:03 <Berengal> I need a heterogenous map of sorts and I'm wondering about the best way to do this. Basically, it'll contain a datum and some functions that take this as input, I also need references to access the data from elsewhere. What I have planned now is an existential type and typed references coupled with unsafeCoerce
12:31:06 <Taslem> Is there any way at all to make any sort of linked-list structure with variable nesting?
12:31:16 <jmcarthur> Taslem: you mean a tree?
12:31:42 <Taslem> Hm, not exactly what I was looking for.
12:31:46 <jmcarthur> Taslem: try Data.Tree
12:32:05 <jmcarthur> Taslem: it allows an arbitrary number of branches at each node
12:32:27 <Taslem> Oh, that's what I was looking for. Thanks!
12:36:54 <lispy> argiopeweb: ironically, when I first started hearing that term, I had a hard timing finding its canonical definition
12:37:16 <Taslem> How can you write a multi-line string?
12:37:21 <Runar> Taslem: You can also do it with an arbitrary functor, not just list.
12:37:44 <lispy> argiopeweb: see for example: http://www.google.com/search?hl=en&safe=active&defl=en&q=define:canonical&sa=X&ei=Z9mUTaZH7NmIArKOoZ0J&sqi=2&ved=0CBcQkAE
12:38:08 <lispy> Although, I was pretty sure my math professor was not referring to the bible
12:38:33 <Runar> data Tree f a = Tree a (f (Tree a))
12:38:42 * edwardk canonizes lispy.
12:39:18 * hackagebot language-javascript 0.4.3 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.4.3 (AlanZimmerman)
12:40:11 <Taslem> Is it excusable to use unsafePerformIO to retrieve data from a log file that never changes?
12:40:39 <radicalpumpkin> NEVAR
12:40:39 <dafis> depends on whom you ask
12:40:52 <sipa> use a Reader(T)
12:40:57 <dmwit> A log file? That never changes? Sounds like a contradiction.
12:41:09 <Zao> dmwit: Rotated data?
12:45:33 <Taslem> When I say Log file, I mean it was written by something else, not the program reading it.
12:46:07 <Taslem> I'm trying to make my functions pure, so I do not wish to use IO in this case.
12:46:11 <zygoloid> if it never changes, read it at build time with TH :)
12:47:13 <zygoloid> logfileContents = $( runIO $ readFile "logfile" ), iirc
12:47:55 <Taslem> Oh well. Chances are the function I'm writing would be made impure eventually anyways.
12:48:16 <dmwit> Why not read once at the top-level, and be pure from then on?
12:48:31 <dmwit> That's the usual way.
12:48:57 <Taslem> Well, for one, while the thing never changes during program run, it can be modified to change how the program acts. But only I'm supposed to modify it.
12:49:05 <Taslem> Not users.
12:49:30 <Taslem> So it helps by not requiring a recompile when I make a change. Because program behavior is based on rules listed in the file.
12:49:38 <dmwit> eh?
12:49:49 <dmwit> Reading once at program start would not require a recompile when you make a change.
12:50:03 <Taslem> I know, I know.
12:50:31 <dmwit> Then what's your real objection?
12:50:49 <Taslem> That it will end up being impure anyways?
12:51:40 <Taslem> Well, I'll see. For now I'll just write it purely and then add in the impure stuff.
12:53:38 <aristid> @djinn (a -> a) -> Maybe a -> Maybe a
12:53:39 <lambdabot> f a b =
12:53:39 <lambdabot>     case b of
12:53:39 <lambdabot>     Just c -> Just (a c)
12:53:53 <aristid> djinn generates partial functions :(
12:54:48 <edwardk> aristid: or lambdabot just gives you partial replies ;)
12:54:50 <Saizan> try in query
12:55:00 <edwardk> to avoid spamming the channel
12:55:14 <aristid> nope.
12:55:16 <djahandarie> No, I checked, it is really broken
12:55:34 <djahandarie> Only the lambdabot version though, darcs djinn is fine afaik
12:57:20 * hackagebot hjsmin 0.0.13 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.13 (AlanZimmerman)
13:03:48 <aristid> @pl \k v -> Data.Map.insertWith (++) k [v]
13:03:48 <lambdabot> (. return) . Data.Map.insertWith (++)
13:04:19 <aristid> is there a Multimap class?
13:04:56 <Jafet> Map k [v]
13:05:12 <Jafet> .oO(Class? Which school?)
13:18:50 <aristid> Jafet: sorry, i meant type of course.
13:19:07 <aristid> and yes, Map k [v] does the trick, i was just searching for something more convenient.
13:19:38 <aristid> Jafet: if you look just two lines above my question, you will see that i figured out how to insert a single element into a Map k [v]
13:19:57 <aristid> so i was obviously aware of that option :P
13:22:34 <augur> byorgey! stop writing blog posts!
13:22:58 <aristid> augur: why? oO
13:23:02 <Jafet> aristid: why not flip (:)?
13:23:14 <aristid> :t Map.insertWith
13:23:15 <lambdabot> Couldn't find qualified module.
13:23:19 <aristid> :t M.insertWith
13:23:19 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
13:23:26 <aristid> Jafet: this is why :P
13:23:31 <augur> aristid: because i dont write any, and it makes me feel bad
13:23:52 <Jafet> :t M.update
13:23:53 <lambdabot> forall a k. (Ord k) => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
13:24:00 <aristid> augur: aw :(
13:24:13 <byorgey> augur: that is the worst reason for me to stop writing blog posts I have ever heard ;)
13:24:17 <gigamonkey> Hey folks, slightly OT but maybe you know: is there anywhere on IRC to talk about ML?
13:24:23 <byorgey> not that I have heard very many
13:24:26 <aristid> Jafet: Map.alter could probably also be used
13:24:29 <aristid> :t M.alter
13:24:30 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
13:24:50 <Jafet> Maybe a -> Maybe a? Sounds really tentative
13:25:02 <augur> byorgey: ;)
13:25:13 <gigamonkey> Or failing that, maybe someone here can point me to something to read to quickly teach me just enough ML to grok the code in "An applicative Control-Flow Graph Based on Huet's Zipper"
13:25:15 <augur> byorgey: tell me about enumeration
13:25:35 <byorgey> augur: I don't really have time to chat at the moment, sorry
13:25:43 <augur> :(
13:25:46 <augur> you never do!
13:25:50 <augur> YOU DONT LOVE ME ANYMORE
13:26:01 <augur> T_T
13:34:08 <aristid> preflex: seen kamatsu
13:34:08 <preflex>  kamatsu was last seen on #haskell 4 days, 12 hours, 26 minutes and 50 seconds ago, saying: i see how it works though
13:41:30 <silbo> hey
13:41:56 <silbo> so how many GSoC applications are there yet?
13:44:26 * hackagebot tls-extra 0.1.5 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.1.5 (VincentHanquez)
14:01:13 <Athas> I wish GADTs worked for newtypes...
14:03:59 <Cale> Athas: That's a somewhat interesting request, what would you use that for?
14:05:49 <Athas> Cale: I am currently writing a lot of functions of the form 'SomeClass bar => foo -> MyType bar'.  I would like it if 'SomeClass bar' was guaranteed by the fact that 'bar' is a parameter to 'MyType'.
14:05:57 <Athas> (Because that is always going to be the case.)
14:06:32 <zygoloid> Athas: where would the evidence of that be carried? it can't be in the newtype since they're supposed to have no runtime cost
14:07:23 <Athas> Why is there a need for runtime information?
14:07:39 <acowley> The SomeClass constraint
14:07:55 <byorgey> every type class constraint corresponds to a method dictionary that gets passed at runtime.
14:08:48 <augur> byorgey: i feel compelled to point out that logic tells us neither of those things. :)
14:08:48 <Athas> Could it not be stored as part of the actual bar value?  I assume that is where it is stored anyway - I'm just moving the constraint to every use rather than keeping it at the definition.
14:10:14 <zygoloid> Athas: no, it's no stored in the bar value. typeclass instances are passed separately
14:10:29 <acowley> augur: I think it actually is logical. You wrote a function that says, "Given a proof that bar is an instance of the SomeClass typeclass, and a value of type bar, I will give you a MyType bar."
14:11:45 <radicalpumpkin> zygoloid: I'd like it if a newtype could refine its own type parameters though, GADT style
14:11:52 <radicalpumpkin> even though that refinement is an implicit equality constraint
14:11:58 <radicalpumpkin> that constraint has no runtime representation
14:12:24 <dotprog> Does anybody want to help a beginner in programming Haskell? And please dont't laugh. I started today.
14:12:37 <hpc> dotprog: we are last in line to laugh at new people
14:12:48 <byorgey> dotprog: what do you need help with?
14:12:53 * mauke laughs
14:12:56 <jmcarthur> dotprog: #haskell is a pretty encouraging environment :)
14:13:02 <byorgey> @slap mauke
14:13:02 * lambdabot pushes mauke from his chair
14:13:04 <acowley> except for mauke
14:13:09 <Athas> It's much more fun to laugh at people who ought to know better.
14:13:27 <mauke> @stop byorgey 
14:13:27 <lambdabot> Maybe you meant: show slap
14:13:33 <mauke> maybe I did
14:13:41 <sipa> dotprog: are you following a tutorial?
14:13:53 <jmcarthur> yeah, like if dons said that if you want speed then you should use ruby
14:14:14 <dafis> well, it has rails
14:14:26 <dafis> and a TGV *is* pretty fast
14:14:27 <Athas> It's written in C!
14:14:44 <dafis> what a horrible misuse of C
14:15:19 <dotprog> sipa: yeah, I'm doing "Haskell in 5 steps" right know. And please dont' laugh.
14:15:33 <dafis> dotprog: why should one laugh?
14:15:41 <mauke> this "please don't laugh" stuff is getting annoying
14:15:51 <dotprog> because I'm so bad
14:15:55 <radicalpumpkin> people are scarred by other IRC channels
14:15:56 <dotprog> sorry mauke
14:15:58 <sipa> dotprog: i promise i won't lauhj
14:16:04 <mauke> radicalpumpkin: it's annoying in other channels too
14:16:05 <sipa> unless you ask me one more time
14:16:16 <radicalpumpkin> dotprog: we're really friendly :) now stop apologizing for your lack of experience and start asking us some questions :)
14:16:16 <dafis> dotprog: if you believe you're bad, you're at most half as bad
14:16:31 <Athas> Hm, one thing I don't like about Parsec is that it doesn't (can't) check your grammar for ambiguity...
14:16:36 <jmcarthur> yeah seriously. the worst programmers are the knowitalls
14:17:16 <acowley> jmcarthur: I know
14:17:38 <edwardk> i prefer the knowsmorethanidos
14:17:49 <jmcarthur> edwardk: hear hear
14:18:05 <radicalpumpkin> thear thear
14:18:16 <hpc> knowenoughtoshootselfinfoot
14:18:17 <sipa> beer beer
14:18:39 <byorgey> dotprog: why don't you come to #haskell-overflow?  It's a bit noisy in here
14:18:44 <acowley> and this complete's dotprog's first haskell lesson
14:18:48 <acowley> well done, #haskell!
14:19:04 <mauke> I think it's only noisy because dotprog hasn't asked a question yet
14:19:12 <hpc> acowley: lesson 1: a community of PhDs is decidedly on the sillier half of the internet
14:19:15 <mauke> so the channel is kinad unfocused
14:19:22 <edwardk> we're mostly just filling the void caused by anticipation
14:19:25 <acowley> yes, we are all primed
14:19:28 <byorgey> well, true
14:19:29 <jmcarthur> dotprog: ask your damn question. don't worry about whether it sounds intelligent. :P
14:19:32 <edwardk> no pressure or anything
14:19:42 <byorgey> I am also afraid that dotprog is going to get 17 simultaneous answers =P
14:19:47 <hpc> hahaha
14:19:50 <dotprog> what should I do? I can't read so fast. my english isn't that good
14:19:52 <jmcarthur> don't hold back, #haskell
14:20:04 <hpc> dotprog: ask question
14:20:10 <mauke> receive help
14:20:14 <acowley> lots of help
14:20:15 <jmcarthur> receive bacon?
14:20:27 <dotprog> well, the tutorial says I should compile the hello.hs file with " $ ghc -o hello hello.hs" but then comes "<interactive>:1:1: parse error on input `$'  ". 
14:20:33 <edwardk> dotprog: if the channel is flowing past too fast you can ask in #haskell-overflow, otherwise, just ask your question, and people will typically respond ;)
14:20:43 <jmcarthur> dotprog: stick your code here http://hpaste.org/
14:20:44 <mauke> dotprog: the $ is not part of the command
14:20:51 <jmcarthur> oh
14:20:53 <mauke> dotprog: it indicates that you should run the rest of the line in your shell
14:20:53 <jmcarthur> i see now
14:21:01 <jmcarthur> dotprog: what mauke is saying, not what i was saying
14:21:01 <mauke> dotprog: you're trying to run it in ghci, which won't work
14:21:02 <hpc> ghc -o hello hello.hs
14:21:03 <Cale> and it's meant as a command for your system commandline, not for ghci
14:21:05 <dafis> dotprog: the $ stands for the shell prompt, it's widely used
14:21:08 <hpc> or more preferably:
14:21:11 <edwardk> dotprog: the $ represents a unix prompt, not ghci
14:21:13 <hpc> ghc --make hello.hs
14:21:17 <mauke> 17 answers, go!
14:21:24 <jmcarthur> we're not there yet
14:21:25 <sipa> haha, i'm sure dotprog has had enough answers already :D
14:21:30 <acowley> hpc: --make is default now
14:21:38 <hpc> acowley: oh cool
14:21:48 <mauke> dotprog: there's a #haskell.de
14:22:02 <jmcarthur> do the non-english channels have much traffic?
14:22:13 <hpc> jmcarthur: nyet!
14:22:28 <sipa> no #haskell.nl or #haskell.be :(
14:23:15 <dotprog> you shouldn't laugh
14:23:46 <sipa> dotprog: we all had to learn it once
14:24:08 <hpc> dotprog: however long it takes you to learn haskell, it probably took me longer
14:24:12 <hpc> ;)
14:24:24 <augur> er, not byorgey :D
14:24:26 <edwardk> dotprog: nobody here is laughing at you or your question. any humor comes from the fact that folks are amused by the fact that people who ask questions wind up with so many answers to choose from, not from an attempt to ridicule the speaker
14:24:38 <sipa> well said
14:26:14 <dotprog> I have a file hello.hs and write in the ghci "ghc --make hello.hs"? Is that write?
14:26:31 <mauke> ... no?
14:26:32 <sipa> yes, that's right
14:26:36 <mauke> sipa: no
14:26:37 <dafis> dotprog: no, you write that at the shell prompt
14:26:37 <dotprog> sorry, right not write
14:26:50 <sipa> oh, i didn't see ghci on his line
14:27:09 <sipa> dotprog: it's either "ghci hello.hs" to get the interpreter, or "ghc --make hello.hs" to compile it
14:27:11 <MasseR> dotprog: Are you on windows or linux?
14:27:12 <hpc> dotprog: you write your program in hello.hs; after that, you run "ghc --make hello.hs" in the terminal
14:27:12 <sipa> (without the "")
14:27:29 <dafis> dotprog: in ghci, you'd write ":l hello.hs" to load the file into ghci
14:27:29 <Berengal> I need a heterogenous map of sorts and I'm wondering about the best way to do this. Basically, it'll contain a datum and some functions that take this as input, I also need references to access the data from elsewhere. What I have planned now is an existential type and typed references coupled with unsafeCoerce
14:27:35 <dotprog> i'm working with windows
14:27:54 <MasseR> Thought so. By terminal they don't mean the ghci terminal, but for example cmd.exe
14:28:05 <byorgey> Berengal: I don't quite understand what you want, but you may want to look at the way xmonad handles user-defined state
14:28:17 <byorgey> Berengal: it uses a heterogeneous map
14:28:26 <edwardk> dotprog: then you'd run 'ghci --make hello.hs' at the C:\WhateverDirectoryYouPutYourStuffIn> prompt
14:28:40 <mauke> no, ghc --make hello.hs
14:28:47 <edwardk> er ghc
14:28:49 <edwardk> sorry
14:29:17 <Berengal> byorgey: XMonad uses Dynamic, I think. I don't want to force that restriction if there's a way to avoid it
14:29:34 <Berengal> A way that isn't insane that is
14:29:58 <Eduard_Munteanu> I'd tell you to look into HList, but that's insane too :)
14:30:26 <dotprog> edwark: where's a prompt in windows?
14:30:49 <Eduard_Munteanu> dotprog: start -> run -> type 'cmd'
14:30:51 <Berengal> Basically, I have a tree of continuations that I'll be trampolining, with state that can change inbetween invocations (ContT r (StateT s stuff))
14:31:20 <cathper> I have some computations going on, and the result becomes a list which is output. Can I ask the binary to output the list "strictly" (as soon as an entry is known, print it)?
14:31:30 <Eduard_Munteanu> But you probably also need to know how to 'cd' around.
14:31:33 <Berengal> The parent continuation needs to be able to access the child continuations' state
14:31:48 <mauke> cathper: that happens by default
14:32:11 <dafis> cathper: mapM_ print will print each element on its own line
14:32:15 <hpc> cathper: except it isn't so much that printing is strict as that all the other computation is lazy
14:32:18 <Berengal> So whenever you make a child, you get a ref to it you can use to look up it's data (and other things). At least that's what I'm thinking of doing now
14:32:37 <dotprog> Eduard_Munteanu: I'm working with a german version of windows 7. I can't find it.
14:32:48 <mauke> dotprog: in case you missed it before, #haskell.de is a german haskell channel
14:33:03 <Berengal> dotprog: <Win>-R
14:33:09 <hpc> Berengal: instead of unsafeCoercing, why not have class UnExist a where extract :: Existential -> a?
14:33:22 <Zao> mauke: What does it mean if you enable MagicHash and use fmap as (.)?
14:33:58 <Berengal> hpc: How would that work?
14:34:00 <dotprog> mauke: sorry I didn't see it. thanks
14:34:01 <Eduard_Munteanu> hpc: can that be implemented? :)
14:34:28 <hpc> er
14:34:39 <hpc> nvm, being an idiot
14:34:42 <Berengal> hpc: Since you can't look at the values it might as well be () -> a
14:34:50 <hpc> don't mind me!
14:35:28 <Eduard_Munteanu> In general, with existentials you can pair them up with either a typeclass or a function taking the existentially quantified type.
14:35:42 * hpc is not used to seeing unsafeCoerce as a type cast
14:35:46 <Eduard_Munteanu> The thing is you can't expose the existential, except to replace it.
14:35:54 <cathper> mauke: main = print $ [1, head $ dropWhile (<2^27) [1..] ] won't print the 1 untill dropWhile is done.
14:36:13 <mauke> cathper: yes, it will
14:36:26 <dafis> mauke: depends on the buffering settings
14:36:27 <Eduard_Munteanu> So something like an existential restricted to Show would work, because it produces a String.
14:37:10 <Eduard_Munteanu> Similarly, an existential that contains a value of type 'a' and a function a -> String.
14:37:23 <hpc> > let main = [1, head $ dropWhile (<2^27) [1..] ] in main
14:37:27 <lambdabot>   mueval-core: Time limit exceeded
14:37:32 <hpc> well...
14:37:53 <hpc> > let main = [1, head $ dropWhile (<2^27) [1..] ] in map show main
14:37:56 <lambdabot>   mueval-core: Time limit exceeded
14:38:01 <hpc> humbug
14:38:05 <cathper> dafis: Yeah, but I'd like the list output. I can fix that afterwards, but that's a work-around. Could the buffering setting be tweaked?
14:38:24 <mauke> :t hSetBuffering
14:38:25 <lambdabot> Not in scope: `hSetBuffering'
14:38:29 <hpc> cathper: hSetBuffering stdin {-something-}
14:38:34 <Eduard_Munteanu> Berengal: but what would you use your map for?
14:38:34 <mauke> no, stdout
14:38:37 <hpc> @hoogle hSetBuffering
14:38:37 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
14:38:39 <hpc> er, yes
14:38:40 <hpc> stdout
14:38:42 <dafis> cathper: printList (x:xs) = putStr ("," ++ show x) >> hFlush stdout >> printList xs; printList [] = putStrLn "]"; fudge a little with the first element and
14:38:48 <hpc> @src BufferMode
14:38:49 <lambdabot> Source not found. It can only be attributed to human error.
14:38:58 <Eduard_Munteanu> Berengal: looking them up like a normal map certainly won't work.
14:38:58 <hpc> i think it's NoBuffering
14:39:18 <Athas> Hrmm, I introduced ContT into a subpart of my program, and now I want to use it everywhere!
14:39:21 <Berengal> Eduard_Munteanu: It will if I only expose it used (phantom) typed references
14:39:29 <Athas> How very seductive a tool that is.
14:39:30 <dafis> cathper: you could hSetBuffering stdout NoBuffering, but that may be bad sometimes
14:39:38 <acowley> Athas: how so?
14:39:41 <hpc> Athas: i still don't understand it
14:39:53 <Berengal> using*
14:40:14 <Athas> acowley: I can jump around in the control flow as I please.
14:40:51 <cathper> dafis: I see.
14:41:13 <ddarius> Athas: There's SML/NJ and Scheme over there.
14:41:30 <Eduard_Munteanu> Berengal: like using type representations and discriminating by case?
14:41:33 <dmwit> ?index getArgs
14:41:33 <lambdabot> System.Environment
14:41:41 <acowley> Athas: right, but I can't say I often feel the need for it
14:41:59 <Eduard_Munteanu> Berengal: if only a few different types are enough for you, you don't really need fully heterogenous maps.
14:42:05 <acowley> Athas: and I'd like to know if I'm missing out on something :)
14:42:07 <Eduard_Munteanu> You could use a plain sum datatype
14:42:25 <Berengal> Eduard_Munteanu: I don't know the types at all. They could be anything
14:42:58 <Athas> acowley: I'm writing an interpreter for a procedural programming language, and use ContT for implementing C-like continue/break/return.  Now I have to add proper error handling to the rest of the system, and I'm considering just purint ContT instead of ErrorT into my main monad stack.
14:43:00 <Eduard_Munteanu> Mm, at this point I have to ask... are you sure this is the best way to go about solving your problem?
14:43:17 <acowley> Oh, yes!
14:43:29 <acowley> Those are prime examples of escape continuations
14:43:32 <Berengal> Eduard_Munteanu: I want hierarchical continuations.
14:43:53 <Eduard_Munteanu> Ah, I don't know about those.
14:44:23 <Berengal> Eduard_Munteanu: Basically they're coroutines, but structured like a tree
14:44:26 <Berengal> That's what I want
14:45:19 <parcs> @hoogle (Eq a) => a -> [a] -> Maybe Int
14:45:19 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
14:45:19 <lambdabot> Data.ByteString findSubstring :: ByteString -> ByteString -> Maybe Int
14:45:19 <lambdabot> Data.ByteString.Char8 findSubstring :: ByteString -> ByteString -> Maybe Int
14:46:31 <acowley> Berengal: So you need types to line up as you walk down the tree?
14:47:01 <Eduard_Munteanu> Ok, my guess is you want to map tree levels to contexts.
14:47:33 <Berengal> acowley: Walking the tree isn't a problem. The data and continuations are stored in the same existential. The trouble is that the parent continuation needs to be able to access the data, and I need to be able to store arbitrarily many children
14:49:01 <Eduard_Munteanu> Berengal: ok, but the parent must know the type of the children's data, mustn't it?
14:49:03 <Berengal> Think of a continuation-based web-framework. You have a page that maps to a continuation doing a wizard-type thing. In this wizard there's a calendar widget, which also has state. The trouble is, each time you yield the parent continuation you need to redraw the widget
14:49:25 <Berengal> Eduard_Munteanu: Yes, and it does because it has a typed ref.
14:49:42 <Berengal> But I need to be able to store these heterogenous data
14:49:59 <Eduard_Munteanu> I'm not sure what you mean by a typed reference. Something plain as STRef s a?
14:50:18 <Berengal> The reference is just used to look thinks up in a map
14:50:41 <Berengal> something like newtype Ref a = Ref Int coupled with an IntMap would work just fine
14:51:22 <Eduard_Munteanu> Well that only tells me it can reference the children data, but to actually process it, it mustn't depend on the underlying type.
14:51:25 <Berengal> Then lookupRef map ref = fmap unsafeCoerce (lookup map (unRef ref))
14:51:36 <Eduard_Munteanu> (or else it must access it in a polymorphic fashion)
14:51:50 <Berengal> The map is hidden away behind a monad
14:52:18 <Eduard_Munteanu> Berengal: what are you coercing into?
14:52:21 <Berengal> So you have a 'getData :: Ref a -> MyCont (Maybe a)' function
14:52:58 <dafis> > text "Can you read me?"
14:52:58 <lambdabot>   Can you read me?
14:53:09 <Berengal> Eduard_Munteanu: The type of the ref
14:53:15 <c_wraith> Berengal: fmap unsafeCoerce is funny.  :)
14:53:31 <Eduard_Munteanu> Berengal: but 'a' in 'Ref a' won't match any existentially quantified 'a' in the data
14:53:49 <Eduard_Munteanu> (it can't, you don't know its type)
14:53:49 <Berengal> Eduard_Munteanu: No, that's why I'm using unsafeCoerce ;)
14:54:00 <Berengal> I DO know it's type, but Haskell doesn't
14:54:05 <Eduard_Munteanu> Heh.
14:54:15 <Berengal> I also have a 'setData :: Ref a -> a -> MyCont ()'
14:54:18 <c_wraith> Berengal: I'd really consider using Data.Dynamic
14:54:22 <Berengal> And that's the only way to set the existential
14:54:37 <Berengal> c_wraith: I'm considering it, but that forces a Dynamic restriction
14:54:49 <c_wraith> you mean Typeable?
14:54:52 <Eduard_Munteanu> Berengal: oh so you're basically duplicating untyped pointers / stores, right?
14:54:53 <Berengal> Yes
14:54:59 <c_wraith> Fortunately, nearly everything is Typeable
14:55:18 <Berengal> c_wraith: Typeable isn't a recursive restriction either, is it?
14:55:21 <Eduard_Munteanu> Like C stuff.
14:55:30 <Eduard_Munteanu> (say void pointers to opaques)
14:55:31 <c_wraith> Berengal: no, it's not
14:55:43 * hackagebot yesod 0.7.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.7.3 (MichaelSnoyman)
14:55:53 <Berengal> Eduard_Munteanu: In a way, yes
14:56:21 <Eduard_Munteanu> I'm not sure it's safe though.
14:57:00 <Eduard_Munteanu> Though if you're sure types do match then I guess it's fine.
14:57:15 <Berengal> This is a case where it should be easy to prove that the types match
14:57:20 * ddarius thinks of limit diagrams and cobordisms.
14:58:46 <Berengal> I'm not too averse to requiring Typeable though
14:59:10 <Eduard_Munteanu> IIRC GHC can even derive Typeable
14:59:15 <acowley> it says something that cobordisms are so much on your mind
14:59:17 <Eduard_Munteanu> Can't it?
14:59:21 <acowley> yes
15:06:52 <c_wraith> well.  It can derive Typeable if the types aren't too crazy
15:06:54 <MasseR> Okay time to rm -fr .cabal .ghc again :/
15:08:50 <dcoutts_> sigh
15:12:06 <dafis> MasseR: why?
15:12:39 <acowley> dcoutts_: tibbe mentioned that you'd done some thorough analysis (or at least thinking) about the unsafe IO in, for example, the new Binary builder. Do you have any notes or anything? I found it hard to be sure by looking at the code.
15:13:23 <dcoutts_> acowley: can you be more specific? what kind of safety?
15:13:52 <acowley> There's an inlinePerformIO that calls a function that allocates, while the notes on inlinePerformIO strongly advise against just that
15:14:07 <dcoutts_> is there? :-)
15:14:34 * dcoutts_ contributed to the notes on inlinePerformIO
15:14:40 <MasseR> dafis: cabal starts installing duplicate libraries
15:14:47 <MasseR> ghc-pkg list | sort | uniq -c | sort -n
15:14:49 <acowley> well that's not fair
15:14:58 <hpc> @hoogle inlinePerformIO
15:14:58 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
15:15:11 <hpc> oh my
15:15:26 <dcoutts_> it's like unsafePerformIO, but more so
15:15:38 <dcoutts_> with a dash of extra evil
15:15:41 <ion> awesome
15:15:44 <acowley> Gah, I can't find that on hackage
15:15:49 <dafis> MasseR: too many to fix by unregistering selected libs?
15:15:59 <acowley> but I was looking at Vector.Storable, I think, which is where I noticed the warning about allocations
15:16:07 <c_wraith> The implementation of inlinePerformIO is hilarious.
15:16:23 <MasseR> dafis: When it gets to that point, I have no idea of the culprits
15:16:43 <dafis> MasseR: ghc-pkg check?
15:16:50 <MasseR> dafis: Says everything okay
15:17:09 <monochrom> "ghc-pkg check" only tells you how screwed you are, not how to solve it. :)
15:17:24 <geheimdienst> MasseR: have you looked at ghc-pkg list without the "sort" stuff? you could easily have a package in /usr and a duplicate in ~/.cabal
15:17:24 <dafis> MasseR: then it's probably bad dependency limits in .cabal files
15:17:39 <aristid> :t M.insertLookupWithKey
15:17:40 <lambdabot> forall k a. (Ord k) => (k -> a -> a -> a) -> k -> a -> M.Map k a -> (Maybe a, M.Map k a)
15:17:46 * hackagebot ebeats 0.0.1 - Time in ebeats  http://hackage.haskell.org/package/ebeats-0.0.1 (BrianLewis)
15:17:49 <hpc> shouldn't inlinePerformIO begin with "unsafe"?
15:17:56 <dcoutts_> acowley: honestly, it's probably pretty dodgey
15:18:00 <MasseR> geheimdienst: o.O? ghc-pkg list shows both global and user packages
15:18:01 <aristid> why the k in (k -> a -> a -> a)?!
15:18:17 <monochrom> but hell, my own http://www.vex.net/~trebla/haskell/sicp.xhtml also only tells you how to screw yourself, not how to solve it. :)
15:18:18 <dcoutts_> acowley: but it's likely to be ok with ghc because I think it will not lift it outside of the lambda
15:18:42 <dcoutts_> acowley: I'm looking at the definition of unsafeLiftIO in binary, and uses thereof
15:18:55 <geheimdienst> yeah exactly. i had e.g. an older "cabal" package in ~ which overrode the newer global one and caused a mess
15:19:30 <aristid> ByteString seems to invite people to use unsafe I/O
15:19:35 <MasseR> geheimdienst: Should be some sort of crowdsourced faq of these errors and how to fix 'em :P
15:19:54 <monochrom> "ghc -v" is a better indication of problems
15:20:14 <acowley> dcoutts_: I'm just at a very confused place about when unsafeIO is okay. I thought I understood before, and managed to write some code that was demonstrably not safe so now I'm gun shy.
15:20:18 <MasseR> monochrom: That doesn't help with 'cabal configure'..?
15:20:58 <hpc> acowley: the general rule is "never" ;)
15:21:12 <monochrom> I'm not sure what you mean?
15:21:45 <MasseR> For example I wrote a package today which depends on time. Worked okay, until sometime later today (fixing ghc-pkg check errors). It tried to use time-1.0.3 (or something like that) instead of 1.0.2 which is the one random uses
15:21:59 <Athas> Yes, the time package gives me grief too.
15:21:59 <acowley> hpc: except that there are times when you are doing something that is almost entirely pure
15:22:01 <monochrom> if "ghc -v" shows problems, you are not even supposed to proceed to "cabal whatever".
15:22:01 <MasseR> And there was nothing in the cabal saying that it should use a newer time
15:22:28 <acowley> hpc: or at least times when you *think* you are doing something almost entirely pure
15:22:31 <geheimdienst> MasseR: cabal also has a switch to increase verbosity, like ghc with -v. it will tell you what packages it selects and why ...
15:22:52 <MasseR> Duh, of course -.-. <- idiot
15:23:02 <monochrom> actually "cabal install -v" is pretty useless, if you read its information
15:23:12 <dafis_> MasseR: perhaps one of your other dependencies' latest version depends on a later time
15:23:35 <dafis_> cabal install -v3 --dry-run
15:23:38 <hpc> acowley: in that case, "prove it" would be the rule :P
15:23:48 <lispy> Many times the issue of transitive deps can be handled by switching to cabal-dev, but I can't tell if it would help in this case
15:24:16 <acowley> hpc: which is what I was asking dcoutts_ for :)
15:24:17 <MasseR> dafis_: Probably. However cabal was uninformative and just told that random requires older package and myprog requires newer
15:24:24 <geheimdienst> monochrom: i don't know what you mean, i've found cabal -v helpful on occasion
15:24:27 <acowley> hpc: more for an example than as a challenge
15:25:31 <lispy> I've found cabal's verbose output quite helpful also.  But sometimes you still need ghc-pkg to really figure out what is going on.
15:25:40 <dcoutts_> acowley: so the order, in increasing degree's of unsafety is: unsafePerformIO, unsafePerformDubableIO and inlinePerformIO
15:25:50 <dcoutts_> erm Dupable
15:26:09 <dcoutts_> acowley: and you can't really prove anything, it's implementation dependent
15:26:12 <MasseR> lispy: How can you use ghc-pkg in diagnosing? Other than ghc-pkg check of course
15:26:14 <dafis> and the killer would be unsafeDubyaIO?
15:26:36 <hpc> what's unsafePerformDubableIO?
15:26:37 <dcoutts_> acowley: but you can pretty much rely on data dependencies to order things
15:27:07 <hpc> er, dupable
15:27:11 <dmwit> Great success! 23 lines of imports and data, and only 27 lines of code.
15:27:22 <dmwit> <3 Haskell
15:27:53 <dcoutts_> hpc: sorry, it's unsafeDupablePerformIO, from GHC.IO
15:28:01 <lispy> MasseR: ghc-pkg can tell you which version a package was actually compiled against.
15:28:10 <acowley> dcoutts_: an implementation-specific proof is what I want. The docs are so vague and mysterious, but I'd like to have a better understanding about when an unsafe*IO gets erroneously lifted, for example.
15:28:17 <dcoutts_> hpc: it means it might perform the IO action more than once
15:28:18 <MasseR> dmwit: Heh, that amuses me too. I often laugh at my code when it starts to be around >1/4 of imports :P
15:28:27 <dcoutts_> hpc: so it'd better be safe to do so
15:28:31 <acowley> Where is unsafeDupablePerformIO defined? I can't find it
15:28:47 <dcoutts_> acowley: GHC.IO
15:29:05 <dmwit> MasseR: Ain't glue great? =D
15:29:47 <dcoutts_> acowley: consider: inlinePerformIO $ do buf <- newBuffer 10; ...
15:30:09 <MasseR> dmwit: Yup. Altough I've been wondering why for example in python, with similar functionality there are a lot less importss. Do they export much more within modules..?
15:30:29 <dcoutts_> acowley: normally, with IO you can guarantee that all the actions in the IO do block get run in order, because the >>= sequences them
15:30:29 <MasseR> I haven't had many projects that had more than 5 lines of imports in python
15:30:56 <dcoutts_> acowley: internally this is achieved in ghc's implementation of IO by passing around a dummy state# variable
15:31:37 <dcoutts_> acowley: it's linearly threaded through the IO actions, so there's a data dependency, so the ghc optimiser is force to evaluate in a certain order, hence it's ok if those things have side effects
15:31:51 <lispy> MasseR: I think most haskell modules tend to be very focused.  Some projects provide modules that just re-export several other modules.  When I use those projects, I need fewer imports.
15:32:16 <dcoutts_> acowley: normally the "original" World# constant value is passed in to Main.main and passed all the way through the program
15:32:30 <dmwit> MasseR: Yeah, I'm not sure. I think the Haskell culture somehow encourages very small libraries.
15:32:41 <lispy> MasseR: So, I think it's a combination of those two things.  Short modules and then when you notice a problem is when you don't have the meta modules that re-export things
15:33:04 <dcoutts_> acowley: so in a normal: do buf <- newBuffer 10; ...;  there's a hiddent state# parameter that stops (newBuffer 10) from being a constant, it's actually a function of the state#
15:33:40 <dcoutts_> acowley: if it really were a constant, we'd be in trouble, since ghc would be permitted to lift it out and evaluate it only once, since it's constant right?
15:33:55 <dcoutts_> acowley: using inlinePerformIO makes it a constant! disaster!
15:34:03 <acowley> !
15:34:05 <monochrom> geheimdienst: the like of "selecting random-1.0.0.2 (installed or hackage) and discarding random-1.0.0.0, 1.0.0.1 and 1.0.0.3" is useless.
15:34:21 <monochrom> firstly, "installed or hackage"? so which one is it?
15:34:42 <dcoutts_> monochrom: it has not committed at that point
15:35:09 <monochrom> secondly, you're selecting 1.0.0.2 and discarding all the other versions. great. why are you selecting 1.0.0.2? doesn't say.
15:35:25 <hpc> dmwit: my personal solution to the import problem is "import Lib.All"
15:35:55 <dcoutts_> acowley: because instead of there being an IO action that takes in a state# value, instead inlinePerformIO makes its own local World# value and passes that in, so now if you look at the dependencies, there's nothing to make (newBuffer 10) a function any more, it is now constant
15:36:01 <MasseR> hpc: 50Mb hello world prog? :P
15:36:16 <hpc> MasseR: the module is project-specific :D
15:36:32 <dcoutts_> acowley: meaning ghc is allowed to share them all, and all your buffers become aliased :-)
15:36:49 <hpc> MasseR: and is mostly just for the obvious reflex imports like monad, functor, applicative, arrow
15:37:13 <dmwit> hpc: Yeah, I've got a Prelude.Dmwit for one-offs, but it's not really okay to depend on something like that if you want to send it to other people. =)
15:37:22 <dcoutts_> monochrom: it's most likely selecting that version because 1.0.0.2 is the version that is installed
15:37:54 <hpc> dmwit: indeed; i'm careful not to invent any wheels in those sorts of files ;)
15:38:23 <acowley> dcoutts_: So you only use inlinePerformIO with an argument that depends on a non-liftable argument in an outer scope
15:38:41 <dcoutts_> acowley: right
15:38:57 <monochrom> well, I suppose it is useful for people who install two million different versions of random.
15:39:07 <acowley> dcoutts_: I need to revisit the code I wrote that didn't work
15:39:26 <dcoutts_> acowley: so basically it's safe to do read-only things, but not to create new mutable objects
15:39:45 <acowley> dcoutts_: but don't you do just that when you allocate a buffer and fill it?
15:41:45 <monochrom> My experience with problems posted in this channel is that "ghc -v" tells you everything about the problem.
15:41:51 <acowley> I was doing something similar, where I unsafely created and filled a buffer, and the code ended up broken.
15:42:03 <acowley> monochrom: ghc -v5 tells you everything about every problem
15:42:08 <acowley> I recently learned that
15:42:30 <dcoutts_> acowley: read-only on already created variables, no local allocation
15:42:31 <monochrom> cabal-install behaves strange or ghc behaves strangely because some xxx-1.0 in user is shadowing xxx-1.0 in global
15:42:52 <dcoutts_> monochrom: yes, that's our biggest problem at the moment I think
15:42:57 <acowley> dcoutts_: But the builder uses inlinePerformIO to make a call that allocates
15:43:02 <monochrom> and yyy-2.0 in global is built against xxx-1.0 in global, not the one in user, therefore yyy-2.0 is unusable.
15:43:28 <dcoutts_> acowley: so those conditions are sufficient, and a good rule of thumb :-)
15:43:41 <monochrom> and only "ghc -v" gives you that information. not "cabal install -v1000", not even "ghc-pkg check".
15:44:00 <acowley> dcoutts_: :(
15:44:48 <djahandarie> acowley, that Coq robot thing sounds like it's going to be pretty cool.
15:45:08 <acowley> djahandarie: I think it is already, but I'm getting murdered by roboticist reviewers
15:45:28 <djahandarie> Are you aiming to build some sort of framework for robotics in Coq? Or just exploring the domain? I don't know much about formally verified robotics :p
15:45:46 <acowley> djahandarie: I use an embedding of linear logic in Coq to verify an assembly script and simultaneously generate rich types for every step of the operation that can be used for dynamic validation
15:45:48 <dcoutts_> acowley: for binary, yes, it's a tad dodgey but if you look at ensureFree, at the unsafeLiftIO (which is otherwise bad because it uses const) is probably ok because it uses the n parameter
15:46:24 <acowley> dcoutts_: are those in Data.Binary? I keep having trouble finding the functions you mention
15:46:43 <dcoutts_> acowley: erm, that's the latest darcs version I can find
15:46:47 <djahandarie> Neat
15:46:57 <dcoutts_> acowley: sorry, I've gotta go to bed
15:47:12 <acowley> djahandarie: The usual way is to verify an algorithm, then only apply it to a narrow class of problems that support the proof
15:47:15 <Eduard_Munteanu> Whoa! BONUS' dead-tree form of LYAH made it on LWN!
15:47:22 <dcoutts_> acowley: basically it all becomes comprehensible if you look at the actual data dependencies
15:47:23 <acowley> dcoutts_: Thanks for the help!
15:47:24 <hpc> LWN?
15:47:38 <acowley> dcoutts_: I'll dust off my broken code, and maybe bend your ear with it at some point soon
15:47:42 <monochrom> Linux Weakly News
15:47:44 * hpc is such a clueless boob today
15:48:04 <acowley> djahandarie: My approach is to use incomplete planners with gnarly heuristics, etc, but generate scripts in a verifiable core language
15:48:08 <monochrom> and oh, where is Haskell Weakly News?
15:48:17 <ddarius> acowley: Those robotniks don't like being a slave to the type system.
15:48:22 <monochrom> ah, it's released
15:48:36 <djahandarie> ddarius, they aren't. Dependent types. ;)
15:48:47 <acowley> djahandarie: So what I'm interested in is coming up with Coq toolkits for specific applications that facilitate proving relevant lemmas, etc., as well as automated proving for scripts 
15:49:03 <acowley> ddarius: my types depend on my robots
15:49:22 <Eduard_Munteanu> Heh, I assume 'pun intended' :P
15:49:39 <acowley> I mostly speak in puns
15:50:01 <monochrom> my <$> quote makes it to HWN
15:50:02 <monochrom> \∩/
15:50:16 <acowley> okay, wife will be annoyed soon; I must be off!
15:50:47 <Eduard_Munteanu> http://lwn.net/Articles/435218/
15:50:59 <Eduard_Munteanu> (for subscribers atm)
15:52:48 <djahandarie> ddarius, http://strictlypositive.org/winging-jpgs/winging12.jpg
15:52:50 <Eduard_Munteanu> Hrm, it seems some dude from O'Reilly "spammed" LWN with this, great.
15:54:40 * geheimdienst just discovered ghc-pkg dot. that's neato.
15:59:50 <aristid> geheimdienst: neato is actually an alternative renderer for dot files :)
16:00:05 <hpc> wait, what?
16:00:11 <hpc> @hackage neato
16:00:11 <lambdabot> http://hackage.haskell.org/package/neato
16:00:13 <geheimdienst> badum-ching! rimshot
16:00:34 <dmwit> hpc: GraphViz comes with several different strategies for laying out graphs.
16:00:39 <geheimdienst> somebody got it
16:00:42 <dmwit> "neato" is one of them
16:00:53 <geheimdienst> isn't it even the default these days ...
16:01:20 <aristid> hpc: it's part of graphviz
16:01:35 <aristid> hpc: which is not a haskell package, but a C program (i think)
16:01:55 <monochrom> can I call my package "awesome"? :)
16:03:16 <Eduard_Munteanu> monochrom: nope, that's taken :)
16:03:41 <Eduard_Munteanu> You could Haskellize the name, maybe "howsome"? :)
16:03:54 <geheimdienst> hawsome
16:04:08 <geheimdienst> aweshome
16:04:20 <Eduard_Munteanu> newsham
16:04:26 <geheimdienst> lol
16:04:26 <monochrom> then perhaps awe-inducing
16:04:55 <geheimdienst> inductive awe
16:05:05 * ddarius will simply call his package "thebestpackageever."
16:08:13 <aristid> ddarius: what if you make another package that is even better?
16:08:29 <geheimdienst> thebestpackageeverer
16:08:34 <aristid> if the name was awesome, you could name it moreawesome
16:08:35 <geheimdienst> thebestpackageeverest
16:08:39 <geheimdienst> thebestpackageeverest2
16:08:39 <aristid> but best is already superlative
16:08:59 <dmwit> What was that cabal command to list the packages that are used?
16:09:11 <aristid> dmwit: ghc-pkg list?
16:09:17 <geheimdienst> aristid: i have no trouble at all coming up with superlativer superlatives
16:09:30 <dmwit> aristid: No, just the packages used for building this one executable.
16:20:07 <lispy> dmwit: http://hackage.haskell.org/trac/ghc/ticket/5071
16:23:19 <dmwit> lispy: subscribed
16:24:18 <lispy> dmwit: I'm surprised no one else has discovered this bug before me.
16:24:37 <lispy> Don't people worry about malloc failing? :)
16:27:57 * hackagebot pdfsplit 0.0 - split two-column PDFs, so there is one column per page  http://hackage.haskell.org/package/pdfsplit-0.0 (DanielWagner)
16:28:56 <djahandarie> Wouldn't that make more sense as pdfjoin? :p
16:29:00 <djahandarie> Joining two columns into one...
16:29:11 <dmwit> Perhaps.
16:32:20 <osoleve> is <$> really identical to fmap?
16:33:00 <sipa> :t (<$>)
16:33:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:33:03 <sipa> :t fmap
16:33:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:33:26 <osoleve> i didn't know if it was a quirk of lambdabot or what, thanks
16:33:41 <djahandarie> @check (\f a -> fmap f a == f <$> a)
16:33:42 <lambdabot>   Precedence parsing error
16:33:42 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `Da...
16:33:50 <djahandarie> @check (\f a -> fmap f a == (f <$> a))
16:33:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
16:33:51 <lambdabot>    arising from a use of `...
16:34:33 <djahandarie> Why is that trying to show a function? lol
16:35:53 <Eduard_Munteanu> > (\f a -> fmap f a == f <$> a) id 1
16:35:54 <lambdabot>   Precedence parsing error
16:35:54 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `Da...
16:36:09 <lispy> djahandarie: because check needs to show the counter examples if there are any
16:36:15 <Eduard_Munteanu> > (\f a -> fmap f a == (f <$> a)) id 1
16:36:16 <lambdabot>   No instance for (GHC.Num.Num (f a))
16:36:16 <lambdabot>    arising from the literal `1' at <int...
16:36:20 <lispy> djahandarie: so it would need a show instance for f
16:36:39 <Eduard_Munteanu> > (\f a -> fmap f a == (f <$> a)) id [1.10]
16:36:40 <lambdabot>   True
16:36:56 <DukeDave> 87
16:36:57 <Eduard_Munteanu> @check (\f a -> fmap f a == (f <$> a)) id
16:36:58 <lambdabot>   No instances for (Test.QuickCheck.Arbitrary (f a),
16:36:58 <lambdabot>                    GHC.S...
16:37:39 <Eduard_Munteanu> @check (\f a -> seq (head a) $ fmap f a == (f <$> a)) id
16:37:39 <lambdabot>   "*Exception: Prelude.head: empty list
16:37:51 <aristid> lol
16:37:51 <Eduard_Munteanu> Bah.
16:37:57 * Eduard_Munteanu was forcing types :)
16:38:13 <aristid> @check (\f a -> seq (map id a) $ fmap f a == (f <$> a)) id
16:38:14 <lambdabot>   "OK, passed 500 tests."
16:38:38 <Eduard_Munteanu> @check (\f a -> seq (a ++ a) $ fmap f a == (f <$> a)) id
16:38:39 <lambdabot>   "OK, passed 500 tests."
16:39:30 <aristid> @check (\f a -> fmap f (a `asTypeOf` []) == (f <$> a)) id
16:39:30 <lambdabot>   "OK, passed 500 tests."
16:39:43 <Eduard_Munteanu> Ah, forgot about that.
16:39:48 <aristid> :)
16:40:16 * Eduard_Munteanu wonders...
16:40:19 <Eduard_Munteanu> @src asTypeOf
16:40:19 <lambdabot> asTypeOf = const
16:40:21 <aristid> :t (`asTypeOf` [])
16:40:22 <lambdabot> forall a. [a] -> [a]
16:40:27 <Eduard_Munteanu> Ah, better.
16:40:30 <sipa> @src (<$>)
16:40:30 <lambdabot> f <$> a = fmap f a
16:40:34 <sipa> good enough?
16:40:43 <Eduard_Munteanu> LOL
16:40:57 <aristid> uh.
16:43:18 <azaq23> @type let asTypeOf = (const :: t -> t -> t) in 42 asTypeOf (4 :: Int)
16:43:19 <lambdabot> forall t. (Num (Int -> t)) => t
16:43:36 <azaq23> @type let asTypeOf = (const :: t -> t -> t) in 42 `asTypeOf` (4 :: Int)
16:43:37 <lambdabot> Int
16:46:04 <newsham> eduard: yes?
16:48:47 <Eduard_Munteanu> newsham: no, nothing :). We were making up names for monochrom's pkg :)
16:49:00 <Eduard_Munteanu> (sorry if I disrupted you needlessly :D)
16:49:50 <monochrom> in revenge, you could suggest naming a package "monochrom" next time. :)
16:50:03 <shachaf> > 42 asTypeOf 4 -- It works!
16:50:03 <lambdabot>   42
16:50:12 <newsham> ed: newsham is (tm)! ;-)
16:50:21 <Eduard_Munteanu> Aww.
16:50:30 <djahandarie> Haha shachaf
16:50:54 <djahandarie> "Lambdabot supports infix functions with no ``s! -- Or does it?!"
16:50:57 <geheimdienst> we'll go with newnewsham then
16:51:42 <newsham> heh.
16:52:44 <aristid> :t 42 asTypeOf
16:52:45 <lambdabot> forall t a. (Num ((a -> a -> a) -> t)) => t
16:52:53 <aristid> :t 42 asTypeOf 4
16:52:54 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
16:53:25 <aristid> :t 42 asTypeOf 4 :: Int
16:53:26 <lambdabot> Int
16:53:47 <Eduard_Munteanu> :t 42 asTypeOf id
16:53:48 <lambdabot> forall t a. (Num ((a -> a) -> t)) => t
16:53:49 <shachaf> > 42 id () 15 "hello" False (Just Nothing)
16:53:50 <lambdabot>   42
16:54:18 <Eduard_Munteanu> > 42 asTypeOd id $ 3
16:54:19 <lambdabot>   Not in scope: `asTypeOd'
16:54:22 <Eduard_Munteanu> > 42 asTypeOf id $ 3
16:54:23 <lambdabot>   42
16:54:56 <azaq23> this should be from vector-space, the num instances
16:55:00 <azaq23> turns 42 into const 42
16:55:05 <djahandarie> azaq23, it is.
16:55:05 <Eduard_Munteanu> Yeah.
16:55:11 <shachaf> 42 is like v in unlambda.
16:55:14 <ion> It would be nice if there were an alternative >ish command that doesn’t use all the nasty addons. In fact, perhaps > should be that command and something like ☃ should behave as the current >.
16:55:15 <lispy> fromIntegral = const?
16:55:25 <Eduard_Munteanu> @vixen What is the meaning of life?
16:55:25 <lambdabot> first you tell me.
16:55:47 <monochrom> eww
16:56:01 <lispy> ion: this comes up from time to time.  The bottom line seems to be, the person who runs lambdabot (Cale) seems to get final say as that person is doing the work
16:56:34 <lispy> OTOH, he would probably hand over the job to another maintainer if one appeared.
16:56:38 <shachaf> ion: What nasty addons?
16:56:52 <ion> > 42 9
16:56:53 <lambdabot>   42
16:56:56 <ion> :t (.)
16:56:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:57:38 <shachaf> > ((^2) + 42) 5
16:57:39 <lambdabot>   67
16:57:46 <ion> yes?
16:58:00 <lispy> > 5 . 6 $ 1
16:58:02 <lambdabot>   5
16:58:34 <lispy> > 5 'a'
16:58:34 <lambdabot>   5
16:58:37 <Eduard_Munteanu> > fix 6
16:58:37 <lambdabot>   6
16:58:49 <lispy> ah, see 6 is broken!
16:58:54 <geheimdienst> > 'a' 5
16:58:55 <lambdabot>   Couldn't match expected type `t1 -> t'
16:58:55 <lambdabot>         against inferred type `GHC.T...
16:58:57 <Eduard_Munteanu> :)
16:59:07 <djahandarie> lispy, Cale is completely fine with adding a vanilla >
16:59:08 <newsham> ed: http://www.newsham.com/images/technical/technical-main.jpg
16:59:11 <djahandarie> No one has done it.
16:59:32 <lispy> Right
17:00:01 <geheimdienst> it could be called >>
17:00:04 <lispy> I'm not a fan of some of the current "features" but I don't feel like fixing it either.
17:00:13 <Cale> The function constants aren't so bad, are they?
17:00:21 <shachaf> > let { fivе = 5; siх = 6 } in five.six $ 1
17:00:22 <lambdabot>   5.6
17:00:27 <Eduard_Munteanu> newsham: what's that piggy doing there? The image is smallish
17:00:27 <Cale> It's just a natural consequence of having a Num instance for functions.
17:00:37 <elliotstern> On a windows machine earlier, "liftM show getCurrentTime" was giving me some trouble about there not being a instance for (Show UTCTime).  On my mac machine, it works (it can find the instance for sho).  I find this confusing.  Anyone know what I need to do to get it work on windows?
17:00:53 <lispy> > 5 . 6 $ fix
17:00:54 <lambdabot>   5
17:01:01 <lispy> fix  $ 5 . 6
17:01:08 <lispy> > fix $ 5 . 6
17:01:10 <lambdabot>   5
17:01:21 <shachaf> > fix $ 5.6
17:01:22 <lambdabot>   5.6
17:01:59 <lispy> I never noticed that 'const a' commutes with fix
17:02:13 <shachaf> > let { fivе = 5; siх = 6 } in succ + five.six $ 0
17:02:14 <lambdabot>   6.6
17:02:17 <lispy> > const 1 $ fix == fix $ const 1
17:02:17 <lambdabot>   Couldn't match expected type `a -> b'
17:02:17 <lambdabot>         against inferred type `GHC.Bo...
17:02:34 <Eduard_Munteanu> > 1 error
17:02:35 <lambdabot>   1
17:02:53 <shachaf> > 2 error
17:02:54 <lambdabot>   2
17:03:05 <shachaf> Ah ah ah!
17:03:28 <lispy> > if 2 error > 2 then fix 1 else fix 2
17:03:29 <lambdabot>   2
17:03:31 <Eduard_Munteanu> > 1 fix 2 error
17:03:32 <lambdabot>   1
17:03:36 <Cale> > five.six
17:03:37 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
17:03:37 <lambdabot>    arising from a use of `...
17:03:41 <Cale> > five.six $ 1
17:03:42 <lambdabot>   5.6
17:03:45 <Cale> lol
17:03:48 <Cale> sneaky
17:03:50 <Eduard_Munteanu> Whoa!
17:03:51 <Cale> unicode
17:03:57 <Cale> @undef
17:04:03 <Cale> > let { fivе = 5; siх = 6 } in succ + five.six $ 0
17:04:03 <Eduard_Munteanu> Oh.
17:04:04 <lambdabot>   Not in scope: `five'Not in scope: `six'
17:04:08 <Cale> ;)
17:04:15 <lispy> ah, I wondered about that
17:04:22 <lispy> Kind of makes sense
17:04:23 <Cale> > let { five = 5; six = 6 } in succ + five.six $ 0
17:04:25 <lambdabot>   6
17:19:12 <aristid> :t foldr (.) id
17:19:12 <lambdabot> forall b. [b -> b] -> b -> b
17:19:32 <aristid> :t foldl' (.) id
17:19:33 <lambdabot> forall a. [a -> a] -> a -> a
17:19:39 <aristid> which of those is better?
17:19:50 <aristid> (if order does not really matter)
17:20:52 <lpsmith> aristid, order matters, associativity does not
17:20:57 <lpsmith> foldr is better in this case though
17:21:12 <hpc> > foldr (.) id [f, f, f, f] x
17:21:14 <lambdabot>   f (f (f (f x)))
17:21:19 <hpc> > foldl' (.) id [f, f, f, f] x
17:21:21 <lambdabot>   f (f (f (f x)))
17:21:35 <hpc> > foldl' (.) id [f, g, f, g] x
17:21:37 <lambdabot>   f (g (f (g x)))
17:21:38 <hpc> > foldr (.) id [f, g, f, g] x
17:21:40 <lambdabot>   f (g (f (g x)))
17:21:42 <hpc> neat
17:22:45 <aristid> > foldr (.) id [f, g, h] x
17:22:47 <lambdabot>   f (g (h x))
17:22:49 <lpsmith> well,  I take that back, I'm not sure which is better
17:22:54 <aristid> > foldl' (.) id [f, g, h] x
17:22:56 <lambdabot>   f (g (h x))
17:22:58 <lpsmith> My intuition says foldr though
17:23:49 <lpsmith> This might be one of those rare cases where foldl v foldl' isn't a big deal
17:24:47 <lpsmith> it might depend on the exact nature of the functions and data they operate on
17:24:50 <lpsmith> I mean
17:25:31 <lpsmith> > foldr (.) id [('h':),('e':),('l':),('l':),('o':)] []
17:25:32 <lambdabot>   "hello"
17:25:35 <enthymeme> is there a GHCi command to spit out the fixity of an operator?  Or do I have to browse the containing module.  
17:25:45 <lpsmith> enthymeme, :info
17:25:59 <enthymeme> :3 thanks!
17:26:00 <lpsmith> In my example case foldr is clearly better
17:26:13 <lpsmith> enthymeme, you are welcome :)
17:26:15 <enthymeme> and . is right associative
17:27:04 <lpsmith> good point,  that probably means that in most cases, foldr (.) id is better
17:27:06 <enthymeme> so unless you wanted to do some sort of crazy sectioning with the $ operator foldr would be the only viable way to get "(f.g.h) x", right?
17:27:25 <enthymeme> at least from the list [f,g,h]
17:27:43 <lpsmith> enthymeme, well,  (.) is associative,  so it doesn't matter if it's foldl or foldr
17:27:51 <lpsmith> (in terms of what is produced)
17:28:00 <lpsmith> but it can matter as far as performance is concerned
17:29:55 <BMeph> IMHANO, foldr is better because "forcing" the compositions doesn't actually accomplish anything. Well, I guess it consumes the 'id' immediately, but that's almost trivial. :)
17:30:01 <lpsmith> >  foldl (.) id (map (+) [1..10^7]) 0 
17:30:04 <lambdabot>   mueval-core: Time limit exceeded
17:30:12 <lpsmith> >  foldl (.) id (map (+) [1..10^6]) 0 
17:30:16 <lambdabot>   mueval-core: Time limit exceeded
17:30:21 <lpsmith> >  foldl (.) id (map (+) [1..10^5]) 0 
17:30:24 <lambdabot>   5000050000
17:30:35 <lpsmith> >  foldr (.) id (map (+) [1..10^6]) 0 
17:30:37 <lambdabot>   *Exception: stack overflow
17:30:44 <lpsmith> >  foldr (.) id (map (+) [1..10^5]) 0 
17:30:46 <lambdabot>   5000050000
17:31:26 <aristid> > foldr ($) 1 [f, g, h]
17:31:27 <lambdabot>   Ambiguous type variable `b' in the constraints:
17:31:27 <lambdabot>    `SimpleReflect.FromExpr ...
17:31:32 <aristid> > foldr ($) 1 [f, g, h] :: Expr
17:31:33 <lambdabot>   f (g (h 1))
17:31:40 * BMeph thinks -> This <- time, he may finally just shut up and stick to quirky comedy comments...
17:31:40 <aristid> > foldl' (flip ($)) 1 [f, g, h] :: Expr
17:31:42 <lambdabot>   h (g (f 1))
17:34:08 <absentia> nre
17:34:11 <absentia> re
17:34:11 <absentia> am I lagged?
17:34:36 <monochrom> I don't know.
17:34:41 <aristid> is there an elegant way to incrementally build up the contents of a record?
17:34:52 <monochrom> but you can /ping monochrom
17:35:32 <lpsmith> aristid, yeah,  the answer to your question is,  "it depends"
17:36:27 <lpsmith> http://hpaste.org/45195/microbenchmarks
17:37:04 <lpsmith> at least with ghc-6.12.3 on my machine,  test2 is faster than test0 on large inputs
17:37:55 <lpsmith> but in the "hello" example,  foldr should turn out to be better
17:38:04 <monochrom> wow, hlint can do foldr-map fusion!
17:38:27 <aristid> lpsmith: currently i build a list of Record -> Record functions, and apply them with foldr ($) (Record {})
17:38:41 <aristid> lpsmith: this gives warnings about uninitialized record members, of course :)
17:38:52 <lpsmith> well ($) isn't associative :)
17:39:08 <aristid> so?
17:39:16 <aristid> i don't have an initial valid record
17:39:59 <aristid> if all elements had the same type, i could use [(String, String)] or something like that
17:40:06 <lpsmith> well, because ($) isn't associative,  foldr ($) /= foldl ($)
17:40:25 <aristid> which should not matter in this case
17:41:02 <lpsmith> you can only freely interchange foldl op x and foldr op x when op and x form a monoid
17:41:21 <lpsmith> (i.e. op is associative and x is an identity)
17:41:42 <lpsmith> or rather,  the identity
17:42:03 <aristid> lpsmith: i don't need to FREELY interchange
17:42:29 <aristid> also i'm looking if there maybe are completely different options
17:44:17 <lpsmith> aristid, I'm not saying that you do.  :)   
17:44:17 <lpsmith> That's from your original question though
17:44:33 <aristid> those are only vaguely related :)
17:45:04 <lpsmith> well,  you can replace a foldr ($)  with a foldr (.) with minimal hassle
17:45:21 <lpsmith> let me think for a moment for the exact law
17:45:41 <lpsmith>    foldr ($) x fs  == foldr (.) id fs x
17:45:45 <lpsmith> I believe
17:46:38 <lpsmith> and of course, once you are using (.),  you can freely replace that with foldl',  which should be better if your functions are strict
17:46:55 <lpsmith> but if your functions are non-strict,  I'm guessing that foldr is usually better
17:46:59 <lpsmith> well, often
17:48:57 <aristid> lpsmith: and if order does not matter, how about foldl' (flip ($)) initialValue?
17:49:18 <lpsmith> aristid, that should work too
17:49:39 <danharaj_> God. Marshalling data between Haskell and OpenGL is a pain.
17:50:06 <warzl> can someone pm me so IO can test my irc client?
17:50:27 <ion> lambdabot can.
17:50:35 <lispy> danharaj_: how so?
17:51:09 <danharaj_> lispy: I haven't done marshalling before so it's a bit rough. I'm not very good at Haskell.
17:51:10 <warzl> hm, doesn't work
17:51:12 <warzl> thanks tho
17:51:46 <lispy> danharaj_: Well, allocaBytes and pookArray help a lot
17:51:52 <lispy> danharaj_: do you need some example code?
17:51:59 <lispy> peekArray*
17:52:32 <danharaj_> lispy: nah. I seem to be managing. Most of the effort is trying to organize the opengl raw api in my head so that I can write a nice wrapper for it.
17:53:00 <dmwit> pookArray... a fellow Dvorak typist!
17:53:02 <lispy> danharaj_: several of us have been talking about it.  We should all band together
17:53:34 <danharaj> You have my sword.
17:53:37 <lispy> dmwit: I do use dvorak, but how was that a clue? :)
17:54:13 <dmwit> You can't possible miss 'e' and hit 'o' on a qwerty keyboard, but it's dead simple to on a dvorak one.
17:54:15 <danharaj> lispy: I think the part I would be most eager to take part in is writing a DSL for GLSL, but I bet everyone knows that's where the fun is at :p
17:54:15 <lispy> usually my tell tale sign of using dvorak is switching r and l
17:54:27 <danharaj> I also use dvorak, high five.
17:54:29 <lpsmith> BMeph,  foldl' (.) has the advantage of putting the function to be applied first closest to the argument, which matters a bit if the function is strict
17:54:29 <warzl> is dvorak better on your wrists?
17:54:34 <danharaj> People freak out when they're trying to use my home board.
17:54:36 <dmwit> warzl: meh
17:54:56 <dmwit> warzl: If you want something good for your wrists, using an ergonomic keyboard matters much more than which layout you use.
17:55:03 <danharaj> I have found that what really helps your wrists is making sure they're properly aligned with your keyboard.
17:55:05 <dmwit> I use a Kinesis Advantage and I love it.
17:55:14 <lispy> kinesis is nice
17:55:19 <warzl> I'm using kinesis freestyle
17:55:24 <warzl> not a big difference so far
17:56:01 <lpsmith> e.g.   (big_composition . f) 1  == big_composition (f 1) versus  (f . big_composition) 1,  you have to keep examining more of the closures of big_composition before you can apply the function
17:56:09 <lispy> danharaj: I'm okay with GLSL, so I haven't been thinking about a DSL for it.  I think Pseudonym said he made a DSL for GPU shaders before GLSL was even at thing.
17:56:41 <danharaj> lispy: that's cool. Is there a mailing list or irc channel I can loiter in to catch the winds of ambition as they rise?
17:56:43 <lispy> danharaj: Where OpenGL is concerned, I think a scene graph DSL would be very interesting.
17:56:52 <Twey> warzl: Considerably better, I'd say.  I get wrist-strain if I use QWERTY for too long, but Dvorak's just lovely.
17:57:14 <lispy> danharaj: #haskell-game and the hopengl mailing lists.  There is a group on haskellers.com for game dev
17:57:16 <warzl> do you notice more strain on your left wrist with qwerty?
17:57:48 <lpsmith> the coolest thing about the kinesis,  IMO, is that it makes good use of your thumbs,  whereas a standard keyboard devotes both thumbs to one key
17:57:55 <lispy> danharaj: haskell-game group and the opengl group are small enough that we're sort of the same group at the moment
17:58:08 <lpsmith> (though I haven't used a kinesis enough to get comfortable with it)
17:58:17 <danharaj> lispy: ok. Someone should make a bounty board of ideas/api's people should pursue :)
17:58:30 <gio123> dmwit:haskel-blah :)
17:58:51 <lispy> danharaj: yeah, there are lots of little "marketing" things that we should be doing to keep and build excitement
17:59:15 <dmwit> gio123: Yes, sorry, you're right. Keyboards are off-topic here.
17:59:38 <lispy> danharaj: I keep a personal TO DO list on workflowy.com and then for some of the library ideas that I have on there I put them on reddit.com/r/haskell_proposals
18:00:01 <warzl> it might be on topic to discuss what keyboards haskell people like in particular :)
18:00:18 <gio123> nooo
18:00:20 <lispy> danharaj: For example, I'm currently working on a freetype2 binding that I also listed on r/haskell_proposals and got some feedback from redditors.
18:00:24 <gio123> dmwit:nooo
18:00:24 <danharaj> mm
18:00:38 <gio123> dmwit: I have question in haskell-blah :)
18:00:44 <gio123> because i invite dthere
18:00:46 <danharaj> lispy: I'm sort of green when it comes to Haskell, have only made toy projects, and mostly a newbie at OpenGL, so a way to quickly find my bearings on how to be industrious would be great. I have a particular application I have in mind that uses OpenGL.
18:01:56 <lispy> danharaj: Well, I find that writing down what I learn (frequent brain dumps) and sharing that information helps me a lot.  Sharing it means blog posts, bug reports, emails to the appropriate mailing list, etc.
18:02:19 <danharaj> lispy: oi. I'll have to sneak some of that in between uni work :)
18:02:28 * lispy nods
18:03:08 <lispy> I do recommend workflowy.com for tracking your tasks.  Some people swear by GTD.  YMMV.
18:03:21 * lispy goes to hack on freetype2
18:04:35 <danharaj> lispy: mm. I think I'll start hunting around for bits of API that would be useful to implement. I think I'll work on managing opengl objects in a sane way first.
18:06:20 <aristid> workflowy.com has a pretty slick interface
18:11:26 <Taslem> Why was I just presented with a picture of a unicorn?
18:11:48 <tg_> Taslem: when presented with a unicorn, it is customary to bow instead of question it.
18:12:36 <Taslem> ... No, I'm serious. What the heck is a unicorn doing in the channel news?
18:12:42 * BMeph bowed
18:12:42 <Axman6> they are not beasts who should ever be questioned, lest you unfurl their wrath upon yourself
18:13:03 <Axman6> Taslem: it's not channel news, it the network MOTD i believe
18:13:19 <Taslem> Ah, right. It's hard to see, it only appears for a half second.
18:13:22 <Axman6> that's why it says welcome to freenode at the top, with two more unicorns
18:13:34 <Axman6> it flashed in irssi -_-
18:15:56 <fryguybob> cabal install pony
18:16:39 <Taslem> Are there any games that have been written successfully in Haskell?
18:16:59 <danharaj> RainCat
18:18:05 <Axman6> frag
18:20:11 <Taslem> How can you perform a pattern-match as an expression?
18:20:21 <Axman6> what do you mean?
18:20:40 <allbery_b> there used to be an implementation of  Fluxx but I've never been able to get beyond the google link that goes nowhere
18:20:42 <lispy> Taslem: there are currently 74 packages just on hackage in the "Game" section.  Many of which are games: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
18:20:47 <Makoryu> Taslem: Haskell doesn't have first-class pattern matches, if that's what you're asking
18:21:37 <Makoryu> Taslem: The only way to pass a pattern match around as a value is to make it a function
18:21:46 <Taslem> Aw, that's too bad.
18:23:33 <Axman6> Taslem: it would help if you explained what you wanted
18:24:20 <Taslem> WHere    data C a = C a,                 performing f (C a) = a,   without that function definition.
18:24:42 <Axman6> (\(C a) -> a)?
18:24:52 <Axman6> how else would you propose doing that?
18:24:58 <Axman6> we have records also
18:24:59 <Taslem> Yeah, I know. Just wondering if there was a less verbose way.
18:25:24 <Axman6> data C a = C {unC :: a}
18:25:27 <Taslem> It's for a property of an unknown constructor until its proper pair shows up.
18:25:35 <aristid> the siren of the Applicative can be pretty loud at times
18:25:54 <Axman6> that doesn't sound at all well typed
18:26:59 <Philippa> Taslem: do you just want case statements?
18:27:08 <Taslem> No, the issue is that it's essentially "filtering" a list of properties. And it filters them by constructor. And the type is recursive. No, not cases.
18:27:28 <Axman6> i still can't tell what you're after
18:27:54 <Philippa> ah. You could build "recogniser" functions that return Maybe result, and Nothing is a match failure?
18:28:11 <Philippa> then you can use chains of them where appropriate
18:28:51 <Philippa> nesting gets a little bit trickier, but you could probably use the Maybe monad for it
18:28:55 <Taslem> Yeah, it looks like I might have to redesign it. The problems I'm having are because I don't know exactly what I need the program to be capable of.
18:31:04 <aristid> with Applicative i can do structure analysis, right? because the structure is static
18:31:14 <aristid> if i want to optimise some kind of parser
18:31:27 <aristid> i'm not sure if i'm getting this right
18:36:41 <Philippa> aristid: you can, yes
18:36:53 <Philippa> not just for parsers, but yeah
18:55:52 <chomp> if i have a function f :: (a -> b) and g :: (b -> c), is there a more elegant way to (inline) express a function h :: (a -> c) than simply writing (let h x = g (f x) in h) ?
18:56:26 <chomp> mind you i realize that's fairly elegant in itself, i'm just wondering as a newb if there's a more idiomatic expression
18:56:43 <hpc> chomp: have we got the function for you :P
18:56:45 <hpc> :t (.)
18:56:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:56:49 <hpc> er
18:56:54 <hpc> :t (Prelude..)
18:56:54 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:56:57 <chomp> oooh, i llike the sound of that
18:56:59 <hpc> lambdabot is kind of strange
18:57:08 <hpc> (.) is what you will use
18:57:29 <chomp> i have to say, this is the first language i've learned that i actually like more as i learn more about it
18:57:35 <chomp> :>
18:57:38 <hpc> :D
18:57:54 <chomp> save the best for last, i guess
18:59:24 <hpc> chomp: it's kind of ridiculous how many ways you can abstract (.) in haskell
18:59:29 <hpc> :t <=<)
18:59:30 <lambdabot> parse error on input `<=<'
18:59:33 <hpc> :t (<=<)
18:59:34 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
18:59:38 <hpc> :t (<<<)
18:59:39 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
19:00:02 <hpc> i am probably forgetting a couple
19:06:29 <aristid> hpc: (<=<) is different from (.) :)
19:06:51 <hpc> aristid: yeah, but still
19:07:12 <hpc> oh duh, fmap can be (.)
19:09:31 <pumpkin> :t (.) `on` Identity
19:09:32 <lambdabot>     Couldn't match expected type `a -> a'
19:09:32 <lambdabot>            against inferred type `Identity a1'
19:09:32 <lambdabot>     In the second argument of `on', namely `Identity'
19:11:06 <pumpkin> @ty ((fmap Identity .) .) (.) `on` (runIdentity .)
19:11:06 <lambdabot> forall a. (a -> Identity a) -> (a -> Identity a) -> a -> Identity a
19:16:17 <aristid> :t \f g -> Identity . f . runIdentity <=< Identity . g . runIdentity
19:16:18 <lambdabot> forall a a1 a2. (a1 -> a) -> (a2 -> Identity a1) -> Identity a2 -> Identity a
19:16:44 <aristid> :t \f g -> Identity . f <=< Identity . g . runIdentity
19:16:45 <lambdabot> forall a b a1. (b -> a) -> (a1 -> b) -> Identity a1 -> Identity a
19:16:49 <pumpkin> tsk tsk
19:17:00 <aristid> @pl \f g -> Identity . f <=< Identity . g . runIdentity
19:17:00 <lambdabot> (line 1, column 22):
19:17:00 <lambdabot> unexpected "=" or "<"
19:17:00 <lambdabot> expecting variable, "(", ".", space, operator or end of input
19:17:00 <lambdabot> ambiguous use of a left associative operator
19:17:07 <aristid> wtf
19:17:26 <aristid> @pl \f g -> Identity . f `qqq` Identity . g . runIdentity
19:17:26 <lambdabot> (line 1, column 22):
19:17:26 <lambdabot> unexpected "`"
19:17:26 <lambdabot> expecting variable, "(", ".", space, operator or end of input
19:17:26 <lambdabot> ambiguous use of a left associative operator
19:17:39 <aristid> @pl \f g -> qqq (Identity . f `qqq` Identity . g . runIdentity
19:17:39 <lambdabot> (line 1, column 27):
19:17:39 <lambdabot> unexpected "`"
19:17:39 <lambdabot> expecting variable, "(", ".", space, operator or ")"
19:17:40 <lambdabot> ambiguous use of a left associative operator
19:17:47 <aristid> @pl \f g -> qqq (Identity . f) (Identity . g . runIdentity)
19:17:47 <lambdabot> (. ((Identity .) . (. runIdentity))) . qqq . (Identity .)
19:18:02 <aristid> :t (. ((Identity .) . (. runIdentity))) . (<=<) . (Identity .)
19:18:03 <lambdabot> forall a b c. (b -> c) -> (a -> b) -> Identity a -> Identity c
19:18:21 <aristid> pumpkin: totally easy to do this point-free ;)
19:26:03 <chomp> hmm what if i want to composite higher-order functions like (a -> b -> c) with (c -> c -> c)
19:27:32 <parcs> :t (.:)
19:27:33 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:28:25 <parcs> :t (undefined :: (c -> c -> c)) .: (undefined :: a -> b -> c)
19:28:26 <lambdabot> forall a a1 b. a1 -> b -> a -> a
19:29:22 <hpc> parcs: hey, cheater!
19:29:43 <aristid> :t \f g a b c d -> f (g a b) (g c d)
19:29:43 <lambdabot> forall t t1 t2 t3. (t2 -> t2 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t -> t1 -> t3
19:29:56 <aristid> @pl \f g a b c d -> f (g a b) (g c d)
19:29:57 * applicative just looked above in the log and saw <hpc> chomp: have we got the function for you :P
19:29:58 <lambdabot> join . ((flip . ((flip . (((.) . (.)) .)) .)) .) . (.) . (.)
19:30:02 <aristid> HAHAHA
19:30:23 <hpc> whoa
19:31:11 <chomp> my brain, it is teh hurt.
19:31:24 <applicative> @unpl join . ((flip . ((flip . (((.) . (.)) .)) .)) .) . (.) . (.)
19:31:24 <lambdabot> (\ x -> (\ as b c f i l -> x (as c f) (b i l)) >>= \ y -> y)
19:31:40 <applicative> good luck perceiving the identity there...
19:33:00 <aristid> :t \f g a b-> f (g a) (g b)
19:33:00 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
19:33:07 <aristid> :t on
19:33:08 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:34:14 <aristid> :t \f g -> f `on` uncurry g
19:34:15 <lambdabot> forall c a b c1. (c1 -> c1 -> c) -> (a -> b -> c1) -> (a, b) -> (a, b) -> c
19:34:53 <applicative> chomp: I hope our friends aren't alarming you....
19:35:26 <chomp> as far as i can tell this is the greatest language ever conceived
19:35:36 <parcs> :t curry .: curry .: (\f g -> f `on` uncurry g)
19:35:37 <lambdabot> forall a b c b1 c1. (c1 -> c1 -> c) -> ((a, b) -> b1 -> c1) -> a -> b -> b1 -> ((a, b), b1) -> c
19:35:46 <parcs> hmmm, nevermind
19:36:51 <aristid> :t \f g -> curry .: curry (f `on` uncurry g)
19:36:51 <lambdabot> forall a b c c1. (c1 -> c1 -> c) -> (a -> b -> c1) -> a -> b -> a -> b -> c
19:36:56 <aristid> parcs: this? :)
19:37:10 <parcs> yeah@
19:37:12 <parcs> !*
19:37:23 <c_wraith> that's certainly better than what lambdabot provided, but it's still not good. :)
19:37:49 <aristid> c_wraith: well i think \f g a b c d -> f (g a b) (g c d) is the best
19:53:12 <xplat> pointfree is nice, but variables are a great shortcut when you're shuffling data around as much as you're doing things with it
19:56:06 <shachaf> xplat: Some RPN programmers might disagree with you.
20:04:27 <xplat> to me, the great thing about pointfree programming is you don't have to let variable names get in the way of your logic.  and the great thing about pointful programming is you don't have to let '(flip .) . (.) . (flip flip . join)' get in the way of your logic.
20:04:59 <xplat> it's nice to have multiple tools in your toolbox
20:07:02 <xplat> even forth programmers keep their new words in a dictionary, not on the stack
20:07:14 <pumpkin> @remember xplat to me, the great thing about pointfree programming is you don't have to let variable names get in the way of your logic.  and the great thing about pointful programming is you don't have to let '(flip .) . (.) . (flip flip . join)' get in the way of your logic. it's nice to have multiple tools in your toolbox
20:07:14 <lambdabot> It is stored.
20:08:43 <parcs> someone here once said that if you find a point-free definition to be unreadable then you haven't defined yet the proper combinators
20:09:29 <shachaf> A Factor programmer I know, at least, says that it's generally better-suited to point-free style than Haskell.
20:27:48 <joe6> i used gforth for a program once and it was a pita to understand after a few weeks..
20:28:19 <joe6> again, the comments were not that great, either. But, readability is a big issue for forth-based programs.
20:29:19 <joe6> the good thing about pointfree is that the types help deciphering a lot of information. Without the types, it might as well be forth..
21:02:12 <scutigera> tap tap tap is this thing on ?
21:03:14 <enthymeme> hehe
21:03:34 <enthymeme> is it just me or does the Value/Entity/Service distinction in Domain Driven Development sound haskellish?
21:04:12 <scutigera> mmmm, sounds a little bit buzzword compliantish - maybe from the back of an IBM sales brochure ?
21:13:16 <lispy> okay, now cabal builds the freetype2 code.  Time to add an .hsc file and see if I can bind to the init function and then call it from a different haskell project
21:13:24 <Boxo> In factor you have dup and swap and so on to help you pointfree. How would you write those in haskell... :o
21:13:56 <jmcarthur> write what in haskell? dup and swap?
21:14:22 <Boxo> something that corresponds to them that you can use to similarly ease pointfree programming
21:14:28 <jmcarthur> sounds like maybe join and flip
21:14:47 <jmcarthur> :t join :: (a -> a -> b) -> a -> b
21:14:48 <lambdabot> forall a b. (a -> a -> b) -> a -> b
21:14:53 <jmcarthur> :t flip
21:14:54 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
21:14:56 <ddarius> :t uncurry (flip (,))
21:14:57 <lambdabot> forall b a. (a, b) -> (b, a)
21:15:06 <Boxo> maybe
21:15:12 <jmcarthur> :t Prelude.flip
21:15:13 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
21:15:16 <ddarius> :t id&&&id
21:15:17 <lambdabot> forall b. b -> (b, b)
21:15:46 <djahandarie> :t join (&&&) id
21:15:46 <lambdabot> forall c. c -> (c, c)
21:15:48 <jmcarthur> i was thinking in terms of arguments to a function
21:16:04 <jmcarthur> since that is essentially what the forth/factor stack is
21:16:51 <jmcarthur> as a bonus, they read left to right with the function, too
21:17:08 <jmcarthur> so you can say "join foo" to mean "dup foo" and "flip bar" to mean "swap bar"
21:18:35 <Boxo> drop ~= const
21:19:17 <ddarius> W, C, K
21:20:33 <Boxo> what an awesome correspondence! translating between factor and haskell!
21:20:42 <monochrom> dup (x:rest) = x:x:rest
21:20:51 <monochrom> swap (x:y:rest) = y:x:rest
21:20:53 <monochrom> etc.
21:23:38 <ddarius> stack xs = xs:xs
21:23:51 <radicalpumpkin> caballero!
21:24:09 <radicalpumpkin> http://www.yesodweb.com/blog/rails-can-scale
21:29:24 <scutigera> I can pronounce Yesod easier than Caballero
21:29:39 <scutigera> rollsome !
21:29:41 <radicalpumpkin> scutigera: ;)
21:30:48 <scutigera> and I'm watching the _whole_ thing...
21:31:55 <scutigera> radicalpumpkin: and what timezone are you in? ...
21:32:09 <radicalpumpkin> east coast US :)
21:32:34 <scutigera> radicalpumpkin: I'm west, can I call a foul ?
21:34:17 <scutigera> radicalpumpkin: too funny ! :-)
21:39:43 <chomp> son of a
21:39:56 <radicalpumpkin> mother?
21:39:59 <radicalpumpkin> father?
21:40:01 <chomp> well one thing is for sure.  we are no strangers to love.
21:41:42 <scutigera> love is like oxygen.  all you need is love.
21:41:51 <scutigera> and haskell, of course
21:42:07 <chomp> i'll take a beer too while we're at it
21:44:08 <enthymeme> man, haddock is awesome
21:45:21 <scutigera> enthymeme: do tell - when I looked at it, I thought special notation for the _code_ ?? However it's sure makes pretty documentation.
21:51:45 <scutigera> anybody know the secret to make haskell mode indent correctly in less than 5 tries ?  is there a super-secret indent mode ?
21:53:11 <scutigera> copumpkin: aha - I knew it !  your disguise didn't fool me.
21:53:53 <copumpkin> :P
21:56:21 <scutigera> and so it begins... http://www.debian.org
21:57:47 <Jafet> I thought that was where you ended up, after trying everything else.
21:58:10 <copumpkin> debian is a terminal object in the category of distributions?
21:58:13 <chomp> -_o
21:58:32 <chomp> that sounds like a terrible idea
22:00:21 <ion> chomp: I’m enthusiastic about it. It can be awesome, like the combination of Haskell and PHP that exceeded everyone’s expectations.
22:00:53 <enthymeme> okay, what the hell with the color abuse from the server
22:01:28 * monochrom unleashes http://www.vex.net/~trebla/haskell/exception.xhtml
22:01:50 <c_wraith> enthymeme: pay attention to the date.  especially the date globally
22:01:51 <monochrom> @tell DRMacIver http://www.vex.net/~trebla/haskell/exception.xhtml
22:01:51 <lambdabot> Consider it noted.
22:01:59 <monochrom> @tell Berengal http://www.vex.net/~trebla/haskell/exception.xhtml
22:01:59 <lambdabot> Consider it noted.
22:02:20 <enthymeme> ah, AFD.
22:02:33 <c_wraith> yep
22:02:45 <c_wraith> prepare for the whole internet to be full of bad colors and bad ideas
22:02:48 <ion> No, it’s tomorrow.
22:06:00 <c_wraith> ion: 4/1 lasts for approximately 48 hours, globally.  You need to be aware of the whole range of time it's 4/1, online.
22:11:22 <scutigera> using an FFI and I need the right thing for NULL, is nullPtr the right thing ?
22:12:04 <c_wraith> yes
22:12:20 <scutigera> merci.
22:45:45 <mm_freak> a memory leak in GHC just killed my whole system
22:45:55 <mm_freak> worst thing is, i cannot reproduce it
22:48:22 <Jafet> You... can't remember how?
23:04:11 <mm_freak> Jafet: i just compiled as usual, and it said something along those lines: "The impossible happened! April screws you!"
23:07:17 <hvr> is it normal, that when I run something that's supposed to be single-threaded, with -N4 it becomes _much_ slower than not using -N at all?
23:07:50 <mm_freak> hvr: if it does no multithreading, then the -N switch shouldn't change anything
23:08:05 <mm_freak> if it makes it slower, then your multithreading may be poor
23:08:07 <hvr> i.e. I'm just parsing an 8MiB JSON file with aeson, and it goes from 5 seconds to 25 seconds
23:08:24 <hvr> just by using -N6
23:08:45 <hvr> I don't use any `par` or `forkIO` stuff
23:09:10 <hvr> (GHC 7.0.2 btw)
23:09:24 <mm_freak> that's unusual
23:10:33 <hvr> I'm wondering whether attoparsec uses `par`
23:10:58 <napping> this is the same program, just using -N or not?
23:11:09 <hvr> yes, same compiled binary
23:11:27 <hvr> bascially just a
23:11:31 <hvr> decode = either Error fromJSON . APL.eitherResult . APL.parse json
23:11:48 <hvr> followed by some deepseq's
23:11:51 <napping> I think it's using the threaded runtime and locks and everything either way.
23:12:16 <napping> I wouldn't expect that to make things so much slower
23:13:01 <hvr> maybe it's just worker-migration overhead?
23:13:25 <hvr> but should the runtime try to keep evaluation on one worker if the programm doesn't require distribution?
23:13:57 <hvr> in top I see that the worker all get processing time
23:16:08 <napping> you could try running with an event log
23:16:12 <napping> http://research.microsoft.com/en-us/projects/threadscope/
23:16:42 * hackagebot mime-mail 0.3.0 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.3.0 (MichaelSnoyman)
23:16:44 * hackagebot pool 0.1.0 - Thread-safe resource pools.  http://hackage.haskell.org/package/pool-0.1.0 (MichaelSnoyman)
