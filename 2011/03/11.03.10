00:00:03 <robryk> in definition of add, in first argument of m
00:01:03 <robryk> i can get it to work by reducing out n from the definition
00:01:21 <robryk> but i can't do the same with multiplication
00:01:28 <kmc> robryk, you're using the two numerals at different types, yes?
00:01:41 <robryk> all my numerals are forall types
00:01:51 <kmc> they're synonyms
00:02:08 <robryk> yes
00:02:17 <kmc> i'm not sure if a synonym on the left of a (->) really gives you a rank-2 function type
00:02:29 <robryk> what else?
00:02:46 <robryk> and why it should start working when i define it as add m = m inc ?
00:03:53 <kniu> robryk, does it?
00:04:00 <robryk> it does typecheck then
00:04:05 <kniu> hm
00:06:37 <kmc> it works if you change the synonym to an explicit wrapper type
00:07:27 <robryk> but why doesn't it work now? i cannot think of where to put a type qualification to make it work and i cannot see why it can't be well-typed now
00:07:50 <kmc> maybe the expansion of type synonyms with forall's is not hygenic
00:08:03 <kmc> or is strange in some other way
00:08:22 <kmc> if all the forall's got shoved to the left, it wouldn't work
00:08:57 <robryk> if i manually replace Numeral with its meaning
00:09:01 <robryk> i get a similar error
00:09:23 <robryk> complaining about expecting forall a. <def of numeral> instead of <inside of def. of numeral>
00:10:00 <levifikri> simple question, how to convert Seq to List?
00:10:07 <kmc> levifikri, Data.Foldable.toList
00:10:23 <kmc> you can use all the Foldable stuff with Seq
00:14:35 <levifikri> If I were to convert a Seq into a List, then convert it again to Seq. Would it hurt performance too much?
00:14:56 <levifikri> The problem is, I need to use a function that is only provided for List, i.e. takeWHile
00:15:51 <shachaf> @ty Data.Sequence.takeWhileL
00:15:52 <lambdabot> forall a. (a -> Bool) -> Seq.Seq a -> Seq.Seq a
00:15:53 <shachaf> @ty Data.Sequence.takeWhileR
00:15:53 <lambdabot> forall a. (a -> Bool) -> Seq.Seq a -> Seq.Seq a
00:17:12 <levifikri> shachaf, oh.. Why it is not in the documentation? http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html
00:17:41 <shachaf> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
00:19:57 * hackagebot hmeap 0.10 - Haskell Meapsoft Parser  http://hackage.haskell.org/package/hmeap-0.10 (RohanDrape)
00:20:38 <kmc> that's some 2-year-old version of 'containers'
00:20:57 * hackagebot hmeap-utils 0.10 - Haskell Meapsoft Parser Utilities  http://hackage.haskell.org/package/hmeap-utils-0.10 (RohanDrape)
00:26:28 <freedrull> meapsoft?
00:27:24 <freedrull> oh, meapsoft
00:28:00 * hackagebot hsc3-sf 0.9 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-0.9 (RohanDrape)
00:34:01 * hackagebot hsc3-graphs 0.9 - Haskell SuperCollider Graphs  http://hackage.haskell.org/package/hsc3-graphs-0.9 (RohanDrape)
00:44:58 <hpaste> adrake pasted "Test.class"  http://hpaste.org/44660
00:59:19 <Ptival> @pl \l -> head (['a'..'z'] \\ l)
00:59:20 <lambdabot> (line 1, column 24):
00:59:20 <lambdabot> unexpected "\\"
00:59:20 <lambdabot> expecting variable, "(", operator or ")"
00:59:49 <Ptival> @pl \l -> head (Data.List.(\\) ['a'..'z'] l)
00:59:49 <lambdabot> (line 1, column 25):
00:59:49 <lambdabot> unexpected "\\"
00:59:49 <lambdabot> expecting pattern
00:59:52 <Ptival> :\
01:00:17 <quicksilver> just use a different operator, I guess
01:00:31 <quicksilver> @pl \l -> (head (['a'..'z'] ** l)
01:00:32 <lambdabot> (line 1, column 30):
01:00:32 <lambdabot> unexpected end of input
01:00:32 <lambdabot> expecting variable, "(", operator or ")"
01:00:36 <Ptival> @pl \l -> head (['a'..'z'] ++ l)
01:00:36 <lambdabot> head . (['a'..'z'] ++)
01:00:43 * quicksilver nods
01:01:01 <Ptival> thanks :)
01:01:19 <Ptival> it's so easy I should be shameful
01:03:05 <Ptival> oh
01:04:04 <Ptival> I can't pattern match equal arguments, like f a a = ... when f :: a -> a -> ... ?
01:04:29 <Ptival> f a b | a == b = ?
01:08:45 <quicksilver> Ptival: correct, you cannot, and the guard is the right way to do it.
01:22:44 <mercury^> That seems to be somethingthat could be added though.
01:23:54 <mercury^> As far as I can see it is completely harmless, self-explanatory and useful.
01:28:15 <quicksilver> mercury^: it would require an Eq instance
01:28:39 <quicksilver> and it would imply computaiton in a way that simple pattern matches normally do not.
01:45:12 <hpaste> MaxJadi pasted "Error "  http://hpaste.org/44661
01:47:11 <maxJadi> Hi, I got this error "http://hpaste.org/44661/error" when i want to install quickcheck, do you Have any Idea?
01:52:37 <Saizan> maxJadi: ghc-pkg list ghc ?
01:57:13 <maxJadi> "/usr/lib/ghc-6.12.3/package.conf.d" It seems that I should update my ghc ...
01:57:40 <Saizan> not necessarily
01:57:58 <Saizan> if you only get that it means you are missing the "ghc" library
01:58:14 <Saizan> which is the library interface to ghc
01:58:26 <Saizan> maybe you package manager puts that in a separate package
01:58:51 <Saizan> though with ghc-7+ QuickCheck will no longer depend on that lib
02:00:44 <Saizan> if you were missing the ghc compiler you'd be getting a different error message
02:04:00 <maxJadi> Saizan, So I'll wait for new version of Fedora which comes with ghc-7+ :)    Thank you
02:05:41 <weirdo> @pl (\x y -> x * 10 + y)
02:05:42 <lambdabot> (+) . (10 *)
02:09:28 <Saizan> maxJadi: or you could install something like ghc-devel
02:09:42 * Saizan never used fedora though
02:16:25 <zeke> Okay, I've been playing with using the List Monad using monadic syntax (>>= and return), and it's awesome. Just something I found while doing this that it looks like liftM accomplishes the same task as map on lists. Anyone know if this is a perfect, IE liftM can be used for all cases map would be, or is there some cases where map performs correctly and liftM wouldn't?
02:16:34 <zeke> > map (*10) [1..10]
02:16:34 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
02:16:51 <zeke> > liftM (*10) [1..10]
02:16:52 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
02:17:10 <ceii> @t liftM
02:17:10 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
02:17:16 <ion> @src liftM
02:17:16 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:17:17 <ion> @src fmap
02:17:18 <lambdabot> Source not found. That's something I cannot allow to happen.
02:17:18 <ceii> @type liftM
02:17:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:17:29 <ceii> sure, it's the same as map
02:17:31 <jonkri> hdbc vs hsql vs haskelldb? :)
02:18:16 <Saizan> flip a 3-sided coin
02:18:38 <jonkri> :)
02:19:00 <ion> > (fmap (+1) (Just 42), fmap (+1) Nothing, liftM (+1) (Just 42), liftM (+1) Nothing)
02:19:01 <lambdabot>   (Just 43,Nothing,Just 43,Nothing)
02:21:00 <yitz> @check \f x -> fmap f x == liftM f x
02:21:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
02:21:01 <lambdabot>    arising from a use of `...
02:22:06 <yitz> @check \n x -> fmap (+n) x == liftM (+n) x
02:22:06 <lambdabot>   No instances for (Test.QuickCheck.Arbitrary (f a),
02:22:07 <lambdabot>                    GHC.S...
02:47:35 <weirdo> is there some util that removes redundant parentheses?
02:47:41 <weirdo> i don't want to abuse @pl too much
02:47:49 <weirdo> since it all goes to the channel
02:48:53 <sipa> you can do it in pm
02:48:57 <sipa> with the bot
02:54:25 <sphynx> weirdo: also "cabal install pointfree" brings @pl to your home :)
02:55:42 <weirdo> :-))
02:57:53 <hvr_> is there somewhere a haskell operator precendence cheatsheet for prelude operators?
02:58:13 <hvr_> (and if yes, where :) )
02:58:50 <mauke> in the report, probably
02:58:55 <mauke> @where report
02:58:55 <lambdabot> http://www.haskell.org/onlinereport/
02:59:02 <sipa> http://www.haskell.org/onlinereport/decls.html#fixity
02:59:22 <hvr_> sipa: thx!
02:59:32 <mauke> hlint also does that
03:00:02 <hvr_> yes, that's good too; I just wanted something to pin to the wall as a reminder
03:00:28 <hvr_> since every language has subtle differences in the fixity of its operators (except for LISP/Scheme...)
03:01:29 <mauke> I don't know, the only language that really surprised me there was pascal
03:01:41 <weirdo> what does this declaration do? where q     = p*p; (h,t) = span (< q) xs
03:01:47 <mauke> but maybe it's because most of my languages are C-based and Haskell doesn't share much with C
03:06:58 <yitz> hvr_: grep infix Prelude.hs | sort
03:12:23 <weirdo> meow?
03:16:16 <sphynx> weirdo: take a look on "span" description here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#g:11
03:16:43 <weirdo> oh, wait! (h,t) is a non-function definition, right?
03:16:46 <sphynx> in short: it divides list on two lists
03:16:59 <weirdo> i thought only functions were allowed in "where" clauses... stupid me
03:17:04 <weirdo> thank you :-)
03:17:06 <sphynx> (h,t) is a tuple of two lists (head and tail)
03:17:27 <sipa> it's a pattern match
03:17:32 <sphynx> yes, you can do pattern matching in where
03:19:41 <sphynx> so you can write something like: "where x:xs = some_function_returning_list" or "where (h, t) = span (>2) xs" etc.
03:52:37 <weirdo> > pure 42
03:52:38 <lambdabot>   No instance for (GHC.Show.Show (f t))
03:52:38 <lambdabot>    arising from a use of `M7653558943...
03:52:54 <weirdo> what is this i don't even
03:53:43 <sipa> :t pure
03:53:44 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
03:53:56 <ion> > pure 42 :: Maybe Integer
03:53:57 <lambdabot>   Just 42
03:54:09 <ion> > pure 42 :: [Integer]
03:54:10 <lambdabot>   [42]
03:55:46 <TaTonka> hey, i have a question. for uni, we have to redefine the elem function, and there i get an error i am not used to.
03:56:04 <TaTonka> the error is "08032011.hs:77:25: parse error (possibly incorrect indentation)"
03:56:08 <weirdo> thank you
03:56:09 <TaTonka> and the function is
03:56:26 <TaTonka> elem' :: [Char] -> Char -> Bool
03:56:27 <TaTonka> elem' [] c = False
03:56:27 <TaTonka> elem' (x:xs) c
03:56:27 <TaTonka> 			| (x == c) = True
03:56:27 <TaTonka> 			| otherwise elem' xs c
03:56:39 <TaTonka> the last line is line 77 in my source file...
03:56:52 <weirdo> otherwise =
03:56:56 <parcs> otherwise is an expression that evaluates to True
03:57:00 <parcs> it is not syntactic sugar
03:57:06 <parcs> :t otherwise
03:57:07 <sphynx> weirdo: "pure" is a generic way to put a pure value (in our case number 42) in some container (or you may call it computational context). So here you can put 42 in list or a Maybe, getting [42] or (Just 42)
03:57:07 <lambdabot> Bool
03:57:21 <TaTonka> ah okay, thanks
03:57:45 <weirdo> sphynx, thank you. i was trying to do pure 42 :: Maybe but it didn't work. i suppose i don't know kinds all too well
03:57:57 <ion> It’s to applicative functors what return is to monads. (They should be the same thing, really.)
03:58:37 <sphynx> weirdo: although "pure" is from Control.Applicative module, so it's mainly used while you are writing the code in Applicative style
03:59:00 <weirdo> i'm on one of the last chapters of LYAH
03:59:11 <weirdo> it's becoming harder and harder as i go
03:59:13 <sphynx> weirdo: you can nicely apply effectful functions to effectful arguments with Applicative
03:59:31 <sphynx> > pure (+) <*> Just 2 <*> Just 3
03:59:32 <lambdabot>   Just 5
03:59:40 <sphynx> or even better:
03:59:57 <sphynx> (+) <$> Just 2 <*> Just 3
04:00:03 <sphynx> > (+) <$> Just 2 <*> Just 3
04:00:04 <lambdabot>   Just 5
04:00:17 <sphynx> it's just like applying (+) to 2 and 3, but in Maybe context
04:00:41 <sphynx> > (+) <$> Just 2 <*> Nothing
04:00:42 <lambdabot>   Nothing
04:01:29 <ion> > (Nothing <*> Just 2 <*> Just 3, pure (+) <*> Nothing <*> Just 3, pure (+) <*> Just 2 <*> Just 3)
04:01:30 <lambdabot>   (Nothing,Nothing,Just 5)
04:03:38 <sphynx> ion: hm, first case is interesting
04:03:54 <sphynx> > Just 2 <*> Just 3
04:03:55 <lambdabot>   Just 2
04:03:58 <parcs> @src Maybe (<*>)
04:03:58 <lambdabot> (<*>) = ap
04:04:11 <parcs> @src Maybe ap
04:04:12 <lambdabot> Source not found. Do you think like you type?
04:04:33 <sphynx> :t (<*>)
04:04:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:04:53 <parcs> anyway, Nothing <*> _ = Nothing; _ <*> Nothing = Nothing
04:04:56 <ion> > (pure (+) <*> Just 2 <*> Just 3, do { f <- return (+); a <- Just 2; b <- Just 3; return (f a b) })  -- Note the similarity here
04:04:57 <lambdabot>   (Just 5,Just 5)
04:05:23 <sphynx> but why Just 2 <*> Just 3 works?
04:05:42 <sphynx> Just 2 should be :: f (a -> b)
04:05:43 <parcs> lambdabot has an function instance of Num
04:05:56 <parcs> it's not standard
04:05:57 <ion> > 2 3  -- nasty
04:05:58 <lambdabot>   2
04:06:02 <sphynx> omg
04:07:29 <sphynx> Prelude Control.Applicative> Just 2 <*> Just 3
04:07:30 <sphynx> <interactive>:1:5:  No instance for (Num (a -> b))
04:07:34 <sphynx> that's better :)
04:11:17 <Saizan> no love for function spaces?
04:17:34 <weirdo> anyway, guys, how do i get some functional programming skills? i had serious trouble writing a permutation function
04:18:04 <weirdo> it all worked fine in imperative languages, though
04:18:34 <ion> By studying and practice.
04:18:36 <koala_man> have you tried ebay?
04:18:45 <ion> Or a brain transplant.
04:19:40 <Entroacceptor> the best is a practice-feedback loop
04:20:00 <Entroacceptor> (if you want to keep your brain, that is)
04:35:58 <runiq> Hey there
04:36:24 <runiq> Are there users of Arch Linux in here, by any chance?
04:36:44 <fabjan> weirdo: permutation as in all permutations of a list?
04:37:43 <weirdo> yes
04:37:49 <weirdo> a friend of mine wrote it in 3 lines
04:39:17 * hackagebot msgpack 0.6.0.0 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.6.0.0 (HideyukiTanaka)
04:40:12 <fabjan> @src permutations
04:40:12 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:40:18 * hackagebot msgpack-rpc 0.6.0.0 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.6.0.0 (HideyukiTanaka)
04:40:36 <fabjan> :(
04:44:56 <confound> weirdo: filter (\x -> x == nub x) $ replicateM (length x) x but that seems like it might be kind of inefficient :)
04:46:40 <hpaste> sthalik pasted "that's what he wrote"  http://hpaste.org/44665
04:48:01 <mauke> looks broken
04:48:06 <mauke> permutations shouldn't require Eq
04:48:27 <confound> there's nothing in that function that uses it, anyway
04:48:33 <confound> oh, delete might
04:50:34 <mauke> and that's why permutations "aba" won't work
04:54:00 <confound> mine requires Eq too, I suppose
04:56:34 <mauke> :t permutations
04:56:35 <lambdabot> forall a. [a] -> [[a]]
04:56:46 <mauke> :t permutations [id, negate, succ]
04:56:46 <lambdabot> forall a. (Num a, Enum a) => [[a -> a]]
04:57:40 <mauke> :t sequence (map (foldl' (.) id) (permutations [(^ 2), negate, succ]))
04:57:40 <lambdabot> forall a. (Num a, Enum a) => a -> [a]
04:57:50 <mauke> > sequence (map (foldl' (.) id) (permutations [(^ 2), negate, succ])) 4
04:57:52 <lambdabot>   [25,-25,-15,-17,17,9]
05:02:25 <weirdo> http://hpaste.org/paste/44665/any_better_now#p44666
05:19:12 <fryguybob> > let perms (n:ns) = join [f n ps | ps <- perms ns]; perms x = [x]; f n = zipWith (\a b -> a++(n:b)) <$> inits <*> tails in perms "abc"
05:19:14 <lambdabot>   ["abc","bac","bca","acb","cab","cba"]
05:23:43 <b52> i have a data type Address with the constructor Address String Int, is it possible to tread a string like address somehow if it matches this structure "x.x.x.x:x" ?
05:24:22 <augustss> fryguybob: A better base case is perms [] = [[]]
05:24:57 <augustss> fryguybob: Not better, clearer
05:25:09 <fryguybob> augustss: Yes that is clearer.
05:25:22 <mm_freak_> > foldM (\xs x -> zipWith (\l r -> l ++ x:r) <$> tails <*> inits $ xs) [] "abc"
05:25:23 <lambdabot>   ["abc","bca","cab","bac","acb","cba"]
05:26:11 <mun> hi
05:26:35 <mun> is \exists v. x = v & P equivalent to \forall v. x = v --> P?
05:28:18 <Spockz> dreixel: do you know of a library that contains an data structure for math expressions and functions that can `optimise' the structure? 
05:29:02 <Spockz> dreixel: johan made this thing that could generically simplify a datastructure but I'm not sure whether that is public domain
05:29:19 <dreixel> Spockz: are you talking about the exercise assistant?
05:29:31 <Spockz> dreixel: yes, that's the example indeed
05:29:54 <dreixel> Spockz: http://ideas.cs.uu.nl/www/
05:34:21 <Spockz> dreixel: I can find the running examples. But not the source code itself
05:35:54 <dreixel> Spockz: http://hackage.haskell.org/package/ideas ?
05:36:12 <elliott> What's a decent purely-functional data structure for picking random elements out of and nothing else? Like a Set, except for literally random access.
05:36:18 <Spockz> dreixel: ah right :(
05:36:20 <elliott> (Preferably something in the stdlib.)
05:37:36 <sipa> elliott: random or arbitrary?
05:37:49 <elliott> sipa: Random. As in "provided by Haskell's pseudo-random number generator".
05:38:18 <elliott> I literally just need "insert :: a -> T a -> T a" and "gimmeRandom :: T a -> IO a". Or equivalents.
05:38:38 <copumpkin> GHC 7 is EXTREEEME!! http://snapplr.com/gtdn
05:39:03 <elliott> copumpkin: It just embeds more science into the program.
05:39:26 <copumpkin> elliott: man, you should close as wontfix with that comment
05:39:28 <sipa> elliott: you mean want to read http://okmij.org/ftp/Haskell/perfect-shuffle.txt :)
05:39:38 <elliott> copumpkin: Do I even have the power to do that? X-D
05:39:46 <copumpkin> maybe
05:40:03 <elliott> sipa: I never said the random selection had to be perfect. :-)
05:40:41 <elliott> I'd just use a list except it's going to have hundreds of thousands of elements, so yeah.
05:40:45 <djahandarie> elliott, so is  head list  random enough for you? ;)
05:40:51 <djahandarie> I swear, it's random!
05:41:00 <sipa> elliott: i assume you want some constraints on the randomness, otherwise i give you  T = [], gimmeRandom = head, insert = (:)
05:41:13 <elliott> You both get slaps.
05:41:17 <elliott> Slaps for everyone.
05:41:20 <elliott> Free slaps, only available today.
05:44:15 <djahandarie> elliott, it's fairly easy to get O(log n) lookup with Data.Map and just lookup a random index.
05:44:29 <elliott> djahandarie: Yeah, that'd probably be the easiest.
05:44:37 <elliott> djahandarie: Data.IntMap, though.
05:44:41 <elliott> Since the keys are essentially arbitrary...
05:49:11 <fmapE> I'm trying to build some bindings to a c library (jack)
05:49:51 <fmapE> compiling a simple c program with the lines #include <jack/jack.h> \\ #include <jack/types.h> at the beginning is successful
05:50:07 <fmapE> however hsc2hs, with the same lines at the beginning of the file
05:50:13 <fmapE> complains "no such file or directory"
06:24:19 <mun> is this formula consistent? \forall v,w. c = v & d = w --> P(c,d)
06:37:57 <pr>  /win 20
06:39:50 <pr> hi cubi 
06:39:53 <cubi> hi pr 
06:48:53 * hackagebot monad-memo 0.1.1 - Memoization monad transformer  http://hackage.haskell.org/package/monad-memo-0.1.1 (EduardSergeev)
06:50:38 <djahandarie> Interesting idea. I wonder if it actually does anything of use
07:02:41 <vitka> exit
07:07:18 <jlouis> neat to see that Cabal has test suite runners now
07:07:41 <jlouis> paves the road for automated test runs on hackage I guess
07:12:51 <FliPPeh_> I always wondered, what's with the funny "ghc --info" output, is it intended to be read via haskell?
07:13:40 <mauke> looks like it
07:13:47 <mauke> [(String,String)]
07:15:18 <sphynx> jlouis: where can I read more details about running test suites in Cabal?
07:15:39 <jlouis> sphynx: it is pretty new, let me find the link to the new documentation
07:16:11 <jlouis> sphynx: http://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/users-guide/#test-suites (courtesy of tibbe on haskell-cafe)
07:16:24 <sphynx> jlouis: thanks!
07:20:21 <sphynx> so now we can run those suites with "cabal test"?
07:25:36 <Saul_L> Pretty cool, huh? Yeah, I know it's not but bear with me.
07:25:51 <Saul_L> LOL, this guys is a great teacher :D
07:26:10 <Saul_L> from http://learnyouahaskell.com/starting-out
07:26:52 <cubi> you can buy it in book form if you like it
07:27:24 <Saul_L> I can't buy anything right now, I'd downlod it tho
07:27:34 <cubi> http://nostarch.com/lyah.htm
07:27:39 <cubi> its up for pre-order
07:28:07 <Saul_L> thx anyway
07:28:11 <cubi> np :)
07:28:16 <pr> already pre-ordered it @ cubi 
07:28:17 <pr> !
07:28:29 <confound> LYAH helped me a lot
07:28:59 <cubi> BONUS ftw
07:29:02 <FliPPeh_> LYAH <3
07:29:09 <FliPPeh_> Funny pictures just make everything click
07:29:24 <Saul__> writing from Chatzilla now :D
07:29:34 <sgronblo> I only have 2,5 chapters left of lyah and thought it was a pretty decent book
07:29:41 <Saul__> <-- Saul_L
07:31:44 <djahandarie> BONUS, is this a good link to pass around for the LYAH preorder? http://nostarch.com/lyah.htm
07:32:09 <cubi> its from his website djahandarie 
07:32:15 <cubi> http://learnyouahaskell.com/faq
07:32:22 <djahandarie> Ah. Okay, sounds good
07:38:18 <BONUS> hey!
07:38:28 <BONUS> yeah sure. i'm gonna start promoting it a bit now
07:38:37 <BONUS> althought
07:38:42 <BONUS> if you pre-order it on amazon it's hella cheap
07:39:14 <djahandarie> I was going to drop it on reddit
07:39:26 <BONUS> i'm gonna drop it like tomorrow :)
07:39:31 <luite> BONUS: do you have pics of your vast collection of stuffed owls?
07:39:33 <BONUS> plus on twitter and probably update the site a bit
07:39:40 <djahandarie> Okay, I'll let you handle it then :)
07:39:40 <confound> I'm going to drop it like science.
07:39:52 <pr> woot.
07:39:53 <FliPPeh_> The books aren't colored ;<
07:39:56 <BONUS> oh i do, but i keep them in my basement, away from prying eyes
07:40:09 * hackagebot http-types 0.5.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.5.1 (AristidBreitkreuz)
07:40:13 <BONUS> yeah, having a 360-page book be printed in color would make it cost like a million dollars
07:40:19 <FliPPeh_> Worth it!
07:40:20 <pr> 24.95 Eur
07:40:22 <pr> \o/
07:40:32 <luite> aw, I don't like people who don't show pictures of their stuffed owl collection :(
07:40:45 <BONUS> haha
07:40:50 <pr> oh wait, it's actually 25.95 (amazon preorder)
07:43:54 <sgronblo> BONUS: I think you should split up the chapters more on lyah.com
07:44:16 <BONUS> you mean like into more chapters
07:44:19 <BONUS> or just more sub-sections?
07:44:22 <sgronblo> I was reading some of them on my crappy nokia e51 and the browser froze for minutes while loading some of the bigger chapters
07:44:30 <FliPPeh> We need to go deeper.
07:44:31 <sgronblo> more pages
07:44:52 <BONUS> haha. maybe i could buy you an iphone or something instead? :)
07:45:07 <sgronblo> did you already make that much money off the book or?
07:45:22 <BONUS> no no, i'd take that out of my savings
07:46:33 <sgronblo> At least the e51 fits nicer into a pocket and since it's so crappy I'm not worried about scratching it's display :)
07:46:48 <BONUS> there will also be a cool pdf version
07:46:56 <BONUS> in a week or so
07:46:58 <sgronblo> Well I've also been reading it on my kindle
07:47:03 <pr> do i get the pdf version for free if i preordered it on amazon? :o)
07:47:06 <pr> (jk)
07:47:08 <hai> i want to apply a fast fourier transform on an audio sample. I opened it with hcodecs, what i supossed to pass to the fft function ?
07:47:10 <sgronblo> That worked pretty far but the text was pretty small
07:47:11 <BONUS> haha, dunno
07:47:20 <sgronblo> In article mode the code segments were repeated
07:47:30 <Saul_L> In my Country the price of pre-order would feed may family of 4 for a week, or buy me a good pair of shoes, not everyone leaves in EU
07:47:54 <BONUS> hmm yeah, i didn't make the kindle version, that was some other dude
07:48:07 <sgronblo> I don't think there is a kindle version
07:48:08 <luite> although it's universally known that almost all (*) haskell book writers make huge loads of cash
07:48:10 <BONUS> alternatively, you could feed your family with shoes
07:48:11 <sgronblo> Only epub
07:48:15 <luite> (*) all but a finite number of exceptions
07:48:16 <BONUS> oh, that's right
07:48:27 <sgronblo> And I was reading the web site on it
07:48:42 <sgronblo> I wonder if it's possible to improve the support for article mode somehow
07:49:53 <BONUS> hmm. brb starcraft
07:50:34 <Eduard_Munteanu> hai: what fft function?
07:50:45 <Eduard_Munteanu> I don't think HCodecs has one.
07:50:54 <hai> the one from Numeric.FFT
07:50:56 <pr> BONUS: master league i suppose? hehe
07:51:20 <Eduard_Munteanu> @hoogle FFT
07:51:20 <lambdabot> Data.Time.Clock data DiffTime
07:51:20 <lambdabot> Data.Time.Clock data NominalDiffTime
07:51:20 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
07:51:21 <BONUS> trying to get into gold for now -.-
07:51:27 <Eduard_Munteanu> hai: what package?
07:51:32 <Entroacceptor> which servers?
07:51:36 <Entroacceptor> eu?
07:51:39 <BONUS> yup
07:51:57 <hai> Eduard_Munteanu, it recieves [Complex Double] 
07:52:46 <Eduard_Munteanu> I'm going to assume this is about...
07:52:51 <hai> Eduard_Munteanu,the package is pure-fft
07:52:52 <Eduard_Munteanu> @hackage pure-fft
07:52:52 <lambdabot> http://hackage.haskell.org/package/pure-fft
07:54:43 <Entroacceptor> BONUS: if you ever want to play some team games...
07:55:08 <Eduard_Munteanu> hai: well, you have    type Sample = Double
07:55:29 <Eduard_Munteanu> You could get the samples and make them Complex Doubles easily.
07:55:34 <rj300> hey
07:55:45 <hai> Eduard_Munteanum yeah, it generates a array of doubles
07:55:49 <rj300> who has the biggest Monad?
07:55:52 <rj300> :P
07:56:29 <Silvah> Could someone explain me what continuations are for?
07:56:38 <FliPPeh> >>===
07:57:15 <hai> Eduard_Munteanu, i did the folowing: got the elems of the array, turned them Complex and passed to fft
07:57:33 <Eduard_Munteanu> hai: yes.
07:57:44 <Eduard_Munteanu> That should do it.
07:57:51 <djahandarie> rj300, the set of Monads can't form a measurable space, that question is ill-defined.
07:58:17 <Saizan> can't?
07:58:21 <hai> Eduard_Munteanu, if I got 10 musics i would never end that algorithm, so i though something was wrong
07:58:45 <djahandarie> Saizan, joking. It probably can :P
07:59:27 <djahandarie> I wonder what an interesting sigma-algebra would be for that
08:00:07 <Eduard_Munteanu> hai: what do you mean by "10 musics"?
08:00:17 <shlevy> Howdy. This is a bit off-topic, but I'm not sure where to ask this and my only FP experience is in Haskell: Has anyone done any functional programming with Matlab or know any resources to get me started?
08:01:03 <hai> Eduard_Munteanu, each audio sample is a .wav
08:01:09 <Eduard_Munteanu> shlevy: that usually means doing, e.g. vector multiplication or writing component-wise operations instead of using loops.
08:01:51 <Eduard_Munteanu> hai: yes, but not a Sample.
08:02:06 <Eduard_Munteanu> A file is made up of multiple samples.
08:02:28 <Eduard_Munteanu> Do you mean it never produces any result?
08:02:52 <hai> Eduard_Munteanu, yeah, but i'm opening an file .wav with hcodecs each
08:03:19 <Eduard_Munteanu> What are you doing with the output of 'fft'?
08:03:27 <hai> Eduard_Munteanu, anyway the array produceded have milions of elems
08:03:58 <Eduard_Munteanu> hai: yes it does, but you're supposed to FFT on smaller power-of-2 windows.
08:04:14 <hai> Eduard_Munteanu, how so?
08:05:32 <BONUS> Entroacceptor: sure, add me, i'm KissyBoy.962
08:06:30 <Eduard_Munteanu> hai: normally you'd split the [Complex.Double] into bits.
08:06:38 <Eduard_Munteanu> Each something like 4096 samples.
08:07:20 <Eduard_Munteanu> And you get a spectrum analysis for each.
08:08:05 <hai> Eduard_Munteanu, is that the frequency of the audio?
08:08:56 <kamaji> Hey #haskell, does there exist some program like matlab that uses haskell as its language?
08:08:57 <Eduard_Munteanu> Unless it's a sinewave, you won't get anything close to a *single* frequency.
08:09:12 <kamaji> Like a ghci with plotting and environment vars and stuff
08:09:39 <Eduard_Munteanu> hai: do you know a bit about Fourier transforms?
08:10:13 <accel> i realize this soudns like trying to amte a lion and a donkey; but ... is there a way to use my desktop (ubuntu 64bit) to help my laptop (osx snow leopard) compile haskell 7.0.2 ?
08:10:26 <Eduard_Munteanu> kamaji: hm, there was a #haskell-math channel, I'm not sure whether it's around anymore.
08:10:49 <kamaji> Eduard_Munteanu: Is that a program? 
08:10:52 <Eduard_Munteanu> And there are a few packages that can do plots and the like.
08:11:02 <kamaji> Eduard_Munteanu: anything like an interactive environment, though?
08:11:04 <Eduard_Munteanu> No, a discussion channel for that kind of stuff.
08:11:12 <Eduard_Munteanu> Um, ghci? :)
08:11:24 <djahandarie> I can't imagine #haskell-math surviving, too close to #haskell. ##categorytheory seems to be doing okay though ;)
08:11:29 <hai> Eduard_Munteanu, i have no clue, just want to find the frequencie to track the tone of a music and then i want to estime the bpm
08:11:46 <aristid> djahandarie: evolutionary irc science ;)
08:11:55 <kamaji> Eduard_Munteanu: Sorry I meant like graphical, more like matlab
08:12:23 <kamaji> although to be honest.... I guess if I use plotting functions then it's basically the same effect
08:12:31 <elliott> A full CAS is not a trivial endeavour.
08:12:31 <Eduard_Munteanu> Matlab isn't much graphical anyway, it's just an IDE paired with a language and some libs.
08:12:40 <elliott> Not that Matlab is a CAS.
08:13:10 <kamaji> elliott: a CAS?
08:13:21 <Eduard_Munteanu> hai: I'm not sure frequency domain analysis is how you're supposed to do it.
08:13:24 <elliott> kamaji: Computer Algebra System a la Maple, Mathematica, Maxima, Axiom, etc.
08:13:42 <kamaji> elliott: oh right. Yeah I guess that's pretty similar to what i'm talking about
08:13:43 <kmc> not compare and swap? ;)
08:14:06 <kamaji> I'm just wondering if such a thing exists
08:14:09 <kamaji> using haskell
08:14:11 <elliott> kmc: pah, DCAS!
08:14:25 <hai> Eduard_Munteanu, i was sugested to proceed like that
08:14:30 <elliott> kamaji: No; such a project is a very large undertaking.
08:14:34 <elliott> But there are bits and pieces.
08:14:45 <kmc> cmpxchg16b
08:14:45 <hai> Eduard_Munteanu, anyway shouldnot be lazy and search on my own
08:14:48 <kmc> say that three times fast
08:15:10 <Eduard_Munteanu> But I might be wrong, have a look at something Google suggested: http://www.clear.rice.edu/elec301/Projects01/beat_sync/beatalgo.html 
08:15:26 <Eduard_Munteanu> It's a bit more complicated than just a FFT.
08:16:02 <kamaji> Ok I gotta run. thanks elliott, Eduard_Munteanu 
08:16:21 <Philonous> Silvah: A continuation is an object (not in the OO sense) that tells a function what to do with it's result. So instead of "returning" a value it calls the continuation. This gives rise to a style of programming (continuation passing style, CPS). You can build many control operators just with continuations (and macros), so you could for example build a compiler that gives you access to continuations and have the "orthodox" control oper
08:17:13 <Eduard_Munteanu> kmc: CAS? Heh.
08:17:35 <hai> Eduard_Munteanu, alright
08:18:59 <Silvah> Philonous: '"orthodox" control oper...'? Seems like the sentence got cut.
08:19:12 <Philonous> and have the "orthodox" control operators (branching, looping etc.) as a library. 
08:19:23 <Eduard_Munteanu> A naive version could be done using time-domain-only techniques, I suppose.
08:20:12 <Philonous> In Haskell, continuations are usually just functions. And you use CPS style unwittingly all the time. For example the third argument to withFile is a continuation that tells it what to do with the newly acquired handle
08:20:47 <kmc> indeed the right-hand argument to (>>=) is a kind of continuation
08:21:14 <kmc> i think "continuation-based IO" would be a much better name than "monadic IO"
08:21:27 <kmc> since the monad-ness of the interface is a secondary concern
08:21:34 <Philonous> kmc: Yes, as Wadler pointed out, ContT is a meta-continuation monad
08:21:35 <confound> kmc: that would have been less scary to me, certainly :)
08:21:50 <kmc> :D
08:25:38 <HugoDaniel> how do i write a string to stderr ?
08:25:54 <Silvah> HugoDaniel: hPutStr stderr "something"?
08:26:14 <HugoDaniel> yeah
08:26:14 <Eduard_Munteanu> 1>&2 :P
08:26:17 <HugoDaniel> thanks
08:27:26 <Silvah> Philonous: thanks for your explanation.
08:28:00 <Philonous> Silvah: In scheme, continuations are much more interesting than in Haskell, because you can access the rest of the whole program (call-with-current-continuation, call/CC for short). That means you can do wicked program transformations with them , but in haskell you have to encapsulate them in a monad. It still gives you rather cool monadic operators
08:28:37 <Jafet> @quote ContT
08:28:37 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
08:28:37 <lambdabot> just don't know what it means.
08:28:51 <djahandarie> Haha
08:29:02 <Jafet> @quote klein
08:29:02 <lambdabot> heatsink says: If monads are containers, the Cont monad is a klein bottle.
08:30:03 <Silvah> Philonous: I don't really think accessing the rest of the program is interesting, keeping everything as local as possible was always better IMO.
08:32:04 <Philonous> Silvah: Very good point. Indeed, what could happen is, that you could accidently access the continuation of the interpreter (in an interpreted scheme sesson). That's why delimited (or composable) continuations where invented. Where continuations are weird, delimited continuations are just mind boggling.
08:32:23 <Philonous> Silvah: But in Haskell all continuations are delimited. 
08:37:08 <Eduard_Munteanu> Non-delimited as in setjmp stuff?
08:38:02 <Eduard_Munteanu> Poor man's call/cc.
08:41:32 <Philonous> Eduard_Munteanu: Yes, delimited continuations return to the call site, I think that's the point
08:41:40 <mauke> non-delimited as in the whole stack
08:42:04 <mauke> right through main() and off to _exit()
08:46:00 <Saul__L> WASAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA !!!!!!
08:48:08 <byorgey> > concat $ zipWith replicate [1,1,1,34,1,6] "WASA !"
08:48:09 <lambdabot>   "WASAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA !!!!!!"
08:48:48 <aristid> byorgey: a pretty useful function :)
08:50:25 <c_wraith> > map length $ group "WASAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA !!!!!!"
08:50:26 <lambdabot>   [1,1,1,34,1,6]
08:50:41 <c_wraith> looks familiar
08:51:03 <aristid> > map (length *** head) . group $ "WASAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA !!!!!!"
08:51:04 <lambdabot>   Couldn't match expected type `([a], [a1])'
08:51:04 <lambdabot>         against inferred type `[...
08:51:17 <c_wraith> you wanted &&&
08:51:20 <aristid> damn
08:51:27 <aristid> i ALWAYS confuse them
08:51:34 <aristid> > map (length &&& head) . group $ "WASAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA !!!!!!"
08:51:36 <lambdabot>   [(1,'W'),(1,'A'),(1,'S'),(34,'A'),(1,' '),(6,'!')]
08:51:42 <aristid> > unzip . map (length &&& head) . group $ "WASAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA !!!!!!"
08:51:43 <lambdabot>   ([1,1,1,34,1,6],"WASA !")
08:51:52 <aristid> full circle!
08:51:57 <byorgey> =D
08:52:05 <byorgey> run-length encoding FTW
08:52:36 <Eduard_Munteanu> That'd be poor man's compression.
08:52:56 <aristid> Eduard_Munteanu: except most of the time, it makes stuff longer instead of shorter :)
08:55:16 <raichoo> You scared him away with the awesomeness…
08:55:56 <fryguybob> @check \xs -> (uncurry (\x -> concat . zipWith replicate x)) (unzip . map (length &&& head) . group $ xs) == xs
08:55:57 <lambdabot>   "OK, passed 500 tests."
08:56:30 <zygoloid> aristid: "the product of the functions is a function on the product"
08:56:32 <ion> Make sure it doesn’t just test a bunch of [(),(),(),()]s.
08:57:05 <ceii> @check \xs -> (uncurry (\x -> concat . zipWith replicate x)) (unzip . map (length &&& head) . group $ xs) == (xs :: Int)
08:57:06 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:57:11 <ceii> @check \xs -> (uncurry (\x -> concat . zipWith replicate x)) (unzip . map (length &&& head) . group $ xs) == (xs :: [Int])
08:57:11 <lambdabot>   "OK, passed 500 tests."
08:57:44 <Jafet> > let bwt mxs = map last $ sort (rotations mxs) in bwt "That Sam-I-am, that Sam-I-am!  I do not like that Sam-I-am!"
08:57:45 <lambdabot>   Not in scope: `rotations'
08:57:58 <Jafet> @let rotations xs = let xs' = Nothing : map Just xs in take (length xs') $ zipWith (++) (tails xs') (inits xs')
08:57:59 <lambdabot>  Defined.
08:58:02 <Jafet> > let bwt mxs = map last $ sort (rotations mxs) in bwt "That Sam-I-am, that Sam-I-am!  I do not like that Sam-I-am!"
08:58:04 <lambdabot>   [Just '!',Just '!',Just ' ',Just 't',Just 't',Just 't',Just 'I',Just 't',Ju...
08:58:30 * hackagebot type-level-numbers 0.1.0.2 - Type level numbers implemented using type families.  http://hackage.haskell.org/package/type-level-numbers-0.1.0.2 (AlexeyKhudyakov)
08:58:43 <Jafet> Unfortunately, reverse bwt is rather ugly.
09:00:18 <Boxo> @check \xs -> and xs == foldl (&&) True xs
09:00:18 <lambdabot>   "OK, passed 500 tests."
09:00:54 <Boxo> @check \_ -> True
09:00:55 <lambdabot>   "OK, passed 500 tests."
09:00:58 <Boxo> @check \_ -> False
09:00:59 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
09:01:15 <Jafet> > let nothing Nothing = True; nothing _ = False; bwt = (fromJust . findIndex nothing &&& map fromJust . filter (not.nothing)) . map last . sort . rotations in bwt "That Sam-I-am, that Sam-I-am!  I do not like that Sam-I-am!"
09:01:17 <lambdabot>   (27,"!! tttItoe,mmmmmmIII ---   ---SSShhh kttTli aaaaaa dnaaao  ")
09:01:22 <Boxo> @check \(a,b) -> a == b
09:01:23 <lambdabot>   "OK, passed 500 tests."
09:01:26 <Boxo> heh
09:03:32 <elliott> <Boxo> @check \(a,b) -> a == b
09:03:32 <elliott> <lambdabot>   "OK, passed 500 tests."
09:03:33 <elliott> nice.
09:05:25 <mauke> @check (==)
09:05:26 <lambdabot>   "OK, passed 500 tests."
09:06:14 <djahandarie> lambdabot is a supporter of equality.
09:06:33 <ion> @check \a b -> (a == b) == (a == b)
09:06:34 <lambdabot>   "OK, passed 500 tests."
09:07:06 <fryguybob> @check \a b -> (a :: Int) == b
09:07:06 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n1\n"
09:07:40 <djahandarie> ion, that's just a tautology :P
09:07:57 <ion> REALLY?
09:08:17 <c_wraith> I like when @check returns lies
09:08:26 <c_wraith> But I can only think of one obvious case where it does
09:08:45 <djahandarie> ion, yes, it's a good thing I had a PhD in tautology-detection to let you know this.
09:11:03 <Jafet> Is that typical of the subjects in which people here get their PhDs?
09:13:24 <c_wraith> I don't have a phd, only a dph.
09:13:31 <c_wraith> (since I'm not on GHC 7 yet)
09:15:01 <djahandarie> @quote edwardk phd
09:15:01 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
09:15:11 <djahandarie> @quote edwardk spj
09:15:12 <lambdabot> No quotes match. Wrong!  You cheating scum!
09:15:15 <djahandarie> >:[
09:16:19 <pr> @quote spj
09:16:19 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
09:16:54 <pr> hehe
09:18:09 <djahandarie> @remember edwardk [you mean #haskell has a 2 phD/nick average ?] clearly this is why SPJ stays away, he doesn't want to dilute that metric.
09:18:09 <lambdabot> It is forever etched in my memory.
09:18:26 <monochrom> haha
09:19:59 * rtharper will definitely forever dilute that average
09:20:39 <Jafet> That average already takes you into account!
09:20:44 * kmc is the loser with no graduate degree
09:22:36 <c_wraith> lots of people here have no graduate degrees
09:22:42 <c_wraith> It's just that some people have hundreds :)
09:22:57 <kmc> but i thought you need three PhDs in vorpal category theory to write "hello world" in Haskell
09:24:42 <c_wraith> nah, vorpal category theory is only necessary when avoiding being eaten by the jabberwocky library
09:25:21 <ion> Huh. <ion> @quote | <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:25:21 <theorbtwo> It's also useful when you want to outgabe momraths.
09:25:57 <monochrom> popular culture authors like to create "this person has 10 phds" characters to depict either a very learned person or a very crazy scientist. in reality, such authors obviously haven't even talked to one single phd --- the way grad school works, most schools don't even admit you for doing a 2nd phd.
09:26:03 <c_wraith> ion: that happens sometimes.
09:26:24 <Jafet> Some people do have 10 PhDs
09:26:39 <theorbtwo> Jafet: But five of those are honorary.
09:26:47 <Jafet> Hm, only five?
09:26:54 <kmc> you can get one in Soviet Russia and then come to America for the second one
09:27:06 <ZeroGravitas> hey people, have a quick question about parsec. Anyone know how to create a parser which acheives the same thing as this regex: \d{1,3}
09:27:38 <Jafet> Only because your PhD in Soviet Russia is based on worthless ternary computers
09:29:40 <mauke> ZeroGravitas: impossible in general
09:30:28 <c_wraith> mauke: Uh?  I don't think that's impossible.  
09:30:44 <c_wraith> mauke: unless you mean backtracking behavior?
09:31:00 <ZeroGravitas> surely you should be able to do it with some combinations of the count parser, I just can't get it to work.
09:31:42 <mauke> c_wraith: I do
09:31:57 <kmc> catMaybes <$> count 3 (optionMabe char)
09:32:00 <kmc> optionMaybe *
09:32:04 <kmc> that will allow 0 but you get the idea
09:32:08 <c_wraith> mauke: oh, yeah.  parsec is annoying that way.  quit using libraries that don't compose!
09:32:15 <mauke> kmc: that's a terrible regex
09:32:33 <mauke> @hackage parsec
09:32:34 <lambdabot> http://hackage.haskell.org/package/parsec
09:33:24 <mauke> I hate this javascript bullshit
09:33:34 <mauke> thanks for the unusable synopsis
09:34:54 <mauke> well, \d{1,3} is syntactic sugar for \d(?:\d\d?)?
09:35:06 <mauke> that should be straightforward to encode
09:37:45 <mauke> manyNtoM a z p = liftM2 (++) (exactly a p) (atMost (z - a) p)
09:37:50 <mauke> exactly = replicateM
09:39:06 <mauke> atMost n p | n <= 0 = return [] | otherwise = liftM2 (:) p (atMost (n - 1) p) <|> return []
09:39:09 <mauke> or something like that
09:40:11 <hygge> good evenin. is it possible to declare a Data.Map storing functions as values. Should be right since its a functional language? :) I mean from String to f where f _any_ lambda function.
09:40:29 <byorgey> hygge: sure. easy as pie.
09:40:35 <kmc> hygge, yes, all of the function have to have the same type though
09:40:38 <mauke> well, not *any* function
09:40:42 <hygge> right...
09:40:43 <ZeroGravitas> :mauke kmcs' idea did the trick but I'm gonna try that as well, I like the idea of it more.
09:40:55 <kmc> :t M.fromList [('x',pred),('y',succ)] :: M.Map Char (Int -> Int)
09:40:55 <lambdabot> M.Map Char (Int -> Int)
09:40:57 <hygge> i mean some lambda functions take 1 arg, some none (constants) some take n...
09:41:09 <kmc> no function takes 0 args
09:41:11 <kmc> by definition
09:41:12 <mauke> "lambda function" is not a meaningful term
09:41:14 <kmc> in fact they all take 1 arg really
09:41:24 <byorgey> as long as they have the same types it doesn't matter how you wrote them down.
09:41:35 <kmc> "lambda" is just the name for the syntax which creates function values
09:41:37 <hygge> kmc: ok, so then it is fine then :) 
09:41:39 <HugoDaniel> how do i catch exception thrown by "error" ?
09:41:44 <byorgey> :t M.fromList [('x', pred), ('y', \x -> succ x)] :: M.Map Char (Int -> Int)
09:41:45 <lambdabot> M.Map Char (Int -> Int)
09:41:47 <kmc> HugoDaniel, Control.Exception
09:42:04 <mauke> HugoDaniel: mostly, you don't
09:42:15 <mauke> error doesn't really throw exceptions, it aborts the program
09:42:35 <hygge> byorgey: what was "pred" and "succ" in your example?
09:43:11 <byorgey> > [pred 3, succ 3] -- hygge 
09:43:12 <lambdabot>   [2,4]
09:43:23 <ion> > suck 4
09:43:24 <lambdabot>   Not in scope: `suck'
09:43:26 <aristid> > sequence [pred, succ] 3
09:43:27 <lambdabot>   [2,4]
09:43:45 <hygge> of course
09:44:03 <HugoDaniel> im calling a function that has the type "String -> MyData" and calls error, there is no IO, just an exception that is thrown, and i want to catch it
09:44:12 <ion> > [pred, succ] <*> pure 3
09:44:13 <lambdabot>   [2,4]
09:44:35 <hygge> :t (\x -> \y -> x+y)
09:44:36 <lambdabot> forall a. (Num a) => a -> a -> a
09:44:43 <djahandarie> suck = in . Succ obviously
09:44:47 <mzero> I always wish there were a version of that that worked for 2-tuples:
09:44:52 <jmcarthur> HugoDaniel: it's bad practice to catch exceptions from pure functions. it's nicer if you just use Mayber or Either in the first place
09:45:03 <jmcarthur> *Maybe
09:45:07 <byorgey> hygge: that can also be abbreviated  \x y -> x + y
09:45:12 <HugoDaniel> jmcarthur, its not my fault someone wrote this function this way :(
09:45:17 <jmcarthur> HugoDaniel: ah
09:45:24 <jmcarthur> HugoDaniel: the spoon package is designed for situations like that
09:45:24 <byorgey> hygge: but they are exactly the same thing
09:45:25 <mzero> something like     sequencePair (pred, succ) 3
09:45:30 <hygge> ok!   
09:45:31 <HugoDaniel> yeah, i always use Either or Maybe, or lift stuff to those two types
09:45:42 <jmcarthur> HugoDaniel: i'd still try to convince the package maintainer to fix it, but in the meantime you can use spoon
09:46:09 <djahandarie> Is there no way to define data types with lambdabot?
09:46:14 <byorgey> mzero: well, if you make   data Pair a = Pair a a  and then derive a Traversable instance for it...
09:46:14 <jmcarthur> HugoDaniel:  basically spoon just takes misbehaving functions like that and turns them into Maybes
09:46:20 <djahandarie> The @let command doesn't seem to do it
09:46:24 <HugoDaniel> "Takes an error-throwing expression and puts it back in the Maybe it belongs in. "
09:46:28 <HugoDaniel> amazing :)
09:46:48 * hackagebot happstack-server 6.0.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.0.2 (JeremyShaw)
09:47:05 <hygge> kmc: when u said all lambda functions do take one arguments, i guess i mean that they are all curried to take one? i mean \x y -> x+y becomes (\x->(\y->y+x)?
09:47:16 <mzero> byorgey - ew! The hope was for some simple, common pattern to use in ad hoc cases where you need to pass a value and its transformed version around
09:47:16 <hygge> :t (\x->(\y->y+x))
09:47:17 <lambdabot> forall a. (Num a) => a -> a -> a
09:47:19 <hygge> grr
09:47:20 <hygge> :)
09:47:49 <kmc> right hygge
09:47:53 <mzero> usuall I need one of those fns to be id
09:47:59 <kmc> all functions take exactly one argument
09:48:04 <kmc> (not sure what you mean by "lambda function")
09:48:23 <hygge> i guess i mean lambda expression
09:48:31 <hygge> \x -> ...
09:48:43 <mzero> > let with = \f v -> (v, f v) in  with show 42  
09:48:44 <lambdabot>   (42,"42")
09:49:01 <kmc> @pl \f v -> (v, f v)
09:49:01 <lambdabot> ap (,)
09:49:13 <byorgey> hygge: all Haskell functions are curried, whether they are defined using a lambda expression or not
09:49:17 <mzero> clever
09:49:38 <hygge> :t (\x->(\y->y+x)) still shows to arguments...but maybe i havent grasped currying yet
09:49:39 <lambdabot> Not in scope: `still'
09:49:39 <lambdabot> Not in scope: `to'
09:49:39 <lambdabot> Not in scope: `arguments'
09:49:42 <kmc> hygge, yeah; the lambda syntax allows any number of arguments but the semantics are 1-argument curried functions
09:49:50 <kmc> hygge, it's a function of one argument, which returns another function
09:50:04 <byorgey> hygge: (\x -> (\y -> y + x)) is a one-argument function (x) that returns a function (\y -> y + x)
09:50:16 <kmc> (\x -> stuff) is a 1-arg function, even if "stuff" has a lambda in it too
09:50:24 <hygge> i see
09:51:21 <hygge> M.fromList [('x', pred), ('y', \x y -> fst x y)] :: M.Map Char (Int -> Int)
09:51:29 <hygge> :t M.fromList [('x', pred), ('y', \x y -> fst x y)] :: M.Map Char (Int -> Int)
09:51:30 <lambdabot>     The lambda expression `\ x y -> fst x y' has two arguments,
09:51:30 <lambdabot>     but its type `Int -> Int' has only one
09:51:30 <lambdabot>     In the expression: \ x y -> fst x y
09:52:14 <hygge> :t M.fromList [('x', pred), ('y', \x -> (y->fst x y))] :: M.Map Char (Int -> Int)
09:52:15 <lambdabot>     Pattern syntax in expression context: y -> fst x y
09:52:25 <rostayob> Is there any doc on Data.Data, apart from the API docs?
09:52:35 <kmc> the Scrap Your Boilerplate papers
09:53:07 <kmc> Data.Data is largely meant to be used through the "syb" package
09:53:37 <rostayob> kmc: this: http://web.archive.org/web/20080622204226/http://www.cs.vu.nl/boilerplate/ ? they seem outdated
09:54:04 <kmc> go to the "syb" package on hackage
09:54:06 <kmc> it has a newer link i think
09:54:46 <TomMD> I just reviewed the SYB papers linked from the package - they seemed to match the package afaict.
09:56:27 <rostayob> kmc: oh ok... so why the different namings?
09:57:05 <kmc> ?
09:59:05 <rostayob> kmc: I mean in base you've got only Data.Data
09:59:11 <byorgey> hygge: all the elements stored in a Map must have the same type.  Since pred has type  Int -> Int,  \x y -> fst x y  must also... but there is no way that \x y -> fst x y can be given the type Int -> Int, so GHC complains
10:00:00 <byorgey> hygge: the stuff about "has two arguments" is because any lambda expression that looks like  \x y -> ...  will always have a type that looks like   X -> Y -> ...  where x :: X and y :: Y
10:00:44 <hygge> byorgey thx. 
10:00:47 <kmc> rostayob, Data.Data is in 'base' because GHC supports "deriving Data" and so the class needs to ship with GHC
10:00:54 <byorgey> and although fundamentally everything is one-argument functions, it is still a convenient shorthand to talk about "two-argument functions" instead of talking about "one-argument functions that return functions"
10:01:06 <rostayob> kmc: ah ok, fair enough. thanks.
10:01:19 <hygge> ok... so i can never have this map of String -> Any Higher Order Function
10:01:26 <hygge> rethink implementation then :)
10:01:48 <kmc> hygge, really *any* higher order function?
10:01:52 <kmc> or just one of a few types?
10:02:11 <byorgey> hygge: if you DID have such a map, what would you do with it?
10:02:14 <kmc> you can do:  data Stuff = Foo (Int -> Char) | Bar (Bool -> Int -> String); type MyMap = Map String Foo
10:02:28 <kmc> hygge, you could also use Data.Dynamic but that's probably not the right answer
10:02:29 <byorgey> kmc: I think you mean  Map String Stuff
10:02:34 <kmc> yeah
10:02:34 <kmc> that
10:02:38 <kmc> hygge, what are you trying to do?
10:02:56 <hygge> kmc, yeah. i am trying to do an interpretor of a simple functional language. i wanted to have a lookup from function name to function definiton. and as i know all functions can be expressed using lambda cal i wanted to have this map fro string -> lambda functions
10:03:15 <kmc> there's still no such thing as a "lambda function"
10:03:27 <hygge> expression...
10:04:02 <byorgey> lambda functions = functions.  lambda expressions are just one particular syntax for writing down functions.
10:04:06 <kmc> you can create a single type to represent "functions of the language being interpreted"
10:04:30 <kmc> hygge, i've often used something like this:  data Value = VInt Int | VBool Bool | VFun ([Value] -> Value)
10:04:53 <kmc> that gives you a type for values in a language with integers, booleans, and (first-class, non-curried) functions
10:04:57 <kmc> then you can do Map String Value
10:05:07 <kmc> (that way you treat constants uniformly with functions, too)
10:06:25 <hygge> kmc: thanks. hmm. i recognize this from how we did an interpreter for a subset of C in uni. also, now i realised that Integer is the only type i have, as for what it seems for now
10:06:48 <hygge> each function still takes a variable number of Ints though
10:08:12 <kmc> hygge, one reason you can't use Haskell's type system to model your language's type system is that you'd have to prove at Haskell-compile-time that the user of your interpreter will never input a type-incorrect term
10:08:31 <mm_freak_> in attoparsec is there a nicer way to get the rest of the input than 'takeWhile (const True)'?
10:09:01 <kmc> actually, there are huge advantages to modeling object-language types in the meta-language type system, but a) it's more work, and b) you still need some dynamic typechecking layer
10:09:22 <kmc> and (unless you want to typecheck in the parser) a type for untyped syntax and another for typed syntax
10:09:36 <hygge> aha!
10:13:53 <Saizan> dynamic typechecking for your object language only though
10:14:18 <rostayob> I know it's a strange question but
10:14:33 <rostayob> is there a way to convert get the name of a function as a string?
10:14:43 <kmc> that's a strange question
10:14:57 <rostayob> eheh :P
10:14:58 <kmc> http://mainisusuallyafunction.blogspot.com/2010/11/obtaining-name-of-function-in-haskell.html
10:15:33 <rostayob> oh god. I already gave up.
10:15:49 <rostayob> is there really no other way? mhm.
10:16:00 <kmc> i don't claim there's no other way
10:16:08 <kmc> a compiler extension or preprocessor could do it
10:17:10 <kmc> GHC could provide a primitive to do this, without *too* much work
10:17:36 <kmc> rostayob, is this an isolated question or is there a problem you're trying to solve this way?
10:18:15 <rostayob> kmc: well, do you have 5 minutes to listen to me :P?
10:18:20 <kmc> yeah
10:18:22 <rostayob> ok
10:18:31 <kmc> and someone else might have an idea too
10:18:39 <rostayob> basically I want to store a really stupid, non recursive haskell data type into a redis hashed set.
10:18:44 <rostayob> So I have something like
10:18:56 <mm_freak_> rostayob: in haskell it doesn't make a lot of sense to "get the name of a function"
10:19:10 <rostayob> data Foo = Foo { id :: Int, author :: String, content :: String }
10:19:17 <mm_freak_> you would need to do that at the preprocessing level or something
10:19:26 <rostayob> and I'm storing this thing in a redis hashed set
10:19:41 <rostayob> something like
10:19:44 <rostayob> foos:id
10:19:46 <rostayob> now
10:19:51 <rostayob> I want to have a function
10:20:04 <rostayob> in which the user can specify an arbitary number of "fields" to get
10:20:14 <rostayob> something like
10:20:22 <hpaste> BrianHV pasted "varUpdate cleanup"  http://hpaste.org/44668
10:20:23 <rostayob> getFoo :: Int -> [fields] -> Foo
10:20:34 <mm_freak_> rostayob: in other words, you want a real record system, which GHC lacks =)
10:20:44 <rostayob> so I want to do getFoo 45 [author]
10:20:56 <BrianHV> looking for tips on cleaning up that hpaste code similar to what you guys taught me with applicative yesterday
10:20:56 <mm_freak_> i needed the same thing, when i tried to write 'modifyField' for my StateT monad transformer
10:20:59 <kmc> rostayob, but it returns [Foo] not [Author]
10:21:04 <kmc> so what's the point?
10:21:18 <kmc> err i guess a single Foo
10:21:31 <rostayob> kmc: I want to get a foo from a "foo id"
10:21:43 <kmc> getFoo :: Int -> Foo
10:21:46 <rostayob> but I may want to get certain fields
10:21:49 <rostayob> and also
10:21:50 <c_wraith> BrianHV: In that particular case, I don't think there's really anything cleaner than what you're doing.
10:21:55 <kmc> why not get the whole thing, and then extract the fields
10:22:03 * hackagebot cabal-dev 0.7.4.1 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.7.4.1 (RoganCreswick)
10:22:14 <rostayob> kmc: actually it doesn't matter, the thing is that
10:22:18 <rostayob> I want to do it automatically
10:22:20 <kmc> of course you could move that into getFoo :: Int -> (Foo -> a) -> a
10:22:22 <kmc> but that seems pointless
10:22:29 <BrianHV> c_wraith: all right... thanks for taking a look
10:22:33 <rostayob> data type -> string fields and string field -> data type
10:22:39 <rostayob> without having to specify the things manually
10:22:46 <c_wraith> BrianHV: you can certainly make it shorter, but that may not make it cleaner
10:22:48 <rostayob> so if I change the data type it'll still work
10:22:55 <mm_freak_> BrianHV: you can only get rid of some intermediate variables there
10:22:57 <kmc> the record syntax already gives you that
10:23:13 <kmc> case x of Foo { author = a } -> ...
10:23:20 <kmc> that code will still work even if you add/remove other fields in Foo
10:23:31 <rostayob> kmc: yes I know, but i don't want to specify "author"
10:23:51 <rostayob> I want to give an id, get the fields and then use those strings as functions to create the datatype
10:23:51 <kmc> what do you want to specify?
10:24:00 <mm_freak_> varGet timerVar >>= toggleTimer >>= varSet timerVar
10:24:00 <rostayob> and the other way around
10:24:09 <hpaste> BrianAdkins pasted "Cracker Barrel Puzzle"  http://hpaste.org/44669
10:24:22 <rostayob> I want to give the datatype and "convert" it to an hashed set
10:24:27 <rostayob> without having to do
10:24:43 <BrianHV> mm_freak_: interesting. I hadn't thought about that...
10:24:59 <BrianHV> that's basically point-free monadic sequencing, no?
10:25:17 <rostayob> hset "foo:id" "author" (author foo)
10:25:25 <mm_freak_> BrianHV: in general "do x <- c1; c2 x" can be rewritten to "c1 >>= c2"
10:25:27 <rostayob> i don't want to write "author" manually
10:25:33 <kmc> rostayob, ah, ok
10:25:36 <mm_freak_> it can not, if you use 'x' later
10:25:45 <kmc> you want to introspect on the field names of the "Foo" type and generate some code
10:25:49 <BrianHV> right
10:25:58 <kmc> rostayob, you can do that with Template Haskell
10:26:01 <kmc> it won't be pretty
10:26:03 <rostayob> kmc: yes,  but without th possibly...
10:26:06 <rostayob> ahah exactly
10:26:29 * BrianHV should be able to write a varUpdateIO function
10:26:29 <mm_freak_> BrianHV: there are a lot of ways to write elegant monadic code, but in this case you won't get anything /cleaner/, as c_wraith pointed out
10:26:33 <kmc> doing this in one-stage Haskell has more problems besides the "function name" problem
10:26:52 <kmc> rostayob, you can look at my "rowrecord" package, which does something vaguely similar with TH
10:26:58 <kmc> my TH code is probably awful though
10:27:12 <kmc> i find it takes about 10x as long to write n lines of TH as it does to write n lines of one-stage Haskell
10:27:16 <lysgaard> What does hGetBufNonBlocking: invalid argument (Bad file descriptor) mean?
10:27:33 <lysgaard> Am I trying to open a file that doesn't exist?
10:27:35 <kmc> it means you tried to read from a bad file descriptor
10:27:41 <kmc> no, that would probably error earlier
10:27:54 <rostayob> kmc: it certainly does, the thing is that the data type may change
10:27:56 <mm_freak_> BrianHV: although avoiding intermediate variables is a good start…  personally i use a lot of combinators to avoid names, the most frequent being Control.Applicative stuff, Control.Monad stuff and 'maybe' and 'either'
10:28:03 <kmc> rostayob, i'd probably suck it up and write the boilerplate unless your types are *huge*
10:28:13 <rostayob> kmc: yes yes, absolutely.
10:28:28 <monochrom> still trying to optimize 8 lines into 80 lines?
10:28:54 <rostayob> but if there was a nice way of doing thing
10:29:02 <rostayob> welll... it'd been nice eheh
10:29:16 <kmc> (i wrote rowrecord in order to do CSV parsing of a schema with 12 records each with 5-8 fields
10:29:18 <kmc> )
10:29:30 <BrianHV> mm_freak_: yeah... I need to study applicative for a while so it's intuitive... it doesn't seem that hard, but I'm definitely not thinking that way yet
10:29:32 <kmc> you could also generate the boilerplate somehow
10:29:39 <kmc> a preprocessor like CPP or M4 or a totally custom codegen program
10:29:59 <kmc> i'm of the opinion that Haskell *really* needs a system intermediate in power/complexity between CPP and TH
10:30:11 <BrianHV> varUpdateIO was easy to write, and now my function is just toggleTimerVar timerVar = varUpdateIO timerVar toggleTimer
10:30:19 <BrianHV> I like this.
10:30:33 <rostayob> kmc:  I guess I agree, you end up (or at least I end up) wanting to use th loads of times but it's too ugly
10:31:18 <kmc> yeah
10:31:36 <kmc> that's why I think Liskell is a cool project
10:32:00 <kmc> i would not want to write a whole program in Liskell but i'd love to use it to write one module which uses heavy metaprogramming
10:33:18 <freedrull> i dont understand what you'd use lookAhead for in data.binary.get
10:33:42 <mm_freak_> BrianHV: just learn one combinator after another…  there is not much of a new concept to learn
10:33:50 <rostayob> kmc: god I just googled liskell
10:34:13 <rostayob> kmc: why would someone actually want the lisp syntax? I mean ok it's uniform and everything but it's really, really ugly
10:34:15 <mm_freak_> BrianHV: applicative style is all about generalizing application from functions to functors
10:35:05 * hackagebot storablevector 0.2.7.1 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.7.1 (HenningThielemann)
10:35:08 <BrianHV> mm_freak_: my problem is that I have to think really hard about sentences like that last one. ;)  though I'm finally at the point where "functors" is the only one I have to decode
10:35:14 <BrianHV> s/one/word/
10:36:21 <kmc> rostayob, for metaprogramming
10:37:13 <ozataman> is there a data structure that would kind of be like (Map (k1,k2,k3) SomeDataType), but would offer lookups with arbitrary combination of keys; i.e. using only k1, using k1 & k2, etc.?
10:37:24 <kmc> most of the nastiness of TH comes from varied and incomplete support for quoting and splicing
10:37:36 <kmc> s-expressions give you a single uniform way to do that
10:37:41 <rostayob> kmc: I'm sure we can figure out something better without lisp :P
10:37:52 <rostayob> yeah yeah lisp uniform syntax is great... great but ugly
10:38:12 <kmc> i also think lisp syntax is not that bad and that most people who trash it online have written less than 100 lines of any lisp-like language
10:38:24 <kmc> rostayob, you already said that
10:38:39 <kmc> i think we agree that TH is also ugly
10:39:01 <kmc> so if s-exprs are equally ugly but make metaprogramming easier
10:39:10 <kmc> wouldn't it make sense to use them for metaprogramming-heavy modules?
10:39:23 <mm_freak_> BrianHV: if you forget about all the category theory stuff a functor is simply a container-like type, over which you can map functions
10:40:19 <kmc> if your type F can implement:  (a → b) → F a → F b
10:40:20 <rostayob> kmc: I don't know, I never tought about the ideal meta programming syntax. I dont trash lisp (lisp is great) but I think it's still quite ugly
10:40:22 <kmc> then it's probably a functor
10:40:40 <lysgaard> Anyone have experience with the binary-communicator package?
10:40:55 <kmc> don't get me wrong, i don't hate lisp, some of my best friends are lisp
10:41:18 <rostayob> some of your best friend are lisp? eheh
10:41:23 <monochrom> methinks you anthropomorphize too much
10:41:30 <ion> Ah. Took me a while to realize why ap (,) works as \f v -> (v, f v) but it’s obvious in hindsight. :-)
10:41:35 <kmc> the "container" analogy for Functor is useful but it breaks down if you look at the representation of those values
10:42:00 <kmc> IO is a functor but the representation of a value of type (IO T) probably doesn't contain a T anywhere
10:42:00 <monochrom> what with "you type can implement ..." and "my best friends are lisp"
10:42:15 <kmc> just some code which could be executed to produce a T
10:43:16 <BrianHV> hmmm... yes.
10:43:19 <fryguybob> ozataman: Would the lookups be unique?
10:43:49 <kmc> likewise (S -> T) doesn't contain a T even though ((->) S) is a functor
10:43:55 <BrianHV> on a somewhat unrelated note, I feel like I've turned a corner in haskell. I've been working on it for almost a year, and I'm finally at the point where I feel like I can get stuff done without spending all my time battling the type system.
10:44:34 <mm_freak_> kmc: hence "container-like" =)
10:44:52 <ozataman> fryguybob: meaning a single unique combination of the individual keys would be present?
10:44:56 <kmc> yeah
10:44:58 <ozataman> fryguybob: if so, yes.
10:45:06 <fryguybob> ok
10:45:07 <kmc> i agree with "container-like" i'm just putting emphasis on the "like" ;)
10:45:42 <kmc> (S → T) is like an array indexed by S
10:45:49 <mm_freak_> BrianHV: just don't give up…  for me coding in haskell is quite natural now, so it's possible =)
10:45:57 <fryguybob> ozataman: But k1 could occur in more than one place?
10:46:11 <mm_freak_> BrianHV: just don't try too hard to understand everything, because the understanding comes as you use it
10:46:21 <mm_freak_> so don't be afraid to write real applications ;)
10:46:25 <ozataman> fryguybob: yes, definitely
10:46:27 <kmc> BrianHV, yeah... first you learn how to not battle the type system, then you learn how to make the type system work for you
10:46:56 <fryguybob> ozataman: So searches on "partial" keys would give more than one result?
10:47:16 <ozataman> fryguybob: right, exactly
10:47:41 <ozataman> fryguybob: so the search can start with the specific: try all 3 keys. if nothing is found, relax conditions and lookup by k1,k2. if that doesn't return anything now lookup by k1 only
10:49:21 <mm_freak_> once you master the type system it feels like a strange, magical weapon
10:49:44 <mm_freak_> it's quite an experience, when you come from weaker languages like C or PHP
10:49:46 <monochrom> not magical anymore
10:50:15 <BrianHV> I'm already seeing hints of what the type system can do. that's what's motivating me to stick with it.
10:50:18 <mm_freak_> monochrom: until you get used to it, at which point there is no return
10:50:27 <mm_freak_> it's so difficult for me to write PHP code nowadays
10:50:34 <boegel> is printing a large string String (with numbers and newlines) especially slow? 
10:50:47 <mm_freak_> boegel: not slower than printing a String in general
10:50:49 <boegel> using ByteString (both Lazy and strict) doesn't seem to make much difference
10:50:51 <BrianHV> I don't even revert to python much anymore. I can do almost everything I need to do for my one-off projects in haskell
10:51:02 <boegel> mm_freak_: any better (faster) options?
10:51:06 <BrianHV> (though I still want something to supplant django...)
10:51:28 <mm_freak_> boegel: yes, blaze-builder and/or enumerators
10:51:57 <mm_freak_> though lazy bytestrings should be fine most of the time
10:51:57 <boegel> mm_freak_: stuff that's in the Haskell Platforms? :)
10:52:09 <mm_freak_> boegel: lazy bytestrings ;)
10:52:14 <astory> if I compile haskell code to c code, can somebody compile the c code without haskell installed?  I'm submitting a project to somebody that probably doesn't have haskell installed.
10:52:14 <boegel> mm_freak_: basically, I need to print a (potentially large) list of Integer's
10:52:19 <mm_freak_> boegel: remember to use the bytestring-specific printing functions
10:52:25 <boegel> mm_freak_: doesn't seem much faster
10:52:37 <boegel> mm_freak_: I am (otherwise it doesn't typecheck :P)
10:53:33 <monochrom> if you use ghc to compile, you still need the rts provided by ghc.
10:53:35 <mm_freak_> boegel: when i was a beginner i found myself using hPutStr . B.unpack ;)
10:53:51 <astory> monochrom: is there a way around that?  like statically including the rts?
10:54:03 <mm_freak_> astory: yes, send them the binary
10:54:05 <boegel> mm_freak_: I wouldn't consider myself a beginner, but I'm a long way from expert
10:54:21 <boegel> monochrom: which RTS options do you have in mind that would make IO faster?
10:54:26 <astory> mm_freak_: ok, I'll do that, but I wanted a way to have it be architecture independent.  It's not super important.
10:54:27 <monochrom> it could be done but no one has done that. executable is statically linked by default.
10:54:42 <astory> ok, so it'd take compiler hacking.  oh well
10:54:47 <mm_freak_> boegel: if bytestring output is slow, the problem is somewhere else
10:55:03 <boegel> astory: there's a nice trick around that if you can't set RTS options directly on the command line
10:55:11 * hackagebot cookie 0.1.0 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.1.0 (MichaelSnoyman)
10:55:12 <boegel> mm_freak_: hmm, it might be
10:55:36 <mm_freak_> astory: you're asking to deploy a C program source code to someone, who is lacking the standard library
10:55:50 <boegel> astory: see http://www.haskell.org/haskellwiki/SPOJ#Garbage_Collection
10:55:56 <mm_freak_> *for something similar
10:56:13 * hackagebot http-enumerator 0.4.0 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.4.0 (MichaelSnoyman)
10:56:15 * hackagebot pool 0.0.1 - Thread-safe resource pools.  http://hackage.haskell.org/package/pool-0.0.1 (MichaelSnoyman)
10:56:17 * hackagebot xml-enumerator 0.2.0 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.2.0 (MichaelSnoyman)
10:56:34 <mm_freak_> boegel: in what way is it slow?  slow output or delayed output?
10:56:49 <mm_freak_> the latter may be related to laziness
10:56:51 <boegel> mm_freak_: it just takes too long ^_^
10:57:08 <boegel> mm_freak_: it's printing pretty fast, 
10:57:08 <monochrom> performance analysis is a whole-program analysis.
10:57:44 * boegel should profile his code
10:57:52 <astory> mm_freak_: yes, that was the intention.  I'm ok with it not being possible
10:58:27 <lysgaard> kmc: Is "bad file descriptor" a explainable error. I'm trying to open/read from a network handle and i get that error. What can make that happen?
10:58:50 <freedrull> i have a function that has a type :: Get [a], is there a function that will run this parser and return the number of bytes read as well?
10:58:51 <confound> are you trying to open it or read from it?
10:59:01 <kmc> lysgaard, what OS?
10:59:08 <lysgaard> kmc: linux
10:59:18 <kmc> that's an OS-level error so on Linux i'd use strace to see the actual sequence of syscalls
10:59:52 <boegel> mm_freak_: I'm trying to solve https://www.spoj.pl/ranks/PRIME1 (website seems down right now)
11:00:01 <kmc> astory, JHC produces mostly portable C code
11:00:38 <kmc> astory, sending GHC-produced binaries is usually ok; GHC will by default statically link its RTS and all Haskell libs
11:00:51 <kmc> which means the run-time requirements are no more than your typical dynamically-linked C program
11:01:00 <_mpu> > let id :: forall l a. l a -> l a = \x -> x in id (3 :: Int)
11:01:01 <lambdabot>   Couldn't match expected type `l a'
11:01:01 <lambdabot>         against inferred type `GHC.Types...
11:01:07 <_mpu> > let id :: forall l a. l a -> l a = \x -> x in id Nothing
11:01:08 <lambdabot>   Nothing
11:01:15 <_mpu> this is great
11:01:40 <mm_freak_> boegel: yeah, seems down
11:01:41 <pokoko222> guys coq is worth it to be learned or i should just keep doing my proofs on hand
11:01:54 <pokoko222> i mean it will take time to learn it, and well should i waste that time
11:01:58 <kmc> a coq in the hand is worth two in the bush
11:02:02 <_mpu> pokoko222: coq is nice
11:02:24 <pokoko222> you would say "it pays off on the long run"?
11:02:47 <_mpu> What are the rules in quantification of type variables in signatures ?
11:03:02 <boegel> mm_freak_: so, let's say I have a [[Integer]]
11:03:10 <kmc> _mpu, with respect to which situations?
11:03:15 <boegel> mm_freak_: i.e. a list of large lists of Integers
11:03:28 <_mpu> pokoko222: I had fun learning it, it is a very special way to do proofs
11:03:50 <kmc> it's way more fun than proofs by hand, it's like a puzzle game
11:03:53 <pokoko222> how much it takes to make the transition from doing things on paper to coq?
11:03:58 <monochrom> depends on what you prove
11:04:26 <_mpu> pokoko222: but it depends on what you are excepting to proove
11:04:43 <monochrom> "a proof acceptable to a traditional mathematician" is usually better off done by hand.
11:04:44 <pokoko222> i need it to play with logic, sets, relations and functions proofs
11:04:52 <pokoko222> i already do them on paper 
11:05:18 <pokoko222> later on algebraic structures groups and rings and bla bla
11:05:27 <pokoko222> the subject is algebraic structures...
11:05:50 <monochrom> however, a correctness proof for a program considered "boring to a traditional mathematicians" is better off done by coq or other theorem provers.
11:06:01 <_mpu> pokoko222: you might be interested in what does George Gonthier
11:06:47 <mm_freak_> boegel: using bytestrings doesn't help here
11:07:03 <_mpu> kmc: well for example I was surprised that let id :: l a -> l a = \x -> x does not work
11:07:16 <mm_freak_> boegel: though you can write a fast Integer -> ByteString converter (or use a ready-made one)
11:07:39 <boegel> mm_freak_: hmm, sounds interesting
11:07:42 <mm_freak_> boegel: your main bottleneck may be the lists, but that depends on how they are generated
11:08:06 <mm_freak_> if they are generated properly they should get fused away
11:08:45 <boegel> mm_freak_: it's a large list that is filtered (primes sieve)
11:08:56 <kmc> _mpu, hmm, and when i put in the forall's, it wants RankNTypes
11:08:57 <kmc> that is strange
11:09:20 <boegel> mm_freak_: I just removed all the pretty formatting stuff, and just did BSS.putStr . BSS.pack $ show list
11:09:30 <boegel> mm_freak_: seems to get about twice as fast :-/
11:09:37 <_mpu> kmc: so I thought it was mandatory to have a forall quantifier, but it seems to be sufficient if the type variable is present before a => in a signature
11:10:06 <_mpu> kmc: I had to enable glasgow exts
11:10:18 <_mpu> kmc: -fglasgow-exts
11:10:32 <monochrom> -fglasgow-exts may imply RankNTypes
11:10:35 <ozataman> fryguybob: any ideas?
11:10:56 <mm_freak_> boegel: 'show' is slow
11:11:06 <boegel> mm_freak_: hmmk
11:11:14 <boegel> mm_freak_: so how can I avoid it?
11:11:37 <fryguybob> ozataman: If you always have a priority for the key it might work as a Trie.  But nothing else comes to mind.
11:12:08 <ozataman> fryguybob: I see, thank you. I did think about tries, but have not used one directly before. I might look at it then.
11:12:24 <mm_freak_> > map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10) $ 572651
11:12:26 <lambdabot>   [1,5,6,2,7,5]
11:12:56 <mm_freak_> you could use blaze-builder to turn this into a ByteString efficiently
11:13:28 <tromp__> :t unfold
11:13:29 <lambdabot> Not in scope: `unfold'
11:13:31 <_mpu> why do we need rankntypes with this signature `forall l a. l a -> l a' ?
11:13:34 <tromp__> :t unfoldr
11:13:35 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:14:08 <mm_freak_> :t B.pack
11:14:09 <lambdabot> Couldn't find qualified module.
11:14:12 <mm_freak_> :t BC.pack
11:14:13 <lambdabot> Couldn't find qualified module.
11:14:21 <boegel> mm_freak_: I'm limited to stuff that's in the Haskell Platform for this...
11:14:37 <monochrom> actually ExplicitForAll sufficies
11:14:44 <_mpu> > :t many1 letter
11:14:44 <lambdabot>   <no location info>: parse error on input `:'
11:14:53 <_mpu> :t many1 letter
11:14:54 <lambdabot> Not in scope: `many1'
11:14:54 <lambdabot> Not in scope: `letter'
11:14:57 <boegel> :t Data.ByteString.Char8.pack
11:14:57 <mm_freak_> boegel: then you need to do it yourself…  you can use B.snoc
11:14:58 <lambdabot> String -> BSC.ByteString
11:15:05 <boegel> :t Data.ByteString.Char8.snoc
11:15:06 <lambdabot> BSC.ByteString -> Char -> BSC.ByteString
11:15:19 <jmcarthur> boegel: what is it that you're doing exactly that you are limited to the platform?
11:15:20 <confound> make my snoc the B.snoc
11:15:39 <jmcarthur> boegel: is this, bychance, ai challenge stuff?
11:15:53 <mm_freak_> boegel: well, with the HP you are quite limited
11:16:08 <boegel> jmcarthur: two things: preparing for a programming contest (they install the Haskell platform), and trying to solve stuff on spoj.pl (likewise, only the HP is available imho)
11:16:21 <boegel> jmcarthur: no, is there a new contest yet? :)
11:16:28 <jmcarthur> boegel: we working on one :)
11:16:30 <jmcarthur> *we're
11:16:37 <boegel> jmcarthur: I know you are :)
11:16:48 <jmcarthur> boegel: we're within a few weeks now
11:16:50 <boegel> jmcarthur: had a lot of fun with the last one, will try and compete in the one too
11:16:55 <boegel> jmcarthur: cool
11:17:05 <jmcarthur> boegel: we'll actually have a more modern ghc this time :D
11:17:11 <boegel> mm_freak_: yeah, well, I can add code as much as I like
11:17:18 <boegel> jmcarthur: GHC 7?
11:17:22 <mm_freak_> boegel: can the integers be negative?
11:17:22 <jmcarthur> i don't know about 2011.2, but at least the last platform
11:17:28 <boegel> mm_freak_: no
11:17:45 <mm_freak_> oh yes, you're making a prime sieve
11:17:46 <monochrom> 2011.2 is about to happen today.
11:17:47 <jmcarthur> boegel: 6.12, right now, unless i can squeeze in 2011.2 before we start
11:17:49 <boegel> mm_freak_: but they can be large (up to 10^9)
11:17:59 <mm_freak_> 10^9 is not large
11:18:06 <boegel> jmcarthur: 6.12 is fine by me
11:18:07 <jmcarthur> monochrom: yeah, but it isn't in ubuntu 10.10, so would at least require more setup on the servers
11:18:28 <jmcarthur> might be able to get it in though :)
11:18:29 <mm_freak_> boegel: should even fit into Int, so you could use some nondynamic function to make a bytestring
11:18:41 <boegel> >maxBound Int
11:18:44 <mm_freak_> boegel: but in fact i doubt that using bytestrings will improve performance here…  it might even decrease it
11:18:49 <boegel> !eval maxBound Int
11:18:57 <mm_freak_> > maxBound :: Int
11:18:57 <lambdabot>   9223372036854775807
11:18:59 <boegel> mm_freak_: little difference
11:19:07 <mm_freak_> that's 64 bits
11:19:12 <boegel> mm_freak_: non-dynamic function?
11:19:23 <mm_freak_> with 32 bits you get up to about 2 * 10^10
11:19:54 <mm_freak_> boegel: take n instead of takeWhile (> 0)
11:20:22 <mm_freak_> boegel: but really, printing the numbers is likely not your bottleneck
11:21:11 <boegel> mm_freak_: what do you mean by "take n instead of takeWhile (> 0)" ?
11:21:41 <boegel> mm_freak_: using Int instead of Integer yield 45% speedup :)
11:22:04 <mm_freak_> boegel: see the formula above
11:22:19 <mm_freak_> and yes, using Int can help, though not always
11:22:35 <mm_freak_> printing one million numbers takes less than two seconds here
11:22:40 <mm_freak_> Integer, not Int
11:23:14 <mm_freak_> if using Int speeds it up, that's a strong indication that your problem is not related to printing
11:23:20 <boegel> mm_freak_: I'm printing 33K numbers in my test case, but the testcase used by the SPOJ server is probably a lot larger
11:23:55 <mm_freak_> printing 100k numbers takes about 150 ms here
11:24:14 <boegel> mm_freak_: printing how? each number on a seperate line?
11:24:15 <mm_freak_> using 'print'
11:24:22 <mm_freak_> let me try that
11:24:44 <mm_freak_> each number on a separate line = 400 ms
11:24:50 <mm_freak_> by: mapM_ print
11:24:55 <boegel> hmm
11:24:58 <boegel> nice
11:25:01 <mm_freak_> (it's a flat list)
11:25:58 <boegel> mm_freak_: mapM_ (putStrLn "" . (mapM_ print)) would help
11:26:00 * boegel tries
11:26:17 <dmwit> type error
11:26:47 <mm_freak_> boegel: mapM_ (print >=> putChar '\n')
11:26:52 <mm_freak_> no
11:27:01 <mm_freak_> boegel: mapM_ (print >=> const (putChar '\n'))
11:27:11 <mm_freak_> no
11:27:18 <mm_freak_> lol
11:27:48 <monochrom> you want blank lines?
11:28:10 <mm_freak_> mapM_ (mapM_ print >=> const (putChar '\n'))
11:28:21 <boegel> mm_freak_: I need a blank line between the printing of lists
11:28:25 <jmcarthur> mapM_ $ putStrLn . show
11:28:34 <monochrom> alright no wonder
11:28:38 <jmcarthur> ah
11:28:47 <jmcarthur> mapM_ $ putStrLn . (++"\n") . show
11:28:50 <mm_freak_> boegel: so you want to print the individual lists as lists
11:28:51 <jmcarthur> :P
11:29:14 <boegel> mm_freak_: no, as number on seperate lines
11:29:21 <boegel> *numbers
11:29:21 <fryguybob> ozataman: Depending somewhat on what your values are maybe a map for each key into a Set of values, then intersect the sets?
11:29:28 <jmcarthur> um
11:29:35 <mm_freak_> boegel: you can use a combination of unlines and show
11:29:38 <weirdo> :t (+3) <*> (*100)
11:29:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
11:29:40 <lambdabot>     Probable cause: `*' is applied to too few arguments
11:29:40 <lambdabot>     In the second argument of `(<*>)', namely `(* 100)'
11:29:44 <monochrom> [[1,2],[3]] -> "1\n2\n\n3\n\n"
11:29:45 <weirdo> why doesn't this work?
11:29:46 <jmcarthur> oh i se
11:29:48 <jmcarthur> e
11:30:11 <mm_freak_> :t mapM_ (putStr . unlines . map show)
11:30:12 <lambdabot> forall a. (Show a) => [[a]] -> IO ()
11:30:23 <weirdo> when i put "some-fun <$>" in front of it it works
11:30:41 <weirdo> i don't understand the parsing of <$> and <*>
11:31:05 <jmcarthur> it's not a parsing issue
11:31:12 <mm_freak_> boegel: that even speeds it up a lot
11:31:13 <boegel> mm_freak_: but show is slow ^_^
11:32:04 <ozataman> fryguybob: yeah, that could work. I don't see the values overlapping
11:32:11 <ion> weirdo: ((+3) <*> (*100)) x would mean (x+3) (x*100). You can’t apply a number to a number.
11:32:23 <jmcarthur> > 3 100
11:32:24 <lambdabot>   3
11:32:28 <ion> jmcarthur: :-)
11:32:31 <jmcarthur> to confuse matters :)
11:32:46 <ion> > ((+3) <*> (*100)) 2
11:32:47 <mm_freak_> boegel: print = putStrLn . show
11:32:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
11:32:52 <jmcarthur> but that's just because the first 3 is given a cool type
11:32:55 <_mpu> :t <*>
11:32:55 <lambdabot> parse error on input `<*>'
11:33:01 <_mpu> :t ( <*> )
11:33:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:33:21 <jmcarthur> :t (+) <*> (*100)
11:33:22 <lambdabot> forall a. (Num a) => a -> a
11:33:48 <jmcarthur> > (+) <*> (*100) $ 2
11:33:49 <lambdabot>   202
11:34:12 <boegel> mm_freak_: ow
11:34:24 <boegel> mm_freak_: there's no way to avoid show?
11:34:52 <mercury^> @pl \a -> f <*> (pure a)
11:34:52 <lambdabot> (f <*>) . pure
11:34:57 <jmcarthur> what is it you want? Show a => a -> ByteString?  unfortunately, Show uses String
11:35:08 <mercury^> Hrm, why is there no shortcut for that? It seems a rather common operation to me.
11:35:51 <hpaste> teki pasted "Matching to an algebraic type"  http://hpaste.org/44671
11:36:03 <teki> how can i check which form of an ADT a variable is?  I am trying the code at http://hpaste.org/44671/matching_to_an_algebraic_type
11:36:41 <mm_freak_> boegel: write it yourself with the formula i've given you
11:36:47 <mm_freak_> that's faster than using 'show'
11:37:04 <monochrom> @type pure
11:37:05 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
11:37:34 <jmcarthur> teki: http://hpaste.org/paste/44671/matching_to_an_algebraic_type#p44672
11:37:41 <ion> weirdo: (,) <$> (+3) <*> (*100) $ x means (,) (x+3) (x*100). You can apply ((,) (x+3)) to (x*100) but you can’t apply (x+3) to (x*100).
11:37:48 <mm_freak_> boegel: but again, you're looking at the wrong spot
11:38:00 <mm_freak_> boegel: output/formatting is /not/ your bottleneck
11:38:02 <jmcarthur> teki: oh, are you wanting it to check that the two 'c's are equal?
11:38:14 <teki> jmcarthur: yes
11:38:29 <jmcarthur> teki: http://hpaste.org/paste/44671/matching_to_an_algebraic_type#p44673
11:38:54 <teki> jmcarthur: yeah, once you mentioned case i figured there was a good workaround
11:39:00 <ion> > (,) <$> (+3) <*> (*100) $ x
11:39:01 <lambdabot>   (x + 3,x * 100)
11:39:15 <teki> jmcarthur: thanks for the help, though
11:39:31 <jmcarthur> np
11:39:42 <mm_freak_> boegel:
11:39:45 <mm_freak_>     mapM_ (putStrLn . unlines . map show) $ do
11:39:46 <mm_freak_>         fmap (\x -> [x..x+999]) [1000000, 1001000 .. 1999999]
11:40:09 <mm_freak_> this code prints one million numbers in the way you specified and needs about 1.6 seconds on my system, which is a slow netbook right now
11:40:32 <mm_freak_> oh, scratch the 'do'…  it's there for historical reasons =)
11:40:45 <boegel> mm_freak_: mapM_ putStr . intersperse "\n" $ map (unlines . map show) ps
11:40:51 <boegel> mm_freak_: this does what I want
11:41:08 <hpc> @src unlines
11:41:09 <lambdabot> unlines = concatMap (++ "\n")
11:41:18 <boegel> mm_freak_: spoj.pl is still down to figure out whether it's fast enough now though :(
11:41:20 <hpc> @src intersperse
11:41:20 <lambdabot> intersperse _   []     = []
11:41:20 <lambdabot> intersperse _   [x]    = [x]
11:41:20 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
11:41:45 <hpc> huh
11:41:45 <boegel> > concat $ intersperse 1 [[2,3],[4,5],[6,7]]
11:41:46 <lambdabot>   No instance for (GHC.Num.Num [a])
11:41:46 <lambdabot>    arising from a use of `e_11234567' at ...
11:41:55 <boegel> > concat $ intersperse [1] [[2,3],[4,5],[6,7]]
11:41:56 <lambdabot>   [2,3,1,4,5,1,6,7]
11:42:05 <djahandarie> Oh wow, the type family example in Discussion is pretty neat here: http://hackage.haskell.org/trac/ghc/wiki/KindFact
11:42:11 <boegel> > intersperse 1 [2..5]
11:42:12 <lambdabot>   [2,1,3,1,4,1,5]
11:42:28 <mm_freak_> boegel: likely unlines is faster
11:42:55 <djahandarie> (If there is fusing being done)
11:42:59 <hpc> :t intersperse "\n"
11:43:00 <lambdabot> [[Char]] -> [[Char]]
11:43:01 <hpc> :t unlines
11:43:02 <lambdabot> [String] -> String
11:43:04 <hpc> :P
11:43:16 <teki> jmcarthur: in fact just Branch c trees will match (and work); you don't have to add the guard
11:43:20 <boegel> mm_freak_: I need both
11:43:38 <mm_freak_> boegel: not for the printing like you specified it
11:43:38 <boegel> mm_freak_: intersperse is only used on the small top list
11:43:56 <jmcarthur> teki: it won't do the check
11:43:57 <boegel> mm_freak_: yes, I need a blank line *between* the printing of lists
11:44:00 <jmcarthur> teki: that's binding a new c
11:44:09 <mm_freak_> boegel: try my code above
11:44:14 <mm_freak_> the latest one
11:44:29 <mm_freak_> notice that i changed putStr to putStrLn
11:44:54 <teki> jmcarthur: if it bound the new c, wouldn't there be a compile error?
11:45:08 <jmcarthur> teki: if you are using -Wall you should get a warning, otherwise nothing
11:45:12 <mm_freak_> for [[a,b], [c,d]] it prints "a\nb\n\nc\nd\n"
11:45:20 <boegel> mm_freak_: ok, but that adds an extra blank line at the end
11:45:32 <mm_freak_> boegel: is that bad?
11:45:35 <boegel> mm_freak_: and that difference is important for me
11:45:38 <boegel> mm_freak_: it might be
11:45:39 <mm_freak_> i see
11:45:48 <mm_freak_> then use intercalate instead of intersperse at least
11:46:02 <boegel> mm_freak_: the output is checked automatically by the problem judge, and it might trip over an extra blank line
11:46:04 <boegel> :t intercalate
11:46:05 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:46:06 <mm_freak_> > intercalate "\n" ["abc", "def", "ghi"]
11:46:06 <lambdabot>   "abc\ndef\nghi"
11:46:56 <boegel> :t intersperse
11:46:57 <lambdabot> forall a. a -> [a] -> [a]
11:47:13 <mm_freak_> boegel: with intercalate it takes 1.8 secs
11:47:18 <mm_freak_> with unlines 1.6 secs
11:47:31 <mm_freak_> so you might be better of just using unlines and 'last'
11:47:33 <mm_freak_> uhm
11:47:35 <mm_freak_> 'init'
11:48:21 <tdresser> @pl f a b = a + b * y
11:48:21 <lambdabot> f = (. (y *)) . (+)
11:48:41 <tdresser> @pl f a b = a + b * a
11:48:42 <lambdabot> f = liftM2 (.) (+) (*)
11:52:29 <mm_freak_> boegel:
11:52:35 <mm_freak_>     putStr . intercalate "\n" . map (unlines . map show) $ do
11:52:35 <mm_freak_>         fmap (\x -> [x..x+999]) [1000000, 1001000 .. 1999999]
11:52:37 <mm_freak_> 4 seconds
11:53:51 <boegel> mm_freak_: the problem has a 6s limit, and that includes sieving the primes... :)
11:56:12 <ozataman> fryguybob: thanks a lot for the ideas!
11:58:46 <frerich_> Hi; as a small exercise, I'm trying to write a tic tac toe game in Haskell. However, I'm totally unsure how to model this. What I came up with for now was that there's a Cell type (Empty | Cross | Circle) and the playground is a [[Cell]] (I'm undecided whether I should maybe use a 3x3 tuple instead).
11:59:15 <kmc> lists aren't really made for random indexing, they're more like for loops than like data structures
11:59:22 <kmc> but, it will totally not matter at a 3x3 size
11:59:33 <frerich_> What's totally unclear to me is: how do I model the game flow? I was thinking of having a function which takes a 'turn' and a 'playground' and returns a new playground. And another function for deciding whether the game is finished. And probably a third for displaying the current playground.
11:59:35 <kmc> you could also use Data.Array but i find its API to be clunky
11:59:46 <frerich_> kmc: Ah, but that's already interesting. I'm looking for a "haskellish" way to do this :)
12:00:06 <kmc> that sounds like an excellent way to organize the code
12:00:32 <frerich_> My initial idea was that the 'Game' is actually a recursive function which applies a turn to a playground, and then repeats that. However, I later realized that getting a turn from the player needs IO
12:00:59 <frerich_> So I guess I need a toplevel IO function which does the 'get turn, apply turn, display playground, check for end of game' loop.
12:02:28 <frerich_> kmc: Ok, thanks for giving me some direction :-)
12:02:38 <tromp__> for a 3x3 game, use bitmaps
12:03:02 <kmc> heh
12:03:06 <kmc> that seems like excessively much work
12:04:25 <tromp__> it works fine in my connect-4 code
12:04:29 <burp> tictactoe enumertee
12:04:43 <frerich_> Oooh, you have code for a connect-4 game? Is it possible to see that somewhere?
12:05:26 <tromp__> http://www.cwi.nl/~tromp/c4/fhour.html has a source tar link
12:05:37 <tromp__> it includes c, java, and haskell versoins
12:06:14 <freedrull> whats a tuple with 3 elements instead of 2 called....
12:06:18 <hpc> triple
12:06:27 <kmc> a 3-tuple :)
12:06:47 <hpc> "truffle"!
12:07:07 <freedrull> are there functions for 3 tuples or do you have to make your own
12:07:30 <boegel> mm_freak_: just resubmitted the solution to SPOJ, again "time limit exceeded"
12:07:39 <boegel> mm_freak_: see https://www.spoj.pl/problems/PRIME1/ (works now)
12:08:07 <mauke> spoj.pl judges are generally pretty lenient regarding whitespace
12:08:18 <kmc> freedrull, mostly not, but see the "tuple" library on hackage
12:08:31 <kmc> freedrull, if you're using tuples heavily it's a sign that maybe you should create a new data type instead
12:08:41 <byorgey> freedrull: you have to make your own.  However, note that if you are using 3-tuples a lot there is probably a better way to do whatever you are doing
12:09:33 <freedrull> byorgey: kmc well its a library im using that is using the 3 tuple not me...
12:09:43 <freedrull> runGetState from Data.Binary returns a 3 tuple
12:09:59 <hpc> @hoogle runGetState
12:09:59 <lambdabot> No results found
12:10:12 <byorgey> freedrull: ah, fair enough.
12:10:12 <kmc> ok
12:10:31 <byorgey> there should be a package for this situation, sort of like spoon =)
12:11:01 <byorgey> which would use TH to adapt functions returning tuples to your custom data type
12:11:18 <kmc> freedrull, you can invoke that function as «let (val, bs, n) = runGetState getter inpt k in …»
12:11:32 <kmc> or «case runGetState getter inpt k of (val, bs, n) -> …»
12:14:22 <freedrull> kmc: oh that looks good...
12:18:01 <hpaste> runiq pasted "~/.mpdconf"  http://hpaste.org/44675
12:18:38 <runiq> Whoops, sorry.
12:18:46 <freedrull> hehe
12:19:00 <freedrull> runiq: #mpd?
12:20:17 <runiq> freedrull: I mis-clicked, I didn't want to post it to #haskell, really.
12:20:28 <weirdo> is applicative style with <*> on functions and lists of functions used a lot?
12:20:37 <weirdo> it scares me. the pain, the pain...
12:20:48 <dons> http://hackage.haskell.org/platform/  :D
12:21:05 <kmc> yay!
12:21:05 <hpc> :t and
12:21:06 <confound> woo
12:21:06 <lambdabot> [Bool] -> Bool
12:21:06 <hpc> :t or
12:21:07 <lambdabot> [Bool] -> Bool
12:21:21 <runiq> Woohoo, nice
12:21:25 <kmc> when will debian have it? ;)
12:21:26 <merijn> It's a bit pink, isn't it? :>
12:21:37 <monadic_kid> oh was that pure fluke, i just downloaded & installing platform now, i thought it's been out for a few days already
12:21:48 <hpc> > [(&&),(||)] <*> [False, True] <*> [False, True]
12:21:48 <lambdabot>   [False,False,False,True,False,True,True,True]
12:21:51 <byorgey> weirdo: not a lot, no
12:22:18 <merijn> How experimental is the experimental 64bit support for OSX?
12:22:36 <lince> hi ppl 
12:22:55 <lince> \join #mysql
12:23:08 <hpc> lince: /
12:23:17 <hpc> :P
12:23:20 <lince> yes its done thanks 
12:23:21 <lince> ;)
12:23:38 <weirdo> thanks for all the help, guys!
12:23:40 <weirdo> detached
12:23:42 <lince> eheh  long time away from irc
12:24:38 <wagle> yay!  2011.2 is out
12:24:39 <HugoDaniel> haskell platform!!!
12:24:55 <merijn> It has been for a few days, hasn't it?
12:25:07 <djahandarie> No.
12:25:10 <djahandarie> Just came out. :)
12:25:20 <jmcarthur> sweet!
12:25:36 * hackagebot haddock 2.9.2 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.9.2 (DavidWaern)
12:26:12 <merijn> Now I just need to figure out how to uninstall the old OSX versions
12:26:53 <runiq> New haddock? Is it able to generate system-wide indices yet?
12:29:43 <dons> HP release needs your upmods love  http://news.ycombinator.com/item?id=2310761 
12:30:21 <merijn> dons: Non-existent link? Doesn't show anything when I go there...
12:30:26 <kmc> likewise
12:30:29 <djahandarie> Same
12:30:40 <roconnor> @hoogle callCC
12:30:41 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
12:30:54 <roconnor> @hoogle runCont
12:30:55 <lambdabot> Control.Monad.Cont runCont :: Cont r a -> (a -> r) -> r
12:30:55 <lambdabot> Control.Monad.Cont runContT :: ContT r m a -> (a -> m r) -> m r
12:31:19 <dons> merijn: interesting
12:31:28 <merijn> Maybe HN is slow again, it's not loading CSS for me atm either
12:31:30 <dons> http://news.ycombinator.com/newest does it show up here?
12:31:42 <mercury^> Are there equivalents of Data.Traversable etc. in category-extras?
12:31:47 <hpaste> freedrull pasted "getEvents"  http://hpaste.org/44677
12:31:48 <kmc> they probably deleted it; try submitting "Lisp Platform 2011.2" or "Building your Agile startup using Haskell Platform"
12:31:59 <djahandarie> Hahaha
12:32:13 <djahandarie> dons, it doesn't
12:32:20 <opqdonut> was there an announcement on some list or something?
12:32:42 <opqdonut> google can't find anything, and I can only get the changelog from the haskell platform site
12:32:43 <wagle> http://news.ycombinator.com/item?id=2310761 doesnt work
12:33:01 <djahandarie> opqdonut, it was released moments ago
12:33:02 <wagle> http://news.ycombinator.com/newest gives a list
12:33:06 <dons> weird.
12:33:08 <merijn> Anyhoo, how experimental is the experimental 64bit support?
12:33:18 <djahandarie> opqdonut, http://www.haskell.org/pipermail/haskell-cafe/2011-March/090082.html
12:33:27 <opqdonut> thanks
12:33:33 <dons> yeah, doesn't show up for me. weird
12:33:35 <opqdonut> I want to spread the word :)
12:33:43 <dons> well, they might just block cdn links (nyud.net
12:33:45 <dons> hmm
12:34:00 <djahandarie> It is mirrored on the actual site too isn't it?
12:34:12 <monadic_kid> i downloaded it about 15 mins ago
12:34:14 <dons> well, the site is not explicitly mirrored
12:34:59 <djahandarie> dons, I mean, we could safely use http://hackage.haskell.org/platform/ for places that don't like CDNs, right?
12:36:01 <dons> djahandarie: yeah, prob. ok.
12:36:04 <dons> its a good host
12:36:40 <rostayob> what's the best way to get the current time in haskell?
12:37:11 <parcs> @hoogle getCurrentTime
12:37:12 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
12:37:12 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
12:37:44 <rostayob> parcs: thanks
12:40:07 <dons> how about this then?  http://news.ycombinator.com/item?id=2310846
12:40:56 <kmc> works for me
12:41:05 <kmc> GHC 7 ∀
12:41:07 <poucet> dons: nice new site
12:41:32 <dons> funny. they just must block cdn links
12:41:34 <dons> that's annoying
12:41:38 <merijn> pffft, only 3 upvotes so far after mine
12:42:24 <djahandarie> 4 ;)
12:42:39 <drhodes> 6
12:43:37 <confound> should I wait for an ubuntu package or build it from source?
12:44:05 <merijn> Real men build from source :>
12:44:39 <parcs> i'd wait for the ubuntu package
12:45:03 <dons> feel free to roll a torrent for  the windows installer. i can host it
12:45:16 <confound> I have the previous version installed via ubuntu
12:45:18 <kmc> yay 'text' is in HP 2011.2
12:45:46 <mm_freak_> boegel: what kind of sieve?
12:46:00 <hpaste> otulp pasted "SEG-Y iteratee with state"  http://hpaste.org/44678
12:46:12 <otulp> There's my problem :)
12:46:34 <monochrom> w00t dons
12:46:42 <otulp> I'm looking for some pointers on using iteratees (from enumerator) with state.
12:46:48 <freedrull> oh wait that isnt how case expressions work...should i use a let-in? http://hpaste.org/44677/getevents
12:46:58 <boegel> mm_freak_: Erasthosthenes
12:47:03 <boegel> mm_freak_: anyway, time for bed
12:47:22 <mm_freak_> otulp: i've only read the comment…  have you seen the 'isolate' function?
12:47:25 <parcs> i'm pretty disappoint that lang/ghc is still version 6.10 in freebsd
12:47:29 <monochrom> yes unfortunately nyud.net is widely blocked because of a few black sheeps and because anti-malware take the easy way out.
12:47:33 <mm_freak_> boegel: use STUArray for that
12:47:41 <mm_freak_> it's about the fastest solution you can get in haskell
12:47:57 <mm_freak_> compared to C it is slightly slower, though
12:48:02 <boegel> mm_freak_: is it in the platform? :)
12:48:07 <mm_freak_> boegel: yes
12:48:21 <otulp> mm_freak_: Nope.
12:48:32 <monochrom> anyway this is too sakura for me :)
12:48:41 <mm_freak_> boegel: 'array' library, Data.Array.ST
12:48:49 <boegel> mm_freak_: hmmk
12:48:56 <boegel> mm_freak_: what I have now is available at
12:49:00 <mm_freak_> boegel: should be about a five-liner
12:49:04 <boegel> mm_freak_: I'm off to bed, ttyl
12:49:08 <monadic_kid> array should be part of platform
12:49:10 <mm_freak_> ok, good night
12:49:10 <boegel> mm_freak_: *at boegel.kejo.be/files/prime1.hs
12:49:22 <otulp> mm_freak_: isolate doesn't look like what I need.
12:49:37 <monochrom> dons: is "hp-tmp" going to be not-so-tmp? :)
12:49:52 <otulp> Or, at least I don't see how it applies.
12:49:53 <dons> eventually
12:49:54 <dons> its ok for now
12:50:02 <mm_freak_> otulp: for your headers
12:51:15 <otulp> mm_freak_: So, do things i two passes. First just the reel headers, get what I need. Then re-run, ignoring the headers, and going straight for the traces. I guess that's a way to do it.
12:51:45 <mm_freak_> otulp: doesn't sound like a good way to me
12:52:10 <otulp> Seems hackish, yes. But that's how I figured you meant isolate would be used.
12:53:01 <mm_freak_> nope, isolate is an enumeratee
12:53:04 <pr> haskell just got pink!
12:53:04 <rostayob> How can I set a language flag while in ghci?
12:54:01 <shachaf> rostayob: :set -XLanguageFlag
12:54:25 <rostayob> shachaf: thanks
12:55:09 <mm_freak_> otulp: you apply isolate to an iteratee, which works with part of the header
12:55:11 <merijn> pr: Damn pinko's with their hippie languages! :>
12:55:35 <mm_freak_> (joinI $ isolate 3200 $$ processReelHeader) >> restIteratee
12:55:41 <parcs> you can also set it upon calling ghci (ghci -XLanguageFlag). with that, you can create an alias for ghci to automatically provide you with the most common language extensions such as OverloadedStrings
12:56:07 <otulp> mm_freak_: I don't get how that provides restIteratee with the needed configuration.
12:56:26 <mm_freak_> otulp: use (>>=) instead of (>>)?
12:56:46 <mm_freak_> reelHeaderInfo <- joinI $ isolate 3200 $$ reelHeader
12:56:48 <mm_freak_> …
12:59:42 <otulp> D'oh. I think I see it. Though no need for isolate. If you are right, then that whole state thing was a massive brain fart on my behalf.
12:59:47 <pr> merijn: :D
13:00:06 <merijn> If I have a thread which needs to wait for info coming over either a socket or Chan is there a nice way to do this or should I just spawn an additional thread to monitor the socket and have that write to the Chan as well (adding an annotation to designate where the info came from)
13:01:52 <Ptival> I can't "catch" a Nothing inside of a "do" expression, right? (if you see what I'm trying to mean...)
13:02:06 <dons> pattern match?
13:02:22 <merijn> Ptival: What exactly are you trying to do?
13:02:54 <Ptival> basically what I want to do is try a first computation, and depending on its success or failure, do something different next
13:03:27 <merijn> Ptival: You want either pattern matching as dons suggested or the Maybe monad
13:03:45 <Twey> :t maybe
13:03:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:03:50 <Ptival> well I was using the Maybe monad there, but
13:04:16 <Twey> maybe failureValue somethingDifferent $ yourComputation
13:04:38 <Ptival> try2Things = do { e1 <- trySthg e ; --here I want to try something else if I had Nothing ; return sthg }
13:05:40 <Ptival> Twey: thanks, that should help
13:05:58 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml updated for 2011.2.0.0 :)
13:06:26 <djahandarie> monochrom, :)
13:07:36 <monadic_kid> where does template haskell look for shared libraries/dlls again? 
13:09:01 <dons> also on reddit http://www.reddit.com/r/programming/comments/g1g10/the_haskell_platform_20112_is_out_ghc_7_for_all/ 
13:09:06 <dons> traffic looking good so far
13:09:26 <monochrom> btw where was 2011.1.0.0? XD
13:09:55 <merijn> Zero index month as second release number? :p
13:10:02 <merijn> s/index/indexed
13:10:08 <dons> monochrom: it was the preview during jan/feb
13:10:11 <dons> RC only
13:10:57 <monadic_kid> " can't load .so/.DLL for:" ghci/template haskell I knew how to fix this problem before, i'm pretty sure i just need to copy the shared library dll in the correct place
13:13:34 <merijn> If I have a thread which needs to wait for info coming over a socket and Chan is there a nice way to do this or should I just spawn an additional thread to monitor the socket and have that write to the Chan as well (adding an annotation to designate whether the info originally came from another Haskell thread or the socket)
13:13:54 <monochrom> oh w00t haskell platform endorses parsec-3 :)
13:14:30 <c_wraith> merijn: I don't know of any way to block on either, so your idea sounds appropriate
13:14:37 <monochrom> now I have no excuse. I must update something on the haskell wiki...
13:15:21 <dons> monochrom: damn straight
13:15:24 <dons> the war is over
13:16:08 <djahandarie> Heh
13:16:16 <merijn> c_wraith: That's what I feared, it's a shame, I think it's really ugly. Spawning a separate thread for the socket is ok, but it'd be much nicer if you could give that a separate thread and then have something like select for Chan's
13:16:38 <merijn> But since Chan's are implemented using MVar's I'm not sure whether that's even possible to implement...
13:17:18 <merijn> Oh, I guess there's a tryTakeMVar, but then you'd essentially be polling all Chan's in the set
13:17:21 <jmcarthur> merijn: there's always the library approach. i've used orc before. pretty nice for stuff like that
13:17:44 <monochrom> most likely an easy s/ParserCombinators\.//g haha
13:19:58 <otulp> mm_freak_: Thanks. Much better now. Can't imagine why I was so stuck on this whole state thing.
13:20:13 <dons> someone update  the title pleasE?
13:21:00 --- mode: ChanServ set +o monochrom
13:21:18 <gwern> double check my logic here - if 2000 gigabytes costs $80, and something uses up 20 gigabytes, then the cost of that 20 gigabytes is 20 * (80 / 2000), or 0.8 or 80 cents
13:21:28 <merijn> jmcarthur: I dunno, Orc doesn't really look like what I want (granted, I only looked at it for like 5 secs just now)
13:21:57 <mm_freak_> otulp: you're welcome
13:22:11 <jmcarthur> merijn: it lets you merge the output of things executed in multiple threads into common streams of data and stuff like that without any major effort
13:22:47 <jmcarthur> merijn: for one, you could possible avoid the need for Chan altogether, but even if not, you can just say something like   x <- readFromChanA <|> readFromChanB
13:22:48 --- topic: set to '["new! Haskell Platform 2011.2: http://is.gd/dCGPn", "Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by monochrom
13:22:51 <merijn> jmcarthur: In a way that let's you block on multiple streams?
13:22:53 <jmcarthur> *possibly avoid
13:23:01 --- mode: monochrom set -o monochrom
13:23:04 <jmcarthur> merijn: see that example i gave
13:23:28 <monochrom> hmm strange, doesn't Text.Parsec re-exports Text.Parsec.String?
13:23:35 <dixie>     My brain just exploded.
13:23:35 <dixie>     I can't handle pattern bindings for existential or GADT data constructors.
13:23:35 <dixie>     Instead, use a case-expression, or do-notation, to unpack the constructor.
13:23:37 <dixie> hehe ;)
13:23:43 <lpsmith> gwern, sounds right to me :)
13:23:53 <jmcarthur> merijn: that will eventually give you values from both chans, but you can also restrict the result to just the first one that returns
13:24:38 <merijn> jmcarthur: Hmm, I guess I'll give the paper  more thorough read then
13:24:52 <monochrom> oh wow, re-exports Text.Parsec.String but hides everything?!
13:25:13 <monochrom> (well, hides everything except an unhidable instance)
13:25:50 * monochrom will cope
13:27:01 <TomMD> Just set -XExplictInstanceExports to hide that instance.  Also, be sure to set -XEnableImaginaryGHCExtentions
13:27:26 <c_wraith> the nice thing about -XEnableImaginaryGHCExtensions is that it enables itself!
13:27:38 <TomMD> Right, I completely forgot about that.
13:27:52 <merijn> jmcarthur: I still think it's rather silly that there's no primitive shipping with GHC which allows 1 thread to act as intermediary between two other sets of threads. As that is something I somehow seem to find myself needing a lot
13:28:16 <jmcarthur> no need to be primitive though
13:28:27 <TomMD> What do you mean by intermediary?  A transformation on data before it is received by the second thread?
13:32:07 <merijn> TomMD: Basically I get input from "worker" threads, need to combine all this information to send out over a socket, but also send information coming in over the socket back to all the workers
13:32:53 <merijn> But I think I'll just go with the "one big chan and tag the direction of traffic" solution
13:34:23 <jlouis> Do you have to do anything special to get access to the IO-manager?
13:34:29 <jlouis> i.e., the new one
13:34:42 <jlouis> that is, does it take -threaded?
13:34:48 <c_wraith> jlouis: yes
13:34:58 <merijn> jlouis: I think it "Just Works"?
13:35:19 <c_wraith> I'm pretty sure they only replaced the IO manager for the threaded runtime
13:35:23 <jlouis> I am just seeing worse runtimes with GHC7 so I was wondering...
13:35:27 <c_wraith> the non-threaded runtime has an entirely different system
13:35:38 <jlouis> yeah, that is the interesting thing
13:35:59 <dons> jlouis: yes, entirely new concurrency layer (the io manager), now based on epoll etc.
13:36:18 <jlouis> dons: yeah, but how do you enable it?
13:36:23 * kmc wonders what an IO manager could even do for the non-threaded runtime
13:36:27 <thoughtpolice> jlouis: it's enabled by default if you use -threaded
13:36:34 <thoughtpolice> no need for anything special
13:36:39 <jlouis> ah, -threaded it is then for the tests
13:36:41 <jlouis> :)
13:36:48 <thoughtpolice> i believe several nasty bugs in the new IO manager were also squashed in 7.0.2, iirc
13:36:50 <hpc> kmc: blocking/non-blocking trickery?
13:36:55 <thoughtpolice> (guess who trolls the GHC trac constantly)
13:37:23 <jlouis> what do we want? GHC6.12 (non-threaded as it is fastest for combinatorrent), GHC7 threaded and nonthreaded
13:37:45 <jlouis> anything else?
13:37:54 <kmc> GHC 6.12 threaded, for completeness?
13:38:01 <jlouis> yeah, why not
13:38:09 <hpc> 6.12 is still being developed?
13:38:18 <hpc> *maintained
13:38:22 <thoughtpolice> no, but it is much more widespread than GHC 7
13:38:23 <kmc> it is?
13:38:29 <thoughtpolice> the 6.12 branch has been done for a while now
13:39:05 <thoughtpolice> currently the STABLE branch reflects ghc 7.0.2. prior to 7.0.1, STABLE reflected 6.12.3 (roughly speaking)
13:39:29 <jlouis> GHC6.12 still lingers in too many distributions
13:39:38 <jmcarthur> too many for what?
13:39:44 <jlouis> It will probably linger for half a year more in Ubuntu 11.04
13:40:07 <monochrom> if you are a library author or something, try to support 6.12 for 9 more months IMO
13:40:15 <jmcarthur> is ubuntu 11.04 already frozen on the previous haskell platform?
13:40:20 <thoughtpolice> the haskell community obviously likes and wants to drive fast - 6.12 is so last year, man.
13:40:24 <merijn> I say, deprecate with a sledge hammer :>
13:40:24 <kmc> half a year? Ubuntu 8.04 is still supported
13:40:39 <jlouis> jmcarthur: they *tend to freeze* some months before release
13:40:44 <jmcarthur> kmc: and ghc 6.8 is all but forgotten
13:40:49 <jlouis> It is the same story with Erlang...
13:40:51 <Cale> Does 7 have enough library support to be usable now?
13:40:51 <aavogt> is compatibility really that difficult this time?
13:41:03 <jmcarthur> Cale: i've been using it as my main ghc
13:41:06 <jmcarthur> no problems here
13:41:07 <Cale> cool
13:41:10 <monochrom> 7 has new Haskell Platform support to be usable now
13:41:15 <jlouis> Cale: I could pretty easily use it for combinatorrent
13:41:16 * hpc is tempted to use ghc5 now
13:41:34 <monochrom> so for example no more "hi I can't build cabal-install!"
13:41:41 <thoughtpolice> Cale: i've been using 7 on most of my machines since 7.0.1 was released
13:41:48 * kmc started Haskelling on GHC 6.4
13:41:52 <thoughtpolice> and is pretty stable; i just upgraded to 7.0.2
13:42:00 <jlouis> I started on 4-something
13:42:04 <Cale> I can't exactly switch so easily unless the other iPwn guys come with me, but we probably will at some point :)
13:42:09 <jlouis> but I've been on-n-off
13:42:23 <thoughtpolice> kmc: i got to start with 6.6, i remember how excited an SMP-capable runtime was for everyone :>
13:42:29 <thoughtpolice> *exciting
13:42:30 <kmc> new in GHC 6.4: ghci for amd64 Linux
13:42:43 <kmc> yeah
13:42:51 <hpc> i think i started with 6.10
13:43:09 <kmc> i remember a good two years of people saying "pure languages are great for parallelism" with absolutely zero way to demonstrate it in GHC
13:43:10 <jlouis> the cool thing aobout a new compiler is that your program gets faster and you have to do nothing at all
13:43:27 <Cale> I think I started with 5.02. It was 5.something anyway :)
13:43:47 <monochrom> does iPwn use 6.12? I don't think you need to worry about 6.12 being forgotten in the short future
13:44:07 <kmc> afaik the iphone stuff is still on 6.10.4
13:44:13 <merijn> btw, does anyone remember where the pretty graphs about the speedup of the "new" threaded gc can be found? Was discussing parallel haskell with a friend and he complained the gc has to freeze all threads...
13:44:20 <monochrom> ah 6.10 is getting borderline now :)
13:44:53 <thoughtpolice> merijn: http://hackage.haskell.org/trac/ghc/blog/new-gc-preview
13:45:02 * frerich_ reads up on Data.Array and thinks that "Haskell provides indexable arrays, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers." is really the most complicated description for an array he ever saw
13:45:05 <monochrom> but in the case of iPwn you don't need any new libs in the short future anyway
13:45:12 <Cale> Yeah, we're using 6.12 right now. We'll probably want to switch to 7. It sounds like Ryan may actually end up paying someone to work on GHC (particularly when it comes to fixing up the translation of arrow syntax)
13:45:17 <merijn> thoughtpolice: Nice, that's the one  I was thinking of
13:45:20 <thoughtpolice> merijn: the new GC will still freeze all threads when it must do a major garbage collection, but it won't have to freeze threads for minor collections
13:45:25 <thoughtpolice> important to remember
13:46:03 <thoughtpolice> (technically, when i say 'threads' I mean OS threads - nursery objects are per-thread, so it will block any GHC threads on that CPU, but it won't block the other CPU threads)
13:46:16 <monochrom> I personally would say "upgrade after your current product release is shipped and you begin the next product release cycle"
13:46:47 <monochrom> "get your thesis^H^H^H^H^H^H product shipped first!" :)
13:46:51 <thoughtpolice> Cale: fun stuff, i hope to play bloodknight sometime in the future :)
13:47:02 <Cale> :)
13:48:19 <monochrom> In the Atlanta Olympic Games IBM purportedly did not adhere to that rule and therefore lost 2 days - 2 crucial days, like, 2 days after the Game opened.
13:48:26 <Ptival> tryBetaReduce (App e1 e2) = maybe (Just (App e1 (fromJust (tryBetaReduce e2))))
13:48:26 <Ptival>                                   (\e -> Just (App e e2))
13:48:27 <Ptival>                                   (tryBetaReduce e1)
13:48:36 <Ptival> is there some way to reduce this?
13:48:45 <thoughtpolice> Cale: can i ask what the gripe about arrow syntax translation is? i think i might have seen something on the bugtracker about it, is it a longstanding issue (if i'm thinking of the right one)?
13:49:01 <Ptival> like the first line, can I use something like "lift"?
13:49:04 <kmc> Ptival, why are you using fromJust?
13:49:41 <monochrom> hrm the haskell wiki seems to be not very responsive.
13:49:46 <kmc> as uses of "maybe" go that one is pretty convoluted; i'd try rewriting it with pattern matching and see if it looks better
13:49:54 <Ptival> kmc: App :: Lambda -> Lambda -> Lambda, while tryBetaReduce :: Lambda -> Maybe Lambda
13:49:56 <hpc> Ptival: Just (App e1 (fromJust (tryBetaReduce e2))) <--> App e1 <$> tryBetaReduce e2
13:50:01 <hpc> or something like that
13:50:14 <kmc> Ptival, right, but when you say "fromJust" you're asserting that a Maybe can never be Nothing; how are you able to make that assertion?
13:50:24 <Ptival> not at all actually
13:50:31 <Cale> thoughtpolice: Well, I don't understand it completely myself -- you'd be better off asking Ryan or Stephen about it, but from what I've heard, it's something to do with the interaction between all the pairing that goes on and garbage collection.
13:50:33 <Ptival> I think I'll write it the way I thought and figure it out then
13:50:35 <hpc> :t \f x -> Just (f (fromJust x))
13:50:36 <lambdabot> forall a a1. (a -> a1) -> Maybe a -> Maybe a1
13:50:59 <c_wraith> woo.  fmap without the correctness!
13:51:07 <kmc> haha
13:51:39 <doserj> Am I sexist when I say that http://hackage.haskell.org/platform/ speaks to the feminine side in my?
13:52:34 <hpc> doserj: i am sort of wondering what they will use for the next release
13:52:59 <monochrom> you are not sexist.
13:53:10 <Cale> thoughtpolice: In the more distant future, we may actually want to rework the Arrow class itself a bit, since even if we avoid the use of 'arr', the arrow syntax translation uses it heavily.
13:53:20 <hpc> i vote for the google approach; blank white page, with just the download stuff in the middle
13:53:23 <hpc> and EXCELLENT icons
13:53:32 <thoughtpolice> Cale: interesting
13:53:36 <hpc> haskell.org is being slow...
13:53:37 <Cale> thoughtpolice: and the occurrences of 'arr' make it impossible to do a lot of meaningful analysis on arrow values
13:53:56 <Cale> (because they contain opaque function values)
13:54:18 <monochrom> I'm pretty sure I have seen a similar theme on the like of domain parking websites and spammer websites etc. :)
13:54:25 <hpc> Cale: yarr, arr be a complicatarr
13:54:39 <Ptival> oh I think I got it
13:54:48 <Cale> Instead, what I think we'd want is an explicit associator and commutator
13:54:59 <monochrom> perhaps the haskell wiki is being redditted
13:55:19 <Cale> So that there's less of arr (\(x,y) -> (y,x)) and all that :)
13:55:57 <accel> wtf, I just compiled haskell 7.0.2 from haskell platform 6.12, and now then release haskell platform 2011.2 with ghc 7?
13:56:06 <accel> I demand a full refund for my recompilation
13:56:15 <Cale> You should never compile GHC yourself
13:56:21 <Cale> Unless you're working on it.
13:56:27 <hpc> heh
13:56:41 <merijn> I do that all the time on FreeBSD, installing from packages is for chumps
13:56:55 <monochrom> see my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml for how to build Haskell Platform without losing your current ghc 7.
13:57:13 <accel> you compile from a tbz?
13:57:17 <accel> I generlaly take version 0.00001
13:57:22 <accel> apply all the patches in sequence
13:57:27 <accel> then compile from the patched tree
13:57:42 <monochrom> you take someone else's software?
13:57:55 <monochrom> I generally write my own software and build my own chips.
13:57:57 <Cale> I use the generic linux version
13:58:35 * frerich_ is IRC'ing using a switch and an LED. click click click.
13:58:40 <Cale> If you find that you have to compile for your platform, you should submit the binary to the GHC guys so that at least other people don't have to repeat your CPU's hard work :)
13:58:59 <accel> Cale: but I don't know how to put in trojans yet.
13:59:04 <accel> Is tehre a tutorial on writing key loggers in haskell?
13:59:10 <jlouis> lol
13:59:19 <jlouis> It is not that hard
13:59:22 <monochrom> key loggers are so imperative
13:59:34 <m3ga> I just took the @AdaInitiative open technology and culture census. You should too! https://www.surveymonkey.com/s/adacensus2011-website
13:59:36 <jlouis> We did all sorts of funny thing with libc.so back in days
13:59:38 <monochrom> I know how to write a tsr.
13:59:51 <merijn> Cale: Well, there are packages for FreeBSD, but the ports system and cultural preference means most (yay, generalisation!) users compile things from scratch
13:59:53 <Ptival> tryBetaReduce (App e1 e2) = maybe (tryBetaReduce e2) Just (tryBetaReduce e1)   -- I think that's what I meant...
14:00:31 <Ptival> but it's hard to read this way :\
14:00:52 <c_wraith> Isn't that just...  tryBetaReduce e1 <|> tryBetaReduce e2
14:00:53 <Ptival> or at least to understand that e1 is tried before e2
14:01:01 <Ptival> possibly...
14:01:06 <confound> if I have a type that looks like Either (that is, Bad a | Good b), is there any way to make it an instance of some typeclasses myself (Show, mostly) but get the rest of Either's instances?
14:01:10 <monochrom> what c_wraith says. `mplus` or <|>
14:01:33 <merijn> :t (<|>)
14:01:33 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
14:01:37 <accel> is beauticul code: visualization with haskell any good?
14:02:18 <Ptival> c_wraith, monochrom: thanks
14:02:24 <monochrom> to visualize haskell code: first visualize code in language L for all L, then let L = haskell.
14:02:37 <accel> it's about writing visualization code in hasell
14:02:40 <accel> not visualizing monads
14:03:00 <roconnor> > Left 6 < Right 5
14:03:01 <lambdabot>   True
14:03:20 <merijn> accel: Visualizing monads is easy, you just imagine a spacesuit filled with Uranium and...
14:03:47 <hpc> lol merijn
14:03:49 <accel> simulate it uqint the equations of quantum mechanics
14:03:49 <Ptival> :)
14:04:03 <accel> and monads simulates the behaviors of the piosn-2 quarks
14:04:09 <accel> operating under a level 3 gravity field
14:04:18 <accel> in the context of the grand unifieid string theory
14:04:22 <accel> of feynman diagrams
14:05:31 <confound> lol?
14:05:34 <monochrom> http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements now updated for the new Haskell Platform too! (God I so own this page...)
14:07:02 <Blarumyrran> Hello. How do I check if all elements of the list except one satisfy a predicate?
14:07:24 <c_wraith> do you care which one?
14:07:27 <Blarumyrran> No
14:07:27 <merijn> Blarumyrran: filter and check if the remaining list is length one?
14:07:28 <kmc> :t \p -> (<=1) . length . filter (not . p)
14:07:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:07:38 <thoughtpolice> Blarumyrran: any
14:07:39 <thoughtpolice> :t any
14:07:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:07:41 <TomMD> No, use foldl
14:07:57 <thoughtpolice> er, actually nvm, thinking the other way around i believe
14:07:59 <applicative> confound, why aren't you using Either?
14:08:03 <Ptival> tryBetaReduce (Abs v e)   = do e' <- tryBetaReduce e
14:08:03 <Ptival>                                return (Abs v e') -- I guess there's also an elegant way to avoid the "do" here?
14:08:06 <merijn> thoughtpolice: any doesn't check there is only one which doesn't match
14:08:19 * thoughtpolice is confused and tired today
14:08:27 <confound> applicative: because I want to provide my own show
14:08:45 <applicative> I see you don't want just 'deriving Show" then?
14:08:47 <Blarumyrran> thanks
14:09:10 <monochrom> case filter (not . p) xs of { [x] -> "all except one satisfy p"; _ -> "something else happens" }
14:09:14 <thoughtpolice> Ptival: (Abs v) `liftM` tryBetaReduce e 
14:09:16 <thoughtpolice> i think
14:09:22 <thoughtpolice> :t liftM
14:09:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:09:25 <confound> applicative: yes, that's what I said. :)
14:09:50 <thoughtpolice> Ptival: yes, that should work, so tryBetaReduce (Abs v e) = (Abs v) `liftM` tryBetaReduce e
14:09:51 <Ptival> thoughtpolice: looks fine
14:10:24 <kmc> Ptival, i'd write it thus: tryBetaReduce (Abs v e) = Abs v <$> tryBetaReduce e
14:10:32 <thoughtpolice> Ptival: you can also be prettier and use applicative
14:10:34 <kmc> which is only trivially different from thoughtpolice's
14:10:34 <thoughtpolice> yeah, like kmc said
14:10:40 <Ptival> ok
14:10:46 <kmc> (<$>) = fmap
14:10:52 <thoughtpolice> i do find <$> much prettier to read than `liftM` or fmap personally
14:10:55 <accel> besides yi; is there any editor on haskell?
14:11:03 <thoughtpolice> accel: for haskell? or written in haskell
14:11:05 <accel> basically I'm looking for "notepad in haskell" to hack on
14:11:17 <accel> writteen in haskellj
14:11:32 <confound> is that like intellij?
14:11:43 <merijn> accel: yi seems like your best bet
14:11:45 <accel> confound: you're going to have to may me consuitling fees
14:12:02 <confound> I don't want to consuitle you!
14:12:07 <merijn> Although I'm thinking of writing my own editor in Haskell (or maybe steal yi's code)
14:12:56 <accel> there iw wxhnotepad
14:13:01 <accel> but i'm not sure I want to install all of wx
14:13:06 <thoughtpolice> yi is very large these days. if you go back in time and find some of the earliest yi releases, it is some very simple and easy to understand code
14:13:09 <accel> there's also hedi, hsed
14:13:23 <thoughtpolice> (like, yi-0.1)
14:14:19 <merijn> Anyone here actually use yi?
14:14:46 <accel> i got it to compile once
14:18:53 <jjohnsson> With -fllvm my very simple vector test program went from a runtime of 1.5 s to 0.5 s. Nice! Time to sleep.
14:19:01 <xpika> how can i find which cabal packages depend on libiconv?
14:19:11 <accel> is there anything like puf/wget written in haskell?
14:27:09 <roconnor> is there some easy way to build a type isomorphic to data TailList a b = Nil b | Cons a (TailList a b) in lambdabot?
14:27:30 <roconnor> meh, nevermind
14:32:59 <merijn> Hmm, I think my earlier problems with Chan and sockets can also be solved with Iteratees, which seem a more elegant approach for my purposes anyway (since incremental streams are what I'm dealing with...)
14:33:11 <roconnor> @src scanl
14:33:11 <lambdabot> scanl f q ls = q : case ls of
14:33:12 <lambdabot>     []   -> []
14:33:12 <lambdabot>     x:xs -> scanl f (f q x) xs
14:33:56 <roconnor> > scanl z f [a,b,c]
14:33:57 <lambdabot>   Couldn't match expected type `a -> b -> a'
14:33:57 <lambdabot>         against inferred type `S...
14:34:01 <roconnor> > scanl f z [a,b,c]
14:34:02 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
14:36:34 <applicative> "-fllvm is incompatible with -fPIC and -dynamic on this platform" Anyone know how I can get around that?  Whats telling it I wan't fPIC and dynamic?
14:37:01 <thoughtpolice> applicative: ? what platform, did you just run 'ghc make' or somesuch?
14:37:06 <c_wraith> are those in your ./cabal/config file?
14:37:06 <thoughtpolice> er, ghc --make
14:37:08 <maurer_> applicative: Are you trying to do shared libs?
14:37:14 <c_wraith> err, ~/.cabal/config
14:37:50 <maurer_> applicative: Also need to know thoughtpolice's "what platform" question. From -dynamic, I'm guessing this is OS X?
14:38:15 <applicative> thoughtpolice: c_wraith I was just fooling around to see if i could get llvm to work.  It's on OS X
14:38:20 <applicative> right maurer_
14:38:41 <maurer_> applicative: See if it will build statically.
14:38:49 <kmc> does OS X do a dynamic build by default?
14:38:55 <thoughtpolice> -dynamic has nothing to do with OS X; dynamic shared libraries are supported on both OS X and linux.
14:39:00 <thoughtpolice> kmc: i don't think so, but i could be wrong
14:39:32 <maurer_> thoughtpolice: They are supported, but you see them almost exclusively used on OS X, whereas in linux they are rare.
14:39:50 <thoughtpolice> i know there are some quirks with OS X and the LLVM backend, which is why it requires its own LLVM mangler; I guess currently dynamic linking against other haskell libs with the LLVM backend doesn't work on OS X atm
14:39:56 <kmc> why are they more popular on OS X maurer_?
14:40:04 <thoughtpolice> maurer_: ? i always enable dynamic linking on all my GHC installs on linux.
14:40:08 <maurer_> kmc: I do not know. I think just because apple shipped stuff that way.
14:40:19 <maurer_> thoughtpolice: -dynamic isn't for dynamic linking...
14:40:38 <kmc> ghc -dynamic "Use dynamic Haskell libraries (if available)"
14:40:40 <thoughtpolice> for GHC, -dynamic means 'do dynamic linking'
14:40:47 <kmc> so i don't think this relates to what Apple ships
14:40:51 <maurer_> thoughtpolice: Oh, sorry, still in the "ld" world.
14:40:56 <thoughtpolice> for the OS X version of GCC, -dynamic does something different, yes
14:41:07 <kmc> what does it do?
14:41:15 <thoughtpolice> i can't remember off hand, just a sec
14:41:31 <roconnor> > foldr (\x a e -> k (f e x))  id [a,b,c] z
14:41:32 <lambdabot>   Couldn't match expected type `t1 -> t'
14:41:32 <lambdabot>         against inferred type `Simpl...
14:41:36 <maurer_> kmc: It's a different form of shared library building, primarily for mach if I remember right.
14:41:46 <applicative> at the moment my command is ghc --make parfib2.hs  -fllvm  -static -o parf, but it still complains about PIC and dynamic
14:41:48 <roconnor> > foldr (\x k e -> k (f e x)) id [a,b,c] z
14:41:49 <lambdabot>   f (f (f z a) b) c
14:42:03 <maurer_> kmc: It comes up specifically under "Darwin Options" when I read the gcc manpage
14:43:00 <thoughtpolice> on OS X, -dynamic for GCC is passed directly to the linker (ld) and it merely controls output, but it seems -dynamic is the default
14:43:07 <thoughtpolice> so that might explain it
14:43:30 <thoughtpolice> (i was thinking of another option like -dylib I guess which is specifically for linking dynamic libraries on OS X, IIRC)
14:44:33 <roconnor> > foldr (\x k e -> k e : k (f e x)) id [a,b,c] z
14:44:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:44:43 <roconnor> > foldr (\x k e -> k e ++ k (f e x)) id [a,b,c] z
14:44:44 <lambdabot>   No instance for (Data.Monoid.Monoid SimpleReflect.Expr)
14:44:44 <lambdabot>    arising from a u...
14:46:26 <applicative> I wonder where this is configured?  
14:46:46 <thoughtpolice> actually, no, looking at the GHC source code, the message applicative is talking about is directly part of DynFlags - it seems that -fllvm without -static or with -fPIC, is not supported unless you are on linux
14:47:00 <thoughtpolice> so it seems as if something is implying the '-dynamic' or '-fPIC' flag
14:47:33 <thoughtpolice> (relevant code for the brave: compiler/main/DynFlags.hs, function 'parseDynamicFlags_')
14:48:25 <thoughtpolice> actually, it's even stricter than that; -fllvm is only supported with -dynamic or -fPIc on x86_64 linux, it's not supported anywhere else it seems
14:48:27 <applicative> this must be in some configuration file, not baked into my ghc, though?
14:48:34 <roconnor> > foldr (\x k e -> e : k (f e x)) (:[]) [a,b,c] z
14:48:35 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
14:48:38 <roconnor> > scanl f z [a,b,c]
14:48:39 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
14:48:40 <thoughtpolice> it's possible it's baked in by GHC, i just wouldn't know why.
14:48:45 * thoughtpolice keeps looking at the GHC source
14:49:56 <applicative> it's the new platform installer ghc, so there may be some things they've superadded.
14:50:21 <thoughtpolice> it's possible; in that case you may want to consult dons or mzero what's up
14:51:43 <thoughtpolice> looking through GHC more, it seems -fPIC is the default in fact, if you have a 64bit GHC on darwin, but i don't think the latest HP release is a 64bit GHC
14:51:56 <thoughtpolice> you can tell by running 'ghc --info', fwiw
14:52:31 <zmv> hm, Haskell makes much more sense after understanding currying.
14:52:46 <confound> currying is the bomb
14:52:48 <thoughtpolice> (if it's not 64bit GHC on darwin, then the default is to see if -fPIC exists)
14:53:00 <zmv> confound: yeah :)
14:53:25 <thoughtpolice> applicative: so, it seems something is implying -fPIC, yes. looking through GHC though, it doesn't seem like it's the default in any configuration other than x86_64 ghc on darwin.
14:53:48 <thoughtpolice> so it being HP related seems possible; ask dons or mzero like I said just to see
14:54:38 <thoughtpolice> oh, apparently there IS a x86_64 build of the haskell platform for OS X!
14:54:46 <thoughtpolice> did not know that. if you're running that, then yeah, -fPIC is the default
14:55:05 <applicative> thoughtpolice: yes, that's what I was trying.
14:55:22 <parcs> i wonder if there exists a monad that provides the functionalities of both Get and Put..
14:55:57 <hpc> @hoogle Get
14:55:57 <lambdabot> Network.HTTP.Base GET :: RequestMethod
14:55:57 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
14:55:57 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
14:56:02 <hpc> @hoogle Put
14:56:02 <lambdabot> Network.HTTP.Base PUT :: RequestMethod
14:56:02 <lambdabot> Control.Monad.State.Class put :: MonadState s m => s -> m ()
14:56:02 <lambdabot> Prelude putChar :: Char -> IO ()
14:56:08 <parcs> from the binary package
14:56:10 <hpc> oh
14:56:11 <thoughtpolice> applicative: then yes, it seems that's the issue. until there are changes to the LLVM backend to work with -fPIC on OS X, it seems you'll either have to a) not use LLVM, or b) use the 32-bit HP installer for OS X
14:56:21 <thoughtpolice> :/
14:56:37 <applicative> yes, i'm seeing that that follows.  ah well.   
14:56:40 <thoughtpolice> (neither is great, i like GHC to use all my registers and have LLVM when available. :( )
14:57:43 <applicative> it's annoying though it seems to me the 32 bit version didn't used to be able to work with -fllvm.  Though it must now, there's a fresh bug report about building pandoc with the 32 bit os x installer
14:58:57 <thoughtpolice> applicative: ? were you running 32bit GHC 7 on OS X prior to this? that's when the llvm backend became available.
14:59:09 <thoughtpolice> (ghc 7 was the first release to have it, IIRC)
14:59:52 <mattyb> What's the recommended way to get the new Haskell Platform on Ubuntu Maverick?
14:59:56 <thoughtpolice> applicative: also, there are some strange issues like I said with the LLVM backend on OS X - it is why GHC actually has a smaller, less evil 'mangler' that is run on the output code that GHC generates, to align with the OS X calling conventions among other things
15:00:21 <thoughtpolice> (i believe specifically, on OS X, there are more strict alignment requirements for pointers/arguments passed on the stack, which is why)
15:00:46 <kmc> this can hopefully be upstreamed into LLVM in the future?
15:01:11 <thoughtpolice> let's see!
15:01:15 <applicative> Maybe i'll go over to the 32 bit one after all. You're right I only used 6.12 or whatever on OS X
15:01:16 * thoughtpolice jumps into the LLVM mangler code
15:01:33 <thoughtpolice> (when in doubt, use the source as they say)
15:01:37 <applicative> too many ghc's to choose from
15:01:58 <hpc> thoughtpolice: use the source, luke
15:03:01 <thoughtpolice> it seems that GHC's llvm manlger kicks in on OS X, because it only needs to re-arrange code in the output assembly, so that info tables will appear directly before the code segments that they refer to (since info tables are used in GHC's heap layout, which contains, among other things, closures.) it also fixes up stack alignment which must be 16-byte aligned, but this apparently is offset by GHC itself
15:03:10 <maurer_> Is it better form to include the "base" package, or the "haskell2010" package?
15:03:23 <lpsmith> mattyb, I've never used the Haskell Platform or the Ubuntu universe packages for GHC
15:03:24 <thoughtpolice> the RTS apparently sets it to a 'wrong' starting value or somesuch
15:03:38 <thoughtpolice> kmc: so, it seems part of it could be fixed in LLVM, and the other part is just GHC
15:03:42 <lpsmith> mattyb, you are probably best off downloading the HP and installing it manually in /usr/local
15:04:08 <kmc> thoughtpolice, i don't understand your explanation of *why* tables-next-to-code is needed
15:04:25 <kmc> i thought it was basically a performance optimization
15:04:41 <lpsmith> err, rather, I've never used the HP under linux.  I have found the HP rather helpful on windows though :)
15:04:48 <kmc> saves you an indirection on each entry and a word in each info table
15:06:44 <maurer_> kmc: If the code generator assumes that optimization is possible though, then when the assumption holds false, it won't work
15:06:51 <thoughtpolice> kmc: it is an optimization, but TNTC affects both the code generated and the RTS, so they must be in alignment (that is, unless you explicitly have a registered build with TNTC disabled)
15:07:30 <kmc> right
15:07:33 <thoughtpolice> so when you've got a registered build, TNTC is most certainly implemented, so any code generated by GHC must also take this into account - hence the mangler *must* move the info tables, or the invariant does not hold in the RTS that the info tables are located right before their corresponding pieces of code
15:07:58 <kmc> i see
15:08:15 <kmc> i've been disassembling ghc output lately and i've noticed that TNTC makes objdump a bit unhappy :)
15:08:52 <kmc> btw does anyone know offhand if there's an explicit mapping from closure type to info table size somewhere in GHC's source?
15:09:09 <thoughtpolice> the thing I wonder though, is why this is required on OS X using the LLVM backend, but not on e.g. linux. i wonder what it 'gets right' on linux that it doesn't on OS X
15:09:33 <thoughtpolice> i believe davidt said something about this on g-h-u at one point, i should look it up
15:09:35 <kmc> istr the ghc-llvm developers submitting patches to LLVM to support TNTC
15:10:11 <thoughtpolice> yeah, david terei. it may be in LLVM 2.9, not sure
15:10:19 <thoughtpolice> (they're relasing LLVM 2.9 real soon now too)
15:11:16 <ddarius> 3
15:13:51 <thoughtpolice> kmc: i don't know if there's an explicit mapping; i know info tables get larger/smaller depending on how you link (for example, if you use profiling there are extra fields inside info tables making it larger,) I only see the RTS definitions for all the info tables in ./ghc/includes/rts/storage/InfoTables.h, though. i would think there's a mapping somewhere though
15:14:32 * hackagebot sbv 0.9.12 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.12 (LeventErkok)
15:14:52 <jlouis>   /11
15:17:44 <kmc> thoughtpolice, for context, i'm trying to take a GHC-compiled binary and split it up into info tables and their associated entry code
15:20:09 <sunfun> i have just tried to write my own isPrefixOf'  between two lists
15:20:25 <sunfun> how to use quickCheck with a function like isPrefixOf? is it right doing quickCheck (\x -> isPrefixOf [] [] == True) ? 
15:20:48 <sunfun> * isPrefixOf'
15:23:22 <lispy> ?check \x -> isPrefixOf x (x++x)
15:23:22 <lambdabot>   "OK, passed 500 tests."
15:23:52 <sunfun> lispy, but what is x? Is it a list?
15:23:58 <kmc> yes
15:24:04 <kmc> x is a list because it's the argument to (++)
15:24:15 <kmc> that is enough for GHC to infer that it's a list
15:24:26 <kmc> however the type of the elements of that list is unconstrained
15:24:29 <kmc> and will default to ()
15:24:31 <sunfun> kmc,  but before x++x there is only x
15:24:31 <kmc> which is usually not what you want
15:24:39 <kmc> @check \x -> x == reverse x
15:24:40 <lambdabot>   "OK, passed 500 tests."
15:24:54 <kmc> sunfun, type inference information flows both forward and backwards in time
15:25:03 <sunfun> kmc, right ok
15:25:05 <applicative> @check \x -> x == reverse x :: [Int}
15:25:05 <lambdabot>   Parse error at "}" (column 29)
15:25:09 <applicative> @check \x -> x == reverse x :: [Int]
15:25:09 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
15:25:11 <kmc> because it occurs at compile-time
15:25:17 <applicative> :(
15:25:18 <kmc> that's also how we can overload stuff based on its return type
15:25:31 <kmc> > (toEnum 0 :: Char, toEnum 0 :: Bool)
15:25:32 <lambdabot>   ('\NUL',False)
15:25:34 <sunfun> and if in a check i use [x]
15:25:38 <sunfun> is it wrong?
15:26:00 <kmc> how do you mean?
15:26:26 <jmcarthur> @check \x -> [x] == reverse [x :: Int]  -- ;)
15:26:27 <lambdabot>   "OK, passed 500 tests."
15:26:28 <sunfun> i mean a list of something using [x]... or it is a list of only one element?
15:26:39 <kmc> it's a list of only one element
15:26:41 <kmc> > [7]
15:26:42 <lambdabot>   [7]
15:26:57 * applicative curses that clever jmcarthur
15:27:11 <jmcarthur> @check \x xs -> (x:xs :: [Int]) == [x]++xs
15:27:11 <lambdabot>   "OK, passed 500 tests."
15:27:32 <kmc> @check \x -> x == [7]
15:27:32 <lambdabot>   "Falsifiable, after 0 tests:\n[-1]\n"
15:28:47 <applicative> sunfun, yes [x], or [y] or [7] is always the 'singleton', one member list
15:29:03 <sunfun>  and if i do \x z ->  x z
15:29:13 <applicative> that's clearer as 
15:29:15 <sunfun> it will never know what thet are
15:29:18 <sunfun> ?
15:29:21 <applicative> \f x -> f z
15:29:40 <applicative> @type \x y -> x y
15:29:41 <lambdabot> forall t t1. (t -> t1) -> t -> t1
15:30:02 <applicative> it knows it x is a function and y is a suitable argument
15:30:19 <applicative> @type ($)
15:30:20 <lambdabot> forall a b. (a -> b) -> a -> b
15:30:41 <applicative> ($) is \x y -> x y
15:30:52 <sunfun> this language is every day more interesting guys
15:31:05 <sunfun> thank you
15:31:25 <hpc> ($) == id, too
15:31:41 <hpc> curry \x y -> x y into \x -> x
15:31:45 <hpc> id = \x -> x
15:31:52 <hpc> ($) = id
15:31:53 <hpc> :D
15:32:01 <applicative> > id even 4
15:32:02 <lambdabot>   True
15:32:22 <applicative> > even `id` 4
15:32:23 <lambdabot>   True
15:32:25 <hpc> > zip`ap`tail [1..]
15:32:26 <lambdabot>   Couldn't match expected type `[a] -> [b]'
15:32:26 <lambdabot>         against inferred type `[t]'
15:32:30 <hpc> > zip`ap`tail$[1..]
15:32:31 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
15:32:38 <hpc> @quote aztec
15:32:38 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:35:13 <carlo_h> > 1 + 1
15:35:14 <lambdabot>   2
15:35:49 <carlo_h> are there any restrictions on what I can ask lambdabot?
15:36:20 <ddarius> You shouldn't ask her how much she weighs.
15:36:31 <hpc> @vixen are you fat?
15:36:31 <carlo_h> hokay
15:36:32 <lambdabot> yes, i am
15:36:45 <hpc> that went better than i expected
15:37:01 <moisan> hi, I'm working on different search strategies on trees. Would a functor be of any use to me? If I understand correctly, functor are for saying "hey this type can be mapped this way". But what if I want to map it various ways?
15:38:40 <sunfun> but doing this: (\x y -> isPrefixOf' x (y++x) == True)  is different or not from the usage of the alone x (x++x) ?
15:39:15 <hpc> btw, (True ==) and (== True) both == id
15:39:24 <teki> Alright, can somebody find the redundancy here?  I have no idea what's going on... http://hpaste.org/44683/overlapping_patterns
15:40:00 <Cale> teki: empty matches the same things as _
15:40:14 <teki> Cale: Wait, I want it to match B.empty
15:40:14 <Cale> teki: a variable pattern matches anything, and so does _
15:40:28 <Cale> teki: then you want x | x == B.empty
15:40:54 <teki> Cale: oh, I see.  Earlier it was giving a fuss about qualified names in a pattern match when I had B.empty
15:41:14 <Cale> right, because variables occurring in patterns always bind values
15:41:15 <applicative> empty isnt a pattern, isn't that the way to put it
15:41:35 <Cale> Well, empty is a pattern, it just doesn't have the meaning that you want :)
15:41:54 <Cale> (it's the same sort of pattern as 'cs' is)
15:41:56 <applicative> oh, i see, if it were B.empty, there would be a different problem
15:42:19 <Cale> B.empty is a problem just because we explicitly don't allow patterns to bind qualified names
15:42:37 <applicative> yes even more trouble.
15:42:40 <Cale> (though it's theoretically not a problem, it would be confusing)
15:42:47 <Axman6> teki: that code is horribly indented
15:42:47 <hpaste> teki pasted "Overlapping patterns?"  http://hpaste.org/44683
15:42:59 <Cale> http://fractal.io/ -- btw, this is amazing :)
15:43:08 <Cale> I particularly like the mandelbulb :)
15:43:33 <teki> alright, well thanks for the help cale/applicative
15:43:42 <Axman6> teki: and you should turn off using tabs in your editor, instead make it use spaces instead of tabs
15:43:49 <Axman6> never use tabs in haskell
15:43:58 <applicative> teki, our gentlemen have it in for tabs
15:44:00 <Cale> oh, yeah, tabs are evil :)
15:44:17 <applicative> some excellent haskellers reject this though
15:44:39 <applicative> Oleg uses tabs
15:44:44 <applicative> !!
15:45:25 <Cale> Oleg is a really smart guy, but many of his tastes about code are strange.
15:45:39 <teki> Jesus Christ, I was getting bugs before by the 4 spaces to 8 spaces tab conversion.  And now I need to use spaces instead?
15:45:39 <Cale> he'also'likes'this'style'of'identifier
15:45:44 <Axman6> i;ve long suspected oleg is secretly trying to hurt the haskell world, and this is just more proof
15:46:10 <applicative> Axman6, its plain he is
15:46:14 <Cale> teki: Yeah, don't use tabs at all. Get your editor to convert them automatically to spaces.
15:46:17 <Axman6> teki: yes, in haskell, tabs are defined to be 8 spaces wide
15:46:36 <Cale> Tabs are defined to align to the next column which is a multiple of 8 spaces
15:46:39 <Axman6> teki: any decent editor will insert x spaces instead of a tab character for you if you tell it to
15:47:05 <Cale> I think they should be defined as a lexical error though
15:47:06 <jmcarthur> actually, the most decent of editors give you indentation toggling instead :)
15:47:08 <applicative> teki, can your editor make it relevant just for .hs files? 
15:47:24 <teki> yes, I am using notepad++.  I was being slightly sarcastic.
15:48:23 <teki> Also, more philosophical question.  Given that, for example, B.empty is a "constant" (just the empty bytestring), and that I can do case statements with constant matching, is there a good reason that I'm not seeing for why it is not reasonable to be able to pattern-match to B.empty?
15:48:26 <applicative> is there help for notepad++, I can't remember.  
15:48:42 <teki> applicative: i can figure it out.  that's not a big deal.
15:49:13 <c_wraith> teki: it's just a syntactic thing.  lowercase names are name bindings inside a pattern match, regardless of whether that same name was bound to anything else in an outer scope
15:49:14 <applicative> what you pattern match on are the constructors of the type
15:49:56 <teki> c_wraith: okay, makes sense
15:50:08 <newsham> just a suggestion: http://www.thenewsh.com/~newsham/x/art/bind.jpg
15:50:10 <Cale> teki: We do have a special case for that in the case of numbers, but apart from that, the way that the system knows whether to bind a variable or match against something is whether or not that thing is syntactically a constructor.
15:50:29 <Cale> teki: Data constructors start with an uppercase letter
15:50:39 <Cale> and variables start with a lowercase letter
15:50:41 <teki> yes
15:50:43 <teki> okay
15:50:46 <teki> so for example
15:51:05 <Cale> and that's how it tells whether to match or to bind a variable to a value
15:51:16 <teki> if I have a Tree a = Leaf a | Branch a [Tree a] type
15:51:19 <teki> just a standard tree
15:51:36 <teki> I can pattern match on "Leaf 1" but not on "Leaf c" where c is an externally defined constant?
15:51:44 <Axman6> no
15:51:54 <Boxo> yes
15:51:55 <teki> okay, now this is confusing
15:52:02 <hpc> leaf x | x == c...
15:52:03 <teki> okay, now it's MORE confusing
15:52:09 <Axman6> you can check for equality of constants using ==
15:52:11 <teki> hpc: yes, I know that trick
15:52:20 <teki> but can I pattern match on Leaf 1
15:52:24 <Eduard_Munteanu> Cale: !
15:52:31 <Cale> Eduard_Munteanu: hi
15:52:32 <Eduard_Munteanu> Please register ##categorytheory :)
15:52:35 <Cale> Eduard_Munteanu: I did
15:52:36 <hpc> numbers are magic
15:52:37 <Axman6> this isn't like erlang, where you can have foo (Bar x x) will only match when x == x
15:52:38 <Eduard_Munteanu> Ah.
15:52:39 <Cale> Didn't I?
15:52:44 <Cale> Do you want ops?
15:52:55 <Eduard_Munteanu> Ah, no, I just didn't see chanserv over there.
15:52:58 <newsham> teki: "1" isnt something that can be bound to.
15:52:59 <Axman6> teki: numbers are patterns
15:53:03 <newsham> "c" is something that can be bound to
15:53:13 <teki> okay, so Leaf 1 would work but Leaf c would fail
15:53:13 <newsham> (1's kinda like a data constructor)
15:53:16 <teki> makes sense
15:53:29 <teki> (1 is a data constructor, for Num types)
15:53:30 <Cale> Eduard_Munteanu: Well, I gave you ops anyway
15:53:36 <newsham> thikn of (Leaf 1) sort of like (Leaf One)   where  Num = One | Two | Three | Four | ..
15:53:40 <teki> yep
15:53:44 <teki> okay, makes sense
15:53:49 <gio123> Cale: hi
15:53:56 <teki> thanks for the detailed explanations all
15:54:07 <Boxo> btw, Leaf = \x -> Branch x []
15:54:13 <Eduard_Munteanu> Ah, thanks, though I'll probably never use it anyway, we seem to be a civilised lot over there.
15:55:31 <Cale> Eduard_Munteanu: Right, that's why I'm handing out ops very liberally :)
15:55:43 <Cale> Eduard_Munteanu: So anyone is allowed to deal with a problem if one arises.
15:55:57 <Eduard_Munteanu> Heh.
15:56:13 * applicative was inferring that ##category-theory was attracting trolls
15:57:03 <Eduard_Munteanu> Feel free to idle in there and spot them :).
15:57:16 <ntc2> is there a way (GHC extension?) to use "complex" expressions between backticks as infix operators?
15:57:24 * applicative is setting up a bot to oppress ##category-theory with notices "hey when you get tired of this abstract nonsensecome visit ##set-theory"
15:57:28 <monochrom> not yet
15:58:01 <ntc2> E.g., i'd like to write something like 'negate `(.).(.)` (+)' for the function that adds two numbers and then negates them
15:58:02 <Cale> ntc2: It's kinda syntactically weird, since backticks aren't naturally a kind of bracket
15:58:05 <Eduard_Munteanu> :))
15:58:28 <Cale> ntc2: That'll look nicer if you make a definition for (.).(.)
15:58:35 <Cale> Like .: or something
15:58:52 <Boxo> @unpl (.).(.)
15:58:52 <lambdabot> (\ i b c f -> i (b c f))
15:58:55 <ntc2> Cale: oh, because "`" don't balance?
15:58:59 <Cale> ntc2: right
15:59:15 <ntc2> yeah, i can define 'o2 = (.).(.)' for the "two-compose"
15:59:28 <ntc2> i just wanted to litter my code with the boob operator
15:59:31 <Cale> ntc2: So in the syntax, you'd have to define the class of expressions not containing backticks
15:59:36 <ntc2> (or panda operator, depending on company)
15:59:43 <Boxo> .+
15:59:44 <Cale> ntc2: which is sorta unnatural to have to do
15:59:46 <monochrom> o_o is boob enough
16:00:03 <Axman6> for any man?
16:00:12 <nejucomo> huh.  With Test.HUnit, I have a test that is defined as:  test (assertFailure <stuff>)  -but when I run I do not see this failure.
16:00:13 <monochrom> for plain text files
16:00:18 <Eduard_Munteanu> @unpl ((.) (.))
16:00:18 <lambdabot> (\ b c e f -> b c (e f))
16:00:45 <nejucomo> However, if I change it to: test (do putStrLn "Hello?" ; assertFailure <stuff> )  -it does show both Hello and the failure.
16:00:45 <ntc2> Cale: oh, yes, that would be unnatural
16:00:48 <ntc2> thanks
16:01:01 <nejucomo> Why isn't the lone assertFailure being evaluated?
16:01:06 <applicative> > fmap negate (+) 1 2
16:01:06 <lambdabot>   -3
16:01:15 <nejucomo> -or rather, is evaluating as a non-failure.
16:01:56 <nejucomo> I suspect laziness is biting me in the ass somehow.
16:01:56 <Axman6> wouldn';t assertFailure be something that succedes when something fails?
16:02:14 <nejucomo> Oh, could be.
16:02:31 <nejucomo> However, in the latter case (do …; assertFailure …) it is counted as a failure.
16:02:36 <nejucomo> Strange.
16:03:07 <nejucomo> Maybe I should read the documentation instead of relying on ghci :browse only.  ;-)
16:03:17 <Axman6> indeed
16:03:28 <Axman6> i don't think I've ever used :browse
16:03:34 <hpc> i did, once
16:03:37 <hpc> to see what it dd
16:03:39 <hpc> *did
16:03:50 <ddarius> applicative: Far more hand grenades in set theory.
16:03:51 <nejucomo> I wish ghci :browse provided documentation similar to python's help().
16:04:16 <Eduard_Munteanu> :t assertFailure
16:04:17 <lambdabot> Not in scope: `assertFailure'
16:04:22 <Eduard_Munteanu> @hoogle assertFailure
16:04:22 <lambdabot> Test.HUnit.Base assertFailure :: String -> Assertion
16:04:23 <lambdabot> Test.HUnit.Lang assertFailure :: String -> Assertion
16:04:50 <Eduard_Munteanu> It seems to be a pure function.
16:05:01 <Eduard_Munteanu> :t error
16:05:02 <lambdabot> forall a. [Char] -> a
16:05:28 <Axman6> @hoogle Assertion
16:05:28 <lambdabot> Test.HUnit.Base type Assertion = IO ()
16:05:28 <lambdabot> Test.HUnit.Lang type Assertion = IO ()
16:05:28 <lambdabot> Control.Exception data AssertionFailed
16:05:33 <Axman6> heh
16:05:36 <Eduard_Munteanu> Ah.
16:05:43 <nejucomo> http://hunit.sourceforge.net/HUnit-1.0/Guide.html
16:06:05 <nejucomo> Ok, so now back to evaluation order, exceptions, and the difference between the two versions of my test.
16:06:45 <Eduard_Munteanu> Evaluation shouldn't matter for execution of the assertion action.
16:06:49 <nejucomo> Why would a test of (assertFailure "blah") not cause an error, but actually pass (!) whereas (do putStrLn "blah" ; assertFailure "blah") will count as a failure?
16:08:23 <kmc> nejucomo, in the former case, what's the type of (assertFailure "blah")?
16:08:38 <kmc> I am wondering if HUnit (which I've never used) is somehow polymorphic over IO actions and non-actions
16:08:41 <applicative> i use ghci :browse all the time, I'm not ashamed I can't remember half the functions in Data.Void
16:08:50 <nejucomo> Assertion (type synonym for IO () )
16:09:02 <c_wraith> nejucomo: I think you're running into the HUnit assertion bug
16:09:27 <c_wraith> HUnit doesn't use throwIO, so sometimes exception throwing gets optimized out on GHC < 7
16:09:32 <nejucomo> I hope it's an hunit bug and not some weird edge case of haskell.  ;-)
16:09:42 <c_wraith> Well, it is a GHC bug, also
16:09:49 <c_wraith> you can use -O0 to disable optimizations
16:09:51 <nejucomo> aha.  So it's a buggy optimization?
16:09:53 <Eduard_Munteanu> @hoogle exit
16:09:53 <ddarius> applicative: You can't remember half a function?
16:09:53 <lambdabot> module System.Exit
16:09:54 <lambdabot> System.Exit data ExitCode
16:09:54 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
16:09:54 <c_wraith> yes
16:10:19 <nejucomo> Wow.  That's bad.
16:10:23 <Eduard_Munteanu> You could write your own assertFailure then, using Debug.Trace and exiting.
16:10:31 <nejucomo> Is ghc 7 stablish?  Maybe I'll just upgrade.
16:10:55 <c_wraith> yeah, there's a new version of the haskell platform using ghc 7 as of today
16:10:57 * nejucomo googles ghc 7
16:11:02 <parcs> @hoogle [Word8] -> Int
16:11:03 <lambdabot> Prelude length :: [a] -> Int
16:11:03 <lambdabot> Data.List length :: [a] -> Int
16:11:03 <lambdabot> Data.List genericLength :: Num i => [b] -> i
16:11:06 <c_wraith> that means "stable, give or take" :)
16:11:07 <nejucomo> woot!
16:11:07 <Eduard_Munteanu> (actually just writing to stderr if you only care about IO)
16:12:01 <Eduard_Munteanu> nejucomo: some 3rd party packages might not work yet
16:12:03 <kmc> i'm not sure that's a buggy optimization
16:12:11 <kmc> it's clear that HUnit *should* use throwIO
16:12:21 <kmc> but i guess it's a bug either way
16:12:31 <applicative> ddarius: it turns out not, I thought it was maybe 'fromVoid', but it's 'absurd'
16:13:04 * nejucomo looks up difference between ioError and throwIO.
16:13:13 <nejucomo> @hoogle ioError
16:13:13 <lambdabot> Prelude ioError :: IOError -> IO a
16:13:14 <lambdabot> Control.Exception ioError :: IOError -> IO a
16:13:14 <lambdabot> Control.OldException ioError :: IOError -> IO a
16:13:24 <nejucomo> @hoogle throwIO
16:13:24 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
16:13:24 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
16:13:25 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
16:14:02 <nejucomo> Oh, right, ioError is "the old way" for exception management?
16:14:54 <c_wraith> kmc: well, it was related to GHC also producing code that crashed with internal GHC errors in some cases...  So it's pretty clear the optimization was breaking stuff.
16:15:17 <c_wraith> kmc: I recall errors along the lines of "Invalid PAP entry"
16:15:19 <kmc> ok
16:15:31 <kmc> nejucomo, ioError is H98 i think
16:15:36 <kmc> which is even older than OldException
16:15:45 <ddarius> It is Haskell 98.
16:15:57 <monochrom> ioError is the haskell 98 way to throw an exception. it can't possibly be optimized away (if live code)
16:17:14 <roconnor> @src return Control.Monad.Cont.Cont
16:17:14 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:17:33 <roconnor> @src Control.Monad.Cont.Cont return
16:17:34 <lambdabot> Source not found. There are some things that I just don't know.
16:17:51 <nejucomo> Well, I guess I try to tell cabal to pass -O0 as a test.
16:25:00 <nejucomo> cabal passes "-O" to ghc.  Even if I add "-O0" with —ghc-option or in the .cabal file, it then includes both -O and -O0...
16:25:13 <nejucomo> The result still exhibits the same test behavior.
16:28:47 <c_wraith> hmm.  When I had a similar problem, adding -O0 to cabal fixed it.
16:33:56 <parcs> what does Main: <<loop>> mean?
16:34:18 <acowley> Can anyone take a look at a simple coinductive proof I'm not sure about?
16:35:04 <kmc> parcs, your program entered an infinite loop in a way that GHC was able to detect
16:36:30 <parcs> that's awesome.
16:36:49 <kmc> yep
16:36:54 <kmc> tell your friends that GHC solves the halting problem
16:36:58 <c_wraith> parcs: in particular, it was able to determine that calculating a value depending on calculating that value
16:37:15 <c_wraith> an easy example of that would be:  let x = tail x
16:37:24 <c_wraith> err, throw an "in x" at the end
16:37:27 <hpc> :t let x = tail x in x
16:37:28 <lambdabot> forall a. [a]
16:37:35 <hpc> > let x = tail x in x
16:37:39 <lambdabot>   mueval-core: Time limit exceeded
16:37:49 <c_wraith> hpc: mueval doesn't detect that
16:37:52 <kmc> it doesn't do it in ghci
16:37:57 <hpc> boring
16:38:07 <kmc> ghci doesn't do blackholing; i'm not sure why
16:38:07 <shachaf> lamdabot used to do it.
16:38:45 <kmc> also i think it doesn't always work with the threaded RTS
16:38:58 <c_wraith> it never works with the threaded RTS
16:39:07 <c_wraith> because doing so would require extra bookkeeping
16:39:13 <kmc> i ran a test just now with GHC 6.12
16:39:18 <c_wraith> it would need to require which thread entered the thunk and blackholed it
16:39:26 <c_wraith> err, need to *record
16:39:38 <kmc> on the threaded RTS it aborts after 0.325s
16:39:46 <kmc> with non-threaded it's ~instant
16:40:01 <kmc> i don't know what's going on
16:40:04 <c_wraith> maybe it just detects that no threads are making progress
16:40:17 <kmc> perhaps it waits for a GC and determines that the whitehole is unreachable or something
16:45:20 <warrenharris> If I have a datatype that is an instance of a class, why can't I return a value of that datatype from a function but with the class signature, e.g. instance C Foo where...; mkFoo :: (C a) => a;  mkFoo = Foo
16:46:18 <warrenharris> I'd like to write a constructor function that might return one of several implementations.
16:46:27 <kmc> that type signature for mkFoo says "pick any type T you like, as long as it's an instance of C.  i will give you a value of type T"
16:46:42 <kmc> that's very different from "i will give you some particular type T and not tell you which"
16:46:50 <warrenharris> what's the right way to say it then?
16:46:57 <kmc> probably
16:47:15 <hpaste> anon pasted "4mart"  http://hpaste.org/44685
16:47:16 <kmc> data Thingy = Impl1 Int | Impl2 (Char -> Bool); mkFoo :: Whatever -> Thingy
16:47:21 <kmc> that is, just return a value
16:47:24 <Cale> warrenharris: Tell us more about the actual problem you're trying to solve
16:47:34 <gio123> Cale: 1 secon
16:47:38 <gio123> Cale: 1 second
16:47:50 <c_wraith> You can do exactly that with a rank-2 type, but I feel like that's never actually the best solution
16:48:23 <warrenharris> I'd like to write a function that takes a string, and depending on the string value (name of a protocol), return one of several implementations, all implementing the same interface.
16:48:29 <kmc> without knowing more about the problem I suspect the class C is not really necessary
16:48:49 <kmc> data Protocol = Protocol { send :: String -> IO (); recv :: IO String };  getProtocol :: String -> Protocol
16:49:04 <kmc> no classes necessary
16:49:17 <Cale> Yeah, that seems reasonable
16:49:19 <kmc> in Java every time you want a new behavior you're forced to create a new type
16:49:20 <warrenharris> kmc: I originally wrote it that way, but got into trouble...
16:49:22 <kmc> Haskell has no such restriction
16:49:32 <kmc> what trouble was that?
16:49:36 <BobFunk> trying to install snap with the new haskell platform release but running into an error with hint
16:49:40 <BobFunk> Module `DynFlags' does not export `supportedLanguages'
16:50:01 <warrenharris> because one of the methods was mkSession which returned a type that depended on the protocol in question
16:50:07 <Cale> Hmm, is hint updated to work with GHC 7 yet?
16:50:15 <kmc> warrenharris, ok
16:50:16 <c_wraith> BobFunk: you're trying to install an old version of Hint
16:50:24 <kmc> then you can use GHC's ExistentialQuantification extension
16:50:30 <BobFunk> c_wraith: just doing cabal install hint
16:50:36 * hackagebot bson 0.1.3 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.1.3 (TonyHannan)
16:50:38 <Cale> warrenharris: and you couldn't just make it recursive?
16:50:44 <gio123> done
16:50:45 <gio123> :)
16:50:47 <c_wraith> BobFunk: what version is it trying to install?
16:50:48 <warrenharris> that lead me to using a class with functional dependencies
16:50:50 <BobFunk> ahh - dog - guess I need a cabal update
16:51:11 <kmc> data Protocol = forall sesh. Protocol { mkSession :: IO sesh; ... };  getProtocol :: String -> Protocol
16:51:17 <kmc> still no classes required
16:51:23 <BobFunk> c_wraith: was trying to install hint-0.3.3.1
16:51:25 <kmc> where did you need fundeps warrenharris?
16:51:34 <warrenharris> kmc: that's exactly what I had, but
16:51:34 <BobFunk> c_wraith: doing a cabal update and will see if that fixes it
16:51:35 <c_wraith> BobFunk: ah, yes.  3.3.2 has the fix for that.
16:51:37 <Cale> If you don't have a typeclass, you don't need fundeps :)
16:51:46 <kmc> you can also use existentials to solve the original problem of "return some (C t) without saying which t"
16:51:52 <kmc> but i expect that's not the best solution
16:51:55 <c_wraith> BobFunk: err, 0.3.3.2, I mean
16:51:57 <BobFunk> c_wraith: great - was just the cabal update 
16:52:08 <BobFunk> thanks :)
16:52:26 <Cale> If you don't mind passing around the extra parameters, working directly with dictionaries of methods can often be nicer if the class mechanism seems to be getting in the way of what you're trying to do.
16:53:43 <Cale> warrenharris: Note that if you use existentials, you're throwing away all knowledge of which specific type it was, and can only apply functions to the resulting value which would have been okay with any type in that class.
16:53:45 <warrenharris> when I went to use that Protocol type, I kept getting errors: 'bla"  is a rigid type variable bound by
16:53:46 <warrenharris>              the type signature for 'bla'
16:54:04 <Cale> Well, those we would have to see
16:54:33 <Cale> That usually means you wrote an implementation which was less polymorphic than the type signature suggested it should be
16:55:10 <Cale> Like, if you write  foo :: Integer -> [a], and then write  foo n = show n, you'll get that error.
16:55:25 <warrenharris> let me try again, or work up a concrete example
16:55:33 <Cale> (because [Char] isn't an acceptable [a] here -- it has to work for any type a)
16:57:28 <lispy> Anyone know of a library for reading/writing Office OpenXML files?  Preferably in Haskell, but C would be okay too.  I found some stuff in C# but that's probably not going to cut it for me.
16:58:02 <gio123> Cale: is it correct?
16:58:18 <Eduard_Munteanu> I think there was a lib for writing XLS files, I don't remember if it was Haskell stuff though.
16:58:50 <lispy> Eduard_Munteanu: hmm....I hadn't thought about using the older format.
16:59:30 <Eduard_Munteanu> Then again, if this is specifically about Excel stuff, you could do with CSV stuff.
16:59:36 <lispy> Eduard_Munteanu: yeah, this looks kind of promising: http://www.libxl.com/
16:59:45 <lispy> Eduard_Munteanu: you can only pass values via csv
16:59:45 <Eduard_Munteanu> Barring some limitations on UTF-8 and such.
17:00:00 <lispy> No formals, no styling, and no macros if you use csv
17:00:18 <Eduard_Munteanu> Yeah.
17:01:11 <lispy> This excel library is something I've wanted for a while.  I should probably bite the bullet and write it, but it's quite a lot of work for a spare-time project.
17:01:39 <Eduard_Munteanu> Maybe you could rip-off OpenOffice code?
17:03:12 <hpaste> WarrenHarris pasted "proto with session"  http://hpaste.org/44686
17:03:17 <Eduard_Munteanu> Though if it's Java, doing Haskell, C and Java intefacing isn't that alright.
17:03:29 <warrenharris> Cale, kmc: Here's an example of the error I had: http://hpaste.org/44686/proto_with_session
17:03:40 <warrenharris> (sorry, I gave you the wrong error the first time)
17:03:59 <kmc> it's not awful Eduard_Munteanu, but some kind of IPC is probably easier than JNI-and-FFI
17:04:05 <kmc> write a Java app to dump the document in a sane format
17:04:11 <lispy> there is a jvm-bridge
17:04:29 <lispy> But, I find that FFI to C is always cleanest with Haskell
17:04:35 <Eduard_Munteanu> warrenharris: yes, existentials can't escape.
17:04:48 <warrenharris> apparently not ;-)
17:04:54 <Cale> warrenharris: So, that's an example of using an existential
17:05:16 <Eduard_Munteanu> warrenharris: what you can do instead is pass a continuation that works on the existential type, if that does what you want.
17:05:17 <kmc> warrenharris, how about «let Protocol s doit = make "proto1" in doit s»
17:05:28 <kmc> or similar with "case"
17:05:29 <Cale> warrenharris: You must use case
17:05:34 <Eduard_Munteanu> But the result can't "expose" that information.
17:05:53 <kmc> also these types don't really make sense; "mkSession" isn't "making" anything, and doit returns a useless value.  but i expect these are just for demonstration purposes
17:06:13 <warrenharris> kmc, yes just for demo
17:06:39 <warrenharris> I don't understand what you mean by let Protocol s doit =...
17:06:53 <warrenharris> doit needs to be a virtual method too
17:06:55 <kmc> deconstruct the Protocol value by pattern-matching, instead of by using record selectors
17:07:01 <kmc> that expression binds "doit"
17:07:02 <Eduard_Munteanu> Virtual?
17:07:06 <Eduard_Munteanu> As in C++?
17:07:11 <Cale> warrenharris: Perhaps you could extend the example a bit. There's currently no reason to have mkSession at all. You could pre-apply doit to the session that mkSession was.
17:07:15 <kmc> case make "proto1" of Protocol s doit -> ...
17:07:23 <warrenharris> virtual as in dispatched depending on which proto impl
17:07:46 <Cale> warrenharris: (and I suspect you might be able to do a similar thing with a full example of what you're after)
17:07:57 <Eduard_Munteanu> That sounds like typeclasses, those can do type-based dispatch.
17:08:06 <kmc> only sort of
17:08:07 <Cale> warrenharris: Is there any reason to have the session value?
17:08:14 <kmc> they're really just sugar for these kinds of record tricks
17:08:23 <Eduard_Munteanu> So you can have different implementations for different involved types.
17:08:24 <kmc> warrenharris, remember that you can pre-apply values without wasting computation time, because computation is lazy
17:08:31 <Cale> warrenharris: Why not just have the rest of the things which operate on that session already applied to the session?
17:08:33 <warrenharris> Cale: yes, in my real code, the session carries it's own state
17:09:00 <Cale> So, instead of foo :: sess -> Bar -> Quux
17:09:06 <Cale> you just have  foo :: Bar -> Quux
17:09:25 <Cale> and the session is already in the implementation of that foo
17:09:26 <Eduard_Munteanu> But IMHO you rarely need to do tricks like that unless you're coming from some OO background and thinking you have to apply the same techniques.
17:09:28 <warrenharris> I need to make a session per thread, which is why I can't preapply it
17:09:34 <Cale> What do you mean?
17:09:51 <kmc> Eduard_Munteanu, yeah, the idea that each new behavior requires a new type is a Java-ism that doesn't even extend to OOP in general
17:09:51 <Cale> I think it would help a lot to have a better example of what you're really trying to do here.
17:09:57 <warrenharris> the proto represents a global state, and sess represents a per-thread state
17:10:17 <warrenharris> I'm sorry if my example make it all seem too trivial
17:10:22 <Eduard_Munteanu> Existentials are sort of useful for hiding internal, implementation-specific types, though.
17:10:47 <Cale> See, the thing is, with your current example, mkSession is a value of a type such that the only thing you can do with that value is to apply the corresponding function doit to that value.
17:11:08 <warrenharris> my session is really an implementation specific type -- it depends solely on the proto's implementation
17:11:10 <Cale> (you can't even apply a doit from a different Protocol record, it has to be the same one)
17:11:27 <warrenharris> Cale: yes
17:11:41 <warrenharris> that's exactly what I watn
17:11:42 <Cale> So, what I'm saying is that you might as well get rid of mkSession, and just have different doits
17:11:58 <Cale> Which implicitly act on different sessions
17:12:22 <Cale> because there's only one session as it is that you could ever apply any given doit function to
17:12:32 <warrenharris> but the calling code (in this example useProto) doesn't know the implementation of the proto or the session
17:12:34 <Cale> So you might as well have already applied it
17:12:41 <Cale> Why should it know?
17:12:45 <warrenharris> (I should have passed p as an arg)
17:12:52 <Cale> That's fine
17:13:58 <warrenharris> I'm sorry, but I'm failing to see how to preapply doit
17:15:25 <Cale> warrenharris: When you currently create a value of type Protocol
17:15:39 <Cale> you supply two things: the session value, and the doit function
17:16:07 <Cale> The only value which you'll ever be allowed to supply to that doit function, as it stands, is this same session value
17:16:23 <Cale> So instead of writing Protocol session doit
17:16:27 <warrenharris> in the real impl there are many functions besides doit, and they all take session
17:16:32 <Cale> you might as well write  Protocol (doit session)
17:16:50 <Cale> okay, but are there any which transform the session?
17:16:59 <warrenharris> yes, most do
17:17:08 <Cale> I mean, are there any of type sess -> sess
17:17:09 <Eduard_Munteanu> warrenharris: they won't be able to take anything else but that same 'session'
17:17:32 <Cale> I don't mean sess -> IO ()
17:17:53 <warrenharris> session uses mvars internally, is stateful
17:18:01 <Cale> yeah, that's fine
17:18:22 <Cale> But they'll be the same MVars the whole time, yeah?
17:18:42 <Cale> (and if not, you could make them MVars of MVars or something)
17:19:06 <warrenharris> one impl will have it's own mvars, another impl might do something different
17:19:06 <Cale> But there's nothing which produces a value of type sess
17:19:17 <Cale> right?
17:19:29 <warrenharris> only hte mkSession constructor which will be called once per thread
17:19:31 <Cale> (Even if there is, we can still manage this, it's just slightly more complicated)
17:19:35 <Cale> okay
17:19:53 <Cale> So the only session which you could pass as a parameter is *the* session that you created the Protocol value with
17:20:07 <Cale> You can't pass anything else because the type system will not allow it
17:20:49 <Cale> (You only have one value of the appropriate sess type which was passed in when you created the Protocol, and nothing will create another value of that type)
17:20:56 <warrenharris> I don't think so. For each proto impl, there can be many session objects (one per thread).
17:21:30 <kmc> warrenharris, but why not make a different Protocol object for each thread, which has the same functions except each one has been pre-applied to that thread's session value?
17:21:31 <Cale> If I have a datatype:
17:21:41 <gio123> Cale: second ppl
17:22:01 <Cale> data Counter = forall c. Ctr c (c -> c) (IO ())
17:22:09 <Cale> or even:
17:22:13 <Cale> data Counter = forall c. Ctr c (c -> c) (c -> IO ())
17:22:15 <warrenharris> kmc: that's effectively equivalent to what I've got
17:22:16 <kmc> then you don't expose the existence of the session value or type at all
17:22:29 <kmc> warrenharris, except simpler and without using type extensions
17:22:40 <Cale> and I write   myCounter = Ctr 0 (+1) print
17:22:41 <kmc> you don't need the existential if that value is baked into the methods
17:22:59 <warrenharris> ok, I see what you mean
17:23:16 <kmc> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
17:23:24 <kmc> "Functions are the masters of reuse: when you use an advanced feature, you need a yet more advanced feature to abstract over it (think: classes < existential types < universally quantified constraints < unknown). But all you need to abstract over a function is another function."
17:23:34 <warrenharris> so there would be an interface for the proto, with a mkSession that returns an interface for the session (containing doit)
17:23:50 <kmc> warrenharris, why two different types
17:24:03 <warrenharris> to avoid the existential
17:24:10 <kmc> mkSession :: ProtocolName -> IO Session
17:24:20 <kmc> or if you really need two stages of IO actions
17:24:23 <warrenharris> there are other proto methods (session-independent)
17:24:23 <kmc> mkSession :: ProtocolName -> IO (IO Session)
17:24:33 <kmc> warrenharris, does it matter if you push those down into the session?
17:24:42 <warrenharris> maybe ot
17:24:44 <warrenharris> not
17:24:48 * hackagebot th-sccs 0.0.0.20110310 - Binding group analysis in Template Haskell  http://hackage.haskell.org/package/th-sccs-0.0.0.20110310 (NicolasFrisby)
17:24:53 <kmc> well it will work either way
17:25:53 <kmc> bbl
17:26:02 <warrenharris> kmc, Cale: Thanks, let me play with this some more, and read the antipatterns article
17:29:42 <ian_mi> I am a bit confused about type arithmetic. Can anyone tell me how to define the concatenation of fixed length vectors?
17:30:39 <ian_mi> What I have tried is defining a Plus n m type family and making concat be Vec n -> Vec m -> Vec (Plus n m)
17:31:30 <ian_mi> the problem is to define applicative (specifically pure) for Vec I needed to make a Nat class but it is impossible to define a class instance for a type family.
17:34:57 <maurer_> Is there an analog of hGetContents or readFile that is not lazy?
17:35:14 <ezyang> Try strict-io. 
17:36:34 <confound> if I have some function f, is there a concise way of doing groupBy (\x y -> f x == f y)? I feel like there must be but I can't quite see it.
17:36:57 <accel> umm that code looks really short
17:37:07 <accel> there's no repetition
17:37:11 <confound> f
17:37:12 <accel> how much shorter do you want it to get?
17:37:14 <shachaf> accel: Sure there is.
17:37:19 <accel> true
17:37:29 <accel> you're also replaicinng ' ' all over the place
17:37:33 <monochrom> if you use bytestring, you also get eager I/O
17:37:37 <confound> Thanks for letting me know you don't know how to help.
17:37:44 <parcs> @type (flip seq <*> length) .: readFile
17:37:45 <lambdabot> FilePath -> IO [Char]
17:37:49 <shachaf> @ty groupBy ((==) `on` ?f)
17:37:50 <lambdabot> forall b a. (Eq b, ?f::a -> b) => [a] -> [[a]]
17:38:08 <accel> accel --
17:38:11 <confound> Right, on. thanks
17:40:40 <pr> :t (.:)
17:40:41 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
17:42:14 <Eduard_Munteanu> BTW, is there a review of Haskell design patterns somewhere, like the C++ thingy? Not that it's terribly useful to think in such terms, but it'd be fun to read.
17:42:47 <Eduard_Munteanu> (well, except the factorial-in-a-hundred-ways thingy, that was fun too)
17:43:32 <kmc> i think a study of patterns would be quite interesting
17:43:44 <kmc> particularly with an eye towards "how can we turn this pattern into a library or language feature"
17:44:07 <Eduard_Munteanu> ("Can we turn this pattern into a zygo thingy? ;))
17:44:11 <kmc> hehe
17:44:45 <kmc> the popular meaning of the term "design patterns" covers basic CS concepts, cookbook workarounds for language flaws, common sense, whatever else the user of the term happens to be selling
17:45:09 <kmc> http://perl.plover.com/yak/design/
17:45:32 <Eduard_Munteanu> I should note the factorial stuff is quite instructive too, even if tongue-in-cheek.
17:45:43 <monochrom> just use Jackson Structured Design.
17:45:53 <kmc> yes
17:46:22 <kmc> (and an "antipattern" is whatever the other guy is selling)
17:46:37 <confound> kmc: You can't really trust anything on that site.  The author is well-known to favor octopi over other cephalopods.
17:47:40 <Eduard_Munteanu> "But the C++ macro system blows goat dick"
17:55:06 <maurer_> Can someone explain to me why iteratees are so much better than lazy IO? To me, they look about the same, except that in one you are forced to do explicit stream management.
17:55:49 <monochrom> in lazy IO you are forced to do explicit stream management.
17:56:39 <monochrom> if you want to distinguish between "no more data because normal end" and "no more data because error", lazy IO won't do.
17:58:19 <maurer_> Can't you just call "hIsEOF" on the handle?
17:59:03 <monochrom> I haven't tried. But certainly you have to time it exactly right if you plan to call hIsEOF
17:59:46 <maurer_> monochrom: As long as hsIsEOF occurs after you find out you're at the end of the file (e.g. it would never happen on an infinite size file) then you should be fine...
18:00:21 <monochrom> yes, but very easy to say.
18:00:43 <monochrom> it is easier to say "just write a correct program" if we just need to talk.
18:00:51 <confound> Can't we just agree not to write bugs?
18:01:06 <monochrom> haha great minds think alike
18:01:10 <maurer_> monochrom: Sure, but it seems like we're adding a whole lot of complexity in exchange.
18:01:30 <Cale> maurer_: To be fair, I really like lazy IO a lot more than some people in here, but the problem with lazy IO is that it detaches when the I/O occurs from the execution sequence of IO, and at least in the present implementation, makes it impossible to deal with errors or other problems that can occur. If the file is rewritten or truncated after your readFile, you can get nonsense, or a truncated string which is indistin
18:01:30 <Cale> guishable from the situation where the file was just different.
18:01:47 <monochrom> Yes, it seems like getting lazy IO right adds a whole lot of complexity.
18:02:19 <Cale> There's also the problem that "modern" operating systems have draconian limitations on the number of filehandles which are allowed open
18:02:39 <Cale> and lazy IO makes it impossible to determine when the file handle gets closed
18:02:56 <Cale> (it's some time after the garbage collector picks up the string, or you reach the end of it)
18:03:04 <maurer_> Cale: Can't you just hClose it?
18:03:15 <Cale> You can, but your string will be truncated randomly
18:03:20 <monochrom> if you hClose, you have to do it at the right time.
18:03:42 <Cale> You should really never hClose a handle which has had hGetContents applied to it
18:04:02 <maurer_> Cale: Why is that operation supported then?
18:04:06 <monochrom> the pattern emerges: if you want to do anything non-toy with lazy IO, you have to do them at the right time. very easily said.
18:04:29 <monochrom> it is supported in case you want to try
18:04:48 <Cale> maurer_: I suppose it might be useful if you were really careful with it
18:05:22 <Cale> maurer_: But you have to make sure that the *evaluation* of the expressions you wanted to compute with the string has occurred before the *execution* of the hClose
18:05:46 <maurer_> Not entirely. You only need to ensure that the length of the file has been determined.
18:05:53 <maurer_> All the computation does not need to be done.
18:06:12 <Cale> Well, sure, you need to make sure that the entire file has been read.
18:06:16 <maurer_> Cale: Yeah.
18:06:27 <Cale> Well...
18:06:38 <maurer_> The point being that for any case where you run into fd restrictions, you likely know that you are "done" with that file.
18:06:41 <Cale> But if the entire file has been read, you might as well not hClose, because it'll close automatically in that cse.
18:06:42 <Cale> case*
18:06:51 <monochrom> you are really welcome to try. if you get it to work, no heisenbugs, that's cool, I don't care.
18:06:52 <Cale> (though it would make sure for you)
18:08:01 <maurer_> I agree that it would be nice to know why the stream ended, but am not 100% sure that iteratees are the way to do it.
18:08:32 <monochrom> timing your hClose is the real difficult part
18:09:03 <maurer_> monochrom: The only cases I can see with enough files to matter are things like webservers, where the solution would be "connection out of scope, clean up"
18:09:10 <Cale> maurer_: I agree.
18:09:25 <Cale> maurer_: Iteratees are unconvincingly complicated for the problem they solve.
18:09:44 <maurer_> They might be an acceptable under-the-hood datastructure, but I think we'd need a nicer interface over the top?
18:09:46 <maurer_> I dunno.
18:09:49 <monochrom> complicated to use? complicated to implement?
18:10:00 <roconnor> heh, conal's exercise: headT ∘ fmap f ≡ f ∘ headT is pretty easty to prove
18:10:00 <Cale> monochrom: Both.
18:10:03 <maurer_> monochrom: Complicated to use, in comparison with lazy IO
18:10:08 <roconnor> it is the free theorem for headT
18:10:17 <Cale> monochrom: Type-wise, they result in big complicated messes
18:10:39 <maurer_> monochrom: I don't care how complicated it is to implement, that's a case of getting a few crack programmers to write it correctly, and then everyone else can use it, similar to the general paradigm of library/kernel design.
18:11:26 <Cale> Yeah, I'd be okay with something that's more complicated to implement if it gave a simpler interface.
18:12:53 <maurer_> I guess the thing to think about would be what interface would be desired?
18:13:33 <monochrom> it is not more complicated to use than a parser combinator lib.
18:14:34 <maurer_> monochrom: Parser combinators take a problem and make it simpler. This takes a problem and makes it more complex. Just because prior parsers were much more complex is no excuse for us to make using streams just as complicated as parsing.
18:15:58 <monochrom> if you use an input stream as no more than an input stream, throughout your whole program, I repeat: throughout your whole program, perhaps. I doubt how many times that happens.
18:16:19 <monochrom> 99% of my input streams, I have to do some parsing of them anyway.
18:16:41 <gio123> Cale: 1 secon
18:17:14 <monochrom> iteratee (or enumerator if you like, they say it's simpler) is 2-in-1, input stream and parsing, and I just have to write the parsing part.
18:17:17 <maurer_> monochrom: This may not be as much of an issue for the moment, but if we want proper pipeline parallelism, we're going to need simple streams.
18:20:29 <Axman6> hoorah, new platform!
18:23:37 <maurer_> Axman6: Is it ghc7 based?
18:23:46 <Axman6> yes
18:23:58 <Axman6> with 64 bit support for OS X too (though it's experimental)
18:24:15 <xemdetia> Dear #haskell I am trying to figure out Text.XML.Light and am fairly new to Haskell. Does anyone know of any projects or anything like that which use it that I could peek at the source for? Or at least a better documentation than the hackage pages?
18:25:22 <Axman6> xemdetia: how much haskell do you know?
18:26:55 <xemdetia> Not enough really, I just am trying to do something more tangible with it so I can figure things out better.
18:27:57 <Axman6> what have you been using to learn haskell?
18:28:08 <xemdetia> YAHT from wikibooks
18:28:25 <confound> My mind is trying to turn that into YHBT
18:28:47 <Axman6> i would suggest you look at LYAH, it's a much better tutorial, and more up to date
18:28:52 <Axman6> @where lyah
18:28:52 <lambdabot> http://www.learnyouahaskell.com/
18:29:09 <confound> xemdetia: I really enjoyed LYAH. I just finished reading it a few days ago.
18:29:18 <xemdetia> I have tried to work through lyah several times, and it just doesn't click for me.
18:30:10 <Seta00> "You probably already have your favorite text editor installed so we won't waste time on that." <- whoa, nice way to avoid the editor war xD
18:30:21 <djahandarie> xemdetia, any particular place you start getting lost?
18:32:21 <xemdetia> When you start trying to apply Haskell to outside sources, I mean lyah is really good about trying to work with stuff in just haskell or plaintext but I can't figure how to do anything more complex. That's why I started looking for the XML lib, but I see the hxt one that has arrows which I haven't come across in the tutorial texts.
18:32:44 <confound> xemdetia: Maybe your brain is defective. Have you tried getting a new one?
18:33:04 <xemdetia> I consulted my doctor but he said try again next life (I guess he's buddist).
18:33:16 <confound> O
18:33:17 <confound> good luck.
18:34:02 <confound> xemdetia: My ridiculous not-quite trivial application that I write when learning a new language is a tic-tac-toe game.  Is that at all helpful? it sounds like you might be past that point.
18:35:07 <xemdetia> confound: Mine is usually some sort of converter/parser for the need at hand which is where I am at now. Pulling data from an XML file seems something really suited to a filter/map operation
18:35:35 <monochrom> you can use tagsoup for basic xml work for now
18:36:04 <monochrom> you have to do your own "does start tag match end tag" if you care, of course.
18:36:33 <xemdetia> monochrom: I'll start looking into tagsoup, thanks.
18:36:34 <monochrom> there are also other xml libs now
18:37:18 <monochrom> tagsoup just gives you a list of three cases: "it's a start", "it's text", "it's an end".
18:37:47 <xemdetia> Does it let you access attributes at all?
18:37:59 <monochrom> precisely for its primitiveness, it's great fun for beginners. think of it as lego haskell xml
18:38:06 <monochrom> I forgot
18:38:39 <monochrom> yes, attributes are attached to the "it's a start" case.
18:38:41 <xemdetia> Yeah hackage definitely seems to say this is a beter option and at least something I can work with. My problem with the other XML.Light lib is that I wasn't really sure how to even set it up to pull anything out and fooling around in ghci was getting me nowhere.
18:39:20 <xemdetia> monochrom: I will definitely give this a try. Thanks a lot
18:39:45 <confound> monochrom: have you ever watched homestar runner?
18:39:55 <monochrom> no
18:40:16 <confound> oh. nevermind then. I heard your "it's an end" comment in the voice of one of the characters
18:41:03 <monochrom> I had one of those pregnancy gender detection kit in mind. "it's a boy!" "it's a girl!"
18:41:26 <confound> hahaha
18:41:39 <lpsmith> has process supervision really been done justice in Haskell?   I see there is something on hackage taken from RWH...
18:52:19 <Axman6> urgh, why oh why can't new installs of ghc/the platform just work? -_-
18:53:12 <Axman6> when the platform installs process-1.0.1.5 there's no need for cabal install to try and install it too >_<
19:00:05 <dons> Axman6: sounds like cabal-install's fault
19:00:22 <Axman6> sounds like everything's broken now >_<
19:01:55 <Axman6> ffs
19:02:35 <confound> foreign function specification?
19:03:26 <Axman6> step 1) rename ~/.cabal to start fresh. step 2) run cabal update, creating config file and supposedly downloading the package list. step 3) run cabal install pcre-lite, and have cabal complain that you haven't downloaded the package list. step 4) rage!
19:04:35 <Axman6> why can't this stuff just work >_<
19:06:07 <Axman6> dcoutts: are you about?
19:08:10 <Axman6> hmm, removing .ghc may fix this... let's see!
19:09:40 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml hints at why vanishing .cabal but keeping .ghc is a bad idea
19:10:55 <Axman6> yeah i always forget about .ghc
19:11:26 <monochrom> bookmark my page. read it 3 times a day. plus a 4th time on Sundays.
19:11:57 <Axman6> it would be so nice if these things did just work though -_-
19:12:11 <Axman6> i've never had a clean compiler upgrade
19:12:36 <monochrom> things just work for me. I just tried it today.
19:12:53 <monochrom> corrupted or inconsistent file states can't be helped.
19:13:09 <Axman6> do they just work? or do you have to do things like delete your .cabal and .ghc dirs?
19:14:04 <Axman6> dons: do you have any plans to update ghc-core to show LLVM output?
19:16:04 <kmc> that'd be rad
19:19:52 <Axman6> indeed
19:35:31 <monochrom> yesterday I installed ghc 7.0.2 generic linux x86 binary. today I built and installed haskell platform from source. just worked. no deleting .cabal or .ghc. I had (still have) 2 older ghc's and 2 older haskell platforms.
19:36:29 <monochrom> but don't hesitate to guess "software works 100% for monochrom uniquely". I'm coming to realize it.
19:39:30 <monochrom> if ghc+cabal works for you then emacs haskell-mode doesn't work for you. if emacs haskell-mode works for you then gtk2hs doesn't work for you. if gtk2hs works for you then firefox crashes on you. something must break for you - if you are not monochrom.
19:40:47 <monochrom> at least that's what I gathered from IRC in the past few years.
20:12:41 <lispy> I'm not sure if my irc client is doing utf-8 correctly.  Anyone want to help me find out?
20:12:55 <lispy> > '\u0128'
20:12:56 <lambdabot>   <no location info>:
20:12:56 <lambdabot>      lexical error in string/character literal at chara...
20:13:05 <lispy> > "\u0128"
20:13:06 <lambdabot>   <no location info>:
20:13:06 <lambdabot>      lexical error in string/character literal at chara...
20:13:11 <systemfault> éééé````èèèù`oïê
20:13:13 <lispy> > "\0128"
20:13:14 <lambdabot>   "\128"
20:13:16 <mzero> ½
20:13:28 <lispy> I see a a half
20:13:32 <lispy> Sweet, must work
20:13:47 <mzero> ☺
20:13:53 <geheimdienst> lölcät <- these vowels are wearing hats
20:14:35 <lpsmith> does HXT have a ByteString -> XmlTree interface,  or an XmlTree -> ByteString interface?   All I've found so far is reading in XML from a file and printing it back to a file...
20:16:08 <lpsmith> Ahh, I found hread and xread,  but unfortunately no ByteStrings
20:17:14 <lpsmith> ok, n/m
20:18:06 <lpsmith> Err... it does have XBlob, meaning it does have some bytestring support
20:20:34 * hackagebot yesod-examples 0.7.0.1 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.7.0.1 (MichaelSnoyman)
20:28:03 <sshc> Hmm, I wonder how simple it'd be to write something like "flip" that modifies a function, but instead of flipping the first two arguments, it moves the first argument to the last argument.  This would useful, but I'm 
20:28:55 <sshc> Hmm, I wonder how simple it'd be to write something like "flip" that modifies a function, but instead of flipping the first two arguments, it moves the first argument to the last argument.  This would useful with some functions like Data.Map.Lookup, but I'm mostly interested in how it'd be implemented.
20:29:37 <mzero> trivial for any given number of arguments
20:32:44 <sshc> mzero: Really?  how it would it be implemented then?
20:33:12 <mzero> rot3 f a b c = f b c a
20:33:36 <mzero> @src flip
20:33:36 <lambdabot> flip f x y = f y x
20:33:42 <sshc> mzero: That only works with functions with three arguments
20:33:57 <mzero> right- I said it was trivial for any given number of arguments
20:34:09 <mzero> I don't think you can do it generalized in Haskell98
20:34:16 <mzero> or even Haskell2010
20:34:35 <sshc> Is it possible with any of GHC's extensions?
20:34:56 <sshc> It's a really interesting puzzle, and I'd really like to know if it could be done
20:35:11 <mzero> might be - but I'm pretty sure you'd have to use one of the less safe instance extensions
20:36:23 <sshc> Yeah, but I wonder how it could be done
20:50:38 <dainanaki> Hello all, using the new Haskell platform on OS X. I'm trying to cabal install cabal-dev but it's failing because it's trying to install network-2.3.0.2. What I don't get is why it's trying to do that since that's already installed as a system package. Does anyone have any advice?
20:54:41 <dainanaki> nevermind
21:12:24 <dainanaki> Well actually I still can't figure out how to get it to recognize my system's copy of network instead of trying to install it as a user package
21:17:47 * hackagebot Semigroup 0.0.6 - A semigroup  http://hackage.haskell.org/package/Semigroup-0.0.6 (TonyMorris)
21:23:36 <pseudonym_> Haskell newbie here, I'm wondering if there's a way to consume a RandomGen in such a way that the whole list doesn't stay in memory if I only want, say, a rolling average, or the nth element.
21:25:13 <shachaf> pseudonym_: What list are you referring to?
21:25:24 <shachaf> pseudonym_: Also, your nick is taken in this channel. :-)
21:25:27 <pseudonym_> I'm using Random to generate a random list
21:26:05 <shachaf> Oh, randoms.
21:26:08 <pseudonym_> but if I index into that list or do a scan on it
21:26:32 <pseudonym_> the memory usage is linear with how many elements I take
21:26:47 <shachaf> pseudonym_: Are you sure no references to the list are being kept around?
21:26:47 <ulfdoz> &aw
21:27:04 <pseudonym_> I'll give you an example;
21:27:20 <pseudonym_> let rands :: (RandomGen g) => g -> [Double]; rands g = map fst $ iterate (\(a, g) -> random g) (random g)
21:27:28 <pseudonym_> do { g <- newStdGen; return $ (rands g) !! 100000; }
21:27:50 <pseudonym_> if you change the size of that index, memory usage increases, too high, and I run out of memory
21:29:08 <ion> Why do you want the 100000th random number?
21:29:38 <kmc> the smallest weird number
21:30:04 <pseudonym_> in my playing around with haskle I just, well, played around with some things, like say, computing the rolling standard deviation of "random"
21:30:11 <pseudonym_> I'm just learning the language so to speak
21:30:30 <pseudonym_> but I noticed that the memory usage was linear with the number of elements I took
21:30:36 <pseudonym_> even if I dropped all but the last one
21:30:41 <pseudonym_> or even if I indexed into it
21:31:38 <pseudonym_> I realize those values still have to be computed, but there ought to be a way to make the memory usage of such an operation constant, or linear in the number of elements I am actually taking, yes?
21:32:16 <shachaf> Yes.
21:32:46 <pseudonym_> So I would like to learn me a haskell for great good, or something or other, on that
21:33:50 <pseudonym_> I'm going to guess whatever deep magic I have to invoke to get the indexing operation to use constant memory will be applicable to other toy algorithms I implement that can be abstracted as scans over the list
21:34:02 <Cale> pseudonym_: hmmm... the memory usage on that was linear?
21:34:35 <Cale> Let me think about that. I can understand it taking linear time, but I don't see a particularly good reason why space usage should be linear.
21:34:35 <pseudonym_> yes
21:34:37 <shachaf> pseudonym_: Yes, it's also linear with let foo :: Integer -> [Integer]; foo g = map fst $ iterate (\(a, g) -> (g,g+1)) (g,g+1)
21:34:41 <kmc> pseudonym_, how were you measuring memory usage?
21:34:46 <shachaf> Or seems to be.
21:35:07 <Cale> There will be linear allocation
21:35:15 <Cale> But shouldn't be linear space.
21:35:52 <pseudonym_> Well I'm not sure how useful :set +s is, but I've been just watching the private memory usage in my OS
21:36:00 <pseudonym_> and if I set the index to something in the tens of millions or so
21:36:00 <kmc> yeah; i'd expect it to accumulate garbage but collect most of it on each GC
21:36:05 <kmc> pseudonym_, you're using ghci?
21:36:11 <kmc> might be different in compiled
21:36:13 <pseudonym_> I've noticed it with compiled
21:36:13 <kmc> code
21:36:14 <pseudonym_> too
21:36:18 <pseudonym_> let me test that
21:36:22 <kmc> did you run with something like:  ./myprog +RTS -s
21:36:23 <pseudonym_> so I'm not wasting your time
21:36:35 <pseudonym_> it was a slightly more complex program in ghc, which I simplified to test in ghci
21:37:53 <Cale> hmm, wow, I am seeing that
21:38:01 <Cale> I think I may know why
21:38:14 <Cale> Basically iterate and !! interact poorly
21:38:35 <Cale> You're going to get a giant expression by the time you reach the nth element that needs to be evaluated
21:39:53 <Cale> iterate f x !! 5 --> (x : iterate f (f x)) !! 5 --> iterate f (f x) !! 4 --> (f x : iterate f (f (f x))) !! 4 --> iterate f (f (f x)) !! 3
21:39:55 <Cale> and so on
21:40:51 <btutt> :t iterate
21:40:52 <lambdabot> forall a. (a -> a) -> a -> [a]
21:41:00 <Cale> So what's taking up all the space in memory is the large bunch of applications of f to x in the parameter to iterate. It's normally not a problem if you're evaluating them all, because the elements of the list are actually tied together and share structure
21:41:36 <Cale> But when you don't evaluate them and try to walk down the list, they'll grow and grow.
21:42:18 <Cale> I think you'll find that if you print them all, you won't see the space usage anymore, for example.
21:42:56 <ddarius> http://haskell.org/haskellwiki/Stack_overflow section 3
21:43:02 <btutt> :t random
21:43:03 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
21:45:43 <ddarius> ∀l.∃n. last l = l !! n, <=/=> ∃n.∀l. last l = l !! n
21:46:26 <btutt> :t RandomGen
21:46:27 <lambdabot> Not in scope: data constructor `RandomGen'
21:46:30 <pseudonym_> Cale, how would I go about creating a list of random numbers I can safely iterate over?
21:46:53 <Cale> pseudonym_: Well, have you tried the randoms function?
21:46:57 <Cale> :t randoms
21:46:58 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
21:46:59 <pseudonym_> Yes, I still get oom
21:46:59 <Cale> :t randomRs
21:47:00 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
21:47:02 <Cale> hmm
21:47:03 <shachaf> «Typically, we think of a function "being strict" in an argument as a function that "forces" its argument, but the above definition of strict should immediately suggest another function that is strict and doesn't "force" it's argument in the intuitive sense, namely id.»
21:47:19 <shachaf> Why doesn't id "force" its argument in the intuitive sense?
21:47:28 <ion> @src iterate
21:47:28 <lambdabot> iterate f x =  x : iterate f (f x)
21:47:39 <shachaf> I'd understand if they used (const undefined) as an example, but evaluating (id x) forces evaluation of x.
21:47:48 <ion> @src iterate'
21:47:48 <lambdabot> Source not found. There are some things that I just don't know.
21:47:53 <ion> Perhaps there should be a strict version.
21:48:09 <kmc> shachaf, because "id" doesn't contain a pattern match
21:48:16 <pseudonym_> @src randoms
21:48:16 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:48:18 <kmc> and pattern-matching is the primitive construct for forcing
21:48:21 <ddarius> shachaf: It depends on your notion of intuition.
21:48:29 <pseudonym_> Well I tried :P
21:49:25 <pseudonym_> found the internal definition of random
21:49:36 <pseudonym_> but it seems obtuse to me
21:49:55 <btutt> @src random
21:49:56 <lambdabot> Source not found. I am sorry.
21:49:56 <Cale> pseudonym_: actually, weird, I see increasing space with an infinite list of Doubles, but not with an infinite list of Integers
21:50:10 <Cale> That doesn't make sense...
21:50:51 <pseudonym_> I just swapped the type of my Rands from [Double] to [Integer] and I still got increasing space, let me try Int
21:51:04 <Cale> import System.Random
21:51:04 <Cale> main = do { g <- newStdGen; print $ (randoms g :: [Double]) }
21:51:10 <Cale> is the program I'm using
21:51:11 <shachaf> kmc: I suppose... I think of forcing in the sense that I mentioned, though.
21:51:19 <pseudonym_> one second
21:51:22 <Cale> I'm compiling with -O2
21:51:35 <shachaf> kmc: "seq" is another primitive for forcing, and it seems intuitive.
21:54:18 <pseudonym_> Cale
21:54:19 <pseudonym_> you're right
21:54:24 <pseudonym_> if I just print randoms g :: [Int]
21:54:37 <pseudonym_> I get 1.5mb of private memory and it's constant
21:55:05 <pseudonym_> hm
21:55:12 <pseudonym_> if I do it with [Double] I get constant memory too
21:55:22 <pseudonym_> wait
21:55:24 <pseudonym_> no it didn't recompile
21:55:26 <pseudonym_> no way those are doubles
21:55:28 <Eduard_Munteanu> Is it statistically significant wrt the numer of tests?
21:55:33 <ddarius> shachaf: const undefined is a good example of an even less intuitively obvious strict function, though I wonder if that ever matters in the context of that page.  It will likely lead to different operational behavior, but I think only in cases where you will get an exception/non-termination anyway.
21:55:49 <pseudonym_> Eduard_Munteanu: I'm seeing OOM for large values when indexing into "randoms"
21:56:56 <pseudonym_> If you change the program so that it includes
21:57:01 <kmc> shachaf, yeah, seq is special
21:57:02 <pseudonym_> n <- readLn :: IO Int
21:57:11 <pseudonym_> and change the print line to     print $ (randoms g :: [Double]) !! n
21:57:28 <pseudonym_> I can easily make the program take up a GB or two of memory, or hit out of memory conditions
21:57:41 <pseudonym_> I guess in Haskell terminology that's space not memory?
21:58:55 <Eduard_Munteanu> @src randoms
21:58:55 <lambdabot> Source not found. Take a stress pill and think things over.
21:59:04 <pseudonym_> randoms  g      = (\(x,g') -> x : randoms g') (random g)
21:59:05 <Eduard_Munteanu> @hoogle randoms
21:59:05 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
21:59:16 <pseudonym_> that's the source from hackage
22:00:48 <pseudonym_> I like that in the source, the comment before the definition of Random Float is
22:00:54 <pseudonym_> -- hah, so you thought you were saving cycles by using Float?
22:01:02 <pseudonym_> and the definition proceeds to use Doubles
22:01:26 <shachaf> @source System.Random
22:01:27 <lambdabot> http://darcs.haskell.org/packages/base/System/Random.hs
22:07:59 <pseudonym_> So...
22:08:20 <pseudonym_> Is there a definition of randoms that doesn't use linear space when indexed into?
22:10:42 <Cale> I can't think of a good reason why the current one uses linear space
22:10:57 <Cale> I'll do some profiling and see if I can figure it out
22:12:22 <Cale> and of course, under profiling, memory leak goes away :P
22:12:44 <btutt> heh
22:13:04 <btutt> what about without -O2? does it go away then?
22:13:35 <Cale> That was without -O2
22:13:51 <btutt> what about -O2 and -prof then
22:14:14 <Cale> Same
22:14:31 <pseudonym_> Cale, I tried throwing in my definition for a rolling average
22:14:31 <ion> Bugs can sense debuggers and hide from them while they’re nearby.
22:14:35 <btutt> ugh
22:14:40 <pseudonym_> and you're right, as long as I print every element
22:14:42 <pseudonym_> constant memory
22:14:54 <btutt> the cat never likes the box to be opened
22:15:06 <pseudonym_> output was: 0.49997440066191945,0.49997454675910014,0.49997467914414845,0.4999744107900
22:15:09 <pseudonym_> after running for a while
22:15:11 <btutt> it likes being unknowable
22:15:18 <Cale> although I wonder if this will actually increase in size forever
22:15:19 <pseudonym_> so it's clearly converging to ~0.5
22:16:34 <Cale> The space leak that I'm seeing with printing all the values is very slow, and it only happens with Double, not Integer.
22:16:41 <geheimdienst> so, how about this? (map (toEnum . fromIntegral)) -- they seem to use it to convert from [Word8] to String. i'd have expected encodeString or what's-it-called from the utf8-string package. is the toEnum thing a quick-and-dirty variant?
22:17:00 <Cale> yes
22:17:06 <Jafet> Who uses it to convert that?
22:17:14 <geheimdienst> xmonad :-)
22:17:27 <ion> btutt: The cat likes to be in the superposition of being both dead and alive.
22:17:30 <pseudonym_> Cale, right, I'm just saying that at least with my rolling average or rolling stdev functions
22:17:37 <geheimdienst> i'm trying to figure out something and i'm reimplementing a bit of xmonad code
22:17:38 <Jafet> If that was in ByteString.Char8 or something, it would be fine
22:17:38 <Eduard_Munteanu> randomIvalInteger seems a bit more contrived than the Double variant, I wonder if it's missing some strictness.
22:17:41 <btutt> ion: yep :)
22:17:41 <pseudonym_> I can do "print $ rollingAvg (randoms g :: [Double]"
22:17:44 <pseudonym_> and everything is peachy
22:17:48 <Cale> Hmm, it's gotten up to 2.2 MB, which was the size that it was while profiling
22:18:02 * hackagebot interpolatedstring-perl6 0.8 - QuasiQuoter for Perl6-style multi-line interpolated strings  http://hackage.haskell.org/package/interpolatedstring-perl6-0.8 (AudreyTang)
22:18:05 <pseudonym_> if I do (rollingAvg (randoms g :: [Double])) !! n
22:18:06 <Cale> and it doesn't appear to be increasing anymore, but I'll let it run for a while
22:18:08 <pseudonym_> for sufficiently large n
22:18:12 <pseudonym_> I just get an out of memory
22:18:19 <Cale> pseudonym_: yeah, that's expected
22:18:28 <pseudonym_> is there a way around that?
22:18:47 <ion> @src (!!)
22:18:48 <lambdabot> xs     !! n | n < 0 = undefined
22:18:48 <lambdabot> []     !! _         = undefined
22:18:48 <lambdabot> (x:_)  !! 0         = x
22:19:26 <ion> @more
22:19:38 <Ptival> :\
22:19:41 <Cale> pseudonym_: Yeah, you want to force the evaluation of the elements of the list as you go down it... so something like  strictList :: [a] -> [a]; strictList [] = []; strictList (x:xs) = x `seq` (x:xs)
22:19:50 <Cale> er
22:19:51 <Ptival> lambdabot is lazy :D
22:20:06 <Cale> pseudonym_: Yeah, you want to force the evaluation of the elements of the list as you go down it... so something like  strictList :: [a] -> [a]; strictList [] = []; strictList (x:xs) = x `seq` (x : strictList xs)
22:20:23 <pseudonym_> then do what, strictList $ randoms g?
22:20:23 <Cale> (sorry, just edited my line :P)
22:20:39 <Cale> Uh, apply strictList just before doing the !!
22:20:43 <pseudonym_> ok
22:20:47 <pseudonym_> I'll give that a shot
22:21:26 <Eduard_Munteanu> Wait... I wonder...
22:21:38 <Eduard_Munteanu> randoms  g      = (\(x,g') -> x : randoms g') (random g)
22:21:46 <Cale> The problem is that xs !! n doesn't force all the previous n elements to be computed, and by the time you get to the nth one, the expressions describing the elements are very large.
22:21:50 <Eduard_Munteanu> Maybe it could benefit from a lazy annotation?
22:22:27 <Cale> The problem is an interaction between iterate and !! which would happen with any functions at all.
22:22:28 <Eduard_Munteanu> That pattern is irrefutable anyway.
22:23:03 <Jafet> @src iterate
22:23:03 <lambdabot> iterate f x =  x : iterate f (f x)
22:23:46 <Cale> pseudonym_: In general, you want to try to avoid using !!, but there are some cases (like this one perhaps) where it's pretty unavoidable.
22:23:53 <pseudonym_> Cale: you are correct
22:24:01 <pseudonym_> strictList fixes the space
22:24:17 <Cale> pseudonym_: great
22:24:42 <btutt> don't forget. seq is whnf and not nf. i.e. seq /= deepseq
22:24:52 <Cale> pseudonym_: It forces the evaluation of each element of the list to occur before the corresponding tail of the list can be observed
22:24:58 <btutt> (could give you grief later)
22:25:08 <Cale> Yeah, but in this case, that'll always be enough
22:25:12 <btutt> yep
22:25:20 <Cale> Because the problem is due to iterate
22:26:21 <pseudonym_> You brilliant bastards you
22:26:25 <pseudonym_> :D
22:26:56 <Jafet> > iterate succ 0 !! 1000000
22:26:57 <lambdabot>   *Exception: stack overflow
22:27:02 <pseudonym_> *shakes fist* some day I'll be able to hask with you guys
22:27:09 <pseudonym_> With the best of them, maybe tomorrow.
22:27:16 <Jafet> > let iterate f x = x `seq` x : iterate f (f x) in iterate succ 0 !! 1000000
22:27:17 <pseudonym_> But thanks Cale, this problem has been keeping me up
22:27:17 <lambdabot>   1000000
22:27:37 <btutt> Not sure I'd call it all iterates fault per say. lazy is lazy :) 
22:27:51 <btutt> Haskell is just cat lazy
22:28:05 <btutt> :)
22:28:14 <Eduard_Munteanu> I would've thought 'iterate' would do some memoization trick for that :/
22:28:16 <Cale> pseudonym_: Yeah, space issues can be tricky. You need to build up a mental model of how expressions get reduced to other expressions.
22:28:29 <Jafet> It does. But it's still non-strict.
22:28:30 <Cale> Eduard_Munteanu: It does, sort of, but that doesn't help :)
22:28:40 <pseudonym_> So just, before I go to sleep, to make sure I understand this correctly
22:28:50 <Cale> Eduard_Munteanu: Because none of the earlier elements have been evaluated by the time !! gets to the nth
22:29:18 <pseudonym_> I hit an out of memory condition because the !! operator caused the lazy list to be expanded to... a list of computations that were not yet done. Thunks? And it was *that* that occupied all the memory
22:29:22 <pseudonym_> Err, space
22:29:25 <btutt> Certainly iterate creating a whnf spine of the list would be less surprising
22:29:37 <pseudonym_> What is "whnf"?
22:29:52 <btutt> Weak Head Normal Form
22:30:06 <Eduard_Munteanu> @wikipedia WHNF
22:30:06 <lambdabot> Unknown command, try @list
22:30:39 <pseudonym_> it looks like wiki does not have an article on whnf
22:30:46 <Eduard_Munteanu> Bah, anyway, it's an evaluation strategy.
22:30:58 <pseudonym_> the nearest hit is to lambda calculus though so it's a swing and an almost hit? :P
22:31:10 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Evaluation_strategy
22:31:16 <pseudonym_> the third hit is a reference to the Lepidoptera dinosaur species
22:31:18 <Eduard_Munteanu> Right, this one should be instructive.
22:31:22 <Eduard_Munteanu> Heh.
22:31:32 <pseudonym_> sorry
22:31:39 <pseudonym_> apparently Lepidoptera only sound like dinosaurs
22:31:44 <pseudonym_> they're actually moths and butterflies
22:32:05 <Eduard_Munteanu> Pterodactilus moth :P
22:32:38 <pseudonym_> I have read the article on evaluation strategies
22:33:00 <pseudonym_> but no I still don't know what WHNF is, I'm sure I'll find it online eventually
22:33:10 <lispy> weak head normal form
22:33:15 <pseudonym_> yes :)
22:33:21 <lispy> Basically, evaluated up to the outter most constructor
22:33:25 <pseudonym_> I mean I don't know what that is
22:33:28 <pseudonym_> ah
22:33:42 <lispy> NF == fully evaluated, IIRC
22:33:49 <Eduard_Munteanu> Strange, I thought they'd mention that there.
22:33:50 <pseudonym_> Cale, Eduard_Munteanu, was my summary of why I hit an issue with laziness an accurate, if just a newbie's view of what occurred?
22:34:01 <lispy> then you have head normal form, and then whnf
22:34:43 <btutt> Yeah, whnf is when only the outer most element of the lazy thunk has been demanded. NF is when the rest of the thunk is demanded.
22:34:50 <lispy> pseudonym_: http://en.wikibooks.org/wiki/Haskell/Graph_reduction
22:35:07 <btutt> (trying to keep things simple)
22:35:16 <Eduard_Munteanu> Yeah, it's the lack of strictness there that breaks it.
22:35:34 <pseudonym_> Well I'm trying to understand, what, exactly, occupied all the memory, err, space to cause an out of memory condition
22:35:44 <pseudonym_> And my understanding now is that it wasn't already calculated values
22:35:58 <btutt> It was thunks for the values you were trying to ignore
22:36:00 <pseudonym_> But unevaluated computations up to the index I requested from the lis
22:36:02 <pseudonym_> list'
22:36:05 <Jafet> There is also stepeval, although it implements Haskell naively (without laziness).
22:36:09 <Jafet> @where stepeval
22:36:10 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
22:36:23 <btutt> yep
22:36:30 <pseudonym_> So the problem was I requested !! 5000000 or something
22:36:47 <pseudonym_> and it had to figure out 4999999 individual methods of calculating all the prior indices
22:36:48 <lispy> pseudonym_: from that article I just linked: "weak" = no reduction under lambdas. "head" = first the function application, then the arguments.
22:36:59 <pseudonym_> generating, essentially a large expression tree?
22:37:01 <btutt> so it had to allocate that many unevald computations (thunks)
22:37:12 <pseudonym_> ahuh
22:37:13 <pseudonym_> ok
22:37:30 <pseudonym_> and by using strictList I told it, no no, don't worry about those thunk things
22:37:52 <pseudonym_> I want each value to be computed as soon as you see it, not when you think you need it
22:38:10 <btutt> not quite. strictList said I need the answer to those thunk things. !! just ends up ignoring them all
22:38:18 <pseudonym_> ah
22:38:33 <pseudonym_> and so !! ended up generating a huge wasted list of stuff I didn't really want in the first place
22:38:57 <btutt> well randoms is an infinite list.....
22:39:04 <pseudonym_> yep
22:39:05 <btutt> GIGO (garbage in garbage out)
22:39:30 <Eduard_Munteanu> pseudonym_: you do want those, implicitly, since the state of the random generator depends on all those prior values.
22:39:46 <Eduard_Munteanu> That's why it had to build up that huge computation in the first place.
22:39:48 <pseudonym_> like I said I was trying to do some toy algorithm stuff to learn haskell, and one of those things I like to do in languages to figure out how to efficiently do things, is to do things like a rolling average function or a rolling std dev function
22:39:57 <pseudonym_> But when I did that, I was hitting this laziness issue
22:40:06 <pseudonym_> So there's no real problem I'm trying to solve
22:40:13 <btutt> @src randoms
22:40:13 <lambdabot> Source not found. There are some things that I just don't know.
22:40:15 <pseudonym_> Except learning haskell
22:40:39 <pseudonym_> Eduard_Munteanu: So would that perhaps be a problem with the definition of "randoms"? I don't know...
22:40:42 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/latest/html/libraries/random-1.0.0.3/System-Random.html 
22:41:18 <btutt> Would making x in the randoms lambda a ! variable prevent this?
22:41:26 <levifikri> How to format a number into string? e.g. 2.67 => 2.57000 (5 decimal space)
22:41:40 <btutt> @src printf
22:41:40 <lambdabot> Source not found.
22:41:55 <Eduard_Munteanu> pseudonym_: well I think it could be fixable from within Random, by adding more strictness there. Actually, many monads have a Strict and a Lazy variant, and this random stuff looks a lot like State.
22:42:22 <Eduard_Munteanu> But then I suppose there could be legitimate uses of the lazy version, so it'd have to be a separate thing.
22:43:08 <levifikri> btutt, ok get it http://cvs.haskell.org/Hugs/pages/libraries/base/Text-Printf.html. Thx
22:43:24 <btutt> np
22:43:50 <Eduard_Munteanu> levifikri: that's a Hugs thingy, and Hugs is kinda old and moldy. Perhaps you should look into another source.
22:44:06 <Eduard_Munteanu> @hoogle Printf
22:44:06 <lambdabot> module Text.Printf
22:44:06 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
22:44:06 <lambdabot> Text.Printf class PrintfArg a
22:44:13 <Eduard_Munteanu> @hackage Text.Printf
22:44:13 <lambdabot> http://hackage.haskell.org/package/Text.Printf
22:44:17 <Eduard_Munteanu> Bah.
22:44:43 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/Text-Printf.html
22:45:50 <Eduard_Munteanu> Though IMHO, a lazy Random monad makes little sense to me. The computation is fixed anyway, so it's not like there could be something else going on.
22:45:51 <augur> apparently the gnostics believed in the supreme and unknowable god of all gods, Monad
22:46:09 <augur> which is ironic.
22:47:12 <pseudonym_> Thank you all for your help tonight, and goodnight
22:48:30 <geheimdienst> augur, what was their take on Monoid?
22:48:49 <augur> none!
22:48:51 <Cale> augur: That 'monad' has a different etymological origin though.
22:49:11 <augur> Cale: stfu
22:49:22 <Cale> The 'monad' from category theory is a portmanteau of 'monoid' and 'triad'
22:50:00 <Cale> In the end, I suppose it's still mono- + -ad
22:50:17 <Cale> But the route taken is a bit more convoluted in the CT case :)
22:50:48 <geheimdienst> wasn't this guy leibniz also messing around with monads? is the gnostics' meaning or a another, third one?
22:51:15 <Eduard_Munteanu> Really? I thought it was a less braindead way of saying 'monoidoid' :P
22:51:15 <augur> Cale: NOT
22:51:17 <augur> Cale: THE
22:51:19 <augur> Cale: POINT
22:51:36 <Cale> geheimdienst: Well, not exactly the same thing, but closer :P
22:53:07 <Eduard_Munteanu> Oh, wait, monoidoid was for a category.
22:53:20 <Eduard_Munteanu> This archaic stuff is confusing.
22:53:23 <Cale> heh, yes
22:53:44 <Cale> A groupoid being a category in which every arrow is invertible
22:54:38 <Cale> (and a group being a monoid in which every element is invertible)
22:55:09 <Eduard_Munteanu> Hrm, I think that'd be a groupoidoid, since a groupoid is already 'less-than-a-semigroup'
22:55:36 <Eduard_Munteanu> (basically, it's a no-rules thingy)
22:55:42 <Eduard_Munteanu> Just closure.
22:57:10 <Eduard_Munteanu> I wonder how useful they are, since edwardk has been playing with stuff like semigroupoids too.
22:57:16 <Cale> oh, no
22:57:24 <Cale> you're confusing two definitions of groupoid
22:58:17 <Cale> Some people used to use groupoid as a term for a general set with a binary operation on it, but now you'll mostly see that called a magma.
22:58:18 <Eduard_Munteanu> AFAIK, it's groupoid < semigroup < monoid < group
22:58:29 <Eduard_Munteanu> Ah, that.
22:59:06 <Cale> because it's more useful to reserve groupoid for something that is actually vaguely like a group
22:59:23 <Cale> (as categories with all arrows invertible really are)
22:59:48 <Eduard_Munteanu> Ah, makes sense.
23:00:24 <Eduard_Munteanu> In that case, I've been reading older books than you did it seems :)
23:02:34 <btutt> are there any good books on category theory that don't require a bunch of abstract algebra as well? i.e. groups, rings, etc?
23:02:54 <btutt> you know, CT for undergrads or something. ;)
23:03:21 <Eduard_Munteanu> It depends what you mean by "a bunch".
23:03:33 <PatrickRobotham> There's one!
23:03:34 <Eduard_Munteanu> You do have to know what all those mean, of course.
23:03:35 <btutt> as little as possible. ;)
23:04:05 <Eduard_Munteanu> But not stuff like Abel-Ruffini, Sylow groups or that sort of higher abstract algebra stuff.
23:04:27 <PatrickRobotham> btutt: There's "Conceptual Mathematics: A first introduction to categories"
23:04:36 <Eduard_Munteanu> (basic abstract algebra is taught here in highschools)
23:04:47 <Eduard_Munteanu> You could have a look at Awodey's.
23:05:18 <Eduard_Munteanu> It doesn't have a lot of prerequisites in that department.
23:05:48 <btutt> cool. thanks
23:05:56 <Eduard_Munteanu> @where awodey
23:05:56 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
23:06:38 <Eduard_Munteanu> But that being said it's still a bit scary of a book.
23:08:11 <Eduard_Munteanu> Hrm, it's been removed.
23:08:25 <btutt> yeah bummer
23:08:33 <Eduard_Munteanu> I'm not sure it's available somewhere freely (legally) anymore since he published the 2nd edition.
23:08:50 <Eduard_Munteanu> You can try Googling it for yourself.
23:12:18 <Eduard_Munteanu> Also this might have a bit of CT, but not much...
23:12:22 <Eduard_Munteanu> @where ttt
23:12:22 <lambdabot> Toposes, Triples and Theories: http://www.cwru.edu/artsci/math/wells/pub/ttt.html
23:15:03 <btutt> cool thanks
23:15:15 <Eduard_Munteanu> @where+ awodey Category Theory, Steve Awodey: http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf    (broken link)
23:15:15 <lambdabot> Okay.
23:15:24 <Eduard_Munteanu> @where awodey
23:15:24 <lambdabot> Category Theory, Steve Awodey: http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf (broken link)
23:17:13 <btutt> Awodey is now at CMU so that might be why the link broke. Additionally, he doesn't publish a pdf from his home page there.
23:17:53 <Eduard_Munteanu> He used to offer the 1st edition on his homepage for free.
23:18:21 <Eduard_Munteanu> But he recently published a 2nd edition.
23:18:30 <btutt> yeah I see. last year
23:20:00 <Eduard_Munteanu> btutt: btw, there's also ##categorytheory ;)
23:21:05 <btutt> Don't you find it odd that Awodey is in the Philosophy dept? I just invented this new theorem. All abstract logic classes belong to the Math dept. ;)
23:22:25 <Eduard_Munteanu> They could use a few more people who are strong in their base field in philosophy circles.
23:22:49 <btutt> the 2nd edition contract probably had electronic rights clauses in it that caused its removal.
23:23:20 <Eduard_Munteanu> A couple of years ago I attended a philosophy talk at a local univ, and I was surprised the talker was a math guy, this Niiniluoto.
23:23:57 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Ilkka_Niiniluoto
23:24:49 <Eduard_Munteanu> Interestingly there was much game theory going on, and some thing that didn't seem far from CHI and intuitionistic stuff.
23:25:36 <btutt> huh time for sleep i'm afraid. thanks for the suggestions.
23:25:41 <Eduard_Munteanu> I can't help to wonder how baffled were math-naive people there. :)
23:26:00 <btutt> :)
23:26:08 <Eduard_Munteanu> *were the
23:26:11 <Eduard_Munteanu> G'night.
23:26:46 <Eduard_Munteanu> (the conference was on scientific realism, but it was kinda detailed)
23:33:40 <boegel> does someone here know who's responsible for the mail client that takes care of the mailing lists?
23:34:28 <boegel> I'd like someone to look at http://www.mail-archive.com/haskell@haskell.org/msg23355.html
23:38:05 <solrize> so is it the preferred practice among the haskell crowd to use parsec for simple pattern matching that a perl/python programmer would do with regexps?  haskell's regex modules are a big pain, but so is parsec
23:40:16 <kmc> the regex modules are a pain for entirely unnecessary reasons
23:41:24 <kmc> there's the terrible generic (=~) API and then like a hundred other modules with their own APIs
23:42:09 <kmc> Parsec isn't that bad even for small things, once you know it well
23:42:21 <kmc> but it's tricky to learn
23:42:51 <solrize> it's not difficult it's just cumbersome
23:43:27 <solrize> in terms of the amount of code you have to write to pull a date out of a filename or the like
23:43:33 <solrize> and its api is also cumbersome
23:44:03 <solrize> maybe i should write an api wrapper for one of the regex modules, to give it a python-like interface
23:44:35 <kmc> i'd like to use that if it's good
23:44:51 <solrize> you think it's worth doing?
23:44:55 <kmc> but it's hard to solve the problem of too many different modules by writing yet another module
23:45:05 <solrize> i'd just pick one module and wrap it
23:45:25 <solrize> i can never remember the crazy typeclass weirdness text.regex.posix
23:45:44 <kmc> the classes around (=~)?
23:45:49 <solrize> yeah i guess
23:45:56 <kmc> lass RegexOptions regex compOpt execOpt => RegexMaker regex compOpt execOpt source | regex -> compOpt execOpt, compOpt -> regex execOpt, execOpt -> regex compOpt where
23:45:56 <quicksilver> you don't have to use the =~ if you don't want
23:46:08 <quicksilver> there are simple functions with names like 'matchRegex' or something
23:46:18 <kmc> that is such a weird, un-Haskelly API design
23:46:31 <solrize> i'd just use the same names that python uses, to the extent possible
23:46:34 <kmc> i really don't understand why it's written that way
23:47:00 <kmc> it's not cool to have a single operator that does 50 unrelated things depending on the argument and result types
23:47:01 <geheimdienst> i believe the technically correct term for "un-Haskelly" is hasn'tkelly
23:47:11 <kmc> haha
23:47:37 <kmc> solrize, sounds good
23:47:44 <kmc> try to do it with zero type classes ;)
23:48:25 <quicksilver> it was an experiment, kmc
23:48:49 <quicksilver> a successful experiment, in face.
23:48:57 <quicksilver> but there remains some doubt about the conclusions to draw from it :)
23:49:14 <quicksilver> for me, it was a successful experiment demonstrating that such an API design is not sensible.
23:49:23 <quicksilver> the maintainer interprets the results a different way :-/
23:49:27 <solrize> heh
23:50:27 <kmc> it's just such an odd mismatch with the rest of the language and standard library
23:50:37 <kmc> and it's something beginners often want to do
23:51:00 <quicksilver> secretly it's a bonus.
23:51:12 <quicksilver> regexps are a terrible solution in 99% of the cases beginners want to use them :)
23:51:21 <solrize> "now you have two problems"
23:51:25 <solrize> jwz
23:51:40 <kmc> it just causes people to give up on Haskell because it's so abstract and complicated to do even simple things like regex matching
23:51:43 <Jafet> "Two problems do not make a solution"
23:52:02 <solrize> found it -->  Some people, when confronted with a problem, think
23:52:02 <solrize> “I know, I'll use regular expressions.”   Now they have two problems. 
23:52:04 <kmc> jwz's quote is cute but i think it's not that accurate for regex
23:52:09 <kmc> maybe he means in C
23:52:14 <kmc> regexes suck in C because string processing sucks in C
23:52:20 <solrize> hmm
23:52:31 <Jafet> He's referring to perl, where people use regex for everything
23:53:04 <kmc> shrug
23:53:11 <Jafet> In recent versions you can even call external perl from inside a regex
23:53:25 <Jafet> And the external code can itself use regexes
23:53:29 <solrize> lol
23:53:43 <solrize> metacircular regex evaluation
23:53:46 <kmc> regexes are a 
23:53:56 <kmc> regexes are a tool i use daily for getting shit done
23:54:11 <kmc> i'm not the only one
23:54:23 <kmc> obviously you can misapply this tool
23:54:33 <Jafet> Well, perhaps Text.Regex should come with a tutorial
23:54:37 <geheimdienst> kmc, i agree, haskell does come off as abstract and complicated. the other day there was a discussion about "split", and i suggested in an ideal world, some kind of split could be in Prelude. lots of people protested ...
23:54:42 <Jafet> Calling all Haskell bloggers...
23:54:53 <kmc> geheimdienst, that's not what i was arguing at all
23:56:03 <geheimdienst> you said "simple things like regex matching", i thought "simple things like split" ... *shrug*
23:56:42 <kmc> geheimdienst, my point was that the overloaded regex API is terrible and un-Haskelly, but would be taken by beginners as evidence supporting the meme that Haskell is too abstract for getting anything done
23:56:52 <kmc> as if it were a typical Haskell API, which it's not
23:57:02 <geheimdienst> i see
23:57:56 <kmc> the logical conclusion of that line of API design is to have a single "class F t where f :: t" and then to name all your functions "f" with different types
23:58:03 <kmc> and then your program can just be f f f f f f f f f f f f f f f f f
23:58:50 <kmc> this version has the advantage that (unlike regex) it doesn't require MultiParamTypeClasses or FunctionalDependencies
23:59:10 <kmc> gotta sleep, peace all
23:59:15 <geheimdienst> cu
