00:00:15 <Ptival> well, if you have a p :: Population, (generation p) gives you the Int, and (coins p) gives you the [Coin]
00:00:45 <CADD> ohh alright
00:01:01 <Ptival> unless you want to do something special when coins is empty, you should not write these functions...
00:01:21 <CADD> nope, just filling them
00:02:33 <CADD> awesome, thank you so much, so, i dont really need getters for coin either then, right?
00:03:14 <Ptival> they're there, "name" and "value"
00:03:34 <Ptival> if there's a collision, you can use "Coin.name" and "Coin.value" for disambiguation
00:03:49 <CADD> ok, wow, i am really liking haskell, cool, thanks a bunch
00:04:01 <Ptival> np
00:04:27 <Ptival> so you can just erase all these get* :D
00:05:01 <CADD> haha, yeah, this is really refreshing comming from C++ :D
00:05:19 <miyako> CADD: I'm feeling the same way :)
00:05:45 <CADD> miyako: haha good stuff :D
00:06:30 <miyako> I tried learning ocaml once but it didn't really stick, I'm liking haskell much more- the documentation seems much better
00:07:31 <CADD> hmm, yeah, ive never touched ocaml, from the looks of it, it wasnt the best..
00:08:10 <Ptival> CADD: if you're looking at miyako's code, you can see the the way (s)he pattern matches against these fields inside function declarations :
00:08:13 <Ptival> vertex_cmp (Vertex {name=n1}) (Vertex {name=n2}) =                          
00:08:14 <Ptival>     n1 == n2
00:08:27 <CADD> ill definatly check it out
00:08:31 <miyako> so, Ptival any other general suggestions/observations on the code I posted?
00:08:51 <Ptival> (btw I'm a beginner too compared to a lot of people here)
00:09:06 <miyako> the only downside so far to my experience with haskell is that I don't know anyone else who knows it, so it's hard to get feedback on if I'm doing things poorly
00:09:10 <Ptival> miyako: hum let me look at it again
00:09:33 <CADD> hey, but you of great help, helping us really big newbies
00:09:37 <miyako> I've pretty much been going off of the wikibook and some tutorials on writing xmonad configuration files lol
00:10:18 <CADD> haha, i know what you mean, people look at me funny when i said im going to do a non OO aproach
00:10:21 <Ptival> miyako: I'm not sure graph_data will ever prove useful
00:10:35 <CADD> J language was an interesting venture...
00:11:00 <miyako> Ptival: yeah, I had it in there at one point for something and never really removed it
00:12:36 <miyako> CADD: yeah, I've been telling people that not everything has to be OO for a while, every once in a while they even listen
00:13:01 <Ptival> miyako: if you use hlint, you will find some info about your code
00:13:16 <miyako> "come on guys, it's a 200 line program, you don't need to write an AbstractFactoryFactoryImplSingletonFactory"
00:13:31 <Ptival> for instance, Haskell prefers camelCase to this_kind_of_convention
00:13:33 <shachaf> miyako: That's not really what OO is.
00:14:17 <Ptival> miyako: foldr (||) False (map (vertex_cmp v) g)   ===   foldr ((||) . vertex_cmp v) False g
00:14:36 <Ptival> miyako: foldr (||) False   ===   or
00:14:37 <dibblego> Ptival: instead of foldr (||) False try or
00:14:38 <Ptival> :t or
00:14:39 <lambdabot> [Bool] -> Bool
00:14:50 <Ptival> sure
00:14:57 <CADD> mhm, OO is nice, but it has its limitations. But now that I am seeing how nice haskell is, it may be my new python..
00:15:14 <Ptival> :t or (map (f v) g)
00:15:15 <lambdabot>     No instance for (SimpleReflect.FromExpr Bool)
00:15:15 <lambdabot>       arising from a use of `f' at <interactive>:1:9-11
00:15:15 <lambdabot>     Possible fix:
00:15:25 <Ptival> :t \f v g -> or (map (f v) g)
00:15:26 <lambdabot> forall t a. (t -> a -> Bool) -> t -> [a] -> Bool
00:16:13 <Ptival> miyako: if you can, you should definitely use hlint, gives you a lot of ways to improve your code
00:16:17 <miyako> shachaf: I know, OO is a very useful tool, but sometimes people try to get way overboard with it
00:16:22 <miyako> Ptival: building it now
00:16:27 <dibblego> or (map f k) == any f k
00:17:01 <Ptival> miyako: (Path ewt (e:[])):[]   ===   [Path ewt [e]]
00:17:45 <Ptival> miyako: \x -> f x y   ===   (`f` y)
00:17:56 <Ptival> this last one might be hard to read for a newbie still
00:18:09 <Ptival> enclosing f inside ` ` makes it infix
00:18:15 <CADD> mhm, and it can lead to some really bad code, really fast.    like.calling.functons.way.too(deep)
00:18:17 <Ptival> f a b === a `f` b
00:18:32 <shachaf> CADD: Writing bad code can lead to bad code, OO or otherwise.
00:18:40 <miyako> okay, I've seen that before but I wasn't sure what it did
00:18:50 <CADD> shachaf: absolutely ture
00:19:00 <shachaf> I'm not sure what "way too deep" means.
00:19:39 <miyako> shachaf: the probem I've observed is people writing bad code, and essentially responding "no way this code is bad, I used every single design pattern in GoF"
00:20:27 <CADD> to be honest, i dont have any examples, but you can recognize code rot pretty quickly, that was just a lame example
00:20:35 <Ptival> miyako: and you can use features named "partial application" and "sections" to write code like (+1) for \x -> x + 1, or (`f` y) for \x -> x `f` y
00:21:16 <miyako> Ptival: yeah, I've done that before, I realized looking at the code that I could make better use of that, knowing about `f` will help
00:21:50 <miyako> one problem I found myself running into was I would define a function, e.g.: foo x y z = x + y + z
00:22:13 <Ptival> you can also "defix" operators with parentheses in a similar fashion: (+) 1 2 === 1 + 2
00:22:25 <Ptival> or should I say "prefix"
00:22:35 <Ptival> don't know the terminology, you get the idea
00:22:39 <miyako> yeah
00:23:04 <Ptival> @pl foo x y z = x + y + z
00:23:05 <lambdabot> foo = ((+) .) . (+)
00:23:08 <Ptival> ow
00:23:14 <Ptival> you did not see that :D
00:23:18 <shachaf> @ty (+) .: (+)
00:23:19 <lambdabot> forall a. (Num a) => a -> a -> a -> a
00:23:30 <shachaf> But, really, the pointful version is simpler.
00:23:56 <shachaf> Go use a concatenative language. :-)
00:24:04 <Ptival> @pl foo a b c d e = a + b + c + d + e
00:24:04 <lambdabot> foo = ((((((+) .) . (+)) .) . (+)) .) . (+)
00:24:16 <Ptival> I guess there's a time where you go list...
00:24:59 <Ptival> @pl foo a b c d e = sum [a,b,c,d,e]
00:24:59 <lambdabot> foo = ((((sum .) .) .) .) . (. ((. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:))) . (.) . (.) . (.) . (:)
00:25:02 <Ptival> zomg
00:25:06 <Ptival> sorry for that :p
00:25:24 <miyako> well, looks like I have a lot to learn, but I'm still pretty happy with what I've done after a week of learning
00:25:32 <shachaf> @pl foo [a,b,c,d,e] = a + b + c + d + e -- So much cleaner!
00:25:32 <lambdabot> (line 1, column 17):
00:25:32 <lambdabot> unexpected "="
00:25:32 <lambdabot> expecting variable, "(", operator or end of input
00:25:39 <shachaf> Bah, I suppose it can't @pl pattern matching.
00:26:03 <lispy_> cabal ignores -pgmc in ghc-options :(
00:26:17 <shachaf> @pl foo l = sum [head l, head (tail l), head (tail (tail l)), head (tail (tail (tail l))), head (tail (tail (tail (tail (tail l)))))]
00:26:18 <lambdabot> foo = sum . liftM2 (:) head (ap ((:) . head . tail) (ap ((:) . head . tail . tail) (ap ((:) . head . tail . tail . tail) (return . head . tail . tail . tail . tail . tail))))
00:26:41 <miyako> I'm not sure I really grok what . does yet
00:26:47 <shachaf> @src (.)
00:26:47 <lambdabot> (f . g) x = f (g x)
00:26:47 <lambdabot> NB: In lambdabot,  (.) = fmap
00:26:54 <CADD> well ill see you guys, thanks again for the help.
00:26:54 <Ptival> miyako: did you want feedback about your Haskell programming or about your algorithmic design?
00:26:57 <shachaf> miyako: Just function composition.
00:27:10 <lispy_> according to ghc docs, -pgmc should allow you to specify the command for your C compiler.  But, in actuality, when cabal invokes ghc on .c files it doesn't apply ghc-options.
00:27:18 <miyako> Ptival: haskell programming, I realize the algorithm itself is terrible right now
00:27:29 <lispy_> so, I put -pgmc in cc-options, but then it passes it to gcc which doesn't recognize the option.
00:27:46 <miyako> although I would be interesting in ways that knowing more about haskell specifically would have made algorithm improvements trivial
00:27:48 <lispy_> This is really quite obnoxious.
00:28:01 <Ptival> lispy: that seems problematic for sure :\
00:29:43 <lispy_> More annoying is that 'runghc Setup.hs makefile' is documented in the cabal manual but it's not a recognized command :(
00:30:30 <lispy_> cabal is probably the least flexile build system I've ever used.
00:30:53 <miyako> actually, Ptival, I take that back; although I know the algorithms could be better, there is no sense in not potentially learning something by hearing your feedback on the algorithms if you have feedback
00:31:17 <geheimdienst> my pet peeve with cabal is that it can't (yet?) pass options to haddock
00:35:30 <Ptival> miyako: I'm not sur why you chose that vertices hold their edges
00:35:46 <lispy_> and --with-gcc=foo, doesn't seem to work with cabal :(
00:35:46 <Ptival> are they the outgoing ones?
00:36:51 <geheimdienst> lispy_, are you working with .hsc or is that some via-c thing?
00:36:55 <geheimdienst> (just curious)
00:37:23 <miyako> Ptival: yeah, the idea was that the vertex has a list of the outgoing edges
00:37:36 <miyako> and then the edges know their weight and what vertex they go to
00:37:42 <lispy_> geheimdienst: I'm trying to get objective-c files to build on osx.  I need to trick ghc into thinking they are c files while still having gcc think they are objective-c files
00:37:53 <lispy_> geheimdienst: GHC by default thinks that .m files are linker scripts
00:37:54 <Ptival> miyako: vertex_edges === Vertex.edges === edges
00:38:31 <miyako> Ptival: yeah, I learned that when you explained it to CADD :)
00:38:32 <geheimdienst> interesting!
00:40:27 <lispy_> geheimdienst: yeah, so I tried writing a wrapper around gcc (called occ) that forces gcc to treat all input as objective-c files.  But, cabal doesn't correctly tell ghc to use my occ script.  cabal has --with-gcc as an option to configure but when I run it with verbose output I can see that it ignores the option.
00:40:49 <lispy_> geheimdienst: I also tried setting ghc-options: -pgmc occ, in my .cabal file to no avail
00:41:16 <lispy_> geheimdienst: it looks like I'll need a makefile.  But, I only need the makefile on osx, so I don't want to require it on windows.
00:41:30 <lispy_> So, then, what I need a separate package just for OSX?
00:41:59 <lispy_> The inflexibility of cabal here is really really annoying
00:42:04 <miyako> hlint really prefers camelCase huh? lol
00:42:07 <lispy_> And the documentation seems to be completely wrong
00:42:18 <augur> anyone have suggestions on deriving equivalent data types by algebraic constructor manipulations??
00:42:19 <lispy_> miyako: camelcase is the haskell standard
00:42:27 <geheimdienst> hm ... so could you do: "PATH=./something:$PATH cabal ..." in bash, with a shell script ./something/gcc that has the parameters ...?
00:42:51 <geheimdienst> (somewhat hacky, but i don't think it crosses the line yet)
00:42:52 <geheimdienst> :)
00:42:53 <lispy_> geheimdienst: oh, I'll try that
00:43:48 <miyako> well, I guess I'll have to learn to change my haskell to camelcase before I share it with anyone
00:43:49 <lispy_> geheimdienst: oh, I think ghc uses some other mechanism to find it's gcc
00:44:03 <miyako> but I really find camelCase much more difficult to read than using_underscores
00:44:33 <shachaf> I wish Haskell didn't use camel_case.
00:44:35 <geheimdienst> not from PATH? o_O
00:45:42 <miyako> well, I really appreciate the input everyone
00:45:51 <augur> noone? :(
00:46:12 <miyako> sorry for all the newb questions
00:46:14 <miyako> g'nite
00:46:30 <geheimdienst> just to be clear, afaik you have the options of saying «export PATH="abc:$PATH" \n commands», or of saying «PATH="abc:$PATH" command» on one line
00:48:30 <lispy_> geheimdienst: oh, okay, it does work. but ghc is passing some options to gcc that are messing things up....but maybe I can fix that in the script
01:08:11 * lispy_ is now baffled again
01:08:57 <lispy_> I took the gcc command that ghc is trying to use and modified it to call the .m file and specify objective-c to gcc, but now I get errors about SSE instructions.
01:09:36 <xaotik> Hi! Question about type classes. You know how in math I can, say, instantiate the real line as a topological space in different ways by specifying different topologies? Can I do similar things in Haskell, by instantiating a type as a member of a type class in different ways?
01:10:17 * geheimdienst knows nothing about this, but would search the gcc manpage for "sse". it has literally eleventy hundred options. maybe you need to turn on sse instructions.
01:10:22 <geheimdienst> ^^ lispy_
01:10:57 <lispy_> geheimdienst: Well, as a test I removed a lot of the code gen options that gcc is using and it stopped giving the errors
01:11:20 <lispy_> geheimdienst: so it seems that ghc is doing something weird that isn't a problem on non-objective-c source.
01:13:04 <geheimdienst> yeah ... strange ... i guess you could give gcc the opposite option in the script. turn off that problematic thing that ghc turns on
01:14:22 <lispy_> Well, i'm actually thinking that a make file and a OSX-only package that makes a .a file is the cleanest solution
01:15:16 <geheimdienst> yes, probably. that changing PATH proposal was already somewhat hacky
01:16:51 <mreh> I can't see any trace output
01:17:03 <mreh> the Debug.Trace.trace trace
01:17:31 <mreh> is it going to the stderr
01:25:16 <mreh> clearly the value is never demanded
01:25:59 <mreh> or I have a serious compiler problem
01:42:55 <Jafet> @src trace
01:42:55 <lambdabot> trace string expr = unsafePerformIO $ do
01:42:55 <lambdabot>     hPutStrLn stderr string
01:42:55 <lambdabot>     return expr
01:43:14 * hackagebot uu-parsinglib 2.7.0.1 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.0.1 (DoaitseSwierstra)
01:44:08 <bss03> xaotik: You use newtype wrappers.
01:44:53 <bss03> xaotik: Compare the "normal" [] Monad instance with the ZipList Monad instance.  Both use [] as the underlying data structure.
01:45:25 <xaotik> I saw a paper on "named instances"
01:45:39 <xaotik> Is there a GHC extension for that?
01:45:59 <bss03> Don't know.  Doesn't ring a bell.
01:46:13 <bss03> But, I'm far from a Haskell expert.
01:46:25 <xaotik> It seems like a much more natural solution
01:47:15 <xaotik> The idea seems to be to just say (value # instance) instead of (value) to specify what kind of instantiation you want
01:47:27 <bss03> xaotik: What's un"natural" about newtype wrappers?
01:48:37 <bss03> I'd worry a bit that syntax like that would interfere with (a) custom operators and (b) GHC's own magic hash.
01:50:48 <xaotik> In my topology example, I look at the real line as being the same object no matter what topology I decide to put on it. I don't know about the wisdom of the syntax choice, you're probably right. In the paper they claim that using named instances cleans up some definitions that would otherwise be messy with newtype.
01:51:51 <xaotik> It's called "Named Instances for Haskell Type Classes"
03:02:17 <bss03> @type (#)
03:02:18 <lambdabot> parse error on input `)'
03:14:44 <bss03> xaotik: Skimmed the paper.  Checked the GHC 7 documentation.  I don't think it is implemented, yet.
03:16:33 <bss03> xaotik: I'm still a bit wary of it, but I don't think it's use of '#' will actually collide with much.
03:18:30 <bss03> xaotik: Does seem like it could clean up some code.  I forget how context-sensitive the newtype wrap/unwrap is, I don't do it enough.
03:20:17 <bss03> > let x # y = y : x in 3 # 2 # 1 # []
03:20:18 <lambdabot>   No instances for (GHC.Num.Num [[a]], GHC.Num.Num [a])
03:20:18 <lambdabot>    arising from a use...
03:20:34 <bss03> > let x # y = y : x in [] # 3 # 2 # 1
03:20:36 <lambdabot>   [1,2,3]
03:22:05 <bss03> Well, it'll collide with custom operators called '#', I guess.
03:27:24 <levifikri> Hi, I got the following problem
03:27:26 <levifikri>     Ambiguous module name `Data.Binary':
03:27:26 <levifikri>       it was found in multiple packages:
03:27:26 <levifikri>       binary-0.5.0.2 ghc-binary-0.5.0.2
03:27:42 <levifikri> how to explicitly point it to either one of them?
03:28:28 <Kaidelong> the only elegant way is to use cabal
03:28:38 <levifikri> Kaidelong how?
03:29:01 <levifikri> need to uninstall one of them?
03:29:22 <Kaidelong> levifikri: no, you'd make a cabal project which specifies which one to use
03:29:27 <Kaidelong> I do not remember how to do this
03:29:36 <Kaidelong> there is also an extension PackageImports
03:29:48 <Kaidelong> which allows you to specify what package you want exactly, in an import
03:29:52 <Kaidelong> but that's ugly
03:30:16 <Kaidelong> depending on what you want to do, it's the quicker and easier way though
03:31:28 * Kaidelong tries to dig up documentation on PackageImports, and fails miserably
03:32:10 <Kaidelong> oh here we go
03:32:28 <Kaidelong> import "name-of-the-package-you-want-to-import-from" What.You.Are.Importing
03:32:58 <Kaidelong> then use {#- LANGUAGE PackageImports -#}
03:33:10 <Kaidelong> for levifikri
03:33:30 <Kaidelong> if you actually want to publish this though you'll probably want to explicitly list your actual dependencies in a cabal project file
03:33:38 <Kaidelong> rather than relying on XPackageImports
03:33:47 <monadic_kid> levifikri: how are you building your program?
03:34:18 <monadic_kid> levifikri: are you using cabal or directly with ghc?
03:34:44 <Kaidelong> there is an even more inelegant way, in that you can give GHC a parameter to make it ignore a package
03:35:46 <monadic_kid> Kaidelong: i don't see that as elegance or not, if you're compiling with ghc then there is no problem using -hide-package
03:36:15 <Kaidelong> monadic_kid: Actually, since you don't pollute the source code in any way, that's probably more elegant than package imports
03:36:46 <Kaidelong> although cabal would probably be the way to go here
03:37:15 <monadic_kid> levifikri: how ae you building your program?
03:40:53 <aristid> Kaidelong: you do NOT have to use cabal oder PackageImports
03:41:17 <aristid> Kaidelong: when i use ghci by hand in such cases, i just do ghci -hide-package offending-package
03:41:21 <Kaidelong> aristid: I did mention -hide-package
03:41:26 <Kaidelong> oh, I didn't by name though
03:41:37 <Kaidelong> now I did!
03:41:43 <aristid> i did first!
03:41:58 <Kaidelong> aristid: I knew the name of it, I swear!
03:42:25 <aristid> Kaidelong: but you in the beginning said that using cabal was the only way, so your mind did not remind you fully of it :P
03:42:41 <Kaidelong> aristid: I said it was the only truly elegant way
03:43:10 <Kaidelong> as in you know it'll work just about anywhere
03:43:12 <Kaidelong> every time
03:43:20 <aristid> Kaidelong: cabal does -hide-all-packages and then pulls in all packages with -package one at a time
03:43:21 <Kaidelong> (so long as cabal is around at least)
03:43:27 <aristid> you CAN also do that by hand :P
03:43:27 <Kaidelong> yeah
03:43:31 <Kaidelong> yeah
03:43:38 <aristid> of course i use cabal too
03:43:41 <Kaidelong> but the point is that you are not doing it by hand
03:44:15 <Kaidelong> (and cabal is a standard way to automate these things)
03:44:25 <xaotik> bss03: Sorry, sfk. But yeah it seems like a cool idea! Hopefully somebody picks it up. I guess newtype will work for now though.
03:44:29 <xaotik> afk*
03:45:13 <Kaidelong> what really is odd is that there are so many different ways to do this
03:45:23 <Kaidelong> although I guess the cabal way is blessed
03:48:23 <dibblego> @pl \f p g x -> concatMap f . filter p . map g $ x
03:48:23 <lambdabot> (. ((. map) . (.) . filter)) . (.) . (.) . (=<<)
03:50:47 <aristid> Kaidelong: really there are only two ways: adjust the default package set with -hide-package or start from a clean slate with -hide-all-packages. cabal just is a convenience wrapper around the latter. so you can't really say that there are many ways to do this
03:51:26 <Kaidelong> aristid: there is XPackageImports
03:52:32 <aristid> Kaidelong: oh, right, but that requires adjusting the source code :)
04:13:26 <levifikri> monadic_kid sorry I got meeting just now.. Yup, I use ghc, and your solution does work. Thx! :D
04:41:06 <emartinj> Anyone here experienced with the ffi? I have som rather simple code that segfaults when I hook a finalizer to a ForeignPtr. 
04:44:40 <monadic_kid> emartinj: can paste it
04:44:48 <monadic_kid> emartinj: *can u paste it
04:45:33 <emartinj> sure. http://hpaste.org/44742/segfaulting_code_windows
04:47:50 <emartinj> I'm wrapping a MIP solver (cbc) through its C interface. I'm on windows 7 32 bit using the latest haskell platform. The calling convention is stdcall. When I try the del function it works ok. I'm a total haskell noob, but have a project that I'd really like to try out in Haskell.
04:53:45 <mreh> I've got to go through learning the ffi this week, I want to write hooks for the BioAPI
04:54:41 <monadic_kid> emartinj: safe keyword means that the imported C function could call back into Haskell, if that is not the case then mark it as unsafe, do you need to use block? the docs says this is deprecated and should use mark funciton. Also there is maybePeek: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Marshal-Utils.html#v:maybePeek
04:58:48 <monadic_kid> emartinj: are you sure you're dealing with stdcalls, did you wrap the C code in extern "c"?
05:11:18 <Phantom_Hoover> So I want the new shiny Haskell platform because I'm a neophile — what do I do?
05:11:31 <Phantom_Hoover> I'm on Debian Squeeze with GHC 6.12.
05:12:52 <hpc> sudo apt-get install haskell-platform
05:13:05 <hpc> er, no
05:13:08 <hpc> that's the 2010 one
05:14:40 <hpc> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
05:14:44 <Kaidelong> :t unzip . map fst . (zip`ap`tail) . (zip`ap`tail)
05:14:45 <lambdabot> forall b. [b] -> ([b], [b])
05:15:04 <Kaidelong> > unzip . map fst . (zip`ap`tail) . (zip`ap`tail) $ [1,2,3,4,5,6,7,8]
05:15:06 <lambdabot>   ([1,2,3,4,5,6],[2,3,4,5,6,7])
05:15:12 <Kaidelong> whoops
05:15:24 <hpc> lol
05:15:52 <Kaidelong> > (zip`ap`tail) . (zip`ap`tail) $ [1,2,3,4,5,6,7,8]
05:15:54 <lambdabot>   [((1,2),(2,3)),((2,3),(3,4)),((3,4),(4,5)),((4,5),(5,6)),((5,6),(6,7)),((6,...
05:16:46 <hpc> Phantom_Hoover: uninstall ghc 6.12 first, probably
05:19:58 <Kaidelong> > (zip`ap`tail.tail) $ [1,2,3,4,5,6,7,8]
05:19:58 <lambdabot>   Precedence parsing error
05:19:59 <lambdabot>      cannot mix `Control.Monad.ap' [infixl 9] and ...
05:20:05 <Kaidelong> > (zip`ap`(tail.tail)) $ [1,2,3,4,5,6,7,8]
05:20:07 <lambdabot>   [(1,3),(2,4),(3,5),(4,6),(5,7),(6,8)]
05:32:07 <hpc> @hoogle Int -> m a -> m [a]
05:32:07 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
05:32:07 <lambdabot> Text.ParserCombinators.ReadP count :: Int -> ReadP a -> ReadP [a]
05:32:07 <lambdabot> Prelude drop :: Int -> [a] -> [a]
05:38:21 <koniiiik> Is there any documentation explaining comprehensively the available numeric types, predefined operations and such?
05:38:57 <ezyang> koniiiik: Probably the Haskell98 specification. 
05:39:00 <Eduard_Munteanu> koniiiik: the Haskell Report?
05:39:09 <ezyang> Not including external libraries, of course. 
05:39:11 <koniiiik> I found lots and lots of documents that are gibberish to anyone who hasn't been using Haskell for the past 10 years at least.
05:39:30 <ezyang> koniiiik: What information are you looking for? 
05:39:35 <Eduard_Munteanu> comprehensive != easy
05:39:49 <Eduard_Munteanu> @where report
05:39:49 <lambdabot> http://www.haskell.org/onlinereport/
05:40:00 <koniiiik> Yeah, well...
05:40:09 <koniiiik> Which exact part of the report should I look at?
05:40:47 <ezyang> Predefined types and classes 
05:41:06 <ezyang> 6.4: Numbers. but there are also some other relevant sections (like Ord and Eq) 
05:41:39 <ezyang> But as you yourself pointed out, the docs are written very much from the perspective "you know what typeclasses are'. If you don't know what typeclasses are, this won't be very helpful. 
05:41:40 <Eduard_Munteanu> Also http://www.haskell.org/onlinereport/exps.html might be useful
05:42:18 <Eduard_Munteanu> koniiiik: if you're merely interested in learning Haskell, you should probably take a look at LYAH first
05:42:21 <Eduard_Munteanu> @where lyah
05:42:22 <lambdabot> http://www.learnyouahaskell.com/
05:42:38 <koniiiik> ...and to think I only wanted to know why the predefined division function doesn't return a rational number...
05:42:49 <Eduard_Munteanu> Then if you need a quick reference you can lookup the Prelude online.
05:42:51 <ezyang> Sure. 
05:42:53 <ezyang> :t (/) 
05:42:54 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:43:11 <ezyang> :info Fractional 
05:43:18 <Eduard_Munteanu> @src Rational
05:43:18 <lambdabot> type Rational = Ratio Integer
05:43:19 <ezyang> aww, does lambdabot not support that? 
05:43:26 <Eduard_Munteanu> @src Fractional
05:43:26 <lambdabot> class  (Num a) => Fractional a  where
05:43:26 <lambdabot>     (/)             :: a -> a -> a
05:43:26 <lambdabot>     recip           :: a -> a
05:44:12 <ezyang> rationals are fractionals, though division is monomorphic in its three arguments, so they all have to be the same type. 
05:44:18 <ezyang> > 2 / 3 
05:44:19 <lambdabot>   0.6666666666666666
05:44:27 <Eduard_Munteanu> You can also use this as a reference: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
05:44:32 <ezyang> > (2 / 3) :: Rational 
05:44:33 <lambdabot>   2 % 3
05:44:45 <ezyang> There's also defaulting going on. 
05:45:54 <koniiiik> Now I'm definitely lost... Thanks anyway, I guess I'll somehow figure it out.
05:46:27 <Eduard_Munteanu> :)
05:46:33 <ezyang> If you give us a specific example, we can give more targeted advice. 
05:46:34 <Eduard_Munteanu> You should definitely take a look at LYAH.
05:46:54 <Kaidelong> @ty (/) <*> fromIntegral
05:46:55 <lambdabot> forall a. (Fractional a, Integral a) => a -> a
05:47:00 <Kaidelong> oh right
05:47:09 <Kaidelong> herp
05:47:24 <Kaidelong> @ty fmap fromIntegral . fmap (/) fromIntegral
05:47:25 <lambdabot> forall a b a1. (Integral a, Num b, Fractional a, Integral a1) => a1 -> a -> b
05:48:08 <Kaidelong> @ty (. fromIntegral) . ((/) . fromIntegral)
05:48:09 <lambdabot> forall a a1 a2. (Integral a1, Fractional a, Integral a2) => a2 -> a1 -> a
05:48:26 <Kaidelong> > (. fromIntegral) . ((/) . fromIntegral) 4 6
05:48:27 <lambdabot>   No instance for (GHC.Real.Fractional (f (a -> b)))
05:48:27 <lambdabot>    arising from a use of...
05:48:39 <Kaidelong> > (. fromIntegral) . ((/) . fromIntegral) (4: Int) (6: Word8)
05:48:40 <lambdabot>   Not in scope: data constructor `Int'Not in scope: data constructor `Word8'
05:48:49 <Kaidelong> > (. fromIntegral) . ((/) . fromIntegral) (4 :: Int) (6 :: Word8)
05:48:50 <lambdabot>   Couldn't match expected type `f (a -> b)'
05:48:50 <lambdabot>         against inferred type `GH...
05:49:20 <Eduard_Munteanu> Kaidelong: missing some paranthesis...
05:49:31 <Eduard_Munteanu>  > ((. fromIntegral) . ((/) . fromIntegral)) (4 :: Int) (6 :: Word8)
05:49:34 <Eduard_Munteanu> > ((. fromIntegral) . ((/) . fromIntegral)) (4 :: Int) (6 :: Word8)
05:49:35 <lambdabot>   0.6666666666666666
05:49:42 <Kaidelong> there we go
05:49:48 <Kaidelong> or just use $ I guess
05:49:58 <Eduard_Munteanu> Yeah.
05:51:44 <Kaidelong> oh wait that won't work
05:51:50 <Kaidelong> $ is right associative
05:52:04 <Kaidelong> but confusingly, in lambdabot
05:52:17 <Kaidelong> (. fromIntegral) . ((/) . fromIntegral) $ 4 6
05:52:22 <Kaidelong> should typecheck
05:52:31 <Kaidelong> > (. fromIntegral) . ((/) . fromIntegral) $ 4 6
05:52:31 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a1)
05:52:32 <lambdabot>    arising from a use of ...
05:52:38 <Kaidelong> yep
05:52:46 <Eduard_Munteanu> Uh, yeah.
05:53:05 <Eduard_Munteanu> With ($) 6 would apply to 4 ;)
05:53:32 <koniiiik> Okay, looks like I won't be able to figure it out by myself.
05:53:44 <Kaidelong> koniiiik: What are you trying to do?
05:53:48 <Kaidelong> turn integers into rationals?
05:53:53 <koniiiik> I have two variables of type Int, I want somehow to squeeze out their quotient as a rational number.
05:54:05 <Eduard_Munteanu> :t div
05:54:06 <lambdabot> forall a. (Integral a) => a -> a -> a
05:54:23 <Kaidelong> Eduard_Munteanu: I do not think that is what he wants
05:54:26 <Eduard_Munteanu> Ah.
05:54:34 <Kaidelong> (. fromIntegral) . ((/) . fromIntegral)
05:54:38 <Eduard_Munteanu> @hoogle a -> Rational
05:54:39 <lambdabot> Prelude toRational :: Real a => a -> Rational
05:54:39 <lambdabot> Data.Time.LocalTime timeOfDayToDayFraction :: TimeOfDay -> Rational
05:54:39 <lambdabot> Data.Time.Clock getModJulianDate :: UniversalTime -> Rational
05:54:39 <Kaidelong> should serve his purpose, though
05:55:21 <Kaidelong> > let (./.) = (. fromIntegral) . ((/) . fromIntegral) in 5 ./. 6 :: Rational
05:55:21 <Eduard_Munteanu> > toRational $ 3 / 4
05:55:22 <lambdabot>   3 % 4
05:55:23 <lambdabot>   5 % 6
05:55:36 <Eduard_Munteanu> > toRational $ 3 / 9
05:55:36 <lambdabot>   6004799503160661 % 18014398509481984
05:55:40 <Eduard_Munteanu> Eww.
05:55:48 <Twey> o.@  Ewwwww.
05:55:53 <Eduard_Munteanu> > 3 % 9
05:55:54 <lambdabot>   1 % 3
05:55:54 <Kaidelong> > let (./.) = (. fromIntegral) . ((/) . fromIntegral) in 3 ./. 9 :: Rational
05:55:55 <koniiiik> *sigh*
05:55:56 <lambdabot>   1 % 3
05:56:04 <Twey> Yay rounding errors ☺
05:56:05 <Eduard_Munteanu> Ok, you can simply use '%'.
05:56:10 <Kaidelong> @ty (%)
05:56:11 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
05:56:13 <Twey> Yeah, % is the way to go
05:56:16 <Eduard_Munteanu> :t (%)
05:56:17 <Kaidelong> oh there we go
05:56:17 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
05:56:30 <Kaidelong> koniiiik: use the % operator
05:56:34 <Eduard_Munteanu> I initially thought it was a constructor.
05:56:35 <Twey> You could also use CReal, I think?
05:56:40 <Twey> :t toRational
05:56:41 <lambdabot> forall a. (Real a) => a -> Rational
05:56:42 <Kaidelong> Eduard_Munteanu: It probably is
05:56:52 <Twey> > toRational (3 / 9 :: CReal)
05:56:53 <lambdabot>   *Exception: CReal.toRational
05:56:58 <Phantom_Hoover> <hpc> Phantom_Hoover: uninstall ghc 6.12 first, probably
05:56:58 <Twey> :-\  Really?
05:57:09 <Phantom_Hoover> Then what?
05:57:10 <Twey> I'd assume CReal could convert to Rational fairly easily
05:57:16 <Eduard_Munteanu> @src Ratio
05:57:16 <lambdabot> data (Integral a) => Ratio a = !a :% !a
05:57:17 <Twey> I thought it was basically a Rational inside
05:57:33 <koniiiik> Kaidelong: <interactive>:1:3: Not in scope: `%'
05:57:43 <Twey> koniiiik: import Data.Ratio
05:57:48 <Twey> @index (%)
05:57:48 <lambdabot> Data.Ratio
05:57:51 <Twey> Yeah.  Data.Ratio.
05:57:59 <koniiiik> Eh, okay...
05:58:03 <Eduard_Munteanu> > 3 :% 9
05:58:04 <lambdabot>   Not in scope: data constructor `:%'
05:58:05 <mauke> Twey: Reals aren't Rational
05:58:23 <Kaidelong> Rationals don't suffer from FP impercision
05:58:25 <Twey> mauke: Oh, dud.
05:58:28 <Twey> duh**
05:58:32 <Kaidelong> they're also slower
05:58:38 <Kaidelong> for the same reason
05:58:43 <Twey> It could convert the ones that are, though.
05:58:52 <Twey> Also
05:58:53 <Eduard_Munteanu> Ok so it's not a constructor, though the Show and Rational instances could've done that reduction to coprime num/denum
05:58:55 <Twey> :t toRational
05:58:55 <lambdabot> forall a. (Real a) => a -> Rational
05:59:01 <Twey> Isn't that what toRational is *for*?
05:59:20 <mauke> @hoogle approx
05:59:20 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
05:59:27 <Eduard_Munteanu> toRational does an approximation I guess.
05:59:31 <koniiiik> Hm, now I get     Couldn't match expected type `Int' against inferred type `Integer'
05:59:39 <Twey> Eduard_Munteanu: It's just a renaming and retyping of the constructor, for convenience purposes
06:00:05 <burp> > approxRational (1 % 4) (1 % 10)
06:00:06 <lambdabot>   1 % 3
06:00:07 <Eduard_Munteanu> koniiiik: both numbers given to (%) must have the same type
06:00:17 <Twey> Why are there two a's in that?
06:00:25 <koniiiik> Eduard_Munteanu: Yes, they are both Ints.
06:00:40 <Eduard_Munteanu> koniiiik: could you paste your code?
06:00:44 <Eduard_Munteanu> @where hpaste
06:00:44 <lambdabot> http://hpaste.org/
06:01:44 <Kaidelong> > ((/) `on` fromInteger) (5 :: Int) (10 :: Word8)
06:01:45 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
06:01:45 <lambdabot>         against inf...
06:01:56 <Kaidelong> > ((/) `on` fromIntegral) (5 :: Int) (10 :: Word8)
06:01:57 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:01:57 <lambdabot>         against inferred type ...
06:02:22 <Kaidelong> > fromIntegral (10 :: Word8)
06:02:23 <lambdabot>   10
06:02:30 <Kaidelong> what is the problem then
06:02:41 <mauke> :t (/) `on` fromIntegral
06:02:42 <lambdabot> forall b a. (Fractional b, Integral a) => a -> a -> b
06:02:45 <mauke> a a
06:03:02 <Kaidelong> oh right, on can't fix that
06:03:07 <Eduard_Munteanu> :t on
06:03:08 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:03:11 <Kaidelong> so you'd have to resort to
06:03:41 <Kaidelong> > ((. fromInteger) . ((/) . fromInteger)) (5 :: Int) (10 :: Word8)
06:03:42 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
06:03:42 <lambdabot>         against inf...
06:03:56 <Kaidelong> > ((. fromIntegral) . ((/) . fromIntegral)) (5 :: Int) (10 :: Word8)
06:03:57 <lambdabot>   0.5
06:04:01 <Kaidelong> there we go
06:04:06 <Kaidelong> > ((. fromIntegral) . ((/) . fromIntegral)) (5 :: Int) (10 :: Word8) :: Rational
06:04:08 <lambdabot>   1 % 2
06:04:32 <Kaidelong> > ((. fromIntegral) . ((/) . fromIntegral)) (5 :: Int) (10 :: a -> Word8) :: Rational
06:04:33 <lambdabot>   No instance for (GHC.Real.Integral (a -> GHC.Word.Word8))
06:04:33 <lambdabot>    arising from a...
06:04:42 <Kaidelong> thought so
06:04:44 <Kaidelong> also, good
06:04:50 <Phantom_Hoover> So, erm, can you compile GHC 7 with GHC 6.12?
06:05:24 <MAN> Phantom_Hoover: uh, good. I haven't tryied to compile ghc 7 yet.
06:05:35 <MAN> Phantom_Hoover: you found any issues?
06:05:41 <Phantom_Hoover> I'm asking if you can.
06:05:55 <MAN> ohh... so we are BOTH lazy...
06:06:40 <Phantom_Hoover> Indeed.
06:06:46 <Kaidelong> koniiiik: If it says "inferred type integer" it means that the compiler does not agree with you that both are ints
06:07:45 <Kaidelong> koniiik: Try adding a type declaration :: Int for the thing giving you trouble
06:07:50 <Kaidelong> and see what happens
06:08:34 <Eduard_Munteanu> :t \a b -> (fromIntegral a) % (fromIntegral b)
06:08:35 <lambdabot> forall a b a1. (Integral a, Integral b, Integral a1) => a -> a1 -> Ratio b
06:08:52 <Kaidelong> > ((. fromIntegral) . ((/) . fromIntegral)) (5 :: Int) (10 :: a -> Word8) :: Ratio Word8
06:08:52 <lambdabot>   No instance for (GHC.Real.Integral (a -> GHC.Word.Word8))
06:08:53 <lambdabot>    arising from a...
06:09:00 <Kaidelong> > ((. fromIntegral) . ((/) . fromIntegral)) (5 :: Int) (10 :: Word8) :: Ratio Word8
06:09:02 <lambdabot>   1 % 2
06:09:04 <Eduard_Munteanu> Actually, you could do with...
06:09:10 <Kaidelong> > ((. fromIntegral) . ((/) . fromIntegral)) (511 :: Int) (10 :: Word8) :: Ratio Word8
06:09:11 <lambdabot>   51 % 2
06:09:32 <Eduard_Munteanu> :t \a b -> (fromIntegral a) % b
06:09:33 <lambdabot> forall a b. (Integral a, Integral b) => a -> b -> Ratio b
06:09:46 <Kaidelong> > fromIntegral (511 :: Int) :: Word8
06:09:47 <lambdabot>   255
06:10:04 <Kaidelong> > 255 % 10
06:10:04 <lambdabot>   51 % 2
06:10:48 <Kaidelong> wow the opportunities for obfuscation are boundless
06:11:01 <Eduard_Munteanu> @pl \a b -> (fromIntegral a) % b
06:11:01 <lambdabot> (%) . fromIntegral
06:11:11 <Eduard_Munteanu> @pl \a b -> (fromIntegral a) % (fromIntegral b)
06:11:11 <lambdabot> (. fromIntegral) . (%) . fromIntegral
06:11:19 <Eduard_Munteanu> Yep.
06:11:26 <parcs> @type let sequence = liftM2 (:) (fmap head) (sequence .: tail) in sequence
06:11:28 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
06:11:28 <lambdabot>       Expected type: [a] -> [a]
06:11:28 <lambdabot>       Inferred type: [[a]] -> [[a]]
06:11:46 <Kaidelong> > (100 :: Word8) % 276
06:11:47 <lambdabot>   5 % 1
06:12:32 <Kaidelong> > 355 % 532 :: Ratio Word8
06:12:32 <lambdabot>   99 % 20
06:14:23 * hackagebot cabal2arch 0.8.0 - Create Arch Linux packages from Cabal packages.  http://hackage.haskell.org/package/cabal2arch-0.8.0 (PeterSimons)
06:17:08 <hpc> @src Ratio
06:17:08 <lambdabot> data (Integral a) => Ratio a = !a :% !a
06:17:51 <hpc> @let ratioApply x (a :% b) = a x :% b x
06:17:52 <lambdabot>  <local>:1:16: Not in scope: data constructor `:%'
06:17:52 <lambdabot>  
06:17:52 <lambdabot>  <local>:1:28: Not in sc...
06:17:58 <Phantom_Hoover> So what new things are there in the latest version of the Haskell platform and GHC?
06:18:05 <hpc> aw...
06:18:53 <aristid> Phantom_Hoover: everything faster!
06:18:54 <hpc> :t let ratioApply x (a :% b) = a x :% b x in ratioApply
06:18:55 <lambdabot> Not in scope: data constructor `:%'
06:18:55 <lambdabot> Not in scope: data constructor `:%'
06:19:04 <aristid> hpc: you can only use %
06:19:08 <aristid> hpc: :% is hidden
06:19:17 <hpc> aristid: that's no fun :P
06:19:24 <aristid> @src Ratio
06:19:24 <lambdabot> data (Integral a) => Ratio a = !a :% !a
06:19:34 <hpc> @src (%)
06:19:35 <lambdabot> x % y = reduce (x * signum y) (abs y)
06:19:52 <hpc> :t reduce
06:19:53 <lambdabot> Expr -> Expr
06:20:09 * hpc is confused now
06:20:12 <Eduard_Munteanu> So no pattern matching rationals for you ;)
06:20:16 <aristid> hpc: there are numerator and denominator functions
06:20:21 <hpc> > reduce x
06:20:22 <lambdabot>   x
06:20:25 <hpc> :t numerator
06:20:26 <lambdabot> forall a. (Integral a) => Ratio a -> a
06:20:27 <aristid> :t reduce
06:20:28 <lambdabot> Expr -> Expr
06:20:30 <hpc> oh cool
06:20:39 <aristid> hpc: reduce is not a real function, it seems :)
06:20:47 <koniiiik> Kaidelong, Eduard_Munteanu: Sorry about the delay, here's what I'm trying to do: http://hpaste.org/44743/what_im_trying_to_do
06:20:51 <hpc> :t let ratioApply x r = (numerator r x) % (denominator r x)
06:20:52 <lambdabot> <no location info>:
06:20:52 <lambdabot>     not an expression: `let ratioApply x r = (numerator r x) % (denominator r x)'
06:20:56 <hpc> :t let ratioApply x r = (numerator r x) % (denominator r x) in ratioApply
06:20:57 <lambdabot> forall t a. (Integral a, Integral (t -> a)) => t -> Ratio (t -> a) -> Ratio a
06:21:13 <hpc> > let ratioApply x r = (numerator r x) % (denominator r x) in ratioApply (5 % 1) 2
06:21:13 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio t -> a))
06:21:13 <lambdabot>    arising from...
06:21:15 <aristid> hpc: what's wrong with you! :P
06:21:33 <Eduard_Munteanu> @src Rational
06:21:33 <lambdabot> type Rational = Ratio Integer
06:21:33 <hpc> aristid: i was really hoping there would be an integral instance for functions, like the Num instance
06:21:51 <Eduard_Munteanu> koniiiik: you should use Ratio Int there instead of Rational
06:22:07 <Eduard_Munteanu> koniiiik: or use Integer everywhere.
06:22:12 <Eduard_Munteanu> instead of Int
06:22:15 <koniiiik> Eduard_Munteanu: Eh, okay, should I ask why is that?
06:22:28 <Eduard_Munteanu> koniiiik: type Rational = Ratio Integer
06:22:28 <hpc> @src Integral
06:22:29 <lambdabot> class  (Real a, Enum a) => Integral a  where
06:22:29 <lambdabot>     quot, rem, div, mod :: a -> a -> a
06:22:29 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
06:22:42 <Eduard_Munteanu> koniiiik: that's why it complains about mismatches between Integer and Int.
06:22:50 <koniiiik> Hm, OK...
06:23:01 <Eduard_Munteanu> Because Rational forces Integer.
06:23:02 <hpc> @src Real
06:23:02 <lambdabot> class  (Num a, Ord a) => Real a  where
06:23:02 <lambdabot>     toRational      ::  a -> Rational
06:23:19 <hpc> eek
06:23:28 <Eduard_Munteanu> Ew.
06:23:33 <hpc> so much for that evil plan :)
06:24:09 <greenrd> what's the best way of debugging ffi code where haskell calls a C library? gdb and set a breakpoint in the C code?
06:29:06 <hpc> greenrd: the only way to know is to try? :P
06:31:55 <ezyang> greenrd: Are you debugging a segfault? 
06:32:24 <greenrd> ezyang: no, an incorrect result
06:32:51 <ezyang> In that case, gdb will only be useful if you believe the C library itself is buggy. 
06:33:28 <greenrd> well, at least I can see what is going in and out of the C library that way, no?
06:33:40 <ezyang> Yes. 
06:34:07 <ezyang> But it will be annoying to figure out which Haskell call resulted in the C call. 
06:34:15 <greenrd> ok
06:34:30 <ezyang> So it's probably better to add tracing at the Haskell level. 
06:35:39 <Eduard_Munteanu> @hoogle trace
06:35:39 <lambdabot> Debug.Trace trace :: String -> a -> a
06:35:39 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
06:35:40 <lambdabot> module Debug.Trace
06:37:34 <ezyang> Ah, the ability to run speculatively run stateful computations in Haskell: glorious. 
06:37:37 * ezyang ♥ persistence 
06:40:29 * hackagebot utility-ht 0.0.6 - Various small helper functions for Lists, Maybes, Tuples, Functions  http://hackage.haskell.org/package/utility-ht-0.0.6 (HenningThielemann)
06:42:42 <Sir_Burpalot> Greetings, chaps... May I ask a question?
06:43:04 <hpc> Sir_Burpalot: yes, but you only get one and that was it
06:43:05 <hpc> :P
06:43:29 <aristid> Sir_Burpalot: actually you already consumed your allowance of one question. ask tomorrow
06:44:19 <Sir_Burpalot> Well, I'll ask it anyway... What's so great about Haskell?
06:44:37 <Twey> @where whyfp
06:44:37 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
06:44:39 <Sir_Burpalot> It's a static language, so it's obviously inferior to dynamic languages like Ruby and Lua.
06:45:00 <Heffalump> Haskell programmers are better trolls.
06:45:07 <Twey> It's true
06:45:15 <Heffalump> it's because we have to think more than Ruby and Lua programmers
06:45:38 <Sir_Burpalot> Uhm, I'm not really trolling.
06:45:48 <Sir_Burpalot> I really just want to know why you like Haskell so much.
06:45:58 <DevHC> allow me to troll around instead
06:46:00 <DevHC> trolololololololo
06:46:10 <Heffalump> in what way does coming into a channel about a static language and saying "it's obviously inferior to dynamic languages" not consitute trolling?
06:46:20 <Twey> Sir_Burpalot: Static typing gives compile-time guarantees, which cuts down on the time spent by programmers finding annoying niggling bugs.
06:46:48 <Twey> For further possible answers, please read the paper I linked above.
06:47:06 <Sir_Burpalot> Thanks. I'll check it out.
06:47:16 <ceii_> It's more like a statically typed language would be "obviously superior" to dynamic ones if it could offer its guarantees with no cost to expressiveness
06:47:18 <Sir_Burpalot> "The requested URL /~rjmh/Papers/whyfp.html was not found on this server."
06:47:20 <Sir_Burpalot> Pffthahaha.
06:47:32 <Twey> http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
06:47:38 <ceii_> now Haskell doesn't manage to do that, but it's extremely expressive compared to usual static languages
06:47:51 <Twey> @where+ whyfp http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
06:47:51 <lambdabot> Okay.
06:48:28 <Jafet> How can Haskell be superior when it doesn't even have record subtyping?!
06:48:55 <Jafet> Do you know what huge fraction of webscale services are written with subtyping
06:49:33 <Twey> Heheh
06:49:40 <ceii_> does that mean they couldn't have been written almost as easily without it?
06:50:01 <Twey> Jafet: It uses NoSQL instead
06:55:39 <Sir_Burpalot> "The functional programmer sounds rather like a mediaeval monk, denying himself the pleasures of life in the hope that it will make him virtuous."
06:55:46 <Sir_Burpalot> That actually sounds like a very accurate description...
06:56:05 <aristid> haskell is quite pleasant :)
06:56:07 <Jafet> Looks like he's not getting the hint.
06:56:23 <DevHC> or it's that OTHER have no idea what REAL pleasures of life r :]
06:56:29 <DevHC> +s
06:56:35 <Jafet> @where ops
06:56:35 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:56:46 <Jafet> Oops
06:56:55 <ezyang> "Pleasures of life" = "Expressivity of unbounded state usage" 
06:56:56 <Sir_Burpalot> Jafet: I have only just started reading that article. Give me a break.
06:56:56 <Jafet> I thought we had only a high density of phds
06:57:08 <Jafet> Not operators.
06:57:10 <hpc> Sir_Burpalot: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
06:57:18 <hpc> try doing that in any other language
06:57:35 <DevHC> that's simple once u understand the logic behind it
06:57:48 <DevHC> (not that understanding it is so simple)
06:58:10 <hpc> DevHC: indeed; expressing it succinctly is an entirely different matter though
06:59:12 <lispy_> It looks like extra-lib-dirs has to be an absolute path. Why is that (or better yet, how can I get the absolute path?)
06:59:33 <Sir_Burpalot> I'm not denying that functional programming has its advantages.
06:59:44 <Sir_Burpalot> Some languages are partly functional... Like Lua, for instance.
06:59:45 <ezyang> lispy_: Because it's intended to be used with system installed libraries. 
07:00:07 <lispy_> ezyang: So what is the solution for libraries built by the package?
07:00:12 <ezyang> I think abcBridge has a hack to work around this. 
07:00:53 <hpc> @. pl undo \x -> do {y <- var; y $= x; return y}
07:00:53 <lambdabot> (var >>=) . (`ap` return) . ((>>) .) . flip ($=)
07:00:53 <Eduard_Munteanu> Sir_Burpalot: you mean pure vs non-pure.
07:00:56 <lispy_> I had to use a custom makefile to be able to build some of the C code for this package
07:00:56 <hpc> ew
07:01:13 <lispy_> But now packages that depend on this package can't link unless I hardcode a path into the .cabal file.
07:01:21 <lispy_> Which means this package only works on my machine
07:01:25 <lispy_> And that's pretty lame
07:01:28 <ezyang> Yeah, look at abcBridge's Setup.hs 
07:01:46 <ezyang> if you have access to it. 
07:02:10 <lispy_> I don't think I have access to it
07:02:16 <ezyang> Ok, I'll send you a copy. 
07:02:20 <Sir_Burpalot> Eduard_Munteanu: yes, that's what I meant... So why would you want to use a purely functional language when you could use a language like Lua and enjoy the best of both worlds?
07:02:34 * hackagebot numeric-prelude 0.2.1 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.2.1 (HenningThielemann)
07:02:35 <lispy_> But, rewriting the .cabal file in Setup.hs seems kind of ridiculuous
07:02:49 <hpc> request: can we have pl, djinn, etc, as mueval functions?
07:02:52 <hpc> so one can say
07:02:52 <ezyang> You don't need to rewrite the entire thing, but yes, it is slightly ridiculous. 
07:03:00 <hpc> > pl . undo $ "do ..."
07:03:01 <lambdabot>   Not in scope: `pl'Not in scope: `undo'
07:03:15 <ezyang> http://hpaste.org/44744/setuphs_with_usbuilt_librari 
07:03:26 <lispy_> another point of grumble here is that the absolute directory requirement is not documented
07:03:58 <parcs> how can i get this kind of case statement to parse: http://pub.lambda.ath.cx/patrick/stuff/static/Case.hs
07:04:42 <Jafet> @. pl undo [ x | x <- xs ] --hpc
07:04:42 <lambdabot> xs
07:04:45 <ezyang> parcs: you need a bigger indent 
07:04:58 <hpc> Jafet: i know, but it would be fun to be able to manipulate them first-class
07:05:01 <ezyang> lispy_: I can't remember if I told Duncan about this infelicity. If I didn't, I guess I should poke him. 
07:05:17 <lispy_> ezyang: this seems to be the magic line: buildinfo = emptyBuildInfo { extraLibDirs = [static_dir] }
07:05:32 <ezyang> lispy_: Right, but you need all of the extra support stuff to make packages that build with the package work too. 
07:05:47 <lispy_> ridiculous
07:05:50 <lispy_> ezyang: thanks
07:05:52 <Jafet> Well, Stringified code passing doesn't strike me as "first-class". Maybe "golftastic".
07:05:56 <Eduard_Munteanu> Sir_Burpalot: there's a variety of reasons, they generally fall in either (1) getting static assurances, by factoring I/O separately and (2) more opportunities for optimization
07:06:33 <Eduard_Munteanu> Impure languages generally can't do deforestation.
07:06:44 <ezyang> Well, having a Cabal package build the support C library is slightly wrong. 
07:06:59 <Eduard_Munteanu> It's also difficult to statically contain side-effects.
07:07:16 <Zao> ezyang: Interestingly, the policy on CPAN is that things that use foreign libraries ought to bundle source.
07:07:28 <Zao> (not that Haskell is Perl)
07:07:28 <parcs> ezyang: thanks
07:07:30 <ezyang> Zao: Really? I guess that reduces headaches. 
07:07:42 <Heffalump> must make distro integration fun
07:07:54 <lispy_> ezyang: I'm starting to think that letting cabal build anything is wrong.  I'm starting to think it should generate input for proper build systems instead.
07:08:59 <hpc> lispy_: indeed! just so long as it isn't autohell
07:09:36 <ezyang> lispy_: Enh, Cabal does a mostly good job at building Haskell libraries :-) 
07:09:52 <lispy_> hpc: I'm actually thinking that it could generate GNU makefiles (windows GHC installer may then need to bundle make)
07:11:08 <Heffalump> ezyang: mostly because it's calls ghc --make, which is also annoyingly monolithic
07:11:19 <Heffalump> but it does provide a good out of the box solution
07:11:25 <ezyang> Fair enough. 
07:11:30 <lispy_> ezyang: except for the lack of parallel builds, you can't build individual files our sections of the .cabal file, and getting stuff into ghci has been impossible till cabal-dev added support for it
07:12:43 <Heffalump> getting stuff into ghci is actually quite easy, if ugly: cabal build -v, cut and paste the ghc --make line replacing --make with --interactive
07:13:11 <ezyang> Much less fun on Windows, where quoting conventions differ :-) 
07:13:31 <hpc> "much less fun on windows, where * differs" :P
07:14:14 <Heffalump> ezyang: works for me, though I do have to replace all the \ with / first because I'm using a proper shell
07:14:19 <ezyang> Well, it would be OK on Windows if the quoting convention was consistent. 
07:14:23 <ezyang> Heffalump: Yes. That's a pain :-) 
07:14:30 <lispy_> The cabal manual claims that you can now do, runhaskell Setup.hs makefile to get a makefile but my install of GHC doesn't recognize 'makefile' as a valid argument to Setup
07:14:37 <Heffalump> it's not much more work than the rest of the cut-n-paste job
07:14:57 <lispy_> So, I don't know what version of things you need for that makefile support
07:15:00 <Heffalump> lispy_: that sounds like you have a version of Cabal that's out of step with the manual you'r reading.
07:15:39 <lispy_> Heffalump: yeah, and I think it depends not on the installed version of Cabal but on the version of Cabal that GHC was bulit against
07:16:22 <Heffalump> why would it? runhaskell Setup.hs should link Setup.hs against the currently installed Cabal in your packages
07:16:52 <Heffalump> there's nothing magic about Setup.hs here, it's just a program that links against a library in the normal way.
07:17:22 <lispy_> Are you sure?  I've always had weird issues using runhaskell Setup.hs.  Things like, the constraint solver behaves differently than cabal-install's
07:17:37 <Heffalump> what constraint solver?
07:17:43 <Heffalump> you mean runhaskell Setup.hs install?
07:17:43 <lispy_> To the point where I've broken packages by installing some one way and some the other day.
07:17:45 <lispy_> er, way
07:18:14 <Heffalump> you're still confusing two different things. If runhaskell Setup.hs makefile says that makefile isn't a valid argument, then runhaskell linked Setup.hs against a version of Cabal that doesn't support that option.
07:18:45 <Heffalump> if runhaskell Setup.hs install gets past the beginning but has trouble installing the underlying package, that's down to how the Cabal library that got chosen manages depenendencies itself.
07:19:58 * ezyang submits patch for GHC bug. \o/ 
07:20:06 <lispy_> I'm not confusing them.  I'm pointing out that mixing runhaskell Setup.hs with cabal-install in dangerous.
07:20:49 <lispy_> I don't know why Setup.hs resolves constraints differently than cabal-install, but it does.  I kind of assumed it was because it uses a different version of Cabal than cabal-install
07:21:55 <Heffalump> that would depend on what cabal-install was built with. But the issue with 'makefile is still nothing to do with the internals of Setup.hs itself, it's what runhaskell chooses to do.
07:22:12 <lispy_> does that command work for you?
07:22:54 <lispy_> Heffalump: http://hpaste.org/44745/aoeu
07:23:03 <lispy_> I use ghci just so we could see the versions of tihngs
07:23:39 <lispy_> Now search this page for 'makefile' http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/builders.html
07:24:18 <Heffalump> no (same version of Cabal
07:24:50 <Heffalump> ok, so probably a doc bug
07:24:58 <Heffalump> ISTR that command existed a long time ago
07:26:40 <Silvah> > mkStdGen 123
07:26:40 <lambdabot>   124 1
07:27:24 <Silvah> > if fst (randomR (0, 1) (mkStdGen 123)) == 0 then "fada" else "umlaut"
07:27:24 <lambdabot>   "umlaut"
07:28:12 <lispy_> Heffalump: actually, that is a weird because when I explicitly navigate to the latest release of cabal that command is no longer listed: http://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/users-guide/
07:28:53 <Heffalump> perhaps then -latest is a dev version
07:28:58 <Heffalump> or the symlink is out of date
07:29:26 <Heffalump> I think the symlink is to 1.8
07:29:31 <Heffalump> so I guess the code bit-rotted and was dropped
07:29:32 <lispy_> Yeah :(
07:29:33 <lispy_> So weird
07:29:35 <Athas> Is there a way to reduce the memory usage of ghci?  I only just started a project that is still no more than a few hundred lines of code, but ghci takes over 700MiB of memory...
07:29:43 <Heffalump> not really weird
07:30:39 <c_wraith> Athas: you can use unlimited memory with only one line.  You're probably doing something that results in a space leak.
07:30:53 <ezyang> pastie please 
07:31:16 <lispy_> I think it's weird that it's removed and I think it's weird that the version of Cabal that is in the HP isn't the 'latest' version of Cabal on the website.
07:31:55 <lispy_> I could understand it not being the latest if the HP version were OLDER than the stable release
07:32:06 <Athas> c_wraith: no, I'm only talking about loading my code.  It requires barely 100MiB after loading it only once, but after a few hours of development (where I don't actually run my code), it grows really huge.
07:32:13 <monadic_kid> I'm having problems getting more profile information in drawDynamicSprites function: http://hpaste.org/44746/get_more_profile_info
07:32:35 <lispy_> Cabal/cabal-install seem to be a very weird state where the blessed stable release in the HP is not actually a stable release (according to Duncan)
07:33:17 <Heffalump> it's just about having a gradual roll-out
07:33:21 <c_wraith> Athas: ah.  ghc doesn't unload unused code from memory.  every time you cause packages to be reloaded, it will use more memory.
07:33:21 <monadic_kid> my profile tells me drawDynamicSprites is taking ~40% of the time but all the children of that function i've annotated doesn't show anything signficant, it's only getting called like 11 times per-frame
07:33:51 <Heffalump> I actually raised a bug about that (ghc not unloading stuff) but then couldn't reproduce it with a small example
07:33:52 <lispy_> I don't see how putting it in the HP qualifies as a gradual roll out.
07:34:07 <Athas> c_wraith: ah.  Well, I can survive a reload every hour or so, I suppose.
07:34:23 <Heffalump> it's more gradual than putting it in the HP and getting existing installs to warn about ugprading
07:36:29 * lispy_ goes to sleep
07:36:35 <lispy_> I'll have to fight with cabal more later :(
07:50:41 * roconnor gathers more ammo into the anti-HP camp
07:51:00 <Heffalump> what would you do instead?
07:51:18 <Heffalump> I think for experienced users of Haskell, the HP is basically irrelevant
07:51:19 <roconnor> as opposed to HP?
07:51:31 <Heffalump> yes
07:52:02 <ezyang> Enh, I find HP a very convenient set of system libraries to fall back to when I have to nuke my .cabal/.ghc directories every once in a while. 
07:52:11 <roconnor> do exactly what we were doing before HP.  Ship GHC with cabal install.  Then I would finish the ongoing work to fix up cabal.
07:52:21 * roconnor head slap
07:52:44 <Heffalump> we never did ship GHC with cabal install before
07:52:49 <roconnor> oh
07:52:58 <Heffalump> but I agree, GHC+cabal-install is all experienced users need
07:53:04 <roconnor> in that case I'd ship GHC with cabal install
07:53:24 <roconnor> or maybe bundle GHC with cabal install and call it HP
07:53:31 <roconnor> however you want to name that
07:54:36 <monadic_kid> but HP is suppose to be a "batteries included" package
07:54:49 <monadic_kid> like ocaml batteries
07:55:07 <monadic_kid> included
07:55:20 <roconnor> monadic_kid: I agree that HP fulfills it's purpose.  But it's purpose is evil.
07:55:29 <monadic_kid> evil?
07:55:39 <roconnor> though like true evil it is subtle and people think it is good.
07:56:01 <Kaidelong> "languages ride platforms to success"
07:56:27 <roconnor> langagues ride platforms to stagnation
07:56:46 <ezyang> "that's how they get work done!" 
07:57:14 <pozic> roconnor: would you say Coq has stagnated?
07:57:38 <roconnor> pozic: coq libraries are stagnated.
07:58:12 <pozic> roconnor: but nothing is stopping anyone from starting a SCOQ.List library.
07:58:19 <roconnor> SSReflect's libraries are a major breakout of that stagnation.
07:58:41 <RowanDuffy> Should I learn SSReflect then? 
07:58:42 <roconnor> pozic: yes, but almost no one uses the SSReflect libraries.
07:59:02 <pozic> roconnor: perhaps because there is no documentation/no marketing?
07:59:05 <ezyang> I've always thought the libraries situation for proof assistants to be... uniquely different to programming languages. 
07:59:06 <roconnor> RowanDuffy: are you intrested in formalizing discrete math?
07:59:07 <Kaidelong> roconnor: No reason for the two to be mutually exclusive!
07:59:10 <Kaidelong> look at java
07:59:15 <Kaidelong> until very recently
07:59:18 <RowanDuffy> I'm more interested in software correctness. 
07:59:22 <Kaidelong> and even then just a little bit of motion
07:59:26 <Sir_Burpalot> Do any of you speak Arabic?
07:59:30 <Tyr42> Hello
07:59:40 <roconnor> Kaidelong: what to be mutally exclusive?
07:59:49 <Kaidelong> successful and stagnated
07:59:56 <roconnor> oh
08:00:23 <Kaidelong> I guess a haskell platform is nice so long as the haskell language is not innately tied to it
08:00:37 <roconnor> my only interest in the success of haskell is to get people to share new and better libraries
08:00:55 <roconnor> but if those libraries all use the mtl, then I will be very very sad.
08:01:07 <Kaidelong> roconnor: Then you're bound to have a huge code base that is easily broken in some or other place by every change in the language
08:01:38 <Kaidelong> I think how willing you are to break legacy code has more to do with it than anything else
08:01:49 <roconnor> Kaidelong: I rather that than bound to a small buggy code base that is impossible to change.
08:02:38 <pozic> roconnor: If I go to the website of ssreflect I cannot even say why I would want it.
08:02:46 <pozic> roconnor: see*
08:02:53 <roconnor> pozic: that's okay
08:02:57 <category> What's the mtl?
08:03:10 <roconnor> category: it was the first library for monad transformers.
08:03:37 <category> Aha,
08:03:54 <pozic> roconnor: the modules seem to be documented, so that's good. 
08:03:59 <roconnor> pozic: I'm not trying to sell you on SSreflect.
08:04:22 <pozic> roconnor: ok, let's approach this differently? What makes SSreflect interesting for you?
08:04:59 <roconnor> pozic: Well I work on the Mathematical Components project with Georges.
08:05:49 <roconnor> pozic: oh, maybe you want to know why you might want to use SSReflect libraries over the coq standard libraries.
08:06:19 <pozic> roconnor: yes, just you working on it, doesn't mean humanity has any use for it. 
08:06:19 <roconnor> pozic: SSReflect libraries are to a large extent based on decidable predicates of the form A -> bool
08:06:39 <roconnor> pozic: such predicates are nice because they are computable
08:06:53 <Tyr42> Hey, I don't mean to interrupt, but is anyone else having trouble running cabal install cabal-install for the most recent update?
08:06:56 <roconnor> pozic: which means a lot of "reasoning" can be done by evaluation.
08:07:20 <roconnor> pozic: so if you are working in a domain full of decidable predicates, this library might have a lot of useful functionality for you.
08:07:41 <roconnor> pozic: if you are working in a domain full of undecidable predicates, then maybe the SSReflects are not that helpful.
08:07:51 <Heffalump> Tyr42: what trouble?
08:08:03 <pozic> roconnor: if I know a certain predicate is true and is provable in Coq, then SSReflect is applicable?
08:08:14 <pozic> roconnor: that seems pretty wide.
08:08:36 <roconnor> pozic: if you have a decision procedure for deciding if a predicate is true on a given input, then SSReflect is applicable.
08:08:38 <monadic_kid> adding call sites isn't showing me anything significant for drawDynamicSprites: http://hpaste.org/44746/get_more_profile_info
08:08:39 <Tyr42> Heffalump: undefined reference to `rtsTimerSignal'
08:09:03 <Tyr42> Heffalump:In function `spzw_info'
08:09:32 <Tyr42> Heffalump:  When building Cabal-1.10
08:09:58 <pozic> roconnor: this is too vague, I will just read the tutorial.
08:10:05 <roconnor> ??
08:10:09 <Heffalump> what version of GHC are you starting from?
08:10:11 <roconnor> pozic: do you know what a predicate is?
08:10:34 <Tyr42> 6.12.1
08:10:41 <roconnor> having a decision procedure for a predicate is a very precise notion.
08:11:05 <Tyr42> which is what is in the apt repo
08:11:22 <Tyr42> I am running ubuntu btw
08:11:49 <roconnor> it means you can implement the function as a function to Bool.
08:11:51 <pozic> roconnor: yes
08:12:18 <pozic> roconnor: is it whether one _can_ or whether one _has_?
08:12:39 <pozic> roconnor: I said _can_ first, and then you said 'no'.
08:13:14 <roconnor> pozic: right, you have to have such a procedure.
08:13:34 <roconnor> so for example, odd :: Nat -> Bool is a nice decidable predicate
08:14:48 <roconnor> allTrue :: [Bool] -> Bool isn't dedicable.  We can't implement this function in Haskell.
08:15:53 <pozic> roconnor: if the list is finite, you can. 
08:16:09 <roconnor> ha right
08:16:15 <roconnor> I was thinking streams
08:16:48 <roconnor> allTrue :: (Nat -> Bool) -> Bool isn't dedicable.  We can't implement this function in Haskell.
08:16:48 <mreh> @hoogle [(a,b)] -> ([a],[b])
08:16:48 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
08:16:48 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
08:18:30 <Kaidelong> allTrue = undefined
08:18:48 <Kaidelong> or rather
08:18:51 <roconnor> Kaidelong: I'm implying a certain specification
08:18:51 <Kaidelong> const undefined
08:19:46 <pozic> roconnor: for embedded devices, you can decide basically everything. So, how does SSReflect scale for that case?
08:20:04 <roconnor> pozic: it would probably work very well for that case.
08:20:20 <Kaidelong> there are some things you can prove for all natural numbers though
08:20:26 <Kaidelong> IE congruence to 0 mod 1
08:20:47 <pozic> roconnor: why would it work better than just state transitions (which is intractable)?
08:21:28 <Kaidelong> although I suppose making some general way to prove anything for all the natural numbers just having a test Nat -> Bool would be impossible
08:21:46 <roconnor> I mean, that the SSReflect library might be useful for that domain.  You still have a wide range of formalization options for your embedded device.
08:22:16 <roconnor> Kaidelong: you can decide if (f 1) = True or not.
08:26:15 <Tyr42> So, can everyone else compile Cabal no problem?
08:26:53 <ManateeLazyCat> Tyr42: Compile Cabal? Why you need do that? Cabal package has include in GHC, you really need is cabal-install
08:26:58 <ManateeLazyCat> @hackage cabal-install
08:26:59 <lambdabot> http://hackage.haskell.org/package/cabal-install
08:27:46 <Tyr42> I'm updating cabal install, by running `cabal install cabal-install`
08:27:49 <Tyr42> and it's failing
08:28:14 <Tyr42> And it's Cabal that's not linking
08:28:30 <Tyr42> with an undefined reference to `rtsTimerSignal'
08:28:35 <Tyr42> In function `spzw_info'
08:28:42 <Tyr42> When building Cabal-1.10
08:28:45 <Heffalump> Tyr42: might be worth updating to 6.12.3, or 7.0.x
08:30:01 <Tyr42> ok, how would I do that?  I tried apt-get install ghc, and it says it's up to date
08:30:19 <Tyr42> I don't normally use anything other than apt-get
08:30:30 <Heffalump> ah, hmm. In that case why do you want to install a new cabal-install?
08:30:33 <ManateeLazyCat> Tyr42: Which version your ghc-6.12.3?
08:30:46 <Heffalump> Tyr42 has 6.12.1 (which comes with Debian I think)
08:30:50 <ManateeLazyCat> Tyr42: You just need install new cabal-install when you installed *new* version GHC.
08:31:22 <ManateeLazyCat> Tyr42: If you have ghc-6.12.1, you don't need "cabal install cabal-install" except you want to install newer version ghc, such as ghc-7.0.2
08:31:46 <Tyr42> ok
08:32:10 <Tyr42> I was also trying to build nikki and the robots (http://joyridelabs.de/game/)
08:32:23 <mreh> @hoogle a -> a -> Bool -> a
08:32:24 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
08:32:24 <Tyr42> and it was also trying to install Cabal-1.8
08:32:24 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
08:32:24 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
08:32:31 <Tyr42> which was failing in the same way
08:32:39 <Heffalump> it does still sound like something's wrong
08:33:56 <monadic_kid> i think you might have headaches trying to build nikki and the robots, it depends on Qt and building the qt haskell bindings is a pain in the ass if you can get it working at all
08:34:00 <Heffalump> I don't have a squeeze install to hand
08:34:12 <mreh> > toEnum True
08:34:12 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:34:13 <lambdabot>         against inferred type ...
08:34:25 <mreh> > fromEnum True
08:34:26 <lambdabot>   1
08:34:29 <mreh> > fromEnum False
08:34:30 <lambdabot>   0
08:34:32 <mreh> neat
08:34:57 <Tyr42> Well, I already worked through a few issues with the external dependencies, and I want to get it running
08:35:10 <ManateeLazyCat> Oh, crap Android framework, i don't want to play, go to sleep ...
08:35:58 <monadic_kid> yeah someone needs to write haskell bindings to android NDK :P
08:36:52 <Heffalump> Tyr42: you can install a later GHC/HP by downloading a binary tarball from the GHC website, or by using the experimental Debian repo for Haskell
08:37:05 <Tyr42> alright
08:37:11 <Tyr42> I'm going to try that second option
08:37:17 <ManateeLazyCat> monadic_kid: Crap android, i don't want  use it even through Haskell.
08:37:34 <Heffalump> if anyone else around has a squeeze install, it would be interesting to know what cabal install Cabal does.
08:38:02 <ManateeLazyCat> Tyr42: First, try command "ghc-pkg check"
08:38:13 <ManateeLazyCat> Tyr42: Then you know which package break.
08:38:13 <Heffalump> yes, good point
08:38:18 <Heffalump> well, you mgiht know
08:40:03 <Tyr42> "There are problems in package ConfigFile-1.0.6:
08:40:03 <Tyr42>   dependency "MissingH-1.1.0.3-fef9e3588b65015550d82ddc7f1c6c47" doesn't exist
08:40:03 <Tyr42> "
08:40:13 <Tyr42> what?
08:40:27 <Tyr42> from ghc-pkg check
08:40:36 <Heffalump> that's a problem, but it won't be causing the symptoms you describe above
08:42:57 <pozic> <command line>: cannot satisfy -package Cabal-1.10.0.0: 
08:42:58 <pozic>     Cabal-1.10.0.0-30b3f082077a2793c432ea426276c8f9 is unusable due to missing or recursive dependencies:
08:43:00 <pozic>       process-1.0.1.4-b476e45706840d55749b12ebe18dc835
08:43:03 <pozic>     (use -v for more information)
08:43:07 <pozic> Heffalump: that's what I get
08:43:21 <pozic> Pretty epic failure 
08:46:37 <Heffalump> that's sad :-(
08:48:19 <pozic> Heffalump: if you first install Cabal, it does work. The dependencies of cabal-install are just wrong.
08:48:39 <pozic> It seems pretty amazing one can get the dependencies wrong for such a simple program.
08:50:02 <Tyr42> A more complete error if that helps
08:50:33 <Tyr42> here:  /home/theo/.cabal/lib/unix-2.4.2.0/ghc-6.12.1/libHSunix-2.4.2.0.a(Signals.o): In function `spzw_info':
08:50:33 <Tyr42> (.text+0x4d14): undefined reference to `rtsTimerSignal'
08:50:52 <pozic> cabal-install cabal-install also keeps compiling stuff if you run it again and again.
08:51:00 <pozic> It should say 'foo is already installed'.
08:51:09 <pozic> Two epic failures in 5 minutes. 
08:53:03 <roconnor> Tyr42: let me know if you build nikki and the robots.
08:53:23 <Twey> preflex: zdec zw
08:53:23 <preflex>  zw
08:54:10 <Tyr42> roconnor:  Sure
08:56:48 <Tyr42> hey, would it be safe to try and reduce the version of Cabal required in nikki.cabal, and see if the still compiles?
08:57:22 <Heffalump> well,it won't destroy anything
08:57:44 <Tyr42> how do I see what version of Cabal I have now?
08:58:18 <Heffalump> ghc-pkg list
08:58:56 <Tyr42> what, I have Cabal 1.8.0.2
08:59:05 <Tyr42> why is it trying to rebuild it then
08:59:21 <Tyr42> it only requires >= 1.8
09:00:17 <Tyr42> going from 1.8.0.2 to 1.8.0.4 wouldn't seem to change much
09:00:30 <Tyr42> why does it try and build Cabal then
09:02:02 <Tyr42> Wait, it's trying to build 1.8.0.2
09:02:08 <Tyr42> which is what I already have
09:02:10 <Tyr42> I though
09:02:13 <Tyr42> thought
09:02:13 <Heffalump> probably some underlying dependency it thinks is different
09:02:51 <Tyr42> can I tell it to skip trying to build Cabal and use the one I have?
09:02:58 <Heffalump> if Cabal depends on foo, and something else in nikki directly or independently depends on some version of foo that's not already installed, then Cabal will need to be rebuilt against that foo too
09:03:20 <Tyr42> is this some issue with usr libs vs system libs?
09:03:22 <Heffalump> try cabal install nikki --dry-run and see what else it is trying to install that you already have
09:03:51 <Tyr42> Cabal-1.8.0.2
09:03:51 <Tyr42> bindings-libzip-0.1.0.2
09:03:51 <Tyr42> LibZip-0.2.0.1
09:03:51 <Tyr42> cabal-macosx-0.1.1
09:03:51 <Tyr42> nikki-0.2.18
09:04:32 <Tyr42> Oh I see:  Cabal-1.8.0.2 (reinstall) changes: unix-2.4.0.0 -> 2.4.2.0
09:05:32 <Heffalump> I wonder if unix 2.4.2.0 just doesn't work with the GHC you hve
09:05:54 <Heffalump> what happens if you try cabal install --constraint 'unix==2.4.0.0' ? It'll probably tel you about some constraint that's violated.
09:07:08 <Tyr42> something's happening
09:07:28 <Tyr42> I think that helped
09:08:25 <Tyr42> oh, wait, now it's trying to build Cabal
09:08:32 <Tyr42> and it worked
09:08:48 <Tyr42> oh good
09:09:24 <Tyr42> not
09:09:43 <Heffalump> do it again with the --constraint and the --dry-run
09:10:15 <monadic_kid> when ghc outputs a time profile, does the alloc% column represent percentage of allocation time or percentage of allocations for a program?
09:10:34 <Heffalump> percentage of allocations AFAIK
09:11:13 <monadic_kid> if that is the case then my profile is not making much sense
09:11:44 <Tyr42> I'm trying it while reducing the version of unix required in nikki.cabal to 2.4.0.0
09:12:24 <Tyr42> and it looks like it would try and rebuild Cabal anyways
09:12:33 <Tyr42> along with a lot of other stuff
09:12:35 <emartinj> I have a problem with a segfaulting ffi binding to a C library that I'm unable to solve. 
09:13:02 <Tyr42> well, I'll try it anyways
09:14:37 <Tyr42> nope, doesn't work
09:16:33 <Tyr42> Oh well, I suppose I'll just have to wait until they release a binary
09:21:24 <Jesin> hmm
09:21:30 <Jesin> is there a nice method with cabal
09:21:42 <Jesin> to check whether you have the latest versions of all your packages
09:21:48 <Jesin> and upgrade those that are outdated?
09:21:55 <Jesin> :p
09:22:05 <c_wraith> ....  the command that used to do that was removed because it often broke everything
09:22:05 * hackagebot bounded-tchan 0.2 - Bounded Transactional channels (queues)  http://hackage.haskell.org/package/bounded-tchan-0.2 (ThomasDuBuisson)
09:22:09 <aavogt> that's what cabal upgrade is supposed to do
09:22:37 <Jesin> well
09:22:40 <Jesin> fine
09:22:47 <Jesin> not upgrade all of them, then
09:22:52 <Jesin> but just check whether they're outdated?
09:23:01 <hpc> cabal update?
09:23:30 <Jesin> hm
09:23:37 <Jesin> does that notify you of any updated versions?
09:23:57 <Jesin> like, on stdout or stderr
09:24:05 <c_wraith> not that I'm aware of
09:24:10 <Jesin> or does it just fetch the information and quietly hide it away =/
09:24:12 <Jesin> ok
09:24:13 <hpc> i know it downloads a file with all the version numbers
09:24:15 <Jesin> hm
09:24:23 * hpc hasn't used cabal in forever
09:24:30 <Jesin> does it diff them with current version numbers
09:24:32 <Jesin> :p
09:24:35 <Jesin> rawr.
09:24:39 <Jesin> $ cabal upgrade
09:24:41 <Jesin> cabal: Use the 'cabal install' command instead of 'cabal upgrade'.
09:24:42 <Jesin> You can install the latest version of a package using 'cabal install'. The
09:24:44 <Jesin> 'cabal upgrade' command has been removed because people found it confusing and
09:24:45 <Jesin> it often led to broken packages.
09:24:47 <Jesin> If you want the old upgrade behaviour then use the install command with the
09:24:49 <Jesin> --upgrade-dependencies flag (but check first with --dry-run to see what would
09:24:50 <Jesin> happen). This will try to pick the latest versions of all dependencies, rather
09:24:52 <Jesin> than the usual behaviour of trying to pick installed versions of all
09:24:53 <Jesin> dependencies. If you do use --upgrade-dependencies, it is recommended that you
09:24:53 <djahandarie> ...
09:24:55 <Jesin> do not upgrade core packages (e.g. by using appropriate --constraint= flags).
09:24:59 <Jesin> so
09:25:00 <c_wraith> yikes.  please don't paste that much
09:25:04 <Jesin> sorry...
09:25:05 <Jesin> =/
09:25:10 <Jesin> um
09:25:12 <HugoDaniel> jesin use hpaste.org
09:25:15 <Jesin> right
09:25:24 <Jesin> got careless, didn't realize it was that big
09:25:26 <Jesin> sry about that
09:25:28 <Jesin> ...
09:25:31 <Jesin> hm.
09:25:32 <HugoDaniel> no prob.
09:25:33 <Jesin> but
09:25:37 <Jesin> what does --upgrade-dependenceis
09:25:42 <Jesin> *what does --upgrade-dependencies
09:25:44 <Jesin> do
09:25:49 <djahandarie> I think your enter key is being fired at a rapid rate also.
09:25:56 <Jesin> :(
09:25:58 <Jesin> habit
09:26:01 <Jesin> should try to break it
09:26:02 <hpc> Jesin: say you have foo version 2.0 and bar version 1.5
09:26:12 <hpc> Jesin: and foo version 3.0 just came out, but requires bar version 2.0
09:26:18 <Jesin> or higher?
09:26:20 <Jesin> or what
09:26:26 <hpc> Jesin: --upgrade-dependencies will upgrade foo to 3.0 and bar to 2.0
09:26:31 <hpc> without the flag, it only upgrades foo
09:26:45 <Jesin> even if it *requires* bar >= 2.0?
09:26:48 <Jesin> that sounds broken
09:26:51 <hpc> or tries to, and fails because you don't have bar at the right version
09:26:57 <hpc> :P
09:27:07 <Jesin> no, it would get that in dependency resolution, wouldn't it?
09:27:14 <Jesin> ...hmm
09:27:32 <Jesin> is it possible to have more than one version of a package installed at once?
09:28:02 <Heffalump> yes
09:28:35 <roconnor> Jesin: it isn't possible to install the save version of a package twice though :/
09:28:38 <roconnor> yet
09:28:54 <Jesin> wait, "save version"?
09:28:59 <roconnor> *same
09:29:02 <roconnor> sorry
09:29:21 <kmc> emartinj, any luck with your FFI problem?
09:30:25 <kmc> emartinj, what was the problem?
09:33:13 <c_wraith> ugh.  Ok, I want superclass equality constraints now.
09:33:46 <roconnor> c_wraith: lets write our own haskell report
09:34:12 <c_wraith> roconnor: GHC already has syntax for 'em.  It just doesn't work yet. :(
09:34:19 <roconnor> :(
09:34:44 <Heffalump> I hear they're supposed to be in 7.2
09:35:00 <Heffalump> I really want them as I'm currently simulating them with a class member to witness the equality.
09:35:20 <dolio> You could run one of the 7.0.1 RCs. :)
09:35:23 <dolio> They were in there.
09:35:26 <dolio> Then they were out.
09:35:27 <Heffalump> they were?
09:35:30 <Heffalump> how come?
09:35:40 <dolio> Didn't work right yet somehow.
09:35:49 <dolio> I don't know the specifics.
09:36:17 <Jesin> ...
09:36:18 <bss03> Twey: CReals aren't Rationals inside.  They are memoized contiuations/thunks inside.
09:36:22 <Jesin> http://hackage.haskell.org/packages/archive/functors/0.1/doc/html/src/Data-Functor-Syntax.html
09:36:24 <Jesin> THERE it is
09:36:27 <Jesin> XD
09:36:36 <Twey> bss03: *nod*
09:36:48 <c_wraith> I could go back to fundeps.  But that became an incredible mess, and I couldn't get them to work with GeneralizedNewtypeDeriving in the obvious way.
09:36:57 <aavogt> bss03: are they really memoized? Sometimes a constant will be needed at two different precisions
09:37:14 <dolio> CReals are Int -> Integer.
09:37:49 <mercury^> What does c n represent then?
09:37:51 <bss03> aavogt: AFAIK, the underlying library does memoization, but I could be wrong.
09:38:08 <Heffalump> c_wraith: fundeps don't give you type equality anyway
09:38:26 <Heffalump> i.e. even if the fundep proves a = b, you don't get a free coercion
09:38:32 <dolio> Something like c n / 2^n <= r <= (1 + c n) / 2^n
09:38:33 <c_wraith> Heffalump: well, they kind of do with FlexibleInstances..
09:38:37 <bss03> mercury^: c n * (2 ^ -n) = "c" +/- 1 * (2 ^ -(n+1))
09:38:40 <dolio> Where r is the real you're approaching.
09:38:50 <Heffalump> how?
09:38:54 <c_wraith> Heffalump: oh, I see what you're saying.  yeah, they don't
09:39:45 <c_wraith> Still, I've got the entire structure I want working with fundeps, except that I can't use GeneralizedNewtypeDeriving where I want to.
09:40:16 <bss03> mercury^: So higher values passed into the function give more bits of the number.
09:42:02 <bss03> Twey: So, can you see why they can't be converted to Rational?  There's no "correct" choice of denominator.
09:42:37 <bss03> I do wish approxRational worked on them, but it is not part of the typeclass and implemented in terms of toRational. :(
09:42:54 <bss03> > toRational (1 :: CReal)
09:42:54 <Twey> bss03: Yeah.  I figured that out about two seconds after I considered it.  :þ
09:42:55 <lambdabot>   *Exception: CReal.toRational
09:43:31 <bss03> Twey: Okay, was just scanning history and didn't see you get any clarification.  I must have missed it.
09:43:50 <Twey> Ah, no, someone else pointed it out and I did a facepalm.  ☺
09:44:31 <aavogt> well this is the same issue about how there's a  Show CReal instance
09:45:00 <aavogt> but they wrote that one
09:45:33 <aavogt> @ty showsPrec 
09:45:34 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
09:45:51 <aavogt> > showsPrec 5 (pi::CReal) ""
09:45:52 <lambdabot>   "3.1415926535897932384626433832795028841972"
09:48:15 <c_wraith> Oh, I see.  I can't get GeneralizedNewtypeDeriving to work just because there are higher-kinded types involved.  Blah.
09:48:19 <HugoDaniel> oh
09:48:28 <Jesin> [13:26:26]	<bss03>	I do wish approxRational worked on them, but it is not part of the typeclass and implemented in terms of toRational. :(
09:48:30 <HugoDaniel> category-extras doesnt build in ghc 7 :(
09:48:34 <Jesin> that seems so broken
09:48:36 <Jesin> lol
09:48:43 <Jesin> the Real typeclass
09:48:43 <c_wraith> HugoDaniel: category-extras is deprecated anyway
09:48:46 <Jesin> has toRational
09:48:46 <HugoDaniel> ah
09:48:47 <HugoDaniel> i see
09:48:50 <Jesin> as a required method
09:48:51 <HugoDaniel> what should i use instead ?
09:49:03 <Jesin> hmm
09:49:07 <Jesin> it depends on what you need from it
09:49:10 <c_wraith> HugoDaniel: edwardk broke it into a bunch of different packages.
09:49:11 <Jesin> comonads-fd
09:49:22 <Jesin> adjunctions
09:49:40 <HugoDaniel> oh
09:49:44 <Jesin> etc
09:49:45 <HugoDaniel> i just need the either monad
09:49:58 <c_wraith> ...  GHC 7 provides that in the prelude, anyway
09:50:09 <c_wraith> err, not the prelude.
09:50:11 <c_wraith> In base
09:50:16 <c_wraith> Control.Monad.Instances
09:51:11 * hackagebot text-icu 0.6.3.3 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.3.3 (BryanOSullivan)
09:51:43 <mercury^> In what way is Either a monad?
09:51:46 <c_wraith> I wouldn't need any higher-kinded types with type families and superclass equality, though.  Bah.
09:52:13 <Eduard_Munteanu> I think edwardk was going to make a package that imports all the others.
09:52:50 <Jesin> or requires
09:52:56 <HugoDaniel> oh cool
09:53:01 <c_wraith> return = Right ; (Left a) >>= _ = Left a ; (Right a) >>= f = f a
09:53:15 <HugoDaniel> im sick of these case inside case inside case :/
09:53:20 <hpc> c_wraith: and fail?
09:53:30 <Twey> HugoDaniel: Use more monads
09:53:33 <c_wraith> hpc: ignore fail.  That's the only correct implementation.
09:53:36 <hpc> :P
09:53:45 <Jesin> fail = Left
09:53:47 <Jesin> I think
09:53:49 <Jesin> :p
09:53:54 <hpc> can't, Jesin
09:53:56 <Twey> Nope
09:53:59 <Twey> Wrong type
09:54:00 <Jesin> @src mplus Either
09:54:00 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:54:14 <Jesin> ...
09:54:17 <Jesin> wrong type
09:54:18 <Jesin> ok
09:54:20 <Twey> fail = Left would constrain all Eithers to be Either String :þ
09:54:23 <Jesin> yeah
09:54:31 <Jesin> fail _ = Left undefined
09:54:34 <Jesin> then
09:54:38 <Twey> That works
09:54:41 <Jesin> or
09:54:43 <Twey> FSVO
09:55:01 <c_wraith> "for some value of"?
09:55:05 <ion> fail = Left . unsafeCoerce
09:55:06 <ion> ;-)
09:55:11 <Jesin> fail _ = Left $ error "Either.fail: sensical implementations don't work so let's go with this one"
09:55:16 <Jesin> :p
09:55:33 <Twey> Yeah, that's the way :þ
09:55:36 <c_wraith> Why bother wrapping it in left, then?
09:55:47 <Eduard_Munteanu> 'fail' doesn't really belong in Monad, so why bother.
09:55:52 <Twey> Or, y'know, just fail = Left . error
09:55:59 <Jesin> ooh
09:55:59 <Twey> c_wraith: Laziness
09:56:02 <c_wraith> or just "error"
09:56:04 <Twey> That way you can match against the failure
09:56:12 <Twey> So long as you don't care what's in it, you can still use it
09:56:13 <hpc> :t error
09:56:14 <lambdabot> forall a. [Char] -> a
09:56:36 <Jesin> fail = Left . error . ("Either.fail: " ++)
09:56:46 <Jesin> :t fail
09:56:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:57:06 <Jesin> also
09:57:07 <kmc> c_wraith, maybe it will work with StandaloneDeriving?
09:57:08 <Jesin> [13:39:54]	<Twey>	That way you can match against the failure
09:57:14 <Jesin> yes, that's what I was thinking
09:57:15 <Jesin> but
09:57:25 <c_wraith> kmc: doubtful, it's not a standard typeclass
09:57:26 <Twey> c_wraith: E.G. case someEitherComputation of Right v -> use v; Left _ -> die horribly
09:57:30 <Jesin> when is fail even *invoked*?
09:57:39 <Twey> Jesin: Pattern-match failures in do-notation
09:57:50 <kmc> c_wraith, it works with newtype deriving, and lets you give an explicit instance context and head
09:57:51 <bss03> Jesin: Agreed, but it think it was a pragmatic / historic thing.  Sort of like fail in the Monad typeclass.
09:57:51 <Jesin> @src mplus Either
09:57:51 <lambdabot> Source not found. Wrong!  You cheating scum!
09:57:52 <hpc> Jesin: do Left wrongBad <- Right happyGood
09:58:06 <c_wraith> kmc, oh, hmm.  I'll see what happens if I dry that
09:58:06 <Jesin> @src (->) (>>=)
09:58:07 <lambdabot> f >>= k = \ r -> k (f r) r
09:58:12 <Jesin> @src Either mplus
09:58:12 <aavogt> @undo do Just a <- x; return a
09:58:13 <lambdabot> Left _ `mplus` n = n
09:58:13 <lambdabot> m      `mplus` _ = m
09:58:13 <lambdabot> x >>= \ b -> case b of { Just a -> return a; _ -> fail ""}
09:58:23 <Jesin> @src Either mzero
09:58:24 <lambdabot> mzero            = Left noMsg
09:58:31 <Jesin> @src noMsg
09:58:32 <hpc> :t noMsg
09:58:32 <lambdabot> Source not found. I feel much better now.
09:58:32 <lambdabot> forall a. (Error a) => a
09:58:39 <hpc> @src Either noMsg
09:58:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:58:49 <Jesin> > noMsg
09:58:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:58:50 <lambdabot>    `Control.Monad.Trans.Err...
09:58:55 <Jesin> > noMsg :: Either String
09:58:56 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
09:58:58 <hpc> > noMsg :: String
09:58:58 <lambdabot>   ""
09:59:01 <Jesin> > noMsg :: Either String String
09:59:02 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error
09:59:02 <lambdabot>                     (Data....
09:59:03 <hpc> > noMsg :: Maybe Int
09:59:04 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error
09:59:04 <lambdabot>                     (Data....
09:59:09 <Jesin> > noMsg :: Int
09:59:10 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error GHC.Types.Int)
09:59:10 <lambdabot>    arising ...
09:59:16 <Jesin> > noMsg :: [Integer]
09:59:17 <hpc> @instances Error
09:59:17 <lambdabot>   No instance for (Control.Monad.Trans.Error.ErrorList
09:59:17 <lambdabot>                     GH...
09:59:30 <hpc> @help instances
09:59:30 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
09:59:33 <Jesin> @instances Error
09:59:38 <hpc> ...
09:59:42 <Jesin> why isn't
09:59:44 <Jesin> what
09:59:45 <Jesin> ...
09:59:57 <c_wraith> kmc: doesn't look like StandaloneDeriving is particularly happy with MPTCs
10:00:06 <aavogt> @instances-importing Control.Monad.Error Error
10:00:24 <aavogt> @bot
10:00:25 <lambdabot> :)
10:00:30 <Jesin> http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Error.html
10:00:31 <aavogt> @instances-importing Error Control.Monad.Error
10:00:32 <lambdabot> Couldn't find class `Control.Monad.Error'. Try @instances-importing
10:00:43 <hpc> @vixen Y U NO INSTANCES
10:00:44 <lambdabot> Guys who can speak latin really turn me on.
10:00:50 <hpc> oh, okay
10:01:10 <Jesin> @instances MonadPlus
10:01:10 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:01:24 <kmc> oh c_wraith :/
10:02:25 <c_wraith> With type families, these classes wouldn't be multi-parameter.  But I'm pretty sure I'd need superclass equality to make this work...  So I'm stuck there
10:02:52 <Jesin> hmm...
10:03:18 <mreh> @vixen Y U NO STUDY LATIN
10:03:19 <lambdabot> I have a boyfriend, but he likes to watch.
10:03:33 <Jesin> I kind of wonder why the standard library has
10:03:39 <Jesin> instance Monoid a => Applicative ((,) a) where
10:03:40 <Jesin>         pure x = (mempty, x)
10:03:42 <Jesin>         (u, f) <*> (v, x) = (u `mappend` v, f x)
10:03:44 <Jesin> but not
10:03:52 <monochrom> @vixen 我懂拉丁文
10:03:52 <lambdabot> Yes
10:04:02 <djahandarie> Haha
10:04:13 <monochrom> @vixen 你懂拉丁文嗎
10:04:13 <lambdabot> Yeah
10:04:24 <emartinj> Are there any known problems with addForeignPtrFinalizer or newForeignPtr on windows?
10:04:44 <mreh> @vixen Deoxyribonucleic-acid?
10:04:44 <lambdabot> good question
10:04:51 <Jesin> instance Monoid a => Monad ((,) a) where
10:04:53 <Jesin>   return = (,) mempty
10:04:55 <Jesin>   (a1,x1) >>= f = let (a2,x2) = f x1 in (a1 `mappend` a2, x2)
10:05:13 <monochrom> @vixen 你自相矛盾嗎?
10:05:13 <lambdabot> i think you know the answer to that one, silly
10:05:18 <Jesin> that's the Writer monad I think, from which that Applicative instance is derived
10:05:31 <monochrom> hrm, I conclude that she actually knows Chinese!
10:05:41 <mreh> @vixen De gustibus non est disputandum
10:05:41 <lambdabot> i drive a pickup truck
10:05:45 <mreh> lol
10:06:02 <hpc> @vixen your pickup truck is now diamonds!
10:06:02 <lambdabot> No pic, sorry
10:08:12 <Jesin> um, does anyone have any idea why...?  :p
10:21:24 <jonkri> is it a bug that a call to "myFunction x y = myFunction x y" crashes my system?
10:21:46 <aristid> jonkri: crash? you mean that the program cancels with <<loop>>?
10:21:49 <hpc> > let f x y = f x y in f 1 2
10:21:53 <lambdabot>   mueval-core: Time limit exceeded
10:22:08 <jonkri> aristid: no, i mean complete freeze. fedora, ghc
10:22:17 <Jesin> may be a space leak
10:22:28 <hpc> how long did you let it run?
10:22:30 <ion> jonkri: You probably have a hardware problem. Improper CPU cooling for instance.
10:22:39 <jonkri> hpc: maybe three-four seconds?
10:22:54 <hpc> me tries
10:22:54 <jonkri> ion: oh :(
10:22:58 <ion> s/Improper/Inadequate/
10:23:23 <ion> I take it cpuburn causes the same thing?
10:23:24 <greg_72> hi there, what is a proper type-theoretic formulation on what a normal datatype definition can contain, and what a GADT allows over this?
10:23:37 <hpc> i get constant memory use and 100% cpu use
10:24:00 <jonkri> i have a core 2 duo...
10:24:22 <jonkri> i cannot verify it now, i was just curious
10:24:30 * monochrom wonders how "complete" is a "complete freeze"
10:24:56 <jonkri> monochrom: i don't think i could enable caps lock and stuff
10:25:10 <monochrom> how do you irc then? from another computer?
10:25:19 <jonkri> monochrom: this was the other day
10:26:09 <monochrom> hardware problem is the most likely. OS problem is the second most likely.
10:27:04 <monochrom> indeed, once upon a time, some computers could run windows 3.1 fine but would fail on OS/2. hardware under-spec.
10:27:27 <monochrom> e.g., as simple as RAM errors.
10:27:45 <bss03> Jesin: You didn't provide a complete Monad instance for  Monoid a => ((,) a).
10:27:56 <bss03> Jesin: What about "fail"? >:)
10:28:13 <Jesin> bss03: that has a default definition
10:28:59 <bss03> Jesin: Then probably just oversight?
10:29:07 <Jesin> fail = error
10:29:27 <Jesin> it would be fail _ = mzero
10:29:41 <Jesin> if ((,) a) had a sensible mzero
10:29:54 <Jesin> but I don't think it does
10:32:36 <Saizan> greg_72: basically a gadt constructor can take additional types and type equalities as arguments
10:33:09 <bss03> fail s = (mempty, error s)?
10:33:26 <parcs> what is the data type for a signed 32-bit integer?
10:33:38 <Jesin> bss03: no, that still collects context information
10:33:53 <Jesin> I don't think that's supposed to happen
10:35:25 <bss03> parcs: Data.Int.Int32?
10:35:45 <parcs> bss03: thanks. i just found that through google as well
10:36:48 <Jesin> hm
10:37:13 <Jesin> what are the laws for Alternative, besides that (<|>) is associative and has empty as an identity element?
10:37:33 <colbseton`> hello, i'm new in haskell world and i would make a program wich uses monads (Maybe, List or Either). I have no idea, can you give me it (for beginners) ? thanks
10:37:41 <Jesin> and, why are they not in the documentation for the Alternative typeclass?
10:37:41 <colbseton`> which*
10:38:08 <revenantphx> colbseton`: As a suggestion from a fellow learner,
10:38:11 <revenantphx> don't focus on "learning monads"
10:38:19 <revenantphx> just learn haskell and you'll see them as you go.
10:38:58 <Jesin> ^ that.
10:39:02 <revenantphx> But, if you're insistent, maybe play with List for some sort of simplified query system.
10:39:18 <revenantphx> (using filter and some basic tuple association lists)
10:39:21 <revenantphx> idk, might be fun.
10:40:08 <revenantphx> But really, just… use haskell. You'll see monads, whether you realize it or not.
10:40:40 <Jesin> ooh!
10:40:46 <Jesin> foldr is also good to understand
10:40:51 <Jesin> :)
10:40:55 <bss03> > do { x <- [1...]; guard $ x < 10; return x ^ 2; }
10:40:56 <lambdabot>   A section must be enclosed in parentheses thus: (1 ...)Not in scope: `...'
10:41:00 <colbseton`> ok revenantphx i think you're right
10:41:03 <bss03> > do { x <- [1..]; guard $ x < 10; return x ^ 2; }
10:41:05 <lambdabot>   No instance for (GHC.Num.Num [b])
10:41:05 <lambdabot>    arising from a use of `e_11102' at <in...
10:41:20 <Jesin> :t guard
10:41:21 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:41:24 <Jesin> oh
10:41:33 <Jesin> > do { x <- [1..]; guard $ x < 10; return $ x ^ 2; }
10:41:37 <lambdabot>   mueval-core: Time limit exceeded
10:42:36 <bss03> > do { x <- [1..100]; guard $ x < 10; return $ x ^ 2; }
10:42:37 <lambdabot>   [1,4,9,16,25,36,49,64,81]
10:43:00 <djahandarie> colbseton`, if you are interested in learning about certain typeclasses, try out using Functor first. It's much simpler and helps you build up to what you need for Monad.
10:43:31 <LambdaLoop> hello, i was wondering how to make state/io monad
10:43:32 <djahandarie> Also learning exactly what typeclasses are is fairly critical to understand any of them. :)
10:43:46 <LambdaLoop> so i could get input and change the state
10:44:03 <bss03> > fmap (^ 2) $ Just 5
10:44:04 <lambdabot>   Just 25
10:44:08 <bss03> > fmap (^ 2) $ Nothing
10:44:09 <lambdabot>   Nothing
10:44:24 <bss03> > fmap (^ 2) $ Right 6
10:44:24 <Jesin> the IO monad is built in
10:44:25 <lambdabot>   Right 36
10:44:30 <aristid> > map (^ 2) . filter (< 10) $ [1 .. 100]
10:44:32 <lambdabot>   [1,4,9,16,25,36,49,64,81]
10:44:37 <aristid> ^ bss03 :)
10:44:40 <aavogt> simpler is probably type classes like Monoid which has the type variable with kind *
10:44:49 <aavogt> :t fmap
10:44:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:44:58 <aavogt> :t mappend
10:44:59 <lambdabot> forall a. (Monoid a) => a -> a -> a
10:45:11 <djahandarie> Yeah, Monoid would be better if you don't know about type classes ata ll.
10:45:13 <aavogt> the   'a' there :: *
10:45:20 <bss03> > fmap (^ 2) $ Left "An error"
10:45:21 <lambdabot>   Left "An error"
10:45:37 <LambdaLoop> Jesin: is there any way to get input, and change state as a result? 
10:45:54 <Jesin> LambdaLoop: you get input through the IO monad
10:45:57 <aristid> > fmap (^ 2) $ Left ()
10:45:58 <lambdabot>   Left ()
10:46:07 <djahandarie> LambdaLoop, you probably want something like   StateT SomeStateType IO a
10:46:10 <Jesin> you cannot "change state" in general, but the State monad allows computations
10:46:16 <bss03> LambdaLoop: unsafePerformIO, but there's a reason it is called "unsafe".
10:46:21 <Jesin> that store a state along with the current value
10:46:26 <Jesin> D:
10:46:27 <Jesin> noooo
10:46:28 <djahandarie> Why would you recommend unsafePerformIO at all?
10:46:37 <Jesin> don't give him unsafePerformIO
10:46:43 <Jesin> it's a *horrible* idea
10:46:47 <aristid> especially not for state
10:46:47 <LambdaLoop> lol
10:47:05 <LambdaLoop> how would you use State T SomeStateType IO a?
10:47:15 <djahandarie> LambdaLoop, http://www.haskell.org/haskellwiki/Simple_StateT_use
10:47:19 <Jesin> it's StateT, without a space
10:47:26 <LambdaLoop> oh woops
10:47:29 <LambdaLoop> thanks
10:47:59 <djahandarie> yw
10:48:17 <bss03> :t do { x <- gets head; putStrLn . show $ x }
10:48:19 <lambdabot>     No instance for (MonadState [a] IO)
10:48:19 <lambdabot>       arising from a use of `gets' at <interactive>:1:10-18
10:48:19 <lambdabot>     Possible fix: add an instance declaration for (MonadState [a] IO)
10:48:49 <bss03> do { x <- gets head; putStrLn . show $ x } `runStateT` [25]
10:48:56 <bss03> > do { x <- gets head; putStrLn . show $ x } `runStateT` [25]
10:48:57 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
10:48:57 <lambdabot>        ...
10:49:20 <bss03> @instances StateT
10:49:21 <lambdabot> Couldn't find class `StateT'. Try @instances-importing
10:49:31 <bss03> @instances MonadIO
10:49:32 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
10:49:51 <bss03> > do { x <- gets head; liftIO . putStrLn . show $ x } `runStateT` [25]
10:49:52 <lambdabot>   Ambiguous occurrence `liftIO'
10:49:52 <lambdabot>  It could refer to either `Control.Monad.IO.C...
10:51:20 <bss03> > do { x <- gets head; liftIO (putStrLn . show $ x) } `runStateT` [25]
10:51:21 <lambdabot>   Ambiguous occurrence `liftIO'
10:51:21 <lambdabot>  It could refer to either `Control.Monad.IO.C...
10:53:17 <ezyang> I'm getting an error *** Vectorisation error ***     Tycon not vectorised:  GHC.Show.T:Show when I try writing some code with DPH. 
10:53:31 <ezyang> Is this because DPH code must be in a separate module from "normal" code? 
10:53:53 <ezyang> (I was attempting to combine two modules that were originally working) 
10:58:16 <ddarius> Erds on Ramsey Numbers: "Imagine an alien force, vastly more powerful than us, landing on Earth and demanding the value of R(5,5), or they will destroy our planet.  In that case, we should marshal all our computers and all our mathematicians, and attempt to find the value.  But suppose, instead, that they asked for R(6,6), [then] we should attempt to destroy the aliens."
10:58:30 <companion_cube> :D
10:58:34 <parcs> > sequence [Nothing, Just 4, Nothing, Just 3]
10:58:35 <lambdabot>   Nothing
10:58:43 <sorje> ddarius: lol
11:05:00 <LambdaLoop> hmm... suppose I have a function that takes a State monad
11:05:25 <LambdaLoop> how would I transform it to be a function that takes a StateT s IO a
11:05:34 <LambdaLoop> (monad)
11:06:14 <LambdaLoop> or rather
11:06:24 <LambdaLoop> returns the above monads
11:07:57 <dolio> Most monad libraries don't provide it, but you can lift State s a into StateT s m a.
11:08:33 <LambdaLoop> dolio: how would i do that?
11:08:35 <dolio> Really, you can lift it into (MonadState s m) => m a.
11:09:16 <Eduard_Munteanu> State s a = StateT s Identity a
11:09:30 <dolio> @type \v -> do s <- get ; let (x, s') = runState v s ; put s' ; return x
11:09:31 <lambdabot> parse error on input `;'
11:09:48 <dolio> @type \v -> do s <- get ; let { (x, s') = runState v s } ; put s' ; return x
11:09:50 <lambdabot> forall (m :: * -> *) s b. (MonadState s m) => State s b -> m b
11:11:26 <napping> ezyang: I think the problem is that it tries to produce a vectorized version of everything used in the module
11:11:55 <LambdaLoop> hmm... thanks
11:16:19 <ezyang> napping: ah, I see. 
11:17:19 <monadic_kid> anyone have an ideas why i get strange profile results, my callgraph breakdowns never make any sense because well the percentage breakdown is doesn't add up
11:20:12 <napping> ezyang: how much do you use category-extras?
11:22:10 <ezyang> napping: Mmmmmmmm, haven't ever used it seriously. 
11:22:21 <dons> monadic_kid: haven't seen that. 
11:22:27 <dons> monadic_kid: missing -auto-all perhaps?
11:22:34 <ezyang> It's a dons! 
11:22:35 <Eduard_Munteanu> I think category-extras has a huge bus factor.
11:23:37 <dons> heya ezyang 
11:23:48 <monadic_kid> dons: nope, I'm using SCC to break down a particular action which comes up taking 40% of the program time, is %alloc column the amount of time of allocations or percentage of allocations?
11:24:08 <ezyang> dons: Did you ever see my email about strict-concurrency? 
11:24:16 <dons> % of allocs
11:24:20 <dons> ezyang: yep. in my queue
11:24:22 <dons> will get to it.
11:24:23 <Eduard_Munteanu> Percentage in bytes, IIRC.
11:24:25 <ezyang> cool. :-) 
11:24:39 <HugoDaniel> hey dons :)
11:25:22 <Eduard_Munteanu> I actually remember someone walking in here and asking "what's a dons?". :)
11:27:13 <dons> hey HugoDaniel 
11:28:34 <napping> ezyang: aww, that's not so fun. You don't write short beautiful code full of Kan extensions and recursion schemes?
11:29:18 <ezyang> napping: It's on my TODO list :-) 
11:30:14 <Eduard_Munteanu> Short, beautiful code, that references years of learning category theory and heaps of books and research articles. Who needs documentation when you have CT? ;)
11:30:40 <Eduard_Munteanu> "It's a zygo, can't you see?"
11:31:14 <ddarius> The vast majority of categorists would have no idea what "zygo" meant.
11:31:21 <Eduard_Munteanu> No, but really, category-extras is nice.
11:31:28 <Jesin> ...
11:31:45 <Jesin> "values and continuations can be seen as categorically dual concepts"
11:31:48 * Jesin is enlightened
11:31:52 <Eduard_Munteanu> Mm, yes, 'zygo' wasn't a good example. Perhaps Yoneda, Kan and whatnot stuff there's in there.
11:32:31 <napping> If only programs could become much shorter and quicker to write with a few years of study
11:32:57 <ezyang> Jesin: It's a good dualism to understand :-) 
11:33:06 <Eduard_Munteanu> Anyway, even disregarding that, category-extras is interesting in itself.
11:33:26 <ezyang> Actually, not true. I once used the Comonad for a blog post. 
11:33:32 <Jesin> I'm not even using category theory rigorously
11:33:57 <Jesin> I think rigorously, from axioms, may be the wrong way to go about learning it
11:33:58 <Jesin> but
11:34:14 <Jesin> I already saw the Monad-Comonad duality
11:34:30 <Jesin> but
11:34:34 <Eduard_Munteanu> sigfpe's stuff on comonadic cellular automata is a good example.
11:34:40 <Jesin> values vs continuations, this is awesome
11:34:42 <Jesin> :D
11:34:43 <ddarius> Jesin: Look up Filinski's symmetric lambda calculus and Hayo Thielecke's thesis.
11:36:16 <ezyang> Is that "A Functional Abstraction of Typed Contexts"? 
11:36:48 <ddarius> No.
11:36:53 <ezyang> Hmm. 
11:37:01 <Jesin> hmm.
11:38:02 <Athas> I'm having trouble with existential types/heterogenous collections.  The following definitions fail to compile, and I'm uncertain how to fix it: http://hpaste.org/44747/existential_typesheterogenous
11:41:05 <dolio> Athas: You need to return a Maybe (exists a. a), essentially.
11:41:07 <Eduard_Munteanu> Athas: you can't extract 'v' there
11:41:10 <lispy> There, I wrote up my experience with objective-c as a ghc bug: http://hackage.haskell.org/trac/ghc/ticket/5025
11:41:19 <ezyang> Athas: Looking. 
11:41:51 <Eduard_Munteanu> Or rewrite lookupShowable in CPS style.
11:42:59 <Eduard_Munteanu> (Existentials don't come free, you can't actually expose those values.)
11:43:27 <Athas> Hm, I see.
11:44:48 <Eduard_Munteanu> You probably shouldn't use heterogenous lists at all.
11:44:59 <Eduard_Munteanu> (if this is for something practical)
11:45:08 <monadic_kid> dons: okay i think i've figured it out now, i had an action with inline pragma the docs say that -auto-all will apply call-sites to functions with inline pragmas I was still getting entry for it but with taking up no pecentage of time (or an very small amount i can't remember now)
11:45:23 <monadic_kid> *will not apply call-sites to
11:45:31 <dons> ok
11:45:47 <harry_t> hi everyone
11:45:48 <monadic_kid> I just find a bit weird that even though it was being ignored an entry for it was there still
11:45:55 <Eduard_Munteanu> Hi, harry_t 
11:46:09 <harry_t> i am writing a part of speech tagger in Haskell
11:46:38 <Athas> It is, I have a design where I maintain a tree of pairs of functions and values, where I know little else than the fact that each function can be applied to its associated value.
11:46:53 <harry_t> and i am trying to iterate over a list of tagged words that I have and extract counts for all sequences of 3 words, 2 words, and single words
11:46:59 <harry_t> so im using this data structure
11:47:00 <Eduard_Munteanu> monadic_kid: (pure speculation) maybe GHC generates a non-inlined variant as well for cases where it can't be inlined
11:47:08 <harry_t> import qualified Data.Map as Map
11:47:08 <Athas> I find it hard to express, though.  Probably because it's basically an OO design (then again, what I'm doing is intrinsically OO...).
11:47:08 <harry_t> data Counter = Ct {stringPOSMap  :: Map.Map String (Map.Map String Int),
11:47:08 <harry_t>                    trigramCounts :: Map.Map (String, String, String) Int,
11:47:09 <harry_t>                    bigramCounts  :: Map.Map (String, String) Int,
11:47:09 <harry_t>                    unigramCounts :: Map.Map String Int,
11:47:09 <harry_t>                    numWords      :: Int
11:47:09 <harry_t>                   }
11:47:20 <Eduard_Munteanu> harry_t: please don't paste lots of stuff in here
11:47:23 <harry_t> sorry
11:47:23 <Eduard_Munteanu> Use a pastebin.
11:47:31 <dons> ?paste
11:47:31 <lambdabot> Haskell pastebin: http://hpaste.org/
11:47:32 <revenantphx> PASTEBIINNNN
11:47:37 * hackagebot threadmanager 0.1.4 - Simple thread management  http://hackage.haskell.org/package/threadmanager-0.1.4 (BrianLewis)
11:48:09 <harry_t> http://pastebin.com/zxwbJYYL
11:48:15 <harry_t> ok so i have this data structure
11:48:56 <monadic_kid> Athas: what is that you're doing that you think is OO?
11:49:08 <harry_t> and i also have a list of type [(String, String)] which is [(part-of-speech, word)]
11:49:28 <harry_t> and i iterate over this list generating the trigram, bigram, and unigram counts in one pass
11:50:17 <Athas> monadic_kid: a generic library for writing GUIs, where new GUI elements can be created through a vaguely class-like mechanism.
11:50:31 <Athas> Each GUI element acts as a typical object - it has internal state and can send and receive messages.
11:50:48 <Athas> The types of messages are uniform across all elements, but the state can be whatever.
11:51:08 <harry_t> but then later when i create the Counter and extract a unigram count from that it takes a while while it iterates over my list of tagged words and it gives me the count
11:51:32 <harry_t> but then when i try to extract a bigram count from the same data structure it takes a really long time
11:51:43 <harry_t> like it has to iterate over all the words again
11:52:20 <ezyang> harry_t: That's not too surprising. 
11:54:48 <harry_t> is it because when i iterate over the list of words to create the Counter it creates it lazily by keeping track of (Map.insert "some_word" 5 (Map.insert ....... ) and then only evaluates each map that contains my counts later?
11:55:00 <harry_t> when i ask it to?
11:55:08 <Eduard_Munteanu> Athas: ok so you have some functions like f :: state -> KnownArgument -> KnownReturnValue. If you preapply the state part, then you don't need to worry about being heterogenous.
11:55:16 <ezyang> > enumFromTo 3 5 
11:55:17 <lambdabot>   [3,4,5]
11:55:46 <Athas> Eduard_Munteanu: the state is mutable, so it's more like f :: state -> KnownArgument -> (state, KnownReturnValue).
11:58:48 <Eduard_Munteanu> Athas: well, in that case you can safely have an existential state, as long as you don't leak it outside (you can't)
11:59:33 <Athas> Hm, yes, I begin to grasp what I must do...
11:59:48 <monadic_kid> Athas: you're probably better off using a record of functions
12:00:37 <monadic_kid> Athas: you can get really far with them, even share private mutable state
12:01:01 <xarch> why do we talk about the cofree comonad and not the free comonad? why are there two "co" ?
12:01:05 <monadic_kid> not that i'm advocating it
12:01:07 <Eduard_Munteanu> Or do it CPS style, I guess.
12:01:34 <Eduard_Munteanu> (returning a function with a preapplied state to use next time)
12:02:04 <Eduard_Munteanu> xarch: mm, you should think "cofree is a comonad"
12:02:25 <Eduard_Munteanu> As in cofree is the free comonad.
12:02:43 <ezyang> free coffee? 
12:02:55 * Eduard_Munteanu just had some cofree
12:03:05 <xarch> well yeah
12:03:15 <xarch> but sometimes I see written « The Cofree Comonad »
12:03:42 <dolio> Cofreenes is dual to freeness.
12:03:49 <dolio> Or something like that.
12:04:07 <xarch> so that means it's actually free comonad?
12:04:09 <hpc> the coffee monad!
12:04:11 <Saizan> cofree = right adjoint to the forgetful functor
12:04:17 <dolio> xarch: No.
12:04:18 <Saizan> free = left adjoint
12:04:28 <xarch> ok
12:04:38 <Saizan> (iirc)
12:04:43 <dolio> Yes, that's correct.
12:05:24 <dolio> So, cofree comonads are produced by the C in U -| C, where U is the forgetful functor from the category of comonads to the category of endofunctors.
12:05:43 <dolio> Both over some category.
12:06:15 <Eduard_Munteanu> Hm, I thought it was merely a free comonad in the more usual sense of 'free'.
12:06:26 <Eduard_Munteanu> i.e. trivial to construct
12:07:43 <Athas> Eduard_Munteanu: I think the CPS style is the most elegant, so I'll try that.
12:07:49 <xarch> thanks!
12:07:51 <dolio> If you add "op"s in the right places, there's probably a way to relate it to freeness.
12:08:23 <dolio> But conceivably you could have free comonads that aren't the same as cofree comonads.
12:08:37 <dolio> In that case it'd be F -| U, for the same U.
12:08:49 <napping> What is your -| ?
12:09:01 <dolio> F -| U means F is left-adjoint to U.
12:10:15 <dolio> I wouldn't be surprised if there's no free comonad functor, though.
12:10:19 <dolio> And no cofree monad functor.
12:10:44 <harry_t> if i have a data structure with several fields, and I call a function to create that an instance of that data structure, and i ask about the value of one field (and so it evaluates the function to create the instance and return the field value) and then I ask about the value of another field in that data structure, is it going to reevaluate the function to create the instance and then return 
12:10:44 <harry_t> the value of the other field?
12:10:57 <dolio> The distinction shows up in other places, too.
12:11:18 <dolio> You generally have free algebras and cofree coalgebras, but not the other way around.
12:11:22 <Heffalump> it won't reevaluate the data structure itself
12:11:35 <napping> harry_t: Almost certainly not
12:11:42 * hackagebot oeis 0.3.1 - Interface to the Online Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/oeis-0.3.1 (BrianLewis)
12:11:44 <Heffalump> i.e. if you do let struct = f x in (field1 struct, field2 struct), then f x will only be called once
12:12:07 <napping> If you have a constructor with several arguments, and inspect one field, that work will be shared
12:14:16 <harry_t> ok so i have a data structure that has several fields, and I construct an instance of it by iterating over a really long list and I do something like
12:14:43 <harry_t> A x y z = createA someList
12:14:53 <harry_t> and then I ask about the value of x
12:15:02 <harry_t> it takes a long time which is fine
12:15:07 <harry_t> but then I ask about the value of y
12:15:13 <harry_t> and it also takes a really long time
12:15:39 <roconnor> harry_t: you can make the fields strict by putting a ! in front of the field names
12:15:54 <roconnor> that way one one field is ready, they will all be ready
12:15:56 <roconnor> Complex does this
12:16:03 <harry_t> so if i did
12:16:09 <hpc> @src Complex
12:16:09 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
12:16:15 <harry_t> A !x !y !z = createA someList
12:16:20 <roconnor> no no
12:16:26 <roconnor> in the record definition
12:16:35 <harry_t> ohhhhhh
12:16:46 <harry_t> ok so i have this data structure specifically
12:16:47 <harry_t> http://pastebin.com/zxwbJYYL
12:17:08 <harry_t> so it would be like
12:17:12 <roconnor> hmm
12:17:19 <harry_t> !stringPOSMap :: blah
12:17:20 <roconnor> those Maps are not going to strictify very well
12:17:36 <xarch> son in this case U : (T, _, _) -> T no?
12:17:39 <harry_t> because i think that when i create the data structure
12:18:42 <harry_t> i dont know actually
12:18:43 <dolio> xarch: Yes.
12:19:03 <roconnor> harry_t: I don't think I understand your problem actually
12:19:08 <dolio> xarch: Well, that's what it does. That's not its type.
12:19:22 <ezyang> I'm minimizing a DPH program that's broken with the new codegen, and was wondering if there were any further minimization tips: http://hpaste.org/44749/minimizing_broken_dph 
12:19:27 <harry_t> so when i instantiate one of those Counter structures
12:19:41 <dolio> The type is Comonad[C] -> Endo[C], or what have you.
12:19:56 <napping> harry_t: My guess is that the record fields are accumulating a bunch of lazy junk
12:19:57 <harry_t> i am iterating over a huge list and calling a lot of Map inserts
12:20:13 <harry_t> thats what i think too
12:20:18 <roconnor> ok
12:20:42 <napping> then making it strict will make all the work be done the first time through
12:21:10 <napping> though you still have to be careful that the Int contents are not just stacks of (1 + (1 + (1 + ...)))
12:21:31 <napping> If you check one field, and then look at it again, that is quick, right?
12:22:18 <harry_t> yes
12:22:20 <Galathalion> hey
12:22:43 <roconnor> harry_t: is there any particular reason you want to slow everything down upfront?
12:22:54 <AtnNn> how can I "update my code to use the new base 4.x" ? GHC complains when I import Prelude.
12:22:55 <napping> yeah, then it's building up a lot of lazy work.
12:22:57 <harry_t> not really
12:22:58 <roconnor> (though you might be able to reduce memory useage)
12:23:26 <napping> memory usage will improve, but overall speed might not
12:23:38 <harry_t> true but im always going to need to evaluate every field in my data structure
12:23:43 <harry_t> in my application
12:23:48 <napping> Don't use Map.update
12:23:58 <Galathalion> need help coming up with ideas for a simple haskell-project in cognitive science
12:24:04 <Galathalion> anyone feel obliged?
12:24:10 <Galathalion> =)
12:24:15 <napping> ah, actually Map.insertWith' might be ok
12:24:25 <harry_t> yeah thats what i was just thinking also
12:24:45 <harry_t> so if i apply all the inserts strictly
12:25:15 <harry_t> then buildign up the data structure will take a while but then evaluating the Maps will be much faster?
12:25:29 <napping> in fact, Map.insertWith' (+) k 1 is probably exactly what you want
12:25:35 <napping> then just make sure that happens strictkly while the structure is built
12:25:44 <harry_t> ok great! im going to try it
12:25:46 <harry_t> thank you
12:26:07 <napping> insertWith' just fixes the map fields
12:26:21 <napping> if you also make the record fields strict, then the maps will be ready for use as soon as the fold finishes
12:26:46 * hackagebot language-dot 0.0.7 - A library for the analysis and creation of Graphviz DOT files  http://hackage.haskell.org/package/language-dot-0.0.7 (BrianLewis)
12:27:19 <harry_t> yeah im going to do both
12:34:23 <Galathalion> herro
12:40:30 <monadic_kid> Athas: this what I meant: http://hpaste.org/44750/nasty_hidden_sideeffecting_oo you don't have to use IO and you don't have to use it for all functions, object functions act as a constructor and can take & capture arguments
12:43:19 <frank00> Hello, I'm trying to read all the files from the current directory <-- show $ getDirectoryContents (read getCurrentDirectory) -- it rightly fails, but how should it be done?
12:46:26 <AtnNn> frank00: getDirectoryContents =<< getCurrentDirectory, or just getDirectoryContents "."
12:47:51 <parcs> @type getDirectoryContens
12:47:52 <lambdabot> Not in scope: `getDirectoryContens'
12:47:53 <parcs> @type getDirectoryContents
12:47:54 <lambdabot> Not in scope: `getDirectoryContents'
12:47:59 <frank00> thanks AtnNn , but I would like to print it to screen, and this putStrLn (show $ getDirectoryContents =<< getCurrentDirectory) fails
12:48:01 <parcs> @hoogle getDirectoryContents
12:48:01 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
12:48:22 <parcs> frank00: instead of show use fmap show
12:48:46 <Saizan> you also need putStrLn =<< ..
12:49:57 <monadic_kid> :t print
12:49:58 <lambdabot> forall a. (Show a) => a -> IO ()
12:50:36 <monadic_kid> > print =<< getDirectoryContents =<< getCurrentDirectory
12:50:37 <lambdabot>   Not in scope: `getDirectoryContents'Not in scope: `getCurrentDirectory'
12:50:46 <Saizan> no IO on lb
12:50:52 <frank00> print . fmap show . getDirectoryContents =<< getCurrentDirectory <-- like this?
12:51:11 <monadic_kid> frank00: if you use print you don't need to use show
12:51:12 <Saizan> no
12:51:24 <monadic_kid> frank00: print =<< getDirectoryContents =<< getCurrentDirectory
12:51:53 <parcs> frank00: do you know how to perform this with do notation
12:52:17 <frank00> parcs : yes, I suppose so
12:52:41 <tehgeekmeister> is there a function of type (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a such that if both maybe arguments are Justs it applies the function to determine which value should be chosen, but if only one is a just, it evaluates to that, and obviously to a Nothing if both arguments are nothing?
12:52:51 <tehgeekmeister> preliminary hoogling did not find such a function.
12:53:01 <parcs> frank00: do you know what do notation expands to?
12:53:03 <ezyang> tehgeekmeister: You can arrange for this using applicative. 
12:53:16 <monochrom> @type liftM2
12:53:16 <ezyang> tehgeekmeister: f <$> a <*> b 
12:53:17 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:53:36 <frank00> parcs: IIRC, >>= is <- and a line is just >>, right?
12:53:44 <monochrom> nevermind, liftM2 behaves differently
12:53:55 <tehgeekmeister> monochrom: liftM2 isn't what I want, is it?
12:54:03 <monochrom> it isn't.
12:54:18 <tehgeekmeister> thought so.
12:54:21 <tehgeekmeister> glad i'm not going crazy.
12:54:22 <Saizan> tehgeekmeister: \f a b -> liftM2 f a b `mplus` a `mplus` b
12:54:22 <ezyang> oh, yeah, mine isn't it either. 
12:54:27 <monadic_kid> > (,,,) <$> Just 1 <*> Just 2 <*> Just 3
12:54:28 <lambdabot>   Overlapping instances for GHC.Show.Show (d -> (a, a1, a2, d))
12:54:28 <lambdabot>    arising fr...
12:55:02 <aristid> > liftA3 (,,,) (Just 1) (Just 2) (Just 3)
12:55:03 <lambdabot>   Overlapping instances for GHC.Show.Show (d -> (a, b, c, d))
12:55:03 <lambdabot>    arising from...
12:55:10 <aristid> :t liftA3 (,,,) (Just 1) (Just 2) (Just 3)
12:55:10 <lambdabot> forall a b c d. (Num a, Num b, Num c) => Maybe (d -> (a, b, c, d))
12:55:15 <ozataman_> Hey all. Anyone know how to use "cabal build" to produce -prof -auto-all -caf-all executable with GHC 7.0.2?
12:55:17 <aristid> :t liftA3 (,,) (Just 1) (Just 2) (Just 3)
12:55:18 <lambdabot> forall a b c. (Num a, Num b, Num c) => Maybe (a, b, c)
12:55:21 <aristid> > liftA3 (,,) (Just 1) (Just 2) (Just 3)
12:55:21 <lambdabot>   Just (1,2,3)
12:55:29 <monadic_kid> > (,,) <$> Just 1 <*> Just 2 <*> Just 3
12:55:30 <lambdabot>   Just (1,2,3)
12:55:36 <monadic_kid> ah to many , :)
12:55:46 <tehgeekmeister> Saizan: ah, so liftM2 f a b applies the function if both values are justs, and the mplus bits take care of the rest.  slick.
12:56:28 <Saizan> tehgeekmeister: yep
12:56:54 <ezyang> Note that this code will do some odd things for MonadPlus with side-effects. 
12:56:57 <tehgeekmeister> Saizan: Problem with this is both of these values are *actually* IO (Maybe a) (database queries), would that structure (appropriately lifted) mean the queries potentially happen multiple times?
12:57:05 <ezyang> Yes. 
12:57:05 <frank00> parcs : forget my answer, I see it's a mistake :S
12:57:22 <monadic_kid> tehgeekmeister:  (,,) `liftM` Just 1 `ap` Just 2 `ap` Just 3
12:57:43 <monadic_kid> tehgeekmeister: or  (,,) <$> Just 1 <*> Just 2 <*> Just 3
12:57:51 <dons> i wish <$> and <*> were lighter syntax
12:58:02 <Saizan> monadic_kid: that doesn't respect the spec at all
12:58:29 <monadic_kid> Saizan: the spec?
12:58:29 <Saizan> tehgeekmeister: yes
12:58:51 <Saizan> monadic_kid: the initial question
12:59:04 <tehgeekmeister> Saizan: so I probably can't do anything much more elegant than handling this all manually?
12:59:23 <tehgeekmeister> if i want to not perform the queries multiple times
12:59:56 <shachaf> What happened to that idiom bracket implementation someone was going to do?
13:00:30 <monadic_kid> shachaf: what do you mean? there is one in Control.Exception
13:00:43 <frank00> mhhh, I'm sorry to bother you all again, but in the folder where the compiled is I have a subfolder called "toprocess", and I would like to do something like map function filesInThatFolder. If there's only one file in the main folder I call getContents, but I am not sure how to do that on multiple files on a subfolder
13:00:44 <shachaf> monadic_kid: There is?
13:00:47 <monadic_kid> :t bracket
13:00:48 <lambdabot> Not in scope: `bracket'
13:00:54 <monadic_kid> :t Control.Exception.bracket
13:00:55 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:00:56 <shachaf> monadic_kid: I mean the applicative bracket syntax to replace <$>/<*>.
13:00:58 <monadic_kid> :t Control.Exception.bracket_
13:00:59 <lambdabot> forall a b c. IO a -> IO b -> IO c -> IO c
13:01:12 <monadic_kid> ah okay
13:01:51 <Saizan> shachaf: it's in SHE :)
13:02:22 <monadic_kid> who is SHE?
13:02:32 <ezyang> Strathclyde Haskell Enhancement 
13:03:32 <monadic_kid> nice
13:04:06 <Saizan> tehgeekmeister: \f a b -> do x <- a; y <- b; return $ liftM2 f x y `mplus` x `mplus` y -- some variation of this if you don't want to perform the b query if the a returns Nothing
13:04:09 <monadic_kid> i was about to say couldn't it be implemenated with template haskell
13:04:38 <tehgeekmeister> Saizan: much thanks.
13:05:33 <tehgeekmeister> That's much, much more elegant than my four line pattern matching version.
13:05:48 <Saizan> mh, you've to perfom b anyway, so that's not a problem :)
13:06:39 <lispy> did ghc move to github yet?
13:06:52 <lispy> this repo is ancient: https://github.com/ghc-hq/ghc
13:07:05 <lispy> But, I thought they said the move would happen when 7.0.2 comes out
13:07:26 <Saizan> i think the main repo is still darcs
13:08:03 <ezyang> They're moving this Tuesday, IIRC. 
13:08:06 <tehgeekmeister> Hm, actually, I have to execute both queries no matter what.  I should probably just combine them so it's only one hit to the database...  That can happen later.
13:08:31 <lispy> ezyang: cool.  The googles are failing me to find the exact date.
13:08:57 <ezyang> It's either Tuesday or Thursday: one of the Ts 
13:09:12 <olsner> ezyang: who owns the github repo? it'd be neat if it started being a real up-to-date mirror
13:09:33 <lispy> olsner: well, I see this https://github.com/ghc-hq/ghc
13:09:42 <lispy> olsner: claims to be the official github repo
13:10:25 <olsner> lispy: yeah, except it's out of date by (iirc) a couple of years and has no shared history with the git repo at darcs.haskell.org
13:11:17 <lispy> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg19333.html
13:11:29 <lispy> olsner: it's actually over a year out of date
13:11:39 <olsner> yeah, "October 23, 2009" - so not exactly 2 years, more like one year and a few months
13:12:46 <lispy> olsner: oh, sorry.  I misread your message as "a couple *days*"
13:12:58 <lispy> olsner: I didn't meant to nitpick the number of years :)
13:13:03 <olsner> :)
13:13:27 <lispy> doing git clone http://darcs.haskell.org/ghc-git/ghc.git is crazy slow compared to github :( :(
13:13:55 <lispy> it's been at "Cloning into ghc..." for about a minute.  The github version was half way downloaded after 10 minutes.
13:14:29 <aristid> lispy: did you use git-protocol with github, or http?
13:14:50 <olsner> the darcs.haskell.org repo shows last commit from Tue Feb 22 but hasn't moved for at least a week so not sure if it's being kept up to date
13:14:54 <olsner> builds fine though
13:14:59 <lispy> aristid: http, but I think I read that github can do them equally efficiently due to some cleverness
13:15:41 <lispy> okay, that clone finished
13:15:44 <lispy> trying the build now
13:16:08 <rostayob> If I have a function that returns a data type, will the datatype fields be lazy? So if I expect only one data type field the other won't be computed?
13:17:27 <maurer_> rostayob: Correct.
13:18:57 <rostayob> maurer_: thanks.
13:24:13 <LambdaLoop> is there any way to match more than one pattern for case expressions?
13:24:26 <LambdaLoop> something like
13:24:32 <LambdaLoop> case x of 
13:24:44 <DevHC> [] -> "blabla"
13:24:45 <LambdaLoop> 1 or 2 -> x + 1
13:24:51 <DevHC> _ -> "not blabla"
13:25:24 <DevHC> case x of x | x `elem` [1,2] -> "one or two"
13:25:47 <LambdaLoop> oh
13:25:54 <LambdaLoop> thanks!
13:26:16 <LambdaLoop> didn't know you could use guards in case 
13:28:20 <shachaf> What Haskell needs is case fallthrough by default.
13:28:47 <LambdaLoop> that would make it act weird....
13:28:58 <LambdaLoop> and it doesn't make sense
13:29:09 <aavogt> this http://hackage.haskell.org/trac/ghc/ticket/3919 ?
13:29:17 <shachaf> LambdaLoop: But it can lead to such great bugs.
13:30:36 <LambdaLoop> shachaf: lol
13:31:00 * hackagebot vty-ui 1.0.1 - An interactive terminal user interface library  for Vty  http://hackage.haskell.org/package/vty-ui-1.0.1 (JonathanDaugherty)
13:31:14 <LambdaLoop> aavogt: that sounds amazing!
13:31:18 <Sgeo> Why is this link broken?
13:31:19 <Sgeo> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Concurrent-Chan.html
13:31:29 <Sgeo> It was linked to from http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
13:31:39 <shachaf> @source Control.Concurrent.Chan
13:31:40 <lambdabot> http://darcs.haskell.org/packages/base/Control/Concurrent/Chan.hs
13:31:48 <shachaf> Er, that's not source.
13:32:12 <shachaf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
13:32:18 <Sgeo> ty
13:32:27 <shachaf> Fix the link on the wiki. :-)
13:32:28 <aavogt> LambdaLoop: well it's not that much of an inconvenience
13:33:18 <LambdaLoop> aavogt: true, guards work just as well at the moment
13:33:37 <Taslem> Could someone help me debug my code?
13:33:38 <Taslem> http://pastebin.com/VfcbaKXL
13:34:37 <DevHC> u r mixing tabs and spaces.
13:34:49 <Taslem> I noticed, thanks, got it fixed.
13:34:49 <BMeph_> Does anyone know of a way, using Parsec, to show a tree of how something was parsed up to where it doesn't match?
13:35:35 <BMeph> If that last statement doesn't make sense to you, please tell me. :)
13:35:57 <Sgeo> The entire page seems obsolete
13:38:14 <LambdaLoop> Taslem: how does the 'o' fit in at line 4?
13:38:28 <maurer_> BMeph_: Parsec allows you to have tried several different parses before it fails. How do you want to canonicalize the failed parse?
13:38:51 <Taslem> I was fiddling around with names to make sure there were no conflicts. But I got it fixed.
13:39:03 <LambdaLoop> oh ok
13:39:24 <LambdaLoop> sorry then
13:39:45 <Taslem> Nah, it's okay, you were right.  
13:40:21 <LambdaLoop> :)
13:44:30 <Taslem> Don't "where" statements let you write imperatively, basically?
13:45:15 <BMeph> maurer_: Different parses as in all of the chars that satisfy a 'char' parse, or all of the different alternates of an '<|>' alternation? Or both?
13:45:22 <BMeph> Taslem: No, basically. :)
13:45:41 <Taslem> Okays, then.
13:45:59 <Taslem> How do you write multi-line comments?
13:46:21 <Eduard_Munteanu> Taslem: {- stuff -}
13:46:31 <Taslem> Okay.
13:47:37 <DevHC> guess what, i can make ghci segfault
13:48:17 <Eduard_Munteanu> That should be piece of cake with unsafePerformIO ;P
13:48:23 <BMeph> Taslem: The "big" problem with your pastebin frag as is looks there, is that all of the expressions after a 'where' need to line up on the left.
13:48:37 <Taslem> Yeah, that's what I realized.
13:48:38 <LambdaLoop> Taslem: as a code suggestion, you can name your Object while pattern matching it
13:48:40 <DevHC> lol unsafe isn't needed, IO is enough :P
13:48:51 <Taslem> Name it?
13:49:08 <LambdaLoop> Taslem: as in  setProp prop obj@(Object n p)
13:49:23 <Taslem> Really? I didn't know that.
13:49:23 <LambdaLoop> so that obj is bound to the object
13:49:42 <BMeph> Taslem: Curiously, called an 'as-pattern' from its use in ML.
13:50:26 * BMeph thinks it should be called an 'at-pattern', "obviously. ;)
13:50:57 * BMeph forgot the closing '"' above, whoops. :)
13:51:16 <DevHC> i think it steals a cute looking operator name D:
13:51:31 <Taslem> If you can make a type like: (A Int) or (A a)....
13:51:47 <Taslem> Can you make it so that the 'a' in the latter is restricted to one of several types?
13:52:01 <Taslem> Like it has to be a String OR an Int, and nothing else, though it could be either?
13:52:04 <aavogt> it really doesn't save much space since you can write:
13:52:17 <DevHC> not really
13:52:18 <aavogt>  setProp prop obj = case obj of Object n p ->
13:52:31 <BMeph> Taslem: As in "the 'a' is a member of some typeclass," yes. ;)
13:52:45 <Taslem> Oh, right, forgot about that.
13:53:20 <aavogt> Taslem: make/use a type class to express the same idea?
13:55:44 <DevHC> u'll have to use 1 typeclass per function: class FCanBeApplied a where {} ; instance FCanBeApplied Int where {} ; instance FCanBeApplied String where {} ; f :: FCanBeApplied a => a -> a ; f a = error "olololololo"
13:55:54 <DevHC> is that fugly? :D
13:57:25 <aavogt> why are you overlapping?
13:57:39 <DevHC> wat?
13:58:01 <aavogt> that adds a fallback case so you don't get a compile error when you pick a nothing-else somewhere
13:58:37 <DevHC> ?
13:58:59 <aavogt> oh, I misunderstood
13:59:04 <aavogt> @hackage HList
13:59:04 <lambdabot> http://hackage.haskell.org/package/HList
13:59:13 <aavogt> in there is a class TypeEq
14:00:14 <aavogt> so you can write:        f :: (TypeEq a String x1, TypeEq a Int x2, Or x1 x2 True) => a -> a  -- or similar
14:00:36 <aavogt> maybe Or is called HOr or True, HTrue...
14:00:54 <aavogt> this means you don't need to write extra classes
14:02:13 * aavogt doesn't really see what the benefit of expressing this is
14:02:19 <aavogt> also the error messages will be horrible
14:02:25 <aavogt> when you get a type error
14:03:52 <aavogt> maybe it can work to have an unsatisfiable class constraint which mentions a type whose name explains what you intended with the type
14:05:39 <DevHC> lol
14:06:20 <harlekin> @pl (\(f, g) (x, y) -> (f x, g y))
14:06:20 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
14:07:03 <harlekin> Mh, I'm rather looking something that's shorter and involved join (***) (+) (x, y) :: (Int -> Int, Int -> Int) which I ant to apply to another pair of Ints.
14:07:08 <harlekin> *looking for
14:07:08 * hackagebot hsmagick 0.5 - FFI bindings for the GraphicsMagick library  http://hackage.haskell.org/package/hsmagick-0.5 (VincentGerard)
14:07:13 <DevHC> basically one might want to calm his conscience by asserting that he has used his functions only for Int, CInt, Word8, Word16, Word32, and Word64, but not Integer
14:07:14 <harlekin> *involves -.-"
14:08:43 <Taslem> Did you know that there are people who think Haskell is the worst language ever? :/
14:08:49 <sonoflilit> Hello
14:09:00 <sonoflilit> I'm trying to write some template haskell
14:09:13 <aavogt> sonoflilit: why?
14:09:21 <sonoflilit> and I would like to get the name of a type constructor in a pure function
14:09:31 <sonoflilit> I want to extend persistent
14:09:38 <sonoflilit> snoyman's persistent
14:09:45 <harlekin> @pl (\(x, y) (dx, dy) -> let (f, g) = join (***) (+) (x, y) in (f dx, g dy))
14:09:45 <lambdabot> (line 1, column 26):
14:09:45 <lambdabot> unexpected "("
14:09:45 <lambdabot> expecting "()", natural, identifier or "in"
14:09:56 <aavogt> sonoflilit: you have a specific type constructor in mind?
14:09:57 <sonoflilit> is that at all possible?
14:10:06 <aavogt> you can just write something like  ''Maybe
14:10:16 <sonoflilit> I see
14:10:19 <sonoflilit> can I write ''f?
14:10:38 <sonoflilit> mm, no
14:10:40 <aavogt> where does f come from?
14:10:48 <Taslem> Is it possible to make a pattern-match for something like....    (a ++ 3:[])?
14:11:18 <Taslem> Basically, match for (a:b:c:d:e:f:.......:3:[])
14:11:37 <sonoflilit> I'd like to have a function f :: MyEnum -> ConT
14:11:50 <sonoflilit> Con*
14:11:57 <aristid> Taslem: not as a "real" pattern match. effectively you have to call a function, directly or over view patterns/guards
14:12:19 <sonoflilit> Type*
14:12:23 <Taslem> Hm... That would be a neat feature in Haskell..... 
14:12:40 <napping> general matching involving ++ is pretty hard.
14:12:44 <napping> You might try Maude
14:13:19 <bss03> What package has in Monad instance for Either [Char]?
14:13:29 <bss03> @instances Monad
14:13:30 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
14:13:37 <Taslem> Well, I mean, x ++ y is really (a:b:c:d : y) etc. 
14:13:54 <bss03> @where Either
14:13:55 <lambdabot> I know nothing about either.
14:14:18 <bss03> @info Either
14:14:19 <lambdabot> Either
14:14:32 <sonoflilit> sorry, f :: MyEnum -> NormalC, where dataMyEnum = A | B | C
14:14:39 <sonoflilit> can this be done?
14:14:49 <sonoflilit> or only f :: MyEnum -> Q NormalC?
14:15:01 <aristid> bss03: in older versions of ghc, it's in mtl (IIRC), and in newer versions it's in base
14:15:12 <aavogt> @hoogle String -> Name
14:15:12 <lambdabot> Language.Haskell.TH mkName :: String -> Name
14:15:12 <lambdabot> Language.Haskell.TH.Syntax mkName :: String -> Name
14:15:12 <lambdabot> Language.Haskell.TH.Syntax mkNameL :: String -> Uniq -> Name
14:15:24 <aavogt> sonoflilit: you can use mkName, but it's unhygenic
14:15:28 <bss03> snoflilit: It can be done, but it makes the function partial.
14:15:36 <Taslem> Is there any difference at all between [] and ""?
14:15:53 <bss03> @type ""
14:15:54 <lambdabot> [Char]
14:15:56 <bss03> @type []
14:15:57 <lambdabot> forall a. [a]
14:16:02 <aristid> Taslem: yes. the latter is monomorphic
14:16:12 <Taslem> I find that a bit odd, really.
14:16:15 <sonoflilit> as in, pattern match manually and make it give the correct data?
14:17:03 <Taslem> Because if [] == "", then the same operations that can be performed on [] should be performed on "".
14:17:05 <bss03> aristid: Did I say package?  I meant module.
14:17:11 * hackagebot zeromq-haskell 0.5.0 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.5.0 (ToralfWittner)
14:17:15 <Taslem> Yet 3:"" yields an error.
14:17:36 <aristid> bss03: Control.Monad.Instances in newer versions of ghc
14:17:41 <napping> "" is an instance of []
14:17:47 <aristid> it used to be in Control.Monad.Error
14:17:57 <aristid> napping: [] is not a class, so that statement is wrong :P
14:18:00 <napping> it doesn't make sense to do all things
14:18:08 <napping> aristid: instantiating a polymorphic type
14:18:14 <bss03> aristid: Although, it probably is a GHC version issue; I 'll bet this was written against GHC 7.  I need to target Maverick == GHC 6.12, I think.
14:18:22 <Eduard_Munteanu> Taslem: you can't pattern-match on functions because that'd imply inverting those functions
14:18:31 <sonoflilit> aavogt: also, can you explain [||] syntax?
14:18:56 <Eduard_Munteanu> And in the general case, that's tough (tm).
14:18:56 <Taslem> Yeah, I see what you mean. But, with strong typing, wouldn't it be possible to unroll them?
14:19:19 <mauke> ?!
14:19:19 <lambdabot> Maybe you meant: . ? @ v
14:19:20 <napping> No, types don't make ++ invertible
14:19:31 <Eduard_Munteanu> How do you invert (*0) ?
14:20:30 <napping> For ++ in particular, there is "associative-commutative rewriting" as found in languages like Maude
14:21:52 <napping> but if you don't have unique matches you get nondeterminism
14:34:01 <blackdog> anyone know who built the x86_64 ghc on the haskell platform page?
14:34:23 <blackdog> and whether it might be possible to release it with shared libs?
14:41:56 <dons> blackdog: all ghc's built by ghc HQ
14:43:09 <blackdog> dons: so i should bother igloo, or raise a bug, or .. ?
14:43:20 <blackdog> i don't really know whether it's an oversight or a policy decision
14:43:29 <dons> feature request ? what platform are you x86_64ing on?
14:43:32 <blackdog> mac
14:43:41 <dons> oh, that's a known issue.
14:43:43 <dons> they're working on it.
14:43:47 <dons> ?bug
14:43:47 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:44:12 <blackdog> huh, that's weird. the macports build of it works a treat
14:44:15 <Anpheus> I read that as "newtype?type=bug"
14:44:19 <Anpheus> And was like :O, you can just do that?
14:44:52 <dons> blackdog: http://hackage.haskell.org/trac/ghc/ticket/5008 
14:45:04 <dons> oh, shared libs. not quite the same
14:45:14 <dons> are shared (haskell) libs working on x86_64 yet?
14:45:46 <blackdog> dons: the path at the moment is to build the macports version of ghc 6.12, then build 7.0.1 from source
14:45:50 <blackdog> that works fine
14:46:03 <blackdog> and all hubris tests pass, so we're definitely building shared libs
14:48:58 <Eduard_Munteanu> Hm, I remember it working here on Gentoo.
14:48:59 <blackdog> dons: if you pass -shared to that command line with a macports-built ghc, it works fine.
14:49:16 <blackdog> not with the released one, though - you get the 'have you installed the "dyn" libraries' complaint
14:49:38 <Eduard_Munteanu> (even with the binary GHC, IIRC)
14:49:58 <blackdog> Eduard_Munteanu: mac problem
14:50:11 <Eduard_Munteanu> Ah.
14:52:11 <Igloo> blackdog: 64bit OS X isn't in the PlatformSupportsSharedLibs list; plese file a ticket if you think that's wrong
14:52:46 <blackdog> Igloo: ok. need a test case?
14:53:23 <Igloo> Shouldn't be necessary; thanks
14:55:32 <cathper> Any idea why lhs2TeX typesets ^ by \uparrow?
14:56:17 <dons> blackdog: might want to negotiate with gregory wright about whether this is known to be working
14:56:55 <kosmikus> cathper: because it has always done so :) if you don't like it, change it.
14:56:56 <blackdog> dons: ok, i'll follow up.
14:58:29 <cathper> kosmikus: I will, but if there was some clever reason I would hesitate :-)
15:00:43 <elliott> cathper: Knuth!
15:00:54 <elliott> In Knuth's up arrow notation, ^ is \uparrow.
15:01:00 <elliott> Q.E.D.
15:01:30 <elliottcable> Knuth’s up-arrow notation rocks.
15:02:00 <elliottcable> I accidentally re-invented it in high-school, sort of. I theorized a method to describe ultimately large numbers in a clean, simple way… and then some dude told me Knuth had already done that )-:
15:03:01 <hpc> it's been invented many times
15:03:09 <hpc> see: conway's chained arrow notation
15:03:10 <roconnor> The exponential function isn't total!  You guys are all evil and stupid!
15:03:29 <c_wraith> It's total when both inputs are natural numbers.
15:03:35 <c_wraith> Who cares about other cases?
15:03:39 <hpc> it's total when both inputs are complex numbers
15:03:39 <elliott> c_wraith: Not according to some!
15:04:01 <Heffalump> hpc: complex as in non-zero real and imaginary parts?
15:04:11 <elliott> Admittedly those who claim it is not tend to be slightly crazy. But I'm pretty sure at least one Ph.D. in mathematics has claimed that exponentiation is really not total.
15:04:13 <roconnor> c_wraith: oh ya, prove the exponential function on the natural numbers is total!
15:04:23 <hpc> complex as in a + bi, where a, b :: Real
15:04:26 <roconnor> see, it can't be done!
15:04:30 <elliott> roconnor: and the axiom of choice is false too!
15:04:32 <elliott> :)
15:04:40 <c_wraith> of course the axiom of choice is false.
15:04:43 <Heffalump> hpc: what's 0^0?
15:04:45 <c_wraith> it's utter nonsense.
15:04:53 <hpc> Heffalump: eleventy one!
15:05:01 <napping> no, the axiom of choice is obviously true. It's the well-ordering principle that's obviously false
15:05:14 <hpc> zorn's lemma is the fun one
15:05:37 <roconnor> the axiom of choice is stated in a context that is already stupid and evil.
15:05:52 <c_wraith> Go ahead and choose an element from R \ CR for me.
15:06:13 <c_wraith> oh, and I need to know its digits for this algorithm
15:06:44 <Eduard_Munteanu> To be honest, exponential refers only to a^x where only x varies, so most exponentials are total ;)
15:07:03 <Eduard_Munteanu> (And who cares for a != e? :P)
15:07:37 <Eduard_Munteanu> "Power" is the other way around.
15:08:35 <tswett> What's that datatype that contains a string, and whose Show instance produces that string?
15:08:36 <hpc> wait, i am somewhat confused now
15:08:53 <hpc> the AXIOM of choice is equivalent to the well ordering THEOREM, says wikipedia
15:09:06 <luite> and Zorn's LEMMA
15:09:07 <tswett> c_wraith: what's CR?
15:09:08 <luite> :p
15:09:09 * hpc is prepared to accept wikipedia as wrong, but wanted to be sure
15:09:16 <roconnor> hpc: /tophat
15:09:21 <c_wraith> tswett: Computable Reals
15:09:27 <tswett> Ah.
15:09:34 <tswett> 0.  :P
15:09:44 <c_wraith> 0 is computable.  not in C \ CR
15:09:58 <tswett> Oh, that's subtraction, not division.
15:10:18 <hpc> oh i see, the theorem is a direct result of the axiom
15:10:27 <tswett> The probability that a randomly-generated infinite Brainfuck program will halt.
15:10:37 <Eduard_Munteanu> He wants to know its digits :P
15:10:45 <tswett> Oh, okay.
15:10:55 <tswett> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.  You can figure out what order they come in.
15:11:14 <c_wraith> really?  can you prove all those digits are in it?
15:11:16 <roconnor> you need to state the distribution
15:11:20 <atp> does anyone know whether or not yitz's ListT eventually made it into mtl or not?
15:12:50 <hpc> man, i love set theory
15:13:03 <hpc> "what if we assumed math worked like this?"
15:13:04 <roconnor> atp: I think it is easier to abandon the mtl
15:13:08 <hpc> "nope, boring; how about this?"
15:13:09 <Eduard_Munteanu> hpc: that is offtopic here! :P
15:13:24 <atp> roconnor: surely we can't all still be copying the code from the wiki can we
15:13:25 <roconnor> hpc: xplat and I are trying to prove that set theory is inconsistnent
15:13:27 * hpc moves to the not not not haskell channel :D
15:13:37 <roconnor> atp: oh there is a ListT package I think
15:13:42 <Eduard_Munteanu> ##not-categorytheory
15:13:54 <roconnor> atp: and I expect a proper listT is in monadLIb
15:14:29 <Eduard_Munteanu> roconnor: unless this is about mtl2
15:14:36 <roconnor> http://purely-functional.net/monadLib/doc/MonadLib.html#t%3AContT
15:14:42 <atp> roconnor: I guess the question I'm driving at is why haven't they merged ListT done right into mtl yet... as far as I can see there was broad concensus for the change two or three years ago already
15:14:49 <roconnor> I think that is a proper listT
15:15:08 <tswett> roconnor: uniform.  I think.
15:15:12 <roconnor> atp: because people rely on all the erronious behavour of the mtl
15:15:18 <tswett> c_wraith: uh... give me a moment.  :P
15:15:27 <roconnor> atp: since the mtl is in HP, it is now widely depended on
15:15:30 <elliott> <tswett> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.  You can figure out what order they come in.
15:15:31 <elliott> <c_wraith> really?  can you prove all those digits are in it?
15:15:34 <elliott> erm in Chaitin's omega?
15:15:36 <atp> roconner: bleh
15:15:37 <roconnor> atp: and we are stuck with it for the next 10 years or more
15:15:44 <roconnor> atp: blame HP
15:15:46 <elliott> I can handwave that proof in like two seconds, therefore it's trivial!
15:16:20 <roconnor> atp: oops wrong link
15:16:26 <atp> roconnor: sigh, ok, thanks for answering my question, I won't shoot the messenger :p
15:16:35 <roconnor> http://purely-functional.net/monadLib/doc/MonadLib.html#t%3AChoiceT
15:16:37 <c_wraith> I can handwave prove the axiom of choice is true in a couple seconds.  Not a compelling argument :)
15:16:44 <roconnor> atp: please shoot HP
15:17:11 <atp> roconnor: I thought they were supposed to improve Haskell, not make it suck
15:17:37 <atp> roconnor: everything's been downhill since they took out monad comprehensions (this is my best Cale impression)
15:17:43 <roconnor> atp: They are ignorant about the destruction they are causing
15:17:47 <Heffalump> I think mtl was widely depended on before the HP even existed
15:17:53 <elliott> <3 monad comprehensions
15:17:59 <Cale> What?
15:18:17 <elliott> Cale: We're just giving a Caleskell tutorial. (blatant lies)
15:18:19 <Eduard_Munteanu> @quote monad.comprehensions
15:18:20 <lambdabot> Cale says: Removing monad comprehensions was actually the snowball which caused the avalanche of fail in Haskell 98
15:18:28 <Eduard_Munteanu> Hah.
15:18:29 <Cale> Well, Haskell 98 was largely a step down from 1.4 because of that yes.
15:18:31 <roconnor> :D
15:18:49 <Cale> It sounded like you were saying the language's progress as a whole has been downhill though.
15:18:58 <elliott> haskell 98 report is better because oerjan did typo fixes to it
15:19:01 <elliott> qed
15:19:13 <atp> haha
15:19:21 <roconnor> Cale: it sure has.  First Haskell 98, then the mtl and now the HP
15:19:41 <atp> the DLL hell that is cabal doesn't help either
15:19:58 <roconnor> well, First Haskell 98 and then the HP
15:20:00 <Heffalump> cabal isn't DLL hell, it just makes it easier to run into the problems
15:20:06 <elliott> let's go back to our roots, live like natives...
15:20:09 <elliott> EVERYONE SWITCH TO HUGS!
15:20:12 <roconnor> each development entrenching more problems more deeply
15:20:22 <elliott> a suitably old version, of course
15:20:27 <atp> elliott: i know, compiling is so 1950
15:20:28 <roconnor> Heffalump is right
15:20:52 <roconnor> I'm pretty hopeful cabal will eventually solve or at least reduce the DLL hell
15:20:56 <Heffalump> yeah
15:20:58 <Cale> I suppose *as standardised* it has been downhill. There have been a lot of improvements in GHC though.
15:21:04 <c_wraith> I...  Don't have these problems anymore.  Turns out, there's plenty of software that already exists that solves the problem.
15:21:12 <Heffalump> if you could just declare packages as internal dependencies, a huge number of the problems would go away
15:21:23 <elliott> bah
15:21:25 <Cale> I'm not sure that HP is really entirely a bad idea, and given that there's nothing which requires me to use it, I'm okay with it.
15:21:25 <elliott> it's too much
15:21:28 <elliott> roconnor: join me in switching to Gofer
15:21:36 <Cale> mtl has problems
15:21:42 <dcoutts_> roconnor: me too
15:21:44 <roconnor> and if you could install more than one copy of the same version of software with differnt dependences, the other half of the problems would go away
15:21:46 <atp> while we're complaining i would like it if cyclical module dependencies actually worked as advertised in the report
15:21:56 <dcoutts_> roconnor: right
15:21:56 <Cale> Particularly, I don't understand why we're hanging on to ListT still
15:21:57 <gio123> Cale: hi
15:22:01 <c_wraith> roconnor: I can do that.
15:22:11 <roconnor> elliott: the langauge or the web protocol?
15:22:11 <atp> Cale: exactly!
15:22:11 <hpc> atp: how do they work in the report?
15:22:14 <Cale> gio123: If you ask me about CLP, I'm going to be upset :)
15:22:19 <atp> hpc: they just work :)
15:22:21 <roconnor> elliott: cause I'm more of a Miranda sort of person
15:22:22 <elliott> roconnor: the protocol is gopher. but - both
15:22:22 <Eduard_Munteanu> CLP?
15:22:27 <Cale> There are like 50 other people in this channel who know more about CLP than I do.
15:22:28 <Eduard_Munteanu> Tell me.
15:22:39 <elliott> roconnor: we'll write on our glogs about our usage of gofer.
15:22:44 <roconnor> :D
15:22:47 <roconnor> good idea
15:22:54 <hpc> atp: ah; never really a fan of cyclic module depends; having the modules form a tree instead of a graph is quite helpful
15:23:01 <elliott> roconnor: instead of twitter, we'll serve out .plans via finger
15:23:04 * roconnor starts writing a gopher server in Haskell
15:23:11 <elliott> (fun fact: finger is a tiny subset of gopher)
15:23:16 <roconnor> does firefox support gopher?
15:23:22 <elliott> i think so. but nothing else does.
15:23:24 <atp> elliott: you're not actually saying that twitter is an improvement on finger are you
15:23:29 <elliott> and firefox desperately wants to get rid of it
15:23:30 <Eduard_Munteanu> roconnor: they removed it recently
15:23:35 <elliott> atp: did i say ghc was an improvement on gofer?
15:23:36 <Eduard_Munteanu> roconnor: but it's still available as an addon
15:23:36 <hpc> atp: EVERYTHING is an improvement on finger
15:23:42 <elliott> finger is awesome!
15:23:43 <sshc> Does anybody here have any suggestions for improving my ~2 minute link time?
15:23:47 <atp> hpc: finger is the bomb
15:23:54 <sshc> Why would linking take so long?
15:24:01 <atp> hpc: when the internet became shitty enough that we couldn't have finger, that's when life started to suck
15:24:05 <hpc> are we talking about finger the idea, or finger the implementation?
15:24:15 <c_wraith> sshc: because ld sucks. :(
15:24:31 <kmc> sshc, switch to 'gold'
15:24:37 <maurer_> sshc: "gold"
15:24:38 <kmc> 2 minutes is excessive thoug
15:24:43 <kmc> what are you linking?
15:25:00 <hpc> because one is neat, and the other a gaping wide security hole
15:25:02 <elliott> roconnor: um, can't use irc any more, let's switch over to talk(1)
15:25:06 <monochrom> the gold linker seems to work nicely
15:25:10 <elliott> hpc: how on earth is finger a security hole?
15:25:15 <roconnor> elliott: talk is way better than irc
15:25:17 <atp> elliott: just a sec, i'll PHONE you from my VAX
15:25:36 <hpc> i thought it had an overflow bug that let you run arbitrary code
15:25:41 <maurer_> atp: I know a guy who sitll runs his mail off a VAX. He's crazy.
15:25:50 <maurer_> s/sitll/still/
15:25:53 <atp> hpc: it did, there was a worm back in the day that used it
15:26:00 <sshc> I actually haven't heard of "gold"
15:26:01 <Cale> Linking anything big is always insanely slow.
15:26:03 <lpsmith> the F-22 is still based on the VAX
15:26:03 <sshc> Thanks, I'll google it
15:26:04 <elliott> roconnor: yeah, you can see all my webaskjn^Wembario^H^Hrasing typos as i make them god talking to this guy is so boring^W^W^W^W^W^W^W :)
15:26:15 <atp> maurer_: i actually liked vms, but whatever
15:26:16 <roconnor> gopher://gopher.floodgap.com/1/
15:26:26 <elliott> <hpc> i thought it had an overflow bug that let you run arbitrary code
15:26:35 <sshc> Cale: Would dynamic linking improve speed?
15:26:37 <elliott> and IIS has had loads of security holes too!
15:26:41 <elliott> web sucks
15:26:51 <monochrom> linking to dynamic libs improves linking speed
15:26:54 <Cale> When I build our game in XCode, it takes something like 4 or 5 minutes to link everything.
15:26:54 <hpc> elliott: anyone who uses IIS deserves it though :P
15:27:02 <elliott> hpc: apache has not had none either
15:27:03 <monochrom> hehehe
15:27:20 <hpc> apache is fat as hell though
15:27:32 <hpc> and nobody exploits it anyway, because joomla is so easy to crack
15:27:34 <Heffalump> why is linking so slow?
15:27:35 <roconnor> man
15:27:42 <elliott> hpc: if djb didn't write it, it has security holes.
15:27:44 <Cale> Well, that might be an exaggeration, it's been a while since I last had to use XCode.
15:27:45 <elliott> :)
15:27:50 <roconnor> I'm so redoing my blog on gopher
15:27:58 <elliott> roconnor: support so hard
15:28:07 <roconnor> elliott: how so?
15:28:19 <elliott> roconnor: oh, assume I put a comma after support and an i before support
15:28:23 <atp> roconnor: make sure to use gopher tunnelled over fidonet
15:28:37 <atp> roconnor: if you can get a ham radio in the path that would be ideal
15:28:40 <roconnor> I'll serve HTML 5.0 over gopher
15:28:44 <elliott> no no no, just put a gopher client connecting to a localhost-bound server up on the net exposed via telnet
15:28:45 <Cale> But the round-trip for compiling the game and seeing if something works is about 10 minutes. Of course, that's XCode + iPhone Simulator in VMware, and I think there's some kind of bad interaction which is slowing it down even more than it normally would be.
15:28:46 <Eduard_Munteanu> Can't we all just go back to BBS?
15:28:46 <atp> roconnor: we can party like it's 1977
15:28:47 * monochrom switches to AOL
15:28:50 <elliott> preferably a graphical one
15:28:52 <elliott> use ssh x forwarding
15:29:15 * monochrom logins to AOL and types in 'go #haskell" to get here!
15:29:16 <hpc> ssh+x: the ghetto vm
15:29:39 <atp> i can't believe there are still gopher servers
15:29:55 <monochrom> actually is that AOL or is that CompuServe? :)
15:29:59 <napping> elliott: I'd rather run a server proved by Xavier Leroy than written by djb
15:30:00 <hpc> (now watch me not mention how i am running this irc client :P)
15:30:16 <maurer_> Clearly, we should all be running L4.verified
15:30:17 <elliott> napping: psht, he had to write a whole system to find his bugs!
15:30:21 <elliott> (Coq :P)
15:31:17 <atp> elliott: as opposed to djb, who mainly just denies his bugs are bugs by redefining the term
15:31:34 <elliott> atp: afaik that has only arguably happened once
15:31:34 <atp> elliott: i will admit that he writes beautiful code however, insofar as C can be
15:31:42 <elliott> with the qmail lots-of-ram-dedicated-to-qmail case
15:31:46 <elliott> do you know of another?
15:31:55 <atp> elliott: no, i'm just pushing your buttons :p
15:31:58 <Heffalump> there's a whole webpage about them, isn't there?
15:31:59 <elliott> (my leroy comment was a joke btw :))
15:32:08 <elliott> (Coq is awesome)
15:32:13 <atp> yes, i love coq
15:32:34 <elliott> inevitable joke in 3, 2, 1
15:32:36 <atp> although it's support for coinduction is kind of warty
15:32:37 <companion_cube> who is "djb" ?
15:32:44 <Eduard_Munteanu> I'd @remember that if there weren't so many already.
15:32:46 <elliott> copton: daniel j. bernstein
15:32:52 <elliott> ...
15:32:53 <elliott> companion_cube:
15:33:10 <elliott> Eduard_Munteanu: What, so many quotes?
15:33:10 <atp> i was reading RFC 1143 the other day and it was written by djb, i had no idea
15:33:16 <elliott> Isn't that the point of a QDB? :)
15:33:21 <atp> he must have been like 20 when he wrote it
15:33:31 <elliott> "The Q Method of Implementing TELNET Option Negotiation" -- exciting.
15:33:33 <Eduard_Munteanu> Too many Coq-related quotes.
15:33:39 <elliott> @quote coq
15:33:39 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
15:33:44 <Eduard_Munteanu> @quote kmc.coq
15:33:44 <lambdabot> No quotes match. My mind is going. I can feel it.
15:33:44 <elliott> :-D
15:33:48 <Eduard_Munteanu> @quote coq
15:33:48 <lambdabot> sorear says: <sorear> Unfortunately, Coq *cannot* prove that your program will terminate before the heat-death of the universe. <psnively> Right. That's a software engineering problem, not a
15:33:48 <lambdabot> computer science problem. ;-)
15:33:52 <companion_cube> never heard of him before :/
15:34:11 <elliott> companion_cube: then you probably haven't heard of most people :P
15:34:21 <roconnor> Eduard_Munteanu: that's because Coq assumes the exponential function is total.  it is stupid and evil.
15:34:22 <hpc> hey, none of this Coq talk, there are kids in this channel! :P
15:34:29 <Eduard_Munteanu> Heh.
15:34:41 <atp> roconnor: it is, technically
15:34:45 <atp> roconnor: just not in practice :)
15:34:46 <elliott> hpc: DING DING DING
15:34:47 <blackdog> elliott, companion_cube: redo is interesting. seen apenwarr's implementation?
15:34:49 <companion_cube> well, from what i read in wikipedia, he mainly worked in security or crypto ?
15:34:50 <elliott> inevitable joke reached
15:35:04 <elliott> blackdog: i prefer languages and systems that don't need explicit build steps. :)
15:35:16 <elliott> companion_cube: networking too, about equally
15:35:20 <atp> companion_cube: he's a bit of a legend, a larger-than-life personality in the early internet days
15:35:22 <elliott> though ofc a lot of engineering work counts as security.
15:35:25 <blackdog> elliott: which would they be?
15:35:32 <blackdog> even ruby needs bundler, capistrano etc...
15:35:35 <atp> companion_cube: if you were active in late 80s early 90s he was basically a god in a pretty small community
15:35:43 <companion_cube> uh, ok, i'm just ignorant (and young :þ)
15:35:48 <elliott> blackdog: For instance Haskell (ghc --make/ghci is just the interface to Unix).
15:35:56 <elliott> blackdog: But a better example is Smalltalk.
15:36:02 <Eduard_Munteanu> Theorem: the sequence of conversations about theorem proving and total languages inevitably converges to a joke about body parts.
15:36:24 <elliott> (Modern Smalltalk is quite useless because it's a programming language with neutered interfaces to the OS, in a box; Smalltalk-80, however, was an operating system.)
15:36:24 <atp> Eduard_Munteanu: this is INRIA's fault
15:36:37 <blackdog> elliott: Haskell still needs cabal or equivalent for package management
15:36:42 <elliott> atp: *the French's
15:36:55 <companion_cube> you know what "coq" means in french, right ?
15:36:55 <elliott> blackdog: That's also the interface to Unix. :-) But like I said, see Smalltalk.
15:36:56 <blackdog> elliott: and smalltalk suffered from the lisp problem of wanting to be the whole world
15:37:03 <atp> elliott: well to be fair Coq has none of the meanings it has in ENglish in french
15:37:08 <elliott> blackdog: Unix suffers from the problem of wanting to be the whole world.
15:37:22 <blackdog> that's its only job, though;)
15:37:30 <elliott> blackdog: So is Smalltalk's.
15:37:30 <roconnor> One awesome thing about NixOS, is that I can reread the build log of any software that I built on my system.
15:37:33 <atp> and it does it poorly
15:37:38 <Cale> Who here knows CLP well and can help gio123?
15:37:46 <elliott> Unix has realigned the discourse by making people think an OS has to be A, B and C or it's just a language.
15:37:51 <sshc> kmc, maurer_: I've install aur/gold-cvs.  How do I tell cabal to use the gold linker?
15:37:56 <sshc> Also, thanks for your help
15:38:04 <elliott> e.g. A = "Support no language well, but support C the best".
15:38:18 <blackdog> elliott: unix is a low-level bridge, though. it's easy to hook up diverse languages to cooperate. can you easily pull in python, C, haskell from smalltalk?
15:38:22 <elliott> (Sometimes erroneously called "language agnosticism", as if a language system cannot host other languages.)
15:38:22 <Eduard_Munteanu> What's CLP?    ("now you have 2 problems")
15:38:23 <Cale> gio123 is reading this paper and needs help with it: http://www.cse.unsw.edu.au/~mmaher/pubs/cp/clptheory.pdf
15:38:30 <Cale> Eduard_Munteanu: Constraint logic programming
15:38:33 <elliott> blackdog: Yes (but I don't think this has been done). However, look at Lisp Machines.
15:38:41 <atp> blackdog: you only think it's easy because someone else wrote the bridge for you
15:38:45 <elliott> blackdog: There was at least one (I think more than one) C compiler for the Lisp Machines.
15:39:01 <maurer_> sshc: Check your distro, likely there will be a command like "update-alternatives" that will let you set what the ld command invokes
15:39:05 <blackdog> atp: actually, that's not true. I wrote a bridge between ruby and haskell, i do know what's involved.
15:39:11 <elliott> blackdog: It is just as hard as pulling any other language into Unix. (Except not so hard because you don't have to fight with Unix itself...)
15:39:28 <atp> blackdog: i mean the OS interface stuff.
15:39:29 <maurer_> sshc: Otherwise just "ln -s /usr/bin/gold /usr/local/bin/ld"
15:39:34 <atp> blackdog: since you were talking about UNIX.
15:39:36 <maurer_> And it'll probably work right :P
15:40:21 <blackdog> atp: then i don't understand what you mean.
15:40:45 <atp> blackdog: well, you were suggesting that UNIX makes working with many languages easy, when in fact it does no such thing
15:40:56 <sshc> maurer_: Oh, I thought "ld" itself was a linker.  What is the default linker "ld" uses?
15:41:09 <Eduard_Munteanu> ld is a linker.
15:41:31 <Zao> 'ld' is a name that many different linkers use.
15:41:36 <elliott> Unix favours the programming language UnixLang, a really bad language with no decent control structures where every variable is either a map from strings to variables or a bytestring, that everyone would hate if they actually realised it was a language.
15:41:39 <Eduard_Munteanu> Yeah, that's more accurate.
15:41:43 <elliott> (atp: )
15:41:43 <sshc> (I use archlinux, for what it's worth)
15:41:46 <Eduard_Munteanu> Just like 'cc'
15:41:59 <Eduard_Munteanu> There's GNU ld, GNU cc ...
15:42:21 <Eduard_Munteanu> (aka gcc)
15:42:23 <blackdog> atp: and yet it seems to have happened - there are bridges all over the place working with unix.
15:42:30 <blackdog> it might be a worse-is-better sort of argument
15:42:39 <elliott> blackdog: But it would be easier in another system.
15:42:44 <atp> blackdog: yes, obviously. but that doesn't mean it's because it's easier.
15:42:46 <elliott> Or at the very, very least AS easy.
15:43:12 <atp> blackdog: UNIX owes its popularity largely to being in the right place at the right time.
15:43:25 <atp> blackdog: don't get me wrong, i'm typing this from a nix system
15:43:31 * hackagebot boomslang 0.0.3 - Boomshine clone  http://hackage.haskell.org/package/boomslang-0.0.3 (BrianLewis)
15:43:34 <sshc> Ah, binutils now already comes with gold
15:43:37 <elliott> (Me too, but only because it killed off everything else.)
15:43:40 <atp> blackdog: but it's actually a pretty shitty OS
15:43:44 <Eduard_Munteanu> Really?
15:43:54 <elliott> gold has been part of binutils since forever :)
15:43:59 <sshc> Wonderful!
15:44:01 <sshc> "Gold is now included with binutils-2.21 in Core (named ld.gold)."
15:44:07 <Zao> elliott: Internet forevers?
15:44:13 <blackdog> atp: ah, right. so we're talking about a hypothetical world where smalltalk or some equivalent system got hugely popular - notional usability
15:44:14 <elliott> Zao: wut
15:44:29 <elliott> blackdog: Nice -- so since Unix won, every discussion of other systems is irrelevant?
15:44:31 <blackdog> i thought we might be talking about current possible solutions, excuse me :)
15:44:44 <elliott> blackdog: Catch 22.
15:44:48 <napping> elliott: even so, object languages tend to require everything that wants to talk to them to pretend to be an object
15:44:49 <Eduard_Munteanu> Interesting. I wonder if there are significant differences from plain 'ld' (support for linker scripts etc)
15:44:54 <blackdog> elliott: no, it's fine. I just thought we were talking about something else.
15:45:11 <elliott> blackdog: OSes don't have to be hugely popular to work nowadays, anyway.
15:45:15 <elliott> If you have a web browser, that's 90% of it.
15:45:33 <hpc> the other 10% is being able to develop in your favorite language
15:45:55 <elliott> hpc: Don't be silly: the system *is* your favourite language. :)
15:46:01 <blackdog> hpc: if that language is javascript:)
15:46:03 <atp> hpc: woe is me, ghc doesn't work on OpenVMS itanium
15:46:10 <hpc> lol
15:46:19 <elliott> atp: I sure hope you're joking or I might have to disown you :)
15:46:30 <atp> elliott: :p
15:46:58 <atp> elliott: let me just fire up my symbolics machine here and see how well ghc runs
15:47:04 <elliott> atp: *hi5*
15:47:35 <napping> atp: what are you talking about? Just dig up an old copy of Yale Haskell
15:47:46 <hpc> all of you are OS hipsters
15:47:52 <atp> napping: for openvms itanium?
15:48:08 <atp> napping: god did HP ever bet on the wrong horse
15:48:08 <napping> no, that's the early compiler done in lisp
15:48:09 <napping> I think
15:48:13 <hpc> trying to use the most obscure system possible to power your super-abacus
15:48:17 <atp> napping: oh, i see
15:48:23 <Eduard_Munteanu> Heh
15:48:29 <elliott> hpc: And Dvorak users are keyboard hipsters!
15:48:32 <atp> napping: if it doesn't have functional dependencies i don't want to be right
15:48:41 <atp> elliott: hey i use dvorak
15:48:48 <elliott> atp: I was mocking the joke. :)
15:48:54 <atp> elliott: oh
15:49:08 <hpc> elliott: no, maltron
15:50:15 <paulh> Can someone explain this? http://hpaste.org/44754/bindings
15:50:57 <hpc> paulh: look up do notation, and what fail does
15:50:58 <atp> napping: good call, it was yale haskell
15:51:15 <accel> is there work on the following tool: takes as input a *.hs file, and compiler optimiation flags; as otput, it dumps out what the code is transformed into after each optimization pass ?
15:51:42 <atp> accel: you mean the core code?
15:52:00 <Eduard_Munteanu> -ddump...
15:52:14 <atp> accel: you can get this information by reading core, but it's a bit different from vanilla haskell
15:53:36 <accel> atp: how does it differ from vanilla haskell?
15:53:44 <accel> Eduard_Munteanu: will look into that; thanks
15:53:52 <elliott> accel: It's even less readable!
15:53:57 <Eduard_Munteanu> :))
15:53:58 <elliott> tauntaun_drying: That's, uhh, specific
15:54:35 <atp> accel: quite considerably
15:54:45 <atp> accel: Real World Haskell discusses it a bit from a beginner's perspective
15:54:48 <kmc> accel, most syntactic sugar is removed; type classes are replaced by explicit dictionaries; polymorphism done with explicit type abstraction and application
15:55:07 <DevHC> can anyone show me a non-obscure use of maybeWith?
15:55:17 <kmc> @hoogle maybeWith
15:55:18 <lambdabot> Foreign.Marshal.Utils maybeWith :: (a -> (Ptr b -> IO c) -> IO c) -> Maybe a -> (Ptr b -> IO c) -> IO c
15:55:18 <lambdabot> Data.IntMap mapMaybeWithKey :: (Key -> a -> Maybe b) -> IntMap a -> IntMap b
15:55:18 <lambdabot> Data.Map mapMaybeWithKey :: Ord k => (k -> a -> Maybe b) -> Map k a -> Map k b
15:56:09 <monochrom> I wonder what it does when given Nothing
15:56:31 <accel> atp , kmc : what is core written like that?
15:56:36 <accel> atp, khc: isn't ghc self hosting?
15:56:38 <kmc> :t Foreign.maybeWith Foreign.C.String.withCString
15:56:38 <lambdabot> forall c. Maybe String -> (GHC.Ptr.Ptr Foreign.C.Types.CChar -> IO c) -> IO c
15:57:03 <DevHC> apparently it passes nullPtr to the 2nd function
15:57:04 <atp> accel: yes, but ghc "simplifies" (from a compiler's perspective) haskell down to something more manageable and regular before trying to optimize
15:57:27 <atp> accel: it strips out syntactic sugar, it monomorphizes, etc
15:57:31 <accel> yeah; but why is core written like that?
15:57:39 <sphynx> > filter (maybe False (const True)) [Just 2, Nothing, Just 5]
15:57:40 <lambdabot>   [Just 2,Just 5]
15:57:44 <kmc> accel, because it's simpler to compile Core to machine code than to compile Haskell to machine code
15:58:00 <sphynx> are there any other, more natural way of filtering out Nothings from a list?
15:58:01 <kmc> accel, how much do you know about how compilers work?
15:58:09 <kmc> sphynx, catMaybes
15:58:10 <DevHC> > malloc 4
15:58:11 <lambdabot>   Not in scope: `malloc'
15:58:13 <monochrom> ah, the doc says "nullPtr if Nothing" too
15:58:15 <atp> accel: it's an intermediate representation, kind of like how gcc compiles C into a portable Lisp-like (syntax-wise) form before generating code
15:58:32 <levifikri> I wish to convert Int64 to Double, and vice versa. Anyone could suggest how to do this?
15:58:37 <napping> sphynx: catMaybes
15:58:39 <accel> i've written a java -> mips compiler before
15:58:42 <Zao> levifikri: Define "convert".
15:58:52 <Zao> levifikri: Numerically or bit-twiddlingly?
15:58:59 <sphynx> kmc: thanks!
15:59:18 <monochrom> if you understand maybeNew, maybeWith is a nicer repackaging of maybeNew, i.e., does the allocation and deallocation for you.
15:59:20 <mauke> levifikri: fromIntegral, round
15:59:21 <kmc> accel, did you go straight from full-blown Java syntax to MIPS assembly, or did you compile through some intermediate forms?
15:59:24 <levifikri> numerically
15:59:36 <DevHC> monochrom: doubtfully
15:59:52 <DevHC> maybeWith takes a function and returns a function
16:00:08 <monochrom> that's beside the point
16:00:10 <accel> kmc: we took java, parsed it, converted it to TAC, then to mips assembly
16:00:16 <kmc> accel, what's TAC?
16:00:20 <accel> three address code
16:00:24 <kmc> ok
16:00:32 <accel> we did some constant fold / common sub expression optimizations too
16:00:37 <DevHC> hold on, lemme upload an "obscure" use of maybeWith
16:00:46 <atp> accel: on the java AST?
16:00:46 <accel> kmc: impressed yet? :-D
16:00:52 <atp> accel: directly?
16:01:00 <accel> atp: this was 4 years ago
16:01:08 <kmc> accel, so you understand that compilers go through several intermediate forms
16:01:09 <monochrom> you may as well say "what is the use of (+)?" and I may say "it adds" and you retort "I doubt it, it returns a function"
16:01:23 <accel> right; what I don't understand is that if we can use ghc to compile core
16:01:28 <accel> why write core in some intermediate format
16:01:31 <accel> instead of full haskell
16:01:34 <mauke> wat
16:01:43 <atp> accel: because full haskell is needlessly complex
16:01:43 <kmc> "Core" and "Haskell" are the names of two languages
16:01:48 <kmc> i don't understand your question
16:02:05 <Eduard_Munteanu> accel: that's like asking "why use SSA?".
16:02:06 <accel> Hmm, I thought core = a part of the ghc source tree
16:02:09 <kmc> no
16:02:10 <accel> not a separate language
16:02:16 <kmc> "Core" is a minimal Haskell-like language
16:02:17 <atp> accel: it's like in C: foo[i] is really just syntactic sugar for *(foo + i)
16:02:27 <napping> core is the intermediate language where GHC actually applies optimizations
16:02:34 <accel> hang on; when we say "Core"
16:02:35 <kmc> some optimizations anyway
16:02:45 <napping> so if you want to see your program with optimizations applies, you read Core (or maybe the assembly after than)
16:02:48 <accel> are we talking  (1) the output of -ddump or (2) parts of the ghc tree?
16:02:52 <kmc> (1)
16:02:54 <accel> ah
16:02:56 <kmc> <kmc> "Core" is a minimal Haskell-like language
16:03:01 <accel> I understand now.
16:03:05 <DevHC> monochrom: that's not a valid argument. maybeWith does NOT allocate and deallocate for u
16:03:08 <accel> is there a spec for Core?
16:03:18 <accel> (in particular, does Core dictate laziness / strictness?)
16:03:19 <atp> accel: the GHC sources :)
16:03:28 <kmc> Core isn't a standardized language the way Haskell is
16:03:29 <atp> accel: it does sort of, with let bindings and case bindings
16:03:40 <Eduard_Munteanu> There's something for STG, but I'm not sure for core. (don't ask about STG)
16:03:46 <atp> accel: let more or less introduces a thunk and case more or less reduces one
16:03:48 <kmc> Core is lazy, but afaik its "case" always forces evaluation
16:04:00 <kmc> unlike Haskell where "case e of x" doesn't force anything
16:04:07 <kmc> this makes Core operational semantics much simpler
16:04:14 <kmc> which is a good reason to use it during optimization passes
16:04:31 <napping> also, function annotations show inferred laziness
16:04:35 * hackagebot Hsed 0.2.2 - Stream Editor in Haskell  http://hackage.haskell.org/package/Hsed-0.2.2 (VitaliyRukavishnikov)
16:04:38 <accel> 'case reduces', as in seq or deepseq ?
16:04:51 <napping> The Fc papers describe the type system
16:04:53 <monochrom> as in seq
16:04:55 <kmc> case forces to weak head-normal form, same as "seq"
16:04:56 <atp> accel just to WHNF i think
16:05:31 <Eduard_Munteanu> Hm, that hsed sounds interesting.
16:06:10 <atp> accel: you know a good exercise that makes a lot of this clear pretty fast is trying to write a lazy CPS transformation
16:06:41 <accel> continuation passing style?
16:06:47 <accel> what does that have to do with haskell?
16:07:07 <atp> accel: because lambda calculus in CPS form has an explicit evaluation order
16:07:25 <atp> accel: so if you take a simple lambda calculus interpreter, and try to do the conversion
16:07:42 <atp> accel: you know?
16:08:10 <atp> accel: because in lambda calculus by itself strict and lazy are equivalent
16:08:35 <atp> accel: but in CPS the structures will be different
16:08:40 <atp> accel: depending on which you choose
16:08:58 <accel> atp: link for exercise you described in detail?
16:09:04 <accel> this soudns like the type of exercise
16:09:06 <accel> I need to do
16:09:10 <accel> before I ask more stupid quetions
16:09:12 <accel> and get kicked
16:09:18 <atp> accel: there's no link really, it's just an idea to think about in your head
16:09:28 <atp> accel: lots of olivier danvy's papers are instructional i guess
16:09:54 <atp> accel: also we don't kick on #haskell i don't think :)
16:10:17 <lispy> if we kicked for stupid questions, I would have been booted ages ago
16:10:20 <accel> my ability to be annoying exceeds ops's patience; I've been kicked twice so far
16:10:22 <kmc> people do get kicked
16:10:31 <kmc> not for asking dumb questions but for being annoying
16:10:33 <kmc> i.e. being trolls
16:10:41 <accel> or asking for a list of who the ops are
16:10:44 <atp> accel: alternatively (and perhaps simpler) just write a simple lazy lambda calculus interpreter that has integers and a simple case statement
16:10:44 <kmc> accel, you were kicked for being a troll
16:11:02 * lispy goes to dig into cabal again (stupid cabal build system bugs...grr)
16:11:04 <napping> accel: I don't know if GHC uses it, but CPS transform is also often used in functional language compilers for similar purposes as the SSA form is used in imperative language compilers
16:11:17 <atp> yeah, CPS is really central to FP
16:11:27 <accel> i belive the chicken scheme interpreter is all cps
16:11:41 <accel> however, i fail to see the connection of why cps is special in the context is laziness
16:11:46 <atp> accel: chicken scheme does some weird stuff though
16:12:14 <atp> accel: think about a CPS transform: it labels all intermediate results, right
16:12:18 * kmc grumbles about "functional language" versus "imperative language"
16:12:29 <kmc> i suppose here it means something unusual: whether or not C's semicolon is a function
16:12:39 <kmc> as it is in Haskell
16:12:53 <atp> kmc: imperative languages are more about making mutability easy i think
16:13:04 <napping> kmc: I mean more whether higher order functions are supported (with proper lexical scoping)
16:13:08 <kmc> atp, but what does that have to do with SSA versus CPS
16:13:16 <kmc> napping, oh, but every halfway decent language supports those
16:13:22 <kmc> "imperative" doesn't mean "not functional"
16:13:43 <atp> kmc: yes you could completely simulate C with a state monad, but would you get many optimization benefits from that representation?
16:14:08 <atp> kmc: the choice of CPS for functional language compilers has more to do with the fact that inlining can be done safely, which is important for FP
16:14:20 <atp> kmc: at least as i understand it, my background is math, not CS
16:14:52 <atp> also i wonder how you would simulate volatile with a state monad representation
16:15:08 <kmc> atp, "safely" meaning "without changing side effects"?
16:15:09 <napping> kmc: imperative can also mean C-like (or perhaps Pascal-like)
16:15:20 <kmc> because most functional languages have unrestricted side effects with evaluation
16:15:40 <kmc> also i didn't say anything about state monads
16:15:43 <napping> I've never heard of CPS being used in a compiler for a language without higher order functions
16:16:19 <atp> kmc: that's true, perhaps i was reading in to what you were saying too much
16:17:06 <kmc> you can have a first-class sequencing operator without saying anything about how it's implemented
16:17:24 <kmc> GHC Haskell implements IO's (>>) in terms of special compiler primitives that break the usual rules
16:17:38 <kmc> other Haskell implementations might implement it by building an abstract syntax tree of deferred IO actions
16:17:45 <kmc> and none of this has anything to do with monads
16:17:58 <atp> kmc: it's all stores and loads at the bottom, the fact is that from a sufficiently highlevel standpoint the rules aren't broken and IO's implementation doesn't matter
16:20:41 <gio123> is there anybody familier with CLP?
16:21:53 <Eduard_Munteanu> gio123: ask your question directly
16:22:46 <gio123> to long question..., first I need to find if there is somebody has knowladge in foundation of CLP
16:23:08 <gio123> I am reading a paper and some problem to undestand proof there...
16:23:45 <Eduard_Munteanu> Go on...
16:23:51 <mauke> how about no
16:23:58 <mauke> this is #haskell
16:24:22 <Eduard_Munteanu> Ok, try on #haskell-blah or somewhere else.
16:24:43 <DevHC> http://hpaste.org/44755/obscure_use_of_maybewith_and
16:25:02 <paulh> what is the easiest way to look up class instances?
16:25:13 <DevHC> ^ kmc monochrom
16:25:19 <Eduard_Munteanu> (just don't ask to bug somebody privately)
16:26:00 <paulh> never mind
16:26:25 <atp> well i better crash take care guys
16:28:05 <monochrom> usually the first function you give to maybeWith is something already in the lib such as withCString (like kmc said) rather than a homebrew function.
16:29:05 <monochrom> the doc also says "converts a withXXX function to ..."
16:29:26 <DevHC> D:
16:29:39 <monochrom> have you seen the doc?
16:29:49 <DevHC> uhm, chakravarty's :P
16:30:59 <DevHC> "This function lifts a MarshalAlloc.alloca based marshalling function for a to Maybe a. It marshals values Nothing in the same way as maybeNew."
16:31:38 <DevHC> maybeNew :: "Lift a function that marshals a value of type a to a function that marshals a value of type Maybe a. In case, where the latter is Nothing, return Ptr.nullPtr."
16:34:02 <monochrom> those withXXX functions count as "alloca based"
16:34:42 <DevHC> sort of noticed
16:35:25 <monochrom> and not to be anal about "must call alloca", the spirit is that a withXXX function does allocation at the beginning and deallocation at the end, i.e., as a memory management wrapper.
16:35:48 <monochrom> also probably deallocates fine if exception
16:36:22 <DevHC> yes, alloca deallocates upon exceptions
16:36:46 <DevHC> http://www.google.co.uk/search?hl=en&source=hp&q=haskell+maybeWith&aq=f&aqi=&aql=&oq= <-- apparently maybeWith is used once. ONCE.
16:36:50 <DevHC> :D
16:37:12 <megajosh2> Hey, has anybody successfully installed curl-1.3.6 on windows?
16:37:28 <monochrom> so withMaybe's purpose is "wouldn't it be nice if those withXXX functions worked for Maybe types too"
16:37:44 <megajosh2> It keeps telling me that the curl libraries aren't found, when I've added them to a lot of different places I'd expect to be checked
16:38:17 <moisan> Hi, I have a type [(Bool, IO String)] and I want to putStrLn each pair, how can I do that easily? I tried with mapM_ without success
16:38:47 <megajosh2> You want to print the string, or the literal tuple?
16:39:04 <moisan> the string
16:39:17 <megajosh2> mapM_ (putStrLn.snd)
16:39:21 <megajosh2> Try that
16:39:39 <megajosh2> Wait a minute
16:40:07 <moisan> megajosh2 : nice but it complains about IO String that should be String
16:40:15 <megajosh2> Yeah I saw that made no sense
16:40:36 <moisan> I'm in a "do" block but I don't know how do use the "<-" in a mapM
16:40:48 <DevHC> mapM_ (\p -> snd p >>= putStrLn)
16:41:33 <elliott> mapM_ ((>>= putStrLn) . snd)
16:41:43 <DevHC> why u
16:42:10 <moisan> DevHC : perfect thanks :)
16:43:16 <TheZimm> :t
16:43:17 <luite> or even  mapM_ (snd >=> putStrLn)
16:43:24 <DevHC> :O
16:43:25 <TheZimm> :t Map
16:43:25 <lambdabot> Not in scope: data constructor `Map'
16:43:26 <luite> (from Control.Monad )
16:43:37 <TheZimm> :t Tuple
16:43:38 <lambdabot> Not in scope: data constructor `Tuple'
16:43:41 <TheZimm> argh
16:43:58 <megajosh2> I forgot all about (>=>)
16:44:02 <DevHC> @pl \t -mapM_ ((>>= putStrLn) . snd)
16:44:02 <lambdabot> (line 1, column 4):
16:44:02 <lambdabot> unexpected "m"
16:44:02 <lambdabot> expecting "->"
16:44:05 <DevHC> ff
16:44:12 <DevHC> @pl \t -> mapM_ ((>>= putStrLn) . snd) t
16:44:12 <lambdabot> mapM_ ((putStrLn =<<) . snd)
16:44:30 <Axman6> TheZimm: what are you trying to do?
16:44:45 <DevHC> :i Tuple
16:44:58 <DevHC> @where tuple
16:44:58 <lambdabot> I know nothing about tuple.
16:45:30 <aavogt> sonoflilit: [| |] is just a convenient way to write ExpQ
16:45:50 <TheZimm> no idea :P
16:46:44 * hackagebot darcs 2.5.2 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.5.2 (GaneshSittampalam)
16:50:37 <gio123> to long question..., first I need to find if there is somebody has knowladge in foundation of CLP
16:52:36 <dons> nice. good work, Heffalump 
17:07:40 <Eduard_Munteanu> gio123: don't ask here and don't ask for private help or stuff like that
17:07:51 <moisan> Why can't I compare a Integer with a Rational? How can I work around that?
17:08:24 <Eduard_Munteanu> moisan: convert the Integer to a Rational
17:08:54 <Eduard_Munteanu> > fromInteger (4 :: Integer) :: Ratio Integer
17:08:55 <lambdabot>   4 % 1
17:09:05 <moisan> excellent, thanks
17:09:16 <Eduard_Munteanu> > (fromInteger (4 :: Integer) :: Ratio Integer)  <  5 % 8
17:09:17 <lambdabot>   False
17:09:36 <gio123> Eduard: I do not ask to private help to unknowns!!!
17:09:45 <gio123> and it is not ur busness where I ask
17:11:41 <Eduard_Munteanu> Ok. It seemed to me some other people were annoyed by those questions, including channel staff, since it's offtopic.
17:12:42 <Eduard_Munteanu> So you might have better luck asking in other channels.
17:14:49 <Eduard_Munteanu> (after all it's something usual that you don't ask to ask or for people "who might know")
17:16:19 <lpsmith> Ok,  I'm using Ubuntu and Synaptic says my libgmp version is 4.3.2,  but the .so file is /usr/lib/libgmp.3.5.2    Is there a correspondence between these numbers,  or should I not worry about it?
17:17:05 <napping> usually the numbers agree
17:17:06 <Eduard_Munteanu> lpsmith: not usually. The .so version is generally bumped with every ABI or semantic change.
17:17:33 <lpsmith> heh,  two contradictory answers :)
17:17:34 <napping> but the package version should be bumped for those reasons as well
17:18:08 <Eduard_Munteanu> So they could release a version of libfoo that improves performance or kills a bug, but if applications can continue to link to it without recompiling, the .so version isn't bumped.
17:18:09 <lpsmith> napping, but a new package version might not change the ABI or semantics 
17:18:30 <moisan> at which point can I mix guards with "let .. in" or "... where ..."? Is it possible?
17:19:15 <napping> guards definetely can't use definitions from a let in the body
17:19:20 <ezyang> moisan: Do a case. 
17:19:41 <napping> yeah, a case or local definition inside the scope of the let/where will work
17:19:53 <moisan> ezyang : didn't know case existed in haskell :P thanks
17:20:12 <lispy_> ezyang: I plugged in that code you gave me, but I'm still not having any luck
17:20:34 <ezyang> lispy_: :-/ Where are you at right now? 
17:20:41 <gio123> Eduard_Munteanu: I know the question I have is not related to haskell but there is no chanl which suports CLP. also it does not make sence to ask directly question here in the chanell since it is offtopic. 
17:20:46 <lpsmith> Doesn't moisan mean    let x | foo = ... | otherwise = ...?
17:20:46 <lispy_> ezyang: portland?
17:20:49 <lpsmith> that's legal
17:20:54 <ezyang> lispy_: Haha. 
17:21:06 <ezyang> As in, what's not working. What's the situation. 
17:21:11 <lpsmith> You can also do pattern matching in a let or where,  but it's irrefutable so it will never fail
17:21:14 <lispy_> ezyang: What should the extra-lib-dirs line look like in the .cabal file after I update my Setup.hs?
17:21:21 <moisan> lpsmith : no no I wanted let x in | foo = ... | otherwise = ...
17:21:31 <Eduard_Munteanu> gio123: there's #haskell-blah for that sort of unrelated stuff, I already suggested that to you.
17:21:33 <lpsmith> ahh
17:21:48 <gio123> ok
17:21:51 <ezyang> lispy_: Not set, but you still need Extra-libraries 
17:21:51 <gio123> I will go there
17:22:00 <lispy_> ezyang: it copies the file here correctly ./cabal-dev/lib/GLFW-b-0.0.2.2/ghc-6.12.3/shared/libglfw.dylib
17:22:03 <ezyang> (it should get overwritten anyway, though) 
17:22:10 <napping> gio123: repeatedly asking if anybody know is even more off topic
17:22:23 <ezyang> Ah. 
17:22:25 <lispy_> ezyang: but then ld complains that -lglfw cannot be found
17:22:29 <gio123> ok
17:22:35 <ezyang> I think... you need to use LD_PRELOAD_LIBRARY 
17:22:40 <ezyang> (or whatever it's called) 
17:22:55 <Eduard_Munteanu> LD_PRELOAD
17:22:56 <lispy_> when?
17:23:03 <lispy_> at run-time?
17:23:11 <lispy_> It's possibly to get this dylib statically linked in
17:23:18 <ezyang> Yes. 
17:23:22 <lispy_> That's what happens when I use an absolute path
17:23:29 <lispy_> It gets linked in and I can actually delete the .dylib
17:23:33 <ezyang> It's not possible to statically link in a dynamic library. 
17:23:53 <ezyang> (well, it should be possible, but IIRC it's fiddly and no one really does it) 
17:24:01 <lispy_> Well, I tried it and it worked
17:24:03 <ezyang> So, did you build a static version of the library? 
17:24:10 <Eduard_Munteanu> I'm not sure if there's any standard way to convert a .so into an .a
17:24:16 <ezyang> Oh. Hm. 
17:24:25 <lispy_> oh, yes, I guess it is a .a in reality
17:24:31 <moisan> ezyang : wait a second, how can I pattern match with case when I want to check if "k ==0" ?
17:24:37 <lispy_> $ file ./cabal-dev/lib/GLFW-b-0.0.2.2/ghc-6.12.3/shared/libglfw.dylib
17:24:37 <lispy_> ./cabal-dev/lib/GLFW-b-0.0.2.2/ghc-6.12.3/shared/libglfw.dylib: current ar archive random library
17:24:48 <lispy_> I'll rename it to .a
17:24:49 <ezyang> case k of _ | k == 0 -> 
17:25:13 <moisan> ezyand : ho, learn you a haskell confused me on this one thanks
17:25:13 <ezyang> I note that .a files ought to be dunked in ./cabal-dev/lib/GLFW-b-0.0.2.2/ghc-6.12.3, where they /will/ get picked up automatically. 
17:25:42 <ezyang> It was a delierate design choice to put shared files in shared/, so that GHC didn't default to dynamic linking. 
17:25:43 <Eduard_Munteanu> Is this dylib thingy a Haskell thingy?
17:25:51 <ezyang> It's dynamic libraries on Mac OS X 
17:25:56 <Eduard_Munteanu> Oh.
17:27:06 <Eduard_Munteanu> Unless you want to override some library linking in, using LD_LIBRARY_PATH might work too
17:27:18 <ezyang> lispy_: I'm a bit confused why your build system is outputting dylib files. 
17:28:32 <lispy_> ezyang: at one point I was building both a .dylib and a .a.  Then I simplified it a bit.  I'll just create the .a version.  Waiting to see if the changes build.
17:29:19 <ezyang> lispy_: The dylib file can still be handy if you want to load the library in ghci 
17:29:47 <lispy_> Okay, if I need it I'll add it back later.  I want to get it to work first
17:31:03 <ezyang> Ah, now I do remember building this up. Maybe I should write a blog post about it. 
17:31:26 <lispy_> Or fix Cabal :)
17:31:31 <ezyang> Fair enough :-) 
17:31:49 <dcoutts_> wasproblem? :-)
17:32:01 <lispy_> ezyang: I don't know if you saw it, but I was annoyed at the lack of objective-c support so I created this: http://hackage.haskell.org/trac/ghc/ticket/5025
17:32:13 <ezyang> dcoutts_: Essentially, Cabal has shitty support for Haskell packages that build their own external C libraries. 
17:32:26 <lispy_> dcoutts_: extra-lib-dirs needs to be absolute, so building a library as part of your package is excessively painful.
17:32:48 <dcoutts_> ezyang: for when you want them as separate C libs, rather than linked into the Haskell lib you mean. Yes.
17:33:11 <ezyang> dcoutts_: Both, unfortunately. 
17:33:52 <lispy_> dcoutts_: I also noticed a weird thing about c-sources.  For some reason, cabal hands c-sources to ghc instead of gcc.
17:34:15 <dcoutts_> lispy_: yeah, that's kind of annoying, I'd rather have it just use gcc directly.
17:34:16 <lispy_> dcoutts_: There's probably a reason, but it seems odd from where I'm sitting.
17:34:49 <lispy_> dcoutts_: It turns out to be quite limiting to do it this way (see the URL I gave ezyang)
17:34:50 <Eduard_Munteanu> Probably so they get linked into the executable as well when doing --make
17:35:03 <ezyang> dcoutts_: Because usually the external library has its own build process, so it'll generate its own .a file, and then there's no facility for blitting it into the generated Haskell .a file. 
17:35:18 <ezyang> and you'd have to relocate it to actually make that happen which is... messy. 
17:35:25 <dcoutts_> lispy: the objective c, yes, it's totally silly to use ghc as a C/C++/ObjC compiler
17:35:49 <ezyang> "What, you mean GHC doesn't mean Glorious Heterogenous Compiler?" 
17:35:53 <Eduard_Munteanu> Surely 'ld' can combine two .a's.
17:36:08 <dcoutts_> ezyang: right, anything more complicated than just simple C sources that can be built by the Simple build system itself is a pain.
17:36:47 <dcoutts_> ezyang: for that use case we would just want to have it separate, there's no point trying to merge into one .a file
17:36:49 <ezyang> Eduard_Munteanu: Probably. But you'll need to tell Cabal explicitly how to do that. 
17:37:18 <ezyang> And it turns out, just making sure the lib.a file ends up in the same place as the libHS.a file works quite well. 
17:37:24 <dcoutts_> Eduard_Munteanu: actually I don't think it's at all trivial. There's no portable support for it in ar afaik
17:37:37 <dcoutts_> but it's ok, since that's not the way you'd go anyway
17:37:54 <Eduard_Munteanu> dcoutts_: mmm, how do you make a static lib that depends on other static libs then?
17:38:07 <lispy_> dcoutts_: do you know why 'runhaskell Setup.hs makefile' was removed in Cabal 1.10?  Also, did you know that on the cabal documenation website cabal-latest links to 1.8 :(
17:38:38 <dcoutts_> Eduard_Munteanu: the thing with static linking is you need to list all the libs, so there's no special support for having them depend on each other
17:38:40 <ezyang> Eduard_Munteanu: "The static lib says so" 
17:38:56 <Eduard_Munteanu> Ah, yeah.
17:39:02 <ezyang> dcoutts_: Huh, I always thought static libs did have some sort of hinting info, even if it wasn't used. 
17:39:20 <ezyang> I guess I'm mistaken. 
17:39:25 <dcoutts_> lispy_: the makefile thing was only to support an old version of the ghc build system, it was not useful to anyone.
17:39:46 <dcoutts_> ezyang: shared libs have explicit deps on each other, not static libs afaik
17:39:50 <Eduard_Munteanu> Well, in any case, you can always subordinate Cabal to autotools or some plain Makefile :P 
17:40:03 <dcoutts_> lispy_: and yes, I've not updated the cabal website yet
17:40:16 <lispy_> dcoutts_: Hm...I've been thinking about cabal lately, and I think what I want (I can't speak for others) is to have cabal be a DSL for package deps and have it generate inputs to other build systems.  GNU make primarily.
17:40:48 <dcoutts_> lispy_: cool, you can make your own build system implementation, the "Simple" one is just one implementation.
17:40:50 <lispy_> dcoutts_: I think this would give me back parallel builds and a few other things
17:41:10 <dcoutts_> lispy_: the spec allows for any implementation so long as it conforms to the command line interface
17:41:18 <Eduard_Munteanu> I suppose Cabal could work as some sort of 'gcc -M'
17:41:37 <ezyang> dcoutts_: And the hooks API? :wink: 
17:41:37 <lispy_> so, that cabal configure ==> generates Makefile or cabal.mk and then you can wrap that or hook that into other makefiles
17:42:12 <lispy_> You get the constraint solver, but then you get control over how the building actually happens
17:42:13 <dcoutts_> ezyang: the hooks api is special to the "Simple" build system, another implementation would use something else
17:42:32 <ezyang> Oh, ok. 
17:42:57 <dcoutts_> lispy_: you get control by virtue of the fact that the build system has a command line interface and each package can use a different build system,
17:43:21 <lispy_> dcoutts_: I mean, you can't ask cabal to build just one exe out of a cabal file
17:43:26 <lispy_> dcoutts_: you can't do parallel builds
17:43:32 <lispy_> dcoutts_: you can't rebuild a single file
17:43:38 <dcoutts_> sure, lots of limitations to the Simple build system
17:44:53 <dcoutts_> lispy_: depending on where you want to direct your energy, we could add that to the Simple build system impl, or you could make a new independent build system impl
17:45:49 <lispy_> dcoutts_: I would want it to work for Simple builds, yes
17:46:02 <lispy_> Doing it for other builds would be much harder I assume
17:46:58 <ezyang> dcoutts_: I guess we're waiting for someone to flip out and write Build: Complex? :-) 
17:47:09 <dcoutts_> :-)
17:47:09 * ezyang hasn't really gotten sufficiently annoyed at it yet :-) 
17:47:33 <dcoutts_> there's also the makefile wrapper which has not recieved much love
17:47:49 <dcoutts_> build-type: Make
17:48:02 <Eduard_Munteanu> or... Build: Invoke Autotools And Call It A Day? :)
17:48:20 <lispy_> I have to use a makefile because GHC isn't a good Objective-C compiler, but at the same time I'm using build-type: Custom
17:48:38 <dcoutts_> Eduard_Munteanu: yes that's what build-type: Make does
17:49:05 <dcoutts_> and you can of course do anything via build-type: Custom
17:49:13 <dcoutts_> just implement the right command line interface
17:52:58 * hackagebot cab 0.0.0 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.0.0 (KazuYamamoto)
17:53:33 <lispy_> this is getting annoying.  On my mac I have to do 'sudo port deactivate libiconv' to build haskell stuff and then 'sudo port activate libiconv' to run anything built with macports :(
17:53:48 <dcoutts_> lispy_: btw, Joel Stanley has been working on a patch to handle components in a .cabal file better which should make it easier to build individual components as you're after
17:54:12 <lispy_> dcoutts_: ah, I didn't know that.  I don't talk to him much (he being in Texas), but that's good to know
17:54:25 <dcoutts_> lispy_: and a bit of work on the ghc command line handling should make cabal ghci and cabal build Module much easier to implement
17:54:54 <dcoutts_> lispy_: really none of it is that hard, there's just lots of stuff to do
17:55:27 <lispy_> I don't want to sound rude, but this where I think we should have made cabal into a DSL for makefiles.  Make does this stuff well already.
17:55:40 <dcoutts_> lispy_: it doesn't do it very well
17:55:46 <dcoutts_> we could do a lot better
17:56:32 <dcoutts_> lispy_: which is partly why we've not done it in a half-baked way yet, because we wanted a proper dependency-based build system
17:56:37 <dcoutts_> not just calling ghc --make
17:56:43 <dcoutts_> we did a GSoC project on it
17:57:03 <dcoutts_> perhaps we were too ambitious, worse is better and all that.
17:58:22 <lispy_> What is wrong with the way gnu make does it?
17:59:55 <dcoutts_> lispy_: http://www.well-typed.com/blog/13
18:00:58 <lispy_> dcoutts_: thanks, i'll read it as soon as I finish testing this package
18:01:17 <lispy_> I need to make sure it still works on windows/linux
18:03:28 <napping> dcoutts_: sounds like Nix-style chroots is the absolutely right way of making sure dependencies are captured
18:04:45 <dcoutts_> napping: oh I'm talking about things like file dependencies within a build-tree, not making sure the dependencies of a package are complete.
18:04:58 <dcoutts_> napping: so correct incremental rebuild
18:05:46 <napping> even within a tree, how do you restrict which other local files GHC reads?
18:06:35 <dcoutts_> napping: you need to know which files ghc will read to have a correct build rule
18:06:58 <dcoutts_> so it's not that we restrict it, but we need knowledge of what it's doing
18:07:25 <napping> and how do you know if you have a wrong rule, if the .hs file says import SomeLocalModule, and you didn't declare it in the rule?
18:07:35 <dcoutts_> (which tends to break abstraction barriers that programs erect, they don't want you to know what files they read in the background)
18:08:02 <napping> so you run ghc -v and see what it actually touches?
18:08:51 <dcoutts_> napping: you mean how would one test the correctness of a build rule?
18:09:06 <napping> yes
18:09:09 <dcoutts_> when one is calling out to an external process, outside of your make-like dsl
18:09:31 <dcoutts_> napping: ok, you can debug/test the rules using strace
18:09:42 * dcoutts_ has code to do this
18:09:46 <napping> Nix has a simple answer - run the build step in a chroot with just the packages it asked for
18:10:05 <dcoutts_> napping: that doesn't help, this is about individual build actions
18:10:21 <dcoutts_> not the entire build system as a whole
18:10:21 <napping> run each individual build step in it's own chroot!
18:10:54 <dcoutts_> ok, I guess that'd work. It's pretty extreme :-)
18:10:56 <napping> if you want the Right Thing!
18:11:16 <Saizan> a new chroot for each .hs file? vesta might be doing something like that
18:11:27 <napping> The problem with make is not so much that you can write bad rules, but that you don't realize they are bad
18:11:30 <dcoutts_> Saizan: really?
18:11:51 <napping> if you know the compiler, running with something like -v probably isn't too bad
18:11:59 <napping> if -v is more expensive than strace, something is really wrong
18:12:00 <Saizan> dcoutts_: yeah, iirc, i think they have a custom filesystem implementation, or something like that
18:12:21 <dcoutts_> Saizan: oh so they can construct that kind of chroot on the fly cheaply
18:12:53 <dcoutts_> with good OS control over the filesystem namespace, that approach might well be practical
18:13:34 <napping> It would be nice to properly track dependencies on system files as well
18:13:42 <Saizan> though they also warn to not assume the "environment", as it's called there, is a fresh one
18:13:50 <Saizan> so there might be some recycling
18:13:58 <napping> probably not require them to be declared, but record them at build time
18:14:28 <napping> getting a proper rebuild after upgrading libraries would be nice
18:21:11 <rostayob> Let's say I'm using the record syntax for a data type, and I want to have a function that modifies a certain fileld, depending on an argument. How can I do that?
18:21:51 <ezyang> rostayob: You can write it manually using record syntax. 
18:22:00 <ezyang> You could also use something like fclabels. 
18:23:47 <rostayob> ezyang: no wait... Let's say I have Foo { bar :: String, meh :: String}, I want to have a function that modifies one of the two. is this possible?
18:24:38 <parcs> rostayob: f foo = foo { bar = "hey" }
18:24:55 <djahandarie> modifyBar r v = r { bar = v }
18:25:17 <rostayob> parcs: no no, I want a function that it's linke fun :: Foo -> (Foo -> String) -> Foo
18:25:21 <rostayob> so I can decide which to modify
18:26:44 <napping> then you have to write that function
18:26:48 <Saizan> rostayob: if you pass it a (String -> Foo -> Foo) instead of (Foo -> String) it'll work
18:27:38 <Saizan> a pair of (String -> Foo -> Foo) and (Foo -> String) is what's called a label/lens/functional reference/..
18:27:39 <napping> update "bar" (con@Con { bar = x }) = con { bar = upd1 x} ; update "foo" (con@Con { foo = y}) = con {foo = upd2 y}
18:27:42 <napping> something like that
18:27:43 <rostayob> Saizan: yeah but I already know what I'm going to do to that field, I just want to be able to chose which field to modify from time to time
18:28:01 <napping> No general way would work if fields have different types
18:28:30 <rostayob> napping: yeah that would work but it's ugly, I was hoping for a better way but I suspected that it's not possible
18:28:35 <Saizan> rostayob: let me restate it like this: there's no built-in support for passing around "setters"
18:29:01 <Saizan> rostayob: though there are libraries about it, or you can just write the setters by hand and pass them around.
18:29:26 <Saizan> setBar v foo = foo { bar = v }
18:29:39 <Saizan> same for setMeh
18:29:53 <Saizan> them you can apply f to setBar or setMeh
18:30:00 <Saizan> *then
18:31:14 <rostayob> Saizan: yep, thanks.
18:40:58 <roconnor> is datatype one word in English?
18:41:08 * roconnor presumes not
18:41:19 <pastorn> roconnor: it is when it's popular enough
18:41:59 <ninly> i'm normally pretty liberal about allowing compounds in my usage, but that's not one i'd probably use
18:46:11 <lispy_> dcoutts_: I started reading that article. So I'm not really excited about writing makefiles by hand either.  I'm talking about having cabal generate them correct-by-construction first.  THen using make to actually build things.
18:46:35 <dcoutts_> lispy_: the other bit about expressiveness still applies
18:46:44 <roconnor> what article?
18:50:43 <dcoutts_> roconnor: http://www.well-typed.com/blog/13
18:51:02 <killing-joke> i want to generate a pseudorandom sequence. for a range of numbers 'r', i want to select each number once and only once for every 'r' iterations
18:51:22 <roconnor> dcoutts_: thanks
18:53:07 <killing-joke> i have been working with code linked from the Wikipedia article on linear congruential generators, but they are (perhaps obviously) more random than i require
18:55:54 <monochrom> to have each number appear exactly once is shuffling. http://www.haskell.org/haskellwiki/Random_shuffle
18:56:41 <killing-joke> monochrom, thanks! duh.
18:57:36 <killing-joke> wow. it's not a one-liner.
19:05:56 <roconnor> > choose . permutations -- one-liner
19:05:57 <lambdabot>   Not in scope: `choose'
19:07:53 <Axman6>  @src choose = (!! 4) >_>
19:08:08 <cole> What's the easiest way to replace "let value = myList !! 3" with "value * 3"? 
19:08:55 <Axman6> huh?
19:08:57 <cole> (How do I replace the third element in a list with its value times three?)
19:11:41 <geheimdienst> > (\(xs, (y:ys)) -> xs ++ (y * 3) : ys) $ splitAt 3 [1..9]
19:11:44 <lambdabot>   [1,2,3,12,5,6,7,8,9]
19:11:47 <geheimdienst> something like this?
19:24:45 <nic_> I have a question. In haskell when you use recursion to re-execute the main function until the user tell you to stop does it push a new instance on the stack every time or does it use a more memory efficient method? 
19:24:46 <Eduard_Munteanu> Hm, does this Haskell proof of forall <-> exists conversion formula look alright?  http://paste.pocoo.org/show/353292
19:25:04 <lispy_> nic_: haskell doesn't use a stack in the normal way
19:25:14 <Eduard_Munteanu> It compiles fine.
19:25:26 <Eduard_Munteanu> But is my abstraction correct?
19:25:27 <roconnor> nic_: function calls do not push stack frames in GHC.
19:25:39 <dibblego> Eduard_Munteanu: are you using leksah with unicode → ?
19:25:49 <Eduard_Munteanu> dibblego: no, Vim.
19:25:53 <dibblego> ok
19:25:58 <Eduard_Munteanu> It replaces -> with that as I type.
19:26:09 <dibblego> yeah so does leksah with "Candy mode" on
19:26:12 <roconnor> ... now that I think of coding dentiationally rather than operationally, call-by-value seems really stupid.
19:26:25 <dolio> Eduard_Munteanu: What is the exists datatype supposed to represent?
19:26:37 <nic_> roconnor: does this have to do with lazyness or is it something more complex?
19:26:53 <lispy_> nic_: it has to do with the reduction order
19:26:57 <roconnor> nic_: it is related to lazyness
19:27:08 <dibblego> roconnor: what is dentiationally?
19:27:27 <lispy_> nic_: You might enjoy reading this: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
19:27:30 * djahandarie assumes 'denotationally'
19:27:31 <roconnor> dibblego: when you think of the values denoted by expressions rather than how they are computer.
19:27:31 <Eduard_Munteanu> dolio: a formula that contains an existential quantifier
19:27:35 <roconnor> opps
19:27:36 <roconnor> yes
19:27:38 <roconnor> denotationally
19:27:46 <dibblego> ah right, yes, I have had this thought myself
19:27:47 <dolio> So, like Exists P ~ exists a. P a?
19:27:51 <nic_> thanks guys
19:28:19 <Eduard_Munteanu> dolio: yes, P is there so it looks more natural
19:28:22 <dibblego> have you tried to convince others? I find this difficult
19:28:30 <dolio> Then Exists is not defined correctly.
19:28:51 <dolio> It should be 'data Exists p = forall a. MkExists (p a)'.
19:28:54 <roconnor> dibblego: not yet
19:29:09 <Eduard_Munteanu> Oh, right I didn't think of employing type operators.
19:29:32 <Eduard_Munteanu> Thanks, lemme see how I can fix it (don't spoil it :D).
19:31:13 <Eduard_Munteanu> Hm, I kinda need a kind signature I think.
19:32:00 <dolio> Should be inferable, I think.
19:34:12 <Eduard_Munteanu> Hm, it wasn't that. I think I need another universally quantified variable.
19:34:18 <Eduard_Munteanu> (in the theorem)
19:35:51 <oxy__> hey there
19:36:19 <dibblego> hey oxy__ how goes?
19:37:47 <llayland> is there a standard name for:  foldr1 $ flip (.)
19:38:21 <roconnor> @type foldr1 $ flip (.)
19:38:22 <lambdabot> forall a. [a -> a] -> a -> a
19:38:32 <dibblego> llayland: it's pretty close to mconcat for the Endo monoid
19:38:46 <roconnor> llayland: flip (foldr ($))
19:38:53 <roconnor> @type flip (foldr ($))
19:38:54 <lambdabot> forall b. [b -> b] -> b -> b
19:39:18 <roconnor> > flip (foldr ($)) [f g h] x
19:39:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:39:19 <lambdabot>    `GHC.Show.Show a'
19:39:19 <lambdabot>      a...
19:39:21 <lispy_> silly, roconnor. Those types are totally different.  One uses b and the other is in terms of a.
19:39:22 <accel> (not trolling): since I really want control of when things get executed, shoudl I be using ocaml instead of haskell? since in ocaml, I can go f() f(); if I want it executed twice, and let x = f(); f1 x; f2 x; if I want it executed once and shared
19:39:27 <roconnor> > flip (foldr ($)) [f g h] x  :: Expr
19:39:27 <djahandarie> @type ala Endo foldMap
19:39:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:39:28 <lambdabot>    `GHC.Show.Show a'
19:39:28 <lambdabot>      a...
19:39:36 <roconnor> > flip (foldr ($)) [f, g, h] x
19:39:38 <lambdabot>   f (g (h x))
19:39:41 <accel> (not trolling): since I really want control of when things get executed, shoudl I be using ocaml instead of haskell? since in ocaml, I can go f() f(); if I want it executed twice, and let x = f(); f1 x; f2 x; if I want it executed once and shared [ there's absolutely no way in haskell to get this level of control right?]
19:39:45 <djahandarie> @type ala Endo Data.Foldable.foldMap
19:39:45 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
19:39:50 <roconnor> > foldr1 $ flip (.) [f, g, h] x
19:39:51 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
19:40:01 <roconnor> > (foldr1 $ flip (.)) [f, g, h] x
19:40:02 <lambdabot>   h (g (f x))
19:40:12 <roconnor> llayland: ah, sorry, they are different
19:40:21 <roconnor> llayland: your's is backwards :P
19:40:32 <dibblego> accel: haskell doesn't prevent you from doing this
19:40:40 <djahandarie> > ala Endo Data.Foldable.foldMap [f,g,h]
19:40:41 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:40:41 <lambdabot>    arising from a use of `...
19:40:47 <djahandarie> > ala Endo Data.Foldable.foldMap [f,g,h] x
19:40:48 <lambdabot>   f (g (h x))
19:40:51 <accel> dibblego: how so?
19:40:57 <djahandarie> Ah.
19:41:11 <accel> dibblego: !/seq lets me control strictness; but I don't see how it lets me control memoization/sharing
19:41:14 <dibblego> accel: I'm not sure why think it does, so I'm not sure how to answer your question
19:41:39 <Eduard_Munteanu> Does this express the theorem correctly?   direct :: forall (a :: * → *). Exists a → ((forall b. b → a b) → a ())
19:41:42 <dibblego> accel: there are plenty of ways to do this in haskell, though this is not how you worded your question
19:41:47 <lispy_> accel: there are ways to make sharing observable
19:41:50 <Eduard_Munteanu> I did the direct theorem, it compiled.
19:42:12 <accel> lispy_: please define observable
19:42:12 <Eduard_Munteanu> direct (MkExists f) g = g ()
19:42:29 <Eduard_Munteanu> Wait, it's fishy.
19:42:38 <lispy_> accel: laziness actually gives you more control over evaluation because you have more evaluation orders/strategies available.
19:43:17 <lispy_> accel: http://www.ittc.ku.edu/csdl/fpg/sites/default/files/20090903-hask.pdf
19:43:48 <dibblego> roconnor says it best imo
19:44:31 <accel> lispy_: looks nice; if you have more slides/papers related to shi, please send them to me too
19:44:48 <accel> if these guys are doing shit with xilinx flga, they know theri stuff
19:44:54 <lispy_> accel: honestly, that was the first link on google for observable sharing :)
19:44:56 <roconnor> well, my programming style explicitly opposes accel's premise.
19:45:07 <accel> lispy_: ouch
19:45:35 <accel> i'm goign to go hide in that corner and pretend I'm not lazy
19:45:37 <dolio> Eduard_Munteanu: exists a. P a <=> forall r. (forall a. P a -> r) -> r
19:45:37 <lispy_> it is by andy gill so yes it's a good source
19:45:50 <accel> @google andy gill
19:45:51 <lambdabot> http://www.ittc.ku.edu/~andygill/
19:45:51 <lambdabot> Title: Andy Gill | Functional Programming Group at KU
19:46:16 <accel> can I get lambdabot to visit a webpage, render it in lynx, and pump the output to a pm to me?
19:46:26 <lispy_> accel: this should be another good read: http://www.haskell.org/pipermail/haskell-cafe/2008-February/039639.html
19:47:02 <accel> added to reading list
19:47:10 <accel> what does andy gill mean in slide 3
19:47:12 <accel> slide 4
19:47:17 <accel> where he says "can we capture the structure of parity?"
19:47:28 <accel> wtf does "parity" mean ?
19:47:44 <Eduard_Munteanu> Hm, yes, I have to backtrack a bit.
19:47:44 <accel> s/parity/structure
19:48:13 <accel> also; i'm at slide 6; and he still deosn't define what 'observable sharing means
19:48:50 <accel> actually i just went through all 27 slides
19:48:56 <accel> and i till don't see the def of observable sharing
19:49:04 <lispy_> accel: well, he's defining a try but he wants a dag
19:49:04 <Eduard_Munteanu> dolio: actually shouldn't P be universally quantified too?
19:49:15 <lispy_> slide 9 is good
19:49:23 <lispy_> Anyway, I'm off to do chores.  Good luck.
19:49:24 <dolio> If you're proving the theorem for all P, then yes.
19:49:32 <Eduard_Munteanu> Yeah.
19:49:35 <dolio> But that would be outside the bi-implication.
19:49:48 <accel> what does observable sharing mean?
19:50:02 <Eduard_Munteanu> Oh, and 'r' on the inside!
19:50:24 <Eduard_Munteanu> Now it makes sense, lemme see.
19:50:34 <dolio> forall p. ((exists a. p a) <=> (forall r. (forall a. p a -> r) -> r))
19:50:54 <llayland> thanks.   yes I tend to do things backwards :)  and I'll look at the Endo monoid
19:51:02 <Eduard_Munteanu> Yep.
19:51:08 <accel> yo yo yo
19:51:15 <accel> what is observable sharing in haskell yo?
19:51:45 <Saizan> accel: stop repeating your question, if anyone wants to answer he's actually more likely to do it if you're less annoying.
19:51:52 <Kaidelong> wouldn't that neccessarily amount to "observable side effect"?
19:52:13 <Saizan> Kaidelong: no
19:52:21 <accel> Saizan: I was actually hoping if soeone knew the answer they would just give me a link rather than the effort to /ignore me
19:52:29 <Jesin> umm
19:52:31 <Jesin> [23:25:18]	<accel>	dibblego: !/seq lets me control strictness; but I don't see how it lets me control memoization/sharing
19:52:44 <accel> Jesin: yes
19:52:49 <Jesin> you can control memoization
19:52:49 <accel> Jesin: what about that?
19:52:57 <Jesin> eh
19:52:59 <Jesin> hm.
19:53:11 <Saizan> accel: it doesn't work like that, at least here.
19:53:16 <Jesin> what in particular do you want to control about it
19:53:35 <Jesin> or why
19:53:39 <Jesin> =/
19:53:56 <accel> http://hackage.haskell.org/trac/ghc/ticket/917#comment:7 <-- I know that there are other solutions to this problem; but it seems like if I can control memoization, I can solve this much more elegantly.
19:54:31 <accel> http://hackage.haskell.org/trac/ghc/ticket/917#comment:7 <-- I know that there are other solutions to this problem; but it seems like if I can control memoization, I can solve this much more elegantly. (i.e. I don't want a solution to this that involes going through the list just once; I want something that builds towards me controlling memoization)
19:54:52 <Eduard_Munteanu> Ok, the direct works, on to the inverse.
19:55:30 <dibblego> accel: http://research.microsoft.com/en-us/um/people/simonpj/papers/weak.htm
19:57:05 <accel> dibblego: nice; thanks
19:57:11 <accel> Saizan: please see how dibblego answers questions
19:57:53 <Saizan> accel: so what?
19:58:12 <accel> Saizan: i'm giving you free advice on how to be more helpful to me
20:00:21 <Saizan> accel: ok, let's be clear, next time i find you trying to get attention by any distruptive way, e.g. like above, you'll get banned.
20:00:58 * accel thanks the freenode staff for cloaking.
20:02:18 <accel> suppose I have a gigantic binary tree; and one function which runs down it left node first, one node which runs down it right node first; is there a way to run down the tree lazily, rather than build one copy of the tree for both functions?
20:03:23 <accel> i.e. suppose (f 100) <-- creates a tree of 100 levels, where level i has 2^i nodes; and function g1 g2 traverses the tree in prefix and postfix order
20:03:43 <accel> say I ahve: let x = f 100 in (g1 x) + (g2 x)
20:03:56 <accel> then the standard thing would be to run f 100; cache/store/memoize it in x; then run g1 & g2 on it
20:04:09 <accel> whereas I'd prefer if both g1 & g2 constructed the free lazily on the fly as nodes were requested
20:04:13 <accel> [does my question amke sense at all?]
20:04:57 <roconnor> accel: in GHC you could write (g1 (f 100)) + (g2 (f 100))
20:04:58 <accel> http://en.wikipedia.org/wiki/Tree_traversal <-- pre and post order defined as in this page
20:05:10 <Eduard_Munteanu> dolio: hm, the inverse proves a lot more trickier than the direct theorem: http://paste.pocoo.org/show/353307/
20:05:16 <Eduard_Munteanu> The latter was trivial.
20:05:26 <accel> roconnor: ghc won't optimize the (f 100) in the two to be shared?
20:05:29 <Eduard_Munteanu> Any ideas?
20:05:35 <roconnor> accel: no grrr
20:05:37 <accel> roconnor: and if not, why not?
20:05:38 <roconnor> @where CSE
20:05:38 <lambdabot> http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
20:05:39 <llayland> Unless I'm missing something, then at some point g1 and g2 will be processing nodes that are quite far apart and it wouldn't be that much different than pre caching it
20:05:44 <roconnor> accel: ^^
20:05:51 <accel> roconnor: thanks
20:05:52 <dolio> Eduard_Munteanu: You want to call f, and your result type will be an Exists p.
20:06:11 <roconnor> accel: because it causes space leaks like what you are afraid of in your example, that's why not.
20:06:13 <Eduard_Munteanu> Yes, but I don't have anything to call it on.
20:06:14 <roconnor> :)
20:07:36 <Eduard_Munteanu> MkExists . f     doesn't really cut it
20:07:54 <dolio> inverse f = f {- ... -}
20:09:00 <dolio> Eduard_Munteanu: Let me ask you this: what is the type of MkExists?
20:09:06 <accel> roconnor: nice; thanks
20:11:29 <Eduard_Munteanu> dolio: forall a. a -> Exists p
20:11:41 <dolio> Right.
20:11:52 <dolio> What's the type of f?
20:12:13 <Eduard_Munteanu> The first parens, forall r. (forall a. p a → r) → r
20:12:31 <dolio> Uh huh. Does that look suspicious?
20:12:48 <dolio> Wait, my bad. You got the type of MkExists wrong.
20:12:51 <jeffsco> @pl \f g a x -> f a (g x)
20:12:51 <lambdabot> flip . ((.) .)
20:13:07 <Eduard_Munteanu> dolio: well, p is quantified there too
20:13:19 <dolio> It should be forall a. p a -> Exists p
20:13:32 <Eduard_Munteanu> Oh, right.
20:15:20 <Eduard_Munteanu> We could have r ~ Exists p   I suppose.
20:15:24 <jeffsco> @pl \f g a x -> g a (f x)
20:15:25 <lambdabot> flip (flip . ((.) .))
20:15:37 <dolio> That is possible.
20:18:30 <llayland> @pl \a b f -> (f a b, b)
20:18:30 <lambdabot> join . ((flip . ((,) .)) .) . flip . flip id
20:19:17 <Eduard_Munteanu> Hm, I don't suppose there's polymorphic constructor matching, is there?
20:19:47 <Eduard_Munteanu> I was thinking of deconstructing 'p a'.
20:20:34 <monochrom> @vixen do you have free advices for free?
20:20:35 <lambdabot> i do occassionally, i guess
20:20:40 <monochrom> nice
20:21:01 <Eduard_Munteanu> Hm, forget it, that made no sense :)
20:21:46 <Eduard_Munteanu> Anyway to collapse forall r. (forall a. p a → r) → r   I kinda need to apply it to something :/
20:23:20 <dolio> What does the type look like if you substitute Exists p for r?
20:23:32 <Eduard_Munteanu> Hm... inverse f = f (const ...) looks promising
20:23:40 <Eduard_Munteanu> Lemme see.
20:24:01 <Eduard_Munteanu> (p a -> Exists p) -> Exists p
20:24:06 <dolio> No.
20:24:27 <Eduard_Munteanu> Um... (forall a. p a -> Exists p) -> Exists p
20:24:31 <dolio> Yes.
20:24:37 <dolio> So, what type does the argument to f need to be?
20:25:00 <Eduard_Munteanu> Oh. Exists p
20:25:19 <Eduard_Munteanu> Scratch that.
20:25:36 <Eduard_Munteanu> It looks an awful lot like MkExist its first argument I mean
20:26:11 <Eduard_Munteanu> s/first//
20:28:01 <Eduard_Munteanu> A-ha!
20:28:10 <Eduard_Munteanu> inverse f = f MkExists
20:28:27 <Eduard_Munteanu> dolio: thanks!
20:28:30 <dolio> No problem.
20:31:23 <pygmalion> http://pastebin.com/wLD76PZD I'm trying to figure out how I can use my calculatePriority function (see bottom) with today as the second argument (see top). i know that i can't get (today :: IO Day) to be just Day by nature of IO, but I don't see how it could be usable or what the right way to do what I need to do is
20:33:34 <roconnor> @wn cycolmatic
20:33:35 <lambdabot> No match for "cycolmatic".
20:33:40 <roconnor> @wn cyclomatic
20:33:41 <lambdabot> No match for "cyclomatic".
20:33:45 <Eduard_Munteanu> Regarding my first variant, why couldn't I use    data Exists p = forall a. MkExists (a -> p) ? My interpretation of that is 'exists a' means a <=> p if there's such an a.
20:33:47 <roconnor> pfft
20:33:52 <roconnor> cyclomatic complexity
20:33:58 <Eduard_Munteanu> I wonder if there are different ways of encoding that existential.
20:36:02 <Eduard_Munteanu> The type operator there makes sense, though, it encodes a second-order statement.
20:36:52 <geheimdienst> pygmalion, i think you're looking for "<-". in your main function, try "t <- today" and then do calculatePriority ... t
20:37:12 * Eduard_Munteanu also wonders about Not (Not a) as a way to express it
20:37:23 <Eduard_Munteanu> But I'm probably thinking too much aloud.
20:37:27 <Eduard_Munteanu> :)
20:37:34 <pygmalion> geheimdienst: ah brilliant! thanks!
20:37:41 <geheimdienst> you're welcome
20:40:36 * hackagebot quicklz 1.5.0.4 - binding to QuickLZ compression library  http://hackage.haskell.org/package/quicklz-1.5.0.4 (AustinSeipp)
20:43:15 <Eduard_Munteanu> Hm... I wish this was expanded more upon... http://en.wikipedia.org/wiki/Nonfirstorderizability
20:44:09 <Eduard_Munteanu> So I have this second-order formula, there are chances it can't be expressed first order; like dropping type operators there.
20:47:52 <Cale> Eduard_Munteanu: I don't think there's a really great way to formalise nonfirstorderizability which makes sense in every setting. It's easy to see for instance how to define properties of the real numbers which are first order or not, but in general, you could always use a first order theory of sets to discuss a second-order concept.
20:50:11 <Cale> I guess if you fix the second order system you're talking about then it becomes a reasonable question whether the second-order quantifiers can be eliminated from a given statement.
20:51:24 <Eduard_Munteanu> Yeah, I think that's the case when saying "exists a. a ~ forall r. (forall a. a -> r) -> r", which is first order, but the Haskell-encoded theorem is second-order
20:53:20 <Eduard_Munteanu> I suppose the first case doesn't unify the two 'a's so it's not actually rigourous.
21:24:10 <lispy_> man, 'cabal sdist' really whines about a lot of things
21:24:17 <lispy_> it complains if you  use -O2
21:24:27 <lispy_> and it won't let you create the package if you try to put files in ./dist
21:24:36 <lispy_> Even if you are creating ./dist from a makefile
21:32:05 <cole> I'm attempting "(_, time) = getClockTime" but I'm getting an error saying "Couldn't match expected type "Clocktime" against expected type "IO Clocktime" What's wrong?
21:32:40 <cole> (Oops, I actually wrote: "(IO _ time) = getClockTime")
21:33:12 <cole> Nope, it was: "(TOD _ time) = getClockTime"
21:33:16 <dibblego> cole: IO ClockTime is a different type to ClockTime  and so is treated differently, there are functions to work with it such as (>>=) and fmap
21:33:36 <dibblego> cole: what do you do with the "time" value after that?
21:33:45 <cole> what if I want to extract the seed in a where clause?
21:34:01 <cole> I pass it through as a seed to a random number generator
21:34:43 <dibblego> ok so you want something like: getClockTime >>= \(_, time) -> seed time
21:36:52 <geheimdienst> cole: i'd try to replace that with (_, time) <- getClockTime
21:37:11 <geheimdienst> IO is somewhat like a box. "<-" takes the contents out of an IO box. (that's not the whole story, but good nuff for now)
21:37:37 <geheimdienst> where can't handle "<-", it's only permitted in "do" blocks
21:37:56 <Jesin> @undo do { x <- getClockTime; doStuffWith x }
21:37:56 <Jesin> ...
21:37:57 <lambdabot> getClockTime >>= \ x -> doStuffWith x
21:38:08 <Jesin> where's lambdabot?
21:38:08 <Jesin> laggy
21:38:08 <Jesin> ok
21:40:20 <applicative> > 1
21:40:21 <lambdabot>   1
21:40:35 <Jesin> hmm
21:40:35 <Jesin> [01:19:12]	<geheimdienst>	IO is somewhat like a box. "<-" takes the contents out of an IO box. (that's not the whole story, but good nuff for now)
21:40:35 <Jesin> [01:20:02]	<geheimdienst>	where can't handle "<-", it's only permitted in "do" blocks
21:40:35 <Jesin> it's only permitted in "do" blocks
21:40:35 <Jesin> because anything you take out of an IO box, has to be put back into one, basically
21:40:45 <Jesin> and "do" blocks ensure that
21:44:24 <Jesin> *sigh*
21:44:25 <Jesin> eh
21:44:25 <Jesin> I have to go to bed now actually
21:44:28 <applicative> cole: getClockTime is an action which can be done at anytime.  It isn't a pair of numbers TOD x y. 
22:02:56 <Gracenotes> > let g(q,r,t,i)=let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y:g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1)in g(1,180,60,2)
22:02:56 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,...
22:03:11 <Gracenotes> happeh pi day :D
22:03:24 <Gracenotes> > length "let g(q,r,t,i)=let(u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y:g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1)in g(1,180,60,2)"
22:03:24 <lambdabot>   139
22:05:22 <ddarius> Gracenotes: Now you can tweet it so that if any internet-being needs the digits of pi in an emergency, they'll have ready access.
22:06:19 <lispy_> I don't see what the big deal is.  Pi only has 10 digits, it just reuses them.
22:07:28 <Gracenotes> I should also commandeer all 480 cores on my school's newest beowulf cluster to mitigate such emergencies. no one's ever done that.
22:08:03 <Boxo> Is there a way to write fractions in unary?
22:08:46 <Axman6> > let g(q,r,t,i)=let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in map digitToInt $ y:g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1)in g(1,180,60,2)
22:08:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
22:08:47 <lambdabot>         against inferred type...
22:09:22 <Axman6> > let g(q,r,t,i)=let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in concatMap show $ y:g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1)in g(1,180,60,2)
22:09:23 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
22:09:23 <lambdabot>    arising from a use of...
22:09:29 <Axman6> o.O
22:09:40 <Axman6> ah
22:09:54 <Gracenotes> map intToDigit?
22:09:56 <Axman6> > let g(q,r,t,i)=let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y:g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) in concatMap show $ g(1,180,60,2)
22:09:58 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
22:10:02 <Gracenotes> that too
22:10:03 <Gracenotes> :D
22:10:07 <Axman6> heh
22:12:15 <Gracenotes> not sure if the algorithm's been *proven* correct, in the same way that some prime testing algorithms haven't been proven correct
22:13:38 <Jafet> That's okay, you've tried it and it looks right.
22:14:21 <Jafet> > pi::CReal
22:14:22 <lambdabot>   3.1415926535897932384626433832795028841972
22:14:30 <Jafet> > showCReal 1000 pi
22:14:31 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
22:15:06 <Jonno_FTW> wow
22:15:24 <Gracenotes> think that uses something like liebniz's formula for pi, a similar identity with slightly more terms
22:15:40 <Jafet> > and $ zipWith (==) (filter isDigit (showCReal 1000 pi)) $ let g(q,r,t,i)=let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y:g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) in concatMap show (g (1,180,60,2))
22:15:41 <lambdabot>   True
22:15:58 <Gracenotes> still gets slower and slower as you request more digits, but starts out zippily
22:16:58 <Jafet> I don't know any linear time algorithm
22:17:15 <Gracenotes> the spigot algorithm above is supposed to be, at least
22:17:43 <Gracenotes> a slightly slower version of it is used for the shootout
22:18:12 <Gracenotes> they introduce a few nice optimizations, and the above is the most optimized (perhaps dangerously optimized, as noted in the paper)
22:18:18 <Jafet> It looks like some terms to g get larger and larger
22:19:07 <Gracenotes> oh yeah. it requires big ints. which are logarithmic :)
22:20:50 <Gracenotes> ...I could be so much more formal than that, but, yeah, I think it's supposed to be faster for base-10 generation
22:21:34 <Jafet> Not just that. It looks like q increases geometrically, so the algorithm is about quadratic
22:22:50 <Gracenotes> it seems all of them do except for i
22:25:45 <ddarius> Gracenotes: There are no ways of not having it get slower and slower.
22:27:02 <Gracenotes> I figured :/
22:27:34 <ddarius> Gracenotes: It's just inherent in it being irrational.
22:28:21 <Jafet> Well, some have nearly-linear algorithms
22:28:46 <Jafet> > "0." ++ concatMap show [1..]
22:28:48 <lambdabot>   "0.123456789101112131415161718192021222324252627282930313233343536373839404...
22:29:22 <ddarius> Jafet: You could probably do iterative deepening on some of the better fixed number of digits algorithms for pi and get something reasonably asymptotically fast.
22:29:23 <Jafet> Actually, that one is indeed linear
22:30:26 <Gracenotes> I have looked at a few papers, but with more interest in how it worked than how it asymptotically behaved
22:30:28 <ddarius> Jafet: At each step that has to increment an integer which is not a constant time operation, nor is formatting the number.
22:31:06 <Jafet> Yes, but each step on an n-digit integer produces n more digits
22:31:28 <Jafet> Just do it in the correct base to start with.
22:31:43 <Gracenotes> base pi? :|
22:33:19 <Jafet> > let showAtBase b n = (\(i,f) -> (show=<<i) ++ "." ++ (show=<<f)) $ splitAt (floor(log n/log b)+1) $ dropWhile (==0) $ unfoldr (\x -> let (i,r) = let d = floor (x/b) in (d, x-b*fromIntegral d) in Just (i,r*b)) n in showAtBase pi 10
22:33:21 <lambdabot>   "301.2120111002213001203002221212220200300111121121202212222111000200130100...
22:33:50 <Jafet> Well, anything past the first ten or so digits is probably garbage
22:40:26 <pygmalion> i need some advice on the best data structure to use for a to do list app. each to do item (type of ToDo) has an associated "priority value" which is an int calculated with a function (calcuatePriority :: ToDo -> Day -> Int). the day argument means that the priority will vary as time passes. initially i planned to use a map with the priorities as keys and the values as ToDo items, however it doesn't seem like this will work with the dynamic nature of the pr
22:40:38 <xaotik> Where should I get started learning FRP?
22:42:15 <DrSyzygy> pygmalion: Sounds like you might want to make a priority list?
22:42:30 <DrSyzygy> Hmmm.
22:42:36 <pygmalion> DrSyzygy: ooh. that sounds like it might fit. never heard of it?
22:42:36 <DrSyzygy> No, maybe not with varying priority.
22:42:45 <DrSyzygy> pygmalion: Google for priority list.
22:42:45 <pygmalion> DrSyzygy: yeah that's the tricky part
22:42:59 <DrSyzygy> Varying with the day might be obnoxious to fit into any data structure at all tho'.
22:43:47 <pygmalion> DrSyzygy: well i was thinking about writing a function reorderList :: ToDoList -> ToDoList that basically recalculates all of the priorities and reorders the list accordingly, but this might be tough with tree like structures
22:45:25 <companion_cube> maybe, if you can assume that your function calculatePriority is monotone along time, you will not have to reorder ?
22:46:42 <pygmalion> companion_cube: i don't think it will be though. the way it works is that it takes into account the difference between the current day and the due date of the to do list item (as well as the category, status, urgency level etc. all defined within data ToDo) to calc a weighted priority
22:46:55 <Jafet> How many things do people put on their todo lists, anyway?
22:47:29 <pygmalion> Jafet: haha who knows. this is more of a learning exercise anyway. i thought it might be cool to have relatively automatic priority-based ordering
22:47:34 <DrSyzygy> Jafet: But think of the performance when you hit a million itmes! Think of it!
22:47:45 <pygmalion> hahah
22:47:55 <DrSyzygy> pygmalion: So don't keep it in a tree structure... You'll want it as a list everytime you view it anyway.
22:48:03 <companion_cube> if you use the code in mission c ritical, company wide todolist ? :D
22:48:12 <Jafet> You can't invent an efficient data structure if the ordering can have just about any degree of complexity.
22:48:21 <pygmalion> DrSyzygy: fair enough. list of tuples i guess.
22:48:36 <DrSyzygy> pygmalion: Just a list of your TodoList items.
22:48:45 <DrSyzygy> Hide the actual details inside a datatype.
22:48:45 <Jafet> If the priority is calculated with simple functions over some monotonic variables, then you can.
22:49:25 <DrSyzygy> Jafet: So you think I should rethink my paper on arbitrary complexity efficient sorted lists before claiming the Turing price? ;-)
22:50:28 <Jafet> You could determine the interval covered by pri(t)-pri(t') for time intervals t-t', and then use some sort of interval tree
22:50:54 <Jafet> But that probably only wins for mission critical company wide todolists
22:52:00 <DrSyzygy> If even then.
22:52:39 <Jafet> It will surely win then, unless the executives came up with ridiculous calculatePriority definitions
22:53:28 <Jafet> Perhaps, mutually referential ones
23:03:09 <lispy_> Grr... I hate you cabal: setup: GLFW-b-0.0.2.2: library-dirs: build is a relative path (use --force to
23:03:09 <lispy_> override)
23:03:19 <lispy_> Why does it care if it's a relative path?
23:03:25 <lispy_> This package works
23:03:41 <lispy_> and library-dirs is not even a line in the .cabal file
23:10:51 <lispy_> This forces me to do completely irrational things in my Setup.hs and cabal file
23:14:01 <augur> how can i reason about the effective equivalence of definitions?
23:14:21 <augur> and transform filters into generating functions?
23:14:26 <augur> or something along those lines?
23:14:50 <geheimdienst> lispy_: pity that dcoutts is not around. i bet he could explain at least the library-dirs issue
23:15:10 <lispy_> cabal is the most frustrating build system I have ever used
23:15:17 <Axman6> augur: the equivalence of functions?
23:15:27 <lispy_> I'm really quite sick of it and only using it because that's what hackage requires.
23:15:32 <augur> Axman6: eh well. sort of. i know its undecidable in general
23:16:14 <augur> Axman6: but i mean things like f ~ flip f modulo order of arguments, etc.
23:16:45 <Axman6> so, you want to prove that, basically, flip (flip f) = f?
23:16:57 <augur> well thats obviously easy, but :P
23:17:00 <Jafet> Since it's undecidable in general, you could elaborate about this transforming filters into generating functions instead
23:18:22 <augur> Jafet: ok well, the stupid case im considering is crap like .. [as ++ bs | as <- lists_of a, bs <- lists_of b, length as == length bs]
23:19:35 <augur> and turning that into something like nil = [], next asbs = [a] ++ asbs ++ [b]
23:20:43 <augur> doesnt have to be of that form but you get the idea -- the filter is just a filter, but theres probably a way of deriving the facts of the functions from the filter
23:30:08 <lispy_> I really don't understand why each release of cabal has to break so much stuff
23:30:13 <Jafet> Sorry, but I find your question undecodable, not undecidable
23:30:16 <lispy_> And why does it complain about everything?
23:32:01 <augur> Jafet: :(
23:32:01 <dons> lispy_: cabal is a solver for an undecidable logic. what is in , and is not in, a particular solution, changes from release to release. and looks like breakage
23:32:01 <lispy_> dons: Not that.
23:32:01 <Jafet> Note that your list comprehension is actually something like [] : [a,b] : undefined
23:32:04 <dons> ok. then the question is ill-formed
23:32:05 <dons> ;)
23:32:13 <lispy_> dons: I spent 20 hours this weekend working around ghc/cabal issues to get this library to build, then I upgraded to 7.0.2 and now cabal won't accept my package.
23:32:54 <lispy_> dons: and working versions of the package keep getting rejected by sdist because it assumes they don't work.  Things like relative paths in my .cabal file get rejected by hackage.
23:32:59 <lispy_> It's really annoying
23:33:06 <Jafet> augur: if you don't mind a crude heuristic, there is quickspec
23:33:24 <augur> Jafet: i need a technique :\
23:33:35 <Jafet> Technique to do what?!
23:34:27 <Jafet> A function has a potentially infinite number of properties, which ones do you want to extract?
23:34:36 <dons> lispy_: you're doing it wrong.
23:34:37 <augur> Jafet: well put it this way, ok: let asbs = [] : map (\x -> [a] ++ x ++ [b]) asbs
23:35:22 <lispy_> dons: Well, as I said before I'm doing irrational things with this package because cabal forces me to.
23:35:26 <augur> not that thats quite what im aiming for but
23:35:35 <dons> lispy_: is it an irrational package?
23:35:44 <dons> e.g. does it talk to C somehow? 
23:35:49 <dons> in a non-standard way?
23:35:52 <lispy_> A package that can't be expressed as the difference of two integers?
23:36:03 <lispy_> dons: is objective-c non-standard?
23:36:10 <Jafet> Quotient
23:36:10 <augur> Jafet: i mean, suppose you had some functions that built up the lists of a. nil_a () = [], next_a as = a:as, and similarely for lists of bs
23:36:11 <lispy_> (er not difference, but ratio)
23:36:35 <augur> and you have some way of building lists of both: (++)
23:36:54 <dons> lispy_: yes.
23:36:56 <lispy_> dons: cabal files won't let you pass objective-c code to gcc
23:36:57 <Jafet> Anything mac-os-toolchain is probably irrational.
23:37:00 <augur> you might then ask, how can i take these ~5 functions and enforce that the as and the bs number the same
23:37:02 <dons> quite rightly.
23:37:11 <dons> you should standardize the obj-c ffi first
23:37:15 <dons> ;)
23:37:17 <lispy_> gcc accepts objective-c no problem
23:37:23 <dons> i.e. what you're doing is outside of the spec
23:37:29 <lispy_> Or just the C ffi to communicate with obj-c and
23:37:30 <dons> so your errors will be outside too
23:37:53 <lispy_> What spec?
23:38:07 <dons> the FFI and Cabal specs, which state how to interact with C
23:38:14 <dons> not Obj-C (or Java, or ...)
23:38:35 <lispy_> Yeah, so I created a makefile so I could build the objectivec
23:38:35 <Jafet> augur: still don't know what you're getting at. But you can express that as a context-free grammar or something
23:38:39 <dons> not supported, in other words. so it might work, but no warranties
23:38:51 <augur> Jafet: yes but the point is to _derive_ the CFG from the constraints
23:38:54 <lispy_> and no help from cabal.  To the point that it works against me.
23:39:15 <Jafet> Okay, now we have a decodable problem
23:39:51 <Jafet> I think deriving arbitrary CFGs is still undecidable, though
23:40:03 <augur> im not saying it should be decidable
23:40:12 <augur> but there must be techniques regardless
23:40:26 <augur> even if they might not succeed
23:40:36 <augur> or halt
23:40:45 <dons> write a makefile, call ghc directly, until it works
23:40:48 <dons>  then encode it in cabal speak
23:42:17 <lispy_> I wrote a makefile.  I invoke things manually, but the problem I have now is that cabal arbitrarily disallows my use of paths
23:42:45 <lispy_> It actually works on 3 different OSs
23:42:49 <lispy_> But sdist won't have it
23:42:51 <Jafet> augur: I don't know how you would do that
23:42:59 <augur> ok
23:43:23 <lispy_> Cabal has always had arbitrary constraints like this that are really frustrating
23:43:42 <lispy_> Like how it still tells you not to optimize your code
23:44:57 <Jafet> I'm still fairly sure that quickspec will heuristically find your grammar, if you cleverly choose the right equations
23:45:22 <augur> that may be, but the question is not "give me the grammar"
23:45:26 <augur> the question is "how"
23:45:36 <augur> i know the grammar, thats not the issue
23:45:41 <augur> the issue is understanding how to do this
23:45:48 <Jafet> Well, see how quickspec works then.
23:46:01 <augur> what techniques are usable for generic problems, etc.
23:47:57 <Jafet> ...every time I answer what I think the question is, it seems to change.
23:48:38 <lispy_> The solution with cabal seems to be, write you own build system from scratch in Setup.hs on every project.
23:48:47 <lispy_> That's a step backwards, FYI.
23:49:58 * hackagebot quicklz 1.5.0.5 - binding to QuickLZ compression library  http://hackage.haskell.org/package/quicklz-1.5.0.5 (AustinSeipp)
23:55:59 * hackagebot quicklz 1.5.0.6 - binding to QuickLZ compression library  http://hackage.haskell.org/package/quicklz-1.5.0.6 (AustinSeipp)
