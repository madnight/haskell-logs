00:01:50 <jonkri> @t (>=>)
00:01:50 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:02:11 <jonkri> @type (>=>)
00:02:12 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:11:51 * hackagebot tls 0.4.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.4.0 (VincentHanquez)
00:24:08 <phr_> cool, i'm trying to talk to him (Vincent) about that package
00:34:31 <phr_> tab-based indentation considered evil :(
00:35:47 <jaspervdj> Anyone who can recommend a package for fitting linear curves to data points?
00:38:25 <phr_> @hoogle srandomgen
00:38:26 <lambdabot> No results found
01:01:00 <ksf> ezyang, the stackoverflow bounty is over in 4 hours
01:01:18 * ksf can't believe noone earned it yet.
01:01:39 <vegai> what bounty is that?
01:01:45 <ksf> http://stackoverflow.com/questions/5057136/real-world-applications-of-zygohistomorphic-prepromorphisms
01:01:49 <ksf> 300 karma.
01:01:52 <vegai> :-D
01:04:23 <greap> Still no idea really. When I ghc-pkg unregister pretty, it then complains about ghc not being installed which is weird. If I then install pretty 1.0.1.1, the problem persists, but then if I install 1.0.1.2 I get "dependencies conflict: ghc-6.12.3 requires pretty ==1.0.1.1 however, pretty-1.0.1.1 was excluded because ghc-6.12.3 requires pretty ==1.0.1.2"
01:07:00 <ksf> that sounds... borked. can you hpaste the output of cabal install -v ?
01:07:07 <ksf> @hpaste
01:07:07 <lambdabot> Haskell pastebin: http://hpaste.org/
01:09:41 <greap> ksf: sure
01:11:07 <ksf> hmmm ghc comes with pretty, doesn't it?
01:11:18 <ksf> you shouldn't unregister that.
01:12:25 <jonkri> what xml library can you use to properly parse xml-types types? i'm not sure i find don't find the predicates and filters provided by xml-types sufficient
01:13:18 <dmead> @hoogle clojure
01:13:18 <lambdabot> No results found
01:13:48 <greap> http://hpaste.org/44440/broken_quickcheck
01:13:56 <greap> ksf: http://hpaste.org/44440/broken_quickcheck
01:14:03 * ksf only ever used haxml
01:14:10 <hpaste> sordina pasted "Broken quickcheck"  http://hpaste.org/44440
01:15:01 <ksf> greap, cabal install pretty -v ?
01:16:11 <greap> http://hpaste.org/44441/broken_quickcheck_annotation
01:17:15 <ksf> and the whole of cabal install quickcheck --reinstall?
01:17:52 <greap> http://hpaste.org/44442/broken_quickcheck_annotation?pid=44442&lang_44442=
01:18:34 <ksf> quickcheck, not pretty
01:19:22 <greap> Oh sorry.
01:20:27 <greap> http://hpaste.org/paste/44440/broken_quickcheck_annotation#p44443
01:21:03 <ksf> that looks cut off
01:21:05 <greap> By the way, all this seemed to start happening after agda mysteriously stopped working recently.
01:21:44 <greap> Nope, it's all there.
01:22:39 <ksf> hmmm. ghc (the package, not the compiler) depends on Cabal which depends on pretty
01:23:33 <ksf> so, taking into account that that package isn't installable by cabal but ships with ghc, I think with unregistering it you just broke half your ghc.
01:24:32 <ksf> you may try re-registering it (stuff isn't deleted), but what I'd actually recommend is nuking the install and starting from scratch.
01:24:55 <ksf> oh, and there's ghc-pkg hide if you don't want to see a package but don't want to break anything.
01:25:06 <greap> Is there an easy way to nuke it all?
01:25:16 <ksf> rm -r ~/.cabal ~/.ghc
01:25:21 <greap> ah cool
01:25:31 <greap> Thanks ksf, I'll give that a shot!
01:25:33 <ksf> ...plus however you installed ghc.
01:26:33 <ksf> looks like you have OSX or something from here, you would have to ask someone else about that.
01:31:19 <greap> ksf: I just used the haskell platform for that, but that shouldn't matter since I do all my haskell package-management a normal user.
01:32:01 <ksf> well, but the pretty-1.0.1.1 you unregistered should have been a system-wide one.
01:46:09 <greap> Thanks a lot ksf. Nuking it worked great!
01:46:40 <greap> It wouldn't have been able to uninstall the system-wide pretty since that's installed by root.
01:47:11 <greap> Propper privelige separation wins the day again :D
01:48:21 <vegai> nuking saves the day again!
01:57:56 <ksf> cabal install moab
01:58:39 <Martty> do that in the shell not in irssi!
01:59:30 <DevHC> irssi sux
01:59:42 <ksf> description: Uses thermobaric bombs to clean ~/.cabal and ~/.ghc . No nuclear fallout expected.
02:07:23 <jaj> http://fukung.net/v/31948/1b2b54d10aefb752f74783046e2c0ee0.jpg
02:16:36 <ManateeLazyCat> Hi all. :)
02:17:42 <jaj> Hi Mr Manatee
02:17:55 <ManateeLazyCat> jaj: Hi. :)
02:18:06 <ManateeLazyCat> Mr Manatee, hahaha. :)
02:19:53 <ManateeLazyCat> Haha, Python like Haskell too, lazy evaluation, lambda, functional programming.
02:20:32 <int-e> no strong typing though, and has trouble with (even tail) recursion.
02:21:20 <ManateeLazyCat> int-e: Yes, and weak concurrent support.
02:21:48 <ManateeLazyCat> int-e: I prefer like Haskell, but you know, i need use Python do some script work.
02:22:17 <ManateeLazyCat> int-e: Python haven't free-lock concurrent mechanism.
02:22:18 <ManateeLazyCat> int-e: And Haskell is much much simple. :)
02:22:37 <jaj> I did some functional programming in python some time ago and it ended up becoming very ugly
02:23:07 <ion> Python’s lambda is crippled, too.
02:23:25 <jaj> especially since some standard library "functions" cannot be passed as functions
02:23:34 <ManateeLazyCat> jaj: Yes, if you compare with Haskell, but still better than other script language.
02:23:40 <ManateeLazyCat> ion: Haha.
02:23:49 <ManateeLazyCat> ion: I don't know why not use symbol instead.
02:24:01 <ion> I like Ruby much more than Python. But of course it has its faults too.
02:24:01 <ManateeLazyCat> ion: I need type lambda every time, sadly.
02:24:24 <ManateeLazyCat> ion: Scippled better than nothing, right? :)
02:24:40 <mapreduce> Python's lambda is crippled in that you can't have multiple statements within a lambda, is that what you mean?
02:24:46 <ion> yeah
02:24:52 <mapreduce> Not to be argumentative, but show me a Haskell multi-statement lambda. :)
02:25:04 <zygoloid> \x -> do ... ;-)
02:25:33 <ion> Haskell has things such as ‘let … in …’, >>= etc. Python only has, well, semicolons and linefeeds. And you can’t use them in Python lambdas. :-)
02:26:16 <ion> Please correct me if i’m under the false impression.
02:27:20 <mapreduce> Well, you could, erm, make a semicolon function that takes a list of lambdas and runs them.
02:27:25 * mapreduce clutches at straws.
02:27:46 <jonkri> what's wrong with my let statement on the third line in this (partial) function? http://paste.pocoo.org/show/346866/ ... the where instances are not being considered it seems
02:28:08 <mapreduce> lambda x: semicolon(lambda: fire_the_missiles(x), lambda: reboot_the_pc(x)) or something
02:28:28 <zygoloid> jaj: some of those results are wrong even with 'fix.hs' :/ i am disappoint
02:29:05 <jaj> zygoloid: yeah I know... but it's fun anyway
02:30:27 <zygoloid> jonkri: 'where' binds to the parseIQ equation on line 3, and isn't visible to the one on line 2. replace the first 9 characters on line 3 with spaces to fix.
02:30:30 <ManateeLazyCat> ion: Yeap, Python's functional programming is weak.
02:30:32 <ManateeLazyCat> ion: I think Python's policy is let user choose, you can write Python with OOP style or FP
02:32:25 <jonkri> ah, right. thanks
02:33:47 <ion> In Ruby, the passing of lambdas as function call parameters is used in everything including the standard library. It’s such a common operation that Ruby has special syntax for it. Compare ‘withFile "foo" ReadMode $ \fh -> doStuffWith fh’ and ‘open "foo" do |io| do_stuff_with io end’ for instance.
02:34:43 <zygoloid> |io|? that's very smalltalkesque :)
02:35:05 <ion> Smalltalk is a major influence, yes.
02:36:44 <mm_freak_> i don't like ruby's syntax…  and about python's FP features i don't like that it has no TCO
02:36:54 <mapreduce> I thought Python's style was "if you don't code like Guido, prepare for bloat".
02:37:21 <mapreduce> He considered removing map, reduce (dear to my heart!) and lambda not that long ago.
02:37:23 <mm_freak_> i don't understand why TCO isn't a common thing anyway…  it appears like only FP language compilers have it
02:37:36 <mm_freak_> and GCC has it, if you don't set any C/C++ standard to use
02:37:48 <quicksilver> because implementers of other programming languages think recursion is a bad thing
02:37:54 <quicksilver> so you shouldn't encourage its use ;)
02:38:39 <mm_freak_> yeah, but that's stupid…  a compiler implementor should go without politics
02:38:54 <mm_freak_> if you want to discourage it, add a warning flag or something
02:39:05 <hpaste> jaj pasted "Dbus-client infinite loop"  http://hpaste.org/44444
02:39:07 <mapreduce> Tail calls to yourself can get complicated with inheritance.
02:39:17 <mm_freak_> blah.c:12:33: Warning: You are using bad programming style.
02:39:26 <mapreduce> That's without considering tail calls to some library you dynamically link with.
02:39:36 <jaj> hmm when I run this and another application wants to introspect my exported objects then the other application goes into an infinite loop: http://hpaste.org/44444
02:40:00 <mm_freak_> mapreduce: i don't understand…  a tail call is a call to the same function, i.e. in the same class
02:40:17 <mm_freak_> if you're calling a different class by inheritance, it's not the same function anymore
02:40:39 <mm_freak_> or you can call the code, which decides, as a tail call
02:40:55 <mapreduce> mm_freak_: Sure, but consider Java: class A { void foo() { foo(); } } class B extends A { int x; void foo() { if (x++ == 0) super.foo(); } }
02:41:18 <mm_freak_> mapreduce: what's wrong with that?
02:41:50 <mapreduce> If your compiler compiles A.foo() as an endless loop, then that code will loop forever, whereas it should actually terminate pretty instantly.
02:42:19 <mapreduce> (assuming you do new B().foo() in a main)
02:42:29 <mm_freak_> if your compiler compiles A.foo as an endless loop, then it's wrong…  that's not related to tail calls
02:42:55 <mm_freak_> it should compile A.foo as a wrapper function, which calls the right method
02:43:15 <mm_freak_> now this wrapper function calls the right method as its tail call, and also the wrapper itself gets called as a tail call
02:43:19 <mm_freak_> so what's the problem?
02:43:21 <quicksilver> mapreduce: but that isn't a tail call :)
02:43:26 <quicksilver> it just looks a bit like one.
02:43:27 <mapreduce> mm_freak_: It's only wrong because of inheritance.  In C that would be fine.  void foo() { foo(); } is the same as void foo() { while (1); } assuming your compiler does TCO.
02:43:37 <quicksilver> virtual method dispatch isn't a simple call.
02:43:39 <mapreduce> quicksilver: Right, that's why I said TCO gets tricky with inheritance. :)
02:44:33 <mm_freak_> i don't get it…  let's take C++ instead of java, because i know its semantics better…  a virtual method call is a call to some wrapper function with the given parameters
02:44:50 <mm_freak_> and this wrapper function calls the real method based on a lookup…  this is a tail call
02:44:59 <mm_freak_> and in fact, g++ optimizes tail calls very well
02:45:37 <mapreduce> So if your virtual method calls itself, how does that end up optimised?
02:45:39 <mapreduce> Trampolining?
02:46:33 <mm_freak_> no, regarding TCO there is no problem with two functions calling each other
02:47:12 <mm_freak_> the wrapper function gets the same arguments as the final method…  it checks the given object's RTTI and relays accordingly
02:47:52 <mm_freak_> (of course this is a model…  in actual code there is no wrapper /function/…  it's just some code)
02:48:13 <mapreduce> As a model it sounds like it'd run out of stack.
02:48:23 <mm_freak_> without TCO yes, with TCO no
02:48:43 <mapreduce> Ok, I think I understand you.
02:49:02 <mm_freak_> note that we're not talking about tail /recursion/, but about tail calls in general
02:49:57 <mm_freak_> if TCO would only work with recursion, then a whole paradigm would break:  continuation-passing style
02:51:14 <mapreduce> So does that end up being implemented as trampolining?
02:54:35 <Younder> mapreduce, Is this hacking?
02:54:42 <mm_freak_> i think in native code compilers TCO just replaces a CALL by a JMP
02:54:57 <mm_freak_> (in x86 terms)
02:55:12 <mm_freak_> perhaps with some code to clean up the stack
02:55:25 <mm_freak_> unless you're calling the same function again, of course
02:55:35 <Younder> Trampolineing is usually used to hide your IP address.
02:55:40 <mapreduce> Younder: No.
02:55:49 <mm_freak_> Younder: no, it's a compiler techinque in this context
02:57:35 <Younder> Aah what I refer to as thunking
02:58:28 <Philippa> mapreduce: ghc does a worker/wrapper transform so even tail calls from other modules can be compiled as jumps. If compiling via C, it'll trampoline initially but the Evil Mangler was written to, er, mangle the resulting asm to turn it directly into jumps
02:58:47 <HugoDaniel_II> i have a datatype like this: data MyType a b = MyType ....
02:59:33 <HugoDaniel_II> can i make a monad instance of a type with two type vars without having to declare an instance for all possible values of the inner type var ?
03:01:32 <mm_freak_> HugoDaniel_II: instance Monad (MyType a) where …
03:02:27 <jedai_> HugoDaniel_II: just like it's done for Either a or (,) a
03:02:41 <jedai_> or (->) a
03:02:49 <HugoDaniel_II> ah yes :)
03:02:50 <HugoDaniel_II> cool
03:02:52 <mm_freak_> or State s, which i find a better example, because often people talk about "the state monad", which is wrong
03:02:57 <mm_freak_> State is a class of monads
03:04:03 <sipa> (State a) is monad
03:04:10 <sipa> as is (StateT a m)
03:04:21 <HugoDaniel_II> indeed
03:05:10 <mapreduce> Philippa: Thanks.
03:23:40 <vegai> building hakyll+deps on an ARM box takes a whole lot of time...
03:26:55 <Ptival> can I somehow do something like [p | x <- l, y <- l, p <- x*y, somepred p]?
03:27:29 <Botje> let p = x * y, somepred p
03:27:41 <Ptival> thanks
03:27:48 <Botje> or, p <- return (x * y)
03:27:56 <Botje> but the let is less typing :)
03:28:06 <Ptival> sure
03:28:13 <Ptival> it makes sense
03:31:04 <ClaudiusMaximus> > comparing length "let p=x*y" "p<-[x*y]" -- probably i'd use 'let'
03:31:05 <lambdabot>   GT
03:32:33 <vegai> @type comparing
03:32:34 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
03:32:59 <Ptival> yeah, "p <- [x*y]" just makes it unclear in my opinion
03:33:39 <ion> or let p = x*y
03:34:03 <ion> Whoops, i had scrolled up and missed that it was already said.
03:45:19 <ksf> it should be possible to write a library for polyvariadic functions that can accept any sequence of arguments adhering to a regex, shouldn't it?
03:46:03 * ksf searches for "oleg parsing type-level"
03:47:09 <ClaudiusMaximus> @quote dsp
03:47:09 <lambdabot> JohnyBoy says: so have a nice goodspeed
03:49:43 <pesco> trevor?
04:19:57 <sipa> > "5"
04:19:58 <lambdabot>   "5"
04:20:31 <sipa> > 1.03^(5/3)
04:20:32 <lambdabot>   Ambiguous type variable `t' in the constraints:
04:20:32 <lambdabot>    `GHC.Real.Fractional t'
04:20:32 <lambdabot> ...
04:20:37 <sipa> > 1.03^(5 `div` 3)
04:20:38 <lambdabot>   1.03
04:20:46 <sipa> > 1.03^(5//3)
04:20:47 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Arr.Array i e))
04:20:47 <lambdabot>    arising from a u...
04:21:05 <hpc> > 1.03**(5//3)
04:21:05 <lambdabot>   No instances for (GHC.Float.Floating (GHC.Arr.Array i e),
04:21:06 <lambdabot>                  ...
04:21:08 <hpc> > 1.03**(5/3)
04:21:09 <lambdabot>   1.0504983497704847
04:21:12 <hpc> :P
04:24:34 <Jafet> @hoogle Double -> Double -> Double
04:24:35 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
04:24:35 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
04:24:35 <lambdabot> Prelude max :: Ord a => a -> a -> a
04:46:19 * hackagebot hatt 1.0 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.0 (BenedictEastaugh)
05:02:04 <fryguybob> @tell conal Small typo on your latest blog post: The identity functor is easiest.
05:02:04 <lambdabot> Consider it noted.
05:11:47 <Ptival> @src zipWith
05:11:48 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:11:48 <lambdabot> zipWith _ _      _      = []
05:13:18 <int-e> hmm, has anybody ever proposed a syntax along the lines of "module Foo.Bar.Baz as Baz ( ... ) where ?
05:14:09 <hpc> int-e: what would that do?
05:14:11 <sipa> what's the point of Foo.Bar.Baz here?
05:14:35 <int-e> hpc: define a module Foo.Bar.Baz, but make the namespace available as Baz as well.
05:14:36 <hpc> sipa: that's normal module syntax, what he is adding is "as Baz"
05:14:42 <hpc> int-e: oh, neat
05:15:00 <hpc> that would be kinda tough for GHC to keep track of, i think
05:15:16 <hpc> it currently assumes the modules are a directory structure
05:15:23 <int-e> hpc: (so that instead of, say, import Prelude hiding (map), you could refer to a locally defined 'map' as Baz.map as well as Foo.Bar.Baz.map.
05:15:43 <hpc> int-e: ah, now i see
05:15:48 <int-e> hpc: it has to take care of renaming imports already, which allow this 'as Foo' syntax.
05:16:00 <sipa> hpc: i know, but i was wondering why he'd still have the hierarchical part in his syntax, if he just wants it accessible as Baz
05:16:16 <hpc> sipa: he doesn't mean so you can say "import Baz"
05:16:40 <aavogt> you could write Baz.hs then re-export it from Foo.Bar.Baz
05:16:42 <hpc> so you can say "module Foo.Bar.Baz as Baz where x = Baz.map"
05:16:56 <int-e> or perhaps alternatively, allow  module Foo.Bar.Baz where import Foo.Bar.Baz as Baz ...
05:16:57 <hpc> instead of Foo.Bar.Baz.map
05:17:18 <hpc> int-e: i like the former idea better :P
05:17:30 <hpc> that looks like an infinite dependency
05:17:46 <int-e> ghc thinks so, too. "Module imports form a cycle for modules:"
05:18:18 <DevHC> which isn't necessarily wrong? :P
05:18:59 <hpc> i do like the idea of fixing that bug
05:19:14 <hpc> "THIS namespace can have its name changed, but not the namespace we are currently in"
05:19:40 <hpc> s/bug/inconsistency/ if you prefer
05:20:11 <int-e> hpc: so do I, but the latter explains the effect I want to have in terms of already existing concepts, and would work without a syntax change.
05:20:23 <int-e> hpc: (context: "i like the former idea better")
05:20:30 <kniu> I need a version of GHC that's 90% smaller.
05:20:39 <int-e> kniu: hugs? jhc? *g*
05:20:42 <FauxFaux> I need one that's 95% smaller.
05:21:02 <int-e> I need one that fits on a 360k floppy disk? :-)
05:21:25 <kniu> Ran out of quota space when trying to untar the ball.
05:23:24 <JaffaCake> kniu: you need GHC 0.19
05:23:26 <hpc> wtf, when i stat my ghc, it says it is 255 bytes
05:23:31 <JaffaCake> that was a nice compact release
05:23:44 <Jafet> You just need to have modules as values and then you can probably fix them or something
05:24:18 <Bynbo7> hpc: it's probably a script that runs the actual binary
05:24:35 <pozic> Bynbo7: I don't think he was serious.
05:25:38 <hpc> no, i was serious
05:25:42 <hpc> didn't know it was a script :P
05:26:02 <int-e> Jafet: however modules as values are a dependency nightmare, from what little I've seen in ocaml.
05:26:34 <hpc> Bynbo7: neat
05:26:42 <Bynbo7> mine's 439
05:27:05 <Jafet> But you can't have corecursive modules in ML, huh!
05:27:15 <Bynbo7> hpc: if you'd use3d ghc on OS X, you'd have run into this fact many times :P
05:27:44 <hpc> heh
05:28:30 <kniu> gah
05:28:59 <Jesin> hmm
05:29:11 <Jesin> I'm wondering about
05:29:33 <kniu> Can I get GHC through hackage?
05:29:35 <Jesin> how much inlining does GHC generally do, under -O2 for example?
05:29:51 <Jesin> in particular
05:30:10 <Jesin> (<$) is in the Functor class,
05:30:14 <Bynbo7> kniu: no, and it would still build from source anyway
05:30:21 <kniu> hm
05:30:26 <Jesin> (<*) and (*>) are in Applicative, and (>>) is in Monad
05:30:40 <Jesin> for a monad like
05:30:42 <Bynbo7> do you have enough ram to store the tarball in a ramdisk?
05:30:59 <Jesin> newtype Findspace b a = Findspace {runFind :: (a -> b) -> a}
05:31:00 <Jesin> instance Monad (Findspace b) where
05:31:02 <Jesin> 	return = Findspace . const
05:31:02 <saml> my ram is 12GB
05:31:03 <Jesin> 	m >>= f = Findspace $ \p -> runFind (f $ runFind m $ \x -> p $ runFind (f x) p) p
05:31:04 <aavogt> Jesin: have you tried using ghc-core?
05:31:15 <Jesin> hm?
05:31:17 <b52> could someone help me please: 
05:31:19 <saml> it's like 12GB of random access parallel flip flops
05:31:21 <b52> http://npaste.de/z8/
05:31:25 <Jesin> no, never heard of it, aavogt
05:31:31 <ClaudiusMaximus> is there any guarantee about alignment of the first byte of data within a ByteString? or is it (as i suspect) "to the nearest byte, no more no less"
05:31:33 <Jesin> is it useful for questions like this?
05:31:51 <Jesin> I'm trying to figure out whether, under that Monad instance, and
05:31:51 <aavogt> it runs ghc with various flags and gives output which is useful for performance (core, asm, whatever optimizations fired)
05:32:02 <Jesin> instance Applicative where { pure = return; (<*>) = ap }
05:32:09 <saml> is npaste haskell markdown thingy?
05:32:12 <saml> forgot the name
05:32:21 <aavogt> pandoc?
05:32:24 <copumpkin> ClaudiusMaximus: I doubt it, but as it's a foreign ptr, it's probably the alignment your OS's malloc guarantees
05:32:28 <Bynbo7> hpaste?
05:32:28 <hpc> ClaudiusMaximus: wouldn't it align the same as C, where the head of the structure is the nearest word?
05:32:31 <Jesin> will it discover that x >> y = y?
05:32:36 <hpc> or copumpkin can know more :P
05:32:40 <saml> yup pandoc
05:32:52 <Jesin> and (<*) = const
05:32:54 <Jesin> and such
05:33:13 <Jesin> it can do that by inlining
05:33:22 <Jesin> and then reducing
05:33:26 <aavogt> hopefully inlining const too
05:33:27 <Jesin> but I'm not sure under what circumstances it does that...
05:33:31 <Jesin> yes  :p
05:33:33 <b52> my problem should be your concern, not the highlight thingy :D
05:33:59 <ClaudiusMaximus> copumpkin, hpc: but if you split a bytestring at an arbitrary point, it should just keep the same array behind the scenes and not copy it?
05:34:01 <aavogt> in that case I think it does, because the definitions are very small
05:34:08 <Bynbo7> b52: this is not the best way to go about gtting help. just pasting code and expecting people to solve your problems is quite rude
05:34:11 <copumpkin> ClaudiusMaximus: yeah, no copying
05:34:13 <aavogt> or at least GHC is likely to inline
05:34:52 <DevHC> Bynbo7: yes it IS the best way to ask for help
05:35:21 <hpc> DevHC: usually some additional context would help :P
05:35:42 <hpc> "this code isn't working! it has a type error on line 9000 that i don't understand"
05:35:58 <copumpkin> b52: deriving (Show) on TestCase
05:36:01 <hpc> "why does fooBarBaz quux return 5 instead of "five"?"
05:36:25 <DevHC> ^answer: because it should
05:36:29 <aavogt> use print rather than  putStrLn (show x)
05:36:44 <ClaudiusMaximus> how heavy is the penalty for trying to upload misaligned float data to an opengl texture? (heaviness ranging from "boom" to "10% slower"?)
05:37:04 <copumpkin> ClaudiusMaximus: measure measure measure :)
05:37:06 <Bynbo7> parseTestCases looks a hell of a lot like replicateM
05:37:12 <ClaudiusMaximus> copumpkin: lazy lazy lazy :)
05:37:13 <Bynbo7> :t replicateM
05:37:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
05:38:38 <hpc> ClaudiusMaximus: my guess would be that it is somewhere between "boom" and "copies the data to somewhere that is aligned"
05:38:45 <hpc> i don't know much though :P
05:39:47 <Jesin> [09:09:53]	<aavogt>	or at least GHC is likely to inline
05:39:53 <Jesin> so, I hope this means
05:40:20 <Jesin> writing out definitions for (<*>), (*>), fmap, etc
05:40:38 <Jesin> hand-simplified ones I mean
05:40:56 <Jesin> ultimately does not result in cleaner code than (<*>) = ap, fmap = liftM
05:41:09 <Jesin> and just leaving the defaults for the rest
05:42:18 <hpc> not to mention, optimizing for programmer time is a useful pursuit
05:49:59 <Jesin> hmm
05:50:05 <Jesin> if GHC inlines so aggressively
05:51:27 <Jesin> I do kind of wonder about this code
05:51:52 <Jesin> #ifdef USE_REPORT_PRELUDE
05:51:53 <Jesin> and                     =  foldr (&&) True
05:51:55 <Jesin> or                      =  foldr (||) False
05:51:56 <Jesin> #else
05:51:58 <Jesin> and []          =  True
05:51:59 <Jesin> and (x:xs)      =  x && and xs
05:52:01 <Jesin> [...]
05:52:02 <Jesin> #endif
05:52:51 <Bynbo7> ghc doesn't inline all that aggressively, especially for recursive functions
05:53:18 <Jesin> well
05:53:25 <Jesin> {-# INLINE [0] foldr #-}
05:53:26 <Jesin> foldr k z = go
05:53:28 <Jesin>           where
05:53:29 <Jesin>             go []     = z
05:53:31 <Jesin>             go (y:ys) = y `k` go ys
05:53:35 <Jesin> :p
05:54:03 <Jesin> I would think the definition of "and" given in the report prelude
05:54:11 <Jesin> would be simple enough to get inlined almost always
05:54:29 <Bynbo7> it's quite possible that those definitiopns are no longer necessary
05:54:30 <Jesin> if not, they could just add an {-# INLINE and #-} pragma
05:54:42 <Bynbo7> but were at some point when ghc was less intelligent
05:55:22 <Jesin> and the foldr definition would get inlined to... basically the definition that's explicitly written out
05:55:23 <hpc> hysterical raisins, etc
05:55:54 <Jesin> I would like to get that cleaned up, because I thought that meant that kind of coding style was a good idea
05:56:05 <Jesin> like, writing everything out instead of just composing stuff
05:56:08 <Bynbo7> which one?
05:56:21 <Jesin> which one what?
05:56:36 <Bynbo7> well, it depends on many things, sometimes you need to write things out to get better performance, sometimes ghc is smart enough
05:56:42 <Jesin> nah, the weird foldr definition makes sense
05:56:45 <Bynbo7> it's all a matter of benchmarking ;)
05:56:49 <Jesin> I just meant, like, and
05:56:51 <Jesin> :p
05:56:52 <Jesin> k
05:57:02 <Jesin> maybe I should do some of that
05:57:24 <Bynbo7> I'd be surprised if these days those two definitions of and produced different code
05:57:29 <Jesin> but, if the "and" definition is unnecessary (and with that "foldr" I don't see how it *would* be necessary)
05:57:42 <Jesin> I'd like to see that cleaned up soon  :p
05:58:25 <Jesin> also, I do wonder how default definitions get used in typeclass instantiation
05:58:31 <Bynbo7> file a bug then, ask in #ghc. do it yourself! :P but if you do, make sure you benchmark it and find out tht there is no difference
05:58:47 <Jesin> oh, I didn't know there was a #ghc
05:58:50 <Jesin> hm, k
05:59:02 <Jesin> I'll have to figure out how to do that sometime  :p
05:59:28 <Jesin> I've been playing with the concepts of the language but I'm still kind of new to messing with compilers
06:00:12 <Bynbo7> well, that isn't really messing with the compiler, just the prelude code that comes with it
06:00:22 <hpc> the first rule of freenode: if there is a program on the internet, it has a channel here :P
06:00:46 <Bynbo7> if there is no channel, there is no problem. Next!
06:00:46 <DevHC> define the internet
06:00:51 <Jesin> lol
06:05:17 <DevHC> let's vote for a new feature if it hasn't been propsed yet
06:05:25 <DevHC> allow general expressions in ``
06:06:00 <Jesin> what happens if you try to nest it
06:06:02 <Jesin> :p
06:06:07 <Jafet> \`
06:06:09 <DevHC> epic failure
06:06:19 <Jesin> \`
06:06:21 <Jesin> LOL!
06:06:23 <Jesin> :p
06:06:32 <Jesin> Jafet:
06:06:37 <Jesin> what about more levels of nesting?
06:06:44 <Jesin> \\` obviously wouldn't work
06:06:54 <Jesin> would we have to use \\\` for the second level?
06:07:09 <Jesin> oh!
06:07:10 <Jesin> or
06:07:15 <Jesin> we could just use it twice
06:07:37 <Jesin> foo `bar ``baz`` qux` quuxen
06:07:42 <Jesin> XD
06:07:57 <DevHC> which is `bar` applied to `baz` applied to .. or something
06:07:59 <Jesin> see, `` by itself is a parse error
06:08:03 <Jesin> so I think that would actually work
06:08:16 <Jesin> foo `bar ``baz`` qux` quuxen -- is equivalent to
06:08:33 <Jesin> (baz bar qux) foo quuxen
06:08:40 <Jesin> so
06:08:46 <Jesin> baz bar qux foo quuxen
06:08:48 <Jesin> basically
06:09:00 <DevHC> `(something `my expr`something)`
06:09:14 <DevHC> ^ alternative: use parens
06:09:21 <Jesin> I like that better
06:09:30 <Jafet> Or you two could direct your hyperactive energy towards something useful, like a universally accepted record subtyping system
06:09:51 <Jesin> I dunno what those are
06:09:57 <DevHC> yeah like
06:10:00 <DevHC> WAT?
06:10:01 <Jesin> but something useful sounds like a better idea than extending ``
06:10:59 <Ptival> @src sum
06:10:59 <lambdabot> sum = foldl (+) 0
06:13:02 <sipa> @pl \x -> h (f x) (\s -> g s x)
06:13:02 <lambdabot> liftM2 h f (flip g)
06:18:23 <roconnor> Is it a holiday in the UK and or in Europe?
06:19:14 <copumpkin> roconnor: wondering where all the nottingham people are?
06:19:15 <copumpkin>  :P
06:19:43 <roconnor> indeed
06:19:53 <roconnor> I need to urgently book a flight to france
06:20:03 <roconnor> and it is $500 cheaper if I take a side trip to london.
06:20:14 <roconnor> ... stupid non-monotonic airline prices
06:20:21 <copumpkin> oh, you'd like to meet up with some of them?
06:20:35 <roconnor> well if it is $500 cheaper to go to london than to not go to london
06:20:48 <roconnor> I figure it is a good opportunity
06:20:48 <copumpkin> but then you get mugged for $600 in london
06:20:48 <xarch> it's holidays for some parts of France, if you wonder
06:20:58 <xarch> h
06:21:00 <copumpkin> a friend of mine got stabbed
06:21:02 <roconnor> xarch: some parts?
06:21:07 <xarch> it's a holiday, I mean
06:21:10 <xarch> roconnor: yeah
06:21:17 <xarch> there are three parts
06:21:19 <copumpkin> roconnor: you could try the agda/epigram mailing list
06:21:20 <roconnor> xarch: what about the paris parts
06:21:28 <xarch> hm
06:21:32 <xarch> it just finished
06:22:06 <roconnor> copumpkin: I emailed Venanzio Capretta last night
06:22:34 <pozic> roconnor: where are you now?
06:22:48 <roconnor> Ontario
06:23:14 <hpaste> EugeneSmolanka pasted "test.hs"  http://hpaste.org/44447
06:24:25 <roconnor> copumpkin: airlines are funny
06:25:06 <roconnor> copumpkin: what I call a trip to paris with side trip to london, they call a round trip to london with a 3 month stop over in paris.
06:26:24 <copumpkin> lol
06:27:16 <mux> who's coming to paris? :)
06:27:22 <roconnor> I am
06:27:45 <mux> roconnor: I live there, maybe we should arrange something haskell-related?
06:27:51 <roconnor> cool
06:28:00 <mux> like, exchanging our monad tutorials or something
06:28:03 * mux giggles
06:28:04 <roconnor> ;)
06:28:06 <copumpkin> roconnor: good luck, gotta go to work now :)
06:29:11 <Jafet> The world's first monad tutorial convention
06:30:51 <xarch> there are too much haskell programmers in paris 
06:30:55 <xarch> :/
06:31:34 <roconnor> xarch: not enough ocaml programmers?
06:31:47 <xarch> hm
06:31:53 <xarch> I meant the opposite actually
06:31:56 <xarch> oops
06:36:33 <Ptival> consprod a:(as@(b:c:d:e:_)) = a*b*c*d*e : consprod as
06:36:39 <Ptival> is there a right way to write this?
06:37:02 <Ptival> (with tail I can see it, but can I have an inner @ like I'm trying to do?)
06:37:18 <sipa> well, try it?
06:37:19 <byorgey> Ptival: so you're taking successive products of a "sliding window" of 5 elements at a time?
06:37:25 <byorgey> the inner @ should work fine
06:37:33 <Ptival> byorgey: exactly
06:37:50 <Ptival> well this does not :\ "Parse error in pattern"
06:38:03 <opqdonut> consprod = map (product.take 5) . tails
06:38:24 <Ptival> opqdonut: well thanks
06:38:36 <sipa> oh
06:38:49 <sipa> consprod (a:(as@(b:c:d:e:_))) = a*b*c*d*e : consprod as
06:39:04 <byorgey> note opqdonut's solutions will give you some extra values on the end
06:39:15 <opqdonut> yeah, depending on the semantics you want
06:41:15 <byorgey> > let takeIMeanIt 0 _ = Just []; takeIMeanIt n (x:xs) | n > 0 = (x:) `fmap` takeIMeanIt (n-1) xs; takeIMeanIt _ _ = Nothing   in catMaybes . map (fmap product . takeIMeanIt 5) . tails $ [1,5,4,2,10,3,6,7,1]
06:41:16 <lambdabot>   [400,1200,1440,2520,1260]
06:42:19 <Ptival> :t tails
06:42:20 <lambdabot> forall a. [a] -> [[a]]
06:42:28 <Boxo> > map (product.take 5) . filter ((>=5) . length) . tails $ [1,5,4,2,10,3,6,7,1]
06:42:29 <lambdabot>   [400,1200,1440,2520,1260]
06:42:30 <byorgey> > tails [1,2,3,4,5]
06:42:30 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
06:42:32 <Ptival> @src tails
06:42:32 <lambdabot> tails []         = [[]]
06:42:33 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
06:42:40 <Ptival> where is tails?
06:42:45 <Ptival> @info tails
06:42:45 <lambdabot> tails
06:42:49 <Ptival> :\
06:42:53 <djahandarie> Useful command, lambdabot 
06:43:10 <djahandarie> Ptival, it's from Data.List
06:43:14 <Ptival> ok
06:43:27 <djahandarie> And you can @hoogle for stuff if you don't know where it comes from
06:43:36 <quicksilver> @index tails
06:43:37 <lambdabot> Data.List
06:43:52 <djahandarie> Though using hayoo for that would be more useful since it indexes all of hackage while I don't think there is an instance of hoogle out there that does
06:45:00 <sm> morning.. I thought current hoogle does that if you add +package
06:45:15 <quicksilver> sm: only for the package database it has been run against
06:46:13 <accel> I realize the following may sound advanced to someo of you (ir so, feel free to bow before me) -- is there an inverse of !/seq in haskell? I.e. something that says -- don't cache this result -- have it remain lazy and reaclculate it every time it's needed?
06:46:40 <Saizan> there isn't
06:46:49 <sipa> data MakeLazy a = MakeLazy a
06:46:59 <accel> is there any technical implementation that makes it hard to impelment?
06:47:26 <Saizan> MakeLazy will prevent seq from having its usual effect, but it won't prevent sharing
06:47:42 <accel> right; and it's sharing that I want to kill
06:48:19 <Saizan> you can pass around a function though
06:48:42 <accel> so when I call the function, it generates a lazy var that is the result?
06:48:50 <accel> but why wouldn't the function call be shared/cached ?
06:48:50 <quicksilver> it's hard to be sure that the body of your function doesn't get lifted to a CAF and shared though
06:49:02 <Saizan> i.e. instead of something of type X, something of type () -> X, then each application should not be shared with the others
06:49:08 <quicksilver> accel: function calls are never cached.
06:49:09 <Jafet> Something about this sounds evil
06:49:12 <Saizan> yeah, you've to pay attention to optimizations
06:49:21 <quicksilver> but, see my caveat above.
06:49:40 <sipa> if you have referential transparency, sharing shouldn't matter ;)
06:49:56 <accel> it's a matter of whetehr someting is O(1) or O(n) in space
06:50:41 <Saizan> i don't know how hard it be to mark a thunk as "DO NOT UPDATE THX"
06:50:49 <quicksilver> accel: see http://hackage.haskell.org/trac/ghc/ticket/917
06:51:10 <accel> quicksilver: yeah, my question was motivated by reading that
06:51:27 <Jafet> Well, with this you could do lovely things like real IO in pure code
06:51:44 <Jafet> (Doing IO every time a value is requested)
06:52:01 <pozic> I see zero reason to do hacks like this. 
06:52:17 <quicksilver> pozic: the reason is, when sharing the value causes a substantial space consumption.
06:52:20 <pozic> Why can't you just build a data structure with an API. 
06:52:28 <pozic> ?
06:52:57 <pozic> quicksilver: you can always write it without sharing, no?
06:53:11 <quicksilver> you can't guarantee it, no
06:53:16 <quicksilver> you can only try to outguess the optimiser.
06:53:31 * accel thinks
06:53:34 <pozic> It is not an optimiser if it doesn't optimise ;)
06:53:43 <Jafet> Pessimizer
06:53:55 <pozic> In the case of GHC you can turn off certain optimizations related to this, right?
06:54:01 <Bynbo7> it is optimising, by only ever doing work once
06:54:01 <quicksilver> optimizer in "Not Getting Everything Right" shocker.
06:54:07 <accel> man, ocaml is starting to look prettier day by day
06:54:15 <accel> actually, not ocaml
06:54:22 <accel> but being able to control strictness/laziness
06:54:25 * accel didn't mean to troll
06:54:40 <djahandarie> You can turn of full laziness in GHC
06:54:42 <djahandarie> off*
06:54:44 <Saizan> does ocaml ever give you sharing?
06:54:57 <accel> in ocaml; it's explicit to me if the list is strict
06:55:07 <accel> or if it's a bunch of (lambda() 's)
06:55:31 <Saizan> right, but it's hard to recover any sharing from the bunch of lambdas
06:56:17 <accel> not having sharing does not concer me
06:56:17 <quicksilver> yes, the \()-> encoding gets you non-strict evaluation but it doesn't get you laziness
06:56:23 <accel> not having control over strictness/laziness/sharing does
06:56:35 <accel> quicksilver: eh?
06:56:45 <accel> I think of haskell
06:56:46 <quicksilver> accel: laziness == sharing. That's what the word means.
06:56:49 <accel> where every value is wrapped up in \() ->
06:56:56 <quicksilver> non-strict evaluation = not evaluating an expression until you need it
06:56:58 <accel> no, laziness = don't exec it until it's needed
06:57:05 <quicksilver> laziness = storing that value once evaluated.
06:57:09 <quicksilver> accel: I'm afraid you are wrong.
06:57:14 <accel> quicksilver: provide link plese
06:57:20 <sipa> i think it's both actually
06:57:21 <Saizan> yeah, accel, you're wrong :)
06:57:26 <pozic> accel: essentially you are stating the theorem: there exists some computation which cannot be done in O(optimal) space in Haskell. 
06:57:37 <accel> okay, give me a link that laziness = sharing
06:57:43 <pozic> accel: I don't think it is true, but you are welcome to come up with a proof.
06:57:45 <Jafet> I think that the real solution is more polymorphism.
06:57:55 <Saizan> accel: see the difference between call-by-name and call-by-need
06:57:57 <Bynbo7> accel: this is a very well known problem, with very well known, and simple solutions. why must you keep fighting it?
06:58:01 <owst> look at: call-by-name vs call-by-need
06:58:19 <Jafet> If you used Sequence s => s a instead of [a], you could then replace the space leaking parts with optimized Sequences.
06:58:20 <Bynbo7> it'sd like continually asking why isn't insertion sort faster in C
06:58:49 <accel> Bynbo7: because progress ia mde by people saying "this sucks, let's fix it" rahter than "this sucks; okay, let's accept it'
06:59:04 <quicksilver> accel: the word laziness in general is indeed misused and overused (you might say, we are lazy in our terminology) - however once you are discussing a *precise* evaluation model, like we just were about ocaml lists, then the terminology is normally used more carefully.
06:59:06 <accel> question is: why are you not working on fixing this?
06:59:24 <accel> quicksilver: can you provide me a link to this definition? clearly my intuition is wrong somewhere
06:59:40 <Bynbo7> sure, but stupid little problems like this are not something that have an easy fix, and are extremely easy to overcome. 
06:59:50 <quicksilver> accel: a lists of "\() ->" expressions gives you non-strict evaluation, in that the parts aren't evaluated until needed, but laziness is the additional step where you store the result, once evaluated.
07:00:08 <accel> quicksilver: taht soudns like memoization
07:00:15 <quicksilver> it does sound like it, yes.
07:00:29 <accel> in fact, ! can almost be taken to mean "cache this result"
07:00:36 <Saizan> accel: first sentence: http://en.wikipedia.org/wiki/Lazy_evaluation
07:00:42 <Bynbo7> no it can't
07:01:09 <Jafet> seq doesn't cause sharing, it causes evaluation
07:01:19 <Saizan> accel: though that first sentence is quite vague about what are "repeated evaluations"
07:01:22 <accel> this is a silly request
07:01:36 <accel> but in lisp, I can understand it's executation model through the meta circular evaluator, like in chapter 4 of sicp
07:01:39 <accel> what's the equiv in haskell?
07:01:41 <mux> I have quite often heard the definition laziness == non-strict evaluation + sharing from haskellers; I have yet to read in an actual CS paper/book. I'm not sure if the term is consistently defined within the field
07:01:48 <Saizan> but call-by-need is a precise evaluation strategy.
07:01:53 <accel> is there a clear execution model for haskell?
07:01:59 <Saizan> yes
07:02:01 <accel> something clearer than "whatever ghc feels like doing"
07:02:13 <Saizan> well, for haskell as in the haskell report no
07:02:18 <copumpkin> accel: sounds like you're making assumptions here
07:02:26 <accel> copumpkin: what assumptions?
07:02:28 <Saizan> it jsut requires non-strict evaluation
07:02:36 <Saizan> though we all expect lazyness :)
07:02:38 <proe> hello
07:02:59 <Bynbo7> just having non strict evaluation would suck >_<
07:03:00 <mux> It would be nice if Haskell's execution model could be defined more clearly via operational semantics
07:03:00 <accel> i'm willing to admit I may be wrong; but I want proof :-)
07:03:27 <quicksilver> as I recall, lazineess and non-strictness are defined in the SPJ/Lester book : http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
07:03:45 <proe> can haskell handle video streaming?
07:03:50 <quicksilver> (I don't mean to imply that source is original or canonical, but its reference list is probably a good place to look for older references)
07:04:04 <sipa> @faq can haskell handle video streaming?
07:04:04 <Bynbo7> proe: as in a web server streaming video? or something else?
07:04:04 <lambdabot> The answer is: Yes! Haskell can do that.
07:04:08 <accel> http://hackage.haskell.org/trac/ghc/ticket/917 <-- for example, in this link  ... if this code was done in scheme, I'd be able to "see" how it eecuted by running it through the chapter 4 of sicp; how can I equivalently "see" how this code runs in ahskell?
07:04:16 <Bynbo7> proe: the answer is of course yes though
07:04:21 <accel> @faq can haskell decide the halting problem?
07:04:21 <lambdabot> The answer is: Yes! Haskell can do that.
07:04:26 <accel> @faq can haskell give me ops?
07:04:26 <lambdabot> The answer is: Yes! Haskell can do that.
07:04:29 <accel> liar
07:04:30 <sipa> @faq can haskell do the dishes?
07:04:30 <lambdabot> The answer is: Yes! Haskell can do that.
07:04:44 <copumpkin> @faq can accel shut the fuck up about getting ops?
07:04:44 <lambdabot> The answer is: Yes! Haskell can do that.
07:04:46 <proe> thanks.
07:04:47 <sipa> i do fear it involes some impureness :(
07:04:56 <accel> lol
07:05:04 <copumpkin> I think it's lying
07:05:11 <proe> i just got to know about haskell today. i will give it a try.
07:05:29 <pozic> accel: you grab a pen and you grab some paper, after you read some academic books about Haskell.
07:05:37 <sipa> on the other hand, if i do it by hand, it definitely causes destructive updates from time to time
07:05:41 <accel> so basically it's by hunch
07:05:46 <accel> rather than by a clearly defined model
07:05:47 <pozic> accel: no.
07:05:53 <Saizan> it is clearly defined.
07:05:59 <mux> nothing gets me down like seeing an interesting discussion going in #haskell while there's a visual studio c++ instance staring at me on my windows xp work computer.
07:06:01 <pozic> accel: I think the model is clear, but there is no formal model.
07:06:02 <Saizan> just on paper rather then somewhere executable.
07:06:10 <proe> bye
07:06:38 <copumpkin> mux: aww
07:06:42 <accel> to be nasty: in C/python/ruby/C++/scheme ... is there any sitaution where turning up the optimiation level amkes the big-oh running time worse?
07:06:58 <copumpkin> python/ruby optimization level?
07:07:01 <Bynbo7> accel: what do you want? someone to write out the entire evaluation model for haskell compiled by GHC right here in the channel for you? go and do some reading!
07:07:03 <copumpkin> those words go together?
07:07:21 <pozic> accel: Haskell and GHC have nothing to do with eachother.
07:07:27 <pozic> accel: Next question.
07:07:37 <pozic> @next
07:07:37 <accel> scheme has a very clear eecution model efined in chapters 4/5 of sicp
07:07:38 <lambdabot>  Defined.
07:07:44 <accel> where does haskell have this?
07:07:44 <Bynbo7> pozic: oh god no please >_<
07:07:55 <mux> accel: it doesn't, as others have said already
07:08:01 <copumpkin> accel: it also defines its own parser 
07:08:08 <copumpkin> accel: the language is simple, and is designed to be
07:08:11 <copumpkin> haskell is not
07:08:20 <accel> this doesn't seem very mathematical
07:08:36 <Bynbo7> ha
07:08:36 <copumpkin> accel: go look up some papers and read them
07:08:38 <accel> seems rather hacky for all the theoretical stuff haskell builds itself upon
07:08:45 <accel> copumpkin: links?
07:08:46 <Bynbo7> copumpkin: it's no use man -_-
07:08:55 <copumpkin> accel: find them yourself :P you're not making me want to go find you anything
07:09:13 <Saizan> accel: the result of evaluating an haskell expression is clearly defined, the operational behaviour of doing so isn't
07:09:14 <accel> okay so let me get this straight
07:09:14 <int-e> accel: the semantics are too easy: equational reasoning just works! (just kidding)
07:09:21 <accel> to understand, to visualize how haskell executes a piece of code
07:09:25 <accel> i need to dig up reserach papers
07:09:28 <Jafet> accel: we don't care about your complaints, so there's no point trying to troll a response out from us.
07:09:33 <accel> just to be able to look at a piece of haskell code
07:09:40 <Jafet> As for me, I wouldn't mind you going away.
07:09:41 <accel> and get it's big-Oh space usage out of it
07:09:47 <Saizan> accel: if every operational detail was established in the standard there would be no room for optimizing compilers
07:09:59 <Bynbo7> yes, that's exactly correct, if only you would actually do that accel you wouldn't be wasting all our time
07:10:43 <accel> C/C++ can still do optimizations, even given standards
07:10:47 <accel> err, gcc/g++
07:10:54 <Bynbo7> haskell was never designed as a language with high performance in mind, that's just something we've come to expect in recent years
07:11:15 <Saizan> accel: right, but then they are evaluating differently than what you'd expect from a trivial C implementation
07:11:18 <Bynbo7> and we're finding that, golly, some of these problems are hard to fix, whodathunkit!
07:11:32 <accel> and when someone asks about them
07:11:33 <Jafet> And I wouldn't mind others to stop proving me wrong about them not caring
07:11:33 <orbital_fox> accel, whatis your point btw? i just started reading now?
07:11:37 <accel> let's lynch them
07:11:56 <Saizan> accel: gcc even constant folds loops into their answers, that's ends up running with quite different big-O performance
07:11:59 <Bynbo7> when someone asks about them, they are given answers. if they choose not to read the answers, that's their own problem
07:12:05 <pumpkin> accel: you're just saying "it's not very mathematical" that we don't have a "formal model", and now you're annoyed that you have to read papers?
07:12:22 <accel> pumpkin: I don't ind reading papers
07:12:31 <pumpkin> then don't expect to be spoon-fed
07:12:33 <Bynbo7> obviously you do
07:12:35 <accel> i just find it hilarious that to understand something as basic as "how does haskell execute this piece of code"
07:12:38 <djahandarie> accel, people in this channel have been answering you for the past 30 minutes, not lynching you.
07:12:39 <accel> ... isn't even documented in books
07:12:42 <accel> but only in primary resources
07:13:00 <pumpkin> have you read the report?
07:13:02 <nostard> accel: it's not basic
07:13:04 <rwbarton> I don't think C or any programming language is any different
07:13:15 <Bynbo7> ffs, quicksilver, how long do we have to put up with this? this is the worst kind of trolling, one that wastes everyone else's time
07:13:16 <orbital_fox> accel, there are different ways to design things, top down, and bottom up
07:13:17 <rwbarton> considering that compilers are improving all the time
07:13:28 <Saizan> accel: "how haskell execute this piece of code" doesn't have an answer. the only thing that's defined is the result of haskell evaluation
07:13:29 <pozic> I wonder why this always makes #haskell explode. 
07:13:31 <Jafet> The trollees seem to enjoy it, else they wouldn't be responding.
07:13:33 <accel> does C/C++ compilers ever make big-oh running time worse?
07:13:36 <pozic> That didn't use to be the case. 
07:13:44 <Jafet> Just leave the stereo.
07:13:48 <orbital_fox> apparently haskel is top down, top being abstract/mathematical and expressive requirements
07:13:49 --- mode: ChanServ set +o pumpkin
07:13:50 <pozic> The C++ standard is not even a free standard, if you like complaining.
07:13:56 <quicksilver> Bynbo7: if it bothers you, then stop replying.
07:14:06 <int-e> Saizan: I guess we should have an operational semantic for the IO monad. (and possibly ST)
07:14:12 <Bynbo7> it bothers me that it's wasting everyone's time, not just mine
07:14:20 <pumpkin> and drowning out other responses
07:14:27 <accel> Bynbo7: I eventually take advice; I actually read chapters of RWH.
07:14:28 <hpaste> b52 pasted "Google Code Jam"  http://hpaste.org/44448
07:14:35 --- mode: pumpkin set +q accel!*@*
07:14:37 <int-e> Saizan: not that I want to write on. (And IIRC the concurrent Haskell papers define fragments of it anyway.)
07:14:40 --- mode: pumpkin set -o pumpkin
07:14:41 <Bynbo7> how many months did that take you?
07:15:02 <b52> Bynbo7: i solved the problem myself, in good looking way i think: http://hpaste.org/44448/google_code_jam
07:15:10 <orbital_fox> Bynbo7, people can choose how they want to waste their time, no one has to join or respond
07:15:13 <b52> but i still got a problem, its not very fast :/
07:15:35 <b52> do you have an idea where i could try to optimize it?
07:15:42 <Bynbo7> b52: foldr1 (++) is concat
07:15:59 <orbital_fox> pumpkin, that is irc issue, not people's wanting to express them selves
07:16:09 <b52> Bynbo7: ?
07:16:15 <Bynbo7> :t concat
07:16:16 <lambdabot> forall a. [[a]] -> [a]
07:16:27 <Bynbo7> :t foldr1 (++)
07:16:28 <lambdabot> forall a. (Monoid a) => [a] -> a
07:16:32 <Bynbo7> bah
07:16:36 --- mode: ChanServ set +o pumpkin
07:16:40 <Bynbo7> :t foldr1 (++) :: [[a]] -> [a]
07:16:41 --- mode: pumpkin set -q accel!*@*
07:16:41 <lambdabot> forall a. [[a]] -> [a]
07:16:44 <accel> wtf, why did I get silenced?
07:16:45 --- mode: pumpkin set -o pumpkin
07:16:51 <int-e> accel: but for a large part, Saizan is right - the objective is to make equational reasoning sound (purity), and be non-strict; purity makes graph rewriting sound and that's what most (all?) haskell implementations do.
07:16:57 <pumpkin> accel: cause you're annoying as fuck, but others seem to want to talk to you
07:17:02 <b52> where do i use concat Bynbo7 ?
07:17:02 <pumpkin> so I'll leave it
07:17:18 <pozic> I think accel should get a useful answer. 
07:17:21 <Bynbo7> you don't, you should be using concat instead of foldr1 (++)
07:17:32 <Bynbo7> pozic: he's been given many
07:17:36 <int-e> pumpkin: sorry, how long has this been going on?
07:17:40 <b52> Bynbo7: why?
07:17:43 <pumpkin> pozic: I agree, but I also think he should make people want to help him
07:17:45 <pozic> Bynbo7: and apparently he didn't understand any of them. 
07:17:56 <Bynbo7> b52: because that's what it's therte for
07:18:15 <pozic> So, perhaps either nobody should say something or someone should take the time to explain or point at a precise primary resource.
07:18:26 <Saizan> accel: what haskellers do pragmatically is use call-by-need as a good approximation of what GHC would actually do
07:18:37 <Bynbo7> pozic: there's a huge difference between not understanding, and not reading the answers at all. he was given many places to look for the answers he wanted, and refuses to read any of them
07:18:45 <pozic> Or we can take the policy that everyone with too little knowledge of the Omega number must be kicked.
07:18:51 <b52> Bynbo7: ok, but thats not the problem :D
07:18:57 <Saizan> accel: and if they have to be extremely precise they look at GHC's produced Core
07:19:16 <Bynbo7> b52: sure, but good coding style it always something you should aim for
07:19:24 <b52> agree
07:19:28 <orbital_fox> pumpkin, accel et al, just make a temp sub channel if you like for this discussion, that way it wont "flood" this channel
07:19:29 <Bynbo7> reinventing the wheel is usually not a great idea
07:19:38 <pumpkin> #haskell-overflow
07:19:43 <pumpkin> for accel and others who want to talk to him
07:19:51 <pumpkin> (just a suggestion, as orbital_fox did too)
07:20:15 <Saizan> accel: anyhow, the point is that wrapping things in lambdas like you'd do to emulate "lazyness" in ocaml only gives you call-by-name, not call-by-need
07:20:39 * Bynbo7 suggests #haskell-ask-questions-dont-listen-to-answers
07:21:15 <Bynbo7> b52: do you know where most of the time is being spent in your code?
07:21:20 <accel> ah; this ameks sense: Call-by-need is a 2http://en.wikipedia.org/wiki/Memoization version of call-by-name where, if the function argument is evaluated, that value is stored for subsequent uses
07:21:41 <b52> Bynbo7: i think "round", but can i investigate that a bit further?
07:22:10 <orbital_fox> accel, come on man, take it to #haskel-overflow, just switch there and we can talk there, its a nice subjects but it can choke people here
07:22:11 <Bynbo7> b52: what is round supposed to do?
07:23:12 <b52> its supposed to get a slice of a list which sums doesnt exceed a defined value
07:23:49 <Bynbo7> can you give examples?
07:24:25 <Bynbo7> using xs++[x] will always poerform very badly if you use it a lot
07:24:28 <b52> sure, max is 4, the list is [1,2,3,4] result would be [1,2]
07:25:01 <b52> should i try to use foldl or something?
07:27:17 <Bynbo7> well, something like this may do it (let's see if i can get it right)
07:27:46 <opqdonut> iterating through xs++[x] is actually quite ok
07:27:59 <opqdonut> the problem is having thunks of the form (((xs++a)++b)++c)
07:28:22 <opqdonut> a-la foldl (++)
07:28:32 <Bynbo7> > let round k xs = map fst . takeWhile ((<= k) . snd) . zip xs . scanl1 (+) $ xs in round 4 [1,2,3,4]
07:28:34 <lambdabot>   [1,2]
07:28:39 <Bynbo7> > let round k xs = map fst . takeWhile ((<= k) . snd) . zip xs . scanl1 (+) $ xs in round 7 [1,2,3,4]
07:28:40 <lambdabot>   [1,2,3]
07:28:47 <Bynbo7> :D
07:28:52 <Bynbo7> first time, booyah!
07:29:12 <b52> hehe
07:29:36 <Bynbo7> > let round k = map fst . takeWhile ((<= k) . snd) . zip xs . scanl1 (+) in round 7 [1,2,3,4]
07:29:37 <lambdabot>   Not in scope: `xs'
07:29:42 <Bynbo7> bah
07:30:02 * Bynbo7 goes back to his non-pointfree world again
07:30:31 <DevHC> "error: a C finalizer called back into Haskell. This was previously allowed, but is disallowed in GHC 6.10.2 and later."... ok, then the FFI documentation for touchForeignPtr is bullshit: "This function can be used to express liveness dependencies between ForeignPtrs: For example, if the finalizer for one ForeignPtr touches a second ForeignPtr, then it is ensured that the second ForeignPtr will stay alive at least as long as the first. This can be use
07:30:31 <DevHC> ful when you want to manipulate interior pointers to a foreign structure: You can use touchForeignPtr to express the requirement that the exterior pointer must not be finalized until the interior pointer is no longer referenced."... or?
07:30:34 <hpc> @pl round k xs = map fst . takeWhile ((<= k) . snd) . zip xs . scanl1 (+) $ xs in round 7 [1,2,3,4]
07:30:34 <lambdabot> (line 1, column 76):
07:30:34 <lambdabot> unexpected reserved word "in" or "i"
07:30:34 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
07:30:45 <hpc> @pl round k xs = map fst . takeWhile ((<= k) . snd) . zip xs . scanl1 (+) $ xs
07:30:45 <lambdabot> round = join . ((map fst .) .) . (. ((. scanl1 (+)) . zip)) . (.) . takeWhile . (. snd) . flip (<=)
07:30:51 <sm> humble request to ops: please don't silence/kick people without both warning and announcing. and preferably don't do it at all for anything less than extreme spamming. Excessive use of power hastens the channels slide toward #c++
07:32:02 <Bynbo7> sm: for an issue that's been going on for weeks, it doesn't feel like it was hasty to me, far from it
07:33:25 <DevHC> @where ffi
07:33:25 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
07:33:46 <DevHC> @where simon
07:33:47 <lambdabot> I know nothing about simon.
07:33:53 <DevHC> @where simon-peyton
07:33:53 <lambdabot> I know nothing about simon-peyton.
07:34:00 <DevHC> @where simon peyton jones
07:34:00 <lambdabot> I know nothing about simon.
07:34:06 <DevHC> @where "simon peyton jones"
07:34:07 <lambdabot> I know nothing about "simon.
07:34:14 <DevHC> @where simon-peyton-jones
07:34:14 <lambdabot> I know nothing about simon-peyton-jones.
07:34:18 <djahandarie> DevHC, what are you looking for?
07:34:23 <DevHC> FFI experts
07:35:10 <DevHC> .. who can acknowledge my findings about the FFI documentation
07:35:21 <Bynbo7> i don't believe he's as much of an expect as someone like TacticalGrace (who wrote most of it) is
07:35:33 <DevHC> i'm not asking specifically him
07:35:41 <Bynbo7> it would probably be better to ask in #ghc btw
07:35:47 <DevHC> :o
07:36:10 <DevHC> it's not ghc specific, actually
07:37:22 <DevHC> about finalizers: "Whether a finalizer may call back into the Haskell system is system dependent. Portable code may not rely on such callbacks."; notes on touchForeignPtr: "This function can be used to express liveness dependencies between ForeignPtrs: For example, if the finalizer for one ForeignPtr touches a second ForeignPtr, then it is ensured that the second ForeignPtr will stay alive at least as long as the first."
07:37:26 <DevHC> i see that as a contradiction
07:37:51 <Bynbo7> isn't GHC the only compiler that impliments the FFI?
07:38:20 <DevHC> definitely not the only
07:38:23 <quicksilver> hugs has some FFI support
07:38:40 <quicksilver> jhc has complete(?) FFI support
07:42:38 <DevHC> a finalizer is of type FunPtr (Ptr a -> IO ()). function pointers can be imported (C) code or wrapped haskell functions. so a finalizer is pragmatically some general, black boxed code to Haskell. it cannot be determined wether a general function "touches" another ForeignPtr. so how is touching supposed to work?
07:42:54 <DevHC> touching in finalizers, i mean
07:43:29 <DevHC> not to mention that touchForeignPtr is a haskell function, which cannot be (portably) used in a finalizer
07:52:14 <jonkri> is ross (mentioned at http://hackage.haskell.org/packages/accounts.html) around here somewhere? i just realized that i need a hackage account to be able to upload :P
07:52:27 <quicksilver> he doesn't IRC, or not often.
07:52:38 <djahandarie> Ross P?
07:52:46 <quicksilver> yes.
07:52:55 <djahandarie> Yeah I don't think I've ever seen him here
07:53:01 <jonkri> ok, thanks
07:56:30 <sipa> @pl \x y -> x >>= \v -> return (y v)
07:56:31 <lambdabot> (. (return .)) . (>>=)
07:59:06 <roconnor> are there any haskell related events on or around July 15th  in London?
08:01:48 <Saizan> you could organize AngloHaskell :)
08:02:13 <roconnor> I'd need a local organizer to help
08:02:18 <roconnor> and by help I mean do all the work
08:03:52 <orbital_fox> lol :P
08:14:38 <comex> I want to do something like [x | Foo x <- somelist], except that I also want a list of the elements that didn't match the pattern
08:14:54 <comex> partition instead of filter
08:14:58 <comex> is there a nice way to do this?
08:15:57 <roconnor> @hoogle partition
08:15:57 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
08:15:57 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
08:15:57 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
08:16:04 <quicksilver> partitionEither (f somelist) where f (Foo x) = Left x; f (OtherStuff x) = Right x;
08:16:14 * hackagebot HLogger 0.0.1.0 - Simple, concurrent and easy-to-use logging library  http://hackage.haskell.org/package/HLogger-0.0.1.0 (JonKristensen)
08:16:18 <quicksilver> I think it might be partitionEithers, with an s.
08:17:31 <Bynbo7> partition (\Foo{} -> True)?
08:17:40 <Bynbo7> needs false also...
08:17:58 <Bynbo7> partition (\x -> case of Foo{} -> True; _ -> False)
08:18:03 <Bynbo7> x*
08:22:16 <quicksilver> Bynbo7: odd. I don't know about that function.
08:22:35 <quicksilver> Bynbo7: anyhow I have the from comex's question that he also wants to unwrap the constructor
08:22:55 <quicksilver> which is the partitionEither version does
08:23:14 <comex> oh, cool
08:23:48 <Bynbo7> well, it depends on whether the type only has two constructors really
08:24:48 <quicksilver> true, and what the structure of those constructors are
08:25:02 <quicksilver> possibly mine could be generalised to stuff more into the 'Right' part
08:26:15 <comex> well, in the other case i just want to return the whole object
08:26:36 <comex> so f x = Right x
08:30:21 * hackagebot HXMPP 0.0.1.0 - A (prototyped) easy to use XMPP library  http://hackage.haskell.org/package/HXMPP-0.0.1.0 (JonKristensen)
09:05:11 <marekweb> hi, very new to haskell here; what does => mean in a function signature (as opposed to ->) ?
09:05:29 <shachaf> marekweb: Type class constraint.
09:05:29 * hackagebot derp 0.1.1 - Derivative Parsing  http://hackage.haskell.org/package/derp-0.1.1 (DavidDarais)
09:05:51 <shachaf> marekweb: You should probably read an introduction that explains it; I think LYAH is recommended around here.
09:05:54 <shachaf> @where lyah
09:05:54 <lambdabot> http://www.learnyouahaskell.com/
09:05:59 <edwardk> marekweb: the stuff on the left of the => are type class cosntraints on the types you are using.
09:06:17 <marekweb> I see, thanks
09:06:18 <edwardk> marekweb: Num a => a — says that you have a type that works for any a, such that a is an instance of Num.
09:06:46 <edwardk> marekweb: they get a fair bit more complicated than that, but thats the gist
09:06:53 * shachaf vaguely wonders why the syntax is (C a, D a) => a instead of C a => D a => a.
09:07:18 <edwardk> shachaf: good question. =)
09:07:35 <shachaf> I suppose there's no real benefit to the latter, but having a pseudo-tuple there is weird.
09:07:54 <int-e> shachaf: because the latter suggests that order matters, and it's not supposed to.
09:08:09 <int-e> just guessing.
09:08:10 <shachaf> int-e: So does the former.
09:08:10 <pozic> shachaf: , == "and". I am not sure why the parentheses are there. 
09:08:43 <shachaf> pozic: ->/=> is also very much like "and". :-)
09:09:10 <pozic> shachaf: ok, so they just flipped a coin ;)
09:09:26 <Lemmih> shachaf: How is -> like "and"?
09:09:31 <pozic> shachaf: I like how it is now better than your alternative. 
09:09:46 <pozic> One has to prove all the arguments to the -> 
09:09:54 <pozic> Just like in /\.
09:10:02 <shachaf> Lemmih: curry and uncurry.
09:10:19 <monochrom> ⇒ is not like ∧. however (x∧y)⇒z equals x⇒(y⇒z)
09:10:49 <pozic> monochrom: that is how I meant 'like'.
09:10:57 <shachaf> monochrom: Perhaps your meaning for the word "like" is different from mine. :-)
09:11:08 <monochrom> very different
09:11:15 <fryguybob> like is not like like.
09:11:20 <monochrom> my meaning is not like yours <duck>
09:11:52 <pozic> monochrom speaks monochromian like all people from Monogromia do. 
09:12:58 <ion> Buffalo buffalo Buffalo buffalo like like Buffalo buffalo.
09:13:03 <hpaste> inetic pasted "Infinite loop in cont monad?"  http://hpaste.org/44450
09:13:23 <monochrom> infinite loops are fun
09:14:53 <shachaf> ion: Buffalo buffalo like Buffalo buffalo like like like Buffalo buffalo.
09:15:09 <ion> hah
09:26:38 * hackagebot derp 0.1.2 - Derivative Parsing  http://hackage.haskell.org/package/derp-0.1.2 (DavidDarais)
09:26:47 <edwardk> hah, love the name
09:26:53 <byorgey> =)
09:27:39 * hackagebot derp 0.1.3 - Derivative Parsing  http://hackage.haskell.org/package/derp-0.1.3 (DavidDarais)
09:28:06 <hpc> ha!
09:28:14 <byorgey> haha, the ol' package upload one-two
09:30:39 * hackagebot derp 0.1.4 - Derivative Parsing  http://hackage.haskell.org/package/derp-0.1.4 (DavidDarais)
09:30:51 <marekweb> herp derp
09:33:23 <confound> yeah that's what I keep thinking too
09:54:44 <roconnor> San Dimas!!  Excellent!
09:57:53 <byorgey> roconnor: ?
09:58:17 <roconnor> http://www.reddit.com/r/haskell/comments/fvwol/haskell_job_offer/
09:58:26 <roconnor> and http://en.wikipedia.org/wiki/Bill_%26_Ted%27s_Excellent_Adventure
09:58:36 <byorgey> ah =)
10:19:29 <HugoDaniel> how do i make a function have the same precedence as a type constructor ?
10:20:01 <mzero> you have to find the precedence and declares your similarly
10:20:06 <hpc> ^
10:20:08 <nyingen> anyone good with HaXml?
10:20:12 * hpc types slow :(
10:20:21 <mzero> there is no syntax for "make the precedence of this thing like that thing"
10:21:05 <HugoDaniel> oh hmm
10:21:19 <HugoDaniel> i just tested and both have the same precedence, makes sense
10:21:30 <HugoDaniel> i guess i should rest a bit :/
10:21:56 <monochrom> perhaps they both use the default precedence. default is unique.
10:22:42 <mzero> ah - the precedence of non-symbol functions and constructors IS the same, and it is higher than any symbol based function or constructor
10:24:00 <hpc> the precedence of `nonSymbolFunction` is the same as the precedence of `NonSymbolConstructor` too
10:24:19 <monochrom> it's all infixl 9 to me
10:26:27 <HugoDaniel> cool
10:37:24 <HugoDaniel> it would be nice to `f1 . f2 . f3` :)
10:37:57 <HugoDaniel> maybe in ghc 9000
10:38:31 <dmwit> `(f1 . f2 . f3)`
10:38:50 <dmwit> ...would be safer
10:38:52 <hpc> > 1 `(5 . 4 . 3)` 2
10:38:53 <dmwit> and nestable
10:38:53 <lambdabot>   <no location info>: parse error on input `('
10:38:55 <monochrom> haskell 2047 will allow `f1 . f2 . f3`
10:39:40 <dmwit> (It's not clear what to do with `f1 `f2` f3`, but `(f1 `f2` f3)` and `(f1 `(f2)` f3)` are both clear.)
10:40:44 <mercury^> It's bad that start and end are both represented by `;
10:41:06 <mercury^> One should just use two different characters for start and end.
10:41:08 <hpc> `(let x = 5 `(x . 5)` 5 in x x)` 5
10:41:09 <hpc> :D
10:41:15 <aristid> there are too few characters with symmetrical opposites
10:41:24 <mercury^> It need not be symmetrical.
10:41:31 <hpc> mercury^: it's fine; start is "`("; end is ")`"
10:41:44 <monochrom> haskell 2086 will do away with plain text syntax altogether
10:42:11 <mercury^> Yes. Programs will be written in Microsoft Word 2090;
10:42:43 <dmwit> You know what I learned recently? I learned that '(', despite being named LEFT PARENTHESIS by the Unicode spec, is in fact an *opening* parenthesis, and is rendered backwards in RTL contexts.
10:42:43 <hpc> mercury^: by then, the japanese and chinese will be the dominant countries
10:42:51 <hpc> mercury^: so it will be Microsoft Syllable :D
10:42:56 <allbery_b> yep
10:42:59 <HugoDaniel> ahaha
10:43:02 <HugoDaniel> :)
10:43:07 <c_wraith> dmwit: that's actually really handy.
10:43:28 <mercury^> That's really confusing.
10:43:33 <hpc> c_wraith: until you try and actually type something, that is
10:43:41 <mercury^> Are there proper LEFT and RIGHT parentheses at least?
10:44:13 <dmwit> mercury^: no
10:44:26 <hpc> one would think, if people are changing from ltr to rtl, they would also not be rendering the same document?
10:44:41 <hpc> or is that just me being unreasonably logical?
10:44:42 <monochrom> but they use the same punctuations
10:45:21 <monochrom> either way is confusing, if you ask me.
10:45:52 <shachaf> Why would you want LEFT and RIGHT parentheses?
10:46:23 <hpc> shachaf: clearly, a simple regular expression should tell which from which, and we can all just use | for all our nested syntax needs :P
10:46:45 <dmwit> shachaf: So I can tell weapons and tools apart even when playing Nethack in Farsi. ;-)
10:47:18 <monochrom> you need to grow out of 1970s terminals already
10:47:32 <shachaf> dmwit: The confusing thing is that when you type (in Hebrew, at least), you use the left parenthesis key on the NetHack to type a right parenthesis.
10:47:35 <dmwit> I really don't think 1970s terminals did Unicode, monochrom.
10:48:49 <monochrom> I am referring to the human mindset, not the terminal.
10:49:22 <aristid> monochrom: it's not just a mindset. it's partially also a lack of credible alternatives.
10:49:43 <Jafet> I cast level 5 immunity to reason
10:49:47 <jmcarthur> aristid: proof by lack of imagination?
10:49:56 <conal> fryguybob: thanks for the typo report. fixed now.
10:49:56 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
10:50:07 <monochrom> someone could easily make a GUI for NetHack and represent weapon/tool by simple icons rather than ( )
10:50:08 <jmcarthur> ah the person i'm quoting appears
10:50:21 <aristid> jmcarthur: i did not say it's impossible. just that right now there are no credible alternatives yet.
10:50:21 <fryguybob> :D
10:50:21 <jmcarthur> i do that quote a lot ;)
10:50:25 <dmwit> monochrom: Could and has.
10:50:32 <jmcarthur> aristid: ah alright
10:50:48 <shachaf> monochrom: And it's terrible.
10:50:56 <dmwit> monochrom: That particular complaint was very, very tongue-in-cheek.
10:50:57 <jmcarthur> aristid: you mean no *discovered* alternatives
10:51:05 <jmcarthur> i misinterpreted
10:51:29 * shachaf would like to play NetHack in something like Chinese.
10:51:37 <shachaf> No more "Your knapsack cannot accommodate any more items".
10:51:53 <nyingen> heh
10:51:57 <aristid> jmcarthur: i don't want to claim anything about the endless undiscovered possibilities :)
10:52:34 <c_wraith> one of my friends was playing nethack in japanese.  She reported the porting was terrible.  The game text was stored in two different encodings, apparently randomly.
10:53:02 <monochrom> God, what did I start?
10:53:04 <ben_m> Greetings, people :) I was wondering if it's possible to represent patterns like { 3, 2, 1, 6, 5, 4, 15, 14, 13, ... } in Haskell? (1+2+3 = 6, 6+5+4 = 15, ...)
10:53:32 <Jafet> We shall invent the definitive computer interface of the future. But it must be able to play NetHack.
10:53:58 <dmwit> > let f (a, b, c) = (a+b+c, a+b+c-1, a+b+c-2) in iterate f (3,2,1)
10:53:59 <lambdabot>   [(3,2,1),(6,5,4),(15,14,13),(42,41,40),(123,122,121),(366,365,364),(1095,10...
10:54:03 <shachaf> @faq Can Haskell represent patterns like { 3, 2, 1, 6, 5, 4, 15, 14, 13, ... }?
10:54:03 <lambdabot> The answer is: Yes! Haskell can do that.
10:54:19 <ben_m> dwmit, cool, thanks :)
10:54:23 <dmwit> You can probably get a closed form on the first elements, even.
10:54:33 * dmwit suddenly has regrets
10:54:37 <dmwit> Was that a homework problem?
10:54:40 <ben_m> No, really.
10:54:44 <dmwit> phew
10:54:49 <Zao> Your sequence sounds a bit underspecified.
10:54:56 <monochrom> a homework is way more well-specified than this "guess the pattern"
10:55:00 <hpc> > let f [a, b, c] = [a+b+c, a+b+c-1, a+b+c-2] in join . iterate $ [3,2,1]
10:55:00 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a]'
10:55:12 <dmwit> hpc: iterate f
10:55:13 <ben_m> It's actually a question from a friend, who is a Lisp zealot so I automatically told him "sure, HAskell can do that"
10:55:15 <hpc> > let f [a, b, c] = [a+b+c, a+b+c-1, a+b+c-2] in join . iterate f $ [3,2,1]
10:55:16 <lambdabot>   [3,2,1,6,5,4,15,14,13,42,41,40,123,122,121,366,365,364,1095,1094,1093,3282,...
10:55:19 <ben_m> But then I failed to do it :P
10:55:21 <hpc> dmwit: ;)
10:55:23 <roconnor> > iterate ((-3).(*3)) 3
10:55:25 <lambdabot>   [3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,-3,...
10:55:26 <monochrom> for example it is a mystery why it starts at 3 (why not 47?), and why 2 comes after 3.
10:55:29 <kmc> ben_m, implement Lisp in Haskell, duh
10:55:44 <shachaf> roconnor: subtract
10:55:44 <roconnor> > iterate ((subtract 3).(*3)) 3
10:55:46 <lambdabot>   [3,6,15,42,123,366,1095,3282,9843,29526,88575,265722,797163,2391486,7174455...
10:55:59 <roconnor> > iterate ((subtract 3).(*3)) 3 >>= (\x -> [x,x-1,x-2
10:56:00 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:56:01 <roconnor> > iterate ((subtract 3).(*3)) 3 >>= (\x -> [x,x-1,x-2])
10:56:03 <lambdabot>   [3,2,1,6,5,4,15,14,13,42,41,40,123,122,121,366,365,364,1095,1094,1093,3282,...
10:56:11 <dmwit> roconnor++
10:56:28 <ben_m> Very cool.
10:56:29 <roconnor> @pl iterate ((subtract 3).(*3)) 3 >>= (\x -> [x,x-1,x-2])
10:56:29 <lambdabot> ap (:) (ap ((:) . subtract 1) (return . subtract 2)) =<< iterate (subtract 3 . (3 *)) 3
10:56:46 <ben_m> I not only got the solution, but can also try to understand the snippets and try to understand them :)
10:57:38 <dmwit> :t showIntAtBase
10:57:39 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
10:58:23 <c_wraith> I wrote some code a while ago to implement show for Integer via divide & conquer, to try to get it better than O(n^2).
10:58:30 <dmwit> > map (flip (showIntAtBase 3 ("012"!!)) "") (iterate ((subtract 3).(*3)) 3)
10:58:36 <lambdabot>   ["10","20","120","1120","11120","111120","1111120","11111120","111111120","...
10:59:24 <dmwit> 11111 + 2
10:59:28 <conal> c_wraith: O(n^2) show for Integer?
10:59:43 <c_wraith> conal: where n is the bit length
10:59:55 <kmc> why so long?
11:00:10 <c_wraith> It just uses divMod.  well, quotRem.
11:00:12 <Jafet> > (\x -> [x,x-1,x-2]) =<< scanl (+) 1 (map (3^) [0..])
11:00:13 <dmwit> > map (2+) . scanl (+) 0 . iterate (*3) $ 1
11:00:13 <lambdabot>   [1,0,-1,2,1,0,5,4,3,14,13,12,41,40,39,122,121,120,365,364,363,1094,1093,109...
11:00:14 <lambdabot>   [2,3,6,15,42,123,366,1095,3282,9843,29526,88575,265722,797163,2391486,71744...
11:00:39 <conal> c_wraith: wow. i had no idea.
11:00:43 <Jafet> > (\x -> [x,x-1,x-2]) =<< scanl (+) 3 (map (3^) [1..])
11:00:44 <lambdabot>   [3,2,1,6,5,4,15,14,13,42,41,40,123,122,121,366,365,364,1095,1094,1093,3282,...
11:01:05 <dmwit> Jafet++
11:01:23 <Jafet> > take 3 . iterate pred =<< scanl (+) 3 (map (3^) [1..])
11:01:24 <lambdabot>   [3,2,1,6,5,4,15,14,13,42,41,40,123,122,121,366,365,364,1095,1094,1093,3282,...
11:01:27 <monochrom> to show an n-digit number, first you divide by base for n time, then you divide again for n-1 time... altogether about n^2/2 time
11:02:00 <conal> monochrom: ah. thanks.
11:02:23 <ben_m> I'm copy/pasting all those solutions so I can try to understand them later :D
11:02:35 <Jafet> I'm pretty sure integer-gmp uses divide and conquer
11:02:45 <conal> c_wraith: fascinating. did you get anywhere with divide & conquer?
11:02:55 <c_wraith> conal: I got it to work.  Not really to be efficient.
11:03:03 <Jafet> At least for the size of numbers where it is profitable.
11:03:20 <Eduard_Munteanu> I don't really get it, shouldn't you get one digit for every division/remainder?
11:03:21 <c_wraith> Jafet: does show use integer-gmp's code?  The representation of J# is strange
11:03:38 <monochrom> yes, you get one digit every division.
11:03:39 <Eduard_Munteanu> Or is this something else than base-conversion?
11:03:40 <c_wraith> Eduard_Munteanu: yes.  And on average, each division/remainder is an O(n) step
11:03:44 <conal> c_wraith: trouble with constant factors? or asymptotics?
11:03:46 <Eduard_Munteanu> Oh.
11:03:50 <monochrom> it is just base conversion
11:03:54 <c_wraith> conal: no testing for performance, actually
11:03:59 <Jafet> c_wraith: I can't think of any reason why it wouldn't. But I've never seen the implementation
11:04:04 <c_wraith> @src Integer
11:04:05 * hackagebot hakyll 3.0.1.0 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.1.0 (JasperVanDerJeugt)
11:04:06 <shachaf> > take 3 . iterate pred =<< scanl (+) 3 (iterate (*3) 3)
11:04:07 <lambdabot> data Integer = S# Int#
11:04:09 <lambdabot>              | J# Int# ByteArray#
11:04:11 <lambdabot>   [3,2,1,6,5,4,15,14,13,42,41,40,123,122,121,366,365,364,1095,1094,1093,3282,...
11:04:20 <conal> c_wraith: nonetheless, sounds interesting.
11:04:26 <c_wraith> That J# representation is odd.  I don't understand what that Int# is doing there.
11:04:39 <dolio> Length.
11:04:49 <Jafet> > length . show $ foldl1' (*) [1..100000]
11:04:53 <lambdabot>   mueval-core: Time limit exceeded
11:04:55 <dolio> if I had to guess.
11:05:05 * conal wishes everyone would blog these experiments even if not measurably impressive results.
11:05:15 <Jafet> c_wraith: that looks like ghc is directly using the mpn interface in gmp, not the higher-level mpz interface
11:05:29 <c_wraith> Oh, right, there's no primitive to get the length of a ByteArray# in older versions (all released versions) of GHC
11:05:58 <Jafet> Er, but you were asking about the Int#
11:06:01 <mzero> reading back log -- funny hack I discovered the other day:    if you want to say (-x) to mean the operator section of subtracting x,  but find (subtract x) looking ugly with your other operator sections.... try    (-x+)  !!!
11:06:03 <shachaf> > take 3 . iterate pred =<< (scanl (+) <*> iterate (*3)) 3
11:06:05 <lambdabot>   [3,2,1,6,5,4,15,14,13,42,41,40,123,122,121,366,365,364,1095,1094,1093,3282,...
11:06:15 <c_wraith> Jafet: that would make dolio's guess of "length" sound reasonable, though.
11:06:19 <Jafet> mzero: that looks even uglier
11:06:27 <mzero> > iterate ((-3+).(*3)) 3 >>= (\x -> [x,x-1,x-2])
11:06:28 <lambdabot>   [3,2,1,6,5,4,15,14,13,42,41,40,123,122,121,366,365,364,1095,1094,1093,3282,...
11:06:41 <mzero> Jafet: not if you're code-golfing!  :-)
11:06:45 <monochrom> (-x+) is awesome
11:06:49 <shachaf> Jafet: Really? It looks nice.
11:07:02 <Jafet> Well ok, beholders and stuff.
11:07:16 <shachaf> > (+-3) 5
11:07:17 <lambdabot>   Not in scope: `+-'
11:07:26 <c_wraith> Conal: may turn out that gmp is smart enough to avoid the O(n^2) algorithm in big cases anyway, in which case my implementation's only potential advantage would be greater laziness
11:07:39 <shachaf> Bah, it's prefix.
11:08:16 <monochrom> > (+ -3) 5
11:08:17 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
11:08:17 <lambdabot>      must have lower prece...
11:08:27 <aristid> > (+ (-3)) 5
11:08:28 <lambdabot>   2
11:08:34 <conal> c_wraith: sounds good. i'm all for correct & lazy numerics. 
11:08:47 <monochrom> (-x+)++
11:08:50 <aristid> monochrom: haskell's handling of negative numbers is soo broken :(
11:08:58 <monochrom> @karma (-x+)
11:08:58 <lambdabot> (-x+) has a karma of 1
11:08:58 <aristid> i think haskell should have used _ instead
11:09:00 <aristid> _5
11:09:02 <monochrom> \∩/
11:09:05 <conal> such a shame for such a high-level programming language to be still mired in low-level numerics. :(
11:09:09 <Jafet> http://gmplib.org/manual/Binary-to-Radix.html
11:09:27 <conal> (machine-oriented, non-lazy number types)
11:09:37 <mzero> actually - if I could wave my magic wand --- I just remove unary minus from Haskell... it is a wart
11:09:45 <monochrom> haskell 2086 will do away with plain text syntax anyway
11:10:00 <kmc> mzero, and if/then/else
11:10:01 <roconnor> conal: isn't this simply a reflection of modularity getting in the way of optimization?
11:10:15 <mzero> monochrom: every language since the dawn of programming has said they were going to do that eventually.....
11:10:27 <mzero> kmc - yes - that was my comment on reddit
11:10:30 <monochrom> syntax tree is so much more beautiful and unambiguous and tree-hugging
11:10:41 <conal> roconnor: and perhaps giving up too easily on obtaining both goals.
11:11:06 <monochrom> actually I think most mainstream languages have sworn to swear by plain text.
11:11:21 <kmc> agda has some kind of compiler optimization for inductive naturals, right?
11:11:23 <roconnor> monochrom: Since using Texmacs I can imagine an AST editing system being reasonable
11:11:37 <conal> roconnor: especially considering how well we've done with combining modularity & efficiency in other ways. 
11:11:37 <kmc> like you define numbers in the nice inductive way, and it replaces them with machine integers at eval time
11:11:38 <roconnor> conal: Isn't this one of the great unsolved questions in computer science?
11:11:54 <roconnor> conal: we've done well in other ways?
11:11:59 <conal> roconnor: maybe ongoingly solved, rather than unsolved.
11:12:00 <shachaf> mzero: Could you remove unary minus from mathematical notation while you're at it?
11:12:07 <edwardk> roconnor: having spent a year or two hacking on rich text programming, I ran screaming
11:12:16 <dolio> kmc: It performs calculations using Haskell's Integer.
11:12:18 <DevHC> mzero: GHC will keep it as an extension anyway.
11:12:25 <kmc> ah, cool
11:12:34 <dolio> + and *, at least.
11:12:42 <roconnor> edwardk: every AST editor I've seen has been terrible, except for TeXmacs, which is actually more pleasant than LaTeX.
11:12:53 <comex> let's require writing numbers as (S . S . S . S . S) 0
11:12:59 <kmc> special-case compiler hacks are ugly, but preferable to forcing an unnatural API on users
11:13:00 <edwardk> roconnor: too many intuitions break, structured cut and paste is not nearly usable enough.
11:13:03 <conal> roconnor: yes. we haskellers stuck with pervasive lazy evaluation long enough and with enough smarts & determination to get to performance competitive with non-lazy (and hence non-modular) languages.
11:13:06 <roconnor> edwardk: granted TeXmacs AST isn't all that semnatically rich.
11:13:06 <mzero> shachaf - In the early part of the 20th century there was such a wonderful explosion of mathematical notation and invention --- now we treat it as an ossified holy relic THAT MUST NOT BE ALTERED
11:13:11 <edwardk> texmacs is almost tolerable, very mathematica'ish
11:13:22 <shachaf> "more pleasant than LaTeX" doesn't seem very difficult.
11:13:26 <roconnor> edwardk: Structured cut and paste works imperfectly but really quite well in TeXmacs.
11:13:39 <conal> roconnor: another great example: garbage collection. i don't know how many nay-sayers i heard while i was at microsoft.
11:13:51 <edwardk> roconnor: yeah but there is so little structure to it.
11:13:54 <roconnor> conal: people say we have performace on par with non-lazy languages, but I don't really believe the hype.
11:14:01 <edwardk> all you get are some subscripts here and there
11:14:04 <mzero> comex: and we can write negative numbers like this:    (S . S . S) x = 0
11:14:13 <roconnor> conal: point about GC well taken
11:14:52 <edwardk> In my case I went and implemented everything as a mozilla plugin, using xul and mathml to render my rich text elements
11:15:04 <conal> roconnor: i'm not worried about the exact factor of relative performance. significant progress is enough for me. and cheap hardware makes up the difference.
11:15:08 <comex> in some situations (games, maybe phones), GC is still too slow
11:15:12 <comex> *shrug*
11:15:37 <kmc> erm
11:15:42 <roconnor> conal: though I'm tempted to dismiss the GC argument as people giving up on performance because they decided computers are fast and performance isn't an issue for most problems.
11:15:52 <edwardk> that gave me portability (nominally) out of the game. sadly, what did the project in for me was the two-hold blow of a.) discovering haskell and b.) working on a mac during the period where mathml rendering was horribly horribly broken in mozilla.
11:15:54 <kmc> the majority of smartphone software is written in Java and run with garbage collection
11:16:29 <roconnor> conal: I think I agree with that.  moving form abysmal performance in Haskell into not abysmal is a big win :D
11:16:34 <Philippa> roconnor: there are some tasks for which GC is simply the way to go if you don't want a much larger heap footprint
11:16:40 <comex> on Android, I seem to remember that caused some rendering stuttering
11:16:49 <kmc> yep
11:16:57 <comex> though maybe the new GPU rendering support avoided that
11:17:11 <kmc> that isn't a problem with GC on phones, it's a problem with GC for realtime tasks (on any platform)
11:17:14 <hpc> my old G1 lags on the stupidest of simple thigns
11:17:16 <hpc> *things
11:17:20 <conal> roconnor: that movement is what i'd like us to do for high-level numerics!
11:17:27 <roconnor> Philippa: really?  I don't see how GC could be better than a big tangle of mess of managing allocations yourself.
11:17:36 <monochrom> most OOP design patterns require automatic GC.
11:17:42 <roconnor> conal: ah. I guess so
11:17:47 <kmc> hpc, old Android has a stupid dalvik VM
11:17:50 <kmc> no JIT compilation
11:18:00 <hpc> ah
11:18:09 * hpc is running 1.6, so that would explain it i suppose
11:18:10 <Philippa> roconnor: heh. Yeah, I'm just saying that sometimes even the optimal big tangled mess is just going to be a localised GC :-)
11:18:10 <kmc> monochrom, most OOP "design patterns" are boilerplate workarounds for C++ language design flaws, and so don't require automatic GC
11:18:18 <roconnor> Philippa: interesting
11:18:25 <roconnor> I guess I could believe taht
11:18:25 <monochrom> the observer pattern requires automatic GC
11:18:40 <conal> roconnor: to make our old "good for equational reasoning" mantra true even for practical programming with numbers.
11:18:43 <comex> it's not *that* messy if you have reference counting
11:18:45 <Philippa> kmc: many of them are applicable to Java or even Smalltalk too
11:19:01 <kmc> true, many of the new ones are workarounds for Java flaws instead
11:19:02 <Philippa> comex: if refcounting works. In the general case, it doesn't
11:19:30 <kmc> it is funny how Java is used as the strawman of OOP by both Java proponents and OOP detractors (i.e. half of this channel)
11:20:05 <conal> roconnor: and not just equational reasoning, but rigor in general.
11:20:15 <hpc> kmc: perhaps one side argues the crappy libs are good, while the other argues the good jvm is crappy?
11:20:23 <hpc> :P
11:20:26 <monochrom> do you prefer CLOS and Smalltalk then? they are even more entrenched in automatic GC than petty Java.
11:20:35 <Philippa> *nod*. Java's pretty much the defining language for one model of OOP though
11:20:39 * comex happens to be an Apple apologist ;p
11:20:44 <roconnor> conal: usually optimizing code means breaking abstraction barriers.  Is this what is needed for your numeric code?
11:20:49 <kmc> Philippa, i don't see why it shouldn't be C# at this point
11:20:51 <hpc> comex: you are an... applepologist?
11:21:00 <pumpkin> comex: haskapologist?
11:21:09 <kmc> in so many ways Java just stopped developing because they assumed their users are idiots and couldn't handle it
11:21:13 <Philippa> kmc: because C# is if anything the defining instance for a slightly different (and better) model
11:21:26 <kmc> while C# has features which are obviously missing from Java, rather than some paradigmatic shift
11:21:34 <kmc> i think they are essentially the same model
11:21:43 <comex> how about Python?
11:21:46 <Philippa> depends: is higher-order imperative a paradigmatic shift from first-order?
11:22:00 <comex> or Ruby
11:22:01 <Philippa> comex: Python's fundamentally different enough - dynamic typing etc etc
11:22:05 <roconnor> edwardk: have you used TeXmacs recently?  They have a new matching parenthesis structure.
11:22:08 <kmc> or at least a substantial core of C# is a better realization of the same model as Java
11:22:23 <conal> roconnor: as long as the breaking is done by the compiler.
11:22:35 <monochrom> reference counting leaks because OOP has evolved to use cyclicy blatantly. most implementations of the observer pattern for example.
11:22:37 <comex> still, a lot of code is OOP
11:22:40 <roconnor> conal: are you planning on using RULES or some such thing?
11:22:50 <roconnor> conal: I agree, that breaking abstractions can be done by the compiler
11:22:52 <conal> roconnor: as in deforestation, for instance.
11:22:56 <roconnor> yes
11:23:08 <Philippa> kmc: they're closely related, but I see C# as pushing for something that's plain more subtle than Java. Admittedly I also think of parametric polymorphism in java as a huge hack
11:23:26 <edwardk> roconnor: last time was maybe 7 months ago
11:23:30 <kmc> Philippa, a lot of real-world Java code is higher-order, using those ridiculous verbose design patterns
11:23:33 <Philippa> comex: yeah. It's just that there are many models of OOP out there
11:23:45 <kmc> nobody can even agree on what "OOP" means
11:23:48 <roconnor> conal: though I think we will eventually need to manually tell compilers where and how to apply optimizations.  Doing it automatically I don't think will work well enough in general.
11:23:50 <comex> and templates in C++ are a huge non-hack that were never finished
11:24:00 <conal> kmc: nor "functional".
11:24:05 <Philippa> kmc: yeah, I know. It's just that the language's paradigm itself is, well, entirely ignorant. It's greenspun on
11:24:22 <edwardk> roconnor: or just move those optimizations to runtime where you know what the constants are in practice. this is why i like jitting so much
11:24:22 <hpc> conal: "functional" just means "functions are values" i thought
11:24:26 <Philippa> comex: they're a huge hack, they conflate the roles of ML modules and parametric polymorphism
11:24:34 <kmc> hpc, that's such a low bar as to be met by every decent language
11:24:44 <jmcarthur> roconnor: yeah i've had computer assisted program derivation on my mind recently, which i see as somewhat related to what you just said
11:24:48 <conal> hpc: there are many such ideas about what "functional" means.
11:24:49 <kmc> but i agree that "functional language" is a red herring term and that one should speak of "functional-style code"
11:24:57 * comex doesn't know what a ML module is
11:25:01 <jmcarthur> roconnor: give a high level specification and then derive a high performance lower level implementation
11:25:12 <Jafet> A functional language is one that isn't dysfunctional
11:25:15 <kmc> the Linux kernel is written using object-oriented, functional, aspect-oriented, reflective style
11:25:16 <kmc> in C
11:25:21 <conal> "functional-style code" is so vague in my ears.
11:25:39 <comex> but in terms of implementation, they do something barely any other language does
11:25:40 <Philippa> comex: ML's a family of programming languages. It developed a module system that's almost (sometimes, is) a programming language unto itself
11:25:45 <conal> i like Peter Landin's definition.
11:26:08 <Philippa> conal: "functional-style code" is /supposed/ to be vague. Sometimes, admitting that's what you're doing matters :-)
11:26:10 <roconnor> jmcarthur: I haven't looked at it much, but SPECWARE is the first formal system I've come across that seems like it could plausibly handle this
11:26:30 <hpc> kmc: what's aspect-oriented?
11:26:44 <jmcarthur> roconnor: looks neat. thanks for the link
11:26:49 <jmcarthur> well, the keyword
11:27:20 <Philippa> kmc: generally speaking I'd call a language functional if it supports (in the active rather than passive sense) code in a functional style. C doesn't meet that test and nor does java
11:27:27 <monochrom> ♥ Doug Smith
11:27:33 <conal> Peter Landin (grandfather of Haskell) recommended against the term "functional" and suggested the precise & substantive notion of "denotative" as a replacement.
11:27:54 <monochrom> also you will find that all the category theory you learned is useful a second way :)
11:28:07 <conal> which he (PL) said "gives us a test for whether the notation is genuinely functional or merely masquerading."
11:28:13 <jmcarthur> conal: i've decided that "denotative" is sufficiently unknown enough that most people don't have preconceived notions about it ;)
11:28:34 <hpc> @wn denotative
11:28:36 <lambdabot> *** "denotative" wn "WordNet (r) 2.0"
11:28:37 <lambdabot> denotative
11:28:37 <lambdabot>      adj 1: having the power of explicitly denoting or designating or
11:28:37 <lambdabot>             naming [syn: {denotive}] [ant: {connotative}]
11:28:37 <lambdabot>      2: in accordance with fact or the primary meaning of a term
11:28:38 <lambdabot>         [syn: {explicit}]
11:28:59 <conal> jmcarthur: yeah. another considerable merit!
11:29:02 <Philippa> conal: it's definitely useful if that's the distinction you want to make. I do think that there's some value to the flavour of "functional" that's common in languages like ML or Lisp and is still common across all monads in haskell, though
11:29:16 <Philippa> (and I don't have another good term for it: "higher-order" alone doesn't capture it)
11:29:44 <jmcarthur> Philippa: are you talking about features or style?
11:30:13 <conal> See http://conal.net/blog/posts/is-haskell-a-purely-functional-language/#comment-35882 for a snippet from Peter Landin's advice (his seminal "Next 700" paper, which led to ML & Haskell).
11:30:42 <kmc> hpc, you mean in Linux?
11:30:58 <hpc> kmc: in what you said, yeah
11:31:22 <Philippa> jmcarthur: yes
11:31:43 <edwardk> conal: sure, but he's dead now, so if we don't comply, its not like he'll come after us… i hope
11:31:43 <Philippa> (but you can treat features as support-of-style, if that helps)
11:32:11 <hpc> you can just @msg me later, if it helps
11:32:46 <kmc> hpc, there are config variables as well as runtime events which change the treatment of certain cross-cutting concerns (like locking or assertions) across the whole kernel
11:33:02 <hpc> kmc: ah
11:33:04 <kmc> and these are implemented using lots of metaprogramming, such that the average kernel programmer doesn't have to care
11:33:20 <kmc> it's not an exact fit for the AOP idea but seems more than a bit reminiscent
11:33:48 <kmc> if you hotplug out all but one CPU, it will rewrite all the locking code on the fly
11:34:03 <hpc> "average kernel programmer" hehe
11:34:29 <kmc> for good or ill, there are a lot of kernel programmers
11:34:52 <hpc> i would say good; it is at least nice to know someone still knows their shit
11:35:16 <Philippa> I wouldn't assume that kernel programmer => knows their shit
11:35:24 <monochrom> rewriting all the locking code on the fly sounds awesome
11:35:42 <jmcarthur> i haven't worked with a kernel programmer who i'd say didn't know their shit
11:35:46 <conal> Landin & Backus are from an era when functional programming was about deep elegance & rigor, rather than about power tools for imperative programming.
11:35:58 <jmcarthur> except for perhaps myself
11:36:11 <Philippa> conal: that depends, were the lisp crowd using the term much?
11:36:19 <kmc> it's all relative, but the impressive rate at which Linux security holes are discovered and introduced suggests that some of them could know their shit a bit better
11:36:34 <monochrom> heh
11:36:47 <Philippa> I think we may be partially erasing the culture we don't like, just as eg the Smalltalk-descended OO folks do to ours
11:36:48 <hpc> we can't all be BSD ;)
11:37:06 <jmcarthur> hehe
11:38:42 <monochrom> this is why "majority" doesn't exist in practice. there is only "weighted majority", i.e., weighted by your attention.
11:39:18 <monochrom> "the majority of phone apps are written in Java" - not true to the iphone people, the license almost bans it.
11:39:34 <kmc> right
11:39:44 <Studley> Hello
11:40:01 <aristid> monochrom: dumbphones with j2me plus android more than outnumber iPhone, probably
11:40:24 <kmc> i was including symbian too but i think i'm mistaken
11:40:30 <kmc> you can use Java but it's not the default / preferred language
11:40:34 <kmc> hi Studley
11:41:03 <Philippa> but it's portable across more than symbian, so it's not exactly unknown regardless
11:41:35 <Studley> I was wondering if there's somebody here who could explain function type declarations to me.
11:41:42 <kmc> blackberry is java-based no?
11:41:55 <kmc> Studley, almost certainly one of the 722 of us can do just that ;)
11:41:58 <kmc> go ahead and ask your question
11:41:59 <monochrom> function'name :: type
11:42:12 <monochrom> example: f :: Int -> Bool
11:42:16 <Philippa> monochrom: yeah. Which is great until someone's got confused about all the arrows, but hey
11:42:24 <mauke> Studley: function :: ArgumentType -> ResultType
11:42:30 <hpc> f 5 = True; f _ = False; f -1 = FILE_NOT_FOUND -- :D
11:42:39 <shachaf> infixr ->
11:43:02 <kmc> :t error "file not found" :: Bool
11:43:02 <monochrom> confusion cannot be avoided. or at least, cannot be avoided by me making another choice.
11:43:03 <lambdabot> Bool
11:43:07 <Studley> Yeah, I got that part
11:43:46 <Studley> I'm trying to take a number and drop the units place
11:44:19 <monochrom> such as input 42, output 40?
11:44:28 <Studley> no, input 42, output 4
11:44:31 <Studley> completely drop it
11:44:39 <monochrom> > div 42 10
11:44:40 <lambdabot>   4
11:44:41 <mauke> divide by 10
11:44:45 <Studley> Okay
11:46:01 <conal> hpc: if "functional" just means "functions are values", consider what "purely functional" might mean. also, "first-order functional languages"
11:47:05 <monochrom> there is the word "purely functional" because the word "function" has been hijacked to include side effects.
11:48:14 <Cin> monochrom: Right- this is what I like about Scheme, it calls them procedures.
11:48:31 <Peaker_> When I teach Haskell, I also teach there are functions (a -> b) and procedures (IO a)
11:48:36 <kmc> much like the term "immutable value", another tautology
11:48:43 <hpc> i teach it as actions instead of procedures
11:48:58 <Peaker_> Almost everyone says: "Oh, Pascal also had that distinction!"
11:49:00 <hpc> it's more clear that "this is a thing that is performed"
11:49:15 <Peaker> Then I explain that functions in Pascal were also procedures..
11:49:17 <Cin> Yeah, actions is consistent with the literature by Jones et al, but procedure also works for those from older langs.
11:49:46 <c_wraith> Peaker: What do you teach them things like (a -> IO b) are?
11:49:52 <kmc> most languages use "function" for at least three separate roles
11:49:52 <Peaker> c_wraith, functions that return procedures :)
11:49:52 <Cin> Peaker: What was the thing in Pascal? Functions had to return something?
11:49:52 <kmc> Haskell separates the three
11:50:01 <c_wraith> Cin: yes
11:50:01 * monochrom goes back in time to assassinate Wirth
11:50:02 <Peaker> Cin, Pascal called (a -> IO b) function and (a -> IO ()) procedure
11:50:28 <Cin> Ah. I remember something from that black hole some call "college".
11:50:28 <Studley> My main goal is to have a function that inputs an integer number and outputs a list of its digits
11:51:05 <hpc> > let digits = map read . show in digits 123
11:51:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:51:06 <lambdabot>         against inferred ty...
11:51:09 <mzero> Studley - digits "as would be written down", or digits "as multipliers of successive powers of 10"?
11:51:18 <Studley> as would be written down
11:51:23 <hpc> > let digits :: Int -> [Int]; digits = map read . show in digits 123
11:51:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:51:27 <lambdabot>         against inferred ty...
11:51:28 <mzero> to solve Euler problems, for example, you need both kinds available
11:51:39 <monochrom> @quote monochrom Euler
11:51:39 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
11:51:46 <hpc> > map read . show (123 :: Int) :: Int
11:51:47 <lambdabot>   Couldn't match expected type `[GHC.Base.String]'
11:51:47 <lambdabot>         against inferred t...
11:51:56 <hpc> oh, derp
11:51:57 <mzero> > let digits = map digitValue . show in digits 123
11:51:58 <lambdabot>   Not in scope: `digitValue'
11:52:11 <mzero> don't we have digitValue somewhere in the libs?
11:52:15 <Saizan> digitToInt
11:52:15 <hpc> > map (read . return) . show (123 :: Int) :: Int
11:52:16 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:52:16 <lambdabot>         against inferred ty...
11:52:30 <hpc> :t map (read . return)
11:52:30 <lambdabot> forall a. (Read a) => [Char] -> [a]
11:52:39 <Saizan> :: [Int]
11:52:39 <Studley> I was using a function that would give the trailing digit and a recursive function that would repeatedly call the first function
11:52:40 <hpc> :t map (read . return) . show
11:52:40 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> [a]
11:52:40 <monochrom> nice way to complete the circle of our conversation. it started with turning a number into digits...
11:52:46 <mzero> > let digits = map digitToInt . show in digits 123
11:52:47 <lambdabot>   [1,2,3]
11:52:57 <hpc> oh
11:53:01 <hpc> @src digitToInt
11:53:01 <lambdabot> Source not found. Sorry.
11:53:12 <mzero> in Data.Char
11:53:17 <mzero> >>= lunch
11:53:19 <hpc> oh duh
11:53:22 <Studley> oh, okay
11:54:12 * mzero wonders if he should have asked if this was homework...
11:54:12 <Studley> Okay, thank you!
11:54:17 <Studley> It's not.
11:54:17 <septomin> suppose i have a list of candidate solutions to a problem and a scoring function f, and i want to find k tuples (x, f(x)) such that f(x) is maximal - is there a good way to do this without a fold or explicit recursion?
11:54:26 <Studley> I just want to learn Haskell because it looks interesting.
11:54:38 <mzero> okay - the big question to ask yourself, btw, is what should digits 0 produce?  [0] or []
11:54:51 <dmwit> :t maximumBy -- septomin?
11:54:51 <hpc> :t maximum
11:54:51 <Studley> I would say 0.
11:54:51 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
11:54:52 <lambdabot> forall a. (Ord a) => [a] -> a
11:55:00 <Studley> er, [0]
11:55:17 <hpc> maximumBy (compare `on` snd)
11:55:20 <hpc> or something like that
11:55:26 <hpc> then zipWith [0..]
11:55:35 <dmwit> maximumBy (comparing snd) -- ;-)
11:55:44 <hpc> :D
11:55:47 <dmwit> reads like English, almost
11:55:53 <hpc> almost
11:56:22 <Cin> Studley: It starts that way. Then you're shouting at your parents during breakfast for not getting why a Functor abstracts (a -> b) -> [a] -> [b], then you're donning your lambda knight chainmail with "Avoid Success / At All Costs" t-shirt, searching for Haskell jobs on the net, travelling the world doing hackahtons, emulating Haskell in other languages, and then finally you reach Satori.
11:56:27 <Phantom__Hoover> Is there a simple way of doing unordered pairs in Haskell?
11:56:49 <dmwit> Data.Set?
11:57:06 <hpc> a heterogenous pair is very hard
11:57:07 <monochrom> "I'm attempting a better way to get digits" -> "don't you wish haskell were higher level about numbers" -> "like it's higher level about memory by GC" -> "yeah, like Java" -> "that's OO" -> "no, that's not OO" -> "what's OO anyway?" -> "what's functional anyway?" -> "hi, I'm learning haskell, how do you get digits?"
11:57:28 <aristid> monochrom: nice loop.
11:57:49 <monochrom> yeah, totally!
11:58:23 <Philippa> Cin: you know my dad's actually been to two Anglohaskells now?
11:58:27 <septomin> is there something like maximumBy that will get you the top k elements rather than just the greatest?
11:58:35 <mauke> sortBy
11:59:01 <monadic_kid> Phantom__Hoover: does it have to be unordered? can't use an association list (list of pairs)
11:59:11 <septomin> well, ideally i wanted O(kn) rather than O(n log n)
11:59:12 <Studley> My main problems with learning new languages is that I can never think of anything to code.
11:59:15 <septomin> where k << n
11:59:26 <Studley> This time, I'm just going to write programs to do random things that come to mind.
11:59:35 <kmc> septomin, sort is lazy afaik
11:59:36 <Peaker> Studley, write a ray tracer
11:59:37 <monadic_kid> Phantom__Hoover: i mean can't you use an assocation list
11:59:43 <kmc> such that taking the first k elements is cheaper than sorting the whole list
11:59:56 <hpc> kmc: it can't be lazy; you don't know what the first k elements are
12:00:03 <Phantom__Hoover> Peaker, write the non-Euclidean raytracer I have been steadily avoiding for about a year.
12:00:10 <hpc> there can always be a smaller element later in the list
12:00:18 <kmc> hpc, yeah, it's not lazy in that sense
12:00:23 <Peaker> Phantom__Hoover, why avoid it? It's fun! 
12:00:36 <hpc> oh, you mean that it doesn't fully sort the later elements
12:00:37 <Phantom__Hoover> Peaker, it's... not.
12:00:43 <hpc> neat
12:00:44 <kmc> you do need to scan the whole list to find the k smallest elements, unavoidably
12:00:51 <Phantom__Hoover> The algorithms for tracing geodesics seem to be obscure.
12:01:15 <Studley> I would have no idea where to start, but that sounds like it could be fun
12:03:25 <Phantom__Hoover> Studley, I don't have an idea where to start either, which is why I gave up shortly after starting.
12:03:39 <Phantom__Hoover> Even the coördinate system eludes me.
12:04:17 <Studley> I tried to write a 3D renderer in TI-BASIC once.
12:04:22 <Studley> I realized I knew nothing and stopped.
12:04:31 <Peaker> Phantom__Hoover, did you write  normal euclidean one?
12:05:17 <Phantom__Hoover> I did not, because I view actually building my experience up as a sign of weakness.
12:05:30 <Peaker> Phantom__Hoover, What? :)
12:05:50 <monadic_kid> o_0
12:06:15 <Phantom__Hoover> Is ":P" *really* necessary there?
12:06:50 <Studley> I usually try to write something, get bored with it, try something much harder, get totally overwhelmed, and just drop everything
12:07:02 <Studley> It's not working very well for me.
12:07:40 <Phantom__Hoover> I came in here ultimately because I want to implement an esoteric language.
12:07:56 <monochrom> perhaps play with tryhaskell.org and do the exercises
12:08:52 <Phantom__Hoover> Which requires as a central thing that I implement subgraph isomorphism.
12:09:46 <xplat> it wouldn't be so hard to write a non-Euclidean raytracer just for isotropic geometries
12:10:10 <xplat> or even better, just for isotropic geometries with curvature of a particular sign
12:10:30 <xplat> for hyperbolic, you use the half-plane model and your geodesics are arcs
12:10:36 <tawe> Question. I read that, contexts should 'talk' about type variables, for instance, (Eq a, Ord b), but, (Eq [a], Ord b) is incorrect. To solve that, we should create an "instance Eq a => Eq [a] where ...". Is this all correct?
12:10:43 <xplat> (well, half-space model)
12:11:04 <byorgey> tawe: contexts can talk about things like [a] if you enable the FlexibleContexts extension
12:11:22 <tawe> byorgey, I guess I'm talking about 'default' stuff
12:11:31 <tawe> byorgey, or the book i read
12:11:35 <xplat> and for either projective or spherical geometry, your rays are planes
12:12:01 <byorgey> tawe: but yes, if there is an  instance Eq a => Eq [a] ...  then just have an Eq a constraint will also let you compare [a]'s for equality
12:12:23 <xplat> these are both a little harder than euclidean, but way easier than a generic riemannian raytracer
12:12:40 <Studley> mzero: say I wanted to use the method to split a number into digits in a function instead of just at the prompt. How would I do that differently?
12:12:55 <tawe> byorgey, my question is why such restriction it's necessary. For example, I coud define Eq [a] in terms of  length of the list, and nothing to do with elements in the list. But this restriction forces to 'a' be in Eq class.
12:13:24 <tawe> byorgey, maybe i'm confused
12:13:25 <byorgey> tawe: it is not necessary.  
12:13:40 <byorgey> tawe: when the Haskell language standard was defined it was conservative in some ways
12:14:01 <Studley> Oh, he's gone
12:14:03 <byorgey> tawe: since then we have many standard, well-accepted extensions to the language standard such as FlexibleContexts
12:14:03 <tawe> byorgey, oh, it's ok then. :) thanks for the clarification.
12:14:17 <byorgey> sure
12:18:53 <nyingen> HaXml is driving me completely nuts
12:19:35 <nyingen> I'm getting the impression that it's not widely used, though. There seem to be no tutorials other than a HTML-cleaning report, and my post to haskell-cafe went unanswered
12:20:07 <Studley> Okay, now I'm getting the error 'Invalid type signature'
12:20:19 <Eduard_Munteanu> nyingen: maybe you should restate your question here.
12:20:37 <Studley> I've got a function with Int -> [String]
12:20:39 <Eduard_Munteanu> It might also help to use the docs on hackage, too.
12:21:29 <Eduard_Munteanu> Studley: what's the line that's causing it?
12:21:42 <Eduard_Munteanu> foo :: Int -> [String]    is certainly valid
12:22:34 <hpaste> nyingen pasted "HaXml problem"  http://hpaste.org/44452
12:23:08 <nyingen> Eduard_Munteanu: I've been looking at the hackage docs, and also the '99 paper introducing it
12:24:03 <nyingen> it seems to me that there's something about HaXml that I'm just not getting. I try out various combinations of combinators that seem like they should work, but the output is totally inconsistent with my expectations
12:24:29 <nyingen> usually there is no output, or an error message saying "more than one output", or the entire document is passed through unchanged
12:25:50 <Studley> Eduard_Munteanu: The only other line in my function is
12:25:50 <Studley> NumberToWords n = map (digitToWord) (map (digitToInt) (show n))
12:25:50 <Studley> And each of those work on their own
12:26:27 <Eduard_Munteanu> I've had my fair share of (performance) issues with HXT too.
12:26:39 <nyingen> Maybe I should document some of these HaXml attempts and the outputs which seem weird, and post those to cafe
12:26:50 <Eduard_Munteanu> Studley: function names must start with lowercase.
12:26:53 <nyingen> but again, I get the impression that few people actually use HaXml, so maybe there's not much help
12:27:06 <Studley> Eduard_Munteanu: durp
12:27:28 <Studley> Thank you.
12:27:35 <kmc> Studley, also you can drop the parens around digitToWord
12:27:41 <kmc> and combine the two maps
12:27:51 <Studley> How?
12:27:55 <kmc> numberToWords n = map (digitToWord . digitToInt) (show n)
12:28:04 <kmc> map f (map g xs)  ===  map (f . g) xs
12:28:12 <kmc> and then you can simplify further
12:28:14 <Studley> Oh, okay
12:28:16 <tawe> Question. Any idea why this doesn't work? http://pastebin.com/Af1qKhEK  it's horrible to be forced to make all combinations.
12:28:20 <kmc> numberToWords = map (digitToWord . digitToInt) . show
12:28:20 <Studley> I get it
12:28:23 <accel> Note: this is not the earlier question of (why doesn't haskell allow explicit control of strict/lazy, shared vs re-calculate). Question is: is there any fork of ghc that allows this type of control (i.e. resolves ticket 917) -- since Haskell is about experimenting with new ideas in programming languages, I'm curious if there's a fork of ghc that addresses this particular problem
12:28:26 <gwern> > 50 / 127
12:28:27 <lambdabot>   0.3937007874015748
12:28:29 <kmc> (except you might run into dumb polymorphism problems there)
12:29:05 <mauke> tawe: data Foo = C Bool Int
12:30:01 <tawe> mauke, yes, but that change the definition of my data. Maybe logically 'One' and 'Two' represent two different things.
12:30:30 <mauke> you can still factor out the common fields
12:31:28 <tawe> mauke, don't understand :(
12:36:48 <Phantom__Hoover> Anyone know of an implementation of the Ullman algorithm for subgraph isomorphism in Haskell?
12:38:04 <fram> Damned, the 'impossible' happened! I tried deleting all the .hi files I could find but to no avail. What can I do?
12:38:17 <kmc> ghc --fforce-recomp
12:38:25 <kmc> er one dash
12:39:07 <nyingen> there also appears to be some kind of printing bug in HaXml. Erroneous newlines appear in the output, even if it's just passed through
12:39:17 <pozic> fram: but the developers that they fix their compiler.
12:39:22 <pozic> fram: bug*
12:42:04 <fram> actually what are the .hi files in question?
12:42:20 <dmwit> tawe: Logically, One and Two represent two different things. Likewise, logically, C False and C True represent two different things.
12:42:27 <fram> The bug does not depend on my project, even ghci fails to start
12:42:38 <fram> (without loading anything)
12:43:15 <dmwit> As for why Haskell doesn't allow for _ patterns in constructor positions, well, that's just so that we can tell the types of the arguments to the constructors unambiguously in all situations.
12:44:17 <tawe> dmwit, ok, the last explanation was what i was looking for.
12:44:54 <mzero> dmwit/tawe - that seems not quite like why I think it does
12:45:23 <mzero> it requires a constructor because to pattern match means exactly to match a constructor
12:45:40 <mzero> and that is *the* major driver of evaluation
12:45:46 <dmwit> Yeah, well, that's just, like, your opinion, man.
12:46:21 <mzero> :-)
12:46:31 <dmwit> The question then remains: *why* does a pattern match mean exactly to match a constructor?
12:46:46 <dmwit> Although you've said words, I don't think you've really answered the question.
12:47:28 <mzero> ah - well - because that is the ONLY computation haskell actually does!  (well, modulo the builtin primitives)
12:47:57 <mzero> well -- I suppose one could say, haskell consists of constructing forms , and inspecting them
12:48:14 <mzero> constructing lazily, and inspection forcing evaluation
12:48:45 <mzero> mind you I'm sure conal could make a much more eloquent, and accurate, version of this
12:48:52 <mzero> (cue conal...)  
12:49:08 <conal> mzero: hi. (reading)
12:49:12 <mzero> :-)
12:49:35 <mzero> so an function clause like       f (_ 3 []) = .....    
12:51:07 <mzero> meaning match any construtor from any type that has a Num a in 1st position and [b] in 2nd, with those values.... is not the kind of inspection that the abstract model can do --- to add it would complicate up things greatly (not to mention be a very gnarly, open ended type)
12:51:42 <dmwit> I totally agree. And that is pretty much the argument I gave.
12:52:15 <dmwit> I note that a pattern like that would still seem to drive evaluation to me.
12:52:40 <mzero> consider   data Ziggy = Xeno | Yarrow Int String       and    data Rec = Rec Int [Int]     
12:52:50 <mzero> what could the type of f be?
13:07:26 <hpaste> WolfgangJeltsch pasted "TypeEq"  http://hpaste.org/44454
13:08:26 <Saizan> someone decided TypeCast was too nasty to keep around?:)
13:17:07 <nyingen> @keal
13:17:07 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
13:17:20 * nyingen squints
13:18:25 <aavogt> also, why is there an issue to have two values for type-level things like True and False? (in that paste)
13:22:19 <revenantphx> I'm trying to work out how to take a series of tokens like [3, +, (, 1, +, 2, *, 4] and build a tree without looking online/in a book >_<.
13:22:23 <revenantphx> But I'm totally failing at this.
13:23:49 <Alkhi> heh.. I am trying to compile my file in ghc but I am failing at even this ._. pretty much complete newbie with haskell
13:24:11 <revenantphx> Alkhi: What are you using to build?
13:24:22 <revenantphx> you should use 'ghc --make' unless you've got a cabal project set up.
13:24:31 <revenantphx> (--make will automatically link in necessary dependencies)
13:24:52 <Alkhi> I dont know what cabal project is, but yeh I am using ghc --make p
13:25:47 <Alkhi> hmm
13:26:19 <dmwit> Alkhi: Well, it would help if you pasted your file online somewhere (for example hpaste), along with the exact command you ran and the exact error it gave.
13:26:22 <dmwit> ?hpaste
13:26:23 <lambdabot> Haskell pastebin: http://hpaste.org/
13:27:12 <Alkhi> ah thanks, figured actually before that link what I did wrong, thx again
13:27:28 <Neophyte> Is anyone familiar with pushdown automatas ?
13:28:29 <roconnor> Neophyte: I reviewed them a month ago.
13:28:52 <Neophyte> roconnor, cool. would you be able to help me construct one for a specific language
13:28:56 <dmwit> For almost all questions, it is faster to ask the question than to ask whether there are experts before asking your question.
13:29:01 <kmc> Alkhi, cabal is a build system / dependency manager / half-of-a-package-manager for Haskell
13:29:19 <monochrom> revenantphx: reading some material on the subject isn't such a bad idea for this subject. it is not that easy to invent it. it took a Knuth to invent it. or Earley.
13:29:32 <revenantphx> monochrom: Any recommendations for books?
13:29:34 <Neophyte> sure, i'll ask: i need help constructing a PDA for L={0^n 1^3n | n>=1}
13:29:39 <revenantphx> I'm just reading wiki page on parse trees right now.
13:29:52 <dcoutts_> kmc: mm, slightly annoying that we don't have a clear description isn't it.
13:29:53 <monochrom> if you find something online, that's the most convenient.
13:30:08 <roconnor> Neophyte: yacc is the standard program for doing this task automatically
13:30:15 <Neophyte> what is yacc
13:30:18 <dmwit> Neophyte: That sounds really, really home-worky.
13:30:30 <dmwit> What have you tried so far?
13:30:34 <roconnor> Neophyte: though you typically first express the language as a context free grammer
13:30:38 <Neophyte> dmwit is there a policy against such a thing? I have 4 nodes.
13:30:55 <Neophyte> roconnor we havent really done anything with CFG yet
13:31:13 <roconnor> ah
13:31:13 <Neophyte> but the stack isn't working with my 4 nodes
13:31:27 <Neophyte> we are covering CFG after PDA
13:31:33 <monochrom> if you want books, I personally prefer Appel's "Modern Compiler Implementation in ____".
13:33:37 <Neophyte> dmwit this doesn't work but for node 0 on input 0 i have 0,z;00z (input 0, z in my stack, place 00 in my stack) to node 1. 0,0;000 for node 1 to node 1. and trying to go anew from there
13:34:53 <dmwit> Neophyte: That looks promising.
13:35:00 <monochrom> revenantphx: oh actually, you already have a stack-shunting thing working? except it evaluates directly? then changing it to give a tree is easy.
13:35:03 <dmwit> Neophyte: Are you accepting by empty stack or what?
13:35:16 <Neophyte> no because n>=1
13:35:25 <Neophyte> for 0^n 1^3n
13:35:31 <revenantphx> monochrom: I have the stack-shunting thing in JAVA.
13:35:36 <monochrom> oh haha ok
13:35:37 <revenantphx> and I rewrote it so it doesn't evaluate directly.
13:35:49 <revenantphx> It produces an RPN stack, then evaluates it.
13:35:56 <revenantphx> I'd like to do tree in haskell.
13:36:07 <thoughtpolice> i wrote a little compiler from arithmetic expressions -> x86 asm
13:36:15 <revenantphx> Making it simple by having each non-whitespace character be a single token
13:36:19 <thoughtpolice> it uses dijkstra's shunting yard to compile to RPN, and then just uses the stack
13:36:22 <monochrom> to do tree you can still use stack-shunting.
13:36:23 <dmwit> Neophyte: PDAs typically accept either by empty-stack or by accepting-state; which one is yours?
13:36:24 <thoughtpolice> pretty fun, it was only like 100 lines
13:36:38 * thoughtpolice thinks it might be on hackage actually for no reason at all
13:36:40 <revenantphx> thoughtpolice: Could I see it? I failed to implement shunting yard in haskell XD.
13:36:42 <Neophyte> from node 1 to node 2 I have 1,0; (so it removes a 0 from my stack). but I am stuck from node 2 to node 3 because i reduce too many 0's with what i have written down dmwit by accepting state
13:36:59 <thoughtpolice> revenantphx: http://hackage.haskell.org/package/calc
13:37:01 <revenantphx> so monochrom what's the story with parse trees vs abstract trees?
13:37:08 <Neophyte> because from node 2 to node 2 i have 1,0;
13:37:12 <thoughtpolice> wow
13:37:18 <Neophyte> then z,z to node 3
13:37:24 <thoughtpolice> i uploaded that to hackage nearly over 3 years ago now!
13:37:25 <thoughtpolice> crazy
13:37:27 <monochrom> however, if you really like, look for "recursive descent parser" for the not-stack-shunting story. (it replaces stack by recursion. same difference in my eyes.)
13:37:35 <Martijn_> In ~/.cabal/config I can set documentation to True; can I configure it to build documentation with source links too?
13:38:03 <Neophyte> i can draw it then upload
13:38:08 <monochrom> I don't distinguish parse tree from abstract whatever tree.
13:38:08 <revenantphx> monochrom: is it possible to produce a parse tree from a string in a constant fold?
13:38:09 <thoughtpolice> revenantphx: because of the time scale note my haskell abilities back then were probably considerably less than now :p
13:38:09 <dmwit> Neophyte: z,z sounds ill-typed; is z really an input symbol? I thought it was only a stack symbol.
13:38:21 <revenantphx> thoughtpolice: don't worry, I'm probably not even close yet.
13:38:29 <revenantphx> though I haven't looked at the code haha.
13:38:30 <monochrom> what is constant fold?
13:38:36 <Neophyte> dmwit by z i mean nothing in the stack
13:38:52 <revenantphx> monochrom: I mean, just in one straight foldl
13:38:53 <thoughtpolice> revenantphx: but i think you'll find it's amazingly simple actually
13:38:55 <revenantphx> without anything else.
13:38:58 <dmwit> Neophyte: Oh, do your PDAs have a way to detect empty stacks? You should double-check that.
13:39:13 <dmwit> sorry
13:39:16 <thoughtpolice> revenantphx: looking at it again, my whole lexer, parser and stack shunting algo was about 60 lines
13:39:17 <dmwit> I said that wrong.
13:39:25 <revenantphx> thoughtpolice: yeah, looks pretty simple
13:39:34 <Neophyte> then maybe i should put the $ symbol in my stack
13:39:35 <monochrom> it is possible but I wouldn't do it.
13:39:39 <Neophyte> to detect when it is empty
13:39:53 <dmwit> Empty-stack detection is common, and done exactly as you say -- with a terminal symbol (which happens to be z in your case).
13:39:58 <dmwit> I'm not taking issue with that.
13:40:03 <revenantphx> monochrom: aw :P.
13:40:03 <Neophyte> ok
13:40:06 <revenantphx> that's no fun hehe
13:40:37 <dmwit> What I'm asking is specifically about the first 'z' in "z,z;", which looks to me like it is trying to match a *stack* symbol against the *input string*.
13:40:56 <Neophyte> i meann e,z which is to say the empty string and the empty stack
13:41:01 <ciz> may i ask a question about an exer on real world haskel?
13:41:22 <dmwit> Neophyte: Okay, *now* you should double-check what PDAs can do. Because checking for an empty string is indeed a very rare feature of PDAs.
13:41:37 <ketil> Hm.. isn't there Monad/Applicative instances for Either e?
13:41:41 <monochrom> every pure function "can" be written as a fold (for the input data structure) followed by an unfold (for the output data structure). but you shouldn't do it.
13:42:02 <dmwit> Neophyte: However, as a hint, non-determinism is very common. So you should see if you can exploit that instead. ;-)
13:42:08 <Neophyte> k
13:42:20 <nkpart> Hey all, is there a way I can make this type check: https://gist.github.com/851878 . I'm not exactly sure I've got these terms right, but I think I'm trying to keep id' polymorphic, even though it's been bound in the do-notation bit
13:42:24 <Neophyte> i'll keep working on it thanks
13:42:35 <revenantphx> monochrom: here's an example of what I'd like to do
13:42:35 <revenantphx> https://gist.github.com/851881
13:42:38 <Martijn_> @ketil I believe category-extras has instances for those (that don't use the Error class constraint)
13:42:39 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
13:42:40 <revenantphx> er
13:42:40 <revenantphx> wait
13:42:53 <revenantphx> here refresh that
13:42:57 <revenantphx> with something like that.
13:42:58 <dmwit> Neophyte: (I should add that "checking for an empty input" is uncommon, but "consuming none of the input characters and doing a state transition" is not uncommon.)
13:43:02 <revenantphx> Though, ignore UnaryOp for now.
13:43:12 <revenantphx> I'm just sure how you'd "start" from 3.
13:43:16 <revenantphx> It reminds me kind of a zipper.
13:43:38 <dmwit> Neophyte: (Let me know if the distinction there was too subtle and I can explain a bit more.)
13:43:46 <Neophyte> please
13:43:56 <dmwit> Sure.
13:44:29 <dmwit> Actually, the distinction is pretty short: a transition that consumes none of the input characters is valid even on non-empty input strings. It just keeps the string as-is.
13:45:01 <ketil> Martijn_, I found some in Control.Monad.Error - but not an Applicative instance.
13:45:06 <Neophyte> alright
13:45:21 <Neophyte> i'll draw up what i have, and make the neededc corrections, brb
13:46:31 <monochrom> most haskell books have a chapter on parsing too. they are all recursive descent.
13:48:04 <revenantphx> monochrom: the problem with doing recursive descent is it flounders on "1+2"
13:48:09 <revenantphx> you say "parse an expression"
13:48:11 <monochrom> monadic parser was the last step in my monad-learning process
13:48:15 <revenantphx> it says "OKAY I SEE A PLUS SIGN"
13:48:19 <revenantphx> OKAY TIME TO PARSE TWO MORE
13:48:23 <revenantphx> OH LOOK A PLUS SIGN
13:48:26 <revenantphx> TIME TO PARSE TWO MORe...
13:49:11 <monochrom> it doesn't flounder if you do it right
13:49:24 <revenantphx> that's the whole LL/LR deal I still don't fully understand >_<
13:49:37 <monochrom> for example if you have the base case of "I see a number"
13:49:48 <monochrom> no, no LL/LR deal necessary
13:50:01 <revenantphx> continue then. 
13:52:23 <revenantphx> what do you mean having that base case?
13:53:17 <revenantphx> If you had the string "1+2", then you'd have to put the '1' in some sort of holding (stack?), then when you see the +, you build the left hand side of the resulting tree off the stack, and right hand side by consuming more input?
13:53:52 <Fuco> I have function f :: Int -> Int defined as f x = x*x... it works for positive numbers, but not for negative, why? Error say "No instance for (Num (Int -> Int))"
13:53:58 <Fuco> but isn't Int already isntance of Num?
13:54:12 <revenantphx> make sure negatives are in parenthese
13:54:13 <revenantphx> i.e
13:54:15 <revenantphx> (-9)
13:54:16 <Fuco> I see
13:54:28 <kmc> Int is an instance of Num, (Int -> Int) isn't
13:54:45 <revenantphx> the (Int -> Int) you're seeing is probably the function -
13:54:48 <revenantphx> :t -
13:54:48 <lambdabot> parse error (possibly incorrect indentation)
13:54:52 <revenantphx> :t (-)
13:54:53 <lambdabot> forall a. (Num a) => a -> a -> a
13:54:56 <revenantphx> :t - 9
13:54:57 <lambdabot> forall a. (Num a) => a
13:55:01 <Fuco> makes sense, thanks ;)
13:55:11 <mauke> > x -9
13:55:11 <lambdabot>   x - 9
13:55:26 <revenantphx> :t (-) 9
13:55:27 <revenantphx> ahem
13:55:27 <lambdabot> forall t. (Num t) => t -> t
13:55:29 <revenantphx> there we go
13:57:44 <Neophyte> dmwit, i am sort of stuck but would you look at my PDA? I think it is close, i'll upload it 
14:01:42 <monochrom> well, I guess some kind of LL business is necessary, but not much. it just means that the grammar rule "exp ::= num | exp + exp" is unsuitable for recursive descent, change it to "exp := num more; more ::= + num more | eof"
14:06:39 <revenantphx> monochrom: thinking about that :\
14:07:12 <revenantphx> So that's what's meant by having to mechanically modify the grammar?
14:07:44 <monochrom> mechanically = algorithmically = use a computer = use monochrom
14:07:48 <revenantphx> also why + num more?
14:07:59 <revenantphx> wouldn't it be more like
14:08:35 <revenantphx> exp ::= num more
14:08:35 <revenantphx> more ::= op num
14:08:35 <revenantphx> op ::= + | - | * | / ...
14:08:49 <revenantphx> except, that wouldn't really work :\... hm
14:08:54 <monochrom> more ::= op num more
14:08:58 <revenantphx> why that though?
14:09:20 <revenantphx> (also, that grammar doesn't cover "(2-1) + (1 + 3)
14:09:21 <revenantphx> "
14:09:23 <revenantphx> )
14:09:44 <monochrom> precedence and parentheses are another step up
14:09:58 <revenantphx> er, well, the point wasn't the parentheses
14:10:05 <revenantphx> say it's
14:10:07 <revenantphx> 2*1 + 5
14:10:21 <revenantphx> 2*1 should be recognized as it's own expression.
14:10:29 <revenantphx> that other definition only looks for nums :\
14:10:36 <monochrom> precedence is another step up
14:11:01 <monochrom> for now if you go by my rules, and yes it can only do +, here are some examples.
14:11:18 <kramble> hi, I'm trying to compile on my fresh new ubuntu a program developped under mac, and the ghc of my buntu doesn't understand that module Toto is in file toto.hs, it is looking for Toto.hs but not toto.hs
14:11:25 <monochrom> "1"  the derivation steps go  exp -> num more -> num eof -> 1 eof
14:11:27 <kramble> Is there a switch to help it ?
14:11:34 <revenantphx> kramble: rename it to Toto.hs
14:11:46 <mzero> ubuntu's file system is case sensitive
14:11:49 <mzero> Mac's is not
14:11:49 <kramble> revenantphx: I really don't like uppercase in code filename
14:12:01 <revenantphx> kramble: Sorry, but get used to it.
14:12:01 <mzero> kramble - no choice
14:12:06 <monochrom> "1+2+3"  exp -> num more -> num + num more -> num + num + num more -> num + num + num eof -> 1+2+3 eof
14:12:11 <kramble> ghc doens't have a switch for that ?
14:12:16 <mzero> module name must match file name
14:12:16 <revenantphx> monochrom: hm.
14:13:08 <kramble> it makes me cry, but I have to
14:13:26 <Evious> You can switch to Windows.
14:13:34 <Evious> Case-insensitive file names, give 'em whatever capitalization you want :)
14:13:47 <Evious> Then flip out when all your code 'suddenly' breaks on Linux :(
14:14:00 <revenantphx> kramble: What's wrong with capitalization in file names XD.
14:14:08 <revenantphx> That's a purely aesthetic issue.
14:14:25 <kramble> revenantphx: capitalization is always slower to type because there is one more key to press
14:14:33 <revenantphx> kramble: Oh stop whining.
14:14:35 <monochrom> but people like to spend whole lives arguing aesthetic issues such as C syntax
14:14:51 <revenantphx> monochrom: I just use OTB and ignore people who bitch about it.
14:15:22 <lispy_> OTB?
14:15:27 <revenantphx> One true brace.
14:15:31 <revenantphx> Opening braces are always on the same line,
14:15:33 <applicative> off track betting
14:15:35 <revenantphx> ending braces on their own.
14:15:37 <revenantphx> period.
14:15:39 <revenantphx> no special cases.
14:15:53 <mzero> kramble - I wonder if that is measurably true --- sounds like one of those things that seems intuitive, but our understanding of the psycho-mechanics of typing is often misleading
14:16:00 <revenantphx> (hugging else statements is personal choice imo)
14:16:32 <Maxdamantus> } while(foo);
14:16:33 <kramble> mzero: the fact of speed is a fake argument i often use
14:16:45 <monochrom> I layout code randomly and ignore people
14:16:52 <kramble> the irregularity in filename, which slow reading, is the real meaning of that
14:17:00 <revenantphx> monochrom: nice.
14:17:09 <revenantphx> kramble: Seriously, stop whining.
14:17:10 <revenantphx> >_>
14:17:25 <kramble> revenantphx: seriously i'm not talking to you
14:17:34 <mzero> (I'm pretty sure that mixed case generally improves reading speed.. but again... empirical studies would be best here)
14:18:11 <kramble> mzero: it's false, in every day life there is uppercase only at begining of phrase, we all are used to read lowercase
14:18:28 <mzero> Now, if your argument were that you were naming all your files so that ls -r read as e.e.cummings poetry.....
14:18:35 <mzero> .... THEN I'd be all for it
14:18:53 <kramble> ghc could have implemented it
14:18:54 <revenantphx> kramble: Yes, but I would submit that capital letters serve as context to help you find the beginning of sentences and such.
14:19:02 <mzero> kramble - I don't buy any arguments here w/o actual timing data ... either way!
14:19:03 <revenantphx> kramble: There's a reason we use them.
14:19:04 <monochrom> don't speak for the Germans
14:19:07 <revenantphx> mzero: ^
14:19:27 <kramble> revenantphx: begining of sentence, not word
14:19:32 <revenantphx> kramble: Yep.
14:19:50 <mzero> wemightaswellgetridofspacestheyjusttakeupextratimetotypeandextraeyemuscleenertytoscanacross
14:20:07 <mzero> (man, that was hard to type!)
14:20:09 <roconnor> mzero: camlCase please
14:20:09 <revenantphx> icompletelyagreeitshardtoreadwithspacesandtheymakeittakelongersincewehavetolookatthem
14:20:13 <kramble> mzero: when ur use to it it's fast to read
14:20:37 <mzero> in that case, let's all learn Chinese - it's denser and faster to read
14:20:52 <kramble> mzero: but slow to write
14:20:57 <monochrom> "Denn alles Fleisch, es ist wie Grasund alle Herrlichkeit des Menschen wie des Grases Blumen." - capital letters left right and centre.
14:21:14 <mzero> look - I get enough speed up by writing in Haskell, where my code is 1/3 what it would be in C++....  I can tollerate the spaces and case shifts
14:21:18 <mzero> :-)
14:21:33 <kramble> mzero: uppercase file are ugly in a linux filesystem
14:21:53 <kramble> harmony is beautiful
14:21:54 <revenantphx> kramble: gcc's ugly too.
14:21:57 <revenantphx> What's your point.
14:22:02 <kramble> gcc ugly ?
14:22:29 <mzero> Have it any color you like, so long as it's black. ... Or in the case of Haskell, mixed-case.
14:22:37 <revenantphx> Paint it black.
14:22:42 <kmc> we should switch Haskell to use comment syntax // and /* for typing speed, obviously
14:22:49 <kramble> so there will never be a feature to tolerate lowercase in ghc ?
14:22:58 <jix> kramble: how would you name a file for the module FooBar .. foobar.hs? and how would you name a file for the module Foobar .. also foobar.hs? ... oops!
14:23:00 <revenantphx> kramble: No one except you actually cares that much.
14:23:06 <kramble> i have to compile and patch it, if i want that
14:23:06 <Evious> kramble, there is, it's called MS Windows
14:23:08 <revenantphx> Saying "file name must match module name" is simple enough.
14:23:10 <kramble> (I hope it builds)
14:23:11 <mzero> only if you implement it and submit a patch
14:23:17 <Evious> Just go use Windows. Works for me.
14:23:28 <revenantphx> jix has a good point too.
14:23:36 <Evious> Who cares about being consistent with the libraries you use, go do your own thing...
14:23:46 <kramble> jix: i name a mofule Foobar because ghc want me to do that, but i rather like foobar
14:23:51 <revenantphx> modules named TheRapist and Therapist would both be therapist.hs
14:23:55 <revenantphx> how do you know which is which?
14:23:59 <kmc> the fact that ghc is forced to do a broken thing on a broken OS is not a valid reason for it to do the same broken thing on a non-broken OS
14:24:08 <revenantphx> For file names to be case-insensitive, module names would have to be so as well.
14:24:14 <revenantphx> kmc: ^
14:24:15 <mzero> it isn't GHC that wants you to do that - it is the defintion of Haskell that requires that module names start with an upper case
14:24:17 * monochrom uses oleg'case. The'rapist.hs
14:24:21 <hpc> revenantphx: one is creepy and talks to children; the other should be in prison
14:24:23 <kramble> revenantphx: same word with different capitalization is an awful thing, i hope i will never encounter such a code
14:24:32 <monochrom> hell, oleg'case is not even about case.
14:24:40 <revenantphx> kramble: You probably will. You're not special.
14:24:45 <revenantphx> kramble: Deal with it.
14:25:25 <kramble> i regret the old time where everything were lowercase except constant which were uppercase
14:25:33 <kramble> but the youg generation come and throw that
14:25:50 <revenantphx> I think kramble's trolling...
14:26:01 <roconnor> back in my day vairables were 1 letter long; you had 26 of them and you liked it.
14:26:02 <kramble> so now we have to endure all the caprices of these people
14:26:10 <kramble> old c time was cool
14:26:44 <monochrom> actually I had 52 of them because A-Z were number variables and A$-Z$ were string variables.
14:26:57 <kramble> i'm shocked to see that someone want to force me to use uppercase (they must be fascist)
14:27:21 <revenantphx> In my day you had under a dozen registers, and you liked it.
14:27:55 <hpc> in my day, the internet was grad students carrying magnetic tape
14:27:56 <dark> kramble, o.o
14:27:59 <hpc> uphill, in the snow, both ways
14:28:02 <hpc> and we LIKED it
14:28:04 <Draconx> kramble, wait... you're _advocating_ going back to old C time, where only the first 6 characters of external identifiers were significant, without regard to case?
14:28:13 <kramble> Draconx: yeah
14:28:33 * dark will create the rebel army for a lowercase nation
14:28:40 <kramble> >26**6
14:28:48 <hpc> > 26 ^ 6
14:28:49 <lambdabot>   308915776
14:29:00 <kramble> it's sufficient
14:29:01 <monochrom> that would probably make revenantphx's parsing job easier, if we limited expressions to be at most 6 characters long.
14:29:07 <revenantphx> monochrom: oh shush.
14:29:08 <revenantphx> >_<
14:29:11 <hpc> :D
14:29:12 <kramble> monochrom: :)
14:29:17 <dark> seriously, the reason I resisted learning haskell was that the convention here is to use camelCase for identifiers, not lowercase_with_underline
14:29:31 <revenantphx> dark: Just use the convention for each language, bam.
14:29:32 <dark> (nowadays I'm kind of defeated, .-.)
14:29:34 <revenantphx> Wow that's so hard.
14:29:39 <kramble> caml is the only place where i see the jdlkdj_qjdhkjs_dkfjlkfd
14:29:41 <dark> yes.
14:29:47 * monochrom recruits dark for the noble cause of oleg'case
14:29:59 <dark> I come from OCaml
14:30:00 <Philippa> dark: _ plays badly with haskell's application syntax
14:30:00 <revenantphx> What_About_Microsoft_Case?
14:30:04 <hpc> kramble: try using C++ sometime
14:30:14 <revenantphx> Microsoft_Case_Is_Amusing_Too
14:30:15 <hpc> m_sStupid_Case
14:30:20 <kramble> hpc: only the day were >> to close template will be portable
14:30:31 <dark> application syntax? it seems similar to caml
14:30:45 <revenantphx> the application syntax is  
14:30:49 <Philippa> caml is widely regarded as fugly compared to haskell though :-)
14:31:00 <revenantphx> brb
14:31:15 <kramble> fugly ? what does it mean ?
14:31:21 <dark> and I know - it is completely irrational. It's just a weird feeling I have when I see camel case. (I tend to associate it to java, or c++, or anything similar to this)
14:31:39 <c_wraith> I was reviewing some Erlang code last night.  Who ever thought that syntax was a good idea?  (The language is pretty nice, but..  Why that syntax?  why?)
14:32:17 <monochrom> it does seem camelCase in haskell is a long tradition, like 20 years. way before java. probably java just copied from one of the camelCase communities, but I don't know which one.
14:32:28 <dark> I actually really like the-lisp-convention and I would like to use a language with required whitespace between identifiers (like, uhm, agda?). But this'naming'scheme'looks'promising'too (but, uhm.. er.. weird)
14:32:31 <jix> c_wraith: the first interpreter was written in prolog... and borrowed from it's syntax
14:32:55 <dark> monochrom, but.. haskell doesn't have 20 years.. does it?o.o
14:33:12 <Philippa> it does
14:33:19 <Philippa> and it has immediate predecessors, too
14:33:23 <dark> uhm. o.o
14:33:25 <kmc> the first version was specified in 1990 (?)
14:33:48 <kmc> and the most-recent-before-last-year version was specified in 1998
14:34:07 <kmc> it is an old language with some recent new popularity
14:34:28 <kmc> not many languages have that kind of history
14:34:41 <kmc> it's claimed that Erlang is another
14:34:44 <monochrom> haskell was a committee design. the committee members came from gofer miranda etc. look for those roots for traditions.
14:34:46 <dark> most languages die without being noticed
14:35:01 <revenantphx> Erlangs been around 25 years or so, no?
14:35:04 <kmc> most languages are never popular, or accumulate popularity steadily from the moment of release
14:35:43 <c_wraith> some languages are invented in japan and unheard-of until some web framework comes along that makes writing the exact same site as everyone else has really easy.
14:36:22 <dark> c_wraith, about those I know only ruby
14:36:30 <hpaste> bos pasted "Dir.hs"  http://hpaste.org/44455
14:36:32 <c_wraith> dark: yeah, that's really just ruby :)
14:36:38 <dark> but I think lua had a similar history
14:36:49 <kramble> popularity of language could be a really interesting study
14:36:59 <dark> invented for internal use, but then gained popularity with a game
14:37:22 <dark> (I think it was with grim fandango. it wasn't actually a success)
14:38:15 <revenantphx> dark: Not even close.
14:38:26 <revenantphx> It was in Brazil for some random reason.
14:38:31 <revenantphx> i forget exactl.
14:38:34 <kramble> i think that the day where haskell is portable with graphics, haskell could become really popular
14:38:59 <revenantphx> But haskell isn't a good language for graphics :|
14:39:03 <Evious> Sure it is :D
14:39:16 <Pseudonym> "Graphics" covers a lot of ground.
14:39:18 <Evious> Take a look at protovis to see how awesome functional interfaces to graphics are.
14:39:24 <revenantphx> But you're involving transactions and transfers with the GPU.
14:39:37 <revenantphx> Which are not pure at all.
14:39:43 <Pseudonym> Not everything in graphics involves GPUs.
14:39:45 <dark> revenantphx, it was created to aid data description, and little programming (done by experts in other areas), at PUC, but with a contract with petrobrás (the national oil company)
14:39:46 <revenantphx> And sure you could cheat with IO or something but, at that point... what's the point.
14:40:03 <Evious> The definition of a GUI is pure.
14:40:29 <kramble> if haskell can do io it can do graphics
14:40:35 <Pseudonym> Actually, I was almost hired by NVIDIA based on my having written a shading language compiler in Haskell.
14:40:40 <dark> like, geologists, etc. (I'm Brazilian btw). but lua became *really* popular after some commercial games used it to do high-level programming. the permissive licensing helped a lot on this
14:41:00 <hpc> Pseudonym: almost? :P
14:41:16 <Pseudonym> Melbourne, Australia to Silicon Valley is a big commute.
14:41:22 <c_wraith> dark: lua's other really good feature in that domain is that it's really easy to embed in such a way as to not compromise the security/stability of your application
14:41:31 <hpc> ooh
14:41:37 <hpc> worth it, i would say
14:42:01 <Adamant> Pseudonym: NVIDIA has a good eye for talent in general.
14:42:03 <Pseudonym> Life circumstances prevented it at the time.
14:42:08 <hpc> :(
14:42:13 <dark> c_wraith, yeah
14:42:25 <Adamant> they snapped up the best young professor at my college
14:43:20 <siracusa> Is there an overview of common design patterns in Haskell somewhere?
14:43:37 <Pseudonym> @google "common haskell idioms"
14:43:38 <lambdabot> http://www.haskell.org/haskellwiki/Tutorials
14:43:38 <lambdabot> Title: Tutorials - HaskellWiki
14:43:42 <Pseudonym> Hrm.
14:44:24 <Pseudonym> However, siracusa, many design patterns in Haskell are drawn from category theory.
14:44:39 <Pseudonym> So learning a little of that might help.
14:45:01 <Pseudonym> http://www.haskell.org/haskellwiki/Category:Idioms
14:45:03 <Pseudonym> There we go.
14:45:23 <dark> Pseudonym, some monad tutorial writers says that trying to explain haskell programming patterns using this math is too confuse
14:45:26 <Pseudonym> Some of those aren't idioms, like "Roman numerals".
14:45:49 <Pseudonym> Oh, I don't necessarily mean "learn what a Kleisli triple is".
14:45:52 <siracusa> Pseudonym: Ah great, thanks!
14:45:58 <Pseudonym> But sometimes it helps to know what a universal object is.
14:46:36 <kramble> never see code using terminal objects
14:46:45 <kramble> but it could be really elegant
14:47:33 <revenantphx> fun page: http://www.haskell.org/haskellwiki/Blow_your_mind
14:48:15 <dark> http://www.haskell.org/haskellwiki/Lifting Haskell doesn't allow a type Pair a = (a, a) to be a functor instance - wny?
14:48:59 <c_wraith> dark: a couple reasons.  one, you can't create instances for type synonyms, by default.  Two, the type the synonym expands to has the wrong kind to be a functor.
14:49:08 <rwbarton> type synonyms can't be instances
14:49:24 <Pseudonym> If you want the efficiency of that, use newtype.
14:49:31 <Pseudonym> But you pay for it with syntax.
14:49:45 <kleinucopia> will GHC be just as efficient if a function deconstructs a type in a pattern match and then reconstructs it, say to send the whole type as an argument to another function, as if the function hadn't deconstructed the type?
14:49:58 <kleinucopia> I would think the answer is yes, but I just wanted to be sure.
14:50:00 <Pseudonym> kleinucopia: It depends.
14:50:17 <Pseudonym> It's technically an incorrect transformation sometimes.
14:50:17 <rwbarton> it's necessary though because otherwise what is map (+1) (3,5)?
14:50:18 <Pseudonym> For example:
14:50:25 <Pseudonym> f :: Either A B -> Either A C
14:50:30 <Pseudonym> f (Left a) = Left a
14:50:30 <pastorn> goddamn erlang
14:50:34 <Pseudonym> f _ = undefined
14:50:49 <rwbarton> There is already a functor instance for (,) Int and you'd have no way to select which one to use.
14:50:53 <kleinucopia> Pseudonym: so in a case where it would work, how can ghc know?
14:50:58 <pastorn> i was asking what would happend if i wrote "f(X,X)", maybe that would pattern match/do equality testing
14:51:14 <pastorn> but "f" isn't an arbitrary function, it's the forgetting... noone understands me
14:51:18 * pastorn feels all alone
14:51:38 <Pseudonym> kleinucopia: Have you tried inspecting the generated Core?
14:52:01 * Cin gives pastorn a small cake
14:52:08 <kleinucopia> Pseudonym: I don't have a specific case I was thinking about. Just a question that popped into my head.
14:52:15 <levifikri> Hi, I encoded an array of bytestring using Data.Binary. But the problem is: the encoded data is quite big. I saw a lot of NULL value there. Could somebody explain why so? Or is it my mistake?
14:52:16 * pastorn eats Cins cake
14:52:20 <kleinucopia> the case I was thinking of goes like this:
14:52:37 <pastorn> @faq Can haskell bake cakes?
14:52:37 <lambdabot> The answer is: Yes! Haskell can do that.
14:52:55 <kleinucopia> f :: T a b -> (T a b, U a)
14:53:21 <kleinucopia> f T x y = (f (T x y), U x)
14:53:31 <levifikri> there are 00 00 00 00 00 00 00 between each element of bytestring
14:53:35 <kleinucopia> or something similiar
14:53:48 <kleinucopia> err... scratch that f (T x y), and make it g
14:53:59 <Pseudonym> In this case, you could do this:
14:54:05 <kramble> @faq Can haskell beats Chuck ?
14:54:05 <lambdabot> The answer is: Yes! Haskell can do that.
14:54:17 <Pseudonym> f (t@(T x y)) = (g t, U x)
14:54:24 <Pseudonym> If it matters to you.
14:54:26 <Studley> @faq can haskell ever love me back
14:54:27 <lambdabot> The answer is: Yes! Haskell can do that.
14:54:42 <Studley> yay
14:55:00 <lambdabot> Group hug!
14:55:24 <monochrom> levifikri: somehow you managed to use 64 bits for each byte? I think you made a mistake, or you didn't know a better function to use.
14:55:37 <lispy_> levifikri: do you need to trim the bytestrings first perhaps?
14:55:56 <monochrom> however I don't know enough Binary.Put to say how.
14:55:58 <lispy_> oh, between the elements /me learns to read
14:56:42 <kleinucopia> Pseudonym: right, I forgot about as patterns.
14:56:54 <kleinucopia> but as to the question, ghc won't guess, right?
14:58:33 <Pseudonym> I suggest writing an example, and examining the generated Core.
14:58:43 <Pseudonym> I honestly don't know, and I'd be interested in knowing the answer.
14:58:56 <kleinucopia> I actually have a case of it in something I'm working on now that I looked. I only need to do a pattern match to restrict the type the fn accepts; I discard the bindings. In this case as-matching would probably help.
14:59:24 <levifikri> ok let me make a simple example
15:01:43 <kleinucopia> Pseudonym: here's something that seems related: http://tinyurl.com/4o5b47t
15:04:35 <levifikri> I made something like this 
15:04:36 <levifikri> testEncodeChars :: [String] -> LB.ByteString
15:04:37 <levifikri> testEncodeChars cs = 
15:04:37 <levifikri>   let bs = map LB.pack cs in
15:04:37 <levifikri>     encode bs
15:05:35 <levifikri> testEncodeChars ["Hello", "World"] would result as 
15:05:35 <levifikri> Chunk "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\STX\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ENQ" (Chunk "Hello" (Chunk "\NUL\NUL\NUL\NUL\NUL\NUL
15:05:36 <levifikri> \NUL\ENQ" (Chunk "World" Empty)))
15:05:53 <levifikri> too many NUL in between Hello and World
15:06:33 <levifikri> LB is Data.ByteString.Lazy.Char8
15:07:09 <rwbarton> That's a list of bytestrings, not a bytestring.
15:07:34 <rwbarton> Why do you expect the binary encoding to be anything in particular?
15:07:46 <confound> what's the relationship between hack and wai?
15:07:55 <hpc> :t encode
15:07:56 <lambdabot> Not in scope: `encode'
15:08:00 <hpc> @hoogle encode
15:08:00 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
15:08:00 <lambdabot> Network.CGI formEncode :: [(String, String)] -> String
15:08:00 <lambdabot> Network.CGI.Protocol formEncode :: [(String, String)] -> String
15:08:06 <rwbarton> It's got to encode the length of the list, and the length of the bytestrings.
15:09:14 <rwbarton> Did you mean to concatenate the strings before calling pack?
15:09:30 <levifikri> it doesn't have to be a list of bytestring btw,
15:09:35 <levifikri> encode [1,2,3]
15:09:43 <rwbarton> sure
15:09:48 <levifikri> Chunk "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ETX\NUL\NUL\NUL\NUL\SOH\NUL\NUL\NUL\NUL\STX\NUL\NUL\NUL\NUL\ETX" Empty
15:09:53 <monochrom> rwbarton's point is the "list" part.
15:10:07 <rwbarton> what's wrong with that output?
15:10:14 <levifikri> too many NUL
15:10:21 <levifikri> is it because of the list?
15:10:42 <monochrom> <rwbarton> It's got to encode the length of the list
15:10:45 <rwbarton> well even a single Integer is going to take several bytes...
15:11:08 <rwbarton> it has to encode th length of the Integer as well
15:11:09 <monochrom> length of list is Int and could be 32 bits or 64 bits.
15:11:43 <monochrom> map ord "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ETX"
15:11:47 <monochrom> > map ord "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ETX"
15:11:48 <lambdabot>   [0,0,0,0,0,0,0,3]
15:12:14 <hpc> > map ord "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ETX\NUL\NUL\NUL\NUL\SOH\NUL\NUL\NUL\NUL\STX\NUL\NUL\NUL\NUL\ETX"
15:12:15 <lambdabot>   [0,0,0,0,0,0,0,3,0,0,0,0,1,0,0,0,0,2,0,0,0,0,3]
15:12:29 <hpc> neat
15:12:35 <levifikri> ok I get it
15:12:35 <hpc> length 3, data is 1,2,3
15:13:03 <rwbarton> I don't know what the format for Integer is but in this case it appears to be using 5 bytes
15:13:15 <hpc> @src Integer
15:13:16 <lambdabot> data Integer = S# Int#
15:13:16 <lambdabot>              | J# Int# ByteArray#
15:13:32 <Ptival> how to easily parse "10 11 12 13 ..." into [10, 11, 12, 13, ...]?
15:13:48 <monochrom> map read . words
15:14:05 <hpc> :t words
15:14:06 <lambdabot> String -> [String]
15:14:07 <hpc> :t map read
15:14:08 <lambdabot> forall a. (Read a) => [String] -> [a]
15:14:36 <monochrom> although, something else is needed to say "I want numbers not bools"
15:16:00 <hpc> usually it can figure it out when you start actually using the numbers
15:16:27 <hpc> unless you do silly things like only show them, or discard them entirely
15:18:00 <Ptival> thanks
15:24:35 <hpaste> anon pasted "paste"  http://hpaste.org/44456
15:30:19 <hpc> oh my, that paste is seriously indented
15:30:52 <hpc> indents nearly 40 characters in places
15:33:31 <kmc> heh
15:33:41 <kmc> i assumed it was the "letting the name of your function dictate how far you indent" problem
15:33:44 <kmc> but actually it's not
15:34:20 <hpc> it is a ginormous where
15:35:20 <mjrosenb> is there anything like zipWith for maps?
15:35:32 <mjrosenb> or zip for that matter?
15:35:53 <Saizan> unionWith intersectionWith
15:36:09 <duckinator> hi
15:36:36 <kmc> hi mjrosenb :)
15:36:51 <hpc> :t unionWith
15:36:52 <lambdabot> Not in scope: `unionWith'
15:52:20 <geheimdienst> mjrosenb: you might also be interested in Map.fold or Map.foldWithKey, for zipping each map key together with its map value
15:59:01 <mjrosenb> geheimdienst: i do not remember any simple way to make fold behave like zip?
16:00:03 <kmc> if you want to zip each key together with its value, that's just M.assocs
16:02:11 <geheimdienst> it depends on what you're trying to do ... i read your question as "i'd like my function to be called with each key/value pair of a map, similar how zipWith calls a function with each pair out of two lists"
16:05:28 <geheimdienst> > M.foldWithKey (\k v acc -> (show k ++ "--" ++ show v) : acc) [] $ M.fromList [(3, 42), (4, 37)]
16:05:29 <lambdabot>   ["3--42","4--37"]
16:07:27 * hackagebot hspec 0.3.0 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.3.0 (TrystanSpangler)
16:20:11 <hpaste> anon pasted "1"  http://hpaste.org/44457
16:21:59 <Augusto> hallo
16:23:30 <c_wraith> Woo!  profiling has exposed that most of this application's runtime is spent in a function that calls readchan...  When the chan is often empty!
16:28:39 <mjrosenb> kmc: no, but I think what i want is zipWith f m1 m2 = let ks = keys m1 `union` keys m2 in fromList (L.zipWith3 (\x y z -> (x, f y z)) ks (map (`lookup` m1) ks) (map (`lookup` m2) ks)))
16:29:09 <kmc> that's... almost M.unionWith
16:30:16 <kmc> this is a hole in the API, afaik :/
16:30:21 <kmc> i think it's come up here before
16:32:08 <kmc> a more efficient implementation should be feasible even with the existing API
16:32:20 <mjrosenb> yeah... most likely.
16:32:35 <mjrosenb> that was from perusing the api for a couple of minutes
16:32:58 <mjrosenb> and implementing unionWith with zipWith should be trivial
16:34:46 <Ptival> @pl (\acc l -> (acc + 1, drop acc l))
16:34:47 <lambdabot> ap ((.) . (,) . (1 +)) drop
16:39:04 <co_dh> greeting  guys.  I found type are not first class in Haskell, in the sense that to define composition of 2 type , you have to dp: newtype (g :. f) a = O (g (f a))
16:39:17 <co_dh> instead of gf  = g f. 
16:39:29 <co_dh> or gf a = g ( f a )
16:39:39 <co_dh> s/dp/do
16:40:24 <co_dh> so is it possible to make type as a first class member in Haskell? or is that what agda fills ? 
16:41:28 <kmc> yep, that would be agda
16:41:49 <co_dh> am I the only one that find agda hard to read ? 
16:41:58 <kmc> no, although a good font helps
16:42:09 <kmc> for me Agda is terribly hard to read in terminal Emacs but much better in X Emacs
16:42:27 <kmc> for types to be fully first-class would allow functions that take and return types, and also take and return other sorts of values
16:42:42 <co_dh> I have X Emacs, still,  Agda is hard to understand. 
16:43:02 <kmc> and that means it'll be either dynamically typed or dependently statically typed
16:43:36 <co_dh> kmc: thanks !
16:43:41 <kmc> however there are languages like Omega, which aren't dependently typed, but sort of replicate all the value machinery at the type level
16:43:48 <kmc> (in fact Omega has an infinite hierarchy of such levels)
16:44:04 <monochrom> no wonder it is called Omega
16:44:07 <co_dh> is Omega dynamically typed? 
16:44:09 <kmc> no
16:44:16 <kmc> it is statically typed
16:44:20 <Mathnerd314> kmc: but... perhaps it is unsound!
16:47:50 <co_dh> every monad comes with a pair of adjoint functor, so what's the functors of List monad? 
16:48:35 <dolio> Free monoid, and forgetful.
16:49:21 <co_dh> dolio: can you be more concrete ? thanks
16:49:40 <dolio> The forgetful functor takes monoids to their underlying sets.
16:50:00 <dolio> The free monoid functor takes sets to the free monoid (list) over that set.
16:50:10 <co_dh> but for list monad, what's the forgetful functor? 
16:50:11 <Rotaerk> that sounds almost like a proverb
16:50:16 <Rotaerk> "the forgetful functor.."
16:51:07 <co_dh> I mean, can we write the forgetful functor of list monad as a haskell function? 
16:51:17 <kmc> a functor would not be a Haskell function
16:51:23 <kmc> because it's a map on both types and functions
16:52:12 <dolio> Haskell doesn't do well representing categories whose objects are other than Haskell types.
16:52:24 <dolio> And the category of monoids isn't really such a category.
16:52:26 <co_dh> kmc: ok, can we write the forgetful functor as a haskell class?
16:52:36 <kmc> that doesn't make sense either
16:53:03 <kmc> some functors (some endofunctors on Hask) can be written as type constructors which are an instance of 'Functor'
16:53:05 <kmc> many others can't
16:53:14 <kmc> i think category-extras has a more general Functor class
16:53:24 <wolverian> fwiw, http://hackage.haskell.org/platform/ still says "Next release: January 2011" 
16:53:30 <kmc> haha
16:53:37 <hpc> you still can't generalize over all mathematical functors though
16:54:25 <wolverian> I'd report the bug but the page doesn't have contact information :p
16:54:57 <co_dh> that's sounds like : mathematical language a more abstract language than haskell. 
16:55:10 <co_dh> am I right? 
16:55:29 <kmc> i'd say maths is a lot more abstract than anything which can be executed by a computer
16:55:42 <kmc> but you may have to clarify your definition of "abstract"
16:55:50 <co_dh> I cant' :(
16:56:09 <kmc> co_dh, why ask us if your statement is correct if you don't even know what it means?
16:56:16 <co_dh> Is there a programming language based on category theory? 
16:56:47 <kmc> yes but i don't recall the names
16:56:49 <hpc> co_dh: yes, somewhere around here... <.< >.>
16:56:51 <hpc> :P
16:56:51 <kmc> someone else here probably knows
16:57:02 <co_dh> I know what "abstract" mean, but I can't clarify it :(
16:57:02 <hpc> oh, there is one?
16:57:04 <hpc> neat
16:57:21 <kmc> if you stay up past about 5 AM EST, #haskell becomes more and more categorical
16:57:27 <kmc> and once in a blue moon such languages will show up
16:57:45 <ddarius> abstraction = quotienting
16:58:13 <ddarius> Charity and CPL are probably the closest to "languages based on category theory"
16:58:26 <edwardk> kmc: it was factored into another package. i believe it is in 'categories' now
16:59:18 <edwardk> kmc: hah, re 5am thats mostly because i'm still awake, but tired enough that i start rambling
17:05:44 <temoto_> How was this channel haskell-? called where they talk off topic?
17:06:06 <geheimdienst> temoto_: haskell-blah
17:06:40 <geheimdienst> past 3am, the lines between haskell and haskell-blah tend to blur
17:10:56 <hpaste> pastorn pasted "aoeu"  http://hpaste.org/44458
17:11:23 <pastorn> lolwat?
17:11:47 <pastorn> who has admin rights to hpaste?
17:12:14 * pastorn thinks announcing shouldn't be on by default :/
17:12:43 <dark> > do { x <- "12"; y <- "45"; return [x,y] }
17:12:43 <lambdabot>   ["14","15","24","25"]
17:13:14 <dark> x <- "12" means what? that x will receive values '1' and '2'?
17:13:23 <Bynbo7> yeah
17:13:37 <Mathnerd314> > "12" == ['1','2']
17:13:37 <lambdabot>   True
17:13:43 <Bynbo7> [x | <x <- [1..4]]
17:13:48 <Bynbo7> > [x | x <- [1..4]]
17:13:49 <lambdabot>   [1,2,3,4]
17:13:58 <dark> oh, I already knew about this String = [Char]
17:14:13 <Bynbo7> > [(x,y) | x <- [1..4], y <- "bar"]
17:14:14 <lambdabot>   [(1,'b'),(1,'a'),(1,'r'),(2,'b'),(2,'a'),(2,'r'),(3,'b'),(3,'a'),(3,'r'),(4...
17:14:28 <dark> now, the interpretation of list as a non-deterministic computation looks nicer
17:14:42 <co_dh> x <- "12" means x will return either 1 or 2 . 
17:15:00 <ion> >>= is akin to “for each” (and …concat) in the list monad.
17:15:22 <dark> (like, I didn't know that x <- somelist would result in x being 'any' value of somelist.. like some non-deterministic choice)
17:15:58 <co_dh> I have a feeling that by using >>= and return, the symmetry of monad ( of return, join , map )  are lost. 
17:15:58 <Bynbo7> well, it'ds completely deterministic, when you know that >>= is defined as flip concatMsp
17:16:20 <dark> http://www.haskell.org/haskellwiki/Blow_your_mind#Monad_magic
17:16:26 <ddarius> co_dh: Use (>=>) and return.
17:16:44 <dark> @src (>=>)
17:16:44 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:16:50 <dark> @type (>=>)
17:16:51 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:16:54 <Bynbo7> :t (>=>)
17:16:54 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:17:23 <geheimdienst> > [1,2] >>= [4,5]
17:17:24 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
17:17:39 <co_dh> if we just ( return, join, map) , can we make monad composable? 
17:18:03 <co_dh> s/just/use/
17:18:35 <dark> return >=> return == return?
17:18:48 <Bynbo7> :t return >=> return
17:18:49 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:19:16 <dstcruz> kmc: hey, got a question about a quote of yours... can I pm?
17:20:55 <kmc> yeah
17:21:01 <kmc> (shit, what did i say)
17:21:06 <co_dh> a monad is just a functor with 2 natural morphism, if we can compose functor, why not monad? 
17:21:25 <kmc> you can compose monads
17:21:40 <kmc> [Maybe Char] is the list monad composed with the maybe monad, applied to the type Char
17:21:42 <co_dh> kmc: do you mean monad transformer?
17:21:52 <kmc> however, that's not the same as composing the "functionality" of the two monads
17:22:14 <owst> Can someone explain how the following typechecks? I think it's something to do with _|_, but can't form an explanation! loopy :: Int \n loopy = loopy
17:22:33 <ddarius> co_dh: As you said, a monad is a functor with two natural transformations.  You can compose the two functors of two monads to get a third functor, but you still need to formulate two natural transformations.
17:23:18 <co_dh> ddarius: so those 2 natural transformations cannot be composed, I guess. thanks 
17:23:29 <Bynbo7> owst: well loopy is defined to have the type Int on the right of the =, meaning that when loopy is defined on the right, its type is also Int. You're right about it being because of _|_ though
17:24:17 <dark> owst, the most general type for this seems to be forall a. a. when you provide a type, the compiler try to find the intersection between what you provided and the most general type. and the intersection between forall a. a and something is this something
17:24:55 <deech> Hi all, how do I round down a Double, the "floor" function expects something in Integral which Double is not.
17:25:04 <dark> (this is called unification, but I don't know the algorithm itself)
17:25:04 <ddarius> :t floor
17:25:05 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:25:20 <kmc> > floor 3.5
17:25:21 <lambdabot>   3
17:25:24 <c_wraith> :t fromIntegral . floor
17:25:24 <owst> Right, so you mean "to get an Int having called loopy, call loopy, which'll give you an Int"
17:25:24 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
17:25:47 <ddarius> owst: There is no "calling" here.  There is no functions.
17:25:48 <dark> owst, you seem to believe that loopy is a function that receive no parameters
17:25:53 <kmc> "call" isn't really the right verb because it's not a function
17:26:11 <dark> somebody here had a nice link about this
17:26:19 <kmc> owst, the answer is that when you're type-checking a group of recursive definitions, you're allowed to assume the correctness of each variable's type as it's used on the right-hand side
17:26:27 <owst> Hmm. Try again: to get the value of the expression loopy, get the value of loopy?
17:26:43 <deech> c_wraith: Thanks!
17:27:13 <c_wraith> deech:  the compiler might complain about that.
17:27:21 <c_wraith> :t fromInteger . floor
17:27:22 <lambdabot> forall a a1. (Num a, RealFrac a1) => a1 -> a
17:27:29 <c_wraith> But it won't complain about that one.
17:29:01 <dark> http://conal.net/blog/posts/everything-is-a-function-in-haskell/ found it
17:29:18 <owst> dark: Thanks, I'll take a look.
17:30:58 * conal chuckles over that url
17:33:53 <dark> "Or perhaps they’ve heard someone speak with confidence, and they confused confidence with understanding." < lots (most?) of things I talk with confidence, I have no actual knowledge *feels guilty*
17:37:03 <frank00> I have a lil question about >>=
17:37:06 <dark> owst, something I think I understand is that your loopy expression can have any type you want (Int, but also Float, etc) because you will never actually see its value (in order to prove it isn't an Int, etc)
17:37:55 <c_wraith> frank00: just ask
17:38:24 <frank00> In evaluating [1,2] >>= \n -> "ab" >>= \ch -> return (n,ch)  : sice >>= is infixl I evaluate  [1,2] >>= \n -> "ab" first. That gives me "abab". But then I should pass that to >>= \ch -> return (n,ch)  which makes no sense at all to me :S
17:38:50 <c_wraith> that's correct.
17:38:54 <frank00> What am I missing? (btw, the result in GHCi is: [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
17:39:06 <c_wraith> String = [Char]
17:39:12 <frank00> ok
17:39:30 <kmc> why does it make no sense?
17:39:40 <c_wraith> break it into ['a','b','a','b']
17:39:41 <frank00> ['a', 'b', 'a', 'b']
17:39:57 <c_wraith> Yeah.  Does it make more sense if you think of it that way?
17:40:17 <frank00> yes, I have to pass it to \ch -> return (n,ch) 
17:40:25 <kmc> > concatMap (\n -> concatMap (\ch -> return (n,ch)) "ab") [1,2]
17:40:25 <frank00> but... n?
17:40:26 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
17:40:28 <frank00> I don't see n
17:40:37 <c_wraith> n is from the previous lambda
17:40:39 <c_wraith> Oh, I see.
17:40:41 <kmc> frank00, \ scopes as far as possible to its right
17:40:59 <c_wraith> yeah, kmc covered it.  lambda expressions scope as far as possible.
17:41:43 <frank00>  /as far as possible/, mhhh. Am I correct in saying that the expression I posted posses /not/ associative property?
17:41:55 <c_wraith> that is correct
17:42:15 <c_wraith> there's only one >>= in the top-level expression
17:42:22 <kmc> there is no way (>>=) could be associative, as its left arg, right arg, and return value all have different types
17:43:01 <frank00> well, that settles it, I must have mixed monads with app. functors
17:43:12 <frank00> thanks c_wraith and kmc 
17:43:26 <kmc> the function you're implementing can be performed with applicative functors
17:44:25 <c_wraith> > (,) <$> [1,2] <*> "ab"
17:44:25 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
17:45:08 <frank00> kmc : I suspected so (reading learn you a haskell for a greater good)
17:49:34 <frank00> >  (++) <$> "Thank you " <*> ["c_wraith", "kmc"]
17:49:34 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:49:35 <lambdabot>         against inferred type...
17:49:49 <frank00> doh :P
17:50:06 <c_wraith> Heh.  That'd explode every character in the first string.  That might be unpleasant :)
17:50:08 <frank00> >  (++) <$> ["Thank you "] <*> ["c_wraith", "kmc"]
17:50:09 <lambdabot>   ["Thank you c_wraith","Thank you kmc"]
17:50:13 <c_wraith> there you go :)
17:50:14 <frank00> \o/
17:53:26 <BJ_> hi there
17:55:22 <frank00> hello
17:55:32 <BJ_> hi
17:59:43 <mjrosenb> hrmm, with view patterns
18:00:30 <mjrosenb> there's no way of using a view pattern to pull something out of a state monad, e.g.
18:00:55 <mjrosenb> Int -> State (Map Int Int) Int
18:01:17 <mjrosenb> and I want to use a view pattern to match on the first argument there
18:01:35 <mm_freak_> mjrosenb: what's the matter with that?
18:01:44 <mm_freak_> you need the state?
18:03:55 <roconnor> ($ a) <$> (($ (h f)) <$> ((.) <$> u)) -- haskel does kinda look like line noise
18:08:55 <ddarius> @pl \a h f u -> ($ a) <$> (($ (h f)) <$> ((.) <$> u))
18:08:55 <lambdabot> (. flip (flip . (((.) . (<$>) . flip id) .)) ((.) <$>)) . (.) . (.) . (<$>) . flip id
18:09:00 <ddarius> Fixed
18:09:33 <roconnor> :D
18:09:43 <btutt> :t flip
18:09:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
18:09:58 <tophei> 9+2
18:10:20 <roconnor> @unpl (($a).)
18:10:21 <lambdabot> (\ c f -> c f a)
18:10:25 <roconnor> @unpl ((($a).).)
18:10:25 <lambdabot> (\ d g j -> d g j a)
18:11:04 <co_dh> what's the meaning of | here : class (Category r, Category t) => Functor f r t | f r -> t, f t -> r where
18:11:42 <shachaf> @wiki Functional dependency
18:11:42 <lambdabot> http://www.haskell.org/haskellwiki/Functional_dependency
18:11:43 <co_dh> does that means t depends on fr , and r on f t ? 
18:12:04 <co_dh> shachaf: thanks :)
18:27:20 <Bfig_> how can you make a one liner quicksort? ie, quicksort xs = if xs == [] then [] else ... ??. how do you write an inline pattern matching without returning anything? ie, 'else y:ys <- xs [ z : z <- ys, z<y ] ++ [ z : z <-ys, z>=y]' ?
18:28:24 <Bfig_> i could write two times the word quicksort but i want to cram it in a single line :p
18:28:33 <roconnor> @unpl ($ id)
18:28:33 <lambdabot> (\ b -> b (\ a -> a))
18:28:43 <roconnor> @unpl ($ id) . (.)
18:28:43 <lambdabot> (\ h e -> h e)
18:29:25 <Bfig_> ?
18:29:39 <roconnor> that was for me
18:29:54 <augur> so
18:30:01 <augur> who's heard of chomsky-schutzenberger
18:30:37 <shachaf> Bfig_: That's not quicksort.
18:31:07 <Bfig_> i forgot to ++ the y in the middle
18:31:07 <shachaf> Bfig_: There was a golfing session for it yesterday, though. It's probably in the logs.
18:31:20 <Bfig_> how is it not quicksort? :S
18:31:20 <kmc> Bfig_, with "let" and "case"?
18:31:28 <kmc> Bfig_, anything can be written on a single line using { } ;
18:31:49 <Bfig_> mmm i'll check on the syntax then, thanks to both of you
18:32:03 <Hugglesworth> Bfig_: qsort (x:xs) = [a|a<-xs,a<=x] ++ [x] ++ [a|a<-xs,a>x]
18:33:10 <Hugglesworth> and the obligitory `qsort [] = []` but you could just if that if you /really/ want it on one line
18:33:20 <ksf_> why are alex and happy in the platform but not a single combinator library?
18:33:43 <ksf_> oh, parsec. and regex*
18:33:45 <ksf_> nvm.
18:34:09 <Bfig_> Hugglesworth, how do you use the (x:xs) inside the else clause?
18:34:17 <kmc> you probably want case not if
18:34:23 <kmc> case xs of [] -> ...; (x:xs) -> ...
18:34:43 <Bfig_> ohh pretty cool.
18:34:45 * ksf_ always uses functions instead of case.
18:35:02 <kmc> "if" is not much loved in haskell
18:35:06 <Hugglesworth> qsort z@(x:xs) = if z==[] then [] else [a|a<-xs,a<=x] ++ [x] ++ [a|a<-xs,a>x]
18:35:09 <ksf> (and I don't want to hear anything about short identifiers, there)
18:35:11 <kmc> it's so restricted compared to "case"
18:35:20 <Hugglesworth> meh
18:35:30 <ksf> and it's not curryable.
18:35:39 <Hugglesworth> I'm from C, so you'll have to pry if from my cold dead hands
18:35:43 <shachaf> if should be if'
18:35:55 <kmc> Hugglesworth, how could z == [] if it matched (x:xs)?
18:35:58 * ksf doesn't mind, he uses pca.
18:36:01 <roconnor> @unpl ($a) .(<*>)
18:36:01 <lambdabot> (\ e -> e <*> a)
18:36:06 <kmc> it could work with a lazy pattern instead, but it's still a big hack
18:36:09 <monochrom> some uses of if-then-else are fine. make sure they are really boolean conditions.
18:36:13 <ksf> the other important one being cap, for monadic code.
18:36:13 <Hugglesworth> kmc: oh right
18:36:19 <shachaf> Also, never do "== []".
18:36:22 <shachaf> Use null.
18:36:32 * Hugglesworth flees
18:36:50 <Bfig_> Hugglesworth, so @ means match this or that pattern? DAMN NICE
18:36:53 <Hugglesworth> shachaf: you too? why are so many jbopre haskell people
18:37:00 <Hugglesworth> Bfig_: no
18:37:04 <Hugglesworth> I'm just an idiot
18:37:11 <ksf> foobar >>= cap (print "ontrue") (print "onfalse")
18:37:11 <kmc> x@p means match p, and also bind the whole thing to x
18:37:16 <shachaf> Hugglesworth: I'm hardly a jbopre.
18:37:16 <geheimdienst> @src null
18:37:17 <lambdabot> null []     = True
18:37:17 <lambdabot> null (_:_)  = False
18:37:19 <Hugglesworth> z@(x:xs) gives z the value of (x:xs)
18:37:27 <dolio> I use if, but 'if null xs then ... head xs ... else ...' isn't something I'd do.
18:37:35 <Hugglesworth> shachaf: you're still there
18:37:44 <Bfig_> so in that case qsort [] wouldn't be  defined properly right?
18:37:48 <dolio> Since I'm not a scheme programmer.
18:37:50 <geheimdienst> what's the difference between null and "== []"?
18:37:53 <Hugglesworth> yeah
18:37:58 <ksf> @src null
18:37:58 <lambdabot> null []     = True
18:37:59 <lambdabot> null (_:_)  = False
18:38:06 <copumpkin> geheimdienst: one requires EQ
18:38:07 <copumpkin> Eq
18:38:08 <shachaf> @ty (==[])
18:38:09 <lambdabot> forall a. (Eq a) => [a] -> Bool
18:38:10 <shachaf> @ty null
18:38:11 <lambdabot> forall a. [a] -> Bool
18:38:21 <lpsmith> >  [] == (1 : undefined)
18:38:22 <lambdabot>   False
18:38:32 <geheimdienst> ok thanks
18:38:55 <lpsmith> == []  isn't that big of a deal,  it'll only force one cell of the resulting list,  same as null
18:39:17 <copumpkin> null [(+1)]
18:39:19 <copumpkin> > null [(+1)]
18:39:20 <lambdabot>   False
18:39:24 <copumpkin> > [] == [(+1)]
18:39:25 <lambdabot>   False
18:39:29 <copumpkin> o.O
18:39:35 <lpsmith> The Eq issue of == [] versus null is a valid, but minor point.
18:39:50 <shachaf> copumpkin: lambdabot extensions.
18:39:58 <lpsmith> that's lambdabot-skell
18:40:04 <shachaf> > (+1) == (+1) -- It doesn't actually work, alas. :-(
18:40:05 <lambdabot>   *Exception: (==): No overloading for function
18:40:07 <lpsmith> > (+1) == (+1)
18:40:08 <lambdabot>   *Exception: (==): No overloading for function
18:40:12 <lpsmith> oh,  nm
18:40:16 <lpsmith> > (+1)
18:40:17 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:40:17 <lambdabot>    arising from a use of `...
18:40:48 <shachaf> copumpkin: It's needed for the Num (->) instance.
18:40:55 <copumpkin> yeah, I figured
18:41:14 <lpsmith> > \x -> x + 3
18:41:15 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:41:16 <lambdabot>    arising from a use of `...
18:41:19 <lpsmith> that used to work
18:41:55 <shachaf> > putStrLn " <IO ()>"
18:41:55 <lambdabot>   <IO ()>
18:42:02 <Pseudonym> I think I just did something that isn't kosher.
18:42:06 <Pseudonym> -- {-
18:42:12 <Pseudonym>     code that was commented out, but isn't now
18:42:13 <Pseudonym> -- -}
18:42:27 <shachaf> Pseudonym: What's wrong with that?
18:42:45 <Pseudonym> Everything is permissable, but not everything is good for you.
18:43:50 <shachaf> Pseudonym: You can turn {-/-} into {--}/{--}, if you prefer. Same number of characters.
18:44:30 <shachaf> Pseudonym: Hmm, but this isn't valid: {-\n-- {-\n-}
18:51:09 <bss03> I've been thinking about using System.Posix.Signals.  But, as one familiar with C...
18:51:36 <bss03> I know there are a number of things that are unsafe to do from a signal handler.
18:52:16 <bss03> The documentation for System.Posix.Signals doesn't provide any guidance as to what Haskel features / functions are "Okay" from a signal handler.
18:52:45 <bss03> Are there any good guidlines, or should I really be handling signals from a C wrapper / controller?
18:56:32 <ksf> btw, anyone got any news on ghc 7.0.2?
18:57:28 <ksf> @quote douglas-adams I love deadlines, I especially like the swooshing sound they make as they fly past
18:57:28 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
18:57:33 <ksf> @remember douglas-adams I love deadlines, I especially like the swooshing sound they make as they fly past
18:57:34 <lambdabot> Nice!
18:59:16 <minn_> Is there an instance of Applicative analogous to the "zipped list" instance of lists for n-ary trees? Clearly, if you have something like (Node a xs) <*> (Node b ys) defined with zipWith (<*>) on xs and ys, the law pure id <*> u = u doesn't hold.
19:00:00 <ksf> minn_, yes it does.
19:00:10 <ksf> pure x = (Node x [])
19:00:24 <ksf> err wait. 
19:00:40 <minn_> then you're going to "zipWith" everything to [], though
19:00:41 <napping> pure x = Node x (repeat (pure x)) ?
19:00:41 <ksf> you need to apply everything to everything again.
19:00:50 <ksf> or that, yes.
19:01:16 <minn_> That works too
19:01:25 <minn_> (well, the other didn't, so "that works")
19:03:04 <bss03> That's a big tree.
19:03:16 <BMeph> Finally done!
19:03:25 <BMeph> Now, it's time for the re-write! :D
19:04:10 * hackagebot Ganymede 0.0.0.1 - An Io interpreter in Haskell.  http://hackage.haskell.org/package/Ganymede-0.0.0.1 (WaltBaety)
19:04:18 <BMeph> (For Your Perusal: Ganymede-0.0.0.1 is released! Watch out, I hear it's rather wild and wooly... ;)
19:04:31 <bss03> So, no hints on handling signals from Haskell?
19:05:24 <ksf> bss03, afaik the rts doesn't do any deep magic, there.
19:06:03 <napping> which Io?
19:06:45 <BMeph> napping: Read the description, and be amused... :)
19:06:46 <shachaf> napping: Presumably the #io one.
19:06:56 <BMeph> shachaf: ...or not. :)
19:07:08 <shachaf> Oh, maybe not.
19:07:24 <ksf> ooooh *that* io.
19:07:51 <ksf> didn't even know there was a paper about it
19:08:19 <BMeph> ksf: Yes. However, now that I'm free to work on it on my own, I think I'm going to ditch more of vague's stuff, and make it more like the original.
19:08:58 <ksf> you definitely are, I never expected someone else to even know that gem exists.
19:09:31 <ksf> isn't the moon called "gandymede"?
19:09:39 * shachaf has not heard of this Io.
19:09:49 <geheimdienst> ganymede, i believe
19:10:00 <ksf> hmmm indeed.
19:10:03 <geheimdienst> gandhimeat
19:12:39 <ksf> dammit. it's not even a misprint in my copy of http://en.wikipedia.org/wiki/The_Physicists
19:12:51 <monochrom> System.Posix.Signals uses a new thread to run your handler. A whole lot of things are safe, just because nothing else is really suspended and to be resumed.
19:12:54 <ksf> which is, btw, an awesome play.
19:14:05 <ksf> and damn wikipedia, the whole article is a spoiler.
19:15:05 <BMeph> I looked for a moon whose name started with an "H", to be more "Haskelly," but they're all puny. However, Ganymede is not puny, and even better, it's in the same group as Io, which is a different one than Amalthea.
19:15:20 <Andy_> Hey guys, I'm new to haskell and have a question thats hopefully easy to answer... I have a custom "expression" data type with a couple different constructors (if0, add, etc) that are each formed differently. I'm trying to write an interp function that handles each type, but and am getting a "Multiple Declarations of Main.Interp" error when trying to define the different parts of the pattern matching interp function for each type of 
19:15:52 <geheimdienst> BMeph: amalthea?
19:16:13 <shachaf> Andy_: You should probably @paste your code.
19:16:42 <bss03> ksf: Well, I was wandering if there were any haskell functions to avoid -- ones that might call C / POSIX functions that aren't safe to call from a signal handler?
19:17:46 <napping> bss03: Does any Haskell code run in a signal handler?
19:18:04 <ksf> shouldn't you get out of the handler asap anyway?
19:18:14 <napping> not necessarily
19:18:35 <bss03> monochrom: Okay, well, I'll just assume Haskell works until I run into a problem that's impossible to debug. :P
19:18:45 <napping> I haven't checked recently, but I think the rts has real signal hadlers, that just schedule your handler to be called
19:18:58 <BMeph> geheimdienst: Amalthea is the name of vague's Io interpreter writtem almost a decade ago, in OCaml.
19:19:14 <napping> and no haskell code actually runs inside a signal handler
19:19:42 <bss03> Oh, I figured I's probably just twiddle a MVar CSigAtomic in the handler.
19:19:49 <Andy_> Heres what I'm trying thats giving me a multiple definitions error: http://codepad.org/yzI1CTiW
19:19:59 <Andy_> let me know if thats not enough to determine where the error is coming from
19:20:37 <geheimdienst> BMeph: okay i see :) it will be quite some more interpreters until we run out of jupiter moons with melodious names
19:20:45 <shachaf> Andy_: It probably isn't.
19:20:58 * shachaf suspects you have multiple definitions somewhere.
19:21:08 <bss03> I could do a whole lot, but that would probably involve introducing a number of OpenGLesqe StateVars, and I'd rather avoid that.
19:21:09 <minn_> You have multiple defintions of "Main.Interp,
19:21:27 <minn_> "which means mutiple data or class definitions of a data type or class called Interp, most likely
19:21:39 <Andy_> thats what its telling me... but I thought that if they had different patterns then it would work?
19:21:51 <Andy_> since one of them interprets if expressions and one add expressions
19:21:55 <shachaf> Andy_: There's probably context missing.
19:21:58 <fmapE> Andy_
19:22:05 <fmapE> it's not complaining about your interp function
19:22:12 <shachaf> Andy_: If it said "Interp", upper-case, then it's probably not the function, as people are pointing out.
19:22:13 <bss03> napping: That would be ideal.  I hope that's the case.
19:22:37 <shachaf> Andy_: Also, using Reader/State could probably help with carrying env around everywhere. :-)
19:22:51 <napping> bss03: I don't even remember in what manual I thought I read that stuff
19:23:23 <BMeph> geheimdienst: I suspect making interpreters for Io will go out of style before we run out of names for them. :)
19:23:25 <Andy_> The actual error is "Multiple declarations of `Main.interp'", it only happens when I have both of those interp functions enabled
19:23:34 <ksf> Andy_, and the next obligatory things to mentions are type-safe interpreters via GADTs and de brujin indices.
19:23:44 <fmapE> Andy_: oh well that changes things
19:23:45 <shachaf> Andy_: Oh, lower-case.
19:23:53 <shachaf> Andy_: You should @paste the rest of your code, then.
19:24:56 <Andy_> k, here it is: http://codepad.org/gIdlWuBc
19:25:33 <napping> the problem is defining addV in the middle
19:25:35 <fmapE> Andy_, you have another function declaration in between
19:25:39 <fmapE> you can't do that
19:25:45 <Andy_> ohhhh
19:25:46 <napping> you have a lot of freedom to rearrange definitions, but not quite that much
19:25:47 <fmapE> all of your declarations of a function have to go together
19:25:58 <shachaf> Andy_: You can put addV in a "where", though.
19:26:06 <Andy_> great. that was easier than I thought. I was under the impression it was completely free ha
19:26:09 <bss03> napping: The reading the "source" linked from the docs makes it seem that way.
19:26:46 <shachaf> Andy_: Isn't your Command just State?
19:26:53 <napping> Nothing depends on order, but a few things have to be grouped
19:27:28 <Andy_> shachaf: yes... but I'm trying to learn how they work so I figured I'd make it from scratch haha
19:27:37 <shachaf> Andy_: Reasonable.
19:27:49 <bss03> napping: I doesn't just "cast" the Handler to the appropriate C type and call sigaction, which is what I thought might happen.
19:27:53 <shachaf> Andy_: You could pass env around in a similar way. :-)
19:28:22 <fmapE> sachaf, Andy_: At that point it's time to learn monad transformers I'd think
19:29:00 * shachaf >>= undefined
19:29:04 <bss03> napping: I thought stictness depnds on order. { and False _ = False; and _ False = False; and _ _ = True } has different strictness is you rearrange the first two parts, yeas?
19:29:14 <Andy_> Thanks guys, it worked once I moved the other function out. I'll look into monad transformers next
19:29:18 <terminer> hi ppl, in haskell... is there a way to achieve the "most efficient" technique, or there are millions of ways which can be as same as efficient?
19:30:43 <napping> ah, I guess strictness may vary
19:30:58 <ddarius> terminer: There's exactly as much of a way in Haskell as there is in every other language.
19:31:07 <napping> templates do split up typechecking
19:31:28 <shachaf> ddarius: Probably less than in some non-Turing-complete languages.
19:32:02 <ddarius> shachaf: I considered using slightly more careful terminology, but decided against it.
19:32:34 <bss03> terminer: Agreed, there's certainyl "bad" and "good" ways to write Haskell, and those depend somewhat on the compiler and the hints.
19:33:01 <napping> Without using TH, I don't think whether a module compiles can depend on the order of definitions
19:33:27 <bss03> napping: That makes sense.
19:33:39 <ksf> ...and still noone with a real-world example of a zygohistomorphic prepromorphism.
19:34:13 <terminer> bss03 ddarius shachaf : I don't fully know how haskell compilation works yet, but as i'm seeing... seems that it's good and bad way is more limited than OOP... which is good
19:34:25 <napping> It's probably easier to find equally fast programs in Haskell, because the inliner is fairly predictable
19:34:50 <terminer> napping: yeah, that's what i wanted to hear..
19:35:15 <shachaf> terminer: It probably doesn't answer whichever question you had.
19:36:46 <terminer> shachaf: it is easier to find equally efficient programs in haskell, that makes it less prone to huge difference in codes
19:37:17 <napping> no, that's not what I meant
19:37:54 <terminer> napping: what is it then? cc: shachaf 
19:38:23 <napping> given one Haskell program, there are certain ways you can rewrite it that probably won't change what the compiler ends up with
19:38:34 <napping> like, hmm, "refactorings", you might say
19:38:57 <napping> but other sorts of changes might still make it lots faster or slower
19:40:00 <minn_> It seems like the "bad" ways to write Haskell often become "good ways" once you understand them
19:40:07 <terminer> for example a simple program, to check how many times '2' is repeated in [4,3,5,2,4,1,2,6,8,4,3,2]... how many ways do you think this can be written in?
19:40:27 <djahandarie> Infinity.
19:42:05 <terminer> keeping in mind efficiency of course..
19:42:13 <parcs> terminer: i only see two ways: using length and filter, and using a fold
19:42:48 <terminer> okay, so that limits it to a couple of ways, unlike in OOP which can be written in 'infinity' ways
19:42:49 <ddarius> parcs: Length and filter are each folds and their combination can be made into a single fold.
19:43:14 <ddarius> There are plenty of other ways to do it.
19:43:19 <parcs> ddarius: yeah
19:45:50 <djahandarie> terminer, is id . id the same as id?
19:46:47 <terminer> sorry can't anwer that, i just started haskell today
19:46:58 <djahandarie> > 3
19:46:59 <lambdabot>   3
19:47:01 <djahandarie> > id 3
19:47:01 <lambdabot>   3
19:47:06 <djahandarie> > (id . id) 3
19:47:07 <lambdabot>   3
19:47:16 <djahandarie> You can keep going
19:47:32 <terminer> yeah
19:55:22 <terminer> howManyTimes :: Int -> [Int] -> Int
19:55:24 <terminer> howManyTimes x xs = length [n | n<-xs, x==n]
19:55:45 <terminer> is this considered efficient?
19:56:11 <napping> efficient enough for [Int], probably
19:56:36 <terminer> how many "efficient" ways can this be written in? how much "more" efficient can i go?
19:57:04 <napping> you could switch to better data structures
19:57:07 <ddarius> Asymptotically, you can't get any more efficient than that while using a list.
19:57:16 <ddarius> (an unstructured list, I should say)
19:57:37 <terminer> ddarius: doesn't this make haskell more powerful than OOP?
19:57:48 <ddarius> No.
19:57:55 <terminer> mmm ... k lol
19:58:52 <ddarius> Not that that question makes much sense as Haskell is a programming language and OOP is a programming paradigm.
19:59:53 <terminer> for example in java, what would you call it? its a language but with an OOP paradigm.. was there Java which wasn't OOP?
20:00:33 <terminer> or c++
20:00:51 <ddarius> @google FunctionalJava
20:00:52 <lambdabot> http://functionaljava.org/
20:00:52 <lambdabot> Title: Functional Java
20:02:31 <terminer> ddarius: you're completely right... didn't know about that at all
20:02:46 <terminer> thanks ddarius , thank you ppl! gtg
20:32:20 <Ptival> @pl \(_, l) -> length l > n)
20:32:20 <lambdabot> (line 1, column 24):
20:32:21 <lambdabot> unexpected ")"
20:32:21 <lambdabot> expecting letter or digit, variable, "(", operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
20:32:28 <Ptival> @pl \(_, l) -> length l > n
20:32:28 <lambdabot> (> n) . length . snd
20:38:34 <copumpkin> whoa: http://www.cs.berkeley.edu/~megacz/garrows/
20:40:15 <jmcarthur> copumpkin: ooh
20:41:12 <c_wraith> wow.
20:41:14 <c_wraith> that looks neat
20:41:29 <geheimdienst> wat is this. supercompilation in haskell?
20:42:21 <c_wraith> no, it's multi-level programming.
20:42:33 <jmcarthur> no, it's just a rockin' way to make dsls
20:42:56 <c_wraith> hmm.  some unfortunate limitations at the moment.
20:43:05 <c_wraith> especially the "your whole program must be one file" limitation
20:46:40 <c_wraith> also, there appears to be a typo in the GArrow definition there.  That type for second isn't right.  but whatever
20:51:05 <zzing> On theoretical level, would it be possible to make a library for window creation (think opengl use) where the window and it properties and events are combined together in some fashion similar to how parsec builds up from basic things?
20:57:59 <ksf_> zzing, google "functional reactive programming"
20:58:35 <ksf_> even if that's not what you actually mean, it's one of the directions (and a cool one) that that thought would lead you to.
21:00:55 <zzing> ksf_: I looked at that. It was too 'out there' when I looked at it last.
21:01:16 <ksf_> it actually is "out there".
21:01:45 <ksf_> but it's *the* way to combine input and output decleratively.
21:04:06 <zzing> Would something like a window monad make any sense?
21:04:34 <ksf_> I don't think so.
21:04:49 <ksf_> ...at least not without frp.
21:05:23 <zzing> I was looking at an SDL demo I converted to GLFW and it looked really ugly.
21:05:59 <ksf_> gui and graphics code tends to be quite imperative, yes.
21:06:13 <zzing> I want to give some thought to ways where this doesn't have to be (as ugly?)
21:06:40 <ksf_> there's e.g. http://www.haskell.org/haskellwiki/GPipe which uses a more declerative model.
21:06:51 <djahandarie> copumpkin, wow, nice!
21:07:17 <zzing> I am not likely the guy to code it, but I want to give some attention to the problem.
21:07:29 <ksf_> but as the libraries you end up using, gl or gtk or whatever, are designed to be used imperatively, there's only so much haskell can do about that without resorting to deep magic.
21:07:30 <djahandarie> All the little things he has done along the way are cool too
21:08:42 <zzing> yes
21:08:55 <ksf_> zzing, there's grapefruit which is operational, but not for the faint of heart, and quite certainly bitrotted.
21:09:05 <zzing> Can gpipe work *now*?
21:09:10 <ksf_> yep
21:09:30 <jmcarthur> it sort of works
21:09:34 <zzing> I will look at it then
21:09:38 <ksf_> though you're probably going to hit a wall sooner or later if you want to do serious stuff
21:09:45 <jmcarthur> it doesn't have amazing code generation or anything
21:10:05 <ksf_> jmcarthur, it doesn't need to, the drivers do their optimizing themselves
21:10:08 <jmcarthur> makes my intel graphics card very unhappy, for example, because it declares way too many intermediate variables
21:10:12 <jmcarthur> ksf_: ^^
21:10:12 <zzing> hmm
21:10:24 <ksf_> oh. that would mean that intel sucks.
21:10:29 <jmcarthur> ksf_: some of the examples don't even run on it
21:10:33 <ksf_> gpipe is in utter need of a rewrite.
21:10:34 <jmcarthur> oh i agree that intel sucks
21:10:49 <ksf_> jmcarthur, can't you use gallium?
21:10:50 <zzing> There is some bad formatting going on here: http://www.haskell.org/haskellwiki/GPipe/Tutorial
21:11:16 <jmcarthur> ksf_: i thought that was only partially working
21:11:25 <ksf_> well, it does work.
21:11:55 <jmcarthur> ksf_: http://www.phoronix.com/scan.php?page=news_item&px=ODE0OQ
21:12:10 <jmcarthur> almost a year old by now though i guess
21:12:20 <ksf_> well, it works for nvidia.
21:13:30 <zzing> Oh I was thinking about taking another look at my unfinished cocoa haskell editor/ide 'Hcode' and wondering if you guys ever had any unique ideas for a haskell centred editor (not primarily written in haskell)
21:13:41 <btutt> wow garrows looks interesting
21:14:01 <ksf_> zzing, have a look at yi and leksah
21:15:53 <zzing> interesting
21:16:14 <zzing> leksah looks the best for gui
21:16:43 <zzing> For some reason it looks incredibly busy gui
21:17:27 * jmcarthur likes emacs just fine
21:17:29 <zzing> I can learn from it though
21:18:05 <zzing> emacs and vi are with aristotle on the top level of hell
21:20:33 <Maxdamantus> Try vim.
21:21:01 <zzing> s/vi/vim    <-- I have :p
21:42:51 <zzing> So has anyone ever gotten a haskell app into either of apple's app stores?
22:21:03 <Omie> Hi everyone !
22:21:38 <mjrosenb> Omie: hiya!
22:22:02 <Omie> I have read, practiced basics of Haskell quite a few times. Wish to develop something meaningful now
22:22:13 <Omie> need idea :-D
22:22:46 <cafesofie> implement a basic lisp in haskell?
22:22:48 <mjrosenb> Omie: the first thing i wrote was a cli that given n would compute an n bit prime number
22:23:28 <Omie> cafesofie: I have no idea about lisp
22:23:36 <cafesofie> now would be a good time to learn then :)
22:24:22 <Omie> mjrosenb: I did those kinds of things. most of the things like this endup in only 1 function
22:25:26 <Omie> cafesofie: heh, okay. added in list.
22:26:31 <Omie> I was hoping for something better. I tried and modified tcp server code I found. Added more functions, commands etc. but it was someone else's code that I used.
22:26:57 <Omie> [not saying lisp idea is bad]
22:30:36 <zzing> Omie: Port the old text based star trek game to haskell.
22:31:34 <Omie> zzing: Great ! Thanks
22:32:48 <zzing> Another idea - implement a typesafe python in haskell...
22:34:24 <zzing> http://www.zimmers.net/anonftp/pub/cbm/vic20/games.basic/index.html
22:35:08 <Omie> I don't know python either :-P My language learning path is like C > C++ > Java > vb.net > c#.net > haskell | There was a fork at vb.net to php :-P
22:35:38 <zzing> Omie, at least you have a clear path
22:36:25 <zzing> My list would include an odd 20+ languages most of which I cannot even remember :-)
22:37:15 <Omie> heh
22:37:26 <zzing> How about functional nethack?
22:37:38 <Entroacceptor> Omie: go and complete the xdg libs
22:39:21 <zzing> What is that?
22:39:41 <kevinburke> http://hpaste.org/44463/kev
22:39:42 <hpaste> kev pasted "kev"  http://hpaste.org/44463
22:39:51 <kevinburke> what happens if you pattern match a do expression and it doesn't match?
22:40:43 <zzing> I thought that patterns have to be exhaustive
22:40:50 <kevinburke> can you pattern match the same function for more than one type of result? like could the next line be t2@(C.IntTy)
22:41:02 <kevinburke> sorry I'm just wondering how to design it
22:41:59 <Omie> I gtg, I will look into Star Trek/kind of game thing. Will come back again later. Thanks :-)
22:42:04 <zzing> hmm, hpaste looks awesome! 
22:42:19 <zzing> Omie, I would love to converse
22:42:31 <zzing> Me newbie :-)
22:43:11 <Omie> I am a newbie too
22:43:37 <Omie> I'll drop by later. really gtg now
22:43:39 <Omie> cya
22:43:41 <Entroacceptor> zzing: xdg is the freedesktop stuff, like start menus
22:43:45 <zzing> K
22:44:11 <Jafet> kevinburke: then the result is undefined
22:44:13 <zzing> Entroacceptor: I am on mac, that is why I have never heard of it
22:44:29 <Jafet> > case 1 of {}
22:44:30 <lambdabot>   <no location info>: parse error on input `}'
22:44:35 <Jafet> > case 1 of 2 -> 3
22:44:36 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
22:45:47 <kevinburke> Jafet: In that case I want to put multiple expressions inside the case statement, in a let/in or a do block, but haskell doesn't seem to like that
22:46:18 <Jafet> Why doesn't it like that? How are you trying to do it?
22:47:11 <kevinburke> Jafet: Let me try a few things and if I cant get it to work i'll hpaste some more
22:56:27 <kevinburke> never mind I got it to work - thanks
23:10:02 <jho> I'm reading Learn You a Haskell, and am in chapter 8, on the part dealing with kinds. There I came across the term "ADT" but I can't for the life of me figure out what it means; it's not repeated on the page anywhere. Can anyone shed light on what it means?
23:10:11 <jho> Context being "How do we know this type has a kind of * -> (* -> *) - > *? Well, fields in ADTs are made to hold values, so they must be of kind *, obviously."
23:13:40 <Entroacceptor> jho: does 'algebraic data type' fit?
23:16:05 <Entroacceptor> oh, I missed the second line. yes, it is.
23:16:07 <jho> Entroacceptor: Yeah, makes sense. Thanks.
23:17:09 * hackagebot yesod-auth-oauth 0.3 - OAuth wrapper for yesod-auth  http://hackage.haskell.org/package/yesod-auth-oauth-0.3 (HiromiIshii)
23:53:57 * hackagebot hopenssl 1.6.1 - FFI bindings to OpenSSL's EVP digest interface  http://hackage.haskell.org/package/hopenssl-1.6.1 (PeterSimons)
