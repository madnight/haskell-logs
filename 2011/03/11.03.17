00:05:16 <accel> i just had the weirdest feeling
00:05:21 <accel> i started writing a library in haskell
00:05:30 <accel> and realized ... this is useful, I could put this on github
00:05:34 <accel> and it struck me:
00:05:56 <accel> i'm no longer 100% wasting #haskell's time, I'ma ctually producing something that has a non 0 probability of being epsilon utility
00:06:02 <accel> it's fucking weird
00:09:47 <freiksenet> is it somehow possible to paramtetrize types in haskell by concrete values? I want to make a toy B+-tree implementation and I wanted to parametrize it by t (half of maximum node size)
00:10:08 <dolio> Not by values.
00:10:20 <freiksenet> so what is the good solution to this?
00:10:38 <dolio> You can embed natural numbers as types, though.
00:10:45 <dolio> data Z ; data S n
00:10:59 <dolio> I think there are packages for that these days.
00:11:13 <freiksenet> heh, I guess I could also just switch to agda :D
00:11:27 <_mpu> or coq
00:11:51 <_mpu> dependent types are hell
00:12:03 <freiksenet> my coq skills are even more rusty than my agda skills I am afraid. Anyway - what is haskell "model" solution for this kind of stuff? is there one? is using dependent type emulation a "good" solution?
00:12:05 <dolio> I was pondering a B tree in Agda the other day, but I decided it'd be a pain to work out all the "you can have between MIN and MIN*2 elements in a node" stuff.
00:21:40 <freiksenet> I guess I don't have time to do that dependent types simulation, I will just do it with a field.
00:23:59 * hackagebot cryptocipher 0.2.7 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.7 (VincentHanquez)
00:25:59 * hackagebot libgit 0.1.0 - Simple Git Wrapper  http://hackage.haskell.org/package/libgit-0.1.0 (VincentHanquez)
00:26:38 <shachaf> dolio: And that's  with fixed-size keys. :-)
00:57:08 <cathper> I want to have the intersection of multiple lists; I could just fold intersect, but it's too slow. The lists are sorted, so I fold Data.Ordered.isect.
00:58:12 <cathper> This is still not too fast. And because the first many lists (and the last many lists) have many elements in common, the intersection is not trimmed very much in the first many foldings.
00:58:53 <cathper> So I consider transposing the list of lists and check if the heads (of the non-transposed list of lists) are the same. If they are, include it. If not ...
00:59:32 <cathper> I have to remove heads that are not the largest.
01:00:59 <cathper> Any ideads to effectively finding "heads that are not the largest" and gluing the largest heads to the lists they belongs to effectively are most welcome.
01:02:05 <ziman_> if you want just do the intersection, you might want to convert the lists to Data.Set's and do the intersections on them; at least I would probably do that
01:02:39 <ziman_> Data.Set has a function called fromAscList
01:02:47 <ziman_> that builds the set in O(n) time
01:07:05 <ziman_> hmm but will that be faster than sorted-list intersection? now I think I might be suggesting a non-solution
01:10:07 <cathper> I'm reading fromAscList.
01:11:10 * hackagebot hiernotify 2011.3.17 - Notification library for a filesystem hierarchy.  http://hackage.haskell.org/package/hiernotify-2011.3.17 (PaoloVeronelli)
01:11:51 <_Ray_> I would do (but I'm not sure it's actually a good solution) a sort of mergesort-ish thing. In the merge stage of mergesort, you can easily modify it to calculate the intersection instead of sorting the things, considering they're already sorted. If I'm calculating it right, this'd be O(n log n), where n is the sum of the lengths of the lists
01:12:47 <cathper> Sounds reasonable.
01:12:54 <_Ray_> (Unlike in mergesort, you don't split in half, you split in half-the-amount-of-lists. The base case is two lists, you calculate the intersection, and return it.)
01:13:51 <cathper> Right.
01:14:29 <cathper> Uhm, but isn't this the same as folding isect?
01:14:35 <cathper> Complexity-wise.
01:15:13 <cathper> Hmm. Maybe I'm stupid now.
01:15:54 <_Ray_> If the lists are all the same, folding intersect should (correct me if I'm wrong) be theta(n^2)
01:16:52 <Jonno_FTW> when I run anything to do with ghc-pkg, I get the following error:  ghc-pkg recache
01:16:55 <Jonno_FTW> ghc-pkg: /home/jonno/.ghc/i386-linux-6.12.1/package.conf.d/unlambda-0.1-601bc7704196b7ec58170920ab22d694.conf: hGetContents: invalid argument (invalid UTF-8 byte sequence)
01:18:02 <cathper> _Ray_: Theta(nm) where n and m are the lengths and the number of lists, I think.
01:18:04 <ziman_> i'd say fold isect is O(m*n) where m is the count of the lists and n is the length of each one — which is pretty much the best you can get (modulo constant factors)
01:18:44 <_Ray_> catpher, yeah, that's right. for some reason I assumed they were n lists of length n :)
01:21:24 <cathper> ziman_: You might be right, but in my head the following is faster: Run through all heads and find (min,max), if they equal, include the element and repeat on the tails, if not, repeat on the entire lists where the head is max and the tails of the rest of the lists.
01:22:06 <cathper> Worst-case is probably not better, but the way my data looks like will (is my intuition) make it faster.
01:23:03 <ziman_> do you sort the lists in the descending order?
01:24:56 * _Ray_ thinks his method is, as you said, complexity-wise the same as folding insert for the identical-list scenario.
01:26:43 <ziman_> while traversing the heads, you can build a new version of the structure (structure = (head_list, tails)) — if you encounter a maximum head, shift the corresponding list; if you encounter a new maximum, "reset" the structure being built to a copy of the old structure up to the current point
01:27:10 <lispy_> dcoutts: are you around?
01:27:26 <lispy_> ?botsnack
01:27:26 <lambdabot> :)
01:28:29 <lispy_> ?tell dcoutts when you get a chance, could you please run 'darcs optimize --upgrade' (with a recent-ish darcs) in both the Cabal and cabal-install repos.  At least one of them is not in the hashed format yet and that's bad for performance and data corruption.
01:28:29 <lambdabot> Consider it noted.
01:29:22 <lispy_> And if anyone here every gets sick of cabal being not so great at building things, go comment on this ticket: http://hackage.haskell.org/trac/hackage/ticket/815  :)
01:30:15 * hackagebot tdoc 0.4.0 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.4.0 (NicolasPouillard)
01:34:32 <lispy_> ?tell dcoutts if you need more information about hashed see this: http://wiki.darcs.net/OF
01:34:32 <lambdabot> Consider it noted.
01:42:45 <aleator> Given Data.Text, how do I easily find out the starting index of each word in a string
01:42:48 <aleator> ?
01:52:49 <cathper> ziman_: That sounds like a good idea.
02:02:11 <hvr> http://caml.inria.fr/mantis/view.php?id=5237 seems to apply to GHC as well :-(
02:02:42 <hvr> I just tried to build bytestring-mmap on ubuntu 11.04,
02:02:45 <hvr> and it bombed with
02:02:50 <hvr> /tmp/ghc12255_0/ghc12255_0.s:859:0: Error: .size expression does not evaluate to a constant
02:05:23 <lispy_> hvr: you may need to mention that in #ghc
02:05:39 <lispy_> not sure if the right people will notice it here
02:05:46 <hvr> k
02:12:42 <gienah> hvr: bytesting-mmap 0.2.1 builds ok on gentoo ghc 7.0.2 amd64
02:13:46 <hvr> gienah: what does 'as --version' say?
02:13:56 <hvr> GNU assembler (GNU Binutils for Ubuntu) 2.21.0.20110302
02:15:32 <gienah> hvr: GNU assembler (GNU Binutils) 2.20.1.20100303
02:16:12 <hvr> well... the bug report did say that it happens on recent binutil versions
02:16:28 <gienah> hvr: maybe it might be fixed in even more recent binutil versions?
02:17:02 <hvr> maybe... no idea
02:24:02 <xpika> how do i auto indent in yi?
02:25:30 <xpika> im editing a hs file in yi with vim mode
02:28:52 <gienah> xpika: maybe this might help: http://code.google.com/p/yi-editor/issues/detail?id=243
02:29:36 <gienah> xpika: you probably need to build yi with the haddock docs enabled to try and figure stuff out
02:30:14 <gienah> xpika: and you may need to download the yi distribution to obtain the examples if they are not already installed in your yi installation
02:30:43 <hvr> can I pass additional ghc options via the cabal commandline?
02:30:52 <hvr> I'd like to set the -pgma option
02:31:48 <gienah> xpika: yi should have smart indentation since it has an incremental haskell parser
02:32:41 <gienah> hvr: personally I hack the .cabal file with sed :-)
02:33:02 <hvr> ic
02:33:32 <hvr> the good thing is, that most libraries build just fine w/ those binutils
02:33:47 <hvr> just bytestring-mmap is one of the few that makes problems
02:38:34 <xpika> gienah: it does syntax highlighting and relaces \ with lamdas but does not perform any automatic indentation like I saw on the google video
02:41:27 <gienah> hvr: i am not really sure but I get the impression it might be a ghc bug, rather than a binutils bug, it seems that as is more strict in recent versions
02:45:45 * hackagebot lhs2tex 1.17 - Preprocessor for typesetting Haskell sources with LaTeX  http://hackage.haskell.org/package/lhs2tex-1.17 (AndresLoeh)
02:47:56 <ManateeLazyCat> Good evening! :)
02:48:30 <ezyang> Good morning! 
02:48:41 <ManateeLazyCat> Hehe. :)
02:49:00 <ManateeLazyCat> Start haskell coding after work, it's exciting
02:49:28 <gienah> xpika: maybe you need to turn on the experimental haskell mode in yi
02:50:45 <gienah> xpika: modeName = "precise haskell"
02:59:56 <gienah> xpika: some user configs here are using precise mode: https://github.com/yi-editor/yi-contrib/tree/master/src/Yi/Config/Users
03:16:05 <co_dh> ##categorytheory
03:19:19 <_Ray_> So... summing up. Monads are pointed functors with join. They're functors because they map types to types. As such, they have a fmap, which takes a function from Id and "lifts" it to the functor in the monad. It's pointed because it can create instances of its type, based on instances of some other type (not only lift functions). And since it has join, once I've applied two lifted functions to an element, I can collapse that (in some way determined
03:19:19 <_Ray_>  by the monad) into one single application. Meaning, F (F a) -> F a, where F is the functor / monad.
03:20:33 <_Ray_> I still have to finish reading the typeclassopedia (specifically the monoidal structure that arises between unit / pure / return and join, and revise the notion of applicative), but that seems to be it.
03:25:20 <ziman_> well, it's not really applying two lifted functions — it's more like collapsing a value of type "monad-X in monad-X" into a value of type "monad-X", no functions involved
03:26:05 <ziman_> however, it's true that you can get the F (F a) value by applying "return" (which is not a lifted function) twice.
03:27:12 <_Ray_> you're right, I shoud have said a "twice lifted value" or something like that
03:27:58 <_Ray_> Is that all there is to monads? At least, save for the intuition that comes with practice and examples?
03:29:19 <ziman_> I cannot think of anything more I would add.
03:30:39 <_Ray_> Cool :) Now I just need to make a gazillion tiny programs that use them to get some intuition. Thanks :)
03:33:59 <ziman> In practice, we (arguably) use more the kleisli-flavoured angle of view at monads, where, instead of fmap+join, you have bind+return.
03:34:48 <ziman> They are expressible in terms of each other.
03:34:56 <mauke> fmap/join is bind
03:35:01 <mauke> you need return in both cases
03:38:17 <Kaidelong> if you require Applicative all you have to define additionally is bind
03:38:23 <Kaidelong> and >>= just becomes a method
03:38:36 <Kaidelong> err
03:38:36 <Eduard_Munteanu> Yeah, return = pure
03:38:37 <Kaidelong> not bind
03:38:38 <Kaidelong> join
03:38:41 <_Ray_> Yeah, join = (>>=) id, f >>= x = join (fmap f x)
03:41:10 <_Ray_> fmap f x = (return . f) >>= (return . x), if I'm not mistaken
03:41:20 <_Ray_> err, return x, not return . x.
03:42:24 <_Ray_> I first make f :: a -> b into an f' :: a -> M b, then I apply it with >>= to an x' :: M a. >>=, given a (a -> M b) and a M a, gives me an M b.
03:42:58 <_Ray_> (which is what fmap f x gives me)
03:44:02 <mauke> fmap f x = x >>= return . f
03:44:15 <ion> :t \f x -> x >>= return . f
03:44:15 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a -> a1) -> m a -> m a1
03:44:16 <_Ray_> hrm, seems return x is unnecessary, x is already of type M a
03:44:17 <ion> :t fmap
03:44:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:44:46 <_Ray_> yeah, save for the order of >>= I get it :)
03:44:53 <Eduard_Munteanu> But 'f' is not monadic.
03:45:23 <Eduard_Munteanu> (If it were you'd get along fine with '>>=' instead.)
03:45:48 <_Ray_> to think of it in another way, fmap f gives me a function lifted onto a monad. so by saying it's >>= return . f, I am giving >>= a semi-lifted f' (a -> M b instead of a -> b), and applying that to the value I'm passed
03:46:32 <_Ray_> bind will then join the result of the computation. so I have gone from a -> b to M a -> M b, which is what fmap f should do
03:46:35 <Eduard_Munteanu> :t (>=>)
03:46:36 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
03:47:18 <_Ray_> In any type expression the parenthesis are just for clarification, right? Meaning, the type arrows are associative?
03:47:25 <_Ray_> (Because of currying)
03:47:45 <quicksilver> no.
03:47:59 <quicksilver> (a -> b) -> c is quite a different type to a -> (b -> c)
03:47:59 <Eduard_Munteanu> Right-associative only.
03:48:28 <_Ray_> If I give an a to an (a -> b) -> c, the compiler will whine?
03:48:28 <Eduard_Munteanu> Which is more like a definition rather than a property, e.g. a -> b -> c   ==   a -> (b -> c)
03:48:42 <Eduard_Munteanu> Yes.
03:48:52 <_Ray_> Hrm. I guess it makes sense.
03:48:53 <quicksilver> _Ray_: yes, certainly. the first parameter to (a -> b) -> c needs to be a function.
03:49:16 <_Ray_> If the definition wanted an 'f' (pattern matched it), but I haven't given it an 'f', the compiler can't know what to do.
03:49:21 <_Ray_> I guess it could give me a placeholder function.
03:49:47 <quicksilver> I don't know what you're saying I'm afraid.
03:50:12 <_Ray_> Say I have g :: (a -> b) -> c, and the def of g is g f x = f x
03:50:22 <_Ray_> err, that makes little sense
03:50:29 <_Ray_> but say the pattern is 'g f x'
03:50:37 <Eduard_Munteanu> Um, that'd require arbitrary inversion of functions.
03:51:10 <_Ray_> Hrm. Right.
03:51:17 <Eduard_Munteanu> What if I said...   g (f x) = x  ?
03:51:19 <_Ray_> a -> b is different from (a -> b).
03:51:24 <quicksilver> if the definition is of the form "g f x" then 'c' must logically be a function type.
03:51:30 <Eduard_Munteanu> _Ray_: not by itself.
03:51:39 <_Ray_> One is two parameters specifically, the other associates a potentially infinite parameter list to a potentially infinite list of results.
03:51:47 <quicksilver> _Ray_: No.
03:51:54 <quicksilver> a -> b is exactly (a -> b)
03:52:07 <Eduard_Munteanu> You can't actually pattern-match on anything but constructors.
03:52:10 <quicksilver> the tricky part is that "a -> b" is not in any sense a constituent of "a -> b -> c"
03:52:36 <Eduard_Munteanu> Think of the associativity rule as sugar for writing   a -> b -> c.
03:52:54 <Eduard_Munteanu> If that rule didn't exist, you couldn't write it, but instead you had to write a -> (b -> c).
03:53:40 <_Ray_> The problem my idea had is that, suppose I wanted to curry (a -> b) -> c into a -> b -> c. That would mean that, given an a, I'd need to have a function :: b -> c. But given a b, I don't have enough information to reconstruct an a -> b, I just have two instances of types a and b.
03:53:51 <Eduard_Munteanu> Just like you can't write   3 + 4 * 2   in math without any associativity and precedence rules.
03:54:08 <quicksilver> _Ray_: you do not with to use the word 'curry' in that sentence.
03:54:11 <quicksilver> wish to use.
03:54:20 <_Ray_> Err, partially apply.
03:54:24 <_Ray_> I always get those two confused.
03:54:36 <quicksilver> but you're absolutely right to say "given an a and a b, you don't have an a -> b"
03:54:53 <quicksilver> no, that's not partial application either.
03:55:03 <quicksilver> you're simply talking about converting between two types.
03:55:04 <_Ray_> :o What's it called?
03:55:19 <quicksilver> "suppose I wanted to convert (a -> b) -> c into a -> b -> c" perhaps.
03:55:29 <_Ray_> What's the actually-possible a -> b -> c == a -> (b -> c) called?
03:55:43 <quicksilver> that is simply a defintion.
03:55:53 <quicksilver> "a -> b -> c" is defined to mean "a -> (b -> c)"
03:55:59 <quicksilver> that is the convention we choose to us.
03:56:08 <Eduard_Munteanu> @djinn ((a -> b) -> c) -> (a -> b -> c)
03:56:09 <lambdabot> f a _ b = a (\ _ -> b)
03:56:15 <quicksilver> without that convention, "a -> b -> c" would be meaningless.
03:56:17 <_Ray_> Well, that'd be a syntactical definition.
03:56:20 <_Ray_> But what about the semantics?
03:56:21 <quicksilver> yes.
03:56:37 <quicksilver> when things are defined syntactically equal, semantics has nothing to say.
03:56:40 <quicksilver> they are the same thing.
03:56:52 <_Ray_> hrm. bugger.
03:56:56 <Eduard_Munteanu> Um, I expected something else.
04:13:18 * hackagebot list-tries 0.4.1 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.4.1 (MattiNiemenmaa)
04:16:32 <zlobert> mazaRusha
04:26:22 * hackagebot Coadjute 0.1.1 - A generic build tool  http://hackage.haskell.org/package/Coadjute-0.1.1 (MattiNiemenmaa)
04:28:24 <ski> _Ray_ : the pragmatical reasoning is that it is more common (in Haskell) to want to express `a -> (b -> c)' than to express `(a -> b) -> c', so it is the former of those which gets to use the shorthand notation `a -> b -> c'
04:29:00 <hpc> ski: more common in any language, i would think
04:29:15 <hpc> how often do you see people throwing continuations to every function they see
04:29:45 <ski> _Ray_ : contrast this with the pragmatic reasoning for choosing `c ^ b ^ a' in math to mean `c ^ (b ^ a)' rather than `(c ^ b) ^ a', because the latter can already be expressed equivalently as `c ^ (a * b)'
04:31:37 <ski> (note that the type `a -> (b -> c)' is isomorphic to `(a,b) -> c' (or `(b,a) -> c'), so `a -> (b -> c)' can "already be expressed in the uncurried way", but still we prefer this to get the shorthand notation, because this is more common (and the syntax for application, as well as opportunity for partial application, encourages it))
04:32:19 <ski> hpc : i think i've seen logicians who by `A -> B -> C' meant `(A -> B) -> C'
04:32:53 <hpc> as in "(A implies B) implies C"?
04:32:57 <hpc> that might make more sense
04:33:25 <ski> yes, with `->' being implication
04:33:44 <ski> presumably the rationale here was similar to the math one for `c ^ b ^ a'
04:34:54 <hpc> if you meant the other, you would say "A /\ B -> C", yes?
04:35:01 <ski> indeed
04:35:12 <hpc> groovy
04:35:22 * hpc is getting the hang of this theory stuff
04:36:05 <ski> hence one often says `forall x,y. P x /\ x =< y => P y' rather than `forall x,y. x =< y => (P x -> P y)', to express that the property `P' is monotone/upper
04:36:29 <ski> (which i think that in many cases the latter formulation is more esthetically pleasing)
04:36:37 <ski> (s/which/while/)
04:37:56 <ski> often, it seems that theorems arise as questions from these kind of "
04:38:00 <ski> trivial" rewritings
04:38:23 <hpc> indeed
04:38:40 <ski> like, we know `A /\ B -> C', which is the same as `A -> (B -> C)', is it then provable that `A -> (B <- C)' so that we get `A -> (B <-> C)'
04:38:43 <ski> ?
04:40:46 <ski> e.g. if you consider transitivity `forall x,y,z. x =< y /\ y =< z -> x =< z', this can be expressed as `forall y,z. y =< z -> (forall x. x =< y -> x =< z)'
04:40:55 <hpc> we would know that A /\ C' -> B'
04:41:10 <ski> this raises the question : how about `forall y,z. y =< z <- (forall x. x =< y -> x =< z)' ?
04:41:22 <ski> and indeed, that can be proven, using reflexivity
04:41:34 <hpc> wait, we can prove that?
04:41:44 <hpc> the a -> (b <- c) thing
04:42:25 <ski> and so we can prove `y =< z' by proving the "more complicated" `forall x. x =< y -> x =< z', which is often a useful/practial proof strategy :)
04:42:48 <ski> hpc : take arbitrary `y',`z'
04:42:48 <hpc> also, i am confused by your use of =< and =>
04:43:27 * ski used no `=>' here
04:43:38 <ski>   then assume `forall x. x =< y -> x =< z'
04:43:39 <hpc> up above you did
04:43:59 <ski>   therefore, instantiating `x' to y`, we know `y =< y -> y =< z'
04:44:08 <ski>   we know `y =< y' by reflexivity
04:44:13 <ski>   hence `y =< z'
04:44:15 <ski>   QED
04:44:48 <rostayob> I've got a 125£ vaucher from cambridge press. Any suggestions oh haskell/functional programming books? I'm already "ordering programming in haskell"
04:44:57 <ski> hpc : yeah, i used it above when talking about monotonicity/upper, i think because mathematicians more often write `=>' than `->' for implication
04:45:00 <hpc> rostayob: lyah!
04:45:12 <hpc> (if cambridge press has it)
04:45:26 <hpc> so => = ->
04:45:31 <ski> but then i was thinking that in ascii, it might be harder to read, with lots of `=<' and `=>' symbols in the transitivity, so i changed to `->' then
04:45:40 <rostayob> hpc: what's that?
04:45:47 <hpc> learn you a haskell?
04:45:52 <hpc> it has a book now
04:46:24 <ski> (btw, i think that Prolog's choice of `>=' and `=<' for the non-strict comparision operators is superior to Haskell's (and others) choice of `<=',`>=')
04:46:25 <rostayob> hpc: oh... I don't know if I need that, isn't it an haskell introduction?
04:46:36 <hpc> it's still awesome
04:47:08 <rostayob> hpc: yeah but I wouldn't use it :P
04:47:11 <Xilon> rostayob: It's available online, check it out. I wouldn't bother getting it in physical form though
04:47:26 <ski> rostayob : hm, possibly "Purely Functional Data Structures', if cambridge press carries that
04:47:33 <rostayob> ski: I already have that
04:47:38 <ski> ok
04:47:44 <rostayob> (great book anyway)
04:47:57 <rostayob> "Pearls of Functional Algorithm Design", this looks good...
04:48:37 <ski> (my granma got a book voucher, but wasn't that interested in using it for herself, so wondered if i wanted any book, and i suggested that one, which was promptly shipped :)
04:49:13 * ski has "Pearls of Functional Algorithm Design" borrowed, and has looked a little bit in it ..
04:49:41 <rostayob> ski: actually the same is happening with me, my grandfather refereed someone and got that :P
04:50:04 <ski> hpc : did you follow my proof above ?
04:50:13 <ski> rostayob :)
04:50:56 <rostayob> ski: so would you suggest pearls of functional etc.? I'd never buy a 60£ book normally but I can now!
04:51:12 <errantventure> why buy?
04:51:52 <rostayob> errantventure: mh?
04:52:06 <errantventure> say again?
04:52:18 <ski> hpc : anyway, consider another rewriting of transitivity : `forall x,z. (exists y. x =< y /\ y =< z) -> x =< y'. this formulation suggests asking `forall x,z. (exists y. x =< y /\ y =< z) <- x =< y'. this can't be proved for (e.g.) all partial orders, but expresses the property of an order that it is `dense' (and usually we rename `=<' to `<', as well as require irreflexivity (and probably anti-symmetry), as well, then)
04:52:53 <rostayob> errantventure: I have a voucher to spend
04:53:06 <errantventure> go for it then
04:53:29 <errantventure> otherwise, programming textbooks are probably one of the easiest things to pirate out there
04:53:53 <ski> rostayob : i don't think i can judge yet whether i'd want to buy this book. the book contains many studies of special problems, with some general remarks and strategies baked into the text (as opposed to also trying to draw also a more general picture, which i was thinking it would do, initially)
04:54:02 <ion> Purely functional data structures? As in pair a b = \f -> f a b; first p = p (\a _ -> a); second p = p (\_ b -> b)?
04:54:23 <sipa> @pl \x -> f x (g a) <= b
04:54:23 <lambdabot> (<= b) . flip f (g a)
04:54:29 <sipa> @pl \x -> f (g a) x <= b
04:54:29 <lambdabot> (<= b) . f (g a)
04:54:32 <rostayob> errantventure: I can't really read on scren for more than 15 mins
04:54:43 <rostayob> ski: ok, I see
04:54:49 <ski> ion : "Purely Functional" is better rephrased as "non-mutating" (since it doesn't have very much to do with *functions*)
04:55:01 <ion> ah
04:55:04 <errantventure> fair enough
04:55:05 <ski> rostayob : i'm not saying it's not interesting, note
04:55:44 <errantventure> just outta curiosity, if you can't log more than 15 min of screen time, how do you expect to do much programming?
04:57:06 <rostayob> errantventure: programming /= reading 50 pages of text...
04:57:22 <errantventure> point taken
04:57:37 <ski> ion : so, a "folklore" example is implementing the queue datastructure as `data Queue a = Q {front :: [a] , back :: [a]}', where a queue `[0,1,2,3]' can be represented as any of `Q [0,1,2,3] []',`Q [0,1,2] [3]',`Q [0,1] [3,2]',`Q [0] [3,2,1]',`Q [] [3,2,1,0]', provoding amortized `O(1)' `get' and `put' operations
04:58:35 <ion> aye
04:59:31 <rostayob> ski: that book is great (purely functional data structures)
05:01:24 <ski> rostayob : yeah :)
05:02:18 <rostayob> other suggestions?
05:02:57 <ski> TaPL is good, if you're into understanding type systems
05:03:48 <ski> i've heard SICP,EoPL recommended, but i've not read them yet (only browsed some)
05:04:03 <ski> CtM is good (but thick and heavy :)
05:04:29 <rostayob> ski: those are all MIT! eheh
05:05:02 <rostayob> ski: what's CtM?
05:05:10 <ski> @where CtM
05:05:10 <lambdabot> http://www.info.ucl.ac.be/~pvr/book.html
05:05:35 <ezyang> I have a copy by my bedside. It's a nice, light read. 
05:05:41 <ezyang> (well, for certain definitions of "light") 
05:06:05 <ski> @where+ CtM "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
05:06:05 <lambdabot> Done.
05:06:17 <maxJadi> Is it possible to convert a "ByteString" type to "Enumerator ByteString m b" type ? 
05:06:19 <rostayob> the problem is that none of those is cambridge press :P
05:07:54 * ski has little awareness of which publisher various books are published at
05:11:18 <rostayob> ski: yeah of course, I'm just disappointed ehe
05:24:18 <duairc> Can anybody tell me why exactly this terminates early? foldr (||) False (True:repeat False)
05:24:32 <duairc> I presume there's something about the definition of (||) that allows it to do so
05:24:44 <ezyang> || is lazy. 
05:24:53 <ezyang> > True || (error "bang!") 
05:24:53 <lambdabot>   True
05:24:59 <ezyang> > False || (error "bang!") 
05:25:00 <lambdabot>   *Exception: bang!
05:25:07 <ezyang> > (error "bang!") || True 
05:25:08 <lambdabot>   *Exception: bang!
05:25:51 <ski>      foldr (||) False (True : repeat False)
05:26:15 <ski>   =  True || foldr (||) False (repeat False)
05:26:15 <ski>   =  True
05:26:20 <ski> is basically how that evaluates
05:26:25 <ski> duairc : ^
05:26:36 <ski> @src (||)
05:26:36 <lambdabot> True  || _ =  True
05:26:36 <lambdabot> False || x =  x
05:26:42 <ski> @src foldr
05:26:42 <lambdabot> foldr f z []     = z
05:26:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:27:31 <ski> (and recall that function arguments are not evaluated (in general), prior to calling the function)
05:28:06 <duairc> ski: aha, yes, that's what I was missing (seeing how it would look after the first step). So it also depends on the definition of foldr. Okay... specifically what I'm trying to do is a fold over a ByteString from which I want to terminate early; I don't think ByteString's foldr allows me to do that in the same way
05:29:36 <ion> The result of function f depends on the definition of function f, yes. :-)
05:29:36 <ski> possibly not (at least for strict bytestrings), but i'm not sure
05:30:50 <duairc> ion: I know, I wasn't really thinking hard enough, I was just sort of like "foldr does magic with laziness so that it can terminate early", and I kind of presumed that would work for all foldrs. Silly in retrospect.
05:31:01 <Jafet> Hm, how do you do (||) with lub
05:31:10 <Jafet> I can't remember
05:31:21 <Mackleficent> Anyone in here know of learning material similar to "The Haskell Road to Logic, Maths, and Programming"? It seems to be quite outdated now.
05:33:41 <byorgey> Jafet: use parCommute
05:40:43 <Mackleficent> Also, admins--
05:40:47 <Mackleficent> *ops
05:41:30 <Mackleficent> the tunes.org link at the end of the topic gives me a 404
05:41:47 <FauxFaux> Mackleficent: Stop failing at speechmarks.
05:42:02 <Mackleficent> *you* stop failing
05:42:16 <ezyang> Anyone have a copy of TAPL 'round? I have a question about Lemma 15.3.6. 
05:42:16 <Mackleficent> I'm on freenode's webchat.
05:42:32 <imc> hello great people!
05:42:33 <byorgey> ezyang: I do. what's the question?
05:42:45 <FauxFaux> Mackleficent: Perhaps you should report a bug in that.
05:42:46 <Mackleficent> FauxFaux: What do you mean?
05:43:03 <Mackleficent> ...you're mocking me, ok. Very helpful.
05:43:08 <FauxFaux> Mackleficent: It's not a 404; I'm guessing you've opened it with a ``"'' at the end.
05:43:13 <Mackleficent> I did
05:43:20 <FauxFaux> It doesn't have a " at the end.
05:43:21 <imc> I'm looking for a way to embed a ghci-like shell in my program... the "Interactive Example" does not compile as the PackageConfig module cannot be found... any idea?
05:43:24 <ezyang> byorgey: The first part states that if v is a closed value of type T_1 -> T_2, then v has the form \x : S_1 -> t_2. It seems to me that there's a subtype relation missing between T_1 and S_1. 
05:43:28 <Mackleficent> The hyperlink does.
05:43:44 <FauxFaux> The topic is in Haskell list style.
05:43:45 <ezyang> But I'm not sure. 
05:44:33 <Mackleficent> Well, that's a pity. It breaks webchat's hyperlinks.
05:44:48 <byorgey> ezyang: I think you're right that you could add such a subtype relation to the statement of the lemma and it would still be true.
05:44:49 <ezyang> And I checked the errata and there is a correction for part (2), so ostensibly someone's looked at this definition carefully in the recent past :-) 
05:45:06 <byorgey> ezyang: but since it's only used in the proof of progress (I think) it doesn't really matter whether there's a relationship between S1 and T1.
05:45:27 <byorgey> you just need to know that it has the right shape so an application can take a step by beta-reduction.
05:45:29 <ezyang> Ah, I see. Yeah, I guess it's not too hard to prove the weaker form. I guess I need to convince myself this is ok for tProgress. 
05:45:37 <ezyang> Hmm. 
05:45:47 <ezyang> Oh, that is quite curious. 
05:46:28 <byorgey> what is?
05:47:29 <ezyang> I always imagined the Progress proof w/ subtyping to need to have some special machinery for the T-App case, but I guess if you just do the substitution a later invocation of T-Sub will do the trick. 
05:47:54 <ezyang> The use of induction seems a bit free-wheeling, but I guess it does work. 
05:48:24 <byorgey> progress doesn't care much about types.
05:49:03 <byorgey> yes, I see what you mean about a later invocation of T-Sub.
05:49:36 <byorgey> well, in particular, *evaluation* doesn't care at all about types.  It just does the same old beta-reduction and so on as always.
05:49:43 <byorgey> it's up to the type system to keep up.
05:50:09 <byorgey> If I'm not making sense feel free to ignore me =)
05:50:17 <ezyang> Yeah, I was thinking, "Progress doesn't work if you don't have well-typed terms..." 
05:50:22 <ezyang> No, that sounds fair. 
05:51:23 <byorgey> right, progress says that if you *start* with a well-typed term then you can take an evaluation step -- but you might have complete garbage after taking that step!
05:52:08 <ezyang> ...oh, that's why we have Safety, isn't it? 
05:52:55 <ezyang> I'd love to see a semantics that has progress and type preservation, but not safety. I think that's not possible. 
05:53:34 <byorgey> no, that's the point.  progress + preservation = safety.
05:53:56 * ezyang nods 
05:54:00 <Eduard_Munteanu> Mm, progress and preservation are quite formal, but safety?
05:54:34 <ezyang> Oh, I see! That's why my proof of Progress doesn't actually reference any of the new subtyping rules. 
05:54:44 <ezyang> (besides T-Sub) 
05:54:49 <byorgey> by "safety" is usually meant "if well-typed term t can take multiple steps to a normal form, then that normal form is a value".
05:55:03 <byorgey> i.e. "well-typed programs don't go wrong"
05:55:15 <imc> right, cabal install hint (for Language.Haskell.Interpreter) should be fine for me
05:55:23 <Eduard_Munteanu> Hm, I see.
05:55:27 <byorgey> ezyang: right.  That's preservation's job.
05:55:37 <ezyang> Cool proof modularity :-) 
05:55:41 <byorgey> exactly =)
05:55:52 <ezyang> Unrelatedly, how do people go about picking exercises to do when self-studying? 
05:55:59 <ezyang> (when there are no recommended ones) 
05:56:46 <byorgey> I usually just do them all, but feel free to skip one as soon as I sense that it will be boring and/or easy
05:56:49 <Eduard_Munteanu> I recently felt in the mood of writing Haskell proofs and I picked the existential -> universal quantifier conversion as a theorem :)
05:57:42 <ziman> @hackage hint
05:57:42 <lambdabot> http://hackage.haskell.org/package/hint
05:57:44 <byorgey> Eduard_Munteanu: nice =)
05:58:45 <ezyang> Hmm, not a bad idea, I guess. I always feel like there are too many exercises :-) 
05:59:44 <wferi> Hi! I've got a rather strange problem with the timeplot package:
06:00:00 <wferi> tplot's termination depends on the name of the input file.
06:00:27 <wferi> this terminates: tplot -if or.log -tf 'date %b %e %T' -o overruns.png -k 'overrun' 'sum 10'
06:00:41 <wferi> this does not terminate: tplot -if overruns466. -tf 'date %b %e %T' -o overruns.png -k 'overrun' 'sum 10'
06:01:00 <wferi> but gobbles up all available memory and spins indefinitely
06:01:17 <wferi> or.log is a symlink to overruns466.log
06:01:20 <wferi> (typo above)
06:02:01 <wferi> the symlink isn't the point, a copy serves just as well.
06:02:20 <wferi> ghc 6.12.1
06:02:30 <wferi> anybody seen anything similar?
06:02:37 <Axman6> how very strange
06:04:11 <wferi> I've got no good idea how to start debugging this...
06:05:04 <Axman6> wferi: well, the least you can do is fine the edge cases for when it failes
06:05:19 <wferi> Ah yes, I did.
06:05:24 <Axman6> so maybe foo.log works, but foo1.log doesn't, then that's something you can tell the delevopers
06:06:26 <wferi> there's always a limit on line count, under which it works, over which it does not.
06:07:05 <wferi> The limit itself depends on the file name... :)
06:07:42 <Jonno_FTW> > 0x7FDE623822FC16E6
06:07:42 <lambdabot>   9213909880891250406
06:07:56 <wferi> is Eugene Kirpichov present on this channel?
06:11:02 <fryguybob> ezyang: Choosing exercises is an exercise left to the reader.
06:12:00 <Athas> Why have functional dependencies fallen out of favor?
06:12:00 <lambdabot> Athas: You have 1 new message. '/msg lambdabot @messages' to read it.
06:12:58 <Axman6> Athas: have they?
06:15:40 <Athas> Axman6: it appears that libraries that make use of them are being phased out (to be replaced by type family-based ones, it seems).
06:15:55 <Axman6> fair enough
06:27:32 <Kaidelong> belatedly
06:27:47 <Kaidelong> (a,b) does in fact prove (a -> b)
06:27:57 <Kaidelong> unlike what was suggested above
06:28:40 <byorgey> @type const . snd
06:28:41 <lambdabot> forall a b a1. (a1, a) -> b -> a
06:28:42 <Kaidelong> @ty const . snd :: (a,b) -> (a -> b)
06:28:43 <lambdabot> forall a b. (a, b) -> a -> b
06:29:14 <Kaidelong> I had some message to that effect in the buffer but got occupied elsewhere
06:29:16 <edon> json library from the json package doesn't escape " and ' ?
06:29:47 <ziman> @djinn (a,b) -> a -> b
06:29:47 <lambdabot> f (_, a) _ = a
06:30:33 <byorgey> Kaidelong: indeed, although in a rather uninteresting way of course!
07:01:07 <tawe> @src foldr
07:01:07 <lambdabot> foldr f z []     = z
07:01:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:01:20 <tawe> @src foldl
07:01:20 <lambdabot> foldl f z []     = z
07:01:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:28:44 <amed_> hellow
07:28:53 <Ptival> hello
07:29:04 <amed_> i have a problem with church numerals
07:29:16 <amed_> somebody help me?
07:29:33 <mauke> difficult if you don't ask a question
07:29:36 <Axman6> amed_: not if you don't tell us what the problem is
07:29:54 <amed_> i have this error ERROR - Cannot find "show" function for: *** Expression : test *** Of type    : (a -> a) -> a -> a
07:30:39 <Axman6> that's right, there is no way to show functions in haskell
07:31:00 <tromp__> try printing church succ 0 instead
07:31:37 <amed_> wait
07:31:53 <roconnor> Survey time: Does Applicative generalize Functor or does Applicative specialize Functor?
07:32:26 <amed_> I can paste code here?
07:32:33 <tromp__> i thought specialize
07:32:33 <Axman6> @where hpaste
07:32:34 <lambdabot> http://hpaste.org/
07:32:40 <amed_> tks
07:33:02 <Axman6> roconnor: well, all Applicatives are Functors, but not the other way, so it's a specialisation no?
07:33:56 <roconnor> sounds fair
07:36:28 <amed_> my code http://hpaste.org/44842/churchhs
07:40:18 <amed_> tromp__: ?
07:40:19 <Boxo> fmap f x = pure f <*> x
07:41:42 <tromp__> you cannot print church numerals, since they're functions
07:41:54 <tromp__> you have to unchurch before printing
07:42:49 <amed_> tromp__: then, as I print the numbers?
07:43:03 <roconnor> \church -> church (print "S">>) (print "O")
07:43:37 <Boxo> nice
07:44:31 <roconnor> \church -> church (putChar 'S' >>) (putChar 'O')
07:44:32 <tromp__> churchtostring n = n ('S':) "0"
07:45:32 <amed_> tromp__: n is a integer?
07:45:50 <tromp__> n is a church numeral
07:46:45 <tromp__> :t \n -> n ('S':) "0"
07:46:46 <lambdabot> forall t. (([Char] -> [Char]) -> [Char] -> t) -> t
07:46:55 <Axman6> roconnor: don't you want purStr?
07:47:11 <roconnor> I did
07:47:14 <Axman6> or putChar as you said later, mevermind me
07:47:50 <amed_> Main> churchtostring two "SS0"
07:48:44 <roconnor> tromp__: now let's do base 10 conversion using church encodings
07:52:07 <geheimdienst> has anyone been able to compile the current network-2.3.0.2 on hackage? with ghc-7.0.2, i mean
07:52:14 <geheimdienst> i'm getting Ambiguous occurrence `closeFdWith': It could refer to either `Network.Socket.closeFdWith' or `GHC.Conc.closeFdWith'
07:54:49 <wferi> well, I'm down to a single putStr "" change in timeplot: if I uncomment it, the command does not terminate anymore.
07:55:06 <WatermelonStorm> A question. How would I parse a messages from a server handle in the format "\x00" ++ message ++ "\xFF"?
07:55:10 <WatermelonStorm> It's a websocket-like protocol.
07:55:19 <WatermelonStorm> In that aspect.
07:55:49 <Axman6> is \x)) a literal string or a byte value?
07:56:04 <WatermelonStorm> A byte value. 
07:56:05 <amed_> mmm i don't undertanding very well i'm newbie
07:56:11 <WatermelonStorm> It's 0x00, the message and then 0xff.
07:56:30 <Axman6> use something like Data.Binary then
07:57:07 <Axman6> if it's network data, you might prefer to use attoparsec
07:57:20 <WatermelonStorm> Actually, I found an implementation of what I want in the websockets module.
07:58:04 <Axman6> s/module/package?
07:58:20 <WatermelonStorm> Yes.
07:58:26 <WatermelonStorm> I'm relatively new to Haskell...
07:58:53 <kmc> modules are the things you "import"
07:59:01 <WatermelonStorm> Yup, kmc.
07:59:01 <kmc> packages are collections of modules, and are the things you cabal-install
07:59:04 <WatermelonStorm> And the websock--
07:59:09 <WatermelonStorm> Yes.
07:59:35 <rpglover64> I seem to be having trouble catching the "Prelude.read: no parse" exception; any advice?
07:59:54 <rpglover64> (other than "don't"?)
08:00:12 <wferi> rpglover64: isn't reads an option?
08:00:14 <kmc> don't
08:00:25 <rpglover64> it is
08:00:26 <kmc> also, you're probably not forcing evaluation within the scope of your catch
08:00:31 <rpglover64> and I'm probably going to use it
08:00:39 <kmc> that's why we have Control.Exception.evaluate
08:00:56 <kmc> also you can use 'spoon'
08:01:06 <rpglover64> i don't want to use spoon
08:01:42 <rpglover64> (I also can't install packages; I have to stick to the haskell platform that uses ghc 6.10.4)
08:02:00 <kmc> urk
08:02:11 <rpglover64> kmc: yeah...
08:03:06 <rpglover64> http://hpaste.org/44843/i_cant_read
08:03:17 * hackagebot msgpack 0.6.0.1 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.6.0.1 (HideyukiTanaka)
08:05:06 <rpglover64> kmc: evaluate doesn't seem to be doing it (and neither is "mapM evaluate", since the thing I'm returning is a list)
08:06:53 <kmc> evaluate forces only to weak head-normal form
08:07:04 <kmc> it forces until the outermost constructor is produced
08:07:08 <kmc> so is that enough to trigger your error?
08:07:09 <mattyb> Hey folks, I keep getting this: "Make has restarted itself 3 times; is there a makefile bug?" when building GHC. I checked the Troubleshooting doc, and I haven't modified anything during the build. I'm just trying to get GHC to build successfully. Any ideas?
08:07:15 <rpglover64> apparently not
08:07:44 <kmc> do you have Control.DeepSeq?
08:07:52 <kmc> evaluate (foo `deepseq` ())
08:07:59 <kmc> anyway you should use reads ;P
08:08:31 <rpglover64> I got it!
08:08:41 <rpglover64> (strict data fields ftw)
08:08:52 <kmc> "read" is just a bad function
08:09:16 <rpglover64> and now i will try to refactor to use reads
08:09:18 <rpglover64> thank you
08:09:21 <kmc> :)
08:17:03 <frank00> is it possible to pattern match inside guard conditions?
08:19:23 <Axman6> if you turn on pattern guards it is: foo x | Just y <- x = y + y
08:20:58 <frank00> thanks
08:24:42 <Yrogirg> Hello! I get "parse error on input `mult'" in http://hpaste.org/44844/infixl What's wrong?
08:25:50 <lowasser> It should be
08:25:52 <monochrom> replace "(mult)" by "mult"
08:25:56 <lowasser> mult :: Double -> Double -> Double
08:25:56 <lowasser> mult = (*)
08:25:57 <lowasser> yeah
08:33:52 <Yrogirg> http://hpaste.org/paste/44844/infixl_annotation#p44845 doesn't work either
08:37:43 <astory> how can I get all but the last element of a list?  All I've got now is take (length l - 1) l
08:38:30 <Jafet> > last [1..10]
08:38:31 <lambdabot>   10
08:38:35 <Jafet> Oh
08:38:45 <astory> yeah, I want everything that last didn't give me
08:38:53 <solarus> > init [1..10]
08:38:54 <lambdabot>   [1,2,3,4,5,6,7,8,9]
08:39:04 <astory> thanks!  I thought init only worked on lists of lists
08:39:12 <kmc> > init []
08:39:12 <Jafet> > inits [1..5]
08:39:12 <lambdabot>   *Exception: Prelude.init: empty list
08:39:12 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
08:39:33 <astory> ah, I see
08:39:42 <Jafet> @vixen does take (length l - 1) l looks thrashy to you?
08:39:42 <lambdabot> what about me?
08:39:53 <kmc> lists aren't a great data structure for this operation
08:40:00 <astory> yeah, but mine are short
08:40:33 <kmc> fair enough
08:41:09 <kmc> Data.Sequence lets you pattern-match at both ends
08:43:49 <Yrogirg> so does anyone have a short working example with declaring infix functions?
08:44:39 <monochrom> Yrogirg: infixl 7 `mult`
08:45:54 <kmc> that's not necessary, though
08:45:59 <kmc> only if you want to change precedence
08:46:04 <kmc> Yrogirg, can you be more specific?
08:46:17 <kmc> any ordinary function name can be used infix with backticks
08:46:19 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009 has a lot of short working examples of everything
08:48:44 <monochrom> oh ha, even that is wrong
08:52:00 <Yrogirg> Essentially the prelude variant of ||  http://hpaste.org/44846/infixr
08:52:00 <Yrogirg> and I still get "parse error on input `or''"
08:52:25 <monochrom> infixr 2 `or'`
08:52:43 <monochrom> True `or'` _ = True
08:52:45 <monochrom> etc
08:55:02 <Yrogirg> but there was a way to use infix functions without ` `
08:55:46 <kmc> if you name your function using punctuation, then it's infix by default
08:55:51 <Yrogirg> at least prelude functions can be declared to work without ` ` (e.g. || && + - *)
08:56:09 <monochrom> > "or" == "||"
08:56:09 <lambdabot>   False
08:56:14 <monochrom> does that help?
08:56:36 <kmc> True ||| _ = True
08:56:40 <kmc> (|||) True _ = True
08:56:43 <kmc> either style works
08:57:12 <Jafet> > let a == b = unsafePerformIO $ randomRIO (False, True) in "or" == "||"
08:57:13 <lambdabot>   Not in scope: `unsafePerformIO'
08:57:54 <geheimdienst> > True `(||)` False
08:57:54 <lambdabot>   <no location info>: parse error on input `('
08:59:22 <djahandarie> > let f = (||) in True `f` False
08:59:22 <lambdabot>   True
09:00:52 <Yrogirg> kmc >if you name your function using punctuation, then it's infix by default
09:00:52 <Yrogirg> and how do you prescribe priority of that infix operation in such case?
09:01:06 <kmc> infixl 7 |||
09:01:58 <Yrogirg> so
09:01:58 <Yrogirg> infixl 7 |||
09:01:58 <Yrogirg> ||| :: Bool -> Bool -> Bool
09:01:58 <Yrogirg> True  ||| _  =  True  
09:01:58 <Yrogirg> False ||| x  =  x
09:01:59 <Yrogirg> must work?
09:04:36 <aristid> Yrogirg: no, it should be (|||) :: Bool -> Bool -> Bool
09:05:04 <aristid> because there, you use it like a function. in the other positions you use it like an operator.
09:05:12 <monochrom> http://hpaste.org/44847/two_infix_examples
09:05:17 <Yrogirg> oh, thank you
09:12:18 <Skola> during cabal install Happstack I get this
09:12:20 <Skola> ghc: 
09:12:20 <Skola> unknown symbol `_rtsTimerSignal'
09:12:20 <Skola> Loading package unix-2.4.2.0 ... linking ... ghc: unable to load package `unix-2.4.2.0'
09:12:54 <kmc> are you running on some godawful ancient linux distribution, e.g. RHEL 4?
09:13:02 <Skola> macosx
09:13:21 <Jafet> Heh
09:13:38 <Skola> <command line>: cannot satisfy -package Cabal-1.8.0.6: 
09:13:38 <Skola>     Cabal-1.8.0.6-ec9be469687b5a514f4b7e8e2b8343c7 is unusable due to missing or recursive dependencies:
09:13:38 <Skola>       containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379
09:13:39 <Skola>     (use -v for more information)
09:13:39 <Skola> cabal: Error: some packages failed to install:
09:13:39 <Skola> happstack-6.0.0 depends on network-bytestring-0.1.3.4 which failed to install.
09:23:36 <edwardk> djahandarie: i'm looking to put together another boston haskell towards the end of this month, but my other speaker hasn't finished his project. open to suggestions
09:24:59 <edwardk> i talked to ddarius though, and he expressed willingness to dive into fibrations, so we might have a fairly categorical session instead
09:30:52 <kmc> edwardk, is your other speaker me? ;)
09:31:08 <geheimdienst> your speaker is in the other castle
09:31:30 <kmc> edwardk, i could present about hdis86
09:31:48 <kmc> just a short talk about how to make FFI bindings that feel like native Haskell libs
09:36:22 <amedxy> hellow
09:40:44 <kafee> hi, i have a question that's buggin me
09:41:12 <kmc> sure, go ahead and ask :)
09:41:53 <kafee> i have the x server, i have a gui toolkit, let's say gtk, what does it do to, let's say, show a windows on the screen?
09:42:15 <kafee> under the hood
09:42:39 <kmc> X is based on a client/server protocol
09:42:48 <kmc> GTK will send some X messages to the X server over probably a UNIX socket
09:42:50 <aristid> use xlib to talk to the x server to tell it to draw the damn window?
09:43:03 <kmc> xlib is a client library for said protocol
09:43:10 <amedxy> hellow
09:43:12 <kmc> i don't know whether GTK uses it or whether it talks the X protocol directly
09:43:14 <kmc> hi amedxy
09:43:48 <kafee> is some sort of pixel manipulation?
09:44:08 <mauke> no, it's sockets
09:44:19 <kmc> the client talks to the X server using a network protocol
09:44:21 <kafee> what does the x does to print the window
09:44:27 <kafee> yeah
09:44:30 <kmc> kafee, depends on your graphics hardware
09:44:35 <kafee> then the x...
09:44:38 <kmc> writes to some memory, makes a DMA request to the card, etc.
09:44:39 <mauke> what the server does depends on the server
09:44:48 <amedxy> kmc hpaste.org is up?
09:44:55 <mauke> it could call the windows api, for example :-)
09:45:04 <kmc> your X server might be a VNC server in which case it will buffer those pixels until the next VNC client request
09:45:07 <kmc> (or push them, don't recall)
09:45:19 <kafee> yeah
09:45:24 <kmc> your X server might be Xnest in which case it passes those requests on to the outer X server
09:45:46 <kafee> what about a toolkit based in, let's say, arrows
09:45:49 <kmc> on Linux the X server is given special privileges by the kernel, such that it can talk to the graphics hardware more directly
09:45:52 <monochrom> hpaste.org is up
09:45:57 <kafee> like fruit
09:46:10 <monochrom> they just call gtk or something
09:46:11 <kafee> does it work similary to gtk
09:46:32 <kmc> amedxy, i don't do PM; please ask questions in the channel
09:46:44 <amedxy> ok
09:46:47 <amedxy> http://hpaste.org/44848/church2
09:46:51 <amedxy> this is my code
09:46:55 <nickela> how imrove look this Data.List.Split.splitWhen analog:
09:46:57 <nickela> myspl p xs = uncurry (++) $ second return $ runState (foldM (\a b-> if p b then get >>= \c -> put [] >> return (a++[c]) else modify (++[b]) >> return a) [] xs) []
09:47:03 <amedxy> i can't use bool operator
09:47:48 <amedxy> as print IZZERO values​​?
09:47:56 <amedxy> as print IsZERO values​​?
09:48:42 <pumpkin> all this church recently must mean there's some school assigning it?
09:48:47 <amedxy> and how to print values of my exp func?
09:49:06 <amedxy> pumpkin: is a exercise
09:49:11 <pumpkin> from what school?
09:49:19 <amedxy> pumpkin: personal
09:49:38 <pumpkin> I thought I saw someone else asking the exact same thing a few hours ago
09:49:45 <Axman6> you did
09:49:47 <amedxy> pumpkin: i'm
09:51:01 <amedxy> pumpkin: although I'm not asking the same thing
09:51:39 <amedxy> this is my new code http://hpaste.org/44848/church2
09:51:43 <pumpkin> oh it was you
09:51:56 <djahandarie> edwardk, I see. I wouldn't mind something categorical :)
09:52:51 <amedxy> pumpkin: can u help me?
09:53:02 <djahandarie> Though I'd probably want to read up on fiberations before listening to ddarius's talk...
09:53:18 <edwardk> kmc: that'd work
09:53:32 <edwardk> kmc: then i can have derek do the other talk, and we're all set.
09:53:53 <kmc> cool, what's the other talk?
09:54:00 <kmc> fiberations?
09:54:12 <edwardk> sounds like an introduction to fibrations, probably with code
09:54:13 <djahandarie> fibrations* btw :P
09:54:16 <kmc> cool
09:54:20 <kmc> i like code
09:54:22 <djahandarie> Code!
09:54:24 <kmc> (Agda code?)
09:54:36 <kmc> we should have a Boston Agda meetup
09:54:41 <djahandarie> I didn't even know ddarius writes code
09:54:42 <pumpkin> with three people there? :P
09:54:43 <edwardk> not sure, you'd have to ask derek
09:54:48 <edwardk> i'd show up
09:54:56 <kmc> instead of going for beers afterward we'd have to drop acid
09:54:57 <pumpkin> sounds good to me
09:55:02 <edwardk> for 3 people, i might even fund snacks ;)
09:55:03 <djahandarie> Hahaha
09:55:18 <kmc> Fear and Loathing in the Stata Center
09:55:41 <amedxy> kmc: can u help me?
09:58:23 <edwardk> kmc: can you talk to derek and see what night works best for you two? then i'll follow up with nirav to get us the room
09:58:45 <kmc> any weekday night is ok for me
09:59:10 <kmc> any weekday night where no vendor plans to release a Linux kernel is better
09:59:14 <kmc> but those are harder to predict ;)
09:59:17 <edwardk> =)
09:59:33 <edwardk> k, then i'll follow up with derek
09:59:34 <kmc> amedxy, by the way, did you see the HLint hints on your paste?
09:59:36 <monochrom> they don't release linux kernels at night
09:59:53 <edwardk> monochrom: the nature of his job is more about managing what happens after the release
10:00:15 <kmc> yeah, if there's some particularly nasty patch it can take us a little while to get it ready to build
10:00:40 <kmc> actually, which week?
10:01:02 <amedxy> i don't have errors to execute
10:01:14 <edwardk> if i had to guess probably around 3/30 or 4/1
10:01:36 * djahandarie requests 4/1
10:01:38 <edwardk> that would give us two weeks notice
10:01:40 <edwardk> k
10:01:45 <kmc> april fools :D
10:01:56 <edwardk> dangerous day to give talks
10:02:09 <djahandarie> Yeah, we can say it's Boston Haskell and troll everyone, and it's actually Boston Agda
10:02:10 <kmc> ok my preference is not 3/24, 3/25, 4/3, or 4/4
10:02:18 <kmc> djahandarie, please.  Boston Java meetup
10:02:22 <edwardk> k
10:02:30 <kmc> (those dates are probably fine too; it's not a particularly strong requirement)
10:02:36 <djahandarie> kmc, yeah but that way I'll suffer too ;)
10:02:50 <edwardk> 4/1 it is. if derek can't make it, i'll talk
10:02:56 <kmc> cool
10:03:15 <djahandarie> Yeay
10:03:48 <djahandarie> Now I have no reason to not go :)
10:04:59 <kmc> djahandarie, do you live in Bumblefuck, CT?
10:05:04 <amedxy> kmc: tks for your help
10:05:50 <djahandarie> kmc, that predicate wasn't neccessary, everywhere in CT is Bumblefuck.
10:06:12 <maurer_> kmc: List actually works fine here.
10:06:18 <djahandarie> I live in Storrs though :)
10:06:18 <maurer_> err, nvm
10:06:26 <maurer_> out of context
10:06:44 * monochrom is trapped in Monad, CT
10:07:00 <kmc> djahandarie, no, some places in CT are New York ;)
10:07:01 <djahandarie> Haha
10:07:13 <kmc> anyway iirc Megabus runs to Storrs now
10:07:17 <kmc> but i think not from there to Boston :/
10:07:53 <djahandarie> Apparently not.
10:07:54 <edwardk> monochom: Ah, so you can't get out.
10:08:10 <djahandarie> Only goes to Hartford and New York
10:08:16 <kmc> he just needs some connecticut-specific function to do so
10:08:50 <djahandarie> Hm, maybe peter pan does
10:08:53 <edwardk> It is a lot easier to leave if you live in Comonad, CT.
10:09:12 <djahandarie> I wish any of these places actually existed
10:09:16 <dmwit> Getting back home can be tricky, though.
10:09:21 <monochrom> then I would be trapped outside Comonad, CT.
10:09:59 <edwardk> monochrom: it is easy to extract yourself from Comonad, CT. And since every functor is strong, you can always get back in.
10:10:00 <kmc> there's a Haskell, TX
10:10:13 <kmc> most Haskell jobs listings are for jobs in Haskell, TX
10:10:21 <edwardk> You may not wind up in the same place you left from though.
10:10:41 <monochrom> this is surreal!
10:11:28 <monochrom> indeed there was someone entering this channel to ask "is this channel about Haskell, TX?"
10:11:45 <kmc> that's right.  we trolled him but good.
10:12:20 <djahandarie> I could get up to Boston with peter pan, but I'd need to stay the night somewhere :<
10:12:22 <edwardk> Especially considering the census shows 3101 people in the entire city. so we'd be a significant fraction of the population
10:12:26 <monochrom> but we didn't think of "no, this channel is about Monad, CT"
10:12:49 <djahandarie> No one thinks about CT
10:13:10 <kmc> edwardk, we could move there and take over!
10:13:20 <kmc> it's much easier to take over a town than it is to start a new one
10:13:45 <mart> Hi, Does anyone have any advice for improving build times on OS X? Linking takes ages. The GHC faq suggests switching to the GNU ld (on solaris)... is there a straightforward way to use the GNU linker on OS X (without breaking other things)?
10:14:02 <edwardk> kmc: yeah, but i think if programming language communities did that, i'd defect back to perl. the idea of taking over pearl city, hawaii is much more appealing
10:14:11 <mightybyte> Is "Function `$wa{v XIPg} [lid]' has two call patterns, but the limit is 1" a message that I should be concerned about? (ghc 7.0.2)
10:14:16 <kmc> yeah... Haskell is in the bumblefuck part of Texas
10:14:19 <monochrom> eh? I thought the gnu linker was slow enough.
10:14:20 <kmc> (read: not Austin) 
10:14:43 <kmc> mart, "gold" is a faster alternative to GNU ld; i don't know if it's supported on OS X
10:15:09 <kmc> if ghc gets your ld from $PATH, it would be easy to use the GNU ld or gold for only those builds
10:15:14 <kmc> i don't know if that's where it gets it
10:15:50 <monochrom> I think ghc gets ld from $PATH
10:16:18 <edwardk> hrmm, i think wall has already started: http://maps.google.com/maps?f=q&source=s_q&hl=en&geocode=&q=perl+harbour+,+hi&aq=&sll=21.354139,-157.95825&sspn=0.029937,0.055747&gl=us&ie=UTF8&hq=&hnear=Perl+Harbour,+Ewa,+Honolulu,+Hawaii&z=15&iwloc=A
10:17:06 <mart> kmc: monochrom: thanks.  do you know if changing ld on my path likely to break anything else on OS X?
10:17:11 <monochrom> what? hahaha. I think it's a Google easter egg.
10:17:20 <kmc> mart, you can change it for one terminal only
10:17:22 <kmc> but no, i don't know
10:17:25 <monochrom> I don't know. I have only tried on linux.
10:17:25 <edwardk> =)
10:17:31 <kmc> in fact you can change it for one command only
10:17:38 <kmc> PATH=~/gnu
10:17:39 <kmc> err
10:17:50 <kmc> PATH=~/gnu-local-install:$PATH ghc --make foo.hs
10:18:07 <mart> sure, but it'd be nicer not to do that every time I do a build :)
10:18:22 <kmc> alias ghc?
10:18:23 <thoughtpolice> kmc: gold only works with linux/ELF right now, I don't think anyone has plans to port it, although I don't think anybody would be opposed to a port either
10:18:40 <thoughtpolice> I thought that OS X used GNU ld, but looking at my mbp, I'm not actually sure if it does
10:18:41 <kmc> i hear Mach-O is crazy
10:19:09 <mart> I'll have a look through the cabal docs, see if I can configure anything.  just wanted to get an idea of what other people are doing.
10:19:48 <thoughtpolice> in general, on this debian machine, gold seems to do pretty well for link times, but there are cases where it explodes on me compared to GNU ld (not time-wise, but memory wise. linking a debug build of clang from the SVN repos takes about 800mb of RAM sometimes)
10:20:24 <thoughtpolice> in general though, when GHC builds applications, it does seem to take the link time down a bit, which is awesome
10:20:48 <kmc> lets write a linker in haskell
10:21:27 <lispy> thoughtpolice: doesn't gnu ld also require 1GB of memory to link some haskell programs?
10:21:28 <mart> I'm just getting started, so my project is tiny.  Builds nicely on Linux, but like a dog on OS X.
10:21:59 <mart> Also, the binary size is 10x bigger on OS X :o
10:22:18 <thoughtpolice> lispy: no. in the case of debug clang builds though, ld/gold seem to be about even in speed (minus 10 seconds or so,) but from what I've observed, the memory usage with gold is much higher
10:22:42 <thoughtpolice> lispy: clang is extremely large though when built normally, especially under debug (because it builds and links ALL of LLVM into it, all compiled in debug mode)
10:22:48 <lispy> thoughtpolice: ah.  Well, I've had issues with gnu ld taking too much memory when split-objs is enabled.
10:23:01 <thoughtpolice> like, right now, my debug clang binary is about 300m
10:23:29 <lispy> I thought I heard at one point that cabal files that have both executable and library sections can have the executable depending on the library.  What is the syntax for this (having a hard time finding it in the manual)?
10:23:29 <thoughtpolice> lispy: gold memory usage doesn't seem to be an issue at all almost when just using GHC to build things, or even building GHC itself though
10:23:48 <lispy> thoughtpolice: cool.  So would you recommend gold for daily work in haskell?
10:23:49 <thoughtpolice> lispy: uh, I think you just have to make the executable src-dirs the same as the library src-dirs, and cabal will 'do the rest'
10:23:59 <lispy> ah
10:24:08 <thoughtpolice> lispy: I basically only use gold on this machine. the one restriction I can think of is that I still don't think gold can link the linux kernel
10:24:33 <thoughtpolice> the kernel apparently twists GNU ld in strange, arcane ways that were likely birthed in fire at the dawn of time as we know it
10:24:40 <kmc> the linux kernel is basically a test suite for gcc and ld
10:25:21 <kmc> in fact i wouldn't be surprised if more than a few gcc extensions were added specifically for kernel use
10:25:36 <thoughtpolice> that sounds pretty reasonable, honestly
10:26:03 <lispy> The kernel drives a lot of open source
10:26:21 <thoughtpolice> lispy: in general though yes I'd highly recommend it. it's also pretty easy to install on debian at least, just 'aptitude install binutils-gold' and it'll save your old LD too so you can switch them
10:26:46 <lispy> thoughtpolice: I used to use debian exclusively, but I've been trying out fedora lately.
10:27:08 <kmc> will kernel builds still work properly after you do that thoughtpolice?
10:27:11 <thoughtpolice> i'd be surprised if fedora didn't have a build of gold
10:27:26 <thoughtpolice> kmc: not sure, I haven't compiled a kernel on this machine in ages honestly.
10:27:35 <lispy> thoughtpolice: it probably does.  I just don't know if installing binutils-gold would let me easily switch between them like on debian :)
10:27:44 <thoughtpolice> lispy: true
10:28:08 <lispy> modern redhat is pretty reasonable though.  They've really caught up with debian so it might
10:28:14 <maurer_> lispy: List the package as a dependency for the executable
10:28:20 <kmc> fedora ≠ redhat
10:28:22 <maurer_> lispy: As a warning, this will make haddock sad.
10:28:26 <lispy> maurer_: ah, the package itself?
10:28:30 <maurer_> lispy: Yeah.
10:28:46 <lispy> kmc: true, but ISTR that fedora is based no RH
10:28:50 <lispy> on*
10:28:52 <thoughtpolice> on the note of packages, I must say, cabal-dev is aaaaaa-mazing
10:28:57 <thoughtpolice> that is all.
10:29:02 <lispy> thoughtpolice: yes it is!
10:29:08 <lispy> thoughtpolice: I'm really digging cabal-dev ghci
10:29:16 <lispy> actually, I have an alias so I just type, cadev ghci
10:29:19 <jystic> Hi all, when doing FFI, should I use Ptr CUChar or Ptr Word8 to represent 'unsigned char *'?
10:29:33 <kmc> lispy, yeah, it's a feeder project for RH and uses the same package manager
10:29:47 <thoughtpolice> lispy: yeah, it's really nice. it makes it easy to write stuff that depends on very specific library versions, and not pollute GHC's package databases. it's great.
10:29:47 <kmc> jystic, i'd say it depends on what the library means by "unsigned char *"
10:29:57 <kmc> "pointer to bytes" vs "pointer to characters"
10:30:13 <kmc> in practice it doesn't matter and you can just pick the one which makes the rest of your code nicer
10:30:16 <lispy> kmc: BTW, I talked to some more people about the SDL/LGPL issue and now I'm okay with using that library license wise, but until it's in the Haskell Platform I don't think I'll adopt it for my tutorial series.
10:30:24 <kmc> ok
10:30:41 <jystic> kmc: thanks, how about for CUShort and so on, is CUShort always 16-bits, CUInt always 32-bit, etc?
10:30:51 <kmc> CUShort is always the same size as a C unsigned short
10:30:52 <kmc> etc.
10:30:54 <kmc> that's what they're for
10:31:02 <lispy> kmc: Did you mention being the author of the SDL bindings?
10:31:05 <jystic> but Word16 is always 16-bits?
10:31:12 <kmc> lispy, ? i'm not the author
10:31:16 <kmc> yes
10:31:50 <kmc> jystic, also Int and CInt are frequently different sizes
10:32:01 <kmc> but CInt is always a C int
10:32:03 <thoughtpolice> lispy: IIRC, Lemmih is the author of the SDL binding
10:32:05 <lispy> kmc: Okay.  I ask because dons told me that SDL won't get included as is because it doesn't meet the quality standards (yet)
10:32:09 <kmc> ok
10:32:20 <kmc> jystic, you can also use hsc2hs and write (#type uint8_t)
10:32:23 <lispy> I was hoping to poke someone to clean it up :)
10:32:30 <lispy> I have enough side projects going on
10:32:35 <kmc> likewise ;)
10:32:46 <jystic> what does that output?
10:33:02 <jystic> CUChar or Word8?
10:33:16 <thoughtpolice> lispy: isn't the SDL package notoriously problematic on everything that's, well, not linux?
10:34:07 <kmc> jystic, it outputs some integral Haskell type with the same size as C's uint8_t
10:34:22 <kmc> you can run hsc2hs if you want to see what it happens to produce on your system
10:34:27 <lispy> thoughtpolice: That could be.  I haven't tried it.
10:35:13 <jystic> kmc: thanks! I think I have a good handle on things now
10:39:47 <kmc> cool :)
10:40:55 <mart> just run into this problem with gold: http://hackage.haskell.org/trac/ghc/ticket/4862
10:41:07 <lispy> Has anyone heard from the author of the OpenGL bindings lately?  I sent him an email and didn't hear back in a week.  I emailed the opengl list last night with patches but no response there either yet
10:42:08 <thoughtpolice> didn't Sven say he didn't have time for further maintenance at one point? maybe i'm wrong
10:42:11 * thoughtpolice checks his gmail
10:43:26 <thoughtpolice> hm, I think I am wrong. must be thinking of someone else
10:43:59 <lispy> Did he turn over maintainership?
10:44:55 <edwardk> clearly the program you use to run gold should be au, not ld.gold
10:45:28 <thoughtpolice> lispy: hm, well, OpenGL is part of the platform, so after rethinking it, I don't think he's given up maintainership, because all platform packages must have active maintainers IIRC
10:45:45 <mart> Linking Main ...
10:45:46 <thoughtpolice> though the OpenGL bindings don't really see a ton of work, either
10:45:47 <mart> /usr/bin/gold: -fno-stack-protector: unknown option
10:46:47 <lispy> thoughtpolice: They are very current these days.  Supporting OpenGL 3.1
10:47:13 <lispy> thoughtpolice: 4.1 was released about 9 months ago, but implementations and books are not ubiquituous yet
10:47:33 <thoughtpolice> yeah, I don't even know how much driver support there is for 4.0. i think nvidia has drivers, but that's it\
10:48:01 <lispy> Yeah, the redbook for 4.1 won't be out until August of this year
10:48:36 <lispy> I know because I'm trying to decide if I should wait that long to get a copy.  The 4.1 book will cover tessellation shaders which are new in 4
10:48:59 <DevHC> :o clean uses ~ for the unary minus. canhaz?
10:50:08 <lispy> DevHC: that would be inconsistent with a fair bit of Haskell's syntax, so I think it would require an extension.
10:50:27 <lispy> DevHC: for example, we already use ~ for lazy pattern matches
10:50:39 <lispy> and we use it to say types are equivalent
10:51:43 <kmc> back in my day we only had two kinds of shader
10:51:55 <kmc> and they didn't even work!
10:52:04 <lispy> :)
10:52:17 <lispy> Back in my day, we just had renderman shaders!
10:52:17 * kmc had the misfortune of doing graphics labs on the GeForce FX 5200... the card so bad that NVIDIA had to cheat at 3DMark
10:52:22 <lispy> .rb and all that
10:52:23 <joeytwiddle> 3,99a4,99n5,99d6,99 7,99a8,99l9,99l10,99 11,99t12,99h13,99a14,99t2,99
10:52:26 <kmc> :O
10:52:45 <kmc> .rb best bot ever?
10:52:45 <joeytwiddle> 8,99b9,99e10,99s11,99t12,99 13,99b14,99o2,99t3,99 4,99e5,99v6,99e7,99r8,99?9,99
10:53:56 <azaq23> <blink>
10:54:02 <djahandarie> lol...
10:55:24 <jystic> .rb @pl concatMap f xs = concat $ map f xs
10:55:25 <joeytwiddle> 14,99@2,99p3,99l4,99 5,99c6,99o7,99n8,99c9,99a10,99t11,99M12,99a13,99p14,99 2,99f3,99 4,99x5,99s6,99 7,99=8,99 9,99c10,99o11,99n12,99c13,99a14,99t2,99 3,99$4,99 5,99m6,99a7,99p8,99 9,99f10,99 11,99x12,99s13,99
10:55:44 <jystic> damn, no bot chaining
10:55:57 <jystic> @pl concatMap f xs = concat $ map f xs
10:55:57 <lambdabot> concatMap = (=<<)
10:56:14 <jystic> see lambdabot, that was easy, did you pass out because of the colors?
11:01:00 <xplat> i'm trying like mad with Control.Newtype.ala, Control.Arrow.Kleisli, and (Control.Category.>>>) to get (>=>) out and i'm having no luck :(
11:02:20 <xplat> i can't even seem to get it to work for the easier case of '*' from ala, Product, and mappend
11:05:07 <dolio> @type ala
11:05:07 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:05:16 <tieTYT> is real world haskell still available online with comments?
11:06:22 <dolio> xplat: The problem with something like (*) is that ala is for wrapping elements of a container, sticking them together using some traversal, and then unwrapping.
11:07:12 <dolio> Same problem with (>=>).
11:07:22 <aristid> > text "let's see if this begins with a space"
11:07:22 <lambdabot>   let's see if this begins with a space
11:07:52 <dolio> @type ala Product foldMap
11:07:52 <lambdabot> Not in scope: `foldMap'
11:07:53 <Saul__L> bookmark irc.freenode.net/haskell
11:07:57 <dolio> @type ala Product Data.Foldable.foldMap
11:07:58 <lambdabot> forall o (t :: * -> *). (Num o, Data.Foldable.Foldable t) => t o -> o
11:08:06 <Saul__L> damn
11:08:20 <azaq23> @type let x >==> y = runKleisli $ Kleisli x Control.Category.>>> Kleisli y in (>==>)
11:08:20 <lambdabot> forall a (m :: * -> *) b b1. (Monad m) => (a -> m b) -> (b -> m b1) -> a -> m b1
11:08:50 <aristid> @type (>=>)
11:08:51 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:08:59 <aristid> azaq23: but that's the cheap version ;)
11:09:23 <dolio> If you wanted an uncurried version, and had an (a, a) container, maybe you'd be in luck.
11:12:19 <Saul__L> connected
11:12:21 <azaq23> aristid: What's cheap about it? Or do you mean in relation to the original problem (using Control.Newtype)? If so, yes I don't know about that part.
11:12:28 <monochrom> this is strange. ubuntu already comes with the gold linker out of the box as /usr/bin/ld.gold. the only function of "apt-get install binutils-gold" is to symlink /usr/bin/ld to /usr/bin/ld.gold
11:12:56 <dolio> @type ala Product (mappend `on`)
11:12:57 <lambdabot> forall o o'. (Num o, Newtype (o -> Product o) o') => o -> o'
11:13:07 <dolio> @type ala Product (uncurry . mappend `on`)
11:13:08 <lambdabot>     Couldn't match expected type `Product o'
11:13:08 <lambdabot>            against inferred type `(a, b)'
11:13:08 <lambdabot>     In the first argument of `(.)', namely `uncurry'
11:13:17 <dolio> @type (mappend`on`)
11:13:18 <lambdabot> forall b a. (Monoid b) => (a -> b) -> a -> a -> b
11:13:36 <dolio> @type uncurry . (mappend`on`)
11:13:37 <lambdabot> forall b b1. (Monoid b1) => (b -> b1) -> (b, b) -> b1
11:13:47 <dolio> @type ala Product (uncurry . (mappend `on`))
11:13:47 <lambdabot> forall b. (Num b) => (b, b) -> b
11:13:55 <dolio> @type curry $ ala Product (uncurry . (mappend `on`))
11:13:56 <lambdabot> forall b. (Num b) => b -> b -> b
11:14:06 <dolio> @type curry $ ala Product (uncurry . ((>>>) `on`))
11:14:07 <lambdabot>     Couldn't match expected type `Product o'
11:14:07 <lambdabot>            against inferred type `cat a b'
11:14:07 <lambdabot>     In the first argument of `on', namely `(>>>)'
11:14:35 <dolio> @type curry $ ala Kleisli (uncurry . ((>>>) `on`))
11:14:35 <lambdabot> forall a (m :: * -> *). (Newtype (Kleisli m a a) (a -> m a), Monad m) => (a -> m a) -> (a -> m a) -> a -> m a
11:14:39 <dolio> There we go.
11:14:52 <djahandarie> Whoa.
11:15:09 <djahandarie> Interesting pattern
11:15:12 <dolio> Oh, wait.
11:15:20 <dolio> That's too restricted, because of on's type.
11:15:37 <djahandarie> Yeah, but it does work for some stuff it seems
11:15:53 <aristid> azaq23: (>=>) is in the standard library, so using it instead of Kleisli'd (>>>) - as you did - is "cheap" (to clarify: it is the (>=>) version that i called cheap)
11:16:18 <djahandarie> @type \pa f -> curry $ ala pa (uncurry . (f `on`))
11:16:18 <lambdabot> forall b c n c1. (Newtype n b, Newtype c1 c) => (b -> n) -> (n -> n -> c1) -> b -> b -> c
11:18:12 <djahandarie> This is basically just under2, right?
11:18:16 <djahandarie> @type under
11:18:16 <lambdabot> forall o n n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> (n -> n') -> o -> o'
11:18:57 <dolio> Not quite?
11:19:04 <dolio> Oh, wait, yes.
11:19:39 <dolio> It takes a function on newtypes and turns it into a function on the underlying types.
11:20:31 <djahandarie> It would probably be better to just define this with pack and unpack directly :P
11:22:12 <azaq23> aristid: Oh, I thought cheap as in "being the easy way out / working but marginally related 'solution'" in relation to the original problem or something like that, not cheap as in actually cheap :)
11:22:16 <dolio> So, here's a question:
11:22:19 <dolio> @type ala
11:22:20 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:22:41 <dolio> Why 'ala wrap trav' instead of 'ala (trav wrap)'?
11:22:57 <dolio> Or does ala use wrap in some way I'm forgetting?
11:23:43 <aristid> azaq23: my "cheap" had very little meaning :) writing (>=>) by hand with runKleisli is certainly a useful exercise
11:24:16 <djahandarie> It infers the type of the unpack for you
11:24:44 <djahandarie> Hm
11:25:15 <dolio> What does ala use Newtype n o for?
11:26:06 <bapuche> How can I make a multinomial function return an integer; multi a = (fact $ sum a) / (product $ map fact a)  returns a number of type "fractional". One way I see is to create a Pascal's triangle-like structure and index into it, but that's beyond me right now. 
11:26:27 <roconnor> god damn it scheme!
11:27:15 <roconnor> someone write some scheme code in TeXmacs.  It has a type error in it.
11:27:24 <roconnor> and now I don't get bibliographies
11:27:47 <dolio> Oh, it doesn't use the first argument at all.
11:28:24 <dolio> > let f _ = Product 1 in ala f Data.Foldable.foldMap [1..10]
11:28:24 <lambdabot>   3628800
11:28:44 <dolio> Okay, mystery solved.
11:29:07 <djahandarie> I wonder if this is actually desirable.
11:29:11 <dolio> @type ala
11:29:11 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:30:11 <djahandarie> @type \pa hof -> unpack . hof pa
11:30:12 <lambdabot> forall t a o (f :: * -> *). (Newtype a o, Functor f) => t -> (t -> f a) -> f o
11:30:32 <djahandarie> @type \pa hof -> unpack (Prelude..) hof pa
11:30:33 <lambdabot> forall t t1 b c a t2. (Newtype ((b -> c) -> (a -> b) -> a -> c) (t1 -> t -> t2)) => t -> t1 -> t2
11:30:38 <djahandarie> What the hell
11:30:49 <djahandarie> @type \pa hof -> (Prelude..) unpack (hof pa)
11:30:49 <lambdabot> forall t b o a. (Newtype b o) => t -> (t -> a -> b) -> a -> o
11:30:55 <dolio> @type \pa hof -> unpack Prelude.. hof pa
11:30:55 <lambdabot> forall t b o a. (Newtype b o) => t -> (t -> a -> b) -> a -> o
11:31:17 <djahandarie> @type \pa hof -> (Prelude..) unpack (hof pack)
11:31:17 <lambdabot> forall t b o o1 n a. (Newtype b o, Newtype n o1) => t -> ((o1 -> n) -> a -> b) -> a -> o
11:32:15 <dolio> What about...
11:32:17 <djahandarie> ala' is just that with an extra hook before pack
11:32:23 <djahandarie> @type ala'
11:32:24 <lambdabot> forall o n a b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((a -> n) -> b -> n') -> (a -> o) -> b -> o'
11:32:32 <dolio> @type \pa hof -> ala' pa hof pa
11:32:32 <lambdabot> forall n b n' o'. (Newtype n n, Newtype n' o') => (n -> n) -> ((n -> n) -> b -> n') -> b -> o'
11:32:41 <dolio> Wait, that's not right.
11:33:09 <djahandarie> I guess the reason ala has the type it does is for similarity with ala'
11:33:51 <dolio> Anyhow, that's fine. You need the first argument to specify the newtype if you're using it.
11:34:21 <dolio> I was just thinking that ala wrap hof = unpack . hof wrap
11:34:53 <dolio> @type let a w h = unpack . h w
11:34:53 <lambdabot> <no location info>: not an expression: `let a w h = unpack . h w'
11:34:57 <dolio> @type let a w h = unpack . h w in a
11:34:58 <lambdabot> forall t (f :: * -> *) a o. (Functor f, Newtype a o) => t -> (t -> f a) -> f o
11:35:14 <dolio> @type unpack
11:35:15 <lambdabot> forall n o. (Newtype n o) => n -> o
11:36:06 <djahandarie> @type let a w h = unpack . h w in a Product Data.Foldable.foldMap
11:36:07 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t, Num a) => t a -> a
11:36:22 <djahandarie> @type let a w h = unpack . h w in a Product
11:36:22 <lambdabot> forall a (f :: * -> *) a1 o. (Functor f, Newtype a1 o) => ((a -> Product a) -> f a1) -> f o
11:36:37 <djahandarie> I wonder if this would be interesting with some other Functor...
11:37:32 <dolio> @type let a w h = unpack . h (pack `asTypeOf` w) in a
11:37:33 <lambdabot> forall o n (f :: * -> *) a o1. (Functor f, Newtype n o, Newtype a o1) => (o -> n) -> ((o -> n) -> f a) -> f o1
11:37:36 * hackagebot skypelogexport 0.1 - Export Skype chat logs to text files  http://hackage.haskell.org/package/skypelogexport-0.1 (EugenyDzhurinsky)
11:37:43 <temoto> Hello. I missed you guys. :)
11:37:53 <dolio> @type let a w h = unpack . h (pack `asTypeOf` w) in a Product
11:37:54 <lambdabot> forall o (f :: * -> *) a o1. (Functor f, Newtype a o1) => ((o -> Product o) -> f a) -> f o1
11:39:25 <temoto> Please, help me to name a function. I'm a bit lost around quantiles and percentiles. It splits sorted array until accumulated sum of previous values is <= k * sum of all values.
11:40:55 <temoto> *splits at point where
11:45:40 * hackagebot http-enumerator 0.4.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.4.1 (MichaelSnoyman)
11:46:42 * hackagebot warp-static 0.0.3 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-0.0.3 (MichaelSnoyman)
11:49:15 <jay> hello
11:50:57 <xplat> 14:40 < lispy> Back in my day, we just had renderman shaders!
11:51:43 <xplat> back in my day, we just had phong shaders and gourad shaders, we wrote them by hand uphill both ways in fortran, and we roughed out our scenes with gourad because phong was too slow
11:52:45 * hackagebot carboncopy 0.1.2 - Drop emails from threads being watched into special CC folder.  http://hackage.haskell.org/package/carboncopy-0.1.2 (EugenyDzhurinsky)
12:00:45 <joe6> in the llvm module, can I use -> "CodeGenModule (Function (IO Char))" instead of " CodeGenModule (Function (IO Int8)) "
12:00:55 <joe6> the Char instead of Int8?
12:01:37 <Guest3798> hello iam newbie :)
12:02:00 <byorgey> hi Guest3798 
12:02:24 <byorgey> Guest3798: visiting from tryhaskell?
12:02:40 <joe6> i seem to be getting all kinds of errors when I change Int8 to Char..
12:03:09 <byorgey> they are not interconvertible.
12:03:16 <byorgey> Char is Unicode chars and may be several bytes.
12:03:17 <temoto> joe6, numbers and Char are usually not compatible.
12:04:01 <joe6> byorgey, oh, really, I thought Char = byte, as in C, hence my confusion.
12:11:16 <aristid> joe6: i think haskell's behavior is much better there :)
12:13:42 <revenantphx> Hm.
12:13:48 <revenantphx> #haskell is good at math.
12:13:53 <revenantphx> I have
12:13:54 <revenantphx> #define SIGMA (1)
12:13:54 <revenantphx> #define CONST_A (1 / sqrt(2 * pi * (SIGMA ^ 2)))
12:13:58 <revenantphx> and then
12:13:59 <revenantphx> weight[i] = CONST_A * exp(-1 * (i - (len/2)^2) / 2 * SIGMA ^ 2);
12:14:06 <revenantphx> (gaussian distribution)
12:14:18 <revenantphx> but, when I look at the values of weight… it's stuff like 6.209e-301
12:14:19 <revenantphx> D:
12:14:35 <Zao> revenantphx: haskell-blah even more so.
12:14:38 <Zao> And less off topic.
12:14:44 <joe6> aristid, makes sense..
12:14:48 <revenantphx> Well, I did implement it in haskell. At some point.
12:14:49 <revenantphx> :)
12:15:03 <aristid> revenantphx: why did you switch from haskell to C? :P
12:15:13 <revenantphx> Because I had too for work.
12:15:19 <Zao> aristid: Not C either, unless he wants to xor stuff.
12:15:36 <revenantphx> Anyways, you *don't* want to see the code beyond that.
12:15:38 <aristid> Zao: heh.
12:15:42 <revenantphx> It's scary stuff.
12:15:51 <aristid> revenantphx: why are you using ^?
12:16:03 <revenantphx> that would do it wouldn't it.
12:16:11 <aristid> ???
12:16:20 <xplat> frack, once again a dead firefox
12:16:23 <revenantphx> lol
12:16:30 <revenantphx> xor is an important part of a gaussian distribution
12:16:34 <revenantphx> (derp)
12:17:15 <aristid> revenantphx: see, my questioning why you switched from haskell to C ultimately brought you to the problem
12:17:24 <revenantphx> aristid: Genius!
12:17:33 <aristid> i know!
12:18:18 <SoleSoul> Hi. I have to generate assembly code from bytecode for homework. In the process I have to create labels. each label name has to be unique. How can I achieve that considering Haskell's functions are pure? How can I generate another name each time I call the generator? Thanks
12:18:33 <xplat> one of these days i'm going to write my own browser.  a browser that doesn't suck!  (yeah, that'll be the day)
12:18:48 <kmc> SoleSoul, pass around an infinite list of labels
12:19:12 <revenantphx> kmc: I love how that's a valid strategy in Haskell ^_^
12:19:23 <revenantphx> "Oh, just pass around an infinite list of labels"… amuses me.
12:19:49 <kmc> SoleSoul, so you can do «[Label] -> Stuff» or «[Label] -> (Stuff, [Label])»
12:19:56 <revenantphx> but yeah, pass around an infinite list, chop off the head each time you use one, and pass the remainder of the list into the next call...
12:19:56 <xplat> it kind of infuriates me that now that we finally have desktop operating systems that can run for a reasonable amount of time under reasonably heavy load without falling over, we've gone and moved all our desktop apps into a browser that ... wait for it ...
12:20:27 <kmc> SoleSoul, the latter makes it easier to fan out to multiple functions, because you don't need to split the list
12:20:27 <revenantphx> Not to mention we have to put up with javascript.
12:20:43 <kmc> SoleSoul, and the latter has a little syntactic sugar in Haskell, via Control.Monad.State
12:20:55 <kmc> but you don't "need monads" here, it's just sugar for passing and returning values
12:21:35 <xplat> revenantphx: yes!  java was too slow, but javascript is fast enough!  (?!)
12:21:48 <kmc> in fact you can just do «Label -> (State, Label)» as long as you have some kind of "nextLabel" function
12:22:04 <monochrom> IE9 now compiles javascript. it could be fast. :)
12:22:12 <kmc> so does Chrome
12:22:13 <azaq23> Next step is putting apps into facebook - oh wait
12:22:25 <monochrom> "there is a monad for that" :)
12:22:28 <dahankzter> ghc: This ELF file contains no symtab  :(  can I fix it?
12:22:41 <kmc> a good JIT compiler is vastly more capable than a static compiler
12:22:48 <SoleSoul> kmc: I'm afraid I don't know enough to understand your solution. what does the right pointing arrow mean?
12:22:49 <jystic> Chrome's javascript compiler is really cool
12:22:51 <kmc> a good JIT compiler makes sense even for "native-compiled" languages
12:22:56 <kmc> SoleSoul, a function
12:23:07 <kmc> A -> B is the type of functions that take A and return B
12:23:30 <SoleSoul> oh, that's fine. I'm trying to understand what you suggested.
12:23:35 <jystic> http://blog.chromium.org/2010/12/new-crankshaft-for-v8.html
12:23:54 <kmc> in fact I'd love to see a tracing JIT for Haskell
12:24:02 <kmc> because we could get some of the same gains as supercompilation
12:24:10 <lispy> kmc: I agree, but I wish we had an alternative to Javascript for the sort of "application" development people will do in the future.  High performance webgl stuff for games, for instance.
12:24:13 <SoleSoul> kmc: how do I create the list? something like that? [1..]
12:24:16 <kmc> sure
12:24:20 <monochrom> oh, chrome is going to compile javascript too?
12:24:30 <kmc> or maybe i can feed GHC's output into edwardk's x86-64 ASM JIT
12:24:34 <lispy> kmc: but maybe this is where we all jump on the NaCL bandwagon and make a ghc that emits NaCL programs
12:24:35 <FauxFaux> It already has.
12:24:37 <kmc> monochrom, Chrome has been using V8 for a while
12:24:37 <jystic> monochrom: It already does I believe
12:24:42 <kmc> V8 is a tracing JIT compiler
12:24:43 <monochrom> nice!
12:24:46 <xplat> kmc: yes, javascript can be fast with a good jit.  java could be considerably faster with a similar jit.  ml could be WAY, WAY faster with the same strength of jit
12:24:50 <revenantphx> Wait.
12:24:52 <revenantphx> I have a quick question.
12:24:54 <revenantphx> Am I...
12:24:56 <revenantphx> the only person here...
12:24:59 <monochrom> oh, does it do tail-call optimization? :)
12:25:01 <revenantphx> who listens to bossa nova while programming?
12:25:13 <revenantphx> (I find it's the only genre of music that actually helps me focus).
12:25:13 <revenantphx> (odd)
12:25:14 <monochrom> yes you are the only one.
12:25:17 <xplat> javascript just creates way too many code paths for things that can't happen.  or 'can't happen'
12:25:27 <SoleSoul> kmc: can I generate an infinite list of [label1, label2..] ?
12:25:52 <SoleSoul> or I just attach the word "label" to the generated number
12:25:57 <azaq23> SoleSoul: you can could create it using a recursive definition - just like a function, but which is a list
12:26:05 <xplat> and people are using it to power <canvas> ... it boggles the mind
12:26:06 <maurer_> Is there a good tutorial on how to use hsc now that #include is deprecated?
12:26:08 <kmc> map Label [1..]
12:26:13 <kmc> it is maurer_?
12:26:14 <kmc> damn
12:26:16 <azaq23> > let x = 1 : x in take 10 $ x
12:26:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
12:26:50 <kmc> xplat, but a JIT makes those code paths nearly irrelevant
12:27:10 <monochrom> hmm, I wonder if hugs builds on freebsd
12:27:13 <harlekin> Why is this Ix instance implementation causing listArray (Vec2 0 0, Vec2 1 1) (repeat Nothing) to halt? http://hpaste.org/44851/halting_ix_vec2_int_instance
12:27:16 <azaq23> if your labels are just containers for integers, kmc has the correct solution of course
12:27:43 <revenantphx> What I want to see is someone exploit the browser, take control of the JIT, and feed it custom bytecode.
12:28:02 <revenantphx> Better yet, someone just make an LLVM browser, or a Parrot VM browser, idk.
12:28:09 <kmc> STG machine browser
12:28:10 <revenantphx> Something so we can use better languages.
12:28:15 <revenantphx> STG machine browser XD
12:28:16 <lispy> revenantphx: that's basically what NaCL is
12:28:17 <kmc> you can compile to Javascript
12:28:24 <dahankzter> does anyone know how to fix/workaround "ghc: This ELF file contains no symtab"? There is a bug filed but well... im kanda lost
12:28:37 <lispy> revenantphx: use LLVM to produce bitcode and then execute it in a sandboxed way
12:28:41 <xplat> kmc: the speed of my browser says 'no it does not'.  or rather the lack of speed.
12:28:43 <monochrom> ah, it should build fine, there is even a "freshport"
12:28:45 <SoleSoul> kmc: Did I understand it wrongly or it's much more complicated than global variables? (I'm quite new)
12:28:56 <kmc> more complicated
12:28:57 <revenantphx> lispy: LLVM in browser would be nice .+.
12:29:00 <revenantphx> ._.
12:29:02 <kmc> maybe you should start with something simpler
12:29:10 <kmc> anyway i have to go but others can help you
12:29:18 <SoleSoul> kmc: thanks!
12:29:19 <lispy> revenantphx: http://code.google.com/p/nativeclient/
12:29:25 <revenantphx> Looking at it now...
12:29:54 <revenantphx> lispy: Can I interface this with a <canvas>
12:29:59 <revenantphx> for WebGL :3
12:29:59 <lispy> revenantphx: when it first came out my initial reaction was: Oh!  We need GHC to support this.  But, I just don't have the capacity to do it aline.
12:30:01 <lispy> alone*
12:30:11 <lispy> revenantphx: I hope so, but I don't know
12:30:30 <revenantphx> "Google offers Native Client along with examples to demonstrate its efficiency under an open source license to the web community. It is now up to other browser developers to port it for their applications."
12:30:31 <revenantphx> Pro.
12:30:45 <xplat> and <canvas> is completely wrong for entirely other reasons
12:30:54 <revenantphx> That's a nice way to get something out. "Hey look we did it for you, and its cool. Now use it before users complain."
12:34:21 <lispy> What do people use instead of time and old-locale?
12:34:58 <xplat> i mean it's basically, 'let's take the whole abstract display list model that was absolutely the only actual advancement in UI tech in web apps compared to old apps, and just throw it all out and go back to a model that was old in 1990'
12:35:10 <revenantphx> for(int j = i - (3 * SIGMA), k = 0; i < i + (3 * SIGMA); j++, k++){
12:35:11 <revenantphx> :|
12:35:17 <revenantphx> My for loops get crazy late at night.
12:35:26 <revenantphx> And then I wake up and I'm like "WHAT THE HELL WAS I DOIINNNNGGGG"
12:35:29 <revenantphx> It's code hangover.
12:35:36 <xplat> '(and decrepit by 1995)'
12:35:59 <revenantphx> I vote for redoing the internet :|
12:36:02 <revenantphx> We'll all move to port 81.
12:36:05 <revenantphx> And have a sexy, fun time.
12:36:12 <revenantphx> Who's with me.
12:36:41 <monochrom> I use nothing instead of time and old-locale
12:36:49 <xplat> no, we'll take over port 80
12:37:00 <xplat> you bring the time machine, i'll bring the guns
12:37:57 <xplat> (you do have a time machine, right?)
12:38:28 <revenantphx> Well I do.
12:38:32 <revenantphx> It travels at .99c
12:38:37 <revenantphx> Only problem is, it only goes *forward*.
12:39:08 <xplat> what?!
12:39:15 <xplat> that's like a car that only goes north
12:40:08 <ion> Ah, you mean Apple™ iCar™
12:40:14 <kmc> revenantphx, only a noob would write out SIGMA
12:40:18 <kmc> just use Σ
12:40:27 <revenantphx> kmc: Can't use unicodeeee D:
12:41:04 <monochrom> what do you mean can't use unicode? are you writing in TRS-80 BASIC?
12:41:09 <xplat> you mean gcc doesn't have an extension for utf-8 identifiers?
12:41:10 <revenantphx> C99. T_T
12:41:17 <revenantphx> If it does, I don't know about it.
12:41:34 <_Ray_> Just for giggles, is there anything I can do for ghc to accept the syntax λx.x as \x -> x?
12:41:50 <bapuche> I answered my own question, at least for trinomials, the special case I care about right now. tri a = tri' $ reverse $ sort a where tri' [a,b,c] = pascal !! (a+b+c) !! c * pascal !! (a+b) !! b.
12:42:00 <xplat> _Ray_: you could use a custom preprocessor
12:42:36 <xplat> or -XUnicodeSyntax gives you *almost* that, but different
12:42:44 <monochrom> well to be fair C99 belongs to about the same decade as TRS-80
12:43:37 <xplat> bapuche: or you could have used `div`
12:44:11 <ion> ray: You’ll probably want λx → x instead of λx . x since . has a different meaning in Haskell.
12:44:48 <Evious> Leksah can pretty-print common symbols (->, \)
12:45:03 <SoleSoul> kmc, or anyone else, I'm afraid I need some more directions. I can read but I don't know what to look for. Attached below is the string I want to return as a translation to a bytecode function. There are labels inside named IF_TRUE0 and END0. I have to turn this "0" to an incrementing counter but it doesn't fit with the purity of the functions. I know you told me what to do but I did not understand. Would you please just give me mor
12:45:06 <SoleSoul> "@0\nA=M\nA=A-1\nD=M\nA=A-1\nD=D-M\n@IF_TRUE0\nD;JEQ\nD=0\n@0\nA=M-1\nA=A-1\nM=D\n@END0\n0;JMP\n(IF_TRUE0)\nD=-1\n@0\nA=M-1\nA=A-1\nM=D\n(END0)\n@0\nM=M-1"
12:45:14 <bapuche> xplat: Heh. Thanks, simpler. Wonder which runs faster?
12:45:14 <_Ray_> ion: Yeah.
12:45:19 <monochrom> you have to modify ghc to accept λ for \. if you do, you violate haskell 2010.
12:45:53 <EvanCarroll> which is sad, if you ask me.
12:46:16 <EvanCarroll> I'd love to be able to write code that uses extended characters. I think that would be awesome, fun, and entertaining.
12:46:30 <EvanCarroll> I find it unfortunate that Lambda isn't in the X11 Compse DB
12:47:06 <mauke> you can use "extended" characters just fine
12:47:11 <xplat> EvanCarroll: even without language extensions, you can use extended characters for your own functions, just not in place of the standard ascii syntax that already exists
12:47:15 <mauke> > (\λ -> λ + 1) 41
12:47:15 <lambdabot>   42
12:47:51 <xplat> mauke: now that example is just confusing :)
12:47:52 <ion> evancarroll: Indeed, but it’s one of the rare characters i remember by ctrl-shift U3BB :-)
12:48:10 <EvanCarroll> Right. I understand. I just like the idea of using the real lamda. Being unicode aware is cool, having a unicode core enabled core is bragging rights
12:48:24 <mauke> adding your own compose combinations is easy, btw
12:48:42 <EvanCarroll> right, it is.
12:48:57 <EvanCarroll> But lambda/sigma seems prime for inclusion
12:48:58 <xplat> EvanCarroll: and if you don't mind your code being incompatible with Haskell 2010 compilers other than ghc, use -XUnicodeSyntax
12:49:11 <EvanCarroll> zomfg? ther eis an extention that does this?
12:49:20 <EvanCarroll> I will never wite non-ghc code again.
12:49:27 <xplat> (but please don't upload stuff to hackage like that :-7)
12:49:31 <EvanCarroll> no way.
12:49:34 <mauke> EvanCarroll: lambda and sigma are letters
12:49:42 <EvanCarroll> I understand that.
12:49:43 <mauke> you can use them for variables
12:49:43 <monochrom> the extension still doesn't accept λ for \ . this is why you still have to modify ghc.
12:49:50 <mauke> that's pretty much it
12:49:54 <EvanCarroll> =(
12:49:56 <xplat> monochrom: hm, i thought it did
12:50:00 <EvanCarroll> too bad.
12:50:02 <kmc> unicode has some "math lambda" codepoint i thought
12:50:05 <xplat> guess i was confused
12:50:18 <EvanCarroll> it seperates symbols into a special series of pages. iirc
12:50:31 <ion> I don’t mind having ASCII characters in the source, but i’d like my editor to prettyprint the code in the style of LaTeX output from lhs2tex.
12:50:39 <azaq23> SoleSoul: Why don't you create an algebraic datatype like data TypeOfLine = Label String Int | ExecLabel Name Int | Normal? Label is the label definition, ExecLabel is the used label, normal for any other expression. Then create a list [(Label, String)] of those. I don't think you really need a infinite list here.
12:50:53 <xplat> kmc: i never saw something like that in my various trawls through unicode characters, except of course for the usual math greek and alphabetics.  i never saw one that was a non-letter.
12:50:55 <Saul__L> CRAZY PEOPLE XD
12:51:02 <EvanCarroll> isSymbol i think is in the unicode standard., I'm not sure there is a test for math-glyphs I dont think use-in-app is in the standard.
12:51:07 <xplat> er, greek and latin alphabetics
12:51:28 <Saul__L> xD XD XD XD XD XD XD XD XD XD
12:52:29 <ion> 𐎍 U+1038D Ugaritic letter lamda
12:52:38 <xplat> i don't see why λ couldn't be a keyword, but i guess then you'd have to use it like λ x → x + x
12:52:39 <ion> 𐎍x → x+1
12:52:52 <kmc> xplat, how would you like it if l were a keyword?
12:53:26 <SoleSoul> l 1 I
12:53:39 <xplat> kmc: it wouldn't be as bad as if x, y, or s were keywords, and i've used languages that did that just fine
12:53:48 <ion> I wouldn’t mind the Finnish letter ö being a special character, since it would be stupid of me to use it in the code except as a standardized symbol of the language syntax.
12:54:08 <mauke> och nö du
12:54:24 <xplat> the x operator in python didn't even make my top 20 pain points
12:55:16 <SoleSoul> א
12:56:02 <azaq23> the x operator?
12:56:37 <EvanR-work> \x -> y (y x) z
12:56:51 <EvanR-work> silly +, its too magical
12:56:55 <Taslem> Is there a right-associative version of ($)?
12:57:30 <mauke> some people define €
12:57:41 <Saul__L> ☺
12:57:51 <mauke> wait, isn't ($) right associative?
12:58:01 <ion> One would think the Greek would be willing to sacrifice being able to say Μπορώ να φάω σπασμένα γυαλιά χωρίς να πάθω τίποτα in Haskell code (rendering it undecipherable for the rest of the planet) so that everyone can use the established lambda as a, well, lambda. :-)
12:58:04 <ceii> Taslem, $ is right associative
12:58:17 <azaq23> afaik there is no x operator in python whatever that actually is supposed to mean
12:58:30 <Taslem> Oh, pardon, I meant left.
12:58:31 <Saul__L> :D :D :D
12:58:34 <hpc> :t f $ x $ y
12:58:34 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
12:58:34 <lambdabot>     In the first argument of `($)', namely `x'
12:58:34 <lambdabot>     In the second argument of `($)', namely `x $ y'
12:58:47 <hpc> :t f $ g $ y
12:58:47 <lambdabot>     Ambiguous type variable `b' in the constraints:
12:58:47 <lambdabot>       `Show b' arising from a use of `f' at <interactive>:1:0
12:58:47 <lambdabot>       `SimpleReflect.FromExpr b'
12:58:57 <Saul__L> :P
12:59:02 <hpc> > show $ show $ x
12:59:02 <lambdabot>   "\"x\""
12:59:03 <ceii> Taslem: whitespace is the left-associative apply operator
12:59:04 <hpc> neat
12:59:12 <nickela> > let s p xs = uncurry (++) $ second return $ runState (foldM (\a b-> if p b then get >>= \c -> put [] >> return (a++[c]) else modify (++[b]) >> return a) [] xs) [] in s (even.flip div 2) [1..10]
12:59:13 <hpc> x $ y $ z = x . y $ z
12:59:14 <lambdabot>   [[],[2,3],[],[6,7],[],[10]]
12:59:17 <Saul__L> ^_^
12:59:19 <Taslem> I meant, of the same order-of-operation.
12:59:26 <Saul__L> :O
12:59:31 <EvanR-work> ceii: ( ) f x ? :)
12:59:37 <Saul__L> çÇç
12:59:40 <ceii> Ah. Then no there isn't
12:59:42 <Saul__L> -_-
12:59:46 <kmc> Saul__L, can we help you?
13:00:02 <kmc> Taslem, "order of operation"?
13:00:05 <kmc> like associativity?
13:00:08 <Saul__L> hehe, no just having some fun :D
13:00:08 <mauke> kmc: precedence
13:00:09 <kmc> operator precedence?
13:00:13 <Taslem> Precedence, sorry.
13:00:13 <ceii> EvanCarroll: map ( 1) [id, succ]
13:00:24 <mauke> :t map ( 1) [id, succ]
13:00:25 <lambdabot>     Ambiguous type variable `a' in the constraint:
13:00:25 <lambdabot>       `Enum a' arising from a use of `succ' at <interactive>:1:14-17
13:00:25 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
13:00:25 <EvanR-work> over here
13:00:47 <Saul__L> çÇç
13:00:51 <Saul__L> -_-
13:01:04 <Saul__L> v
13:01:05 <ceii> oops wrong completion
13:01:05 --- mode: ChanServ set +o mauke
13:01:06 --- mode: mauke set +q *!*@190.186.47.246
13:01:26 <monochrom> Saul__L: please don't over-do it
13:01:28 <ceii> isn't my client set to last spoken?
13:01:56 --- mode: mauke set -o mauke
13:02:44 <Taslem> Are there any existing graphics libraries for Haskell?
13:03:12 <ion> yes
13:03:12 <EvanR-work> yes
13:03:21 <EvanR-work> graphics combinators!
13:03:31 <ceii> there are cairo and opengl bindings, and higher-level libraries like craftwerk and hieroglyph
13:04:15 <ceii> I think all the high level 3d libraries all bitrotten though
13:04:21 <ceii> are*
13:04:48 <Taslem> Any personal recommendations for ease of use / speed / etc.
13:06:00 <ceii> ease of use-wise that new craftwerk lib looked nice
13:07:15 <ceii> for speed you'll need to ask someone else
13:08:11 <elliotstern> I'm having some trouble on my Mac with importing Parsec; the ld is complaining about some undefined symbols - http://hpaste.org/44855/ld_problem_with_trying_to_impo
13:08:57 <Taslem> Are semicolons equivelant to whitespace?
13:09:11 <Taslem> (I mean, besides function application)
13:09:32 <ceii> Taslem: not quite, they're an alternative to layout
13:09:39 <siracusa> elliotstern: ghc --make foo.hs
13:09:44 <ceii> they're sort of equivalent to newlines
13:10:55 <Taslem> Would ending lines in more than one yield a syntax error?
13:11:13 <ceii> definitely
13:11:24 <elliotstern> siracusa: Thanks
13:11:29 <Taslem> It doesn'
13:11:32 <Taslem> tlook like it.
13:11:35 <ceii> oh
13:11:41 <Taslem> Though I might be wrong.
13:11:44 <ceii> > 1 + 1 ;
13:11:45 <lambdabot>   <no location info>: parse error on input `;'
13:12:05 <ceii> > let a= 1 ; in a
13:12:06 <lambdabot>   1
13:12:09 <ceii> > let a= 1 ; ; in a
13:12:09 <lambdabot>   1
13:12:20 <Taslem> > let a = 1;;;;; in a;;;;
13:12:21 <lambdabot>   <no location info>: parse error on input `;'
13:12:24 <ceii> oh, empty definitions are allowed
13:12:28 <Taslem> Hm, okay, that explains something.
13:12:42 <mauke> Taslem: whitespace is sometimes equivalent to semicolons
13:14:33 <Taslem> Yeah, it looks to me like semicolons are equivelent to newlines in constructs like let, where, do, etc... I think..
13:14:46 <mauke> it's the other way round
13:15:30 <Taslem> I wouldn't see any difference, you could substitute either or.
13:15:33 <ceii> right, true Haskell uses semicolons
13:15:45 <kmc> Taslem, the Haskell report explains the precise translation from whitespace to semicolons and braces
13:16:00 <Taslem> Okay, I see.
13:17:15 <xplat> xˣ.ͯхₓⅹⲭⵝ꒼ｘ𐊐𐊴𐌗𐌢𐍇𝐱𝑥𝒙𝓍𝔁𝔵𝕩𝖝𝗑𝘅𝘹𝙭𝚡
13:17:56 <ceii> I can't display half of these characters right
13:18:08 <ceii> :(
13:18:24 <Botje> ceii: most of them aren't valid unicode
13:18:27 <xplat> these are a bunch of xs in unicode.  i specifically left out chis, as well as diagonal crosses that have never been letters
13:18:46 <xplat> and also the capital of all complete case pairs
13:19:34 <xplat> botje: what do you mean?  did my paste mess up?
13:19:39 <mauke> I see all of them as valid unicode
13:19:39 <ion> botje: I may be reading this wrong, but all of them seem like valid Unicode to me.
13:19:47 <mauke> most of them not in my fonts, though
13:20:09 <ceii> If the people who cry because unicode won't include an ideogram from their name knew how many goddamn xs there are in there
13:20:10 <Botje> i'm seeing the question mark in a box thing
13:20:27 <Botje> isn't that the sign for invalid character?
13:20:44 <ion> No, just something that your font doesn’t happen to provide.
13:20:47 <xplat> botje: it's the sign for invalid character -among other things-
13:20:56 <ion> (usually)
13:21:37 <Botje> ah
13:22:41 <ion> My fonts lacked five of them.
13:24:16 <xplat> some of those are latin, some are 'mathematical latin', there's also roman numeral 10, various ancient and modern scripts related to greek and latin, one that seems unrelated but is still a letter and looks remarkably x-like, there are superscripts, subscripts, a combining x that goes above another letter, as well as a cjk fullwidth x
13:24:42 <siracusa> mauke: What was that +q supposed to do you set on Saul__L?
13:24:45 <xplat> 28 in all
13:25:10 <xplat> it would more than double if i included all the capitals and chis, i think
13:25:20 <Taslem> Is there are distinguishing aspect of Strings from a list of Chars?
13:25:27 <kmc> none Taslem
13:25:31 <kmc> type String = [Char]
13:25:34 <Botje> siracusa: silence him.
13:25:39 <Taslem> I thought so.
13:25:45 <kmc> this means that strings are woefully inefficient in space and time, which is why we have libraries like Data.Text
13:25:54 <kmc> but Strings are simple to work with and maximally lazy
13:25:57 <kmc> so they're the Prelude default
13:27:00 <xplat> i would phrase that as '[Char] was invented well before 1998 and Data.Text well after, so [Char] is the prelude default'
13:27:09 <kmc> heh
13:27:55 <kmc> i think Integer should be in Prelude and Int not, for similar reasons
13:28:55 <joe6> i am trying to send a patch to XMonadContrib and darcs record failed to record the patch with this error: http://pastebin.com/6Dw50Mic
13:29:29 <joe6> any thoughts on how I can record this patch telling darcs that I used cabal install to install this module
13:29:34 <xplat> i think my theory of 'whatever performed least horribly on ancient haskell compilers' is a more parsimonious explanation of what is actually in the prelude
13:30:02 <Heffalump> joe6: darcs record --no-test
13:30:18 <Taslem> I need a good project to work on. :/
13:30:47 <joe6> Heffalump, thanks.
13:31:02 <joe6> Taslem, check out llvm and haskell
13:31:02 <xplat> before fusion a list of characters was not a horrible choice of data structure
13:32:07 <xplat> (given the usual Haskell execution models)
13:32:43 <xplat> these days if the same committee were starting from scratch i don't think the advantages of [Char] would cut it
13:33:03 <Heffalump> [Char] is great for expository purposes and for convenience of certain kinds of operations
13:33:50 <Heffalump> and fusion can apply to lists too, so I don't really see why that made a difference to the trade-off
13:35:02 <xplat> Heffalump: because fusion speeds up array-of-small-unboxed-values-based structures way more than it speeds up lists
13:35:46 <Heffalump> I don't see why. In either case it eliminates concrete intermediate values.
13:36:08 <xplat> and also implementing fusion is at best marginally easier on lists than arrays
13:36:13 <dolio> It speeds up lists way more. Arrays of small unboxed values are already significantly faster than lists.
13:39:30 <xplat> dolio: a lot of the difference was eaten up by arrays not being as lazy and the greater copying overhead, and arrays were harder to implement even without taking that into account
13:40:05 <dolio> Lazy lists of arrays are even better.
13:40:14 <dolio> I don't think ByteString actually does much fusion.
13:40:36 <dolio> But its lazy strings are way faster than normal strings.
13:41:21 <xplat> yes, the lazy strings/unrolled lists are pretty nice
13:41:29 <xplat> being cache-tuned and all
13:41:42 <politik> http://hackage.haskell.org/platform/mac.html says that 64-bit support is experimental... anyone know if that means problems are expected, or if it is fairly stable?
13:42:35 <kmc> ByteString and String are solving different problems, though
13:42:44 <xplat> stream fusion was invented for bytestrings, though
13:42:53 <kmc> efficient packed Unicode storage is harder than efficient byte storage
13:43:37 <xplat> kmc: the real comparison here is text or utf8-string vs String, not bytestring vs string, yes
13:44:01 <dolio> text actually does fusion, though, I think.
13:44:05 <kmc> i expect so
13:44:19 <xplat> still, both of those basically blow away String
13:44:23 <kmc> something really should be done about the proliferation of copy-pasted packed array libraries
13:44:30 <kmc> if we had better module abstraction, that might be easy
13:45:30 <xplat> i can't really find much good to say about Haskell modules (the language feature, not the modules themselves)
13:46:09 <kmc> it's a simple, consistent feature
13:46:26 <kmc> aside from typeclasses, import specifiers are pretty flexible
13:46:30 <xplat> no, it's a simple, inconsistent feature
13:46:34 <kmc> i like that you can import several things qualified as a single name
13:47:14 <xplat> the modules want to form a global namespace, but that role actually belongs to packages
13:47:33 <Heffalump> simple, consistent and inflexible :-(
13:48:20 <xplat> so what the global module namespace actually accomplishes is just to give packages a way to interfere with each other and be needlessly incompatible
13:48:28 <lispy> I've really only bumped into the typeclass issues, but YMMV :)
13:50:01 <xplat> and yet, package-qualified imports are discouraged
13:50:51 <old_sound> hi, is it possible to mix ByteStrings from Data.ByteString with the ones from Data.ByteString.Lazy?
13:51:22 <old_sound> I have a function that returns the ones from Data.ByteString and then I'm using a library that expects the lazy ones… I guess I'm missing something really obvious here
13:51:23 <mauke> .oO( separate but equal )
13:51:33 <mauke> old_sound: you can convert them
13:51:38 <xplat> yeah, i understand this gives more flexibility to split and merge packages, but is it really worth the pain when it comes to things like
13:51:42 <old_sound> mauke: how?
13:52:02 <mauke> old_sound: fromChunks [s]
13:52:05 <parcs> old_sound: L8.fromChunks . S8.toChunks
13:52:17 <mauke> parcs: wait, there's a strict toChunks?
13:52:17 <xplat> how it's impossible to use monads-tf for any real purpose because you'll always end up needing to talk to something that uses mtl?
13:52:29 <mauke> parcs: what would that do?
13:52:58 <xplat> (or if you don't in the library, your clients will)
13:54:59 <xplat> (i do like the ability to merge things from a bunch of different modules into a single file-local prefix, though, that is an unusual and pleasant feature)
13:55:30 <parcs> mauke: toChunks = return :D
13:56:21 <old_sound> mauke: parcs, got it working, thanks :)
13:59:58 <kmc> L8? S8?
14:00:08 <kmc> sounds like someone's using ByteString.Char8
14:00:46 <mauke> smite them
14:01:03 --- mode: ChanServ set +o mauke
14:01:04 --- mode: mauke set -q *!*@190.186.47.246
14:01:54 --- mode: mauke set -o mauke
14:03:16 <andrus> hey, I saw the release of http://mahrz.github.com/craftwerk.html
14:03:30 <andrus> anybody know of any other image drawing/filtering libraries for haskell?
14:05:34 <aavogt> andrus: there are bindings to graphicsmagick
14:06:31 <xplat> preflex: seen conal
14:06:32 <preflex>  conal was last seen on #haskell 20 hours, 59 minutes and 12 seconds ago, saying: djahandarie: yeah. TypeCompose could be decomposed. it accumulated miscellany over time.
14:06:33 <Heffalump> xplat: now the monads-fd -> mtl change has happened, using monads-tf is no problem, is it?
14:06:45 <conal> xplat: hi
14:08:39 <xplat> conal: i was just messing around with sec-0.0.1.  aaaaaand i didn't realize it wasn't you until i just reread the license :(
14:08:43 <conal> andrus: are you looking for any particular properties in an image library? do you care about semantics/properties?
14:08:54 <conal> xplat: ah.
14:09:35 <xplat> i wonder if Steffen Siering shows up here ...
14:10:34 <andrus> conal: thanks for the info on the graphicsmagick bindings -- I assume this is hsmagick (i feel ignorant now having known only of imagemagick)
14:10:39 <conal> andrus: e.g. if you care about composability & semantics, you might like continuous & infinite images rather than discrete & finite ones. see http://stackoverflow.com/questions/5323186/writing-a-functional-and-yet-functional-image-processing-library-in-scala/5330623#5330623
14:11:23 <conal> andrus: that was aavogt . i know almost nothing about imagemagick.
14:11:59 <andrus> ah, oops. i'm in finals week and haven't slept for a while
14:12:40 <aavogt> I dunno much about it besides that it exists
14:12:49 <xplat> continuous & infinite images feel good for image synthesis
14:13:30 <conal> xplat: so much easier to compose & reason about.
14:13:39 <conal> andrus: good luck on your finals!
14:14:07 <xplat> not sure how well they would work for processing existing images.  although i think they would still handle some cases well
14:14:50 <andrus> conal: thanks, i've just got electricity and magnetism left.
14:15:06 <alpounet> interesting topic
14:15:12 <conal> xplat: might be much more elegant. and synthesis includes processing, if you care at all about compositional synthesis.
14:15:50 * conal likes composition
14:17:17 <xplat> conal: well, i think cases that would be labelled as 'synthesis based on existing samples' would go better than what's usually called 'processing'
14:18:30 <conal> xplat: what distinction(s) do you have in mind behind these two labels?
14:19:45 <xplat> well, in 'processing' it seems like you do a lot of things that make it harder to abstract away sampling
14:21:10 <conal> xplat: ah, thx. i didn't realize that some people mentally associate discreteness (sample focus) with "processing".
14:21:47 <xplat> like gaussian blurs, resizes where the scale factor is between 0.5 and 2.0 (or almost-but-not-quite a simple rational), discrete convolutions, etc
14:22:24 <xplat> er, spefically gaussian blurs with small radius relative to the sample grid
14:23:15 <xplat> also things that are specifically sampling-based like recentering pixels from camera raws
14:27:11 <xplat> i think what people mostly associate 'processing' with is you have one or two input images that make up the overwhelming majority of the content of each output image
14:27:21 <conal> xplat: yeah. this stuff can be awkward to discuss & sort out, since sometimes people are used to thinking discretely, and sometimes they're even trying to accomplish pixelish aims--as opposed to discrete approximations to continuous phenomena.
14:28:43 <conal> and it can take some sorting out to distinguish what's natural from what's habitual (a distinction from Gandhi)
14:29:05 <aristid> haskell has all the facilities to do error handling really well, but i get the feeling that the standard library does not put them to good use at all :(
14:29:22 <xplat> and the discreteness mostly comes out of trying to make the most out of that situation, where your attention to the input and output sample grids is going to have an overwhelming effect on the end result
14:30:52 <xplat> aristid: most of the standard library comes from an era before people figured out how to do error handling really well in haskell
14:31:11 <ddarius> We've figured out how to do error handling really well?
14:31:14 <aristid> xplat: have people really figured it out now, either?
14:31:21 <xplat> aristid: at least the situation is more on the magnitude of the C standard library than the C++ one ... :I
14:31:25 <dons> Maybe is a monad. game over. ;)
14:31:53 <ddarius> dons: s/Maybe/Either e/ and I agree.  In my opinion, that's how most exceptions should be handlede.
14:32:31 <ddarius> Maybe we should just do Either (Maybe e)
14:32:32 <dons> yup. Either is extremely good on the power/weight ratio here
14:32:49 <ddarius> fail = Left . const Nothing
14:33:04 <ddarius> (or I guess const (Left Nothing) ...)
14:33:15 <xplat> MonadError + throwIO for execution time + throw for when you want to be evil and mix them up
14:33:19 <aristid> fail _ = Left Nothing <- for some reason more appealing to me.
14:34:50 <aristid> dons: Maybe is easier to compose than Either e because you do not have to convert between different es
14:35:19 <ddarius> Maybe is just Either ().
14:35:27 <aristid> but it doesn't give you any data back at all, of course
14:35:27 <dons> you still have to convert between different Nothings
14:35:45 <Heffalump> it's unfortunate there are so many different options for error handling. They all make sense in themselves, but it's confusing.
14:35:48 <ddarius> Maybe is often adequate.
14:36:08 <dons> Heffalump: indeed. a guide should be prepared on best practices here. the one thing we might actually need "design patterns" for strangely
14:36:23 <dons> see also issues with laziness migrating exceptions
14:36:36 <xplat> there are a few things that need design patterns
14:36:44 <ddarius> In my opinion there are about three options that should be used, and the Either monad (or a variant) should be the one primarily used.
14:36:52 <dons> array programming is another area where there's too much choice
14:37:03 <xplat> at least we don't need ones for type-level naturals anymore
14:37:07 <dons> hehe
14:37:10 <ddarius> dons: That's gotten better.
14:37:13 <aristid> ddarius: what about EitherT?
14:37:57 <ddarius> aristid: That would fall under "or a variant."
14:37:58 <dons> http://nix-tips.blogspot.com/2011/03/how-to-choose-haskell-array-library.html 
14:38:17 <aristid> i also get the feeling that if something is already in IO, it should use the SomeException thing
14:38:35 <dons> hmm. not sure i'd agree.
14:38:45 <parcs> is it good practice to use ErrorT and throwError?
14:38:59 <dons> stick to explicitly matched stuff unless you've a good reason to move exceptions out multiple levels
14:39:01 <aristid> :t EitherT
14:39:02 <lambdabot> Not in scope: data constructor `EitherT'
14:39:10 <aristid> @hoogle EitherT
14:39:10 <lambdabot> No results found
14:39:54 <aristid> dons: matched as in... pattern matching?
14:40:43 <dons> aristid: yeah
14:40:52 <dons> explicitly checked exceptional values
14:41:34 <aristid> dons: i think there is a chapter in rwh about "staircases" somewhere :)
14:41:48 <ddarius> aristid: Occasionally the IO exception mechanism should be used, arguably, though, I think even many of those cases should be switched to EitherT IO.
14:43:01 <aristid> ddarius: should it also catch errors thrown by libraries that use SomeException and put them into the EitherT?
14:44:06 <ddarius> aristid: It depends on the situation.
14:44:41 <aristid> also once you have an EitherT ErrType IO where ErrType has a lot of constructors, that could be considered approaching SomeException
14:44:56 <ddarius> aristid: It can be EitherT SomeException for all I care.
14:45:05 <maurer_> kmc: What do you think of this for a tracing interface: http://hpaste.org/paste/44857/trace_interface#p44858
14:45:24 <ddarius> aristid: The goal would be to avoid having a large ErrType.
14:46:29 <aristid> let's say i have network-facing code. all kinds of things can go wrong in that process
14:46:48 <aristid> getAddrInfo might fail, the server might send invalid responses, it might send valid error responses
14:49:07 <xplat> i think it can be a good idea to separate errors caused by evaluation from errors caused by execution
14:49:49 <monochrom> exception is an implicit, builtin EitherT
14:50:11 <xplat> since they are conceptually separate phases one of which is being performed lazily
14:50:18 <aristid> xplat: i think the ability to catch expression errors (as in bottom) at all is a mistake
14:50:39 <tawe> @src scanl
14:50:39 <lambdabot> scanl f q ls = q : case ls of
14:50:39 <lambdabot>     []   -> []
14:50:39 <lambdabot>     x:xs -> scanl f (f q x) xs
14:51:11 <kmc> maurer_, looks reasonable.  i don't have time to think about it in depth just now
14:51:16 <kmc> (Ubuntu shipped two new kernels today...)
14:51:27 <xplat> aristid: you might be right.  but i was talking about evaluation errors that don't masquerade as bottom anyway
14:51:44 <xplat> a bottom that contains information is a type error
14:52:05 <maurer_> kmc: I assumed that process was automated :P
14:52:16 <aristid> xplat: what do you mean then? i don't quite follow
14:52:48 <ddarius> aristid: I don't understand your thrust.  I already said I feel that some things should use the (synchronous) IO exception mechanism, and my original statements had nothing to do the complexity of the error type, which doesn't become any less complex by being implicit.  However, to respond, many of the things that can go wrong with such code accidental complexity and can be hidden.  Some of the ways that things can go 
14:52:48 <ddarius> wrong, such as connection failure, should probably be less treated as exception and handled more directly.  Other things can be handled in a more localized scope.
14:52:58 <xplat> (well, a bottom that contains information is a type error in standard semantics, if you had a semantics admitting control effects it might be different)
14:53:49 <aristid> ddarius: part of it is that i'm in _just_ such a position right now, and not really sure what to do.
14:54:04 <xplat> aristid: i mean 'errors in evaluation' like the Nothing in listToMaybe
14:54:30 <aristid> xplat: that's not an error at all
14:54:38 <kmc> maurer_, lots of it is, but you can't really determine whether a rebootless patch is safe in a purely automated way
14:54:45 <xplat> aristid: it's an abstracted error
14:55:26 <aristid> xplat: depends on how you use it, i guess
14:56:02 <xplat> aristid: well, i'm talking about using it as safeHead
15:01:27 <ddarius> aristid: One aspect of this is that you should be pushing more code inward, rather than having exception percolate further outward in many situations.  Exceptions are propagated when the immediately failing code doesn't have enough information to know what to do.  Unfortunately, usually, by the time you reach a handler you're too far removed from the cause to really do anything about it.  One solution is to push the "w
15:01:27 <ddarius> hat to do about it" information inward, so it can be run in a context where the information is readily available and still able to be acted upon.
15:02:30 <runiq> ...that clears up the question I was just about to ask
15:02:37 <runiq> Thanks, ddarius. :)
15:04:04 <aristid> ddarius: thanks, i will try to keep that in mind
15:09:36 <aristid> huh, Control.Exception.catch uses fromJust to force the exception into the required type, so using catch with anything other than SomeException or IOException is probably dangerous?
15:09:49 <aristid> -IOException+IOError
15:10:18 <Heffalump> errm, I don't think it's dangerous
15:10:26 <Heffalump> @src Control.Exception.catch
15:10:26 <lambdabot> Source not found. stty: unknown mode: doofus
15:10:43 <aristid> Heffalump: http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/src/Control-Exception-Base.html#catch
15:11:16 <aristid> Heffalump: the Maybe in fromException exists for a reason, i hope
15:11:38 <aristid> i would have re-thrown exceptions with the wrong type
15:12:00 <Heffalump> aristid: that seems to be the NHC implementation only
15:12:31 <aristid> Heffalump: oh. so the NHC implementation is just buggy
15:12:33 <Heffalump> which is still odd, but I'm sure the GHC one does the right thing
15:12:35 <aristid> phew
15:12:39 <edwardk> preflex: xseen cale
15:12:39 <preflex>  cale was last seen on freenode/#haskell 1 day, 23 minutes and 28 seconds ago, saying: (Ryan Trinkle)
15:12:44 <aristid> Heffalump: thank you!
15:13:02 <Heffalump> you had me worried too :-) But when I searched for what H'98 is, I saw the NHC guard.
15:13:39 <aristid> Heffalump: i guess we should submit a bug report to NHC?
15:14:22 <Heffalump> I guess so
15:14:54 <monochrom> catch = GHC.IO.catchException
15:15:19 <Heffalump> yeah, I didn't follow that through. The Hugs implementation is explicit.
15:15:42 <monochrom> perhaps the fromJust is perfectly safe in NHC
15:16:44 <aristid> Heffalump: actually, it seems like NHC just doesn't really have exception support
15:26:10 <aristid> :t Control.Exception.try
15:26:10 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
15:26:39 <tew88> I'm, working my way through LYAH and have just ran into a snippet of code that isn't making a great deal of sense to me. Could anyone explain the need for the return function in the following piece of code? http://pastebin.com/eyWBsme1
15:26:45 <aristid> :t Control.Exception.try >=> Control.Exception.try
15:26:46 <lambdabot>     Couldn't match expected type `Either e a'
15:26:46 <lambdabot>            against inferred type `IO a1'
15:26:46 <lambdabot>     In the second argument of `(>=>)', namely
15:27:06 <kmc> tew88, it's not necessary; that block could just end with "getLine"
15:27:08 <hpc> tew88: so, let's see what forM does
15:27:09 <hpc> :t forM
15:27:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
15:27:19 <aristid> :t \a -> Control.Exception.try a >>= Control.Exception.try
15:27:19 <kmc> do { x <- a; return x } ≡ do { a }
15:27:19 <lambdabot>     Couldn't match expected type `Either e a'
15:27:19 <lambdabot>            against inferred type `IO a1'
15:27:20 <lambdabot>     In the second argument of `(>>=)', namely
15:27:42 <hpc> tew88: so we give it a list of things, it applies an action, and the result of the whole thing is the action performed to each item in sequence
15:27:52 <hpc> so the action we give it is:
15:27:58 <hpc> ( \ a -> do...
15:28:00 <hpc> return color
15:28:06 <aristid> :t Control.Exception.try . Control.Exception.try
15:28:06 <lambdabot> forall e a e1. (GHC.Exception.Exception e, GHC.Exception.Exception e1) => IO a -> IO (Either e (Either e1 a))
15:28:13 <kmc> tew88, i think the superfluous return makes it more readable to someone who's not used to first-class IO, but that's not really a good reason to keep it imo
15:28:28 <tew88> kmc: With it omitted, I get an error: The last statement in a 'do' construct must be an expression
15:28:36 <kmc> tew88, you can't end with "colour <- getLine"
15:28:40 <kmc> but you can end with "getLine"
15:28:47 <tew88> Ahha
15:28:59 <hpc> so the result of that action is going to be whatever the color is; all the colors get put in the list that becomes colors
15:29:02 <kmc> if you read about how "do" syntax is translated into uses of the (>>=) function, this will make more sense
15:29:16 <hpc> or kmc can type really fast and more coherently, that's okay too :P
15:29:25 <copumpkin> > partition' even [0..]
15:29:26 <kmc> "colour <- getLine" roughly translates to "getLine >>= \colour ->" which would be a syntax error; that lambda has no body
15:29:26 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
15:29:40 <copumpkin> > snd $ partition' even [0..]
15:29:42 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
15:29:44 <tew88> Right. Thank you very much!
15:29:44 <kmc> but "colour <- getLine; return colour" translates to "getLine >>= \colour -> return colour"
15:29:47 <copumpkin> > snd $ partition even [0..]
15:29:47 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
15:29:53 <kmc> which is just "getLine >>= return"
15:29:58 <hpc> :t partition
15:29:59 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:30:03 <kmc> and it's a law that "x >>= return" ≡ x
15:30:13 <tew88> kmc: I'll look it up. Thank you.
15:30:14 <hpc> if you break that law, god help you
15:30:16 <hpc> :P
15:31:07 <mreh> Not even god can help you
15:31:54 <btutt> *crosses fingers* going to upgrade to OS X 10.6 with a clean install that should be fun. Get to install HP after. :)
15:32:20 <hpc> mreh: ^^
15:32:50 <gnezdo> I am trying to fix a function so it doesn't blow stack. The function is :: [a] -> (SomeStatistic, [a]). Implemented with mapAccumL it naturally blows stack.
15:33:17 <gnezdo> the input and output [a] are the same length with some elements munged.
15:33:44 <gnezdo> Any suggestions?
15:33:53 <hpc> :t mapAccumL
15:33:54 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:33:58 <hpc> @src mapAccumL
15:33:59 <lambdabot> mapAccumL _ s []        =  (s, [])
15:33:59 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
15:33:59 <lambdabot>    where (s', y ) = f s x
15:33:59 <lambdabot>          (s'',ys) = mapAccumL f s' xs
15:34:21 <gnezdo> Of course I also want to be lazy and not have all of [a] in memory :)
15:34:40 <hpc> lazy != not everything in memory
15:34:59 <hpc> in fact, lazy/strict generally implies almost nothing about performance
15:35:01 <gnezdo> yeah, yeah, I want it to be evaluated as I go
15:35:08 <hpc> without knowing other details :P
15:35:58 <hpc> play around with strictness annotations or seq, perhaps
15:36:16 <gnezdo> mapAccumL probably will kill me no matter what
15:36:19 <Eduard_Munteanu> @hoogle mapAccumL
15:36:19 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
15:36:19 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:36:19 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
15:36:21 <gnezdo> so I need a replacement
15:36:32 <Eduard_Munteanu> :t foldr
15:36:32 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:36:34 <gnezdo> a different approach rather
15:36:38 <Liskni_si> I guess adding a bang pattern to s' should just work
15:37:03 <hpc> also, it will be worth looking at how you read from your answer
15:37:11 <Watermind> is there some usual way to denote an instantiation relation between types?    i.e.    B ? A      whenever  B = A[C/a]   for some type C and type var a
15:37:28 <hpc> the difference between print (xs !! a kajillion) and map print xs can be astounding
15:37:48 <Eduard_Munteanu> I think you might want mapAccumR if it's anything like foldr.
15:38:03 <hpc> @src mapAccumR
15:38:03 <lambdabot> Source not found. Maybe you made a typo?
15:38:08 <hpc> :t mapAccumR
15:38:09 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:38:13 <hpc> :t mapAccumL
15:38:14 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:39:00 <Eduard_Munteanu> Right folding usually makes better producers and it's better for lazy stuff.
15:39:24 <gnezdo> mapAccumR doesn't make a differenc3
15:39:27 <mauke> I'm pretty sure that only applies to foldr itself
15:39:32 <Saizan> mapAccumL would actually be lazier
15:39:50 <Saizan> well, it all depends on how you use the accumulator
15:41:34 <hpc> yeah, if the accumulator is strict in the whole list, you might want to (foldl' (:) []) the right hand list (i think that gets rid of those thunks without overflowing)
15:41:43 <Eduard_Munteanu> @src mapAccumL
15:41:43 <lambdabot> mapAccumL _ s []        =  (s, [])
15:41:43 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
15:41:43 <lambdabot>    where (s', y ) = f s x
15:41:43 <lambdabot>          (s'',ys) = mapAccumL f s' xs
15:42:49 <Saizan> see how y doesn't depend on info from the recursive call? so when you're going to force the list in order there's no risk of having to force the tail to get the head
15:42:57 <Eduard_Munteanu> > mapAccumL (\acc x -> (acc + x, x)) 0 [1,2,3]
15:42:58 <lambdabot>   (6,[1,2,3])
15:43:07 <gnezdo> OK, let me just dump the whole fragment into hpaste
15:43:08 <Eduard_Munteanu> > mapAccumL (\acc x -> (acc + x, x+1)) 0 [1,2,3]
15:43:08 <lambdabot>   (6,[2,3,4])
15:43:22 <Eduard_Munteanu> Hrm.
15:44:17 <Eduard_Munteanu> So it's just (map, foldl) ?
15:44:57 <Eduard_Munteanu> Ah, no, you can actually mess with the accumulator in the mapping function.
15:45:13 <Eduard_Munteanu> > mapAccumL (\acc x -> (acc + x, acc + x)) 0 [1,2,3]
15:45:14 <lambdabot>   (6,[1,3,6])
15:45:17 <Saizan> it's mapM for State
15:45:24 <Eduard_Munteanu> Oh.
15:45:50 <Saizan> mapAccumR is mapM for the inverse/backwards state monad instead
15:45:59 <Eduard_Munteanu> Well in this case, the right version should still be better, wouldn't it?
15:46:27 <Saizan> what is the current case?
15:46:35 <Eduard_Munteanu> Unless you're using it on strict stuff.
15:46:46 <Eduard_Munteanu> Yeah, you're right, I'm guessing.
15:47:26 <gnezdo> http://hpaste.org/44860/mapaccuml_and_friends
15:47:35 <hpc> :t (second &&& first) . mapM
15:47:36 <lambdabot> forall d d1 a (m :: * -> *) b. (Monad m) => (a -> m b) -> ((d, [a]) -> (d, m [b]), ([a], d1) -> (m [b], d1))
15:47:49 <hpc> :t mapM
15:47:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:48:13 <hpc> eh, close enough
15:48:24 <Eduard_Munteanu> A-ha.
15:48:53 <Saizan> gnezdo: try with "!updatedC = ClampOut {" for line 25
15:48:59 <Eduard_Munteanu> So indeed the left variant looks better.
15:49:43 <Saizan> gnezdo: are you compiling with -O2 ?
15:49:45 <gnezdo> Eduard_Munteanu: still blows the stack
15:49:55 <gnezdo> Saizan: just playing in ghci for now
15:50:03 <gnezdo> stupid?
15:50:11 <gnezdo> lemme compile
15:50:52 <Eduard_Munteanu> If not, you might want to do  clamp c x = c `seq` x `seq` ...
15:51:18 <Eduard_Munteanu> I'm not sure the bang stuff does what you need otherwise.
15:52:53 <Eduard_Munteanu> (erm, 'clamper')
15:53:17 <gnezdo> it's actually more fun still: print ss at the bottom never completes
15:53:29 <gnezdo> the program just eats all the memory there is
15:55:10 <Saizan> ok, so the stack overflow was probably sum
15:55:51 <gnezdo> Saizan: nope, I get it with
15:55:52 <gnezdo> *Main> fst $ clampWarnComplexList 15 (zipWith (:+) [0..2^20] [0..2^20])
15:55:57 <gnezdo> *** Exception: stack overflow
15:56:04 <gnezdo> or at least there's more than one way to get it
15:56:29 <djahandarie> monochrom, I don't think it does TCO
15:56:50 <dons> gnezdo: try running in ghc -O2, then tell us if it still fails?
15:56:57 <monochrom> clamper !c x = (updatedC, if hadClamp then clampedX else x)  is a recipe for building a deep "if ? then ? else (if ? then ? else (if ? then ? else (..."
15:57:12 <accel> why does haskell bitch when i have a literate tab (rather than a \t) in my strings in a *.hs file?
15:57:47 <monochrom> why ask why?
15:57:48 <Eduard_Munteanu> accel: with -Wall ?
15:58:07 <Eduard_Munteanu> accel: -Wall can sometimes be a little more than you want.
15:58:27 <monochrom> without -Wall. I just ran into it earlier today.
15:59:51 <gnezdo> dons: OK, success wrt getting the clamped output ([a]) out with -O2
16:00:14 <gnezdo> and yes, I removed the 'if hadClamp then' too
16:00:37 <gnezdo> though, it should not get nested
16:00:46 <dons> so there's some unintentional laziness, that the strictness analyzer catches. you could also remove it explicitly to be on the safe side
16:01:04 <gnezdo> where is it?
16:01:18 <Eduard_Munteanu> You could sprinkle a few 'seq's in there.
16:01:29 <monochrom> I impeach "x".
16:01:36 <hpc> -Wall isn't so bad by itself
16:01:50 <hpc> -Werror makes it too much
16:01:59 <Eduard_Munteanu> clamp c x = c `seq` x `seq` ...
16:02:18 <hpc> or clamp !c !x = ...
16:02:22 <hpc> if that extension is enabled
16:02:24 <Eduard_Munteanu> hpc: I've seen a few C apps using -Werror by default in their build system ;)
16:02:28 <monochrom> I mean I impeach "if hadClamp then clampedX else x" and to solve it I guess "clamper !c !x = ..."
16:02:42 <hpc> Eduard_Munteanu: damned good policy if you ask me
16:02:54 <Eduard_Munteanu> I'm not sure how well '!' works without -On
16:03:11 <monochrom> I am sure ! becomes seq
16:03:23 <hpc> i hate compiling something, and having warnings spam my console
16:03:50 <ddarius> Stop compiling things.
16:04:27 <accel> i never compile my code
16:04:32 <accel> i just hand it to chinese teenagers 
16:04:34 <Eduard_Munteanu> hpc: have you been spoiled by build systems like the kernel's, which are pretty much silent? :)
16:04:36 <accel> and tell them to execute it in their head
16:04:54 <mreh> abacuses here
16:04:56 <Eduard_Munteanu> Heh.
16:05:06 <monochrom> ghc --make -O main.hs > /dev/null 2> /dev/null
16:05:13 <monochrom> in fact...
16:05:23 <Eduard_Munteanu> 2>&1 >/dev/null :)
16:05:23 <monochrom> ghc -v5000 --make -O main.hs > /dev/null 2> /dev/null
16:05:40 <monochrom> in fact, 2>&1 >/dev/null is the wrong order.
16:05:59 <hpc> Eduard_Munteanu: i've been spoiled with only usually compiling my own code
16:06:43 * dons sez: always use -O2 if you care enough to use -O 
16:07:01 <dons> may as well use SPJ's brain while you've got it right there.
16:07:08 <hpc> my website's compilation process is pretty much just a series of "COMPILATION NOT NEEDED" followed by all the scripts linking in about 2 seconds each
16:08:31 <djahandarie> Can I use SPJ's brain when I don't have it present?
16:08:57 <hpc> > unsafeUseSPJ'sBrain
16:08:58 <lambdabot>   Not in scope: `unsafeUseSPJ'sBrain'
16:09:02 <monochrom> download SPJ's brain at http://www.haskell.org/ghc/download_ghc_7_0_2
16:09:20 <hpc> @let unsafeUseSPJ'sBrain = error "Brain not Found!"
16:09:21 <lambdabot>  Defined.
16:09:26 <shachaf> "Given a sufficiently smart compiler-writer"?
16:09:27 <hpc> > unsafeUseSPJ'sBrain
16:09:29 <lambdabot>   *Exception: Brain not Found!
16:09:31 <hpc> :D
16:10:01 <Cin> lol
16:10:32 <dons> -O2 turns on stuff SPJ thinks up
16:10:33 <luite> einsteinbraaain
16:10:53 <hpc> http://www.kleinbottle.com/drinking_mug_klein_bottle.htm
16:11:04 <Cin> -fcambridge-extensions
16:11:08 <Eduard_Munteanu> Mmm, does it also turn on strict field unboxing for pragma-annotated stuff?
16:11:38 <Eduard_Munteanu> (IIRC it did)
16:11:41 <drdo> Is Learn you a Haskell any good?
16:11:48 <Entroacceptor> yes
16:11:49 <monochrom> yes, it's very good
16:11:59 <geheimdienst> it will definitely learn you a haskell
16:12:01 <drdo> Why would you implement assoc (findKey) with a foldr?
16:12:12 <drdo> And then claim it's clearer
16:12:15 <monochrom> depends
16:12:31 <drdo> it's not only less clear but less efficient too
16:13:15 <tieTYT> i'm using cygwin and ghci.  Pressing the up key isn't showing my last line though, it's just jumping one line up
16:13:25 <tieTYT> i installed ghc today
16:13:33 <drdo> monochrom: on what?
16:13:42 <Eduard_Munteanu> tieTYT: you probably shouldn't be using Cygwin, AFAIR it's really old.
16:13:52 <monochrom> on what is assoc, what is findKey, and what is clearer.
16:14:03 <Eduard_Munteanu> tieTYT: try MSYS' bash if you want a shell on Windows.
16:14:10 <Eduard_Munteanu> MinGW/MSYS
16:14:19 <drdo> finding a value by key on an association list
16:14:32 <monochrom> oh, that's a foldr
16:14:38 <Eduard_Munteanu> :)
16:14:38 <drdo> why?
16:15:01 <Eduard_Munteanu> :t assoc
16:15:02 <lambdabot> Not in scope: `assoc'
16:15:17 <drdo> i call it assoc because i'm used to lisp
16:15:24 <Eduard_Munteanu> :t lookup
16:15:24 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:15:28 <hpc> @src lookup
16:15:28 <lambdabot> lookup _key []          =  Nothing
16:15:28 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
16:15:28 <lambdabot>                         | otherwise = lookup key xys
16:15:42 <mauke> lookup kx = foldr (\(k, v) z -> if k == kx then Just v else z) Nothing
16:15:58 <monochrom> my "is" does not mean "equal". my "is" means "a special case of"
16:16:01 <drdo> Won't that iterate through the list twice?
16:16:13 <mauke> drdo: what? why twice?
16:16:22 <hpc> drdo: here's a visual that will help you learn to fold:
16:16:27 <monochrom> so, finding a value by key on an association list is a special case of foldr, can be done with a foldr, etc.
16:16:49 <drdo> I understand foldr
16:16:56 <mauke> drdo: then why twice?
16:16:57 <hpc> fold (*) z list converts the list from a:b:c:...:[] to a*b*c*...*z
16:17:06 <hpc> the z replaces the []
16:17:11 <hpc> and the (*) replaces the (:)
16:17:23 <hpc> the r/l determines what direction the parentheses go in
16:17:32 <tieTYT> Eduard_Munteanu: ok
16:17:33 <drdo> mauke: first you need get to the end to start reducing
16:17:34 <tieTYT> thanks
16:17:39 <mauke> drdo: no, I don't
16:17:47 <drdo> how so?
16:17:56 <mauke> why would I?
16:18:00 <monochrom> > foldr (\(k, v) z -> if k == 0 then Just v else z) Nothing (repeat (0,'x'))
16:18:01 <lambdabot>   Just 'x'
16:18:04 <Eduard_Munteanu> tieTYT: and you'd be using it with the regular Haskell Platform for Windows
16:18:10 <mauke> drdo: even so it would only scan the list once
16:18:29 <drdo> mauke: How do you get to the last element if not in linear time?
16:18:34 <monochrom> my example traverses an infinite list twice
16:18:39 <mauke> drdo: I don't get to the last element
16:18:48 <mauke> drdo: well, not if I find the key elsewhere first
16:18:53 <hpc> how do you know you need to get to the last element?
16:19:16 <monochrom> by "I understand foldr"
16:19:22 <drdo> I'm probably missing something, probably related to laziness
16:19:25 <Cale> foldr f z [1,2,3] --> f 1 (foldr f z [2,3])
16:19:29 <hpc> lookup in a list is always going to be O(n)
16:19:31 <hpc> it can't not be
16:19:31 <Cale> and then it's f's turn
16:19:39 <hpc> even if it is sorted
16:19:46 <Eduard_Munteanu> foldr (\(k, v) z -> if k == 0 then Just v else z) Nothing ((0,'x'), (1,'y'), error "foo")
16:19:49 <Eduard_Munteanu> > foldr (\(k, v) z -> if k == 0 then Just v else z) Nothing ((0,'x'), (1,'y'), error "foo")
16:19:50 <lambdabot>   Couldn't match expected type `[(t, t1)]'
16:19:50 <lambdabot>         against inferred type `((t...
16:20:16 <Eduard_Munteanu> > foldr (\(k, v) z -> if k == 0 then Just v else z) Nothing ((0,'x'), (1,'y'), (5,error "foo"))
16:20:17 <lambdabot>   Couldn't match expected type `[(t, t1)]'
16:20:17 <lambdabot>         against inferred type `((t...
16:20:19 <drdo> Cale: Then you are growing the stack
16:20:20 <Eduard_Munteanu> Bah.
16:20:20 <Cale> drdo: In a limited sense, foldr is always O(1), in that it always passes control to f in constant time
16:20:25 <monochrom> > foldr (\(k, v) z -> if k == 0 then Just v else z) Nothing [(0,'x') , (1,'y') , error "foo"]
16:20:25 <lambdabot>   Just 'x'
16:20:26 <Cale> drdo: No stack
16:20:42 <Cale> drdo: The stack grows according to pattern matches which are waiting to happen.
16:20:52 <hpc> drdo: the function you are folding (which we will say is \elem list -> something)
16:21:03 <hpc> will only evaluate the remainder of the list if it has to evaluate "list"
16:21:09 <Cale> drdo: (It consists of case expressions which are waiting for their scrutinee to be sufficiently evaluated to pattern match)
16:21:15 <hpc> if it only evaluates "elem", it doesn't continue folding
16:21:24 <Cale> drdo: Lazy evaluation is outermost-first
16:21:42 <drdo> hmm
16:21:57 <Cale> So it's f which is evaluated there, and it's passed '1' and 'foldr f z [2,3]' as parameters
16:22:04 <monochrom> this is why you should gather empirical evidence first
16:22:14 <Cale> only if it decides to pattern match on its second parameter will control return to folr
16:22:16 <Cale> foldr*
16:22:18 <gnezdo> http://hpaste.org/44865/mapaccuml_and_friends_annotat 
16:22:30 <gnezdo> well, now it only chews enormous amounts of heap
16:22:39 <geheimdienst> drdo: the r in foldr does not mean that the list gets processed right-to-left, just to clarify
16:22:52 <Cale> (or if it returns something based on its second parameter, and something from outside pattern matches on it)
16:23:07 <drdo> geheimdienst: I thought it did
16:23:09 <Cale> It means that the expression tree which is generated leans to the right
16:23:49 <Cale> http://upload.wikimedia.org/wikipedia/commons/3/3e/Right-fold-transformation.png
16:23:55 <drdo> I guess i'm really just not used to laziness and need to think about it 
16:24:01 <Cale> http://upload.wikimedia.org/wikipedia/commons/5/5a/Left-fold-transformation.png
16:24:33 <Cale> Let's evaluate that lookup thing using foldr
16:24:58 <geheimdienst> drdo: that must be a misunderstanding then. foldr *doesn't* go to the end of the list, then work backwards, or anything like that
16:25:11 <Cale> lookup kx = foldr (\(k, v) z -> if k == kx then Just v else z) Nothing
16:25:30 <drdo> geheimdienst: I was thinking exactly that, that's why i was going crazy
16:25:40 <monochrom> some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748) and find one single student who faithfully evaluate 389238493+97283748 first.
16:25:40 <geheimdienst> (i had that misunderstanding myself for quite a while)
16:25:57 <kmc> hahaha monochrom
16:26:02 <Cale> lookup 2 [(1,"hello"),(2,"there"),(3,"world")]
16:26:08 <kmc> @remember monochrom some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748) and find one single student who faithfully evaluate 389238493+97283748 first.
16:26:08 <lambdabot> Okay.
16:26:16 <hpc> > 0 * (error "the hell with this")
16:26:17 <lambdabot>   *Exception: the hell with this
16:26:21 <hpc> D:
16:26:22 <Cale> -> foldr (\(k, v) z -> if k == 2 then Just v else z) Nothing [(1,"hello"),(2,"there"),(3,"world")]
16:26:34 <kmc> hpc, it would work with inductive naturals...
16:26:38 <kmc> > 0 :: Natural
16:26:39 <lambdabot>   Not in scope: type constructor or class `Natural'
16:26:40 <kmc> > 0 :: Nat
16:26:41 <lambdabot>   Not in scope: type constructor or class `Nat'
16:26:46 <kmc> Cale, where did they go? :/
16:26:48 <Cale> -> (\(k, v) z -> if k == 2 then Just v else z) (1,"hello") (foldr (\(k, v) z -> if k == 2 then Just v else z) Nothing [(2,"there"),(3,"world")])
16:26:52 <drdo> monochrom: I've been programming for a long time in strict evaluation languages :P
16:26:53 <Cale> kmc: not sure
16:27:07 <monochrom> the truth is that the "()" in "a*(b+c)" tells you how to parse, not how to evaluate.
16:27:16 <kmc> would it only work for 0*n and not n*0?
16:27:22 <Cale> -> (\z -> if 1 == 2 then Just "hello" else z) (foldr (\(k, v) z -> if k == 2 then Just v else z) Nothing [(2,"there"),(3,"world")])
16:27:36 <Cale> -> if 1 == 2 then Just "hello" else (foldr (\(k, v) z -> if k == 2 then Just v else z) Nothing [(2,"there"),(3,"world")])
16:27:40 <monochrom> and similarly "f x (foldr blablah)" tells you how to parse, not how to evaluate.
16:27:46 <Cale> -> foldr (\(k, v) z -> if k == 2 then Just v else z) Nothing [(2,"there"),(3,"world")]
16:27:51 <hpc> kmc: it depends on how the patterns are ordered
16:28:05 <Cale> drdo: I should be putting this on hpaste, but do you see what's happening here?
16:28:07 <hpc> but you have to evaluate one before the other, no matter what
16:28:45 <mauke> unless you use magic
16:28:46 <phreak> hello fellow geniuses
16:28:59 <mauke> what was it called? unamb?
16:29:10 <hpc> :t unamb
16:29:11 <lambdabot> Not in scope: `unamb'
16:29:12 <kmc> i love unamb
16:29:21 <kmc> actually i love 'lub' even more
16:29:31 <gnezdo> I guess I came to a point where it is obvious that all of my huge input xs will stay in memory.
16:29:38 <gnezdo> http://hpaste.org/44867/mapaccuml_and_friends_annotat
16:29:42 <kmc> (2,⊥) `lub` (⊥,3) ≡ (2,3)
16:30:00 <gnezdo> so, I need something other than (ClampOut a, [a]) as output 
16:30:33 <gnezdo> because both of them require the input list to be evaluated
16:30:38 <phreak> hey guys, what's the most generic/precise term there is for a data structure which associates by cartesian points? so if you have an array, you have a series of objects. well i want multiple sets of series of objects (rows) with named positions in the series (columns)
16:30:43 <phreak> like a database table
16:30:45 <Cale> http://hpaste.org/44868/lookup_via_foldr
16:30:51 <phreak> but for each 'coordinate' to associate to an object
16:31:11 <Cale> drdo: ^^
16:31:25 * dolio has uneasy feelings about unamb/lub.
16:31:30 <hpc> kmc: how does that even?
16:32:15 <hpc> phreak: you mean like a matrix?
16:32:25 <hpc> oh, nvm
16:32:29 <BMeph> phreak: You mean like a table? ;p
16:32:35 <hpc> @hoogle table
16:32:35 <lambdabot> Text.Html table :: Html -> Html
16:32:35 <lambdabot> Text.XHtml.Frameset table :: Html -> Html
16:32:35 <lambdabot> Text.XHtml.Strict table :: Html -> Html
16:32:39 <hpc> :(
16:32:53 <phreak> what's the diff between a matrix and a table?
16:34:00 <hpc> a matrix has rows and columns indexed by Nats
16:34:06 <hpc> ie, like a real matrix :P
16:34:10 <Cale> I would normally assume that the elements of a matrix come from a ring.
16:34:22 <phreak> nats?
16:34:24 <monochrom> I hope you love the lub and glb in http://www.vex.net/~trebla/tmp/lub.png :)
16:34:27 <hpc> natural numbers
16:34:34 <hpc> though Cale probably knows more
16:34:48 <Cale> 'table' isn't a precise term
16:34:55 <Cale> So it's hard to say what the difference is
16:35:02 <phreak> cale, so what would you name a structure which maintains refs to objects in a x/y axis way?
16:35:37 <monochrom> 11-dimension arrays are not unheard of
16:35:59 <phreak> what?
16:36:05 <Cale> phreak: I don't know, a two-dimensional array?
16:36:12 <monochrom> 11-dimension arrays
16:36:26 <Cale> "table" isn't a terrible name
16:36:56 <monochrom> oh, you want me to say 11-dimension tables? I don't mind.
16:37:00 <geheimdienst> drdo: btw, i found this page very clear: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
16:37:46 <drdo> dead link
16:37:59 <shachaf> > foldl' f z [a,b,c] -- Lambdabot should use a special version of seq that shows how this is actually evaluated.
16:38:00 <lambdabot>   f (f (f z a) b) c
16:38:01 <monochrom> not dead link here. ensure you have the ' at the end
16:38:06 <drdo> oh yes
16:39:48 <Saizan> gnezdo: you can fix the heap usage by using this main instead http://hpaste.org/paste/44865/mapaccuml_and_friends_annotat#p44869
16:43:37 <gnezdo> Saizan: OK, this is black magic, how is your version different?!
16:43:55 <gnezdo> I mean I see textual differences, but don't grasp the sematic ones
16:45:23 <Saizan> case forces evaluation of the (,) constructor right away, while using let will defer that
16:45:36 <Saizan> this has consequences for gc
16:46:14 <drdo> I think i understand it know
16:46:24 <Saizan> since the 'ss' thunk which you force later will still reference the whole tuple, so the list 'rs' can't be gc'ed as it is traversed
16:46:28 <gnezdo> Oh, another fun thing, if I swap the 2 prints, heap blow up is back
16:47:31 <gnezdo> Thanks Saizan, this is subtle...
16:47:45 <Heffalump> I thought there was a selector optimization for that situation, or does that only apply to case?
16:48:43 <Saizan> Heffalump: i thought there was too, but also that it's still quite tricky
16:49:37 <kmc> 'selector thunks'
16:49:58 <kmc> anyway that's in the realm of relying on very specific GHC behavior that changes between versions
16:50:19 <gnezdo> kmc: any suggestion on how to avoid that?
16:50:23 <kmc> whereas case forcing the scrutinee to whnf as long as there's a constructor pattern is something most Haskell implementations will do
16:53:22 <monochrom> oh w00t, haskell weekly news has a web version now
16:55:20 <Eduard_Munteanu> Grr, it'd suck if that kind of subtle stuff crept in often.
16:55:30 <Eduard_Munteanu> gnezdo: what GHC version is that?
16:55:49 <gnezdo> 6.12.1
16:55:56 <Eduard_Munteanu> Mm, reasonable.
16:56:09 <gnezdo> I need it to run on 6.8.3 eventually :)
16:56:32 <phreak> i thought the drawing scheme in cocoa touch is that you specify x/y coordinate (origin of frame) and that's from top left. so it progresses down and to the right. but then drawing happens from origin up and to the right
16:56:39 <phreak> but it doesn't seem to
16:56:43 <phreak> it seems to draw down and right
16:57:05 <phreak> because i had to make my y be 0 otherwise my view began drawing from bottom of screen downward (invisible)
16:57:05 * BMeph chills out to "Paisan Saizan and the Selector Thunks"... ;þ
16:59:16 <Saizan> the major problem here is that we want to be tail recursive and strict in the state, while lazy on the list..
16:59:41 <gnezdo> I'm not above replacing mapAccumL with a custom function :)
16:59:46 <monochrom> the nature of mapAccumL makes it a bit harder
17:01:32 <Saizan> BMeph: wrong part of italy :)
17:02:21 <fmapE> so does /usr/local/include count as a "non-standard location" for header files according to cabal-install?
17:02:49 <gnezdo> http://hpaste.org/44870/mapaccuml_and_friends_annotat <- the latest with complex stuff taken out
17:02:52 <fmapE> because it complains that it can't find a header in that directory
17:03:05 <fmapE> unless I give it the extra-include-dirs flag
17:03:08 <gnezdo> if the two bottom lines are swapped - heap goes out
17:08:10 <drdo> Hmm, i just tried to create a Map with 999999 entries and ghc is taking forever and already at 370MB
17:09:22 <kmc> compiling your program?
17:09:32 <drdo> making the map
17:09:48 <kmc> how is it ghc that's taking forever?
17:10:08 <Zao> Did you perhaps mean "GHCi"?
17:10:19 <kmc> i would not expect that to work well in ghci
17:10:23 <kmc> compiled code is much more efficient
17:10:26 <kmc> (you should use ghc --make -O)
17:10:29 <drdo> ghci doesn't compile?
17:10:32 <Zao> Not that it's not a strange choice of words then too.
17:10:37 <kmc> you can load that compiled code into your ghci session
17:10:54 <kmc> drdo, it compiles to a bytecode of sorts, but it's still slower and various optimizations don't work etc.
17:11:23 <kmc> when you load a module (":m +") it will look for a .o and .hi file and if they exist will load those instead of the .hs source
17:11:30 <drdo> I thought it compiled to native code even interactively
17:11:37 <kmc> nope
17:13:21 <monochrom> well it works quickly for me.
17:13:32 <monochrom> let x = fromList [ (x :: Int,()) | x<-[1..999999] ]
17:13:35 <monochrom> seq x ()
17:13:44 <monochrom> (that takes just a few seconds)
17:13:57 <monochrom> Data.Map.lookup 4 x
17:14:03 <monochrom> Data.Map.lookup 9999999 x
17:14:11 <monochrom> those are instantaneous
17:14:16 <monochrom> all these are in ghci
17:14:44 <drdo> I guess it might be the the zip then
17:15:22 <monochrom> 126MB memory
17:15:25 <Saizan> gnezdo: i think now the problem is that if you print ss first it has to force and keep in memory the whole (take n (zipWith (:+) xs xs)) since it has to use that to compute rs later
17:16:43 <monochrom> it is so easy and unscientific to make guesses
17:17:01 <Saizan> i've been doing some experimentation on the side
17:18:40 <gnezdo> yeah, this makes sense. So I will have to consume the big list first and the get the stats
17:19:15 <monochrom> let y = fromList (zip [1 :: Int ..999999] (repeat ()))
17:19:29 <monochrom> that is a similar experiment using zip
17:20:17 <monochrom> seq y () is just as fast, lookups are again instantaneous
17:20:31 <monochrom> it is so easy and unscientific to guess
17:22:10 <monochrom> changing "Int" to "Integer" doesn't seem to hurt either
17:22:13 <joe6> anyone used the parseBitcode of LLVM/Core/FFI?
17:23:51 <monochrom> why do programming schools still not include the training of the scientific method?
17:24:10 <kmc> monochrom, scientific method, is there a button for that in VS.NET?
17:24:20 <kmc> or is it more of a J2EE / Rails thing
17:24:39 <joe6> monochrom, was that meant for me?
17:24:44 <monochrom> no
17:30:44 <Saizan> http://hpaste.org/paste/44870/mapaccuml_and_friends_annotat#p44872 <- saving space by duplicating work :)
17:32:40 <gnezdo> Saizan: any reason this is better than a (map foo xs, foldl' bar xs) ?
17:33:23 <Saizan> gnezdo: no, it just required less rearranging of code for me
17:33:32 <gnezdo> :)
17:33:38 <Saizan> (though also a custom mapAccumL)
17:34:01 <gnezdo> I guess, I shouldn't really expect magic here.
17:34:20 <gnezdo> Even if this were done in a strict language, I'd probably run into the same problems
17:34:53 <gnezdo> not just strict, with mutable variables too
17:36:02 <Saizan> in a strict language you'd have to make the sum rs in the same loop that produces the initial xs to even be able to get that sum in constant space
17:36:28 <Saizan> or use something like python generators, i guess (which are lazy list anyhow)
17:37:26 <gnezdo> I think I will go with your first version and selector thunks :) I control the call sites, I can afford it
17:38:04 <Saizan> selector thunks are what that version avoids, afaiu the terminology :)
17:38:07 <jmcarthur> @djinn (b -> c) -> (a -> b) -> (a -> c)
17:38:07 <lambdabot> f a b c = a (b c)
17:39:23 <gnezdo> yeah, duplicating work is not so hot: It makes the code run for 25% longer :)
17:40:00 <aristid> @. pl djinn (b -> c) -> (a -> b) -> (a -> c)
17:40:00 <lambdabot> f = (.)
17:40:13 <aristid> \o/
17:40:28 <Saizan> it's a bit surprising for me that the heap can grow that much here
17:40:41 <aristid> @. pl djinn (a -> b) -> (b -> c) -> (a -> c)
17:40:41 <lambdabot> f = flip (.)
17:41:49 <Eduard_Munteanu> I'm more than surprised by the problems gnezdo encountered.
17:42:16 <gnezdo> I'm always open to nice solutions :)
17:51:29 <joe6> what does the | mean in: class (CmpRet a b) => Cmp a b | a -> b where
17:51:47 <kmc> the stuff to the right is a "functional dependency"
17:51:58 <kmc> means that for each type a, there's only one choice of b
17:52:12 <kmc> in other words, forbids «instance Cmp A B» and «instance Cmp A C» from coexisting
17:52:26 <hpc> joe6: it is a fundep
17:52:35 <joe6> ok, thanks.. something like an array?
17:52:36 <hpc> google will explain more; i don't use them much
17:52:42 <kmc> so named because type classes are like relations, and a binary relation with that property is a function (here, a function on types)
17:52:53 <kmc> what's it got to do with arrays?
17:52:59 <hpc> it basically means, "for every a, there is exactly one type b can be"
17:53:28 <joe6> ok, thanks a lot.
17:53:31 <hpc> so class ThingToMaybe a b | a -> b where ...
17:53:45 <hpc> instance ThingToMaybe Foo (Maybe Foo) ...
17:53:55 <hpc> and you can't have instance Foo Either Foo Foo
17:54:03 <copumpkin> Wow, lexical scope is incompatible with functional programming, folks.
17:54:09 <copumpkin> We should remove it from Haksell
17:54:12 <copumpkin> http://www.jsoftware.com/jwiki/Guides/Lexical%20Closure#dissent has spoken
17:54:18 <hpc> copumpkin: stop the presses!
17:54:41 <kmc> monads in the haskell/scheme sense
17:55:11 <aristid> copumpkin: that guy would love @pl
17:55:14 <kmc> i can't read this gibberish language but i'll bet this is a case of closing over mutable vars
17:55:32 <copumpkin> he's saying that closing over anything is bad, as far as I can tell
17:55:40 <copumpkin> because FP is about being explicit about what you're operating on
17:55:50 <kmc> but it's based on an example where closure makes a function impure
17:55:55 <hpc> "i am a software engineer and what is this?"
17:56:04 <kmc> by which i think he means, closing over a mutable variable makes a function impure
17:56:13 <kmc> well, yes it does ;P
17:56:30 <copumpkin> I think he's misplaced his dissent though
17:56:42 <kmc> i do approve of calling out Paul Graham
17:56:43 <copumpkin> on silent mutable variables rather than lexical scope
17:57:09 <aristid> kleisli your master shall be
17:57:37 <copumpkin> yoda your english teacher must have been
17:57:53 <aristid> indeed was he
17:58:01 <hpc> in soviet russia, yoda speaks flawless english
17:58:27 <copumpkin> lol
17:58:40 <copumpkin> @remember hpc in soviet russia, yoda speaks flawless english
17:58:40 <lambdabot> I will remember.
17:58:48 <hpc> :D
17:58:57 <kmc> poland reverse language you orders in
17:59:27 <hpc> in orders you language reverse poland?
17:59:37 <hpc> that doesn't any of the sense make
18:00:10 <aristid> i think the verb must come last
18:00:11 <hpc> this all reminds me of my calc teacher in high school
18:00:13 <kmc> obviously you're not a golfer
18:00:14 <aristid> being the operator
18:00:22 <hpc> she was extremely russian
18:00:37 <hpc> before christmas, she gave us a packet with 150 derivatives to solve
18:00:41 <hpc> she called it the home take test
18:01:04 <aristid> hpc: did anybody actually do it?
18:01:06 <hpc> i can NEVER see "take-home test" without reflexively replacing it with "home take test"
18:01:13 <hpc> aristid: it wasn't so bad
18:01:46 <kmc> i took "in" to be an operator connecting a dependent clause to another clause
18:01:49 <hpc> try saying it out loud, and it will be permanently eched in your mind
18:02:58 <aristid> it kind of makes sense, yes
18:03:49 <copumpkin> I believe that our education, like such as in south africa, and the iraq, everywhere like such as and
18:03:57 <confound> me too
18:04:16 <hpc> but have you ever been so far as to have been like?
18:04:46 <aristid> copumpkin: man i tried to parse this as RPN
18:05:06 <copumpkin> http://en.wikipedia.org/wiki/Caitlin_Upton#Infamous_response
18:05:59 <kmc> has anyone really been far as decided to use even go want to do look more like?
18:06:28 <monochrom> I take "in soviet russia, yoda speaks flawless english" to mean: normally, flawless english speaks yoda. oh wait...
18:06:37 <monochrom> I mean hahahah
18:06:46 <hpc> monochrom: much to learn, you still have
18:07:11 <monochrom> this is a very well-constructed loop!
18:08:26 <copumpkin> kmc: you've got to be kidding me
18:08:59 <copumpkin>  I’ve been further even more decided to use even go need to do look more as anyone can. Can you really be far even as decided half as much to use go wish for that? 
18:09:29 <kmc> colorless green ideas sleep furiously
18:10:03 <blackdog> kmc: but that parses flawlessly...
18:10:22 <micrypt> Gah... I'm speed reading LYAH and I seem to be burning out. Anyone care to explain Applicative functors?
18:10:33 <kmc> micrypt, you might want to read Typeclassopedia
18:10:52 <kmc> micrypt, but with all these classes like Applicative and Monad, it's easy to get too focused on "what *is* it, really"
18:10:57 <kmc> and maybe better to play with concrete examples
18:11:00 <aristid> random idea: throwing randomly generated sentences at people and observe how they try to parse them. try to infer how people parse language.
18:11:13 <kmc> because in the end, a class is just an API that various types can implement, and those different types need not have much in common
18:11:21 <copumpkin> preflex: seen erikc
18:11:21 <preflex>  erikc was last seen on #haskell 44 days, 22 hours, 51 minutes and 33 seconds ago, saying: is what i meant
18:11:21 <parcs> micrypt: you are reading too fast
18:11:23 <kmc> micrypt, do you have a specific question?
18:11:52 <aristid> micrypt: why do you speed read it if you burn out? :)
18:12:15 <micrypt> kmc: What are they for? 
18:12:25 <kmc> micrypt, they're not all for one thing
18:12:37 <kmc> different types are used for different things
18:12:47 <kmc> the class is provided so that you can reuse some code and some intuition between t hem
18:13:36 <micrypt> aristid: Trying to cover some ground within a limited timeframe and re-read as required in the future.
18:13:48 <kmc> micrypt, do you understand the type class "Functor"?
18:13:50 <aristid> Applicative is more general than Monad but still get you big parts of the "Monad goodness", and there are a few real types that are Applicative only. also it provides you with a nice syntax.
18:14:10 <micrypt> kmc: Yes, I figured that part out.
18:14:32 <aristid> oh wait, lyah bringt applicative before monad, right?
18:14:39 <kmc> yes aristid (as it should be ;P)
18:14:41 <micrypt> Yes, it does.
18:14:43 <aristid> then explaining them in terms of monads makes little sense :D
18:14:50 <kmc> micrypt, so what do the different instances of Functor have in common?
18:15:07 <aristid> kmc: well dunno, Monad is more useful because _most_ real Applicative instances are also Monad
18:15:14 <micrypt> kmc: The functor laws and "fmap"?
18:15:38 <kmc> micrypt, ok.  well applicative has additional functions, pure and (<*>)
18:15:53 <kmc> and some laws (see http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Control-Applicative.html )
18:16:03 <kmc> does that answer your question?
18:16:44 <copumpkin> micrypt: an Applicative is something that lets you fmap over multiple things at once
18:16:45 <micrypt> Looks like it does, thanks.
18:16:55 <kmc> micrypt, so you just wanted the definition of the class?
18:17:04 <kmc> that's kind of funny, because it can be looked up easily
18:17:15 <kmc> whereas usually people asking these sorts of questions are looking for deep intuition which may not exist
18:17:24 <kmc> hmm i think some of these laws are redundant
18:17:34 <micrypt> copumpkin: Aaah. Okay.
18:18:01 <micrypt> kmc: I was starting to get a nagging feeling that I was learning rules without knowing what they were meant for.
18:18:07 <kmc> micrypt, it may be easier to understand what Applicative is good for if you look at liftA, liftA2, liftA3
18:18:13 <kmc> micrypt, that will tend to happen when you speed-read...
18:18:46 <kmc> micrypt, most languages you can learn by quickly absorbing some new syntax for ideas you already know
18:18:49 <aristid> copumpkin: Applicative also has pure. something that lets you fmap over multiple things at once is Apply (http://hackage.haskell.org/packages/archive/semigroupoids/1.1.2/doc/html/Data-Functor-Apply.html)
18:18:52 <kmc> this doesn't usually work for learning Haskell
18:18:55 <micrypt> Yeah, the rest had made sense to this point though. :P
18:19:13 <copumpkin> aristid: yeah, I know :)
18:19:28 <copumpkin> aristid: it just didn't seem as useful in context
18:19:29 <kmc> micrypt, usually the point where something obviously stops making sense is well beyond the point where you stop learning well
18:19:43 <copumpkin> (I work right next to edwardk, and helped him come up with instances of Apply when he was making it)
18:19:45 <kmc> it stops making sense because you *already* failed to learn all the prerequisites, but didn't realize at the time
18:20:06 <micrypt> kmc: True.
18:20:34 <aristid> copumpkin: being paid for finding instances for Apply, hah
18:20:45 <kmc> they don't call it (<$>) for nothing
18:20:55 <copumpkin> aristid: it's pretty sweet :)
18:21:08 <kmc> istr at Galois (<$>) and (<*>) are pronounced "money" and "splat" respectively
18:21:18 <astory> does ghc have a clean function to clear out secondary files after compliing?
18:21:28 <kmc> one time i wrote «splat a b = [| $a <*> $b |]»
18:21:46 <aristid> kmc: huh?
18:21:56 <kmc> aristid, you can tell it to put them somewhere else
18:21:59 <kmc> and then rm -r that dir
18:22:02 <kmc> cabal does this for you
18:22:07 <kmc> huh what?
18:22:23 <astory> kmc: did you mean me?
18:22:31 <kmc> sorry
18:22:31 <kmc> yes
18:22:32 <aristid> kmc: what is splat?
18:22:39 <aristid> (your function)
18:22:40 <astory> how do you tell it to put them somewhere else?
18:22:56 <Saizan> -outputdir= iirc
18:22:58 <kmc> astory, by reading the manpage
18:23:06 <kmc> not to be that guy but i don't remember offhand and don't feel like looking it up
18:23:17 <astory> fair enough
18:23:19 <aristid> does cabal even have a manpage?
18:23:22 <kmc> ghc does
18:23:22 <astory> although i do hate that guy
18:23:35 <astory> you know lots offhand, so I figured it was worth a shot
18:23:47 <kmc> yeah, it is worth a shot
18:23:55 <aristid> kmc: so what did you need the splat function for?
18:23:56 <kmc> (that's why i don't say "read the manpage, fuckface")
18:24:15 <kmc> (it is reasonable to request cached information from peers)
18:24:27 <kmc> aristid, http://hackage.haskell.org/packages/archive/rowrecord/0.1/doc/html/src/Text-RowRecord-TH.html
18:24:51 <kmc> the 6 lines of fromCon took me about 2 hours to write and are probably terrible style
18:24:56 <kmc> isn't Template Haskell great
18:25:22 <aristid> kmc: oh, that does make sense. sort of.
18:26:10 <aristid> if i hadn't been able to come up with a name, it would have just been (\a b -> [| a <*> b |]) :D
18:26:18 <aristid> um with $
18:26:32 <kmc> i wanted to build an expression of the form «a <*> b <*> c <*> ...»
18:27:05 <aristid> like liftAn id
18:27:14 <gnezdo> Saizan: sigh, ghc-6.8.3 is too dumb to deal with the subtlety
18:27:20 <kmc> guess so
18:27:24 <kmc> a = pure f
18:27:34 <aristid> liftAn, then
18:27:35 <kmc> but it was easier to do it that way instead of special-casing the first operator to (<$>)
18:27:38 <gwern> hm. is there any file function which deteccts hidden files, eg. with a prefixed '.' on unix? (I'm looking at a really horrible function in xmonadcontrib)
18:28:01 <gnezdo> plan B - double traverse
18:29:51 <jmcarthur> @pl \a b c d -> b d (a c) c
18:29:51 <lambdabot> flip flip id . (liftM2 flip .) . flip ((.) . flip)
18:30:24 <OceanSpray> what is this i dont even
18:31:26 <aristid> note how this is much less cryptic than J code
18:31:28 <djahandarie> It's a failure to succinctly make a point-free form of an expression.
18:33:57 <djahandarie> roconnor, the exercises in this book are annoying :P
18:55:42 <sina> hey everyone
18:55:47 <kmc> hi sina
18:55:54 <sina> key kmc :)
18:56:16 <sina> I'm wondering, when we have a type defined as x :: (a->b)->[a]->[b]
18:56:25 <sina> what does the first bit (a->b) mean
18:56:33 <sina> does it mean function a over b ?
18:57:06 <kmc> yes
18:57:12 <Axman6> it's a function that takes a's and returns b's
18:57:12 <kmc> (a -> b) is the type of functions that take 'a' and return 'b'
18:57:27 <kmc> so your function x takes a function as its first argument, and a list as its second
18:57:43 <frank00> q: I have a big string, and need my program to parse a bit of it and return the rest of it for another round of parsin ( so [a] -> (thing, [a]) ) It seems to call for monads. I am asking: is there a  monad who is right for the job or should I write one myself?
18:58:00 <kmc> frank00, that's the type signature of the State monad
18:58:02 <kmc> @unmtl State s a
18:58:02 <lambdabot> s -> (a, s)
18:58:14 <Axman6> x :: (a -> b) -> [a] -> [b] says it takes a function from a's to b's, and a list of a's and returns a list of b's
18:58:17 <kmc> frank00, but perhaps you'd like to use a parser library like Parsec
18:58:20 <sina> ok. thanks a lot kmc. so when I have x y (z:zs) = (x y) : x y zs
18:58:47 <Axman6> i don't think that definition is right
18:58:48 <kmc> itym «y z : x y zs»
18:58:58 <sina> it means  the result of the function x over y consed to x y zs ?
18:59:01 <kmc> «map f (z:zs) = f z : map f zs»
18:59:17 <kmc> yes, that's what it would mean, if i understand "x over y" correctly
18:59:18 <sina> yeah, thats the function
18:59:20 <kmc> (that's not a standard term)
19:00:07 <sina> ok. Its not a code I'm supposed to run. just need to prove something based on it... :(
19:00:49 <kmc> maybe we can help
19:01:54 <lispy> Has anyone here heard from Sven Panne more recently than Oct of 2009?
19:02:28 <lispy> It seems to me that he may have disappeared.
19:02:49 <sina> kmc: its a question regarding calculating the cost for the worst case scenario. its basically mapping a function that does this ([1] ++ [given_number]) over a list of ints
19:03:04 <lispy> That was the last time he posted to the HOpenGL mailing list and I've been unable to contact him via email.
19:18:18 <joe6> doesn't unsafePerformIO break the purity of haskell?
19:18:51 <blackdog> joe6: yes. it's usually used in situations like the FFI where you can prove that something is safe, but not within the type system
19:18:59 <shachaf> joe6: There's a reason it's called unsafePerformIO.
19:19:23 <joe6> blackdog, ok, thanks..
19:19:25 <kmc> joe6, if you think that's bad, take a look at unsafeCoerce and reallyUnsafePtrEq#
19:19:43 <lispy> unsafeCoerce is the best!
19:19:46 <kmc> once you allow C FFI you've given up on hard enforcement of the rules, anyway
19:19:55 <joe6> what is stopping from using them everywhere?
19:19:57 <lispy> It's like adding False as an axiom
19:20:13 <kmc> joe6, peer pressure
19:20:17 <blackdog> joe6: community disapproval
19:20:20 <joe6> just use it  on all functions with return types of IO ..
19:20:20 <blackdog> damn, he beat me to it
19:20:35 <kmc> joe6, if you look at some core libraries like ByteString, they actually use unsafePerformIO all over the place
19:20:37 <blackdog> the problem comes when your program doesn't work and no-one will help you with it.
19:20:40 <lispy> joe6: Oh, well adding it everywhere would lead to code that doesn't work correctly
19:20:47 <kmc> they're written by clever people and extensively audited and tested
19:21:13 <joe6> ok, thanks.
19:21:15 <lispy> Well, and unsafePerformIO can be safe and correct when used appropriately.
19:21:20 <kmc> basically when you use unsafePerformIO you take on a bunch of responsibilities that are usually left to the compiler
19:21:41 <kmc> same with FFI, same with unsafeCoerce, etc.
19:22:13 <kmc> GHC Haskell lets you break these rules because it's preferable to needing to modify GHC itself
19:22:30 <kmc> that said there's a few common use cases of unsafePerformIO which i would really like to see replaced with a new GHC feature
19:22:45 <lispy> kmc: such as?
19:22:46 <joe6> kmc, ok. thanks a lot.
19:22:54 <kmc> lispy, global IORefs / MVars / etc.
19:23:04 <lispy> ah
19:23:26 <kmc> JHC lets you say "x <- newIORef" at the top level of a file
19:23:41 <joe6> what is JHC?
19:23:47 <kmc> joe6, a Haskell compiler
19:24:00 <joe6> better than GHC?
19:24:03 <kmc> better
19:24:07 <kmc> ?
19:24:16 <kmc> joe6, when is software ever strictly ranked better vs. worse
19:24:17 <lispy> kmc: but then what if someone writes unsafePerformModule ;)
19:24:26 <blackdog> joe6: it produces C
19:24:32 <kmc> JHC has some cool stuff GHC doesn't, and it has a totally different approach to compilation under the hood
19:24:38 <blackdog> so it's more convenient when you want to link it into other programs
19:24:50 <blackdog> however, it doesn't support Cabal (or vice versa)
19:25:01 <kmc> on the other hand, it's much less mature and lacks many GHC features and library support
19:25:06 <blackdog> so it's harder to get a suite of libraries goin
19:25:10 <kmc> and its generated code is not as fast
19:25:24 <kmc> joe6, GHC is used for the majority of work done in Haskell; other compilers have more niche roles but are interesting to study
19:25:37 <kmc> lispy, i'm not sure what you mean
19:25:39 <lispy> It's actually faster at some programs, but lots of programs do not compile with JHC.  Where is Lemmih?
19:25:47 <kmc> but if you refer to the ordering-IO-between-modules problem
19:25:50 <kmc> JHC has a solution to that
19:25:57 <joe6> how about the packages on hackage? or, are they planning something similar for JHC too?
19:26:17 <kmc> joe6, cabal already supports some compilers other than GHC
19:26:33 <lispy> Lemmih started a fork called LHC that had support for building more programs but I think he eventually went on to work on other things.
19:26:47 <kmc> LHC is still under development but is no longer a fork of JHC
19:27:07 <kmc> iirc it uses GHC's frontend to output Core, followed by a whole-program backend
19:27:15 <Saizan> yep
19:27:22 <lispy> Interesting
19:28:01 <lispy> I do sometimes wish GHC was split into several projects like that.  Major independent components that do things like just translate to core, or just translate core to llvm, or ...
19:28:23 <lispy> Sort of like how gcc and binutils are setup to be a bunch of cooperating programs
19:28:37 <kmc> isn't there some new "plugins" feature for GHC that could help with that?
19:28:50 <lispy> I admit I don't follow GHC dev
19:28:54 <lispy> Could be!
19:28:54 <kmc> i do like the idea of specifying Core-Core optimization passes as arbitrary programs
19:29:08 <mxyz> what is the name for a map variant that also takes an index?
19:29:12 <kmc> http://www.cs.berkeley.edu/~megacz/coq-in-ghc/
19:29:18 <lispy> kmc: yeah, and someone wrote a library so you can do Core to Core transformations in Coq
19:29:21 <kmc> yes
19:29:27 <lispy> heh
19:29:48 <blackdog> lispy: you'd need to work out the social structure first
19:29:53 <kmc> :t flip zipWith [1..] -- mxyz
19:29:54 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
19:30:04 <kmc> > zipWith (,) [1..] "abcdef"
19:30:05 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f')]
19:30:31 <mxyz> sweet. thank you!
19:30:45 <lispy> blackdog: I wouldn't mind if GHC HQ and all the familiar people were still maintainers as they are now.  Just put in a better separation between the phases.  Er, not really better, so much as "at the process level"
19:31:28 <blackdog> lispy: technical structure always reflects social structure, though. it'd be more work for the few people involved to do it that way, so it stays monolithic.
19:31:57 <lispy> dons has said the same thing when I mentioned similar ideas to him.
19:32:05 <blackdog> it may even work better to have igloo being an integrator of the various chunks, but it'd still need a captain for eachchunk
19:32:16 <lispy> I'm not sure if it's true, but I don't need the delination enough to submit patches.
19:32:31 <blackdog> lispy: UNSW posse thinks alike:)
19:32:36 <EM03> where is a good place to find haskell freelancers?
19:32:37 <lispy> heh
19:32:54 <lispy> EM03: have you looked at haskellers.com?
19:32:58 <kmc> EM03, this channel
19:33:06 <EM03> i can't find any anywhere
19:33:15 <EM03> one guy wasted my time and 400 dollars
19:33:15 <kmc> also reddit.com/r/haskell , haskell-cafe mailing list
19:33:28 <kmc> what kind of project EM03?
19:33:42 <blackdog> EM03: there are a lot of frustrated haskellers working on ruby, python, C...
19:34:02 <kmc> there are also a lot of Haskellers who use ruby, python, C professionally and love it
19:34:05 <djahandarie> 400 dollars does not sound like much of anything at all though.
19:34:17 <EM03> for 2 hours of work it is 
19:34:25 <EM03> that did not get complete 
19:34:26 <blackdog> kmc: i can't see how that conflicts with what i said:)
19:34:34 <kmc> it doesn't
19:34:39 <lispy> EM03: you could try haskellers.com which is basically a resume aggregator.
19:34:39 <djahandarie> EM03, you didn't have a contract?
19:34:43 <EM03> ruby and python are jokes to me :P hehe 
19:34:43 <kmc> blackdog, quite true what you said about technical / social structure.... some of the bizarre features of Git directly reflect ancient Linux-hacker traditions
19:34:45 <EM03> yes I did 
19:34:58 <blackdog> 2 hours of work doesn't get a lot, even in Haskell. most of your time is going to be in understanding the codebase...
19:35:12 <EM03> it was supposed to be much longer the guy was just lying etc 
19:35:16 <EM03> didn't even know haskell 
19:35:20 <blackdog> kmc: that's an interesting perspective. can you elaborate?
19:35:57 <kmc> blackdog, who in their right mind would think up git-format-patch and git-am
19:36:19 <EM03> you guys give way to much credit to python and ruby though .....to me they are just a step above PHP 
19:36:30 <kmc> EM03, i don't like your attitude
19:36:44 <kmc> the quality of tools matters but the quality of programmers matters a lot more
19:36:45 * lispy thinks EM03 is a troll
19:36:47 <EM03> what I said is the truth though 
19:36:49 <EM03> what?
19:36:52 <EM03> wow 
19:37:07 <EM03> the quality of the tools is as well .....
19:37:09 <lispy> kmc: I haven't used those commands.  Could you explain a bit more?
19:37:25 <djahandarie> EM03, well, like has been stated, haskellers.com is a good place to look for people.
19:37:32 <blackdog> kmc: what's the link to linux hacker traditions?
19:37:32 <EM03> I'm on there right now 
19:37:33 <kmc> lispy, git-am parses a Maildir, extracts patches from emails, and applies them
19:37:38 <djahandarie> :)
19:37:41 <blackdog> kmc: sorry if i'm being dense
19:37:42 <kmc> blackdog, swapping patches on the LKML since forever
19:37:46 <kmc> the new tool supports the old workflow
19:37:53 <kmc> rather than changing the workflow, even though the new tool supports that as well
19:37:56 <lispy> ah
19:38:09 <lispy> Does linus use github?
19:38:09 <kmc> everyone *else* using git sets up a shared repo and pushes branches etc
19:38:46 <kmc> it's just bizarre that the right way to apply a 50-patch series to the Linux kernel is to send 50 emails
19:39:25 <lispy> Yeah, sounds really flaky and inconvenient
19:40:00 <lispy> I hate sending plain text prose over email.  Using it to send files sucks.  But, that is the main way to use darcs too :(
19:40:04 <blackdog> kmc: i guess it has to be that way - it wouldn't get uptake if it didn't support the old workflow too.
19:40:24 <blackdog> but it's an interesting end-run around it - at least you can overlay new workflows
19:40:34 <kmc> yes
19:41:04 <lispy> One nice thing about the way git is structured is that new commands seem to be easy to add
19:41:27 <kmc> yeah.  you have a simple data model that's common to all commands
19:41:29 <lispy> And the data format is corruption evident
19:41:58 <kmc> it's hard to understand all 5,000 git commands, but if you understand two commands then you understand how they interact
19:42:03 <lispy> (The UI needs some polish)
19:42:19 <kmc> yes, the UI is almost accidental
19:42:32 <kmc> the original idea was for git to be the "plumbing" on top of which other people would implement a user-friendly VCS
19:42:40 <kmc> but nobody did this well enough so the git developers had a go
19:42:54 <lispy> Well, github is a pretty nice UI
19:42:58 <kmc> there's still various alternatives
19:45:15 <lispy> I'm having issues with cabal on osx.  I build some obj-c code using a makefile and when I build both a .a and .dylib, gcc links the final program using the dylib (I don't want that).  If I get rid of the dylib things get statically linked but then I can't use ghci.
19:45:43 <lispy> Advice?
19:50:18 <joe6> :t mFib = mFib :: CodeGenModule (Function (Word8 -> IO Word8)) ; :t LLVM.Core.dumpValue = LLVM.Core.dumpValue :: LLVM.Core.Value a -> IO ();  this works: ot <- optimizeFunction mFib; LLVM.Core.dumpValue ot; but, I cannot get "mFib >>= LLVM.Core.dumpValue" to work.
19:50:19 <lambdabot> parse error on input `='
19:50:43 <joe6> I expected that (>>=) would remove the CodeGenModule as it does the IO
19:51:41 <joe6> any thoughts, please?
19:54:40 <joe6> ot <- optimizeFunction mFib = ot :: Function (Word8 -> IO Word8)
19:55:16 <joe6> :t (>>=)
19:55:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:55:34 <joe6> so m has to be consistent across the function definition.
19:55:45 <lispy> yes
19:56:09 <joe6> is it possible to do (Monad m, Monad m1) => m a -> (a -> m1 b) -> m1 b
19:56:22 <lispy> ?hoogle  m a -> (a -> m1 b) -> m1 b
19:56:22 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
19:56:22 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
19:56:22 <lambdabot> Language.Haskell.TH.Syntax bindQ :: Q a -> (a -> Q b) -> Q b
19:56:40 <lispy> joe6: I think you want liftIO but I didn't study your question carefully
19:56:54 <joe6> :t liftIO
19:56:54 <lambdabot>     Ambiguous occurrence `liftIO'
19:56:54 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
19:56:54 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
19:57:06 <lispy> ?slap lambdabot 
19:57:06 * lambdabot decomposes lambdabot  into several parts using the Banach-Tarski theorem and reassembles them to get two copies of lambdabot !
19:57:10 <joe6> :t Control.Monad.Logic.liftIO
19:57:11 <lambdabot> forall a (m :: * -> *). (Control.Monad.Logic.MonadIO m) => IO a -> m a
19:57:38 <accel> How does blah.cabal pass options to "runhaskell Setup.lhs" ?
19:57:46 <joe6> lispy, it is the other way, going from m a -> IO a
19:57:59 <lispy> :t lift
19:58:00 <lambdabot>     Ambiguous occurrence `lift'
19:58:00 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
19:58:00 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
19:58:10 <lispy> :t Control.Monad.Logic.lift
19:58:11 <joe6> :t Control.Monad.Logic.lift
19:58:11 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
19:58:11 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
19:58:41 <joe6> I am looking for m a -> m1 a
19:58:52 <lispy> accel: If blah.cabal has build-type: simple, then Setup.hs is ignored unless you call it explicitly
19:59:02 <lispy> joe6: Yeah, and in general it doesn't exist
19:59:13 <Saizan> joe6: createModule mFib >>= dumpValue ?
19:59:15 <lispy> joe6: You need to use lift/litfIO depending on the context
20:00:05 <axfan> I just want to say
20:00:08 <axfan> Haskell is the best langauge ever
20:00:12 <djahandarie> :)
20:00:48 <axfan> Ok, back to coding
20:00:50 <ChaseQ1> Haskell
20:00:51 <Saizan> joe6: mFib >>= \x -> liftIO (dumpValue x) would work too, but it'd be in the CodeGenFunction monad
20:01:06 <joe6> Saizan, thanks a lot.
20:01:37 <Saizan> err, CodeGenModule, i meant
20:01:50 <accel> lispy: I need to pass --c2hs-options=--cpp-opts=-U__BLOCK__
20:03:21 <blackdog> accel: ha,, i remember that. awful pain in the bum.
20:03:25 <blackdog> mac, right?
20:04:00 <accel> blackdog: yeah, some fuction in /usr/include/std*.h that looks like void(^)(fuck-you-i-like-shift-six-instead-of-star)
20:04:20 <lispy> accel: oh!  In that case you need to use build-type: Custom and then write some special code in Setup.lhs
20:04:23 <accel> is "void (^) foo()" even valid ansi C?
20:04:36 <joe6> which package do you install to get liftIO ?
20:04:36 <kmc> nope, that's Apple's "blocks" extension
20:04:51 <joe6> hoogle tells me about cgi transformers, etc
20:05:01 <joe6> but, nothing as Control.Monad.Logic
20:05:03 <lispy> joe6: I think it's in mtl
20:05:35 <lispy> joe6: Is your code sharable?  Posting some almost working code on hpaste might intice someone here to take a deeper look
20:05:41 <joe6> lispy, not according to hoogle.
20:05:43 <lispy> entice*
20:05:52 <Saizan> joe6: you get it from Control.Monad.Trans
20:05:53 <Saizan> iirc
20:06:11 <joe6> lispy, i am just trying out things from the http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html
20:06:27 <joe6> lispy, trying out different combinations of functions in that package.
20:06:41 <joe6> lispy, just to familiarise myself with the code.
20:06:53 <joe6> Saizan, thanks.
20:13:07 <co_dh> ##categorytheory
20:13:30 <joe6> Saizan, it appears to have been moved to Control.Monad.IO.Class
20:13:55 <djahandarie> co_dh, you can just type  /join ##categorytheory  if that's all you want to do :)
20:14:15 * djahandarie isn't against spreading knowledge of its existence in this channel though ;)
20:16:21 <co_dh> djahandarie: thanks. :)
20:23:02 <lispy> looks like the projects on code.haskell.org have finally been restored.
20:23:10 <lispy> I guess I missed the announcement.  I thought it was still down
20:23:35 <djahandarie> Yeah they've been up for quite awhile now.
20:23:42 <djahandarie> It was just that the accounts were screwed up a little I think.
20:24:13 <joe6> is it possible to have a lambda function without arguments?
20:24:27 <kmc> no, that would make no sense
20:24:31 <kmc> every function has exactly one argument
20:24:45 <kmc> in some languages you use those to delay evaluation, but Haskell delays evaluation of everything
20:24:59 <kmc> however, you can make a function which ignores its argument
20:25:11 <kmc> and you can make that argument be of type (), which is the "useless type" with only one value
20:25:16 <joe6> http://sprunge.us/VXNC 
20:25:29 <joe6> i am trying to define the mSub function
20:25:32 <kmc> but there are relatively few reasons to do this
20:25:34 <kmc> in a pure, lazy language
20:25:35 <joe6> without any argments.
20:25:48 <kmc> then you are doing it wrong
20:26:10 <kmc> what's the type of createFunction?
20:26:26 <joe6> kmc, i agree that it has no utility, but the createFunction of LLVM wants a lambda function as the output. hence, I am trying to see if it is possible.
20:26:34 <kmc> as the input?
20:26:39 <kmc> what's the type of createFunction?
20:26:42 <joe6> i could use the newFunction and defineFunction,
20:27:07 <joe6> :: (IsFunction f, FunctionArgs f g (CodeGenFunction r ())) => Linkage -> g -> CodeGenModule (Function f)
20:27:16 <joe6> for createFunction.
20:27:56 <kmc> so i suspect that FunctionArgs type class allows g to be something built by a "do" block, in addition to allowing it to be a function returning such a value
20:30:00 <pooper> poop
20:30:52 <joe6> kmc, yes.
20:31:08 <kmc> pooper, well put
20:31:28 <djahandarie> Well dropped.
20:32:17 <copumpkin> @remember pooper poop
20:32:17 <lambdabot> It is stored.
20:33:24 <kmc> @quote ubuntu.freebsd
20:33:24 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
20:33:42 <djahandarie> lol.
20:33:42 <shachaf> @protontorpedo
20:33:42 <lambdabot> how is haskell different than java?
20:34:18 <djahandarie> I have a hard time believing that NIXDAEMON-COOL quote isn't generated by a markov chain
20:34:49 <kmc> they turned out to be a real person with a real Haskell question and a very real language barrier
20:34:56 <kmc> but i still have no idea where that sentence came from
20:35:24 <djahandarie> Maybe an online translator. In which it could very likely be a markov chain.
20:36:44 <shachaf> djahandarie: You wouldn't expect phrases like "ubuntu freebsd" to come up, would you?
20:38:39 <cizra> So Haskell has some primitive kind of type coercion, it seems?
20:38:42 <cizra> > 2 < 3
20:38:43 <lambdabot>   True
20:38:48 <cizra> :t (<)
20:38:48 <lambdabot> forall a. (Ord a) => a -> a -> Bool
20:39:07 <cizra> Note that in (<), the types of the arguments must be the same.
20:39:10 <cizra> > 2 < 2.5
20:39:10 <lambdabot>   True
20:39:15 <cizra> .. but here they obviously aren't.
20:39:17 <cizra> :t 2
20:39:17 <lambdabot> forall t. (Num t) => t
20:39:18 <cizra> :t 2.5
20:39:19 <lambdabot> forall t. (Fractional t) => t
20:39:53 * cizra ponders. Do those type classes share something in common?
20:40:09 <cizra> > 2 :: Int < 2.5 :: Float
20:40:10 <lambdabot>   <no location info>: parse error on input `2.5'
20:40:21 <cizra> > (2 :: Int) < (2.5 :: Float)
20:40:22 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:40:22 <lambdabot>         against inferred type ...
20:40:30 <cizra> ahha!
20:40:57 <djahandarie> Fractional is a subclass of Num.
20:41:29 <djahandarie> So when it unifies, 2's type becomes (Fractional t) => t
20:41:47 <cizra> *nod*
20:41:53 <cizra> Do they _ever_ get a concrete type?
20:42:00 <cizra> hmmm, actually they don't need
20:42:08 <cizra> they only need to figure out the Ord typeclass.
20:44:35 <dmwit> > sum . map (^2) $ [1..49]
20:44:37 <lambdabot>   40425
20:44:43 <dmwit> > sum . map (^2) $ [1..7]
20:44:45 <lambdabot>   140
20:45:07 <dmwit> > 1869 % 7
20:45:08 <lambdabot>   267 % 1
20:45:22 <dmwit> > sum [425, 384, 484, 576]
20:45:23 <lambdabot>   1869
20:50:29 <fcr> > length [1..]
20:50:33 <lambdabot>   mueval-core: Time limit exceeded
22:04:33 <wavewave> hi, is there any way to make cabal warn before installing the same version of a package which will cause a broken dependency?
22:08:13 <wavewave> this cabal dependency problem is very annoying.
22:10:01 <c_wraith> wavewave: there's been some work in tools to make that easier to handle.  cabal-dev is one option
22:10:45 <wavewave> c_wraith : I know cabal-dev. but I would like to have some kind of pre-warning system before I do something stupid. 
22:12:03 <wavewave> c_wraith : when I mindless do 'cabal install some-package', then it automatically install the same version of some basic package
22:12:17 <wavewave> like hslogger or something like that.
22:12:37 <c_wraith> do you care if it reinstalls something without breaking anything?
22:12:55 <c_wraith> Or do you just want a warning when it would lead to ghc-pkg check complaining something's broken?
22:13:06 <wavewave> with different dependency tree I guess, and a whole bunch of my previous installed package have broken dependency. 
22:13:31 <wavewave> c_wraith : at least, just warning .
22:13:58 <wavewave> c_wraith : I mean if some dep will be broken, then cabal should ask user to make sure. 
22:14:37 <wavewave> so i ask if such default option already exist.
22:15:42 <wavewave> c_wraith : I know that solving this dependency problem completely is difficult. 
22:16:55 <c_wraith> Actually, there's a fair bit of work being done on this topic around..  uh, where I live.  Even if I'm not there right now.  the last tech talk at Galois was given by a co-worker of mine, and part of it was devoted to how we deal with these issues
22:17:43 <wavewave> c_wraith : I see. I am very thankful to those workers :)
22:18:15 <c_wraith> By the way, the answer is: a custom tool that requires patched version of Cabal and cabal-install, but it does its job.
22:18:56 <wavewave> c_wraith : oh, good. would you tell me some link of it?
22:19:13 <c_wraith> yeah, let me find it
22:19:23 <wavewave> c_wraith : thanks so much!!
22:19:34 <c_wraith> as I said, it requires patched versions of cabal and cabal-install.  And it's not really documented.  So...  Good luck :)
22:20:14 <c_wraith> https://github.com/janrain/coup
22:20:16 <wavewave> c_wraith : yes, I understand it. as you may guess already, I am  a kind of early adaptor of experimental things. 
22:20:34 <wavewave> c_wraith : oh thank you so much!
22:21:31 <wavewave> c_wraith : in fact, I should not experiment with my production machine, but I am always doing that and always regret it. 
22:40:51 <z1y> hi all. I am have ghc 6.8.2dfsg1-1 on debian lenny. I tried to install cabal (latest) but it reported the the package time >= 1.1 is missing. How to solve this problem?
22:41:02 <z1y> s/I am have/I have/
22:41:27 <c_wraith> that's a *really* old ghc
22:41:32 <c_wraith> any particular reason you're using it?
22:41:33 <ulfdoz> Its debian.
22:41:49 <z1y> yes, it's debian lenny :(
22:42:06 <c_wraith> I mean, is anything preventing you from using a newer binary ghc release?
22:42:10 <ulfdoz> Have a look into backports, maybe you find some more recent one.
22:42:14 <c_wraith> because that's the direction I'd go.
22:42:16 <z1y> I've tried to build ghc-6.12 , but the system memory is too small (500MB), and the machine halted :D
22:42:17 <Jafet> That's a *really* old debian. Any particular reason you're using it?
22:42:29 <c_wraith> debian doesn't handle ghc very well
22:44:10 <cizra> z1y: You could perhaps try to cross-compile on another machine.
22:44:15 <z1y> oh, this guy already built the package for debian lenny http://rajeshsr.co.cc/blogs/2010/04/04/ghc6-6-12-haskell-deb-packages-for-x86-lenny/. It's unsafe, but I will try it
22:44:18 <cizra> z1y: or set up some crazy scheme with distcc.
22:44:18 <ulfdoz> Jafet: There is no thing like a *new* debian.
22:44:45 <c_wraith> z1y: you could also use the generic binary linux distro.  It doesn't build ghc
22:44:48 <z1y> cizra: oh, really? that sounds great. I will try it
22:45:18 <cizra> z1y: Note that it's a tricky thing to do.
22:45:33 <z1y> cizra: no problem. I love tricky stuff :)
22:45:42 <c_wraith> but...  500 MB isn't enough to link a lot of haskell programs, due to the way GHC creates object code
22:45:45 <cizra> z1y: Basically, with distcc you can ensure that your machine only does the preprocessing (which is easy anyway) and offloads the compiling to somebody else
22:46:03 <cizra> z1y: ... BUT I have no idea where it links or if the paths end up being right.
22:46:54 <cizra> z1y: For linking, also investigate gold. It's supposed to be MUCH faster than ld, and it might perhaps consume less memory.
22:47:15 <z1y> cizra: yes I see. thank you for the tips. I am 'googling' for them now
22:47:44 <ulfdoz> rofl, there is a ghc 6.12 for anything but lenny in backports.
22:50:27 <z1y> ulfdoz: yep. no ghc in backports
22:55:56 <lispy> How to pick a gui library to use with opengl: http://www.reddit.com/r/haskell/comments/g6a06/comparison_picking_a_gui_library_to_use_with/
23:59:41 <augur> GREETINGS ALL
