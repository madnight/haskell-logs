00:05:57 <gienah> siplux: yes the haskell platform for ghc 6 had mtl-1, while as haskell platform 2011 for ghc 7 has mtl-2, there are some confusing changes for beginners
00:06:30 <siplux> gienah: thanks, I actually just found the correct page and realized that Writer became writer
00:07:35 <gienah> siplux: great, here is one page on the changes: http://haskell.org/haskellwiki/Upgrading_from_MTL_1_to_MTL_2
00:08:05 <siplux> gienah: ah - thanks, hadn't seen that one yet
00:08:15 <frerich> Ok, so for somebody who dropped out of university after five semesters of Comp. Sci., can anybody here explain what "But the function is (ab)using the monomorphism provided by lambda-bound variables to force the type of m to be correct in the fromEnum call." means in the mail http://code.google.com/p/ndmitchell/issues/detail?id=420&colspec=ID%20Status%20Proj%20Summary%20Priority%20Stars ?
00:08:43 <frerich> I understand that monomorphism is the opposite of polymorphism, but how is that related to 'lambda-bound variables'?
00:09:27 * frerich wishes there wasn't so much new nomenclature to learn with Haskell for mere mortals without a PhD like him.
00:10:59 * hackagebot repa 2.0.0.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.0.0.1 (BenLippmeier)
00:11:01 * hackagebot repa-bytestring 2.0.0.1 - Conversions between Repa Arrays and ByteStrings.  http://hackage.haskell.org/package/repa-bytestring-2.0.0.1 (BenLippmeier)
00:11:03 * hackagebot repa-io 2.0.0.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-2.0.0.1 (BenLippmeier)
00:11:59 * hackagebot repa-algorithms 2.0.0.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-2.0.0.1 (BenLippmeier)
00:12:02 * hackagebot repa-examples 2.0.0.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-2.0.0.1 (BenLippmeier)
00:15:00 * hackagebot msgpack 0.6.1 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.6.1 (HideyukiTanaka)
00:16:49 <frerich> benmachine: Thanks for pointing out the improvement to the random enum function!
00:18:22 <DRMacIver> frerich: So what's going on there is that with a let definition, m can be polymorphic. It would have type (Enum a) => a. This means that nothing forces it to have the same type in the two places that it's used.
00:18:43 <Kaidelong> foldr is more general than foldl because a foldr defined in terms of foldl may be _|_ where the real foldr isn't. Am I wrong?
00:18:44 <DRMacIver> (I think)
00:19:20 <DRMacIver> frerich: But the arguments to lambdas are forced to be monomorphic, so making it m <- return maxBound forces it to be used with only a single type, so the two uses of m are consistent.
00:19:29 <shapr> Where's the monad tutorial that starts with functor,applicative, etc?
00:19:43 <DRMacIver> (it's a lambda bound variable because do notation is just sugar over lambdas)
00:19:49 <Kaidelong> I would imagine not since foldl never goes into a form where you can see the accumulator when running on non-terminating input
00:20:51 <frerich> DRMacIver : Hm, I understand that 'let m = maxBound' may 'm' be polymorphic, but I don't understand the second part. Where in 'm <- return maxBound' is a lambda? I thought lambda is something like \x -> x+1
00:21:28 <Kaidelong> why "m <- return maxBound" instead of just "let m = maxBound" or even "maxBound"
00:22:06 <Jafet> @undo do { x <- y; z; } -- frerich
00:22:06 <lambdabot> y >>= \ x -> z
00:22:09 <DRMacIver> frerich: It's because do notation is actually turned into lambdas. 
00:22:24 <frerich> DRMacIver: Aha!
00:22:44 <frerich> I guess it shows that I didn't get to that chapter in RWH yet, ahem...
00:22:47 <DRMacIver> frerich: do m <- return maxBound; blah is the same as return maxBound >>= \m -> blah
00:23:57 <Kaidelong> I suppose "return maxBound" would be important for some monads, like lists
00:24:00 <frerich> DRMacIver: Ah, and in that lambda, 'm' is actually forced into a single type (and in particular, to the same type as in the other places where 'm is used). Hmm.
00:24:09 <DRMacIver> frerich: Right, exactly.
00:24:34 <DRMacIver> Kaidelong: That's exactly what we're discussing. :) In this case it's basically just a cheeky trick to force m to always be used with a consistent type.
00:24:53 <DRMacIver> Kaidelong: See http://code.google.com/p/ndmitchell/issues/detail?id=420&colspec=ID%20Status%20Proj%20Summary%20Priority%20Stars
00:26:12 <Kaidelong> DRMacIver: How ugly!
00:27:18 <Kaidelong> I guess that's unavoidable there though
00:27:21 <DRMacIver> Perhaps. I don't see an obviously better way to do it though. 
00:27:25 <Kaidelong> yeah
00:27:37 <DRMacIver> But then I'm not all that good at Haskell, so possibly I wouldn't. :) 
00:28:38 <Kaidelong> :t maxBound >>= curry randomRIO 0 >>= return . toEnum
00:28:38 <lambdabot>     No instance for (Bounded (IO Int))
00:28:38 <lambdabot>       arising from a use of `maxBound' at <interactive>:1:0-7
00:28:38 <lambdabot>     Possible fix: add an instance declaration for (Bounded (IO Int))
00:29:12 <Kaidelong> :t return maxBound >>= curry randomRIO 0 >>= return . toEnum
00:29:13 <lambdabot> forall a. (Enum a) => IO a
00:29:30 <Kaidelong> :t return maxBound >>= curry randomRIO 0 . fromEnum >>= return . toEnum
00:29:30 <lambdabot>     Ambiguous type variable `a' in the constraints:
00:29:30 <lambdabot>       `Bounded a'
00:29:30 <lambdabot>         arising from a use of `maxBound' at <interactive>:1:7-14
00:29:35 <Kaidelong> there we go
00:30:01 * hackagebot tls-extra 0.1.3 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.1.3 (VincentHanquez)
00:30:33 <Derander> has anyone managed to get cryptohash-0.7.0 off of cabal to install on 64bit ghc? My system is having trouble compiling some C stuff it looks like
00:30:42 * frerich thinks he will write his next few Haskell proigrams without do notation, just to understand what is going on behind the scenes (and how do makes things more convenient for me)
00:31:28 <DRMacIver> frerich: I think you will quickly grow to regret that decision, but it's worth a shot :)
00:31:38 <Kaidelong> >=> is often more valuable to me than do notation anyway
00:32:56 <DRMacIver> Is that a typo or an operator I don't know?
00:33:00 <DRMacIver> :t (>=>)
00:33:01 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:33:09 <DRMacIver> Apparently the latter
00:33:14 <Kaidelong> yep
00:33:45 <Kaidelong> :t hGetLine >=> putStrLn
00:33:46 <lambdabot> Not in scope: `hGetLine'
00:33:52 <Kaidelong> :t hReadLine >=> putStrLn
00:33:53 <lambdabot> Not in scope: `hReadLine'
00:33:55 <Kaidelong> bah
00:34:22 <Kaidelong> :t (undefined :: Handle -> IO String) >=> putStrLn
00:34:23 <lambdabot>     Not in scope: type constructor or class `Handle'
00:34:34 <Kaidelong> :t (undefined :: a -> IO String) >=> putStrLn
00:34:35 <lambdabot> forall a. a -> IO ()
00:34:53 <fabjan> @type flip
00:34:54 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
00:35:03 <Kaidelong> wow lambdabot
00:35:25 <Kaidelong> try "(a -> b -> c) -> b -> a -> c"
00:35:40 <Kaidelong> which prelude replacement is that anyway?
00:36:29 <Kaidelong> :t flip $ flip (<*>) . pure
00:36:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
00:37:19 <Kaidelong> @src flip
00:37:19 <lambdabot> flip f x y = f y x
00:37:35 <Kaidelong> @ty (let flip f x y = f y x in flip)
00:37:36 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t1 -> t -> t2
00:38:02 <Kaidelong> lamdabot is lying
00:38:53 <Kaidelong> @ty fmap . flip ($)
00:38:53 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
00:45:45 <fabjan> @hoogle a -> (a -> b) -> b
00:45:45 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
00:45:45 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
00:45:45 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
00:47:03 * hackagebot cgi-utils 0.2.1 - Simple modular utilities for CGI/FastCGI (sessions, etc.)  http://hackage.haskell.org/package/cgi-utils-0.2.1 (ChrisDone)
01:04:06 * hackagebot string-quote 0.0.1 - QuasiQuoter for non-interpolated strings, texts and bytestrings.  http://hackage.haskell.org/package/string-quote-0.0.1 (AudreyTang)
01:07:07 * hackagebot happy-meta 0.2.0.2 - Quasi-quoter for Happy parsers  http://hackage.haskell.org/package/happy-meta-0.2.0.2 (JonasDuregard)
02:26:08 <dixie> Server error: thread killed
02:26:31 <dixie> I have happstack application... can be this done by because of spacek leak ?
02:28:23 * hackagebot BNFC-meta 0.2 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.2 (JonasDuregard)
02:39:18 <shapr> dixie: Have you tried space profiling?
02:57:50 <roelvandijk> dixie: Also check how much OS threads are spawned by your server
02:58:09 <roelvandijk> dixie: /s/much/many
03:01:20 <Saizan> "thread killed" is what you get if it receives a killThread
03:02:38 <mercury^> Saizan: :)
03:04:44 <Saizan> and it wasn't a joke :P
03:08:20 <Jonno_FTW> @src gcd
03:08:21 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
03:08:21 <lambdabot> gcd x y = gcd' (abs x) (abs y)
03:08:21 <lambdabot>    where gcd' a 0  =  a
03:08:21 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
03:08:24 <Jonno_FTW>  gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
03:08:24 <Jonno_FTW> 20:34 < lambdabot> gcd x y = gcd' (abs x) (abs y)
03:08:24 <Jonno_FTW> 20:34 < lambdabot>    where gcd' a 0  =  a
03:08:24 <Jonno_FTW> 20:34 < lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
03:08:26 <Jonno_FTW> woops
03:22:45 <drommy> ima ask a really dumb question, bear with me lulz 
03:23:54 <drommy> um how do i install haskell on ubuntu? i got it working on my windows pc but it i cant find any instructions that make sense for ubuntu :/
03:25:09 <shreyas123> Hi..
03:25:17 <mercury^> drommy: install ghc using synaptic.
03:25:22 <Saizan> drommy: seen the haskell platform page?
03:35:31 <Guest15309> hi guys. Can someone explain how the type of (map . map) comes about?
03:35:47 <quicksilver> you have to think of map as a function with only one argument
03:35:58 <quicksilver> that's the key, because (.) composes funtions with only one argument.
03:36:03 <quicksilver> @type map
03:36:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:36:11 <Botje> Guest15309: expand the definition of .
03:36:18 <quicksilver> view that as (a -> b) -> ([a] -> [b])
03:36:29 <Botje> map . map = \f -> map (map f)
03:36:30 <quicksilver> then you're composing that with another map
03:36:43 <quicksilver> so the second map gets "([a] -> [b])" as its input type
03:36:52 <quicksilver> so the output must be ([[a]] -> [[b]])
03:37:43 <Guest15309> ah I see thanks! I was first thinking that (map . map) would expand to map (map)
03:39:51 <Guest15309> \exit
03:41:38 <Skola> are there any good FP/Haskell screencasts on tha interwebs besides the Channel9 stuff?
03:42:48 <Botje> screencasts are slow :(
03:43:36 <DRMacIver> I've never really understood the appeal of screencasts.
03:43:49 <DRMacIver> At least for conveying technical information
03:43:51 <Skola> it's good for idiots like me
03:44:02 <Skola> you see I am a designer
03:44:07 <Skola> need visual stimuli!
03:45:04 <dixie> shapr, roelvandijk: I didn't try investigate it yet. I was curious about chance that out-of-memory linux killer knows about the haskell threads. But problably the problem is something else. The thread is long-running operation - it can be some happstack timeout handler.
04:01:53 <ManateeLazyCat> Hi all. :)
04:02:14 <ManateeLazyCat> Good evening. :)
04:03:21 <Botje> hallo!
04:03:58 <rtharper> oh hihi
04:04:05 <jonkri> anyone with some gtk2hs experience that can tell me why running this program doesn't open a window (just goes into some kind of loop): http://hpaste.org/45130/gui_test
04:06:23 <mux> jonkri: I think you're simply missing a widgetShow invocation here
04:07:51 <jonkri> mux: that was the problem :) thanks! seems i should report a bug to http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html :)
04:07:58 <mux> jonkri: great
04:08:31 <mux> jonkri: so I suppose you actually just added "widgetShowAll window_register" ?
04:09:11 <ManateeLazyCat> widgetShowAll (guiWindowRegister gui)
04:11:11 <jonkri> mux: i added "widgetShow $ guiWindowRegister gui"
04:11:17 <mux> yeah, that's the same
04:11:22 <mux> fine :)
04:11:22 <jonkri> ManateeLazyCat: hi... i've been looking for you :)
04:11:42 <ManateeLazyCat> jonkri: Hey, i just back from company.
04:11:54 <jonkri> i hear that you are the man to talk to when it comes to gtk2hs :)
04:12:14 <ManateeLazyCat> jonkri: I'm interested gtk2hs problem. :)
04:13:34 <shapr> g'day seafood 
04:13:34 <jonkri> ok :) i want to know if someone is porting gtk2hs to gtk3, and if so, if i will be able to theme my gtk3 program with the new css theming engine
04:13:35 <ManateeLazyCat> I haven't so much time haskell now, but yes, i will try to help other people about gtk2hs problem. :)
04:13:59 <flamingspinach> I didn't even know there was a gtk3...
04:14:07 <seafood> shapr: Hey!
04:14:23 <shapr> How's code?
04:14:33 <jonkri> flamingspinach: it has been done for a while now, and gnome3 will be released in april
04:14:35 <ManateeLazyCat> jonkri: We plan to to write gobject-introspection tool before binding gtk+3
04:14:47 <seafood> seafood: I'm working on the Accelerate library at the moment.
04:14:59 <jonkri> ManateeLazyCat: that's cool... useful :)
04:15:08 <ManateeLazyCat> jonkri: I'm working it after Ubuntu 11.04 release.
04:15:15 <ManateeLazyCat> jonkri: I need stable version to test APIs.
04:15:53 <ManateeLazyCat> jonkri: I'm using gtk+2 and gtk2hs develop Manatee (http://www.flickr.com/photos/48809572@N02/) i don't want dirty my environment by gtk+3 bug.
04:16:03 <ManateeLazyCat> s/i'm/i will
04:17:02 <ManateeLazyCat> jonkri: I found pygtk has switch to gobject-introspection, i think we should switch too, but you know, it's looks like build new gtk2hs from group up.
04:17:45 <ManateeLazyCat> I hope gtk2hs's binding become simpler after finish gobject-introspection
04:18:56 <jonkri> i see
04:19:41 <ManateeLazyCat> If we use gobject-introspection, i think we will use newest c2hs and not c2hs branch in gtk2hs.
04:20:06 <ManateeLazyCat> But now haven't people works on gtk+3, you perhaps need waiting some time.
04:20:20 <ManateeLazyCat> Or welcome to send patch! :)
04:20:58 <jonkri> i'm about to start working on developing a cross-platform messenger application and i wanted to use gtk3 theming. do you have any kind of guess for when there could be a gtk3 haskell binding available?
04:21:34 <jonkri> unfortunately, i'm still a haskell noob :P
04:21:55 <jonkri> (http://www.pontarius.org/ is my project)
04:23:01 <ManateeLazyCat> jonkri: Well, i can't promise this, because i have busy Linux districted work need finish, not like before, a free haskell programmer 
04:24:08 <jonkri> i understand
04:24:11 <jonkri> i like your pictures on flickr, looks good :)
04:24:11 <ManateeLazyCat> jonkri: My suggestion, you don't worried this, AFAIK, GTK+3 just clean departed APIs, and add new features, won't break like qt3 to qt4
04:24:20 <Entroacceptor> jonkri: look at PSYC, maybe that idea can excite you, too
04:24:34 <Entroacceptor> jonkri: http://about.psyc.eu/
04:25:53 <ManateeLazyCat> jonkri: So you're developing XMPP client?
04:25:59 <jonkri> Entroacceptor: interesting. i've never heard of that before... we are currently implementing http://www.xpmn.org/, which is a network architecture on top of xmpp
04:26:40 <Entroacceptor> psyc isn't widely known
04:26:46 <ManateeLazyCat> jonkri: It's looks really cool! :)
04:26:48 <Entroacceptor> and so far is weird to install
04:26:55 <jonkri> ManateeLazyCat: yes, with support for in-band encryption (xtls) for end-to-end encryption, and jingle for transferring socks5 data out-of-band
04:26:57 <Entroacceptor> but the technology is sound afaict
04:27:34 <jonkri> Entroacceptor: i will definitely look it up. thanks :)
04:27:48 <ManateeLazyCat> jonkri: Wow
04:28:11 <ManateeLazyCat> jonkri: Your protocol library is split out? Or mix in your Client?
04:28:17 <jonkri> all we need now is a user-friendly and sleek-looking gui to bind it all together :)
04:28:34 <tibbe> Any students interested in this year's Summer of Code?
04:29:06 <jonkri> ManateeLazyCat: it's split out. xmpp (core) library: http://www.pontarius.org/projects/pontarius-xmpp/ , xpmn library: http://www.pontarius.org/projects/pontarius-xpmn/
04:30:18 <ManateeLazyCat> jonkri: Thanks, i will looks that, looks really cool.
04:30:41 <jonkri> ManateeLazyCat: thank you :)
04:31:05 <ManateeLazyCat> jonkri: Maybe i can write some client in Manatee (http://hackage.haskell.org/package/manatee) to talk with your client. :)
04:31:13 <ManateeLazyCat> Haha. :)
04:31:23 <ariabbas> ...
04:32:00 <shapr> ManateeDSL?
04:32:58 <ManateeLazyCat> Damn it, i need write manay Python code for work. Only hacking Haskell when back to home. :)
04:33:35 <ManateeLazyCat> And PyGTK do great work on GTK+ binding.
04:33:43 * jonkri watching the manatee video
04:33:46 <jonkri> ManateeLazyCat: i'm currently using (ergo)(x)emacs, but i would love to switch to something with better ghc integration...
04:34:41 <ManateeLazyCat> jonkri: Haha, new version Manatee in developing, the develop speed won't fast like previous version (haven't time), but you know, i'm keep going on it. 
04:35:03 <jonkri> that's nice
04:35:06 <jonkri> good luck with that :)
04:36:03 <ManateeLazyCat> jonkri: When you watch video in few 2 minutes, you will consider it's a browser, but it's not browser after you watch complete. :)
04:36:46 <jonkri> ManateeLazyCat: yeah, i fast forwarded a little bit :)
04:37:47 <shapr> ManateeLazyCat: I like writing Python code!
04:38:39 <ManateeLazyCat> shapr: Not bad, clean like Haskell, but i hate Python's lambda, write too many characters, and you know what? You can't write multiline in lambda block!
04:38:57 <tlonim> ManateeLazyCat: i thought that was a webkit browser custom written .. is that firefox ? 
04:39:14 <ManateeLazyCat> tlonim: Like i said, watch *complete*. :)
04:39:23 <tlonim> ok :)
04:39:25 <shapr> Truly, python lambdas are limited.
04:39:29 <tlonim> it is long man 14:00 :)
04:39:29 <ManateeLazyCat> tlonim: It's not *just* browser. :)
04:39:43 <ManateeLazyCat> tlonim: I think it's worth you watch it. :)
04:39:50 <tlonim> ManateeLazyCat: ok.
04:40:08 <shapr> Jag forst√•r inte.
04:40:11 <ManateeLazyCat> tlonim: I'm glad to ask me "what's it" after you watch *complete* it. :)
04:40:36 <tlonim> ok
04:40:43 <ManateeLazyCat> shapr: I feeling Python developer haven't understand lambda's power.
04:40:58 <ManateeLazyCat> shapr: Other i dislike is i can't write _ in Python.
04:41:05 <shapr> Yes, I agree.
04:41:16 <ManateeLazyCat> shapr: I like to write _ in Haskell if don't use some variable
04:41:17 <shapr> Guido van Rossum does not believe Functional Programming belongs in Python.
04:42:12 <beastaugh> I've never quite understood why Python has a lambda construct at all, given that prejudice
04:42:20 <ManateeLazyCat> shapr: Special lambda's argument is too many, and you just use one of them, it's feeling really bad that waste my finger
04:43:16 <ManateeLazyCat> shapr: When i first read *Python Core Programming*, i wonder Python support lambda, so i write many lambda in Python, after i know i can't write multiline lambda and _  , i delete all lambda
04:43:33 <shapr> On the good side, you do get nested list comprehensions.
04:43:57 <ManateeLazyCat> shapr: I still think Haskell's lambda is best one i seen.
04:44:00 <shapr> But yes, FP in Python does not match.
04:44:01 <shapr> I agree!
04:44:25 <quicksilver> shapr: I think Guido says things he probably regrets but he is unwilling to retract (pride? stubborness?)
04:44:51 <shapr> quicksilver: Could be, I don't know.
04:44:52 <quicksilver> just because he wrote a programming language some people expect him to have insights about them :P
04:45:47 <ManateeLazyCat> shapr: Except those, Python is clean, beauty language! Of course, after Haskell.
04:45:52 <shapr> of course!
04:46:03 <tlonim> python is not meant to be full FP language.. 
04:47:12 <ManateeLazyCat> Otherwise Python feeling is dynamic check, i always got some type mismatch when program running, ouch! 
04:47:47 <jonkri> ManateeLazyCat: got to go... see you around. and thanks again :)
04:48:08 <ManateeLazyCat> jonkri: You're welcome! :)
04:49:02 <IdolfHatler> Hi, I'm a bit confused: ghc says that ParsecT is not an instance of MonadTrans (or MonadReader og MonadError)... anybody experienced this before?
04:56:50 <IdolfHatler> anybody?
05:01:47 <hpc> aw, i missed a python bash in my sleepiness
05:03:26 <ManateeLazyCat> hpc: Haha, you haven't sleep?
05:03:49 <ManateeLazyCat> tlonim: http://haskell.org/haskellwiki/Manatee#Introduction have answer. :)
05:06:31 <Cale> IdolfHatler: That is confusing
05:06:49 <Cale> IdolfHatler: could you paste a more precise message on hpaste?
05:07:39 <IdolfHatler> http://hpaste.org/45134/no_instance_for_monadtrans_p
05:07:53 <striker55> hi
05:09:20 <IdolfHatler> Cale: Do you have any ideas?
05:09:46 <Cale> IdolfHatler: hmm, you're using parsec 3.1.1?
05:10:00 <IdolfHatler> perhaps, I wouldn't really know :)
05:10:07 <Cale> ghc-pkg list parsec
05:10:54 <IdolfHatler> /var/lib/ghc-6.12.1/package.conf.d: parsec-3.1.0
05:10:55 <IdolfHatler> /home/freaken/.ghc/x86_64-linux-6.12.1/package.conf.d:   parsec-2.1.0.1
05:11:43 <Cale> Okay, and you're importing  Text.Parsec, just to be sure
05:12:09 <IdolfHatler> Text.Parsec.Prim
05:12:43 <Cale> and Text.Parsec.ByteString?
05:12:50 <IdolfHatler> yeah
05:13:00 <IdolfHatler> ByteString.Lazy, but all the same
05:13:16 <IdolfHatler> just tried, it didn't change anything that I used Text.Parsec
05:13:33 <Cale> instance MonadTrans (ParsecT s u) where
05:13:34 <Cale>     lift amb = ParsecT $ \s _ _ eok _ -> do
05:13:34 <Cale>                a <- amb
05:13:34 <Cale>                eok a s $ unknownError s
05:13:40 <Cale> ^^ this is in Text.Parsec.Prim
05:13:43 <Cale> So, huh
05:14:39 <IdolfHatler> delete .cabal and .ghc and try again?
05:14:47 <IdolfHatler> or won't that fix anything?
05:15:46 <Cale> Well, I guess you could try it, but I'll be a bit surprised. I was worried that it might be using that parsec-2.1.0.1
05:15:59 <Cale> But parsec-2.1.0.1 didn't have a Text.Parsec.Prim module
05:16:08 <IdolfHatler> k
05:16:29 <IdolfHatler> I don't really have much idea how the package system works yet :)
05:22:32 * hackagebot dimensional 0.8.2.1 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.8.2.1 (BjornBuckwalter)
05:24:23 <applicative> I guess it couldn't be that IdolfHatler has the wrong monad transformer library?
05:24:38 <IdolfHatler> perhaps: but removing .cabal and .ghc worked
05:24:46 <IdolfHatler> I'm still puzzled :)
05:30:02 <applicative> IdolfHatler: It works now?  
05:30:26 <IdolfHatler> yeah
05:30:33 * hackagebot repa-examples 2.0.0.2 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-2.0.0.2 (BenLippmeier)
05:30:48 <IdolfHatler> well, that file compiles - I don't know if I will have other problems :)
05:31:35 <applicative> It is a little baffling; it's hard to see how ghc could know enough to give that error, and still give it.
05:33:21 <onit> hi, new on haskell.want to have a function that takes a list of sorted Ints and returns a list of range tuples
05:33:28 <onit> clues?
05:33:54 <onit> i check the library - Data.List/utility
05:34:04 <onit> anyone in?
05:34:09 <sipa> what do the range tuples represent?
05:34:11 <mauke> I don't know of one
05:34:29 <onit> they r plain  numbers
05:34:42 <onit> [1,2,3,5,6,7,9,10) -> [(1,3), (5,7), (9,10)]
05:34:45 <mauke> my guess: "abcmnwxyz" -> [('a', 'c'), ('m', 'n'), ('w', 'z')]
05:34:55 <sipa> oh i see
05:35:24 <applicative> we'll just have to define one.
05:35:30 <onit> so mauke, since u caught my drift in some way, any clues
05:35:38 <onit> r there library for this stuff?
05:35:43 <sipa> maybe
05:35:50 <sipa> but it's not hard to write it yourself
05:35:52 <quicksilver> yes, it's called Haskell.Homework
05:35:55 <IdolfHatler> applicative: I might have been using the wrong transformer lib, which I then removed?
05:36:00 <quicksilver> contains all the answers one after another :)
05:36:35 <applicative> IdolfHatler: that's what i was thinking, but i thought the troubles about that were cleared up.  
05:36:42 <quicksilver> No, I don't think that exact function lives in any library but it's a fairly simple one to write.
05:36:52 <onit> <listening/>
05:36:59 <onit> <listening-very-intently/>
05:37:01 <IdolfHatler> applicative: ?
05:38:02 <applicative> IdolfHatler: there was for a while a conflict of monad transformer libraries, mtl being the ancient reputable one, with the same module names.
05:38:31 <quicksilver> to find sequences, recurse through the list checking the current element is (+1) from the element before.
05:39:36 <onit> thats a start
05:40:28 <onit> how shall we spit it out as tuples?
05:40:56 <onit> it might be unbounded list
05:41:18 <onit> why did mauke consider his ranges as "abcmnwxyz" -> [('a', 'c'), ('m', 'n'), ('w', 'z')]
05:41:38 <sipa> is it not what you mean?
05:41:42 <quicksilver> well, once your sequence is complete you evaluate to (start,end) : recursiveCall
05:41:49 <applicative> what are the ranges in "abcmnwxyz"
05:41:50 <onit> i mean why did he "abcmnwxyz" -> [('a', 'c'), ('m',w'),('x','z')]
05:41:58 <onit> why not teh above?
05:42:10 <sipa> ?
05:42:13 <onit> i considered soemthing liek [1,2,3,5,6,7,9,10) -> [(1,3), (5,7), (9,10)]
05:42:26 <applicative> > ['a'..'z']
05:42:26 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
05:42:40 <hpc> > ['a'..'Z']
05:42:41 <lambdabot>   ""
05:42:54 <sipa> onit: i don't see how ('m','w') is present in your string
05:42:55 <hpc> > ['A'..'z'] -- lol
05:42:55 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
05:43:42 <hammi>  > [0..'z']
05:43:43 <applicative> onit, I think we are all on the same page
05:43:55 <onit> sipa, what r you basing the ranges on?
05:44:13 <onit> thx applicative, u might be.i m majorly lost in haskell
05:44:15 <sipa> ('m','w') in the output is supposed to mean m..w, no?
05:44:23 <sipa> > ['m'..'w']
05:44:23 <lambdabot>   "mnopqrstuvw"
05:44:29 <onit> but i jus finsihed one page of reading :)
05:44:35 <applicative> I think we're fretting about a typo somewhere
05:44:36 <sipa> reading what?
05:44:38 <frerich> onit: Another idea - you could also consider massaging the list into a list of sequences, e.g. [1,2,3,5,6,7,9,10] becomes [[1,2,3],[5,6,7],[9,10]] and then take the first and last element of each list for your result
05:44:48 <onit> oh yes , got it sipa
05:45:13 <onit> the haskell wiki
05:45:26 <sipa> about what?
05:45:51 <onit> no applicative, sipa was right.i had an understnading gap<geez>.now its sorted
05:45:59 <ariabbas> ...
05:46:18 <onit> the list into a list of sequences..hmm
05:47:24 <sipa> @let rangeTuples [] [a] = [(a,a)]; rangeTuples [] (a:b:r) | b==a+1 = rangeTuples [(a,b)] r | rangeTuples [(f,s)] (a:r) | a==s+1 = rangeTuples [(f,s+1)] r; rangeTuples x y = x ++ rangeTuples [] y
05:47:24 <lambdabot>   Parse error: |
05:47:53 <onit> i see
05:48:06 <onit> atleast the conciseness of haskell is lovely
05:48:23 <sipa> @let rangeTuples [] [a] = [(a,a)]
05:48:24 <lambdabot>  Defined.
05:48:29 <onit> once i understand it it will be awesome :)
05:48:43 <sipa> @reset
05:48:43 <lambdabot> Unknown command, try @list
05:49:23 <sipa> @let rangeTup [] (a:b:r) | b==a+1 = rangeTup [(a,b)] r; rangeTup [(f,s)] (a:r) | a==s+1 = rangeTup [(f,s+1)] r; rangeTup x y = x ++ rangeTup [] y
05:49:24 <lambdabot>  Defined.
05:49:37 <sipa> > rangeTup [] [1,2,3,5,6,7,9,10]
05:49:40 <lambdabot>   mueval-core: Time limit exceeded
05:49:43 <sipa> :(
05:50:08 <sipa> how do i reset lambdabot's memory?
05:50:16 <onit> hee hee\
05:50:18 <sipa> @reset
05:50:18 <lambdabot> Unknown command, try @list
05:50:23 <sipa> @forget rangeTup
05:50:23 <lambdabot> Incorrect arguments to quote
05:50:24 <Kaidelong> @define
05:50:29 <onit> i think he is supervisor bribed by ghc
05:50:32 <hpc> @undefine
05:50:38 <sipa> @undefine rangeTup
05:50:47 <onit> why do you keep a timer, lamdabot
05:50:53 <onit> good things take time
05:51:01 <hpc> onit: evil things take infinite time
05:51:22 <hpc> and the best things are done in ghci
05:51:37 <sipa> @let rangeTup [] (a:r) = rangeTup [(a,a)] r; rangeTup [(f,s)] (a:r) | a==s+1 = rangeTup [(f,s+1)] r; rangeTup x y = x ++ rangeTup [] y
05:51:39 <lambdabot>  Defined.
05:51:46 <sipa> > rangeTup [] [1,2,3,5,6,7,9,10]
05:51:50 <lambdabot>   mueval-core: Time limit exceeded
05:51:55 <onit> ha ha..hpc
05:52:04 <hpc> :D
05:52:20 <sipa> @undefine rangeTup
05:52:30 <sipa> @let rangeTup [] [] = []; rangeTup [] (a:r) = rangeTup [(a,a)] r; rangeTup [(f,s)] (a:r) | a==s+1 = rangeTup [(f,s+1)] r; rangeTup x y = x ++ rangeTup [] y
05:52:31 <lambdabot>  Defined.
05:52:34 <sipa> > rangeTup [] [1,2,3,5,6,7,9,10]
05:52:36 <lambdabot>   [(1,3),(5,7),(9,10)]
05:52:52 <sipa> @undefine rangeTuple
05:52:58 <sipa> @let rangeTuple = rangeTup []
05:52:59 <lambdabot>  <local>:1:13: Not in scope: `rangeTup'
05:53:05 <onit> Prelude> let rangeTup [] (a:r) = rangeTup [(a,a)] r; rangeTup [(f,s)] (a:r) | a==s+1 = rangeTup [(f,s+1)] r; rangeTup x y = x ++ rangeTup [] y
05:53:05 <onit> Prelude> rangeTup [] [1,2,3,5,6,7,9,10]
05:53:06 <onit> [(1,3),(5,7),(9,10)
05:53:06 <Kaidelong> sipa: just "undefine"
05:53:15 <onit> i ran sipa stuff on ghc
05:53:21 <onit> and isnt that working
05:53:26 <onit> it seemed to me..
05:53:40 <sipa> onit: i forgot one clause
05:54:38 <sipa> @let rangeTup [] [] = []; rangeTup [] (a:r) = rangeTup [(a,a)] r; rangeTup [(f,s)] (a:r) | a==s+1 = rangeTup [(f,s+1)] r; rangeTup x y = x ++ rangeTup [] y
05:54:38 <lambdabot>  Defined.
05:54:44 <sipa> @let rangeTuple = rangeTup []
05:54:45 <lambdabot>  Defined.
05:54:53 <sipa> > rangeTuple [1,2,3,4,5,6,7,8,9,10]
05:54:55 <lambdabot>   [(1,10)]
05:55:36 * hackagebot repa 2.0.0.2 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.0.0.2 (BenLippmeier)
05:55:38 * hackagebot repa-bytestring 2.0.0.2 - Conversions between Repa Arrays and ByteStrings.  http://hackage.haskell.org/package/repa-bytestring-2.0.0.2 (BenLippmeier)
05:57:36 * hackagebot repa-io 2.0.0.2 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-2.0.0.2 (BenLippmeier)
05:57:38 * hackagebot repa-algorithms 2.0.0.2 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-2.0.0.2 (BenLippmeier)
06:06:51 <onit> thanks sipa/lambdabot - was great help
06:07:02 <onit> it worked
06:07:10 <onit> n skips the meory error too
06:07:22 <onit> i m trying to understand it
06:08:00 <onit> will read more and will be back for more l8r.thanks :)
06:11:06 <applicative> hmm, did the repa site have that fancy edge detection demo before. 
06:12:59 <applicative> the fancy OS X binary 'just works'.  All this prodigious competence is surely unwholesome.
06:32:42 <gronliz> why is not GHC.Prim ByteArray# used to implement Bytestring?
06:33:32 <Saizan> one of the reasons is that it's not portable
06:33:57 <gronliz> lol GHC is Haskell
06:35:39 <gronliz> who writes portable haskell?
06:36:20 <byorgey> people who are writing fundamental libraries which they hope will become widely adopted, such as ByteString.
06:36:31 <benmachine> there are other compilers
06:36:35 <Kaidelong> how useful is Jhc?
06:36:39 <Kaidelong> at this point
06:36:51 <rtharper> and text!
06:36:55 <benmachine> Kaidelong: it's probably less stable than GHC but it's supposed to be pretty good
06:37:05 <benmachine> it has a proper garbage collector now
06:37:06 <Kaidelong> maybe I should give it a try then
06:37:22 <benmachine> I could never get the libraries to compile iirc
06:37:23 * benmachine shrug
06:37:47 <Kaidelong> wasn't one of the points of Jhc to minimize garbage collection?
06:38:03 <benmachine> well, it was supposed to produce fast code in general
06:38:27 <Kaidelong> any evidence that it does?
06:39:39 <Kaidelong> as a mature thing to mention that isn't GHC, I suppose nhc98, and the yale haskell compiler?
06:39:47 <Kaidelong> oh and the utrecht haskell compiler
06:39:53 <rtharper> UHC!
06:39:59 * rtharper will be hacking on UHC this summer
06:40:29 * Kaidelong has been interested in Jhc but a bit too frightened to try it
06:40:30 <benmachine> http://lhc-compiler.blogspot.com/2010/07/great-haskell-compiler-shootout.html
06:41:04 <gronliz> ghc does not have any serious competitors
06:41:30 <benmachine> it's unquestionable that ghc is way ahead of the competition
06:41:34 <illissius> which is, i think, one of the main things holding back haskell'
06:41:38 <benmachine> but there are niches in the market that it does not cover
06:41:48 <benmachine> illissius: writing a compiler is just hard work ok :P
06:42:08 <jonkri> if i have an event thread reading a channel that should be able to time-out (and reset its own timer everytime it does something), how could i do that? should i have an mvar containing the time of the last action and a separate process looping over that mvar, killing the process (or whatever) when it detects that that the time-out has occurred? 
06:42:09 <Kaidelong> nhc98 works for platforms where ghc can't IIRC
06:42:28 <illissius> the real demand for 'standardize this shit so i can be sure it works the same on each compiler' only really comes once there's actually more than one compiler people want to use for real-world things
06:42:36 <benmachine> jhc can cross-compile to wii I think
06:42:52 <illissius> and which implements the features in need of standardization
06:43:05 <benmachine> illissius: ghc has been very well-behaved wrt extensions
06:43:05 <Kaidelong> looks like Jhc does really well on the benchmarks where it does well and terribly where it doesn't
06:43:17 <benmachine> Kaidelong: heh, probably
06:43:52 <Kaidelong> I am actually surprised to see that it already is competitive with GHC on the mean
06:44:36 <Kaidelong> or is that just because of all the things it can't even compile, perhaps?
06:44:37 <illissius> benmachine: and yeah I know compilers are hard, wasn't disputing that, that's something like the cause of the cause
06:46:39 <Kaidelong> I suppose you have to take in mind that all these benchmarks were written with GHC in mind, too
06:46:47 <accel> what does these two lines of code do?
06:46:50 <accel>                let c | (i .&. n) == (j .&. n) = 0
06:46:55 <accel>                      | otherwise              = 255
06:46:57 <accel> I don't unerstand how it's valid syntax
06:47:02 <accel> shouldn't it be: let c = .... ?
06:47:30 <mauke> they're guards
06:47:35 <illissius> if ((i & n) == (j & n)) c = 0; else c = 255;
06:47:41 <benmachine> guards aren't just restricted to functions
06:47:57 <accel> so guards cn just decide "I'll fuckin pop up wherever I want?"
06:47:59 <illissius> or wait, ignore me.
06:48:06 <accel> and ghc is like "oh, wait, you're a guad, okay, you may pass"
06:48:14 <mauke> accel: only after patterns
06:48:25 <accel> how is let c ... a pattern ?
06:48:29 <accel> that looks like a let binding to me
06:48:30 <mauke> it isn't
06:48:32 <mauke> c is
06:48:33 <benmachine> c is a simple pattern
06:48:44 <accel> hmm
06:48:46 <mauke> let PATTERN = EXPRESSION
06:48:47 <accel> is any "expression" a pattern ?
06:48:51 <mauke> no
06:48:56 <mauke> counterexample: f x
06:48:56 <accel> so c + 1 | ...
06:48:58 <accel> would be bad
06:48:59 <Axman6> accel: c is a function with no arguments
06:49:04 <mauke> Axman6: no
06:49:10 <Axman6> yes damnit
06:49:11 <Axman6> :P
06:49:14 <Kaidelong> Axman6: that doesn't even make sense
06:49:22 <benmachine> Axman6: did you read conal's blog post about this
06:49:25 <Kaidelong> :k (->)
06:49:26 <lambdabot> ?? -> ? -> *
06:49:41 <accel> a war has been started; my job here is done
06:49:47 <accel> so basically, any time where I ahve a = for assignment
06:49:51 <accel> I can just insert a patern there?
06:49:59 <Axman6> guard*
06:50:05 <mauke> no, you already have a pattern there
06:50:22 <accel> noted; thanks
06:50:22 <Axman6> guards in a way split the equal sign based on certain conditions
06:50:33 <benmachine> Axman6: you can also use guards in case statements, where there's not a = but a ->
06:50:38 <Axman6> my students have a hard time understanding this stuff -_-
06:50:51 <Axman6> sure
06:50:57 <Axman6> i never said they couldn't
06:51:01 <benmachine> I think I meant to highlight accel
06:51:41 <illissius> anyway, if we had two viable compilers which people wanted to use and which both implemented a big and important feature like GADTs, MultiParamTypeClasses, or whatever, but in slightly and annoyingly different ways, i bet we'd have a lot more energy being put into drafting a proposal for the haskell' commitee than we do now (where half of people use ghc as a de-facto standard and half of people avoid extensions entirely, half being used in a 
06:51:42 <illissius> metaphorical sense)
06:51:53 <frerich> Hm, interesting, I always wondered what the thing after 'let' was called. Seems my understanding of what a 'pattern' is was wrong, I thought it's some argument configuration for a function.
06:52:09 <Kaidelong> illissius: That has merit really
06:52:19 <benmachine> frerich: well, functions definitions often do have patterns in
06:52:26 <benmachine> frerich: but the concept of patterns is more general
06:52:33 <Kaidelong> on the other hand, standardization around GHC has its advantages
06:52:40 <Axman6> illissius: time to start hacjing on JHC
06:52:43 <benmachine> > let x:xs = [1,2,3] in (x, xs)
06:52:44 <lambdabot>   (1,[2,3])
06:53:11 <Kaidelong> you know that GHC will be maintained, for example.
06:53:39 <Axman6> Kaidelong: i think the inference is that this second compiler is also well maintained
06:53:42 <illissius> Axman6: well personally I'm content to just use GHC as the de-facto standard :-)
06:53:46 <Kaidelong> even with just two out there one might eventually lose steam
06:54:02 <frerich> benmachine : I see, it never occurred to me that you could deconstruct values with 'let', too.
06:54:03 <Kaidelong> with people flocking over to the other
06:54:08 <Axman6> illissius: JHC has some interesting advantages, which i can't remember off the top of my head
06:54:34 <illissius> just trying to analyze why it is that everyone seems to care about haskell' but almost no one seems to care enough to do any work on it and write proposals
06:54:40 <benmachine> frerich: doing so with case is safer, of course
06:54:45 <frerich> benmachine: but now that I think about it, I believe it already used this when writing 'let (row, col) = functionReturningAnIntIntTuple'
06:54:47 <benmachine> (well, in some cases)
06:54:48 <Kaidelong> does Disciple count as a haskell compiler or should I think of it more as a whole other language?
06:54:54 <illissius> the latter, i think.
06:54:57 <benmachine> frerich: right. patterns are everywhere :)
06:55:03 <accel> @hoogle act.
06:55:03 <lambdabot> Parse error:
06:55:03 <lambdabot>   --count=20 act.
06:55:03 <lambdabot>                 ^
06:55:07 <Axman6> Kaidelong: it's definitely a whole language
06:55:11 <accel>    act. PixelData RGBA UnsignedByte
06:55:15 <Kaidelong> alrighty then
06:55:16 <accel> how is that valid haskell code?
06:55:25 <accel> @hayoo act.
06:55:26 <lambdabot> Unknown command, try @list
06:55:28 <benmachine> accel: context? is there a forall before act?
06:55:31 <accel> @list
06:55:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:55:58 <accel> http://hpaste.org/45141/haskell
06:56:02 <accel> http://hpaste.org/45141/haskell <-- how is this vlaid code
06:56:14 <Kaidelong> you want hoogle
06:56:35 <benmachine> accel: weird. are you sure it is?
06:56:51 <benmachine> oh wait yes
06:56:51 <accel> ya
06:56:53 <accel> it conmpiles too
06:56:54 <accel> and fucking runs
06:56:58 <benmachine> act is one of the parameters to the function
06:56:58 <accel> and displays a shitty checkerboard
06:57:05 <accel> but why does it say
06:57:06 <accel> act.
06:57:09 <benmachine> accel: less swearing, there may be children present
06:57:10 <accel> what does the . mean?
06:57:17 <benmachine> presumably it's the (.) operator
06:57:41 <accel> benmachine: this is IRC, all children are really FBI agents
06:57:46 <benmachine> (add please to my swearing comment, it was a request not a command)
06:57:53 <Kaidelong> is that template haskell?
06:58:04 <benmachine> Kaidelong: not that I see
06:58:05 <accel> benmachine: hmm, the "." is indeed the (.) operator -- thanks
06:58:11 <Kaidelong> oh wait
06:58:15 <Kaidelong> that's a list comprehension
06:58:17 <Kaidelong> lovely
06:58:36 <benmachine> accel: my guess is that PixelData RGBA UnsignedByte is a nearly-applied data constructor
06:58:43 * hackagebot hstzaar 0.5 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.5 (PedroVasconcelos)
06:58:47 <djahandarie> Yeah I don't know if I'd use a list comprehension with a let nested inside of it
06:59:02 <accel> with a guard inside the let
06:59:02 <Kaidelong> I don't really like list comprehensions period
06:59:09 <benmachine> I'd use do instead of list comprehension
06:59:14 <benmachine> since they're basically the same anyways
06:59:16 <accel> this must have been someone trying to impress a girl shoulder surfing him
06:59:19 <Kaidelong> yep
06:59:23 <Eduard_Munteanu> Axman6: oh, so you're teaching now? Haskell?
06:59:33 <djahandarie> Axman6, your teaching Haskell?
06:59:34 <applicative> i wonder if people will stop dissing list comprehensions once they're monad comprehensions again
06:59:47 <Axman6> i'm tutoring the first year comp course at ANU
07:00:10 <Eduard_Munteanu> Nice.
07:00:14 <benmachine> applicative: nah, they'll be basically still redundant :P
07:00:25 <djahandarie> applicative, monad comprehensions are nice when you have 'short' dos. They obviously would be just as bad as oversized list comprehensions
07:00:26 <Kaidelong> applicative: that'd at least be better than having them specifically for lists
07:00:57 <Kaidelong> if you have to have one of the two I'd go with do syntax
07:00:59 <Axman6> it's good fun, the first assignment is to implement langton ants (with all the graphics code written for them)
07:01:06 <Kaidelong> or perhaps the F# style code blocks
07:01:13 <Kaidelong> which are a lot like list comprehensions
07:01:18 <Kaidelong> and a lot like do synta
07:01:19 <applicative> of course they're only good if theyre short.  It never occurs to me to use list comprehensions, but then I see a beautiful use of them and regret it.
07:02:04 <Axman6> yeah, i never use list comprehensions
07:02:13 <Kaidelong> applicative: the simple ones can generally be done easily with neither sugaring anyway
07:02:33 <Axman6> though, the new syntax for doing database query type things with them is interesting, things like order by and.. stuff...
07:02:58 <Eduard_Munteanu> Yeah, SQL-like comprehensions are funny.
07:03:02 <benmachine> Axman6: mm, but adds complexity to the language. I have some sympathy for people who want to keep things simple
07:03:13 <applicative> wasn't the plan of making them monad comprehensions again related to some database scheme too?
07:03:26 <Kaidelong> why does haskell have that unneccessary if..then..else sugar anyway
07:03:31 <Axman6> haskell is already a somewhat complex language.
07:03:42 <benmachine> Axman6: yes, let's not make it worse :)
07:03:52 <Axman6> Kaidelong: because it's fairly easy to teach
07:04:12 <spirit> i'm implementing a few category theory constructs in haskell, but went back to 'pencil and paper' for the moment, in order to get my head round some stuff. not sure it's appropriate to ask here about the correctness of a couple of examples i have come up with, for equalisers that is.
07:04:17 <applicative> I think the idea that it has different ways of doing things, that suit different people etc. is a good one. e.g. let vs where 
07:04:21 <applicative> i hate let.
07:04:31 <djahandarie> spirit, ##categorytheory may be useful for you
07:04:35 <Kaidelong> yeah I also much prefer where
07:04:40 <djahandarie> Most of the CTers here are also in there
07:04:54 * Kaidelong joins for osmosis' sake
07:04:59 <benmachine> applicative: yeah I always use where if possible
07:05:05 <benmachine> but not always possible
07:05:15 <spirit> cheers, will try there
07:05:20 <applicative> no, not always. 
07:05:23 <Kaidelong> benmachine: ...?
07:05:41 <Kaidelong> where can you use let .. in .. where you can't use where?
07:05:45 <Kaidelong> GHCi?
07:05:51 <applicative> i remember some power point of peyton jones giving a list of such duplications 
07:05:53 <benmachine> well, like, halfway through a do-block
07:06:09 <Kaidelong> oh those lets
07:06:18 <benmachine> Kaidelong: that's only one example, there are others
07:06:26 <applicative> Kaidelong: at least, it's sometimes inconvenient to get the right scope for where
07:06:32 <frerich> http://www.haskell.org/haskellwiki/Let_vs._Where
07:07:29 <applicative> http://www.haskell.org/haskellwiki/Declaration_vs._expression_style -- this has a little table of opposing styles, I'm on the left, of course
07:08:55 <applicative> let case if and \x -> are all to be avoided. 
07:09:25 <benmachine> I like case
07:09:49 <benmachine> because I often find that the thing I want to pattern-match on isn't exactly one of the arguments to my function
07:09:52 * applicative admits a weakness for case
07:10:06 <Kaidelong> I generally find that I do not need to use case
07:10:13 <Kaidelong> I am liberal with making top level bindings though
07:10:33 <Kaidelong> if I find that something is getting to be 4 lines or so I figure I may as well make another top level binding
07:11:17 <Kaidelong> well, in a single expression side of the declaration
07:11:23 <applicative> I approve of that practice, partly because it lets the reader see what the types of the intermediate elements are.
07:12:26 <Kaidelong> I find it also makes point-free style easier in some cases
07:13:25 <Kaidelong> a lot of complicated things become function compositions on a single line
07:13:39 <Kaidelong> I think this is also why I tend to avoid do syntax
07:13:57 <Kaidelong> I'd rather make individual a -> m b or m a bindings than have dense do blocks
07:14:03 <spirit> even though this is more of a math-question, simple category theory examples, i hope it's ok to post them here.
07:14:12 <spirit> i'm implementing some simple category theoretic constructs in haskell at the moment and practised a bit using 'pencil and paper' -- i produced a couple of examples of equalisers, one in the category of sets, one in the cat of graphs. correctness check from any of you guys would be much appreciated. here are my examples: http://pastebin.com/E33UHbpv
07:20:56 <accel> @hoogle .&.
07:20:57 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
07:21:00 <accel> wtf
07:21:03 <accel> this type declaration is useless
07:21:07 <accel> @src .&.
07:21:07 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:21:12 <accel> lambdabot: screw you too
07:21:50 <Kaidelong> @src (.&.)
07:21:50 <lambdabot> Source not found. You untyped fool!
07:21:52 <applicative> @hoogle (+)
07:21:52 <lambdabot> Prelude (+) :: Num a => a -> a -> a
07:21:52 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
07:21:52 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
07:22:07 <Kaidelong> I do believe .&. is bitwise AND
07:22:14 <Axman6> yes
07:22:16 <Kaidelong> > 2 .&. 2
07:22:17 <lambdabot>   Ambiguous type variable `a' in the constraint:
07:22:17 <lambdabot>    `Data.Bits.Bits a'
07:22:17 <lambdabot>      a...
07:22:20 <applicative> how is the type declaration worse than for +
07:22:21 <Kaidelong> bah
07:22:25 <Kaidelong> > 2 .&. 2 :: Word8
07:22:26 <lambdabot>   2
07:22:33 <Kaidelong> > 2 .&. 18 :: Word8
07:22:34 <lambdabot>   2
07:22:53 <accel> it really isn't
07:22:55 <accel> but I like to bitch
07:23:06 <applicative> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.3.1.0/Data-Bits.html  --accel
07:23:18 <accel> applicative: thanks
07:24:10 * frerich thinks a function called .&. taking two values of a type which is a member the 'Bits' class is quite suggestive about what it does.
07:24:28 <Axman6> frerich: you'd be surprised -_-
07:25:20 <accel> is there a way to tell cabal
07:25:23 <accel> unpack everything I have installed?
07:25:28 <accel> i want to have one giant palce
07:25:29 <accel> that I an grep
07:25:32 <accel> for function names
07:28:46 <dcoutts_> accel: no, but you can use ghc-pkg list or cabal list --installed, to see what you have installed, and then you can cabal unpack that list
07:34:21 <Raynes> BONUS: Ping.
07:35:09 <BONUS> pong!
07:35:16 <BONUS> what's up
07:36:43 <pastorn> BONUS: hey :)
07:36:47 <BONUS> hey yo
07:36:50 <Kaidelong> I am wondering if "List" is a good word to describe the data structure constructed by (:)
07:37:00 <pastorn> i looked through the erlang book which ripped off yours
07:37:00 <Axman6> why not?
07:37:03 <Kaidelong> it makes people think of them as lists, which is clearly wrong
07:37:07 <Axman6> it's a classic linked list
07:37:19 <BONUS> pastorn: well it didn't really rip it off, it's a totally different book :)
07:37:23 <BONUS> but it's inspired by the style
07:37:25 <Kaidelong> Axman6: Only after it is fully evaluated
07:37:27 <Raynes> BONUS: I wanted to ask you about your experiences with No Starch, since you're publishing a book with them. I'm about a quarter inch away from signing a contract with them, so it's nice to hear about experiences from people who have been there.
07:37:47 <pastorn> Sorry to say they have better pictures than yours :(
07:37:58 <pastorn> though, they have better source material: http://learnyousomeerlang.com/static/img/erlang-the-movie.png
07:38:12 <pastorn> (well, some of its pictures)
07:38:24 <BONUS> haha
07:38:28 <mauke> better pictures? that's unpossible
07:38:30 <BONUS> yeah it has awesome pictures
07:38:40 <pastorn> your bug describing head/tail is pretty awesome :D
07:39:03 <pastorn> those are called "centipedes", right?
07:39:06 <mauke> no, wiggler
07:39:25 <applicative> i dont agree that the erlang pictures are better. and the lawn at the top has to go.
07:39:42 <mauke> http://www.google.de/images?q=wiggler
07:40:45 <pastorn> i think he might eat it... http://www.city-data.com/forum/attachments/san-antonio/39453d1239233722-centipedes-_41069480_centipede_pa_ok2.jpg
07:43:09 <luite_> looks yummy, you should be quick to bite it before it bites you though
07:45:29 <Kaidelong> the erlang text mentions that static typing is mostly about type errors, but there is a performance rationale as well
07:46:05 <rtharper> WAHHH why would someone post that
07:46:07 <Kaidelong> but I guess the author is not worried about that
07:46:15 <rtharper> must disable auto image loading...\
07:46:52 <pastorn> rtharper: you didn't like the centipede?
07:47:01 <rtharper> I think things with...legs
07:47:03 <rtharper> *hate things
07:47:24 <luite_> you like snakes better?
07:47:28 <rtharper> yeah
07:47:33 <rtharper> I don't mind snakes at all
07:47:40 <rtharper> insects, arachnids
07:47:41 <luite_> though some snakes have rudimentary legs
07:47:45 <rtharper> I know
07:47:56 <rtharper> their vestigial stumps don't really scare me
07:47:59 <rtharper> but insects
07:48:00 <rtharper> arachnids
07:48:04 <rtharper> *shudders*
07:48:21 <rtharper> any arthropod
07:48:22 <luite_> hehe, I think centipedes are neither insecs nor arachnids :)
07:48:36 <rtharper> I said arthopod
07:48:45 <rtharper> =D
07:48:59 <luite_> yes but I was already typing that :p
07:49:17 <rtharper> lol
07:49:21 <Kaidelong> chilopods
07:49:38 <rtharper> I think the Carboniferous era represents my Hell
07:56:17 <mrcarrot> could anyone take a look at this code and tell if it is well made. coming from imperative world, it feels fishy to do this many function calls: http://pastebin.com/ku6DVT06
07:56:34 <mrcarrot> it is working and it is my implemetation of fibonacci
07:57:54 <monochrom> it is just fine.
07:59:22 <Kaidelong> fibs = 1 : scanl (+) 1 fibs
07:59:26 <Kaidelong> achieves the same thing
08:00:40 <Kaidelong> sans arguments
08:01:23 <Axman6> monochrom: that code should compile into very efficient code, much like you would write in C
08:01:41 <Kaidelong> mrcarrot, you meant, Axman6 
08:02:03 <Kaidelong> also it would memoize
08:02:13 <Kaidelong> which is not true of something you'd generally write in C
08:02:28 <applicative> mrcarrot, seems good. you aren't wasting any function calls are you?  it's sort of self-memoizing
08:02:38 <Axman6> Kaidelong: well, it would evaluate the list, but that is a bad thing really
08:03:03 <Kaidelong> Axman6: How else do you propose calculating fibbonaci numbers though?
08:03:10 <Kaidelong> I know there is an analytical formula
08:03:13 <Axman6> i wouldn't use a list
08:03:19 <Kaidelong> but calculating it is just as difficult in practice IIRC
08:03:51 <Kaidelong> well, calculating it to a sufficiently precise value to get an actual fibbonaci number out
08:03:59 <Axman6> > let fibs n = fibs' n (0,1) where fibs' 0 (x,_) = x; fibs' n (x,y) = (y,x+y) in fibs 100 :: Int
08:04:00 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t, t)
08:04:15 <Axman6> > let fibs n = fibs' n (0,1) where fibs' 0 (x,_) = x; fibs' n (x,y) = fibs' (n-1) (y,x+y) in fibs 100 :: Int
08:04:15 <lambdabot>   3736710778780434371
08:04:24 <Axman6> > let fibs n = fibs' n (0,1) where fibs' 0 (x,_) = x; fibs' n (x,y) = fibs' (n-1) (y,x+y) in fibs 1000 :: Integer
08:04:25 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
08:04:30 <Axman6> > let fibs n = fibs' n (0,1) where fibs' 0 (x,_) = x; fibs' n (x,y) = fibs' (n-1) (y,x+y) in fibs 10000 :: Integer
08:04:30 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
08:09:17 <mrcarrot> one of the reason i am asking about this implementation is that my simple implementation in python outperforms this implementation... even though i compile with -O2
08:10:13 <Axman6> you simple implementation is probably not building up a huge list in the process. try the one i just wrote
08:10:15 <monochrom> does "simple implementation" use "big ints"? such as fib 10000 = 336447648764317832666216120051075433103021484606800639065647699746800814421...
08:10:52 <mrcarrot> okay, thanks
08:11:20 <Axman6> will the python one give you the actual answer? it does it have limited precision?
08:15:22 <mrcarrot> Axman6: it gives the very same result... the actual number
08:15:50 <jlouis> Axman6: python has arbitrary sized integers by default
08:16:18 <Axman6> i wasn't sure, I've not used python extensively
08:16:52 <jlouis> mrcarrot: chances are your code is doing something which is quite slow, or your algorithm is different
08:17:03 <benmachine> man, API design is hard
08:17:05 <azaq23> it just converts automatically, beneath int there's the type long. try type(int(<big integer>)), leads to <type 'long'>
08:17:18 <jlouis> Haskell ought to execute faster for a CPU-bound task like calcing the nth fib
08:17:47 * benmachine can't work out how to translate getsockopt into sensible haskell
08:17:54 <jlouis> benmachine: it is. 
08:18:19 <jlouis> benmachine: I like to have an actual use case for the API as well so you can check it is possible to work with it
08:18:36 <jlouis> for sockets, I'd probably try to get an API at a quite low level
08:19:41 <benmachine> jlouis: the thing is that getsockopt just has no type safety whatsoever
08:22:56 <mm_freak> usually i pass messages to a thread using an MVar
08:23:03 <mm_freak> is throwing async exceptions faster?
08:23:07 <jlouis> benmachine: ah, details :)
08:23:23 <mm_freak> for example have a thread, which sleeps forever, until an exception is raised
08:23:27 <benmachine> jlouis: well I basically have to either have something horrible and unhaskelly or just reinvent the whole thing
08:23:42 <jlouis> benmachine: I see your pain, indeed
08:24:23 <jlouis> mm_freak: I wouldn't expect it to be so much faster/slower it matter in the large
08:26:23 <deibit> hello every haskeller. I'm donwloading haskell platform, but already got ghc 6.12 (from a former install)
08:26:54 <deibit> would I need (and how) uninstall the old platform before this new one?
08:27:03 <deibit> i'm on a mac
08:27:28 <manateeUser> Haha, buy a SSH account today, sweet now. :)
08:28:06 <Axman6> deibit: how did you install 6.12?
08:28:16 <Axman6> platform?
08:28:54 <deibit> is so simple but my question is if they can live together or should i uninstall prior release
08:29:19 <deibit> prior is 2010.10 I think
08:29:25 <Axman6> they don't live together too nice in my experience. i would install personally
08:29:46 <deibit> what's the best way to uninstall it?
08:30:01 <applicative> there is an uninstaller inside the platform stuff
08:30:08 <deibit> b00b cuestion but i'm lost in a mac
08:30:17 <deibit> sorry I mean n00b
08:31:03 <deibit> do you know how the uninstaller is named?
08:32:22 <applicative> uh
08:32:30 <applicative> this: /Library/Frameworks/GHC.framework/Versions/Current/Tools
08:33:22 <applicative> i'm not sure you need to uninstall, the platform installer seems to know about previous versions i had
08:33:46 <applicative> it re-symlinks the ghc in /usr/bin
08:33:55 <applicative> and so on
08:35:26 <deibit> uninstaller found on: /Library/Frameworks/GHC.framework/Tools
08:35:31 <applicative> deibit: this is the executable uninstaller, sorry for error proneness: : /Library/Frameworks/GHC.framework/Versions/Current/Tools/Uninstaller
08:35:44 <deibit> thanks applicative 
08:36:22 <Athas> Is there a variant of Map that maintains order of insertion?
08:36:24 <deibit> I  think the same as you, it would re-sym links to Current->7.03 
08:36:38 <deibit> but for sure...I prefer uninstall it
08:36:43 <Athas> I can hack it together with [(k,a)] and some utility functions, of course.
08:37:23 <applicative> deibit: yeah.  I just installed 7.0.3 while i've been on here today
08:37:44 <deibit> The Glorious Glasgow Haskell Compilation System, version 7.0.2
08:37:58 <deibit> glorious on boat!
08:38:22 <monochrom> "fibs n = fibs' n (0,1) where fibs' 0 (x,_) = x; fibs' n (x,y) = fibs' (n-1) (y,x+y)" is as tight as it gets. I have looked at the core. Even the tuple is eliminated.
08:38:35 <applicative> justly so-called
08:38:54 <Axman6> monochrom: yeah removing the tuple was going to be the only thing I'd suggest
08:39:14 <Axman6> unrolling may speed it up slightly
08:40:14 <kaf3ii> anyone knows how to disable capslock ? 
08:40:44 <Axman6> kaf3ii: keyboard prefs, there's a button labled something like special keys in the bottom right corner
08:41:38 <kaf3ii> im using xmonad and would preferably use xmodmap/setxkbmap if its doable..
08:42:50 <kaf3ii> it used to work before but when i reinstalled my system i can't get xmodmap -e "clear lock" to disable the capslock
08:43:54 <kaf3ii> my goal is to use capslock as mod3 to control xmonad
08:44:27 * Axman6 wonders why on earth you would bother with X11 on OS X
08:45:23 <applicative> Axman6: for xmonad of course
08:45:36 <Axman6> uh, sorry, thought this was #Mac OS X
08:45:42 <applicative> hah
08:45:44 <Axman6> frigging autocorrect
08:45:54 <Axman6> kaf3ii: ignore everything i said :)
08:46:25 <kaf3ii> sorry thought this was #archlinux 
08:46:30 <applicative> hah
08:46:45 <monochrom> sorry, it's for #os/2
08:46:59 * applicative watches the ships passing in the night
08:46:59 <Axman6> using xmonad on arch is perfectly acceptable
08:47:08 <monochrom> damn, should have said #appleIIe
08:47:13 <applicative> whats wrong with xmonad on OS X
08:47:48 <monochrom> hi! how do I install haskell platform on apple IIe?  XD
08:47:53 <Axman6> well, using X11 on OS X is idiotic imo
08:48:55 <osoleve> i actually had a use for it once
08:49:12 <Axman6> so have i, but it's not something i look forward to
08:49:27 <Axman6> MATLAB uses some bizzare mix of Java windows and X11 windows
08:49:28 <applicative> funny, i like xmonad on os x.  it's like a secret world.
08:49:46 <osoleve> i was doing computational chem research, and would SSH into a SC or HPC to run the simulations, and using X i was able to see what I was doing, haha
08:50:06 <monochrom> don't worry about what non-users of your computer think of your computer settings.
08:50:08 <Axman6> i hope those weren't real time graphical sims :P
08:50:20 <osoleve> Axman6: of course not
08:50:29 <Axman6> that's ok then
08:50:42 <Axman6> i have no problem with using ssh -X on OS X. 
08:51:05 <monochrom> (despite what I say about 1970s terminals universally)
08:51:07 * Axman6 is writing a graph processing assignment for running on an HPC cluster
08:52:59 <Axman6> running MPI code on my macbook pro makes its fans very loud
08:53:30 <monochrom> do your fans say "go go Axman6 go!"?  <duck>
08:53:51 <Axman6> what else would fans say?
08:54:33 <monochrom> they might make waves instead
08:54:56 <benmachine> "whirrrr"
08:55:12 <sonoflilit> Hello
08:55:38 <sonoflilit> I'm having performance problems with a Yesod webapp probably coming from suboptimal GC strategy
08:55:48 <sonoflilit> how do I tackle handling such issues?
08:56:18 <Axman6> what makes you think that's the cause?
08:56:51 <sonoflilit> after a data export operation, my app takes 500M memory, and stays there forever
08:57:06 <Axman6> which version of ghc?
08:57:20 <sonoflilit> this makes the entire system thrash (server only has ~700M)...
08:57:21 <sonoflilit> 6.12
08:57:38 <benmachine> I think it was quite recently that GHC started returning freed memory to the OS
08:57:47 <Axman6> 6.12.what? i think one of the 6.12's added giving free memory back to the OS
08:57:54 <Axman6> possibly 7.0
09:00:52 <monochrom> +RTS -M4M -RTS  to limit heap to 4M.
09:01:42 <sonoflilit> monochrom: and what would happen if heap ever tries to go over 4M?
09:01:48 <monochrom> abort
09:02:08 <sonoflilit> monochrom: that's a tad problematic in a production webserver
09:02:23 <sonoflilit> Axman6: so moving to ghc7 would solve my woes?
09:02:43 <quicksilver> I doubt it.
09:02:53 <quicksilver> even if that memory is not really 'returned' to the OS it's still not in use
09:02:56 <quicksilver> so it won't cause thrashing
09:02:58 <monochrom> a "product" webserver, my friend, has 70GB RAM, not 700MB.
09:03:00 <quicksilver> it'll just get swapped out.
09:03:15 <monochrom> s/product/production/
09:03:40 * quicksilver has multiple webservers in production and I can tell you none of them have anything like 70G in them ;)
09:03:41 <sonoflilit> perhaps if I increase frequency of GC it would never spike so high?
09:03:46 <Twey> +1
09:04:19 <DRMacIver> I have production webservers with anything from 200MB of RAM to 16GB. I definitely don't have anything with 70GB.
09:04:47 <djahandarie> I have a server with 70GB of RAM, I think
09:04:50 <djahandarie> Let me check
09:05:41 <DRMacIver> If we had a server with 70GB in it we'd have much better things to do with it than serve web pages. :)
09:05:44 <djahandarie> 56 GB
09:05:50 <djahandarie> xen2:~ # cat /proc/meminfo 
09:05:51 <djahandarie> MemTotal:     58866688 kB
09:06:33 <sonoflilit> or is there anything else I can do to make GC better fit my use case?
09:06:44 <DRMacIver> sonoflilit: Generate less garbage? :)
09:07:13 <quicksilver> sonoflilit: I think you need to analyse your problem more carefully.
09:07:23 <quicksilver> It doesn't necessarily matter that it's using 500M if it isn't really using it.
09:07:30 <quicksilver> it'll just be swapped out as I said.
09:07:30 <DRMacIver> (apparently those servers I had in mind are 12GB, not 16GB)
09:07:46 <quicksilver> on the other hand if it really is using it... then that's what you need to look at.
09:07:56 <djahandarie> And interesting, all this server does is run irssi, for the most part
09:07:59 <djahandarie> interstingly
09:08:16 <sonoflilit> quicksilver: but every time it spikes, it has to swap hundreds of megs twice
09:08:22 <monochrom> hahaha, 56GB scrollback buffer for your irssi
09:08:30 <djahandarie> I will never forget.
09:09:00 <quicksilver> sonoflilit: sure, if it really needs that memory. If it really needs that memory then you need to stop it needing it.
09:09:05 <sonoflilit> once when it spikes, once when the rest of the software inhabiting the machine wants to do stuff
09:09:09 <quicksilver> (if you don't have it available)
09:09:32 <sonoflilit> quicksilver: I have a feeling it just doesn't GC enough
09:09:48 <sonoflilit> but maybe it has some strange need for all of it to be around until export is finished...
09:10:14 <quicksilver> I'm pretty sure you're wrong about it not GC'ing enough.
09:10:29 <quicksilver> it's quite easy to test putting in a few hundred extra GC calls but I bet it doesn't work.
09:10:52 <quicksilver> GHC will never allocate more memory without first trying to GC
09:11:01 <quicksilver> so you get a forced GC each time your memory footprint increases.
09:11:05 <sonoflilit> quicksilver: because you think then it wouldn't have spiked so high?
09:11:12 <osoleve> what's wrong with saying safeInit (x:xs) = Just [x] : safeInit xs? I'm getting "Couldn't match expected type 'Maybe [a]' with actual type [a0]"
09:11:14 <sonoflilit> ah
09:11:29 <quicksilver> in fact, that's backwards - memory allocation is *caused* by a GC
09:11:41 <sonoflilit> huh?
09:11:45 <quicksilver> if it runs a GC, and doesn't clear out much space, it says "OK, we actually do need some more heap here"
09:11:53 <quicksilver> osoleve: (Just x) : ....
09:12:09 <quicksilver> probably.
09:12:23 <osoleve> quicksilver: same error. it's a problem with "safeInit xs" I think
09:13:22 <Jafet> What's safeInit?
09:13:32 <monochrom> @let safeInit (x:xs) = Just [x] : safeInit xs
09:13:33 <lambdabot>  Defined.
09:13:37 <monochrom> @type safeInit
09:13:37 <lambdabot> forall t. [t] -> [Maybe [t]]
09:13:42 <monochrom> works
09:13:45 <monochrom> @undefine
09:13:50 <Jafet> Sounds useful
09:13:59 <quicksilver> osoleve: what type did you want it to be?
09:14:09 <osoleve> [a] -> Maybe [a], quicksilver 
09:14:18 <dmwit> Surely there would be a catMaybes in there.
09:14:30 <monochrom> [a] -> [Maybe [a]]
09:14:33 <quicksilver> then you wanted safeInit (x:xs) = Just (x:xs) surely?
09:14:39 <quicksilver> or, erm
09:14:47 <quicksilver> oh, I see
09:14:57 <Jafet> concat.catMaybes
09:14:58 <quicksilver> I don't think you've thought this through. Mind you neither have I :)
09:15:01 <dmwit> :t let safeInit [] = Nothing; safeInit xs = Just (init xs) in safeInit -- ?
09:15:02 <lambdabot> forall t. [t] -> Maybe [t]
09:15:33 <dmwit> :t let safeInit xs = guard (not . null $ xs) >> return (init xs) in safeInit
09:15:34 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m [a]
09:16:09 <dmwit> [init xs | (x:_) <- xs] -- ;-)
09:16:26 <osoleve> :t safeInit (x:xs) = Just (x:fromMaybe xs (safeInit xs))
09:16:27 <lambdabot> parse error on input `='
09:16:29 <dmwit> :t let safeInit xs = [init xs | _:_ <- xs] in safeInit
09:16:30 <lambdabot> forall t. [[t]] -> [[[t]]]
09:16:41 <osoleve> :t let safeInit (x:xs) = Just (x:fromMaybe xs (safeInit xs))
09:16:41 <lambdabot> <no location info>:
09:16:41 <lambdabot>     not an expression: `let safeInit (x:xs) = Just (x:fromMaybe xs (safeInit xs))'
09:16:54 <dmwit> whoops
09:17:22 <monochrom> you want ":t let safeInit (x:xs) = Just (x:fromMaybe xs (safeInit xs)) in safeInit"
09:17:30 <dmwit> Huh, I don't understand that inferred type at all.
09:17:35 <osoleve> :t let safeInit (x:xs) = Just (x:fromMaybe xs (safeInit xs)) in safeInit
09:17:35 <lambdabot> forall t. [t] -> Maybe [t]
09:17:36 <monochrom> or else @let first
09:17:42 <osoleve> thanks, monochrom 
09:17:48 <osoleve> have I mentioned I love you guys?
09:18:34 <benmachine> dmwit: which one?
09:18:58 <BONUS> hey y'all sorry for spamming but upvote this if you like LYAH: http://www.reddit.com/r/programming/comments/ge0p6/promo_code_to_get_learn_you_a_haskell_40_off_e/ thanks!
09:19:11 <dmwit> benmachine: [[t]] -> [[[t]]]
09:19:39 <osoleve> secret bonus swag!?
09:19:46 <dmwit> :t let safeInit xs = [init xs | (_:_) <- xs] in safeInit
09:19:47 <lambdabot> forall t. [[t]] -> [[[t]]]
09:19:54 <dmwit> Parens don't help.
09:19:59 <BONUS> secret bonus swag indeed
09:20:11 <dmwit> Why is xs being inferred to be a [[t]], and not a [t]?
09:20:35 <benmachine> dmwit: because in x <- xs inside a list comprehension, xs :: [a] and x :: a
09:20:49 <benmachine> but in your case x is _:_, so x :: [t] so xs :: [[t]]
09:21:21 <dmwit> ah
09:21:23 <dmwit> Yes, of course.
09:21:50 <dmwit> :t let safeInit xs = [init xs | _ <- xs] in safeInit
09:21:51 <lambdabot> forall t. [t] -> [[t]]
09:22:16 <dmwit> There we go. Now we just need to generalize the comprehension syntax to be arbitrary Monad(Plus)s instead of plain lists.
09:22:34 <monochrom> > let safeInit xs = [init xs | _ <- xs] in safeInit [1,2,3]
09:22:35 <lambdabot>   [[1,2],[1,2],[1,2]]
09:22:53 <dmwit> > let safeInit xs = listToMaybe [init xs | _ <- xs] in safeInit [1,2,3]
09:22:54 <lambdabot>   Just [1,2]
09:22:57 <dmwit> > let safeInit xs = listToMaybe [init xs | _ <- xs] in safeInit []
09:22:58 <lambdabot>   Nothing
09:23:25 <monochrom> not sure why you go through list first.
09:23:38 <dmwit> Because the syntax doesn't allow me to go straight to Maybe.
09:24:01 <monochrom> safeInit [] = Nothing; safeInit x = Just (init x)
09:24:03 <dmwit> If it were monad comprehensions instead of list comprehensions, then it wouldn't go through lists.
09:24:18 <dmwit> monochrom: I want the nice short syntax. I already proposed that long version (and others).
09:26:20 <monochrom> you could write [init xs | _ <- xs]_Maybe to indicate you're after the Maybe monad.
09:26:38 <monochrom> lambdabot-executability? who needs that?
09:26:55 <dmwit> No need for anything so special, a plain old type signature will do.
09:27:06 <dmwit> But list comprehensions aren't monad comprehensions in lambdabot (right?).
09:27:21 <dmwit> > [print x | x <- readFile "foo"]
09:27:22 <lambdabot>   Couldn't match expected type `[t]'
09:27:22 <lambdabot>         against inferred type `GHC.Types...
09:27:27 <dmwit> (right.)
09:28:02 <saml> @djinn (a,b,c) -> (c,b,a)
09:28:03 <lambdabot> f (a, b, c) = (c, b, a)
09:28:21 <aristid> dmwit: no monad comprehensions in lambdabot, eh? :) also, it would have to be > join [print x | x <- readFile "foo"] or > [() | x <- readFile "foo", print x]
09:28:45 <dmwit> err... yeah, I suppose it would
09:28:54 <monochrom> then again without lambdabot-executability you can't check your types
09:29:05 <aristid> you can do :t
09:29:13 <aristid> IO (IO ()) would be a strong clue :)
09:29:22 <monochrom> "I have a shorter way to write that if it doesn't have to type-check" XD
09:30:28 <Jafet> Redefine IO to act like ST
09:30:40 <aristid> monochrom: infinite types? :)
09:30:44 <Jafet> Or that sandboxed IO on hackage
09:31:06 <monochrom> @vixen do you like infinite types?
09:31:06 <lambdabot> yah, i like
09:31:19 <monochrom> infinite types are so hot!
09:31:39 <monochrom> err, infinite type programmers
09:31:53 <Jafet> Mmm baby, let's go do something corecursive.
09:32:03 <djahandarie> It really bugs me how google 'corrects' comonad to monad every time
09:32:38 <monochrom> click on the "I really want comonad" link. it will train google.
09:33:04 <monochrom> every click trains. make sure you click what you want and avoid what you don't want.
09:33:27 <Jafet> Start a project across all haskell blogs to feature the word "comonad"
09:33:42 <monochrom> if you don't train, someone else will anyway, but at your expense, i.e., train towards what he/she wants but not what you want
09:34:48 <dmwit> Huh, clicking Google links trains Google? Where does it say that?
09:35:03 <quicksilver> google monitor and record every click you make
09:35:21 <quicksilver> and they customise their default behaviour towards what makes them the most billions of dollars per second.
09:35:32 <quicksilver> which in some cases may be the behaviour you want.
09:35:39 <Jafet> In Soviet Russia, Google searches you.
09:35:44 <quicksilver> if you're selling comonads, for example, via adwords.
09:35:54 <dmwit> I just google'd "test", and don't see any Javascript or special link-forwarding on the returned results.
09:36:01 <dmwit> Therefore I'm going to say [citation needed].
09:36:09 <quicksilver> why would they need javascript of special link forwarding?
09:36:18 <quicksilver> it's their server. They have the logs.
09:36:20 <dmwit> How else can they tell what link I clicked?
09:36:24 <quicksilver> they know what you typed first
09:36:28 <dmwit> They can tell what I searched for, yes.
09:36:30 <quicksilver> they know what alternatives they offered
09:36:32 <dmwit> But that's not tracking my every click.
09:36:35 <quicksilver> and they know what you clicked next
09:36:41 <dmwit> No, they don't.
09:36:45 <dmwit> That's what I'm saying.
09:37:15 <quicksilver> why would they not know?
09:37:26 <quicksilver> it's their server, they have a record of every URL you request
09:37:37 <dmwit> No, they have a record of every *google* URL I request.
09:37:43 <djahandarie> I usually scroogle when I can
09:37:54 <dmwit> And the results don't link to google.com, they link to test.com or whatever.
09:38:01 <quicksilver> dmwit: that's not what we're talking about
09:38:07 <dmwit> It's what I'm talking about.
09:38:11 <quicksilver> dmwit: we're talking about the "did you really mean comonad" link
09:38:15 <quicksilver> dmwit: that links to google.
09:38:28 <djahandarie> dmwit, I'm pretty sure the links do link to Google
09:38:31 <quicksilver> the thing it does when you make what it believes to be a typo.
09:38:33 <dmwit> Right, but I'm saying you can't use it for training, because they can't know if you didn't click it what that means.
09:38:35 <monochrom> google takes statistics, remember?
09:38:39 <djahandarie> They did at one point at least...
09:39:01 <dmwit> Or rather, I'm not claiming that you *can't* use it for training, I'm just asking what makes people believe that it *is* used for training.
09:39:02 <djahandarie> Maybe they use Javascript to track that now
09:39:03 <monochrom> if a lot of people click "when I say comonad, I mean it", google will learn.
09:39:05 <dmwit> Does Google say this somewhere?
09:39:44 <DRMacIver> dmwit: It did use to be the case that the links on google's search results weren't actually what you thought they were and redirected from a link on google servers. Checking now that no longer seems to be the case.
09:39:47 <monochrom> various talks in conferences. how their statistics collecting trumps all semantic analysis.
09:40:18 <monochrom> err not conferences, just going to universities to give talk
09:40:23 <quicksilver> DRMacIver: no, they still are, it's just they hack the status bar with javascript so it doesn't appear to be so.
09:40:31 <quicksilver> DRMacIver: try 'copy link location' and you'll see.
09:40:44 <DRMacIver> quicksilver: I just tried exactly that
09:41:07 <quicksilver> DRMacIver: well, it still is that way for me. Odd.
09:41:07 <ezyang> Hey all, what kind of data structure lets me do lookups in both directions, e.g. given k find v, and given v find k. 
09:41:32 <dmwit> ezyang: A pair of Maps. ;-)
09:41:34 <DRMacIver> quicksilver: Odd indeed. Browser difference? 
09:41:40 <ezyang> uguuu 
09:42:17 <djahandarie> uguu
09:42:19 <DRMacIver> So what I'm seeing is that there's javascript onmousedown on the links but the links go to the real origin URLs.
09:42:29 <dmwit> Look at the javascript.
09:42:38 <ezyang> Hee hee the WP article is hilarious: http://en.wikipedia.org/wiki/Bidirectional_map 
09:42:38 <dmwit> It's function clk(...) { return true; }
09:42:44 <dmwit> (At least here.)
09:43:02 <roconnor> @type mapAccumL
09:43:03 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:43:08 <monochrom> diagonalize. use google chrome to analyse google javascript code. :)
09:43:10 <roconnor> @src mapAccumL
09:43:11 <lambdabot> mapAccumL _ s []        =  (s, [])
09:43:11 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
09:43:11 <lambdabot>    where (s', y ) = f s x
09:43:11 <lambdabot>          (s'',ys) = mapAccumL f s' xs
09:43:15 <roconnor> pfft
09:43:17 <djahandarie> ezyang, you should help expand it! ;)
09:43:19 <dmwit> ezyang: There's a bimap package on Hackage.
09:43:50 <roconnor> @hoogle mapAccumL
09:43:50 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
09:43:50 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:43:50 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
09:43:53 <DRMacIver> dmwit: Hm. so it is. Perplexing.
09:44:15 <DRMacIver> dmwit: No, it's redefined somewhere else
09:44:17 <dmwit> So, yeah, I'm keeping my [citation needed] on the "Google tracks all clicks" claim.
09:44:19 <ezyang> Bimap is just... two maps. 
09:44:22 <DRMacIver> dmwit: If I look at it in the javascript console it's much more interesting
09:44:27 <dmwit> ezyang: Yes, just like I said.
09:44:31 <dmwit> DRMacIver: Oh, neat.
09:44:57 <dmwit> ezyang: Why would you expect something more sophisticated than that?
09:45:03 <DRMacIver> dmwit: https://gist.github.com/892729
09:45:22 <DRMacIver> Buggered if I know where that's getting set though.
09:45:23 <ezyang> Not sure, it just feels like there ought to be something better. 
09:46:28 <djahandarie> ezyang, maybe post something to Haskell Cafe?
09:46:33 <ezyang> sure. 
09:46:43 <djahandarie> Make sure the subject is a challenge so Oleg opens it
09:47:01 <dmwit> Better in what way?
09:47:15 <djahandarie> And then claim that it'll be impossible to do [something related to this] in the type system
09:47:21 <dmwit> It's got the same asymptotics as a one-way map, and you surely can't do better than that.
09:49:09 <dmwit> DRMacIver: Well, I'm having a slight bit of trouble reading that javascript, but it mainly seems to be URL-encoding a few characters.
09:49:24 <benmachine> dmwit: it would be really nice if I could have a data structure that evidently was a bijection
09:49:43 <dmwit> Oh, no, I see it.
09:50:20 <dmwit> Yeah, okay, it's tracking. =)
09:50:53 <DRMacIver> dmwit: Frankly it would be *astonishing* if google weren't tracking.
09:51:10 <DRMacIver> Even without specific evidence of them doing so it would take a great deal of convincing for me to believe that they weren't doing it. :)
09:51:21 <dmwit> benmachine: Ugh. I would think the type-hackery needed to do that would be more annoying than it was worth. If you want that, it would be much, much easier and cleaner in Agda, and you probably want something like Agda for whatever you're doing anyway.
09:51:54 <benmachine> dmwit: but it's easy to have a structure which evidently maps each key to one value
09:52:03 <dmwit> benmachine: Not at all.
09:52:11 <dmwit> benmachine: The type of Map doesn't make that guarantee in the slightest.
09:52:20 <benmachine> ok but the interpretation of it does
09:52:22 <benmachine> sorta
09:52:31 <dmwit> Yes, and the interpretation of the bimap type does what you say.
09:52:32 <shachaf> dmwit: Are you talking about Google redirecting to /url... when you click on a link?
09:52:57 <dmwit> shachaf: yep... is that not a tracking trick?
09:52:59 <ezyang> Yeah, you wouldn't be able to improve the asymptotics, since a bimap is only a x2 factor. 
09:53:08 * hackagebot cpsa 2.2.2 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.2 (JohnRamsdell)
09:53:11 <ezyang> But I'd imagine that one ought to do better than "double the time and space" 
09:54:08 <shachaf> dmwit: Yes, but I think one of the reasons that they added that was that people who ran websites complained that they didn't get a Referer header anymore (since searches are being made from /#..., which doesn't get passed along).
09:54:47 <shachaf> It's very annoying that you can't copy links from search results anymore.
09:54:57 <dmwit> ?
09:55:01 <dmwit> I have no trouble copying links.
09:55:45 <Jafet> My browser does not send headers with misspelled names.
09:56:09 <ezyang> hmm, but it doesn't look like I can use a bimap here :-/ 
09:56:13 <shachaf> Jafet: Really? It's not HTTP compliant?
09:56:15 <ezyang> More thought necessary. 
09:56:35 <Jafet> I mean, "referer" isn't a word.
09:56:38 <shachaf> dmwit: If I search for something and copy the link, I get /url?... instead of the link I tried to copy.
09:56:50 <dmwit> shachaf: I don't.
09:56:52 <shachaf> Jafet: Yes, but it *is* an HTTP header.
09:56:57 <dmwit> When was the last time you tried?
09:57:04 <shachaf> A few minutes ago.
09:57:08 <Jafet> I *am* being facetious.
09:57:19 <dmwit> Oh, never mind, I'm still using the old-school version of Google.
09:57:28 <shachaf> Ah, that would explain it.
09:58:02 <monochrom> where can I find the old-school version of Google? :)
09:58:13 <shachaf> Ah, that would explain it.
09:58:17 <shachaf> Er.
09:58:19 <dmwit> monochrom: google.com/search?q=foo
09:58:20 <shachaf> monochrom: web.archive.org
09:58:24 <Jafet> @google old school version of Google
09:58:25 <lambdabot> http://code.google.com/p/prodigypong/
09:58:25 <lambdabot> Title: prodigypong - A Cool Modern Version Of The Simple Old School Pong Game With A Ne ...
09:58:44 <shachaf> dmwit: That's not sufficient, unfortunately.
09:58:45 <Jafet> It hasn't really changed that much, I guess.
09:59:02 <dmwit> monochrom: I've got a bookmark set with keyword "g" to the address "google.com/search?q=%s", so typing "g foo" in my address bar expands to that.
09:59:16 <dmwit> shachaf: Insufficient in what way?
09:59:24 <dmwit> (WFM)
09:59:35 <shachaf> Still goes to "Google Instant", unless you have that turned off.
09:59:37 <djahandarie> How is /search?q=blah any different from the normal version?
09:59:39 <djahandarie> Ah
09:59:55 <dmwit> Right, but links are copyable from /search?q=foo
10:00:15 <shachaf> Ah, I suppose. But then you can't change your search. :-)
10:00:29 <dmwit> ^Lg new search
10:00:31 <dmwit> not too bad
10:00:43 <dmwit> Same keystrokes to do a search as to change it -- very nice.
10:00:59 <shachaf> For adding one word to a 20-word search?
10:01:15 <dmwit> Such complicated searches require one extra click, yes.
10:01:20 <dmwit> Not such a bad price to pay, I guess.
10:02:10 <dmwit> Or, to add just one word
10:02:17 <dmwit> ^L<End>+extra+word
10:02:58 <Jafet> 20-word search?
10:03:29 <dmwit> shachaf: Have I convinced you yet? =)
10:04:39 * shachaf suspects the discussion is pointless. :-)
10:04:50 <sai> [42, 23,23]
10:05:05 <Jafet> I thought I did see some arguments.
10:05:34 <dmwit> Points in my favor: copy-able links. Points in your favor: Google Instant is p. convenient, and very flashy.
10:06:10 <djahandarie> Google Instant really ticks me off anyways
10:06:43 <shachaf> The main advantage of "Google Instant" isn't so much the "instant" bit as the "usable with keyboard only" bit.
10:07:33 <sai> hi guys
10:08:04 <aristid> shachaf: they introduced features for keyboard use actually a few months before instant
10:08:28 <shachaf> aristid: Do you have to enable those explicitly?
10:08:43 <dmwit> The keyboard features still work at /search?q=
10:08:47 <aristid> shachaf: no.
10:09:13 <aristid> shachaf: it's basically just the arrow key navigation
10:09:25 <shachaf> aristid: Doesn't seem to be working.
10:10:10 <aristid> shachaf: confirm the search with enter, then use arrow up and down to switch between search results. works for me.
10:10:21 <aristid> open a result with enter
10:11:15 <shachaf> Not for me, with "Instant" off.
10:12:23 <aristid> shachaf: interesting. before instant came, you could use it. but looks like they bundled that now
10:13:02 <benmachine> install vimperator, problems solved ^_^
10:13:20 <aristid> benmachine: or just keep instant on
10:13:32 <benmachine> or that, I guess
10:16:18 * hackagebot reactive-banana-wx 0.1.0.2 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.1.0.2 (HeinrichApfelmus)
10:18:18 * hackagebot reactive-banana 0.1.0.2 - Small but flexible  functional reactive programming (FRP) library.  http://hackage.haskell.org/package/reactive-banana-0.1.0.2 (HeinrichApfelmus)
10:19:09 <lpsmith> I'm having trouble compiling unix-compat under GHC-7.0.3
10:19:16 <lpsmith> Cabal says: * Missing (or bad) header file: HsUnixCompat.h
10:20:01 <lpsmith> apt-file search HsUnixCompat.h returns one package,  libghc6-unix-compat-dev
10:20:24 <lpsmith> does anybody have any ideas?
10:20:47 <idnar> @src iterate
10:20:48 <lambdabot> iterate f x =  x : iterate f (f x)
10:21:53 <c_wraith> Yeah, iterate doesn't have any clever optimizations
10:25:59 <dcoutts> lpsmith: it'll be that the HsUnixCompat.h (that's distributed with the unix-compat package) fails to compile for some reason
10:26:11 <dcoutts> lpsmith: that's what the (or bad) is alluding to
10:28:26 <lpsmith> dcoutts, yeah,  I see the file in the package.   Have there been changes to cabal that would prevent it from looking in the package's include/ directory?
10:28:26 <lpsmith> because I do have unix-compat installed successfully under ghc-6.12.3
10:28:45 <helloHaskell> hi there
10:29:01 <dcoutts> lpsmith: run configure with -v3, you'll be able to see what the C compiler is complaining about when cabal tests if the header is ok
10:30:43 <lpsmith> /usr/local/hs/ghc-7.0.3/lib/ghc-7.0.3/unix-2.4.2.0/include/HsUnix.h:79: fatal
10:30:44 <lpsmith> error: libutil.h: No such file or directory
10:31:40 <dcoutts> lpsmith: so that explains why cabal is complaining
10:32:00 <dcoutts> lpsmith: but I'm not sure what the cause of the unix problem is
10:32:35 <dcoutts> lpsmith: but it looks like you should file a ghc ticket with all the details
10:33:09 <lpsmith> ok, thanks
10:33:27 <lpsmith> dcoutts, I'll do a few minutes more investigation though
10:34:48 <monochrom> /usr/include/libutil.h belongs to libbsd-dev
10:34:55 <lpsmith> yeah,  I see that
10:36:08 <monochrom> interesting, only libedit-dev depends on it (apart from ghc)
10:36:28 <lpsmith> yeah,  I installed libbsd-dev and I managed to compile unix-compat
10:36:56 <lpsmith> I just "discovered" apt-file a few days ago.  It's a really handy tool!
10:37:12 <lpsmith> thanks monochrom, dcoutts 
10:37:21 * hackagebot unbound 0.2.2 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.2.2 (BrentYorgey)
10:37:33 * monochrom adds that to his haskell platform page just to be sure
10:38:20 <lpsmith> My laptop
10:39:01 <lpsmith> My laptop's HD died a while ago,  so the reason I have unix-compat for ghc-6.12.3 is that I compiled it on that laptop, which probably had libbsd-dev installed
10:39:32 <lpsmith> (fortunately I was able to recover almost all of my files)
10:40:02 <byorgey> hi helloHaskell 
10:40:24 <dcoutts> lpsmith: this was on ubuntu?
10:40:37 <lpsmith> dcoutts, yes
10:40:37 <dcoutts> lpsmith: the "error: libutil.h: No such file or directory" thing
10:40:41 <dcoutts> odd
10:40:50 <dcoutts> lpsmith: are you going to file a ticket?
10:41:54 <lpsmith> like I said,  I installed libbsd-dev and the problem went away
10:42:00 <doserj> there is http://hackage.haskell.org/trac/ghc/ticket/4974 already
10:43:48 <lpsmith> dcoutts, what should the ticket be?   "bad error message,  reporting a missing libutil.h as a missing HsUnixCompat?"
10:43:53 <lpsmith> thanks doserj 
10:44:09 <dcoutts> lpsmith: ah, s'ok the ticket doserj pasted is the one
10:44:12 <dcoutts> I'll comment on that
10:52:59 <monochrom> HsUnixConfig.h controls whether you #include <libutil.h> by way of HAVE_LIBUTIL_H
10:53:44 <monochrom> HsUnixConfig.h is set up by the environment that built ghc.
10:54:25 <monochrom> conceivably, it sets HAVE_LIBUTIL_H according to whether libutil.h was present when ghc was built
10:55:09 <monochrom> it seems that ghc 6.12.3 generic binary tarball was built with libutil.h absent, and ghc 7.0.x with libutil.h present.
10:55:33 <monochrom> (so you didn't needed libutil.h before)
10:56:14 <c_wraith> that sounds plausible
10:56:38 <dcoutts> lpsmith, doserj, monochrom: http://hackage.haskell.org/trac/ghc/ticket/5063
10:56:57 <monochrom> Now, I do not recommend fudging HsUnixConfig.h yourself. The presence of libutil.h (at ghc build time) probably not only controls what HsUnix.h does, but also what code goes into the lib.
10:57:05 <dcoutts> monochrom: right, so what is libutil.h actually used for? seems totally superfluous
10:58:25 <lispy> Does anyone really follow Haskell-Cafe anymore?  Have all the serious technical discussions for Haskell moved elsewhere?  If so, where?
10:58:30 <monochrom> I don't know.
10:58:48 <lispy> I see that SimonM follows SO sometimes
10:59:28 <lpsmith> I've heard rumors that the serious technical discussions have migrated to the Agda community :)
10:59:29 <c_wraith> He also posts to Haskell-Cafe sometimes, still.
10:59:51 <lispy> I had the impression that on Haskell-Cafe just about every email gets tons of replies, but my fast few threads there were mostly not-replied to.
11:00:16 <lispy> (I could be doing something wrong)
11:00:38 <lpsmith> lispy, yeah, I sent an email a while ago asking how to install another top-level exception handler on an existing thread in GHC,  got no response
11:00:46 <lpsmith> I wasn't exactly expecting a response, though
11:01:06 <lispy> Interesting
11:01:19 <monochrom> "get tons of replies" has moved to reddit :)
11:01:24 * hackagebot enumerator 0.4.9 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.9 (JohnMillikin)
11:01:26 <lpsmith> I have an idea that *might* work at this point about how to do that,  but there is a very good chance it won't either
11:01:40 <lispy> I sent my email on to libraries@ with a follow up patch.  I think that may have been where I should have started anyway since it was a question about base.
11:02:33 <lispy> I wonder if -Cafe hit a critical mass, then exceeded what it could sustain and now most people ignore it?
11:02:51 <lispy> I know I unsubscribed for a while because it was too high volume
11:02:56 <lpsmith> well,  emails that are easier to respond to get more responses.   Wadler's Law/ the BSD Bikeshedding issue and all that.
11:03:08 <lispy> oh, good point
11:03:48 <aristid> lispy: i guess a lot of people are still subscribed, but archive all mails into a separate folder and never look into it
11:04:29 <lispy> Basically, I have to be more selective about where I send my questions.  My good 'ole fallback, the Cafe, is not so great anymore me thinks.
11:05:10 <lpsmith> aristid, yeah, that pretty much describes me.   I archive all the -cafe emails into a folder and only sporadically look at it
11:07:28 <monochrom> I answer unanswered haskell-cafe questions within my reach.
11:07:52 <monochrom> ("type family subtle points" is outside my reach)
11:08:59 <djahandarie> I don't subscribe to it
11:09:00 <djahandarie> Too busy
11:09:06 <djahandarie> Even the Agda list is getting too busy for me :p
11:10:05 <monochrom> due to my timezone, there are very few unanswered questions within my reach.
11:10:13 <lispy> I may also need to have more patience with getting a response :)
11:10:25 <lispy> monochrom: what is your timezone?
11:10:25 * hackagebot enumerator 0.4.9.1 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.9.1 (JohnMillikin)
11:10:39 <monochrom> US-Canada eastern time
11:10:43 <lispy> ah
11:10:50 <lispy> I'm US-pacific
11:10:56 <djahandarie> EST here
11:10:57 <monochrom> the bloody Europeans have answered all easy questions.
11:11:09 * lispy nods
11:14:02 <aristid> web-devel is fairly low traffic :) i haven't even bothered setting up a filter
11:22:10 <tarrasch> > seq (error "1") (error "2")
11:22:11 <lambdabot>   *Exception: 1
11:22:21 <tarrasch> Could it be error 2 ever?
11:22:36 <monochrom> rarely, but yes
11:22:50 <tarrasch> monochrom, but always if using pseq, right?
11:22:55 <monochrom> yes
11:23:42 <tarrasch> ah ok, for some reason I thought the thing with pseq was that it calculates the left argument in parallel, but you need to combine it with par to do that, no?
11:24:02 <monochrom> par x y is the parallel one.
11:24:38 <tarrasch> Yes, I guess it's as 'simple' as that ...
11:25:00 <tarrasch> Anyway, thanks monochrom!
11:25:19 <Cin> @bf +++.
11:25:19 <lambdabot>  Done.
11:25:28 <Cin> How do you get lambdabot to output something for bf?
11:25:32 <monochrom> of course, although par is parallel, all parallelism is subject to data dependencies found at run time as things unfold
11:26:08 <Cin> It always seems to reply with Done. to me.
11:26:20 <tarrasch> monochrom, what can a 'data dependency' be?
11:26:59 <monochrom> par x (y+x)  y+x depends on x
11:27:14 <tarrasch> ah ok
11:27:37 <dmwit> ?bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
11:27:37 <lambdabot>   `
11:27:49 <dmwit> Cin: Gotta give it a big enough number that it corresponds to something printable. =)
11:27:57 <dmwit> ASCII 3 is not.
11:27:58 <Cin> dmwit: Ah, ok.
11:28:18 <jmcarthur> awesome to see repa updated
11:28:19 <Cin> (In the terminal it outputs \3.)
11:28:59 <dmwit> I doubt it.
11:29:10 <dmwit> I find it much more likely that it returns (not outputs) "\3" (not \3).
11:31:02 <Cin> No, literally. Try it.
11:31:12 <Cin> $ echo '+++.' | bf 
11:31:12 <Cin> 
11:31:31 <Cin> Well, you can't see it. But in my terminal it shows the little character with 0003 on it.
11:37:04 <lispy> Where does repa get its name?
11:37:15 <lispy> is it an acronym?
11:37:46 <copumpkin> regular parallel arrays
11:37:47 <lispy> oh, indeed: (REgular PArallel arrays)¬†
11:38:08 <copumpkin> REgular Parallel Arrays, I'd guess
11:38:22 <lispy> An it's russian for turnip :)
11:42:36 <monochrom> yikes, turnip
11:42:57 <explorator> anyone actually using this ?
11:43:44 <copumpkin> turnips?
11:43:45 * monochrom trolls. "I use this all the time.  function f(x) { this.x = x; }
11:43:56 <copumpkin> explorator: only 734 people in here
11:43:59 <copumpkin> probably nobody
11:44:06 <explorator> :)
11:44:11 <lispy> I suspect explorator meant repa?
11:44:16 <copumpkin> no, he joined after that
11:44:19 <lispy> ah
11:44:39 <monochrom> I suspect java/javascript question. "does anyone use the this pointer, ever?"
11:44:49 <lispy> Most people in my office use Haskell.
11:44:52 <explorator> :D
11:45:03 <copumpkin> most of the people I work with on a regular basis use it regularly
11:45:05 <lispy> I say most, because not everyone is a programmer
11:45:12 <ion> Most people in my apartment use Haskell.
11:45:21 <augur> wow. this is the first time ive ever experienced this.
11:45:34 <monochrom> welcome augur XD
11:45:35 <copumpkin> augur: knowledge?
11:45:40 <augur> XP
11:45:44 <lispy> this is it
11:45:45 <copumpkin> extreme programming?
11:45:54 <augur> i emailed a prof at u wyoming with a question since his work seemed vaguely relevant
11:46:19 <augur> and he responded with some pointers, about as useful i suppose as what i get from people here
11:46:36 <copumpkin> augur: man, that sucks
11:46:40 <copumpkin> :P
11:46:42 <augur> and in typical fashion i left it at that, figuring ok this guy doesnt want me to bug him any further, i'm sure hes got shit to do
11:46:43 <monochrom> are they the "this pointer"? XD
11:47:02 * copumpkin punches monochrom 
11:47:11 <c_wraith> copumpkin: you can reach china from there?
11:47:18 <copumpkin> he's not in china is he?
11:47:21 <augur> and he emails me again all miffed that i didnt respond
11:47:21 <lispy> this.professor.ask("Can I haz halp plz?");
11:47:29 <copumpkin> augur: aww!
11:47:41 <lispy> augur: oh.  Interesting.
11:47:48 <c_wraith> oh.  I guess he's said he's Chinese, but that's not the same as being in China.
11:48:01 <djahandarie> augur, well, at least you have a good reason to bug him now ;)
11:48:36 <djahandarie> augur, and why didn't you respond to the last thing _I_ said to you, huh?!?!
11:48:43 <McManiaC> is there a nice, convenient library built ontop of HTTP?
11:48:47 <augur> i mean, ok, yeah i couldve emailed with a thank you certainly, tho i always feel like noone gives a fuck about receiving just "thanks" in an email cause why bother, its not like it actually means anything (at least thats how i feel about them)
11:48:52 <augur> but honestly wow
11:48:53 <copumpkin> c_wraith: canada, last I looked
11:48:58 <augur> djahandarie: imma fuck you up son
11:49:01 <djahandarie> Haha
11:49:04 <Evious> Careful, last-word chains like that can explode out of control.
11:49:18 <Evious> Next thing you know you're engaged in 30 e-conversations and can't stop ANY of them.
11:49:21 <augur> he was all "this is why i generally dont reply to this shit" and its like ok guy
11:49:44 <lispy> McManiaC: doesn't the HTTP package have a 'simple' interface?
11:49:47 <augur> you're not knuth, i doubt you're constantly bombarded by questions from people
11:49:48 <djahandarie> Oh, was he actually angry? I thought was just asking what you thought
11:49:55 <augur> no man he was MIFFED
11:50:06 <augur> "No comment, at all? Rather disappointing and why I rarely spend my time on queries of this kind."
11:50:19 <lispy> McManiaC: simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
11:50:48 <McManiaC> lispy: hmmm, is it possible to use this with https?
11:51:16 <copumpkin> augur: apologize!
11:51:24 <dmwit> Yeah, seems easy to clear up.
11:51:31 <augur> oh i replied with a normal sort of email you know
11:51:32 <augur> but still
11:51:41 <dmwit> Just say you thought he wouldn't want to be bothered, but now that you know, you've got a deluge of follow-ups. =)
11:51:46 <lispy> McManiaC: I don't think so.
11:51:56 <gwern> McManiaC: I looked into this earlier; http does not support https
11:52:02 <lispy> McManiaC: If you need tls then you probably should use curl
11:52:12 <gwern> McManiaC: best https support seems to be via curl or wget; fortunately we have a decent libcurl binding
11:52:33 <lispy> McManiaC: http://hackage.haskell.org/package/curl  which has an "easy" module Network.Curl.Easy
11:52:41 <augur> i emailed lambek about a paper he wrote once and he offered to send me a /hardcopy/ of it
11:52:42 <augur> and he did
11:52:45 <augur> along with other stuff
11:52:46 <gwern> McManiaC: I cover https in http://www.gwern.net/haskell/Archiving%20GitHub.html if you're curious
11:52:55 <augur> and then like two weeks later he sent me even MORE stuff randomly
11:53:14 <gwern> augur: wow. so is lambek that awesome or just awesomely desperate for attention?
11:53:24 <augur> just that awesome
11:53:47 * gwern would feel burdened. 'now I have to read this and generate some deep insights to justify lambek's expectations and generosity!'
11:53:48 <monochrom> hahaha
11:54:01 <augur> lambeks got a lemma. he dont need no attention
11:54:36 <djahandarie> He's the third wheel though
11:54:45 <gwern> third?
11:55:07 * gwern thinks the third wheel is usually quite important
11:55:48 <yokto> hello can someone tell me why in this 4line examble (http://pastebin.com/fCbE9UeY) with rankNtypes run1 works but run2 not
11:56:12 <McManiaC> gwern: thx, will have a look
11:56:15 <augur> whats a third wheel
11:57:06 <gwern> maybe djahandarie meant 'fifth wheel'
11:57:46 <djahandarie> I think you guys are being a little too literal here :p
11:57:57 <copumpkin> yokto: because the parameter to foo needs to be (forall a. a -> a)
11:58:02 <copumpkin> :t return id 
11:58:03 <monochrom> yeah, just say "nth round thing"
11:58:03 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> a)
11:58:15 <copumpkin> yokto: you want that to be m (forall a. a -> a)
11:58:29 <copumpkin> which is tricky and requires impredicative types to even be possible
11:59:03 <opqdonut> hmm, ghc-core is showing (# Word64, Word64 #)
11:59:12 <opqdonut> those words could be unboxed too, right?
11:59:17 <copumpkin> depends on the context
11:59:31 <copumpkin> if you're just going to be boxing them a lot, GHC may have chosen not to unbox them
11:59:56 <opqdonut> I'd prefer them to scoot around unboxed
12:00:39 <yokto> ah ok your right - types can be so tricky sometimes :)
12:01:00 <opqdonut> ha!, an UNPACK solved that
12:02:00 <djahandarie> Main reason GHC doesn't have impredicative types is just because it makes stuff really hard to type check, right?
12:02:06 <djahandarie> Would it break inference?
12:02:24 <copumpkin> it does
12:02:29 <copumpkin> have impredicative types now, again
12:02:33 <copumpkin> and they can't be inferred
12:02:35 <djahandarie> Oh, we do?
12:02:54 <copumpkin> we never lost them
12:02:59 <copumpkin> they were just temporarily deprecated
12:03:09 <djahandarie> Ah, that's what it was
12:04:06 <yokto> by the way thanks
12:07:16 <copumpkin> np
12:10:42 * hackagebot sbv 0.9.17 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.17 (LeventErkok)
12:24:25 <thoughtpolice> whoa, http://darcs.haskell.org/cgi-bin/darcsweb.cgi?r=ghc;a=darcs_commitdiff;h=20110329170158-3fd76-46055b7fd503075a44a34d7187aa1f35c09be59e.gz
12:24:28 <thoughtpolice> -fvia-C is no more!
12:26:06 <olsner> ... a darcs commit :/ weren't they supposed to switch to git like a month ago?
12:26:51 <frerich_> Is a guy called 'sigfpe' here sometimes? I recently noticed that I really like his blog.
12:27:46 <mauke> preflex: seen dpiponi
12:27:47 <preflex>  dpiponi was last seen on #haskell 1 year, 18 days, 20 hours, 18 minutes and 49 seconds ago, saying: Talking of IDEs, It's be fun to have an interactive code building environment like the way Coq works. I believe someone is working on something like that.
12:28:18 <olsner> I wonder if that means sigfpe has been working on that for 1 year, 18 days :P
12:33:25 <jlouis> thoughtpolice: congratulations :)
12:42:56 <thoughtpolice> jlouis: that's what I was thinking, too!
12:43:38 <jlouis> it is one of those commits that screams *cleanup* because a lot of now dead code is removable
12:43:42 <thoughtpolice> olsner: the git switchover is happening this thursday
12:44:12 <jlouis> and the llvm backend is pretty interesting, even though I have yet to play with it :)
12:44:25 <thoughtpolice> olsner: they delayed it because they wanted a 7.0.3 release (primarily for fixes e.g. so GHC can work with xcode 4, which is what I needed,) but now that the release is done, they're completing the move
12:44:42 <thoughtpolice> sigh, i guess this means my not-yet-accepted GHC patches will have to be moved over to git
12:44:51 * thoughtpolice hopes darcs has an easy option to generate a unified diff
12:45:04 <jlouis> it shouldn't be too hard if you have the unified diffs
12:45:25 <thoughtpolice> oh no, it would be easy then. i just don't know off hand how to generate a unified diff with darcs from a darcs patch :)
12:45:39 <thoughtpolice> (although i'm almost certain it can do this, i've seen it before I think)
12:45:50 * thoughtpolice uses git for basically everything
12:46:00 <jlouis> me too
12:48:01 <kith> i wish there was a gui for git
12:48:39 <RogueShadow> kith: isn't there?
12:48:46 <kith> havent found one
12:48:48 <kith> for mac?
12:48:52 <RogueShadow> EGit on eclipse maybe?
12:49:46 <olsner> kith: git comes with a tk gui that works on at least (linux,mac,windows)
12:50:14 <thoughtpolice> killown: gitx
12:50:14 <olsner> some people don't like it, but I use it for all my git gui needs
12:50:23 <thoughtpolice> that's a nice git frontend for git on OS X, imo
12:50:39 <jlouis> I use gitk and magit-mode in Emacs
12:50:41 <thoughtpolice> in general I agree with olsner - gitk (the tk interface) is pretty usable and clear
12:50:49 <jlouis> the rest of the stuff I fire away on the command line
12:50:54 <thoughtpolice> gitx is just a nice, OSX alternative with a nice conforming UI and stuff
12:51:28 <thoughtpolice> kith: er, sorry, meant to say that to you. gitx - http://gitx.frim.nl
12:51:36 <jix> there is also gitg which is a gtk clone of gitx
12:51:51 <thoughtpolice> jlouis: is magit worth using? i've seen it mentioned a bunch but never bit the bullet on using it
12:51:59 <thoughtpolice> which is strange, because I basically only use git + emacs for development :)
12:52:06 <kith> thx
12:52:42 <olsner> thoughtpolice: I think someone (don't remember who, simon marlow maybe?) has an automatic tool for importing darcs patches into git and used it to put stuff in the existing ghc.git repo
12:53:49 <thoughtpolice> olsner: i think you're referring to darcs-fastconvert, yes?
12:54:31 <jlouis> thoughtpolice: I've bound it to F10 so I can easily ask it to show my the status of the repository. Then you can select hunks interactively and commit them. For more advanced things, I tend to skip it for the cmdline though
12:54:42 <jlouis> thoughtpolice: but for the small stuff, it is really helpfull
12:54:47 <jlouis> -l
12:54:59 <b0fh_ua> Hello! I have a function of type String -> IO (Result), when working with passed list of strings everything is pretty straighforward: mapM func list. However now I want to add Writer monad in order to write down the status of the execution of func. And at this point I am confused of how to do that - e.g what will be the type of func and how to execute it with list?
12:55:00 <olsner> could be, but fastconvert is a whole-repo conversion thing isn't it? I was under the impression the ghc.git repo was rather being updated incrementally
12:55:06 <thoughtpolice> ah, yeah, 'status' is probably the #1 thing that would be nice to save time on
12:55:15 <thoughtpolice> olsner: not sure, that's why i asked :P
12:55:41 <jlouis> thoughtpolice: you select a file, press 4 and then it expands it into hunks
12:56:04 <jlouis> thoughtpolice: at which point you can 's' to stage a hunk, 'u' to unstage etc...
12:56:17 <jlouis> I'll have to run, but you got the PR speech :)
12:57:26 <olsner> git gui also has interactive add/commit and status view btw
13:08:59 * hackagebot yackage 0.1.0 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.1.0 (MichaelSnoyman)
13:12:37 <luite_> is there some package that provides more gmp functions for Integer? I'm looking for mpz_perfect_square_p, which tests an integer for "perfectsquareness"
13:23:12 <Kaidelong> what kind of bindings does haskell have to MPI and OpenMP?
13:23:16 <Kaidelong> if any
13:24:51 <Kaidelong> ah found something for MPI
13:24:57 <Kaidelong> no luck with OpenMP so far though
13:26:05 * hackagebot case-insensitive 0.2.0.1 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-0.2.0.1 (BasVanDijk)
13:33:48 <rostayob> is anybody here using the mongoDB bindings?
13:34:46 <jystic> rostayob: jump on to #snapframework, there's quite a few of us using them
13:35:23 <rostayob> jystic: ok, thanks
13:35:50 <dmwit> Oh, cool, case-insensitive is a neat idea.
13:36:07 <dmwit> Is there any human-sort-order wrapper like the one given in there?
13:36:09 <pastorn> dmwit: for what?
13:36:37 <dmwit> pastorn: Human-sort-order is nice for things like file browsers.
13:37:09 <pastorn> oh, right
13:46:56 <Younder> Hi all
13:47:24 <dmwit> howdy
13:47:36 <Younder> Water is not essential to life. Methane will do to.
13:50:21 <Younder> I was ecstatic when I made this discovery..
13:50:32 <lispy> dmwit: I'm a little surprised one one has replied with insights about the alloca email, so I sent it and a patch to the libraries list.
13:50:47 <lispy> the patch updates the haddocks to say that alloca fails with exceptions
13:51:39 <Younder> I would like to say like Motzart da da da da da
13:51:59 <Younder> der zauberflute
13:52:26 <Younder> papagena
13:52:31 <dmwit> ?where ops
13:52:31 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
13:52:38 <digitteknohippie> does anyone know if himerge is dead?
13:52:43 <dmwit> lispy: Aw, it really ought not to be the docs that change. =P
13:53:00 <dmwit> lispy: Also, is it definitely an exception? It seems to be something much more... traumatic. At least here.
13:53:29 <lispy> dmwit: I disagree.  I think throwing an exception is the right thing to do given all the code in the wild that pretends like it can't receive a nullPtr
13:53:31 <glguy> dmwit: ?
13:53:44 <dmwit> glguy: "?"?
13:53:49 --- mode: ChanServ set +o jmcarthur
13:53:58 <mauke> /kick dmwit 
13:54:02 --- mode: ChanServ set +o glguy
13:54:06 <glguy> dmwit: ?
13:54:12 <dmwit> glguy: Oh, it was looking like Younder was sapmming nonsense.
13:54:19 <lispy> glguy: Younder is spamming
13:54:24 <jmcarthur> was he not?
13:54:36 --- mode: jmcarthur set +q *!*@224.13.202.84.customer.cdi.no
13:54:41 --- mode: jmcarthur set -o jmcarthur
13:54:50 <glguy> crisis averted
13:54:52 --- mode: glguy set -o glguy
13:54:58 <dmwit> Thanks. =)
13:55:02 <niteria> what does 'as' keyword do?
13:55:10 <niteria> I haven't seen it before
13:55:13 <jmcarthur> niteria: import Data.Set as Set
13:55:17 <dmwit> If you want to make me an op, I'll take care of it myself next time.
13:55:20 <jmcarthur> or    import qualified Data.Set as Set
13:55:21 <byorgey> funny, I seem to recall Younder productively discussing Haskell at some point in the past
13:55:28 <jmcarthur> byorgey: so do i
13:55:28 <niteria> tas = M.delete (i,j) as (p1, as1) = if i == len then (nil, tas) else check (i+1, j) tas
13:55:32 <niteria> like this
13:55:40 <dmwit> niteria: It is just a name.
13:55:49 <dmwit> niteria: The plural of 'a', probably, for a list of 'a's.
13:56:00 <niteria> oh
13:56:04 <niteria> silly me
13:56:15 <jmcarthur> ha
13:56:28 <niteria> some silly code formater highlighted it
13:57:18 <digitteknohippie> :.( himerge is dead it seems.
14:00:52 <lispy> dmwit: yeah, playing with ghci + ulimit, it certainly seems the exception aborts ghc
14:01:15 <lispy> dmwit: So, maybe it should be a catchable exception if it's going to be an exception
14:04:02 <dmwit> :O
14:04:44 <dmwit> sjanssen lives!
14:05:12 <mauke> preflex: seen sjanssen
14:05:12 <preflex>  sjanssen was last seen on #ghc 1 day, 6 hours, 31 minutes and 28 seconds ago, saying: we'll just want to be sure that we don't accept new output without checking it manually
14:05:50 <dmwit> Seen on gtk2hs-devel twenty minutes ago!
14:28:00 <McManiaC> is there a function to wait until a given time?
14:28:24 <mauke> threadDelay
14:29:22 <c_wraith> and getCurrentTime, and some combination of * and - and maybe div
14:29:30 <c_wraith> and >>=, of course
14:29:31 <monochrom> take note of threadDelay's unit
14:30:01 <McManiaC> hmm
14:30:07 <McManiaC> hoped for something prebuilt :P
14:30:08 <McManiaC> but ok
14:31:21 <monochrom> I write my own loop over threadDelay to sleep for xxx minutes.
14:31:36 <mauke> I have a sleep :: Double -> IO () somewhere
14:31:53 <mauke> (unit: seconds)
14:31:57 <c_wraith> Oh, right.  on a 32-bit system, threadDelay's max delay is like 34 minutes.
14:32:16 <monochrom> For "wait until 22:00 tonight", I sleep for a minute (or whatever resolution you like) then check getCurrentTime...
14:32:41 <dmwit> Seems like a package with a bunch of different such functions would be nice.
14:33:24 <monochrom> there is already a package for "sleep for xxx minutes". it's so small I didn't use it :)
14:34:33 <dmwit> Which package? Perhaps it could be extended with the variants that people want in other situations.
14:34:39 <McManiaC> and how do you add a DiffTime to UTCTime ? I knew there was a function but I dont find it :(
14:34:52 <McManiaC> the time package is so tiny
14:35:01 <monochrom> http://hackage.haskell.org/package/unbounded-delays
14:35:28 <dmwit> I thought you added NominalDiffTimes to UTCTimes, not DiffTimes to UTCTimes.
14:35:32 <hpc> @hoogle DiffTime -> UTCTime -> DiffTime
14:35:32 <lambdabot> Prelude const :: a -> b -> a
14:35:32 <lambdabot> Data.Function const :: a -> b -> a
14:35:32 <lambdabot> Prelude seq :: a -> b -> b
14:35:42 <hpc> @hoogle DiffTime
14:35:42 <lambdabot> Data.Time.Clock data DiffTime
14:35:43 <lambdabot> Data.Time.Clock data NominalDiffTime
14:35:43 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
14:35:48 <hpc> @hoogle NominalDiffTime
14:35:48 <lambdabot> Data.Time.Clock data NominalDiffTime
14:35:50 <dmwit> ?hoogle NominalDiffTime -> UTCTime -> UTCTime
14:35:50 <lambdabot> Data.Time.Clock addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime
14:35:50 <lambdabot> Prelude seq :: a -> b -> b
14:35:50 <lambdabot> Control.Parallel par :: a -> b -> b
14:35:55 <hpc> there you go
14:36:13 <McManiaC> NominalDiffTime /= DiffTime
14:36:16 <monochrom> use addUTCTime and obey its types at all costs
14:36:36 <monochrom> screw DiffTime if necessary
14:36:55 <dmwit> McManiaC: Converting between DiffTime and NominalDiffTime requires a leap-second table, I guess.
14:36:55 <hpc> haskell has a lot of time types :(
14:36:55 <McManiaC> ok
14:37:03 <monochrom> if buddha is on the roard, unsafeCoerce Buddha :: NominalDiffTime
14:51:03 <lispy> locale specific stuff needs polish in Haskell.
14:51:18 <lispy> For example, I couldn't find a currency parser or type the other day
14:51:30 <lispy> I guess few of us had needed that stuff
14:52:01 <dmwit> Yeah, I haven't seen a lot of talk of i18n in general.
15:02:09 <dmwit> From the wiki page for type families: "However, when associated types are explicitly listed as subitems of a class, we need some new syntax, as uppercase identifiers as subitems are usually data constructors, not type constructors."
15:02:33 <dmwit> Can data constructors be subitems of classes?
15:02:41 <dmwit> If so, how? If not, why do we need new syntax?
15:03:26 <geheimdienst> data Something = ... deriving (Show) ...?
15:03:34 <djahandarie> That's not in a class
15:03:35 <geheimdienst> Show is a class, right? i have no clue honestly ..
15:03:45 <djahandarie> It means in a typeclass definition
15:03:46 <dmwit> Yeah, but the subitems of the Show class are show and shows.
15:04:16 <c_wraith> and showList
15:04:22 <c_wraith> @src Show
15:04:22 <lambdabot> class  Show a  where
15:04:22 <lambdabot>     showsPrec :: Int -> a -> ShowS
15:04:22 <lambdabot>     show      :: a   -> String
15:04:22 <lambdabot>     showList  :: [a] -> ShowS
15:04:22 <geheimdienst> ok, "subitems" means the functions that make up the class? i read it as "things that instantiate the class" ...
15:04:40 <dmwit> Fine, whatever. Anyway, only functions, not constructors.
15:04:50 <geheimdienst> agreed
15:04:59 <dmwit> geheimdienst: Oh, yeah, this is talking about import and export lists, specifically.
15:05:04 <dmwit> That context is probably important here.
15:05:39 <monochrom> like import System.IO(IOMode(ReadMode)) ?
15:06:24 <monochrom> nevermind
15:06:24 <dmwit> Right, like that.
15:06:30 <dmwit> ReadMode is a subitem of IOMode.
15:06:46 <byorgey> data constructors can't be subitems of classes.  But maybe that point is that you can't tell *syntactically* whether  IOMode(ReadMode) refers to a type with a constructor or a class with an associated type
15:07:00 <byorgey> i.e. you'd like to be able to parse without doing name resolution.
15:07:08 <djahandarie> Yeah, that sounds right
15:07:13 <dmwit> O...kay.
15:07:21 <Eelis> is there a nice type class for functors F that have a canonical injection  inj :: a -> F a  such that   fmap f (inj x) = inj (f x)  ? (and nothing else, so it's not a Monad or Arrow or anything)
15:07:36 <dmwit> Okay.
15:07:37 <dmwit> Yes.
15:07:43 <hpc> Eelis: pointed, i think
15:07:46 <byorgey> Eelis: yes, Pointed
15:07:46 <hpc> @hoogle Pointed
15:07:46 <lambdabot> No results found
15:08:00 <byorgey> http://hackage.haskell.org/package/pointed
15:08:14 <geheimdienst> does this have anything to do with those data family things? http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/type-families.html
15:08:14 <Eelis> ah, splendid! thanks :)
15:08:21 <djahandarie> Ed's latest pointed doesn't involved Functors anymore
15:08:31 <dmwit> geheimdienst: Yep, it's exactly the feature I'm reading about now. =)
15:09:10 <lispy> What does it mean when data is pointed or co-pointed?
15:09:28 <byorgey> lispy: pointed means what Eelis just said.
15:09:29 <djahandarie> By itself? Not much
15:09:34 <hpc> lispy: pointed -> has pure/return/whatever
15:09:44 <hpc> copointed -> something else (join i think?)
15:09:44 <byorgey> lispy: for copointed, flip the direction of the arrow.
15:09:58 <hpc> or that
15:10:01 <byorgey> surely not join.
15:10:07 <djahandarie> point : a -> f a; copoint : f a -> a;
15:10:12 <lispy> hmm
15:10:15 <hpc> aha
15:10:33 <lispy> How does this relate to function points?
15:10:34 <monochrom> copoint is aka unsafePerformIO
15:10:35 <dmwit> Huh.
15:10:45 <djahandarie> lispy, it doesn't
15:10:47 <hpc> monochrom: lol
15:10:48 <dmwit> Now I'm trying to think of something that has a reasonable copoint (other than Identity).
15:10:59 <djahandarie> dmwit, any newtype
15:11:02 <Eelis> hm, i wonder why the pointed package depends on stm
15:11:08 <byorgey> djahandarie: uh, what?
15:11:13 <byorgey> dmwit: Stream
15:11:19 <hpc> streams have copoint=head
15:11:24 <djahandarie> byorgey, what?
15:11:25 <hpc> or ninja
15:11:42 <Eelis> oh, it's one of those cases where a package containing a type class tries to provide instances for anything that might conceivably be useful, resulting in dependency hell
15:11:44 <byorgey> djahandarie: newtype Foo = Foo Int,  how is that copointed?
15:11:56 <hpc> Writer has copoint = fst
15:12:00 <hpc> modulo newtypes
15:12:02 <djahandarie> byorgey, copoint (Foo x) = x ?
15:12:08 <hpc> for functions, copoint = fix?
15:12:09 <dmwit> ?unmtl Writer m a
15:12:09 <lambdabot> (a, m)
15:12:13 <byorgey> djahandarie: that has type  Foo -> Int
15:12:31 <dmwit> Cool.
15:12:33 <byorgey> djahandarie: of course it's kind of the same idea but not really the same thing
15:12:37 <hpc> no, fix isn't general enough
15:12:52 <lispy> Eelis: the alternative is orphaned instances
15:13:10 <Eelis> lispy: i never got what's wrong with those
15:13:15 <byorgey> hpc: (->) e  is not copointed in general
15:13:20 <dmwit> hpc: fix might work for Endo
15:13:29 <hpc> dmwit: that's it
15:13:33 <lispy> Eelis: basically the problem with them is that you cannot control instance imports
15:13:40 <djahandarie> byorgey, erm yeah, sorry, I mean for any newtype with the proper kind
15:13:42 <hpc> @src Endo
15:13:42 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:13:53 <djahandarie> Like Sum
15:14:03 <byorgey> newtype Endo a = Endo { appEndo :: a -> a }
15:14:04 <lispy> Eelis: so you end up importing two modules and suddenly you have conflicting instances for something
15:14:15 <hpc> appEndo sounds like a harry potter spell :P
15:14:27 <byorgey> hahaha
15:14:34 <Eelis> lispy: so.. if both alternatives suck, what's the way forward?
15:14:37 <byorgey> @remember hpc appEndo sounds like a harry potter spell
15:14:37 <lambdabot> Done.
15:14:51 <lispy> Eelis: I think the solution is a better module system.
15:15:14 <djahandarie> I guess even the kind restriction isn't enough
15:15:34 <Eelis> lispy: ok, i see
15:15:53 <hpc> any comonad is also a copointed
15:16:04 <lispy> Eelis: http://www.haskell.org/haskellwiki/Research_papers/Type_systems#Modules
15:16:34 <Eelis> lispy: that all looks old. has work on this stalled?
15:16:36 <lispy> At least one interesting paper is missing from that list
15:16:45 <lispy> I think it's incomplete
15:17:58 <lispy> Eelis: http://lambda-the-ultimate.org/node/1558
15:18:18 <lispy> I don't know if that will really address it, that one is targeted at type classes
15:18:34 <lispy> I saw a good paper on this...why can't I find it
15:18:40 <Eelis> shrug. i guess i'll just have to annoy my users with silly dependencies for the foreseeable future
15:18:41 <dmwit> Are classes and type constructors in the same namespace?
15:18:45 <djahandarie> @tell edwardk Why do you have a Copointed instance for Sum but not for Product?
15:18:45 <lambdabot> Consider it noted.
15:18:50 <dmwit> I guess I could test it pretty easily.
15:19:09 <hpc> djahandarie: wow, really? that's quite an omission
15:19:19 <dmwit> Yep, they are.
15:20:09 <byorgey> dmwit: there are only two namespaces, Type-things and Value-things
15:20:15 <djahandarie> hpc, :p
15:20:54 <lispy> Eelis: here it is.  I haven't read more than the abstract, but I think this would address the problem: http://www.mpi-sws.org/~dreyer/papers/mtc/main-long.pdf
15:21:16 <lispy> "In addition, programmers have explicit control over which type class instances are available for use by type inference in a given scope."
15:21:18 <Eelis> lispy: thanks
15:22:08 <lispy> oh right.  Now I recall why I didn't read that paper.  It's incomprehensible as soon as you get to the first figure.
15:23:15 <dmwit> Oh, come on, you can't internalize sixty new symbols in ten seconds?
15:28:54 <dmwit> Regarding http://www.haskell.org/haskellwiki/GHC/Type_families
15:29:12 <dmwit> Around the section containing "outside".
15:29:30 <dmwit> The page claims, "Even then ambiguity is possible.", but the example given doesn't follow the conditions above.
15:29:39 <dmwit> Is ambiguity really possible, or are those conditions enough?
15:30:24 <tieTYT> i'm not sure if I'm ready to understand the answer to this quesiton, but why do symbols like + not need back ticks around them to be used in infix notation?
15:30:47 <dmwit> There's no real deep reason.
15:30:54 <dmwit> The parser has a special case for all-symbol identifiers.
15:30:57 <dmwit> They're infix.
15:31:05 <dmwit> Non-symbol identifiers are prefix.
15:31:13 <lispy> > 1 `+` 2 -- in fact, they don't work with backticks
15:31:14 <lambdabot>   <no location info>: parse error on input `+'
15:31:16 <tieTYT> ok, I'll take that as gospel :)
15:31:27 <mauke> pretty simple, really
15:31:32 <mauke> operators don't look like words
15:31:33 <dmwit> Symbol identifiers can be converted to prefix with parens, and non-symbol identifiers can be converted to infx with backticks.
15:33:37 <byorgey> dmwit: I think those conditions are enough, although I'm not 100% sure.  I agree that example does not follow the conditions.
15:34:03 <dmwit> Okay. I think I'm going to edit away the example.
15:35:32 <ddarius> `(`foo`)`
15:36:18 <geheimdienst> > succ `(`map`)` [1,2]
15:36:18 <lambdabot>   <no location info>: parse error on input `('
15:36:33 <hpc> > (fmap) succ (Just 4)
15:36:34 <lambdabot>   Just 5
15:36:59 <dmwit> > (.) succ (Just 4)
15:37:01 <lambdabot>   Just 5
15:37:20 <mauke> > 4 . Just
15:37:21 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
15:37:21 <lambdabot>    arising from a use of `...
15:37:30 <geheimdienst> > 1 `(+)` 2
15:37:31 <lambdabot>   <no location info>: parse error on input `('
15:37:34 <mauke> > (4 . Just) succ
15:37:34 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:37:35 <lambdabot>    `GHC.Enum.Enum a'
15:37:35 <lambdabot>      ar...
15:37:44 <mauke> oh you
15:39:43 <n00b_> what does $ do in haskell?
15:39:48 <dmwit> ?src ($)
15:39:48 <lambdabot> f $ x = f x
15:40:05 <dmwit> Practically speaking, it reduces the number of parentheses necessary.
15:40:05 <monochrom> blah $ stuff = (blah) (stuff)
15:40:15 <sipa> n00b_: a (b (c (d e))) = a $ b $ c $ d e
15:40:22 <n00b_> wierd...thanks
15:40:29 * djahandarie likes monochrom's version
15:40:37 <monochrom> example: p x $ q y = (p x) (q y)
15:40:44 <geheimdienst> basically, you can replace the "(" with "$" and then you can leave off the ")"
15:41:01 <aristid> note that p x $ q y is NOT the same as (p x) q y
15:41:12 <dmwit> Someday in the future, ($) will be infixl.
15:41:36 <aristid> dmwit: so you could write p x $ q $ y?
15:41:38 <geheimdienst> you could think of $ as "parens from here to the end of line"
15:42:10 <dmwit> aristid: That would not be very useful.
15:42:10 <n00b_> under that definition wouldn't p x $ q $ y = px (q) (y)? how does it paren the expression before it
15:42:19 <dmwit> aristid: But here's one that would: p x $ q y $ z
15:42:38 <aristid> which now is (p x $ q y) z
15:42:42 <dmwit> right
15:42:55 <n00b_> w t f?
15:42:57 <dmwit> noob_: No, because ($) is infixr.
15:43:07 <dmwit> n00b_: That was meant for you, not noob_.
15:43:08 <n00b_> infixr?
15:43:13 <dmwit> Yes, it associates to the right.
15:43:42 <dmwit> So "p x $ q $ y" associates as "p x $ (q $ y)", not as "(p x $ q) $ y".
15:44:29 <n00b_> wow its bad that im really confused
15:44:41 <azaq231> noob_: normal function application parsed as this: f g x y = (((f g) x) y), now $ makes it parse like this: f $ g $ x $ y = (f (g (x y))). That is the point of $. so you can do "return $ Just 10" instead of return (Just 10). return Just 10 parsed as ((return Just) 10), which is wrong.
15:44:42 <byorgey> $ is just function application. end of story.
15:44:42 <n00b_> i've only programmed in java, web based languages and scheme
15:45:01 <byorgey> with a very low precedence.
15:45:09 <byorgey> I guess it wasn't the end of the story.
15:45:17 <geheimdienst> :)
15:45:19 * byorgey thinks trying to explain $ in terms of parentheses is a bad idea.
15:45:28 <aristid> byorgey: it also associates to the right. which is relevant.
15:45:29 <ddarius> id < ($)
15:45:36 <byorgey> aristid: that's true
15:48:32 <n00b_> so are you telling me what it does or how it does it? because i just want to know what it does
15:48:49 <aristid> n00b_: f $ x = f x
15:48:55 <aristid> that's the definition.
15:49:12 <aristid> well, that and
15:49:17 <aristid> infixr 1 $
15:49:22 <djahandarie> n00b_, all it does is move around the parentheses
15:49:44 <aristid> djahandarie: byorgey says explaining it with parentheses is evil! therefore, you are evil
15:49:57 <djahandarie> Maybe.
15:51:09 <byorgey> n00b_: perhaps some examples will help?
15:51:12 <byorgey> > succ 3
15:51:12 <lambdabot>   4
15:51:17 <byorgey> > succ $ 3
15:51:17 <lambdabot>   4
15:51:24 <byorgey> > succ (1 + 2)
15:51:25 <lambdabot>   4
15:51:31 <byorgey> > succ $ 1 + 2
15:51:31 <lambdabot>   4
15:51:40 <aristid> byorgey: the evil parentheses strike again.
15:51:44 <ddarius> byorgey: That was a bad choice of example.
15:51:52 <byorgey> ddarius: I just realized that.
15:51:52 <djahandarie> The fact that succ 1 + 2 will result in the same thing probably isn't good
15:51:55 <djahandarie> Haha
15:51:58 <byorgey> hehe
15:52:13 <hpc> WE MUST FIX ARITHMETIC!
15:52:27 <byorgey> > fix succ
15:52:27 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
15:52:29 <djahandarie> > fix succ
15:52:30 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
15:52:30 <djahandarie> Damn
15:52:46 <digitteknohippie> mmm, why didnt i do this sooner. http://mycroft.mozdev.org/search-engines.html?name=haskell
15:52:55 <aristid> does lambdabot have loop detection?
15:53:00 <benmachine> nope
15:53:06 <aristid> oh
15:53:06 <dmwit> > let loop = loop in loop
15:53:10 <lambdabot>   mueval-core: Time limit exceeded
15:53:12 <aristid> > succ undefined :: ()
15:53:13 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
15:53:27 <dmwit> benmachine: Yes, but not the kind you meant. =)
15:53:28 <n00b_> you guys are breaking math aren't you?
15:53:40 <aristid> n00b_: no we're fixing it :P
15:53:43 <benmachine> dmwit: mm?
15:53:48 <aristid> > fix math
15:53:49 <lambdabot>   Not in scope: `math'
15:53:52 <dmwit> n00b_: We had to invent all new kinds of math to figure out what we were doing. ;-)
15:54:09 <dmwit> benmachine: It has loop detection, but not GHC's black-hole detection.
15:54:15 <dmwit> benmachine: It detects loops via timeout. =)
15:54:19 <djahandarie> These st- things scare me
15:54:45 <djahandarie> I guess io-16793 would be scarier
15:54:55 <benmachine> dmwit: well, that's not exactly *loop* detection
15:55:01 <benmachine> but sure ok :P
15:55:04 <n00b_> f (x) = f $ x?
15:55:13 <dmwit> n00b_: Yes.
15:55:22 <dmwit> n00b_: And, since it's an equality, f $ x = f (x).
15:55:32 <dmwit> n00b_: (Which is, incidentally, also the very first answer you got. =)
15:55:47 <djahandarie> And since those parentheses are useless, f $ x = f x
15:55:52 <n00b_> f $ x $ y = f (x $ y) but not f (x (y))?
15:56:11 <dmwit> n00b_: Yes to the first, but also yes to the second.
15:56:15 <djahandarie> Unless you're treating "x" as a syntactic variable rather than an actual name
15:56:18 <aristid> let's have fun with parentheses: ((f) $ (x)) = ((f) (x))
15:56:20 <dmwit> f $ x $ y = f (x $ y) = f (x (y))
15:56:36 * hackagebot Biobase 0.3.1.0 - Base library for bioinformatics  http://hackage.haskell.org/package/Biobase-0.3.1.0 (ChristianHoener)
15:56:38 <Philonous> @type let unfix :: a -> a -> a; unfix = return in unfix . fix 
15:56:38 <lambdabot> forall a. (a -> a) -> a -> a
15:56:52 <dmwit> ...and f (x (y)) = f (x y), as folks are kindly pointing out.
15:57:46 <dmwit> Philonous: That's a strange name for const.
15:57:55 <aristid> hmm would be cool if we had an haskell AST pretty-printer
15:58:05 <niteria> (18.12 secs, 5274829612 bytes)
15:58:07 <Philonous> > let unfix :: a -> a -> a; unfix = return in (fix . unfix) 3
15:58:08 <lambdabot>   3
15:58:11 <dmwit> aristid: We surely do. Ever gotten an error message from GHC?
15:58:18 <niteria> i think ghci is lying
15:58:24 <aristid> dmwit: i mean for valid expressions :)
15:58:34 <ddarius> > fix 3
15:58:35 <byorgey> niteria: why?
15:58:35 <lambdabot>   3
15:58:45 <Philonous> > let unfix :: a -> a -> a; unfix = return in (fix . unfix) 'a'
15:58:46 <dmwit> aristid: It works for valid expressions. What are you talking about?
15:58:46 <lambdabot>   'a'
15:58:58 <aristid> dmwit: huh? then i don't know what you mean
15:58:59 <Philonous> > fix 'a'
15:58:59 <lambdabot>   Couldn't match expected type `a -> a'
15:58:59 <lambdabot>         against inferred type `GHC.Ty...
15:59:02 <niteria> 5274829612 ~= 5gb, no?
15:59:08 <n00b_> 1 $ 2 $ 3 $ 4 = 1 (2 (3 (4))) = 1 (2 (3 4))
15:59:17 <byorgey> niteria: note, that's the total allocation, it doesn't mean it was all in use at the same time.
15:59:21 <dmwit> niteria: Yep, functional languages typically allocate (and de-allocate) a lot.
15:59:28 <aristid> n00b_: except numbers are not typically functions
15:59:32 <dmwit> aristid: Okay, let me whip up something to show you.
15:59:34 <byorgey> niteria: lots of it got garbage collected, and more got allocated, etc. along the way
15:59:39 <Philonous> dmwit: Strange name, but it does what it advertises. Kind of.
15:59:43 <aristid> n00b_: in lambdabot numbers are functions, but that's another story
15:59:46 <niteria> oh, I see
16:00:01 <n00b_> k thanks
16:00:05 <niteria> isn't it reusing somehow?
16:00:21 <monochrom> yes
16:00:29 <nazgjunk> Hey.  What'd be a good Haskell introduction and/or book for a long-time amateur with most recent experience in python (me)?  I realize this question is a terrible one, but I'm seeing a lot of options and I'd rather not buy more than one book to start with ;)
16:00:36 <niteria> 5gb of allocations should take > 20sec I guess
16:00:42 <aristid> nazgjunk: learn you a haskell?
16:00:56 <Philonous> @where lyah
16:00:56 <lambdabot> http://www.learnyouahaskell.com/
16:01:00 <byorgey> niteria: not really.
16:01:05 <Philonous> @where rwh
16:01:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:01:31 <dmwit> aristid: Check out the last two lines of the error message for this: http://hpaste.org/45154/prettyprinter
16:01:35 <Philonous> nazgjunk: You can read both online, free of charge
16:01:43 <monochrom> tryhaskell.org is interactive introduction
16:01:46 <dmwit> aristid: You'll notice it's not an exact match: it's been parsed and pretty-printed.
16:01:47 <geheimdienst> "real world haskell" is more sophisticated ... i would definitely start with "learn you a haskell"
16:02:08 <nazgjunk> Much appreciated!  
16:02:23 <dmwit> aristid: Try mucking about with whitespace, for example, and you'll see what I mean even more clearly.
16:03:02 <n00b_> so what are your qualifications guys?
16:03:19 <monochrom> supreme commander
16:03:46 <lispy> n00b_: haskellers.com has many of us listed with our interests and specialties within haskell
16:04:12 <maurer_> Grand Poobah
16:04:30 <n00b_> well if im a CS sophomore at a 4 yr university Is it bad i don't know shit about this?
16:04:41 <n00b_> or most other languages
16:04:45 <monochrom> yes
16:04:59 <dmwit> Oh, come on.
16:05:07 <dmwit> I would say he's above average if he's heard of Haskell.
16:05:13 <geheimdienst> monochrom: stop that
16:05:19 <monochrom> I don't mean the haskell part.
16:05:24 <n00b_> lol idc i want an honest answer
16:05:51 <dmwit> Although, hm... I guess it was my sophomore year that I heard about Haskell.
16:05:52 <maurer_> n00b_: Read things; make things. Don't worry about where you are, just go forward and you'll get where you need to be.
16:06:01 <dmwit> So maybe I have no idea whether it's above average.
16:06:06 <lispy> I heard about haskell in undergrad, but one of the better known profs at my school has a haskell background
16:06:19 <niteria> hmm, why is sum [1..1000000] faster than let sm a acc = if a == 0 then acc else sm (a-1) (acc+a); s 1000000 0 ?
16:06:30 <niteria> it's against my intuition
16:06:56 <maurer_> popsi: What the hell?
16:07:08 <lispy> ?src sum
16:07:09 <lambdabot> sum = foldl (+) 0
16:07:43 <lispy> niteria: fewer operations?
16:07:44 <niteria> (2.50 secs, 163495036 bytes) vs (1.68 secs, 155851724 bytes)
16:08:00 <lispy> oh, that's not enough data to say that one is definitely faster
16:08:13 <n00b_> is UWEC  a good school for CS?
16:08:19 <lispy> (although, it wouldn't surprise me if one is faster)
16:08:21 <Philonous> Does ghc even support proper tail calls?
16:08:28 <n00b_> also my ss# is and my mom's maiden name is lol
16:08:39 <lispy> Philonous: of course, but the question is: how useful are they in haskell
16:09:06 <int80_h> http://hpaste.org/45155/testing_my_assumptions
16:09:20 * lispy buggers off to get work done
16:09:25 <Philonous> lispy: In the strict case?
16:09:46 <niteria> oh
16:09:52 <n00b_> what counts as "mutation" in haskell? 
16:10:03 <niteria> my function isn't strict
16:10:09 <dmwit> int80_h: No, there's several reasons it can't have that type.
16:10:21 <int80_h> dmwit: crap
16:10:32 <dmwit> int80_h: First of all, jsonMap returns a Json, not a [jsonMap].
16:10:43 <eyelash> maurer_: ;)
16:10:54 <dmwit> int80_h: Second of all, jsonScalar is being provided with an IO action in that code, which it certainly can't handle.
16:11:11 <byorgey> n00b_: nothing.  Haskell has no mutation.
16:11:15 <n00b_> hey hey hey  hey hey
16:11:16 <n00b_> okay
16:11:19 <n00b_> thanks
16:11:30 <benmachine> byorgey: not even ST/IO?
16:11:35 <n00b_> my prof said i had to write this in haskell, and not use mutation lol
16:11:35 <int80_h> dmwit: well that is the part I need to fix. But I have to know what the type of json is first
16:11:41 <byorgey> benmachine: no. those do not exist. ;)
16:11:44 <n00b_> so i was like...uh where mutation?
16:11:48 <benmachine> byorgey: noted
16:12:03 <dmwit> benmachine: No, even IO actions are just descriptions of sequences of mutations, not actual mutation.
16:12:30 <dmwit> int80_h: Ill-typed code doesn't have a type.
16:12:40 <dmwit> That's what a type error means.
16:12:42 <niteria> can I make let sm a acc = if a == 0 then acc else sm (a-1) (acc+a); s 1000000 0 strict?
16:12:55 <dmwit> niteria: Sure.
16:12:57 <niteria> or is it already?
16:13:08 <benmachine> dmwit: have you seen the article about how C is a purely functional programming language?
16:13:35 <niteria> dmwit: how?
16:14:07 <int80_h> http://hpaste.org/paste/45155/testing_my_assumptions_annota#p45157
16:14:12 <int80_h> dmwit: fixed
16:14:19 <dmwit> niteria: Something like "sm a acc = if a == 0 then acc else let a' = a - 1; acc' = acc + a in a' `seq` acc' `seq` sm a' acc'", I guess.
16:14:45 <dmwit> int80_h: json :: Page -> Json, I would guess. But why not just ask ghci?
16:15:10 <Philonous> niteria: adding a bang (!) to a parameter makes it strict (f !strictparam nonstrict = something), and you can force evaluation of something by using seq like in "evaluate_first `seq` result", 
16:15:16 <int80_h> dmwit: I think there's a scope problem. But I thought I could figure out this type by myself anyway
16:15:23 <dmwit> niteria: Note that I would probably write that "if" as "sm 0 acc = acc; sm a acc = sm (a-1) (acc+a)".
16:15:46 <niteria> that's just for playing with ghci
16:15:56 <dmwit> You can use that in ghci, too.
16:16:09 <dmwit> > let sm 0 acc = acc; sm a acc = sm (a-1) (acc+a) in sm 10 0
16:16:10 <lambdabot>   55
16:17:36 <niteria> oh, I see
16:17:41 <niteria> that's cool
16:18:12 <mm_freak> benmachine: well, if you set "purely function" = "referentially transparent", then all haskell except unsafe* is pure, including IO and ST
16:18:13 <int80_h> @hoogle Json
16:18:14 <lambdabot> No results found
16:18:18 <int80_h> crap
16:18:23 <dmwit> ?hackage yesod
16:18:23 <lambdabot> http://hackage.haskell.org/package/yesod
16:18:31 <dmwit> Docs are there, under Yesod.Json.
16:18:48 <mm_freak> s/function/functional/
16:19:23 <int80_h> dmwit: I loaded the Yesod module into ghci. It can tell me the type of jsonMap, but it claims Json is out of scope
16:19:43 <int80_h> even though it described jsonMap in terms of Json
16:20:08 <dmwit> Load Yesod.Json, then?
16:20:10 <mm_freak> int80_h: that doesn't mean Json is in scope‚Ä¶  refer to the haddock docs to find it
16:20:21 <niteria> ok, strict version is faster than sum [1..1000000], thank god
16:20:46 <dmwit> niteria: Is the strict version faster than using the strict version of sum?
16:20:49 <dmwit> sum' = foldl' (+) 0
16:21:21 <Rotaerk> I'm disappointed in the presence of unsafe* in haskell
16:21:23 <Rotaerk> tisk tisk
16:21:27 <int80_h> http://hackage.haskell.org/package/yesod
16:21:41 <niteria> dmwit: no
16:21:52 <mm_freak> Rotaerk: why?  you can use them for efficiency
16:21:55 <niteria> dmwit: strict sum is faster
16:22:04 <lispy> Rotaerk: replace "unsafe" with "burden of proof is on the programmer".
16:22:06 <mm_freak> (if you know, what you're doing, of course)
16:22:09 <dmwit> niteria: Great. =)
16:22:16 <niteria> way faster
16:22:26 <Rotaerk> mm_freak, you can also use them to bypass the ubiquitous purity and cause side effects
16:22:30 <lispy> It's kind of nice that in Haskell, lots of burden of proof stuff is "grepable"
16:22:31 <Philonous> Rotaerk: unsafe* ist not haskell (as defined per the standard)
16:22:37 <Rotaerk> ah
16:22:42 * hackagebot MC-Fold-DP 0.1.0.0 - Folding algorithm based on nucleotide cyclic motifs.  http://hackage.haskell.org/package/MC-Fold-DP-0.1.0.0 (ChristianHoener)
16:23:05 <mm_freak> Rotaerk: sure, just like in C you can dereference a null pointer‚Ä¶  both wrong things to do
16:23:33 <Rotaerk> mm_freak, one of the charms of haskell is its purity; unsafe* kind of makes it pointless
16:23:36 <Maggi> Hello, which channel should I join to discuss STM (general; concepts, no specific implementations)?
16:23:45 <mm_freak> Rotaerk: you risk bugs in your code, because the semantics become unintelligible to humans, and nobody is going to use your library anyway
16:24:24 <mm_freak> Rotaerk: as said, without unsafe* and FFI a lot of efficient data structure implementations would be impossible
16:24:28 <mm_freak> not difficult, but impossible
16:24:54 <dobblego> Rotaerk: haskell sets out to be practical, at the expense of dogma
16:25:04 <mm_freak> Rotaerk: if you deny unsafe*, you need to deny FFI for exactly the same reason
16:25:09 <dobblego> unsafe* is essential to this goal
16:25:42 <niteria> @src foldl'
16:25:42 <lambdabot> foldl' f a []     = a
16:25:42 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:26:02 <hpc> unsafe* is also very very rarely used in code most people will see
16:26:28 <mm_freak> Rotaerk: and you need a filesystem, which disallows users to edit haskell-generated object files =)
16:27:40 <benmachine> Philonous: I think unsafePerformIO is effectively possible via the FFI which is now standard
16:28:27 <Rotaerk> you can allow for performance optimizations without allowing for backdoors into impurity in the pure code
16:29:11 <Philonous> benmachine: Oh right. What a shame. This gem of purity and sanity. Forever spoiled.
16:29:17 <mm_freak> Rotaerk: you may try to write such a compiler
16:30:32 <mm_freak> then we would have to wait another 20 years, before haskell is even barely usable for practical applications
16:30:42 <Maggi> can anybody point me in the right direction?
16:31:05 <sipa> Maggi: just ask a question
16:31:07 <mm_freak> Maggi: you can do that here, if you want
16:31:11 <hpc> Maggi: -->
16:31:12 <hpc> :P
16:31:18 <mm_freak> i don't think there is any STM-specific channel
16:31:47 <warzl> what does ' mean in haskell?
16:31:49 <mm_freak> there may be CS channels, where you can discuss STM, but i
16:32:01 <hpc> warzl: it's just another character you can put into names
16:32:01 <mm_freak> 'm sure that haskellers are interested in STM, too (at least me) =)
16:32:06 <monochrom> ' means part of a name in haskell. example: fork'spoon
16:32:13 <hpc> > let conanO'Brien = "hilarious" in conanO'Brien
16:32:13 <lambdabot>   "hilarious"
16:32:46 <hpc> warzl: it has a convention of being used for helper stuff, or for strict versions of other functions
16:32:50 <warzl> ah thanks
16:32:52 <Philonous> Rotaerk: The _real_ scandal is that we allow bottom to sully our little paradise. We need to get out of the Turing tar pit, I want provable termination. 
16:33:06 <mm_freak> warzl: if the first character in a token is ', then it's a character literal
16:33:08 <mm_freak> > 'x'
16:33:09 <lambdabot>   'x'
16:33:21 <hpc> > let x = "some simple value"; x' = const "processing the value" x in x'
16:33:22 <lambdabot>   "processing the value"
16:33:23 <Maggi> alright, thanks, will ask here then. thought that there might be a channel about distributed programming or similar
16:33:25 <monochrom> yeah, get out of Turing tarpit, provable termination, only to get into G√∂del tarpit
16:33:30 <mm_freak> i use x' to mean "current" and x to mean "next"
16:33:40 <warzl> ah ok
16:34:04 <mm_freak> Maggi: STM is not exactly about distributed programming, and in fact i wouldn't use it there
16:34:16 <hpc> @remember monochrom yeah, get out of Turing tarpit, provable termination, only to get into G√∂del tarpit
16:34:16 <lambdabot> I will never forget.
16:36:29 <Maggi> mm_freak: it's about concurrency, distributed systems "may" be concurrent
16:37:07 <mm_freak> yes, i would use STM in concurrency
16:37:09 <Maggi> I guessed it was related in that sense
16:40:27 <Maggi> anyway, STM is an alternative to lock-based synchronization, however, there seem to be lock-based STM implementations, is that correct? Is it even possible to implement STM without locks?
16:41:32 <bd_> Maggi: There are some proposed hardware-based implementations that avoid actually locking (however, then you have hardware limits on how many variables you can touch in a transaction)
16:41:45 <bd_> The main goal of software STM is to avoid _explicit_ locking
16:44:33 <niteria> is there a nub that works on sorted lists?
16:44:37 <niteria> I mean, faster
16:44:43 <Maggi> the log that is written to and used to verify if other processed made changes to data, how's that possible without locking (or rather the writting part)? Or have I missed something?
16:45:42 <mrd> > map head . group . sort $ [6,4,4,6,8,2]
16:45:44 <lambdabot>   [2,4,6,8]
16:46:59 <mm_freak> Maggi: as bd_ said, the goal of STM is not to be lock-free, but the user does not have to use locking
16:47:07 <niteria> mrd: that's what I came up with
16:47:10 <mm_freak> it's a lock-free /abstraction/, not a lock-free implementation
16:48:08 <niteria> mrd: there's also Data.Set.elems $ Data.Set.fromList [6,4,4,6,8,2]
16:48:16 <niteria> > Data.Set.elems $ Data.Set.fromList [6,4,4,6,8,2]
16:48:16 <lambdabot>   Not in scope: `Data.Set.elems'Not in scope: `Data.Set.fromList'
16:48:22 <Maggi> mm_freak, bd_: thought so, thanks for claryfing
16:48:24 <monochrom> st-17178: how are you?
16:48:34 <niteria> > S.elems $ S.fromList [6,4,4,6,8,2]
16:48:34 <lambdabot>   [2,4,6,8]
16:49:59 <dmwit> niteria: Do you actually mean sorted lists, or just lists with order-able elements?
16:50:15 <dmwit> niteria: If you mean sorted lists, then "map head . group" is linear time.
16:50:59 <Maggi> another question, how does STM handle asynchronous code execution i.e., making an ARPC within an atomic block?
16:51:20 <dmwit> ARPC sounds like IO, which can't be done in STM.
16:51:25 <dmwit> Only memory accesses are allowed.
16:51:52 <dmwit> However, you are allowed to *return* an IO action.
16:52:08 <dmwit> So, if you like, your atomic block can compute an ARPC to run, and run it after the computation commits.
16:52:17 <niteria> dmwit: I meant sorted, but I did sorting step to make it faster
16:53:52 <monochrom> st-17217: how are you?
16:54:10 * dmwit applauds monochrom's persistence
16:55:11 <mm_freak> dmwit: although that doesn't change much‚Ä¶  you can just as well return a value and react upon that
16:55:45 <dmwit> Yep.
16:56:35 <dmwit> All I'm saying is: no sense making up a new type for describing actions when IO is a perfectly good existing type with a nice interface.
16:57:05 <BMeph> Is there a 'parsec' channel? :)
16:57:13 <dmwit> Just ask here, I guess.
16:57:20 <Maggi> would STM be suitable for mutual exclusion?
16:57:47 <dmwit> Maggi: Yes, though you have to be a bit careful to avoid livelock.
16:58:12 <Maggi> dmwit: got a basic example?
16:59:03 <dmwit> I guess the style is you just let both threads do whatever it was they were going to do in a mutually exclusive way, but in an atomically block.
16:59:47 <BMeph> Cool. So, I have a trinary data type, and I want to parse a sequence of them into a list. Two of the three values signal the end of the list, but the third can optionally allow more in the list. Is there a fancier solution than the "obivous" way?
16:59:54 <monochrom> in ghc-haskell: join (atomically ( (readTChan x >> return (putStrLn "hi")) `orElse` (readTChan y >> return (exitSuccess)) ))
16:59:57 <kevinburke> Hey, I'm looking for a summer of code in haskell, any ideas?
17:00:16 <dmwit> BMeph: Yep, there's a combinator for lists of things.
17:00:42 <hpc> kevinburke: there was a link to trac earlier today but it left my scrollback
17:00:45 <monochrom> look for sepEndBy and sepEndBy1
17:00:53 <dmwit> BMeph: See sepEndBy and friends.
17:00:55 <dmwit> Ah, beaten.
17:01:11 <monochrom> but this one may be trickier
17:01:24 <hpc> http://hackage.haskell.org/trac/summer-of-code/report/1 <- kevinburke
17:01:27 <dmwit> Nah, the "end" parser can just parse either of the two ending indicators.
17:01:55 <Maggi> dmwit, monochrom: cheers
17:02:24 <hpc> i think the mathematical environment idea would be a fun one
17:03:16 <monochrom> one little, two little, three little dcoutts...
17:03:16 <Maggi> last question ;p, recommend any papers on STM (general; doesn't have to be "haskell-centric")?
17:04:02 <mm_freak> as a slightly OT question, which language is more mature targetting the JVM?  scala or clojure?
17:04:10 <monochrom> I don't know of the general one. I only know of the haskell-specific one, but it will cite the general one.
17:05:40 <Maggi> monochrom: haskell-specific ones are fine too, I'm not a haskell-guru but I doubt I'd have to be one for STM (I hope ;p)
17:06:04 <BMeph> dmwit, monochrom: Thanks to you both, I'll check on it.
17:06:09 <monochrom> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/index.htm
17:07:17 <monochrom> I think the "composable memory transactions" one is most suitable
17:09:34 <mm_freak> Maggi: as for everything you should understand haskell's type system
17:09:37 <Maggi> monochrom: thanks, will read that/those, might be back this week
17:10:12 <mm_freak> and you should know how to express monadic computations‚Ä¶  that should be sufficient to experiment with STM in haskell
17:10:59 <Maggi> I should be fine then :)
17:11:54 <acowley> If anyone has a chance, I followed through on a promise and posted a port of an OpenGL tutorial: http://www.arcadianvisions.com/blog/?p=224
17:12:03 <acowley> Let me know if there's anything missing/wrong etc.
17:14:18 <shapr> I wonder if Maggi is related to Moggi?
17:14:43 <hpc> shapr: maybbi?
17:14:46 <acowley> I tried reading Moggi when first learning Haskell. It didn't help.
17:14:47 <shapr> argh
17:14:51 <monochrom> haha
17:15:28 <ddarius> "Notions of Computation" is a pretty good paper.
17:15:31 <ddarius> shapr: How's life?
17:15:44 <shapr> ddarius: Certainly not boring
17:16:02 <shapr> But insufficiently haskell-oriented to discuss here :-)
17:16:26 <BMeph> monochrom: Since you noticed it "may be trickier," I'll field this to you.
17:16:49 <acowley> shapr: Just use terms that sound Haskelly, and you can talk about anything here
17:17:40 <BMeph>  1) I'm already using lexemes, so the parsed items are "separated" by whitespace, which gets eaten. 2) The "enders" of the sequence are ending members of the sequence (i.e., they should be included in the sequence).
17:18:47 <monochrom> eww
17:18:51 <BMeph> shapr: If you aren't going to talk about Haskell, will you at least include a unicycle anecdote? ;)
17:19:32 <shapr> BMeph: Sure... I bought a 24" unicycle for my girlfriend recently so we can unicycle together :-)
17:19:55 <BMeph> shapr: That's...disturbing.
17:20:01 <acowley> two unicycles sounds suspiciously like a more pedestrian vehicle
17:20:05 <ddarius> BMeph: ?
17:20:29 <BMeph> shapr: Not your part, I mean my reaction; I find it endearing, and a little arousing. 
17:20:31 <ddarius> Isn't "pedestrian vehicle" self-contradictory?
17:20:34 <tomberek> ddarius: are you familiar with the knot-tying loeb?
17:20:37 <dobblego> have any of you met people who are convinced that they have "solved" the expression problem?
17:20:40 <shapr> ok, that is .... probably TMI
17:20:50 <acowley> ddarius: I try :)
17:20:57 <ddarius> tomberek: More or less.
17:21:31 <BMeph> shapr: Eh, not that arousing, just made me think of my wife, that's all. ;)
17:21:31 <ddarius> shapr: I think I'm going to forcibly buy Mo an ukulele.
17:21:35 <XXX-man> can i interpret regular expression as tree?
17:21:44 <shapr> Speaking of on-topic-ness, has there been any recent activity with copilot or atom? I want to generate Arduino code from Haskell.
17:21:53 <shapr> ddarius: Oh that's awesome :-) Does Mo write Haskell?
17:22:39 * geheimdienst wonders if shapr unicycling with his girlfriend wouldn't constitute biunicycling, or bicycling for short ...
17:22:40 <ddarius> shapr: Not yet, but I finally got him and copumpkin to meet this past weekend, so now he has another person telling him to learn Haskell.
17:22:59 <tomberek> ddarius: i've tried optimizing it as much as possible,, ended up with being able to construct a doubly linked circular list, and i can take 100 million steps along that list in 6 seconds on a 1.2GHz core.... is that about the best I can expect? I think I might be needing a CPS conversion, but i'm not sure
17:23:16 <acowley> shapr: You can do that. I followed a blog post that described how and got some things working.
17:23:27 <acowley> shapr: But it is still much more work than just writing in wiring
17:23:36 <BMeph> tomberek: Implementation specifications, ewwwwww! ;p
17:24:27 <BMeph> monochrom: If you think I'm "doomed," I have the most part of what I'm using at: http://hpaste.org/45158/parsec_question
17:24:43 <monochrom> no, I don't think you're doomed yet.
17:25:10 <ddarius> tomberek: CPS transforming would be a rather odd thing to do.  That said, traversing 100 million pointers that are unlikely to have nice locality is already a time consuming operation.  You are only two orders of magnitude from a step a cycle.
17:25:27 <BMeph> monochrom: Well, By "doomed," I just mean "doomed to parse out the list 'by hand'".
17:26:02 <XXX-man> can i interpret regular expression as tree?
17:26:21 <hpc> > 1.2 / 100
17:26:22 <lambdabot>   1.2e-2
17:26:30 <monochrom> to a large extent, re-organizing the grammar helps reduce hand-written code.
17:26:32 <hpc> >100 / 1.2
17:26:36 <hpc> > 100 / 1.2
17:26:37 <lambdabot>   83.33333333333334
17:26:44 <XXX-man> 1*5
17:26:46 <tomberek> ddarius: is seems pretty good, it's just that I'm using this type of construct to do the repetition:  for 0 _ a = a;    for n f a = for (n-1) f (f a)     just seems cludgy
17:26:50 <hpc> jeez, took long enough; that's about 90 cycles per list element
17:26:53 <XXX-man> 1 / 5
17:27:02 <hpc> are you just touching the elements, or doing things with them?
17:27:02 <BMeph> > 6*1.2e9/100e6
17:27:03 <lambdabot>   72.0
17:27:08 <hpc> if the latter, that's pretty fast
17:28:20 <tomberek> hpc: just touching
17:28:40 <hpc> i see
17:28:42 * BMeph hopes the touching isn't inappropriate... ;p
17:28:51 <hpc> > unsafeTouchPointer
17:28:52 <lambdabot>   Not in scope: `unsafeTouchPointer'
17:30:10 <BMeph> > useListerine
17:30:11 <lambdabot>   Not in scope: `useListerine'
17:30:27 <BMeph> Heh. Mouthwash humor.
17:30:43 <Peaker> @index unsafeIOToST
17:30:43 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
17:30:54 <Peaker> Isn't it unfortunate that unsafe operations are in the same module/import?
17:33:53 <btutt> @hoogle MkState
17:33:53 <lambdabot> No results found
17:36:03 <gks> I've done a bit of searching but not finding anything real concrete. I see the new Haskell book is out and I'm curious what real world things someone might be able to do with Haskell. Any links to interesting things?
17:36:12 <tomberek> right now i am just traversing with a function with a type like this:    MyType -> MyType,   i was thinking of using a CPS   MyType -> (MyType -> r) -> r         would that net any benefits?
17:36:26 <XXX-man> can i interpret regular expression as tree?
17:36:39 <monochrom> there was a window manager (xmonad) written in haskell
17:37:08 <monochrom> some people use some web frameworks (snap, yesod) written in haskell
17:37:15 <monochrom> what is your real world?
17:37:32 <geheimdienst> monochrom: there *was* a window manager?
17:37:55 <gks> i guess that sounded worse than it was intended. lol. I'm just curious what people are doing with Haskell
17:37:57 <BMeph> XXX-man: Yes, you can! Next question? ;p
17:38:04 <monochrom> everyone has a different "real world", as defined by the 0.001% of the real world he/she comes into contact.
17:39:00 <XXX-man> next question in  #haskell-blah
17:39:02 <XXX-man> :)
17:39:10 <monochrom> galois.com use haskell to provide most of its services
17:39:18 <XXX-man> BMeph: ok?
17:39:20 <XXX-man> :)
17:40:14 <Peaker> I think Haskell is very under-represented in opensource and visible software, relatively to its merit... Maybe it's because of the still-existing annoyances with butterfly effect/etc. Maybe it's just people's fear of the unknown
17:40:22 <gks> I think I'll grab the ebook and see what I can learn from it. Seems very different than anything else I've seen lately. Seems a toss up between learning Haskell or Erlang right now for me
17:40:44 <monochrom> a lot of NDA prevents haskell use from being visible
17:40:47 <gks> I was hoping someone could convince me to pick Haskell first lol :-P
17:40:53 <ddarius> Haskell is better as an Enterprise language.
17:41:07 <ddarius> gks: Learn them both.
17:41:07 <geheimdienst> @slap ddarius
17:41:07 * lambdabot will count to five...
17:41:09 <Peaker> monochrom, Any more than other languages that happen to be more visible?
17:41:18 <mathstuf> gks: configuring XMonad got me into it :)
17:41:30 <monochrom> Much more.
17:41:41 <BMeph> ddarius: So which language would be better for the Defiant? ;p
17:41:52 <Peaker> btw: Wouldn't the butterfly dependency effect be solved by replacing having the name+version in the symbol names, with having the hash of (all dependency-version hashes, the package name, the package version) ?
17:41:57 <Peaker> monochrom, why?
17:42:14 <gks> best way to install the required tools on a Mac? MacPorts have something?
17:42:31 <monochrom> I don't know why. Apart from "it just happens".
17:42:59 <monochrom> As it also happens, J enjoys the same problem.
17:43:05 <mathstuf> gks: installer from website and then cabal from there? (linus user myself)
17:43:39 <jmcarthur> mathstuf: wow! most people just complain about configuring xmonad because they don't want to learn another language
17:43:57 <monochrom> Only a sociologist can explain why.
17:43:59 <mathstuf> jmcarthur: it was my wandering WM days
17:44:14 <aavogt> xmonad could be easier to configure
17:44:21 <mathstuf> though it was really just KWin -> ratpoison -> xmonad
17:44:32 <Peaker> http://hackage.haskell.org/package/binary-search -- claims it has exponential searches, but I can only see binary searches
17:44:35 <dmwit> gks: I guess the Haskell Platform probably has something for Mac...?
17:44:52 <dmwit> http://hackage.haskell.org/platform/mac.html
17:45:20 <dmwit> The Haskell Platform is the compiler + a collection of libraries of known, high quality.
17:45:23 <monochrom> You have to study the social dynamics and psychology behind FOSS, and you have to study the social dynamics and psychology behind all the NDA projects in banks and the military. And only then can you explain:
17:45:29 <Peaker> Is a search of index 0, 1, 2, 4, 8, ... considered "exponential search"? that's what I need and am guessing
17:46:04 <monochrom> why C enjoys both high profile GTK+ FOSS and secret bank projects, and why Haskell and J enjoys only secret bank projects.
17:46:06 <Peaker> monochrom, Well, trying to push Haskell at my workplace is heavily rejected before the (dis)advantages are even brought to light..
17:49:27 <monochrom> the armchair sociologist inside me says: secret bank and military projects select language (and other tools) by technical merit only. proletarian programmers select language by a more mixed bag of factors.
17:49:31 <gks> dmwit: thanks for the link!
17:50:55 <hpc> monochrom: i would think secret bank stuff also comes down at least partly to what the programmers there know
17:52:02 <BMeph> hpc: "What the programmers know" is a criterion for acceptance. I think monochrom is looking more at rejection criteria.
17:52:42 <hpc> ah
17:53:17 <monochrom> actually, secret bank projects come down to what the minority elite programmers know. and they do know a lot.
17:54:08 <djahandarie> This is reminding me of this one guy who trolled the US government constantly for years regarding technology
17:54:13 <monochrom> the elite makes a decision and force it over their numerous underlings
17:54:24 <djahandarie> How would the bank know who is an elite programmer?
17:54:30 <BMeph> I'd be interested in a secret bank project written in Tcl. Just because...it's in Tcl!
17:56:10 <monochrom> self-perpetuating choosing of who to promote to the elite.
17:56:24 <dmwit> tcl is a nice language.
17:56:37 <dmwit> s/nice/consistent/, I guess
17:57:12 <ddarius> Consistently slow
17:57:18 * dmwit shrugs
17:58:21 * BMeph seriously wonders how Tcl and Ruby stack up in the "speed" department...
17:58:42 * BMeph specifically means against each other, mind you.
18:00:23 <XXX-man> mercurial:MIT?
18:06:18 <rnik> Is there a library for GHC that lets you create abstract syntax trees and emit code at runtime?   Like System.Reflection.Emit in .NET?
18:07:23 <ddarius> There's the GHC API, there's hint, there's Harpy, there are a few other things.
18:08:49 <dmwit> Huh, adding type equalities to the context of a class instance can make it undecidable?
18:09:12 <hpc> wouldn't extra constraints make it even more decideable?
18:09:21 <dmwit> No, not necessarily.
18:09:32 <dmwit> But it's hard to imagine an equality constraint being undecidable.
18:09:34 <dmwit> (to me)
18:09:53 <dmwit> Hm... maybe it's not.
18:10:26 <ddarius> Think Prolog occurs check.
18:10:40 <hpc> ah
18:10:58 * hpc hasn't prolog'd, but knows of occurs checking
18:12:37 <Peaker> who's Ross Paterson ?
18:12:57 <rnik> Okay the GHC api is what I want, but I see it is hidden.
18:13:03 <Peaker> I want to send a patch to his binary-search package.. too bad we don't have a github field for hackage packages
18:13:22 <dmwit> We have a repository field.
18:13:27 <dmwit> Which could reasonably link to github.
18:14:43 <Peaker> ah, so unfilled by binary-search
18:15:00 <Peaker> I wish everyone migrated to github already :)
18:15:25 <dmwit> It's that good?
18:15:33 * dmwit has so far managed to avoid it
18:17:01 <mathstuf> Peaker: its good, but the bug tracker still leaves quite a bit to be desired
18:18:19 <Peaker> dmwit, Beyond being a simple host of repos with users and permissions. The nicest thing is the "fork" button, you press it and your dashboard gets a new repo which is a clone of that one.. then you can send pull requests to them
18:18:27 <XXX-man> so, is there way to interpret regular exprssion as tree?
18:18:30 <Peaker> dmwit, really easy to fork stuff, and send others URL of your fork
18:18:38 <Peaker> dmwit, also has very nice stats/graphs/etc it can draw
18:18:47 <dmwit> XXX-man: There was a neat paper about that at POPL this year.
18:18:47 <Peaker> XXX-man, sure
18:19:36 <Peaker> dmwit, so if binary-search was on github, I'd browse to its page, press "fork", copy&paste the URL I get, "git clone" it here, make my patch, commit&push, then I think owner gets github message about someone forking + here're the changes
18:20:05 <XXX-man> smwit: can u tell me a title of the paper please?
18:20:18 <dmwit> XXX-man: I'm looking for it. The POPL site seems down.
18:20:24 <XXX-man> Peaker: a* for example, how would u represent?
18:20:45 * monochrom puns on "a* search" :)
18:20:57 <XXX-man> http://www.cse.psu.edu/popl/11/
18:21:03 <Peaker> monochrom, that's what I thought he meant at first! (in #haskell-blah)
18:21:05 <XXX-man> does not works here also
18:21:11 <Peaker> XXX-man, (many (string "a"))
18:21:13 <dmwit> XXX-man: Regular Expression Containment: Coinductive Axiomatization and Computational Interpretation
18:21:43 <dmwit> XXX-man: Oh, you just mean representing the expressions themselves as trees?
18:21:53 * monochrom doesn't think of regular expressions as coinductive
18:22:35 <dmwit> XXX-man: If that's what you mean, you'd probably be more interested in "A Play on Regular Expressions", which was a functional pearl this year or last year.
18:23:19 <XXX-man> seems this paper is not freely availabe
18:24:04 <dmwit> The functional pearl definitely is.
18:24:13 <XXX-man> http://scholar.google.com/scholar?cluster=9977906751897778399&hl=en&as_sdt=0,5
18:24:21 <dmwit> Use regular Google instead of Google Scholar. =)
18:24:23 <acowley> The play on regular expressions is also a very nice, readable paper
18:24:25 <XXX-man> could u see please this link
18:24:50 <dmwit> The PDF of the former seems available from diku.dk at your Google Scholar link.
18:25:13 <dmwit> Oh, huh, that's a different paper (?).
18:25:38 <XXX-man> :)
18:25:40 <XXX-man> yes
18:25:43 <XXX-man> confused me
18:25:51 <dmwit> Anyway, that's not the paper you want.
18:25:59 <XXX-man> dmwit: may i show u one page?
18:26:06 <dmwit> That talks about representing regular expression *matches* as trees, not the expressions themselves.
18:26:21 <hpc> the expression isn't a tree
18:26:24 <hpc> it's a string
18:26:37 <dmwit> The string can be parsed.
18:26:39 <dmwit> Then it's a tree.
18:26:54 <acowley> monochrom: doesn't any finiteness depend on the input?
18:26:56 <dmwit> (can, and should, by any sane implementation)
18:27:35 <XXX-man> dmwit: i am representing unranked terms as unranked trees and decidinig identityof unranked trees
18:28:10 <XXX-man> so, i am intepreting unranked terms as unranked trees
18:28:11 <Peaker> Is there a standard class for STRef/newSTRef/read/write vs IORef/etc?
18:28:21 <Peaker> (like STArray and MArray)?
18:28:30 <dmwit> Peaker: I think so, though I don't remember where.
18:28:32 <hpc> Peaker: yes
18:28:35 <dmwit> Let's see...
18:28:35 <hpc> :t ($=)
18:28:36 <lambdabot> Not in scope: `$='
18:28:41 <hpc> @hoogle ($=)
18:28:41 <lambdabot> No results found
18:28:43 <aavogt> that's in opengl
18:28:55 <Peaker> I'll just use STRefs directly for now :)
18:29:01 <acowley> I think it's Data.StateVar
18:29:01 <aavogt> http://hackage.haskell.org/package/StateVar-1.0.0.0
18:29:01 <roconnor> is there a showHex that is padded with 0's
18:29:03 <XXX-man> I need to check also in(term, reglang) whether term belongs in regular language
18:29:16 <XXX-man> so, i need to interpret reglang as unranked tree
18:29:51 <dmwit> roconnor: printf, maybe?
18:30:00 <dmwit> > printf "%3x" 1
18:30:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:30:01 <lambdabot>    `Text.Printf.PrintfType ...
18:30:04 <dmwit> > printf "%3x" 1 :: String
18:30:05 <lambdabot>   "  1"
18:30:06 <roconnor> bleah
18:30:13 <dmwit> > printf "%0.3x" 1 :: String
18:30:13 <lambdabot>   "001"
18:30:48 <osoleve> how do i get the index of an item in a list?
18:31:19 <dmwit> :t find
18:31:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
18:31:22 <dmwit> :t findIndex
18:31:23 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
18:31:34 <osoleve> mmk, thanks
18:31:35 <dmwit> osoleve: And then you refactor so that you don't have to do that.
18:31:46 <osoleve> haha okay
18:31:52 <osoleve> i'll think of a better solution :)
18:32:33 <Peaker> :t lookup
18:32:34 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
18:32:36 <acowley> What were you planning on doing with the index?
18:32:45 <dmwit> XXX-man: ftp://ftp.diku.dk/diku/semantics/papers/D-612.pdf may be the Henglein paper?
18:32:55 <osoleve> acowley: the more i think about it, the less it would work, so nevermind :3
18:33:07 <tomberek> ddarius: specifying the type (and making it less polymorphic) of the 'for' function   {for' :: Int -> (DList->DList) -> DList -> DList} has made the traversal of the doubly linked list almost twice as fast
18:33:09 <Peaker> @type \x -> lookup x . (`zip` [0..])
18:33:09 <lambdabot> forall b a. (Eq a, Num b, Enum b) => a -> [a] -> Maybe b
18:33:54 <Peaker> aavogt, doesn't seem to have instance for ST s?
18:34:07 <Peaker> aavogt, it's specific to IO
18:34:18 <Peaker> disgraceful :-)
18:34:47 <XXX-man> dmwit: aha, but they are doing axiomatization of regular languages
18:34:51 <XXX-man> I do not need it
18:34:53 <roconnor> > bitsize (0::Word32)
18:34:54 <lambdabot>   Not in scope: `bitsize'
18:35:02 <XXX-man> I need more simple thing :)
18:35:23 <acowley> :t bitSize
18:35:24 <lambdabot> forall a. (Bits a) => a -> Int
18:35:30 <roconnor> > bitSize (0::Word32)
18:35:30 <lambdabot>   32
18:35:43 <acowley> This one annoyed me today
18:35:48 <acowley> > bitSize (0::Float)
18:35:49 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Float)
18:35:49 <lambdabot>    arising from a use of `...
18:35:51 <acowley> :(
18:35:57 <roconnor> > fix bitSize
18:35:58 <lambdabot>   64
18:36:08 <hpc> roconnor: O.O
18:36:10 <hpc> :t bitSize
18:36:11 <lambdabot> forall a. (Bits a) => a -> Int
18:36:20 <roconnor> hpc: gives the native cpu integer size
18:36:38 <hpc> oh i see how it doesn't bottom out
18:36:40 <hpc> im dumb
18:36:46 <roconnor> :D
18:37:01 <hpc> that's a cool trick
18:37:20 <dmwit> XXX-man: As I tried to tell you. =)
18:37:50 <XXX-man> dmwit: what do you mean :)?
18:44:57 <Peaker> @index HasBounds
18:44:57 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
18:45:13 <hpc> @index hack!
18:45:13 <lambdabot> bzzt
18:45:16 <hpc> @index hack
18:45:17 <lambdabot> bzzt
18:45:19 <hpc> aw
18:45:23 <Peaker> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array-MArray.html#t%3AHasBounds <-- listed here, but import of HasBounds from MArray fails?
18:46:01 <Peaker> oh, it's renamed to getBounds in ghc 7?
18:46:31 <Peaker> and now is monadic.. breakage-inducing?
18:47:07 <hpc> Peaker: it's bug-checking incentive!
18:47:16 <hpc> Peaker: if they already have to go through the code once...
18:47:33 <Peaker> what's the reason for this change though?
18:47:37 <Peaker> what was wrong with a pure bounds?
18:48:29 <hpc> (someone should rename !! to !!! in the next haskell revision; i would bet money that within a month, most buggy packages are either totally fixed or removed)
18:49:39 <marcot> Is there a function that behaves like "rm -r" in haskell?  It seems that removeDirectoryRecursive follow symlinks, and I want them to be simply erased.
18:51:08 <hpc> system "rm -r" ?
18:51:22 <hpc> or whatever it's called
18:51:36 <hpc> (yes, i know relying on shell behavior is bad)
18:52:38 <XXX-man> dmwit: ?
18:56:41 <dmwit> XXX-man: Hey, sorry, I was cooking.
18:56:48 <dmwit> I didn't mean anything by it.
18:56:55 <dmwit> Just a cheeky "I-told-you-so".
18:57:25 <glguy> lispy: CReal was way to slow, but BigFloat Prec50 worked like a charm :)
18:57:49 <XXX-man> dmwit: good apetite
18:58:17 <dmwit> thanks =)
18:58:47 <copumpkin> glguy: edwardk and I are working on and off on a good mpfr binding for haskell
18:58:53 <copumpkin> in case that'd be useful
18:59:13 <copumpkin> he's also wrapping it in fancier interval arithmetic
19:00:32 <Axman6> glguy: what's the implementation of BigFloat like?
19:00:52 <glguy> "A simple implementation of floating point numbers with a selectable precision. The number of digits in the mantissa is selected by the Epsilon type class from the Fixed module.
19:00:53 <glguy> The numbers are stored in base 10."
19:01:00 <glguy> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-BigFloat.html
19:01:09 <Axman6> copumpkin: interesting, one of my current lecturers is doing research into interval arithmetic
19:01:23 <roconnor> typeclasses are kinda amazing
19:03:02 <copumpkin> Axman6: I think the stuff he wants to do is called taylor models
19:03:44 <dmwit> Is there any way to get ghci to reduce type families?
19:03:47 <copumpkin> apparently model the values as a taylor series and behave a lot more nicely on addition than interval arithmetic 
19:03:57 <copumpkin> dmwit: not that I know of :/ I think it tries pretty hard not to
19:04:04 <dmwit> annoying
19:05:16 <djahandarie> I would be nice if there was some library for modulo arithmetic on Hackage
19:05:22 <glguy> hmm, looks like BigFloats comparison functions are wrong
19:05:24 <glguy> *Main Data.Number.CReal Data.Number.BigFloat> 3.990025605686288622567559877435e-24 < (1e-10 :: BigFloat (PrecPlus20 Prec10))
19:05:25 <glguy> False
19:05:43 <Axman6> o.O
19:05:54 <copumpkin> glguy: doesn't that 1e-10 reduce to 0 with that precision?
19:06:03 <copumpkin> or am I misunderstanding the annotation?
19:06:11 <glguy> misunderstanding
19:07:12 <copumpkin> oh I see
19:07:17 <glguy> *Main Data.Number.CReal Data.Number.BigFloat> (1e-80 :: BigFloat Prec10)
19:07:17 <glguy> 1.0000000000e-80
19:07:33 <copumpkin> yeah
19:08:57 <dmwit> data BigFloat e = BF (Fixed e) Integer deriving (Eq, Ord)
19:09:08 <dmwit> I guess you can't really expect the derived Ord instance to do the right thing.
19:09:49 <dmwit> It shouldn't be hard to fix, and I'm sure they'd accept a patch.
19:10:07 <dmwit> Oh, this is that package that has no real maintainer.
19:10:13 <XXX-man> dmwit: do you have strong backgrounds with this regural expressions and all it buisness :)?
19:10:18 <dmwit> So you don't even have to bother with a patch, just upload a fixed version. =)
19:10:37 <dmwit> XXX-man: No, I have a weakish background. But stronger than a non-CS person, I guess. =)
19:10:50 <XXX-man> :)
19:10:59 <XXX-man> person from biology?
19:11:00 <augur> byorgey: your enumeration task has become interestingly relevant!
19:11:53 <dmwit> XXX-man: Actually, I work on lenses. I played with string lenses for a little while. Regular expressions are really important there.
19:12:02 <dmwit> But I didn't spend long enough to become *really* expert.
19:12:06 <XXX-man> dmwit: in CLP? do you work?
19:12:30 <XXX-man> lenses? what is that?
19:13:01 <dmwit> Lenses and bidirectional programming: the goal is to write a language that has both a forward and a backward interpretation.
19:13:17 <dmwit> The forward interpretation takes inputs to outputs, and the backward interpretation takes outputs to inputs. (Roughly.)
19:13:27 <ddarius> monochrom: How can you not think of regular expressions as coinductive?
19:13:37 <btutt> If I upgrade a package from 2.1.0.3 of QuickCheck to 2.4.0.1 should the updated Cabal depenency be >= 2.4.0.1 && < 2.5 or just >= 2.4.0.1 ?
19:14:59 <XXX-man> huh, very interesting
19:15:39 <acowley> ddarius: I think it's actually an interesting point... if your regex matcher doesn't produce incremental output, is a match of something like "a*" on infinite input just a divergent process? 
19:15:40 <XXX-man> is it hard to have paper in POPL?
19:15:49 <dmwit> (We hope) it's useful whenever you have two different data structures that need to be "synchronized" somehow.
19:16:09 <dmwit> I guess POPL is one of the top few conferences in the programming languages community.
19:16:28 <XXX-man> do u have paper there?
19:16:32 <dmwit> That and ICFP.
19:16:43 <dmwit> I do. Check http://dmwit.com/ =)
19:16:53 <XXX-man> what FP means?
19:16:55 <augur> dependent type/agda people: supposing i had a type like (X : Set) -> {X}x(XxX -> 2)  (mixing notations a bit, but..)
19:17:02 <dmwit> functional programming
19:17:16 <acowley> dmwit: I think I sort of used a lens recently! I wrote a function with type (a -> b) -> (a -> c -> d) -> m (b -> m c) -> Topic m a -> Topic m d
19:17:20 <augur> is there a more elegant way of expressing this?
19:17:25 <jmcarthur> augur: is lowercase supposed to be a product?
19:17:28 <augur> yeah
19:17:30 <jmcarthur> lowercase x, i mean
19:17:39 <XXX-man> pierce is ur supervisor???
19:17:41 <XXX-man> great
19:17:53 <dmwit> acowley: Still parsing...
19:17:53 <lispy> glguy: interesting
19:18:14 <acowley> dmwit: The first function is a projection, the second an injection, the third a transformer
19:18:24 <augur> i mean really the type is supposed to be a functor-ish-y thing that takes a set to the pair consistent of that set and _some_ function over pairs of elements of that set
19:19:03 <lispy> glguy: it's easy to have non-terminating calculations with CReal, IIRC
19:19:07 <dmwit> acowley: Neat!
19:19:08 <jmcarthur> augur: {X} ... does that mean the first parameter to x is implicit or what? that doesn't seem to fit with your other use of x, where the first parameter is explicit
19:19:13 <augur> so like F Int == (Int, = :: (Int,Int) -> Bool) in haskellish notation, i guess
19:19:16 <dmwit> acowley: What was the context?
19:19:21 <augur> jmcarthur: no, its supposed to be the set containing X
19:19:34 <augur> i mean, like i said, the idea is that inhabitants of the type are pairs
19:19:34 <acowley> dmwit: I use it to thread monadic transformations of projections of a monadic stream of record types
19:19:45 <augur> specifically, pairs where the first element is that set that was the argument
19:19:53 <augur> and the second element is a function ~ ...
19:20:12 <acowley> dmwit: actually, it's part of the code that answers my mini-rant about robotics software from last year's hackphi
19:20:12 <glguy> lispy: did you see the comments about bigfloats?
19:20:16 <XXX-man> dmwit: can you come in haskell-blah :)?
19:20:21 <augur> eg an ordered set might be .. Poset X = (X, <_{X}) right
19:20:58 <lispy> glguy: yeah, does the wrong thing during comparison
19:21:16 <dmwit> glguy: It should be easy to fix, upload a fixed package! =)
19:21:25 <augur> so that if p :: Poset X, then fst p == X, and snd p == some function of type XxX -> 2
19:21:30 <lispy> glguy: but seriously, IEEE754 floats have issues with comparison too :)
19:21:40 <dmwit> acowley: haha
19:22:00 <augur> im just curious if theres a cleaner way to express this other than F : (X : Set) -> {X}x(XxX -> 2)
19:22:02 <jmcarthur> augur: oh so this is just a dependent product then?
19:22:10 <lispy> I just read that japanese tutorials for enumerator.  It's actually pretty nice.
19:22:13 <glguy> lispy:  and error this hilarious would result in a massive recall. Intel would have flashbacks
19:22:14 <augur> yes, its a dependent product
19:22:20 <augur> well
19:22:26 <augur> sort of, right
19:22:53 <lispy> glguy: minor detail :)
19:23:19 <augur> i mean, its a dependent product but thats the resulting value because this is supposed to be the type of the type operator
19:23:58 <osoleve> qwp, did you know there's more than one infinity?
19:24:01 <jmcarthur> augur: and i'm still slightly confused on your {X} notation. you mean it's a classical set containing X whose type is Set?
19:24:02 <augur> so the fact that its a dependent product is really secondary, it more just a product type that is the body of a dependent type
19:24:03 <osoleve> wrong channel.
19:24:29 <augur> sort of like (X : Set) -> XxX -> 2
19:24:36 <augur> only it also happens to have X carried along with it
19:24:40 <acowley> augur: I don't really see the problem?
19:24:48 <augur> jmcarthur: yes, its just the set containing X
19:24:49 <djahandarie> Wasn't #agda just talking about this?
19:24:59 <augur> so that the product will ofcourse always have X as its first value
19:25:12 <fragamus> I have a monad question: I want to use the list monad, or something like the list monad, but I want to write my own bind operator.  You see, with the list monad as I am using it, the list elements are being returned as the funciton value which is matched by an expression.  What I want is something more like the state monad, where there is some hidden state.
19:25:13 <augur> acowley: im not saying theres a _problem_, im just wondering if theres a nicer notation
19:25:56 <augur> i mean, haskell pair notation is used for products, but i could appropriate it for elsewise -- (X : Set) -> (X, r : XxX -> 2)
19:26:02 <augur> but i dont know, is that kosher?
19:26:04 <augur> meh!
19:26:15 <augur> i feel there should be some standard notation for this
19:26:22 <lispy> fragamus: we usually use newtypes for that sort of stuff
19:26:34 <dmwit> fragamus: Perhaps you'd like something like StateT s []?
19:26:42 <dmwit> ?unmtl StateT s [] a
19:26:42 <lambdabot> s -> [(a, s)]
19:26:44 <lispy> newtype FragmusList a = FL [a]
19:27:14 <lispy> oh, maybe yeah.
19:27:27 <dmwit> fragamus: If you get to thinking you might like ListT instead, then you should check out the Omega monad instead.
19:27:30 <marcot> hpc: That's what I'm using, I was just considering if there was a better option.  But thanks anyway.
19:27:34 <lispy> "I want to write my own bind operator."  I read that much and went for the newtype.
19:28:17 <Axman6> hmmmm... seems StateT a [] could easily be used for something like non-deterministic state machine evaluation
19:29:20 <jmcarthur> augur: i don't really see how that function would be implemented. could you give an implementation to go with the type?
19:30:00 <owst> A package I need to use on Hackage has an out-of-date dependency. Should I contact the maintainer? (Sorry if that is a very obvious question)
19:30:13 <augur> jmcarthur: uh.. well its supposed to be a type operator
19:30:30 <Axman6> owst: that would be preferable
19:30:47 <jmcarthur> augur: oh, so then that *is* the implementation?
19:31:06 <augur> but like, you could say, F : (X : Set) -> {X}x(XxX -> 2) ; f : X -> F X ; f X = (X, const True)
19:31:13 <owst> Axman6, great thanks. I was only checking in case there was some other intended method of notifying them. 
19:31:40 <augur> er, sorry, that shold be
19:31:42 <Axman6> owst: in the mean time you can also download and install the package manually after fixing the dependency
19:31:46 <augur> f : (X : Set) -> F X
19:32:09 <ddarius> {X} makes little sense.
19:32:17 <augur> ddarius: the set containing X
19:32:22 <augur> how does that not make sense
19:32:33 <augur> {1} is the singleton containing 1
19:32:39 <augur> {X} is the singleton containing X
19:32:55 <owst> Axman6: Yup, in the middle of doing so for a couple of packages that are themselves arch packages at the moment :). Thanks for the advice.
19:33:01 <roconnor> @hoogle runPut
19:33:01 <lambdabot> No results found
19:33:13 <jmcarthur> augur: why do you need a set of types?
19:33:25 <ddarius> Yes, and it makes little sense to use it.  -All- singleton sets are isomorphic.  So {X}xA ~ A.  You might say "well, I can get the X that's relevant from the first component", but you'd already have to know it to know the (type of the) type the thing.
19:33:25 <augur> jmcarthur: ey?
19:33:42 <jmcarthur> or is that supposed to be the type of a set of Xs?
19:34:31 <augur> jmcarthur: no, its supposed to be what i wrote.
19:34:48 <jmcarthur> without your awkward {X} stuff, i'd guess you mean something that would look like this in agda:   F : Set ‚Üí Set ; F X = X √ó (X √ó X ‚Üí Bool)
19:35:47 <augur> ddarius: yes, i suppose, but the point is that this is supposed to be a type for sets-plus-structure, and having the structuring function doesnt let me inspect the set itself since the set isnt present
19:36:18 <augur> ddarius: like, a partial order is a pair, (X,<=) where <= : XxX -> 2
19:36:23 <ddarius> Then it should be a type of -sets- plus something.  I.e. Œ£X:Set.X√óX -> 2
19:36:34 <jmcarthur> what ddarius said
19:37:09 <augur> yes but thats just the pairs, thats not the operator that says given some set, what does an ordering over it look like
19:37:33 <ddarius> augur: Learn more about sigma types.
19:37:46 <jmcarthur> augur: the second component depends on the first
19:37:50 <copumpkin> the type of it
19:37:52 <augur> ofcourse it depends on the first
19:37:58 <augur> i didnt say it didnt
19:38:13 <augur> but sigma types are not type operators
19:38:19 <augur> they're just the type of dependent pairs
19:38:20 <ddarius> augur: As you said yourself, a poset is a -pair- not a -function-.  I.e. it is a dependent sum, not a dependent product.
19:38:30 <augur> ddarius: and as i said, im not looking for the type of the pair
19:38:53 <augur> im looking for the type function that given a set GIVES ME the pair type
19:39:22 <augur> which is exactly what i typed
19:39:28 * osoleve gives augur the pair type
19:39:33 <augur> o mai
19:39:37 <jmcarthur> okay, so first.... am i correct in guessing that you are looking for the definition of F : Set -> Set?
19:39:44 <augur> no what
19:39:57 <jmcarthur> F takes a Set and gives you a Set?
19:40:12 <jmcarthur> the result being this pair?
19:40:32 <osoleve> :t id
19:40:32 <augur> i mean, in some abstract sense i suppose it would be true that this holds, sure, but the point is that F should take some set and give me the type of posets over that set
19:40:32 <lambdabot> forall a. a -> a
19:40:35 <jmcarthur> in haskell F would be a type alias
19:40:44 <augur> Poset {1,2,3} should be the type of posets over {1,2,3}
19:40:56 <tomberek> ddarius: i've been able to shave the 6s traversal of the linked list down to about 3.5s (that's 100 million steps on a 1.2 GHz) so apx 10 cycles per traversal
19:41:09 <augur> not that it gives me SOME poset
19:41:29 <augur> treating lists as ordered sets, [1,2,3] : Poset {1,2,3}, and also [3,2,1] : Poset {1,2,3}
19:41:30 <augur> etc etc
19:41:47 <tomberek> *er 30
19:42:50 <augur> its exactly what i said, Poset : (X : Set) -> {X}x(XxX -> 2)
19:43:20 <augur> given some set X, you get back that type of pairs where the first element is X and the second element is some function of type XxX -> 2
19:43:53 <jmcarthur> okay, here's a silly question. when you say (X : Set), it's looking like you are not talking about Set as in what agda calls a type
19:43:58 <jmcarthur> is that right?
19:44:09 * hackagebot git-object 0.0.1 - Git object and its parser  http://hackage.haskell.org/package/git-object-0.0.1 (KazuYamamoto)
19:44:31 <jmcarthur> because if not, that's the source of confusion here
19:44:33 <augur> maybe maybe not, im not sure it matters but i just mean sets-as-collections
19:44:54 <jmcarthur> yup that was it. i was thinking valid values of X would be things like Int, String, etc.
19:45:06 <augur> well it could be for all i care
19:45:53 <augur> but obviously the details of _agda_ might make that difficult
19:46:03 <jmcarthur> but then the result type would be {Int}x(IntxInt -> 2)
19:46:11 <augur> yes it would
19:46:16 <augur> and whats an inhabitant of that type?
19:46:18 <augur> (Int, <=)
19:46:28 <augur> another might be (Int, =)
19:46:39 <jmcarthur> so you'd have a classical set containing the Set Int paired with a binary relation on Ints...
19:46:41 <augur> another (Int, fork (&&) even even)
19:46:44 <augur> whatever you like
19:46:46 <ddarius> augur: Œ£X:Set.E(X) is a dependent version of Set√óE, not of X√óE.  The consumers want to be able to -extract- the Set from the pair your operator produces, so your operator needs to pack it up.  Œ£X:Set.E(X) says that there is some -Set-, such that E(X), not that there is Some E(X).
19:47:14 <augur> ddarius: yes, but the point is that i dont want just some set
19:47:18 <augur> i want the set im telling you about
19:47:40 <augur> look, ddarius, if i say All Partial Orderings Over The Set {1,2,3}
19:47:43 <augur> thats a type, right?
19:47:58 <jmcarthur> augur: those values have type Œ£[ X ‚à∂ Set ] X √ó X ‚Üí Bool
19:48:08 <ddarius> augur: Your type operator -knows- the Set and will pack up -that- set.  The consumers need to not know the Set until they unpack it.  If they knew the Set ahead of time, then they have no need to project it out.
19:48:20 <augur> ddarius: its a simple question, yes or not
19:48:23 <augur> no*
19:49:05 <ddarius> augur: It's a type, but the type of -partial orderings- is (a refinement of) that sigma type.  You want a type operator Set -> Set, that will produce partial orderings, i.e. those sigma types.
19:49:17 <augur> ok, yes
19:49:20 <augur> now do me a favor will you
19:49:21 <jmcarthur> augur: is {1,2,3} a Set or a value *in Agda*?
19:49:24 <augur> tell me the type of this function
19:49:37 <augur> \x -> All Partial Orderings Over The Set x
19:49:51 <jmcarthur> augur: we are giving you things of type Set -> Set (for agda's definition of Set)
19:49:53 <ddarius> Set -> Set.
19:50:09 * hackagebot wai-app-file-cgi 0.0.2 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.0.2 (KazuYamamoto)
19:50:29 <augur> ok fair enough
19:50:30 <ddarius> (More particularly Set1 -> Set1)
19:50:32 <jmcarthur> augur: what is the type of x in that expression?
19:50:49 <ddarius> (er Set0 -> Set1)
19:50:54 <augur> tho mind you, im not talking about agda's set, like i said
19:51:02 <augur> might as well be lists for all i care
19:51:31 <augur> its not the type Type version of Set its just a set
19:51:52 <ddarius> If you want x to be a value of some type, then the function will be ThatType -> Set1, if you want x to be a "type" then, in Agda terms, it would be Set0 -> Set1.
19:51:53 <dolio> The type of partial orderings of {1,2,3} is {1,2,3} x {1,2,3} -> Bool.
19:52:10 <augur> yes i get that dolio
19:52:13 <jmcarthur> let's just call the type of classical sets S to avoid further ambiguity
19:52:24 <augur> but if you lambda abstract over that, dolio, you get \X -> XxX -> Bool
19:53:43 <augur> i mean goodness look, you can have a type operator that takes a set to the type of binary predicates over that set
19:53:50 <ddarius> augur: And that's fine, and there's no "{X}" there.
19:53:58 <augur> ddarius: yes but look, ddarius
19:54:11 <augur> if i then also want to throw the set into the mix
19:54:30 <augur> and hair pairs that satisfy fst p == X and snd p :: XxX -> Bool
19:54:39 <augur> then those pairs are inhabitants of
19:54:41 <augur> wait for it
19:54:44 <ddarius> augur: And what is the type of -fst- there?
19:54:45 <jmcarthur> augur: so now that we have declared S to be the type of classical sets, it looks like you want the result to have type  Œ£[ X ‚à∂ Set ] X √ó X ‚Üí Bool  but now we don't have a meaningful thing to abstract out of it
19:54:57 <jmcarthur> oops
19:54:57 <augur> ddarius: ClassicalSet
19:55:00 <jmcarthur> s/Set/S/
19:55:20 <jmcarthur> augur: what do we want to abstract out from  F = Œ£[ X ‚à∂ S ] X √ó X ‚Üí Bool  ?
19:55:27 <jmcarthur> eh, forget the F = part
19:55:42 <ddarius> ClassicalSet isn't a function and can't be applied.
19:55:51 <augur> ddarius: i didnt say it was!
19:55:52 <jmcarthur> X is a value of type ClassicalSet, there
19:55:52 <augur> what
19:55:59 <augur> oh, the type of fst sorry
19:56:22 <jmcarthur> Œ£[ X ‚à∂ ClassicalSet ] X √ó X ‚Üí Bool
19:56:36 <augur> look guy, i dont even know what the ACTUAL type of fst is supposed to be, im just trying to explain this to you
19:56:46 <augur> jmcarthur: stop using sigmas, you're doing it wrong
19:57:02 <ddarius> augur: How do you know he's doing it wrong when you don't even know what you want?
19:57:04 <jmcarthur> augur: i'm trying to get you to help clear things up because you are not being clear as it is
19:57:12 <augur> ddarius: i DO KNOW
19:57:22 <augur> ffs would you numbskulls listen :|
19:57:26 <jmcarthur> calm down
19:57:26 <augur> im not asking for the type
19:57:30 <augur> i GAVE YOU the type
19:57:36 <augur> im just asking for a cleaner fraking notation
19:57:37 <jmcarthur> you gave us a poorly formed type
19:57:39 --- mode: ChanServ set +o shapr
19:57:40 <ddarius> "i dont even know what the ACTUAL type of fst is supposed to be" is what you said -just before.-
19:57:43 <jmcarthur> it didn't make sense
19:57:45 <shapr> augur: dude, be nice.
19:57:56 <augur> ddarius: im not asking for the type of fst
19:58:53 <augur> look, ddarius, if X is a set, what are the inhabitants of {X}x{X}
19:59:10 <augur> you can list them all, right? theres exactly one inhabitant -- (X,X)
19:59:44 <shapr> Calm and friendly is good... makes it easier to understand what others are saying.
20:00:04 <ddarius> So what would the type of fst be, for that or your original type.  It should be obvious.  Just fill in the blanks.
20:00:31 <augur> {X}x(XxX -> 2) -> {X}
20:00:41 <augur> blank filled in
20:00:55 <augur> fst (X,<=) = X
20:00:58 <augur> maaaagick
20:01:04 <ddarius> Yep.  So, to give fst a type, I'd have to already know X, so there is no use in having it.
20:01:38 <augur> ddarius: how does that answer my question
20:01:40 <ddarius> If, however, fst : Set◊(X◊X -> 2), then I would actually learn that the first component was X without already knowing it.
20:02:44 <augur> no seriously, how is this even remotely relevant to the question i asked. im not trying to be unnecessarily assholish, just appropriately assholish. my question was about cleaning up notation.
20:02:47 <ddarius> Of course, in 'fst : Set◊(X◊X -> 2)' X is unbound.  So we use a dependent sum (also called a dependent pair) to bind it.  Then fst for that dependent sum will indeed be Blah -> Set and when we do that we will find out the set that was used.
20:03:01 <jmcarthur> augur: your question was if there was a better way to express what you said. a less ambiguous way is certainly better
20:03:25 <augur> jmcarthur: my question was "is there a more elegant way of expressing this?"
20:03:26 <ddarius> augur: Fine. To clean up {X}◊(X◊X -> 2) write (X◊X -> 2).  They are completely equivalent.
20:03:34 <jmcarthur> less ambiguous is more elegant
20:03:48 <augur> its completely unambiguous as it is
20:03:53 <jmcarthur> obviously not
20:04:06 <augur> jmcarthur: obviously it is
20:04:19 <jmcarthur> then we wouldn't have been so confused by it
20:04:45 <augur> ddarius: but if i give you a function of that type as an argument, i cant go asking what elements are in the set X
20:04:49 <augur> because the set X isnt an argument
20:04:51 <augur> just the function
20:05:09 <augur> jmcarthur: just because you were confused doesnt mean it wasnt unambiguous
20:05:12 <augur> it just means you were confused
20:05:16 <ddarius> Your function is Set -> Set.  (Œ£X:Set.X√óX -> 2) : Set
20:05:28 <augur> no i mean a function of type XxX -> 2
20:05:33 <jmcarthur> i don't believe i am the one who is confused anymore
20:06:00 <ddarius> Writing '(X : Set) -> pack X with some binary relation on X) : Set -> Set
20:06:19 <augur> what
20:08:03 <augur> ddarius: i dont understand
20:08:24 <ddarius> augur: I pointed that out earlier.
20:08:32 <augur> no, i dont understand what you just wrote
20:08:46 <ddarius> That's because you don't understand sigma types.
20:09:00 <augur> i understand sigma types well enough
20:09:06 <ddarius> Apparently not.
20:09:10 <augur> but look at what you just typed
20:10:39 <augur> ddarius: heres a sigmatype for what i want
20:10:43 <augur> since you're so insistent
20:10:49 <augur> or something with sigma types
20:11:02 <augur> hold on to your pants cause its gonna be fun
20:11:20 <augur> (X : Set) -> Sigma (Y : {X}) XxX -> 2
20:12:07 <ddarius> augur: Do you tend to use ((), Bool) a lot in your code?
20:12:10 <augur> god knows if thats _actually_ constructable in MLTT
20:12:25 <augur> what
20:13:19 <augur> sorry, Set there should be ClassicSet
20:14:37 <augur> or ofcourse it could also be YxY -> 2, for obvious reasons
20:14:53 <ddarius> augur: Incorrect.
20:14:58 <augur> uh?
20:15:05 <augur> well what else could it be, pray tell
20:15:07 <ddarius> It could be X◊X -> 2 though.
20:15:19 <augur> the only value that Y will ever take on is X
20:15:30 <augur> because Y : {X} and {X} has only one inhabitant, X
20:15:35 <ddarius> augur: You don't use Y so that's irrelevant, and Y isn't even in scope in the latter.
20:15:42 <augur> i know
20:15:45 <augur> it COULDVE been
20:15:47 <augur> which is what i said
20:15:56 <augur> and if you had done so it wouldntve made a difference
20:16:04 <ddarius> If you changed it to (Y : Set) -> Y◊Y -> 2, yes.
20:16:09 <augur> what
20:16:31 <augur> i wouldnt have to change it to that at all
20:16:44 <augur> Sigma (Y : {X}) YxY -> 2 is a perfectly valid sigma type
20:16:50 <augur> (assuming X)
20:17:08 <jmcarthur> augur: what i the nature of values of the type {X}? what is the type of {X}?
20:17:08 <ddarius> That's not what you said, you said Sigma (Y : {X}) X◊X -> 2.
20:17:11 <jmcarthur> *what is
20:17:56 <augur> ddarius: yes and read what i said after it -- it could have also been Sigma (Y : {X}) YxY -> 2, because Y can only be X
20:18:20 <ddarius> augur: No, Sigma (Y : Set) X◊X -> 2 is a 
20:18:24 <augur> jmcarthur: how convoluted do you want? Maybe its Set, maybe its Setof Set, maybe its .. i dont know
20:18:26 <augur> take your pick
20:18:32 <ddarius> very different type to Sigma (Y : Set) Y◊Y -> 2
20:18:37 <augur> i didnt say Sigma (Y : Set)
20:18:42 <augur> i said Sigma (Y : {X})
20:18:50 <jmcarthur> augur: i'm only asking because everything you've been saying so far doesn't appear to be well typed at all
20:19:13 <ddarius> Sorry, Sigma (Y : {X}) X◊X -> 2 is a very different type to Sigma (Y : {X}) Y◊Y -> 2 is a
20:19:30 <augur> ddarius: its not different at all
20:19:59 <augur> if Y : {X}, then Y = X, 
20:20:09 <augur> forall X
20:20:17 <jmcarthur> augur: the convention you seem to have set already is that things of the form {a,b,c,d,...} are values. you are using that as a type here
20:20:46 <roconnor> @hoogle foldmap
20:20:46 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
20:20:46 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
20:20:47 <augur> jmcarthur: i didnt say they were values at all
20:21:13 <jmcarthur> augur: sure you did. you used {1,2,3} as an example of a value of ClassicalSet
20:21:35 <augur> did i? maybe i did, my mistake, you're right
20:22:25 <jmcarthur> i think if we can clearly establish the types of everything in this expression then this should clear up pretty easily, one way or another
20:22:27 <augur> let me use {|...|} for instances of Set
20:22:44 <jmcarthur> okay, and what does {a,b,c} mean?
20:22:53 <augur> (X : ClassicalSet) -> Sigma (Y : {|X|}) XxX -> 2
20:23:05 <augur> {a,b,c} : ClassicalSet, {|a,b,c|} : Set
20:23:13 <roconnor> @hoogle showString
20:23:13 <lambdabot> Prelude showString :: String -> ShowS
20:23:13 <lambdabot> Text.Show showString :: String -> ShowS
20:23:13 <jmcarthur> ah!
20:23:41 <jmcarthur> and what might a value of type {|a,b,c|} be?
20:23:42 <ddarius> At any rate, using Sigma (Y : {X}) (X◊X -> 2), then this is just Sigma (_ : {X}) (X◊X -> 2) which is -the definition of- {X}◊(X◊X -> 2) which is isomorphic to (X◊X -> 2) as we had at the beginning.  If you want -that- type, there it is.  You never gain anything by using {X}.
20:23:52 <augur> jmcarthur: a!
20:23:54 <augur> or b
20:23:55 <augur> or c
20:23:57 <augur> take your pic
20:23:57 <jmcarthur> okay
20:23:57 <augur> k
20:24:15 <augur> ddarius: i know its isomorphic
20:24:18 <augur> im not saying it isnt
20:24:38 <augur> Int x Int is isomorphic to Int that doesnt make it identical
20:25:08 <augur> otherwise i reserve the right to tell you to shove it anytime you use products of countably infinite sets!
20:25:19 <ddarius> augur: 1◊A -> A is -canonically- isomorphic to A natural in A.
20:25:22 <augur> and since i highly doubt you never right (Int,Int) in your haskell types
20:25:34 <ddarius> Int◊Int is not canonically isomorphic to itself.
20:25:49 <augur> Int x Int is not isomorphic to Int x Int?
20:25:57 <ddarius> Not in only -one- way.
20:26:10 <augur> ok?
20:26:56 <augur> look, ddarius, if i said Poset X = {|X|} x (X x X -> 2)
20:27:18 <augur> and i asked you to give me a function f : X -> Poset X -> Bool
20:27:27 <augur> -> 2 rather. or vice versa.
20:28:23 <augur> which tests whether its first argument is a minimum of the poset
20:28:54 <augur> and you can have all of agda to do this with if you'd like
20:29:03 <augur> what is that function going to look like?
20:29:17 <augur> is it just going to look like f x g = ... where g is a function?
20:29:18 <augur> no
20:29:52 <augur> maybe it is, maybe i dont know agda well enough, or MLTT well enough, but you do, so you tell me
20:29:54 <ddarius> No, it would look like f x (_,g) = ... where g is a function.
20:30:25 <ddarius> Just like a function ((), Bool) -> Bool would look like f (_, b) = ...
20:30:41 <ddarius> The only thing that can be done with {X} is to ignore it.
20:30:46 <augur> uh
20:30:53 <augur> and how are you going to test if x is the min then?
20:31:04 <augur> surely you'd want it to be
20:31:13 <jmcarthur> okay, here's where i'm seeing an inconsistency. X : ClassicalSet ; {|X|} : Set ; Y : {|X|}    but as you are using it, Y : ClassicalSet, so it follows that {|X|} ‚â° ClassicalSet
20:31:22 <augur> f x (xs,g) = any xs (`g` x)
20:32:17 <augur> jmcarthur: no, because the point is that {|X|} is the type that X is and nothing else is. im not saying it makes sense in Agda, but
20:32:38 <jmcarthur> augur: so then my conclusion is correct anyway
20:32:46 <jmcarthur> since the type of X is ClassicalSet
20:32:51 <augur> which conclusion is that
20:32:55 <ddarius> augur: f x (_, g) = any X (`g` x) would work just as well.
20:33:01 <jmcarthur> {|X|} ‚â° ClassicalSet
20:33:17 <augur> ddarius: where you're getting X from the type signature?
20:33:21 <jmcarthur> and in fact, for anything inside {| |}, it will be ClassicalSet
20:33:54 <augur> jmcarthur: it might be! you introduced the distinction really, not me. i came into this with just sets and products :P
20:33:57 <ddarius> augur: You asked me to write a function X -> Poset X -> Bool.  I clearly know X as I'm writing a function of it.
20:34:26 <byorgey> what on earth are we discussing? or don't I want to know?
20:34:27 <jmcarthur> augur: my point is that now you have      X -> ClassicalSet x (XxX -> 2)
20:34:28 <augur> jmcarthur: {X} x (XxX -> 2) is perfectly well and good as a product. maybe its problematic and leads to russels paradox if you have a type system that lets that happen, i dont know
20:34:45 <augur> jmcarthur: no, i dont, i have  {X}. {X} ~= Set-of-all-Sets
20:34:48 <jmcarthur> augur: which leads into what ddarius is saying about fst being useless
20:35:18 <augur> ddarius: fair enough. let me rephrase that
20:35:30 <augur> ddarius: write a function f : forall X. X -> Poset X -> Bool
20:35:40 <jmcarthur> that's the same thing
20:35:48 <ddarius> jmcarthur: Not quite.
20:36:17 <ddarius> augur: f X x (_, g) = any X (`g` x)
20:36:37 <augur> ddarius: or, as it were, f x (X,g) = any X (`g` x)
20:37:01 <augur> tho obviously in agda land it would indeed be what you just said
20:37:55 <ddarius> augur: My point is, whatever you ask me to produce, it either can't be done at all, or you will already have told me X or I know it (with or without {X}).
20:38:05 <ddarius> I'll never need you {X}.
20:38:07 <jmcarthur> if you weren't wanting to talk about types you shouldn't have mentioned agda in the beginning
20:38:09 <ddarius> s/you/your
20:38:45 <jmcarthur> we both agree that type theory and set theory are quite different, after all ;)
20:38:52 <ddarius> Which is what I said earlier.  The only way to use the type {X} is to already know X.
20:39:17 <augur> sure, if we throw in the explicit argument, but half the point was to make this the explicit argument. tho i see your point and i _probably_ want to revise my conception of treating Poset and similar things as type operators
20:39:39 <augur> jmcarthur: depends on the type theory!
20:39:53 <jmcarthur> alright, but agda's type theory at least
20:39:58 <augur> byorgey: beep boop
20:40:17 <augur> byorgey: any good reading for inhabitant enumeration?
20:41:07 <augur> its become oddly relevant in the last few days
20:42:36 <ddarius> My work laptop is thrashing.
20:44:31 <joe6> jmcarthur, do you have a few minutes to add any suggestions to some agda code?
20:45:27 <joe6> jmcarthur, i converted a haskell program to agda. But, I want to add more agda-specific functionality..
20:54:19 <jiao> Hi, I have a question. If I want to write the Game of Life, should I use MonadState? I found that if I use Gtk to display and there are two handlers, one is used to update the body every 100ms, the other is an expose handler which is for draw the body.
20:56:18 <jiao> Should I use MonadState to write this kind of program?
20:56:51 <augur> ddarius: i suppose you could parameterize as Poset X = Sigma (Y : Setof X) YxY -> 2, at least so you could say f : X -> Poset X -> Bool
20:57:45 <augur> otherwise you'd have a funny time giving a type for the min function
20:58:08 <augur> but obviously this would be quite different from what i suggested
20:58:27 <augur> byorgey: wake up you bastard
21:01:43 <augur> byorgey: well, when you start responding to things, lemme know if there are any set rules to enumeration of lambda inhabitants, especially when some type information is known.
21:11:05 <ddarius> If "Setof X" is just a different notation for "{X}" that changes little.
21:17:02 * ddarius is being foiled by the stupidest error ever.
21:51:31 <pastorn> BONUS: saw your book on reddit now - you weren't able to print it in color?
21:52:51 <Peaker> GHC 7 error: "Could not deduce (a ~ ()) from the context (Show a, Ord a)" seems to be worse than GHC 6.12 errors?
21:57:14 <ddarius> pastorn: How's he supposed to get web traffic if you can get everything from the site from a book?
22:02:31 * hackagebot yackage 0.1.0.1 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.1.0.1 (MichaelSnoyman)
22:04:02 <dankna> ddarius: cracked up when I saw that comment, thank you
22:16:55 <roconnor> > maxBound :: Word32
22:16:55 <lambdabot>   4294967295
22:20:22 <pastorn> ddarius: heh :)
22:26:26 <liyang> Is there a searchable heap implementation out there somewhere? The three [ph]ackages I've seen don't expose anything for O(log n) searches.
22:38:50 <shapr> > maxBound :: Word64
22:38:51 <lambdabot>   18446744073709551615
22:42:35 * hackagebot hakyll 3.0.2.0 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.2.0 (JasperVanDerJeugt)
22:47:50 <liyang> > maxBound :: Int
22:47:50 <lambdabot>   9223372036854775807
22:58:56 <roconnor> > ord 'E'
22:58:56 <lambdabot>   69
22:59:32 <roconnor> > length "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"
22:59:33 <lambdabot>   69
23:00:08 <roconnor> liyang: there are a couple priority search queue structures.
23:00:11 <roconnor> PSQueue
23:00:17 <roconnor> is that what you are talking about?
23:41:26 <liyang> roconnor: Hm... I'd like to be able to look up some collection of non-overlapping ranges/segments (of a spline), and be able to pick out the one that contains a particular point. Trying to see if I can use any of those to do the search in log-time. :-/
23:42:11 <liyang> (Currently they're in an IArray and I'm hand-rolling a binary search.)
23:59:37 <ketil> Can anybody tell me how to watch the SPJ talk on parallel programming?  It's apparently on vimeo, and after crashing both FF and Chromium, I've finally managed to get to a page insisting this video is private, and I need to log in...
