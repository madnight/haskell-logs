00:15:59 <t_branden> Hey all, I recently watched the MIT 6.001 lectures (Structure and Interpretation of Computer Programs) and it really piqued my interest in functional languages.  I'm decently experienced in imperative languages like C/C++, but I really want to get my feet wet with Haskell.  What are the best resources available?  I'm thinking about the Channel 9 lecture series and LYAH, but are there other 
00:15:59 <t_branden> things I might be overlooking?  
00:17:10 <ehamberg> t_branden: lyah is a great start.
00:17:30 <ehamberg> there's even a dead tree version coming out this month if you prefer that.
00:18:04 <ehamberg> also, see http://haskell.org/haskellwiki/Learning_Haskell
00:18:17 <zenzike> @lyah
00:18:31 <t_branden> I think the online version is actually looking pretty appealing, but I have a pdf version as well laying around.  I just have a bit of free time over my spring break, so I decided what better time to blow my mind?  I'll check out your link.  Thank you.
00:19:24 <MasseR> How come cabal-install tries to reinstall (to --user) libraries that are already installed globally?
00:24:03 <blueonyx> why doesnt Learning_Haskell wikipage mention real world haskell?
00:26:05 <blueonyx> t_branden: http://book.realworldhaskell.org/ is also great
00:26:28 <levifikri> hi
00:26:36 <levifikri> can help on this indentation problem? https://gist.github.com/848860
00:27:00 <levifikri> I tried different combination, but still didn't successfully compile
00:27:40 <t_branden> Thank you =)  I saw "Write Yourself a Scheme in 48 Hours".  I assume that's just implementing all the constructs/syntax of a Scheme dialect on top of Haskell? 
00:28:35 <blueonyx> levifikri: you want to either use an "in" clause where you use a, or forgot the "do" after "test =" if you write a IO action 
00:29:17 <levifikri> blueonyx I added do after test =, but still compile error
00:30:00 <blueonyx> levifikri: what do you want to accomplish?
00:30:08 <levifikri> https://gist.github.com/848860
00:30:47 <levifikri> I want to do something complex, but got that problem. So I replicate the problem using simple case
00:31:12 <levifikri> updated -> https://gist.github.com/848860
00:31:13 <blueonyx> ah, maybe you have to indent the if/then/else 2 or more spaces more
00:32:10 <levifikri> you meant like this https://gist.github.com/848860 ? (updated, but still error)
00:32:32 <blueonyx> what's the error?
00:33:17 <levifikri> parse error, possibly incorrect indentation
00:33:25 <blueonyx> how about: https://gist.github.com/d6d3f9a7b83c946e528f
00:33:33 <levifikri> at line 4
00:33:56 <blueonyx> incorrect indentation :)
00:36:29 <levifikri> so, does it mean I should always put all statements on the right side of = sign?
00:39:11 <blueonyx> no but you have to indent it at least as wide as the left side
02:22:14 <Ptival> :t (>>=)
02:23:48 <Jafet> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:27:46 <Ptival> thanks Jafet ^^
03:38:45 <frank00> I'm havin some Char (1,2..8) and I would like to convert them in 'a', 'b', 'c' etc. mychar + number gives error, so I'm  converting back and from Int. Is there an easier way to achieve that?
03:39:27 <Botje> toEnum (fromEnum char + number)
03:53:09 <frank00> thanks
03:58:56 <Botje> this does essentially the same thing, mind you :P
04:02:43 <frank00> :P no worries
04:21:26 <lpsmith> is there a convenient way of atomically creating a file or directory with a given set of permissions?
04:22:33 <Jafet> posix has open and mkdir.
04:25:40 <Jafet> Hrm, Posix doesn't have mkdir.
04:26:17 <lpsmith> it does,  Posix is oddly organized,  and sometimes the names are permuted
04:26:20 <lpsmith> thanks Jafet
04:26:54 <lpsmith> try System.Posix.Directory.createDirectory
04:29:32 <jaj> Jafet: of course POSIX has mkdir
04:29:55 <Jafet> Sure, but Posix doesn't. Actually, it doesn't have open either, but has something called createFile.
04:30:07 <jaj> ah ok System.Posix
04:30:12 <Jafet> @hoogle FilePath -> FileMode -> IO a
04:30:32 * Jafet slaps lambdabot for not being here
05:01:27 <maiqkl> What would be a concise definition of what an expression is in haskell? Would it be correct to say that a function is an expression, but one with parameters? 
05:02:11 <sipa> a function is an expression of type (a -> b)
05:02:53 <DevHC> 5 is also a function (taking 0 arguments) :)
05:03:19 <DevHC> #include <appropriate_terminology.h>
05:03:36 <Jafet> In haskell, all functions take one argument, so 5 isn't a function, unless you made it one by using something horrific like vector-spaces
05:04:22 <kfr> I have a record with like 40 entries - that doesn't really work in Haskell, does it?
05:04:41 <Jafet> It works in haskell, but might not work for the programmer
05:04:47 <maiqkl> So what is the distinction between expressions and functions?
05:04:52 <Jafet> What doesn't work for you?
05:04:59 <kfr> Jafet: Construction
05:05:00 <hpc> an expression is something that can be used as a value
05:05:02 <maiqkl> Is there even one?
05:05:02 <hpc> in any language
05:05:13 <hpc> a function is a subset of values, and so a subset of expressions
05:05:26 <Jafet> kfr: well, you can make a few basic values and customize them with record accessors
05:05:40 <Jafet> Or make functions with reduced parameters that save typing
05:05:44 <hpc> (in other languages, like java, functions are not values)
05:06:52 <Jafet> I would think that deconstruction is the finicky bit
05:06:52 <maiqkl> So an expression is just the assertion of a truth?
05:07:06 <sipa> no, an expression is something that evaluates to a value
05:07:16 <sipa> 5 is an expression
05:07:23 <sipa> putStr is an expression
05:07:23 <hpc> 5+5 is an expression
05:07:29 <sipa> putStr "bla" is an expression
05:07:32 <DevHC> Jafet: u probably missed my "#include <appropriate_terminology.h>" terminology comment
05:07:34 <hpc> \x -> 5 + 5 - x is an expression
05:07:56 <maiqkl> I'll rephrase that , so on expression is just something that asserts a value?
05:08:02 <Jafet> DevHC: no, I *am* appropriate_terminology.h
05:08:07 <hpc> let x = 5 in x is an expression
05:08:20 <DevHC> Jafet: u don't get it
05:08:43 <DevHC> Jafet: in OUR terminology, say that 5 is a function of 0 arity
05:08:49 <hpc> if you were really #include-ing that header...
05:08:55 <sipa> DevHC: tell me, what arity does id have?
05:08:57 <hpc> wouldn't you be spamming the channel with dictionary text?
05:09:10 <hpc> or does the log have to be preprocessed first?
05:09:26 <DevHC> sipa: 1
05:09:31 <Jafet> hpc: I'm smart enough to avoid those things
05:09:36 <hpc> :D
05:09:49 <sipa> > id (const 5) 3
05:09:58 <Jafet> 5
05:10:02 <hpc> hehe
05:10:07 <hpc> > id 5 3
05:10:11 <hpc> 5
05:10:12 <hpc> :D
05:10:14 <DevHC> lol
05:10:18 <sipa> DevHC: looks like arity 2 to me
05:10:29 <DevHC> u're being deceived
05:10:38 * sipa doesn't know u
05:10:49 <hpc> y u no use full english words?!
05:10:51 <hpc> :P
05:10:52 <DevHC> maybe it's cuz .. there is NO U
05:10:56 <DevHC> ya hear me?
05:10:57 <DevHC> NO U
05:11:38 <sipa> DevHC: just trying to point out that your definition of "arity" is not always clearly definable
05:11:57 <DevHC> not mine btw
05:12:09 <sipa> i know
05:12:17 <McManiaC> how do you put inline code in haddock documentary?
05:12:21 <hpc> anyhoo, maiqkl: something is an expression if you can copy it wholesale and do things like
05:12:26 <hpc> > id (some big long expression)
05:12:33 <hpc> is the general rule
05:15:36 <DevHC> well, i don't see why we can't say that id :: a -> a has an arity of 1, and id :: (a -> b) -> (a -> b) has an arity of 2
05:17:48 <hpc> DevHC: the useful definition of arity considers id to be (a -> b) -> a -> b
05:18:22 <DevHC> ?
05:18:52 <sipa> DevHC: because (a -> b) -> (a -> b) is the same thing as (a -> b) -> a -> b
05:19:03 <hpc> actually, here's a formal definition of arity
05:19:09 <DevHC> yes it is
05:19:12 <hpc> let X = some type that doesn't include (->)
05:19:16 <DevHC> hence the question mark above
05:19:20 <hpc> x -> X has arity 1
05:19:28 <hpc> x -> y has arity 1+(arity y)
05:22:10 <DevHC> hpc: so what r u saying?
05:25:26 <xplat> as a consequence of that definition, every function type whose ->-spine ends with a variable (like a -> a, or (a -> b) -> a -> b) has every arity above some minimum
05:25:37 <xplat> so id has arity 1,2,3,4,5,6,7...
05:26:20 <Jafet> I thought arity was a property of syntax
05:26:27 <xplat> something like Int -> Int -> Int, however, has just one arity (in this case, 2)
05:26:53 <Jafet> For example, all operators are binary
05:26:58 <Jafet> Except for that other one
05:27:16 <xplat> Jafet: that's another form of arity, but it's pretty uninteresting in haskell, so we don't talk about it much
05:27:51 <sipa> well, arity as a property of polymorphic types is either 0 or 1 in haskell
05:27:55 <theorbtwo> Well, something of type a->a where a is (b->c) has type (b->c) -> (b->c), which is still airity 1, right?
05:28:25 <DevHC> no :P
05:28:35 <theorbtwo> Oh.  No, because that's eqivelent to (b->c)->b->c.
05:28:55 <xplat> syntactic arity in haskell is always 0 or 2, the simple form of semantic arity is always 1, so we tend to talk about the involved form of semantic arity
05:29:24 <xplat> *0 or 1
05:29:53 <Jafet> If you want to define it that way, you can say it's one less than the number of things in the type, where the thing after the last arrow is not a function
05:31:24 <xplat> but arrows in parens don't count if the type would parse differently without the parens
05:32:37 <sipa> i'd say you have two definitions: one, for polymorphically typed expressions which is always 0 or 1, and another one which is only definable for monomorphically types ones, which can be any natural number
05:33:11 <xplat> (the last arrow outside necessary parens can be different from the last arrow when type constructors other than -> are involved ... and even that's not quite right if some of them are operator-y and have lower precedence than ->)
05:33:57 <xplat> sipa: undefined can have arity both 0 and 1 even in the 0/1 definition
05:34:08 <hpc> xplat: so a definition could be "the number of arrows in the spine of the value"
05:34:18 <hpc> which would resolve that issue
05:34:20 <sipa> xplat: so, the arity of undefined is undefined :)
05:34:46 <xplat> hpc: i'd say 'the right ->-spine of the type', but i think you have the idea
05:36:24 <xplat> sipa: the only thing that makes undefined unique here is that it's atomic and available in any context
05:36:44 <sipa> yes, you're right
05:37:05 <xplat> there are plenty of other examples, like (error "boom!") and the second x in \x -> x
05:37:45 <sipa> and if you have instances over function types, polymorphic types may tell you even less about whether something will be instanciated to a function type or not
05:38:27 <xplat> it's the nature of instances that you can never be sure one is absent except in whole-program analysis
05:38:58 <xplat> someone could always add another
05:39:04 <sipa> yes, open world 
05:39:46 <sipa> but if instances can not be made over function types, something of type (forall x. Show x => x) will never be a function type
05:40:25 <xplat> well, yes, but this is haskell, and instances over function types are allowed even in haskell98
05:40:36 <sipa> really?
05:40:58 <xplat> yes
05:41:53 <xplat> Reader and ReaderT are just there to avoid confusion
05:41:59 <frank00> I am using getChar and getLine to read IO. Is there a getInt?
05:42:11 <sipa> :t read
05:42:37 <xplat> lambdabot is still awol?
05:43:04 <saml> frank00, use read
05:43:14 <saml> l <- getLine;  read l
05:43:18 <saml> let i = read l
05:43:33 <saml> > read "23432" :: Int
05:43:47 <sipa> 23432
05:43:58 <xplat> do { l <- getLine; return (read l :: Int) }
05:44:04 <saml> Syntax Error!
05:44:28 <frank00> ohh I see, I was misusing ::
05:44:30 <frank00> thanks
05:45:28 <xplat> frank00: btw, the :: doesn't cast anything, it just disambiguates which overload of 'read' to use
05:58:10 <frank00> mhhh, I think I need to flush a putStr (if that's even applicable to Haskell). Do you know how to do so?
06:00:46 <Jafet> hFlush
06:00:57 <frank00> thankee
06:08:01 <hpaste> Bambooo pasted "Compiz and fluxbox"  http://hpaste.org/44412
06:11:24 <frank00> thanks Jafet 
06:12:15 <Jafet> compiz is for little kids
06:20:38 <kfr> I have an IO a and an IO [a]
06:20:55 <kfr> I basically want to : those, yielding an IO [a]
06:21:14 <kfr> What should I use for that?
06:21:48 <Jafet> liftM (:)
06:21:55 <kfr> Ah, thanks
06:21:57 <Jafet> liftM2, rather
06:22:54 <roconnor> also (:) <$> h <*> t will work if you import Control.Applicative
06:23:11 <roconnor> liftM2 (:) is probably easier though
06:37:56 <copumpkin>  (| h : t |) will work if you have SHE
06:38:54 <zenzike> surely that should be phrased: if SHE is present ...
06:42:57 <copumpkin> :)
06:43:05 <paolino> hi, what is marking a package as broken inside ghc package database ?
06:43:12 <frank00> randomRIO (1, 8) :: Int <-- I'd like it to give me a random Int, but there's a type mismatch if I use that... hints?
06:43:39 <copumpkin> frank00: it gives you an action that returns an int
06:43:43 <copumpkin> you need to use it in a do block
06:43:51 <copumpkin> x <- randomRIO (1, 8)
06:43:55 <copumpkin> now x will contain a random int
06:44:05 <copumpkin> (also, why the hell does it take a pair?)
06:44:07 <frank00> ahhh, sure, not to mix stuff with nasty stuff
06:44:23 <frank00> it's a constructor copumpkin 
06:44:25 <saml> you want pure random number generator?
06:44:25 <paolino> the range
06:44:33 <saml> pure functional random number
06:44:45 <copumpkin> frank00: I know what it does, but not why they made it take a pair instead of the two numbers separately
06:44:57 <saml> is it possible to have a function that spits out random number purely?
06:45:03 <saml> merssein twisteR?
06:45:08 <copumpkin> saml: sure, since numbers aren't really random
06:45:11 <frank00> oh, don't ask me ;) I'm nobish :P
06:45:28 <saml> yah number are chaotic 
06:47:12 <zenzike> copumpkin: is there a good reason for it not to take a pair?
06:47:28 <frank00> I feel vey silly having put randomness into a function 
06:47:32 <saml> > let rand seed = seed + 1
06:47:37 <copumpkin> zenzike: curried functions are easier to use
06:47:43 <copumpkin> they "fit" in more places
06:48:02 <saml> so in boomerang there is lens. can random number function built using lenses?
06:48:13 <zenzike> copumpkin: intuitively I tend to write things curried because you can partially apply them, but I'm not sure it's always best
06:48:48 <zenzike> I was just wondering if you had a good reason in this case :-)
06:49:47 <copumpkin> zenzike: pairs are icky :P
06:49:51 <copumpkin> good enough?
06:49:52 <zenzike> :-)
06:50:07 <paolino> the range should be a data, probably
06:54:12 <DevHC> to me, the ickyness about curryable functions is that the inventor of the function might have a different opinion about which argument should go first
06:55:01 <DevHC> often, the order is "well" decided, like in map (where u specify the function first, and then the list)
06:55:13 <zenzike> DevHC: but isn't that the same problem whether you use pairs or not?
06:56:39 <EvanR> DevHC: flip or rename it
06:56:42 <EvanR> mapM vs forM
06:56:44 <DevHC> but for example, one might want to reverse the arguments to the replicate function, and have something like: spaces = replicate ' ', where replicate = Prelude.replicate
06:57:20 <DevHC> EvanR: yes, my point is that i have to flip it or rename it.
06:57:41 <EvanR> as opposed to what
06:57:52 <sipa> DevHC: well, the alternative is that you can't curry at all
06:57:59 <sipa> which is not a problem, just an inconvenience
06:58:27 <DevHC> zenzike: no, because in case of pairs, u r forced to specify partial application manually, like \z -> f (z,1337) or \z -> z (1337,z)
06:59:18 <DevHC> ofc currying is better than no currying at all, but i've just named something which is not so epic
06:59:49 <sipa> but remove currying, and you gain nothing
07:00:07 <DevHC> i have a feeling taht u r repeating me
07:00:08 <sipa> you'd just have to specify all arguments always
07:00:11 <sipa> ok
07:02:05 <DevHC> in some language (python?) there's a feature called something like "named arguments", where u give arguments to a function like so: f(left = 1337, right = 42), or: map(func = f, list = [1,2,3])
07:02:39 <DevHC> there the naming matters, not the order in which the named arguments occur
07:03:26 <DevHC> and it could be convenient if, for functions taking lots of arguments, u could "curry" by specifying not all named arguments
07:03:28 <frank00> gahhh, when I try to use RandomRIO it says: "Couldn't match expected type `Int' against inferred type `IO t' In a stmt of a 'do' expression: a <- randomRIO (1, 8) :: Int"
07:03:33 <DevHC> EvanR^
07:03:51 <DevHC> ya know
07:04:11 <kosmikus> frank00: should be "IO Int"
07:04:49 <frank00> you mean, after the :: kosmikus ?
07:04:51 <DevHC> i've been thinking about a new syntax where _ can be used as a placeholder for arguments
07:04:54 <kosmikus> frank00: yes
07:04:55 <DevHC> consider something like:
07:05:05 <EvanR> DevHC: named arguments just increases teh size of the code for disproportionate probability of cases
07:05:26 <EvanR> its about how often 'would this feature be nice' vs how much room does it take up
07:05:41 <EvanR> or how much complexity to add to a syntax
07:05:42 <kosmikus> DevHC: you can simulate something similar to named arguments with Haskell record types, if you really want it. not the partial application, though.
07:06:17 <frank00> kosmikus: thanks! that did it! But may I ask you why?
07:06:33 <kosmikus> @type randomRIO
07:06:41 <frank00> kosmikus: thanks! that did it! But may I ask you why?
07:06:46 <frank00> woops sorry wrong chat
07:07:02 <kosmikus> no bot?
07:07:12 <frank00> IO a
07:07:22 <frank00> ohhhhhhh
07:07:28 <frank00> like Maybe a
07:07:31 <frank00> silly me
07:07:37 <kosmikus> frank00: you're annotating the expression "randomRIO (1, 8)"
07:07:48 <kosmikus> frank00: and its type is "IO Int", not "Int"
07:08:08 <DevHC> EvanR: i didn't think about that in detail, but since GHC contains a shit load of syntactical extensions, i guess that yet another extension can be included without much cruft
07:08:30 <DevHC> ...so about the _ placeholder syntax, consider:
07:08:40 <DevHC> wrapInParens s = "(" ++ s ++ ")"
07:08:43 <EvanR> DevHC: true
07:08:48 <DevHC> is kind of fugly. new syntax:
07:08:49 <fryguybob> frank00: The type annotation in the do block applies to the expression to the right of the "<-".
07:08:58 <DevHC> wrapInParens = "(" ++ _ ++ ")"
07:09:25 <DevHC> then, basically:
07:09:29 <frank00> thanks kosmikus and fryguybob 
07:09:52 <DevHC> f x = g _ _ _ _ _ _ _ _ _ x _ _ _ _
07:10:13 <DevHC> which basically binds the Nth argument of g (N = ... i didn't count)
07:10:32 <Silex> looks like linux rights
07:11:24 <hpaste> Jz pasted "3A. \1050\1088\1072\1090\1095\1072\1081\1096\1080\1081 \1087\1091\1090\1100...  http://hpaste.org/44413
07:11:33 <DevHC> unfortunately _ is used in matching syntax, notably lambda expressions, and just using _ to mean "surround the code with "\x -> (" and ")", is asking for ambiguity
07:11:46 <DevHC> +"
07:12:26 <kosmikus> DevHC: not only syntactic ambiguity. where should the lambdas be inserted?
07:12:58 <DevHC> yeah that should be noted as well
07:13:50 <DevHC> how about: (\\ <any _ u write here is subject to lambdaization> )
07:15:08 <DevHC> obviously that would imply that u can't use, for example, (\(1,_) -> "ok") inside there with the obvious meaning...
07:15:51 <kosmikus> DevHC: note that there's http://hackage.haskell.org/trac/haskell-prime/wiki/FlexiblePartialApplication
07:16:02 <kosmikus> DevHC: which in turn mentions a GHC ticket
07:16:34 <DevHC> :O
07:16:38 <DevHC> someone beat me to it
07:19:30 <DevHC> lol, Milestone _|_
07:21:05 <DevHC> ofc that mentions only partial application, whereas in thought about extended uses, like that paren wrapper function: "(" ++ _ ++ ")"
07:26:10 <frank00> in a "do" part, is there a way to terminate the program (like error, just a non exceptional quit)
07:27:04 * hackagebot ghci-diagrams 0.1.1 - Display simple diagrams from ghci  http://hackage.haskell.org/package/ghci-diagrams-0.1.1 (PeterDivianszky)
07:27:19 <Botje> @hoogle exitWith
07:27:24 <Botje> uh. right
07:27:36 <Botje> frank00: look at the System.Exit package
07:27:41 <frank00> thanks
07:31:54 <Younder> Ho mathematically sound is 'do'? I fail to connect it to the category theory notion of monad.
07:32:01 <Younder> How
07:32:59 <Younder> It seems more closely related to sequence.
07:33:29 <pumpkin> Younder: it desugars trivially into a sequence of >>=
07:33:35 <pumpkin> which is directly related to the categorical join
07:33:53 <Younder> aah
07:34:17 <Jesin> join m = m >>= id
07:34:19 <Jesin> m >>= f = join (fmap f m)
07:34:59 <Jesin> fmap f m = m >>= return . f
07:35:55 <Jesin> ^ fmap in terms of {return, (>>=)}; (>>=) in terms of {fmap, return, join}
07:36:12 <Jesin> :p
07:36:35 <Jesin> oh
07:36:46 <Jesin> [11:08:29]	<pumpkin>	Younder: it desugars trivially into a sequence of >>=
07:36:49 <Jesin> as for the desugaring
07:36:54 <Jesin> there's a thing for that
07:37:42 <Jesin> @undo do { a <- ma; b <- mb; c <- mc; return (a b c) }
07:37:51 <Jesin> ...
07:37:57 * Jesin pokes lambdabot
07:38:08 <Jesin> what
07:38:21 <Jesin> pumpkin
07:38:23 <Jesin> guys
07:38:27 <Jesin> why's lambdabot gone :(
07:38:33 <reynard> hello, I am reading about category theory in order to understand monad.  Basically, I know what a 'category' is, I understand 'functor', I can understand natural transformation 'eta' and eta(y).F(f) = G(f).eta(x).  When I get into the topic of Monad, it is noted that a Monad is an endofunctor with two natural transformations, 'unit' and 'mu'.  I know that a monad is a composition of two adjoint functor, so it is an e
07:38:34 <reynard> ndofunctor.  However, I do not understand how and why the 'unit' and 'mu' integrate into the entire picture.  Can anyone advise how I can proceed?  Many thanks.
07:41:28 <Jesin> *sigh*
07:41:48 <Jesin> Actually, I wanted to ask
07:43:11 <Jesin> is there any difference between using the UNPACK pragma on a "data" declaration with one constructor and one field
07:43:18 <Jesin> and simply using the 
07:43:25 <Jesin> "newtype" keyword instead?
07:43:34 <Jesin> :p
07:43:59 <Saizan> yes
07:45:03 <tab> Jesin: the unpack is just going to pack the field with the constructor, whereas with the newtype the constructor is not stored.
07:45:11 <roconnor> reynard: say you have two adjoint functors F -| G
07:45:46 <roconnor> reynard: that means you have a function unit : 1 => GF and a counit : FG => 1
07:45:57 <kfr> do { contents <- readFile path; return $ Just contents } -- how do you undo this with =<<?
07:46:05 <roconnor> reynard: the monad is the composition GF
07:46:19 <roconnor> reynard: and the unit of the monad is that unit natural transformation 1 => GF
07:46:30 <Jesin> hm, ok
07:46:48 <Saizan> kfr: do { x <- m; ..} == m >>= \x -> ..
07:46:50 <roconnor> reynard: the join natural transformation nees to have type GFGF => GF
07:46:55 <Jesin> tab: so this also means there is no point in using UNPACK with newtype?
07:47:11 <tab> Jesin: i don't think you can use unpack with newtype anyway
07:47:18 <Jesin> hm, ok
07:47:23 <Younder> counit = co-unit?
07:47:30 <Jesin> also, I don't suppose this makes sense?
07:47:34 <Philonous1> kfr: mechanically readFile >>= \x -> (return $ Just x), or better readFile >>= return.Just, even better: Just `liftM` readFile
07:47:38 <roconnor> reynard: but that can be built from lifting counit:  fmap_G counit : GFG => G1
07:47:41 <Jesin> newtype T a = T !a
07:47:56 <Jesin> (using strict fields with newtypes, I mean.  :p )
07:47:56 <Younder> 1^C
07:48:03 <reynard> roconnor: am trying to digest it, many thanks.
07:48:06 <roconnor> reynard: so as a special case of fmap_G counit we have GFGF => G1F
07:48:19 <roconnor> and G1F = GF
07:48:25 <tab> Jesin: you should try, but i think it does make sense
07:48:45 <tab> Jesin: i.e. forcing the evaluation of the field
07:49:14 <Younder> bijectiveness makes things a lot easier
07:49:28 <Younder> sigh
07:49:57 <Saizan> tab: you'd end up with T x meaning x `seq` x at runtime, which is completely redundant
07:50:06 <kfr> (liftM Just readFile) path?
07:50:22 <Saizan> no, liftM Just (readFile path)
07:50:51 <kfr> Ah
07:51:31 <kfr> Thanks, it works
07:52:01 <Philonous1> AH, oh, sorry, you could also have (liftM Just . readFile) path (if you want to eta-reduce path
07:54:08 <tab> Saizan: hm yes indeed
07:54:10 <Jesin> *sigh*  I keep getting annoyed by little things in the standard library like
07:54:13 <Jesin> instance Applicative Maybe where
07:54:15 <Jesin>         pure = return
07:54:16 <Jesin>         (<*>) = ap
07:54:29 <roconnor> why is that annoying?
07:54:44 <Jesin> ap = liftM2 id
07:55:19 <Saizan> ?
07:55:28 <Jesin> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:55:33 <Jesin> it seems like too much indirection
07:55:38 <Jesin> when it's so easy to just write
07:55:41 <Jesin> instance Applicative Maybe where
07:55:43 <Jesin> 	pure = Just
07:55:44 <Jesin> 	(Just f) <*> (Just x) = Just (f x)
07:55:46 <Jesin> 	_ <*> _ = Nothing
07:55:53 <roconnor> Jesin: it is call composability
07:56:35 <Philonous1> Jesin: It's reinsurance that Maybe's Applicative and Monad instances are compatible
07:56:53 <Jesin> well
07:57:10 <Jesin> instance  Functor Maybe  where
07:57:12 <Jesin>     fmap _ Nothing       = Nothing
07:57:13 <Jesin>     fmap f (Just a)      = Just (f a)
07:57:15 <Jesin> ^ they do that
07:57:16 <Jesin> instead of fmap = liftM
07:57:19 <roconnor> Jesin: your definition breaks an abstraction barrier on the representation of Maybe
07:57:48 * roconnor would be inclined to define fmap = liftM
07:57:55 <Saizan> remember that Functor was there before Applicative, btw :)
07:58:11 <Jesin> Maybe is very simple, I don't see its Applicative or Monad instances changing
07:58:21 <roconnor> Jesin: I admit they are inconsistant.  Likely due to historical reasons
07:58:41 <Jesin> hmm
07:58:42 <Jesin> [11:32:19]	<roconnor>	Jesin: your definition breaks an abstraction barrier on the representation of Maybe
07:58:44 <Jesin> well
07:58:50 <roconnor> (I mean they are inconsistent as to whether they reuse code or not)
07:58:52 <Jesin> (<*), (*>), and (>>)
07:59:02 <Jesin> are in their respective typeclasses
07:59:12 <roconnor> yes
07:59:22 <Jesin> because in some cases there are more efficient implementations of those than the default
07:59:57 <roconnor> Jesin: What makes you think you can make more efficent implementations of those than the compiler will?
08:00:08 <Jesin> well
08:00:10 <Jesin> this, for one thing
08:00:21 <Jesin> hmm, I should use hpaste
08:01:32 <Jesin> http://hpaste.org/44416/the_search_monad_is_an_example
08:01:35 <Jesin> :p
08:01:46 <hpaste> Jesin pasted "the search monad is an example"  http://hpaste.org/44416
08:02:37 <Jesin> roconnor: I doubt the compiler will recognize that for me?
08:02:38 <Jesin> :p
08:02:49 <roconnor> Jesin: recoginize what?
08:03:09 <Jesin> x <* _ = x
08:03:14 <Jesin> _ *> y = y
08:03:27 <timcowlishaw> ls
08:03:32 <Jesin> lol
08:04:41 <Jesin> eh, I recognize those actually have different semantics, and my complaints about "Maybe" could probably be optimized out by the compiler
08:04:44 <frank00> yay! I've finished my first dumb program! I would like to post it somewhere (it's not long, less than 100 lines) to get some minireview in my style (aka the errors which I should eradicate). Do you think that's suitable for "beginner" mailing list?
08:05:05 <Jesin> are they generally optimized out like that, though?
08:05:22 <Jesin> I'm not quite sure exactly how aggressive GHC is with inlining in what conditions
08:05:35 <zygoloid> frank00: if you want people here to look at it, you can post it at hpaste.org
08:07:19 <Jesin> roconnor: you were asking about (<*), (*>), and (>>), though
08:07:19 <roconnor> Jesin: let me try
08:07:22 <Jesin> is that a good example?
08:07:34 <Jesin> hm.
08:08:43 <hpaste> Frank00 pasted "first program"  http://hpaste.org/44417
08:09:07 <Jesin> btw, those definitions have different semantics than the default in that, for example, _|_ *> y is not _|_
08:09:31 <Jesin> I may have been hasty in defining those like that
08:09:52 <Jesin> because of course I had a particular use of that monad in mind when I defined those
08:11:02 <freedrull> are the *ed schemer books good reads, even if you arn't particularly interested in learning any form of lisp?
08:11:09 <frank00> there zygoloid  ( and thanks for the tip ). It's a simple program for blindfold chess training
08:11:58 <roconnor> @botsnack
08:11:58 <Jesin> and I haven't formally verified that my definitions of (*>) and (<*) are strictly more defined and always produce extensionally equivalent results otherwise.
08:12:16 <fryguybob> frank00: Be sure you look at the hlint hints at the bottom of the paste.
08:12:21 <roconnor> Jesin: I need lambdabot
08:12:29 <CosmicRay> yes, MegaMonad was mine, to whoever was asking yesterday ;-)
08:12:34 <frank00> I am fryguybob :P
08:12:40 <Jesin> what happened to lambdabot?  :(
08:13:19 <roconnor> find I'll simplify by hand
08:13:22 <roconnor> *fine
08:13:24 <fryguybob> frank00: An easier way to "exit" innerCycle would be to not recurse when you want to exit.
08:13:41 <Jesin> I don't really know how to use lambdabot that well
08:13:47 <Jesin> I didn't know it could do that
08:13:59 <Jesin> except @pl, @undo, and @unpl
08:14:14 <roconnor> Well x <* y is clearly equal to (\m f p -> (f $ m $ \x -> p $ (f x) p) p) (\p -> const $ x $ p . const) (\a p -> (a $ y $ \x -> p $ (a x) p) p) by expanding your definitions
08:14:30 <frank00> fryguybob: you mean, put the recursion in the "else" block?
08:14:31 <roconnor> the question is does that immediately reduce to x
08:14:41 <roconnor> and I presume the answer is yes
08:14:57 <Jesin> hmm
08:15:06 <Jesin> listToFindspace xs = Findspace (findInList xs) where
08:15:07 <Jesin> 	findInList [x] _ = x
08:15:09 <Jesin> 	findInList (x:xs) p = if p x then x else findInList xs p
08:15:13 <frank00> because if I do that it gives me error fryguybob 
08:15:20 <Jesin> elemBy eq x (y:ys) = eq x y || elemBy eq x ys
08:15:22 <Jesin> elemBy _ _ [] = False
08:15:23 <Jesin> findspaceToListBy eq (Findspace fnd) = listem [] where
08:15:25 <Jesin> 	listem xs = let x = fnd (\x -> not $ elemBy eq x xs)
08:15:26 <Jesin> 	  in if elemBy eq x xs then [] else x : listem (x:xs)
08:15:27 <roconnor> and I expect GHC to be able to determine that, and your definiton of x <* _ = x is simply an error prone definition that the compiler would infer anyways from the default definition
08:15:46 <Jesin> no, I think they actually have different semantics
08:15:50 <Jesin> hmm
08:15:55 <Jesin> meh.
08:16:00 <Jesin> I'm really not sure.
08:16:16 <Jesin> I should learn more about what reductions the compiler does.
08:16:37 <fryguybob> frank00: I'll paste and example, just a second.
08:16:58 <Jesin> I also expanded ap into
08:17:02 <Jesin> 	m1 <*> m2 = Findspace $ \p ->
08:17:04 <Jesin> 		let f = runFind m1 $ \g -> p $ g $ runFind m2 (p . g)
08:17:05 <Jesin> 		 in f $ runFind m2 $ p . f
08:17:30 <Jesin> just to see what it looked like
08:18:16 <Jesin> ...gah, 11:53
08:18:18 <Jesin> I have to go
08:18:24 <Jesin> bbl I think
08:20:39 <fryguybob> frank00: http://hpaste.org/paste/44417/first_program_annotation#p44418
08:22:07 <fryguybob> frank00: Another note, while type inference is very useful you often get clearer error messages when you have type annotations at the top level.
08:23:46 <frank00> ohh that way for the if, thanks fryguybob. Where should I move the types? befor main, right?
08:24:41 <Bfig_> is there any problem with using notepad++ for writing lhs files? i'm having trouble with either the line jumps or the whitespace (at least that's what i concluded after some tinkering). i'm using hugs
08:24:54 <fryguybob> frank00: Put the type annotations just before the function.
08:25:23 <fryguybob> frank00: Like you have for intCheck.
08:25:28 <paolino> is possible to use bootstrap.sh from cabal-install with 7.0.1 ?
08:25:54 <fryguybob> frank00: In GHCI you can ask what the inferred type is using :t nameOfFunction
08:28:12 <frank00> fryguybob: I am a bit at loss... I think almost every function I use has signatures. Should I do that for "do" functions too?
08:28:30 <fryguybob> frank00: Right.
08:28:57 <fryguybob> frank00: As you discovered nesting ifs in a do block is not particularly elegant.  You should think of ways that you can avoid that.  Specifically instead of using intCheck :: String -> Bool try something like maybeReadInt :: String -> Maybe Int.
08:29:37 <frank00> ohhh I see I see
08:30:13 <fryguybob> frank00: This immediately leads to being able to write evalAnswer with more type safety.
08:34:22 <Philippa> frank00: you can also use a big case block with guards
08:36:19 <frank00> guards? in cases? I didn't know that!
08:36:29 * frank00 googles
08:37:15 <hpaste> inetic pasted "How do you save a tree data structure to binary files in non linear fashion using...  http://hpaste.org/44419
08:40:55 <paolino> anyone installed cabal install on 7.0.1 ? using bootstrap.sh fails
08:44:13 <sg|> hello I need a little help with my haskell code. I am willing to learn how do we set an input validator for numerical range ?
08:44:23 <sg|> like between 10 - 20 
08:45:51 <sg|> hello I need a little help with my haskell code. I am willing to learn how do we set an input validator for numerical range ?
08:45:55 <sg|> like between 10 - 20 
08:46:09 <frank00> omg 10 PRINT A 20 GOTO 10
08:46:18 <frank00> (sorry for the tasteless joke)
08:46:50 <sg|> lol :)
08:46:56 <EvanR> syntax error
08:47:09 <sg|> anyone can help me ?
08:47:54 <fryguybob> sg|: Can you give more details.  You can paste here: http://hpaste.org/
08:48:01 <paolino> sgl: what kind of input?
08:48:32 * hackagebot asil 1.2 - Action Script Instrumentation Library  http://hackage.haskell.org/package/asil-1.2 (ArieMiddelkoop)
08:48:38 <sg|> ok pasting 
08:49:32 * hackagebot asic 1.2 - Action Script Instrumentation Compiler  http://hackage.haskell.org/package/asic-1.2 (ArieMiddelkoop)
08:49:35 <hpaste> Selcuk pasted "Pizza Ex Program"  http://hpaste.org/44420
08:50:13 <sg|> http://hpaste.org/44420/pizza_ex_program
08:50:21 <sg|> this is my code paste 
08:50:52 <sg|> basiclay  I want my program just accept the number between 1 -10 
08:51:16 <srobertson> i'd like to use Data.IntMap, but with newtype-wrapped Ints for safety (got a lot of different types floating around). was planning to make a newtype wrapper for IntMap, keyed to a member of a class IntKey with method (getKey :: a -> Int), and just wrap the methods from Data.IntMap that i need manually. is there a better way?
08:52:09 <paolino> sg|: you can use guards
08:52:41 <paolino> but you have to decide what to do when values are out of range
08:53:10 <sg|> paolino just display error  thats all I want
08:53:17 <paolino> :t error
08:53:18 <lambdabot> forall a. [Char] -> a
08:53:33 <paolino> use this
08:54:18 <sg|> how ?
08:54:20 <paolino> http://learnyouahaskell.com/syntax-in-functions
08:54:32 <paolino> search for guards
08:56:08 <paolino> sg|: last guard should be something like '| otherwise = error "values out of range"'
08:56:41 <paolino> > otherwise
08:56:42 <lambdabot>   True
08:57:23 <fryguybob> sg|: You can also capture the error in the type of alfredo.  For example:  alfredo :: Float -> Float -> Maybe Float   or    alfredo :: Float -> Float -> Either String Float
08:57:29 <int-e> roconnor: on Jesin's Find monad - as far as I can see, the answer is 'yes', but requires eta reductions to see, which ghc might be reluctant to do.
08:58:06 <fryguybob> sg|: This has the benefit of forcing the consumers of alfredo to deal with the error case.
08:59:03 <sg|> fryguybob when I am running to program after I load it from haskell, I do alfredo 10 20 as an example
08:59:31 <sg|> fryguybob I just want to define a range for alfredos pizza like 10 topping for maximum 
08:59:40 <sg|> If the user enter alfredo 10 20 
08:59:58 <sg|> I want to display an error lke ( out of topping number ) 
09:00:08 <sg|> or if they enter 10.2 
09:00:17 <sg|> wanna display the same error 
09:01:38 <paolino> sg|: then the right place to deal with the error is not inside "alfredo"
09:02:42 <dcoutts_> paolino: using cabal-install-0.10.0 on ghc-7.0.1 ?
09:03:08 <paolino> sg|: report the problem to the caller with Either Bool Float or something
09:03:09 <dcoutts_> paolino: that version's bootstrap should work for ghc 7.0 and 6.12
09:03:36 <paolino> dcoutts_: shell I use darcs to get it ?
09:03:54 <paolino> cabal-install-0.10.0 ?
09:04:01 <dcoutts_> http://www.haskell.org/cabal/release/cabal-install-0.10/cabal-install-0.10.0.tar.gz
09:04:54 <paolino> dcoutts_: sorry if I ask, but how would I have guessed ?
09:05:22 <paolino> the 7.0.1 download page says >= 0.8 for cabal-install
09:05:25 <sg|> paolino sorry for asking to much but I am really newbie 
09:05:26 <dcoutts_> paolino: you wouldn't have guessed, it's not on hackage yet
09:05:36 <fryguybob> sg|: http://hpaste.org/paste/44420/pizza_ex_program_annotation#p44421
09:05:46 <dcoutts_> paolino: cabal-install-0.8 does work with ghc 7, but it does not build with ghc 7
09:07:00 <paolino> dcoutts_: thanks
09:07:46 <dcoutts_> paolino: lemme know if you have any problems with that version, I'll be uploading it to hackage in the next couple days
09:08:09 <sg|> fryguybob thank you but having some errors
09:08:10 <sg|> http://hpaste.org/paste/44420/pizza_ex_program_annotation#p44422
09:10:45 <paolino> dcoutts_: should bootstrap.sh there work now ? It tries to download 1.10.1.0 which is not on hackage
09:11:06 <dcoutts_> paolino: oh um yes, sorry, you'll need to install that first for now
09:11:08 <paolino> or, I didn't parse what you said 
09:11:13 <dcoutts_> I'll be putting both on hackage soon
09:11:19 <paolino> ok
09:11:22 <fryguybob> sg|:  Those errors don't seem to line up with the code.  Can you paste the whole file?
09:11:34 <dcoutts_> paolino: http://www.haskell.org/cabal/release/cabal-1.10.1.0/Cabal-1.10.1.0.tar.gz
09:13:04 <elliott> I've been thinking about how to structure a certain pattern of code in my program. It's an interpreter. When any instruction fails in a specific way, I halt the execution of the rest of the instruction, run an error handler, and go immediately on to the next instruction, but *without* reverting the state changes caused by the failing instruction. I don't need any kind of error messages -- there is one and only one way to handle "an error occurred"
09:13:04 <elliott> . In practice, there are usually three ways this error is caused: (1) An IO error fails. I have a special liftIO variant for this, which catches IO exceptions, and throws my own special exception type with the current state, where it is restored by the handler and continued with. This is very ugly. (2) A map lookup or similar yielding Nothing, so that my code looks like "case x of { Nothing -> handleErr; Just x -> do ... long stuff ...}". The inde
09:13:05 <elliott> ntation rapidly piles on and it gets very ugly. And (3), basically the same as (2), is "if bad then handleErr else (lots and lots of stuff)". I'm wondering what the most elegant way to handle this in Haskell in my monad stack would be. Possibly having the instruction-executing actions be "MaybeT MyMonad" rather than "MyMonad", and handling the Nothing? Basically, I want to be able to have this kind of failure support without nesting my code to inf
09:13:08 <smoge> is there a "evaluate defun" of  "evaluate region" in haskell-mode in Emacs???
09:13:10 <elliott> inity and writing lots of boilerplate every time I want a Just.
09:13:12 <elliott> Perhaps the continuation monad would help?
09:13:14 <elliott> Wow, that came out to a lot of lines.
09:13:16 <elliott> Sorry about that.
09:13:22 <smoge> can I evaluate just the selected region?
09:13:30 <monochrom> still better than pressing enter 100 times
09:13:38 <smoge> ?
09:13:55 <napping> smoge: reloading the buffers is closest
09:14:03 <smoge> hum, ok
09:14:13 <smoge> but it would be possible, right?
09:14:39 <napping> not very easily
09:14:44 <smoge> is there another editor plugin with this feature?
09:14:48 <elliott> monochrom: indeed
09:14:56 <elliott> I do that accidentally sometimes :)
09:15:01 <napping> I don't know of an interpreter with that feature
09:15:29 <smoge> of course, with the ghci running on another window
09:15:33 <napping> You can't define new types or classes at the prompt in ghci
09:15:49 <smoge> is there a reason for that?
09:16:00 <smoge> since you can evaluate the whole file anyway?
09:16:19 <napping> Another problem is what it should do - functions can be defined in terms of functions later in the file
09:16:55 <sg|> fryguybob http://hpaste.org/paste/44420/full_prog#p44423 --> This is the whole file code.
09:16:59 <Jesin> @botsnack
09:16:59 <lambdabot> :)
09:17:02 <Jesin> :D
09:17:05 <Jesin> he's back!
09:17:09 <Jesin> @list
09:17:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:17:24 <Jesin> eh
09:17:28 <Jesin> the link isn't loading =/
09:17:39 <m3ga> beginner question : if i have 'data X = X { a::Int, b::String, c::Y, .... }' and i have an value of type X, whats the easiest way of creating a new X with all the fields of x, but with a single field modified?
09:17:57 <napping> there's a record update syntax
09:18:03 <napping> x { field = newVal }
09:18:30 <sg|> fryguybob http://hpaste.org/paste/44420/pizza_ex_program_annotation#p44424 --> this is the compiling error.
09:18:42 <Jesin> napping: that is where x :: X, right?
09:18:59 <smoge> is there a code pool for haskell programs?
09:19:00 <m3ga> napping: thanks!
09:19:02 <napping> yeah, x is the old value of the type defined in terms of record fields, and in the {} you put just the fields to change
09:19:07 <smoge> im a newbie, i'd like to have this
09:20:20 <smoge> is there some kind of lilypond bindings for haskell (music notation)?
09:21:32 <paolino> smoge: google hackage
09:22:53 <sg|> fryguybob working perfect ! thank you !
09:23:04 <fryguybob> sg|: Excellent.
09:24:42 * hackagebot sendfile 0.7.3 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.3 (JeremyShaw)
09:26:07 <jmcarthur> wow, i just learned that GHC represents all the Word* types the same way as Word. so i guess that there's basically no performance reason to use things like Word8 or Word16 unless they are in packed arrays or something
09:26:33 <c_wraith> Is there Word64 on 32 bit machines? :P
09:26:36 <napping> is there ever a performance reason?
09:26:46 <jmcarthur> c_wraith: *performance* reason
09:27:09 <jmcarthur> napping: well i was just thinking of saving memory and/or bandwidth
09:27:16 <c_wraith> jmcarthur: I was more questioning representing Word64 as a 32-bit value, which you accidently implied :)
09:27:26 <jmcarthur> c_wraith: ah. caught me
09:27:47 <napping> Oh, not memory, no. If you do need the semantics, it's probably faster than modding things yourself
09:28:07 <jmcarthur> well yeah, the semantics is a different matter
09:28:08 <elliottcable> elliott: (elliottt?) damn you for stealing my name
09:28:11 <napping> I don't think any instructions on 8 or 16 bits are faster than the 32 bit version
09:28:19 <elliottcable> elliott: every single message you send (or that is sent to you) fuckin’ hilights me! D:
09:28:27 <elliott> I am not elliottt. and that's not my fault
09:28:37 <jmcarthur> napping: no, but memory bandwidth is usually a bigger deal than cpu loads anyway
09:28:51 <elliottcable> elliott: I didn’t say it was, I’m just bitching :D
09:28:56 <greygjhart> hi
09:28:56 <jmcarthur> napping: things like how quickly your cache invalidates and stuff
09:29:09 <napping> any boxed value is almost certainly a multiple of the machines word size
09:29:35 <Jesin> @help ft
09:29:35 <lambdabot> ft <ident>. Generate theorems for free
09:29:40 <Jesin> what exactly does that do, btw?
09:29:56 <elliott> I conclude that my code structure is completely unworkable :-)
09:29:58 <elliottcable> How the hell is this the only channel on Freenode with any other “elliott”s in it, and it has *three* of them? )-:
09:30:07 <jmcarthur> napping: i've been making sure that they unbox by looking at Core
09:30:11 <greygjhart> is there anything particular to install in order to use Parsec as mentioned in the HitchHikers_guide_to_Haskell ?
09:30:23 <elliott> elliottcable: because you're not in any good channels
09:30:26 <napping> well, then they are passed in registers
09:30:35 <elliottcable> elliott: I’m in, like, 50% of Freenode.
09:30:48 <elliott> clearly the wrong 50% then
09:31:02 <elliott> also the channel limit is like 20 i believe, so that's rather unlikely unless you have like a hundred nicks
09:31:06 <napping> I'm pretty sure GHC doesn't bother trying to use al + ah or such
09:31:07 <elliott> although i think you can get it raised to 100.
09:31:12 <greygjhart> because ghc complains that it can't find the module Text.ParserCombinator.Parsec
09:31:35 <napping> so it's only passing around the boxed versions for the original arguments or final returns that might actually use memory
09:31:43 <jmcarthur> napping: good point
09:31:45 <napping> well, I suppose they might spill on the stack a bit
09:31:48 <elliottcable> elliott: I have one nick, with +u, and I’m in approximately 90 channels right now
09:31:52 <elliottcable> elliott: :D
09:32:10 <paolino> greygjhart: cabal install parsec , should do
09:32:10 <elliott> And you follow all of those?
09:32:17 <napping> anyway, if you only have one, the memory doesn't matter. If you have a lot, an unboxes array will take less space for smaller words
09:32:18 <jmcarthur> napping: and ghc also doesn't pack record fields (and probably shouldn't)
09:32:21 <elliottcable> elliott: to some extent or other, yes
09:32:28 <elliottcable> elliott: I’ve been very prolific on Freenode for half a decade now
09:32:38 <napping> hmm, packing record fields would actually be pretty reasonable, if you have some unboxed strict fields
09:32:44 <jmcarthur> i have somewhere between one and a lot
09:32:46 <dons> elliottt: elliott elliottcable . confusing.
09:32:52 <greygjhart> paolino: ah ok, so I must install Cabal ? The page doesn't mention it, so I thought I was good to start with the package ghc only
09:32:54 <jmcarthur> napping: only reasonable as a programmer annotation though
09:32:55 <elliott> dons: yes. be confused! be very confused!
09:33:00 <elliottcable> dons: I know, right?
09:33:12 <elliottcable> dons: it’s very simple: none of those people are *me*! #problemsolved
09:33:28 <jmcarthur> but yeah, i do have some rather large record types with strict fields that i *could* UNPACK, but i fear that they might just get reboxed a lot if i do that
09:33:59 <paolino> greygjhart: you need cabal-install
09:34:12 <paolino> which is not Cabal
09:34:26 <dcoutts> dons: HP build with new Cabal + cabal-install ok?
09:34:40 * dcoutts would like to upload to hackage
09:35:34 <paolino> dcoutts: here it is installing hakyll
09:35:40 <greygjhart> paolino: yes I've installed it
09:35:55 <paolino> dcoutts: no problem
09:36:28 <greygjhart> thanks a lot, that was just the little help I was needing
09:36:42 <paolino> you are welcome
09:37:10 <greygjhart> I thought there'd be at least some explanation about basic requirements on that page, so I thought maybe I was doing something wrong
09:37:22 <greygjhart> well bye then and thanks very much again
09:40:13 <dons> dcoutts: yes.
09:40:23 <dons> just need ghc 7.0.2 blessed
09:40:47 <dcoutts> dons: ok, I'll release the new Cabal + cabal-install then
09:40:49 <paolino> dcoutts_: it worked great, installed 52 packages
09:41:03 <dcoutts> dons: thanks for testing
09:42:58 <paolino> are there plans to parallelize cabal-install ?
09:46:48 * hackagebot happstack-server 6.0.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.0.1 (JeremyShaw)
09:53:18 <dcoutts> paolino: not at the moment, there are higher priorities
09:53:30 <dcoutts> that said, we accepet patches :-)
09:53:44 <dcoutts> and it should not be too hard, we do have a full dep graph (see InstallPlan)
09:53:47 <Hugglesworth> Trying to figure out how to make some modular code; Is it possible to include a file conditionaly?
09:54:09 <Hugglesworth> like `if blah then import xxxx else return ()` or sth
09:54:14 <conal> augustss: i replied to your comment on haskell & "real-world applications" http://www.reddit.com/r/haskell/comments/ftxc7/do_you_think_haskell_will_ever_catch_on/c1iqriu
09:55:03 <napping> Hello conal
09:55:09 <roconnor> category theory is hard
09:55:22 <conal> thinking is hard
09:55:25 <conal> napping: hi
09:55:26 <napping> I think I made some progress on cleaning up the actor stuff at least
09:56:01 <roconnor> conal: I liked your recent post.  I've been doing some programming reasoning recently too (mine was to prove laws) and it is really kinda fun.
09:56:10 <napping> locally-finite preorders with some local conditions on what sorts of neighbors a node can have seems enough to define the usual semantics
09:56:15 <roconnor> conal: I wish it was required in to get a CS degree
09:56:55 <napping> and the claims I'd been reading that sounded dubious make much more sense from a more constructivist point of view
09:57:13 <napping> Now I've some hope of finding useful equational laws
09:57:29 <conal> roconnor: :) . yeah. odd that CS is such a formal enterprise (in that we use precise programming languages) but reasoning is so neglected.
09:58:05 <jmcarthur> conal: our implementations are precise, but very few languages actually are, as far as i can tell
09:58:10 <roconnor> also, free theorems are surprisingly useful for their cost.
09:58:19 <napping> I suspect part of the difficulty with concurrent programming is the lack of a nice denotation for the space of possible behaviors
09:58:46 <conal> jmcarthur: yeah. the languages are a mixture. usually precise about syntax, and then clarity drops off.
09:58:51 <Lemon> are there ways to keep the garbage collector from running until a certain point in the program?
09:59:14 <jmcarthur> Lemon: generate less garbage or give the runtime some hints to start with a larger heap?
09:59:18 <napping> not that I know of, and I don't see why you would want to
09:59:21 <jmcarthur> Lemon: it's no guarantee
09:59:25 <Lemon> hm.
09:59:38 <Lemon> Does the garbage collector interfere with parallel code?
09:59:41 <conal> most programming languages are rigid about syntax, without the certainty/rigor/correctness benefits of rigidity
09:59:50 <Lemon> That is, say I got two threads running.
10:00:10 <napping> from the pretty pictures I've seen, you might want ThreadScope
10:00:17 <Lemon> One thread needs to garbage collect, and the other thread's data is unaffected,
10:00:27 <Lemon> would the garbage collector stop the other thread from doing work?
10:00:41 <napping> ThreadScope will show you when threads are working or stopped and why
10:00:53 <roconnor> it would be intresting to write a function System.blockGC :: IO a -> IO a
10:00:54 <Lemon> I tried to install threadscope, but some dependencies don't compile.
10:00:54 <napping> also, I'm pretty sure the first level collections are thread local
10:03:23 <jmcarthur> napping: they aren't yet
10:03:43 <napping> the nursery collections?
10:03:50 <jmcarthur> napping: i think marlow is working on that now though
10:04:23 <jmcarthur> napping: i seem to recall reading that even the nursery collections are stop-the-world right now
10:04:33 <kniu> I was here last night trying to parallelize a path tracer.
10:04:43 <kniu> But I was unsuccessful.
10:05:08 <jmcarthur> napping: and my experience with threadscope seems to support that understanding
10:05:21 <jmcarthur> kniu: the gc currently stops all threads, but when you are using the threaded runtime the gc is parallel
10:05:32 <kniu> oh okay
10:05:46 <kniu> it's just
10:05:49 <conal> i have some more posts coming up with a lot more equational reasoning.
10:05:51 <thoughtpolice> the GC is parallel, but it is still stop the world, yes
10:05:51 <jmcarthur> kniu: i think ghc 7.2 will be a bit smarter about generation 1 collections
10:06:04 <thoughtpolice> 7.4 or so will probably have simon's new GC
10:06:11 <jmcarthur> thoughtpolice: oh that far off? darn
10:06:13 <thoughtpolice> which can do young-gen collections independently of other CPUs
10:06:20 <kniu> my parallel program runs 3x slower than the single threaded version and uses 200% of the CPU.
10:06:36 <jmcarthur> kniu: sounds like data dependency issues to me, then
10:06:37 <thoughtpolice> jmcarthur: yeah, i haven't heard anything about it being merged for 7.2, which will happen sooner than normal since GHC is switching to git
10:06:43 <napping> that's a bit worse than expected
10:06:45 <kniu> jmcarthur, what do you mean?
10:06:49 <thoughtpolice> it could still make it in, though, maybe it's just not documented
10:07:01 <conal> and it has me thinking: maybe a helpful way to express what's qualitatively different between "pure" Haskell vs IO (& STM) is that the "pure" stuff is good for equational reasoning. (because it has precise & simple denotation.)
10:07:01 <jmcarthur> kniu: or maybe too fine-grained parallelism
10:07:06 <jmcarthur> kniu: try threadscope out
10:07:18 <kniu> once I figure out how to install the damn thing.
10:07:21 <jmcarthur> kniu: actually, what is the grain of your parallelism?
10:07:21 <thoughtpolice> ugh, threadscope is such a heavy weight dependency
10:07:41 <kniu> jmcarthur, one giant list of Doubles that need to be computed on two cores,
10:07:44 <jmcarthur> kniu: if you run with +RTS -s, what does it say about sparks and stuff?
10:07:48 <thoughtpolice> i had plans to rewrite threadscope to work in a browser, which would be great and a hell of a lot easier than installing GTK
10:08:01 <Philippa> conal: so IO's no gofer?
10:08:01 <thoughtpolice> every try getting gtk2hs working on OS X? the horror is incredible IIRC
10:08:04 <djahandarie> conal, I think augustss was probably just clarifying that you were talking about "going the extra mile" in Haskell, rather than comparing Haskell with other languages.
10:08:13 <kniu> so I just split the list and did a (deepseq a ()) `par` (deepseq b ()) `pseq` (a ++ b)
10:08:13 <jmcarthur> thoughtpolice: even just generating some static images would be nice
10:08:26 <dcoutts> thoughtpolice: I hear it's easer than it used to be, using homebrew rather than macports
10:08:34 <thoughtpolice> dcoutts: good to know
10:08:39 <roconnor> what does Caml have to do with category theory?
10:08:40 <jmcarthur> kniu: i'd still like to see the sparks statistics
10:08:46 <kniu> k, gimme a sec
10:08:47 <mm_freak_> is there a way to parse an HTTP response only using http-enumerator?
10:09:01 <conal> one might say that Haskell's relationship with imperative programming is not so much good for equational reasoning as bad for incorrect equational reasoning.
10:09:03 <mm_freak_> even the most low level function (http) insists on connecting and requesting
10:09:07 <Philippa> roconnor: the abstract machine was supposedly derived categorically
10:09:16 <thoughtpolice> jmcarthur: i had an experimental little program that would dupe threadscope and the eventlogging infrastructure, it would create a fifo where the program would have put its eventlog file, and then can lazily and incremently read the resulting eventlog file on the other end
10:09:19 <roconnor> Philippa: really?
10:09:28 <thoughtpolice> viola! you can get the eventlog data in real time, but i didn't get to the point of displaying it
10:09:35 <jmcarthur> ah cool
10:09:42 <Philippa> roconnor: yeah, so it was called the "categorical abstract machine". I think they ditched it though
10:09:45 <thoughtpolice> funnily enough, eventlog-linked programs ran faster using my little shim then under normal conditions
10:09:50 <roconnor> Philippa: hah
10:09:54 <thoughtpolice> because binary parsing the eventlog directly is way faster than writing to disk
10:10:07 <roconnor> Philippa: but what does it mean to derive an abstract machine categorically?
10:10:17 <Philippa> roconnor: dunno, I can't remember anything from the paper :-)
10:10:17 <thoughtpolice> unfortunately, the eventlog infrastructure makes the eventlog grow extremely quickly, so you'll quickly hit the limits of fopen because it can't handle large files
10:10:18 <jmcarthur> thoughtpolice: sounds like a win/win to me
10:10:21 <thoughtpolice> :/
10:10:21 <jmcarthur> oh
10:10:38 <thoughtpolice> that needs to be fixed for sure
10:10:43 <roconnor> Oh CAM has it's own wikepdia article
10:10:44 <napping> monads are so nice for writing denotational semantics
10:10:49 <thoughtpolice> like, a 10 second run of a program can result in a 400mb eventlog file
10:10:51 <roconnor> http://en.wikipedia.org/wiki/Categorical_abstract_machine
10:10:58 <jmcarthur> yeah i noticed they get very large
10:10:58 <thoughtpolice> depending on the parallelism, of course
10:11:01 <jmcarthur> easy to crash ThreadScope, even
10:11:30 <thoughtpolice> oh yeah, i had massive issues with threadscope lock ups too.
10:11:38 <thoughtpolice> all in all i figured it was a good idea, i just need to get back to it
10:11:48 <Jesin> @help ft
10:11:49 <lambdabot> ft <ident>. Generate theorems for free
10:11:52 <Jesin> what does that do
10:12:02 <Jesin> and how is it used
10:12:03 <Jesin> :p
10:12:04 <thoughtpolice> fixing the eventlog infrastructure would probably be the best place to start too I imagine
10:12:40 * dcoutts is working on the eventlog infrastructure at the moment
10:12:45 <roconnor> Philippa: this is the paper you were refering to? --> http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6V17-45DJ3JV-16&_user=1067350&_coverDate=04%2F30%2F1987&_rdoc=1&_fmt=high&_orig=gateway&_origin=gateway&_sort=d&_docanchor=&view=c&_searchStrId=1660696152&_rerunOrigin=scholar.google&_acct=C000051241&_version=1&_urlVersion=0&_userid=1067350&md5=9109b52ae6129887881c0f84707b7561&searchtype=a
10:13:01 <jmcarthur> kniu: how long does it take to run?
10:13:18 <kniu> jmcarthur, I'm still trying to install threadscope
10:13:24 <dcoutts> thoughtpolice: so what's your main complaint/suggestion?
10:13:28 <jmcarthur> kniu: you don't need to for the +RTS -s thing
10:13:36 <kniu> alright
10:13:40 <jmcarthur> kniu: threadscope is nicer for detailed analysis
10:14:27 <hpc> @help djinn
10:14:27 <lambdabot> djinn <type>.
10:14:28 <lambdabot> Generates Haskell code from a type.
10:14:28 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
10:14:39 <hpc> djinn == ft?
10:14:42 <djahandarie> No.
10:14:44 <djahandarie> @ft map
10:14:45 <lambdabot> Done.
10:14:48 <jmcarthur> ...
10:14:50 <burp> @djinn Int -> Int
10:14:50 <lambdabot> Error: Undefined type Int
10:14:54 <Jesin> ...??
10:14:55 <djahandarie> @free map
10:14:56 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:15:06 <thoughtpolice> dcoutts: gtk2hs is heavyweight and threadscope seemed to have some reliability issues on larger eventlog files when using it, mainly. i don't know if i reported a bug however, so that is my fault admittedly.
10:15:09 <hpc> oh
10:15:16 <thoughtpolice> i'm also not the biggest fan of gtk in general, but it's the best we have too
10:15:23 <Jesin> @free ap
10:15:24 <lambdabot> Expected variable or '.'
10:15:31 <djahandarie> hpc, http://www.mpi-sws.org/~dreyer/tor/papers/wadler.pdf relevant
10:15:32 <Jesin> @ft ap
10:15:33 <lambdabot> Done.
10:15:35 <Jesin> @free ap
10:15:36 <lambdabot> Expected variable or '.'
10:15:45 <Jesin> @free
10:15:45 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:15:49 <Jesin> umm
10:15:49 <hpc> @help free
10:15:50 <lambdabot> free <ident>. Generate theorems for free
10:15:57 <hpc> @help ft
10:15:57 <lambdabot> ft <ident>. Generate theorems for free
10:15:58 <dcoutts> thoughtpolice: ok, so mainly issues with threadscope rather than the unrelying event infrastructure
10:16:04 <hpc> λbot bug?
10:16:11 <dcoutts> thoughtpolice: threadscope currently loads the whole log file in memory at once
10:16:15 <jmcarthur> @free zip
10:16:16 <lambdabot> $map ($map_Pair f g) . zip xs = zip ($map f xs) . $map g
10:16:20 <dcoutts> which obviously will never scale
10:16:27 <djahandarie> I'm not sure what @ft does. It probably does the same thing as @free and doesn't output it.
10:16:30 <thoughtpolice> dcoutts: yeah, the event infrastructure seemed to work fine and have very nice detailed info, the biggest limitation obviously is that it can't handle large files
10:16:37 <thoughtpolice> so it's good to know you're fixing that :)
10:17:07 <dcoutts> thoughtpolice: you mean threadscope can't handle large files, ghc should be able to generate truly massive multi-GB log files
10:17:21 <hpc> how should i read the dollar signs in free output?
10:17:27 <hpc> @free getLine
10:17:28 <lambdabot> $map_IO $id getLine = getLine
10:17:43 <hpc> ha!
10:17:53 <c_wraith> what a brilliant free theorem!
10:17:58 <dcoutts> thoughtpolice: or did you mean ghc fails when log files get to big? you mentioned fopen
10:17:59 <jmcarthur> heh
10:17:59 <thoughtpolice> dcoutts: I could have sworn I'd run into errors about eventlog's fwrite failing when handling very large files. in fact i'm sure of it. i'll see if I can reproduce that right fast with something on my machine
10:18:11 <hpc> i see
10:18:19 <hpc> $map == some fmap-y function
10:18:22 <jmcarthur> kniu: so... how long *does* it take? i'm about to go grocery shopping and am wondering if i should wait or not
10:18:26 <hpc> $id == some identity thing
10:18:34 <kniu> jmcarthur, sorry about that
10:18:37 <dcoutts> thoughtpolice: hmm, ok. ghc ought to be built with the posix large file support, so yes details would be good.
10:18:53 <jmcarthur> kniu: np. i hadn't told you that
10:18:56 <kniu> yeah
10:18:57 <kniu> uh
10:19:13 <kniu> what am I supposed to look at?
10:19:24 <kniu>   SPARKS: 1 (1 converted, 0 pruned)
10:19:44 <jmcarthur> okay so you are really only generating one spark, so very coarse parallelism
10:20:07 <kniu> ye
10:20:39 <monochrom> @bots
10:20:39 <lambdabot> :)
10:21:07 <jmcarthur> kniu: what about the GC?
10:21:11 <jmcarthur> how much time is it taking?
10:21:27 <kniu>   %GC time      27.6%  (14.2% elapsed)
10:21:51 <jmcarthur> not absolutely terrible
10:21:57 <jmcarthur> on the high side
10:22:08 <kniu> any way to reduce it, then?
10:22:57 <jmcarthur> maybe the cost of splitting and appending the lists is too much? at this point i can only speculate. i think threadscope might be the way to go
10:23:26 <kniu> okay
10:23:47 <jmcarthur> but i must say at this point i'm a bit mystified
10:24:16 <jmcarthur> kniu: the gc cost might just be due to your deepSeq. means you are actually holding on to all the values in those lists
10:24:45 <jmcarthur> kniu: might save some gc by using an array or something instead
10:24:52 <kniu> perhaps
10:24:54 <kniu> going to try it out.
10:25:05 <jmcarthur> repa might even be a reasonable thing to try
10:25:17 <jmcarthur> ndp isn't there yet
10:25:35 <jmcarthur> but i'm still curious why this isn't working
10:27:05 <jmcarthur> kniu: oh, another thing, if you are on linux, there's something called the "last core slowdown," a phenomena in which if you have n cores your program can scale for the first n-1 cores, but then when you add the last one it slows down a bit. with only two cores, this might manifest as just not getting any parallelism at all. i'm not sure why that happens, but it does sometimes
10:27:27 <jmcarthur> kniu: to be clear, this seems to be just an issue with ghc on linux, not ghc on other platforms, and not other runtimes on linux
10:27:29 <kniu> jmcarthur, that's quite a big limitation, then.
10:27:31 <jmcarthur> afaik
10:27:48 <jmcarthur> kniu: i've read that the new gc simon is working on will fix it
10:27:55 <jmcarthur> which implies that it's gc related
10:28:00 <kniu> I am on linux 2.6.37, using ghc 6.12
10:28:19 <kniu> would ghc 7.0 help at all?
10:28:37 <jmcarthur> kniu: ghc 7 does tend to work a lot better for parallelism
10:28:39 <monochrom> a bit funny that it takes the combination of linux and garbage collector.
10:28:44 <jmcarthur> kniu: but i don't know for sure
10:29:05 <kniu> ran it again
10:29:07 <kniu>   %GC time      24.9%  (5.3% elapsed)
10:29:30 <kniu>   Task  1 (worker) :  237.95s    (327.85s)      63.88s    (  7.95s)
10:29:30 <kniu>   Task  2 (bound)  :  234.91s    (327.85s)      85.52s    ( 10.54s)
10:29:56 <jmcarthur> that's pretty good parallelism there
10:31:06 <kniu> jmcarthur, but it's slower than the single-threaded version.
10:31:13 <jmcarthur> i still recommend threadscope, just to see if anything weird shows up. also try ghc 7 or a different approach like parallel arrays. aside from that, i'm at a loss. no idea how to explain that aside from maybe the last core slowdown
10:31:48 <jmcarthur> kniu: oh, using the brainfuck scheduler on linux bychance? i've noticed that i get better parallelism with the stock scheduler
10:31:58 <jmcarthur> *better throughput from parallelism
10:32:01 <kniu> brainfuck scheduler?
10:32:10 <jmcarthur> kniu: if you don't know what it is you don't have it
10:32:14 <kniu> oh.
10:32:25 <jmcarthur> oh well
10:32:27 <hpc> someone wrote a scheduler in brainfuck?
10:32:28 <jmcarthur> that's all i've got
10:32:31 <hpc> that takes balls of steel
10:32:32 <jmcarthur> hpc: no :P
10:32:48 <monochrom> the brainfuck scheduler is an alternative scheduler for the linux kernel to favour UI
10:32:57 <hpc> oh, bleh
10:33:05 * hackagebot riak 0.3.0.1 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.3.0.1 (BryanOSullivan)
10:33:17 <jmcarthur> i'm leaving now
10:33:25 <jmcarthur> kniu: good luck kniu 
10:33:25 <monochrom> "so that when you recompile kernel or ghc in the background, you can still watch youtube"
10:33:27 <jmcarthur> err
10:33:30 <kniu> thanks, jmcarthur 
10:33:33 <jmcarthur> redundancy is redundant
10:33:40 <monochrom> frankly I find that rather fringe and cliche
10:34:04 <hpc> monochrom: wouldn't that be better served by just not passing -J or whatever flag?
10:34:19 <jmcarthur> monochrom: it's nice to be able to do make -j3 and still have a reasonably responsive machine
10:34:36 <jmcarthur> i don't care about youtube videos, but just having my browser not be laggy is nice
10:34:46 <jmcarthur> (on a two core machine)
10:34:52 <hpc> -j2 is that much slower?
10:35:05 <monochrom> I find that "nice make" is more than enough to get a more than responsive UI
10:35:26 <jmcarthur> monochrom: in my experiences that's not the case
10:35:33 <jmcarthur> at least not with browsers, specifically
10:35:43 <jmcarthur> anyway, i'm really leaving
10:36:06 <hpc> all you silly dudes with your GUI linuxes :P
10:36:56 <kniu> see, right now I'm seriously contemplating doing the following:
10:37:10 <monochrom> I used to build ghc on a slower computer than my current one and firefox still responded just fine. and one core too.
10:37:15 <kniu> write a shell script that runs two instances of the single-threaded version of the program,
10:37:30 <kniu> with one rendering the top half and the other rendering the bottom half of the image,
10:37:40 <kniu> and then just stitching them together with a third program.
10:37:44 <hpc> kniu: eeew
10:37:54 <hpc> i tried that with folding@home and the results are decidedly sub-par
10:38:04 <kniu> it'd get better performance than what I got now.
10:38:12 <monochrom> perhaps my trick is not to visit reddit, i.e., not to load a page with 1000 comments.
10:38:16 <hpc> (this was because the threaded client caused panics)
10:38:31 <hpc> monochrom: that's generally wise :P
10:38:34 <kniu> wrote the same path tracer in C, and got 2x speedup just by using pthreads on different halves of the image.
10:38:48 <hpc> the javascript alone will bring ff to a crawl
10:38:51 <DevHC> a question about ForeignPtr
10:38:53 <kniu> problem is that it segfaults randomly.
10:38:59 <jmcarthur> kniu: thought of one more thing. you might want to try running with +RTS -g1  (the parallel GC might actually be hurting you. i often only helps with >2 cores)
10:39:15 <DevHC> in the documentation about finalizers, it's said that: Whether a finalizer may call back into the Haskell system is system dependent.
10:39:18 <jmcarthur> *it often
10:39:21 <kniu> huh
10:39:23 <kniu> going to try it.
10:40:00 <DevHC> however, a note for touchForeignPtr says: This function can be used to express liveness dependencies between ForeignPtrs: For example, if the finalizer for one ForeignPtr touches a second ForeignPtr, then it is ensured that the second ForeignPtr will stay alive at least as long as the first.
10:40:07 * hackagebot xml-enumerator 0.1.3 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.1.3 (MichaelSnoyman)
10:40:42 <DevHC> so does that mean a finalizer can be portably only-haskell or only-nonhaskell? or what?
10:41:07 <tolkad> How do you depend on a cabal package that isn't on hackage?
10:41:29 <hpc> are there alternatives to hackage?
10:41:42 <quuuux> tolkad: no differently than if it's on hackage. cabal-install just won't help you install it
10:42:05 <tolkad> quuuux: but then how do you tell cabal where it is located so you can do the build?
10:42:28 <hpc> tolkad: if it is installed on your system, it doesn't matter what repo you got it from
10:42:31 <quuuux> tolkad: ghc-pkg knows where all the installed stuff lives
10:43:17 <tolkad> but if I'm distrubuting my source code to other people
10:43:30 <tolkad> I don't want to have to give them seperate instructions of where to download these other packages
10:43:32 <monochrom> you then distribute the other packages too
10:43:58 <monochrom> if the other packages don't license you to re-distribute...
10:44:05 <quuuux> persuade the author to upload the package to hackage?
10:44:06 <monochrom> you start another license flame war :)
10:44:32 <tolkad> but they might not want these other non-hackage packages cluttering their ghc-pkg database. is there anyway I can just temporarily use them for the build?
10:44:51 <tolkad> also that would mean I would have to give them seperate instructions on which order to install the packages in
10:44:56 <monochrom> you can distribute just an executable. if the other packages license you to.
10:45:00 <tolkad> or give them a non-cabal build script
10:45:21 <quuuux> if it's only needed for the building step, you can use a local package database which you nuke when it's built and installed
10:45:30 <tolkad> monochrom: well even if you distribute an executable you have to give people the source code
10:45:46 <quuuux> otherwise you'll either need to statically link everything in to your executable, or put up with these packages in the database
10:46:21 <monochrom> the source code part can be less convenient regarding other packages
10:46:42 <tolkad> so I basically need to gather all these packages up and write a non-cabal build script to make sure they get cabal-installed in the right order?
10:46:43 <uber_mor2> monochrom: Not sure if you remember my problem from yesterday, but I solved it and wanted to share my solution with you :)
10:47:01 <monochrom> there is no such thing as "self-contained source code" anyway. there is always external dependencies the builder has to chase manually.
10:47:03 <pozic> tolkad: nobody cares about having to compile a few extra modules. Optimize for your developer time. 
10:47:36 <tolkad> pozic: people should be able to compile a project with a single command. they also shouldn't have to know which order to install the packages in
10:47:49 <uber_mor2> monochrom: I ended up adding the {-#LANGUAGE BangPatterns #-} pragma and a ! before my data structure. Everything seems to be evaluating now :)  thanks for your help yesterday
10:47:51 <monochrom> for example if you give C source code to a windows end-user, he/she still needs to find a compiler manually.
10:47:55 <pozic> tolkad: I was implying it was completely automatic.
10:48:06 <pozic> monochrom: that is not true.
10:48:42 <pozic> monochrom: you could in theory tell cabal to download a C compiler from the Internet, use that, and deinstall the C compiler.
10:48:54 <hpc> pozic: wut
10:49:01 <monochrom> no one does that. add "in practice" to my sentence if you like.
10:49:03 <pozic> hpc: I am just saying what is possible.
10:49:04 <hpc> that's the most disgusting idea...
10:49:04 <tolkad> ooh. what about a cabal meta-package
10:49:21 <pozic> hpc: I am not saying that one should do that.
10:49:34 <pozic> cabal install ccompiler, would be nice to have working on Windows.
10:49:35 <tolkad> I make a cabal package with a build script that calls cabal again on all the other packages
10:49:49 <hpc> pozic: it is a case for having that shit bundled in the windows platform
10:49:58 <hpc> *windows haskell platform
10:50:41 <tolkad> is it true that there are some ghc devs who sold their souls to microsoft?
10:50:52 <monochrom> yes
10:51:16 <pozic> hpc: yes, but that doesn't mean one has to depend on that.
10:51:23 <hpc> to work on F# i suppose?
10:51:28 <pozic> hpc: whether or not to do something depends on requirements. 
10:51:37 <monochrom> and this is why they include gcc in windows haskell platform
10:51:46 <hpc> oh lol
10:52:19 <pozic> Do they also still bundle Perl?
10:52:35 <monochrom> let me check
10:53:13 <monochrom> yes
11:06:12 * hackagebot unordered-containers 0.1.1.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.1.0 (JohanTibell)
11:22:18 <zingi> Hi, i need help with this: http://codepad.org/lYy0zlY4
11:22:54 <djahandarie> zingi, what is the problem?
11:23:21 <quuuux> zingi: is line 75 literally as in the pastebin?
11:23:33 <kramble> hi, i want to know if there is a way to stop ghc at the first error ?
11:23:47 <zingi> hi djahandarie quuuux i should fill those 3 dots
11:24:06 <zingi> djahandarie: quuuux actually this is a university assignment
11:24:26 <quuuux> zingi: either that, or delete the 'where' on the preceding line. It's expecting the typeclass's methods to be described there, in an indented block
11:24:30 <zingi> djahandarie: quuuux : i need to do line 75
11:25:17 * hackagebot wai-extra 0.3.2.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.3.2.1 (MichaelSnoyman)
11:25:25 <quuuux> zingi: okay, so define the instance there and that syntax error ought to vanish
11:26:04 <zingi> quuuux: yeah, no problem with that.... but i have to use same technique used in lines 65-70 but using the second string as key, how can i achieve that?
11:26:48 <djahandarie> zingi, pattern match the pair like (Pair _ a) instead of (Pair a _)
11:26:58 <quuuux> zingi: ah, now, that's the meat of the assignment, isn't it? :) Consider how the names are bound to which parts of the structure
11:27:04 <djahandarie> Pattern matching is generally how you take stuff out of data constructors.
11:27:28 <zingi> djahandarie: and (Pair _ b) instead of (Pair b _) right?
11:27:37 <djahandarie> zingi, yep, since you want the second part of it.
11:27:50 <djahandarie> The _ just means to disregard that part
11:28:07 <zingi> djahandarie: and same with the unpack (Pair _ w) = w? it should be (Pair w _ ) = w
11:28:09 <djahandarie> You could do (Pair a a') and (Pair b b') and only use the ' versions if you wanted
11:28:27 <djahandarie> zingi, I don't know what unpack does.
11:30:46 <zingi> djahandarie: neither do i lol
11:31:14 <djahandarie> zingi, it looks like it is used in the translate function but I don't particularly feel like figuring out what it is suppose to do. :)
11:31:15 <zingi> djahandarie: this is a cool assignment indeed, translates english2french2german2italian..
11:31:21 * hackagebot wai-extra 0.3.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.3.3 (MichaelSnoyman)
11:32:08 <zingi> djahandarie: i'll leave it for now
11:32:57 <zingi> djahandarie: for line 80, it's just a quicksort.. i can find it on haskell's website
11:33:07 <djahandarie> zingi, what university is teaching Haskell?
11:33:19 <djahandarie> And that is probably plagiarism.
11:33:22 <zingi> djahandarie: McGill, Montreal, Canada
11:33:48 <zingi> djahandarie: why plagiarism? there's no other way one can do it
11:33:58 <djahandarie> There are plenty of ways to write quicksort.
11:34:29 <djahandarie> And also, no doubt, the point of the assignment is for you to understand it, not for the code to be written. ;)
11:35:28 <zingi> djahandarie: the course is not based on haskell, the course is about the principles of programming languages. so many material to be covered, no time to study all of haskell in 2 weeks
11:35:32 <monochrom> you don't actually have to use the quicksort algorithm
11:36:08 <zingi> qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
11:36:11 <djahandarie> And one could argue that the one on the Haskell website isn't really the quicksort algorithm anyways.
11:37:03 <shachaf> There's certainly nothing quick about it.
11:37:22 <monochrom> after finishing this assignment, you will have learned only about 5% of haskell, so don't worry about learning too much.
11:37:24 <djahandarie> zingi, you could just write 'sort' there if you are just trying to complete the program.
11:37:50 <zingi> djahandarie: but i need 'quicksort'
11:38:06 <djahandarie> Define quicksort. A sort that goes fast? ;)
11:38:19 <djahandarie> Quicksort is a terrible exercise in Haskell anyways
11:38:58 <sproingie> quicksort is defined as an in-place sort and this isn't something that lends itself to functional idioms
11:39:01 <quuuux> if the assignment specifically asks for quicksort, I'd bet that the algorithm has been defined in lectures/notes at some point
11:39:13 <Jafet> ghc mergesort.hs -c -O2 # quicksort
11:40:21 <djahandarie> If you really want a quick sort, using Data.Vector and sort from http://hackage.haskell.org/packages/archive/vector-algorithms/0.4/doc/html/Data-Vector-Algorithms-Intro.html , which is an introspective (quicksort + heapsort) sort.
11:40:29 <zingi> djahandarie: good to know, thanks for the info.. quuuux i'm checking
11:40:43 <djahandarie> But that is 'advanced' level Haskell
11:40:50 <djahandarie> In one of the 'advanced' directions you can go in Haskell
11:40:54 <djahandarie> There are many paths ;)
11:41:29 <zingi> djahandarie: keep it simple on me lol
11:42:04 <djahandarie> Well if you professor is just expecting you to copy something from the lecture notes, go ahead and do that I guess.
11:42:07 <djahandarie> your*
11:42:59 <zingi> djahandarie: this is our 3rd lecture for haskell in class, and i already have over 400 papers and links from him.. no idea where one can buy time
11:43:26 <djahandarie> Either way, I'm opposed to non-learning / time wasting ;)
11:43:45 <monochrom> surprisingly many profs choosing haskell for class have lost touch with the haskell community. for example we have realized for a decade that "qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)" is not quicksort, and in fact is not a satisfactory sorter at all.
11:44:16 <zingi> monochrom: mentioned here: http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
11:44:16 <aristid> monochrom: s/surprisingly/unsurprisingly/. fixed it for you
11:44:16 <monochrom> there is also the not-sieve thing.
11:44:36 <monochrom> yes that page is outdated
11:44:59 <monochrom> and probably too obscure or uninteresting to be noticed and fixed
11:45:14 <zingi> monochrom: ah k
11:45:30 <djahandarie> The 'sort' function in Data.List is mergesort
11:45:34 <djahandarie> Which usually does a good job.
11:45:36 <zingi>   quicksort :: Ord a => [a] -> [a]
11:45:37 <zingi>   quicksort []     = []
11:45:37 <zingi>   quicksort (x:xs) = quicksort [y | y <- xs, y <  x] ++ [x] ++
11:45:39 <zingi>                      quicksort [y | y <- xs, y >= x]
11:45:57 <zingi> is it okay to paste code blocks here?
11:45:57 <shachaf> monochrom: Was that ever given as a serious example of how to sort in Haskell?
11:45:59 <monochrom> these days for introductions we refer people to LYAH and we have pretty much forgotten that http://www.haskell.org/haskellwiki/Introduction even exists.
11:46:08 <monochrom> yes, in the 90s
11:46:20 <monochrom> and a serious example of "look how haskell is so easy!" too
11:46:24 <djahandarie> zingi, usually more than two lines is spammy
11:46:26 * quuuux wonders what damage that did to Haskell's reputation...
11:46:49 <djahandarie> You can probably make a shitty quicksort look elegant in C too
11:47:06 <monochrom> that was the 90s and now we know better. easy inefficient algorithm is not acceptable.
11:47:08 <djahandarie> quuuux, anyways, if you have a bad assignment you can't really help it.
11:47:29 <djahandarie> Put in my golfed quicksort and confuse your professor
11:48:00 <aristid> or just use STArray :D
11:48:06 <shachaf> monochrom: Yes. CPUs aren't fast nowadays like they were in the 90s.
11:48:13 <djahandarie> quicksort = fix(\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z])
11:48:33 <monochrom> hahaha
11:48:44 <zingi> djahandarie: LMAO
11:48:57 <DevHC> djahandarie: r u fucking with me?
11:49:01 <mauke> > let quicksort = fix(\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z]) in quicksort ""
11:49:02 <lambdabot>   ""
11:49:12 <luite_> djahandarie: hmm, still quite long, it must be possible to outgolf that :)
11:49:13 <Heffalump> that's not very golfed
11:49:27 * shachaf wonders if quicksort on linked lists ever makes sense.
11:49:32 <quuuux> oh, wow. I love the `concat [f x | x <- take 1 xs]' trick
11:49:36 <maurer_> What are the guidelines for packaging things produced by the ffipkg command? Clearly they shouldn't be uploaded to a package server in that form, but I don't see any clear way to make a wrapper package depend on the results of ffipkg.
11:49:38 <aristid> @pl fix(\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z])
11:49:40 <lambdabot> fix ((join .) . flip flip [] . ((:) .) . ap (ap . ((++) .) . (. ((: [y < x]) . ((y | y) <-) . tail))) (((x :) .) . (`ap` take 1) . ((<-) .) . flip flip x . ((|) .) . (. ((: [y >= x]) . ((y | y) <-) .
11:49:41 <lambdabot>  tail))))
11:49:41 <Jafet> :t partition
11:49:42 <quuuux> I'm actually tempted to use that in some of my real code
11:49:42 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:50:01 <aristid> :t fix ((join .) . flip flip [] . ((:) .) . ap (ap . ((++) .) . (. ((: [y < x]) . ((y | y) <-) . tail))) (((x :) .) . (`ap` take 1) . ((<-) .) . flip flip x . ((|) .) . (. ((: [y >= x]) . ((y | y) <-) .tail))))  
11:50:02 <lambdabot> parse error on input `|'
11:50:07 <aristid> hahaha
11:50:17 <djahandarie> luite_, Heffalump, my goal was to fit it in a tweet. Perhaps it is possible to get it smaller. ;)
11:50:20 <Heffalump> pl can't manage list comprehensions, can it?
11:50:24 <djahandarie> Nope.
11:50:28 <shachaf> @. pl undo fix(\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z])
11:50:32 <lambdabot> fix (join . flip flip 1 . flip flip take . (join (=<<) .) . flip flip [] . ((flip . ((:) .)) .) . ap (ap . ((ap . ((++) .)) .) . flip . flip flip tail . (. flip (flip . flip ap return . (if' .) .
11:50:32 <lambdabot> flip (<)) []) . ($ (=<<))) ((ap (:) .) . flip . flip flip tail . (. flip (flip . flip ap return . (if' .) . flip (>=)) []) . ($ (=<<))))
11:50:32 <lambdabot> optimization suspended, use @pl-resume to continue.
11:50:47 <Heffalump> flip flip tail? wtf?
11:50:47 <shachaf> @pl-resume
11:50:53 <lambdabot> fix (join . flip flip 1 . flip flip take . (join (=<<) .) . flip flip [] . ((flip . ((:) .)) .) . ap (ap . (liftM2 (++) .) . flip . flip flip tail . (. flip (flip . (`ap` return) . (if' .) . flip (<)
11:50:53 <lambdabot> ) []) . ($ (=<<))) ((ap (:) .) . flip . flip flip tail . (. flip (flip . (`ap` return) . (if' .) . flip (>=)) []) . ($ (=<<))))
11:50:54 <lambdabot> optimization suspended, use @pl-resume to continue.
11:50:59 <djahandarie> Hahaha
11:51:00 <shachaf> Heffalump: What's wrong with flip flip tail?
11:51:02 <aristid> @undo fix(\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z])
11:51:02 <lambdabot> fix (\ s z -> concat concatMap (\ x -> [s concatMap (\ y -> if y < x then [y] else []) tail z ++ x : s concatMap (\ y -> if y >= x then [y] else []) tail z]) take 1 z)
11:51:03 <djahandarie> I think it's stuck in a loop
11:51:06 <Jafet> This is getting pointless.
11:51:08 <shachaf> @ty flip flip tail
11:51:08 <lambdabot> forall (f :: * -> *) b a. (Functor f) => f (([a] -> [a]) -> b) -> f b
11:51:16 <aristid> oh, @undo can remove list comprehensions
11:51:19 <quuuux> @type flip flip 1
11:51:19 <lambdabot> forall (f :: * -> *) a b. (Functor f, Num a) => f (a -> b) -> f b
11:51:25 <mauke> that looks broken
11:51:28 <mauke> missing parens?
11:51:36 <djahandarie> A lot of things look broken right now.
11:51:36 <Heffalump> oh, I see
11:52:23 <luite_> djahandarie: ah yes, long ago, code size was limited by primitive cpu's with tiny amounts of ram, nowadays it's twitter message limits
11:52:37 <djahandarie> Of course. We need to get with the times here.
11:53:25 <luite_> future supercomputers will use twitter for message passing
11:53:26 <aristid> note how a twitter message conveniently fits in a SMS. it even reserves 20 characters for the @sender
11:53:29 <monochrom> Prelude.Twitter.Types will have all data types definable in 140 words or less.
11:53:47 <quuuux> @type if'
11:53:48 <lambdabot> Not in scope: `if''
11:54:00 <quuuux> @unpl if'
11:54:00 <lambdabot> if'
11:54:09 <quuuux> which order does if' take parameters in?
11:54:11 <djahandarie> quuuux, it is just the function form of if then else.
11:54:15 <shachaf> quuuux: Same order as if.
11:54:18 <djahandarie> if' a b c = if a then b else c
11:54:32 <mauke> :t fix(\s z->[w|x:t<-z,w<-s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]])
11:54:33 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
11:54:33 <lambdabot>       Expected type: [t]
11:54:33 <lambdabot>       Inferred type: t
11:54:35 <mauke> aww
11:54:43 <quuuux> oh, I've seen a variety with the bool as the 3rd parameter
11:54:44 <aristid> tsk
11:55:06 <djahandarie> mergesort = let m(a:x,b:y)=[a:m(x,b:y),b:m(a:x,y)]!!fromEnum(a>b);m(x,y)=x++y;s l@(_:_:_)=m$s***s$splitAt(length l`div`2)l;s l=l in s
11:55:10 <djahandarie> Mergesort was harder.
11:55:23 <aristid> but you sneaked three stars in there
11:55:28 <djahandarie> Some people in here helped with that one
11:55:30 <aristid> :t join (***)
11:55:30 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:55:49 <luite_> djahandarie: and bogosort? :p
11:56:09 <djahandarie> luite_, I only have quantum bogosort written.
11:56:21 <mauke> :t fix(\s z->[w|x:t<-[z],w<-s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]])
11:56:22 <lambdabot> forall t. (Ord t) => [t] -> [t]
11:56:44 <djahandarie> > fix(\s z->[w|x:t<-[z],w<-s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]]) ""
11:56:46 <lambdabot>   ""
11:56:53 <djahandarie> > fix(\s z->[w|x:t<-[z],w<-s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]]) "blah blah blah"
11:56:55 <lambdabot>   "  aaabbbhhhlll"
11:56:55 <maurer_> What are the guidelines for packaging things produced by the ffipkg command? Clearly they shouldn't be uploaded to a package server in that form, but I don't see any clear way to make a wrapper package depend on the results of ffipkg.
11:56:59 <djahandarie> Nice.
11:57:06 <djahandarie> How did you get rid of the concat trick?
11:57:12 <mauke> >>=
11:57:40 <mauke> look at w
11:57:56 <luite_> it does look more golfy
11:58:49 <Jafet> > filter (and . ap (zipWith (<=)) tail) . permutations $ "foo bar"
11:58:51 <lambdabot>   [" abfoor"," abfoor"]
11:59:06 <Jafet> > head . filter (and . ap (zipWith (<=)) tail) . permutations $ "foo bar"
11:59:08 <lambdabot>   " abfoor"
11:59:12 <djahandarie> mauke, ah, I see it now. Is that actually shorter?
11:59:24 * hackagebot netlines 0.2.0 - Enumerator tools for text-based network protocols  http://hackage.haskell.org/package/netlines-0.2.0 (ErtugrulSoeylemez)
11:59:35 <luite_> Jafet: not quite bogosort though
11:59:52 <mauke> djahandarie: yes
12:00:04 <mauke> or maybe not
12:00:08 <djahandarie> > fmap length ["fix(\\s z->[w|x:t<-[z],w<-s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]])", "fix(\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z])"]
12:00:09 <lambdabot>   <no location info>:
12:00:09 <lambdabot>      lexical error in string/character literal at chara...
12:00:11 <mauke> I'm confusing two versions
12:00:17 <djahandarie> > fmap length ["fix(\\s z->[w|x:t<-[z],w<-s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]])", "fix(\\s z->concat[s[y|y<-tail z,y<x]++x:s[y|y<-tail z,y>=x]|x<-take 1 z])"]
12:00:18 <lambdabot>   [58,72]
12:00:48 <djahandarie> Quite a bit shorter
12:01:18 <mauke> oh, I thought you meant just the concat trick
12:01:24 <mauke> eliminating concat saved one char
12:01:47 <mauke> :t fix$\s z->[w|x:t<-[z],w<-s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]]
12:01:48 <lambdabot> parse error on input `->'
12:01:48 <Jafet> > head . filter (and . ap (zipWith (<=)) tail) . permutations $ "hello world"
12:01:52 <lambdabot>   mueval-core: Time limit exceeded
12:01:53 <mauke> heh
12:02:03 <djahandarie> Jafet, it worked!
12:02:14 <Jafet> I wonder what the expected runtime of bogosort is
12:02:37 <djahandarie> It can go forever iirc
12:02:40 <aristid> preflex: seen kamatsu
12:02:41 <preflex>  kamatsu was last seen on #haskell 26 days, 29 minutes and 1 second ago, saying: can't you just use ""?
12:02:46 <aristid> preflex: xseen kamatsu
12:02:46 <preflex>  kamatsu was last seen on freenode/#haskell 26 days, 29 minutes and 7 seconds ago, saying: can't you just use ""?
12:02:48 <shachaf> mauke: If it just saved one character, wouldn't join save two?
12:02:50 <roconnor> what is bogosort?
12:03:11 <luite_> Jafet: http://portal.acm.org/citation.cfm?id=1760624
12:03:14 <mauke> shachaf: yep
12:03:15 <quuuux> O(silly)
12:03:20 <djahandarie> roconnor, shuffle randomly until it's in order.
12:03:35 <roconnor> IIRC it has average run time of O(n!)
12:03:37 <luite_> Jafet: better link: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.148.7743
12:04:32 <roconnor> what is Landin's  SECD machine?
12:04:38 <djahandarie> What is the point of xseen? Is preflex on more than one network?
12:05:01 <revenantphx> Okay...
12:05:09 <revenantphx> so how can I specifically set a LaTeX document's sie.
12:05:14 <revenantphx> I want exactly 9.75"x7.5"
12:05:15 <revenantphx> >_>
12:05:18 <revenantphx> Having no luck with this.
12:05:31 <mauke> djahandarie: yes
12:05:48 <Jafet> I'm sure ##latex will help you with your masochistic needs
12:05:49 <shachaf> revenantphx: #latex might know better than #haskell. :-)
12:06:07 <revenantphx> shachaf: this is ture, but I asked before in here during an offtopic bit
12:06:10 <revenantphx> and was hoping to follow up
12:06:36 <mauke> > length "fix(\\s z->join[s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]|x:t<-[z]])"
12:06:37 <lambdabot>   57
12:06:47 <shachaf> Maybe #haskell-blah, then? :-)
12:07:39 <djahandarie> > fmap (fix(\\s z->join[s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]|x:t<-[z]])) ["", "test"]]
12:07:40 <lambdabot>   <no location info>: parse error on input `->'
12:08:14 <revenantphx> mauke: Obfuscated Haskell contest >_>?
12:08:19 <revenantphx> well, it's not that bad I guess.
12:08:19 <djahandarie> > fmap (fix(\s z->join[s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]|x:t<-[z]])) ["", "test"]]
12:08:20 <lambdabot>   <no location info>: parse error on input `]'
12:08:23 <djahandarie> Bah
12:08:24 <djahandarie> > fmap (fix(\s z->join[s[y|y<-t,y<x]++x:s[y|y<-t,y>=x]|x:t<-[z]])) ["", "test"]
12:08:24 <revenantphx> What's \\s for?
12:08:26 <lambdabot>   ["","estt"]
12:08:29 <revenantphx> ah there you go :P
12:08:42 <revenantphx> so... what is it >.>
12:08:46 <djahandarie> Quicksort.
12:08:50 <revenantphx> aaaah
12:08:52 <quuuux> > (>.>) (-.-) (<.<)
12:08:52 <revenantphx> Oh I see it now.
12:08:53 <shachaf> Non-quicksort.
12:08:54 <lambdabot>   "foobar"
12:09:08 <revenantphx> I still don't get fix/Mu correctly
12:09:13 <revenantphx> ._.
12:09:19 <conal> New blog post: http://conal.net/blog/posts/deriving-parallel-tree-scans/ 
12:10:03 <shachaf> revenantphx: "fix (\f -> ...)" is more or less the same as "let f = ... in f".
12:10:21 <revenantphx> but fix is... all recursive and stuff :|
12:10:22 <revenantphx> what.
12:10:24 <revenantphx> >_<
12:10:33 <revenantphx> > (>.>)
12:10:34 <lambdabot>   Not in scope: `>.>'
12:10:46 <revenantphx> :t (>.>)
12:10:46 <lambdabot> Not in scope: `>.>'
12:10:47 <djahandarie> revenantphx, the use of fix here is just a simple translation between   let f x = ... f x ... in f    to   fix(\f x -> ... f x ...)
12:10:50 <saml> > ke$ha
12:10:50 <lambdabot>   Not in scope: `ke'Not in scope: `ha'
12:11:08 <djahandarie> revenantphx, to save like, a character. :)
12:11:16 <revenantphx> djahandarie: confused XD
12:11:17 <revenantphx> oh wlel
12:11:18 <shachaf> revenantphx: You should read _The Little Schemer_. :-)
12:11:18 <saml> Absolute0, why?
12:11:20 <revenantphx> I have homework to do.
12:11:24 <revenantphx> shachaf: Yes I should.
12:11:37 <quuuux> > 2 + 2
12:11:38 <lambdabot>   Ambiguous occurrence `+'
12:11:38 <lambdabot>  It could refer to either `L.+', defined at <local...
12:11:41 <revenantphx> #latex still has given no answer.
12:11:43 <revenantphx> :|
12:11:48 <quuuux> :( Foiled, oh well
12:11:49 <saml> > 2 + 2 :: Int
12:11:49 <mauke> @undefine
12:11:50 <lambdabot>   Ambiguous occurrence `+'
12:11:50 <lambdabot>  It could refer to either `L.+', defined at <local...
12:11:51 <shachaf> revenantphx: It's written in a strict language which only makes it more confusing.
12:12:14 <shachaf> But nevertheless.
12:12:15 <saml> why u did that?
12:12:35 <djahandarie> conal, neat. You are writing machine. :)
12:12:52 <conal> djahandarie: :) several more in the pipeline.
12:12:59 <conal> writing helps me clarify my thinking.
12:13:18 <djahandarie> Writing helps force me to think. I don't know if it clarifies my thinking.
12:13:29 <conal> hah.
12:14:04 <arcatan> useful anyway
12:14:15 <Veinor> 15:18:52        <monochrom> surprisingly many profs choosing haskell for class have lost touch with the haskell community. for example we have realized for a decade that "qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)" is not
12:14:17 <Veinor>                             quicksort, and in fact is not a satisfactory sorter at all.
12:14:19 <Veinor> could you elaborate?
12:14:19 <djahandarie> Usually writing either English or [programming language] does that though. English generally annoys me though so I tend to not write much of it ;)
12:14:28 * hackagebot hopenssl 1.6 - FFI bindings to OpenSSL's EVP digest interface  http://hackage.haskell.org/package/hopenssl-1.6 (PeterSimons)
12:14:41 <djahandarie> Then again I don't write much Haskell either.
12:14:44 <mauke> monochrom: I have realized it is quicksort!
12:14:57 <kramble> it's not a quick sort
12:15:01 <kramble> it's a pivot sort
12:15:16 <conal> btw, i'm using pandoc & gitit for writing and some home-made gitit plugins. generates the html used in my blog posts.
12:15:18 <mauke> what's the difference?
12:15:29 <burp> any ideas how I can use fortran sources with cabal most comfortable? (a more flexible c-sources option would be nice where you can specify the compiler)
12:15:51 <kramble> quick sort is something where two cursors converge to the center of the list
12:15:55 <luite_> let's call it quacksort
12:15:55 <mauke> no
12:16:09 <kramble> and we switch elements between left and right
12:16:09 <sm> conal: nice, have you looked at hakyll also ?
12:16:14 <djahandarie> conal, why do you use unicode by the way? It tends to obscure things for me.
12:16:15 <mauke> kramble: says who?
12:16:35 <jmcarthur> conal: it occurs to me... is this a non-empty tree?  foo = Branch foo foo
12:16:40 <quuuux> @pl preflex : xseen dons
12:16:41 <lambdabot> preflex : xseen dons
12:16:45 <conal> sm: thanks for the reminder. i saw & liked hakyll and then forgot about it.
12:16:55 <kramble> mauke: wikipedia and every scientist i encounter
12:17:01 <conal> jmcarthur: in the sense of having no leaves.
12:17:08 <quuuux> hmm. Are preflex/lambdabot coded to ignore each other?
12:17:10 <mauke> kramble: [citation needed]
12:17:14 <conal> djahandarie: do you mean lambda, arrows, etc?
12:17:21 <mm_freak_> sm, conal: hakyll is nice, but some things are unnecessarily difficult to do
12:17:26 <jmcarthur> conal: the thought was just triggered by reading "Our trees will be non-empty and binary"
12:17:29 <sm> new version just released. I use the old one. I'm guessing it's simpler and easier to host than gitit
12:17:29 <djahandarie> conal, yeah, and the monoid stuff.
12:17:37 <sm> mm_freak_: oh like what ?
12:17:56 <djahandarie> conal, primarily the monoid stuff really. The :: and -> basically look exactly the same.
12:17:56 <conal> jmcarthur: ah! i guess that remark is inaccurate.
12:18:04 <kramble> mauke: http://en.wikipedia.org/wiki/Quicksort
12:18:07 <mm_freak_> sm: like taking all posts and generating an index out of them
12:18:15 <mm_freak_> sm: the API is /too/ opaque
12:18:38 <mm_freak_> well possible, but inconvenient
12:18:41 <conal> djahandarie: yeah. those notational changes makes the connection to Haskell less transparent.
12:18:45 <sm> in the new one ? It does not strike me as super user-friendly I will agree
12:18:45 <quuuux> @pl preflex xseen dons
12:18:45 <lambdabot> preflex xseen dons
12:18:46 <preflex>  dons was last seen on freenode/#haskell 2 hours, 38 minutes and 27 seconds ago, saying: just need ghc 7.0.2 blessed
12:18:52 <sm> compared to say jekyll
12:18:57 <djahandarie> conal, I personally avoid using unicode even in Agda where everything is written in unicode so I could just be a edge case. :P
12:19:05 <roconnor> Philippa: this CAM is kinda neat
12:19:18 <mm_freak_> sm: i don't know jekyll, but i'm not terribly fond of generating static pages anymore anway
12:19:38 <roconnor> Philippa: though it should probably be called CCCAM
12:19:39 <mm_freak_> my next homepage will by a dynamic yesod-based site
12:19:52 <luite_> kramble: the pseudocode is very similar to the haskell version
12:20:03 <conal> great to see these haskell-centric alternatives springing up
12:20:10 <kramble> luite_: those two algorithms look like they're the same, but no
12:20:14 <conal> php gives me nightmares.
12:20:19 <sm> interesting. Jekyll, for the record is the ruby static site generator, one of hakyll's inspirations. As usual, the ruby EDSL is super readable
12:20:39 <mm_freak_> sm: i assume that was a joke
12:20:53 <kramble> luite_: quicksort in 
12:21:17 <kramble> is in place (don't know english expression to mean in the arguments array, and didn't need more memory)
12:21:27 <acowley> djahandarie: What do you have against unicode in Agda?
12:21:32 <mauke> kramble: "Although quicksort is usually not implemented as an in-place sort, it is possible to create such an implementation."
12:21:35 <luite_> kramble: except that it isn't
12:21:42 <sm> not at all. I believe a regular user will get up to speed with jekyll far quicker than hakyll
12:21:53 <mauke> kramble: the "simple version" is equivalent to the haskell code
12:21:58 <kramble> mauke: quicksort is the algorithm described, if a sort is not implemented like that it's not quicksort
12:22:05 <revenantphx> I'm weird and find most unicode symbols look awkward in monospaced fonts.
12:22:06 <mauke> kramble: wrong
12:22:13 <mauke> kramble: http://en.wikipedia.org/wiki/Quicksort
12:22:20 <ShaneHudson> Silly question.. how do you pronounce Haskell? I usually say "Hask-ell" but I went to the University of Kent last week and they all called it "Hass-kool"
12:22:24 <revenantphx> I'd love a great monospace font with support for lots of mathematical symbols and stopp.
12:22:34 <kramble> mauke: it's not become one claims it's quicksort, it not necessary true
12:22:36 <luite_> I don't think it's possible to implement a really in-place quicksort, but I'd like to see
12:22:37 <revenantphx> ShaneHudson: It's supposed to rhyme with rascal I always that.
12:22:44 <revenantphx> luite_: why not >_>
12:23:03 <kramble> mauke: s/become/because/
12:23:05 <Jafet> No, it should not rhyme with "Pascal"
12:23:08 <luite_> revenantphx: since the maximum recursion depth depends on the length of the list
12:23:15 <revenantphx> Jafet: rascal, not Pascal
12:23:31 <mauke> kramble: I have no idea what you just said, but your wikipedia link directly contradicts your claims
12:23:45 <kramble> wich paragraphe ?
12:23:49 <acowley> revenantphx: I agree they can look a little funny, but I think the tradeoff is worth it
12:23:53 <Jafet> Well, I don't know what really rhymes with what.
12:23:57 <Runar> a ++ ((++) <$> a <*> a) ++ ((\x y z -> x ++ y ++ z) <$> a <*> a <*> a) ++ ...
12:24:01 <djahandarie> acowley, I'm not sure. I just know I get sorely confused when opening an Agda file with unicode in it compared to one without.
12:24:02 <mauke> kramble: the entire article?
12:24:03 <revenantphx> Jafet: Pascal is "Pahs-Kahl"
12:24:04 <acowley> revenantphx: primarily for little infix operators
12:24:16 <revenantphx> Jafet: Rascal is "rass-keul"
12:24:20 <revenantphx> idk, my phonetizing sucks.
12:24:20 <arcatan> the way i pronounce haskell rhymes with hell
12:24:32 <acowley> djahandarie: There is certainly a familiarity curve. Unicode cons seems designed to trip people up. 
12:24:35 <kramble> mauke: the article begin with reordering elements in the list, so qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs) is not quicksort
12:24:36 <Jafet> @check (\xs -> fix (liftM2 take length.ap(ap.((++).) . (.(filter=<<flip(<).head))) (liftM2(++)(filter=<<(==).head) . (.(filter=<<flip(>).head)))) xs == sort (xs::[Int]))
12:24:37 <lambdabot>   "OK, passed 500 tests."
12:24:40 <luite_> revenantphx: but perhaps there's a clever trick to make it use constant extra space
12:24:45 <mauke> kramble: no, it doesn't
12:24:53 <revenantphx> luite_: What's so hard about in-place quicksort >_>.
12:25:00 <mauke> kramble: the article begins with "Quicksort is a sorting algorithm developed by C. A. R. Hoare that, on average, makes O(nlogn) (big O notation) comparisons to sort n items."
12:25:00 <acowley> djahandarie: I found that I went from being really annoyed by it to liking it over a couple months. Back in Coq-land, I miss it quite a bit.
12:25:06 <ShaneHudson> Jafet: That is why I say "Hask-ell" to try to differate it from Pascal
12:25:13 <kramble> mauke: tjhe step are : 1. ... 2. reorder the list
12:25:22 <kramble> it's written in algorithm paragraph
12:25:34 <luite_> revenantphx: well, a real in-place algorithm only uses a constant amount of extra space
12:25:42 <mauke> kramble: it doesn't say "in place"
12:25:47 <Jafet> kramble: for all intents and purposes, this golf tournament defines quicksort to be one that partitions and recursively sorts lists. Any questions?
12:25:50 <revenantphx> luite_: If you're sorting integers, xor them and you have in-place.
12:26:01 <Jafet> This is not about quicksort at all, but about golf.
12:26:02 <kramble> mauke: in place is a poor translation of a french expression
12:26:04 <revenantphx> luite_: (or any simple type, such as pointers).
12:26:08 <mauke> kramble: no, it isn't
12:26:08 <acowley> I actually like revenantphx's phontecizing
12:26:10 <djahandarie> acowley, I think I might not be against using say, greek letters for type-level variables, but using various little symbols and stuff tends to just confuse me. For example, it gets hard for me to scan a file looking for where that character is defined.
12:26:12 <revenantphx> luite_: No need for a swap variable then.
12:26:14 <mauke> kramble: also, did you read the first paragraph?
12:26:30 <djahandarie> acowley, and I'd need to 'learn' how to scan for that character for every new character.
12:26:35 <revenantphx> djahandarie: I prefer |-> to the unicode arrow for instance >_>
12:26:47 <revenantphx> 'cause I'm weird.
12:26:50 <acowley> djahandarie: That's fair, and you also need to figure out how to enter that symbol.
12:26:53 <luite_> revenantphx: no, that's not the point. with usual quicksort implementations you need to recurse, which uses a bit of stack space in imperative languages. the maximum recursion depth depends on the input size
12:27:00 <kramble> mauke: ok, i read it, but it's one of the false statement of wikipedia
12:27:06 <kramble> the algorithm is clear enough
12:27:12 <revenantphx> luite_: Well, you can always cheat with goto's
12:27:17 <revenantphx> luite_: >
12:27:20 <revenantphx> luite_: :>
12:27:24 <acowley> djahandarie: But those symbols can and do shorten expressions built out of them, so I appreciate that improved readability in those cases
12:27:47 <kramble> mauke: or they do the quicksort on a copy of the array
12:27:54 <revenantphx> the point is not whether the implementation or not is in place, but whether the algorithm fundamentally requires additional space imo.
12:27:58 <djahandarie> acowley, yeah, probably after memorizing all the symbols and what they usually do it would become easier for me to read also.
12:28:02 <kramble> but the haskell code is not quicksort
12:28:13 <djahandarie> acowley, but it feels like a slightly unnecessary addition to the learning curve of Agda.
12:28:15 <mauke> kramble: [citation needed]
12:28:18 <luite_> revenantphx: that doesn't immediately solve the problem, since you need to store all kinds of offsets and lengths, to make sure that you sort the right part of the array in each recursive step
12:28:21 <revenantphx> For instance, an iterative quick sort requires 2n space, fundamentally.
12:28:27 <kramble> mauke: reafd the algorithm and compare
12:28:33 <mauke> kramble: that's not a citation
12:28:47 <revenantphx> iterative merge sort*
12:28:48 <kramble> mauke: i won't past a wiki pargraph here
12:28:53 <mauke> kramble: you yourself said <kramble> mauke: ok, i read it, but it's one of the false statement of wikipedia
12:29:03 <acowley> djahandarie: I agree, and like revenantphx is complaining about, some of the characters can end up rather unpleasant. I have no clue about fonts, so I've never tried tweaking at that level.
12:29:04 <mauke> wikipedia is not a credible source
12:29:05 <kramble> quicksort is in place
12:29:11 <luite_> kramble: it isn't
12:29:33 <luite_> kramble: not according to the definition of in-place algorithm on wikipedia at least :p
12:29:44 <revenantphx> acowley: It'd be wonderful if there was a nice font though.
12:29:51 <revenantphx> acowley: I just like using size 11 monospace fonts so...
12:29:55 <kramble> i always read this algorithm in place, it's the first time i read it's not in place, and I'm asking myself why
12:29:55 <revenantphx> doesn't match well with unicode math
12:30:02 <djahandarie> Dejavu Sans Mono has a lot of unicode in it.
12:30:33 <revenantphx> You know a nice font (for math?)
12:30:34 <revenantphx> AMS Euler.
12:30:37 <revenantphx> That's a nice font :|.
12:30:47 <revenantphx> http://en.wikipedia.org/wiki/File:AMS_Euler_sample_math.svg
12:30:48 <luite_> kramble: in-place means constant amount of extra space, independent of inpunt size
12:30:48 <revenantphx> so pretty.
12:31:00 <kramble> luite_: no it's mean you work in the input array
12:31:05 <luite_> kramble: nope
12:31:06 <FUZxxl> Hey out there!
12:31:20 <FUZxxl> Is there anyone with knowledge of Attoparsec?
12:31:23 <kramble> luite_: in place ? i'm french but i understand in and place
12:31:33 <mauke> kramble: the stack is a place
12:31:35 <acowley> revenantphx: Why the straight face?
12:31:42 <kramble> mauke: it's mean in the input place
12:31:51 <mauke> kramble: I don't believe you
12:31:58 <revenantphx> acowley: I'm humbled by it's niceness.
12:32:24 <kramble> is an algorithm which transforms input using a data structure with a small, constant amount of extra storage space. The input is usually overwritten by the output as the algorithm executes
12:32:25 <companion_cube> kramble, "in place" means that it modifies the input structure without allocating more memory
12:32:34 <kramble> so it implie that sort is done in the input array
12:32:43 <kramble> otherwise it would be impossible to implement
12:33:01 <luite_> kramble: yes, in-place implies that the input array is overwritten, but the converse is not true
12:33:10 <mauke> quicksort needs more than constant extra storage
12:33:33 <kramble> luite_: ok, (but for me sort in the array but using memory without limit is stupid, but you're right)
12:33:38 <companion_cube> quicksort in C does not, does it ?
12:33:48 <mauke> companion_cube: yes, it does
12:33:53 <companion_cube> of course, in haskell, there is no such thing as in place
12:33:57 <luite_> kramble: well there are algorithms that are actually in-place, like quicksort isn't ;p
12:34:01 <mauke> companion_cube: yes, there is
12:34:07 <companion_cube> mauke, to store what ?
12:34:15 <mauke> companion_cube: stack frames
12:34:27 <kramble> the quicksortS I learn at school were all in place
12:34:46 <kramble> and the haskell code is still not quicksort
12:34:48 <companion_cube> mauke, but quicksort with pointers do not use stack
12:34:50 <luite_> let them add their quicksorts to wikipedia then :p
12:35:05 <mauke> companion_cube: how so?
12:35:16 <luite_> companion_cube: you probably have to  keep some array/stack of offsets somewhere. if you don't please show your implementation 
12:35:35 <companion_cube> oops, i think i'm wrong
12:35:43 <companion_cube> sorry guys :s
12:36:19 <luite_> anyway, I don't really have a problem with calling that haskell example quicksort :)
12:36:23 <kramble> just to finish, (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs) is not quicksort
12:36:31 <mauke> yes, it is
12:36:36 <kramble> no
12:36:44 <kramble> it's not the algorithm
12:36:48 <kramble> it's another sort
12:37:04 <mauke> but no one else agrees with you
12:37:28 <kramble> where did you recognize the algorithm in this haskell code ?
12:37:38 <kramble> there is no switch, no reordering
12:37:38 <mauke> in the haskell code
12:37:42 <mauke> it's not exactly long
12:37:56 <kramble> there is a pivot, that's all
12:38:06 <kramble> pivot doesn't imply quicksort
12:38:07 <mauke> and there's a left sublist, and a right sublist
12:38:11 <mauke> and they're sorted recursively
12:38:17 <mauke> and the results are concatenated
12:38:27 <kramble> it's not quicksort
12:38:29 <mauke> just like the pseudocode on wikipedia
12:38:49 <kramble> mauke: you didn't read the pseudo code, otherwise you won't say taht
12:39:07 <Jafet> @check \xs -> fix (liftM2 take length . (join.).(.flip(map.(flip=<<(filter.).flip((.).(==)).compare.head))[GT,EQ,LT]) . zipWith id.ap(:)((id:).(:[]))) xs == sort (xs :: [Int])
12:39:08 <lambdabot>   "OK, passed 500 tests."
12:39:19 <mauke> er, you didn't even read the wikipedia article before telling me to look at it
12:39:36 <mauke> and now I've finished reading it
12:39:40 <Jafet> Probably can't get it much shorter unless I start pl-ing it by hand
12:39:50 <kramble> mauke: where in this haskell algorithm you see a reorder of the list
12:39:54 <kramble> where ?
12:40:12 <mauke> where in the simple pseudocode do you see a reorder of the list?
12:40:15 <kramble> there is creation of two sublists, these two algorithms are similar
12:40:18 <sgronblo> Does haskell have a function that retrieves all elements from a list using another list of indices to get?
12:40:37 <kramble> mauke: second step of algorithm
12:40:37 <maurer_> map (!!)
12:40:46 <mauke> sgronblo: usually I'd say zipWith, but that's rather inefficient
12:40:47 <maurer_> err
12:40:59 <mauke> kramble: "var list less, greater"
12:41:08 <maurer_> > map ([4, 5, 6] !!) [1, 2]
12:41:09 <lambdabot>   [5,6]
12:41:21 <maurer_> sgronblo: I'd just do it that way.
12:41:23 <mauke> oh, right
12:41:32 <kramble> mauke: to reorder you switch element from left with element from right
12:41:34 <mauke> (still inefficient because !! is linear)
12:41:36 <Jafet> @pl quicksort xs = take (length xs) $ concat $ zipWith ($) [quicksort, id, quicksort] $ map (\r -> filter ((r==) . compare (head xs)) xs) [GT,EQ,LT] -- for reference
12:41:37 <lambdabot> quicksort = fix (liftM2 take length . (join .) . (. flip (map . (flip =<< (filter .) . flip ((.) . (==)) . compare . head)) [GT, EQ, LT]) . zipWith id . ap (:) ((id :) . return))
12:41:39 <kramble> the haskell code didn't do that
12:41:48 <mauke> kramble: you're not listening to me
12:41:56 <kramble> mauke: i listen i reacocard d
12:41:57 <mauke> so I'm going to stop talking
12:42:01 <sgronblo> maurer_: thanks, I don't worry about the efficiency atm though
12:42:03 <kramble> i read, but you confuse things
12:42:24 <kramble> kramble: implement the two and come back, i did it, not you
12:42:40 <jmcarthur> conal: hey i commented on your blog but it's very short and i think i might expand on it a bit, so you can just delete it instead of approving it
12:42:48 <kramble> am i wrong ? do you implement the two ?
12:42:50 <Jafet> @pl quicksort xs = concat $ zipWith ($) [quicksort, id, quicksort] $ map (\r -> filter ((r==) . compare (head xs)) xs) [GT,EQ,LT]
12:42:51 <lambdabot> quicksort = fix ((join .) . (. flip (map . (flip =<< (filter .) . flip ((.) . (==)) . compare . head)) [GT, EQ, LT]) . zipWith id . ap (:) ((id :) . return))
12:43:08 * conal looks
12:43:28 <maurer_> sgronblo: If you need efficiency (e.g. they are huge) you can try: "map ((Data.IntMap.fromList $ zipWith [0..] listOfData) Data.Map.!) listOfIndices"
12:43:38 <maurer_> That will be slower for small lists, but if the list is big enough, it can be faster
12:44:02 <maurer_> Alternatively, if you sort the list of indices first, you can use an alternating take/drop
12:44:11 <maurer_> Which is likely the fastest, but may require 2 or 3 lines of code.
12:44:14 <conal> jmcarthur: is my tree type not already a cofree comonad?
12:44:24 <kramble> mauke: haskell code is not in place, it can't be, quickqsort can be
12:44:31 <kramble> that's the difference
12:44:34 <jmcarthur> conal: it's Free Vec2
12:45:02 <maurer_> Anyone know how to make ffipkg link against a .a static library?
12:45:03 <conal> jmcarthur: ah. i'll reread the defs. thx. i'm happy to pass your comment through. would you like me to?
12:45:13 <jmcarthur> conal: here's a cofree comonad:  data T a = Leaf a | Branch (T a) a (T a)
12:45:44 <lpsmith> kramble,  you can implement a mostly in-place quicksort in Haskell
12:45:53 <jmcarthur> conal: woops wrong
12:45:54 <lpsmith> Use the ST monad, for instance
12:46:08 <jmcarthur> well that is a cofree comonad, actually
12:46:13 <kramble> lpsmith: yes but we were comparing two precise algorithm (i hope that i can implement what i want with haskell :D )
12:46:23 <jmcarthur> conal: but i was thinking of  data T a = Branch (T a) a (T a)
12:46:25 <conal> jmcarthur: do you have a url handy for the defs?
12:46:27 <jmcarthur> infinite trees only
12:46:33 <jmcarthur> hmm
12:46:35 <maurer_> kramble: What are you attempting to do? Define your problem more clearly.
12:46:55 <jmcarthur> conal: i could just write them here. edwardk's blog or category-extra has them in some form, i'm sure
12:47:00 <conal> jmcarthur: ah, yeah. both show up in some of my recent posts. That latter one is a trie.
12:47:06 <dolio> Cofree F A = A * F (Cofree F A)
12:47:08 <kramble> maurer_: just explain why filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs is not quicksort
12:47:19 <jmcarthur> ah dolio is ahead of me
12:47:20 <maurer_> kramble: But it is, so explaining that would be impossible.
12:47:28 <kramble> maurer_: it's not
12:47:35 <kramble> go implement the two, and come back
12:47:39 <lpsmith> In some sense it is,  in another sense it isn't
12:47:46 <kramble> lpsmith: thank you
12:48:14 <lpsmith> but mergesort works so much better in Haskell
12:48:24 <lpsmith> at least if you are sorting ordinary lists
12:48:25 <maurer_> kramble: It a.) picks a pivot, b.) separates the list based on the pivot, and c.) joins everything together around the pivot
12:48:34 <jmcarthur> conal: basically it's cofree if all constructors have a value and it's free if none of them do except for one constructor that has nothing but a value
12:48:42 <kramble> maurer_: that is not the defntion of quicksort
12:48:51 <kramble> it's very similar, but it's not
12:48:58 <jmcarthur> conal: that is, it's cofree if the tree has values at the nodes and free if the values are at the leaves
12:49:01 <dolio> Free F A = A + F (Free F A)
12:49:02 <augustss> kramble: exactly
12:49:21 <jmcarthur> s/nodes/branches/
12:49:54 <conal> jmcarthur: thx. would you like me to pass through your comment now or would you like to elaborate on it first?
12:50:05 <maurer_> kramble: The only thing you could even claim is that the partitioning step is different, which is silly if you're choosing to operate on an immutable input.l
12:50:15 <jmcarthur> conal: i'll just leave it i guess. i was able to explain here at least
12:50:23 <jmcarthur> unless you'd like me to expand on it there
12:50:25 <dolio> Also, Cofree should be a greatest fixed point, and Free should be least, if that makes a difference (which it doesn't in Haskell).
12:50:32 <conal> jmcarthur: done
12:50:38 <mm_freak_> what's a good language to low level number crunching with a good interface to haskell?
12:50:47 <edwardk> jmcarthur: the data T a = Branch (T a) a (T a) is a convenient trie for zeroless binary numbers
12:50:47 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
12:50:48 <mm_freak_> having to do the FFI stuff manually would be no concern
12:51:09 <Jafet> kramble should try IO String -> String next time.
12:51:14 <edwardk> @tell djahandarie long done
12:51:14 <lambdabot> Consider it noted.
12:51:16 <augustss> maurer_: I would claim you can't do the real quicksort immutably.
12:51:22 <djahandarie> edwardk, :)
12:51:23 <lambdabot> djahandarie: You have 1 new message. '/msg lambdabot @messages' to read it.
12:51:46 <mauke> augustss: how do you define "real"?
12:51:53 <kramble> maurer_: yes but the big difference between this two algos
12:52:06 <zygoloid> mauke: "the one described in the paper published by Hoare" ?
12:52:09 <edwardk> mauke: lennart has a nice blog post on the topic
12:52:21 <augustss> mauke: it has to have the clever partitioning of the imperative formulation of quicksort
12:52:30 <zygoloid> fortunately you can do it in ST :)
12:52:51 * mauke sighs at "the imperative formulation"
12:53:14 <augustss> mauke: imperative quicksort is beautiful
12:53:16 <mauke> the pseudocode at wikipedia is imperative and creates two new sublists
12:53:16 <kramble> quciksort is an imperative algo, which doesn't need a malloc
12:53:44 <augustss> kramble: it does need stack, though
12:53:47 * pozic notes there is no definition of functional and stops a new discussion about nothing at all.
12:53:49 * hackagebot hakyll 3.0.0.4 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.0.4 (JasperVanDerJeugt)
12:53:54 <sgronblo> Anyone using vim here, I tried this indent/haskell.vim I found on vimscripts, but it doesn't really seem to work that well.
12:54:08 <kramble> augustss: yes but a fixed quantity so you can embed it everywhere
12:54:08 <Jafet> It's not so much intrinsically imperative as inherently impure
12:54:13 <Jafet> Try saying that really fast
12:54:16 <jmcarthur> pozic: there are many definitions of functional :\
12:54:45 <augustss> kramble: worst case O(log n), so yeah, not much
12:54:52 <pozic> jmcarthur: not one of them can be tested formally. 
12:54:58 <kramble> augustss: O(n * n) ?
12:54:59 <kramble> no ?
12:55:28 <zygoloid> there's nothing for it. someone will need to get in touch with Tony Hoare and ask him if he thinks it's a quicksort.
12:55:31 <augustss> kramble: I was talking about stack space, not time
12:55:45 <lpsmith> Though the difference between the functional "quicksort" and quicksort is substantial,  it is much smaller than the  sieve (p:ns) = p : sieve [ n | n <- ns,  n `mod` p /= 0 ]  and the Sieve of Eratosthenes
12:55:48 <zygoloid> iirc he works at MSR now so maybe one of the simons can ask ;-)
12:55:59 <kramble> augustss: i'm sur you can do it in fixed space
12:56:12 <augustss> kramble: I don't think so
12:56:26 <augustss> kramble: you can do heapsort in fixed space
12:56:44 <kramble> i remember an algorithm similar to quicksort in fixed space
12:57:12 <mauke> me too: bubblesort
12:57:18 <edwardk> =)
12:57:23 <augustss> kramble: i don't see how, but i regard log n as a constant anyway. :)
12:57:29 <luite_> mauke: it even has the same worst case complexity
12:57:37 <kramble> augustss: there is a version on wikipedia in fixed space (the one I know)
12:57:42 <kramble> (really complex to coe)
12:57:42 * Philippa hands augustss an array encoded in a planet-sized chunk of computronium
12:57:44 <luite_> kramble: no
12:57:46 <kramble> s/coe/code/
12:57:49 <mauke> kramble: no, you're wrong, please stop talking
12:57:58 <kramble> mauke: i'm wrong about what ?
12:58:04 <mauke> everything, basically
12:58:18 * Heffalump recommends calming down
12:58:25 <edwardk> relax
12:58:39 <edwardk> while he is wrong, we can at least be civil about it ;)
12:59:25 <Philippa> kramble: you can't do quicksort in fixed space because each call must make /two/ recursive calls. You can make the second one a tail call, is that what you're thinking of?
12:59:42 <kramble> mauke: i'm wrong ? you're sure ?
12:59:42 <kramble> Philippa: http://pastebin.com/0uDNYuRH
12:59:42 <kramble> from wikipedia
12:59:42 <kramble> in space
12:59:57 <kramble> yeah ?
13:00:00 <kramble> capish ?
13:00:00 <augustss> Philippa: you want to make the larger one the tail call
13:00:07 <mauke> kramble: yes, I'm sure
13:00:07 <Wolfspaw> Hello everybody, my course in computer science is coming to an end and I need to choose a topic for my end-course-project, I'm thinking of doing on Functional Reactive Programming and Games (as Yampa or Frag), is there recent material on it? (as far Yampa Frag are 3 years ago, 2008)
13:00:15 <zygoloid> once you've recursed all the way down to the bottom the first time, you need log n extra pieces of information to find your way back.
13:00:15 <Wolfspaw> I have 1 year to do it, is it a bad idea?
13:00:25 <Philippa> augustss: sure, you get to assign what "second" means :-)
13:00:35 <augustss> Philippa: yep
13:00:36 <luite_> kramble: the problem is in the recursion depth, longer lists will require more recursion
13:00:37 <Philippa> (at least, in terms of the array)
13:00:40 <luite_> kramble: in the worst case
13:00:47 <edwardk> kramble: note the two calls
13:00:48 <kramble> luite_: there is way to do it in place
13:00:52 <kramble> it's really tricky
13:01:03 <Philippa> it's not "really tricky", it's the one we're talking about. It still needs stack space
13:01:18 <kramble> Philippa: we're not talking about the same
13:01:30 <jmcarthur> Wolfspaw: http://conal.net/papers/push-pull-frp/
13:01:35 * zygoloid thinks that if the haskell "quicksort" /is/ a quicksort, then we need another name for the more specific in-place array-based quicksort algorithm
13:01:38 <luite_> kramble: if you change the last to calls from quicksort(...) to heapsort(...) yes, then it's in-place :p
13:01:42 <kramble> there is a really tricky one, taht a few of you here have implemented
13:02:00 <kramble> otherwise you wouldn't argue with someon which did taht
13:02:06 <kramble> when ignorants speak...
13:02:11 <augustss> kramble: wikipedia seems to claim the space is O(log n)
13:02:12 <edwardk> i think you are confusing in-place partitioning with the lack of extra memory usage mentioned above w.r.t quicksort vs. heapsort
13:02:28 <kramble> what is this algo http://pastebin.com/0uDNYuRH
13:02:30 <kramble> ?
13:02:35 <kramble> what does it do ?
13:02:38 <zygoloid> kramble: the pseudocode which you claimed runs in constant space does not. do you have other pseudocode to show us?
13:02:45 <c_wraith> yes, the space in quicksort is O(log n), because of the stack.
13:02:45 <Wolfspaw> jmcarthur: thanks! I'll read it
13:02:52 <luite_> kramble: yes it's quicksort, but it still uses O(log n) space becasue of space space for the recursion
13:03:06 <mauke> *stack space
13:03:07 <luite_> kramble: with longer lists, you may have to recurse more often, so the extra space is not constant
13:03:18 <luite_> stack space that is
13:03:19 <kramble> ok i have to seak for the version in place
13:03:21 <edwardk> kramble: it uses a potentially terribel amount of stack space, because it naively doesn't even chose the correct sublist for recursion.
13:03:21 <dahankzter> isnt the famous C quicksort "in-place" rather than in space?
13:03:24 <edwardk> er terrible
13:03:25 <jmcarthur> Wolfspaw: the hackage package going with that: http://hackage.haskell.org/package/reactive
13:03:30 <augustss> kramble: your pastebin is O(n) space
13:03:32 <edwardk> er for the tail call
13:03:32 <kramble> this algo is not the one i implemented years ago
13:03:48 <jmcarthur> Wolfspaw: also see http://hackage.haskell.org/package/grapefruit-frp and http://hackage.haskell.org/package/elerea
13:04:15 <luite_> kramble: it's quite unlikely that the one you implemented is actually in-place, but if you can still find the code, by all means paste it, and we can analyze its complexity 
13:04:54 <edwardk> kramble: the in-place, is talking about the partitioning, not the stack. there is still a logarithmic amount of stack space being consumed
13:04:59 <augustss> kramble: the naive one you pasted is O(n) space, but you can do O(log n).  I don't believe you can do better.  You'll have to show me.
13:05:21 <edwardk> (in your case linear, but in the best case, logarithmic)
13:05:31 <companion_cube> that's interesting to see how many people did think this algo was in place because they did not think ofthe stack space
13:05:43 <kramble> sorry guys, i trust wikipedia, sorry
13:05:50 <kramble> this algo is not in space
13:05:53 <Wolfspaw> jmcarthur: alright! Taking note of those too, thanks! 
13:05:59 <mauke> wikipedia says the same thing
13:05:59 <kramble> i'm sorry , wiki is full of crap sometime
13:06:00 <Philippa> companion_cube: "in place" isn't the same thing as constant space
13:06:06 <edwardk> kramble: the wikipedia article: To make sure at most O(log N) space is used, recurse first into the smaller half of the array, and use a tail call to recurse into the other. 
13:06:11 <augustss> kramble: so quote where wikipedia says you can do it in O(1) extra space
13:06:18 <edwardk> kramble: your own source is telling you that
13:06:19 <companion_cube> Philippa, maybe that's the cause for the confusion too
13:06:22 <companion_cube> at least for me :/
13:06:32 <kramble> i read that : "Another implementation that works in place", and i didn't check
13:06:40 <kramble> it was a false statement
13:06:45 <edwardk> kramble: in place is talking about how it manipulates the pivot.
13:06:55 <Philippa> it means it doesn't copy the array it's sorting
13:06:58 <jmcarthur> kramble: in-place is not the same as constant space
13:07:05 <quuuux> @let foo = "     > replicate 19 (replicate 7 'a') ++  [foo] -- "
13:07:06 <lambdabot>  Defined.
13:07:12 <quuuux> > replicate 19 (replicate 7 'a') ++ [foo] -- "]
13:07:14 <lambdabot>   ["aaaaaaa","aaaaaaa","aaaaaaa","aaaaaaa","aaaaaaa","aaaaaaa","aaaaaaa","aaa...
13:07:25 <edwardk> kramble: it still uses a big ole honkin stack to track what its doing ;)
13:07:31 <quuuux> oh, bah. That works with /msg!
13:07:36 <augustss> kramble: when all of #haskell is against you, chances are very good you are wrong. :)
13:08:16 <pozic> augustss: that sounds almost like a democrazy.
13:08:39 <djahandarie> http://books.google.com/books?id=oaVq6dbw37kC&pg=PA283&lpg=PA283&dq=quicksort+constant+space+parallel&source=bl&ots=Viov9F1DaD&sig=KaSK_RPKUbE5MmQenik1PIujxXs&hl=en&ei=d2htTceAIsL7lweuhcitBQ&sa=X&oi=book_result&ct=result&resnum=2&ved=0CBwQ6AEwAQ#v=onepage&q&f=false claims it has a O(1) quicksort
13:09:00 <edwardk> pozic: meritocracy more like, the ph.d to nick ratio around here is higher here than in any other channel i've ever seen ;)
13:09:03 <augustss> pozic: here it's a meritocrazy
13:09:20 <Jafet> Where trolling is responded to in magnificent 5.1.
13:09:39 <dahankzter> the wikipedia entry is clear too, log(n) space even for in place algo
13:09:53 <Philippa> djahandarie: hrmm, I guess you can do it by keeping the original array bounds and effectively computing where you are in the 'tree' and thus where to go next
13:10:06 <companion_cube> edwardk, you mean it's 2 phD/nick in average ? :)
13:10:18 <sgronblo> numberedInputLines <- zip [0..] (lines $ hGetContents handle) is it possible to get this working without having to get the contents using <- on a separate line first?
13:10:26 <edwardk> companion_cube: yeah, i'm dragging the average down =/
13:10:32 * companion_cube too
13:10:50 <Philippa> dunno what you're complaining about, I never finished my first degree :p
13:11:08 <djahandarie> I'm still in progress. :)
13:11:08 <aavogt> sgronblo: <- (zip [0..] . lines) `liftM` hGetContents handle
13:11:22 <quuuux> sgronblo: x <- fmap (zip [0..] . lines) $ hGetContents handle
13:11:29 <edwardk> clearly this is why SPJ stays away, he doesn't want to dilute that metric.
13:11:50 <djahandarie> What, does he have 3 PhDs? ;)
13:11:54 <Jafet> I'm just here to balance out the grade curve
13:11:55 <Wolfspaw> hehehehe
13:12:14 <Philippa> @remember <companion_cube> edwardk, you mean it's 2 phD/nick in average ? :) <edwardk> clearly this is why SPJ stays away, he doesn't want to dilute that metric.
13:12:15 <lambdabot> Done.
13:12:17 <sgronblo> ah yeah i read about functors and fmap recently so I guess that's the way I could have come up with myself
13:12:31 <companion_cube> yay, i'm in lambdabot's database now \o/
13:13:17 <Jafet> sgronblo: http://www.haskell.org/pipermail/reactive/2008-November/000047.html
13:13:52 <companion_cube> sgronblo, then you'll read about Control.Applicative...
13:14:11 <sgronblo> companion_cube: yeah it came up today while reading lyah on the bus
13:15:22 <sgronblo> but i stopped reading just when i got to the part where it showed how those applicative functors worked with lists
13:16:01 <pozic> djahandarie: nice reference.
13:16:50 <edwardk> djahandarie: nah, he followed that time tested path of running screaming from academia off to industry before completing one. 
13:16:58 <augustss> djahandarie: looks like a cool algorithm.  I'm not sure it's quicksort anymore, but it is certainly similar
13:17:10 * djahandarie 's head explodes
13:17:23 <djahandarie> edwardk, ah.
13:17:42 <augustss> edwardk: that's not actually the truth
13:18:17 <Jafet> Katajainen et al have an in-place stable linear-logarithmic time mergesort
13:18:42 <augustss> edwardk: SPJ became a professor without a phd.  then he left for industry.
13:18:46 <kramble> my memory was wrong, the algo of my teacher wasn't in place
13:18:52 <Jafet> Conveniently, I think they don't derive the constants
13:19:08 <edwardk> augustss: i knew he was doing the professor thing sans ph.d but i wasn't sure about the relative timeline.
13:19:50 <edwardk> kramble: sok, djahandarie supplied one in your absence ;)
13:19:55 <augustss> edwardk: lecturer at UCL, professor at Glasgow, researcher at MSR
13:20:05 <beastaugh> Robin Milner never got a PhD either
13:20:21 <kramble> edwardk: he succeed ? can i have the code
13:20:23 <augustss> beastaugh: (except honorary)
13:20:33 <edwardk> i never made it past the lecturer stage before escape back to industry
13:20:42 <companion_cube> Milner did not have a PhD ? oO
13:20:44 <djahandarie> kramble, it isn't really a 'quicksort' though. It drops some other sorts in the middle of it for good measure.
13:20:53 <djahandarie> kramble, http://books.google.com/books?id=oaVq6dbw37kC&pg=PA283&lpg=PA283&dq=quicksort+constant+space+parallel&source=bl&ots=Viov9F1DaD&sig=KaSK_RPKUbE5MmQenik1PIujxXs&hl=en&ei=d2htTceAIsL7lweuhcitBQ&sa=X&oi=book_result&ct=result&resnum=2&ved=0CBwQ6AEwAQ#v=onepage&q&f=false
13:21:50 <djahandarie> kramble, I'd still say quicksort is O(log^2 n) in terms of space usage. Just that you can apparently modify it some to stop using stack space and achieve O(1)
13:21:57 <augustss> Still log n < 64.  It used to be log n < 32, but times change. :)
13:22:29 <kramble> djahandarie: saw that, so it can't be embeded (that's why i use heapsort)
13:22:52 <augustss> also, heapsort is stable
13:23:06 <djahandarie> I don't think I've ever seen this algorithm anywhere before though, I wonder why it ended up under the radar.
13:23:13 <edwardk> =) if oleg can use the fixed size of pointers to claim that algorithms that use functional references have the same asymptotics as imperative ones, who am I to argue. ;)
13:23:27 * djahandarie takes a note to try and implement it and see how it does
13:23:46 <edwardk> djahandarie: clearly you need to find a better link and add an addendum to the wikipedia article
13:24:57 <lpsmith> So what if your machine supports variable-sized pointers?
13:25:29 <kramble> djahandarie: the more i read your algo, the more it reminds me the one of my teacher
13:25:29 <losvedir> is there any way I can trouble some haskellers to critique my little 9 line function? http://pastebin.com/x0k2qX3m
13:25:43 <losvedir> i'm new to haskell and while it's a beautiful language, i'm kind of overwhelmed at the options
13:25:47 <Jafet> I really can't imagine how to reasonably exhaust a 64-bit address space.
13:26:06 <ion> The options?
13:26:11 <losvedir> i have some guards, nested wheres. should i use a let?
13:26:14 <kramble> if we do true complexity analysis, there is only linked list
13:26:28 <djahandarie> kramble, was this lecture in the early 90s? Maybe your lecturer wrote this algorithm :)
13:26:53 <djahandarie> Anyways I need to run, o/
13:26:56 <kramble> djahandarie: maybe he read it
13:27:16 <lpsmith> losvedir:  You probably want to avoid   parsed ++ [[op]]
13:27:22 <lpsmith> that's slow
13:27:40 <lpsmith> as you have to make a complete copy of the "parsed" list every time
13:27:53 <losvedir> lpsmith: ah, great! good to know, thank you
13:28:06 <pozic> lpsmith: that is an example of something a compiler could optimise, no?
13:28:46 <pozic> lpsmith: using difference lists (a common solution) is just as well a hack as some XOR linked list hack.
13:29:04 <losvedir> lpsmith: is there a quick fix, or does that mean i should think about a different strategy?
13:29:20 <lpsmith> pozic, yes,  but GHC doesn't.   Moreover those kinds of optimizations might prove to be more trouble than they are worth
13:29:44 <pozic> lpsmith: do you think it would take too long to recognize this situation?
13:29:46 <lpsmith> losvedir, you could do  [op] : parsed   and token:parsed instead
13:30:17 <lpsmith> and then return  "reverse parsed" at the end.
13:30:22 <losvedir> lpsmith: ah, interesting, just stick it to the front. then at the very end, i suppose i could reverse the list
13:30:28 <lpsmith> exactly :)
13:30:46 <losvedir> yay, thanks! : )
13:30:50 <pozic> lpsmith: do you have any idea how much harder it becomes to prove correctness, because of that?
13:31:04 <kramble> does this variable (function) "Monad m => m ()" exist in the standard haskell library ?
13:31:05 <lpsmith> Or you could use difference lists or Data.Sequence,  if you don't like that approach
13:31:28 <lpsmith> pozic, my thought was more along the lines of "will this optimize break my intentions somewhere else"
13:31:47 <acowley> kramble: You mean "return ()"?
13:31:56 <lpsmith> You are giving up control to the compiler,  so you might have more difficulty doing exactly what you want to do in another situation
13:31:58 <mauke> kramble: def from Data.Default
13:31:59 <kramble> acowley: yes, mone (like i like to call it)
13:32:24 <losvedir> lpsmith: interesting, i'll have to take a look at those
13:32:31 <pozic> lpsmith: yeah, it's just that I have been proving the correctness of some functional version of some trivial C algorithm and it becomes much larger, because all the invariants need to hold reversed versions of all the data.
13:33:02 <pozic> lpsmith: the Hoare semantics would fit on 3 lines. In my program, jus the type is already 7 lines.
13:33:14 <sgronblo> eh how do you print an IO action directly?
13:33:18 <pozic> lpsmith: er, just the type of an important lemma.
13:33:25 <edwardk> sgronblo: what would that mean
13:33:47 <Saizan> you could do the equivalent of hoare triplets in type theory too
13:34:00 <sgronblo> without having to um left arrow it first and then map putStrLn on to it. so umm how do you print an IO [String] directly?
13:34:06 <pozic> Saizan: yes, but YNot does not compile.
13:34:07 <edwardk> saizan: in fact, greg morrisett has a bunch of guys doing just that ;)
13:34:17 <pozic> edwardk: and it doesn't compile. 
13:34:25 <jmcarthur> sgronblo: what is the value of an IO [String]?
13:34:26 <edwardk> sgronblo: you can't.
13:34:33 <pozic> (I think it was a very good idea to make it somewhat more practical)
13:34:36 <kramble> mauke: def is not really what I want, i was seeking for something like mzero
13:34:42 <Saizan> edwardk: ah, i've seen conor's lecture instead :)
13:35:00 <sgronblo> well I want to print the list of strings dwelling inside of it, naturally
13:35:08 <jmcarthur> sgronblo: an IO [String] represents something that *when executed* gives you a string. there are no strings "in" it
13:35:20 <Saizan> it seems almost doable in haskell
13:35:20 <edwardk> sgronblo: an IO action is just that, it is a sequence of instructions that will net you some value, printing it, doesn't make sense. what would it show me? should it cause those effects to happen to show me what it would do? should it print the list of effects? but those effects will determine other effects!
13:35:28 <Zao> jmcarthur: gives you a list of string, surely.
13:35:38 <jmcarthur> *gives you a list of strings
13:36:04 <sgronblo> ok, so if you have an IO [String] how do you print it out line by line?
13:36:15 <jmcarthur> sgronblo: map putStrLn =<< foo
13:36:23 <jmcarthur> sgronblo: "foo" is your IO [String]
13:36:24 <kramble> :t (=<<)
13:36:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:36:31 <mauke> putStr . unlines =<< foo
13:36:42 <sgronblo> oh havent run into that double arrow guy yet
13:36:46 <jmcarthur> man i suck
13:36:50 <jmcarthur> sgronblo: mapM_ putStrLn =<< foo
13:36:53 <mauke> sgronblo: that's what '<-' calls
13:37:03 <jmcarthur> sgronblo: it's the reverse argument order of >>=
13:37:06 <Zao> do { ss <- foo; mapM_ (\x -> putStrLn x) ss }
13:37:12 <Zao> If you want to spell things out a lot.
13:37:20 <kramble> :t map putStrLn =<<
13:37:20 <lambdabot> parse error (possibly incorrect indentation)
13:37:27 <lpsmith> losvedir, actually,  on second look you should probably get rid of the accumulator variable altogether
13:37:31 <jmcarthur> :t (mapM_ putStrLn =<<)
13:37:31 <edwardk> sgronblo: if you have an IO [String]. you have a recipe for finding a list of strings, you can use that to build up a more complicated recipe for finding a list of strings, and then printing them out by doing mapM_ putStrLn =<< foo -- or using unlines to build up one big string and putStrLn'ing that, etc.
13:37:31 <lambdabot> IO [String] -> IO ()
13:37:36 <kramble> :t (\foo -> map putStrLn =<< foo)
13:37:37 <lambdabot> [[String]] -> [IO ()]
13:37:43 <jmcarthur> kramble: i meant to use mapM_
13:37:44 <ion> @. pl undo do { ss <- foo; mapM_ (\x -> putStrLn x) ss }
13:37:44 <lambdabot> mapM_ putStrLn =<< foo
13:37:50 <ion> @. redo pl undo do { ss <- foo; mapM_ (\x -> putStrLn x) ss }
13:37:50 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
13:37:52 <kramble> :t (\foo -> mapM_ putStrLn =<< foo)
13:37:53 <lambdabot> IO [String] -> IO ()
13:37:59 <kramble> :t mapM_
13:37:59 <edwardk> :t (putStrLn . unlines =<<)
13:38:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:38:00 <lambdabot> IO [String] -> IO ()
13:38:13 <kramble> mapM_ is the generalised version of sequence_ ?
13:38:21 <edwardk> kramble: yes
13:38:39 <edwardk> :t sequence_ id
13:38:40 <lambdabot>     Couldn't match expected type `[m a]'
13:38:40 <lambdabot>            against inferred type `a1 -> a1'
13:38:40 <lambdabot>     In the first argument of `sequence_', namely `id'
13:38:44 <edwardk> :t mapM_ id
13:38:46 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m ()
13:38:49 <losvedir> lpsmith: oh my. hmmm, how would i do that?
13:38:49 <edwardk> :t sequence_
13:38:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
13:39:00 <losvedir> lpsmith: oh, oh, oh. i got it
13:39:05 <boscop> which book do you recommend for learning haskell, that doesn't dumb it down but explains the concepts behind it?
13:39:06 <kramble> i will use mapM_ instead of sequence_ in future
13:39:15 <hpc> you can define mapM_ in terms of sequence_, and the other way around
13:39:16 <kramble> :t mapM
13:39:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:39:25 <augustss> @src mapM
13:39:25 <lambdabot> mapM f as = sequence (map f as)
13:39:34 <augustss> @src mapM_
13:39:34 <edwardk> mapM_ is to sequence_ what mapM is to sequence, traverse is to sequenceA, traverse_ is to sequenceA, etc.
13:39:34 <lambdabot> mapM_ f as = sequence_ (map f as)
13:39:37 <ion> boscop: Is LYAH >> RWH good enough?
13:39:44 <lpsmith> losvedir, well,  here's what I did.  You might glance at it after you play with it: http://pastebin.com/muGRpGAF
13:40:00 <losvedir> lpsmith: oh, terrific. i will play and then i will glance. thanks so much!
13:40:02 <edwardk> er traverse_ is to sequenceA_
13:40:51 <boscop> ion, it seems to only cover the basics
13:41:13 <kramble> :t fmapM
13:41:14 <lambdabot> Not in scope: `fmapM'
13:41:52 <kramble> do you always implement the transformer when you define a new class monad ?
13:41:59 <kramble> s/class//
13:42:52 <hpc> kramble: it depends on the monad
13:42:56 <edwardk> kramble: i used to implement them both separately for pedagogical reasons if nothing else, but folks veered strongly the other direction with regards to transformers, etc.
13:43:05 <edwardk> so i followed suit
13:43:16 <kramble> edwardk: sorry i don't understand what you said
13:43:19 <hpc> general purpose stuff should have transformers, but specific stuff probably won't
13:43:29 <edwardk> kramble: mtl used to define both State and StateT as separate monads
13:43:41 <edwardk> now, type State s = StateT s Identity
13:43:52 <kramble> hoogle say me that State s = type StateT s Idenity
13:43:55 <saml> hey, would you use haskell or ml to write a compiler?  or scheme, python, javascript, lua...etc?
13:44:04 <kramble> i find use of transformer better, so i try to always create one
13:44:12 <saml> compiler meaning.. reads source and outputs code (C or assembly)
13:44:22 <edwardk> kramble: not everything offers a transformer version. there is no IOT, STT, STMT, etc.
13:44:31 * hpc would probably use haskell/parsec
13:44:34 <kramble> edwardk: IOT :D
13:44:40 <hpc> but i haven't used parsec extensively
13:44:47 <companion_cube> or perhaps ocaml, saml 
13:44:49 <saml> hpc, have you used language-c  ?  for C code generation?
13:44:58 <saml> companion_cube, why not haskell?
13:44:58 <companion_cube> you can use a parser generator, also
13:45:00 <hpc> i haven't generated C code ever
13:45:06 <companion_cube> saml, just to give an alternative
13:45:18 <edwardk> saml: i find haskell is a lot more fun to write a compiler in than ML-like languages
13:45:24 <saml> why not scheme, python, javascript, lua... and other dynamic languages?
13:45:27 <hpc> saml: i made an html/cgi monad though
13:45:31 <edwardk> i always feel like i'm drowning in a sea of boilerplate when writing ML based compilers
13:45:33 <hpc> and am working on one for javascript
13:45:51 <edwardk> so many stupid little methods that should be defined for me with deriving ;)
13:45:59 <hpc> it's working well so far, but i think i hit a wall on the js stuff
13:46:17 <saml> hpc, are you writing something in javascript? or are you compiling javascript?
13:46:24 <pozic> edwardk: in OCaml you don't need to have boilerplate.
13:46:24 <hpc> and with classes and work, you will have to wait a few weeks for a better answer
13:46:29 <companion_cube> edwardk, did you try in java ? :D
13:46:39 <hpc> saml: http://98.169.17.243:8000/test/js.cgi
13:46:45 <kramble> boilerplate = plumbing code ?
13:46:46 <hpc> saml: ^ generated entirely in haskell
13:46:51 * hpc gets source real quick
13:46:56 <edwardk> pozic: in ocaml, you also have metaocaml, etc. which i do like, that was going to be the flipside to the previous statement ;)
13:47:23 <pozic> edwardk: I am sorry for spoiling your moment.
13:47:34 <edwardk> pozic: sok. i forgive you. this time ;)
13:47:45 <hpc> saml: http://dl.dropbox.com/u/37707/JS.hs
13:47:57 <pozic> edwardk: no ban? Man, it has been ages since I last have been banned here. 
13:48:07 <edwardk> I'm a soft touch
13:48:22 <hpc> i noticed that functions are going to be hideous unless i take a more structured approach, so im rethinking the monad
13:48:35 <edwardk> hpc: have you seen jmacro?
13:48:51 <hpc> no
13:48:52 <saml> does anyone generate C from haskell?
13:48:59 <hpc> i want to implement this myself
13:49:08 <saml> language-c does not have example
13:49:18 <edwardk> hpc: it is by far the most disturbingly cool javascript-in-haskell i've seen.
13:49:21 <companion_cube> saml, i think some people in galois do this for subsets of C
13:49:28 <edwardk> http://www.haskell.org/haskellwiki/Jmacro
13:49:36 <saml> is there mirror for code.haskell.org  ?
13:49:46 <edwardk> template haskell quasiquotation and everything
13:49:52 <saml> oh it's up!
13:50:00 <edwardk> hygienic macro expansion, etc.
13:50:02 <saml> http://code.haskell.org/language-c/examples/    yay examples!
13:50:07 <aristid> edwardk: the name creates mistrust
13:50:12 <saml> hackage did not have examples directory
13:50:59 <hpc> edwardk: that looks totally different from what i intend to have code look like
13:51:22 <hpc> i want function(x, y) { return 5 + x + y;} to look like
13:51:23 <acowley> hpc: welcome to template haskell :P
13:51:28 <edwardk> hpc: yeah you seem to want a haskell edsl
13:51:42 <hpc> function $ do {[x,y] <- args; return 5 + x + y}
13:52:16 <aristid> hpc: but that doesn't really work :)
13:52:22 <hpc> yeah, i also want it totally sans extensions
13:52:33 <hpc> aristid: modulo lazy typing :P
13:52:42 <saml> hashed copy instead, but this may take a while.
13:52:47 <aristid> hpc: even then
13:52:48 <edwardk> in sclv's case he wanted something he could use to write mostly idiomatic javascript as such in small quoted fragments. the shallow haskell edsl is a nice goal, but i find it to be tedious when working with interop to native javascript
13:52:49 <companion_cube> 'sans extensions' ?
13:53:08 <hpc> er, i forget the word, companion_cube
13:53:14 <companion_cube> are you french ?
13:53:17 <hpc> like GADTs and bang patterns
13:53:21 <edwardk> haskell 98 is a laudable goal
13:53:22 <hpc> no, american :P
13:53:30 <companion_cube> :)
13:53:47 * hpc just has an obnoxiously unconventional vocabulary
13:54:03 <aristid> hpc: to sound more intellectual, you should also use some german words
13:54:07 <hpc> lol
13:54:28 <companion_cube> "the gestalt of this combinator is so incroyable"
13:54:35 * edwardk tries to figure out what is wrong with sans in that context, then shrugs and moves on.
13:54:41 <hpc> companion_cube: cromulent!
13:54:43 <edwardk> sans is a perfectly cromulent word
13:54:51 <pozic> Sans is tech speak, AFAIK. 
13:54:58 <aristid> edwardk: nothing wrong with it, we're just a bunch of kids ;)
13:55:03 <hpc> sans was around before sans serif
13:55:07 <Jafet> @remember edwardk Haskell 98 is a laudable goal.
13:55:07 <lambdabot> I will remember.
13:55:07 <hpc> :P
13:55:07 <pozic> (who cares that the French invented it)
13:55:10 <edwardk> now, tech speak is crap like 'performant' which is actually not a word. ;)
13:55:33 <pozic> edwardk: I cringe when I see that.
13:55:35 <edwardk> as it is the use of a non-productive suffix
13:55:37 <hpc> crap, i was going to do something, and the channel got interesting
13:55:41 <pozic> edwardk: it is a good bullshit detector. 
13:55:41 <hpc> and now i forgot what it was
13:55:51 * companion_cube did not know "sans" was used by english speakers
13:56:07 <monochrom> "leverage" used to be a bullshit detector
13:56:09 <aristid> "performant" is a relatively common word in german :D
13:56:13 <hpc> companion_cube: it isn't used much, but we are nerds
13:56:24 <hpc> so i figured everyone knew what it meant
13:56:36 <edwardk> aristid: yep. it is nicely productive in german =)
13:56:47 <pozic> What is the German? 
13:56:55 <aristid> pozic: "performant"
13:57:06 <hpc> who is spain?
13:57:07 <pozic> aristid: I mean 'sans'.
13:57:09 <hpc> why is hitler?
13:57:20 <hpc> :D
13:57:21 <aristid> pozic: sans ist not german
13:57:24 <companion_cube> hpc, i knew the meaning, but not that it was used
13:57:26 <hpc> @wn sans
13:57:28 <lambdabot> No match for "sans".
13:57:28 <pozic> aristid: ...
13:57:30 <aristid> (notice my careful use of ist instead of is)
13:57:32 <hpc> ...
13:57:41 <aristid> pozic: "ohne"
13:57:45 <hpc> sans is french
13:57:51 <monochrom> wait, shouldn't it be "sans ist nicht Deustche"?
13:57:53 <Jafet> That's clearly a non-productive use of "is"
13:58:03 <aristid> monochrom: no.
13:58:32 <mathstuf> hi, im sure im doing something un-Haskell-like here, but is there a way to fix this error (or a better way to structure things so my code isnt killing kittens)? http://fpaste.org/1UKY/
13:59:07 <aristid> mathstuf: Typeable? woah, crazy stuff
13:59:47 <aristid> mathstuf: how about using Node a instead?
13:59:51 <mathstuf> ideally, addOutput would ensure that Edge a could be connected
13:59:52 <edwardk> mathstuf: those are a lot of dead kittens.
14:00:00 <mathstuf> nodes can have many outputs/inputs
14:00:18 <mathstuf> and of different types
14:00:29 * pozic checks to check his cat.
14:00:38 <aristid> mathstuf: why of different types?
14:00:45 <pozic> Surely, all of them must be dead by now.
14:01:09 <companion_cube> perhaps there is an infinite lazy stream of kittens somewhere, so that we can kill more
14:01:24 <conal> New blog post: http://conal.net/blog/posts/composable-parallel-scanning/
14:01:26 <mathstuf> working on a data pipeline lib
14:01:58 <maurer_> Does anyone know how to make Cabal play nicely with -EAGAIN ?
14:02:00 <hpc> pozic: not bad enough, if it hasn't gone back in time and removed kitties from our memories
14:02:10 <edwardk> copumpkin: well, thats good. no matter what you do, most of them will survive then.
14:02:16 <mathstuf> each node may need different types and make different data available
14:02:18 <edwardk> er companion_cube 
14:02:34 <hpc> conal: you remind me how anemic my blog is...
14:02:39 <hpc> 4 posts, one of which isn't mine
14:02:46 <hpc> also, your blog is slow
14:02:47 <edwardk> i do recommend against consuming kittens as input. indigestion and hairballs await.
14:02:48 <maurer_> When I try to build on a system where some data is in AFS, I have to build multiple times to get it to go b/c I get bus errors partway through when -EAGAIN and similar are passed on file open.
14:03:13 <hpc> edwardk: it also isn't typesafe
14:03:14 <companion_cube> how do you extract Kitten from a IO [Kitten] to kill them N
14:03:15 <conal> hpc: slow to load?
14:03:15 <pozic> conal hosts it on his C64.
14:03:21 <companion_cube> ?*
14:03:21 <lambdabot> Maybe you meant: . ? @ v
14:03:23 <hpc> :D
14:03:31 <dcoutts_> maurer_: sounds like a generic issue, not cabal specific
14:03:50 <maurer_> dcoutts_: Maybe it's a ghc issue? It's never been an issue with any other languages I've built with.
14:03:59 <conal> pozic: can't let a C64 go to waste!
14:03:59 <ion> pozic: Yeah, the branch of C64-specific optimizations for GHC isn’t merged yet.
14:04:06 <maurer_> e.g. building with gcc and friends, or ocamlc and friends, doesn't end up with a problem.
14:04:22 <edwardk> wow, all this time i thought he was hand typing out the html for the page for me for each request
14:04:25 <ion> The memory usage is high and swapping to a C cassette is *slow*.
14:04:50 <dcoutts_> maurer_: so what makes you think that open is returning EAGAIN?
14:04:56 <edwardk> ion: plus it is intense manual labor
14:05:08 <dcoutts_> maurer_: according to my man 2 open, EAGAIN is not a possible error
14:05:40 <maurer_> dcoutts_: It was a guess based on AFS-nonblocking semantics in other areas. I may be mistaken, maybe I should trace it.
14:05:59 <dcoutts_> maurer_: if you can make a really small test prog that'd be ideal
14:06:08 <dcoutts_> maurer_: and an strace would be useful too
14:06:12 <edwardk> ion: if you copy the kernel down to main memory, you can tweak it to remove the redundant write in case of 'read errors' pshaw, like those ever happen, that should speed up swapping by a factor of 2 ;)
14:06:44 <aristid> dcoutts_: according to my man 3posix open, EAGAIN is a possible error.
14:06:47 <maurer_> dcoutts: Yeah, I'm building an strace log for my prog right now, I'll try to find a way to duplicate it on smaller progs. It only seems to show up when some of the files to be used are AFS backed though.
14:06:54 <pozic> How much could those magnetic cassettes store anyway?
14:07:27 <aristid> The open() function may fail if:
14:07:28 <aristid>        EAGAIN The path argument names the slave side of a pseudo-terminal device that is locked.
14:07:37 <aristid> admittedly a rather obscure error
14:08:04 <edwardk> the datasette was 300 baud, so its mostly a function of how big of an audio tape you had lying around.
14:08:34 <dcoutts_> aristid: aye, just found that too, obscure indeed
14:08:52 <dcoutts_> perhaps AFS is adding its own extra meaning
14:09:07 <sgronblo> What kind of syntax trickery was needed to map (- 1) to a list?
14:09:18 <aristid> sgronblo: map (subtract 1)
14:09:23 <sgronblo> aristid: thanks
14:09:31 <maurer_> I'll keep working on getting a good way to duplicate it, it's just a bit tricky because once I run the build once on a machine, it caches the necessary files, and no longer generates the error :(
14:09:36 <aristid> sgronblo: (- 1) is a number
14:09:57 <shachaf> > map pred [1,12]
14:09:57 <lambdabot>   [0,11]
14:09:59 <untwisted> aristid: can't you also map ((-) 1) ?
14:10:09 <shachaf> untwisted: You'd need flip for that.
14:10:10 <mathstuf> flip (-)
14:10:27 <sgronblo> I'm fine with subtract
14:10:32 <untwisted> shachaf: ahhh, yes
14:10:37 <ion> ‘@somemagiccommand [1,2,3] [0,1,2]’ should respond with ‘map (subtract 1)’
14:10:52 <aristid> sgronblo: i think subtract was made specially for this problem :)
14:10:56 <ion> …or pred
14:11:05 <aristid> ion: indeed, pred would be better:)
14:11:08 * hackagebot iteratee 0.8.1.2 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.1.2 (JohnLato)
14:11:08 <hpc> sgronblo: there's a few proposals to make function application require an explicit space
14:11:09 <edwardk> pozic: you should be able to fit about 270k on a 120 minute cassette, but in practice, with the redundant encoding, and the fact that most were half that length, you got way less
14:11:12 <maurer_> Essentially there appears to be a bad interaction between AFS cache misses and the build system, I'll try to be more specific before bugging anyone again though.
14:11:17 <edwardk> pozic: plus that would take 2 hours to load!
14:11:22 <hpc> sgronblo: then use -x as negation, and (- x) as a section
14:11:26 <aristid> sgronblo: map pred might also work :)
14:11:29 <hpc> none of those have happened yet, sadly
14:11:31 <aristid> > pred 1.0
14:11:32 <lambdabot>   0.0
14:11:45 <Jafet> ion: see quickspec
14:11:55 <pozic> edwardk: the creativity/variance in games was much higher back then, though. 
14:12:23 <edwardk> pozic: mostly because there were fewer tropes to fall back on. most of those games were shit
14:13:32 <pozic> edwardk: trope?
14:13:35 <dcoutts_> maurer_: according to my reading of the Haskell openFile code, it does not expect the C open call to return EAGAIN, so it would fail in that situation
14:14:03 <maurer_> dcoutts_: Yeah, I'm still trying to verify that's what's happening.
14:14:09 <edwardk> conventions or devices used within a creative work
14:14:33 <edwardk> murder mysteries have a number of tropes, the closed room mystery, etc.
14:14:53 <pozic> edwardk: isn't the word for that 'motive'?
14:15:17 <edwardk> motifs are similar
14:15:20 <conal> augustss: another comment on http://www.reddit.com/r/haskell/comments/ftxc7/do_you_think_haskell_will_ever_catch_on/c1iqriu
14:15:29 <edwardk> but they tend to be within a given work
14:15:37 <pozic> edwardk: dict trope doesn't list your meaning (I am not saying you are wrong, obviously)
14:16:14 <edwardk> http://tvtropes.org/pmwiki/pmwiki.php/Main/HomePage
14:17:41 <pozic> conal: Plenty of people know how to think clearly about real world applications. 
14:18:09 <Jafet> Well, we have more tropes now and most games are still shit
14:18:30 <Jafet> Sturgeon's law has pretty strong invariants
14:19:00 <maurer_> dcoutts_: Sorry, can't get it duplicated under strace at the moment (all my machines have the file cached :( ) I'll submit a report once I get an strace log showing what's going on. Thanks for listening to me.
14:19:10 <edwardk> anyways games have evolved because we as gamers have evolved a larger shared vocabulary of movements and controls, and strong opinions about what works to avoid alienating the user. my wife for instance was completely left behind as games evolved, and while she enjoys the idea of gaming, she can't deal with the twitch aspect of MMOs. sadly a lot of games lean on the tropes to give the illusion of content, the same way a lot of java pr
14:19:14 <edwardk> of productivity
14:19:21 <dcoutts_> maurer_: ok great
14:20:18 <Jafet> In a soundbite, "MMOs are like Java"
14:20:45 <edwardk> er sorry that got mangled as i was editing and lost the middle section. she can't handle the twitch aspect of shooters and other reflex games, and doesn't deal well with the number of competing concerns involved in MMOs, etc.
14:20:56 <edwardk> hah
14:21:24 <acowley> edwardk: Same for my wife, though it can be rewarding to find a game that works for her
14:21:50 <edwardk> acowley: we have found that when we
14:22:05 <djahandarie> Oh, edwardk, acowley, you two might be interested in ##categorytheory :)
14:22:14 <djahandarie> Fairly active
14:22:34 <edwardk> we're stuck waiting at a restaurant or something, i can dig out the iphone and we can work through interactive fiction games together. that avoids the twitch aspect entirely
14:22:45 <dcoutts_> maurer_: it's probably worth filing a ticket even if you cannot reproduce it. A quick google indicates that there are other situations where open returns EAGAIN, such as mandatory file locking.
14:23:48 <aristid> edwardk: what does "twitch aspect" mean?
14:23:56 <acowley> djahandarie: Thanks for the tip! I've got to head out in a couple minutes, but an additional place to not work is always welcome :)
14:24:14 <acowley> edwardk: can you recommend any such games? I've never really tried them.
14:24:23 <edwardk> aristid: reflex oriented gaming
14:24:39 <djahandarie> acowley, ;)
14:24:51 <edwardk> acowley: sure. let me dig up a list of good intro material
14:25:01 <pozic> edwardk: decease incurring gaming could be a whole new market!
14:25:05 <acowley> Gargh: my goal in Coq: sum x' + (fst st Y + h) = sum (snd st X) + fst st Y. I try to do a rewrite and get Error: Found no subterm matching "snd st X" in the current goal.
14:25:20 <acowley> what am I missing?
14:25:58 <acowley> It sure looks like there is an "snd st X" ...
14:26:51 <jmcarthur> omg ghci is awesome
14:27:02 <jmcarthur> i just realized i can tab complete inside a string literal for a file name
14:27:26 <edwardk> acowley: frotz is available for the iphone, gargoyle is a decent pc z machine. the easiest introduction to the form might be a bit unconventional, something from adam cadre, he tends to write fun stuff, Narcolepsy is nice in that it has a few puzzles, but goes in radically different directions as you play
14:27:57 <acowley> edwardk: thanks!
14:28:23 <edwardk> on the other end of the difficulty spectrum, Varicella and Slouching towards Bedlam give an example of radically different tones
14:28:39 <edwardk> Slouching towards Bedlam is also short, Varicella is quite difficult though.
14:29:00 <shachaf> edwardk: Most of the Z machine games I've played have been Infocom games.
14:29:08 <edwardk> Jigsaw is more traditional and is quite good once you get past the rather steep intro learning curve.
14:29:19 * shachaf supposes he should look at some of the non-Infocom ones at one point.
14:29:38 <edwardk> shachaf: yeah, the non-infocom stuff has become rather good
14:30:05 <shachaf> edwardk: Have you seen the short one-room gme Enlightenment?
14:30:19 <Jafet> There's a one-move game, Aisle.
14:30:39 <edwardk> if you want a fun trampy sort of game, another adam cadre classic is Interstate 0, which is a good example of more sandbox-style play
14:30:44 <ddarius> Maybe I should consider playing Jigsaw.  I've heard it recommended othertimes.
14:30:46 <edwardk> but i'm pretty far off topic here ;)
14:31:11 <edwardk> jigsaw is a lot of fun, but it sometimes devolves into trying to look under/behind everything
14:31:47 <Jafet> (What does your wife think about I/0?)
14:31:53 <ddarius> edwardk: I miss adventure games in the vein of SpaceQuest or Sam and Max Hit the Road.
14:32:11 <Philippa> ddarius: there's a pile of new ones actually
14:32:19 <edwardk> jafet: we didn't play through that one together
14:32:19 <Philippa> mostly Tell Tale Games' stuff
14:32:38 <shachaf> Philippa: They make text-based games?
14:32:40 <shachaf> Oh, never mind.
14:32:42 <Philippa> episodic Monkey Island and Sam&Max
14:33:15 <Philippa> there's a sale on Steam once in a while too
14:33:37 <shachaf> Tell Tale's Monkey Island is not as good as the original.
14:33:57 <shachaf> (By which I mean 1/2/3.)
14:34:21 <shachaf> ddarius: You should play The Neverhood.
14:34:39 <ddarius> Philippa: On phones?
14:35:02 <Philippa> ddarius: on PC. Don't know if there're any phone releases
14:36:19 <zygoloid> ddarius: have you played The Longest Journey? it's a big stylistically different from the games you mentioned but still very good 
14:36:49 <edwardk> longest journey was the last pc adventure game my wife enjoyed
14:37:05 <edwardk> sadly its sequel added all the twitch-gamer aspects in
14:37:37 <zygoloid> yeah. the 3d was a mistake too imo
14:38:05 <ddarius> zygoloid: No.
14:38:25 <monochrom> they should go 4D  <duck>
14:38:45 <Philippa> in the long run 3D's here to stay, it scales up better to high frame counts than 2D
14:38:55 <tawe> I have a question. Here it's the code. What I'm trying to do it's almost self explanatory, but doesn't work, any help? http://pastebin.com/3tKTM5xV
14:38:55 <ddarius> monochrom: There should be more 4D games.
14:39:12 <Jafet> We present The Sequel, now in glorious projective 3-space
14:39:47 <ddarius> Jafet: Hell's yeah.
14:40:05 * ddarius doesn't understand Philippa's response.
14:40:51 <zygoloid> tawe: what doesn't work
14:40:59 <Philippa> I don't know if TTG are doing phone ports or not (I don't think they're on android at least), but they're doing new graphic adventures on PC and at least some console releases
14:41:04 <tawe> zygoloid: If I do: fooo 2 3
14:41:15 * monadic_kid notes #haskell-game
14:41:21 <tawe> zygoloid, I expect "(2,3)"
14:41:27 <Philippa> -blah would be more appropriate
14:41:45 <zygoloid> tawe: i'd expect "(Test,Test)" :)
14:41:56 <tawe> zygoloid, I'm sorry, yes, that.
14:42:24 <tawe> ERROR - Unresolved overloading
14:42:24 <tawe> *** Type       : (Num a, Visible a) => [Char]
14:42:44 <bla123> tawe: using Hugs?
14:42:50 <Jafet> ddarius: for what it's worth, you can play go in projective 3-space: http://www.math.cmu.edu/~fho/jenn/#go
14:42:50 <tawe> bla123, yes
14:43:02 <bla123> tawe: works fine in GHCi
14:43:07 <zygoloid> tawe: this is a defaulting issue. it doesn't know which type 'a' should be, and it refuses to guess because there's a non-Prelude class in there
14:43:32 <ddarius> Jafet: If I could play Go.
14:43:36 <zygoloid> tawe: (2 and 3 aren't actually Integer, they're Num a => a)
14:43:51 <bla123> tawe: try to give it explicit types: fooo (2::Int) 3
14:44:39 <Jafet> Oh, I'm sure the lines are simpler there
14:45:11 <tawe> bla123, ERROR - Cannot infer instance :(
14:45:28 * shachaf seems to remember trying a 4D Rubik's cube program once.
14:45:32 <tawe> bla123, works for 2::Integer :)
14:45:35 <bla123> tawe: sry, should have been: fooo (2::Integer) 3
14:45:48 <tawe> bla123, yes :), thanks
14:46:24 <bla123> tawe: this problem vanishes when you use it in some function where the compiler can infer the correct type from it's use
14:46:50 <mercury^> shachaf: is it not just as easy to find an algorithm in that case? It will merely be so complicated that humans have trouble implementing it.
14:47:15 <shachaf> mercury^: Presumably, yes.
14:49:45 <tawe> bla123, and why infers that the second argument is an Integer? :|
14:50:36 <bla123> tawe: the type signature "fooo :: Visible a => a -> a -> String" says that both parameters have to be of the same type
14:50:50 <tawe> bla123, oh.
14:51:28 <bla123> tawe: with this signature they can be different: "fooo :: (Visible a,Visible b) => a -> b -> String"
14:51:44 <tawe> bla123, I see.
14:59:50 <losvedir> lpsmith: thank you for your help with my tokenize function before. here's my new version incorporating your suggestion to remove the accumulator: http://pastebin.com/3naw4MJa
15:00:14 <losvedir> no helper function, just ordinary recursion. much, much better than i had before, i think. thanks again!
15:02:14 <pozic> losvedir: you can use a lazy pattern there (at the r) to make it enterprise friendly. 
15:02:31 <pozic> losvedir: then you can get rid of the op and rest lines.
15:03:59 <losvedir> pozic: hmm, i'm not quite sure i understand. what do you mean by "use a lazy pattern"?
15:05:15 <Saizan> > let (a,_:_) = (1,[]) in a
15:05:16 <lambdabot>   *Exception: <interactive>:3:4-19: Irrefutable pattern failed for pattern (a...
15:05:31 <Saizan> > let (a,~(_:_)) = (1,[]) in a
15:05:32 <augustss> losvedir: instead of r you put ~(op:rest) in the pattern
15:05:32 <lambdabot>   1
15:06:26 <augustss> losvedir: or rather r@~(op:rest)
15:06:33 <pozic> losvedir: http://pastebin.com/1dE5F5Jm
15:06:36 <losvedir> ahhh!  i think i see
15:07:33 <losvedir> augustss, pozic: so, if it can pattern match for op:rest it will, otherwise r will be null?
15:07:40 <pozic> It only shows that you copied your solution if it is home work ;)
15:08:21 <augustss> losvedir: it will only do the pattern match when you use either op or rest.
15:08:29 <pozic> losvedir: it basically won't do anything until you want to see the value of r.
15:08:48 <augustss> losvedir: but I wouldn't write that way.  I'd combine the null r and otherwise alternatives into one and use a case
15:09:01 <losvedir> pozic: hehe, not homework. just playing around. you should have seen my first monstrosity of a solution! http://pastebin.com/x0k2qX3m  lpsmith here helped me neaten it up
15:09:07 <augustss> lazy pattern matching is error prone
15:09:22 <pozic> losvedir: I don't think lazy pattern matching is a good idea. I just wanted to show off.
15:09:32 <pozic> [here]
15:09:53 <losvedir> pozic: i see, ha. well i learned something new and interesting, so thanks! i see that "enterprise friendly" now was a joke?
15:10:12 <pozic> losvedir: you got that right.
15:10:31 * pozic ponders using webscale next time. 
15:11:04 <augustss> http://pastebin.com/gpTcuEtr
15:11:25 <augustss> losvedir: that's what I meant
15:12:04 <losvedir> augustss: hmm, i'll have to chew on that one a bit
15:12:22 <losvedir> augustss: why would you do it this way rather than my way?
15:12:27 <Twey> Anything that includes ‘enterprise’ and ‘friendly’ in the same time tends to be a joke
15:12:29 <pozic> losvedir: If you want the shortest possible program, you could use Parsec, too. 
15:12:32 <Twey> the same line**
15:12:45 <augustss> losvedir: don't, it's wrong
15:13:19 <augustss> losvedir: I lost some bits of the code :)
15:13:34 <pozic> augustss: do you write separate tokenizers in your parsers?
15:13:36 <losvedir> augustss: ah, ok
15:13:44 <kniu> How do I add a progress bar to pure computations?
15:13:53 <augustss> pozic: yes, i do
15:14:02 <pozic> augustss: why?
15:14:17 <pozic> augustss: other than speed, I cannot think of any reason.
15:14:28 <augustss> losvedir: I try not to use head&tail if I can avoid it
15:14:33 <pozic> It only complicates your code, no?
15:14:41 <augustss> pozic: I find it a nice separation of concerns
15:15:04 <augustss> pozic: I think it simplifies my code
15:15:37 <pozic> augustss: So, you get to parse [TOKEN1, TOKEN2, STR "This is not a token"]?
15:16:12 <augustss> pozic: something like that, yeah
15:16:52 <c_wraith> kniu: there are a bunch of possible ways of doing that.  It depends on the nature of the computation, really.
15:17:02 <augustss> pozic: but if I were parsing FORTRAL IV I'd not have a separate tokenizer
15:17:10 <augustss> FORTRAN IV
15:17:50 <pozic> augustss: because of the large number of tokens? 
15:17:52 <kniu> c_wraith, I got a giant list of Doubles.
15:18:32 <c_wraith> I so want foldl+drop to be in the standard libs.
15:18:32 <kniu> Just want to figure out what percentage of them have been reduced to normal form every second or so.
15:18:32 <homie> you lucky you
15:18:39 <homie> you did not get triples!
15:18:45 <pozic> kniu: you can do that if you compile all your code to some language which automatically increments a counter, and has an upperbound on complexity.
15:18:56 <augustss> pozic: because it's weird.  it doesn't have significat whitespace
15:19:13 <pozic> kniu: ok, that's a different problem, never mind. 
15:20:23 <pozic> augustss: don't you mean that the white space is significant?
15:21:55 <lpsmith> pozic,  IIRC,  you can strip out the whitespace of Fortran IV program and have it do the same thing
15:21:59 <lpsmith> it ignores whitespace
15:22:16 <augustss> pozic: No, beyond column 6 it's not
15:23:04 <augustss> For instance DO 100 I=1,10 tokenizes very differently from DO 100 I=1.10
15:23:18 <augustss> As NASA knows
15:23:32 <pozic> BOOM!
15:23:38 <hpc> lol
15:23:41 <augustss> Since that mistake sent a Mariner into the sun
15:24:01 <pozic> They never send the best guy first.
15:24:10 <pozic> ^^
15:26:04 <pozic> Ok, a Mariner is an actual satellite. Better fits the story too.
15:26:22 <pozic> Er space probe.
15:26:37 <ddarius> @quote Yoneda
15:26:37 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
15:26:37 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
15:26:59 <hpc> ahaha!
15:32:10 <monochrom> huh! when I load an svg file in emacs, it shows the picture instead of letting me edit the text?!
15:32:22 <hpc> monochrom: vim? :P
15:32:52 <monochrom> While I denounce plain text files, I did not expect this level of sophistication! XD
15:32:53 <hpc> (related, when i open a folder in vim, it show me a pseudo-browser)
15:36:59 <hpc> @undo do {(x, v) <- f; v; return x;}
15:36:59 <lambdabot> f >>= \ (x, v) -> v >> return x
15:37:17 <hpc> @pl \f -> f >>= \ (x, v) -> v >> return x
15:37:17 <lambdabot> (uncurry (flip (>>) . return) =<<)
15:37:22 <hpc> bleh
15:54:01 <zingi> any freelancers here?
15:55:55 <maurer_> zingi: Kind of, why?
16:08:22 <maurer_> btw channel, zingi is attempting to recruit someone to do his homework for him (e.g. trying to cheat) so be careful.
16:09:15 <hpc> aw, and i was hoping for some practice writing enterprise code
16:09:17 <luite_> what is the going rate for homework?
16:09:22 <Adamant> I don't think we're the ones who need to be careful at this point
16:09:37 <hpc> luite_: here, i would say, a heaping dose of scorn
16:10:48 <mathstuf> hrm...i have Array i (TVar e) and its initialized to all values to 'undefined'; why would doing 'atomically (writeTVar elem some_valid_value)' cause Prelude.undefined to be thrown?
16:10:55 <luite_> oh wait I thought this was -blah
16:11:15 <c_wraith> I will do homework for $1 million USD per assignment.  I figure I can sacrifice my ethics to retire. :)
16:11:29 <luite_> c_wraith: does that include writing phd theses?
16:11:36 <hpc> c_wraith: wouldn't it be easier to just get tenure?
16:11:43 <Adamant> I will do homework for money if I can get the program to confess to the professor and still pocket the money.
16:11:45 <hpc> certainly more fun ;)
16:11:57 <c_wraith> luite_: No, nothing that exceeds one term in scope.
16:13:25 <luite_> c_wraith: how about when I'm really behind and need to finish it this term? ;)
16:13:28 <mathstuf> this works
16:13:29 <mathstuf> atomically (do tv <- newTVar (undefined :: Int); writeTVar tv 10; v <- readTVar tv; return v)
16:13:38 <c_wraith> luite_: sorry, no go. :)
16:14:38 <c_wraith> mathstuf: that looks like a really convoluated way to write "return 10" :)
16:15:03 <mathstuf> was just seeing whether writeTVar in that would also throw Prelude.undefined
16:15:21 <c_wraith> mathstuf: also, no need to bind a value then return it.  By the monad laws, that is equivalent to just putting the action there
16:15:47 <mathstuf> ah true
16:16:05 <mathstuf> i usually catch those things when reading over the code again, but not always when writing it
16:16:30 <hpc> let's not rail on the style mishaps of test code :P
16:18:44 <c_wraith> no one made fun of my spelling of "convoluted".  Hmm.
16:20:55 <hpc> haha, convoluated
16:23:13 <c_wraith> @hoogle Language.Erlang
16:23:13 <lambdabot> No results found
16:44:47 <sunfun> :t product
16:44:48 <lambdabot> forall a. (Num a) => [a] -> a
16:44:51 <ksf> would it be possible to say bytecode-compile and interpret haskell without typechecking? that is, trust the types to be correct?
16:46:27 <hpc> ksf: probably, if you didn't want typeclasses to behave right
16:46:33 <hpc> or mandatory signatures
16:48:25 <ksf> well, one could add dynamic typechecks.
16:48:46 <ksf> typeclass resoving is an issue, yes.
16:49:04 <ksf> but I don't think the whole thing would be more complex than what say go does.
16:49:14 <c_wraith> Is this a case for proof-carrying code?
16:49:40 <c_wraith> Could it carry its own proofs of type-correctness, in such a way as to make verifying the proofs far faster than actually typechecking?
16:49:53 <ksf> erm, no. I ask because such an interpreter might just be easy enough to write in lua or c to aid bootstrapping.
16:49:59 <c_wraith> ah
16:50:02 <ddarius> ksf: The answer is "no."  Primarily due to type classes (for Haskell 98 at least.)
16:50:39 <hpc> c_wraith: perhaps like quickcheck?
16:50:50 <hpc> "if these are right, then blah == blah blah
16:50:51 <hpc> "
16:51:08 <c_wraith> hpc: quickcheck is not really anything like proof-checking
16:51:43 <ksf> why would resolving typeclasses at runtime be a problem?
16:52:03 <ksf> you know what type your stuff is, you know the instances, so you can match up.
16:52:28 <ksf> ...assuming no funky extension stuff
16:52:40 <ddarius> What thing does read return?
16:53:01 <ksf> a thunk
16:53:23 <c_wraith> more usefully, what implementation does read use?
16:53:55 <ksf> but in general, yes, return type polymorphism isn't easy.
16:54:18 <ddarius> It's not just "return type polymorphism."  There's nothing terribly special about the return type.
16:55:01 <ddarius> class C a where f :: (a -> X) -> X; g :: [a] -> X
16:55:29 <ksf> there you know what f and g to use because you know what a is.
16:55:34 <ksf> otherwise, you couldn't pass it.
16:55:51 <ddarius> ksf: I can pass [] to g, and f -provides- a.
16:56:38 <ksf> I'm subsuming f under "return-type polymorphism". at least in my mental model.
16:56:40 <c_wraith> I guess this is tractable if your compilation strategy is whole-program, and you handle typeclasses by specializing them
16:56:59 <ddarius> ksf: That's fine.  You could say "positive type polymorphism" but the a in g isn't a positive occurrence, so that still fails.
16:57:11 <ddarius> c_wraith: Specializing them to what?
16:57:44 <c_wraith> ddarius: whatever they're used as.  It's whole-program.  You see all the uses.  You can create a different implementation for each set of types.
16:57:46 <ksf> giving all [] proper types seems to need unifying, yes.
16:58:14 <ddarius> c_wraith: What types?  What do I specialize g [] to ?
16:58:32 <ksf> ok, let me reframe the question: what's the easiest way to get haskell code to run, forgetting all that type erasure and whatnot goodness
16:58:37 * hpc just thought of the best bad idea
16:58:42 <hpc> haskell with duck typing
16:59:24 <ksf> hpc, the fun with type families paper has that as an example
16:59:29 <copumpkin> ksf: read the typing haskell in haskell paper and write the simplest type checker
16:59:36 <copumpkin> then use haskell-src-exts
16:59:45 <ksf> ...without using haskell.
16:59:53 <copumpkin> ?
17:00:05 <copumpkin> oh, you want to write an interpreter in another language?
17:00:10 <copumpkin> why would you ever want to do that
17:00:12 <ksf> the idea is to bootrap from an alien language
17:00:20 <ksf> bootstrap, even.
17:00:20 * djahandarie bootraps
17:00:23 <hpc> heh
17:01:27 <ksf> it's a kind of shame that hugs can't bootstrap ghc
17:01:37 <hpc> ksf: does bootstrapping from klingon count? :D
17:01:40 <hpc> it's an alien language
17:02:01 <ksf> hpc, if you write a perl module for that, yes.
17:02:44 <monochrom> klingon bootkicks rather than bootstraps ghc :)
17:03:17 * ksf senses a "in the klingon empire..." meme.
17:03:35 <hpc> meanwhile, on the starship enterprise...
17:05:56 <monochrom> on the starship enterprise, spock explodes ghc's brain
17:06:33 <hpc> it's a shame that nick is taken here; on foonetic i am Spock
17:06:42 <monochrom> onoes
17:06:48 <hpc> it leads to some fun jokes
17:07:02 <aavogt> instead you're a program coverage tool
17:07:12 <hpc> indeed
17:07:25 <hpc> (it stands for headprogrammingczar, which is an old old nickname)
17:07:28 <aavogt> quite useful when making tests
17:09:18 <monochrom> in czarist russia, headprogrammingczar programs you
17:10:08 <ksf> in czarist russia, putin is Vladimir the gentle.
17:10:18 <ddarius> monochrom: That's what a Russian head programmer should do, no?
17:10:29 <monochrom> yeah!
17:11:16 <ksf> there's a suspiciously low amount of russians here, btw.
17:12:07 <ClaudiusMaximus> @hoogle tryReadChan
17:12:07 <lambdabot> No results found
17:12:33 <hpc> ksf: it's the Glorious Glaskow Haskell Compilation System
17:12:37 <hpc> it watches their every move
17:12:57 <ksf> tryReadChan c f = readChan c >>= f . Just `orElse` f Nothing 
17:13:13 <ksf> cps ftw
17:14:25 <ClaudiusMaximus> readChan blocks, i don't want to block, so i don't see how that helps
17:14:56 <ksf> I mean to say "you want to use STM"
17:15:12 <ksf> that's be TChan, then.
17:15:58 <ksf> you could surely do that with vanilla concurrency, but would suffer much agony doing such.
17:16:26 <aavogt> @src Chan
17:16:26 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:16:28 <co_dh> I have a question about Theorem for free. From the point of view of Category theory, these theorem seemed just law for natural transformation , am I right? 
17:16:55 <aavogt> isEmptyChan :: Chan a -> IO Bool -- ClaudiusMaximus?
17:17:30 <monochrom> isEmptyChan is buggy and too hard to fix. use STM TChan
17:17:36 <ClaudiusMaximus> maybe i should accelerate the merging of my experimental code (which uses GLUT) into my main code base (using GTK) so that i can maybe use postGUI(A)Sync, or something
17:17:38 <ddarius> co_dh: Yes, no, and maybe.
17:17:38 <co_dh> take fst for example : fst is just a natural transformation from (X B)  to Id functor. 
17:17:55 <ddarius> co_dh: And what natural transformation is fix?
17:18:04 <napping> co_dh: but is everything of type (a , b) -> a a natural transformation?
17:18:11 <co_dh> ddarius: which part is the yes, and which part is no? 
17:19:57 <ddarius> napping: You could make a suitable category out of System F, say, and parametricity would imply that all such values of that type satisfy the naturality condition.
17:20:06 <ClaudiusMaximus> aavogt, monochrom: yeah i've been bitten by that in the past, not fun..
17:20:10 <ddarius> co_dh: Answer my question and you'll get the objectively no part.
17:20:10 <napping> I think that's how it's proved, actually
17:20:23 <copumpkin> @free fix :: (a -> a) -> a
17:20:23 <lambdabot> f . g = h . f => f (fix g) = fix h
17:20:30 <ddarius> napping: No, it isn't.
17:20:43 <co_dh> ddarius: thanks , I need to read the paper carefully again. 
17:21:09 <ddarius> napping: At any rate, free theorems are at least superficially stronger than naturality conditions.
17:21:13 <monochrom> postGUI(A)Sync is the best thing since threading
17:21:36 <ddarius> (For types that can be expressed as natural transformations between functors.)
17:22:31 <co_dh> copumpkin: what's that @free? 
17:22:34 <ClaudiusMaximus> what would be even more awesome is some kind of type system voodoo that doesn't let you forget to use postGUI(A)Sync where it's needed
17:22:45 <napping> not making a category out of System F and the usual evaluation behavior, but working in one or more categories
17:22:59 <co_dh> oh , they implemented theorem for free in the bot? that's amazing :)
17:25:12 <halberd> algorithms question:  you start with a set of points in R2 and may pre-process them in any way you like.  Then, you are given a set of real numbers, and you must determine whether there exist 2 numbers in the set A and B such that (A,B) is one of the points in R2
17:25:20 <napping> I think I read sometihgn like Scott's "Functorial polymorphism and semantic parametricity"
17:25:31 <ddarius> napping: Parametricity is usually proved using the method of logical relations, and how much it was influenced by category theory originally isn't completely clear, it certainly doesn't work by casting polymorphic types as natural transformations.
17:25:36 <halberd> the latter part should be done as efficiently as possible
17:25:55 <halberd> both in the number of points you are given initially, and in the number of real numbers you are given in the latter part
17:26:05 <ddarius> halberd: You lost me at "you are given a set of real numbers."
17:26:59 <co_dh> how the concept of fixed point are treated in Category theory? 
17:27:13 <halberd> ddarius, should I clarify, or what?
17:27:56 <halberd> you are given a set A of points in the plane, and may pre-process A, and then are given any number of sets B of real numbers
17:28:30 <halberd> if you're objecting to "infinite precision" then they can both be integers
17:28:39 <Draconx> halberd, computers can't, in general, represent arbitrary real numbers.  So you need to clarify exactly what kind of numbers you mean.
17:28:45 <halberd> Z2 and Z instead of R2 and R
17:28:46 <ddarius> co_dh: A variety of ways depending on what you are doing.  However, fix being fix isn't too important.  I could find other examples.
17:29:14 <halberd> and this is a practical problem
17:30:27 <napping> is there one set of numbers you get or several?
17:30:56 <halberd> the sets B are processed sequentially, multiple of them but we really just have to worry about one
17:31:05 <co_dh> halberd: put points in a dictionary , with x as key, and ys as value. 
17:31:05 <halberd> some assumptions we can make, for any number x in B, the number of points in A of the form (x,y) or (y,x) is large
17:31:27 <halberd> so we want to be efficient in terms of that
17:31:38 <napping> I don't see enough structure to make it hard
17:32:01 <halberd> well I have a solution that's more efficient than the naive solution in many cases
17:32:10 <halberd> but it may not be the best
17:32:11 <napping> it sounds like you need to consider for each x in B, for each pair (x,y), whether y is in b
17:32:37 <halberd> that takes too long, because the number of such pairs (x,y) is large
17:32:52 <halberd> on the order of |B|
17:33:03 <gwern> > 2011 - 1957
17:33:03 <lambdabot>   54
17:33:37 <napping> what is the practical problem?
17:33:50 <halberd> a type of Medicare edit called CCI
17:33:56 <co_dh> @free reverse :: [a] -> [a]
17:33:56 <lambdabot> $map f . reverse = reverse . $map f
17:34:20 <co_dh> :t $map
17:34:21 <lambdabot> parse error on input `$'
17:34:40 <co_dh> what's the $map here? 
17:34:50 <halberd> a billing rule
17:35:45 <halberd> now there is an algorithm where you can do fast set intersection
17:35:45 <napping> so, the problem is symmetric
17:35:55 <halberd> yeah the set of points is symmetric around the line y=x
17:36:20 <napping> something like Map Double (Set Double) to represent the pairs
17:36:33 <halberd> for fast set intersection between X and Y, first you sort both of them
17:36:40 <halberd> where X and Y are sets of numbers
17:36:54 <halberd> first sort both of them, then start with the smallest member of each
17:37:01 <napping> then you can filter the outer and inner set
17:37:21 <halberd> and "leapfrog" the current element of X and Y over each other
17:37:35 <halberd> so you don't have to look at all elements of the set - you can skip most, if X and Y are favorably distributed
17:38:11 <halberd> so this is good - for a given number x you store X as the set of numbers y such that (x,y) is in A
17:38:17 <halberd> or such that (y,x) is in A
17:38:35 <napping> how many points, anyway?
17:38:57 <halberd> and compute fast set intersection between X and B, to see if there are any points (x,y) in A
17:39:04 <halberd> where y is also in B
17:39:28 <gwern> lambdabot: @join #lesswrong
17:39:30 <halberd> napping, it's a laughably small number, but it runs on a server that is very taxed for resources and has to hit disk all the time
17:39:38 <halberd> so performance is very important
17:39:52 <halberd> 10,000 disk references is bad
17:40:09 <halberd> |B| is actually less than 1000
17:40:15 <napping> if it's a small set of pairs, why would it ever go to disk for them?
17:40:33 <halberd> well |A| is quite large
17:40:45 <copumpkin> lambdabot: @join #categorytheory
17:40:45 <lambdabot> Not enough privileges
17:40:46 <halberd> I forget how large exactly, either tens or hundreds of thousands
17:41:08 <halberd> well I don't know napping I'm not a server systems guy I'm a dev
17:41:19 <halberd> but for some reason we have an extremely tight memory limit per process
17:41:47 <napping> that doesn't sound very large
17:41:51 <halberd> we do buffer pages we read from disk
17:42:00 <halberd> but loading a page is tough
17:42:08 <Draconx> halberd, what's wrong with a b-tree?
17:42:10 <halberd> it's ridiculously small napping , measured in kilobytes I believe
17:42:38 <napping> that sounds quite absurd
17:42:55 <halberd> maybe it's a couple of megabytes
17:42:58 <halberd> not larger than that
17:43:40 <halberd> the rule of thumb is if you want to store more than 1000 pieces of data you should use a data structure that can page to disk if necessary
17:44:38 <halberd> there's a lot of users on each server so I guess that partially explains it
17:45:07 <napping> unless there are tens of thousands of users, you should have at least a few megabytes
17:45:32 <halberd> I think it's like 2 mb, but a lot of that is taken up with other stuff
17:45:53 <napping> anyway, unless there is more structure in the set of points you will have to do the filtering you suggested
17:47:38 <napping> are you perhaps trying to run this as CGI?
17:48:22 <halberd> eh think of it like that
17:48:51 <napping> sounds like your problem is the platform and not the algorithm
17:49:05 <halberd> well any algorithm that is N^2 smells bad to me
17:49:13 <siracusa> Using HList, I'm trying to intersect two lists. I defined `instance TypeEq A A HTrue' for a data type A. Now I want the equality test to be HFalse for all other data types if A is one of them. How to do this?
17:49:16 <halberd> I think that what I suggested will be fast enough for practical purposes
17:49:26 <halberd> but it would be nice if I could do better
17:56:29 <sbahra_> Hey.
17:56:33 <sbahra_> Cale: :(
17:56:53 <sbahra_> @ask Cale Could lambdabot join #concurrencykit please?
17:56:53 <lambdabot> Consider it noted.
17:57:07 <siracusa> Defining instances for each pair of types A B works, though, but this cannot be the way to go.
17:58:47 <kfr> What's the shortest way to count the number of spaces at the beginning of a String?
17:59:40 <halberd> you just loop over it incrementing a counter
18:00:06 <kfr> I thought explicit recursion would exactly be the wrong way
18:00:07 <kfr> To do this
18:00:10 <xplat> it is
18:00:51 <xplat> > length . takeWhile (' '==) $ "   test"
18:00:52 <lambdabot>   3
18:01:04 <kfr> Ah, takeWhile
18:01:05 <kfr> Thanks
18:01:37 <xplat> there's probably something even better, like find
18:02:02 <xplat> > find (' ' /=) "   test"
18:02:03 <lambdabot>   Just 't'
18:02:11 <xplat> > findIndex (' ' /=) "   test"
18:02:12 <lambdabot>   Just 3
18:02:18 <kfr> Oh, nice
18:02:19 <kfr> Thanks
18:03:20 <xplat> that's probably your best bet if you don't worry about the case where it's all spaces
18:21:22 <kfr> What container do I use when I want O(1) random access?
18:21:25 <kfr> Data.Vector?
18:21:51 <kfr> Or Data.Array hmm
18:23:19 <kfr> That bounds business in Data.Array is odd
18:23:22 <kfr> I don't need that at all
18:23:50 <co_dh> hash table is also O(1)
18:25:11 <elliott> co_dh: at what?
18:25:19 <elliott> hash tables aren't actually O(1), because that completely ignores collisions.
18:26:11 <co_dh> elliott: agree. 
18:26:50 <co_dh> elliott: are you conal? 
18:27:11 <elliott> co_dh: No, and nor am I elliottt, but if everyone pretended I was those two people (simultaneously), that would be just fine.
18:27:20 <elliott> I'm also not elliottcable as he has pointed out
18:27:29 <elliott> I am elliott, though
18:27:38 <djahandarie> elliott, perhaps a new nick would be in order :P
18:27:46 <djahandarie> I guess this channel alone isn't important enough for that
18:27:54 <Cale> It also ignores the time it takes to compute the hash, which assuming the hash table is large enough to hold its elements without collisions, will take at least log time to compute.
18:27:54 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:27:57 <elliott> djahandarie: Hell with that, do you realise how many years I spent knowing I'd never own my first name as a nick?!
18:28:09 <elliott> But then! Then! Whoever owned it didn't log in for ages! And now it is mine! Forever!!
18:28:10 <monochrom> we need more eliot, elliot, eliott, ellliott...
18:28:26 <ddarius> @fresh
18:28:26 <lambdabot> Hady
18:28:27 <elliott> monochrom: yeah, if you want to support the incorrect spelling, I suppose
18:28:34 <ddarius> Quick, everyone select a name!
18:28:35 <Cale> lambdabot: @join #concurrencykit
18:28:37 <elliott> Cale: Indeed.
18:28:42 <elliott> Hash tables are overrated.
18:29:49 <btutt> Overused maybe, sometimes good enough is good enough :)
18:29:50 <Draconx> when considering asymptotic complexity of comparison-based data structures, the usual convention is to count only the number of comparisons.
18:30:28 <monochrom> there is a recent http://hackage.haskell.org/package/unordered-containers
18:31:16 <Draconx> (unless explicitly stated otherwise)
18:31:19 <elliott> Draconx: that would only apply if all associative maps required hashing.
18:31:20 <elliott> which they do not
18:31:26 <elliott> (I assume that's in reply to the log hashing comment)
18:31:43 <ddarius> Draconx: Therefore hash tables are O(0)
18:31:50 <elliott> ddarius: Brilliant!
18:31:54 <elliott> Give this man a Ph.D.
18:32:13 <elliott> Therefore hash tables are O(-27).
18:32:17 <elliott> I think that's the fastest anyone's ever gone.
18:33:45 <monochrom> beware of dubious assumptions in certain asymptotic analyses (especially the folklore ones) (although some other asymptotic analyses are fine)
18:34:33 <ddarius> Yeah, like the aphysicality of RAM.
18:37:04 <elliott> Does anyone want to have a go at answering my insanely convoluted monad-architecturing question from much earlier today? :-) (I'd paste it for reference, but it's quite a few lines long ...)
18:38:44 <xplat> ah, if only RAM was physical.  with the variable word-length and everything.
18:39:11 <xplat> be a really handy thing to have
18:40:15 <elliott> RAM is actually PURE PLASMA.
18:40:43 <geheimdienst> i'm kinda sure it's impure
18:44:48 <Draconx> ddarius, hash tables (at least ordinary ones) require at least one comparison.  So you won't have O(0) comparisons.
18:52:33 <kfr> I want to perform a ByteString.split but it takes a Word8 and I am not sure how to convert a '\n' to that
18:53:59 <kfr> http://www.haskell.org/hoogle/?hoogle=Char+-%3E+Word8
18:53:59 <ClaudiusMaximus> > ord '\n'
18:54:00 <lambdabot>   10
18:54:04 <Zao> > (fromIntegral $ ord '\n') :: Word8
18:54:04 <kfr> Oh, I see
18:54:04 <lambdabot>   10
18:54:11 <kfr> Thanks
18:54:17 <Zao> @type ord '\n'
18:54:17 <lambdabot> Int
18:54:19 <monochrom> you can actually use Char8.split, it takes a Char
18:54:38 <monochrom> you can mix Char8 and non-Char8 functions.
19:00:45 <int80_h> anyone here familiar with the codebase for haskellers.com?
19:23:05 <xplat> just make a hashtable that serializes the entire key and uses that as an index.  no comparisons needed!  no collisions to worry about!
19:23:54 <xplat> all you need is an exponential amount of memory
19:25:21 * jmcarthur finally discovers the awesome lurking inside delimited continuations
19:26:32 <halberd> in Cache you use sorted sets
19:26:42 <halberd> multi dimensional
19:27:01 <halberd> sorted hierarchical sets
19:27:20 <xplat> if you have delimited continuations and first-class generative prompts you can express lazy evaluation as a purely control effect, no references/cells needed
19:27:39 <jmcarthur> xplat: :o
19:27:51 <justin-kp> does haskell do pointer tagging to speed up performance of pattern matching?
19:27:55 <ddarius> If you have delimited continuations, you can express all effects.
19:28:37 <ddarius> justin-kp: GHC does.  
19:29:00 <halberd> hierarchical sets are really something
19:29:10 <halberd> sorted sets
19:29:24 <justin-kp> ddarius: how many bits are available for the tag?
19:29:40 <ddarius> 2 on 32-bit architectures, 3 on 64-bit.
19:30:33 <justin-kp> ddarius: so does this mean pattern matching will be much faster if i keep num constructors 8 or less on 64 bit?
19:30:46 <justin-kp> or should i not worry about that too much
19:31:13 <ddarius> You shouldn't worry about it too much, but there will be a discontinuity in performance if you have 8 or more constructors.
19:31:33 <justin-kp> ddarius: you mean 9 or more?
19:31:36 <ddarius> No.
19:32:25 <justin-kp> 3 bits = 8 possible values?
19:32:47 <ddarius> Yes.  8 possible values /= 8 constructors.
19:33:40 <justin-kp> is one of the combinations of bits reserved for something else?
19:33:50 <halberd> probably 0 is reserved for nothing
19:34:03 <ddarius> justin-kp: Thunks
19:34:24 <justin-kp> ddarius: ah makes sense
19:34:57 <xplat> see garcia, lumsdaine, and sabry: 'lazy evaluation and delimited control', 2009
19:35:10 <justin-kp> ddarius: thanks for explanation
19:35:35 <jmcarthur> xplat: thanks!
19:37:07 <ddarius> jmcarthur: The traditional references for this sort of thing would be "Representing Monads" and "Representing Layered Monads."
19:38:32 <ddarius> > logBase 8 7
19:38:32 <lambdabot>   0.9357849740192015
19:38:46 <ddarius> > logBase 2 7
19:38:47 <lambdabot>   2.807354922057604
19:39:33 <jmcarthur> ddarius: you get a thanks too
20:12:08 <levifikri> Hi, what is the best way to convert Int to Word8?
20:12:13 <levifikri> I meant [Word8]
20:20:05 <roconnor_> levifikri: big endian or little endian?
20:21:32 <roconnor_> levifikri: how do you want to handle negative numbers?
20:28:29 <levifikri> reconnor_ either big/little endian would be ok. No negative number.
20:31:47 <roconnor_> > unfoldr (\x -> guard (x > 0) >> quotrem x 256) 12345678
20:31:48 <lambdabot>   Not in scope: `quotrem'
20:32:02 <roconnor_> > unfoldr (\x -> guard (x > 0) >> quotRem x 256) 12345678
20:32:02 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a, b)'
20:32:03 <lambdabot>         against infe...
20:32:44 <roconnor_> @type unfoldr
20:32:44 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:33:49 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return (quotRem x 256)) 12345678
20:33:50 <lambdabot>   [48225,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
20:34:05 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return . swap (quotRem x 256)) 12345678
20:34:06 <lambdabot>   Not in scope: `swap'
20:34:45 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return . Data.Tuple.swap (quotRem x 256)) 12345678
20:34:45 <lambdabot>   Not in scope: `Data.Tuple.swap'
20:35:02 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return . (\(a,b) -> (b,a)) (quotRem x 256)) 12345678
20:35:03 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
20:35:03 <lambdabot>         against inferred ...
20:35:21 <roconnor_> > unfoldr (\x -> guard (x > 0) >> (return . \(a,b) -> (b,a)) (quotRem x 256)) 12345678
20:35:23 <lambdabot>   [78,97,188]
20:35:33 <roconnor_> levifikri: ta
20:35:57 <roconnor_> probably can do better
20:38:13 <roconnor_> > unfoldr (\x -> guard (x > 0) >> (return (let a = fromIntegral x in (a, shiftR x (bitsize a))) 12345678
20:38:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:38:21 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return (let a = fromIntegral x in (a, shiftR x (bitsize a))) 12345678
20:38:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:38:36 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return (let a = fromIntegral x in (a, shiftR x (bitsize a)))) 12345678
20:38:36 <lambdabot>   Not in scope: `bitsize'
20:38:46 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return (let a = fromIntegral x in (a, shiftR x (bitSize a)))) 12345678
20:38:47 <lambdabot>   Ambiguous type variable `b' in the constraint:
20:38:47 <lambdabot>    `Data.Bits.Bits b'
20:38:48 <lambdabot>      a...
20:38:54 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return (let a = fromIntegral x in (a, shiftR x (bitSize a)))) 12345678 :: [Word8]
20:38:54 <lambdabot>   Ambiguous type variable `b' in the constraint:
20:38:55 <lambdabot>    `Data.Bits.Bits b'
20:38:55 <lambdabot>      a...
20:39:17 <ClaudiusMaximus> > bitSize (0 :: Integer)
20:39:18 <lambdabot>   *Exception: Data.Bits.bitSize(Integer)
20:39:45 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return (let a = fromIntegral x in (a, shiftR x (bitSize a)))) (12345678::Int) :: [Word8]
20:39:46 <lambdabot>   Ambiguous type variable `b' in the constraint:
20:39:46 <lambdabot>    `Data.Bits.Bits b'
20:39:46 <lambdabot>      a...
20:40:59 <roconnor_> hmm it works for me in ghci
20:41:20 <roconnor_> 12345678 :: Word8
20:41:24 <roconnor_> > 12345678 :: Word8
20:41:25 <lambdabot>   78
20:43:34 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return ((\a-> (a, shiftR x (bitSize a))) (fromIntegral x))) (12345678::Int) :: [Word8]
20:43:35 <lambdabot>   [78,97,188]
20:43:38 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return ((\a-> (a, shiftR x (bitSize a))) (fromIntegral x))) (12345678::Int) :: [Word16]
20:43:39 <lambdabot>   [24910,188]
20:43:43 <roconnor_> > unfoldr (\x -> guard (x > 0) >> return ((\a-> (a, shiftR x (bitSize a))) (fromIntegral x))) (12345678::Int) :: [Word32]
20:43:44 <lambdabot>   [12345678]
20:44:10 <roconnor_> lambdabot doesn't have the monomorphism restriction
20:44:16 <roconnor_> that's why it work for me in ghci
20:44:24 <roconnor_> ya monomorphism restriction!
20:44:50 <roconnor_> *yay
20:45:24 <roconnor_> @pl (\a-> (a, shiftR x (bitSize a))
20:45:24 <lambdabot> (line 1, column 32):
20:45:25 <lambdabot> unexpected end of input
20:45:25 <lambdabot> expecting variable, "(", operator or ")"
20:45:28 <roconnor_> @pl (\a-> (a, shiftR x (bitSize a)))
20:45:28 <lambdabot> ap (,) (shiftR x . bitSize)
20:45:33 <ddarius> > bitSize 0
20:45:34 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:45:34 <lambdabot>    `Data.Bits.Bits t'
20:45:34 <lambdabot>      a...
20:45:38 <ddarius> > bitSize (0 :: Integer)
20:45:39 <lambdabot>   *Exception: Data.Bits.bitSize(Integer)
20:45:43 <roconnor_> @pl (\x -> guard (x > 0) >> return ((\a-> (a, shiftR x (bitSize a))) (fromIntegral x)))
20:45:43 <lambdabot> ap ((>>) . guard . (> 0)) (return . ap (ap (,) . (. bitSize) . shiftR) fromIntegral)
20:46:38 <roconnor_> > unfoldr (ap ((>>) . guard . (> 0)) (return . ap (ap (,) . (. bitSize) . shiftR) fromIntegral)) 12345678 :: [Word8]
20:46:40 <lambdabot>   [78,97,188]
20:47:26 <roconnor_> > unfoldr (ap ((>>) . guard . (> 0)) (return . ap (ap (,) . (. bitSize) . shiftR) fromIntegral)) 12345678 :: [Word16]
20:47:27 <lambdabot>   [24910,188]
21:10:36 <dmwit> > '\x0840'
21:10:37 <lambdabot>   '\2112'
21:10:48 <dmwit> > '\x2B740'
21:10:49 <lambdabot>   '\177984'
21:11:03 <dmwit> > maxBound :: Char
21:11:04 <lambdabot>   '\1114111'
21:11:32 <dmwit> So, what, every codepoint is valid, even the ones that haven't been defined yet?
21:12:59 <Draconx> dmwit, well, other than some holes in the middle, unicode defines code points up to U+10FFFF.
21:13:31 <shachaf> dmwit: Why not?
21:14:09 <dmwit> Draconx: Yup, I was just wondering what GHC did with the holes. Looks like it just accepts them.
21:14:14 <dmwit> shachaf: *shrug*
21:14:20 <ClaudiusMaximus> > let ok [] = True ; ok (c:cs) = c `seq` ok cs in ok ( [minBound .. maxBound] :: String )
21:14:21 <lambdabot>   True
21:14:25 <ion> It would be fun to have Haskell programs crash when receiving characters defined in a new version of Unicode before Haskell has been updated to match.
21:14:38 <ion> s/before Haskell/before the Haskell implementation/
21:14:58 <shachaf> ion: That's true. And fun is an important thing to optimize for in language design.
21:15:02 <dmwit> ClaudiusMaximus: No fair, .. could skip some.
21:15:33 <dmwit> > let enumFromTo a b = [a, b] in [minBound .. maxBound] :: String
21:15:34 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
21:15:42 <dmwit> Anyway, you get my point.
21:16:01 <ClaudiusMaximus> > let ok [] = True ; ok (c:cs) = chr c `seq` ok cs in ok [ord minBound .. ord maxBound]
21:16:03 <lambdabot>   True
21:16:14 <dmwit> > length [minBound .. maxBound]
21:16:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:16:15 <lambdabot>    `GHC.Enum.Bounded a'
21:16:15 <lambdabot>    ...
21:16:21 <dmwit> > length [minBound .. maxBound :: Char]
21:16:22 <lambdabot>   1114112
21:16:32 * dmwit is mollified
21:17:04 * shachaf suspects that dmwit has been playing NetHack again.
21:17:40 <btutt> libraries should let applications deal with badly formed Unicode code point streams
21:18:08 <dmwit> shachaf: Oh, yes, I feel like an angry god. =P
21:18:10 <shachaf> dmwit: What behavior would you want for non-defined code points?
21:18:24 <dmwit> shachaf: I didn't want to prescribe one. I was just curious what Haskell did.
21:18:58 <dmwit> I think I'm mostly unqualified to say what the right behavior is.
21:19:37 <shachaf> *Certainly* _|_ is not the correct behavior.
21:21:12 <dmwit> On the other hand, a lex/parse error for '\xwhatever' is not clearly the wrong behavior.
21:21:35 <dmwit> > '\x1114112'
21:21:36 <lambdabot>   <no location info>:
21:21:36 <lambdabot>      lexical error in string/character literal at chara...
21:21:56 <dmwit> The holes could do the same thing.
21:22:17 <shachaf> > chr (maxBound::Int)
21:22:18 <lambdabot>   *Exception: Prelude.chr: bad argument: 9223372036854775807
21:22:21 <shachaf> Hmm.
21:22:39 <mzero> that's one max integer!
21:22:54 <btutt> > '\x1114111'
21:22:55 <lambdabot>   <no location info>:
21:22:55 <lambdabot>      lexical error in string/character literal at chara...
21:23:00 <dmwit> Welcome to the 64-bit future, mzero. =)
21:23:13 <dmwit> > '\1114111' -- whoops
21:23:14 <lambdabot>   '\1114111'
21:23:22 * shachaf was surprised at Int being that big. Too much C.
21:23:31 <ion> dmwit: A discrepancy between how character literals work and how text read from e.g. a file works wouldn’t be very nice.
21:23:31 <dmwit> Anyway, if 1114112 is out of bounds, 0x1114112 is certainly out of bounds. =P
21:23:55 <btutt> > '\x10ffff'
21:23:56 <dmwit> ion: Would it be so bad if the file wasn't actually text?
21:23:56 <lambdabot>   '\1114111'
21:24:09 <dmwit> ion: I mean, if a file contains characters in the hole, it's not really text. Right?
21:24:24 <mzero> "the hole"? 
21:24:27 <ClaudiusMaximus> > read "'\\1114112'" :: Char
21:24:28 <lambdabot>   *Exception: Prelude.read: no parse
21:24:39 <btutt> mzero: undefined unicode code points
21:24:40 <dmwit> I certainly don't expect hGetLine to do sane things on my binary files.
21:24:47 <ion> dmwit: It could be text using a newer version of Unicode than what your Haskell implementation has.
21:24:54 <dmwit> yup
21:25:09 <dmwit> So could, potentially, characters beyond 0x10ffff.
21:25:31 <btutt> indeed. complaining about Unicode string/stream/whatever contents is an application policy problem
21:25:32 <mzero> one must be VERY careful with names here
21:25:59 <ClaudiusMaximus> > reads "'\\1114112'" :: [(Char, [String])]
21:26:00 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
21:26:00 <lambdabot>         against inferred ty...
21:26:19 <dmwit> All I'm saying is: the holes are treated differently than the too-large values. Whether that's good or bad is not clear to me, but I think one has to be careful that whatever excuses are made for the holes don't also apply to the too-large values.
21:26:42 <btutt> Characters beyond 0x10FFFF won't be defined. That wouldn't be Unicode any longer.
21:27:03 <mzero> one probably wants to define String in terms of Unicode code values -- 
21:27:45 <mzero> essentially one wants 0 ~ 0x10FFFF excluding the surrogate area 0xD800 ~ 0xDFFF
21:28:03 <mzero> those should all be all legal values in a String, and read from a file, and parsed from literals
21:28:17 <dmwit> > '\xd800'
21:28:18 <lambdabot>   '\55296'
21:28:45 <btutt> Hrm. so if '\x10ffff' parses. Does that imply Char in Haskell is 32bits of UTF-32 annoying-ness?
21:29:01 <dmwit> No, the implementation is not specified in the Report.
21:29:26 <dmwit> ?src Char
21:29:26 <lambdabot> data Char = C# Char#
21:29:36 <dmwit> ...helpful
21:29:49 <dmwit> Anyway, at a guess, GHC probably does use 32 bits.
21:29:55 <btutt> Blech
21:30:27 <mzero> btutt - no - it says absolutely nothing about how it is stored
21:30:30 <c_wraith> no such thing as UTF-32
21:30:47 <dmwit> Yeah, I was wondering about that.
21:31:00 <dmwit> UCS-4 is probably what he meant
21:31:02 <c_wraith> A Char is probably a machine word, internally.  Fast to access, easy to work with.
21:31:22 <mzero> points c_wraith at page 92 of chapter 3 of the Unicode spec
21:31:32 <btutt> http://en.wikipedia.org/wiki/UTF-32/UCS-4
21:31:42 <mzero> There is UTF-32....
21:31:45 <mzero> and it is well defined
21:32:37 <mzero> one might hope that Char were defined as a "Unicode scalar value" (0 ~ D7FF & E00 ~ 10FFFF)
21:32:57 <mzero> but they are probably defined in the H. spec as "Unicode code point" (0 ~ 10FFFF)
21:34:30 <btutt> I'd rather deal with UTF-16 most of the time unless I had some reason to encode extra data in high end bits of UTF-32 storage.
21:34:35 <c_wraith> dmwit already pointed out that '\xd800' is a valid char literal
21:34:36 <mzero> Unicode scalar values have the property that they are exactly the set of values that can be encoded in UTF-x 
21:34:45 <rwbarton> The Report says "The character type Char is an enumeration whose values represent Unicode characters"
21:34:59 <rwbarton> with a reference to the Unicode standard
21:35:05 <mzero> That is a sad definition
21:35:08 <rwbarton> I would take that to mean scalar value
21:35:08 <c_wraith> btut, don't worry, String isn't efficient anyway.  Throw it out.
21:35:15 <btutt> That would seem to indicate they'd have to be 32bits.
21:35:16 <mzero> since "Unicode character" is must more squirrely beast
21:35:23 <copumpkin> rwbarton: the CT library is coming along by the way!
21:35:31 <rwbarton> copumpkin: cool
21:35:32 <copumpkin> it's got lots of awesomeness in it now
21:35:33 <btutt> c_wraith: Yeah, started using Data.Text not that long ago.
21:35:43 <mzero> btutt - there is nothing in the standard that prevents an implementation from storing them internally as UTF-8 byte sequences
21:35:48 <copumpkin> rwbarton: there's also ##categorytheory as of a couple of days ago
21:36:02 <mzero> though, in fact, Char is a boxed 23 bit value in GHC
21:37:24 <c_wraith> practically, though, that's a machine word.  I doubt 64-bit GHC is going to store them more tightly packed than that.  word-aligned lookups are just that much faster.
21:38:57 <mzero> The problem with the Haskell spec's language is that there are "Noncharacters" in Unicode -- which I'm pretty certain are, and should, be allowed as Char values
21:38:58 <rwbarton> I think 64-bit GHC does use 64 bits for a Char#, yeah
21:39:31 <btutt> Oh ick. that just seems wrong.
21:40:05 <rwbarton> I might be confusing it with the box part though
21:40:10 <rwbarton> I'm not really sure
21:40:20 <btutt> heh
21:40:37 <c_wraith> remember, the Char type is designed to store a *single* unicode value.  Concerns for storing multiples of them efficiently belong to some other data type.
21:40:49 <rwbarton> I know Char uses more space on 64-bit than 32-bit.
21:41:03 <c_wraith> the only question is 50% or 100% more?
21:41:20 <rwbarton> right
21:41:22 <mzero> btutt - naw, it's not wrong -- in pretty much every language implementation, a bare character being operated on (rather than stored as part of a string), is going to take up a full machine word
21:41:22 <rwbarton> I don't know
21:41:58 <mzero> so - the only issue is when you're storing strings of 'em --- but in that case, String, or [Char] in Haskell, isn't what you want anyway -- you want Text
21:43:03 <dmwit> So, I'd like to point out that the folks that wrote the Haskell spec were language people, and very likely not Unicode experts. So in their defence, the chose what looked like the most comprehensive pre-existing specification for characters and went with it.
21:43:03 <mzero> even in C - when you say something like     char succ(char x) { x + 1; }   -- that char is going to be passed around as a full machine word
21:43:09 <dmwit> There's something to be said for that.
21:43:25 <btutt> To properly process the stuff you need text-icu like things anyway. The internal storage of UTF-8/UTF-16/UTF-32 ought to be mearly optimization
21:43:27 <jmcarthur> preflex: seen mmorrow
21:43:27 <preflex>  mmorrow was last seen on #ghc 1 year, 43 days, 3 hours, 21 minutes and 32 seconds ago, saying: * mmorrow is rtfm'ing
21:43:41 <mzero> dmwit - I'm not faulting them - just seeing ways it could be tightened up
21:44:00 <dmwit> So, is the Gtk2Hs site just completely down?
21:46:24 <btutt> Combining characters, complex scripts, argh! :)
21:50:40 <ManateeLazyCat> dmwit: Don't worry, i will find time fix it.
21:50:40 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
21:53:29 <ManateeLazyCat> @tell juhp Thanks.
21:53:30 <lambdabot> Consider it noted.
21:56:13 <juhp> :)
21:56:13 <lambdabot> juhp: You have 1 new message. '/msg lambdabot @messages' to read it.
22:08:33 <phr_> does vincent hanquez ever come here?
22:09:12 <anonchik> 1
22:14:34 <dmwit> ManateeLazyCat: Okay, great, thanks. =)
22:14:37 <phr_> @seen vincent
22:14:37 <preflex>  vincent was last seen on #perl 1 day, 8 hours, 57 minutes and 19 seconds ago, saying: and blonde hair
22:14:37 <lambdabot> Unknown command, try @list
22:32:21 <ManateeLazyCat> dmwit: I can't promise when, but i try, maybe i need learn WordPress and Windows knowledge that how to build window installer.
22:32:59 <ManateeLazyCat> dmwit: All data still in backup, just site can't restore after move server.
22:33:10 <ManateeLazyCat> dmwit: So build new version WordPress should work.
22:33:14 <dmwit> Ah, it's good that there's a backup. =)
22:33:42 <dmwit> Is there a way I can help?
22:34:14 <ManateeLazyCat> dmwit: If you master WordPress, you can ask Alex for gtk2hs data, then help me rebuild gtk2hs site.
22:34:37 <ManateeLazyCat> help us.
22:34:58 <ManateeLazyCat> dmwit: I must will do it, but won't next week, i'm so busy now. :(
22:35:43 <dmwit> Alright. When I get a chance, I'll try to install Wordpress at dmwit.com to learn about it.
22:36:04 <ManateeLazyCat> dmwit: Ok, thanks.
22:36:17 <ManateeLazyCat> dmwit: I will fix "gtk2hs windows installer" then.
22:36:44 <ManateeLazyCat> Install gtk2hs on Windows is painful.
22:36:58 <ManateeLazyCat> dmwit: Goodbye, i still in company, need back to work. :)
22:46:50 <sanders_> When using ghci, is it possible to get docs for a function? 
22:47:56 <sanders_> (kind of like ":i function", but to provide docs as well) 
22:49:31 <dmwit> Maybe, with some rc-hackery, but the simplest thing is probably just to open up your local haddocks in a browser next to your ghci session.
23:13:44 <greap> Hey. What does this mean: bytestring-0.9.1.7-3973950ef27fa829da48139a49f09e43 is shadowed by package bytestring-0.9.1.7-64b858f95ff0dacc8acf396bb53cf4b9?
23:14:58 <mzero> it means you have two builds of bytestring-0.9.1.7 installed!
23:15:01 <dmwit> It means you have two versions of bytestring-0.9.1.7 installed (perhaps by making yourself a patch?), with the two different package hashes shown, and that one of them is currently being ignored because the other was installed over it.
23:15:29 <dmwit> You can unregister the dominant one if the shadowed one is the one you really wanted.
23:19:44 <greap> How is that possible though?
23:19:54 <greap> I have just been using cabal.
23:39:18 <gio123> hi
23:46:37 <zenzike> hello!
23:48:43 <lpsmith> greap, dmwit,  it's possible when the dependencies that bytestring depends on are updated.   Also,  sometimes cabal-install is a little flaky
23:56:24 <greap> I seem to have got that now, but I'm getting this one now which doesn't seem to make sense: cabal: dependencies conflict: ghc-6.12.3 requires pretty ==1.0.1.2 however
23:56:26 <greap> pretty-1.0.1.2 was excluded because ghc-6.12.3 requires pretty ==1.0.1.1
