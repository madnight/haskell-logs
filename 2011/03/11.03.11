00:01:49 <solrize> lol
00:33:18 * hackagebot temporal-music-notation-demo 0.1.5 - generates midi from score notation.  http://hackage.haskell.org/package/temporal-music-notation-demo-0.1.5 (AntonKholomiov)
00:39:31 <profmakx> eh
00:59:37 <merijn> What's the canonical (if any) Iteratee library?
01:00:32 <pacak> merijn: http://okmij.org/ftp/Haskell/Iteratee/
01:00:51 <pacak> merijn: That was the first iteratee code
01:01:59 <pacak> merijn: But probably you should not use it in a real work.
01:02:31 <merijn> pacak: That's sorta why I wanted to know which library is the one most commonly used for "Real Work"
01:04:54 <pacak> merijn: That's up to you. http://hackage.haskell.org/package/enumerator-0.4.7 have more libraries, but http://hackage.haskell.org/package/iteratee-0.8.1.2 looks... More right. Dunno why.
01:05:11 <pacak> merijn: You can try both.
01:06:26 * hackagebot tdoc 0.3.0 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.3.0 (NicolasPouillard)
01:09:03 <lanjiao> Hi, sb know which can do the best job for generating etags for *.hs?
01:09:17 <quicksilver> hasktags as far as I know
01:09:29 <lanjiao> I tried gasbag hasktags, but both seems not good
01:09:49 <quicksilver> I know of nothing else.
01:10:37 <merijn> hmm, enumerator seems to have the more pleasant API
01:12:41 <pacak> merijn: Not really. iteratee uses usual syntax for joining - >>= and so on. In enumerator there are a a lot of ugly $$ and other obscure signs.
01:13:49 <lanjiao> neither of them can generate such function tags which the definition isn't start at the beginning of a line
01:14:11 <sritchie_> hey all -- I'm trying to install Haskell Platform on snow leopard, but when I run the installer (i386), i get a message saying "The installer could not install the software because there was no software to install."
01:14:29 <lanjiao> ya, i prefer iteratee
01:14:31 <sritchie_> so, as a quick question, what's the best way to get haskell running on OS X 10.6?
01:14:47 <co_dh> the Haskell Platform. 
01:15:19 <pacak> sritchie_: VM + linux + haskell platform :)
01:15:19 <merijn> sritchie_: Do you have Xcode installed? I think that's a prerequisite...
01:15:46 <sritchie_> merijn: yup, definitely do
01:16:11 <merijn> That's odd then
01:16:19 <co_dh> stritchie_ : which url you used to download the haskell platform? 
01:16:41 <sritchie_> chrome://downloads/Users/sritchie/Downloads/Haskell%20Platform%202011.2.0.0-i386.pkg
01:16:46 <sritchie_> oh, whoops, that's not helpful
01:17:23 <sritchie_> ttp://lambda.galois.com/hp-tmp/2011.2.0.0/Haskell%20Platform%202011.2.0.0-i386.pkg
01:17:32 <sritchie_> with an h, there
01:17:36 <co_dh> i386 is for 32 bit platform, 
01:18:09 <sritchie_> co_dh: I'll try the 64 bit
01:18:10 <merijn> co_dh: What's your point? The main OSX release is 32bit, the 64bit Haskell Platform build is experimental
01:18:15 <co_dh> use Haskell Platform 2011.2.0.0-x86_64.pkg	. 
01:18:24 <co_dh> 10.6 is 64 bit. 
01:18:29 <merijn> co_dh: Please don't give people wrong info
01:18:45 <merijn> 10.6 runs 32bit just fine
01:18:45 <co_dh> ok, let me google again.
01:19:14 <merijn> I was running the 32bit version of the previous Haskell Platform just fine
01:19:20 <sritchie_> I'm retrying the i386 download, and the 64 bit -- I'll see which one works
01:19:38 <sritchie_> and yeah, OS X can run 32 bit stuff just fine
01:20:07 <sritchie_> oh! one other question
01:20:08 <co_dh> In Snow Leopard, most built-in applications have been rebuilt to leverage the 64-bit x86-64 architecture (excluding iTunes, Front Row, Grapher and DVD Player applications).[26] They will run in 32-bit mode on machines with 32-bit processors, and in 64-bit mode on machines with 64-bit processors.
01:20:19 <merijn> If it doesn't, work you might wanna wait around for the repeated Haskell Platform mentions to summon dons or someone else working on HP to see if they can help
01:20:29 <co_dh> http://en.wikipedia.org/wiki/Mac_OS_X_Snow_Leopard
01:20:33 <co_dh> if the wiki is correct. 
01:20:36 <merijn> co_dh: Yes, but the OS itself is still running in 32bit and a lot of applications are as well
01:20:48 <co_dh> in fact, sritchie_ can verify if the system is running in 64 bit or 32 bit. 
01:21:07 <co_dh> merijn: yep, you are right. 
01:21:54 <co_dh> sritchie_:  can you verify is your download correct by check the md5sum? 
01:22:02 <sritchie_> let me do that now
01:24:01 <sritchie_> where can I find the md5sum? I don't see a link on the haskell platform page
01:24:48 <sritchie_> the other question I had -- it seems the haskell-mode for emacs page on haskell.org is gone
01:24:48 <sritchie_> http://projects.haskell.org/haskellmode-emacs/
01:26:23 <sritchie_> does anyone have any recommendations for emacs configuration?
01:27:39 <merijn> sritchie_: Looks like the darcs repo of emacs-haskellmode is still alive: http://code.haskell.org/haskellmode-emacs/
01:27:51 <merijn> I don't have any experience with emacs, though
01:28:56 <sritchie_> is there a "standard" editor for haskell?
01:29:02 <sritchie_> or a preferred editor?
01:29:11 <co_dh> http://lambda.galois.com/hp-tmp/2011.2.0.0/md5sum.txt
01:29:21 <merijn> Most people seem to use either vim or emacs, same are using Yi I guess
01:29:32 <merijn> s/same/some
01:29:47 <runiq> Has anybody tried leksah?
01:30:00 <Jafet> The ghci prompt
01:30:00 <co_dh> I have trouble to install Yi on debian.
01:31:49 <sritchie_> hey, bad md5sum
01:31:55 <sritchie_> I'll wait for the re-download
01:32:37 <hpaste> adrake pasted "Error: Use better pragmas"  http://hpaste.org/44687
01:33:42 <mjrosenb> adnap: that is kinda epic.
01:34:13 <mjrosenb> hrmm, adrake is not in here.  he should fix that
01:38:08 <gienah> co_dh: maybe you can create debian yi using the gentoo patches: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/app-editors/yi
01:50:42 <hpaste> Ptival pasted "Could not deduce (Functor m)"  http://hpaste.org/44688
01:52:21 <Jafet> Shouldn't there also be (Monad m) =>
01:53:08 <Jafet> Also, I think the Functor instance comes from Control.Applicative
01:53:24 <Ptival> I'm quite lost so I'll just try anything you might hint me to do
01:54:06 <Jafet> I suspect you just need those two things.
01:54:20 <mun_> for the notation {f(1,t,2) \in S | t < 3} does this mean that the first and third argument of *all* f's in S are 1 and 2 respectively? or is that a constraint?
01:55:27 <Jafet> I've never seen that notation in Haskell
01:55:51 <Ptival> Jafet: what two things?
01:56:20 <Jafet> Ptival: an assertion that m is a Monad, and importing the Monad m => Functor m instance from Control.Applicative.
01:56:29 <Ptival> ok I'll try this
01:57:59 <Jafet> Hrm, that might not be right
01:58:04 <Jafet> @instances Functor
01:58:05 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
01:58:46 <Jafet> I thought there was a Monad instance
01:59:50 <shachaf> Jafet: Not that I know of.
02:00:00 <mmaurer> I forget, is thre something of the form (IO a -> IO (Maybe a)) for error catching? I can't seem to find one with hoogle.
02:00:12 <shachaf> You'd need... OverlappingInstances, or some other extension.
02:01:44 <Jafet> fmap f t = t >>= return . f
02:02:11 <Ptival> Jafet: I just added a Functor m assertion
02:02:38 <Ptival> seems to fit well with the rest of my code
02:03:06 <Jafet> That works practically because most Monads are also instances of Functor
02:03:23 <Jafet> @instances Monad
02:03:23 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
02:19:42 * hackagebot DifferentialEvolution 0.0.1 - Global optimization using Differential Evolution  http://hackage.haskell.org/package/DifferentialEvolution-0.0.1 (VilleTirronen)
02:21:44 <itsnotvalid> hello guys
02:22:24 <mjrosenb> itsnotvalid: hello.
02:22:37 <rostayob> Is there some ordered set which can work with a user defined comparing function, and not Eq?
02:22:45 <itsnotvalid> i've installed cabal in my own directory ~/.cabal
02:23:07 <rostayob> well and not Ord actually.
02:23:20 <itsnotvalid> but even with path like /home/itsnotvalid/.cabal/bin, i still get the cabal installed in /usr/bin
02:24:04 <itsnotvalid> which cabal -> /home/itsnotvalid/.cabal/bin/cabal, but cabal --version still points to an old version
02:25:32 <mjrosenb> itsnotvalid: what does file `which cabal` say?
02:25:47 <itsnotvalid> which cabal -> /home/itsnotvalid/.cabal/bin/cabal
02:25:55 <mjrosenb> rostayob: sortBy?
02:26:04 <mjrosenb> itsnotvalid: right, and the file bit?
02:26:38 <itsnotvalid> mjrosenb, what's file bit?
02:26:40 <rostayob> mjrosenb: No, I mean I want to have an ordered set like Data.Set but with another ordering function, not "compare"
02:26:50 <rostayob> mjrosenb: anyway i'll just write it, should be easy.
02:27:00 <mjrosenb> itsnotvalid: file `which cabal`
02:27:15 <rostayob> well actually no, since Data.Set does not export its constructors...
02:27:28 <aleator> yay. My second public cabal package is uploaded.
02:27:37 <itsnotvalid> mjrosenb: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, stripped
02:27:47 <mjrosenb> rostayob: just copy them all to another file (note: this is the wrong way to do it)
02:28:03 <itsnotvalid> aleator: congrats
02:28:09 <rostayob> mjrosenb: yeah, it's definitely the wrong way to do it :P. is there another way?
02:28:35 <mjrosenb> itsnotvalid: fun.  if you manually run ~/.cabal/bin/cabal --version, does it print out the right number?
02:28:38 <merijn> Am I the only one who keeps associating cabal with the homicidal AI in command & conquer? >.>
02:29:23 <itsnotvalid> mjrosenb, it print out the 0.8.2 and Cabal 1.8.0.6, the same thing as in ghc-pkg
02:30:07 <itsnotvalid> but the point is, there is Cabal-1.10.1.0, I don't know why it gets 1.8.0.6 under the belt
02:30:56 <mjrosenb> err, when you say cabal, i assume you mean cabal-install
02:31:06 <mjrosenb> since cabal does not actually include an executable
02:31:25 <itsnotvalid> yes i am talking about cabal-install
02:31:33 <itsnotvalid> /usr/bin/cabal -> 0.8.0
02:31:44 <itsnotvalid> .cabal/bin/cabal -> 0.8.2
02:32:09 <rostayob> mjrosenb: isn't there another way of doing it? it'd bee 15 lines of code if I had access to the constructors
02:32:59 <quicksilver> rostayob: use Data.Set and newtype your member type?
02:33:04 <quicksilver> (and give it a different Ord instance)
02:33:09 <mjrosenb> rostayob: you could define a new Ord for (a -> a -> Ord, a), which uses the built in compare function
02:33:41 <quicksilver> mjrosenb: tuples already have an Ord instance.
02:33:58 <mjrosenb> quicksilver: -XflexibleInstances?
02:34:06 <mjrosenb> and you need another one i think
02:34:11 <merijn> Speaking of newtype, as I understand it a newtypes datatype will inherit all typeclass instances of the original type, except those you explicitly specify for the newtype?
02:34:15 <quicksilver> overlapping, which is forbidden.
02:34:29 <quicksilver> merijn: no, they inherit no instances, except those you explicitly specify.
02:34:36 <merijn> quicksilver: ah
02:34:43 <rostayob> mjrosenb: the thing is that my ordering function needs the current time to work
02:34:57 <mjrosenb> rostayob: ow.
02:35:25 <mjrosenb> rostayob: i've frequently wanted ways of easily lifting classes into IO
02:35:25 <rostayob> so I can't really use Ord
02:35:58 <rostayob> I need something that is like a -> a -> UTCTime -> Ordering
02:36:30 <merijn> rostayob: Can't you just convert the set to a list when you need to order it and sort that using sortBy?
02:37:01 <rostayob> merijn: that's not really efficient, why use sets at all then?
02:37:08 <greap> Hey guys. I just installed the new haskell platform and agda and had no issues, however, after trying to install yi and its dependencies I now have a cabal package error, and agda unable to run. I've had this happen a few times in the past and am wondering if there's something I can do to avoid it.
02:37:25 <mjrosenb> rostayob: if the sorting is actually dependent on the current time, then i suspect *really* bad things will happen if the ordering between twe elements in the set changes
02:37:41 <itsnotvalid> greap: cabal gives me headaches
02:38:04 <greap> I can 'fix' the error by deleting my user's cabal files, but that's a lot of new compiling to do, and the error recurrs eventually.
02:38:09 <itsnotvalid> i am figuring my way out for getting 7.0.2 running without using sudo
02:38:36 <rostayob> mjrosenb: not really, because while it depends on the current time, the ordering doesn't change until you change another factor of that datatype.
02:38:36 <greap> itsnotvalid: Ah, I just installed haskell platform system-wide
02:38:43 <rostayob> another member
02:38:53 <mjrosenb> itsnotvalid: i usually just use my package manager for everything; i *really* dislike having multiple package-manager like things running at the same time
02:39:48 <greap> mjrosenb: I actually really enjoy running multiple package managers, such as rubygems, and macports. But cabal always seems to have issues.
02:40:00 <itsnotvalid> mjrosenb, what systeam are u using? i am using ubuntu and there is no 7.0.*
02:40:22 <itsnotvalid> i have no way but to build everything myself... and it's painful, but only if there is better choices
02:41:28 <scree> rostayob: it seems the best thing you could do would be to make backwards-compatible changes to the Set interface
02:41:33 <itsnotvalid> there is also no way of using just one single package manager if every package are only built for one package manager... look at gem, pypi, cabal, npm, whatever... every language has one manager
02:41:34 <greap> I also wondered if there would be some way I could build a cabal package separately from the main user files so that it would continue to work if I buggered something else up.
02:41:54 <itsnotvalid> greap: cabal-dev?
02:42:23 <greap> itsnotvalid: awesome!
02:42:49 <mjrosenb> itsnotvalid: i use gentoo; portage seems to have all of those things in it
02:43:21 <scree> rostayob: you want to store a comparison function in the *set*, not on some type level; so have a type 'CunningSet a' and make 'Set a' a specialization of it with a newtype
02:43:30 <mjrosenb> itsnotvalid: and if it does not, then most languages that have such repositories have scripts that will convert the repositories package format to an ebuild
02:43:54 <merijn> itsnotvalid: It'll probably take a few months for Ubuntu to distribute the new Haskell Platform
02:45:24 <itsnotvalid> well i once used gentoo... but later just be lazy not to ebuild everything in portage... yes the packages are really up-to-date or so with portage, but that some languages' packaging system works better than portage
02:45:59 <itsnotvalid> but cabal is far from that...it's just pain, with those cross referencing hell
02:47:12 <itsnotvalid> merijn: exactly, so that's why I am installing without that
02:48:38 <mjrosenb> itsnotvalid: anyhow, the issue is that you have installed cabal-1.10.* with cabal-install, and it is only picking up a older version installed by apt?
02:49:09 <itsnotvalid> mjrosenb: i am reinstalling everything right now, hold on
02:54:55 <rostayob> scree: sorry about the late reply. that seems like a nice idea actually, but I still don't see how it works
02:55:14 <rostayob> scree: I mean at the end I'm going to insert stuff in the original set right?
03:17:20 * hackagebot DifferentialEvolution 0.0.2 - Global optimization using Differential Evolution  http://hackage.haskell.org/package/DifferentialEvolution-0.0.2 (VilleTirronen)
03:19:20 <Ptival> itsnotvalid: personally, I just put alias cabal='~/.cabal/bin/cabal' in my .bashrc
03:20:14 <itsnotvalid> Ptival: sounds likea good idea, let me try that if it doesn't work after reinstalling
03:20:20 <Ptival> this way I don't use anymore the cabal in my haskell-platform...
03:21:47 <Ptival> but it might be troublesome if you use tools that will try to use cabal (since which cabal is still /usr/bin/cabal)
03:22:28 <itsnotvalid> i gonna uninstall the old platform if it doesn't listen
03:22:29 <Jafet> Well, the proper improper way is to add ~/.cabal/bin to PATH
03:22:48 <Jafet> Which is also required by some other build tools (c2hs?)
03:23:32 <Ptival> how are PATH conflicts resolved?
03:24:19 <merijn> Ptival: What do you mean by PATH conflict?
03:24:24 <Ptival> (rather, a program conflict for two paths in PATH)
03:24:58 <merijn> The first path found is used
03:25:02 <Ptival> ok
03:25:10 <merijn> i.e. once a match is found the rest of $PATH is never checked
03:25:18 <Ptival> ok
03:25:20 <Ptival> from the left
03:25:23 <merijn> Yes
03:41:07 <micrypt> In this case: let xss = [[1,2,3,4,5],[5,6,7,8]] 
03:41:09 <micrypt> [ [ x | x <- xs, even x ] | xs <- xxs]  
03:41:37 <micrypt> * [ [ x | x <- xs, even x ] | xs <- xss]  
03:41:56 <micrypt> How does the list comprehension know to dig one level deeper?
03:42:09 <merijn> What do you mean?
03:42:19 <Zao> It's powered by Skynet.
03:42:23 <merijn> There's two list comprehensions, one inside the other
03:43:18 <micrypt> merijn: Yes, but I would've expected it to view the list as a whole not the sublists... (I'm completely new to Haskell.)
03:43:42 <merijn> [ foo | xs <- xxs] just means "do foo for every item xs in xxs"
03:44:02 <micrypt> merijn: Ah, thanks.
03:44:11 <Zao> micrypt: What is your comprehension even supposed to do?
03:44:16 <Zao> It doesn't typecheck here.
03:44:24 <Zao> Oh, wrong input.
03:45:17 <merijn> micrypt: So you are saying "return a list where for every list xs in xxs, you create a list which contains all x in xs (where even x is true) "
03:45:34 <Zao> > let f xxs = [ [ x | x <- xs, even x ] | xs <- xxs] in f [[1,2,3,4,5],[5,6,7,8]]
03:45:35 <lambdabot>   [[2,4],[6,8]]
03:45:37 <Zao> > let f xxs = [ g xs | xs <- xxs]; g xs = [ x | x <- xs, even x ] in f [[1,2,3,4,5],[5,6,7,8]]
03:45:38 <lambdabot>   [[2,4],[6,8]]
03:45:38 <merijn> micrypt: Which book/site/tutorial are you using?
03:45:46 <micrypt> merijn: Yes. 
03:46:24 <micrypt> Learn You A Haskell For Great Good.
03:46:24 <merijn> Good :p
03:46:24 <micrypt> It's slightly less intimidating... and I like the pictures. :)
03:46:51 <merijn> It is much more understandable then a lot of others, yes. I recommend Real World Haskell when you are done with Learn You a Haskell
03:47:28 <micrypt> merijn: Will do. Learn You A Haskell's fairly short.
03:49:12 <itsnotvalid> micrypt, i am following that too
03:51:47 <merijn> micrypt: Also, do you understand map and filter? If so, it helps to see that a list comprehension [ foo x | x <- xs, bar x] is essentially the same as first doing "filter bar xs" and then doing "map foo" on the result (or in one go "map foo (filter bar xs)")
03:52:50 * hackagebot protocol-buffers 1.8.2 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-1.8.2 (ChrisKuklewicz)
03:53:52 * hackagebot protocol-buffers-descriptor 1.8.2 - Text.DescriptorProto.Options and Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-descriptor-1.8.2 (ChrisKuklewicz)
03:53:54 * hackagebot hprotoc 1.8.2 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-1.8.2 (ChrisKuklewicz)
03:57:15 <micrypt> merijn: Yeah, I'm fairly comfortable with Scala. 
03:58:22 <merijn> oh, that should help a lot in general :)
03:58:29 <micrypt> Following dibblego's advice & aiming to get less sloppy.
04:00:06 <micrypt> This should be interesting. Thanks for your guidance.  :)
04:17:26 <karto> hi... just getting my feet wet with Haskell here. Is there a way to have 'cabal install ...' run multithreaded?
04:17:26 <karto> I'm thinking an equivalent to 'make -j5'
04:17:26 <dcoutts> karto: sorry, not yet
04:17:31 --- topic: '["new! Haskell Platform 2011.2: http://is.gd/dCGPn", "Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
04:17:31 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Thu Mar 10 14:04:33 2011]
04:17:31 --- names: list (clog _ggreg THC4k anonus Guest50043 karto jaspervdj faluf dancor sepp2k erg0t tab mfo_ phyrex1an rup kerx_ Bfig fryguybob danten Chaze maxJadi FireFly cheater00 ramkrsna kamatsu micrypt boscop damex gio123 iago Shown gienah rtharper maurer_ homie Kortatu gemelen javecantrell emporas gal_bolle jwr mpiechotka Volt_ itsnotvalid stianhj jejansse Fuco rostayob LouisJB povik bens gellien ace2001ac mun_ jutaro waterlaz miloshadzic ankit9 pikhq yokto sShintah Y_Less)
04:17:31 --- names: list (colbseton sunfun fmardini silver lyn Astro merijn edon dkasak agundry morphling orbital_fox path[l] spirit mapreduce nonnooo simonmellor Cerise empity mceier lanthan der_eq jeltsch morricone Entroacceptor mortberg PatrickRobotham insomniaSalt Martijn_ janbanan pi8027 boegel augur danvet Ptival Samoi Amadiro roelvandijk kyagrd hackagebot ajhager ketil RayNbow`TU myu2 illissius Snark kaf3ii Deesl pacak hiptobecubic Icewing novas0x2a nchaimov mattrepl jrib)
04:17:31 --- names: list (Beetny Athas notostraca alek_br m3ga zul_netbsd skeptical_p Muad_Dibber aleator_ jsgf shintah scm lpsmith Jafet io_a_ Palmik andrus Dunearhp metasyntax alexsuraci ibt Adman65 ceii_ Philonous otto_s ExtraSpice lispy tr3x ps-auxw Seta00 flippo npouillard accel weirdo gwern ormaaj ArchGT Cobra joelb abbe hzh cubi fcr mikeg smarmy juhp siracusa moisan profmakx theorbtwo b52 kaol araujo Tanell mattyb djl Denebola __marius__ Philippa bhungy znutar Blarumyrran)
04:17:31 --- names: list (Neronus jix derrotebaron Belgarion_ wto anders^^ MacCoaster alios alpounet birkenfeld ivan pesco Huggleslorx jonafan arsenm cozmic fengshaun bogner poucet dropdrive winxordie tensorpudding jssanders steve_himself Janno FliPPeh_ zenzike sjanssen hiredman robinbb jmelesky ksf disgrntld kamaji stepcut StoneToad augustss alexbobp mun Nisstyre Kafka TacticalGrace brisbin MrFahrenheit hc saccade norm2782 _2x2l sohum cyanoacry dleslie Khisanth xinming dogmaT moshee)
04:17:31 --- names: list (ddarius schroedinbug Bleadof jonrh SimonRC idnar BMeph Draconx|Laptop amaron hammi neurogeek alip confound srcerer pingveno adnap Draconx cognominal antonh TML Sunhay snorble aiko fihi09`` demolithion __nickm__ caligula_ akosch sigue jho muep Ke ville Nereid helgikrs naypalm ccasin abojep jystic amiri tlonim djahandarie whoops ousado noj Cthulhon liesen inr ian_mi iFire jbauman_ sshc dcolish Counter-Strike dreixel majoh Tinned_Tuna Cale nanothief)
04:17:31 --- names: list (flamingspinach boris`` dual bss03 shutdown_-h_now snr setmeaway comak ryant5000 byorgey Gabbie kevinww_ lsthemes qz ezyang luite robinhoode systemfault rothwell meadowlark eno EvanCarroll dMazz perlite Gunni zax quotemstr thorkilnaur _soro burp holgr jedai ahihi2 parcs _mpu magicman bqf deggis hswe drbean suiside etpace jimi_hendrix earthy a11235 johs MrDomino^ raek pastorn qebab rokoteko sgronblo lantti ido Bassetts jd10 comex MasseR PHO_ jgrimes tavelram)
04:17:31 --- names: list (tmuki JuanDaugherty jyyou Odd_Bloke zong_sharo niko kolmodin ve smadge museun stepnem fabjan inimino dRbiG drhodes freiksenet elliottcable scree newsham blackdog thetallguy1 tessier Maxdamantus eZet kermit tmielika @ChanServ OnionKnight zomg shiduke Rooz bxc Fingerzam dionoea CindyLinz kalven mrshoe category tengen And[y] Vulpyne agemo jamwt gseitz zygoloid kosmikus Raynes tridactyla int-e lunaris mattam welterde carrbs sajkr reacocard jrockway freedrull)
04:17:31 --- names: list (Kalivha ernst sbok dorkitud1 pettter `0660 cncl_ mietek Lemmih nornagon oc palmje udoprog mrd Saizan ben jml gdsx snarkyboojum harlekin taruti quaestor obcode appamatto felipe_ dumael preflex Nanar yahooooo soeren xinitrc_ deavid Draggor quicksilver eyck vili_ emias dons cpa sophacles Nshag electrog1ek timchen1` joeytwiddle idoru ilab dcoutts gerard0 hpaste tew88 dino- septomin mq tomaw nlogax Igloo flux etabot shachaf Veinor rwbarton opqdonut micahjohnston)
04:17:31 --- names: list (Clex jcapper Vq Zao Yahovah funscala1 mm_freak_ robinsmidsrod ixzkn tswett Ferdirand borism ChongLi marienz arlinius tromp__ guerrill1 Arnar integral orbitz MK_FG Boney duairc Baughn dmwit ath SonicvanaJr andrewsw janne- slabanja_ plan kakeman wires ziman_ jackhill_ klugez KaneTW ihckt_ alexsdutton DrSyzygy ehamberg fram dqd Vorpal Hunner cjay mjrosenb nimred edenc tamiko noddy2000 Ornedan_ copton szbalint zaphar_p1 hellige_ larsrh hpc mux mornfall Aisling)
04:17:31 --- names: list (Heffalump McManiaC nominolo jmcarthur angstrom Botje_ Soft Taggnostr3 thetallguy mike1703 dilinger_ koninkje_away trez cynick david` Twey tafryn mafs CosmicRay sipa davean jdsc AnAdorableNick saurik companion_cube coffeemug alexsuraci` HaudRex hyko zakwilson bd_ BrianHV nothingmuch jrk_ gereedy Jaak stroan otulp olsner monochrom pantsd_ FauxFaux impl thoughtpolice chromakode gracenotes Gilly untwisted ray Raku^ DustyDingo shepheb wagle Obfuscate brett)
04:17:31 --- names: list (troofax ClaudiusMaximus hgolden periodic BONUS ReinH tomjnixon pr elventear aleator ricky mauke Aestas defect lambdabot solarus Martty ion killing-joke clanehin jayne dixie peterquest pantski Mitar Zol malorie cibs astory tlockney em jlouis xarch almostsix ahf koala_man ToRA ollip saiam Laney Boxo ibid scsibug RowanDuffy cwillu_at_work chitragupt kloeri Paradox924X Starfire jekor bezik flori solidsnack erk go|dfish Colours absentia mlh duckinator nniro)
04:17:31 --- names: list (xenocryst joni6128 poseidon wolverian _erik dom96 Zeiris_ jvogel aculich_ kelvie hvr_ Silex davidL faj_ elliottt Eliel_ ski__ shamster_ krainboltgreene ahihi2__ yrlnry Innominate ksandstr arkx milli samferry Dashkal stesh xplat aavogt Liskni_si aristid cafaro derekwright ezrak geekounet c1de0x fredcy nelhage allbery_b jlewis joaopizani mercury^)
04:17:38 <karto> is it in the works?
04:18:07 <dcoutts> karto: there are quite a few cabal tasks higher in the TODO list
04:18:16 <dcoutts> but I hope we'll do it eventually
04:18:27 <fryguybob> I'm getting: setup.exe: internal error: unexpected package db stack: [UserPackageDB] when doing cabal Install cairo after everything compiles with the new HP.  Any ideas?
04:19:34 <karto> ok. I won't presume to know what is more important of course... I just saw 3 cores idling and thought they might be put to better use. I'll get back to actually learning haskell now :)
04:21:36 <dcoutts> fryguybob: we'll need all the details so we can reproduce it. Can you file a ticket.
04:22:05 <fryguybob> dcoutts: Yeah.
04:22:07 <dcoutts> fryguybob: in particular, all the versions of things. ghc, cabal --version details etc
04:26:46 <Ptival> :pl \c x -> f $ g c x
04:27:07 <Ptival> @pl \c x -> f $ g c x
04:27:07 <lambdabot> (f .) . g
04:28:40 <Ptival> @pl \c -> f . g c
04:28:40 <lambdabot> (f .) . g
04:32:31 <scree> rostayob: sorry about the *very* late update.  Probably didn't explain quite right: you define "CunningSet a = { comparisonFn :: (a -> a -> Ordering, someTree :: SomeTree a}"
04:32:54 <bss03> @djinn (a -> (b -> c)) -> (b -> (a -> c))
04:32:55 <lambdabot> f a b c = a c b
04:33:13 <scree> rostayob: you then define set operations by doing find and replace on "Set.hs"; i.e. "s/Set/CunningSet" ond "s/compare/comparisonFn set"
04:33:41 <scree> rostayob: obviously, set unions &c. become unsafe, because you've got no guarantee the comparison functions are the same
04:33:56 <FUZxxl> @help djinn
04:33:56 <lambdabot> djinn <type>.
04:33:56 <lambdabot> Generates Haskell code from a type.
04:33:56 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
04:34:06 <scree> rostayob: but things like "insert" that operate on *one* set should be fine
04:34:31 <copumpkin> scree: you can always just iterate over all elements and reinsert them with the new comparison function
04:34:41 <copumpkin> they're just either unsafe or inefficient :P
04:35:06 <scree> copumpkin: sure, I meant the find and replace versions would be unsafe / poorly defined
04:35:11 <greap> When I cabal install quickcheck I'm told it is already installed, but I can't import it in ghci... This is very weird.
04:36:10 <Jafet> @pl \a b c -> f $ g a b c
04:36:11 <Jafet> ((f .) .) . g
04:36:11 <lambdabot> ((f .) .) . g
04:36:11 <Jafet> @botsnack
04:36:11 <lambdabot> :)
04:36:56 <scree> rostayob: then you define "newtype Set a = SetWrapper (CunningSet a)", and define "empty = SetWrapper { comparisonFn = compare, someTree = emptyTree }" & so on, to define something that behaves the same as a normal Set
04:37:15 <scree> rostayob: your library is hopefully now a drop-in extension of Set.hs
04:38:00 <bss03> @type flip
04:38:01 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:38:29 <hpc> flip :: (a -> b -> c) -> (b -> a -> c)
04:38:45 <scree> @src flip
04:38:46 <lambdabot> flip f x y = f y x
04:39:01 <hpc> caleflip is something like
04:39:05 <hpc> :t fmap ($)
04:39:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f (a -> b)
04:39:17 <hpc> :t ($> ($))
04:39:18 <lambdabot> Not in scope: `$>'
04:39:24 <hpc> :t (<$ ($))
04:39:25 <lambdabot> forall a a1 b. a -> (a1 -> b) -> a
04:39:29 <scree> @pl (\f x y -> f y x)
04:39:30 <lambdabot> flip
04:39:34 <confound> heh
04:40:07 <merijn> lambdabot is filled with newbies confusing dirty lies!
04:40:14 <merijn> s/newbies/newbie
04:40:31 <ion> @src (<$)
04:40:32 <lambdabot> (<$) = (<$>) . const
04:42:20 <fryguybob> dcoutts: Ticket added http://hackage.haskell.org/trac/hackage/ticket/812
04:43:17 <scree> @type (\f x -> f <*> pure x)
04:43:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
04:43:44 <scree> hmm
04:44:30 <bss03> (a -> b -> ... -> y -> z) -> (b -> .. -> y -> a -> z).  I wonder how to write that type without elipses.
04:44:53 <hpc> bss03: the long way, unfortunately
04:45:14 <scree> @type (\f x -> fmap ($ x) f)
04:45:14 <hpc> when you have types that huge, it is generally a sign that you should make a data structure
04:45:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
04:45:26 <scree> better
04:46:22 <sipa> @djinn (a -> b -> c) -> (b -> a -> c)
04:46:23 <lambdabot> f a b c = a c b
04:47:16 <bss03> hpc: Well, I was wondering because some asked earlier about a generalization of flip.
04:47:32 <hpc> ah
04:47:33 <bss03> hpc: Where, it takes the first argument and makes it the last argument.
04:47:41 <xplat> > let { rots xs = zip (tails xs) (inits xs); (>>%) = liftM (>>); lastToMaybe = (guard . not . null) >>% (return . last); bwt xs = map lastToMaybe $ sort (rots xs) in bwt "That  Sam-I-am, that Sam-I-am!  I do not like that Sam-I-am!"
04:47:41 <lambdabot>   <no location info>: parse error on input `in'
04:47:45 <hpc> there's a few generalizations, iirc
04:47:46 <bss03> hpc: I'm still not exactly what the type of that function would be.
04:47:54 <mjrosenb> bss03: that sounds impossible
04:48:06 <hpc> it might be possible with typeclasses
04:48:19 <mjrosenb> bss03: however, you could do something *vaguely* like that with TH
04:48:23 <hpc> you would need one anyway, to make it deal with variadic functions nicely
04:48:24 <bss03> mjrosenb: Maybe it is.  If so, it shouldn't be well-typed.  Which is why I'm thinking about it's type.
04:48:27 <hpc> er, to make it variadic
04:49:03 <dcoutts_> fryguybob: thanks
04:49:48 <rostayob> let's say I want a split a bytestring at a certain character
04:49:57 <bss03> So, something like Printf.  Where a and T c => a -> c are members of a type class T and you chain them to get your result?
04:49:58 <rostayob> how can I do that? I mean is it possible? is one char always one Word8 in a BS?
04:50:24 <bss03> rostayob: By the pidgeonhole pinciple that impossible.
04:50:26 <merijn> rostayob: Bytestrings don't have char's
04:50:34 <merijn> They have bytes
04:50:40 <bss03> rostayob: There are more Chars than Word8s.
04:50:51 <rostayob> yeah exactly, but still
04:50:56 <rostayob> Data.ByteString.Char8
04:51:08 <merijn> rostayob: Unfortunate historical name, blame C
04:51:19 <rostayob> has break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
04:51:33 * hackagebot interpolatedstring-perl6 0.8.1 - QuasiQuoter for Perl6-style multi-line interpolated strings  http://hackage.haskell.org/package/interpolatedstring-perl6-0.8.1 (AudreyTang)
04:51:54 <rostayob> will this work for any bytestring? like regardless on how I encoded them? (in my case, with Data.ByteString.UTF8)
04:52:18 <merijn> No idea
04:52:41 <rostayob> regardless on how I encoded the string, sorry
04:53:14 <rostayob> well, data.bytestring.utf8 has splitat...
04:53:29 <rostayob> no sorry, break
04:53:34 <rostayob> i mean it has break as well
04:54:08 <rostayob> mhm
04:56:52 <Fuco> is it possible to create custom types like list? It has a "constructor" [a], can I create something like {a} or <a> or something similar?
04:57:08 <Fuco> I just mean the syntax, not the functionality of list
04:57:34 <Jafet> No, the list syntax is magickal
04:57:37 <merijn> Fuco: You mean the surrounding brackets like syntax? I don't think so, at least I've never encountered it
04:57:55 <Jafet> You can use operator-like constructors, which are prefixed with :
04:58:04 <merijn> Personally I prefer the prefix for parametric types anyway
04:58:11 <Jafet> Eg. oleg's (?) :::
04:58:23 <Fuco> thanks, I was just curious
04:58:37 <Fuco> since there isn't that much magic in haskell as far as I can tell
04:58:43 <Fuco> so [a] is indeed a special case
04:59:05 <Fuco> makes sense tho, considering how much lists are used
04:59:19 <Jafet> @src []
04:59:19 <lambdabot> data [] a = [] | a : [a]
04:59:36 <Jafet> Fantasy haskell
04:59:49 <ion> @src lambdabot
04:59:49 <lambdabot> Source not found.
04:59:53 <fabjan> @src {}
04:59:54 <lambdabot> Source not found. :(
05:00:17 <hpc> :t let fix = fix in fix fix
05:00:18 <lambdabot> forall t. t
05:01:46 <FUZxxl> :pointful
05:01:49 <FUZxxl> @pointful
05:01:49 <lambdabot> ()
05:02:09 <karto> I'm getting ghc panics (running arch linux, ghc 7.0.2) with 'cabal install' - "ghc: This ELF file contains no symtab". Both with yesod and snap. Any ideas what that's about?
05:02:11 <FUZxxl> @pointful  let fix = fix in fix fix
05:02:11 <lambdabot> let { fix = fix} in fix fix
05:02:41 <hpc> @pl let fix = fix in fix fix
05:02:41 <lambdabot> fix id (fix id)
05:02:43 <xplat> > let { rots xs = zip (tails xs) (inits xs); (>>%) = liftM2 (>>); lastToMaybe = (guard . not . null) >>% (return . last); bwt :: Ord a => [a] -> [Maybe a]; bwt xs = map (lastToMaybe . snd) $ sort (rots xs) } in map (maybe '$' id) $ bwt "That Sam-I-am, that Sam-I-am!  I do not like that Sam-I-am!"
05:02:44 <lambdabot>   "!! tttItoe,mmmmmmIII ---   $---SSShhh kttTli aaaaaa dnaaao  "
05:02:47 <hpc> :t fix id (fix id)
05:02:47 <lambdabot> forall t. t
05:02:54 <hpc> :t fix id
05:02:55 <lambdabot> forall a. a
05:04:30 <hpaste> polux pasted "nary tree"  http://hpaste.org/44692
05:06:52 <mjrosenb> xplat: is that BWT?
05:08:01 <Jafet> :t liftM2 (>>)
05:08:02 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
05:08:11 * Jafet osmosises
05:28:08 <hpaste> foo pasted "SM"  http://hpaste.org/44693
05:29:13 <hpaste> foo pasted "Transition"  http://hpaste.org/44694
05:34:59 <tib> hi, any traffic here?
05:35:16 <Entroacceptor> no, never
05:35:22 <sipa> no, it's jammed
05:35:24 <zygoloid> this is the most we've had in years right now
05:35:33 <luite> everyone has fled for the tsunami
05:35:56 <confound> I'm on a boat!
05:35:59 <tib> :)
05:36:06 <zygoloid> i think we may be losing our status as most helpful channel on IRC
05:36:22 <hpc> zygoloid: to who?
05:36:43 <btutt> shrodinger's cat
05:37:04 <zygoloid> hpc: to the null channel :)
05:37:23 <hpc> #null?
05:37:32 <hpc> :D
05:37:40 <tib> I know tryhaskell.org (from where I came here), and tryruby.org (both was quite useful for me)
05:37:49 <tib> anyone knows other try[language].org pages?
05:38:02 <fryguybob> dcoutts_: With a little fiddling with Gtk2HsSetup.hs I was able to get it to register.  Adding the info to the ticket.
05:38:08 <luite> tib: you've already tried the best, so why not stick to it ;)
05:38:09 <Entroacceptor> confound: look at me, now back to your boat, now back to me!
05:38:27 <tib> luite: you mean haskell? :)
05:38:28 <hpc> the boat is made of diamonds!
05:38:36 <hpc> OH NO IT IS SINKING!
05:39:54 <Jafet> > let twb xs = let xs' = map (\x->if x=='$' then '\0' else x) xs in tail . head . filter ((=='\0').head) $ foldr (const $ sort . zipWith (:) xs') (repeat []) xs' in twb "!! tttItoe,mmmmmmIII ---   $---SSShhh kttTli aaaaaa dnaaao  "
05:39:55 <lambdabot>   "That Sam-I-am, that Sam-I-am!  I do not like that Sam-I-am!"
05:40:35 <luite> tib: there's a brand new release of the haskell platform, install it if you want to try some more
05:43:09 <tib> luite: thx, I've read about it on hackernews.. will definitely give it a try
05:43:19 <cubi> http://www.vidarholen.net/~vidar/rage/129985352816075.html
05:43:21 <cubi> :>>
05:43:27 <cubi> perfect!
05:44:12 <aristid> Jafet: is that BWT or something similar?
05:44:17 <luite> tib: and people here are generally very helpful, so don't hesitate to ask questions, even simple ones
05:44:47 <luite> tib: oh, and read this: http://learnyouahaskell.com/
05:44:57 <scree> > let f l = let { perm = fmap snd $ sortBy (comparing fst) (zip l [0..]); ls = fmap (l !!) (iterate (perm!!) 0); inv = zipWith const ls l; (a,b) = span (/='$') inv } in (tail b ++ a) in f "!! tttItoe,mmmmmmIII ---   $---SSShhh kttTli aaaaaa dnaaao  "
05:44:59 <lambdabot>   "*Exception: Prelude.tail: empty list
05:45:38 <Jafet> Inverse of xplat's bwt
05:45:49 <scree> meant to be
05:46:23 <scree> > let f l = let { perm = fmap snd $ sortBy (comparing fst) (zip l [0..]); ls = fmap (l !!) (iterate (perm!!) 0); inv = zipWith const ls l} in inv in f "!! tttItoe,mmmmmmIII ---   $---SSShhh kttTli aaaaaa dnaaao  "
05:46:24 <lambdabot>   "!  Sam-I-am! I like that Sam-I-am,!  Sam-I-am! I like that S"
05:46:34 <hpc> haha
05:46:41 <scree> worked with *my* bwt
05:46:49 <scree> damn
05:47:54 <tib> luite: "Learn you a Haskell" is a great learning page, once I bite myself through to Higher Order Functions
05:47:55 <FliPPeh_> Can someone recommend me some simple, yet nicely written, haskell projects which code I can use to improve my haskell-fu?
05:48:20 <hpc> FliPPeh_: as in, something already written for you to hack around with?
05:48:39 <FliPPeh_> hpc: Something already written, so I can study the source code
05:48:55 <tib> luite: but since I'm not working daily with Haskell (damn hard to find jobs where you can use functional languages), it gets easily forgotten
05:48:56 <hpc> http://dl.dropbox.com/u/37707/Data/Data.tar.gz <-- is an irc bot i run
05:49:00 <FliPPeh_> I know all those haskell basics by now
05:49:10 <FliPPeh_> But I don't get the functional way of programming I fear :/
05:49:14 <hpc> it's rather ugly, since i wrote it when i was learning
05:49:16 <FliPPeh_> Nicely splitting IO
05:49:19 <hpc> there's some good stuff in there though
05:49:25 <Entroacceptor> cubi: looks exactly like me!
05:49:30 <cubi> Entroacceptor: ;)
05:49:45 <FliPPeh_> hpc: Thanks, I'll have a look at it :)
05:50:42 <luite> tib: yeah you really have to play with to actually learn it. and you might even learn a few things that are useful in other languages
05:53:09 <MasseR> I'm trying to generate a binary histogram with "V.accum (+) (V.replicate 256 0) (zip (map fromIntegral $ BL.unpack c) (repeat 1))", where BL is lazy bytestrings. The program however runs out of memory quite soon. 
05:53:15 <scree> > let f l = let { cmp a b = if a == '$' then LT else if b == '$' then GT else compare a b; perm = fmap snd $ sortBy (cmp `on` fst) (zip l [0..]); ls = fmap (l !!) (iterate (perm!!) 0); inv = zipWith const ls l; (a,b) = span (/='$') inv } in (tail b ++ a) in f "!! tttItoe,mmmmmmIII ---   $---SSShhh kttTli aaaaaa dnaaao  "
05:53:17 <lambdabot>   "That Sam-I-am, that Sam-I-am!  I do not like that Sam-I-am!"
05:53:40 <MasseR> Where should I add strictness, to make it work right?
05:53:50 <MasseR> Or do I have a wrong approach?
05:53:54 <scree> :)
05:54:48 <Jafet> scree: for golf it is probably better to map Just l and then Nothing sorts first
05:55:26 <scree> Jafet: ah, good point
05:56:28 <koala_man> cubi :DD
05:57:11 <koala_man> cubi: that generator is written in haskell btw ^^
05:57:15 <cubi> nice :)
05:58:33 <rpglover64> I have a question about whether or not the writer monad is appropriate for a particular use case.
05:59:25 <hpc> *psychically deduces rpglover64's question and answers "yes"*
05:59:27 <hpc> :P
05:59:28 <scree> > let f l = let { str = fmap (\x -> guard (x /= '$') >> Just x) l;  perm = fmap snd $ sortBy (comparing fst) (zip str [0..]); ls = fmap (str !!) (iterate (perm!!) 0); inv = zipWith const ls l; (a,b) = span isJust inv } in catMaybes (b ++ a) in f "!! tttItoe,mmmmmmIII ---   $---SSShhh kttTli aaaaaa dnaaao  "
05:59:30 <lambdabot>   "That Sam-I-am, that Sam-I-am!  I do not like that Sam-I-am!"
05:59:50 <rpglover64> hpc: Nice.  Thank you for helping :)
05:59:51 <djahandarie> scree, what is this suppose to be? :P
06:00:03 <rpglover64> i'm writing minimax
06:00:21 <rpglover64> and I'm currently building the tree functionally and then pruning it
06:00:37 <rpglover64> but I need to keep track of how many nodes were actually evaluated
06:00:38 <scree> djahandarie: it's an inverse bwt
06:00:58 <scree> djahandarie: if I'd been paying attention, I'd have noticed before a few seconds ago tha Jafet already made one up top
06:01:10 <djahandarie> Ah
06:01:44 <hpc> rpglover64: that would be a good place for a writer, where you append to the Sum monoid
06:01:58 <hpc> (Sum a) `mappend` (Sum b) = Sum (a + b)
06:02:02 <rpglover64> right
06:02:25 <Jafet> unsafePerformIO (modifyIORef succ ctr) `seq` ...
06:02:59 <rpglover64> now I just need to figure out the types...
06:03:04 <hpc> rpglover64: dunno much about minimax; do you need to be able to read how many nodes you have evaluated?
06:03:07 <Jafet> And then build the tree as usual while wearing your trollface
06:03:27 <rpglover64> hpc: no, but I'm doing this for class, and that's a requirement of the assignment
06:03:42 <rpglover64> it's a performance metric
06:03:46 <hpc> ah, cool
06:03:48 <hpc> no problem then
06:04:28 <hpc> man, all the people who come in here asking questions related to homework make me really jealous
06:04:33 * hpc has to use java in his classes
06:04:50 <rpglover64> Jafet: I just realized you were talking to me.  shame on you for mentioning unsafePerformIO ;)
06:04:52 <merijn> The advanced classes here are basically all C
06:05:12 <Jafet> @quote unsafePerformIO
06:05:12 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
06:05:23 <hpc> @quote unsafe
06:05:23 <lambdabot> Peaker says: * FunctorSalad doesn't think things like sexuality are impure <Peaker> only if wrapped in unsafePerform...
06:06:16 <rpglover64> hpc: it's a higher level class (AI) that's supposed to be language independent; we're provided template code in java, but I've managed to convince the professor to let me use haskell;  he's a little reluctant because the TAs don't know it
06:06:45 <hpc> rpglover64: that's part of the fun! torturing your TAs with unfamiliar stuff
06:06:49 <merijn> Mentally scarring TA's, like a boss :D
06:06:56 <poucet> @quote semantic
06:06:56 <lambdabot> scook0 says: real men don't need semantics, they pipe meaning directly into their compilers!
06:06:59 <poucet> @quote love
06:06:59 <lambdabot> lambdabot says: I know nothing about love.
06:07:40 <mauke> preflex: quote . love
06:07:42 <preflex>  <poppavic> yer back to the lovely "Mine is bigger than yours" issue, and the idiots still ain't learned a damn thing about shit under shit "underwear"
06:08:03 <Jafet> @vixen are you pure?
06:08:03 <lambdabot> yes, i am
06:08:51 <djahandarie> @what is love
06:08:51 <lambdabot> I know nothing about is.
06:08:57 <djahandarie> Heh
06:11:01 <aristid> @vixen what is love?
06:11:01 <lambdabot> i dunno...
06:11:27 <c_wraith> @vixen baby don't hurt me no more
06:11:27 <lambdabot> i didn't think so
06:12:31 <hpaste> fmapE pasted "\"error when trying to build haddock 2.9.2\""  http://hpaste.org/44695
06:13:19 <jystic> @pl f x = g . h x
06:13:19 <lambdabot> f = (g .) . h
06:13:25 <fmapE> I'm getting the just-pasted error when trying to build haddock 2.9.2
06:13:48 <c_wraith> fmapE: what's the magic number for the version of ghc-paths you have installed?
06:14:01 <fmapE> the exact one that it complains it can't find
06:14:04 <c_wraith> um, nevermind what exactly it is, just... is it different?
06:14:12 <c_wraith> ok, then, I'm confused
06:14:26 <fmapE> yea me too
06:14:31 <fmapE> that's why I'm here -.-
06:15:13 <fmapE> uhhh
06:15:15 <fmapE> wait a sec
06:15:23 <fmapE> ghc-pkg didn't say THAT before...
06:15:49 <fmapE> ahhh
06:15:51 <fmapE> ok
06:16:00 <fmapE> answering my own question I think
06:16:40 <fmapE> ghc-pkg just decided to let me know that I should do a "ghc-pkg recache
06:16:46 <fmapE> and that changed the magic #
06:16:50 <fmapE> I bet that's what was happening
06:17:16 <fmapE> yup there it goes
06:23:14 <fmapE> hah
06:23:28 <fmapE> ghc's linker really eats resources...
06:23:40 <djahandarie> Yes, yes it does
06:23:46 <c_wraith> well.  it's just regular system ld
06:23:55 <c_wraith> but yeah, it handles haskell code badly
06:23:59 <c_wraith> due to split-objs
06:24:51 <fmapE> I'm not familiar really with how ld works
06:24:59 <fmapE> I know the basic idea of a linker and that's about it
06:25:12 <fmapE> so what is it about haskell object code that makes it so difficult?
06:25:46 <c_wraith> to keep executable size down, ghc produces lots of very small object files
06:26:20 <c_wraith> the end result of this is that ld is passed as many as thousands of object files to link, in the final pass
06:26:28 <c_wraith> and it's just not designed to handle that
06:26:42 <fmapE> ah
06:26:45 <fmapE> are there linkers that can?
06:27:16 <c_wraith> the dynamic linker has no trouble with it...
06:27:20 <c_wraith> ld is just old and decrepit
06:27:21 <hpc> perhaps a haskeller should see if it would be possible to patch ld
06:27:31 <ion> How about gold?
06:27:32 <rothwell> wonder if it'd help to combine those into a .a before linking...
06:27:48 <c_wraith> rothwell: they are combined into one .a file per module.
06:27:55 <rothwell> oh, well... there you go!
06:28:00 * rothwell shuts up
06:28:21 <hpc> compiling multiple modules into a .a sometimes helps
06:28:35 <hpc> it reduces my website compilation time by a few seconds at least
06:29:01 <hpc> i put 8 or so modules into one big file
06:29:21 <fmapE> c_wraith can ghc do dynamic linking (if so, on OS X?)
06:30:11 <c_wraith> as of 6.12 it can on linux and OS X...  I believe.  I've never used it.
06:34:13 * fmapE goes to try building a dynamic program...
06:36:15 <fmapE> hmmm guess not...
06:36:54 <rpglover64> Does this line indicate that I'm doing something rather silly:
06:36:55 <rpglover64> fmap (\x -> tell (Sum 1) >> return x)
06:37:31 <Jafet> fmap over the game tree?
06:37:36 <rpglover64> yeah
06:37:38 <Jafet> Nothing obviously wrong with that
06:37:42 <rpglover64> okay
06:38:05 <rpglover64> I can't then figure out how to get my pure minimax function to work with the monad
06:38:17 <rpglover64> minimax :: Tree NodeContents -> NodeContents
06:39:07 <rpglover64> there doesn't seem to be a "sequence" for things that aren't lists
06:39:26 <Cale> rpglover64: You might like the sequence in Data.Traversable
06:39:34 <rpglover64> Ah; thanks
06:39:38 <rpglover64> hadn't looked there yet
06:39:49 <Cale> rpglover64: But of course, you could always write your own
06:39:51 <Jafet> So you want to make it Tree (Writer NodeContents) -> Writer NodeContents?
06:40:04 <rpglover64> Cale: of course
06:40:06 <Jafet> Er wait
06:40:18 <roconnor> @hoogle sequence
06:40:18 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:40:19 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:40:19 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
06:40:25 <Cale> For lists,  sequence [] = return []; sequence (x:xs) = do v <- x; vs <- xs; return (x:xs)
06:40:29 <Cale> er
06:40:34 <Cale> vs <- sequence xs
06:41:04 <Peaker> @src sequence
06:41:05 <lambdabot> sequence []     = return []
06:41:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:41:05 <lambdabot> --OR
06:41:31 <Cale> oh, I typoed that even moar
06:41:32 <hpc> or?
06:41:33 <Cale> heh
06:41:38 <Cale> return (v:vs)
06:41:43 <Cale> (I haven't slept)
06:42:00 <Cale> whoa, where's the last line? :)
06:42:10 <Cale> There's another line where it provides an alternate definition
06:42:17 <Cale> let's try once moe
06:42:18 <Cale> more*
06:42:22 <Cale> @src sequence
06:42:23 <lambdabot> sequence []     = return []
06:42:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:42:23 <lambdabot> --OR
06:42:25 <Cale> huh
06:42:38 <hpc> :t sequence
06:42:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:42:39 <Cale> time to go look in the magic file
06:42:49 <hpc> :t flip `asTypeOf` sequence
06:42:49 <lambdabot> forall a b. [a -> b] -> a -> [b]
06:43:03 <Cale> wat, it's there in the file
06:43:09 <Cale> maybe it's limiting the number of lines
06:43:41 <Cale> sequence xs = foldr (liftM2 (:)) (return []) xs
06:43:48 <Cale> Is the alternate definition
06:45:00 <djahandarie> Cale, any objections to importing Control.Newtype from the newtype package into lambdabot? I always find myself copying stuff from ghci into IRC which isn't as cool
06:45:25 <Cale> What is that package again?
06:46:12 <djahandarie> It basically creates a Newtype typeclass and associates packs with unpacks
06:46:25 <djahandarie> Which lets you work with newtypes with very little syntax
06:46:50 <Cale> okay
06:46:51 <djahandarie> An example:  h 
06:46:53 <djahandarie> Oops
06:46:56 <Cale> seems sensible
06:46:59 <hpc> :P
06:47:02 <djahandarie> ala Sum foldMap [1,2,3,4] -- foldMaps the list ala the Sum newtype. This results in 10.
06:47:26 <hpc> :t foldMap
06:47:27 <lambdabot> Not in scope: `foldMap'
06:47:33 <hpc> @hoogle foldMap
06:47:33 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
06:47:33 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
06:47:45 <hpc> groovy
06:48:08 <djahandarie> foldMap just being a very generalized concatMap
06:48:19 <aavogt> Cale: did you get a patch for \bot from me?
06:49:29 <hpc> :t concatMap
06:49:30 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:49:42 <zygoloid> djahandarie: is 'ala' a function there?
06:49:47 <djahandarie> Yeah
06:50:02 <hpc> so kind of an alternative definition of (>>=) then?
06:50:14 <djahandarie> No Monads involved
06:50:28 <hpc> @hoogle ala
06:50:28 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
06:50:28 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
06:50:28 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
06:50:55 <zygoloid> ala :: Newtype n a => (a -> n) -> OperationOn n -> OperationOn a ?
06:51:24 <zygoloid> (i'm assuming this is actually just "ala _ = unsafeCoerce" with some cunning type-level checks)
06:51:34 <djahandarie> No unsafeCoerce.
06:51:43 <djahandarie> http://hackage.haskell.org/packages/archive/newtype/0.1/doc/html/src/Control-Newtype.html#ala
06:52:30 <zygoloid> that's a disappointingly non-general type :/
06:52:54 <djahandarie> Disappointingly non-general?
06:53:30 <djahandarie> It allows you to work with almost anything you want provided that function accepts a pack
06:54:17 <zygoloid> it requires an ((a -> b) -> (c -> d)), where (a->b) is a newtype wrapping and d is a newtype.
06:54:21 <djahandarie> I think it's nicer than imposing a Functor constraint or something, because now that constraint can just be imposed via the extra argument
06:54:48 <yokto> hello, Can some one tell me why in ghc the types are different, when i define:  let f x = x+1 and let g = \x -> x+1
06:55:22 <zygoloid> i was hoping for something that would recursively construct the appropriate return type, performing all necessary wraps/unwraps
06:55:29 <aavogt> there's a monomorphism restriction that applies in the second case yokto
06:55:56 <aavogt> if you add a type signature, you can get around it
06:56:16 <djahandarie> zygoloid, wouldn't that require a catamorphism / Mu-recursive type?
06:57:18 <zygoloid> djahandarie: for which type? the newtype?
06:59:45 <hpc> yokto: in more detail, the monomorphism restriction says "if this thing looks like a value, it cannot be polymorphic"
06:59:52 <hpc> "f x = ..." looks like a function
06:59:58 <hpc> "f = ..." looks like a value
07:00:03 <hpc> even if the other side is a lambda
07:00:20 <Cale> @undefine
07:00:26 <djahandarie> zygoloid, I'm actually not quite sure why you would need to recursively apply the packs/unpacks. For gaining the Newtype behavior within a structure rather than changing the structures entire behavior?
07:00:35 <yokto> ok
07:00:46 <Cale> > pack False :: All
07:00:50 <lambdabot>   Could not find module `Data.Newtype':
07:00:50 <lambdabot>    Use -v to see a list of the files ...
07:00:55 <Cale> oh, heh
07:01:01 <hpc> hehe
07:01:24 <Cale> > pack False :: All
07:01:24 <hpc> the package isn't installed?
07:01:24 <Panaetius> is there a torrent available for the Haskell Platform 2011.2.0.0 for Windows?
07:01:25 <lambdabot>   Could not find module `Data.Newtype':
07:01:25 <lambdabot>    Use -v to see a list of the files ...
07:01:34 <Fuco> are the examples from RWH available somewhere on the web?
07:01:39 <Cale> I forget where I need to add the package...
07:01:56 <djahandarie> Cale, just in the mueval package list right?
07:02:31 <hpc> Fuco: you mean besides in the rwh text?
07:02:32 <aristid> oh, 43% off LYAH: http://www.amazon.com/gp/product/1593272839
07:03:01 <hpc> amazon is slow it seems
07:03:01 <Fuco> I mena like a zip with the source code from the examples
07:04:35 <Cale> oh! Control.Newtype
07:04:41 <Cale> not Data.Newtype
07:04:45 <Cale> that's unexpected
07:04:52 <djahandarie> Ah
07:05:01 <hpc> aristid: read the editorial review at the bottom :D
07:05:02 <djahandarie> I had it as Data.Newtype first, but then Control felt better
07:05:05 <Cale> > pack False :: All
07:05:06 <lambdabot>   Could not find module `Data.Newtype':
07:05:06 <lambdabot>    Use -v to see a list of the files ...
07:05:12 <Cale> oh right
07:05:14 <Cale> @undefine
07:05:16 <Cale> > pack False :: All
07:05:18 <lambdabot>   All {getAll = False}
07:05:21 <Cale> there we go
07:05:23 <djahandarie> :)
07:05:33 <hpc> awesome sauce!
07:05:45 <djahandarie> > ala Endo foldMap [(+1), (+2), (subtract 1), (*2)] 3
07:05:46 <lambdabot>   Not in scope: `foldMap'
07:05:50 <ion> :t pack
07:05:52 <djahandarie> > ala Endo Data.Foldable.foldMap [(+1), (+2), (subtract 1), (*2)] 3
07:05:52 <lambdabot> forall o n. (Newtype n o) => o -> n
07:05:53 <lambdabot>   8
07:06:13 <hpc> :t unpack
07:06:13 <aristid> hpc: heh "You'll start with the kid stuff: basic syntax, recursion, types and type classes."
07:06:17 <lambdabot> forall n o. (Newtype n o) => n -> o
07:06:25 <djahandarie> :t op -- also useful
07:06:26 <lambdabot> forall o n. (Newtype n o) => (o -> n) -> n -> o
07:06:45 <hpc> djahandarie: wha?
07:06:59 <aristid> hpc: Newtype got into lambdabot:)
07:07:05 <aristid> @hackage newtype
07:07:05 <lambdabot> http://hackage.haskell.org/package/newtype
07:07:12 <hpc> i know, i mean what does op do?
07:07:13 <illissius> :t ala
07:07:14 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
07:07:18 <illissius> :d
07:07:22 <djahandarie> > op Product $ Product 3
07:07:23 <lambdabot>   3
07:07:30 <hpc> > op Sum (Sum 5)
07:07:31 <lambdabot>   5
07:07:37 <hpc> > op Product (Sum 5)
07:07:38 <lambdabot>   Couldn't match expected type `Data.Monoid.Product o'
07:07:38 <lambdabot>         against inferr...
07:08:18 <hpc> op x = unpack . x . pack?
07:08:30 <djahandarie> op _ = unpack
07:08:43 <hpc> that's silly
07:08:54 <djahandarie> It just allows you to apply the type constraint to unpack without an actual value.
07:09:00 <djahandarie> :t op Product
07:09:01 <lambdabot> forall o. Product o -> o
07:09:12 <hpc> ah
07:09:18 <hpc> still kind of silly
07:09:22 <hpc> :t op pack
07:09:23 <lambdabot> forall o n. (Newtype n o) => n -> o
07:10:03 <djahandarie> :t unpack :: Product o -> o -- is more verbose
07:10:04 <lambdabot> forall o. Product o -> o
07:10:27 <hpc> why not just leave it polymorphic?
07:10:35 <hpc> oh, nvm
07:10:51 <hpc> 'n' gets hidden in common use cases
07:11:48 <hpc> :t \x m m' -> op x (m `mappend` m')
07:11:49 <lambdabot> forall o a. (Monoid a, Newtype a o) => (o -> a) -> a -> a -> o
07:12:04 <hpc> :t \x m m' -> op x (x m `mappend` x m')
07:12:05 <lambdabot> forall o n. (Monoid n, Newtype n o) => (o -> n) -> o -> o -> o
07:12:45 <hpc> @hoogle (Monoid n, Newtype n o) => (o -> n) -> o -> o -> o
07:12:46 <lambdabot> Warning: Unknown class Newtype
07:12:46 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:12:46 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
07:12:50 <hpc> humbug
07:14:04 <djahandarie> :t \x -> ala x foldMap
07:14:05 <lambdabot> Not in scope: `foldMap'
07:14:10 <djahandarie> :t \x -> ala x Data.Foldable.foldMap
07:14:11 <lambdabot> forall n (t :: * -> *) o'. (Newtype n o', Monoid n, Data.Foldable.Foldable t) => (o' -> n) -> t o' -> o'
07:14:32 <djahandarie> More general form of that.
07:14:54 <djahandarie> It would be nice if there were an mconcatMap to make signatures slightly less scary
07:14:59 <djahandarie> The Foldable is hardly needed here
07:19:33 <BONUS> hey djahandarie, yesterday you talked about making a reddit link to the amazon page for lyah, right?
07:19:40 <djahandarie> BONUS, yep
07:19:55 <BONUS> i was thinking, if i made it it might look too much like shameless self promotion :)
07:20:01 <djahandarie> Haha okay, I'll do it then
07:20:07 <BONUS> haha awesome, thanks!
07:20:29 <Jafet> Is there even such a thing as shameful self-promotion
07:20:42 <djahandarie> BONUS, is http://www.amazon.com/gp/product/1593272839/ref=s9_simh_gw_p14_d0_i1?pf_rd_m=ATVPDKIKX0DER&pf_rd_s=center-2&pf_rd_r=1N612FW1B5WMFCF8F992&pf_rd_t=101&pf_rd_p=470938631&pf_rd_i=507846 the right link?
07:20:44 <ion> Shameful self-promotion by proxy
07:21:05 <BONUS> yeah that's it!
07:21:11 <BONUS> ion: sneaky, huh? :)
07:21:37 <Jafet> http://www.amazon.com/dp/1593272839
07:21:53 <Jafet> I never understand their URL schema
07:21:59 <djahandarie> That is a nicer URL
07:21:59 <BONUS> ooh, amazon has short URLs now?
07:22:12 <Jafet> Using the ISBN like that has always worked
07:22:12 <aristid> BONUS: no, you can remove large parts of the url
07:22:28 <FauxFaux> http://www.amazon.com/dp/Jafet-wins-the-Amazon/1593272839
07:22:34 <BONUS> ah. i always wished they had like
07:22:40 <BONUS> amazon.com/author/title
07:22:44 <Jafet> Mmm, Amazons
07:22:50 <FauxFaux> http://www.amazon.com/dp/BONUS-loses-the-Amazon/1593272839
07:22:56 <BONUS> haha
07:23:38 <Athas> Should I use mtl or monads-fd?
07:23:38 <lambdabot> Athas: You have 1 new message. '/msg lambdabot @messages' to read it.
07:24:07 <ion> Meh. No discount at amazon.co.uk, which IIRC ships to Finland for free.
07:24:08 <Athas> (And didn't I go through this with mtl/transformers semi-recently?)
07:24:52 <aavogt> mtl-2 apparently
07:24:53 <djahandarie> http://www.reddit.com/r/haskell/comments/g1zwu/learn_you_a_haskell_is_on_preorder_on_amazon_42/  :)
07:25:21 <djahandarie> Let's get some upvotage on that
07:25:26 <BONUS> nice, thanks!
07:26:29 <aristid> BONUS: do you get any kinds of analytics data? like "how many copies pre-ordered today"?
07:26:53 <BONUS> aristid: i guess my publisher gets it, but i will ask them
07:27:14 <BONUS> it's encouraging that it says: 47% buy the item featured on this page:
07:27:20 <BONUS> re: lyah
07:27:40 <aristid> "47% WHO BUY ANYTHING buy the item featured on this page"
07:27:41 <aristid> i guess
07:27:51 <BONUS> i was thinking like 47% who visit the page?
07:28:01 <aristid> i don't believe that.
07:28:02 <BONUS> it is a bit unclear as to 47% of WHAT that means
07:28:07 <BONUS> but yeah that might be a bit too much
07:28:08 <quicksilver> I'm sure it's what aristid said.
07:28:22 <quicksilver> it's still pretty good though
07:28:49 <confound> 47% of 100%
07:28:50 <confound> duh!
07:29:14 <aristid> confound: always the right answer :)
07:29:21 <BONUS> 47% who buy anything? like ever?
07:29:40 <jjohnsson> BONUS: where can I get it?
07:29:44 <aristid> BONUS: i guess they got a timeframe. like "in the next 30 minutes"
07:29:48 <BONUS> ah
07:30:14 <rostayob> Will sort be efficient with something like "take 20 . sort foo"? My guess is that it should (lazyness) but does it actually?
07:30:15 <BONUS> jjohnsson: the book? on amazon & other book shops
07:30:38 <nominolo> rostayob: yes, you only pay for the elements you use
07:30:49 <rostayob> And with "sort" I mean the stock function
07:30:53 <nominolo> it's designed like to behave like that
07:31:00 <jjohnsson> BONUS: thanks. still says it's not out on http://learnyouahaskell.com/faq
07:31:00 <rostayob> cool
07:31:08 <BONUS> oh yeah i gotta update that!
07:31:18 <Panaetius> BONUS: is there an ebook version available?
07:31:23 <rostayob> so if I take M elements on a list of length N, the complexity would be something like O(N + M log M)
07:31:36 <BONUS> Panaetius: there will be. i know there's an epub version floating around somewhere
07:31:41 <BONUS> that was put together by someone
07:32:06 <Panaetius> well, I'm using a local mirror at the moment, but an ebook would be less messy :)
07:32:26 <BONUS> there's gonna be a cool pdf available too
07:32:27 <Panaetius> yeah i know that one, but it's incomplete and missing the funny images...
07:33:10 <nominolo> rostayob: O(M log M) I think
07:33:18 <BONUS> Panaetius: no, not the incomplete one
07:33:28 <BONUS> it's gonna be a complete one, with color images and everything
07:33:30 <nominolo> apparently it's a property of lazy merge-sort
07:33:34 <Panaetius> cool :)
07:33:38 <rostayob> nominolo: no, that's impossible
07:33:52 <rostayob> nominolo: you have to analyze all elements at least once, that's for sure :P
07:33:57 <Panaetius> and thanks for the nice tutorial, i think I wouldn't have made it without lyah :)
07:34:25 <nominolo> rostayob: yeah, that didn't seem right.  So it's O(n) to get the first element
07:34:39 <Jafet> It's O(n log m), which happens to be the theoretical minimum.
07:34:55 <nominolo> rostayob: see http://www.haskell.org/pipermail/haskell-cafe/2009-July/063928.html
07:34:57 <rostayob> nominolo: yes, and O(n + m log m) to get the first m. I think.
07:34:58 <BONUS> Panaetius: thanks for reading :)
07:34:59 <Jafet> Of course, that formula only makes sense for asymptotically large n and m, eg. not m=1.
07:35:19 <rostayob> ah... ok
07:35:21 <aristid> BONUS: is there any differences in content compared to the website?
07:35:53 <FliPPeh_> LYAH has taught me Functors, Monoids and Monads <3
07:35:57 <BONUS> aristid: yes. the book has gone through an editing process and i dare say that it's better and cleaner
07:36:00 <BONUS> BUT
07:36:04 <BONUS> i will update the site to reflect the contents of the book
07:36:54 <nominolo> BONUS: if there's not going to be an ebook, it would be nice to have a PDF formatted for size, say, A5.  That seems to work well on a kindle
07:37:19 <BONUS> hmm
07:37:27 <BONUS> i think there will be an ebook sort of thing
07:38:11 <Panaetius> BONUS: by the way, are you planning on expanding lyah? I'd love some resources on a little more advanced haskell topics, i.e. a chapter on arrows sure would be nice
07:38:12 <rostayob> I asked this a few hrs ago, but I haven't found a solution yet: I want to use Data.Set with a custom comparing function (not Ord's 'compare'). How can I do that considering that the constructors for Set are not exported?
07:38:35 <nominolo> rostayob: use a newtype
07:38:52 <Panaetius> nominolo: a correctly tagged PDF should do just fine when reflow is available, if the Kindle supports PDF Reflow
07:38:58 <BONUS> Panaetius: not quite right now, but i might do a sort of guide that takes what you know in LYAH and then makes real working stuff with that
07:39:01 <rostayob> nominolo: how would that help?
07:39:02 <nominolo> e.g., newtype MyKeyType = MKT OriginalKeyType
07:39:03 <BONUS> somewhere in the future
07:39:15 <nominolo> rostayob: you can then define a different Ord instance
07:39:21 <Peaker> Not arrows, arrows suck! :)
07:39:38 <Peaker> Category is useful, though
07:39:40 <nominolo> Panaetius: do you have an example, then I could try it.
07:39:59 <rostayob> nominolo: no, Ord is not good for me, since I my ordering function needs the current time to work
07:40:22 <nominolo> rostayob: uh, so it's going to be impure?
07:40:39 <Panaetius> BONUS: that would be grat :) I was somewhat at a loss when I finished lyah and had no idea where to go from there 
07:40:56 <mjrosenb> rostayob: you may want to mention that your ordering function needs to have a type that is not compatible with compare.
07:40:59 <systemfault> RWH could be the next step :/
07:40:59 <rostayob> nominolo: no, I can get the current time and then put it in the function. eg. when traversing the tree the time is the same
07:41:00 <BONUS> people usually combine it with RWH
07:41:04 <djahandarie> BONUS, competing with Real World Haskell? :)
07:41:09 <BONUS> cause LYAH doesnt teach you much real world stuff
07:41:14 <BONUS> haha, oh no
07:41:26 <systemfault> Shrug, LYAH is a way better tutorial than RWH will ever be.
07:41:30 <FliPPeh_> RWH isn't that great to be honest
07:41:31 <rostayob> nominolo: I mean my comparing function would be something like compare :: a -> a -> UTCTime -> Ordering
07:41:35 <FliPPeh_> It's _WAY_ to fast moving
07:41:42 <BONUS> idk, depends on your preference i think
07:41:48 <Gracenotes> RWH has killer exercises also
07:41:50 <BONUS> some people find LYAH way too verbose and hand-holdy
07:41:52 <djahandarie> RWH is tackling a totally different problem.
07:42:01 <BONUS> they're completely different books
07:42:07 <Gracenotes> it's a wonderful tour of the libraries, at least the libraries 3 years ago ;)
07:42:27 <djahandarie> "Learn how to program Haskell" vs "Learn how to make real world applications using Haskell"
07:42:37 <djahandarie> I'd like a "Learn how to program using Haskell", personally :)
07:42:57 <djahandarie> i.e., something that is more tailored towards teaching basic computing concepts and such
07:43:16 <djahandarie> Similar to SICP
07:43:19 <Jafet> "Learn how to not program using Haskell"
07:43:19 <BONUS> hmm yeah. LYAH is mainly aimed at the crowd that says "i don't *get* haskell"
07:43:21 <Gracenotes> ooh, that reminds me, I'll be giving a haskell talk at my university's linux user group (the second one)
07:43:23 <Panaetius> nominolo: http://dl.dropbox.com/u/20734733/Stanislaw%20Lem%20-%20The%20Offer%20of%20King%20Krool.pdf an excerpt from the cyberiad. should do nicely
07:43:24 <systemfault> How To LYAH? :/
07:43:25 <rostayob> mjrosenb: yeah, I tought it was clear since I said I can't user Ord :P
07:43:43 <Gracenotes> so I need to mix how-to-haskell and useful-thing-in-haskell
07:43:59 <Gracenotes> the latter probably by showing how it interoperates with useful-real-world-thing
07:44:21 <djahandarie> BONUS, your guide is spot on for people who are already familiar with programming, but it's pretty much impossible for me to hand it to someone who has never done it before
07:44:39 <Panaetius> nominolo: but in my phone i have to activate the reflow mode first, it's an option in the menu
07:44:46 <BONUS> true, it does make quite a few assumptions when it comes to basic programming knowledge
07:45:22 * hackagebot copilot 1.0.2 - A stream DSL for writing embedded C monitors.  http://hackage.haskell.org/package/copilot-1.0.2 (LeePike)
07:45:50 <Gracenotes> don't want to go to bio :(
07:46:35 <djahandarie> copilot is pretty cool
07:46:59 <nominolo> Panaetius: ok, it doesn't seem to work out of the box.
07:47:46 <Panaetius> BONUS: i'm not that fond of RWH. in the end i just started doing all my project euler problems in haskell and went from there
07:48:14 <Jafet> Panaetius: I call that "missing the point"
07:49:43 <Panaetius> nominolo: seems the kindle doesn't support PDF reflow, but check out http://blog.10ninox.com/2010/11/04/pdf-reflow-on-kindle/
07:49:49 <systemfault> I think that LYAH and RWH are as good... LYAH is just a "better tutorial"
07:50:29 <djahandarie> Haskell guide holy wars!!
07:51:04 <Entroacceptor> I saw a book "seven languages in seven weeks"
07:51:20 <Entroacceptor> it had an intro into haskell, too
07:51:47 <mercury^> Did it teach type classes?
07:51:56 <djahandarie> A fairly unknown fact was how that book was originally named "learn nothing in seven weeks" but the publisher changed it
07:52:03 <BONUS> lol
07:52:17 <JimmyRcom> RWH is a lot better if you read it offline and read the newer comments, still liked bonus' guide better
07:52:26 <JimmyRcom> *read it online
07:52:55 <Panaetius> what i mean is, lyah taught me the basics, but i found it easier to just jump in, making mistakes and learning on my own. i.e. the gap from lyah to RWH was a little to big. Like, you don't get that much out of it as the topics seem a little too advanced for a beginner
07:53:01 <BONUS> learn spanish, italian, french, dutch, flemmish, croatian and russian in 7 weeks
07:53:28 <systemfault> Of course!
07:53:34 <Blarumyrran> Those are similar languages
07:54:04 <djahandarie> Learn Spanglish, Southern Drawl, Confused Asian Foreigner, AND Overexcited Indian in 7 weeks!
07:54:07 <BONUS> still, i think learning-wise we're better off now that we have RWH, LYAH, tryhaskell, etc. than we were before all that
07:54:10 <Jafet> I learned C++ in twelve parsecs
07:54:10 <BONUS> haha
07:54:37 <roconnor> Jafet is a tachyon!
07:55:28 <Panaetius> then again, I'm still a haskell noob and i guess my haskell code is as bad as my php code was when i first started out, so you're probably right, Jafet :)
07:55:32 <Jafet> It takes a lifetime to reach native overexcited Indian.
07:55:55 <systemfault> PHP code can be good?
07:55:57 <Jafet> Panaetius: the "Euler" puzzles don't cover the same kind of programming problems as those in RWH.
07:55:57 * roconnor finds it hard to believe noob haskell code could be as bad as php code.
07:56:04 * systemfault stops trolling
07:56:19 <Jafet> systemfault: it can be better than Visual Basic 6 code.
07:56:35 <systemfault> Right, but VB6 is dead, PHP isn't
07:56:46 <mjrosenb> Jafet: i wrote some pretty horrid VB6 code in my day.
07:57:00 <djahandarie> I wrote some too, I don't even know why I tried that language
07:57:03 <djahandarie> I just remember hating it
07:57:06 <Jafet> It's not dead, just retired
07:57:18 <Panaetius> yes but they provide a nice set of 'small' problems with enough depth to actually get you coding. because after lyah i was at a complete loss on how to do a bigger project in haskell
07:58:01 <djahandarie> Panaetius, this is semi-useful for coding, but not for real-world stuff exactly: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
07:58:09 <Jafet> Panaetius: they don't have anywhere near the same depth as, say, writing a network server or interfacing with a blas library.
07:58:23 <Jafet> RWH introduces you to that kind of problems.
07:58:32 <djahandarie> It's similar to Euler, but without the crazy math knowledge needed for the later problems
07:58:38 <Panaetius> nominolo: oh and if you want to see what i mean by reflow, open the pdf i sent you in adobe reader, hit CTRL+4 and resize the window (and do the same without hitting CTRL+4)
07:58:53 <BONUS> i thought it was pretty much impossible to make a book that makes it easy to pick up the basics of haskell and do useful stuff with it at the same time
07:59:11 <djahandarie> I can agree with that
07:59:24 <djahandarie> But I think it'd be useful to have notes in the sidemargin that mention where things tend to be used
07:59:53 <djahandarie> That'd be more for the mental effect rather than actually teaching anything though
07:59:57 <Philippa> *nod*. You sorta need a guide to domain-specific stuff in Haskell somewhere, but...
08:00:17 <Panaetius> djahandarie: i did those at the same time as i did project euler :) 
08:00:37 <JimmyRcom> now we just need a good ocaml book
08:00:43 <djahandarie> Someone should really write a nice intro to writing EDSLs in Haskell, since it's an incredibly common thing to do
08:05:01 <roconnor> @type either 
08:05:02 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:06:26 <roconnor> @type \f a l -> foldr (\b k a -> either id k (f a b)) id l a
08:06:27 <lambdabot> forall a b. (b -> a -> Either b b) -> b -> [a] -> b
08:06:34 <Panaetius> Jafet: oh i'm not saying that project euler is the be all and end all of learning haskell, but i found the progression of "lyah->doing project euler (and 99 problems) stuff to get the hang of it -> reading examples on reddit like the socket server one->starting a small project" came more natural than "lyah -> rwh" did
08:07:17 <Jafet> Okay.
08:08:07 <Jafet> (Why do people refer to things that happen to be linked from Reddit as "on Reddit"?)
08:08:24 <Jafet> (Partly why I instinctively disrespect that website.)
08:09:06 <BONUS> Jafet: kind of like when you say something is "on TV" i guess
08:09:12 <Tomsik> as "on the web"
08:09:28 <Tomsik> or "on google news"
08:10:25 <Panaetius> but that's exactly the problem i had. after finishing lyah i was at a loss on how to continue and rwh just didn't do it for me, but the haskell reddit is a nice place to get some pointers to smallish code samples that one can study and further reading
08:10:42 <roconnor> @pl \f a l -> foldr (\b k a -> either id k (f a b)) id l a
08:10:42 <lambdabot> flip . flip foldr id . (flip ((.) . either id) .) . flip
08:10:50 <roconnor> @pl foldr (\b k a -> either id k (f a b)) id l a
08:10:50 <lambdabot> foldr (flip ((.) . either id) . flip f) id l a
08:10:55 <Panaetius> that's why i say "on reddit" as i didn't find any other good ressources
08:10:56 <Panaetius> ah well
08:12:19 <roconnor> @type \f x l -> foldr (\b k a -> either id k (f a b)) id l x
08:12:20 <lambdabot> forall a b. (b -> a -> Either b b) -> b -> [a] -> b
08:17:17 <runiq> Hey everyone.
08:19:11 <runiq> A beginner's question: Is it theoretically possible to make any data type an instance of any type, or are there restrictions in place? I'm currently going through BONUS' LYAH tutorial, and I wanted to make the "Frank" data type in the Kinds chapter an instance of Functor.
08:19:30 <runiq> Whoops, I meant "make any data type an instance of any *class*".
08:19:49 <Twey> runiq: The kinds have to match
08:19:53 <monochrom> indeed you have to obey Kinds restrictions.
08:20:03 <runiq> And that is all?
08:20:04 <Twey> And some types simply have no sensible instance of a class
08:20:04 <greenrd> found a bug in text-icu regular expression matching: ICUError U_REGEX_INVALID_STATE - has anyone seen this?
08:20:20 <BONUS> runiq: like a simple example would be that you can't make Int an instance of Functor
08:20:33 <BONUS> because fmap for Int would then be (a -> b) -> Int a -> Int b
08:20:39 <BONUS> and that doesn't make sense, type-wise
08:20:48 <runiq> Right, of course. Thanks a lot!
08:21:03 <monochrom> that's the only restriction if you don't care whether the methods misbehave.
08:21:20 <runiq> Also, the tutorial is awesome. Thanks for that as well, Bonus. :)
08:22:05 <BONUS> thanks for reading :)
08:24:39 <runiq> Okay, just to make the matter a bit clearer to me... "Frank" has kind * -> (* -> *) -> *, and to make Frank an instance of Functor, I'd *somehow* have to get a * -> * kind out of it. Is this really not possible in this case?
08:25:41 * hackagebot free-theorems-seq 1.0 - Taming Selective Strictness  http://hackage.haskell.org/package/free-theorems-seq-1.0 (DanielSeidel)
08:25:47 <BONUS> let's see
08:26:05 <BONUS> if you just made it
08:26:09 <BONUS> fmap would be of type
08:26:23 <BONUS> (a -> b) -> Frank c a -> Frank c b
08:26:28 <BONUS> which would expand to
08:27:12 <BONUS> (a -> b) -> a c -> b c
08:27:14 <imc> hello, i'm looking for documentation on FRP.Yampa (already getting my hands on it through the scarce examples found on the web)
08:27:39 <Twey> BONUS: Huh?
08:27:42 * hackagebot free-theorems-seq-webui 1.0 - Taming Selective Strictness  http://hackage.haskell.org/package/free-theorems-seq-webui-1.0 (DanielSeidel)
08:27:42 <BONUS> wait
08:27:45 <BONUS> did i mess that up?
08:27:47 <Twey> I think so
08:27:54 <Twey> In a couple of different ways
08:28:03 <BONUS> ugh ok wait
08:28:06 <Twey> Let f = Frank c
08:28:22 <imc> in particular I would like to know how to have something like a "time source" signal
08:28:34 <Twey> Then fmap :: (a -> b) -> Frank c a -> Frank c b = (a -> b) -> f a -> f b
08:29:19 <BONUS> yes, but
08:29:39 <runiq> So, Frank c would be of kind * -> *. But that's not really possible, since Frank's other type parameter has kind (* -> *)
08:29:40 <BONUS> data Frank a b = Frank (b a)
08:29:45 <Saizan> if Frank :: * -> (* -> *) -> * then Frank c can't be an instance of functor at all
08:30:03 <monochrom> Frank has kind * -> (* -> *) -> *. Frank Int has kind (* -> *) -> *. Frank Int IO has kind *. None of them has kind *->*. End of impossibility proof.
08:30:04 <BONUS> Saizan: yeah, i was trying to explain why, although i seem to have tripped myself up
08:30:08 <runiq> Saizan: Yes, that's what I thought. I wasn't entirely sure, though.
08:30:17 <Twey> Oh, b :: * -> *
08:30:21 <Twey> Yeah, I don't think that works at all
08:30:40 <Saizan> Flip Frank b would
08:31:30 <monochrom> Frank Int Stein
08:31:40 <BONUS> haha
08:31:48 <Saizan> given newtype Flip (f :: * -> (* -> *) -> *) a b = Flip (f b a)
08:33:11 <runiq> Saizan: Whoa... That's... advanced. :D I'll have to think this through for a while...
08:33:12 <greenrd> argh, text-icu uses unsafeInterleaveIO for regular expressions
08:33:16 <greenrd> I suspect that's why it's failing
08:34:26 <greenrd> big red flag: "this is not thread-safe"
08:34:43 <greenrd> or it could be just that the C interface has changed in an incompatible way
08:34:56 <runiq> Saizan: Ah, okay, awesome - you implemented the flip function for data types. I wouldn't ever have even thought of that.
08:34:59 <bos> greenrd: what's going wrong?
08:35:31 <greenrd> bos: I just filed a bug - ICUError U_REGEX_INVALID_STATE. That's all I know so far.
08:35:39 <confound> Flip Frank is what you use for turning hotdogs
08:35:47 <Saizan> runiq: yep
08:35:50 <bos> greenrd: ah
08:36:16 <greenrd> bos: so is all that unsafe stuff in there definitely safe?
08:36:23 <Gracenotes> o.o
08:36:55 <bos> greenrd: i thought so when i was writing it ... ?
08:38:24 <greenrd> bos: ok at least I have a reproducable test environment - I assume
08:38:26 * greenrd checks
08:39:02 <greenrd> yup, I do
08:39:03 <runiq> Okay, I'll play with this some more.
08:39:08 <runiq> Thanks for the help, guys!
08:39:15 <bos> greenrd: ok, i'll take a look
08:39:37 <aristid> greenrd: pure code that is not thread-safe is EVIL
08:39:48 <greenrd> bos: thanks! anything you'd like me to do? short of showing the code, which I'd have to get permission for
08:40:32 <bos> greenrd: this is happening in a multi-threaded app?
08:42:21 <greenrd> aristid: well, it's pure code that I think is based on impure code that is not thread-safe
08:42:29 <greenrd> bos: no
08:42:48 <bos> greenrd: ok
08:44:15 <dons> jlouis: have luck with -threaded ?
08:45:47 <bos> greenrd: i need more details. see the bug.
08:49:47 <kanak> Hi, is there a blog hosting site (e.g. wordpress.com, blogger) that has out-of-the-box support for haskell syntax highlighting?
08:51:58 <sm> I doubt it
08:54:24 <kanak> sm: thanks. i'll try to see if i can use plugins with wordpress to get what i want.
08:55:52 <sm> http://stackoverflow.com/questions/1522573/how-to-get-haskell-syntax-highlighting-on-php-blog may be helpful, there is a js highlighter 
08:57:17 <nominolo> Panaetius: I don't have adobe reader
08:59:29 <lars9> is there any well known lazy&pure language after haskell? haskell is over 20 years old now
08:59:46 <mzero> Haskell2010 is only one year old!
08:59:46 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
09:02:51 <sm> lars9: no!
09:03:14 <confound> lars9: if it were well known, would you have to ask that question?
09:04:31 <Panaetius> nominolo: without: http://dl.dropbox.com/u/20734733/WithoutReflow.png with: http://dl.dropbox.com/u/20734733/WithReflow.png though as you see, the document is not really tagged correctly, as it eats the linebreaks in places where it shouldn't. in a correctly tagged document the original linebreaks/paragraphs persist and it just adds linebreaks as needed to get the text to fit the screen
09:04:39 <lars9> so it seems ppl havent invented enough for a new language to born yet?
09:05:00 <djahandarie> There are plenty of new languages.
09:05:15 <kmc> lars9, compare GHC Haskell to Haskell 98
09:05:23 <djahandarie> Most of the interesting ones are going in the direction of dependent types.
09:05:34 <acowley> Is every Haskell Functor an initial F-algebra?
09:05:44 <djahandarie> I guess that would include GHC too, if you look at its trajectory :)
09:06:11 <kmc> the language implemented by GHC is vastly different from Haskell
09:06:16 <kmc> so i'd consider that a successor
09:06:39 <confound> it's a weird question anyway
09:07:00 <kmc> Haskell is a good enough starting point that most people working on new features for similar languages don't feel the need to reinvent the wheel
09:07:57 <sm> lars9: but you could look at http://code.google.com/p/pure-lang/
09:08:07 <copumpkin> acowley: haskell functors are endofunctors on hask
09:08:15 <kmc> lars9, so if you're looking for inventions that have occurred since Haskell 98 you should look in section 7 of the GHC Manual
09:08:16 <sm> also http://www.haskell.org/haskellwiki/DDC
09:08:46 <kmc> there are also cool extensions present in other compilers that aren't GHC
09:08:52 <copumpkin> acowley: you talking about functor fixed points?
09:08:58 <acowley> copumpkin: yes, but I needed to uniqueness of a function F(a) -> a
09:09:05 <nominolo> Panaetius: nice.  Would be nice to have this in the Kindle viewer
09:09:08 <copumpkin> acowley: that's a fold
09:09:11 <acowley> right
09:09:28 <kmc> disciple is neither lazy nor pure in the sense of Haskell
09:09:31 <acowley> but I'm uncomfortable because I need it in the context of a coninductive proof specifically dealing with infinite data
09:10:01 <copumpkin> acowley: oh, well more strictly it's a terminal coalgebra, but haskell doesn't really make much of a distinction
09:10:23 <Panaetius> nominolo: i'm somewhat astonished that it isn't present in the kindle. my mobile phone and even my 10 year old palm do it flawlessly
09:10:35 <acowley> so, let's call that function fin in honor of sigfpe, and then I have f . fin = fin . fmap f
09:10:47 <djahandarie> All the initial algebras would be unique up to isomorphism wouldn't they?
09:10:53 <acowley> djahandarie: yes
09:11:11 <Panaetius> nominolo: but you should check out the link i sent you, there's some alternatives to it
09:12:04 <acowley> and so what I want to say is that, given fmap f x, you will be applying something isomorphic to fin to it, so I can rewrite (fin . fmap) with (f . fin), and I get my guarding codata constructor by unfolding that composition and looking at what f does
09:12:43 <acowley> but that all assumes that given some functor F, I do in fact have the equation "f . fin = fin . fmap f"
09:13:27 <acowley> the cool part is that I will almost certainly cut this proof from the paper because it has gotten absurdly off topic :/
09:14:59 <acowley> so does all that sound wrong, right, other?
09:23:41 <binarybana> Hi! To install HP 2011.2 in Ubuntu, is the currently recommended route to install from source?
09:23:47 <binarybana> Or is there a PPA somewhere?
09:28:55 <dmwit> binarybana: I'm fairly sure there's a binary installer on the HP website.
09:29:14 <dmwit> I doubt the recommended route for the HP is ever to install from source (unless you're on the committee creating it).
09:29:31 <binarybana> That's what I was thinking to myself
09:29:46 <dmwit> http://hackage.haskell.org/platform/linux.html
09:29:50 * lispy1 searches for the independent thought alarm
09:29:54 <binarybana> but the links for Ubuntu seem to all be to package repositories with 2010.2
09:30:04 <confound> dmwit: I think you're thinking of ghc.
09:30:18 <dons> binarybana: via src.
09:30:19 <confound> I installed HP from source on ubuntu yesterday because I couldn't find a deb
09:30:55 <lispy1> dons: how's it going?
09:31:09 <binarybana> maybe I should volunteer to setup a PPA (after learning how to make one first)
09:31:17 <dmwit> Okay.
09:31:22 <kmc> i thought there was one already
09:31:23 <dmwit> I'm often wrong. =)
09:31:26 <lispy1> binarybana: cool.  Volunteers are always needed :)
09:31:50 <karl_> has anyone gotten haskell-src-exts to compile with GHC 7.0.2?
09:32:39 <karl_> All I got was
09:32:41 <karl_> haskell-src-exts-1.10.2 failed during the building phase. The exception was:
09:32:41 <karl_> ExitFailure 9
09:32:44 <dons> monochrom: added your guide here, http://hackage.haskell.org/platform/linux.html 
09:32:52 <karl_> No other info.
09:33:00 <dons> karl_: yes. got it to work (when building agda)
09:33:14 <lispy1> karl_: How much ram do you have?
09:33:22 <dons> 9 sounds bad.
09:33:26 <dons> like a segfault
09:33:30 <lispy1> karl_: in the past when I  got ExitFailure 9, gnu ld was running out of memory
09:33:34 <karl_> I got
09:33:43 <karl_> 1 GB RAM and 256 MB swap.
09:34:10 <lispy1> karl_: can you watch the build with top and see if it tries to use too much?
09:34:57 <lispy1> karl_: FWIW, I would expect 1GB to be enough
09:35:56 <karl_> then again, I have a dozen tabs in opera and chrome open.
09:42:12 <jlouis> dons: I've been in a maze of twisty little erlang terms and json encodings all day, sorry :)
09:42:54 <bos> jlouis: lucky you :-p
09:43:57 <jlouis> ok, some fast preliminary play with it shows some rather impressive performance
09:45:08 <lispy1> jlouis: my scrollback doesn't go far enough, what are you playing with?
09:45:18 <jlouis> dons: update :) It looks really, really good with -threaded
09:45:49 <jlouis> I should probably run my test cases again and then see how my sparklines improve
09:45:54 <jlouis> lispy1: Combinatorrent
09:46:09 <jlouis> lispy1: specifically, combinatorrent + new-io-manager
09:46:13 <lispy1> jlouis: ah.  cool.  
09:46:35 * lispy1 is waiting on a ghc7 download right now actually :)
09:47:24 <lispy1> I have an older version, but now that the HP is out I wanted to upgrade again
09:47:49 <jlouis> yeah, Another thing is to check the client with many torrents
09:47:50 <kmc> jlouis, how concurrent is combinatorrent?
09:47:58 <jlouis> 500 forkIO's
09:48:01 <jlouis> around that
09:48:07 <jlouis> it depends on the number of peers
09:48:58 <jlouis> and the number of torrents you spawn
09:48:59 <jlouis> etc
09:49:41 <kmc> cool
09:52:38 <jlouis> it looks much better
09:53:25 <jlouis> Now it is in the range of etorrent 
09:53:32 <djahandarie> Nice
09:53:43 <djahandarie> Switch all efforts to combinatorrent ;)
09:53:44 <jlouis> etorrent being a bit faster on a single torrent
09:53:56 <jlouis> well, I have more developers in etorrent :P
09:54:18 <djahandarie> Make them learn Haskell!
09:54:26 <djahandarie> It'll only be a little painful :)
09:54:29 <jlouis> haha
09:54:40 <jlouis> Haskell isn't painful IMO
09:54:48 <jlouis> It is bliss
09:55:02 <c_wraith> it's painful.  The pain of baptism by fire. :)
09:55:52 <PhilRod_> it's painful if you then have to spend all day writing in C++, knowing how much easier it could all be...
09:58:14 <acowley> djahandarie: did you have any thoughts about my earlier question involving initial algebras (or possibly final coalgebras!)?
09:58:18 <bos> greenrd: found your bug
09:58:28 <bos> greenrd: it's actually a bug in ICU itself
09:58:59 <kmc> jlouis, it'd be cool to show this off beyond the Haskell community, as an example of GHC's support for massively concurrent IO
10:00:14 <djahandarie> acowley, I'm not sure.
10:00:29 <sm> go jlouis .. maybe soon you'll have a few more haskell developers
10:01:17 <zygoloid> djahandarie: suppose i had: f :: (([Sum a] -> b) -> Sum a -> c), and i wanted (([a] -> b) -> a -> c). it'd be nice if that sort of wrap/unwrap could be implicitly built for me, is all :)
10:01:21 <acowley> djahandarie: fair enough, I'm not sure either. It's frustrating though as all I was doing was a functor laws proof, but the lack of a base case in the data type sent me down that path
10:10:03 <djahandarie> zygoloid, I have no idea how I would write such a thing for the general case
10:10:47 <zygoloid> some hideous monstrosity using OverlappingInstances, I imagine ;(
10:11:02 <djahandarie> Yeah
10:11:25 <djahandarie> instance Newtype p u => Newtype (a -> p) (a -> u) is a nice one to have around
10:13:47 <joe6> what is the haskell equivalent to prolog DCG?
10:14:28 <djahandarie> Is there a newtype AppLift lying around somewhere? Like instance (Applicative a, Monoid x) => Monoid (AppLift a x) where
10:14:36 <dons> jlouis: i really think we can beat erlang here. i'd love to know where you think the bottlenecks are
10:14:45 <dons> jlouis: but yes, do tell about -threaded and ghc 7
10:15:52 <hpc> djahandarie: where mappend = liftA2 mappend?
10:17:11 <djahandarie> mappend (AppLift ax) (AppLift ay) = AppLift (mappend <$> ax <*> ay)
10:17:28 <kmc> joe6, can you tell us what that is?
10:19:03 <karl_> how do I tell ghc to statically link EVERYTHING?
10:19:03 <bos> greenrd: bug fixed
10:19:04 <Fuco> kmc Definite Clause Grammar
10:19:21 <Fuco> something like CFG++
10:19:53 <Fuco> and to answer the question, I don't think there's a built-in haskell equivalent
10:20:39 <joe6> uco, thanks. Are they(DCG) still relevant in today's context?
10:20:46 <joe6> s/uco/Fuco/
10:20:53 <Fuco> they are just a syntactic sugar
10:21:12 <joe6> oh, ok.
10:21:22 <joe6> Fuco, thanks.
10:29:32 <weirdo> does leksah integrate with ghci?
10:30:23 <hpc> karl_: ghc statically links by default
10:45:38 <lispy1> dcoutts: why are more things showing up here? http://hackage.haskell.org/packages/archive/preferred-versions  I thought the plan was to stop using it!
10:45:52 <lispy1> dcoutts: it's such a frustrating hack :(
10:46:05 <lispy1> dcoutts: just let people fix their package
10:46:14 <dcoutts> lispy1: is it frustrating because it's not reflected in the hackage pages?
10:46:53 <lispy1> dcoutts: It's frustrating because it's inconsistent and people don't have sufficient control or intorspection
10:47:18 <dcoutts> lispy1: the network addition was done by the package author
10:47:37 <dcoutts> lispy1: and the plan in the new server is to allow the package maintainers to do this more easily
10:47:59 <dcoutts> but the new package pages also make clear when there are versions that are not preferred
10:48:02 <lispy1> Why are people releasing new versions if they don't want anyone to use it?
10:48:05 <dcoutts> as does cabal list 
10:48:11 <dcoutts> lispy1: betas
10:48:27 <dcoutts> lispy1: I've deliberately not unmasked cabal-install-0.10
10:48:37 <Panaetius> Non type-variable argument in the constraint: MonadState AppData m
10:48:37 <Panaetius>     (Use -XFlexibleContexts to permit this)
10:48:37 <Panaetius>    <-- can someone explain this error to me and how to fix it (or where/how exactly I can set that flag in leksah?)
10:48:50 <dcoutts> liesen: as maintainer, I want more testing and feedback before I recommend everyone upgrade
10:48:54 <dcoutts> oopes
10:49:02 <dcoutts> lispy1: ^^
10:49:04 <Panaetius> it's on line 70 of https://github.com/snkkid/LazyFooHaskell/blob/master/lesson14/lesson14.hs (and some of the following lines)
10:49:23 <lispy1> But, if no one is using it because cabal-install doesn't use it, then how will you get people to use it?
10:49:46 <dcoutts> lispy1: sorry, I don't follow
10:49:47 <lispy1> dcoutts: and why are we still preferring base3?
10:50:02 <dcoutts> lispy1: yes that one is a hack, to stop old packages breaking
10:50:29 <dcoutts> lispy1: and I'm quite happy to separate the mechanism into two parts, hacks and maintainer preferences
10:50:41 <lispy1> That's not the solution
10:50:51 <taotree> So, I found a performance issue: we have something dumping messages on a TChan, and then a consumer processing those. But the consumer can't keep up, so we're getting lots of memory usage as the producer is dumping lots of stuff on the channel, but consumer isn't keeping up. Is there a straightforward API to blocking the producer if the channel queue gets a certain size or something so we can have the producer wait for the consumer to
10:50:51 <taotree>  catch up?
10:51:00 <lispy1> Is the problem that you don't want people to fix their packages?
10:51:17 <dcoutts> lispy1: you cannot currently fix old packages, they're immutable
10:51:38 <Panaetius> i tried changing it to 'getFrame :: ((MonadState AppData) m) => m Int' but that doesn't help
10:51:41 <dcoutts> lispy1: we'll also add a .cabal file patching mechanism on the new hackage server, that may allow us to stop using the other mechanism for such hacks
10:52:10 <dcoutts> lispy1: but do not underestimate the degree to which that hack was useful. It saved us from 90% of hackage breaking during the base-3 to 4 transition.
10:52:30 <dcoutts> lispy1: I don't know if you recall the ghc-6.6 -> 6.8 transition.
10:53:21 <lispy1> Basically, I should still be using base3, parsec2,  and cabal 0.8?
10:53:52 <dcoutts> lispy1: we'll remove the parsec 3 one now that the new HP uses parsec 3
10:54:07 <dcoutts> lispy1: but up until now, parsec 2 was indeed the recommended standard version
10:54:20 <dcoutts> lispy1: base 3 is as you know rather a special case
10:54:23 <lispy1> Okay, but I should still use base3 even though ghc gives me a warning?
10:54:45 <dcoutts> lispy1: as you know, it only uses that preference if the package does not specify an upper bound on base
10:54:51 <lispy1> Even if the transition to base4 was hard; it's over now.  Let's clean up.
10:55:01 <dcoutts> lispy1: sure, that's fair enough
10:55:13 <dcoutts> it's a question of how we go about it
10:55:26 <lispy1> Well, my vote is to get rid of this mechanism.
10:55:53 <dcoutts> lispy1: and for cabal, yes I only released it a few days ago, version 0.10.0 had some bugs we found, I'll probably move to 0.10.2 being the default in the not too distant future
10:56:44 <dcoutts> lispy1: we'll certainly keep it for the maintainer use case, when they want to make new release available but don't want to yet recommend everyone upgrade, and also to mark known-broken versions.
10:57:04 * hackagebot text-icu 0.6.3.2 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.3.2 (BryanOSullivan)
10:57:08 <lispy1> known-broken seems like a different problem.
10:57:14 <dcoutts> lispy1: we can try and make the feedback and info about that clearer. Like the new hackage server shows the non-preferred versions better, as does cabal list
10:57:47 <lispy1> So, if your reason for keeping it is the new hackage server, then when will we get it?  I've heard things about it for something like a year
10:58:17 <dcoutts> lispy1: we're underresourced, like all projects
10:58:23 <Panaetius> ah nevermind, I missed the {-# LANGUAGE FlexibleContexts #-} part
10:58:42 <dcoutts> lispy1: highest priorities recently have been getting new cabal releases out and catching up on the cabal patch backlog.
10:59:14 <dcoutts> lispy1: Gracenotes has been working a bit on the new server, but we could definitely do with more help
10:59:28 <lispy1> That's good, but what time frame are we talking?  Another 2 years out for new hackage?  A week?
10:59:39 <dcoutts> more like 6 months perhaps
10:59:46 <dcoutts> there are various stages
11:00:13 <dcoutts> current interim target is live mirroring
11:00:49 <Gracenotes> hm. it is technically fully functioning. http://sparky.haskell.org:8080/recent
11:01:04 <dcoutts> oh good :-)
11:01:35 <Gracenotes> and I've installed haskell in a VM from scratch using it
11:01:56 <Gracenotes> this was a month ago, give or take...
11:02:03 <dcoutts> Gracenotes: perhaps you could send a status report to cabal-devel
11:02:14 <dcoutts> with what is left to do, and what people could help with
11:03:04 <dcoutts> Gracenotes: having done the recent cabal releases, I'm slightly wondering what my next project should be. There's lots to choose from. Priorities are tricky to work out.
11:04:05 <Heffalump> dcoutts: you have some paid-for time to work on infrastructure?
11:04:33 <dcoutts> Heffalump: the IHG is paying for some cabal work at the moment
11:04:55 <Heffalump> so you mean "what should your next project in cabal" be?
11:05:04 <Heffalump> with the quote marks in more intelligent places than I managed
11:05:07 <Gracenotes> tbh mirroring seems just fine, editable-mirroring hackage (including user account info) is a good next milestone. I have a few things this weekend to do, mostly in order to distract me from studying for a midterm
11:05:12 <dcoutts> Heffalump: I'm talking about my volunteer time
11:05:16 <roelvandijk> Is it possible for interested 3th parties to mirror hackage?
11:05:17 <Heffalump> ah, ok
11:05:32 <dcoutts> roelvandijk: with the new hackage-server impl, yes :-)
11:05:59 <roelvandijk> dcoutts: I'm mainly interested in data mining all hackage packages
11:06:07 <dcoutts> roelvandijk: so long as you are prepared to use beta software
11:06:11 <Gracenotes> even not using the new hackage server... diversity can't hurt so long as there's compatibility
11:06:27 <roelvandijk> dcouts: I would like to have an up-to-date clone of all hackage data
11:06:40 <roelvandijk> dcouts: But I don't want to cause undue amounts of bandwith for hacakge
11:06:42 <Gracenotes> hackage server also has a half-finished mode to get a tarball exporting all the packages (sans sensitive information). will probably have to be torrented.
11:06:52 <dcoutts> roelvandijk: I mean you can do it now, there's nothing magic. The hackage-mirror client just uses the ordinary unprivileged HTTP interface
11:07:23 <roelvandijk> dcoutts: But can it do something like only copy the differences since a previous sync?
11:07:39 <dcoutts> roelvandijk: that's exactly what it does
11:07:48 <roelvandijk> dcoutts: That sounds perfect!
11:08:07 <dcoutts> Gracenotes: btw, did you have any luck integrating my mirror client changes?
11:08:11 <lispy1> dcoutts: I'm trying to find the features you mentioned on the new hackage and it's really slow, but I don't see how I would mark a package as something I do or do not want to install
11:08:17 <roelvandijk> dcoutts: I want to try my hand and reverse dependencies for functions
11:08:26 <roelvandijk> dcoutts: s/and/at
11:08:30 <jlouis> dons: don't be too sure. Erlang is 15 years of optimized C in the part it traverses the most
11:08:47 <jlouis> dons: yet, it is way way better than earlier
11:09:30 <dcoutts> lispy1: there's a maintainer link for each package, but you need to be the maintainer
11:09:44 <lispy1> I got a 404 when I tired to edit tags
11:09:49 <dcoutts> lispy1: and I don't think we've synced the full user accounts with passwords
11:10:14 <Gracenotes> that would be nice to get done soon
11:10:29 <lispy1> putting it on a faster server would be nice too :)
11:10:34 <lispy1> http://sparky.haskell.org:8080/package/free-theorems-seq-webui/tags/edit
11:10:41 <lispy1> That's a 404 for me
11:10:42 <dcoutts> roelvandijk: reverse deps for functions? you mean a full function index for all packages? talk to tibbe, he wants to do the same.
11:10:55 <Gracenotes> scp-ing the htcrypt list over
11:11:02 <roelvandijk> dcoutts: That is exactly what I mean
11:11:12 <lispy1> dcoutts: So, the decision about what to install will still be server side?
11:11:30 <dcoutts> lispy1: it's always been client side, the server just provides some default preferences.
11:11:36 <dcoutts> but you still have full control
11:11:55 <Gracenotes> lispy1: the 404 link would be 401 otherwise
11:12:17 <lispy1> Not really.  That preferred-versions file gets magically updated and I don't have a way to know when I need to update my ~/.cabal/config to match
11:13:05 <dcoutts> lispy1: so you want to ignore all maintainer preferences and always use the latest, irrespective?
11:13:17 <Gracenotes> dcoutts: your version is 400 lines and mine is 300, and there's very little code in common between them :)
11:13:21 <lispy1> Gracenotes: but I wasn't prompted for authentication when clicking on the tag link.  I was when clicking the manage link.
11:13:46 <lispy1> dcoutts: Possibly.  Some control or freedom would be nice, yes.
11:13:47 <dcoutts> lispy1: perhaps, file a feature request ticket. Ask for a per-server config option to ignore preferences provided by that server.
11:14:04 <Gracenotes> lispy1: yep, it is 404 at the moment. html page needs to be hooked up to that url, but at the moment it's not worth it because it's controlled by access details anyway (and sparky has no account info :( )
11:14:21 <jlouis> and yes, profiling is also up next to see where the bottleneck is hiding now
11:15:08 <dcoutts> lispy1: or better, send a patch. I think it would be reasonably straightforward.
11:15:13 <lispy1> dcoutts: If we're going to have different distributions of hackage that's a nice feature, but I don't think this current strategy of growing it out of text files that are secretly controlled by hackage adimns is the way to go about it.
11:15:44 <dcoutts> lispy1: no, obviously. That's why the new server makes it a per-package thing, controled by the maintainers of that package.
11:15:49 <lispy1> Was there an announcement on Haskell-cafe or Haskell lists when network was added to that file?
11:16:01 <dcoutts> lispy1: no, the maintainer of the package just asked for it do be done.
11:16:29 <lispy1> and being out of sync with the HP is a bad
11:16:29 <dcoutts> lispy1: to mark as broken, the packages within that range.
11:16:41 <lispy1> "a bad state to be in"
11:16:41 <weirdo> is it hard/possible to implement an purely functional erastotenes sieve?
11:16:46 <dcoutts> lispy1: you mean parsec 3? yes we're out of sync by a day
11:17:07 <lispy1> And base
11:17:13 <lispy1> Base 4 is in the HP too
11:17:15 <dcoutts> no, that's quite a different issue
11:17:20 <dcoutts> there are further hacks for base
11:17:22 <lispy1> http://hackage.haskell.org/platform/changelog.html
11:17:27 <Gracenotes> weirdo: you might be interested in http://lambda-the-ultimate.org/node/3127
11:17:50 <weirdo> thank you
11:17:51 <roconnor> @type scanl
11:17:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
11:17:57 <lispy1> dcoutts: oh, and HP shipped cabal-install 0.10.2
11:18:03 <Gracenotes> the paper's linked at the top
11:18:05 <dcoutts> lispy1: yes, I know
11:18:25 <roconnor> >scanl (\x, (_, y) -> (x, x+y)) 0 (repeat 51)
11:18:27 <roconnor> > scanl (\x, (_, y) -> (x, x+y)) 0 (repeat 51)
11:18:28 <lambdabot>   <no location info>: parse error on input `,'
11:18:35 <roconnor> > scanl (\x (_, y) -> (x, x+y)) 0 (repeat 51)
11:18:37 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
11:18:41 <dcoutts> lispy1: when I remove the < 0.10 thing for cabal-install. Every cabal user will be prompted next time they do cabal update.
11:18:42 <lispy1> dcoutts: is it seems that the only legitimate line in that file is the network one
11:19:03 <roconnor> > scanl (\(x, _) y -> (x+y,y)) 0 (repeat 51)
11:19:04 <lambdabot>   [(0,0),(51,51),(102,51),(153,51),(204,51),(255,51),(306,51),(357,51),(408,5...
11:19:04 <lispy1> But that's fine, right because the HP has now blessed that version
11:19:10 <dcoutts> lispy1: so you'll understand that I want to make sure that it's not going to break everything for them, hence a slow introduction.
11:19:14 <Gracenotes> weirdo: the final 'answer' ends up being a bit weird if you don't follow the author's line of reasoning
11:19:22 <lispy1> dcoutts: but the HP already blessed it
11:19:35 <lispy1> if it's not good enough for hackage why is it in the HP?
11:19:37 <dcoutts> lispy1: but that's for new users, this also affects existing users
11:19:53 <dcoutts> lispy1: it's about a gradual changeover, not big bang
11:20:32 <dcoutts> lispy1: you're quite right about parsec 3 though, now the new HP is released we can remove that one.
11:20:54 <lispy1> I don't understand why you would treat those two differently
11:21:10 <dcoutts> lispy1: it's because of the self-upgrade prompt built into cabal-install
11:21:48 <lispy1> Using cabal-install to install new versions is already dangerous.  Who still does that?  I use cabal-dev to make sure my deps get updated too.
11:22:30 <dcoutts> lispy1: installing new version of most things is not dangerous
11:22:50 <dcoutts> upgrading libs low down in the stack tends to cause problems
11:22:51 <lispy1> dcoutts: I'm going to lunch.  Good luck with the new hackage and I expect it to be in place when I get back (okay, just kidding!)
11:22:57 <dcoutts> :-)
11:23:09 * monochrom trolls with "resolve all debates by adding more options. 'check-new-version: true/false' in .cabal/config"
11:23:23 <dcoutts> lispy1: you might note that the new cabal version removes the upgrade command
11:23:34 <lispy1> dcoutts: I didn't use that command anyway
11:23:52 <lispy1> just doing 'cabal install foo' has corrupted my pkg dbs lots of times though
11:24:02 <lispy1> Part of why I was eager to adopt cabal-dev
11:24:32 <lispy1> anyway, I was serious about getting some lunch
11:24:36 <dcoutts> :-)
11:46:26 <jlouis> I wonder what it means that 81% of the program is spent in MAIN MAIN
11:46:53 <jlouis> Probably that my Cost centres are sitting too tightly in the program
11:47:03 <jlouis> and needs to be moved to a more general spot
11:47:10 <Jafet> It means that your main is actually appropriately named
11:47:20 <jlouis> that too!
11:47:48 <jlouis> 81% of the time spent in the RTS?
11:47:55 <xplat> hey, cool, after i pasted my version of bwt some people wrote unbwt for it
11:48:30 <Jafet> I just copied my already-written version of twb. *shame*
11:49:54 <jlouis> dons: perhaps you know what MAIN refers to in profiles? IIRC Jaffacake attributes it to any spot in the code when the profiling timer hits, which is unknown as a cost centre
11:50:16 <jlouis> I am spending all my time there :)
11:50:43 <Jafet> Doesn't that go to "CAFs"?
11:51:14 <jlouis> CAF's are not the culprit according to the profile log
11:52:18 <jlouis> https://gist.github.com/fa6437218617444f1167 
11:52:32 <jlouis> The productivity is awesome btw
11:53:38 <jlouis> demandInput is somewhat unsurprising. It is what reads in messages from sockets
11:53:56 <jlouis> but it is less than 5% spent there. It is hardly an optimization candidate :)
11:58:13 <roconnor> would it be confusing to call the State monad the "state transformer monad" in my paper/
11:58:40 <dmwit> Yeah, probably, if you didn't really mean the StateT transformer. =P
11:58:41 <Gracenotes> but not the "state monad transformer"
11:58:56 <roconnor> or have we all decided by now to drop the state monad's middle name?
11:59:01 <dmwit> Oh, I see what you're going for.
11:59:05 <byorgey> "state transformer monad" and "state monad transformer" are different things.  But I do think it would be confusing.
11:59:21 <dmwit> One sentence clearing up the difference would probably be good if you're going to use "state transformer monad".
11:59:22 <Gracenotes> are you going to be doing other things to the state besides transforming it?
11:59:45 <roconnor> It's kinda sad really.  The "state transformer monad" is really more accurate name for State.
11:59:52 <Jafet> I would just call the State monad the State monad
12:00:23 <roconnor> Jafet: good idea.
12:00:26 <Gracenotes> well, I suppose there's a reason it's not newtype StateTransformer = runStateTransformer {...}
12:00:31 * roconnor puts State into san serif font
12:00:36 <Gracenotes> probably not a good reason
12:01:06 <Gracenotes> or monospace font? dunno type conventions -_-
12:01:23 <byorgey> hmm, code.haskell.org is super slow
12:01:38 <byorgey> is this because of the platform release?
12:01:49 <roconnor> Gracenotes: normally I'd use monospaced font.  But I'm using a stylized haskell notation in my paper.
12:01:57 <jlouis> byorgey: it is very fast here
12:01:57 <roconnor> (pseudo-haskell actually)
12:02:03 <Jafet> Quoted code is traditionally put in typewriter font
12:02:09 <byorgey> jlouis: thanks, weird
12:02:15 <jlouis> byorgey: ipv6?
12:02:25 <byorgey> I've read lots of papers with quoted code in sans serif.
12:02:36 <jlouis> it does answer on ipv6, which may...
12:02:49 <byorgey> which may what?
12:02:54 <xplat> quoted code is traditionally put in the same font as blockquoted code
12:03:03 <roconnor> I had my code originally in monospaced font.  But then I was comparing my paper to ndm's paper, and my code looked like crap.
12:03:04 <byorgey> xplat: indeed =)
12:03:21 <jlouis> byorgey: if you have ipv6 connectivity through a tunnel and the tunnel is congested, for instance
12:03:42 <byorgey> jlouis: I don't even know what that means but I believe you
12:03:47 <btutt> Stylized Haskell looks nicer in papers.
12:03:53 <jlouis> byorgey: windows? or linux?
12:03:58 <byorgey> jlouis: linux
12:04:00 <btutt> You get all of those nice arrows
12:04:10 <btutt> and better looking special operators
12:04:11 <byorgey> jlouis: I'm at school so this is through U Penn's network
12:04:16 <roconnor> btutt: I suspect it would look nicer in my editor too if it supported it. :)
12:04:24 <btutt> Heh
12:04:37 <byorgey> finally, my push succeeded
12:04:39 <xplat> a  b
12:04:46 <byorgey> took about 5 minutes to darcs push a single change
12:04:58 <btutt> That's just what we need a Haskell editor that has an IME that visualizes stylized Haskell
12:05:09 <roconnor> IME?
12:05:30 <jlouis> byorgey: it may be your network is preferring ipv6, or there may be something else wrong
12:05:31 <btutt> Input Method Editor. Those wierd thing Chinese/Japanese/whatever users use. 
12:05:45 <btutt> kinda like auto-complete on every place you can type
12:05:49 <roconnor> oh.  
12:06:11 <btutt> East Asian IMEs traditionally narrow glyphs down by typing phonetic spellings IIRC
12:06:18 <Fuco> how can I use printf from Text.Printf to print to standard output? (or some other stream?)
12:06:27 <jlouis> byorgey: oh, there is a haskell-cafe thread: "IPv6 issues for (code|community).haskell.org?"
12:06:49 <byorgey> jlouis: ah, I had seen that and deleted it because I assumed it didn't apply to me =P
12:07:01 <jlouis> Y. Gale sent a ticket on it
12:07:08 <Fuco> I tried "eprintf = hPrintf stderr"
12:07:08 <roconnor> btutt: yes, I'd like this
12:07:15 <byorgey> ok, as long as it is known, I am patient
12:07:19 <roconnor> btutt: it is similar to how TeXmacs input works
12:07:24 <Fuco> but it say Ambiguous type variable `r' in the constraint:
12:07:37 <Fuco> `HPrintfType r'
12:07:41 <jlouis> byorgey: try an 'ifconfig' and look for an ipv6 address that is not link local (fe80:..)
12:07:46 <byorgey> Fuco: probably the monomorphism restriction biting you
12:07:59 <Fuco> damn... by standard output I ment standard error
12:08:06 <byorgey> Fuco: disable it by putting {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file
12:08:10 * roconnor remembers being excited a few weeks ago when the monomorphism restriction actually helped him.
12:08:15 <btutt> roconnor: I tried some visual TeX editors. I wasn't convinced very well. Hard problem space.
12:08:17 <btutt> heh
12:08:22 <byorgey> roconnor: haha
12:08:49 <kmc> Fuco, you can put a type signature on your invocation of printf
12:08:50 <roconnor> btutt: One of TeXmacs's advantages is that it does't use TeX.
12:09:07 <Jafet> roconnor: did you mention it on the wiki?!
12:09:16 <roconnor> which wiki?
12:09:19 <byorgey> kmc: who wants to do that though?  The magic of printf is that it is well-typed but you need not actually know what the types are.
12:09:26 <Jafet> I think they're hiring http://www.haskell.org/haskellwiki/Monomorphism_restriction
12:09:28 <kmc> ;P
12:09:47 <roconnor> oh I don't know if I support the monomorphism restriction.
12:10:03 <Jafet> @remember byorgey The magic of printf is that it is well-typed but you need not actually know what the types are.
12:10:04 <lambdabot> I will remember.
12:10:15 <roconnor> It was just a rare case where my interests just happened to align with one of the motivating reasons for the MR.
12:10:32 <kmc> when printf gives me weird type errors i usually do something like let myprint :: Int -> String -> IO (); myprint = printf "foo %d bar %s"
12:10:57 <roconnor> It did something like (let x = fromIntegral y, in ... x ... x ...) and I wanted the use of one x to force the type of the other x.
12:11:10 <roconnor> without bothering to give a type to x.
12:11:35 <kmc> heh
12:11:40 <kmc> use MonoLocalBinds instead :D
12:11:40 <roconnor> 'cause I was too lazy to write x :: Word8
12:11:48 <roconnor> kmc: is that for real?
12:12:02 <kmc> the feature or my suggestion?
12:12:08 <roconnor> the feature?
12:12:24 <kmc> yeah
12:12:26 <btutt> roconnor: Oh. cool. I think I saw that a ways ago but didn't like it for some reason. probably because the screen shots looked very lame. I used to do Calc III/IV homework in LaTeX or Word 98 way back when.
12:12:36 <roconnor> it seems like a better version of the MR ... granted it is also more confusing. :D
12:12:40 <kmc> in GHC 7 it's implied by GADTs and TypeFamilies and some other stuff
12:12:46 <kmc> for implementation reasons
12:12:59 <kmc> makes every "let" binding monomorphic unless given a signature
12:13:21 <btutt> I wish there were better QT bindings for Haskell. It'd be more insensitive to port GHC to arm. (QT + Embedded == no need for X, yay!)
12:13:27 <roconnor> btutt: Not only is the input of math formulas by far the best WYSIWYG system I've ever encounted, it has become even better in recent releases.
12:13:38 <kmc> apparently inference for polymorphic local bindings in the presence of type equality coercions is some kind of enormous pain in the ass
12:13:45 <roconnor> btutt: now TeXmacs math formulas come with matching braces
12:14:04 <btutt> The toolbar screen shots remind me of Equation Editor in Word
12:14:11 <btutt> (but prettier)
12:14:17 <jlouis> argh, not the equation editor!
12:14:25 <roconnor> you type '(' and you get a pair of open/close parens and then you type your whatever, and then when you type ')' it takes the cursor past the existing ')'
12:14:44 <btutt> sweet
12:14:48 <roconnor> btutt: ya, it looks kinda like crap.
12:14:55 <roconnor> (the menu buttons)
12:14:59 <EvanR-work> my stupid haskell program segfaults 0.1% of the time :(
12:15:00 <roconnor> they are full of confusing icons
12:15:19 <roconnor> but after a couple of weeks you get used to what they mean, and might even click on one occasionally.
12:15:22 <jmcarthur> segfault is bad
12:15:27 <EvanR-work> yes
12:15:32 <EvanR-work> very bad, worse than in C
12:15:46 <roconnor> EvanR-work: unsafePerformSomething?
12:15:55 <EvanR-work> FFI something
12:16:39 <roconnor> btutt: you can still type unmached braces, but it is really hard.
12:17:25 <EvanR-work> im using hdbc mysql, and adns
12:17:28 <kmc> EvanR-work, gdb?
12:17:48 <thoughtpolice> EvanR-work: you may want to tell GHC HQ if you can get it to reproduce in any way. gdb can at least tell you if you crash somewhere in haskell land, or in C-land
12:17:58 <thoughtpolice> (i.e. if it's really GHC HQ's problem or not)
12:18:01 <xplat> okay, so  i understand how to make, but how does one make a dollar inside a circle?
12:18:11 <kmc> but you might crash in haskell-land due to corruption from bad use of FFI or bad C code
12:18:24 <EvanR-work> kmc: spurious when under 'heavy' load, i havent put it on the testbench yet...
12:18:31 <kmc> once any part of your program has corrupted memory, you can't infer much from where the later crash occurs
12:20:20 <EvanR-work> yeah
12:20:23 <EvanR-work> :(
12:20:35 <EvanR-work> smart=stay away from ffi libs
12:20:40 <lispy1> dcoutts: thanks for removing Parsec from the preferred-versions
12:20:44 <EvanR-work> but then haskell cant do much
12:21:05 <kmc> yeah
12:21:14 <kmc> then you have to add more compiler primitives instead
12:21:18 <kmc> which is even more error-prone
12:21:28 <dcoutts> lispy1: thanks for reminding me :-)
12:21:42 <thoughtpolice> obviously, we need to add compiler primitives making it easier to add compiler primitives.
12:22:08 <dcoutts> thoughtpolice: I already did that :-)
12:22:19 <dcoutts> (sort-of)
12:22:21 <kmc> foreign import prim?
12:22:24 <dcoutts> yes
12:22:32 <kmc> EvanR-work, i expect gdb will still be useful though
12:22:42 <dcoutts> so it only does out-of-line cmm primops for now
12:22:43 <kmc> if you're willing to spend some time puzzling out what the haskell code is doing
12:22:50 <kmc> there are some tricks for that
12:22:56 <lpsmith> Isn't there a maxInt constant somewhere in the standard libraries?
12:22:59 <thoughtpolice> dcoutts: foreign prim is a nice addition, i was thinking of trying to maybe bind another integer library to something like openssl.
12:23:03 <kmc> hmm i wonder what happens if you run valgrind on ghc-compiled code
12:23:04 <monochrom> "yo dawg ... compiler primitives ... moar compiler primitives ..."
12:23:12 <kmc> lpsmith, maxBound :: Int ?
12:23:19 <thoughtpolice> maxBound :: Int
12:23:24 <lpsmith> thanks :)
12:23:33 <roconnor> @hoogle Re
12:23:33 <lambdabot> Data.Graph reachable :: Graph -> Vertex -> [Vertex]
12:23:33 <lambdabot> Data.Graph.Inductive.Query.DFS reachable :: Graph gr => Node -> gr a b -> [Node]
12:23:33 <lambdabot> module Text.Read
12:23:45 <roconnor> @hoogle Imaginary
12:23:45 <lambdabot> No results found
12:23:47 <thoughtpolice> dcoutts: there doesn't seem to be much documentation on them though, IIRC. although that seems like a rather rare feature to need
12:23:50 <roconnor> @hoogle Im
12:23:50 <lambdabot> Text.Html image :: Html
12:23:50 <lambdabot> Text.XHtml.Frameset image :: Html
12:23:50 <lambdabot> Text.XHtml.Strict image :: Html
12:23:56 <roconnor> :(
12:24:10 <EvanR-work> kmc: i would like to know development techniques to diagnose situations like this, if im supposed to be using haskell for production software dev
12:24:27 <dcoutts> thoughtpolice: yeah, it's really more for ghc-specific implementations of core libraries
12:24:33 <EvanR-work> i was able to fix one bug with hdbc mysql by looking at its ffi code
12:24:43 <EvanR-work> but it was just guess work
12:25:03 <dcoutts> thoughtpolice: there's some docs on adding new primops, and the out-of-line case is the one that foreign import prim covers
12:25:25 <thoughtpolice> dcoutts: yeah, i've been reading the commentary to try and bone up on my Cmm
12:25:36 * thoughtpolice needs a new computer before he can do any more hacking with GHC, though...
12:34:09 <devinus> dons: where can i submit bug reports about the haskell platform?
12:34:22 <adnap> could you use something similar to length-typed vectors to define dimension-typed objects in geometry, like a hypersphere?
12:35:24 <Jafet> Yes, but once you succeed your users will ask for Hausdorff dimension
12:36:34 <copumpkin> data Z
12:36:37 <copumpkin> data S n
12:36:45 <copumpkin> data L (f :: * -> *)
12:36:49 <mzero> devinus: the haskell platform mailing list is haskell-platform@projects.haskell.org
12:36:50 <copumpkin> countable ordinals
12:37:19 <kmc> how's that work?
12:37:39 <jmcarthur> "Impredicative polymorphism no longer deprecated."   huh!
12:37:54 <mzero> or you can report a bug directly into the trac: http://trac.haskell.org/haskell-platform/newticket?summary=%3CProblem%3E&description=%3CDescribe%20the%20problem%3E&component=Platform
12:38:19 <xplat> copumpkin: that's the 'ordinal notation' form, right?
12:39:58 <btutt> it was briefly deprecated 'cause the implementation had serious issues or something, IIRC (just in the 7.0.x series maybe?)
12:40:07 <roconnor> copumpkin: you have to mod out by an equivalence relation to get ordinals from that representation.
12:40:10 <xplat> where the decision problem of whether your object represents a valid ordinal is so undecidable it makes the halting problem look like a first-grade homework problem?
12:40:58 <roconnor> xplat: oh, it is not arithemetically definable?
12:41:29 <kmc> i bet they undeprecated impredicative polymorphism after rewriting the typechecker
12:41:39 <xplat> roconnor: valid ordinal notations are a complete set for the hyperarithmetic hierarchy
12:42:37 <c_wraith> would undeprecated reduce to precated?  because precating impredicative types results in strings of letters that look like gibberish
12:42:44 <roconnor> xplat: hey, wanna help me prove that set theory is inconsistent?
12:43:01 <xplat> roconnor: which one?
12:43:06 <roconnor> xplat: Z
12:43:31 <roconnor> but I'd be happy with ZF
12:46:15 <xplat> so not Z with unbounded separation, then ...
12:46:32 <EvanR-work> second time today it segfaulted, ok so somethings really wrong
12:46:34 <EvanR-work> gdb...
12:46:44 <Feuerbach> In which way were associated types inspired by object-oriented languages?
12:47:08 <roconnor> xplat: I think that has already been done.
12:47:38 <monochrom> not inspired
12:47:48 <monochrom> in other words, in no way.
12:48:02 <xplat> roconnor: well, yes
12:48:22 <roconnor> xplat: I want to strike at the power set axiom.
12:48:43 <EvanR-work> is there a switch for ghc to instrument the binary with stuff gdb can use
12:48:53 <xplat> monochrom: well, in a way they were partly inspired by C++, which is an OO language--but not by C++'s OO features ...
12:49:17 <ousado> C++ is not an OO language
12:49:17 <roconnor> xplat: wikipedia says that no theory containing the powerset of the natural numbers has had a proof theoritical ordinal described for it. ... I think there is a reason for this!
12:49:24 <EvanR-work> flameon
12:49:43 <monochrom> we just need to answer directly the original literal question.
12:49:50 <xplat> roconnor: hm.  ambitious, yet plausible ...
12:50:09 <Feuerbach> monochrom: SPJ et al. claim that they were, and I'm tempted to believe them. Sorry, nothing personal :)
12:50:27 <xplat> of course, if powerset doesn't work, then not even definable powerset works ...
12:50:37 <monochrom> then SPJ et al. shall answer the question
12:50:46 <btutt> EvanR-work: there's that -fvia-C option....
12:50:49 <copumpkin> roconnor: yeah, good luck doing that in the type system
12:50:52 <roconnor> xplat: I was told, totally by hearsay, that Jack Silver doesn't belive ZFC is consistent and thinks the powerset axiom might be problematic.  Before I couldn't understand why he would take issue with it, but now I think I understand what might be motivating him.
12:51:14 <btutt> but that's Cmm debugging...
12:51:27 <roconnor> xplat: indeed.
12:51:36 <roconnor> xplat: Agda doesn't have a proper powerset operation.
12:51:51 <roconnor> (though Coq does and is probably inconsistent too)
12:52:15 <EvanR-work> btutt: hmm
12:52:41 <btutt> Doing -auto-all, and -caf-all might or might not help....
12:54:51 <btutt> roconnor: Is the powerset axiom part of Coqs underlying theorem prover bedrock?
12:56:19 <roconnor> btutt: In Coq the powerset propery follows from the impredicativity of Prop (to tie this back with #haskell).  I think it would be easy to remove that impredicativity and I suspect few Coq developments would break.
12:56:50 <btutt> well thats good at least
12:57:21 <roconnor> I also think it would make Martin Lof very happy.
13:04:39 <Fuco> guys, it seems to me the first method is "reversed" withReader :: (r' -> r) -> Reader r a -> Reader r' a
13:04:43 <Fuco> shouldn't it be r -> r' ?
13:05:02 <Fuco> What I think it does is it takes the "state" of the reader and transforms it?
13:05:25 <Fuco> I have a Reader [String] IO () and I'd like to append to the list
13:05:36 <EvanR-work> er, isnt that a Writer
13:05:48 <roconnor> @hoogle local
13:05:48 <lambdabot> Control.Monad.Reader.Class local :: MonadReader r m => (r -> r) -> m a -> m a
13:05:48 <lambdabot> Trace.Hpc.Mix LocalBox :: [String] -> BoxLabel
13:05:48 <lambdabot> Data.Time.LocalTime localDay :: LocalTime -> Day
13:05:52 <sipa> Fuco: you have a reader, that reads from a sring
13:06:06 <sipa> if you want to turn it into a reader that reads from an int
13:06:19 <roconnor> Fuco: local (++foo)?
13:06:21 <sipa> i need to convert that int to a string, before passing it to the original reader
13:06:21 <byorgey> Fuco: well, yes, but think of it this way: by giving a function (r' -> r) you can specify how to run a Reader r a computation (which needs an r) within a Reader r' a (which actually has an r').
13:06:23 <xplat> a demonstration that the powerset axiom makes set theory inconsistent would be the biggest shakeup in set theory and FOM for the last 50 years at least
13:06:40 <byorgey> hence the (r' -> r) function is needed to convert what is actually there (r') to what is wanted (r).
13:06:51 <roconnor> xplat: see, now you are motivated.
13:07:03 <xplat> last thing that would seem to rival it is independence of choice, and even that ...
13:07:07 <Fuco> well, I'm doing the "roll your IRC bot" thing and there they use Reader not Writer ( http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot )
13:07:13 <Fuco> now pause for a moment so I can read all this stuff :D
13:07:14 <roconnor> xplat: ideally we could turn it in for 6 $1,000,000 prizes, but I think the Clay institute might not accept that :/
13:07:54 <EvanR-work> i figured local was like the haskell equivalent of goto
13:08:00 <Saizan> "hey, i proved NP=P in an inconsitent logic!"
13:08:13 <Saizan> not very convincing.
13:08:15 <roconnor> Saizan: give me $1,000,000
13:08:16 <xplat> roconnor: heh
13:08:37 <byorgey> Fuco: note that if you used withReader you would write    withReader transform someNewComputation    and within someNewComputation you would have access to the transformed state
13:09:42 <roconnor> EvanR-work: local is not nearly as bad as goto.  I think local is quite reasonable, though I'm not sure if I've used it.
13:10:16 <byorgey> yes, local is nice.
13:10:20 <xplat> (if i proved p=np, rather than p!=np, in a consistent logic, i would not bother to pick up the prize)
13:10:22 <EvanR-work> not that i can say definitively on the issue, but goto can be considered reasonable ;)
13:10:40 * hackagebot cryptocipher 0.2.6 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.6 (VincentHanquez)
13:10:42 <xplat> (at least if it was a constructive proof ...)
13:11:20 <robertosucks> Why # [3,2,1] > [2,1,0]  return True  ? 
13:11:48 <roconnor> because 3 is bigger than 2
13:11:49 <DevHC> lists are compares lexicographically
13:11:53 <DevHC> -s+d
13:12:15 <robertosucks> lexicographically?
13:12:20 <Saizan> yep
13:12:28 <jmcarthur> interesting i just had somebody ask me the exact same question last night. this must be an example in learn you a haskell
13:12:34 <Saizan> > [a,b,c] > [d,e,f]
13:12:35 <lambdabot>   False
13:12:43 <robertosucks> jmcarthur, yes it is
13:12:50 <DevHC> the first element is checked. if they are the same, then the second one is checked. the first different element determines the ordering
13:13:00 <roconnor> @src [] compare
13:13:00 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:13:03 <hpc> robertosucks: lexicographical == how words are ordered in a dictionary
13:13:05 <roconnor> @src compare []
13:13:05 <lambdabot> Source not found. I feel much better now.
13:13:11 <roconnor> I hate you @src!!
13:13:15 <robertosucks> Thanks
13:13:45 <DevHC> @hoogle (a -> a -> Bool) -> (a -> a -> Ordering)
13:13:45 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:13:45 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:13:45 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:14:32 <DevHC> is there a function which can convert (<), (<=), or such, to functions of type (a -> a -> Ordering)?
13:14:37 <roconnor> DevHC: and [] is less than non-[]
13:14:50 <roconnor> DevHC: you also need an Eq constraint
13:15:02 <DevHC> @hoogle Eq a => (a -> a -> Bool) -> (a -> a -> Ordering)
13:15:03 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:15:03 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:15:03 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:15:03 <roconnor> DevHC: er, maybe not
13:15:42 <Jafet> ordFromLT (<) a b = if a < b then LT else if b < a then GT else EQ
13:15:52 <DevHC> yawn
13:15:56 <roconnor> \f a b -> if f a b = f b a then EQ else if f a b then LT else GT
13:16:00 <Jafet> ordFromGT (>) = flip (ordFromLT (>))
13:16:04 <roconnor> oh
13:16:31 <roconnor> Jafet: mine works on both <= and < :D
13:16:40 <Jafet> I applaud roconnor for putting equality first
13:16:59 <roconnor> Jafet: yours is faster for your specialized case.
13:17:06 <monochrom> interesting
13:17:18 * roconnor wishes for CSE
13:17:53 <Jafet> No, there is no place for CSE.
13:17:58 <roconnor> :(
13:18:00 <DevHC> @where CSE
13:18:00 <lambdabot> http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
13:19:12 <DevHC> aha! i've persumably found my leak!
13:19:15 <Jafet> Besides, it also gets in the way of unboxing
13:19:37 <roconnor> DevHC: did you do a CSE?
13:19:51 <DevHC> http://www.youtube.com/watch?v=ssTZ6czMaiM
13:19:52 <roconnor> apparently they can cause space leaks. >:(
13:19:58 <DevHC> roconnor: no, i did not
13:20:26 <monochrom> I am glad I use flash block.
13:20:35 <DevHC> :D
13:20:56 <DevHC> i'm sad i don't have a working flash player atm :<
13:21:10 <Jafet> I removed flash player.
13:21:19 <hpc> noscript :D
13:21:22 <DevHC> how did it exist in the first place?
13:21:34 <hpc> DevHC: have i got the link for you...
13:21:38 * hpc searches for it
13:22:06 <hpc> http://forums.xkcd.com/viewtopic.php?p=392196#p392196 <-- DevHC
13:24:21 <mzero> funny post, but historically inaccurate: Flash is not a descendant of Shockwave
13:24:39 <mzero> and the order of extensions is completely wrong
13:25:09 <hpc> huh, didn't know the first
13:25:29 <hpc> knew the second, but order doesn't matter in this case
13:25:31 <DevHC> ROFL
13:28:44 <hpc> oh, it COMPETED with shockwave
13:29:01 <hpc> er
13:29:14 <hpc> developed based on a product that competed with shockwave
13:30:23 <sgronblo> Is there some clever way in haskell to call a high level function without having to pass in a bunch of values that might be needed by lower level functions. I maybe be doing this competely wrong, I'm taking a sort of pythonic approach.
13:30:25 <mzero> exactly
13:30:54 <EvanR-work> the -xc RTS option isnt giving much of a 'stack trace'....
13:31:01 <kmc> sgronblo, pass around a single data type holding all those values?
13:31:12 <hpc> currying?
13:31:27 <kmc> if the low-level functions need those values, and the high-level function doesn't have them,  where do they come from?
13:31:29 <EvanR-work> pass around f a b c
13:31:30 <hpc> lowFoo :: A -> B -> C; highFoo = lowFoo magicConstant
13:31:36 <EvanR-work> ya
13:31:53 <hpc> highFoo :: B -> C
13:32:34 <DevHC> sgronblo, i assume u want to avoid functions of ~1000 arity. how about using structures?
13:33:06 <sgronblo> hmm, thanks for the suggestions, I'll see if I can make something out of it
13:33:21 <monochrom> the pythonic approach as the over-arching approach for your program is a recipe for forcing you to pass around too many data. re-modularize.
13:34:24 <EvanR-work> uhm whats the 'pythonic approach' ?
13:34:26 <monochrom> use Jackson Structured Design for your program
13:35:11 <sgronblo> well you don't have to pass around too many data, because you can define your data structures that need to be used by multiple functions in module scope or make them part of a class
13:35:27 <sgronblo> i have no idea what jackson structured design is...
13:35:39 <EvanR-work> sgronblo: was that an explanation of pythonic?
13:36:16 <EvanR-work> you can do that in haskell, you just cant change the data in those 'module scope' areas
13:37:21 <kmc> you can also "make them part of a class" except s/class/data type/
13:37:33 <sgronblo> EvanR-work: yeah i know the term was vague
13:38:43 <kanakola> Hi, GHC is complaining about this signature "showMaybe :: (Show a) => Maybe a -> String" and I'm not sure why. It claims that the "a" in constraint Show is ambiguous. But I don't understand how/why. 
13:39:15 <sipa> can you paste the full code?
13:39:22 <kmc> data in a class instance in Python is accessed through an ordinary function argument (usually named "self")
13:39:24 <c_wraith> kanakola: it's not complaining about that line, it's complaining about where you call the function
13:39:35 <kmc> and you can do the same in Haskell
13:39:39 <hpc> kanakola: imagine you are trying to show a number, 5
13:39:41 <hpc> > 5 :: Int
13:39:42 <lambdabot>   5
13:39:44 <hpc> > 5 :: Float
13:39:44 <lambdabot>   5.0
13:39:47 <hpc> > 5 :: Rational
13:39:47 <lambdabot>   5 % 1
13:39:54 <hpc> kanakola: which of those does it choose?
13:40:08 <hpc> kanakola: that's what it complains about, wherever you are calling that function
13:40:12 <kmc> the "instance methods" obj.f in Python are ordinary functions partially-applied to that one argument
13:40:56 <kmc> yep, an object is a dict of first-class partially-applied functions, tell that to the next person who claims OOP and FP are mortal enemies
13:41:03 <kanakola> hpc: I see. Right now i've only defined showMaybe Nothing = Nothing  and showMaybe (Just x) = show x, so I guess the 2nd definition is the problem. 
13:41:10 <kanakola> hpc: Is there a way to do what I"m trying to do?
13:41:28 <hpc> kanakola: it isn't the definition; it is where you call it
13:41:45 <hpc> kanakola: showMaybe (Just True) will work fine
13:41:50 <hpc> because True is definitely a Bool
13:41:52 <EvanR-work> kmc: mutable vs immutable are mortal enemies ;)
13:42:06 <Rusky> anyone know how to parse multiple postfix operators with parsec?
13:42:11 <hpc> the error gives you a line number where the problematic call is
13:42:46 <c_wraith> kanakola: also that definition is certainly not your real definition, as it doesn't compile
13:42:53 <kmc> EvanR-work, i suppose "mutable data" is one of the like nine unrelated things lumped in under the banner "object-oriented programming"
13:43:02 <EvanR-work> kmc: yes
13:43:16 <EvanR-work> often implicitly
13:43:18 <kanakola> hpc: the line it was showing was the definition line, and even x = showMaybe (Just True) fails.
13:43:29 <kmc> but you can get the benefits of other aspects of OOP without mutation
13:43:29 <kanakola> c_wraith: How do i make it compile?
13:43:45 <kmc> and a lot of guides on OOP will tell you to avoid mutation where possible
13:43:50 <EvanR-work> really?
13:43:59 <EvanR-work> thats got to be a vast minority
13:43:59 <kmc> and some OOP languages support restricting mutation
13:44:03 <hpc> kanakola: showMaybe returns a String, yes?
13:44:07 <c_wraith> kanakola: the definition you pasted has different return types in the two cases.  The first case does not match what your signature promised
13:44:14 <Rusky> parsec doesn't let you use multiple postfix operators of the same precedence
13:44:15 <hpc> kanakola: so showMaybe Nothing should return a string
13:44:18 <hpc> Nothing is not a string
13:44:20 <DevHC> sgronblo, consider, if u haven't yet: http://pastebin.com/8mVrgPm5
13:44:21 <Rusky> and multiple precedences only allow one order
13:44:34 <kanakola> hpc: sorry I meant to type show Nothing instead of just Nothing
13:44:46 <hpc> kanakola: ah
13:44:46 <kmc> d = new Date(); d.setYear(2010); d.setMonth(1); d.setDay(31);
13:44:56 <hpc> :t show Nothing
13:44:57 <lambdabot> String
13:45:03 <kmc> plenty of people rage against that kind of nonsense
13:45:08 <kmc> even though it's still quite common
13:45:58 <EvanR-work> ya
13:45:59 <hpc> kmc: on the one hand though, it could be better than having oodles of constructors
13:46:15 <hpc> forcing developers to figure out which is which
13:46:17 <monochrom> because people enjoy 3 extra lines of code to claim productivity
13:46:49 <hpaste> kanakola pasted "showMaybe"  http://hpaste.org/44705
13:47:11 <kanakola> c_wraith, hpc: I've pasted the code and the error. could you please take a look?
13:47:28 <hpc> in the future, kanakola, mind mentioning that it is homework?
13:47:42 <robertosucks> [ [ x | x <- xs, even x ] | xs <- xxs]  Can someone explain me that list comprehension?
13:47:45 <kanakola> hpc: It's not a homework. I'm self-studying.
13:47:46 <hpc> it won't stop us from helping, but it will make us give more educational answers
13:47:50 <hpc> ah
13:47:52 <c_wraith> kanakola: I assure you, the code you have pasted is not the problem.  You know how I can tell?  The error message refers to line 240
13:47:54 <kanakola> hpc: sorry. i should've mentioned that i'm a beginner at this
13:47:57 <kmc> hpc, then:  d = Date( DateSpec().withYear(2010).withMonth(1) );
13:47:59 <kmc> no mutation
13:48:12 <aristid> robertosucks: it's map (filter even), i think
13:48:16 <aristid> :t map (filter even)
13:48:17 <lambdabot> forall a. (Integral a) => [[a]] -> [[a]]
13:48:19 <kanakola> c_wraith: line 240 is the showMaybe Nothing = show Nothing line. I didn't want to paste the entire document
13:48:19 <hpc> kmc: enterprise!
13:48:21 <hpc> :P
13:48:29 <aristid> :t \xxs -> [ [ x | x <- xs, even x ] | xs <- xxs]
13:48:30 <kmc> a little bit yeah
13:48:30 <lambdabot> forall t. (Integral t) => [[t]] -> [[t]]
13:48:31 <kmc> but, no mutation
13:48:44 <kmc> in either class
13:48:54 <aristid> the python people are stupid for focussing on list comprehensions so much
13:48:55 <hpc> compile error confirmed, here
13:49:04 <c_wraith> kanakola: the problem is on the line *calling* that code, almost certainly.
13:49:12 <aristid> but guido thinks list comprehensions are better than combinators, i guess
13:49:21 <monochrom> "show Nothing" could be ambiguous type-wise. why don't you just hard-code it to the string "Nothing"?
13:49:31 <c_wraith> Oh, I guess that's true.
13:49:35 <aristid> > show Nothing
13:49:36 <c_wraith> show Nothing is ambiguous
13:49:36 <lambdabot>   "Nothing"
13:49:46 <aristid> c_wraith: it will default to Maybe ()
13:49:58 <roelvandijk> kanakola: Try showMaybe (Nothing :: Maybe ())
13:49:59 <monochrom> don't trust lambdabot
13:50:02 <kanakola> monochrom: that fixes the problem, 
13:50:03 <c_wraith> aristid: even in compiled code?
13:50:05 <rly> kanakola: showM (Just x) = show x; showM y = show y
13:50:17 <aristid> c_wraith: yes? unless you disabled defaulting
13:50:21 <hpc> kanakola: http://hpaste.org/44706/fixed
13:50:25 <kmc> aristid, Python's syntax really isn't set up to use points-free combinators effectively
13:50:30 <hpc> show Nothing always == "Nothing"
13:50:37 <kmc> list comprehensions are a more limited special case but they're a better fit
13:50:45 <hpc> it's some bullshit to do with Nothing being polymorphic, i suppose
13:50:59 <rly> hpc: my solution doesn't have such a problem.
13:51:07 <rly> No type annotations needed. 
13:51:10 <raichoo> alios: I see what you did there ;)
13:51:16 <hpc> rly: ah
13:51:29 <alios> raichoo: ;)
13:51:44 <hpc> you tricksy hobbitses with your reordering of patterns
13:52:11 <jamwt> hey guys, is there a library function somewhere that does `foldl' (.) id`
13:52:12 <kanakola> hpc: I'm a little confused because :t (show Nothing) is String right? but why didn't that work?
13:52:21 <jamwt> (chains a list of compositions)
13:52:32 <hpc> > show Nothing
13:52:33 <lambdabot>   "Nothing"
13:52:44 <monochrom> "main = print Nothing" is a type error for ghc.
13:52:50 <kmc> jamwt, why foldl' not foldr? (.) is associative
13:52:53 <roelvandijk> kanakola: Because the compiler needs to now the type of the 'a' in 'Maybe a' which is the type of 
13:52:58 <jamwt> or foldr
13:52:59 <jamwt> sorry
13:53:00 <roelvandijk> kanakola: 'Nothing'
13:53:01 <jamwt> that's what it really is
13:53:04 <hpc> > let x = show Nothing in x ++ "test"
13:53:04 <Jafet> :t let n = Nothing in (n, show n)
13:53:05 <lambdabot> forall a. (Maybe a, String)
13:53:05 <lambdabot>   "Nothingtest"
13:53:08 <aristid> kmc: i think list comprehensions often obscure the meaning of the expression. but admittedly python isn't as well-equipped for this task as haskell, but AFAIK guido actively hinders efforts to make it better-equipped
13:53:12 <kmc> :t appEndo . mconcat . map Endo
13:53:13 <lambdabot> forall a. [a -> a] -> a -> a
13:53:14 <rly> Is anyone using Haskell professionally here?
13:53:15 <monochrom> that is, echo "main = print Nothing" > e.hs  then  ghc --make e.hs
13:53:20 <kmc> jamwt, ^^^^
13:53:23 <kmc> Data.Monoid
13:53:27 <aristid> @src Endo
13:53:28 <lambdabot> Source not found. Just try something else.
13:53:28 <hpc> appendo!
13:53:45 <kmc> newtype Endo a = Endo { appEndo :: a -> a }
13:53:59 <hpc> endo == endofunctor
13:54:07 <kmc> endofunction or endomorphism
13:54:27 <roelvandijk> kanakola: show is a method of the Show type class, so when you use it the compiler needs to know precisely which version of show you need
13:54:36 <rly> Is an endofunctor A x -> A x? 
13:54:42 <accel> gitit
13:54:44 <accel> is it awesome?
13:54:51 <accel> it's written in haskell
13:54:53 <accel> and uses latex
13:54:54 <accel> and git
13:54:57 <jamwt> accel: it's pretty good
13:55:00 <accel> it's like my 3 favorite things
13:55:02 <rly> accel: you are an awesome troll.
13:55:07 <hpc> rly: functor in the categorical sense
13:55:09 <kmc> rly, a functor maps types to types *and* functions to functions
13:55:11 <kanakola> roelvandijk: So you're saying since Nothing is a part of any type, "showMaybe Nothing" is still ambiguous? because the Nothing could be of any Maybe type right? like it could be a nothing from Maybe Int or it could be a nothing from Maybe Char. And that's where the ambiguity comes from?
13:55:17 <aristid> :t let endo = undefined; appEndo = undefined; x :: [a -> a] -> a -> a; x = appEndo . mconcat . map endo in (endo, appEndo)
13:55:18 <lambdabot>     Ambiguous type variable `a' in the constraint:
13:55:18 <lambdabot>       `Monoid a' arising from a use of `mconcat' at <interactive>:1:82-88
13:55:18 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
13:55:34 <hpc> :t undefined undefined
13:55:35 <lambdabot> forall t. t
13:55:38 <hpc> :t fix undefined
13:55:38 <roelvandijk> kanakola: exactly right!
13:55:39 <lambdabot> forall a. a
13:55:51 <accel> rly: ?
13:55:55 <kmc> rly, so a Haskell endofunctor would be a pair of a type and a function, like: (F :: *  *, fmap :: (a  b)  F a  F b)
13:56:24 <kmc> rly, but we usually identify that pair with the type constructor F itself, presuming there's an "instance Functor F"
13:56:34 <hpc> kmc: you mean a -: a -: ...?
13:56:49 <kmc> Prelude.Functor is the type class of endofunctors on the category Hask
13:56:53 <hpc> er, ->
13:56:59 <hpc> hard to read your fancy arrows in this font
13:57:04 <kmc> not a class of more general functors
13:57:06 <kmc> yeah
13:57:08 <kmc>   ->
13:57:27 <rly> kmc: the category consisting of all  values such that F x exists?
13:57:30 <hpc> it shows only the leftmost pixels of the arrow head
13:57:35 <hpc> so it looks like -:
13:57:36 <kanakola> thank you guys so much for your help :) :)
13:57:49 <rly> accel: use less enters.
13:57:49 <kmc> rly, categories aren't about values
13:57:54 <kmc> or you have to explain what you mean by that
13:58:03 <accel> so using enters = troll?
13:58:04 <rly> kmc: whatever is in a category.
13:58:17 <rly> kmc: objects*
13:58:21 <monochrom> that is the standard non-fancy arrow. fancy arrow would be  or  or  or 
13:58:29 <kmc> categories have "objects" (i.e types) and morphisms
13:58:42 <Jafet> It's not trolling until IO String is involved
13:59:01 <monochrom> How do I extract the IO out of IO String?
13:59:08 <ddarius> :t const "foo" :: IO String -> String
13:59:09 <lambdabot> IO String -> String
13:59:13 <rly> How do I reverse the IO?
13:59:18 <hpc> > let tro = "tro" ++ fix ("lo"++)
13:59:18 <lambdabot>   not an expression: `let tro = "tro" ++ fix ("lo"++)'
13:59:23 <hpc> > let tro = "tro" ++ fix ("lo"++) in tro
13:59:23 <copumpkin> @remember monochrom How do I extract the IO out of IO String?
13:59:23 <lambdabot> Good to know.
13:59:23 <accel> with the undo monad
13:59:24 <Twey> monochrom: Haha
13:59:24 <lambdabot>   "trolololololololololololololololololololololololololololololololololololol...
13:59:32 <rly> How do I write webscale application in Haskell?
13:59:40 <weirdo> how is "deriving" in a "data" declaration different from "instance"?
13:59:42 <Twey> With Snap
13:59:48 <rly> Why doesn't Oracale use Java? 
13:59:50 <Twey> And NoSQL!
13:59:51 <kmc> weirdo, "deriving" writes the instance for you
14:00:00 <hpc> weirdo: "deriving" lets GHC do magic stuff to make the instance for you
14:00:03 <monochrom> Oracale is comercialized cale
14:00:09 <kmc> and thus it only works on certain classes for which the compiler has a special rule
14:00:16 <kmc> (enumerated in the Haskell Report, and GHC supports a few more)
14:00:21 <weirdo> thank you
14:00:30 <hpc> there's extensions that you can turn on to make deriving do cooler stuff
14:00:39 <rly> Twey: you can say that, but which big system have you build with it?
14:00:58 <kanakola> this is probably a stupid question, but is there a way to define a new type that is a subset of an existing type? For example, I want to define "Bit" as Ints that are just 0 or 1. I know I can do a datatype declaration data Bit = Zero | One or something like that, but is there a way to say that it's Int, but can only take on these two values?
14:01:10 <Twey> rly: It's a little-known fact that I was actually the one who built Google, using Haskell and Snap technology from the future.
14:01:14 <kmc> nobody's made a big website in Haskell, therefore it is impossible
14:01:24 <rly> kmc: that's the spirit.
14:01:26 <kmc> kanakola, not really
14:01:29 <Twey> @faq Can Haskell enable me to travel back in time to create Google?
14:01:29 <lambdabot> The answer is: Yes! Haskell can do that.
14:01:43 <hpc> kanakola: no, but there's trickier ways
14:01:46 <kmc> kanakola, oh, but you can write "instance Num Bit"
14:01:50 <rly> I am sure one could do it with Haskell, and in fact, existing libraries would probably be irrelevant.
14:01:52 <kmc> which then lets you use the literals 0 and 1
14:01:57 <kmc> numeric literals are overloaded
14:01:58 <kmc> > 1 :: Int
14:02:00 <lambdabot>   1
14:02:01 <hpc> instance Num Bit where fromIntegral 0 = Zero; fromIntegral 1 = One; ...
14:02:02 <kmc> > 1 :: Float
14:02:03 <lambdabot>   1.0
14:02:11 * hpc doesn't endorse the Num method
14:02:20 <hpc> you can also write f :: Bit -> Int
14:02:24 <rly> I doubt Google uses much stuff from outside of Google which hasn't been developed by at least 20 people.
14:02:25 <Jafet> > 1 :: (Num a) => a -> a
14:02:26 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:02:26 <lambdabot>    arising from a use of `...
14:02:43 <hpc> which will give you guarantees that the int that comes out will only be 0 or 1
14:03:09 <hpc> rly: and probably not much stuff from inside, too
14:03:21 <rly> hpc: yeah, I suppose.
14:03:37 <rly> It's just that "open-source" generally is open sores ;)
14:03:48 <kanakola> hpc, kmc, Jafet: thank you. I guess I'll stick to a new data type that with functions to change them into Int
14:03:49 <Heffalump> o rly?
14:03:57 <kmc> kanakola, you can also use "deriving (Enum)"
14:03:59 <rly> Heffalump: yeah, rly.
14:04:05 <kmc> and then fromEnum :: Bit -> Int
14:04:18 <kanakola> kmc: that's pretty sneaky :)
14:04:18 <hpc> lol, totally forgot about Enum
14:04:23 <Heffalump> no, you're rly. I'm Heffalump.
14:04:26 <hpc> while you are at it, derive Ord and Eq
14:04:39 <monochrom> o Heffalump
14:04:43 <hpc> Ord, Eq, Enum are a pretty awesome trio of type classes
14:05:00 <rly> o Heffalump, have you descended from the skies to say o, to Me, the rly. 
14:05:05 <hpc> oh, and Bounded
14:05:23 <Heffalump> no, I came up from the depths
14:05:29 <Heffalump> of a Heffalump trap
14:05:39 <hpc> he waits behind the wall
14:05:40 <hpc> ZALGO
14:05:44 <hpc> :P
14:05:46 <monochrom> I came from a 1970s monitor
14:05:49 <rly> Usually that's called a basement.
14:06:05 <rly> monochrom: spare me what you do at night.
14:08:17 <kanakola> conceptually, if a class is bounded, it should also be ordered, right? 
14:09:04 <monochrom> yes for things laypeople can manage to imagine
14:09:12 <kmc> 0 days since using zorn's lemma
14:09:46 <rly> Imagining things.. is that built in to Vista?
14:10:05 <rly> That was the best I could do, troll wise.
14:10:59 <kmc> accel, clearly gitit would be better if it used darcs, because darcs is also written in haskell
14:11:10 <accel> no
14:11:13 <accel> darcs sucks
14:11:14 <accel> git rocks
14:11:27 <accel> there's only one piece of decent haskell software
14:11:29 <accel> it's called ghc
14:11:36 <sm> gitit does use darcs
14:11:41 <sm> what is this git you speak of
14:11:46 <monochrom> git uses darcs
14:11:58 <monochrom> darcs uses cvs
14:12:58 <kmc> accel, you call ghc decent? it doesn't even support dependent types
14:12:59 <rly> accel: why is GHC decent?
14:13:02 <Twey> gitit does use darcs
14:13:08 <sm> accel you are mistaken sir! I use plenty of fine haskell software
14:13:14 <Twey> And I'm partial to XMonad :
14:13:16 <rly> sm: oh, rly?
14:13:41 <kmc> accel, plus GHC fails to support restful cloud technologies like AJAX and Rails
14:13:47 <kmc> so it's really quite shite you see
14:14:04 <rly> GHC is developed by an evil empire.
14:14:18 <rly> It places backdoors and shit, you know.
14:14:27 <kmc> rly, no, you missed the memo.  Apple is the new evil empire
14:14:30 <rly> GHC comes all brownish out of the box.
14:14:40 <kmc> Microsoft are now the washed-up has-beens we can feel sorry for
14:14:43 <JimmyRcom> ghc is useless, I mean, it doesn't even support twitter
14:14:55 <shachaf> kmc is telling the truth.
14:14:58 <kmc> ghc -XTwitter -ddump-tweets
14:15:04 <rly> GHC on rails! They don't even have rails in Glasgow.
14:15:27 <kmc> rly, they have the third-oldest underground metro in the world
14:15:28 <DevHC> rly: ur mutherboard, processor, network card, videocard, power supply, and cooling fan r backdoored.
14:15:34 <shachaf> You can't be properly evil without being powerful.
14:15:39 <kmc> my cooling fan is backdoored by THE CHINESE
14:15:40 <kmc> (scary music)
14:15:49 <monochrom> @remember kmc ghc -XTwitter -ddump-tweets
14:15:49 <lambdabot> Done.
14:16:00 <DevHC> rly: did i mention that ur cables r backdoored too?
14:16:06 <rly> DevHC: I know! The government does that to protect me!
14:16:07 <kmc> shachaf, every tinpot dictator would disagree with you
14:16:30 <thoughtpolice> kmc: GHC isn't webscale like java, therefore it is a failure
14:16:39 <rly> DevHC: there is a cable coming out of your ass right there.
14:16:50 <kmc> thoughtpolice, you mean Oracle Java, prepare to be sued
14:17:20 <monochrom> you should compare like with like, such as GHC with javac
14:17:25 <thoughtpolice> but i don't have 10 million dollars!
14:17:37 <Twey> kmc: You mean Oracle Java, prepare to be sued
14:17:38 <kmc> i enhanced the image using Adobe Photoshop image enhancement software
14:17:40 <DevHC> rly: chineez ppl don't make backdoored cooling fans with public keypairs owned by ur government
14:17:47 <thoughtpolice> er, sorry, that's the cost of support contracts. i don't have 50 million dollars is what i meant
14:17:48 <kmc> Twey, they trademarked the registered-trademark symbol?!?
14:17:50 <kmc> *brilliant*
14:17:56 <Twey> I thought so
14:18:03 <Twey> But actually, it's a patent
14:18:12 <Twey> They'll grant patents on anything these days
14:18:29 <kmc> does anyone have a business-process patent on the business process of creating meaningless business-process patents?
14:18:30 <Twey> IIRC someone actually got a patent on their patent-filing process
14:18:38 <kmc> :D
14:18:40 <Twey> Haha
14:19:01 <thoughtpolice> didn't alan cox do that or something? i seem to remember some very strange meta-patent held by someone pretty well known in the linux community
14:19:36 <rly> Has anyone read Advanced Types And Programming Languages? 
14:19:40 <Twey> Yes, here we are, it was IBM: http://yro.slashdot.org/story/07/10/20/1031236/IBM-Seeking-Patent-Protection-Racket-Patent
14:19:50 <thoughtpolice> naturally an example of the absurdity of software patents, but it was pretty funny it hought
14:20:08 <rly> Is there anyone who thought the book was any good? 
14:20:12 <DevHC> http://www.patentstorm.us/patents/7028023.html
14:20:15 <Twey> Not exactly a patent-filing process, but
14:20:26 <Twey> DevHC: Haha!
14:20:28 <thoughtpolice> rly: i've read some of it, i liked it. i only selectively read like one or two chapters though
14:20:32 <rly> I read a few chapters, but you cannot read a page without seeing a spelling error. 
14:20:32 <thoughtpolice> since they're fairly disconnected
14:20:36 <Twey> Oh crap, Haskell infringes patents!
14:20:45 <rly> The QA on that book is really terrible.
14:20:48 <monochrom> I think everyone here thinks the book is good. But you have to be interested in type systems to find it worthwhile.
14:21:03 <rly> I don't think anyone has ever proofread it.
14:21:17 <rly> If there has been an 'editor', he/she should be fired immediately.
14:21:37 <rly> I think it is a ripoff :)
14:21:51 <DevHC> the only thing being infringed in the rights of the people, by the patent office
14:22:00 <DevHC> is the rights*
14:22:08 <rly> DevHC: people have no rights; guns have rights.
14:22:16 <DevHC> i have rights
14:22:23 <xplat> @ty ala Endo $ mconcat .: map
14:22:23 <rly> DevHC: do you have a gun?
14:22:23 <lambdabot> forall a. [a -> a] -> a -> a
14:22:25 <DevHC> (yes, i'm not a person, nwhahaha)
14:22:40 <DevHC> chuck norris doesn't need a ...
14:22:57 <rly> DevHC: Ab Plus Pro?
14:23:01 <rly> DevHC: yes, he does!
14:23:15 <rly> He has been using it for years.
14:23:43 <DevHC> o rly
14:36:55 <xplat> i look away from #haskell for an hour and look back at #whoselambdaisitanyway
14:37:00 <hpaste> kanakola pasted "better way to write this?"  http://hpaste.org/44707
14:38:51 <kanakola> I'm trying to write a function using list comprehensions that would convert [Just 4, Nothing, Just 3] into [4,3]. Is there a better way to do that than what i'm doing?
14:39:09 <aristid> :t catMaybes
14:39:10 <lambdabot> forall a. [Maybe a] -> [a]
14:39:11 <napping> pattern matching?
14:39:13 <shachaf> > catMaybes [Just 4, Nothing, Just 3]
14:39:14 <lambdabot>   [4,3]
14:39:16 <shachaf> @src catMaybes
14:39:16 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:39:18 <aristid> kanakola: just use the existing function :)
14:39:39 <napping> the | Just a <- ..] bit already skips over things that don't match
14:39:49 <napping> > [a | Just a <- [Nothing, Nothing]]
14:39:50 <lambdabot>   []
14:39:57 <napping> see, no exception
14:40:06 <aristid> :t concatMap (\x -> case x of Just x -> [x]; Nothing -> [])
14:40:07 <lambdabot> forall t. [Maybe t] -> [t]
14:40:09 <kanakola> napping: i didn't know that'd work! :)
14:40:15 <kanakola> aristid: but that'd be cheating :)
14:40:26 <aristid> kanakola: why is using catMaybes cheating?
14:40:37 <Jafet> > null $ do { Just a <- Nothing; return a; }
14:40:38 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
14:40:38 <lambdabot>         against inferred ...
14:40:41 <aristid> i hate it when you are supposed to solve problems in suboptimal ways
14:40:47 <Jafet> > null $ do { a <- Nothing; return a; }
14:40:48 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
14:40:48 <lambdabot>         against inferred ...
14:40:54 <kanakola> aristid: because the exercise was to write something like catMaybes using list comprehension :)
14:41:14 <rly> aristid: then you must hate solving every problem.
14:41:18 <Jafet> @undo [x | Just x <- ls]
14:41:18 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ls
14:41:34 <aristid> rly: i am very glad that i'm learning haskell on my own, without artificial limitations
14:42:07 <DevHC> lol what are "natural" limitations
14:42:16 <DevHC> (what are "artificial limitations, btw?)
14:42:21 <monochrom> good profs set meaningful limitations. bad profs set lame limitations.
14:42:23 <aristid> DevHC: for example my stupidity is a natural limitation :)
14:42:25 <jmcarthur> is that deserving of a "lol"?
14:42:47 <jmcarthur> oh i misread that
14:42:47 <aristid> DevHC: and an artificial limitation is when i am forced to solve a problem with list comprehensions because my university tells me to
14:43:06 <jmcarthur> i read that as "lol what are 'natural' transformations"
14:43:18 <rly> aristid: that is part of the jumping through a hoop type of education that is now popular.
14:43:19 <aristid> jmcarthur: lolol natural transformations!
14:43:38 <aristid> rly: and i am not subject to it. yay!
14:43:53 <monochrom> "assignment #1: write a function to determine whether a number is even or odd. you can only add 1, subtract 1, and compare with 0".
14:43:54 <kanakola> aristid: I'd definitely be using catMaybe if I came across a problem where I needed to do just that, but right now I'm trying to learn list comprehensions, so I have to limit myself
14:44:03 <DevHC> what r list comprehensions? :>
14:44:09 <aristid> kanakola: list comprehensions are trivial :)
14:44:12 <monochrom> that's an example of artificial limitation
14:44:17 <DevHC> lol
14:44:22 <rly> aristid: I am sure all universities suck to varying degrees. 
14:44:26 <kanakola> aristid: I wasn't smart enough to just realize that I could just do Just a <- xs :( 
14:44:34 <aristid> monochrom: and ill-specified
14:44:51 <monochrom> you just didn't know haskell enough
14:44:53 <aristid> monochrom: if you take the description literally, you cannot solve this at all
14:45:23 <aristid> rly: i am not learning haskell in a university. i am learning it on my own.
14:45:41 <c_wraith> aristid: then your university sucks even more, by its absence
14:45:43 <rly> aristid: yes, I can read :)
14:46:04 <aristid> c_wraith: my university exists, and teaches me other things.
14:46:06 <rly> University has value, for a few years. 
14:46:33 <rly> If you are a good student, the professors bore you to death towards the end. 
14:46:57 <DevHC> i like to say that i am a good student
14:47:04 <DevHC> and some courses r far from boring
14:47:11 <revenantphx> What are some good universities to look at if I'm considering a more theoretical CS track?
14:47:12 <kanakola> monochrom: your problem is actually quite interesting. When you say compare, you mean that I can get GT, LT, EQ out of it right (and not just True/False to is this equal to zero)?
14:47:20 <monochrom> no no, if you are a good students, the profs lure you to do projects towards the end, and work you to death.
14:47:25 <mjrosenb> revenantphx: i'd recommend cmu.
14:47:32 <revenantphx> mjrosenb: Yeah, it's my first choice haha.
14:47:38 <rly> It is the same with everything. A new topic is "cool" and "interesting", but after some years, it is all the same. 
14:47:39 <revenantphx> It's right down the street from me.
14:47:45 <monochrom> I suppose GT,LT,EQ is fair.
14:47:51 <mjrosenb> revenantphx: you a senior?
14:47:53 <revenantphx> Junior.
14:48:46 <rly> monochrom: you can solve it without GT, LT.
14:48:57 <DevHC> rly: so far functional programming has sustained being "cool" and "interesting" :]
14:49:01 <rly> monochrom: I think it is actually quite a good exercise that way ;)
14:49:10 <rly> DevHC: for you?
14:49:14 <DevHC> y
14:49:19 <kanakola> rly: I thought the problem was that if i give you a negative number, you need to know whether to sub1 or add1 to bring it to zero. 
14:49:25 <rly> DevHC: but you don't have years of experience?
14:49:39 <rly> kanakola: you don't need to know that. 
14:50:03 <DevHC> i first heard about fp ~1.5 years ago
14:50:17 <rly> It just would be a slightly more complicated problem, too hard for a newbie, but anyone with a brain should be able to figure it out. 
14:50:26 <DevHC> ~2.5*
14:50:34 <revenantphx> I think FP is more 'interesting' because there are so many tie-in topics.
14:50:46 <DevHC> tie-in?
14:50:49 <revenantphx> i'm sure you could spend years on parsing and compilers alone,
14:51:00 <kanakola> rly: Maybe you've got a better approach. I was thinking of bringing the number down (or up) to zero. At each step, I just negate the answer to the smaller or larger value.
14:51:00 <revenantphx> or looking at the related mathematics.
14:51:09 <rly> FP is programming for n00bs, if you don't use IORefs/STRefs, as far as I am concerned.
14:51:24 <monochrom> oh god, what depravity, there is indeed a way without knowing positive/negative.
14:51:41 <DevHC> unfortunately rly might be right here :/
14:51:44 <xplat> the odd-even problem is even more interesting if you can only compare with 0 for equality
14:51:58 * monochrom will assign this depraved homework next time!
14:52:01 <c_wraith> rly: how about MVars? :)
14:52:07 <rly> c_wraith: or those...
14:52:14 <DevHC> can i be considered non-noob if i've decided to use FFI for a project?
14:52:25 <rly> It took me about 3.5 seconds to figure out a solution for that problem. 
14:52:29 <monochrom> now how to prove it correct?
14:52:42 <rly> That is also pretty trivial.
14:52:56 <c_wraith> DevHC: depends.  Can you explain the difference between a safe and unsafe foreign import, which you should use, and why?
14:52:58 <rly> Not really worth writing down if it is that easy, is it?
14:53:09 * hackagebot omnicodec 0.5.0.1 - data encoding and decoding command line utilities  http://hackage.haskell.org/package/omnicodec-0.5.0.1 (MagnusTherning)
14:53:11 <rly> monochrom: where did the problem come from, btw?
14:53:11 <kanakola> Nooo... what's the easier solution?
14:53:28 <mjrosenb> what was this problem?
14:53:30 <monochrom> I made it up to illustrate artificial limitations
14:53:49 <napping> monochrom: what's so unnatural about that problem?
14:53:49 <DevHC> c_wraith: i know what the report says, and i can think of performance reasons for preferring "unsafe". what else should i know? concrete cases?
14:53:49 <rly> monochrom: well, you should give it to your students.
14:53:56 <monochrom> using only the laws of quantum mechanics, determine whether a number is even or odd. XD
14:53:57 <napping> data Nat = Zero | Suc Nat
14:54:00 <kanakola> mjrosenb: <monochrom> "assignment #1: write a function to determine whether a number is
14:54:00 <kanakola> 	    even or odd. you can only add 1, subtract 1, and compare with 0".
14:54:03 <napping> decrement, and compare with zero
14:54:18 <napping> well, and the induction principle
14:54:20 <kanakola> napping: what if the number is negative, you could go on decrementing forever
14:54:38 <xplat> oh, well you don't even need succ if you're working on nats, just pred
14:54:48 <rly> kanakola: that would be a good time to learn about concurrency.
14:54:49 <xplat> it's with integers that it becomes interesting
14:54:50 <c_wraith> DevHC: there are a lot of ways unsafe can corrupt your process that safe protects you against.  Additionally, safe foreign calls are run concurrently, where unsafe foreign calls block the standard RTS machinery
14:55:04 <DevHC> :O
14:55:34 <kanakola> rly so your solution is to have one thread increment, another decrement, and return the answer of whichever terminates first?
14:55:55 <xplat> this problem also took me 3.5 seconds to solve, only because i've had a similar (slightly less artificial-sounding) problem in algorithms class
14:55:58 <rly> kanakola: you can do it with one computational thread. 
14:56:13 <rly> kanakola: but conceptually there are more threads, yes.
14:56:21 <monochrom> yeah, you can think two-threads first, then merge back to sequential
14:56:35 <hpaste> septic pasted "Parse error in pattern"  http://hpaste.org/44710
14:56:40 <sonoflilit> Hello all
14:56:49 <sonoflilit> I'm playing with Persistent
14:56:53 <DevHC> c_wraith: go on
14:56:59 <kmc> DevHC, did you see ezyang's blog post on this matter?
14:57:06 <antonh> Can someone help me with my paste? 44710
14:57:06 <sonoflilit> trying to add a nicer query DSL like HaskellDB's
14:57:07 <DevHC> kmc: no?
14:57:21 <c_wraith> DevHC: yeah, look at ezyang's post.  Most of what I know comes from that, and the discussion following it
14:57:26 <kmc> http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
14:57:32 <monochrom> this is also how you deal with "prove or disprove: blah blah" questions in exams. fork 2 threads, one tries "prove", the other tries "disprove". no need to guess.
14:57:47 <monochrom> yes, fork 2 threads in your brain.
14:57:59 <mjrosenb> monochrom: people are not as good about that as computers are.
14:58:00 <kanakola> that's really clever :)
14:58:21 <sonoflilit> I took a mkPersist example and ran it with -ddump_splices, and pasted the splices to a copy of the file so I could edit them
14:58:22 <mjrosenb> antonh: (x:xs)
14:58:26 <monochrom> there is a meta-theorem about "all exam questions are decidable" so this method terminates.
14:58:33 <sonoflilit> then I tried to compile that file and got
14:58:38 <monochrom> (unless the prof typos...)
14:58:41 <mjrosenb> monochrom: disagree.
14:58:47 <sonoflilit> parse error on input `instance'
14:59:00 <xplat> that problem was 'assume you are in front of an infinitely long wall with one door, and you don't know where the door is.  you can only see one mile in each direction.  devise a search strategy guaranteed to find the door eventually, and which uses involves travelling at most a constant factor more distance than you could achieve if you already knew where the door was.'
15:00:41 <mjrosenb> xplat: if you didn't specify the 'constant factor more', and only asked for 'minimize the extra distance', it would be a harder problem
15:00:54 <monochrom> I actually was lost somewhere and had to do it in real life.
15:01:19 <xplat> and because of that problem, i didn't think of the easiest solution to this one, because i figured out how to reuse that solution and stopped thinking :)
15:01:40 <xplat> in the even/odd problem you don't have to proceed only one direction at a time ...
15:01:52 * xplat sighs
15:01:56 <sonoflilit> that parse error is really strange, because the file has {-# LANGUAGE TypeFamilies #-} and the original file works
15:02:35 <sonoflilit> can anyone help me get the file to compile?
15:04:28 <kmc> sonoflilit, where's your file?
15:04:45 <DevHC> :O
15:04:45 <sonoflilit> in the active directory, which is the same directory the other file is in
15:05:07 <sonoflilit> I did `cp tests.hs testsunpacked.hs` and changed the TH lines to their unpacked form
15:05:08 <kmc> i mean, can i see it?
15:05:10 <xplat> sonoflilit: i think kmc wants to see the file
15:05:14 <sonoflilit> oh
15:05:17 <sonoflilit> one moment
15:06:04 <roconnor> xplat: the idea that even definable powerset is inconsistent is reasonable because I think the theory is that the paradox would arise somewhere from the impredicativity of definable powerset.
15:06:10 <sonoflilit> how do I tell lambdabot to show that I pasted it?
15:06:14 <hpaste> AurSaraf pasted "TestsUnpacked.hs"  http://hpaste.org/44711
15:06:17 <sonoflilit> ah
15:06:19 <sonoflilit> great :)
15:06:34 <kmc> that's a lot of code :)
15:06:44 <kmc> which line has the error?
15:06:45 <sonoflilit> I can paste the TH version
15:06:47 <sonoflilit> 19
15:07:03 <kmc> i see
15:07:23 <kmc> does "deriving" work on an associated type like that?
15:07:32 <kmc> i see no reason it shouldn't but i've never tried
15:07:52 <sonoflilit> I pasted an annotation, that file /does/ compile and work
15:08:20 <kmc> (btw, you can put all the LANGUAGEs in one pragma separated by commas)
15:08:29 <sonoflilit> wow, auto-hlint,awesome
15:08:38 <kmc> sonoflilit, it looks like TH is generating names of the form x[a2ur]
15:08:44 <kmc> which aren't valid Haskell identifiers
15:08:52 <kmc> i don't know if that's related to your problem
15:09:03 <kmc> but it seems to be a reason why this dumped splice won't work as-is
15:09:14 * hackagebot regex-tdfa 1.1.8 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-1.1.8 (ChrisKuklewicz)
15:09:32 <mjrosenb> is there something that can be done with  TH that will enable you to add deriving (Foo) for arbitrary classes Foo?
15:09:41 <Twey> There's a package
15:09:49 <kmc> http://hackage.haskell.org/package/derive
15:09:52 <Twey> http://community.haskell.org/~ndm/darcs/derive/derive.htm
15:09:54 <sonoflilit> that's not fun
15:09:55 <Twey> Yeah, that
15:09:55 <kmc> this has a *really* cool implementation
15:10:09 <sonoflilit> so I need to manually replace every identifier?
15:10:14 <kmc> you write an instance for some example type and it derives how to derive that instance
15:10:17 <sonoflilit> or say just macro-replace the []s with nothing?
15:10:26 <kmc> sonoflilit, i guess. maybe it can be convinced to print the names differently?
15:10:34 <kmc> i'd worry about capture in the latter case
15:10:37 <Twey> As is usually the case with Mitchell's stuff
15:11:05 <mjrosenb> ahh, i think that got pulled in when i installed minesweeper
15:11:12 <kmc> and that in turn is based on some super general notion of search over a space of possible instances
15:11:18 <sonoflilit> kmc: I don't think so
15:11:19 <mjrosenb> minesweeper had some issues :(
15:11:26 <sonoflilit> isn't that how TH always does it?
15:11:49 <kmc> sonoflilit, probably safer to convert x[abcd] to x_abcd
15:11:55 <kmc> dunno why it prints that way
15:11:56 <kmc> sigh
15:13:02 <xplat> kmc: probably to AVOID capture of/by legal identifiers more easily ...
15:13:32 <kmc> yeah, but then what good is the printed code anyway?
15:13:35 <kmc> if it's not valid haskell
15:14:46 <c_wraith> kmc, ghc doesn't even derive Show that produces legal haskell code
15:15:04 <kmc> oh
15:15:10 <kmc> sonoflilit, you got this from -ddump-splices?
15:15:41 <kmc> sonoflilit, you can instead use runQ
15:15:49 <kmc> and ppr
15:15:51 <xplat> holy crap, but Jack Silver's wikipedia bio is intimidating ...
15:16:11 <kmc> and i think that might give you legal haskell code
15:16:53 <sonoflilit> fixed the issue, still failing on the same line and error
15:17:06 <sonoflilit> wait
15:17:09 <sonoflilit> not fully fixed
15:19:16 <sonoflilit> now it is, still same error
15:21:10 <roconnor> xplat: my only hope is that his mind has slowed with age.
15:22:01 <kmc> sonoflilit, maybe you can cut it down to a smaller test case?
15:22:16 <sonoflilit> I'll try
15:26:57 <sonoflilit> done
15:28:23 <sonoflilit> I have it down to a really bare minimum
15:28:36 <sonoflilit> pasted, of course, as annotation of previous link
15:29:06 <kmc> cool
15:29:32 <kmc> oh, i think the problem is simply that you don't use the kw "instance" for associated types
15:29:38 <kmc> only for standalone family instances
15:29:46 <kmc> sorry i didn't remember that earlier
15:30:12 <kmc> so ghc / TH is being imprecise with how it outputs generated asstype instances
15:30:45 <sonoflilit> huh
15:31:01 <sonoflilit> so TH doesn't go through a valid haskell code step?
15:31:18 <sonoflilit> and the dump_splices can be wrong?
15:31:22 <sonoflilit> how... strange
15:31:33 <kmc> well splices generate abstract syntax trees
15:31:44 <sonoflilit> sounds fine
15:31:49 <kmc> and i guess the AST for a family instance inside or outside a class instance is the same
15:31:55 <kmc> but the concrete syntax differs
15:31:58 <sonoflilit> argh
15:32:03 <kmc> and the pretty-printer for that AST is not taking that into account
15:32:05 <sonoflilit> so I submit a bug report?
15:32:14 <kmc> or look for an existing one
15:32:20 <sonoflilit> that too :)
15:32:21 <sonoflilit> thanks
15:32:29 <kmc> or ask in #ghc
15:32:43 <sonoflilit> in the meantime, I only have to remove those "instance"s?
15:32:51 <kmc> worked for me, on your small test case
15:33:56 <Rusky> anyone know how to parse multiple postfix operators with e.g. parsec?
15:33:59 <sonoflilit> TestsUnpacked.hs:47:4: parse error on input `{'
15:34:25 <Rusky> with buildExpressionParser you can't have more than one equal precedence postfix operators on the same term
15:35:05 <Rusky> and my own solutions always seem to run into left recursion problems
15:35:09 <kmc> Rusky, can you make a single "operator" that is actually a parser capable of returning one of several operators??
15:35:11 <kmc> ?*
15:35:12 <lambdabot> Maybe you meant: . ? @ v
15:35:16 <kmc> ;P
15:35:26 <Rusky> hmm yes
15:35:49 <Rusky> same problem though
15:36:05 <kmc> the left-recursion problem?
15:36:11 <sphynx> I'm trying to compile my code with -prof option, but it says "Perhaps you haven't installed the profiling libraries for package `fgl-5.4.2.3'?" How can I install them or disable profiling of fgl?
15:36:22 <sonoflilit> seems like there was another place where dump_splices fails
15:36:24 <Rusky> with buildExpressionParser I get the problem of the second operator being unexpected
15:36:25 <kmc> sphynx, you can't disable profiling of fgl; all the code linked together has to be built with profiling
15:36:27 <sonoflilit> someting with {}s
15:36:41 <xplat> maybe have one operator that is a parser that returns a whole sequence of operators?
15:36:56 <Rusky> hmm that could work
15:36:57 <kmc> sphynx, did you get fgl from cabal-install or from your OS's package manager?
15:37:05 <sphynx> kmc: ok, so how can I install fgl build with profiling info? 
15:37:07 <Rusky> xplat: turning it into an ast could be a problem though
15:37:11 <sphynx> from cabal-install
15:37:42 <kmc> cabal install --reinstall --enable-library-profiling
15:37:44 <kmc> fgl
15:37:50 <sphynx> cool, thanks!
15:37:59 <kmc> better yet put this in your ~/.cabal/config:
15:38:02 <kmc> library-profiling: True
15:38:02 <xplat> rusty: it's a simple left fold
15:38:12 <kmc> then you still need to reinstall fgl but all packages going forward will have profiling versions
15:38:18 <kmc> (at the cost of double compilation time)
15:38:29 <sonoflilit> kmc: do you know what the right syntax would be in line 147?
15:38:40 <kmc> imo Haskell Platform should ask you if you're a "user" or a "developer" and in the latter case automatically enable that option and haddock
15:38:41 <Rusky> xplat: haha I love when that happens. I just need to figure out how to notice it
15:38:41 <sphynx> kmc: thanks! great advice!
15:38:47 <Rusky> xplat: thanks
15:38:58 <xplat> Rusky: np
15:39:13 <hpc> kmc: "user" as in "uses libs to make programs" vs "develops libs and ghc"?
15:39:35 <kmc> no "developer" as in "writing Haskell libs/apps" vs "user" as in "just wants to get xmonad working"
15:39:38 <c_wraith> oh, hey.  I suddenly want superclass equality constraints.  yay!
15:39:44 <kmc> sonoflilit, this line? toPersistFields Pet x[a2ui] x[a2uj] x[a2uk]
15:40:32 <sonoflilit>     { entityDef _ = Database.Persist.Base.EntityDef
15:40:52 <sonoflilit> TestsUnpacked.hs:47:4: parse error on input `{'
15:41:05 <sonoflilit> oh sorry that was 47 :P
15:41:12 <kmc> sonoflilit, yeah, i don't get what's going on there
15:41:28 <kmc> at line 137-139 you have three "data instance"s with no right-hand side
15:42:07 <kmc> oh i think "entityDef _ = ..." starts off the methods part of the type class instance
15:42:22 <kmc> so that brace should move to right after "instance PersistEntity Person where"
15:42:28 <kmc> or probably, not exist
15:42:35 <sonoflilit> kmc: I think those are meant to be that way
15:42:50 <kmc> does "data Foo =" actually work
15:42:58 <kmc> as an alternative to "data Foo"
15:43:47 <sonoflilit> hmm, tested, no
15:44:06 <sonoflilit> and you need a special extension to allow "data Foo"
15:44:23 <roconnor> kmc: try newType Foo = Foo Foo
15:45:20 <roconnor> magic (Foo x) = magic x
15:45:24 <shachaf> roconnor: That also has a nicer Show instance. :-)
15:48:05 <Ptival> why would "modifyMVar_ c $ const (return 1) ; print =<< readMVar c" print 0 instead of 1? (0 being the initial value of the MVar)
15:48:24 <sonoflilit> what's wrong with my line 192's ->?
15:50:27 <sonoflilit> kmc: what's wrong with my line 192's ->?
15:50:39 <sonoflilit> It gives an error after I solved all the { errors
15:52:41 <kmc> Ptival, prints 1 for me
15:53:04 <Ptival> kmc: ok, I'll try on a small program to figure this out :\
15:53:42 <kmc> sonoflilit, not sure... try rewriting that pattern as ((x_a3pU,_):_)
15:53:54 <kmc> that use of qualified infix *should* work
15:54:12 <kmc> also it keeps using { } to override layout but then not inserting ;
15:54:57 <c_wraith> Is it bad I'm using a GADT just so that internal typeclasses don't leak into documentation?
15:55:13 <c_wraith> well, and all type signatures
15:55:25 <kmc> seems reasonable, depending
15:55:29 <kmc> you know my feelings about typeclasses ;)
15:55:46 <c_wraith> I'd be happy if I could do this without an internal typeclass
15:55:55 <c_wraith> maybe I should ask about that, instead
15:56:06 <kmc> maybe you can pass around whatever is in the class inside your [G]ADT instead
15:56:07 <sonoflilit> kmc: didn't help, also you're off by one line
15:56:24 <c_wraith> Hmm.  It just occurred to me I could do it with an associated data type.  New fun type toys!
15:56:30 <kmc> which pattern sonoflilit?
15:56:38 <kmc> oh "GHC.Types.[]"
15:56:40 <kmc> probably isn't right
15:56:46 <kmc> unqualify that mo'fo'
15:57:01 <kmc> c_wraith, hooray for asstypes
15:59:57 <iago> there is some online doc for cpphs (in addition to the API doc) ?
15:59:58 <c_wraith> Hmm.  Maybe not.  Ok, here's the problem, in overly general terms:  I have an abstract key/value store.  I want to provide multiple implementations sharing as much code as possible.  I want two independent directions I can tweak: whether the values are forced to whnf, and whether the internal backing is Data.Map or the new UnorderedMap stuff.
16:00:14 <iago> I recall there was,but I am not able to find it right now
16:00:42 <kmc> (which new UnorderedMap?)
16:01:02 <c_wraith> tibbe's hash-based maps
16:01:36 <c_wraith> @hackage unordered-containers
16:01:36 <lambdabot> http://hackage.haskell.org/package/unordered-containers
16:01:43 <kmc> cool!
16:02:21 <c_wraith> My current thought is to use a typeclass for each axis of behavior, and implement everything general in terms of those type classes.  But then I get into a mess when I want to not let those classes leak into the public-facing type signatures
16:02:22 <kmc> how does it compare to the "hashmap" package
16:02:47 <c_wraith> supercedes it
16:02:57 <c_wraith> same base ideas, further performance tweaking, especially for space
16:03:11 <kmc> excellent
16:03:12 <c_wraith> In fact, he started with Milan's code
16:03:18 <xplat> c_wraith: what kind of keys do you have?
16:03:39 <c_wraith> xplat: general.  It's library code.  In some cases, the keys will be Hashable, in other cases, they'll be Ord
16:03:40 <kmc> is it still essentially a binary patricia trie?
16:03:43 <c_wraith> yes
16:03:58 <c_wraith> He's working on an alternate backend, but it still has performance issues
16:04:00 <kmc> that's still quite good, but what i'd really be excited to see is something like clojure's packed 32-ary tries
16:04:03 <xplat> c_wraith: then some of it will leak into the type signatures either way ...?
16:04:15 <kmc> i guess that's probably next :)
16:04:41 <c_wraith> kmc: he's working on it.  It was faster for lookups, slower for inserts, in the last test results I saw.  I think.
16:04:51 <kmc> not too surprising
16:04:54 <c_wraith> Basically, he's not happy with it yet, so it's still in-progress
16:04:58 <xplat> i mean, there's no class that's the inclusive disjunction of Hashable and Ord, and even then ...
16:05:20 <c_wraith> xplat: you can hide that by making the generic interface a typeclass with either an associated type or a fundep
16:05:36 <c_wraith> xplat: but that's outside the scope of what I'm dealing with now
16:06:38 <kmc> the direct elimination of classes would give you:  data Store k v m = Store { insert :: k -> v -> m -> m; lookup :: k -> m -> v }
16:06:58 <c_wraith> kmc: that doesn't leave any real room for common code, though
16:07:10 <kmc> mkMap :: (Ord k) => Store k v (M.Map k v)
16:07:22 <kmc> what code do you want to share?
16:08:15 <c_wraith> oh, I see.  Just eliminating the internal classes...  Store would get long, but the backing would be short.
16:08:29 <c_wraith> And there's no common code there, anyway.
16:08:33 <c_wraith> So that wouldn't be so bad.
16:08:50 <kmc> another option is to unify this "ops struct" with the map itself
16:08:54 <kmc> (thereby hiding the latter's type)
16:09:01 <kmc> you can do that with an existential
16:09:20 <kmc> data Store k v = forall m. Store ...
16:09:27 <kmc> this is problematic if you need operations like "union"
16:09:29 <c_wraith> I wish I could see a way to change a field in a data type between strict and non-strict without just having two data types.
16:09:50 <c_wraith> Nah, I think the existential probably does what I want there
16:09:56 <kmc> c_wraith, if it's an abstract type you can put the seq's into your smart constructors
16:10:38 <kmc> data Foo = Foo !Int; mkFoo = Foo  data Foo = Foo Int; mkFoo = (Foo $!)
16:11:43 <c_wraith> ah, hmm.  I'll need to learn a ton more about optimizing to make this efficient...  But that's a couple steps further down the road
16:12:11 <ddarius> It's never too early to start optimizing.
16:12:20 <c_wraith> I should optimize it all before I write it!
16:12:33 <c_wraith> Really, it's just maximizing inlining that I want to happen..
16:13:10 <c_wraith> And I suspect there are already sufficient tools for doing that
16:13:20 <c_wraith> I'll learn what they are after I get stuff working. :)
16:13:20 <kmc> hiding / abstracting the interface will prevent inlining :/
16:15:24 <kmc> what's your goal in writing this?
16:16:02 <c_wraith> @hackage lrucache
16:16:02 <lambdabot> http://hackage.haskell.org/package/lrucache
16:16:10 <c_wraith> I'm working on version 2
16:16:21 <kmc> cool
16:16:31 <c_wraith> increasing options, etc.
16:18:13 <kmc> that's a cool trick, threading a doubly linked list through the values of a map
16:18:38 <c_wraith> not the fastest, but it's conceptually simple
16:18:58 <kmc> when implementing 'patience' i needed a structure that was like a priority queue of stacks with pointers between them
16:19:06 <kmc> and it all worked out perfectly without any mutation
16:19:14 <kmc> just by using sharing
16:19:18 <kmc> i was really pleased
16:19:27 <c_wraith> yeah, I'm not doing any mutation in the base implementation
16:19:57 <kmc> cool
16:20:12 <kmc> i see v1 has a pure data structure + atomic ops for manipulating it inside an MVar
16:20:28 <c_wraith> yeah, I'm keeping that same basic layout.
16:20:31 <monochrom> premature optimization is the root of all project euler problems getting reduced to O(1) solutions
16:20:49 <kmc> i think that's a nice design
16:20:51 <kmc> and often quite fast
16:20:59 <c_wraith> Just providing multiple options for how the pure data structure will work
16:21:04 <kmc> (even faster if you can use atomicModifyIORef instead, though i guess that has contention problems?)
16:21:15 <c_wraith> I should benchmark that again
16:21:18 <kmc> i don't remember if aMIOR can livelock but i think so
16:21:30 * kmc wonders how it avoids ABA problems
16:22:01 <c_wraith> I think the biggest reason I went with an MVar is I can actually provide strictness.
16:22:17 <c_wraith> aMIOR can't be strict, due to its implementation
16:23:01 <c_wraith> Though I suppose I could provide that strictness externally, that potentially leads to multiple threads repeating the same evaluation
16:23:10 <kmc> why can't it be strict?
16:23:11 <c_wraith> using an MVar ensures that only one thread will evaluate it
16:23:57 <c_wraith> it's defined in terms of an atomic compare and swap, that works only on single-word operations
16:24:26 <c_wraith> and that means it replaces the value with a thunk pointing evaluating the function supplied
16:24:32 <c_wraith> err, pointing *to
16:25:04 <c_wraith> If it actually did any evaluation, it would need locking, rather than CAS
16:25:17 <sonoflilit> TestsUnpacked.hs:159:27: Not in scope: `Database.Persist.TH.apE'
16:25:17 <c_wraith> because evaluation can take arbitrary time, etc
16:25:24 <kmc> hmm, right
16:25:56 <kmc> you could get the value, evaluate outside the lock, then do the CAS with the result (and try again if it'd changed)
16:26:04 <kmc> but if you want that kind of thing, you should probably use STM instead
16:26:18 <kmc> and that answers my question about ABA problems too
16:26:33 <kmc> because it really is just a CAS, not a get-and-compute-and-optimistic-CAS
16:26:44 <c_wraith> using an MVar puts an upper bound on work done, even if it reduces the actual concurrency to zero.
16:27:22 <c_wraith> And in the kinds of use cases I've worked with, that upper bound is more important than true concurrent access to the store
16:29:20 <kmc> i see
16:29:39 * hackagebot attoparsec-binary 0.1 - Binary processing extensions to Attoparsec.  http://hackage.haskell.org/package/attoparsec-binary-0.1 (AndrewDrake)
16:29:55 <kmc> whereas the lazy version doesn't bound the work?
16:31:26 <c_wraith> yeah.  It ends up being pretty similar to comparing accessing a single value with STM vs a single MVar
16:31:31 <sonoflilit> kmc: in all those places where I replaced x[....] with x_...._, it now says there are too many arguments relative to the type
16:31:38 <c_wraith> I saw the same CPU/memory profile with aMIOR as I did with STM
16:31:42 <sonoflilit> so those aren't supposed to be function arguments at all?
16:33:16 <kmc> c_wraith, hmm, if two threads read the IORef, and once forces the value inside, won't it block the other one from forcing it too?
16:33:25 <kmc> (iirc there's an extremely unlikely race, but otherwise)
16:33:49 <c_wraith> yeah, the failure condition must have been somewhere else.
16:33:59 <c_wraith> And like I said, it's probably worth re-testing this anyway
16:34:24 <c_wraith> But I do remember that MVar held up the best under contention, in the most abusive test I ran
16:34:32 <kmc> interesting
16:34:50 * kmc wonders if aMIOR could be made more awesomer with cmpxchg16b
16:34:58 <c_wraith> These tests were sometime in the GHC 6.10 lifetime
16:35:06 <c_wraith> 7.0 might improve things
16:39:12 <c_wraith> Hmm.  It just occurred to me that if I don't actually make these vary by type, I can't apply a typeclass to allow varying key types
16:39:26 <c_wraith> I guess I can't make the store type existential
16:39:30 <c_wraith> That's fine, though.
16:59:57 <lpsmith> So I implemented Dijkstra's algorithm in Haskell,  and am reminded of why I left imperative programming for functional.
17:00:57 <lpsmith> I had (at least) four bugs before it worked.  It feels a little embarrassing, actually, how many mistakes I made.
17:01:40 <kmc> did you use a fibonacci heap?
17:02:22 <xplat> you implemented it imperatively?
17:02:42 <lpsmith> Yup, in the ST monad
17:02:46 <lpsmith> no, I used a binary heap
17:04:12 <lpsmith> Basically one array of nodes as the binary heap,  one array of nodes to hold the cost of travelling to each node,  and one array of nodes to store indexes into the binary heap
17:04:54 <lpsmith> err, an array from indexes to nodes,  an array of nodes to costs,  and an array of nodes to indexes
17:05:04 <kmc> sounds like you implemented it imperatively *and* with C data structures
17:05:22 <lpsmith> hey,  I didn't say it was good code!  =)
17:05:33 <lpsmith> It did run fast though
17:05:34 <kmc> and i'm not saying i can think of a better way off the top of my head
17:05:46 <luite> but why did you leave imperative programming for functional then?
17:05:52 <kmc> just noting that this might be a bigger component
17:06:13 <lpsmith> luite, because I found it *far easier* to write correct code
17:06:39 <luite> really? sounds like it would be just as easy to get correct code for this algorithm in, say, C# or Python
17:06:41 <kmc> lpsmith, do you feel the same way when doing functional programming in dynamically typed languages?
17:06:52 <lpsmith> and this seems to demonstrate to me that while I have become a better imperative programmer,  it's still tricky.
17:06:54 <luite> with those data structures
17:07:19 <kmc> Haskell has data types that don't suck, static checking that doesn't suck, and good support for FP
17:07:27 <kmc> i feel like all three of these properties help me write correct code
17:07:41 * mjrosenb has heard good things about using finger trees for priority queues
17:07:46 <kmc> i think they're roughly equally important
17:07:54 <mjrosenb> however, i have yet to implement them, nor test them
17:08:15 <kmc> http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-PriorityQueue-FingerTree.html
17:08:19 <luite> the types are relatively simple here though
17:08:28 <lpsmith> luite, that's my point.  For this exercise, it didn't matter what language I would have used;  C# or Haskell,  I would have probably made approximately the same kinds and number of mistakes given the approach I took
17:08:33 <hpc> kmc: it also has lambdas that kick ass
17:08:40 <hpc> currying, lazy evaluation
17:08:43 <xplat> in particular, they're supposed to be good for priority queues that also allow keyed access
17:08:54 <lpsmith> My thesis is it's the approach taken,  not the language so much
17:09:00 <hpc> the whole thing comes together quite nicely
17:09:06 <luite> lpsmith: hmm, I guess I don't really understand your point then :p
17:09:26 <c_wraith> clearly, what we need is a left-fold on priority queues
17:09:33 <kmc> FP in Python or Javascript is still prone to a whole class of errors that you don't get in Haskell
17:09:44 <kmc> (or in Lisp for that matter)
17:09:54 <lpsmith> kmc:  I don't mind dynamic typing
17:10:05 <lpsmith> I actually like dynamic typing on a number of fronts
17:10:15 <xplat> luite: his point is: he was reminded of why he abandoned imperative for functional because he wrote an algorithm imperatively and made more mistakes than he is used to now that he normally writes functionally.
17:10:28 <c_wraith> really, I guess the issue with dijkstra's algorithm is you *really* want keyed access to the priority queue
17:10:34 <lpsmith> xplat, thank you :)
17:10:39 <c_wraith> And doing that requires explicit sharing.
17:10:45 <luite> xplat: ah good explanation, thanks
17:11:08 <hpc> fun personal game i play, is to see how many lines of code you can write at once that still compiles
17:11:11 <hpc> and does something useful
17:11:28 <lpsmith> kmc:  I honestly think imperative/functional is way more important than static types v dynamic types
17:11:39 <hpaste> Hugo pasted "Database.DataTypes"  http://hpaste.org/44714
17:11:55 <hpc> iirc, my haskell record is 100, my java record is 150, and my perl record is 300
17:11:57 <xplat> functional composes better than imperative
17:12:06 <lpsmith> Learning Haskell's type system made me a much better programmer in dynamically typed languages;  but I now find I don't make that many type errors in dynamic languages
17:12:08 <hpc> but the haskell program did significantly more
17:12:09 <c_wraith> hmm.  does dijkstra *actually* need keyed access?  Maybe it doesn't, if you had correct combinators in your priority queue
17:12:23 <xplat> hpc: java code should be counted as a 5:1 or maybe 10:1 ratio to haskell though
17:12:50 <hpc> xplat: agreed
17:12:57 <lpsmith> c_wraith, it would be hard to implement dijkstra without keyed access,  as you have to find a node that isn't the smallest and adjust it's cost downward
17:13:05 <hpc> 5:1 perhaps, since that's how many lines it takes to make a lambda
17:13:50 <c_wraith> lpsmith: oh, well, all the nodes adjacent to the one you just extracted..  Which is O(1) in most graphs.  since most graphs are sparse
17:14:02 <xplat> in haskell i've often written lines that created up to 8 lambdas (as sections)
17:14:38 <xplat> (or 'partially applied' functions)
17:15:07 <lpsmith> c_wraith, there might be another alternative,  but I don't think a "vanilla" priority queue works
17:15:51 <c_wraith> lpsmith: yeah, you'd need some sort of dijkstra-implementing structure.  preferably one that implements the whole professor, at that point.
17:16:03 <monochrom> hahaha
17:16:29 <hpaste> Ptival pasted "NoMonomorphismRestriction?"  http://hpaste.org/44715
17:16:33 <Ptival> is someone able to figure out what is my problem here? ^
17:16:47 <xplat> lpsmith: you could use a vanilla queue and store multiple copies of a node at different distances.
17:17:03 <xplat> check if they are already visited when pulling them out
17:17:25 <c_wraith> That sounds rather like A*
17:17:36 <xplat> for sparse graphs it wouldn't affect the complexity much
17:17:53 <xplat> probably killer for dense graphs though
17:17:56 <c_wraith> or at least, the dynamic generation of nodes for which A* is none
17:18:02 <c_wraith> err, *known
17:18:18 <lpsmith> xplat; maybe,  you have to be sure to only insert an element if you *know* that it needs to be adjusted downwards though,  otherwise you will destroy complexity
17:18:42 <lpsmith> Which is easy enough in Dijkstra's algorithm
17:18:56 <lpsmith> but that is a good point.
17:19:41 <xplat> lpsmith: if you have bounded indegree and don't readd any nodes you already pulled one copy of off the queue it won't destroy complexity
17:20:01 <c_wraith> You could probably implement this with a PSQ efficiently...  Especially if you added a "find and decrement" function that did both in a single pass.
17:20:50 <xplat> c_wraith: find and decrement is a common operation in PSQ specs for that reason
17:20:56 <c_wraith> ah.
17:22:07 <c_wraith> there are a few different PSQs on hackage, aren't there?
17:22:20 <monochrom> there is about 1.
17:22:43 <monochrom> perhaps I misremember. there may be 2.
17:23:19 <dmwit> Well, there's finger trees. Is that the one?
17:23:30 <xplat> that's a one
17:24:46 <dmwit> priority-queue pure-priority-queue fingertree-psqueue meldable-heap pqueue PSQueue
17:24:53 <dmwit> All of those seem to be PSQ implementations.
17:26:49 <lpsmith> Ptival,  well,  clearly your issue is in "test", because that's the only definition where the Monomorphism Restriction applies
17:27:24 <monochrom> also applies to "count = unsafePerformIO (newMVar 0)".
17:27:55 <xplat> that looks like a bad idea
17:28:22 <monochrom> in fact test is monomorphically IO() no matter what you do. count is another story.
17:28:28 <lpsmith> unsafePerformIO (newMVar ...) is usually fairly safe
17:28:40 <kmc> egads why though
17:28:46 <monochrom> what is the meaning of count :: (Num a) => Mvar a ?
17:28:47 <kmc> usually that's done at top level
17:28:51 <lpsmith> but there are a bunch of problems surrounding polymorphic references
17:29:02 <kmc> Ptival, why did you use unsafePerformIO?
17:29:15 <kmc> i would worry about inlining
17:29:22 <Ptival> that was given to me (it's a homework, I simplified it for the purpose of showing my problem)
17:29:31 <Ptival> I wrote everything but test
17:29:36 <xplat> doesn't the unsafePerformIO documentation include a simple example of how to segfault by doing that with an IORef?
17:29:37 <kmc> someone is giving you homework with unsafePerformIO in it?
17:30:15 <Ptival> kmc: apparently...
17:30:17 <kmc> wow
17:30:27 <kmc> bring your instructor here so we can yell at him/her
17:30:45 <lpsmith> kmc:  I've had to use unsafePerformIO . newMVar in other situations;  but there shouldn't be any reason to do that here.
17:31:06 <Ptival> well he actually got this part from a homework of another university so he's not that much responsible for this ^^
17:31:14 <kmc> you can move newMVar into the "do" block and move the rest of the "where" into a "let" that follows it
17:31:20 <Ptival> but still responsible for giving it to us
17:31:27 <monochrom> Data.PriorityQueue.FingerTree lacks the "s" in "psqueue". there is no look-up.
17:31:30 <Ptival> ok
17:31:31 <lpsmith> For example,  I was loading in some records from a JSON file using the JSON package,  but it doesn't make allowances for unsafePerformIO
17:31:48 <Ptival> I'll talk with my teacher about this problem...
17:31:49 <kmc> Ptival, when you asked us earlier about weird MVar behavior, knowing that your MVar was created in this super dodgy way would have been useful
17:31:59 <kmc> Ptival, try refactoring your code that way, and see if the problem goes away
17:32:06 <lpsmith> And the MVar was being used to cache a value,  so I had to restore it empty,  but couldn't use the JSON package if I didn't use unsafePerformIO
17:32:09 <Ptival> kmc: ok
17:32:29 <kmc> Ptival, if you want to make it work with unsafePerformIO you should at least add {-# NOINLINE count #-} on the line before
17:32:45 <kmc> and probably add a monomorphic type signature for count, to avoid the problem xplat mentioned
17:33:42 <kmc> this happens pretty often... someone comes here with homework and we critique the code written by their professor
17:34:39 <Ptival> :)
17:34:39 <kmc> at my school all the programming languages courses (dozens) were taught by the same two guys
17:35:13 <stepcut> kmc: at least the quality was consistent ?
17:35:20 <lpsmith> At my school,  the head of the math department didn't want me to skip discrete math because it "had an SML lab component"
17:35:27 <lpsmith> But I already knew SML
17:35:56 <geheimdienst> trolling-by-proxy. if i were a professor, i'd put wrinkles and easter eggs in the code, then wait until my students show up in #haskell and get yelled at :)
17:36:03 <lpsmith> And then later I helped some of my friends with their "SML lab component",  and saw some of the code the head of the math department had written.
17:36:06 <monochrom> priority-queue has a look-up, but it does linear search.
17:36:10 <lpsmith> It was *terrible*
17:36:19 <lpsmith> I guess he thought it was good though.
17:36:22 <monochrom> I wouldn't call that a psqueue.
17:36:34 <xplat> i once applied to transfer to a school that told me none of my CS credits would be good there because they weren't taught in Java
17:36:45 <kmc> ugggggh
17:37:19 <mjrosenb> monochrom: what is the type of lookup?
17:37:23 <xplat> because, you know, you have to write a quicksort so differently in java than any other language
17:37:29 <geheimdienst> :t lookup
17:37:30 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:37:34 <lpsmith> yuck.  xplat, what were your courses in?
17:38:13 <xplat> first you create an AbstractSequenceSubrangeFactory interface, and then you create the implementation for ArrayList ...
17:39:02 <Eduard_Munteanu> LOL
17:39:32 <xplat> lpsmith: Turbo Pascal, which wasn't great (and dates me!) but i'd even written things in Object Pascal back then, never mind the languages i used inbetween the two schools
17:39:50 <lpsmith> Hah, I loved Turbo Pascal
17:39:54 <stepcut> turbo pascal was the first language I used
17:39:56 <lpsmith> Not the language so much
17:40:07 <lpsmith> but the IDE was awesome
17:40:13 <stepcut> because it came pre-installed on my 286.. and there wasn't much else to do :)
17:40:19 <lpsmith> I honestly have not found an IDE I like as much as Turbo Pascal
17:40:40 <Eduard_Munteanu> @remember xplat because, you know, you have to write a quicksort so differently in java than any other language. first you create an AbstractSequenceSubrangeFactory interface, and then you create the implementation for ArrayList ...
17:40:40 <lambdabot> Okay.
17:40:58 <lpsmith> My first language was Microsoft Basic,  because it came on the ROM of my C64 and there wasn't much else to do :)
17:41:11 <Eduard_Munteanu> That should serve as a good comparison for newcomers.
17:41:26 <monochrom> a psqueue is a pqueue with one more operation. pqueue let's you enter (priority,data) and then get out the pair with minimum priority. psqueue further lets you ask "have you seen data?", i.e., s = search. that's look-up.
17:41:44 <xplat> my actual first language was logo.  lisp with arity!
17:42:00 <lpsmith> Stepcut,  at first,  there was *nothing* else to do, I didn't even have a storage device or any game cartridges.
17:42:12 <lpsmith> So I had to type in a basic program to do anything
17:42:43 <xplat> then i did a bunch of basic and injured my brain, then assembler, turbo pascal, C, perl, ... and off to the races
17:42:44 <stepcut> lpsmith: heh. My first computer was the TI 99/4A. But there were catrigdes and tape loading.
17:43:08 <monochrom> pure-priority-queue also has look-up but linear. in fact pure-priority-queue is merely Data.Map.Map priority [data].
17:43:33 <stepcut> lpsmith: with no cartrige it booted into BASIC. but then there was also an Extended Basic cartrige. I remember thinking that I could never use all 16k of RAM..
17:44:00 <lpsmith> I don't think Basic damaged me much.   It was difficult to transition to Pascal,  but once I did there was no looking back.  I pretty quickly realized that pascal was a *much* better language.
17:44:14 <xplat> it's a little harder to blame gates for 640K when you remember that
17:44:45 <monochrom> meldable-heap does not have look-up
17:44:45 <xplat> (can still blame him for a lot of other things though :)
17:45:41 <stepcut> lpsmith: yeah, same here.
17:46:20 <stepcut> lpsmith: then I read a bunch of books about hackers/crackers, and thought I had to learn C to be cool. But then realize that Haskell was the true way of life.
17:46:32 <xplat> lpsmith: i saw an interesting post recently on the blog of the <adjective> programmer (don't remember which adjective; reformed?  he likes erlang) that argued that programming in MS BASIC made people stronger
17:47:10 <xplat> lpsmith: basically, that it was so hard to write a decent program in that language that people determined to do something developed mental skills that made any other language look like cake
17:47:12 <lpsmith> sort of the same,  I learned C++ thought it was awesome because it removed some of the limitations that Pascal had that had been seriously annoying me,  but got really disenchanted with both C++ and Pascal after a month
17:47:18 <monochrom> pqueue's look-up is linear
17:48:16 <sonoflilit> do you mean prog21.dadgum.com ?
17:48:51 <xplat> i remember in my first pascal course getting a lot of the pointer programs to work basically correctly the first time, which shocked my teacher (that was in HS)
17:49:20 <kmc> stepcut, btw you do have to learn C to be cool :)
17:49:32 <xplat> which goes to show how low expectations were i guess :)
17:49:38 * geheimdienst growls at kmc
17:50:35 <monochrom> This completes disqualifying 4 out of 6 claims of psqueues in "<dmwit> priority-queue pure-priority-queue fingertree-psqueue meldable-heap pqueue PSQueue <dmwit> All of those seem to be PSQ implementations."
17:50:37 <xplat> sonoflilit: yes
17:50:48 <kmc> why the growling geheimdienst
17:50:59 <lpsmith> xplat, I think that's true of some people and Basic, yes
17:51:19 <hpaste> WilliamKnop pasted "GHC: compiler/utils/Util.lhs: Core lint error"  http://hpaste.org/44716
17:51:31 <monochrom> if it doesn't say "psqueue" with an "s", it is not a psqueue.
17:51:41 <lpsmith> I mean,  the beautiful thing about learning to program in the early 80s is that the bar was so low,  the environments so simple
17:51:49 <Eduard_Munteanu> I never thought pointers were a big issue either... but many people have problems with them.
17:52:00 <lpsmith> And there wasn't many fancy software packages available to distract you
17:52:14 * geheimdienst doesn't like c
17:52:15 <kmc> no facebook
17:52:17 <xplat> also, a lot of the computers were pretty much instant-on, so if you crashed your machine, w/e
17:52:26 <kmc> geheimdienst, but it's an important one to know
17:52:31 * Eduard_Munteanu still likes C a lot
17:52:44 <lpsmith> I mean,  imagine a young child learning C# these days
17:52:59 <lpsmith> Can you ever get to the point that you think you've mastered the language?
17:53:12 <xplat> just save your program first (admittedly, that took like a whole minute on a goddang 1541 :)
17:53:20 <kmc> lpsmith, also, any computer you'd get as a gift or fish out of the trash would at least have a BASIC interpreter
17:53:32 <kmc> lpsmith, now, your gift is an iPad and the manufacturer goes to great lengths to prevent you from learning to program with it
17:53:40 <parcs> is libHSghc-7.0.2.a not supposed to be stripped?
17:53:40 <lpsmith> kmc:  absolutely
17:53:41 <geheimdienst> .. but i guess there's a difference between learning c to know more about stuff and using or liking c
17:53:47 <xplat> kmc: you can still go to tryhaskell!
17:54:09 <lpsmith> of course, the PC was a big step towards not having readily accessable programming environment
17:54:14 <stepcut> kmc: :)
17:54:25 <lpsmith> The PC should have had something distributed with it by default
17:54:27 <stepcut> kmc: I'm cooler than C now
17:54:29 <kmc> lpsmith, it's true, but IBM didn't go so far as to forbid anyone from selling development tools that run on the PC
17:54:37 <xplat> pcs still had rom basic for a good long time
17:54:39 <kmc> also many flavors of DOS at least came with QBASIC
17:54:46 <lpsmith> kmc:  absolutely =)
17:54:52 <Eduard_Munteanu> I'm personally not a fan of middle grounds, as in I rarely look into similar languages.
17:55:05 <xplat> although it eventually got pulled
17:55:09 <Eduard_Munteanu> I couldn't pull myself into seriously looking into another languages until Haskell.
17:55:50 <Eduard_Munteanu> I'm just not the guy who'd enjoy learning Perl after PHP after Python after...
17:56:45 <lpsmith> Eduard_Munteanu, my enthusiam for learning new languages is greatly diminished
17:56:58 <xplat> i kind of want to learn J now
17:57:10 <xplat> if only for the environment
17:57:14 <Eduard_Munteanu> I'd look into Coq / Agda / Epigram next.
17:57:23 <Eduard_Munteanu> I mean, more seriously.
17:57:35 <xplat> yeah, that's a good angle too
17:57:54 <kmc> _Software Foundations_ for the win
17:57:58 <lpsmith> Yeah,  I'm not sure where to go.  Coq or Agda probably, to be honest
17:58:20 <lpsmith> Clojure or Scala or F# maybe
17:58:22 <kmc> if you like Haskell i recommend taking a look at Clojure
17:58:31 <xplat> i just wish agda syntax and libraries were stable enough i could be confident other people's code will load correctly on the compiler i install
17:58:47 <kmc> my (unfair) opinion is that F# is "Haskell, but .NET, but worse", and so I'd learn it iff i needed to do some .NET project
17:59:01 <lpsmith> xplat, Haskell used to have the same problem :)
17:59:06 <kmc> similarly there's a few reasons to use ocaml even if you know Haskell but they don't come up in my life very often
17:59:12 <lpsmith> If agda survives 10 years, things will get better
17:59:23 <xplat> kmc: that's totally unfair.  F# is "Ocaml, but .NET, but worse".
17:59:52 <kmc> Clojure is good in a lot of the same ways as Haskell, but different enough to be worth learning for fun
17:59:57 <Eduard_Munteanu> Ocaml is still one of the things that doesn't require huge paradigm shifts :/
18:00:00 <lpsmith> though it took close to 20 years for Haskell to really mature;  it may take Agda 30
18:00:11 <lpsmith> it's a harder problem
18:00:17 <xplat> lpsmith: even in 98 the compilers were at least documenting which version the new features were added in ...
18:00:35 <pluhngz> Japan Orders Evacuation Near 2nd Nuclear Plant - Senior engineers at the Daiichi and Daini and operated by Tokyo Electric Power have stated that if they are not provided coolant within 48 hours, Tokyo could become the next Chernobyl with Tokyo becoming uninhabitable for 150 years.
18:00:36 <pluhngz> http://www.nytimes.com/2011/03/12/world/asia/12nuclear.html
18:00:44 <monochrom> someone should kidnap dons and make him build an infrastructure and bytestring for agda
18:00:46 <lpsmith> xplat, true;  but bitrot was *extremely* common those days
18:00:52 <xplat> agda's biggest problem for me is lack of approachable/comprehensive documentation
18:00:57 <lpsmith> and then there was the comment syntax that changed around that time
18:01:09 <Eduard_Munteanu> pluhngz: it's probably an overstatement
18:01:21 <pluhngz> imagine if tokyo becomes unlivable
18:01:25 <pluhngz> as that nytimes article says
18:01:26 <pluhngz> jeez
18:01:26 <lpsmith> I remember a professor wanted to know why this haskell program he'd gotten from another professor at another university didn't work.
18:01:42 <lpsmith> And I pointed out that --* had become an infix operator
18:01:50 <lpsmith> that was circa 2001
18:02:20 <kmc> can't we probably foreign-import ByteString into Agda
18:02:21 * Eduard_Munteanu would take that nuclear stuff to #haskell-blah
18:02:39 <kmc> paired with a (slow) Agda model for compile-time reasoning?
18:03:28 * lpsmith thinks that people are almost certainly overreacting to the nuclear thing,  but I agree with Eduard_Munteanu 
18:03:33 <impl> That is what happened at Three Mile Island. In that case, the causes were mechanical failure, operator error and poor design, according to government investigators.
18:03:35 <pluhngz> the only thing worse for the world and various global societies, then a devastating earth quake are homosexuals that have shit encrusted anal sex with each other, because it doesnt populate the planet as designed by nature
18:03:53 * kmc golf claps
18:03:58 <impl> Three Mile Island was caused by someone forgetting to replace a valve after maintenance.
18:04:19 <lpsmith> #haskell-blah for discussions of nuclear power, please
18:04:45 * monochrom regrets not banning swiftly
18:04:50 <xplat> since agda has limited phase distinction, it really needs to have efficient evaluation even at compile time
18:05:52 <xplat> (with dependent types, the turnstile actually turns!)
18:12:31 <drbean> 86
18:26:00 <hpaste> WilliamKnop pasted "GHC: Core lint error"  http://hpaste.org/44717
18:33:01 <sshc> I'm unsafe foreign importing XGetImage, but it hangs under heavy load
18:33:19 <sshc> What could possibly cause this?
18:37:07 <madeinindia> hai
18:37:18 <madeinindia> any bopdy here
18:38:26 <stepcut> madeinindia: with 661 people in the channel, the answer is probably always yes..
18:38:42 <stepcut> madeinindia:  :p
18:39:28 <augustss_> howdy
18:39:43 <btutt> hey
18:40:00 <monochrom> with 660+ bots in the channel, you can bet there is no body.
18:40:23 * geheimdienst finds offended that the 200+ cats have been ignored
18:40:45 <augustss_> It's bots all the way down. 
18:41:02 <stepcut> monochrom: heh
18:55:31 <Jonno_FTW> ...
18:56:16 <stepcut> ....
18:57:09 <Jonno_FTW> :t (.) . (.) . (flip .)
18:57:10 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (f2 :: * -> *) a1 b. (Functor f, Functor f1, Functor f2) => (a -> f2 (a1 -> b)) -> f (f1 a) -> f (f1 (a1 -> f2 b))
19:20:41 <deech> Hi all, this is probably way esoteric but does anyone use Haskell to do live music performances? If so is there a good environment?
19:25:12 <Jonno_FTW> deech: how do you mean?
19:25:23 <Jonno_FTW> I think there are some midi packages
19:25:39 <stepcut> deech: http://www.youtube.com/watch?v=xaoLbKWMwoU
19:31:23 <ddarius> deech: There are at least a few live coders in the Haskell community.
19:48:47 * roconnor sometimes things Haskell is only used for hedge funds and live music perfomance.
19:48:50 <roconnor> *thinks
19:51:13 <roconnor> deech: http://www.youtube.com/watch?v=lY-NaFqRviI
19:58:25 <drhodes> Does parsec have a function for matching parsers against strings in a way that will return something like a  Maybe [(Int, Int)] , a list of ranges of where the parser matches?
20:09:12 <monochrom> something logically equivalent to that. you can ask for "current position" at any time. so ask at beginning and ask again at end.
20:18:01 <drhodes> ok monochrom, thanks
20:18:32 <roconnor> What is the airport code for London Heathrow?
20:18:54 <drhodes> LHR!
20:19:31 <roconnor> thanks
20:19:34 <drhodes> (just looked it up to seem like an international jet setter)
20:20:29 <monochrom> jet setter, jet getter, jet iterator, and jet observer
20:20:53 <monochrom> and oh, no oop is complete without jet manager
20:21:13 <drhodes> can't forget the jet factory
20:22:28 <Ptival> jet bean?
20:22:41 * roconnor combines a jet setter and jet getter into a jet lens
20:32:54 <btutt> So therefore the 2 jet lens are the CEO of Boeing and Airbus because they jet set and they get the jets from the factory. ;)
20:36:46 <Anpheus> Does anyone know if you can use the LLVM bindings for GHC on Windows?
20:36:51 <freedrull> in data.binary.get, whats the difference between getBytes and getByteString ??
20:37:25 <Anpheus> As well, Cale, are you here?
20:37:41 <Cale> hi
20:37:51 <Anpheus> Hey, it's pseudonym_ from a day or two ago
20:38:18 <Anpheus> Regarding the space leak you saw when we were trying to figure out how to make my toy algorithms more strict, and not occupy so much space
20:38:32 <Cale> yeah, I remember now
20:38:33 <Anpheus> You said when you used [Double] you saw a slow spaceleak
20:38:40 <Cale> Yeah, that was weird.
20:38:51 <Anpheus> Maybe that's due to -fexcess-precision?
20:38:55 <Anpheus> or whatever the flag is?
20:39:06 <Cale> It actually seemed to stop after a certain bound though.
20:39:19 <Cale> The maximum size for the program was 2.2MB after a long time
20:39:26 <copumpkin> preflex: seen dolio
20:39:26 <preflex>  dolio was last seen on #haskell-blah 2 days, 4 hours, 6 minutes and 42 seconds ago, saying: In private message, it says 63743.
20:39:32 <TheZimm> copumpkin :O
20:39:40 <Anpheus> It's my understanding that when you don't use that flag, Haskell uses different optimizations for doubles, that could include storing them on the heap
20:39:48 <copumpkin> yep
20:40:02 <Anpheus> I noticed I got constant usage with my program when I used -fexcess-precision
20:40:10 <Cale> Interesting.
20:40:19 <kmc> yeah
20:40:22 <Anpheus> So I'm guessing the leak was maybe just Haskell using a small amount of space in the heap?
20:40:26 <kmc> Anpheus, do you have a small case?
20:40:26 <Cale> Yeah, I think you'll find that it actually does have constant space usage, but that it takes a while to reach the constant
20:40:28 <kmc> test case*
20:40:36 <Anpheus> not really a leak, just that it needs to use some without -fexcess-precision
20:40:38 <kmc> i would be interested to see the GHC Core and assembly code
20:40:43 <Cale> with the GC lagging behind as far as collecting garbage is concerned
20:40:57 <Cale> You could also try fiddling with the RTS options for the garbage collector
20:41:10 <Cale> (to make it collect more often)
20:41:20 <Anpheus> Anyhow
20:41:24 <TheZimm> is there a specific calulus library for haskell?
20:41:34 <jmillikin> Does anybody here use lazy left-folds regularly and/or find them useful for something? I'm debating removing the "foldl" equivalent from one of my libraries, leaving just foldl' , but am not sure if the lazy version has some use case I don't know of.
20:41:35 <kmc> there's an IO action for asking for a garbage collection
20:41:47 <roconnor> > deriv (\x -> sin (2*x)) x
20:41:48 <lambdabot>   2 * 1 * cos (2 * x)
20:41:51 <kmc> jmillikin, what's the data structure?
20:41:57 <jmillikin> kmc: iteratees
20:42:07 <Anpheus> @src deriv
20:42:07 <Cale> jmillikin: It seems to make sense to leave it in unless it's a burden.
20:42:07 <lambdabot> Source not found. There are some things that I just don't know.
20:42:10 <Anpheus> :t deriv
20:42:11 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
20:42:16 <jmillikin> http://hackage.haskell.org/package/enumerator
20:42:26 <TheZimm> roconnor is the integral as well?
20:42:29 <TheZimm> and limits?
20:42:34 <Anpheus> can't find deriv on hoogle
20:42:36 <Cale> jmillikin: There are admittedly not all that many occurrences of it, but in some cases, it's better by some constant factor.
20:42:36 <Anpheus> interesting
20:42:46 <Cale> jmillikin: reverse is one
20:42:53 <jmillikin> I'm moving the "fold" family into subtype-specific modules (.List, .Binary, .Text) and would like to leave the lazy fold out if it's not useful.
20:42:57 <roconnor> TheZimm: I have a function that integrates but it is too slow to be useful.
20:42:59 <Anpheus> Does anyone know if you can use the LLVM bindings on Windows?
20:43:04 <jmillikin> Cale: in general, reverse is not a sensible operation for iteratees
20:43:12 <roconnor> TheZimm: (numeric integration)
20:43:17 <TheZimm> ahh
20:43:23 <kmc> Cale, it's better because you don't waste time entering the closure at every step
20:43:32 <Cale> jmillikin: Lazy right folds are much more common. The trouble with lazy left folds is that nothing can be computed until the end of the list (or stream) is reached.
20:43:43 <TheZimm> idk if youre familiar with the taylor series but i was looking into making a little utility to help out with those
20:44:09 <jmillikin> Cale: iteratees are a special case of left fold. Right folds aren't reasonable to encode with them.
20:44:28 <Cale> hmm, really?
20:44:29 <TheZimm> roconnor just found this http://www.haskell.org/haskellwiki/Blog_articles/Mathematics
20:44:36 <jmillikin> I'm OK with leaving lazy foldl in, but my main concern is someone using it without understanding the space ramifications
20:44:44 <maurer_> What do people think about a MonadPlus instance for IO with the semantics that mzero = fail "mzero", and mplus executes both actions in parallel, taking whichever one succeeds as the result, preferring the first one. If both fail, it inserts mzero
20:45:05 <Anpheus> Sounds like a parallel maybe / amb
20:45:05 <jmillikin> Cale: Oleg's written a bunch about them (see < http://sites.google.com/site/haskell/notes/lazy-io-considered-harmful-way-to-go-left-fold-enumerator > for example)
20:46:13 <Cale> maurer_: Apart from the reliance on fail, that's not totally unreasonable, I guess...
20:46:39 <maurer_> Cale: The issue is that mzero has to be of type "IO a"
20:46:47 <Cale> throw
20:46:58 <maurer_> Cale: Is throw any different from fail?
20:47:04 <Cale> It's not fail ;)
20:47:15 <Cale> fail is something I like to try to pretend doesn't exist, as far as possible
20:47:29 <kmc> wait, why does mzero need to use "fail"?
20:47:35 <kmc> couldn't it raise a custom exception
20:47:43 <maurer_> kmc: Sure, I just thought of fail first.
20:47:43 <Cale> Yes, that's what I'm suggesting.
20:48:41 <kmc> maurer_, i like it, it reminds me of "lub" 
20:49:36 <jmillikin> maurer_: how about throwIO ?
20:49:54 <kmc> hopefully it is not too surprising that effects from both actions occur
20:50:11 <kmc> maurer_, when one side finishes do you kill the other with an async exception, or just let it run and ignore the result?
20:50:23 <maurer_> kmc: I was going to let it run and ignore the result.
20:50:25 <kmc> or... let it run and unify the results using "lub"? ;)
20:51:13 <maurer_> kmc: I figured that this way it could be both used as "attempt all of these techniques" and turns msum into a sort of parMapIO_
20:51:26 <kmc> *nod
20:51:39 <kmc> btw, did you see http://hackage.haskell.org/package/speculation
20:52:21 <maurer_> jmillikin: What would be the benefit of throwIO over throw?
20:52:56 <kmc> maurer_, it shouldn't be an error merely to evaluate that IO action
20:53:03 <jmillikin> maurer_: more explicit type, more obvious side-effect sequencing
20:53:10 <kmc> sometimes it's useful to put IO actions into a data structure and then only execute some of them
20:53:17 <kmc> and your datastructure might be strict
20:53:26 <maurer_> Sure, I guess throwIO would help then.
20:53:34 <kmc> and "it's correct"
20:53:38 <maurer_> Heh.
20:54:27 <kmc> "The throwIO variant should be used in preference to throw to raise an exception within the IO monad because it guarantees ordering with respect to other IO operations, whereas throw does not."
20:56:11 <adnap> does lambdabot keep track of when users come in here?
20:56:31 <kmc> adnap, the logs do
20:56:33 <btutt> Which suggests: Why doesn't throw do that? because it can occur in a non-monadic function that has more latitude for optimizing things around?
20:56:46 <kmc> preflex keeps track of when people speak
20:56:53 <kmc> btutt, there aren't really "monadic functions" and "non-monadic functions"
20:57:07 <kmc> and the fact that IO is a monad is totally irrelevant here
20:57:12 <adnap> kmc: what logs?
20:57:15 <kmc> "throw" throws on evaluation; "throwIO" throws on execution
20:57:17 <kmc> adnap, see topic
20:57:40 <kmc> evaluating an IO action should be side-effect-free
20:57:44 <kmc> executing it is not
20:57:48 <adnap> man, it's cut off on my screen
20:57:56 <kmc> throw "i failed to decide what to do" >> throwIO "i failed to do it properly"
20:58:13 <Anpheus> Hey guys, I'm back. So does anyone have any info on GHC using LLVM on Windows? I know the GHC 64-bit port is a ways out, but...
20:58:22 <kmc> adnap, http://tunes.org/~nef/logs/haskell/
20:59:19 <kmc> i think there are legit uses for throw e :: IO t
20:59:30 <kmc> it just has a different meaning from throwIO e :: IO t
20:59:37 <btutt> :t throwIO
20:59:38 <lambdabot> Not in scope: `throwIO'
21:00:20 <kmc> basically when pure computation goes wrong we use "throw" or "error" or such to bail out
21:00:32 <maurer_> kmc: Does it make more sense for the result of msum to hang on the completion of all actions, or to leave them spinning?
21:00:34 <kmc> and that's ok even if what you're computing happens to be a description of how to perform some IO
21:00:56 <kmc> but that's different from successfully computing a description of how to throw an exception
21:01:32 <kmc> maurer_, this is for a "try all approaches" construct?
21:01:42 <kmc> also, why are you using IO? which features of IO do you expect the actions to use?
21:02:10 <maurer_> kmc: I wanted to make it so I could use some cool features of monad comprehensions when they make it back into ghc soon.
21:02:21 <kmc> oh, neat
21:02:25 <kmc> do you have an example?
21:02:28 <maurer_> Sure.
21:03:14 <freedrull> can an Int be converted to an Int64?
21:03:18 <kmc> yes
21:03:30 <kmc> your general-purpose integer-conversion function is fromIntegral
21:03:38 <kmc> :t fromIntegral
21:03:39 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:04:00 <kmc> on all standard GHC platforms, Int64 can represent all of Int
21:05:18 <freedrull> oh thanks, i thought that might be the function i wanted...
21:06:24 <freedrull> although i don't quite understand how it knows which type i want it converted to
21:06:32 <kmc> type inference
21:06:36 <btutt> By evaluation do you if you had a thunk that contained a (\a -> b) a function invocation. Evaluation would be demanding everything but performing the actual function call? and execution is actually invoking the lambda function?
21:06:53 <kmc> no btutt
21:07:01 <kmc> execution is something special you can do to an IO action
21:07:17 <kmc> an IO action is a value describing some actions to perform in the real world
21:07:27 <maurer_> kmc: http://hpaste.org/44719/example_use
21:07:33 <maurer_> There, I'd want to async kill all threads
21:07:40 <kmc> to execute an IO action is to perform the actions so described
21:07:58 <btutt> so its an IO monad specific term in this case?
21:08:05 <kmc> it's specific to the IO type
21:08:11 <btutt> Ah.
21:08:12 <kmc> (the fact that the IO type is a monad is irrelevant)
21:08:23 <btutt> enlightenment begins :) thanks
21:08:26 <kmc> (all that means is that you use the operator named (>>=) to glue together IO actions, rather than some other function)
21:08:34 <btutt> gotcha
21:08:48 <kmc> but i can't blame you for calling it "the IO monad" because that is basically the type's name in common usage
21:08:52 <kmc> just wanted to clarify
21:09:16 <kmc> evaluation is the basic computational process in Haskell
21:09:26 <kmc> proceeds by beta-reduction (as in the lambda calculus) and by pattern-matching
21:09:30 <shachaf> kmc: Well, or just "IO".
21:09:52 <maurer_> kmc: http://hpaste.org/44721/example_use_2
21:10:24 <btutt> So does this imply that GHC treats IO >>='s differently than other Monads in terms of optimizations?
21:10:29 <maurer_> In that use case, we'd want to get back the first result that succeeded so we could continue on with our lives, but at the same time it'd be nice to have all the channels burst the same message, so we want to leave the jobs spinning
21:10:33 <kmc> no btutt
21:10:41 <kmc> IO values are totally ordinary Haskell values
21:11:01 <kmc> evaluating a Haskell value doesn't cause IO to occur
21:11:10 <kmc> that's still true even if the value is an IO action
21:11:23 <kmc> so GHC is free to muck around with evaluation order, even with respect to IO actions
21:11:49 <Ptival> so when does the sorcery occur?
21:11:50 <kmc> i see maurer_
21:12:09 <kmc> Ptival, what sorcery?
21:12:24 <Ptival> the IO
21:12:36 <kmc> here is a little model of IO:
21:12:40 <kmc> type IO t = String
21:12:49 <kmc> x >> y = x ++ ", then " ++ y
21:12:56 <jmillikin> IO isn't sorcery. ``main`` returns an IO, and that IO is what is executed at runtime.
21:13:04 <kmc> putChar c = "put the char '" ++ [c] ++ "'"
21:13:24 <jmillikin> (print 1 >> print 2) is the same process as ([1] >> [2])
21:13:26 <kmc> (putChar 'x' >> putChar 'y') = "put the char 'x', then put the char 'y'"
21:13:53 <kmc> the magic occurs when some process external to your Haskell code reads this description and actually performs the actions described
21:14:02 <geheimdienst> > [1] >> [2]
21:14:03 <lambdabot>   [2]
21:14:09 <geheimdienst> > [1] >>= [2]
21:14:09 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
21:14:11 <Ptival> ok
21:14:29 <kmc> of course Strings containing English are a lousy type for computers to interpret, but you get the idea
21:14:56 <kmc> note that it doesn't matter what order we force evaluation of the string
21:15:01 <kmc> because it's just a string
21:15:12 <Ptival> ok
21:16:10 <kmc> http://hpaste.org/44722/gadt_for_io
21:16:12 <Ptival> so we can just go around and compose/evaluate IO actions (with respect to types), and then it all just comes into place in our main IO action as a giant script of what should happen upon execution
21:16:21 <kmc> exactly Ptival
21:16:40 <kmc> the thing i pasted is one plausible implementation of the IO type
21:16:43 <btutt> I see. so throwIO happens in the context of the IO magic in the RTS when trying vs throw happens during evaluation i.e. computing the IO script
21:16:49 <kmc> yes
21:16:58 <btutt> sweet.
21:17:26 <kmc> now the dirty secret is that GHC doesn't implement IO as some nice abstract syntax tree of IO scripts
21:17:32 <kmc> that would be slow
21:17:53 <kmc> instead it implements IO as a thin wrapper over "functions" that have side-effects
21:18:21 <kmc> and the code for (>>=) and such is very careful to introduce artificial data dependencies between these functions in order to make execution order follow from evaluation order
21:18:30 <kmc> and it's basically a big hack
21:18:46 <kmc> but is invisible most of the time
21:18:56 <kmc> and we can pretend the IO type is something more civilized
21:19:21 <kmc> (and other compilers, or even other libraries for GHC, are free to implement it that way)
21:20:07 <maurer_> kmc: Now I'm curious--would it make more sense to rather than preferring the first one, prefer the first completed computation?
21:20:27 <kmc> maurer_, in which example?
21:20:48 <kmc> for your example #1 i would take the first action to complete and kill the others
21:21:26 <kmc> example #2 could do that
21:21:50 <kmc> or maybe example #2 really should use (fmap msum . sequence) not msum
21:21:52 <maurer_> Actually, the more I look at it, the more it seems like first to complete, kill other makes sense.
21:22:06 <kmc> though you still want parallelism
21:22:20 <kmc> but in the second case it's fine to let them all finish and then combine the SuccessObjects
21:22:33 <maurer_> kmc: I think Example #2 might make more sense to rewrite with SuccessObject replaced by Response
21:22:40 <btutt> Hrm. Ok, so I think I get the conceptual model now. The question would then be: can you write some Haskell code that behaves differently when using throw vs throwIO in code using IO in GHC? If so, what would that look like?
21:22:40 <kmc> maurer_, one way to choose is, which of these is hardest to implement with existing stuff?
21:22:47 <maurer_> As otherwise there's no need for msum, and I should just use "parallel"
21:22:52 <kmc> btutt, yes, the throwIO doc has an example
21:22:57 <btutt> cool.
21:23:02 <kmc> throw e `seq` ()
21:23:10 <kmc> that will raise an exeption
21:23:15 <kmc> throwIO e `seq` () -- will not
21:23:29 <btutt> hah
21:23:39 <btutt> seq always screws things up. ;)
21:23:43 <kmc> yes
21:24:35 <adnap> man, i wish conal was online
21:24:46 <maurer_> kmc: Easiest to implement would be a toss up between order of completion and order called, with the easiest mode being to not kill the spawned processes
21:24:49 <adnap> i want to show him something
21:25:06 <kmc> maurer_, then "msum" should kill them, in order for it to be more useful as a library
21:25:27 <maurer_> kmc: e.g. Control.Concurrent.IO.{parallel,parallelInterleaved}
21:25:32 <kmc> have you read the source to System.Timeout?
21:25:35 <btutt> to sum up: throw is just plain easier to deal with. ;)
21:25:52 <kmc> heh
21:25:55 <kmc> i'd say the opposite
21:26:21 <maurer_> kmc: Yep. I actually had a custom rolled version of that in a compiler I wrote a few months back, then saw that function show up :)
21:33:19 <btutt> or put a different way: IO is special IO is special, don't think about it, just let it be. :)
21:35:00 <kmc> it's special in some ways
21:35:18 <kmc> and it's ordinary in other ways where it appears special
21:36:16 <kmc> it's special in that your Haskell implementation will provide some system which inspects IO actions and executes them, and this system can't be written in Haskell
21:40:37 <taruti> Who is responsible for code.haskell.org these days?
21:54:40 <maurer_> kmc: Is there a way to catch all exceptions with the newstyle catch?
21:55:06 <maurer_> kmc: Using \_ works fine for the old one, but the new one becomes very sad if I try to give it a generalized "a -> IO ()" function.
21:57:09 <maurer_> Hm, looks like I can just use "onException" instead.
21:57:15 <kmc> SomeException -> IO ()
21:57:19 <kmc> ?
22:00:02 <maurer_> kmc: http://hpaste.org/44723/monadplus_io
22:00:18 <maurer_> I'm about to actually test it, but it _seems_ right.
22:03:16 <maurer_> Hm, doesn't work right as is. Reworking.
22:09:27 <maurer_> Well, I got it working, but had to sacrifice thread control to do it...
23:13:38 <maurer_> Anyone know how to make a polymorphic deserializer? e.g.  I have a typeclass
23:13:38 <maurer_> class (Serializable a) => Fooable a where foo :: a -> IO ()
23:13:38 <maurer_> and I want to be able to marshal and unmarshal things of type
23:13:38 <maurer_> data Foo = forall a. (Fooable a) => Foo a
23:32:13 <Jafet> maurer: how do you know what type to deserialize?
23:41:25 <maurer_> Jafet: Try all of them, pick the one that doesn't error?
23:43:15 <Jafet> Fooable is open, so you have to close it yourself at some point or other by manually specifying all the Fooables to try.
23:52:48 <adnap> when is FlexibleInstances okay to use?  is it okay when you know you're never going to want a different instance?
