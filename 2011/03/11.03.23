13:42:15 --- topic: '["new! Haskell Platform 2011.2: http://is.gd/dCGPn", "Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
13:42:15 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Thu Mar 10 14:01:45 2011]
13:42:15 --- names: list (clog Igloo Phantom__Hoover _bob dancor gigabytes TheZimm cwillu_at_work paolino sonoflilit devon2009 conal gio123 heatsink alek_br gemelen jem777 Saladpie zelvosaur cjay_ pacak rsuniev-a mauke ousado mceier_ BlankVerse Tor__ sritchie_ ketil TomMD rtharper baldo LouisJB shutdown_-h_now kmels__ rostayob nick8325 beastaugh lpsmith pozic gniourf_gniourf revenantphx cheater00 asflierl ormaaj jeltsch Zephyrus arsenm piotr__ bgs100 mmaruseacph2 _ay_ ulfdoz lcfrs)
13:42:15 --- names: list (otulp moisan iago c_wraith dark Ragnaroek Jonno_FTW Cobra__ dolio micrypt Cthulhon| fryguybob Tomsik mreh Athas der_eq Rayne ab3 Baughn stroan tensorpudding path[l] pheaver lbc sepp2k pikhq bharath_g mee raichoo lantti SirPlus dkasak flux cozmic arnihermann niko zodiak kaini danten rando roconnor gerard0 idnar iFire elliott saiko-chriskun Guest50988 mrsolo ymasory morphling jystic poincare101 bos lopex killown mzero rononovski_ hircus_work ahihi2 xinming rdd)
13:42:15 --- names: list (Nisstyre artefon jmelesky SyntaxNinja ndrsndrs _8david _nickel arjanb neurogeek quetzal- emmanuelux amiri_ sm anonymo3 FUZxxl Jantaro ttt-- sbahra homie```` adlan doserj lispy twanvl fhs devinus_ saml myu2 xenocryst edon nniro igorgue mpiechotka smerz Runar boscop xplatoid copumpkin blueonyx PepeSilvia Icewing corruptmemory Adamant PhilRod_ adrake gwern zax carlocci Palmik azaq23 Spockz Pewpewarrows JimmyRcom emporas sjanssen dschoepe slabanja FireFly)
13:42:15 --- names: list (alex404_ barik Darkone HugoDaniel phyrex1an Twey ClaudiusMaximus moshee Guest24945 TacticalGrace jrib ceii_ Shown gaddafi joeytwiddle Mreric Fuco dimmy dual dcoutts_ jendap Chaze kaf3ii dogmaT janbanan pi8027 spirit trin_cz insomniaSalt Jafet kevinww hammi derekwright clanehin brisbin ExtraSpice Axman6 dleslie hackagebot shintah liyang jaspervdj ankit9 dreixel ivan anonus monochrom ChongLi_ scm wagle Aestas em yitz robinbb mgsloan alip TheMoonMaster otto_s)
13:42:15 --- names: list (helgikrs ceii augur Sunhay eno aavogt jethomas jmcarthur npouillard jameyo cubi oc80z arlinius Hunner zygoloid Philippa pantski ps-auxw tridactyla siracusa antonh palmje theorbtwo parcs [mth] hzh_ Hugglesworth dobblego sipa Muad_Dibber spb fcr tengen ajhager joaopizani duairc_ stesh_ dumael Denebola novas0x2a PreciousMetals thorkilnaur Astro nlogax osoleve akosch ambroff jyyou Nshag tieTYT2 snapcase osfameron mun obcode joe6 n0tk ryant50001 jonrh jb55 OODavo)
13:42:15 --- names: list (setmeaway tmielika vav FDFlock smadge JaffaCake davidlee anderson fabjan muep m3ga Bwild Niedar ray alexsdutton milli duckinator Vorpal BMeph Eladith bhungy comak Eliel sajkr ksandstr wto drbean absentia szbalint Adman65 sshc dibblego dagle wisemanby hiredman damex willb funscala1 proq mimi_vx downhill Botje deggis araujo ricky Ptival Younder kelvie_ tamiko cognominal sonnym dino- lsthemes integral olsner frerich CosmicRay tildedave Fullma jcapper nothingmuch)
13:42:15 --- names: list (lyn ngochai zong_sharo Tinned_Tuna mm_freak vili sShintah preflex herzen dfeuer flippo mlh Vq borism jledbetter djanatyn marienz perlite tomaw schroedinbug kermit jmv benmachine almostsix jnj aiko lostman__ david` cafaro timestart owain thetallguy1 Philonous Ke flamingspinach MK_FG exlevan pantsd nchaimov derrotebaron miloshadzic taruti sordina kolmodin jedai anders^^ copton DRMacIver snorble Zeiris ddarius Nereid gbacon skaar andersk fihi09 kniu mikeg)
13:42:15 --- names: list (thetallguy \yrlnry DrSyzygy liw `0660 canvon jonafan sidek ace2001ac faluf companion_cube orbitz zenzike earthy ilab Snufsen cizra rwbarton geekounet etabot edenc Nemykal Bleadof aleator ion politik xplat rothwell qebab omgub KaneTW Cale kalven ortmage jix BONUS alpounet Gertm mafs drhodes BrianHV bd_ carrbs Raynes newsham c1de0x ski SonicvanaJr pygmalion Gunni MrDomino birkenfeld Paradox924X KitB lambdabot Nanar welterde EvanR-work malorie appamatto Vulpyne)
13:42:15 --- names: list (hpc MarcWeber _soro_ gseitz wires` nominolo guerrilla Yahovah_ lunaris eL_Bart0 ixzkn_ int-e elliottt davidL kosmikus mrshoe dilinger jamwt mattam kakeman Boney profmakx jho alexsuraci mike1703 ernst hvr alexbobp znutar Khisanth Innominate shepheb etpace LiteralKa pingveno ido poucet cathper jknotten Seta00 abojep gredman Bassetts solidsnack EvanCarroll brett majoh suiside _erik comex andrewsw bqf Obfuscate jssanders agemo FauxFaux solarus aculich eyck)
13:42:15 --- names: list (koala_man thoughtpolice Laney hc faj ville Mitar PHO_ sophacles SimonRC jayne regalia a11235 @ChanServ zomg Rooz bxc Fingerzam dionoea CindyLinz jrockway freedrool sbok pettter cncl_ mietek Lemmih nornagon oc udoprog mrd Saizan jml gdsx snarkyboojum harlekin felipe_ yahooooo soeren xinitrc_ deavid Draggor quicksilver emias dons cpa electrog1ek timchen1` idoru dcoutts septomin Veinor opqdonut Zao robinsmidsrod Ferdirand tromp__ Arnar dmwit janne- plan ziman)
13:42:15 --- names: list (jackhill_ klugez ihckt_ ehamberg dqd mjrosenb nimred noddy2000 Ornedan_ hellige_ larsrh mux mornfall Aisling Heffalump McManiaC angstrom koninkje_away trez cynick tafryn davean_ jdsc AnAdorableNick saurik hyko Jaak impl chromakode Gilly untwisted DustyDingo periodic ReinH pr Martty killing-joke dixie Zol jlouis xarch ahf ToRA saiam Boxo ibid scsibug chitragupt kloeri Starfire bezik flori erk go|dfish joni6128 dom96 jvogel kelvie shamster_ ahihi2__ arkx)
13:42:15 --- names: list (samferry Dashkal Liskni_si aristid mercury^ eZet Maxdamantus tessier blackdog scree freiksenet dRbiG inimino museun MasseR jd10 rokoteko pastorn raek magicman _mpu holgr meadowlark ezyang byorgey dcolish jbauman ian_mi inr liesen noj djahandarie tlonim ccasin sigue caligula_ srcerer confound cyanoacry _2x2l norm2782 StoneToad dropdrive pesco MacCoaster Belgarion_ Neronus __marius__ kaol b52 ibt mortberg Entroacceptor Cerise Gracenotes abbe alios tew88 TML)
13:42:15 --- names: list (OnionKnight dorkitude tmuki hgolden minsa johs KittenBitten maurer_ allbery_b Taggnostr2 ollip wolverian jlewis tswett burp koniiiik brixen shachaf sohum whoops ve Silex tlockney cibs troofax Raku^ gereedy zakwilson)
13:42:15 -asimov(freenode.net)- [freenode-info] help freenode weed out clonebots -- please register your IRC nick and auto-identify: http://freenode.net/faq.shtml#nicksetup
13:43:35 <paolino> c_wraith: what is the difference between the 2 ? 
13:44:04 <paolino> TMVar / MVar
13:44:25 <c_wraith> paolino: TMVar is built on top of STM.  It uses optimistic (non-locking) retry logic.
13:44:55 <c_wraith> paolino: MVar is a primitive provided by GHC.  It provides locking logic for readers/writers
13:44:57 <osoleve> how do i collapse a list of strings into a single string?
13:45:05 <paolino> :T concat
13:45:11 <osoleve> thanks
13:45:11 <roconnor> :t concat
13:45:12 <lambdabot> forall a. [[a]] -> [a]
13:45:30 <tromp__> :t join
13:45:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:46:47 <c_wraith> paolino: their specified behavior is essentially the same, except for in the case of an STM rollback, TMVar reads/writes will be rolled back too, if they were part of the same transaction.  MVar is atomic by itself, and never part of a larger transaction
13:46:53 <osoleve> hahaha that was dumb. i wanted to collapse a list of strings into a single string at the end of a function that does exactly the opposite
13:46:56 <osoleve> nevermind
13:47:25 <osoleve> i've got to go hit an NA meeting, i'll figure out the real issue a little later
13:47:27 <c_wraith> paolino: their non-specified behavior is essentially opposite though, in that TMVar is optimistic and non-locking, while MVar is pessimistic and locking.
13:47:56 <kniu> Are there doubly-linked lists in Haskell?
13:48:18 <kniu> well
13:48:42 <companion_cube> maybe you can use a zipper on lists instead
13:48:45 <Jafet> Sure.
13:48:52 <paolino> c_wraith: ok, adding atomically to all the TMVar functions, are they still different ?
13:49:07 <Jafet> A bit tricky, though, on account of immutability and stuff
13:49:18 <kniu> I just want (++) to be O(1), really.
13:49:35 <Saizan> you can do doubly linked lists with IORefs if you really want :)
13:49:44 <pozic> Or with STRefs..
13:49:49 <Jafet> Any kind of operation on a doubly-linked list is O(n)
13:49:57 <Jafet> You have to return a new doubly-linked list.
13:49:59 <osoleve> couldn't youjust cons the end of the list to the beginning of the list?
13:50:02 <roconnor> ++ is O(1) for dlists
13:50:12 <Jafet> Perhaps you want Data.Sequence.
13:50:13 <c_wraith> paolino: yes, they are, in the matter of how they handle contention.  STM is much worse under contention, because of its optimistic strategy
13:50:21 <Saizan> yeah, you just need DList, i.e. [a] -> [a]
13:50:35 <djahandarie> kniu, see Data.Sequence (finger tree) or DList (CPS transformed List)
13:50:44 <osoleve> wait, i'm thinking of a circularly linked list. nvm.
13:50:58 <c_wraith> > cycle [1..5]
13:50:59 <lambdabot>   [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,...
13:51:10 <c_wraith> that's a singly-linked circular list :)
13:51:27 <pozic> What is an NA meeting?
13:51:46 <osoleve> narcotics anonymous
13:51:59 <jeffwheeler> Does the bytestring-mmap package require that I have some linux system package installed? I'm getting weird assembly messages when I try to install the latest version on GHC 7.
13:52:04 <Jafet> Circular?
13:52:21 <pozic> osoleve: heh, I thought you were joking.
13:52:26 <jeffwheeler> But I expect that it /should/ work because I think other things (like Hakyll) should work on 7.0.
13:52:42 <jeffwheeler> (This is the error I'm getting: "Error: .size expression for __stginit_bytestringzmmmapzm0zi2zi1_SystemziIOziPosixziMMapziInternal does not evaluate to a constant")
13:52:48 <osoleve> pozic: nope! didn't expect there'd be junkie coders, huh? :-P
13:52:52 <osoleve> time to roll, bug ya guys later
13:52:54 <kniu> okay, those would help
13:52:55 <kniu> thanks guys
13:53:17 <thoughtpolice> jeffwheeler: hm, i just installed bytestring-mmap-0.2.1 on linux/x86_64, ghc 7.0.2
13:53:26 <pozic> osoleve: one could say that some Haskell programmers are on crack, but that they really were... no :)
13:53:39 <thoughtpolice> jeffwheeler: to answer your question, i don't think it does. that error seems a little scarier, perhaps a NCG bug?
13:53:42 <jeffwheeler> thoughtpolice: hmm, I wonder what's going wrong. I have 7.0.2. on x86_64. Ubuntu.
13:53:58 <kniu> also, what if list syntax were polymorphic, like OverloadedStringLiterals?
13:54:13 <jeffwheeler> thoughtpolice: I've seen errors like this in the past. Maybe I can have it compile with llvm or something.
13:54:28 <kniu> It would be nice to get rid of all those fromList calls.
13:55:23 <Jafet> kniu: your code will get longer and more complicated on account of the extra type signatures
13:55:38 <jeffwheeler> thoughtpolice: oh, yeah. Removing the '-fvia-C' flag in the cabal file works . . . I hope it's actually built correctly now.
13:55:55 <xplat> you should be able to make list syntax polymorphic with -XRebindableSyntax probably ... some of it even without, just by hiding parts of the prelude ...
13:56:07 <thoughtpolice> jeffwheeler: strange! maybe you should bug #ghc though, that actually sounds like it might be a bug. at least to me
13:56:19 <jeffwheeler> thoughtpolice: will do
13:56:40 <c_wraith> paolino: STM performs best when you have many different mutable cells, and each concurrent transaction updates a small, generally non-overlapping subset of them, so that contention is low.  When every transaction updates the same mutable cell, as in the case you suggest, every concurrent action is going to have conflicts, leading to heavily increased CPU usage.
13:56:42 <thoughtpolice> at least, I wouldn't think that -fvia-C would be the difference between compilation failure/success
13:56:52 <thoughtpolice> in principle it shouldn't, but there are always corner cases i suppose
13:57:06 <kniu> Jafet, I thought we're not in Java land anymore?
13:57:24 <kniu> The length of types matters little if they're inferred anyway.
13:57:53 <kniu> And we already have overloaded number literals and overloaded string literals.
13:58:00 <Jafet> kniu: we're in Haskell land, where all code is as polymorphic as possible
13:58:22 <Saizan> not really
13:58:33 <Saizan> though we have monad comprehensions back now
13:58:40 <Saizan> so there's hope!
13:58:42 <xplat> but no polymorphiccer?
13:58:47 <thoughtpolice> i don't think it's merged in yet, but it will be soon i believe
13:58:52 <thoughtpolice> (monad comprehensions that is)
13:59:08 <paolino> c_wraith: clear, thanks
13:59:10 <Saizan> oh, let's hope 
13:59:51 <ketil> paolino: I'll add that you can compose STM transactions into bigger ones with less trouble than locking (MVar) operations.
14:00:21 <ketil> or.. with different trouble, rather :-)
14:01:20 <paolino> ketil, live locking ..., don't mix big and small transactions
14:01:38 <pozic> Is STM fundamentally slower than MVars?
14:01:51 <c_wraith> pozic: not in its prime use case
14:01:59 <paolino> not when MVars deadlock :p
14:02:23 <pozic> c_wraith: I mean in all cases where the MVars would result in a computational valid result.
14:03:08 <Saizan> when there isn't high contention STM should be even faster?
14:03:18 <c_wraith> pozic: In the case of "thousands of mutable cells, you generally update 4 or 5 atomically, and generally don't overlap with other transactions", it will likely be faster than using MVars, due to not locking
14:04:04 <c_wraith> pozic: even ignoring the correctness issues of losing atomicity
14:04:29 <pozic> c_wraith: most benchmarks show STM is slower than MVars (or locking using the C primitives for that matter).
14:05:03 <c_wraith> Hmm.  It's fully possible STM isn't ever faster...  But there are cases where it's more correct.
14:05:13 <pozic> c_wraith: IMHO, if you build the best possible compiler you could have the advantages of STM (composability), and correctness.
14:05:17 <c_wraith> and it's also often much easier to reason about
14:05:24 <pozic> c_wraith: and performance, of course.
14:05:40 <pozic> We already posisble have the first two, of course.
14:05:51 <pozic> I.e., I do not see any reason for it being slower. 
14:06:01 <sin3141592> I was just wondering why Haskell has an ‘if’ language construct. Since it is pure and non-strict, a simple function should suffice. Am I missing something?
14:06:05 <c_wraith> the current STM implementation is *really* bad under high contention, though.
14:06:12 <pozic> It is just that the implementation of the language STM does things in a particular (non-optimal) way.
14:06:14 <c_wraith> sin3141592: nope.  Lots of us wish if wasn't syntax
14:07:06 <pozic> (You can do the same in Java, btw.)
14:07:26 <sin3141592> c_wraith: It seems like a really bad design decision considering that Haskell provides these wonderful features to support it so easily.
14:07:27 <pozic> In Java you have to mark stuff as synchronizing variables, etc. 
14:07:34 <c_wraith> It's conceivable to implement multiple different backends for STM
14:07:44 <pozic> It could also simply synchonize everything by default and optimise from there. 
14:07:47 <c_wraith> But so far, the people who have tried it have been unhappy with their results
14:08:11 <jmcarthur> STM is often very fast so long as you have fine-grained transactions
14:09:03 <pozic> The problem with STM is that you lose progress, right?
14:09:28 <pozic> If you compile STM to locks behind the scenes then you do not. 
14:09:35 <Zao> All you need is some unsafePetCat
14:09:46 <c_wraith> pozic: well, not lose...  The progress was wrong.  It has to be restarted, correctly this time. :)
14:09:55 <pikhq> pozic: That certainly is something to *consider* in your usage of STM.
14:10:05 <pozic> c_wraith: progress has a specific meaning in this context.
14:10:07 <jmcarthur> c_wraith: that is kind of unique to the optimistic implementation
14:10:15 <pikhq> You really prefer not to have to redo very large transactions.
14:10:20 <c_wraith> pozic: But yes, the problem is you can often restart your transaction due to rollbacks.
14:10:31 <pozic> c_wraith: not often, but unbounded, right?
14:10:36 <c_wraith> jmcarthur: and yes, we're talking about the current implementation
14:10:37 <pozic> I.e., no progress.
14:11:25 <jmcarthur> pozic: there is no guarantee that a particular transaction will complete, even if it would have completed in complete isolation of other transactions
14:11:34 <c_wraith> well, there will be some progress.  *one* transaction has to commit in order for the rest to be rolled back.
14:11:47 <jmcarthur> yeah there is global progress
14:11:47 <pikhq> In any case, I wouldn't be surprised *or worried* that STM has lower performance than more primitive methods of parallelism.
14:11:55 <pikhq> The trick with STM is that it's easier to *reason about*.
14:12:12 <pikhq> Which is a very significant advantage.
14:12:19 <pozic> pikhq: the thing is, all the people that build large systems, want their systems to work fast. 
14:12:33 <jmcarthur> *fast enough
14:12:34 <pikhq> pozic: Big deal.
14:12:41 <c_wraith> jlouis did combinatorrent with STM, right?
14:12:52 <c_wraith> I feel like that's a perfect use case for it
14:12:53 <pikhq> pozic: Parallelism is desirable in almost any case you can actually manage it these days.
14:12:53 <pozic> pikhq: they can pay $10M to pay an expert programmer team to save $100M in hardware costs.
14:13:15 <pikhq> Even on fucking *cell phones*, you're going to want parallelism now.
14:13:21 <jmcarthur> programmers vs. hardware is not an issue that everybody agrees on
14:13:32 <jmcarthur> it probably just depends on the project
14:13:34 <c_wraith> jmcarthur: because the answer changes depending on your scale
14:13:38 <pikhq> And in those cases, programmer time is often (though not always) a higher priority.
14:13:39 <jmcarthur> right
14:14:27 <pikhq> Still, it depends, yes. If CPU time is your priority, you're probably not going to care too much about abstractions with even vaguely notable cost.
14:14:48 <proq> except that on the most prevalent smart phone right now (iphone) it is not much work with GCD
14:15:28 <jlouis> c_wraith: right. Combinatorrent is STM all over the place
14:15:32 <pikhq> proq: GCD is an example of an abstraction of parallelism with some amount of cost.
14:15:46 <c_wraith> jlouis: and you're happy with the abstraction STM provided for that?
14:16:02 <jmcarthur> generally, STM excels with a huge number of fine-grained transactions with very little contention
14:16:23 <jlouis> Yes, but STM is a *concurrency* primitive, not one for *parallelism* (although it does provide some)
14:16:51 <pikhq> jlouis: Oh, sorry, right, it's a concurrency primitive which can be beaten into doing some parallelism.
14:16:59 <proq> oh nice I haven't seem STM yet, just what I was looking for to play with my new 6-core machine
14:16:59 <jlouis> exactly
14:17:07 <pikhq> The distinction is pretty dang important.
14:17:12 <pozic> Not that parallelism vs concurrency discussion again...
14:17:28 <jlouis> If I were to do parallel stuff, I'd probably not start off by looking at STM
14:17:29 <jmcarthur> i would never consider STM for anything to do with performance (not that i'm saying STM is too slow for high-performance systems)
14:17:42 <jmcarthur> what jlouis said
14:17:53 <jlouis> it is a nice tool to have in the toolbox later on, if sharing is needed
14:18:00 <pikhq> pozic: What debate?
14:18:10 <pozic> Let's just agree to use whatever people wrote in actual books to be the definition of those concepts, not what some random guy on a blog claims (I do not care he is a professor). 
14:18:11 <jlouis> but the whole point of getting speed is to split up the computation so no sharing at all occurs
14:18:16 <jlouis> (for the major parts)
14:18:43 <jlouis> pozic: You mean Harper?
14:18:46 <proq> jlouis: what would you start off with?
14:18:46 <pozic> jlouis: yes
14:18:49 <jmcarthur> pozic: there isn't any debate about this...
14:19:04 <pozic> jlouis: I do not see there is anything 'well-known' about him. 
14:19:10 <jlouis> pozic: Currently I am counting Bob Harper, Myself, Simon Marlow and Rob Pike among those who has that world view :P
14:19:23 <pikhq> They have very meaningful distinctions, with quite seperate design considerations and different use cases.
14:19:27 <pozic> jlouis: the thing is, that doesn't count for me :)
14:19:43 <pikhq> And it just so happens that you can pain-stakingly use concurrency to implement parallelism.
14:19:46 <pozic> jlouis: point me at books that contain proof for what they say. 
14:19:56 <pozic> jlouis: books that are relatively old. 
14:20:04 <jmcarthur> you use parallelism for performance and concurrency for different logical processes. our hardware happens to require concurrency for a lot of parallelism, but that doesn't really mean we have to write parallel code at such a low level
14:20:52 <jmcarthur> pozic: modern academic literature is insufficient? why must it be an old definition?
14:21:10 <jlouis> 1935 is old enough :)
14:21:25 <pikhq> pozic: Is the par function in any meaningful way doing the same thing as mvars?
14:21:47 <pozic> jmcarthur: literature made up by some guys/group that happened to interact does not count. The references I have, which I am not going to name, have a different idea, which is consistent with tons of literature. 
14:21:48 <jlouis> anyway, for concurrency I was quite happy with STM
14:21:54 <jlouis> I tried the CML library as well
14:22:03 <jmcarthur> pozic: which you're not going to name...
14:22:14 <proq> oh nevermind I've looked at STM before 
14:22:15 <jlouis> but that one leaks certain things (Process Ids of concurrent stuff change)
14:22:18 <jmcarthur> pozic: you ask for citations and refuse to offer your own?
14:22:24 <pozic> jmcarthur: entirely correct.
14:22:52 <jmcarthur> well, there goes any motivation for anybody to even attempt to satisfy your request, then
14:22:54 <pikhq> pozic: Okay, you're holding a different standard of proof for yourself than for us. This is not a discussion, this is at best a sharing of dogma.
14:23:04 * hackagebot snappy 0.1.0.0 - Bindings to the Google Snappy library for fast compression/decompression  http://hackage.haskell.org/package/snappy-0.1.0.0 (BryanOSullivan)
14:23:17 <bos> yay https://github.com/mailrank/snappy
14:23:22 <pozic> pikhq: I am not here to teach everyone. 
14:23:35 <pozic> pikhq: I might pick up something here, I might teach someone something, but that's it.
14:23:37 <jmcarthur> i would generally say that the burden of proof is on the one who is refuting experts in the field
14:23:45 <pozic> jmcarthur: I do not count them as experts.
14:24:12 <pozic> I think Lamport invented some old algorithms in that area. 
14:24:39 <pozic> If you find a book written by him claiming these definitions, I might consider to start thinking of those concepts in a different way.
14:24:52 <pozic> Until then, I will just assume that my education was better in that area. 
14:25:06 <jmcarthur> in any case, it isn't the majority's responsibility to convince the minority of anything, so if you want to continue communicating ineffectively with others then be my guest
14:25:16 <c_wraith> bos: does it include the C source for the library, or do I need to install it separately?
14:25:29 <pozic> jmcarthur: what makes you think it is the majority?
14:25:38 <jmcarthur> words are defined however people use them
14:25:40 <bos> c_wraith: separate
14:25:41 <pozic> jmcarthur: perhaps it is a USA school kind of thing. 
14:26:03 <thoughtpolice> bos: ooo!! i just finished a binding to quicklz last week, I was looking at snappy (it seems to have very comparable compression/decompression rates and a non-gpl license)
14:26:06 <proq> pozic: it's a fallacy to think that something has to be in a book to be a rational argument
14:26:06 <jmcarthur> pozic: not all names mentioned so far are from the US
14:26:12 <thoughtpolice> bos: it seems you beat me to that :)
14:26:40 <bos> thoughtpolice: about an hour's work :-)
14:26:52 <pozic> proq: I never said that. 
14:27:02 <thoughtpolice> bos: yeah, like quicklz it has a remarkably simple interface - easy peasy for the FFI :)
14:27:31 <bos> thoughtpolice: the only downside is that doing a lazy binding looks like more work
14:27:34 <proq> pozic: no, you implied it.  otherwise why mention that it needs to be in a book
14:27:56 <jmcarthur> i make no claims about the universality of these definitions for concurrency and parallelism. at least here in #haskell, however, we have found it useful to distinguish them, old books be damned.
14:28:04 <Saizan> we could just drop the topic of how to call those.
14:28:04 <thoughtpolice> bos: interestingly, snappy in general seems to be as fast as quicklz on compression, and much faster on decompression. an even better case for this, is that quicklz has to statically choose at compile-time a compression setting to use, which greatly affects compression speed/decompression speed/compression ratio
14:28:11 <thoughtpolice> bos: snappy seems to be much more 'consistent'
14:28:19 <Saizan> it's as pointelss as a GPL vs. BSD debate
14:28:21 <pozic> proq: no, I did not. Books exist to get some minimal amount of weeding out of complete idiots. 
14:28:26 <jmcarthur> and arguing about it is unproductive. look how far from the original topic we have strayed
14:28:46 <c_wraith> jmcarthur: at least the original topic was covered pretty thoroughly first
14:28:50 <thoughtpolice> bos: yeah, I was having issues too for another reason. quicklz has a streaming mode, but enabling it and compiling code with GHC causes both very strange test results at the best, and segfaults at the worst.
14:29:05 <pozic> So, again, is there any fundamental reason according to you which makes STM forever fundamentally slow?
14:29:08 <thoughtpolice> i haven't figured it out yet, so i haven't written any lazy/enumerator based bindings for quicklz. strict bytestrings only for now until I figure it uot :/
14:29:19 <pozic> No/Yes, because...
14:29:20 <jmcarthur> pozic: i don't think it's fundamentally slow at all
14:29:38 <pozic> jmcarthur: that is how I see it too. Anyone with a different idea?
14:29:39 <jmcarthur> pozic: the current optimistic implementation is very fast for certain kinds of workloads, as i said earlier
14:29:44 <jmcarthur> okay :)
14:29:44 <bos> thoughtpolice: ouch
14:30:00 <pikhq> pozic: It's not fundamentally slow; it's merely that the current implementation is designed for certain workloads and is slow in other sorts of workloads.
14:30:20 <pozic> pikhq: right, but this algorithm could be changed such that it also works of other work loads.
14:30:27 <pozic> for*
14:30:33 <pikhq> Hypothetically? Certainly.
14:30:52 <pikhq> I'd imagine it'd work best with hardware designed around transactional memory, though.
14:31:07 <jmcarthur> i'm doubtful that any one implementation would be ideal for all workloads, though
14:31:09 <c_wraith> "also" is a bit optimistic.  I'd say there are tradeoffs involved.  It might be best to allow runtime-swappable backends
14:31:22 <pikhq> (though I have no idea if it'd be practical to design such hardware)
14:31:26 <pozic> I think that is an important argument to be made in texts advocating STM. 
14:31:31 <jlouis> The only thing I dislike about STM is that you have sharing
14:31:38 <jmcarthur> yes!
14:31:44 <jlouis> but that is not part of fast/slow
14:31:51 <pozic> "Yes, it is not optimal for everything Right Now, but this can be fixed".
14:32:07 * hackagebot hamlet 0.7.3 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.7.3 (MichaelSnoyman)
14:32:09 * hackagebot yesod-core 0.7.0.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.7.0.2 (MichaelSnoyman)
14:32:13 <pozic> STM could actually _fix_ some problems. 
14:32:18 <jlouis> Then again, I've made my point clear a couple of times: I believe in message passing, not STM
14:32:21 <jmcarthur> i'm not a huge fan of shared-memory concurrency. even with stm, it feels very low level
14:32:24 <jlouis> for concurrency
14:32:25 <thoughtpolice> bos: very ouch. streaming mode enabled shouldn't affect correctness, but it sure as hell does. i haven't yet pinned it down to some oddity in GHC or quicklz, although the test failure/segfault results are consistent across both linux/OS X with ghc7. i actually wonder if it has something to do with the size of quicklz compression/decompression state
14:32:29 <jmcarthur> i'm also not sure about message passing
14:32:42 <jlouis> MP is very imperative
14:32:42 <Saizan> pozic: before saying that you should have some idea of how to fix it though
14:32:50 <jmcarthur> i think there is a lot of potential in process calculii
14:32:53 <thoughtpolice> (by default, the buffer to handle quicklz state is about 32k, and enabling streaming will at least increase that by 10,000 bytes)
14:32:55 <pozic> Saizan: I have some idea of how to fix it myself.
14:33:00 <pikhq> jlouis: It seems to me that we just don't really know what abstractions work best.
14:33:04 <pozic> Saizan: I am not going to say that on some blog :)
14:33:11 <jmcarthur> some more than others of course
14:33:17 <jmcarthur> a lot of them *are* message passing
14:33:21 <pikhq> We just know that some are positively terrible.
14:33:31 <c_wraith> I think a lot of heavy erlang users have declared that message passing breaks down eventually, too
14:33:43 <pozic> You can rewrite message passing to STM and the other way around.
14:33:44 <jmcarthur> i'd believe it
14:33:53 <jlouis> pozic: yep :)
14:33:54 <Saizan> pozic: ah, so this was a giant build up to this bragging?:)
14:33:55 <pozic> It is meaningless from a formal point of view.
14:34:15 <pikhq> I seem to recall that some usecases for message passing turn into standard locking.
14:34:17 <jlouis> c_wraith: breaks down? I haven't heard that view
14:34:27 <pozic> Saizan: an idea and a proof of correctness down to the asm level are two different things.
14:34:29 <jmcarthur> all turing complete languages are the same?
14:34:30 <c_wraith> jlouis: turns into spaghetti code, in particular
14:34:43 <pikhq> pozic: From a formal point of view they're all just as expressive as Brainfuck.
14:34:57 <jlouis> c_wraith: the same way as encoding everything in strings in Haskell does :)
14:35:00 <jmcarthur> for some definition of "expressive"
14:35:15 <c_wraith> jlouis: so you think typed message-passing would be better?
14:35:24 <pikhq> jmcarthur: Equally capable of expressing all that is computable. :P
14:35:25 * jmcarthur looks up the definition of expressive for once...
14:35:35 <hpc> "typed $x" is quite frequently better than "$x"
14:35:43 <jmcarthur> "Effectively conveying thought or feeling."
14:35:43 <pozic> Felleisen (or however it is spelt) claimed to have defined expressive.
14:35:59 <jmcarthur> so i guess it depends on if you mean expressive to the computer or expressive to humans
14:36:23 <jlouis> c_wraith: It is different, but yes, a statically typed MP beats a non-static version in my opinion
14:37:22 <jmcarthur> IMO, static types go somewhat against what erlang is all about
14:37:27 <c_wraith> I suppose that's a fair hypothesis.  It's not one that's really been tested in large applications.
14:37:29 <jlouis> dynamic typing doesn't hurt that much in Erlang due to: a) Process isolation and b) the dialyzer (static type analysis/inference)
14:37:39 <jmcarthur> there are very few languages i would say that about
14:38:40 <jlouis> you should be pretty well driving if you add polymorphic variants for messaging I think
14:38:52 <jlouis> (to Erlang)
14:39:08 <jlouis> it gives fewer guarantees, yes, but it would work
14:39:22 <ddarius> pozic: He claimed to have given one definition of relative expressiveness.
14:40:00 <jlouis> another path is to make messages generic (as in haskell generics)
14:40:04 <shachaf> @learn -- broken link.
14:40:04 <lambdabot> http://www.haskell.org/learning.html
14:40:16 <Boxo> Some language comparison defined expressiveness as size of gzipped code
14:40:37 <ddarius> The general idea behind Felleisen's definition is intuitive and reasonable.
14:41:05 <pozic> ddarius: oh, I thought the paper was not that bad. 
14:41:19 <thoughtpolice> Boxo: that would be the shootout. they do gzip-based metrics because it really accounts for "amount of code", but you don't want to take whitespace into account, etc (otherwise a clusterfuck can be deemed "more expressive" than python where whitespace is significant)
14:41:35 <ddarius> Though, it does have the consequence of (using it non-rigourously) placing Haskell closer to the bottom end of expressiveness as compared to most languages.
14:42:02 <hangs> hi, sorry if this is a newbie question. I'm getting a compile error that I can't understand
14:42:02 <pozic> Forth would probably be the most expressive then. 
14:42:03 <thoughtpolice> i still don't think that's a good, or even very meaningful metric though. ioguy would probably have something to say about that though (like he does abotu anything relating to ever questioning the shootout, its implementation or purpose)
14:42:11 <hangs> the code is here http://hpaste.org/44978/test
14:42:27 <hangs> runghc says: 2.hs:35:9:     No instance for (Num [Char])       arising from a use of `writeLoop'     Possible fix: add an instance declaration for (Num [Char])     In a stmt of a 'do' expression:         writeLoop (Set.toList cities) cityNameToGeocode geocodeToLatLong 
14:42:48 <pozic> hangs: you are adding two Strings.
14:43:23 <pozic> hangs: "hi" + "hello" => uhm, wtf?
14:43:46 <djahandarie> :t (++)
14:43:47 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:43:52 <djahandarie> God damn it lambdabot
14:43:57 <djahandarie> :t (P.++)
14:43:58 <lambdabot> Couldn't find qualified module.
14:44:02 <djahandarie> :t (Prelude.++)
14:44:02 <lambdabot> forall a. [a] -> [a] -> [a]
14:44:08 <c_wraith> hangs: in particular, that error message says "You told me to add these two values together, which means their type must be an instance of Num.  But I can't find an instance of Num for String ([Char] is the same as string)"
14:44:26 <MasseR> Where is the monoid (++) version from? (package/module)
14:44:33 <djahandarie> MasseR, it's just defined in lambdabot
14:44:39 <djahandarie> (As (++) = mappend)
14:44:47 <hpc> pozic: i don't see where he is doing arithmetic on strings
14:44:48 <MasseR> Oh :/
14:45:00 <pozic> hpc: I didn't look at the code. 
14:45:09 <pozic> hpc: he must be doing something like that.
14:45:16 <hpc> yeah, i thought so too
14:45:26 <hpc> but his code doesn't have anything but (++)
14:45:28 <hangs> uh, i'm using only ++
14:46:09 <djahandarie> hangs, write your type annotations for all the top-level declerations.
14:46:22 <monochrom> what should the types be of cityNameToGeocode and geocodeToLatLong?
14:46:27 <benmachine> hangs: is that error message exact? it refers to line 35 which is empty?
14:46:32 <hangs> both are Maps.
14:46:50 <hpc> hangs: add type signatures to things
14:46:51 <djahandarie> @type lookup
14:46:51 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:46:54 <benmachine> hangs: I'd advise giving explicit type signatures to top-level bindings; sometimes this leads to better error messages
14:46:59 <djahandarie> @type M.lookup
14:46:59 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
14:47:29 <hpc> hangs: "tokenize :: thing -> other thing -> more stuff"
14:47:30 <hpc> etc
14:48:10 * hackagebot tls 0.5.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.5.1 (VincentHanquez)
14:48:12 <hangs> monochrom: both are Data.map. cityNameToGeocode is a map String -> String while geocodeToLatLong is String -> (double, double) for the lat and long
14:48:38 <hangs> benmachine: sorry that error message is actually on line 33 of the version in hpaste
14:49:10 * hackagebot tls-extra 0.1.2 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.1.2 (VincentHanquez)
14:49:32 <hangs> benmachine: it's actually at the call to writeLoop in main
14:50:17 <hangs> hpc: oh dear. i was hoping to avoid writing types, i find them confusing. but maybe i have to. is this common in haskell?
14:50:29 <pozic> hangs: you are already confused.
14:50:36 <benmachine> hangs: it's common practice to give all top-level bindings type signatures
14:50:40 <pozic> hangs: the good programmers don't need to write them ;)
14:50:48 <benmachine> oh, I always do
14:50:53 <benmachine> maybe I am not a good programmer :( :(
14:51:05 <hpc> benmachine: the good programmers don't have to, but they do anyway ;)
14:51:17 <hangs> benmachine: ok good to know that I'm not the only one. i was drinking the type inf kool aid
14:51:20 <G_Morgan> I always write type signatures. Then when I do something obviously stupid the type checker moans at me.
14:51:27 <hpc> the BEST programmers only have to write types
14:51:36 <hpc> and let a totally different program write the program you want
14:51:39 <hpc> :P
14:52:05 <benmachine> the super-best programmers just meditate, and then SD cards materialise in front of them
14:52:10 <monochrom> the file should have a parse error to begin with. line 48 semicolon
14:52:11 <benmachine> from chance fusion of air particles
14:52:12 * hackagebot tls 0.4.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.4.1 (VincentHanquez)
14:52:16 <hpc> lol benmachine
14:52:37 <benmachine> monochrom: I think that's not a parse error anymore, because of some silly extension
14:52:57 <Saizan> i generally put type signatures to toplevel bindings after the fact, taking them from ghci
14:53:06 <benmachine> ghc has a thing to print them
14:53:10 <djahandarie> I usually write my type signatures first
14:53:11 <G_Morgan> Wouldn't SD cards materialising be an impure operation
14:53:47 <pozic> I would also expect it to be a parse error. 
14:53:54 <hpc> aha! so the best-est-est programmers only write programs that were already there
14:54:02 <monochrom> silly extensions should get a {#- LANGUAGE DoIfThenElse #-} at the head of the file unconditionally. Do you actually want other people to reproduce your experiment or not?
14:54:23 <pozic> hangs: you should just like, debug.
14:54:38 <pozic> hangs: we can do it in a few minutes, sure, but that would destroy a learning moment :)
14:55:12 <benmachine> monochrom: it got into h2010 somehow I think :(
14:55:16 <pozic> hangs: if you do not understand some specific part of Haskell, you can show a minimal example and probably someone will say something useful.
14:55:18 <hpc> pozic: we are also lazy
14:55:19 <hpc> :D
14:55:22 <hangs> pozic monochrome: thanks. no change if i remove the semicolon
14:55:49 <hangs> yeah let me debug for a bit
14:55:51 <hangs> thanks 
14:56:32 <shachaf> monochrom: Whence "monochrom"?
14:57:34 <djahandarie> monochromium
14:57:59 <benmachine> hangs: -fwarn-missing-signatures will tell you the inferred types for the declarations you haven't given signatures
14:58:13 <hpc> ring, ring, ring, ring, ring, ring, ring... monophone! do do do-do do-do!
14:58:22 <pozic> I suppose it means that he has an opinion which is sophisticated and is not black/white. 
14:59:08 <monochrom> "getLetLong latLongH (Set.fromList (Map.elems cityNameToGeocode)) []" gives you "Map String (String,String)" not "Map String (Double,Double)". Clearly, parseCityCodeLine is producing String not Double.
14:59:11 <hangs> benmachine: thanks, that's helpful
15:00:00 <pozic> Then again, he might also use an ambiguous nickname like that on purpose to make it extra interesting or it was just random :)
15:00:09 <monochrom> and parseGeocodeLine either
15:01:40 <monochrom> hmm why the sudden interest in my nick?
15:02:38 <pozic> monochrom: shachaf asked.
15:04:31 <monochrom> unsophisticated people think that you need to be colourful to be interesting or fun. but monochromicity has much variation too. Chinese proverb: [black] ink has five colours. ("five" being a metaphor for "many")
15:06:05 <monochrom> For a long time ancient Chinese paintings used only black ink. Just by greyscale you already get rich and expressive paintings.
15:06:29 <pozic> monochrom: interesting.
15:06:40 <hpc> more so, sometimes; adding color makes it hard to see the shading
15:06:46 <pozic> monochrom: other cultures have similar proverbs. 
15:07:43 <G_Morgan> hpc: this is partly because the human eye sees better contrast with rods than with cones
15:07:55 <pozic> Is the five from a time that the Chinese didn't have a proper number system yet?
15:08:35 <pozic> Some cultures still strongly discourage the development of number systems.
15:08:42 <monochrom> no, the Chinese language has a habit of using concrete numbers to stand for adjectives like "several", "many".
15:09:44 <pozic> So, how can you say "The water varies between 5 colours"? 
15:10:12 <monochrom> we will just say exactly that.
15:10:26 <pozic> But how can someone understand whether it is many or 5?
15:10:32 <moshee> context
15:10:40 <monochrom> yes, it means the reader has to guess "does he literally mean 5 or does he just mean quite a lot?"
15:10:58 <pozic> That seems pretty annoying to use :)
15:11:01 <ddarius> Just like one has to do with English in regards to hyperbole.
15:11:16 <G_Morgan> How does a person know what I mean when I say "the world literally exploded"
15:11:37 <pozic> G_Morgan: sure, but numbers seem different.
15:11:46 <monochrom> "black ink has 5 colours" well if you can make 5 you can make 4 or 6 or 10. that consideration tells you "5" is being a metaphor or an example.
15:11:48 <ddarius> "I took on 50 guys."
15:11:50 <gwern> so, I'm using up my free $100 of AdWords, and I'm struggling - what keywords would someone search for who would like to read http://www.gwern.net/haskell/Archiving%20GitHub.html ?
15:11:54 <gwern> suggestions anyone?
15:12:05 <gwern> I have obvious things like 'haskell tutorial' and 'haskell github'
15:12:14 <monochrom> "I have 5 eggs" this is a falsifiable statement, so I really intend the literal 5.
15:12:26 <gwern> monochrom: You have two cows...
15:12:43 <ddarius> monochrom has e cows.
15:12:51 <G_Morgan> It also makes the Picard "there are 4 lights!" episode a little more confusing
15:13:15 <monochrom> disambiguating mathematicians' language is worse, amounts to GÃ¶del incompleteness.
15:14:29 <gwern> huh. the price for an click on the keyword 'haskell' is 14 cents.
15:14:34 * gwern feels vaguely ashamed and uncool
15:15:13 <shachaf> gwern: What about "curry"?
15:15:23 <gwern> shachaf: no way. I'd get blown away by food sellers
15:15:26 <gwern> and recipe sites
15:15:32 <pozic> gwern: what is the point of advertising?
15:15:38 * shachaf was hoping to help gwern feel better about himself.
15:15:47 <hangs> monochrom: sorry, i meant String instead of Double in the types.  i don't understand your reference to {#- LANGUAGE DoIfThenElse #-}. is that something I should put at the top of my life? I don't know what it does
15:15:48 <hpc> why would haskell need to be advertised?
15:15:53 <hpc> i thought we were avoiding success
15:15:57 <gwern> shachaf: I don't see how making blatantly bad suggestions makes me feel better :(
15:16:08 <jmcarthur> that's so 2007, hpc 
15:16:08 <Zearen> I am here to verify that data Dict k v = Dict (Maybe v) (Map.Map k (Dict k v))
15:16:15 <gwern> hpc: well, it says how small a market we still are, which is saddening
15:16:16 <shachaf> gwern: By raising the cost-per-click, I mean.
15:16:18 <monochrom> nevermind about {#- LANGUAGE DoIfThenElse #-}. I was using ghc 6.12 and you 7.0
15:16:18 <hpc> hangs: iirc it makes if-then-else not suck so hard when inside a do block
15:16:20 <G_Morgan> hpc: I think we failed badly at the avoiding success thing. Oh wait not we succeeded..
15:16:41 <Zearen> is an invalid type?  (Hello and sorry for the split line)
15:16:45 <hpc> G_Morgan: indeed; just enough success to paralyze us without any of the perks
15:16:48 <monochrom> no it makes if-then-else suck worse
15:16:49 <gwern> pozic: the point is to get more readers, use up my adwords coupon and learn how it works too
15:16:57 <hpc> monochrom: oh, lol
15:17:04 <niteria> is there a standard function like that: mix a b c = (head a):(head b):(head c) ++ (mix (tail a) (tail b) (tail c))
15:17:07 <niteria> ?
15:17:10 <pozic> gwern: why do you want more readers? To make the world think you are some special snow flake?
15:17:11 <gwern> I bet java adwords would cost a lot more
15:17:18 <gwern> pozic: yes. EVERYONE MUST LOVE ME
15:17:24 <hpc> niteria: zip and zipWith
15:17:26 <hpc> :t zip
15:17:27 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
15:17:28 <hpc> :t zip3
15:17:28 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
15:17:31 <hpc> :t zipWith
15:17:32 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:17:41 <pozic> gwern: How about 'haskell code'?
15:17:56 <pozic> gwern: real programmers install Adblock for Google, though.
15:18:00 <gwern> pozic: doesn't seem to boost the estimates, but good enough
15:18:02 <hpc> > zip3 [1..5] [1.0 .. 5.0] [False, False, False]
15:18:03 <lambdabot>   [(1,1.0,False),(2,2.0,False),(3,3.0,False)]
15:18:20 <niteria> but it's touples
15:18:29 <pozic> gwern: I would say mirror github Haskell next time I search for this.
15:18:31 <monochrom> I'm betting those prepostmorphism, *morphism words are very cheap.
15:18:40 <dmwit> niteria: concat . transpose
15:18:45 <monochrom> grecomorphism
15:18:45 <hpc> oh, or that
15:18:47 <pozic> gwern: but nobody else would try that, I suppose, without knowing about that website.
15:18:47 <dmwit> Zearen: That looks like a fine type to me.
15:18:52 <hpc> :t concat . transpose
15:18:53 <lambdabot> forall a. [[a]] -> [a]
15:18:53 <dmwit> Zearen: Though it's a bit odd.
15:19:29 <monochrom> actually I have adblocks plus, but I add an exception to allow text google ads.
15:19:31 <jmcarthur> > concat $ transpose [[1..],['a'..],[5..]]
15:19:31 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
15:19:32 <lambdabot>    arising from the literal `1...
15:19:35 <gwern> pozic: variations on 'mirror' are useful, actually
15:19:38 <jmcarthur> doh
15:19:42 <jmcarthur> > concat $ transpose [[1..],[3..],[5..]]
15:19:43 <lambdabot>   [1,3,5,2,4,6,3,5,7,4,6,8,5,7,9,6,8,10,7,9,11,8,10,12,9,11,13,10,12,14,11,13...
15:19:51 <pozic> gwern: how do you know that they are useful?
15:19:54 <jmcarthur> only works if all the lists have the same type, duh
15:19:58 <monochrom> I like ads, I just dislike slow ads.
15:20:01 <niteria> cool
15:20:03 <niteria> thanks
15:20:03 <pozic> gwern: you seem to be looking at some number coming from a computer.
15:20:22 <pozic> gwern: can you show a screenshot of whatever output you are looking at?
15:20:24 <gwern> pozic: when I put them in the list of keywords, google has a button to estimate, given how much I've said I'm willing to pay per click and total per day, how many clicks there will be
15:20:30 <gwern> pozic: have you ever used adwords before?
15:20:40 <pozic> gwern: no, but I also have coupons lying around.
15:20:49 <gwern> pozic: they may've expired. you should check
15:20:58 <pozic> gwern: they did, but there are new ones.
15:21:00 <benmachine> I had some expire on me :(
15:21:00 <ddarius> Why are so many "numbers" not numbers?
15:21:05 <gwern> if nothing else, you cou.d buy java words and troll the java programmers ;)
15:21:08 <hpc> ddarius: eh?
15:21:09 <Zearen> dmwit: thanks, I was looking at the wrong thing :)
15:21:10 <pozic> gwern: they probably send them until you use it.
15:21:16 <gwern> 'come to haskell. we have zygocookies!;
15:21:20 <monochrom> if your stupid server takes 30 seconds to give me your ad, and I mean 30 seconds after the rest of the page finishes render, well you are a waste of natural resources.
15:21:45 <hpc> monochrom: and that's if the ad doesn't block the rest of the page
15:22:14 <monochrom> and flash ads are totally pointless.
15:22:19 <benmachine> hpc: I hate that :(
15:22:20 <hpc> gwern: oh man, if you could somehow cargo-cult legitimate mathematical facts...
15:22:22 * ddarius loves flash ads.
15:22:22 <pozic> gwern: why doesn't it just say "what is your budget?" and optimise for that? 
15:22:29 <monochrom> but text ads from google? fast and small and just fine.
15:22:32 <gwern> hpc: I think google recently switched to async loading its JS
15:22:37 <G_Morgan> ads? When did they start added them to the internet
15:23:07 <gwern> pozic: well, it doesn't know what keywords are best. google is smrt and does try to give you suggestions based on the target URL, but they're not great
15:23:31 <hangs> benmachine: no luck after adding the type signatures either. same error. are there other warning flags besides -fwarn-missing-signatures that you recommend turning on?
15:23:35 <pozic> gwern: theoretically they could compute it. 
15:24:03 <benmachine> hangs: well, -Wall in general. do the type signatures it suggested look right to you?
15:24:12 <hangs> yes they do
15:24:19 <benmachine> oh ok
15:24:20 <benmachine> hmm
15:24:35 <benmachine> could you repaste with the signatures added?
15:24:43 <Saizan> hangs: i think you missed monochrom's comment pointing out the problem, earlier
15:25:01 <monochrom> hangs you need to fundamentally change your code. either parseGeocode should spit out Double, or writeLoop should stop speaking of (0,0)
15:25:18 <gwern> pozic: how could they compute the optimal keyword to advertise on for a given URL? they'd need to know the answer to millions of counterfactuals
15:25:23 <benmachine> oh, so he did
15:25:38 <benmachine> gwern: well, this IS google we are talking about :P
15:26:09 <gwern> benmachine: let's not fall into the trap of assigning them attroibutes like omniscience... they're worthy of veneration and blood-offerings, but not our worship
15:27:00 <G_Morgan> Googles blood sacrifice service is still in beta
15:27:50 <Botje> G_Morgan: so it only works in chrome?
15:28:04 <hangs> monochrom: Saizan: sorry, I did miss the comment earlier. you are right, the 0, 0 is the problem! Replacing with "0", "0" works. style Q: I don't care what the lat-long value is if its not found... can I write a wildcard of some sort (a la _). 
15:28:10 <benmachine> hangs: also, learning how to use Maybe as a monad would make your code at least ten million per cents more precise
15:28:20 <benmachine> er
15:28:21 <benmachine> concise
15:28:35 <benmachine> hangs: that's what Maybe is for
15:28:45 <pozic> gwern: Google can contact me with a number they want to pay for such a solution. 
15:28:46 <G_Morgan> benmachine: I think it would in fact make it 5% more concise
15:28:50 <hpc> @src Maybe
15:28:50 <lambdabot> data Maybe a = Nothing | Just a
15:29:07 <gwern> pozic: haha. a number with at least 8 significant figures, amirite
15:29:10 <hpc> Maybe is perhaps the greatest data structure in the prelude
15:29:12 <monochrom> hangs is already using Maybe. doesn't solve the question "what to do when Nothing". that is the specifier's job.
15:29:14 <benmachine> G_Morgan: it would probably halve the code size if not better
15:29:24 <hangs> benmachine: would you recommend a good resource for learning about Maybe? I've been struggling with the real-world haskell book for the last 2 days and find it densely written.
15:29:29 <benmachine> G_Morgan: ...of the bit I am thinking of applying it to
15:29:31 <hangs> benmachine: thanks so much.
15:29:31 <pozic> gwern: oh, I am fairly modest. 
15:29:34 <hpc> hangs: lyah
15:29:36 <hpc> @where lyah
15:29:36 <lambdabot> http://www.learnyouahaskell.com/
15:29:41 <benmachine> lyah is good
15:29:47 <hpc> most approachable tutorial by far
15:29:54 <G_Morgan> benmachine: It was a Chinese 5%
15:30:00 <hangs> hpc: cool. thanks.
15:30:07 <benmachine> G_Morgan: :P
15:30:15 * hpc sees rwh as a reference
15:30:16 <benmachine> hangs: there was something else I was going to recommend as well
15:30:24 <hpc> benmachine: the wikibook?
15:30:24 * benmachine has never read rwh all the way through
15:30:32 <benmachine> all about monads, I think?
15:30:34 <benmachine> the one with sheep
15:30:54 <hpc> lyah has a fantastic section on monads
15:31:01 <benmachine> ah yeah
15:31:11 <benmachine> @where all about monads
15:31:11 <lambdabot> I know nothing about all.
15:31:12 <monochrom> print (case (Map.lookup geocode geocodeToLatLong) of { Nothing -> city ++ "not found"; Just (lat,long) -> city ++ lat ++ long})
15:31:13 <benmachine> :(
15:31:22 <hpc> like, as soon as that section came out, everyone suddenly "understood" monads
15:31:22 <benmachine> heh
15:31:28 <hpc> except they were actually saying correct things
15:31:28 <benmachine> :P
15:31:40 <hpc> it was quite nice
15:31:44 <hpc> same with the zipper section
15:31:48 <benmachine> the thing that made me understand monads was 'you could have invented monads' or whatever it was called
15:31:56 <hpc> ah yes, the sigfpe one
15:32:00 <hpc> that was great too
15:32:14 <benmachine> it was a completely different way of looking at them
15:32:18 <benmachine> and I was like, this makes so much sense
15:33:15 <G_Morgan> I got monads after somebody actually did a tutorial that taught the maths.
15:33:20 <hpc> what i liked about lyah was it taught the standard monads with a lot of words and no cookie-cutting
15:33:36 <G_Morgan> All the twisted analogies were just confusing
15:33:37 <hpc> as opposed to others which go "writer is blah blah and a type for a logish thing"
15:33:42 <hpc> "*CODE*"
15:34:05 <mm_freak> i got monads by using them
15:34:22 <mm_freak> almost everything about haskell actually
15:34:25 <monochrom> all analogies must die.
15:34:34 <benmachine> G_Morgan: ok so I first parsed that as "analogies to the python framework for co-operative multitasking"
15:34:37 <benmachine> and went, wat
15:34:57 * benmachine has one of those I-need-to-go-outside-more moments
15:35:10 <hpc> that's probably true too :P
15:35:47 <G_Morgan> The other thing that struck me when I first got monads is that they weren't really about the problem
15:35:55 <G_Morgan> They were about hiding the details of the problem
15:36:05 <G_Morgan> IO monad isn't about IO
15:36:12 <hangs> benmachine: hpc: thanks for the sigfpe link
15:36:13 <G_Morgan> It is about hiding the mess that IO generates otherwise
15:36:39 <hpc> hangs: when you get time and experience, go through the whole archive; sigfpe is pretty fucking awesome
15:36:40 <niteria> is there a function that returns intermediate results of foldr?
15:36:57 <hpc> niteria: the analogous scans?
15:37:03 <monochrom> scanr has all the intermediate results of foldr
15:37:11 <hangs> hpc: thanks. 
15:37:25 <hangs> 2 quick questions about print: how do I get rid of the "" that it puts around everything. 
15:37:33 <monochrom> putStrLn
15:37:34 <hangs> and can i get it to write out utf8?
15:37:34 <hpc> hangs: don't print strings
15:37:39 <hpc> > show "12345"
15:37:40 <lambdabot>   "\"12345\""
15:37:44 <shachaf> hangs: It doesn't put it around everything.
15:37:45 <niteria> cool, thanks
15:37:50 <hpc> > "12345"
15:37:51 <lambdabot>   "12345"
15:38:09 <shachaf> > print "<IO ()>"
15:38:10 <lambdabot>   <IO ()>
15:38:21 <hpc> hangs: i thought haskell did unicode by default
15:38:25 <hpc> shachaf: nice
15:38:42 <G_Morgan> Haskell chars are unicode points.
15:38:44 <monochrom> under suitable conditions, ghc I/O does utf-8
15:38:59 <G_Morgan> If you want UTF values you can use ByteString.UTF8
15:39:01 <hangs> monochrom: and the conditions are... ?
15:39:14 <monochrom> not sure what happens on windows and macos x
15:39:23 <hpc> it's hard to tell, sometimes
15:39:34 <monochrom> on linux if you have locale environment variables set to request utf-8
15:39:39 <hpc> my website can't handle unicode input
15:39:47 <zax> Is this bike red or orange? http://www.tredz.co.uk/prodimg/37621_1_Zoom.jpg
15:39:49 <hpc> haven't worked out how to fix that
15:40:18 <monochrom> hpc: does http://www.vex.net/~trebla/cgi-lab/ help?
15:40:19 <hpc> zax: that bike is "SPECIALIZED" :P
15:40:50 <hpc> monochrom: er, meant output
15:41:07 <hpc> i can't put unicode arrows in my blog posts, for example
15:41:24 <hpc> i tried once, and had to delete it from the terminal
15:41:35 <monochrom> if someone else wrote the blog software, too bad, someone else is dumb.
15:41:43 * shachaf <-
15:41:57 <c_wraith> It's been so long since I've done a web page that couldn't handle unicode...  I've forgotten how to not handle it.
15:42:07 <monochrom> if you wrote the blog software and it's ghc-haskell, I know how.
15:42:32 <hpc> monochrom: haha
15:42:56 <monochrom> but first of all there is some <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> you have to attend to
15:43:11 <hpc> huh
15:43:34 <c_wraith> Screw meta tags.  Do it the right way.  meta tags are such a bad hack...
15:43:37 <hangs> G_Morgan: thanks. can i just putStrLn a ByteString ? And should I be using ByteString over Strings in all my code? I presume it will work fine for map lookup, etc?
15:43:37 <hpc> yeah, i'm just doing it as cgi, so everything is through env, stdin, and stdout
15:43:39 <monochrom> the html code should contain that, to tell the browser you're sending utf-8
15:43:56 <hpc> and isn't there an http header?
15:44:02 <c_wraith> CGI writes the response headers.  Just write your content-type header including the charset
15:44:04 <G_Morgan> If you putStrLn a ByteString you will output a Bytestring
15:44:08 <hpc> oh yeah, derp
15:44:10 <monochrom> if you can do it in the http header, even better.
15:44:12 <hpc> charset=utf-8
15:44:25 <G_Morgan> hangs: There are to/fromstring methods in ByteString.UTF8
15:44:30 <hangs> hmmm.. ghc 2.hs : 58.205 secs. ghc -O2 58.244 (does ghc do -O2 by default ?)
15:45:01 <monochrom> now of course there is much work to make sure the body is actually utf-8 as claimed :)
15:45:30 <hpc> eh
15:45:31 <G_Morgan> hangs: you can also use lazy bytestrings if you prefer
15:45:41 <hpc> i can just use the html escapes
15:45:43 <monochrom> yeah in fact in my reply.cgi I use the http header.
15:46:12 <monochrom> yeah &#9394; is an option too.
15:46:28 <hpc> being too lazy to do the research made me just go with the evil i know
15:46:51 <monochrom> yes I spent whole evenings reading standard docs and testing.
15:46:51 <hpc> if i ever really really need unicode
15:47:44 <ddarius> monochrom: You should become a party planner..
15:48:28 <monochrom> not sure how my knowledge of html and xml and css will result in a fabulous party.
15:48:53 <monochrom> perhaps a "css trivia quiz" game during the party?
15:49:21 <hpc> monochrom: that's easy; the answer to every question is "it depends on the browser"
15:49:54 <monochrom> "here are 5 rules and they totally overstep each other. here is <p class='foo'>x</p>. which rule fires?"
15:53:32 <niteria> how to sum digits of an integer that's in a string?
15:53:49 <hangs> G_Morgan: import Data.ByteString.UTF8 says     Could not find module `Data.ByteString.UTF8': do i need anything special?
15:54:16 <dagle> niteria: How would the string look like?
15:54:23 <niteria> sum $ map read $ show "13123" 
15:54:27 <niteria> won't work
15:54:31 <monochrom> the "utf8-string" package
15:54:42 <niteria> sum $ map read $ show 13123 , I mean
15:54:48 <G_Morgan> hangs: have you cabal installed utf8-string
15:54:56 <hangs> ah, no.
15:55:07 <niteria> it doesn't have to be in a string
15:55:07 <siracusa> > sum $ map digitToInt "123"
15:55:08 <lambdabot>   6
15:55:59 <gwern> hm, aren't we supposed to use Text these days if we have unicode bytestrings?
15:56:06 <hpc> @src digitToInt
15:56:06 <lambdabot> Source not found.
15:56:09 <hpc> :t digitToInt
15:56:10 <lambdabot> Char -> Int
15:56:27 <hpc> oh right, because String != Char <.<
15:57:02 <G_Morgan> gwern: Perhaps. I've used ByteString.UTF8 a lot because I'm parsing strings out of the middle of a ByteString that I'm doing other processing on
15:59:40 <hangs> G_Morgan: thanks, that cabal install worked.
16:00:20 <G_Morgan> hangs: As gwern mentioned the blessed way to handle text is with the Text package.
16:00:39 <G_Morgan> hangs: ByteString.UTF8 works but I mentioned it because it is what I've experience with
16:00:47 <G_Morgan> hangs: Text might be better
16:00:50 <hangs> ok
16:12:58 <nzero> In HaXml what's wrong with let v = (keep /> attr "ver" /> showattr "ver") in hrow [hcol [v]] f? It bails with "Non-exhaustive patterns in function find".  Full code here: https://gist.github.com/884223
16:13:58 <sjanssen> @hoogle withCString
16:13:59 <lambdabot> Foreign.C.String withCString :: String -> (CString -> IO a) -> IO a
16:13:59 <lambdabot> Foreign.C.String withCStringLen :: String -> (CStringLen -> IO a) -> IO a
16:20:59 <Maxdamantus> @hoogle (a -> Bool) -> (a -> a) -> a -> a
16:20:59 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
16:21:00 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
16:21:00 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
16:31:25 <o`> bo?
16:31:27 <o`> da?
16:31:28 <o`> zoo?
16:32:13 <o`> help
16:32:15 <o`> \help
16:32:29 <djahandarie> o`, what do you need help with?
16:32:59 <djahandarie> Apparently with how to part the channel.
16:33:09 <niteria> is there an easier way to write ((<10).(^2)) ?
16:33:44 <djahandarie> :t ala Endo foldMap [(<10), (^2)]
16:33:44 <lambdabot> Not in scope: `foldMap'
16:33:50 <djahandarie> :t ala Endo Data.Foldable.foldMap [(<10), (^2)]
16:33:50 <lambdabot>     No instance for (Num Bool)
16:33:50 <lambdabot>       arising from the literal `10' at <interactive>:1:34-35
16:33:50 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
16:33:58 <djahandarie> Oh, lol
16:34:44 <niteria> (\x -> x^2 < 10), might be clearer
16:35:13 <niteria> i guess lambda looks better
16:35:21 <djahandarie> Yes I would probably go with the lambda
16:35:36 <djahandarie> I was going to show you how to compose a list of functions, but I didn't realize they had different ypes
16:35:40 <djahandarie> types*
16:36:43 <ddarius> More Hans Rosling!
16:37:01 <djahandarie> @ty ala Endo Data.Foldable.foldMap :: [a -> a] -> a -> a
16:37:02 <lambdabot> forall a. [a -> a] -> a -> a
16:38:13 <djahandarie> @ty execState . mapM modify -- also works, but is far less clearer than a foldMap with the Endo monoid
16:38:14 <lambdabot> forall s. [s -> s] -> s -> s
16:43:49 <magicman> @ty ala
16:43:50 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
16:44:13 <magicman> O_o
16:44:21 <djahandarie> @hackage newtype
16:44:22 <lambdabot> http://hackage.haskell.org/package/newtype
16:44:27 <magicman> Ah, cheers.
17:06:16 <freedrool> is there a way to print a list of data Foo without the brackets at each end? i defined an instance of show for my datatype, but can i define an instance of show for a list of that datatype?
17:06:38 <mauke> showList
17:06:43 <ndrsndrs> intercalate ", " . map show
17:06:45 <ndrsndrs> or, that
17:07:15 <c_wraith> @src Show
17:07:15 <lambdabot> class  Show a  where
17:07:15 <lambdabot>     showsPrec :: Int -> a -> ShowS
17:07:15 <lambdabot>     show      :: a   -> String
17:07:15 <lambdabot>     showList  :: [a] -> ShowS
17:07:34 <c_wraith> showList is a horrible hack, but it does do what you want in this case.
17:08:09 <hpc> @src ShowS
17:08:09 <lambdabot> type ShowS = String -> String
17:08:58 <freedrool> ok cool, thanks
17:10:04 <freedrool> c_wraith: why is it a hack though?
17:10:18 <hpc> freedrool: it only exists for String
17:10:24 <hpc> > show "123"
17:10:24 <lambdabot>   "\"123\""
17:10:29 <hpc> > show [1,2,3]
17:10:30 <lambdabot>   "[1,2,3]"
17:10:38 <dolio> It's less of a hack than the alternative.
17:11:03 <c_wraith> the alternative is having String be a real type
17:11:07 <c_wraith> That's not a hack at all
17:11:19 <dolio> Well, yes, that's a good solution.
17:11:32 <freedrool> oh, because String is just type String = [Char]?
17:11:36 <c_wraith> yes
17:11:37 <hpc> yes
17:11:42 <elliott> yes
17:11:42 <sshc> It seems somebody accidentally the slideshow at http://corp.galois.com/blog/2009/4/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galo.html
17:11:47 <dolio> I was thinking overlapping instances.
17:11:48 <proq> odd how the original meaning of hack "clever/brilliant code that was thrown together quickly" has become "ugly code that works by barely solving the problem"
17:12:01 <hpc> dolio: that's not so much a hack as just... bad
17:12:24 <proq> or more loosely "code that I don't approve of"
17:12:26 <elliott> proq: attempts at the former universally produce the latter
17:12:33 <elliott> :P
17:12:35 <hpc> dolio: it means strings can't be shown in h98
17:12:55 <dolio> Overlapping instances mean that?
17:12:56 <elliott> ouch, yeah, how does Show String even work in h98?
17:13:01 <elliott> never even considered that
17:13:03 <hpc> dolio: it's an extension
17:13:07 <dolio> I don't care about H98.
17:13:15 <dolio> I care that overlapping instances are a bad extension.
17:13:18 <c_wraith> elliott: it works because of the showList hack
17:13:39 <benmachine> @quote overlapping
17:13:39 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
17:13:39 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
17:13:40 <hpc> @quote 98.goal
17:13:40 <lambdabot> No quotes match. My mind is going. I can feel it.
17:13:42 <ddarius> instance Show String is doubly disallowed by Haskell 98.
17:13:58 <hpc> @quote admirable
17:13:58 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
17:14:05 <hpc> hmm
17:14:18 <elliott> @quote 98
17:14:18 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
17:14:30 <hpc> lol
17:14:33 <hpc> @quote hpc
17:14:34 <lambdabot> hpc says: when all you have is Haskell, everything looks like a research paper
17:14:40 <elliott> @quote elliott
17:14:40 <lambdabot> elliott says: Only two things in the universe are certain: Death, and two of the libraries you've decided to use taking different types of ByteString.
17:14:42 <elliott> FEED MY EGO
17:14:55 <hpc> @quote elliott 
17:14:55 <lambdabot> elliott says: Only two things in the universe are certain: Death, and two of the libraries you've decided to use taking different types of ByteString.
17:15:00 <hpc> :(
17:15:00 <elliott> @quote ehird
17:15:00 <lambdabot> ehird says: 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
17:15:04 <benmachine> @quote benmachine
17:15:04 <lambdabot> benmachine says: main = interact id
17:15:07 <freedrool> i dont really see why its a hack, so String is a type synonym, so what
17:15:07 <proq> see... that is in no form a hack.  more like just insanely bad code.  how is any part of that clever?
17:15:10 * benmachine blinks
17:15:17 <elliott> @quote proq
17:15:17 <lambdabot> No quotes match. You type like i drive.
17:15:19 * benmachine wonders who on earth thought that was quotable
17:15:30 <benmachine> proq: what is?
17:15:45 <hpc> @quote hpc
17:15:45 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
17:15:51 <proq> showList
17:16:02 <benmachine> proq: it's not insanely bad
17:16:04 <benmachine> it's not even insane
17:16:12 <benmachine> it's just a little bit unseemly
17:16:19 <dolio> Which code is insanely bad?
17:16:24 <hpc> showList
17:16:39 <proq> oh, sorry.  overlappingInstances
17:16:40 <hpc> man, how many people are going to stumble into this conversation and ask what's up? :P
17:16:43 <benmachine> oh right
17:16:44 <hpc> oh, or that
17:16:53 <benmachine> overlappinginstances is...
17:17:01 <benmachine> there are some quite ingenious things that can be done with it
17:17:15 <benmachine> but really it's a solution to a non-problem :P
17:17:26 <hpc> it's not incoherentinstances
17:17:35 <hpc> which means almost nothing, but hey
17:17:38 <benmachine> heh
17:17:45 <benmachine> justplainweirdinstances
17:17:46 <dolio> I think part of the issue is: part of the Haskell mindset for many people is that brilliant, ad-hoc, quick fix solutions are inherently not appreciated.
17:17:54 <dolio> Compared to theoretically well-founded ones.
17:18:20 <dolio> So you could produce a hack by traditional standards, and it'd be judged as poor form.
17:18:26 <benmachine> they are culturally discouraged because
17:18:34 <hpc> i wonder if anyone has ever written a brilliant ad-hoc Coq theorem
17:18:36 <benmachine> haskell is a good language for reusability
17:19:50 <monochrom> "hack" as "clever work" is rather recent. in traditional blacksmithing, "hack" is more like "keep beating until it's done", totally brute-force unclever to me.
17:20:12 <hpc> sweet, etymology
17:20:16 <ddarius> monochrom: Thanks for reminding me monochrom.
17:20:27 <hpc> ddarius: this is your name twice ddarius
17:20:31 <hpc> ;)
17:20:32 <proq> monochrom: if by recent you mean ~1980 at MIT, sure
17:20:47 <freedrool> oh wait, i need {-# LANGUAGE FlexibleInstances, OverlappingInstances #-} to define Show [MyType]?
17:21:06 <monochrom> 1980 is still rather recent to me.
17:21:40 <hpc> in 1980, i was...
17:21:40 <monochrom> it was just like yesterday
17:21:40 <hpc> negative ten
17:21:40 <dolio> Geeze.
17:21:40 <freedrool> maybe i should just define a separate printing function
17:21:54 * hackagebot ssv 0.2 - Comma-separated-value (CSV) read, show and write routines  http://hackage.haskell.org/package/ssv-0.2 (BartonMassey)
17:22:21 <dolio> Anyhow, showList is probably the least of the reasons for making String its own (abstract) type.
17:22:40 <hpc> the best of reasons is that [Char] is a shitty type for strings
17:22:46 <dolio> Yes.
17:22:52 <hpc> char* is barely good enough
17:23:14 <elliott> [Char] is more acceptable than (char *) at least.
17:23:20 <ddarius> char * is worse than [Char]
17:23:20 <dolio> I'd rather do [Char] than char*.
17:23:47 <elliott> High-fives for all!
17:24:28 <hpc> why is [Char] better?
17:24:43 <ian_mi> I've never had any problem with [Char]
17:24:47 <ian_mi> is this a performance issue?
17:24:47 <elliott> For one, it can handle binary data.
17:24:47 <ddarius> @src CStringLen
17:24:48 <lambdabot> Source not found. Are you on drugs?
17:24:48 <dolio> You don't need to futz with en/decoding issues manually.
17:24:50 <elliott> Two, sharing.
17:24:51 <hpc> i would think the speed of char* for concatenation, etc is better
17:24:58 <hpc> ah, that's fair
17:25:10 <elliott> Three, better language facilities (I realise this isn't fair).
17:25:12 <copumpkin> way safer
17:25:17 <hpc> elliott: hehe
17:25:17 <elliott> copumpkin: That's more a language thing.
17:25:32 <elliott> hpc: Oh, and Unicode.
17:25:33 <elliott> Obviously.
17:25:36 <copumpkin> oh I just got here
17:25:37 <hpc> yeah, i can see how sharing would help
17:25:39 <monochrom> anyway blacksmith "hack" is definitely less recent and more original than 1984 MIT "hack".
17:25:40 <elliott> copumpkin: An unboxed array of bytes terminated by 0 can be totally safe, but ...
17:25:45 <ddarius> copumpkin: Want to go eat somewhere or do something, and no, I don't know where or what?
17:26:11 <elliott> Hey people or other objects, let's perform acts!
17:26:23 <elliott> Or not.
17:27:10 <ian_mi> does that imply that you're an object?
17:27:13 <copumpkin> ddarius: pretty exhausted :/ got almost no sleep last night. Maybe tomorrow?
17:27:25 <hpc> ian_mi: it's objects all the way down!
17:27:28 <elliott> ian_mi: Darn! A concrete statement!
17:27:31 <hpc> JVMs for everyone!
17:27:52 <ian_mi> oh no
17:27:58 <monochrom> free lambdas for everyone
17:30:32 <dolio> ddarius: You need to train him not to stay up until 4:30 chatting in #agda.
17:30:42 <monochrom> hahaha
17:30:52 <ddarius> dolio: Or harden him.
17:31:04 <monochrom> program chanserv to ban him at 1:00 daily
17:31:26 <hpc> lol
17:31:59 <copumpkin> dolio: I was actually doing the obfuscation stuff for people who needed it fairly urgently :P the #agda was a temporary thing
17:32:09 <dolio> Ah.
17:33:03 <niteria> is there a function reverse . tail . reverse ?
17:33:10 <copumpkin> init
17:33:11 <ddarius> reverse . tail . reverse
17:33:14 <copumpkin> oh wait
17:33:28 <copumpkin> :)
17:33:32 <hpc> hehe
17:33:39 <dolio> init is too lazy. Doesn't fail on infinite lists. 
17:33:51 <copumpkin> dolio: damn
17:34:37 <elliott> no such thing as too lazy!
17:34:56 <dolio> Bob Harper disagrees!
17:35:20 <ddarius> Sure there is as we are finding out due to the Haskell Report authors thinking that.
17:35:53 <elliott> NO SUCH THING
17:36:49 <augur> elliott: my code is so lazy it refuses to run
17:36:50 <augur> :X
17:37:02 <elliott> My code is so lazy it won't even allow itself to be written.
17:37:18 <hpc> my code would be lazy if i got around to writing it
17:37:32 <augur> conal: spj's talk on parallelism?
17:37:40 <elliott> I don't know how lazy my code is; I haven't checked yet, so it hasn't been evaluated.
17:37:47 <proq> monochrom: where did you see mention of a blacksmith hack?  I'm also seeing claims that it dates back to ~1950 at MIT
17:38:18 <monochrom> all literatures on blacksmiths. dictionaries.
17:38:33 <conal> augur: ??
17:38:50 <augur> conal: spj gave a talk at some conf recently on parallelism techniques and so forth
17:38:59 <elliott> proq: The older MIT meaning just means prank/practical joke/type of thing around campus, no?
17:39:13 <augur> and that reminded me of when he asked you about making frp work using lots of threads and specex
17:39:33 <monochrom> "computer programming" cannot possibly be older than "sword hacking", even if you take Charles Babbage and Ada into account.
17:39:49 <conal> augur: was spj's talk on *imperative* parallel programming? or denotative/functional? or both?
17:40:00 <augur> ehhhh
17:40:11 <Peaker> Will we ever see ByteString replaced with a generalized/parameteric type (* -> *) ?
17:40:15 <dagle> @src init
17:40:15 <lambdabot> init [x]    = []
17:40:15 <lambdabot> init (x:xs) = x : init xs
17:40:15 <lambdabot> init []     = undefined
17:40:41 <shachaf> > init []
17:40:41 <lambdabot>   *Exception: Prelude.init: empty list
17:40:59 <ddarius> But now the question is: Did Countess Ada "hack?"
17:41:01 <augur> conal: http://skillsmatter.com/podcast/scala/talk-by-haskell-expert-simon-peyton-jones/js-1434
17:41:21 <benmachine> Peaker: how?
17:41:22 <Peaker> Maybe nicer to have:  init = reverse . drop 1 . reverse ?
17:41:45 <Peaker> benmachine, unboxed-array-type?  type ByteString = UArray Word8?
17:42:02 <shachaf> > reverse . drop 1 . reverse $ [1..]
17:42:08 <ddarius> Peaker: Probably not, but then such a type wouldn't have some of the guarantees bytestrings have.  Of course, if you just need efficient storage of a random access sequence of things, there is vector already.
17:42:11 <lambdabot>   mueval: ExitFailure 1
17:42:11 <lambdabot>  mueval-core: Time limit exceeded
17:42:47 <benmachine> Peaker: but unboxed arrays can only be of certain types?
17:43:00 <Peaker> ddarius, but I can't use "fmap" with ByteString..
17:43:34 <ddarius> You can't use fmap with Integer either.
17:43:35 <Peaker> I guess I couldn't make a Functor instance of an unboxed array type.. unless the unboxing is only guaranteed for some type instantiations
17:43:46 <conal> augur: thx. looks like a mixed bag, even including some denotative/functional.
17:44:02 <Peaker> ddarius, sure, but replacing ByteString.map with Vector.fmap could be nice if we just had ByteString as a Vector of Word8?
17:44:22 <Peaker> > init [1..]
17:44:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:44:33 <Peaker> oh :)
17:44:49 <benmachine> my suspicion is that ByteString as a Vector of Word8 would be slower
17:44:53 <proq> monochrom: that would be grammatically incorrect then.  the MIT definition is a noun "a hack", but the dictionary definition of "hack" is a verb
17:44:55 <benmachine> ...maybe
17:45:31 <Peaker> benmachine, the question is whether there is a good reason for that, or just some missing optimization that could cover it (I don't mean "sufficiently smart compiler", just specific set of optimizations shown to make them similar perf-wise)
17:46:12 <copumpkin> benmachine: why?
17:46:24 <benmachine> copumpkin: iono it just sounds more complicated :P
17:46:34 <benmachine> I guess essentially the API is the same
17:46:36 * ion o
17:46:50 <benmachine> but ByteStrings are very... specialised
17:47:23 <Peaker> benmachine, that's why we have specialization optimizations? And maybe we have type-based pragma rules?
17:47:28 <ddarius> benmachine: But they also have constraints that a Vector Word8 wouldn't have, so theoretically you could have Vector Word8 be faster than ByteString.
17:47:31 <monochrom> indeed "swording hacking" and "hack some good code" are grammatically correct.
17:47:41 <monochrom> err sword hacking
17:48:14 <monochrom> I saw "hack some good code" in a letter-to-the-editor in DDJ.
17:49:47 <proq> sure, but "this code is a hack" is not, unless you mean the MIT definition of hack
17:49:59 <Peaker> ddarius, don't constraints help optimizers? why would it do the opposite?
17:50:32 <Augusto> hello friends
17:51:41 <Augusto> Does anyone know please tell me what type of graphics library to Haskell works?
17:51:45 <ddarius> Peaker: ByteString has constraints in the form of guarantees it gives the user that Vector does not have.
17:51:59 <benmachine> ddarius: what are those?
17:52:32 <copumpkin> Peaker: if the optimizer has more freedom it can do crazier stuff :P
17:52:33 <copumpkin> pinned memory for foreign calls, at least
17:52:53 <Peaker> ah, opposite constraints :)
17:53:51 <Peaker> Is it practical/useful to separate the memory pinning from the type?  If not, maybe use a phantom type to specify if it is pinned, and a type alias to hide the phantom type most of the time?
17:54:08 <Peaker> separate from type as in:  pinnedVector :: Vector a -> Vector a
17:54:33 <dmwit> Augusto: There's a few. There's OpenGL bindings, GTK2 (+Cairo) bindings, wxHaskell bindings, libGD bindings, and some native implementations of a few different graphic formats.
17:54:38 <dmwit> Augusto: What are you looking to do?
17:56:41 <Augusto_> hi again
18:00:36 <freedrool> damn, my binary is 2 megs?
18:01:59 <c_wraith> freedrool: sounds about right for a small haskell program.  the entire RTS is linked in, and that's not small.
18:02:17 <Ptival> freedrool: hello world is 700K+ :)
18:02:22 <freedrool> Ptival: hehe
18:03:02 <freedrool> i have about 80 loc, and im using codec.midi, data.list, and system.environment
18:03:25 <shachaf> freedrool: You can probably strip it if you haven't.
18:03:36 <hpc> can't you compile haskell to the ghci bytecode to see how large that is?
18:03:54 <ddarius> No.
18:04:21 <freedrool> shachaf: don't really need to but just curious how would i do that?
18:05:30 <freedrool> shachaf: i can look it up i guess
18:05:55 <freedrool> http://stackoverflow.com/questions/699908/making-small-haskell-executables
18:06:09 <Augusto_> hey friends help me
18:06:53 <dagle> Augusto_: What type of graphics? 
18:07:30 <Augusto_> Does anyone know please tell me what type of graphics library to Haskell works?
18:07:42 <dmwit> Augusto_: Did you see my previous answer?
18:07:59 <dmwit> Augusto_: There's a few. There's OpenGL bindings, GTK2 (+Cairo) bindings, wxHaskell bindings, libGD bindings, and some native implementations of a few different graphic formats.
18:08:12 <dmwit> Augusto_: What are you looking to do?
18:09:40 <Augusto_> I am doing a project for my college.
18:10:02 <dagle> What type of project?
18:11:45 <Augusto_> Actually we are doing research on the programming language Haskell. The teacher wants to know what types of commonly used graphics library.
18:12:03 <dmwit> ?where hackage
18:12:03 <lambdabot> http://hackage.haskell.org/package/
18:12:29 <dmwit> Augusto_: Ctrl+F on that page will find commonly used libraries.
18:12:59 <dmwit> There are 175 packages in the "graphics" category. =)
18:15:29 <Augusto_> thanks dmwit
18:17:56 <rothwell> anyone here dealt with eclipsefp?
18:18:32 <Augusto_> dmwit Which of these reads a text file and identifies the numbers and generates the graph or graph?
18:18:34 <rothwell> for reasons i can't be bothered to go into right now, eclipse can't talk to a web browser on my system
18:19:09 <rothwell> i'm trying to read the documentation that i assume is just going to be a pile of html that eclipsefp has helpfully hidden away somewhere
18:19:10 <Augusto_> Graphics*
18:19:25 <rothwell> (they'd normally be accessible via Help -> Help Contents)
18:20:24 <dagle> Augusto_: That sound like a program rather then a library.
18:22:24 <monochrom> that is "graph plotting" rather than "graphics"
18:22:59 <Augusto_> In this case there is a calculation that identifies and transforms in graphs or graph?
18:23:51 <nzero> rothwell: Haven't used eclipsefp.  A very few docs are in the src at https://github.com/JPMoresmau/eclipsefp/tree/master/net.sf.eclipsefp.haskell.doc.user/html
18:24:25 <rothwell> nzero: actually just found the net.sf.eclipsefp.haskell.doc.user_2.0.3.jar almost the same second you said that
18:24:41 <nzero> :)
18:25:15 <rothwell> this stuff annoys me immensely... why's it so hard for them to put the html documentation at http://eclipsefp.sourceforge.net/documentation.html
18:25:52 <ddarius> My amp is callin.g
18:26:28 <rothwell> the plugin seems decent, anyway
18:26:36 <rothwell> nice to see type errors as soon as i make them
18:26:45 <sshc> Haskell's apparent lack of localization support annoys me
18:26:48 <nzero> rothwell: How's that tool looking, anyway?  I'm tempted to move from vim.
18:26:55 <sshc> Which library should I use for i18n (translation to other languages), if there is one?
18:27:12 <nzero> rothwell: good to hear
18:27:32 <shachaf> nzero /= mzero?
18:27:38 <rothwell> nzero: heh, i'm doing the same... using eclipse for java for work and today someone told me that eclipsefp works on ghc 7.0 now
18:27:38 <rothwell> installed it... may switch from vim
18:28:01 <nzero> shachaf True
18:29:45 <Peaker> Coworkers use Eclipse on our C code at work. I tried it in place of emacs, but it has too many annoyances, and it doesn't have keyboard macros!
18:29:50 <rothwell> seems it still doesn't offer niceties such as looking up function definitions in the standard library and so on
18:30:02 <Peaker> Imagine translating a bunch of guards with pattern-matchers, when you don't have keyboard macros :)
18:30:40 <dagle> Peaker: It does have keyborad macros, you just press tab between 1 and 128 times and choose the right thing todo.
18:30:54 <rothwell> hehe
18:31:04 <rothwell> that's... pretty much it
18:31:28 <Peaker> It has really bad find-file dialog.. A lot of poor-contemporary-GUIsms (e.g: Barely-visible focus needs to be explicitly moved to specific location to do useful thing)
18:32:04 <Peaker> (though I may be in a minority opinion that almost all (non-touch-based) GUIs are poorly designed)
18:32:14 <rothwell> the find dialog is awful, yeah
18:32:15 <dagle> Well it's a tool made from the java-world. What to expect?
18:32:26 <rothwell> have accidentally wiped out text in the open document several times
18:32:28 <Peaker> Mediocrity, I guess
18:32:55 <nzero> rothwell: as a haskell newbie, so many libraries are new to me (today, haxml, for example) that when I go to someone's code, I want a quick summary of which functions are from where.  (could be hover-over).  (I know in ghci I can do :info (/>))
18:32:55 <rothwell> i don't think it's possible to write java without an ide, especially with "checked exceptions" and the like
18:32:55 <rothwell> you'd go insane almost immediately
18:33:27 <rothwell> nzero: eclipsefp doesn't seem to offer that yet.. i'm still looking
18:33:52 <Peaker> nzero, haxml looks complicated to me, btw.. I prefer the simple/xml-light one
18:34:53 <dagle> I know people that forces people to write java on paper before they gets hired. Some of then says that they need eclips to program, then he just smilies.
18:35:03 <Peaker> nzero, I would love a good IDE for the static languages I use (for dynamic ones I think it is a lost cause..), but I don't think one exists, and I think we'll have to replace semi-structural/semi-textual editing with fully-structural editing to get some cool IDE's
18:35:21 <nzero> rothwell: yep, I just thought I may as well see if I could understand what appears to be the most powerful one.
18:36:00 <nzero> sorry, that to Peaker
18:36:17 <Peaker> http://hackage.haskell.org/packages/archive/HaXml/1.20.2/doc/html/Text-XML-HaXml-Html-Parse.html <-- this seems unacceptably crappy.. Not ByteString and using a pure exception?
18:36:39 <monochrom> just old
18:36:51 <Peaker> monochrom, old code still had Either
18:37:57 <monochrom> htmlParse name = Prelude.either error id . htmlParse' name   XD
18:38:00 <rothwell> dagle: don't get me wrong... i think there's a difference between requiring eclipse due to lack of programming skill and requiring eclipse due to ... java
18:38:11 <monochrom> it uses Either and then throws it away!
18:38:50 <Peaker> monochrom, and htmlParse' is not exported!
18:39:01 <Peaker> that's almost a daily WTF :)
18:39:13 <monochrom> yeah, should at least offer it as another choice
18:40:00 <Peaker> imright = either error id
18:40:15 <Peaker> then people can use that on the Either, no need to compose every Either result in the world with imright
18:40:17 <osoleve> what does this mean?
18:40:20 <osoleve> Couldn't match expected type `a0 -> [String]' with actual type `[String]'
18:40:43 <Peaker> osoleve, You used a list of string type where a function that returns a list of string was expected, or vice versa
18:40:48 <parcs> you missed a parameter
18:41:07 <dagle> rothwell: Well it's basic stuff. Like how to use scanner etc.
18:41:22 <Peaker> doesn't GHC have a helpful "Perhaps xxx was not applied to enough arguments" hint afterwards?
18:41:44 <osoleve> no :(
18:42:28 <nzero> Peaker: While we're on the topic of HaXml: What's wrong with this use of showattr ?:   let v = ( keep /> attr "ver" /> showattr "ver" ) in hrow [hcol [v]] f   Bails with: Non-exhaustive patterns in function find  https://gist.github.com/884223  
18:43:00 <rothwell> dagle: urhur. i'm mainly referring to requiring eclipse due to java design flaws... like correctly writing equals() and hashCode() in the presence of mutable data, subclassing, null references, reference equality, etc, etc, etc
18:43:01 <rothwell> dagle: just totally unreasonable for anyone to be writing that stuff
18:43:09 <Peaker> nzero, I don't know Haxml, I looked at a few XML libs and chose "xml" for its simplicity
18:43:25 <rothwell> dagle: and you're obviously required to do it correctly if you want to use any of the standard containers
18:44:17 <rothwell> dagle: meanwhile, outside of work, i write "deriving Eq" and forget about it
18:44:28 <dagle> :)
18:46:52 <osoleve> okay, so I have three functions, each tokenize creates output for shuntingyard which creates output for postfixEval
18:47:05 <osoleve> so I write a function calc = postfixeval . shuntingyard . tokenize x
18:47:12 <osoleve> calc x*
18:47:16 <osoleve> is that correct?
18:48:26 <byorgey> osoleve: you probably want just  calc = postfixeval . shuntingyard . tokenize
18:48:26 <osoleve> ohh, i had the type signature wrong
18:48:34 <Peaker> osfameron, it sounds like what you want is:  calc = postfixeval . shuntingyard . tokenize   or   calc x = postfixeval . shuntingyard . tokenize $ x
18:48:34 <osoleve> byorgey: yeah, i fixed that, too
18:48:38 <Peaker> oops
18:48:42 <Peaker> osoleve, ^^
18:48:45 <byorgey> ok =)
18:49:06 <osoleve> i had calc :: (Integral a) => String -> a
18:49:12 <osoleve> I needed calc :: String -> Int
18:49:17 <osoleve> still figuring out type signatures
18:49:36 <Peaker> osoleve, Haskell's most important precedence rule:  prefix function application (e.g: "f x") is always higher precedence (and left-associative) than infix (e.g: f . g).  So   a . b . c x   is parsed as a . b . (c x)
18:49:54 <Peaker> osoleve, String -> Int is a special case of (Integral a) => String -> a
18:50:01 <Peaker> osoleve, why do you prefer the more specific type?
18:50:18 <osoleve> Peaker: "could not deduce String -> Int from ..."
18:51:17 <incomprehensibly> Cale: quite a while ago I think I heard you say something about FRP on the iPhone
18:51:32 <osoleve> but on a lighter note, using only the first six chapters of LYAH, I wrote an infix calculator with support for multiple digits!
18:51:36 <osoleve> :D
18:52:00 <osoleve> (multiple digit support with the help of someone in here)
18:53:11 <osoleve> (yes, haskell already does that without any help, but it was a fun exercise to translate my scheme version)
18:53:25 <Peaker> osoleve, cool :)
18:54:10 <osoleve> thanks for all of your help, guys. I feel really accomplished right now and slightly more prepared for when my copy of RWH comes tomorrow
19:44:05 <axfan> 689 people
19:44:08 <axfan> and no one is talking
19:44:36 <micrypt> axfan: Hi. 
19:44:45 <axfan> micrypt: Hello
19:44:50 <Ptival> :)
19:45:01 <micrypt> #689 (Alive)
19:45:01 <dolio> Are you a fan of Axman6?
19:45:05 <axfan> nope
19:45:08 <axfan> i just met him last night
19:45:16 <axfan> i made this name when i was 12
19:45:46 <osoleve> dolio: i'm a fan of Axman6 
19:48:45 <dolio> I'm a Michael Bolton fan.
19:48:51 <dolio> Celebrate the guy's entire collection.
19:49:44 <axfan> im a Haskell fan
19:50:31 <BMeph> I'm not sure. I guess that makes me...an oscillating fan? ;Ã¾
19:51:23 * BMeph is a fan of Bynbo7
19:52:14 <osoleve> http://www.google.com/imgres?imgurl=http://3.bp.blogspot.com/_QCcMTHCBJ4c/TQLmMm0IWcI/AAAAAAAADls/RFDLuetcC6Q/s1600/I%2525E2%252580%252599m%252BA%252BHuge%252BMetal%252BFan%252B-%252BMe%252BToo%252521.gif&imgrefurl=http://funstoo.blogspot.com/2010/12/im-huge-metal-fan-me-too.html&usg=__lhuddw0qWFWZdsW9ltcd4NTdpm4=&h=509&w=500&sz=51&hl=en&start=1&sig2=wAnYFW2dJjCCl8hhynyVPg&zoom=1&tbnid=VsT4dDrsGyGOfM:&tbnh=131&tbnw=129&ei=XLKKTc6l
19:52:21 <osoleve> wahhh long link, sorry.
19:52:59 <axfan> that is a very long like
19:53:00 <axfan> link*
20:11:51 --- mode: ChanServ set +o copumpkin
20:12:02 --- mode: copumpkin set -b *!*@unaffiliated/j-invariant
20:12:09 --- mode: copumpkin set -o copumpkin
20:19:57 <quantum> haskell is the most zen language around
20:20:11 <axfan> hey OpenGLCheck-1.0 wont compile
20:20:14 <axfan> any ideas why?
20:21:41 <lispy> axfan: Not without more information :)
20:21:56 <lispy> axfan: you could put the last 10 lines of output from the build up at hpaste.org :)
20:22:18 <axfan> alright
20:23:25 <axfan> i used hpaste now what?
20:23:39 <monochrom> tell us the url
20:23:43 <axfan> http://hpaste.org/44987/compileerrors
20:23:52 <axfan> thank you guys
20:24:12 <monochrom> probably mismatch version of QuickCheck?
20:24:22 <axfan> thats what im trying to install
20:24:37 <axfan> wait..
20:24:53 <axfan> im reinstalling it
20:24:54 <axfan> :P
20:25:20 <axfan> how do i use an older version of quickcheck?
20:28:04 <monochrom> you could "cabal install QuickCheck-1.2.0.1" (or any version number you choose). however as long as a high version is already installed, there is almost no use adding an older version
20:28:16 <axfan> oh i see
20:28:45 <monochrom> OpenGLCheck hasn't been updated. QuickCheck-1 and QuickCheck-2 has different API.
20:29:05 <monochrom> but if you are willing to work a bit harder, here is how:
20:29:43 <axfan> well actaully
20:30:01 <monochrom> 1. still "cabal install QuickCheck-1.2.0.1". the real problem is how to convince OpenGLCheck to care about it rather than going for the newest version present.
20:30:01 <axfan> openglcheck is a dependency for the real package i want
20:30:04 <axfan> which is the .obj codec
20:30:49 <monochrom> 2. choose some directory, cd there, "cabal unpack OpenGLCheck", cd OpenGLCheck-1.0
20:31:23 <monochrom> 3. in OpenGLCheck.cabal, look for "QuickCheck >= 1.1.0.0", change it to "QuickCheck >= 1.1.0.0 && < 2"
20:31:29 <monochrom> 4. "cabal install"
20:31:54 <monochrom> you could probably guess what the change means and why it helps.
20:32:04 <axfan> thank you very much :)
20:32:24 <lispy> classic example of cabal tracking too much information to be a good package manager
20:32:42 <monochrom> I disagree. exactly the opposite.
20:33:14 <ndrsndrs> p_jExE5
20:33:18 <ndrsndrs> woops
20:33:44 <monochrom> if cabal tracked less or knew less, this same problem would be more unsolvable.
20:35:13 <monochrom> the community PVP is plain as day, package authors should be doing "QuickCheck >= 1.1.0.0 && < 2"
20:36:14 <axfan> ok mono you were right
20:36:16 <axfan> except
20:36:18 <axfan> i had to add .3
20:36:19 <axfan> after the 2
20:36:21 <axfan> for some reason
20:36:23 <axfan> but it worked :)
20:36:25 <btutt> Mysterious type checker errors are annoying.
20:36:30 <axfan> ahh hangon
20:36:33 <lispy> monochrom: Nah, when you use cabal-install to get someone's library it sucks to have cabal deal with installing the test harness for the developers of the library.
20:37:28 <btutt> http://hpaste.org/44988/typechecker_fun
20:38:04 <monochrom> that comment would be right for most other libs (whose primary purposes are to provide APIs and functions, not tests)
20:38:08 <btutt> (snippet from using HDBC)
20:38:37 <monochrom> but you look at the name OpenGLCheck and you know this package is explicitly test and test only.
20:40:07 <lispy> monochrom: I thought axfan said he didn't care about OpenGLCheck, but that he wanted to install something that depends on it
20:40:13 <axfan> yea
20:40:20 <axfan> i want to install this
20:40:24 <axfan> http://hackage.haskell.org/package/obj
20:40:31 <axfan> but its dependent on openglcheck
20:40:47 <monochrom> then the blame would still be on the author of obj, not cabal.
20:43:06 <axfan> well thank you for the help
20:44:02 <monochrom> all package managers (good or broken) I have seen tracks version range information
20:44:58 <monochrom> as for "should package x depend on package y", cabal or any package manager is just being a messenger.
20:46:18 <axfan> oh wow
20:46:22 <axfan> this is actaully my fault
20:46:25 <axfan> i should have read the package info
20:46:47 <axfan> talk to you guys later time to code
20:58:14 <dmwit> btutt: That error isn't mysterious.
20:58:20 <dmwit> It's telling you exactly how to fix your code.
20:58:35 <dmwit> Namely that you almost certainly meant (row:_) rather than [row:_].
20:59:37 <rothwell> hm... trying to work through the HXT pickling tutorial on the wiki and seem to have failed to manage the simplest example possible: http://paste.lisp.org/display/120836
20:59:38 <rothwell> main just prints []
21:00:02 <rothwell> assume there's something wrong with xpickle_colour, but i can't seem to write anything else that typechecks...
21:01:08 <dmwit> ?src print
21:01:08 <lambdabot> print x = putStrLn (show x)
21:01:25 <dmwit> Not going to help you, but (\c -> putStrLn (show c)) is better written (print). =)
21:01:50 <rothwell> dmwit: yeah, just a bad habit, there
21:02:54 <btutt> dmwit: So is the [row:_] better explained by: [column:_]? (in how the typechecker becomes unhappy?
21:03:38 <dmwit> btutt: The pattern [row:_] matches a list with exactly one element, that element being a non-empty list. Is that really the pattern you want?
21:04:13 <btutt> Yeah. I have a SQL result set with 1 row and 1 column
21:04:19 <dmwit> i.e. if [row:_] is bound to xs, then row = xs !! 0 !! 0
21:04:28 <dmwit> Okay.
21:04:36 <dmwit> Then, why are you trying to take the head of that result?
21:04:48 <dmwit> Presumably SQLResult is not a type alias for yet another layer of list.
21:05:00 <btutt> rows' is [[SqlValue]]
21:05:10 <dmwit> Yes, meaning row is SqlValue.
21:05:10 <btutt> shouldn't [row:_] yield [SqlValue]?
21:05:14 <dmwit> No.
21:05:22 <dmwit> You didn't read carefully enough, so try again. =)
21:06:41 <dmwit> rothwell: What I find odd about that snippet is that I don't see the constructor Colour used anywhere.
21:07:05 <dmwit> rothwell: Does HXT have some Template Haskell magic or similar that makes that happen, or where is that supposed to appear?
21:07:35 <rothwell> dmwit: as far as i know... no, but the wiki tutorial isn't too helpful
21:07:54 <rothwell> http://www.haskell.org/haskellwiki/HXT/Conversion_of_Haskell_data_from/to_XML
21:07:54 <rothwell> that one
21:08:33 <rothwell> there's probably something fundamental that i'm missing
21:09:36 <dmwit> Yup, there is.
21:09:52 <dmwit> In 3.4, you can see that they're using xpWrap, and the constructor for the datatype appears there.
21:10:02 <dmwit> In your example, the constructor never appears.
21:10:10 * rothwell eyes it
21:11:09 <dmwit> <- NOT an XHT expert
21:11:26 <rothwell> hehe... this is the first time i've looked at it
21:11:54 <dmwit> btutt: Do you understand the difference between the pattern (row:_) and the pattern [row:_]? If so, the rest of your problem should be pretty clear.
21:14:09 <btutt> i'm having trouble seeing the difference. :( Probably something to lookup in the report.
21:14:58 <ddarius> btutt: Why do you think they would be the same?
21:15:34 <napping> [x] is the same as (x:[])
21:16:31 <dmwit> btutt: Okay, then it's easy to explain.
21:16:56 <dmwit> btutt: The pattern (row:_) matches any (non-empty) list, binding "row" to the first element of the list, and throwing away the rest of the list (with the "_").
21:17:17 <dmwit> btutt: The pattern [row:_], on the other hand, is best understood as being two patterns:
21:17:51 <dmwit> First, the list is matched against the pattern [tmp], then the resulting variable tmp is matched against the pattern (row:_).
21:18:08 <dmwit> So, the whole pattern [row:_] *only* matches top-level lists with *exactly one element*.
21:18:38 <shachaf> ddarius: So did someone try to mug you or something like that in Boston a while ago?
21:18:40 <btutt> the hidden tmp thing is what is giving me grief. 
21:18:40 <dmwit> Moreover, that first element is further deconstructed into *its* first element, which is bound to "row", and the rest of that first element of the top-level list is thrown away.
21:19:00 * shachaf doesn't recall.
21:19:02 <dmwit> Consider:
21:19:13 <dmwit> > let (row:_) = [[1, 2], [3, 4]] in row
21:19:13 <lambdabot>   [1,2]
21:19:22 <dmwit> > let [row] = [[1, 2], [3, 4]] in row
21:19:23 <lambdabot>   *Exception: <interactive>:3:4-27: Irrefutable pattern failed for pattern [r...
21:19:30 <dmwit> > let [row] = [[1, 2]] in row
21:19:31 <lambdabot>   [1,2]
21:19:39 <dmwit> > let [row:_] = [[1, 2]] in row
21:19:40 <lambdabot>   1
21:20:14 <dmwit> > let ((row:_):[]) = [[1, 2]] in row
21:20:15 <lambdabot>   1
21:20:43 <dmwit> > let ((one:two:[]):rest) = [[1, 2], [3, 4]] in (one, two, rest)
21:20:44 <lambdabot>   (1,2,[[3,4]])
21:21:06 <dmwit> Playing with a few more examples like these on your own should help.
21:21:27 <dmwit> If you like, I could propose a few example pattern matches as puzzles, to see if you can guess how they would bind things. =)
21:22:05 <btutt> Its the whole :[] translation thing napping mentioned. highly non-intuitive given syntax that seems so simple [row:_] but yet behaves in a visually counterintuitive way (to me)
21:22:21 <dmwit> Consider how intuitive it looks here:
21:22:29 <dmwit> > let [one, two, three] = [1, 2, 3] in two
21:22:30 <lambdabot>   2
21:22:42 <dmwit> > let [one] = [1] in one
21:22:43 <lambdabot>   1
21:23:03 <dmwit> > let [(one, a)] = [(1, 'a')] in a
21:23:04 <lambdabot>   'a'
21:23:08 <dmwit> etc.
21:24:16 <napping> btutt: maybe it would make more sense with the parens
21:24:25 <napping> [row:_] is the same as [(row:_)]
21:24:37 <napping> and you know (row:_) is a pattern that matches a list
21:24:44 <btutt> yeah. I think the tidbit is just to use parents for pattern matching list.
21:24:52 <btutt> much simpler that way :(
21:24:56 <btutt> er, parens
21:25:09 <monochrom> use more parens, and desugar all [1,2,3] [1] etc.
21:25:24 <monochrom> write out (1:[]) instead of [1]
21:25:27 <dmwit> Personally, if I was expecting to get a nested list with exactly one row and one column, I'd probably write something like this:
21:25:35 <shachaf> ((:)((:)(row)(_))([]))
21:25:44 <linzy> hi
21:25:57 <dmwit> case result of { [[realResult]] -> Just realResult; _ -> Nothing } -- for btutt
21:26:21 <dmwit> It conveys very visually exactly what you're expecting to happen, I think.
21:26:41 <btutt> yep
21:27:02 <dmwit> rothwell: How's that HXT coming?
21:27:36 <quantum> monochrom is an asshole
21:27:37 <quantum> fuck that guy
21:27:45 --- mode: ChanServ set +o monochrom
21:28:03 --- mode: monochrom set +b *!*@unaffiliated/j-invariant
21:28:08 --- kick: quantum was kicked by monochrom (quantum)
21:28:08 <rothwell> dmwit: just updated to: http://paste.lisp.org/display/120836#1
21:28:10 <napping> Hello
21:28:12 --- mode: monochrom set -o monochrom
21:28:25 <rothwell> dmwit: it... looks right, but apparently still isn't
21:28:37 <napping> linzy: did you see shachaf's totem pole?
21:28:48 <dmwit> rothwell: That looks more believable, yeah.
21:29:12 <btutt> dmwit: Thanks for the help.
21:29:12 <rothwell> HXT.xpWrap (Colour, from_colour) :: HXT.PU String -> HXT.PU Colour
21:29:32 <dmwit> BTW, from_colour is often written as "data Colour = Colour { fromColour :: String } deriving (Eq, Show)".
21:29:49 <napping> Does Haskell have a subobject classifier?
21:29:52 <rothwell> dmwit: ah, yeah
21:31:18 <rothwell> dmwit: erk... it suddenly works
21:31:52 <btutt> napping: you mean like rec.recordId?
21:31:58 <rothwell> dmwit: got a sneaking suspicion that code i just pasted works and that i hadn't hit save
21:31:58 <rothwell> or something idiotic
21:32:06 <btutt> (where rec is a variable binding)
21:32:22 <dmwit> rothwell: Great. =)
21:32:22 <rothwell> dmwit: yeah, it does
21:32:27 <dongstermobile> Hi
21:32:35 <ddarius> napping: Haskell is a programming language not a category.
21:32:58 <dmwit> Howdy, dongstermobile.
21:33:04 <napping> ddarius: in the denotational semantics we all pretend exists
21:33:07 <dongstermobile> Is there some pretty printer for ByteStrings or a way to not display the Chunk prefix and End?
21:33:27 <dongstermobile> Rather than use my own pretty printer (which would likely be slow).
21:34:33 <dmwit> dongstermobile: There's unpack, I guess, but be careful: a ByteString is *not* a String.
21:34:49 * rothwell eyes gap where he expected hxt bytestring functions to be
21:35:21 <dongstermobile> dmwit: Right, that's something I wanted to avoid. I'll just use the bytestring output routines.
21:36:08 <ddarius> napping: Depending on how much you idealize Haskell the answer varies from "You don't have a category" to "Bool".
21:36:48 <napping> I'd like to at least not idealize away bottoms
21:37:06 <dongstermobile> bye
21:40:00 <ddarius> napping: You probably want to look at synthetic topology.
21:41:30 <napping> ah, that does look interesting. Also, a small counter-example would be nice
21:41:45 <napping> from some of the stricter senses
21:42:57 <ddarius> A counter-example of what?
21:43:43 <napping> how you don't have a category, whether distinguishing undefined from const undefined means you don't have proper exponentials, etc
21:44:18 <ddarius> It depends on how exactly you define the category, but certainly Haskell's (.) and id don't satisfy the unit laws.
21:44:54 <monochrom> the utility of bytestring in hxt is rather limited
21:46:05 * ddarius needs a novel.
21:46:40 <monochrom> and I mean in principle, in every xml lib. parser and unparser using bytestring as an internal buffer, sure. bytestring for text nodes? no way. a byte is not a character.
21:47:11 <napping> well, those are functions themselves rather than actual composition
21:50:10 <rothwell> hm... no options for unicode bytestrings? there's compact-string but it's broken on 7.0
21:50:39 <monochrom> "unicode bytestring" is a self-contradiction
21:50:48 <napping> there are various packages for encoding and decoding
21:50:50 * ddarius was going to say "oxymoron."
21:51:01 <monochrom> utf-8 bytestring sure. unicode Data.Text sure.
21:51:07 <napping> many things seem to expect bytestrings to contain utf-8
21:51:20 <dmwit> rothwell: In case nobody's said it yet, use Text.
21:51:29 <rothwell> i don't think it is... it's just that the bytestring library exposes an interface that addresses by bytes and not characters
21:51:34 <rothwell> dmwit: thanks
21:51:40 <monochrom> now of course hxt hasn't used Data.Text yet.
21:52:41 * ddarius should probably read "Twenty Thousand Leagues Under The Sea"
21:53:03 <shachaf> ddarius: _The Mysterious Island_.
21:53:06 <shachaf> (If you haven't.)
21:54:36 <rothwell> i just started the third book of the baroque cycle, "the system of the world"
21:54:36 <rothwell> would recommend
22:11:15 <Axman6> dolio: i have fans? :o
22:11:27 <dolio> Apparently.
22:11:33 <ddarius> "We describe Directed Type Theory, a new notion of dependent type theory, inspired by higher dimensional category theory"
22:13:02 <deech> Hi all, anyone here use/play with Hare?
22:14:34 <lambdabot> lambdabot has a karma of as big as she wants
22:16:12 <djahandarie> ddarius, where is this?
22:17:30 <ddarius> Dan Licata's thesis.
22:20:36 <djahandarie> Does he use it in his other papers?
22:21:35 <djahandarie> Seems like he doesn't have many papers published after this one
22:22:09 <ddarius> The copyright on his thesis is 2011, what do you want of him?
22:22:30 <djahandarie> Nothing, I was just observing this fact
22:28:33 <roconnor> They say that laziness kept Haskell pure, and purity is what is important, not laziness
22:28:52 <roconnor> but the reason purity is important is that it allows equational reasoning
22:29:18 <roconnor> but, in the presence of general recursion, I don't see how you can do equational reasoning without laziness (non-strictness)
22:29:33 <roconnor> meaning laziness is important after all
22:29:48 <zomg> I like how none of that made absolutely no sense 
22:29:48 <zomg> :D
22:30:00 <zomg> but that's probably just me 'cause I'm a haskell noob
22:30:01 <zomg> =)
22:30:15 <dabblego> it makes a lot of sense to me
22:30:15 <zomg> Oh and I used a double negative. That was unintentional
22:30:17 <roconnor> I'm glad all of it made some sense
22:30:17 <blackdog> roconnor: pete gammie was making a point to me about that a couuple of days ago
22:30:32 <roconnor> I'm glad I'm not alone
22:30:56 <blackdog> roconnor: apparently when you try to automate richard bird's proofs, for instance, you hit a stumbling block - once you have laziness, then you can't necessarily use inductive arguments
22:31:35 <blackdog> because you've got potentially infinite structures, so some equational transformations may not preserve termination
22:31:48 <roconnor> really?
22:31:56 <roconnor> hmm, I guess so
22:32:04 <blackdog> i don't know, i haven't tried to automate them:)
22:32:14 <blackdog> but pete's done a fair bit of work on that sort of thing.
22:32:15 <jmcarthur> that doesn't sound like a laziness issue. that sounds like motivation for distinction between data and codata
22:32:16 <roconnor> but if you have strictness
22:32:25 <jmcarthur> (to me)
22:32:28 <roconnor> you cannot substitute a function with it's definition
22:32:41 <blackdog> jmcarthur: possibly. but bird is proving things using haskell as a base
22:32:52 <jmcarthur> ah
22:32:55 <roconnor> jmcarthur: in the presence of general recursion, doesn't data and codata collapse into the same thing? ... maybe not.
22:33:19 <joe6> agda's dependent typing is pretty cool and intuitive. But, can agda be used for programming as we do in haskell?
22:33:29 <jmcarthur> roconnor: i'm not sure if there is a distinction when you have general recursion
22:33:32 <napping> yeah, there's no difference between data and codata in Haskell
22:33:50 <joe6> there seems to be a lot of literature on using agda for programming, but am not sure if it is possible to do IO and stuff 
22:33:51 <roconnor> joe6: as long as you don't need to tie the knot, you are probably fine in Agda
22:33:53 <jmcarthur> joe6: sure it can. it even uses haskell as its FFI
22:34:07 <napping> I'm going to read Bart Jacob's paper about inductive reasoning after I finish some other things
22:34:09 <jmcarthur> joe6: the standard library has IO stuff
22:34:30 <joe6> cool, thanks a lot. off to agda tutorials, then.
22:34:38 <joe6> jmcarthur, roconnor, thanks
22:34:42 <jmcarthur> joe6: http://www.cse.chalmers.se/~nad/listings/lib-0.5/IO.html#1
22:37:05 <napping> something about partial data being also inital when you work in CPOs, so there should be some way to do induction
22:55:53 <joe6> jmcarthur, thanks, just got my first hello world from agda.
22:56:23 <joe6> i seem to get better response when I ask agda questions here than in the #agda irc. Is it bad to ask agda questions here?
23:03:25 <ddarius> roconnor is complaining that the full beta rule is not (generally) valid in eager languages.
23:10:35 <roconnor> ddarius: do you ever sleep? :D
23:12:24 <ddarius> It depends on what tomorrow brings.
23:28:31 <Axman6> osoleve: how goes the haskelling?
23:33:46 <miller> I have a happy grammar that, when i try to compile it with happy, always has happy saying "Parse error:" with the line being one greater than the last line in my file. Has anyone run into this before?
23:34:27 <Axman6> miller: that just means the error is before that line... good luck finding it :)
23:34:34 <miller> @_@
23:36:28 <Jafet> For a moment, I thought happy was an adjective there
23:36:57 <Axman6> i guess you'll just have to take a close look at the code and try to find the error in your parser. if you can't see it, try removing things until it stops breaking
23:36:57 <rothwell> i think most adjectives regarding happy are unprintable
23:37:07 <Axman6> heh
23:39:01 <miller> Axman6: I can remove literally everything in the file though, and still get just 'Parse error'...
23:39:23 <miller> my first thought was to try and find some subset that didn't give an error, but... i.. can't find any
23:43:10 <rothwell> erk... "Pattern rng:interleave is not allowed in Relax NG schema"
23:43:10 <rothwell> i dispute that!
23:44:56 <rothwell> ugh... works if you just use a raw xmlns instead of xmlns:rng in the schema
23:44:57 <rothwell> sounds like a bug to me
23:47:27 * hackagebot wai-handler-devel 0.2.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.2.1 (MichaelSnoyman)
23:47:29 * hackagebot yesod 0.7.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.7.2 (MichaelSnoyman)
