00:31:14 <Skola> is there any lhs to html parser that will let me concert && into &and;
00:31:15 <Skola> etc?
00:31:19 <Skola> convert*
00:31:58 <Skola> <- to &larr;
00:32:02 <Skola> etc
00:37:24 <Skola> It feels a bit cheap to just go over the document with some JS replaces
00:39:31 <kuda> hello
00:39:39 <kuda> anyone Haskell users from Australia?
00:39:44 <kuda> *any
01:01:52 <jeffwheeler> kuda: I think they held a Haskell meetup in Brisbane
01:02:24 <jeffwheeler> kuda: here's some more info: http://www.haskell.org/haskellwiki/User_groups#Australia
01:02:56 <jeffwheeler> kuda: you can also look at this map: http://www.haskellers.com/
01:17:28 <kuda> thanks jeffwheeler 
01:23:39 <hamishmack> kuda: There is a #haskell.au her on IRC.  Also http://www.mail-archive.com/haskell-cafe@haskell.org/msg87878.html
01:24:12 <kuda> join #haskell.au
01:24:33 <kuda> oh thanks hamishmack 
01:24:42 <kuda> not too many people but good to know :)
01:53:04 <Spockz> is there a way I can ask the compiler to give me all the available functions given a certain haskell file?
01:55:02 <Saizan> you can load the file in ghci and then use :browse
02:11:34 <kniu> Where can I get an implementation of treaps?
02:11:54 <kniu> Or do I have to write one myself?
02:37:03 * hackagebot hquantlib 0.0.1.1 - HQuantLib is a port of essencial parts of QuantLib to Haskell  http://hackage.haskell.org/package/hquantlib-0.0.1.1 (PavelRyzhov)
03:27:13 <Layla93> I got this link from a friend.. I kinda did not like the title.. but there might be some good parts.. Please leave comments on it : http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
04:02:37 <cheater00> hi
04:02:45 <cheater00> can haskell be said to be a "declarative" language?
04:04:33 <Twey> cheater00: Yes
04:04:42 <Twey> (as can most things)
04:05:12 <Twey> Haskell is probably more declarative than most.  Certain libraries/EDSLs are entirely declarative.
04:06:29 <mercury^> The wording is not very good in my opinion. C is completely declarative.
04:06:47 <mercury^> `predicative' might be better
04:08:23 <cheater99> how is C declarative?
04:08:50 <mercury^> How is it not?
04:09:07 <cheater99> show me a definition of "declarative programming language" that includes C.
04:10:47 <cheater99> In computer science, declarative programming is a programming paradigm that expresses the logic of a computation without describing its control flow.[1] Many languages applying this style attempt to minimize or eliminate side effects by describing what the program should accomplish, rather than describing how to go about accomplishing it.[2] This is in contrast with imperative programming, which requires an explicitly provided algorithm.
04:11:11 <cheater99> Common declarative languages include those of regular expressions, logic programming, and functional programming.
04:11:11 <mercury^> Declarative is an english adjective. C programs are declarative because they declare a program behaviour.
04:11:17 <Twey> cheater99: http://conal.net/blog/posts/the-c-language-is-purely-functional/
04:11:23 <cheater99> Twey: yeah lol
04:11:24 <mercury^> Why are you quoting from, presumably wikipedia?
04:11:35 <cheater99> mercury^: yeah, and a ring is an english noun too
04:11:51 <cheater99> doesn't mean algebra is about marriages
04:12:21 <cheater99> and calculus isn't about, you know, stones!
04:12:25 <mercury^> Clearly the `declarative' in `declarative programming language' is not meant to diverge from the inherent english meaning.
04:13:04 <cheater99> well, i didn't know an amorphous metal could actually type on a computer keyboard
04:19:15 <masak> mercury^: you may make the argument all you want, it still doesn't change the generally agreed-upon meaning of "declarative language".
04:20:48 <mercury^> masak: my argument was not against the concept that denotes but against the name for it.
04:21:30 <masak> some names are wrong from some perspectives. that's life.
04:22:07 <masak> "declarative" here is not meant to be read as "contains declarations", but more like "focuses on the 'what' rather than the 'how'"
04:22:56 <mercury^> masak: the C program is also concerned with `what', but its domain of discourse is another.
04:22:59 <masak> C, with its operators, loops, and conditional statements clearly focuses on the how.
04:23:25 <mercury^> As I said, `predicative' might be better.
04:23:49 <Twey> masak: When you say ‘square x = x * x’, is that focussing on the ‘what’ or the ‘how’?
04:23:49 <masak> the common term is 'imperative', which isn't ideal, but there you go.
04:24:25 <masak> Twey: I'm aware that the dichotomy imperative/relative breaks down at some point, if that's what you're after.
04:24:34 <Twey> You can read that as ‘The square of x is x multiplied by itself’ (what) or ‘to get the square of x, take x and multiply it by itself’ (how)
04:24:46 <Twey> Two sides of the same coin
04:24:57 <masak> Twey: aye. I guess it depends on the language that declaration is made in.
04:25:33 <masak> or one could conceivably hold either view in the same language, even.
04:25:59 <Twey> Aye
04:26:21 <Twey> It's just an arbitrary label; it describes how you look at things, not anything about the actual language in which they're written
04:26:36 <masak> I beg to differ.
04:26:53 <masak> commonly, languages *themselves* adopt or induce a look at things.
04:27:10 <masak> C doesn't induce a declarative prespecive on the world.
04:27:15 <masak> Prolog does.
04:27:53 <masak> I guess someone, trying hard enough, could write declarative C, or imperative Prolog.
04:27:54 <mercury^> Please stop misusing `declarative' already, at least for this discussion. :/
04:28:38 <masak> I don't want to offend with my use of 'declarative' -- but I am using it as it's usually being used.
04:29:45 <masak> you could tell me to stop calling tall people 'tall' and start calling them 'vertically ambitious'. that would just make it harder for me to describe them.
04:31:21 <Saizan> it's fairly common practice to take a natural language adjective and give it a narrower/different meaning when used in technical contexts
04:31:45 <mercury^> This is not about political correctness. There is no risk of a language being insulted. It is just that you are confusing people with the terminology. I am always confused for example and always have to take care when reading `declarative', because the natural meaning and this technical one are completely different.
04:31:55 <masak> language is a tool, and one that occurs in contexts.
04:32:14 <augur> Saizan: : this is true!
04:32:17 <mercury^> Yes, but ideally if you give something a completely different meaning, only one of those can apply in any context.
04:32:18 <masak> mercury^: I see someone trying to go against the grain of an established term. let me know how that goes.
04:32:41 <augur> so whats this shit, people talking about natural language and all?
04:33:17 <Saizan> in fact, i think non-native english speakers have quite an advantage here :)
04:34:09 <codolio> I get confused when people talk about irrational and imaginary numbers.
04:34:32 <mercury^> `imaginary' can sometimes be a real problem
04:34:51 <mercury^> Fortunately that does not normally happen in mathematical contexts.
04:35:09 <Twey> codolio: Why?
04:35:24 <Twey> Those mean pretty much what they say :þ
04:36:00 <sipa> this integrally rational solution is naturally quite complex
04:36:37 <mercury^> `rational' can also mean `logical', thus the confusion Twey.
04:36:54 <mercury^> `natural' is of course also very dangerous
04:37:11 <sipa> hey, mathematicians defined "sexy prime numbers"
04:37:18 <Twey> mercury^: You can see it like that, too: ‘impossible to predict’
04:37:29 <Twey> ‘Natural’ is a crime against nature
04:46:09 <Jafet> But any large program involving ContT must be declarative, because there is no easy way for other people to figure out the control flow.
04:46:45 <Twey> ‘Must’ only in the sense that one is likely to get punched in the nose if it is not
04:47:39 * hackagebot cryptohash 0.7.0 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.0 (VincentHanquez)
04:50:26 <Jafet> Hash.Skein? Sounds a little premature
04:51:25 <sipa> as long as it isn't called sha3
05:02:40 * hackagebot timers-updatable 0.2.0.1 - timers which are updatable in the remaining time  http://hackage.haskell.org/package/timers-updatable-0.2.0.1 (PaoloVeronelli)
05:03:36 <Skola> euler4  0.00s user 0.00s system 73% cpu 0.002 total
05:04:03 <Skola> after time
05:04:09 <Skola> can I get more precise measurements?
05:04:21 <Skola> or should I profile my programs with other tools?
05:09:27 <mercury^> Skola: most processors can give you clock counts.
05:10:16 <Skola> ok, would you advice it for profiling? or should I look into Haskell-specific profiling?
05:10:20 <Jafet> Solve real problems
05:11:08 <Skola> will
05:11:16 <Skola> but just learning the language
05:11:34 <Skola> and trying to understand my mistakes
05:12:21 <Jafet> Or at least, bigger fake problems
05:12:38 <Skola> yeah I'm just going over my initial solutions
05:13:08 <Skola> learned some new things this week so doing quick rewrite of the first few problems
05:13:53 <Skola> but are there Haskell specific "fake" problems that are more relevant?
05:16:26 <Jafet> Well, the Euler problems don't inherently teach you Haskell, except by accident.
05:16:57 <Jafet> I suggest just deciding what kind of program you want to write and then try to write it in Haskell
05:20:04 <Skola> well eventually I want to rewrite a personal app (which has project management, news reader, searchable code-library functionality)
05:20:08 <Skola> it has a web interface
05:20:19 <Skola> and runs on my own machine
05:20:22 <blueonyx> hi, is there already some Snap Request -> HTTP.Enumerator Request converter and vice versa for Response, ie an haskell http proxy?
05:20:24 <Skola> it's currently written in python
05:21:26 <lgm> Hello!
05:21:36 <Skola> oh yes, it also has NLP functionality
05:22:06 <Skola> so there's a wide range of functionality that I want to explore
05:22:26 <lgm> Does anyone on this channel know the Kiselyov, Shan and Friedman version of Backtracking Monad Transformers, known as LogicT?
05:22:49 <lgm> i have a question about the typing
05:23:45 <lgm> i know that Haskell doesn't insist that Monads are functors, but i thought this was just a niggle and everyone really made them functors
05:24:53 <lgm> it looks like, however, that the two-continuation version of their code is not functorial
05:28:10 <hpc> lgm: if it follows the monad laws, there is always a function fmap = liftM
05:28:19 <hpc> so if it isn't a functor, it isn't a monad either
05:28:26 <lgm> wonderful
05:29:23 <lgm> i would love to see how we get a map from sfkt a -> sfkt b given a map a -> b
05:31:46 <lgm> from an sfkt a we can extract a map forall ans.SK (m ans) a -> FK (m ans) -> M ans
05:32:26 <lgm> but i certainly don't see how to compose f with this to get the corresponding sfkt b
05:35:48 <ndrsndrs> how difficult is it to use utf8 input with BNFC?
05:36:58 <ndrsndrs> agda removes the unicode characters from the input before feeding it to alex, but i'm not sure if you can do that sort of thing without writing the .x by hand
05:40:22 <Saizan> lgm: liftM f m = m >>= (\x -> return (f x) -- inline >>= and return for LogicT by hand 
05:40:50 <Dunearhp> does anyone know if there is a ubuntu repository for the latest haskell platform? The one linked from the default page still has platform 2010
05:41:14 <outsid3r> hi
05:41:34 <outsid3r> if i have a list like [1,2,3,4], how i apply foldr to get [2,3,4,1] ?
05:42:40 <lgm> Saizan: is that to implement fmap?
05:43:09 <benmachine> lgm: yes
05:44:00 <mercury^> outsid3r: why do you want to use foldr?
05:44:04 <mercury^> It is complicated and unnatural.
05:44:08 <lgm> i'm sorry, i'm must be getting tired
05:44:22 <outsid3r> idk, but i must write reverse function using foldr
05:44:45 <mercury^> What you gave as example is not reverse.
05:44:55 <outsid3r> i know
05:45:03 <mercury^> ok...
05:45:22 <outsid3r> but i was thinking about creating a recursive function that would do that till it get fully reversed
05:45:32 <mercury^> that's just stupid
05:45:52 <mercury^> reverse is much easier
05:45:58 <lgm> i don't see how that works out at all
05:46:15 <outsid3r> lol i know, but this is a college exercice
05:46:15 <outsid3r> exercise*
05:46:26 <mercury^> Yes, and you are doing it wrongly.
05:46:42 <lgm> can you provide a simple expression for fmap directly?
05:46:56 <lgm> fmap f = ???
05:47:07 <lgm> for LogicT, that is
05:47:18 <lgm> using the two-continuation data type
05:47:18 <hpc> lgm: fmap = liftM
05:47:31 <hpc> :t fmap `asTypeOf` liftM
05:47:32 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => (a -> b) -> f a -> f b
05:47:53 <hpc> @src liftM
05:47:53 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:47:54 <outsid3r> mercury that's why im asking for help
05:47:55 <Saizan> hpc: he wants an implementation that doesn't use combinators
05:48:06 <lgm> no -- that's ok
05:48:15 <mercury^> outsid3r: how do you implement the identity on lists using foldr?
05:48:18 <hpc> then fmap f m = m >>= return . f
05:48:27 <outsid3r> mercury^, idk
05:48:45 <mercury^> outsid3r: ok, then think about it for a while.
05:48:54 <outsid3r> mercury^, what do you mean with identity?
05:49:03 <lgm> yes, i see
05:49:07 <mercury^> > id [1,2,3,4]
05:49:07 <lgm> i'm being stupid
05:49:07 <lambdabot>   [1,2,3,4]
05:49:22 <outsid3r> then is foldr (:) [] [1,2,3,4]
05:49:25 <lgm> sorry -- it's nearly 6am and i'm just brain dead
05:49:43 <hpc> outsid3r: exactly
05:49:54 <mercury^> outsid3r: ok. Can you modify that a bit to get what you want maybe?
05:50:19 <outsid3r> i need to get 4:3:2:1:[]
05:50:22 <outsid3r> hmm
05:50:29 <Saizan> foldr (:) [] = foldr (\x xs -> [x] ++ xs) []
05:50:41 <Saizan> now, that puts x in front 
05:53:01 <lgm> thanks for your help!
05:58:10 <mercury^> outsid3r: still at it?
05:58:56 <outsid3r> back, i left my room for a while, im gonna try it now
05:59:58 <outsid3r> any tips?
06:00:03 <mercury^> outsid3r: (:) prepends its first argument to its second argument. You can use foldr to write something with appends its first argument to the second argument.
06:00:29 <mercury^> Which is what you need as the argument for another foldr which reverses the list.
06:01:24 <Dunearhp> >foldr (\a b -> a:b) [] [1,2,3,4]
06:01:43 <Dunearhp> > foldr (\a b -> a:b) [] [1,2,3,4]
06:01:44 <lambdabot>   [1,2,3,4]
06:01:48 <outsid3r> thats the identity
06:02:24 <mercury^> We do not want to spoil your fun of finding the solution yourself.
06:03:59 <outsid3r> well with foldl it gets easy, foldl (\a b -> b:a) [] [1,2,3,4]
06:05:22 <mercury^> > foldl (flip (:)) [] [1..4]
06:05:24 <lambdabot>   [4,3,2,1]
06:05:33 <mercury^> Yep.
06:05:38 <chessguy> also known as...reverse
06:05:58 <outsid3r> i didnt knew that function flip
06:06:25 <mercury^> You do not need it now anyway.
06:08:53 <outsid3r> why foldl (:) [] [1,2,3,4] does not work?
06:09:45 <mercury^> > foldl f [a,b,c,d]
06:09:46 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
06:09:46 <lambdabot>    arising fr...
06:09:55 <mercury^> bleh, how is that done?
06:10:07 <mercury^> anyway, write out what it actually means.
06:11:14 <Saizan> > foldl f z [a,b,c,d]
06:11:14 <lambdabot>   f (f (f (f z a) b) c) d
06:11:16 <outsid3r> it cant work because it the same as []:4:3:2:1
06:11:37 <mercury^> outsid3r: exactly.
06:11:52 <mercury^> Err, not quite actually.
06:12:22 <outsid3r> 1:2:3:4:[] => []:4:3:2:1
06:12:26 <outsid3r> oh
06:12:31 <outsid3r> []:4:3:2:1:[]
06:12:32 <sipa> wrong
06:12:37 <sipa> [] is not a number
06:12:58 <sipa> [1,2,3,4] = 1:2:3:4:[]
06:13:02 <outsid3r> foldl (:) [] [1,2,3,4] => []:4:3:2:1:[]
06:13:22 <mercury^> outsid3r: nope, still not there.
06:13:27 <sipa> outsid3r: that's []:(4:3:2:1:[])
06:13:39 <sipa> and [] is not a number, so you can't prepend it to a list of numbers
06:13:49 <mercury^> sipa: that is not the point right now.
06:14:25 <outsid3r> so the second arguments is appended first
06:14:43 <outsid3r> :t foldl
06:14:43 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:15:09 <mercury^> outsid3r: it becomes (1:2):3
06:15:31 <mercury^> bleh
06:15:35 <mercury^> stupid keyboard :<
06:16:13 <mercury^> outsid3r: it becomes ((([]:1):2):3):4
06:16:21 <mercury^> Which is not a list.
06:16:31 <outsid3r> yes
06:17:10 <hpc> mercury^: it could be, if you have an appropriately crazy num instance ;)
06:17:39 <mercury^> hpc: I don't think that is ever a list.
06:17:41 <outsid3r> so, how i reverse a list with foldr ?
06:17:52 <mercury^> outsid3r: *sigh*
06:18:23 <mercury^> > foldr (foldr (:) . return) [] [1..4]
06:18:25 <lambdabot>   [4,3,2,1]
06:18:36 <Fuco> whoa
06:18:36 <outsid3r> what is . return ?
06:18:46 <mercury^> > return 3
06:18:47 <lambdabot>   No instance for (GHC.Show.Show (m t))
06:18:47 <lambdabot>    arising from a use of `M6412667863...
06:18:48 <hpc> mercury^: instance Num a => Num [a] -- your list becomes [[Int]], and probably ends up being []:[1]:[2]:[3]:([4]:[])
06:19:07 <mercury^> > (return 3) :: [Int]
06:19:08 <lambdabot>   [3]
06:19:09 <hpc> (4 gets "listified" twice to make types match)
06:19:37 <outsid3r> is there other way without using return?
06:19:47 <outsid3r> because i never learned that
06:19:57 <hpc> outsid3r: return = (:[])
06:20:06 <benmachine> outsid3r: do you know how to reverse a list without foldr?
06:20:11 <hpc> outsid3r: aka, it takes a thing and makes it the only element of the list
06:20:41 <benmachine> mercury^: is that the O(n^2) form of reverse?
06:20:51 <sdrodge> oustid3r: . is function composition and return takes something and wraps it in a list (in this context)
06:22:27 <mercury^> benmachine: I am not entirely certain if it actually ends up that, with lazy evaluation and fusion etc. Do you have something that is obviously not O(n^2) and uses foldr?
06:22:45 <benmachine> reverse xs = foldr (\x rev -> rev . (x:)) id xs []
06:22:51 <benmachine> difflists woo :P
06:24:01 <Saizan> which is exactly what you get if you define foldl with foldr and then use foldl (flip (:)) []
06:24:05 <benmachine> yes
06:24:09 <benmachine> that is how I found it I think
06:24:21 <outsid3r> f . g = f (g x) 
06:24:36 <Saizan> f . g = \x -> f (g x)
06:24:59 <benmachine> (f . g) x = f (g x)
06:30:12 <Jonno_FTW> f . g = (\f -> f) (g x)
06:30:42 <hpc> Jonno_FTW: that makes negative sense :P
06:30:45 <mercury^> Jonno_FTW: err, no.
06:30:51 <Jonno_FTW> :(
06:31:03 <Jonno_FTW> oic
06:31:22 <hpc> what you defined is the same as
06:31:29 <hpc> (.) _ g = id (g x)
06:31:36 <hpc> for some mysterious x value
06:31:38 <cheater99> hi
06:31:44 <Jonno_FTW> hello
06:31:50 <cheater99> can haskell be called a "declarative" language?
06:32:08 <opqdonut> sure it can
06:32:14 <Saizan> trying again?:D
06:32:14 <hpc> cheater99: yes
06:32:29 <opqdonut> at least when compared to traditional imperative languages
06:33:15 <hpc> the quintessential example of delcarative programming in haskell is basically every pure value ever
06:33:28 <cheater99> when is haskell non-declarative?
06:33:32 <hpc> in IO
06:33:39 <Saizan> hpc: i wouldn't be that broad
06:33:42 <opqdonut> well haskell
06:34:05 <opqdonut> *haskell's IO is more declarative than, say, IO in C
06:34:17 <opqdonut> (damn ' and return keys are too close to each other)
06:34:36 <hpc> Saizan: fair; but for sufficiently not-ugly functions, you are really saying more about what something is, than what the function does
06:34:42 <cheater99> Saizan: why?
06:34:56 <hpc> "derivative of a constant multiplied by x is that constant)
06:34:59 <hpc> etc
06:35:24 <Saizan> cheater99: because the intent of even pure code might be quite obfuscated by implementation details
06:35:41 <cheater99> Saizan: i don't think that's what declarative means
06:35:53 <cheater99> Saizan: i think what you mean is "descriptive"
06:36:06 <sipa> declarative = saying what, not how
06:36:11 <hpc> declarative vs imperative == "this is what it is" vs "this is what it does"
06:36:26 <Saizan> i knew i shouldn't get in a discussion about such ill-defined terms
06:36:32 <sipa> haha
06:36:34 <cheater99> hpc: i would think about differently, "this is what it is" vs "this is how to get it"
06:36:35 <hpc> heh
06:36:47 <Saizan> "what it is" and "what it does" are quite meaningless too
06:37:14 <Jafet> What code does is to be doing.
06:37:17 <Saizan> i've seen a room with half people having one idea of "what vs. how" and the other half the opposite.
06:37:28 <yottis> i think it's a matter of degree
06:37:31 <hpc> Saizan: not really; just because the boundary is fuzzy doesn't mean we can't reason about how much of each aspect haskell has
06:37:46 <Saizan> luckily i was in the one that agreed with the prof. so i got the exam right :)
06:37:46 <hpc> a blue-green gradient is still blue and green, so to speak
06:37:52 <yottis> haskell is clearly more declarative than say C, but less than sql
06:38:10 <hpc> sql isn't very declarative, imo
06:38:22 <Saizan> hpc: it's not just fuzzy, it's so vague it can even be inverted.
06:38:50 <hpc> perhaps this should be in -blah?
06:40:02 <hpc> (an sql statement reads like you are telling it what to do: "select a bunch of columns from table X, where 5 is less than 6"
06:40:05 <hpc> )
06:40:54 <cheater00> you mean less than sql selects. there are many many imperative things in sql. i don't think you can get *any* more declarative than a constraint engine, so yeah, i'd say sql is pretty declarative
06:43:54 <outsid3r> using foldl i need to define a function dec2int that receives a list [2,3,4,5] for example and returns and int 2345
06:44:11 <outsid3r> well my first thought was 5*1 + 4*10 + 3*100 + 2*1000
06:45:32 <hpc> outsid3r: read . map (head . show)?
06:45:44 <Saizan> write an equivalent expression that only ever uses 10 to multiply
06:45:44 <outsid3r> ?
06:46:00 <outsid3r> idk read and show functions
06:46:11 <Jonno_FTW> > show 5
06:46:11 <lambdabot>   "5"
06:46:12 <hpc> show :: Something -> String
06:46:20 <outsid3r> it cant be a string
06:46:28 <Saizan> hpc: it's an exercise that he needs to do with foldl
06:46:29 <outsid3r> dec2int :: [Int] -> Int
06:46:29 <hpc> > head . show $ 5
06:46:31 <Jonno_FTW> > read "5"
06:46:31 <lambdabot>   '5'
06:46:32 <lambdabot>   *Exception: Prelude.read: no parse
06:46:37 <Jonno_FTW> > read '5'
06:46:38 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:46:38 <lambdabot>         against inferred ty...
06:46:44 <hpc> Saizan: ah
06:46:45 <Jonno_FTW> > read '5' :: Int
06:46:45 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:46:45 <lambdabot>         against inferred ty...
06:46:59 <Saizan> outsid3r: you can ask yoursefl a few questions to sort this out
06:47:11 <Saizan> outsid3r: what should be the result of dec2int [] ?
06:47:42 <outsid3r> these exercices are pretty basic using another language, with haskell everything tends to be difficult, except then we really get used to it
06:47:50 <monad> Woho!
06:47:57 * monad goes >>=
06:48:11 <zygohistopreprom> i have no idea what i do!
06:48:21 <Jafet> > read . concatMap show $ [2,3,4,5] :: Int
06:48:23 <lambdabot>   2345
06:48:29 <hpc> (... that was supposed to be "prepromorphism"
06:48:30 <hpc> )
06:48:48 <monad> I wonder how many times i will be highlighted with this nick.
06:48:59 <hpc> only one way to find out!
06:49:19 * monad transforms into a statemonad with a counter.
06:50:43 <hpc> that reminds me, it's gonna be fun when lyah does transformers
06:50:54 <hpc> the jokes will be so bad, but so good
06:51:25 <monad> A craploads of monads in monads?
06:51:36 <Bfig> what is the difference with flip $ (.) and flip . ? looking at the types i don't understand why the b and c are switched instead of the a and b (for the second function) and why the function differs in currification
06:51:59 <opqdonut> :t flip (.)
06:52:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
06:52:02 <opqdonut> :t (flip .)
06:52:02 <Jafet> (flip .) is (.) flip
06:52:03 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f1 (f (a -> b)) -> f1 (a -> f b)
06:52:06 <hpc> Bfig: flip (.) is flip applied to (.)
06:52:17 <hpc> Bfig: (flip .) is flip applied to (.)
06:52:18 <opqdonut> gah, too generic :)
06:52:19 <Bfig> flip applies to the arguments of . vs flip applies to the applied to the overall input?
06:52:21 <hpc> er
06:52:32 <hpc> flip (.) is (.) applied to flip
06:52:37 <hpc> (flip .) = (.) flip
06:52:42 <outsid3r> any tips ?
06:52:53 <Saizan> outsid3r: what should be the result of dec2int [] ?
06:53:05 <benmachine> hpc: rly? do you apply a function to an argument or an argument to a function?
06:53:12 <hpc> Bfig: for what that does to the types and why, this might help: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=4
06:53:19 <Jafet> outsider: how would you do it in any other language?
06:53:21 <outsid3r> well, i think is 0 but in the exercise it does not state anything about it
06:53:21 <hpc> benmachine: quiet you, it's early here
06:53:33 <Saizan> outsid3r: 0 seems fine
06:54:18 <Saizan> outsid3r: given that we know that   dec2int = foldl f 0, now we have to find what to use for f
06:55:02 <Saizan> outsid3r: now, suppose acc = dec2int xs; what should be the result of "dec2int (xs ++ [x])" ?
06:57:55 <Saizan> e.g. xs = [2,3] and x = 4; so dec2int [2,3] = 2*10 + 3 (if dec2int is correct), then dec2int (xs ++ [x]) = 2*100 + 3*10 + 4, but we want to write that by applying some f to (2*10+3) and 4
06:58:08 <outsid3r> w8
06:58:30 <Saizan> can you see what f should be if f (2*10+3) 4 = 2*100 + 3*10 + 4 ?
06:59:58 <outsid3r> i wrote using lists by comprehension: sum [x*y | (x,y) <- zip (reverse [2,3,4,5]) [10**x | x <- [0,1..]]]
07:01:15 <outsid3r> well now i need to write it using foldr
07:01:16 <outsid3r> foldl*
07:01:36 <Saizan> i guess you could apply equational reasoning to derive a foldl version, but answering my questions should be faster :)
07:01:40 <Jafet> Slow thinker, huh
07:02:03 <outsid3r> jafet?
07:02:38 <hpc> Jafet: that somehow reminds me of battlechess, and how slow the AI can sometimes be
07:03:01 <Saizan> i'd avoid such comments
07:03:17 <outsid3r> i just started this about 3 days ago
07:04:13 <hpc> outsid3r: wow, folds on day 3! it took me forever to learn folds
07:05:45 <tlk> Hello, I'm a haskell first timer - running cabal on MacOSX seems to give a lot of dependency errors
07:05:48 <tlk> such as "cabal: cannot configure unix-2.4.2.0. It requires base >=4.2 && <4.4
07:05:50 <tlk> "
07:06:12 <tlk> I guess I'm the error here, any clue on what I have done wrong?
07:06:18 <outsid3r> this is my worksheet (idk the real word) number 4
07:06:26 <Jafet> outsider: try to answer Saizan's question.
07:06:47 <hpc> "can you see what f should be if f (2*10+3) 4 = 2*100 + 3*10 + 4 ?"
07:07:13 <monad> hpc: In my class they had lazy evaluation and infinit lists lecture 3. You could just watch some peoples heads expload.
07:07:31 <tlk> I used macports to install haskell-platform on Darwin Kernel Version 10.7.0, and got cabal-install version 0.6.2
07:07:32 <hpc> man, i really wanna take a haskell class now
07:07:45 <hpc> it would be so much fun
07:07:46 <outsid3r> i had sudoku game solver on lecture 3
07:08:05 <monad> hpc: I'm doing hardware verification in haskell atm. :)
07:08:14 <outsid3r> and cesar's chipher
07:08:52 <hpc> "can you see what f should be if f (2*10+3) 4 = 2*100 + 3*10 + 4 ?" <- this question is literally one step from solving the problem, btw
07:09:06 <outsid3r> oh let me check
07:09:25 <outsid3r> the problem is how to map [1,10,100] into foldl or something like that
07:09:34 <jlouis> is mtl still recommended for use, or should I pull in something else?
07:09:50 <Bfig> how does this constructor work? it generates the fibonacci series apparently (tested it): 0 : 1 : zipWith (+) fibs ( tail fibs ). is this correct? it starts generating the first part [0, 1] then in some way it must say 'sum the last number computed with the one before that'. how can you talk about the tail of something infinite? how is it intelligent enough to know you are asking for the tail of the last thing you computed? why d
07:09:51 <Bfig> on't you get a sort of 'stutter' where the series repeats itself all over again?
07:10:27 <Jafet> Bfig: what is tail?
07:10:35 <hpc> outsid3r: too complicated; (2*10+3) = 23, 2*100+3*10 = 230
07:10:54 <hpc> ^ shoul help you see what to do
07:10:55 <outsid3r> so foldl (\x y -> (+) ...)
07:10:57 <outsid3r> it must be a sum for sure
07:10:59 <Bfig> Jafet, all elements but the first
07:11:07 * tlk learns to use hpaste: http://hpaste.org/45067/cabal_on_macosx_1067?pid=45067&lang_45067=bash
07:11:07 <hpc> outsid3r: yep
07:11:42 <Jafet> Bfig: so it shouldn't hard to see that the tail is always available when the zip needs it.
07:12:32 <outsid3r> [1,2,3,4], well using a pattern (x:xs) i would reserve x for the end
07:12:38 <Bfig> the tail of what, is the question
07:12:38 <outsid3r> dec2int (x:xs) = ...
07:12:53 <outsid3r> foldl (...) x xs 
07:12:53 <hpc> outsid3r: don't think about lists right now
07:12:55 <Jafet> Bfig: the tail of fibs, like fibs itself, is lazily generated, obviously
07:13:05 <hpc> think of how you turn 23 and 4 into 234
07:13:28 <outsid3r> well 4 + 3*10 + 2*100
07:13:42 <hpc> outsid3r: so what do you do with 23?
07:13:59 <outsid3r> use a function, 2*100 + 3*10
07:14:13 <outsid3r> (+) 2*100 3*10
07:14:29 <outsid3r> or (+) 3*10 2*100 since its a sum
07:14:35 <Bfig> i'm trying to picture the way the evaluation goes but it's hard... let's see, it starts at [0. 1], you now need fibs and the tail of fibs, so you have [1] and [0,1], zips to [1]. you paste it and now you find that the first [1] is actually a [1,1], and on the fibs properly said it is [0,1,1]
07:14:50 <Bfig> ok now i think i got it
07:14:56 <Bfig> thanks Jafet 
07:14:57 <Jafet> Bfig: don't think about it that way. fibs and tail fibs never actually change.
07:15:22 <Bfig> but it is hard because it makes no sense unless you talk about the values computed on the way
07:15:32 <outsid3r> \x y -> (+) x*10 y*100
07:15:40 <jlouis> Bfig: the point is that it is a value containing computation
07:15:40 <Jafet> fibs is always [0,1,...], and tail fibs is always [1,...]. The definition for fibs just tells you how to fill in the (...).
07:15:43 <outsid3r> something like that
07:15:53 <hpc> outsid3r: very close
07:15:56 <jlouis> (which is not done until it is needed)
07:16:01 <outsid3r> the problem is 10 and 100
07:16:02 <Bfig> it is like a cursor going through the list while it is computed on the fly
07:16:04 <hpc> > (\x y -> (+) x*10 y*100) 23 4
07:16:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:16:04 <lambdabot>    arising from a use of `...
07:16:12 <outsid3r> it depends on the iteration , it could be 10000 or 100000000
07:16:21 <hpc> > (\x y ->  x*10 + y*100) 23 4 :: Int
07:16:22 <lambdabot>   630
07:16:37 <hpc> > (\y x ->  x*10 + y*100) 23 4
07:16:37 <lambdabot>   2340
07:17:01 <hpc> so (\y x ->  x*10 + y*100) is almost what we want
07:17:08 <outsid3r> but if i have [2,3,4,5,6,7,8,9] ?
07:17:19 <Bfig> jlouis, but what i mean is that it's defined in terms of results that are not available from the start of the computation
07:17:20 <outsid3r> it must be 9*1 + 8*10 + 7*100, ...
07:17:24 <hpc> outsid3r: we don't know about the list on the inside
07:17:26 <hpc> :t foldl
07:17:27 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:17:38 <hpc> outsid3r: which is why i said "think about it as 23 and 4"
07:17:46 <hpc> 234 = 23 * 10 + 4, yes?
07:17:50 <outsid3r> yes
07:17:55 <Bfig> ie, you have a kind of 'cursor' in the list that is right about to fall outside the range and then you sum it up
07:18:01 <outsid3r> oh
07:18:02 <outsid3r> damn
07:18:11 <outsid3r> i see
07:18:15 <Bfig> and the compiler can see through all this, which is even crazier
07:18:26 <Boxo> Well, you can evaluate it on paper like any other haskell expression and you will inevitably get the right answer
07:18:35 <Jafet> Bfig: what does "not available" mean? The values are defined right in the expression; they're just not calculated by a computer until they're needed.
07:18:50 <outsid3r> i dont need to do something like 2*10 + 3*100 + ... 
07:18:58 <hpc> outsid3r: :D
07:19:22 <Boxo> Or, better than paper, using notepad so you can paste. It's educational.
07:19:36 <outsid3r> my mind always maps the problem like if i were in another non functional language
07:19:37 <Jafet> I tried http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+fibs+%3D+0+%3A+1+%3A+zipWith+%28%2B%29+fibs+%28tail+fibs%29+in+fibs, but it isn't as lazy as GHC is
07:20:28 <Bfig> Jafet, what i mean is that the next step requires values that were computed in the last computation in such a way that you have to make a reference to values that you can't possibly know of
07:20:32 <hpc> Bfig: how does this work? v
07:20:34 <Boxo> Stepeval! That's awesome, I've wanted a thing like that for so long.
07:20:52 <hpc> > let fibs = 1 : 1 : (fibs !! 0 + fibs !! 1) in fibs
07:20:53 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
07:20:59 <hpc> > let fibs = 1 : 1 : (fibs !! 0 + fibs !! 1):[] in fibs
07:21:00 <lambdabot>   [1,1,2]
07:21:09 <hpc> Bfig: ^
07:21:15 <Bfig> what does !! mean?
07:21:30 <hpc> list !! ix == element in list at index ix
07:21:34 <hpc> list !! 0 = head list
07:21:57 <hpc> basically, we are making a list with two elements 1 and 1
07:22:00 <Bfig> shouldn't it be the tail?
07:22:04 <hpc> then a third element that is the first two added together
07:22:18 <hpc> we know the first two elements are there
07:22:23 <hpc> so we can add them together
07:22:35 <hpc> the fourth element will be the second and third added together
07:22:43 <hpc> we know we have the second, and we just computed the third
07:22:53 <hpc> etc
07:23:26 <Jafet> Bfig: see also http://haskell.org/haskellwiki/Tying_the_knot
07:23:30 <Bfig> wait, i don't understand your code... doesn't that give you a finite list or a list like this: [1,1,2,2,2,2,...] ?
07:23:49 <hpc> Bfig: no; (fibs !! 0 + fibs !! 1) is one number
07:24:33 <hpc> > let list = [1,1] in (fibs !! 0, fibs !! 1, fibs !!0 + fibs !! 1)
07:24:34 <lambdabot>   Not in scope: `fibs'Not in scope: `fibs'Not in scope: `fibs'Not in scope: `...
07:24:34 <Bfig> so you only get [1,1,2]... i don't understand
07:24:47 <outsid3r> hpc, how i do something like that inside foldl ?
07:25:57 <hpc> outsid3r: so say we have foldl (\x y -> {-who cares-}) WhoCares
07:26:12 <outsid3r> yes
07:26:15 <hpc> outsid3r: y is the element we are currently looking at, and x is the result of another fold
07:26:25 <hpc> so x would be 23, and y would be 4, in our above example
07:26:37 <hpc> so if 234 == 23*10 + 4...
07:26:57 <hpc> we have foldl (\x y -> {-answer goes here-}) 0
07:27:05 <hpc> and that's it
07:27:40 <outsid3r> {-answer goes here-} = (+) {-answer still here-} ?
07:28:07 <hpc> outsid3r: try (\x y -> x * 10 + y)
07:28:14 * hpc just totally gave away the answer <.<
07:28:31 <hpc> > (\x y -> x * 10 + y) 23 4
07:28:32 <lambdabot>   234
07:28:38 <hpc> > (\x y -> x * 10 + y) 2 3
07:28:39 <lambdabot>   23
07:28:41 <outsid3r> what the hell
07:28:47 <outsid3r> it works, how ?
07:29:30 <hpc> outsid3r: say our list is [2,3,4]
07:29:31 <Jafet> Bfig: perhaps a simpler example is an expression like powers = 1 : map (\x -> x*2) powers
07:29:49 <outsid3r> it would be 4*10 + 3 on first iteration
07:29:51 <hpc> so we start at the top, with (\x y -> x * 10 + y) 0 2
07:29:51 <Jafet> Try to evaluate powers by hand.
07:30:04 <hpc> outsid3r: then 
07:30:06 <hpc> er
07:30:10 <outsid3r> 43
07:30:21 <hpc> outsid3r: then (\x y -> x * 10 + y) 2 3
07:30:26 <hpc> then (\x y -> x * 10 + y) 23 4
07:30:43 <hpc> > foldl (\x y -> x * 10 + y) 0 [2,3,4]
07:30:44 <lambdabot>   234
07:30:54 <outsid3r> wtf i just got it, we keep multiplying by ten to get a 0 at the end
07:30:56 <outsid3r> and then we sum
07:31:17 <hpc> it becomes
07:31:20 <hpc> yes
07:31:26 <Bfig> Jafet, you start with [1], then map a cursor starting at the start of your list with (*2), so you get [1, 2, 4, 8...]. is that correct?
07:32:01 <hpc> ((((0 * 10) + 2) * 10) + 3) * 10 + 4
07:32:06 <Bfig> i can only imagine this in terms of a cursor going through the data... it's hard to think of this data structure as previously existent because i can't see the recursion elements explicitly
07:32:27 <Bfig> even though i understand what you say when you talk about the list 'always being there'
07:32:54 <outsid3r> this problem was more related with maths than anything else
07:33:07 <jlouis> Bfig: there are two views: How will a compiler implement it .. and .. What are the rules and semantics for it?
07:33:11 <Cale> Bfig: What are you guys discussing?
07:33:27 <jlouis> Cale: fibs in the infinite list version
07:33:43 <jlouis> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
07:33:44 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:33:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:33:49 <Cale> okay
07:33:52 <Bfig> Cale, a recursion construct that allows to reference elements in the list that 'don't exist'
07:33:55 <hpc> outsid3r: like i said before, folds are tough; i think you are pretty close to "getting it", but it's really hard to teach
07:34:02 <Cale> Bfig: But all the elements in the list exist.
07:34:05 <Cale> ;)
07:34:09 <Jafet> Bfig: by evaluation, I mean in this sort of detail: powers = 1 : map (*2) powers = 1 : map (*2) (1: tail powers) = 1 : 2 : map (*2) (tail powers) = 1 : 2 : map (*2) (2 : tail $ tail powers) = 1 : 2 : 4 : map (*2) (tail $ tail powers) etc.
07:34:44 <Cale> Bfig: How familiar are you with 'fix'?
07:34:56 <Jafet> Hm, is there a pedagogical notation for that tail.tail.tail
07:35:08 <outsid3r> hpc: because of the recursive thinking, that is also kinda related with maths but the problem is mainly recursive thinking... 
07:35:09 <hpc> Jafet: drop
07:35:12 <Bfig> Jafet, i see it like this: 1: ... = 1: 1*2 : ... = 1: 2: 2*2 : ....
07:35:23 <Jafet> Durr
07:35:36 <Bfig> but you can only 'see the next step' when you compute the previous step
07:35:42 <Bfig> Cale, fix?
07:35:45 <Cale> Bfig: fibs is a list whose first element is 0, whose second element is 1, and the elements thereafter are given by adding fibs to itself elementwise.
07:35:48 <Jafet> Bfig: sure, but it's nice to be explicit about what's in those (...).
07:35:55 <outsid3r> hpc: very simple things can become hard at first the we use this kind of thinking
07:36:01 <Cale> Bfig: fix f = f (fix f)  or   fix f = x where x = f x
07:36:19 <Bfig> Jafet, it's of course what you said, the tail is just a way of saying 'i already used the first n elements of the list'
07:36:26 <Cale> Bfig: If you're not familiar with such a thing already, it probably won't help for me to write fibs in terms of it...
07:36:46 <Cale> Bfig: But some people learn about recursion in different ways :)
07:37:04 <hpc> @src zipWith
07:37:04 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:37:04 <lambdabot> zipWith _ _      _      = []
07:37:16 <Cale> Bfig: The fundamental way in which we scrutinise data structures in Haskell is pattern matching.
07:37:45 <Bfig> i just imagine the 'zipping', and there are two guys deploying a neverending stream of small metallic squares to keep the thing going
07:37:46 <Cale> Bfig: so let's pattern match against fibs a bunch and see if we can work out what the values matched are
07:38:08 <Jafet> http://en.wikipedia.org/wiki/File:DrawingHands.jpg
07:38:09 <Bfig> that's the crazy, you're zipping on air, but you always get something :p
07:38:21 <Cale> You're not zipping on air...
07:38:21 <Bfig> is that escher's?
07:38:31 <hpc> Bfig: you're zipping on the tower underneath you
07:38:54 <hpc> Bfig: and the top of the tower is built from the previous two pieces
07:38:57 <monad> It's a function that is bootstrapping it self.
07:39:17 <Cale> Suppose we want to know what the 5th element of the list is. Well, it's the 3rd element after the first two, which is to say it's the third element of zipWith (+) fibs (tail fibs)
07:39:43 <outsid3r> zipWith applies a function F to a pair of elements isn't it? like [1,2,3,4] [5,6,7,8], F is applied to 1,5, then 2,6, ... ?
07:40:06 <Bfig> hpc, agreed, my point is that you don't see the recursion explicitly and obviously like if you were referencing a previous element directly, the zipping uses two elements that are 'virtual' in the sense that they are not there until they are, ie, that expression can only make sense as long as you keep adding stuff.
07:40:34 <Cale> which is, by the equation given for fibs, the third element of  zipWith (+) (0 : 1 : (zipWith (+) fibs (tail fibs)) (tail (0 : 1 : zipWith (+) fibs (tail fibs))))
07:40:37 <Bfig> if you say f(x) = f(x-1) o g, you can see the recursion explicitly
07:40:43 <outsid3r> now i must write a recursive definition of zipWith hehe
07:41:00 <Bfig> this kind of weird reference is only available if you are allowed to partially construct the objects
07:41:03 <Cale> zipWith needs to pattern match the second list, so we evaluate the tail:
07:41:10 <Cale> zipWith (+) (0 : 1 : (zipWith (+) fibs (tail fibs)) (1 : zipWith (+) fibs (tail fibs)))
07:41:26 <Cale> and now we can push the zipWith along
07:41:35 <Bfig> Cale, i understood how the thing evaluated, i'm just discussing the aesthetic :D
07:41:39 <Cale> (0 + 1) : zipWith (+) (1 : (zipWith (+) fibs (tail fibs)) (zipWith (+) fibs (tail fibs)))
07:41:44 <outsid3r> zipWith f xs ys = [f x y | (x,y) <- zip xs ys]
07:42:06 <Cale> Well, actually, what I'm giving is a pretty unrealistically inefficient version of how it might be evaluated.
07:42:18 <hpc> > let zipWith f xs ys = [f x y | (x,y) <- zip xs ys] in zipWith (+) [1..3] [2..4]
07:42:19 <lambdabot>   [3,5,7]
07:42:22 <hpc> outsid3r: nice
07:42:33 <Cale> Really, every occurrence of 'fibs' in memory is a pointer to the same location.
07:42:54 <outsid3r> that's not the recursive definition, it's just definition of what zipWith is
07:42:54 <Cale> and each 'tail fibs' etc. ends up pointing to the same place once evaluated
07:43:08 <outsid3r> now i must write a recursive definition
07:44:06 <Bfig> i think i found out what's bothering me: you have to construct an object from itself... not from previously constructed objects but from ITSELF, and somehow you can use this object even if it isn't fully constructed (we're never gonna complete the list obviously)
07:44:50 <Cale> That is the nature of recursion.
07:45:01 <Bfig> the solution to this paradox is that the object has a recursive substructure, and if you can build this object as a function over that recursion you can work with this object naturally
07:45:14 <Bfig> still, weird :)
07:45:22 <Cale> Bfig: Let's take a closer look at this fixed point thing I mentioned.
07:45:29 <Cale> fix f = x where x = f x
07:45:42 <Cale> We can write fibs in terms of fix and a non-recursive function:
07:46:02 <Cale> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
07:46:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:46:07 <Boxo> @src fix
07:46:08 <lambdabot> fix f = let x = f x in x
07:46:13 <Bfig> Cale, how can that be computed?
07:46:29 <Bfig> fix i mean, i understand that it makes sense
07:46:35 <Cale> Bfig: What it does is to find the least-defined fixed point of the given function.
07:46:49 <Bfig> least defined = smallest?
07:47:02 <Cale> Yeah, smallest in a funny definedness ordering
07:47:17 <Cale> Where nontermination or "bottom" is the least defined value of all
07:47:28 <Cale> and then various partially defined values are above that
07:47:46 <Bfig> under a finite range? does that function work for all functions a->b ?
07:47:47 <Cale> We usually write bottom with a symbol like _|_ (ascii art)
07:47:50 <Cale> [] and _|_ : _|_
07:48:00 <Cale> lie above _|_ in the partial ordering
07:48:11 <Boxo> It's funnynd weird how the mathematical definition and the haskell definition of a fixed point look exactly the same, but feel like they stand for different things.
07:48:29 <Cale> and then 0 : _|_, 1 : _|_, ... and _|_ : [] and _|_ : _|_ : _|_ lie above _|_ : _|_
07:48:34 <outsid3r> hpc, 
07:48:37 <outsid3r> myZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:48:37 <outsid3r> myZipWith _ [] [] = []
07:48:37 <outsid3r> myZipWith f (x:xs) (y:ys) = (f x y) : (myZipWith f xs ys)
07:48:56 <Cale> Bfig: It will always find you the least-defined fixed point, for any function a -> a
07:48:58 <Cale> :t fix
07:48:59 <lambdabot> forall a. (a -> a) -> a
07:49:16 <Jafet> outsider: what happens with myZipWith f [x] []?
07:49:23 <Cale> If nontermination is a fixed point of the function, then of course, it gives you that
07:49:27 <Cale> > undefined
07:49:27 <lambdabot>   *Exception: Prelude.undefined
07:49:38 <Cale> > fix cos
07:49:41 <lambdabot>   mueval-core: Time limit exceeded
07:49:43 <outsid3r> Jafet, well error
07:49:46 <Cale> > fix id
07:49:49 <lambdabot>   mueval-core: Time limit exceeded
07:50:01 <Boxo> > fix (const 3) -- but if it's not...
07:50:01 <lambdabot>   3
07:50:05 <Cale> ^^ some examples of functions which send the nonterminating value to itself
07:50:10 <outsid3r> i must define behavior also for that, yes
07:50:24 <Cale> Now what about a function like (1:)
07:50:30 <Cale> which adds 1 to the beginning of any list
07:50:43 <Cale> It does *not* have _|_ as a fixed point, because...
07:50:47 <outsid3r> myZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:50:48 <outsid3r> myZipWith _ [] [] = []
07:50:48 <outsid3r> myZipWith _ _ [] = []
07:50:48 <outsid3r> myZipWith _ [] _ = []
07:50:48 <outsid3r> myZipWith f (x:xs) (y:ys) = (f x y) : (myZipWith f xs ys)
07:50:49 <Cale> > head (1 : undefined)
07:50:50 <lambdabot>   1
07:51:04 <Cale> 1 : _|_ is clearly not the same thing as _|_
07:51:07 <hpc> outsid3r: why not reverse those first two patterns, in your first one?
07:51:12 <hpc> myZipWith f (x:xs) (y:ys) = (f x y) : (myZipWith f xs ys)
07:51:19 <hpc> myZipWith _ _ _ = []
07:51:25 <cheater-> what's _|_ : _|_?
07:51:28 <cheater-> what is the colon?
07:51:33 <Cale> cheater-: list constructor
07:51:37 <hpc> cheater-: (:) :P
07:51:38 <cheater-> oh ok
07:51:43 <cheater-> thanks
07:51:46 <Zao> > 0 : 1 : [2..5]
07:51:47 <lambdabot>   [0,1,2,3,4,5]
07:51:54 <outsid3r> hpc, if i put _ _ _ = [] then it would be always [] for any xs and ys right ?
07:52:02 <Cale> > fix (1:)
07:52:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:52:12 <Zao> outsid3r: Depends on where you put it.
07:52:19 <Bfig> i don't understand, that function isn't even a->a
07:52:26 <Cale> Which function?
07:52:28 <Cale> (1:)?
07:52:29 <Bfig> 1:
07:52:31 <Bfig> yes
07:52:34 <outsid3r> i defined _ [] and [] _ for both cases
07:52:35 <Cale> It's [Integer] -> [Integer]
07:52:41 <Zao> @type (1:)
07:52:41 <lambdabot> forall t. (Num t) => [t] -> [t]
07:52:45 <Cale> which is a -> a for a = [Integer]
07:52:59 <cheater-> does every haskell function have a fixed point?
07:53:02 <Bfig> ok, you're right
07:53:04 <Cale> cheater-: yes
07:53:13 <Zao> Cale: Aren't there several kinds of fixed point?
07:53:14 <Cale> (and fix finds it)
07:53:17 <cheater-> what is fix for LiftM?
07:53:19 <Zao> "least" and whatnot?
07:53:21 <Bfig> what fixed point does f x = x+1 have?
07:53:33 <Cale> Well, fix finds a special fixed point, the least-defined one.
07:53:36 <Jafet> @pl let fibs = 0 : scanl (+) 1 fibs in fibs
07:53:36 <lambdabot> fix ((0 :) . scanl (+) 1)
07:53:39 <Bfig> undefined + 1 = undefined?
07:53:44 <cheater-> Bfig: inifnity? :)
07:53:46 <Cale> Bfig: yep
07:53:47 <cheater-> dunno
07:53:57 <cheater-> > fix LiftM
07:53:58 <lambdabot>   Not in scope: data constructor `LiftM'
07:53:59 <Jafet> Bfig: that depends on which type you use for x.
07:54:02 <Cale> Bfig: or with some sorts of numbers, you'll get a representation of infinity :)
07:54:15 <Cale> But with Integer, undefined is the least fixed point
07:54:29 <cheater-> > fix (+1)
07:54:33 <lambdabot>   mueval-core: Time limit exceeded
07:54:36 <cheater-> :O
07:54:44 <Cale> 1 + undefined being no more defined than undefined itself, using the definition of + for Integer values
07:54:49 <Jafet> Bfig: Integer is a strict type, in the sense that it only has normal form (totally defined) values and bottom.
07:55:42 <mercury^> :k mu
07:55:42 <lambdabot> Not in scope: type variable `mu'
07:55:55 <mercury^> What's the name of that thing again?
07:56:01 <Bfig> Jafet, i'm still trying to parse your last sentence
07:56:04 <Jafet> :k Mu
07:56:04 <mercury^> The type level fix.
07:56:04 <lambdabot> (* -> *) -> *
07:56:04 <Cale> > map (fix (\fac n -> if n == 0 then 1 else n * fac (n-1))) [1..10]
07:56:05 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
07:56:07 <mercury^> Ah.
07:56:31 <Jafet> :k Identity -- fun with Mu
07:56:31 <lambdabot> * -> *
07:56:32 <Cale> ^^ fix also can be used to find fixed points which have functional types
07:56:55 <Cale> Let's see what happens if we apply the function  (\fac n -> if n == 0 then 1 else n * fac (n-1))  to undefined
07:57:02 <Cale> (\fac n -> if n == 0 then 1 else n * fac (n-1)) undefined
07:57:18 <Cale> -> (\n -> if n == 0 then 1 else n * undefined (n-1))
07:57:44 <Cale> this is not a totally undefined function because it gives a defined value when you apply it to 0
07:58:07 <ddarius> @let d xs ys = d' [(xs,ys)] [] where d' [(xs,ys)] xys = (head xs, head ys):d' (reverse $ (xs, tail ys):(tail xs, ys):xys)) []; d' ((xs, ys):xsyss) xys = (head xs, head ys):d' xsyss ((tail xs, ys):xys)
07:58:07 <lambdabot>   Parse error: )
07:58:11 <tux_mark_5> hello
07:58:41 <tux_mark_5> is there a way to access haskell's lists via ffi directly?
07:58:44 <ddarius> @let dd xs ys = d' [(xs,ys)] [] where d' [(xs,ys)] xys = (head xs, head ys):d' (reverse $ (xs, tail ys):(tail xs, ys):xys) []; d' ((xs, ys):xsyss) xys = (head xs, head ys):d' xsyss ((tail xs, ys):xys)
07:58:45 <lambdabot>  Defined.
07:58:56 <ddarius> > dd [0..] [0..]
07:58:57 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0),(2,1),(1,2),(0,3),(4,0),(3,1),(2...
07:59:10 <Cale> and if you apply this (\fac n -> if n == 0 then 1 else n * fac (n-1)) function over and over you get a slightly more defined function out each time, and this increasingly defined sequence of partial functions converges to a total function which is the fixed point
07:59:19 <mercury^> Why is there no diagonal list type?
07:59:27 <mercury^> (or is there?)
07:59:34 <Cale> mercury^: Diagonal list type?
07:59:43 <Cale> Is there a vertical list type? ;)
08:00:11 <mercury^> Some list where join visits every element.
08:00:40 <Cale> mercury^: Are you thinking something like list, but with the Monad instance of Nat -> a ?
08:01:01 <mercury^> I do not know what that monad looks like.
08:01:04 <mercury^> But probably yes.
08:01:25 <Jafet> > let ddd xs ys = [(xs !! x-y, ys !! y) | x <- [0..], y <- [0..x]] in ddd [0..] [0..]
08:01:26 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0),(2,1),(1,2),(0,3),(4,0),(3,1),(2...
08:01:31 <Cale> Oh! You don't know about the (->) e monad?
08:01:38 <Cale> It's the same as the reader monad
08:01:47 <mercury^> Ah, of course I know about that one.
08:02:05 <mercury^> Hmm, no, I do not mean that.
08:02:18 <mercury^> diagonal was a bad word I guess
08:02:29 <Boxo> so that join [[1,2,3], [10,20,30], [100,200,300]] = [1,20,300]?
08:02:30 <Cale> oh!
08:02:33 <Cale> I see what you mean
08:02:57 <Cale> Boxo: Yeah, that would be the (->) Nat monad
08:03:02 <Cale> (in disguise)
08:03:05 <Boxo> yeah
08:03:07 <Cale> (sorta)
08:03:30 <Cale> I mean, to the extent that it works as a monad at all -- you need the lists to be infinite for associativity to work.
08:03:54 <Cale> But I think he means that join should traverse the antidiagonals somehow...
08:04:17 <Cale> I don't think that associativity will work out, but you could definitely try it.
08:04:21 <mercury^> The monad instance I have in mind could be a drop in replacement for usual lists. It does not behave just as one would expect maybe for finite lists and it might be a bit slower.
08:04:40 <mercury^> But apart from that it does everything in more or less the same way.
08:05:09 <Jafet> http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html
08:05:44 <mercury^> Alright.
08:06:31 <mercury^> runOmega should be called `every' though. :)
08:14:44 <mercury^> Why can the Contravariant instance of (-> b) not be defined just like that, but instead has to use another type Op?
08:15:05 * hackagebot collada-output 0.3 - Generate animated 3d objects in COLLADA  http://hackage.haskell.org/package/collada-output-0.3 (TillmannVogt)
08:15:19 <Saizan> because (-> b) is not valid haskell
08:15:21 <hpc> mercury^: you can't do sections of types
08:15:56 <mercury^> Ok. Why not?
08:16:02 <Saizan> and the reason for that is that it'd make instance resolution (and maybe inference?) harder, afaiu
08:16:08 <hpc> mercury^: because because
08:16:15 <hpc> also that
08:16:34 <Saizan> though typeclasses are known to be fairly restricted, so there could be room for extensions
08:16:46 <hpc> type-level trickery seems to have a nasty habit of making compilation potentially non-terminating
08:17:05 * hackagebot SVGPath 1.0.2 - Parsing the path command from SVG  http://hackage.haskell.org/package/SVGPath-1.0.2 (TillmannVogt)
08:25:48 <tux_mark_5> is there some documentation anywhere about what internal format is used for list storage?
08:26:01 <hpc> tux_mark_5: yes
08:26:12 <hpc> "data [a] = a:[a] | []" :P
08:26:31 <hpc> er, "data [a] = [] | a:[a]"
08:26:37 <tux_mark_5> i mean on the C side of things
08:26:58 <tux_mark_5> because i'd like to "peek" to ghc list data from C via ffi
08:27:03 <Jafet> What C side of things?
08:27:08 <tux_mark_5> RTS
08:27:12 <hpc> oh, you want to look for something on how haskell values are stored, in the general case, then
08:27:21 <tux_mark_5> yup
08:27:42 <tux_mark_5> i know that haskell uses closures for most of the things, but lists seem to be different beasts
08:28:08 <Jafet> I would designate a proper cross-language interface rather than resorting to unportable hacks.
08:28:12 <tux_mark_5> because after unsafeCoerce'ing [1::Int, 2, 3] C function receives some weird value which is not even pointer
08:28:30 <hpc> what Jafet said
08:28:34 <Jafet> Lists, like most other data structures, can be made of thunks.
08:28:42 <Jafet> (And usually are)
08:29:05 <tux_mark_5> but how to calculate the position of thunk in memory after unsafeCoercing the value?
08:29:29 * hpc would venture to guess that the only lists most people will ever throw around in normal form are strings
08:29:46 <tux_mark_5> not me ;)
08:29:52 <tux_mark_5> here's what i'm trying to do:
08:30:03 <tux_mark_5> haskell currently lacks a form of OOP
08:30:06 <Jafet> That requires knowledge of GHC internals. I don't think those internals persist across versions.
08:30:16 <hpc> for one, coercing is not even remotely predictable
08:30:20 <Jafet> Or at least, that any of the developers intend then to.
08:30:23 <monochrom> you should begin with http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008 and http://www.haskell.org/onlinereport/haskell2010/haskellch24.html#x32-26200024
08:30:36 <tux_mark_5> there have been some efforts made on the subjects like HList - but none of then are acceptable
08:30:51 <Jafet> In other words, what you're doing sounds quite stupid.
08:30:54 <tux_mark_5> so i've decided to write small OOP framefork for haskell and to hook it to d-bus
08:31:17 <tux_mark_5> depends on the perspective i guess
08:31:22 <monochrom> or at least http://www.haskell.org/haskellwiki/Foreign_Function_Interface
08:31:32 <tux_mark_5> dbus is designed to be OOP
08:31:42 <hpc> general rule: every use of unsafeCoerce in code should be justified by a week or so of reasearch saying there is no other way
08:31:49 <tux_mark_5> so what you are saying that it's stupid to use dbus from haskell
08:32:07 <hpc> tux_mark_5: no, just that the way you want to go about it is
08:32:22 <hpc> you are relying too much on assumptions that can change at any time
08:32:23 <Jafet> If your perspective is that you want to hack into the internals for a specific build of a specific release of GHC to accomplish FFI, that sounds endlessly stupid. See monochrom's links for what FFI really is about.
08:32:27 <tux_mark_5> basically i wrap a value to Dynamic with doDyn and i pass it to C function with unsafeCoerce
08:32:35 <monochrom> dbus in haskell is already done. for example http://hackage.haskell.org/package/dbus-client
08:32:43 <tux_mark_5> i know that, i've seen it
08:32:56 <tux_mark_5> i just need "more oop" interface to it
08:33:18 <hpc> tux_mark_5: why not wrap around the existing interface?
08:33:18 <monochrom> download ghc source code and start adding oop extensions to it.
08:33:42 <tux_mark_5> that's what i'll do
08:33:51 <Jafet> I don't understand how knowing the internal representation of lists lets you do "OOP".
08:33:59 <tux_mark_5> what i need is signal & slot support in haskell
08:34:10 <tux_mark_5> for a small project i'm working on
08:34:20 <tux_mark_5> to do that i need to have a form of "objects" in haskell
08:34:32 <tux_mark_5> having those it's quite easy to integrate with dbus-client
08:35:03 <tux_mark_5> which would allow to write quite elegant code in haskell which interfaces well with other programs & services running in the system
08:35:15 <hpc> i don't think you need OOP for that
08:35:30 <tux_mark_5> well, OOP is the way to create guis
08:35:31 <monochrom> see http://hoc.sourceforge.net/examples.html for an example of cocoa oop
08:35:46 <tux_mark_5> i'm a bit away; brb
08:35:58 <Jafet> I get the impression you're using words you don't understand.
08:36:41 <monochrom> search for "functional reactive programming" to see a non-oop way to create guis. talk to Cale or anyone from iPwn studio, who actually use it.
08:37:11 <Jafet> Interesting; which library do they use?
08:37:24 <monochrom> something in-house
08:37:35 <Jafet> Naturally
08:37:59 <Saizan> customized yampa, iirc
08:38:33 <monochrom> stop speaking like "mouse is the only way to use guis"
08:38:43 <Cale> Yeah, it's definitely Yampa like... kinda moving away from Yampa now, but still arrowy.
08:39:14 <drhodes> has ipwn managed to get haskell running on the xoom tablet?
08:39:18 <Cale> (We're still using Yampa in some parts of the game, actually, but it'll eventually be replaced by the new library)
08:39:39 <Cale> drhodes: Not that I know of. Currently we just have it running on iDevices.
08:39:50 <drhodes> wow
08:40:17 <jystic> Cale: is this game released yet?
08:40:27 <Cale> There's some work going into making it run on Android
08:40:30 <Cale> no, not yet
08:40:38 <Cale> Still lots of work to do :]
08:40:56 <tux_mark_5> i'm back
08:41:15 <jystic> How are you compiling for iDevices? is that info online anywhere?
08:41:21 <tux_mark_5> Jafet: i'm getting the impression that you have no idea what i'm trying to accomplish
08:41:28 <jystic> (is it painful?)
08:41:46 <Jafet> tux: yeah, I don't
08:42:09 <tux_mark_5> are you aware of obj-c and it's objects ?
08:42:18 <brbr> hello
08:42:32 <Cale> jystic: GHC iPhone... It's not too painful, but takes a bit of work to get set up. Talk to blackh (Stephen Blackheath) if you're interested in it.
08:42:36 <tux_mark_5> baiscally obj-c uses hashtables as a form of dispatch
08:42:55 <tux_mark_5> which means that these hashtables can be constructed on runtime
08:43:11 <jystic> Cale: Cool, I'm definitely interested, which version of GHC is it based on?
08:43:18 <tux_mark_5> so it hit me - that i could construct something simillar for haskell
08:43:37 <tux_mark_5> to store all properties and "methods" as Dynamic values somewhere
08:43:41 <Jafet> GHC already does that kind of dispatch with polymorphic functions.
08:43:49 <tux_mark_5> yes it does
08:43:59 <tux_mark_5> but it doesn't do well with inheritance
08:44:06 <Bfig> how can i understand this expression: e = (foldr (++) . map (:)) [1,2,3] [[filter even]] ? is this reasoning correct?: associating from the start, i foldr with concatenation as operation, (.) as element for [], and list map(:). this doesn't make sense at all
08:44:10 <Cale> jystic: Presently I think we're using 6.12.3. (I've been building things in Linux lately though)
08:44:17 <tux_mark_5> also it doesn't do well with "extensible records"
08:44:43 <Saizan> Bfig: (.) is not given as argument to foldr there
08:44:46 <Cale> Bfig: the . isn't in parens, so it is not a parameter to the foldr
08:44:48 <Jafet> tux: okay. So why do you need to know the internal representation?
08:44:48 <monochrom> "<tux_mark_5> are you aware of obj-c and it's objects ?"  are you aware of "<monochrom> see http://hoc.sourceforge.net/examples.html for an example of cocoa oop" ?
08:45:13 <Bfig> i don't understand, isn't it the second parameter the 'identity' of the operation?
08:45:18 <monochrom> I have a feeling that you are the unaware and unobserving one.
08:45:26 <Bfig> (could be anything meaningful to the operation)
08:45:38 <Cale> Bfig: well, let's just carry out the evaluation and see what happens.
08:45:39 <tux_mark_5> monochrom: i don't need a GUI lib
08:45:51 <jystic> Cale: Nice, I wanted to give iPhone dev a go, but I started learning Obj-C and found it too painful / unfun to be worth my spare time, so I went back to hacking on Haskell projects :)
08:45:52 <Cale> Bfig: (f . g) x = f (g x)
08:46:00 <Cale> (foldr (++) . map (:)) [1,2,3] [[filter even]]
08:46:00 <tux_mark_5> monochrom: and i don't need bindings to obj-c
08:46:19 <olsner> Cale: is that a ghc cross-compiler or do you have to run it on arm somehow?
08:46:19 <Cale> -> foldr (++) (map (:) [1,2,3]) [[filter even]]
08:46:28 <Cale> olsner: cross compiler
08:46:32 <tux_mark_5> what i need is some oop base platform which could be used to easily create bindings for all-things-oop
08:46:54 <olsner> cool, I didn't know ghc could do cross compiling
08:46:55 <Cale> olsner: I don't think there's any hope of getting GHC to run on my iPod touch :)
08:47:09 <monochrom> the way I see it, HOC has a oop base platform.
08:47:17 <brbr> can someone please help me understand how to prove type soundness with an abstract machine?
08:47:25 <brbr> more specifically..
08:47:27 <brbr> In the STLC, part of soundness is proved by using small or big step operational semantics that pretty much look like e --> e'.... but how does this work when your operational semantics are in the form of an abstract machine that uses closures?  How can you say "this expression is equivalent to this machine state, therefore you can take a step"?
08:48:09 <Cale> -> foldr (++) [(1:),(2:),(3:)] [[filter even]]
08:48:17 <Bfig> Cale, how do you read the functions 'consuming' operators when they have a tuple as input?
08:48:28 <monochrom> but I cannot forget who brought up gui in the first place.
08:48:28 <tux_mark_5> well thanks for nothing i guess then
08:48:33 <Cale> Bfig: example of what you mean?
08:48:50 <Bfig> wait, a tuple is not the correct term... just several inputs
08:49:00 <Cale> tux_mark_5: what are you asking about? I sorta missed that thread of the conversation...
08:49:18 <Bfig> ie, f :: a->b->c->..->x, and then you do f g h i ...
08:49:21 <tux_mark_5> about direct access from c to haskell's lists
08:49:29 <Cale> tux_mark_5: ?
08:49:34 <Cale> tux_mark_5: Umm...
08:49:43 <ddarius> > let pell = (1,0):map (\(x,y) -> (3*x+2*y, 2*x+3*y)) pell in map (\(x,y) -> x^2 - 2*y^2) pell
08:49:44 <lambdabot>   [1,1,-119,-3719,-96719,-2436719,-61011719,-1525761719,-38146386719,-9536713...
08:49:45 <Bfig> g h i stand for arbitrary elements, possibly functions of one or more parameters
08:49:46 <Cale> tux_mark_5: Might be sorta doable, but it's awkward.
08:50:00 <tux_mark_5> how? ;)
08:50:09 <Cale> tux_mark_5: Better to marshal through some other representation, since C doesn't handle infinite datastructures so naturally.
08:50:18 <ddarius> > let pell = (1,0):map (\(x,y) -> (3*x+2*y, 3*x+2*y)) pell in map (\(x,y) -> x^2 - 2*y^2) pell
08:50:19 <lambdabot>   [1,-9,-225,-5625,-140625,-3515625,-87890625,-2197265625,-54931640625,-13732...
08:50:25 <jystic> tux_mark_5: What it is about direct access to haskell's lists that will let you make do OOP? (I'm intrigued)
08:50:33 <Cale> tux_mark_5: You'd end up relying on GHC's internal representations.
08:50:34 <jystic> let you do OOP*
08:50:37 <tux_mark_5> well i don't need to access *all* hasell's structures - just TypeRep field of Dynamic
08:50:47 <tux_mark_5> Cale: yes, that's what i want ;)
08:51:07 <hpc> you want to tie yourself to one version of GHC?
08:51:09 <Cale> I also don't understand why you'd want to do this.
08:51:21 <tux_mark_5> maybe to few ;)
08:51:29 <ddarius> > let pell = (1,0):map (\(x,y) -> (3*x+3*y, 2*x+2*y)) pell in map (\(x,y) -> x^2 - 2*y^2) pell
08:51:30 <lambdabot>   [1,1,25,625,15625,390625,9765625,244140625,6103515625,152587890625,38146972...
08:51:32 <Saizan> tux_mark_5: you'd better go read GHC's source and maybe commentary, since it's not part of the documented API
08:51:32 <monochrom> he/she wants OOP
08:51:49 <Cale> A better way would be to offer some functions for deconstructing the list with more C-like types.
08:52:07 <tux_mark_5> i've poked around RTS for quite a while, but i can't seem to figure how pointers of lists are marshalled
08:52:42 <Saizan> i don't think list are treated specially
08:52:46 <hpc> no, he is saying you do it; make a function [whatever you want] -> AnEasierTypeToUse
08:53:24 <hpc> (not Dynamic, because it still has the list inside)
08:53:24 <tux_mark_5> i just want to compare a few Dynamic values from C/RTS 
08:53:37 <augustss> tux_mark_5: any messing with rts internals is error prone and non-portable
08:53:52 <Fuco> is -> a function or just syntax? I think I saw somewhere it was an instance of some class/
08:53:53 <tux_mark_5> augustss: it's not a problem for me right now ;)
08:54:01 <Fuco> (in lambda definition)
08:54:05 <Cale> tux_mark_5: Why not just export a Haskell function for doing that via FFI then?
08:54:25 <augustss> tux_mark_5: it's always a problem, even if you ignore it right now
08:54:26 <tux_mark_5> hmm
08:54:31 <hpc> Fuco: in (\args -> body), "->" is syntax that separates the arguments and the lambda body
08:54:50 <tux_mark_5> well, I could export haskell's function and to everything from there
08:54:52 <Jafet> Fuco: ((->) a) also represents functions of type a -> something
08:54:57 <hpc> Fuco: in (f :: Foo -> Bar), "->" is the type constructor for functions
08:54:59 <Cale> Fuco: (->) is a type-level function, and at the value level is part of the syntax of lambda expressions, as well as part of the syntax of case expressions
08:55:10 <Fuco> ah yea, that's probably it
08:55:16 <Fuco> thanks
08:55:23 <tux_mark_5> but i'm still curious of how things work ;D
08:55:30 <tux_mark_5> things as in [things] ;D
08:55:43 <augustss> tux_mark_5: the internal representation of data type is quite complex (with things like pointer tagging), and it sometimes changes between ghc releases
08:56:10 <tux_mark_5> yeah, i'm aware about pointer tagging, data types, bitmap layouts and so on
08:56:17 <jystic> tux_mark_5: shouldn't that be [thing] ? :)
08:56:25 <Cale> tux_mark_5: If you want a good foundation for how this stuff is implemented, start here: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3729&rep=rep1&type=pdf
08:56:38 <hpc> tux_mark_5: if you already know how other data types work... you know how lists work :P
08:56:47 <hpc> lists are just another type
08:56:48 <Cale> But that's actually a bit out of date. Now there's pointer tagging and spines :P
08:56:56 <tux_mark_5> but unsafeCoercing a list gives me a value which is not a pointer
08:57:06 <Cale> So "spineless" and "tagless" are kinda inappropriate
08:57:14 <Cale> But it's pretty close
08:57:15 <tux_mark_5> which means that unsafeCoercing somehow "damages" the value
08:57:23 <hpc> tux_mark_5: that is totally meaningless
08:57:28 <augustss> tux_mark_5: unsafeCoerce gives you any type you want
08:57:29 <tux_mark_5> or that it's mangled/marshalled in a way that i don't understand
08:57:39 <monochrom> "spineful tagful G machine" is still "STG machine"
08:57:39 <hpc> tux_mark_5: unsafeCoerce destroys all sorts of information, no matter the type
08:57:55 <tux_mark_5> i unsafeCoerce it only for one reason - that i could access it's data
08:58:18 <Saizan> tux_mark_5: if you unsafeCoerce to e.g. Ptr, then you're going to use as a pointer the first word of the represetation of the list
08:58:26 <Saizan> tux_mark_5: not the pointer to the list itself.
08:58:29 <augustss> tux_mark_5: using unsafeCoerce is not way
08:58:47 <tux_mark_5> hmm
08:58:54 <tux_mark_5> that's not good
08:59:11 <tux_mark_5> is there a way to pass a "undamaged" pointer to C then?
08:59:18 <augustss> tux_mark_5: there's some weird function (the name escapes me) that e.g. vacuum uses to unpack a node
08:59:18 <Saizan> you'd unsafeCoerce x :: Ptr Foo, is not the same as &x in C
08:59:22 <hpc> tux_mark_5: you have to use the FFI
08:59:38 <hpc> which is what we have been saying
08:59:39 <Saizan> s/you'd//
08:59:54 <tux_mark_5> well if anybody has any suggestions how to do the &x thing in haskell that would be nice
08:59:57 <augustss> tux_mark_5: something like unpackClosure
09:00:01 <tux_mark_5> oh, yes
09:00:03 <tux_mark_5> that's the one
09:00:12 <tux_mark_5> augustss: thanks ;)
09:00:20 <monochrom> godawful
09:00:36 <augustss> tux_mark_5: unpackClosure#
09:02:31 <Cale> tux_mark_5: But anything like this is the wrong approach to take. The FFI is pretty nice and you should use it.
09:03:03 <tux_mark_5> well, i just need to play with Dynamic values - and the only reason for that is to have some average performance
09:03:19 <Cale> tux_mark_5: Why is this?
09:03:23 <hpc> you don't need to use Dynamic!
09:03:49 <tux_mark_5> so how can i implement object-property system without dynamic?
09:04:17 <tux_mark_5> because "objects" can contain anything - and Dynamic can be used to store anything
09:04:18 <Bfig> Cale, ok, i saw what you meant about the composition, you are composing map and then applying foldr (++). so in total you'd start with a list [1, 2, 3], map ":" creating a list of partial functions [1:, 2:, 3:] then you would concat those using at the end [[filter even]] ?
09:04:20 <monochrom> HOC shows how. it is not just a brute-force cocoa binding that you imply.
09:04:44 <tux_mark_5> hmm
09:04:53 <monochrom> part of it contains how you would do any obj-c classes at all
09:05:15 <Cale> Bfig: that code is sorta ridiculous, just so we're on the same page :P
09:05:24 <tux_mark_5> having my own oop framework would allow me to bind haskell to other languages too
09:05:30 <tux_mark_5> not only some d-bus library
09:05:40 <Cale> Bfig: one sec, I'll write out a complete evaluation
09:05:45 <tux_mark_5> for example, ruby
09:06:39 <tux_mark_5> also one of my goals is to have inter-process signals, which could be used with nice syntax (and without resorting to TH to generate some boilerplate code)
09:07:27 <tux_mark_5> anyway, thanks everybody for your help ;)
09:10:32 <Cale> Bfig: http://hpaste.org/45068/evaluation
09:10:36 <Cale> Oh, he dropped...
09:12:05 <Cale> tux_mark_5: You could of course represent objects in terms of the operations which apply to them, more explicitly - message passing in particular
09:13:11 <tux_mark_5> Cale: maybe I could, but can't say i imagine how that kind of a system would work
09:13:27 <Cale> tux_mark_5: So you'd have some representation of the messages which could be passed to some object, and the object itself, and some operation which constructs the IO action for sending a message to an object.
09:14:07 <tux_mark_5> i would still need to store the state of an object somewhere
09:14:18 <Cale> Well, these are IO actions.
09:14:26 <Cale> Plenty of state everywhere in IO
09:14:48 <tux_mark_5> IORef aren't exactly pretty
09:14:55 <tux_mark_5> *IORefs
09:14:58 <Cale> If you'd prefer a pure OO model, you'd of course make it  Message -> Object -> Object
09:15:22 <hpc> tux_mark_5: IORefs are a right sight prettier than Dynamic and unsafeCoerce ;)
09:15:36 <tux_mark_5> only on the outside ;D
09:16:21 <Cale> Whenever there's only one operation you can perform on something, you can represent it as that operation itself too.
09:16:52 <Cale> So if the only thing you can do with an object is to send it a message, then you can represent any object as the operation which sends the object a message.
09:17:12 <Cale> and your object representation becomes  Message -> IO ()
09:17:41 <Cale> Oh, but what if the operation of sending a message will always pass back another object?
09:17:42 <tux_mark_5> i could do that, but as far as i understand i would lose partial application
09:17:59 <Cale> newtype Object = O (Message -> IO Object)
09:18:11 <tux_mark_5> my current idea is to store Key - Value pairs for each object class somewhere in RTS/C
09:18:24 <tux_mark_5> where Key is just some name
09:18:31 <tux_mark_5> and Value is a Dynamic value
09:18:34 <Cale> tux_mark_5: Are you just introducing C for no good reason here?
09:18:46 <Cale> tux_mark_5: Or is there C code that you want to interface with?
09:19:01 <tux_mark_5> there is some code to which i want to interface
09:19:02 <Cale> If there's no C code, I recommend avoiding C.
09:19:21 <tux_mark_5> C++ to be more precise
09:19:37 <Cale> and even if there is, I recommend cutting the interface as close as possible to the C side of things, so that you have as much stuff on the Haskell side as possible.
09:19:50 <Cale> With C++, you'll need a C++ <-> C interface of course
09:19:56 <tux_mark_5> yup
09:19:56 <Cale> That shouldn't surprise anyone.
09:20:39 <tux_mark_5> right now my vision of OOP system comes down to hashtables which store Dynamic values
09:20:50 <Jafet> Still doesn't want to use the FFI, eh.
09:21:02 <Jafet> You're pretty weird.
09:21:14 <tux_mark_5> the problem is that haskell doesn't offer anything better 
09:21:17 <tux_mark_5> i mean to store values
09:21:24 <tux_mark_5> just look at HLists package
09:21:25 <Cale> What do you mean?
09:21:36 <Cale> HList is for *typed* heterogeneous lists.
09:21:38 <tux_mark_5> which is supposed to implement full OOP using type families & stuff
09:21:49 <Cale> Yeah, don't bother with HList, it's kinda unrealistic.
09:21:50 <tux_mark_5> and the code for it is beyond horrible and unusable
09:22:12 <Cale> also, you get pretty good models of OOP *much* more simply via traditional functional programming.
09:22:31 <tux_mark_5> yeah, i know, type classes can do that
09:22:36 <Cale> But let's look at the actual interface we're contending with.
09:22:40 <Cale> No, not even typeclasses
09:22:44 <Cale> Just functions and datastructures
09:22:55 <Cale> (and maybe datastructures containing functions)
09:23:03 <tux_mark_5> okay then
09:23:05 * geheimdienst thinks you can get pretty far with simple functions
09:23:08 <Jafet> See SICP chapter 3.
09:23:27 <tux_mark_5> let's make it simple - i need to implement object class iheritance somehow
09:23:49 <tux_mark_5> i also need the ability to add extra fields/properties for each derived class
09:24:00 <tux_mark_5> if you know how to do that, please share ;)
09:24:07 <Cale> tux_mark_5: How important is it that this is statically checked?
09:24:08 <hpc> tux_mark_5: so you want java?
09:24:08 * geheimdienst likes prototype inheritance in the style of javascript
09:24:19 <tux_mark_5> i don't need it to be statically cheked
09:24:24 <Cale> Okay, then it's trivial.
09:24:26 <tux_mark_5> in fact, i need quite the opposite
09:24:32 <Cale> ;)
09:24:52 <tux_mark_5> because most of scriptable languages are duck-typed
09:25:05 <hpc> "most" == "just python"?
09:25:12 <tux_mark_5> ruby ;)
09:25:23 <Jafet> Visual Basic
09:25:25 <tux_mark_5> i don't like python, it's repulsive somehow
09:25:42 <Cale> I think of python and ruby as being practically the same language.
09:25:43 <tux_mark_5> i wouldn't even dare to think to touch VB
09:25:56 <tux_mark_5> ruby has much nicer API ;)
09:26:04 <tux_mark_5> and it's much more flexible
09:26:29 <tux_mark_5> so, if implementing inheritance is trivial, then please share how to do that ;)
09:27:24 <Cale> tux_mark_5: Well, it'll just amount to constructing more values of the same object type as values you already have.
09:27:25 <tux_mark_5> another requirement is ability to change properties by name (reflection)
09:27:37 <Cale> You'll have one big object type.
09:27:46 <tux_mark_5> what if i want to store *anything* in these properties?
09:28:14 <tux_mark_5> because data Obj = OInt Int | OWord Word | ... isn't going just to cut it
09:28:19 <Cale> You don't want to store *anything* in the properties, you only want to store values which can cross your C boundary.
09:28:22 <tux_mark_5> that's why i chose Dynamic in the first place
09:28:49 <hpc> ideally, the only thing you store is a strict bytestring
09:29:07 <tux_mark_5> i wan't a framework that can be used within haskell
09:29:20 <tux_mark_5> and that would be just a wrapper between haskell and C/Ruby/whatever
09:29:27 <tux_mark_5> *wouldn't
09:29:36 <Cale> Please show me the C interface to your objects
09:29:44 <Cale> Because I'm not really sure what operations they have
09:30:02 <tux_mark_5> another reason i need objects is signal & slot support
09:30:12 <geheimdienst> why do you need to interact with ruby from haskell? do you have large amounts of legacy ruby code or something like that?
09:30:21 <tux_mark_5> it's just an example
09:30:24 <hpc> why do you want haskell?
09:30:43 <hpc> you are striping it of its static type system and playing with pure values in C code
09:30:51 <hpc> that pretty much removes every advantage haskell could offer
09:30:52 <tux_mark_5> basically i want a really flexible OOP environment which wouldn't feel as cut-up version of "real" oop frameworks like GObject
09:31:09 <tux_mark_5> imagine this situation:
09:31:13 <hpc> haskell is perhaps the worst language for what you want
09:31:15 <Cale> If you'll show me the C API for interacting with your objects, I can pretty straightforwardly translate it into a Haskell API for working with them.
09:31:28 <tux_mark_5> i have to services/applications which communicate via dbus
09:31:33 <tux_mark_5> *two
09:31:40 <geheimdienst> ok
09:31:40 <Cale> and then we can go from there in making it more usable on the Haskell side of things
09:31:53 <tux_mark_5> one of these services has two "OS" threads
09:32:07 <tux_mark_5> so in the end I have 3 threads in 2 processes
09:32:27 <Cale> (have you looked at dbus-client?)
09:32:31 <tux_mark_5> each of these threads can generate an event, which needs to be received by other 2 processes
09:32:45 <tux_mark_5> yes, that's what i've been using for quite a while
09:32:54 <Cale> Okay, what's wrong with it? :)
09:33:10 <tux_mark_5> i don't like how everything has to be wrapped to Variants
09:33:24 <Cale> and you'd prefer wrapping everything into Dynamics?
09:33:29 <Cale> (same thing?)
09:33:40 <tux_mark_5> i do this automatically - it's easier
09:33:50 <Cale> The advantage of Variant here is that you have this Variable class
09:33:51 <hpc> so why not automatically wrap things into Variants?
09:33:54 <tux_mark_5> Variant unboxing isn't very nice thing either
09:34:13 <hpc> Dynamic isn't magically more automatic than Variant
09:34:14 <Cale> which you can extend with marshalling instances for your own datatypes that produce sensible values on the other side
09:34:36 <Cale> It's not bad from the looks of things...
09:34:47 <Cale> You'd use the Maybe monad a bunch.
09:34:48 <tux_mark_5> maybe i have a wrong example
09:35:09 <tux_mark_5> ok, let's try to look from a different side of things
09:35:24 <tux_mark_5> i'm sure you are all aware of xmonad ;D
09:35:45 <Cale> Maybe show us a piece of code using dbus-client that you'd like to tidy up?
09:35:47 <tux_mark_5> anyway, i've have to X servers running with xmonad's on the same pc
09:35:57 <tux_mark_5> s/to/two/
09:36:24 <tux_mark_5> i've modified xmonad's log hook to emit all events via dbus
09:36:44 <tux_mark_5> now i'm writing an app, which would collect all events from both xmonads
09:36:50 <tux_mark_5> and possibly from other services
09:36:50 <Cale> okay
09:37:08 <tux_mark_5> and provide some panel (or colleciton of panels), which could visually provide the information
09:37:18 <tux_mark_5> each panel contains components
09:37:25 <allbery_b> dbus supports types
09:37:28 <tux_mark_5> each component has several slots
09:37:32 <Ptival> isn't there a function that takes two lists [a,b,c] [1,2,3] and returns [a,1,b,2,c,3]?
09:37:41 <tux_mark_5> for example "setValue, setColor, setBackground"
09:37:54 <hpc> :t zipWith
09:37:55 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:37:56 <Ptival> (assuming a b c are ints)
09:38:02 <Ptival> oh right
09:38:23 <hpc> :t zip
09:38:24 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
09:38:26 <tux_mark_5> and i have otehr objects - like XMonad - which are like "event-sources", which collect the received informaton from dbus
09:38:37 <Cale> > concat (transpose [[1,2,3],[4,5,6]])
09:38:38 <lambdabot>   [1,4,2,5,3,6]
09:38:44 <tux_mark_5> so it all comes down to this 
09:38:59 <Ptival> I thought this would be in Data.List already :)
09:39:08 <Ptival> like intersperse or intercalate...
09:39:15 <tux_mark_5> i want to "connect" xmonad's event "workspaceChanged" to one of components "setValue" with one line of code
09:39:18 <Cale> Ptival: yeah, I sometimes call it /\/
09:39:19 <allbery_b> if it's trivially composed, it's generally not given a name
09:39:45 <hpc> allbery_b: except for all the stuff that is trivially composed :P
09:39:55 <tux_mark_5> and that would be possible only with the object system i described
09:40:06 <hpc> zip = zipWith (,), etc
09:40:06 <localecho> heh
09:40:42 <allbery_b> there's a lot of cruft in Data.List, I will admit
09:42:42 <allbery_b> tux_mark_5: sounds to me like you want Qt
09:42:51 <Cale> tux_mark_5: Why only with that system? You can't invent a function using the stuff in dbus-client for doing it?
09:43:13 <tux_mark_5> allbery_b: yeah, i want qt in haskell
09:43:21 <tux_mark_5> i know there is qtHaskell
09:43:43 <tux_mark_5> but even hello world produces 50M+ binaries 
09:43:46 <Cale> I must admit I stilly don't really have a crystal clear idea of what you're trying to do here...
09:43:56 <Cale> still*
09:44:03 <tux_mark_5> which makes the entire project as usable as a toy for me
09:44:45 <Cale> tux_mark_5: It's because GHC statically links everything.
09:44:51 <allbery_b> that's because ghc is not so much with the shared objects,so the entire binding is linked in as a single lump
09:44:54 <tux_mark_5> i want qt-style inter-process signal-slots , which can be used without writing lots of boilerplate code
09:45:08 <ddarius> > let pell = (1,0):map (\(x,y) -> (3*x+4*y, 2*x+3*y)) pell in map (\(x,y) -> x^2 - 2*y^2) pell
09:45:09 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:45:19 <ddarius> > let pell = (1,0):map (\(x,y) -> (3*x+4*y, 2*x+3*y)) pell in pell
09:45:20 <lambdabot>   [(1,0),(3,2),(17,12),(99,70),(577,408),(3363,2378),(19601,13860),(114243,80...
09:45:21 <tux_mark_5> Cale: i know that - but it doesn't link Qt libraries themselves statically
09:45:22 <allbery_b> that should be implemented on top of dbus-core
09:45:46 <tux_mark_5> Cale: which means that bindings weigh more in size than the Qt library itself 
09:45:59 <Cale> tux_mark_5: Show me some of the code you've written which is boilerplatey, and maybe we can remove the boilerplate in a Haskelly way, rather than by the reinvention of OO.
09:46:28 <allbery_b> tux_mark_5: shared libraries for Haskell libs are still in progress, I think you can build ghc HEAD with them enabled
09:46:35 <tux_mark_5> Cale: it's a mess right now - i'm still in designing the project
09:47:03 <Fuco> is it somehow possible to use "System.IO.Unsafe" to print debug info during execution?
09:47:05 <pacak> I am trying (once again) to play with lastest iteratee on ghc 7.0.2
09:47:08 <tux_mark_5> allbery_b: i've tried building some GTK apps with shared library support - but that isn't pretty
09:47:14 <tux_mark_5> the main application links 50+ haskell libs
09:47:38 <ddarius> > 17 ^ 2
09:47:38 <lambdabot>   289
09:47:39 <tux_mark_5> and when starting such application linux's linker takes almost a second to load all the libs
09:47:43 <pacak> code main = fileDriver printLines "/etc/passwd" works as expected in compiled version of the program, but gives *** Exception: epollControl: permission denied (Operation not permitted) when i am trying to run it in ghci/runhaskell
09:47:46 <pacak> Any ideas?
09:47:52 <allbery_b> I think I would either bind to just the dbus parts of Qt or write a compatible binding on top of the existig dbus bindings
09:47:56 <monadic_kid> Fuco: you can use trace
09:48:04 <tux_mark_5> cpu usage visibly spikes to 100% for short time
09:48:17 <Fuco> that was rather complicated
09:48:24 <Fuco> I tried but I think I didn't get it
09:48:26 <monadic_kid> Fuco: ?
09:48:56 <Fuco> do you know of any tutorial?
09:49:08 <jonkri> hmm... could someone tell me why the module documentation for not generated for http://hackage.haskell.org/package/pontarius-xmpp? Network.XMPP.PontariusXMPP is in Exposed-Modules
09:49:09 <monadic_kid> > Debug.Trace.trace "hello" (10 + 5)
09:49:10 <lambdabot>   Not in scope: `Debug.Trace.trace'
09:49:15 <ddarius> > 24^2
09:49:16 <lambdabot>   576
09:49:20 <monadic_kid> Fuco: trace is so simple
09:49:28 <geheimdienst> fuco, trace is easier than it looks. you import the module and then write «trace "blah blah"» before any expression
09:49:31 <geheimdienst> @hoogle trace
09:49:31 <lambdabot> Debug.Trace trace :: String -> a -> a
09:49:31 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
09:49:31 <lambdabot> module Debug.Trace
09:49:43 <tux_mark_5> personally, i think that the reason why haskell isn't as popular as other mainstream languages is the fact, that most haskell users think that everthing should be done in FP
09:49:49 <geheimdienst> > 42 + 37
09:49:50 <lambdabot>   79
09:49:56 <geheimdienst> > 42 + (trace "lolcats" 37)
09:49:57 <lambdabot>   Not in scope: `trace'
09:50:06 <Cale> My recommendation would be to start by using dbus-client directly, and once you have some Haskell code written, you can work out the fashion in which it's repetitive or overly verbose, and make some definitions to factor things a bit better.
09:50:14 <geheimdienst> this would have worked if lambdabot would have imported Debug.Trace
09:50:22 <tux_mark_5> personally i think that "salvation" lies in usage of OOP + FP - something like scala
09:51:01 <monochrom> salvation lies in eliminating programmers
09:51:13 <tux_mark_5> ;)
09:51:30 <monadic_kid> i'm not a fan of scala, to me it's bloated and not particularly elegant syntax either
09:51:34 <Cale> tux_mark_5: OOP and static typing mix horribly
09:51:37 * geheimdienst thinks oop has some advantages and some disadvantages. often, oop is not worth the effort. certainly it's no "salvation" ... my 2 cents
09:51:44 <tux_mark_5> anyway, i like haskell, i really do, but 2 major "flaws" are huge binaries and lack of extensible records
09:51:52 <Cale> Well, at least, the way most people try to do OOP :P
09:52:07 <Ptival> style question: do you increase the indent level after a let in a do?
09:52:11 <Cale> Subtyping in particular is awful.
09:52:11 <tux_mark_5> i'm not a huge fan of scala either - that's why i don't used it - but it's an example that OOP + FP does indeed work
09:52:13 <hpc> Ptival: no
09:52:21 <tux_mark_5> ocaml is a great example of that too
09:52:26 <hpc> it's not even a style question; it's how do syntax works
09:52:33 <monochrom> depends on what is "after"
09:52:40 <Ptival> hpc: ok. I'll have to fix my vim indent :\
09:52:43 <Cale> Ptival: You can't, unless you also write 'in', and put in another 'do'
09:53:08 * allbery_b is spoiled, has been looking for decent languages to use to program for android of late :)
09:53:19 <monochrom> after. adv.  1. "let x=x+1" the "x=x+1" is after "let".  2. "let x=x+1 in y" the "y" is after "let"
09:53:21 <tux_mark_5> Cale: btw, what do you think about OCaml?
09:53:22 <hpc> allbery_b: you can use C now, from what i hear
09:53:38 <Cale> tux_mark_5: I haven't really touched the object-y parts of it at all.
09:53:39 <geheimdienst> hpc: what part of "decent" is confusing you?
09:53:40 <geheimdienst> ;)
09:53:44 <tux_mark_5> oh
09:53:47 <hpc> lol
09:53:49 <Cale> tux_mark_5: So I can't really say.
09:53:55 <allbery_b> I agree about scala.  poked at erjang but it's developed in fits and starts and doesn't work with current erlang (can't read boot)
09:54:21 <geheimdienst> allbery_b: have you looked into clojure? i wonder if it can be used on android these days
09:54:21 <allbery_b> ==geheimdienst :)
09:54:29 <ddarius> > let pell = (1,0):map (\(x,y) -> (x+2*y, x+y)) pell in map (\(x,y) -> x^2 - 2*y^2) pell
09:54:30 <lambdabot>   [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1...
09:54:45 <allbery_b> aside from the fact that I'm un-fond of lisp... :)
09:55:08 <allbery_b> it should work.  (of course I'd like a haskell-alike but that seems rather remote)
09:55:31 <allbery_b> I'm vaguely poking at ocamljava
09:55:49 <Cale> allbery_b: Have you talked to kmc about his work getting GHC to compile stuff for Android?
09:56:01 <allbery_b> no
09:56:04 <monadic_kid> OCaml's OO is decent and you get structural subtyping, it's pretty advance compared to mainstrain OO languages
09:56:31 <tux_mark_5> but it's syntax is a bit messed up compared to haskell
09:56:33 <Cale> I'm pretty sure that Ryan was getting him to work on that. At iPwn we eventually plan to support Android anyway.
09:56:39 <tux_mark_5> and haskell's type system is much more powerful
09:56:46 <allbery_b> yes
09:56:49 <mercury^> Cale: what is iPwn?
09:57:06 <tux_mark_5> so rather than using ocaml i decided to use haskell and to fill in the missing OOP blanks myself
09:57:20 <Cale> mercury^: The company I work for. We're writing a game called BloodKnight for iPhones in Haskell.
09:57:37 <mercury^> Sounds nice. Is there some place with more info?
09:57:42 * allbery_b frustrated that erjang doesn't like erlang R14 (it translates BEAM to JVM bytecode)
09:57:46 <mercury^> Also, is it your main work now or do you do something else too?
09:57:55 <Cale> there's http://ipwnstudios.com/
09:58:06 <Cale> It's my main work
09:58:24 <rndm> Cale: i'm surprised Apple allows that. Didn't they change their TOS to prevent adobe from compiling flash to xcode projects?
09:58:27 <monadic_kid> so what about OOHaskell? it uses HList underneath and does pretty much what most would do on a basic level in haskell, code looks pretty close the ocaml's oo class syntax
09:58:29 <monochrom> ♥ ocaml
09:58:39 <mercury^> Cale: is the engine you developed freely available?
09:58:47 <tux_mark_5> HList is beyond awful for me 
09:58:48 <allbery_b> I don't think it's up to date
09:58:48 <Cale> rndm: They changed that back, and besides, never enforced it except in Adobe's case.
09:58:57 <Ptival> can you rewrite this in a comprehension? do { x <- l; [x, x+1] }
09:59:07 <tux_mark_5> i couldn't sleep knowing that my code uses HList ;D
09:59:17 <tux_mark_5> well, that's a joke, but anyway, i don't like it
09:59:27 <tux_mark_5> it reminds me of C++ templates
09:59:35 <mercury^> > [x, x+1 | x <- [1..4]]
09:59:35 <lambdabot>   <no location info>: parse error on input `|'
09:59:42 <mercury^> Ptival: I guess not.
09:59:44 <tux_mark_5> personally, i feel that things like C++ boost shouln't even exist
09:59:46 <Cale> mercury^: no, but I think we plan to eventually release some of the FRP framework and the code which goes into GHC/making GHC compatible with these platforms.
09:59:48 <rndm> Cale: good to see it was just anti-adobe =)
09:59:48 <allbery_b> extra braces, mercury^
09:59:58 <hpc> Ptival: [y | y <- [x,x+1], x <- l]
10:00:00 <monadic_kid> well then just stick to basics record of functions/actions, lexcial closures over IORefs that can be shared between actions
10:00:04 <mercury^> Cale: nice, thanks.
10:00:11 <hpc> > [y | y <- [x,x+1], x <- [1..5]]
10:00:12 <lambdabot>   [x,x,x,x,x,x + 1,x + 1,x + 1,x + 1,x + 1]
10:00:12 <allbery_b> rndm: yes, it was very much aimed specifically at adobe.  just excessively ham-handed
10:00:20 <Cale> mercury^: You'd have to talk with RyanT5000 if you wanted to know more about that though... I'm not 100% sure what we're releasing.
10:00:35 <byorgey> hpc: switch the order =)
10:00:38 <hpc> > [y | x <- [1..5], y <- [x,x+1]]
10:00:38 <lambdabot>   [1,2,2,3,3,4,4,5,5,6]
10:00:41 <hpc> there we go
10:00:43 <hpc> :P
10:01:04 <hpc> the trick is that [x,x+1] has to become do y <- [x,x+1]; return y
10:01:25 <monadic_kid> tux_mark_5: do it the simple way: http://hpaste.org/44750/nasty_hidden_sideeffecting_oo
10:01:33 <Ptival> thx hpc
10:02:14 <Cale> tux_mark_5: ^^ that's a decent, if limited, example of the way I usually encode OO in Haskell.
10:02:23 <tux_mark_5> monadic_kid: well, the syntax isn't exactly pretty, and you can't add inheritance this way
10:02:58 <Cale> tux_mark_5: Sure you can add inheritance, it just has to be explicit.
10:03:06 <tux_mark_5> Cale: i want for OOP code to be pretty in haskell
10:04:04 <Cale> inheritance is one of the least important features of OOP in my eyes though.
10:04:53 <Cale> OOP is *really* about the idea that a value is determined by the definitions of some operations which act on it
10:05:26 <Cale> (a coalgebraic worldview, to traditional FP's algebraic one)
10:05:29 <monadic_kid> what exactly is ugly about it really? what is the problem with that code? except for the obvious such as mutable state
10:05:41 <mercury^> Cale: can you expand on that last statement.
10:05:44 <mercury^> ?
10:06:00 <hpc> Cale: wouldn't that make it "verb-oriented programming" if it is all about the operations?
10:06:20 <allbery_b> mmm, Icon
10:06:30 <Cale> mercury^: The identity of an object is entirely determined by the manner in which it responds to messages that you send it.
10:06:41 <mercury^> Ok, so far I am with you.
10:08:28 <tux_mark_5> Cale: this is my idea of OOP in haskell
10:08:29 <Cale> Which, if you look at it from a slightly different angle, these replies are the results of applying various deconstructors to it.
10:08:30 <tux_mark_5> http://hpaste.org/45070/oop
10:08:54 <tux_mark_5> it's partially working pseudocode
10:09:16 <tux_mark_5> i've overloaded >> operator for object access
10:09:27 <mercury^> Cale: it's a bit foggy now, but I think I am with you still.
10:10:43 <Cale> mercury^: Well, let's look at a simple example of an object in a simple game, with a method for drawing the value on the screen, and a way of stepping it forward in time (you'd probably want more than just this, but let's keep it simple)
10:11:01 <Fuco> how would Data.Foldable.minimumBy work on Data.Map?
10:11:09 <Fuco> I want to find min value in map
10:11:14 <Fuco> value, not key
10:11:46 <Cale> We can represent such a thing as a pair consisting of the results of those two operations:  data GameObject = O { draw :: IO (); step :: GameObject }
10:11:47 <monadic_kid> tux_mark_5: you should check OOHaskell paper for ideas, it goes over various features of OO from OCaml, self recursion etc
10:11:53 <hpc> :t minimumBy
10:11:54 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
10:12:02 <hpc> Fuco: it would do it by value
10:12:04 <Cale> If you want to be fancy, we can include the time delta as a parameter to step:
10:12:24 <Cale> data GameObject = O { draw :: IO (); step :: DeltaTime -> GameObject }
10:12:25 <hpc> the type is Map key value, so minimumBy is polymorphic over the type of value
10:12:27 <Fuco> so I won't get key from it?
10:12:29 <tux_mark_5> monadic_kid: i've checked it out a while a go and decided that objc style hashtable distpach is the way to go
10:12:33 <hpc> Fuco: no, you won't
10:12:37 <Fuco> damn
10:12:38 <mercury^> Cale: alright, so `deconstructor' can be anything really.
10:12:42 <Cale> mercury^: yeah
10:12:50 <tux_mark_5> and i prefer the syntax from "http://hpaste.org/45070/oop"  ;)
10:13:02 <tux_mark_5> no boilerplate code, no useless invocations
10:13:13 <hpc> Fuco: you can make an associative list though, and do minimumBy (comparing second)
10:13:16 <tux_mark_5> just pure OOP ;)
10:13:24 <hpc> :t Data.Map.toList
10:13:25 <lambdabot> forall k a. M.Map k a -> [(k, a)]
10:13:42 <Fuco> that's a bit slow I guess... but should work ;P
10:13:55 <hpc> well, maps are ordered by key, not value
10:14:00 <hpc> so it has to be linear anyway
10:14:01 <Cale> mercury^: The important thing being that we have a product type with occurrences of our object type in positive positions, I guess.
10:14:22 <Fuco> yea
10:14:34 <mercury^> Cale: what are occurrances in positive position?
10:14:34 <Cale> Rather than enumerating the possible game objects and their associated data as a sum type
10:16:30 <copumpkin> meaning we return them
10:16:44 <Cale> mercury^: Actually, I'm pretty tired, and not sure how important this point really is here, but the terminology comes from the way that A -> B can be re-expressed in logic as (not A) or B
10:17:29 <mercury^> Ok.
10:17:35 <hpc> mercury^: i am probably wrong, but this is what i think, if it helps
10:17:55 <hpc> mercury^: algebras are about building things up, so you have (Object -> Stuff -> Object)
10:18:20 <hpc> mercury^: in a coalgebra, you are taking it apart, like (Object -> (Stuff, Object))
10:18:47 <Cale> It's sort of about whether we're primarily using sums or primarily using products to express our values.
10:19:03 <Cale> Another option for designing our game is to make a sum type
10:19:12 <Cale> With all the possible objects in the world as cases
10:19:23 <Cale> and their various data as fields of those
10:19:53 <Cale> (clearly somewhat cumbersome in this very OO-favoured case, but lovely for things like lists and binary trees)
10:21:33 <Cale> The nice thing about having a sum type is that you know what all the cases are up-front, so it's easy to write more and more functions which operate on all those possible cases in future modules.
10:22:07 <outsid3r> im writting a sudoku solver, for now i have written a function to check if a row contains any repeated element:
10:22:13 <outsid3r> checkRow :: GridRow -> Bool
10:22:14 <outsid3r> checkRow (x:xs) | null (x:xs)     = True
10:22:14 <outsid3r>                 | x == 0          = checkRow xs
10:22:14 <outsid3r>                 | all ((/=) x) xs = checkRow xs 
10:22:14 <outsid3r>                 | otherwise       = False
10:22:24 <Cale> On the other hand, we can also do things the other way around, like is probably nicer in this example of the objects in a game world, and capture the operations we want to perform as a product type.
10:22:24 <outsid3r> then i wrote a function to check for all rows
10:22:29 <outsid3r> checkRows :: Grid -> Bool
10:22:30 <outsid3r> checkRows (row:grid) | null (row:grid)  = True 
10:22:30 <outsid3r>                      | checkRow row     = checkRows grid 
10:22:30 <outsid3r>                      | otherwise        = False
10:22:33 <outsid3r> but it is not working
10:22:35 <jmcarthur> outsid3r: hpaste.org
10:22:46 <outsid3r> the recursion does not end
10:22:53 <hpc> outsid3r: null (x:xs) always returns False
10:22:56 <Cale> and then it's easy to extend the sorts of objects in our world in future modules, simply by writing new values of this type
10:22:56 <hpc> @src null
10:22:56 <lambdabot> null []     = True
10:22:57 <lambdabot> null (_:_)  = False
10:22:59 <jmcarthur> too much code to paste directly here, so next time please use a paste bin sort of thing :)
10:23:14 <Cale> (but hard to extend the operations, because we have to update all our existing definitions)
10:24:11 <outsid3r> on checkRows ?
10:24:39 <mercury^> outsid3r: it is not very efficient to use lists for your grid.
10:25:05 <outsid3r> mercury^, yea but for now it's all i have, the exercise states to use lists
10:25:07 <Cale> That's the tradeoff that OO languages make -- they make it easy to extend the cases of data (add one new subclass / copy a value and add a field to it), but hard to extend the methods on that data (have to extend the implementation of all existing objects)
10:25:38 <outsid3r> Grid :: [[Int]]
10:26:04 <Cale> Or rather, that's not the best way to explain that example. In an ideal world, your new cases of data come just from replacing the values of the fields of your objects
10:26:12 <mercury^> Cale: alright. How does that fit with (co)algebras though? (Sorry for being a bit thick wrt. that apparently)
10:26:33 <outsid3r> hpc, i did not get the error, why the recursion does not end on checkRows?
10:26:34 <copumpkin> coalgebraic definitions tend to be "observey"
10:26:35 <copumpkin> :P
10:26:40 * copumpkin shrugs and waves his hands some more
10:27:06 <Cale> Wellll... hmm, how to explain this :)
10:27:37 <mercury^> Ah, ok. If that's all there was to it that's fine. I just thought it would formally correspond to that somehow. (or does it actually?)
10:27:53 <Cale> You want "infinite streams" of future versions of your object
10:27:57 <jmcarthur> i'm sure there is a way to formalize it
10:28:08 <Cale> basically
10:28:13 <jmcarthur> i think of the coalgebraic view as sort of a tree
10:28:43 <jmcarthur> you can traverse the tree of object states, and as you go you can also get some extra data (the "output" of the methods)
10:29:32 <byorgey> outsid3r: that code goes into an infinite loop?
10:29:34 <btutt> SqlLite error messages sure can suck
10:30:05 <byorgey> outsid3r: looks to me like it will crash
10:30:10 <outsid3r> byorgey, ye
10:30:17 <byorgey> outsid3r: both your functions have no case to handle the empty list
10:30:32 <byorgey> outsid3r: if you pattern match on (row:grid) that will only match lists with at least one element
10:30:35 <outsid3r> byorgey, w8, actually the error is on checkRow 
10:30:43 <Cale> mercury^: You know how the terminal F-coalgebra for the polynomial functor F which sends an object T to 1 + A x T is possibly infinite lists, while the initial F-algebra is finite lists?
10:30:51 <outsid3r> byorgey, k
10:30:59 <outsid3r> byorgey, let me try to fix it
10:31:05 <byorgey> ok
10:31:08 <mercury^> Cale: yes.
10:31:53 <Cale> I think the notion is that when our object has a field consisting of another object (the one which corresponds to the resulting object after sending a message), we don't want those chains of message-passings to necessarily be finite.
10:32:19 <outsid3r> byorgey, ok, fixed, thanks ;)
10:32:31 <byorgey> great =)
10:33:28 <ddarius> > let pell = (1,0):(3,2):tail (tail $ concat (zipWith (\abs (x,y) -> map (\(a,b) -> (a*x+2*b*y, b*x+a*y))) (tail $ inits pell) pell)) in pell
10:33:28 <lambdabot>   Couldn't match expected type `[a]'
10:33:28 <lambdabot>         against inferred type `[(t, t)] ...
10:34:20 <ddarius> > let pell = (1,0):(3,2):tail (tail $ concat (zipWith (\(x,y) -> map (\(a,b) -> (a*x+2*b*y, b*x+a*y))) pell (tail $ inits pell))) in pell
10:34:23 <lambdabot>   mueval-core: Time limit exceeded
10:34:30 <Cale> The initial F-algebra for the functor  data F a = O { next :: a, value :: Integer } is empty, while the terminal F-coalgebra is infinite streams of integers
10:34:59 <outsid3r> checkRow :: GridRow -> Bool
10:35:00 <outsid3r> checkRow [] = True
10:35:00 <outsid3r> checkRow (x:xs) | x == 0          = checkRow xs
10:35:00 <outsid3r>                 | all ((/=) x) xs = checkRow xs 
10:35:00 <outsid3r>                 | otherwise       = False
10:35:04 <outsid3r> any more elegant way to write this?
10:35:58 <jmcarthur> outsid3r: hpaste, please
10:35:59 <hpc> outsid3r: yes, on pastebin ;)
10:36:08 <outsid3r> k, sorry
10:36:29 <jmcarthur> outsid3r: i'll give it a shot if you stick it on hpaste :)
10:36:29 <byorgey> outsid3r: yes, using 'all' and 'tails'
10:36:39 <Cale> mercury^: So at least in this case, the latter thing is a lot closer to the idea of an object which can respond to a 'next' message and a 'value' message.
10:36:46 <byorgey> outsid3r: use 'tails' to generate the list of all suffixes first
10:36:49 <byorgey> > tails [1,2,3,4]
10:36:49 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
10:36:56 <Cale> mercury^: I'm not sure how to formalise the idea much more than that, but hopefully it helps.
10:37:00 <outsid3r> with more elegant i mean, can i put all inside the guards?
10:37:06 <outsid3r> didnt knew that function, tails
10:37:13 <mercury^> Cale: yeah, thanks a lot.
10:37:44 <outsid3r> how i put the case [] inside the guard?
10:37:46 <byorgey> outsid3r: you could also use 'filter' to throw away the zeros first and then 'nub' to check for duplicates
10:37:50 <copumpkin> > let pell = (1,0):(3,2):tail (tail $ concat (zipWith (\(x,y) -> map (\(a,b) -> (a*x+2*b*y, b*x+a*y))) pell (tail $ inits pell))) in take 10 pell
10:37:54 <lambdabot>   mueval-core: Time limit exceeded
10:37:57 <byorgey> outsid3r: you can't.
10:37:57 <hpc> outsid3r: guards aren't for patterns
10:38:01 <copumpkin> > let pell = (1,0):(3,2):tail (tail $ concat (zipWith (\(x,y) -> map (\(a,b) -> (a*x+2*b*y, b*x+a*y))) pell (tail $ inits pell))) in take 3 pell
10:38:05 <lambdabot>   mueval-core: Time limit exceeded
10:38:19 <Cale> mercury^: They're common terms thrown about in FP CS land this way, and I've never seen anyone spell out the connection explicitly, but that example sorta makes it clear enough to get by :)
10:38:53 <byorgey> > let noDuplicates xs = xs == nub xs in noDuplicates . filter (/=0) $ [1,0,2,0,0,4,3]
10:38:53 <outsid3r> nub is that function that removes duplicates right?
10:38:54 <lambdabot>   True
10:38:55 <Cale> Aaaanyway...
10:39:02 <byorgey> > let noDuplicates xs = xs == nub xs in noDuplicates . filter (/=0) $ [1,0,2,0,0,4,3,4]
10:39:04 <lambdabot>   False
10:39:06 <byorgey> yes
10:39:25 <outsid3r> so if i do something like nub xs == xs it means that there is no duplicates
10:39:33 <jmcarthur> > liftA2 (==) id nub . filter (/=0) $ [4,2,3,0,6,7,0,1]
10:39:34 <Cale> tux_mark_5: If you don't like IO, you can always do objects without IO, just by being recursive.
10:39:35 <lambdabot>   True
10:39:46 <Cale> tux_mark_5: I wanted to give this example earlier...
10:40:04 <tux_mark_5> Cale: there is nothing wrong with IO
10:40:09 <Cale> data GameObject = O { draw :: IO (); next :: GameObject }
10:40:22 <tux_mark_5> i just don't like hundreds of readIORef/writeIORef
10:41:36 <Cale> circle radius x v a = O { .. } where draw = drawCircle radius x; next = circle radius (x + v) (v + a) a
10:41:57 <monochrom> Bart Jacob's (and Jan Rutten's) "a tutorial on (co)algebras and (co)induction" describes how to use coalgebra to model OOP. Bart Jacobs is into this.
10:42:03 <Cale> (this is using some extension syntax supported by GHC, but you could also write the fields in-place)
10:42:18 <Cale> monochrom: cool!
10:42:30 <monochrom> the pdf is at http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf
10:43:30 <Cale> tux_mark_5: See how that works? The constructor for our circle object is just a function, and we "respond" to the next "method" by simply giving calling the constructor with different parameters.
10:44:19 <monochrom> his other papers are at http://www.cs.ru.nl/B.Jacobs/PAPERS/index.html
10:44:26 <Cale> (This is unrealistic code, because you probably want vector addition for x,v,a, rather than number addition, but I didn't feel like writing ^+^ or whatever)
10:44:53 <Cale> It's also unrealistic in being overly simple, but I hope it sort of gets the idea of the encoding across.
10:44:56 <tux_mark_5> hmm
10:45:04 <tux_mark_5> well yeah
10:46:03 <jedai> outsid3r: Note that if by "elegant" you mean "efficient", you should probably use Data.IntMap instead, it would bring your algorithm from O(n²) to O(n log n)
10:46:22 <Cale> There was also some edit fail in my previous remark, but it seems understandable, and I'm really sleepy ;)
10:47:20 <outsid3r> jedai, maybe later, for now i must use lists, this is just my 4 worksheet from college
10:47:37 <Cale> tux_mark_5: This encoding doesn't necessarily mesh well with external representations of objects though, because it's either infinite or full of function values -- the objects are their methods, and the "private data" are function parameters.
10:48:28 <Cale> tux_mark_5: But you can provide a method to serialise to whatever format you like of course, or to do the appropriate IO for constructing the object in an external form, perhaps.
10:48:35 <tux_mark_5> i think that i'll try to implement the oop lib in my own way and if that doesn't work i'll try to do it some other way 
10:48:54 <Cale> tux_mark_5: When I want to do OO-like things in Haskell, this is typically what I do though.
10:49:12 <tux_mark_5> hmm
10:49:36 <Cale> and it really is good enough to produce nice results in most if not all of the cases where you "want" OO
10:49:46 <monochrom> using a lookup table of Dynamic's is javascriptish. which is actually fine by me, javascript enjoys the clean-up of Guy Steele. Just make sure you use the prototype paradigm!
10:50:27 <Cale> It just doesn't tackle inheritance or subtyping at all, but those things are quite overrated ;)
10:51:00 <tux_mark_5> Cale: well, i don't think that iheritance is overrated
10:51:05 * confound_ does
10:51:08 <Cale> OO is all about objects responding to messages, and everything else is fanciness
10:51:12 * monochrom will hack up "dependent javascript" one day
10:51:12 <hpc> inheritance really comes down to holding a parent object inside the child, anyway
10:51:19 <Cale> yeah
10:51:31 <tux_mark_5> all in all, i like the OCaml's approach to OOP, but it is sad, that haskellers simply ignore this need of OOP within GHC
10:51:40 <Cale> It's not that sad
10:51:47 <tux_mark_5> for me it is
10:51:58 <aavogt> @where OOHaskell
10:51:58 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
10:51:59 <confound> inheritance is just a particular form of code reuse
10:52:09 <monochrom> mainstream "inheritance" confuses two things together.
10:52:27 <tux_mark_5> the real world is object based 
10:52:34 <confound> there are other forms of code reuse even within an OO paradigm
10:52:37 <tux_mark_5> as in from philisophical perspective
10:52:52 <hpc> the real world can be anything if you use philosophy to judge it
10:52:58 <tux_mark_5> most of the code for some "magical" reason is written in OOP
10:53:14 <opqdonut> well most code was "magically" procedureal before that :)
10:53:19 <beastaugh> tux_mark_5: object based in what sense?
10:53:34 <Cale> The real world isn't object based, it's totally declarative. It's all about differential equations, man. ;)
10:53:37 <opqdonut> anyway, how you model the world shouldn't dictate how you structure your program
10:53:40 <monochrom> I know that philosophical perspective. "Define 'object' to refer to real world things. Oh therefore real world things are objects!"
10:53:42 <tux_mark_5> most (mainstream and popular) programming langugaes are OOP
10:53:54 <tux_mark_5> just look at C++, Java
10:53:55 <opqdonut> well they're also nonpure
10:54:00 <opqdonut> and not functional
10:54:10 <opqdonut> unlike haskell
10:54:10 <confound> 20 years ago most mainstream and popular programming languages weren't OOP. so what?
10:54:16 <Cale> tux_mark_5: Popular doesn't mean good ;)
10:54:24 <tux_mark_5> why do you think google chose Java as their programing language instead of Haskell?
10:54:43 <hpc> google didn't choose java
10:54:45 <monadic_kid> THey don't use one language apparently or do you mean Android?
10:54:46 <Cale> It means "similar to stuff that lazy programmers already knew, or were forced to learn as a result of working on existing stuff"
10:54:47 <hpc> and they do use haskell
10:54:55 <tux_mark_5> (for android that is)
10:55:05 <Cale> tux_mark_5: Because there are tons of people who already know Java.
10:55:05 <monochrom> yeah, you have better chance with "why do you think 'google' contains 'oo'?"
10:55:11 <jmcarthur> hpc: well... isn't it only a few of the "20% time" projects that use haskell?
10:55:11 <confound> haha
10:55:23 <tux_mark_5> and why there are tons of people who know java? ;)
10:55:29 <tux_mark_5> haskell is older than java
10:55:39 <confound> you are full of terrible arguments
10:55:46 <Cale> Because Java is all but indistinguishable from the older popular languages.
10:55:48 <tux_mark_5> i'm full of statistics
10:55:50 <monochrom> Sun spent a lot of money.
10:55:52 <confound> are you deliberately trolling?
10:55:55 <tux_mark_5> it doesn't mean i like them
10:55:57 <confound> "tons" is a statistic now?
10:56:03 <aristid> tux_mark_5: probably the choice for java was made before google bought android, so while google clearly uses java for many of their non-android things too, you can't ascribe the decision for java on android to them
10:56:06 <Cale> Before Java, C++ was really popular
10:56:13 <confound> anyway, even if you had real numbers (you don't), the conclusions you're presenting don't follow from them
10:56:19 <monadic_kid> Haskell was never hyped up and marketed like Java/OO was in the 90s
10:56:20 <hpc> before that, Pascal was popular
10:56:21 <Cale> and if not C++, then C
10:56:23 <jmcarthur> tux_mark_5: can you give any particular justification for this alleged need for OO aside from "everybody else uses it"?
10:56:26 <tux_mark_5> basically what im trying to say - haskell has some shortcomings, which should be addressed
10:56:28 <hpc> before that, fortran/cobol
10:56:31 <hpc> etc etc
10:56:38 <monochrom> I think OO is the shortcoming.
10:56:40 <hpc> the abacus was popular at one point
10:56:40 <confound> no, you're trying to say "I want to keep writing in an OO style, so the world should conform to me"
10:56:51 <tux_mark_5> yeah, but the lack of extensible records isn't?
10:56:54 <Cale> tux_mark_5: Apparently the shortcoming is popularity :P
10:56:56 <jmcarthur> tux_mark_5: i agree that haskell has shortcoming, but i strongly disagree that lack of language support for objects is one of them
10:56:58 <aristid> well, you CAN write haskell in an OO style, if you really want
10:57:14 <tux_mark_5> i can write OO in assembly too, you know
10:57:20 <monochrom> yes I would like extensible records.
10:57:35 <jmcarthur> tux_mark_5: in haskell, OO isn't such a stretch as it is in assembly
10:57:36 <aristid> tux_mark_5: and reasonably conveniently, too
10:57:46 <beastaugh> Haskell is full of objects
10:57:48 <monochrom> I probably won't always use extensible records for OO though.
10:57:51 <beastaugh> they're just not mutable objects
10:57:52 <Cale> tux_mark_5: I guarantee that you almost never need extensible records, and I'm one of the people who would like to see some system for row polymorphism added to GHC as an extension.
10:57:56 <tux_mark_5> but it's more of a stetch in haskell that it is in C
10:58:10 <aristid> monochrom: extensible records may be useful independent of OO :)
10:58:13 <jmcarthur> i strongly disagree again
10:58:14 <Cale> tux_mark_5: Whaaaaaat
10:58:20 <jmcarthur> i think C-style OOP is completley wrong
10:58:25 <jmcarthur> *completely
10:58:35 <tux_mark_5> look at GTK & GObject
10:58:40 <jmcarthur> haskell supports OOP almost natively
10:58:48 <aristid> better than C.
10:59:00 <Cale> tux_mark_5: Absolutely not. Any abstraction you can reasonably cobble together in C, you can do in Haskell and be safer and nicer about it.
10:59:24 <tux_mark_5> sure you can
10:59:36 <tux_mark_5> but you'll end up with 50 MB binaries, like qtHaskell did
10:59:39 <Cale> No.
10:59:52 <monochrom> I seriously think "popular" only means "for lazy brains".
10:59:56 <Cale> Do you even know why those 50MB binaries were being produced?
10:59:57 <jmcarthur> qtHaskell is *generated*
11:00:00 <Cale> It's not because of Haskell code.
11:00:05 <aristid> tux_mark_5: C++ binaries tend to be that big, too.
11:00:05 <jmcarthur> and qt is huge
11:00:22 <tux_mark_5> aristid: show me an executable that is 50 MB 
11:00:29 <jmcarthur> wtf
11:00:37 <tux_mark_5> personally, I only have vmware on my machine of that size
11:00:49 <monochrom> jhc probably gives you a small executable.
11:00:55 <tux_mark_5> qt isn't huge
11:01:07 <jmcarthur> tux_mark_5: try statically linking qt into your executables
11:01:08 <tux_mark_5> the size of all the qt libs combined is about 30 megs
11:01:25 <jmcarthur> yeah there's the bulk of it already
11:01:43 <Cale> Yep, that's where all the size is coming from
11:01:43 <tux_mark_5> keep in mind, that these are *BINDINGS* we are talking about
11:01:48 <monochrom> hugs generates an executable the exact size of your source code.
11:01:53 <jmcarthur> tux_mark_5: yeah, and they are statically linked
11:02:02 <tux_mark_5> so BINDINGS are larger than the lib :D
11:02:11 <jmcarthur> of course they are...
11:02:15 <Cale> tux_mark_5: The bindings include the lib...
11:02:24 <outsid3r> http://hpaste.org/45072/sudo new implementation
11:02:26 <hpc> tux_mark_5: guess what though? when you run a haskell program with qt statically linked, you don't need to also have qt installed!
11:02:27 <outsid3r> with nub
11:02:28 <tux_mark_5> bindings link the application dynamically
11:02:33 <jmcarthur> no
11:02:35 <outsid3r> much better indeed, tks guys
11:02:43 <Cale> If they did, it wouldn't be 50MB :P
11:02:53 <tux_mark_5> as in ldd haskellQtApp shows libQtGui4.so is being used
11:03:37 <tux_mark_5> for example, I use leksah for my haskell development
11:03:58 <tux_mark_5> and it links 52 external libs 
11:04:07 <Cale> Well, okay, you might be right about the 50MB just consisting of a large number of foreign imports + all the generated stuff, hmm.
11:04:15 <tux_mark_5> the leksah binary itself is 39 MB
11:04:27 <Cale> But still, the library which wraps all the C stuff is being linked into your executable.
11:04:37 <parcs> is it generally safe to use split-objs with cabal?
11:04:54 <Cale> Yeah, try -split-objs and see if it makes your executable smaller
11:05:05 <tux_mark_5> it does link, but i think that the statically linked lib shouldn't be that large in the first place
11:05:12 <jmcarthur> well, you need to rebuild all the libs with split-objs, don't you?
11:05:18 <Cale> yeah, I think so...
11:05:19 <parcs> i think so. :(
11:05:31 <monochrom> I have a small program that uses gtk2hs. It is not 50MB. 14MB sure. I haven't even stripped.
11:05:34 <Cale> tux_mark_5: Why?
11:05:47 <jmcarthur> monochrom: doesn't cabal strip by default?
11:05:48 <monochrom> 6.7MB if stripped.
11:05:52 <jmcarthur> huh guess not
11:05:55 <tux_mark_5> Cale: "why?"
11:06:02 <jmcarthur> or maybe you were jus tinvoking ghc manually
11:06:16 <Cale> tux_mark_5: It's a significant amount of Haskell code.
11:06:19 <monochrom> your "50MB" or "30MB" argument is borked.
11:06:24 <Twey> Is there documentation somewhere of the classes Pandoc uses when highlighting code?
11:06:38 <tux_mark_5> Cale: which does pretty much nothing other than calls the native C/C++ code
11:07:04 <Cale> tux_mark_5: Some Haskell code for every single piece of C++ code in the qt library, plus extra typeclasses and instances and all sorts of other junk.
11:07:24 <monochrom> oh heh I entered "ghc -O --make" myself.
11:07:34 <jmcarthur> ah
11:07:42 <hpc> monochrom: not -O2?
11:07:48 <tux_mark_5> Cale: most of haskell stuff should disappear in runtime
11:07:51 <jmcarthur> -O is usually just as effective as -O2
11:08:00 <jmcarthur> sometimes even better
11:08:01 <monochrom> ~/.cabal/config has "executable-stripping: True" as default, don't worry
11:08:07 <Cale> http://qthaskell.berlios.de/doc/apiGuide/doc-index.html ;)
11:08:20 <monochrom> oh actually I know a case of -O0 trumping -O :)
11:08:25 <tux_mark_5> i could print stats of my ~/.cabal/bin directory if you want
11:08:26 <jmcarthur> uh...
11:08:33 <jmcarthur> monochrom: that sounds like a bug :)
11:08:34 <hpc> @quote O2
11:08:34 <tux_mark_5> every single binary that is there is stripped
11:08:34 <lambdabot> dons says: looks like a job for -O2
11:08:58 <jmcarthur> tux_mark_5: and are all your libs and stuff built with split-objs?
11:09:05 <tux_mark_5> no
11:09:20 <Cale> tux_mark_5: and most of that stuff is not just stubs, it actually has to do marshalling between Haskell datatypes and C datatypes
11:09:29 <jmcarthur> split-objs is meant to tackle this size issue a bit
11:09:31 <tux_mark_5> as far as i understand i would need to keep huge amount of object files in order to use that
11:09:36 <jmcarthur> yes
11:09:40 <jmcarthur> an unfortunate penalty
11:09:43 <monochrom> import Data.List(foldl'); () & () = (); main = print (foldl' (&) () (replicate 2500000 ()))
11:09:44 <jmcarthur> also, you link times go up
11:09:46 <jmcarthur> *your
11:09:50 <Cale> and besides, this entire discussion tangent is ridiculous
11:10:11 <Cale> because it has nothing to do with representing abstractions
11:10:15 <beastaugh> Twey: http://johnmacfarlane.net/highlighting-kate/
11:10:22 <tux_mark_5> for example, i couln't use haskell on embedded devices with these sizes
11:10:23 <Cale> it has to do with a binding to an extremely large C++ library
11:10:25 <monochrom> To be fair, that is unrealistic code, I wouldn't mind missing such a corner case. :)
11:10:33 <jmcarthur> tux_mark_5: you can't use *ghc* on embedded devices
11:11:08 <tux_mark_5> "right"
11:11:19 <Twey> beastaugh: Hm, thanks
11:11:20 <tux_mark_5> i have a mouse which has 512 KB of memory
11:11:28 <Cale> tux_mark_5: We're building Haskell code for iPhones using GHC. If you want to go smaller than that, Haskell makes an awesome metalanguage.
11:11:35 <tux_mark_5> it contains firmware, which is written in C
11:11:37 <jmcarthur> i doubt your mouse will be running qt either
11:11:48 <tux_mark_5> true
11:11:49 <Cale> That's the sort of code you'd use something like Atom for
11:11:57 <jmcarthur> yeah atom/copilot
11:11:59 <beastaugh> Twey: when you install Pandoc you need to pass the -fhighlighting flag
11:12:03 <jmcarthur> jhc might stand a chance
11:12:08 <Cale> http://hackage.haskell.org/package/atom
11:12:11 <monochrom> yes you are seriously confusing "haskell" with "ghc". go look up hugs and jhc some day. you may even discover extensible records.
11:12:15 <Cale> Atom is a Haskell DSL for designing hard realtime embedded software.
11:12:25 <tux_mark_5> i think that something should be done about these huge binaries
11:12:25 <hpc> also yhc?
11:12:31 <hpc> or is that an old one
11:12:35 <tux_mark_5> any sane person would say so
11:12:42 <Cale> (people are actually using it to design software for controlling industrial hydraulic systems)
11:12:44 <Twey> beastaugh: I've got highlighting — I'm generating HTML with it, and the HTML needs CSS to make the highlighting visible.
11:12:53 <Cale> tux_mark_5: Don't use the QT binding then :P
11:12:54 <jmcarthur> tux_mark_5: i'm sorry, but most people don't care. if you're doing embedded stuff, don't use ghc. there are alternatives
11:13:02 <Twey> It seems that Pandoc can generate that
11:13:11 <Cale> tux_mark_5: There are other libraries and bindings which are much smaller.
11:13:22 <jmcarthur> regardless, what the hell does this have to do with OOP?
11:13:30 <tux_mark_5> nothing ;D
11:13:31 <monochrom> there is even a compiler to generate javascript code if you feel so inclined
11:13:39 <jmcarthur> i missed the switchover to binary sizes
11:13:47 <hpc> jmcarthur: he trollin' :P
11:13:58 <tux_mark_5> the idea is that ghc devs ignore some serious issues that i think should be addressed
11:14:02 <beastaugh> Twey: oh, ok
11:14:04 <Jafet> Didn't you know? Haskell sucks for everything.
11:14:04 <beastaugh> http://johnmacfarlane.net/highlighting-kate/hk-kate.css.html
11:14:08 <Cale> tux_mark_5: I don't understand how this line of discussion is at all an appropriate response to my remark that any abstraction which can be cobbled together in C can be done more elegantly in Haskell.
11:14:10 <jmcarthur> tux_mark_5: if you think they are so serious why don't you fix them? :P
11:14:12 <beastaugh> something like that? :)
11:14:13 <Jafet> It's a wonder why people try to use it.
11:14:25 <Cale> tux_mark_5: Because QT really has nothing to do with that.
11:14:27 <Twey> Clearly we should stop wasting our time and switch to F#.
11:14:27 <jmcarthur> i get by fine
11:14:27 <monochrom> I'm pretty sure I haven't seen a javascript executable 50MB large. Either that, or 50MB of javascript code is a full-fledged office suite.
11:14:31 <tux_mark_5> i don't have the GHC internals knowledge of how things work
11:14:55 <jmcarthur> but you're enough of an expert to judge what an acceptable binary size is for what ghc does
11:15:11 <hpc> 50MB of javascript is a browser crash waiting to happen
11:15:16 <tux_mark_5> here we have hello world with 50 Megs ;)
11:15:22 <monochrom> But a whiner keep shifting topics to rationalize complaining.
11:15:32 <Cale> tux_mark_5: But that's a constant term.
11:15:34 <Twey> hpc: I wouldn't be surprised if some of those fancy new libraries approach that
11:15:45 <jmcarthur> i'm pretty sure hello world is nowhere *near* 50 MB
11:15:51 <Cale> tux_mark_5: It's not like a program twice as complicated as hello world will be 100MB
11:15:58 <tux_mark_5> actually it is
11:16:04 <hpc> Twey: why?! that's pretty much the ENTIRE browser cache!
11:16:04 <monochrom> no, 50MB of javascript is intended to be run on a standalone javascript implementation (such as ECMA's reference one)!
11:16:13 <hpc> people suck...
11:16:19 <tux_mark_5> qtHaskell's hello world app is 51 Megs in size
11:16:28 <monochrom> to add coolness, the ECMA reference implementation is written in some ML!
11:16:34 <tux_mark_5> i haven't tested this myself
11:16:45 <tux_mark_5> but the author wrote this in some mailing list
11:16:49 <jmcarthur> tux_mark_5: 644K here...
11:16:51 <monochrom> (50MB of javascript code poses no challenge to an ML program, no)
11:16:54 <Twey> hpc: My friend wrote a script that would render an image into HTML tables with background-color on the cells ;)
11:16:58 <jmcarthur> tux_mark_5: hello world, that is
11:17:09 <jmcarthur> tux_mark_5: so you are doing something seriously wrong
11:17:15 <jmcarthur> oh qt's
11:17:16 <tux_mark_5> ...
11:17:18 <jmcarthur> well shit, that's qt
11:17:20 <tux_mark_5> yes, qt
11:17:32 <jmcarthur> i'm not going to defend qt
11:17:43 <monochrom> I'm going to join the attack on qt.
11:17:51 * Twey chuckles.
11:17:52 <monochrom> qt cannot be embedded.
11:18:08 <tux_mark_5> it can actually
11:18:08 <monochrom> qt is too big for even ipad
11:18:15 <Cale> BUT I WANT TO RUN QT ON THE MICROCONTROLLER IN MY MOUSE
11:18:17 <jmcarthur> qt doesn't qualify as a hello world
11:18:19 <tux_mark_5> qt runs on iPhone, android and etc
11:18:26 <Twey> Hahahaha
11:18:29 <monochrom> a kde account takes forever to log on. I have seen it.
11:18:53 <jmcarthur> monochrom: qt actually does run on a lot of mobile devices
11:18:53 <monochrom> apple decided against qt for macos x
11:18:55 <mercury^> That might get better with the new C++ revision.
11:18:58 <Twey> It is known!
11:19:07 <monochrom> qt is not mainstream.
11:19:20 <monochrom> (windows and darwin are mainstream)
11:19:24 <tux_mark_5> :D
11:19:34 * jmcarthur sees what monochrom is doing now
11:19:38 <monochrom> wait, does windows fit in an ipad?
11:19:41 <hpc> gtk is almost mainstream, given how many people use ubuntu now
11:19:50 <beastaugh> I keep getting this error when I try to compile a .hs file whose filename matches a module name in the ghc-pkg database: "File name does not match module name"
11:19:54 <tux_mark_5> hpc: it will shift to qt  ;)
11:19:57 <hpc> monochrom: windows is ~15Gb last i checked
11:20:02 <monochrom> "windows mobile" doesn't count. complete rewrite and shrunk API
11:20:11 <beastaugh> any way I can disable to lookup attempt and just have it treat it as a Main file?
11:20:11 <tux_mark_5> hpc: the new ubuntu's "unity" interface will use qt by default
11:20:20 <Cale> beastaugh: What's the name of the .hs file, and what's the module declaration on its first line?
11:20:24 <hpc> unity also sucks :P
11:20:33 <Cale> beastaugh: Leave the module declaration out
11:20:34 <tux_mark_5> yeah, it does
11:20:46 <Cale> If you want it to be a Main, or explicitly name the module Main
11:20:53 <hpc> every ubuntu laptop i have seen has been straight gnome
11:21:03 <hpc> even on tiny eeePCs where unity would make sense
11:21:05 <beastaugh> Cale: unfortunately, it does this even leaving out the module declaration
11:21:08 <Cale> But it's easier just to leave it out
11:21:11 <beastaugh> Cale: hakyll.hs
11:21:14 <Cale> okay
11:21:20 <Cale> That can't be the name of a module
11:21:38 <Cale> (but it's an okay filename for a main program)
11:21:53 <abbe> Hi, whom should I talk to if I like to invite lambdabot to join another channel?
11:21:53 <hpc> Hakyll.hs would work
11:21:55 <Cale> Because it doesn't start with an uppercase letter, it can't be a module name though.
11:21:57 <Fuco> when I have a function in a where clause, and it is using a variable defined in the "main" function, will it shadow it, or will it use the "main" variable?
11:21:59 <hpc> abbe: Cale
11:22:00 <tux_mark_5> what i can't figure out is why most of you are agains OOP; OCaml guys thought it was a great idea
11:22:03 <mercury^> I have had a quick look at the unity page. It looks exactly like the current gnome interface I find.
11:22:07 <abbe> Cale, Hi
11:22:07 <Fuco> because this might be a stupid source of some errors I'm having ;P
11:22:22 <abbe> thanks hpc.
11:22:47 <Cale> tux_mark_5: Because it's horribly overused, and mostly to patch over inadequacies of the imperative/effectful programming style.
11:23:07 <monochrom> I am not against OOP. I just find it overused. Like I said, I'm even fine with javascript. And ocaml of course.
11:23:09 <Jafet> Fuco: Haskell is lexically scoped.
11:23:18 <tux_mark_5> Cale: if FP was the solution, it would be dominant right now
11:23:22 <Cale> and to the extent that it's used to "encapsulate state", we don't really need it because we like to make everything stateless
11:23:25 <Fuco> Jafet: that means?
11:23:26 <beastaugh> lots of ocmal programmers hate OOP and think having it in the language was a huge mistake
11:23:34 <beastaugh> *ocaml
11:23:40 <tux_mark_5> Cale: world isn't stateless
11:23:45 <monochrom> If I knew scala, I might find it fine too.
11:23:45 <Cale> tux_mark_5: Do I really have to make this argument again?
11:23:51 <abbe> Cale, if it's not a problem, could you please ask lambdabot to join #haskell-india ?
11:24:04 <tux_mark_5> i'm just curious
11:24:05 <Jafet> Fuco: means that a definition outside main can't use a variable from all the way inside main.
11:24:09 <Younder> FP is a programming style. It is no more THE solution than OOP is..
11:24:10 <tux_mark_5> OCaml embraced the idea
11:24:17 <jmcarthur> tux_mark_5: most ocaml programmers don't use OOP
11:24:19 <tux_mark_5> and you fight agains it for some reason
11:24:33 <tux_mark_5> despite the fact that O in their name stands for Object
11:24:34 <monochrom> the real world has no state: http://groups.google.com/group/comp.lang.functional/msg/4c1cb17ded810ea0
11:24:34 <Cale> tux_mark_5: I tend to have a lot of patience, but I'm a little tired at the moment, and this is ridiculous, because we're going in circles. I already told you why FP is not dominant.
11:24:40 <jmcarthur> tux_mark_5: in industry, even
11:24:48 <monochrom> tell me how to mutate the state "I wore glasses yesterday"
11:24:48 <Jafet> Can we all acknowledge that tux has pushed the envelope for advanced #haskell trolling, and just ban him?
11:25:04 <Cale> Jafet: never
11:25:07 <Jafet> Otherwise we'll just have more and more bored people responding to him...
11:25:14 <Younder> Windows related stuff is best in OOP. Some web stuff  too. For database stuff FP is better..
11:25:16 <Zao> monochrom: You can mutate the record of knowledge that you wore glasses yesterday.
11:25:29 <Fuco> Jafet: http://pastebin.com/TrXJMV0m Please check this example out
11:25:36 <Fuco> I'm not sure I described it correctly
11:25:37 <Zao> monochrom: Just ask Winston Smith.
11:25:46 <monochrom> oh ha
11:25:55 <tux_mark_5> okay, i you don't want me here, i won't be here;
11:25:57 <Younder> Consider rollback without functional data-structures..
11:26:01 <Cale> tux_mark_5: State is simply a way of looking at things. It is never ever fundamental to anything.
11:26:12 <jmcarthur> well, it's fundamental to state :P
11:26:16 <Jafet> Fuco: it is local to f', because it appears in the parameter list for f'.
11:26:23 <Fuco> ok thanks
11:26:35 <tux_mark_5> i was interested in physics once, and pretty much every particle in universe had some sort of state
11:26:39 <jmcarthur> state is a rather self-fulfilling need
11:26:47 <tux_mark_5> so i figured then that OOP was a cool idea
11:26:49 <jmcarthur> tux_mark_5: by state you mean dependence on time
11:27:03 <jmcarthur> which is not necessarily the same as "requiring mutable state to reason about"
11:27:07 <beastaugh> Cale: so, it works if I don't have import Hakyll in the file
11:27:29 <jmcarthur> tux_mark_5: i've never attended a physic lecture where mutable state was encouraged
11:27:34 <jmcarthur> *physics
11:27:35 <beastaugh> I suppose GHC is trying to find the Hakyll module in the search path and is beginning in the current directory
11:27:43 <monochrom> physics precisely eliminates mutation. physics "state" translates to immutable record in programming.
11:27:44 <Cale> beastaugh: if you want to be able to import a module, it basically can't be the main module of your program.
11:27:49 <jmcarthur> most things are given as functions of time
11:28:03 <Cale> beastaugh: This is actually a lie I just told you, but it's inconvenient to disobey that rule.
11:28:09 <monochrom> which further translates to functional reactive programming, actually.
11:28:14 <beastaugh> Cale: sure, but I don't want the module to be the main module of the program, I just want to call the file hakyll.hs
11:28:16 <jmcarthur> yup
11:28:23 <tux_mark_5> but still, much of FP code has to hack around the state
11:28:30 <hpc> beastaugh: capitalize the first letter; module names start with a capital letter
11:28:32 <beastaugh> actually it's not even my file, it's an example in the library, I just want to be able to compile it
11:28:39 <hpc> beastaugh: that's all you really need to do
11:28:40 <Cale> beastaugh: If the module name is Hakyll then name the file Hakyll.hs, not hakyll.hs
11:28:46 <jmcarthur> tux_mark_5: due only to our strangely designed hardware
11:28:50 <tux_mark_5> because that's how computer architectures work - you have cpu, you have ram
11:28:53 <jmcarthur> yup
11:29:09 <monochrom> where is conal when we needs him to explode some brains? :)
11:29:10 <Zao> tux_mark_5: Damn you, Von Neumann!
11:29:14 <beastaugh> that's not going to work :)
11:29:20 <Cale> tux_mark_5: Computer architectures work according to Maxwell's laws.
11:29:20 <tux_mark_5> ;D
11:29:24 <beastaugh> https://github.com/jaspervdj/hakyll/blob/master/examples/brochure/hakyll.hs
11:29:25 <tux_mark_5> :D
11:29:25 <jmcarthur> but just because our machines are designed that way doesn't mean that it's "how the real world works"
11:29:49 <jmcarthur> the real world, to my knowledge, is not a von neumann architecture
11:29:51 <tux_mark_5> but we shouldn't ignore the fact of how architectures work
11:29:52 * conal wakes up, looks around
11:29:53 <beastaugh> all I want to do is run ghc --make on that file
11:29:55 <Cale> tux_mark_5: which are differential equations that never change :)
11:29:58 <josiah14> hi all
11:30:13 <jmcarthur> tux_mark_5: nobody said to ignore it
11:30:14 <josiah14> what should i look out for learning Haskell coming from C++ and C#?
11:30:40 <Saizan> beastaugh: have you installed the Hakyll library?
11:30:54 <monochrom> conal, please tell tux_mark_5 that the whole shebang of "state, IO" is a hack, and there is something better lurking in denotational design!
11:31:05 <pyf> hi! i'm trying to install a package with cabal, but I get an error message including "cannot satisfy -package Cabal-1.10.1.0: 
11:31:06 <pyf>     Cabal-1.10.1.0-64e8f05722ea5bbdf07df2e5a3491105 is unusable due to missing or recursive dependencies". does anyone know what i can do to fix this? the full output is here: http://hpaste.org/45073/cabal_install_problem?pid=45073&lang_45073=    . Thanks!
11:31:07 <josiah14> not yet.  I'm trying the online tutorial 'Try Haskell' right now
11:31:09 <Cale> josiah14: The fact that it's going to be like learning to program all over again. :) Learning C# was probably pretty easy if you already knew C++, but Haskell is pretty different.
11:31:13 <Saizan> beastaugh: and what's the exact error message you get? and what is your current working directory?
11:31:16 <josiah14> i follow through on my projects tho, when i start
11:31:26 <jmcarthur> we have constraints imposed by the hardware. it makes the machine tougher to fit to FP. that's all there is to it
11:31:34 <beastaugh> Saizan: yes
11:31:42 <beastaugh> let me paste some console output into a gist
11:31:45 <beastaugh> https://gist.github.com/888519
11:31:51 <Cale> josiah14: So basically, take it easy, and give it some time to become comfortable. Ask lots of questions here :)
11:31:55 <josiah14> thanks Cale
11:32:04 <josiah14> ill be sure to
11:32:15 <josiah14> im here for the journey, however long it takes
11:32:19 <jmcarthur> (the IO monad is what you get when you try to fit FP to the machine rather than the machine to FP)
11:32:51 <jmcarthur> i'm taking "the machine" to include the VM, too
11:33:11 <Saizan> beastaugh: are you on a case-insensitive file system, perhaps?
11:33:23 * monochrom renames conal's denotational design to detonational design!
11:33:27 <beastaugh> Saizan: hmm, yes, that could be it
11:33:29 <beastaugh> I'm on OS X
11:34:11 <Cale> I knew a lot of imperative languages when I started learning Haskell, and it took me about 2 months before I felt like I could really do genuinely useful things with Haskell. (Though I was studying a full load of math courses at the time.) It took about a year before I'd really say I was altogether comfortable. It has been both worth the time, and it's made picking up other functional languages and ideas a lot simpler.
11:34:21 <Saizan> beastaugh: try renaming hakyll.hs to whatever.hs
11:34:32 <Cale> We have better tutorials now than what existed when I started though :)
11:34:43 <beastaugh> yeah, looks like that works
11:34:45 <beastaugh> how annoying
11:34:50 <beastaugh> thanks for the help, everyone
11:34:55 <Saizan> np
11:35:26 <masak> Cale: when did you start learning Haskell?
11:35:33 <Cale> 2001
11:35:45 <conal> some folks persist in believing that the nature of sequential (1940s-style) computers must impact how they describe and solve their problems.
11:36:08 <conal> "We shape our tools and afterwards our tools shape us." - Marshall McLuhan
11:36:12 <tux_mark_5> because it's easier & faster to develop stuff that way
11:36:23 <monochrom> pyf: I need your outputs of "ghc -v" and "ghc-pkg list -v"
11:36:53 <jmcarthur> tux_mark_5: it's easier to use the incorrect tools than the correct tools?
11:37:04 <Cale> tux_mark_5: My point about bringing up Maxwell's laws is really just to try to force you to realise that the state machine description of our architecture is an abstraction in the first place, and that there's actually a "declarative" layer beneath that, which of course is another abstraction itself.
11:37:10 <hpc> jmcarthur: of course! OOP forever! :D
11:37:31 <tux_mark_5> i get what you are trying to say
11:37:32 <josiah14> Cale: yah, I'm learning Haskell as an intro to functional programming because I know its a pure functional language
11:37:40 <Cale> tux_mark_5: Statefulness is a property of our description of the behaviour of something, not of the thing itself.
11:37:45 <kmc> is it troll hour again
11:37:54 <josiah14> i figure, though, I'll probably move to prefer clojur once I get the hang of it
11:38:01 <tux_mark_5> but the problem is that most of libraries, OSeses and other software is one way or another OOP/imperative
11:38:12 <kmc> Haskell is a fine imperative language
11:38:25 <Cale> tux_mark_5: Sure, there is a problem there, but we *do* manage imperative stuff pretty directly and nicely.
11:38:34 <pyf> monochrom: i've annoted the hpaste with them here:  http://hpaste.org/paste/45073/cabal_install_problem_annotat#p45074      thank you!
11:38:35 <tux_mark_5> but not all of it :/
11:38:39 <jmcarthur> like what?
11:38:41 <Cale> All of it.
11:38:53 <Cale> Well, all of C.
11:38:56 <tux_mark_5> ;D
11:39:10 <Cale> Which is all you'd expect from any language in that regard.
11:39:13 <jmcarthur> it's been said before, and i agree with it, that haskell is one of the finest imperative languages
11:39:36 <monochrom> "the language is not the carrier of the message. the language is the message." - Sapir McLuhan
11:39:38 <Cale> and we have our own way of writing code in an imperative style, with varying levels of purity and analysability
11:39:49 <tux_mark_5> wel, yeah, haskell does handle imperative code pretty wel
11:39:52 <josiah14> wow
11:39:54 <Cale> You can even make it really convenient.
11:40:14 <tux_mark_5> ;D
11:40:20 <Cale> But we try not to write our code imperatively, because that's not really a good way to write most programs.
11:40:24 <josiah14> Haskell looks a lot like how I'd write proofs in my discrete math classes
11:40:29 <Cale> josiah14: :)
11:40:35 <Jafet> kmc: today features interesting ones like "why do you all dislike OOP? OCaml is OOP!"
11:40:40 <Cale> josiah14: Functions in Haskell are honest to goodness functions.
11:40:54 <Cale> josiah14: Supply the same parameters, get the same result.
11:41:01 <Cale> Makes testing really cool.
11:41:02 <kmc> Jafet, it's true that there are a lot of anti-OOP strawman arguments here
11:41:06 <josiah14> that would be rly good for parallel computing, since you get around all the messiness of states
11:41:09 <ddarius> Honest to goodness partial functions.
11:41:13 <Cale> josiah14: That too!
11:41:28 <Cale> Haskell has some of the best support for concurrency and parallelism of any language out there.
11:41:29 <monochrom> "IO is not the recipe of the action. IO is the action." - antikmc McLuhan :)
11:41:34 <josiah14> thats pretty damn cool
11:41:35 <tux_mark_5> i'm strong believer that no pure concept is the way to go ;)
11:41:43 <jmcarthur> tux_mark_5: then why are you here?
11:41:46 <kmc> needs more cake
11:41:48 <Cale> tux_mark_5: Well, you're just wrong, what can I say? :)
11:41:51 <tux_mark_5> :D
11:42:01 <Jafet> kmc: and "how do I get the internal GHC representation of lists? I need this to do OOP with dbus"
11:42:07 <kmc> hahaha
11:42:14 <kmc> the answer is "vacuum" of course
11:42:14 <tux_mark_5> ;D
11:42:19 <Cale> tux_mark_5: There are so many cases where purity is so incredibly helpful.
11:42:29 <kmc> anyway i recommend less arguing about Haskell vs. FooLang, and more learning and using both
11:42:32 <tux_mark_5> well, i agree with that
11:42:39 <jmcarthur> tux_mark_5: http://www.nizkor.org/features/fallacies/middle-ground.html
11:42:47 <Cale> Almost all of every program can be pure, and it makes it much easier to analyse the behaviour, test it, and get it right in the first place.
11:42:55 <Cale> It makes types mean a whole lot more.
11:43:01 <monochrom> there is no learning possible if someone keeps whining about 50MB executables.
11:43:10 <Cale> It cuts debugging time to something like a tenth of what it otherwise would be.
11:43:12 <kmc> there's a lot of blog-noise about "debunking the haskell myth" from people who started learning haskell roughly one week ago
11:43:43 <josiah14> hows the speed compare to C?
11:43:57 <monochrom> or other historical accidentalities such as "my cpu has registers"
11:43:59 <AK_> Hello
11:44:15 <jmcarthur> josiah14: usually within the same order of magnitude, but slower. if you massage it a bit you can get really close though, and you can certainly get competitive speeds with a lot less work
11:44:17 <tux_mark_5> monochrom: 50 MB is true actually
11:44:20 <pyf> monochrom: do you know what the problem is?
11:44:32 <tux_mark_5> for me Qt is the best GUI toolkit, because i could write a nice looking GUI app in minutes
11:44:54 <tux_mark_5> i can't say the same (right now) about any other language/library combo
11:45:09 <josiah14> this is rly cool, im having fun with it already.
11:45:09 <kmc> desktop GUIs are the absolute ass end of the software industry
11:45:18 <jmcarthur> being the best crap doesn't mean it's not crap :P
11:45:28 <josiah14> hows OCaml?  I heard that can be pretty fast, but I dont see much around about it
11:45:34 <tux_mark_5> so what, HTML5 is the way to go? :D
11:45:39 <Cale> josiah14: Well, GHC produces in the best case quite competitive code. In the average, not-trying-so-hard case, it can a single-digits, to factor of 10 off pretty easily. On the other hand, it can be possible to write code which is faster than you'd get in C by accomplishing implementations of more sophisticated algorithms.
11:45:46 <jmcarthur> josiah14: less pleasant, IMO. also, you can make faster haskell code without much effort
11:45:54 <kmc> josiah14, GHC is a good compiler.  simple idiomatic haskell code will typically be slower than C but will take 10% as long to write and debug
11:46:02 <kmc> then if you really need speed you can tweak it
11:46:06 <tux_mark_5> desktop software will be forever there, because one still needs drivers, servers, OSes and so on
11:46:27 <jmcarthur> tux_mark_5: the way to go is with a better GUI lib (which we don't have yet)
11:46:44 <hpc> why do drivers depend on the existence of desktop software?
11:46:48 <Cale> tux_mark_5: I can write a pretty nice looking Gtk2Hs program in minutes. I can even use Glade to design the UI and then attach code to it.
11:47:01 <tux_mark_5> the better gui lib right now is Qt and sadly, as i've mentioned, qtHaskell doesn't do well with binary sizes
11:47:19 <jmcarthur> why is it such a big deal, anyway?
11:47:23 <Cale> Gtk2Hs is probably a good bit nicer to use than GTK 2
11:47:38 <tux_mark_5> size is always a big issue ;)
11:47:43 <jmcarthur> not to me
11:47:50 <Cale> because despite it being considered kind of a low-level binding by Haskell standards, there's actually quite a lot which it does to abstract things.
11:48:11 <kmc> size is a big issue if you want to troll GHC users
11:48:16 <josiah14> would Haskell be useful in writing programs for, say, a dual core ARM Cortex A9 microcontroller?
11:48:25 <jmcarthur> josiah14: there are DSLs for that :)
11:48:30 <jmcarthur> oh ARM
11:48:32 <tux_mark_5> i'm trying to force devs to look into this issue
11:48:34 <josiah14> if i could find a way to interpret that
11:48:37 <hpc> there's also cross compilers
11:48:39 <jmcarthur> you could get away with real haskell with the right compiler then
11:48:39 <tux_mark_5> as far as i know there is a bout about that
11:48:44 <tux_mark_5> *bug
11:48:48 <Cale> josiah14: We're using GHC to compile code for iPhones at the company I work for.
11:48:52 <monochrom> pyf: you need to "ghc-pkg unregister --user haskell98-1.1.0.1" and "ghc-pkg unregister --user process-1.0.1.5"
11:48:52 <tux_mark_5> something to do with hs_init_root or something
11:48:53 <jmcarthur> tux_mark_5: you aren't going to force anybody to do something that nobody cares about
11:48:54 <hpc> tux_mark_5: "forcing" devs into doing something will only make them hate you
11:48:56 <Cale> josiah14: It takes some extra rigging.
11:48:57 <hpc> tux_mark_5: please stop
11:48:59 <Cale> josiah14: But it works.
11:49:04 <josiah14> thats wicked
11:49:26 <tux_mark_5> maybe force is too strong word ;)
11:49:46 <tux_mark_5> anyway, how this is related to that "hs_init_root" thing?
11:50:01 <tux_mark_5> i've noticed a ticked filed a few years ago
11:50:06 <josiah14> i work pretty often with embedded stuff, and its going dual core, especially in robotics,  this sort of programming could be useful
11:50:19 <pyf> monochrom: should I override this? : ghc-pkg: unregistering process-1.0.1.5 would break the following packages: Cabal-1.8.0.6 (use --force to override)
11:50:19 <pyf>  
11:50:22 <hpc> tux_mark_5: nobody mentioned hs_init_root
11:50:27 <Cale> I don't know what hs_init_root is.
11:50:30 <tux_mark_5> wait, i'll find the ticket
11:50:32 <Cale> There's an hs_init
11:50:44 <Cale> which is part of the C side of the Haskell FFI
11:50:58 <Cale> used to initialise the Haskell runtime (the garbage collector, etc.)
11:51:09 <TomMD> Is there a way to add a TVar finalizer?
11:51:26 <Cale> TomMD: I don't think there is.
11:51:29 <monochrom> pyf: well then, "ghc-pkg unregister --user Cabal-1.8.0.6" first.
11:51:50 <Cale> TomMD: That would kinda break the nice clear semantics of STM...
11:52:10 <TomMD> All I can see is an unsafe hack-job of unsafeIOToSTM use of 'addFinalizer' - as you say, that breaks semantics.
11:52:15 <monochrom> whatever way you install Cabal-1.8.0.6, it ought not bring in yet another copy of process-1.0.1.5 just to shadow the global one you already have.
11:52:18 <Fuco> when I have a function Data.Map.member, it takes two arguments. I want to compose it with not, but it's not possible, because "M.member applied to too few arguments"
11:52:27 <Fuco> is there some whay I can compose them?
11:52:50 <tux_mark_5> hpc: it has something to do with __stginit
11:53:08 <Saizan> ?type Data.Map.member
11:53:09 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Bool
11:53:29 <monochrom> pyf: I would also like to have a copy of your ~/.cabal/logs/build.log so I may know how to get to such an erroneous state to begin with. it shouldn't be possible.
11:53:35 <Saizan> Fuco: so, you want \k m -> not (M.member k m)
11:53:42 <Fuco> yea
11:53:51 <tux_mark_5> hpc: where was a bug related to executable size & quasiquoting
11:53:57 <Cale> TomMD: Do you have to unsafeIOToSTM that? Couldn't you add the finaliser after the transaction?
11:54:08 <tux_mark_5> hpc: and it was somehow related to hs_add_root(__stdinit_*);
11:54:11 <Saizan> Fuco: which is equal to \k -> not . M.member = (not .) . M.member
11:54:13 <pyf> monochrom: thanks for helping. give me a minute.
11:54:14 <hpc> tux_mark_5: i don't care; you have to explain how it is relevant to anything that has been said before
11:54:17 <Fuco> I was hoping I can somehow get rid of arguments
11:54:19 <hpc> tux_mark_5: you mentioned it, not me
11:54:25 <hpc> tux_mark_5: and i didn't even ask what it was
11:54:29 <tux_mark_5> ????
11:54:37 <Saizan> Fuco: oops, \k -> not . M.member k = = (not .) . M.member
11:54:52 <Fuco> what is (not .) ?
11:54:57 <hpc> :t (not .)
11:54:58 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f Bool
11:55:28 <hpc> Fuco: (not .) = \f -> (not . f)
11:55:45 <Fuco> hmm
11:55:49 <hpc> > (2 *) 4
11:55:50 <lambdabot>   8
11:56:11 <Cale> Fuco: If that type signature scares you, the usual type would be (a -> Bool) -> (a -> Bool)
11:56:29 <Cale> (but lambdabot has some generalisations in it :)
11:56:47 <Fuco> so it takes a bool function and produce another bool function
11:56:49 <Fuco> makes sense
11:56:50 <Cale> yeah
11:56:58 <Fuco> it's like partial application when you do (1+)
11:56:59 <Cale> by composing it with not
11:56:59 <Fuco> I see
11:57:03 <Cale> mhm
11:57:04 <Cale> exactly
11:57:21 <frerich_> Is there an existing function like 'count x l = length $ filter (x==) l'? I'm always thinking there must be some ready made thing when writing functions like this.
11:57:30 <Cale> frerich_: not that one
11:57:40 <Fuco> :t (not .) . M.member
11:57:41 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Bool
11:58:06 <Cale> frerich_: length . filter (x==) is pretty short though ;)
11:58:22 <Fuco> so this partially apply k to M.member and then compose it with (not .) and apply that to map?
11:58:54 <frerich_> Cale: Yes, true. I just also realized I could use function composition here. One question about that: is 'count x = length . filter (x==)' point free, or should the 'x' go away for that, too?
11:59:19 <Cale> frerich_: Well, it's a bit more point free than the one with l :)
11:59:20 <jmcarthur> it's "more" point free, but not completely
11:59:22 <Fuco> we did this unpl<->pl stuff in class but it was a long time ago ;d
11:59:28 <Fuco> I should look into it again
11:59:29 <Cale> But you could make the x go away too
11:59:34 <jmcarthur> point free is only worth it if it's worth it
11:59:41 <pyf> monochrom: ok, (last few hundrew lines of) the log is here http://hpaste.org/45079/buildlog (i could post the whole thing, if you like, but it's v long)
11:59:49 <jmcarthur> @pl count x l = length $ filter (x==) l
11:59:49 <lambdabot> count = (length .) . filter . (==)
11:59:50 <Cale> @pl \x -> length . filter (x==)
11:59:50 <lambdabot> (length .) . filter . (==)
11:59:50 <Fuco> jmcarthur: it's a nice obfuscation ;D
11:59:57 <jmcarthur> i like point free
12:00:05 <Cale> Here's another case of (f .) . foo
12:00:07 <TomMD> Cale: yes, I could.  That just means my users have to use an IO action instead of an STM action.  Not sure if that is too much of a drawback.  I'm still thinking on it.
12:00:11 <frerich_> jmcarthur: I always thought the hype about point free was odd but slowly I find that point free looks very 'slick'
12:00:24 <frerich_> jmcarthur: It seems to reduce definitions to the bare minimum, the relationship between functions.
12:00:26 <jmcarthur> the way i usually approach things, if a point free definition is hard to read then there's another combinator that needs to be written
12:00:29 <TomMD> If it's the only way then obviously it's the only way - I'm just trying to think of alternatives.
12:00:38 <jmcarthur> frerich_: i agree
12:01:01 <Fuco> I think I get it
12:01:12 <Eduard_Munteanu> @pl \a b c -> c a b
12:01:12 <lambdabot> flip . flip id
12:01:13 <TomMD> Making a global STM and shoving finallizer requests into that STM for a reader thread executed at start up would be one, but I'm not supporting that as a better idea
12:01:14 <frerich_> Err
12:01:17 <Fuco> you just have to realize how the partial application works and how it eats arguments ;P
12:01:23 * frerich_ tries to grok 'filter . (==)'
12:01:27 <jmcarthur> frerich_: i like to think about my code as a series of transformations. i don't care to bother with clumsy things like naming the inputs and intermediates!
12:01:27 <pyf> monochrom: i get a different error now when i try to install glib. it says i need to install gtk2hs-buildtools, but that doesn't seem to sort the problem. the output is here: http://hpaste.org/45078/new_problem
12:01:31 <ddarius> jmcarthur: count x l = length (filter (x==) l).  Hmm...  count = count' where count' x l = length (filter (x==) l), aha!
12:01:40 <jmcarthur> ddarius: :(
12:01:47 <monochrom> pyf: Oh, so you did the like of "cabal install --force haskell98-1.1.0.1"? that's a no-no, you should almost never do that.
12:01:57 <Cale> Fuco: so, (not .) . M.member will apply the function (not .) to the function which is the result of M.member, which is the function that looks up whether the specified key is in any given map.
12:02:16 <ddarius> jmcarthur: Have you experimented much with J and concatenative languages like Joy?
12:02:22 <Cale> Fuco: So yeah, if we partially apply this to some key...
12:02:33 <Cale> ((not .) . M.member) k
12:02:43 <Fuco> M.member k m is (M.member k) m right? So it's (not.) . (M.member k) m
12:02:45 <Cale> -> (not .) (M.member k)
12:02:48 <Fuco> yea :)
12:02:54 <monochrom> pyf: edit PATH to contain $HOME/.cabal/bin .  that's were all the executables are installed when you "cabal install"
12:02:54 <Cale> -> not . M.member k
12:03:07 <Fuco> thanks!
12:03:11 <Cale> Fuco: almost had it right there
12:03:16 <jmcarthur> ddarius: not enough J to give it justice, and not Joy at all
12:03:17 <Fuco> yea, extra .
12:03:41 <Cale> yeah
12:03:47 <monochrom> s/were/where/
12:03:55 <Fuco> btw, J is awesome language :)
12:04:00 <ddarius> J is fun, but you have to memorize enough of the combinators before it starts flowing.
12:04:05 <Fuco> yea
12:04:12 <Fuco> but there's only 400 or so :D
12:04:20 <Cale> J is fun, but I wish they'd just named everything sanely.
12:04:26 <jmcarthur> i would probably like the J model more than Joy's model, but yeah, as with any point free programming, the combinators make quite a curve
12:04:32 <Cale> It's kind of unnecessarily terse.
12:04:38 <monochrom> you can put on your résumé or CV "Languages: C/C++, J/Java/Javascript"
12:04:42 <Cale> lol
12:04:44 <Fuco> well, in the spirit of APL I guess
12:04:55 <Cale> Languages: C, C++, C/C++
12:04:59 <jmcarthur> i'm not a huge fan of having to think about a "stack" while programming, like i'm pretty sure Joy has
12:05:06 <Cale> http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html
12:05:12 <Fuco> A,B,C,D,E,I,J,K,R,S,Q,W
12:05:17 <jmcarthur> i probably do that implicitly anyway with point free programming, though
12:05:21 <Fuco> I might have mixed Q in wrong position
12:05:29 <ddarius> jmcarthur: Indeed.
12:05:33 <jmcarthur> at least once i am doing multi-argument functions in point free style
12:05:33 <Fuco> I think there's also Z
12:06:16 <Cale> http://www.cpax.org.uk/prg/portable/c/c++/rfe00003.html -- there's some examples of C/C++ code here
12:06:16 <monochrom> B/VDM/Z
12:06:18 <Cale> lol
12:06:46 * frerich_ notices he usually writes pointy functions first, then temporarily rewrites to point free (followed by admiring his latest gem), then reverting to pointy again because he's afraid that he won't be able to understand the point free version two days later.
12:07:06 <Fuco> I love the underscores :D
12:07:10 <jlouis> I sometimes write the point free variant if it is rather simple
12:07:13 <Cale> When it gets to the point of writing (f .) . g, I usually back off a bit
12:07:20 <monochrom> I write pointy functions first too. It's fine as long as you strive to improve later.
12:07:23 <Cale> But I'll naturally write things in terms of compositions the first time
12:07:26 <jlouis> Cale: yeah, some here
12:07:31 <jlouis> same*
12:07:43 <Cale> Occasionally, I'll use the function monad or applicative, if it suits my thinking
12:07:51 <monochrom> comments are for explaining to yourself
12:08:13 <Fuco> @pl \x y z -> f (g x y z)
12:08:13 <lambdabot> ((f .) .) . g
12:08:19 <Fuco> oh, right
12:08:47 <pyf> monochrom: thank you for helping out with it, it works now. 
12:08:58 <ddarius> Ideally, comments should be explaining -what- the code is doing, only why it is being done this way as opposed to another way (if there is another simpler way, that was rejected for some reason.)
12:08:59 <jmcarthur> (fmap . fmap . fmap) f g
12:09:08 <ddarius> s/should/should not/
12:09:31 <monochrom> I think programmers are too obsessed with source code and not utilize comments enough. Come on, you call it *code*, which dictionary says code is supposed to be comprehensible?
12:09:35 <aristid> ddarius: and what it is doing should be clear from the code itself
12:09:42 <ddarius> aristid: Yes.
12:09:45 <jlouis> I don't shy away from an overview comment for the module if it is large and complex
12:10:11 <Cale> Rather than (f .) . g, I will *sometimes* use fmap f . g
12:10:16 <Cale> If that makes sense to do
12:10:44 <Cale> Depends which level of functions I'm really thinking on :)
12:11:01 <aristid> Cale: well you COULD use f .: g
12:11:12 <monochrom> If you starting calling it your source dissertation, that's different.
12:11:17 <Cale> If I wanted to introduce a new definition for it
12:11:25 <MHD0> Is that C/C++ language a joke?
12:11:36 <aristid> MHD0: it does not exist
12:11:47 <Cale> MHD0: Yes, it was invented just to deal with people who ask questions about C/C++
12:11:49 <aristid> there are two languages: c and c++
12:12:12 <Cale> aristid: Well, there are those requests for enlightenment
12:12:17 <Cale> http://www.cpax.org.uk/prg/portable/c/c++/
12:12:32 <Cale> and an interpreter
12:12:33 <MHD0> I know, and C/C++ means C++ that supports extern "C" {
12:12:35 <Fuco> :t fmap
12:12:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:12:41 <Fuco> oh... @_@
12:13:06 <aristid> Cale: wtf
12:13:24 <aristid> MHD0: no. C++ always supports extern "C".
12:13:34 <frerich_> monochrome: In my experience, consider introducing a dedicated function (so that you gt a chance to introduce a new name) or improve existing names whenever you feel the urge to add a comment explaining what is going on. If you feel that urge, it means your code is hard to read, so try to make it self-documenting.
12:13:55 <MHD0> aristid: Oh, right. I meant that.
12:14:26 <monochrom> I am precisely attacking self-documenting.
12:14:37 <frerich_> monochrome: Otherwise, a comment explaining *what* is happening is actually kind of duplication of information (violates the DRY principle) so it's prone to the usual problems with duplicated information (like, the comment may become out of date as the code changes).
12:14:53 <aristid> frerich_: i give you bonus points for saying "monochrome"
12:14:54 <monochrom> oh, some code doesn't need explanation, of course.
12:14:59 <Cale> aristid: It's a joke which was started by people on the relevant newsgroups who were tired of answering questions about C/C++ with "there's no such language".
12:15:06 <frerich_> aristid: Oops, sorry.
12:15:18 <frerich_> aristid: The tab completion in this IRC client is a pain :)
12:15:23 <aristid> Cale: but now those people who say "there's no such language" are wrong :(
12:15:36 <jmcarthur> an example of a good comment, IMO, is a derivation of your current implementation from a previous, simpler implementation
12:15:39 <Fuco> what would be the *normal* type of (. g)
12:15:44 <Fuco> or what does it do?
12:15:44 <ddarius> frerich: Go to a channel with less people.
12:15:48 <monochrom> yes, what jmcarthur says.
12:15:53 <ddarius> monochrom: Specifications can also say what the code does, but specifications should not be comments.  In the worst case, they should be documentation which is what you read when you don't want to or can't look at the code.
12:16:09 <aristid> Fuco: depends on the type of g.
12:16:17 <aristid> :t (. undefined)
12:16:17 <Cale> aristid: They were right at the time. The language exists now, by popular demand! ;)
12:16:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f b
12:16:26 <monochrom> specification should appear in external documentation, yes.
12:16:28 <aristid> :t (Prelude.. undefined)
12:16:29 <lambdabot> forall b c a. (b -> c) -> a -> c
12:16:38 <Fuco> if (g .) = \f -> (g . f)
12:16:40 <Cale> (looks quite different from C and C++ though)
12:16:42 <aristid> Cale: supply finds demand
12:16:48 <Fuco> than (. g) is \f -> (f . g) ?
12:17:02 <aristid> Fuco: yes.
12:17:21 <monochrom> specification should also appear in comments (internal documentation) when it is necessary to sketch out how to transform that specification to the final implementation step-by-step.
12:17:24 <Jafet> Fuco: that's pretty much a definition for operator sections.
12:17:34 <jmcarthur> what would be nicest would be a way to give the specification for the externally visible documentation, then give a compiler checked derivation from the spec to the implementation. there are some existing systems for that sort of thing, but thay are kind of complex and not well-studied
12:17:44 <ddarius> jmcarthur: Indeed.
12:17:50 <monochrom> (well, unless you have hyperlinks available)
12:17:51 <Cale> It has a _phw keyword for printing "Hello, World!"
12:17:58 <Fuco> I just tried this random function
12:17:58 <Fuco> @pl \a b c -> f a (g b c)
12:17:58 <lambdabot> (. g) . (.) . f
12:18:01 <MHD0> I am utterly baffeled by the fact that "pointerPosition $= ps" calls the motionCallback in GLUT.
12:18:05 <Fuco> and I'm figuring out how to do it by hand
12:18:06 <Fuco> :P
12:18:12 <MHD0> That has eluded me for like a week
12:18:17 <MHD0> Damn
12:18:33 <Cale> MHD0: Should it not?
12:18:49 <Cale> It seems kinda natural that it would...
12:18:51 <MHD0> Cale: Not when called inside the callback itself I think...
12:19:02 <Cale> ah, hmm
12:19:13 * frerich_ wishes they would teach stuff like comments or debugging at the university instead of focussing on composing algorithms  so much
12:19:14 <MHD0> I was chasing weird bugs in that code for like three weeks before it stuck me tonight.
12:19:39 <MHD0> I even suspected lazy evaluation of some sort...
12:19:57 <Cale> It's almost never the evaluation order
12:19:58 <monochrom> {- apply fusion law to <a href="specification.html">the specification</a> to obtain the following code -} is pretty much the only way you can avoid repeating the specification in comments.
12:20:35 <Cale> The only difference between lazy evaluation and strict evaluation is performance, and the fact that some programs finish successfully under lazy evaluation which would otherwise take forever under strict evaluation.
12:20:49 <Cale> You can't really observe it happening.
12:20:50 <jmcarthur> Cale: and space behavior :\
12:21:02 <monochrom> Cale, I object against "strict evaluation"
12:21:06 <Cale> I guess I was lumping that into performance
12:21:07 <ddarius> jmcarthur: That usually falls under "performance."
12:21:11 <jmcarthur> ah
12:21:32 <Cale> monochrom: Would you prefer "eager"?
12:21:53 <monochrom> I know one evaluation order that gives you the denotationally strict semantics, yet if you use it for "seq" in foldl' you absolutely save nothing.
12:22:01 <jmcarthur> MHD0: is this to implement some sort of pointer-locking scheme?
12:22:09 <monochrom> yes explicitly "eager evaluation".
12:22:18 <monochrom> lazy vs eager. non-strict vs strict.
12:22:24 <jmcarthur> MHD0: i think GLUT has something in its interface just for that, if so
12:22:30 <MHD0> jmcarthur: Yes, so that I can have pointer motion affect a virtual pointer inside the scene
12:22:38 <Cale> monochrom: I hesitate to use "eager" for that, because I've seen it used to refer to some non-strict evaluation mechanisms.
12:22:52 <c_wraith> eh.  strict -> eager, lazy -> non-strict
12:23:06 <c_wraith> They're not fully independent.
12:23:10 <jmcarthur> monochrom: what evaluation order is that?
12:23:35 <c_wraith> The fun one is non-strict but eager. :)
12:23:52 <monochrom> to evaluate "seq x y", evaluate y first, withold the result, go evaluate x, now come back to report the result of evaluating y.
12:24:15 <monochrom> foldl' using that order is completely pointless.
12:24:24 <monochrom> yet you can still call it "strict evaluation"
12:24:35 <Cale> It's not completely pointless
12:24:58 <monochrom> you are right that "eager" may not be specific enough, but "strict" is even more vague.
12:24:58 <jmcarthur> monochrom: actually, isn't our implementation of seq allowed to do that anyway?
12:25:10 <Cale> In fact, it's perfectly acceptable in a lot of cases, since it'll still prevent stack overflow.
12:25:19 <Cale> It is allowed to and sometimes does do that.
12:25:20 <jmcarthur> pseq is the only one specified to actually evaluate x first
12:25:38 <jmcarthur> oh i guess that's what you are getting at
12:25:38 <c_wraith> I figured the only time seq does that is when y is a subexpression of x
12:25:39 <monochrom> if it is allowed, then stack overflow is also possible, yet no one has observed stack overflow yet.
12:25:48 <Kaidelong> how'd something be non-strict but eager?
12:26:05 <Kaidelong> can you safely conflate speculative parallelism with eager evaluation?
12:26:16 <c_wraith> Kaidelong: eager evaluation in parallel, returning as soon as an answer is found.
12:26:25 <monochrom> oh actually my example shows stack overflow when -O, yes, it is observed.
12:26:49 <Cale> Kaidelong: I've just seen "eager" used to refer to certain kinds of optimistic evaluation mechanisms, which tried their best to do things innermost-first, but would back off if they started losing hope about termination.
12:26:51 <monochrom> but it is firstly corner-case and secondly even you call it a bug, meaning you reject it anyway.
12:27:09 <Kaidelong> so then eager is just a vague word
12:27:23 <Cale> We could decide not to worry about those...
12:28:03 <monochrom> I have coined "crazy evaluation" for the parallel strategy to do non-strict. It goes nicely with "lazy evaluation", and it is a faithful description IMO :)
12:28:17 <monochrom> (as crazy as a fork bomb :) )
12:28:32 <Kaidelong> I'm sure you could figure out a disciplined way to do it
12:28:45 <Cale> Try to reduce every node of the expression in parallel?
12:28:55 <Eduard_Munteanu> I suppose speculative evaluation should preserve lazy semantics. For example, if the RTS happens to speculatively evaluate an 'undefined' where it shouldn't, it shouldn't produce an error, right?
12:29:09 <Cale> Eduard_Munteanu: right
12:29:34 <Cale> See, and here monochrom will shout at you again for saying 'lazy semantics' instead of 'non-strict semantics'
12:29:37 <ddarius> Incidentally, executable specifications are the quintessential case of self-documenting code.
12:30:37 <ddarius> I don't think code should be self-documenting insofar as I don't think the code should be the documentation, except in the particular case where the code is exactly the specification.
12:30:38 <Kaidelong> ddarius: but the specification may be as cryptic and difficult to understand as a program
12:30:43 <Cale> But I kinda think it's okay to say X semantics whenever X is an evaluation strategy to refer to the semantics arising from that strategy.
12:30:48 <ddarius> Kaidelong: Indeed.
12:31:17 <Fuco> what is the priority of . operator>
12:31:24 <Fuco> no, wrong question
12:31:27 <ddarius> Kaidelong: The point is, though, if it is the specification, it is part of the public interface and should be in the documentation, and is thus self-documenting.
12:31:54 <Eduard_Munteanu> "lazy" is shorter, hence lazier :P
12:31:56 <Kaidelong> ah sure
12:32:09 <ddarius> Any other code potentially makes promises that aren't intended by the public interface and therefore should not be in the documentation.
12:32:18 <Kaidelong> and you could argue that "private" things really should be in a different module instead
12:32:37 <monochrom> the specification has presumably gone through some social process to have received negotiation, modification, and consensus that everyone agrees it's comprehensible.
12:32:38 <jmcarthur> it would be nice if haddock had a way for you to just say that you want a functions definition to be shown in the documentation
12:32:46 <jmcarthur> some functions are definitely simple enough to be their own documentation
12:32:59 <frerich_> ddarius: Depends, is your definition of 'specification' that it documents the intent or the actual behaviour?
12:33:34 <jmcarthur> s/simple enough to be//
12:33:49 <jmcarthur> frerich_: ideally it should be both ;)
12:33:54 <Eduard_Munteanu> (don't mind me I was trying to fix my rxvt-unicode colors)
12:34:15 <monochrom> be monochrome. never worry about colors again.
12:34:32 <ddarius> jmcarthur: If the implementations make no promises beyond those provided by the public interface, then that's fine.  They are executable specifications.
12:34:42 <jmcarthur> frerich_: if the implementation doesn't actually satisfy the specification, then the implementation is wrong, not the specification
12:34:43 <Jafet> Use 70s terminals
12:34:51 <jmcarthur> i take that back
12:35:17 <jmcarthur> i'll just say that if the implementation doesn't satisfy the spec then you messed up
12:35:48 <jmcarthur> ddarius: yeah that's the idea
12:39:07 <monochrom> I should paste my example again, this time permanent rather than just 1-hour.
12:40:45 <frerich_> That's pretty academic. In practice, the specification documents the intent (so yes, it counts as documentation - but it's not public, because it doesn't necessarily reflect the published product). The program itself is a specification of the algorithm, unlike the specification it does not document the intent but the actual behaviour. What you usually call "documentation" is (unfortunately) usually a mixture of the intent and the
12:40:46 <frerich_> actual observable behaviour.
12:41:20 <frerich_> Talking about "executabls specifications" is a bit pointless, that's called a program.
12:41:47 <Jafet> Humpty Dumpty strikes again
12:41:48 * hackagebot Animas 0.1 - Updated version of Yampa: a library for programming hybrid systems.  http://hackage.haskell.org/package/Animas-0.1 (EdwardAmsden)
12:42:31 <jmcarthur> frerich_: i think your description unnecessarily muddies the waters
12:42:49 <monochrom> http://hpaste.org/paste/45080/funny_experiment_on_strictness#p45081
12:42:49 <Kaidelong> looks like the name edwardamsden.com has expired
12:43:48 <ddarius> frerich: An executable specification is indeed a program.  You can specify that a program behaves the same as another program.  That it is a program doesn't make it not a specification, and a program is a specification of -something- but it may promise more than the desired specification.
12:44:15 <ddarius> (And that is, of course, assuming that the program does meet the desired specification.)
12:44:16 <Kaidelong> monochrom: what, why!?
12:44:21 <jmcarthur> monochrom: bizarre!
12:44:42 <monochrom> probably because "we allow 'seq x y' to evaluate y first"
12:44:44 <frerich_> jmcarthur: I think it does if you have the definitions of Comp.Sci. in mind - but in day-to-day software engineerings, I think the definitions are different (in that you don't think about programs as specifications, a specification is a documentation of intent and requirement).
12:45:01 <monochrom> and people claim "either way there is no stack overflow". well here it is.
12:45:02 <jmcarthur> monochrom: ah, that may be it. should try that with a version of foldrl' using pseq
12:45:10 <jmcarthur> *foldl'
12:45:30 <ddarius> Indeed, pretty much all uses of seq should be uses of pseq.
12:45:43 <jmcarthur> frerich_: that definition sounds like a recipe for disaster though, *especially* in day-to-day engineering
12:45:49 * hackagebot repr 0.4.1 - Render overloaded expressions to their textual representation.  http://hackage.haskell.org/package/repr-0.4.1 (BasVanDijk)
12:45:51 <monochrom> yeah, I haven't tried pseq but it should work.
12:46:02 <ddarius> jmcarthur: Well, witness day-to-day software engineering...
12:46:23 <jmcarthur> ddarius: :(
12:46:46 <ddarius> frerich: Anyway, everyone here was talking about -formal- specifications.  It's extremely rare to come across formal "specification documents."
12:46:48 <jmcarthur> dijkstra was certainly unhappy with it
12:47:03 <Tomsik> Knuth also?
12:47:19 <jmcarthur> i haven't read much on knuth's take on software engineering
12:47:56 <hpc> someone should write a ghc extension that re-implements seq as pseq
12:48:04 <monochrom> But in other experiments (with less trivial data types, for example Bool --- two values not just one) seq does the desired thing at all optimization levels.
12:48:11 <ddarius> hpc: All you would have to do is shadow seq.
12:48:13 <hpc> call it ThreadedSeq or something
12:48:28 <hpc> ddarius: no, i mean for standard library stuff too
12:48:36 <hpc> so foldl' magically uses pseq
12:48:45 <jmcarthur> hpc: you mean go in and magically changed code that's already compiled? :P
12:48:49 <jmcarthur> *change
12:48:50 <davy> Hello all, i am a novice in Haskell and have behaviour i don't understand
12:48:52 <frerich_> jmcarthur: Disaster 
12:48:53 <frerich_> i
12:48:55 <frerich_> oops
12:48:55 * hpc shuts up lol
12:49:11 <monochrom> in day-to-day software work, there are a million different levels of specifications.
12:49:13 <davy> i am using the Parsec library to parse a simple format
12:49:16 <ddarius> hpc: All you would have to do is shadow seq early in the GHC libraries or simply not call it seq.  You don't have to "extend GHC" in anyway, and pseq is a perfectly correct implementation of seq.
12:49:36 <monochrom> "requirement specification", "design specification", "functional specification"...
12:49:39 <frerich_> jmcarthur: Disaster is probably pretty close to the truth, unsatisfactory in any case unless you decide that worse is better.
12:49:59 <jmcarthur> worse is better is worse
12:50:05 <jmcarthur> (IMO)
12:50:11 <frerich_> ddarius: Sorry, I missed that this was about formal specifications. I'd like to take my arguments back and claim the opposite.
12:50:20 <jmcarthur> :D
12:50:21 <monochrom> some of them are vague intents, sure. some other of them are precise and can be formalized.
12:50:22 <fryguybob> "Let us change our traditional attitude to the construction of programs. Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do." -- Knuth
12:50:24 <davy> Sometimes i have to use a $ symbol in the return part, and sometimes it isn't needed
12:50:32 <jmcarthur> i like formal specifications and i wish they were taken more seriously outside of academia
12:50:46 <davy> unfortunately i cannot find any information about it
12:50:52 <jmcarthur> davy: the reason is that return is just a function, not a key word
12:51:08 <jmcarthur> davy: so ($) tells it that you want everything to the right of it to be treated as a single parameter
12:51:26 <hpc> davy: ($) is a shortcut so you don't need so many parenthesis
12:51:28 <jmcarthur> davy: if there would be no need for parens, there should also be no need for ($)
12:51:41 <monochrom> there is nothing vague about "I want to sort an array of numbers by the < order". you could write it in Sanskrit or you could write it in formalized (symbolic) math.
12:51:55 <hpc> ($) also has some neat theoretical applications, but that's a totally different question to answer
12:51:55 <davy> So if i understand it well, i could wrap it in "(" and ")"?
12:52:00 <hpc> davy: yes
12:52:12 <jmcarthur> davy: instead of  return $ foo bar baz  you could say  return (foo bar baz)
12:52:30 <monochrom> whereas "I want the software to make me happy", sure, that's the vague, unformalizable one.
12:52:34 <jmcarthur> davy: but  return $ foo  is equivalent to  return (foo)  and to  return foo
12:52:40 <ddarius> monochrom: For that particular case, perhaps not, it depends on the definition of (<).  But even a slightly more general case, that specification becomes non-deterministic.
12:52:43 <frerich_> jmcarthur: So do I. I still frown at the idea of considering "software development" an engineering discipline. I bet most real engineers (building bridges and motorcycles and dishwashers) would laugh at the informal approach to making computers do stuff :-}
12:52:50 <ddarius> monochrom: Which is fine.
12:53:04 <monochrom> well yeah non-deterministic /= vague
12:53:06 <jmcarthur> frerich_: it is an engineering discipline. just not a very disciplined one :(
12:53:43 <monochrom> vague is "I want to be happy, I want more money" which doesn't really appear in day-to-day software work either. so much for "day-to-day specs can't be formalized"
12:54:00 <ddarius> monochrom: Though, I did point out one ambiguity.  Another is what does "number" mean?  Naturals, Int32, Integers, Complex numbers?
12:54:04 <hpc> frerich_: to some extent, it is a cost/benefit analysis; when you build a bridge, a mistake at the bottom costs hundreds of millions and a lot of embarassment, due to the nature of how it is built
12:54:17 <hpc> a software flaw can easily be fixed if the program isn't in production yet
12:54:24 <hpc> at least, more easily
12:54:26 <ddarius> monochrom: Uh, usually day-to-day specs are "the customer accepts the product."
12:54:38 <aristid> hpc: and ignoring that possibility would be foolish.
12:54:46 <jmcarthur> monochrom: read the daily wtf much?
12:55:03 <monochrom> well oops ok, but that kind of spec is just one in a long chain of more refined specs.
12:55:08 <jmcarthur> it shows bad code a lot, sure, but bad specs are also common
12:55:12 <ddarius> monochrom: In theory.
12:55:46 <davy> ok, thx guys, i am try to get it to work. Just for info: i made a snippet to describe my problem: https://gist.github.com/888572
12:55:53 <ddarius> Usually, that long chain is "the customer accepts the product" -> code.  Of course, that would imply that the code actually met the spec...
12:56:13 <frerich_> ddarius: That experience sounds depressing :(
12:56:29 <jmcarthur> http://thedailywtf.com/Articles/The_spec_0x3f__Plus_more_comments!.aspx
12:57:25 <jmcarthur> http://thedailywtf.com/Articles/Finally,_we_have_the_spec!.aspx
12:57:35 <ddarius> Okay, there may be one or two, maybe even three more levels, but usually only the code level is formal, maybe also "passes these regression/unit tests."
12:57:57 <ndrsndrs> davy: what type is Conjuction, and what are the types of the things you're passing to it
12:58:38 <davy> Conjunction is a constructor for the Expr data type and it receives a list of Expr
12:58:53 <davy> | Conjunction [Expr]
12:59:22 <ndrsndrs> So Conjunction :: [Expr] -> Expr, and the argument :: Parser [Expr]
12:59:50 <Spockz> how can I install an extra script next to my executable with cabal?
12:59:56 <ddarius> Here one could say that "formal" means that I can know that my code will meet the spec.
13:00:10 <ndrsndrs> so you need to transform an ([Expr] -> Expr) to a (Parser [Expr] -> Parser Expr)
13:00:35 <ndrsndrs> @hoogle (a -> b) -> (f a -> f b)
13:00:35 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
13:00:35 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:00:35 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
13:02:11 <frerich_> ddarius: FWIW, in practice you can even let your code be the spec to a degree (argh, here we are again) by managing customer expectations. Usually they don't really want what they ask for anyway. ;-)
13:02:14 <davy> ndrsndrs: i don't fully understand that 
13:02:29 <davy> but i think i understand my problem i bit more
13:02:38 <davy> Parsec works with Monads
13:03:01 <davy> A Monad has a bind and a return if im not mistaken?
13:03:28 <hpc> davy: yes
13:04:56 <davy> a monad can be typed as a do... return ... construction
13:05:00 <Kaidelong> a monad is an applicative functor with bind
13:05:05 <Kaidelong> err
13:05:10 <Kaidelong> with join
13:05:17 <Kaidelong> although you get join from bind anyway
13:05:36 <Kaidelong> but applicative functor with join is enough
13:05:49 <Saizan> i don't think davy knows what an applicative functor is anyhow
13:06:20 <davy> Kaidelong: sorry, i am really a novice, have to use Haskell for my Master Study 
13:06:25 <Saizan> davy: do-notation is syntactic sugar for the use of bind
13:06:35 <Kaidelong> good luck!
13:06:49 <Saizan> ?undo do x <- foo; y <- bar; baz x y
13:06:49 <lambdabot> foo >>= \ x -> bar >>= \ y -> baz x y
13:09:38 <ion> I recently thought of how to implement State as an applicative functor, with the Monad instance being implemented based on the Applicative instance. It seemed like the implementation was more complex that way than the other way around. Was i just being stupid/ignorant and implementing the applicative functor in a pessimal way?
13:11:57 <Saizan> it's just more work, i'd say
13:15:36 <outsid3r> how do i stop this?
13:15:38 <outsid3r> transpose :: [[a]] -> [[a]]
13:15:38 <outsid3r> transpose xss = head (foldr (\xs ys -> [(head xs):(head ys)]) [[]] xss) : transpose (map tail xss)
13:15:50 <outsid3r> how i check if xss is null ?
13:15:58 <ion> transpose [] = …
13:16:09 <outsid3r> but xss can be [[],[]]
13:17:20 <outsid3r> well, i can check for the first column only
13:18:40 <outsid3r> transpose xss = if length (head xss) > 0 then head (foldr (\xs ys -> [(head xs):(head ys)]) [[]] xss) : transpose (map tail xss) else []
13:18:42 <davy> Thank you, i read some more about monads. Just to make sure i understand it well:
13:18:48 <outsid3r> another better approach?
13:19:41 <ion> ‘length foo > 0’ traverses the whole list, ‘not (null foo)’ doesn’t.
13:20:17 <outsid3r> have you sure that it transverses ?
13:20:28 <outsid3r> the list probably has an internal flag that represents it's size
13:20:31 <outsid3r> so it's constant 
13:20:53 * hackagebot hquantlib 0.0.1.2 - HQuantLib is a port of essencial parts of QuantLib to Haskell  http://hackage.haskell.org/package/hquantlib-0.0.1.2 (PavelRyzhov)
13:21:08 <Saizan> it doesn't
13:21:16 <outsid3r> that's strange
13:21:30 <davy> let's say: sumTwoDice = rollDie >>= \die1 -> rollDie >>= \die2 -> return (die1 + die2)
13:21:39 <outsid3r> well, for some reason developers must have done this in this way
13:21:56 <davy> and: oneDie = rollDie >>= \die1 -> return die1
13:22:10 <ndrsndrs> outsid3r: it's just the same as 'data List a = Nil | Cons a (List a)'. apart from having funny names, it doesn't have any extra magic
13:22:24 <davy> these are ok afaik
13:22:43 <Saizan> davy: btw "m >>= \x -> return x" is exactly the same as "m", according to the monad laws
13:22:52 <outsid3r> what i meant was, the data structure inside can probably have a variable that represents it's size, i mean, it's internal structure written in C
13:22:54 <ion> davy: Yeah, although ‘f >>= \a -> return a’ can be said just as ‘f’.
13:23:04 <outsid3r> so length would return that value
13:23:11 <davy> is it somehow possible to do: oneDie = rollDie
13:23:25 <outsid3r> it's just more efficient
13:23:36 <Saizan> davy: yes, that's fine
13:24:05 <Saizan> outsid3r: length would be more efficient, everything else wouldn't
13:24:09 <davy> ok, i gained some understanding :)
13:24:22 <ion> Incidentally, i used dice as an example at the end in http://heh.fi/state-monad
13:24:25 <davy> but
13:24:35 <Saizan> outsid3r: also, it wouldn't work for infinite lists
13:24:39 <outsid3r> Saizan, yes
13:25:16 <Saul__L> Hi, shiuld I ask here or on #haskell-blah about changing Leksah GUI style/theme?
13:25:16 <outsid3r> how infinite lists work internally? 
13:25:22 <Saizan> consing an element to a list doesn't even need to look at the tail, currently
13:25:23 <outsid3r> they must have some kind of generator
13:25:29 <ion> A simple example: foo = 0:foo
13:25:51 <osoleve> > 0 : [1..10]
13:25:52 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
13:25:53 <ion> the : constructs a linked with 0 as the head and foo as the tail.
13:26:14 <ion> which points to the value (:) returned
13:26:44 <ion> > let foo = 0:foo in foo
13:26:45 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:27:02 <Saizan> a circular list is quite easy, something like iterate (+1) 0 requires more magic :)
13:27:50 <hpc> Saul__L: blah
13:28:12 <Saul__L> k, thxc
13:28:18 <Saizan> in this case the fact that the representation in memory of a list can simply be some code which when executed will produce the next element and tail
13:28:51 <outsid3r> hpc, i just wrote the sudoku checker to check if a board is valid, actually is just checkRows grid && checkRows (transpose grid) :P
13:29:12 <Kaidelong> > fix (:0)
13:29:13 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:29:13 <hpc> outsid3r: you also want to check the nine squares
13:29:16 <Kaidelong> > fix (0:)
13:29:17 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:29:18 <ddarius> frerich: Usually they don't really know what they want.
13:29:24 <outsid3r> hpc, oh, i almost forget that
13:29:50 <davy> if you have "z = m >>= \x -> return (SomeTypeConstructor x)" then you cannot do:  "z = (SomeTypeConstructor m)" can you?
13:30:02 <outsid3r> hpc, well, maybe convert the squares into lists of 9 elements, then  use checkRows 
13:30:15 <Saizan> davy: no
13:30:23 <outsid3r> it does not seem easy for me to convert a square into a list of 9 elements
13:30:44 <Saizan> davy: also, i hope you mean SomeDataConstructor :)
13:30:50 <ezyang> > (,,) <$> [1,2,3] <*> [4,5,6] <*> [7,8,9] 
13:30:51 <lambdabot>   [(1,4,7),(1,4,8),(1,4,9),(1,5,7),(1,5,8),(1,5,9),(1,6,7),(1,6,8),(1,6,9),(2...
13:30:53 <hpc> outsid3r: ooh, nice
13:30:59 <davy> Yes You are right :)
13:31:16 <ion> @pl m >>= return . Constructor
13:31:16 <lambdabot> Constructor `fmap` m
13:31:18 <outsid3r> hpc, any hint to do that ?
13:31:57 <hpc> outsid3r: (join . take 3 . map (take 3)) i think will do it for the first corner
13:32:03 <Saizan> davy: Control.Monad defined liftM f m = m >>= \x -> return (f x), so you can use "liftM Constructor m"
13:32:21 <outsid3r> idk join function
13:32:27 <hpc> outsid3r: that is, it will take the first three columns, then the first three rows, then concatenate them
13:32:33 --- mode: ChanServ set +o Saizan
13:32:38 <hpc> > join ["123","456","789"]
13:32:39 <lambdabot>   "123456789"
13:32:41 --- mode: Saizan set +b *!*funny-gir@*.grybow.net.pl
13:32:41 --- kick: SHE-IS-SMART was kicked by Saizan (SHE-IS-SMART)
13:32:47 <Saizan> spammer.
13:32:51 --- mode: Saizan set -o Saizan
13:33:00 <davy> Saizan: thx, i'm going to read about liftM
13:33:18 <outsid3r> yea but my teacher didnt teached join yet, so there must be another way, anyway ++ does the same isn't it?
13:33:27 <azaq23> n
13:33:31 <Boxo> liftM = fmap, btw
13:33:32 <azaq23> join is concat
13:33:35 <azaq23> @src concat
13:33:35 <lambdabot> concat = foldr (++) []
13:33:40 <hpc> outsid3r: join :: Monad m => m (m a) -> m a, but you can think of it as join :: [[a]] -> [a]
13:33:51 <Saizan> err, just use concat?
13:33:54 <outsid3r> idk monads yet
13:34:02 <Saizan> ?type concat
13:34:02 <lambdabot> forall a. [[a]] -> [a]
13:34:04 <gwern> > 8000000 * 140
13:34:05 <lambdabot>   1120000000
13:34:08 <hpc> outsid3r: you don't need to, for this; it's just concat ;)
13:34:13 <Saizan> and no, it's not the same as (++)
13:34:16 <outsid3r> yea
13:34:21 <gwern> > (8000000 * 140) / 1000
13:34:21 <lambdabot>   1120000.0
13:35:55 * hackagebot textmatetags 0.0.1 - A simple Haskell program to provide tags for Haskell code completion in TextMate  http://hackage.haskell.org/package/textmatetags-0.0.1 (AlessandroVermeulen)
13:36:57 * hackagebot textmatetags 0.0.1.1 - A simple Haskell program to provide tags for Haskell code completion in TextMate  http://hackage.haskell.org/package/textmatetags-0.0.1.1 (AlessandroVermeulen)
13:38:55 * hackagebot textmatetags 0.0.1.2 - A simple Haskell program to provide tags for Haskell code completion in TextMate  http://hackage.haskell.org/package/textmatetags-0.0.1.2 (AlessandroVermeulen)
13:40:18 <Spockz> sorry for the hackage bot spam
13:40:42 <josiah14> whats with the type syntax for functions
13:41:00 <josiah14> for instance :: (a->b)->[a]->[b] for map
13:41:19 <josiah14> how do i read that?
13:41:57 <Heffalump> -> is right-associative, so it's equivalent to (a->b)->([a]->[b])
13:42:08 <Heffalump> x->y is a function that takes an x and returns a y
13:42:24 <Heffalump> so map takes a function from a to b, and returns a function from [a] to [b]
13:42:42 <josiah14> ahah
13:42:46 <josiah14> that makes sense
13:42:55 <Heffalump> another way of looking at it is that map takes two arguments, first a function from a to b, then a [a], and finally returns a [b]
13:43:17 <geheimdienst> (this is probably the more intuitive way of looking at it)
13:43:58 <Saizan> it alsa says that map has to work in the same way regarless of what types you choose to instantiate a and b
13:44:21 <gwern> gah. 8 million times 140 bytes is... roughly 1 gigabyte?
13:44:46 <geheimdienst> > 8*1000*1000 * 140
13:44:47 <lambdabot>   1120000000
13:45:23 <Kaidelong> > 1024 * 1024 * 1024
13:45:24 <lambdabot>   1073741824
13:45:34 <Kaidelong> the answer is "yes"
13:46:04 <copumpkin> gwern: working with twitter data? :o
13:46:11 <geheimdienst> i wish the 1024 stuff would die already
13:46:13 <gwern> copumpkin: nah, just thinking about SMS burdens
13:46:16 <Kaidelong> > (8000000*140) - (1024 * 1024 * 1024)
13:46:17 <lambdabot>   46258176
13:46:18 <copumpkin> ah okay
13:46:26 <ion> A gigabyte is 10¹² bytes. A gibibyte is 2³⁰ bytes.
13:46:38 <Kaidelong> hmm? oh
13:46:40 <copumpkin> ion: not necessarily in common usage, though
13:46:49 <ion> Also, you’ll want to use the gigabyte almost always.
13:47:34 <lpsmith> Yeah, I appreciate the distinction,  but gibibyte is such a terrible name
13:47:50 <davy> Thank you all, great support! I understand it a bit more. Bye
13:47:54 <ion> Related: https://wiki.ubuntu.com/UnitsPolicy
13:47:57 <geheimdienst> terrible name for a terrible thing
13:48:08 <lpsmith> I don't think it's a terrible thing :)
13:48:32 <geheimdienst> why not use 1000 like the rest of the world?
13:48:34 <Kaidelong> I don't see the "correct" usage very often
13:48:41 <josiah14> what i hate is how companies that amke routers and such rip people by interchanging Gigabyte and Gigabit
13:49:12 <saiko-chriskun> hah
13:49:24 <gwern> it's hard for me to care very much when 2 terabytes retails for $60 or so
13:49:46 <josiah14> not the same when ur talking data transfer rates
13:50:05 <znutar> does anyone use gigabytes when talking routers?
13:50:07 <gwern> well, the telecoms screw you over in so many ways that th\at is not important
13:50:16 <lpsmith> hah!
13:50:22 <josiah14> haha, no kidding
13:50:24 <hpc> gwern: you realize what you are saying...
13:50:33 <hpc> gwern: that a factor of 8 is just a drop in the bucket
13:50:36 --- mode: ChanServ set +o monochrom
13:50:39 <josiah14> iv seen at least one company measure in gigabytes
13:50:49 <josiah14> it could have been a mistake
13:51:01 <gwern> hpc: sure. that's what, 3 turns of moore's law?
13:51:06 <josiah14> im sure the marketing people dont even know there is a difference
13:51:15 <lpsmith> gwern, you are from the UK, no?  How good/bad is it over there?
13:51:21 <gwern> lpsmith: I'm not
13:51:40 <hpc> this is getting off topic
13:51:43 <revenantphx> The whole gigabit vs gigabytes thing is obnoxious.
13:52:00 <revenantphx> But no one's going to buck the trend,
13:52:06 <revenantphx> because they'll look worse than their competitors.
13:52:26 <hpc> revenantphx: unless they advertise both numbers
13:52:31 <revenantphx> hpc: That's a good idea.
13:53:03 <znutar> also because it's weird and unnatural on the hardware side of things to start dividing by 8 in your units when you're talking about wiggling a single wire or differential pair or whatever
13:53:17 --- topic: set to '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]' by monochrom
13:53:18 <revenantphx> Someone should just advertise "20,000 kilobits per second vs competitors 20 mbits per second. The choice is obvious."
13:53:37 <hpc> revenantphx: why stop there?
13:53:45 <hpc> 100,000,000,000 electrons per hour!
13:54:00 <revenantphx> :O
13:54:00 <aristid> i like big numbers.
13:54:01 <revenantphx> egads!
13:54:02 <copumpkin> hpc: some might even say that's over 9000!111!!!
13:54:03 --- mode: monochrom set -b *!*@95.69.9.219
13:54:08 <revenantphx> copumpkin: go die.
13:54:10 <revenantphx> :P
13:54:19 <revenantphx>  /ban copumpkin
13:54:20 * copumpkin goes and dies
13:54:20 * jmcarthur watches some dragon ball kai
13:54:22 <revenantphx>  /kick copumpkin
13:54:25 --- mode: monochrom set -o monochrom
13:54:36 <burp> 9000 factorial, * 111 triple factorial? wow :D
13:54:44 <hpc> > 9000!
13:54:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:54:55 <hpc> lambdabot, why do you hate fun? :D
13:54:55 <revenantphx> hpc: put that into a lower base to make it look bigger :)
13:54:58 <copumpkin> if I were an ISP, I would definitely advertise in those terms
13:55:28 <geheimdienst> what terms? "omg over 9000!!1!" ?
13:56:31 <revenantphx> advertise in low-quality jpegs of kittens per second
13:56:52 <copumpkin> animated gifs
13:56:53 <revenantphx> jok/ps
13:56:55 <revenantphx> >_>
13:57:01 <revenantphx> (jpegs of kittens per second)
13:57:06 <revenantphx> the / is redundant.
13:57:27 <copumpkin> divided by per second
13:57:30 <copumpkin> is second
13:58:07 <Eduard_Munteanu> KiTtyBytes
14:01:20 <frerich_> Hmm, if I have two lists "abca" and "cbac", is it possible to compute a (bijective) function which maps elements of one list to the other? I guess a function which would yield e.g. [(0,2), (1,1), (2,3)] for these demo strings would suffice.
14:02:22 <frerich_> Hm, well, I already know it's possible - but I'd like to express it concisely in Haskell :)
14:03:21 <napping> That doesn't sound especially efficient
14:04:31 <Eduard_Munteanu> f = const "cbac"  :)
14:04:54 <hpc> :t const const const
14:04:55 <lambdabot> forall a b. a -> b -> a
14:04:59 <hpc> :t const const
14:05:00 <lambdabot> forall a b b1. b1 -> a -> b -> a
14:05:07 <hpc> :t const . const
14:05:08 <lambdabot> forall b a b1. a -> b -> b1 -> a
14:05:11 <napping> > (zip `on` (map snd . sort . flip zip [0..])) "abca" "cbac"
14:05:13 <lambdabot>   [(0,2),(3,1),(1,0),(2,3)]
14:05:17 <Eduard_Munteanu> When you look into what's supposed to be "abca", it'll go through its image instead.
14:05:36 <napping> wait, those strings don't have a bijection
14:05:58 <napping> you can see that function is not so safe
14:06:17 <napping> > (zip `on` (map snd . sort . flip zip [0..])) "abca" "cbaa"
14:06:19 <lambdabot>   [(0,2),(3,3),(1,1),(2,0)]
14:06:43 <Eduard_Munteanu> > head $ (const "cbac") "abca"
14:06:44 <lambdabot>   'c'
14:07:09 <Eduard_Munteanu> > head . tail $ (const "cbac") "abca"
14:07:11 <lambdabot>   'b'
14:07:32 <napping> The idea is to label each point with the index, then sort by value to bring corresponding elements together
14:08:12 <Eduard_Munteanu> Anyway, my point was those two already give you a bijection.
14:08:36 <frerich_> napping: I had a similiar idea but your version is so concise, I'm still trying to digest it. Too bad that it doesn't do what I want for "abca" "cbac".
14:08:36 <napping> if it's a bijection, it should have an inverse
14:08:58 <napping> frerich_: that pair doesn't have a bijection! there are 2 'a' in the first, 2 'c' in the second
14:09:00 <Eduard_Munteanu> It does, if you consider "abca" ~ zip [1..] "abca"
14:09:09 <Eduard_Munteanu> (which is the case since lists are ordered)
14:10:03 <frerich_> napping: Well the function can be partial, as long as it's bijective. E.g. in "abca" vs. "a", one of the 'a' in the first string is ignored (just like "bc").
14:10:18 <frerich_> napping: So either [(0,0)] or [(3,0)] would be ok
14:10:53 <napping> then bijection is not the right word
14:11:05 <napping> what do you want for "a" into "abca"
14:11:22 <napping> is it supposed to succeed in all cases?
14:11:33 <frerich_> Same thing. Either [(0,0)] or [(0,3)]. Either would be okay for me.
14:11:53 <frerich_> Well you could even have 'abc' vs 'def', which would yield an empty list.
14:12:20 <napping> so you really want it to identify the intersection, and give a bijection between those elements
14:12:41 <frerich_> napping: Perfectly possible that bijection is not the right word. I just wanted to express that "abca" vs "a" should not yield [(0,0), (3,0)] but just a list with either of those tuples as its only element.
14:13:01 <Eduard_Munteanu> I think you should clarify what it means for your "collection" to have duplicates, like in "abca".
14:14:23 <frerich_> Eduard_Munteanu: Euhm, I'm not sure I understand. Such a situation is perfectly possible (even "aaaa" mapped onto "aaaa")
14:15:52 <revenantphx> frerich_: Could you give some examples of inputs and outputs?
14:16:02 <napping> what do you plan to do with the pairs once you have them?
14:16:35 <revenantphx> if you have duplicates, it'd be a bit hard to have a bijection.
14:16:53 <revenantphx> so, I think napping is right, you want the bijection between the intersection and original.
14:16:56 <revenantphx> or something like that.
14:17:38 <frerich_> napping: I want to count the number of tuples where the first element equals the second (and I also need to know the number of tuples where the first element does not equal the second element).
14:17:46 <copumpkin> DRMacIver: I was wondering if your ncommandments site used something similar to my gaddafi name generator (using the list monad)
14:18:35 <hpc> haha, the n commandments! link?
14:18:50 <copumpkin> http://ncommandments.com/
14:18:53 <frerich_> napping: In my program, the two lists are always the same size.
14:18:54 * ddarius choose n = 0.
14:19:48 <hpc> magnificent
14:20:29 <ddarius> http://ncommandments.com/0
14:20:35 <napping> if you want to count the size of the intersection, that's easier
14:21:18 <Eduard_Munteanu> copumpkin: is you Gaddafi name gen somewhere online? :)
14:21:21 <Eduard_Munteanu> *your
14:21:23 <Saul__L> is there a way to change Leksah theme?
14:21:32 <frerich_> revenantphx: Sure. E.g. 'f "abcd" "abcd"' should yield '[(0,0), (1,1), (2,2), (3,3)]'. 'f "abcd" "dbca" should yield [(0,3), (1,1), (2,2), (3,0)]
14:21:37 <frerich_> revenantphx: The order of the tuples does not matter.
14:21:46 <Saul__L> on WIndows?
14:21:50 <revenantphx> right.
14:22:02 <revenantphx> what about say
14:22:06 <revenantphx> "abcd", "aabc"
14:22:28 <hpc> Eduard_Munteanu: i saved it somewhere
14:22:29 <copumpkin> > map concat $ sequence [["M"], ["u", "o"], ["", "'"], ["a"], ["m", "mm"], ["a", "e"], ["r"], [" "], ["al", "el", "Al", "El", ""], ["", " "], ["Q", "G", "Gh", "K", "Kh"], ["a", "e", "u"], ["d", "dh", "dd", "ddh", "dhdh", "dth", "th", "zz"], ["a"], ["f", "ff"], ["i", "y"]] -- Eduard_Munteanu 
14:22:29 <lambdabot>   ["Muamar alQadafi","Muamar alQadafy","Muamar alQadaffi","Muamar alQadaffy",...
14:22:33 <hpc> or that
14:22:39 <frerich_> revenantphx: [(0,0), (1,2), (3,4)] or [(0,1), (1,2), (3,4)]
14:22:49 <Eduard_Munteanu> Oh, heh.
14:22:53 <revenantphx> copumpkin: pfff
14:22:54 <frerich_> revenantphx: i.e. the 'a' in the first string could be mapped to either 'a' of the second. The 'd' has no match.
14:23:03 <revenantphx> frerich_: But it's ambiguous...
14:23:08 <copumpkin> I stole the data from the wikipedia page on gaddafi
14:23:09 <revenantphx> you need to remove the ambiguity somehow.
14:23:19 <revenantphx> So, deleting duplicates from the second (using nub perhaps) first is needed.
14:23:29 <copumpkin> Eduard_Munteanu: http://upload.wikimedia.org/math/6/1/f/61f34aa25871e9546b6a11243e1bed31.png
14:23:31 <revenantphx> and what about say:
14:23:34 <frerich_> revenantphx: Oh, actualy, I was wrong. Only the first result would be acceptable in my case.
14:23:37 <ion> [([0],[0,1]), ([1],[2]), ([2],[3]), ([3],[])]
14:23:56 <revenantphx> Okay, what about
14:23:58 <frerich_> revenantphx: So *if* the letter is at the same position, then that mapping is to be preferred.
14:24:00 <revenantphx> "aabd", "abcd"
14:24:13 <Eduard_Munteanu> Heh, is that the tree of possible transliterations of Gaddafi's name?
14:24:15 <dropdrive> Not strictly a Haskell question but if I said to you, "take f, and compose it with g" then is that (f . g) or (g . f)?
14:24:18 <frerich_> revenantphx: That would be [(0,0), (2,1)]
14:24:39 <frerich_> revenantphx: That's the only acceptable solution, the 'a' is mapped to the 'a' in the same position. The 'b' is mapped to the only other 'b'.
14:24:51 <Eduard_Munteanu> dropdrive: normally (g . f) is read as "g composed with f".
14:24:52 <monochrom> dropdrive: I would toss a coin to choose one.
14:25:13 <ddarius> Eduard_Munteanu: No, it's a "tree" of strings that contains, among many others, possible transliterations of Gaddafi's name.
14:25:38 <revenantphx> frerich_: you forgot the d at the end
14:25:42 <monochrom> of course with more contextual information, I would do better. but you do not disclose contextual information
14:25:46 <dmwit> dropdrive: If you said that to me, I'd ask which you meant.
14:25:54 <frerich_> revenantphx: Oh, oops, right. So there'd be a (3,3) in the list, too.
14:26:18 <dropdrive> Eduard_Munteanu, monochrom, dmwit: Okay, thanks.
14:26:36 <frerich_> revenantphx: So the key points are 1.) if a 'straight' mapping (the index in both lists is the same) is possible, choose that. 2.) No single element form either list may be mapped to more than one element in the other list.
14:26:52 <revenantphx> suddenly the problem becomes much more complex :|
14:27:11 <revenantphx> I still think nub'bing both sides works easily enough
14:27:31 <copumpkin> Eduard_Munteanu: yeah
14:29:12 <frerich_> revenantphx: Hm then maybe I need to look for other ways to approach the problem.
14:29:25 <revenantphx> Yeah, I'm sure your method *can* be done.
14:29:29 <revenantphx> I'm just not sure it's worth it :\?
14:31:55 <frerich_> revenantphx: My concrete use case is: I'd like to rewrite the function for providing "feedback" on a mastermind guess. The function gets the secret code, and a guessed code. A 'code' is a 4-tuple of colors. I need to count the number of colors in the guess which are in the right position, and the number of colors in the guess which exist in the secret code, but in a different position.
14:32:17 <revenantphx> oh, it's mastermind :)
14:32:20 <dmwit> frerich_: But that function is so much easier than the one you're asking for.
14:32:23 <frerich_> Right now, that check is ugly and buggy and hard to extend. So I'm trying to generalize the problem.
14:32:26 <revenantphx> dmwit: ^
14:32:30 <revenantphx> yeah, that's a lot easier >_>
14:32:36 <revenantphx> you do two checks,
14:32:37 <copumpkin> zipWith (==)
14:32:40 <revenantphx> copumpkin: ^
14:32:42 <revenantphx> and for the other
14:32:44 <revenantphx> elem . nub
14:33:22 <frerich_> I had the zipWith one already, but my function for the other one always gave wrong results in case either code had a color appearing twice. :-/
14:33:35 <frerich_> Elem nub, hm. Let me read up on what 'nub' does
14:34:21 <copumpkin> DRMacIver: I guess my approach doesn't work when the choices are context-sensitive, as they appear to be in your generator
14:34:51 <ddarius> copumpkin: You just use the monadic nature more.
14:34:59 <copumpkin> yeah
14:35:03 <monochrom> you should do two stages. 1st stage find exact matches. and delete them before you go to 2nd stage.2nd stage can now safely count "wrong positions'
14:35:10 <revenantphx> frerich_: nub cuts out all duplicates
14:35:12 <copumpkin> I don't strictly use the monad in that gaddafi generator
14:35:14 <copumpkin> it's more of the applicative
14:35:16 <revenantphx> > nub "aaaaaabbbbbbccccc"
14:35:17 <lambdabot>   "abc"
14:35:20 <dmwit> > let exactMatches xs ys = find id . zipWith (==) xs ys in exactMatches "abca" "cbac"
14:35:20 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
14:35:20 <lambdabot>         against inferred typ...
14:35:24 <frerich_> revenantphx: Yes, but it alsp needs to discard 'exact' matches
14:35:25 <dmwit> :t find
14:35:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:35:31 <revenantphx> frerich_: You do the other one first.
14:35:35 <dmwit> :t findIndices
14:35:36 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
14:35:49 <dmwit> > let exactMatches xs ys = findIndices id $ zipWith (==) xs ys in exactMatches "abca" "cbac"
14:35:50 <lambdabot>   [1]
14:35:51 <revenantphx> let exactMatches =...
14:35:51 <revenantphx>      matches =  ...
14:36:58 <dmwit> :t delete
14:36:59 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
14:37:04 <dmwit> :t deleteIndex
14:37:04 <lambdabot> Not in scope: `deleteIndex'
14:37:38 <ddarius> > nub [0..]
14:37:38 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:37:39 * frerich_ prefers thinks you're able to whip up the solution so quickly because he's not the first one who came here trying to solve this particular problem instead of realizing that the problem is so ridicuously easy that everybody silently solved it except him
14:37:51 <dmwit> ?let deleteIndex n xs = take n xs ++ drop (n+1) xs
14:37:52 <lambdabot>  Defined.
14:37:55 <revenantphx> let partialPatches xs ys = length $ zipWith (==) (nub xs) (nub ys) in partialPatches "abcc" "abbb"
14:37:59 <ddarius> frerich: Both interpretations are correct.
14:38:03 <revenantphx> > let partialPatches xs ys = length $ zipWith (==) (nub xs) (nub ys) in partialPatches "abcc" "abbb"
14:38:04 <lambdabot>   2
14:38:31 <frerich_> ddarius: Yet another sobering experience made with Haskell. :-}
14:38:32 <ddarius> Albeit, it's been a decent while since I last saw someone asking about mastermind, at least that I recall.  And for me, a "decent while" can readily be years.
14:38:48 <dmwit> revenantphx: That doesn't look right to me.
14:38:59 <revenantphx> dmwit: It just counts the number of matching elements.
14:39:10 <dmwit> Yes. But that's not what MasterMind does.
14:39:14 <revenantphx> (how many unique elements the two have in common)
14:39:21 <revenantphx> oh, well I don't remember how to play mastermind >_>
14:39:23 <revenantphx> then.
14:39:44 <frerich_> Hm, interesting, nub doesn't require a sorted list.
14:39:54 <dmwit> Calculating blacks is very easy. Calculating whites is not a one-liner, but it still shouldn't be too tricky.
14:40:04 <ddarius> frerich: The type says that it couldn't use that information anyway.
14:40:26 <napping> all exact matches count as a wrong position
14:40:35 <ddarius> dmwit: I'd be careful with saying something isn't a one-liner...
14:40:58 <dmwit> s/is not a one-liner/should not be forced onto one line/
14:41:08 <ddarius> Pshaw!
14:41:29 <blbrown_win3> with func programming, what is the opposite of when
14:41:51 <copumpkin> unless?
14:41:51 <byorgey> frerich_: no, and as a result it is O(n^2)
14:41:54 <copumpkin> :t unless
14:41:54 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:42:00 <copumpkin> :t when
14:42:01 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:42:03 <byorgey> frerich_: you can do better for instances of Ord.
14:42:10 <teapot_> Hey guys. I've a clean install of Ubuntu LTS and I'm trying to install cabal after installing GHC 7.0.2 from the website (not from the repositories since only GHC 6 is available)
14:42:22 <teapot_> Setup: At least the following dependencies are missing:
14:42:22 <teapot_> base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2
14:42:25 <monochrom> the opposite of when is where
14:42:29 <teapot_> That's the problem I'm having...
14:42:30 <napping> let counts as bs = let exacts = length (filter id (zipWith (==) as bs))in (exacts,length (filter (`elem`bs) as) - exacts)
14:42:46 <byorgey> teapot_: you should install the Haskell Platform
14:42:49 <byorgey> @where platform
14:42:49 <lambdabot> http://hackage.haskell.org/platform/
14:42:59 <dmwit> napping: That's not right, either.
14:43:06 <byorgey> that comes with cabal and lots of other goodies all packaged up nicely
14:43:12 <napping> what's the scoring rule again?
14:43:15 <frerich_> byorgey: Hm yes. But, if it could assume that the given type has an instance of 'Eq' (which it can, it seems) and if it knows that the input list is sorted, then it could be O(n) by removing subsequent duplicates, no?
14:43:20 <ddarius> You could use excluded middle and get something that might arguably be viewed as an inverse to when.
14:43:29 <nihtml> hi, I'm lookin for a trace function in ghci like ocaml's, does it exist?
14:43:44 <byorgey> frerich_: yes, that's true
14:43:51 <monochrom> teapot_: you should disclose full information such as what exact command line you entered and full output.
14:44:12 <napping> nihtml: like #trace?
14:44:16 <byorgey> frerich_: such a function is given by  map head . group
14:44:18 <ddarius> monochrom should preemptively tack on "in a pastebin"
14:44:24 <nihtml> napping: yes
14:44:34 <byorgey> > map head . group $ [1,2,3,3,4,5,5,5,6,6,8]
14:44:36 <lambdabot>   [1,2,3,4,5,6,8]
14:44:40 <napping> not quite. Debug.trace lets you print things when the function is entered
14:44:52 <lpsmith> is there a way to get the user id that a haskell process is running as?
14:45:01 <napping> there's also the ghci debugger http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/ghci-debugger.html
14:45:04 <dmwit> napping: It's easier to define the score of a mapping. Take a mapping from guess pegs to output pegs; each peg that gets mapped to the same index and the same color gets a black, and each peg that gets mapped to a different index and the same color gets a white.
14:45:07 <nihtml> hm okay
14:45:21 <monochrom> well every programmer in 2011 ought to know when where and how to use a pastebin.
14:45:34 <mauke> lpsmith: http://haskell.org/ghc/docs/6.10.2/html/libraries/unix/System-Posix-User.html
14:45:35 <dmwit> napping: The actual score is the score of the mapping that maximizes the score (using the lexical ordering for (blacks, whites)).
14:45:36 <monochrom> more fundamental than reading skill, actually
14:45:40 <copumpkin> is napping a mapping?
14:45:57 <lpsmith> mauke, thanks, I was looking in System.Posix.Process
14:46:20 <ddarius> monochrom: By that logic every programmer ought to know when, where, and how to provide a "bug report."
14:46:23 <monochrom> filepath comes with ghc 7.
14:46:41 <napping> dmwit: a permutation, or any mapping?
14:46:45 <monochrom> yes, we need an assassination service to enforce that.
14:47:03 <dmwit> napping: The "filter (`elem` bs) as" thing is wrong, because if "as" has ten occurences of 'a' and "bs" has only one, the length will be ten instead of one.
14:47:04 <ddarius> monochrom: I'm ten steps ahead of you.
14:47:07 <dmwit> napping: A permutation. Good question.
14:47:10 <teapot_> Haskell Platform isn't working either. Complaining about an OpenGL C library I can't seem to find in the repos.
14:47:10 <monochrom> nice
14:47:11 <frerich_> byorgey: Hm yes, except that the 'n' in O(n) is larger (though still constant) since groups has to do a traversal and so does map.
14:47:12 <revenantphx> dmwit: nub it.
14:47:17 <dmwit> revenantphx: No.
14:47:22 <revenantphx> u nub.
14:47:23 <dmwit> revenantphx: That's not right, because it errs in the other way.
14:47:27 <napping> with any mapping, elem would be the thing
14:47:30 <monochrom> ok the person is uninterested in disclosing information.
14:47:44 <revenantphx> I mean, even if its code for some corporate thing...
14:47:54 <revenantphx> 30 pasted lines are not going to reveal the companies sekrit planz
14:48:26 <ddarius> monochrom: An alternative, less bloody solution that I don't endorse is excluding such entities from programmer-/person-hood.
14:48:35 <dmwit> revenantphx: If "as" has two occurrences of 'a', and "bs" has two occurrences of 'a', that should count for two points, not one, as nub would do.
14:48:38 <byorgey> frerich_: that's really neither here nor there.  After the optimizer and code generator is done with it you really can't make comparisons like that.
14:49:15 <ddarius> For n = 4, this isn't a conversation worth having...
14:49:36 <ddarius> Now if it were A(n,n) then it would be.
14:49:45 <monochrom> haha
14:50:24 <byorgey> frerich_: in fact, multiple list traversals can often get "fused" into one traversal
14:51:02 <frerich_> byorgey: Coolness
14:52:08 <byorgey> frerich_: in general, because of laziness and cool technology like stream fusion, Haskell encourages programming in this style where you chain together incremental modifications to a data structure
14:52:36 <revenantphx> wtf is stream fusion again?
14:52:37 <frerich_> Hm yes I still have the wrong mindset.
14:52:40 <byorgey> it's also much more modular
14:52:56 <frerich_> I think "Oh drat this is going to iterate this silly single linked list over and over!"
14:53:52 <napping> The memory consumption of the silly linked list can be a problem, though
14:53:56 <byorgey> revenantphx: the basic idea is that list produces and consumers in a chain can all get "fused" into a ight loop that doesn't actually allocate intermediate cons nodes
14:54:02 <jmcarthur> revenantphx: it's a particular case of deforestation, which in general is when you can eliminate intermediate data structures that would normally be constructed when you compose certain functions
14:54:31 <revenantphx> so like if you had two traversals, one that increments each number, and one that doubles each number
14:54:40 <revenantphx> you'd fuse them into something that increments and then doubles each number?
14:54:43 <frerich_> The confusing thing is that sometimes, thinking low level makes sense (to understand why 'x:l' is cheaper than 'l ++ [x]') and sometimes it doesn't because somehow everything gets optimized automagically.
14:54:44 <revenantphx> instead of two passes?
14:54:45 <byorgey> right
14:54:47 <jmcarthur> revenantphx: yes
14:54:55 <revenantphx> Okay, so it's just like...
14:54:59 <revenantphx> composing whatever you're fmap'ing.
14:55:05 <revenantphx> er, *map
14:55:05 <byorgey> frerich_: yes, it takes experience to tell the difference, that's true
14:55:06 <jmcarthur> well, in that particular case
14:55:11 <revenantphx> map (f . g)
14:55:15 <jmcarthur> revenantphx: it's much more general than just map
14:55:21 <napping> frerich_: I don't believe fusion usually changes computational complexity
14:55:22 <revenantphx> example?...
14:55:52 <napping> so you can make a somewhat principled distinction between always caring about constant factors, and not digging into low level stuff uncecssarily
14:55:52 <byorgey> napping: right, it doesn't but it has a big effect on constant factors
14:56:18 <jmcarthur> revenantphx: folds and unfolds can also be fused away a lot of the time
14:56:24 <revenantphx> oh, interesting
14:56:33 <jmcarthur> revenantphx: e.g.   sum . map succ
14:56:50 <napping> and just vaguely remembering that there may be some fancy optimizations if you are trying to optmizie code, so actually time things rather than just writing ugly code in the hope that your pain will appease the computer
14:57:07 <jmcarthur> revenantphx: and deforestation can also work for trees that aren't necessarily linked lists, although stream fusion is *usually* intended to mean for lists
14:57:16 <revenantphx> interesting
14:57:25 <napping> I don't believe fusion is implemented for things other than lists, though
14:57:51 <jmcarthur> napping: but it shouldn't be too hard to do
14:58:04 <napping> list fusion is just a bunch of rewrite rules (whether it's the older foldr/build stuff or the newer stream fusion), stuff like "warm fusion" actually took a compiler pass
14:58:12 <jmcarthur> warm fusion?
14:58:46 <monochrom> haha great name
14:58:48 <ddarius> napping: foldr/build like things could be done readily for any polynomial algebraic data type.
14:59:18 <frerich_> Hm, even Knuth's paper (http://www.dcc.fc.up.pt/~sssousa/RM09101.pdf ) has a hard time describing the 'white hit' rule in mastermind nicely. :-/
14:59:38 <jmcarthur> if one was to take the fixpoint package and add a simple rewrite rule then it would have some basic fusion for whatever instances of Fixpoint you define:   forall f g. cata f . ana g = hylo f g
14:59:47 * ddarius would not look to Knuth for elegance in code...
15:00:22 <tromp__> wonder how Knuth would like programming in haskel
15:00:29 <frerich_> ddarius: It' s not even code, just some attempt at explaining the rule to mathematicians or to computers (on the first page of the PDF, bottom most paragraph)
15:00:29 <jmcarthur> i'm not sure what the distinction between fusion and deforestation is, if any
15:00:49 <tromp__> he probably hates not being abe to count bytes and cycles used:(
15:00:52 <jmcarthur> my understanding is that the former is at least some sort of subset of the other, but they may be the same
15:01:24 <hpc> i wonder if we could somehow use the clean style of haskell code to somehow transform steve jobs into someone who values things that work over things that are made of aluminum
15:01:33 <ddarius> jmcarthur: Fusion is a subset of deforestation, though the terms are used fairly loosely now.
15:02:01 * jmcarthur decides to stick with deforestation until he understands the difference
15:03:16 <tromp__> if Fusion is deforestation, then is forestation fission?
15:05:10 <dmwit> > let matches xs ys = count (sort xs) (sort ys) where { count (x:xs) (y:ys) | x < y = count xs (y:ys) | x == y = 1 + count xs ys | x > y = count (x:xs) ys; count _ _ = 0 } in matches "abca" "cbac"
15:05:10 <lambdabot>   3
15:05:29 <dmwit> frerich_: Use something like that, and subtract out the number of blacks.
15:05:30 <dmwit> Done.
15:06:20 <ddarius> > let as = "abcd"; bs = "bacd" in sum [fromEnum (i /= j && a == b) | (i,a) <- zip [0..] as, (j,b) <- zip [0..]]
15:06:20 <lambdabot>   Couldn't match expected type `[t]'
15:06:20 <lambdabot>         against inferred type `[b] -> [(...
15:06:52 <ddarius> > let as = "abcd"; bs = "bacd" in sum [fromEnum (i /= j && a == b) | (i,a) <- zip [0..] as, (j,b) <- zip [0..] bs]
15:06:52 <lambdabot>   2
15:09:26 <dmwit> > let as = "aaaabbbb"; bs = "bbbbaaaa" in sum [fromEnum (i /= j && a == b) | (i,a) <- zip [0..] as, (j,b) <- zip [0..] bs]
15:09:26 <lambdabot>   32
15:09:30 <dmwit> sorry
15:09:53 <dmwit> > let matches xs ys = count (sort xs) (sort ys) where { count (x:xs) (y:ys) | x < y = count xs (y:ys) | x == y = 1 + count xs ys | x > y = count (x:xs) ys; count _ _ = 0 } in matches  "aaaabbbb" "bbbbaaaa"
15:09:53 <lambdabot>   8
15:14:05 <ddarius> > let as = "aaaabbbb"; bs = "bbbbaaaa" in sum [fromEnum (any (\(j,b) -> i /= j && a == b) bs) | (i,a) <- zip [0..] as]
15:14:06 <lambdabot>   Couldn't match expected type `(t, GHC.Types.Char)'
15:14:06 <lambdabot>         against inferred...
15:14:18 <ddarius> > let as = "aaaabbbb"; bs = "bbbbaaaa" in sum [fromEnum (any (\(j,b) -> i /= j && a == b) $ zip [0..] bs) | (i,a) <- zip [0..] as]
15:14:19 <lambdabot>   8
15:14:24 <ddarius> I made it too complicated.
15:18:03 <napping> consider \\
15:19:00 <ddarius> I'm going for as close to the specification as possible.
15:19:44 <napping> approx as bs = length (as \\ (as \\ bs))
15:20:05 <napping> exact as bs = length (filter id (zipWith (==) as bs))
15:20:13 <napping> score as bs = (exact as bs, approx as bs - exact as bs)
15:30:55 <frerich_> napping: Hm that seems to work great
15:31:44 <frerich_> napping: I though it should break since the 'exact' function might count elements which are also counted by 'approx'.
15:31:57 <frerich_> napping: but somehow it works, I'm trying to dissect why that is :)
15:34:42 <napping> that's why the exact count is subracted from the approx count
15:39:40 <frerich_> Hmm, 'approx' is just the 'intersect' function, no?
15:40:04 <frerich_> Well except that it takes the length of the intersection.
15:45:43 <frerich_> napping: Did you use 'filter id' for some specific reason other than it being shorter tahn 'filter (True==)'?
15:46:15 <mwc> has anybody looked at the issue of using regions for the management of compound resources, resources that aren't simple like a file handle but contain other resources?
15:46:34 <mwc> I'm trying to model the OpenCL object dependencies with regions
15:46:56 <hpc> frerich_: it's also simpler
15:47:14 <hpc> it's one less function application
15:47:31 <mwc> so for instance a CommandQueue requires both a Device and a Context, but a Device also requires a Context all of which are resources
15:48:26 <mwc> My current thinking is an existential type with the parent region constraint on the component resource inside the composite resource
15:48:30 <mwc> any thoughts?
15:49:01 <BMeph_> frerich_: In a sense, it's offensive to our programming senses to program a logical test "x == True", instead of just saying "x".
15:49:14 <hpc> BMeph_: haha, well said
15:49:28 <mwc> data ResourceB br = RB { resourceA :: ar `ParentRegion` br => ResourceA ar, ... } 
15:49:36 <mwc> er, should be an exists ar. in there
15:49:44 <BMeph_> frerich_: We actually use that point as a joke, sometimes. :)
15:51:15 <ddarius> BMeph_: Clearly x==True is inadequate and (x==True)==True should be used, except...
15:51:50 <aristid> there should be a safe version of (==). i propose (===).
15:51:59 <aristid> so x===True would be safer than x==True
15:52:16 <frerich_> BMeph: Hm, that's a good example actually. I see it now. This was just hidden for me behind 'id' since I didn't immediately see that the list contains bools (I only later saw it because '==' was given to zipWith).
15:52:31 <hpc> > fix (== True)
15:52:34 <frerich_> I'm pretty slow at reading form right to left.
15:52:34 <lambdabot>   mueval-core: Time limit exceeded
15:53:00 <mwc> hpc: heh, that was my thought too ;P
15:53:58 * frerich_ memorizes "filter id l" as the non-offensive idiom to get all True elements from 'l'.
15:54:17 <hpc> frerich_: another fun one, filter fst
15:54:19 <hpc> :t filter fst
15:54:20 <lambdabot> forall b. [(Bool, b)] -> [(Bool, b)]
15:54:29 * ddarius feels that one shouldn't have a list of booleans to begin with.
15:54:34 <hpc> > filter fst [(False, 1), (True, 2)]
15:54:35 <lambdabot>   [(True,2)]
15:54:40 <hpc> aw yeah!
15:55:05 <ddarius> > [a | (True, a) <- [(False, 1), (True, 2)]
15:55:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:55:11 <ddarius> > [a | (True, a) <- [(False, 1), (True, 2)]]
15:55:12 <lambdabot>   [2]
15:55:36 <hpc> that's no fun; you don't have a totally meaningless tuple half :P
15:56:03 <spidermario> @poll-list
15:56:03 <lambdabot> ["\"blah\"","food","logoVotingMethod","naming","remove@src","threeway"]
15:56:30 <ddarius> Indeed, and in the filter id case, you just get a totally meaningless value.  Taking the length of the result is about the only thing worth doing.
15:57:11 <hpc> :t filter
15:57:12 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:57:27 <hpc> oh right, i can't do that
15:57:32 <hpc> > filter 5 [1..4]
15:57:33 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
15:57:33 <lambdabot>    arising from the literal `5'...
15:57:36 <hpc> :/
15:58:54 * BMeph_ proposes to call ddarius' comprehension the "mapTrues" function! ;þ
15:59:37 <spidermario> > filter (== 5) [1 .. 4]
15:59:37 <lambdabot>   []
16:00:02 <ddarius> If guard didn't have an annoying type, it would be catMaybes . map (guard . fst)
16:00:15 <ddarius> Actually, that still doesn't work well.
16:00:53 <ddarius> At any rate, Maybe > Bool.
16:01:59 <ourfrank> Can I have two different build-depends in a cabal file -- one for compiling on Windows and another for GNU/Linux? If yes, how could I accomplish this?
16:02:22 <ddarius> I guess we could stick the isomorphism between (Bool, a) and Either a a into the standard library somewhere.
16:02:37 <ddarius> @hoogle lefts
16:02:37 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
16:02:37 <lambdabot> Language.Haskell.Lexer LeftSquare :: Token
16:02:37 <lambdabot> Language.Haskell.Syntax HsLeftSection :: HsExp -> HsQOp -> HsExp
16:03:24 * BMeph wonders why we don't have functions that directly give the count of elements of a list that match some criterion
16:04:29 <ddarius> Because Bool : Maybe :: Natural : List
16:04:44 <ion> > not `fmap` True
16:04:45 <lambdabot>   Couldn't match expected type `f GHC.Bool.Bool'
16:04:45 <lambdabot>         against inferred typ...
16:06:13 <BMeph> ddarius: So, the list is itself a count? ;þ
16:06:25 <jjohnsson> > not <$> [True]
16:06:25 <lambdabot>   [False]
16:06:30 <ddarius> BMeph: Yes.  Natural = [()]
16:06:51 <ddarius> And incidentally Bool = Maybe ()
16:06:56 * BMeph almost saw "counit" there instead of "count"...need to lay off the comonad juice for a bit.
16:07:41 <ddarius> count = map (const ())
16:07:53 <ddarius> Well length = map (const ())
16:08:13 <ddarius> count p = map (const ()) . filter p
16:08:23 <aristid> count p = length . filter p would still hold
16:09:15 * BMeph thought that that was what ddarius just wrote...
16:09:34 * djahandarie too
16:09:37 * ddarius wonders what happens if you view queues represented as two lists from the perspective of integers as equivalence classes of naturals.
16:13:44 <aristid> BMeph: no, he explicitly wrote the length in count as map (const ()), which bothers me
16:13:59 <aristid> for no good reason :P
16:15:36 <BMeph> aristid: Fair enough; it bothers me that length has the "Int" result type when it should "obviously" at least be "Word" if not a synonymous "Nat" instead. :)
16:16:13 <ddarius> One day we'll get a GMP-base Natural type.
16:16:22 <ddarius> +d
16:16:33 <BMeph> ddarius: Your threats do not frighten me.
16:17:04 <BMeph> > length (tail [minBound::Int ..maxBound])
16:17:08 <lambdabot>   mueval-core: Time limit exceeded
16:17:10 * ddarius imagines a data type with enqueue a q and dequeue q a.
16:17:53 * BMeph is having trouble imagining what such a type would be used for...
16:18:43 <ddarius> I thought it might be useless, but then I started wondering if it might have applications as a kind of synchronizing channel thing.
16:26:44 <frerich_> Hm, I'm mostly playing with Haskell to get new ideas for being a programmer in other programming languages. Unfortunately, the language I spent most of my time with (about ten years of C++ by now :/) doesn't allow composing functions as nicely (and it has no lambdas). :-/
16:27:12 <ion> Yes, C++ does suck. :-P
16:27:25 <PhilRod> frerich_: you took the words right out of my mouth...
16:27:41 <frerich_> ion: It pays the rent :-/
16:27:55 <ion> Yes, a lot of rent-paying things suck.
16:28:10 <ddarius> Paying rent sucks.
16:30:15 <tromp__> beats paying property taxes and house upkeep
16:30:18 <frerich_> Also, a lot of the cool tricks I learned in Haskell barely translate to C++ because they rely on how Haskell works (being lazy, for instance). So at this point, it's fun to learn something new but my original plan of transposing ideas doesn't work out at all :-/
16:31:21 <jmcarthur> frerich_: haskell has a lot of tricks that aren't related to laziness, too
16:32:04 <jmcarthur> admittedly, you wouldn't want to and/or can't use many of them in C++ anyway
16:32:06 <frerich_> jmcarthur: I'm sure it has, I only scratched the surface. I just hope I eventually hit stuff which will be beneficial in the languages which pay my rent, too :-}
16:32:42 <jmcarthur> frerich_: i recently got a nice job offer doing some ocaml, and there are such jobs out there too
16:32:50 <jmcarthur> *other such jobs
16:33:28 <espringe> frerich_: You can always use boost pheonix for functional programming / currying in c++ :)
16:33:38 <jmcarthur> frerich_: also, even if you're stuck in a job that uses "lesser" languages, haskell can also be used for code generation :)
16:33:45 <jmcarthur> and it's also easy to bind with C
16:33:53 <frerich_> jmcarthur: I read that. The "problem" is that I've been employee #2 (and we're about 20 by now) and I have a 5 minute walk to work. These are pretty good benefits, so I'd like to fix the C++ problem rather than switching jobs :)
16:34:10 <jmcarthur> frerich_: then fix the C++ problem :)
16:34:29 <frerich_> jmcarthur: I actually wrote some internal tool with Haskell already. I'm trying to assimilate colleagues, which is a prerequisite to getting a foot into the door.
16:34:40 <frerich_> So we are two guys writing little helper tools, at least.
16:34:50 <jmcarthur> a good start
16:35:07 <espringe> frerich_: It's an easy solution to solve, first what you need to do push boost extremely heavily
16:35:21 <espringe> get absolutely everything use insane amounts of boost, and obscure language features
16:35:25 <jmcarthur> i've heard about FP completely taking over VB, Java, and Delphi shops, now
16:35:26 <frerich_> (he actually was on the team for the dutch spell checker for Microsoft Office, and they did the POC in Haskell :)
16:35:31 <espringe> And make everything generic as hell
16:35:53 <jmcarthur> "POC"?
16:35:53 <lpsmith> jmcarthur, how big of a shop?
16:36:00 <espringe> Like don't take in a list of something, template it out with:
16:36:00 <espringe> template < template <typename, typename> class Collection  >
16:36:10 <frerich_> jmcarthur: Proof Of Concept
16:36:13 <jmcarthur> aha
16:36:17 <espringe> Anyway, after a few months of that, everyone will so suicidal -- you can just push haskell with ease
16:36:25 <frerich_> espringe: haha
16:37:25 <espringe> frerich_: Every time some one uses inheritance, scream "EWWWW!" and force them to do it statically (with CRTP) etc.
16:37:28 <frerich_> One simple yet effective thing we already did was to get people to write functions so that they mostly (or even exclusively) on their arguments and their return value. And to use types to express invariants.
16:37:36 <espringe> C++ is a bad language, but you can make it intolerably so 
16:37:48 <mauke> preflex: remember <espringe> C++ is a bad language, but you can make it intolerably so 
16:37:53 <jmcarthur> lpsmith: Jane Street used a lot of VB before going about completely over to ocaml. clarify still has a fair bit of java, but they told me that if they had they way they would hire nothing but functional programmers from now on, and there's a small business switching their entire infrastructure from delphi to haskell soon
16:38:11 <lpsmith> hmm
16:38:26 <Heffalump> jmcarthur: is the small business's name public?
16:38:28 <jmcarthur> i don't know how big jane street was at the time, and that last one is quite small
16:39:01 <monochrom> Today must be some kind of Heritage Day. So many people come here to defend inheritance.
16:39:19 <Eduard_Munteanu> @quote you.can.make.it
16:39:19 <lambdabot> EvilTerran says: if three of those lines aren't import Control.Monad; import Control.Arrow; import Control.Applicative;, you can make it shorter ;]
16:39:27 <Eduard_Munteanu> @quote you.can.make.it.intolerably
16:39:27 <lambdabot> No quotes match. Do you think like you type?
16:39:34 * ddarius hasn't seen Irrelevant in a while.
16:39:36 <Eduard_Munteanu> Hrm, different dbs.
16:39:55 <frerich_> espringe: I once read that programming in C++ is much like cutting your toe nails with a chainsaw. It works, but you darn better know what you're doing. :-)
16:40:09 <ddarius> Implementation inheritance is one of the worst ideas, and worst executed ideas, in computer science.
16:40:21 <espringe> frerich_: Another great thing to corrupt your code base:
16:40:21 <espringe> http://en.wikipedia.org/wiki/Barton%E2%80%93Nackman_trick
16:40:33 <mauke> preflex: quote PoppaVic
16:40:33 <preflex>  <PoppaVic> To be fair.. I've never had issues with writing FOR a spacetime, but I geet bent when folks assume they are all the same and then cry herein.
16:42:50 <frerich_> espringe: There are people who argue that  any language which wants to be worth its money should allow bending it, so having to jump through loops like that is taken as an advantage becase you *can* do it.
16:43:15 <Eduard_Munteanu> To be fair C++ isn't nearly as bad as stuff that does dynamic typing.
16:43:42 <mauke> Eduard_Munteanu: I'd say it's worse
16:44:03 <frerich_> espringe: So you can build things like concepts of your own. Or functors. Or local functions. Or whatever.
16:44:09 <espringe> frerich_: Except those things are just total hacks. The Barton Nackman trick is just because C++ doesn't have interfaces
16:44:18 <espringe> (as in, compile time verified interfaces)
16:44:22 <espringe> (nothign to do with runtime)
16:44:51 <espringe> Same with CRTP: Another total hack of abusing the template engine to give you static polymorphism 
16:45:00 <frerich_> espringe: Well *I* tend to say that yes, it's a hack, it shows a deficiency of the language. Other people say "Look, you can express all this stuff using the language itself".
16:45:08 <Eduard_Munteanu> mauke: ah, you were a Perl-head, weren't you? :)
16:45:15 <mauke> Eduard_Munteanu: among other things
16:45:29 <frerich_> espringe: It's taken to an extreme by e.g. Tcl (where even 'if' isn't a special language construct)
16:45:36 <mauke> but I like Perl for its simplicity (compared to C++)
16:45:51 <ddarius> if is easy to not have as a special language construct.
16:46:06 * ddarius likes C++ and dislikes Perl but likes Scheme.
16:46:15 <Eduard_Munteanu> Well, that's the thing. I'd compare with Matlab. It's all warm and fuzzy until you actually hit a problem.
16:46:25 <Eduard_Munteanu> Then you realize the type system is almost absent.
16:46:35 <copumpkin> matlab is horrible
16:46:39 <copumpkin> as far as language design goes
16:46:41 <Eduard_Munteanu> Yeah it is.
16:46:48 <ddarius> It could be TeX.
16:46:51 <copumpkin> it's fairly convenient for doing stuff in
16:47:00 <copumpkin> but I need to shower after every time I use it
16:47:05 <copumpkin> ddarius: true
16:47:08 <Eduard_Munteanu> Heh.
16:47:26 <mauke> (anyone who thinks C++ isn't that complex is welcome to explain the name lookup rules to me)
16:47:47 <ddarius> Who said anything about not being complex?
16:48:31 <accel> mauke: it's easier than figuring out whether something is shared or not in ahskell
16:48:41 <Eduard_Munteanu> @remember copumpkin matlab is horrible as far as language design goes[.] it's fairly convenient for doing stuff in but I need to shower after every time I use it
16:48:41 <lambdabot> Done.
16:48:42 <accel> after ghc's optimization rewriting
16:48:43 <mauke> accel: I accept your challenge
16:48:47 <frerich_> ugh, almost 1m already
16:48:52 <accel> mauke: what challenge?
16:49:47 <Eduard_Munteanu> Honestly doing some matrix/vector operations is pissy in everything else but Matlab, somehow.
16:50:07 <ddarius> mauke: I'm not sure about Perl, but for things like Python, Ruby, Smalltalk, etc. can't you hook name lookup so that it is technically "Turing-hard" to know what name is looked up?
16:50:26 <Eduard_Munteanu> I wish there was a nice lib for doing stuff like that in Haskell.
16:50:33 <ddarius> (Of course, that's likely true of C++ as well for different reasons.)
16:50:44 <mauke> ddarius: no idea
16:51:05 <mauke> but that sounds weird
16:51:24 <napping> You can hook a particular class so that lookup in that class is hard
16:51:51 <Eduard_Munteanu> ddarius: do you mean resolving pointers/references to actual object names? Yeah, I think that's tough everywhere.
16:52:03 <mauke> I'm not talking about the actual lookup, just the rules you'd have to follow in your parser
16:53:08 <napping> parsing should always be easy enough
16:53:20 <ddarius> Parsing C++ is... unpleasant.
16:53:23 <mauke> I see you're new to this thing
16:53:25 <frerich_> not with C++
16:53:45 <ddarius> Parsing Perl 6 is also supposed to be fun for different reasons.
16:54:07 <mauke> because it's lisp
16:54:14 <mauke> well, lisp and haskell
16:54:27 <ddarius> Forth doesn't even pretend at least.
16:54:59 <frerich_> So it's language bingo night again.
16:55:11 <ddarius> J pretends to pretend which is confusing.
16:55:32 <mauke> parsing perl5 is "hard" in the sense that you can run code at read time
16:55:33 <Eduard_Munteanu> You guys know one too many languages... :P
16:58:17 <ddarius> "The rules for parsing J are easy, here they are. [...]  And you apply this rule if the verb is a monad, and that rule if it is a dyad.  Oh by the way, whether something is a monad or dyad is a run-time property, which can change dynamically, technically within a single expression."
16:58:50 <mauke> haha
16:59:52 <mauke> every few months I idly ponder what kind of language category ploki falls in
17:00:04 <mauke> and if a grammar can be written for it
17:01:38 <danharaj_> @pl (\x y -> f (g x y))
17:01:38 <lambdabot> (f .) . g
17:04:48 <ion> :t (\f g x y -> f (g x y))
17:04:48 <lambdabot> forall t t1 t2 t3. (t2 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t3
17:04:50 <ion> :t (.:)
17:04:51 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
17:05:48 <ion> Wait. That wasn’t it…
17:07:31 <ion> Wait, that *was* it. :-)
17:07:49 <danharaj_> :t (.)
17:07:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:08:30 <ion> > ((*2) .: (+)) 2 3
17:08:31 <lambdabot>   10
17:09:09 <ion> @src (.:)
17:09:09 <lambdabot> Source not found. stty: unknown mode: doofus
17:11:47 <aristid> ion: (.:) = fmap.fmap
17:11:59 <aristid> or even, equivalently, (.) = fmap fmap fmap
17:12:10 <aristid> -(.)+(.*
17:12:13 <aristid> -(.)+(.:)
17:12:21 <ion> I’d guess (.:) = (.).(.) and in lambdabot (.) = fmap
17:12:27 <aristid> yes
17:12:47 * danharaj_ 14 year old self assumes direct control
17:12:57 <danharaj_> :t ( . ) ( . )
17:12:57 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
17:25:25 --- mode: ChanServ set +o monochrom
17:25:27 --- topic: set to '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]' by monochrom
17:27:28 <Taslem> How many bots operate on this channel?
17:28:43 <parcs> @src repeat
17:28:43 <lambdabot> repeat x = xs where xs = x : xs
17:28:44 <c_wraith> Two that I know of, most of the time
17:28:47 --- mode: monochrom set -bb *!*@*.i-next.psi.br *!*@unaffiliated/j-invariant
17:28:55 <parcs> repeat should be iterate id
17:29:09 --- mode: monochrom set +b *!*@*.i-next.psi.br
17:29:15 <c_wraith> parcs, that'd be less efficient
17:29:29 --- mode: monochrom set -o monochrom
17:29:35 <c_wraith> In particular, it would generate a new cons cell for each element in the list
17:29:46 <c_wraith> the repeat implementation doesn't
17:29:51 <Taslem> Who besides lambdabot?
17:29:54 <c_wraith> preflex
17:30:42 <Taslem> What does the second one do?
17:33:51 <parcs> whereas the current implementation reuses the same cons cell?
17:34:13 <rothwell> anyone know of a good relax-ng validator for haskell?
17:34:24 <rothwell> the one with hxt seems awful
17:34:43 <ion> repeat x does just a single cons operation.
17:35:45 <parcs> recurseively..
17:35:52 <parcs> recursively*
17:36:08 <ion> iterate id does a cons operation for each item.
17:37:19 <parcs> eh, i don't follow
17:37:27 <parcs> but it's okay. i'll get it eventually
17:37:58 <ion> foo = 0:foo  -- (:) is called just once
17:38:01 <ion> @src iterate
17:38:01 <lambdabot> iterate f x =  x : iterate f (f x)
17:38:34 <parcs> > let x = x + 1 in x
17:38:37 <lambdabot>   mueval-core: Time limit exceeded
17:38:47 <parcs> does this call (+1) once too?
17:38:56 <ion> iterate id 0 → 0:iterate id 0 → 0:0:iterate id 0 → 0:0:0:iterate id 0  -- (:) is called for each item
17:40:14 <Taslem> Does this channel have any policies against new IRC bots?
17:40:27 <ion> x = x+1 = (x+1)+1 = ((x+1)+1)+1 = … Not the same thing at all.
17:40:36 * rothwell tears out remaining hair
17:40:55 <parcs> > let xs = x : xs in xs
17:40:56 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
17:41:04 <parcs> what's the difference
17:41:38 <Taslem> Parcs? x=x+1 cannot lazily evaluate. + is an operator, not a type constructor.
17:42:03 <parcs> i know that
17:42:31 <parcs> i'm talking about the number of operations that are performed
17:42:41 <parcs> with iterate id vs repeat
17:44:19 <ion> x:xs creates a data structure with two fields, the first one pointing to x and the second one pointing to xs, which happens to point to the result of the operation in this case.
17:44:30 <Taslem> repeat takes fewer operations that iterate id.
17:44:50 <Taslem> I mean "than" not "that."  
17:45:45 <parcs> how does repeat only perform a single cons operation?
17:46:01 <Taslem> repeat x = xs where xs = x:xs
17:46:07 <Taslem> That's the prelude operation.
17:46:14 <byorgey> Taslem: no official policies.  Unofficially the policy is "don't be annoying" =)
17:46:25 <Taslem> Yeah, I figured.
17:46:52 <byorgey> people bring various new IRC bots in here occasionally though
17:46:55 <koda> hello, the experimental x64 support on mac is great
17:47:09 <Taslem> Whereas  iterate x = x : iterate f (f x)
17:47:12 <koda> though, is there any flag i can activate to create universal executables?
17:47:48 <Taslem> Koda, couldn't you just copy the files to whatever OS and then run GHC on it?
17:48:22 <koda> Taslem: emh i don't think i understand
17:48:26 <ion> let iterate' f x = x : iterate' f (trace "foo" f x) in iterate' id 0
17:48:31 <ion> let repeat' x = (let xs = x:trace "foo" xs in xs) in repeat' 0
17:49:05 <Taslem> Nevermind.
17:50:37 <Taslem> If I calculated correctly, iterate id performs 4 times as many operations per recursion as repeat.
17:51:18 <Taslem> It may also take up more memory.
17:52:37 <ion> Note the big difference between
17:52:48 <Taslem> Is there a way to tell Haskell to eagerly evaluate something?
17:52:56 <Taslem> Without invoking any sort of IO?
17:52:58 <ion> repeat0 x = let xs = x:xs in xs
17:53:04 <ion> repeat1 x = x:repeat1 x
17:53:26 <parcs> Taslem: seq
17:53:33 <parcs> or rather, join seq
17:54:00 <parcs> ion: wouldn't the appropriate definitions in this case be
17:54:21 <parcs> let repeat' x = let xs = trace "foo" (:) x xs in repeat' 0
17:54:31 <parcs> and the same for iterate'
17:55:03 <parcs> but anyway, ghci confirms your statement, but i still don't really understand. thanks for the help though
17:55:08 <byorgey> Taslem: a `seq` b  evaluates to b, but is strict in a, i.e. it evaluates a to weak head normal form before evaluating b
17:55:31 <Taslem> But, doesn't it also discard the value of a?
17:55:50 <byorgey> yes, but if a is also used somewhere else it is still only evaluated once
17:56:20 <Taslem> Oh, so you can still tell it to evaluate a variable/function and the result is kept? 
17:57:00 <byorgey> Yes, this has nothing to do with seq in particular
17:57:21 <Taslem> By the way...   Is it better practice to do:         a $ b $ c,   or a $ b c ?
17:57:22 <byorgey> e.g. in  let a = 5 + 10 in (a, a)  a will only be evaluated once
17:57:33 <byorgey> neither, it is better to do  a . b $ c
17:57:42 <Taslem> Oh, right.
17:59:21 <koda> oh i didn't see this bug http://hackage.haskell.org/trac/ghc/ticket/964 still open
17:59:33 <koda> so that means it's not yet possible :\
18:02:20 <Taslem> Why typing calculus does Haskell use?
18:02:25 <Taslem> I mean What.
18:03:03 <napping> The Haskell type system!
18:03:26 <napping> It's kind of like Hindley-Milner, or more specifically HM(X)
18:03:34 <Taslem> Ah, okay.
18:03:38 <Taslem> I'll go look that up.
18:03:48 <napping> but has some extensions
18:07:42 <ion> parcs: http://hpaste.org/45083/repeat
18:11:36 <parcs> ion: that is totally awesome. thanks!
18:20:12 <parcs> can it be said that repeat reuses the same cons cell, then?
18:20:51 <ion> It constructs a cell that points to itself.
18:27:39 * hackagebot DescriptiveKeys 0.0.3 - A library for specifying xmonad key bindings with functionality.  http://hackage.haskell.org/package/DescriptiveKeys-0.0.3 (TonyMorris)
18:29:34 <TheZimm> :t
18:29:43 <TheZimm> erm wrong place :P
18:31:01 <rothwell> alright... i broaden my question... is anyone actually processing xml (and validating it) with haskell... at all?
18:31:34 <rothwell> i've wrestled with hxt for days and have given up. i think it's just broken
18:31:41 <rothwell> haxml doesn't support anything beyond DTD for validation
18:31:51 <rothwell> the library from galois doesn't support any validation
18:32:01 <rothwell> the bindings for libxml don't (and don't build on 7.0)
18:32:24 <rothwell> hexpat doesn't seem to support anything
18:32:43 <rothwell> that basically exhausts all the options
18:34:18 <rothwell> it says something when a library interface is so overly complicated that someone releases another library just to simplify the original API
18:34:18 <rothwell> haven't dealt with that sort of nonsense since libpng
18:37:16 <parcs> what about xmlhtml?
18:39:12 <lpsmith> does {-# LANGUAGE Rank2Types #-} not work on GHC 6.12.3?
18:40:34 <lpsmith> doesn't work with GHC 7.0.1 either
18:46:06 <Eduard_Munteanu> lpsmith: I doubt it doesn't work
18:46:29 <Eduard_Munteanu> lpsmith: what symptoms are you experiencing?
18:46:32 <lpsmith> What I mean is,  the declaration isn't respected
18:46:56 <Eduard_Munteanu> Can you paste some code?
18:47:00 <lpsmith> It's the only type extension that the module is using,  and I get an error "use -XRank2Types"
18:47:37 <Eduard_Munteanu> Maybe it's a rank-n type after all.
18:47:55 <napping> 1. does -XRank2Types actually work? 2. Are you putting the LANGUAGE pragma as the first line of the file?
18:50:01 <lpsmith> Eduard_Munteanu,   http://hpaste.org/45084/rank2types_declaration_not_res
18:50:10 <lpsmith> napping, yes
18:50:14 <lpsmith> to both questions
18:50:40 <lpsmith> (also,  ghc-6.10 and later can have language declarations after comments)
18:51:05 <lpsmith> Whereas 6.8 it must literally be the first thing in the file
18:51:11 <Eduard_Munteanu> This doesn't look rank-2 to me, but I could be wrong:  callCC :: ((a -> forall b. Q e b) -> Q e a) -> Q e a
18:51:23 <lpsmith> that's rank2
18:51:36 <lpsmith> besides,  run it with -XRank2Types
18:51:41 <lpsmith> it works
18:52:02 <lpsmith> err
18:52:13 <lpsmith> I'm embarrassed now
18:53:20 <Eduard_Munteanu> You used -XRankNTypes? :)
18:53:49 <lpsmith> No,  I'm not sure what I did wrong
18:54:35 <Eduard_Munteanu> Oh, so it works with {-# LANGUAGE Rank2Types #-} ?
18:55:20 <lpsmith> No,  it doesn't work with -XRank2Types
18:55:35 <lpsmith> I probably wasn't loading something I thought I was loading
18:55:50 <lpsmith> and maybe it had {-# LANGUAGE RankNTypes #-} at the top
18:56:12 * lpsmith ponders why this isn't a "Rank 2" type
18:57:15 <c_wraith> I guess because the forall is further inside
18:57:31 <lpsmith> Ok,  Haskell's rank 2 types isn't defined the way I thought it was
18:59:10 <Eduard_Munteanu> I'd guess it's a rank-4.
18:59:27 <rothwell> parcs: xmlhtml is just a parser, can't validate
19:00:24 <Eduard_Munteanu> Actually no, because you can reduce it to rank-3: callCC :: ((forall b. a -> Q e b) -> Q e a) -> Q e a
19:01:45 <Eduard_Munteanu> (but I'm doing a bit of guesswork, don't take my word)
19:02:12 <lpsmith> yeah,  clearly I don't understand what "Rank N" really means
19:02:13 <dolio> It's rank-3.
19:02:51 <Eduard_Munteanu> dolio: and is my reasoning correct, or have I just happened to stumble upon the correct number? :)
19:03:06 <lpsmith> Eduard_Munteanu, well, the equivalence is correct
19:03:13 <dolio> rank(forall x. T) = max(1, rank T)
19:03:29 <dolio> rank(T -> U) = max (rank(T)+1, rank(U))
19:03:41 <lpsmith> ahh, thanks dolio 
19:03:42 <dolio> rank(_) = 0.
19:03:56 <Eduard_Munteanu> Nice.
19:04:01 <dolio> Don't ask about impredicativity.
19:04:19 <Eduard_Munteanu> Well I suppose rank increases with impredicativity as well.
19:04:21 <dolio> Like rank(Maybe (forall a. a)).
19:04:31 <dolio> Probably a safe answer.
19:04:52 <lpsmith> ok,  so    (forall b.  a -> Q e b) iff (a -> forall b. Q e b)
19:05:08 <lpsmith> are those exactly interchangable,  or is there some subtle difference?
19:05:26 <dolio> There's a difference in a Church-style calculus.
19:05:43 <dolio> But Curry-style ignores it, more or less.
19:06:08 <dolio> They act the same up to bugs in GHC.
19:06:28 <dolio> And GHC will convert the latter to the former, I think.
19:06:37 <Eduard_Munteanu> I suppose the difference comes from (->) a (forall b. Q e b)   vs   forall b. (->) a (Q e b), like considering (->) just like in the impredicative case ?
19:07:45 <Eduard_Munteanu> So (->) being "special" makes it not matter?
19:07:47 <dolio> Technically the interaction between (->) and forall is impredicative. But the flag is for datatypes.
19:08:21 <dolio> Actually, it's got nothing to do with (->), really.
19:08:41 <dolio> (forall (a:*). a) : * is impredicative.
19:08:44 <Eduard_Munteanu> I suppose (->) is a bit privileged in the sense impredicativity doesn't count for it.
19:10:02 <dolio> But GHC doesn't care, as long as you only instantiate a variable that's only used with (->) with a higher-than-rank-0 type.
19:10:43 <Eduard_Munteanu> :k (->)
19:10:43 <lambdabot> ?? -> ? -> *
19:11:36 <Eduard_Munteanu> Oh, alright so you mean (forall (a:*). a) : ?? isn't impredicative.
19:11:48 <Eduard_Munteanu> Or am I way off? :)
19:12:09 <dolio> No, it is impredicative.
19:12:22 <dolio> ?? is the union of multiple kinds.
19:12:22 <lambdabot>  is the union of multiple kinds.
19:12:53 <Eduard_Munteanu> Ah, I don't really get '??' and '?'.
19:12:53 <dolio> The reason (forall (a:*) a) : ?? is that (forall (a:*) a) : *.
19:13:23 <dolio>  ?? is the union of * and #. ? is the union of ?? and (#).
19:13:46 <Eduard_Munteanu> Oh, thanks, it's clearer now.
19:14:10 <Eduard_Munteanu> I don't recall what (#) is, the kind of unboxed tuples?
19:14:15 <dolio> Yes.
19:14:23 <Eduard_Munteanu> I see.
19:17:54 <Teslah> if I'm using the state monad and the state I'm lugging around is (Int,Animal,Bool,City), and I'm using that as the state through my entire program, but all of a sudden I realize I need to add something else to the state so it's (Int,Animal,Bool,City,Bool), what can I do to add that Bool into the state without restructuring every function that uses state in my program? 
19:18:16 <sshc> Teslah: That's a terrible way to structure state
19:18:25 <Teslah> (: Correct me
19:18:28 <Teslah> I was hoping to hear that
19:18:59 <sshc> Teslah: I use records, the state monad, fclabels, and monad-state
19:19:02 <Eduard_Munteanu> Is there any particular reason why (->) isn't ? -> ? -> * ? I would think the compiler can figure how to box/unbox stuff to make things go smoothly.
19:19:03 <sshc> I don't have time to elaborate, sorry
19:19:28 <dolio> Eduard_Munteanu: Unboxed tuples are return-only in GHC.
19:19:41 <Teslah> oh.. alright, well I'll google some of those things, thanks (:
19:19:50 <Eduard_Munteanu> Oh.
19:20:14 <dolio> The rationale being: they're for returning multiple arguments in registers (ideally). To pass multiple arguments in registers, you use multiple arguments.
19:20:46 <dolio> Of the 'a -> b -> ...' form.
19:20:48 <Eduard_Munteanu> It makes sense.
19:23:36 <revenantphx> Teslah: also, type synonyms help
19:23:40 <revenantphx> on a simpler note
19:23:50 <revenantphx> type MyState = (Foo, Bar, Baz)
19:24:05 <revenantphx> but, you'd still have to change any function that unpacks the tuple
19:24:23 <Teslah> right, that's my typical approach 
19:30:41 <Ziphilt> google seems do be being very unfriendly when searching for characters like '#', so i can't find this on my own: i am trying to understand the GHC.Float module because someone else's code uses the F# constructor and functions with "Float#" in their name, and i do not understand what the # means. ghci says parse error when i try to ask what a Float# is
19:31:19 <Ziphilt> s/do/to
19:32:08 <lediable> ?
19:33:04 <Ziphilt> oh hm, apparently google did find me something about unboxed types and the MagicHash extension
19:37:37 <lediable> ..
19:37:58 <Ziphilt> i am trying to modify Gloss to use Double instead of Float
19:38:23 <blackdog> Ziphilt: does http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/primitives.html help at all?
19:38:45 <Ziphilt> yes, i think it does, thank you
19:38:47 <blackdog> basically it's an unboxed float - used for performance reasons. they come with a few extra restrictions.
19:42:18 <gwern> > 18 * 89
19:42:18 <lambdabot>   1602
19:51:03 <lpsmith> gwern, too lazy to open a terminal and start ghci to do your arithmetic?
19:51:07 <lpsmith> :)
19:52:49 * hackagebot Animas 0.2 - Updated version of Yampa: a library for programming hybrid systems.  http://hackage.haskell.org/package/Animas-0.2 (EdwardAmsden)
19:53:51 <lediable> use bc...
19:53:53 <lediable> lol
19:55:08 <lediable> Prelude> (*) 5 6 .... 30
19:55:09 <gwern> lpsmith: as always
19:59:47 <ion> Prelude> foldl (\st v -> case v of "*" -> let (a:b:st') = st in (a*b):st'; n -> read n:st) [] ["5","6","*"]
19:59:50 <ion> [30]
20:00:32 <ion> Oh, wait. That pops from the stack the wrong way. :-P
20:01:06 <groovy2shoes> Last night, oo-oo-ooo, I popped the stack the wrong way...
20:04:18 <ion> (Doesn’t matter with *, but would with e.g. -)
20:12:31 <herzen> god, #haskell is the most active channel I have ever seen. 660 users atm.
20:12:46 <copumpkin> we've been up to 750 or so I think
20:13:21 <Peaker> #python is more active (though far far less interesting!)
20:13:36 <herzen> never joined #pyithon. :)
20:14:28 <copumpkin> also less friendly
20:14:52 <djahandarie> We should go show them who's boss
20:14:59 <copumpkin> damn right
20:15:06 <djahandarie> I got a great idea
20:15:13 <djahandarie> Let's scrape names from their channel
20:15:22 <djahandarie> Then randomly PM them with another person's client
20:15:29 <copumpkin> oh nice
20:15:32 <djahandarie> And tell them if they need any help they should join #haskell
20:15:45 <djahandarie> I'm sure this will work
20:20:35 <ion> A Python fan once told me lambdas/closures have no practical uses, they’re just academic showing off.
20:21:14 <accel> are python lambdas
20:21:15 <accel> real lambdas?
20:21:19 <accel> aren't they leaky?
20:22:40 <ion> Well, they’re quite crippled. You can only put one statement in them and Python doesn’t have something like let … in … or >>= that lets you combine multiple statements into one (to my knowledge; i’d be happy to be proven wrong).
20:23:53 * hackagebot network-enumerator 0.1.2 - Enumerators for network sockets  http://hackage.haskell.org/package/network-enumerator-0.1.2 (JohnMillikin)
20:39:16 <rothwell> python scoping is broken
20:39:21 <rothwell> wouldn't touch lambdas
20:39:41 <rothwell> wouldn't... touch python, but i guess that's besides the point
20:40:04 <rothwell> oh, he's gone
20:41:00 <ddarius> I believe, in later versions, Python's scoping is more or less completely correct.
20:42:11 <rothwell> it wasn't correct in 3.0
20:42:16 <rothwell> haven't tested it since
20:42:25 <ddarius> In what way was it not correct?
20:42:50 <rothwell> silently corrupting outer variables in functions, etc
20:42:59 <ddarius> Elaborate.
20:42:59 <rothwell> i'll see if i can dig up some of the test examples
20:43:05 <copumpkin> ddarius: even with the evil for comprehensions over two variables thing?
20:43:10 <copumpkin> or did they fix that?
20:44:16 <ddarius> Maybe the comprehensions are broken, I don't know the details of those, but for the main function scoping stuff.  Everything seemed pretty much exactly correct, even one or two of the things people complained about.
20:45:09 <rwbarton> Python scoping has some surprising features, like variables escaping from list comprehensions but not generator comprehensions
20:45:24 <copumpkin> http://web.mit.edu/rwbarton/www/python.html
20:45:25 <rothwell> we evaluated a ton of languages for this stuff... i'm trying to find the examples
20:45:34 <rothwell> http://paste.lisp.org/display/120921
20:45:34 <rothwell> there's one
20:45:40 <copumpkin> rwbarton: oh whoops, you spoke!
20:45:48 <rwbarton> One of my favorite topics :)
20:45:48 <rothwell> still trying to find the others... that one wasn't silent failure, at least
20:46:12 <Peaker> Some people want implicit scoping (no variable declarations and no explicit scope spec). Then they have to choose between two consistent schemes:  Global-by-default (simple, but has bad consequences), or local-by-default (makes your "global" functions unreachable, unless you add a quirky rule that unassigned globals are still accessible). Python chose the latter
20:46:12 <rothwell> the middle section is the expected output, obviously
20:46:50 <Peaker> If you assign into a variable in a function, then it is local to that function (syntactically, not chronologically)
20:47:48 <rothwell> not really interested in how it's rationalised... it's broken, in my opinion
20:47:54 <rothwell> if i could find the rest of the examples, i'd elaborate
20:48:35 <rothwell> we used racket scheme as the baseline
20:50:33 <Peaker> rothwell, I'm inclined to agree that it sucks.. I think that implicit scoping inherently sucks
20:50:48 <Peaker> rothwell, But that the simpler global-by-default chosen by Javascript, for example, is even worse
20:51:01 <rothwell> hehe, yeah, javascript had some amusing ones too
20:51:21 <rothwell> what was that one... something to do with 'foreach' i think
20:51:21 <rothwell> i don't really do javascript
20:51:43 <rothwell> indices being silently converted to strings, or something equally insane
20:51:43 <rothwell> it's been a while
20:52:13 <ddarius> Javascript's scoping is definitely broken.
20:52:49 <ddarius> To put it one way, Python should pass the Man or Boy test fine, while Javascript might, maybe, with some contorted code.
20:53:35 <ddarius> That Python makes some poor design choices as far as syntax and defaults, I have no argument against.
20:53:45 <copumpkin> why did drscheme rebrand?
20:54:06 <rothwell> good question...
20:54:30 <ddarius> Because, for some reason, people associate "Scheme" with useless toy implementations with no libraries.
20:54:47 <rothwell> hehe
20:55:18 <parcs> they did a write-up on the name change: http://racket-lang.org/new-name.html
20:55:24 <lispy> perhaps the lack of interesting programs distributed in those languages has some impact there
20:55:36 <monochrom> Soon, people will also associate "Racket" with useless toy implementations and no libraries.
20:56:58 * hackagebot unix-bytestring 0.3.3 - Unix/Posix-specific functions for ByteStrings.  http://hackage.haskell.org/package/unix-bytestring-0.3.3 (WrenThornton)
20:57:06 <ion> monochrom: Well, that can be fixed with a name change, obviously.
20:57:51 <ddarius> monochrom: I doubt that.  DrScheme has pretty extensive libraries, and definitely a serious implementation.
20:58:26 <monochrom> that's good to know. I'm speaking out of experience of countries changing names.
20:58:39 <rothwell> they do have that 'typed racket' stuff, which apparently works well, these days
20:58:46 <monochrom> also political parties changing names.
21:00:02 <accel> https://ccrma.stanford.edu/courses/422/projects/WaveFormat/ <-- so I'm looking at this; and I'm wondering: 
21:00:10 <accel> https://ccrma.stanford.edu/courses/422/projects/WaveFormat/ <-- so I'm looking at this; and I'm wondering:  why is it, in a single file, that part of it is big endian and part of it is little endian?
21:00:37 <ddarius> There are file formats with palindromic endianness.
21:01:03 <monochrom> hehe
21:01:23 <accel> yeah; but I don't understand
21:01:28 <accel> the only logical explaination
21:01:37 <accel> is to easily fuck over little endian and big endian systems
21:01:46 <accel> i.e. both side has to deal with byte shuffeling
21:02:58 <Eduard_Munteanu> That'd be socialistic endianness... everybody has to do the same amount of work. :)
21:03:40 <accel> hell, while we're at it, let's store all data format in 2431-endianess
21:03:49 <accel> if we're going to shuffle bytes, consecutive bytes need not be consecutive
21:04:20 <ddarius> There were middle endian machines, but I think those are all gone now
21:05:02 <Jafet> Eduard: except for the elite PDPs
21:05:14 <accel> hell, gien bytes 4,3,2,1; let's store it at 4, 3 xor 4, 2 xor 3, 1 xor (3 and 4)
21:05:37 <Eduard_Munteanu> Yeah, good biendianness might alleviate it.
21:05:43 <ion> Certain cultures still use a middle-endian date notation. :-P
21:06:01 <copumpkin> I think the endiannesses there
21:06:02 * ddarius uses the (US) military date notation.
21:06:18 <copumpkin> are due to 4-character constants being readable
21:06:25 <ion> ISO 8601 ftw.
21:06:35 <Eduard_Munteanu> Um, how would that go like?
21:06:37 <accel> so has no one written a GUS (Galvis Ultra Sound Patch) importer for haskell?
21:06:58 <ddarius> Probably not.  I'm not really sure why one would.
21:07:43 * ddarius should make his binlog thing and then sit down and pop out file format readers and writers.
21:07:57 <accel> ddarius: what's bin log?
21:07:59 <Eduard_Munteanu> ISO8601 is the same thing as the military convention?
21:08:02 <ddarius> I'm strangely fascinated by file formats.
21:08:23 <accel> ddarius: I'm asking about bin log; not personal hobbies
21:08:55 <accel> is it just me, or does WAVE.hs in the WAVE package look ugly-ish,
21:09:00 <accel> for a haskell piece of source code
21:09:05 <Eduard_Munteanu> Dude, you're not really nice, are you?
21:09:33 <accel> me?
21:09:59 <accel> have you looked at the source? it looks something like I would write (imperative -ish)
21:10:03 <accel> rather than something elegant
21:10:14 <accel> most haskell code I look at makes me go: "whoa, that's elegant; I wish I thought of that"
21:10:24 <accel> this code, I look at and go ... hmm, it's readable without busting out pencil + paper
21:11:32 * hackagebot unix-bytestring 0.3.4 - Unix/Posix-specific functions for ByteStrings.  http://hackage.haskell.org/package/unix-bytestring-0.3.4 (WrenThornton)
21:12:50 <ddarius> Eduard_Munteanu: What I meant is a notation like: 3 Mar 2010.
21:13:06 <Peaker> accel, a criterion for elegance is having to get pencil&paper to be able to understand it?
21:13:21 <Eduard_Munteanu> Ah, that's pretty much unambiguos.
21:15:39 <ddarius> @quote lax.functor
21:15:39 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
21:15:50 <copumpkin> @quote lolcategories
21:15:50 <lambdabot> No quotes match. You type like i drive.
21:15:54 <copumpkin> @quote lolcategory
21:15:54 <lambdabot> tensorpudding says: lolcategory demands moarphisms
21:21:38 <Anpheus> Is this the right channel for learner's questions?
21:22:13 <ddarius> accel: Anyway, to answer your question.  Binlog is my name for a prolog-like language I've partially designed for dealing with binary file formats.  Prolog has a "database" of "facts."  In binlog, the "database" would be the binary file itself.  This would work really well for reading.  Writing would be a little trickier, and updating (without reading and writing back) would be also a bit tricky.
21:22:25 <ddarius> Anpheus: Yes.  It's even more effective when you ask the questions.
21:22:38 <Anpheus> Ok I just wanted to make sure, I forgot if this was the right one.
21:23:31 <Anpheus> I'm trying to learn idiomatic haskell with monads by reimplementing common functions, like minimum, but with say, the Maybe monad instead of using "minimum [] = error "empty list""
21:23:50 <Anpheus> So I'm trying to figure out how to use bind / >>= to implement minimum (x:xs)
21:28:23 <Anpheus> this is what I have, with do:
21:28:37 <Anpheus> minimumM (x:xs) = do { rest <- minimumM xs; return $ min x rest }
21:28:48 <Anpheus> but would that be considered idiomatic? is there a different way of doing it that might be better?
21:29:19 <ddarius> @undo do rest <- minimumM xs; return $ min x rest
21:29:19 <lambdabot> minimumM xs >>= \ rest -> return $ min x rest
21:29:32 <ddarius> @. pl undo do rest <- minimumM xs; return $ min x rest
21:29:32 <lambdabot> min x `fmap` minimumM xs
21:29:52 <ddarius> Where <$> would be used instead of `fmap` nowadays.
21:30:20 <Anpheus> ok so, wait
21:30:50 <Anpheus> using @ causes lambdabot to do something, and he's got some set of commands for transforming haskell?
21:30:59 <Anpheus> he/she/it of course
21:31:02 <ddarius> She
21:31:09 <Anpheus> Good to know ;)
21:31:16 <Zao> @help pl
21:31:16 <lambdabot> pointless <expr>. Play with pointfree code.
21:31:20 <Anpheus> I see
21:31:23 <Anpheus> @help .
21:31:23 <lambdabot> . <cmd1> <cmd2> [args].
21:31:23 <lambdabot> . [or compose] is the composition of two plugins
21:31:23 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
21:31:29 <ddarius> @wiki Lambdabot
21:31:29 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
21:31:29 <Anpheus> huh
21:31:35 <Anpheus> @help undo
21:31:35 <lambdabot> undo <expr>
21:31:35 <lambdabot> Translate do notation to Monad operators.
21:31:35 <Zao> She also listens to private messages :D
21:31:41 <Anpheus> oh ok
21:31:53 <Anpheus> wow that's very helpful
21:32:13 <Anpheus> so let me get this straight
21:32:58 <Anpheus> No, actually, could someone explain in plainer english what the fmap / <$> operator does?
21:33:09 <Anpheus> It appears to be similar to $ except the result is monadic
21:33:49 <ddarius> :t fmap
21:33:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:34:00 <Zao> The plain answer is: "it's fmap, lol".
21:34:02 <ddarius> @src Maybe fmap
21:34:02 <lambdabot> fmap _ Nothing       = Nothing
21:34:02 <lambdabot> fmap f (Just a)      = Just (f a)
21:34:21 <ddarius> fmap is a generalization of map for lists.
21:35:41 <ddarius> Anpheus: If you replace 'return' with 'pure' from Control.Applicative, your code will be even more generic.
21:36:35 <Anpheus> Well you guys sure don't pull any punches, here I thought I'd be playing around with monads, and now I've got Functor and Applicative all up in here.
21:36:57 <ddarius> Every monad is a functor and an applicative functor.
21:37:10 <Anpheus> ok
21:37:11 <ddarius> fmap is liftM.
21:37:17 <ddarius> :t liftM
21:37:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:37:40 <monochrom> You need more examples, not more english (or chinese, or sanskrit...)
21:38:01 <djahandarie> Anpheus, you should have played with Functor first, then we wouldn't be able to mess you up with the other two :)
21:38:05 <monochrom> Take a look at what fmap for list does, and what fmap for Maybe does, and what fmap for IO does...
21:38:12 <ddarius> Anpheus: The thing to notice is that in the "fmap" version of the cons case of minimumM, you really aren't using anything monadic.  Namely, you aren't using bind (>>=), just return.
21:38:24 <adorablepuppy> Pretty new to haskell, been dancing around using it for years, recently decided to get my hands dirty. But all the data structures I make seem to find their way to looking like normalized sql tables ( or rows ), is there a good document around on data structures?
21:38:51 <ddarius> What's wrong with normalized sql tables?
21:38:51 <Anpheus> I see
21:39:02 <djahandarie> adorablepuppy, purely functional data structures can get fairly complicated
21:39:05 <Zao> Why hasn't anyone confused things further with the ((->)lol) monad yet?
21:39:28 <djahandarie> Zao, because all the people here are trying to actually help
21:39:38 <symbolsmith> Zao: what is the ((->)lol) monad?
21:39:43 <adorablepuppy> Nothing is wrong with normalized SQL table, in fact, I do most of my work inside pl/pgsql, but I wanted to goto MACID for a small web application I'm making.
21:39:55 <quotemstr> Do zippered binary trees stay balanced?
21:39:56 <Zao> symbolsmith: I don't know, but I hear that it's quite awesome.
21:40:16 <Zao> symbolsmith: Something that through magic lets you say fmap for it being (.) or something.
21:40:49 * Zao is on thin knowledge ice.
21:40:53 <symbolsmith> oh!
21:41:24 <Eduard_Munteanu> @src Reader
21:41:24 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:41:34 <Eduard_Munteanu> @src ReaderT
21:41:35 <lambdabot> Source not found. Where did you learn to type?
21:41:42 <Eduard_Munteanu> Crap.
21:41:45 <Anpheus> lambdabot is not giving me source in a private chat
21:42:06 <ddarius> Zao: The impressive way to say it is that it is the covariant hom functor.
21:42:15 <djahandarie> quotemstr, no.
21:42:44 <djahandarie> adorablepuppy, you can take a look at Okasaki's papers and books if you want to learn more about data structures in purely functional languages
21:42:45 <Eduard_Munteanu> quotemstr: why would they?
21:43:01 <adorablepuppy> djahandarie, thanks. Will do.
21:43:17 <djahandarie> I'd recommend getting more familiar with Haskell before diving into that though
21:43:36 <Zao> Anpheus: worksforme.
21:43:54 <Zao> djahandarie: Sounds like excellent sunday morning readings.
21:44:16 <ddarius> Okasaki's work is pretty impressive.
21:44:20 <Anpheus> Zao: figured it out, :t doesn't work in private chat but @type does
21:44:24 <danharaj> <3 Okasaki's book
21:44:51 <adorablepuppy> djahandarie: I'm trying to learn haskell by solving practical problems that I need to solve, otherwise, it never quite sticks withme
21:44:53 <Eduard_Munteanu> I want edwardk to write a book!
21:45:09 <ddarius> Eduard_Munteanu: He is actually involved in a few.
21:45:12 <djahandarie> adorablepuppy, then learn how to use existing data structures, not how to implement them.
21:45:22 <djahandarie> ddarius, he has published ones?
21:45:33 <Eduard_Munteanu> Oh. Well, I mean a book on his category-extras :)
21:45:33 <ddarius> djahandarie: I don't think so, but I don't recall for sure.
21:45:40 <ddarius> I know he is working with Dan Friedman on one.
21:45:46 <ddarius> Plus one or two others.
21:45:53 <Anpheus> Ok, so what exactly does this mean in the type of fmap: 01forall a b (f :: * -> *).01, in particular, the (f :: * -> *)
21:46:02 <djahandarie> I see
21:46:04 <Zao> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html <- this fine gentleman, I assume?
21:46:09 <djahandarie> Zao, yes.
21:46:18 <ion> Is there a reason Data.Map doesn’t come with an Applicative instance?
21:46:23 <Eduard_Munteanu> On a related note, I think I've seen one or two familiar names (familiar from here) mentioned in TAPL.
21:46:27 <djahandarie> Anpheus, that is providing the kind of f.
21:46:31 <ddarius> ion: What's pure?
21:46:33 <djahandarie> :k Maybe
21:46:34 <lambdabot> * -> *
21:46:48 <djahandarie> :k IO
21:46:49 <lambdabot> * -> *
21:47:00 <ion> Hm, good point. :-)
21:47:15 <ddarius> ion: Perhaps you want the semigroupoid package.
21:47:19 <Zao> @kind Int
21:47:20 <lambdabot> *
21:47:24 <Anpheus> Is that essentially saying it is a function from a type to a type? That is, if a is a type, then Maybe a is another type?
21:47:32 <djahandarie> Anpheus, exactly.
21:47:32 <ddarius> Anpheus: Yes.
21:48:18 <Anpheus> I see, and normally haskell infers this "forall" bit and you don't *have* to enter it, strictly speaking, but you may, just like Haskell will infer many other types for you?
21:48:27 <ion> ddarius: Thanks
21:48:36 <ddarius> Anpheus: You actually can't enter it in Haskell 98/2010.
21:48:49 <Anpheus> Oh, huh
21:49:10 <Anpheus> Why the use of that notation by lambdabot then? Or is it just informational?
21:49:13 <monochrom> there is an extension to let you enter "forall" at will.
21:49:14 <Eduard_Munteanu> Though GHC gladly accepts it without any pragmas, IIRC
21:49:22 <djahandarie> Anpheus, it's a language extension. The forall becomes useful when you start using it elsewhere
21:49:28 <monochrom> that extension also displays "forall" left right and centre
21:49:33 <ddarius> Anpheus: lambdabot has many extensions turned on, and GHC displays types different when different extensions are turned on.
21:49:41 <Anpheus> I see
21:49:44 <danharaj> forall allows you to talk about more complicated types than you can infer, so it is required for some extensions that are not part of the original standard.
21:50:05 * ddarius has no idea why at least rank-2 types aren't standardized yet.
21:50:06 <monochrom> lambdabot is loaded with a few privileged people's private agenda and is not easily reproducible on a stock ghci.
21:50:17 <danharaj> propaganda bot
21:50:27 <monochrom> observe:
21:50:28 <Zao> Depending on what fancy extensions you use, you need to poke the types system explicitly in the eye at times.
21:50:29 <monochrom> @type (++)
21:50:30 <lambdabot> forall m. (Monoid m) => m -> m -> m
21:50:37 <Zao> As the more awesome systems tend to be somewhat undecidable at times.
21:50:47 <djahandarie> ddarius, "at least"? You think rank-n types should be standardized?
21:50:49 <ddarius> I think flip, (.), and (++) are the only redefined functions.
21:50:52 <ddarius> djahandarie: Yes.
21:50:53 <Jafet> Or simply to use existentialist types.
21:51:15 <danharaj> existentialist types, that's an amusing idea
21:51:16 <djahandarie> ddarius, do you also think Haskell should become dependently-typed?
21:51:19 <Anpheus> Existentialist types?
21:51:20 <Anpheus> Hah!
21:51:21 <ddarius> djahandarie: No.
21:51:31 <Jafet> Err
21:51:39 <Anpheus> Should Haskell support dependently typed modules?
21:51:47 <danharaj> That's a political question :o
21:51:56 <Anpheus> Sure it is, I'm curious
21:52:06 <ddarius> Er, sorry djahandarie, that was meant for danharaj.
21:52:06 <djahandarie> ddarius, where are you drawing the line? Rank-n types can cause the type inference to become undecidable
21:52:13 <Eduard_Munteanu> Rank-2 types are pretty much needed anyway.
21:52:14 <ddarius> Or never mind.
21:52:18 * ddarius is so confused.
21:52:30 <djahandarie> ddarius, think of how confused I am right now, you're using my name
21:53:08 <Jafet> Is that why none of the Simons actually go by "simon" in here?
21:53:16 <ddarius> djahandarie: Dependent typing and parametric polymorphism are total different axes (literally in the lambda cube.)  They have totally different semantics, consequences, and uses.  I don't care about type inference being undecidable or not.
21:53:27 <ddarius> Jafet: Simon Peyton Jones goes by simonpj.
21:53:34 <Zao> Is there a rank-k to mix in with rank-n, or am I thinking of some other concept with -k and -n?
21:53:40 <djahandarie> Okay.
21:53:54 <Eduard_Munteanu> Zao: k usually means a fixed number
21:54:01 <Jafet> Sounds like a seniority thing.
21:54:03 <djahandarie> I'd just get dependent types if we make type inference undeciable.
21:54:16 <djahandarie> I don't give a damn about the lambda cube!
21:54:25 <djahandarie> I only care about CoC ;)
21:54:32 <Eduard_Munteanu> Heh.
21:54:37 <ddarius> djahandarie: You know where to find CiC if you want it.
21:54:58 <Anpheus> CoC = calculus of constructions, CiC = calculus of inductive constructions?
21:55:01 <ddarius> That said, most languages with advanced type systems are already off the lambda cube in various ways.
21:55:02 <djahandarie> Anpheus, yes
21:55:42 <ddarius> djahandarie: I would think you'd want a pure type system if you were going that route.
21:55:55 <ddarius> (The lambda cube is somewhat arbitrary.)
21:56:13 <djahandarie> A pure type system?
21:56:35 <danharaj> It's all about data structures defined category theoretically.
21:56:38 <djahandarie> What would a impure type system be?
21:56:38 <danharaj> B)
21:56:41 <ion> The time cube is the way to go.
21:57:00 <ddarius> @where pts
21:57:00 <lambdabot> I know nothing about pts.
21:57:04 <ddarius> Kuso.
21:57:31 <Eduard_Munteanu> Zao: for example, rank-2 types are decideable (not sure if fully), so you could say rank-k type for k <= 2 is decidable
21:57:36 <Anpheus> ion: all types are defined four times simultaneously?
21:57:38 <Eduard_Munteanu> Rank-n usually implies forall n
21:57:50 <Eduard_Munteanu> s/<=/=/
21:57:51 <djahandarie> Chikushou!
21:58:35 <Eduard_Munteanu> However, I'm not sure if there's partial decidability even for an arbitrary k as long as it's fixed.
21:58:50 <monochrom> hahaha
21:59:07 <danharaj> rank 2 is fully decidable, rank 3 is not fully decidable
21:59:22 <monochrom> perhaps c++ satisfies "all types are defined four times simultaneously"
21:59:31 <ion> Hah
22:00:32 <ddarius> djahandarie: The lambda cube is what you get when you have two sorts.  One classifying values (types) and one classifying types kinds, (i.e. you have a value level and a type level.)  Now you can consider dependencies between these two levels in different ways (and we always allow value depends on value, though that's arbitrary too.)
22:00:36 <Eduard_Munteanu> I'm also unsure how "much" undecidable is rank-n
22:00:57 <Eduard_Munteanu> Perhaps some inferences can be made, regardless.
22:01:16 <ddarius> djahandarie: But why only two sorts?  Why a "linear" order?  Why not arbitrary sorts and arbitrary graphs of dependencies?
22:01:54 <djahandarie> ddarius, right.
22:02:05 <Eduard_Munteanu> Like... dependent sorts? :)
22:02:07 <ddarius> That's what you get with a pure type system.  All the levels syntactically flatten to one, they are differed simply by which sort you use to parameterize in the single Pi binder.
22:02:09 <Eduard_Munteanu> Crazy stuff.
22:02:25 <ion> C++ has 4 corner simultaneous 4 instance class cube in only one-template compilation. 4 corner instances, cubes 4 quad-class C++. No 1 instance superclass.
22:02:26 <ddarius> Eduard_Munteanu: No, dependent types are simply types that can depend on the value level.  
22:02:50 <Anpheus> ion: I think I had template metaprogramming explained to me like that once.
22:02:58 <Eduard_Munteanu> Yes, I know.
22:03:08 <Eduard_Munteanu> But you think dependent sorts are unimaginable?
22:03:26 <ddarius> Eduard_Munteanu: In some ways, that doesn't make sense.
22:03:31 <djahandarie> ddarius, this is essentially what CoC/CiC/Coq/Agda/etc does, right?
22:03:36 <ddarius> djahandarie: No.
22:03:46 <djahandarie> Don't they collapse the type hierarchy?
22:04:07 <Anpheus> Is there a paper online that can explain the relations between Monad, Functor and Applicative?
22:04:08 <Zao> Eduard_Munteanu: Ah, right. That's how k and n work in general.
22:04:13 <ddarius> Or at least, they do insofar as all instances of the lambda cube are instances of pure type systems.
22:04:21 <ddarius> @where typeclassopedia
22:04:21 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
22:04:23 <applicative> @where Typeclassopedia
22:04:23 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
22:04:26 <applicative> grrr
22:04:28 <Zao> Eduard_Munteanu: I now remember which context I was thinking of, it was k-clique and n-clique.
22:04:40 <Eduard_Munteanu> Ah, I don't know that.
22:05:39 <Zao> A k-vertex clique is a complete subgraph with k vertices.
22:05:51 <Anpheus> ddarius, applicative: thanks
22:06:15 <Anpheus> Wait
22:06:22 <Anpheus> fmap fmap fmap is
22:06:26 <Anpheus> that's a real thing?
22:06:29 <Zao> It was a bad likeness though, as n-clique is something completely unrelated.
22:06:31 <djahandarie> It is.
22:06:34 <Eduard_Munteanu> :t fmap fmap fmap
22:06:35 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:06:44 <Zao> (a n-clique has a different metric for "fully connected")
22:06:46 <djahandarie> @type fmap Prelude.. fmap
22:06:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:07:29 <quotemstr> Wait a second -- the *generic* definition of a zipper doesn't permit "modification" of the data structure. That'd be a new operation specific to the data type under discussion, right?
22:07:36 <Anpheus> What use case would <$> <$> <$> or fmap fmap fmap have?
22:07:37 * quotemstr is trying to understand generic data structures.
22:07:44 <Jafet> @google fmap fmap
22:07:45 <lambdabot> http://www.haskell.org/pipermail/reactive/2008-November/000049.html
22:07:45 <lambdabot> Title: [reactive] To fmap fmap or not?
22:07:49 <quotemstr> s/generic/functional/it's-too-goddamned-late
22:07:57 <quotemstr> What's a good resource for functional data structures in general?
22:08:15 <Eduard_Munteanu> quotemstr: it does, though not in the sense of imperative, in-place mutation.
22:08:33 <Eduard_Munteanu> (impure)
22:08:36 <Jafet> quotemstr: the nice thing about a zipper is that it lets you make a new zipper that shares all of the old data structure except the part that you're modifying.
22:08:58 <applicative> > fmap fmap fmap even [Just 2]
22:08:59 <lambdabot>   [Just True]
22:09:20 <Eduard_Munteanu> If this is about trees, then structural mutation might be a little bit more complicated than value mutation.
22:09:31 <Eduard_Munteanu> (in some cases)
22:09:38 <Anpheus> applicative: did you just map something three levels deep?
22:09:49 <quotemstr> Right.
22:09:55 <Jafet> Or most of the zipper, for knottier data structures
22:09:56 <Anpheus> ... fmap is the inception operator?
22:10:05 <Eduard_Munteanu> Heh.
22:10:33 <Anpheus> well that actually makes it make a lot more sense than it ever did before
22:10:40 <quotemstr> Essentially, I'm looking at implementing an n-ary functional tree with arbitrary key-value associations on each node --- this is for a backtracking parser that builds an AST.
22:10:44 <applicative> > fmap (fmap even) [Just 2]
22:10:44 <lambdabot>   [Just True]
22:11:02 <Anpheus> wait
22:11:03 <quotemstr> The zipper abstraction seems appropriate, but it seems it'd be complicated as the types involve become complicated.
22:11:04 <Anpheus> why
22:11:10 <Anpheus> there's one fewer fmaps in that one
22:11:49 <Eduard_Munteanu> quotemstr: make a polymorphic tree, write some primitives for navigating it and then specialize it.
22:11:56 <Jafet> quotemstr: where does mutation come in?
22:12:40 <quotemstr> OTOH, it might be simpler to just use this approach instead: represent the "tree" as a linear stack of operations to perform on the tree. Just push and pop from this stack during parsing. Then, if we need a tree representation, we build it lazily from the list of tree-modification operations.
22:13:12 <quotemstr> Jafet: It doesn't --- from a tree T, I need to generate a new tree T', where T' is different in adding a node, setting (or resetting) a node property, and so on.
22:13:26 <djahandarie> Does anyone remember that one site that explaining floating point numbers really nicely in like 3 paragraphs?
22:14:03 <Jafet> They sound like really really long paragraphs
22:14:18 <Jafet> quotemstr: sure, you can call that mutation.
22:14:19 <quotemstr> The problem with my lazy-tree-building approach is that different instances of the compiled tree can't share structure, so it would have to be built a new each time it's needed.
22:14:24 <quotemstr> Jafet: Ah, okay.
22:15:00 <ddarius> quotemstr: The goal in that approach would be for it not to be needed very often.  And you could, conceivably memoize.
22:15:06 <djahandarie> Found it: http://floating-point-gui.de/
22:15:30 <quotemstr> Oh, and this isn't even Haskell: it's Lisp. I'm just asking you guys because you guys would know the most about functional data structures. :-)
22:15:34 <Eduard_Munteanu> quotemstr: zippers are usually great for local mutations: modifications that don't require you to look very far from the current node.
22:15:49 <applicative> > let o f g x = f (g x) in ( fmap `o` fmap) even [Just 2]
22:15:49 <lambdabot>   [Just True]
22:16:21 <Jafet> "Backtracking parser" still conjures up recursive descent for me
22:16:22 <quotemstr> Eduard_Munteanu: Well, imagine we're parsing a C program and we come across a new typedef. We have to both add an AST node for the typedef-statement *and* update the list of type definitions in effect in the current scope.
22:16:32 <quotemstr> Jafet: I've convinced myself they're isomorphic.
22:16:38 <Eduard_Munteanu> Incidentally some (all?) zippers happen to be comonadic.
22:16:44 <Jafet> Okay, that's not really recursive.
22:16:59 <quotemstr> So creating a zipper for the whole type seems non-trivial.
22:17:21 <Eduard_Munteanu> Uh, I've kinda ran into that.
22:17:41 <wharzl> heya, I'm looking to hire someone to write a language in haskell
22:17:51 <Eduard_Munteanu> Zippers aren't so great if you need to keep multiple focuses _and_ share mutations across them.
22:18:06 <wharzl> not big corporate money, but a fun project which is compensated
22:18:22 <quotemstr> I mean, in this *particular* example, I know how to represent the entire type-zipper as a composition of its component types. But that's manual.
22:18:51 <quotemstr> The grammars are composable so the data manipulation needs to happen automatically.
22:19:23 <applicative> Anpheus: fmap fmap fmap is basically fmap . fmap 
22:19:25 <quotemstr> ddarius: Good idea. It should be possible to memoize subtrees.
22:19:54 <Eduard_Munteanu> wharzl: you might also want to try here http://www.haskellers.com/
22:19:59 <applicative> @type let o f g x = f ( g x) in (fmap fmap fmap, fmap `o` fmap)
22:19:59 <Anpheus> applicative: yeah, and "fmap fmap fmap fmap fmap fmap fmap fmap" is "fmap . fmap . fmap"
22:20:00 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f2 :: * -> *) a1 b1 (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => ((a -> b) -> f (f1 a) -> f (f1 b), (a1 -> b1) -> f2 (f3 a1) -> f2 (f3
22:20:00 <lambdabot> b1))
22:20:00 <wharzl> anyone know where I can post this to haskell hackers?
22:20:09 <wharzl> Eduard_Munteanu, ok :)
22:20:27 <applicative> Anpheus: I see, you are with spirit of things, then :)
22:20:41 <Anpheus> I'm fmapping away.
22:20:51 <Eduard_Munteanu> wharzl: also you might want to look into the mailing list, also I'm not sure about the policy on such things
22:21:03 <Eduard_Munteanu> I suppose asking here is alright too.
22:21:12 <applicative> lamdabot's definition of (.) was getting in my way for a second
22:21:50 <quotemstr> Anyway, I'd appreciate a pointer to some material on functional data structures in general.
22:22:09 <Eduard_Munteanu> quotemstr: Okasaki's book is nice, I hear
22:22:20 <Anpheus> applicative: Using . is effectively function composition, so "fmap . fmap . fmap ..." is fmap(fmap(fmap ...) right?
22:22:42 <applicative> Anpheus: in lambdabot we get 
22:22:48 <applicative> @type (.)
22:22:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:22:55 <applicative> so it's already generalized to fmap
22:22:55 <Eduard_Munteanu> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
22:23:01 <Eduard_Munteanu> Hrm, seems to be available online.
22:23:07 <Eduard_Munteanu> @where okasaki
22:23:07 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
22:23:55 <quotemstr> Eduard_Munteanu: "Purely Functional Data Structures", the CMU thesis?
22:24:01 <quotemstr> Ah. Thanks.
22:24:07 <applicative> > ( (.).(.) ) even [Just 2]
22:24:08 <Eduard_Munteanu> Also, it's not Haskell-specific.
22:24:08 <lambdabot>   [Just True]
22:24:09 <quotemstr> Just what I wanted to curl up with. :-)
22:24:10 <Jafet> I thought Okasaki focused on formal complexity analysis.
22:24:14 <Anpheus> > fmap . fmap . fmap $ even (Just [Just 2])
22:24:15 <lambdabot>   <no location info>: lexical error at character '\ETX'
22:24:23 <Anpheus> bah copy paste issue
22:24:33 <Eduard_Munteanu> He does, after all, it's quite a formal book.
22:24:37 <Anpheus> > (fmap . fmap . fmap) even (Just [Just 2])
22:24:38 <lambdabot>   <no location info>: lexical error at character '\ETX'
22:24:56 <Anpheus> > (fmap . fmap . fmap) even (Just [Just 2])
22:24:57 <lambdabot>   <no location info>: lexical error at character '\ETX'
22:25:04 <applicative> $ associates to the right,
22:25:06 <Anpheus> I swear this was wroking
22:25:09 <Eduard_Munteanu> It's not just a book of recipes.
22:25:10 <Anpheus> working'
22:25:18 <Anpheus> Yeah I copy-pastad the wrong one
22:25:26 <Jafet> It's useful to read, of course, but I'm not sure if it helps with this sort of thing.
22:25:56 <Anpheus> > (fmap . fmap . fmap) even (Just [Just 2])
22:25:57 <lambdabot>   Just [Just True]
22:26:00 <Anpheus> there
22:26:01 <Eduard_Munteanu> On zippers, I liked the Wikibooks: http://en.wikibooks.org/wiki/Haskell/Zippers
22:26:12 <Eduard_Munteanu> Well, if you skip the whole Theseus story :)
22:26:39 <Eduard_Munteanu> Quite formal and still readable.
22:26:54 <Anpheus> So applicative, if (.) is generalized to fmap, is the reason for the difference due to . being infix and fmap being prefix? that is... let me try this
22:27:02 <djahandarie> Eduard_Munteanu, have you read the LYAH section on them?
22:27:02 <Eduard_Munteanu> quotemstr: you might want to check that out too ^
22:27:07 <Anpheus> > (fmap `fmap` fmap `fmap` fmap) even (Just [Just 2])
22:27:08 <lambdabot>   Just [Just True]
22:27:38 <Eduard_Munteanu> djahandarie: I remember skimming over it, but it looked like a long story. Besides I was interested in zippers via differentiation in the general case.
22:27:47 <Eduard_Munteanu> Not doing it just for lists and some trees.
22:27:53 <djahandarie> I see.
22:28:09 <Eduard_Munteanu> Not to say it's bad, though.
22:28:31 <applicative> Anpheus: It's infix, yes, but that's just syntactic nonsense.  It's  a different definition, based on the functor instance for ->
22:29:03 <quotemstr> Jafet: What's wrong with recursive descent?
22:29:14 <Anpheus> No I mean, the reason why "fmap fmap fmap" is not the same as "fmap . fmap" or "fmap `fmap` fmap", is because they are syntactically different, the former from the latter two.
22:29:33 <Jafet> I dunno, I didn't say there was anything wrong with it.
22:29:43 <Anpheus> Although I've no idea why to get "fmap . fmap . fmap" you have to do "fmap fmap fmap fmap fmap fmap fmap fmap"
22:30:07 <quotemstr> Jafet: Fair enough.
22:30:16 <quotemstr> Eduard_Munteanu: Thanks.
22:34:52 <Anpheus> Thanks for everything everyone, until another night
22:39:30 <gienah> quotemstr: recursive descent a very powerful parsing technique, as can be seen in practice by noting that most C++ compilers use recursive descent
22:39:44 <quotemstr> Is the running time of a program in a lazily-evaluated language like Haskell at least as short as that of the same program run with eager evaluation semantics? (Of course, the eagerly-evaluated version may never finish, which is a special case of the preceding.)
22:40:01 <wharzl> haskellers won't send me a verification link :(
22:40:15 <wharzl> also looks a little under-populated
22:40:56 <roconnor> > deriv (\x-> x^2*sin(1/x)) x
22:40:57 <lambdabot>   (1 * x + x * 1) * sin (1 * recip x) + x * x * (1 * negate (1 * recip x * re...
22:40:57 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
22:43:55 <copumpkin> > deriv (\x-> x^2*sin(1/x)) y
22:43:56 <lambdabot>   (1 * y + y * 1) * sin (1 * recip y) + y * y * (1 * negate (1 * recip y * re...
22:44:01 <copumpkin> > deriv (\x-> x^2*sin(1/x)) f
22:44:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:44:01 <lambdabot>    `GHC.Float.Floating a'
22:44:01 <lambdabot>  ...
22:51:53 <roconnor> @tell RayNbow`TU fixed
22:51:53 <lambdabot> Consider it noted.
23:19:50 * hackagebot timers-updatable 0.2.0.2 - timers which are updatable in the remaining time  http://hackage.haskell.org/package/timers-updatable-0.2.0.2 (PaoloVeronelli)
23:20:05 <wharzl> well, I shot up a post at haskell-cafe :)
23:20:14 <wharzl> hope there's some responses
23:32:36 <kamatsu> is anyone here good at theory of computation? particularly context free languages/proofs? I have a homework question I'm having trouble with, and I was wondering if anyone could give me a hint.
23:33:35 <c_wraith> kamatsu: I'm sure lots of people around here could help.
23:39:54 <kamatsu> there's alot of people here who know about PLs, but i don't know about other theoretical CS
23:40:17 <Eduard_Munteanu> Why not just go ahead and ask your question completely?
23:40:26 <djahandarie> Context free languages are pretty closely related to PLs anyways
23:40:42 <c_wraith> most anyone who's gone through a CS program knows *something* about computation
23:41:02 <kamatsu> prove that the complement of L = { w w | w in {0,1}* } is, in contrast to L, context free.
23:41:27 <kamatsu> don't give me an answer, that'd be cheating
23:41:38 <kamatsu> :P
23:41:53 <Eduard_Munteanu> And your question is... ? "Where do I start?"?
23:41:57 <kamatsu> yeah
23:42:06 <kamatsu> i guess i need to come up with a PDA that recognizes it?
23:42:53 * hackagebot monad-memo 0.2.0 - Memoization monad transformer  http://hackage.haskell.org/package/monad-memo-0.2.0 (EduardSergeev)
23:46:36 <djahandarie> kamatsu, you could derive it from the pumpping lemma
23:46:44 <djahandarie> I think.
23:46:50 <djahandarie> This would be proving it for all languages though
23:47:18 <kamatsu> pumping lemma goes the other way, to prove something is not context free
23:47:24 <kamatsu> doesn't give a characterization of context free langs
23:48:00 <kamatsu> there are non-CFLs that still pump
23:51:08 <djahandarie> I'm not sure there is any other way to do this besides what you said then.
23:52:02 <djahandarie> I was originally thinking that the pumping lemma would let you talk about the complement of any non-context-free language, but I don't think it works
23:53:22 <kamatsu> the only other possibility I thought of was to express L as some union/intersection of other sets
23:53:30 <kamatsu> and then negate it
23:53:50 <kamatsu> and maybe i could use some already established result to show that it is context free
23:53:57 <c_wraith> You could also just come up with a context-free grammar describing it.
23:54:12 <djahandarie> c_wraith, that is equiv to finding a PDA for it
23:54:22 <c_wraith> equivalent, yes, but sometimes easier to think in terms of
23:54:43 <c_wraith> What's the normal form that guarantees context-free?  chomsky?
23:54:48 <kamatsu> yes
23:55:34 <c_wraith> It's been a while, for me. :)
23:57:14 <kamatsu> the problem i'm getting is that it's really hard to imagine a grammar or pda that recognizes any binary string except those which can be split into two identical strings.
23:58:14 <c_wraith> well, you could work piecewise.  Anything with an odd length is accepted.
23:58:21 <c_wraith> Then you just narrow it down to the hard case. :)
23:58:25 <kamatsu> hm
23:58:37 <kamatsu> i don't think that helps
23:58:41 <c_wraith> Not really.
23:58:46 <c_wraith> All the difficulty is in the other case, anyway
23:59:11 <kamatsu> it's easy enough to make it reject palindromes.
23:59:22 <c_wraith> but palindromes aren't the question
23:59:25 <kamatsu> yeah
23:59:26 <kamatsu> hm
