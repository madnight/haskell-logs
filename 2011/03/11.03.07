00:27:09 * hackagebot authenticate-oauth 0.1 - OAuth client support for authenticate package.  http://hackage.haskell.org/package/authenticate-oauth-0.1 (HiromiIshii)
00:29:44 <sgronblo_> Ok I've read a bit about monads now in LYAH. I was wondering how it works for Maybe monads if you chain a gazillion of them where one of the first invocations of a function called with >>= returns a Nothing, will haskell still push the Nothing through all the rest of the functions?
00:30:27 <Wyrmling> I'm having some trouble making a function tail-recursive - first time doing it. This is what I have at the moment: http://codepad.org/hb0SC3bO. And yes, this is homework.
00:30:52 <mauke> introduce an accumulator
00:31:47 <Wyrmling> mauke, But I thought Haskell 'variables' are constants and immutable.
00:32:14 <mauke> yes
00:32:46 <Wyrmling> Are you implying.. I should make the function (Integral a) => a -> a -> a ?
00:32:51 <mauke> yes
00:32:54 <Wyrmling> ...
00:32:56 <Wyrmling> Damn it..
00:33:00 <Wyrmling> Is that the only way to do it? =/
00:33:04 <mauke> why?
00:33:14 <Wyrmling> Dunno. It just isn't as pretty =p
00:33:32 <mauke> well, you can leave the outer interface the same
00:33:39 <Wyrmling> Yeah, I'm aware.
00:33:47 <mauke> but yeah
00:33:59 <Wyrmling> Right..
00:34:10 <Wyrmling> I don't suppose Haskell support 'default argument values'?
00:34:40 <ion> That would clash badly with currying.
00:34:44 <Wyrmling> I see.
00:34:57 <mauke> suppose f is a function with a default argument. is 'f' a call to f or just the function itself?
00:35:33 <Wyrmling> Oh well.
00:36:56 <raek> sgronblo_: I'm a newbie, so my understanding might be wrong, but the definition of the Maybe monad is (Just x) >>= f = f x    Nothing >>= f = Nothing   In the Nothing case, f is never used so that seems to imply that the Nothing value won't be pushed though all the other functions
00:38:34 <sgronblo_> raek: Yeah I thought that it might work like that too
00:39:16 * hackagebot yesod-auth-oauth 0.4 - OAuth wrapper for yesod-auth  http://hackage.haskell.org/package/yesod-auth-oauth-0.4 (HiromiIshii)
00:40:31 <mm_freak_> Wyrmling: haskell variables are variables, not constants
00:40:38 <mm_freak_> but they are immutable
00:40:48 <Wyrmling> mm_freak_, what's the difference?
00:40:59 <mm_freak_> difference is that constants always have the same value
00:40:59 <Wyrmling> immutable variable vs constants.
00:41:11 <mauke> f x = x + 1
00:41:16 <ion> wyrmling: Also, triangleNumber n = n*(n+1) `div` 2 ;-)
00:41:19 <mm_freak_> you can consider a top-level variable as a constant
00:41:19 <mauke> ^ x here can have different values at runtime
00:41:29 <Zao> Variables and constants as in math.
00:41:30 <Wyrmling> ion, Yeah, but I'm required to do recursion =p
00:41:35 <mm_freak_> like "x :: Integer; x = 3" in the top level
00:41:38 <Wyrmling> mauke, Ah, okay.
00:41:56 <mm_freak_> if haskell allowed only constants, it would be quite difficult to work with =)
00:42:03 <Wyrmling> Zao, but math doesn't have 'immutable variables'.
00:42:11 <Wyrmling> mm_freak_, yes, I see what you did there. ;p
00:42:18 <mauke> Wyrmling: then what is 'f x = x + 1'?
00:42:19 <mm_freak_> Wyrmling: math doesn't have /mutable/ variables (usually)
00:42:49 <Wyrmling> As far as my understanding goes, in maths, variables are simply variables.
00:43:00 <mm_freak_> so they are in haskell =)
00:43:02 <Wyrmling> There's like.. no need to differentiate between the mutability.
00:43:11 <m3ga> trying to build ghc from darcs and getting "Maybe you haven't done './darcs-all get'?" but there is no darcs-all script
00:43:24 <mm_freak_> yes, there is need, because most math stuff requires referential transparency
00:43:30 <mm_freak_> and haskell takes this further to programming
00:43:41 <Wyrmling> Hmm.. I've heard that term before.
00:44:10 <mm_freak_> referential transparency means that if you say 'x = y', then you can replace each occurence of x by y everywhere
00:44:28 <mm_freak_> just like in haskell you can replace the function's call by the function's body
00:44:56 <Wyrmling> Right.
00:50:25 <Wyrmling> Okay.. I think I got my accumulator. Time to compile.
00:51:15 <ion> People often use this style to make the definition of the inner function with the accumulator local:
00:51:24 <ion> foo n = foo' n 0
00:51:26 <ion>   where
00:51:31 <ion>     foo' … = …
00:51:39 <Wyrmling> Oh
00:51:43 <Wyrmling> Good tips. Cheers!
00:55:47 <Wyrmling> mauke, ion, http://codepad.org/wnQcOMBJ
00:55:51 <Wyrmling> Thanks for all of your helps.
00:58:40 <ion> wyrmling: There’s also sum [1..n] which does use recursion internally.
00:58:55 <Wyrmling> ion, That's what I did before until you reminded me the better formula ;p
01:10:05 <sphynx> hi! I'm reading "Typeclassopedia" article by Brent Yorgey, quite a nice reading! And I have a question: it is said that monads do not compose as well as Applicatives and then monad transformers are introduced
01:10:39 <sphynx> what is meant here? how can one compose different Applicatives to get smth like Monad transformers?
01:11:06 <quicksilver> direct composition of types
01:11:12 <mm_freak_> sphynx: first of all, you can always combine applicative functors
01:11:31 <quicksilver> if Foo a is applicative and Bar a is applicative, then Foo (Bar a) and Bar (Foo a) are both applicative
01:11:36 <mm_freak_> secondly there is less control flow dependency in applicative style, so you get more composable computations
01:11:38 <sphynx> it's just like combining of functions with (.) but functions are in context?
01:12:05 * mux longs for a <| ... |> syntax for applicative functors
01:12:20 <mux> it would fit just nice with <*>, <$>, etc
01:12:34 <quicksilver> mux: http://personal.cis.strath.ac.uk/~conor/pub/she/ ?
01:13:05 <mux> whoa, this is much interesting and I had no idea this existed
01:13:26 * hackagebot yesod-auth-oauth 0.4.1 - OAuth wrapper for yesod-auth  http://hackage.haskell.org/package/yesod-auth-oauth-0.4.1 (HiromiIshii)
01:17:27 * hackagebot gsmenu 2.2 - A visual generic menu  http://hackage.haskell.org/package/gsmenu-2.2 (TroelsHenriksen)
01:17:41 <sphynx> ok, it seems I got it, thanks :)
01:30:30 <inter> @pl \a -> (:) a (foldr (++) [])
01:30:30 <lambdabot> (: foldr (++) [])
01:31:32 <inter> @pl \a -> (a :) .  (foldr (++) [])
01:31:32 <lambdabot> (. foldr (++) []) . (:)
01:32:01 <mauke> :t foldr (++) []
01:32:03 <lambdabot> forall a. [[a]] -> [a]
01:32:07 <mauke> :t concat
01:32:08 <lambdabot> forall a. [[a]] -> [a]
01:32:09 <Maxdaman1us> :t concat
01:32:10 <lambdabot> forall a. [[a]] -> [a]
01:33:45 <Maxdaman1us> :t (. concat) . (:)
01:33:46 <lambdabot> forall a. a -> [[a]] -> [a]
01:38:32 * hackagebot hakyll 3.0.1.1 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.1.1 (JasperVanDerJeugt)
01:39:07 <Peaker> sphynx, if you're still here, you can look at conal's TypeCompose library. Specifically, at the (:.) type composition operator (the type (f :. g) a = f (g a)) implemented as a newtype - and has an Applicative instance which is the natural composition of its types
01:39:59 <Peaker> @type liftA2 . liftA2
01:40:00 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
01:40:40 <sphynx> Peaker Yeah, I'm here, thanks! I'm re-reading the "Applicativ - Further reading" part of Typeclassopedia and this library is suggested there :)
01:41:15 <Peaker> Since (pure,liftA2) and (pure,<*>) are equivalent in power ((<*>) == liftA2 ($).  liftA2 f x y = pure f <*> x <*> y) -- the above: liftA2.liftA2 gives the type of liftA2  for the type composition
01:41:21 <sphynx> also I downloaded the classic Applicative paper by Patterson and McBride
01:41:58 <Peaker> so we can also get <*> of the composed types from the two <*> of the two types
01:43:06 <Peaker> @type fmap . fmap
01:43:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:43:13 <Peaker> @type liftA2 . liftA2
01:43:14 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
01:43:20 <Peaker> @type pure . pure
01:43:20 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Applicative f, Applicative f1) => a -> f (f1 a)
01:43:31 <Peaker> @type join . join
01:43:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
01:44:34 <Peaker> Building:  (Monad m, Monad n) => m (n (m (n a))) -> m (n a)    from:  m (m a) -> m a   and:  n (n a) -> n a       is impossible.. that's why Monads don't compose
01:45:00 <Peaker> you can build m (m (n (n a))) -> m (n a)
01:45:02 <sphynx> aha, I see, so we can automatically get all the Applicative function "for free" from composing two types of different applicatives and can't do this for monads
01:45:43 <Peaker> yeah.. not just "for free", if we have, "State" and "Maybe" for example, we cannot get the composition's Monad instance from:  State s (Maybe a)
01:47:20 <sphynx> still, I have to play with these things a little bit to develop some intuition
01:48:22 <dibblego> I have this in scala http://blog.tmorris.net/monads-do-not-compose/
01:49:23 <sphynx> dibblego: thanks for the link!
01:49:40 <Peaker> Also note how a naive composition: State s (Maybe a)   s -> (s, Maybe a) .  Whereas:  StateT s Maybe a   yields:  s -> Maybe (s, a)     So the "natural" type composition of State s and Maybe doesn't even have the right structure
01:49:58 <Peaker> dibblego, Scala syntax is so horrible :P
01:50:37 <dibblego> scala syntax is trivial compared to its other problems
01:53:04 <Peaker> sphynx, I wasted some time once trying to make a Monad instance for   State s (Maybe a) -- only to realize the structure is wrong :)
01:53:57 <Peaker> dibblego, IME the JVM is pretty awful, is it the reason you use Scala despite all of its shortcomings?
01:54:12 <dibblego> yes
01:54:25 <Peaker> dibblego, you sound like a masochist
01:54:25 <dibblego> here is why http://programmers.stackexchange.com/questions/51245/what-kind-of-things-are-easy-in-haskell-and-hard-in-scala-and-vice-versa/51333#51333
01:54:32 <dibblego> no
01:55:40 <sphynx> wow, a thorough answer!
02:41:05 <weirdo> is there some kind of cheat sheet with keywords i could print and put on a wall or something?
02:45:11 <DevHC> http://lmgtfy.com/?q=haskell+cheat+sheet
02:48:53 <spirit> i'm trying to build a package with leksah and i'm almost there :-) my package needs -XFlexibleContexts, and i cannot seem to figure out where to put that flag. i tried package->flags build flags, but that did not help. any ideas?
02:49:40 <zenzike> I put that kind of thing in the file itself under a {-# LANGUAGE FlexibleContexts #-} command
02:49:54 <zenzike> I don't know if that's best practice though
02:50:55 <jutaro> spirit: Either you put it in the head of the source file (recommended) or you add it as Package/Extensions in the Package editor.
02:52:51 <spirit> makes sense to have it in the source file in order to be able to build the code outside leksah. works just fine! :-)
02:54:56 <jutaro> spirit: You can build it outside leksah even when you use the package editor, cause it writes a standard cabal file.
02:55:38 <jutaro> But it seems to be common practice to put the extensions in the source files. 
02:56:30 <spirit> that's even more impressive!
03:02:19 <quicksilver> well, source files are higher-resolution than 
03:02:23 <quicksilver> entire packages.
03:04:26 <DevHC> allow me to quote that
03:04:34 <DevHC> lol
03:08:00 <zenzike> quicksilver: agreed, but then you lose track of which extensions are being used in a package (unless there's a way of finding out which language options the source files are importing, but I don't know of such a feature)
03:08:24 <quicksilver> zenzike: yeah, it's more important to have them in the cabal file.
03:08:37 <quicksilver> I was just pointing out a reason for putting them in individual source files too.
03:08:47 <quicksilver> without a way to check you're doing it right it's a slightly annoying to keep them in sync.
03:09:18 <zenzike> yup. maybe it should be yet another bit of information that GHC should spit out
03:14:34 <Peaker> how usable is Leksah?
03:20:18 <Peaker> I think I tried leksah a while ago, got a quick seg fault, gave it up...
03:21:16 <hpaste> e pasted "host"  http://hpaste.org/44579
03:21:31 <jutaro> Peaker: Which OS do you mainly need it for?
03:21:35 <Peaker> Ubuntu
03:23:38 <jutaro> Peaker: Ubuntu is perfect for Leksah. But the version on hackage is quite old now. 
03:24:03 <jutaro> The development repo has just been moved to Github. 
03:24:55 <jutaro> So maybe you wait for the next hackage version? 
03:26:19 <Peaker> jutaro, I'll try the github version sometime..
03:35:46 <Axman6> jlouis: you about?
03:38:39 <sphynx> are there any dictionary data structures which provides amortized O(1) lookup? Smth like HashMap
03:39:34 <sphynx> I've seen that Data.Map has O(log n) lookup
03:39:58 <quicksilver> sphynx: hashmaps are not O(1). You have been lied to.
03:40:20 <Peaker> sphynx, http://hackage.haskell.org/packages/archive/judy/0.2.2/doc/html/Data-Judy.html ?
03:40:26 <quicksilver> O(log n) is the best you can do, after that we just argue about constant factors.
03:40:33 <Axman6> they're only O(1) in fairy land
03:40:37 <Peaker> Hashmaps can be O(1) with a good hash function
03:40:46 <quicksilver> Peaker: no they can't.
03:40:51 <Eduard_Munteanu> With limited inserts maybe.
03:40:52 <quicksilver> the hash function must inspect the entire key.
03:41:02 <quicksilver> so their O(keylen) at best
03:41:06 <Peaker> quicksilver, Ah, heh
03:41:09 <sphynx> well, I mean amortized case :)
03:41:14 <quicksilver> and given distinct keys, keylen >= log n
03:41:34 <quicksilver> O(keylen) == O(log n)
03:41:35 <sphynx> if your hashtable size is big enough you get O(1) as most lists are of length=1
03:41:49 <sphynx> when you get too many element in a bucket - you may resize
03:41:53 <Eduard_Munteanu> "average" O(1), yes.
03:41:56 <Peaker> Well, I interpret "what map structure gives me better than logN" to mean a better constant, really..
03:42:03 <jix> with cuckoo hashing you get guaranteed constnat lookup (ignoring key size)
03:42:07 <quicksilver> sphynx: no, it's the cost of calculating the hash that stops it being O(1)
03:42:17 <quicksilver> sphynx: the cost of calculating the hash is a log n factor.
03:42:25 <quicksilver> (not the number of buckets).
03:42:31 <Peaker> quicksilver, no, the hash could be partial and not look at the entire key.. but lookups would then have to compare the entire key too
03:42:43 <Axman6> though the buckets also add an O(n) factor too no?
03:42:47 <Eduard_Munteanu> quicksilver: if you assume n changes there.
03:42:52 <quicksilver> ...so, lecture being finished, it's really all about constant factor.
03:42:58 <Peaker> Axman6, in the worst case with no guarantee on hash collisions, yeah
03:43:03 <quicksilver> Data.Map is OK, Data.IntMap is quite fast (but only Int keys).
03:43:15 <quicksilver> and there are people working on better structures.
03:43:21 <KitB> Data.HashMap is on it's way
03:43:24 <Peaker> Judy has the best constant factor, doesn't it?
03:43:32 <quicksilver> http://hackage.haskell.org/package/unordered-containers
03:43:35 <Axman6> sphynx: you should look at tibbe's new library.
03:43:42 <quicksilver> ^^ that is tibbe's new library, indeed :)
03:43:42 <Axman6> ... the one quicksilver just pasted
03:43:47 <Axman6> :P
03:43:53 * Axman6 high fives quicksilver 
03:43:58 <KitB> But last time I used it I couldn't get a minimum value out (don't know if that's related to the data structure used or not)
03:44:08 <KitB> s/value/key/
03:44:17 <quicksilver> KitB: you get faster structures if you discard ordering
03:44:30 <quicksilver> hence 'unordered containers' as the package name
03:44:30 <Eduard_Munteanu> Hashtables can't do that either, they're pissy to lookup by anything else than key.
03:44:56 <KitB> As far as I was aware, HashMap used IntMap as its underlying data structure
03:45:06 <Eduard_Munteanu> (They're O(hashsize) to iterate through)
03:45:16 <sphynx> ok, so a lot of choices: Data.Map, Data.IntMap, Data.HashMap and Data.Judy
03:45:31 <Eduard_Munteanu> IntMap is quite fine.
03:45:33 <quicksilver> KitB: no, it doesn't. But it does use something very similar.
03:45:51 <KitB> sphynx: Throwing these data structures in won't magically make your code faster, I'm sure you're aware
03:46:02 <KitB> quicksilver: Ah, thanks for clarifying
03:46:02 <quicksilver> possibly it started as copy-pasta from intmap I'm not sure.
03:46:33 <quicksilver> KitB: see data type at top of http://hackage.haskell.org/packages/archive/unordered-containers/0.1.1.0/doc/html/src/Data-HashMap-Common.html
03:46:47 <Eduard_Munteanu> IntMap vs Map improves performance significantly in some CPU-bound tasks.
03:47:08 <Peaker> HashMap refers to "hash" in the sense of "converting to Int for IntMap"?
03:47:13 <sphynx> for now I have a simple task of checking whether some element is in a set
03:47:24 <sphynx> I used Data.Set member for this
03:47:35 <sphynx> it's O(log n) as well
03:47:40 <quicksilver> Peaker: converting to int for something rather like an intmap, yes
03:47:45 <quicksilver> but it's a trie not buckets
03:47:50 <KitB> sphynx: Better than doing it with lists at least :D
03:47:56 <quicksilver> but it's not a conventional hashtable.
03:47:57 <liyang> IntMap easily generalises to an EnumMap, but the existing EnumMap on Hackage is a copypasta of IntMap, rather than just a newtype wrapper around IntMap. :(
03:48:04 <Eduard_Munteanu> sphynx: you can also try IntSet if you're okay with Ints.
03:48:29 <KitB> Eduard_Munteanu: That's useful for me too, so thanks.
03:48:32 * liyang should do something about that.
03:50:30 <sphynx> Eduard_Munteanu: it seems I'm not ok with Integer, since I need to be able to find smth like (Rational, Rational) :)
03:53:13 <sphynx> well, thanks for advice, guys!
03:57:07 <savask> Hello. I'm messing here with cabal, a little, so I need some help again. (I hope I'm not too annoying) So, every time I try to upgrade Cabal or install haskell-patform from the tar.gz I have this error message: "/home/savask/.cabal/lib/unix-2.4.2.0/ghc-6.12.1/libHSunix-2.4.2.0.a(Signals.o): In function `sq9K_info': (.text+0x3594): undefined reference to `rtsTimerSignal' collect2: ld returned 1 exit status" What can I do? I'm on Ubuntu
03:57:33 <parcs> liyang: use the unordered-containers package instead?
04:15:48 <spirit> what's the briefest main for a Main cabal module?
04:16:03 <hpc> main = return () :P
04:17:12 <Botje_> main = print 0 -- shorter
04:17:28 <hpc> @hoogle IO a
04:17:28 <lambdabot> Did you mean: :: IO a /count=20
04:17:29 <lambdabot> module Data.Graph.Inductive.Monad.IOArray
04:17:29 <lambdabot> Text.Html action :: String -> HtmlAttr
04:17:41 <hpc> @hoogle IO
04:17:41 <lambdabot> module Data.Array.IO
04:17:41 <lambdabot> module System.IO
04:17:41 <lambdabot> Prelude data IO a
04:17:45 <hpc> :(
04:18:12 <liyang> parcs: feels more elegant to newtype around IntMap and INLINE any definitions, which is what I'm doing right now.
04:18:14 <hpc> main = 0 -- assumes the appropriate Num instance
04:18:53 <liyang> (rather than another copypasta of the same implementation.)
04:20:18 <hpc> spirit: might i suggest taking an existing Setup.lhs and playing with it?
04:20:31 <parcs> main = fix id should be ok as long as it doesn't get called
04:21:04 <hpc> main = yield -- shortest name :: IO a hoogle knows of
04:21:21 <parcs> @hoogle yield
04:21:21 <lambdabot> Control.Concurrent yield :: IO ()
04:21:49 <parcs> yeah but that requires importing a module
04:22:44 <hpc> :t fix (.)
04:22:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
04:22:45 <lambdabot>       Expected type: a
04:22:45 <lambdabot>       Inferred type: f a
04:22:48 <hpc> bleh
04:22:57 <parcs> :t fix($)
04:22:58 <lambdabot> forall a b. a -> b
04:23:03 <hpc> parcs: not shorter
04:23:11 <hpc> and also the wrong type
04:23:15 <hpc> :t fix id
04:23:16 <lambdabot> forall a. a
04:23:37 <spirit> in Setup.lhs, the lines starting with '>' stand for code?
04:23:45 <parcs> oh wait -- i got it!
04:23:48 <parcs> main = main
04:23:54 <hpc> spirit: indeed
04:24:13 <hpc> note "lhs" vs "hs"; literate haskell is cool, and you see it a lot on blogs
04:24:47 <hpc> i personally don't recommend it for actual code though, unless you are going to have more documentation than lines
04:25:09 <spirit> i only knew .lhs from latex-haskell files before. \begin{code} ... \end{code}
04:25:41 * hpc doesn't much like latex-haskell; it is hard to scroll quickly and still know if something is in code or not
04:26:13 <hpc> specifically in modules that like to include definitions in the documentation
04:27:21 <spirit> *i'm drawing on someone else's code and turned them into .hs files. the interesting bits of the documentation were graphs or mathematical equations, hard to read in latex source anyways
04:29:47 <spirit> before installing leksah i used ghci, i did not have a main for the bunch of modules i had. does leksah offer a ghci mode too? is that what the debugger does? leksah made me write a main, but in fact i don't yet need one, i'd rather prefer a ghci mode
04:30:50 <hpc> try the debugger and find out :P
04:30:51 <jutaro> spirit: You don't need a main in leksah, just make a libraray.
04:31:14 <hpc> jutaro: a librarararararay?
04:31:18 <hpc> :P
04:31:30 <jutaro> hpc: okokok
04:31:45 <hpc> :D
04:32:45 <jutaro> spirit: Switch to debugger mode, and you can eval text in any editor, but we have a default pane for this as well.
04:32:47 <chrisdone> jaspervdj: Hai.
04:34:13 <chrisdone> jaspervdj: You know number-six totally doesn't build right now, right?
04:37:15 <spirit> not sure my debugger-mode is working. i thought it was a toggle button, but i can't toggle it? when i select code and try to eval it via right-click, leksah tells me the debugger is not yet running. i can press 'yes' to start it -- which builds the package.
04:38:03 <jutaro> spirit: Strange
04:38:44 <jutaro> spirit: start leksah from a console and see if it tells you anything
04:39:07 <chrisdone> jaspervdj: How does your build work? You're using all sorts of stuff that isn't in the .cabal file. Do you run number-six from GHCi or something?
04:40:40 <spirit> none of the buttons inside the browser pane seems to do anything either
04:40:54 <co_dh_> does anybody has the url of copumpkin's category theory lib in agda? 
04:41:16 <spirit> i only ever started leksah from the terminal. it tells me interface files of modules are missing
04:41:30 <chrisdone> Turing bless cabal-dev. What a brilliant thing. Surprised it's not standard in Cabal-Install.
04:41:30 <jutaro> spirit: Waht do you see in the log pane when you switch to debugger mode?
04:41:33 <spirit> gotoSource:noDefinition
04:42:07 <jutaro> spirit: That's not related to debugger problem
04:42:33 <dcoutts> chrisdone: give us time :-)
04:42:47 <spirit> i don't know how to start the debugger. the toggle button does not toggle.
04:42:48 <chrisdone> dcoutts: So it's planned? *Gets excited*
04:43:00 <spirit> the terminal says 'Debugger already running' though
04:43:04 <dcoutts> chrisdone: either just integrating it, or solving the same problem in a different way
04:43:25 <spirit> and leksah keeps on telling me, via modal dialog, the debugger was not yet running
04:43:53 <jutaro> spirit: and anything written to the log pane, when you try to strat it?
04:44:09 <spirit> Preprocessing executables for pullbacks-first-0.0.1...
04:44:10 <spirit> Building pullbacks-first-0.0.1...
04:44:26 <chrisdone> dcoutts: Fair do's. We're already using cabal-dev at work. This makes building on other machines such a breeze. ♥
04:45:35 <chrisdone> Looking forward to seeing what you come up with. :-)
04:45:57 <dcoutts> chrisdone: btw, if your organisation wants to contribute, associate membership of the IHG is a good option
04:46:08 <dcoutts> chrisdone: some cabal work is currently being supported by the IHG
04:46:18 <dcoutts> and we could do more with more time
04:50:26 <dcoutts> chrisdone: in particular we're working on the "butterfly problem" at the moment for the IHG
04:50:43 <dcoutts> one aspect of it at least
04:50:53 <Bynbo7> hooray
04:51:15 <dcoutts> it's harder than it looks of course :-)
04:53:00 <spirit> could it be the debugger isn't installed?
04:54:31 * hackagebot combinatorial-problems 0.0.2 - A number of data structures to represent and allow the manipulation of standard combinatorial problems, used as test problems in computer science.  http://hackage.haskell.org/package/combinatorial-problems-0.0.2 (RichardSenington)
04:55:43 <mamooth> Hey there
04:59:39 <chrisdone> dcoutts: Sorry, I'm at the office; people asking me stuff. Thanks. We currently use many technologies ('cluding Java and Common Lisp), Haskell is not treated specially… it's kind of on trial.
05:00:46 <zygoloid> @faq can haskell be tried as an adult?
05:00:46 <lambdabot> The answer is: Yes! Haskell can do that.
05:01:31 <jaspervdj> chrisdone: Oops :-/
05:01:47 <chrisdone> jaspervdj: I got it to build now. Shall I push?
05:01:49 <jaspervdj> chrisdone: I run it using ghc --make. But hang on, I'll fix it right nog.
05:01:52 <jaspervdj> *now
05:01:58 <jaspervdj> chrisdone: Ah, okay, feel free
05:02:02 <jaspervdj> thanks
05:03:28 <dcoutts> chrisdone: right, well hope it goes well :-)
05:04:02 <chrisdone> jaspervdj: Pushed to my fork. I had to remove imports of Flickr handler because that depended on a bunch of things that didn't exist. Feel free to include those and re-import it, if you can. I'll merge back.
05:04:16 <jaspervdj> chrisdone: Okay, I'll check it out
05:05:25 <chrisdone> jaspervdj: (I /believe/ my change to Flickr.hs is correct for Cabal building, maybe not.)
05:06:08 <jaspervdj> chrisdone: Using it for your workplace IRC?
05:06:10 <chrisdone> dcoutts: Thanks. A few projects are in prod now. Seems to be going well.
05:06:14 <chrisdone> jaspervdj: Maybe. :-P
05:06:17 <dcoutts> chrisdone: cool
05:06:28 <dcoutts> jaspervdj: btw, great to see that you're presenting at the functional eXchange 
05:06:39 <copumpkin> co_dh_: it's on github
05:06:52 <copumpkin> https://github.com/pumpkin/categories
05:07:01 <co_dh_> copumpkin:  thanks. 
05:07:01 <dcoutts> jaspervdj: I gave a talk there last year, interesting audience, very commercial/application focused of course
05:07:40 <jaspervdj> dcoutts: Ah, I'm looking forward to it. Gotta make my slides this week.
05:09:26 <dcoutts> jaspervdj: sadly I'm off to Cambridge that weekend, otherwise I'd suggest a pub :-)
05:09:58 <jaspervdj> dcoutts: Ah, it's a pitty, I'm in London the entire weekend probably
05:10:08 <dcoutts> :-( ho hum
05:12:50 <mamooth> I'm new to haskell. I'm currently learning through RWH and some other materials. I was tempted by trying leksah. Unfortuantely, I have some problems with cabal. It complain about glibc-2.0 missing, and I can't manage to resolve this problem.
05:12:56 <mamooth> The message is: The pkg-config package glib-2.0 is required but it could not be found.
05:13:13 <mamooth> I've tried cabal install glibc, but the same problem occur
05:13:22 <sipa> glibc isn't glib
05:13:34 <Axman6> mamooth: what OS are you on?
05:13:41 <mamooth> fedora 14
05:13:50 <sipa> and i think it's complaining that the actual library isn't found, not that its haskell bindings aren't installed
05:13:59 <Axman6> yeah
05:14:01 <sipa> yum install libglib2.0-dev
05:14:05 <sipa> or something like that
05:14:07 <mamooth> sipa: thanks to point me out, quite oubvous but I've missed it :/
05:14:28 <mamooth> sipa: let's try it thx
05:14:30 <spirit> mamooth: did you encounter that issue while trying to install leksah? i might have had a similar issue. i had to install gtk build tools
05:14:34 <spirit> and all was fine :-)
05:14:40 <mamooth> spirit: yes
05:14:47 <mamooth> thanks!
05:14:56 <chrisdone> It's interesting how writing 'real world' code of the size and usual time constraints thereof introduces you to problems with libraries that demonstrate these really haven't been tested in a production environment. The amount of patches I've had to make for HaskellDB+postgresql, some patches for the json lib, etc.
05:15:55 <xplat> > let { sliding n = map (take n) . dropLast n . tails where dropLast n = zipWith const `ap` drop n } in sliding 3 [1..8]
05:15:56 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8]]
05:16:02 <ezyang> chrisdone: Not too surprising. 
05:16:43 <xplat> > let { sliding n = map (take n) . dropLast n . tails where dropLast n = zipWith const `ap` drop n } in take 5 $ sliding 3 [1..]
05:16:44 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7]]
05:16:59 <ezyang> Fortunately, making said patches isn't usually very difficult :-) 
05:17:38 <aavogt> or the few production environments they have been used in are somewhat different from yours
05:17:58 <aavogt> for example the HaskellDB issue with the time formatting string change in ghc
05:18:36 <jaspervdj> chrisdone: Pushed some more changes for the Flickr handler.
05:18:41 <aavogt> so if you have an earlier version of base, everything is fine
05:19:13 <aavogt> oops, I meant HDBC
05:24:53 <Entroacceptor> has anyone used digestive-functors with hstringtemplate?
05:24:58 <ezyang> And I think it's mostly a maturity issue that will go away as multiple groups "buy in" and start leaning on the components 
05:25:28 <jaspervdj> Entroacceptor: Not that I know of
05:25:47 <Entroacceptor> ah, you're here :)
05:26:04 <Entroacceptor> would it be hard to do?
05:28:58 <jaspervdj> depends on what you want to do exactly, I guess. Can you render stuff using the blaze backend and then inject it?
05:30:32 <Entroacceptor> you can tell blaze to render just html snippets?
05:30:46 <Entroacceptor> then that would suffice for now
05:31:23 <ezyang> "unsafeRenderHTML" 
05:31:26 <jaspervdj> Entroacceptor: Yes, snippets is the default, you'd have to manually wrap them in `html` tags etc. to get full pages.
05:31:34 <Entroacceptor> ezyang: *g*
05:33:00 <spirit> yo -- i solved my leksah debugger issue (it appeared i could not start the debugger from within leksah)
05:33:11 <Aune> Where can I find good information about specific monads and there use (intended use). For examle specific detail about the Reader, Writer, State or other interesting monads.
05:33:24 <spirit> i had a terminal open with ghci running. now all is fine :-)
05:34:06 <faanbj> What's the name of that Haskell game with some ninja girl cat and robots?
05:34:23 <spirit> jutaro, leksah debugger would not start cos i had another instance of ghci running inside a terminal :-)
05:34:24 <byorgey> nikki and the robots?
05:34:24 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
05:34:30 <faanbj> byorgey: thanks
05:34:38 <Botje_> Aune: all about monads is a good start
05:35:09 <Aune> Botje_ Thanks will take a look
05:35:34 <quicksilver> Aune: I was just about to say the same thing, but the website appears to be down
05:35:37 <Botje_> or maybe momads for the working haskell programmer
05:35:41 <quicksilver> http://www.haskell.org/haskellwiki/All_About_Monads has an ugly PDF copy
05:35:44 <faanbj> byorgey: Do you know if the trailer is actually a program or just an animation? i.e. how far along they are?
05:35:52 <ozataman> Does anyone know how to make --hyperlink-source a default argument to cabal haddock?
05:35:58 <quicksilver> the content is there but it isn't as easy to read as the old HTML one was
05:36:13 <faanbj> hm, they have a couple of other videos on vimeo besides the trailer, so it looks like it's running
05:36:23 <byorgey> faanbj: I seem to recall there is some sort of playable demo/beta version or some such.  But I am not sure
05:37:19 <Aune> Botje_ , quicksilver: Found a pdf version, part two of AAM seems to be exactly what I was looking for. Thanks.
05:37:35 <faanbj> byorgey: all right, thanks
05:39:50 <jlouis> Axman6: yeah
05:39:57 <Axman6> o/
05:40:16 <Axman6> i watched your infoQ interview earlier, nice to put a face to your name :)
05:40:25 <jlouis> :)
05:42:14 <Guest54787> Hi guys, I wonder what happens when I try to store a function in a MVar like in this little snippet, is the function serialized..?  let test = newEmptyMVar >>= \var -> putMVar var id
05:42:15 <pr> care to share the link to that very interview, Axman6?
05:42:20 <jlouis> Axman6: It has been going rounds since Friday when it was posted
05:42:27 <confound> huh, (`f` y) does what I expect and is sometimes prettier than ((flip f) y)
05:42:35 <ezyang> Guest54787: Nope. 
05:42:50 <ezyang> MVars don't do serialization; they just point to other objects on the heap. 
05:43:23 <Axman6> pr: http://www.infoq.com/interviews/haskell-erlang-p2p-implementation
05:44:05 <Guest54787> ezyang: thanks!
05:44:05 <Axman6> Guest54787: MVars are basically just pointers to haskell objects, with some other nice stuff on top
05:44:07 <ezyang> confound: Note the parens aren't necessary, so you can write flip f y 
05:44:24 <ezyang> go go currying :-) 
05:44:32 <byorgey> confound: indeed.  I often do, e.g.  (`isInfixOf` blah)  and things of that sort
05:44:41 <roconnor> is nometa, https://www.joachim-breitner.de/blog/, someone on #haskell ?
05:44:50 <chrisdone> jaspervdj: Sweet.
05:46:03 <byorgey> preflex: seen nomeata
05:46:03 <preflex>  nomeata was last seen on #haskell 42 days, 21 hours, 49 minutes and 19 seconds ago, saying: ddarius: hmm, right. But looks like there is no “native” mapWithKeyM. 
05:46:08 <byorgey> roconnor: ^^^
05:46:14 <byorgey> hasn't been in here for a while
05:46:17 <roconnor> thanks
05:46:38 <haskellnoob> I have a large list of positive numbers, called nums. I want to pick the shortest prefix of this list whose sum does not exceed a specified number, called target. How do I do this? I guess takeWhile can be used, but I am not sure how to write the predicate.
05:46:41 <xplat> 01:03 < kmc> is that the one in Cambridge off Mass Ave? < kmc> (why is there no Energy Ave)   <-- Mass Ave *is* Energy Ave, up to a factor of c^2
05:47:00 <byorgey> haskellnoob: first use 'inits' to generate the list of all prefixes
05:47:06 <xplat> (which is only a unit conversion anyway)
05:47:26 <hpc> xplat: any sane physicist will use plank units anyway
05:47:35 <haskellnoob> byorgey: thanks. if nums is a really large list, will this be costly?
05:47:42 <byorgey> haskellnoob: then find their sums and use 'takeWhile' and 'last' to pick out the one you want
05:47:58 <ezyang> byorgey: Bah, O(n^2) :-) 
05:48:02 <haskellnoob> byorgey: this definitely looks to be costly to me
05:48:07 <Philippa> hpc: 2x4?
05:48:13 <byorgey> haskellnoob: no, because of laziness it will only compute as far as needed
05:48:14 <haskellnoob> i think O(n) should suffice
05:48:19 <byorgey> and ignore the rest of the list
05:48:30 <byorgey> ezyang: oh, hush.  premature optimization, etc. etc.
05:48:52 <jaspervdj> haskellnoob: You meant the longest prefix, right?
05:48:57 <haskellnoob> shortest
05:48:57 <ezyang> heehee 
05:49:17 <haskellnoob> err.. longest :)
05:49:27 <byorgey> shortestPrefixNotExceeding _ _ = []
05:49:45 <jaspervdj> byorgey: My thoughs exactly. And it would also be pretty fast
05:49:53 <haskellnoob> there we go!
05:49:53 <ezyang> I think I'd probably zip inits with a scan and take on the latter. 
05:50:02 <byorgey> haskellnoob: for O(n), you can instead use scanl (+) to compute the successive prefix sums in O(n) time
05:50:15 <byorgey> ezyang: you're right, that is better
05:50:17 <haskellnoob> byorgey: thanks, let me think about that
05:50:24 * chrisdone often chooses the shortest, O(n²) solutions, thinks about speed when the program behaves sluggishly
05:50:34 <byorgey> > scanl (+) 0 [1,2,3,4,5]
05:50:35 <lambdabot>   [0,1,3,6,10,15]
05:50:54 <byorgey> > zip <$> inits <*> scanl (+) 0 $ [1,2,3,4,5]
05:50:55 <lambdabot>   [([],0),([1],1),([1,2],3),([1,2,3],6),([1,2,3,4],10),([1,2,3,4,5],15)]
05:51:37 <zygoloid> byorgey: shortestPrefixNotExceeding [3,-6,4] (-2) = [3, -6]
05:51:39 <haskellnoob> chrisdone: what are  <$> and <*> ?
05:51:40 <jaspervdj> > :t maximumBy snd
05:51:41 <lambdabot>   <no location info>: parse error on input `:'
05:51:50 <hpc> :t maximumBy snd
05:51:51 <lambdabot>     Occurs check: cannot construct the infinite type:
05:51:51 <lambdabot>       b = (a, b) -> Ordering
05:51:51 <lambdabot>     Probable cause: `snd' is applied to too many arguments
05:51:57 <byorgey> haskellnoob: they are from Control.Applicative
05:52:17 <haskellnoob> byorgey: sounds like I should steer clear of them ...
05:52:23 <byorgey> haskellnoob: if you haven't read about applicative functors yet then no need to worry about it yet =)
05:52:35 <jaspervdj> :t maximumBy (comparing snd)
05:52:36 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
05:52:40 <jaspervdj> that'll work
05:52:50 <haskellnoob> no, i haven't read about applicative functors yet
05:52:58 <chrisdone> haskellnoob: <$> = fmap, <*> takes a function inside a functor, a functor with a value a, and returns a functor with with that function applied to the value a
05:53:11 <byorgey> haskellnoob: in the particular code I just wrote, the result is that inits and scanl (+) 0 are both called on the same argument [1,2,3,4,5], and then the results are combined with zip
05:53:12 <haskellnoob> thanks all, let me try these
05:53:15 <chrisdone> :t (<*>)
05:53:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:53:22 <Aune> :t inits
05:53:23 <haskellnoob> byorgey: thanks
05:53:23 <lambdabot> forall a. [a] -> [[a]]
05:53:32 <Aune> > :t inits
05:53:33 <lambdabot>   <no location info>: parse error on input `:'
05:53:49 <byorgey> chrisdone: even I find that description hard to parse. =)
05:54:12 <chrisdone> byorgey: I find the type more readable but some newbs tend to like pros :p
06:09:25 <hpc> Aune: "> " makes it run a haskell expression; ":t" is a ghci pragma
06:09:32 <hpc> er, command, not pragma
06:09:50 <chrisdone> hpc: But, of course, don't expect it to work in PM. That would be too predictable. :-P
06:09:58 <hpc> of course
06:10:26 <hpc> the mere existence of that bug makes me doubt that lambdabot is that well coded
06:11:21 <chrisdone> I don't think it's a bug; the configuration of each lambdabot plugin has "channel" and "pm" listeners, IIRC. Someone chose for :t to work in the channel but not in the pm.
06:11:45 <hpc> still a terrible feature
06:11:55 <int-e> - @type works in private messages ...
06:12:04 <hpc> at least, there's no reasonable use case for something to be channel-only
06:12:14 <chrisdone> Yes, @type does, not :t. That's what we're discussing.
06:26:07 <hpaste> jdz pasted "scheduler"  http://hpaste.org/44584
06:27:50 <haskellnoob> I think I have it: fst $ last $ takeWhile (\(a,b)-> b < target)  $ zip <$> inits <*> scanl (+) 0 $ nums
06:27:53 <haskellnoob> thanks!
06:28:31 <byorgey> haskellnoob: nice!
06:28:54 <byorgey> haskellnoob: note, just for fun, you could write \(a,b) -> b < target  as   (< target) . snd
06:29:11 <haskellnoob> byorgey: that is a kind way of putting it, and thanks :)
06:29:50 <byorgey> haskellnoob: no, either way is fine, I was serious when I said "just for fun"
06:29:52 <haskellnoob> err.. i don't see it now: each element in the list returned by zip is a pair (a,b)
06:30:05 <byorgey> yes
06:30:11 <zygoloid> eww, partial function!
06:30:41 <zygoloid> > let target = (-4); nums = [1,2,3] in fst $ last $ takeWhile (\(a,b)-> b < target)  $ zip <$> inits <*> scanl (+) 0 $ nums
06:30:41 <haskellnoob> if i just say (< target), how does it know to apply this to the second element in the pair?
06:30:41 <lambdabot>   *Exception: Prelude.last: empty list
06:30:43 <confound> haskellnoob: snd (a, b) = b
06:31:01 <haskellnoob> oh, i didn't notice the snd at the end :D
06:31:05 <byorgey> haskellnoob: not (< target),  (< target) . snd   =)
06:31:10 <byorgey> right
06:31:24 <zygoloid> > let target = (5); nums = [1,2,3,-2] in fst $ last $ takeWhile (\(a,b)-> b < target)  $ zip <$> inits <*> scanl (+) 0 $ nums
06:31:25 <lambdabot>   [1,2]
06:31:31 <zygoloid> ^^ wrong answer here :)
06:31:55 <haskellnoob> zygoloid: it is ok for me, my list only has nonnegative integers
06:32:00 <zygoloid> ok :)
06:32:30 <zygoloid> haskellnoob: is your list necessarily nonempty?
06:32:51 <byorgey> zygoloid: it is OK for empty lists, since scanl (+) 0 will produce a nonempty list from an empty list
06:32:59 <zygoloid> > let target = 1; nums = [5,6,7] in fst $ last $ takeWhile (\(a,b)-> b < target)  $ zip <$> inits <*> scanl (+) 0 $ nums
06:33:00 <lambdabot>   []
06:33:00 <byorgey> as long as the target sum is nonnegative
06:33:24 <zygoloid> yeah, fair point :)
06:33:30 <haskellnoob> zygoloid: yes, it is necessarily nonempty
06:43:59 * hackagebot hslogger 1.1.4 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.1.4 (JohnGoerzen)
06:46:42 <parcs> @hoogle DiffTime -> UTCTime
06:46:42 <lambdabot> Data.Time.Clock UTCTime :: Day -> DiffTime -> UTCTime
06:46:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:46:43 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:14:50 <yitz> preflex: seen mzero
07:14:50 <preflex>  mzero was last seen on #haskell 7 hours, 58 minutes and 21 seconds ago, saying: ew! `elem` in a guard?!?!?!
07:15:03 <yitz> hmm. what's wrong with `elem` in a guard?
07:15:38 <aristid> yitz: who says that it is wrong? :)
07:15:44 <sipa> show the code
07:16:04 <yitz> mzero said it 8 hrs ago, according to preflex
07:17:00 <Jafet> That was in response to "case ... of x | x `elem` [A,B,C,D] ->"
07:17:20 <yitz> preflex has this habit of taking people's statements out of context. we should talk to mauke about that... :)
07:17:23 <chrisdone> preflex: be poppavic
07:17:23 <preflex>  You cannot walk into ##C and speak "C" as a moron. Really-really. This shit is the underlayer to scripting and an uber-layer to the machine.
07:17:47 <Jafet> preflex: be mauke
07:17:47 <preflex>  haskell software should move from alpha to beta to eta, then lambda
07:18:14 <ziman_> preflex, be Cale
07:18:14 <preflex>  Types are a bit like the nubs on lego bricks which provide structural integrity while suggesting how the bricks should fit together.
07:18:20 <yitz> preflex: be mzero
07:18:21 <preflex>  no quotes found for mzero
07:18:27 <aristid> preflex: be yitz
07:18:27 <preflex>  no quotes found for yitz
07:19:07 <aristid> is preflex' quote database independent of lambdabot's?
07:19:15 <chrisdone> papermachine: coi papriminji
07:19:27 <aristid> chrisdone: is papermachine  your bot?
07:19:40 <papermachine> coi
07:19:51 <chrisdone> aristid: Yes. He is an AI. He's very intelligent.
07:19:55 <papermachine> -_-
07:20:10 <mercury^> Will it every quote someone saying "preflex, be someone"?
07:20:14 <aristid> chrisdone: how many olegs?
07:20:16 <papermachine> We prefer the term 'machine intelligence' because while you were created, I wasn't.
07:21:15 <chrisdone> aristid: 0.23.
07:21:21 <Jafet> It's only measurable in olegs if it was written in the type system
07:21:30 <Jafet> @quote elephant
07:21:31 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
07:21:58 <Saul> Hi
07:22:22 <Saul> I'm Haskell curious
07:22:30 <companion_cube> hi Saul 
07:22:55 <Jafet> @vixen are you Haskell curious?
07:22:55 <lambdabot> Ooh, functional programmers are so hot!
07:23:34 <Saul> I wanted to know if Haskell is a better language than Delphi, C/C++ Python, Ruby and such?
07:23:46 <Jafet> Do you expect us to say "no"?
07:23:50 <jlouis> Saul: "better" in what way?
07:24:07 <Axman6> Saul: Haskell is the best language the world has ever seen!
07:24:12 <jlouis> If you value lines of code for instance, you will probably be happy
07:24:14 <mauke> give me an axis to stand on
07:24:16 <chrisdone> @faq Can Haskell answer "mu" questions?
07:24:16 <lambdabot> The answer is: Yes! Haskell can do that.
07:24:20 <Axman6> it'll blow your mind
07:24:45 <Saul> I'm a begginer programmer, I have programed in Pacal, Delphi and Viasual Basic but only very little and I expect you to be honest
07:24:57 <FauxFaux> YOU'RE DOOOMED.
07:24:59 <companion_cube> Saul, it depends much on programmer's taste
07:25:13 <c_wraith> You're probably better off learning haskell without having as much to unlearn.
07:25:20 <mauke> well, I think Delphi is a terrible language, so yes, Haskell would be better IMHO
07:25:39 <mauke> depends a lot on what you're trying to do, though
07:25:48 <c_wraith> But the concept of "better language" is hard to define.
07:25:53 <Axman6> Saul: well, we all think it's a great language. if you're interested, check out this sire:
07:25:56 <Axman6> @where lyah
07:25:56 <lambdabot> http://www.learnyouahaskell.com/
07:26:11 <c_wraith> There are things for which haskell is amazing.  There are some things for which it's not so good.
07:26:21 <Wintermute> Well, that's true for any language out there
07:26:28 <c_wraith> that was sort of my point.
07:26:32 <burp> haskell is already just awesome for it's clean syntax
07:26:40 <c_wraith> "better" isn't well-defined.
07:26:43 <burp> when compared to any other language :>
07:26:58 <c_wraith> the Lisps might argue with that one.
07:26:59 <companion_cube> Wintermute, you're wrong, some languages are good at nothing 0:-)
07:27:08 <mauke> burp: I dunno, brainfuck is pretty clean
07:27:11 <Wintermute> Weeeeell...there's PHP...
07:27:14 <Jafet> Hm, how many olegs is Wintermute?
07:27:19 <burp> gah, come on you know what I mean :P
07:27:20 <jlouis> brainfuck is awesome
07:27:20 * chrisdone amazed how these same old questions spark debate every single time
07:27:28 <c_wraith> And Haskell has some annoying unnecessary syntax.  But it's true that the syntax is very regular, which is a plus.
07:27:29 <Jafet> I'm not sure whether to make personality defect a bonus or penalty.
07:27:29 <jlouis> I've used it many times
07:27:34 <Wintermute> Braifuck is just what the package says: Brainfuck
07:27:39 <jlouis> easiest way to get a turing machine in!
07:27:48 <companion_cube> unlambda > brainfuck
07:27:48 <jmcarthur> c_wraith: this list of things that haskell isn't great for varies from person to person though, which i think is pretty unusual compared to most languages
07:28:17 <c_wraith> jlouis: I see you did some presentation on Erland and Haskell recently.  Or else it just ended up on reddit recently.
07:28:22 <c_wraith> err, Erlang
07:28:28 <jmcarthur> i mean, even if haskell isn't awesome for some particular thing, you can make a DSL that generates code in some other language and still get some of the other benefits of haskell
07:28:50 <jlouis> c_wraith: yep
07:28:55 <jmcarthur> provided you have the time to do that, of course
07:29:04 <Jafet> chrisdone: ritual?
07:29:08 <jlouis> c_wraith: it is almost a year old when I started on this though
07:29:42 <c_wraith> I recently received a small bit of Erlang code, as an example server for a simple protocol.  It reminded me how much I hate Erlang's syntax.  :)
07:30:19 <Saul> Brainfuck? really? gross name though...
07:30:21 <Axman6> heh
07:30:38 <Axman6> Saul: well it's a pretty gross language
07:30:41 <Saul> never heard of that programming language
07:30:52 <Saul> hehe Axman6
07:31:04 <Wintermute> Uhh, I'd rather code in Ook, thanks
07:31:09 <Axman6> it's some what of a joke language, that far too many people have taken seriously
07:31:30 <Saul> xD
07:31:35 <chrisdone> Axman6: Programmers without a sense of humour? You're kidding me.
07:32:01 <c_wraith> Saul: Honestly, haskell is a pretty great language.  Whether it's "better" than some other language depends both on what you're doing, and your personality.
07:32:06 <jlouis> c_wraith: Erlangs power stems not so much from the language (it is ok, but so so). The runtime is really great though
07:32:15 <Saul> Ook? wow, really weird names...
07:32:20 <companion_cube> Axman6, some people really thought brainfuck was a real language ??
07:32:25 <jlouis> c_wraith: on the other hand, Erlang chose the right evaluation order
07:32:30 <jlouis> :P
07:33:14 <c_wraith> jlouis:  Indeed.  There are some great libraries on top of the OTP platform, too.  But that syntax...  It's like they wanted to make people who use it irregularly cry when they try to remember what line terminator they want in the context they're in. :)
07:33:16 <jmcarthur> Axman6: actually, it's not a joke language (it's not intended to be a practical language either though)
07:33:25 <jmcarthur> it was just designed to be easy to write a compiler for
07:33:25 <Peaker> I don't think anyone though brainfuck was a great language. To some it seems to have been the first exposure of the minimalism that allows turing completeness, so they toy with it a lot
07:33:55 <Peaker> s/great/real
07:33:57 <Wintermute> Well, it does neatly reflect Turing's idea of computation
07:34:14 <Peaker> Was Turing not involved in the proof that LC was also TC?
07:34:51 <jlouis> c_wraith: I am with you. Of Haskell/Miranda/Clean, ML and Erlang/Prolog my syntax preference is the Haskell group
07:35:05 <companion_cube> lisp syntax on erlang runtime would be great
07:35:17 <jlouis> companion_cube: LFE, look it up
07:35:33 <companion_cube> it's quite a toy, isn't it ?
07:35:39 <mauke> Low Frequency Effects
07:35:55 <jlouis> companion_cube: perhaps a toy, but it IS quite stable
07:36:06 <Jafet> Brainfuck was the subject of a published paper, so it's hardly a joke language
07:36:18 <aristid> there's even lisp syntax for haskell
07:36:20 <jlouis> My bachelors thesis has Brainfuck in it
07:36:22 <Jafet> Of course, that paper was written before brainfuck existed, and so it wasn't called brainfuck.
07:36:31 <aristid> but i think haskell's syntax is better than lisp's :P
07:36:40 <burp> jlouis: how? :D
07:36:59 <Wintermute> aristid: I'm with you.Lisp has...just too many parenthesis.
07:37:10 <jlouis> burp: formalization of it to obtain a path from BF to Turing machines
07:37:19 <jlouis> I was so bad at Coq then
07:37:27 <Peaker> jlouis, Erlang is lazily evaluated?
07:37:32 <jlouis> Peaker: strictly
07:37:41 <Peaker> jlouis, oh, why is that the "right evaluation order"?
07:37:44 <jlouis> I did say the *right* evaluation order :)
07:38:06 <jlouis> it's not in reality, it is sort of tongue-in-cheek
07:38:17 <jmcarthur> evaluates from the right? ;)
07:38:19 <Peaker> Would be nice if perhaps there was no "default" evaluation order, and it was all tagged in the types somehow
07:38:44 <jmcarthur> i don't know about "nice." there would be some benefits though
07:38:46 <jlouis> all evaluation strategies have advantages/disadvantages, but I'd like easier access to both in Haskell
07:38:49 <aristid> Peaker: with a light-weight syntax, so you're not weighed down?
07:38:58 <Jafet> Haskell has strict and lazy constructors.
07:39:38 <Peaker> aristid, Ideally syntax would be a presentational thing that doesn't bother you too much :)
07:39:45 <Peaker> aristid, not something you have to tediously type in
07:40:01 <owst> Am I correct in thinking that clean has the ! type annotation to mark strict evaluation. Peaker is that what you mean?
07:40:20 <Peaker> owst, Haskell has strictness annotations too, but it clearly has a "lazy-by-default"
07:40:40 <Peaker> Most languages are "strict-by-default" and then you can "emulate" laziness using functions of a unit type or such
07:41:10 <Jafet> What does "no default" mean anyway?
07:41:12 <owst> Hmm, maybe I don't understand your wish then :)
07:41:13 <quicksilver> (functions of unit-type emulate non-strictness)
07:41:22 <quicksilver> laziness requires more work, usually.
07:41:41 <mauke> a mutable cell
07:41:48 <Peaker> a memoized function of unit-type, yeah
07:42:19 <Peaker> owst, I would want a function like "sequence" to be parameterized on the evaluation strategy
07:42:31 <Peaker> owst, and I want it to be tail-recursive when it is strict
07:43:49 <jlouis> Anyway, my point simply was that I would like more control over what is lazy and what is strict
07:44:04 <jlouis> because it *always* bites me
07:45:09 <Philippa> Peaker: give or take the tail-recursive part, it already /is/ parameterised on it by way of the monad in question
07:45:19 <Peaker> jlouis, It would be nice if we had interactive profiling/editing environment with finer-grained control of all resource use
07:45:35 <Peaker> Philippa, Yeah, the problem is that it stack-overflows on strict monads because it isn't tail-recursive
07:45:56 <jlouis> Peaker: Termination checking (eventually with hints) could also be nice to have, but it is probably not in spirit with Haskell
07:46:14 <jlouis> still I friggin' like the Haskell language
07:46:17 <Peaker> jlouis, I think it is totally the spirit of Haskell, but just lacked some mojo at the time :)
07:46:41 <jlouis> even though I hack much more Erlang, heh
07:47:38 <Peaker> Philippa, it's a bit annoying to have to write a lazy-friendly and strict-friendly variant of many functions
07:47:42 <jmcarthur> IMO we have a lot of control over evaluation already
07:47:43 <Peaker> Philippa, (not that I have a good solution)
07:47:49 <jmcarthur> i don't know how much more control you could have
07:48:13 <jmcarthur> do you just mean you want it to be more obvious from the code?
07:48:20 <jmcarthur> like in the types or something?
07:49:02 <Peaker> I wish it was obvious in the types, and that somehow, magically, functions changed their form to tail-recursive when they were strict :)
07:53:43 <Saul> what is a mojo?
07:54:22 <parcs> hmm, ghc7's error messages seem to be a bit less helpful than ghc6's in some cases
07:54:36 <Peaker> Saul, http://www.urbandictionary.com/define.php?term=mojo
07:54:57 <Saul> thx
07:55:16 <Saul> <== non-native English speaker
07:55:20 <parcs> for example, in ghc6 where i would get "couldn't match expected type (String, Int) against inferred type String," i instead get "couldn't match expected type (t0, t1) against actual type String"
07:55:34 <Peaker> Saul, apparently you are not an Austin Powers fan either
07:59:51 <Saul> o_O?
08:00:01 <Saul> Austin Powers?
08:05:21 <Saul> you mean no much of a sense of humour, well yes I'm kinda respectful kinda guy so my sense of humour is limited
08:05:58 <quicksilver> I don't think he means that, no. He just means if you were familiar with the film you'd be familiar with the term/
08:06:33 <Saul> I'll give Haskell a honest try
08:07:01 <Saul> @quicksilver, oh I see
08:07:01 <lambdabot> Unknown command, try @list
08:08:08 <confound> what does respectfulness have to do with a sense of humor?
08:08:35 <Philippa> some people think they're contradictory. Usually the sorts of people who make racist jokes rather than jokes about racism, for example
08:08:46 <Philippa> (or who don't realise you can make the latter kind)
08:10:08 <confound> That makes sense.
08:11:12 <Saul> if respectful=true then make (jokes about (racism))
08:11:28 <Saul>  else jokes (racist )
08:11:47 <Philippa> weeell, implicit in there is that being less than entirely respectful of racist behaviour is probably a good thing, too
08:11:58 <Philippa> it's one of the things humour's best for actually, there's a reason authoritarians hate it
08:12:13 <kmc> Saul, if/then/else considered harmful
08:12:13 <kmc> ;)
08:12:21 <dezzy> hi
08:12:26 <kmc> Philippa, true that!
08:14:08 <Saul> :D
08:14:13 <Saul> hi dezzy
08:15:43 <Saul> Evaluation service  and Try Haskell by  Chris Done,  concept and interface blatantly copied from  _why's Try Ruby!
08:16:10 <Saul> LOL, this chris guys is  a truly Haskel fan :D
08:19:41 <Saul> nice to be here, got to go now, I'll go learn some Haskell thanks for your comments guys. BTW, the only language I actually enjoyed programming in was Pascal
08:19:43 <kmc> indeed
08:19:48 <kmc> he hangs out here pretty often too :)
08:19:52 <Saul> cya  :)
08:19:56 <kmc> ttyl
08:45:40 <dsrogers> hey.  I'm using OpenGL from hackage.  I want to write a vertex command.  The only way I could get it to compile is with:
08:45:50 <dsrogers> vertex $ Vertex2 (-0.5 :: Float) (-0.5 :: Float)
08:46:02 <kmc> that seems roughly correct
08:46:03 <dsrogers> is there some way to make this work without so much casing?
08:46:08 <dsrogers> err, casting?
08:46:08 <kmc> you shouldn't need Float on both numbers
08:46:13 <dsrogers> ah
08:46:15 <kmc> those aren't casts; they're type signatures
08:46:23 <dsrogers> sorry, yes, type signatures.
08:46:30 <dsrogers> I realize the difference.
08:46:40 <kmc> if you put a signature on one, you shouldn't need it on the other
08:46:45 <kmc> you can also make some local alias
08:46:50 <c_wraith> What do people think about reading Haddock from associated types versus Haddock from functional dependencies?
08:46:55 <dsrogers> like vertex2f or something?
08:47:03 <kmc> let vert :: Float -> Float -> IO (); vert x y = vertex (Vertex2 x y)
08:47:11 <kmc> or whatever
08:47:44 <dsrogers> except I would still need parens to get unary minus to behave.
08:47:45 <augur> byorgey: ping
08:47:50 <dsrogers> I suppose there is no real way around that.
08:47:53 <dsrogers> ?
08:52:51 <kmc> dsrogers, yeah :/ unary minus is an ugly corner case of the haskell syntax
08:53:04 <msieradzki> is HOpenGL dead?
08:53:14 <ksf> why should it be?
08:53:20 <kmc> the library is just named "opengl" now
08:53:22 <msieradzki> no upload since like a year
08:53:27 <kmc> it's very much not dead; it's in the Platform
08:53:36 <msieradzki> silly things like UniformLocation not exposing proper data
08:53:50 <msieradzki> I mean it doesn't seem to be actively maintained anymore
08:54:04 <kmc> (sometime a few years ago people realized that it is technically possible to make haskell libraries with names that don't start with 'H')
08:54:24 <ksf> have there be any changes to opengl 2.0 since september 2009?
08:54:31 * dsrogers goes and renames all his internal modules
08:54:34 <msieradzki> to opengl 3.3
08:54:35 <kmc> the current version claims to support OpenGL 3.2
08:54:36 <msieradzki> and to 4.1
08:54:36 <msieradzki> yes
08:54:42 <kmc> which i guess is not the latest
08:54:52 <msieradzki> and current 3.2 "supporting" one doesn't have UniformLocation done properly as an example
08:55:07 <msieradzki> and it mixes 2.1 with 3.2+ stuff
08:55:19 <msieradzki> kmc, none of it matters
08:55:24 <kmc> there are five kinds of shader now?
08:55:24 <msieradzki> except that I can't find a real project page like on code google
08:55:25 <ksf> msieradzki, what about openglraw?
08:55:28 <kmc> back in my day etc.
08:56:19 <msieradzki> potentially asking stupid question
08:56:25 <msieradzki> http://code.haskell.org/OpenGL/ is that supposed to be that slow
08:56:28 <msieradzki> is it down or something
08:56:36 <msieradzki> or should projects be hsoted elsewhere
08:56:43 <ksf> code.haskell.org is notorious for being underpowered, yes.
08:56:48 <ksf> it's not the same server as www
08:57:34 <ksf> msieradzki, if you have any patches or fixes you can rely on them getting included. even if hopengl is really dead (which I doubt), the rest of the community definitely won't drop it.
08:58:47 <msieradzki> I meant undermaintained :P
08:59:07 <ksf> oh, yes, code seems to be fast right now.
08:59:19 <Egbert9e9> i have a clear file but still ghci complains about an indentation mistake on line 75
08:59:42 <ksf> how can it have 75 lines, then?
09:00:39 <Egbert9e9> \_o___o_/
09:00:44 <ksf> msieradzki, that might very well be. I don't think the number of people using opengl 4 isn't that high.
09:01:17 <Egbert9e9> okay, something is wrong with the commandline, i think
09:01:23 <ksf> OpenGL version string: 2.1 Mesa 7.9.1
09:01:23 <ksf> see, I could'nt even use half of that.
09:02:13 <ksf> s/isn't/is
09:02:37 <kmc> i'm just glad OpenGLRaw even exists now
09:02:43 <kmc> i did a bunch of stuff in C++ i'd rather not have
09:02:50 <kmc> due to Haskell OpenGL lacking support for shaders etc
09:03:54 <msieradzki> lacking what?: http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL-GL-Shaders.html
09:04:24 <kmc> past tense
09:08:27 <hpaste> glguy pasted "323"  http://hpaste.org/44588
09:18:10 <Egbert9e9> guys, how do i turn exercise 33's function into one of those function definitions that do not state their parameters?
09:18:16 <Egbert9e9> coprime n m = 1 == myGCD n m
09:18:19 <weirdo> aiee! i don't understand kinds
09:18:25 <weirdo> please help
09:18:46 <Saizan> @pl coprime n m = 1 == myGCD n m
09:18:47 <lambdabot> coprime = ((1 ==) .) . myGCD
09:18:55 <weirdo> i'm reading through "learn you a haskell" and suddenly it became "* -> (* -> *) - > *"
09:19:00 <Egbert9e9> woah.
09:19:22 <hpc> weirdo: yeah, that part is a bit crazy strange
09:19:24 <ksf> it's just like with types.
09:19:35 <ksf> it wants a zero-argument type, a one argument type and gives you a zero-argument type.
09:19:38 <hpc> hard to get at first, but fun to go back to later
09:19:42 <weirdo> any idea where i can find more info on kinds so i can go through that stuff from the book?
09:19:51 <weirdo> it doesn't explain it well
09:20:04 <ksf> they're to types what types are to values.
09:20:08 <ksf> it's as simple as that.
09:20:10 <weirdo> like a metatype?
09:20:17 <weirdo> but what do the arrows mean?
09:20:33 <ksf> functions.
09:20:37 <ksf> or rather, implication.
09:20:42 <ksf> again, the same as with types.
09:20:56 <ksf> data Foo a = Foo [a]
09:21:03 <ksf> Foo :: * -> *
09:21:12 <ksf> takes a type, yields a type.
09:21:15 <ksf> both of kind *
09:21:46 <ksf> data Bar a b = Bar (a b)
09:21:57 <ksf> Bar :: (* -> *) -> * -> *
09:22:21 <ksf> ...note that the definition of Bar says that type "a" takes another type (b) as parameter.
09:22:49 <weirdo> i don't get which star means what
09:23:01 <ksf> any lifted type.
09:23:02 <weirdo> there's at least one star, the last one means that it yields a concrete type, but still
09:23:05 <djahandarie> They all mean the same thing. "Any type".
09:23:09 <ksf> kinds are basically untyped in haskell.
09:23:18 <Egbert9e9> is there a good reason to do @pl?
09:23:21 <djahandarie> ksf, using the word "untyped" here is probably not helpful .:)
09:23:29 <Egbert9e9> it seems to me it's more readable WITH arguments
09:23:32 <parcs> > do { _ <- Just 7; guard (False == False); return 5 }
09:23:33 <lambdabot>   Just 5
09:23:34 <djahandarie> Egbert9e9, sometimes the point-free version is nicer.
09:23:35 <Egbert9e9> parameters/ whatever
09:23:38 <kmc> Egbert9e9, it's a good way to learn some tricks
09:23:38 <ksf> there's *, different arities (->), and more internal stuff like # for unboxed primitive types.
09:23:40 <parcs> > do { _ <- Just 7; guard (False /= False); return 5 }
09:23:40 <lambdabot>   Nothing
09:23:45 <mauke> weirdo: do you understand why (Just "hi" :: Maybe) and (42 :: Int String) are invalid?
09:23:49 <Egbert9e9> djahandarie: can you give an example?
09:23:50 <kmc> you shouldn't blindly use its output of course
09:23:55 <Egbert9e9> kmc: that's true
09:24:17 <kmc> (<4) versus (let isInputValueLessThanFour inputValue = inputValue < 4 in isInputValueLessThanFour)
09:24:17 <weirdo> mauke, because Maybe takes a type parameter, and Int takes none
09:24:32 <Egbert9e9> kmc: oh my god o-o
09:24:39 <mauke> weirdo: that's all there really is to kinds
09:24:49 <mauke> Maybe :: * -> *, but Int :: *
09:24:53 <djahandarie> kmc, you could have used a lambda there :P
09:24:57 <kmc> ;)
09:25:20 <weirdo> by the way, what do you call "JUst"? a type constructor?
09:25:27 <kmc> data constructor or value constructor
09:25:32 <kmc> Maybe is a type constructor
09:25:42 <ksf> mauke, but you're glancing over them forming a zygohistomorphic prepromorphism under composition with monads.
09:25:50 * mauke strangles ksf 
09:25:52 <kmc> in Haskell the language of expressions and the language of types are separated by the iron curtain of the :: symbol
09:26:19 <kmc> public class IsNumberLessThanOtherNumberImplementationFactory { ...
09:26:22 <Egbert9e9> ksf: that's.. wow.
09:26:23 <hpc> kmc: in soviet russia, glorious glaskow haskell compliation system run you!
09:27:06 <weirdo> c#: Func<int,bool> = x => x < 4;
09:27:16 <weirdo> :)
09:27:49 <djahandarie> Egbert9e9, sumMap f = sum . map f    vs    sumMap f xs = sum $ map f xs    is a simple example which I would choose to be point-free almost every time
09:28:10 <hpc> or sumMap = sum . map . ($)
09:28:25 <djahandarie> At which point I wouldn't make the decision to do that :P
09:28:25 <hpc> :t (. ($))
09:28:26 <lambdabot> forall b a b1. ((a -> b1) -> b) -> (a -> b1) -> b
09:28:38 <djahandarie> @type sum .: map
09:28:39 <lambdabot> forall a a1. (Num a) => (a1 -> a) -> [a1] -> a
09:28:46 <djahandarie> That's how I would do it if I wanted to kill the f also
09:28:50 <hpc> :t sum . map . ($)
09:28:51 <lambdabot>     Couldn't match expected type `[a]'
09:28:51 <lambdabot>            against inferred type `[a1] -> [b]'
09:28:51 <lambdabot>     In the first argument of `(.)', namely `map'
09:28:54 <hpc> bleh
09:29:10 <burp> :t (.:)
09:29:11 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
09:29:18 <burp> @hoogle (.:)
09:29:18 <lambdabot> No results found
09:29:48 <djahandarie> @type (Prelude..) Prelude.. (Prelude..)
09:29:49 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:29:50 <burp> where is it from, not Data.Functor
09:29:55 <weirdo> btw, is the book all there is to gory details of haskell, or should i start reading something else immediately?
09:30:03 <djahandarie> burp, that's what it is ^^
09:30:08 <djahandarie> You can ignore the functor abstraction
09:30:13 <kmc> which book?
09:30:31 <kmc> there's a ton of stuff to learn about Haskell
09:30:31 <weirdo> "learn you a haskell for great justice^Wgood"
09:30:32 <djahandarie> LYAH definitely does not go into gory details
09:30:36 <kmc> you will never run out
09:30:37 <burp> djahandarie: I mean, where is it defined?
09:30:45 <djahandarie> burp, in lambdabot.
09:30:51 <kmc> there's _Real World Haskell_ and the Haskell wiki and tons and tons of papers you can read
09:30:51 <burp> oh it's just in lambdabot, ok
09:31:02 <Saizan> the haskell report too
09:31:03 <weirdo> class Tofu t where  
09:31:04 <weirdo>     tofu :: j a -> t a j  
09:31:13 <kmc> and Haskell's gory details are nothing compared to GHC's gory details
09:31:23 <kmc> for which you can read the GHC wiki and the GHC source code
09:31:34 <weirdo> but why does this have a strange kind? the type variables aren't inside the class definition, they're inside function definition
09:31:58 <kmc> kind inference
09:31:59 <c_wraith> weirdo: the kind of the type variable is inferred from the function types
09:32:11 <kmc> it figures out the kinds of t, j, and a from how they're used
09:32:22 <kmc> defaulting to * if unconstrained
09:32:29 <c_wraith> looks like t has kind * -> (* -> *) -> *
09:32:32 <kmc> 'a' is unconstrained so it gets kind *
09:32:50 <kmc> then we know that «j a :: *» so «j :: * → *»
09:33:10 <mauke> what, → but not ∷ ?
09:33:13 <kmc> and «t a j :: *» so «t :: * → (* → *) -> *»
09:33:17 <kmc> mauke, and not ∗ either
09:33:29 <aristid> kmc: and sometimes -> mixed in
09:33:29 <kmc> i don't like the way ∷ looks in my font, and i am a selfish person
09:33:34 <kmc> yeah whoops
09:34:06 <weirdo> * -> (* -> *) -> * -- so the first * stands for t, (* -> *) stand for j a and the last one for the produced concrete type?
09:34:18 <kmc> the first * is t, the (* -> *) is j
09:34:20 <kmc> err
09:34:26 <kmc> the first * is a, the (* -> *) is j
09:34:34 <kmc> what we're computing is the kind of t
09:35:04 <shamster_> hey folks, question Re: file IO -- when reading a data file I'd like to parse the first n values of the (long) file, and perform some analysis on them before parsing the next set. Does file IO occur lazily, or does the entire file get read in?
09:35:15 <kmc> depends which functions you use shamster_
09:35:40 <kmc> "lazy IO" is an ugly hack -- normally, we don't allow IO execution to occur as a result of evaluation
09:35:41 <mauke> a :: *;  j :: * -> *;  j a :: *;  t :: * -> (* -> *) -> *;  t a :: (* -> *) -> *;  t a j :: *
09:35:46 <kmc> but it can be useful, so the std lib supports it
09:36:24 <hpc> @quote oasis
09:36:24 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
09:36:47 <shamster_> kmc: I'm taking a text data file and reading in values as Doubles. afterwards I'm doing various things with those, and ideally the values will be stuck into IORefs...
09:37:31 <shamster_> kmc: for each data set from the file I have to update some values and perform the analysis again..
09:37:55 <djahandarie> (*  *)
09:37:56 <mauke> sounds like it could be done with State, too
09:38:02 <djahandarie> (* < *)
09:38:06 <djahandarie> (* > *)
09:38:14 <mauke> djahandarie: valid ocaml code
09:38:25 <byorgey> hi augur 
09:38:30 <augur> hey
09:38:31 <mauke> I think the first one is also valid perl
09:38:55 <shamster_> mauke: was that Re: my comment?
09:39:00 <djahandarie> I'm pretty sure everything is valid perl.
09:39:09 <mauke> shamster_: the State, yes
09:39:11 <hpc> "i think that's valid perl" lol
09:39:15 <augur> byorgey: anything like that?
09:39:18 <mauke> djahandarie: obviously wrong
09:39:27 <byorgey> augur: I actually don't know how to encode typed lambda terms as a species
09:39:31 <augur> lame
09:39:33 <shamster_> mauke: I'm still struggling to find idiomatic ways to do it
09:39:39 <augur> byorgey: how about encoding equality of elements?
09:39:40 <byorgey> augur: the types introduce constraints which are not purely combinatorial
09:40:05 <byorgey> augur: what do you mean?
09:40:22 <augur> byorgey: well, like, the species of pairs of the same element, or whatever
09:40:43 <augur> i mean, i guess that could be using one kind of product instead of another
09:41:01 <byorgey> augur: oh, I see.  I don't know how to do that either, it seems hard because of beta-reduction.
09:41:12 <augur> no forget the LC right now
09:41:36 <augur> just imagine a species thats just like X*X except you pass it only one slot-filler
09:41:39 <weirdo> how do i check the kind of a class instead of a data type? ghci barfs at me
09:41:50 <augur> i believe that was listed in your paper as a tensor product or something
09:42:08 <augur> where you sent the enumerated elements down both sides of the pair, instead of just one side
09:42:18 <mauke> weirdo: I don't think classes have kinds
09:42:30 <kmc> they basically do
09:42:36 <kmc> but i don't know a way to ask GHC about them
09:42:56 <tarrasch> Hello, is it me or have the Functor instance for (,) disappeared during a night?
09:42:58 <codolio> There's no result kind for classes, so it can't really talk about them.
09:43:19 <c_wraith> well, it could be queried for the kind for its type parameters
09:43:19 <kmc> tarrasch, import Control.Monad.Instances?
09:43:32 <c_wraith> But that's probably just not implemented in GHCi
09:43:34 <kmc> i've seen them written like «Monad :: (* → *) → Prop»
09:43:45 <augur> byorgey: imagine tho that instead of that, you had just one slightly different version, where the sameness is separated by some other stuff
09:43:49 <byorgey> augur: oh, yes, Cartesian product
09:43:56 <tarrasch> kmc, ah, thanks!
09:43:59 <kmc> anyway if you put "instance Monad Int" in a file, ghc will give you a "kind mis-match" error and tell you the expected kind
09:44:05 <augur> eg X*Y*X
09:44:06 <Saizan> weirdo: to see the kinds of the type parameters you can :set -fglasgow-exts and :t one-of-the-methods, any type variable with a kind that's not * will have a kind annotation
09:44:16 <augur> where the X's must be the same, but the Y is different
09:44:19 <roconnor> "Category Theory for Computing Science" seems like a really good gook.
09:44:20 <Saizan> weirdo: not very direct way, but i'm not aware of a better one
09:44:22 <byorgey> augur: ok
09:44:24 <roconnor> *book
09:44:27 <augur> is that doable?
09:44:30 <kmc> haha, -fglasgow-exts
09:44:31 <hpc> roconnor: the best of gook :D
09:44:32 <freedrull> why is every datatype in Sound.MIDI named "T" :[
09:44:41 <byorgey> augur: well, you can just encode it as (X x X) * Y
09:44:46 <roconnor> :)
09:44:50 <mauke> freedrull: because you're not supposed to import it
09:44:56 <mauke> unqualified, I mean
09:44:57 <ezyang> If I make a map with infinitely many elements in it, what do I say it's "lazy" in? Values? No. Keys? I don't think so? 
09:44:57 <byorgey> augur: where the x is Cartesian product and * is normal (partitional) product
09:45:02 <kmc> Author Henning Thielemann <haskell@henning-thielemann.de>  ←  this is why
09:45:07 <mauke> ezyang: spine?
09:45:08 <augur> byorgey: true but one can imagine all sorts of obnoxious extensions that arent so simple
09:45:20 <weirdo> Saizan, thank you!
09:45:28 <augur> byorgey: so the idea is to have a general framework in which to express the sharing of a slot
09:45:31 <ezyang> mmm, yeah, I'd buy that. 
09:46:00 <byorgey> augur: OK, sure.  Just make up a product operation parameterized by some specificational information re: sharing, and axiomatize it appropriately
09:46:21 <augur> byorgey: so theres no established way of doing sharing
09:46:32 <byorgey> not that I am aware of.
09:46:50 <byorgey> but that doesn't necessarily mean there isn't.
09:46:53 <roconnor> a product with sharing is a pullback
09:46:54 <augur> ok
09:46:59 <roconnor> isn't it?
09:47:25 <augur> byorgey: cause i figure if theres a general way to describe sharing, then you can define typed lambda terms that way
09:47:32 <byorgey> roconnor: I'd have to think about whether that corresponds to the sort of thing augur is talking about.
09:47:40 <augur> somehow getting X -> Y and X to share the X
09:48:01 <byorgey> augur: I don't follow
09:48:24 <roconnor> byorgey: is augur assembly record structures with sharing, like in OO heirarchies?
09:48:32 <roconnor> *assembling
09:48:34 <augur> byorgey: well whatever X is, you would want to say that the things you enumerate into one of them are the same you enumerate into the other, right
09:49:01 <augur> whether its a single item (and X is therefore an atomic type) or a set of items (so that X is a function type)
09:49:01 <byorgey> roconnor: yes, I suppose so
09:49:20 <roconnor> that is done with pushouts.
09:49:31 <augur> eg if you enumerated {1,2} into X, and X is the same in both cases, X must enumerate out as a function X' -> Y'
09:49:32 <roconnor> augur: you may be interested in the category of theory presentations.
09:49:40 <byorgey> roconnor: ok, cool. I will have to ponder it.
09:49:40 <augur> roconnor: maybe i would! refs?
09:49:43 <djahandarie> byorgey, I feel like species somehow form a symmetric monoidal closed category, but I'm not sure how :)
09:50:14 <byorgey> djahandarie: symmetric monoidal I believe, but closed?
09:50:54 <byorgey> species do not admit exponentials, AFAIK
09:51:01 <djahandarie> byorgey, if the linear lambda calculus is its inner logic wouldn't it need to?
09:51:27 <roconnor> augur: maybe soem papers by Douglas Smith, e.g. ftp://ftp.kestrel.edu/pub/papers/smith/marktoberdorf.ps
09:51:30 <byorgey> the linear lambda calculus is its inner logic?
09:51:36 <roconnor> augur: I'm not sure that is the best introduction though :(
09:51:57 <djahandarie> byorgey, it isn't? :P
09:52:14 <byorgey> djahandarie: maybe, but I've never heard anything like that before
09:52:26 <augur> awesome, i'll take a look
09:52:26 <djahandarie> Neither have I, I'm just blabbing
09:52:53 <roconnor> augur: maybe I'm way off base here.
09:53:03 <augur> maybe! who knows. we'll see!
09:53:51 <djahandarie> Something to investigate when I'm not at work perhaps...
09:53:57 <shlevy> How would I write a rewrite rule to replace every instance of $ with U+FF04 (full-width dollar sign)?
09:54:41 * djahandarie wonders why you would want to do such a thing
09:54:45 <kmc> sed?
09:55:05 <djahandarie> kmc, that isn't a rewrite rule, in the pragma sense...
09:55:05 <roconnor> shlevy: you mean a GHC rewrite RULE?
09:55:20 <kmc> djahandarie, yeah, i ignored that meaning as it makes no sense
09:55:20 <shlevy> Basically I want to define (＄)= flip ($) in a module then use $ left associatively
09:55:33 <shlevy> roconnor: I think so? 
09:55:38 <roconnor> ah no
09:55:39 <kmc> dear lord
09:55:41 <djahandarie> Oh sweet god
09:55:48 <roconnor> that you can do, but it is terrible :D
09:55:59 <kmc> that is not what rules are for
09:56:14 <roconnor> import qualifed Prelude (($))
09:56:17 <djahandarie> Christ, grant us salvation
09:56:22 <roconnor> (＄)= flip (Prelude.$)
09:56:22 <djahandarie> Forgive our sins
09:56:22 <codolio> That won't work.
09:56:27 <codolio> Rules happen after parsing.
09:56:39 <kmc> ＄＄＄＄＄＄＄＄＄＄＄＄＄＄＄＄
09:56:51 <shlevy> roconnor: But I don't have ＄ on my keyboard.
09:57:01 <roconnor> right, you don't use rules for what shlevy wants, but you can write want shlevy wants with the normal module system.
09:57:18 <roconnor> shlevy: hey, you got it in your IRC window somehow :D
09:57:31 <shlevy> roconnor: Copy-paste :)
09:57:35 <roconnor> ...
09:57:36 <roconnor> wait
09:57:50 <roconnor> so what you acutally want to know is how to type ＄ in your editor?
09:58:24 <shlevy> roconnor: No, I want to write code using $ as if it were left-associative then do what I have to do to make the compiler work with the standard prelude
09:58:26 <byorgey> import Prelude hiding (($))
09:58:30 <byorgey> import qualified Prelude
09:58:35 <shlevy> If I can do it without ＄then great
09:58:39 <byorgey> ($) = flip Prelude.($)
09:58:44 <shlevy> byorgey: Ah, perfect
09:58:46 <byorgey> USE AT YOUR OWN RISK
09:59:01 <roconnor> shlevy: ya, don't share your code with anyone else :D
09:59:11 <hpc> > let infixl ($); ($') = flip ($) in 1 $' (1+)
09:59:11 <lambdabot>   <no location info>: parse error on input `('
09:59:16 * shlevy always thinks of the complicated soultion first
09:59:18 <kmc> jesus christ, why not just define a new operator
09:59:23 <hpc> ^ or something like that
09:59:24 <Jafet> You want to redefine a Prelude function so that it does something totally different?
09:59:25 <kmc> @let (€) = ($)
09:59:25 <lambdabot>  <local>:2:0:
09:59:26 <lambdabot>      Multiple declarations of `L.<stderr>: hPutChar: invalid ar...
09:59:27 <kmc> @let (€) = flip ($)
09:59:28 <lambdabot>  <local>:2:0:
09:59:28 <lambdabot>      Multiple declarations of `L.<stderr>: hPutChar: invalid ar...
09:59:35 <Jafet> @undef
09:59:38 <kmc> @let (€) = flip ($)
09:59:38 <lambdabot>  Defined.
09:59:39 <hpc> the bot cannot unicode i think
09:59:43 <hpc> oh
09:59:45 <shlevy> kmc: Is there anything available on a standard US keyboard?
09:59:49 <shlevy> :t !
09:59:50 <kmc> > 3 € succ
09:59:50 <lambdabot> parse error (possibly incorrect indentation)
09:59:51 <lambdabot>   4
09:59:54 <roconnor> kmc: especially given that the $ operator is kinda a terrible name
10:00:14 <Jafet> shlevy: a compose key?
10:00:16 <kmc> shlevy, the one-character operators unused by Prelude are %, #, and !
10:00:25 <kmc> and (&)
10:00:38 <kmc> and (?)
10:00:51 <kmc> i know this because i wrote obfuscated code that uses all of them
10:00:51 <weirdo> i think i "get" kinds now to some extent. thanks guys!
10:01:14 <shlevy> Ok, for some reason I remember having reason to think no one-character ops were available. Never mind, will not use $
10:01:33 <kmc> or set up a Compose key or AltGr so you can type cool characters
10:01:35 <Jafet> % is used by Ratio, ! is used by Array, and # is used by ghc
10:01:36 <shlevy> I think I'll use #. Poor man's £
10:01:45 <kmc> wouldn't that be 'p'
10:01:54 <roconnor> kmc: ! seems like it would be better than $
10:01:58 <Jafet> > 0 <<< succ
10:01:59 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> c)
10:01:59 <lambdabot>    arising from a use of `...
10:02:03 <MasseR> wow. The program runs in 3-4 seconds without compiler optimizations, and in 30 seconds with -O2
10:02:13 <Peaker> everyone initially searches for reasons to dismiss Haskell (or any new thing that would be an investment to learn, so it's well-placed mistrust). When they see Haskell code, they sometimes encounter obfuscated operator names. To some, this weighs in on dismissal
10:02:23 <roconnor> kmc: since array indexing and function applications are homomorphic.
10:02:28 <kmc> (#) itself isn't used by GHC, to my knowledge
10:02:37 <shlevy> :t (#)
10:02:37 <lambdabot> parse error on input `)'
10:02:38 <kmc> and turning on -XMagicHash doesn't make it invalid as an operator
10:02:44 <hpc> > let (#) = ($) in succ # 1
10:02:45 <lambdabot>   <no location info>: parse error on input `)'
10:03:03 <hpc> '#' is syntax, it seems
10:03:03 <ezyang> Orc totally uses # for its continuation destructor. 
10:03:12 <shlevy> let (!) = ($) in succ ! 1
10:03:17 <codolio> > let i# = 5 in i#
10:03:18 <kmc> works for me hpc
10:03:18 <lambdabot>   5
10:03:21 <shlevy> > let (!) = ($) in succ ! 1
10:03:21 <aristid> didn't TRex use #?
10:03:22 <lambdabot>   2
10:03:23 <shamster_> Re: my previous question on State/IORef, suppose I've got a record with fields like { name, date, ID, location, birthplace } where a data file holds a series of values for the location, but all the other fields are static. I need to update the locations of several of these records and then perform various filters and manipulations based on all the fields and the locations. Would it make sense to use an IORef for the location field?
10:03:29 <kmc> even with -XMagicHash
10:03:39 <aristid> itsamagic hash
10:03:47 <kmc> shamster_, why perform "updates"?  why not write a function that takes a record and returns another record?
10:04:05 <roconnor> shamster_: the data accessor library supports the state monad nicely
10:04:07 <Philippa> Peaker: yeah, one of the problems with "obfuscated" operator names is that long ones actually get in the way of doing algebra on code though
10:04:28 <Philippa> when mathematicians use tiny names, it's not just about the pencil strokes
10:04:35 <shamster_> kmc: yes, I suppose that would work.
10:04:41 <shamster_> roconnor: I'll look into it
10:04:46 <shamster_> thanks for the pointers
10:04:54 <Philippa> (long names make the bit of your brain that tries to put meaning into them click on, and if you're don't algebra you /don't want that/)
10:05:16 * shlevy thinks ♯ would be great for obfuscated code
10:05:31 <kmc> shamster_, what programming languages have you used before?
10:05:35 * hpc is sorely tempted to make a combinator calculus that uses musical notes
10:06:22 <shamster_> kmc: mostly C++ and python
10:06:37 <kmc> those languages have trained you to think in terms of "updates"
10:06:45 <kmc> unlearning this is a big part of learning Haskell
10:06:48 <shlevy> I was looking for a backwards $ in Unicode, but couldn't find any. 
10:06:49 <shamster_> kmc: I'm keanly aware ;)
10:06:55 <Peaker> Philippa, that would be true of all functions though?
10:06:57 <kmc> it's also a big part of learning to write maintainable, correct code in any language
10:07:07 <Jafet> hpc: design it so that Ring des Nibelungen is a metacircular compiler
10:07:12 <Peaker> Philippa, I find that all infix operators are slightly confusing when refactoring expressions mechanically
10:07:15 <jmcarthur> MasseR: what about with just -O ?
10:07:23 <Peaker> Philippa, (e.g: when converting to points-free)
10:07:24 <hpc> Jafet: wha! /me googles this
10:07:26 <shamster_> kmc: That's where i'm stuck and worry about the efficiency of things like File IO and laziness when I "read" in a 4GB file
10:07:45 <roconnor> kmc: then you have relearn updates in a State Transformer monad sense. :D
10:07:46 <kmc> if you're reading 4 GB as String you have no hope of efficiency anyway
10:08:00 <hpc> Jafet: i think i will take the more ironic approach, and make aphex twin a C++ interpreter
10:08:06 <Peaker> shamster_, I suggest "fclabels" for functional update of some fields
10:08:31 <roconnor> Peaker: AFAIK fclables doesn't have functions that integrate with the state monad like data.accessor does
10:08:33 <Peaker> shamster_, basically, if you have:  data Pos = Pos { x, y :: Integer },  then "fclabels" gives you something like:   atX :: (Integer -> Integer) -> Pos -> Pos
10:08:35 <shamster_> kmc: I can do some pretty quick things in c++ with my text data files... reading just bits at a time and updating the necessary object data
10:08:59 <Peaker> roconnor, isn't it something like:  (modify .) . Label.set ?
10:09:00 <kmc> right
10:09:07 <kmc> i meant GHC Haskell's String type specifically
10:09:10 <roconnor> shamster_: fclabels and data.accessors are competitors :)
10:09:17 <shamster_> kmc: ah... 
10:09:21 <Jafet> MasseR: that happens with ghc sometimes, you can check the trac for known cases
10:09:26 <kmc> my point is, the incremental reading is necessary when you get to that size
10:09:31 <MasseR> jmcarthur: -O is slow too
10:09:33 <kmc> but rather than messing around with "lazy IO"
10:09:37 <kmc> which as i said is an ugly hack
10:09:45 <kmc> i would just have a loop that explicitly reads one line, or whatever other unit
10:09:53 <shamster_> Peaker: roconnor: I'll look into those...
10:09:56 <kmc> and passes that along with the old record(s) to a function
10:09:58 <kmc> which returns a new record
10:10:15 <Peaker> shamster_, I think the nice functional approach here would be to read the file, split the file data into the bits you want, map the bits of data to updater functions (of type: YourRecord -> YourRecord). then compose them all (with something like foldr (.) id) into a single big   YourRecord -> YourRecord   and apply to the initial record state
10:10:19 <Jafet> hpc: if you're going for irony, the C++ interpreter should be "Erwachen heiterer Empfindungen bei der Ankunft auf dem Lande".
10:10:27 <mauke> haha
10:10:35 <roconnor> oh fclables does have some MonadState functions ...
10:11:14 <hpc> Jafet: there aren't nearly enough notes in that song to implement all of C++
10:11:15 <Peaker> shamster_, something like:   bigRecordUpdater = foldr (.) id . map recordUpdaterFromLine . lines ;   bigRecordUpdater fileContents initRecord
10:11:19 <shamster_> Peaker: that's sort of where I'm at right now, but things like "read the file" sounds scary. Some of my data sets run into the 100GB sizes...
10:11:36 <MasseR> 99% of the execution time is spent on single function. It shouldn't really be that slow.. hmm
10:11:52 <Peaker> shamster_, well, there is a quick&dirty way to "lazily" read a file of that size, and a correct&advanced way.. if you're just beginning, I suggest the quick&dirty way
10:11:55 <jmcarthur> MasseR: sounds like a compiler bug if it goes slower with optimizations
10:12:07 <jmcarthur> MasseR: unless there's a weird rewrite rule firing or something that's causing it
10:12:20 <kmc> the alternative to Peaker's dichotomy is to just do multiple small reads
10:12:29 <MasseR> jmcarthur: Can I check that somehow? (I am using stream-fusion)
10:12:39 <Peaker> Yeah, imperative loop calling getLine is fine, I guess
10:12:44 <Peaker> (or any "getBit")
10:12:53 <Peaker> getLine is at least strict I/O, right?
10:13:11 <jmcarthur> MasseR: oh! i bet you are relying on something being shared, but the compiler is inlining it so it gets recomputed
10:13:32 <kmc> MasseR, use ghc-core
10:13:37 <kmc> it will dump out the Core intermediate format
10:13:42 <kmc> and also tell you which rules fired
10:13:42 <shamster_> kmc: That's where I'm at now in the sense that I'm doing: map read $ concat $ map words $ lines inputTextData :: [Double]
10:13:50 <jmcarthur> yeah i was going to suggest that too, MasseR ^^
10:13:58 <MasseR> kmc: I have a little trouble parsing that :P
10:13:59 <kmc> shamster_, that's not doing multiple reads
10:14:13 <shamster_> kmc: no, I suppose it isn't
10:14:18 <jmcarthur> MasseR: the hardest thing about Core is the weird names. once you're over that it's pretty easy
10:14:22 <kmc> i'm talking about executing getLine over and over
10:14:31 <hpaste> noteventime pasted "Search thing"  http://hpaste.org/44592
10:14:39 <MasseR> jmcarthur: Yup, I'll check it
10:15:11 <weirdo> crap, LYAH doesn't say anything about forall
10:15:24 <shamster_> kmc: This sounds painful ;)
10:15:34 <codolio> > words "1234\n1234\n1234 1234"
10:15:35 <lambdabot>   ["1234","1234","1234","1234"]
10:15:39 <Peaker> yay, hGetLine is sanely strict
10:15:47 <jmcarthur> weirdo: what do you need to know about forall?
10:15:50 <codolio> > words "1234\n1234 \n 1234 1234"
10:15:51 <lambdabot>   ["1234","1234","1234","1234"]
10:16:00 <jmcarthur> there are a few reasons it might come up
10:16:10 <kmc> shamster_, yeah... there isn't a great solution here
10:16:10 <Peaker> "forall" information is dispersed on a strict need-to-know-basis :)
10:16:15 <weirdo> jmcarthur, i'm just a newbie, but i'd like to know as much as possible about the language, so i could write better programs i won't throw out immediately i get better at haskell
10:16:32 <hpc> @src words
10:16:33 <lambdabot> words s = case dropWhile isSpace s of
10:16:33 <lambdabot>     "" -> []
10:16:33 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:16:45 <shamster_> kmc: why is the lazy file reading not as good?
10:16:48 <kmc> the options are basically "consume tons of memory" (strict whole-file read), "error-prone and semantically dubious" (lazy IO), "crazy API" (iteratee / enumerator), or "imperative loop" (what i suggested)
10:17:02 <kmc> shamster_, because it breaks a basic principle of Haskell: that IO execution never results from expression evaluation
10:17:08 <jmcarthur> weirdo: forall a b c. a -> b -> c   is just the same as   a -> b -> c, so if you're just seeing ghci pop that out or something there's nothing too weird happening there
10:17:21 <shamster_> kmc: okay, that's what I'm wondering
10:17:21 <kmc> this means e.g. that error handling is nonexistent
10:17:22 <Peaker> weirdo, when you have a type like:  id :: a -> a     then the "a" there is a "type variable", right? that basically means there's an implicit "forall a." prefix to that type thus:  id :: forall a. a -> a      which does two things: A) give the type variable "a" its scope.  B) specify that it is polymorphic, can take any type whatsoever
10:17:34 <kmc> shamster_, what's your file format? textual or binary?
10:17:48 <kmc> shamster_, the String type is woefully inefficient; you could use Text or ByteString respectively
10:17:49 <shamster_> kmc: text
10:17:51 <roconnor> shamster_: lazyIO effectivly has semantics of concurency, and some of the troubles that come along with that.
10:17:55 <kmc> there are parser libraries to deal with each
10:17:56 <hpaste> noteventime pasted "Search thing"  http://hpaste.org/44593
10:18:06 <kmc> it has semantics of concurrency in a pure expression-evaluation context
10:18:10 <kmc> which is real bad
10:18:25 <Eduard_Munteanu> Nevertheless, lazy IO is a sane option in many cases.
10:18:32 <Eduard_Munteanu> (saner than strict IO for instance)
10:18:33 <weirdo> Peaker, jmcarthur, but what does it mean when forall is specified explicitly to be something else than the default case? other than that, in which cases do i need to specify it?
10:18:48 <shlevy> kmc: What do you use in place of lazy IO?
10:18:52 <hpc> the trick to lazy IO is knowing when you actually need IO
10:18:57 <hpc> shlevy: par/pseq
10:18:58 <Peaker> weirdo, in normal Haskell (by the standard, Haskell 98 or Haskell 2010) "forall" doesn't even exist. it's a GHC extension
10:19:09 <kmc> shlevy, any of the three other options
10:19:12 <kmc> depending
10:19:13 <Peaker> weirdo, normally you never use it. If you want some additional language features that aren't in Haskell but in GHC, you use it
10:19:14 <roconnor> kmc: if you don't rely on lazy IO reading at specific times and pretend that it is reading in a separate thread, lazy IO isn't so bad.
10:19:20 <Eduard_Munteanu> weirdo: only for existential and rank-n types
10:19:32 <kmc> and for ScopedTypeVariables
10:19:40 <Peaker> weirdo, for example, there's a GHC language extension called "ScopedTypeVariables" that allows you to re-use type-variables from outer declarations in inner ones
10:19:40 <Eduard_Munteanu> Ah, that too.
10:19:42 <kmc> and ImpredicativeTypes
10:20:07 <Eduard_Munteanu> (though those are pretty similar to rank-n)
10:21:13 <Eduard_Munteanu> Lazy Bytestrings are pretty standard these days.
10:21:31 <Peaker> weirdo, but only if you scoped them explicitly with "forall"
10:21:32 <Eduard_Munteanu> And with care they work well.
10:21:51 <kmc> lazy ByteString doesn't imply lazy I/O
10:21:57 <kmc> but, yes
10:22:04 <kmc> i'm not saying one should never use lazy IO
10:22:08 <Eduard_Munteanu> They do use lazy IO, AFAIK.
10:22:08 <Philippa> weirdo: you'll know when you need it because you won't be able to get the typechecker to figure your type out without it :-)
10:22:15 <kmc> Eduard_Munteanu, if you do IO with them...
10:22:21 <weirdo> ok :-)
10:22:21 <Eduard_Munteanu> Ah, sure.
10:22:24 <kmc> i'm just saying it's a hack with various unseemly consequences
10:22:49 * Eduard_Munteanu wonders if we have rank-2 inference
10:23:04 <Philippa> we don't in GHC
10:23:20 * kmc recently uploaded a library which uses unsafeInterleaveIO so does not hold a terribly great moral high ground
10:23:20 <Philippa> (I forget whether you can have it and still cover rank-n with annotations or not, I suspect not though)
10:23:36 <kmc> (in my defense, it should be totally invisible)
10:23:37 <Philippa> (for "has it been proven impossible yet?" values of "can", not "can GHC do it?")
10:23:47 <Eduard_Munteanu> Heh.
10:23:53 <Philippa> mmm. Could be worse: my current project has an unsafeCoerce in it
10:24:05 <kmc> could be worse: use reallyUnsafePtrEq#
10:24:18 <Philippa> heh. No, the unsafeCoerce is enough to let me avoid that :-)
10:24:21 <Eduard_Munteanu> Philippa: ah, I only know rank-n can't be inferred, but 1 and 2 can.
10:24:29 <roconnor> Philippa: unsafeCoercing one type variable to another?
10:24:32 <Philippa> (I'm tearing apart recursive structures)
10:24:34 <Eduard_Munteanu> I'm not sure about limited inference for k >= 3.
10:24:37 <Saizan> on a related note, anyone knows if first order unification can be extended to deal with quantifiers in the language and keep decidability?
10:24:42 <MasseR> How do I check rewrite errors if ghc-core can't handle optimizations?
10:24:54 <kmc> it can't?
10:24:54 <Philippa> roconnor: a type variable to the concrete type I already know it must have but really, really don't want to figure out how to prove it with GADTs
10:25:08 <kmc> ghc-core is just a frontend to ghc -ddump-simpl and others
10:25:41 <jmcarthur> MasseR: ghc-core -- -O Foo.hs
10:26:01 <Philippa> Saizan: how general a case do you need? Higher-order unification in general is undecidable
10:26:03 <MasseR> jmcarthur: Thanks
10:28:54 <Egbert9e9> iknow this solution isn't very smart
10:29:20 <Saizan> Philippa: higher order unification includes terms like F(x) where F is an unification variable that can stand for a lambda term, but to handle something like RankN haskell types (without type families) i don't think i need that
10:29:59 <Egbert9e9> for primeFactors i have this auxilary function called primeFactors' which takes the primeFactors input and initially 2
10:30:32 <Saizan> Philippa: i wonder if GHC is already doing this kind of unification, actually
10:30:34 <Egbert9e9> it then checks if the first is divisiable by the second
10:30:50 <Peaker> weirdo, another extension allows you to have data-types that are polymorphic "existentially" rather than "universally"... i.e: instead of:  data forall a. Blah a = Blah a ;  you can have:  data Blah = forall a. Blah a ;  The type of the Blah constructor is:  forall a. a -> Blah ; but the type of the value you extract out of the constructor is: exists a. a
10:31:00 <MasseR> Yup, it was the stream-fusion package 
10:31:29 <shamster_> kmc: when using a readFile, the return is String, which you claim is inefficient compared to Text. Is there a way to read a file to Text?
10:31:40 <Philippa> Saizan: you could read some of the papers on rank-n inference?
10:31:47 <Peaker> weirdo, So placement of "forall" in the right place can reverse the polymorphism's "direction" in a sense, and instead of the value being polymorphic to its user, it is polymorphic to its provider (the provider gets to choose whatever type, and the user needs to accommodate every type, which is usually the other way around)
10:32:08 <mikolaj> hi!
10:32:28 <shamster_> Or is there a way to read values from a text file directly to Double?
10:32:31 <Eduard_Munteanu> mikolaj: hi
10:33:07 <jmcarthur> shamster_: what is it that you're doing exactly?
10:33:40 <shamster_> jmcarthur: I'm reading in a text data file that has a series of Double values
10:33:43 <Eduard_Munteanu> There's 'read'.
10:33:48 <Eduard_Munteanu> :t read
10:33:49 <lambdabot> forall a. (Read a) => String -> a
10:33:56 <Saizan> Philippa: true! it's been a while since i've done that
10:34:04 <mauke> @hoogle hReadLn
10:34:05 <lambdabot> No results found
10:35:05 <shamster_> Eduard_Munteanu: is that the most efficient way, or is Data.Text somehow faster?
10:35:50 <hpc> i would assume read for doubles has had the bejesus optimized out of it
10:35:57 <c_wraith> I wouldn't
10:36:01 <jmcarthur> shamster_: if it's only doubles then i'd say text is overboard. bytestring sounds fine for that purpose to me. http://hackage.haskell.org/packages/archive/bytestring-lexing/0.2.1/doc/html/Data-ByteString-Lex-Double.html
10:36:13 <djahandarie> read for doubles is very slow
10:36:32 <Eduard_Munteanu> Well, Bytestrings could be faster.
10:37:08 <kmc> you could also write a C program to convert it into 64-bit IEEE floats
10:37:11 <c_wraith> Bytestring certainly allows the fastest code, from a perspective of minimal overhead.
10:37:14 <Eduard_Munteanu> If the file has doubles in it you don't need provisions for multibyte text.
10:37:16 <kmc> (or even a Haskell program you run once)
10:37:34 <djahandarie> It would be interesting if the Text type was tagged with its encoding
10:37:39 <shamster_> Is the idea to read the contents of the file and get a String, and then convert all that to a series of Bytestrings?
10:37:51 <kmc> shamster_, no.  the idea is to read ByteString
10:37:55 <jmcarthur> shamster_: no, read it as a bytestring in the first place
10:38:03 <kmc> String uses vastly more memory and is thus slower too
10:38:04 <djahandarie> Or would that break the model, actually
10:38:08 <Eduard_Munteanu> (and don't use 'unpack' on it)
10:38:27 <shamster_> okay, this is going to take a long while to convert...
10:38:31 <kmc> in GHC Haskell, a String is a singly-linked list of heap-allocated cells each of which holds a Unicode codepoint in UTF-32 (?)
10:38:39 <jmcarthur> bytestring also can be read in efficient chunks
10:39:19 <kmc> a strict ByteString is a flat array of bytes and a lazy ByteString is a list of large chunks represented as strict ByteStrings
10:39:41 <jmcarthur> i have an attoparsec parser that's surprisingly 80% faster than a C++ version of the same parser, right now. the C++ one is just using cin, but it's a similar level of effort so i think is worth comparing
10:40:00 <jmcarthur> it's numeric literal heavy
10:40:06 <jmcarthur> reading the numbers is the slowest part, too
10:40:25 <jmcarthur> for the haskell version, at least
10:40:26 <c_wraith> Doesn't attoparsec have a double parser built in?
10:40:40 <jmcarthur> c_wraith: it does, but it has an obvious, pure implementation
10:40:46 <c_wraith> ah, ok.
10:40:54 <c_wraith> I thought that's something bos would have optimized the bejesus out of.
10:41:01 <jmcarthur> c_wraith: i actually rewrote it because it wasn't specialized for Word, which i wanted
10:41:04 <monochrom> Text's encoding — or rather, representation — is UTF-16. Tagging Text with its encoding is tagging Text with a known constant.
10:41:06 <shamster_> jmcarthur: cin is not the fastest way to go, but that goes in ##c++ :)
10:41:24 <djahandarie> monochrom, yeah
10:41:25 <kmc> i seem to remember reading about a bejeesus-optimized double parser
10:41:26 <jmcarthur> shamster_: yes, but cin is easy, and so is attoparsec, so that's why i think it's worth comparing
10:41:40 <aristid> jmcarthur: c++ iostreams are ridiculously slow
10:41:49 <kmc> Text's encoding is invisible, that's like tagging Int with whether they're big-endian or little-endian
10:42:06 <jmcarthur> aristid: as i just said, this is about the efficiency to effort ratio ;)
10:42:08 <kmc> you could tag a Text value with the encoding of the file it was read from, but that doesn't seem the responsibility of the text library itself
10:42:11 <astory> I'm trying to use the Data.List.Split module but my runtime can't seem to find it.  Any ideas on how to debug?
10:42:19 <kmc> ghc --make
10:42:56 <jmcarthur> aristid: this is at least with cin unsynced with stdio, which helps a lot compared to the default
10:43:11 <Eduard_Munteanu> @hoogle Split
10:43:11 <lambdabot> Data.Graph.Inductive.Internal.Thread type Split t i r = i -> t -> (r, t)
10:43:11 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
10:43:11 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
10:43:11 <aristid> jmcarthur: heh, true
10:43:38 <Eduard_Munteanu> astory: did you install it by cabal-install, or how?
10:43:46 <astory> Eduard_Munteanu: apt-get
10:43:59 <astory> it's possible I don't have the package with that library, I'm looking to see if I can find it
10:44:17 <Eduard_Munteanu> astory: does 'ghc-pkg list' show it?
10:44:19 <kmc> astory, what's the error message?
10:44:36 <astory> Could not find module `Data.List.Split'
10:44:51 <kmc> what are you using to build? cabal or ghc directly?
10:44:56 <astory> kmc: runhaskell
10:45:02 <kmc> k
10:45:14 <astory> Eduard_Munteanu: http://pastebin.com/k1NJFqis
10:45:36 <astory> I can import Data.List fine
10:45:47 <kmc> i should hope so
10:45:52 <c_wraith> astory: Data.List.Split is in the split package.  Not included by default in GHC.
10:46:01 <astory> ok, so I need to find that then
10:46:06 <kmc> cabal install split
10:46:20 <kmc> or: apt-get install libghc6-split-dev
10:46:41 <Eduard_Munteanu> He said he installed it via apt-get, I assumed he installed 'split'
10:46:44 <astory> is there a difference between libghc6-split-dev and -split-prof?
10:46:49 <kmc> yes
10:46:50 <astory> Eduard_Munteanu: oh, no, sorry
10:46:57 <Eduard_Munteanu> Ah, so only ghc.
10:46:59 <kmc> -dev has the normal library, -prof has the profiling version
10:47:12 <astory> ah, thanks for the help
10:47:36 <Eduard_Munteanu> Yeah, ghc-pkg doesn't show it there.
10:47:39 <kmc> you'll want the -prof version if you ever build your application with ghc -prof
10:47:42 <astory> it imported fine now, thanks
10:48:22 <hpc> kmc: will it just not compile, or will it keep you from looking "into" the package when you profile?
10:48:27 <Eduard_Munteanu> BTW, is there anything that makes -prof -auto-all -caf-all shut up about missing profiling libs and go ahead with what it has?
10:48:53 <djahandarie> It needs the profilings libs
10:48:55 <Eduard_Munteanu> hpc: normally it won't build it
10:49:01 <hvr_> I'm trying to migrate from Text.JSON to Data.Aeson, but I'm not sure how to get parsing working; does
10:49:04 <hvr_> decode :: FromJSON a => B.ByteString -> Result a
10:49:07 <hvr_> decode s = either Error fromJSON $ parseOnly json s
10:49:07 <hvr_> look about right?
10:49:18 <kmc> hpc, won't compile; code built with -prof uses a different ABI and can't link to code built without
10:49:23 <kmc> (if you made it link i'd expect segfaults)
10:49:33 <hpc> groovy
10:49:36 <Eduard_Munteanu> Eww.
10:49:52 <hpaste> freedrull pasted "getvlv"  http://hpaste.org/44595
10:50:00 <kmc> whether you can profile "into" the library depends on whether it was built with any cost centers, which is a separate question
10:50:08 <Egbert9e9> why is (mod) of Integral and (/) of Fractional?
10:50:28 <Eduard_Munteanu> > 9 / 2
10:50:29 <lambdabot>   4.5
10:50:53 <ion> :t div
10:50:54 <lambdabot> forall a. (Integral a) => a -> a -> a
10:51:00 <ion> :t divMod
10:51:01 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
10:51:31 <Eduard_Munteanu> 9.32 `mod` 3.4 doesn't make much sense.
10:51:37 <Egbert9e9> ooops
10:51:55 <ion> eduard_munteanu. Well, it does.
10:52:27 <ion> That would be 2.52 :-)
10:52:30 <Egbert9e9> forgot about (div)
10:52:41 <ion> … if we had a fractional mod.
10:52:44 <Eduard_Munteanu> Heh. It could also be 0 :P
10:53:30 <ion> 9.32 `divModFractional` 3.4 = (2, 2.52)
10:53:45 <mikolaj> > :t quotRem
10:53:45 <lambdabot>   <no location info>: parse error on input `:'
10:53:53 <mikolaj> :t quotRem
10:53:54 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
10:53:56 <Eduard_Munteanu> Yeah, if you define it as integer multiple of ___.
10:55:08 <ksf> has anyone yet tried to get >>= into unicode?
10:55:23 * Eduard_Munteanu looks in his vimrc
10:55:46 <freedrull> i'm trying to parse a variable length sequence of bytes, if the current byte is 0x80, then the next byte is part of the sequence... http://hpaste.org/44595/getvlv
10:55:46 <ksf> I've seen > >= and >> = combined, but not a true >>=
10:55:59 <dankna> I would argue that >> = is the right way to do it
10:56:04 <Eduard_Munteanu> Hrm, I don't have it.
10:56:12 <c_wraith> how many open code points are there in the unreserved unicode ranges?
10:56:46 <dankna> there are about 2^20 unused codepoints, I think, not sure.  but that's not the same thing as the "private-use" ranges
10:56:56 <monochrom> return (n+n'_
10:56:58 <monochrom> err
10:57:00 <monochrom> return (n+n')
10:57:12 <monochrom> oh, there are other problems
10:57:50 <freedrull> oh right...n' is a Get Int not an Int..
10:58:04 <dankna> alternatively we could pick something from the mathematical-symbols area that doesn't necessarily have to look like ">>=", and just declare that for our purposes it's a synonym.
10:58:20 <dankna> perhaps ? for example
10:58:44 <ion> “?”?
10:58:53 <dankna> or even ?
10:59:00 <djahandarie> Alternatively, we could not try to find unicode for it an stop using unicode for what should be as easy as typing natural language.
10:59:02 <dankna> that came out as two question marks, ion?
10:59:08 <ion> yes
10:59:51 <dankna> djahandarie, surely the ease of typing it is orthogonal.  if there were a standard meaning for it, then text editors could treat it as a ligature, and then it would be just as easy to type.
10:59:52 <confound> »=
11:00:21 <monochrom> freedrull: http://hpaste.org/paste/44595/getvlv_annotation#p44596
11:00:32 <ksf> I think lhstex ligiaturises it, doesn't it?
11:00:36 <djahandarie> Also, I'm willing to bet that crazy greek letters and symbols is what turns off most people from higher-level math
11:00:38 <dankna> no idea
11:00:55 <kmc> haha
11:00:59 <Jafet> Haskell isn't for most people, you dimwit, it's for higher-level math!
11:01:00 <kmc> i am not willing to bet that
11:01:00 * Eduard_Munteanu proposes the predator laser thingy sign: ∴​
11:01:06 * hackagebot ascii 0.0.1 - Type-safe, bytestring-based ASCII values.  http://hackage.haskell.org/package/ascii-0.0.1 (MichaelSnoyman)
11:01:17 <ksf> that's symmetric.
11:01:26 <ksf> don't use symmetric symbols for asymmetric stuff.
11:01:28 <djahandarie> We don't need to make Haskell any more superficially scary than it already is with its monads and zygohistomorphic prepromorphisms
11:01:33 <monochrom> I'm willing to bet that crazy greek symbols is just an excuse.
11:01:36 <ksf> or do you write = to mean assignment?
11:01:38 <jmcarthur> people who are turned off by greek letters are unlikely to appreciate math even without the greek letters
11:01:48 <Eduard_Munteanu> (They say it's "therefore", but I'd read it as "run!" :P)
11:02:01 <ksf> jmcarthur, nope.
11:02:11 <ksf> a lot of math notation is actually pretty awful.
11:02:25 <jmcarthur> ksf: i mean aside from notational matters entirely
11:02:35 <Eduard_Munteanu> Yeah, some Greek letters are pretty bad, like iota
11:02:39 <monochrom> the turned-off people haven't even seen the awful part.
11:02:57 <pozic> Why is Haskell not crushing F# in popularity considering that most people like Haskell syntax better than OCaml syntax?
11:03:00 <jmcarthur> i'm too stubborn to dumb down my notation for people who are too closed-minded to look past superficial things in the first place, really
11:03:06 <pozic> Hint: it has nothing to do with Greek letters.
11:03:50 <ksf> jmcarthur, I'm just unaccustomed to them. and I don't get why people use greek letters when there's enough latin ones to go by.
11:04:05 <djahandarie> jmcarthur, I'm too stubborn to spend time obscuring my paper just to make it look a little prettier.
11:04:06 <Eduard_Munteanu> pozic: 'cause Haskell doesn't have cheat codes, like stuff for imperative programming. No god mode here (well, except unsafePerformIO).
11:04:09 <jmcarthur> typing unicode isn't hard, either. you just need an editor that doesn't suck configured in a way that doesn't suck. i admit, most people don't want to go through the trouble, but between editor support and language support for unicode, one of them has to give in before the other
11:04:24 <pozic> Eduard_Munteanu: that is not the reason.
11:04:35 <pozic> Eduard_Munteanu: and it would be pretty false.
11:04:56 <jmcarthur> djahandarie: it's only obfuscation if you're not looking at it abstractly in the first place
11:05:02 <Eduard_Munteanu> F# is pretty imperative so they feel comfy with it.
11:05:11 <vegai> pozic: are you sure it isn't?
11:05:22 <vegai> ...crushing F# in popularity, that is
11:05:32 <dankna> doesn't F# have Microsoft supporting it?
11:05:40 <dankna> if so, I would nominate that as the reason behind any popularity it has
11:05:42 <jmcarthur> ksf: i often go with greek to avoid accidental abbreviations and such, for one example
11:05:42 <djahandarie> jmcarthur, people speak and read English more than anything else. Any other language or uncommon symbols are wandering into the land of obscurity.
11:05:50 <Eduard_Munteanu> Doesn't GHC have Microsoft supporting it? :P
11:05:56 <dankna> not in the same way :)
11:05:57 <Eduard_Munteanu> (well, I know it's not at the same level)
11:05:57 <dankna> but yes
11:05:59 <jmcarthur> djahandarie: they're just symbols. they aren't meant to be english-like in any way
11:06:13 <jmcarthur> to me, that's the point
11:06:23 <djahandarie> jmcarthur, I can scan English much faster than anything else. I have a hell of a time following things when other languages are used
11:06:26 <jmcarthur> removes existing associations from the concepts the symbols represent
11:06:28 <pozic> vegai: it is tools, tools, tools. F# has Visual Studio integration (but I read somewhere that it is still broken). 
11:06:36 <jmcarthur> djahandarie: maybe you just need to slow down then
11:06:41 <djahandarie> jmcarthur, why?
11:06:45 <monochrom> Definition. Obscure = Did not see before age 20.
11:06:58 <monochrom> People do write-protect their brains at 20.
11:07:02 <weirdo> f# has horrible type-inference
11:07:06 <jmcarthur> djahandarie: either that or there's no point in the math notation in the first place
11:07:34 <pozic> weirdo: yet, still lots of people decide F# over Haskell.
11:07:38 <jmcarthur> djahandarie: the word "scan" seems to imply that you are reading it pretty quickly, which means the material is information sparse and probably should just be prose anyway
11:07:55 <monochrom> Example. Why is ξ obscure? Because didn't see it in school before 20. Note: some elite British people find ξ not obscure; they saw it in elite school before 20.
11:08:04 <djahandarie> jmcarthur, no, it means that I see a variable somewhere, and I want to scan to see where else it is used or has it been used.
11:08:15 <djahandarie> That is 90% of what I do when reading math or programs.
11:08:23 <dankna> ? ? ?? -- some possibilities
11:08:24 <pozic> monochrom: I saw that at age 12. 
11:08:25 <Eduard_Munteanu> I think I've seen it in school at 17, or so :/
11:08:33 <dankna> ? is kinda elegant-looking
11:08:42 <weirdo> pozic, for me it's pointless, like some useless middle ground. neither popular enough to find work, nor as good as haskell or lisp
11:08:48 <jmcarthur> djahandarie: ah, then this must just be a difference in how we read. i don't have much trouble visually searching for symbols i have on just encountered
11:08:54 <ion> dankna: Still just ?s.
11:08:56 <jmcarthur> *have only just
11:08:57 <dankna> oh well
11:09:01 <ksf> dankna, you're giving me ecoding errors.
11:09:01 <scree> we are talking about ? as in its normal use to indicate a question, right?
11:09:03 <dankna> ion: I'm sending UTF-8
11:09:07 <dankna> I'll stop then
11:09:11 <ksf> no you ain't.
11:09:17 <ion> no you ain't.
11:09:23 * scree understands
11:09:31 <pozic> I have seen a presentation once by someone who didn't know what his Greek letters were. EPIC FAIL.
11:09:33 <dankna> yes, I am, I haven't reconfigured this browser in years
11:09:35 <luite> hmm, pretty sure I saw that letter in greek class in high school :p
11:09:36 <Eduard_Munteanu> By that heuristic, \Chi or \Aleph should be more obscure.
11:09:38 <ksf> switch your client to IRC (Latin/Unicode hybrid)
11:09:38 <djahandarie> I wouldn't say that I would be against a greek letter here or there to make it stick out from the other letters, but when some papers start using them heavily it just makes me get very frustrated
11:09:40 <monochrom> look in http://tunes.org/~nef/logs/haskell/ to see what you really sent.
11:09:44 <confound> dankna: no, you aren't, or it would be displaying properly for us
11:09:44 <ksf> that's what freenode uses.
11:09:53 <confound> ☃
11:09:55 <jmcarthur> djahandarie: i can agree with that. there's a point where there's no point
11:09:55 <dankna> I have no intention of using a Latin/Unicode hybrid, because that's just a broken encoding :(
11:10:08 <dankna> also I don't think I have that option
11:10:19 <djahandarie> jmcarthur, and I fear that is what will happen if we embrace unicode for programming. Make _everything_ unicode!
11:10:27 <dankna> I'm running the most recent xchat for which a Mac port exists, it's about five years old :(
11:10:31 <monochrom> no, "Latin/Unicode hybrid" is evil. see my http://www.vex.net/~trebla/symbols/refute-anti-unicode.html
11:10:32 <djahandarie> Everything in Agda is unicode and it really bugs me.
11:10:33 <Eduard_Munteanu> That'd look like APL.
11:10:40 <scree> dankna: can you LaTeX encode the symbol you were saying?
11:10:45 <kmc> Haskell is *also* pretty imperative, if you write imperative Haskell code
11:10:58 <jmcarthur> djahandarie: i think that once unicode languages reach wider audiences they will be approached more practically
11:11:01 <kmc> this IRC channel exists to make you feel bad for doing so
11:11:02 <dankna> looking at the log.  no, I can't easily latex it, I don't know the symbols.  I guess it's not important enough.
11:11:10 <pozic> kmc: except the GC doesn't interact well with imperative features.
11:11:11 <Eduard_Munteanu> Heh.
11:11:12 <monochrom> In short, "Latin/Unicode hybrid" goofs at ö for example
11:11:21 <ksf> monochrom, nope.
11:11:36 <ksf> only if others don't understand the latin part.
11:11:52 <kmc> pozic, how so?
11:12:02 <pozic> kmc: call it experience. 
11:12:09 <kmc> can you give me an example?
11:12:11 <ksf> anyway, I'm not going to switch away from what freenode mandates just because you say so.
11:12:22 <dankna> okay - yeah I was sending question marks :( weird :(
11:12:32 <Eduard_Munteanu> Well, I don't think it's GC, it's inplaciness.
11:12:33 <monochrom> you are using "Latin/Unicode hybrid"? could you send ö so I can verify it?
11:12:59 <ksf>  
11:13:07 <ksf> that should've been a unicode one, though.
11:13:08 <monochrom> alright then it's fine.
11:13:15 <shamster_> once a ByteString has been bound, how does one read it into a [Double]?
11:13:22 <ksf> I just copied it from the output, and that's always utf8, it seems.
11:13:28 <jmcarthur> shamster_: how are the doubles separated?
11:13:59 <ksf> monochrom, the idea of the hybrid is to preserve latin-capabilities for console clients I think.
11:14:00 <shamster_> jmcarthur: I wrote a c program that just writes doubles to a binary file. No particular separator other than the sizeof(double)
11:14:04 <ksf> there's still a lot of those.
11:14:23 <jmcarthur> shamster_: oh it's binary? i thought you said it was text
11:14:40 <dankna> use the Storable CDouble instance
11:14:43 <shamster_> jmcarthur: it was, but then I wrote a program to convert a test file to binary - everyone agreed that reading in the binary would be fater
11:14:49 <shamster_> s/fat/fast/
11:14:50 <freedrull> monochrom: plan A gets parse error on "else", plan B compiles :3
11:14:51 <kmc> shamster_, http://hackage.haskell.org/package/data-binary-ieee754
11:14:59 <jmcarthur> shamster_: ah i didn't catch that
11:15:13 <jmcarthur> i do agree. it would ebe *much* faster with binary
11:15:15 <monochrom> the idea is fundamentally broken. it's damn hard to look at a a few incoming bytes and guess "is it iso-latin-1? is it utf-8?" they overlap too much.
11:15:18 <jmcarthur> *be
11:15:29 <monochrom> freedrull: I forgot "then" there.
11:15:47 <ksf> monochrom, not really.
11:16:10 <ksf> utf8 is designed to be easily detectable.
11:16:14 <c_wraith> Uh.  Why did GHC just complain to me that I had my context in the wrong order?
11:16:16 <dankna> also, iso-latin-1 is completely subsumed by Unicode
11:16:17 <freedrull> monochrom: i see
11:16:22 <ksf> if you want to fix the thing, switch to jabber.
11:16:33 <dankna> there is no reason to use it as an encoding for new material, ever
11:16:43 <pozic> This has already been discussed to death. 
11:16:46 <ksf> dankna, tell that most of the consoles out there.
11:16:50 <dankna> I do agree that Jabber is the right solution
11:16:53 <ksf> not x terminals, consoles.
11:17:08 <pozic> Just look in the archives, there really is nothing to be said on the topic anymore.
11:17:15 <Jafet> Then stop using those consoles!
11:17:19 <dankna> oh yes, it has certainly been discussed
11:17:22 <Eduard_Munteanu> I wish I had something to use Jabber for :/
11:17:25 <Jafet> @quote reason
11:17:26 <lambdabot> tuomov says: You may remove Ion and Riot (among my other projects) from the list of programs using Darcs (on the wiki). Reason: no version for the most viable *nix platform of the day, Cygwin.
11:17:34 <Jafet> @quote voluntarily
11:17:34 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
11:17:39 <ksf> oh, certainly. when my X won't start and I want help on irc, I'm going to start X to get help.
11:17:40 <pozic> I would not mind switching to Jabber for #haskell. 
11:17:46 <pozic> Just pick a date.
11:18:10 <shamster_> kmc: now I'm stuck wondering which type I should use - be/le?
11:18:22 <dankna> imo there needs to be better client software for Jabber multi-user chat before we can really contemplate switching
11:18:35 <monochrom> suppose you get the bytes 0xc2 0xaa and that is all (or other bytes are just ascii). is it iso-latin-1 "Âª"? is it utf-8 "ª"?
11:18:38 <djahandarie> There are jabber IRC gateways
11:18:48 <Eduard_Munteanu> Oh, wait so you're not reading text-encoded doubles, but binary ones.
11:18:58 <djahandarie> Though I imagine this kind of misses the point...
11:19:06 <Eduard_Munteanu> You might want the 'binary' package then.
11:19:23 <ksf>  is latin?
11:19:47 <monochrom> ª is U+00AA
11:19:48 <shamster_> Eduard_Munteanu: yes, I just got the link from kmc... IEEE754
11:19:57 <ksf> some funky french stuff, maybe.
11:20:09 <ksf> it'd be the latter, because the former doesn't appear in text.
11:20:14 <monochrom> ª is within the "latin-1 supplement" block anyway
11:20:25 <kmc> shamster_, are your floats big-endian or little-endian?
11:21:18 <monochrom> does "Latin/Unicode Hybrid" know what appears in text and what doesn't appear in text?
11:21:20 <shamster_> kmc: jeez, I've got no idea :)
11:21:39 <Eduard_Munteanu> shamster_: how did you get that file then?
11:22:12 <shamster_> Eduard_Munteanu: I performed an fscanf(...) followed by an fread(...) in a small C script I wrote
11:22:21 <shamster_> Eduard_Munteanu: writing out doubles
11:22:31 <ksf> monochrom, if in doubt, what ICU tells you it is is what it is.
11:22:32 <Eduard_Munteanu> shamster_: x86(-32/64) is little-endian
11:22:37 <monochrom> I am doubting the algorithm, not the small human you hide inside your computer
11:22:49 <shamster_> Eduard_Munteanu: there we go... it's little-endian
11:22:54 <Eduard_Munteanu> So that's what you have (unless you're not on something else).
11:23:05 <Eduard_Munteanu> *unless you're
11:23:38 <shamster_> With that said, I now have a binary file I'd like to read and end up treating like a [Double]
11:23:42 <Eduard_Munteanu> The problem is 'binary' expects big-endian stuff.
11:24:29 <ksf> "network byte order"
11:24:51 <fram> damned I think I fucked up my installation again : GHCi runtime linker: fatal error: I found a duplicate definition for symbol   gtk2hs_closure_new
11:25:01 <Eduard_Munteanu> I'm not sure what's the Haskell stuff for serializing without endianness conversion.
11:25:06 <shamster_> Eduard_Munteanu: well, let me see if I can get out from this hole and find a module that will work with little-endian, or write my c-code to write big-endian
11:25:39 <ksf> quick and dirty solution: look at Data.Bytestring.Unsafe, get a Ptr Double from it, then read.
11:26:16 <shamster_> ksf: I'll give it a shot...
11:26:25 <ksf> peek should always use machine order.
11:27:20 <Eduard_Munteanu> Just so you know what this is about. Say you have a number 0xAABB. In little endian, it's layed out 0xBB 0xAA (little / least significant "endian"/byte first).
11:27:41 <ksf> there's also middle endian.
11:28:00 <Eduard_Munteanu> Yeah, though that's for 4 bytes.
11:28:06 <ksf> 03/07/2011
11:28:07 <shamster_> Eduard_Munteanu: yeah, I covered that in a course some time back... but my knowledge was for MIPS ;) 
11:28:13 <Eduard_Munteanu> (I'm not sure how easy that extends to more than 4, I mean)
11:28:31 <Eduard_Munteanu> Ah, MIPS is bi-endian.
11:28:46 <Eduard_Munteanu> Which means you can switch back and forth between little and big.
11:28:52 <ksf> AABBCCDD would be DDCCBBAA little-endian.
11:29:12 <shamster_> And nothing is as it seems!
11:29:44 <Eduard_Munteanu> Middle endian is (some rather arbitary) 4-3-1-2, IIRC.
11:29:59 <ksf> Eduard_Munteanu, middle endian is what americans use for dates.
11:30:10 <shamster_> alright I'm going to fool around with these things for a bit and come back less hopelessly lost (and not as likely to jump straight back to C for getting this job done)
11:30:10 <Eduard_Munteanu> Beats me why they used that for hardware.
11:30:32 <Eduard_Munteanu> ksf: there's actually real hardware with such mixed/middle endianness.
11:30:37 <ksf> and note that numbers are actually written little-endian, at least when written in their original script (arabic)
11:30:44 <ksf> ...where right is the beginning.
11:30:58 <ksf> yep, but that's called mixed, not middle.
11:30:58 <Eduard_Munteanu> Yeah, arabic is right-to-left.
11:31:14 <Eduard_Munteanu> Ah.
11:32:43 <Eduard_Munteanu> Big-endian is generally more natural to read straight from hex, while little-endian is easier to implement in some cases. As for mixed stuff :/
11:33:48 <monochrom> permutation ciphers use middle endian :)
11:34:49 <Eduard_Munteanu> Yeah, and ROT13 is military-strength. :P
11:43:16 * hackagebot ascii 0.0.1.1 - Type-safe, bytestring-based ASCII values.  http://hackage.haskell.org/package/ascii-0.0.1.1 (MichaelSnoyman)
11:43:29 <kmc> i suspect middle-endian comes from extending a little-endian 16-bit architecture to 32-bits
11:43:37 <kmc> and deciding to do the latter in a big-endian way
11:43:45 <kmc> beats me why though
11:44:10 <Eduard_Munteanu> Hah.
11:45:33 <hpaste> edgimar pasted "kill processes w/Xmonad: compilation results"  http://hpaste.org/44597
11:51:15 <Philonous> @botsnack
11:51:15 <lambdabot> :)
11:52:57 <b52> where can i find a select for my Socket from NetworkSocket?
11:53:47 <kmc> we don't typically use select in GHC Haskell
11:53:54 <kmc> we fork off threads and do blocking IO
11:54:02 <b52> well, but i want a timeout ./
11:54:08 <kmc> the GHC runtime system will convert that into select (or epoll or kqueue) behind the scenes
11:54:16 <b52> how can i do it without select?
11:54:21 <kmc> System.Timeout
11:54:30 <ksf> select is slow.
11:54:46 <b52> thats not a problem in my acse
11:55:53 <shachaf> ksf: It is?
11:56:52 <kmc> GHC's IO manager is one of its coolest features, i think
11:57:36 <ezyang> == 
11:58:01 <c_wraith> shachaf: have you seen the benchmark numbers bos and tibbe were putting up, comparing their implementation to select?
11:58:28 <tibbe> c_wraith: also check out the Warp benchmarks that uses the I/O manager
11:58:32 <shachaf> c_wraith: No. Was it selecting on just one fd?
11:58:35 <kmc> especially in light of all the blognoise about how node.js async IO is the best thing ever
11:58:49 <kmc> it's as if we have a garbage collector and they're writing blog posts gushing about the beauty of malloc() / free()
11:58:50 <shachaf> kmc: Does it work for both sockets and disk I/O?
11:59:13 <kmc> shachaf, to my knowledge yes but maybe you should ask tibbe ;)
11:59:26 <shachaf> Oh, I guess it would, if it uses blocking I/O and threads.
11:59:34 <ksf> shachaf, why shouldn't it?
11:59:35 <kmc> no, it *implements* blocking IO and threads
11:59:41 <c_wraith> actually, one of tibbe's most compelling examples was selecting on a few thousand active sockets, and hundreds of thousands of inactive ones
11:59:46 <kmc> using nonblocking IO and select/epoll/kqueue
11:59:50 <shachaf> Oh.
11:59:56 <c_wraith> obviously, select can't even do that
11:59:57 <kmc> remember that Haskell-level threads in GHC aren't OS threads
12:00:17 <kmc> c_wraith, i'm disappointed you didn't use the word "webscale" in that sentence
12:00:24 <ksf> the new IO subsystem is a work of art, yes.
12:00:26 <kmc> example: "one of tibbe's most compelling WEBSCALE examples..."
12:00:31 <kmc> ;)
12:00:33 <ksf> it was, even before, but now it's even better.
12:00:39 <shachaf> kmc: Right, I thought you meant using a pool of threads doing blocking I/O.
12:01:19 <kmc> you'd still need one thread per socket
12:01:52 <kmc> most OSes will choke and die if you try to spawn 100,000 threads
12:01:54 <shachaf> Anyway, in Linux, you can't do non-blocking disk I/O with epoll the way you do it with sockets, as far as I know.
12:02:00 <kmc> aww :/
12:02:18 <kmc> i suppose you could take a hybrid approach
12:02:39 <kmc> epoll for network, pipes, etc., and a single AIO worker thread for disk
12:02:44 <shachaf> You have to the AIO system (io_submit etc., or POSIX AIO (though that's often implemented badly)).
12:03:21 <tibbe> shachaf: GHC I/O manager implements what most systems forces the programmer to do manually: a single thread for I/O using epoll and a worker pool of threads to schedule blocking calls (where epoll doesn't work) and CPU bound threads)
12:04:08 <shachaf> tibbe: Ah, so you use a pool of threads for disk I/O?
12:04:18 <tibbe> shachaf: one upside to that approach is that you don't have to rewrite every single library to work with the event loop. The libraries that block internally will use threads from the thread pool
12:04:31 <tibbe> shachaf: it should (but I should double check)
12:04:59 <tibbe> shachaf: disk I/O is tricky as the OS typically always says "yes" when you ask if a file backed file descriptor is ready for I/O
12:05:23 <kmc> you kind of want to get those requests into the system's IO scheduler as quickly as possible
12:05:42 <c_wraith> also, you can hook c libraries into the IO manager really nicely.
12:05:55 <shachaf> Hmm, Linux aio actually doesn't work unless you use O_DIRECT, does it?
12:06:10 * ksf wonders whether the new IO layer exports fionread, I had to ffi that on my own the last time I used the pre-ghc-included version
12:07:25 <ksf> though the benefits it gives you are dubious when the buffer is collected soon after, anyway.
12:12:46 <monochrom> System.Timeout is interesting
12:13:16 <c_wraith> There was just a big thread on both -cafe and -libraries about new implementations for it
12:13:36 <args0> can we live with functional languages?
12:13:55 <kmc> certainly not
12:15:13 <monochrom> functional languages have been around for 50 years. people seem to live just fine.
12:15:39 <monochrom> nuclear wars would be something we cannot quite live with.
12:15:51 <args0> can we live with functional languages ONLY?
12:15:57 <roconnor> Atlantas was the first to discover functional programming, and look what happend!
12:15:58 <tibbe> shachaf: dcoutts reminded me that the I/O manager doesn't get involved in disk I/O as it only calls epoll when a syscall returns EWOULDBLOCK
12:15:58 <kmc> fortunately the US nuclear arsenal is powered by Perl
12:15:59 <kmc> http://www.foo.be/docs/tpj/issues/vol2_1/tpj0201-0004.html
12:16:16 <tibbe> shachaf: we optimistically attempt the syscall and only add the fd to epoll in case it would block
12:16:29 <shachaf> tibbe: So disk I/O is still completely blocking?
12:16:44 <kmc> args0, can we live only with languages which aren't lacking first-class functions?
12:17:09 <Jafet> Can we live without trolls
12:17:30 <monochrom> I need food. I cannot live with functional languages ONLY (sic).
12:17:42 <monochrom> oh actually, I need oxygen too.
12:18:02 <args0> monochrom: thanks, that's what I was missing... O2
12:18:12 <ion> Cool, me too. I’ve been using oxygen pretty much always.
12:18:39 <tibbe> shachaf: yes, the OS will never return EWOULDBLOCK for disk I/O so one of the threads from the thread pool will be used
12:18:48 <tibbe> shachaf: won't hand remaining Haskell (green) threads though
12:19:47 <dankna> bwahha kmc, I read that entire article before I noticed its date of publication
12:19:55 <m3ga> @seen dons
12:19:55 <preflex>  dons was last seen on #ghc 3 hours, 31 minutes and 25 seconds ago, saying: ok. thanks Igloo
12:19:55 <lambdabot> Unknown command, try @list
12:19:58 <kmc> shhh don't spoil it dankna
12:20:09 <dankna> haha okay
12:20:14 <dankna> I loved the line "... it had been designed for exactly this purpose and that PERL itself stood for "Precision Entry and Reentry Launchings," a lie that would later be repeated over and over again at my court-martial."
12:20:16 <monochrom> oh hahaha
12:23:14 <Veinor> it's a great line
12:28:31 * hackagebot Sysmon 0.1.2 - Sybase 15 sysmon reports processor  http://hackage.haskell.org/package/Sysmon-0.1.2 (VitaliyRukavishnikov)
12:35:34 * hackagebot hakyll 3.0.1.2 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.1.2 (JasperVanDerJeugt)
12:43:48 <dpratt71> so I've been reading about Agda...
12:44:08 <djahandarie> :)
12:44:23 <dpratt71> ...and one of the most obvious differences from Haskell is the (apparent) lack of type inference, at least as applies to function declarations
12:44:48 <djahandarie> You don't get full type inference when you have dependent types
12:44:52 <djahandarie> It can infer some stuff.
12:44:53 <dpratt71> I understand this is because otherwise the type inference algorithm may be non-terminating
12:45:01 <Peaker> Can we live without non-functional programming languages? :)
12:45:08 <Eduard_Munteanu> Is it proven to be undecidable?
12:45:39 <djahandarie> Eduard_Munteanu, I don't know about that. HM breaks down after adding basically anything to it though and that is the main type inference algorithm that we have though
12:45:40 <Peaker> dpratt71, I am not sure but I think it is at least *partly* because Agda chose to have type-based name disambiguation
12:45:51 <Eduard_Munteanu> Anyway, writing type sigs is a good thing.
12:46:42 <djahandarie> dpratt71, there is also an #agda if you are interested in idling there
12:46:52 <dpratt71> quoting from a paper I'm reading "In Agda we cannot infer types in general, but we can always check whether a certain term has a certain type provided it is normal. The reason for this is that the type-checking algorithm in Agda uses normalisation (simpliﬁcation), and without the normality restriction it may not terminate.
12:47:35 <dpratt71> my question is: could a language (as implemented by a compiler) try to infer the type within a given number of steps...
12:47:37 <olsner> Eduard_Munteanu: I think it comes down to how powerful you make the dependent types... UndecidableInstances is already turing complete, as I understand it
12:47:55 <dpratt71> and failing that, require an explicit type signature?
12:48:10 <olsner> but dependent types with the right limitations should be decidable unless "dependent" implies more stuff than I think it does
12:48:14 <djahandarie> dpratt71, isn't that somewhat unpredictable?
12:48:31 <Eduard_Munteanu> I wonder if Agda has subtyping, i.e. if it's CoC.
12:48:36 <djahandarie> In Agda type checking a program can mean running a good portion of it
12:48:39 <kmc> with the requirement that all terms have a normal form, type checking of dependently typed languages is decidable
12:48:56 <dpratt71> djahandarie: perhaps; it just seems that the type would typically be decidable, except for some pathological cases
12:48:58 <kmc> but that's not enough for inference to be decidable
12:49:02 <djahandarie> Eduard_Munteanu, eh, CoC doesn't have subtypes
12:49:06 <dpratt71> 'course that's just a guess
12:49:26 <djahandarie> Eduard_Munteanu, and both Coq and Agda are built up on an extension of CoC called the calculus of inductive constructions
12:49:33 <Eduard_Munteanu> djahandarie: um, isn't CoC polymorphism + subtyping + dependent types, as far as the lambda cube goes?
12:49:53 <roconnor> edwardk: Why isn't ContT defined as newtype ContT o w a = ContT (w (a -> o) -> o) ?
12:50:02 <djahandarie> Eduard_Munteanu, it's polymorphism, type operators, and dependent types
12:50:05 <djahandarie> No subtypes.
12:50:06 <roconnor> edwardk: as a transformer from comonads to monads
12:50:18 <Peaker> kmc, type checking being decidable does not mean it is decidable in reasonable time, though?
12:50:20 <Eduard_Munteanu> Hrm, I misremember perhaps.
12:50:31 <Peaker> (could involve running something that is O(ackermann)?)
12:50:40 <roconnor> edwardk: and as a transformer from monads to comonads?
12:50:48 <djahandarie> Eduard_Munteanu, terms depending on types, types depending on types, types depending on terms.
12:50:52 <djahandarie> No subtypes involved :)
12:50:57 <Eduard_Munteanu> Ah, makes sense.
12:51:18 <kmc> Peaker, sure... your terms can do arbitrary computation before they reduce to a normal form
12:51:20 <roconnor> @type \a f -> extract f a
12:51:21 <lambdabot> forall source. (Extract source) => source -> (Int, Int) -> source
12:51:28 <roconnor> er
12:51:31 <kmc> though you can bound the time for checking a term that's *already* in normal form
12:51:33 <roconnor> @type extract
12:51:34 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
12:51:36 <djahandarie> I think there is some formal construction that works subtypes into this
12:51:37 <roconnor> ?
12:51:43 <djahandarie> But I don't remember what it's called.
12:51:52 <djahandarie> Probably just has some weird symbol instead of a name
12:51:53 <edwardk> roconnor: pulling it up. it made sense to me at the time
12:51:54 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
12:52:08 <roconnor> edwardk: pulling what up?
12:52:35 <edwardk> the source =)
12:52:43 <roconnor> the source of what?
12:52:52 <edwardk> http://hackage.haskell.org/packages/archive/adjunctions/0.9.0.1/doc/html/Control-Monad-Trans-Conts.html
12:52:55 <Eduard_Munteanu> Ok, so Agda already amounts to CoC.
12:52:57 <djahandarie> THE SOURCE
12:53:26 <rj300> hey
12:53:27 <edwardk> you asked me why something wasn't defined in a simpler manner, i hadn't looked at the code in a couple of weeks =)
12:53:51 <roconnor> edwardk: er
12:53:57 <roconnor> edwardk: I didn't see that code
12:54:06 <edwardk> i went with ContsT because that way it was a monad transformer
12:54:07 <roconnor> edwardk: I was just doodling about continutations on paper
12:54:10 <kmc> hi rj300
12:54:17 <edwardk> hah
12:54:19 <roconnor> edwardk: wondering why the mtl definition was so strange
12:54:45 <edwardk> the one you doodled was found by ddarius a while back, and is the ancestor to that code in adjunctions
12:55:06 <roconnor> type Conts r w = ContsT r w Identity  <-- this is what I would normally think of ContT as
12:55:11 <edwardk> http://hackage.haskell.org/packages/archive/adjunctions/0.9.0.1/doc/html/Control-Monad-Trans-Contravariant-Adjoint.html is the general construction
12:55:26 <b52> how can i get raw byte by its hex value?
12:55:29 <b52> \xFF ?
12:55:40 <kmc> you have a byte how?
12:55:43 <kmc> what type?
12:55:48 <b52> String
12:55:54 <roconnor> edwardk: oh neat
12:56:02 <kmc> wait, is this what you want?
12:56:04 <kmc> > 0xFF
12:56:05 <lambdabot>   255
12:56:05 <b52> somethin like "\xFF"
12:56:06 <kmc> or this?
12:56:08 <kmc> > "\xFF"
12:56:09 <lambdabot>   "\255"
12:56:11 <roconnor> edwardk: see, now I really think ContT in the mtl is just wrong.
12:56:12 <kmc> there you are
12:56:18 <kmc> b52, that's not for bytes though, it's for Unicode code points
12:56:19 <b52> second one
12:56:20 <edwardk> nah, its a monad transformer
12:56:24 <roconnor> pfft
12:56:27 <edwardk> just not the one you want =)
12:56:27 <b52> resulting in a one byte string with value 0xff
12:56:31 <roconnor> ConT is a functor transformer
12:56:36 <roconnor> *ContT
12:56:37 <kmc> > "\x262d"
12:56:37 <lambdabot>   "\9773"
12:56:43 <edwardk> it doesn't even care so much about that ;)
12:56:45 <kmc> the Haskell type for bytes is not Char but Word8
12:56:49 <roconnor> the input "monad" doesn't have anything to do with monads.
12:57:00 <edwardk> DiscontT does the same thing comonad-transformer side
12:57:18 <edwardk> it has a trivial lifting of actions in the underlying monad into it
12:57:40 <edwardk> its '
12:57:45 <edwardk> 'cheating' in a way
12:57:52 <edwardk> but its a perfectly good monad transformer
12:58:06 <roconnor> edwardk: can you have more instances for ContsT?  (Monad w) => Comonad (ContsT r w m) and the like?
12:58:16 <edwardk> lots of things only need a '>>=' and not return to transform them, we don't complain that they aren't monad transformers =)
12:58:33 <edwardk> roconnor: interestingly the dual construction doesn't seem to exist
12:58:41 <roconnor> whatz?
12:58:59 <edwardk> find me an adjunction from Hask -> Hask^op
12:59:05 <edwardk> not one from Hask^op -> Hask
12:59:13 <roconnor> oh crap
12:59:15 <edwardk> forgive me if i don't wait ;)
13:00:03 <edwardk> i did a back of the envelope 'proof' that convinced me i could probably get unsafePerformIO out of it
13:00:38 <roconnor> @djinn (((m a) -> o) -> o) -> a
13:00:38 <lambdabot> -- f cannot be realized.
13:00:48 <roconnor> er
13:00:49 <edwardk> since after all if you can sandwhich a monad in it, then extract from the resulting comonad, you're done for
13:00:57 <roconnor> @djinn ((m (a -> o)) -> o) -> a
13:00:57 <lambdabot> -- f cannot be realized.
13:01:18 <roconnor> that does look hard to realize
13:01:28 <edwardk> (->r) isn't an adjunction from Hask -> Hask^op, it is from Hask^op -> Hask
13:01:30 <Peaker> Does Djinn assume "m" is Monad-constrained?
13:01:49 <roconnor> no 
13:01:51 <roconnor> :)
13:01:56 <kmc> i don't think djinn knows anything about type classes
13:02:22 <edwardk> http://hackage.haskell.org/packages/archive/adjunctions/0.9.0.1/doc/html/Data-Functor-Contravariant-Adjunction.html#t:Adjunction unit and counit are of the form a -> g (f a) and a -> f (g a)  -- not g (f a) -> a  and f (g a) -> a
13:02:23 <Peaker> @djinn Monad m => m a -> (a -> m b) -> m b
13:02:24 <lambdabot> f = (>>=)
13:02:24 <mercury^> edwardk: what is the adjoint?
13:02:31 <Peaker> @djinn m a -> (a -> m b) -> m b
13:02:31 <lambdabot> -- f cannot be realized.
13:02:33 <edwardk> mercury of (->) r ?
13:02:35 <Peaker> seems that it does!
13:02:36 <mercury^> Yes.
13:02:40 <edwardk> mercury: (->) r ;)
13:02:43 <mercury^> No, (->r).
13:02:52 <mercury^> (->) r is (r->)
13:03:02 <edwardk> a -> ((a -> r) -> r)
13:03:04 <mercury^> The adjoint of that should be (r,)
13:03:06 <edwardk> mercury: yes
13:03:10 <roconnor> edwardk: so the dual transformer turns out to be again comonad w => monad (ContT o w)
13:03:32 <roconnor> edwardk: (->r) is the tetrahedron of adjuctions.
13:04:10 <edwardk> roconnor: just like how discont isn't dual to cont, but if you view cont as codensity/right kan extension of a constant functor, then you can take the density/left kan extension of the same thing and get discont
13:04:50 <mercury^> Err, I don't get it. Why is (->r) self-adjoint? It cannot even be, because it is not an endofunctor.
13:05:04 <edwardk> mercury: its a contravariant functor.
13:05:19 <edwardk> so one direction it takes you from hask to hask^op, in the other direction it goes from hask^op to hask
13:05:31 <edwardk> a -> ((a -> r) -> r) -- is readily realized
13:05:46 <edwardk> http://hackage.haskell.org/packages/archive/adjunctions/0.9.0.1/doc/html/Data-Functor-Contravariant-Adjunction.html#t:Adjunction
13:06:01 <mercury^> You claim that (a -> r) -> b is isomorphic to a -> b -> r.
13:06:48 <edwardk> i claim  (b -> (a -> r)) is ismorphic to  a -> (b -> r)
13:07:05 <edwardk> remember one of those arrows is in hask^op!
13:07:24 <edwardk> (a -> r) <- b ~ a -> (b -> r)
13:07:42 <mercury^> Ah, right. Thanks. :)
13:07:55 <roconnor> the claim is that a -> (b -> r) is isomorphic to (a -> r) <- b
13:07:59 <roconnor> oh
13:08:03 <roconnor> too late
13:08:54 <edwardk> roconnor: i used to have contravariant dual adjunctions in the adjunctions package but once i came to believe they didn't exist i removed them
13:09:18 <roconnor> edwardk: anyhow, so I claim your Conts is more useful than ContT from the MTL
13:09:21 <mercury^> So hom(-,x) is self-adjoint at least in any closed monoidal category.
13:09:28 <roconnor> edwardk: that being said, I have no use case for Conts
13:09:40 <edwardk> roconnor: i use ContT fairly regularly ;)
13:09:50 <roconnor> ... true
13:10:07 <roconnor> do you use it to get callCC or just to make things faster?
13:10:16 <edwardk> (a -> IO ()) -> IO () -- is a pretty good way to enable you to queue up work at the end of the current continuation
13:10:55 <edwardk> i use it mostly to bolt things into my current "todo" list for reactor.
13:10:57 <ddarius> mercury^: Symmetric closed monoidal category.
13:11:12 <mercury^> ddarius: aren't all closed monoidal categories symmetric?
13:11:28 <ddarius> No.
13:11:29 * roconnor wonders what Conts r Store yeilds.
13:11:29 <mercury^> Hmm, guess not.
13:12:15 <mercury^> ddarius: do you have a good example at hand of one that is not?
13:12:40 <edwardk> defining ghc prims makes my head hurt
13:12:43 <ddarius> mercury^: Presumably any models of ordered linear logic.
13:12:56 <roconnor> Conts r (Store b) = (b -> a -> o) -> b -> o
13:13:00 <ddarius> mercury^: But really, I don't see anything in monoidal closure to imply symmetry.
13:13:10 <kmc> edwardk, what are you defining now?
13:13:22 <ddarius> edwardk: Just farm it off to copumpkin.
13:13:23 <edwardk> kmc: better mpfr bindings that don't need integer-simple
13:13:23 <Cin> Does anyone have an example usage of Graphics.PDF? I appear to be doing everything correct as far as the type system goes, but I end up with a blank page.
13:13:24 <mercury^> ddarius: nah, I just thought it was part of the definition. I am sure you can construct counter examples.
13:13:31 <edwardk> ddarius: we worked on it for hours on friday
13:13:31 <kmc> oooh nice edwardk
13:13:39 <kmc> is this for your interval stuff?
13:13:44 <ddarius> edwardk: Yeah, he mentioned it.
13:13:56 <ddarius> mercury^: Well, oftentimes "symmetric" is implied by the terminology.
13:13:59 <edwardk> kmc: yeah, it was originally built on hmpfr, but that was flat busted
13:14:40 <edwardk> kmc: i want to start playing with chebyshev polynomial approximation and taylor models, and for that i need good arbitrary precision arbitrarily-rounded floating point arithmetic
13:14:57 <roconnor> @unmtl StateT b (Cont o) a
13:14:57 <lambdabot> b -> (a -> b -> o) -> o
13:15:18 <edwardk> roconnor: clearly what you need is a version with an extra quantifier in there to cover the o./
13:15:19 <roconnor> so Conts o (Store b) a ~ StateT b (Cont o) a
13:15:29 <roconnor> I guess that isn't surprising
13:15:52 <edwardk> roconnor: a 'codensity transformer' which sandwiches the comonad in the middle
13:16:02 <edwardk> or some such
13:16:17 <roconnor> what would quantifying o do?
13:16:25 <edwardk> then you just get a cps'd store.
13:16:45 <roconnor> a fast store :D
13:16:48 <edwardk> it removes the 'r' from the type signature
13:17:07 <edwardk> a possibly-fast store.
13:17:11 <Eduard_Munteanu> I don't remember, density/codensity are free monads/comonads, right?
13:17:31 <edwardk> that quantified transformer is something i kicked around, but didn't have a good place to drop it in the namespace hierarchy =)
13:17:59 <edwardk> Eduard_Munteanu: nah
13:18:32 <dixie> hmm, is there findM like function? like find but predicate is "a -> m Bool" ? nothing at hoogle
13:18:46 <dixie> @hoogle [a] -> (a -> m Bool) -> Maybe a
13:18:46 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
13:18:47 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
13:18:47 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
13:18:47 <edwardk> data Free f a = Return a | Free (f (Free f a); newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r) -- both are unrelated monads
13:19:00 <roconnor> edwardk: er, but Conts r (Store b) appears to be a monad rather than a comonad.
13:19:05 <roconnor> edwardk: that is hardly isomorphic
13:19:07 <edwardk> yes
13:19:40 <edwardk> you got state
13:19:48 <roconnor> pfft state
13:19:52 <edwardk> the common cps'd state rep
13:19:53 <roconnor> I can't extract from that
13:19:58 <Eduard_Munteanu> Ah, I meant 'free' in a liberal sense.
13:20:16 <edwardk> in the very liberal sense, yes, you get a monad 'for free' =)
13:20:19 <Eduard_Munteanu> I should look up your 'free' too.
13:20:50 <dixie> :type liftM . find
13:21:08 <ddarius> edwardk: What do you need interval arithmetic for anyway?  Also, have you relooked at affine arithmetic?
13:21:23 <mercury^> Codensity f = Ran_f f, right?
13:21:33 <co_dh_> edwardk: do you have any paper on the category lib in haskell? 
13:21:33 <edwardk> ddarius: its a stepping stone to taylor models.
13:21:36 <edwardk> mercury^: yep
13:21:41 <edwardk> co_dh_: nope
13:21:43 <ddarius> edwardk: For?
13:21:50 <edwardk> ddarius: fun and profit =)
13:22:14 <edwardk> ddarius: playing with portfolio valuations mostly
13:22:24 <ddarius> I figured it was something like that.
13:22:35 <ddarius> 'gonna come out of this as a quant?
13:22:35 <Philonous> edwardk: You seem to have kicked IxContT from categories, will you bring it back in another package?
13:22:58 <edwardk> Philonous: i have started an indexed comonads/monads package, but not released it
13:23:21 <edwardk> mainly because there are some icky api decisions to be made because the index causes some things that collapse under the non-indexed version to become separate operations
13:23:22 <mercury^> Does f need to be a monad for Codensity f to be one?
13:23:30 <Philonous> edwardk: It's not yet on github, is it?
13:23:48 <edwardk> e.g. apply for applicative is the same for comonads and monads in the non-indexed case but in the case of an indexed comonad you need apply to be different
13:24:03 <Philonous> Ah, I see
13:24:05 <Saizan> mercury^: no, f doesn't have to be anything
13:24:49 <edwardk> mercury^: it doesn't even have to be a functor.
13:25:03 <edwardk> just have kind * -> *
13:25:17 <edwardk> Philonous: i hpasted it at some point
13:25:21 <mercury^> Alright. But outside of Hask, the same construction makes a monad out of any functor?
13:25:49 <augur> heyo
13:25:55 <mercury^> (Does this also work for enriched and homotopy Kan extensions?)
13:26:06 <edwardk> mercury^: yes, dubuc called it 'the monad generated by a functor' back around 74 or so
13:26:25 <edwardk> dunno, i suck at category theory
13:26:27 <edwardk> =)
13:26:34 <Eduard_Munteanu> LOL
13:26:45 <b52> http://hpaste.org/44603/steam_master_server_query anyone an idea?
13:27:00 <hpaste> b52 pasted "steam master server query"  http://hpaste.org/44603
13:27:04 <Eduard_Munteanu> edwardk just likes the -extras :P
13:27:11 <edwardk> Eduard_Munteanu: in many ways i do, i know how to stitch together commutative diagrams and translate theory into code
13:27:55 * hackagebot sqlite 0.5.2 - Haskell binding to sqlite3  http://hackage.haskell.org/package/sqlite-0.5.2 (AdamWick)
13:28:06 <monochrom> b52: return (if ... then ... else ...)  layout doesn't do this for you.
13:28:26 <monochrom> layout only adds {;} for you, not ()
13:28:51 <monochrom> also use /= for not-equal
13:28:52 <augur> byorgey: the thing is, i can figure one way of doing species with sharing of values, right
13:29:04 <augur> byorgey: not a way of defining them mathematically but of implementing them
13:29:15 <ddarius> Here's a pro-tip.  Instead of talking about the category of families of sets (or other things), just talk about [D-,=] : Set x Cat -> Cat where D is the discrete category functor and [C,D] is the category of functors between C and D.
13:30:14 <augur> where basically each item comes equipped with a hash of slots that it has, some of which might be named (unnamed just sort of means novelly named), and combining items means combining slot hashes
13:30:25 <mercury^> edwardk: the unit of the adjunction gives us a natural transformation f => f (Codensity f). Why can we cancel the f to get the unit of the monad?
13:30:27 <b52> monochrom: thanks
13:30:51 <augur> so that you might have m slots in X, n slots in Y, but in X*Y you have m+n-k slots, for k shared slots
13:31:15 <ddarius> mercury^: f would have to be monomorphic for you to talk about "cancelling" it.
13:31:19 <dixie> @hoogle [a] -> (a -> m Bool) -> m (Maybe a)
13:31:19 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
13:31:19 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
13:31:19 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
13:32:21 <b52> how can i translate a domain to an ip adress using Network ?
13:32:23 <dixie> haskellers, is there any such a "monadic" find function ? what I'm doing wrong ? :)
13:33:42 <dixie> b52: getHostByName
13:33:48 <dixie> http://hackage.haskell.org/packages/archive/network/2.3.0.2/doc/html/Network-BSD.html
13:33:52 <monochrom> not Network. Network.BSD.getHostByName
13:34:09 <edwardk> mercury: which adjunction, the one for the underlying monad?
13:34:44 <koninkje> Does anyone know how to mix Cabal-style MIN_VERSION_foo(1,2,3) macros with hsc2hs?
13:35:01 <edwardk> i don't lean on that for the definition of the monad for codensity. its just point x = Codensity (\k -> k x) -- which is the same as the unit/counit witness for the adjunction for (->r)
13:39:27 <mercury^> edwardk: did you respond? I got disconnected.
13:40:26 <mercury^> ddarius: should that not rather be Hom(=, D-) : Cat^{op} × Set → Cat?
13:40:51 <thierry`> hi, I'm looking for a simple way to create string perl-style such as "bob" X 3 would give "bobbobbob"
13:41:18 <kmc> > concat $ replicate 3 "bob"
13:41:18 <lambdabot>   "bobbobbob"
13:41:33 <hpc> or join
13:41:48 <thierry`> kmc : wow thanks, I saw replicate on hoogle but couldn't see what to do with it :)
13:41:51 <tromp__> > "
13:41:52 <lambdabot>   <no location info>:
13:41:52 <lambdabot>      lexical error in string/character literal at end o...
13:41:59 <kmc> the main thing is that it returns a list of whatever you put in
13:42:01 <tromp__> > "123" >> "bob"
13:42:02 <ion> @hoogle Integral n => n -> [a] -> [a]
13:42:02 <lambdabot>   "bobbobbob"
13:42:02 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
13:42:02 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
13:42:05 <kmc> so you can use "concat" to smoosh them all together
13:42:21 <kmc> request to rename "concat" to "smoosh" for Haskell 2012
13:42:32 <hpc> kmc: request seconded :D
13:42:49 <hpc> kmc: or better, rename join to smoosh
13:42:49 <tromp__> > [1..5] >> "bob"
13:42:50 <lambdabot>   "bobbobbobbobbob"
13:43:06 <hpc> :t \n -> [1..n] >> "bob"
13:43:06 <mercury^> tromp__: nice.
13:43:06 <lambdabot> forall t. (Num t, Enum t) => t -> [Char]
13:43:53 <ion> Request to rename >>= as (☞ﾟヮﾟ)☞ in Haskell
13:45:06 <hpc> ion: の
13:45:16 <hpc> (japanese character "no" :D)
13:45:49 <ksf> ⋋ or ⋌ ?
13:46:08 <ksf> ⋟
13:46:41 <ion> »͇
13:46:51 <ksf> ➟
13:47:05 <ksf> ➨ for >>
13:47:20 <ksf> or ➾
13:47:29 <dankna> yeah, those are possibilities I gave before
13:47:41 <dankna> or tried to but it didn't work
13:48:11 <roelvandijk> I defined >> as ≫ in base-unicode-symbols, but I never use it myself
13:48:27 <roelvandijk> The ≫ character that is
13:48:36 <fcr> there's also: »
13:49:30 <ksf> >>= is actually a very nice symbol.
13:49:39 <ksf> we should just try to get a ligature for that.
13:49:49 <hpc> this font is so small all those show up as pixel noise
13:49:58 <kmc> nooooooo don't take my «»
13:50:14 <ion> let (＞＞＝) = (>>=) in "foo" ＞＞＝ return
13:50:18 <ion> > let (＞＞＝) = (>>=) in "foo" ＞＞＝ return
13:50:19 <lambdabot>   "foo"
13:50:29 <parcs> is there a unicode variation of >>> ?
13:50:44 <roelvandijk> parcs: I believe (or fear) that there is
13:50:44 * hpc would be interested in seeing a spaceship operator for haskell
13:50:59 <roelvandijk> parcs: ⋙
13:51:01 <kmc> @let (<=>) = compare in 2 <=> 3
13:51:01 <lambdabot>   Parse error: in
13:51:02 <Axman6> _=o=_
13:51:05 <kmc> > let (<=>) = compare in 2 <=> 3
13:51:06 <lambdabot>   LT
13:51:12 <kmc> > let (<=>) = compare
13:51:13 <lambdabot>   not an expression: `let (<=>) = compare'
13:51:17 <olsner> hpc: I would like to operate a space ship in haskell!
13:51:18 <kmc> @let (<=>) = compare
13:51:19 <hpc> x <=> y = \l eq g -> case compare x y of LT -> l; EQ -> eq; _ -> g
13:51:19 <lambdabot>  Defined.
13:51:31 <roelvandijk> ⋙ is also defined in base-unicode-symbols, as an alternative to the arrow (>>>)
13:51:56 <hpc> mine is more in line with the definition of (??)
13:52:33 <monochrom> why are there so many question marks?
13:52:45 <roelvandijk> Because your font is not dejavu sans mono?
13:53:04 <monochrom> no, see http://tunes.org/~nef/logs/haskell/ for what hpc really sent.
13:53:05 <ion> Because your font renderer doesn’t use fallbacks?
13:53:14 <hpc> monochrom: mine was actually question marks, just now
13:53:20 <monochrom> oh haha
13:53:56 <hpc> "definition of (TWO QUESTION MARKS RIGHT HERE)" :P
13:54:18 <roelvandijk> When I set the encoding of the IRC log to UTF-8 everything looks fine
13:54:32 * hpc is using Droid and sees most of the glyphs fine
13:54:41 <hpc> except for the (>>>) one
13:54:47 <ksf> I'm not sure anybody has done that yet, but translating >>= to look nice in lhs2tex is quite trivial (supposed you have a thing to translate it to)
13:54:50 <ion> ➳
13:57:44 <ksf> oooh, there's ⩵ for equality test.
14:00:02 <b52> i got a char and would like to represent its byte value as string
14:00:57 <ksf> http://hackage.haskell.org/package/encoding
14:01:02 <b52> e.g. "\x9" -> "9"
14:01:09 <Eduard_Munteanu> pumpkin, Cale: ping, look on ##categorytheory a bit
14:01:25 <ion> show . ord
14:02:25 <Axman6> b52: "foo" is a string by the way. if you're talking about single Chars, you should use 'x'
14:02:35 <Axman6> or in this case, '\x9'
14:02:36 <b52> ahyour right, sorry
14:02:48 <Axman6> > show . ord $ '\x9'
14:02:49 <lambdabot>   "9"
14:04:44 <weirdo> what garbage collector does GHC use? is it OK with consing lots of garbage?
14:05:07 <hpc> "consing garbage"?
14:05:27 <weirdo> allocating
14:05:57 <monochrom> why do you knowingly allocate garbage?
14:06:37 <ddarius> monochrom: You need to create jobs, man.
14:06:42 <monochrom> haha
14:06:59 <weirdo> monochrom, i was thinking whether to be purely-functional or not
14:07:18 <weirdo> but i suppose i *could* just sprinkle side-effects here and there
14:07:25 <kmc> you can't really
14:07:34 <kmc> and yes, the GC is designed for lots of small short-lived objects
14:07:40 <weirdo> generational?
14:07:42 <kmc> yes
14:07:43 <kmc> "allocation" is just a pointer increment
14:07:46 <weirdo> is it parallel?
14:07:53 <kmc> http://hackage.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
14:07:57 <kmc> yes
14:07:59 <ddarius> weirdo: It is parallel but not concurrency/incremental.
14:08:11 <kmc> GC runs in parallel on all CPUs, but can't run in parallel with non-GC tasks
14:08:20 <monochrom> purely-functional does not knowingly allocate garbage.
14:08:26 <kmc> (this assumes you're using the threaded RTS and have activated a capability for each CPU)
14:08:35 <Eduard_Munteanu> Ah, so it's stop-the-world.
14:08:38 <kmc> yes
14:08:43 <kmc> there are plans to fix this
14:08:51 <ion> @faq Can Haskell knowingly allocate garbage?
14:08:51 <lambdabot> The answer is: Yes! Haskell can do that.
14:08:52 <kmc> something like a per-CPU generation-0 heap
14:09:37 <ddarius> There was a GHC branch with an incremental GC, but it was too slow and difficult to fold back into the mainline so it just whithered away.
14:10:25 * monochrom heard about leveled GC recently, seems interesting.
14:11:04 <weirdo> does the GC run in constant space?
14:11:25 <weirdo> i.e. can it recover from out-of-memory errors in all cases (unless the OS kills it)?
14:11:32 <Eduard_Munteanu> I wonder if explicit GC calling is implemented, that should be an interesting middle-way.
14:11:41 <Eduard_Munteanu> (explicit-only)
14:11:46 <ion> simpleHTTP (getRequest "http://www.timecube.com/") >>= getResponseBody  -- What did you say again about purely-functional languages not knowingly allocating garbage?
14:12:16 <hpc> ion: haha, well played
14:12:17 <monochrom> purely-functional does not knowingly allocate garbage. again.
14:13:59 <monochrom> if you are playing on the fact that timecube is garbage, you don't know it's garbage a priori.
14:14:28 <ddarius> One would also need to show that Haskell allocates in that case.
14:14:33 <Adamant> fifth cube squared disagrees
14:14:50 <Adamant> all time is weapon of educated stupid
14:15:40 <Eduard_Munteanu> Wow, excellent layout and typesetting.
14:16:45 <hpc> Eduard_Munteanu: it puts latex to shame
14:17:23 <monochrom> someone should encourage and help its author switch to flash altogether
14:17:36 <roelvandijk> @faq Can Haskell make sense of the Time Cube?
14:17:36 <lambdabot> The answer is: Yes! Haskell can do that.
14:17:45 <monochrom> maybe I should. public service.
14:17:49 <Eduard_Munteanu> AMS should adopt that.
14:18:44 <Eduard_Munteanu> "Cubicism, Not group theory. "
14:19:00 * monochrom adds to his CV, under section "Service": I persuaded timecube.com to switch to pure Flash so all of us can just use flashblock and be spared of it.
14:19:24 <bubaflub> hello #haskell - a coworker and i are learning haskell and are interested in the Google Summer of Code.  is there anyone we should be talking to about proposals or other things?
14:19:42 <Eduard_Munteanu> Ok, it's too random.
14:20:02 <edwardk> mercury^: yeah i did, but then i went afk
14:20:08 <djahandarie> bubaflub, edwardk is a good person to talk to. However, if you are just learning there may not be much in your grasp
14:20:08 <monochrom> Google Summer of Code is not quite for non-students. end of what I know.
14:20:13 <djahandarie> And yeah
14:20:15 <djahandarie> Students only
14:20:21 <djahandarie> (But you may be student workers)
14:20:35 <bubaflub> djahandarie: i'm a grad student and my coworker is working on his bachelors
14:20:43 <bubaflub> (we both work full-time as well)
14:20:46 <monochrom> nice
14:20:53 <bubaflub> he's got a better grasp on it than i did
14:20:55 <Eduard_Munteanu> Oh, edwardk was working on GSoC? Hm.
14:20:59 <bubaflub> *do
14:21:01 <djahandarie> Ouch, grad student working a full-time job?
14:21:10 <djahandarie> And you want to do GSoC?!?!
14:21:13 <bubaflub> djahandarie: yeah, gotta pay those bills.
14:21:14 <edwardk> babaflub: the key consideration for a viable GSoC project would be finding something that is both within your grasp and beneficial to the community
14:21:29 <Eduard_Munteanu> Note GSoC is already kinda full-time.
14:21:32 <bubaflub> edwardk: i was looking at the trac and reddit
14:21:38 <mercury^> edwardk: what was the answer then?
14:21:39 <edwardk> another consideration will likely be the amount of time that you'd have to devote to the task for the summer
14:21:41 <tomh> hey, anyone here knows what alexMonadScan exactly does?
14:21:41 <djahandarie> Yeah, those are the places to look.
14:21:46 <djahandarie> Gwern also wrote a good article about it.
14:21:51 <monochrom> probably one can pull off both a GSoC and a MSR internship XD
14:21:54 <bubaflub> edwardk: i think i could swing some of the proposals, like the MIME library
14:21:58 <bubaflub> (http://hackage.haskell.org/trac/summer-of-code/ticket/1126)
14:22:05 <bubaflub> but i don't know the status of any of that
14:22:09 <bubaflub> i.e. if that info is out of date
14:22:09 <Eduard_Munteanu> monochrom: Microsoft Research?
14:22:13 <monochrom> yeah!
14:22:27 <djahandarie> bubaflub, here is something nice to read: http://www.gwern.net/Haskell%20Summer%20of%20Code.html
14:22:29 <Eduard_Munteanu> Hm, I'll bring that up in a bit, on -blah
14:22:52 <djahandarie> An analysis of previous projects and what succeeded.
14:22:53 <edwardk> mercury^: it was in the form of a question: as to whether you meant the adjunction that gives rise to the monad on codensity or the underlying monad. i don't lean on that for the definition of the underlying monad for codensity. its just point x = Codensity (\k -> k x) -- which is the same as the unit/counit witness for the adjunction for (->r)
14:23:10 <Studley> Hello
14:23:18 <djahandarie> Studley, greetings.
14:23:51 <edwardk> bubaflub: ah. the trac is where you found it, though we haven't updated it yet for this year's gsoc. usually most projects are raised through reddit.com/r/haskell_proposals, then we encode those that find support and mentors
14:23:55 <edwardk> into the trac
14:24:30 <bubaflub> edwardk: ok, i'll look more at the reddit
14:24:56 <Eduard_Munteanu> I've been 3 times already in GSoC, but this year I can't participate, really. It's my final year and I'm already full-time with school (which I don't attend much) and my diploma project.
14:25:10 <Eduard_Munteanu> So I guess having a full-time job is going to be tough.
14:25:28 <mercury^> edwardk: I meant that in general when you have a functor f and consider Ran_f f = Codensity f, you get a natural transformation from f to f (Codensity f). But to show that Codensity f is a monad, we need one from id to Codensity f. That is why I was wondering how one can cancel the f.
14:25:31 <edwardk> bubaflub: that particular proposal appears to have been largely rejected. i think tibbe went through and updated a few on the trac, but the trac has been picked pretty clean =)
14:25:45 <Eduard_Munteanu> (because you should expect GSoC to be full-time too)
14:25:48 <bubaflub> Eduard_Munteanu: yes.  i did it the last two years with Perl and Parrot.  it was a bit time consuming / tough to balance both
14:25:52 <Studley> would one of you happen to know how I would use a value returned by getStdRandom as an Int?
14:26:10 <Eduard_Munteanu> :t getStdRandom
14:26:10 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
14:26:22 <bubaflub> edwardk: i'm looking at #5 - A simple, sane, comprehensive Date/Time API - that looks like i could handle that with a mentor
14:26:34 <Studley> It keeps giving me errors saying 'no instance for (Num (IO a))'
14:26:35 <bubaflub> + perl5/6 has a great DateTime API to steal/borrow tests from
14:26:58 <ion> > mkStdGen (-2^31)
14:26:59 <Eduard_Munteanu> Studley: do you know about monads and IO?
14:27:02 <lambdabot>   mueval-core: Time limit exceeded
14:27:10 <edwardk> mercury: that natural transformation exists, but we don't use it here. the lifting is just lift m = Codensity (>>= m)
14:27:17 <Studley> Eduard_Munteanu: Not exactly, but I'm willing to learn
14:27:35 <Eduard_Munteanu> Oh, so they published ideas/suggestions already, I'll have a look sometime, I'm curious.
14:27:52 <monochrom> main = do { x <- getStdRandom next; print x }
14:28:35 <Eduard_Munteanu> Do like monochrom says, and have a look at LYAH.
14:28:37 <Eduard_Munteanu> @where lyah
14:28:37 <lambdabot> http://www.learnyouahaskell.com/
14:28:48 <mercury^> edwardk: do you know how to construct it though (in general, not in Hask)? Because I seem to be missing an idea atm.
14:28:49 <Studley> Yeah, I've been looking through that
14:28:52 <monochrom> x is an Int in that scope.
14:29:04 <Studley> I've found it's usually better to ask a real person, though
14:29:25 <Studley> Especially since I don't exactly have a very solid programming background
14:29:31 <edwardk> bubaflub: that one is a bit controversial, largely because there are two entrenched date/time apis: old-time and time which are currently in circulation. you may want to skim the first few entries in http://hackage.haskell.org/trac/summer-of-code/report/1 which are rated as "priority good"
14:29:50 <Eduard_Munteanu> Studley: that's ok, from a certain point of view, you've got less unlearning to do :)
14:29:54 <bubaflub> edwardk: ok.  sounds good.  thanks for all your help.
14:30:11 <edwardk> mercury^: i'd probably need more mental bandwidth than i can devote to it at the moment
14:30:18 <monochrom> asking a person is optimal when answering takes less than 2 minutes.
14:30:29 <Studley> Heh
14:30:59 <bubaflub> edwardk: looks like a lot of guts, compilers, and profiling.  i'll consider it but it's probably not the best place for me to go.
14:31:05 <weirdo> too bad foldl' has to exist
14:31:07 <Peaker> Why is a function like getStdRandom exposed with such a name? It doesn't seem like a very useful way to organize the API
14:31:12 <weirdo> i thought it was all so sweet
14:31:26 <Peaker> weirdo, Yeah, realizing the laziness isn't a solved problem was sad for me too :)
14:31:43 <Peaker> (Also that parallelization wasn't quite completely automatic..)
14:31:52 <Studley> Okay, that seems to work
14:31:54 <Studley> Thanks!
14:32:06 <edwardk> bubaflub: you may have better luck mining the haskell_proposals on reddit
14:32:20 <edwardk> bubaflub: the ones on the trac that are left are fairly hardcore
14:32:53 <edwardk> bubaflub: but do keep in mind that a summer of code project is basically a full time job for the summer
14:34:05 <b52> can i translate a domain to more than one ip address?
14:34:27 <Eduard_Munteanu> b52: do you know about DNS?
14:34:31 <b52> yep
14:34:54 <monochrom> Network.BSD.getHostByName already gives you multiple ip addresses if there are really that many.
14:34:58 <Eduard_Munteanu> Well queries can yield different answers by rotation.
14:35:10 <Eduard_Munteanu> I.e., a given domain name may have multiple A records.
14:35:15 <Peaker> weirdo, some call into question the whole lazy-by-default thing.  It does require sometimes having a separate implementation of stuff for the lazy/strict cases, but that is true in any language. In Haskell, at least, there's a *lot* of code that does not need to be duplicated for the strict/lazy case
14:35:28 <weirdo> but really, does foldl' do something bad so that i might not want to use it in some case?
14:35:41 <bubaflub> edwardk: yeah.  i'm looking at some of these - some are doable but i'm still thinking about it.  my last two GSoC were related to Perl.
14:35:44 <Peaker> weirdo, It consumes the entire input, strictly, which may do more computations than you want
14:35:57 <Peaker> weirdo, or do you mean in relation to "foldl" specifically?
14:36:26 <weirdo> Peaker, i mean the "seq" version
14:36:40 <Eduard_Munteanu> bubaflub: to be honest, you probably shouldn't choose a GSoC project for a language you're just learning.
14:36:49 <Eduard_Munteanu> (if that's the case)
14:36:50 <Peaker> weirdo, ah. I don't think there's any reason to ever prefer foldl to foldl'
14:36:56 <bubaflub> Eduard_Munteanu: agreed.  just scoping out the landscape.
14:37:03 <Peaker> but I'm not sure
14:37:04 <weirdo> but itself is only evaluated when it's needed, right?
14:37:05 <monochrom> try (getHostByName "ca.pool.ntp.org") some day. I get 3 ip addresses.
14:37:08 <weirdo> what about foldr?
14:37:19 <weirdo> in lisp i used REDUCE which is, i believe, foldl
14:37:22 <weirdo> and it was efficient
14:37:29 <weirdo> i guess foldl' matches its semantics
14:37:32 <Peaker> weirdo, REDUCE is like foldl'
14:37:42 <weirdo> yeah, the laziness bit :)
14:37:48 <Peaker> weirdo, foldr is nice and AFAIK Lisp doesn't have it :)
14:38:01 <weirdo> it has :from-end t
14:38:04 <Eduard_Munteanu> Lithp hath uppercase thathemenths like thath?
14:38:07 <weirdo> which haskell doesn't have because of currying
14:38:19 <codolio> Peaker: There are cases where foldl is 'better', but they're pretty contrived usually.
14:38:33 <Peaker> weirdo, foldr is not just right-associative fold, it's also lazy. consider:  null = foldr (const . const $ False) True
14:38:43 <weirdo> Eduard_Munteanu, it's a standard convention to uppercase symbols when writing in english to distinguish them from regular words
14:38:43 <Peaker> @type foldr (const . const $ False) True
14:38:44 <lambdabot> forall b. [b] -> Bool
14:38:53 <monochrom> (getHostByName "www.google.com") gives 5 addresses
14:38:54 <Peaker> weirdo, despite using foldr, this runs in O(1) time on lists
14:38:56 <Eduard_Munteanu> Ah.
14:39:23 <Peaker> weirdo, because "const" does not evaluate its argument which represents the rest of the folding
14:39:25 <hpc> > foldr (const . const $ False) True []
14:39:27 <lambdabot>   True
14:39:30 <hpc> > foldr (const . const $ False) True [5]
14:39:32 <lambdabot>   False
14:39:36 <hpc> > foldr (const . const $ False) True [5..]
14:39:38 <lambdabot>   False
14:39:46 <hpc> :t const . const
14:39:47 <lambdabot> forall b a b1. a -> b -> b1 -> a
14:39:48 <Eduard_Munteanu> :t getHostByName
14:39:49 <lambdabot> Not in scope: `getHostByName'
14:40:07 <monochrom> @hoogle getHostByName
14:40:08 <lambdabot> Network.BSD getHostByName :: HostName -> IO HostEntry
14:40:15 <codolio> Peaker: Oh, I've got one.
14:40:35 <codolio> > let last = foldl (flip const) undefined in last (undefined : [1..10])
14:40:37 <lambdabot>   10
14:40:41 <codolio> > let last = foldl' (flip const) undefined in last (undefined : [1..10])
14:40:43 <lambdabot>   *Exception: Prelude.undefined
14:41:34 <hpc> codolio: have fun with stack overflows
14:41:44 <hpc> when you evaluate that last element
14:41:54 <Peaker> codolio, good one :)
14:42:08 <Peaker> @src foldl
14:42:08 <lambdabot> foldl f z []     = z
14:42:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:42:15 <codolio> > let last = foldl' (flip const) undefined in last [1..1000000]
14:42:17 <lambdabot>   1000000
14:42:19 <Peaker> hpc, why? foldl is tail-recursive?
14:42:21 <codolio> > let last = foldl' (flip const) undefined in last [1..10000000]
14:42:25 <lambdabot>   mueval-core: Time limit exceeded
14:42:45 <hpc> Peaker: what if that last element depended on all the previous elements?
14:42:53 <hpc> and the relation between subsequent elements was non-trivial
14:43:01 <codolio> Anyhow, it doesn't matter, because the resulting element is 'const e ...' which evaluates to e immediately.
14:43:05 <weirdo> @src foldr
14:43:05 <lambdabot> foldr f z []     = z
14:43:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:43:15 <weirdo> poor stack :(
14:43:26 <monochrom> "tail recursion" still does not guarantee either stack overflow or lack of stack overflow.
14:43:31 <ddarius> > foldr (:) [] $ repeat 1
14:43:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:43:51 <hpc> ddarius: ah, good ol' identity fold
14:44:12 <Peaker> hpc, that's a separate issue.. that wouldn't be the fault of the foldl here
14:44:12 * hpc found a neat metaphor for folds on wikipedia
14:44:21 <kniu_> @pl (\x y -> (x, f x y))
14:44:21 <lambdabot> liftM2 (.) (,) f
14:44:27 <hpc> the function param replaces the (:) of the final list
14:44:36 <kniu_> @pl (\x y -> (0, f x y))
14:44:37 <lambdabot> ((,) 0 .) . f
14:44:42 <hpc> and the second parameter replaces the [] at the very end
14:44:44 <weirdo> what's "@pl"? point free style?
14:44:51 <Eduard_Munteanu> Yes.
14:44:55 <Peaker> monochrom, A huge built-up thunk of tail-recursion should not stack overflow, should it? Or do you mean Haskell makes no such guarantees?
14:45:06 <hpc> weirdo: the 'l' in @pl is a joke
14:45:11 <Eduard_Munteanu> I think 'pl' is a pun on pointless :P
14:45:16 <hpc> weirdo: people like to call "pointfree" style "pointless"
14:45:26 <monochrom> see codolio's example, foldl and no stack overflow
14:45:27 <hpc> affectionately or criticizingly :P
14:45:35 <weirdo> @pl [a b a b]
14:45:35 <lambdabot> [a b a b]
14:45:38 <weirdo> :)
14:45:57 <codolio> Peaker: Tail-recursive functions like foldl can build up thunks that will overflow the stack in their accumulator. So they are no protection against stack overflows.
14:45:59 <Peaker> hpc, using foldl with a function that does not build a large non-tail-recursive thunk for the resulting value (and (flip const) doesn't) seems like it shouldn't ever result in a stack overflow itself. (If your list elements themselves are defined by huge non-tail-recursive thunks, that's a separate problem)
14:46:06 <weirdo> @pl (\a b -> [a b a b])
14:46:06 <lambdabot> flip flip [] . ((:) .) . join . join flip
14:46:10 <weirdo> oh my!
14:46:12 <Eduard_Munteanu> @pl fmap fmap . fmap
14:46:13 <lambdabot> fmap fmap . fmap
14:46:17 <Peaker> codolio, Of course, but then it's the "accumulator's fault"?
14:46:17 <ddarius> @src reverse
14:46:17 <lambdabot> reverse = foldl (flip (:)) []
14:46:28 <Peaker> codolio, the function you gave to build the accumulator up, that is
14:46:29 <codolio> But non-tail recursive functions may not overflow the stack either.
14:46:44 <monochrom> you can build a large thunk and then ditch it. no stack overflow. note: although this may count as knowingly allocating garbage, it is still not implied by purely functional programming.
14:46:45 <codolio> Because looking at function calls doesn't tell you anything about stack usage in a lazy language.
14:46:52 <ion> @pl \a b -> burger b a
14:46:52 <lambdabot> flip burger
14:46:56 <hpc> :D
14:47:05 <Peaker> monochrom, I was wondering about the inverse
14:47:16 <monochrom> the inverse?
14:47:18 <parcs> :t text
14:47:19 <lambdabot> String -> Doc
14:47:20 <weirdo> how do i know whether to use foldl' over foldr?
14:47:34 <hpc> > text "Look ma! No quotation marks!"
14:47:35 <lambdabot>   Look ma! No quotation marks!
14:47:53 <Peaker> monochrom, What *does* lead to a stack overflow when one uses tail recursion?
14:47:54 <ddarius> weirdo: The semantics of the problem and the strictness of the function you are going to pass in to whichever.
14:47:59 <Peaker> monochrom, not what doesn't
14:47:59 <parcs> > cat . repeat $ text "."
14:48:01 <hpc> > "Sad quotes :("
14:48:01 <lambdabot>   .*Exception: stack overflow
14:48:02 <lambdabot>   "Sad quotes :("
14:48:04 <Eduard_Munteanu> foldr is better for stuff consumed a bit at a time
14:48:10 <Eduard_Munteanu> Like lists.
14:48:19 <hpc> parcs: whoa
14:48:27 <weirdo> ddarius, how do i know the strictness?
14:48:31 <Eduard_Munteanu> (it makes "good producers")
14:48:39 <Peaker> codolio, surely some operational semantics of stack overflow behavior must be given for a language to be scalable to large computations?
14:48:42 <Eduard_Munteanu> I mean, if the result is a list.
14:48:43 <tomh> ok, whats a better way to concat a character at the end of a string recursively than str ++ [c]
14:48:44 <monochrom> deep thunk and eager operators at every level and you evaluate it. all 3 conditions.
14:48:52 <ddarius> weirdo: Strictness is part of the semantics of the function.
14:49:02 <hpc> tomh: difference lists
14:49:10 <hpc> tomh: google will fill in the details
14:49:11 <Eduard_Munteanu> (+) is strict for numbers.
14:49:12 <Peaker> monochrom, required but not sufficient?
14:49:16 <tomh> hpc: thanks
14:49:18 <dibblego> tomh: rope
14:49:22 <monochrom> sufficient and necessary.
14:49:36 <codolio> Peaker: Functions don't need to use stack in a lazy language. (Refutable) case statements do.
14:49:46 <Peaker> monochrom, If I have a deep thunk of eager operators at every level, but that operator is tail-recursive, I don't think it would overflow
14:49:53 <tomh> dibblego: what do you mean with rope?
14:50:06 <dibblego> tomh: rope, concatenation list
14:50:13 <Eduard_Munteanu> @hackage rope
14:50:13 <lambdabot> http://hackage.haskell.org/package/rope
14:50:54 <hpc> http://hackage.haskell.org/packages/archive/data-rope/0.3/doc/html/Data-Rope.html
14:50:58 <tomh> or hmm I could also just do c:str recursively, and at the end reverse the list
14:51:00 <hpc> http://hackage.haskell.org/package/data-rope-0.3
14:51:05 <tomh> that should take O(n) still right
14:51:17 <hpc> tomh: reversing it will
14:51:47 <tomh> I think I just do that
14:51:49 <hpc> reversing a list is generally a sign of doing it wrong, i think
14:51:55 <hpc> unless it works :P
14:51:59 <tomh> hehe 
14:52:07 <tomh> well im building a parser
14:52:16 <tomh> and i need to put tokens in a list 
14:52:21 <kniu_> (\x y -> f . g x y)
14:52:25 <kniu_> @pl (\x y -> f . g x y)
14:52:26 <lambdabot> ((f .) .) . g
14:52:31 <parcs> there's also Data.Sequence which provides O(1) cons and snoc
14:52:33 <tomh> so if I parse a character, it goes in the list
14:52:44 <c_wraith> generally if you want to reverse a list, you should be building it in the other order.
14:52:54 <c_wraith> unless you want both orders at once
14:53:00 <Eduard_Munteanu> Or use some other data structure.
14:53:13 <c_wraith> @check \xs -> xs == reverse xs
14:53:13 <lambdabot>   "OK, passed 500 tests."
14:53:15 <tomh> c_wraith: building it in the other order causes it to concat lists, which is not desirable I think
14:53:16 <hpc> c_wraith: if you want both orders, that's when you stop using a list :P
14:53:16 <Eduard_Munteanu> Seq is better for stuff like queues.
14:53:31 <c_wraith> tomh: no it doesn't.  You just need to be more clever. :)
14:53:53 <tomh> c_wraith: so you suggest I look at rope or another datastructure?
14:54:28 <mercury^> Eh, why did xs == reverse xs pass?
14:54:32 <Eduard_Munteanu> while lists are good stacks
14:54:35 <kmc> xs :: [()]
14:54:36 <c_wraith> > let f x = x : f (x + 1) in take 20 $ f 5
14:54:37 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]
14:54:38 <dibblego> mercury^: because it uses ()
14:54:39 <kmc> defaulting
14:54:50 <kniu_> That seems bad.
14:54:54 <monochrom> defaults to evil
14:55:10 <c_wraith> tomh: The above example builds the list from front to back in O(n) time
14:55:19 <kniu_> @pl (\a -> a == f a)
14:55:19 <lambdabot> ap (==) f
14:55:21 <Eduard_Munteanu> @check \xs -> (xs :: [Int]) == reverse xs
14:55:21 <lambdabot>   "Falsifiable, after 1 tests:\n[-2,2]\n"
14:55:27 <kniu_> :t ap
14:55:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:55:43 <kniu_> @pl (\a -> f a == g a)
14:55:43 <lambdabot> liftM2 (==) f g
14:55:53 <dibblego> kniu: f x (g x) is the same as f `ap` g
14:56:02 <dibblego> (applied to x)
14:56:09 <hpc> @pl (\a -> f a == f a)
14:56:09 <lambdabot> liftM2 (==) f f
14:56:11 <dibblego> kniu: f x (g x) is the same as (f `ap` g) x
14:56:21 <tomh> c_wraith: processing what it does :P
14:56:22 <hpc> aw, i was hoping for const True
14:56:29 <kniu_> @pl (\(_, a) (_, b) -> a == b)
14:56:30 <lambdabot> (. snd) . (==) . snd
14:56:30 <hpc> or at least f `on` (==)
14:56:44 <dibblego> @type on (==)
14:56:44 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
14:56:53 <c_wraith> tomh: you can also use ShowS-style stuff in more complex examples
14:56:54 <FunctorSalad> did something happen to the mailing lists?
14:56:58 <dibblego> @type on (==) snd
14:56:59 <lambdabot> forall a b. (Eq b) => (a, b) -> (a, b) -> Bool
14:57:13 <FunctorSalad> (last message I received is on friday)
14:57:15 <kniu_> @type on
14:57:15 <tomh> mm
14:57:16 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:57:23 <hpc> @src on
14:57:24 <lambdabot> (*) `on` f = \x y -> f x * f y
14:57:37 <hpc> on is cool
14:57:43 <kniu_> didn't know that one.
14:57:49 <kniu_> @src ap
14:57:49 <hpc> though it would seem more natural to me for the arguments to be reversed
14:57:49 <lambdabot> ap = liftM2 id
14:57:55 <kniu_> @src liftM2
14:57:56 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:58:02 <monochrom> my latest received haskell-cafe message is 1.5 hours ago
14:58:09 <kniu_> @src liftM3
14:58:09 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
14:58:14 <kniu_> oh lordy
14:58:15 <FunctorSalad> ok, might be just me then
14:58:17 <dibblego> kniu_: maybe you could look up SKI combinator calculus
14:58:26 <dibblego> (we are currently discussing the S in SKI)
14:58:38 <parcs> FunctorSalad: haskell-cafe is ok for me
14:58:49 <tomh> @src shows
14:58:49 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:58:53 <hpc> i should turn on my mailing list registration again
14:59:00 <hpc> i stopped when i couldn't handle the volume
14:59:12 <Peaker> @type \f -> flip (.) f . ((.) . flip (.)) f
14:59:13 <lambdabot> forall a (f :: * -> *) b. (Functor f) => f a -> (a -> a -> b) -> f (f b)
14:59:20 <Peaker> damn Caleskell
14:59:24 <parcs> hpc: opt to receive message digests
14:59:35 <parcs> you'll get about 30 messages in one email every day
14:59:39 <Peaker> @type \f -> flip (.) f . ((.) . flip (.)) f   where (.) = (Prelude..)
14:59:40 <lambdabot> parse error on input `where'
14:59:45 <hpc> parcs: ooh, thanks
14:59:53 <Peaker> @type \f -> let (.) = (.) = (Prelude..) in flip (.) f . ((.) . flip (.)) f
14:59:54 <lambdabot> parse error on input `='
15:00:02 <Peaker> @type \f -> let (.) = (Prelude..) in flip (.) f . ((.) . flip (.)) f
15:00:03 <lambdabot> forall a a1 c. (a -> a1) -> (a1 -> a1 -> c) -> a -> a -> c
15:00:07 <Peaker> halleluja :)
15:00:10 <monochrom> haskell-cafe has become slow traffic again. 600-650 messages over 20 days
15:00:35 <Axman6> good!
15:00:37 <djahandarie> Maybe this archaic means of communication is finally dying out
15:01:09 * Axman6 feels that stackoverflow is a good replacement for much of haskell-café
15:01:21 <Axman6> and reddit probably fills the rest
15:01:27 <ion> djahandrie: Yes, the telepathy implant works rather well.
15:02:08 <djahandarie> I for one welcome our new computer overlords.
15:02:29 <mm_freak_> i don't like stackoverflow/reddit
15:05:49 <monochrom> quality of questions at stackoverflow is pretty low.
15:06:08 <alpounet> and oleg doesn't post his stuffs there yet
15:06:28 <mm_freak_> first of all they have web interfaces, so you are forced to use the interface, which the webmasters think is the holy correct one…  secondly they are moderated by haskell-unrelated people, so you are forced to obey their rules, and they decide what is proper content
15:06:59 <monochrom> I don't much worry about their rules their moderation.
15:07:07 <mm_freak_> i heard people complaining about censoring perfectly valid posts
15:07:24 <mm_freak_> alpounet: hopefully he never will
15:07:25 <monochrom> did Jon Harrop complain? :)
15:07:46 <Axman6> would't surprise me
15:07:48 <bwright> The issue is they encourage badges etc so much very few people answer uestions properly.
15:07:58 <bwright> It would be better if they based it more on a persons reputation.
15:08:02 <mm_freak_> i reject to even create an account on those platforms
15:08:12 <FunctorSalad> I never find a question I know about that isn't already answererd ;)
15:08:14 <mm_freak_> for the haskell MLs i don't need an account
15:08:22 <Axman6> FunctorSalad: me too
15:08:24 <FunctorSalad> (probably due to not looking often enough)
15:08:26 <Axman6> and that's a good thing
15:08:41 <Axman6> if they have been answered badly, then i go and answer them with something better
15:09:04 <mm_freak_> IMO haskell.org should have an own such platform
15:09:26 <FunctorSalad> "haskelloverflow"? that's so unoriginal it's good again ;)
15:09:34 <mm_freak_> hehe
15:09:45 <hpc> "haskoverflow" perhaps?
15:09:48 <ddarius> "slatternly" needs to be used more
15:10:07 <mm_freak_> actually "stackoverflow" is a perfectly valid name for a discussion platform about haskell
15:10:09 <allbery_b> trappedinIO
15:10:12 <mm_freak_> maybe heapoverflow
15:10:35 <hpc> aavogt: "IOverflow" :D
15:10:38 <mm_freak_> 80% of all newbie questions are about overflows =)
15:10:41 <hpc> er, allbery_b ^
15:11:11 <monochrom> trappedinIO is a good name
15:11:29 <monochrom> trapped'in'IO even better
15:13:42 <ddarius> monadoverflow
15:14:45 * hpc is a fan of IOverflow
15:15:17 <allbery_b> if you go with the stack.heap overflow motif I'd want to work the appropriate fold into the name too :)
15:16:21 <monochrom> foldl'help
15:17:42 <monochrom> I wouldn't mimick the overflow motif.
15:18:18 <ddarius> overflowoverflow
15:18:51 <hpc> ddarius: overflowverflow
15:19:00 <hpc> er
15:19:06 <hpc> overfloverflow
15:19:13 <allbery_b> foldlerol?
15:19:50 <hpc> :t fix (:[])
15:19:51 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
15:19:51 <lambdabot>       Expected type: a
15:19:51 <lambdabot>       Inferred type: [a]
15:19:58 <hpc> occurscheck.com!
15:20:05 <monochrom> IO Exchange Tower
15:21:07 <hpc> ooh, occurscheck.com is free
15:21:19 <hpc> it doesn't even resolve to a parked domain
15:21:30 * hackagebot RSA 1.0.6.1 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-1.0.6.1 (AdamWick)
15:21:49 <weirdo> what's the haskell convention of marking predicate functions? in scheme they were suffixed with '?', in lisp, it was '-p'
15:22:19 <allbery_b> isSomething is the most common one I see
15:22:20 <alpounet> name it 'p', or 'pred', or 'predicate' heh
15:22:25 <alpounet> oh
15:22:37 <alpounet> not as an arg, but as the name of a given predicate
15:22:40 <ddarius> weirdo: Down with booleans!
15:22:43 <Twey> Nah, we usually just leave them alone
15:22:49 <Philonous> hpc: Occurs check is a unification thing, so I suspect you would attract prolog programmers rather than haskellers
15:22:51 <monochrom> heh, occurscheck.com is nice too
15:22:59 <Twey> odd, even, all, or, and
15:23:09 <monochrom> ooh, attract prolog people to haskell!
15:23:19 <allbery_b> if you look too deep into the predicate, the predicate looks also into you?
15:23:29 <monochrom> @type null
15:23:30 <lambdabot> forall a. [a] -> Bool
15:23:40 <monochrom> is a predicate following no convention
15:23:42 <alpounet> that's for java people
15:23:42 <Twey> Yeah, there are a bunch ☺
15:23:50 <monochrom> also look for odd, even.
15:23:57 <Twey> 000216 < Twey> odd, even, all, or, and
15:24:01 <Twey> >.>
15:24:08 <monochrom> Twey wins
15:24:20 <Twey> \o/
15:24:24 <monochrom> no one likes not.
15:24:31 <Twey> Heh
15:24:44 <monochrom> not is the mother of all predicates. not.
15:24:51 <Twey> Calling not a predicate seems like a bit of a stretch
15:24:55 <ddarius> Twey: Clearly all, and, and or should be isAll, isAnd and isOr.
15:24:58 <Twey> I guess you'd have to include id in that case, too
15:25:04 <Twey> ddarius: Obviously.
15:25:13 <monochrom> if you include or, you may as well include not.
15:25:14 <ddarius> monochrom: isNot
15:25:33 <Philonous> @type or
15:25:34 <lambdabot> [Bool] -> Bool
15:25:48 <ddarius> Twey: id would of course need to be renamed to simply, is.
15:25:55 <Twey> You could also call it ‘anyTrue’
15:25:58 <Twey> ddarius: Heheh
15:26:11 <Twey> @let is = id :: Bool -> Bool
15:26:11 <lambdabot>  Defined.
15:26:35 <Twey> @let yes = const True
15:26:36 <lambdabot>  Defined.
15:26:40 <Twey> @let no = const False
15:26:41 <lambdabot>  Defined.
15:26:42 <monochrom> no, you need "is too" to go with "is not"
15:27:10 <monochrom> isToo (isNot (isToo (prime 2)))
15:27:29 <Twey> Heh
15:28:12 <Peaker> weirdo, Well, when you have static types on stuff (e.g: String -> Bool) and it's visible in the documentation, in ghci, etc as well as checked, a "-p" suffix is less useful
15:28:40 <Peaker> weirdo, Scheme's "?" and "!" suffixes are great, though in Haskell at least the "!" tagging is far deeper with IO
15:28:43 <monochrom> Hungarian notation is Hungarian
15:28:44 <Twey> > let { let's _ _ _ _ = text "OK?"; [get, carried, away] = [0, 0, 0] } in let's not get carried away
15:28:45 <lambdabot>   OK?
15:29:25 <ddarius> That and booleans were sent by the devil to lead you to iniquity.
15:29:28 <monochrom> > let { let's _ _ _ _ = text "OK?"; [not, get, carried, away, ok] = [0, 0, 0] } in let's not get carried away
15:29:29 <lambdabot>   OK?
15:29:56 <hpc> @let { let's _ _ _ _ _ = text "OK?"; [get, carried, away, now] = [0, 0, 0] }
15:29:56 <lambdabot>  <local>:6:0: parse error on input `{'
15:30:02 <hpc> > let's not get carried away now
15:30:03 <lambdabot>   Not in scope: `let's'Not in scope: `carried'Not in scope: `away'Not in scop...
15:30:15 <monochrom> hehe
15:30:46 <Twey> Does @let allow multiple bindings?
15:30:50 <monochrom> no
15:30:51 <hpc> @let let's _ _ _ _ _ = text "OK?"; [get, carried, away, now] = [0, 0, 0]
15:30:52 <lambdabot>  Defined.
15:31:00 <hpc> > let's not get carried away now
15:31:01 <lambdabot>   Ambiguous occurrence `get'
15:31:01 <lambdabot>  It could refer to either `L.get', defined at <l...
15:31:04 <Twey> Heh
15:31:06 <monochrom> > now
15:31:07 <hpc> bah, humbug
15:31:07 <lambdabot>   *Exception: <local>:6:30-66: Irrefutable pattern failed for pattern [get, c...
15:31:11 <hpc> @forget
15:31:11 <lambdabot> Incorrect arguments to quote
15:31:13 <hpc> @undefine
15:31:16 <monochrom> ok, it allows multiple bindings
15:31:39 <ddarius> @let f 0 = 1
15:31:40 <lambdabot>  Defined.
15:31:42 <monochrom> you can save typing by @define :)
15:31:43 <FunctorSalad> ddarius: why? (not that I disagree... but not sure what you mean)
15:31:50 <FunctorSalad> (about booleans, not f)
15:31:52 <ddarius> @let f n = f (n-1) * f (n-1)
15:31:52 <lambdabot>  <local>:2:6:
15:31:53 <lambdabot>      Ambiguous occurrence `f'
15:31:53 <lambdabot>      It could refer to either `L....
15:31:59 <ddarius> Hmm
15:32:22 <monochrom> @unslap monochrom
15:32:22 * lambdabot slaps monochrom
15:32:30 <monochrom> @debotsnack
15:32:30 <lambdabot> :)
15:32:41 <kniu_> @pl (\(x, y) -> (f x, y))
15:32:41 <lambdabot> first f
15:32:49 <kniu_> @hoogle first
15:32:49 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
15:32:50 <lambdabot> Data.Monoid newtype First a
15:32:50 <lambdabot> Data.Monoid First :: Maybe a -> First a
15:33:01 <monochrom> @isfaq does haskell speak negative?
15:33:01 <lambdabot> The answer is: Yes! Haskell can do that.
15:33:30 <alpounet> kniu, it just maps the first component of the tuple using the given function
15:33:34 <allbery_b> @notfaq Really?
15:33:34 <lambdabot> Unknown command, try @list
15:33:35 <ddarius> FunctorSalad: You almost always want more information than a boolean provides.
15:33:42 <allbery_b> hm, should gave been 3 edits
15:33:44 <hpc> @faq can haskell ever so far as to be like?
15:33:44 <lambdabot> The answer is: Yes! Haskell can do that.
15:34:02 <alpounet> (even though it can be used in a more general framework, that is, Arrows)
15:34:29 <Peaker> Arrows should be put to rest, since the discovery of Category+Applicative = Arrow, shouldn't they?
15:34:44 <Peaker> where = here means equivalent in power/genericity :)
15:34:55 <kniu_> Why is first in Control.Arrow and not Data.Tuple?
15:35:10 <monochrom> or Category+Applicative be put to rest.
15:35:10 <kniu_> Actually, why does Data.Tuple have barely any functions in it?
15:35:12 <hpc> :t first
15:35:13 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:35:32 <hpc> first is required to be in arrow
15:35:36 <hpc> it is a typeclass function
15:35:42 <alpounet> @src Arrow
15:35:43 <lambdabot> class Arrow a where
15:35:43 <lambdabot>     arr, pure   :: (b -> c) -> a b c
15:35:43 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
15:35:59 <hpc> lambdabot is wrong, here
15:36:02 <alpounet> heh
15:36:10 <alpounet> indeed
15:36:14 <Philonous> Peaker: It appears the only convincing reason to use arrows in the first place is Paterson's arrow notation (which is very nice, though)
15:36:15 <byorgey> kniu: the notion of tupling and the notion of arrows are closely related
15:36:45 <Peaker> Philonous, I always found that notation confusing
15:40:51 <Philonous> Peaker: Really? Why?
15:41:46 <ian_mi> I'm trying to implement type arithmetic using type synonym families. How do I make a type synonym an instance of a class?
15:42:32 <Cale> I'm not sure that you can, since it's a synonym, and those are normally not permitted in instance heads.
15:42:33 <Peaker> Philonous, I'm not sure
15:42:49 <Cale> You might be able to write an instance for the type which it unravels to.
15:42:51 <Peaker> Philonous, it was something like:  x -< f <- y ?
15:43:01 <Cale> x <- f -< y
15:43:24 <Philonous> Peaker: Well, yes, because you are dealing with 2 scopes at the same time
15:43:35 <Peaker> and x and y are fake point names and f is an arrow instance value?
15:43:55 <Peaker> Philonous, Maybe it's because I like points-free
15:44:17 <ian_mi> Cale: yes, I do have instances for the synonym type but my functions can't deduce that it seems.
15:45:56 <Philonous> Peaker: Ah okey, so you don't like "regular" do notation either?
15:50:24 <ddarius> Grargh!
15:50:49 * shachaf agrees with ddarius.
15:50:54 <Peaker> Philippa, I avoid it unless dealing with very imperative code
15:50:59 <Peaker> Philippa, (mostly)
15:51:25 <byorgey> points-free arrow expressions quickly get really really ugly though, because of all the tupling
15:51:54 <byorgey> somehow you just don't end up needing as much tupling when working with monads
15:52:12 <byorgey> although this is all rather hand-wavy of course
15:52:47 <hpc> byorgey: "somehow" == "more study" i would say
15:52:48 * djahandarie waves his hands like a crazy man
15:53:08 <hpc> having arrow deal with tuples directly is kind of a mistake
15:53:09 <byorgey> hpc: indeed
15:53:14 <ddarius> byorgey: I don't think people often make fully point-free monadic code.
15:53:15 <thunkee> are there diagonal (fair) list generators in haskell?
15:53:21 <freedrull> <$> has the same type as fmap, how is it different
15:53:31 <byorgey> ddarius: well, that's also a good point.
15:53:35 <hpc> freedrull: it looks cooler
15:53:41 <ddarius> thunkee: There were in Miranda, not (built-in to) Haskell.
15:53:45 <hpc> ;)
15:53:48 <freedrull> :3
15:53:52 <djahandarie> The monad symbols look terrible in point-free form anyways
15:53:56 <thunkee> ddarius: i know ;)
15:54:06 <FunctorSalad> it has different infix precedence iirc
15:54:23 <thunkee> what to do with inifite generators in haskell?
15:54:56 <Saizan> you can curry a kliesli arrow, but not a general one
15:55:04 <hpc> thunkee: evaluate the last element! :D
15:55:11 <FunctorSalad> ghc-7.0.2/libraries/base/Data/Functor.hs:infixl 4 <$>
15:55:18 <freedrull> hpc: oh, you are actually being serious..
15:55:20 <hpc> thunkee: more seriously, compose them, since they are streams :P
15:56:15 <thunkee> thanks i have a look
15:56:28 <Peaker> @hoogle ApplicativeFix
15:56:28 <lambdabot> No results found
15:56:42 <FunctorSalad> thunkee: http://hackage.haskell.org/package/control-monad-omega ?
15:56:52 <Peaker> btw: Is there a nice Applicative-based parser + fix-point operator for recursive support that can do context-free grammars without back-tracking?
15:56:57 <Peaker> (i.e: good complexity wise)
15:57:20 <Peaker> I guess the arrow-parser can be converted to an Applicative one
15:58:38 <Philonous> byorgey: You don't need the tuples in monads because you have closures. So you can just capture a variable and re-use it later, but arrow-composition is not a regular function, so you have to thread your variables through by hand
15:59:16 <byorgey> Philonous: ah, right.
15:59:29 <Peaker> Philonous, and it sucks that Arrows chose a type product rather than an arbitrary type composition. For some things that could usefully be arrows, it makes sense to have a sum there, not a product
15:59:33 <Peaker> Also sucks to have "arr" in there
15:59:40 <Peaker> bah, I hate arrows
15:59:57 <dibblego> "fuck arrows" -- Edward Kmett
15:59:58 <Philonous> @type left
15:59:58 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
16:00:04 <dibblego> edwardk: :)
16:00:27 <byorgey> Peaker: hmm, I knew about 'arr' but I had never heard that other thing mentioned (re: using e.g. sums instead of products) -- can you give an example?
16:01:33 <FunctorSalad> "Your search - "fuck arrows" kmett - did not match any documents. " :(
16:01:39 <monochrom> @arr matey
16:01:40 <lambdabot> Drink up, me 'earties
16:01:47 <monochrom> heh
16:02:02 <Peaker> byorgey, yairchu wrote a sort-of FRP framework, and he wanted to use arrows (a bit similarly to Yampa). However, his arrow represented a stream like: Input -> [Output], where Inputs are sporadic events.  Horizontal composition (>>>) makes sense. But Vertical composition (***) means the input of the composed arrow is an Either, not a tuple, because you won't have two sporadic events simultaneously there
16:02:11 <Philonous> Peaker: I never said arrows were a nice abstraction, let alone beautiful. But Paterson's notation makes them too useful to skip.
16:02:45 <ddarius> Philonous: ?
16:03:04 <byorgey> Peaker: I see
16:03:05 <Peaker> @src ArrowChoice
16:03:05 <lambdabot> Source not found. Take a stress pill and think things over.
16:03:15 <Peaker> byorgey, I guess he wanted ArrowChoice but not (***)
16:03:21 <dibblego> hmm can't find it now
16:04:17 <Peaker> I think Arrows have completely failed to generalize. Almost every attempt to use Arrows for anything but their 2 original intended purposes fails because of some annoying restriction
16:04:37 <Peaker> Completely unlike Functor, Applicative, Monad, which generalize awesomely (except for "fail" of course)
16:05:30 <dibblego> and point/return
16:08:30 <FunctorSalad> Peaker: hmm Applicative does?
16:08:30 <Peaker> byorgey, http://hackage.haskell.org/packages/archive/peakachu/0.3.0/doc/html/FRP-Peakachu-Program.html  this is how he ended up abstracting his (* -> * -> *) Category type
16:08:46 <Peaker> FunctorSalad, If Monad does, then Applicative clearly does :)
16:08:47 <FunctorSalad> (Applicatives that aren't Monads except for ZipList)
16:09:08 <Peaker> FunctorSalad, efficient context-free parser?
16:09:11 <dibblego> there are plenty
16:09:44 <dibblego> Semigroup e => (Either e) a is a useful one
16:10:36 <FunctorSalad> hmm just a multiplicative identity short of monad?
16:10:51 <FunctorSalad> though maybe that's a larger point than it seems
16:13:08 <thierry`> Hi, I'm working on a toy project : a latex code beautifier (or parser in some way). I'm stuck by the number of way I can deal that. Naturally I would work with regular expression but I want to see if I can use Algebraic data types or anything else haskell offers to work in another way. In short : how can I do that without regex in haskell?
16:14:20 <byorgey> thierry`: use a parser combinator library, such as parsec
16:14:37 <monochrom> attoparsec or parsec for parsing. the "algebraic data type" part is just how you store the parsing result.
16:15:00 <thierry`> thanks a lot :)
16:15:11 <Axman6> thierry`: turning to regexs as a first step is almost always a bad idea
16:15:43 <thierry`> Axman6 : noted!
16:15:56 <monochrom> regex does the lexing part at best. lexing could be done in attoparsec or parsec.
16:15:58 <byorgey> in other words, instead of incrementally modifying a string using regular expressions, first parse into an abstract representation (i.e. an algebraic data type), then beautify that appropriately, then pretty-print it back into a string.
16:16:19 * ddarius won't point out that the "correct" answer here leads down a particularly long path (that #haskellers will joyously espouse.)
16:16:44 <thierry`> ddarius : just my curiosity, what path is that?
16:17:11 <Evious> The path of figuring out how to use parser combinator libraries.
16:17:14 * shachaf refrains from pointing out that ddarius has an unusual way of not pointing things out.
16:18:01 <Evious> (I asked a simple question about regexen here a while ago as well: the response in favor of parser combinators was similar though more vocal, and I spent way more time than I could've.)
16:18:24 <thierry`> at least parsec documentation seems to offer a lot to chew on 
16:18:27 <Evious> (The problem I had didn't need the power of parser combinators at all and I never touched that code after writing it.)
16:18:48 <ddarius> thierry`: Think about how you parse TeX.
16:18:49 <thierry`> Evious : exactly, I just want to indent my latex to my taste :P
16:19:20 <thierry`> but in the form of a beautifier (you know, to learn more haskell)
16:19:28 <monochrom> I bet that you stated your need so grandly that it sounded like regex would be inadequate.
16:19:56 <Evious> There is the dual to the problem, of course: I wrote a very simple regex at work which I ended up changing and debugging three or four times, each time getting more and more complex. It's hard to predict how complex a regex you'll need, sometimes.
16:20:40 <monochrom> If your real job is "every time I see \begin{blah}, indent; every time I see \end{blah}, deindent", regex may suffice, you keep your own indent count.
16:21:13 <thierry`> great, now let's say I want to work with regex (for now) with module should I use? there's so many I don't know which one to take
16:21:25 <monochrom> I would begin with Text.Regex
16:21:33 <ddarius> They all present the same interface.
16:21:50 <monochrom> the package name is regex-compat
16:21:52 <thierry`> kk I didn't know, I'll look at that
16:22:03 <monochrom> I got it from Haskell Platform
16:22:29 <Adamant> getting the regex right is fun
16:22:33 <Adamant> *regexes
16:22:33 <Evious> The regex typeclass interface looks like a real train wreck. I couldn't figure it out :(
16:23:17 <monochrom> I somewhat figured it out. But I still use Text.Regex most of the time (no type class, no =~ etc).
16:23:22 <ddarius> Evious: So don't use that interface.
16:23:27 <Adamant> especially when you use PCRE-type ones and overmunch by trying to get too fancy with the regex instead of treating it as real regular expressions
16:23:32 <Evious> done :D
16:23:55 <ddarius> Evious: I am glad we were able to efficiently come to this amicable solution.
16:24:00 <btutt> Heh. Yeah, Perl like regular expressions are definitely not regular.
16:24:31 <thierry`> ok last question : I'm working mainly with emacs. how could I use a haskell parser to tell emacs how to indent/color the code I parsed? Is it possible? Am I at the wrong place to ask this?
16:24:49 <Adamant> trying to figure out where the lexer ends and parser begins gets very annoying and is probably a bad idea overall. learned that one the hard way.
16:25:42 <tolkad> Can you do anything you can do with fundeps using type families without superclass constraints?
16:26:41 <tolkad> I don't see how to write « class C a b | a -> b, b -> a » without superclass constraints
16:26:42 <ddarius> No.
16:26:57 <tolkad> what about with superclass constraints?
16:27:02 <ddarius> Yes.
16:28:56 <tolkad> « class (CB (A a), B (A a) ~ a) => CA a where { type A a :: * }; class (CA (B b), A (B b) ~ b) CB b where { type B b :: * }
16:29:07 <tolkad> I guess that's how you would do it
16:29:18 <Peaker> tolkad, You've got a one-to-one relationship between 'a' and 'b', so:  class C a where data B a ; ...
16:29:30 <Peaker> tolkad, it's not exactly the same in the sense of requiring to define a new data-type
16:29:30 <tolkad> Peaker: type functions aren't injective
16:29:37 <Peaker> tolkad, note "data" and not "type"
16:29:41 <tolkad> oh
16:30:06 <Peaker> that's basically the difference, with "data", each instance needs to define a new type with "data" or "newtype", so it is bijective and type inference can figure it out either way
16:30:09 <Peaker> (either direction)
16:30:35 <Peaker> But I think it's actually a nicer way to enforce the one-to-one constraint
16:30:41 <tolkad> can you do everything you can do with multiparam type classes using superclass constraints + type families?
16:30:43 <Peaker> than to arbitrarily throw up an error if it is violated
16:31:03 <tolkad> Peaker: weeeeell... you start having to mess about with generalized newtype deriving
16:31:58 <tolkad> if you don't want to write tons of instances
16:32:30 <Peaker> I remember a problem with GND, but it's still usable.. what's the issue?
16:32:52 <Eduard_Munteanu> You can do anything you want with zombocom
16:32:53 <Peaker> btw: Another option is to use the Wrapped class for accessing the content of the newtype
16:32:59 <tolkad> Peaker: if you use it wrong with type families you can write unsafeCoerce
16:33:29 <Peaker> tolkad, well, if you use newtype + GND but don't write any manual instances of the newtype, is that still possible?
16:33:48 <monochrom> thierry`: if your program reads from stdin and writes to stdout, you can in emacs mark a region then give it to your program by M-|
16:34:07 <Peaker> tolkad, class Wrapped w where type Unwrapped w ; wrap :: Unwrapped w -> w ; unwrap :: w -> Unwrapped w
16:34:19 <monochrom> this only helps indentation (or in general all textual transforms) but not color.
16:34:45 <tolkad> Peaker: I'm not sure. I think you mostly just have to avoid passing type parameters to type functions within a newtype and also using generalizednewtype deriving on that same newtype
16:35:06 <Peaker> tolkad, then you can have:  inWrap :: (Wrapped w) => (a -> b) -> w a -> w b ; inWrap f = wrap . f . unwrap
16:35:25 <co_dh> ping
16:35:33 <Peaker> tolkad, inWrap2, inWrap3, etc. then it's not such a big deal to unwrap the newtype "manually"
16:35:42 <tolkad> Peaker: or something like that
16:35:56 <tolkad> why can't we just get superclass constraints?
16:36:04 <tolkad> it was supposed to be released with ghc 7.0.2
16:36:07 <Peaker> tolkad, I once started at a GND breakage example for a good few minutes and didn't get the problem, I shall look again sometime
16:36:26 <Peaker> tolkad, if you use GND reasonably, you should be safe?
16:36:33 <tolkad> Peaker: probably
16:36:40 <tolkad> hopefully
16:38:12 <tolkad> I was wrong earlier about how you trigger it. I don't really understand it myself
16:38:44 <Peaker> tolkad, anyway, with "Wrapped", you just use your instances via "inWrap" mostly..
16:40:22 <tolkad> :t inWrap . inWrap
16:40:22 <lambdabot> Not in scope: `inWrap'
16:40:23 <lambdabot> Not in scope: `inWrap'
16:41:35 <tolkad> Peaker: well, that doesn't work for less straightforward classes
16:42:51 <tolkad> Peaker: wait when did double get kind * -> *?
16:42:57 <tolkad> Peaker: wait when did w get kind * -> *?
16:43:05 <tolkad> don't know why I said double there
16:43:58 <applicative> w is upside down m, I heard, so of course its * -> * 
16:44:03 <Peaker> tolkad, oh whoops, that was wrong :)
16:44:33 <Saizan> applicative: not * <- * ?
16:44:45 <Peaker> tolkad, inWrap :: (Wrapped w, Wrapped w') => (Unwrapped w -> Unwrapped w') -> w -> w'
16:46:17 <tolkad> Peaker: so how would I do this with an Ix instance?
16:46:44 <tolkad> Peaker: wait nevermind, guess I have to write the Ix instance myself
16:46:49 <Peaker> tolkad, same as any other?  inWrap (someArr!) myIxWrapper
16:46:54 <kmc> arr!
16:47:04 <Peaker> tolkad, instead of someArr ! myIxWrapper
16:47:27 <Peaker> well, actually, that's not inWrap :)
16:47:40 <Peaker> just: someArr ! unwrap myIxWrapper
16:49:17 <tolkad> hmm, I'd still rather have superclass constraints. How would I go about fixing superclass constraints in my copy of ghc?
16:49:48 <ddarius> I recommend just sitting there staring at it for a few months.  Then downloading a new version of GHC.
16:52:20 <tolkad> ddarius: I have been making progress
16:52:47 <tolkad> ddarius: for example, I recently figured out that the reason I couldn't find any source files in my ghc copy was that I downloaded a have-prebuilt stage2 version
16:52:55 <tolkad> half-prebuilt*
16:53:29 <tolkad> or maybe it's completely prebuilt and just comes with some of the build files incase I need them or something
16:53:48 <Peaker> will fundeps ever be deprecated?
16:54:22 <tolkad> Peaker: seems it would be easy to just make them into syntatic sugar
16:54:43 <Peaker> don't think so, you need to give a name to each relationship
16:55:08 <tolkad> Peaker: so... just generate a unique name then?
16:55:08 <dolio> I wouldn't be surprised if fundeps became sugar for type families at some point.
16:55:08 <weirdo> aiee! my function won't typecheck
16:55:16 <monochrom> \∩/
16:55:17 <Peaker> tolkad, not something I'd want in real code
16:55:17 <tolkad> weirdo: source please?
16:55:22 <dolio> With auto-generated names.
16:55:24 <Peaker> tolkad, the name is user-visible
16:55:33 <hpaste> sthalik pasted "won't typecheck"  http://hpaste.org/44607
16:55:39 <Peaker> How do you know which name was used?
16:55:46 <tolkad> Peaker: oh. it could also have some reverse-sugar for error messages
16:55:48 <weirdo> please don't laugh, and not sure if it works
16:55:57 <weirdo> other than the types
16:56:03 <tolkad> Peaker: and other error messages contain generated names for type variables
16:56:25 <tolkad> Peaker: even when those type variables don't collide with anything else in that particular error message
16:56:39 <Peaker> tolkad, if you aren't supposed to use the TF name in code, is it only meant to ease on the compiler?  You don't get more power by supporting both if they don't mix
16:57:07 <Peaker> (i.e: refer to a fundep as a type family in newer code)
16:57:10 <tolkad> weirdo: why don't you start by writing type annotations for odometer and foo?
16:57:11 <Eduard_Munteanu> foo x acc base
16:57:16 <Eduard_Munteanu> foo [] 10
16:57:26 <tolkad> weirdo: unless Eduard_Munteanu comes and solves it for you :P
16:57:36 <weirdo> tolkad, where do i put the annotation for foo?
16:57:45 <weirdo> do i need to surround it with () and put :: at the end?
16:58:06 <tolkad> weirdo: put foo on a new line, same indentation as the where keyword. put the annotation on the line before it
16:58:30 <weirdo> Eduard_Munteanu, d'oh :)
16:58:32 <Eduard_Munteanu> And you probably need to get rid of those type sigs there
16:58:36 <augur> erm
16:58:37 <augur> ok where was i
16:58:49 <augur> why does that thing work
16:58:54 <Eduard_Munteanu> Mmm... '~'?
16:59:00 <tolkad> weirdo: where\n<indent>annotation\n<indent>foo … = …
16:59:04 <Eduard_Munteanu> augur: ^   (last time I remember)
16:59:08 <augur> > (\ (~(Just _)) -> 5) Nothing
16:59:09 <lambdabot>   5
16:59:15 <augur> yeah what that makes no sense
16:59:33 <Cameron_> hey, what are some big name websites written in haskell?
17:00:03 <kmc> why do you ask Cameron_?
17:00:11 <tolkad> augur: huh? I thought lazy pattern matching just delays the pattern matching until you try to strictly evaluate the expression
17:00:16 <Cameron_> curiosity
17:00:25 <augur> tolkad: maybe! but whats up with this then
17:00:35 <tolkad> augur: maybe a caleskell feature
17:00:56 <tolkad> augur: caleskell has such wonderful features
17:01:02 <augur> nope, ghci says the same
17:01:22 <magicman> Lazy pattern match only gets forced when one of the bound variables is needed.
17:01:42 <magicman> If you don't bind any variables -> no worries.
17:01:45 <augur> so ~(Just _) is the same as _
17:01:57 <tolkad> Cameron_: you coulld probably search for the server headers of all popular haskell http server libraries on some web statistics site
17:01:57 <magicman> > (\ (~(Just _)) -> 5) undefined
17:01:58 <lambdabot>   5
17:02:30 <tolkad> magicman: huh, I didn't know that
17:02:48 <tolkad> magicman: makes sense though
17:02:48 <magicman> > (\ (~(Just x)) -> 5) undefined -- still goes well, we never use x.
17:02:49 <lambdabot>   5
17:02:57 <magicman> > (\ (~(Just x)) -> x) undefined -- BOOM!
17:02:58 <lambdabot>   *Exception: Prelude.undefined
17:03:04 <augur> weird
17:03:15 <magicman> > (\ (~(Just x)) -> x) Nothing -- Also BOOM!
17:03:16 <lambdabot>   *Exception: <interactive>:3:1-18: Irrefutable pattern failed for pattern (D...
17:03:18 <tolkad> > (\ (~(Just x)) -> case x of ~1 -> 5) undefined
17:03:19 <lambdabot>   5
17:03:25 <tolkad> > (\ (~(Just x)) -> case x of 1 -> 5) undefined
17:03:26 <lambdabot>   *Exception: Prelude.undefined
17:03:32 <augur> ok but this is a fact about haskell not something inherent to the stuff
17:03:35 <c_wraith> http://www.cs.berkeley.edu/~megacz/coq-in-ghc/
17:03:40 <tolkad> > (\ (~(Just x)) -> 5 + 0 * (case x of 1 -> 5)) undefined
17:03:41 <c_wraith> This guy is doing some impressive stuff
17:03:41 <lambdabot>   *Exception: Prelude.undefined
17:03:53 <tolkad> > (\ (~(Just x)) -> 5 + const 0  (case x of 1 -> 5)) undefined
17:03:54 <lambdabot>   5
17:04:22 <weirdo> http://hpaste.org/paste/44607/compiler_clearly_hates_me#p44608
17:04:24 <kmc> holy damn what is all this
17:04:31 <magicman> augur: How do you mean?
17:04:45 <tolkad> kmc: too spammy? sorry
17:04:47 <augur> magicman: nm
17:05:03 <mauke> weirdo: did you mean: :
17:05:15 <monochrom> all this is fascination with newly discovered ~ patterns
17:05:16 <kmc> i meant c_wraith's link
17:05:26 <monochrom> oh haha nevermind
17:05:26 <kmc> i'm good at ignoring lambdaspam now
17:05:30 <tolkad> weirdo: what error message did you get?
17:06:21 <c_wraith> There's all kinds of wrong stuff in that paste
17:06:46 <tolkad> c_wraith: yeah, trying to help teach him how to debug haskell code
17:07:08 <weirdo> finally, it works! thank you!
17:07:10 <weirdo> mauke :-)
17:07:27 <monochrom> oh heh
17:08:00 <monochrom> "debug your mind, not your code"
17:08:16 <tolkad> weirdo: in the future when you get error messages in haskell, the first thing to do if you can't immediately see the error is annotate everything until the error message references the actual error
17:08:49 <tolkad> weirdo: often, if you lack annotations, ghc error messages end up being in completely different places than the actual error is
17:09:11 <tolkad> weirdo: because ghc assumes the error is correct and the rest of the universe is wrong
17:09:11 <djahandarie> We should make a collection of all these functional-programming-related zen-like statements
17:09:54 <monochrom> that helps with type errors but not typo errors like your hand writes "::" and your eyes see "::" too but your brain is stuck thinking you have ":" there
17:10:25 <djahandarie> (This problem gets worse after using Agda)
17:10:38 <tolkad> monochrom: 0_o what is this? « else foo rem quot :: acc »
17:10:46 <tolkad> monochrom: wont that make acc a type variable?
17:10:51 <monochrom> typo errors can only be spotted by another person
17:11:18 <tolkad> monochrom: oh. I thought it was supposed to be a type variable XD
17:11:26 <weirdo> tolkad, i see :-)
17:11:30 <tolkad> was rather confused about what he was trying to do
17:13:44 <monochrom> this is perhaps how pair programming was invented. but the inventor forgot that there is internet and IRC.
17:14:06 <kmc> i thought pair programming was invented to negate the effects of internet and IRC
17:14:36 <hpc> pair programming negates the effects of one of you being a total scatterbrain :P
17:15:00 <kmc> pair programming is one of those things which seems totally insane but is also advocated by intelligent people i respect
17:15:02 <kmc> so i don't know what to think
17:15:18 <confound> it's useful sometimes
17:15:23 <monochrom> the opinion leader problem I have always explained
17:15:46 <weirdo> finally! odometer 4269 ==> [4,2,6,9]
17:15:56 <Peaker> kmc, Sometimes it works
17:15:58 <hpc> weirdo: ??
17:16:11 <Peaker> kmc, if the other guy is of a similar aptitude and the problem fits
17:16:13 <weirdo> my great awesome function
17:16:18 <monochrom> opinion leaders are very intelligent people. their methods work perfectly for their calibre, no question about that. that is the problem of adopting their methods by the rest.
17:16:27 <weirdo> now i'm gonna implement long division
17:16:31 <weirdo> for project euler
17:16:36 <weirdo> think it's a good way to learn haskell
17:16:41 <hpc> ah
17:17:03 <kmc> project euler is a great way to learn part of haskell
17:17:03 <hpc> i found PE is more of an exercise in number theory, myself
17:17:10 <b52> can i do something like this in pattern recognition: "asd" ++ xs = "asdfoo"
17:17:12 <b52> ?
17:17:12 <kmc> there's a huge chunk of the language which it won't teach you
17:17:14 <hpc> though one crazy guy does all the problems in assembly
17:17:19 <tolkad> :t map(show.(:[])).show
17:17:20 <lambdabot> forall a. (Show a) => a -> [String]
17:17:22 <kmc> no b52
17:17:31 <b52> something simliar kmc ?
17:17:39 <kmc> you can do ('a' : 's' : 'd' : xs) = ...
17:17:43 <tolkad> > map(show.(:[])).show 4269
17:17:44 <lambdabot>   Couldn't match expected type `[a]'
17:17:44 <lambdabot>         against inferred type `GHC.Types...
17:17:47 <kmc> because (:) is a constructor of the list type, while (++) isn't
17:17:51 <kmc> (++) is an ordinary function
17:17:54 <tolkad> > (map(show.(:[])).show) 4269
17:17:55 <lambdabot>   ["\"4\"","\"2\"","\"6\"","\"9\""]
17:17:55 <b52> hmm ok
17:18:01 <tolkad> whoops.....
17:18:02 <monochrom> for example Knuth would tell you "I write MMIX code by hand, everyone should do it". he is a very intelligent people. what do you think if the rest of us do it? "totally insane" is exactly what will happen.
17:18:08 <tolkad> > (map(read.(:[])).show) 4269
17:18:10 <lambdabot>   [*Exception: Prelude.read: no parse
17:18:37 <tolkad> > (map(read.(:[])).show) 4269 :: [Int]
17:18:39 <lambdabot>   [4,2,6,9]
17:18:42 <tolkad> there we go
17:18:48 <tolkad> weirdo: =D
17:18:53 <dibblego> b52: 'a':'s':'d':xs = 
17:18:54 <hpc> monochrom: the sign of true insanity is being intelligent people
17:20:09 <monochrom> I would love to see Knuth and Dijkstra do pair programming. XD
17:20:10 <Eduard_Munteanu> Admittedly, the compiler could desugar (++) to (:) in some cases.
17:20:29 <hpc> monochrom: or perhaps torvalds and dons? :P
17:20:34 <tolkad> Eduard_Munteanu: they both run in O(1) in those cases anyway
17:20:36 <Eduard_Munteanu> But that works only for xs (++) ys where xs = constant
17:20:53 <tolkad> Eduard_Munteanu: it never has to iterate through the second list
17:21:03 <tolkad> > [0] ++ [0..]
17:21:05 <lambdabot>   [0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
17:21:07 <Eduard_Munteanu> Yeah, it's only a convenience problem.
17:21:36 <monochrom> torvalds and tanenbaum should do pair programming XD
17:21:53 <tolkad> Eduard_Munteanu: just write your code as inefficiently as you want to and hope that someday ghc will be able to optimize it
17:22:36 <Eduard_Munteanu> And hope P = NP :P
17:22:38 <kmc> case xs of [0..] -> ...
17:22:41 <Eduard_Munteanu> :NP
17:22:52 <kmc> P := NP
17:23:01 <hpc> kmc: oh god
17:23:20 <Eduard_Munteanu> You suddenly made things difficult.
17:23:38 <tolkad> > \x -> case x of [0..] -> x
17:23:39 <lambdabot>   <no location info>: Parse error in pattern
17:23:47 <tolkad> lol didn't think that would work
17:23:59 <tolkad> > \x -> case x of [0..1] -> x
17:24:00 <lambdabot>   <no location info>: Parse error in pattern
17:24:23 <tolkad> those are just syntatic sugar for the Enum functions. nothing magic about them
17:24:50 <Eduard_Munteanu> I meant the P := NP part  :)
17:25:22 <Eduard_Munteanu> OTOH, I think it'd make life simpler for programmers.
17:25:42 <tolkad> I thought := meant define
17:25:53 <Eduard_Munteanu> Erm, or maybe not.
17:26:00 <Eduard_Munteanu> Ah, I interpreted it as assignment.
17:26:19 <nswill> Any thoughts as to why a foreign export function that calls putMVar would have to be called *twice* to make another thread unblock from takeMVar? Every foreign call to my "put" function after the first 2 functions as expect, ie, one call, one unblock.
17:26:53 <tolkad> Eduard_Munteanu: what's the difference between define and assign?
17:27:08 <hpc> duplicate definitions cannot happen
17:27:18 <hpc> assign = mutate; define = crate
17:27:21 <hpc> *create
17:29:35 * hackagebot silently 0.0.2 - Prevent or capture writing to stdout.  http://hackage.haskell.org/package/silently-0.0.2 (TrystanSpangler)
17:29:44 <tolkad> nswill: you are accidentally taking it twice
17:30:23 <tolkad> nswill: search your codebase for all related instances of takeMVar, add a debug print statement right before them so you know how many times each is executed
17:33:00 <nswill> I only have one call to takeMVar (this is a short piece of test code). If there is only one call is it still possible for me to be doing something odd that would cause the runtime system to evaluate takeMVar twice?
17:33:57 <xplat> < mzero> They should have made the AND KIDS be a combining mark   <-- yes, totally, i need this so i can add a SNOWMAN AND KIDS operator to go with my SNOWMAN operator
17:34:32 <tolkad> nswill: maybe the thread with takeMVar in it is being forked twice
17:34:53 <shachaf> xplat is reading unusually
17:35:25 <tolkad> nswill: maybe you're using some rogue Monad instance with a monad transformer on top of IO
17:35:34 <nswill> Oh wait, I tried putting a print before the takeMVar and it doesn't even execute when I am assuming it is supposed to. That must mean this is actually something related to not properly forcing evaluation I suppose?
17:36:03 <kmc> nswill, do you mean "execute" rather than "evaluate"?
17:36:13 <kmc> in general it's hard to care how many times an IO action is evaluated
17:36:14 <nswill> I probably mean evaluate
17:36:31 <kmc> oh then, why do you care?
17:36:46 <tolkad> nswill: you mean execute
17:37:08 <kmc> forcing evaluation won't cause IO to occur
17:37:08 <tolkad> nswill: evaluationis building the "IO a" thunk
17:37:14 <tolkad> evaluation
17:37:18 <nswill> Oh ok
17:37:23 <tolkad> nswill: execution is actually running it
17:37:27 <kmc> (except with some libraries which break the rules)
17:37:38 <kmc> (unfortunately including Prelude's "lazy IO")
17:37:52 <tolkad> kmc: like Debug.Trace?
17:37:59 <kmc> sure
17:38:18 <tolkad> the evil Debug.Trace destroying purity
17:38:25 <kmc> @quote oasis
17:38:25 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
17:38:26 <hpc> @quote oasis
17:38:26 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
17:38:27 <hpc> damn
17:38:29 <kmc> damn
17:38:33 <hpc> :D
17:38:40 <Eduard_Munteanu> OTOH, I suppose if execution was tied to evaluation, that would've been perfectly sane, no?
17:39:15 <hpc> Eduard_Munteanu: only if you like nondeterministic behavior ;)
17:39:18 <kmc> it'd be hard to secretly be using a monad transformer here because takeMVar is not polymorphic over MonadIO
17:39:32 <nswill> After sprinkling a few prints it seems like my forkIO execution is being deferred
17:39:41 <hpc> kmc: it's not hard to liftIO it
17:39:52 <Eduard_Munteanu> Hrm, I suppose it can't be fully determined by evaluation, since no evaluation happens without execution either.
17:39:53 <kmc> hpc, true but you'd know you were doing so
17:39:54 <tolkad> nswill: that shouldn't be possible without using System.Unsafe.IO.*
17:39:59 <Eduard_Munteanu> IO drives everything.
17:40:02 <kmc> nswill, you have no guarantee about when the fork'd thread will start up
17:40:06 <tolkad> System.IO.Unsafe.*
17:40:18 <kmc> how can you tell whether a forkIO is being deferred
17:40:35 <tolkad> tabbed between windows too fast :P
17:40:47 <nswill> Well, deferred from my expectations, obviously those expectations are flawed
17:40:55 <kmc> what do you expect?
17:40:58 <hpc> tolkad: you also imported the wrong module, i hope
17:41:12 <kmc> also did you hpaste your code? i may have missed it
17:41:21 <nswill> I expected it to descend into my forked thread and then block and wait for me to write to my MVar immediately
17:41:27 <hpc> oh, or misinterpret the conversation <.<
17:41:30 <hpc> i can do that too
17:41:37 <tolkad> and then my #haskell log file was so long it crashed my irc client
17:42:29 <kmc> nswill, there's no guarantee about the relative execution rate of the forked thread vs. the IO action that forked it
17:42:34 <kmc> they are true preemptive threads
17:42:37 * hackagebot hosc 0.9 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.9 (RohanDrape)
17:42:45 <kmc> (though GHC's threads are much lighter than OS threads)
17:42:49 <tolkad> nswill: try compiling with -threaded
17:43:13 <tolkad> nswill: worth a try even though I can't think of anyway it would help
17:43:28 <nswill> I tried that and it didn't help. From what I'm hearing from you guys I'm thinking that I need to be more explicit about something in my code, I'm not sure what though
17:43:29 <justin-kp> with Data.Binary, what exactly happens if you call decode with bogus data?
17:43:40 <tolkad> nswill: why not show us your code
17:43:48 <tolkad> justin-kp: exception thrown
17:43:57 <tolkad> justin-kp: if you don't like that, use cereal
17:44:17 <justin-kp> cereal?
17:44:37 <justin-kp> looking it up now
17:44:37 * hackagebot hsc3 0.9 - Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-0.9 (RohanDrape)
17:45:16 <nswill> http://hpaste.org/44609/haskell_and_cocoa
17:45:43 <hpaste> WilliamTalmadge pasted "Haskell and Cocoa"  http://hpaste.org/44609
17:45:59 <nswill> A little background on this, I'm experimenting with using haskell in xcode cocoa projects
17:46:35 <justin-kp> tolkad: i see, so Data.Binary uses laziness, so it can't return errors in the return value
17:46:40 <justin-kp> it has to just throw them
17:46:42 <nswill> This is my first foray into the FFI and haskell threads. This works fine except that I have to push the button in my cocoa app that writes to the MVar twice, but, only the first time
17:47:06 <kmc> why does standbyThenDraw fork itself?
17:47:11 <kmc> only to return?
17:47:24 <kmc> why not a simple loop
17:48:48 <nswill> It was the first thing I tried and it worked for subsequent calls. Just not the very first call. My cocoa app calls "setMVar" and passes it a StablePtr to the MVar and a value to write to it. I have to call setMVar twice and then my standby thread finally draws the circle into my NSView
17:49:11 <kmc> i think you should use a simple loop
17:50:23 <kmc> nswill, also, is your "main" written in Haskell or something else?
17:50:29 <nswill> The cocoa app gets the StablePtr by calling startStandbyThread which in turn invokes sendMVar that passes the pointer to the cocoa thread where it is stored locally
17:50:39 <tolkad> justin-kp: yes
17:50:50 <nswill> The cocoa runtime is the "host" runtime so there's no main
17:50:56 <tolkad> justin-kp: this is useful if you are using lazy io
17:51:02 <kmc> nswill, so, "something else"
17:51:12 <kmc> nswill, did you do the proper song-and-dance to initialize the GHC runtime system?
17:51:20 <tolkad> justin-kp: however, this is essential just programmer laziness. it is completely possible to write something just as fast using cereal
17:51:21 <nswill> Yeah
17:51:25 <tolkad> essentially*
17:51:33 <kmc> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#using-own-main
17:51:35 <kmc> ok
17:51:36 <justin-kp> tolkad: yeah, makes sense... i am not a fan of lazy io though, cereal looks nice
17:52:29 <nswill> I initialized the runtime, resolved all the linking issues. Everything works except for having to push my "write to mvar" button twice to get it to draw a circle. I'll try the loop though
17:53:00 <kmc> btw, Chan might be more appropriate than MVar here
17:53:16 <justin-kp> tolkad: thanks for info :)
17:53:36 <tolkad> justin-kp: np
17:53:48 <quotemstr> Ow, my head.  Seriously dealing with monads for the first time.  Is there an introduction better than the Wikipedia page?
17:53:49 <nswill> You are probably right, I just don't like to let little things like this slip because I figured if I figured out why my program is behaving this way it would give me some better insight into the haskell runtime
17:53:57 <kmc> quotemstr, why do you want to learn monads?
17:54:07 <kmc> nswill, that's probably true
17:54:15 <quotemstr> kmc: They're apparently very useful in parser combinators.
17:54:20 <kmc> but we can't say for sure how deep the rabbit hole goes
17:54:24 <kmc> quotemstr, that's a good reason
17:54:38 <tolkad> quotemstr: monads are quite simple. they are just monoids in the category of endofunctors
17:54:58 <kmc> quotemstr, the pragmatic answer is that a "monad" is any Haskell type for which the operator (>>=) is defined
17:55:16 <kmc> you can become comfortable with a particular such type
17:55:21 <kmc> without understanding what makes them all similar
17:55:41 <kmc> i recommend reading a tutorial about parser combinators, not about monads
17:55:43 <quotemstr> tolkad: That's exactly the problem. All the literature focuses on their abstract mathematical properties, which I think I understand well enough. But when it comes time to operationalize them, I find myself baffled again, thinking, "wait -- why is this necessary? When does the computation actually take place? What exactly is the stored state?"
17:56:10 <tolkad> quotemstr: http://en.wikipedia.org/wiki/Monad_%28functional_programming%29
17:56:12 <tolkad> :P
17:56:31 <quotemstr> kmc: That doesn't help if you want to implement a parser combinators library. :-)
17:56:31 <kmc> quotemstr, monads are never necessary.
17:56:35 <tolkad> quotemstr: the stored state can be anything you want
17:56:47 <kmc> quotemstr, so you're implementing a parser combinator library
17:56:53 * quotemstr is usually more a lisper.
17:56:57 <tolkad> quotemstr: for IO, the stored state in an abstract sense is the entire universe
17:56:59 <kmc> write a function of this type:  bind :: Parser a -> (a -> Parser b) -> Parser b
17:57:11 <kmc> and another:  unit :: a -> Parser a
17:57:29 <kmc> tolkad, quotemstr, IO is a bad example of a monad
17:57:29 <tolkad> quotemstr: for the State monad, the stored state is the "s" in (State s ())
17:57:34 * BMeph wishes someone would explain how these "object" things can sequentialize their messages without tying them together... ;p
17:57:40 <quotemstr> tolkad: So what happens if you have two interleaved IO monads?
17:57:47 <kmc> there is one IO monad
17:57:49 <kmc> its name is IO
17:58:07 <hpc> more specifically, there is IO
17:58:10 <hpc> it happens to be a monad
17:58:12 <quotemstr> But you can have multiple instances of this monad, I thought.
17:58:18 <quotemstr> Since a Monad is a type constructor.
17:58:25 <hpc> quotemstr: no, Monad is a type class
17:58:30 <kmc> for each T there are several different values of type (IO T)
17:58:34 <tolkad> quotemstr: it's easier to think of in terms of two interleaved State monad expressions.
17:58:37 <hpc> @where lyah
17:58:37 <lambdabot> http://www.learnyouahaskell.com/
17:58:43 <quotemstr> hpc: But *a* Monad is a type constructor, right?
17:58:48 <kmc> i repeat: IO is a bad example and a bad place to start learning monads
17:58:50 <kmc> quotemstr, yes
17:59:21 <quotemstr> See, this is why I'm confused. I think I understand what the two fundamental operations do, but trying to imagine how they interact, and how do-notation is derived from them, is still confusing.
17:59:32 <kmc> the do notation is simple
17:59:38 <tolkad> quotemstr: conceptually, think of it as if the entire monad expression is evaluated before being "run". In practice this is not always true
17:59:44 <kmc> do { x <- a; b }   ===>   a >>= (\x -> b)
17:59:47 <quotemstr> kmc: But why "return"? 
18:00:01 <hpc> quotemstr: hysterical raisins
18:00:01 <quotemstr> tolkad: Hrm.
18:00:07 <kmc> you need return because occasionally the RHS of (>>=) is just an ordinary function
18:00:13 <tolkad> quotemstr: I'm speaking of interleaving State monad expressions
18:00:18 <kmc> that is, a function not returning an action
18:00:32 <quotemstr> hpc: No, I mean, why is it there? Is it because, without return, the result of a do-expression would be a function and not the intended value?
18:00:48 <kmc> quotemstr, it is not required to use "return"
18:00:49 <hpc> quotemstr: "hysterical raisins" == "historical reasons"
18:00:57 <hpc> monads aren't applicative
18:01:02 <hpc> at least, not in haskell
18:01:08 <quotemstr> Ah, I thought you were saying it's because of historical reasons that it's *called* return.
18:01:10 <kmc> if you're doing it right, many "do" blocks won't contain "return"
18:01:17 <hpc> that too
18:01:45 <kmc> quotemstr, Monad's method "return" should be replaced by Applicative's method "pure"
18:01:48 <hpc> applicative was applied to haskell after monad, and so monad still doesn't imply applicative
18:01:51 <kmc> that is the historical artifact
18:02:00 <hpc> return is an unfortunate name, which somehow stuck
18:02:09 <quotemstr> hpc: They're not? I thought you applied one using >>= to yield a function.
18:02:14 <hpc> dunno the story behind that psychological accident
18:02:28 <quotemstr> Hrm.
18:02:30 <tolkad> quotemstr: « f :: Monad m => m Int; f = do { x <- return 10; return x } » <--- valid haskell code
18:02:30 * shachaf doesn't like the name "pure".
18:02:48 <kmc> quotemstr, did you read Typeclassopedia
18:02:51 <hpc> shachaf: it is a right sight better than return, tbh
18:03:00 * BMeph believes that 'return' is a deliberate pun, made to sucker OO programmers in...before the sledge whacks them in the back of the skull.
18:03:05 <quotemstr> kmc: I will.
18:03:10 <hpc> BMeph: :D
18:03:12 <kmc> okay anyway
18:03:17 <kmc> return vs. pure isn't very relevant
18:03:29 <tolkad> quotemstr: desugars to « f :: Monad m => m Int; f = (return 10) >>= (\x -> return x) } »
18:03:31 * hpc hates how these discussions always crop up right before he goes to sleep :/
18:03:47 * hpc away!
18:03:55 <kmc> quotemstr, anyway, you asked "what does return do" and also "how does it interact with (>>=)"
18:03:58 <shachaf> hpc: "return" vs. "pure" is the kind of discussion you can afford to miss.
18:04:15 <kmc> quotemstr, the answer to the latter is called the "monad laws"
18:04:15 <tolkad> BMeph: return was one of the easier concepts in haskell to learn, coming from OOP
18:04:21 <kmc> and you can find a list online i'm sure
18:04:28 <kmc> but i prefer an alternative formulation
18:04:32 <kmc> in terms of (>=>) instead of (>>=)
18:04:35 <kmc> @src (>=>)
18:04:35 <lambdabot> Source not found. Just try something else.
18:04:38 <kmc> damn one sec
18:04:46 <tolkad> BMeph: the hardest for me was understanding that "forall" quantified types were not existentially quantified
18:04:53 <BMeph> hpc: You should move to the West Coast (of Scotland! ;)
18:05:03 <kmc> f >=> g = \x -> f x >>= g
18:05:06 <kmc> :t (>=>)
18:05:07 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
18:05:22 <kmc> quotemstr, in those terms the monad laws are simply
18:05:26 <kmc> f >=> return  ≡  f
18:05:30 <kmc> return >=> f  ≡  f
18:05:42 <kmc> (f >=> g) >=> h  ≡  f >=> (g >=> h)
18:06:07 <kmc> in other words, (>=>) is an associative operator, and return is its identity
18:06:33 <quotemstr> That is a nifty formulation.
18:06:45 <kmc> if you look at the type of (>=>) you'll see that it's a bit like function composition
18:06:52 <kmc> except the functions look like (A -> M B) rather than (A -> B)
18:07:31 <kmc> and the laws are similar to the laws for (.), with "return" in place of "id"
18:07:39 <tolkad> quotemstr: in general, « do { something; … } » desugars to « something >> (…) », « do { someVar <- something; … } » desugars to « something >>= (\someVar -> …) »
18:08:22 <tolkad> quotemstr: other than that, there is no magic associated with monads. they are just a typeclass
18:08:26 <aavogt> @undo [ x | x <- f x, x <- g x ]
18:08:26 <lambdabot> concatMap (\ x -> concatMap (\ x -> [x]) g x) f x
18:08:50 <tolkad> quotemstr: the monad laws aren't even enforced. they are just rules instances are supposed to follow
18:08:56 <kmc> so we could say that (excuse my informal notation) the triplet ("_ -> _", (.), id) is similar to the triplet ("_ -> M _", (>=>), return)
18:09:32 <b52> hope someone could help me http://hpaste.org/44610/steam_master_server_query
18:09:37 <hpaste> b52 pasted "steam master server query"  http://hpaste.org/44610
18:10:06 <quotemstr> kmc: Thanks; I figured on the non-enforceability part. The idea reminds me of the informal "concepts" in C++ metaprogramming.
18:10:16 <BMeph> b52: My helpful statement is: You're doing it wrong. ;p
18:10:17 <kmc> *nod* type class laws are a lot like that
18:10:24 <b52> :D
18:10:32 <b52> well, i do know what :D
18:10:34 <b52> *that
18:11:14 <tolkad> b52: for line 24, you can import System.IO.Unsafe and use unsafePerformIO
18:11:45 <tolkad> kidding that's a terrible idea
18:11:55 <kmc> funny joke
18:11:57 <quotemstr> Indeed, someone appears to have implemented Monads in template metaprogramming.
18:12:05 <kmc> i'm not surprised
18:12:08 <kmc> but there isn't much to implement
18:12:15 <kmc> it's just an API shared by many unrelated types
18:12:17 <b52> well, what should i do?
18:12:20 <kmc> and a small API at that
18:12:26 <aavogt> the mtl isn't that small though
18:12:45 <tolkad> b52: fix it so it typechecks? you can't get something out of IO without using the >>= function or its equivalent in a do-block
18:13:07 <kmc> you can't get something out of IO at all.  you put the stuff that needs to use it into IO.
18:13:30 <aavogt> drop the return in front of the if, but put it on the response
18:14:18 <aavogt> also drop the return on 17
18:14:40 <tolkad> monads use continuation style passing?
18:14:54 <tolkad> or continuation-passing style?
18:14:57 <kmc> sort of
18:15:03 <tolkad> or perhaps stylistic continuation passing
18:15:07 <kmc> you could call the right hand argument of (>>=) a continuation
18:15:12 <kmc> and i probably wouldn't yell at you
18:15:37 <btutt> remember return lifts a pure value into the monad, so return expects its parameter to be Maybe String. But your then expression gives it IO Maybe String
18:15:42 <tolkad> so the Cont monad captures the essence of what functional programming is all about?
18:15:51 <quotemstr> Before I got into the full parser combinator literature, I figured I could just use CPS to encode parser behavior, ending up with something a bit like do-notation.
18:15:52 <kmc> erm
18:16:02 <kmc> i think you're missing a few steps there tolkad
18:16:18 <kmc> quotemstr, that is a sound plan
18:16:34 <aavogt> btutt: the missing parentheses in the type are important
18:16:36 <kmc> you may find it useful to write a function of type Parser a -> (a -> Parser b) -> Parser b
18:16:46 <kmc> at which point you've probably implemented most of the requisite monad instance
18:16:53 <kmc> without knowing it ;)
18:17:25 <kmc> there's a tutorial about uu-parsinglib which is also a walkthrough of how the library was designed and implemented
18:18:37 <aavogt> preflex: seen Cale
18:18:37 <preflex>  Cale was last seen on #haskell 2 hours, 35 minutes and 40 seconds ago, saying: x <- f -< y
18:19:08 <tolkad> x <- f -< y indeed
18:19:40 <kmc> arrows :O
18:19:43 <btutt> aavogt: so they are. thanks
18:19:46 <quotemstr> So if >>= takes a Monad with some underlying value and a function from that value to another Monad, and returns a new Monad, one can think of ">>=" as "unpack and apply" yeS?
18:19:48 <aavogt> -XArr enables pirate extensions
18:19:57 <kmc> quotemstr, a monad is a type constructor
18:20:07 <kmc> >>= takes a "value of monadic type" or a "monadic action"
18:20:08 <quotemstr> And "return" as "pack".
18:20:25 <quotemstr> But how do you unpack a Monadic value, then?
18:20:31 <kmc> quotemstr, "unpack and apply" is pretty close, but do note that there's no rule saying that (M T) has to be in any way a container of T's
18:20:41 <tolkad> quotemstr: "another Monad" <-- no, it has to be the same monad type
18:20:44 <quotemstr> (??? (SomeMonad A)) == A ?
18:20:46 <kmc> Maybe and [] are containers
18:20:52 <tolkad> quotemstr: it can have a different parameter though
18:20:56 <tolkad> quotemstr: the type that is
18:21:02 <kmc> (State s) is not a container
18:21:13 <kmc> sometimes the monadic value is more like "instructions on how to make a T at a later time"
18:21:17 <kmc> that's how IO works
18:21:20 <shachaf> data Null a = Null -- My favorite monad.
18:21:24 <kmc> you can't "get the T out of IO T" because there is no T inside it
18:21:30 <kmc> just code that would produce a T by doing IO
18:21:45 <aavogt> and maybe it won't actually produce the value
18:21:46 <kmc> quotemstr, as for how you go (M T -> T), there isn't one specific way
18:21:51 <aavogt> @ty forever
18:21:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
18:21:55 <kmc> it depends on which particular type M
18:22:05 <tolkad> quotemstr: « (x :: m a) >>= (y :: a -> m b) » is ok « (x :: m a) >>= (y :: a -> n b) » is bad and you are a bad person if you write it.
18:22:06 <kmc> examples include "runState" and "maybe"
18:22:27 <kmc> the generic monad interface gives you no way to do (M A -> A)
18:22:31 <tolkad> quotemstr: of course, m still has to have a monad instance
18:22:33 <kmc> but particular types can
18:22:45 <tolkad> quotemstr: so technically I should have a (Monad m) constraint there
18:22:51 <tolkad> quotemstr: but I was being lazy
18:22:53 <kmc> there's a common misconception that "monads are one-way"
18:23:05 <quotemstr> kmc: Ah, I see.
18:23:10 <kmc> this is true of IO, and it's true if you only use the generic monad API
18:23:27 <kmc> but most concrete types you run into, which happen to be instances of Monad, will have some kind of "run" or other inspection function
18:23:38 <kmc> especially parser combinators
18:23:52 <kmc> the big chain of (>>=) is building up a "description" of a parser
18:23:59 <kmc> then you pass that description to an "interpreter" function
18:24:08 <kmc> and get back a function from String to your result type
18:24:35 <tolkad> quotemstr: here's a good example of a simple monad: http://hackage.haskell.org/packages/archive/stm-io-hooks/0.7.1/doc/html/src/Control-Monad-AdvSTM-Def.html#AdvSTM
18:24:58 <kmc> tolkad, why that one?
18:25:13 <tolkad> kmc: because of its simplicity and elegance
18:25:47 <kmc> tolkad, please stop trying to confuse people for your own enjoyment
18:26:07 <Mathnerd314> when does the next Haskell Platform release come out?
18:26:13 <kmc> two days ago
18:26:15 <kmc> ;)
18:26:18 <kmc> i mean, Real Soon Now
18:26:51 <btutt> The thunks are still being demanded
18:27:00 <btutt> Please hold for Garbage Collection
18:27:33 <Mathnerd314> how soon? 2 months soon?
18:27:39 <quotemstr> kmc: Wait -- I thought that >>= *directly* applied a function to a Monadic type's value and yielded another Monadic type.
18:28:03 <quotemstr> kmc: So you'd call the long chain of >>= with the result of 'return input' and use a Monad-specific function to extract the output?
18:28:22 <quotemstr> Where is the extra level of indirection?
18:28:55 <kmc> quotemstr, no, it doesn't directly apply
18:29:02 <kmc> you have (M A) and (A -> M B)
18:29:03 * Mathnerd314 notices that his cabal upgrade happens to be updating containers
18:29:08 <kmc> there's no generic way to fit those things into each other
18:29:11 <kmc> it depends on  the particular type
18:29:22 <kmc> @src Maybe (>>=)
18:29:22 <lambdabot> (Just x) >>= k      = k x
18:29:22 <lambdabot> Nothing  >>= _      = Nothing
18:29:24 <mauke> quotemstr: in M
18:29:40 <kmc> the indirection is that the (>>=) defined within "instance Monad M" is allowed to do whatever it likes
18:29:53 <kmc> it can pattern-match and build the constructors of the type M
18:29:59 <kmc> as in the above example with Maybe
18:31:02 <quotemstr> @src return Maybe
18:31:02 <lambdabot> Source not found. Wrong!  You cheating scum!
18:31:06 <applicative> Mathnerd314: I'm using the new platform on the devil's OS X even as we speak.  There's a 64 bit installer, for what its worth.
18:31:07 <kmc> return = Just
18:31:27 <kmc> > Just 3 >>= \x -> return (x+2)
18:31:28 <lambdabot>   Just 5
18:31:31 <kmc> > Nothing >>= \x -> return (x+2)
18:31:32 <lambdabot>   Nothing
18:31:49 <tolkad> quotemstr: in most, maybe all instances you come across it will directly apply the function. it doesn't have to though
18:32:17 <tolkad> quotemstr: in fact it can completely discard the function, like it does in the Maybe monad when it encounters a Nothing
18:32:32 <tolkad> quotemstr: at which point the type parameter becomes a dummy
18:32:51 <mauke> tolkad: the only monads of that kind I can think of are Identity, Maybe, and []
18:32:54 <Mathnerd314> applicative: from http://code.galois.com/darcs/haskell-platform/download-website/ ?
18:32:57 <mauke> everything else has additional hackery
18:32:59 * kmc suspects a lot of the trouble people have with monads isn't about the specific class but about the sort of polymorphism used
18:33:41 <kmc> like, it's tricky that 'M' is ad-hoc-polymorphic at the same time 'A' is parametrically polymorphic
18:33:48 <kmc> you just don't run into constructor classes in other languages
18:33:52 <tolkad> mauke: the State monad directly applies the function to the value
18:34:00 <quotemstr> kmc: Is there a good Lisp or C++ analogue?
18:34:02 <applicative> Mathnerd314: yes, that's it, I was just looking for it.  I am getting a funny warning from ld, but this is probably due to some idiocy on my part.  Otherwise it seems sound. 
18:34:14 <tolkad> mauke: so does Error
18:34:20 <kmc> quotemstr, not really.  Learning Haskell by analogy to other languages usually doesn't work
18:34:28 <kmc> quotemstr, anyway, what's your current point of confusion?
18:34:41 <mauke> tolkad: State definitely doesn't
18:34:50 <quotemstr> kmc: I was just about type it out. :-)
18:36:11 <quotemstr> So in the parser combiner case, when we apply the Parser monad, we're accumulating a description (e.g., match three of these, or one of that) inside the Monad.
18:36:23 <quotemstr> And we add to this description every time we bind it to a new function.
18:37:07 <quotemstr> And the bound function (the RHS of >>=) can itself bind more state.
18:37:17 <kmc> with you so far
18:37:24 <kmc> except i'm not sure what you mean by "inside the monad" or "bind state"
18:37:36 <quotemstr> Then, when we're done building up this state inside the Monad, it still isn't directly useful because the result is still of type (Parser memble)
18:37:39 <kmc> the value of type (Parser T) *is* the description
18:37:42 <quotemstr> (Parser mumble) even.
18:37:53 <quotemstr> And (Parser mumble) is not applicative.
18:37:56 <tolkad> mauke: (State f) >>= g = State $ \s -> case f s of (a, s') -> case {- direct appliation here -} g a of (State f) -> f s'
18:38:10 <kmc> yes it is -- if it's an instance of Monad, it is (or should be) an instance of Applicative
18:38:15 <tolkad> mauke: (State f) >>= g = State $ \s -> case f s of (a, s') -> case {- direct appliation here -} g a of (State f') -> f' s'
18:38:16 <kmc> or did you mean something else
18:38:21 <quotemstr> So we use some Parser-specific function to transform the (Parser mumble) into a StringT -> Output
18:38:23 <tolkad> whoops, accidentally shadowed a variable
18:38:25 <mauke> tolkad: your "direct application" is in a completely different function
18:38:33 <mauke> namely \s -> ...
18:38:55 <quotemstr> Wait -- I thought Monads *weren't* applicable by themselves.
18:39:12 <kmc> what does "applicable" mean?
18:39:14 <quotemstr> Oh, wait. They are.
18:39:18 <kmc> there is a type class named "Applicative"
18:39:27 <quotemstr> kmc: You can evaluate it against a value and get a value, at least in my intuition.
18:39:28 <kmc> and every instance of Monad is an instance of Applicative, except for historical reasons
18:39:33 <tolkad> mauke: well the instance is still kind of doing it in some kind of conceptual, non-sequitur sense that makes sense to me
18:39:35 <kmc> that's not what the class Applicative means
18:39:39 <kmc> not precisely
18:39:56 <kmc> in this case what Applicative gives you is:   Parser (S -> T) -> Parser S -> Parser T
18:39:57 <tolkad> mauke: anyway I stand corrected :P
18:40:01 <kmc> note that the result is still a Parser
18:40:23 <kmc> to "run" your parser, you don't use some method of a general class like Monad or Applicative
18:40:31 <kmc> you use some totally parser-specific "interpreter" function
18:40:43 <kmc> which knows how to take apart that description you built up
18:40:46 <kmc> and turn it into a Haskell function
18:40:51 <quotemstr> kmc: Ah, okay, that's what I thought.
18:41:06 <kmc> (it so happens that oftentimes the description *is* a function, and the "interpreter" just unwraps a type constructor, but that's a detail.)
18:41:11 <quotemstr> But the interpreter function sounds more like a compiler to me --- it returns a function that can then be evaluated against your real input.
18:41:16 <kmc> sure
18:41:22 <kmc> a compiler is a curried interpreter
18:41:45 <kmc> curry :: ((Code, Input) -> Output) -> (Code -> (Input -> Output))
18:41:53 <tolkad> quotemstr: it doesn't have to be. for example, the Put monad from Data.Binary
18:41:57 <kmc> this is one of the Futamura projections
18:42:03 <kmc> http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
18:42:48 <quotemstr> So I guses what I
18:43:15 <quotemstr> m still wondering is what operations are available on a (Parser T).
18:43:27 <quotemstr> >>=, yes. someParserSpecificInterpreter, yes.
18:43:27 <kmc> well, somewhere you defined it
18:43:44 <kmc> data Parser a = Frobnitz (Int -> Char) | Blarg Bool | Tuba (String -> IO Bool)
18:43:47 <quotemstr> But it's also applicable, you say, and I'm not sure what that means in this case.
18:43:57 <kmc> now you can invent new functions which pattern match that stuff
18:44:09 <kmc> in a totally concrete way, which has nothing to do with monads
18:44:23 <kmc> but then users of that library can use that stuff with (>>=)
18:44:29 <tolkad> quotemstr: Monad is just a typeclass, like any other typeclass. the only special thing about Monads is their special syntatic sugar and the unenforced laws they are supposed to follow
18:44:43 <kmc> "applicable" isn't a word in Haskell
18:44:52 <kmc> if you want to understand how Monad and Applicative relate, you should read Typeclassopedia
18:45:02 <quotemstr> Err, Applicative.
18:45:17 <kmc> remember how i said if you wrote Parser a -> (a -> Parser b) -> Parser b
18:45:22 <kmc> then you would have probably accidentally implemented Monad?
18:45:34 <kmc> if you write Parser (a -> b) -> Parser a -> Parser b, then you've accidentally implemented Applicative
18:45:50 <tolkad> quotemstr: do you understand typeclasses in general?
18:45:57 <quotemstr> kmc: Right. Isn't that just the implementation of >>=?
18:45:59 <quotemstr> kmc: Ahhhh.
18:46:17 <kmc> quotemstr, you could also write these functions without knowing or caring about the classes Monad or Applicative
18:46:27 <quotemstr> tolkad: I think so. I was just asking about the Applicative aspect of the discussion.
18:46:48 <kmc> the only reason to care about the classes is to provide a more familiar interface to users, and to reuse the generic code in Control.Monad / Control.Applicative
18:47:06 <kmc> you can write a parser library with a totally custom bindMyParser :: Parser a -> (a -> Parser b) -> Parser b and no type classes whatsoever and it will be basically usable
18:47:24 <dibblego> I do that in haskell-course
18:48:00 <dibblego> https://bitbucket.org/dibblego/haskell-course/src/57a00f8bebda/L03/Parser.hs
18:48:07 <quotemstr> So Maybe is both a Functor and a Monad and an Applicative.
18:48:11 <tolkad> kmc: well, and the other way around, to be able to write new functions that work with any monad instance
18:48:12 <kmc> yes
18:48:35 <kmc> quotemstr, maybe you'd like to try writing (<*>) and (>>=) for Maybe?
18:48:38 <kmc> you already saw (>>=) above
18:48:44 <kmc> (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b
18:49:16 <tolkad> :t (>>=).(>>=).(<*>).
18:49:16 <lambdabot> parse error (possibly incorrect indentation)
18:49:24 <tolkad> :t (>>=).(>>=).(<*>)
18:49:25 <lambdabot> forall b b1 (f :: * -> *) a b2. (Applicative f) => f (a -> b2) -> ((f a -> b1) -> (f b2 -> f a -> b1) -> b) -> (f b2 -> f a -> b1) -> b
18:49:30 <tolkad> ah there we go
18:49:41 <tolkad> ok that was bad sorry ignore that
18:51:27 <kniu_> @src split
18:51:27 <lambdabot> Source not found. Where did you learn to type?
18:51:34 <augur> hmm
18:52:24 <weirdo> @pl (\x y -> x * 10 + y)
18:52:25 <lambdabot> (+) . (10 *)
18:52:41 <tolkad> kniu_: http://hackage.haskell.org/packages/archive/text/latest/doc/html/src/Data-Text.html#split
18:53:09 <tolkad> kniu_: there's lots of different splits though: http://www.haskell.org/hoogle/?hoogle=split
18:53:46 <tolkad> kniu_: the System.Random split doesn't have a single source because it's part of the RandomGen typeclass
18:58:17 <ArchGT> kmels__: ?
18:59:19 <co_dh> every monad is a functor 
19:00:04 <BMeph> Every Monad is great! ;)
19:00:14 <kmc> instance Functor M where { fmap = liftM }
19:00:17 <quotemstr> Every Monad is above average? :-)
19:00:29 <kmc> instance Applicative M where { pure = return; (<*>) = ap }
19:00:30 <kmc> :t ap
19:00:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:00:33 <kmc> :t liftM2 ($)
19:00:34 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
19:01:01 <tolkad> every monad is sacred
19:01:06 <co_dh> :t Every
19:01:07 <lambdabot> Not in scope: data constructor `Every'
19:01:12 <BMeph> every monad is good... ;)
19:01:54 * BMeph points at tolkad, and says, "I am an eyewitness to what you committed in that location."
19:02:39 <tolkad> BMeph: huh?
19:02:59 <tolkad> BMeph: I have the feeling I have inadvertantly triggered some pop culture reference
19:03:35 <kmc> see also: internet
19:04:36 <BMeph> tolkad: You have. ;)
19:06:16 * BMeph hums: "Every monad is needed, in your neighborhood!" :)
19:07:01 * applicative is pleased that he's no more lost than tolkad
19:09:53 <applicative> > (Just even <*> Just 2 , Just even <*> Nothing, Just (+) <*> Just 3 <*> Just 5, Just (+) <*> Just 3 <*> Nothing)
19:09:53 <lambdabot>   (Just True,Nothing,Just 8,Nothing)
19:13:04 <applicative> > ZipList [(+), (^)] <*> ZipList [2,10] <*> ZipList [2, 10]
19:13:05 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
19:13:05 <lambdabot>    arising ...
19:13:29 <applicative> > getZipList $  ZipList [(+), (^)] <*> ZipList [2,10] <*> ZipList [2, 10]
19:13:30 <aavogt> you need the getZipList apparently
19:13:30 <lambdabot>   [4,10000000000]
19:13:42 <applicative> funny there's no show instance
19:14:53 <kmc> anyone here thought about writing a decompiler for GHC Haskell?
19:15:08 <applicative> what's a decompiler
19:15:18 <tolkad> applicative: bytecode -> code
19:15:20 <kmc> turns a binary into something resembling Haskell source
19:15:26 <kmc> more realistically, something resembling Core
19:15:30 <aavogt> is there GHC haskell worth decompiling?
19:15:45 <applicative> why would we want this, is sounds unusually thankless
19:15:57 <monochrom> every valuable but closed-source program is worth decompiling
19:16:11 <kmc> i'm not aware of any significant Haskell program which is publicly available but not with source
19:16:16 <applicative> I see we can break into Standard Chartered
19:16:34 <kmc> it sounds like a fun project and a good way to learn more about the GHC backend
19:16:45 <monochrom> indeed most decompilers are thankless in public but profitable in private
19:16:45 <kmc> i don't claim it would be useful
19:16:52 <aavogt> doing it backwards
19:17:08 <lpsmith> Has anybody else had trouble with Firefox returning a "XML Parsing Error: undefined entity" when trying to look at the package list on hackage?
19:17:11 <kmc> put sausage in the grinder, turn the crank
19:17:37 <monochrom> there may be some worth in an open-source decompiler to decompile closed-source decompilers
19:17:54 <applicative> has anyone tried to use -fllvm on a mac?  I assume I have to install some recent version
19:18:41 <applicative> maybe Axman6 has used -fllvm on OS X
19:19:25 <joyfulgirl> applicative: In all likelyhood, *someone* has tried it, yes.
19:20:16 <applicative> yes, i was hoping for advice...
19:20:18 <kmc> i like this strategy of yelling at passers-by
19:20:18 <monochrom> on this tangent, there is Richard Bird et al's "invert this function" work. I used this analogy to summarize for a friend what it is about: look at this staple remover (I happened to have one on the desk at the time), by calculation on it I can figure out the stapler.
19:21:05 <applicative> kmc: I knew something about the one I was yelling at, but I grant it was a bit silly
19:21:45 <monochrom> I don't get an xml error from the hackage list. http://hackage.haskell.org/packages/archive/pkg-list.html
19:21:56 <applicative> me neither
19:24:04 <monochrom> I invert the strategy. I yell at someone who has left.
19:24:21 <monochrom> hey ManateeLazyCat do you get an xml error? :)
19:24:21 <quotemstr> Is Nothing a zero for Maybe?
19:24:40 <kmc> zero how?
19:24:47 <quotemstr> A monadic zero.
19:25:05 <monochrom> yes
19:25:07 <kmc> are you talking about the MonadPlus type class?
19:25:41 <b52> how can i convert an Int to PortNumber (Network module)
19:25:46 <quotemstr> I was just going throughthe Wikipedia article again.
19:25:58 <monochrom> fromIntegral converts Int to PortNumber
19:26:14 <kmc> quotemstr, yeah, that section is talking about MonadPlus basically
19:26:20 <kmc> mzero isn't defined for all monads
19:26:21 <kmc> :t mzero
19:26:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
19:26:22 <btutt> @hackage Data.Text
19:26:22 <lambdabot> http://hackage.haskell.org/package/Data.Text
19:26:28 <kmc> and you're right, it equals Nothing for Maybe
19:26:35 <btutt> @hackage text
19:26:36 <lambdabot> http://hackage.haskell.org/package/text
19:26:42 <quotemstr> kmc: Is it useful to have an mzero for a Monad that isn't MonadPlus?
19:26:59 <monochrom> little known secret: if you have a number literal in source code, you don't even need convert. "PortNumber 45" just works.
19:27:13 <djahandarie> quotemstr, it has been proposed to seperate mzero out.
19:27:46 <lpsmith> monochrom, yeah,  I discovered that firefox was returning the same error for every webpage.  We'll see if restarting it fixes it
19:27:58 <kmc> quotemstr, possibly.  i think at one point there was a separate MonadZero class
19:28:13 <monochrom> haha fun
19:29:08 <monochrom> too bad PortNumber doesn't enjoy a Read instance
19:29:14 <dolio> @src filterM
19:29:15 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:29:59 <dolio> @src guard
19:29:59 <lambdabot> guard True  =  return ()
19:30:00 <lambdabot> guard False =  mzero
19:32:01 <dolio> You can generalize filter as: filter p m = m >>= \x -> if p x then return x else mzero, I believe.
19:32:19 <dolio> > let filter p m = m >>= \x -> if p x then return x else mzero in filter even [1..10]
19:32:20 <lambdabot>   [2,4,6,8,10]
19:32:39 <dolio> Which requires only the zero, not addition.
19:34:09 <djahandarie> Oh, that's nifty
19:44:56 <augur> hrmph
19:45:13 <augur> i cant figure out the combinator-based mutual recursion definition of even and odd. anyone know off hand?
19:45:43 <monochrom> combinator-based? using fix?
19:47:30 <monochrom> eh? why do you even need recursion? even n = n `mod` 2 == 0 etc
19:48:40 <kmc> :t fix $ \(even, odd) -> ((n == 0) || (odd (n-1)), even (n-1))
19:48:41 <lambdabot>     Couldn't match expected type `Expr -> t'
19:48:41 <lambdabot>            against inferred type `Bool'
19:48:41 <lambdabot>       Expected type: (Expr -> t, Expr -> Bool)
19:48:49 <kmc> :t fix $ \(even, odd) n -> ((n == 0) || (odd (n-1)), even (n-1))
19:48:50 <lambdabot>     Couldn't match expected type `t1 -> t'
19:48:50 <lambdabot>            against inferred type `(a, b)'
19:48:50 <lambdabot>     In the pattern: (even, odd)
19:48:53 <kmc> whatever
19:49:14 <monochrom> do you really want to use this slow algorithm?
19:50:57 <ivanm> I'm giving an introductory talk on what FP is on thursday to a programming group; is anyone willing to check my slides to make sure I didn't stuff anything up?
19:51:03 <monochrom> fix $ \ ~(even,odd) -> ( (\n -> n==0 || odd (n-1)), (\n -> n/=0 && even (n-1)) )
19:51:43 <applicative> ivanm: sure, maybe i'm clueless enough.
19:52:12 <hpaste> ivanm pasted "talk on FP"  http://hpaste.org/44612
19:52:24 <ivanm> ooohhh, hpastebot is back!
19:52:38 <augur> > (fix $ \ ~(even,odd) -> ( (\n -> n==0 || odd (n-1)), (\n -> n/=0 && even (n-1)))) 4
19:52:39 <lambdabot>   Couldn't match expected type `t1 -> t'
19:52:39 <lambdabot>         against inferred type `(a ->...
19:52:46 <hpaste> applicative pasted "pascal's ziplist"  http://hpaste.org/44613
19:52:47 <ivanm> applicative: ^^ that's it in markdown syntax; each new "# Foo" starts a new slide
19:53:10 * ivanm really needs to go resurrect his c.h.o account so that he can put things like this there rather than hpaste
19:54:45 <monochrom> > fst (fix $ \ ~(even,odd) -> ( (\n -> n==0 || odd (n-1)), (\n -> n/=0 && even (n-1)))) 4
19:54:45 <lambdabot>   True
19:54:49 <monochrom> > snd (fix $ \ ~(even,odd) -> ( (\n -> n==0 || odd (n-1)), (\n -> n/=0 && even (n-1)))) 4
19:54:50 <lambdabot>   False
19:54:55 <monochrom> that's how to use it
19:55:29 <kniu_> I find myself writing horribly ugly code.
19:55:41 <kniu_> Is there a pretty printer for Haskell?
19:55:52 <ivanm> kniu: as in to reformat it?
19:56:06 <ivanm> you could roundtrip via haskell-src-exts...
19:56:35 <kniu_> That seems complicated.
19:56:46 <ivanm> then write better code to begin with! :p
19:59:23 <augur> monochrom: aha
19:59:27 <augur> ok lemme see
20:01:10 <btutt> knlu_: hlint gives you style hints, but not formatting hints
20:01:47 <confound> ivanm: if you're going to list a not-really-fp-but-some-parts dynamic language, any of ruby/js/perl would make more sense than python
20:01:57 <applicative> it could be good though, depends what knlu_ things is ugly
20:02:11 <ivanm> confound: most of the people that will be there use python
20:02:12 * hackagebot monad-memo 0.1.0 - Memoization monad transformer  http://hackage.haskell.org/package/monad-memo-0.1.0 (EduardSergeev)
20:02:31 <ivanm> and the whole "let's remove FP stuff" for python makes that more obvious :p
20:02:47 <applicative> the fp ness of javascript should be emphasized everywhere
20:03:20 <kniu_> btutt, I write my code in such inscrutable ways that hlint gives me no suggestions.
20:03:31 <applicative> "Referential transparency allows the compiler to be more aggressive with its optimisations." Doesn't it also help composability?
20:03:31 <btutt> Heh
20:03:54 <dibblego> python does go quite well out of its way to violate the FP thesis
20:04:36 <ivanm> applicative: don't I already mention that?
20:04:45 <hpaste> monochrom pasted "from mutual recursion to fix"  http://hpaste.org/44614
20:04:49 <btutt> I'm not a big JavaScript fan. Ugh.
20:07:37 <hpaste> WilliamTalmadge pasted "Haskell/Cocoa #2"  http://hpaste.org/44615
20:07:39 <nswill> I don't know if anyone is around from earlier that remembers my haskell/cocoa question. Well I fixed my problem, but I don't understand why it works
20:07:53 <nswill> There's my paste, it's the very last line, a yield statement
20:09:29 <monochrom> before you added "yield", did you compile with "-threaded"? (actually link-time option)
20:09:42 <nswill> Yes
20:09:48 <monochrom> then I don't know why.
20:10:28 <nswill> My original problem was that setMVar had to be called twice before drawCircle would be called, but all subsequent calls to setMVar only required a single call (my intention)
20:11:49 <applicative> ivanm, it seems good.  Maybe too much information per slide -- and thus too much on the whole. 
20:12:03 <monochrom> that is even stranger :)
20:12:03 <ivanm> applicative: *nod*
20:12:27 <ivanm> I was thinking of cutting back, but then the slides look too empty...
20:12:28 <applicative> ivanm, it seems there is a tension between the special interest of Haskell and the interest in fp in general. 
20:12:47 <ivanm> yeah
20:13:07 <ivanm> but most of the stuff we talk about as "advantages" are actually advantages of Haskell
20:13:10 <ivanm> e.g. types
20:13:28 <applicative> i did pandoc -r html -w slidy http://hpaste.org/raw/44612/talk_on_fp , by the way ;)
20:13:36 <ivanm> heh, I'm using s5 :p
20:13:46 * ivanm wonders what the slidy version looks like
20:13:49 <applicative> there were a few issues...
20:13:51 <applicative> just a sec
20:18:50 <ivanm> hmmm.... how do I get the header in slidy like what the sample one at w3.org/Talks/Tools/Slidy2/ ?
20:19:58 <ivanm> oh, pandoc can't support that
20:22:09 <ksf> ivanm, jekyll
20:22:21 <ivanm> ksf: hmmm?
20:22:39 <ksf> pandoc only supports conversion
20:22:45 <ksf> ...not actual layouting.
20:23:04 <nswill> I liked that little quote "Haskell is so strict about type safety that randomly generated
20:23:04 <nswill>           snippets of code that successfully typecheck are likely to do
20:23:05 <nswill>           something useful, even if you've no idea what that useful thing
20:23:05 <nswill>           is." Never heard that before but I like it
20:23:08 <ksf> whereas with jakyll you can slice and dice your data into templates as you wish.
20:23:09 <ivanm> yeah, I wrote my slides in markdown
20:23:15 <ivanm> @quote typecheck
20:23:15 <lambdabot> mjrosenb says: <3 #haskell; "why doesn't this program typecheck?" ;  5 hours of category theory later, op left 4 hours ago
20:23:23 <ivanm> @quote typecheck
20:23:23 <lambdabot> mjrosenb says: <3 #haskell; "why doesn't this program typecheck?" ;  5 hours of category theory later, op left 4 hours ago
20:23:33 <ivanm> OK, pretty sure some variant of that quote is in here
20:23:45 <nswill> Yeah, i got it from your slides
20:23:47 <nswill> :P
20:24:09 <monochrom> @quote successfully.typecheck
20:24:09 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
20:24:10 <lambdabot> thing is.
20:24:18 <ksf> ivanm, e.g. the haskell alphabet was done with jekyll
20:24:41 <ivanm> nswill: yeah, I guessed that ;)
20:24:45 <augur> hmm
20:24:47 <gwern> ksf: jekyll? not hakyll?
20:24:49 <gwern> TRAITOR
20:25:04 <ksf> yeah, that's what I meant.
20:25:14 <nswill> Just made me think of those genetic algorithms that randomly mutate code. If you were to do it using haskell as the base language to mutate, then when the genetic algorithm creates some kind of useful AI that solves a task it would be possible to actually reverse engineer its semantics
20:25:15 <monochrom> dr. jekyll and mr. hakyll
20:25:57 <gwern> nswill: iirc there was a japanese guy doing typecheking AST mutations
20:26:01 <nswill> As opposed to something like a neural network where you end up with a black box that's impossible to reason about or predict its behavior
20:26:14 <monochrom> it may randomly discover a function of type ReadWorld# -> Int
20:26:30 <nswill> :O
20:26:31 <ksf> nswill, you're underestimating the inginuity of evolution. and it's tendency to abuse bugs for great benefit.
20:26:49 <ivanm> ksf: how does one use jekyll to generate slides?
20:27:14 <ivanm> or even hakyll?
20:27:22 <ksf> ivanm, I'd say mostly like a blog.
20:27:29 <ivanm> yeah, forget that then
20:28:33 <applicative> ivanm, http://www.cis.upenn.edu/~byorgey/haskell-alphabet/ is hakyll slides, but with home-made css
20:28:58 <ksf> ivanm, https://github.com/jaspervdj/hakyll/tree/master/examples/simpleblog
20:29:17 <ivanm> applicative: yeah, that requires clicking to the next page then
20:29:36 <ksf> well, that'd be a snipped of javascript.
20:30:16 <ivanm> yeah, too much effort
20:30:18 <ksf> though I don't think you wouldn't want to go without any clicking, at all.
20:30:36 <ivanm> I just found the yatil theme for s5 as well, which gives me the one thing I liked about slidy (boxes around the code blocks)
20:30:39 <ksf> <body onclick=location.load(foo)>?
20:30:53 <ivanm> I think I might have to start trimming some slides down though...
20:31:30 * applicative is worried about all these arrows in hakyll-3.  He is already behind posting things for students
20:32:02 <ivanm> lol
20:33:05 <ivanm> but has anyone noticed anything actually _wrong_ with what I've got in them?
20:33:13 <ivanm> (rather than bitching about the tool I'm using :p)
20:33:19 <dibblego> what slides?
20:33:37 <applicative> sorry, my fault for bringing up the file format....
20:34:04 <applicative> oh ksf mentioned the haskell alphabet....
20:34:08 <ivanm> dibblego: http://hpaste.org/raw/44612/talk_on_fp
20:34:19 <ivanm> each "# foo" is a new slide
20:34:34 <ivanm> (for use with pandoc)
20:35:07 <sm> ksf: actually pandoc does have a template you can mess with
20:36:04 <dibblego> ivanm: have you seen Runar Bjarnason's slides/video on a similar topic recently?
20:36:13 <ivanm> nope; link?
20:37:02 <applicative> sm, have you figured out the template syntax?  
20:37:17 <applicative> maybe I have, but only now that i've made a mess of mine...
20:37:22 <dibblego> ivanm: http://www.nescala.org/2011/
20:37:29 <dibblego> there is also one at the Boston users group
20:37:30 <ivanm> ta
20:37:49 <sm> I don't know what it is, I only did the minimum with it
20:38:35 <sm> $insertthing$
20:38:58 <ivanm> hmmmm....
20:39:11 <ivanm> one of the main things I was asked about to cover was industrial usage, etc., which is why I have it
20:39:15 <applicative> yeah, same here.  we could do with an assemblage of illustrative templates.
20:39:55 <dibblego> industrial usage is a furfy
20:40:05 <ivanm> sm: I think the pandoc website now has better documentation on templates
20:40:06 <sm> I guess.. I do like hakyll, figured I'd move to that when this site needs more than a single fixed template
20:40:16 <ivanm> dibblego: yeah, well, I was asked to talk about it *shrug*
20:41:10 <ivanm> I also decided to follow "Why Functional Programming Matters"
20:41:20 <ivanm> but I might try to put some more "separation of concerns" into it
20:41:40 <applicative> i had noticed https://github.com/kjhealy/pandoc-templates, but now I see https://github.com/claes/pandoc-templates too
20:42:04 <ivanm> also, which games developer was it that did the pro-FP talk a few years back?
20:42:13 <sm> tim sweeney
20:43:08 <applicative> ivanm, this guy Bjarnason to go by the first few minutes does manage to finesse the problem of fp in general and pure, typed, referentially transparent functional programming, 
20:43:19 <applicative> by brio
20:43:19 <ivanm> sm: that's the one, ta
20:45:51 <applicative> hm he says "Why FP?" = "Why RT?" not bad
20:45:55 <ivanm> *sigh* and of course firefox decided to suddenly crash and take all my tabs with it...
20:46:20 <ivanm> applicative: I don't think they're exactly the same
20:48:06 <applicative> no, me neither, it was just a mark of his brazeness
20:48:13 <applicative> brazenness?
20:49:07 <ivanm> something like that
20:50:02 <dibblego> Bjarnason=Apocalisp by the way
20:50:28 <ivanm> ahhh
20:52:42 <applicative> he seems to be doing well.  (>>=) is called Compose. Kinda
21:05:47 <dibblego> ivanm: I don't think clojure calls in the same camp as haskell and clean
21:05:50 <dibblego> *falls
21:06:00 <ivanm> well, they claim to be mainly pure
21:06:03 <ivanm> which is why I put it there
21:06:12 <ivanm> (they at least make a pretence at the importance of purity)
21:06:18 <dibblego> so do a lot of languages
21:06:34 <dibblego> if you were to organise it according to claims, it would look very different
21:06:44 <dibblego> it's on the scala level
21:06:46 <ivanm> hmmm...
21:06:59 <ivanm> I havent' actually used clojure, and couldn't find anything saying otherwise
21:07:05 <dolio> It's purity by convention, I think.
21:07:10 <ivanm> *nod*
21:07:13 <dibblego> interesting how you mentioned air traffic systems
21:07:22 <dibblego> I have a funny anecdote
21:07:23 <drhodes> clojure's primary data structures are immutable
21:07:27 <dibblego> it's long though
21:07:28 <ivanm> well, well-typed did that project last year for it
21:07:37 <ivanm> which is why I put it in
21:07:41 <dibblego> purity by convention is scala too
21:07:52 <ivanm> is it? fair enough then
21:07:56 <dibblego> yes
21:08:03 <ivanm> I'll remove clojure from there then
21:08:14 <dibblego> I think it is more useful to rate languages according to how well they allow you to adhere to purity
21:08:26 <ivanm> does scala have/use/advocate STM like haskell and clojure do? (out of curiosity)
21:08:35 <dibblego> no scala is big on the actor model
21:08:40 <ivanm> that's right
21:08:43 <ivanm> are there any other pure FP langs worth mentioning?
21:09:20 <dibblego> doesn't really matter right? it's just to give an idea of what FP is about
21:09:44 <ivanm> yeah
21:09:54 <ddarius> drhodes: So are the MLs'.
21:09:55 <ivanm> but one reason I put clojure there is that I haven't heard of any other langs
21:10:12 <ivanm> ddarius: except for jdh's beloved hash tables? :p
21:11:51 <drhodes> oh! Rust is a new one without mutable state
21:12:30 <dibblego> "And if you use vals [immutable], you can ensure that they *won't* change after initialization. It will require recompiling to change parameters, but that is acceptable in my particular case. My configuration parameters are typically mode switches or default values (e.g., the vertical acceleration of a commercial transport aircraft when it starts an altitude transition)." -- [scala-user] mailing list by an aircraft controller/technici
21:12:30 <dibblego> an coming to grips with understanding the reader monad and why it might be better than using variables
21:12:44 <ivanm> wikipedia says rust _supports_ pure-functional
21:12:50 <ivanm> doesn't say if it _requires_ it
21:13:15 <drhodes> I think it has a `mut` keyword
21:13:25 <ivanm> hmmm...
21:14:22 <dibblego> there is CAL which is by convention at its Java interface
21:15:03 <ivanm> drhodes: looks like mutability here in the example: https://github.com/graydon/rust/wiki/Language-FAQ
21:18:23 * ivanm heads off home
21:29:48 <kmc> what's the best way to number elements of a list from the end?
21:29:54 <kmc> > mapAccumR (\n x -> (n+1,(n,x))) 0 "abcd"
21:29:55 <lambdabot>   (4,[(3,'a'),(2,'b'),(1,'c'),(0,'d')])
21:31:00 <Axman6> looks pretty good to me
21:31:13 <kmc> feels clunky but i can't think of a better way
21:31:35 <Axman6> there's the reverse . zip [0..] . reverse way...
21:31:40 <kmc> :/
21:32:14 <kmc> i hesitate to guess about these things, but i suspect that would be a lot slower asymptotically
21:32:25 <kmc> not that it matters for my application but... ocd ;P
21:32:28 <dolio> Not asymptotically.
21:32:58 <Axman6> only by a constant factor
21:33:11 <kmc> i meant that the constant factor will be noticable on large inputs
21:33:21 <Axman6> possibly
21:33:27 <kmc> shrug
21:33:31 <Axman6> i think mine would have better space usage
21:33:39 <Axman6> possibly making it faster :)
21:33:44 <Axman6> criterion to the rescue!
21:35:23 <kmc> :t foldr1 (liftA2 (.|.))
21:35:24 <lambdabot> forall a (f :: * -> *). (Bits a, Applicative f) => [f a] -> f a
21:42:37 <kmc> this is one of those situations where i'm undecided between writing functions that return functions and functions that return code
21:42:50 <kmc> in a Lisp i'd definitely go for the latter, but TH is such a pain
21:43:49 <kmc> (the situation is, i'm writing an instruction-set decoder, and want to turn strings like "000000111nnn1mmm" into a combination of pattern-matching and field-extraction functions)
21:48:35 <maurer_> kmc: Uh, try hitting up hell.andrew.cmu.edu with your cabal client. It may solve your problem partially
21:49:41 <maurer_> Otherwise, look to using hsffig and friends to define the "-->" operator
21:51:03 <augur> byorgey: depedent product species?
21:51:26 <augur> byorgey: ie, if X = \ls -> case ls of {x} -> {X' x}, _ -> {}
21:51:49 <augur> and U = \x ls -> {x}
21:52:11 <augur> X :> U = \ls -> case ls of {x} -> {(X' x, X' x)}, _ -> {}
21:52:45 <augur> or more generally, X :> (\x -> K{x}) ?
21:54:14 <augur> where X :> Y = \ls -> { (x,y) | x <- X ls, y <- Y x ls } ??
21:55:15 <kmc> maurer_, how can i list the packages at hell.andrew.cmu.edu?
21:55:31 <maurer_> kmc: http://hell.andrew.cmu.edu:3500/
21:55:39 <maurer_> kmc: Alternatively, add it as a package repo to your cabal config
21:55:54 <maurer_> kmc: e.g.
21:55:56 <maurer_> remote-repo: hell:http://hell.andrew.cmu.edu:3500/
21:56:02 <kmc> maurer_, oh, you made UDIS86 bindings too?
21:56:08 <maurer_> Yeah
21:56:11 <kmc> did you see http://hackage.haskell.org/package/hdis86?
21:56:12 <maurer_> UDIS86 is ffipkg generated
21:56:32 <maurer_> Release date after mine was made :P
21:56:32 <augur> byorgey: actually no you'd probably want the dependent product to behave like normal products, where Y gets the complement of what X gets
21:56:33 <augur> so
21:56:36 <maurer_> I just don't consider mine release worthy
21:56:39 <maurer_> So I guess you don't need it
21:56:42 <kmc> maurer_, yes, i uploaded it like yesterday ;)
21:56:46 <maurer_> udis86 is the wrapper around it to make it less sucky
21:57:32 <augur> X :> Y = \ls -> do (lsx, lsy) <- split ls; { (x,y) | x <- X lsx, y <- Y x lsy }
21:57:49 <kmc> cool
21:57:57 <kmc> as it happens i've moved onto another project
21:58:02 <kmc> which is to write a disassembler for 8-bit AVR
21:58:20 <kmc> i found udis86 was pretty pleasant to use through a basic hsc2hs binding
21:58:37 <kmc> i haven't used these high-powered interface generators
21:58:44 <maurer_> Ah. My wrapper is primarily to reduce the number of instructions used.
21:58:56 <maurer_> e.g. it has a Cond meta-instruction to avoid all the condition code subinsns
21:58:57 <maurer_> etc.
21:59:08 <maurer_> See privmsg if you want to see why I was doing that
21:59:13 <kmc> anyway i built a couple layers around that so it looks like a pure haskell function with an AST return value (which looks a lot like yours)
22:00:08 <augur> byorgey: so you could pair elements with lists that start with that element? X :> (\x -> 0' {x} * L) 
22:07:14 <weirdo> what's the function name to get a subsequence of a list by bounding indices?
22:08:04 <shachaf> weirdo: take n . drop m, for correct values of n and m.
22:08:10 <weirdo> thank you
22:08:26 <dibblego> Either is to either as EitherT is to ?
22:11:02 <dibblego> EitherT m a b = m (forall a b x. (a -> x) -> (b -> x) -> x) ?
22:11:18 <btutt> :t EitherT
22:11:18 <lambdabot> Not in scope: data constructor `EitherT'
22:17:37 <BrianHV> can someone help me understand why, after I use <- in a monad, I can use that name in a let clause but not in a where clause? is there a syntactic reason or am I doing something wrong?
22:18:04 <kmc> "where" attaches to a function equation
22:18:10 <kmc> f x = do { .... } where stuff
22:18:26 <maurer_> where only binds to the function parameters
22:18:42 <BrianHV> aaah, fascinating.  thank you both.
22:18:44 <btutt> (and parameters for the where of course)
22:19:00 <kmc> you can do f x = do { ... let { g y = ... where ... }; ... }
22:19:03 <kmc> but that's probably not what you wanted
22:21:48 <BrianHV> hm... that also explains the cryptic errors I was getting when I tried to use more than one where in a function
22:23:10 <quotemstr> Would parser combinators without backtracking be worth it?
22:23:32 <mzero> sure
22:23:57 <btutt> Not all grammars require backtracking. lots don't
22:24:20 <mzero> and parser combinators still make parsing them nicer
22:44:21 <tehgeekmeister> anyone know what the word is on haskell platform 2011?
22:45:07 <mzero> it is in release candidate testing right now
22:45:16 <mzero> finals expected later this week
22:45:40 <tehgeekmeister> whoooooooooo.
22:47:10 <mzero> http://projects.haskell.org/pipermail/haskell-platform/2011-March/001455.html
22:47:24 <mzero> points to the release candidate installers, if you're eager
22:47:43 <mzero> please make sure you pull the latest RC -- since older RCs are in that dir
22:49:18 <mzero> but if you don't want to be a guinea pig -- you should wait until the release annoucement
22:49:23 <mzero> which will be very soon
22:49:27 <nkpart> 64 bit mac installer! anyone know if this means it'll link against 64-bit libs?
22:51:25 <mzero> it should - but note: 64-bit for Mac is considered experimental by the GHC team
22:51:40 <mzero> i've run it on my project and it works fine.. .but YMMV
