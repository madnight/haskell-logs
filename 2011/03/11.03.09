00:12:52 * hackagebot msgpack 0.5.0.0 - A Haskell binding to MessagePack  http://hackage.haskell.org/package/msgpack-0.5.0.0 (HideyukiTanaka)
00:14:52 * hackagebot msgpack-rpc 0.5.0.0 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.5.0.0 (HideyukiTanaka)
00:29:28 <bogner> I miss the simplest functions when not programming in haskell.
00:29:43 <bogner> Python seems to have a takeWhile, but not a take
00:30:37 <nlogax> there's the list slicing syntax
00:32:53 <bogner> Sure, but it doesn't work on iterators
00:33:15 <bogner> And if the iterator might be infinite, casting to a list and slicing is out too
00:39:24 <quicksilver> bogner: islice, I believe.
00:39:59 <bogner> Oh, nice, that looks about right
00:40:13 <bogner> I guess I just can't find the simplest functions, then
00:43:31 <quicksilver> islice is not very pythonic though
00:43:43 <quicksilver> the pythonic way is to write a for loop and explicitly call next() N times ;)
00:44:05 <bogner> Yeah, I did a list comprehension that calls next() N times
00:44:20 <bogner> [s.next() for _ in range(n)]
00:45:12 <quicksilver> a list comprehension with side-effects
00:45:18 <quicksilver> that's hideous, and therefore pythonic
00:45:20 <quicksilver> well done :)
00:46:05 <bogner> hehe
00:48:05 <drs> Hello? I'm having trouble with Haskell, and was told I could ask about it here?
00:48:15 <Cale_> drs: That's right
00:48:31 <drs> oh good :)
00:48:39 <EnglishGent> hi quicksilver :)
00:48:44 <dibblego> drs: sure mate, let's hear it
00:48:54 <quicksilver> morning EnglishGent 
00:49:35 <drs> i'm a bit confused... i'm trying to write a function to check prime numbers, and i'm using "floor (sqrt x)" at one point. this worked in ghci when i tested it, but its giving me errors when i try to load my script into ghci
00:49:52 <drs> this is for a homework thing, if that wasnt obvious :)
00:50:07 <Cale> drs: Perhaps you're missing a fromIntegral
00:50:07 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
00:50:50 <drs> fromIntegral? 
00:50:52 <Cale> drs: sqrt can only be applied to numbers of floating point types
00:51:10 <Cale> drs: If x is an Integer, that doesn't typecheck, and you'll need a fromIntegral to convert
00:51:54 <drs> Cale: yes, it's an integer... and that would explain why it worked in ghci but not in my script. thank you
00:52:19 <gracenotes> hm. this paper says "When a function is
00:52:19 <gracenotes> qualified by a type class, the same type instance must be used
00:52:19 <gracenotes> for all values within that function. Type classes do not allow
00:52:19 <gracenotes> different instances to interoperate.
00:52:25 <gracenotes> damnit, irssi
00:52:51 <gracenotes> anyhow. not positive I agree with the last point. you can just do (Foo a1, Foo a2) => ...
00:54:10 <zygoloid> gracenotes: s/for all values/for all values of the same type/
00:54:19 <zygoloid> i guess that's what the author meant?
00:55:49 <gracenotes> well, the paper is about data abstraction, so I guess it didn't matter to author
00:58:42 <drs> Cale: Thank you very much! I've got it working now :)
00:58:45 <gracenotes> I was pleased to see section or two dedicated to haskell though
01:00:04 <Baughn> Is there a way to link haskell with java code at the moment?
01:01:02 <quicksilver> there are some ways which are bitrotted, Baughn. I don't know how bitrotted.
01:01:16 <Baughn> For the ones I checked, very bitrotted indeed
01:01:31 <quicksilver> it's presumably possibly, but painful, to do java <-> JNI <-> C ABI <-> FFI <-> Haskell
01:01:45 <Baughn> That would have too much overhead for me
01:02:09 <Baughn> I would prefer not to have to use Scala, but oh well. It's superior to Java. :P
01:02:14 <Cale> drs: cool
01:14:57 <sunfun> how should i import QuickCheck in ghci? I tried import Test.QuickCheck but it doesn't work.
01:19:02 <Cale> sunfun: Is QuickCheck installed?
01:19:53 <Cale> sunfun: cabal install QuickCheck
01:22:11 <sunfun> Cale, ok i'll try with cabal, but i have something like ...libraries/QuickCheck/Test/QuickCheck.hs  
01:22:30 <Cale> Er, what?
01:22:44 <Cale> You just have the source code to QuickCheck maybe?
01:22:56 <sunfun> yes 
01:22:59 <Cale> You need to install it for it to be available in ghci.
01:23:32 <sunfun> oh, ok. So i could do that with cabal?
01:24:48 <co_dh> cabal install QuickCheck
01:25:02 <co_dh> sunfun: yep, just do it.
01:25:11 <sunfun> right, thanks
01:54:15 * hackagebot timeplot 0.2.18 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.18 (EugeneKirpichov)
01:54:54 <spirit> i'm working on a package with multiple modules. Main.hs imports module a and module b. both modules have a constant named foo. when i put 'print foo' inside main, i get an 'ambiguous occurrence "foo" error'. how would i go about fixing it? it seems troublesome to have 'foo1' and 'foo2' ... 
01:55:29 <quicksilver> you could use qualification
01:55:34 <quicksilver> and then use a.foo and b.foo
01:56:15 * hackagebot timeplot 0.2.19 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.19 (EugeneKirpichov)
01:57:03 <spirit> how to use qualification?
01:57:14 <spirit> do i need to specify that anywhere?
01:57:54 <mux> http://imgur.com/94t0P
01:57:59 <mux> woops, mispaste
01:58:19 <Veinor> spirit: import qualified a
01:58:32 <Veinor> then instead of foo, you'll get a.foo
01:58:50 <spirit> great!
01:59:16 * hackagebot hmatrix 0.11.0.3 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.11.0.3 (AlbertoRuiz)
02:01:07 <Veinor> note that you can do import qualified Some.Really.Long.Name as S
02:01:18 <Veinor> and refer to S.foo instead of Some.Really.Long.Name.foo
02:02:14 <quicksilver> you don't need to import qualified.
02:02:22 <spirit> :-) even better! has that been a feature for a long time?
02:02:26 <quicksilver> the default arrangement is to get qualifed and unqualified.
02:02:49 <quicksilver> you only need to use the qualified keyword if you *don't* want the unqualified names.
02:03:01 <quicksilver> http://www.haskell.org/haskellwiki/Import
02:03:08 <quicksilver> spirit: since the dawn of haskell :)
02:03:58 <spirit> can i write import Some.Very.Long.Name as S ?
02:04:26 <quicksilver> you can.
02:12:09 <spirit> if module A and module B each had a function fooBar and both exported that function, and Main imported both modules, then I would have to import them qualified?
02:12:46 <quicksilver> no.
02:12:51 <Lemmih> spirit: Only if you plan on using fooBar in Main.
02:12:56 <quicksilver> you merely have to refer to them qualified
02:13:11 <quicksilver> the ambiguous name won't be complained about unless you try to use it.
02:14:29 <spirit> so the qualified import would be to prevent ghc(i) ambiguous-usage-errors from occurring? or why would i want to import qualified?
02:15:11 <hpaste> inetic pasted "Why changing the Data.Binary.Put monad into a transformer creates a memory leak?"  http://hpaste.org/44637
02:15:58 <quicksilver> you might want to import qualified because Main has its *own* function called fooBar
02:16:09 <spirit> ah! :-)
02:16:09 <quicksilver> although I think that takes precedence anyway.
02:16:27 <quicksilver> you might want to import B qualified so that A's fooBar can be referred to simply as foobar
02:28:10 <Lemmih> Did inetic leave?
02:28:41 <spirit> is System.Vacuum.Cairo sometimes a bit buggy? Sometimes it renders stuff even though it says there's a syntax error. there's a demo video on youtube that has those errors too.
02:30:38 <spirit> i found System.Vacuum.Ubigraph to be more stable. would be interested in 2d too though. any ideas?
02:39:45 <jonkri> does anyone know if it's possible to run different enumerators as different threads, generating event for yet another iteratee/thread? i'm using the enumerator package
02:43:34 <Lemmih> jonkri: I don't see why not.
02:57:30 <merijn> Is it possible (and if so, how easy) to cross-compile using GHC?
02:58:02 <Lemmih> merijn: It is not possible, iirc.
02:58:27 <merijn> Hmm, that's a bummer
02:59:36 <jonkri> Lemmih: the code snippets i've seen are joining together functions, iteratees and enumerators, but how would one do this if the functions were executed in different threads?
03:00:32 <merijn> jonkri: Do you mean "how do I communicate results between threads?"?
03:02:53 <jonkri> merijn: i don't know... i don't see using channels and mvars as a solution to this problem. basically what i want to know is how to have different "blocking" enumerator sources in different threads joined together, all providing data to one iteratee
03:03:59 <merijn> How wouldn't channels solve this? Have all threads write to one channel and have the one iteratee read from that channel?
03:04:06 <Lemmih> jonkri: Create an enumerator that uses a Chan as the source, make the other enumerators output to said Chan.
03:10:09 <jonkri> aha ok
03:10:26 <jonkri> thanks :)
03:14:07 <sunfun> installing Cabal i get this error:  Setup: At least the following dependencies are missing: base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2
03:14:19 <sunfun> what does it mean?
03:15:46 <Lemmih> sunfun: What version of base and filepath do you have installed?
03:18:46 <sunfun> Lemmih, i don't know how to check that
03:19:59 <Lemmih> sunfun: ghc-pkg field base version
03:20:12 <Lemmih> sunfun: What version of GHC are you using, btw?
03:20:30 <sunfun> Lemmih, version: 4.3.0.0
03:20:53 <sunfun> Lemmih, i'm using 7.0.1 on a ppc machine
03:22:31 <Lemmih> sunfun: I'd try the Haskell Platform. Much easier than installing everything on your own. http://hackage.haskell.org/platform/
03:23:23 <sunfun> Lemmih, i know but, there's no version for a ppc machine
03:23:29 <sunfun> only intel
03:24:35 <sunfun> i tried to build from source but it is not possibile too
03:26:06 <sunfun> Lemmih, anyway calling ghc-pkg field Cabal version returns version: 1.10.0.0
03:26:13 <sunfun> but i need cabal-install
03:26:55 <sunfun> i've downloaded that tool and there  is an .sh script called bootstrap.sh to run on unix
03:27:49 <Lemmih> sunfun: And it didn't work?
03:27:50 <sunfun> but it downloads and try to install Cabal-1.8.0.2
03:28:09 <sunfun> no it fails when it try to build Cabal-1.8.0.2
03:28:15 <sunfun> that i don't need i thinkk
03:29:19 <Lemmih> sunfun: What version of filepath do you have installed?
03:30:00 <sunfun> Lemmih, version: 1.2.0.0
03:30:20 <Lemmih> sunfun: You need an older version.
03:30:45 <sunfun> but there is not cabal-install for latest version?
03:32:18 <Lemmih> sunfun: There is but then you have to install it yourself. There's no bootstrap script for it.
03:33:19 <Lemmih> sunfun: You can get the newest version of cabal-install and all its dependencies on hackage.
03:34:01 <ManateeLazyCat> dmwit: Yes, please use newest stable version WordPress, thank you very much! :)
03:35:39 <ManateeLazyCat> @tell dmwit Yes, please use newest stable version WordPress, thank you very much! :)
03:35:39 <lambdabot> Consider it noted.
03:35:58 <hpaste> Jorky pasted "Wine problem"  http://hpaste.org/44639
03:36:04 <ManateeLazyCat> @tell juhp Cale help me bring lambdabot to ##manatee , i love it. It's my message bot.
03:36:05 <lambdabot> Consider it noted.
03:36:54 <sunfun> Lemmih, but the latest version i see is abal-install-0.8.2 on the official site
03:37:05 <ion> /root/.wine? Seriously?
03:37:18 <ManateeLazyCat> haskell.org in attacking?
03:37:48 <sunfun> Lemmih, are you talking about the developer trunk?
03:38:30 <Lemmih> sunfun: No, I'm talking about hackage: http://hackage.haskell.org/package/cabal-install
03:38:53 <basvandijk> Prepare to get spammed...
03:39:06 * sipa prepares
03:39:11 <Zao> basvandijk: Prepare to paste instead?
03:39:24 * sipa assumes it will not be basvandijk himself who spams
03:39:39 <sunfun> Lemmih, oh thanks, so there are all sources i need than, i didn't know that, on wiki there was another site
03:39:44 <sunfun> Lemmih, thank you
03:39:56 <Lemmih> sunfun: Installing ghc-6 would be so much easier, btw.
03:40:15 <sunfun> Lemmih, yeah i know that, sigh
03:40:38 * hackagebot regions 0.9 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.9 (BasVanDijk)
03:40:40 * hackagebot regions-mtl 0.3.1.5 - mtl instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-mtl-0.3.1.5 (BasVanDijk)
03:40:42 * hackagebot regions-monadstf 0.3.1.5 - Monads-tf instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadstf-0.3.1.5 (BasVanDijk)
03:40:44 * hackagebot regional-pointers 0.6 - Regional memory pointers  http://hackage.haskell.org/package/regional-pointers-0.6 (BasVanDijk)
03:40:46 * hackagebot safer-file-handles 0.10 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.10 (BasVanDijk)
03:41:34 <ManateeLazyCat> Wow ... 
03:41:42 <ManateeLazyCat> \o/
03:42:04 <sunfun> Lemmih, there is a bootstrap.sh script too, i hope it will work
03:42:39 * hackagebot safer-file-handles-bytestring 0.2 - Extends safer-file-handles with ByteString operations  http://hackage.haskell.org/package/safer-file-handles-bytestring-0.2 (BasVanDijk)
03:42:41 * hackagebot safer-file-handles-text 0.2 - Extends safer-file-handles with Text operations  http://hackage.haskell.org/package/safer-file-handles-text-0.2 (BasVanDijk)
03:42:44 * hackagebot usb 0.8 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.8 (BasVanDijk)
03:42:46 * hackagebot usb-enumerator 0.3 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-enumerator-0.3 (BasVanDijk)
03:42:48 * hackagebot usb-safe 0.12 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.12 (BasVanDijk)
03:43:04 <basvandijk> phew... finished.
03:46:05 <Egbert9e9> @pl 
03:46:05 <lambdabot> (line 1, column 1):
03:46:05 <lambdabot> unexpected end of input
03:46:05 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:46:40 <Egbert9e9> @pll map (\(x,y) -> (y, x)) (encode $ primeFactors n)
03:46:41 <lambdabot> map (uncurry (flip (,))) (encode (primeFactors n))
03:47:11 <Egbert9e9> @pl map (\(x,y) -> (y, x)) (encode $ primeFactors n)
03:47:11 <lambdabot> map (uncurry (flip (,))) (encode (primeFactors n))
03:47:16 <Egbert9e9> woah
03:49:52 <Egbert9e9> what'ds uncurry?
03:50:32 <Zao> @type uncurry
03:50:33 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
03:51:14 * merijn thinks @pl is a dangerous weapon
03:51:14 <Zao> Given a "binary function", it gives you an "unary function" taking a 2-tuple.
03:51:33 <Zao> @type curry
03:51:33 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
03:51:51 <Zao> Curry, unsurprisingly, does the reverse.
03:52:05 <mauke> :t (snd &&& fst)
03:52:06 <lambdabot> forall a c. (a, c) -> (c, a)
03:59:33 <spirit> i just read this: 'Field labels used in one data type must not be re-used in another' -- is it true?
04:00:10 <Egbert9e9> i've never cme across &&&
04:00:28 <Egbert9e9> i'll just go with (\(x,y) -> (y,x)). seems more straight forward
04:00:46 <quicksilver> spirit: not exactly.
04:01:00 <quicksilver> spirit: selector functions - which is what field labels are, among other things - are like any other function.
04:01:10 <quicksilver> spirit: therefore you can't have two with the same name in the same module.
04:01:18 <Egbert9e9> oh, i see what uncurry is doing
04:05:30 <spirit> that makes sense :-)
04:06:23 <merijn> quicksilver: So far, that's been one of my biggest Haskell peeves
04:06:42 <merijn> But on the other hand, it's not like I know of any solution to the problem...
04:07:28 <fryguybob> @type uncurry . flip . curry $ id
04:07:28 <lambdabot> forall a b. (a, b) -> (b, a)
04:09:16 <quicksilver> it's a price worth paying for first-class labels.
04:09:22 <quicksilver> not that record field *are* first-class labels.
04:09:43 <quicksilver> but if I was going to improve the haskell record system it would be towards first class labels - and therefore this particular problem would not be resolved.
04:13:42 <merijn> Anyhoo, I asked before, but didn't get any definite answer how hard is it (if at all possible) to cross-compile haskell from say OSX/FreeBSD to linux/solaris/different hardware architectures
04:14:48 <Eduard_Munteanu> There's no cross-compiling support (at least beyond the difficult bootstrapping process).
04:15:19 <Eduard_Munteanu> Though you could use a VM or some compatibility layer (like Wine, for Windows) to do that.
04:15:33 <Eduard_Munteanu> I've been compiling stuff for Windows from Wine.
04:15:44 <quicksilver> merijn: currently it's entirely impossible.
04:15:52 <quicksilver> merijn: however people are actively working on fixing it.
04:16:03 <quicksilver> don't expect a working cross compiler by christmas though :)
04:16:11 <merijn> I guess I could use a VM, but that is a lot of effort :\
04:16:24 <quicksilver> dankna, who sometimes hangs out here, is putting quite a bit of time into it.
04:17:30 <merijn> I'm fed up with the "default" shells/terminal multiplexing available, so I figured I'd attempt to write my own in Haskell, but if its not possible for me to compile a binary for all platforms I encounter then I'm not sure its worth the effort :\
04:17:31 <Eduard_Munteanu> I wonder if -fvia-c makes it possible once you have a GNU cross-toolchain.
04:18:13 <Eduard_Munteanu> merijn: that's usually a job for the distribution maintainers, at least for less common arches.
04:18:30 <Eduard_Munteanu> I suppose anyone owning a VAX or such could just compile their own ;)
04:19:03 <merijn> Eduard_Munteanu: That's not what I mean, for example we have Solaris/Linux boxes at the university and I do not have access to install GHC there
04:19:55 <merijn> So if I cannot produce binaries for machines *I*  have to work on (I don't care about the rest of the world getting my stuff working), then investing the time in writing my own tools isn't really worth it
04:20:01 <Eduard_Munteanu> Though GHC probably uses arch-specific stuff way before going to C code.
04:20:11 <quicksilver> Eduard_Munteanu: no, -fvia-c does not make it possible.
04:23:56 <Eduard_Munteanu> merijn: use a VM then. Even if you cross-compile, there's no way to test it without some sort of VM or access to the real machine.
04:24:32 <quicksilver> true.
04:24:36 <merijn> Eduard_Munteanu: I guess I'll go for python as a language instead then
04:25:01 <merijn> Because my hopes of managing to get things working on SunOS for sparc with a VM seem slim
04:57:39 <hpaste> inetic pasted "Why changing the Data.Binary.Put monad into a transformer creates a memory leak?"  http://hpaste.org/44641
05:00:55 <hpaste> inetic pasted "Why changing the Data.Binary.Put monad into a transformer creates a memory leak?"  http://hpaste.org/44642
05:01:46 <wires> in GHCi, is there some way to see all "infixl/r" definitions for all currently in scope symbols?
05:02:08 <quicksilver> not that I know of
05:02:12 <quicksilver> that could be a lot of symbols :)
05:02:25 <wires> yes :)
05:03:18 <wires> .. or maybe the other way around, get me all symbols for each level
05:03:24 <wires> but i guess it's not possible
05:03:49 <wires> quicksilver: thanks
05:04:00 <aib> Have I got this straight? The applicative <*> for a function does: For a multi-parameter function, binds the second parameter to a function application of the first parameter, getting rid of the second parameter.
05:06:41 <quicksilver> <*> for functions combines a function (e -> a -> b) with a function (e -> a) to produce a function (e -> b)
05:07:05 <quicksilver> what this function (e -> b) does is, take that environment 'e' and feed it to both, getting out (a -> b) and a, then it applies those two.
05:09:26 <hpc> > f <$> x <*> y $ z :: Expr
05:09:27 <lambdabot>   Couldn't match expected type `a -> a1'
05:09:27 <lambdabot>         against inferred type `Simpl...
05:09:46 <hpc> :t f <$> x <*> y
05:09:46 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
05:09:47 <lambdabot>     In the second argument of `(<$>)', namely `x'
05:09:47 <lambdabot>     In the first argument of `(<*>)', namely `f <$> x'
05:09:52 <hpc> bah
05:10:50 <Kaidelong> hpc: considering that <$> and <*> are methods, that's hardly surprising anyway
05:10:52 <anincog> I'm a bit confused over how where clauses behave with regards to contexts. If I have a context Foo a, and then a where clause, can I refer to the type a in a signature inside the where clause?
05:11:01 <Kaidelong> well perhaps <$> was a function, I forget
05:11:08 <Kaidelong> @src (<$>)
05:11:08 <lambdabot> f <$> a = fmap f a
05:11:12 <Kaidelong> okay
05:11:47 <Saizan> anincog: you need ScopedTypeVariables for things like that
05:12:12 <Kaidelong> > [5] <$> x <*> y
05:12:13 <lambdabot>   Couldn't match expected type `a1 -> a -> b'
05:12:13 <lambdabot>         against inferred type `...
05:12:16 <mercury^> :t pure
05:12:17 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
05:12:34 <Kaidelong> @instances-importing Pointed
05:12:34 <lambdabot> Couldn't find class `Pointed'. Try @instances-importing
05:12:38 <hpc> :t x
05:12:39 <lambdabot> Expr
05:12:42 <hpc> :t f
05:12:43 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
05:12:50 <Kaidelong> :k Expr
05:12:51 <lambdabot> *
05:12:55 <anincog> Saizan: OK. Do I then also need to repeat the context after the where?
05:12:55 <hpc> :t x <$> f <*> g
05:12:56 <aib> quicksilver: I think I'm gonna need more practice, or at least a case where currying makes more sense. Right now I'm trying with e -> a -> b => e a b = show (a,b) , which doesn't really make sense
05:12:56 <lambdabot>     Couldn't match expected type `a1 -> a -> b'
05:12:56 <lambdabot>            against inferred type `Expr'
05:12:56 <lambdabot>     In the first argument of `(<$>)', namely `x'
05:13:02 <hpc> :t f <*> g
05:13:03 <lambdabot> forall (f :: * -> *) a b. (SimpleReflect.FromExpr (f (a -> b)), SimpleReflect.FromExpr (f a), Applicative f) => f b
05:13:07 <hpc> :t f <*> g $ x
05:13:08 <lambdabot>     Ambiguous type variable `a' in the constraints:
05:13:08 <lambdabot>       `SimpleReflect.FromExpr a'
05:13:09 <lambdabot>         arising from a use of `g' at <interactive>:1:6
05:13:10 <Kaidelong> hpc: functors have kinds (* -> *)
05:13:18 <Kaidelong> Expr has kind *
05:13:20 <Saizan> anincog: no
05:13:26 <hpc> Kaidelong: yeah, i noticed :P
05:13:34 <aib> Or maybe it's this Learn You a Haskell tutorial
05:13:43 * hpc is just sucking at lambdabot
05:13:54 <Kaidelong> :t f
05:13:55 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
05:14:00 <Kaidelong> ah I see
05:14:12 <Kaidelong> > f <*> g
05:14:13 <lambdabot>   No instance for (GHC.Show.Show (f b))
05:14:13 <lambdabot>    arising from a use of `M6552235289...
05:14:20 <Kaidelong> > f <*> g $ x
05:14:21 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:14:21 <lambdabot>    `SimpleReflect.FromExpr ...
05:14:32 <Kaidelong> > f <*> g $ 1
05:14:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:14:33 <lambdabot>    `SimpleReflect.FromExpr ...
05:14:36 <hpc> > f <*> g $ x :: Expr
05:14:37 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:14:37 <lambdabot>    `SimpleReflect.FromExpr ...
05:14:52 <Kaidelong> > (f <*> g $ x) y
05:14:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:14:53 <lambdabot>    `SimpleReflect.FromExpr ...
05:15:21 <Kaidelong> > ap f g x y
05:15:21 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:15:22 <lambdabot>    `GHC.Show.Show a'
05:15:22 <lambdabot>      a...
05:15:22 <hpc> so much for that, i suppose
05:15:34 <Kaidelong> > ap f g 0 1
05:15:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:15:35 <lambdabot>    `SimpleReflect.FromExpr ...
05:15:38 <Kaidelong> nope
05:15:48 <Kaidelong> oh
05:15:51 <mercury^> Gah, stop it. Type errors make me cringe.
05:16:00 <Kaidelong> > ap (f . id) (g . id) 0 1
05:16:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:16:01 <lambdabot>    `SimpleReflect.FromExpr ...
05:16:08 <Kaidelong> doesn't help
05:16:09 <hpc> :t 1 2 3 4 5 -- better, mercury^?
05:16:10 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
05:16:18 <hpc> :P
05:16:35 <Kaidelong> typelackoferrors
05:16:49 <hpc> @type error
05:16:50 <lambdabot> forall a. [Char] -> a
05:17:05 <hpc> a type error!
05:20:03 <hpaste> anincog pasted "Scoped type variables"  http://hpaste.org/44643
05:20:26 <anincog> Saizan: But take the case of http://hpaste.org/44643/scoped_type_variables - won't I need a signature for bar?
05:20:41 <Eduard_Munteanu> So much with parametricity there.
05:23:33 <Saizan> anincog: if add a forall a. to foo's signature then you can give the bar :: a -> a annotation
05:24:17 <anincog> Saizan: Aha!
05:24:22 <anincog> Saizan: Thanks
05:24:32 <anincog> I haven't really looked into forall yet. I should
05:26:30 <Saizan> well, here it's mostly used as syntax for signaling to GHC that you indeed want that type variable to have a lexical scope
05:27:13 <anincog> Saizan: Yeah, I understand... I think I've mixed up the various uses of forall before.
05:34:07 <Jaxan> i don't know much about haskell, but wanted to build something. i got the following error: hsc2hs: src/Sys.hsc: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character). Any clues where i can look for a fix?
05:35:48 <basvandijk> Jaxan: did you use special Unicode characters in Sys.hsc?
05:36:24 <Jaxan> i didn't wrote anything of the code (i just downloaded it and i'm trying to compile it).
05:36:33 <Jaxan> but i should look for special characters?
05:38:25 <Jaxan> i do see some weird arrows: →
05:38:52 <basvandijk> That should be it. What is the package by the way?
05:39:04 <Jaxan> geordi
05:39:25 <Jaxan> http://www.xs4all.nl/~weegen/eelis/geordi/
05:39:44 <lunaris> Does anyone know of an alternative to buildExpressionParser (Parsec) that encodes operators which take differently typed arguments?
05:41:21 <basvandijk> Jaxan: one way to solve it is to change the special Unicode characters to normal ASCII. So → becomes ->.
05:43:11 <basvandijk> Jaxan: what version of ghc are you using? Because I just tried adding some special Unicode symbols to one of my .hsc packages and it build fine (I'm using ghc-7.0.2)
05:43:46 <aib> if zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] , then how come zipWith id :: [b -> c] -> [b] -> [c] ?
05:44:32 <Jaxan> ghc6
05:44:41 <Jaxan> 6.12.1
05:45:10 <lunaris> aib: It's like zipWith ($)
05:45:31 <lunaris> aib: You have two lists to `zip' together with some function
05:46:12 <lunaris> aib: Let's say you're producing item z using x (from the first list) and y (from the second list)
05:46:20 <lunaris> aib: If the function you're given is id, you have:
05:46:22 <lunaris> aib: z = id x y
05:46:29 <lunaris> aib: id x == x
05:46:31 <Zao> The term 'zip' bothers me slightly, as it for me implies interlocking.
05:46:36 <basvandijk> Jaxan: try upgrading to ghc-7.0.2
05:46:37 <lunaris> aib: So you have z = x y
05:46:50 <lunaris> aib: So x must be a function that takes a value of type y and gives you back something.
05:46:53 <lunaris> aib: Hence the type.
05:47:11 <basvandijk> Jaxan: or wait for the new Haskell Platform that is soon to be released
05:47:13 <lunaris> Zao: I suppose you're of the school that `zipWith' should be renamed to `broadside' :P
05:47:25 <Jaxan> basvandijk, ghc7 is not in the debian repo, so that will not be easy, i guess
05:47:38 <aib> lunaris: I can see how it works. I just somehow can't get my head around the -> type notation
05:47:47 <fryguybob> @type [($),id]
05:47:48 <lambdabot> forall a b. [(a -> b) -> a -> b]
05:48:04 <lunaris> aib: Well, if x (in our example) is a function
05:48:06 <aib> maybe I have to learn about $ first, eh?
05:48:13 <lunaris> aib: Then the whole list must be a list of functions
05:48:26 <lunaris> aib: So [b -> c] is a list of functions from some type b to some type c.
05:48:46 <lunaris> aib: And the second list provides the `b's (as evidenced in our use of y)
05:48:47 <basvandijk> Jaxan: Just download a binary distro for your platform: http://haskell.org/ghc/download_ghc_7_0_2
05:48:54 <lunaris> aib: Though perhaps I'm just making this worse...
05:49:09 <aib> let me reread :)
05:49:14 <lunaris> K.
05:49:31 <lunaris> It's a pity no-one can answer my Parsec question :/
05:49:37 <basvandijk> Jaxan: unpack it, configure with --prefix=$HOME/ghcs/ghc-7.0.2, make install, and add $HOME/ghcs/ghc-7.0.2/bin to your PATH and you're done
05:49:40 * lunaris delves deeper
05:51:09 <basvandijk> Jaxan: if you remove ghc-7.0.2/bin from you're PATH you're back to your system GHC. I regullry switch between them
05:52:09 <dankna> there are better ways to have multiple GHCs, but they might involve building it yourself, which is of course to be avoided if possible
05:52:20 <lunaris> I've always used GNU stow
05:52:22 <lunaris> Which does the job
05:52:24 <dankna> me too, yes
05:52:27 <dankna> stow is great
05:52:29 <lunaris> xD
05:52:42 <lunaris> I've got 6.10 and 7 sitting next to each other no problems.
05:52:48 <lunaris> Didn't have to build from source either.
05:52:48 <dankna> nodnod
05:53:00 <lunaris> Only downside is no platform (for 7 at least)
05:53:04 <dankna> right
05:53:09 <lunaris> But I just symlink ~/.cabal to an easily managed directory
05:53:10 <lunaris> Or similar.
05:53:18 <lunaris> And fill that up.
05:53:31 <dankna> I personally use --global as my default for cabal-install, but I think I may be the only person who does
05:53:36 <lunaris> I used to do that.
05:53:41 <lunaris> But I move around machines a lot.
05:53:46 <dankna> I edited the install path so the compiler is included in it
05:53:48 <dankna> oh, gotcha
05:53:49 <lunaris> And then I got bitten :)
05:53:49 <lunaris> Nice.
05:55:27 <aib> I think what I don't understand is how id :: a -> a can substitute for a "(a -> b -> c)". Must have to do with currying, surely
05:55:36 <quicksilver> aib: nothing to do with currying, no.
05:55:57 <quicksilver> aib: do you understand that a -> b -> c is really a -> (b -> c) ?
05:56:25 <aib> by partial application?
05:56:44 <quicksilver> erm
05:56:51 <djahandarie> It isn't 'by' anything, that is just how it is.
05:56:51 <quicksilver> well partial application is related
05:56:56 <quicksilver> but this isn't "by" it.
05:56:57 <djahandarie> It is what allows partial application.
05:57:10 <quicksilver> a -> (b -> c) is what a -> b -> c means.
05:57:21 <aib> ah, right.
05:57:23 <quicksilver> a -> b -> c has to mean something.
05:57:32 <quicksilver> but (->) is a binary type constructor
05:57:37 <fryguybob> aib: Think of an a for a -> (b -> c) that makes both sides of the first arrow the same.
05:57:38 <aib> sorry I guess I was thinking ahead. by associativity
05:57:48 <quicksilver> (->) is not associative.
05:57:54 <aib> it's right-associative?
05:58:03 <aib> otherwise a -> b -> c = (a -> b) -> c
05:58:06 <quicksilver> "(a -> b) -> c" and "a -> (b -> c)" are definitely different types.
05:58:17 <quicksilver> so, by an important convention, we associate ->s to the right
05:58:25 <quicksilver> and a -> b -> c therefore means a -> (b -> c)
05:58:44 <aib> yep.
05:58:46 <djahandarie> (While 'associativity' is a property of binary operators that means it doesn't matter where the parens go :))
05:59:17 <quicksilver> aib: do you now see how to match "a -> b -> c" against "a -> a" ?
05:59:28 <aib> so id :: a -> a becomes id :: (b -> c) -> (b -> c) ?
05:59:57 <quicksilver> yup
06:00:12 <quicksilver> and hopefully you can now see what zipWith id means
06:00:37 <aib> I just did. Thank you, everyone
06:00:41 <quicksilver> :)
06:01:28 <aib> incidentally, I just realized  id :: (b -> c) -> (b -> c)  is a valid Haskell expression, given b and c are .. (types? concrete types? doesn't matter, I just have the revelation)
06:01:48 <sipa> they're type variables
06:01:53 <Kaidelong> aib: Do you know Prolog?
06:02:10 <Kaidelong> it is the same concept
06:02:19 <aib> Kaidelong: only enough to do a 101 homework
06:02:26 <Kaidelong> yeah but
06:02:31 <Kaidelong> they probably covered unification
06:03:04 <udoprog> I was wondering if cabal through ghc has some neat mechanism to handle cross compilation (specifically linux x86_64->i686)?
06:03:22 <dankna> udoprog: no :( that's my current project though
06:03:26 <Kaidelong> udoprog: You could use LLVM or C as the backend
06:03:41 <dankna> but don't hold your breath for it, it's a lot of work
06:04:01 <Kaidelong> although you'd then need a cross-compiler for one of those
06:04:04 <int-e> hmm, template haskell must give you a lot of headaches.
06:04:10 <Kaidelong> so that just shifts the problem elsewhere
06:04:15 <udoprog> dankna: wow, good luck!
06:04:25 <Kaidelong> well maybe you won't
06:04:33 <dankna> thanks.
06:04:36 <Kaidelong> there might be a way to compile C on a platform where you can't compile haskell
06:04:44 <Kaidelong> obviating the need for a cross compiler
06:05:11 <quicksilver> Kaidelong: no you could not.
06:05:22 <quicksilver> using C or LLVM backend does not give you a cross-compiler.
06:05:41 <udoprog> Kaidelong: well take x86_64 gcc, it has the option to compile against 32 bit targets, as long as you'll tell it where to look for 32 bit dependencies
06:05:42 <dankna> there are many architecture-dependencies embedded in the generated code, yeah
06:05:51 * boegel just notified haskell@ of a fail in the mail server config and hopes that someone will resolve it soon
06:05:52 <Kaidelong> ah, that's too bad
06:05:57 <quicksilver> udoprog: GHC can't do cross compilation at all.
06:06:00 <Kaidelong> I thought there was a "high level C" output for Haskell
06:06:13 <quicksilver> udoprog: however, you can build and run a i686 GHC on an x86_64 platform
06:06:15 <dankna> no, there's just a "C" output
06:06:30 <Kaidelong> err, GHC
06:06:35 <quicksilver> udoprog: since x86_64 machines can support + run i686 userlands.
06:06:49 <udoprog> quicksilver: oh yeah, that would be my current approach. virtualization station
06:07:05 <quicksilver> even the unregistereised C is still arch dependent.
06:07:16 <quicksilver> udoprog: you don't actually need to virtualise even
06:07:28 <quicksilver> x86_64 kernels can execute i686 binaries
06:07:33 <Kaidelong> That is a shame
06:07:34 <quicksilver> you just need a separate lib dir for them.
06:07:43 <dankna> at least, on some OSes they can
06:07:45 <Kaidelong> at the stuff being arch-dependant
06:07:52 <udoprog> quicksilver: yeah, but in order to compile, I need a nice system which will handle painful dependencies
06:07:55 <Kaidelong> must be hard work porting GHC over to stuff like SPARC
06:07:56 <udoprog> otherwise*
06:07:58 <quicksilver> dankna: well, linux in particular.
06:08:10 <dankna> yeah
06:08:11 <Kaidelong> You'd have to write a core compiler each time
06:08:13 <quicksilver> udoprog: sure, virtualisation may be easier these days.
06:08:31 <quicksilver> since virtualisation is so easy now.
06:08:32 <dankna> udoprog: well, you can configure Cabal to put $compiler in the install path for everything
06:08:49 <dankna> udoprog: and install your two compilers side-by-side as (for example) ghc-64 and ghc-32
06:09:08 <quicksilver> Kaidelong: no, they didn't quite have to do that
06:09:12 <dankna> udoprog: and then you can provide --compiler (I think that's the flag's name) to cabal-install when installing
06:09:12 <quicksilver> Kaidelong: but, it was hard work, yes.
06:09:19 <udoprog> dankna: hm, a bit fiddly, but I'll give it a try!
06:09:30 <doaitse> is there a way to provide haddock documentation for calss instances, when using export lists?
06:09:34 <dankna> yeah, fiddly as you say, but it ought to work :) I use a similar setup to have two versions of ghc
06:09:35 <quicksilver> Kaidelong: porting GHC to new hardware platforms is a painful manual bootstrap
06:09:36 <dankna> good luck!
06:09:45 <udoprog> thanks : )
06:09:52 <quicksilver> Kaidelong: but not impossible.
06:10:05 <Kaidelong> quicksilver: Seems like getting GHC to build against Java would be a worthwhile endeavour
06:10:12 <Kaidelong> although I think people have done that already
06:10:16 <dankna> against Java?  mm... maybe.
06:10:17 <quicksilver> better to fix the cross compilation, iMO.
06:10:27 <quicksilver> which is what dankna is doing.
06:10:29 <quicksilver> dankna++
06:10:32 <dankna> the Java virtual machine is not all that
06:10:33 <dankna> hehe :D
06:10:43 <Kaidelong> dankna: but at least it is something
06:10:47 <dankna> granted
06:11:05 <Kaidelong> and it'll give me an excuse to use haskell if another crazy professor tells us to do our final project for android phones
06:11:29 * Kaidelong departs momentarily
06:11:33 <quicksilver> Kaidelong: android doesn't use the java virtual machine :P
06:12:05 <Kaidelong> quicksilver: Isn't it "largely compatible with?"
06:12:15 <quicksilver> largely source compatible, sure
06:12:16 <Kaidelong> although perhaps it breaks down in fundamental and important ways
06:12:17 <JimmyRcom> graphical interface
06:12:20 <quicksilver> but it's a totally different VM
06:12:28 <quicksilver> so it's not remotely "binary compatible"
06:12:33 <Kaidelong> oh I see
06:12:44 <Kaidelong> not bytecode compatible, more specifically
06:12:49 <Kaidelong> that is also a shame
06:12:59 <Kaidelong> Android in general seems well
06:13:13 <quicksilver> it's probably going to be easier to get native GHC compilation to android's NDK
06:13:13 <JimmyRcom> Supposedly the google go now works with android.... but I just found out it doesn't have tail call recursion optimization
06:13:22 <Kaidelong> a little bit messy and it should be a lot better designed than it is
06:13:25 <quicksilver> than hack up something with the dalvik layer.
06:13:34 <JimmyRcom> russ cox said it's not useful
06:13:35 <Kaidelong> JimmyRcom: Google heavily employs Python
06:13:44 <quicksilver> althouhg I don't think anyone is specifically working on GHC/android
06:13:46 <udoprog> Just curious, how would ghc threading translate to a jvm?
06:14:01 <quicksilver> (whereas some people were working on GHC/iPhone)
06:14:04 <JimmyRcom> I know, literally, they employ the guy who made python
06:14:09 <Kaidelong> udoprog: presumably you'd compile in a thread pool or link against a provided one
06:14:27 <Kaidelong> a haskell style thread pool, that is
06:14:35 <Kaidelong> I know at least one person wrote one for Java
06:14:51 <Kaidelong> lightweight threads + scheduler
06:15:17 <udoprog> ah, very neat!
06:15:33 <Ke> openmp thread/task pool ftw
06:15:36 <Ke> !
06:16:31 <Kaidelong> honestly operating system processes should not be as heavyweight as they are
06:16:39 <Kaidelong> that is the real problem
06:17:08 <dankna> well, they have to be, to support separate programs, yes?
06:17:19 <JimmyRcom> I think operating system threads cost very little, it's pthreads and the like that allocate all that space
06:17:29 <dankna> each process needs its own virtual address space
06:17:32 <JimmyRcom> there's stackless thread implementations in c
06:18:10 <Kaidelong> JimmyRcom: that really depends on the operating system
06:19:31 <Kaidelong> also the "thread" vs "process" distinction is a little bit odd to me. It seems too heavily tied to implementation and not a very important distinction as to what they actually are.
06:20:35 <Kaidelong> I suppose modern operating systems still work very close to the hardware and that is at the root of a lot of what makes them look so strange to me
06:21:05 <Kaidelong> or rather, the part programmers see
06:21:46 <Philippa> that's kinda their job though
06:22:09 <dankna> yeah, as Philippa says
06:22:10 <Philippa> I mean... you can go about it another way and have the mainframe version of iOS, sure
06:22:27 <Philippa> I think people mostly call that the JVM
06:23:18 <JimmyRcom> I wish I knew more about haskell, go and D =/.
06:24:03 <Kaidelong> Philippa: I realized, hence trying to rephrase it into something closer to what I actually meant...
06:24:13 <Kaidelong> the API exposed by operating systems still seems very low level
06:25:05 <Kaidelong> the fact that just about everyone these days uses some kind of heavyweight runtime system is probably good "proof" of that
06:25:17 <Philippa> mmm. But until we're happy baking GC into our OS, it's the right thing
06:25:31 <Kaidelong> I think that is probably a good idea
06:25:40 <Philippa> I don't think we're quite ready for that
06:25:47 <Kaidelong> (memory management can be a lot more efficient if you bake it into the OS)
06:25:52 <Kaidelong> (it has been tried)
06:25:59 <Philippa> GC doesn't cure all leaks, at least with the OS memory allocation model you can kill the process and grab its memory back
06:26:13 <Kaidelong> the main problem is that if you make your OS managed, you break software that isn't
06:26:40 <Philippa> not entirely, you just allocate pools at the GC level and run from there
06:26:46 <dankna> the other thing is that the OS doesn't need GC backed in
06:26:48 <dankna> GC is a userland issue
06:27:01 <dankna> baked into libc or its replacement maybe, yes, but not into the kernel
06:27:08 <dankna> s/backed/baked/
06:27:09 <Philippa> there're strong benefits to sharing a single GC across the whole of userland though
06:27:22 <Philippa> at which point you're partly arguing about what you think "OS" should refer to
06:27:39 <Kaidelong> also banning unsafe code has other benefits
06:28:02 <Kaidelong> IE the OS will not run code that isn't garbage collected except its own
06:28:02 <JimmyRcom> more inefficient to be constantly growing the stack when needed, I don't think the memory usage is a big deal in most applications
06:29:20 <Kaidelong> JimmyRcom: In practice I find that in a lot of programs I write the bulk of the time is spent waiting on the RAM
06:29:32 <mathijs> Hi all, I'm reading "Generalising Monads to Arrows" and I'm playing with the stream processing code. My current code (almost exact copy of the paper) http://hpaste.org/44644/arrows_for_stream_processing . Now, the paper mentions this is for non-terminating streams only, but by adding another operator would allow termination...
06:30:00 <mathijs> So I would like to add "Block" as an operator, but I can't figure out its type/behaviour.
06:30:03 <Kaidelong> oh and file IO
06:30:14 <Jaxan> i got an overlapping instances error, so i tried to allow them, but it doesn't help :(. any ideas what to do?
06:30:34 <Philippa> JimmyRcom: I take it you've not written much erlang-style use-threads/processes-like-objects code? You can't afford to give each one a half meg stack by default at the moment and you end up doing that even in a GCed model
06:30:36 <Kaidelong> Jaxan: It depends on what you are trying to make an instance for
06:30:56 <Kaidelong> Jaxan: You could try using newtype
06:31:11 <Kaidelong> IE if you want to make an instance for any type, but it conflicts with more specific ones
06:31:15 <JimmyRcom> philippa: =/ I'm from the erlang side, I'm just lurking this channel
06:31:21 <Philippa> ah, fair enough
06:31:43 <Philippa> (GHC's smallest stack unit's 1K - it handles growth reasonably cheaply, but...)
06:31:57 <Kaidelong> you could wrap it into a newtype "newtype AsMyClass a = AsMyClass a" and then make an instance for "AsMyClass a" instead of "a"
06:32:42 <Kaidelong> depending on what you are doing with your typeclass that might also actually be what you want, anyway
06:32:44 <JimmyRcom> from my understanding it's still shared memory or something like that? I don't understand haskell well. Applications can set their stack smaller in pthreads with pthread_attr_setstacksize if they know they won't be eating too much memory in advanced, otherwise can use stackless threads
06:32:48 <Philippa> JimmyRcom: not all stacks are OS stacks though, and I agree that's not a case most OSes optimise for
06:33:06 <Philippa> it's not shared at all
06:33:11 <jlouis> Dear #lazyhaskell, what is the extension for 'deriving Typeable' ?
06:33:13 <JimmyRcom> I mean, in haskell
06:33:22 <jlouis> (in GHC)
06:33:23 <Philippa> well, possibly under the hood, but semantically? Nope, you have to copy stuff out for another thread to see it
06:33:33 <djahandarie> jlouis, DeriveDataTypeable?
06:33:34 <Philippa> (but you may be confusing concurrency with parallelism? Sparks != threads)
06:33:38 <jlouis> djahandarie: thanks
06:34:08 <Jaxan> Kaidelong i'm trying to make an instance of Monad
06:34:26 <JimmyRcom> lol, I say that after watching mr. jlouis's etorrent infoq video ^^^. 
06:34:32 <Kaidelong> Jaxan: what are you trying to make an instance of Monad?
06:35:01 <Jaxan> Kaidelong (Either String)
06:35:24 <jlouis> JimmyRcom: hehe
06:35:24 <JimmyRcom> I dunno much about haskell, just the basics thanks to bonus's guide
06:35:33 <Kaidelong> @instances-importing Monad
06:35:33 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
06:35:39 <Kaidelong> there is your problem
06:35:45 <Kaidelong> Either String overlaps with Either e
06:36:03 <Kaidelong> perhaps the Either monad is already fine for what you are trying to do
06:36:20 <Kaidelong> I would just try going without the instance and seeing if things behave properly
06:36:22 <jlouis> JimmyRcom: in Haskell there is no isolation of the memory space for threads (that's somewhat the reason to call it a 'thread' rather than a 'process')
06:36:23 <Jaxan> yeah well, i'm trying to compile something already existing...
06:36:30 <Kaidelong> you might have to import Control.Monad.Instances
06:36:34 <Jaxan> ok
06:36:47 <jlouis> JimmyRcom: but, luckily, the memory space is immutable
06:37:55 <JimmyRcom> jlouis: thanks for the clarification.
06:38:15 <jlouis> I should say persistent rather than immutable
06:39:47 <JimmyRcom> Great job in porting it to both languages though, you have my admiration for your ability to tolerate frustration.
06:39:48 <Philippa> jlouis: not only that, but the stack itself's not directly accessible to other threads anyway
06:40:47 <jlouis> Philippa: that too!
06:41:14 <Philippa> so it's 'semantically isolated' anyway
06:41:16 <jlouis> The problem with concurrency and harnessing the complexity has a lot to do with the question "what is shared"
06:41:30 <jlouis> and yes, the semantical isolation helps a lot with that
06:42:05 <jlouis> Combinatorrent now works with ghc 7.0.2 btw :P
06:42:44 <JimmyRcom> if you could choose between haskell and erlang for a future similar network program which would you pick?
06:42:53 <JimmyRcom> jlouis
06:43:19 <djahandarie> jlouis, have there been efforts to make a gui for combinatorrent?
06:43:23 <jlouis> for network programs, probably Erlang. The tooling is more developed. 
06:43:40 <jlouis> for other things, I'd probably choose Haskell
06:44:06 <jlouis> it depends on the particular problem IMO
06:44:35 <jlouis> djahandarie: no, not really. My plan was to embed Snap about 6 months ago and then serve stuff to some JS code
06:44:56 <djahandarie> So it'd be a browser frontend?
06:45:01 <JimmyRcom> jlouis: You think it can provide similar amount of connections as an erlang server, given you had infinite freetime?
06:45:03 <jlouis> yeah djahandarie 
06:45:17 <jlouis> JimmyRcom: Haskell? Sure!
06:45:39 <djahandarie> Neat. I might be interested in designing something in the (very) far future once I finish all the stuff I have piled up right now
06:46:02 <djahandarie> A good design feels like where we could actually push a Haskell torrent client way beyond a bunch of other torrent clients :)
06:46:31 <JimmyRcom> jlouis: thanks, I'll give more priority to studying it. Great video by the way
06:47:06 <jlouis> You'll need to push it beyond etorrent, which will be quite a feat :)
06:48:03 <jlouis> etorrent can outperform many of the C clients as well, hehe :)
06:48:08 <djahandarie> jlouis, I feel like you may be bias here ;)
06:48:16 <jlouis> bias? whom?
06:48:17 <jlouis> :P
06:49:53 <djahandarie> jlouis, actually, rtorrent has been crashing every other day for me, do you think etorrent could do better? :)
06:50:29 <jlouis> djahandarie: well, it is written in Erlang, so ... crashes are mitigated
06:50:32 * Eduard_Munteanu still uses Azureus/Vuze
06:50:45 <Eduard_Munteanu> Though a Haskell torrent client sounds like an interesting idea.
06:51:05 <jlouis> usually you crash in the communication with other peers, which is easy to mitigate
06:51:12 <djahandarie> jlouis, I'll check it out then. Thanks. :-)
06:51:20 <djahandarie> I think my crashing was due to sheering number of files
06:51:29 <djahandarie> I think there were thousands of old torrents in there
06:51:38 <djahandarie> sheer*
06:51:38 <jlouis> feel free to report bugs on any of the clients, etorrent or combinatorrent
06:51:46 <djahandarie> Will do
06:51:47 <jlouis> djahandarie: I've only run etorrent up to some 120
06:51:54 <jlouis> so it is kind of interesting
06:52:14 <jlouis> It seriously needs a queueing system for that many torrents though
06:52:33 <djahandarie> The majority were inactive though, only about 40-50 active ones
06:53:02 <jlouis> memory is the worry
06:53:39 <jlouis> Eduard_Munteanu: yeah, a haskell torrent client is interesting, to write and to play with :P
07:05:26 <Jaxan> ghc is compiling a file, but seems to halt, and eventually quit. it doesn't say anything (even with -v)... what can be the problem?
07:07:21 <jlouis> Jaxan: user limits?
07:07:27 <jlouis> and using too much memory
07:07:39 <jlouis> next knee jerk reaction: strace the process
07:07:41 <Jaxan> let's see
07:10:15 <Jaxan> out of memory indeed
07:14:51 * hackagebot ascii 0.0.2 - Type-safe, bytestring-based ASCII values.  http://hackage.haskell.org/package/ascii-0.0.2 (MichaelSnoyman)
07:14:53 * hackagebot authenticate 0.8.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.8.2 (MichaelSnoyman)
07:14:55 * hackagebot yesod-auth 0.3.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.3.1 (MichaelSnoyman)
07:19:58 <sunfun> where i could find more about quickCheck? 
07:20:40 <sunfun> yesterday someone told me about testing my own dropWhile' using quick check, but i haven't understand how to do that
07:22:53 * hackagebot SBench 0.1.1 - A benchmark suite for runtime and heap measurements over  a series of inputs.  http://hackage.haskell.org/package/SBench-0.1.1 (DanielSeidel)
07:32:16 <kmc> sunfun, there is a chapter about it in Real World Haskell
07:33:48 <Kaidelong> @check \x -> dropWhile (const true) x == []
07:33:49 <lambdabot>   Not in scope: `true'
07:33:54 <Kaidelong> @check \x -> dropWhile (const True) x == []
07:33:55 <lambdabot>   "OK, passed 500 tests."
07:34:07 <Kaidelong> @check \x -> dropWhile (const False) x == x
07:34:07 <lambdabot>   "OK, passed 500 tests."
07:34:29 <Kaidelong> @type quickCheck
07:34:30 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
07:34:51 <Kaidelong> @instances-importing Testable
07:34:51 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
07:35:04 <Kaidelong> well
07:35:04 <Kaidelong> (a -> Bool) is testable
07:36:47 <fryguybob> @instances-importing Test.QuickCheck Testable
07:36:48 <lambdabot> (), Bool, Gen prop, Prop
07:37:53 <int-e> Quickcheck 2 has instance (Arbitrary a, Show a, Testable prop) => Testable (a -> prop)
07:38:09 <sunfun> thanks guys
07:39:34 <int-e> but so does QC 1, why doesn't lambdabot see it? (Arbitrary a, Show a, Testable b) => Testable (a -> b)
07:41:27 <int-e> (and the  Gen prop  thing is QC 2 anyway)
07:47:43 <teki> can i update my base version with cabal install base?
07:47:50 <int-e> no
07:47:54 <teki> how, then?
07:47:59 <teki> do i have to get the latest GHC?
07:48:00 <int-e> get a new ghc
07:48:12 <teki> okay then
08:06:13 <djahandarie> mzero, dcoutts, so that new RC has the cabal-install issue fixed, right?
08:06:26 <djahandarie> (HP RC)
08:06:39 <mzero> well, it has dcoutts' latest cabal-install 
08:06:51 <mzero> I hope that I understood that that was the only change required
08:07:17 <mzero> IOW it has cabal-install-0.10.2
08:07:35 <mzero> for Mac these would be the RC4 versions
08:07:44 <mzero> (which also fix a bug in the installer I discovered late)
08:08:37 <keithroe> hello, any happy pros on?
08:09:15 <mzero> how about a happy moderate?
08:09:19 <mzero> :-)
08:09:28 <keithroe> better than a happy novice like myself :)
08:09:42 <keithroe> can you add a type sig to a parameterized production in happy?
08:10:06 <mzero> OH
08:10:11 <keithroe> i am having a heck of a time getting a happy produced parser to typecheck -- thought this might help
08:10:14 <mzero> happy --- I really through you meant the adjective
08:10:20 <mzero> sorry - I never use happy!
08:10:26 <keithroe> ;)
08:10:29 <keithroe> thanks anyway
08:11:53 <keithroe> for anyone curious -- i just RTFM and you cannot currently add type signatures to parameterized productions in happy
08:18:32 <merijn> How easy/hard is it to retrofit bytestring into a program? i.e. should I just develop with strings and later add bytestring into the mix or should I figure out bytestring first and write immediately using that?
08:19:20 <mzero> if you are working with strings of text, you should probably write with String now, and later use Text, not ByteString
08:19:40 <mzero> use ByteString for sequences of octets, not Char
08:20:37 <merijn> mzero: Hmm, might be an idea. I'm not sure yet whether the only input I have to deal with is text or not
08:21:33 <mzero> it matters more, I suppose, what kind of processing you are doing on it 
08:22:10 <hpc> you should be sure to minimize wraps/unwraps
08:23:00 <merijn> mzero: I think text is safe base assumption for now. I'll be doing the shell kind of processing, I have decided I have had it with all the standard shells and decided if I'm gonna spend most of my time in life in a shell I might as well create one that doesn't suck
08:23:26 <basvandijk> Is there documentation somewhere about the new cabal test feature?
08:24:21 <mzero> merijn - then yes, I say you are doing text processing - since that is what the user is going interact in
08:24:54 <merijn> On a slightly related note, hscurses vs jmillikin's ncurses bindings? Normally I'd decide based on documentation, but that appears to be non-existent for both :p
08:24:55 <mzero> in which case, sure, use String for now, then move to Text, always working with Char ---- then you only need to deal with encoding issues immediately on the way in and the way out
08:25:09 <mzero> can't offer an opinion there
08:25:25 <mzero> I suggest writing a shell that runs in a web page served from the shell process!
08:25:34 * basvandijk found the docs of cabal test
08:25:48 <mzero> imagine - it could do things like pull up man pages in side bars as you are typing
08:25:59 <mzero> let you see the contents of pwd in a side pane at all times
08:26:02 <mzero> :-)
08:26:30 <hpc> a shell that can do html output would be a nifty toy
08:26:59 <merijn> mzero: Actually, that is the sorta thing I'm thinking off. Right now I use tmux/bash (used screen before that) but that doesn't integrate nicely together *at all*, why can't my terminal multiplexer and my shell have a vim like command mode
08:27:25 <mzero> actually, bash DOES have vi command mode
08:27:30 <mzero> but - that aside
08:27:33 <merijn> mzero: Yes, but it sucks
08:28:06 <mzero> I still love the idea of a shell that brings up the command summary in a pane just below where I'm typing as I start to type a command
08:28:07 <merijn> Hell, why can I only create linear pipelines? The number of times I've wanted to split a pipeline in N pipelines then merge them back together...
08:28:34 <monochrom> is solved by Arrow
08:29:01 <hpc> Arrow can't split a stream into n streams though, only two
08:29:01 <chrisdone> @where suddenlyspj
08:29:01 <lambdabot> http://skillsmatter.com/custom/geeks/simon-peyton-jones-x-large.jpg
08:29:05 <hpc> because it uses tuples
08:29:09 <hpc> afaik
08:29:17 <merijn> hpc: You can always split into nested tuples
08:29:24 <merijn> And implementing a shell isn't even that hard when you think about it. Sure, posix compatibility is hard, but who cares about that for a user shell?
08:29:32 <monochrom> repeat it to get more. the proc notation does it for you
08:29:34 <hpc> but it is always a static number
08:29:41 <hpc> it isn't a true list
08:30:12 <Philonous> hpc: Yes, arrows are static (that's the point, I think)
08:30:31 <quicksilver> hpc: arrow can split into N streams
08:30:38 <quicksilver> hpc: the 2-ples are just example functions, really.
08:31:43 <merijn> Documentation is not high on the average hackage project's list, is it? :p
08:32:32 * chrisdone documents his libraries
08:33:08 <malorie> is there function to do something like `f ' ' "abc def" == ["abc","def"]' ? I can't seem to find one
08:33:15 <monochrom> "average" is irrelevant
08:33:39 <hpc> malorie: v
08:33:41 <hpc> @src words
08:33:41 <lambdabot> words s = case dropWhile isSpace s of
08:33:42 <lambdabot>     "" -> []
08:33:42 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
08:33:53 <hpc> adapt that
08:34:11 <monochrom> relevant to you is a weighted average custom made to your work
08:34:30 <merijn> monochrom: I guess :p
08:34:30 <malorie> hpc: thanks. so there isn't a "generic" words?
08:34:45 <hpc> malorie: not that i know of; one would expect it to exist...
08:34:51 <malorie> indeed
08:35:59 <fryguybob> malorie: There is the split package on hackage: http://hackage.haskell.org/package/split
08:47:59 <Eduard_Munteanu> LOL... SPJ is quite "explosive"... http://www.youtube.com/watch?v=NWSZ4c9yqW8
08:48:58 <Eduard_Munteanu> Too much caffeine? :D
08:51:15 <djahandarie> I don't know what video you're talking about but he is always like that :P
08:51:16 * hackagebot greg-client 1.0.2 - A scalable distributed logger with a high-precision global time axis.  http://hackage.haskell.org/package/greg-client-1.0.2 (EugeneKirpichov)
08:51:19 <djahandarie> Unless he is particularly so in this one
08:52:31 <ion> With the poor audio quality of the video the announcer saying “Haskell” almost sounds like “asshole”.
08:52:41 <Eduard_Munteanu> Heh, actually I haven't watched much SPJ live action :)
08:53:00 <Eduard_Munteanu> I wonder if Wadler's got some too.
08:53:06 <djahandarie> He's a great speaker so you should watch more :)
08:53:20 <ion> 01:09
08:54:39 <FliPPeh> Are there any widely used CGI design patterns? I've been looking all over the internet now and all I find are the cheap CGI examples that print "hello world".
08:55:53 <ion> Ah, great, SPJ’s voice has been recorded with a decent mic.
08:56:11 <hpc> FliPPeh: a haskell-specific one that i like, is blaze-html
08:56:39 <djahandarie> What does blaze-html have to do with CGI?
08:56:54 <hpc> it's a much more comfortable way to build html
08:56:58 <hpc> it gets that part out of the way
08:57:03 <hpc> the rest is just simple IO stuff
08:57:15 <ion> I haven’t looked at any web stuff in Haskell, but i should hope there’s something like Ruby’s Rack and Python’s WSGI. They > CGI as a concept.
08:58:11 <xarch> maybe WAI
08:59:37 <monochrom> cgi programs are just like all programs, apart from how to obtain input and what output to emit.
08:59:59 <ion> xarch: WAI seems to look like that indeed.
09:00:18 <monochrom> start with Jackson Structured Design for all functional programs.
09:00:21 <c_wraith> In fact, basically every haskell web server is better than CGI.
09:00:41 * chrisdone uses FastCGI in production ›_›
09:01:05 <c_wraith> chrisdone: wouldn't simple http proxying be simpler and faster?
09:01:06 <chrisdone> The choice of web server is uninteresting to me. I have more interesting issues with practical databases.
09:02:34 <merijn> ion: Happstack and and Yesod seem to be the biggest Haskell webframeworks
09:03:14 <jyunntohoo> ddd
09:03:14 <chrisdone> c_wraith: My applications work over the internet, so the bottleneck is always the internet connection. If you mean fast as in development time, Network.CGI provides a nice enough interface for my needs, and it sits seamlessly ontop of Network.FastCGI.
09:03:18 <ion> I don’t mean a web framework. A web framework would be something that uses something like WAI.
09:03:54 <chrisdone> Snap looks nice, though, I might switch to it when (if already) it has file upload support.
09:03:58 <merijn> ion: Most haskell web frameworks seem to implement their own webserver directly
09:04:38 <c_wraith> chrisdone: I actually meant "processing overhead" for faster, which is significant when your sites are high-traffic.  But simpler was definitely about how bad the CGI interface is.  I don't care how nice a library you make around it, using a weird abstract interface is harder than using the interface you actually mean to use.
09:04:38 <chrisdone> We prefer running the apps behind nginx and proxied from it, so that we can have some redundancy.
09:05:13 <c_wraith> chrisdone: it has file upload support now
09:05:20 <c_wraith> also, your comment was enough to summon mightybyte. :)
09:05:31 <mightybyte> c_wraith beat me to it.
09:06:27 <aristid> bah. snoyman uses numeric ascii constants in his code. :/
09:06:54 <jyunntohoo> :/
09:06:59 <c_wraith> quick, we need an OverloadedCharConstants extension!
09:07:13 <c_wraith> err, rather, OverloadedCharLiterals
09:07:28 <chrisdone> c_wraith: Maybe when we get high traffic that'll be an issue but I don't but it's really premature/pointless to think about that stuff.
09:08:45 <c_wraith> chrisdone: ah.  I guess I started using haskell as a web server when the load was getting too high for rails to handle the requests easily.  That is, I started with the high-load services. :)
09:09:07 <chrisdone> I understand lots of Haskellers love talking about how fast their web servers are, and that's cool. But I've never had such a high load that the *server* has been the problem.
09:09:13 <mwc> n
09:09:21 <chrisdone> c_wraith: Sure, makes sense.
09:10:21 <djahandarie> chrisdone, have you seen how fast my web server is?
09:10:49 <chrisdone> c_wraith: Agreed, re overloaded character literals.
09:12:29 <chrisdone> Our biggest apps are more like "applications" than web sites, the whole UI is generated dynamically, so my interest lies in avoiding writing any JavaScript code directly and doing it all from Haskell. Any Haskell web frameworks do this already?
09:12:50 <c_wraith> yesod has lots of compile-time DSLs for generating content
09:13:06 <c_wraith> Oh, but as far as what you're asking, I don't think so
09:13:08 <sshc> Is there an equivalent of "mod" for Double?
09:13:08 <chrisdone> It needs to be more than a DSL.
09:13:17 <c_wraith> There's nothing like GWT in haskell, that I know of
09:14:51 <c_wraith> Though a couple of less-commonly-used haskell compilers can target javascript as their output.  UHC has an experimental branch for it, and...  I don't recall which the other was.
09:15:02 <chrisdone> c_wraith: Yeah. Though you don't have to compile Haskell to JS, per se, you can actually get away with writing a few fundamentals in JS and then just outputting "show this widget", "trigger this call to the server on this event", etc. A colleague of mine has a CLIM-like framework in Common Lisp that does this. E.g. when you update some data, any "views" in the page get updated automatically to reflect that change.
09:17:11 <chrisdone> All the html elements are tied to (or can be) a view in the server-side, which in turn corresponds to a controller which gets the data from the model. Pretty sweet. I'll be updating this codebase to do something like this soon. If it works out I'll probably release it as a library if anyone's interested.
09:18:03 <jmcarthur> chrisdone: Ur/web has an embedded dsl for javascript. it models the page with FRP, actually. it also supports ajax fairly intuitively
09:18:11 <jmcarthur> not haskell, but still functional
09:19:38 <chrisdone> jmcarthur: Yeah, Ur/Web is awesome.
09:20:04 <mightybyte> chrisdone: Have you looked at jmacro?
09:20:33 <edwardk> we seriously investigated using ur for a lot of our reporting needs here at clarifi
09:20:48 <jmcarthur> i'd love to see a Ur/Web-like framework in haskell. it won't have all the same static checks, but it would still be nice
09:20:51 <edwardk> jmacro is awesome
09:21:19 <jmcarthur> edwardk: ah, cool. helps that the creator and maintainer is nearby, too
09:21:33 <mightybyte> I was discussing this Haskell/JS concept just last week.
09:22:05 <chrisdone> Hm. I did checkout jmacro at some point. Don't recall what it is. 
09:22:06 * chrisdone checks
09:22:17 <edwardk> yeah, adam clearly needs to write some kind of 'confessions of a used dependently typed programming language salesman' in homage to http://research.microsoft.com/en-us/um/people/emeijer/papers/icfp06.pdf ;)
09:23:01 <jmcarthur> heh
09:23:31 <chrisdone> Oh, yeah, that's nice. I'd use jmacro if I were writing JS in Haskell. I really do want to write the bare minimum in JS, though, and abstract away from it.
09:25:04 <mightybyte> chrisdone: I've just started doing some of that with Heist and so far it seems to be working pretty well.
09:25:16 <chrisdone> mightybyte: Some of what?
09:25:18 <edwardk> chrisdone: the nice thing is of course you can glue together jmacro fragments, they form a monoid, you can antiquote out of them back into haskell to inject more code, etc.
09:25:35 <mightybyte> Writing raw javascript and then abstracting away from it.
09:25:41 <chrisdone> Ah, right.
09:25:42 <edwardk> chrisdone: so the quasiquoter isn't all there is to it
09:26:02 <chrisdone> Sure.
09:26:12 <mightybyte> jmacro needs better documentation
09:26:18 <edwardk> mightybyte: yeah
09:27:51 <chrisdone> http://cameraready.eai.eu/#overview ← this project is 50% Haskell, 50% JavaScript. There is a library specifically for rendering that site's UI elements. In the next couple months I want to steadily move all that JS into Haskell zone.
09:29:33 <chrisdone> I don't suppose any of you can login without registering, though. ›_›
09:29:51 <mightybyte> Why does it take so long to render?
09:30:11 <mightybyte> Oh, must have been my browser.
09:30:17 <mightybyte> Different computer does better.
09:30:18 <luite> don't you have a test login?
09:30:20 <chrisdone> mightybyte: The wallpaper isn't very compressed.
09:31:55 <chrisdone> yeah, ok
09:32:28 <chrisdone> user/pass: cdone@create-net.org/haskellchannel 
09:33:00 <chrisdone> Made a temporary password. I'll delete it in a bit. There's nothing to see for that user, really.
09:33:04 * chrisdone adds him to a test conference
09:34:26 <luite> why is there no "haskell" field of interest? ;)
09:34:28 <chrisdone> okay, refresh the overview page. you can now submit to the test conference, hehe
09:34:53 <chrisdone> luite: Hehe.
09:35:30 * chrisdone watches people clicking things
09:35:55 <chrisdone> I get events on the #confy channel on our dev team's IRC server (Hulk). :p
09:36:21 <mightybyte> nice
09:37:32 <chrisdone> You have to hit refresh to see the conferences list.
09:37:47 <chrisdone> The client-side doesn't update information from the server dynamically, caches everything.
09:37:52 <luite> ah
09:38:15 <chrisdone> (I'm aware this isn't great.)
09:39:19 <luite> hmm how do i submit a paper?
09:39:27 <thetallguy> yo, #haskell, sup.  I vaguely remember an announcement in the last few months of a Haskell visual debugger/analyzer.  Can't find it.  Ring a bell?
09:39:29 <chrisdone> luite: Go to the conference and hit Submit Camera Ready.
09:39:41 <dmwit> thetallguy: Just a blog post, no code.
09:39:41 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
09:39:47 <luite> chrisdone: oh I hadn't realized that that was a button
09:39:51 <dmwit> ?messages
09:39:51 <lambdabot> ManateeLazyCat said 6h 4m 24s ago: Yes, please use newest stable version WordPress, thank you very much! :)
09:39:54 <thetallguy> dmwit: link?
09:40:00 <dmwit> um
09:40:09 <thetallguy> dmwit: keyword?
09:40:16 <chrisdone> luite: Thanks for the feedback, I had suspected it wasn't clear enough.
09:40:29 <thetallguy> dmwit: # of syllables?
09:40:34 * hackagebot ssv 0.1 - Comma-separated-value (CSV) read, show and write routines  http://hackage.haskell.org/package/ssv-0.1 (BartonMassey)
09:40:36 <luite> I have to write my paper first, does the site offer any help with that? ;)
09:40:46 <dmwit> http://pgraycode.wordpress.com/2010/03/24/visual-haskell-debugger-part-2/
09:40:52 <chrisdone> @faq Can Haskell write papers for me?
09:40:53 <lambdabot> The answer is: Yes! Haskell can do that.
09:40:53 <FliPPeh> Meh, why can't you output CGI "on the go" instead of somehow trying to do _everything_ in one place because only a single "output stuff" will have to do?
09:41:02 <thetallguy> dmwit: thanks
09:41:38 <hpc> FliPPeh: what do you mean?
09:42:03 <FliPPeh> hpc: Well, with Network.CGI you can only call "output ..." once, and that handles the complete page output
09:42:18 <FliPPeh> hpc: If you try to use more than one "output", only the last one will actually be written
09:42:41 <FliPPeh> Thus you have to cramp everything into a single output call
09:42:50 <thetallguy> bummer, the images are busted
09:43:08 <FliPPeh> Works well with "output $ prettyHtml $ h1 << "Hello World"" but not much else for me
09:43:14 <hpc> but the single output call doesn't wait for all the other stuff to be computed
09:43:23 <hpc> > [1,2,3,4,undefined]
09:43:24 <lambdabot>   [1,2,3,4,*Exception: Prelude.undefined
09:45:28 <FliPPeh> I know, that's not my issue
09:45:37 <FliPPeh> My issue is that of glueing the page together
09:45:39 <chrisdone> A Simulation of Context-Free Grammar with HoaryPolyp
09:45:41 <chrisdone> Heh, who submitted that?
09:46:07 <luite> :p
09:46:13 * chrisdone laughs
09:46:21 <FliPPeh> I'd have to have dozens of "thisSection <- cgiRunThisSection" and then out single output that looks like "output $ prettyHtml $  thisSection +++ thatSection +++ anotherOne +++ ........"
09:46:30 <FliPPeh> That just doesn't seem to awesome to me :/
09:46:53 <hpc> how about output $ prettyHtml $ do this; that; the other;
09:46:59 <hpc> or sequence_ it
09:47:20 <chrisdone> FliPPeh: You could just use WriterT.
09:47:24 <hpc> :t prettyHtml
09:47:25 <lambdabot> Not in scope: `prettyHtml'
09:47:26 <Jafet> This clearly calls for a CGIT
09:48:21 <FliPPeh_> Ergh
09:51:35 <chrisdone> FliPPeh_: If you use WriterT you can write output whenever you like and output it in one go at the end.
09:55:20 <hpaste> chrisdone pasted "CGI and html output"  http://hpaste.org/44646
09:56:36 <chrisdone> FliPPeh_: I find Blazehtml to be much nicer than Text.(X)Html.
09:57:38 <chrisdone> FliPPeh_: I'm curious to see the rest of your application for which you would want non-pure HTML generation.
09:58:32 <chrisdone> jaspervdj: Hey man. We're using number-six now. ;) I added server PASS support. Dunno if you want that.
09:58:38 <chrisdone> (Did I push that?)
09:59:12 <chrisdone> Ah, yeah, I did, but in the dev branch.
09:59:28 <FliPPeh_> chrisdone: There's no "rest" right now, because this is actually stopping me from starting right now
09:59:34 <FliPPeh_> Erghk
10:07:55 <Bfig> what is wrong with this: http://pastebin.us/2407
10:10:11 <c_wraith> Bfig: precedence errors.  several of them.
10:10:46 <c_wraith> Bfig: line 4 there should look like:  nmlt a b = a + nmlt (a - 1) b
10:11:00 <c_wraith> you need two arguments for the recursive call to nmlt
10:11:19 <c_wraith> the first argument is the value (a - 1), the second argument is the value b
10:11:39 <Bfig> ohh cool
10:12:19 <Bfig> thanks :). i thought that the parenthesis meant it would take them both as arguments, thanks for clearing it up
10:13:11 <c_wraith> No, parens don't have anything to do with function application in haskell
10:13:15 <c_wraith> They're only for grouping
10:13:19 <c_wraith> ..  Or making tuples
10:19:25 <yitz> c_wraith: or listing explicit names for import
10:19:49 <c_wraith> yitz: ah, yeah, several places in the import/export syntax where parens apply
10:20:06 <czm> hi, which book would you recommend for learning haskell? real world haskell or the haskell school of expression or some other?
10:21:25 <burp> @lyah
10:21:25 <lambdabot> Unknown command, try @list
10:21:29 <burp> @url lyah
10:21:29 <lambdabot> http://www.learnyouahaskell.com/
10:21:33 <Eduard_Munteanu> @where lyah
10:21:33 <lambdabot> http://www.learnyouahaskell.com/
10:22:20 <Eduard_Munteanu> LYAH; after it you could skim RWH or whatever else you find online.
10:24:07 <Egbert9e9> what's the ("abc" ' ' -> "a b c") function?
10:24:17 <czm> allright, thanks, ill take a look
10:24:49 <Egbert9e9> adds an item in-between items
10:25:02 <xxx_man> what is valuation? for any valuation sigma A|=_{sigma} B
10:25:05 <xxx_man> what this means?
10:25:05 <Zao> @type intersperse
10:25:06 <lambdabot> forall a. a -> [a] -> [a]
10:25:18 <Zao> Egbert9e9: Intersperse puts an element inbetween all elements of a list.
10:25:19 <Egbert9e9> Zao: thanks!
10:25:36 <Zao> Egbert9e9: intercalate is related.
10:25:39 <Zao> @type intercalate
10:25:40 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:26:06 <Zao> > intercalate "wtf" ["omg", "bbq"]
10:26:07 <lambdabot>   "omgwtfbbq"
10:26:25 <Zao> (same thing as intersperse, but with concatenation of the resulting list of lists.
10:26:42 <Zao> @src intercalate
10:26:42 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
10:26:44 <Egbert9e9> o-o woah.
10:27:09 <Egbert9e9> how do i get lambdabot functionality offline?
10:27:22 <burp> ghci
10:27:24 <Zao> You can (theoretically) build lambdabot yourself.
10:27:30 <czm> > map (*5) [1..5]
10:27:30 <djahandarie> The @src function in lambdabot is very inaccurate
10:27:30 <lambdabot>   [5,10,15,20,25]
10:27:34 <czm> cool
10:27:38 <Egbert9e9> i can also (theoretically) build an eifel tower myself -_-
10:27:42 <Zao> burp: GHCi does not remotely have all that she has though.
10:27:46 <ion> You can install pointfree for pl, pointful for unpl, ghci for > and :t etc.
10:27:57 <burp> Zao: I know, but I guess the things Egbert9e9 is asking for
10:28:33 <ion> And hoogle for hoogle
10:28:34 <Egbert9e9> already have ghci and now i'll get me pointfree and pointful
10:28:44 <Egbert9e9> there's an offline hoogle?
10:29:04 <c_wraith> you can install hoogle locally, and have it index whatever you install
10:29:06 <Eduard_Munteanu> 'cabal install lambdabot' *might* work
10:29:29 <Eduard_Munteanu> But I generally Google things and look it up myself.
10:29:39 <Egbert9e9> wow.
10:31:46 <frank00> gentlemen, I'm ploughing through project euler's problems. I have a list of prime divisors of a number (distinct and non distinct), is there a smart way to obtain a set of divisors for a given number? i.e. from [2,2,2] to [2,4,8]
10:33:05 <frank00> I had thought of filtering some cartesian product, but seems inefficient
10:33:33 <djahandarie> Eduard_Munteanu, that has never worked for me
10:33:39 <luite> frank00: if your prime number is p^n * q^m * r^k
10:33:43 <djahandarie> Other people claim it installs but I've never gotten it to work :<
10:33:53 <luite> frank00: err your number
10:34:02 <frank00> ;) luite
10:34:21 <luite> frank00: then your divisors are p^{0..n} * q ^ {0..m} * r ^ {0..k}
10:34:59 <luite> so you can easily enumerate the divisors if you have the prime factors and their exponents
10:35:07 <frank00> luite: nice and easy
10:35:29 <frank00> I bet some <$> and <*> will do
10:36:35 <heatsink> Where can I find out how the worker-wrapper transformation fits with the other transformations in GHC's core simplifier?
10:36:37 <Eduard_Munteanu> Neither have I. But I thought Gentoo was exotic in using linker scripts posing as some libs.
10:40:59 <sshc> Is there really no equivalent of "default" for classes other than "Num"?
10:42:29 <c_wraith> :t default
10:42:30 <lambdabot> parse error on input `default'
10:42:39 <c_wraith> I really have no clue what you mean by that...
10:42:46 <c_wraith> Oh, the default directive?
10:42:58 <sshc> Yes
10:43:00 <c_wraith> I forgot that even exists
10:43:02 <sshc> default (Integer, Double)
10:43:17 <c_wraith> Honestly, it should really never be used.
10:43:59 <c_wraith> GHC's ExtendedDefaultingRules extension does the same thing, but better.
10:44:13 <c_wraith> Well, not the same thing
10:44:26 <luite> it does a different thing, but better? ;p
10:44:38 <c_wraith> It does a similar thing, that often can be used to solve the same problems
10:45:12 <jmcarthur> i just scraped the #haskell irc logs for actions and made a markov generator based on them
10:45:36 <luite> jmcarthur: and it's already more intelligent than the average java programmer? :p
10:46:19 <burp> let's say php
10:46:42 * jmcarthur would like to run gcc on a black turtleneck
10:47:18 * jmcarthur goes off to try to find out what the arrow and gives up trying to build a cute chick.
10:47:46 <heatsink> Hmm.  Only one word of history?
10:47:50 <jmcarthur> 2
10:48:05 <frank00> > (^) <$> [2,2,2]<*> [0..]
10:48:06 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
10:48:09 <Egbert9e9> will (sum [list comprehension]) be equivalent to a foldr expression?
10:48:16 <frank00> > (^) <$> [2,2,2]<*> [0..3]
10:48:17 <mauke> Egbert9e9: no
10:48:17 <lambdabot>   [1,2,4,8,1,2,4,8,1,2,4,8]
10:48:18 <Egbert9e9> computationally
10:48:20 <Egbert9e9> oh
10:48:26 <mauke> sum is a foldl
10:48:42 * jmcarthur advises everyone to $ the way it does
10:49:08 <heatsink> Ah.  I guess so.  I'm not so used to talking to markov generators.
10:49:11 <Egbert9e9> mauke: so should I foldr everything right away?
10:49:45 <mauke> Egbert9e9: huh?
10:50:03 <luite> frank00: I'd first convert (2,3) to [1,2,4,8], and then map product . sequence that list
10:50:10 * jmcarthur spins cjs around really really fast, to help with lambdabot is one of his heart pounding like hell
10:50:11 <Egbert9e9> if sum [list-comprehension] takes more computation than a foldr expression that computes the same thing
10:50:38 <frank00> thanks lite
10:50:43 <Egbert9e9> should I use foldr expression instead of sum [list comprehension]
10:50:45 <frank00> * luite 
10:50:46 <luite> frank00: for example if your factors are 2^3 * 3^2, then construct [[1,2,4,8],[1,3,9]]
10:51:03 <frank00> I have [[2,2,2,2][3,3,3]]
10:51:38 <jmcarthur> > map head $ group [1,1,2,2,2,3,3,3,3]
10:51:39 <lambdabot>   [1,2,3]
10:51:54 <luite> frank00: oh that's also possible. 
10:52:55 * hackagebot authenticate 0.8.2.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.8.2.1 (MichaelSnoyman)
10:53:25 <luite> > map product . sequence . map (map product.tails) $ [[2,2,2], [3,3]] -- frank00 
10:53:27 <lambdabot>   [72,24,8,36,12,4,18,6,2,9,3,1]
10:54:05 <frank00> thanks luite, I will examine that!
10:54:08 <frank00> >t: sequence
10:54:32 <frank00> > t: sequence
10:54:33 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
10:54:33 <lambdabot>         against inferre...
10:54:38 <luite> > sequence [[1,2],[3,4]]
10:54:39 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
10:55:00 <luite> it chooses one element from each of the lists and makes a new list
10:55:13 <luite> > sequence [[1,2],[3,4],[5,6]]
10:55:14 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
10:56:00 <luite> frank00: its type is a bit more general than that, but this is the behaviour for the list monad
10:56:40 <luite> frank00: for other monads it's different, for IO for example, its type is [IO a] -> IO [a]
10:57:47 <luite> frank00: in that case, it converts a list of IO actions, to a big IO action that executes the "small" IO actions in the order they appear in the list
10:58:40 <frank00> thanks luite|
11:00:51 <luite> :t sequence
11:00:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:01:04 <luite> by the way, if you wanted to know the correct lambdabot (and ghci) command
11:03:20 <frank00> doh, yeah it's :t
11:05:46 <Jaxan> help :( -> GHCi runtime linker: fatal error: I found a duplicate definition for symbol __hscore_S_IFDIR
11:05:52 <FUZxxl> >sequence $ map (flip enumFromTo 10) [1..10]
11:06:01 <FUZxxl> > sequence $ map (flip enumFromTo 10) [1..10]
11:06:03 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,10,10],[1,2,3,4,5,6,7,9,9,10],[1,2...
11:06:11 <FUZxxl> > sequence $ map (flip enumFromTo 10) [1..3]
11:06:12 <lambdabot>   [[1,2,3],[1,2,4],[1,2,5],[1,2,6],[1,2,7],[1,2,8],[1,2,9],[1,2,10],[1,3,3],[...
11:09:55 <accel> dumb question: has anyone written a shell in haskell yet?
11:09:59 <Hueho> @help
11:09:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:12:53 <Hueho> hello
11:13:15 <Hueho> i'm having some noob problems with typing :(
11:13:26 <accel> are you using qwerty or dvorak format?
11:13:41 <Hueho> lol
11:14:03 <accel> I know some good typing programs
11:14:07 <accel> they have cute little penguins
11:14:54 <Hueho> http://hpaste.org/44647/typing_problems
11:15:01 <hpaste> hueho pasted "Typing problems"  http://hpaste.org/44647
11:15:23 <mauke> Hueho: what's the type of seq?
11:15:27 <fryguybob> @type sqrt
11:15:28 <lambdabot> forall a. (Floating a) => a -> a
11:15:52 <Hueho> mauke: supposed to be float
11:15:56 <mauke> Hueho: wrong
11:16:06 <Hueho> :/
11:16:09 <luite> seq is built-in
11:16:11 <accel> do you mean seq2?
11:16:12 <Hueho> ok, i will think harder
11:16:15 <Hueho> seq2
11:16:17 <Hueho> i mean
11:16:20 <mauke> Hueho: do you know how to ask ghci for the type of an expression?
11:16:41 <Hueho> not really
11:17:00 <mauke> you just do :t "whatever"
11:17:08 <Hueho> hmm, k
11:17:10 <mauke> and in that case it'll tell you String or [Char]
11:17:18 <mauke> :t seq
11:17:19 <lambdabot> forall a t. a -> t -> t
11:17:44 <Hueho> but i don't want to deal with seq
11:17:49 <mauke> then why are you using it?
11:18:13 <Hueho> i created the function
11:18:16 <Hueho> name seq2
11:18:25 <Hueho> doesn't have anything to do with seq
11:18:29 <mauke> yes, it does
11:18:32 <mauke> look at line 3
11:18:48 <Hueho> ...
11:18:51 <Hueho> i'm a idiot
11:19:15 <Hueho> mauke++
11:19:15 <Bfig> i'm having trouble with folds and maps, how am i supposed to encapsulate/distinguish the first and second operator?
11:19:36 <Bfig> err, operand
11:21:06 <jmcarthur> Bfig: i'm not sure what you mean
11:21:09 <luite> Bfig: can you give an example of what you want to do?
11:21:52 <jmcarthur> Bfig: do you mean how do you know which is which?
11:21:58 <jmcarthur> :t foldr
11:21:59 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:22:01 <jmcarthur> :t foldl
11:22:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:22:08 <jmcarthur> the types tell you ^^
11:22:52 <Bfig> sure, say i want to map a certain Int->Int function composed with a comparison on 0. that would be for example (0==).func. so the map should be something similar to > map (0==).func list; or what has seemed to work for me > map ((0==).func) list;
11:23:12 <aristid> jmcarthur: that's just because haskell98 unnecessarily flipped the argument order in on of them :)
11:23:21 <aristid> @src foldr
11:23:21 <lambdabot> foldr f z []     = z
11:23:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:23:30 <aristid> @src foldl
11:23:31 <lambdabot> foldl f z []     = z
11:23:31 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:23:46 <Bfig> jmcarthur, you mean between foldr foldl and foldr1? i think i know what each is supposed to do but i'm having trouble with the correct form to present the arguments
11:23:47 <jmcarthur> aristid: even if it was flipped the types would still make sure you apply them in the right order
11:23:57 <luite> Bfig: function application binds tighter than (.), so map (0==).func list   actually means (map (0==)) . (func list)
11:24:01 <aristid> jmcarthur: ?
11:24:02 <shachaf> > foldr f z [a,b,c]
11:24:03 <lambdabot>   f a (f b (f c z))
11:24:07 <shachaf> > foldl f z [a,b,c]
11:24:08 <lambdabot>   f (f (f z a) b) c
11:24:19 <shachaf> > foldr1 f [a,b,c]
11:24:20 <lambdabot>   f a (f b c)
11:24:35 <jmcarthur> aristid: if you flip the arguments of the first parameter to the folds they won't work
11:24:46 <Bfig> ok, so that is why the parenthesis solves the problem, right? but it doesn't work the same way with foldr1
11:24:52 <jmcarthur> aristid: i mean when you're applying the folds, not when defining them
11:25:00 <mauke> Bfig: why don't you just use named arguments?
11:25:10 <Bfig> what do you mean?
11:25:18 <Bfig> let ... in ?
11:25:20 <shachaf> Bfig: The parentheses are used because application binds more tightly than (.).
11:25:21 <mauke> map (\x -> func x == 0)
11:25:21 <jmcarthur> Bfig: if you just use parens by default you will avoid the fixity issues
11:25:38 <jmcarthur> Bfig: once you get more familiar with fixity you can then start removing redundant parens
11:25:39 <shachaf> Bfig: map (0==).func list is (map (0==)).(func list)
11:25:44 <Bfig> but if i want to be a True Haskell Programmer i need to understand this :)
11:25:51 <jmcarthur> yes. one step at a time :)
11:25:54 <mauke> shachaf: that was unnecessary
11:26:13 <fryguybob> Bfig: You can use hlint to tell you when somethings are redundant. 
11:26:14 <jmcarthur> Bfig: you could just default to using parens and then use hlint to tell you which ones are redundant. at least that works with the standard operators and stuff
11:26:21 <shachaf> mauke: ?
11:26:24 <fryguybob> :D
11:26:28 <Bfig> so how does it distinguish the second argument?
11:26:29 <mauke> shachaf: luite said the same thing 2 minutes ago
11:26:39 <shachaf> mauke: Oh.
11:26:44 <Bfig> after you have a fully closed expression? ie, a closing parenthesis ?
11:26:45 <jmcarthur> Bfig: are you familiar with how operator precendence works?
11:26:48 * shachaf missed it.
11:27:09 <jmcarthur> Bfig: the magic is in the infix operators, not the map and fold functions
11:27:14 <mauke> Bfig: I don't understand that question
11:27:49 <Bfig> jmcarthur, apparently not :S. you say composition has less precedence than application... i've found some problems with the comparison operators that seemed to bind tighter than some 'more reasonable' interpretations...
11:28:33 <jmcarthur> Bfig: function application finds more tightly than almost anything else (i think record update syntax is the only thing that binds tighter)
11:28:45 <Bfig> i dunno, should work the same on all languages i guess. parenthesis first, then the usual precedence with infix arithmetic/logic
11:29:07 <jmcarthur> Bfig: parens are just a way to manually override
11:29:12 <jmcarthur> Bfig: if in doubt, use parens
11:29:14 <mauke> Bfig: it does
11:29:29 <kmc> jmcarthur, yeah, that's really confusing... the parsing of «f x { y = z }»
11:29:37 <kmc> i try to avoid writing that
11:29:44 <mauke> that's why I don't put a space before {
11:29:51 <Bfig> so the real problem is all stacked on top of application/composition
11:29:58 <kmc> Bfig, plenty of languages don't support infix arithmetic / logic ;)
11:29:58 <jmcarthur> kmc: well, some choice had to be made. either application binds tighter, record update binds tighter, or its an error
11:30:21 <Bfig> gonna read up a bit more and then try again. thanks for clarifying things up
11:30:23 <kmc> i'm in favor of "when in doubt use parens"... if you don't remember the obscure precedence rule, someone reading your code won't either
11:30:24 <jmcarthur> Bfig: i'm serious, just use parens when you're unsure, and use hlint to tell you when you have redundant parens
11:30:36 <jmcarthur> Bfig: you will learn as you go without much trouble that way
11:41:55 <malorie> could somebody care to comment on this code? especially on `bla': http://ideone.com/fAJ9H
11:43:58 <c_wraith> malorie: what would you like to know about bla?
11:44:31 <malorie> c_wraith: whether it could be improved
11:44:39 <c_wraith> :t zipWith ($)
11:44:39 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
11:44:53 <c_wraith> That's similar, having only slightly different semantics
11:45:04 <c_wraith> bla will crash if the list of arguments is longer than the list of functions
11:45:14 <malorie> I see
11:45:16 <c_wraith> the zipWith version stops whenever either ends
11:46:06 <c_wraith> aside from that, it's fine
11:46:23 <malorie> nice :)
11:50:36 <sbahra> Hi
11:50:52 <sbahra> Anybody here use ismtp?
11:52:16 <shachaf> sbahra: mm_freak_ probably does.
11:53:36 <sbahra> shachaf, thanks
11:53:47 <sbahra> haha
11:53:52 <sbahra> I can see why. :-P
12:19:06 <aristid> :t (<*>)
12:19:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:19:21 * hackagebot type-level-numbers 0.1.0.1 - Type level numbers implemented using type families.  http://hackage.haskell.org/package/type-level-numbers-0.1.0.1 (AlexeyKhudyakov)
12:21:34 <sbahra> mm_freak_, ping?
12:22:51 <wires> Are there any mirrors of http://moonpatio.com/vacuum ?
12:27:33 <JuanDaugherty> wat's it about wires?
12:28:10 <wires> About vacuum, see http://hackage.haskell.org/package/vacuum and don's demonstration here http://www.youtube.com/watch?v=A1wtQ_mYHHo
12:29:26 <JuanDaugherty> there seems to be something there (@ hackage)
12:29:50 <mjrosenb> is ticky profiling only meant to be used for people who are working on ghc?
12:31:33 <JuanDaugherty> presume you mean tricky
12:32:28 <JuanDaugherty> rather than say, tacky
12:35:57 <TomMD> JuanDaugherty: No, there is a profiling mode called 'ticky-ticky profiling'.
12:36:12 <JuanDaugherty> ah
12:36:38 <harlekin> I'm trying to draw something with cairo + gtk2hs, but I keep getting "user error (widgetGetDrawWindow: no DrawWindow available (the widget is probably not realized))." What should that tell me?
12:36:50 <harlekin> What does realized mean?
12:37:13 <JuanDaugherty> it's ghc specific
12:37:23 <JuanDaugherty> an idiom of same
12:37:37 <kmc> harlekin, it's some operation gtk requires you to do on a widget
12:37:46 <kmc> i don't remember exactly but you can probably find it in gtk docs
12:38:05 <harlekin> kmc, thanks for the hint.
12:40:37 <harlekin> kmc, I had to show the drawing area before I could get a drawing window, in case you're interested. :) Thanks again.
12:40:56 <kmc> i'm glad you got it working :)
12:42:02 <acts_as> Are there any well-made haskell packages, someone would suggest to learn from?  I'm looking for clean code, good structure, etc.
12:42:17 <kmc> xmonad is a typical example
12:42:24 <kmc> there are some good talks about its internals
12:42:31 <kmc> working with X has an inherent ugliness though
12:46:07 <astory> is there an idiomatic way to implement a dynamic programming algorithm (like the Viterbi algorithm) in Haskell efficiently?  None of the solutions I can come up with are beautiful.
12:47:49 <tromp__> memoization is pretty beautiful
12:48:10 <djahandarie> But that doesn't work if the program needs to be done bottom-up
12:48:11 <mauke> astory: I like to use arrays
12:48:12 <kmc> astory, most DP problems can be understood as memoized recursion
12:48:23 <path[l]> almost all dynamic programming algorithms can be rewritten using memoization right
12:48:24 <astory> kmc: I am aware, and this one can.  Is therea  clean way to do memoization?
12:48:25 <kmc> the MemoTrie and data-memocombinators packages are good for that
12:48:26 <luite> have a look at data-memocombinators
12:48:33 <astory> ok, I'll take a look, thanks :D
12:48:43 * djahandarie likes MemoTrie for very simple things
12:48:44 <luite> data-memocombinators is awesome for experimenting with DP
12:48:46 <kmc> they use laziness in a really clever way to get you memoization without explicit mutable data, even in the implementation
12:48:48 <tromp__> e.g. for parition numbers:
12:48:50 <tromp__> import qualified Data.MemoCombinators as Memo
12:48:51 <tromp__> pents=zip(cycle [1,1,-1,-1])$scanl(+)1$do k<-[1..];[k,2*k+1]
12:48:53 <tromp__> p=Memo.integral q where q 0=1;q n=sum.map(\(s,k)->s*p(n-k))$takeWhile((<=n).snd)pents
12:49:00 * kmc read that as "pants"
12:49:53 <astory> tromp__: I'll need to take a little bit of time to grok that; what's it do?
12:50:01 <djahandarie> That seems to be somewhat golfed
12:50:13 <tromp__> it computes partition numbers
12:50:43 <tromp__> the number of ways to write n as an ordered sum
12:50:51 <astory> oh, cool
12:51:01 <djahandarie> astory, http://stackoverflow.com/questions/5223498/efficient-table-for-dynamic-programming-in-haskell see Jake McArthur's response
12:51:15 <djahandarie> It makes it pretty clear what you need to do
12:51:20 <djahandarie> That one uses MemoTrie
12:52:30 <astory> thanks for the help, this channel rocks
12:52:46 <djahandarie> :-)
12:53:15 <warrenharris> question: Is there a way for cabal to build multiple libraries in a single project? I want my main program to be able to load one of several statically compiled plugins.
12:53:17 <luite> tromp__: hmm, haven't they found a closed form for that recently?
12:53:50 <edwardk> djahandarie: the short answer is there is no purely functional data structure capable of meeting all of the desired asymptotics
12:53:57 <djahandarie> luite, they have? O.o
12:54:14 <djahandarie> edwardk, huh? What is this a response to? :P
12:54:29 <dcoutts_> warrenharris: sorry, not at the moment. Have to use multiple packages.
12:54:40 <edwardk> djahandarie: the dynamic-programming link: O(1) construction, O(1) lookup, memoized
12:54:40 <mjrosenb> should a standard install of ghc should install libHSrts_debug_p.*
12:54:42 <tromp__> luite: i think they did. but it's way more complicated than this program:(
12:55:23 <edwardk> djahandarie: you ultimately need O(log n) to find the value referenced in a pointer machine, or you need some sort of hashing structure.
12:55:24 <warrenharris> dcoutts_: so I need to make separate subdirs each with a cabal file?
12:55:40 <luite> yeah I like the recursive formulation as a dp example, easy to understand an not too trivial :)
12:55:42 <djahandarie> edwardk, makes sense
12:55:47 <astory> edwardk: but hashes' worst-case runtime is not O(1)
12:55:58 <dcoutts_> warrenharris: yes
12:56:08 <warrenharris> ok - thx
12:56:30 <edwardk> astory: you can lean on amortized/expected
12:56:37 <kmc> ugh
12:56:49 <djahandarie> kmc, here to complain about asymptotics? ;)
12:56:51 <astory> edwardk: even so, if you're growing your hash table as you go you've still got log(n) addition time
12:56:52 <kmc> yes
12:57:09 <kmc> log n < 100
12:57:32 <mjrosenb> astory: well if you use arrays, and can resize the array, it will be amortized constant time.
12:57:51 <b52> what do i need to do generate a haddock doc?
12:57:57 <mjrosenb> kmc: i feel less certain of that assertion that log* n < 5
12:57:57 <kmc> it's insane that we write real software based on whether some Algorithms 101 textbook has the words "O(1)", and not based on profiling or cache behavior or anything else
12:58:05 <astory> mjrosenb: no, if you're doubling the array every time you reach your chosen saturation, that amortizes out to log2(n)
12:58:13 <edwardk> astory: you can amortize even that with a witold litwin style sorted linear hash table
12:58:14 <mzero> b52 - does your project have a .cabal file?
12:58:20 <b52> not yet
12:58:28 <mzero> add one
12:58:31 <mzero> then "cabal haddock"
12:58:32 <b52> so i should create one?
12:58:38 <b52> sounds fairly easy
12:58:41 <dcoutts_> cabal init
12:58:43 <mzero> yes - it is the easiest way to generate haddock
12:58:45 <edwardk> astory: you pay for the cost of splitting a bucket every time you add one
12:58:49 <kmc> you don't need to use cabal to run haddock, but it's easy
12:58:57 <mzero> exactly
12:58:58 <kmc> otherwise "man haddock"
12:59:12 * djahandarie recalls coqdock
12:59:17 <b52> :D
12:59:18 <kmc> cabal is pretty slick and confers a lot of other advantages
12:59:25 <mzero> but if you use cabal then you are assured that the docs generated exactly match the library produced
12:59:49 <astory> edwardk: I haven't seen that before, but it still seems like you have to grow the table at least log times
12:59:54 <kmc> i did an FFI project with cabal and was pleased to find that C compilation and hsc2hs Just Works
12:59:54 <astory> even if you don't have to copy the elements
12:59:57 <monochrom> "O(1)" is what you get when you send programmers-wannabe to CS schools
13:00:11 <path[l]> huh?
13:00:41 <path[l]> oh
13:00:49 <edwardk> astory: on any given insert you split exactly one bucket
13:00:57 <edwardk> astory: the asymptotics hold ;)
13:01:49 <astory> edwardk: I'd have to do a more in-depth analysis of their algorithm, which I'm not going to do right now
13:02:43 <sbahra> heh
13:04:15 <tromp__> Data.MemoCombinators seems a little more efficient than Data.MemoTrie
13:04:15 <sbahra> I remember meeting an engineer recently who said something like: "My algorithm is awesome, it is O(1)" (it was O(n^2) for n entries of data, his retort was that n = K for some constant K).
13:04:18 <edwardk> astory: np, the asymptotics are actually quite simple to check. there isn't any recursion in the splitting/copying process except to split the contents of a bucket which contains an expected O(1) elements
13:04:24 <tromp__> at least for partition numbers
13:04:52 * sbahra high fives edwardk 
13:04:56 <djahandarie> monochrom, that being the amount of knowledge they have?
13:04:59 <edwardk> sbahra: yeah even oleg isn't immune to making that sort of argument ;)
13:05:55 <edwardk> tromp__: there is always representable-tries ;)
13:06:05 <monochrom> that being they base decisions on what 1st-year books say about "O(1)"
13:06:10 <b52> how can i get a list of valid cabal Category's ?
13:06:18 <edwardk> in case you ever needed to be able to change one answer in a trie without recomputing the rest
13:06:33 <djahandarie> Hash table! For everything!
13:06:40 <dcoutts_> b52: take a look on hackage at the big package list page
13:06:44 <monochrom> and yes, if they go to CS schools they're screwed one way, if they don't go they're screwed another way.
13:06:49 <edwardk> b52: 2 minutes with perl or vi and a look at hackage's package list page ;)
13:07:16 <dcoutts_> b52: the categories (really tags) are not actually limited, but obviously it makes sense to reuse existing tags
13:07:16 <djahandarie> monochrom, you think school is necessary?
13:07:31 <monochrom> no, see my recent sentence
13:07:43 <monochrom> summary: I think screwed is necessary.
13:07:55 <sbahra> #haskell-blah
13:09:36 <path[l]> I'm not really a cs guy, but I never understood how any hash could ever be O(1)
13:09:37 <djahandarie> edwardk, yeah that's exactly what I think about monochrom too!
13:09:41 <djahandarie> Oops, wrong channel ;)
13:09:45 <edwardk> djahandarie: =)
13:09:51 <kmc> path[l], it's O(1) as long as you ignore all the ways it isn't
13:09:59 <kmc> that's the basis of Intro to Algorithms
13:10:09 <kmc> or really undergrad-level Intro to Anything
13:10:40 * hackagebot http-types 0.5 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.5 (AristidBreitkreuz)
13:10:43 <astory> kmc: so is a list :P
13:10:56 <tromp__> edwardk, how do i tell cabal to install that?
13:11:19 <tromp__> it's not in a standard repository?
13:11:40 <path[l]> it seems to be O(1) if you're willing to bound the number of items inside it. And I could make almost any algorithm O(1) if the number of elements is bounded
13:11:51 <kmc> yep
13:11:52 <mjrosenb> kmc: most systems courses will give you a slap on the wrist if you make that assumption
13:12:46 <edwardk> path[l]: hashing is O(1) only under the assumption of randomness, most growable hash tables offer O(1) insertions only if you amortize the cost of resizing (or you use Litwin style ones I mentioned above, that avoid that jagged spike in insertion times every power of 2 in size). When you perform asymptotic analysis you can worrry about worst case performance. howbad the spike will be, or amortized performance, how bad will it be over 
13:12:52 <kmc> path[l], and the amount of memory in your computer is bounded ;P
13:13:06 <mjrosenb> edwardk: cut off after "wiss it be over"
13:13:26 <edwardk> will it be over any given k operations.
13:13:41 <mjrosenb> path[l]: are you talking about the operation hash :: a -> Int, or implementing a hash table?
13:13:54 <b52> i wanna measure the timespan of an operation in ms, whats the best way to do so?
13:14:15 <djahandarie> b52, criterion is nice in general for microbenchmarks in Haskell
13:14:32 <Philippa> kmc: sure, though the biggest bound is the IPv4 address space :p
13:14:46 <kmc> the biggest bound is the number of bits in the universe
13:14:54 <astory> this kind of hashing issue led to a really long discussion with my algorithms professor :/
13:15:25 <b52> what about system.time ?
13:15:34 <path[l]> mjrosenb: the latter
13:15:45 <kmc> even if you're sold on hashing, there are better options than a flat table
13:16:21 <kmc> Data.IntMap implements a trie with the beloved "O(1) lookup" which also has cheap pure-functional updates, making it great for concurrency
13:16:30 <kmc> one of Clojure's core data structures is something similar
13:16:31 <path[l]> edwardk:  oh I see. So as long is its below the amount of ram I can address, it's O(1) ?
13:16:45 <astory> path[l]: it's true for _some_ constant!
13:17:18 <mjrosenb> kmc: oh yeah, iirc, IntMap mentions a fast merge operation that i cannot find any documentation about.
13:17:22 <path[l]> sorry, I didnt follow that astory 
13:17:52 <kmc> yeah, i don't know how that works mjrosenb
13:18:25 <burp> :t (.) (.)
13:18:26 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
13:18:34 <burp> can someone come up with a quick example for the boob operator?
13:18:59 <djahandarie> :t (Prelude..) (Prelude..)
13:18:59 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
13:19:08 <djahandarie> Might be easier to come up with one with that type signature
13:19:27 <roconnor> @free (.) (.)
13:19:27 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
13:19:59 <roconnor> @free boob ::  (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
13:19:59 <lambdabot> (forall x. h . p x = q (f x) . g) => g . f1 = f2 . k => h . boob p y f1 = boob q (f y) f2 . k
13:20:12 <jlouis> nasty :)
13:20:14 <burp> um, wtf
13:20:34 <burp> @help free
13:20:34 <lambdabot> free <ident>. Generate theorems for free
13:21:02 <mjrosenb> >(.) (.) (+) 1 ord 'a'
13:21:07 <mjrosenb> > (.) (.) (+) 1 ord 'a'
13:21:09 <lambdabot>   98
13:21:42 <mjrosenb> > map . (.) (.) (+) 1 ord $ "abc"
13:21:43 <lambdabot>   Couldn't match expected type `a -> b'
13:21:43 <lambdabot>         against inferred type `GHC.Ty...
13:22:17 <mjrosenb> > map  ((.) (.) (+) 1 ord) "abc"
13:22:19 <lambdabot>   [98,99,100]
13:22:54 <burp> boobify your code
13:23:48 <jlouis> I usually try to keep away from functions which are that comple
13:23:48 <jlouis> x
13:24:20 <Zao> jlouis: Keeping it real?
13:24:42 <mjrosenb> is there a way to ask ghc to count how many times a given function is evaluated?
13:24:58 <aavogt> profiling will do that if you put a cost centre on the function
13:25:15 <jlouis> mjrosenb: code coverage
13:25:23 <b52> how can i tell haddock to generate this new fancy looking docs?
13:25:27 <jlouis> (is another way)
13:25:33 <mzero> it does by default
13:25:38 <aavogt> b52: install a new haddock
13:25:48 <mzero> it does by default if you have a new enough haddock!
13:25:56 <mzero> (circa September 2010)
13:26:12 <jlouis> Zao: keeping it as simple as possible
13:26:46 <aavogt> jlouis: do you mean hpc for code coverage?
13:26:53 <jlouis> aavogt: yes
13:27:10 <aavogt> where does that tell you how many times?
13:27:33 <aavogt> it doesn't show up in the highlighted code
13:28:02 <tawe> @src nub
13:28:02 <lambdabot> nub = nubBy (==)
13:28:07 <tawe> @src nubBy
13:28:07 <lambdabot> nubBy eq []             =  []
13:28:07 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:28:35 <jlouis> aavogt: oh, perhaps it doesn't
13:28:59 <b52> Release of 2011.2.0.0 (stable): Mar 5, 2011. hmm?
13:29:05 <jlouis> profiling it is then
13:29:15 <aavogt> it might be in the .tix or whatever those intermediate files are
13:29:25 <jlouis> b52: it is being tested at the moment IIRC
13:30:46 * hackagebot unordered-containers 0.1.2.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.2.0 (JohanTibell)
13:31:22 <edwardk> path[l]: no that is someone else's argument. the "ints are fixed sized" argument is crap and irrelevant ;)
13:31:38 <b52> jlouis: can i get it anywhere to "test" as well? :>
13:32:33 <path[l]> edwardk:  irrelevant in the sense, that in some architecture it would be O(1) ?
13:33:36 <monochrom> ghc 7.0.2 comes with haddock 2.9.2, new enough version to get you the latest look-and-feel (default).
13:34:02 <mzero> and as a bonus - all the included docs for all the packages are in that look too
13:34:22 <edwardk> path[l]: irrelevant as in the explanation of why hash table insertion is O(1) has nothing to do with the size of pointers and integers. it works perfectly well for huge offline distributed or on-disk hash tables as well
13:34:55 <path[l]> hmm
13:37:45 <monochrom> follow the haskell platform mailing list for current progress. use http://news.gmane.org/gmane.comp.lang.haskell.platform if you like.
13:38:53 <edwardk> woohoo =)
13:39:11 <edwardk> i'm looking forward to a shiny new platform
13:39:11 <tawe> Question. There's some way to do this: foolist= [x | ...., x not in foolist] ?
13:39:36 <monochrom> it's RCing and it seems the final show-stopper is fixed.
13:39:56 <edwardk> tawe: just make a barlist, then nub it
13:40:02 <mauke> tawe: looks like a cyclic definition to me
13:40:07 <mauke> enjoy your bottom
13:40:20 <tawe> edwardk, if I do that, I get a stack overflow
13:40:23 <edwardk> mauke: nah, just crappy asymptotics
13:40:47 <hpc> tawe: you mean you want a list where each element is unique?
13:40:54 <monochrom> I'm pretty sure dons is as impatient as the rest of us, what with all his "go go go!" excitement. :)
13:41:00 <tawe> hpc, yes, no duplicates
13:41:02 <hpc> run the comprehension and put it in a Set, perhaps
13:41:06 <edwardk> tawe: how big is this list?
13:41:13 <edwardk> and are you trying to produce it lazily?
13:41:14 <hpc> dunno how that responds to infinite lists
13:41:27 <edwardk> hpc: it doesn't do well with infinite lists ;)
13:41:59 <tawe> edwardk, as a ridiculous maximun, i guess 50000000
13:42:31 <tawe> edwardk, what i mean is not adding elements in a list that are already there
13:42:36 <luite> tawe: why not graham's number
13:42:41 <edwardk> tawe: then what i'd do is define this as a sort of incremental approximation instead. take in a list of all of the ones seen so far, then generate the next element for the list by adding it to an accumulating parameter and emitting it
13:44:32 <byorgey> ...is that an exponent of 3 after the 50000000 ?
13:44:41 <tawe> yes
13:44:45 <edwardk> foo hist p | candidate `notElem` hist = candidate : foo (candidate : hist) p' | otherwise = foo hist p' -- where you generate an appropriate p' for the next test
13:45:35 <edwardk> then foo [] p0 will give you your list
13:46:05 <luite> perhaps use a set if you can use Ord
13:46:37 <edwardk> that way you don't risk what is probably happening now, in that your search to see if you have already emitted something is running into the future values that you haven't computed yet and bottoming you out
13:47:13 <edwardk> yeah feel free to replace hist with any data structure that can take advantage of the structure of your 'values seen so far', like a Set or IntSet, etc.
13:47:29 <tawe> edwardk, thanks, I'll give it a try.
13:47:51 <edwardk> since at any point in the evaluation you will have only seen a finite prefix, Set is safe there
13:48:02 <byorgey> um, if we assume only 4 bytes needed to store each element, a list of 50000000^3 elements would need about... 27000 exabytes to store.
13:48:27 <edwardk> byorgey: tawe apparently has a lot of money to blow on ram ;)
13:48:28 <byorgey> I would have said '27 foobyes' but I don't even know what comes after exa
13:48:48 <hpc> byorgey: if we assume 4 bytes to hold each element, we can just enumerate all the ints and call it a day
13:48:49 <edwardk> zetta
13:48:55 <hpc> :P
13:48:55 <luite> not yotta?
13:49:15 <edwardk> yotta is the next one up
13:49:17 <luite> ah
13:49:34 <luite> it's been a while since I bought a hard drive that big ;)
13:50:01 <astory> why not just go straight for Ackerman(G, G)?
13:50:14 <tawe> byorgey, yea, i suck at estimating... its a lot less
13:50:22 <byorgey> tawe: ok, good =)
13:50:59 <monochrom> woah, Ackerman(G, G) :)
13:51:04 <hpc> in the future, the universally accepted unit of bigness is "it's big, okay?" :P
13:51:29 <edwardk> lets see, a yottabyte would be about a hundred trillion dollars right now, so hrmm, tawe obviously has a lot of money to spend ;)
13:51:33 <hpc> or in the imperial system, "big enough"
13:52:05 <kmc> i like "metric assload" and the larger "metric fuckton"
13:52:12 <edwardk> two states worth of data centers, no big deal ;)
13:52:30 <kmc> edwardk, are you factoring in a volume discount?
13:52:32 <Maska> Hi.
13:53:07 <edwardk> kmc: not sure, do you really want the world run by Western Digital or Seagate?
13:53:47 <byorgey> hi askaM, settled on a nick yet? =)
13:54:16 <askaM> This should work temporarily.
13:54:48 <monochrom> nice, the new haskell platform builder now calls haddock
13:54:51 <tawe> edwardk, byorgey, ok, a better aproximation is 5000^3 haha.. some zeros escaped 
13:55:31 <edwardk> actually, given that he doesn't need a full yottabyte its probably closer to 270 billion dollars, which sounds a lot more reasonable.
13:56:10 <kmc> sell off a few aircraft carriers to pay for it
13:56:23 <askaM> >.>
13:56:35 <edwardk> exactly, turn off the air conditioning for troops in afghanistan for the next 13 years or so, and its covered.
13:56:59 <djahandarie> I thought that was cut already
13:57:01 <edwardk> tawe: then yeah i'd go with the approach i mentioned above
13:57:22 <edwardk> djahandarie: i hope not
13:57:44 <djahandarie> I gave up hope a long time ago
14:02:57 <mzero> monochrom: :-)
14:03:29 <b52> what does that mean? cabal: internal error: configure install plan should have exactly one local
14:03:33 <b52> ready package.
14:03:45 <dcoutts_> b52: cabal bug, fixed in the new release
14:04:00 <dcoutts_> b52: or there's a workaround if you don't want to install the latest release
14:04:09 <dcoutts_> it's on hackage, so it's easy
14:05:49 * monochrom finds a small bug in script/build.sh !
14:07:57 <basvandijk> dcoutts_: I'm trying out the new test-suite feature of cabal. Cabal complains that the test-suite needs a type. However I have added "type: exitcode-stdio-1.0". Are test-suites already supported?
14:08:09 <b52> dcoutts_: i got the latest cabal from hackage
14:09:52 <monochrom> ah, same bug has been therefore forever
14:10:34 <dcoutts_> b52: ok, if you've got the latest then you're ok, that bug is fixed. If you still have the bug, you don't have the latest.
14:10:47 <b52> cabal install cabal installed the latest
14:11:42 <dcoutts_> basvandijk: yes, in Cabal-1.10.x
14:11:59 <dcoutts_> b52: the cabal program comes from the package cabal-install
14:12:10 <dcoutts_> b52: cabal install cabal-install-0.10.2
14:12:11 <b52> oh
14:12:35 <basvandijk> dcoutts_: I'm using Cabal-1.10.1.0 and cabal-install-0.10.2
14:13:33 <dcoutts_> basvandijk: exitcode-stdio-1.0 is right
14:13:50 <basvandijk> For the record: I'm trying to rewrite my test-suite for the threads package to use the new test-suite feature: http://hackage.haskell.org/package/threads
14:14:11 <basvandijk> My .cabal already contains a "executable test-threads"
14:14:32 <basvandijk> I thought it would be as simple as replacing that with a test-suite
14:14:41 <dcoutts_> basvandijk: ok, and you're converting it from an executable to a test-suite
14:14:48 <basvandijk> indeed
14:14:56 <dcoutts_> so what's the problem exactly?
14:15:23 <basvandijk> cabal configure complains with:
14:15:25 <basvandijk> cabal: threads.cabal:60: The 'type' field is required for test suites. The
14:15:25 <basvandijk> available test types are: exitcode-stdio-1.0
14:15:41 <dcoutts_> and what does the .cabal look like?
14:16:42 <basvandijk> http://hpaste.org/44649/cabaltestsuite
14:17:05 <hpaste> BasvanDijk pasted "cabal/test-suite"  http://hpaste.org/44649
14:19:35 <dcoutts_> basvandijk: mm, looks ok
14:20:34 * basvandijk is browsing the source of Cabal
14:21:01 * hackagebot concurrent-barrier 0.1.1 - Simple thread barriers  http://hackage.haskell.org/package/concurrent-barrier-0.1.1 (JeremyFitzhardinge)
14:21:45 <frank00> project euler is hard !
14:22:06 * frank00 is sweating after 22 problems
14:22:15 <c_wraith> project euler is a horrible way to learn a programming language.  very little of it stretched programming knowledge.  nearly all of it stretches math knowledge
14:22:47 <tomh> c_wraith: then whats a good way? :)
14:23:16 <c_wraith> tomh: total immolation.  Similar to total immersion, but if you don't get stuff done fast enough, you catch on fire. :)
14:23:26 <tomh> hehe
14:23:32 <kmc> i think project euler is a good way to learn a specific small subset of Haskell
14:23:42 <kmc> eventually you have to branch out
14:23:47 <c_wraith> kmc: sure, but the first 20 problems exercise that completely.
14:23:50 <kmc> yeah
14:24:28 <shachaf> c_wraith: That's not *entirely* true.
14:24:29 <frank00> c_wraith: it's kind of fun though. But then, what's a good way to exercise haskell?
14:24:53 <tomh> maybe build a small compiler
14:24:58 <shachaf> frank00: Spend way too much time in #haskell while writing no actual Haskell code.
14:24:59 <frank00> it's not that I'm bored of reading stuff, but I need to test what I have learned!
14:25:15 <frank00> ahah shachaf 
14:25:20 <kmc> i like the "write yourself a scheme" tutorial
14:25:23 <tomh> maybe build a small data processing app
14:25:24 <kmc> (having never actually worked through it)
14:25:36 <hpc> i am a fan of the irc bot approach
14:25:38 <shachaf> kmc: Really? I think that as-a-tutorial it's pretty confusing.
14:25:40 <kmc> if you're interested in programming in general, you will come up with programs you want to write
14:25:50 <kmc> if not then why are you learning haskell ;)
14:25:52 <djahandarie> frank00, shachaf, idling here is actually how I learned most of my Haskell
14:26:00 <kmc> you can always reimplement stuff you already wrote in other languagqs
14:26:04 <frank00> nice one djahandarie !
14:26:06 <kmc> and try to make it better / faster / smaller
14:26:24 <tomh> try to solve some job interview questions using haskell
14:26:31 <tomh> and discover how much easier it is :)
14:26:33 * shachaf notes that djahandarie didn't qualify what "most of my Haskell" is. :-)
14:26:35 <aristid> tomh: sounds boring tho
14:26:48 <frank00> kmc: there is one phase, called the noob phase, when you're unsure of even writing medium stuff, so compact problems are nice
14:26:49 <djahandarie> I tend to only write code when I can't figure out something in my head
14:26:49 <tomh> aristid: its usefull
14:26:58 <kmc> frank00, it's all relative though
14:27:03 <shachaf> aristid: Perhaps you've been going to the wrong job interviews. :-)
14:27:05 <kmc> @where cs11
14:27:05 <lambdabot> I know nothing about cs11.
14:27:11 <kmc> @where+ cs11 http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
14:27:11 <lambdabot> I will never forget.
14:27:14 <kmc> i like this course
14:27:28 <frank00> thanks kmc
14:27:35 <aristid> shachaf: no, it's merely the IDEA of questions being job interview questions that suddenly makes them dull
14:27:45 <kmc> labs 1-3 have some good exercises at the same scale as Project Euler, but using more data types than just Integer
14:29:02 <frank00> I enjoy reading code more than project euler, that's a point
14:29:15 <frank00> but still, what if the ode is full of bad habits :P
14:29:21 <frank00> it's a dangerous worlds out there
14:29:37 <kmc> yep
14:29:48 <kmc> Haskell is a widely misunderstood language
14:29:55 <kmc> there's a lot of misinformation
14:30:17 <tomh> well haskell is also super hard :P
14:30:48 <kmc> that depends on your background
14:30:51 <tomh> no one has succeeded yet in explaining monads in such way that it is easy to understand :)
14:30:52 <kmc> it's hard either way
14:31:01 <kmc> but if you know Java really well, it might be harder ;P
14:31:16 <kmc> tomh, the problem is that people expect an "explanation of monads" to be more than it is
14:31:29 <kmc> "Monad" is an API.  lots of types implement that API.  they don't have much in common with each other.
14:31:38 <kmc> there, i explained monads in a way that's easy to understand ;P
14:31:42 <frank00> but they do!
14:31:58 <aristid> tomh: what you really want is an explanation of IO, not Monads. monads are trivial :)
14:32:10 <tomh> kmc, yeah that actually sounds like one of the best explainations i've seen :P
14:32:28 <tomh> aristid: I don't think I would understand monads then
14:32:57 <Boxo> But people want to understand code written in do-notation for an abstract monad, and also want to have an intuition for what the monad combinators do
14:33:21 <aristid> Boxo: playing with ghci to the rescue
14:33:56 <tomh> what monads do is easy to understand, the situations where you want to use a monad to solve a problem are hard to recognize though
14:33:58 <tomh> atleast for me
14:34:24 <djahandarie> I usually make monads 'as the need arises'
14:34:39 <tomh> yeah, when would you say 'the need arises'
14:35:02 <djahandarie> Usually realizing something is a functor is easy, then once you need to start to need applicative-like behavior, you try to make it Applicative, etc
14:35:16 <djahandarie> I guess it's just a matter of using a lot of other Monads and Applicatives
14:35:49 <djahandarie> Also, another approach is to make your type out of other types and get the Monadness for free :)
14:36:02 <tomh> hehe
14:36:17 <thoughtpolice> luke, use the types
14:36:17 <aristid> building transformer stacks
14:36:21 <frank00> meh, I want to make a little IF with haskell, I hope not to screw up in the middle of it
14:36:44 <aristid> if True a _ = a; if False _ b = b
14:37:25 <kmc> one problem is that "confused about monads" and "confused about first-class IO" and "confused about higher-kinded polymorphism" and "confused about type classes" are all communicated as "confused about monads"
14:38:11 <frank00> lyah did a great job for me
14:38:25 <frank00> (not that I am proficient with anything, it just felt a nice explanation)
14:39:16 <thoughtpolice> Boxo: for any given monad, the semantics will be different from another; most of the types implementing the Monad typeclass have nothing to do with each other. do-notation does not change this - it is merely sugar for the 'monad API' as kmc said. if you want to understand what an arbitrary monad does, you need to understand the purpose and types regardless
14:39:29 <basvandijk> dcoutts_: Do you want me to file a bug report for the test-suite type error?
14:40:31 <hpc> kmc: all that is why functor is introduced first in any reasonable tutorial
14:42:45 <dcoutts_> basvandijk: yeah, I've not tracked it down yet from a quick code inspection. It's odd as it certainly works in other cases.
14:43:56 <basvandijk> dcoutts_: ok will do
14:46:06 <augustss> howdy
14:46:21 <djahandarie> G'day
14:48:51 <dmbarbour> Are there any projects to stick OpenGL into a typeclass (so we don't need to expose all of IO directly)?
14:49:10 <shachaf> dmbarbour: A type class?
14:49:38 <aavogt> MonadIO?
14:49:50 * djahandarie suspects he meant a GADT
14:49:51 <c_wraith> or maybe MonadTrans
14:50:01 <djahandarie> Or maybe not
14:50:20 <dmbarbour> No, I mean a typeclass... as in a 'MonadGL' class.
14:50:41 <dmbarbour> (Similar in purpose to MonadIO, but with only OpenGL operations.)
14:50:43 <augustss> dmbarbour: and how would that help?
14:51:16 <dmbarbour> augustss: sandboxing, basically. I don't necessarily want code to have access to all of IO.
14:51:18 <kmc> dmbarbour, why a type class and not just a type?
14:51:33 <dmbarbour> kmc: to allow multiple implementations.
14:51:43 * kmc wonders if there's a way to write unsafeCoerce with OpenGL
14:51:47 <Bfig> jmcarthur, are you there? you suggested hlint earlier, and i wanted to try it. how do i run/compile this? i've been using hugs for all my haskell needs so far
14:52:01 <kmc> Bfig, you should probably switch to the Haskell Platform
14:52:08 <aavogt> maybe sort of like http://hackage.haskell.org/package/graphics-drawingcombinators
14:52:09 <kmc> which comes with GHC and the GHC Interactive environment ghci
14:52:11 <dmbarbour> kmc: such as, I could transparently write to a local buffer or file instead of the underlying HOpenGL  
14:52:23 <Bfig> kmc, i'll google that, thanks
14:53:03 * Bfig is downloading...
14:53:12 <monochrom> I agree with kmc about looking for insight where there is none.
14:53:20 <dcoutts_> basvandijk: definitely a parser bug. For me it seems to fail whenever the test suite section uses if conditions
14:53:33 <kmc> dmbarbour, why would that need to be a different type?
14:53:46 <kmc> setOutput :: OutputSpecifier -> GL ()
14:53:47 <dcoutts_> basvandijk: so as it happens that'll work as a workaround for you. You no longer need either condition section.
14:53:59 <monochrom> @quote nlogax array
14:53:59 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
14:54:06 <basvandijk> dcoutts_: right
14:54:11 <dcoutts_> basvandijk: you don't need the test flag and there is special support for hpc
14:54:43 <dcoutts_> basvandijk: but please file the ticket, I'll get the guy who developed the feature to take a look.
14:54:45 <monochrom> you just use arrays, you don't look for deeper philosophy. same with monads, num, show.
14:54:48 <basvandijk> dcoutts_: great it works!
14:54:59 <kmc> dmbarbour, some poorly designed languages require every new behavior to have a new type, but Haskell doesn't
14:55:05 <basvandijk> I didn't know about the special hpc support. Nice!
14:55:13 <kmc> dmbarbour, also writing to local buffers is part of OpenGL now
14:55:23 <basvandijk> Should I still file the bug?... it's almost finished
14:55:34 <dcoutts_> basvandijk: yes please, it's certainly a bug
14:55:59 <dcoutts_> basvandijk: the hpc support may be slightly ropey, it's pretty new, if you have find you complaints about it, file more tickets :-)
14:56:03 <dmbarbour> kmc: sure, I could create a 'GL' type and operate on it directly, but I'd rather match the OpenGL API.
14:56:13 <dmbarbour> kmc: that means providing a monadic interface.
14:56:39 <dmbarbour> kmc: HOpenGL currently does so, but makes every operation of type IO.
14:56:49 <dcoutts_> basvandijk: erm, lets try that again :-)  :  if you find you have complaints about it, file more tickets
14:57:21 <dmbarbour> kmc: and there are times when we need something other than OpenGL operations - such as managing textures.
14:57:35 <basvandijk> dcoutts_: I will try it out
14:57:57 <kmc> dmbarbour, you could create a GL type with a monadic API
14:58:02 <jmcarthur> Bfig: yeah, hugs is... not the most fun way to use haskell :)
14:58:28 <kmc> and doesn't "there are times when we need something other than OpenGL operations" contradict with " sandboxing, basically. I don't necessarily want code to have access to all of IO"
14:58:37 <shachaf> jmcarthur: Hugs interact well with warm fuzzy things, though.
14:58:54 <kmc> dmbarbour, you can replicate the HOpenGL API 1:1 with "GL" instead of "IO" in the return types
14:59:06 <kmc> and then provide "runGL :: GL a -> IO a"
14:59:13 * hackagebot lhs2TeX-hl 0.1.3.1 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.3.1 (AlessandroVermeulen)
14:59:14 <kmc> and that function could also take parameters
14:59:22 <Bfig> it's just what we've been told to use... but it's mostly for testing the code with fixed values, making it simple for you with the interface. i find it quite cool, althought you obviously can't use this as a programming tool of any sort
14:59:25 <kmc> like "write to OpenGL" versus "write to a file / local buffer"
14:59:44 <basvandijk> dcoutts_: http://hackage.haskell.org/trac/hackage/ticket/811 I wasn't able to attach the .tar.gz of the package because it was to large... But since you already found what is causing the bug it's not that important
14:59:47 <kmc> and no new classes are necessary
14:59:50 <shachaf> Bfig: What interface? Is that WinHugs or something?
15:00:01 <kmc> dmbarbour, i'm suspicious of type classes; I think they're overused
15:00:05 * basvandijk is going to bed now
15:00:06 <dmbarbour> kmc: a class simply hides the 'GL' type, but something like you suggest is feasible. My original question, though, wasn't how to do it. My question was: does anyone know of a project that already does it?
15:00:25 <mreh> map (\x -> liftM2 (,) (integralImage . fst $ a) (return x)) xys
15:00:37 <mreh> that a should be an x
15:00:41 <kmc> i don't dmbarbour
15:01:14 <dmbarbour> kmc: there is no contradiction on the sandboxing. My sandboxes would simply have some dedicated concepts for that.
15:01:27 <dmbarbour> kmc: (for texture management, I mean)
15:02:10 <dmbarbour> kmc: is there a reason you're suspicious of typeclasses?
15:02:52 <mreh> :t liftM (,a)
15:02:53 <lambdabot> Illegal tuple section: use -XTupleSections
15:03:03 <Bfig> shachaf, yes
15:03:18 <Bfig> by the way, why do i need a 700 mb compiler?
15:03:40 <kmc> dmbarbour, yes, i think they're overused
15:03:48 <Bfig> did you trick me into installing a huge virus kmc?
15:03:52 <dmbarbour> kmc: personally, I prefer providing every public function through typeclasses. I run into too many problems with concrete types. So I'm not seeing how they could be 'overused'. 
15:04:10 <kmc> dmbarbour, some people think "new behavior => new type"
15:04:13 <kmc> because they're used to Java or whatever
15:04:28 <kmc> when it's simpler to have a single type, which might contain IO actions or functions
15:04:33 <kmc> and a concrete API
15:04:42 <kmc> see also http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
15:04:48 <kmc> can you elaborate on your problems with concrete types?
15:05:00 <kmc> note that more overloading implies less static checking
15:12:38 <kmc> Bfig, Haskell Platform comes with a bunch of tools and libraries
15:12:59 <kmc> also it's not especially optimized for space on disk, nor is code produced by GHC in general
15:13:05 <kmc> is this actually a problem for your setup?
15:14:26 <shachaf> kmc: 700MB is a lot to download on a 56Kb/s connection. :-)
15:14:44 * ddarius downloaded all the SICP lectures on a 56kb/s connection.
15:14:55 <kmc> yeah, but i've done it, and it's not as if HP releases are frequent
15:14:57 <kmc> is Haskell Platform really 700 MB?
15:15:10 <shachaf> I have no idea. I'd expect it to be smaller.
15:15:16 <mzero> more on Mac!  almost 1G!
15:15:22 <kmc> if you are really space-limited or bandwidth-limited you can download a binary GHC and a subset of the platform source
15:15:30 <mzero> the installers are much smaller
15:16:02 <kmc> i think HP is probably optimized for the common case of someone with a broadband connection and a hard drive that cost more than $5
15:16:15 <monochrom> ghc binary is typically 100MB compressed. haskell platform source code (does not include ghc) is just 2MB compressed.
15:16:49 <ddarius> Five dollars?!
15:16:59 <jmcarthur> i like the explanation about the wisdom of specifying termination in A Practical Theory of Programming: "One can complain about a computation if and only if one observes behavior contrary to the specification. For that reason, specifying termination without a practical time bound is worthless."
15:17:08 * ddarius wonders how many people are thinking of "In Living Color."
15:17:16 <monochrom> yes jmcarthur :)
15:17:24 <dmbarbour> kmc: Monadic typeclasses essentially specify little-languages (DSLs) without binding you to a specific implementation. A concrete type for a language is much less extensible, and much less reusable. You might see Oleg's justifications for using typeclasses in  http://www.cs.rutgers.edu/~ccshan/tagless/jfp.pdf .
15:17:52 <kmc> yeah i've read that paper
15:17:55 <kmc> it is a cool trick
15:18:15 <hai> i have a doubt: i did, as suggested here, and opened a .wav with hcodecs. What am I suppossed to pass to the fast fourier transform function( say, fft from Numeric.TTF) ?
15:18:32 <djahandarie> Is there any current GHC extension that changes the core grammar and allows other stuff in kinds besides * and k_1 -> k_2 ?
15:18:46 <kmc> dmbarbour, a lot of the stuff you could do with "finally tagless" is better done with GADTs in GHC
15:19:13 <kmc> dmbarbour, and it's not true that concrete types imply a single implementation.  like I said, that's Java thinking
15:19:16 <monochrom> well actually there is a viable objection. you could open up the source code and prove termination or prove non-termination. but in practice a proof of termination includes a time bound already (even though a loose one), no work is really saved by throwing it away at the end.
15:19:27 <kmc> your single type can store infinitely flexible values, like functions
15:19:38 <jmcarthur> mzero: 1GB?! that's almost as much as MacTeX! :P
15:19:44 <kmc> or it can be a syntax tree that can be traversed many ways
15:20:08 * shachaf doesn't remember Haskell being this huge.
15:20:08 <dmbarbour> kmc: "a single type, which might contain IO actions" - at this point, you have already bound yourself to a particular implementation, since 'IO actions' are opaque to anything but the toplevel.
15:20:31 <kmc> if you look around you'll find many monadic DSLs that are very flexible using concrete types
15:20:44 <dmbarbour> kmc: I make plenty use of functions.
15:20:49 <kmc> dmbarbour, sure, if you need that kind of flexibility, then store something other than an IO action
15:20:50 <mzero> c'mon - it's 52 packages -- each in regular and profiled form, and docs
15:20:57 <mzero> and the compiler and interpreter
15:20:58 <jmcarthur> monochrom: yes, but the context of this statement is the specification of the program, not the incidental information discovered while proving its conformance
15:21:00 <mzero> and docs for btoh
15:21:10 <monochrom> windows installers and mac installers seem to be 100M - 200M.
15:21:30 <mzero> on Mac, it expands to about 900MB when installed
15:21:46 <revenantphx> meh disk space is cheap
15:21:56 <monochrom> we have not reached the point of "download 700MB over 56kbps" yet
15:22:21 <kmc> dmbarbour, classes and instances are not first-class citizens in Haskell; you can't easily scope them or abstract over them or even control their importing
15:22:41 <t-cell> Question: How do I the memory usage of a program? If the program exceeds a certain limit, I want it to automatically quit. 
15:22:45 <revenantphx> Hell, 700mb downloads for me in around 4 minutes.
15:22:48 <mzero> 650MB is GHC & base libs, 230MB are the additional HP libs
15:23:02 <t-cell> > let f x = f (x+1) in f 1
15:23:08 <heatsink> djahandrie: Unboxed types are also allowed (they are a different kind) and someone's experimenting with adding type-level natural numbers.
15:23:12 <shachaf> revenantphx: That reflects on your connection; it doesn't mean 700MB is reasonable.
15:23:16 <kmc> dmbarbour, so i'm suspicious of API designs that make heavy use of these features, when alternatives are available
15:23:24 <lambdabot>   thread killed
15:23:30 <heatsink> *djahandarie
15:23:36 <kmc> t-cell, you can do it at the OS level, or you can set a GHC RTS option
15:23:37 <dmbarbour> kmc: it isn't clear to me how that's a problem. Instances are always associated with a type, for which you can scope over and control importing.
15:23:43 <monochrom> please drop the 700MB figure already.
15:23:50 <djahandarie> Ah right, should check out the type-level nats extension
15:23:50 <t-cell> How do I *cap* the memory usage of a program?
15:23:51 <djahandarie> Thanks
15:23:57 <shachaf> monochrom: I like it, though. It's the size of a CD image.
15:23:57 <kmc> dmbarbour, i can't use "instance" inside "let".
15:23:59 <monochrom> (unless you refer to disk space after installation)
15:24:17 <monochrom> but it is not the size of haskell platform compressed
15:24:39 <heatsink> djahandarie: Sorry I don't remember where to get that extension.  It's not in mainline GHC.
15:24:46 <jmcarthur> t-cell: if you build with -rtsopts, you can say +RTS -M1g to cap the heap at 1 GB
15:24:47 <mzero> no - for Mac that's about 190MB -- I'm not sure why it is so much smaller on windows
15:24:50 <monochrom> I mean, brag about "downloading 200MB takes me 5 seconds", sure.
15:24:53 <djahandarie> Yeah I've seen it before already, no problem
15:24:59 <shachaf> Bfig has probablty downloaded 700MB by now.
15:25:07 <heatsink> ok
15:25:11 <jmcarthur> t-cell: that is, after building your program you can run it with that `+RTS -M1g' stuff as command line arguments
15:25:34 <dmbarbour> kmc: it isn't clear to me why you'd want to use "instance" inside "let". Instances just define a set of global functions - an alternative to concrete global functions.
15:25:48 <jmcarthur> dmbarbour: why global?
15:26:07 <kmc> dmbarbour, why do we have Data.List.sortWith?
15:26:18 <kmc> err sortBy
15:26:28 <mee> t-cell: ulimit (man bash) might be useful
15:26:32 <jmcarthur> dmbarbour: local means that you could, say, use a particular monoid on a type that permits more than one option without requiring newtype wrappers
15:27:31 <jmcarthur> kmc: admittedly, sortOn would typically be a lot cleaner than sortBy. i bet there is a nice generalization to other kinds of higher order functions
15:27:42 <dmbarbour> jmcarthur: with monad typeclasses, you're free to construct a monad transformer with a few functions to do the same.
15:27:42 <kmc> sometimes you need sortBy though
15:27:45 <shachaf> kmc: Maybe Haskell should just support local instances. :-)
15:27:53 <kmc> there are some problems with local instances too
15:28:04 <jmcarthur> dmbarbour: i don't see how that's an argument against local instances
15:28:05 <kmc> what if you build a Map with one Ord instance, and then search it with a different Ord instance
15:28:33 <kmc> dmbarbour, another alternative for very cheap abstraction is to make two modules that export functions with the same names
15:28:34 <jmcarthur> kmc: yeah the only way around that would be if Map carried its own instance
15:28:35 <dmbarbour> jmcarthur: I never argued against local instances. I simply stated what exists today.
15:28:44 <kmc> lazy vs strict ByteString, Map vs. IntMap, etc
15:28:57 <kmc> jmcarthur, and performed an equality check on instances?
15:29:14 <jmcarthur> kmc: no. just used it instead of some other in-scope instance
15:29:20 <dmbarbour> kmc: we use 'sortWith' to avoid ad dependency on Ord.
15:29:25 <jmcarthur> kmc: would require dependent types or something for type checking, though
15:29:32 <kmc> jmcarthur, what about when you merge two maps?
15:29:32 <kmc> yeah
15:29:38 <shachaf> kmc: Unfortunately modules are a bit heavyweight to make. And also can't be locally redefined.
15:29:42 <jmcarthur> kmc: basically boils down to agda's implicit parameters sort of stuff
15:29:45 <monochrom> while you hope for local instances, use your own dictionary passing as an interim solution
15:30:02 <kmc> dmbarbour, what if we already have an instance of Ord, why would we still want sortWith?
15:30:20 <kmc> btw GHC's implicit parameters extension already acts much like "local instances"
15:30:31 <dmbarbour> kmc: it's useful to have Ord so you have something to pass to 'sortWith' without threading it through the whole program
15:30:32 <kmc> and has the same confluence problems that jmcarthur and i were discussing just now
15:30:39 <jmcarthur> monochrom: dictionary passing is the only viable implementation i can think of anyway. implicit parameters can make it more type-class-like
15:30:46 <kmc> dmbarbour, sort = sortWith compare
15:30:57 <dmbarbour> kmc: yep
15:30:59 <kmc> you don't need to "thread through" compare, it's a Prelude name
15:31:24 <kmc> anyway, the point here is that "sort" is convenient, but "sortWith" is the more general API and does some things "sort" can't
15:31:26 <dmbarbour> kmc: but if you didn't have typeclasses, you wouldn't have 'compare' at all
15:31:39 <jmcarthur> sumWith (+)
15:31:55 <kmc> yeah
15:31:56 <kmc> note that i never argued that we should get rid of type classes
15:31:57 <jmcarthur> (okay okay, that's just foldl1)
15:32:17 <kmc> what i'm saying here is that the Data.List API would be cleaner and simpler if they relied less on type classes
15:32:36 <jmcarthur> i somewhat agree
15:32:39 <monochrom> is implicit parameters officially blessed again by ghc 7.0.2? the user guide doesn't have "deprecated for now, will come back" any more
15:32:53 <kmc> monochrom, maybe it came back due to typechecker fixes?
15:33:07 <ezyang> monochrom: I can look at the darcs logs, if you want me to. 
15:33:26 <dmbarbour> kmc: I'll grant it would be nice to have a simplified constructor that can turn a record of functions into a typeclass.
15:33:30 <jmcarthur> higher order functions instead of type classes are in some sense equivalent. but it's easier to be more specific without type class boilerplate if you just define higher order functions
15:33:43 <monochrom> no, please don't overwork yourself and look at the darcs logs
15:34:08 <ezyang> I can't tell if you're being sarcastic or not :-) 
15:34:39 <jmcarthur> darcs changes -p 'implicit parameters'   is pretty simple
15:34:43 <monochrom> not sarcastic. not important enough to really look.
15:35:12 <heatsink> Where's a good place to ask about implementation details of GHC?
15:35:28 <ezyang> Here, or #ghc 
15:36:07 <ezyang> monochrom: I don't see anything that would obviously indicate a change from one state to antoher. I'd probably try to trace back the commit that changed the docs. 
15:36:09 <heatsink> Ok, I'll try the GHC channel 
15:55:53 <bss03> Semi-OT, but has anyone here played with XMonad + KDE SC 4?
15:56:31 <kmc> i don't mind that kind of OT at all, but there is an #xmonad channel should #haskell be unhelpful
15:56:42 <bss03> Or, maybe more to the point, can XMonad handle merging two unrelated apps into a single tabbed window?
15:56:52 <bss03> Hrm, maybe I'll look there.
16:10:51 <hpaste> BrianHV pasted "CountdownTimer"  http://hpaste.org/44651
16:11:41 <BrianHV> stylistic/syntactic question in paste kindly specified by hpaste 
16:12:54 <heatsink> BrianHV: Use record syntax to match a constructor and ignore all its fields
16:13:07 <heatsink> foo x@(RunningTimer {}) = ...
16:13:14 <BrianHV> aaah, neat
16:13:39 <BrianHV> thanks!
16:13:45 <heatsink> yup
16:14:04 <kmc> yeah, it works even if RunningTimer was not declared as a record
16:14:22 <kmc> i wonder whether this is a happy accident of the spec
16:14:26 <BrianHV> I really wish I could liberate the start and stop functions from IO, but I don't see a good way of doing that
16:14:50 <jmcarthur> ooh we have an hpaste bot now?
16:15:10 <monochrom> R{} is a neat trick
16:15:17 <kmc> BrianHV, did you want more general advice?
16:15:23 <BrianHV> kmc: sure!
16:15:24 <monochrom> hpaste bot has been active for a few days
16:15:27 <kmc> your lines are really long
16:15:36 <BrianHV> true
16:15:55 <kmc> «return $ t»  ->  «return t»
16:16:13 <shachaf> kmc: That suggestion appears on the bottom of the page. :-)
16:16:16 <kmc> yep
16:16:17 <kmc> for your "let" you can use the "let in do" syntax
16:16:22 <weirdo> how does @pl work?
16:16:28 <kmc> meaning, drop the "in" from that line, and indent "return" back to flush with "let"
16:16:32 <monochrom> @pl \x -> x
16:16:32 <lambdabot> id
16:16:46 <weirdo> i know, i know, but how is it implemented?
16:16:47 <parcs> weirdo: magically
16:16:52 <weirdo> :-)
16:17:03 <weirdo> @pl \xs xs == reverse xs
16:17:03 <lambdabot> (line 1, column 8):
16:17:03 <lambdabot> unexpected "="
16:17:03 <lambdabot> expecting pattern or "->"
16:17:07 <monochrom> someone wrote a lot of rewrite rules and heuristics
16:17:09 <kmc> BrianHV, startTimer t = liftM2 RunningTimer (currentTime t) getCurrentTime
16:17:14 <weirdo> @pl \(xs -> == reverse xs)
16:17:14 <lambdabot> (line 1, column 6):
16:17:15 <lambdabot> unexpected "-"
16:17:15 <lambdabot> expecting operator or ")"
16:17:16 <heatsink> kmc: It's explicitly stated that an "empty" record pattern works for constructors that weren't declared as records. 
16:17:24 <weirdo> damn i already forgot the syntax?
16:17:25 <parcs> :t (==) `ap` reverse
16:17:29 <lambdabot> forall a. (Eq a) => [a] -> Bool
16:17:31 <kmc> stopTimer t = liftM StoppedTimer (currentTime t)
16:17:32 <elliottt> @pl \xs -> xs == reverse xs
16:17:32 <lambdabot> ap (==) reverse
16:17:35 <kmc> alternatively:
16:17:44 <kmc> startTimer t = RunningTimer <$> (currentTime t) <*> getCurrentTime
16:17:53 <kmc> stopTimer t = StoppedTimer <$> currentTime t
16:18:21 <BrianHV> kmc: oh, nice. I like that a lot better. both of those.
16:18:33 <kmc> liftM* is from Control.Monad
16:18:42 <kmc> <$> and <*> from Control.Applicative
16:18:45 <jmcarthur> stopTimer = fmap StoppedTimer . currentTime
16:19:09 <parcs> or even StoppedTimer .: currentTime if you use the functors package
16:19:14 <jmcarthur> hehe
16:19:19 <kmc> it turns out that the more general Applicative class is enough to give you the lifting functions, so there's also liftA, liftA2 etc
16:20:25 <Ocean> @pl (\x -> (x, f (g x)))
16:20:25 <lambdabot> ap (,) (f . g)
16:20:35 <Ocean> wuh
16:20:42 <Ocean> :t ap
16:20:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:21:07 <kmc> (r -> (a -> b)) -> (r -> a) -> (r -> b)
16:21:19 <elliottt> :t <*>
16:21:20 <lambdabot> parse error on input `<*>'
16:21:23 <elliottt> :t (<*>)
16:21:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:21:32 <Ocean> :t (,) :: forall (m :: * -> *) a b. m (a -> b)
16:21:33 <lambdabot>     Couldn't match expected type `m' against inferred type `(->) a'
16:21:33 <lambdabot>       `m' is a rigid type variable bound by
16:21:33 <lambdabot>           an expression type signature at <interactive>:1:14
16:22:01 <Ocean> I don't understand.
16:22:11 <Ocean> @hoogle ap
16:22:12 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
16:22:12 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
16:22:12 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
16:22:14 <elliottt> :t (,)
16:22:15 <lambdabot> forall a b. a -> b -> (a, b)
16:22:34 <elliottt> Ocean: your signature has a kind error, if you're trying to write (,) that way
16:22:41 <accel> if I take haskell's RTS; rip out all the multi threaded stuff; then what remains besides a garbage collector?
16:22:43 <elliottt> the kind of m would have to be * -> * -> *
16:23:25 <Ocean> but (a -> b) :: *
16:23:35 <elliottt> yep
16:23:53 <elliottt> but you tried to use m in the place of (,)
16:23:58 <elliottt> and (,) :: * -> * -> *
16:24:04 <elliottt> (,) a b :: *
16:24:06 <elliottt> just like:
16:24:09 <elliottt> (->) a b :: *
16:24:12 <Ocean> :t ap (,)
16:24:13 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
16:25:00 <Ocean> :t (,) :: forall (m :: * -> *) a b. (Monad m) => m (a -> b)
16:25:01 <lambdabot>     Couldn't match expected type `m' against inferred type `(->) a'
16:25:01 <lambdabot>       `m' is a rigid type variable bound by
16:25:02 <lambdabot>           an expression type signature at <interactive>:1:14
16:25:35 <Entroacceptor> if I want to put everything into typeclasses, I'm still thinking OOP, right?
16:26:09 <Saizan> probably
16:26:18 <elliottt> Ocean: where are you getting that type signature?
16:26:19 <monochrom> or thinking abstract mathematics
16:26:59 <monochrom> afterall, theorem prover substrate Isabelle puts everything into type classes, too
16:27:11 <kmc> accel, once again there is no "haskell's RTS"
16:27:16 <kmc> every compiler has its own RTS
16:27:20 <kmc> they are vastly different
16:27:27 <Ocean> elliottt, from
16:27:28 <Ocean> :t ap
16:27:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:27:48 <Ocean> I'm trying to puzzle how (,) :: m (a -> b)
16:28:02 <Ocean> because ap (,) works.
16:28:05 <kmc> Ocean, m t = (r -> t)
16:28:09 <elliottt> ahhhhhhhhhhhh
16:28:15 <kmc> it's using "instance Monad ((->) r)"
16:28:17 <elliottt> ap (,) assumes that you're working in the function monad
16:28:24 <kmc> @src (->) (>>=)
16:28:25 <lambdabot> f >>= k = \ r -> k (f r) r
16:28:29 <kmc> @src (->) return
16:28:29 <lambdabot> return = const
16:28:49 <kmc> yeah, "ap (,)" forces it to be the function monad
16:28:55 <mm_freak_> sbahra_: pong
16:28:56 <kmc> through the usual process of type inference / checking
16:29:04 <sbahra_> Hi mm_freak_ 
16:29:11 <mm_freak_> hi there
16:29:19 <sbahra_> mm_freak_: Have you tried building ismtp on Windows?
16:29:56 <kmc> if you unify «m (a → b)» with «x → y → (x,y)» then you get m = (x →), a = y, b = (x,y)
16:30:52 <lispy> more quotes!
16:30:53 <elliottt> Ocean: did that help to clarify your question?
16:31:10 <Ocean> Kind of
16:31:13 <mm_freak_> sbahra_: nope, but it shouldn't be a problem, if its dependencies can be built on windows…  mainly 'dnscache', 'netlines' and 'vector'
16:31:18 <elliottt> :)
16:31:27 <lispy> «m = (x →)», «a = y», «b = (x,y)»
16:31:36 <mm_freak_> sbahra_: but wait, it depends also on the 'unix' package
16:31:40 <sbahra_> mm_freak_: Right.
16:31:46 <mm_freak_> that may be a problem
16:31:56 <sbahra_> mm_freak_: It seemed non-trivial, I only had a cursory look earlier today. Going to revisit later tonight.
16:32:09 <sbahra_> mm_freak_: Ok, thanks and thanks for ismtp.
16:32:11 <mm_freak_> i think i can make this optional, because on windows you don't have the SIGHUP problem
16:32:23 <sbahra_> mm_freak_: If you could, that would be great. :)
16:32:25 <mm_freak_> you're welcome
16:32:40 <mm_freak_> uhm
16:32:48 <mm_freak_> SIGPIPE, not SIGHUP
16:32:56 <dibblego> is there a powerset function in the standard library (that is more efficient than filterM const [True,False]) ?
16:33:07 <mm_freak_> i think i could turn this into a second package or leave it to the user entirely
16:33:22 <shachaf> @ty Data.List.subsequences
16:33:22 <lispy> dibblego: can you really expect powerset to be efficient?
16:33:23 <lambdabot> forall a. [a] -> [[a]]
16:33:30 <shachaf> dibblego: That's for lists, not for sets, though.
16:33:40 <mm_freak_> for serious applications using ismtp you'll want to ignore SIGPIPE on unix
16:33:43 <parcs> @src subsequences
16:33:43 <lambdabot> Source not found. My pet ferret can type better than you!
16:33:43 <dibblego> lispy: I expect it to be efficient to within what is possible
16:33:48 <dibblego> shachaf: ah great thanks
16:33:57 <mm_freak_> dibblego: much more efficient and also much more lazy
16:34:06 <dibblego> mm_freak_: you mean subsequences is?
16:34:13 <mm_freak_> yes
16:34:16 <dibblego> ok cheers
16:34:45 <mm_freak_> the filterM variant is just a fancy application of monads…  it's more for show rather than for serious use =)
16:34:50 <dibblego> right
16:35:06 <sbahra_> mm_freak_: Seems straight forward enough to maintain my own patch in the mean time. I'll let you know what kinds of numbers I get out of it compared to our high performance injector.
16:35:37 <kmc> Entroacceptor, i should add that doing OOP in Haskell is not always a bad idea
16:35:51 <kmc> though that too can be done without type classes
16:35:57 <mm_freak_> sbahra_: i just optimized the netlines library yesterday…  since that ismtp performs very well, but i'd be interested in a comparative benchmark
16:36:23 <sbahra_> mm_freak_: Me too, I look forward to it. I'll keep you posted.
16:36:32 <mm_freak_> sbahra_: thanks =)
16:37:37 <mm_freak_> sbahra_: also i'd be interested whether dnscache builds on windows
16:38:07 <mm_freak_> if you could drop me a note on it, i'd appreciate that a lot
16:38:11 <sbahra_> mm_freak_: Sure.
16:38:26 <sbahra_> mm_freak_: Yeah, what prompted this was a client who was using Windows as an injector. :-)
16:38:30 <mm_freak_> thanks a lot
16:40:28 <mm_freak_> sbahra_: by the way, if you're planning to do high performance stuff with lots of connections i suggest using GHC 7, because it has epoll
16:40:49 <monochrom> oh damn, the "deprecated now but will come back" type extension is impredicative polymorphism, not implicit parameters.
16:40:54 <mm_freak_> GHC 6.12 is still using select(), which is a real bottleneck
16:40:59 <shachaf> mm_freak_: Does GHC do the equivalent thing on Windows?
16:41:24 <sbahra_> mm_freak_: Yes, that's the plan.
16:41:31 <mm_freak_> shachaf: i'm not sure, but windows has no poll/epoll…  instead it has async sockets, but needs a window handle for that
16:41:49 <mm_freak_> on the other hand i don't know how well select() performs on windows, so just try it
16:42:06 <kmc> hahaha
16:42:07 <sbahra_> The bottlenecks come with the interface.
16:42:11 <kmc> you need a *window handle* to do async IO?
16:42:28 <hpaste> AlexR pasted "Illegal Delcaration"  http://hpaste.org/44652
16:42:36 <rpglover64> Hi.  I'm trying to figure out what's wrong with my cod
16:42:51 <rpglover64> cool that hpaste messages the channel
16:42:52 <shachaf> Presumably select() in Windows still won't work well with a large number of connections.
16:42:56 <kmc> is GameState a class?
16:42:58 <rpglover64> yes
16:43:11 <mm_freak_> kmc: the async winsocks API uses window events for notification, but i guess you may also be able to use something like (Msg)WaitForMultipleObjects(Ex)
16:43:18 <rpglover64> and showState is a GameState function
16:43:22 <kmc> rpglover64, GHC will technically let you do that, but it's probably not what you want
16:43:29 <kmc> that instance will overlap with *every* other Show instance
16:43:47 <kmc> the stuff before "=>" is not used to find which instance matches
16:43:48 <monochrom> there is probably a reason why the whole OS is called "windows"
16:43:55 <rpglover64> okay...
16:43:57 <kmc> it's only used to succeed or fail after picking an instance
16:44:02 <kmc> rpglover64, why not a single type for GameState?
16:44:05 * shachaf is told by some people that the Windows kernel API is actually nice.
16:44:05 <kmc> why does it need to be a class?
16:44:18 <shachaf> But I've never tried it and I'm not certain whether I want to.
16:44:24 <sbahra_> shachaf: Right, the problem will ultimately be with the interface re:select().
16:44:28 <rpglover64> in case there are different representations
16:44:35 <rpglover64> currently I'm representing it with an array
16:44:43 <rpglover64> but I could use several lists
16:44:44 <kmc> shachaf, yeah, afaik they built a nice microkernel and then implemented the terrible Win32 APIs on top
16:44:47 <kmc> not unlike modern Unixes
16:44:50 <kmc> not unlike x86 processors
16:45:16 <kmc> rpglover64, second question: why do you care about calling "show" versus "showState"?
16:45:38 <shachaf> It would be nice if there was a standard API instead of epoll/kqueue/\/dev\/poll/etc.
16:45:38 <weirdo> :t Random
16:45:38 <lambdabot> Not in scope: data constructor `Random'
16:45:39 <kmc> rpglover64, do you want two different GameState representations to coexist in the same program at the same time?
16:45:49 <weirdo> :t System.Random.Random
16:45:50 <lambdabot>     Not in scope: data constructor `System.Random.Random'
16:45:54 <kmc> hmm /dev/poll, don't know that one
16:45:55 <rpglover64> in normal operation, I don't; I was just confused why that didn't work
16:45:57 <kmc> which OS?
16:45:59 <sbahra_> shachaf: Well, libev and libevent attempt to provide this.
16:46:03 <shachaf> kmc: Solaris.
16:46:04 <mm_freak_> shachaf: well, select() is standard
16:46:12 <kmc> rpglover64, then it's probably cleaner for GameState to be an ordinary type
16:46:13 <sbahra_> shachaf: libev has API compatibility with libevent.
16:46:16 <rpglover64> and I see no reason why there shouldn't be two different GameState representations in the same program at the same time
16:46:17 <kmc> maybe imported from your choice of one of several modules
16:46:21 <mm_freak_> poll() is also standard (BSD), but windows doesn't implement it
16:46:27 <kmc> rpglover64, of course it's possible, just adds complexity
16:46:28 <mm_freak_> it also came late on linux
16:46:43 <kmc> rpglover64, a lot of people learning Haskell tend to over-use type classes
16:46:51 <shachaf> mm_freak_: Nowadays select() is implemented in terms of poll() in standard Linux, isn't it?
16:46:52 <sbahra_> shachaf: Better to use ports on Solaris, rather than /dev/poll.
16:47:04 <monochrom> in fact they tend to over-generalize and over-abstract.
16:47:16 <shachaf> sbahra_: Ah. I've never actually written code for Solaris. :-)
16:47:20 <mm_freak_> shachaf: good question, but that would mean that poll() has also a bad complexity
16:47:26 <kmc> i think functional over-abstraction is less harmful than class over-abstraction
16:47:27 <monochrom> something in OOP taught in school encourages premature generalization
16:47:39 <kmc> OOP taught in school also teaches that new behavior => new type
16:47:46 <rpglover64> It seems to me that the typeclass is cleaner in this case and I could just get away with calling showState instead of show
16:47:49 <kmc> because this happens to be a Java design flaw
16:48:00 <shachaf> mm_freak_: Well, how could poll() reasonably not have a bad complexity, given how it's called?
16:48:39 <mm_freak_> shachaf: it could build a tree before polling
16:48:59 <shachaf> mm_freak_: What do you mean?
16:49:15 <mm_freak_> shachaf: i think epoll has logarithmic complexity, IIRC
16:49:30 <kmc> i really like that Linux is going towards more and more things being fd's
16:49:45 <monochrom> get a concrete design to work before planning an abstract design. there is nothing to generalize until you have at least two specific things to unify into one.
16:49:49 <kmc> if you look at the original UNIX design, almost every sort of object that isn't an fd has turned out to be regrettable
16:49:53 <mm_freak_> shachaf: that suggests that it's using a tree of some sort
16:49:59 <shachaf> mm_freak_: Yes, but poll() can't do that.
16:50:10 <kmc> why doesn't fork() return an fd? then i could use select() to wait for children
16:50:22 <ddarius> X =:= Y ... Y =:= X, aw.
16:50:35 <sbahra_> kmc: I think a process is very different than a file. :-)
16:50:45 <sbahra_> kmc: and a lot of people regret ioctl enough as it is :-P
16:50:45 <mm_freak_> shachaf: it can, but it would still need to iterate all fds at least once…  epoll does that as a separate step
16:50:50 <rpglover64> I think of typeclasses as a cross between abstract classes and interfaces (in java) from a program design stand point, so saying that there exists an interface to use on GameState s seems clean to me; especially since it lets me enforce through types that none of my functions that work with GameState s care about its representation
16:50:51 <kmc> sbahra_, i think a socket or a named pipe is a very different than a file
16:50:56 <sbahra_> mm_freak_: Right, exactly. 
16:51:03 <shachaf> mm_freak_: Well, yes. But it still needs to do it on every call.
16:51:06 <kmc> rpglover64, you can enforce the latter by using modules instead
16:51:39 <mm_freak_> shachaf: that's my point =)
16:51:39 * hackagebot aeson 0.3.0.0 - Fast JSON parsing and generation  http://hackage.haskell.org/package/aeson-0.3.0.0 (BryanOSullivan)
16:51:48 <rpglover64> hmm
16:51:53 <rpglover64> okay
16:51:59 <ddarius> kmc: Objects are the only and best means of abstraction.
16:52:19 <rpglover64> thank you
16:52:27 <kmc> rpglover64, what you're saying isn't wrong, though
16:52:34 <mm_freak_> in fact the select() API /could/ do that, too, if you only look at the interface
16:52:40 * hackagebot riak 0.3.0.2 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.3.0.2 (BryanOSullivan)
16:52:43 <mm_freak_> but it would break a lot of applications, i guess
16:53:07 <kmc> bbl
16:54:04 <monochrom> if you have at least 10 years of experience (or you have downloaded someone else's 10 year experience) you can meaningfully speak of "I anticipate such-and-such extension 2 years down the road, so I design a type class for that future". with that much experience your prediction of the future is accurate. without such experience, it's all vain talk on the same calibre as "I'm building a toaster and I add a PCI slot to it for a f
16:54:04 <monochrom> uture email coprocessor PCI card", i.e., unrealistic vision that will never happen.
16:54:51 <monochrom> (that is, by the time people care about doing email on toasters, PCI will not be the way to do it anyway)
17:26:05 <magicman> join . fmap join === join . join   that's one version of one of the Monad laws, yes?
17:26:46 <monochrom> yes iirc
17:27:16 <edwardk> magicman: that is one way to express the associativity law
17:27:41 <Ptival> magicman: http://en.wikibooks.org/wiki/Haskell/Category_theory#The_first_law
17:27:58 <magicman> Ah, thanks :)
17:28:53 <copumpkin> The first law of category theory?
17:28:58 <copumpkin> is don't talk about category theory, I'd hope
17:29:10 <Ptival> :)
17:29:29 <monochrom> naw. is to protect categories.
17:29:29 <magicman> Hehehe.
17:31:17 <edwardk> the first law of category theory is the first law of category theory
17:33:26 <c_wraith> Don't talk about category theory?
17:33:33 <c_wraith> Is that also the second law?
17:34:35 <Axman6> the second law is that the first law conposed with itself is the first law
17:34:40 <Axman6> composed*
17:34:51 * hackagebot hmt 0.3 - Haskell Music Theory  http://hackage.haskell.org/package/hmt-0.3 (RohanDrape)
17:35:03 <edwardk> wait, i thought the second law was "A category must obey any laws given to it by mathematicians, except where such laws would conflict with the First Law."
17:35:24 <edwardk> then you can play category theory as a game -- like Fluxx
17:52:55 * hackagebot hly 0.1 - Haskell LilyPond  http://hackage.haskell.org/package/hly-0.1 (RohanDrape)
17:54:55 * hackagebot hts 0.1 - Haskell Music Typesetting  http://hackage.haskell.org/package/hts-0.1 (RohanDrape)
17:58:02 <co_dh> greeting,  I have a data type like : data t = Int8_ { unInt8 :: Int8} | Int16_ {unInt16 :: Int16} , the derived Show instance displayed as Int8_ { unInt8=1} for example.  can I make it display just 1 ? 
17:58:26 <dmwit> co_dh: Yes, write your own Show instance.
17:58:31 <co_dh> I know I can derive show myself, and do pattern match , but I'm looking for a better solution. 
17:58:43 <dmwit> co_dh: But it's generally considered bad form to do so; instead, define a pretty-printer as a separate function if you want that kind of thing.
17:59:09 <co_dh> or generic haskell, I guess. 
17:59:28 <dmwit> Generic Haskell? The show function you seem to be asking for is literally two lines long.
18:00:06 <co_dh> my data in fact has 8 parts . I only enter 2 parts here. 
18:00:20 <monochrom> 8 lines long then.
18:00:31 <kmc> you could do it with SYB also
18:00:36 <kmc> not like that's reasonable either
18:01:18 <kmc> monochrom, there's nothing more satisfying than replacing 8 lines of boring boilerplate with a hellishly complex incomprehensible 8-line template haskell expression
18:01:27 <co_dh> is it possible to use the same record name , as Int8_{ v :: Int8} | Int16_ { v :: Int16 }, so I can use v to get the value regardless the type? 
18:01:40 <kmc> co_dh, that is possible only if they have the same type
18:01:46 <monochrom> I fear the general solution is 80 lines.
18:01:47 <kmc> otherwise what is the type of "v", the function?
18:02:21 <co_dh> kmc:  yep, v's type is only known at run time. 
18:02:52 <dmwit> co_dh: You can do something with existential types. But again, it is very, very likely that doing so will be bad in the long run.
18:02:59 <co_dh> kmc: what would be the SYB solutioin? 
18:03:32 <co_dh> I don't understand existential types much. 
18:24:23 <wagle> does anyone program with the full gamut of unicode chars (the forall symbol, etc)?  what do you use to edit?
18:25:06 <astory> how can I convince a function that's decided that it only takes Int to take an Integer?
18:25:29 <kmc> wagle, when i feel the need to do that (not often) i use http://mainisusuallyafunction.blogspot.com/2010/10/typing-mathematical-characters-in-x.html
18:25:45 <kmc> Agda's emacs mode supports a ton of unicode characters
18:25:57 <kmc> astory, probably by converting with fromInteger
18:26:00 <kmc> :t (. fromInteger)
18:26:01 <lambdabot> forall a b. (Num a) => (a -> b) -> Integer -> b
18:26:10 <astory> oh, dur, I'm labelling it with int, I don't need to do that at all
18:26:30 <astory> if I don't care if it's an Int or an integer and just want a natural number, what type should I use?
18:26:40 <wagle> Integer
18:26:43 <kmc> a natural number of unbounded size?
18:26:54 <wagle> Int wraps
18:26:56 <astory> kmc: it's going to be less than 10
18:27:04 <kmc> then i'd use Int
18:27:24 <kmc> but "in principle" i think that the Prelude should only have Integer and that Int should be considered a more advanced data structure like ByteString
18:27:32 <astory> ok, cool.
18:27:52 <kmc> part of the reason to use Int is that much of the std lib uses Int
18:28:21 <astory> yeah, I'm noticing that when trying to make this conversion
18:29:07 <wagle> having to use fromInteger might make you think carefully about wrapping Int..  8)
18:29:33 <astory> I guess the inconvenience is that [1..3] creates a list of Integers
18:29:46 <wagle> depends
18:29:53 <astory> it does when I run it :/
18:30:03 <wagle> :t [1..3] :{Int]
18:30:03 <lambdabot> parse error on input `{'
18:30:13 <wagle> :t [1..3] :: [Int]
18:30:14 <lambdabot> [Int]
18:30:21 <pr> :t [1..3]
18:30:22 <lambdabot> forall t. (Num t, Enum t) => [t]
18:30:34 <kmc> [1..3] creates whatever type is needed
18:30:34 <pr> :t [1..3] :: [Rational]
18:30:35 <lambdabot> [Rational]
18:30:37 <kmc> just like 1 and 3 do
18:30:44 <astory> ah, didn't realize that'd work
18:30:46 <astory> thanks
18:30:48 <kmc> you don't need to say which type explicitly
18:30:56 <kmc> you just use it as if it were [Int] and it will be [Int]
18:31:02 <wagle> Integer is a sort of default
18:31:20 <kmc> in fact you can even make your own type Foo and have [1..3] :: [Foo]
18:31:29 <kmc> to do this you'd implement the Num and Enum type classes for Foo
18:31:47 <wagle> i did that recently
18:33:58 <wagle> the documentation isnt crystal clear on how you need to define the enum instance, but the source makes it clear
18:35:10 <wagle> yarrgh, my clocks going crazy on my quassel server machine
18:36:10 <kmc> not clear how?
18:36:17 <kmc> and which documentation?
18:39:00 <wagle> i had to define all four enum patterns, the docs imply some would be derived
18:39:28 <Ptival> Is there some syntactic sugar for something that looks like \a e -> f a 1 2 3 e ?
18:39:35 <kmc> @pl \a e -> f a 1 2 3 e
18:39:35 <lambdabot> flip (flip (flip f 1) 2) 3
18:39:49 <Ptival> that's not a tasty sugar :(
18:39:52 <kmc> indeed
18:39:58 <kmc> looks like sugar, tastes like cyanide
18:40:11 <kmc> otoh it's not really sugar, just an ordinary function... if you had lots of things of that form you could make a custom thingy
18:40:29 <kmc> wagle, you mean all of enumFrom, enumFromThen, enumFromTo, enumFromThenTo?
18:40:40 <Axman6> Ptival: you just wrote the sugar
18:40:51 <wagle> dont remember which docs, but the one highest google is worst
18:41:00 <kmc> wagle, GHC won't ever derive only part of a type class instance
18:41:09 <kmc> but when a class is defined, it can give default implementations of its methods
18:41:17 <Ptival> kmc: yeah I was just wondering if it existed something even better, like f <something> 1 2 3 <something>
18:41:23 <wagle> i meant default
18:41:25 <kmc> no Ptival, sorry :/
18:41:35 <kmc> wagle, if you look here: http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/src/GHC-Enum.html#Enum
18:41:48 <kmc> all four of those are defined in terms of fromEnum and toEnum
18:41:53 <kmc> which don't have defaults
18:41:59 <wagle> i felt that one wasnt crystal clear
18:42:12 <wagle> or maybe it was fixed
18:42:24 <Ptival> kmc: ok. It's not even something I want to use, just a question that came to my mind ^^, the lambda is already short enough I guess
18:42:27 <kmc> i'm just appealing to the actual source here :)
18:42:43 <kmc> Ptival, i do like the short "hole" syntax in some other languages
18:42:46 * wagle is juggling several sessions
18:42:50 <kmc> like clojure's #(+ 2 (* 3 %))
18:43:01 <kmc> i haven't seen a good one for >1 arg
18:43:13 <kmc> also they're less necessary in Haskell because of sections
18:43:27 <kmc> as in (2+) . (3*)
18:43:31 <wagle> kmc: oops, thats the source, that's what i was recommending
18:43:32 <kmc> but still would be useful as you noted
18:48:01 <monochrom> the haskell reports are pretty clear on the semantics and the pragmatics of Enum.
18:51:56 <wagle> i had the impression the default implementations would work for me until i read the source
18:52:44 <xplat> i sometimes get annoyed by the stdlib using Int where i want it to use Integer
18:53:17 <copumpkin> yeah, or natural
18:53:42 <xplat> but it's much more often i get annoyed by it using [Char] or such where i want it to use either Data.Text or Bytestring.Word8
18:53:58 <xplat> Data.Bytestring.Word8
18:55:41 <xplat> would not have been a problem if String were an abstract type from the beginning ... :(
18:56:08 <copumpkin> half of the benefit of it is being able to pattern match on it
18:57:33 <xplat> if half the benefit of String = [Char] is being able to pattern match on it, the total benefit must be really small
18:57:42 <copumpkin> :P
19:05:17 * hackagebot hmeap 0.9 - Haskell Meapsoft Parser  http://hackage.haskell.org/package/hmeap-0.9 (RohanDrape)
19:06:09 <Ptival> "Code up the a typical data type describing a resistor value:" < is this correct English? "the a typical"
19:06:58 <bss03> Is there a space?
19:07:30 <bss03> It should either be "the typical" or "the atypical".  ("atypical" = not "typical")
19:07:48 <Ptival> I think it's supposed to be "a typical"
19:07:56 <bss03> or, I guess "a typical" without "the".
19:08:00 <Ptival> ok
19:13:53 <wagle> should pattern match on strings using perl/etc style regexps
19:14:39 <Saul> Display all 473 possibilities? (y or n)
19:14:52 <Saul> HI, can you tell me how did I got this message?
19:15:04 <wagle> hit tab
19:15:39 <Saul> yeah, thx, I hit a key but I couldn't figure out which one
19:15:40 <wagle> you hit tab for command/filename/whatever completion
19:16:14 <Saul> you guys know your Haskell xD, thx you cool guys! KUDOS
19:16:38 <Saul> sorry for the exagerated thx, I'm just happy learning Haskell :)
19:18:23 <Saul> I sit helpful to have them in a .txt?
19:18:47 <zeke> So wait, can map be implemented simply with liftM? As far as I can tell they're functionally equivalent, just map is constrained to the List monad while liftM goes for all of them.
19:18:51 <Ptival> Saul: ?
19:19:59 <Saul> Having the 473 commands in a .txt?
19:20:54 <Ptival> how would it help?
19:21:16 <Ptival> either you open your .txt file, or you open ghci and hit tab y
19:21:31 <Saul> well, I put them there now, just in case. Well I don't know I'm new to Haskell so to me anything is a possible help
19:22:05 <Ptival> assuming you're not always in the folder of said .txt file, I find it easier to just run ghci (at least in a Linux shell...)
19:22:21 <Saul> does Haskell have an equivalent to Interbase?
19:22:51 <Ptival> Saul: what is Interbase?
19:23:13 <Saul> Ptival, I Use WIn7 and TotalCommander so I can be in the folder in few key strokes
19:23:14 <Ptival> http://en.wikipedia.org/wiki/InterBase < this?
19:23:48 <Saul> yes
19:24:18 <Axman6> haskell has bindings to many databases
19:24:26 <Ptival> Saul: well, whatever suits you. But the .txt file has some issues still (won't update itself, can't give you the type of something, can't hoogle/src)
19:26:10 <Ptival> it all depends of the way you code (I always have a ghci tab when I'm typing Haskell so it seems easier to just use it for me)... and anyway you usually don't look for a function by its name but rather by its type (> Hoogle)
19:26:20 <Saul> I know, is just for reference Ptival. Axman6, Oh I see, the little I know about Haskell is that is a very mature language so I assumed it had at least one but I wanted to know the name, but I see there are many, os is OK
19:26:45 <zeke> Saul: Haskell has an ODBC backend and the Wiki for InterBase states they provide an ODBC driver.
19:26:48 <Ptival> Saul: http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
19:27:19 <Saul> thx guys
19:27:28 <Saul> God bless you all :D
19:27:50 <astory> I'm getting terrible space complexity when running "map f . map words . lines $ list" where f is inexpensive.  Is there something I can do to make this take less space?
19:28:01 <astory> rather, a file, not a list
19:29:10 <Saul> I'm going to dinneer with my family now. I'm hopping to use Haskell in my studies (college) and in my future Thesis if all goes well, I'll let you know if so, thx again 
19:29:17 <Saul> cya
19:30:43 <Axman6> astory: try forcing the results of the that computation
19:31:22 <Ptival> astory: idk the answer to your question, just notice map f . map g is map (f . g)
19:33:27 <monochrom> you need to expose more of your program to explain time or memory usage
19:35:40 <monochrom> two ways "the exact same map f xs" are totally different:
19:36:31 <monochrom> way #1: main = print (map id [0..] !! 1000000000)
19:37:12 <monochrom> way #2: main = let y = map id [0..] in do { print (y !! 1000000000); print (y !! 0) }
19:37:26 <monochrom> totally different memory usage
19:37:49 <monochrom> in the worst case you need whole-program analysis.
19:42:48 <kmc> sadly equational reasoning does not extend to space / time consumption :/
19:44:33 <monochrom> add auxilliary functions and auxilliary parameters to win that back. Phil Wadler shows one way.
19:44:34 <Ptival> :\
19:45:04 <monochrom> for lazy evaluation, the hard part is to give "how much will I consume your answer" as a parameter.
19:46:43 <astory> Ptival: thanks, I'll try that.
19:46:47 <monochrom> but apart from that, both eager and lazy evaluations face the same problem of automatic memory management, i.e., you still need some whole-program knowledge to know "now no one holds a pointer to xs, therefore memory usage decreases"
19:47:33 <btutt> ugh. HDBC code gets fairly verbose
19:49:11 <monochrom> and the solution is similar. add one more auxilliary parameter to represent something you know about who owns what.
19:54:25 <ddarius> monochrom: Now transform all this extra parameter passing into a monad as that is the Haskell answer to manually globally transforming one's code.
20:03:07 <Ptival> m1 = f a b . g c . h d e $ l
20:03:07 <Ptival> m2 = f a b (g c (h d e l))
20:03:07 <Ptival> m3 = f a b $ g c $ h d e l
20:03:07 <Ptival> m4 = f a b . g c $ h d e l
20:03:16 <Ptival> which one do people prefer? (or something else...)
20:04:32 <rpglover64> I have a question about Data.Tree idioms
20:05:18 <rpglover64> Is it reasonable to "generate" an infinite tree and then later prune it by depth?  Would one have to decorate the nodes with depth to do so?
20:06:10 <Ptival> rpglover64: you can just create a "take" for your tree structure I guess, no need for depth in the nodes if take counts...
20:07:04 <rpglover64> Makes sense; do you know of any reason why there isn't one in the standard library (or if there is one, where to look)?
20:11:11 <Ptival> rpglover64: hum... I've never used it actually, idk why it's not already in it...
20:12:07 <rwbarton> Ptival: m1 is probably most popular, followed by m3 and m4 in some order
20:16:56 <btutt> Ugh. Too many differing ways to handle errors.....
20:21:50 <dmwit> btutt: yah
20:22:29 <Ptival> mapEveryOther1 f = zipWith ($) (cycle [f,id])
20:22:29 <Ptival> mapEveryOther2 f = zipWith ($) $ cycle [f,id]
20:22:29 <Ptival> mapEveryOther3 f = zipWith ($) . cycle $ [f,id]
20:23:35 <Boxo> mapEveryOther1 = mapEveryOther2
20:24:11 <Boxo> = mapEveryOther3
20:24:14 <Boxo> heh
20:24:24 <Ptival> Boxo: yes, I'm in a "best way to write" reflection
20:25:03 <Ptival> I like to be consistent, but here I'm sometimes puzzled :\
20:25:16 <Axman6> i would argu the first is easier to read.
20:25:19 <kmc> "($) $" just looks weird
20:25:22 <kmc> i would go with door #1
20:25:24 <Axman6> indeed
20:26:09 <Ptival> yes, in this case I'd also go with #1, but in other cases I don't like parentheses
20:26:57 <kmc> i generally like the ($) / (.) tricks to avoid parens
20:27:05 <Ptival> me too
20:27:14 <kmc> but sometimes i'll decide it looks better with parens
20:27:16 <kmc> pretty much arbitrarily
20:27:25 <Ptival> yeah, that's where I am too
20:27:40 <aavogt> the $ doesn't suggest that there is another argument there
20:28:11 <kmc> i think it's ok to be a bit arbitrary / inconsistent here
20:28:19 * ddarius suggests that blind devotion to consistency is not the optimal strategy.
20:28:35 <rwbarton> in this particular case #3 looks terrible to me
20:28:42 <kmc> something about hobgoblins
20:29:07 <kmc> :t zipWith id
20:29:08 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
20:29:12 <turiya> hi
20:29:23 <kmc> ^^^^ an acceptable substitute, if you don't mind people reading your code to have a momentary "wait, what?" moment
20:29:38 <kmc> :t \f -> zipWith id $ cycle [f,id]
20:29:39 <lambdabot> forall b. (b -> b) -> [b] -> [b]
20:29:56 <turiya> my haskell implementation of discrete convolution takes way too much time..the C version finishes under 1 sec
20:30:22 <kmc> turiya, what did you learn by profiling your code?
20:31:09 <turiya> kmc: the program does not come to a halt, i cant see the .prof file yet
20:31:29 <kmc> you can ^C it at any time and get the .prof file, i *think*
20:31:42 <kmc> or you can shrink the input size
20:32:09 <turiya> oh! is it.. i will try
20:32:53 <kmc> turiya, some simple things to check:
20:33:01 <kmc> - are you building with ghc -O2
20:33:08 <kmc> (-O is probably good enough but worth trying O2)
20:33:17 <kmc> - are you spending loads of time in garbage collection
20:33:22 <kmc> to check that: ./myprog +RTS -s
20:34:18 <turiya> i see.. 
20:34:54 <Axman6> also, sharing the code with us will help us help you a lot (sharing the C code too would be good)
20:36:18 <hpaste> turiya pasted "conv.hs"  http://hpaste.org/44653
20:36:50 <hpaste> AlexR pasted "prune to depth"  http://hpaste.org/44654
20:37:00 <btutt> *mutters that Control.Failure package should include some more examples in its wiki page*
20:37:16 <rpglover64> Does that look like a reasonable implementation of pruning for Data.Tree?
20:37:23 <hpaste> turiya pasted "conv.c"  http://hpaste.org/44655
20:37:29 <Axman6> turiya: you're using lists and wondering why the performance is a lot worse than the C version?
20:38:47 <turiya> Axman6: i also wanted to try with arrays but building an array also involves building a list first, so i thought the performance would not be too much different
20:39:07 <Axman6> you could try using vector
20:39:51 <turiya> oh! i did not know about it
20:40:59 <Axman6> turiya: you're using things like (!!) which are O(n), which is a bad idea
20:41:25 <kmc> (!!) walks through the list one by one
20:41:45 <kmc> turiya, building the array makes sense if you plan to index the structure many times after you've built it
20:41:57 <kmc> turiya, also look at Map, IntMap, and Data.Sequence
20:42:13 <kmc> i often find those to be better alternatives to the Array API
20:42:22 <Axman6> this is why i suggested vector, it takes care of all the array building for you (and the elimination of them when it can)
20:42:52 <turiya> kmc: i will take a look at them, you are right the O(n) would hurt the performance..
20:43:17 <turiya> Axman6: i will try to do this in vector and see how it goes
20:43:20 <Axman6> it looks like that algorithm could be anywhere from O(n^3) to O(n^5) (just guessing)
20:44:03 <Axman6> i've written comvolution in haskell before, and it was a lot simpler than this
20:44:08 <Axman6> sonvolution*
20:44:11 <Axman6> c* -_-
20:44:57 <turiya> Axman6: hmm.. was it using lists?
20:45:01 <Axman6> yes
20:45:16 <turiya> ah, it had better performance?
20:45:39 <Ptival> rpglover64: you might want to make "<= 0" your base case
20:45:44 <Axman6> can't remember. i think it was O(n^2)
20:46:03 <Ptival> rpglover64: I'm not quite sure why the `seq` too...
20:46:45 <rpglover64> Ptival: otherwise the subtraction thunk will grow, I think
20:47:22 <turiya> Axman6: i should improve the algorithm also then
20:50:52 <turiya> i think, from my limited experence in haskell, the naive way of writing code results in huge performance hit whereas in C it is not as much
20:51:25 <kmc> yeah
20:51:41 <kmc> but it's harder to get anything working at all in C
20:51:46 <Axman6> well of course, would you expect the same performance from C if you were using linked lists instead of arrays?
20:52:03 <kmc> high level languages are about getting /something/ working right away, and then optimizing the parts that need optimizing
20:52:24 <turiya> no but lists seem to be basic data structure in haskell and arrays in C
20:52:46 <Axman6> turiya: yes, but they should not be treated like they are the same thing
20:53:24 <turiya> Axman6: true, i feel that one has to learn haskell really well to write faster code..
20:53:31 <kmc> as you learn more about haskell you will create faster "naive" code, and also have more tricks for optimizing it when it's not fast enough
20:54:18 <Axman6> you have to learn C really well to write fast code too. it's just that when C is taught, there is an emphasis on performance, whereas in haskell there's an emphesis on clarity and ease of programming
20:54:22 <kmc> in C it's impossible to make working code.  in Python it's impossible to make fast code.  in Haskell both are possible if you work at it. ;)
20:54:49 <turiya> i have been spending a lot of time on this simple convolution trying to look at the problem from various points of view and i still am unable to reach a decent solution
20:54:58 <astory> kmc: it's not impossible to make working code in C, you just have to specify your problem around how your program works
20:55:25 <Axman6> turiya: you need to think about how to produce the result lazily, if you want to use lists
20:55:31 <kmc> ah yes astory
20:55:54 <ddarius> CPython is correct ... by definition.
20:56:55 <kmc> Axman6, i think your "emphasis" point particularly holds in terms of standard data structures
20:57:03 <Axman6> yeah
20:57:09 <Axman6> which is kind of a shame imo
20:57:16 <kmc> in Python or Java the "standard" data structures are expected to be fast, fancy, and opaque
20:57:24 <turiya> but ofcourse, i still like to program in Haskell even if it is a pitha
20:57:24 <Axman6> i'd love to see lots of standard structures that are super fast
20:57:38 <kmc> in Haskell the data structures in Prelude are intended to be simple, easy to understand, and maximally lazy
20:57:55 <kmc> i'm fine with this; i'm fine with having to import a module or two to get the fastest data structures
20:58:37 <kmc> linked lists are the "default" data structure in Haskell because you can implement them in one line of code
20:59:14 <Axman6> and most of their operations too
20:59:27 <Axman6> i would love to see a high performance haskell though
21:00:04 <Ptival> rpglover64: actually, I think my comment about your base case is wrong, there does not seem to be an "empty" Data.Tree :\
21:00:30 <Axman6> turiya: also, (fromIntegral n) * (fromIntegral n) should be the same as fromIntegral (n*n) right?
21:00:46 <turiya> Axman6: yes
21:01:43 <rpglover64> Ptival: There isn't, but it doesn't really matter; I'm fine with the first argument of "takeDepth" being the number of levels you go deeper than the root, with negative arguments being silently ignored
21:02:13 <turiya> did not think of it!
21:03:34 <turiya> is there an automatic way to compute the program complexity?
21:03:42 <Axman6> also you're recomputing (fromIntegral n) * (fromIntegral n) many times. why not use let n' = fromIntegral (n*n) in [fromIntegral i / n' |...]?
21:03:57 <turiya> by analyzing the complexity of functions within the code?
21:04:01 <Axman6> turiya: no, especially not with haskell
21:04:25 <Axman6> complexity doesn't make much sense in haskell, because something may never be run, but might have infinite complexity
21:05:15 <turiya> Axman6: i thought using "let" is akin to #define in C
21:05:24 <Axman6> no, not at all
21:05:33 <turiya> oh!
21:06:02 <Axman6> n' will only ever be evaluated once in that code
21:06:08 <turiya> if a function never gets called, we should not be bothered with its complexity? isnt that so?
21:06:18 <turiya> i see..
21:06:26 <kmc> "let" is the basic construct for introducing sharing
21:06:58 <kmc> «(1+1)*(1+1)» may compute the addition twice but «let x = 1+1 in x*x» will compute it once
21:07:21 <kmc> this is what is meant by "lazy evaluation"
21:07:26 <ddarius> The Report says nothing about that.
21:07:29 <kmc> yeah
21:07:39 <kmc> this is an "implementation detail" shared by every reasonable Haskell implementation
21:07:50 <astory> kmc: I don't see how that relates to lazy evaluation, in strict languages let behaves similarly
21:07:51 <ddarius> As is TCO which the Report also says nothing about.
21:08:01 <turiya> i shud make it a habit to use let
21:08:09 <kmc> astory, it's what distinguishes lazy eval from other strategies for implementing non-strict semantics
21:08:21 <rpglover64> personally, I prefer where to let
21:08:30 <kmc> such as call-by-name, where "let" really acts like a macro expansion and duplicates work
21:08:44 <astory> how does it work in ML?
21:09:20 <astory> the way I understood it is that it stored the value in the environment bound to the variable
21:09:23 <kmc> ML is strict so i expect "let" works in the straightforward way
21:09:50 <hpaste> Ptival pasted "takeTree"  http://hpaste.org/44656
21:09:51 <kmc> to evaluate «let x = e in b», evaluate 'e' and then evaluate 'b' in an environment with x bound to that value
21:09:58 <kmc> that's not how "let" works in Haskell
21:10:01 <astory> right, I misunderstood your reply
21:10:05 <kmc> or anyway in GHC Haskell
21:10:08 <astory> but please go on because I'm a little confused now
21:10:28 <kmc> to evaluate «let x = e in b», evaluate 'b' in an environment with x bound to a thunk which will evaluate 'e' if ever entered
21:10:30 <Ptival> rpglover64: that's what I would have written :\
21:11:49 <kmc> the evaluation of 'e' is deferred arbitrarily long, and may never happen at al
21:12:07 <astory> does ghc memoize the evaluatino of the thunk?
21:12:19 <kmc> yes, if i understand your meaning
21:12:27 <astory> ok, I get it now, thanks
21:12:30 <kmc> once the thunk has been evaluated, it is destructively overwritten with the final result
21:12:37 <astory> ahh, that makes sense
21:12:47 <kmc> that's why "let x = 1+1 in x*x" won't duplicate the addition
21:14:12 <kmc> it's kind of ironic that Haskell in the abstract is all about pure unchanging values, but is basically impossible to implement efficiently without tons of mutation behind the scenes
21:14:56 <Ptival> "write GHC in Haskell" :)
21:15:05 <kmc> most of GHC is written in Haskell
21:15:23 <astory> kmc: isn't that sort of a consequence of not running on lambda calculus hardware?
21:15:34 <astory> at some point, it has to hit machine code
21:16:20 <warrenharris> question: Is it possible to declare a function signature in a type class, and then define that function in a sub-class? (I'm getting "'foo' is not a (visible) method of class Sub")
21:16:24 <kmc> this is also how data-memocombinators / MemoTrie are able to memoize functions without invoking any stateful container explicitly
21:16:43 <kmc> the trie in question has thunks at its leaves and when you evaluate at a new function input, a thunk gets expanded into a new subtree
21:17:01 <astory> kmc: that's really clever!
21:17:02 <kmc> astory, kind of
21:17:47 <Ptival> some mutation has to happen sometimes if you ever want to compute something?
21:17:48 <kmc> if you want to talk about operational semantics for lazy evaluation without explicit mutation
21:17:54 <weirdo> @pl ((length [1, 2, 3]) - 1)
21:17:54 <lambdabot> 2
21:17:57 <kmc> then you can talk about graph reduction
21:18:02 <weirdo> @pl ((length a) - 1)
21:18:02 <lambdabot> length a - 1
21:18:14 <weirdo> hmmmmm
21:18:27 <kmc> naively lambda calculus terms are trees, but if you want to not duplicate work, you have to represent them as graphs
21:18:34 <kmc> i.e.
21:18:48 <kmc> (λx. x*x) (1+1)
21:18:51 <astory> hrm, hadn't thought of that.  I really have to get myself into a programming languages course.
21:19:04 <kmc> under non-strict lambda calculus semantics
21:19:04 <kmc> could expand to the term ((1+1)*(1+1))
21:19:15 <kmc> that is, a tree of depth 2
21:19:28 <kmc> but really the two intermediate-level nodes have to be identified somehow
21:19:38 <kmc> otherwise we will duplicate the work of evaluating them
21:19:49 <kmc> so your (*) node has two edges to the same (+) node
21:20:32 <Ptival> I see
21:21:46 <kmc> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
21:22:06 <kmc> this is the original paper describing the basic compilation strategy used by GHC
21:22:52 <Jafet> Though, insinuating that it is impure is somewhat unfair. The language is still pure, and laziness just happens to make it fast
21:23:00 <Jafet> They sound orthogonal to me
21:23:14 <kmc> if you understand this paper you can write much of a pretty good Haskell compiler
21:23:20 <kmc> yeah
21:23:38 <kmc> it's another case of "the compiler handles something ugly, so you don't have to"
21:23:45 <kmc> which is a pervasive theme in high-level languages
21:24:28 <astory> heck, even assembly -> machine code
21:25:25 <Ptival> rpglover64: still there?
21:25:29 <rpglover64> yes
21:25:30 <kmc> the CPU handles the ugly task of coordinating the electrical activity of 1,000,000,000 transistors so that the machine code doesn't have to
21:25:40 <Ptival> rpglover64: did you see my snippet?
21:25:43 <rpglover64> I did
21:25:52 <rpglover64> I like mine better :)
21:25:59 <Ptival> I guess so ^^
21:26:53 <rpglover64> but I can see that the only differences are stylistic and that seq
21:29:40 <Ptival> yes
21:32:14 <weirdo> please help, i don't understand this:
21:32:14 <weirdo> instance Functor ((->) r) where  
21:32:15 <weirdo>     fmap f g = (\x -> f (g x))  
21:32:21 <weirdo> what does 'r' stand for?
21:32:37 <Jafet> A type variable.
21:32:42 <Ptival> rpglover64: Given I don't know much about the evaluation strategy, I can't tell if the seq is helpful in this case
21:32:47 <weirdo> but it's not used anywhere in the instance body
21:33:46 <Jafet> That makes a function of type (a -> b) be an instance of Functor ((->) a), and fmap of type (a -> b) -> (b -> c) -> (a -> c).
21:34:10 <Jafet> In other words, fmap = (.)
21:34:19 <kmc> weirdo, it's like "instance Functor (Maybe r)"
21:34:35 <kmc> and yeah, the type variables aren't used in the body
21:34:43 <kmc> in standard Haskell there is no way to use them
21:34:53 <kmc> wait, no
21:34:55 <kmc> that's not true
21:34:56 <Jafet> Well that won't work, it has kind *
21:35:02 <kmc> you could use them if you put a signature on something?
21:35:07 <kmc> yeah sorry
21:35:11 <kmc> "instance Functor (Either r)"
21:35:17 <Jafet> I think you still need ScopedTypeVariables here
21:35:21 <kmc> blargh
21:35:23 <Ptival> @kind (->)
21:35:24 <lambdabot> ?? -> ? -> *
21:35:33 <kmc> i guess the variables in a "class" head matter, but the variables in an "instance" head don't
21:35:33 <Ptival> what's "??" and "?"?
21:35:52 <kmc> Ptival, GHC has a separate kind # for unboxed values
21:35:52 <c_wraith> ?? is * + unboxed values
21:35:52 <lambdabot>  is * + unboxed values
21:36:04 <kmc> ?? is * union #
21:36:04 <lambdabot>  is * union #
21:36:11 <c_wraith> hah.  ? is unboxed values, unboxed tuples, and *
21:36:16 <kmc> and ? is ?? union (#)
21:36:19 <weirdo> so in this case "->" is the function type, except it's infix, right?
21:36:20 <kmc> (#) is the kind of unboxed tuples
21:36:32 <kmc> yeah (->) is the 2-ary type constructor of function types
21:37:06 <c_wraith> weirdo: you can even create instance for (->), if the types work out right.  Look at the Arrow instance, as an example
21:37:07 <kmc> Ptival, so it's saying that a function can take a boxed or unboxed value, can return a boxed or unboxed values or an unboxed tuple, and a function itself is a boxed value
21:37:13 <Ptival> ok, idk about boxed and unboxed I'll take a look at it
21:37:24 <kmc> (unboxed tuples aren't values; they're basically a convention for multi-value return with zero overhead)
21:37:40 <kmc> Ptival, http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
21:37:43 <weirdo> c_wraith, like a funcallable object?
21:38:01 <weirdo> oh, lisp getting in the way again
21:38:02 <weirdo> :-)
21:38:10 <c_wraith> weirdo: eh, more like "functions aren't special, so they can be made instances of stuff, too"
21:38:24 <kmc> instance Show (a -> b) where { show _ = "nice try" }
21:38:46 <c_wraith> what happened to \bot's smallcheck-based show instance for functions?
21:38:47 <kmc> instance (Num b) => Num (a -> b) where { f + g = \x -> f x + g x }
21:39:15 <Jafet> > succ
21:39:15 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
21:39:16 <lambdabot>    arising from a use of `...
21:40:10 <Jafet> > (succ + sqrt) 1
21:40:11 <lambdabot>   3.0
21:40:17 <c_wraith> Oh.  it's still there.  Just overlapped with something
21:41:03 <kmc> my guess is that smallcheck provides one, and whatever defined Num for functions provides another, less useful Show instance
21:41:08 <kmc> because Show is stupidly a superclass of Num
21:41:14 <c_wraith> oh, right
21:41:19 <c_wraith> that would fit, timewise
21:41:35 <Jafet> ...and of course, instances cannot be hidden
21:41:47 <c_wraith> and...  That restriction is there because it's part of how pattern-matching on numeric values is specified
21:41:56 <c_wraith> err, on numeric literals
21:42:12 <weirdo> on another note, if i make something as a part of a "data" enumeration, can i later define it using a separate "data" declaration to make some kind of a structure?
21:42:17 <kmc> Show is??
21:42:52 <Jafet> zomg mah haskel so fuxored!
21:42:55 <c_wraith> Err.  Hmm, maybe it isn't.  Maybe it's just seen as a necessary complement to how it works.
21:43:25 <c_wraith> weirdo: Constructor names aren't allowed to collide, but if they're in different modules they don't collide if imported properly
21:44:45 <weirdo> c_wraith, i mean, define it first on RHS of "data", then LHS
21:45:03 <c_wraith> weirdo: ah, no.  A full data declaration must be in one place.
21:47:56 <weirdo> data Foo t = Bar t | Baz t; data Bar t = Bleh | Dupa t
21:47:58 <weirdo> what does that do?
21:48:21 <mjrosenb> wait, what class is used for pattern matching on numbers?
21:48:36 <c_wraith> weirdo: but I think you're slightly confused...  An enumeration type is just a bunch of alternative constructors that take zero args.  If you add arguments to the constructors, they're different types
21:52:49 <kmc> mjrosenb, Eq
21:53:49 <kmc> «case x of 1 → ...» ≡ «case x of y | y == fromIntegral 1 → …»
22:00:57 <turiya> is Data.Sequence faster than Data.Vector?
22:03:04 <c_wraith> turiya: it has different asymptotics, including better in some cases, so it's certainly better for *something*
22:03:23 <c_wraith> turiya: but in most common uses, I'd expect Data.Vector to have enough-better constant factors to be faster
22:04:04 <Ptival> I'm pondering when to use let or where too. I like the way where puts the higher-level computation first, and then describes the details in the next lines... to the point that I think I never use "top-level" let clauses
22:04:14 <turiya> for indexing elements, Sequence has O(log(min(i,n-i))) whereas Vector has O(1)?
22:04:44 <c_wraith> turiya: yes.  Sequence really only has better asymptotics for adding elements
22:04:54 <c_wraith> and removing elements, I suppose
22:05:11 <ion> My small patch made it into System.Random, yay.
22:05:15 <turiya> i see.. Vector will do the job in most cases then
22:05:22 <Ptival> plus where "scope" includes the pattern matching code iirc
22:05:41 <c_wraith> ion: what'd you change?
22:05:48 <Ptival> (I might have abused the term "scope" here)
22:06:33 <weirdo> once i finish with LYAH, what should i read next to gain a fuller understanding?
22:06:35 <c_wraith> Ptival: no, that's the right term.  but it means a where clause can't see the values bound in a pattern guard.  give and take
22:06:50 <ion> > mkStdGen (-2^31)  -- c_wraith: http://hackage.haskell.org/trac/ghc/ticket/4910
22:06:54 <lambdabot>   mueval-core: Time limit exceeded
22:07:07 <c_wraith> weirdo: Real World Haskell is good, but especially if you actually do stuff with it
22:07:33 <weirdo> c_wraith, is there something more about all the mind-bending type madness?
22:07:36 <Ptival> c_wraith: oh, can you explain me that better, I don't see it?
22:08:21 <c_wraith> Ptival: oh, pattern guards are an extension, that allow you to treat guards as pattern matches also.  If you're not using that extension, the caveat doesn't mater
22:08:23 <c_wraith> *matter
22:08:47 <Ptival> oh ok, I'll look at it then
22:10:30 <c_wraith> weirdo: I'm not sure.  I avoided that until I found myself needing something new, and asking in here, and finding out how to apply something new to solve my problem :)
22:11:14 <weirdo> i'm still trying to be able to think "functionally"
22:11:27 <c_wraith> In which case, I'd really just recommend doing stuff.
22:11:35 <c_wraith> Write some programs in haskell
22:11:35 <weirdo> i mean, with the PRNG, how am i supposed to code if i can't just call "random" anywhere, i have to keep track of the new seed?
22:11:56 <c_wraith> weirdo: that tends to not be a big deal, it turns out.
22:12:57 <weirdo> is there some IO action i can use to set a mutable variable? are there some mutable containers in haskell?
22:13:18 <kmc> turiya, Sequence is probably better for appending
22:13:42 <kmc> weirdo, yes, lots of different kinds
22:13:47 <weirdo> yay!
22:13:53 <kmc> the basic one is Data.IORef
22:13:58 <c_wraith> weirdo, there are a variety of mutable cells in haskell.  Most notably MVar, IORef, STRef, and TVar
22:14:32 <kmc> also mutable arrays
22:14:32 <c_wraith> those ones all remain distinct because the do fundamentally different things
22:14:37 <c_wraith> *they
22:14:53 <kmc> and plenty more on hackage, including some foreign imports like Judy arrays
22:15:10 <c_wraith> Well, STRef and IORef are nearly identical in what they do.  The difference is in the guarantees provided when you use them
22:17:24 <Ptival> c_wraith: thanks, this is interesting (pattern guards)
22:17:45 <kmc> weirdo, anyway, you could solve your PRNG problem with true mutable variables, or by threading the state through your functions
22:17:59 <kmc> if everything looks like RNGState -> (a, RNGState)
22:18:19 <kmc> now, it's a pain to wire all these functions together
22:18:34 <kmc> but the "do" sugar will do it for you
22:18:47 <kmc> viz. http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-State-Lazy.html
22:19:14 <weirdo> oh, by the way, is there thread-local storage?
22:19:25 <weirdo> i'd better check first, ask later
22:19:26 <weirdo> w8
22:19:35 <kmc> should also note that System.Random already has a way to get random numbers in IO with global state
22:20:00 <kmc> if you want a thread-local IORef, have your thread allocate a new IORef
22:20:31 <weirdo> right
22:20:31 <kmc> i don't know of anything special for TLS as such
22:20:48 <c_wraith> haskell threads aren't OS threads.  They're designed to be *incredibly* lightweight.
22:21:09 <c_wraith> to the point where thread-local storage feels bulky in comparison.
22:21:27 <c_wraith> What is a haskell thread?  9 words?  It's something ridiculously tiny like that.
22:21:47 <c_wraith> err, GHC thread
22:21:51 <c_wraith> I should be clear on that
22:22:17 <kmc> yeah, none of this 2 MB pthreads stack ;)
22:23:41 <weirdo> you mean green threads?
22:23:52 <weirdo> but! they block on IO
22:24:23 <c_wraith> they don't, internally
22:24:35 <c_wraith> But now we're getting into the realm of GHC IO manager magic :)
22:24:51 <c_wraith> (It's not really magic.  But it can feel that way)
22:25:41 <weirdo> it seems like coroutines and call/cc :)
22:25:56 <weirdo> i've done something like that in scheme
22:26:01 <c_wraith> There is code in the GHC runtime that makes all (well, everything built in to the standard libraries) blocking IO actually implemented in terms of non-blocking IO
22:26:23 <c_wraith> and the IO manager schedules which green threads can be run because they have IO waiting for them.
22:26:49 <c_wraith> But until they're ready to perform IO, those green threads are just in a wait queue
22:27:01 <weirdo> sweet :) and it probably has thread affinity built in?
22:27:27 <c_wraith> actually, ghc builds a single-threaded runtime by default
22:27:48 <c_wraith> if you ask it to build the multi-threaded runtime for your application, it gives you a bunch of tuning options, including thread affinity
22:29:43 <kmc> yeah, you can spawn 100,000 threads and have GHC multiplex them between 8 OS threads on your 8-core box
22:29:46 <kmc> you can also do blocking I/O in those 100,000 threads and GHC will transparently implement that with epoll / kqueue / whatever is most efficient for your OS
22:30:09 * hackagebot ghc-pkg-autofix 0.1.4 - Simple utility to fix BROKEN package dependencies.  http://hackage.haskell.org/package/ghc-pkg-autofix-0.1.4 (HiromiIshii)
22:30:26 <kmc> basically you get the benefits of async frameworks like Twisted or Node.js, but without having to manually turn your code inside out
22:31:03 <kmc> weirdo, GHC threads are unlike coroutines in that they're real preemptive threads
22:31:45 <kmc> well, sort of -- you can make an FFI call that will block preemption, but it's not the default
22:31:59 <kmc> the standard IO primitives all go through that async layer
22:32:25 <weirdo> all sounds sweet. even better than lisp, since i can't stand boxing and tag bits
22:32:29 <weirdo> as well as a few other things
22:32:35 <weirdo> though it's too bad there's no good IDE
22:32:55 <kmc> in principle a Lisp implementation could have kickass green threads like GHC does
22:32:58 <kmc> i don't know of any that do
22:33:08 <kmc> but i wouldn't
22:33:23 <kmc> what do you mean by boxing, in the Lisp context?
22:33:24 <weirdo> lisp has poor IO multiplexing support
22:33:35 <weirdo> kmc, putting values into cells of (type, value)
22:33:50 <kmc> well, the stuff i described above isn't a language feature
22:34:04 <weirdo> yeah, it was a digression
22:34:07 <kmc> it's part of how the GHC runtime implements those same 10-year-old IO primitives
22:35:10 <kmc> Haskell implementations are also allowed to reserve tag bits but GHC doesn't
22:55:54 <juhp> Cale: hi
22:56:34 <juhp> probably wrong ToD
23:09:43 <Cale> juhp: hey
23:09:55 <Cale> nah, just wasn't watching IRC
23:10:08 <Cale> (It would be the wrong time of day if I had sane sleeping hours ;)
23:13:52 <geheimdienst> cale, have you thought of getting a job as a cat? you could have sleeping hours as insane as you like
23:14:16 <Jafet> @quote moar
23:14:16 <lambdabot> tensorpudding says: lolcategory demands moarphisms
23:18:59 <levifikri> Hi, is there any function to interleave a list by some number in Haskell
23:19:13 <levifikri> for example, interleave 3 [1,2,3,4,5,6,7,8,9] => [[1,4,7],[2,5,8],[3,6,9]]
23:19:16 <Ptival> how do I know more information about the error coming from a System.Cmd.rawSystem?
23:20:20 <juhp> Cale: can lambdabot join #fedora-haskell ? :)
23:20:22 <Cale> levifikri: You could use splitEvery from the split package on hackage, and transpose, or else just write it yourself like:  transpose . map (take 3) . takeWhile (not . null) . iterate (drop 3)
23:20:28 <Cale> juhp: sure
23:20:33 <juhp> yay
23:20:49 <levifikri> Cale is it efficient?
23:21:01 <levifikri> in term of size and memory usage
23:21:08 <Cale> levifikri: sure
23:21:23 <Cale> levifikri: The code I wrote will be reasonably efficient
23:21:58 <Cale> lambdabot: @join #fedora-haskell
23:22:38 <juhp> Cale: thank you!
23:23:06 <levifikri> Cale thx
23:25:13 <Ptival> does someone know about rawSystem ExitFailure 127?
23:26:16 <geheimdienst> Ptival: sounds like the program that you started with rawSystem terminated with exit code 127
23:26:38 <geheimdienst> you'd have to look up in the man page for that program what 127 means
23:27:28 <Ptival> EKEYEXPIRED? from "ps ax"? :\
23:27:51 <mzero> > let every3 = transpose . map (take 3) . takeWhile (not . null) . iterate (drop 3) in every 3 [1..4]
23:27:52 <lambdabot>   Not in scope: `every'
23:28:00 <mzero> > let every3 = transpose . map (take 3) . takeWhile (not . null) . iterate (drop 3) in every3 [1..4]
23:28:02 <lambdabot>   [[1,4],[2],[3]]
23:28:14 <mzero> didn't know if transpose could handle that
23:28:19 <mzero> > let every3 = transpose . map (take 3) . takeWhile (not . null) . iterate (drop 3) in every3 [1..5]
23:28:21 <lambdabot>   [[1,4],[2,5],[3]]
23:28:46 * hackagebot authenticate 0.8.2.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.8.2.2 (MichaelSnoyman)
23:29:14 <Ptival> geheimdienst: seems _really_ unlikely to me :\
23:29:39 <geheimdienst> hm ... EKEYEXPIRED sounds like an errno to me, not an exit code
23:30:35 <Ptival> oh sorry :\
23:31:44 <geheimdienst> googling for exit code 127, it seems to me that it means command not found, i.e. what bash does if you say "run a bash and execute a non-existant binary"
23:32:07 <geheimdienst> let me guess, you're doing something like this: rawSystem "ps ax" []
23:32:08 <geheimdienst> :)
23:32:34 <geheimdienst> you're looking for "system" in the same package
23:32:55 <geheimdienst> or you could do: rawSystem "ps" ["ax"]
23:33:01 <Ocean> freenode needs a #graphics
23:33:08 <geheimdienst> Ptival: ^^
23:33:37 <Ocean> anybody here worked with Chakravarty's Accelerate library before?
23:33:42 <Ptival> geheimdienst: oh right =___=
23:34:00 <kmc> ln -s /bin/ps /bin/"ps ax"
23:34:01 <geheimdienst> i agree that the naming of rawSystem is a little confusing
23:34:09 <Ptival> geheimdienst: thanks ^^
23:34:14 <Ptival> not that "raw" :)
23:34:14 <geheimdienst> kmc: that works too :)
23:35:22 <Ptival> so if I want to pipe, I should use "system"?
23:36:07 <geheimdienst> presumably yes. i seem to recall that system uses a shell to execute your string. the shell can handle the pipes
23:40:02 <Ocean> That seems really roundabout.
23:40:43 <Ocean> Surely there's a library full of pre-wrapped syscalls?
23:41:00 <kmc> for "ps"?
23:41:15 <Ocean> For creating pipes.
23:41:30 <kmc> what do you want to pipe into what?
23:41:49 <geheimdienst> ocean, i think he meant a pipe as in "ls | grep", not a pipe as in fifo file
23:42:06 <Ocean> oh.
23:42:32 <geheimdienst> ceci n'est pas un pipe ...
23:42:55 <Ocean> But still,
23:43:01 <Ocean> such wrappers exist, right?
23:43:18 <kmc> the 'unix' package has the POSIX APIs
23:43:27 <kmc> and there are other packages for other syscalls, e.g. Linux ptrace
23:43:56 <kmc> fwiw i don't think "system" is a crazy way to invoke mknod()
23:44:40 <kmc> it's roundabout, in the same manner as every shell script
23:45:07 <kmc> looks like System.Posix.Files has the mknod(2) wrapper though so w/e
23:45:10 <geheimdienst> ah, wait, there's yet another meaning to "pipe". that one libc call that gives you 2 file descriptors, what you put in the one comes out on the other ...
23:45:48 <kmc> all three of these create very similar kernel structures, at least on Linux
23:47:28 <geheimdienst> yeah, they clearly are related. i guess mkfifo does 2 calls to pipe() and gives them a name in the file system. shell pipes must be implemented in terms of pipe() calls
23:48:35 <kmc> mkfifo uses the mknod() syscall
23:48:40 <Ptival> how come Haskell binaries are so big?
23:48:48 <kmc> Ptival, do you mean GHC-produced binaries?
23:48:53 <kmc> JHC produces small binaries
23:49:04 <Ptival> kmc > yes
23:49:14 <kmc> GHC statically links a bunch of libraries
23:49:19 <kmc> basically, every Haskell library you use
23:49:40 <Ptival> for a simple main = putStrLn "Hello World!", GHC produces a 669K binary
23:49:46 <kmc> yes
23:49:58 <kmc> you can use objdump to look at the stuff inside
23:50:18 <kmc> i don't think optimizing for static code size is a goal of the GHC team
23:51:07 <Ptival> ok
23:51:27 <kmc> geheimdienst, i don't think there's any way to take a fd returned by pipe() (which on Linux would be created in the "pipefs" special filesystem) and give it a name on an on-disk fs
23:51:40 <kmc> you'd have to create a pipe inode using mknod() and then open() it
23:53:22 <hpaste> robryk pasted "typecheck failure"  http://hpaste.org/44657
23:53:58 <geheimdienst> ptival, from what i understand, a haskell binary includes quite a bit of runtime. it's a little as if /usr/bin/java and your Whatever.class were baked together in a binary file. hence the size.
23:54:58 <geheimdienst> kmc, *shrug* i always thought of what pipe() does and what mkfifo does as basically the same thing, only the one is free-floating and the other is tied to a name in the filesystem
23:55:07 <kmc> yeah
23:55:18 <kmc> that's how i understand it
23:55:26 <kmc> i think the majority of the size of your "hello world" binary will be libraries, not GHC runtime system
23:56:37 <kmc> ghc --make hello_world.hs && objdump -t hello_world
23:56:52 * hackagebot html-minimalist 0.3 - Minimalist haskell html library  http://hackage.haskell.org/package/html-minimalist-0.3 (RohanDrape)
23:56:56 <mathijs> Hi all, I'm looking at the ArrowPlus instance for a stream processor. I thought I had its ArrowZero instance clear for myself, but after reading the possible <+> behavior, it seems as if another "zero value" will work as well witout breaking the monoid rules. Is this perfectly normal? or is it a sign something isn't right?
23:56:59 <kmc> you'll see that most of the global symbols start with "base_"
23:57:49 <kmc> reading assembly output from GHC is fun
23:58:13 <Ptival> ^^
23:58:19 <kniu> u srs?
23:58:42 <kmc> the code it produces is vastly different from what you'd see from a C compiler
23:58:51 <robryk> i've got a strange typing error i can't make heads or tails of
23:59:03 <robryk> could someone take a look at http://hpaste.org/44657/typecheck_failure ?
23:59:27 <kmc> what's the error?
23:59:49 <robryk> couldn't match exptected numeral against infered (a->a)->a->a
