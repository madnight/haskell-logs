00:02:17 <ddarius> Actually, it's usually the category of locally small categories, which is quite a bit more forgiving.
00:05:20 <dolio> Yeah, that's a lot more useful.
00:15:55 <dolio> So, I've started doubting whether the whole category of sets, 2-category of categories, etc. really makes things better.
00:16:22 <geheimdienst> @quote moarph
00:16:23 <dolio> Thanks to some folks at the n-category cafe.
00:17:41 * ddarius just doesn't really care about such issues.
00:18:38 <ddarius> dolio: However, you may want to look at Univalent Foundations / Homotopy Lambda Calculus.
00:18:56 <dolio> I have. That's not really what I'm talking about.
00:19:17 <ddarius> I'm not really sure what you are talking about.
00:19:37 <dolio> They have types, and then whether something is a set, category, or whatever is a definable statement inside the language.
00:20:20 <dolio> I mean more like using whether something is a set, category, etc. as a primary organizing principle.
00:20:28 <dolio> Instead of size.
00:21:17 <ddarius> I don't think anyone "organizes" things by "size" except in "foundational" contexts which most mathematicians don't really care about.
00:22:37 <dolio> Well, in type theory you often see a size hierarchy of universes these days.
00:23:27 <dolio> I'd say it's more necessary the more predicative you get.
00:23:53 <ddarius> Yes, that would fall under "foundational."  I don't think most users actually care what level they are at.
00:24:12 <ddarius> (At least as much as the system will let them get by with not caring.)
00:24:36 <dolio> Anyhow, someone pointed out to me that you can't just have all discrete categories count as sets due to the same foundational problems.
00:24:46 <dolio> Which I knew, and I wasn't proposing.
00:25:11 <dolio> But, if you think about it, if there's a distinction between sets and discrete categories, that isn't much different than small and large sets.
00:26:18 <ddarius> I don't think the purpose of a categorified hierarchy was to avoid that.
00:27:02 <pelotom> sounds like a bunch of abstract nonsense going on in here
00:29:38 * ddarius finds this definition odd: "blah together with binary relations ->^k such that for all k >= 0, if a ->^k b then a is noncanonical and b is canonical, and a ->^0 b iff a is canonical and a = b."
00:31:51 <dolio> It seems a little odd to require that b be canonical.
00:32:19 <imc> question: I have a `Positionable` and `Orientable` classes. I would like to write a RelativePositionable t class, with methods like `myLeft :: t -> Diff ("Positionable")` (as in Data.AffineSpace)
00:32:33 <dolio> Although I guess that might depend on what it's supposed to represent.
00:32:53 <imc> now I have something like class (Positionable t, Orientable t) => RelativePositionable t where ...
00:32:56 <ddarius> That's not the odd part.  The obvious example is an evaluation that's k steps from reducing to a canonical form.
00:33:22 <imc> how can I express `Diff (Positionable p)` in this case?
00:33:53 <ddarius> The odd part is that this definition requires almost no connection between these different relations.
00:34:05 <dolio> Ah, yeah.
00:34:37 <dolio> They could all be the same, really.
00:34:52 <dolio> Oh, not all.
00:35:00 <dolio> for k > 0.
00:35:19 <ddarius> I guess I'll see if this extra flexibility is used.
00:37:33 <imc> I feel like that `class (Orientable o, Positionable p) => RelativePositionable t ("something here that says that t is an o and t is a p")
00:37:38 <imc> could do the job
00:39:36 <imc> mmm class (Orientable o, Positionable p) => RelativePositionable o p t | o p -> t where ...
00:39:52 <Axman6> don't you want class (Orientable t, Positionable t) => RelativePositionable t then?
00:40:08 <Axman6> or not
00:43:36 <pelotom> anyone used graphviz with ghc7?
00:43:58 <pelotom> I'm getting "fd:10: hClose: resource vanished (Broken pipe)" when I try to do anything
00:44:24 <pelotom> not sure if it worked with ghc6, just shooting in the dark
00:57:32 <nkpart> hey, anyone know if there's a yesod irc channel?
01:06:27 <gienah> nkpart: yes #yesod however it is very quite, suggest instead using the web-devel mailing list: http://www.haskell.org/mailman/listinfo/web-devel
01:09:49 * hackagebot sbv 0.9.13 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.13 (LeventErkok)
01:10:49 * hackagebot msgpack-rpc 0.6.0.1 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.6.0.1 (HideyukiTanaka)
01:17:01 <nkpart> Is there a way I can get rid of the new type in this snippet?
01:17:03 <nkpart> https://gist.github.com/872212
01:17:33 <nkpart> I've tried various machinations of existentials and things, none of which worked
01:26:18 <quicksilver> nk
01:26:47 <quicksilver> nkpart: no, I don't think so. You often need a newtype to arrange the parameters of a complex type to match a kind signature.
01:29:25 <Boxo> > fix (==True)
01:29:37 <Boxo> > 1
01:29:46 <mauke> preflex: seen lambdabot
01:29:46 <preflex>  lambdabot was last seen on #haskell 3 hours, 13 minutes and 58 seconds ago, saying: Plugin `search' failed with: thread killed
01:32:38 <nkpart> quicksilver: thought that might be so, I see this X/unX wrapping a bit
01:33:31 <quicksilver> nkpart: we can't do type level functions without naming them (as newtypes) and making the wrapping and unwrapping a piece of syntax.
01:33:48 <quicksilver> I believe it would hurt type inference otherwise.
02:07:46 <savage> what's a good way to match a list with at least 7 entries?
02:07:49 <savage> using guards?
02:08:23 <mauke> not . null . drop 7
02:08:41 <shachaf> (>6::Nat) . genericLength ?
02:08:53 <zygoloid> f (a:b:c:d:e:f:g:_) = ...
02:09:02 <savage> haha yes I thought of that too zygoloid
02:09:20 <zygoloid> are you going to use those 7 entries for something?
02:09:25 <mauke> actually, drop 6, no?
02:09:33 <savage> yes, I will need them
02:09:44 <zygoloid> then you may as well pattern match them :)
02:09:55 <mauke> length (take 7 xs) == 7
02:09:56 <savage> but I prefer to use a map for that
02:10:16 <savage> so i wont need a reference to every entry
02:10:35 <savage> Im using a guard now, length x <= 7 = ...
02:10:44 <savage> err >=
02:10:46 <mauke> might be inefficient, depending on your data
02:10:55 <shachaf> That's why you should use genericLength and Nat. :-)
02:11:10 <savage> yes I can see why mauke
02:11:15 <savage> good point
02:11:21 <zygoloid> f xs | ys <- take 7 xs, not (null ys) = ...
02:11:28 <zygoloid> no, wailt, that's nonsense
02:11:37 <mauke> I'd go with not null / drop
02:11:42 <savage> ok who can come up with the most bloated solution? :P
02:11:52 <savage> props if you fill one line on my screen
02:11:52 <quicksilver> put a splitAt in a where clause
02:12:04 <quicksilver> and then use the "tail half" of the splitAt in the guard
02:12:25 <mauke> quicksilver: that's just drop
02:12:26 <zygoloid> quicksilver: that's icky, you'd need to peel the last element off the second half and move it to the first
02:12:37 <shachaf> Hmm, quicksilver's solution is nice if you're going to use the 7 elements later.
02:12:52 <quicksilver> mauke: yes, it is, but it's also saving the 7 elements for later.
02:12:54 <quicksilver> which apparently we wanted.
02:13:18 <mauke> oh, I thought we wanted to process all of the >=7 elements
02:13:35 <zygoloid> either you splitAt 7 (in which case the second half is meaningless) or you splitAt 6, and check the second half is non-empty (in which case the first half is not so useful)
02:13:59 <mauke> foo xs | length ys == 7 = ... where ys = take 7 xs
02:14:00 <shachaf> zygoloid: You could splitAt and then run length on the first half.
02:14:07 <shachaf> Or, well, take, yes.
02:14:10 <zygoloid> yup. but then why not just use take :)
02:14:40 <savage> I'm thinking simple recursion with a base and a recursive case, implemented with guards, is the cleanest solution
02:15:01 <shachaf> savage: Enforce it in the type system. :-)
02:15:18 <shachaf> Where did the number 7 come from, anyway?
02:15:24 <zygoloid> savage: perhaps if we knew more about your problem we could suggest a better solution?
02:15:27 <quicksilver> from a fair dice roll
02:15:31 <quicksilver> of a six-sided dice
02:15:34 <quicksilver> quite a strange event.
02:15:58 <zygoloid> depends now the die was labelled :)
02:16:14 <savage> I have a list of strings, and I want to process groups of 7 strings and return a list of data structures
02:16:24 <savage> so every group of 7 strings becomes one data structure
02:16:33 <mauke> Data.List.Split?
02:16:33 <zygoloid> this sounds like a job for Data.List.Split
02:16:55 <shachaf> zygoloid: Probably labeled [7,7,7,7,7,7].
02:17:10 <shachaf> Then every roll is equally fair, even if the die is weighted.
02:17:31 <zygoloid> shachaf: Bayes's ghost, i think you're right!
02:18:01 <shachaf> (Unless it lands on an edge, of course.)
02:18:16 <savage> hmm why is this gaurd not working: (length x) >= 7 = []
02:18:25 <savage> "Parse error in pattern: length"
02:18:37 <quicksilver> I would split your list into groups of 7 upfront then
02:19:04 <shachaf> savage: Missing a '|'?
02:19:11 <savage> Ahh!
02:19:13 <shachaf> Anyway, length is evil.
02:19:15 * savage slaps himself
02:19:22 <scree> I suppose technically the wear on the different sides of the die is uneven and depends on the value of the previous roll
02:19:27 <shachaf> We should have a variant of unsafeFoo functions for things that aren't unsafe but you don't want to do.
02:19:30 <shachaf> unwiseLength?
02:20:15 <quicksilver> clearly need a hierarchy
02:20:34 <shachaf> Or we could just use the prefix "evil" for everything.
02:20:34 <quicksilver> unwise < misjudged < unsafe 
02:20:45 <shachaf> evilFix, evilHead, evilPerformIO, evilLength
02:21:53 <savage> I'll have a look at data.list.split
02:22:02 <shachaf> quicksilver: What would be misjudged?
02:28:18 <savage> is there a convenient way to have a function replace a single value in a record?
02:28:42 <shachaf> record{field=value}
02:28:57 <quicksilver> it's just about the only convenient thing you can do with a record :)
02:29:04 <quicksilver> sadly it doesn't scale well to nested records.
02:29:40 <shachaf> misjudgeHaskellRecords
02:29:55 <savage> I have found records very useful in the past
02:30:09 * hackagebot http-types 0.5.2 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.5.2 (AristidBreitkreuz)
02:30:36 <savage> for aggregating a lot of data under a single identifier
02:31:40 <shachaf> savage: Sure, Haskell-with-records is nicer than Haskell-without-records, but they could be much nicer.
02:32:06 <savage> Yes I suppose
02:51:35 <farraj> schocka
02:51:51 <farraj> shocka
02:52:01 <quicksilver> ?
02:52:14 <aristid> did i mention recently how useful github is for collaboration?
02:52:29 <farraj> i was calling a friend, sorry about that
02:52:56 <farraj> hi, i'm so fuckin gay
02:52:58 <farraj> :)
02:53:23 <shocka> ja ta bot
02:56:21 <savage> is there a split function in haskell?
02:56:32 <sipa> :t split
02:56:46 <quicksilver> savage: there is splitAt and break
02:56:55 <quicksilver> but for more generality, see Data.List.Split
02:56:57 <quicksilver> (on hackage)
02:57:22 <savage> split "a,b,c" "," === ["a","b","c"]
02:57:30 <savage> does that exist?
02:57:37 <quicksilver> see Data.List.Split on hackage.
02:58:02 <jonkri> how can i translate the following java architecture to haskell: an abstract Logger base class, and the possibility to extend that class with something like SimpleLogger, XMLLogger, etc, where SimpleLogger and XMLLogger has different constructor/initialization parameters but otherwise export the same api (such as the Logger methods from the Logger class)?
02:58:56 <_mpu> if the api is the same it ssems that typeclasses will do the job.
02:59:06 <quicksilver> classic abuse of typeclasses.
02:59:14 <quicksilver> just use a tuple (or record) of functions for your API
02:59:31 <savage> thx quicksilver
02:59:36 <savage> Guess I'll write my own
02:59:54 <quicksilver> data Logger = { log :: String -> IO () }
03:00:03 <quicksilver> xmlLogger = Logger xmlLog
03:00:08 <quicksilver> or, more likely
03:00:11 <savage> since I don't want to rely on external libraries
03:00:19 <quicksilver> xmlLogger parameters = Logger (xmlLog parameters)
03:00:37 <Xilon> savage: Odd reasoning
03:01:52 <mauke> savage: might as well copy/paste from Data.List.Split then
03:02:01 <_mpu> can't we always use records instead of typeclasses
03:02:18 <savage> Yeah I was just going to copypaste
03:02:33 <mauke> _mpu: I'd say yes because that's what ghc does anyway
03:04:35 <quicksilver> _mpu: yes, but we can't always use typeclasses instead of records
03:04:39 <quicksilver> records are strictly more expressive
03:04:54 <quicksilver> whereas typeclasses give a convenient way to select the dictionary based on type inference.
03:05:00 <Xilon> quicksilver: I'm guessing the Logger class would have info(), debug(), trace(), etc methods
03:05:39 <jonkri> quicksilver: could the xmlLog functions that needs access to a specific state be "overloaded" (like defined as State -> String -> IO () but stored in the record as String -> IO ())?
03:05:47 <quicksilver> or just give the log function a priority parameter :)
03:05:49 <jonkri> State being parameters or whatever
03:05:57 <quicksilver> jonkri: yes, you trap it in a closure
03:06:06 <Xilon> quicksilver: true :P
03:06:18 <jonkri> quicksilver: that's freaky :)
03:06:21 <jonkri> i love it
03:06:29 <jonkri> thanks
03:06:37 <quicksilver> xmlLogger parameters = let state = .. something calculated from the parameters I suppose .. in Logger { ... stuff here can refer to 'state' ... }
03:06:49 <quicksilver> of course, that's immutable, it's more like environment than state.
03:06:55 <jonkri> true
03:06:59 <jonkri> that's ok though :)
03:07:08 <jonkri> is monads the way to go if i wanted a state?
03:07:15 <quicksilver> maybe, maybe not.
03:07:30 <quicksilver> if logging is inherently an IO thing (And maybe it is) then you could just have one or more IORefs in that 'state' part.
03:08:40 <jonkri> ok
03:23:17 <Xilon> Is the Cabal 1.10 exitcode-stdio test-suite type supposed to build the haskell file? It doesn't seem to even try (tried using a file that doesn't exist - doesn't error)
04:05:08 <Skola> what would be the simplest way to appendFile some cgiInput?
04:05:27 <Axman6> eh?
04:07:34 <parcs> @hoogle cgiInput
04:13:36 <Ptival> Where can I find info on what babel, djinn, unlambda, etc. do?
04:13:52 <quicksilver> in the lambdabot source
04:13:59 <quicksilver> or in their own separate packages if they exist.
04:15:59 <Ptival> ok :\
04:19:42 <Jafet> @help djinn
04:23:19 <Skola> sorry for the bad question about cgi. Turned out I was looking for liftIO
04:23:45 <Skola> this thinking about types is so different from what I'm used to
04:26:48 <aristid> Skola: liftIO is a bit of a clutch
04:27:02 <shachaf> @help babel
04:27:18 <shachaf> @botsadness
04:27:25 <Ptival> ^^
04:28:04 <Skola> aristid can you point me to another approach I can go try / read about?
04:28:26 <aristid> Skola: i did not say that there are better alternatives :)
04:28:32 <Skola> ;p
04:28:34 <Skola> ok
04:30:15 <Skola> this whole IO business feels dirty in Haskell for a beginner
04:31:14 <aristid> Skola: i think it's elegant. liftIO is not very elegant, but that's just one tiny piece
04:32:01 <hpc> liftIO is nice for building your own set of functionality around a transformer
04:32:05 <Skola> it could well be, like I said I'm a beginner so I won't pretend to be a good judge
04:32:09 <hpc> but should almost never be called outside helper functions
04:33:11 <parcs> it would be nice if all of the IO operations in base were abstracted to MonadIO
04:33:17 <hpc> the idea of separating IO into a type that cannot be escaped from is quite clever
04:34:17 <hpc> parcs: eh; for specific monads it can be nice to discourage arbitrary IO with the syntactic overhead from liftIO
04:34:49 <hpc> like for my CGI monad, i provide lifts for file input, databases, and printing to stdout and stderr
04:35:20 <hpc> anything else is beyond the purview of the site, so the syntax makes a nice means of discouragement
04:35:58 <Skola> hpc that's what I use it for as well
04:35:59 <quicksilver> you can of course not define or not export a liftIO method
04:36:05 <quicksilver> and then they can't use it at all.
04:36:08 <Skola> do you know where I could read more about it?
04:36:35 <hpc> about liftIO? no idea
04:37:02 <hpc> it's a fairly simple concept, modulo having to understand transformers
04:37:04 <aristid> quicksilver: or export a pleaseDontLiftIO
04:37:55 <Skola> ok still figuring out how/where (besides perhaps hoogle) I find my information
04:38:07 <parcs> google
04:38:14 <Skola> so that I don't have to bother you guys with these questions
04:38:19 <Skola> ya I know 
04:38:24 <Skola> but I'm "settling in"
04:38:43 <Skola> so trying to harvest resources
04:39:21 <parcs> well, if you ever want to know the type of something, you can use ghci or /query lambdabot
04:42:36 <parcs> but irc is still the ultimate search engine :P
04:44:41 <djanatyn> Yay, just wrote my first Haskell code :D
04:44:57 <cubi> \o/
04:45:09 <djanatyn> http://hpaste.org/44812/first_haskell_program
04:45:50 <djanatyn> It's a start. :)
04:45:51 <aristid> djanatyn: and hpaste even tells you how you can improve your program! :)
04:45:58 <djanatyn> Yeah, I noticed.
04:46:00 <hpc> :P
04:46:45 <djanatyn> Well, Haskell looks very cool.
04:47:05 <djanatyn> I know a decent amount of C, and a little bit of Python.
04:47:16 <djanatyn> The syntax is very, very appealing to me :)
04:47:23 <djanatyn> Haskell code looks pretty.
04:47:30 <aristid> it certainly can
04:47:38 <djanatyn> Very exotic, compared to most things I've looked at .
04:47:43 <djanatyn> It also seems very functional, as well :)
04:47:55 <Xilon> purely functional, even
04:48:00 <aristid> djanatyn: but please get rid of the parentheses around name
04:48:07 <aristid> putStrLn name suffices
04:48:11 <djanatyn> I did.
04:48:27 <aristid> oh, good :)
04:48:33 <djanatyn> I took a look at Learn You A Haskell, read the first chapter, and skipped to chapter 9. :)
04:48:42 <djanatyn> Sorry, beginning of the second chapter.
04:48:54 <djanatyn> Why is there such a huge wait between compiling your first program?
04:49:03 <Xilon> also: putStrLn =<< getLine
04:49:05 <hpc> djanatyn: because ghci is the coolest thing ever
04:49:10 <aristid> djanatyn: because ghci is so powerful.
04:49:10 * hpc -> work
04:49:17 <djanatyn> I suppose if it really has a good benefit, I could go through the first chapters before I actually start writing things.
04:49:20 <djanatyn> aristid: Hmm.
04:49:26 <djanatyn> Well, I have a lot of time on my hands.
04:49:31 <djanatyn> I'll work through the first few chapters.
04:49:37 <aristid> do that
04:49:43 <djanatyn> Anyway, cool. Thanks!
04:49:55 <Xilon> djanatyn: Real World Haskell is a good "hands on" book to read
04:50:03 <djanatyn> Okay, I'll check that out as well.
04:50:17 <OODavo> Why does the GHCi syntax differ from regular Haskell syntax, anyway? It's kind of confusing.
04:50:33 <Xilon> OODavo: It doesn't?
04:50:35 <Ferdirand> it doesn't
04:50:46 <MasseR> OODavo: Imagine that the GHCi environment is inside a IO () function
04:51:16 <Ferdirand> (in a do block)
04:51:16 <quicksilver> I prefer to think of GHCi syntax as the syntax of expressions.
04:51:29 <OODavo> I don't know what that means yet.
04:51:37 * OODavo goes back to Learn You A Haskell.
04:52:03 <mauke> MasseR: IO () is not a function
04:52:23 <MasseR> mauke: True. Me fail
05:11:09 <augur> byorgey: i'd like to submit a fiction story to monad.reader
05:11:14 <augur> byorgey: so here goes
05:11:34 <augur> byorgey: There was a man who intuitively understood monads.
05:12:23 <Botje> he was 7 feet tall, arms like tree trunks
05:12:31 <augur> no no, that was the end of the story
05:13:02 <augur> suspension of disbelief only goes so far.
05:19:13 <Adamant> his name was Sanders Mac Lane
05:19:49 <Adamant> he shot lightening from his eyes, and thunderbolts from his arse
05:20:18 <Adamant> also when he died in "Fight Club" everyone realized how fucked up things had gotten
05:26:31 <ManateeLazyCat> When i push patch to code.haskell.org/gtk2hs , i got error : "darcs failed:  Not a repository: AndyStewart@code.haskell.org:/srv/code/gtk2hs ((scp) failed to fetch: AndyStewart@code.haskell.org:/srv/code/gtk2hs/_darcs/inventory)" , lost repository when move server?
05:26:34 <ManateeLazyCat> Any help?
05:29:51 <dcoutts_> ManateeLazyCat: the repo is there, it's darcs-2 format I notice
05:30:07 <dcoutts_> so /srv/code/gtk2hs/_darcs/inventory is not supposed to be there I think
05:30:20 <dcoutts_> ManateeLazyCat: is your local repo darcs 2 format too?
05:31:28 <ManateeLazyCat> dcoutts_: I just use 'darcs show repo', got : "Format: hashed, darcs-2"
05:32:37 <atp> hey guys, does the GHC runtime still only context switch between threads on allocation?
05:33:05 <ManateeLazyCat> dcoutts_: I just use darcs-2.5.2 fetch source code from code.haskell.org/gtk2hs.
05:33:30 <ManateeLazyCat> dcoutts_: I remember darcs-hashed can push patch to darcs-2 repository, right?
05:33:37 <dcoutts_> ManateeLazyCat: not sure then, assuming it's not just a networking problem, ask in #darcs
05:33:52 <ManateeLazyCat> dcoutts_: Ok.
05:34:02 <dcoutts_> ManateeLazyCat: no, darcs-2 format is not compatible with darcs-1 (hashed or old style)
05:34:17 <dcoutts_> atp: yes
05:35:36 <atp> dcoutts_: so if i have a tight loop that does no allocation it's possible for one thread to live forever, more or less?
05:36:13 <dcoutts_> atp: right
05:36:33 <ManateeLazyCat> dcoutts_: Oh, maybe i need convert local repository to darcs-2 before push.
05:36:38 <atp> dcoutts_: is there a yield primitive that ensures context switching or something, à la hugs?
05:37:10 <atp> dcoutts_: i'm getting strange behavior where some thread code only seems to execute if i add in a putStrLn "DEBUG" or similar
05:37:20 <dcoutts_> ManateeLazyCat: you said it was already darcs 2 format
05:37:47 <ManateeLazyCat> dcoutts_: Yeap, i can push to gtk2hs-mirror, it at patch-tag.com
05:37:52 <ManateeLazyCat> It's strange.
05:38:08 <dcoutts_> atp: yes, there's a yield, but it's in IO
05:39:44 <atp> dcoutts_: does it actually yield or is it a compatibility no-op with non-premptive haskells?
05:39:55 <dcoutts_> atp: I think it yields
05:40:34 <atp> dcoutts_: i'll look into it, thanks for the help
05:40:36 <quicksilver> you could also use the threaded runtime and -N2
05:41:29 <atp> quicksilver: right now i'm compiling the app with -threaded, is -N2 an RTS option?
05:41:52 <quicksilver> yes.
05:42:06 <quicksilver> it schedules your haskell threads on two OS threads
05:42:16 <atp> quicksilver: oh, i see.
05:42:16 <quicksilver> so your tight loop won't block progress
05:42:22 <quicksilver> it'll just block one OS thread
05:42:38 <atp> quicksilver: i see. let me give that a try.
05:44:23 <atp> quicksilver: well, something changed, but it still fundamentally doesn't run some code... weird
05:44:39 <atp> quicksilver: and yet if i add a simple DEBUG statement into that part of the code, bam, it all executes. no other changes.
05:50:41 <jonkri> why is there no module documentation generated for this file: http://paste.pocoo.org/show/354540/
05:51:19 <jonkri> i mean at the top (i'm using runhaskell Setup.hs haddock)
06:11:50 <Xilon> Hmm weird, I think cabal is a bit broken for me. A different package, which presumably has functioning tests, doesn't run the tests either
06:25:17 <dcoutts_> Xilon: what are you doing to run the tests?
06:26:35 <tswett> @type loeb
06:26:57 <tswett> lambdabot is only noticed when absent.
06:28:13 <Xilon> dcoutts_: I wasn't running `build`! Thought it was implicit
06:30:21 <ManateeLazyCat> Which one i should contact to fix my gtk2hs account? Looks server don't allowed me push patch cause by ssh key.
06:30:26 <dcoutts_> Xilon: yeah sorry, we're going to try and improve the UI so people don't make that mistake
06:31:03 <dcoutts_> ManateeLazyCat: ah ok if you cannot log in, then email support@community.haskell.org with your username, your real name and your ssh key
06:31:19 <ManateeLazyCat> dcoutts_: Ok, thanks.
06:31:21 <savage> I have a function with a where saying 'loc = getLoc foo', and loc is of type Maybe Point
06:31:48 <savage> how do I check against the value of loc in a guard?
06:32:09 <savage> I know 'loc' is accessible in the guard (since its in the where clause)
06:32:20 <quicksilver> what kind of check would you like to do?
06:32:22 <Botje> | somePatternMatch <- loc
06:32:26 <quicksilver> | loc == Just x
06:32:34 <quicksilver> if the Maybe is of a type which permits Eq
06:32:44 <quicksilver> | fmap p loc
06:32:48 <ManateeLazyCat> dcoutts_: code.haskell.org need id_rsa.pub ? I have `id_dsa.pub` and `id_rsa.pub` under ~/.ssh, i forgot which one is for code.haskell.org
06:32:53 <quicksilver> erm
06:32:58 <quicksilver> | fmap p loc == Just True
06:33:07 <quicksilver> if 'p' is  a predicate on the type inside the maybe
06:33:32 <savage> ah that did the trick
06:33:46 <savage> (I actually had a custom type, had to make it derive Eq)
06:33:49 <savage> thanks!
06:33:54 <dcoutts_> ManateeLazyCat: doesn't matter
06:33:55 <quicksilver> Botje's clever answer is actually a very useful extension
06:33:58 <quicksilver> called PatternGuards
06:33:59 <ManateeLazyCat> dcoutts_: Ok, thanks for your help, i send mail to support@community.haskell.org
06:35:29 <roconnor> For whoever I was supposed to tell, my Lens/Multiplate paper paper is on the arXiv http://arxiv.org/abs/1103.2841
06:42:42 <ManateeLazyCat> Ok, have send mail to support@community.haskell.org , hope my account can restore
06:50:54 <tawe> >head (map (`mod` 0) [1,2,3,4,5])
06:51:24 <tawe> >head (map (mod 0) [1,2,3,4,5])
06:52:11 <tawe> @src head
06:52:22 <Axman6> lambdabot isn’t here right now
06:52:24 <applicative> lambdabot: 0
06:52:49 <applicative> head [] = error "Prelude: empty list"
06:53:05 <tawe> applicative, why is 0?
06:53:38 <zygoloid_> *** Exception: divide by zero
06:53:39 <applicative> mod 0, 0 is all there is, no?
06:53:48 <djahandarie> Anyone have a nice way to represent a congruence relation in Haskell?
06:54:08 <applicative> I take that back, its just an arbitrary decision?
06:54:10 <tawe> damn..
06:54:59 <tawe> it's always doing 0 mod a, not a mod 0 heh
06:55:41 <zygoloid> tawe: the first one is an error, the second is 0.
06:55:56 <Jafet> instance Fractional m => Num (ModuloRing m)
06:56:16 <Jafet> Er, product recall
06:56:18 <zygoloid> tawe: also, you need a space after the > for the real lambdabot to understand :)
06:56:23 <Jafet> instance Num m => Num (ModuloRing m)
06:56:30 <tawe> zygoloid, thanks :)
06:58:00 <applicative> Oh I see, yes, tawe, you took me in too. 
06:58:50 <Jafet> Why is lambdabot down? (Other than to give us humans a shot at the job)
06:58:53 <djahandarie> Relevant to Modulo stuff: http://hpaste.org/44815/more_modulo
06:59:03 <djahandarie> I just happened to be doing this :)
06:59:11 <tawe> applicative, i'm sorry, i thought i already thank you. you were originally who answered my question. 
07:00:01 <djahandarie> Haskell really needs something like Agda where I can bind S and Z to type level natural number literals.
07:00:16 <niczar6589> (noob here) in ghci, why do I get "Not in scope" when I try to declare a type?
07:00:25 <copumpkin> because you can't declare types in ghci
07:00:30 <niczar6589> (I'm trying to run the examples at http://learnyouahaskell.com/types-and-typeclasses)
07:00:32 <niczar6589> ah
07:00:32 <Jafet> djahandarie: going to implement Montgomery redc in unary encoding?
07:00:39 <Ferdirand> do you lose something useful by putting the modulus in the type level ?
07:00:47 <Xilon> niczar6589: Need to write it in a file and :load it
07:00:55 <djahandarie> Jafet, I don't plan on that, no... :P
07:01:31 <Jafet> Well, you could figure out how to make exactly the finite fields instances of Fractional.
07:01:45 <djahandarie> I can switch it to binary encoding if moar performance is needed
07:01:48 <niczar6589> thanks Xilon
07:02:02 <copumpkin> moar
07:02:05 <djahandarie> MOAR
07:02:16 <copumpkin> preflex: seen NEEDMOAR
07:02:16 <preflex>  NEEDMOAR was last seen on ##logic 29 days, 5 hours, 6 minutes and 42 seconds ago, saying: Oops.
07:02:29 * djahandarie goes to advising meeting
07:02:43 * Xilon goes to sleep
07:02:45 <Jafet> O(m^n) O(m^n) O(m)
07:07:34 <applicative> niczar6589, wait, were you trying to assign a type to an expression like "1 :: Int"  that should work in ghci.  You cant define new types in ghci
07:09:10 <applicative> niczar6589: though all the types he uses on that page should be in scope in ghci
07:10:20 <aristid> :t mconcat . catMaybes
07:10:27 <aristid> :(
07:10:38 <niczar6589> nope, I was trying this : factorial :: Integer -> Integer  \n factorial n = product [1..n] 
07:10:55 <applicative> niczar6589: write let first.  
07:11:10 <applicative> then a semicolon between the type declarations
07:11:27 <niczar6589> ah ok cool
07:11:42 <applicative> i mean, between the declaration and the function definition
07:11:50 <niczar6589> yeah that works thx
07:11:57 <applicative> I think there's now a way to do it on two or more lines, but I can't remember
07:12:13 <Jafet> forall a. (Monoid a) => [Maybe a] -> a
07:12:19 <applicative> if lambdabot were up we could give illustrations of the possibilities
07:12:28 <WatermelonStorm> Whoa.
07:12:48 <WatermelonStorm> I wrote a RLE encoder within two minutes as a Haskell newcomer.
07:12:54 <WatermelonStorm> Without references. 
07:13:00 <WatermelonStorm> Man, I love this language.
07:13:41 <copumpkin> feel the powah
07:14:29 <Jafet> groupies.
07:16:03 <Skola> I'm probably doing this wrong: http://hpaste.org/44817/uglinesss
07:16:05 <Skola> it works
07:16:18 <Skola> but this double let should probably not be necesarry?
07:16:41 <Skola> necessary*
07:17:56 <quicksilver> Skola: well, why not just inline the let?
07:18:02 <WatermelonStorm> Exactly what I thought, quicksilver...
07:18:08 <quicksilver> (let x = fromMaybe "none" myArgs in output x) ===> output (fromMaybe "none" myArgs)
07:18:33 <quicksilver> although sinc eyou do use it twice it might be worth giving it a name, once
07:18:43 <zygoloid> Skola: ttp://hpaste.org/paste/44817/uglinesss_annotation#p44818
07:19:09 <Skola> thank you!
07:19:24 <quicksilver> zygoloid: annottation-jinx ;)
07:19:26 <Skola> so you don't need the in :}
07:19:52 <Cale> Skola: yeah, inside a do-block, let without in will make definitions which scope over the remainder of the block
07:20:11 <quicksilver> Skola: another version, with the fromMaybe attached to the getArgs call
07:20:13 <quicksilver> http://hpaste.org/paste/44817/uglinesss_annotation#p44820
07:20:14 <Skola> ok :)
07:20:17 <zygoloid> hpaste.org: where your pastes are annotated in glorious stereo :)
07:20:28 <WatermelonStorm> Skola, as far as I know that's the reason why ghci wants you to use "let".
07:20:43 <quicksilver> I would normally write that fmap as <$> but that's confusing if you've not seen it before
07:20:50 <Skola> thanks quicksilver :)
07:20:54 <quicksilver> x <- fromMaybe "none" <$> getInput "args"
07:20:59 <quicksilver> is what I would actually write.
07:21:26 <WatermelonStorm> I never saw that before.
07:21:31 <zygoloid> it's in Control.Applicative
07:21:38 <copumpkin> or Data.Functor
07:21:41 <WatermelonStorm> The operator looks like it means "let money flow in both directions" or something.
07:21:48 <zygoloid> copumpkin: ooh, shiny :)
07:21:52 <copumpkin> :)
07:22:04 <WatermelonStorm> Although it's obviously not meant for that. 
07:22:10 <applicative> Skola, when you ask for output x is it supposed to show the altered file?
07:22:19 <applicative> (never used this library)
07:22:21 <copumpkin> instance Functor RobinHood
07:22:27 <niczar6589> I have a [(a,b)] and I want (a,b) whose b member is maximum, how would I go about ithis, do I have to define a new type class that impements Ord or something for my tuple?
07:22:47 <Skola> no it spits back the value of args to the webpage
07:22:59 <applicative> ord is already defined for tuples where ord is defined for the elements
07:23:05 <Cale> maximumBy (comparing snd)
07:23:06 <luite_> niczar6589: maximumBy (max `on` snd)
07:23:08 <luite_> oh
07:23:09 <Cale> If you import Data.Ord
07:23:10 <luite_> comparing
07:23:15 <Skola> I append it to an html element
07:23:19 <Skola> w/ js
07:23:29 <Cale> or you can use  compare `on` snd
07:23:33 <niczar6589> applicative: I don't care about the first element of the tuple's value, I want to sort on the second
07:23:55 <applicative> maximum $ map snd xs  ?
07:24:05 <confound> applicative: that doesn't get back the original tuple
07:24:22 <confound> (I can't tell if that's what he wants or not)
07:24:25 <applicative> confound, i thought niczar6589  didn't care
07:24:37 <niczar6589> I want the original tuple
07:24:38 <confound> he might have meant he didn't want to sort on it
07:24:48 <applicative> confound: yes i see the ambiguity
07:25:07 <niczar6589> yeah I want the max, but in my mind this was equivalent to sorting
07:25:28 <Cale> sortBy (comparing snd)
07:26:12 <zygoloid> copumpkin: because RobinHood gives rise to a static arrow?
07:26:17 <Cale> taking the head of that should still be O(n), but with a larger constant factor than using maximumBy :)
07:27:19 <confound> Cale: any reason to prefer (compare `on` snd) to (comparing snd) in either of those cases?
07:27:30 <Cale> not really
07:27:36 <Cale> though on is good to know about
07:27:41 * confound was unaware of comparing
07:28:03 <applicative> niczar6589, Cale's advice is always to be followed, but maybe more elementary things are wanted?  
07:28:20 <quicksilver> confound: comparing predates on.
07:28:20 <niczar6589> I'm looking at the doc for Data.List
07:28:22 <applicative> is there a prelude funtion \(x,y) -> (y,x)?
07:28:27 <quicksilver> applicative: no.
07:28:41 <Jafet> sortBy (flip (comparing snd))
07:28:54 <jix> applicative: I think there is one in a very recent Data.Tuple
07:29:00 <applicative> is it in bad taste to think there should be one?
07:29:12 <mauke> applicative: no
07:29:15 <quicksilver> no, it's not
07:29:21 <byorgey> applicative, quicksilver: yes there is, in Data.Tuple
07:29:25 <Jafet> (snd***fst)
07:29:25 <byorgey> Data.Tuple.swap
07:29:30 <copumpkin> applicative: you in a passive mood today?
07:29:31 <byorgey> it's in base-4.3
07:29:36 <Jafet> &&&, even
07:29:47 <quicksilver> although "\(x,y)->(y,x)" is not much longer than "swap" and equally explanatory IMO.
07:29:54 <quicksilver> byorgey: I know. Data.Tuple is not the prelude.
07:30:27 <Jafet> Should it be in the prelude?
07:30:32 <byorgey> oh. I assumed applicative was just asking whether there was a standard one, not whether it was exported by Prelude.
07:30:43 <copumpkin> swap (a,b)              = (b,a)
07:30:46 <copumpkin> omg it's not lazy enough
07:30:51 <copumpkin> wasn't there lots of bikeshedding about that?
07:31:37 <applicative> one can imagine
07:32:22 <applicative> niczar6589: maximum [("a",2),("b",1)] -- yields ("b",1)  ; let swap (x,y) = (y,x) in swap . maximum . map swap $ [("a",2),("b",1)] -- yields  ("a",2)
07:32:54 <niczar6589> thanks
07:33:01 <fryguybob> @botsnack
07:33:05 <fryguybob> :(
07:33:12 <copumpkin> fryguybob: poke Cale 
07:33:13 <byorgey> :)
07:33:23 <fryguybob> Cale: poke.
07:33:24 <copumpkin> byorgey is the new lambdabot anyway
07:33:29 <copumpkin> > 5 + 7
07:33:33 <byorgey> 13
07:33:37 <copumpkin> see!
07:34:18 <applicative> niczar6589: but the `comparing` function and friends from the Data.Ord module let you use all sorts of comparisons
07:34:33 <Cale> oh
07:35:40 <WatermelonStorm> > 1 + 2
07:35:44 <WatermelonStorm> ...
07:35:46 <lambdabot>   3
07:35:47 <byorgey> 4
07:35:54 <WatermelonStorm> ... Oh you, byorgey.
07:36:08 <byorgey> Unrecognized command, try @helphelphelp
07:36:16 <applicative> > 5 + 7
07:36:22 <lambdabot>   12
07:36:23 <mauke> > let 1 + 2 = 4 in 3
07:36:28 <lambdabot>   3
07:36:33 <applicative> -- just checking whethere byorgyell preserves referential transparence
07:36:35 <applicative> y
07:37:00 <byorgey> error, y not in scope
07:37:57 <WatermelonStorm> > show [1..]
07:38:04 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:38:27 <WatermelonStorm> Yay, byorgey crashed.
07:38:54 <fryguybob>  @calesnack
07:39:00 <Cale> :3
07:39:05 <shlevy> Does/can Haskell do anything smart tail calls modulo cons?
07:39:52 <shlevy> smart with tail calls modulo cons, that is
07:39:53 <WatermelonStorm> shlevy, please improve your sentence generation algorithms. Markov chains shouldn't be used like that.
07:40:08 <Cale> shlevy: Has anyone really been far even as decided to use even go want to do look more like?
07:40:16 <byorgey> shlevy: the short answer is yes.
07:40:25 <byorgey> shlevy: ignore the people making fun of you. =)
07:40:28 <Cale> sorry :)
07:40:34 <Cale> I don't understand the question
07:40:35 <copumpkin> Cale: You’ve got to be kidding me. I’ve been further even more decided to use even go need to do look more as anyone can. Can you really be far even as decided half as much to use go wish for that? My guess is that when one really been far even as decided once to use even go want, it is then that he has really been far even as decided to use even go want to do look more like. It’s just common sense.
07:40:35 <WatermelonStorm> Sorry. |3
07:41:07 <Cale> copumpkin: epic
07:41:08 <byorgey> shlevy: the long answer is that tail calls are a red herring in a lazy language.
07:41:13 <shlevy> My question should have been: "Does/can Haskell do anything smart with tail calls modulo cons" http://en.wikipedia.org/wiki/Tail_call#Tail_recursion_modulo_cons
07:41:24 <shlevy> byorgey: How so?
07:41:37 <confound> that seems like a pretty short answer
07:41:41 <Cale> shlevy: The evaluation order is the reverse of that in a strict language.
07:41:53 <byorgey> shlevy: http://haskell.org/haskellwiki/Tail_recursion
07:42:07 <Cale> shlevy: Things being in tail position or not isn't really all that relevant.
07:42:24 <shlevy> Oh, duh. I actually knew that. I've been using only MATLAB for about a week for a work project and am kind of stuck in that mindset
07:43:46 <shlevy> Thanks!
07:44:03 * hackagebot http-types 0.5.3 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.5.3 (AristidBreitkreuz)
07:44:06 <Cale> In fact, some tail recursive things can behave really poorly unless you add some strictness
07:44:28 <Cale> Because they accumulate large expressions in their parameters which aren't evaluated until much later.
07:44:39 <Cale> @src foldl
07:44:39 <lambdabot> foldl f z []     = z
07:44:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:45:17 <aristid> i love how easy it is to upload packages to hackage. i mean, it could be even easier, but it's pretty good already
07:45:17 <Cale> foldl (+) 0 [1,2,3] --> foldl (+) (0 + 1) [2,3] --> foldl (+) ((0 + 1) + 2) [3] --> foldl (+) (((0 + 1) + 2) + 3) [] --> (((0 + 1) + 2) + 3)
07:45:51 <saml> so, in imperative programming, only places that people use "variable" is for loop counter, some flags, array, malloc
07:45:57 <Cale> The foldl itself doesn't use any stack (or constant stack), but evaluating the resulting arithmetic expression will.
07:49:18 <xaotik> Hi, so I'm reading about standard type classes and I keep seeing terminology from category theory. What are the categories referred to?
07:49:40 <mauke> I assume all categories are hask
07:49:49 <mauke> I also don't know anything about category theory
07:49:51 <xaotik> Is that the category of types?
07:50:24 <Palmik> Hmm, is there some library for converting simple algebraic data type variable to BSON (to be used with https://github.com/TonyGen/mongoDB-haskell) Is that even possible, or do I have to create such a function for each of my types separately?
07:50:43 <xaotik> I know basic category theory from mathematics but I don't see how it relates to Haskell.
07:51:11 <Cale> xaotik: There's a category of Haskell types and Haskell-definable functions between them
07:51:36 <Cale> xaotik: The Functor typeclass captures endofunctors on that category (or a subset of them anyway)
07:52:36 <xaotik> oh, okay
07:52:44 <Cale> (with the type constructor being the mapping on objects, and fmap providing the mapping on arrows)
07:52:47 <Cale> :t fmap
07:52:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:53:46 <xaotik> got it
07:54:17 <xaotik> Has anyone written an introduction along these lines? http://www.haskell.org/pipermail/haskell/2009-January/020929.html
07:54:24 <xaotik> thanks, Cale
07:55:18 <Cale> Our definition of Monad is also a bit funny, in that we use return :: a -> m a, and (>>=) :: m a -> (a -> m b) -> m b. return corresponds to eta (the unit of the monad), but x >>= f = join (fmap f x), where join corresponds to mu (the multiplication of the monad)
07:56:22 <savage> Let's say I have a type 'Grid = Grid [[Int]]', how would I extract the data at a specific index X,Y?
07:56:26 <byorgey> some abstract mathematical presentations of monads use (>>=).
07:56:48 <byorgey> sometimes  flip (>>=)  is written as  (-)^*
07:57:17 <Cale> Yeah, it's just awkward because you can't make use of the definition of a natural transformation as straightforwardly.
07:57:44 <byorgey> savage: index x y (Grid is) = (is !! x) !! y
07:57:58 <savage> Ahh ofcourse
07:57:59 <savage> ty!
07:58:08 <byorgey> Cale: fair enough.
07:58:28 <Cale> savage: If you're going to be doing a lot of that and you want your program to run fast, choosing a better datastructure than lists of lists might be in order.
07:58:41 <Cale> savage: But what byorgey wrote should be fine to start with :)
07:59:18 <copumpkin> ddarius: you might be interested in this paper, http://www.sciencepub.net/nature/ns0712/05_2012_easy_ns0712_31_32.pdf
08:00:31 <mercury^> Umm, you cannot even always define (>>=). The category would need to be closed in some sense.
08:00:42 <applicative> > let foo = permutations . words $ "You've got to be kidding me. Can you really be far even as decided half as much to use go wish for that? My guess is that when one really been far even as decided once to use even go want, it is then that he has really been far even as decided to use even go want to do look more like." in unwords $ "Cale," : (foo !! 4256) ++ ["It's just common sense."]
08:00:43 <lambdabot>   "Cale, be me. Can kidding got You've to you really be far even as decided h...
08:01:44 <applicative> Ah well, the "it's just common sense" was the good part...
08:08:09 * hackagebot monad-control 0.2.0.1 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.2.0.1 (BasVanDijk)
08:09:36 <xaotik> copumpkin: wtf is that xD
08:09:55 <luite> copumpkin: hmm, apparently I also have lots of dark matter in my room un sunny days, but I always thought they were superstrings or gravitons ;)
08:24:25 <ezyang> Yo #haskell, I'm in a library that will be closing for vacation period, and I'm trying to decide on some vacation reading. Any tips? 
08:25:02 <ezyang> I was hoping they'd have a copy of ATTAPL, but seems not. 
08:25:11 <copumpkin> TTFP?
08:25:21 <copumpkin> @where TTFP
08:25:21 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
08:26:26 <ezyang> Duly noted. 
08:27:14 * hackagebot HXQ 0.19.0 - A Compiler from XQuery to Haskell  http://hackage.haskell.org/package/HXQ-0.19.0 (LeonidasFegaras)
08:28:02 <jeltsch> @let x = 1
08:28:03 <lambdabot>  Defined.
08:28:26 <fryguybob> http://www.amazon.com/dp/0521513383/
08:28:41 <jeltsch> @type x
08:28:42 <lambdabot>     Ambiguous occurrence `x'
08:28:42 <lambdabot>     It could refer to either `L.x', defined at <local>:3:0
08:28:42 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/L.hs:73:0-32
08:29:08 <jeltsch> @let cons = (:)
08:29:08 <lambdabot>  Defined.
08:29:11 <jeltsch> @type cons
08:29:12 <lambdabot> forall a. a -> [a] -> [a]
08:29:21 <jeltsch> @let (cons) = (:)
08:29:21 <lambdabot>  <local>:5:1:
08:29:21 <lambdabot>      Multiple declarations of `L.cons'
08:29:21 <lambdabot>      Declared at: <local...
08:29:34 <jeltsch> @let (c) = (:)
08:29:35 <lambdabot>  Defined.
08:29:35 <ezyang> Ok, I think that fills up my borrowing limit. Thanks! 
08:29:42 <jeltsch> @type c
08:29:42 <lambdabot>     Ambiguous occurrence `c'
08:29:42 <lambdabot>     It could refer to either `L.c', defined at <local>:5:1
08:29:42 <lambdabot>                           or `SimpleReflect.c', imported from SimpleReflect at State/L.hs:73:0-32
08:29:49 <jeltsch> @let (ccccc) = (:)
08:29:50 <lambdabot>  Defined.
08:29:53 <jeltsch> @type ccccc
08:29:53 <lambdabot> GHC.Prim.Any -> [GHC.Prim.Any] -> [GHC.Prim.Any]
08:29:58 <jeltsch> Why is this???
08:30:06 <Cale> I'm not sure
08:30:16 <Cale> That is weird
08:30:35 <Jafet> @undef
08:30:39 <Jafet> Talk about pollution
08:30:42 <Cale> @undefine
08:30:51 <_Ray_> Functor + Pointed = Monad?
08:30:58 <mercury^> _Ray_: no.
08:30:58 <Cale> _Ray_: not quite
08:31:05 <Cale> You need a join as well
08:31:06 <mercury^> You also need a multiplication.
08:31:14 <_Ray_> Ah, right.
08:31:32 <_Ray_> Functor gives fmap, Pointed gives unit, and ... something? Applicative maybe? Gives join.
08:31:42 <mercury^> No.
08:31:49 <jmcarthur> applicative doesn't give join
08:32:01 <mercury^> Applicative is also pointed.
08:32:04 <_Ray_> No idea, never seen applicative. Is there something that gives join? Or >>=?
08:32:10 <mercury^> Yes, Monad.
08:32:10 <copumpkin> Monad!
08:32:10 <jmcarthur> monad
08:32:13 <jeltsch> @let anyOk = undefined
08:32:14 <lambdabot>  Defined.
08:32:14 <_Ray_> :(
08:32:20 <jeltsch> @type anyOk
08:32:21 <lambdabot> forall a. a
08:32:33 <jeltsch> @let (anyFlawed) = undefined
08:32:33 <lambdabot>  Defined.
08:32:37 <jeltsch> @type anyFlawed
08:32:38 <lambdabot> GHC.Prim.Any
08:32:45 <jmcarthur> _Ray_: why the frown?
08:32:49 <jeltsch> Okay, at least it’s consistent. :-) 
08:33:01 <_Ray_> jmcarthur: I was hoping it wasn't a stupid question :p
08:33:24 <aristid> GHC.Prim.Any <- what is this?
08:33:27 <jeltsch> @ghcversion
08:33:28 <lambdabot> Unknown command, try @list
08:33:32 <jeltsch> @list
08:33:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:34:00 <jeltsch> What GHC version does lambdabot use?
08:34:10 <_Ray_> So now I think I understand monads, and the only thing I'm missing is some more category theory (youtube can help with that) to understand things like unit :: a -> M a <=> unit :: 1 => M, and the monoidal structure that arises between join and unit. This seems fun.
08:35:32 <mercury^> _Ray_: that unit in the haskell sense is a natural transformation has to do with paramatricity. Or so I have heard.
08:39:53 <Cale> _Ray_: Well, think about what the unit natural transformation η: 1 -> M is made up from. It consists of a component arrow η_X: X -> MX for each object X in C.
08:42:57 <imc> uhmmmm
08:43:04 <Cale> _Ray_: So, having a polymorphic function gives us an arrow of each of those types.
08:43:39 * _Ray_ has to think about it, it still getting the hang of arrows, functors and natural transformations. Thanks :)
08:43:40 <Cale> _Ray_: and then, yeah, as mercury^ mentioned, parametricity is what lets us see that the naturality squares will commute
08:48:21 * hackagebot KyotoCabinet 0.1 - Kyoto Cabinet DB bindings  http://hackage.haskell.org/package/KyotoCabinet-0.1 (WarrenHarris)
08:48:31 <pozic> There are some grid clients which you can install, but how do the servers verify that the client did some actual work? I think such approaches are only useful for problems for which verification is fast, which are certainly not all problems.
08:48:57 <quicksilver> I agree, pozic.
08:49:14 <quicksilver> there are a quite a large class of problems for which verification is fast, though.
08:49:39 <Botje> pozic: you have the same piece of work done multiple times and you verify that the results match
08:49:53 <quicksilver> oh, good point Botje ;)
08:50:13 <pozic> Botje: but that only works if you assume that the people you send it to do not know that they get the same problem.
08:50:54 <Botje> pozic: if you vary the choice of hosts enough and there are enough 'nice' clients, eventually you will find out who the evil guys were
08:52:28 <pozic> Botje: you also have to encrypt your communication for that to work, making it even slower. 
08:52:48 <Botje> encrypt? why?
08:52:51 <quicksilver> only if you believe people can intercept your commmunications
08:52:58 <quicksilver> which is rather paranoid ;)
08:53:00 <pozic> quicksilver: which everyone can
08:53:05 <quicksilver> also, encryption is very fast.
08:53:17 <pozic> quicksilver: sure, it is a small constant. 
08:53:20 <quicksilver> the endpoints can just distribute the unecrypted data
08:53:20 <Botje> pozic: people have to be able to read it when they receive it, so what good would encryption do?
08:53:25 <quicksilver> if the endpoints are not trusted
08:53:31 <quicksilver> so over the wire encryption doesn't seem interesting
08:53:48 <pozic> Botje: your ISP might decide to send '1' instead of '0' just for fun.
08:54:05 <byorgey> my ISP does that a lot
08:54:09 <Botje> pozic: TCP checksumming will catch that.
08:54:18 <Botje> pozic: so will checksumming at the client.
08:54:20 <pozic> Botje: I don't think you get the idea.
08:55:09 <byorgey> Existing grid clients are completely and utterly insecure. Can we move on now?
08:55:19 <pozic> byorgey: are they?
08:55:24 <pozic> byorgey: because that was not established.
08:55:28 <lispy> byorgey: grid clients?
08:56:03 <pozic> lispy: *@HOME etc.
08:56:18 <lispy> pozic: oh, like einstein@home?
08:56:18 <byorgey> pozic: You seem set on arguing about something but I am not sure what it is.
08:56:56 * lispy thinks of something else when someone says "grid client"
08:57:02 <lispy> I think of things like open science grid
08:57:25 <ezyang> Hmm, was the "Lectures on the Curry-Howard correspondence" any good? 
08:57:26 <pozic> lispy: some people say a grid is a specific architecture. 
08:57:29 <byorgey> isn't that the same thing?
08:57:43 <byorgey> ezyang: it's supposed to be excellent, although I haven't read it
08:57:49 <pozic> I would say they are 'distributed systems'. 
08:58:28 <ezyang> ok, I'll grab that one too. 
08:58:31 * ezyang goes wheee 
08:59:06 <lispy> byorgey: open science grid is quite different than, say, @home.  /me is confused about who is talking to whom and asking what
08:59:17 <byorgey> lispy: me too.
08:59:20 <pozic> byorgey: I guess I am just wondering for what type of applications the cloud is really useful. 
08:59:32 <byorgey> pozic: fair enough.
08:59:56 <pozic> I suppose any search problem where one has to constructively create a solution.
09:00:17 <lispy> I guess there are different levels to compare these things.  So, the usage pattern is one level.  The architecture is another level.  There should be a few more levels that I'm drawing a blank on
09:00:33 <pozic> (and where the solution is relatively small in size)
09:00:49 <lispy> Cloud stuff tends to focus on virtualizing everything.
09:01:00 <lispy> grid tends to focus on compute power
09:01:30 <lispy> The cloud often emphasizes storage whereas that tends to be less important for grid folks (except, LHC that generates tons of data)
09:01:40 <pozic> Are there any virtualized solutions which expose timings?
09:02:12 <pozic> Things like executing instruction X takes exactly 3ns. 
09:02:35 <lispy> I don't know much about the cloud, TBH.  Nor have I see such things.  Gotta go!
09:10:10 <hp> I want to learn Haskell and I am trying get a good editor setup. I am running into issues with haskellmode for vim : it cannot find the haddock html files and :make doesn't work.
09:10:33 <hp> I don't know where the haddock files are supposed to be, and I've correctly setup ghc as the compiler for .hs files so I don't know what is going wrong.
09:16:06 <applicative> you mean you are looking for the haddocked ghc documentation? or you want to haddock some modules of your own?
09:16:59 <freedrull> hp what do you mean :make doesnt work
09:18:11 <hp> freedrull: It brings me back to the terminal from which I started vim and says "Press enter or type a command to continue". Then if I press enter it goes back to vim.
09:18:34 <hp> applicative: haddocked ghc documentation. I think I've found it online in tarballs, actually.
09:19:12 <applicative> hp, what os are you using?
09:19:15 <Cale> copumpkin: http://translationparty.com/tp/#151995
09:19:38 <hp> applicative: linux (ubuntu)
09:20:16 <hp> I've looked in /usr/local/share/... (which according to haskellmode is the default location) but didn't anything.
09:21:11 <applicative> hp, hm.  I don't know if the ghc package would put the docs somewhere.  maybe you need to request it when you install?  a "haskell platform" package would do that
09:21:37 <geheimdienst> http://translationparty.com/tp/#9011510 <- "One, cheezburger can have the"
09:21:52 <copumpkin> @hoogle m a -> m ()
09:21:52 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
09:21:52 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
09:21:52 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
09:22:47 <Cale> geheimdienst: http://translationparty.com/tp/#9011521
09:23:11 <applicative> hp, I see there's http://packages.ubuntu.com/maverick/ghc6-doc and http://packages.ubuntu.com/maverick/haskell-platform-doc 
09:23:41 <applicative> hp, but of course, there's also the tarball :)
09:23:55 <hp> applicative: Yes, thanks, just installed those ! I was following RWH's instructions but they seem outdated. It should be easier now.
09:24:05 <Cale> Somehow reading the Japanese versions is even funnier than the English.
09:24:26 <applicative> hp, yeah I think the Haskell platform business was just getting going around the time RWH came out.  
09:24:31 <freedrull> hp: all :make does is run make, there is no other output?
09:24:46 <hp> freedrull: yes, no output at all.
09:25:11 <paolino> hp: /usr/local/share/doc/ghc/html/ contains docs here ubunutu
09:26:00 <applicative> hp, did you install the package haskell-platform of ghc6 
09:26:08 <pozic> Cale: http://translationparty.com/tp/#9011541
09:26:08 <applicative> rather, or: ghc6
09:26:24 <hp> applicative: I installed ghc6 and then haskell-platform.
09:26:54 <pozic> Cale: which translation service does it use?
09:27:04 <applicative> hp oh i see, haskell-platform-doc isn't included in haskell-platform
09:27:05 <Cale> I don't know
09:27:05 <geheimdienst> Cale: http://translationparty.com/tp/#9011544
09:27:11 <pozic> Cale: never mind, it is google.
09:27:28 <pozic> Mine took 11 steps.
09:27:44 <pozic> You are a Haskell addict. -> The Haskell is comfortable. 
09:27:59 <geheimdienst> this could be put on the Data.Monoid documentation with no ill effect
09:29:14 <pozic> OMG OMG OMG, the horror! -- you should move to Japan.
09:29:46 <pozic> (21 steps)
09:30:59 <hp> applicative: ok, problem solved. haskell-platform-doc put the documentation in /usr/share/doc/ghc6-doc/, so for anyone interested you should let g:haddock_docdir="path/to/doc" in ~/.vimrc
09:31:12 <pozic> It is doubtful that this phrase will ever reach equilibrium.
09:31:21 <pozic> Ah, finding flaws in algorithms... 
09:31:44 <pozic> 'OMG OMG OMG, the horror OMG OMG OMG OMG OMG!' 
09:31:45 <geheimdienst> pozic: http://translationparty.com/tp/#9011593
09:32:19 <pozic> geheimdienst: heh, that's fairly funny. 
09:32:28 <pozic> geheimdienst: still, I broke it first :)
09:33:53 <pozic> geheimdienst: http://translationparty.com/tp/#9011614
09:34:12 <geheimdienst> lol
09:34:56 <quicksilver> http://translationparty.com/tp/#9011621
09:34:56 * geheimdienst wishes the output would get put on a cat picture
09:36:54 <applicative> If you say "Oh my God" rather than OMG, it understands -- sort of -- http://translationparty.com/tp/#9011632
09:38:31 <Kaidelong> http://translationparty.com/tp/#9011645
09:38:35 <pozic> http://translationparty.com/tp/#9011657 also loops.
09:38:38 <Kaidelong> why ideograms first and then syllables?
09:39:20 <pozic> For the 'To be or not to be.' it even says it probably is not English. 
09:39:40 <myname_> @help
09:39:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:40:02 <pozic> Nice implementation (the idea is old, though).
09:40:21 <Saizan> poetry is cheating
09:40:31 <myname_> @list
09:40:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:40:59 <Cale> pozic: The comment at the end is random
09:41:08 <myname_> @src map
09:41:08 <lambdabot> map _ []     = []
09:41:08 <lambdabot> map f (x:xs) = f x : map f xs
09:41:27 <myname_> @src undefined
09:41:27 <lambdabot> undefined =  error "Prelude.undefined"
09:42:13 <myname_> @src ($)
09:42:13 <lambdabot> f $ x = f x
09:42:21 <Kaidelong> http://translationparty.com/tp/#9011736
09:43:03 <quicksilver> Saizan: http://translationparty.com/tp/#9011749
09:47:55 <applicative> wow, the new improved uu-parsinglib: now with awesome 'idiom bracket' hacks
09:50:47 <jimi_hendrix> is there a list-like structure that can contain values of different types?
09:51:10 <copumpkin> not easily
09:51:38 <applicative> execParser (iI (,,)  pNatural ":" pNatural  ":" pNatural  Ii)   "3:16:2011" yields (3,16,2011).  This must be hopelessly fragile.
09:52:14 <ion> With Either you can put values of two types into a list. With a type of your own you can put values of any number of predetermined types into a list.
09:52:15 <ClaudiusMaximus> hm translationparty.com doesn't work for me at all - maybe i adblocked too excessively; is an old idea though, here's my implementation: http://claudiusmaximus.goto10.org/cm/2010-09-24_translation_networks.html
09:53:56 <Cale> jimi_hendrix: What do you want it for?
09:55:47 <Cale> jimi_hendrix: Usually what you do is make a type big enough to hold all the elements you'd possibly want to have. Since knowing nothing about the types of the elements would make it impossible to do anything with them, there's always commonality between the elements of the list which can be captured and used in place of the elements themselves.
09:56:10 <jimi_hendrix> Cale, ok
09:56:22 <jimi_hendrix> Cale, that makes sense
09:59:21 <elliottt_> what do people use for HTTP with bytestrings these days?
09:59:31 <elliottt_> is the HTTP package still the right one to use?
10:00:49 <savage> If I have a list of ints ([1,2]) and I have a function check::Int->Maybe Int
10:01:19 <savage> How would I generate a list of tuples [(x,1),(x,2)] where X is the result of check?
10:01:31 <savage> I'm having trouble with the case where check returns Nothing...
10:01:46 <elliottt_> what do you want it to do when check returns Nothing?
10:01:52 <elliottt_> should that element not be in the resulting list?
10:01:55 <savage> yes
10:03:07 <elliottt_> you could investigate the Maybe monad, and the mapMaybe function from Data.Maybe
10:03:13 <elliottt_> that's probably the route that I would take.
10:03:56 <mkscrg> savage elliottt_: Hear hear! mapMaybe is underused, IMO
10:04:04 <elliottt_> it's so great!
10:04:13 <savage> I will have a look at that!
10:04:30 <copumpkin> @hoogle mapMaybe
10:04:30 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
10:04:30 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
10:04:30 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
10:11:51 <mkscrg> I just read about difference lists (of the functional type) in Monad Reader. Is there a good reason these aren't used more? They seem pretty fantastic at first glance.
10:13:54 <Saizan> they can't share tails like standard lists can
10:14:03 <monochrom> do you mean like (("hello" ++) . (" world" ++) . id) "" ?
10:17:10 <byorgey> mkscrg: they are fantastic for very specific applications, where you need to be building up a list structure incrementally and you want to be able to efficiently add at the end as well as the beginning.
10:17:24 <byorgey> mkscrg: they aren't really a general-purpose replacement for lists.
10:18:46 <byorgey> with that said, I think perhaps they get used more than you might think. =)
10:23:46 <gwern> if I want to add at the end, I just use Sequence
10:27:28 <kmc> i love Sequence
10:28:48 <kmc> it's a great option for "i don't want to think super hard, i just want this to be pretty fast"
10:30:50 <kmc> it supports all the usual sequence operations with ease and at least reasonable efficiency
10:34:51 <duairc> Is it possible to enable an extension (specifically OverloadedStrings) in a ghci session after it has begun?
10:35:47 <siracusa> duairc: :set -XOverloadedStrings
10:36:55 <micrypt> What is the "@" operator called?
10:36:58 <duairc> siracusa: Ah, thanks!
10:39:24 <monochrom> "@" is called "as" in SML if you prefer
10:40:02 <kmc> micrypt, do you mean in patterns?
10:41:15 <micrypt> kmc: Yes.
10:43:55 <maurer_> If you could redesign Cabal today, with no need for compatibility with anything, having seen how Cabal works now, what would you do differently?
10:44:48 <maurer_> I guess the packaging system in general really, not just cabal.
10:46:21 <monochrom> track packages myself instead of relying on ghc-pkg. this implies I can track executable-only packages too.
10:47:27 <monochrom> on that note, versionize executables, i.e., "cabal install gtk2hs-buildtools-0.12" does not destroy "cabal install gtk2hs-buildtools-0.11"
10:48:28 <monochrom> actually, just replace all of cabal by nixos :)
10:49:21 <dahankzter> Is there any good reading or examples on how to go about to create internal dsl's in haskell?
10:53:26 <jmcarthur> dahankzter: define internal dsl
10:54:10 <monochrom> perhaps internal = embedded
10:56:19 <dahankzter> yes, no string parsing at runtime or preprocessing or such
10:56:24 <dahankzter> typed and ready
10:56:27 <jmcarthur> monochrom: i guessed that part, but i still asked because DSL means vastly different things to different people. for example, a lot of people tend to label most libraries as DSLs, others only if it qualifies as a full blown programming language itself, and others if it's a library with some syntax sugar to make it not look like a part of the host language at all
10:58:39 <jmcarthur> dahankzter: okay, so basically something using normal haskell syntax and providing a well-defined interface then, right?
10:59:51 <dahankzter> perhaps, not sure really. Is that the Haskell way? In Java which i am trying to forget i tend to use it for ease of use "syntactic sugar" for an api
11:00:15 <jmcarthur> dahankzter: i find that it's nice to have a good idea of the semantics you want and to use type classes (especially existing ones) generously. using type classes kind of *does* give you some sort of "sugar"
11:00:28 <jmcarthur> but the sugar resembling other haskell code, in this case
11:00:59 <jmcarthur> and being a little more semantic instead of syntactic (although you get some syntax sugar too)
11:02:55 <dahankzter> so more or less cleverly named functions that when combined form a higher level "language"?
11:02:59 <jmcarthur> dahankzter: here's a pretty neat example. they define the dsl operationally before they give it a denotational semantics, although my approach would be the other direction. http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm
11:04:12 <jmcarthur> dahankzter: basically the lines are blurry on what a dsl actually is. i like to label libraries with well-defined denotational semantics as dsls, but that's probably an unusual point of view
11:04:29 <jmcarthur> and i'm not going to say that that is the only thing i'd call a dsl either
11:04:54 <dahankzter> maybe its not of the same urgency to do it in haskell as in java
11:05:07 <jmcarthur> but it does make it more like a language than most libraries
11:06:06 <jmcarthur> dahankzter: there's a cool approach here http://conal.net/papers/type-class-morphisms/
11:06:26 <jmcarthur> dahankzter: again, i won't claim this is the only way to make a dsl, but it's a pretty cool way at least :)
11:06:29 <kmc> user-defined infix operators are a totally superficial feature but are really nice for DSLs
11:06:47 <jmcarthur> i agree
11:06:52 <basti_> oh btw, a friend of mine asked for some java FFI in haskell or something comparable allowing java and haskell to run side-by-side. i mentioned lambada and some java-haskell compiler. i forgot that thing's name though. any other ideas on that?
11:07:12 <kmc> basti_, you can combine Haskell FFI and Java JNI
11:07:19 <kmc> no need to compile all the Haskell code to JVM or anything like that
11:07:42 <kmc> it's a big ugly but your GHC-compiled Haskell code will run at native speed and have full library access
11:07:48 <basti_> ah that was an idea i got and proposed but i wasn't all too sure if that makes a lot of sense
11:07:54 <kmc> i've done it several times
11:07:58 <basti_> cool :)
11:08:06 <basti_> may i refer him to you in some way?
11:08:17 <kmc> Haskell's FFI is beautiful, simple, and elegant compared to JNI
11:08:18 <dahankzter> ohh lots of goodies to read thx!
11:08:26 <kmc> basti_, sure, just have him come to this channel and ask me
11:08:50 <basti_> kmc: okay
11:09:44 <kmc> i'm sure others will have useful information too
11:10:28 <kmc> i doubt that any extant Haskell→JVM compiler currently supports a useful range of libraries
11:10:37 <basti_> [x] done
11:10:39 <kmc> (of Haskell libraries i mean)
11:11:09 <kmc> something like ByteString is basically not going to compile to JVM
11:11:40 <basti_> as far as i understood, he wanted to use haskell as a parser and then build a gui in java
11:11:44 <kmc> i did see a project which would compile C, C++ (and theoretically Haskell) to JVM by compiling to MIPS assembly and then translating that
11:12:09 <kmc> multi-language projects are much easier when you can make the components loosely coupled
11:12:11 <basti_> basically, the interface is supposed to translate one string into one tree of some native java type(s)
11:12:19 <NakedTomHanks> hello, I am having problems with running leksah on Ubuntu. I have everything installed and running but if I try to debug I get the popup "GHCi debugger is not running.  Would you like to start it?". Looks like I forgot to install something? On the command line "ghc" and "ghci" works.
11:12:32 <kmc> maybe the parser in Haskell can produce JSON or something and send it down a pipe or a socket
11:12:56 <kmc> maybe it can be a string → JSON service provided over HTTP
11:13:14 <basti_> i beg your pardon? JSON isnt that javascript specific?
11:13:25 <kmc> no...
11:13:29 <kmc> JSON is just a data format
11:13:38 <kmc> one of five thousand different ways to represent nested key-value dictionaries as text
11:13:40 <basti_> i see
11:13:49 <kmc> there are like a dozen JSON libraries on Hackage
11:14:29 <kmc> it happens to be the case that serialized JSON structures are also Javascript literals
11:14:35 <basti_> how do you parse json in java?
11:14:38 <basti_> i see.
11:14:39 <kmc> which provides a convenient if bad way to "parse" them in Javascript
11:14:45 <basti_> for a reason i suppose.
11:14:47 <basti_> ;)
11:15:11 <kmc> but otherwise you can ignore this fact and treat it as a competitor to XML, YAML, s-expressions, benc, ASN.1, protobuf, blah blah blah
11:15:24 <kmc> you parse json in Java by using a JSON parser library
11:15:40 <kmc> i'm sure someone has written one, as JSON is one of the more popular of these formats
11:15:53 <confound> one? I'm sure there are like 13
11:15:58 <basti_> i'd suppose, too
11:17:04 <kmc> yeah if there are 12 JSON libraries for Haskell there must be at least 50,000 for Java
11:17:11 <mjrosenb> kmc: compiling *to* jvm from mips assembly seems like a bad idea.
11:17:12 <basti_> *nod*
11:17:13 <pozic> In C you essentially have types like Anything -> Binary and Binary -> Anything that do not require 'parsing'. Haskell doesn't really have that, right?
11:17:39 <kmc> pozic, look at Data.Binary
11:17:44 <kmc> also the Storable type class
11:18:01 <pozic> kmc: there is still interpretation involved, AFAIK. 
11:18:12 <basti_> *scratches head*
11:18:45 <kmc> Storable is the direct equivalent of C's "just read a buffer and cast it to some type"
11:18:52 <kmc> which is why it's part of the C FFI libraries
11:19:13 <kmc> but unlike the situation in C, "peek" will involve copying data out of that buffer
11:19:52 <kmc> because there's no chance that the in-memory layout of a Haskell object will match what's in your file
11:19:57 <pozic> Right, so it has to interpret stuff. It's not just 'there'.
11:19:58 <kmc> and no standard to say that it should
11:20:11 <basti_> oh
11:20:17 <pozic> kmc: right, but wouldn't a standard be a practical useful thing?
11:20:40 <pozic> It would be less portable, of course.
11:20:52 <kmc> do you know how values are represented in the GHC Haskell heap?
11:20:54 <maurer_> pozic: That would hugely increase the burden on compiler writers, decrease portability
11:21:03 <maurer_> Thunks would become very sad
11:21:07 <pozic> kmc: in a different way with every release?
11:21:15 <kmc> that's not what i meant
11:21:29 <kmc> (but yes, that too)
11:21:42 <pozic> kmc: I have some abstract picture, which I am sure is more simplistic that the actual representation.
11:21:47 <kmc> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects
11:22:19 <kmc> note that it's full of pointers to dynamically allocated objects
11:23:06 <kmc> the value (3,4) would be a 3-word heap object, where the last two words are pointers to 2-word heap objects
11:23:20 <kmc> and the first word of each of those objects points into code or read-only data segments
11:23:40 <kmc> that's a simple case, of course
11:24:07 <kmc> it might actually be a thunk or an indirection or a selector  thunk or a partial application or...
11:24:18 <kmc> maybe a blackhole or a whitehole
11:24:32 <mjrosenb> kmc: whitehole?
11:24:52 <kmc> yeah
11:24:52 <pozic> kmc: most people do not want to store functions.
11:25:28 <kmc> pozic, and you'd force evaluation to get rid of thunks?
11:25:38 <pozic> kmc: yes
11:25:41 <mjrosenb> what exactly is a whitehole? i assume that a blackhole is _|_
11:25:50 <kmc> a blackhole is a thunk that's currently being evaluated
11:26:05 <kmc> so its entry code will kill the program with "<<loop>>"
11:26:12 <kmc> because it means to evaluate that thunk you had to evaluate the thunk
11:26:20 <pozic> kmc: he asked for a white hole.
11:26:24 <mjrosenb> yes, and if you happen to come across it again before hitting a Constructor, then you know you hav looped
11:26:30 <kmc> with the threaded RTS you instead have whiteholes
11:26:36 <mjrosenb> pozic: i also asked about blackholes.
11:26:49 <mjrosenb> whiteholes are things that are being evaluated elsewhere?
11:26:55 <kmc> the entry code for a whitehole places your thread onto a wait queue
11:27:02 <kmc> it will wake up when the thread doing that evaluation finishes
11:28:06 <dolio> mjrosenb: Whiteholes are just used instead of blackholes during threading.
11:28:27 <dolio> Although in theory, you could record a thread id to see if the white hole you've encountered was placed by you, I suppose.
11:29:03 <pozic> Can someone give a _clear_ definition for a white hole?
11:29:03 <dolio> I thought they didn't do that, though.
11:29:16 <kmc> pozic, what's your problem?
11:29:25 <kmc> yeah... iirc GHC doesn't do that, and it also doesn't lock when creating a whitehole, so there's a small window of opportunity for both threads to evaluate it
11:29:36 <dolio> Yes.
11:29:58 <pozic> kmc: nothing, it's just that I haven't seen a definition in English which is meant to be understood by someone not already knowing what a white hole is.
11:29:59 <dolio> Locking would probably cost more ultimately than evaluating a few things twice.
11:30:02 <pozic> 'during threading'.
11:30:12 <pozic> When ones uses the threaded RTS? What?
11:30:16 <kmc> yes
11:30:23 <kmc> it is more helpful to ask questions like that
11:30:27 <pozic> one* 
11:30:28 <kmc> than to simply say "your explanation sucks"
11:30:45 <kmc> i was answering mjrosenb's question based on an estimate of what he might already know
11:31:03 <kmc> the non-threaded RTS generates blackholes; the threaded RTS generates whiteholes
11:31:20 <kmc> both represent a thunk currently under evaluation
11:31:30 <kmc> entering a blackhole kills the program
11:31:38 <kmc> entering a whitehole suspends the current thread until the thunk is finished evaluating
11:31:54 <kmc> (which might never happen, if the current thread is supposed to be doing that evaluating)
11:32:29 <mjrosenb> kmc: does ghc currently do cycle detection on waiting threads?
11:32:58 <mauke> so ... ghc can optimize infinite loops into sleep(Inf)?
11:32:58 <kmc> i'm not sure
11:33:25 <kmc> mjrosenb, i did an experiment with "let x = x in x" and found that the non-threaded RTS would kill my program instantly, and the threaded RTS after about 0.3 seconds
11:33:39 <kmc> maybe it computes whitehole reachability during garbage collection, or something like that
11:33:45 <kmc> yep mauke
11:33:49 <kmc> (certain infinite loops)
11:33:55 <mauke> sweet
11:34:08 <mauke> another idea accidentally invented by me
11:34:25 <dolio> ghci uses white holes, too, I think.
11:34:44 <dolio> If you write 'fix id' in there or something similar, it will just block using no CPU.
11:35:16 <kmc> yeah, ghci never prints "<<loop>>"
11:35:37 <kmc> "fix id" would cause a stack overflow otherwise
11:35:46 <kmc> (if it didn't block)
11:36:20 <dolio> fix id should <<loop>>.
11:36:26 <dolio> With black holes.
11:37:08 <kmc> right
11:37:13 <kmc> sorry, i meant if there was no holing at all
11:37:31 <dolio> Oh.
11:37:54 <dolio> Actually, I wouldn't expect it to use any stack.
11:39:14 <mjrosenb> @src fix
11:39:14 <lambdabot> fix f = let x = f x in x
11:39:18 <kmc> if a blackhole kills your program, then you had some thunk x whose evaluation forced x
11:39:31 <kmc> won't there be a continuation frame for each step of that?
11:47:32 <kmc> that race condition on multithreaded thunk entry is worrying wrt GHC's implementation of IO
11:47:52 <kmc> but i think it should not be a problem
11:48:44 <kmc> because how would two threads end up trying to enter the same IO-thunk?
11:51:58 <micrypt> Any function that accepts two parameters can be be used as an infix operator, right?
11:52:09 <monochrom> yes
11:52:27 <mjrosenb> it can also be used if it accepts more than two parameters
11:52:36 <mjrosenb> just the syntax isn't as nice
11:53:09 <kmc> x `f` y
11:53:35 <mjrosenb> > ((+) `foldl` 0) [0..5]
11:53:35 <lambdabot>   15
11:53:56 <byorgey> > ((+) `zipWith` [1,2,3]) [4,5,6]
11:53:57 <lambdabot>   [5,7,9]
11:54:07 <kmc> i really wish we had operator syntax like Agda's
11:54:19 <mjrosenb> kmc: does it have arbitrary fixity?
11:54:32 * mjrosenb should learn agda
11:54:38 <kmc> yeah
11:54:41 <mjrosenb> it isn't like i'm doing anything better with my time
11:54:58 <monochrom> default fixity is "infixl 9"
11:55:19 <kmc> if_then_else_ : Bool → a → a → a
11:55:30 <kmc> then you can say «if True then 3 else 4»
11:55:43 <aristid> @pl get l a = peek (l a)
11:55:43 <lambdabot> get = (peek .)
11:56:10 <kmc> _⊢_∷_ : Context → Term → Type → Prop
11:56:35 <kmc> Coq has rebindable syntax too but it's not quite as nice
11:56:44 <mjrosenb> \u22a2?
11:56:47 <mjrosenb> is that |-?
11:56:50 <kmc> yeah
11:56:58 <kmc> > ord '⊢'
11:56:58 <lambdabot>   8866
11:57:36 <mjrosenb> are you actually dropping unicode in there?
11:58:10 <monochrom> > '\u22a2'
11:58:11 <lambdabot>   <no location info>:
11:58:11 <lambdabot>      lexical error in string/character literal at chara...
11:58:19 <HugoDaniel> http://softtalkblog.com/2011/03/14/haskell-opens-the-door-to-philosophy/
11:58:22 <HugoDaniel> amazing
11:58:23 <HugoDaniel> :)
11:58:24 <monochrom> oops, \u is java
11:58:29 <mauke> > '\8866'
11:58:29 <lambdabot>   '\8866'
11:58:36 <monochrom> > '\x22a2' = '\8866'
11:58:37 <lambdabot>   <no location info>: parse error on input `='
11:58:40 <monochrom> > '\x22a2' == '\8866'
11:58:40 <lambdabot>   True
12:00:05 <MasseR> Uhm, shouldn't haskell strings be unicode?
12:00:24 <monochrom> they are.
12:00:58 <MasseR> I have two files, both containing the string "pöö", the other as iso-8859-1 and the other utf-8
12:01:23 <MasseR> Reading the utf-8 file produces "p\195\182\195\182"
12:01:31 <MasseR> And the iso "p\246\246"
12:01:38 <kmc> what's your locale's encoding? and what version of GHC?
12:01:44 <MasseR> However, if I write "pöö" in ghci, it prints "p\246\246"
12:01:46 <monochrom> that depends on I/O routines
12:01:57 <kmc> GHC < 6.12 uses utf8 always; GHC ≥ 6.12 uses the locale
12:02:06 <MasseR> Locale is utf8
12:02:11 <MasseR> Ghc 7.0.2
12:02:16 <roconnor> ACM two column format is so annoying to write
12:02:48 <kmc> hmm maybe the situation in GHC < 6.12 was even worse
12:02:49 <kmc> but anyway
12:02:51 <mauke> I thought old ghcs always used latin1
12:02:55 <kmc> how are you reading the file MasseR?
12:03:00 <MasseR> kmc: Lazy bytestring
12:03:02 <kmc> i think you're right mauke
12:03:06 <kmc> MasseR, well, that explains it...
12:03:07 <MasseR> LBS.readFile "unicode"
12:03:12 <mauke> MasseR: bytestrings aren't strings
12:03:13 <kmc> ByteStrings hold bytes, not characters
12:03:29 <kmc> if you want an efficient packed format for text, use the "text" library
12:03:51 <monochrom> when you naïvely unpack bytestring to String, it does the equivalent of iso-8859-1.
12:04:06 <kmc> "unpack ByteString to String" is a type error
12:04:16 <kmc> (ignoring the abomination that is ByteString.Char8)
12:04:21 <MasseR> monochrom / kmc Oh, thanks
12:04:26 <monochrom> or when you naïvely extract Char's from bytestring
12:05:24 <kmc> i would say that (toEnum . fromIntegral :: Word8 -> Char) is not so much naïve as pathological
12:05:32 <kmc> if you write that it's very clear what you're getting
12:05:43 <kmc> and that what you're getting is not UTF-8 or UTF-anything
12:05:52 <MasseR> Makes sense
12:08:04 <MasseR> In that case, maybe it's something with cgi package? getInput :: String -> m (Maybe String), returns "p\195\182\195\182"
12:09:38 <monochrom> perhaps the *.Char8 modules should just be eliminated. programmers need to explicitly and consciously write "iso-latin-1" in their code if they want it.
12:09:50 <mauke> :-(
12:10:10 <kmc> i'm in favor.  perhaps it was a stopgap measure for wanting efficient text before Data.Text existed
12:10:21 <kmc> "i want an efficient text type, but i also want to make sure people who don't speak English can't use my program"
12:10:24 <mauke> I like it for IRC
12:10:28 <kmc> dey tek er jerbs
12:11:26 <kmc> IRC has a Unicode encoding, it's just set on a per-channel basis and not communicated or known by the server
12:11:36 <monochrom> it was a stopgap measure for assuming the whole haskell community sworn by iso-latin-1 despite Haskell 98.
12:12:05 <mauke> IRC has "extended ascii"
12:12:13 <MasseR> Okay so it's ByteString -> Text -> String
12:12:27 <mauke> the protocol is all ascii, but bytes >= 128 are passed through
12:15:35 <kmc> MasseR, why do you have a ByteString in the first place?
12:15:57 <kmc> Text has I/O functions
12:15:57 <MasseR> kmc: Because apparently the cgi module returns wrong data with getInput :: String -> m (Maybe String) function
12:16:19 <kmc> so you want to use getInputFPS instead?
12:16:26 <MasseR> yes
12:16:44 <kmc> you'll have to figure out what the encoding is
12:16:52 <MasseR> I know the encoding, utf-8 :)
12:16:54 <kmc> ok
12:17:00 <MasseR> The getInput seems to return something along the lines "LBS.unpack s"
12:17:04 <MasseR> Ie the mistake I just did
12:17:19 <kmc> if 'cgi' doesn't know the character encoding then it has no business returning String
12:17:38 <kmc> but this library is quite old
12:17:53 <monochrom> wait, cgi should give you just ascii and use the like of %3948 for non-ascii characters, shouldn't it?
12:18:19 <MasseR> monochrom: Are you talking about the CGI package,or cgi protocol?
12:18:26 <monochrom> the cgi protocol
12:18:36 <kmc> yeah it imports Data.ByteString.Lazy.Char8 *sigh*
12:19:00 <mauke> on stdin, you mean?
12:19:15 <monochrom> and if the cgi protocol sticks to ascii and %-codes, any cgi package should have no difficulty giving you the correct unicode code points.
12:19:55 <mauke> I'm pretty sure the CGI protocol doesn't care about encodings
12:19:59 <mauke> ascii or otherwise
12:25:21 <conal> could someone please jog my memory about to configure ghc for --extra-lib-dirs ? there's a configuration file somewhere.
12:25:21 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
12:26:01 <conal> i just installed 7.0.2 on mac os x
12:27:42 <dixie> > 1+1
12:27:43 <lambdabot>   2
12:27:50 <dixie> lambdabot: thanks a lot
12:28:20 <savage> > 1/0
12:28:21 <lambdabot>   Infinity
12:28:33 <savage> really? :o
12:31:57 <dons> 730 nicks. busy busy
12:32:44 <dons> can someone tweak the setting that allows the bots back in?
12:32:48 <dons> we should have #haskell show up in http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode 
12:32:56 <dons> it used to be there, but one of the settings blocked the chan bot?
12:32:58 <dons> monochrom: ?
12:33:40 <kmc> isn't that a good way to get more people here asking for Java help?
12:34:06 <dons> sure
12:34:30 <fryguybob> conal: ~/.cabal/config ?
12:34:34 <ddarius> Great kmc, now "Java" is in our logs.
12:34:58 <conal> fryguybob: that's it. thanks!
12:35:07 <conal> my memory was blank on that one.
12:35:59 <conal> hurray for collective memory.
12:36:35 <mauke> the only related looking ban is $r:IRSeekBot
12:36:47 <mauke> but that's not searchirc
12:38:16 <dons> mauke: hmm
12:39:48 <HugoDaniel> im struggling with hxt :(
12:40:30 <mauke> I think it's because we're +s
12:41:17 <mjrosenb> :t (/)
12:41:18 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:41:31 --- mode: ChanServ set +o mauke
12:41:31 --- mode: mauke set -s
12:41:59 <ddarius> @tell copumpkin http://ncatlab.org/nlab/show/category+of+elements  What I was trying to tell you last... morning.
12:42:00 <lambdabot> Consider it noted.
12:42:07 <mjrosenb> savage: since it uses fractional, it can use Real/IEEE floating point, where Infinity is defined.
12:42:21 --- mode: mauke set -o mauke
12:42:35 <ddarius> What is +s?
12:42:39 <mauke> secret
12:43:03 <mauke> channel doesn't appear in /list or /whois of people on the channel (unless you're also in that channel)
12:43:06 <copumpkin> I thought it'd keep spam out
12:43:06 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
12:43:09 <copumpkin> only reason I put it on
12:43:13 <copumpkin> or would reduce it, anyway
12:43:17 <copumpkin> ddarius: cool, thanks
12:43:21 <copumpkin> ddarius: did you see the paper I linked to?
12:43:34 <ddarius> copumpkin: I don't recall a paper.
12:43:43 <copumpkin> http://www.sciencepub.net/nature/ns0712/05_2012_easy_ns0712_31_32.pdf
12:43:46 <copumpkin> it's excellent
12:44:34 <Igloo> copumpkin: Did you keep any stats to see if it does help?
12:44:35 <monochrom> it is too bad that 2 (or 3) things are grouped under +s. we certainly like to appear in /list but not /whois
12:44:52 <mauke> why not whois?
12:44:59 <copumpkin> Igloo: it's pretty hard to measure
12:45:03 <copumpkin> so nope
12:45:26 <Igloo> If the goal is to keep spam out, it's /list you want to keep out of
12:45:33 <HugoDaniel> looking at the panorama of the haskell xml parsing packages, i can easily understand why there are so many
12:45:38 <HugoDaniel> because im about to code my own
12:45:46 <HugoDaniel> :/
12:45:46 <copumpkin> Igloo: yeah, that's +s (or +p)
12:45:47 <monochrom> if I am in ##c and offend a newbie there, do you want the offendee to /whois monochrom, finds out I'm also in #haskell, and comes here to harass everyone?
12:45:49 <mauke> /list is what searchirc uses
12:45:50 <Igloo> copumpkin: Well, if there's no measurable difference then I don't think we should be +s
12:46:29 <copumpkin> well, if it's impossible to measure, but it makes intuitive sense that it would help
12:46:31 <monochrom> but perhaps you do want it.
12:46:31 <mauke> time for a test
12:46:34 <copumpkin> :P
12:46:37 --- mode: ChanServ set +o mauke
12:46:37 --- mode: mauke set +p
12:47:01 <monochrom> oh +p sounds nifty 
12:47:04 <copumpkin> we have conflicting goals. The logger bot uses /list and so do the spammers
12:47:09 <copumpkin> we want the logger and not the spammers
12:47:31 <Igloo> copumpkin: Whether it intuitively helps doesn't make a difference. We want to know if (and how much) it /actually/ helps
12:47:36 <monochrom> I say, the spammers already know of #haskell :)
12:47:49 <copumpkin> Igloo: what's the cost of keeping +s, let's say?
12:48:00 <copumpkin> not showing up on a website for a ranking?
12:48:06 <copumpkin> seems pretty low to me
12:48:09 <Igloo> copumpkin: We are invisible to legitimate users and that website
12:48:13 <dons> yes
12:48:20 <dons> and other 'irc channel' sites
12:48:27 <dons> also, tracking volument and other stats on the channel
12:48:31 <dons> volume.
12:48:35 * copumpkin shrugs
12:48:54 <kmc> monochrom, simple solution: avoid ##c
12:49:02 <mauke> btw, http://mauke.dyndns.org/interweb/?w=%23haskell
12:49:06 <monochrom> yeah I really mean #isabelle there
12:49:08 <Igloo> copumpkin: To be clear, I wouldn't be surprised if it did help spam, and we could consider the upsides and downsides. But not without some idea of how much it helps
12:50:10 <mjrosenb> have there been historical problems with spam in here?
12:50:13 * ddarius can't imagine a human user not finding #haskell because it wasn't in /list.
12:50:35 <mjrosenb> kmc: but ##c is *hilarious*
12:50:53 <kmc> better use a sockpuppet nick then
12:50:55 <copumpkin> mjrosenb: even not spam. People joining and saying "I have a java question"
12:51:05 <ddarius> Those Isabelle folks are rowdy.
12:51:06 <mauke> preflex: seen PoppaVic
12:51:06 <preflex>  PoppaVic was last seen on ##C 43 minutes and 58 seconds ago, saying: "lol" - response of cham-peens
12:51:19 <copumpkin> Igloo: fair enough :)
12:51:27 <kmc> preflex, is in ##c?
12:51:34 <kmc> -,
12:51:39 <copumpkin> I just have a lower opinion of the value of appearing on such websites or on /list
12:51:40 <monochrom> my view on spam: spams directed to #haskell is a lesser evil, ops see them plain as day, can deal directly. spams doing /who or /whois to discover individuals and pm'ing each separately, that's the evil one, everyone doubts if other people get it, what's the correlation, etc.
12:51:40 <ddarius> kmc: Why wouldn't preflex be there?
12:51:44 <copumpkin> so pretty much anything is higher ;)
12:51:44 <kmc> shrug
12:51:47 <kmc> why would preflex be anywhere
12:51:48 <Igloo> mjrosenb: People do occasionally join to advertise some URL, often with colours, or repeatedly, etc
12:52:27 <ddarius> http://haskell.org http://haskell.org http://haskell.org 
12:52:29 <savage> If I have a list [Loc 0 0, Loc 0 1], how would I use map to increase the first part of the Loc type by 1?
12:52:50 <savage> map SOMETHING [Loc 0 0, Loc 0 1] results in [Loc 1 0, Loc 1 1]
12:52:58 <kmc> map (\(Loc n k) -> Loc (n+1) k)
12:53:11 <savage> thanks!
12:55:32 <savage> im always struggling to extract values from data types
12:55:43 <kmc> that's what pattern-matching is for
12:55:48 <savage> well, writing a new function with matching works
12:55:52 <savage> but it seems cumbersome
12:55:57 <kmc> you can also use "case"
12:56:08 <kmc> case foo of Loc n k -> Loc (n+1) k
12:56:16 <kmc> or even "let"
12:56:20 <kmc> let Loc n k = foo in Loc (n+1) k
12:56:40 <kmc> there's a number of differences between those two
12:56:43 <savage> yeah and I can do "Loc n k = foo" in a where clause
12:56:54 <savage> there's so many ways I get confused sometimes
12:56:58 <kmc> *nod*
12:57:35 <kmc> the big difference between those is that "case" allows multiple alternatives and checks them immediately, while "let"/"while" only allow a single pattern, and will defer the constructor check until you use those variables (at which point, a failed check results in an exception)
12:57:58 <savage> I see
12:58:29 <dons> so what's the decision, copumpkin , mauke ? any change to the protection level?
12:58:54 <monochrom> seems we go with +p -s
12:59:02 <mauke> I don't really care; I say see what happens
12:59:05 <copumpkin> I have no decision :) just an opinion
12:59:19 <mauke> +p should keep us out of /whois
12:59:25 <copumpkin> if we really want to show up on those websites and /list, let's stay public
12:59:55 <dons> k.
13:00:08 <dons> can someone do that then? sounds good.
13:00:16 <mjrosenb> kmc: is there some special magic for do blocks where a failed match causes the whole thing to evaluate to fail "something or other"?
13:00:16 <ddarius> It's been done.
13:00:27 <monochrom> already status quo :)
13:00:39 <dons> oh
13:01:14 <monochrom> haskell community - where proposals and extensions become status quo before any decision :)
13:01:49 <monochrom> (just look at how people embrace UndecidableInstances OverlappingInstances IncoherentInstances so wantonly!)
13:01:58 <ddarius> monochrom: Multiparameter type classes and functional dependencies aren't quite at drinking age yet.
13:02:12 <monochrom> yeah!
13:07:13 <Saizan> UndecidableInstances++
13:09:27 <siracusa> @karma UndecidableInstances
13:09:27 <lambdabot> UndecidableInstances has a karma of 1
13:10:19 <mauke> preflex: karma UndecidableInstances
13:10:19 <preflex>  UndecidableInstances: 1
13:10:23 <mauke> the scales are balanced
13:14:02 <ezyang> Hmm, one function per typeclass. I'm not sure I buy it. 
13:14:25 <monochrom> "one idea per line"
13:15:01 <ezyang> "multifunction typeclasses have multiple lines" ;-) 
13:16:51 <Skola> can I convert an IO String to a String?
13:17:00 <ezyang> Skola: No. 
13:17:21 <ezyang> But if you have a function that expects a String you can use >>= 
13:17:28 <Skola> ok, thanks
13:18:34 <ddarius> F ~ Lan_d(K1) where d : elF -> C and F : C -> Set
13:20:49 <monochrom> @quote monochrom IO.String
13:20:49 <lambdabot> No quotes match. That's something I cannot allow to happen.
13:21:00 <monochrom> onoes, it's lost!
13:21:12 <mauke> preflex: quote monochrom String
13:21:12 <preflex>  no quotes found for monochrom
13:21:17 <mauke> hmm
13:24:01 <Skola> monochrom, any chance you can reproduce the "lost" quote? ;D
13:24:17 <monochrom> "how do I convert an IO String to an IO?"
13:24:42 <ddarius> monochrom: I don't think that that was @remembered.
13:25:28 <mauke> Skola: how do you convert an Inventor Car to a Car?
13:25:36 <mauke> (read as "Inventor of Car")
13:26:13 <Skola> hm I understand the metaphore
13:26:39 <monochrom> there was a successful @quote on March 14, i.e., somewhere in http://tunes.org/~nef/logs/haskell/11.03.14
13:26:41 <Skola> I need to dive into the basics some more, I keep running into these kind of basic things
13:26:57 <mauke> Skola: do you happen to know javascript?
13:26:59 <ddarius> http://ncatlab.org/nlab/show/pro-object
13:27:42 <Skola> yes mauke
13:27:42 <monochrom> oh, if you mean it wasn't the verbatim wording, sure.
13:28:02 <mauke> Skola: how do you sleep() in javascript?
13:28:10 <monochrom> there is something ambiguous about "extract out of" "get out of" etc.
13:28:16 <kmc> mjrosenb, a failed match in a single statement becomes «fail "foo"»
13:28:22 <kmc> it's up to (>>=) to propagate that
13:29:11 <kmc> Skola, an "IO String" is nothing like a String
13:29:32 <Skola> mauke usually with some bad hack :[
13:29:43 <kmc> it's a recipe for how you could perform some IO and get a String
13:29:49 <mauke> Skola: elaborate
13:30:12 <ddarius> "Tell me all your sins, child."
13:30:51 * ddarius likes how trampolined continuation passing style is a "bad hack."
13:30:52 <monochrom> haha
13:31:09 <ezyang> What is the "trampolined" bit? 
13:31:34 <Skola> I don't know if we're referring to the same thing if you ask me to elaborate
13:31:48 <mauke> me neither if you don't elaborate
13:31:54 <monochrom> http://www.vex.net/~trebla/tail.html has a trampoline example (see the source code)
13:32:14 <joe6> any suggestions on how to fix this error: Building haskell98-1.1.0.1...
13:32:25 <joe6> The export item `RandomGen(next, split, genRange)'
13:32:25 <monochrom> although it doesn't emulate multi-threading or delaying
13:32:33 <joe6> attempts to export constructors or class methods that are not visible here
13:32:39 <ezyang> Mm, looks delicious. 
13:32:47 <joe6> in Random.hs:2:4:
13:33:06 <ezyang> joe6: Ooh. I think when I saw that error I nuked my .ghc/.cabal and tried again. Maybe others will have better suggestions. 
13:33:23 <monochrom> "Building haskell98-1.1.0.1" is already a symptom of a deep problem to begin with. while do you build haskell98? it comes with ghc.
13:33:34 <monochrom> s/while/why/
13:34:05 <joe6> xmonad-contrib is doing that.
13:34:09 <monochrom> probably answer is "I'm installing an impossibly new package and it brings in an impossibly new haskell98"
13:34:15 <Skola> mauke, setInterval
13:34:27 <mauke> Skola: I'd use setTimeout
13:34:29 <ezyang> yep, sounds just like what happened to me. 
13:34:31 <monochrom> or else your package database is hosed and confuses cabal
13:34:32 <mauke> why repeat yourself
13:34:44 <joe6> as part of its' install. there is a haskell98-1.1.0.0
13:34:54 <joe6> already installed on my system.
13:35:05 <mauke> Skola: basically, you don't sleep(); instead you wrap the rest of your program in a function and pass it to setTimeout
13:35:14 <mauke> Skola: and that's how IO works
13:35:29 <kmc> how IO works is http://www.haskell.org/haskellwiki/Introduction_to_IO
13:35:33 <mauke> in fact, you can think of IO as asynchronous XMLHttpRequests... sort of
13:36:08 <Skola> that helps
13:36:11 <Skola> both
13:36:14 <Skola> thanks
13:36:42 <kmc> the "do" syntax hides the fact that every line is invoking a function and passing the whole rest of the "do" block as an argument
13:36:47 * roconnor still hates ACM 2 column format.
13:36:52 <roconnor> how can anyone stand this
13:36:59 <roconnor> programs don't fit
13:37:16 <Skola> mauke that's a really useful comparison : }
13:37:23 <opqdonut> roconnor: \scriptsize
13:37:29 <mauke> inorite
13:37:47 <monochrom> joe6: I would like to know how to reproduce it reliably. would you mind sending me the outputs of the following? 1. "ghc -v"  2. "ghc-pkg list -v"  3. "cabal --version"
13:37:55 <edwardk> preflex: xseen pozic
13:37:55 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
13:37:55 <preflex>  pozic was last seen on freenode/#haskell 2 hours, 7 minutes and 32 seconds ago, saying: one* 
13:38:18 <roconnor> opqdonut: I am very tempted
13:39:17 <Skola> mauke ya ;p
13:39:58 <roconnor> 8pt!
13:41:08 <monochrom> you are supposed to keep your programs to 40 columns
13:41:28 <edwardk> monochrom: exactly as God and commodore intended
13:41:39 <monochrom> because it is the era of Apple II and before the 80-column card!
13:42:01 <monochrom> and before Apple IIe too
13:42:16 <edwardk> exactly, just be glad the 22 column display didn't catch on ;)
13:42:17 <ddarius> ezyang: When you interact with event-based systems, you can use the trampoline in it, in this case setTimeout, and not having TCO isn't a problem.
13:42:24 <roconnor> monochrom: I'm limited to 2 columns :P
13:42:25 <monochrom> but perhaps you can take Apple II+ for granted so you have lower case letters!
13:42:32 <monochrom> hahaha
13:42:58 <edwardk> monochrom: true descenders, such a luxury.
13:44:58 <monochrom> People who design "this page best viewed in 40960x37800" web pages should be condemned to Apple II+ for all their future work.
13:45:32 <fryguybob> > 40960*37800
13:45:33 <lambdabot>   1548288000
13:45:33 <edwardk> monochrom: right after i steal their monitor
13:45:41 <edwardk> and video card
13:46:42 <monochrom> actually I don't mind upgrading them to Apple IIc so they have some almost-netbook to use!
13:47:34 <joe6> monochrom, ghc -v is here:  http://sprunge.us/NdTT
13:48:08 <monochrom> in any case, on the bright side, their anti-haskell attitude is well-rewarded by a computer that has no possibility of running haskell! :)
13:48:28 <dons> hackage stats for 2010, http://haskellwebnews.wordpress.com/2011/03/16/hackage-stats-the-past-year/ 
13:48:46 <monochrom> 7.1 ??!!!
13:48:53 <joe6> monochrom: cabal--version is here: http://sprunge.us/ROQL
13:49:10 <ezyang> Cool stuff. 
13:49:12 <dons> 7.1.20110209 
13:49:30 <joe6> monochrom, ghc-pkg --list is here: http://sprunge.us/RLiT
13:49:38 <monochrom> cabal-install version 0.9.5 is a bit odd given your new ghc.
13:50:50 <joe6> i do not understand why I have 2 directories: 
13:50:52 <joe6> using cache: /home/j/.ghc/i386-linux-7.1.20110209/package.conf.d/package.cache
13:50:52 <joe6> using cache: /home/j/.ghc/lib/ghc-7.1.20110209/package.conf.d/package.cache
13:51:00 <roconnor> god damn mtl at #4
13:51:05 <joe6> and this seems to be the root of all problems.
13:51:23 <joe6> is it because of using cabal install and cabal install --user?
13:52:46 <joe6> any thoughts, please?
13:52:51 <dons> roconnor: colour doing well
13:53:07 <roconnor> dons: reasonably
13:53:15 <monochrom> "cabal install" = "cabal install --user" by default
13:53:17 <roconnor> dons: I don't really know how to judge it though :)
13:53:28 <joe6> i do not want to nuke everything and start from scratch. It took me almost 2 days to install ghc and all the stuff with the patches and the compile time.
13:53:40 * roconnor hopes colour beats the mtl one day soon.
13:53:48 <ezyang> joe6: Did you seriously compile GHC from scratch? 
13:54:02 <edwardk> monochrom: if you want to give them something portable, you might as well go all the way. I used to have one of these: http://www.cedmagic.com/history/commodore-sx64.html
13:54:20 <joe6> ezyang, i did it at some point, not sure if i did it for this install though..
13:54:21 <ezyang> What I do is I use HP as my "system" installation, so when I blow away .ghc/.cabal I don't have to reinstall GHC or any of the base packages. 
13:54:27 <roconnor> dons: multiplate is a little low though :)
13:54:54 <joe6> ezyang, what is HP?
13:54:58 <ezyang> Haskell Platform 
13:55:14 <joe6> which is part of the debian packaging?
13:55:36 <joe6> but, that is very old and I wanted something newer when I was fooling around with the TH stuff..
13:55:38 <lispy> I install ghc from source on mac because the mac installer uses the wrong libiconv
13:55:55 <lispy> But, on windows I use the HP
13:56:20 <lispy> And on linux I sometimes build from source and sometimes use the binary tarball (but don't bother with the HP)
13:57:08 <joe6> i think it is this directory that is messed up: using cache: /home/j/.ghc/i386-linux-7.1.20110209/package.conf.d/package.cache
13:57:11 <ezyang> joe6: Right. So if you're building it yourself, you should put "pristine" copies in your system directories. 
13:57:28 <ezyang> My guess is that at some point you accidentally upgraded a Cabal package that shouldn't have been upgraded. 
13:57:33 <joe6> any suggestions on how I can nuke just that directory contents and?
13:57:52 <joe6> ezyang, very probable.
13:58:09 <ezyang> But I have no reason in particular for believing that. 
13:58:58 * lispy recommends using cabal-dev for this very reason
13:59:14 <joe6> or, is there some way to just upgrade them both?
13:59:30 <b0fh_ua> Hello! What may it mean "cabal: skypelogexport.cabal:52: Construct not supported at this position: F 52" ? The cabal file is here: http://pastebin.com/csgXcm5C
13:59:31 <edwardk> dons: nice. i note that i still am nowhere near the top. i believe i peak at #249 -- with a now deprecated package ;)
13:59:34 <monochrom> joe6: you can look at "ghc -v | grep shadowed" and see a major factor (if not all factors) of the problem. for each such package, "ghc-pkg unregister --user" it, because it gets in the way.  (as for why they are there to begin with, no one has been able to reliably, scientifically state how to reproduce the phenomenon)
14:00:15 * hackagebot hulk 0.1.2 - IRC daemon.  http://hackage.haskell.org/package/hulk-0.1.2 (ChrisDone)
14:01:13 <ddarius> edwardk: comonads will fly to the fore
14:01:20 <edwardk> ddarius: obviously
14:01:40 <edwardk> ddarius: and void. i mean everyone needs a package for that
14:01:56 <lispy> heh
14:02:04 <edwardk> ddarius:i'm clearly hoping that semigroupoids will ride comonad's coattails into the standard library
14:02:24 <roconnor> edwardk: have you made Void a semigroup?
14:02:59 <edwardk> roconnor: void doesn't depend on anything. so i'd have to make semigroups depend on it instead. reasonable i suppose
14:03:00 <ddarius> It's not just a semigroup, it's a monoid.
14:03:10 <edwardk> ddarius: nah, mempty would be a witness
14:03:20 <roconnor> ahhhhhhhhhhhhhhh
14:03:30 <ddarius> edwardk: I was about to say that you don't want that though.
14:03:36 <ddarius> I think we've had the conversation before.
14:03:36 <joe6> monochrom, could this command cause such an issue: runhaskell Setup.lhs configure --user --prefix=$HOME/.cabal
14:04:13 <edwardk> yeah, it can be a member of Eq and Ord because those use it strictly in negative position.
14:05:11 <monochrom> that depends
14:06:23 <edwardk> rather it never occurs strictly in positive position, without a corresponding appearance in negative position I can plumb through
14:06:48 <joe6> monochrom, any thoughts on this please? http://pastebin.com/KDPQ3W3i
14:07:10 <joe6> looks like it is intricately connected to the current ghc installed.
14:07:39 <monochrom> I wouldn't call hslogger-1.1.3 part of "the current ghc installed"
14:08:04 <joe6> ghc-7.1.20110209 is what I am referring to?
14:08:16 <joe6> should I remove the other packages other than the ghc-?
14:08:56 <joe6> monochrom, is it better to just reinstall ghc and start from scratch?
14:09:28 <joe6> monochrom, if I do so, Is there anything I can do to prevent this happening again?
14:09:55 <monochrom> what does "ghc-pkg field ghc depends" say?
14:11:46 * ddarius admires Baez's panache.  "Formally capturing the idea of 'forgetful' is hard.  I know, let's just declare every functor forgetful!"
14:11:57 <joe6> monochrom, http://pastebin.com/T4A75ksh
14:14:40 <accel> what's a good db to use with haskell?
14:14:58 <kmc> accel, what Haskell projects are you working on?
14:15:15 <accel> i want to build something like gitit; but back it with something besides git
14:15:28 <accel> seems like a good learning opportunity
14:16:32 <monochrom> joe6: the warning may be a red herring. go ahead with "ghc-pkg unregister --user --force process-1.0.1.4". make a backup first (of the whole .ghc directory) if you feel unsafe.
14:18:47 <hpc> accel: the database situation in haskell is generally the same as you will find in other languages or even on their own:
14:18:48 <joe6> monochrom, I cannot seem to uninstall these.: http://pastebin.com/nRACKyke
14:19:02 <hpc> Oracle sucks, Postgres is awesome, MySQL is kind of in the middle
14:19:02 <joe6> monochrom, just saw your message. I will use force.
14:19:19 <hpc> there's more nuance to that, but it's a convenient generalization
14:19:23 <kmc> http://howfuckedismydatabase.com/
14:19:37 <kmc> is Oracle really worse than MySQL other than "requires money"?
14:20:47 <ddarius> My single interaction with MySQL wasn't as bad as my multiple, but thankfully still rare, interactions with Oracle.
14:21:20 <ezyang> Oracle is also impressively annoying to setup. 
14:22:07 <joe6> monochrom, is this what you would expect: http://pastebin.com/iWr5QcEJ
14:22:51 <monochrom> yes! an improvement.
14:23:33 <monochrom> you also need to unregister --user directory-1.1.0.0 and --user template-haskell-2.5.0.0
14:23:36 <ezyang> Oh hey, it's a Heyting algebra. 
14:23:44 <ddarius> http://ncatlab.org/nlab/show/evil
14:23:59 <ddarius> Oracle is just impressively annoying.
14:24:43 <joe6> monochrom, still the same error on installing though: http://pastebin.com/yUk4W0CQ. sorry, let me remove the directory and template-haskell and try.
14:24:48 <monochrom> I also see that "| grep shadowed" doesn't filter out anything. you can omit that.
14:25:39 <monochrom> don't do any "cabal install" yet. at most do "cabal install --dry-run"
14:27:12 <joe6> monochrom, here it is. http://pastebin.com/5m0z01Q9
14:27:24 <joe6> monochrom, should I install xmonad now?
14:27:24 * hackagebot ghc-syb-utils 0.2.1.0 - Scrap Your Boilerplate utilities for the GHC API.  http://hackage.haskell.org/package/ghc-syb-utils-0.2.1.0 (ThomasSchilling)
14:27:29 <joe6> from cabal, I mean..
14:27:46 <joe6> cabal install in the xmonad directory, I mean.
14:27:49 <edwardk> oracle is a wonderful solution -- when your problem is having too much money in the bank
14:28:30 <joe6> have not tried postgresssql, but oracle seemed to better than MySQL/MS SQL Server/ DB2.
14:29:06 <joe6> the last I used them..
14:29:24 <hpc> edwardk: what gift do you give the person who has everything?
14:29:27 <JuanDaugherty> there's a free version of oracle
14:29:28 <hpc> your oracle license
14:29:29 <monochrom> joe6: please "cd ~" and then "cabal install --dry-run xmonad-contrib". I want to see what it says.
14:29:57 <JuanDaugherty> free version of most shit these days, minimal but usually fully functional
14:30:19 <JuanDaugherty> oracle xe, vs express, flex sdk, etc.
14:30:33 <edwardk> hpc: =)
14:31:18 <hpc> actually, i lie; you give them a bank of america account :P
14:31:25 <JuanDaugherty> i think there's even a free SAP pkg
14:31:49 <joe6> monochrom, http://pastebin.com/DnCvrTG6
14:31:49 <Botje> SAP is open source
14:32:25 * hackagebot vty 4.6.0.6 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.6.0.6 (CoreyOConnor)
14:33:50 <joe6> monochrom, with -v option added, http://pastebin.com/wDgaF9Te
14:34:04 <joe6> is SAP open-source?
14:35:06 <JuanDaugherty> no it isn't
14:35:17 <JuanDaugherty> there are doubtless some components
14:35:20 <JuanDaugherty> that's not new
14:35:25 <monochrom> oh I see. "ghc-pkg unregister xmonad-0.10", "ghc-pkg unregister process-1.0.1.5", "ghc-pkg unregister type-level-0.2.4". (yes you are losing them; install them later if you want them back.) after that, I want to see "cabal install --dry-run xmonad-contrib" again.
14:35:29 <JuanDaugherty> but SAP ECC isn't
14:36:15 <JuanDaugherty> super commercial and open source are anthithetical opposites
14:37:02 <joe6> monochrom, did that. that is what the output is:  http://pastebin.com/DnCvrTG6, http://pastebin.com/wDgaF9Te
14:37:08 <astory> I've got a function I think I'm memoizing using Data.Memocombinator, but it's repeating method calls.  Is there anything I can do to debug?
14:37:22 <ezyang> astory: Pastebin? 
14:37:29 <ezyang> How do you know it's repeating method calls? 
14:37:38 <JuanDaugherty> if you have a corporate account your may well have full access to the sources but that's not what is generally understood
14:37:40 <ezyang> are you appropriately sharing the memoized version? 
14:37:45 <Ke> not so much commercial but business practices that rely on non-conventional methods for extracting profit
14:37:54 <JuanDaugherty> by "open source"
14:37:54 <astory> unsafePerformIO was how I was determining it, also, exponential runtime
14:37:58 * ezyang gestures vaguely at #haskell-blah 
14:37:58 <astory> let me get a paste up
14:38:00 <Ke> like skype or itunes
14:38:39 <monochrom> eh? why are xmonad-0.10, process-1.0.1.5, type-level-0.2.4 still present?
14:38:40 <joe6> monochrom, with just the dry-run output, http://pastebin.com/KJ6XaWUe
14:38:41 <Ke> hmm, well skype is a bad example
14:38:48 <ezyang> OMG, system F is second order logic. 
14:39:28 <astory> https://github.com/Meteorswarm/cs4740_2/blob/master/Probabilities.hs, the function is 'v' in 'viterbi', and the memoized version should be v'
14:39:46 <joe6> monochrom, must have gotten the pastebin's mixed up: http://pastebin.com/ZhHKRbDP
14:40:39 <monochrom> hrm, and "cabal install --dry-run xmonad-contrib" still tries to pull in process and haskell98?
14:40:50 <ddarius> ezyang: No it isn't.  At least not as "second order logic" is typically meant.
14:40:52 <joe6> monochrom, yes
14:41:19 <ddarius> ezyang: As a demonstration, consider what first order logic would correspond to, and second order logic includes first order logic.
14:41:29 <joe6> monochrom, there is no haskell98 in my ghc-pkg list now.
14:41:33 <accel> is there any effort to write a DSL in haskell for implementing bigtable/hbase ?
14:41:40 <ezyang> Ughhh, I made this mistake again >.> 
14:41:42 <joe6> monochrom, could that be the reason that it is trying to install it ?
14:41:57 <joe6> monochrom, there is a haskell2010 though..
14:42:08 <ezyang> I mean second-order *intuitionistic propositional* logic. 
14:42:15 <ezyang> I need to stop eliding those words. 
14:43:05 <monochrom> you didn't unregister haskell98, did you?
14:43:17 <joe6> monochrom, http://pastebin.com/H9yLGGgY
14:43:34 <joe6> monochrom, yes, it was also one of those packages with the unusable error.
14:43:34 <thoughtpolice> accel: ? a DSL to *implement* hbase/bigtable, or a DSL for *using* something like hbase/bigtable? i don't think either exists
14:43:52 <joe6> monochrom, unregistered haskell98, I mean.
14:43:55 <thoughtpolice> i don't even know what a DSL for implementing something like hbase would look like, or what sort of scope you're talking about, so it's hard to answer
14:44:25 <shachaf> thoughtpolice: Then your question clearly wasn't necessary. :-)
14:44:27 <dcoutts_> monochrom: what's odd is that it seems convinced that they're not installed
14:44:29 <monochrom> you shouldn't unregister it. I only asked to unregister process, directory, template-haskell
14:44:47 <dcoutts_> monochrom: oh ok, perhaps not so odd :-)
14:45:01 <joe6> monochrom, I had jumped the gun before you said so. was being over-eager, I guess.
14:45:21 <joe6> monochrom, I have the package source. can I do cabal install there?
14:45:27 <joe6> to re-register it, I mean.
14:45:32 <dcoutts_> monochrom: btw, I should run my plan past you about adding some better safety catches to avoid re-installing and breaking packages.
14:45:38 <accel> thoughtpolice: a DSL for implmeneting databases
14:45:43 <joe6> monochrom, of haskell98, I mean.
14:45:50 <astory> arg, I've got to run, I'll bring my question up later.  Thanks.
14:46:08 <monochrom> is that the right version? haskell98-1.1.0.0?
14:46:26 <thoughtpolice> shachaf: :P
14:46:26 <joe6> yes
14:46:35 <joe6> monochrom, yes, exact version.
14:46:36 <monochrom> alright, but make sure it is --global
14:46:40 <thoughtpolice> accel: no such thing exists AFAIK
14:47:12 <accel> databases is about algorithms for manaing layouts in RAM/disk
14:47:21 <accel> it seems like this is a great opportunity for designing DSLs
14:47:35 <maurer_> accel: Then build one and let us know how it turns out :)
14:47:42 <monochrom> dcoutts_: do you know of any glitch with the combination "cabal-install version 0.9.5 using version 1.10.0.0 of the Cabal library"?
14:47:52 <accel> I'm not complaining haskell lacks one.
14:47:56 <accel> I'm merely asking if one exists.
14:48:02 <accel> if I was compainig I'd be like
14:48:11 <dcoutts_> monochrom: I don't, no
14:48:14 <accel> Haskell sucks; why is there no DSL for implementing databases?
14:48:22 <jfischoff> does anyone here know the state of Haskell on the iphone?
14:48:43 <monochrom> alright then, it should be fine.
14:48:46 <dcoutts_> monochrom: but that is a dev version, so slightly hard to say
14:48:48 <edwardk> accel: then write one
14:48:54 <msg> There are people that do. Perhaps Cale?
14:48:56 <maurer_> jfischoff: Didn't apple make some rule that basically outlawed "code-which-is-not-Obj-C"?
14:48:56 <jfischoff> is there a way to cross compile with using llvm?
14:48:57 <shachaf> jfischoff: #haskell-game might know.
14:49:02 <dpratt71> well, this is kind of confusing...
14:49:08 <shachaf> Or ryant50002, maybe?
14:49:17 <jfischoff> maurer: yeah but then they got rid of it
14:49:30 <Cale> jfischoff: The best person to talk to would be Stephen Blackheath
14:49:34 <jfischoff> shachaf: thanks, I'll check it out
14:49:38 <monochrom> buggy software tends to behave unbuggy when I'm supervising.
14:49:39 <edwardk> jfischoff: it is in a decent enough state that Cale and company over at iPwn can use it to hack on a game
14:49:40 <dpratt71> ...leksah doc says go to Package -> OpenPackage...am I blind? I don't see that option
14:49:48 <Cale> Or RyanT5000, yeah
14:49:55 <Cale> (Ryan Trinkle)
14:50:19 <monochrom> I have two real stories to share if you like this superstitution, in fact. :)
14:50:20 <edwardk> jfischoff: beyond that i don't think the port has been integrated into mainline in any meaningful way. it mostly showed how crappy our cross-platform support was
14:50:40 <sm> accel: there's a DSL for managing layouts in RAM/file trees (forest)
14:50:47 <dons> jfischoff: kinda works
14:50:49 <dons> you can write apps
14:50:56 <edwardk> monochrom: so what you are saying is i need to pay you to sit in front of a server all day, and do nothing but stare intently at the machine?
14:50:57 <dons> prob incomplete, definitely experimental
14:51:00 <jfischoff> edwardk: yeah that is what I was wondering. I know that they made their branch before the llvm support, so maybe it was better now
14:51:01 <dpratt71> anyone here successfully used leksah?
14:51:07 <accel> sm: wht is it called?
14:51:11 <sm> Forest
14:51:12 <accel> dpratt71: yeah; I kinda like it
14:51:21 <sm> recently announced
14:51:24 <accel> dpratt71: except it's lacking an editor; but the auto completion + auto build system, i really like
14:51:26 <jfischoff> dons: how long do you think it would take to get up and running?
14:51:33 <dpratt71> accel: how do you 'open' a package?
14:51:47 <dons> jfischoff: unknown.
14:51:48 <accel> sm: link? I can't find it via google
14:51:51 <jfischoff> hehe
14:51:53 <sm> reddit I think
14:51:54 <joe6> monochrom, I messed up. It was the library files that I had. not the source.: http://pastebin.com/wxLCpnA3
14:52:23 <edwardk> jfischoff: well, iirc, the bulk of the patch consistent of a ton of changes to the build system -- which was replaced almost immediately after they were done, and one other major aspect of the patch was how it managed callbacks without doing dynamic code generation, which isn't really portable/palatable as a general purpose solution
14:52:55 <monochrom> source is cheap. "cabal install --global --root-cmd=sudo haskell98-1.1.0.0" may work wonders.
14:52:56 <jfischoff> edwardk: so in otherwords there might be a better solution now?
14:53:28 <gienah> accel dpratt71 leksah has a yi cabal flag to use yi as its editor
14:53:34 <jfischoff> I think I need look david t and some apple llvm engineers in room for a bit, just get it working 
14:53:44 <jfischoff> in a drop dead simple way
14:53:45 <monochrom> but actually I would again "cabal install --dry-run haskell98-1.1.0.0" first to see if there is anything I don't want
14:53:53 <edwardk> jfischoff: more like, most of the work they did doesn't apply to the current build system, and the callback hack they had doesn't really have a cleaner implementation i can think of
14:54:06 <jfischoff> edwardk: ah
14:55:56 <joe6> monochrom, "cabal install --global --root-cmd=sudo haskell98-1.1.0.0" -- where does it install the package? in the root directory (/ or /usr)?
14:55:56 <jfischoff> edwardk: on the surface I can't see why it would be terribly difficult to make static lib I link against, but that is because I am so ignorant :)
14:56:15 <joe6> monochrom, or is it the root directory of ghc?
14:56:25 <dpratt71> accel: do you have a Package -> OpenPackage menu item (in leksah)?
14:56:52 <joe6> or can i call it as, cabal install --configure-option --prefix=/home/j/.ghc
14:57:01 <accel> gienah: have you used it? you need to custom build leksah for that
14:57:48 <monochrom> oh oops, we need to control the directory carefully, yes.
14:58:18 <edwardk> jfischoff: the callback issue has to do with the way you hand off functions to c, ultimately you need to hand c a function pointer in some contexts, in haskell those functions close over an environment, iirc, the way ghc does it now is it generates a small executable stub of code dynamically that loads the right info into a register then jumps back into haskell. this works fine if you can have pages you write to that have execute priv
14:58:23 <monochrom> /usr/local/lib/haskell98-1.1.0.0 by default.
14:58:34 <Mathnerd314> is multirec abandoned?
14:58:40 <gienah> accel: yes, I patched leksah and yi to build with ghc 6.12.3 and 7.0.2 on gentoo, if your using another os you can look at gentoo to see how to build it: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/app-editors/leksah
14:58:53 <monochrom> --prefix=/home/j/.ghc somewhat helps
14:59:21 <accel> gienah: whoa; nice; does auto completion / that nice window that pops up and shows functions w/ their signaures ... work with yi inside of leksah?
14:59:43 <accel> Does haskell not have bindings to hbase/hadoop? (I can't find it on hackage.haskell.org)
14:59:44 <joe6> monochrom, ok will do.
14:59:48 <jfischoff> edwardk: got it. The iphone works like a console, no jit-ing.
14:59:57 <monochrom> joe6: actually, please wait for a moment.
15:00:04 <edwardk> however, this approach isn't viable on the iphone for a.) term of service reasons, and b.) technical restrictions, so they instead create a fixed sized pool of these functions, by making a small fixed sized pool of pointers, and having each function jump indirectly through the pointer after loading the data from another, and when you hand off a haskell function for a callback to c, you consume one of the slots
15:00:29 <jfischoff> edwardk: but haskell doesn't have a mode for that. Or what if you just embedded ghci?
15:00:45 <gienah> accel: I don't know, have not used it enough to check that
15:00:45 <edwardk> so if you change up your callbacks frequently, then the approach used by the ipwn guys wouldn't work.
15:01:10 <accel> gienah: do you like to build hard to build packages just for the sake of building them? :-)
15:01:46 <edwardk> its more fundamental, it is about the fact that when i pass a haskell function as a function reference to c, this fundamentally needs that mixed privilege support
15:02:11 <monochrom> joe6: alright, there is no better way, please proceed
15:02:21 <joe6> monochrom, ok, will do.
15:02:34 <edwardk> you can work around it, by making a small pool of fixed callbacks, and maintaining lots of state haskell side, but its a hack =)
15:02:42 <gienah> accel: yes, I'm masochist that just loves building hard to build packages so hopefully other people will enjoy using them :-)
15:03:42 <joe6> monochrom, this is what the dry-run says: http://pastebin.com/MLY6qw3A
15:03:45 <thoughtpolice> edwardk: yeah, the adjustor stuff in GHC is a no-go for iPhone. consuming the callback slots is also nasty and tedious, but it seems to work.
15:04:03 <thoughtpolice> at least it becomes tedious and annoying when you need more callbacks
15:04:21 <edwardk> thoughtpolice: yeah, in the ipwn case i think they only have one or two
15:04:29 <thoughtpolice> jfischoff: there are people (including me, I just got my new computer so I can work again!) interested in turning GHC into a real cross compiler
15:04:31 <MasseR> It's usually recommended to keep tests separate from main code. How should Main be tested?
15:04:35 <monochrom> joe6: oh actually, I wonder what is your file ./ghc/inplace/lib/package.conf.d/haskell98-1.1.0.0-inplace.conf , i.e., where does it come from, do you know?
15:04:49 <jfischoff> thoughtpolice: yes me!
15:05:01 <joe6> monochrom, still failed at the same place: random.hs: http://pastebin.com/n6RXcqtG
15:05:13 <thoughtpolice> jfischoff: as of right now, LLVM may not work the way you expect it to. typically the bitcode generated by LLVM/ghc is dependent on the platform in one way or another, because for example, you may depend on constants defined in C headers, which could be very architecture specific, etc
15:05:15 <joe6> monochrom, no idea.
15:05:37 <jfischoff> thoughtpolice: yes I have no idea how it really works
15:05:45 <monochrom> is that where you unpacked ghc 7.1.20010209 binary tarball?
15:05:51 <thoughtpolice> in theory, LLVM bitcode is in fact totally portable, but for example, code that takes endianness into account for example, won't directly work cross platforms (i.e. you couldn't take that bitcode generated by llvm on x86 and then run it on your PPC machine)
15:06:01 <pedro3005> why does something like "infixr 5 :-: ; data List a = Empty | a :-: (List a) deriving (Eq)" work but doesn't work if I change :-: to @ or @@?
15:06:24 <jfischoff> thoughtpolice: that makes sense if you are talking about some sort of parsing at the application level
15:06:28 <Mathnerd314> pedro3005: because : is special 
15:06:32 <edwardk> pedro: to make a type level 'operator' it has to start with :
15:06:46 <hpc> ':' is a "capital symbol" as it were
15:06:49 <joe6> monochrom, that would make sense.
15:07:03 <thoughtpolice> jfischoff: but we're working on making GHC a Real Cross Compiler, in the sense if you have any one installation, you can cross compile your code to any other platform GHC supports (provided you have the necessary dev tools of course, you'll need to compile the RTS, for example, so you can link ARM applications together on your x86 machine)
15:07:04 <savage> does haskell ever get painless? compared to c++ or java?
15:07:06 <hpc> (analogous to a capital letter; it isn't anything special in unicode"
15:07:10 <hpc> s/"/)
15:07:13 <jfischoff> thoughtpolice: is there a coordinated effort to extend ghc in a way to make cross-compiling easier?
15:07:15 <joe6> monochrom, probably where i unpacked the tarball.
15:07:19 <edwardk> savage: more so, IMHO, after protracted use
15:07:23 <pedro3005> I see, thank you
15:07:39 <hpc> c++ and java got MORE painful for me with use
15:07:50 <savage> I see how it's great for things like parsers, because of the pattern matching
15:08:05 <thoughtpolice> jfischoff: it's pretty loose right now. Simon M is interested, but of course GHC HQ has 10,000,000 other things to do. loosely speaking the only person actively working on it is dankna. i've been out of commission for the past week because my computer died
15:08:08 <hpc> i got more sensitive to the crappy syntax as my goals outgrew the language
15:08:09 <thoughtpolice> just got a new one, though
15:08:10 <savage> but for general use...
15:08:20 <monochrom> joe6: could you upload ./ghc/inplace/lib/package.conf.d/haskell98-1.1.0.0-inplace.conf ? it may be what I'm looking for
15:08:21 <hpc> savage: http://98.169.17.243:8000/blog/
15:08:35 <hpc> ^ website made in haskell, with some posts about it
15:08:35 <thoughtpolice> jfischoff: we're trying to get a good wiki page up describing some current in-progress patches and design issues, i haven't talked to dankna this week
15:08:36 <copumpkin> dankna: how's that going by the way?
15:08:53 <dankna> oh, yes
15:08:54 <thoughtpolice> there's also phunge, who worked out a nice patch for hsc2hs to make it safe for cross compiling, although he's MIA at the moment
15:08:56 <jfischoff> thoughtpolice: well if there is maillist or something I wouldn't mind being added. 
15:09:16 <thoughtpolice> jfischoff: jump on glasgow-haskell-users and #ghc here on freenode. those places will almost certainly have the most relevant discussion
15:09:20 <hpc> savage: also, the first perl6 compiler was written in haskell
15:09:31 <hpc> there's a high frequency trading firm that uses haskell for their programs
15:09:39 <jfischoff> thoughtpolice: cool
15:09:47 <dons> several, i think, hpc
15:09:48 <thoughtpolice> jfischoff: the main thing is, it's just A Lot Of Work. also, we need to be very careful we don't break GHC on other architectures that are much less tested
15:09:49 <pozic> hpc: or perhaps 'was' ;)
15:09:54 <pozic> hpc: they are in Tokio.
15:09:56 <hpc> was? D:
15:09:57 <thoughtpolice> i'd be very hesitant to touch the PPC backend for example
15:10:01 <hpc> oh
15:10:02 <dons> also Chicago
15:10:11 <pozic> dons: who are they?
15:10:11 <thoughtpolice> when there are no eyes, all bugs are deep
15:10:12 <hpc> there's also a few games in haskell
15:10:16 <dankna> well, I need to rework stuff as discussed at last week's meeting (sorry I didn't make today's).  I'm still figuring out the best workflow for doing that... I confess I'm a little lost with how to back out my inadvertent whitespace changes while preserving my other stuff and adding yet more stuff, with such a large repository.
15:10:16 <jfischoff> thoughtpolice: could any of the work be done by the Apple LLVM team?
15:10:20 <napping> savage: c++ and Java both strike me as pretty painful
15:10:28 <ddarius> There are several banks and other financial corporations that use Haskell in some respect or another.
15:10:42 <jfischoff> thoughtpolice: or anyone else for that matter
15:10:44 <ddarius> And, of course, that's only those who make that fact public.
15:10:45 <dons> pozic: Allston Trading
15:10:46 <thoughtpolice> jfischoff: we're not working on the LLVM stuff at the moment, we're making GHC's native code generation backend do this
15:10:47 <napping> savage: There are certainly tricky things in Haskell, but you don't have to use them
15:11:08 <jfischoff> thoughtpolice: ah
15:11:08 <savage> napping: but for some applications haskell is just a bad idea, right?
15:11:16 <Axman6> savage: i worked for Tsuru capital in Tokyo, who uses haskell exclusively, for high frequency trading
15:11:16 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
15:11:20 <copumpkin> pozic: why was?
15:11:20 <Axman6> :o
15:11:22 <dankna> I did have to touch the PPC backend btw.
15:11:31 <thoughtpolice> jfischoff: independent of that though, there's a *lot* of stuff in GHC that is going to need to change, the code generators are just one part
15:11:44 <Mathnerd314> is multirec abandoned?
15:11:47 <dons> Axman6: i didn't know you worked for them. cool 
15:11:48 <hpc> savage: it depends; you probably wouldn't do low-level stuff in haskell, but you could write a program that outputs the C code
15:11:56 <jfischoff> thoughtpolice: ugh, maybe I need to figure out a hack for now
15:11:59 <ddarius> savage: Sure.  You don't want Haskell on an memory-constrained embedded device with real-time constraints, though you may still use Haskell when developing software for such things as some do.
15:12:00 <thoughtpolice> dankna: be careful :) there seem to be several PPC users however.
15:12:02 <ezyang> "I.e., that's what GHC does" 
15:12:03 <Axman6> dons: yup :)
15:12:04 <dankna> I know :)
15:12:11 <thoughtpolice> dankna: as for the alpha backend...
15:12:12 <hpc> also what ddarius said
15:12:21 <pozic> Axman6: why did you leave?
15:12:27 <dankna> yeah, what's the status of the alpha backend?  it didn't seem to, er, contain any code-generation :)
15:12:29 <Axman6> it was an internship
15:12:34 <Axman6> 3 months
15:12:34 <dons> capture is written in haskell, http://www.janrain.com/products/capture 
15:12:35 <dankna> is that shared with another arch or something?
15:12:46 <pozic> dankna: ah, so they wanted free labour.
15:13:00 <napping> dankna: via-C?
15:13:03 * dankna != Axman6
15:13:07 <thoughtpolice> dankna: i was pretty sure there was some code generation stuff in there, but honestly I'm not exactly sure who uses GHC on alpha anymore, if at all
15:13:08 <dankna> napping: that could be, yes
15:13:09 <napping> perhaps registerized?
15:13:15 <thoughtpolice> ah, napping is probably right
15:13:20 <pozic> dankna: sorry about that. 
15:13:22 <copumpkin> pozic: I don't think it was free
15:13:25 <joe6> monochrom, sorry for the delay.
15:13:25 <dankna> np, just pointing it out
15:13:27 <joe6>  http://sprunge.us/HKJS
15:13:35 <Axman6> pozic: it wasn;t free, i was paid quite well ;)
15:13:35 <joe6> monochrom,  http://sprunge.us/HKJS
15:13:39 <lispy> dcoutts: naughty naughty!  You should convert the public cabal-install repo to hashed
15:13:44 <napping> The native code generator is probably more recent than Alpha being maintained
15:13:44 <monochrom> actually it's pretty strange that ghc-7.0.2 uses haskell98-1.1.0.1 while ghc-7.1 uses 1.1.0.0
15:13:44 <thoughtpolice> i'd honestly imagine finding alpha machines beefy enough for recent GHC compiles to be very very hard to find
15:13:46 <copumpkin> pozic: they also posted to haskell-cafe about paying 150k for a full-timer a while back
15:13:49 <Axman6> I wouldn't have this new MacBook Pro if i weren;t paid :P
15:13:56 <thoughtpolice> but that's why we're making a GHC a cross compiler! :P
15:14:00 <pozic> Axman6: usually an internship is just expenses. 
15:14:05 <dankna> indeed!
15:14:13 <dankna> that sort of thing is a big motivation for this work
15:14:25 <Axman6> pozic: not this one, included flights and an apartment, on top of pay
15:14:31 <dankna> and for example if we ever wanted to add an ARM NCG, we would need full cross-compilation support
15:14:32 <joe6> monochrom, it could be the manual installation messing up things too.
15:14:35 <pozic> Axman6: ok
15:14:38 <lispy> dcoutts: http://wiki.darcs.net/OF
15:14:43 <thoughtpolice> dankna: re cross compilation, i remember in #ghc last week your patches were discussed. i believe it came down to the fact that dynflags is threaded into the native code generation monad already, yes?
15:14:52 <Axman6> dons: hey are you involved with this new NICTA partnership with Galois?
15:15:01 <lispy> dcoutts: typically as easy as; optimize --upgrade
15:15:02 <dankna> there were a couple action items for me from last week, yes
15:15:11 <thoughtpolice> dankna: I've been doing ARM stuff a lot recently, I think an ARM backend for GHC would be mighty fine and useful, so perhaps in the loooong run, that's on my TODO list :)
15:15:12 <pozic> Anyway, it was more of a joke. I think the major stock exchanges are open in Japan.
15:15:15 <dankna> need to remove whitespace changes that I had inadvertently included to make my patch easier to review
15:15:33 <dankna> need to replace the threading of Architecture with threading of DynFlags everywhere
15:15:38 <monochrom> joe6: alright, this file wouldn't help. I suppose we really have to proceed with "cabal install --global --prefix=/home/j/.ghc haskell98-1.1.0.0" then
15:15:43 <dankna> need to use the monad to pass it where that's possible
15:15:53 <dankna> that's everything I can think of
15:16:11 <thoughtpolice> dankna: yeah, I believe JaffaCake said there were several places in the backend that already have exposure to dynflags, so it might actually make the patches significantly smaller
15:16:22 <dankna> I don't believe it will be significant
15:16:23 <dons> Axman6: somewhat
15:16:30 <dankna> most of the functions I threaded stuff through were not in monads at all
15:16:30 <thoughtpolice> which is good. GHC moves too fast sometimes, keeping certain types of patches up to date can be nightmarish 
15:16:36 <dankna> because most of them were ppr functions
15:16:39 <thoughtpolice> dankna: ah, the pretty printers mostly you mean?
15:16:41 <dankna> yes
15:16:55 <dankna> I absolutely agree that a smaller patch is highly desirable
15:17:09 <dankna> and will do what I can to achieve one
15:17:23 <thoughtpolice> yeah, it's just going to be really hard to make a patch like that small :(
15:17:56 <joe6> monochrom, http://pastebin.com/bv3qkmXj
15:17:57 <thoughtpolice> what you're doing is a huge part of the work in the backend though, so hopefully the patches past that can be much smaller for the most part
15:18:06 <thoughtpolice> (until we hit some other giant thing i'm totally not thinking of)
15:18:16 <monochrom> oh yikes, same problem
15:18:31 <dankna> exactly
15:18:39 <Axman6> dons: just thought it was interesting, glad to see two companies I'd like to work for teaming up
15:19:21 <savage> Still, those are some niche areas for haskell, right?
15:20:03 <ddarius> Haskell: Only good for making money
15:20:17 <Axman6> :(
15:20:32 <monochrom> perhaps you have to re-install ghc again. this should preserve all your --user packages if we're lucky. it's really just re-copying all the necessary files just so we get back the one single file we lost.
15:20:53 <dankna> anyway, I'm not used to having to rework my stuff like this, but it's obviously critical to being part of a team, so I'll just have to learn :)
15:20:57 <thoughtpolice> dankna: but yes, now that I have my new machine, I can actually start helping and not flabbing my mouth! weeeeeeeee
15:21:02 <dankna> great!
15:21:05 <dankna> I look forward to it
15:21:14 <monochrom> if you built ghc yourself and hasn't deleted anything in the source tree, you shouldn't need a rebuild. just a re-copying of files to destination.
15:21:17 <dons> savage: http://haskell.org/haskellwiki/Haskell_in_industry 
15:21:18 <thoughtpolice> I would like to use XCode4 and all, although it badly breaks GHC builds at the moment it seems
15:21:35 <thoughtpolice> so 3 will have to suffice for the moment until that's figured out
15:21:37 <pozic> dons: that page is out of date.
15:21:42 <monochrom> if you used a binary tarball, that's even easier and less harmful.
15:21:59 <Axman6> savage: both Intel and AMD are also now using Haskell for several things
15:22:08 <savage> I'm intrigued
15:22:25 <savage> Because I'm having a hard time with every single thing I do in haskell :P
15:22:30 <thoughtpolice> AMD is using haskell for some really nifty OpenCL work
15:22:30 <Adamant> ddarius: Haskell: it only does everything
15:22:35 <thoughtpolice> what's intel using it for? same thing?
15:22:55 <Adamant> is NVIDIA using it?
15:22:58 <Axman6> savage: that's because you've been infected by other languages first
15:22:59 <pozic> savage: using Haskell without proper education seems like a mistake to me.
15:23:21 <savage> Well I had a functional programming course, and I'm doing another assignment with haskell now
15:23:30 <Axman6> thoughtpolice: their CNC framework (concurrent something something...)
15:23:34 <savage> But it's pretty much "We want a program that does this, MAKE IT!"
15:23:40 <thoughtpolice> uh, i disagree entirely. i had pretty much on education on any sort of advanced programming language technology when I came to haskell like 5 years ago
15:23:43 <thoughtpolice> *no
15:23:50 <pozic> savage: you mean that that is easier?
15:23:51 <Axman6> savage: there's a fairly large difference between practical haskell and academic haskell
15:23:54 <monochrom> "proper education" does not exist.
15:24:06 <thoughtpolice> it just takes some time, and Axman6 is right - your brain has been infected by other languages
15:24:12 <joe6> monochrom, let me try reinstall the ghc reinstall
15:24:19 <thoughtpolice> IME, you'll spend a bit of time unlearning things, before you can really start appreciating some things
15:24:21 <savage> Yes, I am well aware of that
15:24:50 <jfischoff> thoughtpolice: I meant some people at game middleware company that mention they were pushing for openCV to has an assembly language specification so haskell could compile into it. I wonder if that is what AMD is doing..
15:24:50 <thoughtpolice> it's all very well worth it though. i proudly say haskell totally changed the way I think about writing software, and that's a very good thing. :)
15:24:55 <savage> I have a nagging voice that keeps changing my train of though to "I want to set a variable"
15:25:15 <Adamant> IO
15:25:24 <Adamant> for the short run
15:25:32 <Adamant> for the long run, learn to not set them
15:25:37 <pozic> For really large systems, it also seems that Haskell is pretty much fundamentally flawed.
15:25:41 <hpc> when i program in perl at work, i have a nagging voice in my head that wants me to compose functions
15:25:43 <Adamant> how so?
15:25:43 <savage> It must take a lot of practice to be able to switch from C++ to Haskell in an instant
15:25:46 <thoughtpolice> jfischoff: AMD is doing something different; they're using Haskell to write OpenCL programs. basically, what it comes down to is the regular OpenCL API is very cumbersome
15:25:58 <pozic> Take x{a = b } and tell me how long it takes to execute that.
15:26:04 <thoughtpolice> so they have a very nice, type safe wrapper around the OpenCL API with some nice quasi-quoting goodness
15:26:11 <thoughtpolice> pozic: I can't, because it has 0 context
15:26:19 <thoughtpolice> making the example worthless, IMO
15:26:19 <hpc> pozic: TWELVE!
15:26:24 <pozic> thoughtpolice: tell me the complexity.
15:26:26 <hpc> problem solved :D
15:26:36 <savage> I actually had to implement the algorithm first in PROLOG, then in Haskell... 2^confusing...
15:26:37 <pozic> thoughtpolice: if the number of fields is called n. 
15:26:57 <thoughtpolice> jfischoff: see this - http://developer.amd.com/zones/OpenCLZone/publications/assets/MakingOpenCLSimplewithHaskell.pdf
15:27:12 <jfischoff> thoughtpolice: thanks
15:27:21 <Axman6> mmm, why is vegemite so addictive
15:27:24 <pozic> So, we have x which has fields f1.. fn. Then we do x{f1 = 1}. How long is that going to take?
15:27:25 <hpc> savage: the easiest way to transition from a C-like to Haskell is to take a good math course, like discrete math
15:27:37 <hpc> it will get you in the right mindset rather quickly
15:27:50 <thoughtpolice> pozic: TBH, I'm not a person to ask about that, i'm very shoddy on determing complexity in general, and that's my fault, no fault of haskell. i was just pointing out that saying "take this, tell me how long it takes to execute" is rather vague and not welld efined
15:27:52 <hpc> (this is my opinion at least)
15:28:03 <savage> Yes maybe
15:28:13 <savage> I'm not very math oriented, but I see your point
15:28:18 <monochrom> I don't see how "large system" leaps to "how long does it take"
15:28:20 <pozic> thoughtpolice: it is going to take _linear_ time in the size of the field. 
15:28:31 <pozic> er n
15:28:51 <Adamant> pozic: and it wouldn't in an imperative or OO language?
15:28:52 <thoughtpolice> hm, i actually wonder what the core looks like for something like that
15:28:53 <pozic> So, assuming a large system has e.g. a tree structure with lots of fields.
15:28:58 <hpc> n+k, where k is the extra pointery gook
15:29:03 <monochrom> from "fast system" to "how long does it take", sure. but not all "large system"s have to be "fast system"s, and not all "fast system"s have to be "large system"s.
15:29:08 <pozic> That is going to be n times slower in Haskell. 
15:29:12 <savage> It's actually not the 'math'-y concepts like composition I have trouble with
15:29:19 <pozic> Yes, you can implement it with references.
15:29:26 <ezyang> pozic: Haskell doesn't force you to be persistent... 
15:29:30 <pozic> Except you are not programming functionally anymore...
15:29:38 <savage> but things like IO and the desire to use global variables
15:29:39 <ezyang> "Who cares?" 
15:29:42 <ezyang> Right tool for the right job. 
15:29:43 <pozic> ezyang: to a large extent it does.
15:29:55 <ddarius> monochrom: Furthermore, not all large systems have to be written by idiots.
15:30:30 <ezyang> Haskell is actually quite good at mutation of "flat" types, like arrays. It's less good at recursively mutable structures. 
15:30:31 <joe6> monochrom, installing the random package took care of that error.
15:30:39 <joe6> monochrom, just as an fyi..
15:30:44 <monochrom> hrm interesting
15:30:49 <pozic> ezyang: ah, so you suggest to rewrite the whole system with ST when it becomes clear after 5 years that it is 'too slow'.
15:30:54 <pozic> ezyang: great idea!
15:30:56 <joe6> and now the haskell98 package is installed.
15:31:02 <shachaf> How large is a "large system"?
15:31:27 <Adamant> pozic: does it have to be laid out as a tree with large linear members?
15:31:28 <monochrom> lately, "large system" is moving towards "let's draw inspiration from biology", and that's a recipe of "slow system" actually, but people seem to be contend.
15:31:28 <hpc> and what nature of largeness?
15:31:39 <pozic> Even if it is a tree structure with lets say 20 fields it already takes too long.
15:31:50 <Adamant> or is that just the most natural way of doing it?
15:31:53 <thoughtpolice> that seems like a ridiculously selective example nonetheless. furthermore, I detest the idea that everything in haskell has to be purely functional. eradicating mutable state is NOT the goal of haskell. the goal is to make things like mutability and different kinds of state easier to reason about
15:31:54 <ezyang> pozic: From personal experience, that's probably not going to be the reason your system is slow. 
15:32:02 <joe6> monochrom, should i do the dry-run of xmonad-contrib now.
15:32:13 <ezyang> joe6: Can't hurt. 
15:32:37 <thoughtpolice> and frankly, haskell does this extremely well. the goal was never to 'win' against things like using pointers or references. it was to make it easier to reason about the kinds of state we encounter in the real world, and controlling it
15:32:41 <Adamant> pozic: I'm pretty sure you could convert it into an array if speed was in issue
15:32:42 <thoughtpolice> isn't that what ST is meant for?
15:32:45 <pozic> ezyang: I don't think you quite understand. 
15:32:48 <joe6> monochrom, this is what it says: http://pastebin.com/wMZ3H3bv
15:32:54 <pozic> Adamant: uhm, no.
15:32:56 <savage> Ugh im too tired to think. How would I print out a grid that is stored in a [[Int]]?
15:33:03 <pozic> Adamant: I said 'a tree structure'.
15:33:10 <joe6> monochrom, should i go ahead with the install of xmonad-contrib now?
15:33:24 <Adamant> yeah, and you can encode trees in arrays, depending on what you want to do with them
15:33:34 <pozic> Adamant: if such a tree representation would always be a good idea, don't you think GHC would do so?
15:33:35 <shachaf> savage: print?
15:33:46 <Adamant> pozic: it's an optimization
15:33:51 <Adamant> not a universal one
15:33:54 <mee> savage: think 'map map'
15:33:56 <hpc> > print [[1..5],[2..5],[3..5]]
15:33:57 <lambdabot>   <IO ()>
15:34:00 <Adamant> and it's usually done by programmers
15:34:07 <hpc> > show [[1..5],[2..5],[3..5]]
15:34:07 <shachaf> > mapM_ print [1..5],[2..6],[3..7]]
15:34:08 <lambdabot>   "[[1,2,3,4,5],[2,3,4,5],[3,4,5]]"
15:34:08 <lambdabot>   <no location info>: parse error on input `,'
15:34:10 <pozic> Adamant: it's an optimization that is not even applicable in this case.
15:34:16 <shachaf> > mapM_ print [[1..5],[2..6],[3..7]]
15:34:16 <lambdabot>   <IO ()>
15:34:29 <pozic> Adamant: unless you are going to say that custom memory management is going to be faster.
15:34:34 <Adamant> ok, I don't know what you want to do with the tree, so that could very well be the case
15:34:48 <pozic> Adamant: at which point Haskell completely is the wrong tool.
15:34:53 <drhodes> savage: turn [Int] into a string ending in '\n', then print the concat of [String].
15:35:20 <pozic> Really, just like Python is fundamentally slow, so is Haskell in its idiomatic presentation.
15:35:27 <Adamant> pozic: encoding complex structures as flat arrays is a pretty common trick
15:35:30 <ezyang> pozic: I believe your statement in this particular argument is that persistent updates of record objects is slow, and that large systems will use updates for record objects frequently enough that this will cause performance problems. 
15:35:31 <Axman6> putStrLn . unlines . map show
15:35:38 <Axman6> or just mapM_ print
15:35:40 <pozic> Adamant: except how are you going to resize?
15:35:49 <Adamant> pozic: ah, then you have a point
15:35:56 <pozic> Adamant: yes, you are going to resize in O(n) time. 
15:36:05 <pozic> Adamant: which is outside of what is required.
15:36:09 <hpc> but you can't resize faster!
15:36:12 <pozic> Or sqrt n in some smart implementation.
15:36:20 <hpc> or that
15:36:44 <pozic> Anyway, I don't think anyone has said anything to refute my statement.
15:36:48 <savage> thanks guys
15:36:50 <pozic> I don't think Clean has this problem, btw.
15:36:52 <hpc> obviously we need some kind of data structure...
15:37:09 <hpc> to assist us in all this resizing :P
15:37:36 <ddarius> pozic: It depends.  It does if you actually need persistence.  If you don't, you still have to make that clear to Clean, which may be just as onerous as coding monadically.
15:38:15 <pozic> ddarius: if you need persistence you simply need to do nothing in Clean, right?
15:38:24 <pozic> ddarius: and if you don't, you just give one type annotation.
15:38:49 <ddarius> pozic: "One type annotation" which may require global changes to your code to make your code type correct.
15:38:49 <pozic> ddarius: or perhaps I am presenting Clean a bit too positive.
15:39:00 <joe6> monochrom, it seems to be running well. Thanks a lot for your help..
15:39:01 <pozic> ddarius: ok, if that is the case, then Clean is also broken.
15:39:38 <pozic> I think most programs do not need persistent data structures.
15:39:54 <ezyang> pozic: I object! :-) 
15:40:17 <ddarius> pozic: You'd still have to convince Clean that you aren't using the data structure in a persistent way.
15:40:30 <ddarius> One alternative, though, is to use a DiffArray-like structure.
15:40:40 <pozic> ddarius: except DiffArrays are slow.
15:41:10 <pozic> ddarius: but a compiler should be able to recognize you use them in a linear fashion and make them fast.
15:41:16 <ddarius> pozic: Mostly due to a crappy implementation, and they are asymptotically optimal if you do use the array in a single-threaded way.
15:41:32 <pozic> ddarius: at least, that would be the proper way to implement mutable arrays in Haskell.
15:41:50 <ddarius> pozic: No it wouldn't, as that would be massively fragile.
15:42:03 <pozic> ddarius: what would be fragile about it?
15:43:06 <ddarius> pozic: You would be relying on an optimization that is quite easy to lose and hard to control, unless you adopt something like Clean's uniqueness types, in which case you are back where you started.
15:45:18 <hpc> @src foldr
15:45:18 <lambdabot> foldr f z []     = z
15:45:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:45:23 <pozic> ddarius: uhm, the compiler could easily say 'hi user, you said you wanted a linear array, but you lied!'.
15:45:42 <ddarius> Yes, that would be uniqueness types.
15:46:26 <pozic> ddarius: but no annotations would be required other than in one place.
15:46:42 <pozic> ddarius: it would be compatible with the IArray interface.
15:46:56 <pozic> For arrays, that would solve the problem. 
15:47:14 <pozic> I think you can do a similar thing for general data structures.
15:47:29 <pozic> (such that the functional version can compile to an STRef version)
15:47:41 <ddarius> pozic: That's not true, look at actual Clean programs.  And again, the compiler may fail to see that you use the array linearly and convincing the compiler that you do may require non-local changes.
15:48:07 <ddarius> Simply take a Clean program, strip out the uniqueness types, and then look at what uniqueness types the compiler infers.
15:50:02 <pozic> ddarius: for which program is it not decidable?
15:54:30 <ddarius> let a1 = makeArray ... in if halts p then use a1 linearly else use a1 non-linearly.  More realistically, you may have invariants that are non-obvious.  For example, you may store the arrays in a dictionary, but still only use them linearly.
15:55:48 <ddarius> Now the case may be something like f x y is uses the arrays linearly only if x /= y, which is, of course, undecidable in general.
15:56:08 <ezyang> Mmm, aliasing. 
15:56:49 <ddarius> At any rate, if accurate uniqueness inference were possible and feasible, every language would be doing it.
15:56:49 * hackagebot semigroups 0.3.4.2 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.3.4.2 (EdwardKmett)
16:06:08 <monochrom> well, roconnor makes it to lambda-the-ultimate headlines :)
16:07:01 <roconnor> :O
16:07:19 <Twey> Hm
16:07:29 <roconnor> oh, my supervisor posted it
16:07:32 <Twey> Is every Functor also Applicative?
16:07:36 <hpc> Twey: no
16:07:46 <roconnor> every Applicative is also Functor
16:07:50 <monochrom> oh hahaha
16:07:59 <hpc> i can't think of a functor that has no applicative instance off-hand
16:08:11 <roconnor> oh, Jacques admits it in his post
16:08:16 <hpc> but you can't construct (<*>) from fmap
16:08:18 <mm_freak> ok, so i've implemented almost the whole range of RFCs in haskell…  which ones are missing?
16:08:20 <Twey> So is it correct to say that it generalises it?  I thought ‘A generalises B’ means that the instance for B can be derived from the instance for A
16:08:44 <roconnor> hpc: the store comonad isn't applicative
16:08:51 <hpc> roconnor: cool
16:08:52 <roconnor> there are probably simpler examples
16:09:08 <hpc> Twey: "A generalizes B" == "all B are also A"
16:09:19 <hpc> so functor generalizes applicative
16:09:43 * roconnor is now worried he used generalizes wrongly in his paper
16:09:57 <ddarius> There are two ways "more general" is used that leading to antagonistic definitions.
16:10:18 <hpc> or something
16:10:23 <ddarius> These two ways correspond to negative and positive instances, or provide v. consume.
16:11:07 <monochrom> mm_freak: I wonder if you have implemented the pigeon RFC in haskell
16:11:11 <Twey> « applicative functor generalizes functor. » — abstract from roconnor's paper
16:11:51 <hpc> :t fmap
16:11:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:11:53 <hpc> :t applicative
16:11:54 <lambdabot> Not in scope: `applicative'
16:11:56 <hpc> er
16:11:59 <hpc> :t (<*>)
16:12:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:12:09 <hpc> :t (<*>) . pure
16:12:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (a -> b) -> f a -> f b
16:14:04 <Twey> Oh, right
16:14:38 <mm_freak> monochrom: what's that?
16:15:46 <monochrom> an April 1st RFC that lays out how to use pigeons to send packets.
16:16:29 <mm_freak> ah yes, i know that one
16:16:41 <mm_freak> well, i think there is no pigeon interface in haskell
16:16:43 <Mathnerd314> mm_freak: are these implementations online?
16:16:56 <Saizan> make one.
16:16:57 <mm_freak> Mathnerd314: some of them, yes (the ones, which i consider ready for production)
16:17:18 <mm_freak> Mathnerd314: mainly ismtp and ihttp, which i use productively
16:17:41 <mm_freak> i'll upload a new ihttp version in a few minutes
16:17:59 <Mathnerd314> mm_freak: have you done rfc 1495?
16:18:07 <mm_freak> yes
16:18:09 <mm_freak> no
16:18:11 <mm_freak> 1945
16:18:27 <Mathnerd314> * 1459
16:19:01 <Mathnerd314> weird that those are anagrams
16:20:01 <mm_freak> yes, in the fastirc library, but if you plan to use it, say that you don't want newer versions, because the next version will have a completely different, incompatible interface
16:27:37 <mm_freak> fastirc reflects my beginnings with fast, secure data processing in haskell =)
16:28:00 <mm_freak> but a few months later i fell in love with the iteratee concept
16:28:22 <rpglover64> I seem to be having issues running a computation for a maximum amount of time (iterative deepening search)
16:28:25 <rpglover64> http://hpaste.org/44831/timeout_issues
16:29:26 <hpc> rpglover64: "x <- somethingFromOtherThread" is probably a blocking operation
16:29:41 <hpc> try killing the thread first
16:29:54 <hpc> or conditionally killing, if that also doesn't work
16:29:59 <mm_freak> rpglover64: what about System.Timeout?
16:30:01 <hpc> i think there's a way to see if a thread is done
16:30:04 <hpc> or that
16:30:23 <mm_freak> i hate it, but it's fine for semi-pure code
16:30:33 <rpglover64> mm_freak: system.timeout doesn't quite do what I want
16:30:48 <rpglover64> hpc: that seems to work (on one test)
16:30:49 <rpglover64> thanks
16:31:23 <hpc> (btw, i totally pulled that answer out of my ass; i hate multithreading)
16:31:40 <mm_freak> rpglover64: STM would make your life easier
16:31:53 <hpc> a sufficiently educated guess is indistinguishable from an answer :P
16:32:16 <ddarius> hpc: A correct guess is indistinguishable from an answer.
16:32:17 <kmc> i don't see why System.Timeout is better for pure code
16:32:19 <mm_freak> rpglover64: http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/Control-Concurrent-STM-TVar.html#v:registerDelay
16:32:23 <kmc> it seems more suitable for IO
16:32:30 <hpc> ddarius: ^^
16:32:43 <rpglover64> hpc: the second test failed :(
16:32:58 <mm_freak> kmc: because System.Timeout kills the thread /somewhere/
16:33:05 <ddarius> hpc: ^^
16:33:11 <mm_freak> kmc: so if your thread manages resources, that's bad
16:33:54 <shachaf> shachaf: vv
16:33:55 <kmc> if you have IO code managing resources then it should be exception-safe anyway
16:34:30 <mm_freak> kmc: it still gets killed /somewhere/
16:35:11 <mm_freak> i prefer controlled timeouts
16:35:27 <kmc> how would you do a controlled timeout?
16:36:45 <mm_freak> kmc: one example: http://hackage.haskell.org/packages/archive/netlines/0.4.0/doc/html/Data-Enumerator-NetLines.html#v:enumHandleSession
16:38:01 <mm_freak> because of the design of iteratees this even gets along without multiple threads
16:56:18 <roconnor> what is the currency code for pounds?
16:56:34 <djahandarie> conal, I really want to add a TypeCompose dependency to my package now. :) I think it may be overkill due to how small the package is though
16:56:41 <Zao> roconnor: GBP?
16:56:47 <roconnor> thanks
16:57:09 <roconnor> BTW, british coins are terrible
16:57:32 <Zao> roconnor: Took me five minutes to pay for a hot dog the last time I was in the UK.
17:00:18 <roconnor> I have 5 pounds to survive on in Britian. :D
17:00:59 <astory> I've got a function I think I'm memoizing using Data.Memocombinator, but it's repeating method calls.  Is there anything I can do to debug?
17:01:11 <ryant5000> shachaf, jfischoff: ping
17:01:17 <jfischoff> yo
17:01:30 <ddarius> roconnor: Things are probably cheaper in Britian as compared to Britain.
17:01:52 <ryant5000> i just saw your messages from earlier today
17:02:21 <copumpkin> roconnor: why so little money?
17:02:22 <jfischoff> cool, any additional info?
17:02:37 <roconnor> copumpkin: left over from previous trips
17:02:41 <copumpkin> oh
17:02:48 <roconnor> copumpkin: I hope it is enough to make it to an ATM :D
17:02:52 <Igloo> Do you dislike British coins for any reason other than unfamiliarity?
17:02:59 <roconnor> Igloo: their weight
17:03:01 <copumpkin> I love how big they are
17:03:04 <copumpkin> mmm
17:03:08 <copumpkin> well, the big ones, anyway
17:03:09 <ryant5000> jfischoff: well, we're using our ghc-iphone project as it currently stands for our game
17:03:17 <Igloo> roconnor: Too heavy, or too light?
17:03:21 <roconnor> too heavy
17:03:23 * ddarius hates currency in Japan.
17:03:28 <ryant5000> jfischoff: but we'll be working on getting it up to ghc's HEAD once we release
17:03:29 <Igloo> Fair enough
17:03:43 <Igloo> Good thing you weren't here 20 years ago then  :-)
17:03:44 <jfischoff> ryant5000: how long would it take for me to get a dev setup going?
17:03:52 * roconnor wonders if the coins actually weigh 5 pounds
17:04:18 <ryant5000> jfischoff: a couple hours, i would think, assuming you've already got a working Xcode setup
17:04:19 <jfischoff> ryant500: I have made iOS apps and hacked the ghc a little if that helps with the esimate
17:04:41 <jfischoff> ryant500: nice!
17:05:02 <jfischoff> ryant5000: whoops I keep missing a 0
17:05:11 <ryant5000> np :)
17:05:21 <ddarius> roconnor: Just bring it back to Canada and melt it down and sell the metal.
17:05:29 <roconnor> ooh
17:05:33 <ryant5000> jfischoff: http://projects.haskell.org/ghc-iphone/downloads/GHC-iPhone.pdf
17:05:47 <ryant5000> that document has the instructions for setting it up
17:06:09 <jfischoff> ryant5000: sweet
17:06:46 <ryant5000> jfischoff: let me know if you run into any trouble
17:07:06 <jfischoff> ryant5000: You got it :)
17:07:58 <conal> djahandarie: yeah. TypeCompose could be decomposed. it accumulated miscellany over time.
17:08:28 * ddarius reads reviews of the worst rated movies on imdb.
17:08:46 <dabloosh> FUCK
17:08:50 <dabloosh> WRONG CHANNEL
17:08:52 <dabloosh> GOD DAMN IT
17:08:55 <djahandarie> conal, the category-extras curse...
17:09:04 <copumpkin> dabloosh: calm down
17:09:09 <copumpkin> just type /j #therightchannel
17:11:54 <ddarius> copumpkin: No one is in the right channel.
17:13:34 <augur> copumpkin!
17:13:38 <copumpkin> augur!
17:13:53 <augur> tylenol has fixed my fever headache
17:14:29 <copumpkin> preflex: seen tibbe
17:14:29 <preflex>  tibbe was last seen on #ghc 6 days, 9 hours, 32 minutes and 33 seconds ago, saying: dcoutts, will only have minimal email access
17:14:49 <djahandarie> Who was recommending that Category Theory for Computing Sciences book the other day? I finally got a copy
17:14:55 <djahandarie> I like it so far
17:15:01 * djahandarie thinks it was roconnor 
17:15:35 <roconnor> yeah
17:15:40 <xpika> @pl id . id
17:15:40 <lambdabot> id
17:15:50 <djahandarie> roconnor, thanks :)
17:15:53 * roconnor should buy his own copy
17:16:05 <djahandarie> I didn't buy it, got it from some other library via interlibrary loan
17:16:15 <djahandarie> I have the urge to mark it already though...
17:16:23 <djahandarie> It'd be nice if books just came pre-highlighted
17:17:37 <xpika> @pl  (\f -> (f***f))
17:17:37 <lambdabot> join (***)
17:17:58 <ddarius> My copy of MacLane has some notes and crap in the first chapter.
17:18:33 <Mathnerd314> everyone should switch to digital... much easier to transfer highlighting / notes
17:19:37 <ddarius> My digital interface isn't digital though.
17:20:25 <ddarius> "Topology isnt really separate from commutative algebra. Indeed, in the mid-1800s, Dedekind, Kummer and Riemann realized that commutative algebra is a lot like topology, only backwards."
17:20:35 <xpika> @pl  (\f (x,y)-> f x y)
17:20:35 <lambdabot> (`ap` snd) . (. fst)
17:21:49 <Mathnerd314> ddarius: are you on drugs?
17:25:12 <nathy> haskell is fun
17:30:08 <Augusto> hi friend
17:30:16 <Augusto> i need help
17:30:31 * copumpkin looks knowingly at Igloo and dons
17:30:35 <astory> Awesome, I got my memoization problem fixed; I wasn't recursing on the memoized version; instead I was recursing on the normal, exponential-time version
17:30:49 <copumpkin> (http://snapplr.com/k8j6 too)
17:30:54 <copumpkin> Augusto: what's up?
17:31:21 <JuanDaugherty> Mathnerd314, you mean was the person ddarius quoted, don't you?
17:32:12 <JuanDaugherty> (discounting the possibility that ddarius would quote ihrself)
17:33:35 <Mathnerd314> JuanDaugherty: a quick google says it's pretty unlikely that he quoted someone...
17:34:16 <JuanDaugherty> lol, google supercedes the text above?
17:34:49 <JuanDaugherty> those double ticks at the begin and end are what I mean by "quote"
17:36:10 <copumpkin> Mathnerd314: he has been known to read books, occasionally
17:36:10 <copumpkin> ddarius, that is
17:36:16 <Mathnerd314> JuanDaugherty: oh, that is indeed a quote. I was thinking of "My digital interface isn't digital though."
17:37:20 <dons> copumpkin: ?
17:37:33 <copumpkin> dons: a couple of random joiners already :)
17:37:42 <dons> heh
17:38:04 <djahandarie> Is there a reason for people to start joining? :)
17:38:24 <dons> copumpkin: http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode 
17:38:33 <dons> "Brand New!"
17:38:44 <Augusto> sorry copumpkin
17:38:44 <copumpkin> omg shiny!
17:39:12 <nathy> cooool
17:39:27 <copumpkin> Augusto: oh nothing to be sorry for! can we help you with haskell?
17:39:29 <djahandarie> Ah, we finally got +s off the channel, nice
17:39:34 <copumpkin> djahandarie: :(
17:40:19 <Mathnerd314> who wouldn't join #haskell ?
17:40:41 <Augusto> Let me explain my case. I need to create a function that checks if all the numbers are a sequence repeat. As I am beginner in this language, I can not do anything!
17:40:48 <geheimdienst> :t join
17:40:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:41:03 <geheimdienst> Mathnerd314: ^^
17:41:22 <Mathnerd314> geheimdienst: lambdabot has already joined #haskell
17:41:34 <astory> Augusto: what do you mean by a sequence repeat?
17:41:43 <astory> also, what tutorials have you worked though, if any?
17:42:56 <JuanDaugherty> Mathnerd314, ddarius was likely referring to Category theory for working mathematicians which is in fact only available in paper
17:43:04 <Augusto> The program receives a numerical sequence checks for repeat numbers.
17:43:33 <astory> do you know if repeats will be consecutive?
17:44:14 <rpglover64> Still having issues with getting the computation to stop after a set time.
17:44:22 <Augusto> not, random.
17:44:24 <rpglover64> http://hpaste.org/paste/44831/timeout_issues_try_2#p44834
17:44:41 <astory> Augusto: ok, so without worrying about language details, what algorithm are you trying to use?
17:44:47 <astory> how are you planning to solve this problem?
17:45:38 <nathy> tail recursion
17:45:51 <Augusto> No, because I really know nothing of the language.
17:46:05 <astory> Augusto: can you solve this in another language, or, better, in pseudo-code?
17:46:09 <Mathnerd314> > let check = nub >>= (==) in check [1,2,3,4]
17:46:10 <lambdabot>   True
17:46:12 <Mathnerd314> > let check = nub >>= (==) in check [1,2,3,3]
17:46:13 <lambdabot>   False
17:46:27 <BMeph> Augusto: Do you know what the cycle length is? (Just curious, trying to match a multitude of answers, to your problem.)
17:46:44 <astory> also, if you really know nothing, maybe you should work through a tutorial.  There's a thorough (but long!) one at learnyouahaskell.com
17:48:12 <BMeph> Augusto: Never mind, I noticed that I needed to page down, and found further replies you made. Carry on, Mathnerd314 seems to have your problem well in hand. ;)
17:48:42 <astory> BMeph: ?
17:48:53 <astory> oh, I see
17:48:54 <BMeph> astory: ??
17:48:59 <astory> just me being dumb
17:49:52 <djahandarie> > all (<=1) . map length . group . sort $ [3,2,4,3]
17:49:53 <lambdabot>   False
17:49:54 <astory> what is >>=?
17:50:08 <djahandarie> astory, it's from the Monad typeclass.
17:50:18 <astory> ah, I haven't gotten to monads yet
17:50:18 <BMeph> astory: Oh, good. Not your being dumb, I'm just glad that I'm not the only one. ;)
17:51:07 <Augusto> It may be a limited amount of numbers, I think with 15 numbers is a good size.
17:51:19 <BMeph> > all null . map tail . group . sort $ [3,2,4,3]
17:51:21 <lambdabot>   False
17:51:39 <astory> is this just spotting non-unique numbers in a list, or is it more complex than that?
17:51:46 <djahandarie> This is indeed better, but perhaps slightly harder to understand ;)
17:52:20 <fryguybob> @src (->) (>>=)
17:52:20 <lambdabot> f >>= k = \ r -> k (f r) r
17:52:23 * BMeph religiously follows: "Never use 'length' if you don't really want the number."
17:52:43 <nathy> arrows
17:52:46 <astory> BMeph: I was about to use length in some code and now I'm reconsidering...
17:53:22 <astory> but no, I really need the number
17:53:51 <BMeph> astory: Eh, it's my religion; if you want to join me, I invite you. I'm kind of a "quiet" evangelist. ;)
17:55:00 <astory> I'm still a total newb to haskell, so I'm taking some time to figure things out before joining any cults
17:55:07 <astory> well, except the cult of vi /ducks
17:55:28 <BMeph> astory: Too late! Learning Haskell is in itself, joining a cult. ;p
17:56:21 <astory> I don't know, I'm mostly doing it to troll the TAs for this class I'm taking
17:56:29 <Augusto> Friends I am using WinGHCi.
17:56:34 <astory> they said "any programming language"...
17:56:57 <Mathnerd314> @type (,True)
17:56:57 <lambdabot> Illegal tuple section: use -XTupleSections
17:57:13 <Mathnerd314> :-(
17:57:57 <djahandarie> astory, my data structures class was in Java, but I managed to write most of the data structures in a purely functional way, with most of the immutability guarentees enforced
17:58:09 <djahandarie> I feel bad for my TA
17:58:14 <djahandarie> I was just doing it to have fun :)
17:58:44 <astory> djahandarie: my school does data structures part one in java, and I didn't know any functional programming so I just did it, but data structures part 2 is in ocaml, and it vastly improved the stability of my code after that
17:59:16 <astory> with the odd side effect that I couldn't write imperatively for about 2 months after ending that class; I nearly bombed an interview because I almost didn't realize I could use a for loop to solve a problem...
17:59:57 <djahandarie> OCaml doesn't make you bend like Haskell does
18:00:04 <astory> bend?
18:00:06 <djahandarie> Only bend a little :)
18:00:17 <djahandarie> Yes, bend from whatever usual stuff you are used to
18:00:31 <astory> well, the prof said "no references until I say so," so it was pretty bending
18:02:10 <astory> although now that I've learned both, I must say that I enjoy haskell more.  Particularly type classes
18:02:52 <djahandarie> :-) You still have plenty more in Haskell to enjoy
18:03:04 <astory> well, of course
18:03:10 <ian_mi> I never understood what's so mind bending about haskell. Some of the category theory maybe but not haskell itself.
18:03:35 <djahandarie> ian_mi, have you tried implementing any purely functional data structure without an Okasaki paper in hand? ;)
18:03:40 <astory> ian_mi: if you've only learned imperative, state-changing programming, it can be pretty hard to adapt to functional data structures
18:04:10 <kmc> ian_mi, to many, the idea of a programming language that doesn't utterly suck is mind-bending
18:04:20 <astory> heh
18:04:26 <ian_mi> haha
18:04:43 <kmc> Haskell has a few big ideas but also gets a lot of little stuff right
18:04:58 * BMeph looks for a director to help him make "Haskatar: The Lasy Mindbender"
18:05:33 <bss03> Is there a GADT or Type Family way to easily express the idea of fixed-size lists?  There's some crazy IPC magic I'd like to lift from C to Haskell.
18:05:37 * BMeph meant to type "Last", but "Lazy" would work there as well...
18:05:52 <bss03> Along the way I'd like the type checkers to handle finding pointer errors.
18:06:02 <astory> bss03: tuples might do something similar
18:06:09 <ian_mi> bss03: yes, although it's horrible
18:06:09 <BMeph> bss03: Look up Data.Vector ;)
18:06:25 <Mathnerd314> bss03: HList (perhaps?)
18:06:33 <ian_mi> that's one thing haskell doesn't do right, dependant types
18:06:38 <bss03> Tuples are out.
18:06:39 <jmcarthur> data Vec n a where Nil :: Vector Zero a; Cons :: a -> Vector n a -> Vector (Succ n) a
18:06:47 <bss03> Some of these arrays are 80 elements.
18:06:55 <astory> ian_mi: there's a point at which your typechecker becomes undecideable, though
18:07:02 <jmcarthur> s/Vec /Vector /
18:07:12 <Mathnerd314> astory: so? :p
18:07:19 <astory> Mathnerd314: that's bad!
18:07:36 <kmc> Agda typechecking is not undecidable
18:07:39 <ian_mi> well haskell's not at that level
18:07:40 <Mathnerd314> astory: only if you're dumb
18:07:50 <bss03> I don't think I need HList -- I thought that was for Rank 1 lists.  Like [forall a. a]?
18:07:51 <jmcarthur> kmc: it is if you use a nonterminating function at the type level
18:08:01 <kmc> jmcarthur, but there are static checks for termination
18:08:07 <Mathnerd314> astory: and then you wouldn't be worried in the first place
18:08:15 <astory> :(
18:08:17 <kmc> [forall a. a] is a quite useless type
18:08:35 <kmc> "HList is a record system providing strongly typed heterogenous lists, records, type-indexed products (TIP) and co-products; licensed under the MIT X License."
18:08:59 <bss03> kmc: Well, it was just an example to stand in for something moderatly useful like [Show a => a].
18:09:14 <kmc> but [forall a. (Show a) => a] is also a very useless type
18:09:15 <jmcarthur> kmc: yes, but you are not required to write terminating code
18:09:28 <kmc> do you mean [exists a. (Show a) => a]?
18:09:49 <bss03> kmc: It's pretty good for output, right?
18:09:57 <jmcarthur> kmc: the static check only gives you a warning, is what i mean
18:10:03 <kmc> hmm bss03?
18:10:20 <jmcarthur> bss03: the Vector GADT i gave gives you static-length lists
18:10:21 <kmc> jmcarthur, ok
18:10:52 <bss03> kmc: Like, you can (mapM_ print) over a [Show a => a], right?
18:11:20 <kmc> yes, but uselessly
18:11:21 <bss03> jmcarthur: Yeah, I think Data.Vector may be what I want.  I hope it has a Storable instance.
18:11:48 <kmc> bss03, each individual value in that list is polymorphic over all Showable types
18:12:04 <bss03> > (mapM_ print) ([1, "2", '3', 4.0] :: [Show a => a])
18:12:04 <lambdabot>   Overlapping instances for GHC.Show.Show ((GHC.Show.Show a) => a)
18:12:04 <lambdabot>    arising...
18:12:11 <geheimdienst> > [42, "lolcats"]
18:12:12 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
18:12:12 <lambdabot>    arising from the literal ...
18:12:24 <kmc> bss03, the only value which is in both Int and Char is ⊥
18:12:36 <kmc> Int and Char are both instance of Show
18:12:43 <kmc> any value in your list has to be in all Showable types
18:12:46 <kmc> therefore all values in your list are ⊥
18:13:19 <bss03> Ah, hrm.  Okay, yeah, I mean exists, then.
18:13:33 <bss03> I'm not yet comfortable with Rank 2 (or greater) types.
18:13:50 <kmc> yeah, it's more common to want containers of existentials
18:14:21 <bss03> > [1, "2", '3', 4.0] :: [exists Show a. a]
18:14:22 <lambdabot>   <no location info>:
18:14:22 <lambdabot>      Illegal symbol '.' in type
18:14:22 <lambdabot>      Perhaps you intend...
18:14:35 <kmc> GHC doesn't support "exists" syntax; you have to declare a type
18:14:53 <kmc> (also that particular existential is kind of silly because, why not just use [String])
18:15:34 <copumpkin> if we get exists syntax, we should restrict it to GADTs and phantom types
18:15:46 <copumpkin> to stop people from misusing it :P
18:16:51 <kmc> bss03, there is a relationship between existentials and higher-rank functions, via a continuation-passing style transform
18:18:25 <kmc> newtype Exists f = Exists (∀ r. (∀ a. f a → r) → r)
18:18:42 <bss03> So, instead of producing a [exists Show a. a], you instead call show :: Show a => a -> String and produce the [String]?
18:19:13 <kmc> yeah, if you're making a list of showable things, why not just Show them first
18:19:33 <kmc> it's not like you can do anything *else* with a value of type «∃a. (Show a) ⇒ a»
18:19:38 <bss03> Well, I mean you can sortof generalize that to any typeclass insetad of Show?
18:19:50 <kmc> yes, there are other type classes where it makes more sense
18:20:04 <kmc> also you can use existentials without typeclasses
18:20:27 <kmc> ∃a. (a, a → a → a, a → String)
18:21:15 <bss03> exists (Show a, Monoid a). a?
18:21:22 <kmc> more or less
18:21:41 <kmc> (dym «exists a. (Show a, Monoid a) => a» ?)
18:22:08 <bss03> yep.
18:22:23 <bss03> Sorry, never had to use the syntax yet.
18:23:52 <kmc> a value of type «∃x. T» is a pair of a type S and a value v
18:24:10 <kmc> such that «v :: T» if the type variable x = S
18:29:38 <kmc> much as a proof of the proposition «∃x. T» is a "witness" value x together with a proof that T holds for that x
18:32:21 <djahandarie> It feels like things are getting too dependent in here...
18:38:43 <co_dh> what are Hask-enriched categories ? in http://hackage.haskell.org/package/data-category ? is that every homset a Hask category? 
18:41:32 <kmc> hommmmmmmm
18:47:03 <dolio> For any category C, a C-enriched category has hom-objects in C.
18:47:24 <dolio> Normal categories are Set-enriched.
18:48:26 <co_dh> does that mean the arrows from object A to B forms a Hask cateogry in Hask-enriched category? 
18:49:20 <dolio> It means that if A and B are objects in a Hask-enriched category, then Hom(A,B) is a Haskell type.
18:49:34 <accel> this is a bit hard to search for on hackage.haskell.org -- is there a decent DSL for outputting C code in haskell?
18:50:10 <djahandarie> language-c might be what you're looking for
18:50:32 <djahandarie> There are Haskell C EDSLs that are tuned to specific purposes like atom
18:50:33 <accel> djahandarie: will look into it; thanks
18:52:37 <co_dh> dolio:  let A = Int, B = Bool, so Hom(A,B) is Int -> Bool ? 
18:52:42 <astory> what does it mean when I get an error like Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for `numerator'
18:52:45 <astory> ?
18:52:55 <dolio> co_dh: What category are we talking about?
18:53:40 <joe6> monochrom, just wanted to let you know that my ghc installation has been rock solid, since your advice on cleaning it up...
18:53:56 <parcs> astory: that is a type error. you are composing things wrong
18:54:01 <co_dh> dolio: the category (->) 
18:54:07 <dolio> Then yes.
18:54:29 <astory> parcs: I'm having trouble tracking it down, any idea?
18:54:42 <BMeph> astory: It means... UR DOIN IT RONG! ;p
18:54:47 <astory> :(
18:54:51 <djahandarie> astory, it means you need to paste the code ;)
18:55:28 <astory> https://gist.github.com/873753
18:55:31 <BMeph> astory: Yes, paste the code. Then, monochrom will tell you what's wrong before half of us have even looked at it... ;þ
18:56:45 <parcs> astory: prefix ++ x is a type error
18:56:54 <parcs> it should be prefix ++ [x]
18:56:57 <joe6> what is the difference between llvm vs llvm-ht?
18:56:58 <astory> ah, there we are
18:57:10 <astory> thanks!
18:57:15 <astory> I know this is a bit ugly :(
18:57:42 <parcs> you probably should substitute the let .. in clause for a where clause
18:57:58 <astory> I don't really understand where clauses
18:58:41 <kmc> astory, attaches to a function equation, takes bindings similar to "let"
18:58:44 <parcs> astory: where clauses are simply let clauses with a more general scope
18:59:08 <enthymeme> astory: they're not like where clauses in SQL
18:59:20 <astory> enthymeme: no worries, I don't know SQL
18:59:21 <enthymeme> not that I've ever seen that trip someone up
18:59:23 <kmc> more general and more specific
18:59:30 <kmc> "let x = y in z" is an expression, so it can be used in many contexts
18:59:42 <parcs> good point
18:59:46 <kmc> "where" is part of the syntax of declarations
19:01:00 <astory> ok, it's changed to use a where, does that seem more sensible?
19:01:05 <astory> or did I do it wrong again
19:04:06 <sohum> :t (!!)
19:04:09 <lambdabot> forall a. [a] -> Int -> a
19:04:56 <parcs> astory: you're computing `length prefix` twice. you should probably bind that value to a name
19:05:13 <astory> parcs: I agree, although it's going to be < 10
19:05:50 <parcs> astory: okay, as long as you know :)
19:06:02 <parcs> take a look at this function:
19:06:04 <parcs> :t fromMaybe
19:06:05 <lambdabot> forall a. a -> Maybe a -> a
19:06:21 <parcs> you can replace the case expression with that
19:06:40 <astory> is that in prelude?
19:07:02 <parcs> nope. it's in base,  however
19:07:09 <astory> so I don't need to import anything?
19:07:24 <parcs> you do -- Data.Maybe
19:09:56 <astory> thanks!
19:12:34 <monochrom> but monochrom doesn't work so quickly when afk :)
19:12:47 <djahandarie> There is an easy solution to that.
19:22:27 <djahandarie> roconnor, just saw your paper. Good work. :)
19:22:47 <roconnor> thanks
19:42:11 <accel> is there a way in haskell to emulate RAII with monads?
19:42:28 <copumpkin> accel: wat
19:42:45 <accel> C++ style Resource Acquisation is Initialization; destructos
19:42:50 <copumpkin> I know what it means
19:43:03 <copumpkin> the closest thing I can think of is the monadic regions paper
19:43:03 <accel> wait; I have something for you
19:43:22 <Jafet> To some extent.
19:43:22 <accel> http://www.spellcheck.net/speller/ <-- might help with your typos :-)
19:43:32 <accel> i'm thinking in a monad
19:43:34 <copumpkin> I make typos?
19:43:39 <accel> during execution, things get "pushed" into the monad
19:43:49 <accel> and at the end, there's a "fire all destructors at enenmies" command
19:43:53 <accel> and BAM, all the destructors go off
19:43:57 <copumpkin> monadic regions sounds good
19:44:08 <bss03> Doesn't bracket sort of do RAII?
19:44:09 <accel> reading up http://okmij.org/ftp/Haskell/regions.html
19:44:11 <Jafet> But it's ugly in practice.
19:44:18 <copumpkin> yeah
19:44:30 <bss03> @hoogle bracket
19:44:30 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:44:30 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:44:30 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:46:09 <bss03> If you want your "destructors" to fire on an exception being thrown, you probably need to be in the IO Monad anyway.  Otherwise, bracket is trivially generalized to any Monad.
19:46:44 <bss03> @type let bracket c u d = c >>= u >> d in bracket
19:46:45 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m a -> (a -> m a1) -> m b -> m b
19:47:20 <bss03> @type let bracket c u d = do { r <- c; u r >> d r; } in bracket
19:47:21 <lambdabot> forall (m :: * -> *) t a b. (Monad m) => m t -> (t -> m a) -> (t -> m b) -> m b
19:47:22 <kmc> it's funny how the question is never "can i do foo in Haskell" but always "is there a monad for foo"
19:47:36 <copumpkin> is there a monad for finding monads to do things in haskell?
19:47:38 <djahandarie> Is there a monad for asking good questions?
19:47:39 <djahandarie> Damn
19:47:40 <djahandarie> Foiled
19:47:48 <copumpkin> yours was better
19:51:52 <Jafet> No *->* questions here
19:53:13 <djahandarie> You mean * -> * -> Fact ;) http://hackage.haskell.org/trac/ghc/wiki/KindFact
19:53:32 <copumpkin> (* -> *) -> Fact
19:54:09 <djahandarie> Oops, yeah
19:54:10 <magicman> @faq Can I do foo in Haskell?
19:54:10 <lambdabot> The answer is: Yes! Haskell can do that.
19:54:55 <djahandarie> I feel kind of woozy about just dropping another kind in Haskell though.
19:55:07 <djahandarie> It doesn't feel like it will fit in the subtype hierarchy particularly well
19:55:17 <djahandarie> s/Haskell/GHC/ of course...
19:55:32 <copumpkin> kmc was about to jump in and rip your head off
19:55:41 <djahandarie> Yeah, had to catch myself there
19:55:45 <kmc> for sure
19:55:48 <Axman6> "< copumpkin> is there a monad for finding monads to do things in haskell?" Isn't this the IRC monad? =)
19:55:55 <kmc> i like the name Prop better than Fact fwiw
19:56:07 <copumpkin> Prop has connotations from other languages though 
19:56:09 <djahandarie> kmc, see "Bikeshed discussion of nomenclature" section
19:56:21 <kmc> also from the name of that article i was expecting a hack for computing factorials in the kind system
19:56:30 <djahandarie> LOL
19:56:36 <djahandarie> Oh dear christ
19:57:10 <djahandarie> But, yeah, I wonder if there is some way to tie this in with how byorgey has been changing the type/kind system
19:57:13 <Jafet> Who needs Fact when you can have Truth
19:57:23 <co_dh> How can I know which package is using another package, e.g. data-category? 
19:57:40 <djahandarie> co_dh, reverse dependencies. Some other hackage instances have it
19:57:49 <djahandarie> http://sparky.haskell.org:8080/ for example
19:57:50 * hackagebot cassandra-thrift 0.7.4 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.7.4 (KirkPeterson)
19:58:12 <djahandarie> byorgey, have you see conor's little proposition there?
19:58:25 <co_dh> djahandarie: thanks.
20:03:41 <Saizan> conor's little proposition?
20:04:58 <djahandarie> That made it sound like I was reffering to something specific huh. I mean this: http://hackage.haskell.org/trac/ghc/wiki/KindFact :P
20:07:27 <ddarius> Schönfield = Gödel ∘ Krivine
20:22:56 * hackagebot hscassandra 0.0.7 - cassandra database interface  http://hackage.haskell.org/package/hscassandra-0.0.7 (KirkPeterson)
20:34:51 <int80_h> hi everybody
20:53:40 <ryant5000> is there an established name for the function with type ((a, b), c) -> (a, (b, c)) ?
20:53:52 <ryant5000> (or its inverse)
20:54:25 <ryant5000> i find myself writing a typeclass that looks awfully similar to a braided monoid
20:54:41 <copumpkin> I'd call it assoc :P
20:54:46 <copumpkin> but then again, I suck at names
20:54:58 <ryant5000> well, i called it "lassoc" (and its inverse "rassoc")
20:55:03 <ryant5000> so we're on the same page, at least :P
20:55:53 <ryant5000> (er, the opposite: "rassoc" and "lassoc", respectively)
20:55:59 <copumpkin> in general, though, if I found myself using such a function, I'd probably figure out some way to not need it
20:56:08 <copumpkin> (unless it's part of a proof)
20:56:33 <geheimdienst> in which case you'd figure out a way to not need the proof ...?
20:56:38 <ryant5000> it's very similar to being part of a proof
20:56:54 <copumpkin> geheimdienst: nah, I'm fine with using such a thing in a proof
20:57:04 <geheimdienst> ;)
20:57:09 <copumpkin> maybe I just have lower standards for proofs :)
20:57:16 <ryant5000> haha
20:57:31 <ryant5000> well, i'm abstracting fst, snd, etc.
20:57:54 <copumpkin> aha
20:57:55 <ryant5000> it's not possible to do all the pair munging i need to do without a function like this
20:57:58 <ryant5000> and it has to be in a typeclass
20:58:05 <ryant5000> so it's going to have a pretty general  name
20:58:06 <copumpkin> have you seen the tuples package?
20:58:21 <copumpkin> http://hackage.haskell.org/package/tuple
20:58:28 <djahandarie> That doesn't have every permutation though
20:58:33 <copumpkin> lol
20:58:53 <djahandarie> Infinite tuple nesting tree, on the type-level!
20:58:59 <copumpkin> it does, however, have the forbidden 1-tuple in it!
20:59:21 <ryant5000> yes, unfortunately that won't do, since i'm abstracting over (->) as well :)
20:59:35 <djahandarie> Abstracting! Bah!
20:59:54 <ryant5000> djahandarie: you don't like me verbing that?
21:00:16 * copumpkin always verbs his nouns 
21:00:37 <geheimdienst> a process known as copumpkinning
21:00:39 <djahandarie> ryant5000, if I was I'd certainly be against 'verbing'. I was just pretending to be against the concept. :)
21:00:48 <ryant5000> haha
21:00:51 <ryant5000> that's cool :)
21:01:05 <copumpkin> ryant5000: you should start coming to bostonhaskell meetups again!
21:01:30 <ryant5000> copumpkin: for what it's worth, http://en.wikipedia.org/wiki/Braided_monoidal_category calls my "rassoc" "alpha"
21:01:43 <ryant5000> but i'm not going to do that, because that would be lame
21:01:50 <ryant5000> copumpkin: yes, i should
21:01:51 <ryant5000> i've been very busy
21:01:52 <copumpkin> you don't even need the braided part of monoidal
21:01:52 <djahandarie> You should start scheduling boston haskell meetupts before advertising them again
21:02:14 <copumpkin> I figured :)
21:02:23 <ryant5000> copumpkin: isn't rassoc + swap a braided monoidal category?
21:02:24 <copumpkin> djahandarie: bug edwardk :) I just want to get people together!
21:02:36 <copumpkin> ryant5000: swap would be (gives you symmetry too, apparently)
21:02:43 <copumpkin> but I didn't hear you mention that! :P
21:02:43 <djahandarie> Why exactly is edwardk in charge of this anyways? :P
21:02:55 <ryant5000> copumpkin: yeah, that's because i already had a name for it :)
21:02:56 <copumpkin> djahandarie: cause he's willing to pay for the snacks
21:03:02 <ryant5000> (not "gamma", incidentally)
21:03:06 <copumpkin> damn
21:03:12 <copumpkin> if it ain't greek, I ain't usin it
21:03:16 <ryant5000> haha
21:03:54 <copumpkin> djahandarie: although I hear that we may be getting corporate sponsorship of the meetup in the near future :P
21:04:08 <djahandarie> Hahaha, nice
21:04:33 <djahandarie> Let's hope we don't need to start doing strange things as a result of that...
21:04:47 <djahandarie> "Microsoft Haskell! Located in Boston."
21:04:50 <copumpkin> lol
21:21:10 * hackagebot GLFW-b 0.0.2.3 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.0.2.3 (BrianLewis)
21:29:55 <geheimdienst> suppose i have some functions :: Window -> X Bool. is my understanding correct that i cannot use liftA2 (&&) on two of them?
21:30:01 <geheimdienst> it would work if they were :: X Bool, but liftA2 (&&) doesn't know what to do with the additional Window parameter
21:30:06 <geheimdienst> right?
21:31:04 <kmc> :t liftM2 (liftM2 (&&))
21:31:04 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (m Bool) -> m1 (m Bool) -> m1 (m Bool)
21:31:40 <kmc> > liftM2 (liftM2 (*)) Just (Just . (+3)) 5
21:31:42 <lambdabot>   Just 40
21:31:54 <geheimdienst> interesting, thanks
21:32:10 <kmc> X is a monad and so is ((->) Window)
21:32:27 <kmc> this is not recommended unless you're trying to win an obfuscated haskell contest
21:32:46 <geheimdienst> heh
21:33:05 <geheimdienst> right now i'm still at the stage of winning an incompilable haskell contest
21:33:52 <copumpkin> you might also want to look at monad transformers
21:34:50 <geheimdienst> > liftM2 (&&) null null [1]
21:34:51 <lambdabot>   False
21:34:53 <geheimdienst> > liftM2 (&&) null null []
21:34:54 <lambdabot>   True
21:35:18 <geheimdienst> hm-hm
21:35:59 <geheimdienst> so liftM2 kinda distributes the [1] to each of the 'null' functions
21:36:13 <BMeph> > liftM2 (liftM2 (*)) (Just [3,6]) (Just[5])
21:36:14 <lambdabot>   Just [15,30]
21:36:43 <kmc> > liftM2 (liftM2 (*)) [[1],[3,6]] [[5],[2,3]]
21:36:44 <lambdabot>   [[5],[2,3],[15,30],[6,9,12,18]]
21:37:27 <kmc> > sequence [[1],[3,6]]
21:37:28 <lambdabot>   [[1,3],[1,6]]
21:37:33 <geheimdienst> i don't get that yet with two of them nested ...
21:37:35 <kmc> > sequence . sequence $ [[1],[3,6]]
21:37:36 <lambdabot>   [[1,1],[1,6],[3,1],[3,6]]
21:37:48 <kmc> > iterate sequence [[1],[3,6]]
21:37:49 <lambdabot>   [[[1],[3,6]],[[1,3],[1,6]],[[1,1],[1,6],[3,1],[3,6]],[[1,1,3,3],[1,1,3,6],[...
21:37:58 <kmc> > iterate sequence ["abc","xyz"]
21:37:59 <lambdabot>   [["abc","xyz"],["ax","ay","az","bx","by","bz","cx","cy","cz"],["aaabbbccc",...
21:38:15 <kmc> > drop 2 $ iterate sequence ["abc","xyz"]
21:38:16 <lambdabot>   [["aaabbbccc","aaabbbccz","aaabbbcyc","aaabbbcyz","aaabbbxcc","aaabbbxcz","...
21:38:31 <kmc> > map length $ iterate sequence ["abc","xyz"]
21:38:36 <DrSyzygy> ...
21:38:43 <lambdabot>   mueval: ExitFailure 1
21:38:43 <lambdabot>  mueval-core: Time limit exceeded
21:38:50 <kmc> ok enough botspam from me
21:39:11 <Axman6> > liftM2 (liftM2 (*)) [[a],[b,c]] [[d],[e,f]]
21:39:15 <lambdabot>   mueval-core: Time limit exceeded
21:39:25 <Axman6> :(
21:39:25 <Axman6> what the flip?
21:39:33 <Axman6> > liftM2 (liftM2 (*)) [[a],[b,c]] [[d],[e,f]]
21:39:37 <lambdabot>   mueval-core: Time limit exceeded
21:39:44 <Axman6> > liftM2 (liftM2 (*)) [[a],[b]] [[d],[e]]
21:39:48 <lambdabot>   mueval-core: Time limit exceeded
21:40:01 <Axman6> > liftM2 (liftM2 (*)) [[a],[b,c]] [[d],[e,f]] :: [[Expr]]
21:40:03 <lambdabot>   Ambiguous occurrence `f'
21:40:03 <lambdabot>  It could refer to either `L.f', defined at <local...
21:40:13 <Axman6> > liftM2 (liftM2 (*)) [[a],[b,c]] [[d],[e,g]] :: [[Expr]]
21:40:15 <lambdabot>   [[a * d],[a * e,a * g],[b * d,c * d],[b * e,b * g,c * e,c * g]]
21:40:34 <Axman6> :t f
21:40:38 <lambdabot>     Ambiguous occurrence `f'
21:40:38 <lambdabot>     It could refer to either `L.f', defined at <local>:3:0
21:40:38 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
21:42:27 <geheimdienst> > liftM2 (liftM2 (*)) ["a","b"] ["d","e"]
21:42:28 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
21:42:28 <lambdabot>    arising from a use of `GHC....
21:46:01 <geheimdienst> @instances Monad
21:46:02 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
21:46:22 <jmcarthur> bss03: i wasn't talking about the vector library earlier
21:46:48 <jmcarthur> bss03: data Vector n a where Nil :: Vector Zero a; Cons :: a -> Vector n a -> Vector (Succ n) a
21:46:50 <Axman6> > liftM2 (liftM2 (++)) ["a","b"] ["d","e"]
21:46:51 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
21:46:51 <lambdabot>    arising from a use o...
21:47:21 <Axman6> > liftM2 (liftM2 (\x y -> [x,y])) ["a","b"] ["d","e"]
21:47:21 <lambdabot>   [["ad"],["ae"],["bd"],["be"]]
21:48:37 <Axman6> @pl (\x y -> [x,y])
21:48:37 <lambdabot> (. return) . (:)
21:48:50 <Axman6> @pl (\x y z -> [x,y,z])
21:48:50 <lambdabot> (. ((. return) . (:))) . (.) . (:)
21:51:47 <xpika> @pl (\x y -> not y)
21:51:47 <lambdabot> const not
21:54:30 <xpika> @pl (\x y-> not x)
21:54:30 <lambdabot> const . not
22:15:24 * hackagebot haskeline 0.6.4.0 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.4.0 (JudahJacobson)
22:18:43 <lispy> Decent alternative to GLUT: http://hackage.haskell.org/package/GLFW-b
22:19:07 <lispy> Like GLUT it still uses atexit() (sorry!), but it's easier to install on windows
22:38:00 <Axman6> lispy: what's atexit?
22:44:11 <geheimdienst> Axman6: texit is the function to tex something, anything. like when you say "beat it", there isn't any particular "it", just "it"
22:44:42 <geheimdienst> the prefix a- confers more oomph to the function texit, like when you say a-booyah. atexit!
22:44:42 <Axman6> huh? o.O
22:45:11 <Axman6> "atexit -- register a function to be called on exit"
22:45:29 <Axman6> heh, go Apple, block based version: atexit_b(void (^block)(void));
22:46:27 <geheimdienst> further variants include texit_yo, yeah_texit, and texit_srsly
22:46:50 <geheimdienst> function to be called on exit? no, i don't like your explanation very much
22:50:24 <frank00> I have a string like "(thing)stuff" and I would like to obtain a touple ("(thing)", "stuff"). span does something similar but not equal (it cuts last parenthesis). Is there any function to do that?
22:52:11 <Saizan> > lex "(thing)stuff"
22:52:11 <lambdabot>   [("(","thing)stuff")]
22:52:29 <Saizan> not so helpful
22:54:19 <geheimdienst> > break (==')') "(thing)stuff" 
22:54:19 <Saizan> frank00: span will give you ("(thing", ")stuff") then you can move that ) over
22:54:20 <lambdabot>   ("(thing",")stuff")
22:54:38 <geheimdienst> er, i see the problem 8)
22:54:56 <frank00> sorry got disconected
22:56:41 <Saizan> > ((++")") *** drop 1) $ break (==')') "(thing)stuff"
22:56:46 <lambdabot>   mueval-core: Time limit exceeded
22:56:46 <lambdabot>  mueval: ExitFailure 1
22:56:55 <Saizan> > ((++")") *** drop 1) $ break (==')') "(thing)stuff"
22:56:57 <lambdabot>   ("(thing)","stuff")
22:57:36 <geheimdienst> > (\(x,y) -> (tail x, tail y)) $ break (==')') "(thing)stuff" 
22:57:37 <lambdabot>   ("thing","stuff")
22:58:26 <geheimdienst> oh i've been wondering ... is there a function to apply the same function to both things in a tuple? like fmapping the tuple, but for both
22:58:46 <aavogt> > (succ *** pred) (2,True)
22:58:47 <lambdabot>   (3,False)
22:59:32 <geheimdienst> hm ... that seems to apply the 1st to the 1st and the 2nd to the 2nd
22:59:45 <geheimdienst> but thanks, i've been wondering about (***) for a long time :)
22:59:49 <Saizan> join (***)
23:00:03 <co_dh> :t Dual
23:00:03 <lambdabot> forall a. a -> Dual a
23:00:08 <geheimdienst> > join (***) tail ("lol", "cats)
23:00:09 <lambdabot>   <no location info>:
23:00:09 <lambdabot>      lexical error in string/character literal at end o...
23:00:25 <co_dh> :i Dual
23:00:30 <geheimdienst> :t join (***)
23:00:31 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
23:00:43 <co_dh> @hoggle Dual
23:00:44 <lambdabot> Data.Monoid newtype Dual a
23:00:44 <lambdabot> Data.Monoid Dual :: a -> Dual a
23:00:44 <lambdabot> Data.Monoid getDual :: Dual a -> a
23:01:06 <Saizan> > join (***) tail ("lol", "cats")
23:01:07 <lambdabot>   ("ol","ats")
23:01:21 <geheimdienst> oh, i'm an idiot :) thanks
23:01:43 <geheimdienst> :t join
23:01:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:04:55 <co_dh> :t (***)
23:04:56 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:05:33 <co_dh> :t join (***)
23:05:34 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
23:06:10 <co_dh> :t tail
23:06:11 <lambdabot> forall a. [a] -> [a]
23:06:23 <co_dh> :t join (***) tail
23:06:24 <lambdabot> forall a. ([a], [a]) -> ([a], [a])
23:06:30 <geheimdienst> co_dh: i don't understand that stuff either :)
23:07:04 <co_dh> geheimdienst:  reading from the type, and apply theorem for free :)
23:08:15 <co_dh> > join f x 
23:08:16 <lambdabot>   Ambiguous occurrence `f'
23:08:16 <lambdabot>  It could refer to either `L.f', defined at <local...
23:08:33 <co_dh> > join g x
23:08:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:08:34 <lambdabot>    `SimpleReflect.FromExpr ...
23:08:43 <Jafet> @undefine
23:09:03 <co_dh> >join (g :: Int -> Int -> Bool) x 
23:09:15 <Jafet> :t join f x
23:09:16 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
23:09:29 <Jafet> > join f x :: Expr
23:09:29 <lambdabot>   f x x
23:09:57 <Jafet> Perhaps there should be a defaulting rule
23:10:06 <anshul> Hey guys
23:10:15 <geheimdienst> wait, we're dealing with the Monad instance for (->) ...?
23:10:21 <co_dh> geheimdienst:  you see , join duplicate a function or arrow 's argument. so if an arrow f expect 2 argument, join f will need only 1 . 
23:10:22 <anshul> How do you install haskell libraries?
23:10:26 <co_dh> Jafet : thanks
23:10:37 <co_dh> cabal install blah
23:11:03 <anshul> How do you install cabal
23:11:12 <Jafet> cabal install cabal-install!
23:11:20 <Jafet> @where cabal
23:11:20 <lambdabot> http://www.haskell.org/cabal
23:11:55 <anshul> http://pastebin.com/evquxnNk
23:12:10 <co_dh> and (***) expecting 2 arrows, so join (***) take one 1 arrow.  it execute that arrow parallelly 
23:12:12 <anshul> I still get a cabal: command not found
23:12:19 <anshul> Any ideas why?
23:12:23 <geheimdienst> co_dh: yeah ... i've used join to turn an IO (IO Something) into IO Something
23:12:34 <co_dh> you don't have cabal installed. 
23:12:42 <Jafet> The cabal program is provided by the cabal-install package. Download that from the website above.
23:12:59 <Jafet> It is not provided by the Cabal library.
23:13:07 <anshul> Oh ok
23:14:21 <geheimdienst> anshul: if you're using linux, you can probably also get cabal from your package manager
23:14:25 <anshul> How do you install cabal-install?  That requires network, which requires parsec, which require 2 other libraries
23:14:49 <anshul> geheimdienst: Slackware doesn't seem to ship with cabal or ghc
23:15:45 <Jafet> cabal-install comes with an installer that does that for you. Just. download. it.
23:16:16 <anshul> Downloaded
23:16:19 <anshul> Now what?
23:16:53 <Jafet> Run the bootstrap.
23:17:36 <anshul> runghc Setup.hs configure complains that I need HTTP and network
23:17:39 <co_dh> anshul: I suggest you use debian, 
23:17:52 <co_dh> anshul: can you use wget www.google.com ? 
23:18:06 <anshul> yes
23:18:17 <co_dh> do you need to setup proxy ? 
23:18:17 <anshul> co_dh: ???
23:18:42 <anshul> # runghc Setup.hs configure
23:18:44 <anshul> Configuring cabal-install-0.10.2...
23:18:45 <anshul> Setup.hs: At least the following dependencies are missing:
23:18:47 <anshul> HTTP >=4000.0.2 && <4001, network >=1 && <3
23:18:47 <co_dh> do you have inside a company intranet with a windows proxy machine ?
23:18:48 <Jafet> anshul: the bootstrap.
23:19:08 <anshul> co_dh: my net is fine.  We are talking about the package dependencies
23:19:51 <anshul> Jafet: How do I run the bootstrap?  My umnderstanding was that I had to rub Setup.hs configure and then Setup.hs build
23:19:58 <Veinor> anshul: run bootstrap.sh
23:20:03 <anshul> oh
23:20:06 <Jafet> There is a file named bootstrap...
23:20:19 <Jafet> This should even be mentioned in the readme!
23:20:24 <anshul> Jafet: Thanks! You are a life saver
23:20:45 <anshul> I should have read that
23:20:57 <anshul> I assumed the installation will be the same as other packages
23:21:00 <anshul> my bad
23:53:58 <accel> what's haskell for os.sytem ?
23:54:06 <accel> or c's system(...) function
23:54:30 <geheimdienst> @hoogle system
23:54:30 <lambdabot> No results found
23:54:34 <geheimdienst> @hoogle rawSystem
23:54:34 <lambdabot> No results found
23:54:37 <geheimdienst> bah
23:54:52 <geheimdienst> gotta be a new low for hoogle ...
23:55:10 <accel> @hoogle System
23:55:10 <lambdabot> No results found
23:55:12 <geheimdienst> accel: http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Cmd.html
23:55:31 <accel> nice; thanks
23:55:52 <geheimdienst> if you need something with more doodles and twiddles, try System.Process
23:56:16 <ion> “It will therefore behave more portably between operating systems than system.” And generally more securely!
23:56:36 <ion> whenever dealing with untrusted data
23:56:38 <geheimdienst> you mean rawSystem? yeah
23:57:48 <geheimdienst> but i've always thought the name is a little unfortunate ... kinda gives you the idea this is some low-level thing you probably shouldn't be using, when in fact the opposite is true
23:59:49 <ion> Such a function would be named unsafeSomething :-P
