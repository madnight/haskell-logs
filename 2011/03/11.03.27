00:00:09 <c_wraith> I'm not seeing any helpful hints.  Nor the solution, for that matter. :)
00:00:34 <kamatsu> my professor did say it was challenging
00:01:01 <dancor> @hoogle threadAccumParam :: (a -> b -> (b, a)) -> a -> [b] -> ([b], a)
00:01:01 <lambdabot> No results found
00:01:08 <kamatsu> and his idea of "easy" is the challenging questions from sipser
00:01:10 <dancor> @hoogle (a -> b -> (b, a)) -> a -> [b] -> ([b], a)
00:01:10 <lambdabot> No results found
00:02:04 <dancor> sipser is a bit on the scrutable side after all
00:02:30 <kamatsu> i thought that was a good thing
00:02:51 <dancor> it is
00:04:00 <kamatsu> @hoogle mapAccum
00:04:00 <lambdabot> Data.IntMap mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
00:04:00 <lambdabot> Data.Map mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
00:04:00 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
00:04:15 <kamatsu> dancor: what you're looking for?
00:04:18 <c_wraith> well.  let's explore some useless bits.  L = 1L1L | 0L0L | empty
00:04:28 <c_wraith> clearly context-sensitive
00:04:33 <kamatsu> yep
00:04:49 <dancor> kamatsu: yes thank you!
00:04:50 <c_wraith> Err, that's not right.
00:04:54 <kamatsu> actually, that's not the right
00:04:59 <c_wraith> hehe. :)
00:05:05 <c_wraith> That's more restrictive than L
00:05:32 <c_wraith> In fact, L's definition isn't more interesting than what you already provided
00:05:39 <kamatsu> yeah
00:06:04 <c_wraith> This is interesting.  If a language is regular, it's complement is also regular.
00:06:13 <c_wraith> I wasn't aware the same didn't hold for context-free
00:06:24 <kamatsu> ah, something worth noting
00:06:33 <kamatsu> intersection of context free and regular is context free
00:07:11 <c_wraith> What's intersection here:  The strings in the intersection between any context-free language and any regular language?
00:07:35 <kamatsu> the language I = L /\ M
00:07:39 <c_wraith> yeah, ok
00:08:11 <c_wraith> Hmm.  I don't see how to apply that, directly.  But it is interesting
00:08:15 <kamatsu> yeah
00:08:26 <kamatsu> i was thinking if you could express it as some union
00:08:39 <kamatsu> maybe when you complement the whole thing then you could end up depending on that
00:08:55 <c_wraith> oh, hmm
00:09:03 <c_wraith> apply DeMorgan's laws, somehow?
00:09:06 <kamatsu> yeah
00:09:20 <c_wraith> That sounds worth exploring, anyway
00:10:13 <wharzl> I couldn't get the haskell-cafe message to go through, but here's my C9 want ad - http://channel9.msdn.com/Forums/Coffeehouse/WANTED-Haskell-Hacker-for-Compensated-Language-Project
00:10:22 <c_wraith> Though...  Since the very basis of this question is that context-free is not preserved under complement, I'm not sure how to apply that.
00:10:54 <kamatsu> hm, if you express every binary string as S1..SN
00:11:33 <kamatsu> then L is union(x <- 1..n) of {SxSx}
00:12:11 <dancor> you want to show that {binary strings not a concatenation of two identical strings} is context-free?
00:12:13 <c_wraith> that's true.  That makes it the union of an infinite number of regular languages
00:12:23 <kamatsu> dancor: yeah
00:12:29 <kamatsu> c_wraith: right.
00:12:42 <kamatsu> c_wraith: regular languages *are* closed among complement.
00:13:15 <kamatsu> i'm not convinced that helps
00:13:21 <kamatsu> because regular languages are closed under union as well
00:13:30 <c_wraith> yeah, the infinite set changes things
00:13:46 <c_wraith> every language can be expressed as the union of an infinite number of regular languages.
00:13:49 <c_wraith> That's not really interesting
00:14:17 <kamatsu> right, so, scrap that idea
00:17:49 <c_wraith> hmm.  past midnight.  time for food!
00:22:14 <kamatsu> sorry about that, had some net issues
00:26:35 <dancor> kamatsu: s_n := {binary strings of len 2n not a len-n string self-concatted}.  does s_{n+1} = {s_n where you add a 0 or a 1 (not nec. same) to the left of each half} U {.. to the right of each half}
00:30:08 <dancor> i think that is true
00:30:38 <dancor> oh wait you could add something in the middle
00:31:42 <kamatsu> yeah
00:35:16 <dancor> well.. my RHS certainly contains no n+1-self-concats.  for the other direction, suppose a is an 2n+2-len bin str that is not an n+1-self-concat.  so a = b c where b and c are n+1-len and at least one digit place differs.  therefore one digit place will differ in at least one of removing the left-places or the right-places.
00:36:18 <kamatsu> what does that show?
00:36:39 <dancor> i believe that shows that s_{n+1} = {s_n where you add a 0 or a 1 (not nec. same) to the left of each half} U {.. to the right of each half}
00:37:14 <ray> my irc latex senses are tingling
00:37:22 <kamatsu> i don't see how that's true.
00:38:26 <dancor> kamatsu: do you agree that s_{n+1} is a superset of the RHS
00:38:35 <kamatsu> yes
00:39:04 <dancor> ok.  for the other way, take an element a = b c of s_{n+1}
00:39:12 <kamatsu> alright
00:39:27 <dancor> b and c are n+1-len bin strs and they differ in at least one digit-place
00:39:38 <kamatsu> right
00:40:11 <dancor> this digit place could be the very left in which case removing the very right of b and c to make b' and c' will give a member a' = b' c' of s_n
00:40:48 <dancor> and if the digit place is not the very left then we can remove the very left and get b' != c'
00:41:23 <kamatsu> right, okay
00:41:57 <dancor> now, if we could make a CFG that uses this recursion..
00:42:13 <kamatsu> hm
00:42:53 <dancor> does having two stacks give a PDA any more power?
00:42:57 <kamatsu> yes
00:43:03 <kamatsu> two stacks are isomorphic to queues
00:43:08 <kamatsu> a PDA with a queue is a turing machine
00:43:11 <dancor> ah
00:44:25 <kamatsu> sometimes you can use nondeterminism with a PDA to do interesting things that might naively require 2 stacks though
00:44:34 <dancor> ya
00:48:05 <dancor> ray: you could write a latex-detector notifier
00:48:48 <ray> a turing machine is isomorphic to mushihimesama futari
00:48:53 <ray> wait no it isn't what am i saying
00:50:17 <dancor> turing reductions aren't allowed to break the fourth wall
00:53:51 <dancor> kamatsu: so CFGs have same power as NFA+1stack, and DFA+1stack is a strict subset?
00:56:39 <kamatsu> yeah
00:57:49 <dancor> "Another example is L = {w#w : w in {a,b}*}. We can show that L is not context-free using the pumping lemma. However, it's not too hard to build a context-free grammar for the complement of L."
00:57:55 <dancor> http://www.cs.uiuc.edu/class/sp09/cs373/Handouts/closure/cfl-closure.html
00:58:09 <dancor> it's not too hard, that's heartening.
01:00:53 <kamatsu> >_>
01:01:12 <dancor> this does give the hint that CFG is way to go instead of NFA+stack
01:02:20 <dancor> i think you just need to work with the "at least one digit doesn't match idea"
01:03:42 <kamatsu> i don't see how it helps
01:04:59 <kamatsu> http://www.jn.ethz.ch/education/script/chapter5.pdf
01:07:00 <dancor> kamatsu: there you have it
01:07:24 <kamatsu> yep
01:08:20 <dancor> centers
01:08:22 <dancor> crazy!
01:09:30 <kamatsu> yeah
01:09:44 <kamatsu> i see how it works though
01:09:48 <dancor> yes
01:09:52 <dancor> too clever for my blood
01:17:43 <lispy> I'm doing: join $ ioAction <$> ioArg1 <*> ioArg2 <*> ioArg3
01:17:52 <lispy> Is there a way to do this so that I don't need the join?
01:18:07 <lispy> ?pl  join $ ioAction <$> ioArg1 <*> ioArg2 <*> ioArg3
01:18:07 <lambdabot> join (ioAction <$> ioArg1 <*> ioArg2 <*> ioArg3)
01:19:58 <ddarius> Use (=<<)
01:19:59 <pastorn> lispy: ioAction :: ioArg1 -> ioArg2 -> ioArg3 -> IO lol ?
01:21:42 <lispy> ddarius: I must be tired, because I haven't found any obvious places to put (=<<) to make this work
01:22:12 <Saizan> ?type  let f <@> x = join (f <*> x) in \ioAction ioArg1 ioArg2 ioArg3 -> ioAction <$> ioArg1 <*> ioArg2 <@> ioArg3
01:22:12 <lambdabot> forall a a1 b (f :: * -> *) a2. (Applicative f, Monad f) => (a -> a1 -> b) -> f a -> f (a2 -> f a1) -> f a2 -> f b
01:22:25 <lispy> ioArg1 :: IO Foo, ioArg2 :: IO Foo, ioArg3 :: IO Foo, and ioAction :: IO Foo -> IO Foo -> IO Foo -> IO ()
01:22:37 <Saizan> ?type  let f <@> x = join (f <*> x) in \ioAction ioArg1 ioArg2 ioArg3 -> (ioAction <$> ioArg1 <*> ioArg2) <@> ioArg3
01:22:37 <lambdabot> forall a a1 a2 (m :: * -> *) a3. (Applicative m, Monad m) => (a -> a1 -> a2 -> m a3) -> m a -> m a1 -> m a2 -> m a3
01:22:42 <Saizan> yay.
01:23:17 <Saizan> lispy: are you sure that's the type of ioAction? in that case you don't need any operator
01:23:36 <lispy> oh, yeah, ioAction :: Foo -> Foo -> Foo -> IO ()
01:23:42 <lispy> sorry about the type
01:23:44 <lispy> typo)
01:25:34 <jekor> When I profile my program, 85% of the time spent shows as being in the MAIN module. Do I need to add more detailed cost centers, or is there a way to get that level of detail automatically (not just top-level functions)?
01:26:00 <lispy> jekor: are you using the auto caf all option?
01:26:06 <jekor> My other thought is that maybe decreasing the sampling interval might do it? Most of the operations in the program hapeen in a couple milliseconds, tops.
01:26:29 <jekor> I have -auto-all -caf-all
01:28:59 <malosh> Hi. I'm having a problem of style. I'm designing a document typeclass to write Pdf or Ps or anything. I have written font drivers that read standard font formats.
01:29:26 <malosh> Now I want to pair them : class FontDriver a b where ...
01:29:48 <malosh> with instances of a and b, a=Pdf, b=Some font format
01:30:44 <malosh> But now if I write an existential type data Text=for all f. Font f=>Text f, I cannot use these "pairings" anymore. Is Data.Dynamic a good way of solving this ?
01:35:57 <accel> does anyone have a document on implementing a very simple datbase, like sqlite, in haskell? (not looking for sqlite bindings; but ather, writing a datanbase in haskell)
01:39:13 * hackagebot FindBin 0.0.4 - Locate directory of original program  http://hackage.haskell.org/package/FindBin-0.0.4 (AudreyTang)
01:43:13 <accel> is there a way to run ghc in 'debug' mode, and see what are thunks ,and what are executed, and "step through the code like in gdb" ?
01:43:42 <Eduard_Munteanu> accel: you can do that with ghci
01:44:03 <jekor> accel: That's a pretty broad subject.
01:44:06 <Eduard_Munteanu> (something like that)
01:44:39 <jekor> (implementing a DB)
01:45:27 <accel> hmm; things like ahndling ACID
01:51:07 <co_dh> >t: trace
01:51:20 <co_dh> > t: trace
01:51:20 <lambdabot>   Not in scope: `trace'
01:51:37 <co_dh> >hoogle trace
01:52:36 <accel> @hoogle trace
01:52:36 <lambdabot> Debug.Trace trace :: String -> a -> a
01:52:36 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
01:52:36 <lambdabot> module Debug.Trace
01:53:15 * hackagebot FindBin 0.0.5 - Locate directory of original program  http://hackage.haskell.org/package/FindBin-0.0.5 (AudreyTang)
01:53:34 <co_dh> thanks accel.
02:01:43 <wunki> I'm getting an error when trying to install zlib through cabal. Think it's because of XCode 4. It says I'm missing ''zlib.h''. Any idea on how to fix this?
02:03:09 <wunki> screenshot of error: http://cdn.wunki.org/5Y8l
02:04:39 <Saizan> why do you want to reinstall it?
02:05:17 <Saizan> anyhow, it seems you haven't installed the C zlib fully, or at least cabal can't find the relative headers
02:05:28 <Saizan> but i'm not sure how you'd install it on os x
02:06:30 <wunki> Saizan: I want to reinstall it because it never finished installing, but does think it's installed.
02:08:10 <Saizan> it could also be that zlib.h is found but it doesn't build with the flags cabal is using, use -v2 or -v3 to see more details
02:08:47 <quotemstr> Thanks for the tip about reading Okasaki.
02:08:59 <quotemstr> I got through his thesis --- it's quite informative.
02:10:50 <co_dh> quotemstr: which thesis are we talking about?
02:11:27 <wunki> Saizan: I think this is the problem: http://projects.haskell.org/pipermail/haskell-platform/2011-March/001499.html
02:11:34 <wunki> Saizan: thanks for your help
02:12:51 <accel> what's the equiv of cairo/pango on the Mac, and does haskell have bindings for them?
02:19:22 <wunki> Saizan: FYI. The workaround posted here worked. http://projects.haskell.org/pipermail/haskell-platform/2011-March/001499.html
02:27:06 <quotemstr> co_dh: Purely Functional Data Structures
02:28:51 <co_dh> quotemstr: thanks :)
02:29:45 <co_dh> @where Purely Functional Data Structures
02:29:46 <lambdabot> I know nothing about purely.
02:36:58 <mjrosenb> quotemstr: where did you find a copy of his thesis?
02:38:39 <quotemstr> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
02:39:08 <mjrosenb> it makes sense that okasaki was bob's student
02:39:17 <mjrosenb> quotemstr: thanks.
02:42:39 <pastorn> mm_freak: hey, you awake?
02:43:08 <pastorn> @src foldr
02:43:08 <lambdabot> foldr f z []     = z
02:43:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:44:29 <pastorn> @src foldr1
02:44:29 <lambdabot> foldr1 _ [x]    = x
02:44:29 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
02:44:29 <lambdabot> foldr1 _ []     = undefined
02:45:01 <pastorn> undefined? seriously? how about error?
02:46:01 <Saizan> > foldr1 f []
02:46:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
02:46:02 <lambdabot>    `GHC.Show.Show a'
02:46:02 <lambdabot>      a...
02:46:12 <Saizan> > foldr1 (+) []
02:46:12 <lambdabot>   *Exception: Prelude.foldr1: empty list
02:46:18 <pastorn> Saizan: what i have is this (attoparsec):
02:46:23 <pastorn> choice' :: [Parser a] -> Parser a
02:46:24 <pastorn> choice' []      = empty
02:46:26 <pastorn> choice' [p]     = p
02:46:28 <pastorn> choice' (p:ps)  = P.try p <|> choice' ps
02:46:45 <pastorn> Saizan: run all in the list, fail if all fails
02:47:05 <pastorn> (iff.)
02:47:33 <Saizan> that should be equivalent to dropping the [p] clause
02:47:55 <pastorn> Saizan: no, the last one can't have try
02:48:15 <pastorn> foldr (\p -> (P.try p <|>)) empty
02:48:26 <pastorn> but that runs try on all, which is wrong :(
02:48:52 <Saizan> ah, then stick to the direct recursion :)
02:49:44 <pastorn> Saizan: but looking at foldr1, maybe that does what i want :/
02:50:51 <mjrosenb> pastorn: whenEmpty x  _ [] = x; whenEmpty _ f l = f l
02:51:14 <pastorn> mjrosenb: huh?
02:51:23 <Saizan> choice' [] = empty; choice' xs = foldr1 (\p -> (P.try p <|>)) empty xs
02:51:35 <Saizan> err, without the second empty
02:51:43 <pastorn> choice' [] = empty -- this is not nessecary
02:51:50 <mjrosenb> pastorn: you can use that along with foldr1, and just ignore the bad case when you pass the empty list to foldr1
02:51:59 <pastorn> you should never call my choice' function with empty lists
02:51:59 <Saizan> pastorn: why not?
02:52:20 <pastorn> Saizan: it's for regexes
02:52:30 <pastorn> Saizan: ( p0 | p1 | p2 )
02:52:32 <Saizan> then foldr1 would be fine, though i'd add the [] case just to be total
02:53:47 <pastorn> \ps -> if null ps then empty else foldr1 (\p -> (P.try p <|>)) ps
02:55:22 * Saizan sees that pastorn doesn't like pattern matching
02:55:22 <pastorn> nice, thanks Saizan, mjrosenb 
02:55:54 <pastorn> Saizan: leads to code that isn't as easy to maintain
02:56:08 <aristid> pastorn: foldr (\p -> (P.try p <|>)) empty ps ?
02:56:34 <pastorn> Saizan: say that you change a definition somewhere - if your basic combinators are changed in accordance with that change, then your code won't mess up
02:56:49 <mjrosenb> aristid: evidently P.try p <|> empty != p
02:57:00 <pastorn> aristid: won't that apply P.try to the last element?
02:57:00 <Saizan> pastorn: but i don't see [] changing any time soon :)
02:57:14 <pastorn> Saizan: it's a matter of principle ;)
02:57:22 <pastorn> mjrosenb
02:57:23 <aristid> pastorn: your foldr1 would do that too, no?
02:57:25 <pastorn> mjrosenb++
02:57:28 <pastorn> Saizan++
02:57:34 <aristid> @src foldr1
02:57:34 <lambdabot> foldr1 _ [x]    = x
02:57:34 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
02:57:34 <lambdabot> foldr1 _ []     = undefined
02:57:40 <aristid> oh, no
02:57:50 <pastorn> aristid: exactly :)
02:57:57 <pastorn> aristid: tricky, that one
02:58:11 <mjrosenb> pastorn: i've found that in general my constructors change less frequently than i want to go back and read some old code
02:58:13 <accel> @hoogle renderFont
02:58:13 <lambdabot> No results found
02:58:14 <aristid> i don't like the if
02:58:22 <aristid> pattern matching would make the code more readable :P
02:58:41 <pastorn> mjrosenb: ulf norell beat this coding style into me during "advanced functional programming"
02:58:53 <pastorn> and i don't want to dissapoint him
02:59:09 <pastorn> accel: you should look in hayoo
02:59:21 <accel> fuck that
02:59:24 <pastorn> accel: that seems like a GL, GLUT or SDL function
02:59:27 <pastorn> accel: indeed do
02:59:30 <accel> I just read the source of Graphics.Rendering.FTGL
02:59:32 <accel> I'm hard core like that
02:59:50 <pastorn> aristid: now it's a guard :)
02:59:55 <pastorn> choice' ps
02:59:57 <pastorn>     | null ps   = empty 
02:59:59 <pastorn>     | otherwise = foldr1 (\p -> (P.try p <|>)) ps
03:00:32 <pastorn> i couldn't decide how to indent the "then" and "else", so i avoided the problem
03:00:33 <aristid> pastorn: slightly better:)
03:00:49 * pastorn has code structure/indentation OCD
03:01:08 <Saizan> ..ulf norell is also the main developer of a language where you need to pattern match all over the place
03:01:13 <accel> how do I tell ghc: "link against FTGL"?
03:01:17 <pastorn> Saizan: i know
03:01:26 <pastorn> but the AFP course was just haskell
03:01:47 <Saizan> so it's quite ironic :)
03:02:02 <pastorn> Saizan: will i get mixfix in haskell for christmas?
03:02:14 <pastorn> i wantz it
03:02:19 <Zao> accel: Tell GHC, you mean?
03:02:22 <Saizan> if you start hacking them now, maybe
03:02:25 <Zao> --make; --package ASDF?
03:02:55 <mjrosenb> mixfix makes parsers sad
03:03:45 <accel> fuck
03:03:51 <accel> i need to rebuild ftgl in i386
03:03:58 <Zao> \o/
03:03:59 <accel> since my ghc is 386 rather than x86_64
03:04:09 <pastorn> accel: awesome :D
03:04:17 <accel> why is haskell platform default to 386 again?
03:04:22 <accel> as opposed to, say, 286 ?
03:04:23 <pastorn> accel: install xbomb for those nice compilation sessions :)
03:04:26 <Zao> How I wish that someone would make a x64 GHC on Windows already.
03:04:34 <accel> what's xbomb?
03:04:42 <pastorn> accel: the awesomest game
03:04:44 <mjrosenb> accel: minesweeper
03:04:49 <pastorn> minesweeper, on steroids
03:04:53 <Zao> accel: I'd be surprised if GHC targets anything below 686 or so.
03:05:21 <accel> how do I tell ./configure "build for 386 rather than x86_64" ?
03:07:30 <accel> alright
03:07:31 <accel> it works now
03:07:46 <killing-joke> rip oop. "Object-oriented programming is eliminated entirely from the introductory curriculum, because it is both anti-modular and anti-parallel by its very nature, and hence unsuitable for a modern CS curriculum."
03:07:52 <killing-joke> CMU has a new introductory curriculum for CS freshmen  existentialtype.wordpress.com/2011/03/15/teaching-fp-to-freshmen/
03:09:01 <mjrosenb> killing-joke: so i have heard.
03:09:19 <pastorn> accel: what did you do?
03:09:30 <accel> pastorn: I slaughtered a lamb, + a calf
03:09:42 <accel> alternatlvely , you just need to pass the "-m32" flag
03:09:44 <pastorn> no, but seriously, i want to know
03:09:47 <pastorn> oh
03:09:58 <pastorn> accel: compiled xbomb yet?
03:10:05 <accel> no
03:10:21 <pastorn> accel: do it. like a boss
03:10:22 <accel> how about I just give you an ssh account an dyou compile it for me?
03:10:28 <pastorn> haha
03:11:35 <mjrosenb> pastorn: my wife hates xbomb
03:12:36 <killing-joke> because she can't win, or because it makes you late to dinner?  :)
03:12:42 <pastorn> mjrosenb: because it steals you away from her?
03:13:03 <mjrosenb> because it doesn't stop the clock until you've marked all of the bombs
03:13:20 <pastorn> uhm... why is that so bad?
03:13:31 <mjrosenb> because she doesn't use them
03:13:45 <pastorn> wait wat? she doesn't mark any of her bombs?
03:13:47 <pastorn> is she nuts?
03:13:49 <mjrosenb> yup
03:14:04 <mjrosenb> she says they are for the weak
03:14:16 <pastorn> but seriously, then she can't "quick clear" by clicking on numbers where all adjacent bombs are marked!
03:14:21 <pastorn> hahahhahaha
03:14:45 <pastorn> mjrosenb: well, this is obviously a bug, and luckily you have l33t h4xx0r skillz
03:15:08 <pastorn> (and xbomb is under GPL iirc)
03:15:25 <mjrosenb> yeah, i'll have to do that after i get my laptop back
03:15:34 <mjrosenb> i refuse to do dev work in ubuntu
03:15:44 <pastorn> mjrosenb: why? i do it all the time
03:16:15 <mjrosenb> ubuntu just rubs me the wrong way
03:16:36 <pastorn> mjrosenb: DSL + everything installed manually?
03:16:45 <pastorn> or are you using freebsd/gentoo?
03:16:59 <mjrosenb> server is freebsd, laptop is gentoo
03:17:04 <pastorn> haha
03:17:08 <pastorn> why? drivers?
03:17:25 <mjrosenb> i suspect a large part of it is gnome
03:17:37 <pastorn> mjrosenb: which is easily replaced
03:17:40 <mjrosenb> like, i was attempting to recover files off of my hard disk
03:17:58 <mjrosenb> and so i plugged it into a usb adapter, then the computer
03:18:13 <mjrosenb> and it mounted the filesystem and fscked it
03:18:29 <pastorn> ok?
03:18:59 <mjrosenb> when there is major file system corruption, the last thing you want to do is to go and modify the file system
03:19:23 <Zao> Step 1) dd the whole disk to an image.
03:19:33 <pastorn> right, fsck writes stuff
03:19:36 <Zao> Step 2) do whatever you want to a copy of the image
03:19:55 <mjrosenb> Zao: yeah, but in order to dd the image, i still need to plug it in
03:19:56 <Zao> (dd_rescue or sdd might help in getting the image in the first place)
03:20:10 <Zao> mjrosenb: So don't use things that do things automagically for you.
03:20:14 <mjrosenb> Zao: and it was the act of plugging it in which messed things up
03:20:20 <pastorn> mjrosenb: you should've used some more specific tool for that job, like knoppix-std
03:20:20 <mjrosenb> Zao: yeah, too late for that
03:20:25 * Zao notes that he isn't in ##freebsd.
03:20:33 <pastorn> (which is a pretty awesome live cd, but a tad ol)
03:20:43 <Zao> I was going to ridicule you for using GNU/Linux, but as it's off topic here...
03:20:45 * Zao eyes -blah
03:21:08 <mjrosenb> FreeBSD  stargate-atlantis.rosenbridge 8.0-STABLE FreeBSD 8.0-STABLE #1: Sun Feb  7 00:51:05 EST 2010     root@ stargate-atlantis.rosenbridge:/usr/obj/usr/src/sys/GENERIC  amd64
03:21:09 <pastorn> noones haskelling now anyway :)
03:21:37 <mjrosenb> anyhow
03:24:16 <mjrosenb> can someone remind me that unsafeperformio is bad
03:28:45 <Saizan> unsafePerformIO kills kittens in its spare time
03:28:47 <ezyang> It allows you to arbitrarily violate many invariants that are commonly assumed about Haskell programs. 
03:29:51 <accel> Saizan: I thought it killed kittens at it's job too
03:30:04 <spidermario> I think “it unsafely performs side effects” says it all
03:32:32 <mjrosenb> ezyang: so i want to use it to mutate data in a way that should leave the results of any given accessor function unchanged
03:33:27 <ezyang> That's probably OK, but watch out for thread safety and other issues. 
03:34:37 <mjrosenb> yeah, i sort of want there to be a way to tell the compiler i'm doing something kinda sketchy here, make the types look nicer, and make sure everything blocks when it needs to
03:34:48 <ezyang> "It's called IO" 
03:37:02 <ezyang> If you're more specific, we can probably give advice about advanced type system features you can use to enforce the invariants. 
03:38:52 <mjrosenb> i'm thinking of something like a cache
03:39:17 <mjrosenb> where we only hang on to let's say 10 previously computed values
03:39:43 <mjrosenb> and i'd preffer to not lug the structure around, and i'd preffer to not have the whole thing be in the IO monad
03:40:43 <ezyang> That's reasonably OK (even GHC does stuff like that, for String interning). What is your multithreaded story? 
03:42:08 <Saizan> with a MVar (Map ..) it should be quite easy
03:42:36 <mjrosenb> and just throw unsafeperformio around calls to this?
03:43:01 <ezyang> You will also need to maintain a global unique cache, which will need NOINLINE. 
03:43:32 <mjrosenb> i won't cry if there are multiple versions of the cache, but gotcha.
03:44:02 <ezyang> In the worst case scenario, you could end up creating a cache on every access, so nothing gets shared at all. 
03:45:49 * hackagebot alpino-tools 0.0.5 - Alpino data manipulation tools  http://hackage.haskell.org/package/alpino-tools-0.0.5 (DanielDeKok)
04:09:04 <accel> does "cabal unpack" use local cache
04:09:07 <accel> or re-download every tiem?
04:09:15 <accel> these days, I find the easiest way to get the type of a function call
04:09:20 <accel> is to "cabal unpack package; grep"
04:09:25 <accel> but I don't wanbt to be stuffing up the inter tubes
04:09:38 <Saizan> it uses the cache
04:09:55 <accel> nice
04:10:04 * accel would hate to prevent other people from torrenting
04:30:57 * hackagebot hastache 0.1.3 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.1.3 (SergeyLymar)
06:01:18 <mm_freak> pastorn: ?
06:39:40 <ehamberg> i'm trying to do the following. is this possible with a prepared query? DB.quickQuery' db "SELECT * FROM t WHERE foo IN (?)" [possibleValues]
06:39:55 <ehamberg> where possible values should be a list of, well, possible values.
06:40:31 <ehamberg> toSql ["foo","bar"] does not work. :)
06:41:12 <hpc> the question marks don't work that way, unfortunately
06:41:41 <ehamberg> it there an alternative or should i simply add the values as part of the query string?
06:41:48 <ehamberg> “is”
06:42:21 <hpc> add more question marks
06:42:41 <ehamberg> but I don't know how many alternatives there will be.
06:42:54 <mauke> length values
06:42:54 <hpc> and do map toSql ["foo","bar"]
06:43:14 <ehamberg> aha. okay. thanks
06:50:09 <kniu> I need some serious help.
06:50:15 <kniu> @hpaste
06:50:15 <lambdabot> Haskell pastebin: http://hpaste.org/
06:51:10 <kniu> http://hpaste.org/45090/penn_treebank_parser
06:51:42 <kniu> I'm trying to extract rules from a file filled with sexprs
06:51:54 <kniu> it's pretty big at 1 million lines
06:52:00 <kniu> I keep running out of memory.
06:55:32 <Rc43> Hi, guyz.
06:57:30 <Rc43> Could you tell me, why compiler tells me, that i can't compare here (sl /= Void) = sl?
06:57:36 <Rc43> in program http://pastebin.com/eEeLeVqy
06:57:58 <mauke> what's the error message?
06:58:07 <spidermario> @hoogle Num
06:58:07 <lambdabot> Prelude class (Eq a, Show a) => Num a
06:58:07 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
06:58:07 <lambdabot> module Numeric
06:58:08 <Rc43> No instance for (Eq a)       arising from a use of `==' 
06:58:52 <mauke> Rc43: because your type signature says so
06:59:06 <mauke> also, Node x ~ Tree Void x Void
06:59:12 <Rc43> may be i am blind, tell more, please
06:59:30 <mauke> Rc43: == requires Eq (Tree a)
06:59:37 <mauke> Rc43: Eq (Tree a) requires Eq a
06:59:51 <Rc43> If you about data (Eq a) => Tree a = Void
06:59:55 <mauke> your type signature says 'search' works for all 'a', not just those in Eq
06:59:56 <Rc43> it doesn't help
07:00:08 <mauke> wat
07:00:12 <Rc43> really
07:00:16 <benmachine> Rc43: datatype contexts like that don't fix things
07:00:18 <mauke> what are you talking about?
07:00:39 <monadic_kid> what you're doing is abit odd anyway, get rid of Void data constructor and use Maybe
07:01:02 <mauke> monadic_kid: ew
07:01:13 <benmachine> it is a bit odd because there's Node x but also Tree Void x Void and they're basically the same
07:01:21 <mauke> monadic_kid: if it's odd, why does [] exist?
07:01:52 <kniu> also, why do I have to compile everything thrice if I want profiling and shared libraries?
07:02:13 <benmachine> Rc43: basically, use case-matching instead of /=
07:02:19 <hpc> kniu: you can shave it down to twice
07:02:30 <kniu> hpc, oh?
07:02:42 <hpc> kniu: compile profiling and shared, then link the shared into the executable
07:02:52 <hpc> kniu: unless i am horribly misinterpreting what you are asking
07:03:03 <Rc43> benchmacine, how can i do it here?
07:03:40 <benmachine> Rc43: one simple way would be to define an isVoid function on Trees
07:03:45 <Rc43> and why i get error even if there is data (Eq a) =>
07:04:06 <hpc> Rc43: you can't put class contexts in a data declaration
07:04:12 <hpc> Rc43: not without extensions at least
07:04:15 <mauke> because the type signature for 'search' still says it works for all 'a'
07:04:19 <mauke> hpc: you totally can
07:04:20 <benmachine> hpc: well, you could until haskell2011 removed them
07:04:23 <Rc43> so how i should tell tah data parameter is Eq?
07:04:26 <hpc> oh
07:04:30 <mauke> Rc43: you shouldn't
07:04:37 <benmachine> because they were useless :)
07:04:38 * hpc shuts up until he is totally awake
07:04:38 <mauke> what you should do is stop using /=
07:04:45 <Rc43> mauke, ye understood
07:04:52 <Rc43> thanks, i am blian
07:04:56 <mauke> pattern matching is your friend
07:04:56 <Rc43> thanks, i am blianblind*
07:04:57 <Axman6> Rc43: you might think that's what you want, but it's not
07:05:22 <Rc43> Axman6, what about you are talking?
07:07:13 <Axman6> Rc43: you can put class constraints on data types, but then those constraints need to be put on every single function you write to work with it. if you have data Num a => Foo a = ..., then show will get the type show :: (Show a, Num a) => Foo a -> String, functions that have no need for the constraint then start to specify it just to make the types ok
07:07:39 <jlouis> Rc43: I second that it is bad idea
07:07:45 <jlouis> use a pattern match on sl
07:07:57 <Axman6> they infect everything basically. the way you get what you want is to put the constraint on the functions that do actually need the constraint, and then don't export the constructors of the data type
07:08:51 <hpc> types are contagious!
07:08:53 <Axman6> class constraints on data types are like the GPL, they infect everything that uses them
07:09:00 <Axman6> >_>
07:09:03 <jlouis> hehe
07:09:04 <hpc> we must erradicate them with mandatory Python vaccinations!
07:09:23 <mauke> Axman6: the GPL doesn't infect things
07:09:24 <Rc43> Axman6, ye, I have understood that already by myself (use function constraint instead class one)
07:09:37 <Axman6> good =)
07:09:51 <Axman6> mauke: yeah it does, that's the point of it, to spread itself
07:09:54 <Saizan> i think igloo proposal to disallow them got accepted
07:10:01 <mauke> Axman6: only if you publish things
07:10:09 <Rc43> also pattern matching really better, thanks guyz
07:10:09 <Saizan> or at least an extension that disallows them :)
07:10:09 <Axman6> sure
07:10:20 <mauke> that's different from class constraints on types
07:16:09 <jlouis> Rc43: I wonder why your search is "backwards" with the where clauses
07:17:18 <jlouis> Rc43: is it because you only want an equality constraint on the type?
07:18:41 <jlouis> Rc43: I'd probably go for the type: search :: Tree a -> (a -> Bool) -> [a]
07:19:52 <hpc> wouldn't that be better served as filter :: Tree a -> (a -> Bool) -> Tree a?
07:20:28 <Rc43> jlouis, may be, it looks like reasonable
07:21:01 <jlouis> hpc: Yeah, that is another good option
07:21:07 <jlouis> depending on where you want to go
07:21:24 <jlouis> It is even more general
07:22:39 <hpc> it would be a fun challenge to make sure the tree stays sorted or whatever, after the filtering is done
07:22:40 <Rc43> hpc, I am wondering how to implement such filter function
07:23:46 <hpc> Rc43: say you had a tree (in condensed notation) A (B C D) (E F G)
07:23:47 <Rc43> hpc, but no, i know, but it will be like AVL
07:23:59 <hpc> ah, then that's pretty much how it would be done
07:24:00 <hpc> yeah
07:25:12 <hpc> it would be along the lines of filter (v:tree) f | f v = v:filter tree
07:25:19 <hpc> | otherwise = filter tree
07:25:23 <hpc> in horribly butchered haskell
07:26:04 <jlouis> the list variant is easier to write I think
07:26:32 <jlouis> You can also kill the Void constructor and replace the Tree a with Maybe (Tree a)
07:26:48 <jlouis> that way you can make it explicit when "Void" is allowed or not
07:26:48 <benmachine> the Void constructor is fine
07:27:06 <Rc43> I know a little about monads but now i wanted make program withou it
07:27:11 <benmachine> jlouis: well, you can make it explicit whether any of the constructors is allowed :P
07:27:49 <jlouis> oh, doh, I missed the Node has an a
07:27:52 <jlouis> 'a'
07:28:28 <Rc43> lol, my program is so interesting :D
07:42:14 <rothwell> hm... any way to get alex to accept unicode?
07:42:40 <rothwell> saw a patch somebody did in 2009, not sure if it was ever merged in the to mainline
07:47:55 <ml> is there any new exciting language similar to haskell in recent years?
07:48:38 <hpc> habit is currently under development
07:48:56 <hpc> it's a dialect of haskell made for writing low-level stuff
07:49:04 <hpc> like kernels
07:49:48 * tibbe is back from vacation.
07:49:49 <dropdrive> hpc: Any link?
07:49:53 <tibbe> What's new in Haskell land?
07:50:01 <osoleve> tibbe: this guyyy
07:50:09 <tibbe> :)
07:50:21 <tibbe> JaffaCake: nice paper
07:50:33 <tibbe> JaffaCake: skimmed it on my Android from Thailand :)
07:51:06 <hpc> dropdrive: if you google search for "habit programming language" you will find the preliminary report and the subreddit
07:51:16 <hpc> but there isn't much about it online atm
07:51:31 <Axman6> ml: there's deciple
07:51:48 <hpc> Axman6: is that actually how it's spelled?
07:51:55 <Axman6> probably not
07:52:07 <hpc> because the word is "disciple" iirc
07:52:25 <Axman6> well, it's not a word I've ever had to spell =)
07:52:34 <hpc> hehe
07:53:14 <ml> http://lambda-the-ultimate.org/node/2727
07:53:16 <geheimdienst> Axman6: please do not disrupt our mental masturbation with such comments
07:53:17 <ml> for disciple
07:53:30 <geheimdienst> anyhoo, another word with ridiculous spelling is eiderdown ...
07:54:57 <geheimdienst> ;)
08:10:27 <rovar> i need help with an instance of a recursive type.. 
08:10:45 <rovar> https://github.com/gregwebs/persistent/blob/master/Database/Persist/Base.hs
08:11:33 <rovar> I want to add to data PersistValue  |  PersistArray [PersistValue]
08:12:25 <rovar> in creating an instance of PersistField for that PersistValue.. i need a way to recursively construct the PersistArray from a list of values. 
08:13:43 <rovar> i am sure there is a way to lift the value into the constructor of PersistArray but my mind isn't working and I can't figure out how to append to the list held within. 
08:14:22 <benmachine> rovar: could you be more clear about your requirements? do you know what the instance head you want looks like?
08:14:50 <ManateeLazyCat> It's strangle *plink* script under /etc/network/if-up.d/ , script running after network available, but it's just exit after some seconds, strange....
08:15:47 <rovar> benmachine, the instance I'm trying to create is defined at line 68
08:17:00 <benmachine> rovar: line 68 doesn't seem to be an instance to me, are we looking at the same thing?
08:17:16 <rovar> so i'm trying to make  instance PersistField a => PersistField [a]
08:17:26 <benmachine> ah ok
08:17:45 <rovar> so i'm somewhat stuck on both  toPersistValue [] =     and toPersistValue (x:xs) 
08:35:52 <byorgey> rovar: toPersistValue xs = PersistArray (map toPersistValue xs) ?
08:36:10 <byorgey> or even just  toPersistValue = PersistArray . map toPersistValue
08:36:39 <rovar> yea.. i was just getting to that..  i went through mapM though.. which was the long way around :)
08:36:43 <rovar> thanks :)
08:36:55 <byorgey> no monads involved, so no need for mapM
08:36:59 <byorgey> sure =)
08:40:25 <rovar> so for fromPersistValue i have --  fromPersistValue (PersistArray xs) = map fromPersistValue xs
08:42:00 <byorgey> that seems good
08:42:24 <byorgey> oh, wait, no
08:42:40 <rovar> oh.. it's an either
08:42:41 <byorgey> fromPersistValue gives you an Either, right?
08:42:49 <rovar> yea.. easy enough to fix. 
08:43:02 <byorgey> here you actually DO want mapM =)
08:44:32 <rovar> what is wrong with =  Right (map fromPersistValue xs)
08:44:53 <paolino> hello, I'm looking for an instance of Random for Int64, but I haven't found it. Is there any way to derive it ?
08:45:18 <byorgey> rovar: map fromPersistValue xs has type  [Either String a]
08:45:32 <byorgey> rovar: so  Right (mapFromPersistValue xs) has type  Either String [Either String a]
08:45:36 <byorgey> but you want  Either String [a]
08:45:37 <rovar> ohpp you're right. 
08:45:44 <hpc> paolino: is there one for Word64?
08:45:53 <hpc> or something similar?
08:46:09 <Axman6> paolino: if you're on a 64 bit machine, then Int ~= Int64, so a fromIntegral should basically be a no-op
08:46:14 <byorgey> rovar: if you just change the map to mapM it should work. 
08:46:24 <Axman6> if not, get two Ints, and combine them
08:46:29 <byorgey> rovar: that will make the whole thing fail if any one of the individual calls to fromPersistValue does.
08:46:39 <byorgey> @type mapM
08:46:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:46:49 <byorgey> here m is replaced by 'Either String'
08:46:50 <mikeg> Assuming he has an appropriate monad instance for Either...
08:47:14 <byorgey> such an instance is standard. might have to import something though, I forget.
08:47:45 <parcs> paolino: fromInteger?
08:47:50 <paolino> Data.Either possibly
08:47:51 <byorgey> ah, yes, rovar, you will have to import Control.Monad.Instances
08:48:21 <paolino> hpc: there is no instance for Word64
08:49:15 <paolino> Axman6: I cannot be sure the code is tun on a 64 bit machine
08:50:43 <Axman6> do you need to cover the full 64 bits? can you just take Int and apply fromIntegral?
08:51:20 <opqdonut> or Integer
08:51:35 <rovar> so is there any hope for the sqlType function?    maybe something like  sqlType x = SqlList [sqlType (x !! 0)]  
08:51:44 <paolino> :t fromInteger
08:51:44 <lambdabot> forall a. (Num a) => Integer -> a
08:51:44 <rovar> (that just seems inane)
08:52:00 <paolino> :t fromInteger :: Integer -> Int64
08:52:01 <lambdabot> Integer -> Int64
08:52:33 <Axman6> is there a Random instance for Integer?
08:53:02 <paolino> yes ....
08:53:20 <ezyang> I wonder what distribution it has... 
08:53:21 <paolino> mh it's cheating I guess
08:53:33 <Axman6> ezyang: me too, what's why i asked
08:54:04 <paolino> it should be flat, or it breaks a lot of code
08:54:08 <Axman6> seems that if it covered all Integer values, you have just as much chance as getting 1 as you do of getting a number so large it won't fit into memory
08:54:15 <burp> what about CReal? :D
08:54:27 <hpc> CReal would be even worse lol
08:54:40 <geheimdienst> > maxBound :: Integer
08:54:41 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
08:54:41 <lambdabot>    arising from...
08:55:35 <paolino> should I use (*) to combine 2 Ints ?
08:55:39 <Axman6> :t random
08:55:39 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
08:55:41 <Jafet> Seems like the instance for Integer just casts from the instance for Int
08:55:51 <Jafet> Except when using randomR*, where it behaves as expected
08:56:05 <Axman6> > random (mkStdGen 4) :: (Integer, StdGen)
08:56:06 <lambdabot>   (-258552320774346181,289488136 2103410263)
08:56:19 <Jafet> You think it should be bottom instead?
08:56:27 <hpc> paolino: multiplication would be bad; the least of your problems would be that the probability of getting an even number is 3/4 instead of 1/2
08:56:53 <Axman6> > map (fst . random . mkStdGen) [1..] :: [Integer] 
08:56:55 <lambdabot>   [7917908265643496962,-2493721835987381530,5541392136091291592,-258552320774...
08:56:57 <Jafet> Or put (Bounded a) in the method types, but that requires some extension
08:57:11 <byorgey> hpc: not to mention that the probability of getting a prime is zero
08:57:11 <geheimdienst> isn't Integer unlimited? how could you have a random number between 0 and infinity?
08:57:15 <Axman6> > maximum . take 1000 $ map (fst . random . mkStdGen) [1..] :: [Integer] 
08:57:16 <lambdabot>   No instance for (System.Random.Random [GHC.Integer.Type.Integer])
08:57:16 <lambdabot>    arisin...
08:57:22 <hpc> byorgey: ooh, that's even worse
08:57:30 <Axman6> > maximum . take 1000 $ map (fst . random . mkStdGen) [1..] :: Integer
08:57:31 <lambdabot>   9218424180786176118
08:57:38 <Axman6> > maximum . take 100000 $ map (fst . random . mkStdGen) [1..] :: Integer
08:57:42 <lambdabot>   mueval-core: Time limit exceeded
08:57:47 <Axman6> > maximum . take 10000 $ map (fst . random . mkStdGen) [1..] :: Integer
08:57:48 <lambdabot>   9218424180786176118
08:57:50 <Jafet> > maxBound :: Int
08:57:50 <lambdabot>   9223372036854775807
08:57:59 <Jafet> Okay, folks.
08:58:04 <ian_mi> geheimdienst: the distribution 2^-(n + 1) would work
08:58:45 <hpc> by the magic of bell curves!
08:59:23 <paolino> hpc , a bitwise operation ?
09:00:05 <aristid> which expression is nicest? 2^-(n+1), (1/2)^(n+1) or 1/(2^(n+1))?
09:00:43 <hpc> paolino: worst-case, you could generate 64 Bools and fold them into an Int64 using the Bits instance
09:01:06 <ian_mi> a distribution over the natural numbers would be nicest of course
09:01:19 <hpc> foldl' (\x y -> x << 1 + y) 0 bools, for example
09:01:26 <hpc> (not valid haskell, but close)
09:02:27 <hpc> aristid: the first
09:02:42 <aristid> hmm.
09:02:49 <aristid> what about 2^-n-1?
09:03:02 <hpc> nah
09:03:09 <hpc> maybe the second, in a pinch
09:03:14 <hpc> the third is awful
09:03:24 <ian_mi> you mean 2^(-n-1)
09:03:28 <ian_mi> which doesn't look quite as nice
09:03:37 <spidermario> *** Exception: Negative exponent
09:03:45 <ddarius> ^^
09:03:47 <hpc> :t (^)
09:03:48 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
09:03:52 <hpc> :t (**)
09:03:53 <lambdabot> forall a. (Floating a) => a -> a -> a
09:03:54 <Jafet> Now all we need is for Escardo to write us a Random instance for the Cantor set.
09:04:45 <hpc> oh man, don't tempt me
09:05:04 <ian_mi> I could write one, but it would never terminate
09:05:45 <hpc> by Cantor set, you mean the type ([Bool] -> Nat)?
09:06:03 <dolio> Nat -> Bool
09:06:25 <hpc> piece of cake
09:06:34 <ian_mi> no [Bool]
09:06:45 <hpc> smaller piece of cake :P
09:06:49 <DRMacIver> copumpkin: No, N Commandments's approach is really very not-clever. :) 
09:06:49 <dolio> [Bool] has too many values.
09:07:19 <ian_mi> fine Seq Bool
09:07:29 <hpc> Nat -> [Bool] is isomorphic to [[Bool]]
09:07:40 <ian_mi> wait no
09:07:40 <hpc> so you can make a random [[Bool]] and diagonalize it
09:07:44 <ddarius> What do you call an algebraic structure like a ring but with a commutative multiplicative group and an additive monoid?
09:08:15 <dolio> Seq Bool has only the extra, wrong values from [Bool].
09:08:19 <roconnor> a commutative ring?
09:08:23 <roconnor> oh
09:08:27 <roconnor> wait
09:09:07 <ian_mi> dolio: yeh, I just googled sequence
09:09:20 <ian_mi> dolio: I don't who decided to make sequences finite...
09:09:36 <copumpkin> the requirements imposed by the underlying datastructure
09:10:02 <ddarius> roconnor: It's a rig (semiring) only the multiplicative monoid structure is a group.
09:10:20 <ian_mi> data Seq a = Cons (Seq a)
09:10:35 <copumpkin> ian_mi: you're looking for stream, and that thing carries almost no information
09:10:42 <ddarius> copumpkin: What do you mean?  You can't give me infinite data structures with O(1) access to the head and the tail?
09:11:07 <ian_mi> well streams are really sequences then...
09:11:10 <dolio> Anyhow, Nat -> Bool is an implementation of streams of Bools.
09:11:53 <roconnor> ddarius: the additive monoid is commutative?
09:12:07 <conal> stream is the natural trie for (Nat ->)
09:12:21 <dolio> So, tropical semirings are an example?
09:12:24 <conal> i.e., the generic trie construction invents Stream
09:13:49 <paolino> Anybody uses http://hackage.haskell.org/packages/archive/QuickCheck/2.4.0.1/doc/html/Test-QuickCheck-Monadic.html, which has no documentation ? How could one guess it ...
09:13:50 <ddarius> roconnor: Not necessarily unless that is implied by the other axioms.
09:14:37 <copumpkin> paolino: mind-reading powers
09:14:39 * roconnor cannot find a name for it
09:14:58 <copumpkin> I thought most of these ringish structures assume more structure on the + than the *
09:15:07 <copumpkin> most of the ones I've seen anyway, which isn't saying much
09:15:09 <ddarius> copumpkin: Indeed.
09:15:20 <paolino> quickcheck should be out of platform without docs
09:15:23 <ddarius> A ring is a multiplicative monoid stacked on an abelian group.
09:21:55 <dolio> @check \i j k -> i + (j `max` k) == (i + j) `max` (i + k)
09:21:55 <lambdabot>   "OK, passed 500 tests."
09:22:02 <paolino> copumpkin: don't have those powers and signatures are not self explanatory for a beginner, maybe that module is deprecated or broken, others have docs
09:22:14 <dolio> @check \i j k -> i - (j `max` k) == (i - j) `max` (i - k)
09:22:15 <lambdabot>   "Falsifiable, after 1 tests:\n-3\n-1\n3\n"
09:23:17 <hpc> @check \i j k -> i - (j `max` k) == (i - j) `min` (i - k)
09:23:18 <lambdabot>   "OK, passed 500 tests."
09:28:50 <lpsmith> http://hpaste.org/45093/opengl_problem
09:29:11 <lpsmith> I'm having a bit of difficulty installing the Haskell Platform from source, due to opengl issues
09:29:12 <pastorn> lpsmith: what OS are you using?
09:29:15 <lpsmith> Ubuntu
09:29:45 <pastorn> sudo apt-get install libopengl-ev
09:29:47 <pastorn> *dev
09:29:49 <pastorn> or whatever
09:30:12 <jmcarthur> "libopengl" is just mesa, isn't it?
09:30:48 <jmcarthur> huh, i guess there is a libopengl-dev
09:31:02 <lpsmith> wouldn't it be preferable to compile it against the nvidia drivers?
09:31:15 <lpsmith> or is that not really an advantage?
09:31:24 <jmcarthur> oh right
09:31:29 * jmcarthur shrugs
09:33:04 <ddarius> Actually, I guess all I need is a group anyway.
09:33:08 * ddarius wasn't thinking clearly.
09:33:39 <ddarius> Anyway, in future Haskell: (^) :: Monoid m => m -> Natural -> m and (^^) :: Group g => g -> Integer -> g
09:34:23 <ddarius> The latter could be defined simply as (inverse .) . (^)
09:35:02 <lpsmith> but both (N,+) and (N,*) are monoids
09:35:09 <ddarius> lpsmith: So?
09:35:14 <jmcarthur> that's a good thing
09:35:18 <lpsmith> So you'd have to disambiguate if (^) meant (*) or (^)
09:35:27 <lpsmith> clearly you want to default to the latter
09:35:48 <jmcarthur> there are other monoids too
09:36:02 <Saizan> there isn't a Monoid instance for Integer anyway, there are Sum Integer and Product Integer
09:36:05 <lpsmith> And I don't want to have to specify a type each and every time I want to use (^),  that's silly
09:36:46 <jmcarthur> we're allowed to say that future haskell has a clean way of disambiguating ;)
09:38:29 <osoleve> is Nothing considered null, or do you have to check against it?
09:38:54 <lpsmith> osoleve, Nothing often takes the place of null
09:38:55 <jmcarthur> haskell doesn't have null
09:39:01 <parcs> :t isNothing
09:39:02 <lambdabot> forall a. Maybe a -> Bool
09:39:05 <byorgey> you have to check, the type system won't let you ignore it.
09:39:07 <jmcarthur> Nothing is used in its place and requires you to handle it
09:39:15 <jmcarthur> there are nice combinators for making it more convenient
09:39:20 <lpsmith> You can't interchange (Maybe a) and (a) though,  generally speaking
09:39:21 <ddarius> @google tony hoare billion dollar
09:39:22 <lambdabot> http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
09:39:22 <lambdabot> Title: InfoQ: Null References: The Billion Dollar Mistake
09:39:42 <osoleve> > fromMaybe $ Just 2
09:39:43 <lambdabot>   Overlapping instances for GHC.Show.Show
09:39:43 <lambdabot>                              (Data....
09:39:43 <Jafet> > let fromJust = error "Null pointer" in fromJust Nothing
09:39:43 <lambdabot>   *Exception: Null pointer
09:39:51 <osoleve> dang
09:39:55 <ddarius> lpsmith: We could if we had equirecursive types and a = Maybe a
09:40:33 <jmcarthur> > fromJust $ Just 2
09:40:34 <lambdabot>   2
09:40:35 <ddarius> Admittedly, that would only allow a Peano representation of naturals as values.
09:40:38 <jmcarthur> ^^ bad
09:41:07 <lpsmith> > fromJust $ Nothing
09:41:07 <jmcarthur> > fromJust Nothing
09:41:08 <lambdabot>   *Exception: Maybe.fromJust: Nothing
09:41:08 <lambdabot>   *Exception: Maybe.fromJust: Nothing
09:41:45 <rovar> arg.. 
09:41:55 <jmcarthur> osoleve: once you get through Functor, Applicative, and Monad, Maybe won't be frustrating at all :)
09:41:58 <lpsmith> yeah,  better to use case ... of { Nothing -> ... ;  Just a -> ... }  or maybe
09:41:59 <lpsmith> :t maybe
09:42:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:42:10 <jmcarthur> yeah or use maybe, fromMaybe, etc.
09:42:12 <ddarius> The maybe function is one of my favorite functions.
09:42:23 <lpsmith> @src maybe
09:42:23 <lambdabot> maybe n _ Nothing  = n
09:42:23 <lambdabot> maybe _ f (Just x) = f x
09:42:30 <rovar> I think i have List and Map fully implemented.. but i'm having a problem in that instance PersistField [a]  is overlapping with instance PersistField String.. is there any way to specify the former doesn't apply to [char] ? :)
09:42:34 <lpsmith> See,  I would have written that as 
09:42:35 <ddarius> I never case analyze a Maybe unless I'm going to further pattern match (in a refutable way) on the components.
09:42:42 <jmcarthur> > maybe 5 succ $ Just 1
09:42:43 <lambdabot>   2
09:42:46 <jmcarthur> > maybe 5 succ Nothing
09:42:46 <lambdabot>   5
09:42:54 <lpsmith> maybe nothing _ Nothing = nothing;    maybe _ just (Just x) = just x
09:43:04 <osoleve> jmcarthur: i'm not frustrated, just confused. Reading up on Haskell and needed it clarified.
09:43:07 <osoleve> thanks, all. :)
09:43:35 <jmcarthur> well, it can get frustrating until you get used to some of the library functions
09:44:05 <jmcarthur> but then you realize that null sucks anyway
09:44:26 <ddarius> Every programmer should already know that in their bones.
09:47:57 <dolio> Plenty seem to be in denial about it.
09:48:54 <rly> You could argue the same thing about Haskell, but then related to laziness.
09:49:38 <rovar> https://gist.github.com/889366
09:49:54 <rly> In the end whether or not null is allowed or not, you still have to write a correct program, which is not that different in Haskell than in $randomLanguage. 
09:50:00 <rovar> I am trying to create an instance of PersistField (defined on line 85) 
09:50:12 <lpsmith> I recently ran across a pretty sharp PostgreSQL developer with an interest in Haskell and Erlang;   he feels pretty strongly that making everything nullable in SQL was a mistake
09:50:18 <rovar> there is an instance for String.. but I would like to make a seperate instance for [a] 
09:50:57 <rovar> string is obviously overlapping.. is there a way I could specify that my [a] doesn't include [char]  or possibly combine the two, but pattern match the char ones seperately?
09:51:22 <ddarius> lpsmith: There are plenty of people that think that allowing NULL at all in relational databases is a mistake.
09:51:23 <Jafet> OverlappingInstances takes care of that. The GHC manual has the matching rules.
09:51:45 <lpsmith> ddarius, oh I know
09:52:10 <rly> So.. how are you going to express that in fact something could have 'no value'?
09:52:17 <lpsmith> Maybe
09:52:23 <rly> It is just that doing it by default might not be a good idea. 
09:52:31 <lpsmith> right
09:52:33 <Jafet> What does "no value" mean?
09:52:46 <rly> But then again, people can build other systems on top of it. 
09:53:09 <rly> It might be an extremely small point of efficiency too.
09:53:29 <jmcarthur> i think SQL's notion of NULL is pretty horrible, too
09:53:31 <rly> But even that could be fixed in a DBMS. 
09:53:43 <lpsmith> rly, the difference is that Haskell Program will never core dump (unless there is a bug in the runtime or related to the use of the FFI)  because types don't like
09:53:45 <lpsmith> *lie
09:54:03 <jmcarthur> i just wish that common RDBMSs had algebraic data types
09:54:07 <lpsmith> If you have a value of type Int,  you really do have a value of type Int
09:54:10 <rly> lpsmith: except that you cannot really write a lot of programs in Haskell.
09:54:13 <Jafet> People have thought really hard and come up with consistent systems of types and values. "No value" means you're disregarding all that work.
09:54:23 <jmcarthur> or at least sum types (and the notion of "product" would just be relations)
09:54:26 <lpsmith> rly, examples please.
09:54:45 <rly> lpsmith: rgrep foreign. 
09:55:04 <rly> lpsmith: if you are calling C, it is not Haskell anymore :)
09:55:16 <Jafet> Or that you're a troll...
09:55:17 <jmcarthur> that doesn't mean it can't be written in haskell
09:55:24 <lpsmith> rly, that's a separate issue than the one we've been discussiong
09:55:38 <lpsmith> Null pointers do not make your language more expressive
09:55:40 <lpsmith> period
09:55:41 <jmcarthur> the topic is about expressiveness, not bindings...
09:56:02 <rly> lpsmith: no, you made a claim about Haskell programs. 
09:56:02 <dmwit> I feel confident that all (most?) of the things that *are* done in C *could* be done in Haskell, too... but why bother reimplementing them?
09:56:46 <lpsmith> rly, you are putting words in my mouth
09:57:06 <rly> lpsmith: uhm... LOL? 
09:57:28 <jmcarthur> rly: i'm not sure you know what you are talking about
09:57:45 <benmachine> Jafet: did you seriously recommend OverlappingInstances to someone? :P
09:58:02 <jmcarthur> rly: "So.. how are you going to express that in fact something could have 'no value'?"  <-- there is a well-known answer to this, and it was given to you, and you ignored it
09:58:36 <Jafet> Strictly speaking, he mentioned it first
09:59:12 <jmcarthur> hmm, maybe the question was about databases, not haskell?
09:59:16 <benmachine> Jafet: mm, imo the proper response is "do not use overlappinginstances, it is unpleasant for various reasons"
09:59:34 <Jafet> Okay, tell rovar that then
09:59:43 <jmcarthur> rly: i apologize. i misunderstood the context of that question
09:59:44 <Jafet> Although, I've never met the unpleasant side myself
10:00:24 <benmachine> rovar: having a function behave differently for [a] and [Char] is usually considered unpleasant, because you need to know *all* the instances in scope to know what your function will do, instead of just one that matches
10:00:30 <jmcarthur> rly: what i said earlier is what i would propose as a solution. databases should have sum types
10:00:37 <benmachine> rovar: and changes in imports can add new instances that changes existing behaviour in surprising ways
10:01:06 <benmachine> rovar: usually, this sort of behaviour is achieved with newtypes, but I suspect that's not exactly what you want; you could also use Typeable but that's unpleasant too
10:01:10 <dolio> benmachine: Like show?
10:01:38 <Jafet> It gets even better when you use sqlite -- no type checking on columns, period.
10:01:50 <rovar> benmachine, I have concerns about this.. but in the case of persisting to a database..  inserting a [char] is treated drastically differently for all other [a] 
10:02:07 <benmachine> dolio: well, suppose you get a String, and you want to know how it's shown - you know that the [a] instance will tell you that (although you then have to look up the Char instance to work out how *that* works)
10:02:21 <dolio> :)
10:02:51 <benmachine> I wonder if the same trick could be used here
10:02:59 <benmachine> but I should be working on other stuff instead of worrying about it
10:03:16 <benmachine> so I can't fix your problem, exactly, rovar, I can just warn you of what might go wrong :P
10:03:39 <rovar> I can combine the two instances and just pattern match on the [char] somehow.. 
10:03:51 <rly> rovar: what is the point of all these abstractions?
10:04:07 <rovar> ultimately i think the right approach in this case is to not support String but use ByteString instead.. 
10:04:18 <rly> rovar: do you intend to have third parties writing backends?
10:04:20 <rovar> i think we'll be converting everything to Text soon
10:04:29 <rovar> rly, not frequently. no.. 
10:04:39 <rly> rovar: then I think this is overdesigned.
10:04:59 <rovar> well. let me rephrase.. 
10:05:20 <rovar> there is a class for persistent types which every implementor of a new database has to support. 
10:05:29 <rovar> so 3rd parties can use it.. 
10:05:50 <rovar> the problem is that it was designed for relational databases and was a bit too restrictive to support MongoDB
10:06:19 <rovar> so I added to the class itself.. which shouldn't be done often. 
10:07:02 <rovar> what is kind of annoying is that most DB interfaces offer their own data type mappings.. so for every query, types get mapped and unmapped twice. 
10:07:29 <rovar> i would expect that they would always be remapped at least once.. because DBs all have different type representations. 
10:16:03 <lpsmith> well, I gave up on compiling the OpenGL bindings for Haskell on Ubuntu 10.10
10:16:14 <lpsmith> I'm not going to need them anytime soon anywya
10:16:42 <Rc43> Is there approach to get list of data constructors in haskell?
10:16:59 <Rc43> for example, i have data Foo = Foo1 | Foo2 a
10:17:18 <Rc43> and i want get ["Foo1", "Foo2 a"]
10:17:32 <benmachine> Rc43: some faffing about with Data might get you what you want
10:17:34 <parcs> Rc43: derive Enum and Show
10:17:39 <benmachine> but possibly not in exactly that form
10:17:45 <benmachine> it might be complicated
10:18:03 <parcs> eh, on second thought, disregard that advice. :P
10:21:02 <Rc43> If we can aknow field names we can get it bu deriving Enum.
10:21:08 <Rc43> *by
10:44:03 <joe6> does anyone use any commad line tools to paste to hpaste?
10:44:30 <monochrom> I heard someone built something into their own emacs or something.
10:44:43 <joe6> long ago, there used to be pastepipe and hpaste, but I could not get them to compile lately.
10:45:24 <monochrom> also they may be incompatible with current hpaste. (hpaste has went through several reincarnations)
10:46:39 <ourfrank> Where can I find information about the ' and '' template haskell operators? Are there more?
10:47:09 <hpc> pastepipe sounds like about 5 minutes of LWP and input handling
10:49:05 <aavogt> @wiki Template_Haskell
10:49:06 <lambdabot> http://www.haskell.org/haskellwiki/Template_Haskell
10:49:50 <hpc> @wiki is it just string manipulation?
10:49:50 <lambdabot> http://www.haskell.org/haskellwiki/is_it_just_string_manipulation?
10:49:53 <aavogt> ourfrank: there are more like [| |] brackets, $( ) 
10:49:53 <hpc> lol
10:56:03 <ourfrank> As I understand, '' is for type names, and ' for constructor names, right? Thanks for the link, it seems to contain good tutorials.
11:02:08 <aavogt> ourfrank: not just constructor names,    ('head   :: Name) is valid too
11:07:15 <djahandarie> kamatsu, did you figure out your context-free problem?
11:18:01 <Rc43> guys, how can i make it work?
11:18:04 <Rc43>       bracket         (putStrLn "start") (putStrLn "fin") (return read "12" :: Integer)
11:18:50 <c_wraith> :t bracket
11:18:51 <lambdabot> Not in scope: `bracket'
11:18:59 <c_wraith> :t Control.Exception.bracket
11:18:59 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:19:01 <Rc43> import IO
11:19:11 <aavogt> you're missing parentheses around (read "12" :: Integer)
11:19:17 <c_wraith> ah, right.
11:19:26 <TomMD> and the second argument is the wrong type.
11:19:32 <Rc43> i mean return
11:19:39 <aavogt> and you might need to use $! instead of normal function application of return
11:19:45 <Rc43> ah, i have written it
11:19:51 <aavogt> :t IO.bracket
11:19:51 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:20:08 <c_wraith> heh.  really, you'd want evaluate, rather than "return $!"
11:20:15 <c_wraith> In this case, "return $!" would suffice, though
11:20:27 <c_wraith> or, well.  readIO
11:20:37 <c_wraith> :t readIO
11:20:38 <lambdabot> forall a. (Read a) => String -> IO a
11:20:40 <Rc43> what is wrong with second arg?
11:21:19 <TomMD> Control.Exception.bracket         (putStrLn "start") (const $ putStrLn "fin") (\_ -> return (read "12" :: Integer))
11:21:19 <TomMD> Notice the 2nd and 3rd arguments need to be 1-arity functions (which I've done in two separate ways that mean the same thing).
11:21:21 <c_wraith> Rc43: I'd *really* recommend using readIO for that purpose, anyway.  It's the one that's guaranteed to work in IO
11:22:03 <Rc43> btw, i need just to know if arg is integer but this example have interested me
11:22:17 <dmwit> :t reads
11:22:18 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:22:29 <TomMD> So you don't need 'bracket' at all, just some sort of list or maybe type.
11:22:33 <TomMD> as dmwit said.
11:22:51 <Rc43> what is wrong with second arg, first action doesnt return anything, right?
11:23:14 <dmwit> > let isInteger x = any (null . snd) (reads x :: [(Integer, String)]) in isInteger "12"
11:23:15 <lambdabot>   True
11:23:18 <dmwit> > let isInteger x = any (null . snd) (reads x :: [(Integer, String)]) in isInteger "12a"
11:23:19 <lambdabot>   False
11:23:30 <Rc43> :t any
11:23:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:24:15 <TomMD> Rc43: the first arg return unit, or "()".
11:24:31 <Rc43> () != void?
11:24:46 <TomMD> It's the closest Haskell has and is a value.
11:24:49 <TomMD> :t ()
11:24:49 <lambdabot> ()
11:24:51 <Rc43> i mean, i should do something with this ()?
11:24:51 <TomMD> see
11:25:08 <TomMD> Rc43: yes, you should ignore it via "const" or a lambda (\_ -> expr).
11:25:26 <Rc43> (\_ -> putStrLn "fin")
11:25:26 <aavogt> ghc has Any or something similar to that
11:25:28 <Rc43> like this?
11:26:32 <TomMD> in the signature for "bracket" the type variable "a" here unifies with "()".  It's not like the "a ->" disappears just because it isn't meaningful to you.
11:26:55 <benmachine> Rc43: like that, yes
11:27:03 <TomMD> Rc43: Yes, if you see my post above I do it that way once and with const on the other argument.
11:27:34 <TomMD> It's the same thing, just different styles (const _ x = x)
11:27:40 <TomMD> err, sorry "const x _ = x"
11:27:49 <dmwit> Rc43: I think you may be misunderstanding the purpose of bracket, though.
11:28:11 <dmwit> Rc43: (Just based on the order of the arguments you gave and the stated purpose of your code.)
11:28:27 <Rc43> purpose to do action despite unsuccesfull finish of something
11:28:29 <Rc43> right?
11:28:43 <Rc43> for example openFile closeFile readFile
11:28:57 <dmwit> Yes. But you don't need to run things before and after the read.
11:29:02 <dmwit> You just need to catch an exception.
11:29:07 <dmwit> So you should just use catch.
11:29:13 <Rc43> Ok.
11:29:24 <lpsmith> Ok, is there a way to tweak your .cabal/config file to exclude cabal-install from installing newer versions of libraries in the user database than what already exists in the global database?
11:29:42 <dmwit> Also, as I suggested above, it's even better to simply avoid the exception-throwing function at all.
11:30:10 <dmwit> lpsmith: Don't think so.
11:30:42 <dmwit> lpsmith: However, you can request particular versions of a library, if you find that the dependencies of the newest version can't be satisfied with libraries that are already installed.
11:32:03 <benmachine> lpsmith: you can put constraints in there, I think
11:32:20 <benmachine> lpsmith: so, crudely, you could autogenerate Constraint: lines from ghc-pkg
11:32:37 <benmachine> (no idea if this works in practice)
11:32:45 <lpsmith> yeah, I dunno
11:33:04 <lpsmith> my current cabal database with ghc-6.12.3 wants to continually re-install regex-compat
11:33:26 <lpsmith> And I'm going to give ghc-7.0.2 a spin now
11:36:35 <accel> on OSX, what's a decent haskell library for rendering lines / strokes / curves into an OpenGL texture ?
11:38:46 <rovar> is there any way to map between constructors of simiar types without pattern matching? 
11:39:35 <ddarius> rovar: Ultimately, the only way to do anything to a data type is through pattern matching.
11:39:45 <rovar> arg...
11:40:01 <monochrom> "ultimately" does not have to be "directly" though
11:40:57 <monochrom> to have a function for a variety of "similar" types, use a type class. instance code still has to pattern-match.
11:41:12 <rovar> i reckon some TH could help
11:41:29 <monochrom> or else look for one of those "scrap boilerplate" or "generic" big gun solutions
11:43:37 <Eduard_Munteanu> accel: Cairo should work on Mac, doesn't it?
11:43:53 <Eduard_Munteanu> Unless you don't want to depend on that sort of stuff.
11:44:24 <qwert_> hi all!
11:44:40 <qwert_> can anyone help me with STM in haskell?
11:45:03 <Eduard_Munteanu> qwert_: hi. You should ask your question directly.
11:46:50 <qwert_> any idea how to validate a transaction?
11:48:22 <qwert_> anyone read the paper "Composable Memory Transactions" by Simon Peyton Jones??
11:48:44 <qwert_> pls help me understand validation?
11:49:31 <Botje> which part of it is unclear?
11:49:57 <Botje> or rather, which parts do you get?
11:50:10 <qwert_> Could you take a  look at the following implementation "Composable Memory Transactions in Concurrent Haskell"
11:50:32 <qwert_> i guess the validation in the paper is wrong
11:50:46 <qwert_> or may be i don't get it
11:50:59 <qwert_> should i post the url of the paper?
11:51:16 <Botje> i haven't read that paper
11:51:24 <Botje> but probably someone here will
11:51:36 <Botje> I was just trying to get you to more fully explain why you think it's wrong
11:51:51 <qwert_> i can explain it to you 
11:52:05 <qwert_> can u double check my understanding?
11:53:37 <qwert_> i don't understand the readTVar function.
11:54:06 <qwert_> it stores the validation as a state.
11:55:02 <dmwit> Is "validation" a word used in the paper? If not, could you explain what you mean by it?
11:55:17 <qwert_> in the paper  is say "The function readTVar extends the already stored validation by a comparison of its own value with the local new value stored in its log"
11:55:45 <qwert_> but in the implementation it never uses the value store in its log
11:55:47 <qwert_> ????
11:55:53 <qwert_> pls help me out???
11:56:03 <dmwit> What implementation are you looking at?
11:56:31 <qwert_> Composable Memory Transactions in Concurrent Haskell by Frank Huch and Frank Kupke
11:57:43 <qwert_> readTVar implementation on page 6
11:58:32 <jekor> Anyone know why -prof -auto-all -caf-all on my program shows 85% of individual time spent in the cost center "MAIN"?
11:58:49 <overscore> Hi. I'm having a mental block about the difference between   [x,_] and [x:_] in pattern matching.
11:59:29 <Botje> overscore: desugar them. the first is (x:_:[]), the second is ((x:_):[])
11:59:52 <Botje> so the first is of type [a], the second of type [[a]]
12:00:08 <Twey> overscore: The first has two elements, the second has one element which is a list.
12:00:27 <overscore> that clears it up
12:00:38 <overscore> so : is some kind of constructor?
12:00:44 <Twey> : is the list constructor, yes
12:01:00 <Twey> data [x] = [] | x : [x]
12:01:01 <Twey> Roughly
12:01:03 <overscore> and the coma does what exactly? is there a name for it?
12:01:12 <dmwit> qwert_: (I'm reading, by the way, so don't give up on #haskell yet.)
12:01:13 <Twey> It's just part of the syntactic sugar for lists
12:01:18 <Twey> It separates list items
12:01:51 <qwert_> thanks dmwit! 
12:01:59 <overscore> neat. , is for working with consed values, : to make up new lists
12:02:23 <qwert_> read pages 1-6 skip 3.
12:03:29 <dmwit> qwert_: The function "atomically" uses the "isValid" field of the STMState, which is modified in readTVar.
12:04:12 <Botje> overscore: [a,b,c] is just a shorter way of writing a:b:c:[]
12:04:29 <qwert_> yes could you look the the readTVar fun in page 6 where we create the newstate?
12:04:55 <Eduard_Munteanu> overscore: note ':' is right associative
12:05:20 <qwert_> as per the paper "The function readTVar extends the already stored validation by a comparison of its own value with the local new value stored in its log"
12:05:39 <dmwit> Yes.
12:06:12 <qwert_> which is correct and logical but in the implementation return (tVarVal == oldVal) we never look at the stored val in the log
12:06:38 <dmwit> oldVal *is* the value in the log.
12:06:57 <dmwit> tVarVal is the value at the time the validation stage runs.
12:07:02 <qwert_> we compaper tVarRef with it self 
12:07:08 <dmwit> No.
12:07:11 <qwert_> it will always return ture?
12:07:16 <dmwit> We compare the result of reading tVarRef at two different times.
12:07:21 <overscore> yeah i get the :[] part
12:08:16 <qwert_> why is oldVal *is* the value in the log.???
12:08:17 <dmwit> oldVal is read at readTVar time, tVarVal is read after the entire transaction has run.
12:08:52 <dmwit> qwert_: The key to understanding this is to realize that we are building (but not executing) an IO action in the isValid field.
12:09:01 <qwert_> ie after the transaction commits?
12:09:05 <dmwit> That action is only executed later, when we actually do the validation in atomically.
12:09:58 <dmwit> No, before commit, but after the whole transaction has been computed.
12:11:46 <ddarius> overscore: Asking what the comma is in [1,2] is like asking what 'of' is in case e of {...}.  It's just a syntactic separator.  There, in fact, is no comma operator.
12:12:50 <qwert_> so as per you we computed the transaction using startSTM stmAction actionId. then get the new state and check it if its valid?
12:12:54 <monochrom> is like asking what "h" means in "what"
12:13:41 <overscore> gotcha
12:14:18 <dmwit> qwert_: Yes.
12:14:43 <dmwit> qwert_: Or rather, sort of.
12:15:04 <dmwit> qwert_: startSTM stmAction actionId computes the transaction and the new state.
12:15:37 <dmwit> qwert_: Then, the phrase "valid <- isValid newSTMState" executes the validation check that was built up during "startSTM ...".
12:16:32 <dmwit> Transactions often do some computation (in addition to memory accesses).
12:16:55 <dmwit> By the time startSTM is done, we've done those computations, that's all I meant.
12:17:05 <b0fh_ua> Hello! I need some help with Curl and posting od multipart data. The source is at http://pastebin.com/HGYmNmEm. Looks lile the post data is not created correctly. Can somebody please take a look?
12:18:24 <Rc43> doLoop [(String, Integer)] -> IO ()
12:18:32 <Rc43> Guys, what can be wrong with this?
12:18:40 <Rc43> (parse error on ->)
12:18:49 <Igloo> Missing ::
12:18:50 <b0fh_ua> Rc43: ::
12:19:32 <Rc43> lol
12:19:34 <Rc43> thanks
12:20:10 <qwert_> dmwit: we are at 2 diff times reading the value of tVarRef.
12:20:30 <qwert_> when are we comparing it to out local value?
12:21:01 <qwert_> "The function readTVar extends the already stored validation by a comparison of its own value with the local new value stored in its log"
12:21:41 <qwert_> we are comparing the global value of the tVar at 2 diff points in time.
12:22:18 <qwert_> thats diff from comparing the global tVar val to out local val in out log.
12:22:28 <qwert_> *our
12:23:58 <dmwit> qwert_: The "log" is a closure including the value read from the tVar some time in the past.
12:25:05 <qwert_> it too thought so. but is it?
12:25:53 <qwert_> check readtvar on page 5. it show to read a val from log.
12:26:27 <qwert_> tvar 2 arg is the log.
12:27:04 <dmwit> That's a different log.
12:27:17 <qwert_> shouldn't we use lookup (stmId stmState) tLogs
12:27:57 <overscore> ugh autotune :/
12:28:00 <qwert_> its the tread/transaction local val of the tvar.
12:29:11 <qwert_> tLog stores  local new value stored in its log
12:29:25 <qwert_> again "The function readTVar extends the already stored validation by a comparison of its own value with the local new value stored in its log"
12:29:48 <qwert_> in which log is the new value stored?
12:29:49 <dmwit> tLog is a log of writes; the isValid block holds also a log of reads.
12:31:10 <qwert_> are the read and write sets kept seperately?
12:31:24 <qwert_> so the closure is the log of past vals.
12:31:54 <dmwit> I believe so. But this is from a surface reading only.
12:32:07 <overscore> is this good style ? :)
12:32:07 <overscore> http://pastebin.com/K3sqLDCk
12:32:12 <qwert_> makes sense now
12:32:45 <dmwit> overscore: It's alright, although I would point out a few things:
12:32:46 <qwert_> thanks a lot for the help
12:33:03 <dmwit> overscore: Line 4 subsumes line 3.
12:33:22 <dmwit> overscore: It's common to index starting at 0 rather than 1 (though of course that's your choice).
12:33:32 <overscore> (x:y) fails on a 1-valued list no?
12:33:39 <jlouis> no
12:33:45 <jlouis> x:[]
12:33:48 <dmwit> overscore: There's syntactic sugar for Num comparisons, so you can just write "elementAt (x:y) 1 = ...; elementAt (x:y) i = ..." rather than an explicit if.
12:34:14 <jlouis> and x:[] is equivalent to [x] (the latter is a shorthand for the former)
12:34:37 <dmwit> overscore: There is a standard library function for this, in case you weren't aware (though it seems you probably wanted to reimplement it anyway, based on the "problem 3" annotation).
12:34:51 <dmwit> Other than that, yes, looks fine. =)
12:34:58 <ddarius> A horrible standard library function that would be better not existing.
12:35:33 <overscore> thanks
12:36:09 <overscore> you know,
12:36:26 <overscore> I'm probably going to be reimplementing half of the prelude for a long time to come
12:36:38 <dmwit> Yep, that's normal. =)
12:36:40 <overscore> but that's because I don't know haskell well enough to know what to use when
12:40:52 <rly> overscore: the Prelude is incomplete anyway. 
12:41:05 <rly> overscore: I think most Haskellers have their own version of it.
12:41:36 <ddarius> I'm pretty sure most don't.
12:42:10 <b0fh_ua> Hello! I need some help with Curl and posting od multipart data. The source is at http://pastebin.com/HGYmNmEm. Looks lile the post data is not created correctly. Can somebody please take a look?
12:43:19 <qwert_> thanks dmwit for the help. c u later.
12:43:28 <dmwit> cheers
12:43:58 <Rc43> do you know why case matching can work incorrect?
12:44:23 <dmwit> ERR_BUG_DESCRIPTION_TOO_VAGUE
12:44:47 * Eduard_Munteanu returned -ETOOVAGUE :P
12:44:48 <dmwit> That's at both b0fh_ua and Rc43, by the way.
12:45:55 <b0fh_ua> dmwit: but I don't know how to describe it even more detailed. I pasted the code and result of sniffing HTTP protocol. What else can I do?
12:46:30 <dmwit> What result did you expect to see?
12:46:46 <b0fh_ua> dmwit: something posted to the server actually
12:47:39 <Rc43> o_0 case matching doesn't work with string constants? I replaced some1 [case str of some1 -> .. some2 -> ... ] to 
12:47:44 <Rc43> "somestr"
12:47:50 <Rc43> and it became correct
12:48:46 <dmwit> > case "yes it does too work" of "not a match" -> 0; "yes it does work too" -> 1; "yes it does too work" -> 2
12:48:47 <lambdabot>   2
12:49:22 <dmwit> > case "yes it does too work" of [] -> "empty"; ('y':rest) -> rest
12:49:23 <lambdabot>   "es it does too work"
12:49:42 <azaq23> Rc43: Case is also a binding construct. case x of { y -> ... } binds the matched thing (y here, nothing is matched, so there's no (y:z) or something) to the name y. You can't match against the content of a variable using case, apparently.
12:50:15 <Rc43> azaq23, o_0
12:50:18 <Rc43> thanks
12:50:26 <dmwit> > let f x = case x of [] -> "empty"; ('y':rest) -> rest in f "yes you can match against the content of a variable"
12:50:27 <lambdabot>   "es you can match against the content of a variable"
12:50:49 <dmwit> Oh, now I understand what you mean.
12:51:23 <dmwit> > let x = "thing" in case x of [] -> "empty"; y | x == y -> "same"; ('t':rest) -> "never get here"
12:51:23 <lambdabot>   "same"
12:52:03 <dmwit> > let x = "thing" in case "thing" of [] -> "empty"; y | x == y -> "same"; ('t':rest) -> "never get here" -- a better example, less confusing
12:52:04 <lambdabot>   "same"
12:56:26 <Tomsik> Oh, I didn't know you could have guards together with pattern matches in case-expressions, heh.
12:58:07 <dmwit> b0fh_ua: What disqualifies the sniffed HTTP traffic from being "something"?
13:00:20 <Bfig_> if i have several (curried) functions of two operands or more, how are they interpreted when i stack them together without anything? say i wanted to do scanl (*) (4 `div` 3) [1,2,3]... is this correct?: > scanl (*) div 4 3 [1,2,3] 
13:01:01 <dmwit> Function application is left-associative.
13:01:21 <dmwit> So, with all parentheses, that parses as
13:01:29 <Bfig_> or more precisely, why would the parse fail, the first argument to scanl would be (*), the second would be div only?
13:01:31 <BMeph> Bfig_: No.
13:01:39 <dmwit> ((((scanl (*)) div) 4) 3) [1, 2, 3]
13:01:41 <BMeph> Bfig_: Yes.
13:02:04 <dmwit> The parse shouldn't fail, though the type-check should.
13:02:07 <BMeph> Bfig_: (In answer to your two questions, respectively. ;)
13:02:13 <Bfig_> BMeph, :)
13:03:06 <Bfig_> so the parse is always left associative, so when i don't parens it takes the first thing as the next operator for the last function? how do you connect functions of several operators?
13:03:25 <dmwit> Just parenthesize.
13:03:32 <dmwit> scanl (*) (div 4 3) [1, 2, 3]
13:04:07 <BMeph> Bfig_: What do you mean by "connect"? As Inigo Montoya says, "I do not think this word means, what you think it means." ;)
13:04:11 <Bfig_> of course, if *I* write my code, i do it, but i'm facing a 'type error checking' test in two days which amounts for about... a hundred percent of my course grade? ;)
13:04:13 <dmwit> Probably the clearest thing for me to say here is, "I don't understand the question.".
13:04:35 <Bfig_> compose functions with several operands
13:04:55 <Bfig_> three lines up, it should've said operand instead of operator
13:05:39 <dmwit> There are two standard approaches. One is not worth mentioning.
13:05:40 <Bfig_> so i'm trying to understand how the syntax is supposed to work even if only for reading code straight from haskHell
13:05:44 <b0fh_ua> dmwit: because there is no post fields I specified
13:05:47 <dmwit> The other looks like this: \x y z -> f (g x y z).
13:06:27 <dmwit> This "composes" the one-argument function f with the three-argument function g.
13:08:08 <Bfig_> i'm not trying to find a way to compose function, but to understand the parse trees for when you have functions of several operands. let me explain myself a bit better, this is the kind of stuff i have to give types to: ((.) foldr), ((.) . foldr)
13:09:22 <Bfig_> literally, one exercise in a practice sheet i got has this two and some other variants of folds applied to (.) and viceversa, and i have to understand what type it generates.
13:09:48 <dmwit> Okay, so you want to learn how to run the type-checking algorithm by hand?
13:09:55 <Bfig_> basically :p
13:10:04 <dmwit> That's easy, but a very different question than the one I thought you were asking. =)
13:10:17 <Bfig_> can i find it somewhere on the internet so i don't have to bother you? i've been trying since yesterday :S
13:10:35 <dmwit> The keyword is "unification".
13:11:04 <benmachine> Bfig_: I wrote a program to explain this once but then I broke it
13:11:05 <dmwit> Wikipedia's page is probably good.
13:11:11 <dmwit> http://en.wikipedia.org/wiki/Unification_(computing)
13:11:22 <BMeph> Bfig_: Haskell is non-strict; feel free to both look it up ->And<- ask us here. ;)
13:12:10 <dmwit> For the "induction" step, read "f(t_1, t_2)" as "t_1 -> t_2" (that is, "f" is a function arrow) to start with, since that's the most common "f" we have in Haskell.
13:12:24 <Bfig_> thanks to both of you, but i don't wanna push your patience. the channel has been very useful and friendly so far =)
13:13:20 <Bfig_> dmwit, wouldn't that be t_1->t_2->t_3 ?
13:13:35 <dmwit> No, t_1 -> t_2 -> t_3 is just
13:13:43 <dmwit> t_1 -> (t_2 -> t_3)
13:13:54 <dmwit> So, the two arguments to (->) are t_1 and (t_2 -> t_3).
13:14:46 <dmwit> (Actually, the first time I warped my brain enough to understand this point was also the moment I decided Haskell was going to be a language I *had* to learn.)
13:15:53 <Twey> Is ‘arr id’ an identity for >>>?
13:16:13 <BMeph> Bfig_: No, please push us - it makes our xylum stronger! :)
13:16:19 <hpc> :t arr id
13:16:19 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
13:16:27 <hpc> :t Control.Category.id
13:16:27 <lambdabot> forall (cat :: * -> * -> *) a. (Control.Category.Category cat) => cat a a
13:16:37 <hpc> Twey: arr id == id
13:16:40 <benmachine> Twey: id is, and I'd guess that often id = arr id, but it's not guaranteed afaik
13:16:52 <benmachine> wait hmm
13:16:52 <hpc> benmachine: you sure? i thought it was
13:16:56 <Twey> hpc: Only for the function arrow, no?
13:17:07 <benmachine> hpc: I'm not sure
13:17:14 <Twey> ‘arr id’ is more general, I think
13:17:41 <benmachine> Twey: 'id' in this context I'm assuming means Control.Category.id rather than Prelude.id
13:17:45 <hpc> arr id is not more general
13:17:46 <Twey> Oh, okay
13:17:56 <Twey> Yes, I thought you meant Prelude.id
13:18:21 <benmachine> of course, in 'arr id' the id is Prelude.id
13:18:24 <TomMD> What no instance for Applicative STM?  How dare GHC 6.12.X be so incomplete.
13:18:38 <overscore> > myReverse [x,y] = y:x
13:18:39 <lambdabot>   <no location info>: parse error on input `='
13:18:41 <rly> TomMD: perhaps nobody uses STM ;)
13:18:48 <TomMD> Right!  That must be true...
13:18:52 <Twey> overscore: : is cons, not concatenation
13:19:02 <hpc> :t (:)
13:19:03 <lambdabot> forall a. a -> [a] -> [a]
13:19:07 <hpc> :t (++)
13:19:07 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:19:10 <overscore> i want cons tho
13:19:13 <BMeph> TomMD: 6.12? THat's, like, sooooo last year... :)
13:19:18 <overscore> but can't see where the fail is
13:19:26 <dmwit> Twey: Law functor-identity, page 4 of "Arrows and computation": pure id = idA
13:19:30 <TomMD> Right, I know, I usually use 7.0.1 but am grabbing 7.0.3 now.
13:19:37 <dmwit> Twey: So, yes, arr id is identity for >>>.
13:19:56 <Twey> *nod* Thank you
13:20:12 <djahandarie> > (runKleisli $ arr id Kleisli (return :: a -> Maybe a)) 3
13:20:13 <lambdabot>   Just 3
13:20:15 <BMeph> overscore: The fail is, "y:x" is not "[y,x]", but "y:x". :)
13:20:41 <hpc> Twey: also, you should really be reasoning about id and (.), not arr id and (>>>)
13:20:59 <hpc> Twey: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=8 <- should help
13:21:03 <overscore> i want to create a new list by pattern-matching against the former
13:21:46 <parcs> > let myReverse (a:b:xs) = b:a:xs in myReverse [1..10]
13:21:46 <lambdabot>   [2,1,3,4,5,6,7,8,9,10]
13:21:48 <BMeph> overscore: As in, you're trying to claim (by defn of ":"), that "x" is a type of a list of y's type. Except, that can't be right, since you "just earlier" took them both from the same list.
13:23:46 <Evet> i've heard haskell improves programmer productivity
13:24:22 <hpc> Evet: more that it improves the programmer :P
13:24:23 <BMeph> Evet: Unfortunately, it isn't true; people still insist in using Java. ;p
13:25:26 <overscore> hrmmr
13:25:29 <Evet> haskell programs can be compiled to machine code, and can be run without any dependency, right?
13:25:53 <benmachine> Evet: haskell programs use libraries, but they can be statically linked
13:25:54 <hpc> Evet: yes, to the same degree you can run C programs without dependencies
13:26:08 <Evet> great
13:26:17 <hpc> you still need gtk to run gui programs that use it, etc
13:26:26 <Evet> could you recommend me a book to start hacking in haskell?
13:26:32 <hpc> @where lyah
13:26:32 <lambdabot> http://www.learnyouahaskell.com/
13:26:38 <BMeph> overscore: To be more explicit, "[y,x]" is equal to "y:x:[]" just as "[x]" is "x:[]"
13:26:41 <hpc> ^ best introductory material
13:26:42 <rly> Evet: you can just build one statically linked application (even including whatever library you could possibly want). 
13:27:02 <rly> Evet: whether you would actually want that is a different thing.
13:27:27 <hpc> depending on the libraries you include, your program can get really large
13:27:44 <Evet> ahh. how can i forget. learnyouhaskell is legend
13:28:08 <overscore> that's how I started.
13:28:32 <overscore> anyway, i'll mull over the [y,x] problem some
13:28:32 <hpc> same
13:30:30 <overscore> myReverse (x:y:[]) = y:x:[]   passed, but it bombs out
13:31:03 <Bfig_> question about $: if you use it, does it try to associate to *everything* on the right, even if it doesn't make sense sintactically? or is this impossible to predict, say, because the function could be overloaded in a weird way such that it could lead to two correct parses if it didn't collect everything to the right?
13:31:57 <Zao> Bfig_: It's all about fixity.
13:32:11 <Bfig_> ie, take  f:: a->b, g::a->c, f::a->b->c, and you try to parse f $ g x
13:32:22 <Bfig_> Zao, what is fixity?
13:33:02 <BMeph> Bfig_: He means "operator precedence"
13:33:57 <benmachine> Bfig_: $ is just a normal operator, it doesn't do anything magic
13:33:59 <BMeph> Bfig_: (technically, fixity deals with other things, but in this instance, the relevant issue is precedence, IMO.)
13:34:07 <Bfig_> but doesn't wrapping things in parens basically change the parsing tree overriding whatever precedence was before?
13:34:58 <Bfig_> so it doesn't try to be 'intelligent', it is just a way to substitute f $ ... for f ( .... ) [actually the other way round]?
13:35:03 <BMeph> Bfig_: Define "the parsing tree". ;)
13:35:24 <sshc> 8\la -cl
13:35:32 <benmachine> Bfig_: it doesn't try to be intelligent wrt types or anything
13:37:56 <Bfig_> is there a way without parenthesis to talk about the n+1th argument of a function inside the first call? ie, f g t0 t1 t2... can you make t0 and t1 be args for g and t2 for f?
13:38:31 <Bfig_> ie, f taking two parameters, g and t2, and g taking two parameters, t0 and t1
13:39:00 <benmachine> Bfig_: you would have to define your own operator a bit like $ but left-associating
13:39:40 <Bfig_> ok, so there is no standard operator like... $n ?
13:39:41 <aavogt> define f so that you can write    f t2 $ g t0 t1
13:40:03 <aavogt> or    flip f t2 $ g t0 t1
13:40:14 <Bfig_> imagine something like this: f g $2 t0 t1 t2
13:41:24 <benmachine> Bfig_: you'd define something like $$ such that f $$ g t0 t1 $$ t2 = f (g t0 t1) $$ t2 = f (g t0 t1) t2
13:42:18 <Bfig_> ok, so in the case we just had to work with what we had, how would the final type would go for f g t0 (f takes two args, g takes two args)?  >:t f g t0  -=-> a->b->c  (a being the second term of g, b being the second term for f?)
13:43:28 <overscore> is there a way to know what is the version of the haskell platform is currently installed
13:43:49 <benmachine> Bfig_: it can't work like that; if you use things like $ it interferes with currying
13:44:03 <Bfig_> if we add another term then it would only require the second term for f, right?, but if we parens that expression and added another term we'd get the only missing term is the second from g. is this correct?
13:44:42 <jmcarthur> overscore: depends on distro
13:44:44 <benmachine> Bfig_: you've lost me
13:45:02 <Bfig_> let me try to clarify my question
13:46:40 <Bfig_> suppose you have two functions f and g, both taking two arbitrary parameters. you want to see what functions of two variables you can make by composing those two functions, so it is an experiment to see which variables end up being omitted. it must start with f... or (f..., and no more parenthesis are allowed
13:47:43 <BMeph> Bfig_: You seem to be ignoring that if you write "f g ...", that makes "g" an argument of "f". It does not matter if arguments after it could be used in g, writing "f g ..." makes g the first argument to f, period.
13:47:48 <Bfig_> we could have for example  h = f g t0 t1, that would give you some function. the question is for example, in this case, which would be the 'terms missing' in terms of the previous functions
13:48:09 <overscore> jmcarthur: windows
13:48:17 <Bfig_> yes, that far i understand, but what you write to the right might end up in g or f
13:48:48 <Bfig_> in the previous example i think it would mean the same as this: f ( g, t0) t1, type error
13:49:12 <benmachine> Bfig_: h = f g t0 t1 -- gives three arguments to f
13:49:12 <dmwit> "what you write to the right might end up in g or f"
13:49:15 <dmwit> No, this is incorrect.
13:49:20 <Bfig_> not exactly as this because f doesn't need a tuple but two arguments, but my point is the two things go to f and one is lost
13:49:28 <azaq23> f g t0 t1 would result in a type error since f gets three arguments, unless it returns a function, but this doesn't unify with your specification of the problem.
13:49:29 <dmwit> No.
13:49:32 <dmwit> That is not correct.
13:49:54 <dmwit> If f is a two-argument function, and the result type cannot be unified with a function type, then supplying three arguments to f is a type error.
13:50:01 <dmwit> It's not munged in any magical way.
13:50:25 <Bfig_> well, it seems pretty reasonable when talking in abstract :|
13:50:40 <dmwit> No it does not.
13:50:45 <dmwit> I do not want my compiler second-guessing me.
13:50:53 <Bfig_> the problem is when i get some weird crap like this > ((.) . foldr)
13:51:04 <dmwit> If I write f x y z, I don't want it to guess that I actually meant f (x y) z.
13:51:13 <BMeph> Bfig_: When I said that you were ignoring it, I did not mean that you were not aware of it, but that you were -> ignoring <- it.
13:51:39 <jmcarthur> overscore: i have no idea for windows. if it was an installer then you might have an entry in Add/Remove Programs or something
13:52:05 <overscore> ts ok, i found my answer
13:52:05 <jmcarthur> overscore: you might be able to tell by just running ghc --version and then seeing which version of the platform has that version of ghc
13:52:26 <azaq23> @unpl ((.) . foldr)
13:52:26 <lambdabot> (\ f b c -> foldr f (b c))
13:52:50 <Bfig_> i feel like an idiot, excuse me for a second. it's like i have to put my fp goggles and for a couple hours i don't see *shit*. then it all starts to make sense, then i take them out to do other stuff...
13:54:01 <overscore> Also, I find it kinda annoying that GHCi decides to associate to .txt files
13:54:18 <Bfig_> if you know what i mean... it is not evident how that string of operators and compositions should be interpreted easily, i have to learn the sequence that decides the final type :|
13:54:32 * BMeph thinks that overscore is giving too much credence to GHCi...
13:54:42 <monochrom> I only see GHCi associating to .hs and .lhs files (on windows)
13:54:49 <overscore> weird
13:55:08 <overscore> double-clicking causes ghci to pop up here
13:55:32 <overscore> .txt files that is
13:55:55 <monochrom> then again I have only installed the haskell platform 2010.2.0.0 from the installer, not tried the newer version
13:56:03 <siracusa> overscore: Is that for .log files, too?
13:56:06 <overscore> ghci is pretty much a front-end to ghc right?
13:56:06 <Bfig_> this is what goes through my head right now: the . is infix, so i take two operators, then i see the single . and i have to compose fold with the composition, which doesn't make a god damn bit of sense, but following, the function that comes should be something that gives you the option to foldr something (with the three parameters) and then compose it with something... or similar.
13:56:39 <Bfig_> what's unpl?
13:56:50 <monochrom> depends on what "front-end" means. ghci is an repl, shares most code with ghc.
13:56:50 <hpc> @pl \x -> x
13:56:50 <lambdabot> id
13:56:52 <hpc> @unpl id
13:56:53 <lambdabot> (\ a -> a)
13:56:58 <overscore> monochrom: yeah this was using 2010.2 too
13:57:16 <Zao> Bfig_: @pl makes things more pointless. @unpl is the "reverse"
13:57:25 <Bfig_> lol
13:57:33 <Zao> @pl \x y z -> z x y
13:57:33 <lambdabot> flip . flip id
13:57:42 <Bfig_> lmao
13:57:43 <hpc> :t flip id
13:57:44 <lambdabot> forall a b. a -> (a -> b) -> b
13:58:02 <Zao> Bfig_: In this context, a "point" is something akin to a named variable.
13:58:03 <Zao> Or something.
13:58:12 <hpc> :t flip ($)
13:58:13 <lambdabot> forall a b. a -> (a -> b) -> b
13:58:44 <BMeph> Bfig_: Are you a Factor user, by any chance? 
13:58:58 <Bfig_> what's factor?
13:59:07 <azaq23> f . foldr is a function f composed with foldr "on the first argument". so if that is executed, the first argument is foldr with one argument applied.
13:59:15 <hpc> :t f . foldr
13:59:15 <alpounet> Bfig_, a programming language
13:59:15 <lambdabot> forall b a b1. (Show (b1 -> [a] -> b1), SimpleReflect.FromExpr b) => (a -> b1 -> b1) -> b
13:59:29 <hpc> :t ?f . foldr
13:59:30 <lambdabot> forall b a b1. (?f::(b1 -> [a] -> b1) -> b) => (a -> b1 -> b1) -> b
13:59:49 <BMeph> Bfig_: I'll take that as a "No." :)  Factor is a programming language, kind of like Forth meets Common Lisp. 
14:01:33 <azaq23> (.) . foldr = \x -> (.) (foldr x). foldr x is foldr with one argument applied. then \x y -> foldr x . y is the next step. Then \x y z -> foldr x (y z). this is function which now only takes the last argument as the argument to foldr.
14:01:40 <azaq23> :t ((.) . foldr)
14:01:41 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1 -> a -> a) -> f a -> f ([a1] -> a)
14:02:33 <Bfig_> i don't know Lisp or Forth either :p
14:03:39 <Bfig_> i'm a java/C(++)/pascal/modula2/assembly dude... zero fp, zero high level :p
14:03:59 <BMeph> :t (Prelude..) Prelude.. foldr
14:03:59 <lambdabot> forall b a a1. (a1 -> b -> b) -> (a -> b) -> a -> [a1] -> b
14:04:00 <overscore> i know english, french and C(++) :)
14:04:05 <Bfig_> there's just too much magick to this game already :)
14:04:47 <overscore> oh, verilog too.
14:05:44 <dmwit> Bfig_: When you see ((.) . foldr), you can desugar it, if you think it would help.
14:06:00 <dmwit> Bfig_: That desugars to calling the (.) function with arguments (.) and foldr (in that order).
14:06:03 <dmwit> So:
14:06:04 <dmwit> ?src (.)
14:06:04 <lambdabot> (f . g) x = f (g x)
14:06:04 <lambdabot> NB: In lambdabot,  (.) = fmap
14:06:22 <dmwit> (.) f g x = f (g x) -- desugared
14:06:27 <BMeph> :t (Prelude..) 
14:06:27 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:06:55 <applicative> :t (.)
14:06:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:06:57 <dmwit> (.) (.) foldr = \f -> (.) (foldr f)
14:07:32 <dmwit> (.) (.) foldr = \f -> (.) (foldr f) = \f g x -> (foldr f) (g x) = \f g x -> foldr f (g x)
14:08:06 <Bfig_> so i first should take away the infix, and i get that, then start applying the arguments as if they were filling up all the arguments from left to right?
14:08:18 <jmcarthur> @unpl ((.) . foldr)
14:08:18 <lambdabot> (\ f b c -> foldr f (b c))
14:08:32 <dmwit> Bfig_: Yes. That is what the semantics does, and it is what you should do, too.
14:08:34 * BMeph would annotate dmwit's example as: "-> (.) <- (.) (foldr) = \f -> (.) (foldr f)".
14:09:25 <Bfig_> let's see: (.) . foldr => (.) (.) foldr => \x y z (.) ((.), foldr( x, y, z)) ?
14:09:44 <dmwit> eh?
14:09:45 <hpc> Bfig_: no; (x,y,z) is a tuple
14:09:53 <monochrom> BMeph: are you going for a "-> (.) <-" just to be cute? :)
14:10:02 <Bfig_> in classic notation
14:10:35 <dmwit> (.) . foldr => (.) (.) foldr => (\f g x -> f (g x)) (.) foldr => (\g x -> (.) (g x)) foldr => (\x -> (.) (foldr x))
14:10:49 <dmwit> I have no idea what "classic notation" is.
14:11:08 <jmcarthur> uncurried is what i think Bfig_ is going for
14:11:21 <Bfig_> classic as in not haskell, ie, f(x) = ...
14:11:29 <BMeph> monochrom: No "cute", so much as emphasizing which "(.)" is the function, and which is the argument.
14:11:37 <BMeph> *Not
14:13:17 <dmwit> Bfig_: Let's start with "(.) . foldr".
14:13:53 <Bfig_> ok
14:13:59 <sdrodge> I'm using record syntax with data constructors and using the same names for fields resulting in errors, are the fields inside different data constructors really in the same scope?
14:14:14 <dmwit> Bfig_: You already know the first step, which is taking infix stuff to prefix. So that's "(.) (.) foldr", where the first "(.)" is the infix operator from before.
14:14:37 <BMeph> sdrooge: Yes. Next question? ;)
14:14:42 <Bfig_> yes
14:14:52 <dmwit> Bfig_: Now, we've come to a place where we don't have a lambda in the head position (i.e. at the front of the application), so we have to look at the definition of (.).
14:14:59 <TomMD> Why am I not getting the exception I expect where I expect it? http://hpaste.org/45094/missing_exceptions
14:15:08 <dmwit> Bfig_: The definition of (.) is: (.) = \f g x -> f (g x).
14:15:32 <TomMD> I wanted and thought that "gcTVar" would get the IndefiniteBlock exception, but that isn't happening.
14:15:33 <Bfig_> ok
14:15:40 <dmwit> Bfig_: So, we replace the first (.) with that definition: "(\f g x -> f (g x)) (.) foldr".
14:15:47 <TomMD> Am I just doing something stupid (likely)
14:15:56 <dmwit> Now we have the application of a lambda to an expression, so we can do what's called "beta reduction".
14:16:03 <sdrodge> BMeph: is there a good reason why?
14:16:19 <dmwit> This involves taking the first variable of the lambda and replacing it everywhere with the first argument we're applying it to.
14:16:41 <dmwit> So, we'll replace "f" with "(.)" everywhere, since "(.)" is the first argument to the lambda.
14:16:55 <dmwit> This gives us "(\g x -> (.) (g x)) foldr".
14:17:09 <dmwit> That step is the interesting one, so please tell me if it didn't make sense or you can't see how to do that step yourself.
14:17:38 <Bfig_> yes, like quantifying the variable the other way round
14:18:02 <dmwit> (Schematically, we take "(\variable -> body) argument" to just "body", but with "variable" replaced by "argument" everywhere.)
14:18:28 <dmwit> Alright, then the next step is very similar: another beta reduction. How should it look?
14:18:54 <BMeph> sdrooge: Because Haskell doesn't use the "getters and setters" philosophy. ;)
14:19:05 <Bfig_> take foldr and remove the first g, then replace the second?
14:19:15 <Bfig_> ie, \x -> (.) (foldr x ) 
14:19:32 <dmwit> Perfect.
14:19:51 <dmwit> Now, in most languages, we'd stop there, because we have a top-level lambda that's not part of an application.
14:20:40 <dmwit> But see if you can outline how evaluation would go if we started with the body of that lambda.
14:20:51 <dmwit> So the term we're trying to evaluate is "(.) (foldr x)".
14:21:00 <sdrodge> BMeph: it's sdrodge btw, not sdrooge (hard for me to pick out your answers in the stream) can you explain a bit further?
14:21:11 <BMeph> sdrodge: Sorry about messing up your handle. :)
14:21:22 <Bfig_> dmwit, so you keep the free variables that appear in the way as the input for your final lambda?
14:21:31 <Bfig_> damn this is so easy to see like this
14:21:36 <dmwit> sdrodge: There's not a deep reason. People have been complaining about the record system for years.
14:22:08 <Bfig_> stupid book should start by making you understand the parsing trees instead of wasting your time give you more and more syntax
14:22:20 <dmwit> sdrodge: There's a few suggested alternatives. Perhaps some upcoming revision of Haskell' will incorporate one of them.
14:22:48 <dmwit> Bfig_: If you want a really great book on this stuff, I can strongly recommend Types and Programming Languages by Benjamin Pierce.
14:23:09 <sdrodge> dmwit: to what extent are they in the same scope, if I use the same field names in records in different files and then import, will I have problems?
14:23:19 <dmwit> sdrodge: Yes.
14:23:31 <BMeph> sdrodge: Haskell record format is kind of "the worst of both worlds"; everyone wants something better, but cannot agree on which better alternate to choose. :\
14:23:36 <dmwit> sdrodge: They are top-level names. If you want to avoid problems, you must use separate modules and qualified names.
14:23:58 <Bfig_> dmwit, possibly for later reading, right now i have to become competent by tuesday :p...
14:24:01 <sdrodge> dmwit, BMeph: thanks very much for the help.
14:24:18 <Bfig_> so i'll just practice and see what happens. tell you how it goes in a while
14:24:28 <BMeph> sdrodge: (Eh, just listen to dmwit, he's got the good poop on the issue. )
14:24:50 <hpc> you will not find better poop anywhere else ;)
14:25:17 * BMeph thinks dmwit's poop is the real shit...so-to-speak. ;)
14:25:27 <dmwit> =D
14:25:44 <sdrodge> lol
14:26:59 <hpc> he gets to the bottom of the issue
14:27:01 <hpc> :P
14:27:11 <overscore> chortle
14:27:42 <lispy> Stop talking about poop and go reply to my email on haskell-cafe :)
14:28:01 <lispy> (just kidding, I'm not that demanding....today)
14:28:15 <lispy> how is code going today?
14:28:26 <dmwit> Argh, I can't keep up with haskell-cafe.
14:28:52 <hpc> dmwit: digests are your friend
14:28:58 <lispy> dmwit: Yeah, I was unsubscribbed for a few months and it was nice.  But, I needed help with some things so I'm back on the "mark as read" treadmill
14:29:09 <hpc> two emails a day keeps the headaches away
14:30:19 <lispy> I want to create an unboxed array of C types, but what I discovered is that the instances to do so are missing
14:30:38 <lispy> it seems like a reasonable thing (to me anyway) to add to Base
14:31:29 <lispy> similarly for Data.Vector.  But, I had a harder time figuring out what is going on there.  Like, maybe you can use type families to get the same thing?
14:31:59 <dmwit> I thought unboxed arrays just needed a Storable instance.
14:33:02 <lispy> dmwit: Data.Vector has an interface for Storable, but I don't think Data.Array.* has that
14:33:10 <dmwit> Ah, bummer.
14:33:32 <lispy> I don't know how the storable stuff in Data.Vector compares with unboxed though
14:34:17 <lispy> The thing about going via storable is that I think you have to use IO
14:34:26 <lispy> where as the unboxed stuff can use ST
14:35:02 <lispy> and what is the license of this code? http://hackage.haskell.org/packages/archive/FTGL/1.333/doc/html/Graphics-Rendering-FTGL.html
14:35:10 <lispy> The cabal file says BSD but the docs say LGPL
14:35:30 <hpc> i would say whatever is at the top of the source files
14:35:45 <hpc> both of those need the license body in the source files
14:36:36 <dmwit> Oh. Well, Storable should totally be updated for use with ST.
14:36:48 <lispy> dmwit: I'll go check on that. I could be wrong.
14:37:06 <lispy> ah, yeah all IO
14:37:06 <lispy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html
14:37:13 <hpc> lispy: --   * License: GNU LGPL 
14:37:40 <dmwit> I didn't mean "Storable can use ST today", I meant, "somebody should make a new Storable class that can be used with ST".
14:38:42 <danharaj_> What's the easiest way to convert between Floating types?
14:38:45 <lispy> dmwit: I just wanted to make sure I was right that the storable we have now requires IO.  But, it could be rewritten to provide Foreign.Storable.IO and Foreign.Storable.ST without any interesting changes, right?
14:38:51 <lispy> danharaj_: realToFrac
14:39:03 <jmcarthur> @src realToFrace
14:39:03 <lambdabot> Source not found. Do you think like you type?
14:39:05 <jmcarthur> @src realToFrac
14:39:05 <lambdabot> realToFrac = fromRational . toRational
14:39:06 <lispy> danharaj_: depending on the types that conversion can be very expensive.
14:39:18 <lispy> that default definition is terrible
14:39:22 <danharaj_> I wonder if the OpenGL bindings have a cheap Float -> GLfloat
14:39:22 <jmcarthur> yeah it's unfortunate
14:39:28 <dmwit> lispy: Yes, or even "class Storable m a where", so that "m" could be instantiated at ST or IO in one all-encompassing class.
14:39:44 <jmcarthur> they do not :(
14:39:45 <lispy> danharaj: no they don't.  Andy Gill wrote a nice RULES for that though.  Hang on and I'll get you a link
14:39:58 <Makoryu> danharaj: Hoogling yields... uh.... unsafeCoerce.
14:39:59 <Makoryu> :V
14:39:59 <overscore> @src length
14:39:59 <lambdabot> Source not found. Wrong!  You cheating scum!
14:40:12 <lispy> danharaj: http://www.haskell.org/pipermail/haskell-cafe/2011-March/090511.html
14:40:14 <jmcarthur> of course the RULES has to go *in* the opengl lib
14:40:22 <lispy> danharaj: on many platforms you can use unsafeCoerce
14:41:04 <lispy> jmcarthur: yeah, that's a big reason why I've been trying to contact Sven and offering to be opengl maintainer if he's gone
14:41:20 <lispy> jmcarthur: there are little tweaks to openglraw that would help performance.  This is one of them
14:41:28 <jmcarthur> yeah
14:42:20 <dmwit> overscore: length = sum . map (const 1) -- ;-)
14:42:26 <danharaj> :o
14:42:42 <danharaj> so I have to modify the source of the bindings and then recompile?
14:42:52 <lispy> dmwit: making a change like that would be very incompatible though, wouldn't it?
14:43:19 <dmwit> Sorry, a change like what?
14:43:26 <Bfig_> dmwit, how do you use the 'foldr x' element you get? it's a function that takes two variables, right?
14:43:28 <lispy> danharaj: Yes, or use glFloatToFloat :: GLfloat -> Float; glFloatToFloat = Unsafe.Coerce.unsafeCoerce
14:43:54 <dmwit> Bfig_: Yes, exactly, it's a function taking two arguments. So you use it by supplying two arguments.
14:44:15 <danharaj> lispy: thanks. I'll decide on what to do when my project gets out of prototype/screw around phase :)
14:44:26 <lispy> danharaj: this problem was reported quite sometime ago, but I guess the maintainer of the opengl binding didn't notice.  I've been trying to get this updated for a week or two :)
14:44:26 <danharaj> I wish the opengl bindings got more community love.
14:44:45 <lispy> we're on it :)
14:44:47 <Makoryu> Do they use immediate mode under the hood?
14:44:58 <lispy> Makoryu: if you want them too.
14:45:11 <lispy> Makoryu: but they support opengl 3.2 also
14:45:13 <Bfig_> dmwit, so when i have no elements to the right i have my expression right, all the 'free lambdas' from left to right are my parameters, and the types are the ones that you need to make the semantics fit?
14:45:14 <djahandarie> mauke, you should update /stuff/javascript/unicode to the unicode 6 stuff
14:45:36 <Makoryu> I never learned them very well. I don't do graphics stuff in Haskell
14:45:37 * Makoryu shrugs
14:45:42 <jmcarthur> Makoryu: it's not really under the hood. it exposes a pretty raw interface
14:45:52 <Makoryu> OK
14:45:56 <dmwit> Bfig_: What?
14:45:58 <mauke> djahandarie: is that in UCS2?
14:46:31 <Bfig_> dmwit, give me a second i'll write what i'm trying and pastebin it and show. give me about 10 mins to sort it out neatly
14:46:34 <djahandarie> mauke, huh?
14:46:40 <overscore> i'd like the opengl bindings get updated for OpenglES
14:46:40 <lispy> jmcarthur: I think that the OpenGLRaw should expose all the modules too.   Even if some are marked as "use at your own risk."  bytestring does this and it makes it really nice for people.
14:46:44 <jmcarthur> i much prefer OpenGLRaw to OpenGL. i would like a higher level interface, but OpenGL seems to only take it half way, and it also leaves things out, changes arbitrary things, etc.
14:47:26 <jmcarthur> lispy: i also think that all the extension-specific modules should rexport everything provided by the extension even if the core modules already export them
14:47:27 <lispy> jmcarthur: yeah. I 've been meaning to start a replacement to OpenGL.  Like, OpenGLRaw-painless or something
14:47:33 <danharaj> Oh, and if someone could figure out how to build the GLUT bindings with freeglut on windows, I would love that. The freshest tutorial is several years old and doesn't work :\
14:47:50 <lispy> overscore: opengl es should probably be a separate package as it will support less
14:47:55 <jmcarthur> lispy: i found the export thing to be an issue with using my OpenGLRaw21 package as i had originally intended
14:47:57 <danharaj> Hell I would contribute to a project to bring Top Class opengl support to Haskell.
14:48:25 <overscore> lispy: well no doubt they share code..
14:48:29 <lispy> danharaj: I've been using GLFW-b.  I like it better than glut and no extra libraries needed.
14:48:56 <danharaj> lispy: I'll look into it.
14:49:32 <jmcarthur> lispy: i have several early-stage opengl packages in my src dir, each of which ended up having properties i ended up not liking
14:49:43 <jmcarthur> wrappers around OpenGLRaw, mainly
14:50:06 <lispy> danharaj: I have some code examples here: https://github.com/dagit/nehe-tuts  lesson12 doesn't compile at the moment, but I was going to fix that later today
14:50:27 <danharaj> Ah, you're porting nehe's tutorials? Awesome idea.
14:50:47 <lispy> danharaj: yeah, I did it back in 2005, and then this month I've been modernizing them
14:51:05 <lispy> I only made it till you need fonts and then I gave up :)
14:51:13 <danharaj> lispy: If you ever work on a large-scale modernization of opengl support, I'd like to help out :)
14:51:31 <djahandarie> danharaj, was it you who wrote a DSL for SQL?
14:51:40 <lispy> Finding a good opengl font library in Haskell is not as easy as it should be.  I'm thinking of attempting to write an openglraw-printf package
14:51:56 <jmcarthur> haha i was thinking danharaj was djahandarie for a minute there
14:52:06 <djahandarie> -_-
14:52:18 <lispy> danharaj: Cool.  I've already emailed the libraries@ list suggesting that I can take over the opengl bindings if the current maintainer is gone and no one objects
14:52:32 <ddarius> djahandarie: You hash to the same color in XChat.
14:53:16 <danharaj> djahandarie: no. I haven't contributed anything useful to anyone... yet :p
14:53:21 <djahandarie> Hmm
14:53:24 <djahandarie> Oh, it was dankna 
14:53:48 <djahandarie> http://hackage.haskell.org/package/language-sqlite
14:53:57 * BMeph I thought djahandarie was geheimdienst, or at least, that was shachaf's theory... ;)
14:54:26 * djahandarie sighs
14:54:29 <lispy> danharaj: I suspect I can use the nehe lesson13 code (and OS specific translations) to figure out a platform independent font wrapper and then give it a Text.Printf style interface.  I think that would satisfy most simple needs to do fonts in opengl for haskell folks.
14:54:33 <danharaj> What I really hate is how with the bindings I'm using now "Color3 1.0 1.0 1.0" for example, is ambiguous, and specifying the types is a pain -_-
14:54:49 <djahandarie> @tell dankna Do you have any example usages of your language-sqlite lib?
14:54:49 <lambdabot> Consider it noted.
14:55:03 <ddarius> If those are the ones I think they are, there are functions which have more specific types.
14:55:05 <lispy> danharaj: yes, the OpenGLRaw bindings don't have this issue because they have glColor3f as a function
14:55:20 <danharaj> I might just use OpenGLRaw then.
14:55:24 <danharaj> And the library you suggested earlier.
14:55:39 <lispy> danharaj: yeah, the code examples I linked on github use openglraw and glfw-b
14:56:18 <Bfig_> dmwit, http://pastebin.com/1Wuxnn81
14:56:32 <lispy> danharaj: one difference from glut though, is that you can't call swapBuffers/pollEvents/waitEvents inside an event handler.  That way leads to infinite events.  But, otherwise I like it
14:59:04 <Bfig_> dmwit, mmm i think i got wrong the g(y) part... it should go inside the foldr at line 6
14:59:05 <dmwit> Bfig_: Looks good, though the syntax is decidedly non-Haskell. =)
14:59:14 <Bfig_> so is that the proper way to parse it?
14:59:24 <dmwit> Line 6 looks fine.
14:59:41 <dmwit> If anything, my gripe would be with line 7.
15:00:08 <Bfig_> because i interpret foldr(x) w z as foldr(x, w, z) ?
15:00:10 <dmwit> \w z -> ... should be (\w z a -> foldr(w,z,a))(x)(g(y))
15:00:48 <dmwit> i.e. if you're going to eta-expand foldr, consistency with the rest of the derivation says you should eta-expand all three arguments, not just two of them.
15:00:59 <Bfig_> i dunno, wouldn't that be going 'backwards' in some way? isn't foldr(x) already a two parameter function per se?
15:01:22 <Bfig_> so that's calling eta expand? the appearance of a nested lambda?
15:01:34 <dmwit> foldr x is a two-argument function, and so is (\w z a -> foldr w z a) x.
15:01:46 <dmwit> Because (\w z a -> foldr w z a) = foldr.
15:02:10 <dmwit> eta-expansion takes "term" to "\x -> term x".
15:02:18 <dmwit> eta-reduction is the opposite, of course.
15:02:28 <Bfig_> but you could say with a similarly valid chain of reasoning (\w z -> (foldr(x))(w, z) ) = foldr(x)
15:02:39 <dmwit> Alright, I've got to run, but keep asking questions, people here will answer.
15:02:50 <dmwit> Bfig_: Yes, you can say that.
15:02:50 <Bfig_> thanks for all the help, you clarified this a *lot*
15:03:18 <Bfig_> now i can parse like a compiler without caring what it means p
15:03:19 <Bfig_> :p
15:03:25 <jmcarthur> talking about the number of arguments a function takes in haskell is kind of non-sensical, honestly. all functions in haskell are unary
15:04:52 <jmcarthur> like, you can fudge your wording a bit, but actually arguing about it isn't going to go far :)
15:05:31 <geheimdienst> > fudge wording
15:05:32 <lambdabot>   Not in scope: `fudge'Not in scope: `wording'
15:05:56 <Teslah> If I've got a state monad, and I'm lugging around the tuple (Foo, Bar) as the state, and I want to add a type to that tuple state so that it's (Foo, Bar, Bool). How could I do this without changing every function that unpacks that tuple in the program? 
15:06:12 <Teslah> I asked this yesterday and was told it's bad program design, but they didn't have time to elaborate
15:06:49 <lispy> Teslah: A better way to do it is to define a data type to hold your state
15:06:53 <Saizan> Teslah: it'd be easy if you used a custom record type, then you wouldn't have to do anything if you always accessed the fields with record syntax
15:07:12 <lispy> Teslah: like, data MyApp = { foo :: Foo, bar :: Bar, blah :: Bool }
15:07:13 <Teslah> lispy: yes, I usually do that, but that doesn't solve the problem of unpacking
15:07:29 <Saizan> it does
15:07:32 <lispy> (modulo my obvious syntax error there)
15:07:55 <Teslah> oh, wait, I see now
15:08:18 <Teslah> I thought you meant type synonyms. Wow, I can't believe how obvious the answer was
15:08:21 <Saizan> you can pattern match like f MyApp{foo = x, bar = y} = .. <- here the presence or not of blah in the record doesn't matter
15:08:21 <Teslah> Thanks!
15:09:03 <lispy> record types are really nice at times
15:09:09 <geheimdienst> but what he does lose is «f (MyThing _ _)» pattern matching, right?
15:09:28 <geheimdienst> a data doesn't allow extending MyThing at that place
15:09:43 <Teslah> yeah, that's a bit of an annoyance, I just though of that. 
15:09:53 <Saizan> you can use it if you want, but then you lose the advantage 
15:10:06 <geheimdienst> i see. thanks for the confirmation :)
15:10:40 <lispy> You can also use f (Blah {}), with any data type
15:11:05 <lispy> > let f (Just {}) = True; f Nothing = False in f (Just 'a')
15:11:05 <lambdabot>   True
15:11:26 <lispy> then if someone adds a new field to Just that definition of isJust would continue to work
15:12:48 <Saizan> and he'd also get stabbed by ninjas
15:12:54 <Teslah> ):
15:13:11 <lispy> Saizan: you don't like that form of pattern matching?  I use it sometimes :)
15:14:37 <Saizan> lispy: it was about adding a new field to Just :)
15:15:16 <Saizan> Foo{} is noce
15:15:18 <Saizan> *nice
15:15:19 <danharaj> lispy: what's the difference between glfw and glfw-b?
15:15:54 <lispy> danharaj: I have a link for that too :) https://github.com/bsl/GLFW-b/blob/master/README.md
15:16:01 <danharaj> heh
15:17:38 <lispy> danharaj: GLFW-b is also using the latest version of GLFW
15:18:01 <lispy> danharaj: I wrote this article recently to help people pick between the options: http://blog.codersbase.com/2011/03/picking-gui-library-to-use-with-opengl.html
15:20:52 <danharaj> oh dear, why would you even list win32 :p
15:21:24 <lispy> danharaj: completeness :)
15:22:10 <danharaj> useful stuff :p
15:23:08 <lispy> danharaj: You have good timing on asking your question.  I've been revisiting all these same things lately.  I'm glad I wrote down what I learned so that you can benefit :)
15:24:17 <danharaj> Cosmic coincidences.
15:25:27 <danharaj> oh, glfw can shut down without exiting. That's nice. I couldn't get GLUT to exit without exiting ghci.
15:27:27 <lispy> danharaj: it still uses atexit under the hood, but it does seem to be friendlier about shutdown
15:27:49 <danharaj> lispy: ah I'll see. Something that plays nicely with ghci would be a godsend.
15:50:54 <dankna> @tell djahandarie I don't really have any example uses of it, no, although if you look at the source repo there's a very trivial example in there.  I'm flattered that people are paying attention to it and would love to answer any questions you have personally, however.
15:50:55 <lambdabot> Consider it noted.
15:52:29 <sbahra> @ask Cale Can lambdabot join #concurrencykit?
15:52:29 <lambdabot> Consider it noted.
15:52:42 <mauke> @admin + mauke
15:52:43 <lambdabot> Not enough privileges
15:53:05 <mauke> @join #concurrencykit
15:53:16 <sbahra> Thank you mauke.
15:53:27 <djahandarie> dankna, ah
15:53:44 <hpc> @tell Cale nvm, mauke invited λbot
15:53:44 <lambdabot> Consider it noted.
15:53:56 <dankna> what did you want to use it for?
15:53:56 <lambdabot> dankna: You have 1 new message. '/msg lambdabot @messages' to read it.
15:53:57 <djahandarie> I was just looking for a usage to see how elegant the code ended up looking
15:54:01 <mauke> hpc: that's not permanent
15:54:11 <hpc> oh
15:54:21 <dankna> ah, yeah.  fair enough.  I don't actually view it as a DSL so much as just an AST.
15:54:44 <dankna> while it could absolutely be used to construct queries rather than embedding them as text in Haskell code,
15:54:56 <dankna> its primary design goal was more to do interesting /transformations/ on queries
15:55:27 <dankna> like take a create table statement and construct a list of statements that copy the data in that table, with transformations, to a new one
15:55:29 <dankna> or whatever
15:55:36 <neophyte> Is anyone familiar with turing machines
15:55:37 <djahandarie> Interesting
15:55:44 <dankna> or go from create table to drop table, or implement alter table as a higher-level abstraction
15:55:53 <dankna> (since sqlite doesn't support full alter table)
15:56:02 <neophyte> I had a question about constructing a general outline for a deciding turing machine
15:56:10 <neophyte> for deciding a language
15:56:19 <djahandarie> How much type safety have you been able to inject into SQL queries?
15:56:25 <neophyte> L={ww| w in (0+1)*} 
15:56:30 <djahandarie> As in, disallowing malformed things to even be created
15:57:02 <dankna> well, I believe I managed 100% safety on the actual SQL syntax, but 0% on SQL values, because SQL is not inherently type-safe
15:57:06 <gronliz> neophyte: Turing was a homosexual so to better undersand Turing machines you must experiment with homosexuality.
15:57:24 <neophyte> gronliz, true that he was a homosexual, false on the second statement
15:57:24 <djahandarie> neophyte, heh, someone was just asking a question about that language last night
15:57:27 <dankna> sqlite, in particular, is fully dynamically typed
15:57:31 <neophyte> djahandarie, really?
15:57:34 <djahandarie> Yes.
15:57:40 <neophyte> I think I have an algorithm, but I wanted to check it
15:57:42 <gronliz> neophyte: Oh quite to the contrary
15:57:42 <djahandarie> UNSW?
15:57:44 <c_wraith> neophyte: well, he was asking about the next question, not the one you're on.
15:57:49 <djahandarie> Yeah, lol
15:58:18 <hpc> dankna: perhaps have a typed structure for tables, and make the programmer worry about making that match the types in the database
15:58:32 <neophyte> c_wraith which did he ask
15:58:44 <dankna> hpc: could you elaborate on that?
15:58:44 <c_wraith> neophyte: about proving the complement of that language is context-free
15:58:44 <hpc> then you at least only lose type safety in one place
15:59:27 <neophyte> c_wraith, if i explained my general outline to you could you tell me if it'd work
15:59:32 <neophyte> it isn't very long description
15:59:47 * djahandarie slowly sneaks out of the room
15:59:55 <dankna> lol
15:59:56 <c_wraith> well, I'm not gonna be around for much longer.  But someone would probably be willing to help
16:00:11 <gronliz> I have already explained what he must do
16:00:19 <hpc> dankna: so an insert would look something like insertRow :: Data Foo Bar -> Table Foo Bar -> IO ()
16:00:55 <Rotaerk> insertRowInto :: Table Foo Bar -> Data Foo Bar -> IO ()
16:01:39 <dankna> oh, yes, hmmm
16:02:00 <neophyte> c_wraith, not sure who else to ask :/
16:02:10 <neophyte> But If you want I can be brief
16:02:13 <benmachine> neophyte: just ask, and hope
16:02:32 <hpc> dankna: even if the internals of Data and Table are totally independent of Foo and Bar, you can give one type to each table
16:02:37 <dankna> right, I see
16:02:56 <hpc> could be interesting
16:03:29 <dankna> yeah, no, it's a good idea.
16:04:43 <hpc> my website is currently just throwing around [SqlValue] everywhere
16:05:04 <dankna> yeah, mine too
16:06:00 <hpc> also, it could be interesting to add better support for arbitrary structures in text fields
16:06:15 <hpc> like, as long as something is Show a, Read a => a, you can store it in a TEXT field
16:07:23 <ion> You could have a single database with a single table with a single row with a single column that contains a huge text field with everything serialized.
16:07:43 <hpc> hehe, wouldn't that be fun
16:08:13 <hpc> or better, encode all information in the column names
16:08:16 <ion> I’m sure there’s an ENTERPRISE application out there that does that.
16:08:30 <hpc> and all your queries become "DESCRIBE ?" <= "SELECT * FROM ?"
16:09:10 <lispy> danharaj: I just pushed a fix for lesson12.  It should compile/run now
16:09:15 <hpc> obviously you can't put symbols in column names, so you have to base64 encode it
16:09:32 <mauke> can I z-encode them instead?
16:09:38 <dankna> I think that's best done as a higher layer, not part of language-sqlite
16:09:39 <hpc> sure, why not?
16:09:51 <dankna> I have something along those lines, actually, as part of something else
16:09:52 <hpc> dankna: lies! build it into the linux kernel
16:09:56 <hpc> :D
16:09:56 <dankna> hahaha
16:10:40 <mauke> preflex: zenc "SELECT * FROM ?"
16:10:40 <preflex>  z22USELECTz20Uztz20UFROMz20Uz3fUz22U
16:11:09 <hpc> preflex: zenc "snooze"
16:11:10 <preflex>  z22Usnoozzez22U
16:14:50 <benmachine> preflex: zenc zenc
16:14:51 <preflex>  zzenc
16:15:20 <mauke> preflex: zenc benmachine!~bm380@tremulous/developer/benmachine
16:15:20 <preflex>  benmachineznz7eUbm380z40Utremulouszsdeveloperzsbenmachine
16:16:03 <lispy> zenc?
16:16:07 <lispy> z encode?
16:16:41 <benmachine> preflex: zdec mauke
16:16:41 <preflex>  mauke
16:17:06 <benmachine> preflex: zdec zdec
16:17:10 <preflex>  $ec
16:17:21 <benmachine> oh I thought zd = .
16:17:31 * benmachine forgets these things
16:17:34 <mauke> preflex: zenc .
16:17:34 <preflex>  zi
16:17:38 <benmachine> oic
16:17:56 <danharaj> lispy: interesting thing. tutorial #4 crashes in ghci (fine if compiled), #3 works in ghci. I thought you'd find that curious.
16:18:09 <lispy> danharaj: Yeah, I'll take a look
16:18:41 <danharaj> I think it might be the threadDelay?
16:18:55 <lispy> danharaj: when does it crash for you?
16:19:07 <osoleve> @hoogle id
16:19:07 <lambdabot> Prelude id :: a -> a
16:19:07 <lambdabot> Control.Category id :: Category cat => cat a a
16:19:07 <lambdabot> Data.Function id :: a -> a
16:19:08 <lispy> I'm on windows7 at the moment, and ghc7.0.2
16:19:10 <ion> preflex: zenc "\xd"
16:19:11 <preflex>  z22Uzrxdz22U
16:19:23 <danharaj> It crashes immediately without even painting a frame.
16:19:29 <lispy> danharaj: hmm
16:19:33 <danharaj> When I remove the threadDelay in the loop, it doesn't crash.
16:19:39 <lispy> danharaj: 3 and 4 run identically for me
16:19:41 <lispy> ah
16:19:44 <lispy> Okay.  I'll fix that up
16:19:54 <lispy> threadDelay isn't needed, but in the first few examples I didn't understand GLFW well
16:20:29 <ion> preflex: zenc 
16:21:18 <mauke> ion: I think that's getting filtered because whitespace
16:21:51 <osoleve> preflex: zenc bananasfoster
16:21:51 <preflex>  z2Ubananasz0fUfoster
16:23:27 <mauke> preflex: zenc X
16:23:27 <preflex>  X
16:23:35 <mauke> preflex: zenc XY
16:23:36 <preflex>  Xz0bUY
16:23:57 <lispy> oh, I know what that encoding is now
16:24:05 <lispy> That's the encoding GHC uses to mangle names
16:24:35 <dmwit> Yes.
16:25:33 * hackagebot xmobar 0.13 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.13 (JoseAntonioOrtegaRuiz)
16:25:49 <mauke> preflex: zenc Prelude.[Data.ByteString.ByteString]
16:25:49 <preflex>  PreludeziZMDataziByteStringziByteStringZN
16:26:10 <lispy> danharaj: I just pushed a fix
16:26:24 <lispy> danharaj: I couldn't reproduce the crash, but based on what you said that should fix things
16:26:46 <danharaj> k. Strange that you didn't crash, it may be because I'm on an earlier version of GHC.
16:26:51 <TTimo> http://hpaste.org/45095/extending_a_type <- does this work? e.g. is it a viable way to extend a type with more values? 
16:27:30 <lispy> danharaj: now I'm off to test on linux/osx and if that's good then I'm going to push a new release to hackage.
16:27:33 * hackagebot seqloc 0.1 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.1 (NicholasIngolia)
16:28:13 <danharaj> cheers.
16:28:38 <siracusa> TTimo: No. You'd have to wrap BaseType into a new constructor, like data ExtendedType = Base BaseType | ...
16:30:19 <TTimo> siracusa: ouch. thanks, was hoping for a better way .. 
16:37:00 <Rc43> How can i handle errors?
16:37:12 <Rc43> e.g. doesNotExistError
16:37:20 <FauxFaux> Maybe.
16:37:22 <Rc43> (by openFile)
16:37:37 <mauke> :t catch
16:37:38 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
16:37:58 <Rc43> catch isn't standard as i think
16:38:01 <Rc43> or not?
16:38:13 <mauke> define "standard"
16:38:24 <Rc43> "from the box"
16:38:29 <mauke> what
16:38:39 <monochrom> catch is both from the box and in haskell 98
16:38:40 <sipa> what box?
16:39:04 <Rc43> it is idiom
16:39:26 <mauke> I recommend using english idioms in english
16:39:48 <monochrom> methinks you should read the docs fully 3 times before judging what isn't standard.
16:40:18 <monochrom> and yes the box comes with docs too
16:40:19 <Eduard_Munteanu> You mean "out of the box" I think.
16:40:48 <mauke> outside the box
16:41:03 <lispy> base?
16:41:08 <lispy> haskell platform?
16:41:11 <lispy> What is the box?
16:41:14 <Eduard_Munteanu> Mm, no, I mean something "working out of the box"
16:41:35 <mauke> realize the truth. there is no box.
16:41:39 <Eduard_Munteanu> :)
16:41:50 <lispy> think out side the box, use hackage?
16:42:02 <lispy> cabal-install is your friend
16:42:17 <monochrom> god, you don't need cabal-install for catch
16:42:26 <Eduard_Munteanu> Yeah, like lispy says... I'd think the box is either Haskell'98/2010 or the Haskell Platform.
16:42:33 <lispy> monochrom: never said you did
16:42:37 <Rc43> XD
16:42:39 <Eduard_Munteanu> (the latter as in GHC)
16:43:45 <lispy> my point is just that the ghc vanilla install and haskell platform are artificially restrictive in general for haskell stuff
16:44:01 <lispy> so much good stuff on hackage
16:44:56 <Eduard_Munteanu> Meh, Hackage / cabal-install makes it so (too?) much easy to depend on lots of external stuff.
16:45:19 <monochrom> they said that about telegrams too
16:46:03 <TTimo> is there an easy way to have some context when an exception happens .. "*** Exception: Prelude.(!!): index too large" doesn't make this particularly easy to diagnose
16:46:35 <benmachine> TTimo: the usual procedure is "don't use those functions" :)
16:46:47 <Eduard_Munteanu> I sometimes wish Haskell didn't go the Perl way, instead adopt a more conservative, C-like approach wrt this sort of stuff.
16:46:59 <TTimo> hu
16:47:02 <benmachine> TTimo: you could try something like
16:47:06 <benmachine> instead of xs !! n
16:47:09 <Eduard_Munteanu> It's not like Hackage packages get too much vetting anyway.
16:47:14 <benmachine> case drop n xs of
16:47:22 <benmachine>   y : _ -> use y
16:47:29 <Eduard_Munteanu> It's more like we have some sort of sourceforge-install, rather.
16:47:29 <benmachine>   [] -> error "!! failed"
16:47:58 <benmachine> TTimo: that would give a more informative error message
16:48:10 <benmachine> (assumign you replaced !! failed with something interesting)
16:48:50 <monochrom> you can use Control.Exception.assert
16:49:07 <Eduard_Munteanu> But yeah, I suppose it's a convenient way to make it more popular / easy-to-use.
16:49:08 <monochrom> example: assert (i < 10) (xs !! i)
16:49:09 <TTimo> ok .. that's quite a complicated answer to a simple problem though .. 
16:49:23 <monochrom> the benefit is that it tells you line numbers.
16:49:46 <TTimo> I suppose I can wrap the case statement in an operator
16:49:52 <TTimo> still avoid some boilerplate
16:50:19 <TTimo> but in general .. if an exception happens .. that's due to programming error .. I expect some notion of where it happened .. 
16:50:44 <monochrom> yeah, what I said. use assert. has line numbers.
16:51:55 <TTimo> ok .. that's where you start to have code conventions etc. and ask your project contributors to never use !! .. which begs the question .. how many such coding best practices should a starting haskell programmer be aware of
16:52:40 <benmachine> avoid !!, head, tail, fromJust, those are the usual ones
16:53:01 <osoleve> why?
16:53:21 <benmachine> osoleve: why avoid them? because if you use them wrongly it's hard to work out how or where
16:53:30 <osoleve> ah, okay, thanks
16:53:37 <benmachine> you get a perfectly generic error message
16:53:52 <Eduard_Munteanu> osoleve: they're the bane of imperative programming
16:53:54 <TTimo> how come it's possible to get slightly better information
16:54:00 <TTimo> not possilbe
16:54:07 <benmachine> TTimo: there has been some discussion about getting "stack trace"-like things, but in haskell that concept isn't straightforward
16:54:29 <TTimo> yeah .. I've notice that when attempting to step through evaluation :)
16:54:45 <TTimo> but still .. some very basic stuff to help you narrow it down ..
16:55:08 <benmachine> potentially CPP macros could do what you want, but they are a little ew
16:55:11 <Peaker> benmachine, *anything* would be better than *nothing* :)
16:55:25 <benmachine> Peaker: this is true
16:55:48 <Peaker> benmachine, I could make use of "head: empty list. in <thunk force stack here>" and I could make use of <lazy reference tree branch here>
16:56:03 <monochrom> lies are not better than nothing.
16:56:11 <benmachine> Peaker: write the GHC patch then :P
16:56:17 <Peaker> monochrom, what lies?
16:56:30 <benmachine> Peaker: as an example of an anything that is not better than nothing
16:56:36 * hackagebot string-class 0.1.5.0 - String class library  http://hackage.haskell.org/package/string-class-0.1.5.0 (ByronJohnson)
16:56:38 * hackagebot bitmaps 0.2.6.0 - Bitmap library  http://hackage.haskell.org/package/bitmaps-0.2.6.0 (ByronJohnson)
16:56:39 <Peaker> oh :-)
16:56:57 <Peaker> benmachine, someone already wrote a patch
16:57:14 * TTimo icanhas?
16:57:21 <sshc> 00:00:59  * hackagebot string-class 0.1.5.0 - String class library  http://hackage.haskell.org/package/string-class-0.1.5.0 (ByronJohnson) — string class!
16:57:30 <benmachine> Peaker: which is fair enough. sometimes confusing information is worse than no information (e.g. the "possibly incorrect indentation" comment in one of ghc's error messages, that really annoys me)
16:57:43 <benmachine> sshc: what of it?
16:58:13 <TTimo> I must say I've been impressed by ghc's compile time error messages .. beats reading C++ template errors
16:58:18 <sshc> Hah.
16:58:27 <Peaker> benmachine, I remember reading Simon Marlow said something like "After GHC's done with your code, you don't recognize any part of the stack!" to which SPJ replied (IIRC) something like: People used weird things like the voltage fluctations (or some other obscure trait) to debug systems. You don't even have to actually understand what it is, you learn the patterns
16:58:28 <sshc> benmachine: I'm merely expressing my happiness; it will be convenient to use.
16:58:43 <Peaker> TTimo, I had the "lack of Num instances" ones
16:58:52 <Peaker> @type [1] + 4
16:58:52 <lambdabot> forall t. (Num t, Num [t]) => [t]
16:59:04 <benmachine> sshc: maaaybe :P
16:59:14 <sshc> benmachine: Quiiite.  Because I already have.
16:59:22 <Peaker> > [1] + 4
16:59:23 <lambdabot>   No instance for (GHC.Num.Num [t])
16:59:23 <lambdabot>    arising from a use of `e_114' at <inte...
16:59:53 <sshc> benmachine: One nice part is being able to directly convert between any two string types efficiently, without having to first convert the string to some other type.
17:01:13 <monochrom> I support using voltage fluctations to debug ghc-generated code.
17:01:53 <shysoft> Is there a c++ parsing package like language.c ?
17:02:26 <lispy> shysoft: yes, and it was written by you and it won't appear on hackage for a little while :)
17:03:01 <benmachine> shysoft: I heard parsing C++ sucks
17:03:09 <shysoft> Has anyone used language.c by chance?
17:03:51 <lispy> I haven't personally, but I work with people who have.  I think they generally like it
17:04:11 <Peaker> shysoft, I wanted to.. the lack of Show instances drove me nuts
17:04:22 <Peaker> (I went and added deriving Show to everything)
17:04:40 <Peaker> I think Typeable, DebugShow, and some others should be always-derived without question
17:05:05 <Peaker> then they can be implicit contexts for every type variable? (somewhat ugly...)
17:06:39 <hpc> benmachine: is C++ really that hard to parse?
17:06:45 <hpc> i thought it was just the semantics that sucked
17:06:54 <mauke> hpc: yes
17:06:55 <lispy> hpc: it's kind of ugly yeah.
17:06:56 <benmachine> hpc: I heard that!
17:07:16 <lispy> and the big-O of C++ parsing is not so hot from what I hear
17:07:32 <hpc> ah
17:07:39 <gienah> C++ is context sensitive, to be able to parse C++ requres entering stuff in the symbol table then looking it up during parsing
17:08:05 <mauke> that's the easy part
17:08:06 <hpc> oh right, because of overloading and other silliness
17:08:13 <mauke> C has the same issue
17:08:22 <gienah> C++ is a huge language, the type system is complex
17:08:38 <Eduard_Munteanu> Complex?
17:08:51 <Eduard_Munteanu> Sure it's a bit ad-hoc, but IDK.
17:08:52 <lispy> Eduard_Munteanu: real and imaginary components :)
17:08:57 <Eduard_Munteanu> Heh.
17:09:03 <lispy> Eduard_Munteanu: the imaginary bits are the type safety
17:09:07 <hpc> lol
17:09:08 <Eduard_Munteanu> :))
17:09:18 <sshc> 00:03:27 < benmachine> sshc: maaaybe :P — Elaborate?
17:09:29 <aristid> @quote oleg
17:09:29 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
17:09:30 <benmachine> sshc: iono the API just looked untidy to me
17:09:34 <aristid> @quote oleg
17:09:34 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
17:09:43 <hpc> haaah!
17:09:46 <aristid> @quote oleg
17:09:46 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
17:09:51 <benmachine> ^ story of my life
17:09:58 <aristid> lambdabot: more oleg quotes! not repeating you must!
17:09:59 <gienah> inria recently proved the object layout rules for multiple inheritance for C++ in coq, I look at that, and it looks complex to me
17:10:11 <Eduard_Munteanu> @remember lispy [in response to "C++ is a huge language, the type system is complex"] real and imaginary components :) the imaginary bits are the type safety
17:10:11 <lambdabot> Nice!
17:10:15 <hpc> λbot doesn't do quote lists, does it?
17:10:52 <hpc> on another bot, i can say !quote list oleg
17:10:58 <aristid> Eduard_Munteanu: that's a bit difficult to read
17:11:15 <mauke> preflex: quote
17:11:17 <preflex>  <dons> home pcs will never need more than 1024 cpus
17:11:28 <aristid> @quote c++.*complex
17:11:28 <lambdabot> Riastradh says: It's not merely that Darcs has a UI whereas Git doesn't; it's that Git imposes a complex model of operation on you no matter what you are trying to do.  Darcs doesn't: there's a
17:11:28 <lambdabot> pristine tree and a working tree and a set of patches, which you can move from one repository to another; that's all.
17:11:39 <aristid> @quote c\+\+.*complex
17:11:39 <lambdabot> lispy says: [in response to "C++ is a huge language, the type system is complex"] real and imaginary components :) the imaginary bits are the type safety
17:11:39 <sshc> mauke: It depends on the purpose.
17:11:44 <hpc> haha, dons will have fun with that in log2(1024/8) years
17:12:10 <hpc> when moore's law says otherwise
17:12:12 <lispy> hpc: I'm sure he said it sarcastically :)
17:12:38 <hpc> actually, don't graphics cards already have more than that many cpus?
17:12:40 <Eduard_Munteanu> @quote real.and.imaginary
17:12:40 <lambdabot> lispy says: [in response to "C++ is a huge language, the type system is complex"] real and imaginary components :) the imaginary bits are the type safety
17:12:52 <hpc> @quote incompleteness
17:12:53 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
17:13:02 * Eduard_Munteanu isn't sure how to reformat it :)
17:13:24 <sshc> benmachine: Yes.  At least there's *a* string class now.  Still enormously useful.
17:13:32 <hpc> in response to ["C++ is a huge language, the type system is complex", "real and imaginary components :)"] the imaginary bits are the type safety
17:13:36 <hpc> ^ that?
17:14:10 <shysoft> How are people in #haskell nicer than people in #c++?
17:14:19 <hpc> shysoft: very well, thank you :P
17:14:27 <aristid> shysoft: c++ makes you bitter.
17:14:49 * hpc shamelessly steals that joke from an advertisement
17:14:56 <monochrom> I invite you to stay in #haskell for a while to see how nice or not nice people are here.
17:15:02 <Eduard_Munteanu> hpc: not so sure, I'd rather not alter quotes too much :)
17:15:18 * Eduard_Munteanu sic :P
17:15:23 <benmachine> I think it's because most people who use haskell want to use it
17:15:30 <benmachine> whereas lots of people who use C++ don't like it
17:15:36 <benmachine> or, that's a part of it anyway
17:15:55 <hpc> i would think the people who care enough to be in irc are the ones who like it
17:16:04 <gienah> type theory for C++ looks challenging: when trying to prove safety only a subset is safe; when trying to prove progess the C++ template metaprogramming language is a turing complete functional programming languge 
17:16:05 <Eduard_Munteanu> Rrrright.
17:16:20 <hpc> i heard a great explanation the other day, though
17:16:25 <monochrom> I opine that the real reason is that under the guiding hand of shapr, ops actively prosecute nasty people (even nasty smart people)
17:16:34 <hpc> in C++ or another shallow language, people learn the whole thing in a year
17:16:43 <hpc> and get the sense that their way is the right way, because they know it all
17:16:47 <benmachine> monochrom: iinteresting.
17:17:04 <hpc> in haskell, the learning curve is so steep and goes so far that everyone is a newbie with varying levels of knowledge
17:17:17 <hpc> so when a real newbie comes in, we all know what it is like
17:17:25 <monochrom> in fact the two prosecuted are Smerydov (sp?) and palomer.
17:17:32 <Eduard_Munteanu> I'm not sure it's that "bad" with Haskell, at least if you don't include CT along with it :)
17:17:40 <olsner> hpc: takes a year to learn everything you want to know about C++, another ten to learn all the things you *don't* want to know :)
17:17:48 <hpc> olsner: that too :D
17:17:55 <hpc> i think the original context was java
17:18:10 <monochrom> Smerdyakov. it's in the ban list.
17:18:30 <hpc> wait, who are we talking about?
17:19:06 <Eduard_Munteanu> Hrm, that Smerdyakov dude sounds familiar.
17:19:22 <Peaker> monochrom, who's palomer?
17:19:49 <Peaker> did Smerdyakov do SML advocacy in #haskell?
17:19:50 <monochrom> Smerdyakov is a prominent researcher. was doing "you are dumb, do your own homework" to newbies. banned.
17:20:00 <Eduard_Munteanu> LOL
17:20:23 <monochrom> palomer would be the one doing *ml advocacy in #haskell or at least persistently "haskell sucks"
17:20:46 <monochrom> we actually let palomer do that for a year or two
17:21:02 <Peaker> http://tunes.org/~nef//logs/haskell/04.01.01 <-- smerdyakov is saying nonsense there
17:21:05 <monochrom> (clearly, "haskell sucks" is milder than "do your own homework")
17:21:17 <hpc> i think i remember palomer
17:21:35 <hpc> not sure if i was here long enough to remember him though
17:21:41 <Eduard_Munteanu> 2004?
17:21:47 <Eduard_Munteanu> Sounds like a long time to be banned.
17:23:21 <hpc> palomer is 2004?
17:23:25 <Peaker> "sucks" is relative, so Haskell certainly sucks, relatively to something (but probably not relatively to ML :-)
17:23:26 <hpc> that predates me by a lot
17:23:41 <hpc> Peaker: it sucks relative to that ever-elusive perfect type system
17:23:56 * Eduard_Munteanu misunderstood
17:24:31 <Peaker> hpc, well, if you include textual syntax in "Haskell", it sucks relatively to a structural language (rather than a textual one).. that is, not really a language, but a structural program editor
17:24:42 <Eduard_Munteanu> Peaker: that's not really nasty, but a bit not what the OP was expecting.
17:24:48 <hpc> Peaker: like coq?
17:25:04 <Peaker> hpc, Isn't Coq textual too?
17:25:18 <hpc> i thought it was an "interactive theorem prover"
17:25:25 <hpc> i should really actually use it someday
17:25:30 <Peaker> http://www.haskell.org/pipermail/haskell/2006-January/017401.html <-- check out quote of the week
17:25:39 * hackagebot nehe-tuts 0.2.0 - Port of the NeHe OpenGL tutorials to Haskell.  http://hackage.haskell.org/package/nehe-tuts-0.2.0 (JasonDagit)
17:25:53 <gienah> you can extract Haskell from coq, then in the extracted haskell it uses unsafeCoerce for stuff that haskell can not really understand but coq knows is ok
17:25:57 <Peaker> hpc, I don't know either, but I think it's at least mostly textual
17:26:32 <Eduard_Munteanu> Anyway, that's not even close to what I've seen in other chans. Say #math
17:27:00 <hpc> what's #math like?
17:27:20 <hpc> i haven't joined because i am terrified of it being entirely fourier transforms and polynomials
17:27:29 <Eduard_Munteanu> A few angry people in there.
17:27:40 <benmachine> hpc: what's wrong with those :P
17:27:59 <hpc> benmachine: i barely understand the first and suck at manipulating the second
17:28:16 <hpc> my algebra is atrocious now that i have haskell to do it for me :P
17:28:17 <Eduard_Munteanu> And some of them really disdain Haskell and certainly don't welcome category theory talk if it's in any way related to the aforementioned language :)
17:28:29 <benmachine> hpc: I barely understand Cont and suck at manipulating iteratees, and yet... :)
17:28:33 <Eduard_Munteanu> (Though I kinda understand where they're coming from.)
17:28:38 <hpc> benmachine: haha, fair
17:28:59 <quotemstr> What are the biggest unsolved problems in purely functional programming?
17:29:06 <hpc> quotemstr: success :D
17:29:14 <quotemstr> Are there any ephemeral structures that just don't have good functional counterparts?
17:29:14 <Eduard_Munteanu> Avoiding success.
17:29:18 <hpc> that too
17:29:18 <monochrom> automatic programming
17:29:27 <quotemstr> I was impressed that red-black trees seem to work just fine.
17:29:32 <benmachine> the singularity
17:29:42 <Peaker> quotemstr, FRP, probably
17:29:56 <quotemstr> Let me be more precise: are there any problems solved in imperative programming that do not have any good solutions for purely functional languages?
17:29:56 <Peaker> Nobody has come up with really nice FRP semantics that also lend themselves to a nice implementation
17:30:01 <hpc> i wish i knew what FRP was well enough to help work on it
17:30:02 <Eduard_Munteanu> Yeah, FRP is certainly a good example.
17:30:11 <quotemstr> FRP?
17:30:18 <hpc> functional reactive programming
17:30:19 <Eduard_Munteanu> Functional Reactive Programming
17:30:26 <jmcarthur> denotative continuous-time programming ;)
17:30:32 <hpc> whatever that means
17:30:33 <Eduard_Munteanu> Or that :)
17:30:34 <quotemstr> Well, it's all turing-complete, so there's nothing unsolveable. But some things are still less than elegant, I imagine.
17:30:48 <jmcarthur> frp is elegant, it's just unsolved
17:31:02 <hpc> quotemstr: there's plenty of undecideable stuff
17:31:08 <Peaker> I sometimes think that just like Doubles are a pretty poor model of Reals, and we live with them, we might have to live with poor representations of "continuous time"
17:31:20 <hpc> Peaker: but we have CReal?
17:31:34 <monochrom> detonative semantics blows your mind
17:31:37 <jmcarthur> which is not the same as reals
17:31:45 <hpc> but it sucks less than double
17:31:52 <hpc> and is as close as a computer can get to the reals
17:32:09 <Peaker> Even non-continuous time FRP is not sufficiently solved, though!
17:32:11 * quotemstr needs to read more about FRP.
17:32:16 <quotemstr> What kinds of problems are solved by FRP?
17:32:21 <hpc> is there an frp channel?
17:32:24 <Peaker> and that is definitely a potential improvement
17:32:27 <conal> Peaker: we do live with low-level, reasoning-unfriendly numerics (e.g. Doubles), but i doubt we need to.
17:32:34 <Eduard_Munteanu> There seems to be an FRP person, though :)
17:32:38 <quotemstr> hpc: This place seems to have the greatest concentration of people who care about functional programming.
17:33:01 <Eduard_Munteanu> Look what you've done, you awakened conal.
17:33:20 <c_wraith> Does Conal eat 1d10 people per minute?  No, wait, I'm thinking Cthulhu
17:33:23 <quotemstr> I also find it interesting that I'd been advocating persistent data structures in plain-old C, C++, and elisp programs long before developing an interest in FP proper.
17:33:23 <Anpheus> If I have two functions, aM and bM that have types "Double -> Maybe Double", what is the canonical way to compose them such that I can do "(a <blah> b) x" or "f = a <blah> b" and "f x"
17:33:25 <hpc> Eduard_Munteanu: it's okay, he didn't open with a dramatic bad-guy line
17:33:27 <c_wraith> @dice 1d10
17:33:27 <lambdabot> 1d10 => 6
17:33:30 <quotemstr> Eduard_Munteanu: Hah.
17:33:31 <hpc> :P
17:33:44 <monochrom> frp will be the way to do interactions in fp when finished
17:33:46 <Peaker> conal, what kind of alternative do you imagine? Also, what of incomputable reals?
17:33:50 <Anpheus> sorry, a is aM and b is bM
17:33:56 <quotemstr> monochrom: Doesn't the IO monad already exist?
17:34:08 <conal> quotemstr: "functional programming" has become a pretty fuzzy notion. a more specific notion is "denotative", which is about having precise & composable meanings.
17:34:10 <monochrom> yes, IO is what we bear with now
17:34:16 <hpc> quotemstr: FRP would be an interesting counterpoint
17:34:32 <mauke> :t (>=>)
17:34:32 <hpc> the RealWorld# isn't time continuous though
17:34:33 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:34:36 <hpc> so how would that mesh with FRP?
17:34:40 <monochrom> io : frp :: qed : gut
17:34:50 <Eduard_Munteanu> I wonder what's the FRP toolkit of choice these days... Grapefruit, Yampa, ...?
17:34:51 <Peaker> It's useful to have IO even if we have FRP implemented on top of it.. IO is a nice representation of the semantics of the underlying layers that an implementation would have to interact with
17:34:53 <hpc> qed as in "QED"?
17:35:01 <quotemstr> conal: Does "denotative" also cover referential transparency?
17:35:02 <monochrom> quantum electrodynamics
17:35:06 <hpc> oh
17:35:08 <Anpheus> mauke: Thanks!
17:35:15 <hpc> was gonna say, QED is the only way to end a proof ;)
17:35:23 <Anpheus> mauke: is there a source online for similar operators?
17:35:41 <conal> quotemstr: RT is a consequence. so is amenability to rigorous reasoning.
17:35:43 <quotemstr> By the way: did uniqueness types ever go anywher?
17:35:43 <Eduard_Munteanu> Anpheus: look in Control.Monad's documentation
17:35:47 <Anpheus> ok
17:35:47 <Eduard_Munteanu> The base libraries.
17:35:48 <hpc> Peaker: i was thinking just have Yet Another Instance for IO
17:35:53 <quotemstr> I recall thinking uniqueness types were pretty intuitive when I read about them.
17:35:59 <monochrom> actually probably s/qed/qcd
17:36:08 <Eduard_Munteanu> @hoogle (>=>)
17:36:08 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:36:13 <conal> quotemstr: pointers at http://conal.net/blog/posts/is-haskell-a-purely-functional-language/#comment-35882
17:36:52 <hpc> good god, conal
17:36:57 <hpc> your website is sloooooooooooow
17:37:02 <monochrom> haha
17:37:05 <Eduard_Munteanu> Peaker: I think HXT is FRP-ish, yet it provides arrow-based variants of IO
17:37:07 <quotemstr> hpc: Well, we all tried to hit the poor thing at the same time.
17:37:13 <hpc> haha
17:37:23 <hpc> but seriously, my site doesn't slow down like this
17:37:30 <monochrom> conal's website is haskelled
17:37:32 <hpc> and it's on the crappiest craptop ever
17:37:39 <quotemstr> Oh, by the way: one problem with using persistent data structures in imperative, non-GCed languages is that, counter to intuition, the value graph can contain cycles, right?
17:37:47 <hpc> or does nobody read what i say? :P
17:37:53 <quotemstr> Is there a way to guarantee, in general, that the graph is a DAG?
17:37:55 <conal> hpc: oh? the blog specifically? what about my home page, publication pages, etc?
17:38:35 <hpc> it's up now
17:38:39 <hpc> too lazy to diagnose
17:39:29 <Peaker> Eduard_Munteanu, I don't like Arrow-based
17:39:40 <Peaker> Eduard_Munteanu, I prefer yairchu's peakachu
17:39:53 <Eduard_Munteanu> :)
17:39:54 <Peaker> it seems to be nice non-continuous-time FRP
17:40:53 <Eduard_Munteanu> Heh, Peakachu is a real package :)
17:40:58 * quotemstr is thoroughly confused.
17:41:28 <hpc> peakachu, i choose you!
17:42:20 <monochrom> I don't think we absolutely need continuous time yet. Dense time will do, i.e., you can insert between any pair. That means for example rational time sufficies, and you don't even need all of the rationals.
17:42:55 <Eduard_Munteanu> Is there any theoretical reason you'd want continuous semantics?
17:42:57 <quotemstr> monochrom: How would having higher cardinality time help?
17:43:19 <monochrom> In the end you just say it's an abstract unspecified dense set, you can insert an event between any pair of events, that's all you need.
17:43:20 <Eduard_Munteanu> Sure, they are "interesting", but useful?
17:45:50 <quotemstr> I don't understand the difference between continuous and dense time in this context.
17:45:55 <quotemstr> Time is always quantized, even in the real world.
17:49:55 <monochrom> both discrete time and dense time have the prospect of not exceeding cardinality ℵ0. (for example use a dense subset of the rational numbers)
17:50:05 <monochrom> but cardinality is really beside the point.
17:50:53 <monochrom> relative order is the point of "time" in programming for interactions.
17:50:59 <hpc> monochrom: if cardinality were all that mattered, we would all use Integer :P
17:51:47 <monochrom> you have two events x, y, you probably know x is "before" y. the interesting temporal question is "may I have another event z after x but before y?"
17:52:06 <quotemstr> Ah, I see.
17:52:20 <monochrom> with discrete time, after you iterate that several times you can't. dense time gives you that freedom.
17:52:39 <quotemstr> And if you have a set like the integers, you can guarantee that no event separates x and y if (= 1 (- (time y) (time x))
17:53:00 <quotemstr> Doesn't discrete time make implementation easier?
17:53:20 <Anpheus> Ok, so let's say I have 5 functions, a, b, c, d, and e, where they all have the form "a -> a" or "a -> Maybe a", how would one compose those?
17:53:46 <monochrom> now, there are certain external practical constraints that ensure you still can't iterate that too many times, so in practice dense time still ends up having a bounded number of events per second, but you no longer need to commit to a fixed resolution a priori. the resolution kind-of "adapts".
17:53:51 <dobblego> Anpheus: instance Monoid Endo or just foldr (.) id
17:53:51 <quotemstr> Anpheus: Why would you have to do anything special to compose them?
17:54:11 <dobblego> for the latter, foldr (>=>) return
17:54:16 <Anpheus> Well if I wanted to compute, for example if they were all a -> a
17:54:26 <Anpheus> If I wanted a . b . c . d . e
17:54:28 <dobblego> @type foldr (.) id
17:54:28 <quotemstr> monochrom: Ah, I see.
17:54:28 <lambdabot> forall b. [b -> b] -> b -> b
17:54:34 <Anpheus> But if they're all a -> Maybe a
17:54:36 <dobblego> @type foldr (>=>) return
17:54:36 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
17:54:39 <quotemstr> monochrom: I'm reminded of OS kernels that dynamically adjust their timer tick intervals.
17:54:47 <hpc> :t sequence
17:54:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:54:52 <Anpheus> then I need a >=> b >=> c >=> d >=> e
17:55:07 <dobblego> Anpheus: a >=> b >=> c >=> d >=> e >=> return
17:55:25 <dobblego> == foldr (>=>) return [a, b, c, d, e]
17:55:59 <Anpheus> If a :: Double -> Double
17:56:02 <Anpheus> and b :: Double -> Double
17:56:09 <Anpheus> a >=> b causes me grief
17:56:28 <dobblego> Anpheus: use foldr (.) id in those cases
17:56:50 <Anpheus> dobblego: I don't follow
17:57:00 <dobblego> @type foldr (.) id
17:57:01 <lambdabot> forall b. [b -> b] -> b -> b
17:57:11 <Anpheus> Right, but
17:57:15 <aavogt> @ty ala Endo mappend
17:57:16 <lambdabot> forall a o'. (Newtype ((a -> a) -> Endo a) o') => ((a -> a) -> Endo a) -> o'
17:57:24 <aavogt> oops
17:57:27 <dobblego> oo lambdabot is ala aware
17:57:36 <aavogt> @ty ala Endo mconcat
17:57:36 <lambdabot>     Couldn't match expected type `(a -> a) -> Endo a'
17:57:36 <lambdabot>            against inferred type `[a1]'
17:57:36 <lambdabot>     In the second argument of `ala', namely `mconcat'
17:57:42 <Anpheus> let's say I have a mix of functions, some of which are "Double -> Maybe Double" and some of which are "Double -> Double"
17:57:45 <aavogt> it's something like that...
17:57:53 <Anpheus> what is the cleanest way of composing those
17:57:57 <dobblego> Anpheus: you need to lift those Double -> Double to Double -> Maybe Double
17:58:15 <Anpheus> so that would be the idiomatic way? just lift any intermediate result and use >=>?
17:58:18 <hpc> :t (return .)
17:58:19 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
17:58:23 <aavogt> you can write a typeclass with will do that
17:58:35 <Anpheus> I'm trying to learn haskell so
17:58:55 <Anpheus> I'm trying to figure out the idiomatic solutions to some thought experiments and trying to write small programs
17:59:17 <dobblego> Anpheus: write a function (Double -> Double) -> Double -> Maybe Double
17:59:35 <dobblego> @type (return .) -- here is one such function
17:59:35 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
17:59:44 <Peaker> Anpheus, I suggest using (.) when both sides are pure, (=<<) when the right side is wrapped, and left returns it wrapped, and <$> when left is pure -> pure and right is wrapped
18:00:12 <Peaker> Anpheus, impureResult1 . pure . pure =<< impureValue
18:00:36 <hpc> Anpheus: instead of memorizing all that, the type system is a great hint system
18:00:36 <Peaker> Anpheus, pure <$> impureResult1 . pure . pure =<< impureValue
18:00:42 <hpc> :P
18:01:16 <Anpheus> Right, but the type system doesn't tell me what's idiomatic or well understood by other haskellers, or why
18:01:26 <Peaker> or instead of <$>, you can use:  return . a . b =<< c . d ... (similar to dobblego's suggestion, but the (return.) is applied there)
18:02:00 <Peaker> Eduard_Munteanu, look at defendtheking, it's a nice game based on peakachu
18:02:06 <benmachine> Peaker: =<< has lower fixity than <$> btw
18:02:24 <Anpheus> pure . a . b >=> c . d >=> e $ 5
18:02:27 <Eduard_Munteanu> Thanks, maybe that proves instructive.
18:02:29 <Anpheus> that worked for me
18:02:36 <Eduard_Munteanu> Grapefruit examples aren't great.
18:02:57 <Peaker> Eduard_Munteanu, I think defend is undocumented and the names may be terse, so it may be hard to follow, I tried reading a bit a while ago :)
18:03:14 <benmachine> Anpheus: btw, I personally find <=< more natural than >=>
18:03:18 <Anpheus> really?
18:03:21 <benmachine> but that's a matter of taste
18:03:23 <Anpheus> Why is that?
18:03:32 <benmachine> because it looks like function composition
18:03:37 <benmachine> only with some m's thrown in
18:03:41 <benmachine> :t (Prelude..)
18:03:42 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:03:44 <benmachine> :t (<=<)
18:03:45 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
18:04:00 <Anpheus> :t (>=>)
18:04:01 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
18:04:11 <Anpheus> oh I see
18:04:22 <Anpheus> :t (.)
18:04:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:04:33 <Anpheus> well that's not what I expected
18:04:34 <hpc> (.) = fmap in here
18:04:34 <Peaker> Reading left-to-right in the middle of a right-to-left thing is confusing
18:04:41 <hpc> it's a fun surprise
18:04:42 <benmachine> Anpheus: lambdabot is a bit funny :)
18:05:11 <Anpheus> so (>=>) is like (flip (.)) ?
18:05:16 <hpc> Anpheus: yes
18:05:16 <monochrom> x >=> y <=< z <=< k >=> whee
18:05:19 <Anpheus> and <=< is composition like f . g
18:05:25 <benmachine> monochrom: isn't that a fixity error :P
18:05:35 <monochrom> most likely!
18:05:36 <Peaker> Anpheus, well, since Haskell is lazy,  in (f x) the "f" is more determining of the result than the "x", so it makes more sense than "x f" for application.  That means that in (f (g x)) the flow is right-to-left.  so it makes sense for (.) to flow right-to-left. So every dot-like function should be used right-to-left too
18:05:39 <benmachine> Anpheus: yes. in fact I think flip (.) is called (>>>) somewhere
18:05:44 <Eduard_Munteanu> Anpheus: also (>=>) is like (>>>)
18:05:53 <Eduard_Munteanu> :t (>>>)
18:05:54 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
18:05:57 <hpc> Anpheus: when you learn more about haskell, you will find that (<=<) and (.) are the same
18:06:05 <hpc> :t (Control.Category..) -- Anpheus
18:06:06 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
18:06:13 <hpc> Anpheus: but that's for later :D
18:06:32 <aristid> hpc: well the haskell type system demands the Kleisli wrapper
18:06:34 <Eduard_Munteanu> (as in flip (.) == (>>>))
18:06:37 <monochrom> too bad >_> is not a legal operator
18:06:37 <benmachine> hpc: I think that was key to my understanding of monads, so it could well be sooner rather than later
18:06:59 <benmachine> cf. http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
18:09:06 <hpc> benmachine: but now there's lyah, which imo is easier to grasp
18:09:08 <osoleve> is there a way to discern if a function is partial without prior knowledge?
18:09:14 <Anpheus> Why is it that . is fmap for lambabot?
18:09:30 <monochrom> some privileged people's private agenda
18:09:34 <hpc> heh
18:09:39 <Anpheus> that sounds sinister
18:09:45 <hpc> Anpheus: oh, you think that's sinister
18:09:47 <hpc> > 1 2 3 4 5
18:09:48 <lambdabot>   1
18:09:50 <Peaker> Anpheus, It's called Caleskell (Cale's bot)
18:10:00 <Anpheus> Ahuh
18:10:05 <Peaker> > 1 2 + 3 4
18:10:06 <lambdabot>   4
18:10:11 <Anpheus> ...
18:10:26 <Cale> It's just an instance of Num for functions
18:10:27 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:10:30 <Eduard_Munteanu> :t mappend
18:10:31 <lambdabot> forall a. (Monoid a) => a -> a -> a
18:10:35 <hpc> Cale: it's an eeeevil instance!
18:10:42 <hpc> (but i love it anyway)
18:10:45 <Eduard_Munteanu> :t (++)
18:10:45 <Anpheus> ok
18:10:46 <lambdabot> forall m. (Monoid m) => m -> m -> m
18:10:46 <geheimdienst> > (.) (+2) (Just 4)
18:10:48 <lambdabot>   Just 6
18:10:48 <aavogt> > (+1)
18:10:48 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:10:48 <lambdabot>    arising from a use of `...
18:10:54 <Anpheus> what the fuck just happened with this:
18:10:57 <geheimdienst> > (+2) . (Just 3)
18:10:57 <Anpheus> > 1 2 + 3 4
18:10:58 <lambdabot>   4
18:10:58 <lambdabot>   Just 5
18:11:06 <Eduard_Munteanu> Yeah, that one is actually evil.
18:11:08 <aavogt> Cale: could you remove that extra show instance for functions?
18:11:09 <hpc> Anpheus: 1 2 == 1; 3 4 == 3
18:11:14 <geheimdienst> woah, i never knew that that works
18:11:14 <hpc> 1 + 3 = 4
18:11:39 <Anpheus> > 1 2 3 4 2147483648 + 5 6 7 1073741824
18:11:39 <hpc> there's a show instance for functions?
18:11:40 <lambdabot>   6
18:11:40 <geheimdienst> so this involves a Functor instance for functions?
18:11:47 <Anpheus> Ok
18:11:48 <aavogt> so keep the smallcheck one and discard the useless one needed by vector space (or whoever defined that show instance to be able to do the Num instance)
18:11:48 <Eduard_Munteanu> > id
18:11:50 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:11:50 <lambdabot>    arising from a use of `...
18:11:55 <Anpheus> that is sinister
18:11:56 <aavogt> @src Num
18:11:56 <lambdabot> class  (Eq a, Show a) => Num a  where
18:11:56 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:11:56 <lambdabot>     negate, abs, signum     :: a -> a
18:11:56 <lambdabot>     fromInteger             :: Integer -> a
18:12:00 <aavogt> hpc: ^^
18:12:13 <Anpheus> Ok, so since, wait
18:12:17 <hpc> aavogt: oh lol
18:12:21 <Anpheus> if it's possible in haskell to define what "1 2" should mean
18:12:39 <Anpheus> is it possible to make it treat spaces like commas, that is, I could define something and enter in "2 147 483 648"?
18:12:41 <aavogt> this means that to write a Num instance for a function you must have written a Show instance first
18:13:06 <shysoft> I've cabal installe-d language-c. I'm now interested in modifying  language-c's source code and reinstalling it. What would be the easiest way of doing this? I've found language-c-0.3.2.1.tar.gz in ".cabal/packages". Would I untar and modify this and then somehow commit the changes?
18:13:13 <Anpheus> and the result of "2 147 483 648" would be "2147483648"
18:13:14 <Anpheus> ?
18:13:29 <Anpheus> I'm curious
18:13:35 <geheimdienst> so the "Num instance for functions" is what makes that funk tick?
18:13:36 <geheimdienst> > 3 4
18:13:37 <lambdabot>   3
18:13:45 <hpc> Anpheus: so the way numbers work
18:13:55 <dmwit> shysoft: Yes, untar it, then "cabal build" or "cabal install" in the directory that it creates.
18:13:56 <hpc> when you say 3, you are really saying "fromIntegral 3"
18:14:03 <Anpheus> ahu
18:14:04 <Anpheus> h
18:14:06 <hpc> or fromInteger, i forget which
18:14:12 <Anpheus> :t fromIntegral
18:14:13 <lambdabot> forall a b. (Integral a, Num b) => a -> b
18:14:14 <benmachine> fromInteger
18:14:14 <Anpheus> I think that's it
18:14:24 <hpc> and so there's an instance for functions
18:14:36 <benmachine> fromIntegral is just fromInteger . toInteger, but in this case 3 is already an integer, sooo
18:14:40 <hpc> instance Num a => (b -> a) where fromInteger x = \_ -> x
18:14:57 <hpc> so when you say "1 2" you are really saying (\_ -> 1) 2
18:15:00 <hpc> which is 1
18:15:15 * hpc assumes you understand lambdas
18:15:27 <benmachine> you could theoretically define the instance differently, but it would require additional constraints which would make the other aspects less cute
18:15:28 <Anpheus> I see
18:15:28 <geheimdienst> shysoft: if you don't want to manually download tar files next time, you can also use "cabal unpack" to get the source code
18:15:36 <Anpheus> so why exactly is this defined?
18:15:41 <Eduard_Munteanu> Num a => Num (b -> a), isn't it?
18:15:46 <benmachine> Anpheus: it's fun to do this sort of thing:
18:15:52 <aavogt> shysoft: cabal unpack language-c; change stuff in that new directory; cabal install
18:15:57 <benmachine> > sin^2 + cos^2 $ pi
18:15:58 <lambdabot>   1.0
18:16:25 <aavogt> Eduard_Munteanu: since when do type variable names matter?
18:16:26 <Anpheus> you
18:16:27 <Anpheus> lost me
18:16:29 <benmachine> Anpheus: making numeric literals into functions is really an unwanted side-effect of allowing addition and multiplication of functions
18:16:39 <Eduard_Munteanu> > diff sin^2
18:16:39 <lambdabot>   Not in scope: `diff'
18:16:55 <Eduard_Munteanu> aavogt: I added a 'Num'
18:17:20 <aavogt> oops, I missed that
18:17:26 <benmachine> shutdown_-h_now: I would recommend changing the version number if you are making your own changes
18:17:30 <benmachine> eeer
18:17:33 <benmachine> shysoft: that^
18:17:39 <Eduard_Munteanu> @hoogle diff
18:17:42 <lambdabot> module Data.Array.Diff
18:17:46 <lambdabot> Data.Time.Clock.TAI diffAbsoluteTime :: AbsoluteTime -> AbsoluteTime -> DiffTime
18:17:50 <lambdabot> Data.Array.Diff type DiffArray = IOToDiffArray IOArray
18:17:50 <Eduard_Munteanu> @hoogle deriv
18:17:53 <aavogt> > deriv x^2
18:17:54 <lambdabot> Language.Haskell.Lexer KW_Deriving :: Token
18:17:57 <Eduard_Munteanu> Oh right.
18:17:58 <lambdabot>   mueval-core: Time limit exceeded
18:18:14 <Anpheus> ok so
18:18:18 <Eduard_Munteanu> > deriv (^2) . sin
18:18:19 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:18:19 <lambdabot>    arising from a use of `...
18:18:19 <hpc> :t deriv
18:18:20 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
18:18:22 <benmachine> > deriv sin x
18:18:23 <lambdabot>   1 * cos x
18:18:25 <Anpheus> going back to what I originally asked, in lambdabot (.) corresponds to fmap
18:18:26 <Eduard_Munteanu> > deriv ((^2) . sin) $ 1
18:18:27 <lambdabot>   0.9092974268256818
18:18:31 <benmachine> Anpheus: right
18:18:36 <Eduard_Munteanu> > deriv ((^2) . sin) $ x
18:18:37 <lambdabot>   1 * cos x * sin x + sin x * (1 * cos x)
18:18:48 <Anpheus> And that's a political choice, basically, to force a more generalized form?
18:18:50 <Eduard_Munteanu> I'm used with Maxima's 'diff' :)
18:18:53 <geheimdienst> @instances Functor
18:18:53 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
18:19:09 <benmachine> Anpheus: I wouldn't use the term political, it's more a facility for playing about with new ideas
18:19:18 <benmachine> Anpheus: it's somewhat controversial, though
18:19:21 <Anpheus> Ok, but the motiviation I got is correct, right?
18:19:26 <Anpheus> fmap is more general than (.)?
18:19:29 <lispy> Yeah, for example.  I don't like it. :)
18:19:31 <benmachine> yes
18:19:32 <geheimdienst> :t fmap 
18:19:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:19:56 <benmachine> there is an instance of Functor that defines fmap = (.)
18:20:38 <geheimdienst> i don't get it. it defines fmap = (.) or (.) = fmap?
18:20:38 <Anpheus> ok so wait a second
18:21:01 <Anpheus> (.) takes three parameters in my ghci, and fmap takes two
18:21:01 <Eduard_Munteanu> geheimdienst: I'd think the latter
18:21:15 <Anpheus> Should I expect code I write to work on lambdabot if I use . or (.)?
18:21:17 <benmachine> Anpheus: it depends how you think of "taking parameters"
18:21:28 <Anpheus> I knew that would come up
18:21:29 <Eduard_Munteanu> :t (.)
18:21:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:21:31 <benmachine> :)
18:21:35 <Eduard_Munteanu> Son of a...
18:21:37 <Anpheus> Yeah
18:21:38 <hpc> Anpheus: (f . g) = (.) f g
18:21:39 <Eduard_Munteanu> :t (Prelude..)
18:21:39 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:21:43 <benmachine> it's better to look at the type of (.) as
18:21:44 <Anpheus> I know, hpc
18:21:51 <Anpheus> But my (.) and . are:
18:21:53 <benmachine> (b -> c) -> (a -> b) -> (a -> c)
18:21:57 <Anpheus> (b -> c) -> ... that
18:21:59 <Anpheus> well yeah
18:22:00 <benmachine> taking two functions and returning a function
18:22:21 <Anpheus> Yep, I understand that you can move the parenthesis around
18:22:28 <Anpheus> Pointfree functions take advantage of that
18:22:29 <Eduard_Munteanu> (->) is right-associative by definition so you can do that transformation anywhere
18:23:12 <Anpheus> right
18:23:15 <benmachine> Anpheus: anyway, if you look at fmap and replace the fs with (r ->)s, you get the type of composition
18:23:18 <Anpheus> :t fmap
18:23:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:23:34 <ian_mi> :t deriv
18:23:35 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
18:24:33 <ian_mi> why isn't it Dif (a -> b)?
18:25:06 <benmachine> why should it be?
18:25:35 <Anpheus> so
18:25:37 <lispy> ?. pl undo do { r <- m ; return (r, 0) }
18:25:37 <lambdabot> flip (,) 0 `fmap` m
18:26:01 <ian_mi> benmachine: differential values don't make any sense
18:26:08 <ian_mi> differentiable
18:26:09 <Anpheus> if we instead defined fmap as:
18:26:34 <ian_mi> functions are differentiable, not sets
18:26:47 <benmachine> ian_mi: Dif a doesn't mean 'a is differentiable'
18:26:47 <hpc> ian_mi: sure
18:26:55 <hpc> Dif a -> Dif b is a function
18:26:57 <Anpheus> forall a b (f :: * -> *). (Functor f) => (b -> c) -> f b -> f c
18:27:00 <Eduard_Munteanu> ian_mi: you realize automatic differentiation is just a big, tricky type hackery, right?
18:27:14 <Anpheus> and replaced f with ((->) a)
18:27:15 <Anpheus> we get .
18:27:16 <Anpheus> right?
18:27:17 <hpc> @deriv
18:27:17 <lambdabot> Unknown command, try @list
18:27:20 <hpc> @src deriv
18:27:20 <lambdabot> Source not found.
18:27:29 <Eduard_Munteanu> @hackage ad   -- ?
18:27:29 <lambdabot> http://hackage.haskell.org/package/ad   -- ?
18:27:31 <benmachine> Anpheus: yeah
18:28:07 <hpc> Eduard_Munteanu: cool
18:29:50 <Anpheus> benmachine: I know kung fu.
18:30:02 <benmachine> Anpheus: :D
18:30:44 <benmachine> > show me
18:30:46 <lambdabot>   "awesome fight scene follows"
18:32:17 <hpc> benmachine: :D
18:32:47 <monochrom> > [0] + 1
18:32:48 <lambdabot>   No instance for (GHC.Num.Num [t])
18:32:48 <lambdabot>    arising from a use of `e_101' at <inte...
18:39:17 <monochrom> So, w00t, ghc 7.0.3 already!
18:39:34 <benmachine> w00t, reinstalling all my packages already :P
18:43:31 <osoleve> @hoogle when
18:43:31 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
18:50:10 <osoleve> how would I say "if exp returns true, do this"?
18:50:25 <benmachine> osoleve: returns?
18:50:33 <osoleve> evaluates to
18:50:38 <benmachine> *is* :P
18:50:46 <benmachine> what's 'this'?
18:51:21 <osoleve> a composition of functions that ultimately is :: String -> Int
18:52:31 <benmachine> osoleve: what do you do if exp is False?
18:53:00 <osoleve> exp handles that, but i'm going tochange it so that exp returns an int so I can signal multiple error conditions
18:53:46 <benmachine> osoleve: I'm not following you exactly, do you have some example code?
18:54:07 <osoleve> https://github.com/osoleve/Haskell-Infix-Calc
18:54:31 <osoleve> i'm trying to alter Calc.hs to use RDParser.hs to validate expressions before they're evaluated
18:55:28 <benmachine> seems a strange way of doing it
18:55:46 <benmachine> you want calc to be a String -> Int function that does the evaluation?
18:55:52 <osoleve> yes
18:56:03 <benmachine> and the validation as well?
18:56:20 <osoleve> no, i only want it to run if the function is true
18:56:26 <osoleve> validation function*
18:57:04 <benmachine> oh
18:57:23 <benmachine> what do you do if it doesn't validate?
18:57:41 <osoleve> currently, RDParser signals an error, but I plan on changing that
18:58:30 <benmachine> hmm
18:59:09 <benmachine> exactly how you signal an error is important for how you write your if
18:59:25 <osoleve> i just edited it so it returns false instead of signalling an error
18:59:46 <benmachine> ok so what do you want to happen when it returns false?
18:59:58 <osoleve> for now I'll just signal a generic error
19:00:03 <monochrom> if b::Bool, try: when b (haha hehe)
19:00:32 * benmachine confuses self by parsing 'try:' as python
19:00:33 <monochrom> if b :: IO Bool, try: b >>= \c -> when c (haha hehe)
19:00:43 <monochrom> oh sorry!
19:00:45 <benmachine> :P
19:01:17 <benmachine> osoleve: if parse expr then calc expr else error "generic"?
19:01:18 * monochrom resists the temptation to rename to "try"
19:01:28 <benmachine> heh
19:01:39 <osoleve> benmachine: i'll try that, i thought i did but i'll try again
19:01:40 <osoleve> haha
19:02:42 <osoleve> Couldn't match expected type `Int' with actual type `a0 -> c0'
19:02:44 <osoleve> o.O
19:03:00 <osoleve> in the postfixEval . shuntingYard . tokenize exp
19:03:22 <Axman6> what are the types of all functions there?
19:03:32 <benmachine> osoleve: tokenize $ exp
19:03:49 <osoleve> that worked <3
19:03:51 <benmachine> osoleve: f . g . h x = f . g . (h x)
19:03:59 <benmachine> so you need the $ in there to split it up
19:05:29 <hpc> hint: ($) is the lowest fixity operator, so you can use it to break up other things too
19:08:13 <Saul__L> Hi, anyone knows how to change themes on Leksah?.
19:19:29 <lispy> We don't have a binding for freetype2 yet do we?
19:19:38 <lispy> If it's on hackage I'm not spotting it
19:21:48 * geheimdienst has found that the XmfDrawString functions in the X11 binding do fonts the right way
19:22:09 <geheimdienst> er ... sorry, i think i have freetype confused with fontconfig
19:27:57 <eimirae> @type map
19:27:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:28:41 <eimirae> @pl intersect_short xs ys = nub [x | x<-xs, any (x==) ys]
19:28:41 <lambdabot> intersect_short = (nub .) . (. (return . any (x ==))) . (:) . ((x | x) <-)
19:29:53 <gwern> @quote
19:29:53 <lambdabot> hoooool says: haskell is optimized for trolling and that is why everyone should use it
19:29:55 <eimirae> @pl compress (x:y:xys) | x==y = compress (x:xys) | otherwise = x:compress (y:xys)
19:29:55 <lambdabot> (line 1, column 27):
19:29:55 <lambdabot> unexpected "="
19:29:55 <lambdabot> expecting variable, "(", operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
19:30:21 <benmachine> eimirae: be nice to @pl, it is simple-minded
19:30:27 <eimirae> @pl compress (x:y:xys) = if x==y then compress (x:xys) else x:compress (y:xys)
19:30:30 <lambdabot> compress = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (liftM2 ap .) . ap (flip . (((.) . if') .) . (==)) . (. (:)) . (.)) (flip ((.) . (.) . (:)) . (.
19:30:30 <lambdabot>  (:)) . (.)))
19:30:34 <djahandarie> Heh
19:30:36 <eimirae> lol, sorry
19:31:27 <djahandarie> @pl fix (\c (x:y:xs) -> if x==y then c (x:xs) else x:c (y:xs))
19:31:29 <lambdabot> fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (liftM2 ap .) . ap (flip . (((.) . if') .) . (==)) . (. (:)) . (.)) (flip ((.) . (.) . (:)) . (. (:)) . (.)
19:31:30 <lambdabot> ))
19:31:35 <eimirae> @pl increasing (x:y:xys) = x < y && increasing (y:xys)
19:31:36 <lambdabot> increasing = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip (ap . (((.) . (&&)) .) . (<)) . (. (:)) . (.))
19:31:37 <djahandarie> Heh, still exploded
19:32:48 <eimirae> @pl select pred xs ys = [y | (x,y) <- zip xs ys, pred x]
19:32:49 <lambdabot> select = flip (flip . (((:) . ((y | (x, y)) <-)) .) . zip) . return . ($ x)
19:32:59 <djahandarie> eimirae, it can't do list comprehensions
19:33:06 <eimirae> I will make it do them
19:33:13 <djahandarie> @. pl undo select pred xs ys = [y | (x,y) <- zip xs ys, pred x]
19:33:13 <lambdabot> select = (zip >>=) . (`ap` snd) . (. fst) . flip flip [] . (flip .) . flip flip return . (((.) . if') .)
19:33:34 <djahandarie> @type (zip >>=) . (`ap` snd) . (. fst) . flip flip [] . (flip .) . flip flip return . (((.) . if') .)
19:33:35 <lambdabot> Not in scope: `if''
19:33:38 <eimirae> I just wanted to see what it would do to my homeworks
19:33:54 <djahandarie> @type let if' a b c = if a then b else c in (zip >>=) . (`ap` snd) . (. fst) . flip flip [] . (flip .) . flip flip return . (((.) . if') .)
19:33:55 <lambdabot>     Couldn't match expected type `[b] -> [(a, b)]'
19:33:55 <lambdabot>            against inferred type `(a1, b1)'
19:33:55 <lambdabot>     In the second argument of `ap', namely `snd'
19:34:02 <djahandarie> Heh, still didn't work anyways
19:34:22 <lispy> geheimdienst: oh yeah, I saw we had a binding to that, but the haskell bits are LGPL, right?
19:34:24 <djahandarie> Someone should focus on making a version of @pl that actually has some sort of guarentees about the program transforation.
19:34:31 * lispy tends to ignore GLP/LGPL things on hackage
19:35:10 <geheimdienst> lispy: i've no idea about the license
19:35:43 <lispy> geheimdienst: is this the library you meant? http://hackage.haskell.org/package/X11-xft-0.1
19:36:01 <eimirae> @pl stutter (x:xs) = x:x:stutter xs
19:36:01 <lambdabot> stutter = fix ((`ap` tail) . (. head) . liftM2 (.) (:) . flip ((.) . (:)))
19:37:31 <geheimdienst> lispy: yeah, that's what xmonad uses and how i came across it. though you'd probably want the newest (0.3)
19:38:47 <freedrull> in gentoo,
19:38:50 <freedrull> all the dev-haskell/cabal package installs is a file with the characters "[]" in it: /usr/lib/ghc-7.0.2/gentoo/cabal-1.10.1.0.conf
19:39:59 <freedrull> ?!??!!
19:39:59 <lambdabot> Unknown command, try @list
19:40:19 <lispy> geheimdienst: yeah, although I want something not LGPL and cross platform.
19:40:33 <lispy> geheimdienst: freetype2 seems to fit both of that (BSD3 and crossplatform)
19:45:16 <geheimdienst> lispy, good luck then :) i found xft a little weird because you need xft colormaps and xft this and xft that before you can draw a string, but in the end the existing haskell binding makes it all fairly easy. look at Util/Font.hs in xmonad-contrib for an example of how to use it
19:45:24 <geheimdienst> just as inspiration, maybe
19:49:35 <lpsmith> Ok,  so I'm trying out the new cabal-install on GHC-7.0.3,  and it's regularly failing to configure packages that if I go through the (unpack, configure, build, haddock, copy, register) sequence works fine
19:49:36 <lpsmith> like,  cabal install darcs has failed to build terminfo,  haskeline, and hashed storage so far 
19:50:04 <lispy> lpsmith: hmm
19:50:17 <lispy> lpsmith: if you install with --verbose=3 can you tell why it fails?
19:50:54 * hackagebot happstack-server 6.0.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.0.3 (JeremyShaw)
19:51:22 <gienah> freedrull: my /usr/lib/ghc-7.0.2/gentoo/cabal-1.10.1.0.conf just contains one line: []
19:52:45 <lpsmith> lispy, I get a lot of output,  and it's not obvious why it's failing
19:52:49 <lpsmith> Although
19:52:58 <lpsmith> I think I know why now;   my /tmp is tmpfs
19:53:25 <lispy> lpsmith: running out of space?
19:53:36 <lpsmith> if I try to build in /tmp,  it fails rather silently when I go through the sequence
19:53:54 <lpsmith> no,  I have 4 GiB of RAM and ~ 8 GiB of swap
19:53:58 <lispy> hmm
19:55:32 <lpsmith> ahh
19:55:35 <lpsmith> I know why
19:55:38 <geheimdienst> that reminds me: i can't install darcs because the current network package fails to build for me: http://hpaste.org/45096/darcsinstallfail
19:55:49 <geheimdienst> i guess it's because i now have ghc 7
19:56:06 <lpsmith> it's compiling ./Setup.hs,  and then trying to run it from dist/
19:56:16 <lpsmith> And I have noexec set on my /tmp directory
19:56:20 <freedrull> gienah: mine too!! what is the point of this package?!?!?!
19:56:56 <lpsmith> now,  how do I remount my /tmp tmpfs to remove the noexec option without molesting everything in there?
19:57:35 <geheimdienst> couldn't you build it somewhere else ...?
20:01:22 <gienah> freedrull: equery belongs /usr/lib/ghc-7.0.2/gentoo/cabal-1.10.1.0.conf says its not owned by any package, I don't really know what it is for
20:06:05 <mikeg> maybe for historic reasons there are ports that depend on dev-haskell/cabal instead of ghc
20:08:33 <lpsmith> geheimdienst, yeah, that may be the more practical solution :)
20:13:05 <lpsmith> http://hackage.haskell.org/trac/hackage/ticket/696
20:13:52 <lpsmith> hmm,  I could have sworn that I was using the old cabal-install relatively problem-free
20:13:57 <lpsmith> with noexec
20:15:41 <freedrull> i've never seen this cabal error, what does it mean? cabal: internal error: configure install plan should have exactly one local
20:16:08 <Apocalisp> Why would you want IORef when you have STRef?
20:19:40 <TomMD> Perhaps you don't want to be in the ST monad?
20:20:51 <TomMD> I've used IORef a fair amount.  Unsurprisingly, I was in the IO monad...
20:21:52 <nihtml> hi guys, my workmate and me are developing a opencv-binding for haskell. he made a .cabal file but he has a older version of cabal (0.8.0, I use 0.10.2) and it seems that the include-dirs instruction doen't work as well in 0.10.2 as in 0.8... can it be possible that .cabal syntax changes?
20:22:09 <lpsmith> Apocalisp, ST is pretty incompatible with explicit concurrency
20:22:18 <Apocalisp> how's that?
20:22:39 <lpsmith> Apocalisp, runST guarantees that the value it produces is pure
20:22:47 <lpsmith> even if it was created with side effects
20:23:47 <lpsmith> and concurrency with mutable state,  runST would have to ensure somehow that the computation is free of race conditions
20:23:53 <dobblego> Apocalisp: note the functions stToIO (safe) and unsafeSTtoIO (unsafe)
20:24:16 <TomMD> nihtml: Do you know opencv bindings already exist on hackage?
20:24:20 <Apocalisp> yeah, stToIO needs to nail the s down to RealWorld
20:24:20 <lpsmith> shouldn't that be unsafeIOtoST
20:24:28 <dobblego> lpsmith: both
20:24:59 <Apocalisp> dobblego: Should we provide both STRefs and IORefs then?
20:25:00 <nihtml> yes TomMD but don't like it
20:25:09 <lpsmith> there are STRefs and IORefs :)
20:25:13 <TomMD> nihtml: But I'm not aware of issues with include-dirs.
20:25:20 <dobblego> Apocalisp: yes definitely, unless there is some unforeseen gotchya
20:25:30 <Apocalisp> dobblego: No, none.
20:25:58 <nihtml> ok
20:26:04 <dobblego> Apocalisp: then yes, both
20:26:17 <ddarius> Apocalisp: Your ST monad isn't done yet?
20:27:21 <lpsmith> Apocalisp is writing a ST monad? :)
20:27:39 <dobblego> cooking it in scala
20:27:43 <lpsmith> ahh
20:27:50 <Apocalisp> ddarius: Yeah, working on IO now.
20:28:16 <Apocalisp> ST done. IO currently. Next is SIO, then STM.
20:28:17 <ddarius> Oy vey.
20:28:24 <ddarius> SIO ?
20:28:37 <geheimdienst> super IO
20:28:46 <Apocalisp> Oleg's safe-io
20:28:48 <geheimdienst> supreme IO
20:28:50 <Anpheus> When one composes a set of functions, a la "pure . a . b <=< c . d <=< e", what would the category theoretical or technical name for that be?
20:28:50 <ddarius> Ah.
20:28:54 <Apocalisp> Light Weight Monadic Regions
20:29:04 <dobblego> Anpheus: kleisli composition
20:29:17 <lpsmith> heh,  I still want callCC :: ((a -> IO b) -> IO a) -> IO a
20:29:26 <lpsmith> that would be rather handy
20:29:57 <ddarius> lpsmith: You can get one-shot (sub)continuations from threads.
20:30:14 <ddarius> If you have a "thread-dup" you can get multi-shot continuations.
20:30:44 <lpsmith> ddarius,  I don't think that would allow me to do one of the things I would like to do with callCC
20:30:59 <ddarius> Apocalisp: Are you guys making your Scala look more and more Haskell-like, and then one day you're going to switch to Haskell and not tell anyone and no one will be able to tell the difference.
20:31:00 <ddarius> ?
20:31:06 <lpsmith> specifically,  to use callCC to install a top-level exception handler
20:31:13 <lpsmith> around an existing thread
20:31:22 <ddarius> lpsmith: You can do that one-shot continuations.
20:31:26 <dobblego> ddarius: just stealing the good ideas from haskell and telling everyone it's Java
20:31:43 <Apocalisp> ddarius: No, just trying to get an effect system going for Scala.
20:32:32 <Apocalisp> ddarius: Tired of shooting myself in the foot with side-effects.
20:32:39 <dobblego> ddarius: there have been an increasing number of complaints about the absence of an effect system for scala
20:32:42 <lpsmith> ddarius, yes, I should be able to do that
20:32:46 <dobblego> yeah, like I did just the other day
20:32:48 <lpsmith> with one-shot continuations
20:32:49 <lpsmith> but
20:33:22 <lpsmith> I'm skeptical that what I'd like to do is possible in the way you describe
20:33:27 <ddarius> Apocalisp: Yeah, it's strange how even the most innocuous side-effect turns into a big head-ache.
20:33:33 <lpsmith> on the other hand,  if you can prove me wrong,  I would be delighted :)
20:34:03 <lpsmith> ddarius, do you have a sample implementation of your idea?
20:34:11 <lpsmith> that I could look at?
20:34:39 <ddarius> There's a Scheme based implementation in the paper "Threads Yield Continuations."  I could probably make at least one-shot continuations pretty quickly.
20:35:41 <lpsmith> thanks,  I feel like I should have been aware of this paper, but I wasn't
20:36:19 <lpsmith> I'll take a look;  if you are interested in making a callCC1 for IO,  I'd be grateful.
20:45:09 <ddarius> lpsmith: http://hpaste.org/45099/callcc1
20:46:23 <lpsmith> hmm
20:46:46 <lpsmith> Thanks!
20:47:03 <Bfig_> dmwit, can you help me parse a really weird line?
20:47:04 <lpsmith> The use of throwIO might be problematic,  I shall see.
20:47:25 <lpsmith> ddarius++
20:48:24 <Bfig_> @unpl (foldr (++) . map (:)) [1,2,3] [[filter even]]
20:48:24 <lambdabot> foldr (++) (map (:) [1, 2, 3]) [[filter even]]
20:49:21 <Bfig_> what happens with the . between (++) and map ?
20:49:42 <byorgey> (f . g) x = f (g x)
20:49:51 <byorgey> in this case f = foldr (++, g = map (:), x = [1,2,3]
20:50:10 <byorgey> it's just the definition of (.)
20:50:39 <Bfig_> i wasn't sure how to handle the . in the case i had it as infix
20:51:04 <Bfig_> the LHS is completely computed before touching the ., right?
20:51:28 <geheimdienst> function application binds moar than anything else, so it's (foldr (++)) . (map (:))
20:51:29 <Eduard_Munteanu> (++) isn't infix there
20:51:50 <geheimdienst> (right?)
20:51:57 <byorgey> right
20:52:02 <geheimdienst> thanks
20:52:15 <Bfig_> ie, if i had a dot (first one appearing only) and i had an expression like this: t0 t1 t2 . t3 . t4... i'd compute (t0 t1 t2), then ( . ) (t0 t1 t2) (t3), then ( . ) ....
20:52:24 <Bfig_> Eduard_Munteanu, i was talking about the . itself
20:52:39 <Eduard_Munteanu> No, no, the rightmost function is applied first.
20:53:15 <Eduard_Munteanu> Unless you're talking about evaluation order, which may differ.
20:53:24 <Bfig_> Eduard_Munteanu, so  when a . separates the terms in two within the bounds of the parens it is like i must compute the LHS, the RHS and then join them?
20:53:26 <Axman6> . forms a pipe, like | in shells, but backwards. things flow like <-
20:53:46 <Bfig_> ie, in this case i have in the lhs (foldr (++)) and in the RHS (map (:)), right?
20:53:47 <Eduard_Munteanu> byorgey> (f . g) x = f (g x)
20:54:01 <Eduard_Munteanu> So first you apply g to x, and f to the result.
20:54:07 <geheimdienst> Bfig_: yes, that's what i meant above
20:54:30 <Bfig_> thanks all
20:54:48 <Bfig_> much clearer now. so this is for all infix, right?
20:55:07 <Bfig_> parse left to right, bind looser than function application?
20:55:17 <Eduard_Munteanu> Bfig_: prefix form is similar
20:55:40 <Eduard_Munteanu> (.) f g $ x == f (g x)
20:56:02 <Eduard_Munteanu> There isn't really any difference as long as you convert between the two.
20:56:42 <Eduard_Munteanu> or   ((.) f g) x == f (g x)   if you like
20:56:43 <Bfig_> Eduard_Munteanu, i meant for things like `mod`, +, etc.
20:57:30 <byorgey> Bfig_: all operators bind looser than function application.
20:58:11 <byorgey> Bfig_: I'm not sure what you mean by "parse left to right" through, I don't think it makes much difference in which direction you parse it
20:58:17 <byorgey> *though
21:00:55 <Bfig_> in case of composition... ohh but it is commutative, right? 
21:01:02 <Bfig_> big err... associative
21:01:43 <byorgey> right
21:13:23 <gienah> freedrull: maybe emerge -a dev-haskell/cabal-install might help, howeve I never actually use cabal-install
21:13:32 <gienah> sorry wrong channel
21:14:03 * hackagebot wai-app-static 0.0.1.3 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.0.1.3 (MichaelSnoyman)
21:19:56 <ddarius> lpsmith: That use of throwIO probably isn't the best thing.  You just need something that terminates the thread.  Hell, you could just block on an empty MVar as well.
21:25:14 <lpsmith> Hmm, does ghc garbage collect threads that are blocked on a GC'ed MVar?
21:25:42 <lpsmith> If so, that might be a real option
21:26:02 <lpsmith> I don't want to be causing space leaks though
21:27:27 <lpsmith> ddarius, why not just use killThread =<< myThreadId?
21:30:59 <lpsmith> ahh,  looking at the source of killThread,  basically the same thing
21:40:06 * hackagebot RBTree 0.0.4 - Pure haskell Red-Black-Tree implemetation  http://hackage.haskell.org/package/RBTree-0.0.4 (XingboWu)
21:42:52 <Anpheus> In GHCi is there a way to unimport the prelude?
21:43:04 <dmwit> :set -fno-implicit-prelude ?
21:43:46 <Anpheus> it said it was deprecated, recommended -XNoImplicitPrelude, thanks!
21:43:51 <Anpheus> would have taken me a while to find it
21:44:02 <Anpheus> hm that doesn't seem to have helped
21:44:08 <Anpheus> I imported Control.Category
21:44:16 <Anpheus> and now (.) is ambiguous
21:44:26 <Anpheus> Wat do? :P
21:44:29 <dmwit> After -XNoIP, do :m - Prelude
21:45:28 <dmwit> Actually, I guess you can do ":m - Prelude" regardless of whether ImplicitPrelude is on or off.
21:45:42 <dmwit> Sorry for the goose chase.
21:49:16 <Anpheus> odd
21:49:20 <Anpheus> that doesn't seem to work
21:51:22 <lpsmith> is there a way to change the working directory of cabal-install from /tmp?
21:51:31 <dmwit> Anpheus: Works here.
21:51:37 <Anpheus> really?
21:51:41 <Anpheus> I've tried:
21:52:33 <Anpheus> :module - Prelude then :set -XNoImplicitPrelude then :t (.)
21:52:38 <Anpheus> and I get an ambiguous occurence
21:52:43 <Anpheus> and doing a :reload does not help
21:52:58 <dmwit> Don't bother with the :set.
21:53:04 <dmwit> Do you have other modules loaded?
21:53:19 <dmwit> It's possible other modules are re-exporting Prelude's (.).
21:53:32 <dmwit> (The ambiguous occurrence error should tell you which one(s).)
21:54:00 <Anpheus> well the ambiguity is between Prelude.. and Control.Category..
21:55:14 <dmwit> It should say something like...
21:55:35 <dmwit> "Could be Prelude.(.), imported from Data.Function"
21:55:36 <dmwit> or so
21:55:47 <dmwit> But let me ask again: do you have other modules loaded?
21:57:43 <dmwit> Anpheus: Test this. Exit ghci. Then start it with no command-line arguments and do nothing but ":m - Prelude\n:m + Control.Category\n:t (.)"
22:02:28 <Anpheus> that worked
22:02:34 <Anpheus> wonder why it got stuck
22:03:13 <Anpheus> tomorrow I'll ask, how do I get Control.Category without dropping the whole prelude :P
22:08:58 <lpsmith> ddarius, I don't think that callCC will quite work for my purposes, sadly,  as it changes the ThreadId when it shouldn't
22:09:27 <lpsmith> I'll play with it more later though;  we'll see how far I can get with it
22:19:19 * fcr was wondering: what's the haskell equivalent for the C's fmod?
22:24:52 <lispy> hsc versus c2hs.  Discussion.
22:25:02 <lispy> :t fmod
22:25:02 <lambdabot> Not in scope: `fmod'
22:25:51 <lispy> fcr: if you need it and can't find it, it would be an easy ffi import
22:26:09 <geheimdienst> > 5.3 `mod` 2
22:26:10 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:26:10 <lambdabot>    `GHC.Real.Integral a'
22:26:10 <lambdabot>   ...
22:26:17 <geheimdienst> > 5 `mod` 2
22:26:18 <lambdabot>   1
22:26:24 <geheimdienst> > 5.3 `mod` 2.0
22:26:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:26:24 <lambdabot>    `GHC.Real.Integral a'
22:26:24 <lambdabot>   ...
22:26:27 <lispy> fcr: this thread probably contains an answer for you: http://www.haskell.org/pipermail/haskell-cafe/2007-September/031879.html
22:26:47 <dmwit> lispy: c2hs. End of discussion.
22:26:51 <fcr> ohh, great! thanks :)
22:27:34 <geheimdienst> shouldn't the magics of polymorphism allow a "mod" function that handles both ints and floats?
22:27:51 <dmwit> :t mod'
22:27:51 <lambdabot> forall a. (Real a) => a -> a -> a
22:28:00 <geheimdienst> :t mod
22:28:00 <dmwit> > 5.3 `mod'` 2
22:28:00 <lambdabot> forall a. (Integral a) => a -> a -> a
22:28:01 <lambdabot>   1.2999999999999998
22:28:15 <lispy> dmwit: I just read the c2hs user docs and two tutorials, but I don't get what it offers over hsc
22:28:36 <lispy> dmwit: it looks harder to use actually
22:28:42 <dmwit> Ah, the pipermail link mentions mod', too.
22:29:05 <dmwit> lispy: I like c2hs handling of struct peeks and pokes better.
22:29:37 <dmwit> I will admit that I don't know as much as I should about hsc to have as strong an opinion as I do.
22:29:40 <lispy> dmwit: so you use c2hs to define storable instances and you find that bit easier?
22:29:52 <fcr> > -1.3 `mod'` 2
22:29:53 <lambdabot>   -1.3
22:29:58 <fcr> > (-1.3) `mod'` 2
22:29:59 <lambdabot>   0.7
22:30:10 <fcr> :)
22:30:27 <fcr> it's not like fmod, but it's better
22:31:03 <dmwit> lispy: All I know is I have a friend that tried to write a binding to some C using hsc, and found that the standard best-practice for accessing struct fields was to write a C function that accessed it (!) and bind to that.
22:31:10 <dmwit> bleh
22:32:31 <lispy> dmwit: weird, hsc supports #peek and #poke
22:33:33 <ddarius> hsc2hs is clever.
22:33:50 <Maxdamantus> > sum $ zipWith ($) (take 1000 $ iterate ((/2) .) id) (0:0:0:cycle [0,0,1,1])
22:33:52 <lambdabot>   5.0e-2
22:34:31 <lispy> and how does hsffig fit in.  Looks like it generates hsc files
22:34:39 <Maxdamantus> > sum $ zipWith ($) (take 1000 $ iterate ((/2) .) id) (0:0:cycle [0,0,1,1])
22:34:41 <lambdabot>   0.1
22:34:43 <dmwit> lispy: Does #peek and #poke support structs, or only struct pointers?
22:35:30 <dmwit> Hm. Does that question even make sense?
22:35:33 <dmwit> Probably not.
22:36:31 <lispy> dmwit: http://haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
22:36:59 <lispy> #peek struct_type, field
22:37:26 <lispy> I see what your friend was talking about
22:37:28 <lispy> "A function that peeks a field of a C struct will be output. It will have the type Storable b => Ptr a -> IO b. The intention is that #peek and #poke can be used for implementing the operations of class Storable for a given C struct (see the Foreign.Storable module in the library documentation)."
22:38:15 <lispy> So, it's possible there are some performance reasons to not like that
22:39:13 <dmwit> Nah, c2hs does exactly the same thing.
22:39:38 <dmwit> (Though it is slightly more flexible in that it can go several fields deep at once.)
22:39:40 * ddarius usually just uses the raw FFI, and only uses things like hsc2hs for sizeof/offsetof/alignment.
22:40:15 <ddarius> c2hs is more "advanced" than hsc2hs in several ways, but is otherwise pretty similar.
22:40:19 <lispy> ddarius: That's "usually" what I do to (atually, I rarely need to make FFI bindings)
22:40:39 <lispy> I wanted to make a more substantial binding though (freetype2)
22:41:00 <lispy> Which has a lot of structs in their API
22:42:05 <lispy> as you can see here: http://www.freetype.org/freetype2/docs/reference/ft2-toc.html
22:45:32 <lispy> better, yet here is a list of all the symbols they define: http://www.freetype.org/freetype2/docs/reference/ft2-index.html
22:52:15 * hackagebot http-enumerator 0.5.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.5.1 (MichaelSnoyman)
23:11:42 <masak> I'm trying to understand arrows better.
23:12:01 <masak> the Wikipedia article gave me the definition, but I think I'd need a convincing example.
23:12:45 <Twey> masak: See HXT or Hakyll, maybe
23:13:16 <Twey> masak: http://www.haskell.org/haskellwiki/HXT walks you through the HXT arrow nicely
23:13:28 <masak> Twey: Hakyll is why I'm trying to understand arrows in the first place :)
23:13:35 <Twey> ⁵
23:13:52 <masak> Twey: I see that they're being used in Hakyll more or less as a build system.
23:14:08 * masak peruses the link
23:14:09 <Twey> Something like that
23:21:05 <masak> section 4.3 makes the comparison between arrows an Unix pipes. how deep would you say that analogy goes?
23:22:47 <masak> hm, I don't see immediately why <+> would be the dual of >>>
23:22:52 <roconnor> @hoogle String -> Integer
23:22:52 <lambdabot> Prelude read :: Read a => String -> a
23:22:52 <lambdabot> Text.Read read :: Read a => String -> a
23:22:52 <lambdabot> Prelude error :: [Char] -> a
23:23:04 <masak> is there a way to think about duals that helps seeing this more easily?
23:23:09 <roconnor> @hoogle base
23:23:10 <lambdabot> package base
23:23:10 <lambdabot> Text.Html base :: String -> HtmlAttr
23:23:10 <lambdabot> Text.XHtml.Frameset base :: String -> HtmlAttr
23:25:50 <roconnor> let s="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" in readInt 58 (`elem`s) (s!!)  "2MHnFNTcR8C3qg"
23:25:53 <roconnor> > let s="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" in readInt 58 (`elem`s) (s!!)  "2MHnFNTcR8C3qg"
23:25:54 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
23:25:54 <lambdabot>         against inferred type...
23:46:24 * hackagebot sbv 0.9.16 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.16 (LeventErkok)
23:46:26 * hackagebot system-uuid 2.0.0 - Bindings to system UUID functions.  http://hackage.haskell.org/package/system-uuid-2.0.0 (JasonDusek)
