00:05:12 <pastorn> does @pl know any applicative?
00:05:48 <pastorn> @pl (\c -> fmap (+10) (readDigit c))
00:05:48 <lambdabot> fmap (10 +) . readDigit
00:05:52 <pastorn> boo
00:07:53 <pastorn> what's Alternative? A weaker version of MonadPlus?
00:08:46 <pastorn> > many Nothing
00:08:46 <lambdabot>   Just []
00:08:54 <pastorn> > many (Just "hello")
00:08:58 <lambdabot>   mueval-core: Time limit exceeded
00:09:02 <pastorn> right...
00:14:28 <Axman6> :t many
00:14:29 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
00:31:57 <gaddafi> how do you permutate all lottery numbers? ;)
00:32:01 <mm_freak> pastorn: stronger, Alternative generalizes MonadPlus
00:32:32 <mm_freak> gaddafi: "permutate"? find all permutations?
00:32:37 <gaddafi> yes mm_freak 
00:32:40 <gaddafi> list them all
00:32:47 <mm_freak> > permutations [1..49]
00:32:48 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
00:33:09 <Jafet> > length (permutations [1..49])
00:33:12 <lambdabot>   mueval-core: Time limit exceeded
00:33:16 <mm_freak> > nub . map (take 6) . permutations [1..49]
00:33:17 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
00:33:17 <lambdabot>    arising from a use...
00:33:21 <mm_freak> > nub . map (take 6) . permutations $ [1..49]
00:33:23 <lambdabot>   [[1,2,3,4,5,6],[2,1,3,4,5,6],[3,2,1,4,5,6],[2,3,1,4,5,6],[3,1,2,4,5,6],[1,3...
00:33:43 <Jafet> Heh
00:33:49 <boegel> does ndm (Neil Mithchell) hang out in here?
00:34:12 <mm_freak> that's not too long
00:34:17 <mm_freak> only about 13 million
00:34:34 <mm_freak> but lambdabot won't reveal that =)
00:34:39 <mm_freak> > length . nub . map (take 6) . permutations $ [1..49]
00:34:43 <lambdabot>   mueval-core: Time limit exceeded
00:34:53 <pastorn> mm_freak: cool
00:34:55 <Jafet> > length . nub . map (take 2) . permutations $ [1..49]
00:34:58 <lambdabot>   mueval-core: Time limit exceeded
00:35:00 <pastorn> btw, reading that yesod page now
00:35:03 <gaddafi> not in scope. i get not in scope. im doing it wrong
00:35:06 <pastorn> mm_freak: feels like arrows
00:35:13 <mm_freak> pastorn: iteratees?
00:35:16 <pastorn> yes
00:35:25 <pastorn> the input type qualification bit
00:35:28 <mm_freak> they have nothing to do with arrows
00:35:50 <pastorn> mm_freak: but do you understand what i mean?
00:36:08 <mm_freak> yes, but that's not in any way unique to iteratees =)
00:36:13 <mm_freak> a lot of monads have input types
00:36:15 <pastorn> In arrows you can put up criterias on your input
00:36:25 <gaddafi> this fixed it http://stackoverflow.com/questions/1264113/failed-to-try-function-permutations-in-ghci-haskell
00:36:28 <pastorn> well, not on the 'a' in >>=
00:36:34 <mm_freak> you can do that in monads, too…  the difference is something else
00:36:41 <mm_freak> arrows are to functions what monads are to values
00:37:19 <mm_freak> monads compute an abstract notion of value, arrows compute an abstract notion of functions (or transformations)
00:37:45 <gaddafi> why is haskell so awesome?
00:38:08 <pastorn> gaddafi: because of liftM
00:38:12 <pastorn> i guess that's it
00:38:21 <pastorn> (well, it's buddies as well)
00:38:21 <mm_freak> gaddafi: no, why are commonly used languages so awful?
00:38:31 <Maxdamantus> s/'//
00:38:34 <mm_freak> pastorn: fmap, please
00:39:04 <shachaf> @vixen liftM or fmap?
00:39:04 <lambdabot> let's don't talk about that
00:39:06 <pastorn> fmap (fmap (fmap (fmap (fmap (fmap (fmap (fmap (fmap ( ...
00:39:12 * hackagebot persistent-postgresql 0.4.0.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.4.0.1 (MichaelSnoyman)
00:39:15 <mm_freak> > fix fmap
00:39:15 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
00:39:21 <pastorn> mm_freak: awww
00:39:36 <mm_freak> > fix (fmap f)
00:39:37 <lambdabot>   No instance for (GHC.Show.Show (f b))
00:39:37 <lambdabot>    arising from a use of `M5822714466...
00:39:46 <theorbtwo> fmap isn't that uncommon, in anything reasonably modern.
00:40:01 <pastorn> true, forall exists in lots of languages
00:40:05 <theorbtwo> Hm.  Or am I thinking of mapf...
00:40:08 <pastorn> *foreach*
00:40:13 <mm_freak> theorbtwo: it is commonly implemented, but not commonly used
00:40:20 <gaddafi> this is taking forever: length . nub . map (take 7) . permutations $ [1..35]
00:40:22 <theorbtwo> mm_freak: Fair enough.
00:40:28 <gaddafi> why?
00:40:38 <mm_freak> (also it's not exactly fmap, but just a functional version of foreach)
00:40:41 <shachaf> > product [1..35]
00:40:41 <lambdabot>   10333147966386144929666651337523200000000
00:40:47 <pastorn> yeah, if you write "map f (filter p xs)" in python people look down at you
00:40:51 <mm_freak> gaddafi: it needs to generate all values
00:41:01 <shachaf> gaddafi: Because it has to go through that many permutations.
00:41:17 <Jafet> > fix (fmap . Identity)
00:41:17 <lambdabot>   Couldn't match expected type `a -> b'
00:41:18 <lambdabot>         against inferred type `Data.F...
00:41:24 <gaddafi> i wanted those values output in sequence or something
00:41:32 <pastorn> they want you to use list comprehensions (gasp!)
00:41:45 <shachaf> pastorn: ?
00:41:45 <theorbtwo> Hm, if you write map {f $_} grep {p $_} xs in perl, people look up at you.
00:41:52 <pastorn> shachaf: python
00:42:00 <theorbtwo> (But note that you can get more efficency by combining the map and the grep).
00:42:18 <shachaf> Who are They and why do they want me to write in Python?
00:42:20 <mm_freak> gaddafi: 'permutations' is pretty lazy, but if you need the last permutation, you still need to skip all others
00:42:30 <mauke> map p($_) ? f($_) : (), @xs :-)
00:42:58 <pastorn> shachaf: i'm just saying that in python [ f x | x <- xs ] is prefered to map f xs
00:43:14 <shachaf> pastorn: Oh, I missed your last message.
00:43:17 <shachaf> Never mind.
00:43:20 <theorbtwo> mauke: Indeed.
00:43:25 <pastorn> (god knows why... maybe they hate it when people are familiar with the standard libraries)
00:44:09 <mm_freak> one of the python devs even wanted to get rid of reduce/map/filter
00:44:12 <Jafet> That's okay, no one cares about python here.
00:44:18 <mm_freak> stupid guy IMO
00:44:29 <shachaf> "I think dropping filter() and map() is pretty uncontroversial; filter(P, S) is almost always written clearer as [x for x in S if P(x)]"
00:44:46 <mm_freak> Jafet: add TCO and python is a pretty good FP language
00:44:56 <mm_freak> and some library functions, of course
00:45:08 <cathper> Let's have remove = not . filter then :-P
00:45:09 <Jafet> Guido doesn't want reduce, map, filter, or TCO.
00:45:20 <shachaf> Or reasonable lambdas.
00:45:31 <Jafet> I think we can safely ignore him and his innovative language
00:45:58 * shachaf has to write in Python occasionally.
00:46:09 * Maxdamantus tried writing his Python assignments partially functionally and ended up with really long lines :\
00:46:18 <mm_freak> a lot of people reject TCO
00:46:26 <mm_freak> note merely not implement it, but in fact reject it
00:47:13 <pastorn> mm_freak: well, if python doesn't have simple function composition, then dropping those functions isn't such a great loss
00:47:45 * Maxdamantus wonders if it's possible to put a newline somewhere in a conditional operation.
00:47:51 <mm_freak> pastorn: few FP languages actually use composition
00:47:52 <theorbtwo> In perl terms, caller() and TCO are incompatable, and caller() won.
00:48:05 <pastorn> mm_freak: haskell and F# does
00:48:12 <pastorn> i'm guessing ML and OCaml too
00:48:30 <theorbtwo> That is, the basic idea of TCO is that you forget who called you, so you can't have a function that returns that later.
00:49:40 <mm_freak> TCO is pretty good as an optional feature
00:49:51 <mm_freak> because not everybody on this planet is a debugger
00:51:41 <pastorn> > 12 <$ words "hello all you people"
00:51:41 <lambdabot>   [12,12,12,12]
00:52:27 <pastorn> how do i write >>= with applicative?
00:52:29 <pastorn> can i?
00:52:40 <shachaf> No, because then it would be Monad.
00:52:40 <pastorn> (or am i missing join?)
00:53:29 <pastorn> shachaf: yeah... :/
00:53:48 <shachaf> Don't be so gloomy. Nothing wrong with monads.
00:53:54 <pastorn> mm_freak: who was it other than you who helped out with my function pReg ysterday?
00:54:12 <pastorn> mm_freak: i don't have scrollback enough to check
00:54:21 <shachaf> @where logs
00:54:21 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
01:11:56 <accel> Laziness & Sharing. This is the N-th time I'm mentioning http://hackage.haskell.org/trac/ghc/ticket/917 ... but I feel like I finally understand laziness & sharing in GHC now. (PLesae correct the following if I'm wrong). When GHC seems the same varaible more than once in a function, it only evaluaves it the first time, and hsares it in the future. However, if ghc sees an expression duplicated; it does not share -- it evalutes it multiple times, to avoid s
01:13:29 <Jafet> In GHC, binding an expression to a variable causes it to be shared
01:13:42 <pastorn> mm_freak: http://codepad.org/cVHHHPdS
01:13:48 <pastorn> or anyone else for that matter
01:14:09 <pastorn> i'd try to get that applicative, but i can't, the list structure makes it kind of difficult :(
01:17:28 <accel> Jafet: hmm; how does that differ from what I said?
01:17:40 <accel> Jafet: (either I'm misunderstanding you; or our statements are equivalent)
01:17:49 <accel> Jafet: though yours is slightly more elegant
01:18:44 <Jafet> What you said got chewed in half, so I'm not sure
01:19:17 <frerich> Is there a ready made container type which has the size of the container hardcoded in the type (like a tuple) and which allows accessing its elements by index? I looked at Data.ARray and Data.Vector, but either type is only parametrized on the types of the index/elements, but not on the size of the container.
01:19:18 <mm_freak> pastorn: well, you have to keep track of that yourself ;)
01:19:38 <mm_freak> frerich: see the hlist package
01:19:43 <Jafet> The optimizer sometimes does CSE, which shares duplicate expressions anyway.
01:19:52 <frerich> mm_freak: hlist, hmm, thanks for that pointer, will check
01:20:17 <pastorn> mm_freak: awww... maybe i'll do some ((++) . (:[])) magic
01:20:26 <pastorn> mm_freak: for readibility
01:20:28 <mm_freak> pastorn: try to be more applicative
01:20:34 <pastorn> mm_freak: i tried :9
01:20:36 <pastorn> :(
01:20:47 <pastorn> but then i realized i wanted a [Bool] as a result
01:20:48 <mm_freak> your pBits parser can be implemented in a very applicative style
01:21:24 <mm_freak> accum <$> char '%' *> pBit <*> many pBitStep <*> pBit
01:21:28 <pastorn> mm_freak: i thought it could, but the thing with the last element being pBit and not pBitSep messess it up for me
01:21:51 <pastorn> accum :: a -> [a] -> a -> [a] ?
01:22:05 <mm_freak> that's homework =)
01:24:48 <mm_freak> pastorn: also try not to solve a nonexistent problem:  i think, 'bit' is better that 'pBit'
01:25:09 <mm_freak> but that's your personal choice
01:28:01 <pastorn> i don't :p
01:28:19 <pastorn> i know that all p* functions are :: Parser a
01:35:13 <kjellski> Any hints on how to test wether an argument was provided to Getopt::Long::Desciptive?
01:35:23 <kjellski> +or not
01:35:43 <shachaf> kjellski: Is that a Perl thing?
01:37:51 <kjellski> shachaf: yes, http://search.cpan.org/~rjbs/Getopt-Long-Descriptive-0.089/lib/Getopt/Long/Descriptive.pm
01:38:08 <shachaf> kjellski: #perl would probably know, then. :-)
01:39:29 <pastorn> mm_freak: shit, this is difficult!
01:39:33 <kjellski> shachaf: Sorry, I´ve not recognized that I´ve switched the channels ^^... my fault!
01:39:42 <pastorn> mm_freak: i have accum :: Maybe a -> [Maybe a] -> Maybe a -> [a]
01:40:10 <shachaf> pastorn: What are you trying to do?
01:40:22 <pastorn>     pBits = accum <$> (P.char '%' *> pBit <*> many pBitSep <*> pBit)
01:40:33 <pastorn>     Couldn't match expected type `a2 -> a1 -> Maybe a'
01:40:35 <pastorn>            against inferred type `Maybe Bool'
01:43:15 <frerich> mm_freak: Hmm, HList looks powerful. Unfortunately it seems I need to download it, and it also does quite a bit more than what I need (a homogenous list is fine). What I'm trying to improve is that I currently have a 'codeLength = 4' and 'type Code = [Color]'. I have assertions all over the place which verify that 'length code == codeLength'. I'm looking for ways to get rid of the assertions by improving the 'Code'
01:43:15 <frerich>  type so that it has a fixed length. I considerd using 'type Code = (Color, Color, Color, Color)' and that's almost exactly what I want except that I need to be able to access elements of a code by index. I just considered writing a custom list which always has a fixed size, but before trying to bend my brain to do that I'm looking for existing solutions. :-}
01:44:19 <shachaf> frerich: You could just use newtype Code = Code [Color]
01:44:35 <shachaf> frerich: And then only let people make a code through a "constructor" that checks the length.
01:44:41 <Axman6> man bzero
01:44:43 <Axman6> whoops
01:44:56 <frerich> shachaf: Hm that's an interesting idea
01:45:53 <shachaf> Also, if it's always just four elements, you can just make a function to index into it. :-)
01:46:04 <pastorn> i can't get it to typecheck :( http://codepad.org/DiK4bSl4
01:46:31 <frerich> shachaf: Well yeah, to be honest, I used a tuple at first. But I'd like to be able to extend the code length to 6, or 8. And it starts to get a bit ugly at that point. :-}
01:46:32 <ManateeLazyCat> frerich: Essential, HList is *Nested Tuple*
01:46:35 <pastorn> shachaf: ^^^
01:47:32 <ManateeLazyCat> frerich: Such like (A, (B, (C, D)))
01:47:47 <frerich> ManateeLazyCat: That's interesting, I considered the same approach to create an 'indexable' tuple. That's more powerful than what I need thought (my elements are all of the same type)
01:47:56 <frerich> ManateeLazyCat: but it's good to see that the idea wasn't so stupid after all :)
01:48:44 <ManateeLazyCat> frerich: I have program use Nested List to implement any number argument in function  
01:48:58 <ManateeLazyCat> frerich: Just *Nested Tuple* is enough.
01:49:05 <ClaudiusMaximus> frerich: the Vec package might have some ideas too (type-checked length for lists of homogenous elements)
01:49:26 <frerich> ClaudiusMaximus: Oh, is that something else than Data.Vector (I looked at that)? Let me hoogle...
01:50:24 <frerich> ClaudiusMaximus: Coolness, that looks promising
01:51:29 <ClaudiusMaximus> frerich: it's quite heavyweight though - at least it is if you need to write general type signatures...
01:52:35 <frerich> ClaudiusMaximus: It looks comprehensive, yes. It's some interesting food for thought though.
01:53:01 <pastorn> shachaf: could you look at my code a little?
01:53:19 <shachaf> What code?
01:53:31 <pastorn> http://codepad.org/DiK4bSl4
01:54:00 <pastorn> oh, oneOf = P.satisfy . P.inClass
01:54:03 <pastorn> all parsec
01:54:34 <pastorn> *attoparsec
01:57:06 <ManateeLazyCat> frerich: class YourClass a where; instance YourClass (a, b) where; After then, you just need write *every* type for YourClass, then you can write function to accept any number different argument list: FunA :: (a, b) ...; FunB :: (a, (b, c)) ...; FunC (c, (a, b)) ....;
01:57:39 <ManateeLazyCat> frerich: Then you can arbitrary number argument with arbitrary type.
01:57:44 <ManateeLazyCat> in your function.
01:57:56 <shachaf> ManateeLazyCat: I don't think that's relevant to frerich's problem?
01:57:59 <ManateeLazyCat> frerich: That's the power of *Nested Tuple*
01:58:19 <ManateeLazyCat> shachaf: I just seen frerich talk about HList
01:58:30 <frerich> ManateeLazyCat: I think it's a cool concept, maybe I need to use that somewhen. It's way more power than I need right now tho :-)
01:58:35 <ManateeLazyCat> shachaf: So i talk about *Nested Tuple*
01:58:56 <shachaf> ManateeLazyCat: Yes, LISP has *Nested Tuple*s too. :-)
01:59:14 <ManateeLazyCat> frerich: I just login, haven't seen your *real* problem, just talk about HList. :)
02:01:14 <frerich> ManateeLazyCat: Heh, well - as an exercise, I wrote a little text mode mastermind game in Haskell (my second standalone Haskell project, and the first one to use Cabal) - see https://github.com/frerich/mastermind/raw/master/mastermind.hs now I'm trying to improve this by making the types stronger. Right now I have e.g. a 'type Code = [CodePeg]' and 'codeSize = 4', and I need to do assertions everywhere to verify
02:01:14 <frerich>  that a given 'Code' is of length 'codeSize'. I considered using a tuple instead, but that didn't work out very well since I need to be able to access elements of a Code by their index.
02:01:41 <frerich> So I need a homogenous, indexable container type which has the length encoded in its type. At least I think that's what I need.
02:02:52 <shachaf> frerich: Yes, there are ways to encode it, but they're probably somewhat complex.
02:03:19 <frerich> shachaf: So far I like your idea of using a newtype and then a constructor very much :)
02:03:46 <shachaf> @wiki Smart constructors
02:03:46 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
02:03:55 <frerich> shachaf: That doesn't improve the type system but at least it centralizes the assertion
02:04:06 <shachaf> It's not that nice but it works.
02:05:40 <frerich> shachaf: That's a really neat link, I bookmarked it, thanks. In fact, it also explains how to do such constraint checking statically
02:05:47 <frerich> Pretty involved
02:05:51 <shachaf> Yes.
02:10:53 <pastorn> (*>) has the wrong fixity :(
02:11:19 <pastorn> for nice compositioning
02:30:31 <dMazz> I'm having trouble: "Could not find module `Network'", ghc-pkg check doesn't report anything.. running Ubuntu 10.04.2, installed haskell-platform from maverick universe, then updated ghc binary ghc-7.0.2-i386-unknown-linux.tar.bz2
02:30:56 <quicksilver> you can't update a ghc binary.
02:31:06 <quicksilver> ghc versions have to match haskell platform versions
02:32:55 <dMazz> ok, great.. how to reset ghc-/haskell-platform-installations?
02:35:52 <quicksilver> I'd reinstall the maverick universe ghc packages
02:37:04 <dMazz> trying with: apt-get purge ghc; apt-get install haskell-platform
02:38:44 <frerich> Hm, this is probably really dull, but I don't get it. I have a tiny file with two modules (http://hpaste.org/45030/parse_error_on_module ) but ghc yields a parse error on the 'module Main where' line. Did I misunderstand the layouting rules?
02:39:09 <shachaf> You can only have one module per file.
02:39:20 <shachaf> Alas.
02:39:51 <frerich> Really? Oh. Does that mean that '11.1 Qualified Names' in http://www.haskell.org/tutorial/modules.html is outdated then?
02:39:58 <frerich> (I took the idea from there)
02:40:25 <frerich> I also found http://hackage.haskell.org/trac/ghc/ticket/2428 but that was just closed as Won't Fix without elaborating whether the original bug report was valid or not.
02:40:53 <shachaf> frerich: "There is no formal connection between a Haskell module and the file system that would (typically) support it. In particular, there is no connection between module names and file names, and more than one module could conceivably reside in a single file (one module may even span several files). Of course, a particular implementation will most likely adopt conventions that make the connection between modules and files more stringent."
02:41:32 <frerich> shachaf: Hm, I guess I didn't realize that I'm not reading a ghc tutorial but a Haskell tutorial.
02:41:49 <shachaf> Closed as wontfix generally means that the described behavior happens, but won't be fixed.
02:43:17 <quicksilver> I see plenty of elaboration in that ticket.
02:43:51 <quicksilver> It seems to me that they agree with the filer, that the current error message is poor, but for boring architectural reasons it's hard to fix so they can't be bothered.
02:44:06 <quicksilver> (can't be bothered === believe limited resources better spent elsewhere, obviously ;)
02:44:57 <frerich> Yes, but I didn't see an explicit statement on whether it was correct to issue an error at all or whether the given code should be accepted by the compiler. It seemed that nobody questioned whether the code should be accepted (it shouldn't) but that contradicted the tutorial I was following (But now I realize it wasn't a ghc tutorial but a Haskell tutorial).
02:46:45 <quicksilver> It is correct (or entirely within GHC's purview) to issue an error.
02:47:04 <quicksilver> It might be interesting to have a way to have multiple modules in a file, but that's not what that bug report is about :)
02:47:08 <quicksilver> that bug report is just about the error message.
02:47:25 <quicksilver> I'd quite like nested modules, in point of fact, but someone has to make a proper proposal and implement it.
02:50:28 * hackagebot twilight-stm 1.2 - STM library with safe irrevocable I/O and inconsistency repair  http://hackage.haskell.org/package/twilight-stm-1.2 (AnnetteBieniusa)
02:51:42 <quicksilver> the issue - or part of it, at any rate - is the automatic module-finding behaviuors of --make
02:52:36 <shachaf> quicksilver: If a submodule of M had to be called M.Foo, that could still work, no?
02:53:18 <quicksilver> yes, nested modules would be easier than general multiple modules in one file
02:53:37 <quicksilver> M.Foo could be looked for in M/Foo.hs first, and then M.hs second.
02:53:52 <quicksilver> it would waste time compiling M.hs if Foo turned out not to be there, of course.
02:54:28 <shachaf> It wouldn't need to compile all of M.hs just to find out whether module Foo is in there.
02:58:08 <quicksilver> shachaf: in principle, no, although in practice it would require changes to the compiler to make it notice without compiling, I think
02:58:45 <quicksilver> the compiler does its first pass forwards, compiling as it goes, not reading the entire file at once.
02:59:23 <shachaf> It just needs to grep "module\s+Foo" before deciding whether to actually compile.
02:59:33 * shachaf is glad he's not in charge of GHC development.
03:02:46 <quicksilver> shachaf: funnily enough it's not quite that simple, but I suspect you know that :)
03:03:47 <dMazz> I rolled back my ghc to 6.12.1, but my experiments are failing.. http://hpaste.org/45031/installation_networkmodule_t
03:10:39 <quicksilver> dMazz: I think you need to force compilation
03:10:47 <quicksilver> actually no I don't
03:10:53 <quicksilver> I think you just need to pass --make to ghc
03:12:14 <dMazz> ah, thanks that did the trick :)
03:17:36 * hackagebot timers-updatable 0.2 - timers which are updatable in the remaining time  http://hackage.haskell.org/package/timers-updatable-0.2 (PaoloVeronelli)
03:41:36 <frerich> Hm, is there a module for working with types which encode peano numbers, like 'Z' or 'S(S(S Z))'? I'm struggling to write functions which yield an integer 'e.g. "toInt" for Z should be 0 and S(S(S Z)) should be 3. In C++ this was done using template metaprogramming, is something like that possible in Haskell as well?
03:42:43 <Axman6> it's extremely easy in haskell actually
03:43:41 <Axman6> data Peano = S Peano | Z; toInt (S n) = 1 + toInt n; toInt Z = 0; fromInt 0 = Z; fromInt n = S (fromInt (n-1))
03:44:21 <Axman6> that of course doesn't work with negative ints, but you shouldn't do that anyway
03:44:31 <frerich> That's not the same thing. This is a way to create peano *values*.
03:44:40 <Axman6> that's not the most efficient implementaton of toInt
03:44:54 <Axman6> well, you can also do it with GADT's:
03:45:24 <quicksilver> frerich wants Z and S(Z) to be types not values, Axman6.
03:45:30 <quicksilver> frerich: you make them members of a class.
03:45:46 <quicksilver> class Peano a where toInt :: a -> Int
03:45:53 <quicksilver> instance Peano Z where toInt _ = 0
03:46:07 <frerich> quicksilver: Ok, I'm glad you say that because that' show I started. The problem was writing the class instance for 'S a'
03:46:20 <frerich> quicksilver: (I modelled them as 'data Z = Z' and 'data S a = S a')
03:46:48 <Axman6> instance Peano a => Peano (S a) where toInt (S a) = 1 + toInt a
03:46:49 <quicksilver> instance Peano a => Peano (S a) where toInt x = 1 + (toInt (pred x)) where pred :: S a -> a = undefined
03:47:16 <quicksilver> no need to give the types representations, in fact.
03:47:17 <Axman6> quicksilver: those both work right?
03:47:21 <Axman6> sure
03:47:25 <quicksilver> should do
03:47:39 <quicksilver> "where pred :: S a -> a = undefined" is a good trick to know, though ;)
03:47:55 <quicksilver> although actually not quite correct as I wrote it
03:48:02 <quicksilver> where pred :: S a -> a; pred = undefined
03:48:04 <quicksilver> rather.
03:48:52 <frerich> Hm, let me read up what 'instance Peano a => Peano (S a)' means, I never saw a '=>' in that situation
03:48:57 <frerich> I always had 'instance x where...'
03:49:08 <quicksilver> it means S a is an instance of Peano as long as a is an instance of Peano
03:49:41 <frerich> Oh, much like with function signatures, makes sense.
03:49:53 <frerich> I didn't know you could use constraints on types like that.
03:49:57 <frerich> In this situation.
03:50:10 <osfameron> is Z-notation similar in intention/practise to Coq/Agda etc.?
03:50:26 <Axman6> class Peano a where toInt :: a -> Int; data Z; data Peano a => S a; instance Peano Z where toInt _ = 0; instance Peano a => Peano (S a) where toInt _ = 1 + toInt (undefined :: a) might do it, with the right extensions
03:50:31 <Saizan> Z-notation?
03:50:55 <quicksilver> Axman6: if you're going to use a type variable 'a' in a signature you need a forall . to bind it, I think
03:51:11 <quicksilver> and -XScopedTypeVariables of course.
03:51:23 <Axman6> quite possibly. i only started playing with this stuff this week :)
03:51:44 <Saizan> "data Peano a => S a" is exactly the same as "data S a"
03:51:48 <quicksilver> osfameron: this kind of implementation of numbers in the type system is more like a hack compared to Coq/Agda's more 'native' facilities.
03:51:54 <frerich> quickSilver: Is it possible to have the 'toInt' function without any arguments, calling the right version just by doing something like '(toInt :: Z)' or so (a bit like 'maxBound' works)?
03:52:01 <quicksilver> frerich: yes.
03:52:04 <Axman6> and i just followed the yellow brick "use the extension X to do this" ghc error road
03:52:04 <frerich> quicksilver: ...usign the same undefined trick you used
03:52:11 <quicksilver> frerich: it's just convenient to have the parameter. Not necessary.
03:52:48 <Saizan> well
03:53:08 <Saizan> the result of toInt can't be a simple Int if you don't want parameters
03:53:21 <Saizan> it might be a newtype Tagged a = T Int though
03:53:52 <quicksilver> Oh. Good pint.
03:59:38 <frerich> Is there a common name for a function which 'unwraps' a type (S a -> a)?
04:00:06 <frerich> I saw this pattern a few times now (the function always returns a dummy value, the whole point is to get the right type)
04:00:09 <ezyang> check out the newtype package. 
04:02:05 * frerich realizes he's still missing the other half, a function yielding a different type depending on a given Int, hum
04:02:41 <quicksilver> frerich: that's quite a lot harder :)
04:03:03 <frerich> Hm yes, I see that now. It somehow needs a new 'layer' for the compiler, since I'm actually programming the compiler I guess.
04:03:22 <quicksilver> you can make a function with polymorphic return type, but the type then gets chosen by the context
04:03:24 <frerich> but being able to create a new type from an int would be pretty neat
04:08:47 <Axman6> frerich: what you're after are dependant types, which GHC doesn't support, but languages like Agda and Coq do i believe
04:10:39 <mikolaj> :t iter
04:10:39 <lambdabot> Not in scope: `iter'
04:10:45 <mikolaj> :t iterate
04:10:46 <lambdabot> forall a. (a -> a) -> a -> [a]
04:10:53 <mikolaj> :t loop
04:10:54 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
04:11:01 <mikolaj> oops :)
04:11:06 <mikolaj> hi! where in the standard lib can I find something like
04:11:09 <mikolaj> iter :: Int -> (a -> a) -> a -> a
04:11:09 <mikolaj> iter 0 _ x = x
04:11:10 <mikolaj> iter k f x = iter (k-1) f (f x)
04:11:10 <mikolaj>  
04:11:14 <mikolaj> ?
04:11:23 <parcs> @type (!!) .: iterate
04:11:23 <lambdabot> forall a. (a -> a) -> a -> Int -> a
04:11:56 <parcs> i don't think that exists in the standard library
04:12:01 <Axman6> nope
04:12:13 <mikolaj> give me back my Fortran!
04:12:35 <pastorn> how about "no"?
04:12:47 <mikolaj> anywa, thanks, I thought I mush be missing something...
04:12:56 <parcs> @hoogle Int -> (a -> a) -> a -> a
04:12:56 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
04:12:56 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
04:12:56 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
04:13:09 <Axman6> in case you missed it, iter n f x = iterate f x !! n
04:13:39 <Axman6> which should fuse into as efficient as the hand roled version
04:13:44 <Axman6> rolled*
04:13:55 <mikolaj> oh, nice
04:15:16 <Maxdamantus> @hoogle Int -> (a -> a) -> a -> a
04:15:16 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
04:15:16 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
04:15:16 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
04:16:53 <Maxdamantus> @dz Int -> (a -> a) -> a -> a
04:16:53 <lambdabot>  Parse error at "->" (column 5)
04:26:08 <dblhelix> @seen copumpkin
04:26:08 <preflex>  copumpkin was last seen on #haskell 6 hours, 52 minutes and 29 seconds ago, saying: 5 `toThePowerOf` 7
04:26:08 <lambdabot> Unknown command, try @list
04:30:36 <mikolaj> err, parcs, and what is ".:" in "(!!) .: iterate"? can't find it either
04:31:39 <parcs> mikolaj: it's in functors
04:31:41 <parcs> the package, that is
04:31:49 <pastorn> mikolaj: iner n f x = (iterate f x) !! n
04:31:49 <mikolaj> ok, thank you
04:32:00 <mikolaj> yeah, I got it :)
04:32:02 <parcs> g (.:) f = \a b -> g (f a b)
04:32:23 <parcs> err, remove the parens
04:32:29 <parcs> from the left
04:32:29 <mikolaj> funny, that it's in functors, but I'll have a look, thanks
04:33:29 <parcs> well, it's abstracted to an operator on functors:
04:33:32 <parcs> :t (.:)
04:33:32 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
04:33:52 <mikolaj> ouch, now I understand :)
04:34:36 <mikolaj> you sure know how to scare a newbie :)
04:36:42 <mercury^> So (.:) 
04:37:00 <mercury^> = fmap . fmap
04:37:03 <mercury^> ?
04:37:18 <mercury^> (sorry for the many lines, not typing on my usual keyboard here)
04:38:43 <mikolaj> t: fmap
04:38:49 <mikolaj> :t fmap
04:38:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:38:57 <mikolaj> stupid bot
04:39:46 <mikolaj> :t (fmap . fmap)
04:39:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:40:35 <mikolaj> can types lie?
04:41:06 <parcs> no
04:41:10 <parcs> it's true
04:41:23 <frerich> In a sense, I find that 'Either' lies if the 'error' value is the right side :)
04:41:52 <parcs> :t [ (.:), fmap fmap fmap, fmap . fmap ]
04:41:52 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => [(a -> b) -> f (f1 a) -> f (f1 b)]
04:42:20 <mikolaj> ha, you got that prepared somewhere!
04:44:24 <mikolaj> now I have 7 cool ways to write that trivial function! Thank you everybody!
04:47:38 <frerich> Hrm, maybe I'm overcomplicating things. All this talk about peano types and whatnot was just to get rid of the 'size' value in my tiny 'Fixed List' module: https://github.com/frerich/mastermind/raw/master/FixedList.hs
04:48:02 <frerich> It's a module which wraps plain old lists, except that the constructor enforces a given size. I somehow wanted to be able to use a custom size in different situations.
04:54:01 <ezyang> Is it just me or is hackage.haskell.org/trac being really slow? 
04:54:12 <ezyang> I can't manage to log in. 
04:54:47 <FauxFaux> 404. ¬_¬
05:03:15 <mm_freak> frerich_: i find statically checked list sizes an exaggeration…  they are useful in agda, but not so much useful in haskell
05:03:56 <hpc> mm_freak: in any event, a statically checked list is a nested tuple
05:04:04 <mm_freak> and to really become useful you would need to do much work and sacrifice a lot of performance
05:04:27 <mm_freak> (reflection/reification)
05:04:39 <ian_mi> I have found them useful in doing linear algebra
05:04:42 <mm_freak> and then it's not really static anymore…  it's dynamic encoded as static
05:04:48 <ezyang> (a "yes it's broken for me too" would be useful too) 
05:05:17 <benmachine> ezyang: http://hackage.haskell.org/trac/ghc/ticket/4429 this link worsforme
05:05:20 <benmachine> +k
05:05:43 <ezyang> Yeah, viewing is ok. But I can't login... 
05:05:47 <mm_freak> ian_mi: they can be useful, but it's a case where you're demanding a feature, for which haskell is not powerful enough
05:05:54 <benmachine> oh right
05:06:06 <mm_freak> so you implement a DSL and its interpreter in haskell
05:06:51 <ian_mi> mm_freak: I mean, I have found the static dimension checking worth the constant struggle with haskell's limitations :)
05:06:51 <benmachine> (oddity: there are three GHC trackers :o http://hackage.haskell.org/trac/ )
05:08:02 <ian_mi> I'm sure I would be much better suited by agda, but unfortunately I do not know it and don't have time to learn it for a little while
05:08:15 <benmachine> mm_freak: I think it depends on how rich you want your API to be, I'm not convinced that it would be hard to get some basic level of assurance without loss of performance
05:08:30 <benmachine> ezyang: hasn't successfully logged in yet
05:08:37 <mm_freak> benmachine: as soon as the subject to check comes from IO you lose performance
05:08:52 <mm_freak> reification and reflection are expensive processes
05:09:57 <mm_freak> also you don't get more type safety…  you just move the responsibility to some central place (which is good, but not real static checking)
05:10:38 <mm_freak> if you have an error in your type-level stuff (which is completely untyped!), then you may have been better off just handling the exceptional cases in code
05:10:57 <mm_freak> after all GHC warns you about incomplete pattern matches =)
05:11:10 <mm_freak> and there would be nothing wrong with:  head :: [a] -> Maybe a
05:16:56 <benmachine> ezyang: hackage trac just errored at me
05:17:02 <benmachine> OperationalError: database is locked
05:18:06 <ezyang> ah, useful. 
05:43:55 <mightybyte> Anyone ever seen this error?  hGet: illegal ByteString size (-747031249): illegal operation
05:45:45 <ezyang> mightybyte: Sounds like you've overflowed bytestring's size fielld. 
05:45:48 <ezyang> how big data are you talking? 
05:46:20 <mightybyte> 3 gigs
05:46:30 <ezyang> yeah, sounds about right... 
05:46:32 <mightybyte> yep
05:46:33 <mightybyte> :(
05:46:47 <ezyang> I think there was a workaround... 
05:46:54 <mightybyte> Hmmmm, just ran across this.  http://osdir.com/ml/haskell-cafe@haskell.org/2009-08/msg00100.html
05:46:59 <mightybyte> I'll try it
05:47:07 <frerich> Odd that a size field is a signed 32bit value.
05:47:39 <ezyang> We're just using the native integer size. 
05:48:00 <mightybyte> Yeah, I guess for most cases that makes sense for efficiency reasons.
05:48:01 <frerich> Ok, but if it was unsigned, 3GB would fit :)
05:49:18 <dolio> Lots of GHC primitives use signed integers where unsigned would make more sense to me.
05:49:19 <ezyang> hmm, I wonder if we have an unsigned native integer. 
05:49:29 <earthy> Word32
05:49:34 <Axman6> Word
05:49:37 <ezyang> bleagh 
05:49:42 <ezyang> "Word to your Mother" 
05:49:57 <ezyang> Maybe it'd be more palatable if we added type Nat = Word :-) 
05:50:28 <Axman6> or more C friendly with type Uint = Word
05:50:31 <Axman6> :P
05:50:52 <earthy> otoh: using strict bytestrings for large stuff is somewhat dumb
05:51:04 <dolio> I don't know if Word# has always been around. Maybe the primops predate it.
05:51:19 <dolio> And it's a lot of work to change now.
05:51:45 <earthy> @hoogle Data.Foreign.CUInt
05:51:45 <lambdabot> No results found
05:52:06 <earthy> !autolart
05:52:18 <earthy> @hoogle CUInt
05:52:18 <lambdabot> Foreign.C.Types data CUInt
05:52:18 <lambdabot> Foreign.C.Types data CUIntMax
05:52:18 <lambdabot> Foreign.C.Types data CUIntPtr
05:53:33 <benmachine> dolio: I have a vague recollection that TH support for WordPrim came after support for other stuff, so maybe Word# is new
05:54:24 <earthy> plus, ISTR Int is not guaranteed to have more than 29 bits in Haskell.
05:55:01 <dolio> It's guaranteed to have more than that in GHC on presumably every architecture.
05:55:45 <earthy> the haskell'98 report requires Int to at least support -2^29 up to 2^29-1
05:57:25 <earthy> so that's 30 bits including sign
06:01:15 <Axman6> > (negate (2^29), 2^29-1)
06:01:16 <lambdabot>   (-536870912,536870911)
06:03:22 <RayNbow`TU> preflex: seen roconnor
06:03:22 <preflex>  roconnor was last seen on #haskell 10 hours, 31 minutes and 4 seconds ago, saying: @src interact
06:04:05 <Jesin> hmm, Control.Applicative contains this:
06:04:09 <Jesin> -- | One or none.
06:04:11 <Jesin> optional :: Alternative f => f a -> f (Maybe a)
06:04:12 <Jesin> optional v = Just <$> v <|> pure Nothing
06:05:18 <Jesin> I'm wondering why such a function would be in the library, like, what does it do or what is it used for?
06:05:57 <Jesin> ...hm, perhaps it would be clearer if the Alternative laws were actually in the documentation?
06:08:49 <earthy> Jesin: it allows for an optionally occurring 'effect' of the applicative
06:09:05 <Jesin> hm?
06:09:12 <Jesin> optionally under what circumstances?
06:09:34 <earthy> suppose the applicative is a parser
06:10:12 <earthy> then   optional parser    will transform this parser into one that need not consume input
06:10:12 <Axman6> if the argument fails (whatever definition of fails is for that Applicative), then it will return the Nothing case
06:10:49 <absentia> n/win shrink 4
06:11:35 <boegel> @seen ndm
06:11:35 <lambdabot> Unknown command, try @list
06:11:35 <preflex>  ndm was last seen on #haskell 95 days, 17 hours, 58 minutes and 51 seconds ago, saying: if you don't, then there was a parse error
06:11:42 <boegel> hmm
06:11:52 <boegel> ndm doesn't hang out in here anymore?
06:14:12 <Saizan> very rarely
06:14:31 <Jesin> hmm, where would I find the Alternative laws anyway?
06:14:33 <Jesin> :p
06:14:58 <Saizan> there aren't any in Control.Applicative ?
06:15:27 <Jesin> well
06:15:49 <Jesin> "A monoid on applicative functors.
06:15:50 <Jesin> Minimal complete definition: empty and <|>.
06:15:52 <Jesin> some and many should be the least solutions of the equations:
06:15:53 <Jesin>       some v = (:) <$> v <*> many v
06:15:55 <Jesin>       many v = some v <|> pure []"
06:15:57 <Jesin> that's all there is
06:16:00 <Jesin> http://haskell.org/ghc/docs/latest/html/libraries/base-4.3.1.0/Control-Applicative.html
06:16:11 <Jesin> I'm reading through the paper linked at the top of the page
06:16:26 <Jesin> haven't found the Alternative part yet
06:16:47 <Saizan> "a monoid on applicative functors" is already quite a bit
06:17:15 <Saizan> empty <|> m = m <|> empty = m; and (<|>) has to be associative
06:19:06 <Jesin> well, yes
06:19:18 <applicative> > [1,2] <|> [3,4]
06:19:19 <lambdabot>   [1,2,3,4]
06:19:28 <Jesin> are there any laws as to how empty and (<|>) have to interact with (<*>) and pure, though?
06:19:40 <ezyang> oh curious. I guess I'll omiti t for now. 
06:20:08 <Jesin> If not, why even include the Applicative f => Alternative f constraint?
06:20:23 <ezyang> mix 
06:20:42 <applicative> > [even, not.even] <*> [1,2,3] 
06:20:43 <lambdabot>   [False,True,False,True,False,True]
06:21:55 <kniu> is hackage down?
06:22:15 <quicksilver> fmap f empty = empty
06:22:23 <applicative> kniu Chrome says no
06:22:25 <mightybyte> Grrrr, switching to Data.ByteString.Lazy.Char8 didn't fix the problem.
06:22:31 <kniu> wait
06:22:33 <ezyang> I've been having some problems with that server. 
06:22:39 <quicksilver> fmap f (a <|> b) = fmap f a <|> fmap f b
06:22:42 <quicksilver> I'm pretty sure.
06:22:45 <kniu> why isn't there a standard treap implementation on hackage?
06:22:51 <quicksilver> possibly something do with pure.
06:23:18 <mightybyte> Maybe it only fixes it if the usage pattern never requires the whole bytestring to be in memory at the same time.
06:23:20 <applicative> > fmap even ([1,2]  <|> []) 
06:23:21 <lambdabot>   [False,True]
06:26:18 <benmachine> quicksilver: fmap f empty = empty looks like a special case of f <*> empty = empty, does the latter hold?
06:26:39 <mightybyte> Is there any difference between the laziness in String and that of Data.ByteString.Lazy.Char8?
06:27:04 <Jesin> "The moral is this: if you’ve got an Applicative functor, that’s good; if you’ve also got a Monad, that’s even better! And the dual of the moral is this: if you want a Monad, that’s good; if you only want an Applicative functor, that’s even better!"
06:27:08 <Jesin> lol, yay duality  :p
06:27:13 <benmachine> mightybyte: lazy bytestrings are pretty much a lazy list of strict chunks
06:27:18 <mightybyte> ...because my app that crashes when using ByteString worked fine when using String
06:27:37 <benmachine> mightybyte: what kind of crash?
06:28:03 <mightybyte> hGet: illegal ByteString size (-747031249): illegal operation
06:28:40 <benmachine> oh, this happens with lazy bytestrings too?
06:28:44 <mightybyte> Yeah
06:29:09 <Axman6> o.O
06:29:14 <mightybyte> I originally did it with strict bytestrings, but then I switched, and still have the problem.  Very strange.
06:29:23 <Axman6> > -747031249 :: Word
06:29:24 <lambdabot>   18446744072962520367
06:29:30 <Axman6> > -747031249 :: Word32
06:29:31 <lambdabot>   3547936047
06:30:09 <benmachine> mightybyte: where are you getting the bytestring from, some IO operation?
06:30:23 <quicksilver> benmachine: I suspect so. The paper probably says.
06:30:43 <benmachine> quicksilver: the original applicative paper, or was there a separate one for alternatives?
06:31:12 <mightybyte> benmachine: A file
06:31:39 <mightybyte> benmachine: Specifically, parsec's parseFromFile function.
06:31:47 <benmachine> ah, hmm
06:32:03 <benmachine> my guess would be a bug in parsec
06:32:27 <benmachine> or hmm maybe not
06:33:21 <benmachine> mightybyte: I would try reading the whole file into a lazy bytestring and seeing if that still causes a bug
06:34:01 <mightybyte> But doesn't it matter how I use it?
06:34:18 <benmachine> mightybyte: that is what my test is trying to determine :)
06:34:32 <mightybyte> Ahhh, ok.
06:34:42 <Skola> my .lhs programs (both with bird and latex notation) won't compile / :;
06:34:43 <benmachine> first, just try reading the file. if that does nothing upsetting, try 'last' on the result, to make sure it is all evaluated
06:34:46 <Skola> :l*
06:34:58 <benmachine> Skola: error being?
06:35:01 <Skola> it says "possibily an indentation problem"
06:35:07 <benmachine> parse error?
06:35:20 <Skola> ja
06:35:41 <quicksilver> benmachine: I meant the original paper but it doesn't seem to mention it.
06:35:56 <mightybyte> benmachine: That appeared to work.
06:36:11 <benmachine> Skola: try just '> main = return ()' in Main.lhs, see if that works
06:36:21 <mightybyte> benmachine: take 30 contents returned the right answer.
06:36:22 <applicative> mightybyte: you're using ...Parsec.ByteString.Lazy.parseFromFile, 
06:36:26 <applicative> ?
06:36:48 <applicative> I guess else there'd be a type violation somewhere
06:36:58 <mightybyte> applicative: Hmmm, it's from Text.Parsec.ByteString
06:37:20 <benmachine> mightybyte: not Text.Parsec.ByteString.Lazy?
06:37:21 <applicative> maybe that's the problem then?
06:37:31 <benmachine> mightybyte: are you absolutely sure you're using lazy bytestrings?
06:37:40 <applicative> there's a special lazy version of parseFromFile
06:37:45 <mightybyte> Pretty sure
06:38:05 <benmachine> how do you know?
06:38:07 <Skola> benmachine, it compiles
06:38:13 <Skola> I'll go through my syntax again
06:40:24 <mightybyte> benmachine: Ok, let me do some verification
06:41:20 <mightybyte> I guess the fact that I'm not getting a type error would suggest that it's not lazy.
06:41:26 <applicative> Skola: you have to maintain indentation.  Either >moo :: Int  or else > moo :: Int or else >  moo :: Int 
06:41:54 <Skola> ok applicative
06:42:17 <applicative> the number of spaces from > to code must be uniform.  it's the same with .hs files, you can start everything 36 columns in
06:47:53 * applicative is finding the new `Par` monad kind of dismal
06:49:06 <Axman6> how so?
06:52:02 <applicative> not sure, maybe it's just not familiar; but it seems a far cry from "just sprinkle `par` in suitable places and ...."
06:52:24 <applicative> will our imperative friends think it is just replicating their procedures for parallelizing?
06:53:22 <applicative> it is sure swamping both cores, though....
06:53:52 <mightybyte> benmachine, applicative: This is strange.  If I change "import Text.Parsec.ByteString" to "import Text.Parsec.ByteString.Lazy", I don't get a compile error.
06:54:35 <applicative> it's somehow indeterminate which you're using apart from that?
06:54:45 <mightybyte> ...even though I didn't change the ByteString type in any of my parsec rules.
06:56:27 <benmachine> mightybyte: parsec might just see bytestring as "a source of Word8s" and not care exactly which kind it gets
06:56:57 <mightybyte> applicative: Well, loading it in ghci and doing :i did indicate strict before.  But I was assuming the difference would cause a compile error.
06:57:50 <mightybyte> I'm running it again.  This time I'm 99% sure it's using the lazy one.
07:00:29 <applicative> is there some kind of absurdly cheap machine with a pile of small cores, somehow these parallelizing experiments on 2 cores seem stupid
07:01:28 <mightybyte> Get on the Intel multicore test machines?
07:02:10 <applicative> don't you have to be an academic cs person or student?
07:02:48 <mightybyte> No sure.  I think that bos or someone in the Haskell community has access.
07:03:07 <revenantphx> mightybyte: A quick search reveals AMD 6-cores for ~200
07:03:17 <applicative> don't think I can approach Intel with bos's credentials, quite :)
07:03:20 <revenantphx> Cheapest intel six-core's ~600 though :)
07:03:53 <mightybyte> applicative: How many is "a pile"?
07:04:02 <revenantphx> cheapest intel: http://www.newegg.com/Product/Product.aspx?Item=N82E16819115207
07:05:00 <applicative> mightybyte, I guess I was thinking of the shootout for example.  Maybe I'm in a state of illusion, but I was assuming the more cores I had the more I would comprehend the behavior of various strategies
07:07:35 <applicative> revenantphx: that is awfully cheap.  
07:08:01 * hackagebot hiernotify 2011.3.25 - Notification library for a filesystem hierarchy.  http://hackage.haskell.org/package/hiernotify-2011.3.25 (PaoloVeronelli)
07:08:29 <revenantphx> on the other end of the spectrum you have this beauty
07:08:29 <revenantphx> http://www.newegg.com/Product/Product.aspx?Item=N82E16819115079
07:08:33 <revenantphx> ._.
07:08:37 <illissius> amazon EC2 maybe? though that's prob better for simulating a cluster than a multicore
07:08:58 <illissius> "simulating"
07:09:14 <revenantphx> That beautiful thing has 12 virtual cores.
07:09:15 <revenantphx> ehehe.
07:09:29 <revenantphx> Alternatively if you need something with a lot of cores, see if you can do GPGPU.
07:09:33 <revenantphx> GPU's got plenty sitting around.
07:09:40 <revenantphx> OpenCL's fun too.
07:11:45 <applicative> "Intel Core i7-990X Extreme Edition Gulftown"  Gulftown?
07:11:47 <illissius> revenantphx: well, afaik the problem is benchmarking how GHC's parallel runtime scales
07:11:58 <revenantphx> mmk
07:11:59 <illissius> afaik it doesn't run on GPUs.
07:12:06 <revenantphx> my machine only has 4 virtual cores
07:12:09 <revenantphx> (2 physical ones)
07:12:35 <illissius> amd's bulldozer will have effectively twice the 'cores' at the same product-positioning point, as long as you're only doing integer math (not float), so that'll probably be good for this sort of thing. (cores which are a lot more 'real' than intel's hyperthreading)
07:13:12 <napping> That's not so clear
07:13:46 <illissius> napping: which part?
07:14:04 <napping> how well bulldozer will actually perform
07:14:23 <illissius> well i'm not commenting on that
07:15:13 <napping> I suppose it will give you a better idea of scaling, with more rigid division of resources
07:15:37 <illissius> i'm saying it'll effectively have twice as many cores in a much more real sense than HT -- each individual core could still suck and thus lose to whatever intel has opposing it
07:15:48 <illissius> right
07:16:46 <napping> With SMT, if you only run one thread it gets to use all the functional units
07:17:12 <illissius> whether and how far something scales further with hyperthreading and 'virtual cores' is pretty much a crapshoot as far as i can tell, and tells you not very much about what would happen if those cores were physical
07:17:18 <illissius> bulldozer should be more indicative
07:18:40 <napping> Maybe I'll get one - experimenting with parallelism is the only reason I can think of now for getting lots of cores
07:19:55 <applicative> what illisius is saying fits with what I was thinking and imagined I wanted. 
07:20:44 <jystic> Hi all, if I wanted to build a fast parser for C#, which tools should I be looking at? Alex/Happy?
07:21:53 <napping> "crapshoot" is a bit strong - the main point is that one or two threads in a core should perform about the same if your code has enough ILP, and the OS scheduler possibly picking virtual cores complicates things
07:22:19 <Axman6> I've got one of the latest sandy bridge i7's, and it's amazingly fast. doing some benchmarking with monad-par, and on this 4 core, 8 thread system, the fastest I'm getting n-bodies to run is with -N12
07:22:52 <napping> well, it's fair enough if you don't have authority to do things like pin threads
07:23:31 <djahandarie> I think Haskell should try to focus more on applying SIMD-type optimizations
07:24:27 <djahandarie> GHC*
07:24:34 <illissius> napping: i mean it doesn't tell you much about how well your algorithm scales when the number of threads is between NUMPHYSICALCORES and NUMVIRTUALCORES
07:24:42 <illissius> napping: is that wrong? i don't think it would be.
07:24:52 <lpsmith> djahandarie, yes, but there are also plenty of code-generation issues with GHC as is
07:25:15 <djahandarie> Let's add more! :p
07:25:47 <djahandarie> Maybe we can add it to YHC or UHC instead :p
07:25:48 <illissius> e.g. you might get extra scaling out the virtual cores and you might not, and whether it does tells you more about the processor than the algorithm
07:25:52 <illissius> anyway, bbiab
07:26:00 <lpsmith> At least with the native code generator,   it's often amusing to try to implement some low-level bit twiddling functions and then look at an assembly dump
07:26:14 <lpsmith> hopefully the move to llvm will alleviate that problem
07:26:19 <napping> illissius: I think you can expect to see little scaling in that range
07:26:29 <dolio> Add more code-generation issues?
07:27:04 <Axman6> napping: I'm seeing some quite interesting scaling in that range at the moment :P
07:27:49 <djahandarie> lpsmith, I think LLVM has some support for this stuff
07:27:59 <djahandarie> But I think you need to use different functions and such to make it actually happen
07:28:03 <napping> well, illissius is pretty much right - you'll see good scaling in there if your code has lots of memory latency to hide, little ilp and so on
07:28:04 * djahandarie isn't too versed in LLVM
07:31:46 <applicative> jystic, Did you take a look at the parsing machinery in the language-c package?
07:32:04 <jystic> applicative: yeah O
07:32:07 <jystic> oops
07:32:07 <lpsmith> djahandarie, dolio:  http://hpaste.org/45038/rounduppow2
07:32:13 <jystic> applicative: yeah I'm looking at that now
07:32:22 <lpsmith> if you want to be amused,  check out the assembly dump of that
07:32:30 <lpsmith> (with the native code generator,  -O2)
07:32:30 <djahandarie> lol
07:32:45 <lpsmith> it's not very good
07:33:30 <jystic> applicative: it looks like it has been around for quite a while though, I just wanted to check that happy/alex was still the best tool for the job
07:34:43 <jystic> I see that language-java uses alex for lexing, but uses parsec for parsing
07:35:35 <djahandarie> I don't think I would do that
07:36:56 <lpsmith> jystic, does happy support bytestring inputs yet?
07:36:58 <Axman6> jystic: we have much nicer parsing libraries than happy and alex
07:37:24 <jystic> lpsmith: I think the language-c library uses bytestring so it must do
07:37:41 <jystic> Axman6: what would you use for the job?
07:37:45 <Axman6> there's the sledgehammer parsec, which can parse practically anything, attoparsec which is super fast, but more restricted (and more aimed at bytestrings than text)
07:37:55 <lpsmith> If so,  it might still be useful,  as the nicer parsing libraries use different algorithms,  so it isn't exactly an apples-to-apples comparison
07:38:00 <Axman6> jystic: not sure, I've never written a parser for a programming language
07:38:24 <djahandarie> attoparsec can also parse practically anything but doesn't really focus on trying to do that
07:38:54 <Axman6> yeah
07:39:01 <jystic> any ideas on which would perform best?
07:39:02 <aavogt> @hackage bytestring-csv
07:39:02 <lambdabot> http://hackage.haskell.org/package/bytestring-csv
07:39:33 * aavogt couldn't write a monad parser that was quicker than alex in that package
07:39:50 <lpsmith> jystic, if you really want a serious parser,  I'd try writing a parser for some subset of the language you want to parse in say,  happy and attoparsec,   do some benchmarking,  and then share the result
07:39:54 <aavogt> slower by maybe 2x
07:39:58 <lpsmith> I think that would be rather interesting
07:40:16 <lpsmith> I'd definitely be interested in reading about your experiences :)
07:40:20 <jystic> lpsmith: not a bad idea
07:40:41 <aavogt> then again, bytestring-csv doesn't do all the escaping etc. desired
07:41:53 <jystic> aavogt: perhaps using alex for lexing and attoparsec for parsing will be the best option in the end
07:42:47 <lpsmith> or maybe a hand-rolled lexer with a happy parser will perform better :-P
07:43:26 <djahandarie> Or maybe a hand-rolled everything will perform better
07:43:45 <jystic> Or maybe a hand-rolled everything will be a nightmare to maintain :)
07:43:45 <lpsmith> djahandarie, I'm sure it would if you are willing to work hard enough
07:43:55 <hpc> hand-rolling is at least educational :P
07:44:07 * hackagebot zlib-enum 0.2.1 - Enumerator interface for zlib compression  http://hackage.haskell.org/package/zlib-enum-0.2.1 (MalteSommerkorn)
07:44:41 * jystic hand rolls a burrito
07:44:46 * jystic om nom
07:46:14 <lpsmith> heh
07:46:17 <lpsmith> http://hpaste.org/paste/45038/rounduppow2_annotation#p45039
07:46:31 * timestart extracts jystic's coburrito
07:47:27 <jystic> :)
07:49:49 <dolio> --ddump-asm doesn't seem to work with llvm.
07:49:56 <dolio> Er, -ddump-asm.
07:50:13 <dolio> The dumped LLVM code is just as bad, of course.
07:59:39 <boegel> has anyone in here ever used Hoogle as a library, from within a Haskell program?
07:59:57 <boegel> seems like the current version doesn't support it
08:08:36 <lispy> dolio: Sorry but you need to change your nick.  The plugin I use with pidgin picked light cyan for you and I can't control it.  I hope you understand... :)
08:09:12 <lispy> (Yes, I know I should use something else for IRC :)
08:15:10 <dolio> Oh shit, new yi.
08:16:06 <kissmynokia> what are the differences between RWH an Learn haskell your a greater good?
08:16:23 <quicksilver> LYAH is more focussed on teaching the language and has a more comic-book style
08:16:34 <opqdonut> rwh focuses on "advanced" stuff
08:16:41 <quicksilver> RWH is more focussed on solving typical real world problems
08:16:54 <quicksilver> you can read both online, make up your own mind which you like :)
08:17:02 <opqdonut> RWH is readable as ones first haskell book, but knowing the language already can be a bonus when reading RWH
08:17:51 <lpsmith> dolio, are you a yi user?
08:17:57 <kissmynokia> thanks
08:18:13 <dolio> lpsmith: No.
08:18:35 <lispy> RWH is still very basic though.
08:18:43 <dolio> I've never really gotten it working, not that I tried very hard.
08:19:08 <lpsmith> I've gotten it working,  but I'm not terribly convinced it's really going to fix my main complaints with text editors.
08:19:32 <dolio> I'm really kind of locked into emacs, what with the Agda mode.
08:19:41 <lispy> I think LYAH is a beginner book, RWH is intermediate, and we don't have much for advanced people (other than research papers which are very good)
08:20:05 <opqdonut> yeah, well put
08:21:18 <lispy> But, if make it through all of RWH you will know the language well enough to get real work done with it.  In fact, I don't even think you have to finish the whole thing.
08:21:59 <hpc> rwh is more of a reference than a tutorial
08:29:07 <frerich> Hm, if 'x :: Int' is a valid, what do you call "A", "B", and "C" in 'data X = A | B | C'? 'Data constructors seems a bit awkward. Is there a special name for an 'enum' type which hast just nullary data constructors?
08:29:16 <frerich> I'm tempted to say 'value', too.
08:29:22 <frerich> s/is a valid/is a value/
08:38:42 <lispy> hpc: Yeah, that's a good point
08:39:03 <lispy> I do want a book or reading list for topics that are more "advanced" than those in RWH
08:39:49 <lispy> Maybe a compilation of ICFP/POPL/PADL papers with details on when/why to read each.  Plus some expanded/cleaned up articles based on things in the haskellwiki.
08:40:31 <lispy> For example, AFAIK, there are no haskell books that explain when iteratees are appropriate or how to roll your own/use the existing
08:41:24 <hpc> lispy: and reworded to be easier to read, probably
08:41:30 <hpc> some of those papers are really dense
08:41:36 <lispy> yeah
08:41:44 <eikke> check TMR16
08:42:03 <lispy> eikke: for an iteratee article by John Lato?
08:42:33 <lispy> I always forget about that
08:42:35 <eikke> not sure by who, started reading it accidently last night
08:42:48 <eikke> "Iteratee: Teaching an Old Fold New Tricks by John W. Lato"
08:43:08 <lispy> Yeah.  I either read his draft or talked to him while he was writing it
08:43:34 <lispy> But still, I forget about TMR as a source of haskell knowledge :)
08:48:00 <MasseR> "What are the differences between RWH and LYAH" I prefer to think that they both complete eachother. Like quicksilver mentioned, LYAH teaches you the language (and quite deeply at some parts), while RWH glosses over some constructs. Then again RWH shows how to solve real life problems (like quicksilver again mentioned), whereas LYAH has at most little snippets of problems. I say; read both, it is worth it
08:48:15 <gloob_> eclipse-bugs
08:50:43 <frerich> How could I simplify '[zip [1..3] $ repeat col | col <- [1..3]]'?
08:52:33 <ion> > (,) <$> [1..3] <*> [1..3]
08:52:34 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
08:52:55 <ion> whoops, not the same
08:53:35 <djahandarie> > [zip [1..3] $ repeat col | col <- [1..3]]
08:53:36 <lambdabot>   [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)]]
08:54:26 <djahandarie> Well, you could not use a list comprehension
08:55:04 <Axman6> > flip (,) <$> [1,2,3] <*> [1,2,3]
08:55:06 <lambdabot>   [(1,1),(2,1),(3,1),(1,2),(2,2),(3,2),(1,3),(2,3),(3,3)]
08:55:17 <lpsmith> > [ (x,y) | y <- [1,2,3], x<- [1,2,3] ]
08:55:17 <lambdabot>   [(1,1),(2,1),(3,1),(1,2),(2,2),(3,2),(1,3),(2,3),(3,3)]
08:55:28 <ion> Still not the same. :-)
08:55:36 <lpsmith> oops
08:55:44 <lpsmith> > [ [ (x,y) | y <- [1,2,3]] x<- [1,2,3] ]
08:55:44 <lambdabot>   <no location info>: parse error on input `<-'
08:55:49 <lpsmith> > [ [ (x,y) | y <- [1,2,3]] | x<- [1,2,3] ]
08:55:50 <lambdabot>   [[(1,1),(1,2),(1,3)],[(2,1),(2,2),(2,3)],[(3,1),(3,2),(3,3)]]
08:56:10 <lpsmith> that's what I was thinking,  but then I oversimplified it when I actually got to typing it :-P
08:56:22 <djahandarie> > [1..3] >>= (:[]) . zip [1..3] . repeat
08:56:23 <lambdabot>   [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)]]
08:57:09 <lpsmith> I dunno if any of these are really "simpler",  but they are a little bit different anyway
08:57:29 <djahandarie> > ap (>>=) (return .: (. repeat) . zip) [1..3]
08:57:31 <frerich> lpsmith: I think your nested comprehension is pretty neat
08:57:31 <lambdabot>   [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)]]
08:58:16 <lpsmith> yeah,  still got it wrong though :D
08:58:24 <lpsmith> > [ [ (x,y) | x <- [1,2,3]] | y <- [1,2,3] ]
08:58:25 <lambdabot>   [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)]]
08:58:51 <ion> > ((<$> [1..3]) . flip (,)) <$> [1..3]
08:58:52 <lambdabot>   [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)]]
08:59:25 <frerich> Well, thanks again everybody for giving umpteen solutions to one problem. :-)
08:59:29 <hpc> haha
08:59:33 <lpsmith> haskell is good at that
08:59:42 <hpc> each less readable than the last
08:59:48 <ion> Haskell’s motto is TMTOWTDI after all.
09:01:41 <lpsmith> :t (.:)
09:01:42 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
09:02:41 <djahandarie> splitEvery 3 $ flip (,) <$> [1..3] <*> [1..3]
09:02:41 <djahandarie> [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)]]
09:03:17 <frerich> FWIW, this is for the function which decides whether a player won a tic tac toe game. I think I'm actuallly going to stick with 'zip' since I used that in the other tests of the function, too (see http://hpaste.org/45042/tictactoe_winner_test ). It lines up so nicely :)
09:03:21 <lpsmith> funny,  I've defined (sort of) the same function with the same name,  although not in all it's caleskell-like glory
09:03:44 <djahandarie> It's just (.).(.) with (.) = fmap
09:03:58 <ion> > groupBy ((==) `on` snd) $ flip (,) <$> [1..3] <*> [1..3]
09:03:59 <lambdabot>   [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)]]
09:04:12 <djahandarie> Heh
09:05:23 * frerich thinks some people here might enjoy a contest where a given function should be expressed using as many distinct prelude functions as possible
09:05:37 <frerich> I'm sure you could come up with some crazy alternatives to map (+1) [1..3]
09:05:39 <lpsmith> kind of the opposite of haskell golf
09:05:45 <hvr> What's the recommended monad for simulating the imperative 'return'-shortcut?
09:06:08 <ion> Either might work.
09:06:12 <djahandarie> Why would it need to be a monad?
09:06:14 <ezyang> hvr: continuation monad! >:-) 
09:06:30 <lpsmith> though I would think there would be enough identities that it wouldn't be that challenging,  you'd need some kind of ground rules that the prelude functions must be an "interesting" part of the solution
09:06:36 <hvr> ezyang: that one gives me non-local exits  as well, right?
09:06:58 <lpsmith> djahandarie, yeah,  my (.:) was equivalent to (.).(.)
09:07:07 <benmachine> ezyang: the answer to the question "what's the recommended monad"?
09:07:28 <benmachine> erm, "what's the recommended monad?" possibly
09:07:53 <lpsmith> and I think I came up with that name on my own,  and never really shared it with others.   So it's an interesting coincidence
09:08:07 <djahandarie> lol
09:08:21 <benmachine> :t fmap fix return
09:08:21 <ion> Or Maybe if your ‘return’ doesn’t need to return a value, just signify a failure.
09:08:21 <lambdabot> forall a. a -> a
09:08:37 <hpc> > fmap fix return 5
09:08:38 <lambdabot>   5
09:08:48 <hpc> :t fmap fix
09:08:49 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
09:09:05 <hvr> ion: actually I have a return value; I associated "Either"  more with the Error monad...
09:09:12 * frerich thinks it would be nice if 'any' was called 'anyOf' so that you could write 'playerOwns `anyOf` winningSets'
09:09:21 <djahandarie> hpc, 5 was a bad example :p
09:09:23 <hvr> ion: that's why I didn't think of it for returning the non-error short-cut return simply as Left
09:09:34 <hpc> djahandarie: :D
09:09:43 <hpc> > fmap fix return True
09:09:44 <lambdabot>   True
09:09:51 <djahandarie> > fmap fix return (error "INFINITY ")
09:09:52 <lambdabot>   *Exception: INFINITY
09:10:00 <djahandarie> Oh, huh
09:10:06 <hpc> > fmap fix 5 4
09:10:07 <lambdabot>   5
09:10:13 <djahandarie> :t fmap fix return
09:10:13 <lambdabot> forall a. a -> a
09:10:21 <djahandarie> Interesting identity function
09:10:25 <benmachine> fmap fix return = fix . return = fix . const
09:10:33 <lpsmith> well, by parametericity,  it's id if it terminates
09:10:47 <benmachine> = \x -> fix (const x) = \x -> const x (fix (const x)) = \x -> x
09:11:19 <benmachine> lpsmith: right
09:11:30 <lpsmith> isn't that the name of somebody's haskell blog?   yours, benmachine?
09:11:35 <djahandarie> Nah, sclv's
09:11:37 <djahandarie> I think
09:11:40 <benmachine> I don't have a haskell blog :P
09:11:45 <lpsmith> oh :)
09:11:47 <hpc> benmachine: you should :D
09:12:15 <benmachine> hpc: I'm not sure I have enough clever things to say!
09:12:18 <benmachine> but I could try
09:12:28 <hpc> does sigfpe ever come on irc
09:12:31 <hpc> ?
09:12:37 <lpsmith> ehh,  most people don't have very clever things to say on a regular basis
09:12:46 <benmachine> preflex: seen sigfpe
09:12:46 <preflex>  Sorry, I haven't seen sigfpe
09:12:47 <lpsmith> Myself included
09:12:50 <djahandarie> > fix . pure $ 3
09:12:51 <lambdabot>   3
09:12:54 <Saizan> preflex: seen dpiponi
09:12:54 <preflex>  dpiponi was last seen on #haskell 1 year, 14 days, 17 hours, 1 minute and 42 seconds ago, saying: Talking of IDEs, It's be fun to have an interactive code building environment like the way Coq works. I believe someone is working on something like that.
09:13:01 <Saizan> rarely :)
09:13:11 <hpc> hah
09:13:21 <lpsmith> sigfpe being one of those rare exceptions
09:13:36 <benmachine> ...I see what you did there
09:13:43 <benmachine> :P
09:13:45 <hpc> hahaha
09:13:48 <djahandarie> preflex, seen mmorrow
09:13:48 <preflex>  mmorrow was last seen on #ghc 1 year, 66 days, 13 hours, 19 minutes and 35 seconds ago, saying: * mmorrow is rtfm'ing
09:13:52 <djahandarie> :(
09:14:00 <lpsmith> indeed
09:14:22 <hpc> is mmorrow dead or something? :P
09:14:25 <djahandarie> Everyone says they are going to call him but no one ever does
09:14:37 <lpsmith> does anybody have his number?
09:14:40 <djahandarie> Yes
09:14:50 <djahandarie> Cale and copumpkin do I think, probably more people
09:15:07 <Saizan> i think copumpking contacted him or someone who knows him in person
09:15:25 <Saizan> and he's fine
09:15:41 <hpc> just really busy rtfm'ing
09:15:47 <djahandarie> That's good. Just busy I guess
09:15:55 <quicksilver> it was a long manual
09:15:58 <jmcarthur> i'm glad he's alright, but i'm still confused by the sudden disappearance
09:16:02 <quicksilver> and it had links to further reading material
09:16:13 <quicksilver> which pointed to some really interesting wikipedia pages
09:16:16 <quicksilver> some of which needed correcting
09:16:17 <quicksilver> ....
09:16:21 <djahandarie> And it ended up in a depth-first traversal of tvtropes
09:16:32 <Saizan> quicksilver: you seem to talk from experience :)
09:16:45 <hpc> djahandarie: i think you mean breadth-first
09:16:47 <quicksilver> Saizan: I studied for a phd. I know what it's like!
09:16:56 <hpc> depth-first i am fairly sure will end up being bottom
09:17:37 <Saizan> which is why our attempts to forcing mmorrow didn't get us any constructors
09:17:48 <hpc> > mmorrow
09:17:49 <lambdabot>   Not in scope: `mmorrow'
09:18:14 <hpc> @let mmorrow = error "RTFM Exception"
09:18:15 <lambdabot>  Defined.
09:18:18 <hpc> > mmorrow
09:18:20 <lambdabot>   *Exception: RTFM Exception
09:18:22 <hpc> :D
09:22:53 <jmcarthur> lol
09:25:03 <Layla_93> Hello o/
09:26:43 <Layla_93> I started learning haskell today =) I am having a small problem.. I am trying to write a simple script from a tutorial and keep getting errors, here is link to my script please advice :) http://pastebin.com/Qa3inyRY
09:27:29 <lpsmith> Layla_93, looks pretty good
09:27:38 <Layla_93> lpsmith: hi! :D
09:27:40 <lpsmith> the only problem that I see is that you have the indentation wrong
09:28:02 <lpsmith> your left ( needs to be aligned with th b
09:28:24 <Layla_93> lpsmith: oh.. kinda reminds me of python... 
09:28:31 <lpsmith> yeah :)
09:28:42 <Layla_93> lpsmith: trying again....
09:29:32 <Layla_93> ah! finally worked! yay! :D
09:30:30 <gwern> > 11 + 8 + 7 + 13 + 8 + 8
09:30:31 <lambdabot>   55
09:32:13 <lpsmith> yeah,  haskell indentation is a little funny,  but you get used to it pretty quick.   It's slightly different than Python's whitespace
09:32:43 <lpsmith> You also don't have to use indentation,  you can use { something ; anotherthing ; etc }
09:32:55 <lpsmith> but people rarely do that
09:33:17 <lpsmith> except maybe when dealing with lambdabot
09:33:47 <Layla_93> lpsmith: so actually knowing other languages helped :D
09:34:08 <aavogt> you can often get by with only braces or only ;
09:34:27 <aavogt> > case 1 of 2 -> 'a'; 1 -> 'b'
09:34:28 <lambdabot>   'b'
09:34:41 <djahandarie> Only braces? On one line?
09:35:02 <djahandarie> > case 1 of {{ 2 -> 'a' } 1 -> 'b'}
09:35:02 <lambdabot>   <no location info>: parse error on input `{'
09:35:05 <djahandarie> :(
09:35:10 <lpsmith> Layla_93, knowing more languages often help :)
09:35:39 <lpsmith> of course,  knowing more algorithms or more protocols or more tools also helps.   
09:35:45 <Skola> I'm pandoccing some lhs to html, and it's pretty sweet
09:35:47 <ion> Haskell indentation was completely intuitive to me from the first moment.
09:35:56 <aavogt> djahandarie: braces and newlines I guess
09:35:57 <Skola> but can I add like title (as h1) etc in the .lhs
09:36:04 <Layla_93> lpsmith: yesterday you told me my knowledge may get in the way, and it is kinda true.. haskell is so different! :)
09:36:06 <Layla_93> can you exaplain to me what is ; exactly in haskel? a line terminator like in other languages ?
09:36:12 <djahandarie> Ah. In that case you don't really need braces either
09:36:45 <lpsmith> Layla_93, I don't think I said that,  it must've been somebody else
09:36:47 <aavogt> djahandarie: named field syntax :)
09:37:04 <lpsmith> I wouldn't have said that;  I would have said something more like knowledge of Python *can* get in the way
09:37:27 <lpsmith> but only if you must understand Haskell purely through the eyes of Python and not in it's own terms
09:37:54 <benmachine> lpsmith: he did say 'may'
09:38:01 <djahandarie> Knowing other languages helps with critical thinking
09:38:06 <djahandarie> Not neccessarily recognizing pattersn
09:38:14 <djahandarie> You'll probably match things up to the wrong pattern
09:38:28 <benmachine> Layla_93: ; isn't exactly a line terminator in other languages, it terminates statements
09:38:33 <benmachine> in haskell it does more or less the same
09:38:50 <benmachine> except that in haskell it's more often declarations than statements
09:39:19 <c_wraith> I suppose it's only in do blocks that you would call them statements.
09:39:20 <Layla_93> benmachine: okey.. :)
09:39:40 <benmachine> c_wraith: yeah
09:40:38 <lpsmith> ion, I never had much trouble with Haskell indentation either,  except on a few counts
09:41:04 <lpsmith> I know the if-then-else issue threw me
09:41:06 <lpsmith> at first
09:41:34 <Layla_93> lpsmith: this is my first day with haskell, I am sure indentation is not the biggest problems here.. it seems to be a loooong way to really understand it.. maybe I will graduate by that time :D
09:41:45 <c_wraith> doesn't enabling Haskell 2010 make the if-then-else issue in do blocks go away?
09:42:30 <lpsmith> I haven't tried,  I know it was proposed.  Also, I'd like nondecreasing if-then-else outside of do blocks as well
09:43:04 <lpsmith> Layla_93, your first function was spot on.  
09:43:14 <Layla_93> About haskell versions, in perl when I need to use a feature of 5.12 for example, I have to declare that I am using version 5.12.. in haskell I hear there is haskell 2010 and coming haskell 2011.. is there some version dependent features?
09:43:45 <kmc> Layla_93, yes.  and there's many more features which are implemented by GHC but are not part of the Haskell standard
09:44:06 <kmc> unlike Perl, Haskell has a specification beyond "whatever the most popular implementation happens to accept this week"
09:44:35 <Layla_93> emm.. so I installed ghci-6.12.3 which comes with fedora.. is it considered recent? what is haskell 2010?
09:44:59 <lpsmith> I'm still using 6.12.3
09:44:59 <kmc> Haskell 2010 is a language specification
09:45:20 <kmc> it is not a piece of software
09:45:36 <Layla_93> kmc: ah okey..
09:45:44 <kmc> GHC is a piece of software (a compiler) which implements the Haskell 98 specification, and version 7 of GHC also implements Haskell 2010
09:45:57 <quicksilver> I don't think you're answering Layla_93's question
09:46:00 <kmc> however, GHC <7 lets you turn on most of the features which are new in Haskell 2010
09:46:04 <quicksilver> {-# LANGUAGE Haskell2010 #-}
09:46:19 <quicksilver> is the equivalent of the perl structure referred to.
09:46:34 <quicksilver> at the top of a file, it declares you want haskell 2010 features.
09:46:34 <lpsmith> You need to put that at the top of the file
09:46:43 <kmc> but you need GHC 7 for that
09:46:53 <kmc> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/ghc-language-features.html#options-language
09:47:10 <quicksilver> Right. GHC 6.12.3 supports most of Haskell2010, but GHC 7 is the first version to "officially" support it.
09:47:27 <Layla_93> quicksilver: now it is clearer :) 
09:47:36 <kmc> Layla_93, you'll find that a lot of the real-world "Haskell" code uses features that are in neither Haskell 98 nor Haskell 2010
09:47:43 <jmcarthur> ghc 7 is the first to support it *by default* also
09:48:00 <kmc> features that GHC unilaterally added to the language
09:48:01 <jmcarthur> Layla_93: typically you enable language features on a case-by-case basis
09:48:13 <kmc> (possibly supported by other compilers as well)
09:48:22 <jmcarthur> Layla_93: so for example, {-# LANGUAGE GeneralizedNewtypeDeriving, MultiParamTypeClasses, TypeFamilies #-}   and so on
09:48:53 <c_wraith> MPTCs and Type Families?  At the same time? :)
09:49:15 <jmcarthur> c_wraith: but not FDs!
09:49:19 <jmcarthur> :P
09:49:29 <c_wraith> Ah, ok.  I guess I can see some use for that combination, then :)
09:49:58 * jmcarthur wonders if he has any source files using both FDs and TFs
09:50:07 <Layla_93> jmcarthur: ah, so you mean like I kinda declare each feature I need, not that I declare that I need all the 2010 features, right?
09:50:19 <kmc> you can do either
09:50:34 <kmc> but 2010 only includes like 8 features beyond 98
09:50:36 <Ptival> is there some insight available on whether a language extension is "popular" or should not be used?
09:50:53 <jmcarthur> Layla_93: you can do either one, but i typically just choose the features individually because i'm going to end up doing most of them anyway
09:50:57 <lpsmith> Layla_93, honestly,  the first big lightbulb for me and Haskell was structural induction.   I don't think either LYAH or RWH covers that very well;  but algebraic datatypes,  recursion,  and structural induction should be high on your priority list of things to learn.
09:51:12 <kmc> and there are ~50 more features that are supported by GHC but not part of Haskell 2010
09:51:18 <jmcarthur> although since i mainly use GHC 7 these days, i probably leave out the few features that h2010 has over h98
09:51:21 <c_wraith> Ptival: I don't think there's anything centralized.  Mostly, though, avoid IncoherentInstances. :)
09:51:29 <Ptival> I'm always wondering, when ghc shouts at me "Use -XStuff..." whether I did something wrong or if I *really* should use Stuff
09:51:36 <lpsmith> that's one of the more fundamental aspects of Haskell
09:51:36 <kmc> yeah
09:51:42 <lpsmith> and CS, really
09:51:47 <jmcarthur> Ptival: yeah it helps to learn what those extensions do :)
09:52:04 <kmc> it's easy to go down some rabbit hole of bad design where you end up turning on UndecidableInstances and IncoherentInstances and UnreasonableInstances etc
09:52:10 <c_wraith> Ptival: well, if it's asking for OverlappingInstances, you probably should reconsider your design.  But UndecideableInstances is fine.
09:52:16 <kmc> when you can refactor to avoid any instances at all
09:52:35 <jmcarthur> UndecideableInstances can be a warning sign if you weren't expecting it though
09:52:53 <c_wraith> That's also true.
09:52:54 <kmc> this in particular happens when people carry over a design mindset from e.g. Java and then try to implement that in Haskell
09:52:55 <jmcarthur> *expecting to need it
09:53:04 <kmc> you end up with code which uses type classes much more heavily than is necessary
09:53:06 <c_wraith> Yeah, learn what those three extensions, in particular do.
09:53:17 <Ptival> jmcarthur: I guess so, whenever I decide to enable an extension I go look the doc and try to understand it so that I can "manage" what might break because of my choice :\
09:53:39 <jmcarthur> kmc: i actually use type classes very heavily, but not in a Java sort of way i guess
09:53:44 <Ptival> even if usually I'm a little bit clueless
09:53:47 <c_wraith> On the other hand, if it's asking for FlexibleInstances or FlexibleContexts, there's about a 99% chance you're not doing anything objectionable
09:53:49 <napping> most of the extentions break very little
09:54:01 <Ptival> ok
09:54:12 <kmc> yeah, Flexible* are just relaxing some somewhat arbitrary restrictions in the Report
09:54:20 <Layla_93> lpsmith: LYAH or RWH are the 2 only references that was recommended to me..  so what did you use to learn structural induction? is there a nother book you find very essential in addition to the 2 books?
09:54:24 <jmcarthur> i like to use polymorphism a lot because i find that in haskell it tends to actually make my code simpler
09:54:27 <roconnor> @seen RayNbow
09:54:28 <lambdabot> Unknown command, try @list
09:54:28 <preflex>  RayNbow was last seen on #haskell 47 days, 22 hours, 57 minutes and 38 seconds ago, saying: > (\x -> abs (x :: Int) >= 0) minBound
09:54:43 <kmc> structural induction isn't a Haskell concept, it's a fundamental math / CS concept
09:54:54 <kmc> i think i first encountered it explained well in TaPL
09:54:56 <kmc> @where tapl
09:54:56 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
09:55:00 <jmcarthur> because the implementation of a polymorphic function is more restricted than a monomorphic function
09:55:03 <lpsmith> Layla_93, I learned structural induction from "Introduction to Functional Programming using Haskell, 2nd ed" by Richard Bird
09:55:11 <lpsmith> TaPL is pretty dense :)
09:55:11 <kmc> "type classes: exploring the design space" is a good paper about extant and hypothesized type class extensions
09:55:31 <kmc> jmcarthur, that's a good argument for parametric polymorphism
09:55:37 <lpsmith> Layla_93, the book I gave you a link to, the Haskell Road,  covers it.
09:55:41 <kmc> breaks down for ad-hoc polymorphism
09:56:38 <lpsmith> I don't know how well,  but it does cover structural induction.   So does Graham Hutton's "Programming in Haskell",  the "Haskell School of Expression",  and a few others
09:56:43 <Layla_93> lpsmith: okey I will read it after I finish the first 2 books :)
09:56:58 <jmcarthur> kmc: it doesn't break down completely
09:57:21 <jmcarthur> kmc: (Foo a, Bar b) => a -> b    is still much more restricted than   Wibble -> Wobble
09:58:15 <kmc> well yeah
09:58:29 <jmcarthur> unless of course Foo and Bar expose everything about Wibble and Wobble
09:58:30 <kmc> it's a little more restricted than «FooDict a -> BarDict b -> a -> b»
09:58:34 <lpsmith> Layla_93, if your school offers a discrete math class, that might help too.   You probably won't cover structural induction,  but you will cover recursion and induction over the natural numbers
09:58:44 <lpsmith> (or at least should)
09:59:26 <lpsmith> and recursion and induction are two sides of the same coin:  recursion is a very powerful technique that can make seemingly difficult problems easy,  and induction is for reasoning about and understanding recursion
09:59:30 <c_wraith> My Discrete Math courses covered structural induction
10:00:08 <Layla_93> lpsmith: I am planning to study math in colleage so I will ask for it in school too :)
10:00:10 <lpsmith> c_wraith, yeah,  it's not unheard of, but it is less common
10:00:57 <c_wraith> Not that I really considered it anything fundamentally different from natural induction.  It's just the obvious generalization when you're working with more complicated shapes than natural numbers.
10:01:05 <kmc> i think most programming courses teach recursion as some advanced technique for wizards only
10:02:00 <c_wraith> I didn't even really understand why it was being given a different name.  It's all just induction.
10:08:37 <osoleve> if I have a function with type [a] -> a, what can I have it return when given an empty list?
10:08:51 <Martty> undefined
10:08:53 <Martty> or w/e it was
10:08:57 <c_wraith> osoleve: there's only one possible answer for this question
10:09:20 <c_wraith> osoleve: it can't return any value.  In denotational semantics, this is referred to as "bottom"
10:09:34 <osoleve> i thought you were going to say "42"
10:09:38 <osoleve> thanks for the info
10:09:49 <c_wraith> osoleve: There are a few ways it can be implemented..  It can be an infinite loop, or an exception-raising construct like undefined or error
10:10:06 <c_wraith> osoleve: but the key point is, there's no useable value it can return.
10:11:21 <kmc> osoleve, if you gave the function a more specific type you could return something
10:11:28 <kmc> like [Int] -> Int could actually return 42
10:12:05 <newgame> yesterday ezyang gave me the task to desugar do { st <- get; put st { a = 0 }; put st { b = 1 } } to understand the put action. I've written a solution / blog post (https://gist.github.com/887197). Could anyone skim through and tell his/her opinion or some mistakes I did?
10:12:12 <osoleve> meh, it's an exercise in RWH, i'm not going to fuss over it
10:12:12 <kmc> or even "[a] -> Maybe a"
10:12:16 <kmc> :)
10:13:45 <c_wraith> osoleve: well, if it's an exercise, it's actually useful to think about all these variations.  They're important details in why the more polymorphic a function is, the fewer choices it has.
10:14:56 <ezyang> newgame: It looks correct. I'm glad you figured it out by just desugaring the do-notation; if you want a deeper understanding, inline the get and put definitions :-) 
10:17:37 <newgame> ezyang: thanks. In fact, I inlined the get und put definitions but thought then removed them from the code since I thought the code became a bit too convoluted. Do you think I should add them anyway?
10:17:56 <ezyang> No, it's fine. 
10:18:04 <newgame> ok
10:18:18 <ezyang> Basically, you want to be thinking on the higher level of abstraction most of the time. But it is useful to dive down occasionally. 
10:18:20 <boegel> hiya peepz
10:18:46 <newgame> yes, your assignment really helped me to understand my problem
10:19:58 <boegel> is it possible to treat types as values in a Haskell program?
10:20:55 <Saizan> not directly, but you can reify most of them into a gadt
10:20:57 <cizra2> boegel: Probably not. Why do you want it?
10:21:13 <Saizan> which is what SHE does under the hood
10:21:17 <Saizan> @where she
10:21:17 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
10:23:00 <Saizan> well, it's more about bringing values into types, but the technique is the same
10:23:50 <newgame> ezyang: since you're a bit familiar with my old problem (https://gist.github.com/885062), I'd like to ask you another question: In order to allow a strategy to carry arbitrary state around, would it be a good idea to change
10:24:00 <newgame> data Strategy = Strategy { reset :: Code, guess :: Answer -> Code } to
10:24:07 <newgame> data Strategy a = Strategy { initialState :: a, reset :: State a Code, guess :: Answer -> State a Code }
10:24:31 <ezyang> Transforming it into monadic functions means that the strategy can affect the state. 
10:24:36 <ezyang> Decide if that expressivity is appropriate. 
10:26:47 <newgame> I think thats appropriate. I thought about stacking to State Monads together. The outer State is altered by the game, the inner state by the strategy. Therefore side effects from the strategy won't affect the simulation. Is that the right approach (is that even possible the way I imagine)?
10:27:33 <boegel> cizra2: I have same crazy plan in my head which uses hoogle and genetic programming :)
10:27:41 <boegel> cizra2: but I have no idea how to start
10:28:01 <boegel> cizra2: seems like I can't even use hoogle as a library, there's just no support for it
10:28:47 <c_wraith> newgame: it's possible.  Whether it's what you want or not is another question. :)
10:29:57 <newgame> c_wraith: alright. However, it sounds as if it is not what I want :). Would you have a suggestion for an alternative approach?
10:30:29 <c_wraith> newgame: not entirely, as I don't fully understand your domain, nor what expressivity you wish to allow.  And I'm kind of too busy at the moment to learn about it. :)
10:30:55 <newgame> ok, I understand that ;)
10:33:09 <revenantphx> So, now I'm curious.
10:33:18 <revenantphx> Quartz Composer is certainly functional programming,
10:33:22 <revenantphx> but does it qualify as FRP?
10:35:51 <jmcarthur> in the sense that its output is a time varying value computed from other time varying values, yes
10:36:03 <jmcarthur> but it's not really as powerful as it could be
10:36:31 <revenantphx> well, yeah
10:36:46 <revenantphx> I'm just thinking based on the fact that Random is really just an infinite noise distritbution.
10:36:50 <revenantphx> indexed by time.
10:38:22 <revenantphx> and that you can… rewind and such
10:38:27 <revenantphx> playing with time is fun :)
10:59:07 <tarrasch> Hello, Is there anywhere I can get the code in the RWH book?  (By code i mean simply the code they presented in the book, but I would like complete source files) 
10:59:37 <osoleve> once i'm done typing 'em up, sure ;)
11:01:04 <tromp__> :t ap(print.length)((putStr ": slowdowns 1+1/">>).print.head)
11:01:04 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `IO ()'
11:01:05 <lambdabot>     In the first argument of `(.)', namely `print'
11:01:05 <lambdabot>     In the first argument of `ap', namely `(print . length)'
11:01:38 <tarrasch> osoleve, I'm very curious about the end of chapter 16 in particular. It seems as if they assumed they have implemented code that's not even mentioned. In particular: where is the instanciating of WriterIO?
11:01:56 <tromp__> :t print
11:01:56 <lambdabot> forall a. (Show a) => a -> IO ()
11:01:59 <osoleve> tarrasch: I'm on chapter 3 :D
11:02:05 <tarrasch> osoleve, :)
11:02:30 <tarrasch> anyway, expect a roadblock at chapter 16 then :p
11:02:37 <osoleve> thanks
11:02:45 <tromp__> :t ap(>>)(print.length)((putStr ": slowdowns 1+1/">>).print.head)
11:02:46 <lambdabot>     Couldn't match expected type `IO a' against inferred type `[a]'
11:02:46 <lambdabot>     In the second argument of `(.)', namely `length'
11:02:46 <lambdabot>     In the second argument of `ap', namely `(print . length)'
11:02:52 <tromp__> :t ap
11:02:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:03:33 <tromp__> @pl \l -> foo l >> bar l
11:03:33 <lambdabot> liftM2 (>>) foo bar
11:04:52 <tromp__> :t liftM2
11:04:53 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:06:33 <tromp__> what are other (specialized?!) names of liftM2?
11:07:18 <tarrasch> tromp__, you mean like the equivelent for applicative?
11:08:06 <tromp__> for instance
11:08:25 <monochrom> liftA2
11:08:27 <Egbert9e9> what are the naming conventions of module names and their file names?
11:08:40 <Egbert9e9> i'm sure i'm not doing that
11:08:45 <Egbert9e9> doing that right, that is
11:09:31 <tarrasch> Egbert9e9, eh, I think that you should have Captial module names and the file name should be exact as module name, only ending with .hs
11:09:43 <monochrom> module name XX.Yy.ZZzZ => file name XX/Yy/ZZzZ.hs (or XX\Yy\ZZzZ.hs for windows)
11:09:46 <tromp__> @hoogle (b->b->b) -> (a->b) -> (a->b) -> a->b
11:09:46 <lambdabot> No results found
11:09:47 <Egbert9e9> that's what i'm doing
11:10:47 <tromp__> @hoogle (b->b->b) -> m b -> m b -> m b
11:10:47 <lambdabot> Data.IntMap unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
11:10:47 <lambdabot> Data.IntMap intersectionWith :: (a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
11:10:47 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
11:11:01 <Egbert9e9> what does "Failed to load interface for 'ModuleName':" mean?
11:11:30 <monochrom> which module is that? a module in an installed lib?
11:11:57 <Egbert9e9> no, the same dir the main file is at
11:12:30 <doserj> the .hi file is not readable? does not exist? is from a different compiler version?
11:12:43 <Egbert9e9> i've deleted all .hi files
11:13:18 <monochrom> I'm pretty sure we need more context.
11:13:48 <Egbert9e9> oh, when i compile the module it does this:
11:13:49 <Egbert9e9> (.text+0x18): undefined reference to `__stginit_ZCMain'
11:14:10 <doserj> --make
11:14:23 <mauke> -c
11:15:31 <monochrom> do people really like this "lateral thinking" guessing game?
11:16:02 <Egbert9e9> i'm sorry
11:16:54 <monochrom> "A person got on a train. The train entered a tunnel. When the train came out of the tunnel, the person was found dead. What caused the death?"  "You are allowed to ask any amount of yes/no questions until you figure it out."
11:16:58 <Egbert9e9> monochrom: are you talking about not pr0n or my request for help? i'll post the source into pastebin in a bit
11:17:37 <Egbert9e9> well, it's the euler project
11:18:13 <Egbert9e9> just 1-13, it hink
11:18:17 <Egbert9e9> i think
11:18:55 <Egbert9e9> one is (.text+0x18): undefined reference to `__stginit_ZCMain'
11:18:57 <Egbert9e9> err
11:19:00 <tarrasch> Egbert9e9, Project Euler 1..13? Forget compiling! Just use the interpreter, I strongly recommend you that.
11:19:12 <tarrasch> (use ghci, not ghc)
11:19:17 <Egbert9e9> tarrasch: i want to figure out how to write modules
11:19:19 <Egbert9e9> http://pastebin.com/kGeS23NJ
11:19:30 <Egbert9e9> these are the actual answers: http://pastebin.com/xec48KSU
11:19:38 <Egbert9e9> spoilers, i guess
11:20:21 <Scriptor> hi
11:20:27 <tarrasch> Scriptor, yo
11:20:33 <Scriptor> has anyone else gotten an email regarding lyah reviews?
11:20:35 <Egbert9e9> so the first imports problem3 and the second exports problem3
11:21:03 <BONUS> Scriptor: what kind of email???
11:31:30 <tarrasch> BONUS, hey, are you the lyah author? :)
11:31:42 <monochrom> yes
11:31:43 <Scriptor> noiam :p
11:31:57 <tarrasch> Awesome ^^
11:32:21 <Scriptor> I have to say, I've only read up to the modules section so far
11:32:29 <Scriptor> and just learned bits and pieces otherwise
11:33:30 <BONUS> tarrasch: yeah :)
11:37:02 <osoleve> BONUS: you're amazing. thanks for the great tutorial.
11:37:27 <BONUS> no, you are amazing. thanks for reading
11:37:42 <djahandarie> No, YOU'RE AMAZING
11:37:46 <mauke> did you mean: amusing
11:37:53 <BONUS> no, EVERYONE IS AMAZING!!
11:38:23 <Scriptor> group hug?
11:38:29 <osoleve> k
11:38:41 <ion> group kiss!
11:39:04 <osoleve> i'm not that kind of girl
11:39:10 <osoleve> or, any kind of girl. but w/e
11:47:27 <monochrom> group ghc and group jhc
11:49:20 <tieTYT> newb here, when I'm pattern matching on [[string]], how do I specify the head vs the tail?  can that be like [xs:rest]?
11:49:44 <shachaf> For a list with one element.
11:50:10 <shachaf> In general to pattern match a cons cell just do (x:xs), just like you always do.
11:50:55 <tieTYT> what does your first sentence mean?
11:51:04 <tieTYT> what if it has 2 elements?
11:51:10 <shachaf> Then that pattern won't match it.
11:51:15 <tieTYT> why not?
11:51:30 <shachaf> [1] is a list with one element. So is ["abc"]. So is [(xs:rest)].
11:51:55 <tieTYT> how would I match ["abc","def"...] ?
11:52:07 <shachaf> "abc":"def":...
11:52:34 <shachaf> [...] notation doesn't mean "hey, I want to talk about lists here". It's just a pattern.
11:56:05 <monochrom> desugar your "[xs:rest]" to (xs:rest):[] to see what it really means
12:08:48 <Egbert9e9> thanks, it worked
12:13:14 <intractable> Should I expect to be able to compile 6.8.3 if the only ghc I have around is 6.12.3? (because it doesn't seem to work)
12:13:52 <kmc> why do you want to compile 6.8.3
12:14:03 <intractable> because i need it ;)
12:14:12 <kmc> can you download a binary tarball?
12:14:22 <kmc> also, why do you need it?
12:14:22 <intractable> and the mac binary packages have bitten me in the past by overriding already-installed ghcs
12:14:33 <kmc> even with ./configure --prefix=/wherever
12:14:34 <kmc> ?
12:14:37 <intractable> kmc: i have a legacy app that trips a 6.12.3 bug
12:14:46 <kmc> what's the bug?
12:15:04 <intractable> kmc: the mac os x binary packages are distributed as 'installers' that stomp over other versions =/
12:15:08 <kmc> :/
12:15:13 <intractable> something like: http://hackage.haskell.org/trac/ghc/ticket/3771
12:15:41 <kmc> intractable, does it work in 6.10? what about 7.0?
12:15:53 <intractable> I haven't dug all that deeply into where the bug is showing up though
12:16:33 <intractable> kmc: haven't tried building 6.10 yet, but that's a good idea. would be very surprised if it works under 7 (the 6.12.3 is already verbose-warning-laden regarding forthcoming deprecations)
12:17:45 <tromp__> @pl \s -> " "++show s++"/"++show(succ s)
12:17:45 <lambdabot> (' ' :) . liftM2 (++) show (('/' :) . show . succ)
12:18:37 <beastaugh> https://github.com/beastaugh/hatt/blob/master/src/Data/Logic/Propositional/Core.hs#L12-17
12:18:47 <beastaugh> can anyone suggest how to make this datatype an instance of Foldable?
12:20:48 <Egbert9e9> tarrasch: why do you recommend on using ghci?
12:20:56 <Egbert9e9> :q
12:20:57 <Egbert9e9> err
12:31:19 <mzero> intractable - the current mac os x installers for Haskell Platform and GHC  do not remove prior versions
12:31:32 <mzero> however, symlinks in /usr/bin are overwritten to point at new ones
12:31:57 <mzero> and some symlinks, written by prior versions, were generated incorrectly so they fail - but the executables and libs are all still there
12:32:18 <mzero> that said, there is some finesse to getting multiple versions to cooexist on any platform, Mac included
12:32:46 <monochrom> there should be a high probability that a new ghc can build an old ghc
12:33:07 <monochrom> highest probability if the two versions are closest
12:33:51 <monochrom> if necessary, 6.12.3 -> 6.10.4 -> 6.8.x
12:39:17 <ymasory> hi. i just watched a video on higher-kinded types and i'm wondering if it's possible in haskell to have a map from option x to list x where the two xs are guaranteed the same for each entry
12:43:13 <augustss> ymasory: do you mean  Maybe a -> [a] ?
12:45:23 <ymasory> augustss: well no, i'd like a map where i can put the pair Some 5, [3,4] and Some "s", ["a", "b"] at the same time
12:46:20 <doserj> you mean a map as in Data.Map?
12:46:20 <augustss> Oh, i see.  Well those two have different type.  I don't think higher kinds will help you here.
12:47:09 <kmc> you can do that with existential types, but it's probably not what you want
12:47:33 <kmc> and probably not even then, if you mean something like Data.Map
12:47:41 <ymasory> kmc: why not? that's what was used in the scala video i saw
12:48:27 <kmc> well what use is a value (Some x xs) if you know nothing about the types of x and xs?
12:48:39 <kmc> all you know is that if x :: t then xs :: [t]
12:49:26 <solarus> is it enough if the mapping only accepts the two types you specified?
12:49:35 <kmc> maybe you shuold do  Map (Either Int String) (Either Int String)
12:49:44 <monochrom> hehehehe
12:49:52 <kmc> or say Map (Either Int String) (Either [Int] [String])
12:50:13 <c_wraith> These types make me want to curl up in the fetal position
12:50:33 <ymasory> solarus: no i'd want any entries at all so long as the list and option type match within a given entry
12:50:42 <kmc> then how do you use those entrieS?
12:50:50 <kmc> if they have totally unconstrained types
12:50:58 <monochrom> dependent-typely
12:51:07 <shachaf> unsafeCoerce
12:51:16 <monochrom> each look up returns a key, a value, and a type.
12:51:17 <kmc> instance Ord Dynamic where ...
12:51:20 <ymasory> kmc: that's a good point
12:52:10 <byorgey> ymasory: the usual approach in this situation is to make a type class encapsulating the operations you want to be supported, then make the existential wrapper enforce that type class constraint
12:52:11 <monochrom> or a constructive proof that no value is attached to the key in the map!
12:52:40 <byorgey> then when you pull things out of the map, you don't know their type but you do get a type class dictionary which you can use to do the supported operations.
12:53:06 <ymasory> byorgey: that makes sense. like kmc mentioned i'm not sure what you would do with an entry if they didn't even share a type class
12:53:20 <kmc> it doesn't have to be about type classes
12:53:32 <byorgey> ymasory: right.
12:53:36 <kmc> if you store exists a. (a, a -> a -> a, String -> a)
12:53:39 <kmc> then there's a lot yyou can do
12:54:14 <ymasory> right, not just type classes, but some information more than the maybe/list case i mentioned
12:54:48 <monochrom> those flexible-type languages (C in one way, Java in another way) have caused programmers to be lazy thinkers concerning "it could be ANY type".
12:55:21 <monochrom> the truth is you always have extra unsaid assumptions about your ANY type.
12:55:25 <dagle> Thats why I use Dynamic for all my code in haskell. :)
12:57:32 <monochrom> for example in the case of Java, you could say "the type is Object" but look at how many methods Object readily supports. You can "equal", you can "toString", you can "lock", you can "hash". that's a lot of assumptions, and your ANY type is not so arbitrary anymore, at least it has enough structure to be hashed.
12:58:32 <c_wraith> monochrom: some classes implement "hash" as "return 0;"
12:59:00 <c_wraith> It doesn't really take much structure for that implementation
13:01:48 <c_wraith> That implementation even satisfies all the mandatory requirements of the contract for the method.  (It is suboptimal at the suggestions in the method's contract, though)
13:01:55 <kmc> no requirement that it be a good hash
13:12:02 <tromp__> any code golfers here that can shorten the galloping horsemen code on http://www.haskell.org/haskellwiki/Blow_your_mind#Monad_magic?
13:14:02 <jmcarthur> i always wondered this but never asked... are rewrite rules normalized in any way to some extent before attempting to find places to apply them? e.g. is the rule  f . g = h  changed to  forall x. f (g x) = h x  ? likewise, is it only attempted on normalized-ish code?
13:14:21 * edwardk waves hello.
13:14:21 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
13:14:25 <jmcarthur> or is it perhaps attempted in various stages of normalization?
13:14:25 <edwardk> preflex: xseen cale
13:14:25 <preflex>  cale was last seen on freenode/#haskell 1 day, 4 hours, 31 minutes and 25 seconds ago, saying: should be okay now
13:15:25 <edwardk> preflex: xseen dolio
13:15:26 <preflex>  dolio was last seen on freenode/#haskell-blah 1 hour, 28 minutes and 39 seconds ago, saying: Heh.
13:15:49 <edwardk> dolio: welcome aboard!
13:16:14 <Botje> tromp__: that doesn't look particularly understandable
13:16:15 <djahandarie> Also planning on hiring Cale? :p
13:16:28 <c_wraith> I thought Cale already worked for them
13:16:29 <edwardk> he is definitely on the short list =)
13:16:30 <kanak> Hi, suppose I'm writing a logarithm function that takes in a base and the number to take log of. If i make its type log :: Num a => a -> a -> a, I am constraining both the base and the number to have the same concrete types right? E.g. base is an integer, the number will also be an integer?
13:16:36 <tromp__> no; it's not:(
13:16:38 <djahandarie> c_wraith, he works for iPwn
13:16:43 <edwardk> c_wraith: nah, i sent cale over to ryan at ipwn back in the day
13:17:14 <djahandarie> Back in the day being like, 7 months ago? :P
13:17:15 <edwardk> at the time i was doing defense contracting and his being a canadian citizen was a complication, now it'd just be visa issues
13:17:17 <c_wraith> oh.  I thought that's where you were now
13:17:34 <djahandarie> c_wraith, nope, now edwardk, copumpkin, and dolio now work at ClariFi
13:17:42 <edwardk> c_wraith: http://www.clarifi.com/
13:17:55 <edwardk> apoc	alisp and pchiusano as well
13:18:01 <edwardk> er apocalisp
13:18:11 <djahandarie> Oh, didn't know apocalisp worked there also
13:18:18 <djahandarie> And I have very little clue who pchiusano is
13:18:26 <edwardk> he doesn't show up much these days
13:18:34 <djahandarie> preflex, seen pchiusano
13:18:34 <preflex>  pchiusano was last seen on #haskell 165 days, 8 minutes and 10 seconds ago, saying: but thanks for the help :)
13:18:40 <edwardk> see? =)
13:19:02 <edwardk> he's over on #scala/#scalaz a fair bit though
13:19:08 <djahandarie> Must have been before I was active in here I guess
13:19:09 <tromp__> Botje, that code evolved from http://hpaste.org/45045/horsemen
13:19:15 <DevHC> ipwn workers: what's the status of that mobile game or something?
13:19:18 <Botje> tromp__: I would pull the concatMap and iterate into separate functions
13:19:35 <monochrom> horsemen?
13:19:36 <jmcarthur> DevHC: they're still going
13:20:00 <jmcarthur> that's all i've ever heard, officially
13:20:07 <geheimdienst> the four horsemen of the apocalisp?
13:20:34 <tromp__> different horsemen:)
13:20:48 <tromp__> Botje, that would make it clearer, but not shorter?!
13:21:35 <djahandarie> tromp__, you want golfing?
13:21:40 <edwardk> geheimdienst: hiring dolio puts us over quota
13:21:58 <tromp__> isn't golfing the same as code-shortening?
13:22:07 <djahandarie> It's a way to code shorten.
13:22:09 <DevHC> ROFL @ http://www.ipwn.com/starcraft2strategy/
13:22:23 <kmc> is ClariFi some kind of katamari which is attempting to roll up all the Haskellers?
13:22:29 <djahandarie> Haha
13:22:29 <edwardk> kmc: yes
13:22:37 <djahandarie> And force them to program in Scala...
13:22:37 <DevHC> imagine an epic fact: everyone playing SC2 would win 92% of their matches
13:22:48 <edwardk> kmc: i've been trying to get more haskellers in boston for years, this is just a continuation of that plot.
13:23:08 <djahandarie> Oh god, it's a sneaky move to convert all the Haskellers into Scalaers!
13:23:12 <edwardk> i still parse SC2 as star control 2, not starcraft.
13:23:31 <djahandarie> Or a sneaky move to remove all bugs from the Scala compiler
13:23:35 <edwardk> djahandarie: or it is a sneaky move to get overwhelming support to rewrite everything in Haskell instead
13:23:38 * monochrom wants deep-fried calamari!
13:23:41 <jmcarthur> how does scala compare to ocaml?
13:23:42 <edwardk> djahandarie: i'd settle for that
13:23:58 <DevHC> regular price: 65$, today' price: 47$. BUY NOW !
13:24:00 <edwardk> jmcarthur: i like it just a touch better than ocaml, but ocaml is a lot more stable
13:24:15 <monochrom> convert Vectors to Scalers?
13:24:29 <DevHC> that whole page is the biggest generic selling marketing page i've ever seen
13:24:40 <edwardk> devhc: the clarifi one?
13:24:46 <DevHC> ?
13:25:03 <DevHC> this one: http://www.ipwn.com/starcraft2strategy/
13:25:12 <kmc> scala's type system is a lot fancier
13:25:15 <kmc> fancier than haskell's too
13:25:16 <edwardk> ah
13:25:33 <kmc> i stopped eating calamari
13:25:39 <edwardk> devhc: lol
13:25:41 <jmcarthur> DevHC: you found something that is not ipwnstudios
13:25:45 <jmcarthur> and it's great
13:26:10 <edwardk> http://ipwnstudios.com/ is the one you want i think
13:26:16 <edwardk> its a damn sight less colorful though
13:26:24 <DevHC> ololololololo
13:27:16 <DevHC> one should sue the other for trademark infringement
13:28:10 <frerich_> evening
13:34:03 * hackagebot typography-geometry 1.0.0 - Drawings for printed text documents  http://hackage.haskell.org/package/typography-geometry-1.0.0 (PierreEtienneMeunier)
13:59:01 <tieTYT> check out my intersperse method: http://pastebin.com/N7qZwFhD
13:59:24 <tieTYT> is there a way to write the last pattern so I don't have to head and tail list?
13:59:48 <ddarius> edwardk is the katamari
13:59:54 <monochrom> intersperse d (y:z) = y ++ (d : intersperse d z)
14:00:08 <tieTYT> thinking
14:00:20 <hpc> tieTYT: lists are defined as
14:00:28 <hpc> data [a] = [] | a:[a]
14:00:38 <hpc> where (:) is the constructor
14:00:42 <hpc> so you can pattern match on it
14:00:54 <monochrom> indeed "intersperse d [xs] = ..." is sugar for "intersperse d (xs:[]) = ..."
14:01:28 <tieTYT> what I THOUGHT I was supposed to do was this: intersperse d [(x:xs)]
14:03:03 <monochrom> @type intercalate
14:03:04 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:03:04 <tieTYT> i think i get it, that's referring to the first element of it
14:03:12 <kmc> tieTYT, [(x:xs)] only matches a one-element list
14:03:19 <kmc> it matches a one-element list whose only element is a non-empty list
14:03:28 <tieTYT> ok thanks
14:03:38 <kmc> [x,y,z] is sugar for x:y:z:[]
14:03:41 <kmc> in both expressions and patterns
14:03:58 <shachaf> But not in types.
14:04:07 <kmc> yeah, [x,y,z] isn't a valid type
14:04:18 <tieTYT> yeah, it's the _nested_ list that is causing my confusion.  I get it now
14:04:19 <shachaf> Yes, but [x] is, and this causes confusion sometimes.
14:04:33 <monochrom> your job only cares about decomposing the outer list, so I am not sure what is the logic in examining inner lists such as "[(x:xs)]"
14:04:42 <hpc> moral of the story, don't use [x,y..] in patterns
14:04:45 <hpc> they confuse you
14:05:05 <tieTYT> hpc: but [x] is fine?
14:05:24 <monochrom> there is probably some cargo cult in thinking "list is involved therefore I must sprinkle "x:xs" everywhere!"
14:05:30 <shachaf> monochrom: People used to Prolog/Erlang syntax?
14:05:43 <Twey> Yeah, probably
14:05:44 <hpc> tieTYT: [x] counts too :P
14:05:45 <monochrom> and yeah prolog syntax should die die die
14:05:52 <kmc> i think that syntax in patterns is fine
14:05:59 <kmc> [x,y,z] looks exactly like the values it matches
14:06:05 <hpc> fair
14:06:12 <kmc> it's just not the case that whenever you match a list you need brackets
14:06:15 * Twey wonders why the Erlang people decided to base their syntax on Prolog.
14:06:25 <hpc> Twey: hysterical raisins, iirc
14:06:31 <kmc> there's no particular reason to think that would be the case
14:06:35 <kmc> but it's a common misconception
14:06:42 <ceii_> wasn't Erlang first supposed to be a Prolog dialect?
14:06:51 <ceii_> then they changed the plan completely
14:07:02 <Twey> kmc: Probably because in most of the places where list patterns come up (i.e. in function definitions) it is the case?
14:07:18 <kmc> f (x:xs) = ... -- isn't this a function definition?
14:07:25 <Twey> Yep
14:07:28 <Twey> Oh, wait
14:07:36 <Twey> I think we're using different values of ‘brackets’.
14:07:41 <kmc> oh, heh
14:07:47 <kmc> i mean the square guys: []
14:07:50 <Twey> Right
14:07:54 <shachaf> The round ones are parentheses.
14:07:56 <monochrom> I am not a square guy.
14:07:57 <frerich_> Is there any alternative to getting cabal on Mac OS X except by requiring all downloaded packages from hackage and building them in the right order?
14:08:14 <mzero> Haskell Platform?
14:08:15 <Twey> [square brackets] (round brackets) {flower brackets}
14:08:30 <ceii_> flower brackets is cute :o
14:08:30 <hpc> <angled brackets>
14:08:36 <Twey> ceii_: I've always thought so
14:08:37 <monochrom> there is a "bootstrap.sh" included in cabal-install's tarball
14:08:43 <Twey> ceii_: It's an Indian thing.  I adopted it.
14:08:44 <frerich_> mzero: This is with ghc 6.12.3 installed via homebrew
14:08:50 <hpc> (these are totally parens, though)
14:08:53 <Tomsik> curly brackets, dammit
14:09:00 <Twey> shachaf: Yeah, (parentheses) vs. [brackets] is daft
14:09:07 <frerich_> monochrom: Ah, d'oh! I guess I should have asked this before, I just finished building cabal myself (downloading dependencies as needed).
14:09:09 <mzero> well then, bootstrap.sh
14:09:13 <shachaf> Twey: Oh?
14:09:24 <shachaf> Twey: Seems to me that one word is better than two.
14:09:46 <Twey> (round brackets) still bracket (surround) the text, and both (round brackets) and [square brackets] perform parenthesis in English, but neither performs parenthesis in common programming languages
14:09:53 <Twey> With the exception of FORTH
14:10:17 <hpc> forth is silly though
14:10:29 <Twey> And I guess ML, but that's in conjunction with *, so it doesn't really count
14:11:08 <Twey> (not that either really counts as a *common* programming language)
14:11:24 <monochrom> wait, (1+2)+3 is not allowed in common programming languages?
14:11:25 <Twey> Amusingly, they *do* tend to perform *semantic* bracketing as well.
14:11:32 <Twey> monochrom: Sure it is
14:11:36 <Twey> But that's grouping, not parenthesis
14:11:57 <ceii_> Wikipedia says brackets vs parentheses is a US/UK thing
14:12:15 <monochrom> then what is "perform parenthesis"?
14:12:22 <kmc> Reserved Notation "x && y" (at level 40, left associativity).
14:12:22 <mzero> So many brackets to choose from: ⟦⟧ ⟨⟩ ⟪⟫ ⦃⦄ ⦅⦆ ⦇⦈ ⦉⦊ ⦋⦌ ⦍⦎ ⦏⦐ ⦑⦒ ⦓⦔ ⦕⦖ ⦗⦘ -- Enough for everybody!!!!
14:12:24 <Twey> Parenthesis is when you take something *out* of the expression, like a comment, so it's not part of the expression any more
14:13:08 <Twey> ‘Like a comment’ in my above sentence is inside what we call ‘parenthetical commas’ — they indicate that it's not a necessary part of the surrounding sentence, but just an additional comment for extra information
14:13:29 <mzero> "parenthetical" - "a parallel, separate idea"?
14:13:56 <Twey> mzero: Yeah
14:14:13 <Twey> From Greek meaning something like ‘put beside’
14:14:19 <mzero> nonetheless, I call them parentheses
14:14:29 <Twey> You're free to do so
14:14:34 <Twey> I'm free to call your usage silly ;)
14:14:46 <Twey> Anyway, waay off-topic now
14:15:24 <shachaf> Call English silly, please.
14:15:32 <Twey> English is silly
14:15:35 <Twey> But some parts are sillier than others
14:16:03 <monochrom> (: XQuery comment :)
14:16:36 <Twey> (?# regex comment)
14:16:54 <Twey> Eep, netsplit
14:30:03 <hh> whyf Arrow have a type of a b c ? Is not a supossed to be a unary function?
14:30:41 <sipa> :k Arrow
14:30:41 <lambdabot>     Class `Arrow' used as a type
14:30:42 <lambdabot>     In the type `Arrow'
14:30:46 <byorgey> hh: no, Arrow is a generalization of functions, which have both an input and output type
14:30:50 <djahandarie> (Arrow a) => a b c
14:30:56 <djahandarie> And (->) is an instance of Arrow.
14:31:09 <geheimdienst> hh, as i understand it, 'a' is often (->), so a b c can be read as b -> c
14:31:25 <djahandarie> Arrow should have really used a symbol
14:31:39 <geheimdienst> ... such as ~> ...
14:31:49 <hh> got it, so i can write a instance of arrow that is not a function?
14:31:52 <djahandarie> I think that's taken by Category
14:31:53 <Cale> Well, you can use a symbol, like  arr :: Arrow (~>) => (a -> b) -> (a ~> b)
14:32:04 <frerich_> geheimdienst: Ah, interesting. I recently wanted to do an exercise in RWH (explaining what 'second' in Control.Arrow does) and that signature confused me
14:32:04 <Cale> ~> is just an infix type variable
14:32:09 <geheimdienst> @instances Arrow
14:32:10 <lambdabot> (->), Kleisli m
14:32:13 <Cale> (like a)
14:32:23 <djahandarie> Cale, it is unfortunately not defined like that
14:32:28 <djahandarie> :t (&&&)
14:32:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:32:35 <geheimdienst> cale, 'a' is not infix 8)
14:33:16 <geheimdienst> frerich_: is RWH a good read about arrows? they have always confused me
14:33:22 <djahandarie> Oh nevermind, Category uses cat
14:33:49 <lispy> geheimdienst: Does it even cover arrows?
14:34:03 <kmc> i've been haskelling for about 5 years and have never found a use for Arrow in general
14:34:08 <kmc> i know there are some
14:34:16 <Cale> geheimdienst: Emphasis on variable
14:34:27 <hh> that would be my next question
14:34:30 <djahandarie> Doesn't Yampa use arrows in a non-standard way?
14:34:33 <kmc> some flavors of FRP, that one XML lib
14:34:37 <hh> what are they useful for...
14:34:39 <kmc> but it's really niche, compared to Monad or Applicative or anything else
14:34:40 <frerich_> geheimdienst: Oh I don't  know. I read up to chapter five (which did a big jump in difficulty IMHO), then went ahead and wrote a few little text mode games, then came back to RWH and mostly skipped chapter five. Chapter six is about type classes (which I understand) but then has these two exercises, in one go
14:34:44 <geheimdienst> the only thing i ever use is (&&&). on a good day i might be able to tell what (***) is
14:34:51 <sipa> :t (&&&)
14:34:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:34:58 <frerich_> "1.) What does (,) do 2.) What does second in Control.Arrow do". The first was very easy, the second was way too ahrd for me.
14:35:15 <byorgey> the other use I know of for arrows is in hakyll
14:35:19 <djahandarie> :t second
14:35:20 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
14:35:29 <djahandarie> frerich_, try replacing a with (->)
14:35:52 <monochrom> > second not ('x', False)
14:35:53 <lambdabot>   ('x',True)
14:35:53 <kmc> the problem with Arrow is that the requirement to implement "arr" severely restricts which things can be arrows
14:36:04 <monochrom> > second f (a,b)
14:36:04 <lambdabot>   Ambiguous type variable `c' in the constraints:
14:36:04 <lambdabot>    `GHC.Show.Show c'
14:36:04 <lambdabot>      a...
14:36:07 <kmc> i did one project where arrow syntax would have been handy, but was impossible for this reason
14:36:07 <monochrom> oops
14:36:39 <kmc> frerich_, it helps to read (a b c) as (b ~> c)
14:36:44 <kmc> (Arrow (~>)) => ...
14:37:23 <hh> ?
14:37:23 <hh> what is the name of ~>
14:37:27 <geheimdienst> imho another thing that keeps Arrow little-used is that its documentation is incomprehensible even by haskell's standards
14:37:45 <monochrom> the name of ~> is Chen Zhong-Quieh
14:38:03 <geheimdienst> monochrom: thanks for clearing that up
14:38:16 <monochrom> @quote monochrom <$>
14:38:16 <lambdabot> No quotes match. You speak an infinite deal of nothing
14:38:21 <monochrom> @quote monochrom von
14:38:21 <lambdabot> monochrom says: <$> is pronounced Jacquelin von Brionée
14:38:33 <geheimdienst> lol
14:39:01 <hpc> hh: (~>) is the symbol for categories that aren't functions, typically
14:39:20 * geheimdienst pronounces ~> as squiggle-tack
14:39:21 <hpc> hh: it can't be used in haskell because it doesn't start with ':'
14:39:24 <hh> i suposse <*> have a female name as well
14:39:31 <kmc> (~>) is just a type variable
14:39:37 <kmc> as are a, b, c
14:39:43 <geheimdienst> <*> is tick-splat-tack
14:39:45 <monochrom> no, that's Kuso Kamamoto
14:39:56 <kmc> (b ~> c) and (a b c) are the same up to renaming
14:40:00 <ion> The requirement to implement “arr”? Is it a Talk Like A Pirate Day?
14:40:22 <monochrom> arrow users are arr mateys
14:40:23 <hpc> @quote yarr
14:40:23 <lambdabot> hpc says: yarr, arr be rather arr-bitrary
14:40:31 <djahandarie> Haha
14:40:59 <gwern> @quote arrow
14:40:59 <lambdabot> dmwit says: It's not complete until you use monads, arrows, and currying
14:41:05 <geheimdienst> what does a pirate say when starting a sentence, then suddenly being hit in the nadgers? arr- ow!
14:41:12 <hpc> the terrible thing is, i wasn't fishing for a @quote when i said that
14:41:25 <ddarius> arr is largely what makes Arrow represent Freyd categories
14:41:37 <monochrom> @remember geheimdienst what does a pirate say when starting a sentence, then suddenly being hit in the nadgers? arr- ow!
14:41:37 <lambdabot> I will remember.
14:41:50 <hpc> http://comixed.memebase.com/2011/01/30/4-koma-comic-strip-pirate-jokes/
14:41:52 <hh> ok, thank you and bye people
14:42:30 <hpc> http://comixed.memebase.com/2011/03/03/koma-comic-strip-not-amused/
14:42:48 <LambdaSteel> Have a problem with type dependence...I think
14:43:18 <LambdaSteel> The is in http://hpaste.org/45048/type_dep
14:43:41 <LambdaSteel> and the error is attached at end
14:43:57 <basvandijk> Hello, is there a Cabal generated function like: 'packageVersion :: String' which returns the version number of the current package? 
14:44:17 <LambdaSteel> Could you guys help me with that?
14:44:39 <basvandijk> (I like to use such a function in the command line documentation of --version)
14:44:49 <adamvh> Bit of a n00b question ... does anyone know where to look for documentation on repa?
14:47:21 <int80_h> http://hpaste.org/45049/mapping_with_two_lists
14:48:07 <hpc> int80_h: zipWith
14:48:09 <hpc> :t zipWith
14:48:10 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:48:25 <hpc> :t sequence_ .: zipWith
14:48:26 <lambdabot>     Couldn't match expected type `[m a]'
14:48:26 <lambdabot>            against inferred type `[b] -> [c]'
14:48:26 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
14:48:40 <hpc> :t sequence_ .: (. zipWith)
14:48:41 <lambdabot> forall (m :: * -> *) a a1 b c. (Monad m) => (([a1] -> [b] -> [c]) -> [m a]) -> (a1 -> b -> c) -> m ()
14:48:55 <hpc> eh, something like that
14:49:54 <FelipeCeler> Does anyone use Haskell Plugin on Eclipse  ?  Eclipse FP 2.0 
14:50:58 <monochrom> "baz will take an element from [Foo], and one from [Bar] and return IO [Entry]"  does that mean baz :: Foo -> Bar -> IO [Entry] ?
14:51:21 <int80_h> monochrom: yes
14:51:42 <djahandarie> tromp__, oh, forgot to send this to you: mapM_(putStrLn.('1':).(>>=(\s->' ':show s++'/':show(s+1))).reverse.head).iterate(>>=(\l->[a:l|a<-[1..head l-1],all(\b->mod(a*a+a)(b-a)==0)l]))$pure<$>[1..]
14:51:51 <monochrom> then something about "zipWith baz"
14:52:01 <int80_h> monochrom: I'm stuck on visualizing on how to use the function. Which I want to sort out before writing it.
14:52:03 <djahandarie> Probably could shorten further if I thought about what it's actually doing
14:52:29 <monochrom> zipWith baz [a,b,c] [x,y,z] = [baz a x, baz b y, baz c z]
14:54:15 <hape01> with      sudo ~/.cabal/bin/hoogle server         I can start the hoogle webservice on port 80. But how can I do that this goes to background? Perhaps more an unix-topic... sory
14:54:42 <monochrom> sudo ~/.cabal/bin/hoogle server  &
14:55:10 <hape01> monochrom: i give it a try
14:55:36 <int80_h> monchrom: so that leaves me with a list of functions. Could I then exeute that by doing this map head [baz a x, baz b y, baz xz]?
14:55:46 <hape01> monochrom: But service terminates when I close the bash
14:56:04 <monochrom> sequence [baz a x, baz b y, baz xz]  or  sequence_ [baz a x, baz b y, baz xz]
14:56:34 <int80_h> :t sequence_
14:56:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
14:56:40 <int80_h> :t sequence
14:56:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:56:48 <monochrom> pretend m=IO
14:57:06 <int80_h> monochrom: could you articulate the differences in the type signatures of sequence and sequence_?
14:57:15 <int80_h> oooh!
14:57:32 <int80_h> I got it
14:57:34 <int80_h> I think
14:58:00 <int80_h> sequence_ is for when you don't care about the result of a function, just the side effect. Is that right?
14:58:06 <monochrom> yes
14:58:11 <int80_h> w00t!
14:59:47 <Philonous> int80_h: That's not quite right. The effect is part of the return value, nothing is happening to the side. 
15:00:22 <monochrom> int80_h's "function" does not mean function. pretend it says "action"
15:01:21 <monochrom> and I reiterate my "the empress's primary function is to produce a heir!" to justify still using the word "function".
15:02:32 <hpc> the function/action distinction is fairly crucial
15:02:49 <monochrom> hape01: perhaps "setsid sudo ~/.cabal/bin/hoogle server &" is better
15:02:55 <hpc> though actions are a subset of functions if you squint hard enough
15:03:21 <monochrom> well that depends on whether it's English function or mathematical function.
15:03:46 <ion> Running hoogle with sudo makes little sense IMNSHO. :-)
15:03:53 <geheimdienst> is the heir a side-effect or a return value?
15:03:58 <monochrom> the sudo is there for port 80
15:04:11 <hpc> monochrom: comparing english definitions to mathematical definitions is nearly a non-sequitur in these parts :P
15:05:12 <ion> monochrom: You mean what you normally do with setcap cap_net_bind_service=+ep?
15:05:44 <monochrom> I don't know setcap etc, but perhaps.
15:07:16 <Philonous> monochrom: In your sentence, "function" is a normative rather than a descriptive word and I don't see what purpose it servers in describing parts of a programming language  besides causing confusion.
15:07:54 <hape01> monochrom: perhaps "setsid sudo ~/.cabal/bin/hoogle server &" is better - - no unfortunately this exits the server also when closing bash... hmmmm
15:09:07 <monochrom> it may sound ridiculous, but I once ran into a case of success with "setsid setsid"
15:10:14 <monochrom> I still do not understand why it is not quite idempotent.
15:10:17 <geheimdienst> it does sound ridiculous ... :-o
15:11:25 <ion> Try setsid hoogle server </dev/null >/dev/null 2>&1. It may have an issue with the terminal standard output points to disappearing. And seriously, don’t use sudo. :-)
15:12:06 <monochrom> ah! you are enlightening.
15:12:33 <shachaf> Or run it with nohup?
15:12:47 <hpc> i wish there was a better way to run things on lower ports without being root
15:13:09 <int80_h> there is!
15:13:16 <ion> hpc: setcap cap_net_bind_service=+ep
15:13:16 <int80_h> I think dons had something to say about this
15:13:20 <hape01> shachaf: I tried nohup too - I had no chance.
15:13:37 <geheimdienst> how about setsid nohup?
15:13:41 <int80_h> I shall find this slideshow he wrote and give you the url
15:13:47 <shachaf> nohup setsid nohup setsid
15:13:53 <hape01> :-)
15:14:06 <ion> fix (nohup . setsid)
15:14:14 <hape01> ah now it gets functinoal
15:14:16 <hape01> functional
15:14:25 <int80_h> hape01: http://donsbot.wordpress.com/2010/08/17/practical-haskell/
15:14:26 <geheimdienst> nohup and setsid don't do the same thing, so i could imagine that you sometimes have to run both
15:14:30 <shachaf> Anyway, nohup is pretty similar to < /dev/null > /dev/null 2>&1.
15:14:32 <hpc> nohup is a neat command
15:14:46 <hpc> shachaf: nohup outputs to nohup.txt
15:14:57 <hpc> and writes in larger blocks too, iirc
15:15:01 <int80_h> dons has something to say about executing priviledged commands and how to use types to do it safely
15:15:08 <shachaf> The distinction isn't relevant here.
15:15:18 <hape01> I am impressed now
15:15:40 <hape01> didnt know about setsid until now
15:21:17 <Twey> Yay, GHC crash
15:21:25 <hpc> fun!
15:21:28 <hpc> those don't happen often
15:21:40 <Twey> My first, I think
15:32:31 <hape01> setsid noup emacs          - that works too :-) wonderful
15:34:14 <shachaf> > fix emacs
15:34:15 <lambdabot>   vi
15:36:32 <Entroacceptor> erm
15:37:20 <dainanaki> I
15:37:30 <monochrom> Robot
15:37:36 <c_wraith> > emacs "ted"
15:37:37 <lambdabot>   Not in scope: `emacs'
15:37:51 <c_wraith> hmm, must be a special case
15:37:54 <c_wraith> > fix lambdabot
15:37:55 <lambdabot>   Not in scope: `lambdabot'
15:37:58 <lpsmith> erg,  createDirectory throws an exception if the directory already exists
15:38:22 <monochrom> clearly, the criminal @undefine'ed promptly to leave no evidence :)
15:39:12 <dainanaki> I have a transformer stack of the type ParsecT String u (Writer String) and I'm trying to figure out how to tell stuff to the writer monad, but I am having difficulties. I thought just using tell would work, but I get the error:  "No instance for (MonadWriter
15:39:12 <dainanaki>                        [Char] (ParsecT String u (Writer String)))
15:39:13 <dainanaki>       arising from a use of `tell'"
15:39:13 <monochrom> createDirectoryIfMissing if you're really into that.
15:39:20 <dainanaki> Could someone help me out?
15:39:58 <monochrom> lift (tell "stuff")
15:40:18 <shachaf> monochrom: Which would catch the exception?
15:40:41 <lpsmith> is there a way to write a TH macro that expands into the current file name and line number?
15:40:42 <shachaf> It should just return a boolean or Maybe or EEXIST or something.
15:40:45 <monochrom> I don't know how createDirectoryIfMissing does its job
15:40:53 <shachaf> Oh, that already exists.
15:40:57 <dainanaki> Oh, silly me. Thanks
15:41:43 <josh04> Hi, I'm having severe difficulty getting ghc to agree to having the character  ¬ in a source file. Can anyone help?
15:42:05 <shachaf> > let (¬) = not in (¬) True
15:42:05 <lambdabot>   False
15:42:20 <Twey> josh04: Should be fine, so long as you're saving the file in UTF-8
15:42:32 <lpsmith> monochrom, is createDirectoryIfMissing defined, or do I have to do that myself?
15:42:32 <monochrom> tell us your OS, your locale environment variables, your ghc version
15:42:43 <shachaf> lpsmith: Apparently the latter.
15:42:48 <shachaf> s/latter/former/
15:43:00 * shachaf reads backwards today.
15:43:05 <monochrom> @hoogle createDirectoryIfMissing
15:43:05 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
15:43:13 <lpsmith> oh
15:43:18 <lpsmith> Yeah I can't use that
15:43:31 <monochrom> then use exceptions
15:43:32 <josh04> I'm using Windows 7, ghc 6.12.3, and locale is n/a in windows
15:43:33 <lpsmith> I'm looking in System.Posix,  I need to set permissions at creation time
15:44:23 <monochrom> ah, too bad the System.Posix.Directory doc doesn't say which exceptions are thrown
15:45:28 <monochrom> I forgot how to switch ghc into utf-8 mode (if it needs be done manually) on windows
15:45:54 <monochrom> but yeah first positively prove that your file is in utf-8 first
15:46:18 <sm> ghci> writeFile thefile "¬" ?
15:46:56 <monochrom> that still depends on which mode ghci is in. no guarantee at this rate.
15:48:43 <monochrom> oh, on windows, your code page controls it.
15:49:04 <monochrom> chcp 65001  for utf-8 goodness
15:49:18 <monochrom> windows-1251 should die die die
15:49:36 <djahandarie> s/-1251// will also solve these problems
15:49:53 <josh04> Will try :)
15:49:58 <monochrom> someone please remind me "code page" next time windows is brought up!
16:04:04 <josh04> Okay, ghc is working but alex is segfaulting on UTF-8 files. Any advice?
16:07:30 <outsid3r> why this does not work:
16:07:39 <outsid3r> myMinimum :: Ord a => [a] -> a
16:07:39 <outsid3r> myMinimum (x:y:xs) = if null xs then
16:07:39 <outsid3r> 						if x < y then x else y
16:07:42 <outsid3r> 					 else
16:07:45 <outsid3r> 						if x < y then x : myMinimum xs else y : myMinimum xs
16:07:48 <Twey> Hmm, compiling things with -v3… just like Gentoo
16:08:05 <shachaf> @paste, outsid3r
16:08:05 <lambdabot> Haskell pastebin: http://hpaste.org/
16:08:30 <Twey> outsid3r: Type mismatch
16:08:44 <outsid3r> Twey: ?
16:08:51 <Twey> You're returning a value in the True branch of the outer if, but a list in the False branch
16:09:44 <outsid3r> how i handle this ?
16:10:25 <sipa> outsid3r: depends what you want
16:10:34 <sipa> outsid3r: do you want it to return singletons in the first case?
16:10:37 <Taslem> Anyone know a function of the type [a] -> [b] -> [(a,b)]?
16:10:43 <sipa> :t zip
16:10:44 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
16:10:50 <Taslem> Oh, duh. Thanks.
16:10:52 <shachaf> @hoogle [a] -> [b] -> [(a,b)]
16:10:52 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
16:10:52 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
16:10:52 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
16:11:03 <outsid3r> the function should return the minimum value of a list
16:11:39 <sipa> what do you want "y : myMinimum xs" to be>
16:11:39 <sipa> ?
16:11:54 <outsid3r> im trying to write a recursive definition
16:12:29 <sipa> "y : myMinimum xs", will call myMinimum with the list xs as argument, and prepend y in front of it
16:12:37 <sipa> so that's a list
16:12:48 <outsid3r> xs:y ?
16:12:59 <sipa> that won't work
16:13:00 <Taslem> @hoogle (a -> b -> c) -> [a] -> b -> c
16:13:01 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
16:13:01 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
16:13:01 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
16:13:02 <outsid3r> yea i know
16:13:03 <sipa> :t (:)
16:13:04 <lambdabot> forall a. a -> [a] -> [a]
16:13:20 <sipa> : takes something of type a, and something of type list of a, and returns a new list
16:13:29 <sipa> i'm still confused about what you want to do
16:13:34 <outsid3r> yes, like 1:2:3:[]
16:13:34 <sipa> just get the minimum of a list?
16:13:38 <outsid3r> yes
16:13:38 <Taslem> (a -> b -> c) -> [a] -> [b] -> c
16:13:47 <outsid3r> like the minimum function of the predule
16:13:48 <Kaidelong> :t minimum
16:13:49 <lambdabot> forall a. (Ord a) => [a] -> a
16:13:50 <Taslem> @hoogle (a -> b -> c) -> [a] -> [b] -> c
16:13:50 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:13:50 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:13:50 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
16:14:02 <outsid3r> but i need to write my own as an exercise
16:14:28 <sipa> ok, i get it
16:14:41 <Kaidelong> :t foldr
16:14:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:14:55 <sipa> what do you want to call myMinimum to be called with?
16:15:04 <sipa> in the else case
16:15:05 <Taslem> @hoggle (a -> b -> c) -> [a] -> b -> [c]
16:15:05 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:15:05 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:15:05 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
16:15:29 <Kaidelong> :t foldr1 min 
16:15:30 <lambdabot> forall a. (Ord a) => [a] -> a
16:15:34 <outsid3r> idk, my ideia was to propagate the minimum value to the end of the list, and return it on the end 
16:15:37 <Taslem> @hoogle a -> [a]
16:15:37 <lambdabot> Prelude repeat :: a -> [a]
16:15:37 <lambdabot> Data.List repeat :: a -> [a]
16:15:37 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
16:15:44 <Kaidelong> although...
16:15:52 <sipa> outsid3r: does it need to be the end?
16:15:53 <Kaidelong> > foldl1 min [1..10]
16:15:54 <lambdabot>   1
16:16:02 <outsid3r> sipa: idk, im learning haskell
16:16:04 <Kaidelong> > foldl1' min [1..10]
16:16:04 <lambdabot>   1
16:16:10 <sipa> outsid3r: i know, but i'm asking you
16:16:13 <Kaidelong> foldl1' min --works
16:16:14 <outsid3r> there are other ways probably
16:16:18 <outsid3r> like removing values
16:16:26 <sipa> you're very close actually
16:17:01 <outsid3r> should i write some kind of list by comprehension ?
16:17:05 <Twey> Hmph, now highlighting-kate fails suddenly with ExitFailure 9
16:17:22 <sipa> outsid3r: no, no
16:17:31 <sipa> outsid3r: imagine you get the list [2,3,1]
16:17:32 <Kaidelong> outsid3r: You could just use plain recursion
16:17:36 <hpc> use the types, luke!
16:17:45 <sipa> outsid3r: or x=2 y=3 xs=[1]
16:17:51 <outsid3r> yes
16:17:56 <sipa> what do you want to do?
16:18:02 <outsid3r> remove y
16:18:05 <sipa> exactly
16:18:06 <outsid3r> keep 2 and 1 to the next call
16:18:13 <sipa> exactly
16:18:15 <outsid3r> actually i was trying to do that
16:18:15 <Taslem> @hoogle [[a]] -> [a]
16:18:15 <lambdabot> Prelude concat :: [[a]] -> [a]
16:18:15 <lambdabot> Data.List concat :: [[a]] -> [a]
16:18:15 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
16:18:21 <outsid3r> hence (x:y:xs)
16:18:39 <sipa> so, how do you write the list (x:y:xs) with y removed?
16:18:50 <outsid3r> x:xs
16:18:54 <sipa> yup
16:18:59 <sipa> and what do you do with that?
16:19:10 <outsid3r> myMinimum x:xs
16:19:27 <Taslem> @hoogle [a] -> [a]
16:19:27 <lambdabot> Prelude cycle :: [a] -> [a]
16:19:27 <lambdabot> Prelude init :: [a] -> [a]
16:19:27 <lambdabot> Prelude reverse :: [a] -> [a]
16:19:30 <sipa> except that evaluates to (myMinimum x):xs
16:19:38 <sipa> so, you need brackets around (x:xs)
16:19:57 <outsid3r> whats the difference between x : myMinimum xs and myMinimum (x:xs) ?
16:20:24 <sipa> (x : myMinimum xs) will call myMinimum on xs, and prepend x to the result of that
16:20:57 <sipa> but that doesn't work, since myMinimum doesn't return a list, and : takes a list as second argument
16:21:03 <outsid3r> ok, i just tested, it worked perfectly
16:21:17 <outsid3r> i see
16:22:02 <outsid3r> my mistake then, i assumed that haskell would detect that xs would be each call smaller till it reaches the first condition where it is null
16:22:09 <outsid3r> then at that condition a value would be returned
16:22:43 <sipa> haskell is not smart - you need to be pretty explicit in saying what you want
16:22:56 <sipa> but it does allow you to state what you want in a very concise way often
16:23:57 <mm_freak> well, it can infer most of the time
16:24:08 <mm_freak> not what you want, but whether what you demand makes sense
16:24:35 <outsid3r> yea but makes sense in this case, x:myMinimum was actually returning a list, and it should return a value
16:24:45 <Twey> What does a return code 9 from GHC mean?
16:24:55 <Kaidelong> well a list is a value, just not the right type of value
16:24:57 <Kaidelong> http://codepad.org/0txJ1y32
16:27:30 <Twey> lispy: Ping
16:29:10 <outsid3r> i just wrote my first sort function on haskell: 
16:29:12 <outsid3r> ssort :: Ord a => [a] -> [a]
16:29:13 <outsid3r> ssort [] = []
16:29:13 <outsid3r> ssort (x:xs) = (myMinimum (x:xs)) : xs
16:29:32 * sipa thinks this doesn't work
16:29:45 <outsid3r> it works
16:30:03 <sipa> @let ssort x = case x of { [] -> []; (x:xs) = minimum (x:xs)) : xs }
16:30:03 <lambdabot>   Parse error: =
16:30:20 <sipa> @let ssort x = case x of { [] -> []; (x:xs) -> (minimum (x:xs)) : xs }
16:30:20 <lambdabot>  Defined.
16:30:20 <outsid3r> it works on my computer
16:30:28 <mauke> > ssort "outsid3r"
16:30:30 <lambdabot>   "3utsid3r"
16:30:35 <mauke> doesn't look like it
16:30:37 <sipa> > ssort [3,2,1]
16:30:38 <lambdabot>   [1,2,1]
16:30:52 <outsid3r> oh you're right
16:31:11 * Twey tries copying .cabal and .ghc from his other machine.
16:31:13 <outsid3r> w8
16:31:13 <outsid3r> i will fix it
16:31:28 <_Ray_> No need for a recursive call there? :p
16:31:54 <outsid3r> of course it does not work
16:31:58 <outsid3r> i did not remove the element hehe
16:32:24 <tux_mark_5> hello
16:34:39 <tux_mark_5> is there a way to access haskell's lists directly via FFI?
16:34:45 <lispy> Twey: hello
16:34:56 <Kaidelong> @let ssort x = case x of { [] -> []; (x:xs) -> (minimum (x:xs)) : ssort xs }
16:34:57 <lambdabot>  <local>:1:0:
16:34:57 <lambdabot>      Warning: Pattern match(es) are overlapped
16:34:57 <lambdabot>               In...
16:35:14 <Twey> lispy: A while back you got an ‘ExitFailure 9’ error message
16:35:19 <Twey> lispy: Did you ever solve it?
16:35:20 <Kaidelong> wait what
16:35:22 <lispy> Twey: yeah
16:35:36 <Kaidelong> > ssort [3,1,2]
16:35:38 <Twey> lispy: What caused it?
16:35:38 <lambdabot>   [1,1,2]
16:35:52 <Kaidelong> oh, I can see other people's definitions?
16:36:08 <Kaidelong> that'd explain the warning too
16:36:18 <lispy> Twey: cabal passes on the exit code of whatever it ran.  So if you look at man pages you'll see that 9 is segfault
16:36:26 <Kaidelong> @let ssort' x = case x of { [] -> []; (x:xs) -> (minimum (x:xs)) : ssort xs }
16:36:26 <lambdabot>  Defined.
16:36:31 <Kaidelong> ffff
16:36:35 <lispy> Twey: Whenever I've seen that, or someone I know has seen it, it was gnu ld segfaulting
16:37:03 <lispy> Twey: and that usually only happens when ld runs out of memory.  Is this on a virtual machine with a limited amount of ram?
16:37:08 <mauke> > ssort' "Kaidelong"
16:37:09 <lambdabot>   "Kaidelong"
16:37:19 <shachaf> > ssort' [3,1,2]
16:37:20 <lambdabot>   [1,1,2]
16:37:23 <Twey> lispy: Yeah
16:37:28 <shachaf> You're not removing the item from the list after selecting it, so it gets selected again.
16:37:33 <Twey> Can I make it take less memory?
16:37:37 <Kaidelong> shachaf: I forgot to put in ssort' in the recursive call
16:37:46 <lispy> Twey: On my linode, I had to rebuild ghc and cabal to NOT split obj files
16:37:48 <Kaidelong> so it just calls the original broken ssort
16:37:54 <mauke> @define
16:37:57 <Twey> lispy: Haha, it's a Linode
16:38:08 <Kaidelong> @let ssort'' x = case x of { [] -> []; (x:xs) -> (minimum (x:xs)) : ssort'' xs }
16:38:08 <lambdabot>  <local>:1:0:
16:38:08 <lambdabot>      Warning: Pattern match(es) are overlapped
16:38:08 <lambdabot>               In...
16:38:08 <Twey> lispy: Yowch
16:38:17 <sipa> @undef
16:38:38 <Kaidelong> oh
16:38:39 <lispy> Twey: it wasn't that bad.  I did a normal source build, but after the configure step I edited a file (I forget which one) to say don't split obj files, and then built it the rest of the way like normal
16:38:44 <Kaidelong> right, you have to delete the minimum
16:38:47 <Kaidelong> so it's still broken
16:38:55 <ddarius> Split-objs is killer for ld.
16:39:28 <monochrom> gold linker may cope better, if you don't want to custom-build ghc
16:39:35 <Twey> I'm going to try compiling it on my desktop and transferring it across, first.  The systems are pretty similar, and that sounds like a desperation measure.
16:39:48 <Twey> I have no idea how I'd even go about telling ghc to use a different linker
16:40:09 <Kaidelong> @undefine ssort''
16:40:14 <Kaidelong> @undefine ssort'
16:40:20 <mauke> Kaidelong: ...
16:40:22 <shachaf> @undefine EVERYTHING
16:40:25 <ddarius> If only there were a collection of web pages that readily explained such thing...
16:40:27 <monochrom> just ensure your chosen linker has priority in PATH and still called "ld"
16:40:33 <Twey> ddarius: :þ
16:40:59 <Kaidelong> http://code.haskell.org/lambdabot/COMMANDS
16:41:03 <Kaidelong> undefine is listed there
16:41:12 <shachaf> @help undefine
16:41:12 <lambdabot> undefine. Reset evaluator local bindings
16:41:25 <monochrom>  @undefine erases all @let settings
16:41:30 <Kaidelong> oh okay
16:42:04 <monochrom> use it twice a day to prevent gingivitis!
16:42:07 <lispy> Twey: http://hackage.haskell.org/trac/ghc/wiki/Building/Troubleshooting
16:42:18 <lispy> Twey: Workaround: add SplitObjs=NO to mk/build.mk
16:43:02 <lispy> Twey: I also set my .cabal/config on that machine to disable split-objs, but YMMV
16:43:32 <adamvh> n00b question: What does :. mean
16:43:49 <lispy> :t (:.)
16:43:50 <ddarius> Nothing
16:43:50 <lambdabot> Not in scope: data constructor `:.'
16:44:14 <monochrom> well by now your ar version should be way pass 2.17. mine is 2.20 for example.
16:44:28 <adamvh> Ah - I see - it's defined within repa somewhere ...
16:44:56 * ddarius would not be surprised if adamvh is looking at the definition.
16:45:01 <lispy> monochrom: Yeah, but I was trying to locate the instructions for disabling split-obj
16:45:19 <lispy> different problem, same fix
16:45:20 <monochrom> oh, oops, yeah, that is still useful information
16:45:44 <adamvh> ddarius: Indeed I am - just trying to grok it.
16:45:47 <parcs> Twey: i have cabal aliased to 'PATH="/path/to/gold:$PATH" cabal' where /path/to/gold contains a symlink to gold named ld
16:45:48 <monochrom> anyway mk/build.mk is your friend
16:47:02 <_Ray_> @let rem y li = case li of { [] -> []; (x:xs) -> if x == y then xs else x:(rem y xs); }; ssort y = case y of { [] -> []; (x:xs) -> (a: (ssort (rem a (x:xs)))) where a = minimum (x:xs) }
16:47:03 <lambdabot>  <local>:1:70:
16:47:03 <lambdabot>      Ambiguous occurrence `rem'
16:47:03 <lambdabot>      It could refer to either ...
16:47:15 <mauke> @define
16:47:40 <monochrom> note that by hamming-distance-2 auto-correction, @define becomes @undefine
16:47:48 <Kaidelong> > 5 `rem` 3
16:47:48 <lambdabot>   2
16:47:48 <outsid3r> ok, i wrote a function to delete
16:47:50 <_Ray_> wtf :(
16:47:52 <monochrom> @unslap monochrom
16:47:52 * lambdabot is overcome by a sudden desire to hurt monochrom
16:47:52 <outsid3r> myDelete :: Eq a => a -> [a] -> [a]
16:47:53 <outsid3r> myDelete a (x:xs) = if a == x then xs else x : myDelete a xs
16:47:57 <outsid3r> then sort:
16:48:04 <outsid3r> ssort :: Ord a => [a] -> [a]
16:48:04 <outsid3r> ssort [] = []
16:48:05 <outsid3r> ssort (x:xs) = if null xs then x:[] else m : ssort (myDelete m (x:xs)) where m = myMinimum (x:xs)
16:48:11 <ddarius> monochrom: I'm pretty sure Levenshtein distance is what is used.
16:48:24 <outsid3r> sipa: fine now ?
16:48:29 <sipa> outsid3r: what is m?
16:48:30 <monochrom> yeah should have just said "edit-distance" to be safe
16:48:35 <lispy> I've been meaning to look at possibly submitting a patch to Cabal to have it attempt an error code lookup so that message can suggest to the user what it means.  So you might get: ExitFailure 9: This error code usually means segfault.
16:48:36 <sipa> oh
16:48:37 <outsid3r> minimum value
16:48:39 <sipa> nevermind
16:48:48 <sipa> looks good to me
16:48:52 <monochrom> use @undefine twice a minute to prevent gingivitis!
16:48:57 <outsid3r> yea now it really works, i have tested
16:48:59 <lispy>  or, ExitFailure 127: This error code usually means program not found.
16:50:10 <monochrom> I seriously recommend "ExitFailure <number here>: This usually means you should disclose COMPLETE information to #haskell for help"
16:50:32 <lispy> heh
16:50:51 <int80_h> monochrom seaks truth. I've been using @undefine for several years now, and I don't have gingivitis. He also sold me a tiger-repelling rock, and it's been keeping california free of tigers for over a decade!
16:50:59 <monochrom> Too many past help requests have been merely "I got ExitFailure 1" totally useless.
16:51:15 <shachaf> @undefine gingivitis
16:51:38 <shachaf> Plaque and cavities and gingivitis. Today it's teeth, tomorrow -- no teeth!
16:51:41 <monochrom> In fact as it turns out, in 99% of the cases the final "ExitFailure code" is completely irrelevant.
16:52:32 <lispy> I usually have to add --verbose=3 to really figure out what is happening
16:52:53 <lispy>  Sometimes 2 is sufficient though
16:53:22 <lispy> Other times I have to set phasors to kill
16:54:03 <ion> int80_h: Too bad you didn’t have the rock in 1985. http://www.talkbx.com/2007/12/27/california-tiger-attack-brings-back-bronx-zoo-attack-memories/
16:55:00 <int80_h> ion: he says it doesn't work on *those* tigers.
16:55:36 <monochrom> 1985 is way more than a decade agao
16:55:54 <ion> I recommend “ANYTHING: This usually means you should disclose COMPLETE information to #haskell for help”.
16:56:06 <monochrom> a rock installed in 2000 could not possibly work on a 1985 tiger, of course
16:56:32 <int80_h> what if I bought the special time-warp package?
16:56:36 <ion> The rock would need to be homeopathic to have a retroactive effect.
16:57:04 <hpc> @quote monochrom 1985 is way more than a decade ago
16:57:04 <lambdabot> No quotes match. Wrong!  You cheating scum!
16:57:12 <hpc> @remember monochrom 1985 is way more than a decade ago
16:57:12 <lambdabot> Done.
16:57:14 <hpc> :D
16:57:32 <monochrom> not sure of the value of that quote, but whatever you like
16:58:05 <ion> I.e. the rock would need to have zero molecules of a substance that causes similar symptoms to tiger mauling, and it would need to have been shaked the correct number of times in the direction of all the three spatial axes.
16:59:06 <geheimdienst> o_O
16:59:11 <geheimdienst> what are we discussing again?
16:59:29 <ion> Homeopathic monadic rocks.
17:00:11 <geheimdienst> sounds as plausible as it sounds usefuly. carry on then
17:00:15 <_Ray_> xD
17:00:25 <geheimdienst> s/fuly/ful
17:08:09 <hpc> monochrom: just in case :P
17:10:36 * hackagebot string-class 0.1.4.1 - String class library  http://hackage.haskell.org/package/string-class-0.1.4.1 (ByronJohnson)
17:11:37 * hackagebot monad-state 0.1.1.2 - Utility library for monads, particularly those involving state  http://hackage.haskell.org/package/monad-state-0.1.1.2 (ByronJohnson)
17:11:39 * hackagebot bitmaps 0.2.5.1 - Bitmap library  http://hackage.haskell.org/package/bitmaps-0.2.5.1 (ByronJohnson)
17:11:55 <TomMD>  Damn it people, stop uploading to hackage.  I don't have time to learn all the packages that are there already.
17:12:25 <sm> indeed.. it's got that point
17:13:19 <sm> got to that point. Guides, reviews, summaries needed
17:23:53 <LambdaSteel> Hi
17:24:02 <hpc> haskell.org/haskellwiki/hitchhiker's_guide_to_hackage?
17:24:35 <LambdaSteel> Could someone give a help?
17:24:54 <LambdaSteel> http://hpaste.org/45051/could_not_deduce
17:25:56 <LambdaSteel> I'm getting a couple of errors from GHC
17:27:55 <LambdaSteel> Seems related to functional dependence, but I don't have any experience with it. 
17:32:58 <LambdaSteel> http://hpaste.org/45051/could_not_deduce
17:33:23 <TomMD> off hand it looks like you didn't apply the type function at some needed point, but I only glanced.
17:33:24 <LambdaSteel>  Could someone help me with that?
17:33:28 <TomMD> Good luck
17:34:28 * hpc doesn't do those sorts of extensions, and hasn't even seen that error before
17:35:18 <LambdaSteel> what?
17:36:37 <LambdaSteel> I don't know how to interpret the error message
17:39:40 * hackagebot hquantlib 0.0.1 - HQuantLib is a port of essencial parts of QuantLib to Haskell  http://hackage.haskell.org/package/hquantlib-0.0.1 (PavelRyzhov)
18:32:34 <pastorn> LambdaSteel: hey
18:32:49 <LambdaSteel> hi
18:32:58 <pastorn> you still curious?
18:33:04 <pastorn> or did you solve it?
18:33:11 <LambdaSteel> yes
18:33:16 <pastorn> which?
18:33:34 <LambdaSteel> I still curious!
18:33:58 <LambdaSteel> I did not solve it
18:34:30 <pastorn> ok, your problem can be condensed to class C a -> f :: T -> a
18:34:44 <pastorn> class C a where; f :: T -> a
18:35:24 <pastorn> say that you call (f someT), then your function won't know which of your instances of C to use
18:36:06 <pastorn> at least i think that's the problem :)
18:36:35 <LambdaSteel> And how could I fix it?
18:36:43 <pastorn> f :: T -> a -> a
18:36:49 <pastorn> maybe
18:37:34 <augustss> type signature on the call, maybe?
18:37:53 <pastorn> right... fix your type when calling f
18:40:07 <LambdaSteel> But if I fix it, I will avoid others instances to reuse f 
18:41:10 <pastorn> well, where does the [b] come from?
18:41:48 <pastorn> how shold the type checker know which type [b] is? (unless it's always '[]' being used)
18:42:42 <LambdaSteel> when I call it, I fit its type 
18:42:59 <LambdaSteel> But seems that it  not works
18:43:18 <Peaker> LambdaSteel, can you paste the whole thing?
18:43:54 <LambdaSteel> sure, but it is a LOT
18:43:58 <LambdaSteel> wait
18:44:10 <pastorn> LambdaSteel: repo?
18:44:39 <Peaker> LambdaSteel, it'd be easier if I could just try to build it
18:44:47 <Peaker> LambdaSteel, I might be able to help debug the type error
18:44:55 <Peaker> github.com repo could be cool
18:46:19 <LambdaSteel> http://hpaste.org/paste/45054/3d_convexhulldelaunay_error
18:46:42 <LambdaSteel> The ghci output is at the end
18:47:33 <pastorn> LambdaSteel: you know that LANGUAGE supports a list of extensions, right? (comma separated)
18:47:47 <LambdaSteel> I will upload to Github
18:48:00 <LambdaSteel> yes, I know
18:49:22 <Peaker> pastorn, I like one ext. per line :)
18:49:41 <Peaker> LambdaSteel, I can't compile it that way... need other modules. waiting for github
18:51:01 <Dark_Shikari> Question: suppose I have a monadic function foo that gives me a value A, and a non-monadic function bar that takes A and gives me a value B.
18:51:17 <Dark_Shikari> I have a do block that needs to first call foo to get A, then call bar with A to get B, then return it.
18:51:38 <Dark_Shikari> How is one supposed to do this?  Haskell doesn't seem to like it when I end a do block on a call to a non-monadic function.
18:51:49 <Dark_Shikari> because bar doesn't return a monad, whereas foo does.
18:53:24 <LambdaSteel> it doesn't depend on internal modules
18:53:26 <Peaker> Dark_Shikari, fmap bar foo
18:53:44 <LambdaSteel> but i will upload in a sec.
18:54:09 <Peaker> or liftM instead of fmap
18:54:12 <Dark_Shikari> it has a few more arguments than that, how does one use fmap with more?
18:54:12 <Peaker> @type liftM bar foo
18:54:13 <lambdabot> Not in scope: `bar'
18:54:13 <lambdabot> Not in scope: `foo'
18:54:15 <Peaker> @type liftM
18:54:15 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:54:20 <Dark_Shikari> actual arguments necessary:
18:54:28 <Dark_Shikari> A <- foo X
18:54:35 <Dark_Shikari> B = bar A Y
18:54:37 <Dark_Shikari> return B
18:54:42 <Dark_Shikari> how would I do that with fmap?
18:55:04 <Peaker> Dark_Shikari, you could just write:   do { a <- foo X ; let B = bar A y ; return B }  or instead of last 2 lines:   return (bar A y)
18:55:20 <djahandarie> Hello Dark_Shikari
18:55:28 <ion> @pl foo x >>= \a -> return (bar a y)
18:55:28 <lambdabot> flip bar y `fmap` foo x
18:55:29 <Peaker> Dark_Shikari, with fmap: you could do:   fmap (flip bar Y) (foo X)
18:55:35 <Dark_Shikari> I can use let for that?
18:55:44 <Dark_Shikari> I recall that not working, but let me try that again
18:55:53 <Peaker> @pl . undo do { a <- foo X ; return (bar A y) }
18:55:53 <lambdabot> (line 1, column 1):
18:55:53 <lambdabot> unexpected "."
18:55:53 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:56:00 <djahandarie> do blocks have a 'special' let inside them.
18:56:05 <djahandarie> Peaker, @. pl undo
18:56:12 <Peaker> @. pl undo do { a <- foo X ; return (bar A y) }
18:56:12 <lambdabot> foo X >> return (bar A y)
18:56:19 <Dark_Shikari> The latter worked
18:56:23 <Dark_Shikari> return (bar A y)
18:56:27 <Dark_Shikari> thanks.
18:56:31 <Peaker> @. pl undo do { a <- foo X ; return (bar a y) }
18:56:31 <lambdabot> flip bar y `fmap` foo X
18:56:38 * Dark_Shikari will hang around, lest this haskell assignment torture him to death.
18:57:01 <djahandarie> If Haskell isn't fun your teacher is bad ;)
18:57:02 <Peaker> Dark_Shikari, Haskell is an awesome language to get assignments in :-)
18:57:06 <Dark_Shikari> I know.
18:57:18 <Dark_Shikari> 95% of our time is spent debugging type errors.
18:57:22 <Dark_Shikari> And when the type errors are gone, it works.
18:57:27 <Dark_Shikari> Mostly.
18:57:28 <pastorn> LambdaSteel: type StateMBC a = State (SubUnitsSets a) ?
18:57:43 <pastorn> don't you mean type StateMBC a = State SubUnitsSets a?
18:57:51 <pastorn> or type StateMBC a = State (SubUnitsSets a) a?
18:58:10 <djahandarie> Unfortunately GHC can't do all sorts of neat SIMD stuff for you automatically yet. ;)
18:58:10 <monochrom> type errors can be prevented by being logical
18:58:42 <Dark_Shikari> the point is that bugs become type errors
18:58:48 <Dark_Shikari> which means the compiler tells you where your bugs are
18:58:53 <Dark_Shikari> pretty nice, really.
18:59:11 <monochrom> to a large extent, bugs can be prevented by being logical too.
18:59:21 <Peaker> Dark_Shikari, Yeah, and it's much much easier to debug type errors in a large and/or complex program than debugging runtime errors
18:59:37 <djahandarie> Right. The main idea is to encode your program's rules in the type system so the compiler can do an 'exhaustive' search of what can go wrong with your program at compile time
18:59:38 <monochrom> awful homework cannot be saved by awesome language
18:59:50 <Peaker> Dark_Shikari, and it is easier to train yourself to make less type errors than to make less bugs in a less disciplined language :)
18:59:50 <Dark_Shikari> it's not awful homework, we're writing a C# -> x86 compiler
18:59:59 <Peaker> monochrom, it sure can! :)
19:00:02 <Peaker> (in some cases)
19:00:18 <djahandarie> Are you hand rolling the parser?
19:00:22 <Dark_Shikari> no, using happy
19:00:26 <Dark_Shikari> and alex
19:00:30 <pastorn> Dark_Shikari: not bnfc?
19:00:30 <Dark_Shikari> already done that part
19:00:40 <Dark_Shikari> also it's not C#, just a subset (but a quite significant one)
19:00:41 <Peaker> C# is quite a complex language.. why choose a complex language for pedagogy?
19:00:47 <monochrom> well awful homework means "do xxx but don't use recursion, don't use standard lib functions, don't use this, don't use that"
19:00:50 * hackagebot monad-parallel 0.7 - Parallel execution of monadic computations  http://hackage.haskell.org/package/monad-parallel-0.7 (MarioBlazevic)
19:00:52 * hackagebot monad-coroutine 0.7 - Coroutine monad transformer for suspending and resuming monadic computations  http://hackage.haskell.org/package/monad-coroutine-0.7 (MarioBlazevic)
19:00:54 * hackagebot scc 0.7 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.7 (MarioBlazevic)
19:01:04 <Peaker> monochrom, then it's not "awesome language" you're using
19:01:16 <Peaker> monochrom, it's basically "solve this problem in this horrible subset of awesome language"
19:01:24 <monochrom> alright
19:01:48 <Dark_Shikari> the main useful thing about C# is that it makes type checking interesting.
19:02:01 <Dark_Shikari> without classes and subclasses/etc, there's not much type checking to be had in a compiler.
19:02:04 <djahandarie> pastorn, has BNFC actually been used with C#?
19:02:23 <pastorn> djahandarie: dunno, but each year 80+ people uses it for C++
19:02:27 <pastorn> (at chalmers)
19:02:30 <pastorn> sans templates
19:02:31 <djahandarie> Yeah
19:02:43 <Peaker> Dark_Shikari, Haskell's type system is much more interesting to type-check than C#
19:02:53 <Peaker> Dark_Shikari, and it's not because type-classes have some notion of "sub-classing"
19:02:56 <Dark_Shikari> Yeah, sure
19:02:57 <djahandarie> Dark_Shikari, I'd rather use Haskell to type check something without subtyping but with the other neat stuff
19:03:01 <Dark_Shikari> But compiling haskell in haskell?
19:03:04 <Dark_Shikari> heh.
19:03:07 <Dark_Shikari> I guess that's what ghc does.
19:03:08 <pastorn> djahandarie: so if it can do that it should be able to do c#
19:03:40 <Dark_Shikari> anyways afk doing actual work
19:03:52 <monochrom> compiling c# is quite ambitious, even after subsetting
19:04:04 <djahandarie> Now try compiling Agda in Haskell
19:04:24 <djahandarie> It's hardly even Haskell anymore with all the unsafeCoercing!
19:05:04 <dagle> :)
19:05:39 <monochrom> you could compile Agda into x86 directly. then there would be no unsafeCoerce in sight.
19:06:08 <pastorn> monochrom: hah, do you have any agda programs worth running?
19:06:18 <djahandarie> There is a C backend for Agda called Epic
19:06:30 <djahandarie> Also used for Idris and Epigram IIRC
19:06:33 <monochrom> I don't.
19:06:53 <axfan> xmonad is so awesome..
19:06:59 <axfan> thank you haskell
19:07:12 <dmwit> No, awesome is a different WM. ;-)
19:07:27 <monochrom> "alex is happy"
19:08:12 <pastorn> dmwit: lolz u so fannei
19:08:17 <dagle> But awesome is not awesome...
19:08:36 <dmwit> I know, that joke is pretty fresh.
19:08:50 <int80_h> http://hpaste.org/45056/data_constructors_and_accessor
19:08:55 <LambdaSteel> sorry, guys! I'm having problems to set up the repo
19:09:10 <pastorn> LambdaSteel: did you see what i wrote?
19:09:33 <LambdaSteel> the key has some issue with permission
19:09:38 <LambdaSteel> yes
19:10:20 <LambdaSteel> type StateMBC a = State (SubUnitsSets a), is right  
19:10:43 <monochrom> I wonder what is really in line "34"
19:11:35 <monochrom> but what is the "do" doing there when the type is Entry not IO Entry?
19:11:37 <djahandarie> Once I got an error on line 42 and just deleted the program out of fear that the universe was about to explode
19:11:38 <int80_h> monochrom: >   let entryT = last $ splitOn "/" entryFileName
19:11:50 <int80_h> ah!
19:12:26 <monochrom> I'll just say your logic got ghc very confused
19:12:41 <int80_h> monochrom: That's me following coding patterns w/out understanding. 
19:12:52 <int80_h> monochrom: I fixed it. It compiles now
19:13:08 <LambdaSteel> it is a partial application, the rest is "StateMBC a [b]"
19:14:37 <pastorn> LambdaSteel: don't you mean just "b"
19:19:33 <LambdaSteel> finally! https://github.com/EdgarGomes/VirMat 
19:21:23 <LambdaSteel> mbc::(SubUnit a)=>[Point] -> SetActiveSubUnits a -> Box ->    " StateMBC a [b] "
19:25:00 <dagle> :)
19:26:54 <int80_h> http://hpaste.org/45057/deriving_instance_whats_that
19:27:14 <LambdaSteel> sorry for that :-[
19:28:51 <ion> You can’t show an IO String.
19:29:27 <ion> How about entryContent :: String and someFunction :: IO Entry instead?
19:29:54 <ion> someFunction :: … -> IO Entry
19:30:14 <LambdaSteel> pastorn: did you try to compile it?
19:30:56 <int80_h> ion: I haven't started putty correctly. Could you paste that text on hpaste?
19:31:01 <siracusa> int80_h: Or you could wrap the IO String into a newtype and write an Show instance for that by hand.
19:31:55 <int80_h> siracusa: okay, that's understandable. I could try that.
19:37:25 <ion> int80_h: http://hpaste.org/paste/45057/deriving_instance_whats_that#p45058
19:44:24 <int80_h> @ Show
19:44:33 <int80_h> @Show
19:44:33 <lambdabot> ""
19:44:39 <int80_h> @src Show
19:44:39 <lambdabot> class  Show a  where
19:44:39 <lambdabot>     showsPrec :: Int -> a -> ShowS
19:44:40 <lambdabot>     show      :: a   -> String
19:44:40 <lambdabot>     showList  :: [a] -> ShowS
19:45:00 <Peaker> @src ShowS
19:45:00 <lambdabot> type ShowS = String -> String
19:45:18 <Peaker> Could be nicer if ShowS was a DList Char maybe? :)
19:48:45 <jmcarthur> Peaker: heck yes
19:48:58 <Dark_Shikari> (Monad m) is the type for a generic monad
19:49:02 <Dark_Shikari> what's the type of an IO monad?
19:49:08 <jmcarthur> Dark_Shikari: that is not a type
19:49:20 <Dark_Shikari> Monad isn't a type?
19:49:24 <jmcarthur> Dark_Shikari: Monad is a type class. m is a type variable.
19:49:27 <Dark_Shikari> yes.
19:49:33 <Dark_Shikari> And you put (Monad m) in a function declaration.
19:49:33 <jmcarthur> Dark_Shikari: IO is a type constructor. IO String is a type
19:49:42 <jmcarthur> Dark_Shikari: Monad m is a constraint, not a type
19:49:49 <Dark_Shikari> If I wanted a function to only support the IO Monad, what would I put in place of (Monad m)?
19:49:49 <dmwit> Dark_Shikari: More specifically, you put (Monad m) in the *context*.
19:49:49 <rothwell> hxt seems quite obnoxious... is there some way i can get it to stop doing things like printing its own error messages on stderr?
19:50:04 <dmwit> Dark_Shikari: Just use "IO" instead of the variable "m".
19:50:05 <Dark_Shikari> If I wanted a function to only support the IO Monad, what would I put in place of (Monad m)?
19:50:06 <jmcarthur> Dark_Shikari: you would not have any constraints
19:50:11 <Dark_Shikari> (Monad IO)?
19:50:12 <jmcarthur> Dark_Shikari: you would just use IO
19:50:13 <jmcarthur> no
19:50:17 <jmcarthur> just remove that whole thing
19:50:20 <Dark_Shikari> Just IO?
19:50:24 <jmcarthur> :t putStrLn
19:50:24 <lambdabot> String -> IO ()
19:50:28 <dmwit> Monad IO would be fine, though kind of silly.
19:50:37 <Dark_Shikari> So if I had a function that was
19:50:40 <dmwit> :t putStrLn :: Monad IO => String -> IO ()
19:50:40 <lambdabot> String -> IO ()
19:50:47 <jmcarthur> yeah but there's no point
19:50:56 <Dark_Shikari> foo :: (Monad m) => A -> B -> m ()
19:50:59 <Dark_Shikari> I could do
19:51:10 <jmcarthur> foo :: A -> B -> IO ()
19:51:10 <rothwell> http://stackoverflow.com/questions/3901492/running-haskell-hxt-outside-of-io
19:51:10 <rothwell> answered my own question
19:51:11 <Dark_Shikari> foo :: (Monad IO) => A -> B -> IO () ?
19:51:21 <jmcarthur> Dark_Shikari: what i just did would work
19:51:24 <dmwit> Dark_Shikari: Yes, or just foo :: A -> B -> IO ().
19:51:31 <Dark_Shikari> Why?  You're changing the type by removing the input monad.
19:51:37 <jmcarthur> Dark_Shikari: huh?
19:51:38 <dmwit> Dark_Shikari: But the fact that you're asking this suggests that you may be doing something weird and misguided.
19:51:41 <jmcarthur> Dark_Shikari: Monad m is not a type
19:51:46 <Dark_Shikari> Then why is it in the function declaration?
19:51:55 <jmcarthur> Dark_Shikari: Monad is a constraint you apply to a type (usually a type *variable*)
19:52:04 <jmcarthur> Dark_Shikari: IO is not a type variable, so the constraint isn't necessary
19:52:04 <Dark_Shikari> So I'm saying that the "m" must be a Monad?
19:52:09 <jmcarthur> right
19:52:17 <Dark_Shikari> And there's only one IO monad, called IO?
19:52:19 <Dark_Shikari> There are no other IO monads?
19:52:50 <jmcarthur> well, you could define one of your own, but then there would be a conflict if they were both in scope
19:52:57 <Dark_Shikari> OK, so there's one built-in IO monad.
19:52:58 <Dark_Shikari> Makes sense then.
19:53:13 <jmcarthur> but IO () is a concrete type, and the compiler knows already that it's an instance of Monad
19:53:18 <jmcarthur> well, that IO is
19:53:36 <jmcarthur> i fudged my wording earlier
19:53:50 <jmcarthur> Monad is a constraint you apply to a type or type constructor
19:54:10 <jmcarthur> IO is a type constructor, not a type, but it's not polymorphic in any case, so the constraint is still unnecessary
19:55:20 <ion> foo :: a -> a  -- accepts any type, including Integer
19:55:20 <prettyrobots> Is there something like Twisted for Haskell?
19:55:21 <dmwit> Dark_Shikari: Can I ask why you want to restrict something this way?
19:55:23 <prettyrobots> Evented I/O?
19:55:27 <ion> foo :: Num a => a -> a  -- accepts any number, including Integer
19:55:30 <Dark_Shikari> The original code had (Monad m)
19:55:41 <ion> foo :: Integer -> Integer  -- accepts just an integer, the Num a constraint is redundant.
19:55:47 <dmwit> Dark_Shikari: So?
19:55:55 <Dark_Shikari> The assignment says that we now have to change it to use the IO monad.
19:55:56 <dmwit> prettyrobots: Take a look at Push-Pull FRP, maybe?
19:56:04 <jmcarthur> prettyrobots: the GHC runtime already uses async IO when you use threads, if the performance is all you're after
19:56:12 <Dark_Shikari> (a) Ctx.hs now assumes your type checker/translator is speci􏰀cally using the IO monad. If you uncommented any type speci􏰀cations that claimed your type checker works with any Monad ((Monad m) => ...), you’ll need to delete or change these.
19:56:19 <prettyrobots> jmcarthur: On Windows too?
19:56:22 <Dark_Shikari> (from the assignment)
19:56:43 <Peaker> Monad is a constraint you apply to type constructors, not to types
19:56:51 <jmcarthur> prettyrobots: my understanding is that even on windows it does something fast, but i'm not a windows guy
19:56:57 <jmcarthur> still async i know
19:57:08 <jmcarthur> but i'm not familiar with what async interfaces windows has
19:57:20 <prettyrobots> jmcarthur: Overlapped I/O and Completion Ports.
19:57:21 <djahandarie> Peaker, not important here though. You never apply constraints to a concrete type.
19:57:31 <Peaker> prettyrobots, The GHC "threads" are user-threads, and when they do "blocking I/O" it's implemented with an event loop like "epoll"
19:57:56 <Peaker> djahandarie, Yeah, but it's important that type-class constraints have kinds.. If you have (Monad m) constraint, then "m" is of kind * -> *
19:59:04 <jmcarthur> prettyrobots: on my slow linux laptop the most naive possible web server using forkIO handles something ridiculous like 17k http requests per second
19:59:16 <int80_h> @src Show
19:59:16 <lambdabot> class  Show a  where
19:59:16 <lambdabot>     showsPrec :: Int -> a -> ShowS
19:59:16 <lambdabot>     show      :: a   -> String
19:59:16 <lambdabot>     showList  :: [a] -> ShowS
19:59:18 <Peaker> prettyrobots, We all hate shared-state threads, and hail the benefits of determinstic computation. In Twisted, it's deterministic because of the lack of threads. In Haskell, it's deterministic because everything's immutable by default. There is very little shared state and that is explicitly declared as such. So you get parallelism AND safe concurrency :)
20:00:00 <prettyrobots> Peaker: That I understood. Thank you.
20:00:01 <djahandarie> Also, Monad IO will only work with FlexibleContexts. And it's useless anyways.
20:00:09 <djahandarie> Arg I'm lagging terribly
20:00:43 <prettyrobots> jmcarthur: Your naive web server, is that multi-threaded?
20:01:07 <jmcarthur> prettyrobots: it would be if i built it with -threaded, but i think those numbers were for the single threaded build
20:01:18 <djahandarie> Peaker, I think (Monoid String) => String -> IO () would be just as bad a signature as (Monad IO) => String -> IO ()
20:01:20 <prettyrobots> jmcarthur: Cool. Great numbers.
20:01:25 <jmcarthur> having only two cores, i don't have a great machine for benchmarking multithreaded stuff
20:02:08 <Peaker> djahandarie, of course, did I imply otherwise?
20:02:09 <jmcarthur> prettyrobots: btw, i said "most naive possible," but i did at least take the time to use bytestring, etc.
20:02:12 <prettyrobots> jmcarthur: How big does the process get? I'm using Node.js and I like how efficent it is.
20:02:18 <jmcarthur> prettyrobots: so it was actually naive but good practices
20:02:36 <prettyrobots> jmcarthur: I took naive to mean no framework skyscraper.
20:02:36 <jmcarthur> prettyrobots: nothing worth worrying about, but i can't recall for certain right now
20:02:42 <jmcarthur> yes, that too
20:02:53 <Peaker> jmcarthur, it is sad that using ByteStrings takes effort :-(
20:03:08 <gio123> I want to write collection of x_1,...x_n,y_1,...,y_m is of variables of t_1,...tn , s_1,...s_m in a nice way, does this looks ok \cup_{1=<i=<n}x_i \cup \cup{1=<j=<m} y_j  \subset \cup_{1=<i=<n}vars(t_i) \cup \cup{1=<j=<m} vars(s_j) ?
20:03:14 <Peaker> Haskell has the best polymorphism mechanism of all mainstream-ish languages, but doesn't use it at all to be polymorphic over string types
20:03:16 <dmwit> It sounds like Dark_Shikari's problem-setter doesn't understand something about Haskell.
20:03:20 <djahandarie> Peaker, it just seemed a little tangential to the problem, so I wanted to make it clear it wasn't why this is bad.
20:03:28 <prettyrobots> jmcarthur: Like hundred of MB RSS or tens?
20:03:37 <jmcarthur> Peaker: IMO, Text should be the default for String, and ByteString should be the default for non-Text I/O :\
20:03:48 <djahandarie> Text is in base now at least.
20:03:55 <jmcarthur> djahandarie: you mean the platform?
20:03:58 <djahandarie> Erm
20:03:59 <djahandarie> Yeah :p
20:04:08 <jmcarthur> prettyrobots: pretty sure it's not hundreds
20:04:15 <Peaker> jmcarthur, Sure, but it is horrible that we have functions like "ByteString.map", "ByteString.Lazy.map", fmap, Vector.map, do we also have Text.map? 
20:04:27 <jmcarthur> Peaker: yeah that's pretty bad
20:04:32 <int80_h> http://hpaste.org/45059/show_instance
20:04:36 <djahandarie> Peaker, there is ListLike! ;)
20:04:47 <Peaker> jmcarthur, Lazy/Strict bytestrings not having a common interface is ... weird
20:04:59 <prettyrobots> jmcarthur: How do you benchmark? Do you use ab?
20:05:15 <dmwit> int80_h: There's not much you can do for such an instance.
20:05:28 <dmwit> int80_h: You can't escape IO.
20:05:30 <Peaker> djahandarie, Yucky class, though. it would be nice if they went with the Sequence approach of exposing their functionality in standard generic classes like Foldable/Traversable.. if all else fails, ListLike is OK but at least split into small chunks of functionality?
20:05:35 <int80_h> dmwit: hmm, okay maybe I'm on the wrong track then
20:05:38 <Peaker> A huge class is not very useful for actual polymorphism
20:05:53 <jmcarthur> prettyrobots: i think it was httperf
20:06:04 <djahandarie> Peaker, they don't have the proper kinds to use Traversable/Functor/etc
20:06:08 <int80_h> dmwit: Should I stop trying to show an IO String then?
20:06:12 <prettyrobots> jmcarthur: Thanks. Got enough to play with. Thank you.
20:06:16 <dmwit> int80_h: Yes.
20:06:17 <jmcarthur> prettyrobots: this was a while ago, and i don't normally do web dev so things aren't fresh on my mind
20:06:21 <jmcarthur> prettyrobots: np
20:06:22 <Peaker> int80_h, "show" is supposed to be pure.. if it depended on stuff like file contents, it could return different results every time
20:06:39 <Peaker> djahandarie, Yeah, which is why I hope ByteString could be eliminated in favor of Vector Word8
20:06:59 <djahandarie> That's an interesting idea. Though I don't see how that could have all the same optimizations
20:07:09 <Peaker> djahandarie, GHC specialization optimizations?
20:07:12 <int80_h> Peaker: O need to be able to inspect the values in that constructor
20:07:26 <jmcarthur> djahandarie: yeah, but on the other hand, bytestring doesn't fuse
20:07:32 <djahandarie> Peaker, I suppose, but this would be getting very messy
20:07:48 <dmwit> int80_h: That's fine and all, but when you do, it must be done within IO.
20:07:49 <Peaker> int80_h, in what constructor? you only have an arg of type FilePointer
20:07:55 <djahandarie> Maybe there needs to be a better way to write specialization rewrites
20:08:51 <Peaker> djahandarie, messy? why? Specialization behind the scenes?
20:09:23 <djahandarie> Nah, all the stuff would have to be written in the same file Vector is declared, IIRC
20:12:28 --- mode: ChanServ set +o copumpkin
20:12:38 --- kick: Dt100 was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
20:15:35 <TomMD> Has any momentum formed behind ARM or cross compilation tasks that I might have missed due to being unsubscribed from most the MLs for a few months now?
20:16:06 <copumpkin> TomMD: dankna has been working on general cross-compilation support (at runtime) and it's getting closer I think
20:16:08 <dolio> I thought I saw something about that being discussed...
20:16:18 <copumpkin> but there was specific arm talk too
20:16:21 <TomMD> Which ML?
20:16:24 <TomMD> Cafe?
20:18:52 <dolio> Now I can't find anything about it.
20:19:19 <dolio> Maybe it was you, talking here.
20:20:23 <TomMD> I think I found what you might have been talking about: http://www.haskell.org/pipermail/cvs-ghc/2011-March/060535.html
20:20:28 <TomMD> dolio ^^^
20:21:18 <dolio> Does that have anything specifically to do with ARM? I could have sworn I saw people talking about ARM lately.
20:21:51 <dolio> Maybe it wasn't even Haskell-related, though. Obviously I wasn't paying much attention.
20:22:27 <copumpkin> I think it was mtnviewmark
20:22:31 <copumpkin> but I can't remember where
20:23:18 --- mode: ChanServ set +o monochrom
20:24:24 <TomMD> What does Simon M mean when he says "Dan Knapp has sent us some patches to move towards      making the NCG backend selectable at runtime."?
20:24:40 <copumpkin> currently all that stuff is preprocessor-based
20:24:44 <TomMD> You can already select NCG when running ghc (or the c compiler, or llvm)
20:24:53 <copumpkin> only very slightly
20:25:01 <copumpkin> this would make it way more homogeneous
20:25:10 <copumpkin> you can't pick between x86 or x86_64
20:25:11 <copumpkin> or arm
20:25:40 <copumpkin> a lot of information is hardcoded down at that level
20:25:48 <copumpkin> and dankna's patch works to make a lot less of it statc
20:25:53 <TomMD> Oh, which NCG.  Not just that "the" NCG will be used instead of C or LLVM.
20:25:58 <copumpkin> yeah
20:26:22 --- mode: monochrom set +b *!*@*.i-next.psi.br
20:26:38 --- mode: copumpkin set -o copumpkin
20:26:45 <copumpkin> monochrom: whoops, thought I did that
20:27:06 --- mode: monochrom set -b DT-180!*@*
20:27:12 <TomMD> thanks copumpkin - goodnight!
20:27:13 --- mode: monochrom set -o monochrom
20:27:33 <monochrom> admittedly banning the whole isp is unsatisfactory
20:28:46 <copumpkin> monochrom: yeah
20:29:03 <copumpkin> especially since he obviously controls other domains
20:29:07 <copumpkin> but not much we can do about it
20:29:24 <copumpkin> anyone listening, please notify #haskell-ops if you get private message spam that seems related to #haskell
20:29:28 <copumpkin> (often about #calculus)
20:30:05 <Seta00> why did you ban *.i-next.psi.br monochrom?
20:30:08 <lpsmith> oh, private message spam?  I was wondering what had happened...
20:30:18 <Seta00> >_>
20:30:24 <Seta00> you know, reading is hard and all
20:30:31 <lpsmith> :)
20:30:31 <osoleve> could someone hilight me so i can go to bed, please? ##programming is sleeping
20:30:42 <djahandarie> osoleve?
20:30:46 <copumpkin> Seta00?
20:30:58 <osoleve> djahandarie: thanks much, night all
20:31:03 <djahandarie> Night!
20:31:08 <TomMD> :set hl
20:31:08 <TomMD> /osoleve
20:31:13 <TomMD> you are a vim user, right?
20:31:35 <Seta00> copton: a lot of channels on freenode have .br bans or brazilian ISP bans, I just wanted to know the reason
20:31:36 <ymasory> what does it mean to say a type system is turing complete? how can we define input and output to a type system to make that claim meaningful?
20:31:45 <Seta00> (I'm brazilian but I have a ZNC in the US)
20:32:11 <monochrom> temporary measure
20:33:12 <Dark_Shikari> Is there an easy way to convert characters to integers in haskell?
20:33:31 <rothwell> ugh... seems impossible to validate against a relax-ng schema with hxt without being in IO
20:33:40 <djahandarie> Dark_Shikari, ord from Data.Char
20:33:49 <Dark_Shikari> Like, a function.
20:33:56 <djahandarie> :t ord
20:33:57 <lambdabot> Char -> Int
20:34:01 <Dark_Shikari> so ord c
20:34:10 <djahandarie> Where c :: Char, yes :P
20:35:58 <Dark_Shikari> That converts Char to Int instead of Char to Integer
20:36:03 <Dark_Shikari> ... what's the difference between Integer and Int?
20:36:15 <osoleve> size
20:36:26 <Dark_Shikari> so how do I convert Int to Integer?
20:36:47 <Axman6> fromIntegral
20:36:58 <Axman6> :t fromIntegral 
20:36:59 <lambdabot> forall a b. (Integral a, Num b) => a -> b
20:37:02 <djahandarie> :t fromIntegral (3 :: Int)
20:37:02 <lambdabot> forall b. (Num b) => b
20:37:07 <djahandarie> :t fromIntegral (3 :: Int) :: Integer
20:37:07 <lambdabot> Integer
20:37:11 <djahandarie> :)
20:46:56 <gio123>  can one answer me whether U_{1=<i=<n}x_i U U{1=<j=<m} y_j is same as U_{1=<i=<n,1=<j=<m} {x_i,y_j} ?     
20:50:17 --- mode: ChanServ set +o copumpkin
20:50:20 <Eduard_Munteanu> gio123: is 'U' union?
20:50:34 <Axman6> gio123: isn't the first a union of sets which results in a set of x and y values, and the second results in a set of sets of x and y values? not sure if that matters
20:50:34 <gio123> yes
20:50:46 <Eduard_Munteanu> Yeah, it's not the same.
20:51:02 <gio123> aha
20:51:03 <Eduard_Munteanu> {x_i, y_j} will always be like nested sets
20:51:14 <gio123> aha
20:51:33 --- mode: ChanServ set +o monochrom
20:51:34 <gio123> I need to write union of x_i and y_j
20:51:39 --- mode: monochrom set +b *!*@95.69.9.219
20:51:39 <gio123> can one tell me coherant way?
20:51:55 --- mode: monochrom set -o monochrom
20:52:07 <gio123> coherant way of
20:52:24 <gio123> U_{1=<i=<n}x_i U U{1=<j=<m} y_j 
20:53:29 <Eduard_Munteanu> monochrom: who's that fellow?
20:53:37 <copumpkin> Eduard_Munteanu: who knows!
20:54:09 <Eduard_Munteanu> Heh. I mean, why did you and mono get worked up about him?
20:54:23 <monochrom> let's just say I'm paranoid about something who tries to rotate its nick three times
20:54:35 <copumpkin> Eduard_Munteanu: a bunch of number-named bots from that same IP joined within a short period
20:55:27 <Eduard_Munteanu> Ah, the kind that gets a channel listing, spams and gets away.
20:55:38 <copumpkin> who knows
20:55:42 <copumpkin> I'm more worried about joinfloods
20:55:53 <copumpkin> but they're all from the same IP so it doesn't look too bad
20:56:11 <Eduard_Munteanu> gio123: what do you mean?
20:56:49 <gio123> Eduard, more nice way then it look likes what i wote, but concept to be invariant :)
21:03:36 <kuda> Hello
21:04:50 <kuda> I'm new to haskell, I want to write a simple 'cms', what is the best web framework to start out with?
21:06:12 <monochrom> toss a coin to pick one: snap, yesod
21:06:45 <monochrom> but learn haskell first. very different language, do not expect "dive-in project" to work.
21:06:48 <djahandarie> kuda, if you're new to Haskell a CMS isn't a greate place to start
21:07:04 <djahandarie> How did that 'e' sneak in there...
21:07:18 <monochrom> "dive-in project" works for "transitioning from php to ruby" because they are the same.
21:07:28 <kuda> ah i see
21:07:42 <kuda> what would you recommend?
21:08:07 <monochrom> "I am new to Chinese, I want to write in Chinese a movie review for a Chinese movie"
21:08:12 <monochrom> will not work
21:08:27 <djahandarie> Sometimes I feel like your English is broken, monochrom, but then I realize you are using quotation marks to identify your variables
21:08:27 <dolio> Just write a Haskell compiler, like John Meacham.
21:08:39 <djahandarie> kuda, have you followed a tutorial yet?
21:08:41 <monochrom> anyway, try something listed on http://www.vex.net/~trebla/haskell/learn-sources.xhtml
21:08:52 <dolio> Perfect Haskell dive-in project.
21:09:09 <djahandarie> monochrom, argh, don't list the gentle introduction first :p
21:09:28 <monochrom> eh? I list tryhaskell.com first
21:09:30 <kuda> djahandarie: not thouruglhy, bits and pieces, learnyouahaskell and real world haskell are on my to read
21:09:51 <djahandarie> monochrom, well, on the second list I mean
21:09:58 <monochrom> therefore it is 2nd.
21:10:18 <monochrom> eh? where has tryhaskell.com gone?!
21:10:22 <djahandarie> I shall reword my statement. Don't list the gentle introduction before learnyouahaskell
21:10:36 <Axman6> kuda: read LYAH now then ;)
21:10:42 <monochrom> oh cool tryhaskell.org
21:10:56 <djahandarie> kuda, play with those. If you want real-world stuff, RWH has it.
21:11:05 <djahandarie> I don't remember if it does any web stuff or not
21:11:25 <Eduard_Munteanu> Dang ISP.
21:11:25 <kuda> great, thank you all
21:12:29 <monochrom> Fixed. And placed lyah higher as you wish!
21:12:36 <lpsmith> err
21:12:44 <lpsmith> how do I get information out of an IOError?
21:12:49 <lpsmith> err, IOException
21:12:52 <kuda> monochrom: how are php and ruby the same?
21:13:02 <Eduard_Munteanu> @src IOException
21:13:02 <lambdabot> Source not found. Take a stress pill and think things over.
21:13:05 <djahandarie> monochrom, yeay. :)
21:13:37 <monochrom> I know they are different. After seeing the bigger difference between haskell and ruby, you will feel php and ruby are the same.
21:14:03 <monochrom> The same way when you look at the Milky Way, the Sun and Earth are pretty much the same pixel.
21:14:13 <lpsmith> I'm looking at the source of System.Posix,  and I see that some information is recorded when it throws an error
21:14:19 <lpsmith> but how do I get access to that info?
21:14:26 <djahandarie> Pixel?! I didn't know that's how my eyes worked...
21:14:38 <kuda> monochrom: is that the functional part?
21:14:52 <monochrom> the functional part is the smallest difference
21:14:59 <Eduard_Munteanu> lpsmith: maybe using guards with stuff in here? http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html
21:14:59 <lpsmith> In particular,  I'd like to get access to the errno
21:15:00 <kuda> hmm i'm curious now
21:18:29 <jeffwheeler> I just found this function, and am trying to figure out what it actually does: lazy l = head l : lazy (tail l)
21:18:42 <jeffwheeler> It seems like it doesn't do anything at all . . .
21:18:49 <Eduard_Munteanu> lpsmith: I only see stuff like this: http://www.haskell.org/ghc/docs/7.0.2/html/libraries/unix-2.4.2.0/System-Posix-Error.html
21:18:58 <jeffwheeler> @let lazy l = head l : lazy (tail l)
21:18:58 <lambdabot>  Defined.
21:18:59 <Eduard_Munteanu> So maybe they only contain the path?
21:19:07 <jeffwheeler> > lazy [3, 4, 6]
21:19:09 <lambdabot>   [3,4,6,*Exception: Prelude.head: empty list
21:19:28 <monochrom> I don't think "head 1" makes sense. as in type-checks.
21:19:52 <jeffwheeler> monochrom: it's a lower ell
21:19:58 <monochrom> oh oops!
21:20:05 <lpsmith> I'm getting the sinking feeling that it might be easier to write my own binding to the Posix api.
21:20:24 <jeffwheeler> > lazy [1..]
21:20:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:20:39 <jeffwheeler> I have no idea idea why this function is useful.
21:20:48 <monochrom> not a very useful function.
21:21:28 <monochrom> educational, sure. it show some subtle points of haskell semantics.
21:21:32 <jeffwheeler> > head [1, 2, 3, error "ack!"]
21:21:33 <lambdabot>   1
21:21:34 <lpsmith> Eduard_Munteanu, http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/src/Foreign-C-Error.html#errnoToIOError
21:21:41 <jeffwheeler> > head $ lazy [1, 2, 3, error "ack!"]
21:21:42 <lambdabot>   1
21:21:55 <lpsmith> clearly the errno is getting recorded
21:21:57 <lpsmith> but
21:22:01 <monochrom> > length (take 10 (lazy []))
21:22:02 <lambdabot>   10
21:22:06 <monochrom> > length (take 1000 (lazy []))
21:22:07 <lambdabot>   1000
21:22:16 <monochrom> try to sleep on that tonight
21:22:27 <monochrom> hell, in fact...
21:22:29 <jeffwheeler> You've just broken my mind.
21:22:32 <monochrom> > length (take 1000 (lazy undefined))
21:22:33 <lpsmith> what I don't understand is that the module doesn't import the IOError constructor
21:22:34 <lambdabot>   1000
21:22:43 <lpsmith> yet it makes use of it
21:23:05 <lpsmith> wait, n/m
21:23:07 <jeffwheeler> > head (take 1000 (lazy undefined))
21:23:08 <lambdabot>   *Exception: Prelude.undefined
21:23:09 <monochrom> note carefully that I dare only ask for the length, not any of the content. (all contents will be undefined)
21:23:30 <djahandarie> Heh monochrom, nice
21:23:32 <dainanaki> Does it bug anyone else how the reader monad is a mixed metaphor?
21:23:45 <dainanaki> sorry, I mean the writer monad
21:23:46 <monochrom> length cares only about how many ":"s it sees. bear that in mind.
21:24:19 <Eduard_Munteanu> Hm, interesting, though IOError seems to have a hidden constructor
21:24:49 <jeffwheeler> monochrom: hmm, that's interesting. You get (head undefined) : lazy (tail (undefined)) a 1000 times or so, I guess.
21:24:53 <jeffwheeler> That's strange.
21:25:08 <monochrom> yeah
21:25:11 <lpsmith> Eduard_Munteanu, it's defined in GHC.IO.Exception, which doesn't seem to be exported
21:25:43 <lpsmith> you know,  I really think it would be easiest to write my own bindings
21:25:46 <lpsmith> which is kind of sad
21:26:18 <lpsmith> but hey,  I don't need very many of them
21:27:59 <Eduard_Munteanu> lpsmith: wait, GHC.IO.Exception does export IOError
21:27:59 <Axman6> :t lazy
21:28:00 <lambdabot> forall a. [a] -> [a]
21:28:07 <lpsmith> right
21:28:18 <lpsmith> but GHC.IO.Exception isn't available to userland code,  it appears
21:28:32 <lpsmith> at least, it's not in my documentation index
21:28:39 <Axman6> > lazy []
21:28:40 <lambdabot>   [*Exception: Prelude.head: empty list
21:28:43 <Eduard_Munteanu> {-# OPTIONS_HADDOCK hide #-}
21:28:44 <lpsmith> err
21:28:51 <lpsmith> I can import it though
21:28:52 <lpsmith> thanks
21:29:03 <Eduard_Munteanu> lpsmith: maybe that makes it disappear from docs?
21:29:13 <lpsmith> why the heck would they not generat haddocks for this module?
21:29:37 <Eduard_Munteanu> I suppose GHC.* stuff isn't much stable anyway.
21:29:46 <Eduard_Munteanu> (as in stable API)
21:29:49 <lpsmith> right
21:30:09 <lpsmith> Yeah, I haven't used the GHC.* modules extensively enough to know
21:30:16 <lpsmith> how stable they are or not
21:30:45 <Eduard_Munteanu> I suppose primops and such are quite stable, though those are documented by Haddock.
21:31:08 <lpsmith> well, for some value of "quite stable" anyway
21:31:32 <lpsmith> fairly,  but you never know when somebody's going to decide to change something either
21:31:37 <lpsmith> which all in all, is ok
21:31:44 <lpsmith> because it's usually for the better
21:36:19 <gienah> jeffwheeler: I will bump yi in the gentoo overlay later. I sent you an old school yi.cabal to build the docs.
21:36:41 <jeffwheeler> gienah: I saw your email. Thanks. I'm not sure what to do about that bug.
21:36:54 <jeffwheeler> And I really appreciate you putting it in Gentoo! Exciting!
21:37:39 <gienah> jeffwheeler: I can send you a copy of the yi docs if you like your new yi.cabal, so the yi docs could be uploaded somewhere so that people on os's other then gentoo could read them
21:38:15 <jeffwheeler> gienah: you make a strong point. It may be worth using the old-style cabal for the moment, until that bug can be fixed.
21:38:35 <jeffwheeler> I might use your cabal tonight or so.
21:39:02 <gienah> jeffwheeler: probably would be better for yi if people had the docs :-)
21:39:10 <jeffwheeler> gienah: yeah, heh :D
21:39:51 <gienah> jeffwheeler: I think it would be really neat if, in my dreams, yi had a tiling window manager like xmonad in yi with virtual screens
21:40:19 <jeffwheeler> gienah: funnily enough, I was just looking at how the xmonad tiling worked a few hours ago.
21:40:38 <gienah> jeffwheeler: that's awesome :-)
21:40:41 <jeffwheeler> gienah: it's a bit beyond me for the moment, but it looks like most of xmonad's is done in just, like, one file. Pretty concise.
21:40:52 <jeffwheeler> gienah: http://xmonad.org/xmonad-docs/xmonad/XMonad-StackSet.html
21:41:10 * hackagebot enumerator 0.4.8 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.8 (JohnMillikin)
21:41:41 <jeffwheeler> (How could would it be if that could be abstracted from xmonad . . .)
21:41:42 <gienah> jeffwheeler: emacs can sort of do this (tiling and virtual screens), its very useful
21:41:48 <jeffwheeler> * cool
21:41:48 * Eduard_Munteanu wishes xmonad releases happened more often
21:42:12 <Eduard_Munteanu> 0.9 is kinda rotting already
21:42:24 * dainanaki wishes that xmonad worked on OS X outside of X11
21:42:30 <dainanaki> alas
21:42:50 <Axman6> it has been suggested, and it would be possible, just difficult
21:42:50 <jeffwheeler> That one's a lot harder . . . :P
21:42:59 <Axman6> there are apps that do similar things
21:43:06 <dainanaki> Yes, but not scriptable
21:43:13 <dainanaki> Especially not in Haskell
21:43:17 <jeffwheeler> Yeah, but none very well. They can't really "enforce" it.
21:43:20 <Eduard_Munteanu> Can't you get X11 on OS X?
21:43:32 <jeffwheeler> Eduard_Munteanu: yep, but only for X11 apps
21:43:34 <dainanaki> yes, but X11 wms only apply to X11 apps
21:43:37 <Axman6> Eduard_Munteanu: why on earth you'd want to i have no idea
21:43:48 <Axman6> i only ever use it for ssh -X
21:44:11 <Eduard_Munteanu> I'm not sure if anything on Mac plays well with xmonad's spirit.
21:44:25 <Eduard_Munteanu> At least not Mac apps, sure you can get xterms and that sort of stuff there.
21:44:26 <Axman6> sure it does, see divvy
21:44:40 <Axman6> or hyperdock to a lesser extent
21:45:42 * Eduard_Munteanu should stop, he barely touched Mac stuff :)
22:04:00 <lpsmith> maybe I'm looking at this problem all wrong.  Maybe I should be calling System.Posix.Files.setFileCreationMask and then calling the standard (non-posix) directory manipulation functions
22:04:13 <lpsmith> however,  does setFileCreationMask affect other threads as well?
22:04:35 <lpsmith> I think I would assume so
22:04:39 <lpsmith> sigh
22:05:56 <lpsmith> yeah it would
22:47:58 <mzero> Is there no way to flatten Alternatives without Monad?
22:48:30 <mzero> that is, I have a function   that is like     a -> Alternative b
22:48:54 <mzero> given that I have an Alternative a    I want to feed that to my function    much like  >>=
22:49:43 <mzero> What I want, when the instance of Alternative is [], is for the function to be applied to each value, and the results all <|>'d together 
22:50:03 <mzero> this is what >>= would do, but then I've got to put Monad in all the type constraints
22:50:12 <mzero> seems like Alternative should be able to do this...
22:50:34 <mzero> ... but I find no  join like operation on Alternative 
22:51:19 <jmcarthur> if it had join it would be Monad
22:52:12 <mzero> so, alas, I have to have both type class constraints....
22:52:16 <mzero> ?
22:52:17 <jmcarthur> but it doesn't sound like join is really what you want anyway. this sounds more like a mapFold sort of thing
22:52:46 <jmcarthur> err... foldMap is what i think i meant
22:52:55 <jmcarthur> :t Data.Foldable.foldMap
22:52:55 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
22:52:56 <mzero> well, fmapFold, eh? as the instance could be, Maybe
22:53:13 <jmcarthur> but instead of Monoid that could be Alternative or something
22:53:20 <mzero> yeah - or asum
22:53:25 <mzero> :t asum
22:53:25 <lambdabot> Not in scope: `asum'
22:53:50 <mzero> :t Foldable.asum
22:53:50 <lambdabot> Couldn't find qualified module.
22:53:50 <jmcarthur> i've never heard of asum
22:53:50 <jmcarthur> @hoogle asume
22:53:50 <lambdabot> No results found
22:53:50 <jmcarthur> @hoogle asum
22:53:50 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
22:53:52 <jmcarthur> aha
22:54:06 <mzero> :t Data.Foldable.asum
22:54:07 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Alternative f) => t (f a) -> f a
22:56:04 <mzero> well... that is technically more correct - thought for the exposition I wanted this for, that is going to far out from the main topic --- so I'll stick with Monad, which my reader has already seen (and probably assumed)
22:56:55 <jmcarthur> you could always just write out asum manually
22:57:02 <jmcarthur> @src Data.Foldable.asum
22:57:02 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:57:18 <jmcarthur> :t foldr (<|>) empty
22:57:19 <lambdabot>     Ambiguous occurrence `empty'
22:57:19 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
22:57:19 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
22:57:37 <jmcarthur> :t Data.Foldable.foldr (<|>) Control.Applicative.empty
22:57:38 <lambdabot> forall (f :: * -> *) a (t :: * -> *). (Alternative f, Data.Foldable.Foldable t) => t (f a) -> f a
22:57:45 <miller> How does one google for a haskell operator? For example, I'd like to ask google what :-> is, but google ignores all symbols...
22:57:56 <jmcarthur> miller: try hoogle or hayoo
22:58:32 <miller> jmcarthur: thanks!
23:13:34 <Eduard_Munteanu> Indeed, I sometimes wish for a search engine that took regexps and all chars.
23:58:35 * hackagebot RBTree 0.0.3 - Pure haskell Red-Black-Tree implemetation  http://hackage.haskell.org/package/RBTree-0.0.3 (XingboWu)
