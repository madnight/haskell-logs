00:07:40 <mm_freak_> interesting problem:  given i don't want to use agda i would like to do the following on the type level, ideally with normal Int/Integer types:
00:08:19 <mm_freak_> i have a recursive function (Int -> Something)…  each recursive call MUST either terminate or decrease the integer by 1
00:08:39 <mm_freak_> can i check this statically?
00:09:05 <mm_freak_> i would know how to do it with a Nat type, but i'd like to avoid that, because this is a piece of high performance code
00:09:51 <aristid> mm_freak_: can you give the full type of the function?
00:10:02 <hpaste> glguy pasted "software stack puzzle"  http://hpaste.org/44469
00:12:28 <mm_freak_> aristid: forall m r. Monad m => Int -> MaybeT r (Iteratee ByteString m) ByteString
00:13:54 <aristid> mm_freak_: and it is recursive?
00:14:47 <aristid> forM_ [n, n - 1 .. 0] ?
00:21:47 <dixie> hmm... hat-tools are part of what package? I would like to look on delta debugging algorithm impl. within hat-delta
00:22:01 <mm_freak_> aristid: yes, but i can't use mapM…  i'd need to use foldM if anything
00:22:36 <mm_freak_> but my question is to ensure this on the type level, because i don't want to remove the recursive notation
00:23:16 <aristid> mm_freak_: maybe if you use some kind of transformer, you may actually be able to use mapM
00:24:41 <aristid> also i don't see how this would not be ensuring it on the type level, if it works
00:26:39 <path[l]> I saw this video yesterday about fortress and there was this discussion of how a compiler or runtime could at some point choose to parallelise a reduce operation if it new the operation was associative or commutative or both. In haskell is there some pleasing way to describe a function as such?
00:27:45 <koala_man> a monoid?
00:28:06 <path[l]> ah. I knew a monoid had a zero and an identity
00:28:11 <aristid> Monoids are associative by law
00:28:13 <path[l]> I didnt realise that this was also part of it
00:28:28 <path[l]> all operations are associative?
00:28:34 <aristid> but not commutative
00:28:40 <aristid> path[l]: there is only one operation.
00:28:58 <aristid> :t mappend
00:28:59 <lambdabot> forall a. (Monoid a) => a -> a -> a
00:29:13 <path[l]> oh ok. I guess I need to understand exactly what a monoid is
00:29:26 <Jafet> > foldl1 mappend [1..1000000]
00:29:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:29:27 <lambdabot>    `GHC.Enum.Enum a'
00:29:27 <lambdabot>      a...
00:29:38 <Jafet> > foldl1 (mappend :: Int -> Int -> Int) [1..1000000]
00:29:39 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
00:29:39 <lambdabot>    arising from a use of...
00:30:00 <path[l]> does the type system detect if something is associative? Or is that something which cannot be proven by the compiler?
00:30:06 <Jafet> I just wanted to see the error messages, sorry
00:30:56 <Jafet> path[l]: haskell isn't meant for writing such proofs in it
00:31:50 <path[l]> hmm ok let me read a little more about monoids and get back to this :)
00:31:52 <Jafet> But you can add a ghc rewrite rule for fold/mappend, for instance, and the Monoid constraint becomes an assertion of that property
00:33:57 <Jafet> Parallelism also might not work so well for folding lists, even if an implementation is somehow smart enough to figure out whether it benefits the fold itself
00:33:57 <path[l]> I was just trying to figure out what information could be provided so foldl + [1..10000] could be parallelisable but maybe foldl /  [1..100000] is not
00:34:06 <path[l]> well
00:34:24 <path[l]> the thrust of the talk was that there might be a point in the future where on some architectures
00:34:33 <path[l]> some operations should be parallelised
00:34:46 <path[l]> and if we can easily provide hints, thats always better
00:36:28 <aristid> path[l]: Monoid has a law that it must be associative, but it is not enforced.
00:36:48 <path[l]> got it thanks
00:37:14 <path[l]> I think fortress is the same way in the sense that it is enforced by some randomly generated tests
00:37:25 <path[l]> but not by the type system itself
00:37:51 <Jafet> Stochastic type system?
00:37:56 <Jafet> Interesting
00:38:06 <path[l]> I dont really know what that means :)
00:39:06 <Jafet> Me neither
00:42:07 <aristid> path[l]: you can have randomly generated tests for this in haskell too :)
00:43:38 <path[l]> yes, I'm aware. That's why I said it was similar. I was wondering if it was even possible to build a useable type system that could, given a function, decide if it was associative or not. My instinct says no though
00:46:13 <fram> I'm getting the "GHC Panic! The impossible happened. Failed reading byte at position 65505" bug, under debian. What can I do? I tried removing the .hi files of my project, and reinstalling ghc, but this didnt work
00:46:25 <Jafet> Decide? Haskell lets you assert. Agda and Coq let you prove.
00:46:48 <lpsmith> erm,  how do I truncate a file at the current position?   there is hGetPosn,  which returns a HandlePosn,  but I don't see a way to convert that to an integer for hSetFileSize.
00:48:16 <lpsmith> I mean, I suppose I could process the output of show :: HandlePosn -> String,  but that seems a kludge
00:49:10 * hackagebot clash 0.1.2.5 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.2.5 (ChristiaanBaaij)
00:50:00 <Jafet> HandlePosn seems to have a strange lack of class membership
00:51:09 <lpsmith> yeah,  I think HandlePosn represents a small piece of overengineering
00:51:48 <lpsmith> or under, or something
00:51:56 <Jafet> An equally evil hack is to import GHC.IO.Handle and pattern match out the value
00:52:54 <lpsmith> Jafet,  no, that's definitely a far less evil hack :)
00:53:02 <lpsmith> Thanks!
00:53:21 <lpsmith> (Far, *far* less evil hack)
00:58:02 <hpaste> poopington pasted "poop"  http://hpaste.org/44470
01:01:58 <hpaste> cheesington pasted "callanispoo"  http://hpaste.org/44471
01:14:36 <mm_freak_> aristid: ensuring on the type level means:  if i'm in 'f n' and call 'f' recursively with anything but n-1, then it should not type-check
01:22:41 <mm_freak_> but i found that it doesn't work out anyway…  i have to call with other values, too
01:59:27 <dan_> I'm trying to use the approximation lemma to prove that two lists are equivalent. But I'm stuck in a circle. Can anyone give me a pointer in the right direction? What I have is here: http://hpaste.org/44475/
02:24:38 <Jonno_FTW> dan_: you might want to label your question on SO with the haskell tag as well
02:29:22 <dan_> It's interesting that Haskell textbooks don't include introductory material on proving properties of infinite data structures. I'm thinking of "Craft of Functional Programming" in particular, since it has sections on inductive proofs.
02:36:35 <Jonno_FTW> hmm
02:37:02 <sg|> hello all 
02:37:19 <hpaste> sg pasted "example"  http://hpaste.org/44478
02:37:37 <sg|> http://hpaste.org/44478/example  Code is working properly but I would like ti get result in to decimal. How can I do it ? 
02:38:18 <sg|> http://hpaste.org/44478/example ,code is working properly. But I would like to get results in 2 decimal. How can I do it ? 
02:39:08 <dan_> Float values are decimal numbers already, aren't they?
02:39:27 <Eduard_Munteanu> He means like 1.50
02:39:46 <sg|> dan_  yeap but I mean in 1.50 now I am getting 223.8385
02:39:53 <sg|> i want 223.83
02:41:59 <sg|> any help ?
02:42:53 <Eduard_Munteanu> > let myRounding x = (fromIntegral . round $ x * 100) / 100 in myRounding 1.507543
02:42:55 <lambdabot>   1.51
02:43:30 <Eduard_Munteanu> > let myRounding x = (fromIntegral . truncate $ x * 100) / 100 in myRounding 1.507543
02:43:32 <lambdabot>   1.5
02:45:05 <Eduard_Munteanu> Or you can use full precision and truncate the output string (I suppose there is some output somewhere)
02:46:21 <sg|> Eduard_Munteanu  thanks for helping, could you please implement the code on http://hpaste.org/44478/example ?
02:47:47 <Eduard_Munteanu> Well that depends on where you want that rounding to occur. Normally on such things you do the rounding when printing some output.
02:48:39 <Eduard_Munteanu> So you could have your showPrice :: Float -> String that does that.
02:49:50 <co_dh> ping
02:49:57 <Eduard_Munteanu> pong
02:50:35 <sg|> Eduard_Munteanu  yes I want to round it on print. but donna how to do it , newbie on haskell
02:52:42 <Eduard_Munteanu> sg|: 'show' already converts the Float to a String. You merely have to clamp everything after '.' and 2 more digits (chars).
02:52:53 <Eduard_Munteanu> s/clamp/remove/
02:53:31 <Eduard_Munteanu> > show 1.507543
02:53:32 <lambdabot>   "1.507543"
02:56:16 <sg|> Eduard_Munteanu sorry but I didnt get what you mean, command : 'alfredo 20 1'  gives me 1.2566371 as a result and 'alfredo 34 9' gives '25.421768'
02:56:40 <sg|> i want all my results on 2 decimal like 1.25 and 25.42
02:56:59 <Eduard_Munteanu> sg|: what about 1.5 vs 1.50?
02:57:28 <sg|> Eduard_Munteanu   1.50 
02:57:30 <Eduard_Munteanu> If you really want 1.50 you'll have to do your own printing stuff.
02:57:30 <sg|> is ok 
02:57:46 <sg|> 1.50 is ok 2 decimal 
02:58:16 <sg|> Eduard_Munteanu  1.5 is also okey 
02:58:24 <sg|> I dont want 1.3231312
02:58:34 <Eduard_Munteanu> Oh, then you can do like I did before...
02:58:50 <Eduard_Munteanu> > let myRounding x = (fromIntegral . truncate $ x * 100) / 100 in myRounding 1.507543
02:58:51 <lambdabot>   1.5
02:59:20 <sg|> Eduard_Munteanu  did you check http://hpaste.org/44478/example ?
02:59:25 <Eduard_Munteanu> Yes.
02:59:35 <Eduard_Munteanu> Why do you ask?
02:59:43 <sg|> Eduard_Munteanu umm than I am so bad with haskell : ) 
03:00:05 <sg|> Eduard_Munteanu  because I dont know where to add your code in to my code
03:00:06 <Eduard_Munteanu> You just have to add myRounding there before your function returns.
03:00:41 <Eduard_Munteanu> Just call myRounding on the 'otherwise' case with the result as the argument
03:01:24 <sg|> Eduard_Munteanu : | otherwise =  basePrice x + (toppingPrice x y) * 1.5 && myRounding x = (fromIntegral . truncate $ x * 100) 
03:01:26 <sg|> like this ?
03:01:45 <Eduard_Munteanu> No, not like that.
03:02:17 <Eduard_Munteanu> Ok, your function already outputs a proper result, only it's not rounded as you want.
03:02:43 <Eduard_Munteanu> myRounding takes that result and rounds it.
03:03:34 <Eduard_Munteanu> So, on the 'otherwise' case, you need to call myRounding on 'basePrice x + (toppingPrice x y) * 1.5'
03:03:48 <Eduard_Munteanu> (You can simply add myRounding's definintion to the where block)
03:04:43 <sg|> Eduard_Munteanu trying it now
03:06:49 <sg|> Eduard_Munteanu  when I add definiton of myRounding, when compiling gives me error : parse error on input '='
03:07:35 <Eduard_Munteanu> sg|: how did you add it exactly? Repaste the whole thing.
03:07:43 <sg|> Eduard_Munteanu  doing it 
03:09:02 <sg|> Eduard_Munteanu sorry for foring your nerves too much appriciate for your help
03:09:03 <sg|> http://hpaste.org/paste/44478/example_annotation#p44479
03:09:17 <Eduard_Munteanu> Ah, no problem at all.
03:09:50 <Eduard_Munteanu> sg|: well, you added the same definition twice, and you didn't call it.
03:10:25 <Eduard_Munteanu> Think about it: your function is Float -> Float -> Float, myRounding is Float -> Float
03:10:40 <Eduard_Munteanu> You want yours to go through myRounding before returning.
03:13:06 <sg|> Eduard_Munteanu: http://hpaste.org/paste/44478/example_annotation#p44480 
03:13:19 <sg|> Eduard_Munteanu  but i dont know how call myrounding function 
03:13:25 <sg|> how to call it I mean ...
03:13:57 <Eduard_Munteanu> sg|: your previous result (the one that wasn't rounded) was 'basePrice x + (toppingPrice x y) * 1.5 
03:14:30 <Eduard_Munteanu> So your 'otherwise' case needs to do myRounding on that.
03:14:42 <Eduard_Munteanu> Calling means applying that function to something.
03:15:20 <Eduard_Munteanu> i.e., if 'f' is a function, calling 'f' with an argument of 0.5 is simply 'f 0.5' in Haskell.
03:17:29 <sg|> Eduard_Munteanu so is it like otherwise = myRounding && 
03:17:32 <sg|> basePrice x + (toppingPrice x y) * 1.5 
03:17:33 <sg|> this
03:17:38 <sg|> ?
03:18:10 <Eduard_Munteanu> sg|: why the '&&' there?
03:18:16 <sg|> and ?
03:18:17 <Eduard_Munteanu> :t (&&)
03:18:18 <lambdabot> Bool -> Bool -> Bool
03:19:12 <Eduard_Munteanu> Ok, I'm going to spoil it and give you the answer: otherwise = myRounding (basePrice x + (toppingPrice x y) * 1.5)
03:19:26 <Eduard_Munteanu> Why did you think '&&' was appropriate there?
03:24:06 <sg|> sorry i get dc.
03:24:35 <Eduard_Munteanu> 13:55 < Eduard_Munteanu> Ok, I'm going to spoil it and give you the answer: otherwise = myRounding (basePrice x + (toppingPrice x y) * 1.5)
03:24:38 <Eduard_Munteanu> 13:55 < Eduard_Munteanu> Why did you think '&&' was appropriate there?
03:25:16 <sg|> Eduard_Munteanu I thought && for and but I learn when we are calling a function writing function name is enough
03:25:25 <sg|> Eduard_Munteanu  this is last task : http://hpaste.org/paste/44478/example_annotation#p44481
03:26:00 <sg|> Eduard_Munteanu ok have to call it before 
03:26:35 <Eduard_Munteanu> Well, what does it mean to call/apply 'alfredo'? Doesn't it mean writing something like 'alfredo 1 2'?
03:26:56 <sg|> Eduard_Munteanu yes alfredo 10 9 
03:27:12 <Eduard_Munteanu> Same thing here, except myRounding takes a single argument
03:27:52 <sg|> umm
03:29:31 <sg|> Eduard_Munteanu  http://hpaste.org/paste/44478/example_annotation#p44483 
03:29:38 <sg|> last file but not compiling 
03:29:46 <sg|>     The type signature for `myRounding' lacks an accompanying binding
03:30:38 <Eduard_Munteanu> myRounding's type signature is top-level, but its actual definition is in the 'where' block. Both must be in the same place.
03:31:41 <Eduard_Munteanu> Secondly, you forgot the '/ 100' there.
03:31:56 <Eduard_Munteanu> > let myRounding x = (fromIntegral . truncate $ x * 100) / 100 in myRounding 1.507543
03:31:58 <lambdabot>   1.5
03:32:08 <sg|> I add /100 on my rounding function ok 
03:32:39 <sg|> how can I replace signature in same block ? any example ?
03:33:29 <Eduard_Munteanu> Either move the type signature in the where block, or move myRounding's definition to the top level (outside the 'where' block, just like in 'alfredo's case).
03:33:36 <Bfig> if you want to pass an operator as a parameter you put it inside brackets right?
03:34:32 <Eduard_Munteanu> Bfig: yes, paranthesis
03:34:52 <Eduard_Munteanu> > zipWith (+) [1..4] [5..6]
03:34:53 <lambdabot>   [6,8]
03:35:12 <Eduard_Munteanu> > zipWith (+) [1..4] [5..8]
03:35:13 <lambdabot>   [6,8,10,12]
03:35:31 <Bfig> cool, thanks
03:36:16 <Bfig> cool, the bot can exec code, can you define functions on it?
03:36:26 <Eduard_Munteanu> > let add x y = x + y in zipWith add [1..4] [5..8]
03:36:27 <lambdabot>   [6,8,10,12]
03:36:43 <Bfig> nice :)
03:36:50 <sg|> Eduard_Munteanu  thanks, Now it is working, final task :http://hpaste.org/paste/44478/example_annotation#p44484 
03:37:03 <Eduard_Munteanu> Bfig: so this actually applies only to infix operators, since paranthesis merely convert an infix to a prefix (i.e. a normal function)
03:37:18 <Eduard_Munteanu> Bfig: yes
03:37:38 <Bfig> i was seeing the example of ++ on zipWith and i figured that was what was happening but i wanted to make sure 
03:37:52 <omie> Hi
03:38:02 <Bfig> i'm reading the craft of functional programming 2nd ed
03:38:33 <omie> I was trying code posted here : http://stackoverflow.com/questions/3078288/http-post-contents-in-haskell no idea why its sending data
03:38:40 <Eduard_Munteanu> Bfig: you might want to take a look at LYAH if you want a free Haskell (e)book
03:38:42 <mm_freak_> when exactly does a language support first class continuations?  it appears to me like every functional language with closures supports them
03:38:43 <Eduard_Munteanu> @where lyah
03:38:43 <lambdabot> http://www.learnyouahaskell.com/
03:39:06 <omie> i meant, no idea why its *not* sending data
03:40:03 <mm_freak_> omie: you should always specify the /library/ you're using
03:40:08 <mm_freak_> a module is not a library
03:40:24 <osfameron> mm_freak_: isn't that tunneling continuations through closures - i.e. the closure itself isn't a distinct part of the language then ?
03:40:45 <Bfig> Eduard_Munteanu, when i'm done with my book i'll check that site, the internet is a generous father
03:41:07 <mm_freak_> osfameron: i don't understand
03:42:01 <hpaste> Stackoverflow pasted "Network.HTTP request"  http://hpaste.org/44485
03:42:15 <omie> mm_freak_: code I am trying ^
03:42:41 <omie> i modified it little bit and removed module thingi
03:42:46 <mm_freak_> omie: yes, but which HTTP library are you using?  there are many of them
03:43:45 <mm_freak_> appears to be 'HTTP'
03:43:52 <omie> mm_freak_: I am not sure if this is the answer but I see its Network.HTTP and Network.TCP
03:47:35 <hpaste> sg pasted "without rounding"  http://hpaste.org/44486
03:48:25 <sg|> Eduard_Munteanu : http://hpaste.org/44486/without_rounding This one is without rounding and giving me correct answers.
03:49:00 <sg|> http://hpaste.org/paste/44486/with_rounding#p44487 this one is with rounding but giving me wrong result.
03:51:46 <sg|> Eduard_Munteanu  maybe rounding code is wrong ?
03:54:25 <Eduard_Munteanu> sg|: what do you mean 'wrong'?
03:54:34 <Eduard_Munteanu> Perhaps you want 'round' instead of 'truncate'
03:56:20 <Eduard_Munteanu> Oh and you might need to use Double instead of Float.
03:57:40 <sg|> Eduard_Munteanu  when I round it it is just giving me the 1 decimal like if it is 2.3454 round gives me 2.3( jus one decimal)
03:57:52 <sg|> I need ike 2.34 with two decimal
03:58:18 * hackagebot JSON-Combinator 0.2.0 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.2.0 (TonyMorris)
04:14:02 <Eduard_Munteanu> > let myRounding x = (fromIntegral . truncate $ x * 100) / 100 in myRounding 2.3454
04:14:03 <lambdabot>   2.34
04:14:19 <Eduard_Munteanu> sg|: you probably did something wrong there.
04:17:32 <Eduard_Munteanu> > let myRounding x = (fromIntegral . round $ x * 100) / 100 in myRounding 2.3454
04:17:34 <lambdabot>   2.35
04:18:33 <Eduard_Munteanu> > let myRounding x = (fromIntegral . truncate $ x * 100) / 100 in myRounding 2.3454 :: Float
04:18:34 <lambdabot>   2.34
04:18:56 <Eduard_Munteanu> > let myRounding x = (fromIntegral . truncate $ x * 100) / 100 in myRounding (2.3454 :: Float) :: Float
04:18:58 <lambdabot>   2.34
04:19:13 <Eduard_Munteanu> So the problem's definitely on the other end.
05:04:21 <yitz> preflex: seen glguy
05:04:21 <preflex>  glguy was last seen on #haskell 17 days, 16 hours, 20 minutes and 36 seconds ago, saying: start thinking about GHC 7 when it is incorporated into the Haskell Platform release
05:09:45 <Bynbo7> http://www.classnamer.com/?repost!
05:33:02 <co_dh> ping
05:37:16 <Fuco> I assume ghc(i) can work with UTF-8 documents. Do I have to set it somewhere, or will it autodetect them? Right now, I'm getting "lexical error in string/character literal (UTF-8 decoding error)"
05:39:33 <mm_freak_> oh no
05:39:53 <mm_freak_> 'Data.Enumerator.Iteratee a m' is not a proper monad =/
05:40:38 <rtharper> ?
05:40:39 <rtharper> why not?
05:40:59 <mm_freak_> is john millikin in here?
05:41:11 <mm_freak_> because it doesn't adhere to the associativity law
05:41:22 <mm_freak_> (a >> b) >> c /= a >> (b >> c)
05:42:09 <mm_freak_> i noticed with this code: run_ (enumList 2 [0..10] $$ Data.Enumerator.head >> yield 0 (Chunks [0,1,2,3]) >> Data.Enumerator.List.consume)
05:42:51 <mm_freak_> adding parentheses changes the result
05:42:58 <copumpkin> he isn't here
05:42:59 <copumpkin> mailing list?
05:43:09 <mm_freak_> i don't have access to my mail client right now
05:43:37 <mm_freak_> well, i will send unsigned mail, but i don't like that
05:43:42 <copumpkin> lol
05:43:49 <saml> why lol?
05:43:56 <hpc> i tried subscribing to the mailing list, but there's so much volume
05:43:57 <copumpkin> heaven forbid that someone think it might not be you sending that bug report
05:44:00 <hpc> i can't read it all
05:44:25 <saml> maybe you need ipad with rss feed of mailing list with google wave
05:44:40 <hpc> saml: a quality stack of cruft!
05:44:42 <saml> what do you think about mailing list with points (upvote/downvote)
05:44:50 <copumpkin> I just filter it into a gmail list (skipping inbox) and check it periodically
05:44:52 <xiackok> is there any function for [Just 3, Just 5, Nothing, Just 4, Nothing] ===> [3,5,4] or [Just 3, Just 5, Just 4]
05:44:52 <saml> wanna start that startup with me?
05:44:54 <hpc> dunno; this is my first mailing list
05:45:00 <Fuco> rss - the new big ipad thing
05:45:00 <Botje> xiackok: catMaybe
05:45:06 <saml> yup
05:45:08 <copumpkin> catMaybes
05:45:09 <Botje> or catMaybes, i forgot
05:45:14 <saml> > catMaybe [Just 3, Nothing, Just 4]
05:45:16 <lambdabot>   Not in scope: `catMaybe'
05:45:18 <hpc> > catMaybes [Just 1, Nothing, Nothing, Just 4]
05:45:19 <lambdabot>   [1,4]
05:45:22 <copumpkin> [x | Just x <- xs]
05:45:24 <xiackok> ohh thanks
05:45:28 <saml> you're welcome
05:45:42 <hpc> catMaybes = map fromJust . filter isJust
05:45:47 <hpc> :t isJust
05:45:48 <lambdabot> forall a. Maybe a -> Bool
05:45:51 <saml> @src catMaybes
05:45:51 <lambdabot> catMaybes ls = [x | Just x <- ls]
05:45:57 <hpc> or that
05:45:58 <xiackok> hpc: i try yo find isJust :d
05:46:06 <faanbj> why cat?
05:46:10 <saml> @type [ | ]
05:46:11 <lambdabot> parse error on input `|'
05:46:15 <copumpkin> faanbj: meow
05:46:18 <hpc> faanbj: conCATenation
05:46:27 <hpc> or hysterical raisins; whichever
05:47:07 <saml> is there a language where users can override lexical token?
05:47:24 <hpc> um
05:47:27 <hpc> lisp?
05:47:27 <saml> so that it's easy to create dsl
05:47:35 <hpc> C?
05:47:46 <kosmikus> TeX?
05:47:47 <saml> i wanna parse <234>   as something other than 234, for example
05:48:02 <saml> 234 :: Int ...  <234> :: MyInt
05:48:24 <hpc> Haskell is pretty good at dsls, but it can't look like that :(
05:48:24 <quicksilver> you can in haskell if you don't mind the noise of starting/stopping a quasiquoter
05:48:30 <smoge> it there a text editor written in haskell?
05:48:30 <saml> or maybe have custom block at least..   {myblock%      ....   %myblock}
05:48:34 <hpc> bleh, qq
05:48:35 <quicksilver> [|qq$ .... ]
05:48:36 <saml> smoge, yi
05:48:49 <quicksilver> saml: yes, you can do that with quasiquotes
05:49:00 <smoge> yi is activelly developed?
05:49:03 <saml> quicksilver, is it standard? or do i need to cabal install something?
05:49:10 <quicksilver> it's standard.
05:49:20 <quicksilver> it's a GHC extension but it's part of GHC, that is.
05:49:30 <saml> oh wow
05:49:38 <quicksilver> http://www.haskell.org/haskellwiki/Quasiquotation
05:49:49 <saml> yup
05:50:43 <saml> why is my job not use haskell but java
05:51:23 <hpc> it's Enterprise!
05:51:34 <hpc> Spock would be proud of your loyalty to the coffee bean!
05:58:46 <smoge> how the best wait to install yi on archlinux?
05:59:55 <pozic> smoge: either find a package, or just do cabal install yi
05:59:59 <saml> smoge, isn't there aur?
06:00:15 <saml> smoge, why do u need yi?
06:00:36 <saml> using haskell text editor does not make you a smarter
06:01:14 <pozic> It just shows that nobody can build a useful application in Haskell yet again ;)
06:01:17 * pozic ducks
06:01:20 <hpc> haha
06:02:04 <hpc> pozic: one doesn't succeeed on linux by being good, but by being so old that there is no possible way to improve
06:02:09 * hpc ducks
06:02:40 <pozic> hpc: except I don't really get that one. 
06:02:41 <Fuco> I have a nice operating system, it's called emacs
06:03:05 <hpc> pozic: it's why every linux uses X, vim, etc
06:03:14 <hpc> despite being decades old
06:03:37 <pozic> hpc: X is undergoing huge changes right now. 
06:03:42 * hpc doesn't seriously think that, just making a stupid generalization :P
06:03:46 <pozic> hpc: regarding vim, yes :)
06:04:03 <theorbtwo> emacs isn't all that much younger.
06:04:09 <pozic> I don't think there is one good IDE on Linux to do C/C++ development. 
06:04:13 <saml> hey, is there algebra for api design?
06:04:32 <saml> like.. i want to know that my api is complete and closed.. 
06:06:31 <rostayob> pozic: emacs and cedet
06:08:11 <rostayob> it's a matter of taste anyway. For example, I don't think there is one "IDE" which is worth using (:
06:08:39 <smoge> pozic: kdevelop? qt creator?
06:09:04 <smoge> I just want to try it out
06:09:09 <smoge> I'm a emacs user btw
06:09:41 <pozic> smoge: qt creator has some indexing bugs, but otherwise is indeed the best. 
06:10:02 <pozic> smoge: kdevelop doesn't do indexing of symbols and is therefor not an IDE.
06:10:22 <rostayob> pozic: have you tried emacs and cedet?
06:10:42 <pozic> "But..but you can use tags" -- a stupid Linux user that doesn't understand the concept of correct results.
06:10:47 <pozic> rostayob: yes, and it is all crap. 
06:11:00 <rostayob> pozic: what is crappy about it?
06:11:14 <smoge> pozic: why did ask why I bother trying yi?
06:11:16 <pozic> rostayob: I didn't get all modules to work last time, and setup time is too long.
06:11:21 <smoge> did you try? not so good yet?
06:11:23 <pozic> smoge: I didn't.
06:11:27 <rostayob> pozic: so you didn't try it
06:11:39 <pozic> rostayob: I did try it, and it doesn't do what I want. 
06:11:53 <smoge> sorry that was saml
06:12:01 <rostayob> pozic: yeah so what is your looking for that ceded doesn't do?
06:12:08 <smoge> "using haskell text editor does not make you a smarter" (saml)
06:12:16 <rostayob> *cedet
06:12:31 <smoge> haskell in emacs is quite good
06:12:38 <pozic> rostayob: press one button and jump to the location of where that symbol is defined. 
06:12:46 <rostayob> pozic: it does that
06:12:52 <smoge> with speedbar and cedet, and ahg/git is pretty good
06:12:52 <pozic> rostayob: without running an indexer myself every X minutes. 
06:13:03 <smoge> also yasnipett
06:13:16 <rostayob> pozic: I'm quite sure that it can do that (the automatic indexing thing)
06:13:27 <pozic> rostayob: it should keep track of the files I am editing too.
06:13:34 <pozic> rostayob: and I am pretty sure that it didn't.
06:13:45 <pozic> rostayob: there is one commercial product which does it for C, btw.
06:13:57 <rostayob> pozic: that is called cscope, and it's not commercial
06:14:02 <pozic> I forgot its name, but e.g. Google has a license on it and it also works for C++.
06:14:05 <pozic> rostayob: no
06:14:14 <rostayob> well cscope does exactly that
06:14:15 <pozic> rostayob: something which is integrated in Emacs. 
06:14:22 <rostayob> pozic: cscope is integrated with emacs
06:14:28 <pozic> rostayob: so?
06:14:40 <rostayob> pozic: it does exactly what you describe
06:14:47 <pozic> rostayob: I am telling you it was not cscope.
06:14:59 <smoge> so.... yi do not worth trying?
06:15:00 <rostayob> pozic: yes but I'm saying that cscope does that :P
06:15:09 <pozic> rostayob: and cscope doesn't do that.
06:15:20 <pozic> rostayob: cscope does no automatic indexing.
06:15:25 <rostayob> pozic: it does
06:15:44 <rostayob> pozic: http://www.emacswiki.org/emacs/CScopeAndEmacs
06:16:00 <rostayob> pozic: "By default, xcscope.el does automatic indexing by use of a Bash script (cscope-indexer)."
06:16:12 <confound> smoge: what do you lose if you try it?
06:16:19 <pozic> rostayob: well, whatever, show me a youtube video of any working released piece of free software.
06:16:51 <rostayob> pozic: I always use cscope on C projects, and I can assure you it does that.
06:17:03 <pozic> rostayob: and I was asking about C++.
06:17:24 <pozic> rostayob: the commercial tool I was talking about is free for C, but also is not bug free.
06:17:30 <pozic> The bug free part is the hard part, I suppose.
06:18:41 <rostayob> pozic: apart from the fact that you can use cscope for c++, I'm pretty sure that you can do that with cedet. Anyway, if you're happy with other tools...
06:19:32 <b52> is there a short function for concat . repeat
06:19:35 <b52> ?
06:19:42 <pozic> rostayob: I am not happy with other tools. I say that I tried cscope and I observed that it didn't work. If the whole world says "product X works" and product X does not work, why would I continue to believe them? 
06:19:51 <Bynbo7> b52: cycle?
06:20:02 <Bynbo7> > cycle "hello "
06:20:02 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
06:20:10 <b52> Bynbo7: ah nais thanks
06:20:31 <Bynbo7> @src cycle
06:20:31 <lambdabot> cycle [] = undefined
06:20:31 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
06:21:00 <pozic> rostayob: the cscope indexer has to run on the whole source tree. 
06:21:02 <copumpkin> w00t
06:21:06 <copumpkin> x86_64 GHC released
06:21:09 <copumpkin> for mac os
06:21:18 <pozic> rostayob: there is no intelligence applied to reduce the amount of stuff it is going to reindex.
06:21:19 <Bynbo7> official?
06:21:22 <copumpkin> Bynbo7: yeah
06:21:26 <copumpkin> http://www.haskell.org/ghc/download_ghc_7_0_2
06:21:28 <Bynbo7> excellent
06:21:29 <pozic> rostayob: so, all you get is a slower machine for just a small benefit.
06:22:09 <Bynbo7> copumpkin: i just got a new MacBook Pro :D
06:22:14 <copumpkin> nice :)
06:22:20 <smoge> damn!
06:22:26 <Bynbo7> 8 (well 4) cores of goodness
06:22:31 <smoge> I installed yi from a arch repo
06:22:39 <Bynbo7> and should have 8GB RAM quite soon
06:22:42 <pozic> Bynbo7: personal or work?
06:22:43 <copumpkin> cool :)
06:22:49 <smoge> but it did not come with the gtk frontend
06:22:53 <copumpkin> do the new ones support more than 8GB at all?
06:22:57 <Bynbo7> pozic: it's all mine!
06:23:05 <Bynbo7> copumpkin: no :\
06:23:07 <copumpkin> Bynbo7: smeagol, is that you?
06:23:21 <smoge> it has one, right?
06:23:29 <Bynbo7> well, not officially anyway. but i doubt anyone makes 8GB sticks in that size (yet)
06:24:37 <rostayob> pozic: here I am again. cscope is fast enough for me, but again, it depends on what you do.
06:25:48 <rostayob> the stuff I've worked on has always been in the order of thousands of files
06:26:10 <rostayob> for example I would be *a lot* slower without emacs, I'm too used to the editor.
06:27:01 <pozic> qtcreator without bugs in a multi-threaded version of Emacs would be good for me. 
06:27:02 * hackagebot Cabal 1.10.1.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.10.1.0 (DuncanCoutts)
06:27:04 * hackagebot cabal-install 0.10.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-0.10.0 (DuncanCoutts)
06:27:11 <dcoutts_> @yarr!
06:27:11 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
06:28:07 <rostayob> pozic: and I'm not an expert on ide... again, I don't really like them
06:28:29 <smoge> Where do I find functions for gaussian, beat and this kind of probabilities/distributions?
06:28:33 <smoge> beta*
06:28:39 <smoge> random?
06:29:05 <saml> not sure if there's library in hackage
06:29:37 <smoge> damn
06:29:50 <smoge> no scipy for haskell?
06:30:26 <Bynbo7> not at the moment
06:30:34 <saml> use R
06:31:48 <Bynbo7> or sage
06:33:03 * hackagebot base 4.3.1.0 - Basic libraries  http://hackage.haskell.org/package/base-4.3.1.0 (IanLynagh)
06:33:05 * hackagebot bytestring 0.9.1.10 - Fast, packed, strict and lazy byte arrays with a list interface  http://hackage.haskell.org/package/bytestring-0.9.1.10 (IanLynagh)
06:34:03 * hackagebot haskell98 1.1.0.1 - Compatibility with Haskell 98  http://hackage.haskell.org/package/haskell98-1.1.0.1 (IanLynagh)
06:39:04 * hackagebot process 1.0.1.5 - Process libraries  http://hackage.haskell.org/package/process-1.0.1.5 (IanLynagh)
06:40:04 * hackagebot unix 2.4.2.0 - POSIX functionality  http://hackage.haskell.org/package/unix-2.4.2.0 (IanLynagh)
06:41:17 <harlekin> @pl (\(i, e) -> fmap ((,) i) e)
06:41:17 <lambdabot> uncurry (fmap . (,))
06:41:37 <Guest38896> Doesn anyone know Scala? What would be scala version of this? data Frank a b  = Frank {frankField :: b a} deriving (Show)
06:44:14 <c_wraith> Does Ian uploading all these packages mean 7.0.2 is coming out?
06:45:14 <quicksilver> yes.
06:45:17 <doserj> c_wraith: he announced it on the mailing list
06:45:26 <c_wraith> ah, I should read my mail :)
06:45:50 <saml> class Frank<A,B> { public Frank(Function b, Object a} {  b.call(a); } }
06:46:04 <saml> and @Override String toString() { }
06:49:30 <illissius`> pozic: when did you last try kdevelop? 2 years ago?
06:49:50 <illissius`> it does semantic highlighting, jump to definition/declaration, rename symbol, etc. for C++
06:54:45 <pozic> illissius`: KDevelop: 4.1.2 ok?
06:55:27 <illissius`> pozic: yeah
06:55:44 <illissius`> pozic: though if that doesn't have what you want then I'm not sure what you're looking for?
06:56:03 <pozic> illissius`: I am trying it on vlc now.
06:56:08 * hackagebot sequential-index 0.2 - Sequential numbers that allow arbitrarily inserting numbers - for containers  http://hackage.haskell.org/package/sequential-index-0.2 (AristidBreitkreuz)
06:56:53 <pozic> illissius`: I cannot browse the source until the indexing is incomplete.
06:57:01 <pozic> illissius`: that's already one weakness.
06:58:11 <illissius`> pozic: well, yeah. you can still look at things they just won't be highlighted/have semantic information. it takes a minute or two to analyze a project when you first load it, after that it's not too bad
06:59:25 <harlekin> @pl (\(x,y,z) -> f x y z)
06:59:25 <lambdabot> (line 1, column 7):
06:59:25 <lambdabot> unexpected ","
06:59:25 <lambdabot> expecting letter or digit, operator or ")"
06:59:25 <lambdabot> ambiguous use of a non associative operator
06:59:39 <harlekin> @pl (\(x, y, z) -> f x y z)
06:59:39 <lambdabot> (line 1, column 8):
06:59:39 <lambdabot> unexpected ","
06:59:40 <lambdabot> expecting letter or digit, operator or ")"
06:59:40 <lambdabot> ambiguous use of a non associative operator
06:59:57 <basvandijk> Hello, I'm writing a unix daemon (using hdaemonize). When I start it with +RTS -N2 it gives the following error: "forking not supported with +RTS -N<n> greater than 1". Anybody know why forking is not supported with -N2?
07:00:58 <harlekin> Maybe the GHC runtime loses information if there are two threads which fork GHC threads which is crucial to handling threads internally? But I'm just guessing.
07:00:59 <pozic> illissius`: I am on a aout_instance_t and I tried Control-. and Control-,, but no response. 
07:01:18 <harlekin> *two OS threads
07:01:19 <pozic> illissius`: I just want to see where that type is defined. 
07:01:43 <basvandijk> harlekin: Ok that makes sense
07:01:50 <illissius`> pozic: if you hover over it you should get a tooltip with links to the definition and declaration
07:02:28 <pozic> illissius`: that doesn't happen.
07:03:03 <pozic> illissius`: If I hover over a variable I do see all its occurrences.
07:03:16 <pozic> illissius`: but I do not see where the type is defined, which is what I was interested in.
07:04:18 <pozic> illissius`: in some Problems tab it says that certain declarations have not been found, so perhaps it is the correct response.
07:04:32 <pozic> illissius`: I will see whether I can fix that. It sure looks better than it did, but I am not cheering yet.
07:04:56 <illissius`> pozic: possibly
07:05:45 <illissius`> I am not a kdevelop developer, nor am I particularly invested in having you like it :), I just happen to use it and think it's pretty good (better than qt creator, anyway).
07:05:55 <pozic> illissius`: it even warns me that some header file cannot be found when I hover over it and suggests a path. 
07:07:21 <illissius`> (fwiw, I don't really use any of the "IDE" features, just the semantic highlighting/linking/etc., and otherwise use the built-in konsole to compile/run things and such)
07:08:10 * hackagebot data-category 0.4 - Restricted categories  http://hackage.haskell.org/package/data-category-0.4 (SjoerdVisscher)
07:08:35 <pozic> illissius`: refactoring can be nice, but how often does one want to rename variables; pick a name right the first time ;)
07:08:56 <c_wraith> pozic: I often want to rename functions when I change what they do. :)
07:09:25 <illissius`> yeah renaming variables is nice sometimes
07:09:41 <illissius`> I ignore the project-management stuff beyond loading one so it'll find the headers and such
07:10:21 <pozic> illissius`: my usage pattern is the same with other IDEs in languages where the IDE does work. 
07:10:27 <b52> i got a list of numbers and would like to create a list of list with subsets of this numbers each where each sublist must have a sum below a specific treshold, what would be a good way to achieve that?
07:10:30 <pozic> illissius`: with some luck I can add C++ to the list now too :)
07:11:02 <illissius`> pozic: would be nice :) did you manage to get it to find the header / show a tooltip?
07:11:13 <pozic> illissius`: not automatically.
07:11:31 <b52> e.g. treshold 3: [1,3,2,2,1,1,2,3] => [[1], [3], [2], [2, 1], [1, 2], [3]]
07:11:39 <pozic> illissius`: #include <vlc_aout.h>
07:11:58 <pozic> illissius`: it should figure out what the search path is that the build system gets.
07:12:14 <pozic> illissius`: features like that are the difference between a product and a toy.
07:13:51 <Bynbo7> b52: well, i showed you a function yesterday that woulld find those lists, now you just need to repeatedly apply it
07:14:08 <pozic> illissius`: perhaps it is a bug in vlc.
07:14:28 <illissius`> pozic: what's the build system? afaik it should work with Makefiles and CMakeLists.txt
07:14:47 <illissius`> anyway, there's a #kdevelop, they're friendly and helpful in my experience
07:16:09 <pozic> illissius`: it seems they use automake.
07:16:32 <illissius`> it's been a while since I used that
07:17:10 <illissius`> pozic: can't remember how you do it, but get it to generate a Makefile and then load that (open project for current file -> find the Makefile), if you haven't already
07:17:18 <pozic> illissius`: I think the bug lies with VLC. They should not write files which depend on <foo> lookup.
07:17:32 <illissius`> pozic: or you just need to install the headers maybe
07:17:39 <pozic> illissius`: I have the headers installed.
07:17:48 <illissius`> oh. then presumably it should find them
07:18:23 <pozic> illissius`: probably the build system adds some search directories, such that it works in that case.
07:18:31 <pozic> illissius`: bad practice, imho.
07:18:46 <pozic> You tie your code in that case to one build system. 
07:19:07 <b52> Bynbo7: yeah, but thats not so easy to me
07:20:01 <illissius`> anyway, I've had to fiddle with this part of things before (build system / include dirs), it's possible you might have to as well, all I really care about is that I got it to work without too much trouble and that after that, it works. (and don't really care if it's considered a "product" or a "toy", it works for me :)
07:22:02 <sjoerd_visscher> I'm having trouble installing network-2.3.0.2 with ghc 7.0.2
07:22:10 <Bynbo7> me too
07:22:12 <sjoerd_visscher> Socket.hsc:1848: error: ‘AI_NUMERICSERV’ undeclared
07:22:28 <Bynbo7> hmm, different problem for me
07:22:44 <sjoerd_visscher> while it says earlier: checking whether AI_NUMERICSERV is declared... yes
07:22:48 <Saizan> have you installed the new cabal-install ?
07:23:10 <sjoerd_visscher> it's a dependency of the new cabal-install
07:23:53 <pozic> illissius`: I added the path and that also doesn't work.
07:23:56 <Saizan> heh, i think you've to install it with the Setup script then
07:24:27 <Saizan> (or you could build the new cabal-install with an older ghc, maybe)
07:26:00 <illissius`> pozic: ask in #kdevelop if sufficient quantities of care are present... otherwise, oh well.
07:26:20 <pozic> illissius`: I already did. 
07:26:31 <illissius`> ok then
07:26:43 <illissius`> (I'm not in there myself atm)
07:26:55 <pozic> illissius`: but it just shows that nothing works out of the box, but perhaps VLC should be blamed in this case. 
07:27:05 <pozic> Most of the VLC code is pretty good. 
07:27:33 <sjoerd_visscher> haddock doesn't compile either, but I could work around that by changing src/Haddock/Interface/Create.hs
07:27:56 <sjoerd_visscher> line 282 becomes: mkDecls (concat . hs_tyclds)  TyClD    group_ ++
07:52:44 <tolkad> Yay ghc 7.0.2 was released? does that mean this 7.0.2 milestone bug has been fixed? http://hackage.haskell.org/trac/ghc/ticket/2715
07:54:18 <Saizan> tolkad: still open, so i'd guess no
07:58:47 <pozic> illissius`: ok, so basically there is a bug in KDevelop, which is exactly consistent with my statement that all IDEs on Linux are crap.
07:59:12 <illissius`> okay.
07:59:27 <pozic> illissius`: but they are getting closer. 
07:59:46 <harlekin> Is there a problem of sending huge data via hPutStrLn? It seems as if a 48x48x48 array is sent but not received by the client.
08:00:09 <harlekin> Ah, nevermind. It just takes really, really long. O:
08:00:37 <pozic> harlekin: about a second?
08:00:46 <Saizan> hFlush might be your friend
08:01:26 <harlekin> pozic, more like a minute.
08:01:29 <mapreduce> pozic: All IDEs regardless of programming language?
08:01:30 <harlekin> Saizan, I'm already using it.
08:01:30 <quicksilver> > 48*48*48
08:01:31 <lambdabot>   110592
08:02:08 <quicksilver> bytestring hPut might well be faster. Depends how you generate that array and how you serialise it.
08:02:40 <harlekin> quicksilver, yeah. I just want it to work right now. Later I want to use proper serialisation.
08:04:15 <Eduard_Munteanu> FOSS coders tend not to use any IDEs.
08:10:34 <rostayob> pozic: again with the IDEs? ehe
08:26:32 * hackagebot JSON-Combinator 0.2.1 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.2.1 (TonyMorris)
08:41:42 <frank00> I've almost finished "Learn you a haskell for a greater good!"
08:41:52 <Zao> Hooray!
08:41:57 <frank00> \o/
08:42:33 <fmapE> frank00: What do you have left?
08:43:26 <frank00> fmapE: last chapter on "Zippers". But monads are over!
08:43:34 <fmapE> cool
08:43:42 <fmapE> if you figure out zippers let me know
08:43:51 <fmapE> I use monad and arrow transformers all day long
08:43:57 <fmapE> but for some reason zippers elude me
08:44:22 <fmapE> I actually tried going through his chapter and it still didn't help much
08:46:11 <fmapE> I'd actually love to see a chapter in the book on arrows
08:46:32 <aristid> afaik arrows are out of fashion.
08:46:44 <hpc> arrows are kinda dumb, but Categories are cool
08:46:59 <c_wraith> fmapE: Zipper are nothing special.  If you get the concept of a list zipper, you're about 75% of the way there.
08:47:10 <hpc> all can tell arrows are useful for are playing with tuples
08:47:31 <aristid> hpc: that's why i import Control.Arrow in 100% of cases
08:47:47 <hpc> uncurry f <<< x &&& y <<< z
08:47:50 <fmapE> hpc: Arrows are useful for specifying static information about functions
08:47:53 <fmapE> among other things
08:48:03 <fmapE> functions are a trivial instance of Arrow
08:48:08 <fmapE> but there's others
08:48:11 <c_wraith> fmapE: Arrows would be *so* much better without arr
08:48:23 <fmapE> c_wraith: Why's that?
08:48:28 <c_wraith> fmapE: arr means that you can't prevent your arrow instance from doing arbitrary things
08:48:50 <fmapE> true
08:49:58 <quicksilver> c_wraith: Arrows without arr are called Category, right?
08:49:59 <c_wraith> Of course, that's why the GArrow thing is in that experimental extension I was looking at last night.
08:50:01 <ezyang> Bleah, I still don't understand finger trees. 
08:50:02 <frank00_> sorry my connection failed (as usual)
08:50:17 <aristid> ezyang: shame on you.
08:50:24 <ezyang> >_< 
08:50:38 <monochrom> arrow users are arr mateys
08:50:38 <c_wraith> quicksilver: no, Arrows would still have first and second.  Category is just id and >>>
08:50:46 <BMeph> What don't you get, EZ? Why they're useful
08:50:58 <quicksilver> first and second are a bit meh ;)
08:51:06 <fmapE> c_wraith so would you be happy with Arrow being id, first, and >>>
08:51:19 * zygoloid has fallen in love with fingertrees /so hard/
08:51:25 <c_wraith> fmmapE: still need second, but yes.
08:51:26 <xplat> finger trees are kind of similar to trees with zippers
08:51:29 <fmapE> and ArrowLift being Arrow a => ArrowLift a and defining arr?
08:51:50 <fmapE> c_wraith: minimal complete def of Arrow is Category, and then arr, >>> and first
08:52:09 <fmapE> second is easily derivable from first
08:52:11 <edwardk> arrow makes me sad
08:52:15 <fmapE> but you can override it
08:52:18 <c_wraith> fmapE: hmm.  Didn't realize you could define second in terms of first
08:52:20 <xplat> first and >>> is not sufficient for arrows without arr
08:52:27 <ezyang> My trouble is I can't see the big picture with multiple fingers. 
08:52:35 <BMeph> fmapE: Redundant - >>> is derived from .
08:52:45 <fmapE> BMeph: o true
08:52:48 <ezyang> Handling one finger is OK (that's a zipper), but when you have multiple ones it just seems to get... complicated. 
08:53:04 <edwardk> ezyang: thats why we only have 2 in a hinze-patterson fingertree
08:53:08 <BMeph> fmapE: Sorry, rather: '>>>' is derived from '.' I mean.
08:53:13 <fmapE> yes
08:53:14 <edwardk> ezyang: and they are fixed to be the leftmost and rightmost entry in the tree
08:53:16 <ezyang> Ah. 
08:53:25 <ezyang> I see, that does make things simpler :-) 
08:53:39 <edwardk> ezyang: 'traditional' imperative fingertrees used to admit any number of fingers
08:53:56 <edwardk> but those don't implement nicely in a functional framework
08:54:13 <aristid> i wrote a non-Category (<<<) for ReaderT (and Reader and (->) and mtl stacks building on ReaderT)
08:54:29 <edwardk> H&P provided much the same asymptotics as a traditional fingertree by restricting to 2 fingers and saying that if you want any more, you can sttich together a bunch of 2 fingertrees to get it!
08:54:33 <BMeph> edwardk: So, a B-tree is a variadic fingertree? ;)
08:55:16 <edwardk> bmeph: depends, most b-trees don't have the notion of updating fingers
08:55:17 <xplat> well you can also imagine the hinze-patterson fingertree as the derivative (zipper with a 'hole' rather than an actual element in focus) of a cyclic tree
08:55:42 <edwardk> or any of the fast grafting machinery
08:55:52 <edwardk> xplat: cute
08:56:46 <xplat> edwardk: yeah, then there's really only one finger, it just looks like two
08:57:06 <fmapE> c_wraith: what sort of arrows were you wanting where you don't want arbitrary behavior?
08:58:46 <c_wraith> fmapE: using Arrows as a limited composition pattern to for embedded DSLs that I don't want to have full monadic generality.  And then being able to rely on that limited composition when running it.
08:59:10 <c_wraith> fmapE: especially if I want to limit the set of combinators
08:59:17 <c_wraith> fmapE: That latter part is what arr prevents
08:59:27 <fmapE> c_wraith: I see
09:00:24 <fmapE> c_wraith: I learned arrows as part of my interest in functional reactive programming, where arr generally makes perfect sense
09:00:36 <rostayob> stepkut: yeah I read those, so basically right now there is no way of doing that efficiently
09:00:36 <rostayob> ooops sorry wrong chan
09:00:56 <fmapE> oh
09:00:56 <zygoloid> trouble is, if you don't have 'arr' then you need a much bigger set of rewiring combinators
09:01:00 <fmapE> I should correct an earlier statement
09:01:08 <fmapE> you can derive second from first if you do have arr
09:01:40 <fmapE> because the derivation looks like arr swap >>> first f
09:01:47 <fmapE> (or some such)
09:01:52 <c_wraith> ah, right.
09:02:08 <xplat> yes, without arr you need to define at least second and (&&&)
09:02:09 <zygoloid> yeah. and the 'proc' desugaring uses 'arr' too, for things like \((a,b),c) -> (a,(b,c)) ;(
09:02:32 <fmapE> zygoloid: I don't like the proc notation actually
09:03:00 <fmapE> I usually just write my arrow expressions point-free-ish
09:03:04 <xplat> maybe (***) too?  or i guess (***) and diag would work, no (&&&)
09:03:06 <zygoloid> nonetheless, the Arrow combinators without arr aren't enough for general rewiring
09:03:19 <fmapE> true
09:03:33 <zygoloid> i'd be interested in seeing what a minimal set (without arr) would look like
09:04:08 <xplat> probably >>>, first, ***, swap, diag would do it
09:04:52 <xplat> maybe you'd also need rotl and rotr
09:05:09 <fmapE> xplat: what's diag?
09:05:20 <zygoloid> xplat: you can't even do \(a,b) -> a with that, can you?
09:05:29 <xplat> diag = (id &&& id)
09:05:44 <fmapE> ah k
09:06:19 <xplat> zygoloid: hm.  you should be able to do anything that only gets wider, though
09:06:36 <zygoloid> yeah. i think that set (including rotl and rotr) plus discard might be enough
09:06:55 <fmapE> so the general point seems to be that arr is neccessary for more than is immediately obvious
09:07:06 <zygoloid> that seems like it gives you a kinda pairy ziplist which you can arbitrarily duplicate and reorder
09:07:09 <xplat> ... you could say that, yeah
09:07:30 <zygoloid> ... but the full generality of arr is too general
09:10:23 <c_wraith> Maybe this is why the GArrow class I was looking at last night had all those extra functions
09:10:23 <c_wraith> http://www.cs.berkeley.edu/~megacz/garrows/
09:11:59 <roconnor> @tell conal ``The use of anthropomorphic terminology forces you linguistically to adopt an operational view. And it makes it practically impossible to argue about programs independently of their being executed.'' -- Dijkstra
09:11:59 <lambdabot> Consider it noted.
09:16:58 <xplat> i guess only one of (+++) and first is needed too
09:17:04 <xplat> er (***)
09:18:12 <xplat> f (***) g = first f >>> swap >>> first g >>> swap; first f = f (***) id
09:20:59 <xplat> i think defining (***) would allow the library writer a little more leeway as to how effect ordering is handled
09:21:25 <frank00> http://prog21.dadgum.com/23.html <-- has anyone read this? Do you think it is sound?
09:21:53 <saml> it is game
09:22:26 <frank00> ahah
09:23:25 <saml> purely functional language are executed during compilation type checking
09:25:25 <fmapE> frank00: You really should take a look at FRP
09:25:35 <fmapE> there's a paper, "the yampa arcade"
09:25:46 <frank00> I will google it, fmapE 
09:26:24 <fmapE> it's a good introduction to arrow-based FRP, as well as showing an implementation of 'space invaders' using FRP
09:27:48 <sm> frank00: I read it.. it doesn't say a much that's questionable does it ?
09:29:47 <saml> you can describe io in different ways
09:29:53 <saml> monad is one way
09:30:14 <saml> pi calculus is another
09:30:14 <frank00> sm: I am learning haskell and find that many times my minds thinks OO, so I want to get examples of good code to learn from
09:30:26 <saml> frank00, u wanna write games?
09:30:40 <saml> start with data
09:30:53 <saml> and transformations of data
09:31:51 <frank00> saml: I'd like to make many things with Haskell (yes, some game too, namely ineractive fiction). But I want it to make it nicely, especially making reusable code. When I use C
09:32:16 <frank00> *C++ I immediately know that some things belings to classes, some others to namespaces some others to abstract classes and so on
09:32:18 <saml> frank00, so... interactive fiction..
09:32:29 <frank00> I'm much more frightened in haskell, being a newborn here
09:32:30 <saml> how would you model the game?
09:32:37 <saml> don't think about ui
09:32:51 <saml> you need Page
09:32:57 <saml> and Text inside a Page
09:33:17 <saml> and Link in the Text to another Page
09:38:32 <sm> you can see one small example by doing cabal unpack Advgame
09:39:07 <frank00> if I were using C++, I'd make rooms and objects/characters in it. Being in haskell, I am not sure yet :P I would prolly use lists  to represent (rooms / things_in_rooms / agents) and for NPCs action some (condition, action) tuple to define their behaviour. But that seems messy!
09:39:07 <frank00> And less than reusable
09:39:42 <n00p> Sort of like that "alone in the dark" game, I guess?
09:39:45 <n00p> ... resident evil also comes to mind
09:39:54 <kmc> frank00, you can store behaviors by storing functions
09:40:36 <kmc> frank00, i would guess a list is not a great data structure for a room, as you'll want to find stuff efficiently by its location in the room
09:40:45 <kmc> but a list would be fine to start prototyping with
09:40:49 <frank00> n00p: interactive fiction is an adventure, yes, but text driven
09:41:01 <sm> frank00: you don't have to model everything with lists and tuples - you can define your own "structures" (abstract data types)
09:41:20 <frank00> mhh thanks for the tip kmc
09:41:45 <kmc> sm, they don't have to be abstract even
09:42:02 <kmc> frank00, how much Haskell do you know?
09:42:25 <sm> thanks.. your own data types, then. I'm still hazy on DT/ADT/GADT 
09:42:27 <frank00> kmc: reached monads in learnyourwaytohaskell and enjoyed them, so beginner I say
09:42:36 <AdaHopper> Hi!
09:43:01 <kmc> sm, the problem is that the 'A' in ADT can stand for "algebraic" or "abstract" with totally different meaning
09:43:07 <kmc> stupid acronyms
09:43:09 <sm> yes, that is confusing
09:43:16 <AdaHopper> I'm having problems with MacOSRoman coding
09:43:33 <kmc> abstract means that you define the type inside a module, and then you don't export its constructors
09:43:41 <roconnor> an algebraic data type is practically the opposite of an abstract data type. :D
09:43:46 <kmc> this forces the user to go through the API you define, and hides implementation details
09:43:48 <AdaHopper> anyone knows how could I convert macosroman in utf8
09:43:59 <AdaHopper> sorry for interrupting
09:44:00 <kmc> AdaHopper, probably with the "iconv" command line tool
09:44:08 <kmc> or do you mean in Haskell code?
09:44:22 <AdaHopper> reading a file in haskell
09:44:25 <kmc> Haskell has iconv bindings iirc
09:44:45 <AdaHopper> i can't read accents in my mac
09:44:48 <frank00> sm: thanks you too. The thing I find difficult is to think without interfaces. let me make a stupid example. Let's say we have a 2D platform: I would immediately think of making an abstract class with two methods, do logic and draw yourself (or get frame). That allows me to be quite flexible in the implementation. Now, *I know* that I must reason differently in Haskell: functions seems much...
09:44:49 <frank00> ...more powerful and "abstracting" them is probably the way to go. I am searching for good example code to find the Kearma ;)
09:44:52 <kmc> http://hackage.haskell.org/package/iconv
09:44:59 <AdaHopper> thanks kmc
09:45:03 <kmc> that should handle every weird encoding, while other packages tend to stick to UTF-n
09:46:12 <sm> you can define interfaces with typeclasses, if you want
09:46:54 <harlekin> @pl (join . fmap)
09:46:57 <lambdabot> join . fmap
09:49:05 <monochrom> http://spikedmath.com/393.html probably holds for many of you
09:49:32 <saml> i don't get it
09:49:37 <saml> i don't get academic papers
09:49:40 <saml> where do i start?
09:49:50 <copumpkin> you read the abstract
09:49:52 <monochrom> start at section 2
09:49:52 <copumpkin> then think a moment
09:49:59 <copumpkin> and wonder if it's worth your time to read the rest
09:50:08 <copumpkin> you evaluate what the abstract contained, and reach a conclusion
09:50:15 <copumpkin> then if you decided it was interesting to you
09:50:15 <roconnor> monochrom is right.  Introductions are boring.
09:50:16 <dolio> My hair doesn't look anything like that.
09:50:31 <saml> your neck is so narrow
09:50:34 <copumpkin> dolio?
09:50:37 <saml> you narrow neck
09:50:37 <copumpkin> oh
09:50:49 <copumpkin> yeah, I guess mine doesn't look like that either
09:50:54 <copumpkin> but I can identify with the rest of it
09:50:54 <saml> what's *CLICK* ?
09:51:05 <copumpkin> saml: when you understand somethign
09:51:08 <monochrom> the "introduction" section is for peer scholars only.
09:51:27 <saml> so monochrom and copumpkin are saying different things
09:51:31 <yrlnry> The introduction section is where the author tries to prove that the paper is actually interesting.
09:51:35 <saml> one must be fake ph.d
09:51:40 <sm> frank00: you may also find #haskell-game interesting
09:51:41 <dolio> Introductions are useful sometimes.
09:51:43 <tawe> Question. I have a definition: 'data GTree a = Leaf a | Gnode [GTree a]', and the question is: 'How is the completely empty tree represented as GTree?' . My guess is 'There isn't a way to represent the empty tree', but this response doesn't match with a 'How' question :)
09:51:48 <copumpkin> yrlnry: and gets as close to lying as possible without actually doing so
09:51:50 <dolio> They tell you the 12 other papers you should be reading.
09:51:57 <copumpkin> dolio: that or related work
09:52:05 <frank00> thanks sm
09:52:07 <copumpkin> related work is useful if you're getting started
09:52:08 <saml> tawe, Gnode[] ?
09:52:15 <saml> or Maybe GTree
09:52:18 <saml> then Nothing
09:52:25 <yrlnry> There have been some papers I have read that were worth reading solely because of all the interesting work by other people that they put me on the trail of.
09:52:54 <copumpkin> yeah
09:52:55 <yrlnry> "Well, this was boring and stupid, but that other thing sounds pretty interesting."
09:52:59 <tawe> saml, oh, Gnode [] seems perfect. :)
09:53:14 <yrlnry> tawe:  Do you feel silly now?  There were not a lot of choices/
09:53:20 <Der_Dackel> I can't run ghci (probably ghc too) on OSX 10.6 because of a linking failure with libiconv - no MacPorts involved. Error: http://hpaste.org/44492/ghci_errors
09:53:29 <saml> i would always expect GTree to have a root node
09:53:42 * hackagebot yesod-newsfeed 0.0.0.1 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-0.0.0.1 (PatrickBrisbin)
09:53:43 <yrlnry> It had to have the form (Leaf _) or (GNode _), and (Leaf _) obviously wasn't going to do it...
09:54:01 <tawe> yrlnry, I'm silly.
09:54:13 <saml> how can a tree be empty? then it's not a tree
09:54:22 <saml> tree needs root node
09:54:23 <yrlnry> Yes, it is an empty try.
09:54:36 <yrlnry> No a tree is a directed acyclic graph.  When the graph has 0 nodes, it is still a tree.
09:54:41 <tawe> But I thought that Gnode [] would represent a Leaf also.. 
09:54:45 <tawe> makes more sense
09:54:50 <tawe> than the NULL tree
09:55:20 <saml> what's tree with root only?
09:55:25 <yrlnry> Trivial tree.
09:55:26 <saml> Leaf _   ?
09:55:31 <yrlnry> Yes.
09:55:39 <saml> or is it GNode [Leaf _]
09:55:45 <saml> why not GNode [] ?
09:55:51 <saml> GNode [] looks like a root node
09:56:03 <saml> so GNode [] is a trivial tree. not empty tree
10:00:18 <Ke> am I the only one really who would really really like to use traceShow of type b -> b
10:00:39 <hpc> :t trace
10:00:40 <lambdabot> Not in scope: `trace'
10:00:45 * hackagebot alsa-mixer 0.1.1 - Bindings to the ALSA simple mixer API.  http://hackage.haskell.org/package/alsa-mixer-0.1.1 (ThomasTuegel)
10:00:47 <hpc> :t Debug.Trace.trace
10:00:49 <lambdabot> forall a. String -> a -> a
10:00:57 <ClaudiusMaximus> :t join Debug.Trace.traceShow
10:00:58 <lambdabot> forall a. (Show a) => a -> a
10:01:22 <Ke> well that's only a bit painful
10:02:31 <Ke> I fail to see even remotely as significant use case for traceShow of type a -> b -> b as with b -> b
10:02:46 * hackagebot FindBin 0.0.3 - Locate directory of original program  http://hackage.haskell.org/package/FindBin-0.0.3 (AudreyTang)
10:02:59 <kmc> sometimes you want to show x but have the showing occur on evaluation of y
10:03:09 <kmc> perhaps because it's syntactically easier to stuff it into your code there
10:04:19 <hpc> that sort of tracing can change strictness though
10:04:26 <hpc> that would seem problematic
10:04:59 <Ke> I'd really love being able to trace without modifying source
10:05:13 <Ke> with actual programs that use cabal
10:13:03 <sm> Ke: some other trace variants at http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=headblob;f=/hledger-lib/Hledger/Data/Utils.hs line 264
10:16:12 <roconnor> I think I have almost exclusively used trace with type a -> b -> b with a and b different.
10:19:23 <fmapE> So, writing high-level bindings is hard
10:19:34 <kmc> but so rewarding :)
10:19:39 <kmc> what problem have you run into?
10:20:09 <fmapE> kmc: I'm trying to bind to an audio library (JACK specifically)
10:20:20 <hpaste> pielgrzym pasted "Append to file effort :)"  http://hpaste.org/44493
10:20:24 <monochrom> writing high-level binding = design a new API
10:20:25 <fmapE> trying to come up with a high-level interface is frustrating
10:20:29 <fmapE> yes
10:20:39 <fmapE> the biggest issue
10:20:45 <fmapE> is that while you're running
10:20:49 <fmapE> you can add new audio ports
10:20:54 <fmapE> and drop old ones
10:20:57 <fmapE> both in and out
10:21:01 <fmapE> and it's callback based
10:21:52 <fmapE> so I have to be able to write a callback that can find out about new ports and dropped ports
10:21:59 <fmapE> and produce data for all of the outputs
10:22:57 <fmapE> so currently
10:23:15 <fmapE> my idea is to have the user write callbacks in a monad transformer stack
10:23:43 <fmapE> thats essentially ReaderT JackState IO a
10:23:51 <copumpkin> Baughn: the haskell-mode for emacs URL is empty. Are you still the maintainer?
10:24:03 <fmapE> and have jackstate be a list of new/dropped ports for each iteration
10:24:18 <fmapE> so the question I'm struggling with
10:24:19 <Ke> hmm, what does join traceShow actually do
10:24:28 <Ke> what monad instance is this
10:24:32 <Ke> (->) ?
10:24:47 <fmapE> is should I allow the user a means to replace the callback (i.e. a continuation-ish)
10:24:47 <copumpkin> ((->) r) is often called reader
10:24:56 <copumpkin> and is often wrapped in a newtype of the same name
10:26:17 <Baughn> copumpkin: Yes. Sorry, it's been hilarious at work lately.
10:26:29 <Baughn> *Finally* that's clearing up, though
10:30:58 <copumpkin> Baughn: ah cool
10:31:08 <copumpkin> I just wanted to install it on another computer and wasn't able to
10:37:06 <Ke> > join (+) 2
10:37:07 <lambdabot>   4
10:37:24 <opqdonut> hmmh, Map + deleteFindMin is way faster than Data.Heap
10:37:41 <kmc> not too surprised
10:37:44 <kmc> more people use Map
10:37:45 <hpc> > join f x
10:37:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:37:46 <lambdabot>    `SimpleReflect.FromExpr ...
10:37:50 <hpc> > join f x :: Expr
10:37:51 <lambdabot>   f x x
10:37:56 <opqdonut> kmc: indeed
10:38:03 <taweee> :t uncurry
10:38:03 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:38:07 <opqdonut> but a factor of 5 seems overkill
10:38:13 <kmc> IntMap is probably even faster, if your keys are Ints
10:38:21 <taweee> :t (uncurry . id)
10:38:22 <opqdonut> they're floats, sorry :)
10:38:22 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:38:36 <taweee> ?
10:38:39 <opqdonut> maybe I'll profile
10:38:49 <taweee> :t uncurry.id
10:38:49 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:38:59 <fmapE> I wonder if IntMap and the conversion from pointers to ints is faster than Map with pointer keys?
10:39:06 <hpc> taweee: f . id == id . f == f for all f
10:39:10 <hpc> :t uncurry id
10:39:11 <lambdabot> forall b c. (b -> c, b) -> c
10:39:24 <taweee> hpc, hah yes, thanks.
10:39:31 <hpc> it's the first category law, applied to (->)
10:39:36 * hackagebot temporal-media 0.2.1 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.2.1 (AntonKholomiov)
10:39:39 * hackagebot temporal-music-notation 0.1.2 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.1.2 (AntonKholomiov)
10:40:01 <Ke> does join traceShow work at all
10:40:13 <kmc> fmapE, the conversion from pointers to ints should be a no-op at runtime
10:40:20 <taweee> There's any online version of this bot?
10:40:32 <fmapE> kmc: cool thanks
10:40:33 <Ke> for some reason I am totally unable to get anything out of it
10:40:34 <hpc> @where lambdabot
10:40:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:40:35 * hackagebot temporal-music-notation-western 0.1.2 - music notation  http://hackage.haskell.org/package/temporal-music-notation-western-0.1.2 (AntonKholomiov)
10:40:44 <kmc> fmapE, i'm not sure to what extent that's actually true
10:40:50 <fmapE> hm
10:41:00 <Ke> > join traceShow "aa"
10:41:00 <kmc> if you're using fromIntegral it's probably not
10:41:01 <lambdabot>   Not in scope: `traceShow'
10:41:03 <fmapE> well how would you recommend I investigate?
10:41:13 <taweee> hpc, thanks again.
10:41:35 <kmc> to determine if such optimizations are occurring you'd have to read the Core or some later output of GHC
10:42:41 <kmc> it is /probably/ safe (wrt current GHC implementation details) to unsafeCoerce between Ptr and Int
10:43:03 <kmc> and that is guaranteed to be a run-time no-op
10:43:11 <hpc> unsafe is unsafe for a reason though, so test it first ;)
10:43:42 <kmc> testing is not a very reliable way to uncover such bugs
10:43:52 <kmc> see also: all code written in C
10:44:12 <fmapE> kmc: hmm well I'd actually have to use fromIntegral . ptrToIntPtr to convert to pointers if I went the fromIntegral route
10:44:21 <kmc> *nod*
10:44:43 <kmc> it's a shame IntMap isn't more generic in a clever way
10:44:58 <kmc> there's an EnumMap package but it just calls "fromEnum"
10:45:02 * fmapE goes to write a bit of test/benchmark code
10:45:22 <kmc> so it doesn't address the problem of how to write YourType -> Int efficiently
10:46:26 <kmc> what i'm imagining is like class Word t where { toWord :: t -> Word# }
10:46:34 <opqdonut> oh, I was using the wrong heap...
10:46:37 <opqdonut> max vs min
10:46:39 <kmc> where toWord is expected to be a constructor unwrapping + maybe a coerce
10:46:44 <kmc> fmapE, are you using Criterion?
10:46:55 <fmapE> kmc: no
10:46:59 <fmapE> what's that?
10:47:09 <fmapE> also
10:47:15 <kmc> a fantastic benchmarking library
10:47:16 <opqdonut> now it's slightly faster :)
10:47:20 <opqdonut> criterion rules
10:47:36 <fmapE> ah ok
10:47:39 <fmapE> so
10:47:42 <fmapE> at the very least
10:47:53 <fmapE> unsafeCoerce Int -> Ptr () doesn't work
10:48:02 <fmapE> so I doubt the representations are similar enough
10:48:15 <kmc> define "doesn't work"
10:48:19 <fmapE> as in
10:49:01 <kmc> data Int = I# Int#
10:49:06 <kmc> data Ptr a = Ptr Addr#
10:49:17 <fmapE> unsafeCoerce (0xdeadbeef::Int) :: Ptr () gives 0x01024b34
10:49:26 <kmc> and i think GHC guarantees sizeof(Int#) == sizeof(Addr#)
10:49:34 <monochrom> copumpkin: if you trust me, http://www.vex.net/~trebla/tmp/haskell-mode-2.8.0.tar.gz
10:49:36 <fmapE> in ghci at least
10:49:50 <kmc> fmapE, it works for me, are you on a 32-bit system?
10:50:05 <kmc> note that 0xdeadbeef is a negative 32-bit int
10:50:11 <fmapE> oright
10:50:12 <kmc> so it's probably fucking with your bits before they become an Int
10:50:13 <fmapE> also yes
10:50:19 <copumpkin> monochrom: omg what it you have a virus
10:50:32 <fmapE> I'm using OS X so I'm still stuck with 32bit
10:50:38 <monochrom> I don't know.
10:50:44 <kmc> that is, what do you get from just "0xdeadbeef :: Int"
10:51:08 <hpc> > 0xdeadbeef :: Int
10:51:09 <lambdabot>   3735928559
10:51:20 <opqdonut> > 0xdeadbeef :: Integer
10:51:21 <lambdabot>   3735928559
10:51:21 <fmapE> yea I get negative
10:51:29 <fmapE> lemme try something else
10:51:30 <opqdonut> oh, lambdabot is 64bit then :)
10:51:46 <hpc> > 0xdeadbeef :: Float
10:51:47 <lambdabot>   3.7359286e9
10:51:49 <hpc> :D
10:51:59 <hpc> :( no floating point errors
10:52:08 <fryguybob> > 0xdeadbeef :: Int32
10:52:09 <lambdabot>   -559038737
10:52:11 <fmapE> kmc: ok so yea it was the negative
10:52:36 <fmapE> unsafeCoerce (0xeadbeef::Int) :: Ptr ()
10:52:42 <fmapE> gives 0x0eadbeef
10:52:48 <fmapE> hm
10:52:57 <hpc> missing a 'd'
10:53:05 <fmapE> hpc: yes that's the point
10:53:13 <hpc> ah
10:53:20 <fmapE> the 'd' overflows into negative on 32bit
10:53:41 <pheaver> hello, i'm trying to use RTS options with ghc-7.  apparently i'm supposed to build with -with-rtsopts instead of running with +RTS.  but, when i build with  -with-rtsopts="-N2" and then run the program, it says: unexpected RTS argument: "-N2".  has anyone seen this behavior?
10:53:43 <fmapE> and if I recall correctly GHC uses the sign bit of pointers for something else
10:54:02 <kmc> fmapE, i doubt that
10:54:17 <fmapE> why?
10:54:21 <kmc> plus Ptr is often representing a pointer into somewhere other than GHC's heap
10:54:43 <kmc> the issue is just that (0xdeadbeef :: Int) is not the value you'd expect on 32-bit, any more than (999999999999999999999999 :: Int) is
10:54:50 <kmc> it has nothing to do with pointers
10:55:02 <fmapE> ok
10:55:02 <fmapE> \
10:55:31 <kmc> i doubt GHC uses the sign bit for special purposes because i've never heard that it does, plus the upper half of memory is a totally valid space on many platforms
10:55:39 <kmc> what would it do if the OS gave it a mmap there?
10:55:54 <kmc> GHC uses the *low* 2 or 3 bits for pointer tagging
10:56:02 <fmapE> oohhhh ok
10:56:16 <kmc> this is workable because GHC allocates its structures on a word-size-aligned address
10:56:18 <fmapE> but 0xdeadbeef is a 32 bit int
10:56:30 <fmapE> wait
10:56:31 <fmapE> nvm
10:56:34 <kmc> 0xdeadbeef is a compile-time Integer literal
10:56:35 <fmapE> Int is signed
10:56:39 <fmapE> right
10:56:43 <bos> what are you trying to actually do?
10:56:49 <fmapE> bos:
10:57:10 <kmc> bos, the underlying question is whether «unsafeCoerce :: Int -> Ptr t» is going to be safe wrt current GHC
10:57:10 <fmapE> bos: I will have pointers to opaque structures given to me by a library
10:57:30 <kmc> maybe the underlying underlying question is how to make a fast map with (Ptr t) keys
10:57:36 <fmapE> and I want to use those pointers as keys in an intmap
10:57:55 <fmapE> kmc: yea that's prolly it
10:58:09 <rostayob> stepkut: I don't get what advantages the kdmap has over IxSets in terms of ordering results after some search over an index.
10:59:27 <bos> kmc: i'm pretty sure that won't work
11:00:07 <kmc> why not?
11:00:37 <bos> kmc: because the runtime representations of Ptr and Int are different
11:00:40 * hackagebot temporal-music-notation-demo 0.1.2 - Library: generates midi from score notation.  http://hackage.haskell.org/package/temporal-music-notation-demo-0.1.2 (AntonKholomiov)
11:00:58 <kmc> bos, they're both a one-constructor algebraic type
11:01:04 <kmc> with a Word# and Int# field respectively
11:01:15 <kmc> err
11:01:17 <kmc> Addr# and Int#
11:01:22 <kmc> and i think GHC guarantees those have the same size
11:02:14 <monochrom> w00t, ghc 7.0.2 is official
11:02:22 <copumpkin> kmc: they don't guarantee it, afaik
11:02:23 <kmc> would be smart to pair such code with a compile-time assertion to that effect
11:02:36 <kmc> i mean it's fuzzy what GHC "guarantees" in this space
11:02:50 <copumpkin> http://snapplr.com/v96d
11:02:56 <copumpkin> but yeah
11:03:00 <copumpkin> in practice they probably are
11:03:05 <kmc> nice copumpkin
11:03:21 <kmc> i wonder if they're deprecated because no longer necessary
11:03:50 <kmc> what i mean by "guarantee" is weaker than what's in the haddock for unsafeCoerce
11:03:51 <copumpkin> dankna: yo yo
11:03:55 <copumpkin> yeah
11:03:58 <kmc> i think i mean basically that GHC itself makes this assumption internally
11:04:05 <kmc> and it's unlikely to change
11:04:17 <kmc> but maybe it's not as wired-in as i thought
11:04:48 <copumpkin> it might be true, but they might not be willing to commit to other people assuming it
11:06:00 <fmapE> kmc, copumpkin, in which case I probably shouldn't assume it
11:06:13 <copumpkin> fmapE: I dunno, I probably still would
11:06:14 <copumpkin> :P
11:06:25 <kmc> fmapE, it depends on how the code you're writing is to be used
11:06:37 <kmc> the degree to which performance and portability and future-proofness matter
11:06:49 <fmapE> I'm hoping to put it up on hackage
11:06:51 <bos> you could maybe use unordered-containers
11:07:00 <fmapE> it's a binding to a very popular library
11:07:16 <fmapE> there already is one binding but I hate the API
11:07:28 <bos> which library?
11:07:30 <kmc> the super thorough thing to do would be to provide two implementations of a Ptr t -> Int function
11:07:37 <fmapE> JACK (audio routing)
11:07:41 <bos> ah
11:07:44 <kmc> and select between them with C preprocessor magic
11:08:06 <kmc> and have the fast unsafe one enabled only on GHC and on versions you're willing to certify are working
11:08:17 <fmapE> blech
11:08:18 <monochrom> yuck, 107MB tarball
11:08:24 <fmapE> maintenance headache
11:08:28 <fmapE> I'm a college student
11:08:32 <fmapE> I'm willing to fix bugs
11:08:40 <kmc> yeah, not a perfect solution
11:08:43 <fmapE> but I don't wanna have to update my package for every new version of GHC :P
11:08:55 <kmc> well you can start by claiming it works for all GHC 6 and 7
11:09:02 <fmapE> mhm
11:09:09 <kmc> and then upload a "bugfix" if GHC breaks your assumption ;P
11:09:19 <kmc> is this in a performance critical / realtime path?
11:09:20 <fmapE> well I'll try out fromInteger . ptrToIntPtr
11:09:32 <fmapE> realtime yes
11:10:39 <fmapE> the idea is that JACK says passes an int to the callback saying "process this many frames"
11:10:51 <fmapE> then you call jack functions to allocate a buffer for each port with that many frames
11:10:58 <fmapE> and loop that many times to write your buffer
11:11:10 <fmapE> but in client code I want to use an intmap because they will have the ports
11:11:24 <fmapE> so I want to be able to map to the buffer for the port in that callback cycle
11:11:38 <taweee> Question. Any nicer way to do what it's trying to be done here? http://pastebin.com/G6ZXgawS
11:12:20 <fmapE> on a normal system a callback loop cycle should run in about 5.7 microseconds maybe?
11:12:32 <fmapE> so yea performance is a good thing
11:12:43 * hackagebot csound-expression 0.3.1 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.3.1 (AntonKholomiov)
11:13:41 <Maxdamantus> What size requirements are required of Int?
11:13:57 * Maxdamantus would imagine it would not strictly be possible to convert pointers to Int on some platforms.
11:14:10 <kmc> the Report says only that Int includes the range -2^29 .. (2^29)-1
11:14:30 <kmc> i believe GHC's Int is always a machine word
11:14:39 <luite_> taweee: fromMaybe 0 (getNthz xs n)
11:14:41 <kmc> this is true at least of the popular platforms
11:15:06 <dons> > sizeOf (undefined :: Int)
11:15:07 <lambdabot>   Not in scope: `sizeOf'
11:15:16 <dons> > maxBound :: Int
11:15:17 <lambdabot>   9223372036854775807
11:15:21 <dons> > maxBound :: Int32
11:15:22 <lambdabot>   2147483647
11:15:29 <eugenk> hello there. i've got a problem: i just installed the haskell platform 2010 on windows 7 64 bit and started ghci. now, when i want to load the module `System.Directory`, i get an error message: 
11:15:29 <eugenk> Prelude> :m +System.Directory
11:15:29 <eugenk> <no location info>:
11:15:29 <eugenk>     Could not find module `System.Directory':
11:15:29 <eugenk>       it is not a module in the current program, or in any known package.
11:15:37 <taweee> luite_, thanks.
11:15:48 <dons> eugenk: hmm. that's odd.
11:15:50 <taweee> @src fromMaybe
11:15:50 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
11:16:05 <eugenk> on linux everything is fine, but now i want to work a bit with windows ^^
11:16:23 <antonh> Yay. I just ran valgrind on my simple Haskell implementation. It is leaking quite some memory :/
11:16:54 <Zao> antonh: I wouldn't trust valgrind _that_ much.
11:17:07 <luite_> taweee: you may also find fmap handy when working with Maybe, for example: fmap (+1) (Just 1) = 2, fmap (+1) Nothing = Nothing
11:17:18 <Zao> Particularly not with the clever conventions and squirreling of memory that the GC does.
11:17:20 <c_wraith> antonh: have you verified that the application is also growing in size at the same time?
11:17:32 <taweee> luite_, cool
11:17:37 <Zao> antonh: Unless of course you went all insane with Data.Foreign.C, of course :D
11:17:47 <taweee> @src fmap
11:17:47 <lambdabot> Source not found. I feel much better now.
11:17:56 <antonh> Zao, I did not :)
11:18:11 <luite_> taweee: fmap is a method of the class Functor. Maybe is an instance of Functor. you can use fmap for much more than just Maybe
11:18:27 <antonh> c_wraith, no, I didn't verify that
11:18:31 <eugenk> anyone an idea? it is really strange that i can't load the system module... thus i can't install any package with cabal
11:19:19 <luite_> taweee: you can see the implementation for fmap for Maybe here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Maybe.html
11:19:25 * fmapE whistles back to working on his API
11:19:31 <antonh> Zao, i should probably keep valgrind to my C applications, right?
11:19:37 <samuel4211> why should I study haskell? should i start directly with haskell as my first functional language to study? or go with something else, every input from you guys is highly appreciated. thansk
11:19:45 * hackagebot temporal-music-notation-demo 0.1.3 - generates midi from score notation.  http://hackage.haskell.org/package/temporal-music-notation-demo-0.1.3 (AntonKholomiov)
11:20:06 <Zao> antonh: Unless you manually fap around with memory, yeah.
11:20:25 <luite_> taweee: you will see that it also is a Monad
11:20:35 <kmc> samuel4211, if you ask #haskell you will probably get pretty positive opinions of Haskell :)
11:20:40 <Zao> antonh: "leaks" in the Haskell world tends to be more about space leaks, where things tend to hang around for too long.
11:20:59 <taweee> @src maybe
11:21:00 <lambdabot> maybe n _ Nothing  = n
11:21:00 <lambdabot> maybe _ f (Just x) = f x
11:21:13 <samuel4211> kmc: :) that's what i want to hear :D
11:21:20 <taweee> > maybe 0 id (Just 5)
11:21:20 <lambdabot>   5
11:21:27 <taweee> luite_ :)
11:21:38 <kmc> samuel4211, the main reason *not* to learn Haskell is if you're expecting to pick up a new language quickly, or to do something big as your first project
11:22:01 <kmc> learning Haskell is hard and you will feel dumb at not being able to figure out even simple things
11:22:08 <samuel4211> kmc: no, i have no time constraints
11:22:33 <kmc> basically it's *actually* a new language, not some warmed over alternative syntax for Java
11:22:35 <kmc> :)
11:23:07 <fmapE> kmc: The first haskell program I wrote, I mangled the IO monad into warmed over synax for java
11:23:10 <fmapE> ><
11:23:15 <kmc> :D
11:23:15 <luite_> taweee: yeah that's another function. but if you have fromMaybe and fmap, you don't really need maybe:   maybe n f m = fromMaybe n (fmap f m)
11:23:22 <samuel4211> kmc: how old is haskell?
11:23:32 <kmc> samuel4211, the first version of the language was specified in 1990
11:23:40 <kmc> the current version was specified in 2010 and the one before in 1998
11:23:49 <kmc> it's old as languages go, but its relative popularity is new
11:23:55 <vegai> huh, they got the new standard out in 2010?
11:24:11 <samuel4211> 2010? nice
11:24:13 <fmapE> http://portal.acm.org/citation.cfm?doid=1238844.1238856
11:24:20 <fmapE> good read on the history of haskell
11:24:34 <kmc> samuel4211, since Haskell is a standard language, the history of the language is separate from the history of its most popular compiler, GHC
11:24:39 <kmc> GHC is under quite active development
11:24:52 <kmc> version 7 came out late last year and will soon be "blessed" for end-users with the release of Haskell Platform 2011
11:25:09 <luite_> the latest ghc even came out today!
11:25:27 <samuel4211> kmc: i never did any functional programming before... is it preferred over other paradigms such as object-oriented?
11:25:35 <fmapE> luite_: which is exciting, because I think dons said he was waiting for 7.0.2 to release HP 2011
11:25:36 <tg_> is ghc 7.0.2 == ghc 7.0.1 RC?
11:25:46 * hackagebot temporal-music-notation 0.1.3 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.1.3 (AntonKholomiov)
11:25:48 <kmc> samuel4211, it has some advantages and some disadvantages
11:26:03 <kmc> vague questions of "which is better" will never get you a satisfying answer and will usually provoke a flamewar
11:26:06 <tg_> samuel4211: like everything in computer science, there are tradeoffs
11:26:28 <kmc> samuel4211, i suggest you learn Haskell first, then you can see how it's used not only for functional programming but also imperative, object-oriented, concurrent, logic, etc. styles
11:26:45 <kmc> it's a very flexible language; don't believe the outsiders who make it out to be some FP-only extremist's language
11:26:54 <Philonous> samuel4211: functional and object-oriented are by no means mutually exclusive
11:27:25 <luite_> fmapE: yeah I know, but I already installed it, I was so excited that I couldn't wait any longer for the platform ;)
11:27:28 <tg_> samuel4211: there are some areas where Haskellers believe (rightly or wrongly) the language helps the programmer's understanding of what's happening
11:27:28 <kmc> samuel4211, do note also that the most popular "OOP" languages like Java are a pathetic example of what OOP is actually good for
11:27:42 <fmapE> luite_: Yea I should prolly do that too
11:27:47 * hackagebot temporal-music-notation-western 0.1.3 - western music notation  http://hackage.haskell.org/package/temporal-music-notation-western-0.1.3 (AntonKholomiov)
11:27:55 <fmapE> I build dons's alpha of the HP with 7.0.1 64 bit on my mac
11:27:55 <kmc> Java is a terrible, weak language and that has nothing to do with its supposed "paradigm"
11:28:01 <kmc> and everything to do with them assuming their users are idiots
11:28:16 <kmc> so if Haskell is better than Java, this says nothing about functional vs. oop
11:28:24 <kramble> hi, when I compile my program (four .hs files) with --make ghc succeed without complaining, but if i try to build one by one with -c and -o at last, ghc failed saying that it doesn't find classes I import (like Control.Monad.State.Lazy by example)
11:28:34 <tg_> Java: It's what C++ should have been, if we couldn't trust our programmers.
11:28:34 <kramble> why ? and what can I do to compile by hand
11:28:41 <kmc> kramble, because it also wants -package
11:28:49 <kmc> use --make, or use Cabal
11:28:51 * fmapE rushes in behind hmc with the fire extinguisher
11:28:55 <fmapE> *kmc
11:29:23 <Philonous> kmc: I think the "paradign" of java is production of code in an industrial scale, with "programmers" being replaceable components in the code factory
11:29:47 * hackagebot temporal-music-notation-demo 0.1.4 - generates midi from score notation.  http://hackage.haskell.org/package/temporal-music-notation-demo-0.1.4 (AntonKholomiov)
11:29:53 <kramble> kmc: in fact my problem arrised when I try to play with haddock, and haddock complains, so i start to look why using ghc by hand
11:29:55 <kmc> Philonous, and Java is merely an intermediate form for linking... all the effective Java programmers write in shorthand translated by their IDEs
11:29:56 <fmapE> Philonous: That's why it's taught in universities!
11:29:56 <Philonous> kmc: Java es actually quite well suited for this
11:30:14 <tg_> You gus know, the LHC (Large Hadron Collider) is a huge complicated experiment, heavily controlled by computers.
11:30:26 <kmc> kramble, cabal will run both ghc and haddock for you
11:30:39 <fmapE> tg_: so GHC is the Gigantic Hadron Collider?
11:30:43 <confound> Ginormous
11:30:45 <tg_> there are probably... 20,000 computers responsible for just running the mechanics and measurments and readings of the machine
11:30:47 <kramble> kmc: I want to do things by hand before do with auto tools
11:31:04 <tg_> when I watch the operations of the machine, one thing I notice - the commonest approach for the machine operators to fix a problem
11:31:06 <tg_> is to reboot host machines :|
11:31:22 <kramble> tg_: it solves many problem
11:31:23 <tg_> from that fact alone, what language / OS do you suspect they use? :O
11:31:32 <samuel4211> tg_: what do they use in terms of languages? do you know?
11:31:37 <tg_> I do
11:31:46 <fmapE> java/c++ on windows? (my guess)
11:31:47 <kramble> perl under BSD :D
11:31:54 <fmapE> lol
11:31:54 <tg_> kramble: lol
11:31:56 <samuel4211> java?
11:32:00 <tg_> java, yep
11:32:02 <Philonous> fmapE: Yeah, my professors where quite open about it. In their opinion a programmer is a glorified typist while the real work is designing the process that leads the "software architect" from the wishes of his customers to the finished "product". 
11:32:03 <samuel4211> visual basic? lol
11:32:04 <tg_> in linux
11:32:10 <samuel4211> yeah
11:32:32 <fmapE> Philonous I think it's a spectrum, granted I have little actual experience in industry
11:32:33 <tg_> where it really counts (machine safety equipment, radiation monitors, etc)
11:32:45 <tg_> they use something more verificable or some DSL
11:32:51 <kramble> like ADA
11:32:52 <tg_> but most of it's java
11:32:53 <tg_> yeah
11:32:55 <tg_> they use ada
11:33:12 <kramble> ada is the only prooved compilator with coq that i know
11:33:43 <chrisf|work> Philonous: you avoid the workplaces that think that way ;)
11:34:14 <kramble> (one of the biggest french militar industry got a memory leak in their radar, so they reboot theme every day :D)
11:34:39 <tg_> hopefully it's not their reactors
11:34:45 <HaudRex> I want to generate this sequence: [Lam(\a -> a), Lam(\b a -> a b), Lam(\b c a -> a b c), Lam(\b c d a -> a b c d), ...]
11:35:20 <kramble> hg_: our train system is not prooved, they don't know if one day two trains will crash
11:35:39 <tg_> for their actual physics simulations and data analysis, of course, they use C
11:35:56 <kramble> not pascal, i thought it was faster than C
11:36:04 <tg_> they have a whole library built up in C
11:36:05 <kramble> (or fortran, don't remember)
11:36:16 <samuel4211> what do you guys think of F#?
11:36:26 <tg_> samuel4211: it's made by Microsoft
11:36:29 <HaudRex> F# hasn't higher kinded types
11:36:52 <kramble> samuel4211: it's an hybrid between haskell and ocaml, but without the real power of ocaml, and without the real power of haskell
11:36:57 <taweee> luite_, thanks for the information. Unfortunately Hugs doesn't have fmap and fromMap, only maybe and mapMaybe :|
11:37:00 <tg_> excuse me
11:37:02 <tg_> ROOT http://en.wikipedia.org/wiki/ROOT
11:37:04 <tg_> is written in C++
11:37:16 <samuel4211> F# programmiing is currently one of the most paying jobs in my city now, funny
11:37:31 <kramble> wich city ?
11:37:36 <luite_> taweee: oh you should really use ghci instead of hugs
11:37:56 <samuel4211> Montreal
11:37:58 <samuel4211> Canada
11:38:07 <kramble> i know where Montreal is
11:38:17 <tg_> I didn't know Canada had jobs :|
11:38:20 <kramble> maybe i can go there and do some F#
11:38:48 <taweee> luite_, maybe in near future. Now my undergraduate course of functional programming has Hugs enviroment, so I cannot risk myself to make some code not compatible with Hugs
11:39:13 <fmapE> taweee what uni are you at?
11:39:35 <taweee> fmapE, I doubt you know it :), from Uruguay.
11:39:40 <fmapE> ah ok
11:39:50 <samuel4211> kramble: how much do they pay in your city for a functional programmer? here its growing huge
11:39:53 <mauke> @src Maybe
11:39:53 <lambdabot> data Maybe a = Nothing | Just a
11:40:07 <fmapE> speaking of jobs
11:40:11 <rostayob> taweee: yeah my uni tought haskell with Hugs as well
11:40:13 <fmapE> anyone know of people hiring FP interns?
11:40:15 <kramble> samuel4211: french only got C#, C++ and Java jobs
11:40:19 <kramble> FP is really rare
11:40:35 <kramble> but the most well paid is C#
11:40:39 <kmc> tg_, F# is made by Microsoft? so is GHC.  what's your point?
11:40:40 <fmapE> mine teaches FP with Scheme/Lisp in Programming Languages
11:40:44 <rostayob> fmapE: janestreet does OCaml
11:40:51 <fmapE> then if you take the FP course you learn Haskell
11:41:13 <rostayob> fmapE: trading firms in general seem to be using a lot of fp, which is sad
11:41:19 <Philonous> Is there a list of packages that category-extras has been split into?
11:41:21 <rostayob> fmapE: and it's really, really hard to get in jane street
11:41:27 <fmapE> why is that sad?
11:41:36 <rostayob> fmapE: because I don't like finance :P
11:41:43 <fmapE> oh well yes
11:41:48 <fmapE> I'm not so keen on it either
11:41:56 <kramble> fp will be the future when the got a good UI designer
11:42:02 <kramble> s/the/they/
11:42:11 <kramble> today, noone can rivalize with VS
11:42:20 <fmapE> rivalize
11:42:22 <fmapE> good word
11:42:31 <kramble> fmapE: it's not an american word ?
11:42:50 <fmapE> generally we'd just say "no one can rival VS"
11:43:01 <kramble> fmapE: ok, thx for the info
11:43:10 <fmapE> rivalize technically would mean "to make <the object> a rival"
11:43:12 <tg_> i was going to say, I like it
11:43:37 <gwern> @hoogle m (Maybe a) -> (a -> m ()) -> m ()
11:43:37 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:43:37 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:43:38 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:44:13 <kramble> fmapE: i'll try to remmeber that in future
11:44:55 <samuel4211> GHC was made by Micro$oft?
11:45:04 <tg_> wno
11:45:07 <tg_> no
11:45:10 <fmapE> kramble: no worries I just generally find humor in how I and other people use language
11:45:12 <kmc> samuel4211, sort of; Microsoft Research Cambridge employs two of the main GHC developers to work on GHC
11:45:13 <kramble> samuel4211: kro$oft give money an developpers i think
11:45:13 <tg_> GHC is independent and open source
11:45:26 <tg_> some of the lead developers (SPJ, in particular) works for Microsoft Research
11:46:00 <kramble> fmapE: no no, i like when someoe help me to improve my english
11:46:02 <samuel4211> but can Microsoft terminate this as project? it doesn't own it yeah?
11:46:03 <djahandarie> Simon Marlow also works there.
11:46:15 <tg_> samuel4211: nobody can terminate it
11:46:17 <tg_> it's open source
11:46:17 <kmc> samuel4211, the GHC code is BSD licensed
11:46:35 <djahandarie> samuel4211, they could probably tell the Simons to stop working on it
11:46:36 <kramble> samuel4211: where do you think f# come from ? :D it's idea taken from OCaml and Haskell
11:46:44 <djahandarie> But I imagine they'd just quit and go get paid by some other people.
11:46:51 <kmc> kramble, and then renamed so they sound like MS original ideas
11:47:09 <tg_> SPJ and Marlow have pretty sweet jobs
11:47:11 <kramble> kro$oft help many open source projects, but they never say that
11:47:16 <tg_> so they won't be badmouthing their employer anytime soon
11:47:16 <samuel4211> kramble: yeah.. you're right
11:47:29 <kramble> like this they can see what happens in world and evoluate
11:48:17 <kmc> everyone knows monads are useless academic wankery, but F# workflows / computation-expressions are the new enterprise webscale cloud solution
11:48:18 <kleinucopia> is there a function like permutations or subsequences that will take a list and give you all the elements pairwise?
11:48:35 <kmc> kleinucopia, all pairs?
11:49:11 <kleinucopia> kmc: no, just adjacent ones. i.e.  f [a, b, c, d, e]  -> [[a,b],[b,c],[c,d],[d,e]]
11:49:33 <kramble> :t \l -> l >>= \x -> l >>= \y -> return (x, y)
11:49:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m (a, a)
11:49:40 <kmc> > let f xs = zip xs (tail xs) in f "abcde"
11:49:41 <lambdabot>   [('a','b'),('b','c'),('c','d'),('d','e')]
11:49:43 <monochrom> microsoft research enjoys much academic freedom. even more so than compaq research (formerly dec research) or ibm watson, actually.
11:50:10 <aristid> kmc: oh, the temptation to write zip<*>tail!
11:50:14 <kmc> :D
11:50:29 <kmc> microsoft has an interest in funding Haskell research on one hand and on the other hand telling everyone Haskell is incomprehensible academic gibberish and that you should use F# instead
11:50:39 <kmc> i'm not sure how much of the latter they actually do
11:50:40 <kleinucopia> kmc: well, I wasn't looking for pairs, but that should work
11:50:47 <monochrom> for example (straight from spj's mouth) at compaq research before you publish a paper in conference/journal, lawyers have to see it first. at microsoft research you don't even have to do that.
11:50:53 <tg_> kmc: but that's not unexpected. microsoft is huge. the left hand doesn't talk to the right hand in organizations that big
11:50:55 <Boxo> @quote consequtive
11:50:55 <lambdabot> No quotes match. You untyped fool!
11:50:58 <aristid> kmc: that statement about microsoft was sarcastic, right? oO
11:50:59 <kramble> :t \l -> l >>= \x -> l >>= \y -> return [x, y]
11:51:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
11:51:06 <aristid> @quote consecutive
11:51:06 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
11:51:11 <aristid> Boxo: :P
11:51:23 <Boxo> heh
11:51:31 <kmc> aristid, which?
11:52:06 <Boxo> http://en.wiktionary.org/wiki/consequtive
11:52:19 <aristid> kmc: <kmc> microsoft has an interest in funding Haskell research on one hand and on the other hand telling everyone Haskell is incomprehensible academic gibberish and that you should use F# instead
11:52:31 <kmc> aristid, it's not sarcastic; this would be in their business interests
11:52:32 <olsner> kmc: those goals may not be mutually exclusive though - get the academics into haskell and filter the gibberish into useful stuff they can put in F#
11:52:38 <kramble> does kro$oft speaks about Haskell ?
11:52:43 <thoughtpolice> i remember reading simon marlow's twitter, apparently one of the toughest things at MSR is the annual review period where they review the work you've done
11:52:44 <kmc> note that i don't say they *do* this
11:52:56 <thoughtpolice> i think he said something like "PhD students have it so easy, it's a joke"
11:53:11 <kmc> olsner, right, but there's also a pervasive myth that Haskell is harder / more useless than it is
11:53:36 * monochrom imagines Tony Hoare or Robin Milner getting reviewed! XD
11:53:51 <olsner> (or maybe they just made F# to keep Harrop occupied while they research haskell?)
11:53:55 <kmc> hahaha
11:56:12 * monochrom contemplates asking JaffaCake "how well does Tony Hoare pass his annual review?" and hopes the answer is "no no, in Soviet Russia^W^W Microsoft Cambridge, Tony reviews you!"
12:01:55 * hackagebot dataenc 0.14 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.14 (MagnusTherning)
12:04:55 * hackagebot omnicodec 0.5 - data encoding and decoding command line utilities  http://hackage.haskell.org/package/omnicodec-0.5 (MagnusTherning)
12:10:43 <xplat> some of these package descriptions are pretty obscure
12:10:56 <xplat> preflex: seen mjrosenb
12:10:56 <preflex>  mjrosenb was last seen on #haskell 13 hours, 48 minutes and 33 seconds ago, saying: Omie: the first thing i wrote was a cli that given n would compute an n bit prime number
12:12:56 <siyahband> is there anybody who can explain me the logic behind dynamic type checking
12:13:05 <fmapE> I think it would be incredibly useful to have unimplemented = error "Unimplemented" in the Prelude
12:13:14 <fmapE> then I could write type sigs for my API
12:13:28 <fmapE> and define the functions as "foo = unimplemented"
12:13:30 <fmapE> and compile it
12:13:40 <accel> (ghc internals): what is the best way to design my own "compiler" for a piece of ahskell code? I don't want to change the parser, I don't want to change the backend ; I just want to throw in a few optimization passes / be able to specify whether certain things are shared or not (and I'm willing to hack parts of ghc to do this) -- is this easy to do in ghc, or is it spread all over the palce?
12:13:44 <siyahband> ok i am trying
12:13:58 <fmapE> and when I tried to run it it would start yelling line numbers for where I need to implement stuff
12:15:28 <Twey> accel: Might have more luck in #ghc
12:15:31 <kmc> accel, GHC has an API you can use
12:15:39 <kmc> also some people were working on the "GHC Plugins" feature
12:15:50 <fmapE> kmc: AUGH the GHC API
12:15:58 <fmapE> it's even "documented"
12:16:03 <kmc> also you can make GHC dump its Core representation in an external format
12:16:08 <kmc> and i think even read it back in somehow
12:16:18 <fmapE> doesn't mean the documentation helps
12:16:27 <kmc> there are Haskell compilers which have their own frontend and then feed Core into GHC to use its backend
12:16:41 <kmc> siyahband, don't PM random people from the room
12:16:49 <kmc> siyahband, you should ask a question
12:16:51 <siyahband> alright
12:17:19 <accel> Twey, kmc: nice; thanks
12:17:40 <kramble> does someone know why haddock give me an html with method order changed ?
12:17:59 <fmapE> kramble: do you have explicit module exports?
12:18:04 <mzero> it follows your explicit exports
12:18:05 <kramble> yes
12:18:16 <fmapE> then it will use the order of those instead of the order of your definitions
12:18:23 <mzero> consider that your "organizing what is public about this module" section
12:18:40 <accel> why is #ghc silent compared to #haskell ?
12:18:59 <fmapE> accel: Because the only people that generally hang out in #ghc are ghc devs
12:19:12 <kmc> accel, why are there more GHC users than GHC developers?
12:19:15 <mzero> because the JUST got 7.0.2 out the door and they are all out at the pub
12:19:21 <accel> are they also the ones I've pissed off asking for ops in #haskell ?
12:19:25 <kramble> mzero: it's just my order of exprot was incorrect and i didn't notice, so i didn't understand haddock order
12:19:25 <kramble> but thx for the explanation
12:19:39 <kmc> accel, always thus to trolls
12:20:10 <mzero> kramble - you can use that area to organize your module into sections, and to reference blocks of doc that start the section 
12:20:20 <gwern> @quote
12:20:20 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
12:20:56 <kramble> mzero: i will test that, but for now i'm readin the haddock manual in order
12:21:04 <kleinucopia> I want to (essentially) map a function over a list, but the function needs to see the element before the element it gets as an argument to decide. I figured turning the list into pairs of adjacent entries would be what I want, but I am not so sure.
12:21:14 <accel> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html <-- holy shit; I can specify rewrite in the source code?
12:21:23 <kmc> yes
12:21:33 <accel> why did RWH not tell me this?
12:21:37 <accel> where is all this balck magic documented?
12:21:39 <kleinucopia> is there something that might be more idiomatic than a lot of list munging?
12:21:39 <accel> I want thi sknowledge
12:21:49 <kmc> accel, start with the manual you just linked
12:22:08 <kmc> RWH did not tell you this because it's an advanced topic, and RWH doesn't claim to be a comprehensive guide to everything GHC can do
12:22:12 <mzero> klienucopia -- exactly!  
12:22:27 <monochrom> accel: you could use a less provocative tone and attitude
12:22:38 <accel> monochrom: what do you mean?
12:22:48 <kmc> accel, the RULES feature is intended for developers of core libraries, which is probably why nobody bothered to tell you
12:22:59 <monochrom> such as "why did RWH not tell me this?"
12:23:09 <kmc> you should use it if you like, but that's the reason
12:23:12 <kleinucopia> mzero: what I mean is, is there something closer to "map foo xs" instead of do xs <- pairwise xs; etc. etc. etc.; return ys
12:23:22 <accel> monochrom: how should I rephrawe that as?
12:23:29 <kmc> accel, it's a popular IRC question strategy to insult the thing you want help with
12:23:34 <kmc> so that people will run to its defense
12:23:39 <ClaudiusMaximus> :t zipWith
12:23:40 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:23:42 <accel> kmc: exactly :-)
12:23:42 <kmc> but it's unusually ineffective here
12:23:48 <accel> kmc: oh, why not?
12:24:00 <monochrom> if you fix up your attitude, in fact the question shouldn't even be asked
12:24:10 <kmc> accel, because we don't tolerate trolls
12:24:13 <mzero> > let bumpAfterEven a b = if even a then b + 1 else b; mapLookingBack f es = zipWith f es (tail es) in mapLookingBack bumpAfterEven [ 2, 10, 7, 1, 3, 5, 7, 8, 10, 2 ]
12:24:14 <lambdabot>   [11,8,1,3,5,7,8,11,3]
12:24:23 <monochrom> unreasonable to expect RWH to have absolutely everything you want to begin with
12:24:40 <kmc> and because the non-troll members try to be extra friendly, so we can easily tell when jerks show up
12:24:59 <kleinucopia> mzero: ok, so I was on the right track
12:25:00 <hpaste> age pasted "boolean functions"  http://hpaste.org/44495
12:25:06 <age> Hello! I'm new to Haskell and have two questions. First: can someone comment my little piece of code? [paste follows]. Second: is there a way to convert following imperative code to functional style without defining a bunch of functions? [paste follows]. 
12:25:17 <age> Oh, the paste actually preceeds.
12:25:41 <kmc> age, the way to convert imperative code to functional is to think about what your code actually means, and then throw out most of the irrelevant details that imperative programming has forced on you
12:25:54 <monochrom> anyway, some of your questions have reasonable content but bad tone, and some other questions have unreasonable content and shouldn't even be asked except as clearly-marked jokes
12:26:11 <kmc> age, Haskell is also a fine language for imperative programming, but that's probably not what you're trying to learn as a beginner
12:26:20 <aristid> @remember kmc the way to convert imperative code to functional is to think about what your code actually means, and then throw out most of the irrelevant details that imperative programming has forced on you
12:26:20 <lambdabot> I will never forget.
12:26:25 <confound> age: (\a b -> a && not b)
12:26:33 <confound> age: you don't need to give it a name.
12:26:35 <aristid> lambdabot: let us hope that you will not
12:26:36 <accel> hmmm
12:26:41 <jix> age: instead of using let foo a b = bar in foo nested in the fold I'd use a where foo a b = bar .. or what confound said
12:26:49 <bla123> mzero: thanks for being online, your nick name solved my question before asking it!
12:26:51 <age> Oh yay
12:26:54 <aristid> @pl (\a b -> a && not b)
12:26:55 <lambdabot> (. not) . (&&)
12:27:13 <age> But isn't let clearer?
12:27:26 <accel> so basicaly, the ideal strategy for asking questions in #haskell is to wonder "what would a decent human being do?" and ask the question in that manner?
12:27:38 <djahandarie> age, I'm not sure if andNot is much clearer than a && not b
12:27:46 <djahandarie> It is a stylistic choice though.
12:27:48 <age> I just got an idea on my imperative code, but I will paste anyway http://codepad.org/1S0RQTpX
12:28:07 <mzero> bla123: I aims to please
12:28:13 <accel> is that haskell code?
12:28:18 <age> no
12:28:41 <bla123> accel: why think about strategy, people are very kind and responsive here, just ask what you want to know
12:28:46 <age> that is Ruby code. all x/y are boolean, ri/ma/pi are functions
12:30:41 <confound> age: 'single' is just /=
12:31:13 <age> oh?
12:31:29 <age> I see now.
12:32:05 <fmapE> random question
12:32:09 <kmc> random answer: 4
12:32:23 <fmapE> if I'm importing a module that defines a class instance
12:32:33 <fmapE> can I import that module hiding a member function of that class
12:32:54 <aavogt> @faq gives the right answer here!
12:32:55 <lambdabot> The answer is: Yes! Haskell can do that.
12:32:55 <fmapE> so for instance import Control.Monad.State hiding ( liftIO )
12:33:03 <kmc> iirc the class members are imported where the class is imported, not the instance
12:33:07 <fmapE> ok
12:33:13 <fmapE> so I'd have to hide the whole class
12:33:14 <confound> age: and the notOr one is just x || (True `elem` xl)
12:33:27 <confound> or something
12:33:28 <kmc> fmapE, i think you can import a class with only some of its methods
12:33:35 <kmc> or you can import qualified
12:33:45 <fmapE> well I don't wanna import the whole damn module qualified
12:33:47 <aavogt> class methods are regular functions with respect to imports
12:33:53 <fmapE> no reason to
12:33:58 <fmapE> aavogt ok thanks
12:35:08 <confound> age: so, you can use \ to make it slightly less wordy, or @pl to make it even less wordy, or refactor the algorithm to remove maximum wordiness :)
12:35:13 <age> confound: noted. I currently do not understand that code, but will sure try
12:35:29 <confound> which code?
12:35:38 <age> the notOr one
12:35:44 <age> anlso, what's pl ?
12:36:03 <confound> @pl (\a b -> a && not b)
12:36:03 <lambdabot> (. not) . (&&)
12:36:07 <confound> (from aristid, earlier)
12:36:45 <confound> age: your pierceArrow function doesn't need to compare elements to each other, because it actually only cares if they're true.
12:37:00 <age> So it's a very short way to denote a function?
12:37:19 <confound> @pl (\a b -> a && not b)
12:37:20 <lambdabot> (. not) . (&&)
12:37:20 <confound> er
12:37:23 <confound> http://www.haskell.org/haskellwiki/Pointfree
12:37:48 <aristid> age: sometimes, @pl makes functions longer.
12:38:10 <aristid> @pl \_ _ a _ b _ -> a b
12:38:10 <lambdabot> const (const (const . (const .)))
12:38:22 <aristid> @pl \c _ a _ b _ -> c a b
12:38:22 <lambdabot> const . ((const . (const .)) .)
12:38:37 <age> Oh
12:38:39 <confound> age: it's just a different way of writing functions that takes advantage of automatic currying. sometimes (often) it's clearer than using explicit arguments.
12:38:44 <aristid> @pl \c _ a _ b _ -> c (a b)
12:38:44 <lambdabot> const . ((const . (const .)) .) . (.)
12:39:30 <age> bookmarked, will read
12:40:33 <age> confound: so pierceArrow can just be something like "not maximum xl" ?
12:40:35 <bla123> confound: in my experience: if pl generated it, it is usually shorter, but more obfuscated
12:40:46 <confound> age: maximum? no
12:41:03 <confound> age: and, I misread it. pierceArrow = elem True
12:41:37 <confound> or pierceArrow xl = True `elem` xl if you would like to write it that way
12:41:51 <exlevan> or pirxeArrow = or ?
12:41:53 <djahandarie> bla123, in my experience it's usually longer and more obfuscated.
12:42:12 <aavogt> @check \xl -> (True `elem` xl) == any xl
12:42:12 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:42:18 <kmc> in my experience @pl is a good source for learning tricks
12:42:26 <aavogt> @check \xl -> (True `elem` xl) == or xl
12:42:26 <lambdabot>   "OK, passed 500 tests."
12:42:33 <bla123> djahandarie: :D that means that you're better than me at putting it into point-free style manually
12:43:09 <confound> exlevan: yeah, good point :)
12:43:14 <aavogt> missed exlevan's point
12:44:02 <confound> I didn't know about or
12:44:07 <confound> which feels like a ridiculous thing to type.
12:44:40 <Twey> Heh
12:44:49 <exlevan> what's pierce arrow, anyway?
12:44:50 <Twey> There's also ‘and’
12:45:26 <Twey> And ‘any’ and ‘all’, which are the more general versions
12:45:29 <age> exlevan: a boolean function, revense or
12:45:46 <Twey> NOR?
12:46:03 <age> yep
12:46:34 <confound> oh, then I got it backwards
12:46:59 <age> is there any prettyprinting in ghci?
12:48:24 <confound> what do you want to pretty-print?
12:48:25 <waern> any students interested in a Haskell internship in the south of France? :-)
12:48:26 <kramble> what is the interest of -- >>> in haddock ?
12:48:41 <waern> kramble: examples/unit-tests
12:48:43 <monochrom> every data type enjoying a Show instance is pretty-printed, namely by the Show instance code.
12:48:45 <age> confound: a list ?
12:48:56 <monochrom> oh oops, that doesn't count as pretty-printing
12:49:00 <kramble> waern: but it doesn't appear in the generated documentation
12:49:08 <confound> age: return it from something?
12:49:14 <waern> kramble: it doesn't? it should!
12:49:17 <aavogt> @hackage IPPrint
12:49:17 <lambdabot> http://hackage.haskell.org/package/IPPrint
12:49:29 <aavogt> http://hackage.haskell.org/package/ipprint
12:49:31 <kramble> waern: i do test it again to check
12:49:44 <monochrom> ghci pretty-print your code when your code is engaged in error messages. :)
12:49:47 <waern> kramble: you have to be using a fairly recent Haddock
12:50:01 <kramble> waern: the one from haskell platform
12:50:37 <monochrom> admittedly haskell platform's haddock version is old
12:51:05 <waern> kramble: latest platform? That should work
12:51:18 <waern> that's Haddock 2.7.2
12:51:36 <kramble> waern: it's strange, if i put just the line >>> putStrLn "Hello\r\n"
12:51:43 <kramble> something apperas at bottom of doc
12:51:59 <kramble> but if i add a line -- Hello (like i saw in haddock doc) nothing appear
12:52:44 <bla123> isn't it awkward that "fail" of Monad takes a string argument? is has no meaning in the Maybe or List context
12:53:04 <bla123> if someMaybe == fail "" then ...
12:53:13 <Twey> fail is a hack
12:53:16 <Saizan> it's akward that fail is in Monad
12:53:17 <Twey> Everything about it is awkward
12:53:27 <bla123> then why do we have it?
12:53:37 <kramble> every single line of code can fail, so why not a fail in the monad
12:53:49 <Twey> Because the designers of do-notation needed some way to customisably fail in case of pattern-match failures
12:54:28 <Twey> It's widely regarded as a wart
12:54:38 <bla123> Twey: then what about using a derived type class for do notation and keep the monad type class clean?
12:55:00 <waern> kramble: http://code.haskell.org/haddock/tests/html-tests/tests/Examples.hs <- how to use it
12:55:01 <Twey> bla123: That's one solution that has been proposed
12:55:07 <kmc> age, "groom" is another alternative to ipprint
12:55:07 <kmc> bla123, it's not expected that you ever call "fail" yourself
12:55:07 <kmc> it's used by the desugaring of "p <- xs" where p is a non-trivial pattern
12:55:08 <kramble> i see many tutorial on monads wich used fail
12:55:10 <olsner> so... ugly :( pattern-match failures in lambdas are in the same situation but weren't considered to need a way to customisably fail, for some reason
12:55:10 <Twey> (more specifically, splitting fail off into a MonadFail class or the like)
12:55:32 <kmc> i'll admit that customizing pattern-match failure is quite useful for some monads
12:55:33 <Twey> bla123: We're shackled by tradition and backwards-compatibility, though
12:55:43 <kmc> but i'd rather it impose an extra class constraint
12:55:49 <Twey> Maybe we'll get a nicer solution some day.
12:56:31 <olsner> maybe "first-class" pattern matching would be able to make the failure handling explicit in some clean way
12:56:35 <monochrom> pattern-match failures in lambdas already have "error"
12:56:51 <kramble> waern: it does unit testing ?
12:57:05 <Saizan> there was a nicer solution before, but got dropped for the sake of simpler desugaring
12:57:08 <waern> kramble: there's another program "doctest" which does the testing
12:57:11 <bla123> Twey: sry, i don't get it: why do i need a way to fail in the case of a pattern match failure?
12:57:13 <Twey> kramble: Tutorials using fail should probably use MonadZero, instead
12:57:40 <kramble> waern: because i see thing son my console when i use haddock, but nothing in the generated doc in html format
12:57:45 <Twey> bla123: Because otherwise a pattern-match failure is a fatal error, which is not very useful for many types of monads that could fail gracefully
12:57:52 <Twey> (e.g. Nothing, Either)
12:57:54 <kmc> bla123, say i'm doing list-monad nondeterministic computation
12:57:55 <monochrom> > do { Just x <- [Nothing, Just 1, Nothing]; return x }
12:57:56 <lambdabot>   [1]
12:57:58 <Twey> Er
12:57:58 <kmc> i might write (x:y:xs) <- ys
12:58:03 <Twey> Maybe, Either
12:58:08 <waern> kramble: try upgrading Haddock if you can't get it to work. If that fails, please file a ticket at trac.haskell.org/haddock
12:58:10 <kramble> Twey: some should have restrain themselves from writing monad tutorial
12:58:14 <monochrom> similarly list comprehension and monad comprehension
12:58:20 <bla123> Twey: i thought of that, but that means an additional constraint on the type that seems unnecessary ... or should fail belong to MonadZero anyway?
12:58:26 <Twey> kramble: Probably true :þ
12:58:31 <kramble> waern: I don't even know if it fail or succeed
12:58:34 <kmc> it's nice if this simply gives up on any nondeterministic branch where ys has less than 2 elements
12:58:43 <Twey> bla123: fail shouldn't belong to MonadZero, but it probably should belong to a different class
12:58:45 <waern> kramble: if you can't see it in the html output, it fails :-)
12:58:50 <Twey> I think MonadFail is the proposed name
12:59:01 <hpaste> hipmunk pasted "hipmunk"  http://hpaste.org/44496
12:59:05 <kramble> waern: ok i gonna submit an issue
12:59:05 <Twey> MonadZero doesn't take failure information of any type, unlike fail
12:59:16 <waern> kramble: please try the latest version of Haddock first
12:59:30 <kramble> waern: haskell platform has version 2.6.1
12:59:51 <kramble> i dl HP again
13:00:17 <waern> kramble: ok, good
13:00:21 <waern> http://hackage.haskell.org/platform/changelog.html
13:00:26 <monochrom> haskell platform 2010.2.0.0 has haddock 2.6.1
13:00:39 <kramble> and the version of haddock today is ?
13:00:48 <bla123> so you would still recommend testing for mzero instead of (fail ""), even though this adds another type constraint?
13:00:50 <monochrom> at least 2.7, probably 2.8
13:01:09 <kmc> bla123, why do you need to test for it?
13:01:14 <waern> monochrom: oh, that doesn't match the changelog...
13:01:26 <kmc> bla123, monads aren't guaranteed to have (==) even
13:01:31 <kramble> haskell platform is late ?
13:01:32 <monochrom> the changelog is a futuristic version of haskell platform
13:01:50 <waern> heh, yeah I can see that now
13:02:04 <waern> kramble: you have to do: cabal install haddock
13:02:10 <bla123> kmc: in the case of a failure i want to execute some different code
13:02:18 <kramble> waern: it fails becaus ghc seem too old
13:02:21 <kmc> bla123, and you're doing this in a way which is generic over all Monads?
13:02:23 <mreh> what's the parsec combinator for parsing one out of a choice of tokens?
13:02:38 <monochrom> probably called "choice"
13:02:44 <waern> kramble: which GHC version do you have?
13:02:53 <kramble> 6.12.3
13:03:03 <kramble> but i'm checking that i got last haskell platform version
13:03:05 <bla123> kmc: to be honest, the only use that i see for it now is to be able to use Maybe or List
13:03:23 <mreh> monochrom: I thought that, but I thought there was a shorthand
13:03:29 <mreh> that's for a choice of parsers, not tokens
13:03:56 <waern> kramble: ok. You can try: 'cabal install haddock-2.8.1'. That should work with your ghc and have support for >>>
13:04:23 <mreh> isn't there a parser built from a predicate?
13:04:27 <mwc> Damnit, who released 7.0.2 today? I just finished rebuilding all my .cabal stuff on 7.0.1 this morning :)
13:04:47 <bla123> kmc: run some function, return it's value if it worked, otherwise return some other value ... i basically need a more generic version of the "maybe" function
13:04:56 <kmc> *nod*
13:05:17 <bla123> is there anything like that?
13:05:35 <monochrom> if your token is Char, there is oneOf. if your token is something else, you may steal the code of oneOf.
13:05:43 <kramble> waern: if i want last ghc can i do cabal install ghc ?
13:05:53 <kramble> (don't like to have old compilers)
13:06:05 <mreh> monochrom, yah, that one!
13:06:41 <monochrom> satisfy takes a predicate but is for Char only
13:07:03 <mreh> monochrom: seems strange
13:07:30 <monochrom> not strange because for a long time Parsec was used for [Char] only
13:08:05 <mreh> I'm parsing PGM, I thought bytestring would be more appropriate
13:08:19 <mreh> shame
13:09:13 <monochrom> with bytestring input and parsec-3, token is still Char and you still use those Char parsers such as satisfy and oneOf
13:09:45 <mreh> gosh
13:09:54 <mreh> is Char some kind of type alias?
13:10:05 <monochrom> no
13:10:25 <monochrom> if you want token to be Word8, steal some code from oneOf and satisfy
13:10:58 <kramble> waern: yes it works with the version of haddock you suggested, thx
13:11:00 <mreh> well, PGM uses a parametric word length
13:11:09 <monochrom> oh fun :)
13:11:28 <mreh> monochrom: it get's better, it depends on the first few bytes
13:11:45 <mreh> i think i might give up
13:11:53 <mreh> I only wanted to read in some images
13:12:43 <mreh> how do you use code when you don't know the type until execution time?
13:13:26 <mreh> I suppose that's the definition of polymorphism
13:13:37 <monochrom> by re-drawing the boundary between "type" and "data"
13:14:16 <kmc> mreh, for PGM i would just cast up to Word16
13:14:44 <kmc> the other solutions are clunky like
13:14:46 <hpaste> age pasted "s2b"  http://hpaste.org/44497
13:14:51 <waern> kramble: great!
13:15:02 <age> What am I doing wrong in that paste?
13:15:03 <kmc> data PGM = PGM8 (Array (Int,Int) Word8) | PGM16 (Array (Int,Int) Word16)
13:15:04 <kramble> now i'm trying to build last ghc
13:15:15 <kmc> or data PGM t = PGM (Array (Int,Int) t), with then an existential over t
13:15:31 <monochrom> delete "schemeToBinary l = [schemeToBinary e | e <- l]". dead code.
13:15:37 <mreh> kmc: yeah I tried existentials a few weeks ago, didn't grok them properly
13:15:45 <kmc> mreh, they're probably not the right solution here
13:15:46 <mreh> that's the big E existential
13:15:48 <age> monochrom: but I want to get a list
13:15:54 <kmc> i can explain stuff about them anyway
13:16:01 <mreh> backwards E, not existentialism
13:16:03 <monochrom> you won't get a list if your function takes a boolean.
13:16:14 <age> as in [True, False] => [1,0]
13:16:17 <age> hmm.
13:16:39 <mreh> I'm still not getting how the Char combinators can be used to parse Int8s
13:16:56 <monochrom> type Bool is not type [Bool]. there is no subtype relation either.
13:16:57 <mreh> Word8 rather
13:17:12 <kmc> ∃
13:17:17 <age> I fixed that.
13:17:21 <kramble> monochrom: you can embeded one into another with a functor
13:17:38 <kramble> so bool could be considered as a subtype of [Bool]
13:17:39 <monochrom> beside the point
13:17:49 <age> yay, works
13:17:49 <kramble> :)
13:18:03 <monochrom> the point is this is haskell 98 code not flexible human mathematics
13:18:31 <kramble> it would be great if we could use functor implictly
13:18:39 <kramble> (no no it's a joke)
13:19:07 <kramble> (but if we specify wich functor we're using it could be great)
13:19:10 <c_wraith> So, this SpecConstr in GHC 7 warning is kind of silly
13:19:18 <c_wraith> err, move warning over a couple words.
13:19:26 <Studley> I'm working through the 99 haskell questions, and I have to say
13:19:30 <Studley> I think I like this language
13:19:32 <Studley> a lot
13:19:35 <c_wraith> It's basically saying "this could be optimized more, if you increased that value".
13:19:41 <kramble> Studley: gimme the link please
13:19:41 <c_wraith> That's an odd thing to emit a warning about
13:19:48 <Studley> http://www.haskell.org/haskellwiki/99_questions/1_to_10
13:19:52 <kramble> thx
13:19:52 <mreh> @instances functor
13:19:52 <lambdabot> Couldn't find class `functor'. Try @instances-importing
13:20:00 <mreh> @instances Functor
13:20:01 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
13:20:17 <Studley> I just started. I'm on #5
13:20:39 <kmc> Studley, what languages have you used before?
13:21:01 <Studley> kmc: Mostly just QBasic and some C/C++
13:21:20 <kmc> saying "C/C++" is like saying "motorcycle / fighter jet"
13:21:27 <Studley> Oh, and BF
13:21:40 <Twey> Or ‘motorcycle/motor home’
13:21:41 <companion_cube> Studley, did you try LYAH ?
13:21:41 <Studley> heh
13:21:47 <Zao> I have a Dog/Cat.
13:21:48 <kmc> hehe Twey
13:21:56 <kramble> C++ is just C with template and objects
13:21:58 <Studley> Just C++, then
13:22:01 <kramble> and rewrite rules and...
13:22:13 * hackagebot AspectAG 0.3.1 - Attribute Grammars in the form of an EDSL  http://hackage.haskell.org/package/AspectAG-0.3.1 (MarcosViera)
13:22:22 <monochrom> J/Java/Javascript
13:22:22 <Studley> Question #5 is incredibly easy.
13:22:26 <mwc> Twey: I prefer motorcycle/SSBN, since the latter has so many more ways of exploding
13:23:13 <Twey> Touché
13:23:28 <kramble> coulé
13:23:31 <Studley> companion_cube: Yeah, I was looking through that. There didn't seem to be any problems, though
13:23:34 <kmc> C++ is just C with templates, classes, inheritance, references, a second memory management system, more implicit conversions, operator overloading, exceptions, const, new casts, RTTI, and a totally different huge standard library
13:23:44 <Studley> I don't learn well when I'm just looking at the language. I have to actually try it.
13:23:51 <kramble> kmc: references isn't the same thing as pointers ?
13:23:55 <kmc> kramble, not at all
13:24:01 <kmc> they are similar and you might question the need for both
13:24:02 <kramble> what's the diff ?
13:24:06 <kmc> kramble, read a C++ book
13:24:08 <Twey> They're Magic Pointers
13:24:12 <kmc> read the C++ FAQ Lite
13:24:17 <kramble> for me ref is just an ugly hack to hide a pointer
13:24:24 <kmc> kramble, you'll find that C++ usually has two slightly different, slightly incompatible ways to do anything
13:24:29 <Twey> They are, but subtly incompatible.
13:24:38 <monochrom> no, pointer is an ugly hack to expose a reference
13:24:38 <chrisf|work> kmc: only *two*? you're kind.
13:24:41 <kmc> one a carryover from C and one a bit of C++itude which is useless unless you drink the koolaid wholesale
13:24:44 <kramble> can i cat a ref into a pointer ?
13:24:49 <kramble> can i cast a ref into a pointer ?
13:24:56 <Twey> monochrom: These ideas are not mutually exclusive
13:24:57 <companion_cube> J/Java/Javascript <=== very funny, monochrom :D
13:25:00 <kmc> yes kramble
13:25:07 <kramble> and ref to a pointer ?
13:25:10 <jix> kramble: you can get a pointer from any ref, but you can only get a ref from a pointer if it is valid to dereference the ptr
13:25:24 <kramble> jix: so ref = pointer without null value ?
13:25:37 <kramble> (i know there is also a syntax hack wich allow writing without *)
13:25:48 <jix> kramble: yeah and you can't reassign refs IIRC
13:25:55 <kmc> kramble, do you want to use references in your classes? better initialize them in the constructor because they're not first class.  so now you have to use ctors too.  but what if initialization might fail?  now you have to use exceptions too
13:25:55 <kramble> IIRC ?
13:25:58 <chrisf|work> it is also possible to obtain a null reference.
13:25:58 <kmc> that's how they get you
13:26:18 <jix> kramble: if I remember correctly
13:26:27 <kramble> kmc: sorry i do C++ very few, never play with it
13:26:31 <chrisf|work> but it requires some subtle magic.
13:26:32 <jix> chrisf|work: sure it's not undefinde behaviour?
13:26:33 <kmc> the null reference is only sort of a thing
13:26:41 <kramble> but when two things are castable into another i rather use the larger
13:26:58 <kramble> (i never use [] in c except local variable to economize one pointer, i always use *)
13:27:48 <kmc> anyway C++ is a huge mess of complexity many times larger than C
13:27:53 <chrisf|work> the problem with c++ is you MUST hold a huge volume of this subtle crap in your head at all times to avoid shooting yourself in the foot in bizarre ways.
13:27:58 <kmc> yes.
13:28:02 <mreh> > show $ (toEnum 255 :: Word8)
13:28:03 <lambdabot>   "255"
13:28:14 <kmc> i feel you can write clean C++ if you mostly use only C features, and you can write clean C++ if you understand the entire gigantic language very well
13:28:21 <mreh> > show $ (toEnum 256 :: Word8)
13:28:22 <lambdabot>   "*Exception: Enum.toEnum{Word8}: tag (256) is outside of bounds (0,255)
13:28:32 <kmc> but most C++ code in the wild falls in the terrible valley between those two points
13:28:34 <chrisf|work> kmc: and the middle ground is bloody dangerous ;)
13:28:50 <kmc> and even when you master C++ and can do all these incredible things
13:29:00 <kramble> what look nice in C++ is the fact that you can redefine '(' operator on objects and use them like function (never test, a friend of mine said me that)
13:29:09 <kmc> then you realize you wrote a 2000 line library to emulate some trivial feature from Haskell or Python
13:29:11 <companion_cube> it () operator
13:29:13 <chrisf|work> you can define operator ().
13:29:13 <kmc> see: half of boost
13:29:21 <kmc> kramble, that's pretty superficial
13:29:31 <monochrom> the most emulated haskell feature is lazy evaluation
13:29:35 <kmc> not a big deal if you type x() or x.call()
13:29:38 <kramble> kmc: i dream about a language wich is only rewrite rules
13:29:48 <jix> kramble: pure?
13:29:52 <companion_cube> rule number something: every complicated enough C program includes a buggy and  slow implementation of half of common lisp
13:29:54 <kramble> jix: what ?
13:30:03 <companion_cube> that must be right for C++ either
13:30:07 <jix> kramble: http://code.google.com/p/pure-lang/
13:30:30 <kramble> jix: thx for the link, gonna look this weekend
13:30:39 <Twey> companion_cube: Greenspun's Tenth
13:30:48 <kmc> companion_cube, i implemented the Y combinator in C++ once
13:30:50 <chrisf|work> kmc: it's superficial, but operator() is essential for templated algorithms that can take a function or a function object
13:30:51 <kramble> jix: can i change rewrite rules during run ?
13:31:00 <kramble> can i rewrite the rules with rewrite rules ?
13:31:07 <kmc> chrisf|work, yep.  another pair of not-quite-equivalent things
13:31:23 <jix> kramble: I'm not sure. I haven't really used it.
13:31:32 <kramble> jix: ok
13:31:58 <kmc> each C++ feature is a bad decision which looks good in context of all the other bad decisions
13:32:04 <kramble> but if one day there is language which permit easily to rewrite binary code while running, we could have really fast program
13:32:25 <kmc> kramble, that sounds like a tracing JIT compiler, and not like a particular language
13:32:38 <kramble> kmc: ???
13:32:39 <kmc> the best JavaScript and Lua VMs today work that way
13:32:40 <chrisf|work> kramble: see many modern VMs; and in user code you dont want to do it.
13:32:54 <kramble> chrisf|work: ???
13:33:00 <kmc> and you can do the same for traditionally static languages like Haskell or even unadorned machine code that came out of another compiler
13:33:03 <monochrom> kramble probably means self-modifying programs, i.e., programmer not RTS specifies the rewrites.
13:33:13 <kmc> but... that's terrible
13:33:14 <kramble> monochrom: yes exactly
13:33:18 <kramble> kmc: no it's future
13:33:24 <chrisf|work> self-modifying code is hardly a great idea on modern boxes.
13:33:24 <kramble> really fast program
13:33:28 <monochrom> I denounce self-modifying programs altogether.
13:33:34 <kramble> but developper must be really good :D
13:33:35 <napping> why?
13:33:53 <tolkad> In ghc, do default function definitions in classes get specialized for each instance? if they contain references to other class functions is there a possibility of those functions being inlined?
13:34:14 <kramble> napping: the question is for me ?
13:34:24 <monochrom> one reason (among many) to denounce self-modifying programs, equivalently to separate program from data: security
13:34:25 <tolkad> In ghc, do default function definitions in classes get specialized for each instance? if they contain references to other functions of the same class is there a possibility of those functions being inlined?
13:34:34 <chrisf|work> napping: fapping around with the virtual memory system burns up whatever advantage you got, and some.
13:34:36 <tolkad> (fixed an ambiguity)
13:34:36 <kramble> monochrom: except if you prove your compilator
13:34:42 <Heffalump> monochrom: so you don't like shells then?
13:34:56 <chrisf|work> (11:10:37 AM) chrisf|work: napping: fapping around with the virtual memory system burns up whatever advantage you got, and some.
13:35:00 <kmc> the Linux kernel uses self-modifying code for some specific reasons
13:35:12 <kmc> they have clever people to do so and have put a lot of work in
13:35:13 <napping> virtual memory system?
13:35:19 <napping> okay, maybe I'm missing some context.
13:35:21 <monochrom> well, I don't like a word processor acting like an os
13:35:36 <kmc> it makes sense to do these things in very core stuff like the kernel or libc
13:35:43 <kramble> or in 3D games
13:35:46 <bla123> the TH docs contain some code snippet that i cannot get to work in GHC 6.12.3 and 7.0.2: http://haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH-Syntax.html#t:Name  (1. snippet, the dollars in the quotation, is this valid syntax?)
13:35:46 <kmc> and in very specialized applications
13:35:47 <kramble> which need power
13:35:58 <chrisf|work> kramble: do you write 3d games?
13:35:59 <kmc> kramble, i don't think 3D games are the absolute cutting edge of power anymore
13:36:01 <monochrom> "you can add arbitrary programs, not just data, to your *.doc files!" the greatest scheme to propagate viruses.
13:36:06 <kmc> and they're developed by huge teams
13:36:09 <napping> What's the difference between a JIT and a slf-modifying code?
13:36:18 <kramble> monochrom: virus is a poor reason
13:36:20 <kmc> kramble, try scientific simulations or high-frequency financial trading strategies
13:36:31 <mreh> > isSpace "\n"
13:36:31 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:36:32 <lambdabot>         against inferred type...
13:36:35 <kramble> one day security on OS will be designed correctly and the will never be viruses
13:36:38 <kmc> the latency requirements of HFT are two-three orders of magnitude stricter than 3D gaming
13:36:41 <mreh> > isSpace '\n'
13:36:41 <lambdabot>   True
13:36:48 <tolkad> what's wrong with self-modifying code? I know a little bit of assembly and it seems like you'd be able to save a lot of clock cycles with self modifying code
13:37:01 <kmc> tolkad, it's hard to write...
13:37:01 <kramble> tolkad: ha you agree with me :)
13:37:07 <napping> tolkad: it takes a few cycles to get everything into L1
13:37:10 <kmc> hard to test
13:37:10 <pozic> kmc: do you work in HFT?
13:37:21 <kramble> kmc: we must not test it, but prove it
13:37:23 <mreh> that's a premature optimisation
13:37:28 <kramble> if it's proven we don't have to test
13:37:30 <chrisf|work> tolkad: and blow your L1, your TLB, and your branch predictor?
13:37:45 <tolkad> uh unfortunately I kind of only know very old assembly
13:37:54 <napping> how does it bother the TLB?
13:38:04 <kramble> chrisf|work: we can do few changes, like avoid some redirection
13:38:04 <tolkad> Does L1 refer to the register set?
13:38:05 <kmc> pozic, i did
13:38:08 <monochrom> I'm fine if you can prove correctness. if.
13:38:12 <napping> tolkad: separate instruction and data caches
13:38:26 <napping> monochrom: the FLINT group has some good papers on that
13:38:34 <pozic> kmc: why did you stop?
13:38:37 <chrisf|work> it is useful in very limited cases.
13:39:01 <kmc> pozic, long story
13:39:07 <kramble> chrisf|work: you can change resolution of game and avoiding the indirection cost
13:39:18 <kramble> am i in 32bpp or 24bpp or ....
13:39:22 <mjrosenb> if i currently have Data.Map imported qualified as M, do i access ! as M.(!)L
13:39:22 <lambdabot> mjrosenb: You have 1 new message. '/msg lambdabot @messages' to read it.
13:39:26 <kramble> do hardcoded loop
13:39:32 <chrisf|work> kramble: noone cares about that. the hardware does it.
13:39:32 <tolkad> is it possible to modify the instruction cache directly? I've never written assembly for a processor with an instruction cache
13:39:32 <kmc> mjrosenb, x M.! y
13:39:46 <chrisf|work> tolkad: no, it's automatic
13:39:49 <napping> out of that game for quite a long time then, huh?
13:39:50 <kmc> tolkad, usually not; the instruction cache is a transparent local copy of memory
13:39:55 <kramble> chrisf|work: does the program handles the resolution ?
13:39:59 <napping> Intel promises the icache will be updated after taking a jump
13:40:03 <kmc> on some architectures you have to explicitly flush the instruction cache if you write self-modifying code
13:40:04 <chrisf|work> except you want to flush it when you change the world behind it in ways it cant understand.
13:40:07 <napping> no promises on the latency, though
13:40:15 <chrisf|work> some architectures like x86 ;)
13:40:37 <napping> much much lighter than a full flush, though!
13:41:03 <napping> the story is a bit more complicated if one processor wants to write instructions for another to run, but that's rarer
13:41:05 <chrisf|work> if you had to futz around with the pagetables to play by w^x rules, you've got more cost too.
13:41:52 <kmc> tolkad, what processors have you written assembly for?
13:42:00 <tolkad> kmc: SPARC
13:42:10 <tolkad> kmc: and not much
13:42:15 <chrisf|work> kramble: in the grand scheme of things, specializing some loop for the screen size is just deeply uninteresting for today's games.
13:42:37 <kramble> chrisf|work: yes, i was not thinking about the loop for screen size
13:42:38 <tolkad> kmc: maybe there's a cache and I just hadn't heard of it
13:42:47 <kmc> tolkad, seems that every SPARC had an instruction cache
13:42:59 <tolkad> kmc: ah, I just didn't know of it then
13:43:07 <kmc> caches are *really* important to the performance of modern CPUs
13:43:11 <kmc> where by "modern" i mean "last 30 years"
13:43:12 <chrisf|work> tolkad: most of the time, you dont have to know its there.
13:43:22 <tolkad> Just thinking about how much larger the set of self modifying programs is compared to the set of non-self-modifying programs, and how much more convuluted they can be, it seems very intuitive to me that for certain programs they could be much faster.
13:43:30 <kmc> it is far more important to have good cache behavior than to shave off a few instructions
13:43:41 <kramble> it's when i read the code of the function drawpixel in the sdl http://www.libsdl.org/intro.en/usingvideo.html
13:43:47 <shlevy> Anyone know what's up with nixos.org and openquark.org (they're not related, as far as I can tell). I'm feeling cursed: I researched CAL for a few weeks and then the day I was ready to download it the site went down and it hasn't been back up since. And I was about to download an installer for Nixos when that stopped working too (it worked long enough for me to get to the documentation page, but the download link failed and now the who
13:43:48 <saml> what u talking about?
13:43:50 <kmc> instructions execute at 3 god damn billion per second, or better
13:44:09 <kramble> that i think about rewrite code during run
13:44:14 <kmc> a cache miss can cost you hundreds of cycles
13:44:43 <methods> I'm reading real world haskell but taking a break and playing around some demo code here but really confused on something here.. not sure if I could get some help when I'm clearly still getting my head around things
13:44:54 <kmc> tolkad, here's a specific case where self-modifying code makes sense: when you boot a modern linux kernel, it reconfigures itself in various ways according to the hardware you booted it on
13:45:09 <kmc> like if you have only one CPU it will use simplified uniprocessor locking code
13:45:15 <kmc> and actually it will do that dynamically as you hotplug CPUs
13:45:20 <chrisf|work> kramble: you'd try very hard to avoid calling that function ;)
13:45:44 <tolkad> kmc: uh the way I learned it was that memory access effectively takes 1 cycle because different steps of sequential instructions are executed simultaneously
13:45:51 <kramble> chrisf|work, the only solution i see is to build separate binaries, or rewrite code
13:46:03 <kmc> you learned wrong tolkad
13:46:04 <tolkad> kmc: perhaps that's an abstraction though
13:46:13 <tolkad> kmc: ah, must have been an abstraction then
13:46:17 <chrisf|work> or anything along those lines
13:46:42 <kramble> chrisf|work: i'm not sure to understand what you're saying
13:46:46 <chrisf|work> unless you were stuck without h/w acceleration at all
13:47:08 <monochrom> it was not an abstraction many many years ago
13:47:21 <methods> kmc does the kernel do that by simply loading modules ?
13:47:23 <kmc> tolkad, accessing memory is ~100 times slower than accessing cache
13:47:36 <kmc> methods, no, it rewrites the code of the core kernel and every loaded module at the instruction level
13:47:38 <monochrom> it is not an abstraction today if you s/memory/cache/
13:48:07 <methods> kmc yea how is that actually done ? i know various libraries do that instead of using and .so for speed.. but i never knew how
13:48:29 <kmc> methods, read about "altinstructions"
13:48:35 <tolkad> In ghc, do default function definitions in classes get specialized for each instance? if they contain references to other functions of the same class is there a possibility of those functions being inlined?
13:48:45 <kmc> basically each time you use a lock it writes (into a special linker section) the offset of the locking instruction it produced
13:48:53 <methods> kmc:  cool will do.. that's not really portable c though right ?
13:48:57 <kmc> oh hell no
13:49:18 <kmc> Linux is full of GCC extensions, inline assembly, linker hacks, and undefined behavio
13:49:21 <methods> yea but many projects do it even regular programs right ?
13:49:25 <kmc> dunno
13:49:53 <monochrom> regular programs aren't that insane yet.
13:49:58 <shlevy> Is there widely-used kernel that's written reasonably portably? Seems like at the kernel level you need to take advantage of the hardware
13:50:58 <kramble> ghc is really long to build
13:51:08 <methods> what was that wine fork that was focused on directx support ? 
13:51:31 <tolkad> for example, « class C a where { f :: a; g :: a; g = f } » <-- can f be inlined into g if the default definition is used? What does ghc do anyway if some polymorphic function is referenced? I'm guessing it treats it as a sort of implicit parameter?
13:51:34 <methods> cedega..
13:52:22 <kmc> kramble, yes.. why are you building it?
13:52:23 <methods> http://transgaming.com/business/swiftshader  pretty sure they used a technique like that to speed rendering 
13:52:30 <kramble> kmc: to got last version
13:52:37 <kramble> of course
13:52:38 <kmc> they don't have binaries up?
13:52:49 <tolkad> Are people not answering me because this isn't widely known? or am I not making sense?
13:52:54 <kramble> kmc: in fact i want to know if ghc is clean or not
13:53:00 <kramble> ocaml is very clean
13:53:08 <kramble> (not ocaml programs)
13:53:22 <tab> kramble: clean regarding what ?
13:53:23 <hpaste> kleinucopia pasted "deconstructArg"  http://hpaste.org/44498
13:53:48 <kleinucopia> in that paste, I show the error.
13:53:49 <kramble> tab: my first criteria is "does it build ?"
13:54:00 <monochrom> tolkad: just not widely known
13:54:13 <methods> kmc:  "runtime compilation techniques to dynamically build exactly the right code needed"
13:54:33 <kramble> tab: only 5% of programs i try to build in my life build correctly
13:54:36 <kleinucopia> can't the compiler deduce that I'm deconstructing the argument? Or would that be bad?
13:54:38 <napping> tolkad: that should be the sort of thing you can see in the core
13:54:46 <napping> also, -ddump-interface-file might help
13:54:54 <tab> kramble: you're either unlucky or have a complicated environment ;)
13:55:19 <kramble> tab: i always have a broken environment to check which programs are clean (no in reality I'm doomed)
13:55:20 <shlevy> Anyone used nix or nixos?
13:55:39 <monochrom> kleinucopia: f (S x y) = undefined
13:56:07 <kramble> tab: you don't imagine the amount of programs from cabal that doesn't build
13:56:18 <shlevy> kramble: I'm with you. It's scary how rare following the build instructions from the distributor just works
13:56:19 <tolkad> napping: thanks
13:56:28 <kleinucopia> monochrom: yes, but why can't the compiler decide that I'm deconstructing the argument in this case? Is the constructor not enough info?
13:56:59 <kramble> shlevy: the worst in my life was when i try to build firfox, i installed al lthe libraries but it fail
13:57:03 <kleinucopia> monochrom: I should mention that I'm a compiler noob who hasn't read the ghc source
13:57:23 <kramble> i succeed when I understand that condition >=1.2 on gtk doesn't mean that 2.0 >= 1.2
13:57:38 <shlevy> kramble: Ugh. building firefox is always the part I dread most when I build linux from scratch systems. X and xfce take time, but firefox is always a nightmare
13:58:00 <monochrom> you could write a parser that smart. you would become insane then.
13:58:17 <kramble> shlevy: the probem is they never want to give the libraries version they use
13:58:46 <kramble> everything is context unfree today, so it's really hard to port one code from machine to another
13:59:29 <shlevy> kramble: context unfree?
13:59:53 <tolkad> kramble: here's one of the cleaner parts of ghc. It's a good example of ghc compiler code: http://darcs.haskell.org/ghc/utils/parallel/template.pl
14:00:00 <monochrom> A parser that smart would have to be a strange loop interleaving a bit of parsing with a bit of type-checking ad infinitum.
14:00:23 <kmc> sounds like the perl parser
14:00:52 <monochrom> the human brain is such a strange loop, yes. the human brain has also been proven incomplete and inconsistent.
14:01:54 <methods> anyone think they can give me a hint for this ? https://gist.github.com/bd9dabfed5a4d777b165
14:01:58 <kramble> shlevy: the opposite of context free (but maybe it's a french expressionà)
14:02:02 <methods> still learning
14:02:02 <tolkad> monochrom: sounds like a problem you could fix with perl
14:02:15 <monochrom> haha
14:02:16 <kleinucopia> monochrom: if the parser assumed that the type declarations in its input were always correct, couldn't it build a table that it could check?
14:02:51 <kleinucopia> it would be multi-pass, perhaps, but the problem surely isn't incomputable
14:02:54 <kleinucopia> is it?
14:02:59 <kramble> tolkad: perl ont of the most unstable language
14:03:02 <kramble> :D
14:03:23 <kramble> .net with visual studio is really clean
14:03:27 <monochrom> like I said, <monochrom> you could write a parser that smart. you would become insane then.
14:04:10 * shlevy wonders how many mental wards are filled with parser-writers
14:04:23 <kleinucopia> monochrom: should we let the big-wigs know that there's an "insane" lurking in between "computable" and "incomputable"?
14:04:28 <aristid> shlevy: none?
14:04:42 <monochrom> the big-wigs already know. whoever they are.
14:05:14 <shlevy> kneinucopia: Which side of "intractable" is insane on?
14:05:50 <kleinucopia> shlevy: perhaps both
14:06:05 <kramble> with haskell it's really easy to write a parser
14:06:08 <tolkad> is it a good idea to use Parsec's OneOf with a 30,000 character long list?
14:06:31 <monadic_kid> partially applied IORef action argument vs value in a state monad which do you prefer? IORef would become local to that particular action because that is the aciton/function that cares about it plus I wouldn't have to keep adding values to record
14:06:38 <monochrom> no, oneOf takes time proportional to that list.
14:06:42 <ClaudiusMaximus> :t (=<<)
14:06:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:06:49 <ClaudiusMaximus> methods: ^^
14:06:54 <kleinucopia> Intuition dictates that some tractable things must be insane (perl). But if what monochrom says is true, it seems like there must be some more insanity at higher levels of computing difficulty.
14:07:15 <tolkad> monochrom: why can't it just read through the entire list and generate a tree?
14:07:24 <tolkad> monochrom: oh wait infinite lists, nevermind
14:07:40 <monochrom> programmer laziness. attoparsec does what you say.
14:08:22 <monochrom> don't worry about infinite lists for oneOf. not intended to work in the first place.
14:08:45 <shlevy> How often do y'all use infinite lists in non-toy programs?
14:08:51 <kramble> tolkad: parsec must have a function with a predicate
14:08:54 <tolkad> shlevy: often
14:09:03 <kramble> always
14:09:05 <tolkad> shlevy: or at least, arbitrarily sized lists
14:09:13 <tolkad> shlevy: very useful for IO
14:09:29 <kramble> but i hide them behind monad
14:09:43 <monadic_kid> zipWith [0..] pretty useful for me
14:10:00 <monadic_kid> zipWith fn [0..] 
14:10:05 <shlevy> kramble: What do you mean, hide them behind monad?
14:10:34 <aristid> :t zipWith (!!) [0..]
14:10:35 <lambdabot> forall a. (Num [a], Enum [a]) => [Int] -> [a]
14:10:35 <kramble> shlevy: at first haskell main function was of type [string] -> [string]
14:10:44 <tolkad> shlevy: import MonadHide; f :: Mhide [String]
14:10:46 <aristid> :t zipWith (flip (!!)) [0..]
14:10:46 <lambdabot> forall a. [[a]] -> [a]
14:10:49 <kramble> and they gide it behind a monad, so i reproduce it at many places
14:11:03 <kramble> i use a "state" monad when i can avoid infinite list
14:11:20 <ClaudiusMaximus> methods: also, you probably want (return . map) instead of mapM_ in getPositions, otherwise (well, you'll see what gets printed)
14:12:10 <shlevy> Hmm
14:12:59 <bla123> is this valid TH syntax:   let v = mkName "T" in [| data $v = $v |]
14:13:26 * kramble loves program window manager without a doc
14:14:08 <tolkad> bla123: that seems to be a declaration list rather than an expression. shouldn't that be [d| data $v = $v |]?
14:14:14 <dark> I'm looking at snap. I liked this heist. But, is there some heist frontend with haml syntax?
14:14:43 <dark> I'm thinking that maybe I can use (ruby) haml as a pre-processor, emit html or xhtml, that will be passed to heist
14:14:44 <bla123> tolkad: i think so, too. but i'm interested in the $v quotes
14:14:59 <tolkad> http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
14:15:03 <dark> but heist seems to be able to handle multiple frontends (html, xml..)
14:15:07 <tolkad> a splice can occur in place of
14:15:23 <tolkad> an expression, a type, or a list of top level declarations
14:15:32 <tolkad> apparently, not a name
14:15:48 <tolkad> so no, that is not valid template haskell because you cannot splice a name.
14:16:00 <bla123> the snippet is from: http://haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH.html#t:Name
14:16:04 <tolkad> you can write the same thing without resorting to splices though
14:16:12 <bla123> so it must be a mistake in the TH docs then?
14:16:16 <shlevy> I'm extremely mathematical, but never got beyond abstract algebra in school (engineering degree didn't leave time :)) What resources would y'all recommend to understanding the theoretical underpinnings of functional programming and computation in general?
14:16:29 <tolkad> bla123: or an incosistency between implementation/standard
14:16:34 <tolkad> inconsistentcy*
14:16:48 <kramble> shlevy: you don't really need that to play with haskell
14:17:01 <shlevy> kramble: I know, but I want to do more than play :)
14:17:30 <aristid> shlevy: you don't need it for doing more than playing, either
14:17:53 <bla123> tolkad: how can i write it without splices? this example looks like exactly what i need
14:18:57 <kramble> shlevy: there were beginners mathematic guide in the haskell site but i don't find them
14:19:00 <shlevy> aristid: So you think people with the mathematical/theoretical background don't have any advantage in Haskell programming?
14:19:21 <aristid> shlevy: i don't know. i also didn't say that.
14:19:38 <dark> shlevy, understanding how grammars and automatons are related was good for me. but I had a class. [ I'm still to understand much of category theory; much of lambda calculus and types; .. ]
14:19:47 <shlevy> aristid: True enough, sorry.
14:20:09 <Philippa> dark: now relate grammars to algebras, initial and otherwise?
14:20:13 <kramble> shlevy: maybe you can find things here http://www.haskell.org/haskellwiki/Category_theory
14:20:30 <dark> Philippa, my knowledge is too shallow for that, .-. but will improve it
14:20:33 <tolkad> bla123: let v = mkName "T" in [dataD (return []) v [] [normalC v []] []]
14:20:37 <monochrom> shlevy: almost any book or website on "semantics of programming languages" fits
14:20:56 <shlevy> monochrom, kramble: Thanks
14:20:57 <Philippa> dark: in haskell we call initial algebras "algebraic datatypes", if that helps?
14:21:20 <kramble> shlevy: but in fact i just realize you don't want haskell maths explanation but computer programming things
14:21:23 <dark> shlevy, [ you know something about regular expressions? they describe a language: the language of strings that match them. you can also write an automaton - a program - to recognize such strings ]
14:21:39 <tolkad> bla123: the template haskell documentation has data types representing all of haskell syntax. there are a set of functions for each construction (lowercase first letter) that take parameters already in the Q monad, for convenience
14:22:27 <bla123> tolkad: err ... actually, i wanted to avoid the explicit ast, because it's write-once code. but i cannot use the [| ... |] directly, because i need to exchange some type names
14:22:41 <shlevy> kramble: I'm actually interested in both
14:22:56 <tolkad> bla123: you cannot splice names. this is the only alternative
14:23:04 <dark> Philippa, uhmm. I can kind of represent a language as some algebraic data type; I usually would want to do that after parsing. was that about it?
14:23:06 <bla123> tolkad: i also couldn't find some handy function that will take the ast and replace a name with a different one
14:23:38 <tolkad> bla123: well, try splicing the names and see if it works
14:23:44 <dark> but I would need recursive types for some things
14:23:45 <Philippa> dark: there's a little bit more room than that, but that's a decent ballpark for initial algebras. Now figure out what a non-initial algebra is for yourself?
14:23:49 <tolkad> bla123: maybe that documentation is outdated
14:23:58 <Philippa> (oh, and what coalgebras are: for a hint, final coalgebras are initial algebras in haskell)
14:24:04 <bla123> tolkad: what do you mean with "splicing the names"?
14:24:27 <JoeyA> In [atto]parsec, when a parser fails after having consumed input, does subsequent reading of the stream immediately throw an error?  (as long as the failure was not captured in a `try`).
14:24:39 <JoeyA> err, fail, maybe not "throw an error"
14:24:48 <dark> Philippa, I'm thinking about this datatype - grammar a bit. A data X .. = .. would be a "production" of the grammar, right?
14:24:56 <bla123> tolkad: in the ghc docs, i also couldn't find a way to escape from a [| ... |] quote
14:25:03 <methods> ClaudiusMaximus: not really sure how to apply those
14:25:17 <kramble> shlevy: for computer programming i don't really know where you can find interesting things
14:25:17 <dark> does haskell lets one define type X using type Y, and type Y using type X? [ like, er, recursively ]
14:25:23 <Philippa> dark: you can view data constructors as the abstract syntax analogue of productions if you like
14:25:31 <Philippa> and yes, mutual recursion works fine
14:26:27 <kramble> maybe knuth wrote a book
14:26:27 <kramble> dark:
14:26:27 <kramble> @can haskell creates recursive type ?
14:26:27 <lambdabot> Maybe you meant: faq map run wn
14:26:30 <tolkad> bla123: escape? when you are inside it you can write expressions inside $()
14:26:55 <mreh> @faq can haskell create recursive types?
14:26:55 <lambdabot> The answer is: Yes! Haskell can do that.
14:27:13 <comex_> @faq can haskell do something?
14:27:13 <lambdabot> The answer is: Yes! Haskell can do that.
14:27:25 <aristid> mreh: with Mu?
14:27:36 <mreh> could I use Parsec to populate an Array?
14:27:41 <mreh> as it parses
14:27:47 <comex_> @faq can haskell create an instance of the bottom type?
14:27:47 <lambdabot> The answer is: Yes! Haskell can do that.
14:27:55 <tolkad> bla123: like let v = mkName "S" in [d| data T = T $(varT v) |]
14:28:04 <dark> Philippa, http://en.wikipedia.org/wiki/Initial_algebra is extremely dense for me =~
14:28:08 <Philippa> mreh: probably not, on account of having to find out whether the parser fails or succeeds all at once?
14:28:23 <tolkad> bla123: that make sense?
14:28:35 <dark> things like "for a given endofunctor F." stops me
14:28:48 <Philippa> dark: yeah. Try to find a set-theoretic explanation of what algebras are first?
14:28:53 <mreh> Philippa: seems wasteful to read it all into an array
14:29:05 <mreh> but i suppose it's being done anyway
14:29:10 <tg_> @faq Can Haskell answer the halting question?
14:29:10 <lambdabot> The answer is: Yes! Haskell can do that.
14:29:13 <JoeyA> mreh: I don't know.  Array doesn't resize dynamically, so how would you know how big to make it?
14:29:14 <tolkad> dark: an endofunctor is just a functor that maps a category to itself
14:29:14 <mreh> s/array/list
14:29:16 <tg_> MU! MU!
14:29:18 <Philippa> mmm. You can have parsec spit out the array?
14:29:44 <Philippa> tolkad: yeah, but that still doesn't explain enough to read that definition back in terms of even set-theoretic algebras
14:29:47 <kramble> dark: you can see that as the most little thing that can exprain all the others
14:29:54 <Philippa> (which're much easier to get an intuition for)
14:29:58 <kramble> s/exprain/contains/
14:30:02 <tolkad> Philippa: lol I don't even know category theory. I got that off wikipedia
14:30:32 <hpc> i understand what tolkad said, but not what Philippa said
14:30:37 <Philippa> tolkad: I only know snippets - enough to understand F-algebras, though
14:30:40 <blueonyx> hi, given data X = A String | B Int | C Float | ... how to check whether two Xs have the same data constructor? is there an easier way then check (A _) (A _) = True .... check _ _ = False? 
14:30:56 <Philippa> hpc: there's an older definition of algebras in terms of set theory. It's easier for most people to get their heads around
14:31:05 <hpc> blueonyx: A{} A{}, and B{} B{}, ...
14:31:17 <hpc> unfortunately you have to enumerate all possible matches
14:31:24 <blueonyx> kthx
14:31:28 <Philippa> (partly because their signatures look more like eg a record definition than the functor in an F-algebra does)
14:31:30 <hpc> but {} is at least fewer characters
14:31:37 <kramble_> dark: do you know things about http://en.wikipedia.org/wiki/Covering_space ?
14:31:42 <kramble_> because it's the same idea
14:32:13 <dark> Philippa, I understand them as a set s and operations defined on it. I even have some vague notion on what is a group or a ring. [ maybe I should take some class on this while I have chance. I had one catch-all, 'discrete mathematics', but it was very shallow. Another route could be reading actual books.. ]
14:32:15 <Philippa> dark: just assume for now that an algebraic datatype is the same thing as an initial algebra. It's close enough for now
14:32:26 <tolkad> blueonyx: you don't necessarily need a nested case expression though. you could assign a number to each constructor and then compare them
14:32:34 <bla123> tolkad: it works and it does sense. unfortunately, when i replace the type name T with a $(v) quote, ghc reports a parse error. because of that i thought the $() notation didn't work at all
14:32:34 <dark> kramble, no..
14:33:08 <Philippa> dark: okay, cool. An initial algebra is one where you can do direct pattern-matching on it the way you can algebraic datatypes because every constructor is a matching deconstructor - or to put it another way, no value can be built more than one way and every combination builds a value
14:33:15 <Philippa> ("no junk, no confusion")
14:33:21 <dark> I borrowed, and tried to read some books on logic, computer science, from the library here. I fail to understand the most basic things. .-.
14:33:23 <kramble_> dark: ok, so you have many things to understand :D good luck
14:33:27 <kramble_> (and be brave)
14:33:31 <bla123> tolkad: thank you, i guess i'll take the $() and play a bit with it :D
14:33:52 <dark> kramble, hah yeah =)
14:34:07 <Philippa> dark: with algebras, the operations that're defined build new values in S. Coalgebras take values in S apart instead
14:34:55 <Philippa> brb
14:34:55 <dark> Philippa, sounds reasonable. (This thing of: "no value can be built more than one way and every combination builds a value" I understand intuitively, from the notion of deconstruction of the data with pattern matching)
14:35:02 <dark> bye, thanks =)
14:35:58 <tolkad> can the TH documentation be fixed? this incorrect example code just seriously confused a beginner and is completely contradictory to other documentation: http://haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH.html#t:Name
14:35:58 <kramble> :D data List a = { fold :: a -> (a -> b -> a) -> b }
14:36:09 <kramble> sorry :D data List a = { fold :: a -> (a -> b -> b) -> b }
14:36:14 <Philippa> b
14:36:49 <kramble> and data Tree a = {fold :: a -> (a -> List b -> b) -> b}
14:36:55 <kramble> i'm stopping right now
14:37:20 <Philippa> dark: all non-initial algebras can be constructed (in a formal sense I can't be arsed to define right now) from an initial algebra. Informally? Take an initial algebra, write a bunch of functions providing the new algebra's constructors in terms of it and you're done
14:37:22 <dark> algebras can take values of S and build values of S. like, (N, +) - so this is a Co-algebra too?
14:37:41 <kramble> one last ( data Either a b = { fold :: (a -> c) -> (b -> c) -> c} )
14:38:21 <Philippa> dark: in the category of Complete Partial Orders (and thus most turing complete languages) initial algebras are isomorphic to final coalgebras - that is the same thing, yeah
14:38:43 <kramble> (dark i put here some stupid examples)
14:39:20 <Philippa> dark: but non-final coalgebras aren't the same thing as non-initial algebras - a fairly simple example of a coalgebra might be typechecking and evaluation for a simple AST, which sure isn't the same thing as building the program in the first place
14:39:23 <dark> kramble, examples of?
14:40:22 <dark> Philippa, so the group of (N, +) - the natural numbers, and addition - isn't a coalgebra? (It is building a number in N)
14:40:49 <bla123> tolkad: i'd prefer it if they implemented it to match the docs ;)
14:40:50 <BlueIgniter> Hello
14:40:51 <Philippa> dark: right
14:41:03 <Philippa> coalgebras are taking stuff apart, not building it
14:41:09 <roconnor> anyone know anything about freely generated categories?
14:41:30 <kramble> Philippa: if oyu take the cocategory you invert things
14:41:43 <kramble> algebra and coalgebra are exactly the same concept
14:42:12 <Philippa> kramble: only backwards, yes. Hence building vs taking apart
14:42:55 <Philippa> the initial algebra/final coalgebra isomorphism's specific to CPO though, it doesn't apply in total settings
14:42:58 <kramble> Philippa, data List a = { fold :: a -> (a -> b -> a) -> b }  is an algebra for you ? or a coalgebra ? or something else ?
14:43:41 <aristid> is installing template-haskell from cabal a good idea?
14:43:48 <monochrom> no
14:43:58 <aristid> fuck, i think i'm screwed, then :(
14:43:58 <Philippa> kramble: it's both, but it's borth due to a quirk of the category it lives in
14:44:00 <aristid> stupid cabal
14:44:07 <Philippa> in Agda, you can tell the two apart
14:44:18 <aristid> which ghc version came with containers 0.4?
14:44:36 <dcoutts_> 7 probably
14:44:41 <Philippa> Lists're finite, Colists aren't necessarily (and you build them with an unfold)
14:44:45 <kramble> Philippa: do you got an example without the quirk ?
14:44:45 <aristid> why do i have containers 0.4 installed, then?!
14:45:25 <aristid> dcoutts_: lots of packages for some unknown reason depend on containers 0.4, and it probably got installed when i was not looking :/. i wish cabal would protect me against that!
14:45:29 <Philippa> kramble: pick a category that's not descended from CPO. For example, pick a total dependently-typed language like Coq or Agda which'll force you to keep track of the difference
14:45:56 <aristid> well, actually they don't depend on it, they're just compiled against it
14:46:07 <dcoutts_> aristid: you've not been using cabal upgrade?
14:46:09 <aristid> but i have no idea why containers 0.4 was installed in the first place
14:46:12 <aristid> dcoutts_: no.
14:46:26 <aristid> and i'm pretty sure i didn't cabal install containers
14:46:46 <monochrom> I would love to know how to reproduce that too.
14:46:59 <dcoutts_> aristid: mm, it'll have been pulled in by the latest version of something you installed
14:47:12 <aristid> right, possibly
14:47:16 <aristid> but that's evil :(
14:47:24 <dcoutts_> aristid: well maybe
14:47:46 <dcoutts_> aristid: should it simply refuse to install something that uses containers-0.4 ?
14:47:52 <aristid> yes.
14:48:11 <dcoutts_> aristid: or should it install but then continue to use containers-0.3 as the default for other things
14:48:26 <dcoutts_> rather than assuming "always pick the latest installed version"
14:48:44 <aristid> i think refusing to install containers 0.4 would be sufficient
14:48:53 <aristid> because it is so deeply associated with GHC
14:49:14 <dcoutts_> well it's not really
14:49:30 <dcoutts_> it's fine in principle to have multiple versions of it
14:49:33 <aristid> we have this informal rule: don't upgrade packages associated with GHC. if you do, bad things might happen.
14:49:42 <aristid> it's not enforced, but people try to follow it
14:49:47 <aristid> until a rogue package comes along...
14:50:34 <monochrom> we have this formal rule: don't bring in container-0.4 if you already have container-0.3 and dependecies say 0.3 is fine
14:50:52 <hpc> aristid: isn't that a problem with the GHC libs being in different packages?
14:51:02 <aristid> monochrom: i don't know what happened, actually, but a hypothesis is that some package actually had a dependency on 0.4
14:51:15 <aristid> hpc: maybe, i don't know how to solve it optimally
14:51:18 <dcoutts_> right, or cabal would never have installed container-0.4
14:51:37 <dcoutts_> I think I do know how to solve it optimally
14:51:42 <aristid> dcoutts_: another hypothesis is that i was installing containers when i was drunk or tired.
14:51:48 <dcoutts_> but it's non-trivial
14:52:00 <dcoutts_> aristid: heh, I think the other is more likely
14:52:14 <bla123> aristid: maybe you need some config file with additional constraints for cabal? (containers <= 3.*)
14:53:17 <aristid> dcoutts_: i have an idea: maybe there could be virtual packages. so that GHC is actually one big physical package, but it provides virtual packages like base and container. and there is no other way to install these packages than to install the proper physical package. this would enforce consistency, and might even simplify GHC development.
14:53:32 <monochrom> cabal-install should keep a log. we have no post-mortem for why an undesirable package got in.
14:53:41 <dcoutts_> monochrom: it does
14:53:47 <monochrom> where where?
14:54:00 <monochrom> oh, it does.
14:54:09 <dcoutts_> oh, it's not on by default I think
14:54:20 <aristid> oh :/ i would have searched for the culprit
14:54:26 <monochrom> it is on by default. I just forgot it.
14:54:31 <aristid> monochrom: where?
14:54:42 <monochrom> I just forgot it exists. .cabal/logs/build.log
14:55:30 <monochrom> ok great! I know how to taunt the next cabal problem asker next time!
14:55:32 <aristid> ok, i found the culprit
14:55:33 <aristid> comonad
14:56:36 <aristid> @tell edwardk Please don't depend on containers-0.4 in comonad. I broke my whole cabal installation by installing comonad on a machine with GHC 6.12.
14:56:36 <lambdabot> Consider it noted.
14:57:03 <aristid> preflex: seen edwardk
14:57:04 <preflex>  edwardk was last seen on #haskell 6 hours, 1 minute and 23 seconds ago, saying: xplat: cute
14:57:04 <monochrom> eh this is gay. 1.0 doesn't use container at all, 1.0.1 adds it.
14:57:46 <dcoutts_> monochrom: hmm, I didn't realise it was on by default
14:57:54 <aristid> dcoutts_: what do you think of my physical/virtual packages idea? :)
14:57:57 <bla123> btw, on windows the cabal log is put somewhere in a "$prefix" folder
14:58:15 <aristid> the log definitely helped me, so it's good that it's on by default!
14:58:24 <aristid> please don't turn it off
14:58:36 <dcoutts_> aristid: right the log is fine, I'm worried about the build reporting
14:58:53 <dcoutts_> aristid: since we have to have build reporting be opt-in, not opt-out
14:59:13 <aristid> i'm not sure what you mean by build reporting
14:59:15 <dcoutts_> and I'm worried I've got the default wrong for when we add build reporting properly
14:59:37 <dcoutts_> aristid: uploading info to hackage about what builds and what does not
14:59:50 <dcoutts_> even though it's anonymous it's obviously important that it be opt-in
15:00:05 <monochrom> how do I say it? "build-summary: /home/trebla/.cabal/logs/build.log" is a line in config, I didn't put it there myself, cabal-install put it there initially, I let it live. Not detailed build log, just "package x, depends on y, done, success", which is just right.
15:00:55 <aristid> dcoutts_: oh, yes, that should not be opt-out
15:01:19 <aristid> monochrom: it's very useful
15:04:53 <dcoutts_> sigh, I've messed up the default
15:06:12 <dcoutts_> aristid: re vistual packages, it's not specific to core packages
15:06:30 <dcoutts_> it's just most common there
15:06:53 <dcoutts_> so I'm not in favour of any special case solution for core packages
15:07:05 <dcoutts_> because everyone has a different notion of what is core
15:07:07 <aristid> dcoutts_: yes, virtual packages would be nice for non-core packages too.
15:07:40 <dcoutts_> aristid: my suggestion is to tweak the policy on default preferences
15:07:56 <dcoutts_> aristid: the current policy says we prefer the latest installed version
15:08:11 <aristid> isn't there an override of that for parsec?
15:08:31 <dcoutts_> no, you're thinking of source packages
15:08:55 <aristid> huh?
15:09:06 <dcoutts_> if there is no installed version that is suitable then we prefer the latest source version, subject to any per-package preferences like there is for parsec
15:09:40 <dcoutts_> aristid: oh, hmm, perhaps you're right, and we use the per-package prefs for installed ones too
15:09:51 <dcoutts_> anyway that's an orthogonal issue
15:10:18 <dcoutts_> aristid: so at first sight "use latest installed version, otherwise latest source version" is sensible
15:10:34 <dcoutts_> on the theory that if you installed a newer version then you want to use it
15:10:51 <aristid> dcoutts_: well, in the case of comonad, it should simply use container 0.3. it certainly can.
15:11:00 <dcoutts_> where that theory breaks down is that not all packages that are installed are things "you installed"
15:11:16 <aristid> it's a bug that comonad depends on container 0.4 unnecessarily
15:11:17 <dcoutts_> they're indirect deps you don't care about
15:11:30 <aristid> right
15:11:43 <dcoutts_> aristid: so that suggests we tweak the policy
15:11:56 <dcoutts_> to say prefer the latest version that we actually deliberately installed
15:12:24 <dcoutts_> so if we pull in a new version of foo as an indirect dep, that does not mean from now on we want to use that for everything
15:12:38 <dcoutts_> but if we installed foo ourselves then we probably do want to use it
15:14:01 <aristid> dcoutts_: but even your tweaked case does not address the fact that package version requirements are often buggy
15:14:13 <aristid> the constraints are too lax or too strong
15:14:31 <dcoutts_> aristid: sure, cabal can only work with what it's got
15:14:38 <dcoutts_> the info available
15:14:53 <aristid> it can however try to prevent harm as much as possible
15:15:06 <dcoutts_> so you could also imagine a pinning system
15:15:13 <dcoutts_> indeed you can almost do that no
15:15:14 <dcoutts_> now
15:15:14 * napping looks forward to Agda's cabal
15:15:22 <dcoutts_> it's just not convenient
15:15:31 <aristid> package management is hard.
15:16:01 <Studley> Quick question
15:16:21 <Studley> What exactly does 'parse error in pattern' entail?
15:16:40 <aristid> dcoutts_: maybe it would make sense to pin these packages by default, but let people remove the pin if they so desire
15:16:45 <hpc> Studley: it means when you wrote "foo SomeParam = blah"
15:16:50 <dcoutts_> aristid: so the problem with pinning is knowing what to pin, without forcing users to know too much about theses grungy details
15:16:55 <aristid> dcoutts_: so they still can install container-0.4 if they really need it, but they will be warned
15:16:55 <hpc> you didn't type that parameter right
15:17:02 <hpc> (iirc)
15:17:18 <napping> Studley: I'm guessing you wrote foo Constructor x y = ... instead of foo (Constructor x y) = ...
15:17:34 <aristid> dcoutts_: or just adding a prompt. "Do you really want to install container-0.4?"
15:17:34 <napping> but it's hard to say anything more than "your pattern didn't parse" with just the message
15:17:47 <dcoutts_> aristid: but how do we know what to pin?
15:17:54 <ddarius> We should have Hackage attempt to build a package against every version of it's dependencies.
15:18:01 * hackagebot lrucache 1.1.1 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.1.1 (CarlHowells)
15:18:04 <aristid> dcoutts_: pinning packages shipped with GHC would be a start
15:18:06 <dcoutts_> aristid: you can pin things now, just add constraint: foo==1.0 to your ~/.cabal
15:18:11 <c_wraith> ddarius: yes, nothing like exponential explosions
15:18:29 <dcoutts_> aristid: cabal does not know what ships with ghc, cabal works with multiple ghc versions, unreleased ones
15:18:36 <Studley> hpc yup
15:18:40 <Studley> that was it.
15:18:58 <dcoutts_> aristid: and it's not enough, you'd also want HP packages
15:19:09 <aristid> dcoutts_: well, and there's always the physical/virtual package proposal :)
15:19:22 <dcoutts_> aristid: I'm not sure I understand it
15:20:24 <dcoutts_> aristid: sounds like you want to record in the ghc-pkg db that some packages are core packages and cannot be upgraded
15:20:26 <Saizan> dcoutts_: maybe it could warn everytime it ends up upgrading a non-leaf package
15:20:28 <aristid> dcoutts_: GHC 6.12.3 would be a physical package that is recognized by cabal. it would provide virtual packages base 4.2, container 0.3, template-haskell 2.4 and so forth. and if you want to have container 0.4, you install GHC 7.0.2
15:21:04 <aristid> dcoutts_: not updated without updating the associated physical package
15:21:09 <Saizan> dcoutts_: asking for confirmation
15:21:10 <dcoutts_> Saizan: I think that's too strong, many systems are made of multiple packages, e.g. the web frameworks or darcs even (with its hashed-storage)
15:21:55 <dcoutts_> aristid: so there's info to say this is a virtual package and we should ignore corresponding source packages with that name?
15:22:29 <aristid> dcoutts_: that would probably also be necessary, but that's not the core of what i mean
15:22:30 <Saizan> dcoutts_: ah, could be adjusted to a non-leaf package whose dependents are not also upgraded in the current installplan
15:23:02 * hackagebot cabal-dev 0.7.4.0 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.7.4.0 (RoganCreswick)
15:23:35 <dcoutts_> Saizan: but then I can't e.g. rebuild darcs against a new hashed-storage
15:24:17 <Saizan> dcoutts_: why?
15:24:24 <dcoutts_> Saizan: well, only with a warning
15:24:39 <aristid> dcoutts_: there would basically be only one source package: GHC 6.12.3, and its cabal file would contain a line like "Provides-Virtual: base-4.2.0.0, container-0.3.0, template-haskell-2.4.0". and there would be no (or hidden) source packages for base and container and template-haskell
15:25:07 <dcoutts_> aristid: and what does cabal do about there also being source packages containers-0.4.0 ?
15:25:28 <dcoutts_> aristid: or you mean we delete them from hackage?
15:25:42 <aristid> dcoutts_: right, that is a problem i did not really consider at all
15:25:44 <ddarius> Saizan: People aren't going to know whether to say "yes" or "no" to those confirmations typically.
15:26:22 <Saizan> ddarius: i guess so
15:26:48 <aristid> dcoutts_: maybe virtual packages should live in an isolated namespace, so there is no possibility of a clash.
15:27:22 <dcoutts_> aristid: sounds like just having a list of pinned packages is simpler
15:27:41 <aristid> it doesn't solve the same set of problems :)
15:27:47 <dcoutts_> doesn't it?
15:28:11 <dcoutts_> I've missed something then
15:28:20 <aristid> with physical/virtual packages you CAN upgrade. but you have to upgrade the physical package, and get all virtual packages upgraded in one swoop, implicitly
15:29:41 <aristid> well, i guess this could be emulated already by having container have a hard dependency on an exact GHC or base version
15:29:53 <dcoutts_> aristid: hmm ok, though if you're tieing it to base then it's not actually upgradable
15:30:42 <aristid> which is basically the goal?
15:31:18 <dcoutts_> aristid: but then we could just use a list of pinned packages
15:31:25 <aristid> i'm just throwing ideas pretty randomly :)
15:31:25 <dcoutts_> which will work with the current constraint solver
15:33:08 <aristid> i guess list of pinned packages is the most pragmatic near-term solution
15:33:10 * Saizan wonders how many of ghc's and template-haskell's dependencies are actually exposed in the API
15:44:26 <ddarius> dcoutts: If the dependencies are accurate, i.e. every package can build with every package it claims to be able to build against, does cabal install ever do the wrong thing?
15:44:41 <dcoutts_> ddarius: yes
15:44:51 <roconnor> how do I define a coend in haskell?
15:44:51 <dcoutts_> in various ways
15:45:37 <ddarius> dcoutts: Are these ways fixable or inherent?
15:45:50 <roconnor> ddarius: cabal suffers from the butterfly problem.
15:45:58 <dcoutts_> ddarius: mostly fixable with enough work
15:46:10 <roconnor> ddarius: specifically it cannot support two builds of the same version of the same package with differetn dependencies.
15:46:10 <dcoutts_> e.g. we can fix the "butterfly" problem
15:46:15 <hpc> roconnor: installing one package will break a hundred others? ;)
15:46:32 <Saizan> butterfly problem == ?
15:46:44 <Saizan> ah, what roconnor said
15:46:59 <dcoutts_> Saizan: currently package dbs only allow one instance of a package version
15:47:17 <aristid> reminds me of nixos
15:47:21 <dcoutts_> which means if you need to rebuild a package then you're breaking anything which dependened on the old instance
15:47:31 <dcoutts_> aristid: right and that's basically the solution
15:47:42 <roconnor> there was a second problem that cabal had as well, but I forget what it was.  I think it was a problem that nix doesn't solve either.
15:47:46 <Saizan> yeah, that's fixable, the general problem of "i'm installing packages that'd prevent me to use some non-upgradeable packages later" can't be
15:47:50 <dcoutts_> aristid: but you'll also appreciate why it's a fair bit of work
15:48:04 <aristid> dcoutts_: yes.
15:48:06 <dcoutts_> roconnor: the other one is private dependencies
15:48:19 <roconnor> oh right
15:48:21 <dcoutts_> roconnor: or rather, private dependencies is probably an 80% solution to the problem
15:48:31 <dcoutts_> roconnor: we're working on that at the moment for the IHG
15:48:44 <dcoutts_> expect a blog post on it
15:48:55 <roconnor> I think that is something nix could solve but doesn't.
15:49:05 <dcoutts_> right, it needs enough info
15:49:21 <dcoutts_> nix cannot magically conjure up that info
15:49:35 <roconnor> it needs to be specified in nix-pkgs, but it isn't at the momemnt
15:49:39 <dcoutts_> we can do it because we know the programming language
15:49:55 <Saizan> dcoutts_: so you're going to infer which ones are private?
15:49:56 <roconnor> one would need to rewrite all of nixpkgs, which would be a bit of a chore
15:49:58 <dcoutts_> so we can discover the info and check that it's accurate
15:50:00 <dcoutts_> Saizan: no
15:50:09 <dcoutts_> Saizan: but we can tell authors when it is private
15:50:30 <dcoutts_> Saizan: we need to know the info up front for dep planning, deriving it on the fly is not practical.
15:50:50 <Saizan> dcoutts_: yeah, i wondered if that'd go in sdist or similar
15:50:56 <dcoutts_> Saizan: ie after a build we can say "BTW, package foo could be added to build-depends-private"
15:51:16 <dcoutts_> Saizan: the check has to be done at the renamer (or equiv) stage of compilation
15:51:27 <dcoutts_> where we know exactly where everything is imported from
15:51:36 <dcoutts_> and know types of everything
15:52:52 <Saizan> yeah, for a particular choice of flags
15:53:00 <dcoutts_> Saizan: right, that too
15:53:20 <dcoutts_> Saizan: though makeing that kind of thing flag conditional would be pretty evil
15:53:34 <dcoutts_> you're not supposed to change the interface via flags
15:53:39 <ddarius> roconnor: If you pretend Hask is Set, a coend (in and over Hask) is basically an existential.
15:53:49 <roconnor> ddarius: but it is modulo something
15:53:51 <djahandarie> What if you don't pretend that?
15:54:25 <ddarius> djahandarie: Then you don't necessarily even have existentials.
15:54:47 <aristid> what does the [boot] mean? "[1 of 8] Compiling Data.Enumerator[boot] ( hs/Data/Enumerator.hs-boot, dist/build/Data/Enumerator.o-boot )"
15:54:51 * roconnor pretends Hask is Type
15:54:58 <djahandarie> So it would be impossible?
15:55:12 <ddarius> djahandarie: A category doesn't necessarily have coends.
15:55:29 <dcoutts_> aristid: hs-boot is the mechanism ghc provides to resolve circular module deps
15:55:52 <aristid> dcoutts_: ah, interesting.
15:56:07 <aristid> i always try to resolve circular deps, tho
15:57:02 <dcoutts_> most people do most of the time, but there are occasions where circular deps are preferable
15:57:29 <aristid> yeah, i was just curious as to what it means
16:02:37 <rostayob> How can instanciate classes? For example, it seems I can't do something like "instance (Foo a) => Eq a where"
16:02:44 <rostayob> *instantiate
16:03:10 <aristid> rostayob: right, because that's too general
16:03:28 <rostayob> aristid: but I'm using only class' methods in the definition
16:03:30 <aristid> rostayob: basically, GHC needs a specific type
16:03:38 <aristid> Eq a
16:03:42 <aristid> this part is the problem
16:03:47 <aristid> a is too unspecific
16:04:00 <rostayob> aristid: yeah but I want to be able to compare all the instances of Foo, since I'm able to do so
16:04:28 <roconnor> the haskell report says circular dependencies are allowed
16:04:36 <rostayob> because I'm doing "a1 == a1 = fooMethod a1 == fooMethod a2"
16:04:39 <doserj> rostayob: there is a language extension that allows it, but it doesn't mean what you want it to mean
16:04:40 <aristid> rostayob: then define Eq on every single type that defines Foo.
16:04:56 <aristid> rostayob: you can make helper functions to make this more convenient
16:05:06 <mzero> or look at it this way: what happens when you "instance Eq Bob where..."    and Bob is also an instnace of Foo?
16:05:30 <rostayob> mhm... the thing is that in my code, if it's of the class Foo it can be comparable. So if I do what you said, I'll have to do (Foo a, Eq a) each time
16:05:34 <mzero> which implementation of Eq's methods get used for a Bob?  
16:05:48 <rostayob> mzero: The more specific one, I guess
16:06:13 <aristid> rostayob: no. GHC would refuse to choose.
16:06:21 <doserj> rostayob: if every instance of Foo is also an instance of Eq, you want Eq as a superclass of Foo: class (Eq a) => Foo a where...
16:06:21 <mzero> ah - looks easy in this example -- and there is a GHC extension which will let it through ... but it is not to hard to imagine cases where "more specific" might be unclear
16:06:45 <rostayob> ok, so what do I do?
16:07:05 <aristid> doserj: that still requires defining the Eq instances manually. but yeah
16:07:50 <rostayob> the thing is that... I could instantiate Eq for each type
16:08:00 <rostayob> but in my case
16:08:00 <rostayob> it's useless
16:08:09 <rostayob> when I handle Foo types
16:08:16 <rostayob> I'd have to do (Foo a, Eq a)
16:08:22 * mjrosenb has just implemented fold using map
16:08:23 <rostayob> when Foo - in my case - implies Eq
16:08:34 <monochrom> "class (Eq a) => Foo a" solves the (Foo a, Eq a) problem
16:08:58 <doserj> and writing "instance Eq AFooInstance where (==) = eqFromFooInstance" isn't too much boilerplate
16:09:03 <aristid> rostayob: it's a limitation of haskell. haskell is not perfect.
16:10:18 <rostayob> doserj: Well in this case I have to do this at least 5 times, and then have ugly type signatures for a lot of functions :P
16:10:20 <mzero> throw the heretic out!!!!
16:10:24 <rostayob> aristid: I see... isn't there some weird LANGUAGE flag to do what I want to?
16:12:18 <aristid> rostayob: i don't know, actually. but the weird type signatures can be solved in standard haskell.
16:12:33 <aristid> just defined class Foo as: class Eq a => Foo a where ...
16:12:44 <aristid> then Foo a => ... will suffice everywhere
16:14:58 <rostayob> aristid: right. I still have to define Eq for each type, but that's more acceptable. thanks.
16:15:42 <aristid> rostayob: and with a helper function, each instance looks like this: instance Eq X where (==) = fooEq
16:15:55 <rostayob> aristid: yes, makes sense. thanks.
16:16:06 <rostayob> still kinda hackish, but ok :P
16:16:57 <Brechreiz> How do I write the following with do notation?
16:17:02 <Brechreiz> foo = "hello" >>= replicate 3
16:17:21 <Brechreiz> > let foo = "hello" >>= replicate 3 in foo
16:17:22 <lambdabot>   "hhheeellllllooo"
16:17:27 <dolio> do c <- hello ; replicate 3 c
16:17:47 <dolio> @redo "hello" >>= replicate 3
16:17:47 <Brechreiz> > do c <- hello ; replicate 3 c
16:17:48 <lambdabot> Maybe you meant: do read todo undo
16:17:48 <lambdabot>   Not in scope: `hello'
16:18:00 <dolio> @do "hello" >>= replicate 3
16:18:00 <lambdabot> do { a <- "hello"; replicate 3 a}
16:18:12 <Brechreiz> > do { a <- "hello"; replicate 3 a}
16:18:13 <lambdabot>   "hhheeellllllooo"
16:18:20 <Brechreiz> Ah cool! Thanks dolio
16:19:38 <Brechreiz> Of course I could also just say:
16:19:40 <Brechreiz> > concat $ map (replicate 3) "hello"
16:19:41 <lambdabot>   "hhheeellllllooo"
16:19:43 <Brechreiz> :-)
16:19:57 <Brechreiz> > concatMap (replicate 3) "hello"
16:19:57 <dolio> @do concatMap (replicate 3) "hello"
16:19:58 <lambdabot>   "hhheeellllllooo"
16:19:58 <lambdabot> concatMap (replicate 3) "hello"
16:20:37 <Brechreiz> @src concatMap
16:20:37 <lambdabot> concatMap f = foldr ((++) . f) []
16:20:55 <dolio> @undo [ c | c' <- "hello", c <- replicate 3 c ]
16:20:55 <lambdabot> concatMap (\ c' -> concatMap (\ c -> [c]) replicate 3 c) "hello"
16:21:04 <Brechreiz> Why can't I just say myConcatMap = concat . map ?
16:21:17 <dolio> Heh, that's broken.
16:21:57 <dolio> Brechreiz: Arguments don't work out correctly.
16:22:06 <dolio> concat . map = \x -> concat (map x)
16:22:06 <doserj> @type concat . map
16:22:07 <lambdabot>     Couldn't match expected type `[[a]]'
16:22:07 <lambdabot>            against inferred type `[a1] -> [b]'
16:22:07 <lambdabot>     Probable cause: `map' is applied to too few arguments
16:22:07 <monochrom> (myConcatMap = concat . map) ⇒ (myConcatMap f = (concat . map) f) ⇒ not what you think
16:22:26 <dolio> You need \f l -> concat (map f l)
16:22:33 <Boxo> :t (concat .) . map
16:22:33 <dolio> \f -> concat . map f
16:22:34 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
16:22:39 <roconnor> @unpl (conact .) . map
16:22:39 <lambdabot> (\ d g -> conact (map d g))
16:22:53 <aristid> :t [ c | c' <- "hello", c <- replicate 3 c ]
16:22:54 <lambdabot> [Expr]
16:23:27 <aristid> dolio: @undo is not broken if it returns nonsense for nonsensical input :)
16:23:37 <aristid> :t [ c | c' <- "hello", c <- replicate 3 c' ]
16:23:37 <lambdabot> [Char]
16:23:43 <aristid> @undo [ c | c' <- "hello", c <- replicate 3 c' ]
16:23:43 <lambdabot> concatMap (\ c' -> concatMap (\ c -> [c]) replicate 3 c') "hello"
16:23:50 <Brechreiz> I find (concat .) . map quite hard to understand, but maybe that's just me :)
16:23:57 <aristid> :t concatMap (\ c' -> concatMap (\ c -> [c]) replicate 3 c') "hello"
16:23:58 <lambdabot>     Couldn't match expected type `[a]'
16:23:58 <lambdabot>            against inferred type `Int -> a1 -> [a1]'
16:23:58 <lambdabot>     In the second argument of `concatMap', namely `replicate'
16:24:03 <roconnor> Brechreiz: you get used to it after a few years
16:24:06 <Boxo> It takes getting used to
16:24:07 <Boxo> heh
16:24:08 <aristid> ok, that is broken
16:24:13 <roconnor> it's kinda like fmap (fmap concat) map
16:24:17 <monochrom> oh, I don't use ((concat .) . map) myself either
16:24:24 <aristid> Brechreiz: it's the same as \a b -> concat (map a b)
16:24:39 <Boxo> can pl still not do lsit comprehensions? ...
16:24:55 <Boxo> @pl \f xs -> [f x | x <- xs]
16:24:55 <lambdabot> flip flip [] . ((:) .) . (<-) . (| x) . ($ x)
16:25:03 <aristid> Boxo: you could improve it :)
16:26:34 <Boxo> sounds good
16:31:11 <Brechreiz> @src Monad
16:31:11 <lambdabot> class  Monad m  where
16:31:11 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:31:11 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
16:31:11 <lambdabot>     return      :: a -> m a
16:31:11 <lambdabot>     fail        :: String -> m a
16:39:46 <sm> monochrom: shouldn't your articles be syndicated on the planet ?
16:40:09 <sm> looks like another good one - thanks! 
16:40:27 <sm> oh wait, I read this
16:40:33 <sm> bah
16:40:51 <parcs> @hoogle tryIO
16:40:51 <lambdabot> No results found
16:42:11 <lispy_> sm: I think planet is still down?
16:42:43 <sm> lispy_: up for me right now. Though I've had trouble accessing it lately when other people could
16:43:05 <lispy_> sm: ah, cool
16:58:09 <nkpart> Hey, if I encounter an ambiguous module name while trying to import something in GHCi, how can I be explicit about the module I want?
16:59:22 <kmc> ghc -hide-package
16:59:31 <kmc> err ghci -hide-package
17:00:24 <c_wraith> if you don't want to restart ghci, you can also use :set -hide-package blah
17:02:48 <nkpart> cool, thanks :)
17:07:14 <vpalle> if i have a list and need to update every entry in the list with a new updated, transformed version of the entry, without changing the identity of the original list? how do i do that?
17:09:33 <kmc> map
17:09:48 <kmc> you can't change the identity of the original list anyway
17:09:54 <kmc> lists are values; values never change, by definition
17:10:11 <vpalle> map will change the identy
17:10:12 <kmc> > map (+5) [1,2,3]
17:10:12 <lambdabot>   [6,7,8]
17:10:17 <kmc> what do you mean?
17:10:31 <monochrom> I fear that "identity" is java-speak for "pointer equality"
17:10:41 <vpalle> exactly why i said :)
17:10:47 <kmc> what you said is unclear
17:10:58 <kmc> vpalle, if you are asking how to change a list "in place", the answer is that you can't
17:11:31 <monochrom> "mutate the car fields but don't mutate the cadr fields"
17:12:05 <DT-1245> Hey folks
17:12:28 <methods> is there a built in way to access element of an array by index ?
17:12:47 <kmc> methods, the operator ! is used to index arrays
17:12:52 <vpalle> the identity is the problem?
17:12:53 <winxordie> ! indexes lists
17:13:09 <Saizan> !! indexes lists, ! arrays
17:13:10 <kmc> ! indexes arrays, !! indexes lists but lists aren't made for indexing, it will be slow and cumbersome
17:13:19 <winxordie> er, !!
17:13:19 <kmc> vpalle, we still don't know what you mean by "identity"
17:13:36 <kmc> vpalle, can you provide a code example of what you'd like to do and why "map" isn't suitable?
17:13:41 <winxordie> curse you wireless latency
17:14:40 <vpalle> map is causing me the headache of changing the identity
17:15:07 <Saizan> get used to it, or you won't go far in Haskell
17:15:16 <kmc> vpalle, and i still don't know what you mean by that
17:15:29 <DT-1245> I'm new to programming and my friend says that Haskell isn't compatible with mobile apps because it's an unsupported format. He says that it is currently more of an academic project and not fully embraced. He suggests that as a beginner I use C. C++, Java, php, Perl and Python with C# becoming the one being used for Microsoft apps. Any thoughts?
17:15:48 <copumpkin> screw him
17:15:58 <monochrom> it is rather futile to use java vocabulary (for example) here. we have something else called "identity".
17:15:59 <copumpkin> learn it cause it's fun
17:16:09 <kmc> DT-1245, that's mostly true, Haskell isn't that popular because it requires you to think and makes it hard to write buggy programs
17:16:30 <kmc> (harder, anyway)
17:16:41 <monochrom> Cale works for iPwn Studio for writing an iPhone app in haskell.
17:16:41 <DT-1245> kmc - you mean it's a tighter language? 
17:16:51 <kmc> DT-1245, more elegant, more precise, etc.
17:17:03 <kmc> DT-1245, i think it's a good language for beginners as long as you don't expect instant gratification
17:17:09 <kmc> if you want to start making games and websites tomorrow, learn Python
17:17:19 <kmc> if you want to understand some really cool things that few programmers do, learn Haskell
17:17:22 <monochrom> "one experiment proofs you wrong."
17:17:24 <kmc> just don't expect it to be easy
17:17:30 <monochrom> s/proofs/proves/
17:17:55 <monochrom> and yeah, also choose your friends judiciously.
17:18:13 <kmc> anyone who recommends C++ or PHP to a beginner is no friend
17:18:22 <DT-1245> I get that python is supposed to be easier... but he says the following... "For any app to work it requires a compiler to execute it with a library (of commands) supporting the compiler. In order for Haskell based software to be used on mobiles various environments it would need a compiler to support the underlying operating system. Hence why 99.99% of apps are written in some form of C, Java or to a lesser extent Python. C covers 9
17:18:35 <DT-1245> thx kmc for replying btw
17:18:41 <kmc> C is a low-level operating system programming language / portable assembly language
17:18:54 <monochrom> for example, having a lot of opinions is highly correlated to being highly ignorant, so you may like to choose friends with few opinions.
17:19:00 <kmc> it is not suitable for writing general-purpose applications and you will go mad trying
17:19:13 <DT-1245> Yeah i'm kind of getting that feeling <mono> lol
17:19:47 <Bynbo7> DT-1245: you friend sounds like an uninformed fool to me :)
17:19:52 <methods> is it possible to just print <- instead of assigning variables first ?
17:20:01 <kmc> methods, what do you mean?
17:20:14 <monochrom> putStrLn "<-" ?
17:20:15 <kmc> people often ask these impossible vague "which language is best" questions here
17:20:18 <methods> (x,y,z) <- plGetPosition b; print (x,y,z)
17:20:20 <kmc> it's puzzling
17:20:28 <monochrom> plGetPosition >>= print
17:20:34 <kmc> because nobody asking such a question ever says *why* they're learning to program
17:20:35 <vpalle> i know im being unreasonbale, but its just such a sound specificatoin :)
17:20:38 <kmc> or what they hope to get out of it
17:20:39 <monochrom> Chinese is the best language.
17:20:41 <Saizan> plGetPosition b >>= print
17:20:44 <methods> hm i was trying <<= guess that didn't make sense
17:20:51 <DT-1245> <Bynbo> LOL yeah but I can't PROVE why... He says that there isn't a compiler for Haskell to put it onto any of the mobile environments...? Is that even right?
17:20:52 <monochrom> oops, what Saizan says
17:21:10 <Bynbo7> DT-1245: there's a compiler for the iPhone
17:21:14 <copumpkin> dcoutts: you around?
17:21:15 <kmc> DT-1245, there's a bit of work to make GHC target iPhone and Android, but it's not exactly production-grade
17:21:20 <Bynbo7> who cares about anything else >_>
17:21:21 <kmc> DT-1245, what do *you* hope to get out of learning to program?
17:21:24 <dcoutts_> copumpkin: hia
17:21:27 <kmc> fuck the iPhone
17:22:02 <DT-1245> <kmc> and <Bynbo> I'm trying to hopefully create some apps for the iPhone
17:22:18 <copumpkin> dcoutts_: if I have a cbits folder in my cabal package, and I cabal install with a .cabal file that mentions an "  Includes:            cbits/piggie.h"
17:22:26 <kmc> the iPhone unfortunately doesn't really support any beginner-friendly languages
17:22:29 <kmc> but a lot of people manage anyway
17:22:30 <Bynbo7> Objective-C would be best for that imo
17:22:36 <kmc> i hear Objective C is decent
17:22:41 <Veinor> objc isn't bad
17:22:42 <copumpkin> dcoutts_: do I need to do anything else to make it see the piggie.h?
17:22:49 <Veinor> cocoa can be kind of dain-bramaged though
17:22:57 <DT-1245> My friend says that using Haskell (which I was told by another programmer was a "good" language for this purpose tho tough to learn) is a silly idea for this purpose
17:23:04 <methods> hm wait if >>= is the same thing as a(b()) then why can't i just do print.plGetPosition ? 
17:23:07 <Veinor> and it still carries c type declarations, which is kind of bad for 'blocks'
17:23:12 <kmc> methods, it's not, nobody said it is
17:23:15 <Bynbo7> DT-1245: has your friend ever used haskell?
17:23:19 <copumpkin> methods: because it isn't the same thing as a(b())
17:23:22 <methods> sorry was reading this link http://blog.matthewdoig.com/?p=104
17:23:30 <kmc> (>>=) :: IO a -> (a -> IO b) -> IO b
17:23:31 * geheimdienst finds objective-c horribly verbose
17:23:43 <Veinor> it's 'like' composition
17:23:53 <Bynbo7> geheimdienst: me too. and i also never feel safe using it
17:23:59 <monochrom> >>= is not the same thing as a(b()).
17:24:03 <methods> type descriptions still completely confuse me 
17:24:16 <kmc> methods, what's confusing?
17:24:24 <geheimdienst> Bynbo7: sure, it has all the memory safety of c ... i.e. none
17:24:26 <vpalle> im whating for windows 7 phone, all my apps will be a version of query comprehensions in .net. I hope Uis are expressable in this way..
17:24:26 <DT-1245> <Bynbo> no, but he argues and I'm not sufficiently knowledgable to deal with him. Someone recommended I com on this chat to learn and ask my Q's here so I could learn more about it
17:24:28 <monochrom> wrong assumption is the only cause of confusion
17:24:34 <Bynbo7> methods: time for you to learn them then, they're vital to understanding haskell
17:24:52 <methods> so it's an IO operations that returns a to a (function that takes a and creates another IO operation that returns b) that returns an io operation that returns b ???
17:24:53 <methods> lol
17:25:03 <dcoutts_> copumpkin: yes, either include-dirs: . or include-dirs: cbits and include: piggie.h
17:25:03 <Bynbo7> geheimdienst: i miss the type safety of haskell mostly
17:25:12 <kmc> methods, "A -> B -> C" is a function that takes arguments A and B, and returns result C
17:25:20 <Veinor> kmc: :|
17:25:28 <exlevan> methods, compare types of (=<<) and ($)
17:25:28 <dcoutts_> copumpkin: there is no implicit include-dirs beyond the system defaults
17:25:33 <methods> yea that's easy .. but they get more complex 
17:25:41 <kmc> methods, so if we say (x >>= f), then x must have type "IO a" and f must have type "a -> IO b" and the result will have type "IO b"
17:25:48 <dcoutts_> copumpkin: in particular . is not in the include-dirs by default
17:25:48 <copumpkin> dcoutts_: hmm, tried those before and it didn't work
17:26:20 <copumpkin> dcoutts: http://hpaste.org/44500/bad_header
17:26:25 <methods> so 'a/b' is just a place holder for any type right ?
17:26:29 <kmc> methods, yep
17:26:37 <hpaste> copumpkin pasted "bad header"  http://hpaste.org/44500
17:26:43 <methods> why do they use a and b though ? i think i've seen times where there is multiple a's 
17:26:47 <copumpkin> hpaste: damn right I did
17:26:56 <Veinor> if there's multiple a's, they have to be the same type
17:26:58 <kmc> methods, if you use 'a' twice then it has to be filled with the same type in both places
17:27:00 <roconnor> is there a symbol for fmap ($b) ?
17:27:04 <roconnor> $> ?
17:27:08 <dcoutts_> copumpkin: and when you follow the suggestion the error message gives, what do you find?
17:27:10 <monochrom> you could use i and j if you like. IO i -> (i -> IO j) -> IO j
17:27:17 <methods> i try to visualize sometimes how the compiler can convert a statement into strings of functions with 1 argument and it kind of alludes me 
17:27:26 <roconnor> @type \b -> fmap ($b)
17:27:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
17:27:40 <methods> yea but does that mean that the previous statement implied that 'a' and 'b' can never be the same ?
17:27:43 <kmc> methods, no
17:27:45 <djahandarie> @type flip
17:27:46 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:27:48 <kmc> just that they don't have to be the same
17:27:48 <copumpkin> dcoutts_: oh silly me :P
17:27:52 <copumpkin> dcoutts_: nevermind :)
17:27:53 <roconnor> @hoogle a -> f (a -> b) -> f b
17:27:54 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
17:27:54 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
17:27:54 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:27:54 <djahandarie> roconnor, flip flip!
17:28:05 <dcoutts_> copumpkin: so what was wrong?
17:28:28 <copumpkin> my own header file couldn't find the foreign library header I needed
17:28:57 <dcoutts_> copumpkin: ok, so error during the cpp phase
17:29:19 <dcoutts_> copumpkin: ok, so the error message is technically correct and yet not all that helpful :-)
17:29:35 <copumpkin> dcoutts_: it was _very long_ :P
17:29:51 <copumpkin> but if I'd paid more attention to it
17:29:52 <methods> ok I was able to figure this out from what I know so far   mapM_ (\b -> plGetPosition b >>= print) bodies
17:29:57 <copumpkin> I wouldn't have had to ask :P
17:30:04 * copumpkin castigates self
17:30:13 <vpalle> how come #haskell is so frequented, #sml is a sad affair..
17:30:14 <monochrom> that's nice.
17:30:30 <methods> seriously that little 1 line there took up about an hour lol
17:30:36 <kmc> hehe, welcome to Haskell
17:30:43 <dcoutts_> copumpkin: aye, it used to be shorter but that caused confusion because it left out the not-so-uncommon case of the header existing but being bad
17:30:43 <copumpkin> vpalle: we try hard to be nice, and people like to stick around
17:31:09 <monochrom> that is more a function of learning skill than programming skill
17:31:13 <geheimdienst> also, we have lambdacats
17:31:19 <kmc> on the good days it's "that one line took an hour to write but it does the work of 30 lines of java"
17:31:27 <methods> kmc i guess where i was getting hung up is i would try to do print.plGetPosition instead of plGetPosition >>= print .. not sure though still why the first couldn't work but the former does
17:31:33 <roconnor> @type <$
17:31:33 <lambdabot> parse error on input `<$'
17:31:35 <kmc> the types are wrong methods
17:31:36 <roconnor> @type $>
17:31:36 <vpalle> copumpkin: indeed, such good manners :)
17:31:37 <lambdabot> parse error on input `$>'
17:31:42 <roconnor> @type (<$)
17:31:43 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
17:31:47 <kmc> methods, when you have a question like that, you should ask GHCi for the types of (.) and (>>=)
17:31:48 <kmc> :t (.)
17:31:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:31:51 <kmc> :t (>>=)
17:31:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:31:58 <methods> kmc I did.. but it's confusing still 
17:32:11 <c_wraith> :t (>=>)
17:32:12 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:32:15 <kmc> you didn't understand the types, if you still think they do the same thing
17:32:20 <kmc> because the types are manifestly different
17:32:25 <c_wraith> err, I meant <=<, I suppose
17:32:25 <kmc> :t (Prelude..) -- this is GHCi's (.)
17:32:26 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:32:45 <zzing> Does anyone know where I can find a job ad that is somewhere between software development and engineering? I have an English assignment that needs one :-}
17:33:00 <Mathnerd314> google?
17:33:04 <monochrom> learn logic. it helps understand types.
17:33:04 <methods> yea i was trying this    mapM_ (print.getPosition) bodies
17:33:21 <c_wraith> methods, you probably wanted <=< instead of .
17:33:25 <kmc> methods, what's the type of "print"? and what's the type of "getPosition"
17:33:35 <zzing> Mathnerd314: I was afraid that would be full of crappy results.
17:33:40 <methods> lol ... ok let me read what <=< i 
17:33:41 <methods> is
17:33:49 <kmc> :t (<=<)
17:33:50 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
17:33:51 <kmc> :t (Prelude..)
17:33:52 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:34:06 * wagle ponders the universe in which cabal upgrade would work
17:34:07 <monochrom> You could replace m by IO here.
17:34:21 <kmc> methods, do you understand that T is a totally different type from "IO T"?
17:34:30 <methods> kmc: well i posted this link earlier today which showed me trying to figure out the types  https://gist.github.com/bd9dabfed5a4d777b165
17:34:31 <roconnor> wagle: it is a universe similar to nix
17:34:42 <dcoutts_> roconnor, wagle: right
17:34:55 <vpalle> huge amount of type signatures in here :) .. perhaps that account of the general coherence. Hard to make friends in a dynamically typed channel? where everything is arguable..
17:35:00 <methods> kmc yea .. IO T is an action right ? and it's an IO event that produces a T
17:35:05 <kmc> right
17:35:20 <zzing> vpalle: :-)
17:35:21 <kmc> so if you have «A -> IO B» and «B -> IO C» then (.) is no use
17:35:22 <roconnor> methods: have you seen IO_Semantics?
17:35:25 <kmc> which is plain from its type
17:35:26 <roconnor> @wiki IO_Semantics
17:35:26 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
17:35:28 <dcoutts_> roconnor, wagle: but it's also a universe where people specify version constraints in .cabal files correctly
17:35:33 <kmc> because B ≠ IO B
17:35:34 <methods> i will now
17:35:39 <copumpkin> dcoutts_: surely not!
17:35:57 <dcoutts_> copumpkin: parallel universe
17:36:12 <copumpkin> to ensure avoidance of success, I always make a point of never specifying upper bounds and using conflicting versions where possible
17:36:21 <monochrom> I don't think we are ready to get into IO semantics when we can't even match up types.
17:36:26 <wagle> dcoutts_: i figured stuff like that
17:36:27 <roconnor> copumpkin: *lol*
17:36:40 <monochrom> like I said, unification eludes humans
17:36:45 <roconnor> monochrom: oh sorry
17:37:07 <methods> c_wraith: so <=< is just the prefix version of >>= apparently ?
17:37:27 <c_wraith> methods: no, it's different.  It composes two functions that return monadic values
17:37:33 <methods> yea i like this better cause I don't need to create the temp var     mapM_ (print <=< plGetPosition) bodies
17:37:39 <roconnor> @src (<=<)
17:37:39 <kmc> instead of guessing you should look at the types
17:37:39 <lambdabot> Source not found. It can only be attributed to human error.
17:37:39 <c_wraith> methods: the closest analogue is .
17:37:55 <methods> ah so it's the monad version of . ?
17:37:56 <kmc> what (<=<) does is pretty much determined by its type
17:37:57 <wagle> i imagined some sort of type checking that didn't allow you to specify the constraints incorrectly
17:38:07 <kmc> methods, yeah, basically
17:38:21 <methods> :\ kinda weird that you need monad versions of everything ? 
17:38:24 <wagle> s/type/static
17:38:29 <djahandarie> @djinn (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
17:38:29 <lambdabot> -- f cannot be realized.
17:38:34 <monochrom> not everything
17:38:37 <djahandarie> Lies
17:39:14 <kmc> methods, not weird, because composing functions is a totally different operation from applying a function *and* executing the result *and* feeding that into another function *and* executing its result
17:39:15 <methods> couldn't they just have used map instead of mapM but based on given presence of a monad it would act differently ? 
17:39:36 <kmc> methods, yes, at the expense of making the type system much uglier and more complicated and harder to reason with
17:39:38 <methods> just wondering..
17:39:50 <monochrom> they could. they went to #sml.
17:39:55 <copumpkin> @djinn (forall a. m (m a) -> m a) -> (forall a b. (a -> b) -> m a -> m b) -> (b -> m c) -> (a -> m b) -> a -> m c
17:39:55 <methods> lol ?
17:39:55 <lambdabot> -- f cannot be realized.
17:40:11 <c_wraith> :t let thing f g x = g x >>= f in thing
17:40:12 <lambdabot> forall a (m :: * -> *) b t. (Monad m) => (a -> m b) -> (t -> m a) -> t -> m b
17:40:14 <kmc> methods, Haskell's IO is good not because it's "monadic", whatever that means, but because IO actions are first-class values that are treated no differently from any others
17:40:23 <kmc> this is /extremely/ powerful
17:40:25 <monochrom> using the same "map" to do both pure things and IO things. that's sml, no?
17:40:45 <kmc> if you are thinking of IO merely as a "tag" attached to "impure values" then you're not thinking about it correctly
17:41:39 <kmc> the recipe is not the cake
17:41:51 <geheimdienst> > cake
17:41:52 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
17:41:53 <methods> oh while i have some attention any idea why Physics.Bullet apparently requires Graphics.Rendering.OpenGL ? 
17:42:06 <c_wraith> Types like IO (IO ()) are really handy.
17:42:30 <methods> I think I actually bumped into something that was like [IO (IO())]
17:42:35 <kmc> yep
17:42:46 <kmc> i've quite often used IO (String -> IO ())
17:42:52 <kmc> and IO (IO a -> IO a)
17:42:55 <c_wraith> that looks like a logger
17:42:57 <kmc> yep
17:42:59 * JaffaRecipe is naughty but not JaffaCake
17:43:02 <kmc> those are the types of two useful concurrency primitives
17:43:11 <kmc> in fact it really should be IO (forall a. IO a -> IO a)
17:43:19 <copumpkin> impredicative types!
17:43:20 <copumpkin> yay
17:43:41 <kmc> i think SPJ's Beautiful Concurrency paper has some kind of insane nesting of STM and IO that also turns out to be quite useful
17:43:43 <methods> is forall a real loop construct ?
17:43:51 <kmc> methods, it is not a loop
17:43:55 <kmc> what would a loop in types even mean?
17:43:59 <c_wraith> No, the forall refers to the types a can take
17:44:03 <monochrom> sudo'make'me'a'logger :: IO (String -> IO ())
17:44:06 <monochrom> sudo'make
17:44:06 <copumpkin> unify a with f a
17:44:12 <methods> lol .. i didn't think haskell had them anyway i just ave no idea what it is 
17:44:16 <kmc> it's part of the syntax of types, accepted by GHC when certain language extensions are enabled
17:44:18 <monochrom> sudo'make'me'a'forker :: IO (IO a -> IO a)
17:44:42 <monochrom> oh wait, not forker, some wrapper
17:44:46 <methods> does IO (String -> IO ()) return () in the end ?
17:44:47 <kmc> methods, Haskell can express all the standard loops but there's no reason to bake them into the language, since we can do higher-order programming easily
17:45:04 <kmc> it doesn't return anything.  it's not a function.
17:45:14 <methods> :\ i thought everything was a function
17:45:17 <kmc> nope
17:45:20 <kmc> who told you that?
17:45:27 <methods> i know that's a type definition ..
17:45:30 <kmc> http://conal.net/blog/posts/everything-is-a-function-in-haskell/
17:45:43 <kmc> methods, it's not a function's type because it's not of the form A -> B
17:45:53 <kmc> it's an IO action type, because it's of the form IO A
17:45:56 <methods> hm
17:46:02 <monochrom> you want "functions are important in haskell"
17:46:15 <kmc> a value of type "IO (String -> IO ())" is an IO recipe which, if executed, would produce a function of type "String -> IO ()"
17:46:36 <kmc> a value of type "String -> IO ()" is a function which, if handed a String as an argument, returns an IO recipe of type "IO ()"
17:46:51 <kmc> a value of type "IO ()" is an IO recipe which, if executed, does some IO and produces no useful value
17:47:03 <methods> ah yes so i was sorta right!
17:47:15 <kmc> methods, a key idea here is that "evaluate"/"apply" is totally distinct from "execute"
17:47:29 <kmc> the former is what we do to functions, the latter is what we do to IO actions
17:47:51 <methods> yes i understand you can pass around IO actions that never get executed until they are in an IO context right ? like the main :: 
17:48:04 <kmc> it's not about context
17:48:07 <kmc> the only IO action which is ever executed is "main"
17:48:20 <kmc> (or if you type one at the GHCi prompt)
17:48:35 <ion> IO actions are just values, and the only way they’re ever interpreted is by assigning an IO action to main one way or another.
17:48:53 <kmc> that's why (>>=) is important: it takes two actions and glues them together to make a composite action
17:48:59 <roconnor> monochrom: is it time for IO semantics now?
17:49:06 <kmc> and in fact it does more than that: it lets you use the "result" of the first action to decide the second thing to do
17:49:13 <c_wraith> ion: the usual terminology for that is executed, rather than interpreted.  As distinct from evaluated. :)
17:49:31 <monochrom> it is, but it's being done now too. beware of too-many-chefs.
17:49:37 <roconnor> ok
17:49:37 <ion> Wait. Why did i write “interpreted”? A brainfart from thinking about ghci at the same time. :-D
17:49:59 <kmc> ion, it's a pretty reasonable verb to use
17:50:05 <monochrom> I guess 2 is still not too many :)
17:50:07 <methods> bb in a minute
17:50:58 <monochrom> "interpreted" does not hurt
17:52:04 <monochrom> but tomorrow the reddit headline will be like "news: now we know why haskell is slow, because only values are compiled while IO is interpreted"
17:52:16 <kmc> haha
17:55:49 <confound> are you saying that's not true???
17:58:58 <copumpkin> confound: yeah
17:59:06 <copumpkin> at least with GHC
17:59:27 <copumpkin> but you can't tell the difference
17:59:37 <kmc> semantically it is totally reasonable to think of "IO T" as being represented by some concrete "sequence of steps" data type, with an interpreter in the runtime system (necessarily not written in Haskell) which reads that value and executes the steps one by one
18:00:02 <confound> copumpkin: I was joking, anyway
18:00:05 <kmc> and (>>=) is used to glue these together
18:00:08 <copumpkin> :)
18:00:13 <confound> copumpkin: HA HA.
18:00:15 <kmc> what GHC does internally is totally different
18:01:11 <kmc> GHC starts with "unsafe" primitive IO operations (i.e. side-effect-having functions) and builds the safe public IO API around those
18:01:53 <kmc> the irony is that, despite public misinformation, Haskell's type system has no special way to manage or track side-effectful functions and so that layer of code is rather tricky
18:03:08 <revenantphx> kmc: I recall ML or something actually having some sort of distinction?
18:03:17 <revenantphx> I don't remember... I haven't ever actually used ML, heh.
18:03:42 <monochrom> ML has even less distinction. Clean has more distinction.
18:05:07 <revenantphx> ah that was it.
18:06:00 <revenantphx> It seems the syntax haskell uses is somewhat pervasive.
18:06:14 <revenantphx> or rather, lack of syntax (in terms of symbols and such)
18:07:25 <vpalle> I'll wrap up in a nce monad now, keeping me safe from any unwarrented sideeffects.. sleep tight..
18:08:21 <kmc> revenantphx, how do you mean?
18:08:36 <revenantphx> mainly just type annotations
18:08:41 <revenantphx> and the X -> Y -> Z style
18:08:56 <kmc> you can credit/blame ML for that
18:09:01 <revenantphx> ah okay
18:09:19 <kmc> Haskell grew out of Lazy ML
18:09:35 <kmc> ML and Haskell exchange the roles of operators : and :: though
18:09:40 <revenantphx> Yeah.
18:09:44 <revenantphx> I noticed that in Agda too I believe?
18:09:52 <kmc> yeah
18:10:08 <kmc> Agda has more type annotations in more places so i guess they wanted the shorter symbol
18:10:16 <revenantphx> By the way, this might be a bit off topic,
18:10:32 <revenantphx> but what schools do you think I should take a look at if i'm interested in the more theoretical side of computer science?
18:10:39 <revenantphx> (basically, staying away from Java 101)
18:10:48 <accel> is there a hasekll platform with 7.0.2 yet?
18:10:50 <revenantphx> (as much as possible, i know it isn't entirely possible)
18:11:00 <revenantphx> accel: There's not even one with 7.0.1 to my knowledge...
18:11:10 <btutt> Grad Schools
18:11:28 <revenantphx> btutt: I'm asking about undergraduate programs.
18:11:38 <revenantphx> I don't want four years of database management and how to write enterprise software.
18:11:40 <revenantphx> I really dont.
18:11:40 <accel> yeah; but 7.0.1 was not a "main release"
18:11:44 <accel> i.e. it was just dev
18:11:55 <accel> whereas 7.0.2 seems like "yes, we worked out the bugs; so we can release a platform based on it"
18:12:00 <monochrom> there will be a haskell platform with 7.0.2.
18:12:13 <revenantphx> By the way
18:12:16 <btutt> They have that? "normal" undergrad db classes suck since they're not practical at all
18:12:17 <revenantphx> who manages the staging page?
18:12:20 <revenantphx> I redid the CSS for it.
18:12:23 <revenantphx> And made it much nicer.
18:12:28 <kleinucopia> revenantphx: stay away from Rochester Institute of Technology.
18:12:28 <Jonno_FTW> in the repo for the haskell packages in debian, what are all the profiling libraries for?
18:12:34 <kmc> accel, GHC 7.0.2 came out today
18:12:37 <accel> speaking of 7.0.1 bugs; who the fuck manages to createa bugs in haskell? doesn't that require some type of abomination?
18:12:38 <revenantphx> kleinucopia: You're not the first to say that Xd.
18:12:39 <kleinucopia> although I guess they're trying to steer away from Javaland.
18:12:59 <kleinucopia> revenantphx: but I still wouldn't go there if I were you for other reasons
18:13:09 <kmc> revenantphx, the schools i know best have changed their curricula radically since i / people I know left :/
18:13:13 <revenantphx> kleinucopia: I've seen their curriculum. Completely uninterested
18:13:15 <monochrom> 7.0.1 bugs merely required a new type-checker
18:13:22 <kleinucopia> revenantphx: if only I had known.
18:13:27 <revenantphx> I'm thinking I'm going to almost certainly end up in a research course.
18:13:32 <revenantphx> research school*
18:13:36 <accel> i heard there was a big rewrite form 6.12 to 7.0.1
18:13:37 <revenantphx> to find good courses.
18:13:42 <roconnor> @free forall a. a -> a
18:13:42 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
18:13:42 <accel> so basically, if i'm reading soure, i should go tread 7.0.2
18:13:45 <accel> and ditch 6.12 ?
18:13:48 <roconnor> @free x :: forall a. a -> a
18:13:48 <lambdabot> f . x = x . f
18:13:51 <revenantphx> I have 7.0.1, so dunno
18:14:02 <kmc> people keep asking us what to do without saying what their goals are
18:14:07 <ion> What does @free do?
18:14:16 <roconnor> @free x :: forall f. (forall a. a -> b -> f a -> f b) -> (b -> f b) -> f a
18:14:17 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
18:14:21 <kleinucopia> you would think more schools would use haskell. A course using The Haskell Road would probably be a good replacement for both CS 101 and Discrete math in most schools.
18:14:22 <aavogt> @free lunch :: a -> a
18:14:23 <lambdabot> f . lunch = lunch . f
18:14:28 <accel> kmc: my goal is to find a ghc version, raed it's source, and do hacks to allow explicit sharing/laziness control
18:14:38 <kmc> then probably you should start with the latest version
18:14:51 <revenantphx> kleinucopia: bleh, I just want to get away from javaland, as you put it.
18:14:53 <accel> kmc: but i'm also lazy; so I want a haskell platform version to installl
18:14:54 <jeffz> kleinucopia: I tried to install the haskell platform at school today to show another student how to program in haskell, unfortunately the installer requires admin access :/
18:15:01 <jeffz> http://trac.haskell.org/haskell-platform/ticket/62
18:15:16 <kmc> accel, you are not going to complete this project if you are lazy.
18:15:31 <accel> kmc: why not; i'll impelment a feature only when it's needed
18:15:39 <accel> kmc: until then, i'll store a promise to do it at some future date
18:15:41 <revenantphx> accel: Download 7.0.2 from source, compile it.
18:15:48 <revenantphx> Then install newest version of cabal-install from source.
18:15:58 <revenantphx> Same as any other program.
18:16:14 <accel> how do I nuke 6.12?
18:18:43 <Evious> halp http://hpaste.org/44501/crazy_ghci_crash
18:18:59 <hpaste> Evious pasted "crazy GHCi crash"  http://hpaste.org/44501
18:19:02 <Evious> I've got a scary linker error when loading a module in GHCi, and I don't know where to begin fixing it.
18:19:50 <accel> hmm
18:19:57 <monochrom> you have too many versions of the network package
18:20:04 <accel> can I just setup an ssh account and have smoenoe insatll ghc 7.0.2 for me?
18:20:56 <dmwit> Really?
18:21:05 <dmwit> It's just ./configure && make install, as usual.
18:21:13 <monochrom> do you mean "tar -xjf ghc-7.0.2-i386-unknown-linux.tar.bz2" and "make install"?
18:21:42 <dmwit> Perhaps. Earlier binary installers needed a configure step, I thought.
18:21:50 <monochrom> but why don't I take this opportunity to milk you. I charge cdn$1000 for this service.
18:21:59 <dmwit> As for tar, that's just such an unconscious part of the process by now... =P
18:22:13 <accel> http://hackage.haskell.org/platform/linux.html ... where are the 7.0.2 sources
18:22:15 * Saizan still runs configure
18:22:17 <monochrom> actually ./configure is also unconcious
18:22:23 <accel> do I need to rrun this thing called git?
18:22:30 <blackdog> anyone played around with 7.0.2 on mac and know whether it's an x86_64 build like the macports version?
18:22:33 <Evious> Oh cool, that was a quick fix. ghc-pkg unregister'd a random network package and it works now.
18:22:34 <Evious> Kaplah!
18:22:36 <dmwit> tar; ls; configure; make
18:22:38 <thoughtpolice> blackdog: it's not
18:22:58 <dmwit> accel: Do you really want sources?
18:23:01 <blackdog> thoughtpolice: ah. damn. deliberate, or just didn't make it in?
18:23:02 <monochrom> ghc source is not on hackage. go to http://www.haskell.org/ghc/download_ghc_7_0_2 and scroll scroll scroll
18:23:29 <monochrom> you don't need git yet until you have something to submit
18:23:31 <thoughtpolice> blackdog: just didn't make it in, I think GHC proper still needs some work to get x86_64 os x working, the builds on macports are kinda magical from what i understand
18:24:11 <accel> downloading ....
18:24:16 <accel> what's a tar.bz2?
18:24:18 <monochrom> http://www.haskell.org/ghc/download_ghc_7_0_2#macosx_x86_64 may have 7.0.2 on mac for 64 bit
18:24:18 <dmwit> accel: I haven't been following along, so you could have already said that you definitely want to install from source. But in case you didn't, why not just grab the binary installer from http://www.haskell.org/ghc/download_ghc_7_0_2 ?
18:24:38 <monochrom> do you know tar? do you know bz2? then compose.
18:24:54 <accel> running ./configure
18:24:57 <dmwit> accel: A .tar.bz2 is a compressed (via bzip) tarball (which contains a directory full of files). It's similar to a .zip if you're from the Windows world.
18:25:04 <accel> all this green text flying by; I feel like I'm in the amtrix
18:25:19 <accel> is HsColour important?
18:25:28 <monochrom> no
18:25:31 <accel> I actually want to build the PDF documentation for 7,0,2
18:25:44 <accel> okay; typed "make"
18:25:52 <accel> so it's compling 7.0.2 with 6.12 ?
18:26:04 <accel> on MacOSX, what's the right way to nuke 6.12? (I'm cmoe froma ubuntu background)
18:26:08 <accel> i.e. what's apt-get remove ...
18:26:35 <dmwit> You don't need to nuke 6.12.
18:26:46 <accel> I would like to
18:26:50 <accel> as a matter of personal perference
18:26:56 <dmwit> If you grabbed the binary distribution, then no, it is not compiling 7.0.2 with 6.12.
18:27:04 <accel> i grabbed the source
18:27:17 <accel> crap; should I have done make -j 32
18:27:18 <monochrom> dmwit: context says accel wants to modify ghc
18:27:20 <accel> to have it use all my processors?
18:27:33 <accel> I want to write a ghc optimization pass
18:27:37 <Bynbo7> only if you have 32GB of RAM
18:27:38 <accel> that may or may not require modifying GHC sources
18:27:58 <accel> depending on whether are easy ways to write plugins
18:28:08 <dmwit> hokay
18:28:10 <Bynbo7> you're kidding me right?
18:28:31 <accel> Bynboy7: hey how are you? thanks for the suggestion to read RWH
18:28:41 <accel> what am I kidding about?
18:28:42 <dmwit> How to nuke 6.12 depends on how you installed it.
18:28:55 <monochrom> you will also need to read and bookmark http://hackage.haskell.org/trac/ghc/ which is linked from ghc home page
18:29:02 <accel> if you thought I was annoying before I read RWH; just think how annoying I'll be asking about ghc internals
18:29:20 <dmwit> You'll probably have better luck with that in #ghc. ;-)
18:30:33 <accel> are most of the key ghc developers in glasglow university / england, or are they fairly uniformly distributed across the world now?
18:30:48 <copumpkin> they're in cambridge (the original one)
18:30:52 <copumpkin> or oxford
18:31:00 <copumpkin> none in glasgow anymore as far as I know
18:31:17 <accel> hmm; but still concentraed in the british universities?
18:31:31 <dmwit> MSR, I guess
18:32:01 <accel> oh right; simon peyton jones
18:32:16 <accel> man this compilation process is slow
18:32:22 <copumpkin> bos: text doesn't install on GHC HEAD :)
18:32:30 <copumpkin> same reason as everything else breaks on GHC HEAD
18:32:41 <copumpkin> (bang patterns)
18:35:45 <accel> why does this take so long to install
18:35:55 <accel> can I compile ghc over ec2?
18:36:13 <Bynbo7> yes, google it
18:36:15 <copumpkin> nobody except GHC developers compiler GHC themselves
18:36:18 <revenantphx> accel: If it's not capable of being parallel built, probably won't help much though?
18:36:18 <copumpkin> -r
18:36:25 <copumpkin> revenantphx: it is though
18:36:30 <dmwit> So what is the compile-time at these days? Is it down to a few hours?
18:36:31 <revenantphx> http://hackage.haskell.org/trac/ghc/wiki/AmazonEC2
18:36:32 <revenantphx> wow.
18:36:33 <revenantphx> lol.
18:36:43 <accel> dmwit: you're kidding about the few hours right?
18:36:44 <copumpkin> dmwit: wahy less than that
18:37:00 <accel> a few hours .... is like bootstrapping gentoo
18:37:03 <dmwit> Oh, cool.
18:37:03 <copumpkin> on my four-core box I had it taking 20 minutes or so with -j5 or something
18:37:16 <copumpkin> accel: why you compiling your own?
18:37:37 <accel> because people in IRC told me to do so and I trust them
18:37:55 * copumpkin wonders how much petroleum has been wasted by people (gentoo, macports, fink, etc.) recompiling shit unnecessarily
18:39:42 <Saizan> copumpkin: he wants to hack on ghc
18:39:58 <copumpkin> oh
18:40:00 <copumpkin> ok
18:42:16 <accel> yeah; I actually want to do something productive
18:42:21 <accel> instead of pissing people off asking for ops
18:42:25 <accel> or asking questions covered in RWH
18:43:13 <accel> i figure that I can better waste the haskell community's time by writing broken haskell modules that appear to work (but are fundamentally broken an dwould take complete rewrites to fix)
18:43:52 <Zao> accel: Sounds sufficiently evil.
18:44:21 <btutt> how about secretly hack hackage with the output from pl :)
18:45:00 <accel> what's pl?
18:45:12 <Zao> @pl \x -> x * x + x
18:45:12 <lambdabot> (+) =<< join (*)
18:45:16 <kmc> yesssss cloud build everything!
18:45:22 <kmc> does anyone have a cloud build extension for gentoo yet
18:45:26 <dmwit> ?pl \x y z -> z (x y y) (x y y) x y y
18:45:27 <lambdabot> join . (flip .) . join . (flip .) . (flip =<< (flip .) . ap (ap . ((flip . flip id) .) . join) join)
18:45:49 <Zao> kmc: Considering how their distcc was horribly broken last I tried using it, I wouldn't expect so.
18:45:50 <accel> EC2 was invented because bezos could not compile gentoo fast enough. [probabl not]
18:46:13 <accel> does gentoo paralleizeli all that well
18:46:18 <Jonno_FTW> @src join
18:46:18 <lambdabot> join x =  x >>= id
18:46:20 <accel> i feel for the initial packages, there's quite a strong sequential dependency
18:46:21 <Zao> accel: Not really.
18:46:25 <Zao> At all.
18:46:26 <Jonno_FTW> @srcap
18:46:26 <lambdabot> Maybe you meant: slap src
18:46:28 <Jonno_FTW> @src ap
18:46:28 <lambdabot> ap = liftM2 id
18:46:41 <Zao> Of course, that doesn't stop the plebs from doing -j9001 in their global flags.
18:46:44 <napping> is there any way to compose two functions in a Dynamic?
18:46:55 <napping> (.) is too polymorphic for dynApp to work right
18:46:58 <accel> why -j9001? I do -JINT_MAX
18:47:04 <kmc> INT_MAX*4
18:47:19 <napping> -j1335?
18:47:29 <kmc> accel, have fun allocating 2^32 of pthreads's 2MB stacks
18:48:38 <copumpkin> napping: hm, don't think so, unless you can make the types fit before you put the (.) in
18:49:11 <napping> or add a new primtive
18:49:15 <napping> darn
18:54:59 * hackagebot thrift 0.6.0 - Haskell bindings for the Apache Thrift RPC system  http://hackage.haskell.org/package/thrift-0.6.0 (ChristianLavoie)
18:58:08 <Jonno_FTW> @src gcd
18:58:08 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
18:58:08 <lambdabot> gcd x y = gcd' (abs x) (abs y)
18:58:08 <lambdabot>    where gcd' a 0  =  a
18:58:08 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
19:11:27 <accel> ghc still compiling
19:11:32 <accel> is this some type of patientce torture test
19:11:37 <accel> for all the stupid questions I've asked here?
19:12:00 <copumpkin> how -j did you make it?
19:12:05 <dmwit> ?faq is this some type of patience torture test
19:12:05 <lambdabot> The answer is: Yes! Haskell can do that.
19:12:05 <accel> make -j3
19:12:12 <accel> dualcore mac mini
19:12:15 <accel> 4GB RAM
19:12:17 <copumpkin> hahhh
19:12:20 <copumpkin> whoa
19:12:24 <copumpkin> that wasn't what I meant to write :P
19:12:34 <copumpkin> it was suppose to be "ah" :P
19:12:39 <copumpkin> *supposed
19:12:41 <accel> it's okay; just don't do that at funerals
19:12:44 <copumpkin> man, my typing is terrible
19:12:53 <copumpkin> well, it's unfortunate, because my H key is hypersensitive
19:12:55 <accel> done
19:12:56 <accel> sudo make install
19:12:58 <copumpkin> I should clean it up
19:13:53 <accel> ghci
19:13:53 <accel> GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help
19:13:54 <accel> fuck
19:13:58 <accel> how do I get ghc 7.0.2 ?
19:14:15 <accel> ghci-7.0.2 
19:14:16 <accel> GHCi, version 7.0.2: http://www.haskell.org/ghc/  :? for help
19:14:16 <accel> I win
19:14:39 <accel> can I "cabal install cabal-install" ?
19:14:44 <accel> or do I have to compile that from source too?
19:15:31 <copumpkin> accel: once you have it, you can do that to update it :)
19:15:34 <dmwit> You might want to link the usual suspects to their new counterparts first.
19:15:40 <dmwit> ghc-pkg, in particular
19:15:42 <accel> anything besides ghc and ghci?
19:15:53 <copumpkin> but the first time around, you fetch the tarball and run boostrap in there
19:16:02 <copumpkin> bootstrap will grab cabal-install's dependencies and install it for you
19:17:01 <accel> hang in
19:17:02 <accel> what is bootstrap
19:17:04 <accel> what command do I type
19:17:12 <accel> is this in the ghc-7.0.2 make directory  or part of cabal?
19:17:18 <accel> also I have a buch of crap in ~/.cabal compiled with 6.12
19:17:19 <dmwit> It's part of cabal-install.
19:17:22 <copumpkin> grab http://hackage.haskell.org/packages/archive/cabal-install/0.10.0/cabal-install-0.10.0.tar.gz
19:17:26 <copumpkin> unpack it
19:17:33 <copumpkin> and there's a bootstrap (.sh?) in there
19:17:34 <copumpkin> just run that
19:17:35 <accel> do I need to nuke my old cabal from 6.12 ?
19:17:41 <copumpkin> if you have that, then just use that one
19:17:48 <copumpkin> you only need bootstrap if you have nothing
19:17:52 <dmwit> But you clearly already have cabal-install, so you should just cabal install cabal-install, like you suggested at the very beginning.
19:18:11 <accel> cabal install cabal-install
19:18:11 <accel> Resolving dependencies...
19:18:12 <accel> cabal: dependencies conflict: process-1.0.1.5 requires directory ==1.1.0.0
19:18:12 <accel> however
19:18:13 <accel> directory-1.1.0.0 was excluded because Cabal-1.8.0.6 requires directory >=1 &&
19:18:13 <accel> <1.1
19:18:19 <copumpkin> <3
19:18:32 * copumpkin wants to write vector <3 in his dependencies
19:18:52 <accel> this is so weird; I'm not asking for ops; people are not pissed off at me; and we're having a useful, civilized conversation
19:19:01 <copumpkin> accel: it's actually possible!
19:19:04 * copumpkin hugs accel 
19:19:21 <accel> "cabal update; cabal install cabal-install" appears to be working
19:19:23 * tg_ pulls the handle on the haskell-flamewar-slots machine
19:19:27 <copumpkin> accel: oh, you might want to cabal update first
19:19:31 <copumpkin> lol
19:19:46 <accel> is there a way to tell cabal "I just upgraded to 7.12; so recompile everything" ?
19:20:02 <copumpkin> it actually won't see any of your stuff
19:20:11 <copumpkin> it keeps packages from different versions of GHC separate
19:20:15 <copumpkin> so if you ask ghc-pkg list
19:20:22 <copumpkin> you'll only see stuff you've installed since your upgrade
19:20:24 <tg_> [monads-are-stupid] [why doesn't cabal install cabal cabal work] [Why doesn't IO, IO, in my IO, yo?]
19:20:40 <accel> interesting
19:20:41 <accel> thanks
19:20:58 <Jonno_FTW> :O
19:21:18 <Jonno_FTW> can you program in Haskell avoiding monads completely?
19:21:24 <MonadsSuck> Jonno_FTW: sure
19:21:30 <Jonno_FTW> ?faq can you program in Haskell avoiding monads completely?
19:21:30 <MonadsSuck> man, I hate it when an adjoint pair of functors get together and compose. So damn annoying
19:21:30 <lambdabot> The answer is: Yes! Haskell can do that.
19:21:53 <djahandarie> @remember MonadsSuck man, I hate it when an adjoint pair of functors get together and compose. So damn annoying
19:21:53 <lambdabot> It is stored.
19:22:02 <Jonno_FTW> even the IO monad?
19:22:13 <MonadsSuck> Jonno_FTW: yes
19:22:18 <kmc> Jonno_FTW, you can use the IO monad's (>>=) without ever noticing that it has a more general type
19:22:30 <Jonno_FTW> hmm
19:22:33 <MonadsSuck> :t interact
19:22:34 <lambdabot> (String -> String) -> IO ()
19:22:35 <kmc> Jonno_FTW, and in theory GHC could have provided a primitive "bindIO" with that specific type
19:22:38 <MonadsSuck> you can do a lot just with that thing
19:22:44 <kmc> they didn't, but it would be totally safe to do so
19:22:53 <kmc> and likewise "return"
19:22:56 <napping> it would still be a monad
19:23:30 <djahandarie> napping, but not a Monad.
19:23:30 <kmc> right and [Char] is still a monoid but anyone asking "can i print text in Haskell without using monoids" would get an answer of "yes" and/or "stop trolling"
19:23:36 <napping> maybe not a Monad
19:23:36 <napping> "if eta and nu make the following diagrams commute, but nobody points it out, is it still a monad"?
19:23:39 <accel> err, has 7.0.2 been tested on the amc? I can't install cabal-install beause "cabal-install time-1.1.4" fails
19:23:56 <MonadsSuck> accel: why such a specific time version?
19:24:00 <Jonno_FTW> what's the difference between a monad and a monoid?
19:24:04 <accel> taht's the one cabal-install tried to install
19:24:05 <accel> and died on
19:24:10 <parcs> Jonno_FTW: big
19:24:11 <MonadsSuck> Jonno_FTW: for sufficiently general notions of monoid, none
19:24:12 <Saizan> napping: it's mu!
19:24:33 <Jonno_FTW> who am I to believe here?
19:24:40 <djahandarie> Jonno_FTW, both are correct
19:24:52 <djahandarie> The Monoid typeclass in Haskell isn't sufficiently general, however.
19:24:52 <napping> the guy whose name was an allusion to category theory before the rename?
19:24:58 * Jonno_FTW head explodes
19:25:22 <djahandarie> napping, does changing my name to codjahandarie make my opinions count for more? ;)
19:25:26 <Jonno_FTW> what are the difference in the context of haskell?
19:25:29 <napping> Jonno_FTW: that's a reference to the definition "A monad is a monoid in the category of endofunctors"
19:25:50 <copumpkin> Jonno_FTW: there are two related definitions of monoid floating around
19:25:57 <Jonno_FTW> go on
19:25:57 <accel> Socket.hsc: In function ‘main’:
19:25:58 <accel> Socket.hsc:1848: error: ‘AI_NUMERICSERV’ undeclared (first use in this function)
19:25:58 <accel> S
19:26:02 <accel> from "cabal install network-..."
19:26:09 <copumpkin> abstract algebra has a monoid that's just a binary operation that's associative and has a unit (like 0 and +, or 1 and *)
19:26:18 <djahandarie> Jonno_FTW, that's like asking what the difference between a String and IO is.
19:26:21 <btutt> accel:You probably need a newer version of cabal, IIRC
19:26:22 <copumpkin> category theory has a more general (surprise surprise) notion of that concept
19:26:30 <accel> so my current version
19:26:34 <accel> of cabal is too old
19:26:37 <accel> to cabal install "cabal-install" ?
19:26:39 <copumpkin> called a monoid object (in a monoidal category)
19:26:44 <btutt> No, cabal install cabal
19:26:49 <Saizan> accel: exactly!
19:26:59 <dolio> The category theory definition is pretty much the same.
19:26:59 <Jonno_FTW> should I take a course on category theory first?
19:27:04 <btutt> Don't remember if cabal-instal revved
19:27:07 <dolio> They just don't assume that there's an underlying set.
19:27:11 <copumpkin> Jonno_FTW: there's a ##categorytheory
19:27:14 <Saizan> accel: but you've a Cabal version good enouh to install network
19:27:15 <djahandarie> copumpkin, I'm not sure this explaination is benefiting anyone.
19:27:26 <confound> Jonno_FTW: before asking that question or before programming in haskell?
19:27:27 <djahandarie> He's clearly just interested about understand Monoid and Monad.
19:27:35 <djahandarie> Not monoids and monads.
19:27:35 <Jonno_FTW> before the question
19:27:41 <accel> running ./bootstrap.sh
19:27:43 <kmc> Jonno_FTW, the simple answer is that in Haskell, Monad and Monoid are not especially related
19:27:48 <copumpkin> djahandarie: can't hurt to try to sell deeper answers :)
19:27:52 <Jonno_FTW> I can program in Haskell sufficiently without a good knowledge of monads
19:27:52 <djahandarie> copumpkin, it can.
19:28:06 <kmc> despite having similar names, they are not very similar concepts
19:28:15 <copumpkin> :(
19:28:21 <djahandarie> Flash too much of your junk and you might scare the buyers.
19:28:23 <kmc> that changes once you generalize them away from what's actually implemented in Haskell
19:28:39 * copumpkin always shows everything up front
19:29:03 <kmc> @quote HaskellLove monad
19:29:04 <lambdabot> HaskellLove says: haha fuck yeah i am ninja... anyways... when someone asks u about monads ask him is he a programmer or a mathematician... to a programer u can explain it in 5 minutes, not tell him
19:29:04 <lambdabot> how complex it is so he goes studies a hole day and at night he says : wait why the fuck do i waste time, i will never use this
19:29:20 <Jonno_FTW> I remember that guy
19:29:30 <accel> Error during cabal-install bootstrap:
19:29:31 <accel> Building the network package failed
19:29:31 <accel> (from ./bootstrap.sh) -- FUCK
19:29:35 <Jonno_FTW> he kept bugging me for help after I helped him one time
19:29:47 <kmc> he still shows up here occasionally to ask us about new topics to (not) learn
19:29:54 <Jonno_FTW> :(
19:29:58 <accel> who are we talking about? this person soudns like me
19:30:19 <Jonno_FTW> accel: HaskellLove aka ScalaLove
19:30:21 <napping> I'm glad for the equational reasoning
19:30:36 <andy_8> Hey, I'm really new to haskell and can't figure this out - can someone take a quick look at a couple lines of code and see if im missing something obvious with this function or if my error is elsewhere in my program? http://pastebin.com/pThYjKFT
19:31:23 <djahandarie> Jonno_FTW, either way, if you are interested in learning more, I'd definitely recommend LYAH. It does a good job of explaining everything step by step until you actually have enough knowledge to understand the Monad typeclass.
19:31:43 <andy_8> I'm getting expected/inferred type errors when I try to call this, not sure if its the function or the way I'm calling it
19:31:51 <btutt> LYAH does have a very good explanation, (speaking as a new Haskell user)
19:31:52 <djahandarie> It also explains Monoids, but they are fairly trivial.
19:32:02 <Jonno_FTW> djahandarie: I started reading that, then I got side tracked by my studies (namely Java)
19:32:11 <djahandarie> Poor soul.
19:32:35 <djahandarie> At least you will embrace Haskell as your savior when you come to love it.
19:32:47 <kmc> heh
19:32:54 <Jonno_FTW> it was useful to know Haskell before Java though
19:32:57 * djahandarie becomes a religious preacher
19:33:08 * Jonno_FTW is the converted
19:33:26 <Jonno_FTW> the stuff about types and looping was really useful to know
19:33:41 <Pseudonym> Are you listening, choir?  Then let's begin the preachin'!
19:33:46 <copumpkin> :)
19:34:25 <Jonno_FTW> so, have you heard the good news about monads?
19:34:30 <Saizan> andy_8: i'd say your implementation doesn't make much sense, and also it has the wrong type
19:34:32 <kmc> monads mo problems
19:34:48 <Saizan> andy_8: i.e. not the type in your paste at least
19:34:51 <kmc> a type error is just ghc's way of saying "your implementation doesn't make much sense"
19:34:56 <Pseudonym> We'd like to talk to you about the Word of Mac Lane.
19:35:04 <djahandarie> Hahaha
19:35:15 <btutt> The trickiest thing I haven't seen a good explanation of is how the bits of Haskell parses ok . vs $ vs \ Ugh. I probably end up writing too many parens in my code.
19:35:35 <Pseudonym> !bj
19:35:43 <Pseudonym> Whoops.
19:35:45 <Pseudonym> Wrong window.
19:35:51 <Pseudonym> And in case anyone was curious, it was bjam.
19:35:54 <kmc> ... do i want to know what that command does?
19:35:59 <kmc> best bot ever
19:36:11 <andy_8> haskell doesn't make much sense right now so i guess it shows in my code ha. should probably try that tutorial again
19:36:14 <kmc> Pseudonym, wow, you're using bjam? what for?
19:36:28 <Pseudonym> We've standardised on bjam for our C++ here.
19:36:31 <kmc> wow
19:36:38 <kmc> i thought i worked at the only place on earth that did so
19:36:42 <Pseudonym> WoO!
19:36:44 <kmc> did you find some secret hidden documentation?
19:36:58 <Pseudonym> No.  But we don't do anything tricky.
19:37:03 <kmc> btutt, (.) and ($) are ordinary user-defined operators; you can ask GHCi for info about them with like ":i ($)"
19:37:08 <Pseudonym> But since you're here, how do you do system tests?
19:37:22 <kmc> don't know a great way
19:37:25 <kmc> also, worked, past tense :)
19:37:49 <kmc> happy to say that currently the problem of how to build all my C++ code is a vacuous problem :)
19:37:59 <kmc> i find "true" is an excellent build tool in this case
19:38:14 <kmc> btutt, the Haskell report explains how to understand the "infixl" / "infixr" declarations
19:38:17 <Pseudonym> There are a bunch of Boosters working on CMake at the moment.
19:38:27 <Pseudonym> I suspect bjam may be history soon.
19:38:38 <kmc> but basically, higher numbers bind tighter; l/r specifies associativity
19:38:51 <kmc> i do agree with the "when in doubt, use parentheses" approach though
19:38:54 <btutt> Infix right assoc vs left assoc and operator precedence ?
19:38:57 <Pseudonym> There's a lot of sense in making your build system an EDSL in some other language.
19:39:11 <kmc> Pseudonym, yep
19:39:27 <kmc> if you can't remember the precedence rules, someone else reading your code probably can't either
19:39:40 <btutt> kmc: thanks for :i that will help a bit
19:39:41 <kmc> exceptions being well-known idioms like (f . g . h $ x)
19:42:25 <btutt> is there a ghci : command that returns strictness info?
19:42:31 <btutt> (when passed a function)
19:42:32 <accel> ~/build/Cabal-1.10.1.0$ runhaskell Setup.hs build
19:42:37 <accel> when taht completes, where is the binary storeda t?
19:42:50 <accel> ./Cabal.cabal
19:42:51 <accel> ./dist/build/autogen/cabal_macros.h
19:42:54 <accel> I don't see the binary
19:43:01 <copumpkin> just runhaskell Setup.hs install
19:43:03 <btutt> i.e. :s f or something that says f is strict in a -> b (but not the -> c) ?
19:43:15 <accel> or sudo runhaskell Setup.lhs install ?
19:43:22 <copumpkin> yeah, I guess
19:43:24 <copumpkin> depends where you want it
19:43:28 <accel> I did a sudo
19:43:35 <accel> but I can't find it in /usr/local/
19:44:16 <kmc> btutt, not to my knowledge, and it's impossible for the compiler to be certain about which functions are strict
19:44:31 <kmc> but it could in principle keep some of its heuristic strictness analysis info around for this purpose
19:44:35 <btutt> oh sure. but it'd sure be nice. :)
19:44:39 <kmc> i bet that info is in the .hi files and some tool could theoretically read it
19:46:23 <methods> is it possible to do this in a one liner ? http://pastebin.com/4PS389n4
19:46:39 <greap> Is haskell platform moving to ghc 7 any time soon?
19:46:58 <djahandarie> methods, yes, desugar the do notation.
19:47:40 <aavogt> or just use    do {a ; b}
19:47:40 <copumpkin> I love that when I have callbacks from c to haskell, I don't have to pass those ugly void * "user data" parameters around
19:47:43 <djahandarie> greap, very soon.
19:47:51 <shachaf> printBodyNamePos (name,body) = do { print name; plGetPosition body >>= print }
19:47:57 <accel> cabal 0.10.0 installed
19:48:00 <accel> victory is ine
19:48:00 <btutt> Sure would be nice if the type inference/checker differentiated in the error messages between previously inferred results and an explicit type signature. 
19:48:02 <accel> bow before me
19:48:06 <djahandarie> I don't really consider that a one-liner to be honest
19:48:08 <shachaf> You can make anything into a "one-liner". It's not very meaningful, though.
19:48:20 <methods> yea i mean in one statement ... why can't i just do  print name ++ (plGetPosition body) or something
19:48:21 <shachaf> djahandarie: Sure, but (>>) is equivalent to that.
19:48:24 <kmc> clearly ; is an alternate way to spell "\n"
19:48:36 <kmc> methods, you can't because the types are different.  String and IO String are totally different sorts of values
19:48:40 <shachaf> methods: If you want to concatenate the two strings, that's very different.
19:48:47 <accel> you can probably give the ascii code of \n
19:48:49 <accel> and stick it in a []
19:48:53 <napping> @pl (\(name,body) -> print name >> plGetPosition body >>= print)
19:48:53 <lambdabot> uncurry (flip flip print . ((>>=) .) . (. plGetPosition) . (>>) . print)
19:48:55 <shachaf> It's also different in behavior -- show and newlines.
19:48:57 <kmc> but maybe you want to look at liftM2 (++), which has type IO [a] -> IO [a] -> IO [a]
19:49:22 <aavogt> @type uncurry $ liftM2 (>>) print print
19:49:23 <lambdabot>     Couldn't match expected type `b -> a' against inferred type `IO ()'
19:49:23 <lambdabot>     In the second argument of `liftM2', namely `print'
19:49:23 <lambdabot>     In the second argument of `($)', namely `liftM2 (>>) print print'
19:50:23 <aavogt> @type uncurry $ liftM2 (liftM2 (>>)) print print
19:50:23 <lambdabot>     Couldn't match expected type `b -> m a'
19:50:24 <lambdabot>            against inferred type `IO ()'
19:50:24 <lambdabot>     In the second argument of `liftM2', namely `print'
19:51:19 <greap> djahandarie: Awesome. I'd love to try it out, but I really like using HP.
19:51:21 <methods> napping's worked
19:51:22 <accel> woot
19:51:24 <accel> old programs use
19:51:27 <accel> i feel smarter already
19:51:32 <methods> but it's not like I have a nice printf style control
19:51:46 <djahandarie> @type printf
19:51:46 <lambdabot> forall r. (PrintfType r) => String -> r
19:51:47 <kmc> "printf" and "nice" do not belong in the same sentence
19:51:51 <shachaf> @faq Can Haskell do printf?
19:51:51 <lambdabot> The answer is: Yes! Haskell can do that.
19:51:54 <kmc> but Haskell has several printf implementations
19:52:01 <kmc> Text.Printf is in the GHC standard library
19:52:14 <shachaf> kmc: What's nicer than printf?
19:52:30 <methods> yea i mean it would be nice to have  "name: position" on a line 
19:52:31 <kmc> C is poor in data structures so they use a string to describe something that really should be a rich embedded language
19:52:47 <djahandarie> greap, yeah. GHC 7.0.2 just got released today, and a lot of stuff has been moving around on Cabal so I feel like the Platform release is about to happen
19:53:30 <dons> i can feel it with my spiny sense.
19:53:36 <ion> print =<< (name ++) <$> plGetPosition body
19:53:53 <djahandarie> I think that is suppose to be "spider sense" dons
19:53:59 <djahandarie> :P
19:54:04 <accel> on osx; how do I uninstall haskell platform?
19:54:08 <accel> i no longer need it for anything
19:54:13 <methods> ion how does that work ?
19:54:14 <shachaf> djahandarie: I don't think dons is a spider.
19:54:28 <djahandarie> As far as we know...
19:54:52 <Jonno_FTW> I don't see him denying being a spider
19:54:53 <confound> so instead he's an anteater?
19:54:55 <methods> ion <$> not in my scope 
19:55:01 <ion> methods: Control.Applicative
19:55:21 <ion> @src (<$>)
19:55:21 <lambdabot> f <$> a = fmap f a
19:55:23 <ion> @src fmap
19:55:24 <lambdabot> Source not found. Where did you learn to type?
19:55:38 <djahandarie> <$> is just fmap, as @src indicates.
19:55:41 <Jonno_FTW> methods: you can use `fmap` 
19:55:58 <djahandarie> Confusingly, in the Applicative module.
19:56:26 * djahandarie suggests moving it somewhere more natural
19:56:57 <copumpkin> you mean like Data.Functor?
19:57:22 <copumpkin> (where Applicative gets it from)
19:57:48 <co_dh_> greeting. 
19:58:21 <co_dh_> from a Category point of view, is a complete Poset just a category with product ( or coproduct )? 
19:58:44 <djahandarie> copumpkin, oddly enough, I never knew it was in there
19:58:50 <copumpkin> co_dh_: I think so
19:58:54 <ion> methods: The pure function (name ++) is mapped over the IO action plGetPosition body, returning an IO action equivalent to (return . (name ++)) =<< plGetPosition body. That is then bound to print with =<<.
19:59:13 <co_dh_> copumpkin: thanks :)
19:59:38 <methods> all so confusing
19:59:46 <copumpkin> co_dh_: there's ##categorytheory now, btw
19:59:56 <copumpkin> if you want lots of CT talk :)
20:00:02 <ion> One could avoid fmap and do: print =<< return . (name ++) =<< plGetPosition body
20:00:33 <exlevan> print . (name ++) =<< plGetPosition body
20:00:45 <btutt> *ponders if the co prefix of coclass is like all of this category theory co<blah> stuff in COM*
20:00:48 <ion> Hah. Good point.
20:01:53 <methods> one thing here is that plGetPosition doesn't return a string... 
20:02:04 <monochrom> you could avoid fmap if you used liftM <duck>
20:02:19 <shachaf> > liftM <duck>
20:02:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:02:21 <copumpkin> or liftA <heron>
20:02:34 <methods> IO (Foreign.C.Types.CFloat,  Foreign.C.Types.CFloat, Foreign.C.Types.CFloat)
20:02:34 <ion> print . (name ++) . show =<< plGetPosition body
20:02:40 <exlevan> methods, use show (plGetPosition body)
20:02:41 * monochrom lifts his duck!
20:02:42 <shachaf> monochrom, copumpkin: Those are parse errors. Birds don't belong in #haskell.
20:02:52 <exlevan> it will give you a string
20:02:54 <monochrom> but Bird does!
20:02:54 <methods> yea i tried show.plGetPosition 
20:03:05 <copumpkin> @hackage aviary
20:03:05 <lambdabot> http://hackage.haskell.org/package/aviary
20:03:17 * hackagebot xml-types 0.2 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.2 (JohnMillikin)
20:03:17 <copumpkin> @hackage data-aviary
20:03:17 <lambdabot> http://hackage.haskell.org/package/data-aviary
20:03:22 <copumpkin> there we go
20:03:27 <tg_> bird is the WORD?
20:03:28 * shachaf has never seen Bird in here.
20:04:03 <monochrom> no, he hasn't been here. but if he came, we would welcome him.
20:04:39 <monochrom> I would also grill him on "why don't you put your book on the web!"
20:04:41 <methods> idk i can't really get any of those to work 
20:04:56 <ion> As plGetPosition body :: … → IO Something and show :: (Show a) => a → String, you’ll need to lift ‘show’ one way or another.
20:05:06 <btutt> @hackage uniplate
20:05:06 <lambdabot> http://hackage.haskell.org/package/uniplate
20:05:15 <exlevan> methods, paste the code
20:05:22 <methods>   mapM_ (\(name,body) -> print . (name ++) =<< show.plGetPosition body) bodies
20:05:31 <monochrom> I am sorry to tell you that haskell is not a do-what-I-mean language.
20:05:37 <ion> whoops, not … → IO Something but just IO Something as i already applied it to body.
20:06:03 <btutt> If it was, it would be even more complicated
20:06:07 <exlevan> composition won't work, try show (plGetPosition body)
20:06:17 <methods> tried that 
20:06:22 <shachaf> > dwim
20:06:24 <lambdabot>   unsafeLaunching missiles.
20:06:25 <exlevan> or (show . plGetPosition) body
20:06:30 <shachaf> monochrom: WOrks for me.
20:06:43 <ion> exlevan: I’m under the impression plGetPosition returns an IO action. Thus show needs to be lifted one way or another.
20:06:57 <methods> yea it does 
20:07:03 <methods> IO (Foreign.C.Types.CFloat,  Foreign.C.Types.CFloat, Foreign.C.Types.CFloat)
20:07:11 <methods> idk it works fine when i pass that to print
20:07:38 <ion> If ‘print =<< plGetPosition body’ works, i guess ‘print . (name ++) . show =<< plGetPosition body’ should work as well.
20:07:38 <exlevan> ok, then it will be: putStrLn . (name ++) . show =<< plGetPosition body
20:07:39 <monochrom> well show is not print
20:08:16 <methods> yea!
20:08:55 <methods> now obviously you would want a space after name
20:09:05 <methods> question is .. is this the way you would normally work in haskell anyway ?
20:09:43 <monochrom> I just write do { x <- plGetPosition body; putStrLn (name ++ " " ++ x) } normally
20:09:47 <accel> what's the "ideal/best" way on a Mac to keep parallel builds of ghc? I.e. I want to modify ghc, recompile it ... and keep it around to see what my changes do
20:09:55 <monochrom> err, do { x <- plGetPosition body; putStrLn (name ++ " " ++ show x) }
20:09:55 <accel> but I don't want to nuke my root ghc install
20:10:30 <monochrom> when you ./configure'ed you would say ./configure --prefix=/this/is/for/ghc/7.0.2
20:10:59 <accel> so basically ./configure --prefix=/Users/superawesomeworlddictator/local/ghc ?
20:11:15 <monochrom> this also means subsequently you run it using /this/is/for/ghc/7.0.2/bin/ghc
20:11:44 <methods> idk... just massive work just to print something
20:11:53 <accel> how does this interact with things like cabal ... ?
20:12:01 <accel> i almost feel like I should create a separate user account
20:12:10 <accel> and have that user account dedicated to testing my ghc mods
20:12:25 <monochrom> putStrLn (name ++ " " ++ show x)  doesn't look like massive work to me
20:12:46 <co_dh_> greeting. the length :: [a] -> Int is a functor from monoid category of list to monoid category of Nat, does it has an adjoint? 
20:13:16 <mzero> accel - as long as you install the GHC universe under it's own root -
20:13:20 <monochrom> and plGetPosition body  is not "print something", it does non-trivial work
20:13:20 <accel> Bool(False,True) <-- is True/False really provided by the prelude library ((rather than be library builtins) ?
20:13:21 <applicative> methods, what would you prefer?
20:13:28 <mzero> then you can move between roots by which bin dir is on your PATH
20:13:43 <dmwit> ?src Bool
20:13:44 <lambdabot> data Bool = False | True deriving (Eq, Ord)
20:13:47 <dmwit> accel: yeeeep
20:14:22 <applicative> if ... then ... else is built in though, so there's something specious about this
20:15:05 <applicative> I mean, there is Bool - dependent syntax
20:15:15 <accel> ah
20:15:17 <accel> okay
20:15:24 <accel> but if then else
20:15:27 <accel> is just syntactical sugar
20:15:31 <accel> on top of pattern matching, no?
20:16:29 <dmwit> It probably compiles to a case, but I don't think it does that in the desugaring stage.
20:16:55 <applicative> > otherwise
20:16:56 <lambdabot>   True
20:16:57 <copumpkin> there's rebindable syntax these days
20:17:04 <applicative> I just rebound some!
20:17:05 <accel> hmm point being
20:17:09 <accel> we can rip out if/then/else
20:17:14 <accel> and teh langauge would be just as expressive
20:17:17 <copumpkin> yeah, you can make it do what you want
20:17:21 <copumpkin> oh, and yeah
20:17:22 <accel> with just pattern matching + library defined Bool = True | False
20:17:28 <dmwit> Oh, yes. I think there may even be a proposal to do that for Haskell'.
20:17:35 <copumpkin> and it's already in GHC
20:17:42 <copumpkin> you can even rebind guards
20:17:51 * djahandarie suggests for people to specify their subject
20:17:57 <MtnViewMark> bool :: a -> a -> Bool -> a
20:18:33 <copumpkin> bool :: a False -> a True -> (x :: Bool) -> a x
20:18:36 <accel> #if defined(__NHC__)
20:18:42 <accel> are those lines turned on in GHC?
20:18:43 <shachaf> Why even have a boolean type? Just Church-encode it.
20:18:44 <accel> or not?
20:18:47 <copumpkin> no
20:18:55 <btutt> :t fromMaybe
20:18:56 <lambdabot> forall a. a -> Maybe a -> a
20:18:57 <monochrom> if you don't import Bool(True,False), you can still use if-then-else. you just can't explicitly mention the words "Bool", "True", "False". for example (if 'x'=='x' then 'x' else 'x') still works.
20:19:37 <accel> why does Prelude.hs have a bungh oc hugs/nhc crap?
20:19:40 <accel> rather than just be ghc specific
20:19:42 <MtnViewMark> copumpkin: ?? What kind of type sig. is that??
20:19:46 <accel> after all, it's int eh ghc dist
20:19:51 <copumpkin> MtnViewMark: dependent haskell! ;)
20:19:51 <btutt> @src fromMaybe
20:19:52 <djahandarie> MtnViewMark, crazy town!
20:19:52 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
20:19:53 <applicative> that's no haskell signature...
20:20:38 <monochrom> to support this, the haskell reports have the following to say: "every name explicitly mentioned by the source code must be either defined locally or imported from another module. However, entities that the compiler requires for type checking or other compile time analysis need not be imported if they are not mentioned by name. The Haskell compilation system is responsible for finding any information needed for compilation with
20:20:38 <monochrom> out the help of the programmer."
20:21:08 <methods> applicative: maybe something like  putStrLn (name ++ " " ++ (show =<< (plGetPosition body))
20:21:10 <MtnViewMark> accel: We're all one big happy family in HaskellLand!
20:22:13 <accel> i say we nuke all the non-ghc users
20:22:16 <methods> kmc said he doesn't like printf but how else would you print something padded to 5 spaces as nicely as %5s ? 
20:22:17 <accel> and focus on making ghc great
20:22:20 <accel> why split effort
20:22:47 <djahandarie> accel, competition is good. Also GHC needs to care about 'the real world' while other people can do crazy cool stuff
20:22:50 <ion> methods: ++ requires strings as parameters, you can’t give an IO action as a parameter to it (ignoring that show =<< plGetPosition body doesn’t quite work either).
20:22:52 <MtnViewMark> Different aims
20:23:03 <monochrom> i say we nuke all other humans, and focus on giving me all the world's resource. why waste oxygen on you.
20:23:49 <exlevan> methods, why would you want something padded exactly to 5 spaces? If you need pretty-printing, just use a pretty-printing library
20:23:59 * shachaf sees no context for monochrom's comment.
20:24:03 <shachaf> But I suppose none is needed.
20:24:18 <monochrom> the context begins with "i say we nuke all the non-ghc users"
20:24:29 * applicative doesn't see why a String shouldn't have a few IO actions as parts.  if getLine `isInfixOf` x then x else y
20:24:44 <accel> monochrom :the probably with your plan is that
20:24:53 <accel> monochrom: remaining ghc users is still a propductive community
20:25:00 <methods> exlevan: idk i use it all the time in other languages .. right now i just want to print name : position where obviously name can be any length so lining it up to 5 spaces might look nicer if your names are under 5 
20:25:03 <accel> monochrom: whereas if you're the only remainig human, life would be kind of hard
20:25:53 <dmwit> methods: We've got pretty-printing modules that line up columns regardless of width. Why would you want %5s when you can just have the right width with less syntax?
20:26:13 <methods> yea idk 
20:26:24 <methods> habit lol .. what's the name of the lib ?
20:26:31 <exlevan> methods: well haskell is not like other languages. The things here tend to be more abstract
20:26:37 <btutt> hlint is cool
20:27:51 <methods> ion well i was running that within in a map so i can only have 1 expression in there right ? i wanted to just something short and clean .. without need to create another function 
20:28:15 <exlevan> methods: http://hackage.haskell.org/package/pretty may be what you are looking for
20:28:48 <dmwit> ?hackage boxes
20:28:48 <lambdabot> http://hackage.haskell.org/package/boxes
20:28:51 <dmwit> ?hackage pretty
20:28:51 <lambdabot> http://hackage.haskell.org/package/pretty
20:29:03 <dmwit> Those two are both quite nice, depending on your use case.
20:29:28 <exlevan> methods: 'short and clean' and IO rarely go well together
20:30:05 <dmwit> I do not find that "short and clean" and "IO" interact badly.
20:30:12 <exlevan> you could write clean function for rendering your data, and another one for I/O
20:30:50 <monochrom> oh, that's what you mean. yes. all pretty-printing libs don't do I/O prematurely.
20:31:10 <monochrom> meaning, they don't do I/O. you already know how to call putStrLn for that.
20:32:49 <methods> hm that page has no docs on the api ?
20:33:02 <dmwit> Try clicking the module names at the bottom.
20:33:46 <monochrom> no, Text.PrettyPrint.HughesPJ is very sparse on doc
20:34:14 <monochrom> eh? boxes looks interesting
20:34:32 <methods> what's up with that term combinator ?
20:35:08 <monochrom> after figuring out boxes, you may guess how to use pretty, same idea
20:35:30 <copumpkin> stringAppender :: IO (CString -> IO (), IO String)
20:35:37 <copumpkin> I love having first-class IO
20:36:05 <monochrom> that is really half of the usage of macros in other languages
22:35:15 --- topic: '["Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
22:35:15 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Fri Jan 28 14:21:18 2011]
22:35:15 --- names: list (clog ssk38 Palmik _ay_ ramkrsna baguasquirrel jsgf damex setmeaway m3ga pikhq n00p josephholsten levifikri QinGW path[l] napping fcr kaustuv rx1z ExtraSpice mkscrg RayNbow`TU aleator geekounet abbe scm btubbs_ dibblego ormaaj codemac _nickel kevinww Lanther Nisstyre _2x2l wolverian CosmicRay integral Taggnostr2 Liskni_si arkx Arnar brushbox yrlnry ceii_ elliottt aleator_ pantsd_ c1de0x guerrill1 saiam_ tromp__ ousado_ ve BrianHV_ _Mitar Sunil01 btutt nomeata)
22:35:16 --- names: list (nixeagle parcs qz ArchGT derekwright_ horms Gracenotes JohnnyL dolio jessopher augur Adamant myu2 mzero MoALTz Apocalisp Hugglesworth greap Zeiris_ Ptival moshee malkomal_ Astro blbrown_win3 ourfrank ceii jaj_ platypine gwern luite davidlee c_wraith bogner augustss jonafan_ Cobra_ miclorb_ zmbmartin TacticalGrace dark cubi Olathe shepheb em ngochai metasyntax ymasory arlinius nchaimov Mathnerd314 copumpkin StoneToad Rotaerk joelb siracusa cheater- noam killown)
22:35:16 --- names: list (andrewvos lsthemes poindontcare theorbtwo Lemon kfish sonnym systemfault btubbs mun Intensity gienah ray phryk Adman65 pantski sohum shutdown_-h_now fengshaun vagif zzing Itkovian methods Silex SimonRC newsham cozmic sipa McManiaC jonrh gnnr arnihermann gniourf_gniourf creaux age Nereid marienz tensorpudding thetallguy1 waern ClaudiusMaximus rothwell_ jystic ksf vizowl chromakode ahihi Amadiro Dashkal kfr ChongLi borism dual Gunni b52 Ferdirand anonus willb1)
22:35:16 --- names: list (olsner dkasak tswett zaphar_ps allbery_b hackagebot ixzkn jrib pingveno jlewis robinsmidsrod mm_freak_ Jonno_FTW tmuki Philippa perlite zakwilson mornfall funscala1 Colours_ Yahovah Zao alexsdutton Gabbie Philonous filius Vq solarus Cerise inr jcapper osfameron steve_himself xenocrys1 Heffalump pimeys__ szbalint noj mafs mgsloan jd10 Muad_Dibber__ ahf dilinger jmvanel Clex micahjohnston ollip Odd_Bloke opqdonut blackdog ville plan idnar comex_ KaneTW_ tlockney)
22:35:16 --- names: list (a11235 dcoutts_ wto pesco araujo dropdrive confound rwbarton larsrh Veinor mikeg trez ehamberg koninkje1away HaudRex dogmaT amaron otto_s shachaf ocharles Der_Dackel nniro kelvie__ zax_ etabot DrSyzygy pearle amiri flux milli ibid regalia cjay ryant5000 n0tk sgronblo Igloo xarch_ ion Cthulhon| chitragupt nlogax orbitz kloeri cynick solidsna` Jantaro tab jgrimes_ anders^^ brett ibt afarmer jssanders thoughtpolice __nickm__ BlankVerse niko dMazz alpounet)
22:35:16 --- names: list (AnAdorableNick djanatyn barik brisbin tomaw lispy_ jdavis m4thrick [mth] dobblego drbean companion_cube jbauman_ jao alexsuraci ToRA norm2782 insomniaSalt dleslie Samoi pacak CoryDambach sigue Raku^ tamiko Draconx|Laptop mq tg_ faj Obfuscate poucet samferry caligula_ cyanoacry aculich Blub\0 ankit9 joe6 Evious Jafet david` cognominal co_dh Denebola byorgey davidL novas0x2a kelvie_ neurogeek dcolish o^_^o peterquest liyang JaffaCake exlevan ricky septomin)
22:35:16 --- names: list (monochrom miloshadzic kermit Twey Cale Vorpal cibs bqf stepkut almostsix roconnor JuanDaugherty maharj mapreduce tlonim bd_ espringe anonchik xinming_ alek_br dom96 Draconx dino- Entroacceptor tessier juhp angstrom Tanell dv- tew88 dreixel dankna vegai Baughn proq fihi09` kniu akosch jedai_ lambdabot snorble go|dfish joaopizani scsibug ido_ hpaste iFire` Khisanth snr profmakx majoh MasseR Soft __marius__ rup etpace cwillu_at_work coffeemug Innominate gerard0)
22:35:16 --- names: list (Botje mauke absentia dcoutts ilab inimino idoru dfeuer joeytwiddle javecantrell whoops rokoteko timchen1` stepnem cafesofie mercury^ drhodes erk_ djahandarie electrog1ek wagle wires jackhill qebab ccasin mun_ shlevy sopvop aristid KitB_ Nshag jdsc liesen helgikrs srcerer levitation[A] ec|detached sophacles jho repnop cpa robinbb Eliel burp schroedinbug phr_ kolmodin rapacity dons emias ajhager dRbiG MK_FG derrotebaron thorkilnaur antonh jayne TML xplat)
22:35:16 --- names: list (thetallguy ddarius FauxFaux Starfire vili_ alexbobp Boney Axman6 Martty ksandstr mux eyck quicksilver Draggor deavid hzh xinitrc_ nominolo eno alip jix soeren foamping clanehin yahooooo SonicvanaJr Nanar FDFlock preflex edenc DustyDingo periodic pastorn Jaak joni6128 Ornedan cafaro _mpu Gilly duairc saurik hpc faanbj davean dqd stesh stroan dumael ivan jvogel mlh felipe_ edwtjo appamatto obcode tavelram duckinator impl raek Ke MrDomino^ quaestor taruti)
22:35:16 --- names: list (harlekin snarkyboojum _erik_ lostman johs tafryn gdsx jrk_ copton jml ben Saizan mrd udoprog palmje Tinned_Tuna oc nornagon Lemmih ziman ps-auxw mike1703 mortberg canvon hyko alios bezik Zol mietek cncl_ `0660 freiksenet ortmage pettter PHO_ dorkitud1 flamingspinach defect krainboltgreene kakeman adimit mindwarp sbok troofax wolfwood ernst _janne Kalivha freedrull npouillard skaar jrockway reacocard Bleadof sajkr klugez Hunner suiside ath Neronus henr_k)
22:35:16 --- names: list (gereedy carrbs ihckt andrewsw welterde flori mattam lunaris int-e tridactyla Raynes kosmikus zygoloid gseitz jamwt agemo Vulpyne And[y] tengen category mrshoe nimred kalven magicman bhungy CindyLinz dixie Aestas dionoea Paradox924X jacobian Maxdamantus Fingerzam Laney sgtarr Counter-Strike bxc_ jlouis Rooz aiko_ slabanja birkenfeld kaol MacCoaster_ hiredman Belgarion0 Boxo earthy shiduke zomg OnionKnight aavogt ian_mi ace2001ac @ChanServ noddy tomjnixon)
22:35:16 --- names: list (jmcarthur ski hvr lantti shamster hellige nothingmuch_ koala_man Aisling ReinH mjrosenb eZet dmwit scree hc ahihi2 EvanCarroll)
23:18:26 <zzing> If I wanted to represent a stream of characters with the ability to add to the end or cut from the start, and be able to index it quickly, what might be a good datatype to look at?
23:18:54 <companion_cube> Data.Sequence, maybe ?
23:21:17 <zzing> Looks good thanx you
23:24:26 <mm_freak_> zzing: also look at the 'vector' package…  most of the time it's faster than Data.Sequence
23:24:37 <zzing> ok
23:25:42 <Cale> You might also just try Data.ByteString or Data.Text
23:27:41 <hpaste> pipi pasted ",,pi"  http://hpaste.org/44502
23:28:23 <zzing> Anyne get the errors from that paste when compiling some package?
