00:03:16 <ManateeLazyCat> I guess must some public function return cabal's share directory (datadir), what's it, cabal guy?
00:03:50 <dibblego> you mean all packages?
00:04:03 <ManateeLazyCat> dibblego: Yeap.
00:04:05 <dibblego> http://hackage.haskell.org/packages/00-index.tar.gz
00:04:15 <ManateeLazyCat> dibblego: Example, i want get "/home/andy/.cabal/share"
00:04:41 <ManateeLazyCat> dibblego: I just want to know any function can return "~/.cabal/share" 
00:04:53 <dibblego> @hoogle getHomeDirectory
00:05:01 <dibblego> you want that?
00:05:08 <ManateeLazyCat> dibblego: No.
00:05:21 <dibblego> the ls command?
00:05:37 <dibblego> the location of your .cabal directory?
00:05:46 <ManateeLazyCat> dibblego: Do you know fucntion getDataDir?
00:06:08 <dibblego> no
00:06:09 <mauke> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html maybe relevant
00:06:41 <ManateeLazyCat> dibblego: i need figure out how cabal get "/home/andy/.cabal/share/" then i scan .cabal file to get package name and package version, same as getDataDir, but Setup.hs don't need depend Paths_package
00:07:03 <ManateeLazyCat> mauke: I know, buyt getDataDir can't use Setup.hs
00:08:11 <ManateeLazyCat> mauke: Paths_package.hs file just generate after Setup.hs, so i can't use function getDataDir in Setup.hs because it haven't generate by Cabal, see?
00:09:43 <ManateeLazyCat> I try to use getPersistBuildConfig get LocalBuildInfo, then use prefixRelativeInstallDirs return cabal's directories, but looks failed again.
00:10:56 <ManateeLazyCat> dibblego: I can't use use ~/.cabal/share, because user's cabal perhaps not install at HOME directory.
00:11:16 <ManateeLazyCat> dibblego: So i need know how cabal figure out it's `share` directory.
00:14:38 <mreh> :t guard
00:14:42 <mreh> @bots
00:16:33 <shachaf> guard :: forall m. (MonadPlus m) => Bool -> m ()
00:16:35 <shachaf> :)
00:18:24 <ManateeLazyCat> dcoutts: Do you know any function return "~/.cabal/share" ?
00:19:09 <levifikri> Hi. I have a collection of ByteStrings. I would like to store them in a data structure which allow me to retrieve the location of any particular bytestring fast (like indexing in a database). What data structure is most suitable for it?
00:20:02 <btutt> I'm guessing this bit from Configure.hs:
00:20:09 <btutt>         -- installation directories
00:20:09 <btutt>         defaultDirs <- defaultInstallDirs flavor userInstall (hasLibs pkg_descr)
00:20:09 <btutt>         let installDirs = combineInstallDirs fromFlagOrDefault
00:20:09 <btutt>                             defaultDirs (configInstallDirs cfg)
00:21:07 <levifikri> is elemIndex function of Data.List the best for it?
00:22:44 <ManateeLazyCat> btutt: Got it, 'getAppUserDataDirectory "cabal"'
00:23:05 <ManateeLazyCat> btutt: I will got "/home/andy/.cabal", then other thing is simple.
00:23:10 <ManateeLazyCat> btutt: Thanks for tips.
00:23:57 <btutt> Actually shouldn't a post configure hook pass you the LocalBuildInfo that contains the InstallDirs type?
00:24:20 <btutt> See UserHooks.hs
00:24:31 <ManateeLazyCat> btutt: I don't know how to get LocalBuildInfo, if i can, i can try prefixRelativeInstallDirs
00:24:49 <ManateeLazyCat> btutt: Wait, let me chec.
00:25:55 <ManateeLazyCat> btutt: Ah, yes, let me try.
00:26:41 <btutt> Configure.hs defines LocalBuildInfo and InstallDirs.hs ditto for InstallDirs
00:27:22 <btutt> er, Configure.hs creates the LocalBuildInfo
00:43:44 <mjrosenb> @pl (\x -> return (Data.Map.Lookup 5 x))
00:44:02 <mjrosenb> no lambdabot :(
00:44:46 <ion> return . Data.Map.Lookup 5
00:46:06 <mjrosenb> that is what i thought
00:46:11 <mjrosenb> but one typechecked
00:46:14 <mjrosenb> and the other did not
01:08:27 * ManateeLazyCat pasted "get package data dir and don't need deepn Paths_package, you can use it in Setup.hs" at http://paste2.org/get/1283210
01:08:28 <ManateeLazyCat> btutt: Above code fix my problem, thank you very much! 
01:08:32 <ManateeLazyCat> :)
01:09:05 <btutt> glad I could help out
01:09:05 <ManateeLazyCat> I'm foolish that forgot postInst has give me the LocalBuildInfo . :(
01:09:13 <ManateeLazyCat> btutt: Thanks. :)
01:09:44 <ManateeLazyCat> I need add above in my toolkit. :)
01:53:32 <spirit> is there a recommendation on how to group declarations and definitions of functions inside modules? i found some code that has all declarations first. i'm also looking for good practice of indentation, especially how to indent 'if-elseif-else' statements correctly.
01:58:03 <Saizan> nested if/then/else are usually avoided in favour of guards
01:58:28 <Saizan> and declarations are most commonly put near the corresponding definition
01:59:07 <Saizan> also, don't use tabs
01:59:57 <Jafet> I often write bottom-up because it's easier, although a top-down style might be easier to read
02:00:44 <Jafet> I've also seen modules written bottom-up but the "low-level" details shuffled to the bottom of the file
02:01:59 <spirit> i switched to kate editor now, it displays tabs so that i can replace them with spaces. it has a haskell mode, but something seems to be not quite right. my code parses just fine, kate does not recognise the layout as 'she' should though.
02:04:30 <spirit> i'm building on someone else's code, the plan is to first get it to run and then improve it (as i'm in a bit of a hurry)
02:11:57 <ManateeLazyCat> Haha, now Manatee should be easy for user: you just click some image to play sub-module, no more type. :) http://www.flickr.com/photos/48809572@N02/5496671763/lightbox/ 
03:46:55 <mreh> where would signal processing stuff best go in the namespace?
03:48:23 <Saizan> @hoogle Signal
03:49:06 <Saizan> there's System.Posix.Signal, so something like that
03:49:19 <mreh> I was thinking more Digital Signal Processing
03:49:29 <mreh> not POSIX signals :)
03:50:02 <c_wraith> eh, just stick it under Data, like everything else. :)
03:50:04 <c_wraith> @hoogle fix
03:50:12 <c_wraith> err, I can pay attention
03:50:26 <c_wraith> But Data.Functions is rather funny
03:50:38 <Saizan> Data.Function
03:50:42 <Saizan> but yeah :)
03:50:51 <c_wraith> That's why I wanted to hoogle it.  I can never remember if that s is there or not
03:51:39 <Jafet> It could be worse, like someone thinking fix involves monads
03:52:08 <mreh> there's never a simple answer ;)
03:52:16 <c_wraith> because it's also exported from Control.Monad.Fix?
03:54:00 <Twey> c_wraith: Modules are almost always singular
03:54:22 <c_wraith> I think it's just the sheer absurdity of that module that confuses me :)
03:56:11 <Saizan> but after all, in higher order programming functions are data
03:56:58 <Saizan> (that's meant to sound like a "in soviet russia" joke)
03:57:23 <numeral> is there a way to get the length of an integer?
03:57:37 <numeral> or to split an int into digits for instance?
03:57:53 <c_wraith> You can use show to split it into digits
03:58:01 <c_wraith> (if you don't need efficiency)
03:58:12 <aristid> preflex: seen kamatsu
03:58:12 <preflex>  kamatsu was last seen on #haskell 29 days, 16 hours, 27 minutes and 13 seconds ago, saying: can't you just use ""?
03:58:14 <numeral> yeah, just wondering how big this factorial is
03:58:30 <c_wraith> oh.
03:58:34 <c_wraith> that's easy.
03:59:12 <c_wraith> log (n!) ≈ n * log n
03:59:43 <c_wraith> so the number of digits is in the neighborhood of the the original value times the log of the original value
04:00:12 <c_wraith> the rest is a matter of constant factors, and I don't concern myself with them. :)
04:00:34 <numeral> hrm, well this works too sum [1| _ <- show (product [1..1415]) ]
04:00:43 <c_wraith> that's more exact :)
04:00:51 <c_wraith> though you could just use length
04:01:22 <numeral> oh right, didn't occur to me since I was thinking in ints
04:01:30 <fram> hi, I have a function, "importGladeXml", of type FilePath -> Q [Dec] that is supposed to declare stuff for me. I enabled the TH extension but I cannot figure out how to call the function
04:01:38 <numeral> length (show (product blah)))
04:01:51 <numeral> thanks c_wraith 
04:01:53 <c_wraith> fram: $(importGladeXml)
04:02:00 <c_wraith> numeral: you're welcome
04:02:13 <Saizan> fram: $(importGladeXml "some filepath") at the toplevel
04:02:23 <c_wraith> Oh, right, it takes a filepath
04:02:32 <c_wraith> It'll also need to be with the rest of the imports
04:02:41 <c_wraith> Because otherwise the spliced file will be invalid
04:02:59 <Saizan> TH can splice imports now? cool
04:03:20 <c_wraith> Oh, hmm.  Good point.  If it can, that means I can get rid of some CPP
04:04:26 <Saizan> http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH.html#t:Dec <- doesn't seem so
04:04:52 <Jafet> ceiling $ sum $ map (\x -> log x / log 10) [1..1415]
04:06:01 <c_wraith> TH can create type families, but not imports...  What's wrong with this picture?
04:06:21 <fram> thx c_wraith and Saizan! Is there a way to see the generated code?
04:06:39 <c_wraith> Answer:  nothing, I suppose.  The semantics of generating imports after running some of the code in the module is confusing, at best
04:06:57 <c_wraith> fram: yes, but I don't remember what it is, exactly.  something like pass -ddump-splices to ghc
04:07:24 <c_wraith> fram: $(foo) is called a splice in Template Haskell
04:07:45 <fram> ok
04:08:27 <c_wraith> you can splice in FFI declarations?  crazy.
04:09:59 <c_wraith> I don't fully see the value in that, unless you're also generating C code dynamically...
04:10:59 <Saizan> maybe you've a macro that reads .h files and generates the bindings?
04:11:39 <c_wraith> Oh, hmm.  That could work.  I was thinking "why not just do that statically?" but I wasn't thinking of a bindings-generator-helper thing
04:17:43 <c_wraith> hahaha:    build-depends: base >= 0 && < 1000
04:17:58 <Saizan> where's that from?:D
04:18:04 <c_wraith> bindings-dsl
04:18:20 <c_wraith> Since the only haskell in that package is an empty module, I think that might actually be safe
04:19:00 <Saizan> yeah
04:31:32 <bla123> is there a function to replace names in a TH Exp tree  -or-  is there a simple way to generate a traversal function that can do that  -or-  do i have to write it on my own?
04:39:34 <Saizan> i think there are some SYB instances for TH on hackage but icbw
04:56:12 <Feuerbach> Can I emulate existential data types without actually creating a new data type? E.g. is there a way to write a function whose return type is *some* (depending on the argument) instance of Eq?
04:56:55 <napping> an existential is always a new type
04:57:10 <c_wraith> Feuerbach: I'm not sure that return type does you much good.  You'll never be able to compare any of them with each other
04:57:53 <c_wraith> Feuerbach: because you need *two* values to use the functions in Eq, and with an existential, you'll never be able to prove any pair of them are the same type
04:57:56 <napping> if you want to make them without a data declaration, unfortunately there is no "exists" quantifier
04:57:57 <Feuerbach> c_wraith: indeed, Eq is a bad example. Let's say it's Enum
04:58:19 <hpc> so you want Enum a => a -> a?
04:58:30 <napping> you can dualize things, though it may not be any nicer than making a data type
04:59:11 <c_wraith> I think I'd just return whatever set of functions it is that you want to manipulate the value with from the function.  Ignore type classes entirely
04:59:12 <napping> exists a . (Eq a) => [a] would become (forall r . (forall a . (Eq a) => [a] -> r) -> r)
05:00:28 <Feuerbach> c_wraith: you still need some way to express "any type", unless you do the transformation suggested by napping 
05:00:49 <Feuerbach> and it's indeed not a good alternative...
05:01:06 <Feuerbach> okay, I guess I have an answer ("no"). Thanks :)
05:01:35 <c_wraith> Feuerbach: not really.  Take a look at this case:  Show a => Exists a. [a].  That is basically the same, in what you can do with it, as [String]
05:02:32 <c_wraith> Feuerbach: Often, you can use that transformation to remove an existential.  I did the same thing in a more complex case when working with hint code to remove an existential.
05:03:00 <Feuerbach> c_wraith: what is Exists in your example?
05:03:16 <c_wraith> Feuerbach: a mythical existential quantifier
05:03:57 <c_wraith> The concrete example I worked with was:  data Loadable = forall a . Loadable (IO a) (a -> Snap ()) (a -> IO ())
05:04:19 <c_wraith> I finally realized that was much more simply expressed as just:  IO (Snap (), IO ())
05:04:23 <Saizan> putting Show a => where a is not even bound yet is quite weird though :)
05:04:57 * hackagebot Hsed 0.2.1 - Stream Editor in Haskell  http://hackage.haskell.org/package/Hsed-0.2.1 (VitaliyRukavishnikov)
05:05:34 <napping> using existentials is a bit odd if there are not too many methods and they take one argument
05:05:47 <napping> it's harder to replace a class with binarly metods like that
05:06:22 <c_wraith> Those two aren't *exactly* identical, as the existential is a bit more flexible.  But that flexibility only introduced extra ways to do wrong things, in my particular case. :)
05:06:31 <Saizan> yeah, it all depends on the number of possibly distinct observations
05:06:37 <c_wraith> It does depend on the class in use.
05:09:00 <c_wraith> hmm.  Turns out *I* am one of those people concerned with HashMap's size function being O(n).  Heh.  Oh well, in my case I've already wrapped it anyway.  Easy to include a size in that wrapper.
05:10:17 <c_wraith> ...  Less easy to see how to do that efficiently.  crap.
05:10:43 <napping> it seems hard to maintain for intersection especially
05:10:54 <c_wraith> (Suddenly, I'm concerned with constant factors)
05:11:07 <c_wraith> intersection isn't in the API I export, so that's not a problem.
05:11:18 <napping> @quote skew swapping
05:11:29 <napping> aww, no lambdabot
05:11:48 <hpc> who hosts lambdabot?
05:11:53 <c_wraith> Cale
05:12:05 <Saizan> on lispy's machine
05:12:14 <hpc> heh
05:12:26 <c_wraith> and lispy works at Galois.  So..  You could say they're involved, too
05:13:25 <Saizan> in the sense that they indirectly pay for the machine?:)
05:14:37 <savask> Hello. I need a function which will "glue" some Word8s to the one number. But it seems that it should return or Word16, or Word32, or even Word64. Can I do this? Here is mine try:
05:14:37 <savask> glueWords :: Int -> [Word8] -> Word16 -- the type is fixed, because I don't know what to do with it
05:14:37 <savask> glueWords 1 [w] = fromIntegral w
05:14:37 <savask> glueWords n (w:ww) = shiftL (fromIntegral w) (8*(n-1)) .|. (glueWords (n-1) ww)
05:15:18 <c_wraith> savask: Are you hoping to vary the return type based on the length of the lsit?
05:15:31 <savask> Yes :-P
05:15:46 <c_wraith> err, *list.  I don't know what's happened to my spelling.
05:16:03 <c_wraith> That's a very hard problem in haskell.  Things that call your function want to know what it'll return, statically.
05:16:22 <savask> But maybe there is a type (or how does it called?) that will group these Words into one, bigger group.
05:16:42 <hpc> bytestring perhaps?
05:16:49 <c_wraith> You could do it with an existing typeclass, like Integral
05:16:57 <c_wraith> But that would mean that the return type is chosen at the call site
05:17:16 <Saizan> if the maximum you need is Word64 just use that?
05:17:29 <c_wraith> and still chosen statically.
05:18:12 <c_wraith> If you really need to be able to vary the size, and do it at runtime, your best bet is to use an algebraic datatype with different constructors for each size of word.  But I think Saizan's suggestion also has merit.
05:18:13 <Saizan> (it's not like Word8 uses only 8 bits anyway)
05:18:48 <savask> Saizan: The problem is that I if I group 2 I should get a Word16, with 4 words - Word32 and so on.
05:19:08 <savask> Other variants are not suitable.
05:19:50 <c_wraith> savask:  you're stuck with the issue that the return type needs to be calculated at the call site at compile time.
05:20:43 <savask> I know.. But maybe there is better way to do this than to make a function for each number of words.
05:20:56 <c_wraith> that's the safest way to do it.
05:21:06 <napping> you could also take tuple
05:21:16 <napping> it woulde have to be a typeclass, but you would have
05:21:24 <napping> group :: (Word8,
05:21:45 <napping> group :: (Word8,Word8) -> Word16, group :: (Word8,Word8,Word8,Word8) -> Word32, etc
05:21:55 <napping> prbably best just to use something like Binary,though
05:22:09 <napping> if you have a long list of bytes and want to read out larfer values
05:23:12 <savask> Oh, okay, I see the simplest for me way to do this is to write a special function for each case. Thanks for help.
05:23:32 <Saizan> you could use a data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
05:23:36 <Saizan> instead of list
05:23:52 <Saizan> and then use a type family to send each number to the right type
05:26:29 <napping> Saizan: do you really only need one number?
05:26:44 <napping> savask, rather
05:28:19 <savask> napping: Rather?
05:29:09 <napping> do you only need one number?
05:29:20 <napping> or do you want to parse several from a list of words?
05:30:20 <savask> I want to turn a list of Word8 to a Word16, Word32 or Word63 depending on the number of passed words.
05:30:29 <Zao> Word63 will be fun :D
05:30:38 <savask> *Word64
05:34:29 <Saizan> savask: napping was asking if you're going to do this for a whole bunch of lists of word8 or just a few
05:35:14 <savask> Just few.
05:41:32 <Axman6> Zao: not sure if it still has it, but i believe OCaml for a long time had 63 bit ints, the remaining bit was for tagging it to say it wasn't a pointer i think
05:48:19 <aristid> Axman6: why would it be changed? that would be a pretty radical change, so i expect them to still have it
05:48:44 <Axman6> well, i think that ghc also used to have that change
05:48:50 <Axman6> I've been told this anyway
05:50:36 <napping> no, I think GHC's numbers have always been boxed
05:50:59 <napping> so, triple size but full range
06:03:27 <ezyang> Suppose I have the call sortBy someCompareFunction, and now I'd like to get the sorted list in "reverse". I could do reverse . sortBy someComparEfunction, but is there something more efficient I could do? 
06:04:06 <napping> flip someCompareFunction?
06:04:33 <napping> if you need both versions, reverse is probably best
06:05:16 <ezyang> oh, right, flip will do the trick :_) 
06:09:04 <aristid> oO
06:09:28 <aristid> preflex: seen edwardk
06:09:28 <preflex>  edwardk was last seen on #haskell 1 day, 21 hours, 14 minutes and 59 seconds ago, saying: xplat: cute
06:18:06 <lj23> Hi, how can I convert Word8 to Int?
06:18:30 <ddarius> fromIntegral
06:18:37 <ddarius> @bot
06:19:35 <lj23> @bot fromIntegral
06:21:19 <rsuniev> In the Monad definition is it fair to say that map is similar to unit operation and flatMap is similar to join/mult
06:23:07 <lj23> thanks
06:23:21 <ddarius> rsuniev: It sounds like you are talking about Scala and this is #haskell.  The answer is "no" and "no" though.
06:24:10 <rsuniev> ddarius: Sorry. Thanks
06:24:39 <McManiaC> wheres the instance definition for Monad [] ?
06:25:01 <ddarius> In (Control.)Monad I believ.
06:28:00 <aristid> i think it's in the Prelude
06:28:23 * hackagebot cinvoke 0.1 - A binding to cinvoke.  http://hackage.haskell.org/package/cinvoke-0.1 (RemiTurk)
06:28:24 <aristid> or, actually, in GHC's case, in GHC.Base
06:52:19 <dark> I have this type data Line = Dot String | Call String [String] and a p :: Parser Line. I want do something like this: combine p f g = do { l <- p; case l of { Dot s -> f s; Call a b -> g a b } }
06:53:10 <dark> I want to avoid doing case inside this do block; maybe I should define >>= for Line? or some other combinator
06:53:31 <dark> I can't use a "standard" combinator because no one knows about the structure of this type, Line
06:54:52 <dark> maybe what I should do is combine' l f g = case l of { Dot s -> f s; Call a b -> g a b } and do combine p f g = do { l <- p; return $ combine' l f g }
06:55:41 <ezyang> "maybe I should define >>= for Line" : Line probably isn't a monad, so that would be wrong. 
06:56:03 <ezyang> Are you trying to write a "fold" (i.e. destructor) for the Line data type? 
06:56:27 <bss03> I'd do combine' piece wise, so instead of case you just have multiple defintions.
06:56:33 <ddarius> dark: Why don't you want to have a case?
06:56:38 <dark> it is a type I use to decouple two parsers (one that does "lexing" and other that does "parsing")
06:56:41 <ezyang> In that case, something like foldLine f g l = case l of {Dot s -> f s; Call a b -> g a b} will work fine. 
06:56:50 <dark> ddarius, I would have a case *at some point*, but not inside a do!
06:56:57 <ddarius> dark: Why not?
06:57:15 <ezyang> and then combine p f g = p >>= foldList f g 
06:57:26 <ezyang> *foldLine 
06:57:28 <dark> because 1) layout rules are insanely annoying, 2) I, hm, I don't know, but
06:57:39 <dark> ezyang, hm @.@'
06:57:49 <ezyang> Defining a fold type for a non-recursive data type is usually not very useful, though. 
06:57:55 <ddarius> dark: Then don't use layout, but it is completely straight forward.  Just have Dot indented more than case.
06:58:08 <ezyang> *function 
06:58:08 <bss03> dark: You can always just do without layout -- use explicit {;} for your case (and do?).
06:58:39 <dark> 3) .. I find code with less nesting levels easier to read
06:59:39 <dark> (right now my code is kind of "flat", it has function compositions but nothing like an "if" or a "case" in the middle of some applicative code)
07:00:13 <ddarius> dark: You'd have a point if this was going to be like four levels deep, but it's two.  It's just like having an if statement in procedure in most other languages.  I doubt you put every if statement into its own function.
07:02:10 <luite> has anyone here succesfully installed Chart (0.14) on windows, with ghc 7.0.2?
07:03:57 <dark> what if I change the type a lot? in that case, I want that just a small piece of code to know about its structure (but I may not need to inspect it elsewhere)
07:04:29 <ddarius> dark: Unfortunately what you suggested and what others suggested won't really help much.
07:06:48 <CrazyThinker> Is haskell good for web development?
07:07:12 <ddarius> A foldLine function, which is basically what your combine' would be, is pretty intimately tied to the data type.  Only the most superficial changes would be abstracted from, namely renaming the constructors or a change in representation, which would make little sense in this case.  Adding, removing, or changing the types of any of the constructors would require changing all users, anyway.
07:07:37 <ddarius> dark: Of course, that is orthogonal to your original stated concern.
07:07:44 <dark> hm. o.o
07:07:55 <dark> <ezyang> and then combine p f g = p >>= foldList f g  -- but that way, wouldn't fold supposed to return a monad? like, f and g would need to return a monad, or it would be used like my combine'
07:08:12 <dark> but thinking about it, i think i want f and g to return parsers
07:08:23 <Silvah> CrazyThinker: Haskell is good for everything ;)
07:08:31 <ddarius> dark: It's -exactly- your combine'.
07:08:31 <ezyang> dark: That's fine, because f and g are completely polymorphic, and there is no recursion. 
07:09:28 <CrazyThinker> Silvah, any websites coded using haskell?
07:10:16 <dark> CrazyThinker, if you are willing to spend time learning it, I guess you can do anything. I liked one framework, yesod, but I haven't done anything with it (I will try to do some web thing with yesod, and I must say I'm still struggling with the basics)
07:10:58 <CrazyThinker> dark, where can I find other frameworks?
07:11:33 <dark> http://www.haskell.org/haskellwiki/Web/Frameworks ?
07:11:48 <Silvah> CrazyThinker: I'm positive there are some, alas I don't have any links or anything.
07:12:30 <aristid> CrazyThinker: i think the most popular web frameworks are yesod (http://docs.yesodweb.com/), snap (http://snapframework.com/),  and happstack (http://happstack.com/index.html)
07:12:35 <Silvah> Of course there's also a possibility that my memory betrays me.
07:12:57 <CrazyThinker> wow, everybody here are so helpful. Thanks you guys
07:13:48 <bla123> Saizan: thanks for the pointer to SYB, all i needed was "everywhere"
07:14:54 * Silvah goes back to reading about idiocy-based design in C++
07:18:28 <dark> "happstack-state (aka macid): an (optional) powerful NoSQL ACID storage system with native support for Haskell types and replication" <- hey, I think I would like to use it in my non-web app
07:19:34 <dark> (my other option would be sqlite)
07:19:35 <ezyang> In STG, what does sat-only \r [ds_sjT] mean? 
07:29:58 <aristid> dark: i didn't find good docs on MACID
07:33:09 <mietek> How does a monad comprehension look like?
07:33:37 <aristid> like a list comprehension
07:34:11 <ion> Exactly the same semantics and the syntax.
07:34:57 <mietek> Mm.
07:35:28 <ceii> the only difference is that general monads don't support the [_ | a <- as | b <- bs] zip notation
07:35:49 <ddarius> That's an extension (and not a very popular one) anyway.
07:36:09 <rwbarton> All those list comprehension extensions were pretty dubious, yeah.
07:38:14 <dark> manyTill1 p q = do { a <- p; b <- manyTill p q; return $ a:b }
07:38:35 <ceii> that looks a lot like an infinite loop
07:38:40 <dark> do someone know why this isn't defined? (I found my code to be much clearer after defining it..)
07:38:47 <aristid> ceii: there's a MonadZip class for that purpose, it seems
07:39:44 <spirit> i found non-ascii  symbols in one of the hackage packages (http://hackage.haskell.org/packages/archive/type-settheory/latest/doc/html/src/Type-Function.html#injective), how would i go about translating them into ascii? is there a list somewhere?
07:39:48 <dark> (it's on Text.Parsec.Combinator. but well, it can't define all useful combinators..)
07:40:47 <dankna> spirit: "Translating" them into ASCII?  What if there are no translations?
07:41:06 <ceii> spirit: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
07:42:34 <ddarius> spirit: All those symbols are just names.
07:43:29 <spirit> subset operator and existential quantifier too?
07:43:46 <mercury^> What is the notation for monad comprehensions?
07:44:03 <ceii> mercury^: the same as list comprehensions
07:44:12 <mercury^> That seems confusing.
07:44:22 <mercury^> [ and ] should be reserved for list contexts.
07:45:08 <ddarius> spirit: Yes though I don't see any existential quantifiers.
07:45:40 <spirit> sorry, i meant in set operator.
07:45:40 <ddarius> And thus the history of Haskell 1.4 -> Haskell 98 is recapitulated.
07:45:46 <ddarius> spirit: Yes, that's just a name.
07:45:49 <spirit> element of
07:45:52 <dark> mercury^, do { } ?
07:46:05 <ceii> mercury^: it is confusing to beginners, thet's why monad comprehensions were previously removed from Haskell
07:46:10 <ddarius> spirit: If you wanted to write your code in Russian you would have a bunch of non-ASCII characters as well.
07:46:13 <dark> mercury^, do { } can do the same as list comprehension, for a general monad
07:46:21 <ceii> and they'll only be added back as an extension
07:46:22 <dark> but you read it backwards
07:46:27 <mercury^> dark: so it is not the same as for list comprehension, syntax wise.
07:46:37 <mercury^> Instead you have a | within a do block.
07:47:02 <dark> hmm
07:47:16 <dark> is there some ghc flag to enable monad comprehension?
07:47:19 <spirit> ddarius: thanks for your help! i was just wondering, because all 'names' in my example were basic mathematical operators
07:47:35 <ddarius> spirit: No, there's a capital Greek pi.
07:47:36 <ceii> dark: nope, but it's a proposed GHC extension
07:47:48 <jonkri> what do people use for sql with haskell? does haskelldb support keys yet? what options are there for storing haskell terms in sqlite tables?
07:48:15 <ceii> dark: see the haskell reddit there's a link about that right now
07:48:24 <dark> mercury^, anyway I used to think that restricting it to lists was, er, too restricting. but after struggling a bit with the type system I changed my opinion
07:48:54 <mercury^> I do not think they are needed. Nor do I think list comprehensions are needed.
07:49:26 <mercury^> Or do-notation.
07:49:26 <ceii> same for me. I write my list code in do notation too, it's more readable
07:49:28 <dark> needed in which sense? most of haskell things aren't strictly 'needed'
07:49:36 <dark> lol
07:49:46 <spirit> ddarius: are those names defined elsewhere? there's a line close to the top i did not understand: "#include "../Defs.hs"
07:50:31 <dark> right now, most of my type signatures are deliberately restricted, to have better-looking type errors
07:50:56 <ceii> spirit: that's a C preprocessor directive, it will paste the contents of ../Defs.hs at that point in the file
07:51:06 <ceii> (what a horrible thing to do)
07:51:35 <spirit> ceii: I do not have the file Defs.hs, do I?
07:51:36 <ddarius> spirit: No, they are just names.  If I want to write κατα c n [] = n; κατα c n (x:xs) = c x (κατα c n xs), then I can.  One thing that is in that Defs.h is SET as that's not a legal kind and there are no kind synonyms that would let you define it.
07:52:29 <ceii> spirit: it's in the tarball
07:53:58 <dark> Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a -- why this kind of type? Can't ParsecT s u m a imply that there is a Stream s m t type automatically? (all parsec functions has this Stream .. =>)
07:54:47 <rwbarton> dark: how does the compiler know that
07:54:57 <ddarius> dark: That's not the way type classes work, and I'm pretty sure not all Parsec functions necessarily require it, though they may be artificially added to the types (but I don't think even that is true.)
07:56:36 <rwbarton> One could bundle a Stream s m t dict into the ParsecT type with an existential/GADT, but I don't see what good that would do
07:56:59 <dark> rwbarton, hmm
07:57:18 <dark> making type signatures shorter?
07:57:23 <ceii> rwbarton: I don't even think you'd need an existential, would you?
07:57:24 <dark> with less noise
07:57:44 <dark> (I'm here supposing that ParsecT implies there is some corresponding Stream, but I'm not sure)
07:57:45 <rwbarton> maybe I just mean GADT, yeah.
07:57:48 * hackagebot LinearSplit 0.2.1 - Partition the sequence of items to the subsequences in the order given  http://hackage.haskell.org/package/LinearSplit-0.2.1 (VitaliyRukavishnikov)
07:57:56 <rwbarton> Well, I don't know where t is coming from
07:57:57 <ceii> rwbarton: no, I mean nothing of the sort
07:58:23 <dark> uhm, yes, this t isn't at ParsecT type
07:58:24 <ceii> alah right
07:58:36 <ceii> the t parameter is on Stream but not ParsecT
07:58:53 <rwbarton> t must be determined by a fundep or something then
08:02:14 <spirit> ceii: when you wrote 'what a horrible thing to do' did you mean including definitions via c-preprocessor directive? i'm rather new to haskell. i need to implement a fair bit in haskell though, quickly too, so i'm trying to find stuff in hackage i might be able to use.
08:03:13 <ceii> spirit: that's what I meant. I understand why that was done in this case, but I still can't help feel it's just plain wrong
08:04:32 <spirit> ceii: isn't there a package for sets? why not use that?
08:05:13 <ceii> spirit: sorry, I don't understand what you mean
08:05:49 <spirit> ceii: why use SET if there are packages Data.Set and Type.Set
08:05:54 <ddarius> spirit: This is a package about set theory, not about sets.  If you just want sets the way most programmers use them, use Data.Set.
08:06:15 <ddarius> spirit: SET is just a CPP define for * -> *.
08:06:36 <spirit> ddarius: thanks.
08:06:38 <ceii> spirit: what the type-settheory package provides is type-level sets and functions
08:06:53 <ceii> that has nothing to do with set data structures
08:08:36 <roconnor> OMG, the ZX81 is 30 years old today. ... home computers have come pretty far in 30 years
08:08:47 <Ke> =o)
08:09:00 <ddarius> roconnor: And yet they seem no faster.
08:09:18 <roconnor> ddarius: you need to type FAST on your laptop to get it in fast mode.
08:09:24 <ceii> the intarnets got faster, that's enough for me
08:11:27 <roconnor> back in my day, computers came with their schematics, and we liked it that way!
08:11:38 <roconnor> ... seriously we did.
08:11:47 <Ke> I'd love that
08:12:08 <Ke> and I think most free software proponents would
08:12:34 <ddarius> Ke: The schematics of a modern computer would be mostly useless.
08:13:14 <spirit> ceii: here (http://hackage.haskell.org/packages/archive/type-settheory/0.1.3.1/doc/html/src/Type-Set.html#%3A%D7%3A) binary union of SETS is defined, here (http://hackage.haskell.org/packages/archive/containers/latest/doc/html/src/Data-Set.html#singleton) also, though differently
08:13:35 <Ke> 50%-60%, obviusly core2 or phenom2 layout schemas would be useless for regular people
08:14:19 <dark> if I want to implement something as a parser, but have a state unrelated to parsing, should I compose with StateT or use the parserc state?
08:14:19 <bss03> ddarius: Maybe.  Probably not though.  Semantics can be used to produce specifications, and specification are used to write drivers all the time.
08:14:48 <dark> s/semantics/schematics/ bss03?
08:15:13 <bss03> dark: yeah, sorry.
08:18:15 <rwbarton> How large would the schematics for a modern-day computer be on paper, anyways
08:19:34 <aristid> very large
08:20:50 <dark> If I'm to use State, I also don't know if I should put it at the m at ParsecT s u m a or put Parsec inside StateT
08:21:56 <Saizan> depends on how you want it to interact with backtracking, i suppose
08:23:29 <roconnor> wow, ParsecT is crazy!
08:23:40 <aristid> roconnor: why?
08:23:47 <roconnor> it uses m twice
08:24:36 <aristid> roconnor: no it doesn't oO
08:24:43 <aristid> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/src/Text-Parsec-Prim.html#ParsecT
08:24:44 <dark> o.o initially this wasn't a parser at all, but a bunch of definitions that received some parameters and returned just a State. (this is a definition of a "command"). I want to have now a command with a variable number of parameters. but it will do something different if receives 0 or 1 or 2 parameters
08:25:04 <roconnor> runParsecT :: State s u -> m (Consumed (m (Reply s u a)))
08:25:06 <dark> I think that I can receive a list of parameters, and match it
08:25:10 <roconnor> ah
08:25:18 <dark> or.. write parsers that read this list, and combine them
08:25:23 <roconnor> hmm they seem to have CPSd their transformer
08:25:35 <dark> like command_x = command_x_with_0_parameters <|> command_x_with_1_parameter
08:26:04 <aristid> roconnor: because CPS improves performance?
08:26:04 <dark> roconnor, hm o.o
08:26:33 <roconnor> aristid: I've observed an increase in performance by CPSing my monad stacks before
08:26:33 <Saizan> dark: the question is, in foo = a <|> b, if a fails, should its modifications to the state be kept when you run b?
08:26:39 <roconnor> aristid: a long time ago
08:26:45 <dark> Saizan, no, not at all
08:27:05 <aristid> roconnor: crazy! :)
08:27:11 <roconnor> it is
08:27:19 <sshc> Why is there a unit-tuple here?  newtype ArrowApply a => ArrowMonad a b = ArrowMonad (a () b)
08:27:21 <Saizan> dark: then you want to use Parsec's state or StateT, afaiu
08:27:31 <aristid> roconnor: do you even need ADTs? replace everything CPS-style :D
08:27:32 <dark> Saizan, I was doing this thought exercise supposing that in no way state modifications at a would be kept at b (because if a fails, a just never ran - in my app)
08:27:38 <dark> hm
08:27:47 <roconnor> aristid: pattern matching is for weenies
08:28:30 <aristid> roconnor: in theory, it would be possible to actually compile ADTs to CPS-style automatically, no?
08:28:34 <dark> Saizan, what you mean by parsec's state? the u at ParsecT s u m a?
08:29:08 <aristid> dark: "user state type u" :)
08:29:24 <dark> Saizan, that is exactly my two options (but hm or I had a third, putting State at m.. - that would keep state changes at a visible at b?)
08:29:44 <Saizan> dark: yes (yes)
08:29:55 <aristid> but u is a backtracking state
08:29:57 <roconnor> aristid: CPSing changes the strictness of the monad stack
08:29:59 <Saizan> i was in fact excluding that third option
08:30:26 <dark> aristid, what do you mean? that it will be actually built in a, but discarded after a fails?
08:30:27 <Saizan> so i'd probably stick with 'u', as we're calling it
08:30:59 <Saizan> dark: yes, modulo lazy evaluation
08:30:59 <aristid> dark: yes, i think the state will be rolled back when the parser rolls back
08:31:07 <aristid> dark: which is probably what you want?
08:31:18 <dark> aristid, yes
08:31:53 <dark> but, in which way StateT would prevent to run the state in a branch that will be back-tracked, anyway?
08:32:07 <dark> (I don't mind the extra computation)
08:32:12 <aristid> this is over my head now :D
08:32:23 <Saizan> i don't understand what you mean
08:33:32 <Saizan> are you asking in which way using StateT would make the state changes backtrack alongside the parsing?
08:34:29 <dark> uhm, I guess so
08:34:39 * dark somewhat confused
08:34:41 <dark> there is no problem in running the state, and then rolling it back; but there is a problem in running the state on a dead-end, and sticking it. surely I would prefer to not run the state at all in branches that will fail, but I don't see how to do that (and it doesn't seem very important)
08:35:20 <dark> if aristid said that, I supposed that StateT (the other option) wouldn't have this backtracking nature
08:36:02 <aristid> dark: actually i am basing my thoughts on this small comment in the parsec source code:
08:36:03 <Saizan> "StateT s (ParsecT ... m) a" will backtrack
08:36:03 <aristid> -- I'm presuming the user might want a separate, non-backtracking
08:36:03 <aristid> -- state aside from the Parsec user state.
08:36:10 <ceii> my impression is that StateT Parsec will rollback the state when a branch fails, whereas ParsecT State may not
08:36:25 <ceii> but I think your best bet is to try and see
08:36:38 <aristid> > 36-20
08:36:55 <Saizan> dark: 1) "StateT s (ParsecT ... m) a" will backtrack  2) ParsecT s u .. will backtrack    3) ParsecT ... (State s) will not backtrack
08:36:55 <ceii> lambdabot is dead u_u
08:37:12 <dark> ceii, but what about ParsecT s State?
08:37:32 <dark> hm
08:37:39 <ceii> dark, that's what i meant in the second alternative
08:37:46 <Saizan> dark: as far as running the actual modifications to the state that's all a matter of lazy evaluation wrt what information is needed to decide to backtrack or not
08:38:05 <FUZxxl> Is there a function Monad m => a -> m (b -> c)) -> (a -> m b) -> a -> m c ?
08:38:28 <dark> actually it seems one doesn't use ParsecT s State but ParsecT s Int for a int state
08:38:54 <Saizan> FUZxxl: liftM2 ap
08:39:07 <ceii> local lambdabot saves the day \o/
08:41:01 <Saizan> @bot
08:42:35 <dark> monadic_kid, now that is a nice nick :P
08:43:23 <dark> type Parser = Parsec String () => actually, Parser is just a String parser with () at state. so instead of Parser ReturnType i would use Parsec [Argument] MyState ReturnType and hope everything works
08:44:17 * Saizan wonders how he hasn't been clear on this
08:45:38 <dark> oh, er, I'm like, still struggling with the type system
08:51:34 <hpaste> luite pasted "Chart-0.14 installation failure"  http://hpaste.org/44538
09:02:17 <dark> runParser doesn't return the state.. it returns Either ParseError a where a is what I return from the parser. maybe I'm supposed to return the state in the parser return as well? like myparser = do { .. ; q <- getState; return (q, other things) }
09:07:57 <Saizan> yeah, you can implement runParserAndGetState that way
09:08:23 <gracenotes> woo, creating pretty sounds by adding sine waves on top of each other and feeding it to sound device as signed 16-bit integers
09:08:44 <gracenotes> next up.. creating an envelope.. however that's done o.o
09:11:00 <rostayob> Is there any library for key-value storage on disk for haskell? basically bdb, but haskell
09:12:03 <Saizan> there's a binding to bdb
09:12:43 <periodic_> It's called BerkeleyDB I believe.
09:12:58 <Saizan> there's also happstack-state but that keeps everything in memory too
09:13:23 <rostayob> Saizan: yeah I was looking at it, but it seems like it's just straight bindings to the C functions
09:13:35 <copumpkin> there's one that gives you a Map-like interface
09:13:41 <rostayob> Saizan: I already use happstack-state, but I a simpler thing on disk...
09:13:52 <rostayob> *I need a
09:14:27 <rostayob> copumpkin: Which one?
09:14:42 <periodic> So, I have a question folks.  I was approached by someone who wants to hire some people to help him port a JavaScript analysis framework from Haskell to Java.  How do I politely tell him he's going the wrong way?
09:14:48 <copumpkin> http://hackage.haskell.org/packages/archive/berkeleydb/2008.10.31/doc/html/Data-BerkeleyDB.html
09:15:01 <copumpkin> I hate that package names are case-sensitive
09:15:41 <rostayob> copumpkin: oh right, I was looking at BerkeleyDB....
09:16:16 <sm> periodic: "Sir, I'm afraid you are going the wrong way."
09:17:34 <Saizan> periodic: then he'll ask you to port the rest of his codebase to haskell, in the best case, which looks even more painful
09:23:26 <rostayob> copumpkin: That lib doesn't seem to offer you control on where to store the data
09:23:27 <roconnor> periodic: suggest porting to scala instead
09:24:10 <dons> periodic: oh, the Language.JavaScript stuff on hackage?
09:24:17 <dons> its quite nice, we use it at work for some things.
09:24:47 <dons> http://hackage.haskell.org/package/WebBits 
09:25:32 <spirit> Sorry to ask this, very basic it must be: I have a module which goes like this: "module Set where class Set s where emptySet :: s a [...]" when I load it in ghci and then type "let blah = emptySet" I get an error: <interactive>:1:11:
09:25:32 <spirit>     Ambiguous type variable `s' in the constraint:
09:25:33 <spirit>       `Set s' arising from a use of `emptySet' at <interactive>:1:11-18  Probable fix: add a type signature that fixes these type variable(s) -- why is that?
09:26:09 <dip> hi
09:26:25 <dip> is anyone there?
09:26:56 <Ptival> ...
09:27:49 <bss03> periodic: Isn't there like a JHaskell so you can run the Haskell inside whatever Java infrastructure they have?
09:27:51 <periodic> dons: actually, something at Fujitsu...
09:28:19 <starclouded> hello everybody
09:28:22 <periodic> bss03: That's what I'm wondering.  Why does it need to be ported to Java?  Is there some small part they want a different language for?  Could we FFI it?  Could we JHaskell it?
09:29:03 <periodic> roconnor: scala, now that sounds more fun.  Of course, if they are porting it to java so they can hire more heads for their department, Scala wouldn't help much.
09:29:06 <starclouded> anyone has a good web reference that list's logic Constructivist theorems and list's the classical theorems that can not be prove in Constructivist logic?
09:29:45 <roconnor> periodic: maybe they are porting it to Java to leverage existing Java libraries.
09:31:00 <bss03> periodic: Depending on your relationship with the project, prehaps all of those are good questions to ask.
09:31:22 <periodic> bss03: It's a contract that came across my desk.  I'm asking all those questions and more. :)
09:32:00 <bss03> periodic: But, if you just need someone that read and write both Haskell and Java, I'm sure you can find one.
09:33:16 <periodic> To be honest, I'd rather avoid java if I can.  I'd probably take PHP over Java, honestly.
09:33:37 <drhodes> does anyone know of a referentially transparent and dynamically typed language?
09:33:38 <periodic> Mostly because the PHP projects tend to be more dynamic and have less bureaucracy.
09:33:46 <notabel> dcoutts dons (or anyone else): when should we expect Platform 2011.2.0.0? the release timeline says today :-)
09:33:50 <ddarius> Java is pretty miserable, but I don't know if I'd take it over PHP.
09:34:05 <ddarius> drhodes: There are very few referentially transparent languages at all.
09:34:31 <ddarius> drhodes: Joy doesn't have mutation, but it doesn't handle IO in any principled way.
09:34:42 <periodic> ddarius: PHP just lends itself to less stuffy and smaller projects, which is what I want to work with right now.
09:34:46 <drhodes> hmm ok, thanks ddarius I'll take a look
09:34:57 <bss03> I wonder if the Enumerator library is good enough for inclusion in the platform.  It looks quite useful.
09:35:23 <applicative> spirit: did someone answer you?  try let foo :: Set a => a; foo = emptySet  
09:35:33 <btutt> I vote for inclusion of hlint. :)
09:38:54 <spirit> applicative: it's not quite there yet, when i tried i got this: *Set> let foo :: Set a => a; foo = emptySet<interactive>:1:20:    `a' is not applied to enough type arguments    Expected kind `*', but `a' has kind `* -> *'   In the type signature for `foo': foo :: (Set a) => a
09:39:37 <applicative> spirit: I see there's more to Set than I was seeing, let me look above again
09:40:41 <applicative> what does the class definition look like, class Set s where empty :: s a  ?
09:41:13 <spirit> yes
09:41:14 <spirit> class Set s where
09:41:14 <spirit>         emptySet        :: s a
09:41:14 <spirit>     
09:41:16 <applicative> so s is a general type like [] or Maybe or whatever.
09:41:37 <copumpkin> that type signature is going to be a pain if you ever want to make Set an instance of it
09:41:57 <spirit> How to improve it?
09:42:32 <applicative>  let foo :: Set s => s a; foo = emptySet
09:43:08 <applicative> thats sort of renaming emptySet, so it it inhabits every type of the form "s a "
09:44:35 <deech> Hi all, silly question, am I allowed to use the Haskell logo from haskell.org?
09:44:49 <spirit> applicative: ghci is fine with your solution, but when i then type in 'foo', i get a similar error message... foo
09:44:50 <spirit> <interactive>:1:0:
09:44:50 <spirit>     Ambiguous type variable `s' in the constraint:
09:44:50 <spirit>       `Set s' arising from a use of `foo' at <interactive>:1:0-2
09:44:50 <spirit>     Probable fix: add a type signature that fixes these type variable(s)
09:45:12 <napping> why is ByteString's foldr (\w r -> f w >> r) (return ()) 19 times slower than writing up a custom mapM_ in IO?
09:46:34 <applicative> spirit yes, it doesnt know what to show
09:47:15 <Eduard_Munteanu> napping: um, that is a mapM_ for Bytestrings, what do you mean?
09:47:35 <napping> I mean one interms of the internals that peeks from pointers
09:47:35 <applicative> if you have instance Set [] where emptySet = []  then try foo = emptySet :: [a] . it should know that
09:47:43 <spirit> the module i'm evaluating does have a showSet function too, applying this to foo yields the same result. it should show "{}"...
09:48:05 <Eduard_Munteanu> napping: are you using strict or lazy bytestrings?
09:48:37 <Eduard_Munteanu> Lazy is a better option in most cases.
09:49:04 <spirit> applicative: is that an idea on how to improve the code? so that i can have instances of Set?
09:49:31 <napping> lazy
09:50:04 <applicative> spirit, you do want instances, no? 
09:50:19 <spirit> I'm not sure yet
09:50:25 <spirit> I also found this on sets...
09:50:26 <spirit> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/src/Data-Set.html#singleton
09:50:38 <Eduard_Munteanu> Hrm, that's bad, I've never tried using pointers directly.
09:51:25 <napping> it works fine packaged up as a map function, I was just hoping I could use the ofld
09:51:34 <spirit> my project needs graphs as inputs and outputs. graphs i will construct via sets. so i think instances might be useful(?)
09:52:09 <Eduard_Munteanu> I've been using the fold on a few projects so far, and they seemed quite okay.
09:52:38 <Eduard_Munteanu> I mean, I got 3x slower than C code, and the bottleneck didn't seem to be there.
09:52:56 <napping> if you need to fold values together, it's probably fine
09:53:05 <napping> the thing is, I just need to sequence them
09:53:16 <applicative> spirit, about that I'm not sure, I was just trying to deal with the ghci's apparent ignorance and complaints. 
09:53:18 <Eduard_Munteanu> No, I used it to map over the bytestring, like you did.
09:53:33 <spirit> applicative: would the instance declaration sit inside the module, but outside the class?
09:54:00 <Eduard_Munteanu> bsMapM_ f xs = B.foldr (\x acc -> f x >> acc) (return ()) xs >> return ()
09:54:20 <spirit> applicative: since i'm rather unexperienced with haskell, and in a hurry to get code to actually run, i rather have it iterative so that i can test with ghci
09:54:32 <Eduard_Munteanu> (erm, the last return is unneccessary)
09:54:36 <spirit> in the end i'd want to compile it though
09:54:38 <napping> maybe the >> return() will help
09:54:47 <Eduard_Munteanu> I doubt it :)
09:55:34 <applicative> you say class Set a where emptySet :: a ; then you say later, or in any module anywhere that imports it, instance Set Maybe where emptySet = Nothing  then in 
09:56:07 <applicative> another module instance Set [a] where emptySet = [].   and so on
09:56:25 <Eduard_Munteanu> napping: have you tried profiling it to confirm the bottleneck is there?
09:56:55 <napping> that performance difference is from swapping out the map
09:57:35 <applicative> spirit, but it may be that you don't want a class in the Haskell sense anyway.  Note that the Data.Set library defines a type.
09:58:17 <applicative> spirit: it's a general type so for anything a, there's the type Set a.  So it's like lists, [a]
09:59:13 <spirit> applicative: how to find out which makes more sense?
10:00:58 <spirit> problem is, i thought i could built on someone else's code. some of the code has if-else-if-else constructs in it, instead of guards, and i got told that was bad practice. now i'm uncertain about the coder's haskell skills in general -- 
10:01:41 <applicative> spirit, the complaint about if then else would principally be stylistic, not important. 
10:01:47 <ceii_> spirit: if then else expressions aren't a red flag or anything.
10:02:40 <applicative> it usually is a bad sign, i feel, when i'm inclined to pile them up, that I haven't thought through all the cases.  but it's not like it's wrong or something.
10:03:33 <applicative> there are various graph libraries around.  the most illustrious, fgl is a bit hard, I don't really know it
10:04:09 <spirit> applicative, ceii, another piece of code seems wrong though... "isInjective m = card (keySet m) == card (valueSet m)"
10:04:31 <ceii_> that's perfectly normal
10:04:47 <spirit> ceii, it's right you think?
10:05:17 <ceii_> I don't see anything wrong with it out of context
10:05:44 <applicative> m has two sets connected with it, it's injective if their 'card'(inalities) is the same.  makes sense. not sure it needs such an ugly name
10:05:49 <applicative> are the same
10:07:09 <applicative> isHalfBoysHalfGirls family = card (girlsOf family) == card (boysOf family)
10:07:45 <ddarius> applicative: Usually injective would be that card (keySet m) <= card (valueSet m)
10:07:51 <spirit> {1,2,3} {1,2,3,4,5} m(1)=1, m(2)=2, m(3)=3 -- m injective but not surjective
10:08:13 <applicative> yes, we are complaining about "isInjective" but without enough context
10:08:28 <Eduard_Munteanu> @bot
10:08:35 <applicative> spirit: the code is not wrong, the nomenclature is
10:08:45 <Eduard_Munteanu> I'm worried about her.
10:09:22 <ceii_> where is lambdabot hosted anyway? does anyone know what happened to her?
10:09:33 <ddarius> applicative: I would say in this case the name suggests a semantics that is not met by the definition.
10:10:02 <Eduard_Munteanu> lambdabot is hosted by Cale, but IDK what happened.
10:10:04 <napping> doesn't keySet and valueSet extract the actual keys and values from the map?
10:10:09 <spirit> maybe the code is ok, it sits inside a class SetMap, rather specific -- like std::map
10:10:12 <Cale> oh, is it down?
10:10:14 <spirit> yes, all fine maybe
10:10:14 <applicative> spirit: like if i said  "isThreePlaceFunction x = (x + 2) == 2*x "  that would be a stupid name for a predicate
10:10:14 <ddarius> lambdabot is hosty by lispy and administrated by Cale.
10:10:20 <ddarius> s/hosty/hosted/
10:10:30 <napping> um, I think you all have the definitions backwards
10:10:31 <Eduard_Munteanu> Cale: yes for a couple of days it seems.
10:10:36 <Eduard_Munteanu> !seen lambdabot
10:10:37 <napping> injective means each key maps to a different value
10:10:42 <Cale> Y U NO INFORM ME? ;)
10:10:43 <Eduard_Munteanu> preflex: seen lambdabot
10:10:43 <preflex>  lambdabot was last seen on #haskell 1 day, 3 hours, 44 minutes and 44 seconds ago, saying:     Just c -> Just (a c)
10:10:45 <napping> so the cardinality check seems just fine
10:10:48 <applicative> spirit, where is this module?
10:11:52 <napping> at least if keysSet ~= Data.Map.keys and valueSet ~= Data.Map.elems
10:12:04 <Eduard_Munteanu> @bot
10:12:08 <lambdabot> :)
10:12:09 <shachaf> :)
10:12:15 <spirit> applicative: i only have a tar ball.
10:12:19 <Eduard_Munteanu> Heh.
10:12:28 <ddarius> If valueSet = map (theThing!) keySet, then that definition works.
10:12:39 <Eduard_Munteanu> @vixen We missed you, darling!
10:12:44 <lambdabot> I dunno
10:12:45 <spirit> that Data.Map?
10:13:21 <spirit> Data.Set and Data.Map seem to be better candidates to use, as they are hackage packages
10:13:22 <napping> it would actually have to be Data.Map.keysSet and Set.fromList . Data.Map.elems
10:14:36 <napping> pozic: You had some slow or unsafe histogram code
10:14:57 <applicative> spirit: can you paste the module youre quoting from, with isInjective etc on hpaste.org?
10:15:36 <napping> I looked at a bit more, and it seems all unsafety can be encapsulated into quite reasonable primitives
10:15:38 <spirit> I have classes MapElmt as well as Map in the code I'm trying to use and re-write. The Data. versions aren't classes, are they? What are the consequences of not having them sit inside classes?
10:15:52 <Eduard_Munteanu> napping: what histogram do you need?
10:15:58 <dons> periodic: huh. 
10:16:22 <spirit> applicative: is the code then online, as in would google find snippets?
10:16:27 <napping> there was just some discussion a while back about how it is hard to make a histogram of bytes efficiently from a string, compared to the obvious C
10:16:56 <Eduard_Munteanu> napping: I've been using STUArrays for that.
10:17:03 <napping> with unsafe indexing?
10:17:17 <applicative> spirit, no, i was just thinking our friends will be able to advise you if they can see what you are looking at.
10:17:30 <Eduard_Munteanu> No, readArray and writeArray
10:17:45 <napping> ah, you can probably pick up a factor of two from unsafe indexing
10:18:09 <Saizan> spirit: if you put it on hpaste it'll be public, but there are pastebins with short expiration time
10:18:13 <Eduard_Munteanu> I'm doing it with my bsMapM_
10:18:18 <Eduard_Munteanu> I see.
10:18:22 <napping> or this guy: http://hpaste.org/44539/boundedupdate
10:18:31 <spirit> applicative: it's some professors code that he has on his website, but wrapped in a tar ball. it's not like a forum or mailinglist? hpaste? i cannot put his code up there and discuss it if there will be traces.
10:18:32 * napping <3 GHC
10:18:43 <hpaste> napping pasted "boundedUpdate"  http://hpaste.org/44539
10:18:47 <spirit> ah...
10:18:59 <spirit> i can choose 'expire in an hour' -- that safe?
10:19:30 <napping> um, this chanell is also logged
10:19:42 <Saizan> anyhow if you are forbidden from discussing the code with other people
10:19:51 <Saizan> i'm afraid we can't help you?
10:20:11 <ddarius> napping: That seems pointless.
10:20:19 <napping> ddarius: Nope!
10:20:34 <rwbarton> the 'if' could get hoisted
10:20:40 <napping> I find your lack of faith in the optimizer disturbing ;)
10:20:57 <spirit> i'm sure it's ok to discuss code, as it's available on his website. but i would not want to find large pieces of code, as it might appear rude.
10:21:09 <napping> spirit: How about a link to the code, then?
10:21:17 <Eduard_Munteanu> napping: btw, I hope you're using at least -O
10:21:22 <napping> -O2, yes
10:21:40 <napping> ddarius: STUArray, at least, cannot modify bounds at runtime
10:21:46 <napping> this would fail pretty hard in that case ,I think
10:21:51 <Eduard_Munteanu> I suppose -funbox-strict-fields doesn't help much there, since STUArray should already be unboxed.
10:22:10 <ddarius> napping: What does "modifying bounds" have to do with anything?
10:22:15 <Eduard_Munteanu> napping: why do you care about bounds? Just let it be [0..255].
10:22:16 <napping> but with any MArray where bounds are fixed, this has a chance oto float out the test
10:22:45 <napping> aha, but this lets you use a Word8 index into an array indexed by (0,255) without a bounds check
10:22:52 <Eduard_Munteanu> Unless you're trying to do it for UTF8/unicode stuff.
10:22:57 <napping> and without exposing any unsafe behavior
10:23:27 <rwbarton> really one would like the compiler to do this on the naive code without jumping through these hoops
10:23:46 <napping> maybe not this one
10:24:12 <napping> How often are array ounds actually (minBound,maxBound)?
10:24:12 <applicative> spirit:  google's code search doesnt show a use of "isInjective" that fits this case
10:24:14 <ddarius> napping: Yes, you can do an index without a bounds check after doing a bounds check.
10:24:39 <spirit> here is the code, it's a bunch of files though. http://www2.informatik.uni-erlangen.de/teaching/SS2008/Haskell/category.tar
10:24:53 <napping> ddarius: this performs identically to code with unsafe accesses, and twice the speed of the code with safe read and write
10:25:40 * BMeph shudders at the sight of "naked" .tar files...
10:25:54 <ddarius> napping: On what code?
10:26:01 <spirit> applicative: i pasted ther link to the tar ball. isinjective is in SetSeq.hs
10:26:11 <napping> http://hpaste.org/paste/44539/boundedupdate_annotation#p44541
10:26:30 <napping> the check against minBound and maxBound floats out of the loop
10:26:42 * ddarius suggests using more $
10:26:43 <kniu_> Release date for Haskell Platform 3 was set at march 5.
10:26:49 <kniu_> And it's march 5 today.
10:26:51 <Eduard_Munteanu> That check is unneccesary if you're indexing with Word8 anyway.
10:27:02 <napping> how so?
10:27:05 <kniu_> Anybody know what's going on?
10:27:16 <Eduard_Munteanu> 2^8 - 1 = 255
10:27:31 <napping> the bounds could have been (0,128)
10:27:49 <Eduard_Munteanu> Oh, in other cases yes, but if you do a binary histogram....
10:28:15 <napping> thepoint is to provide safe interfaces that let this code be fast
10:28:24 <applicative> spirit: handsome code 
10:28:56 <spirit> applicative, so it's all fine?
10:29:05 <napping> applicative: did you write it?
10:29:16 <Heffalump> kniu_: I think they're furiously working on it.
10:31:11 <spirit> applicative: would you know how to run the test file?
10:31:16 <Heffalump> is anyone else getting spammed by messages by antizeus?
10:31:23 <applicative> napping, ha.  It does case a flood of light on "isInjective"
10:32:21 <napping> ddarius: do you see what it is doing now?
10:32:38 <ddarius> napping: I saw what it was doing from the beginning.
10:32:58 <napping> okay, you seemed to wonder why it saved dynamic checks
10:33:14 <napping> Eduard_Munteanu: you are using a foldr like that and getting decent performance?
10:33:28 <kniu_> yes, I got spammed by antizeus too.
10:33:35 <kniu_> Let's form a support group and talk about it.
10:33:55 <napping> no, that's what ops are for
10:34:02 <Eduard_Munteanu> napping: well, it was quite decent, since I was doing a few sorts of compression on the input. The histogram was just a small part.
10:34:27 <Eduard_Munteanu> Say, Huffman coding.
10:34:30 <napping> hmm, doing just the histogram it seems the fold has a notable overhead
10:35:05 <napping> I'm not too surprised if it's still a small part of time when you do more work
10:35:14 <ddarius> napping: I would rather have bulk operations that don't rely on the optimizer and aren't limited to bounded types.
10:35:40 <napping> I'm not sure how far you can get with that in Haskell
10:36:09 <ddarius> napping: See Oleg's branding stuff.  Also see languages like J.
10:36:20 <napping> I see this as a degenerate case of providing evidence that something is in bounds
10:36:53 <napping> yeah, it would be ideal if the array accepted branded indices, and this could have been a branding operation based on the type bounds
10:38:00 <applicative> spirit, some of the test modules work fine. I can't figure out the duplicate instances problem with a couple of them.
10:39:39 <spirit> it needs a flag, -X... looking for it, i remember that solved the issue.
10:40:02 <Eduard_Munteanu> napping: well, worst case you could FFI for the histogram, but see if you really need it faster first.
10:40:41 <napping> this faster than 1/2 C, so I'm happy for now
10:41:21 <napping> also, histogram is a bit simpler than what I'd really like to do
10:41:33 <napping> though not by a whole lot
10:43:56 <chiho> Does anyone know how the length function is implemented in ghc? I tried writing by my own function { length' [] = 0  ; length' (_:xs) = 1 + length' xs } and it's not nearly as fast. I compiled with -O2
10:44:24 <napping> it's probably like foldl
10:44:29 <napping> foldl'
10:44:34 <ddarius> chiho: That's not tail recursive and is more generic that the Prelude length and is probably defaulting to Integer.
10:45:00 <Eduard_Munteanu> foldl' vs foldl shouldn't matter at -O2
10:45:27 <chiho> ddarius: not tail recursive?
10:46:10 <spirit> applicative, does this help? ghci -XFlexibleContexts SetMap.hs
10:46:39 <ddarius> Eduard_Munteanu: That's not true at all.
10:47:04 <Eduard_Munteanu> Erm, in this particular case, esp. if you use Ints.
10:47:17 <Eduard_Munteanu> @src sum
10:47:17 <lambdabot> sum = foldl (+) 0
10:47:40 <Eduard_Munteanu> @src length
10:47:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:48:26 <Eduard_Munteanu> Since Ints are strict.
10:48:32 <chiho> whoa, did know you can do that
10:48:36 <chiho> didn't*
10:49:03 <Eduard_Munteanu> chiho: you can do it here (or in lambdabot), not in ghci
10:49:08 <Jafet> length = sum . map (const 1)
10:49:59 <Eduard_Munteanu> But you can install lambdabot locally, via cabal.
10:50:13 <chiho> good to know, thanks
10:50:43 <chiho> Jafet: your function is faster than mine, but still not Prelude.length fast
10:51:09 <chiho> at least in ghci, let me try actually compiling
10:51:20 <Eduard_Munteanu> chiho: give a type signature and make sure it ends up an Int
10:51:44 <Jafet> Uh, it is?
10:52:21 * Jafet chalks it up to Haskell being contrary for its own sake.
10:52:22 <Eduard_Munteanu> > let len = sum . map (const 1) :: [a] -> Int in len [1,2,3,4]
10:52:24 <lambdabot>   4
10:53:53 <spirit> applicative, i might have figured out how to. ghci -XFlexibleContexts SetMap.hs and in order to see what the calculations have yielded, e.g. just type in ceq1 :-)
10:54:42 <chiho> Eduard: added signature length' :: [a] -> Int  . Still slow :-(
10:56:23 <Eduard_Munteanu> chiho: try   length' = foldl' (+) 0 . map (const 1)    then.
10:57:38 <Eduard_Munteanu> Oh, heh.
10:57:50 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#length
10:57:55 <chiho> Eduard: that's fast
10:58:16 <Eduard_Munteanu> It seems GHC's uses unboxed stuff.
10:59:15 <ddarius> Eduard_Munteanu: That's probably unnecessary and just a relic from the days when GHC was not as good at unboxing.
10:59:39 <Eduard_Munteanu> I wonder if -funbox-strict-fields helps there.
10:59:48 <ddarius> Eduard_Munteanu: It doesn't because there are no strict fields.
10:59:52 <ddarius> Or fields at all.
11:00:14 <Eduard_Munteanu> @src Int
11:00:14 <lambdabot> data Int = I# Int#
11:01:00 <Eduard_Munteanu> Hm, but why isn't foldl as fast as foldl' in this particular case, I wonder.
11:02:12 <ddarius> Eduard_Munteanu: I believe he was comparing his definitely wrong implementation against your foldl' one, not the sum one against the foldl' one.
11:03:11 <Eduard_Munteanu> Hrm, also GHC's 'sum' is actually a foldl'.
11:03:25 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sum
11:03:27 <chiho> I also tried    length' = foldl' (\x y -> x + 1) 0     at one point and it's also slow, but Eduard's solution seems to be on par with ghc's performance-wise
11:04:15 <ddarius> chiho: With a type signature?
11:04:31 <chiho> doh... no
11:04:46 <ddarius> Eduard_Munteanu: No it isn't.
11:05:35 <aavogt> > sum [1.. ] > (5::Nat)
11:05:36 <lambdabot>   Not in scope: type constructor or class `Nat'
11:05:38 <aavogt> > sum [1.. ] > (5::Natural)
11:05:39 <lambdabot>   Not in scope: type constructor or class `Natural'
11:06:17 <aavogt> does somebody know what the correct type for that to work here is?
11:07:17 <hpaste> a pasted "graphy catty"  http://hpaste.org/44542
11:07:41 <applicative> spirit, yes, it seems fine. you can view a bunch of graphs at once with something cretinous like what hpaste just linked ^^^
11:09:04 <Eduard_Munteanu> Ah, right, it isn't, sorry.
11:10:21 <ddarius> Eduard_Munteanu: It is a bit subtle why the given definitions aren't strict.  It's easy to get the right answer for sort of the wrong reasons.
11:11:41 <spirit> how to go about finding TestCatGraph, applicative, hpaste?
11:12:34 <Eduard_Munteanu> aavogt: erm, what's that?! :)
11:12:50 <Eduard_Munteanu> That rather rings an Agda bell.
11:13:16 <applicative> spirit: yeah, i say at the top you need to give that module a name, inside it, so add "module TestCatGraph" on the first , else ghc thinks its name is Main
11:13:19 <aavogt> Eduard_Munteanu: like these http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-Natural.html
11:13:29 <chiho> ddarius: so type signature helps, now my function is still slower than ghc's, but comparable 
11:13:30 <ddarius> Actually, it is technically strict in the accumulator but GHC doesn't quite figure it out.
11:13:34 <romanandreg> hey guys, I'm having a hard time trying to make the ncurses library link in Mac OS SL
11:13:38 <romanandreg> I'm getting this error
11:13:39 <romanandreg> file was built for unsupported file format which is not the architecture being linked (i386)
11:14:24 <romanandreg> complete error => http://pastie.org/1637072
11:14:31 <applicative> spirit: on the first line of his file TestCatGraph.hs . He didn't give it a name
11:14:37 <Eduard_Munteanu> Those seem to be type-level nats, according to the source :/
11:15:22 <spirit> TestColimitsSet.hs you mean, applicative?
11:15:31 <romanandreg> can anyone help me with this annoying compiling-linking issue?
11:16:20 <applicative> romanandreg you are using a 32 bit ghc? from the Haskell Platform installer?
11:16:35 <romanandreg> applicative: I'm using the latest haskell platform
11:16:48 <Eduard_Munteanu> Wait, how in the world do those conversions between Natural and integrals work without higher rank types? :/
11:16:57 <romanandreg> applicative: installed the native ncursesw using homebrew, probably it uses XCode to compile the library
11:18:04 <notabel> romanandreg: make sure both homebrew and ghc are using the same word size.  it looks like GHC is trying to build 32bit, but homebrew built ncurses as 64bit
11:18:17 <Eduard_Munteanu> Last time I tried, one of the conversions (don't remember which) couldn't be done without a rank-2.
11:18:35 <spirit> i don't know how to. module TestCatGraph import TestCatGraph?
11:19:05 <applicative> romanandreg: maybe uninstall then reinstall with brew install ncursesw --universal
11:19:22 <romanandreg> applicative: going to try that
11:19:34 <msieradzki> kind of off topic: is there any chance GHC/haskell stuff could use github like mono project does?
11:20:23 <Eduard_Munteanu> > sum [1..] :: [Natural]
11:20:24 <lambdabot>   Not in scope: type constructor or class `Natural'
11:20:33 <Eduard_Munteanu> aavogt: that looks like what you need, anyway
11:20:42 <Eduard_Munteanu> erm.
11:20:50 <Eduard_Munteanu> > sum ([1..] :: [Natural])
11:20:51 <lambdabot>   Not in scope: type constructor or class `Natural'
11:21:03 <platypine> lambdabot
11:21:06 <aavogt> something of the sort used to be in scope. Cale do you know?
11:21:15 <applicative> msieradzki, I gather the ghc itself is moving to git so it will appear there.  There was a test version up some time ago
11:21:29 <Eduard_Munteanu> @instances Num
11:21:29 <lambdabot> Double, Float, Int, Integer
11:21:57 <aavogt> > 5 :: CReal
11:21:58 <lambdabot>   5.0
11:22:03 <msieradzki> pull request functionality on git hub is really, really nice but that's it, not like I'm any kind of contributor
11:22:33 <Eduard_Munteanu> Heh, funny... is GHC actually considering abandoning Darcs as the main VCS?
11:22:53 <applicative> Eduard_Munteanu: maybe I dreamt it
11:23:04 <ddarius> It was but then it was a pain to switch and darcs got better.
11:23:21 * Eduard_Munteanu wonders if Git has a frontend for Darcs
11:23:31 <applicative> ddarius, but I thought then there was another volte face
11:23:52 <Eduard_Munteanu> It does for SVN, at least, and CVS IIRC.
11:23:53 <ddarius> Unless it happened 
11:24:18 <ddarius> I'm not aware of anything like that.
11:24:36 <Eduard_Munteanu> #instance-importing
11:24:38 <Eduard_Munteanu> @instance-importing
11:24:38 <lambdabot> Plugin `instances' failed with: Prelude.last: empty list
11:24:43 <Eduard_Munteanu> @instance-importing Num
11:24:44 <lambdabot> Double, Float, Int, Integer
11:25:00 <ddarius> @instances-importing Num Complex
11:25:01 <lambdabot> Couldn't find class `Complex'. Try @instances-importing
11:25:01 <aristid> @instance-importing Num Data.Complex
11:25:01 <lambdabot> Couldn't find class `Data.Complex'. Try @instances-importing
11:25:05 <ddarius> @instances-importing Complex Num
11:25:06 <lambdabot> Complex a, Double, Float, Int, Integer
11:25:11 <applicative> spirit, sorry I moronically said write "module TestCatGraph" and likewise for the other Test.. modules, but its "module TestCatGraph where" of course
11:25:20 <aristid> @index Complex
11:25:21 <lambdabot> Data.Complex
11:25:31 <aristid> ddarius: Complex is flat-namespace for Data.Complex?
11:25:45 <romanandreg> applicative: nope http://pastie.org/1637109
11:25:48 <romanandreg> still causing errors
11:25:49 <ddarius> Complex is the (Haskell 98) standard module.
11:25:57 <ddarius> newsham: Is your kid coding yet?
11:26:00 <romanandreg> notabel: http://pastie.org/1637109
11:28:37 <applicative> romanandreg: man, linking errors are so ugly
11:28:47 <romanandreg> applicative: so frustrating
11:29:04 <spirit> i tried module TestCatGraph where
11:29:04 <spirit>     
11:29:04 <spirit>     import TestCatGraph, but don't i also need import CatGraph? yields errors though, applicative
11:31:01 <ogkwrer> hi
11:31:24 <Eduard_Munteanu> ogkwrer: hi
11:31:51 <ogkwrer> k
11:32:30 <notabel> romanandreg: I don't use homebrew, so I may be off base, but it looks from that transcript like brew is putting ncurses into /Users/roman/.homebrew/Cellar/ncursesw/5.7 but you're telling cabal to look for it in /Users/roman/.homebrew/lib
11:32:57 <spirit> applicative, i got it, cheers! :-) but where do fe01, fe12, mor01, ... come from?
11:33:51 <applicative> spirit: there are just warnings due to his subtle import exports    
11:34:19 <applicative> spirit: they are just the terms defined in TestCatGraph 
11:35:38 <spirit> i get TestCatGraph.hs:9:18: Not in scope: `fe01'
11:35:38 <spirit> TestCatGraph.hs:9:24: Not in scope: `fe12'
11:35:38 <spirit> , would i have to define them as constants inside module TestCatGraph?
11:35:55 <spirit> what's subtle about the imports/exports?
11:36:09 <applicative> spirit: no, they are constants in TestCatGraph.hs do you see that module
11:36:45 <spirit> i see this file -- http://hpaste.org/raw/44542/graphy_catty
11:37:15 <spirit> it imports TestCatGraph, but i changed it to import CatGraph and named the module TestCatGraph
11:38:11 <applicative> spirit: Warning: `poObj2' is exported by `module CatSet' and `module Colimits' -- this is because CatSet and Colimits both import then reexport the further module Category
11:38:33 <Drknzz> Hi guys! I am having a problem with the haskel platform in kubuntu maverick x64: No matter what i do, ghci outputs: ghc: mmap 0 bytes at (nil): Invalid argument
11:38:33 <Drknzz> ghc: Try specifying an address with +RTS -xm<addr> -RTS
11:39:13 <Drknzz> Any ides?
11:39:50 <applicative> spirit: sorry, I wasn't clear, he has a module TestCatGraph my module is Main, since it has a main function
11:39:51 <spirit> applicative, would that be 'dangerous', what you called 'subtle'?
11:40:30 <applicative> spirit, I think he has a reason, I can't follow the whole library all at once ... 
11:42:08 <Drknzz> :((
11:43:15 <applicative> Drknzz: you just installed the ghc + ghci and so on?  but now this is what happens when you call ghci?
11:43:53 <spirit> applicative: :-) it appears he gave the course more than once and i had previously downloaded another version of his tarball that didn't TestCatGraph.hs -- good i found the other one with many more test files!
11:44:22 <Drknzz> applicative: I installed the haskell-platform package as the get haskell page suggested
11:45:34 <applicative> spirit, oh i see.  I was wondering about this failure to communicate. 
11:45:41 <Drknzz> applicative: GHCI and GHC are installed. dont know much more
11:46:46 <gwern> hm, how to download https links... does Network.HTTP even do that?
11:46:59 <Heffalump> gwern: no. And what's worse, it talks HTTP on port 443 if you try.
11:47:27 <gwern> Heffalump: yeah, when I tried my usual openURL definition, github was giving me301 moved permanently reposes
11:50:27 <Drknzz> :/
11:50:33 <applicative> Drknzz, what happens if you call e.g. "ghc-pkg list" or just "ghci"
11:51:04 <applicative> Drknzz, or just ghc -V for that matter
11:51:41 <Drknzz> applicative: Pretty much everything that i do with ghc/ghci triggers this: http://pastebin.com/rrru247L
11:51:49 <Drknzz> At least everything ive tried
11:53:46 <Eduard_Munteanu> Drknzz: what's in /proc/sys/vm/mmap_min_addr ?
11:54:12 <gwern> Heffalump: looks like the curl binding handles https by default, so I guess I'll just use that
11:54:26 <Drknzz> Eduard_Munteanu: 65536
11:54:41 <Eduard_Munteanu> Drknzz: set it to 0, and try again.
11:54:47 <Eduard_Munteanu> Also, is this a 64-bit platform?
11:54:56 <Drknzz> Eduard_Munteanu: Kubuntu Maverik x64
11:55:14 <Eduard_Munteanu> But did you get the 64-bit platform?
11:55:40 <Drknzz> Eduard_Munteanu: I guess so, i installed the haskell platform from the ubuntu repos
11:56:43 <Eduard_Munteanu> See if   echo "0" > /proc/sys/vm/mmap_min_addr    works around it
11:56:58 <Drknzz> Eduard_Munteanu: Ok
11:57:12 <rwbarton> hopefully ghc doesn't actually require mmap_min_addr to be 0, that would be pretty lame
11:57:23 <Drknzz> Eduard_Munteanu: I have no permissions over the file, not even with sudo
11:57:47 <rwbarton> try echo 0 | sudo tee /proc/sys/vm/mmap_min_addr
11:57:54 <Eduard_Munteanu> Oh!
11:57:59 <Eduard_Munteanu> ah
11:58:09 <Eduard_Munteanu> Or just sudo su first
11:58:22 <Eduard_Munteanu> Since '>' is outside the sudo-ed command
11:58:43 <spirit> is anyone using leksah under ubuntu? is it good to use yet?
11:59:06 <Drknzz> rwbarton: that did it, cat now reports its 0
11:59:17 <Eduard_Munteanu> Does GHC work now?
11:59:25 <Drknzz> Still getting the exact same output from ghci
12:00:44 <newsham> ddarius: nope.  he's not allowed near the computers yet.
12:00:56 <Drknzz> Should i try to compile from source instead?
12:01:01 <Eduard_Munteanu> Hrm, you should probably set that back how it was.
12:01:28 <Eduard_Munteanu> Drknzz: what version of GHC is that?
12:01:46 <newsham> ddarius: his main tasks are lining up wooden blocks and cars, crawling into boxes, climbing on his dad and naming pictures of animals.
12:01:57 <newsham> peano arithmetic later...
12:02:14 <Drknzz> Eduard_Munteanu: GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help
12:02:14 <Drknzz> Glasgow Haskell Compiler, Version 6.12.3, for Haskell 98, stage 2 booted by GHC version 6.8.2
12:03:02 <rwbarton> Drknzz: did you try something like ghci +RTS -xm65536 -RTS ?
12:03:02 <Eduard_Munteanu> Heh, newsham 
12:03:15 <romanandreg> notabel: homebrew creates an include and lib directory that hold linkings of each library you are installing
12:03:31 <gwern> @hoogle [a] -> a -> Int
12:03:32 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
12:03:32 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
12:03:32 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
12:03:34 <romanandreg> if that were the issue I guess I wouldn't even compile because it couldn't find the libraries
12:03:57 <gwern> Maybe Int? what'sthe maybe for, 0?
12:04:22 <Eduard_Munteanu> IDK much about Ubuntu, but I'd also suspect SELinux breakage there, it's an idea.
12:04:23 <Drknzz> rwbarton: Output: http://pastebin.com/MGNTTGnZ
12:04:38 <rwbarton> no space after -xm
12:04:45 <Drknzz> I tried both
12:04:51 <rwbarton> oh sorry
12:05:05 <Drknzz> :/
12:05:07 <aristid> gwern: elemIndex probably returns nothing, if the element was not found at all
12:05:17 <Silvah> > elemIndex 6 [2, 3, 4]
12:05:18 <lambdabot>   Nothing
12:05:18 <gwern> > elemIndex '/' "blog post"
12:05:19 <lambdabot>   Nothing
12:05:21 <sepp2k1> gwern: The Maybe is for when the list does not contain the element you're looking for.
12:05:22 <gwern> > elemIndex '/' "blog post/"
12:05:22 <lambdabot>   Just 9
12:05:28 <rwbarton> hmm, I wonder why it's trying to mmap 0 bytes anyways
12:05:35 <gwern> shoot. that's not what I want, I just want a count
12:05:45 <ogkwrer> hi
12:05:46 <gwern> so... maybe length . elemIndices...
12:06:02 <aristid> :t count .: filter
12:06:02 <lambdabot> Not in scope: `count'
12:06:09 <aristid> :t length .: filter
12:06:10 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
12:06:22 <Silvah> :t (.:)
12:06:23 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
12:06:37 <Silvah> Erm, what?
12:06:42 <Drknzz> I will try to compile from source....
12:07:42 <djahandarie> :t (Prelude..) Prelude.. (Prelude..)
12:07:42 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:07:48 <djahandarie> Silvah, this is what it really is ^^
12:07:53 <Eduard_Munteanu> Drknzz: that's going to take some time
12:08:01 <Silvah> What's the type of (.:) wrt. functions?
12:08:19 <Drknzz> Eduard_Munteanu: Especially on a laptop? XD
12:08:53 <ddarius> djahandarie: The middle Predule.. qualification is unnecessary.
12:09:03 <djahandarie> Yeah
12:09:17 <djahandarie> But it might be less clear mixing them
12:09:31 <Silvah> djahandarie: I know, but I didn't use Haskell for some time and now I have problems with deciphering type involving functors.
12:10:26 <Drknzz> Eduard_Munteanu: just compiled only ghci from source
12:10:33 <djahandarie> Silvah, when applied to a function, you are really just using the (r ->) instance
12:10:42 <Drknzz> And now i got prelude :)
12:10:47 <djahandarie> So go ahead and replace f and g with (f ->) and (g ->) to see what is going on
12:10:58 <djahandarie> When you do, you should get the version using Prelude.. rather than the lambdabot .
12:10:58 * ddarius actually thinks the functor version makes it a bit more clear what is going on.
12:11:18 <djahandarie> ddarius, yeah, I actually agree
12:11:49 <djahandarie> Open up two levels of crap and then do something there, then wrap it back up
12:13:24 <applicative> Drknzz, so its working? 
12:14:04 <Drknzz> applicative: Seems like it. At least i got the prelude prompt working now, and that error isnt showing up in neither ghc nor ghci
12:14:04 <Silvah> djahandarie: this makes sense.
12:14:21 <Drknzz> applicative: I think i am going to build the haskell-platform package from source as well
12:19:03 <applicative> romanandreg: It seems like in building TicTacToe it is trying to link some other version, not the homebrew one.  
12:20:24 <applicative> romanandreg: wait but it says its trying the homebrew one. hm.
12:22:03 * applicative doesn't think this could be true: "(maybe you meant: _ncurseszm0zi2_UIziNCurses_baudrate1_info, _ncurseszm0zi2_UIziNCurses_baudrate_info , ... "
12:30:05 <ddarius> I hate Java.
12:34:47 <copumpkin> ddarius: but it's enterprise-ready!
12:35:47 <Jafet> I don't think they use Java on the Enterprise.
12:36:02 <TTimo> it's fat and slow, so maybe they are
12:36:05 <Eduard_Munteanu> The NCC-1701? I sure hope not.
12:37:09 <hpaste> RickyJones pasted "L1 Interpreter"  http://hpaste.org/44543
12:37:51 <ddarius> copumpkin: Unfortunately for Java, C# is also enterprise-ready and doesn't suck.
12:38:06 <copumpkin> then C# can't be enterprise-ready
12:38:11 <hpc> ddarius: but only on windows
12:38:28 <hpc> everyone knows the current business trend is ipads
12:38:54 <pozic> Is there also any good enterprise software?
12:39:05 <c_wraith> hudson?
12:39:09 <pozic> You always hear people complain, but it cannot possibly all suck, right?
12:40:13 <hpc> pozic: clearly they don't understand webscale
12:43:56 <romanandreg> applicative: I'm trying to set ldflags to -arch i386 as suggested here
12:44:05 <romanandreg> http://passingcuriosity.com/2009/haskell-on-snow-leopard/
12:44:36 <dons> those who'd like to be beta-testers for new HP installers, a beta site is up, http://code.galois.com/darcs/haskell-platform/download-website/ 
12:44:39 <dons> please send feedback
12:45:10 <dons> romanandreg: what are you doing?
12:45:17 <romanandreg> nope... didn't do a thing
12:45:38 <romanandreg> dons: trying to compile ncurses-0.2 library using GHC Platform 2010.02
12:45:41 <romanandreg> no luck so far
12:45:42 <dons> ah
12:46:01 <romanandreg> I'm on Snow Leopard, installed the ncursesw library using homebrew
12:46:23 <romanandreg> dons: http://pastie.org/1637109
12:49:18 <pozic> dons: The text could be hyperlinked on http://code.galois.com/darcs/haskell-platform/download-website/contents.html#functionality
12:49:39 <pozic> dons: I don't care (as I already know all the features), but new users might be interested. 
12:49:54 <dons> good idea
12:50:12 <c_wraith> romanandreg: did you make sure that ncurses built a 32 bit version of the lib?
12:50:41 <pozic> dons: I am not sure what the flowers have to do with Haskell, but it sure does look pretty. 
12:50:41 <platypine> 03+6302+
12:50:46 <dons> spring.
12:50:53 <dons> pozic: each release is themed seasonally
12:51:26 <Saizan> the compression artifacts make it look less pretty
12:51:30 <dons> sigh
12:52:05 <dons> i'll hire a designer one day
12:52:11 <pozic> If it loads fast it is good ;)
12:52:15 <romanandreg> c_wraith: how I'm completely possitive that's the case
12:52:33 <copumpkin> dons: I like it
12:53:13 <pozic> dons: it could also do something else on wide-screens. 
12:53:16 <c_wraith> romanandreg: how did you build it?
12:53:31 <applicative> whoa, a 64 bit installer for os x
12:53:32 <pozic> dons: the contents.html page uses about one third of my screen here. 
12:53:39 <copumpkin> applicative: amazing, innit
12:53:54 <revenantphx> dons: oh! you used my CSS :D
12:54:04 <applicative> it is, there goes my careful constructed cabal install house of cards
12:54:07 <revenantphx> dons: Are the back pages messed up? I can fix it, if need bee :\/
12:54:08 <pozic> dons: wording: trivial is an academic word.
12:54:14 <revenantphx> s/bee/be/
12:54:35 <pozic> dons: trivial => easy.
12:54:42 <revenantphx> dons: And, on a side note, the background image should really be changed.
12:55:13 <pozic> dons: the download website could suggest platform based on browser string.
12:55:34 <pozic> dons: see how the Opera website does things for an example of that.
12:56:45 <Tau> copumpkin, i wasn't spaming.
12:56:49 <Tau> it is antizeus.
12:56:57 <pozic> dons: http://code.galois.com/darcs/haskell-platform/download-website/linux.html The Linux in rendered through the rest of the text.
12:57:20 <dons> can you take a screenshot so i can see what you mean?
12:59:33 <romanandreg> c_wraith: using homebrew
12:59:36 <romanandreg> here is the pastie
12:59:37 <romanandreg> http://pastie.org/1637109
13:02:15 <copumpkin> guys
13:02:32 <copumpkin> if anyone receives a PM from a user called antizeus (or a *.crippers.net) user, can you let me know?
13:02:46 <pozic> dons: http://img816.imageshack.us/i/badrender.png/
13:02:55 <applicative> in one panel, ghci is still running, saying maxBound :: Int is 2147483647; in the other it's saying its 922337203685477580
13:03:15 <applicative> finally the death grip of referential transparency has been broken
13:03:40 <aristid> applicative: OS X?
13:03:56 <applicative> yes, i used the new 64 bit installer.  
13:03:59 <pozic> applicative: that is by design.
13:04:09 <applicative> yes, i was kidding
13:04:36 <pozic> One could argue it is bad design.
13:04:36 <applicative> but I dont want to stop the old ghci process
13:04:41 <TTimo> if I have a sequence of IO actions in a 'do' statement, and I don't care what the last action returned is, is there a way to have a last action that returns empty? 
13:04:51 <copumpkin> machine-dependent types are unfortunate
13:04:53 <roconnor> TTimo: return () is common
13:05:36 <TTimo> yes!
13:05:43 <TTimo> exactly what I am looking for, ty 
13:05:46 * applicative is sad, maybe he'll never see 2147483647 again
13:06:21 <roconnor> TTimo: you can often leave it out and just execute a command at the end of a do block
13:06:28 <Drknzz> Hi guys! Why this doesnt work? maximum reverse [1 ... 500]
13:06:43 <pozic> Drknzz: because it is supposed to. 
13:06:43 <applicative>  maximum (reverse [1 ... 500])
13:06:49 <ceii_> copumpkin: I received two pms from antizeus earlier, spamming me to join #calculus
13:06:49 <ddarius> Drknzz: Why doesn't maximum reverse work?
13:06:55 <TTimo> maximum $ reverse [1..500]
13:07:02 <ceii_> ahf, here's a third one
13:07:04 * applicative wonders what the maximum of reverse is
13:07:11 <copumpkin> ceii_: just now?
13:07:16 <ceii_> yes
13:07:17 <TTimo> ahah applicative :)
13:07:29 <pozic> applicative: it is like Warp speed. Duh..
13:07:31 <Drknzz> It should change the behaviour of maximum.... its just a reverse-sorted list
13:07:33 <Drknzz> :S
13:07:38 * romanandreg is starting to get a headache with stupid linker issues
13:07:50 <ceii_> seems to react when I talk for the first time after a while
13:07:53 <copumpkin> ceii_: cool
13:08:16 <cole> Is anyone familiar with the "lang" package? I can't seem to find it.
13:08:20 <marienz> ceii_: is antizeus responding to you? I tried to talk to him/her/it, but was ignored
13:08:21 <Drknzz> Oh, forgot the parenthesis :p
13:08:23 <applicative> romanandreg: I noticed another complication in the cabal file for ncurses .  It presupposes ANOTHER c lib:  panel
13:08:34 <applicative> Drknzz: yes
13:08:39 <marienz> ah, there it went
13:08:41 <ceii_> marienz: I didn't get an answer either
13:08:52 <ceii_> pretty sure it's a bot
13:08:58 <dons> pozic: thanks
13:09:13 <romildo> Hi.
13:09:29 <pozic> dons: everything for propaganda ;)
13:09:37 <pozic> er marketing. 
13:10:09 <pozic> dons: also, the FreeBSD people are not going to be amused.
13:10:21 <pozic> You listed it under Linux. 
13:11:21 <mekeor> :) its UNIXLIKE ;)
13:11:40 <romildo> I am writing a Haskell application go manage movie collections. I want to cabalize it now. For that I am running "cabal init". Which project category do you suggest for such application. The user can type the movie information, or the application can search the internet for it.
13:11:53 <romildo> s/go manage/to manage/
13:13:09 <aristid> romildo: Video?
13:13:19 <ceii_> or Multimedia
13:13:46 <aristid> Video already has a package in it
13:13:49 <aristid> so i suggested it
13:14:01 <aristid> romildo: but don't worry too much about the category
13:15:33 <dons> pozic: there's only 3 users, and I spoke to them personally
13:16:33 <romanandreg> applicative: uhmm
13:16:56 <pozic> dons: it is impossible that you talked to all FreeBSD users, but it is not a very important issue, especially when support is still minimal. 
13:17:45 <romanandreg> applicative: I'm wondering
13:17:50 <romanandreg> which is that library
13:18:04 <romildo> The application is to catalog movies in a collection. It can also play the movie by means of an external application, like mplayer.
13:20:30 <dons> pozic: actually, i am talking to someone trying to create an installer for freebsd (and i used openbsd for nearly a decade). sadly, they're very few of the HP users
13:21:00 <applicative> romanandreg: it looks like libpanel is deep in the gnome UI territory, thats what bugged me.  
13:21:21 <h0t4IT> hello there
13:21:58 <applicative> copumpkin: antizeus is hitting on me.  I would prefer lambdabot.
13:22:33 <Ptival> :)
13:22:33 <aristid> antizeus told me twice to go to #calculus
13:22:44 <aristid> very annoying
13:22:46 <Ptival> oh yeah 2nd time on me too
13:23:04 <Ptival> 10:04, 14:00 (PST)
13:23:20 <nzero> Newbie Q: What might I use instead of Data.Map if my key type (Handle) isn't an instance of Ord? (I can't see a way of making it one)  Performance is not an issue.
13:23:58 <pozic> nzero: a list?
13:24:04 <hpc> nzero: if performance isn't an issue at all, [(Handle, a)]
13:24:29 <pozic> Performance not an issue. Hah.
13:24:40 <nzero> pozic, hpc, thanks.
13:24:40 <hpc> though the question remains, how the hell do you look up something in a list when the key is a handle?
13:24:51 <nzero> it's an instance of Eq
13:24:57 <hpc> wait, for serious?
13:25:09 <nzero> http://is.gd/TPEVEG
13:25:25 <hpc> wtf!
13:25:51 <rwbarton> it's also an instance of Show, I suppose that show function is probably injective
13:26:28 <hpaste> AlexR pasted "test"  http://hpaste.org/44545
13:26:37 <hpc> whoa, the Eq instance is preposterous
13:26:49 <hpc> it doesn't compare the paths, it compares the /innner handles/
13:27:01 <hpc> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/src/GHC-IO-Handle-Types.html#Handle
13:27:16 <nzero> rwbarton: handle: <socket: 12>
13:27:26 <nzero> might do me
13:27:35 <rwbarton> 12 is probably the unix fd
13:27:55 <rwbarton> in which case you're ok as long as you don't leave stale Handles in your map after you close them
13:28:16 <ddarius> hpc: Why is that preposterous?
13:29:11 <hpc> ddarius: Handles, how do they work?! :P
13:29:28 * hpc doesn't see an Eq instance for Handle__, or what the instance could possibly be
13:29:33 <applicative> hpc: this is a little closer to the bottom instance Eq (MVar a) where  (MVar mvar1#) == (MVar mvar2#) = sameMVar# mvar1# mvar2#
13:29:44 <applicative> there isnt an Eq instance for Handle__
13:29:56 <applicative> onl for MVar Handle__
13:30:01 <applicative> only
13:30:03 <hpc> ah
13:30:18 <hpc> and sameMVar# is magic
13:30:26 <hpc> (GHC magic, rather)
13:30:49 <nzero> Thanks all, I'll use Data.Map with show handle.  It's only for a quick hack. (socket-handle-to-username mapping in a simple websockets game).  I expected there'd be another map impl for keys that weren't ordinal.
13:45:32 <parcs> is it generally safe to run strip on the libraries within ~/.cabal/lib? i'm seeing 50% reductions in file sizes...
13:47:17 <Rc43> Hi.
13:47:35 <Rc43> Could anybody remember me what is 'tuing the knot'?
13:47:48 <Rc43> *tying
13:50:29 <copumpkin> Rc43: it's when a value refers to itself, in some way
13:50:40 <Rc43> just recursion?
13:51:07 <copumpkin> it's usually used in the context of recursive non-function types
13:51:10 <copumpkin> but yeah
13:51:28 <hpc> > let xs = zip [1..] (tail xs) in xs
13:51:29 <lambdabot>   Occurs check: cannot construct the infinite type: b = (t, b)
13:51:42 <hpc> > let xs = zip [1..] (map snd . tail xs) in xs
13:51:43 <lambdabot>   Couldn't match expected type `[(a, b)]'
13:51:43 <lambdabot>         against inferred type `(t, ...
13:51:51 <hpc> > let xs = zip [1..] (map fst . tail xs) in xs
13:51:52 <lambdabot>   Couldn't match expected type `[(a, b)]'
13:51:52 <lambdabot>         against inferred type `(t, ...
13:51:54 <hpc> humbug
13:52:05 <Jafet> Du failst
13:52:14 <hpc> sehr fail
13:52:31 <Rc43> Ok, thanks.
13:52:49 <Jafet> Rc43: have you read the Haskell wiki? It contains a few examples.
13:52:51 <hpc> > zip`ap`tail [1..]
13:52:52 <lambdabot>   Couldn't match expected type `[a] -> [b]'
13:52:52 <lambdabot>         against inferred type `[t]'
13:53:05 <hpc> :t zip`ap`tail
13:53:06 <lambdabot> forall b. [b] -> [(b, b)]
13:53:11 <hpc> > zip`ap`tail $ [1..]
13:53:12 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
13:53:22 <Rc43> Like this? http://www.haskell.org/haskellwiki/Tying_the_Knot
13:53:40 <hpc> i was reading that article and it confuses me greatly
13:53:44 <Jafet> That's the article.
13:54:47 <Rc43> Guys, i like haskell, but don't understand in which applications it can be used effectively.
13:54:58 <Rc43> Parallel algorithmes or something?
13:55:10 <Jafet> haskell-ml has a nice implementation of a zipper on a two-dimensional grid.
13:55:10 <Rc43> Differend analysis?
13:55:13 <Rc43> *t
13:55:21 <Jafet> http://www.mail-archive.com/haskell-cafe@haskell.org/msg50766.html
13:55:40 <blbrown_win3> Rc43, haskell can be used as a general purpose language like Java or C#.
13:55:48 <Rc43> Ok.
13:55:52 <Rc43> But it is just tool.
13:56:10 <Rc43> Some tools are more effective for one taks, some not.
13:56:16 <parcs> @pl \a b -> f a b . g
13:56:16 <lambdabot> flip flip g . ((.) .) . f
13:56:21 <blbrown_win3> I haven't used it for webapps though.  Don't know if there is strength there
13:56:30 <Rc43> So there are tasks where haskell > java and tasks where java > haskell.
13:56:36 <hpc> blbrown_win3: there is indeed strength
13:56:41 <blbrown_win3> shrug
13:56:43 <hpc> http://98.169.17.243:8000/blog/
13:57:03 <hpc> written in haskell, and one of those posts talks about how i build html
13:57:12 <ceii_> Rc43: many people here will argue that there are no tasks where java > haskell, except interoperating with the JVM
13:57:13 <blbrown_win3> hpc, that is cgi...don't know if I would call that a strength
13:57:23 <hpc> nothing wrong with cgi :P
13:57:23 <Rc43> hps, oh, it's nice
13:57:58 <raichoo> The more I work with scala the more I'm drawn towards haskell atm.
13:58:08 <parcs> it's just as easy to deploy on SCGI, FCGI, or straight through a Haskell web server with WAI
13:58:10 <blbrown_win3> Rc43, check out parsec.  http://www.haskell.org/haskellwiki/Parsec  Can't really do that with Java
13:58:16 <parcs> (as it is to deploy on CGI)
13:58:44 <Rc43> ceii_, ok, so my question will be like "what tasks are solved with haskell most beautifull?"
13:59:01 <Rc43> *most beautifull way
13:59:20 <siracusa> blbrown_win3: You might also want to look at Happstack: http://happstack.com/index.html
14:00:32 <aristid> hpc: get a domain, man
14:00:36 <hpc> parcs: yeah, that web server was set up rather hastily; my next one will be fcgi
14:00:59 <ceii_> Rc43, I think the problems in which Haskell shines most are the ones that can be expressed as "Get a data set, mash and transform it, spit it out"
14:01:14 <ceii_> but thanks to lazy evaluation, this applies to surprisingly varied things
14:01:56 <hpc> in a way, pretty much anything on a computer is "get a data set, mash it, spit it out"
14:02:03 <ceii_> for really interactive applications, you often find yourself forced to program imperatively
14:02:21 <ceii_> Haskell makes a pretty good imperative language, but that's not where it's best
14:02:45 <hpc> it can be good for outputting imperative languages though
14:04:03 <Martty> haskell is terrible for imperativish stuff :(
14:04:18 <djahandarie> Martty, why do you say that?
14:04:26 <Martty> because i suck at it 
14:04:32 <blbrown_win3> is haskell more declarative
14:04:40 <ceii_> I think imperative Haskell beats status quo languages ala Java hands down
14:04:40 <Martty> GOD GIMME MY FOR LOOPZ 
14:04:42 <blbrown_win3> used for more declarative stuff
14:04:59 <mekeor> GOD GIMME MY FOR LOOPZ !! -- yes please!
14:05:03 <Jafet> Martty: here, have a forM.
14:05:07 <djahandarie> Martty, forM_
14:05:08 <Martty> :P
14:05:11 <ceii_> you get first class actions, real useful types
14:05:19 <Martty> i know i know im just teasing
14:05:20 <mekeor> forM??
14:05:24 <djahandarie> :t forM
14:05:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
14:05:40 <aristid> :t forM_
14:05:40 <blbrown_win3> ceii Java is just slightly more type safe than C
14:05:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
14:05:50 <hpc> > forM [1..5] \x -> [x,x,x]
14:05:51 <lambdabot>   <no location info>: parse error on input `\'
14:05:57 <hpc> > forM [1..5] (\x -> [x,x,x])
14:05:57 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1...
14:06:12 <djahandarie> Because the want it in the list Monad, right.
14:06:17 <hpc> wait, what the hell?
14:06:24 <aristid> :D
14:06:39 <djahandarie> Try it in IO for something more akin to a for loop in imperative languages
14:06:42 <hpc> > forM [1..5] (\x -> [x,x])
14:06:43 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1...
14:06:46 <hpc> > forM [1..2] (\x -> [x,x])
14:06:47 <parcs> > length $ forM [1..5] $ \x -> [x,x,x]
14:06:47 <lambdabot>   [[1,2],[1,2],[1,2],[1,2]]
14:06:48 <lambdabot>   243
14:06:52 <hpc> oh, there we go
14:07:13 <ceii_> > 3^5
14:07:13 <lambdabot>   243
14:07:26 <Martty> > 244 - 1
14:07:27 <lambdabot>   243
14:07:47 <mekeor> err,..
14:07:48 <mekeor> i am new to haskell, and I want to print out all Int's below 100.
14:07:48 <mekeor> How to do that? (i usually program in C --  and there are FOR-loops...D:)
14:08:02 <ceii_> > forM [1..99] print
14:08:03 <lambdabot>   <IO [()]>
14:08:09 <mauke> mekeor: print [minBound :: Int .. 99]
14:08:37 <hpc> map print [0..99]
14:08:39 <mekeor> <interactive>:1:0: Not in scope: `forM'
14:08:41 <hpc> or whatever
14:08:56 <mekeor> ceii_ , <interactive>:1:0: Not in scope: `forM'
14:09:10 <parcs> import Control.Monad
14:09:41 <parcs> or just use mapM_ print [1..19]
14:09:42 <Jafet> mekeor: if you're new, you might want to read through one of the introductory books, such as Learn You A Haskell.
14:09:43 <hpc> @where hoogle
14:09:43 <lambdabot> http://haskell.org/hoogle
14:09:47 <hpc> ^ your bestest friend
14:09:58 <parcs> mapM is imported by the Prelude
14:09:59 <hpc> @where lyah
14:09:59 <lambdabot> http://www.learnyouahaskell.com/
14:10:49 <mekeor> thanks
14:17:52 <aristid> @index forM_
14:17:52 <lambdabot> bzzt
14:17:56 <aristid> zomg
14:18:03 <aristid> @hoogle forM_
14:18:03 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
14:18:03 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
14:18:06 <aristid> there.
14:18:20 <aristid> lambdabot: your fault
14:19:07 <mekeor>  in  haskell, indentation with tabs or spaces?
14:19:17 <mauke> neither
14:19:31 <mekeor> ?!
14:19:31 <lambdabot> Maybe you meant: . ? @ v
14:19:32 <mauke> it's not indentation, it's making things line up (and it's done with spaces)
14:19:55 <mekeor> thanks. ok.
14:20:28 <hpc> there is "indentation" though, in a way
14:20:38 <hpc> do x y z
14:20:40 <hpc>    ...
14:20:41 <glguy> You can use tabs, but you must set your tabstop to 8 spaces
14:20:42 <hpc> vs
14:20:43 <hpc> do
14:20:44 <hpc>   x
14:20:46 <hpc>   ...
14:21:07 <mauke> or just do
14:21:07 <mauke> x
14:21:07 <mauke> ...
14:21:43 <mauke> (the (non-'{') token after "do" determines the base indentation level of the following block)
14:22:46 <hpc> the trick is that it can't be the same indentation as the "do"
14:22:51 <hpc> or you can't tell when it ends/starts
14:22:53 <mauke> it totally can
14:23:02 <hpc> blah = do
14:23:06 <hpc>   do
14:23:08 <hpc>   x
14:23:09 <hpc>   y
14:23:12 <mauke> it starts at the token after "do"
14:23:35 <hpc> er, make that f $ do, on line two
14:23:43 <hpc> so is y part of the action passed to f?
14:23:53 <hpc> science doesn't know! :P
14:23:56 <mauke> I think so
14:24:31 <hpc> anyway, keeping indentation the same at nested levels is begging for bugs :P
14:25:08 <mauke> I've done that
14:25:18 <mauke> to make sure I can never go back to the first block
14:25:32 <hpc> ooh, sneaky
14:25:49 <hpc> when i want that, i usually do f . g $ do...
14:26:17 <mauke> how does that help?
14:26:30 <hpc> or something like that
14:26:43 <hpc> instead of f $ do g $ do...
14:27:18 <mauke> do { foo; x <- bar; when x $ do { baz; qux } }
14:28:23 <hpc> ah
14:28:37 <mreh> an unboxed array couldn't hold _|_ could it right?
14:28:57 <hpc> mreh: don't think so; unboxed -> strict does it not?
14:29:15 <mreh> hpc: yes
14:29:33 <mreh> so I suppose not
14:31:30 <copumpkin> ddarius: what's up?
14:35:25 <thunkee> hi ist there a predefined layn in ghc?
14:35:34 <sipa> layn?
14:35:49 <mauke> did you mean: lawn
14:36:39 <smarmy> can anyone explain this error?  http://hpaste.org/44546
14:37:02 <thunkee> didnt find lawn either
14:37:08 <mauke> wat
14:37:16 <sipa> thunkee: what do you want or need?
14:37:19 <hpaste> smarmy pasted "TypeClass Error"  http://hpaste.org/44546
14:38:09 <mauke> smarmy: getFoo claims to be able to return any Foo f I want
14:38:22 <mauke> smarmy: your Bar instance only returns FooThingys
14:38:28 <thunkee> sipa: show list of lists [[list]]
14:38:29 <smarmy> makes sense
14:38:52 <mauke> > show [[1],[2,3]]
14:38:53 <lambdabot>   "[[1],[2,3]]"
14:38:57 <thunkee> err [[char]]
14:39:11 <mauke> > show [['1'],['2','3']]
14:39:12 <lambdabot>   "[\"1\",\"23\"]"
14:39:17 <hpc> > fix show
14:39:18 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:39:18 <hpc> :D
14:39:43 <thunkee> lay does ist one per line
14:39:46 <ddarius> copumpkin: I lost Mo's number.  I sent him an email, but I doubt he'll check it before 6:30 and he may not check it today at all.
14:39:52 <mauke> thunkee: what is 'lay'?
14:39:58 <thunkee> for showing matrices etc
14:40:01 <copumpkin> > map length . group . fix $ show
14:40:02 <mauke> what?
14:40:03 <ddarius> copumpkin: The restaurant is Tamarind House a bit south of Porter Square.
14:40:07 <lambdabot>   [1
14:41:46 <geheimdienst> > 42
14:41:47 <lambdabot>   42
14:42:23 <Jafet> copumpkin: note that marienz lifted the k-line about half an hour ago. Although he might be unlikely to bother this channel again soon.
14:42:25 <mreh> mutable arrays are a strage new concept to me
14:42:44 <mreh> writeArray returns no value
14:43:12 * marienz nods
14:43:35 <Jafet> Oh, ok. Didn't see you here.
14:43:40 <marienz> obviously prod me if he shows up again (or #freenode if I'm no longer around)
14:43:57 <Ptival> @where lambdabot
14:43:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:45:12 <BMeph> mauke: Were you the one that had a symbol name for 'flip (>>)'?
14:45:26 <mreh> I want to foldM over an STArray, how do I get it out afterwards? 
14:45:30 <mauke> BMeph: yes, but no
14:45:37 <mreh> over a new empty STArray
14:46:00 <c_wraith> mreh: does runSTArray do what you want?
14:46:02 <BMeph> mauke: Okay...were you A one that has...
14:46:11 <mauke> BMeph: it wasn't flip (>>)
14:46:17 <hpc> :t foldM
14:46:18 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:46:44 <c_wraith> Oh.  Yeah, what's the return value in your fold?
14:48:54 <Ptival> what is the "better" way to install GOA?
14:49:13 <Ptival> (assuming there are several ways that I might ignore)
15:06:44 <mekeor> does someone in here understand how the ackermann-function works??
15:06:55 <copumpkin> what about it?
15:07:02 <mekeor> i dont understand it...
15:08:03 <mekeor> ackr(a,b,0)=b+1
15:08:03 <mekeor> ackr(a,b,1)=a+b
15:08:03 <mekeor> ackr(a,b,2)=a*b
15:08:03 <mekeor> ackr(a,b,3)=a^b
15:08:03 <mekeor> ackr(a,b,4)=??
15:08:41 <mekeor> copumpkin: can you go on this list?
15:09:11 <aristid> mekeor: something like this? ackr(a,0,4) = 1; ackr(a,b,4)=a^ackr(a,b-1,4)
15:09:31 <ddarius> @google ackermann
15:09:32 <lambdabot> http://en.wikipedia.org/wiki/Ackermann_function
15:09:32 <lambdabot> Title: Ackermann function - Wikipedia, the free encyclopedia
15:09:42 * hackagebot enumset 0.0 - Sets of enumeration values represented by machine words  http://hackage.haskell.org/package/enumset-0.0 (HenningThielemann)
15:10:01 <mekeor> yes, i know wikipedia xD; BUT I DONT UNDER STAND IT!!
15:10:15 <mekeor> *UNDERSTAND 
15:11:04 <ddarius> mekeor: It gives several definitions including discussion and examples, so that sounds like a personal problem.
15:11:41 <hpaste> ecyrb pasted "How do I desugar fact1?"  http://hpaste.org/44547
15:11:59 <mekeor> i just want to now whats
15:11:59 <mekeor> ackr(a,b,4)=??
15:12:14 <mekeor> (and ackr(a,b,5))
15:13:12 <Ptival> http://upload.wikimedia.org/math/c/d/5/cd50256ccbc1e91f3991a743bd967ebe.png < this?
15:16:37 <dschoepe> I sent an email a week ago asking for my account on c.h.o to be reactivated to support@community.haskell.org and haven't heard back yet. Is that delay normal or did my mail get lost somehow?
15:21:23 <Saizan> i got it back the day afte
15:21:26 <Saizan> *after
15:23:20 <hpaste> ecyrb pasted "How do I desugar fact1? (annotation)"  http://hpaste.org/44548
15:23:33 <ecyrb> I think I got it.  Any thoughts?
15:26:04 <lionel43> how can i check if both trees are the same with haskell, any code out there? want to go through it. thanks
15:27:06 <Axman6> what definition of a tree do you have?
15:28:02 <aavogt> derive Data, then use geq
15:28:07 <lionel43> data Tree a = Empty | Root a (Tree a) (Tree a)
15:28:21 <aavogt> or deriving Eq  is quicker
15:30:21 <Axman6> lionel43: you can define it inductively: starting with Empty, if both trees you give are Empty they're equal
15:30:48 <lionel43> Axman6: let me paste my code
15:31:31 <Axman6> if both trees are Root constructors (not a great name btw), then the trees are equal if the a element is equal, and the lest branch of the first is equal to the left branch of the second, and the right branches are also equal
15:31:40 * gwern stares at code. 'count x = if (length $ elemIndices '/' x) ≡ 2 then True else False'. d'oh!
15:32:22 <Axman6> :(
15:32:25 <lionel43> http://pastebin.com/raw.php?i=NyQJjpWk
15:33:10 <bwright> Hello.
15:33:51 <Axman6> lionel43: why do you have the empty lst == empty rst in there? it doesn't make much sense
15:33:59 <azaq23> bwright hi
15:34:10 <Axman6> what is the definition of a tree being perfect?
15:34:24 <lionel43> should it be depth?
15:34:26 <mekeor> bwright hi
15:34:37 <Axman6> huh?
15:36:28 <lionel43> Axman6: not sure bro...
15:36:57 <Axman6> lionel43: do you want to check that two trees are equal?
15:37:07 <lionel43> all i want to do is to compare if the two trees are equal
15:37:08 <lionel43> yeah
15:37:25 <lionel43> should i check if they have the same length?
15:37:33 <lionel43> compare which is taller
15:37:35 <Axman6> which two trees, the sub trees of Root constructor you pass in?
15:37:42 <bwright> Axman6: A perfect tree is a full tree in which all leaves are at the same depth I think.
15:37:47 <lionel43> depth :: Tree a -> Integer depth Empty            = 0 depth (Root _ lst rst) = 1 + max (depth lst) (depth rst)
15:38:07 <Axman6> why aren't you using the depth then?
15:38:30 <lionel43> http://hpaste.org/44550/tree_length
15:38:39 <hpaste> lionel pasted "tree length"  http://hpaste.org/44550
15:40:18 <lionel43> Axman6: is this considered a good test you think?
15:41:01 <Axman6> i think you need to be more clear about what you're trying to write before writing it
15:42:21 <lionel43> how would one check if both trees are the same or not?
15:43:11 <Axman6> write a function that can tell you if they're equal
15:43:29 <Axman6> i practically gave you the definition above in english btw ;)
15:44:59 <Ptival> lionel43: so a tree is perfect if both subtrees are perfect and of the same height?
15:45:36 <lionel43> i need to check so i have to check if leaf x == leaf y
15:45:52 <lionel43> Ptival: i actually im not sure, thats why im asking here
15:46:10 <lionel43> Ptival: or should i check every single leaf and compare it to the other?
15:46:57 <bwright> Watch algorithmic complexity when checking your trees.
15:47:01 <Ptival> "A perfect binary tree is a full binary tree in which all leaves are at the same depth or same level."
15:47:38 <lionel43>     (Leaf x)     == (Leaf y)        =  x == y
15:47:41 <lionel43>     (Branch l r) == (Branch l' r')  =  l == l' && r == r'
15:47:44 <lionel43>     _            == _               =  False
15:47:51 <bwright> Ptival: He asked for a tree though not a b-tree.
15:47:56 <Ptival> oh
15:48:11 <Ptival> but his Branch is binary
15:48:38 <lionel43> b-tree
15:48:45 <bwright> -_- Ya that would have helped.
15:50:04 <gwern> hm. is github up for everyone?
15:50:30 <lionel43> so i can use Eq
15:50:33 <aristid> gwern: yes
15:50:43 <gwern> well, it seems I got myself banned for spidering, then
15:51:01 <Ptival> :\
15:51:07 <bwright> lionel43: Just use a recursive algorithm with 2 trees for input, check base case, check tree 1 data to tree 2 return if not equal.
15:51:24 <gwern> not a long ban, fortunately
15:51:54 <bwright> lionel43: Then recurse again with the left of the three and the right of the tree in 1 return.
15:52:00 <bwright> tree*
15:52:55 <kmc> http://www.downforeveryoneorjustme.com/
15:53:02 <killing-joke> i have been reading "real world haskell" all afternoon, and doing the exercises on tryhaskell.org. but i still have no idea how to write a simple filter.
15:53:14 <rostayob> killing-joke: filter?
15:53:20 <rostayob> killing-joke: like filtering a list
15:53:30 <burp> like 
15:53:31 <burp> :filter
15:53:32 <Axman6> killing-joke: i would strongly recommend learn you a haskell for great good before reading RWH:
15:53:35 <killing-joke> in sed, it might look like   cat datafile.txt | sed -e'p;'
15:53:35 <Axman6> @where lyah
15:53:35 <lambdabot> http://www.learnyouahaskell.com/
15:53:35 <burp> :t filter
15:53:36 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:54:42 <killing-joke> burp, i will try 'filter', thanks. for some reason, after all that reading, i am burning to write one.
15:55:08 <marienz> did anyone recently (within the last 30 minutes or so) receive spam from antizeus?
15:55:15 <rostayob> marienz: I did.
15:55:15 <bwright> Yes.
15:55:21 <killing-joke> yes
15:55:22 <kmc> yep
15:55:23 <burp> killing-joke: do you have a file where you want to filter lines?
15:55:31 <Eduard_Munteanu> I did a few hours ago.
15:55:32 <Axman6> glad it's not just me
15:55:33 <bwright> He asked me to join #calculus
15:55:39 <rostayob> yeah, same.
15:55:43 <burp> same :>
15:55:47 <marienz> thank you
15:55:56 <rostayob> who would advertise a calculus irc channel anyway.
15:56:21 <killing-joke> burp, yes, i want to operate on incoming HTTP requests
15:56:35 <bwright> rostayob: Maybe he is just really into calculus
15:57:07 <Axman6> marienz: curious, did you get spammed when you first spoke too?
15:57:08 <rostayob> bwright: hardcore calculus fan... wow
15:57:22 <killing-joke> so, "do i have a file?"; actually i want to filter stdin, then
15:57:23 <marienz> Axman6: not that I've noticed
15:57:39 <Eduard_Munteanu> Lemme try something...
15:58:02 <Axman6> Eduard_Munteanu: hello
15:58:02 <Eduard_Munteanu> o/
15:58:07 <Axman6> get it again?
15:58:09 <Eduard_Munteanu> Nothing yet.
15:58:13 <Axman6> hmm
15:58:14 <rostayob> killing-joke: hGetLine stdin
15:58:14 <Eduard_Munteanu> Nope.
15:58:17 <bwright> My university system admins broke ghc. So I downloaded the source and tried to compile it and ran out of space. So I moved it to /tmp/ but after compilation it was still to big.
15:58:20 <dankna> oh - I got that spam too, but it was worded such that I thought it was a misdirected line instead of calculus.
15:58:22 <bwright> How can I cut it down.
15:58:29 <dankna> er
15:58:33 <dankna> s/calculus/spam/
15:58:33 <kmc> bwright, you can download precompiled binaries of ghc
15:58:35 <dankna> braino
15:58:40 <kmc> i also recommend yelling at the admins
15:58:49 <bwright> kmc: Yes but I compiled the binaries and they are still quite large no?
15:58:54 <dankna> yelling at them won't help, but it may be theraputic
15:59:04 <dons> bwright: can you use the haskell platform installers?
15:59:06 <kmc> yeah but maybe you'll have more space if you don't have all the intermediate files from compilation
15:59:28 <kmc> i have had success asking admins to install ghc for me
15:59:29 <kmc> no wait
15:59:34 <Axman6> dons: isn't the platform a lot larger than just GHC alone?
15:59:41 <kmc> i have had success asking admins to increase my quota so i could install ghc
16:00:07 <Jafet> Bring your own disk drive?
16:00:18 <bwright> dons: I am not 100% sure I only got access to the system like 2 days ago ^_^ but it is complaining that it missing libreadline.so.5
16:00:27 <rostayob> I have had succes in making sysadmins installing xmonad on all the pcs ehe
16:00:33 <bwright> Perhaps I could just append my own version of that to my PATH and maybe it will work
16:00:42 <kmc> more like LD_LIBRARY_PATH but yes
16:00:50 <kmc> if you can find a copy compatible with the other stuff on the system
16:00:54 <kmc> is this some ancient linux distro?
16:01:01 <bwright> fc14.
16:01:09 <kmc> oh, that's like the opposite of ancient
16:01:13 <bwright> My compilation works fine I got ghc running but just ran out of space in the process.
16:01:20 <Eduard_Munteanu> They might've updated readline and GHC was left depending on that.
16:01:30 <kmc> istr newer GHC doesn't even use readline
16:01:41 <Eduard_Munteanu> *sigh* I was going to suggest revdep-rebuild :/
16:01:50 <bwright> Eww it is 6.8.3
16:02:05 <Axman6> :|
16:02:07 <kmc> heh
16:02:09 <Eduard_Munteanu> Try latest 6.12-based platform
16:02:11 <Axman6> that's... very old
16:02:31 <bwright> Ok that is it I will just build it myself and write a cron job to load it into tmp every 5 days so I restore my grace period
16:02:41 <kmc> bwright, again, you don't have to build it yourself
16:02:46 <kmc> you can download a tarball with binaries in it
16:03:04 <bwright> kmc: But I have emulated /usr/ in ~/.usr/
16:03:08 <aristid> bwright: grace period?
16:03:16 <kmc> yes, the binary tarball supports ./configure --prefix
16:03:23 <bwright> kmc: kk
16:03:25 <kmc> the process for installing it is a lot like installing from source, just much much faster
16:03:39 <kmc> i also recommend at least asking the admins for increased quota / newer GHC
16:03:43 <bwright> I was trying to compile tor the other day to get onto irc but :/ no dice
16:03:48 <rostayob> dons: I was reading your blog, and you use archlinux right? May I ask you something about managing haskell packages in arch?
16:03:59 <aristid> bwright: can't you just use your own computer for haskell dev? :)
16:04:16 <Eduard_Munteanu> Ah, so that's why Arch has decent support for Haskell :D
16:04:34 <Eduard_Munteanu> I wonder who works on Gentoo stuff.
16:04:42 <aristid> Eduard_Munteanu: if dons should switch to another platform, it will probably quickly get good haskell support too ;)
16:04:54 <rostayob> Eduard_Munteanu: actually it's not so good after all...
16:05:02 <rostayob> at least in my experience
16:05:04 <smarmy> anyone know which version of ghc introduced DoRec?
16:05:33 <Eduard_Munteanu> Gentoo is okay, though cabal/ghc are broken on some aspects.
16:05:40 <kmc_> aristid, sometimes other people need the ability to compile your code
16:05:41 * Eduard_Munteanu can't get lambdabot building here
16:05:47 <rostayob> mainly because the haskell packages provided (not the ones in AUR) are outdated most of the times and they have very strict dependcies
16:05:59 <Saizan> lambdabot is likely to not build regarless of distro
16:06:08 * geheimdienst is on arch linux too, and tried the AUR haskell packages ... in the end, it's more convenient to just use cabal for everything
16:06:21 <lispy_> ?botsnack
16:06:21 <lambdabot> :)
16:06:27 <geheimdienst> istr the AUR packages don't even come with documentation :(
16:06:28 <Eduard_Munteanu> Saizan: why? I mean, last time I looked, it was GHC mishandling linker scripts posing as libs.
16:06:41 <rostayob> geheimdienst: cabal-install is a mess... the nice thing about archlinux is cabal2arch
16:06:42 <aristid> geheimdienst: until cabal hits some problem and you have to restore your environment :/
16:07:10 <lispy_> using cabal-dev instead of cabal-install greatly reduces the amount of fixing your environment you have to do
16:07:13 <rostayob> again the problem is that unless you are willing to make your own packages replacing the base ones, the base ones are oudated
16:07:32 * lispy_ can't stress this enough
16:07:45 <rostayob> lispy_: uh.. neat
16:07:47 <Eduard_Munteanu> I use a mix of system libs and cabal-install (not using the platform yet).
16:07:59 <rostayob> lispy_: I'll definitely try that out
16:08:07 <Kaidelong> Haskell could use some better standard libraries
16:08:10 * geheimdienst shrugs ... i think cabal is better than its reputation. it's been a while since i last had trouble. even back then, reinstalling everything in .cabal was not much of a big deal
16:08:16 <bwright> I am new to haskell but my mates at UNSW got me hooked.
16:08:18 <hpaste> gwern pasted "github downloader"  http://hpaste.org/44552
16:08:24 <gwern> ok, first draft of my github downloader: http://hpaste.org/44552/github_downloader now time to see if it actually works
16:08:37 <Kaidelong> oh yeah
16:08:44 <lispy_> rostayob: it basically ignores the per user pkg db and creates one in at your current path to install things into.  This way, cabal-install doesn't corrupt your user pkg db by installing/updating things at random
16:08:46 <Kaidelong> I have never used Haskell for programming in the large
16:08:48 <rostayob> Eduard_Munteanu: you probably already have the haskell platform installed, it's just a collection of packages as far as I know
16:08:52 <Axman6> bwright: in manuel teaching you?
16:08:53 <Kaidelong> how do you do that?
16:08:56 <Eduard_Munteanu> gwern: that got you banned? :/
16:08:56 <rostayob> lispy_: yes, like a python virtualenv. cool
16:08:59 <kmc_> Kaidelong, you should write some :)
16:09:07 <gwern> Eduard_Munteanu: only for like half a minute
16:09:18 * kmc_ had only minor trouble building lambdabot on recent Haskell Platform
16:09:35 <Eduard_Munteanu> rostayob: no, it's not the HP itself. Yes, HP is a distribution, though.
16:09:53 <bwright> Axman6: I generally teach myself programming languages but they showed me some stuff they had done and I was like 0.0
16:10:03 <geheimdienst> gwern, thanks for pasting that. it's very interesting
16:10:09 <Kaidelong> kmc_: what is "better" to me might not be better to most people though
16:10:12 <lispy_> 0.0?  As in, initial version?
16:10:15 <Kaidelong> I do not really care about performance too much
16:10:16 <Eduard_Munteanu> I wonder when's the next release of xmonad coming out.
16:10:17 <Kaidelong> for example
16:10:23 <rostayob> Eduard_Munteanu: that's what I mean, it doesn't really make a difference...
16:10:24 <Eduard_Munteanu> It's been a while since 0.9
16:10:24 <hpaste> Ptival pasted "Did I over-monaded the problem?"  http://hpaste.org/44553
16:10:25 <Axman6> so you're not at UNSW?
16:10:33 <bwright> gwern: Someone should port mechanize to haskell ^_^ Make your like 1000% easier
16:10:36 <Kaidelong> (unless it overlaps with elegance)
16:10:44 <kmc_> Kaidelong, then maybe these things shouldn't be standard libraries, but things you can get from hackage
16:10:45 <gwern> geheimdienst: interestingly, it crashes with a ghc error when I try runhaskell
16:10:51 <kmc_> of which there are many
16:10:58 <gwern> geheimdienst: that seems to happen fairly often with thecurl binding, odd runtime errors...
16:11:16 <kmc_> for example, haskell needs a better Prelude.  the way to do this is for someone to upload an alternate Prelude and advocate it until it catches on
16:11:24 <kmc_> so far a few people have done the former but none the latter
16:11:25 <gwern> bwright: well, I'm not sure how much any lib could buy me. tagsoup does the hard work of parsing, then I just filter some stuff and shell out to git
16:11:28 <bwright> I am actually confused why my quota is 400mb. Isn't disk cheap?
16:11:50 <bwright> gwern: Mechanize has built in cookie support and can find and submit forms.
16:11:57 <Eduard_Munteanu> Do you even get shell accounts at universities these days?
16:11:58 <gwern> bwright: none of which I use here
16:12:03 <bwright> I used it to parse the past papers in my university library for the courses I do.
16:12:06 <Axman6> if you're at a university, you're sharing that disk with several hundred, possibly thousand students
16:12:15 <Kaidelong> kmc_: I think it is also a problem with diversity, how many different libraries are there for monad transformers again?
16:12:16 <kmc_> Eduard_Munteanu, i had three shell accounts at my uni; the best by far was the student-run one
16:12:23 <gwern> bwright: and forms aren't *that* bad to do with curl; I did it once to submit URLs to alexa/internet archive
16:12:29 <kmc_> *nod* or JSON parsing
16:12:40 <kmc_> not to mention the 48573474853 incompatible JSON-like formats that people keep inventing
16:12:48 <Kaidelong> right
16:12:51 <geheimdienst> gwern: thanks for the heads-up. i was planning to rip wget out of that haskell script i use to download stuff from youtube, since i hadn't known about Network.Curl until you pasted it
16:12:55 <kmc_> what the world really needs is *another* way to store key-value dictionaries
16:12:56 <kmc_> ;P
16:12:57 <Kaidelong> with something like .NET there is at least a semblance of coordination
16:12:59 <bwright> Axman6: 1000 people / 1000GB == 1GB
16:13:03 <hpc> does anyone happen to know a way to quickly find the "successor" to an alphabetical string?
16:13:05 <kmc_> there is coordination in the Haskell Platform
16:13:22 <gwern> geheimdienst: no problem?
16:13:24 <bwright> Axman6: In other words about 50 dollars.
16:13:24 <Kaidelong> well...
16:13:28 <hpc> so xsucc "z" would be "A", and xsucc "Z" would be "aa", for example
16:13:33 <Eduard_Munteanu> There are about 900 people just in my faculty IIRC.
16:13:35 <rostayob> at my uni, in the last 3 weeks, the following happened: 1) someone got root access and replaced the ssh cliend and server binaries with modified versions that stored user and passwd in a file 2) a server crashed and half of the home dis were down for 4 days.
16:13:36 <gwern> bwright: there's also other costs, like backup
16:13:45 <Eduard_Munteanu> Wait, no!
16:13:47 <Kaidelong> I suppose I really mean Hackage
16:13:50 <Eduard_Munteanu> That's per year!
16:13:51 <Axman6> bwright: they also have to keep backups of all your data too. we get 600MB at ANU
16:14:06 <Kaidelong> since the haskell platform without extra stuff added on (IE OpenGL, networking etc) is a bit bare
16:14:09 * hpc can write it himself, but probably won't think of the quickest way
16:14:18 <kmc_> Haskell Platform has OpenGL and networking
16:14:22 <Kaidelong> oh it does?
16:14:23 <gwern> bwright: so part of it is inefficiency, part of it is having bought stuff in the past when disk space was much more expensive, part of it is preventing abuse, etc
16:14:24 <bwright> But I store my real work on like 3 servers 2 local 1 remote.
16:14:27 <bwright> In a git repo.
16:14:40 <kmc_> http://hackage.haskell.org/platform//changelog.html Kaidelong
16:14:43 <gwern> wouldn't want the kids setting up a DC++ hub on the CS department servers...
16:14:48 <geheimdienst> gwern: no problems so far. i'm just doing runInteractiveProcess "wget" ... the whole thing was more or less a direct port from a shell script
16:14:52 <Eduard_Munteanu> Lappys are cheap these days.
16:15:03 <Kaidelong> ah I see
16:15:11 <kmc_> Kaidelong, it's a bit disingenuous to complain that Hackage is disorganized while ignoring HP, which is supposed to be precisely an organized blessed subset of Hackage
16:15:12 <hpc> oh, i can fold it!
16:15:22 <hpc> > foldl f x [y, z] :: Expr
16:15:22 <bwright> Eduard_Munteanu: Running xmonad on my lappy :)
16:15:23 <lambdabot>   f (f x y) z
16:15:26 <kmc_> not to say there isn't room for improvement on both sides
16:15:27 <Kaidelong> kmc_: I see
16:15:34 <hpc> > foldr f x [y,z] :: Expr
16:15:35 <lambdabot>   f y (f z x)
16:15:36 <kmc_> i look forward to the new Hackage 2.0 whenever that will actually exist
16:15:38 <Kaidelong> kmc_: That's still a small list of packages though.
16:15:38 <Eduard_Munteanu> bwright: running it there and here on my desktop :P :D
16:16:00 <gwern> kmc_: it does exist, gracenotes is just too lazy to get everything moved over
16:16:09 <kmc_> heh
16:16:23 <Kaidelong> good to see that mtl is blessed
16:16:29 <Eduard_Munteanu> What?
16:16:35 <bwright> Eduard_Munteanu: I don't get it everyone keeps telling me java is a safe language but it melted the plastic on my eeepc900 when I tried to actually use it. Java broke my computer :(
16:16:38 <Eduard_Munteanu> Wasn't that deprecated?
16:16:47 <aristid> Eduard_Munteanu: no, mtl 2.0 is not deprecated.
16:16:58 <kmc_> hahaha Eduard_Munteanu
16:17:04 <kmc_> err bwright
16:17:13 <hpc> > succ '4'
16:17:13 <Eduard_Munteanu> Hrm, I was under the impression 'transformers' was the replacement.
16:17:14 <lambdabot>   '5'
16:17:19 <bwright> kmc_: :(
16:17:23 <kmc_> @remember bwright I don't get it everyone keeps telling me java is a safe language but it melted the plastic on my eeepc900
16:17:23 <lambdabot> Nice!
16:17:25 <aristid> Eduard_Munteanu: mtl 2.0 now depends on transformers
16:17:35 <Eduard_Munteanu> Ah, that makes sense.
16:17:36 <aristid> Eduard_Munteanu: but it also adds stuff that was formerly in monads-fd
16:17:40 <kmc_> mtl 2.0 is a compatibility layer for transformers
16:17:42 <Eduard_Munteanu> Ah.
16:17:46 <kmc_> slash monads-fd
16:17:48 <aristid> basically, mtl 2.0 is just monads-fd renamed
16:18:12 <kmc_> mtl2 is not so much blessed as officially deprecated
16:18:19 <kmc_> but i'm not sure if this is communicated effectively
16:18:34 <aristid> kmc_: what? mtl 2.0 is officially deprecated?!
16:18:42 <jmcarthur> no
16:18:56 <aristid> monads-fd is certainly deprecated, i know that
16:18:59 <kmc_> new code should use transformers
16:19:00 <kmc_> it is?
16:19:01 <jmcarthur> mtl 2 is the recommended goto now. it just reexports stuff from transformers
16:19:07 <kmc_> ok, i must be mistaken
16:19:15 <jmcarthur> and exposes those type classes and junk
16:19:16 <kmc_> why is monads-fd deprecated
16:19:16 <Eduard_Munteanu> Why not just use transformers?
16:19:24 <aristid> kmc_: because mtl 2.0 is the new monads-fd.
16:19:27 <kmc_> ok then
16:19:35 <aristid> Eduard_Munteanu: because mtl adds stuff that is not in transformers.
16:19:40 <Kaidelong> in the platform, are you just supposed to serialize with zlib and show?
16:19:49 <kmc_> Eduard_Munteanu, because transformers doesn't provide classes for working over, say, (State s) and (StateT s m) generically
16:19:56 <Kaidelong> in which case you'd have problems with things like (->) which cannot be shown
16:20:00 <aristid> Kaidelong: why not with cereal or binary?
16:20:04 <kmc_> Kaidelong, isn't 'binary' in there?
16:20:16 <Kaidelong> aristid: not part of the platform
16:20:22 <aristid> Kaidelong: srsly?
16:20:24 <kmc_> yes, you can't serialize (->), i don't see what that has to do with platform's library selection
16:20:36 <Eduard_Munteanu> IIRC, it indeed isn't there, but it's a small package.
16:20:44 <kmc_> that's disappointing
16:20:53 <kmc_> maybe they're waiting for one of binary or cereal to win out
16:21:10 <kmc_> it's not as though 'binary' lets you serialize (->)
16:21:31 <Kaidelong> well there is haskell src I guess
16:21:32 <aristid> haskell platform is tiny oO
16:21:32 <Axman6> ghc comes with binary doesn't it?
16:21:42 <kmc_> Kaidelong, ?
16:21:44 <aristid> Axman6: no
16:21:51 <kmc_> ghc comes with ghc-binary, which is hidden?
16:21:51 <Axman6> you syre?
16:21:53 <Axman6> sure*
16:21:56 <Kaidelong> haskell-src
16:22:00 <Axman6> hmm
16:22:07 <Kaidelong> library for manipulating haskell source code, it seems
16:22:22 <kmc_> Kaidelong, yes, i was wondering why you mentioned it
16:22:23 <aristid> Axman6: hmm, not 100% sure
16:22:37 <aristid> Axman6: i thought you were mistaking it for ByteString :D
16:22:51 <Axman6> i possibly am
16:23:14 <rostayob> Is anybody aware of a lib/data structure that permits indexing and ordering data after multiple indexes written just in haskell? (basically a sort of database)
16:23:32 <kmc_> why does it have to be written just in Haskell?
16:23:34 <aristid> Axman6: binary is a package for efficient serialization/deserialization of values to/from bytestrings
16:23:46 <Axman6> i know, I've used it many times ;)
16:24:06 <rostayob> kmc_: I'm just curious, I've been trying to do it myself but it's hard. Just wanted to know if is it possible to do it efficiently
16:24:17 <kmc_> well, databases exist
16:24:27 <kmc_> boost has a multi-index container library for C++
16:24:29 <aristid> Axman6: but logically, if it came with GHC, it would also be in the haskell platform
16:24:36 <aristid> Axman6: so it can't be in the haskell platform! :)
16:24:40 <aristid> argh
16:24:40 <Axman6> yeah
16:24:44 <aristid> *so it can't be in GHC
16:25:17 <rostayob> kmc_: but in haskell? I can retrive stuff after indexes using kd-trees, but I have no idea on how to order it efficiently after some index
16:25:19 <Axman6> anyway, don't binary and cereal have different uses? (the main one being they work on different bytestring types)
16:25:25 <aavogt> sort of like http://hackage.haskell.org/package/happstack-ixset, but I dunno if it's efficient
16:25:56 <rostayob> aavogt: yes basically I want to replace ixset, which doesn't really do the ordering and does the lookup in quite an inefficient way
16:26:02 <bwright> Oh come on! 307*M quota: 304M
16:26:05 <jmcarthur> a -> Maybe b -> Either a b  -- should totally be a standard function, amirite?
16:26:28 <rostayob> and the idea right now seems to be to rewrite it with kd-trees, but I don't see how kd-trees solve the ordering problem
16:26:33 <rostayob> jmcarthur: you are right
16:26:43 <aavogt> @ty (flip maybe . Left) . Right
16:26:44 <lambdabot>     Couldn't match expected type `a -> b'
16:26:44 <lambdabot>            against inferred type `Either a1 b1'
16:26:44 <lambdabot>     In the second argument of `(.)', namely `Left'
16:27:07 <aavogt> @pl \x -> maybe (Left x) . Right
16:27:07 <lambdabot> (. Right) . maybe . Left
16:27:33 <aavogt> oh, it's still wrong
16:27:35 <Axman6> @pl \x m -> maybe (Left x) Right m
16:27:35 <lambdabot> flip maybe Right . Left
16:27:37 <aavogt> @pl \x -> maybe (Left x) Right
16:27:37 <lambdabot> flip maybe Right . Left
16:27:50 <aavogt> @ty \x -> maybe (Left x) Right
16:27:51 <lambdabot> forall a b. a -> Maybe b -> Either a b
16:28:03 <Eduard_Munteanu> jmcarthur: how's that supposed to work?
16:28:14 <jmcarthur> @djinn a -> Maybe b -> Either a b
16:28:14 <lambdabot> f a b =
16:28:14 <lambdabot>     case b of
16:28:14 <lambdabot>     Nothing -> Left a
16:28:35 <jmcarthur> umm...
16:28:38 <jmcarthur> lambdabot?
16:28:39 <aavogt> @moar
16:28:39 <lambdabot> Maybe you meant: map more
16:28:41 <Eduard_Munteanu> and _ -> Right b?
16:28:51 <Eduard_Munteanu> erm.
16:28:55 <Eduard_Munteanu> Just x -> Right x
16:28:56 <jmcarthur> Just x -> Right x
16:28:59 <jmcarthur> yeah
16:29:10 <Eduard_Munteanu> Ah, not bad.
16:29:16 <aristid> wasn't haskell platform supposed to come out yesterday?
16:29:18 <Eduard_Munteanu> That's like a maybeDefault
16:29:21 <jmcarthur> basically allow you to "explain a failure"
16:29:39 <Philonous> aristid: Real soon now!
16:29:52 <jmcarthur> hayoo shows one package that has it. it calls the function elaborate
16:33:28 <hpc> > foldr (\x -> (2*):) [] [1..5]
16:33:29 <lambdabot>   <no location info>: parse error on input `)'
16:33:40 <hpc> > foldr (\x -> ((2*x):)) [] [1..5]
16:33:41 <lambdabot>   [2,4,6,8,10]
16:33:50 <hpc> fun!
16:34:07 * hpc might finally be getting the hang of folds
16:38:04 <lysgaard> I have a client server setup. The client writes a request, the server processes the request and the client then reads of the answer. The communicition is trough handles. How do i get the client to "wait" for the server output. Right now the client fails because it expects a answer instantaniously.
16:39:00 <parcs> how does it fail?
16:39:29 <lysgaard> parcs: When i try to parse the response it's of length 0
16:40:11 <lysgaard> The client is like this: hPutContent h cont; resp <- hGetContent h;
16:42:10 <parcs> and length resp returns 0?
16:43:30 <parcs> length resp shouldn't return anything unless the handle is closed
16:46:30 <geheimdienst> so, what's the difference between "IO String" and "a ~ String => IO a"?
16:46:52 <lysgaard> parcs: Hm.. I think I misunderstood my problem. I need to look intoo it more before i know what's causing it.
16:47:02 <geheimdienst> i checked the documentation on type families, and it talks about ~ as being equivalence
16:47:06 <lysgaard> parcs: Thanks for the help anyway =)
16:47:47 <sipa> geheimdienst: i suppose that if you use something like that in an instance declaration, it would overlap with IO Int
16:47:53 <sipa> while IO String wouldn't
16:48:27 <parcs> lysgaard: okay :)
16:48:59 <geheimdienst> sipa: interesting, thanks ... this relates to those errors i've been seeing
16:50:19 <sipa> since the overlap checks ignores contexts
16:50:38 <geheimdienst> where "context" is the bit to the left of =>?
16:50:41 <sipa> yes
16:54:12 * hackagebot bash 0.0.0 - Bash generation library.  http://hackage.haskell.org/package/bash-0.0.0 (JasonDusek)
16:57:03 <hpc> ooh
16:59:53 <Eduard_Munteanu> Haskell to generate bash, to generate awk, to generate latex, to generate postscript, to generate an image :P
17:00:42 <Axman6> of a haskell program
17:00:53 <geheimdienst> which is a quine
17:01:00 <gwern> Eduard_Munteanu: alright, I'm hereby revoking your Haskell card. stop by HQ first thing tomorrow. you can reapply after a month of probation.
17:01:09 <bwright> With inbuilt stegonography with the code for the haskell program
17:01:28 <Eduard_Munteanu> :)
17:01:34 <lysgaard> parcs: How much will hGetContent get?
17:01:35 <Axman6> that generates bash...
17:01:47 <Eduard_Munteanu> Heh.
17:01:48 <Axman6> lysgaard: as much as you use
17:02:20 <kmc_> hGetContents does "lazy IO", which is a dangerous perversion of lazy evaluation
17:02:36 <kmc_> usually evaluating an expression cannot cause IO to occur
17:02:50 <kmc_> but hGetContents has an implementation which breaks the rules
17:03:09 <gwern> hm... my github script is exiting early and so only the alphabetically first repo, XMonader, is getting shelled out to
17:03:36 <bwright> I was talking to a Microsoft employ the other day about agile programming and he was telling me how the corporate world works. Water fa(i)ll design put all your money on a boat and watch it fall off a cliff into a raging river. Rise and repeat.
17:04:01 <kmc_> bwright, yes, the merchants of agile snake oil will try to convince you that's the only alternative
17:04:23 <kmc_> of course "agile" is common sense but it's hard to get rich off common sense without obfuscating it
17:04:34 <monochrom> every software process is a lot of tiny waterfalls combined together. don't scorn waterfall that easily.
17:04:49 <gwern> @src mapM
17:04:49 <lambdabot> mapM f as = sequence (map f as)
17:05:38 <gwern> grr. how do I make my program wait on a  bunch of IO ()s...
17:05:41 <Eduard_Munteanu> There's a lot to be learned from waterfall.
17:05:49 <kmc_> gwern, sequence?
17:05:52 <Eduard_Munteanu> Like, planning ahead.
17:05:54 <gwern> :t sequence
17:05:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:06:12 <gwern> kmc_: but mapM is already using sequence
17:06:27 <kmc_> your question didn't say anything about mapM
17:06:44 <bwright> kmc_: Fair enough.
17:06:51 <kmc_> Eduard_Munteanu, planning ahead? sounds evil, like static types! my preferred development methodology is to write a test case and than pound my fists / ass against the keyboard until i generate some code which passes the test case
17:07:07 <monochrom> which is waterfall
17:07:13 <bwright> kmc_: While pair programming lol :P
17:07:42 <kmc_> if you know what your program does before you run it, you are an evil waterfall just like IBM
17:08:09 <kmc_> gwern, if you have a type like [IO [IO ()]] then yes you could use sequence twice
17:08:28 <monochrom> indeed, if you write a test case first, you know what your program does before you run it --- it passes the test case, that's what it does.
17:08:42 <gwern> kmc_: no, this is a... [String] -> IO[()], I think
17:08:45 <kmc_> that's great if people hire you by test case
17:08:53 <kmc_> IO [()]? very odd
17:09:01 <Eduard_Munteanu> How's that useful? :)
17:09:12 <monochrom> there is no escape from waterfall.
17:09:14 <kmc_> gwern, what are you trying to do?
17:09:18 <gwern> kmc_: well, I'm mapping a String -> IO (), so that's what happens when I map the String -> IO () over a [String]
17:09:27 <kmc_> sure
17:09:28 * Eduard_Munteanu could coin the phrase "real programmers write only test cases (tm)"
17:09:37 <kmc_> it'd be more common to use mapM_ to throw out the list of useless ()
17:09:44 <kmc_> (to avoid accumulating it in the first place)
17:09:54 <bwright> Eh test cases can be automated ish anyway.
17:09:56 <Jafet> Testcase + quickspec = instant program
17:10:13 <gwern> kmc_: [String] = list of https URLs which are git repos; String -> IO () is the shell out to git which returns nothing; since this is the last action in the program, I can't use mapM_ since that would exit instantly before the hundreds of git invocations have finished
17:10:28 <Jafet> (Did I just invent a new software development paradigm?)
17:10:36 <kmc_> oh, it's asynchronous?
17:10:42 <kmc_> are you spawning a thread or something?
17:10:50 <gwern> kmc_: see http://hpaste.org/paste/44552/github_downloader_annotation#p44555
17:10:56 <bwright> Jafet: No Sony owns it.
17:11:15 <gwern> kmc_: no threading; I'm not actually sure what executeFile does concurrency wise
17:11:28 <kmc_> but it doesn't wait until the command completes to return?
17:11:47 <kmc_> i don't see any hope for success then
17:11:48 <Eduard_Munteanu> That's odd. It should at least return a PID or something.
17:11:52 <kmc_> why System.Posix.Process not System.Process?
17:12:04 <gwern> see executeFile yourself! http://hackage.haskell.org/packages/archive/unix/2.4.0.0/doc/html/System-Posix-Process.html#2
17:12:21 <gwern> looks like I could call git directly instead of going through sh, though - says it searches $PATH
17:12:22 <geheimdienst> gwern, are you calling that function withCurlDo? i've been wondering if i need it, the docs are somewhat unclear
17:12:24 <kmc_> uh, executeFile calls execv
17:12:30 <kmc_> which means it should never return
17:12:31 <geheimdienst> you "should" call this once ...
17:12:46 <kmc_> that's why it returns "IO a" for a totally polymorphic 'a'
17:13:20 <vijayl> \?
17:13:22 <vijayl> \q
17:13:27 <gwern> geheimdienst: I haven't touched withCurlDo. I have no idea what that does - seems to work as is
17:13:27 <kmc_> (technically not "never return" but "produces an IO action  which never completes")
17:13:29 <vijayl> help
17:13:43 <monochrom> /quit
17:13:45 <Eduard_Munteanu> vijayl: you're looking for /
17:13:52 <gwern> kmc_: oh, I didn't know execv was that sort of traphole. interesting
17:14:02 <vijayl> oops sorry
17:14:02 <kmc_> gwern, why not use System.Process?
17:14:04 <gwern> I guess xmonad got away with it because it was using a fork
17:14:09 <kmc_> the higher-level, cross-platform interface
17:14:27 <gwern> that sounds like a good idea
17:14:33 <kmc_> yeah, the unix idiom is to fork(), then call execv() in the child process
17:14:56 <Jafet> Well, that's technically the only way to start child processes.
17:15:10 <kmc_> not on linux ;)
17:15:30 <geheimdienst> gwern, i checked the source, it calls curl_global_init, which libcurl documents as "you must call this before using libcurl" ... http://curl.haxx.se/libcurl/c/curl_global_init.html
17:15:46 <gwern> geheimdienst: if the docs don't say to do it, it can't be very important
17:15:57 <kmc_> how rude to make a Haskell binding that has such C-isms in it :/
17:16:07 <gwern> hm, maybe I should use readProcess, it claims to block until the command finishes
17:16:08 <geheimdienst> uh, the docs don't look very complete
17:16:38 <kmc_> also "WARNING: the argument should not return before it is completely done with curl"
17:16:42 <kmc_> sounds dangerous
17:16:45 <lysgaard> So I'm trying to send a Object over a socket as a Binary instance. But at the other end the evaluation never finishes. I use: cont <- hGetContent; putStrLn (show . decode $ cont) but nothing shows
17:16:48 <kmc_> there are FFI techniques to do these things safely
17:17:02 <Eduard_Munteanu> Most bindings are just straightforward translations. I'd think a higher-level API/wrapper would avoid that, instead.
17:17:05 <kmc_> probably because the socket is still open
17:17:18 <kmc_> Eduard_Munteanu, is that how you define "binding" versus "wrapper"?
17:17:26 <geheimdienst> kmc, seems like a roundabout unclear way of saying "best stick this in main: main = withCurlDo $ do ..."
17:17:34 <Eduard_Munteanu> Well, like wxWidgets is wrt GTK.
17:17:42 <kmc_> geheimdienst, yeah, but there are ways to make that invisible
17:18:05 <Axman6> lysgaard: there are packages to do that for you, check out BinaryComm
17:18:07 <geheimdienst> yes, sure. this was about the point that the docs are less than celestial
17:18:29 * gwern has faith in the docs. why are you testing me, oh Curl?
17:18:33 <lysgaard> kmc_: Hmm. This is the flow i want: Client sends a request. Server evaluates the request and writes the answer to the same socket. Client reads off answer. Client and server close the socket
17:18:54 <gwern> as it was in the init, is now, and ever shall be, OS without end, abit.
17:18:58 <kmc> lysgaard, maybe use a higher-level protocol like Thrift?
17:19:17 <kmc> TCP has no notion of requests or corresponding responses, it's something everyone reimplements over and over
17:19:39 <kmc> there's also xml-rpc / yaml-rpc / json-rpc
17:19:59 <kmc> and apparently "messagepack"
17:20:00 <Eduard_Munteanu> Yeah, TCP is pissy in that respect, you need to have some higher-level stuff that can send/receive individual and complete messages.
17:20:16 <geheimdienst> yes, let's all code-review and criticize the curl package just to make gwern nervous :)
17:20:41 * Eduard_Munteanu wishes to see SCTP more widely implemented.
17:20:59 <kmc> i'd like to see the Linux SCTP stack better audited before that
17:21:06 <kmc> but, yes
17:21:49 <gwern> geheimdienst: don't you know, 'thou shalt not test the Curl thy Library'?
17:22:47 <Jafet> Thou shalt not use ye olde english in vain
17:23:08 <monochrom> haha
17:23:12 <gwern> Jafet: pah, you think that's old english?
17:23:23 <gwern> Jafet: with no thorns in it? that's middle english at the earliest
17:23:27 <kmc> :þ
17:23:38 <gwern> ooh, my script seems to be working finally
17:23:54 <kmc> actually that 'y' is an alternate glyph for þ
17:23:57 <kmc> really
17:24:07 <kmc> it's "þe old" i.e. "the old"
17:24:31 <kmc> þe more you know ™
17:26:04 <geheimdienst> chaucer on lolcats: http://houseoffame.blogspot.com/2007/05/i-can-hath-cheezburger.html
17:26:05 <lysgaard_> Axman6: I think binarycomm is what I'm looking for =) Thanks
17:26:26 <geheimdienst> "No thyng hath plesed me moore, or moore esed myn wery brayne than thes joili and gentil peyntures ycleped “Cat Macroes” or “LOL Cattes .” Thes wondirful peintures aren depicciouns of animals, many of them of gret weight and girth, the which proclayme humorous messages in sum queynte dialect of Englysshe"
17:26:31 <Axman6> no worries, i used it in a previous project and it worked quite well
17:26:43 <Jafet> Þe olde Engliſh
17:27:18 <kmc> oh, that's a good library to know about
17:27:49 <Eduard_Munteanu> LOL
17:28:07 <Eduard_Munteanu> Is that about our Philippa?
17:28:42 <Eduard_Munteanu> "plz be respecting our feudalism" :))
17:35:07 <gwern> geheimdienst: hm, should 'ycleped' be 'yclept'?
17:36:33 <geheimdienst> no idea :) but i wouldn't put it past this chaucer dude to make up the spelling as he goes. after all he says peyntures in one line and peintures in the next
17:37:40 <gwern> git treats a repo already existing as an error and that kills the script. hm. now I need to ignore errors...
17:38:09 <gwern> readProcessWithExitCode, I guess
17:39:03 <kmc> spelling wasn't really a thing back then
17:44:39 <lionel43> > quicksort (x:xs) = quicksort [y | y <- xs, y <  x] ++ [x] ++ quicksort [y | y <- xs, y >= x]
17:44:40 <lambdabot>   <no location info>: parse error on input `='
17:44:54 <hpaste> JoelBurget pasted "Marshal null-terminated array"  http://hpaste.org/44556
17:44:55 <lionel43> is this considered a good quicksort?
17:45:25 <joelb> Can someone help me with marshalling a null-terminated array?
17:45:38 <gwern> lionel43: many would point out that that's really a mergesort or something
17:45:39 <joelb> Attempted code above
17:45:43 <dolio> What's a "good" quicksort?
17:45:51 <kmc> lionel43, a lot of people will consider it not a quicksort
17:45:54 <kmc> because it's not in-place
17:45:59 <dolio> It's definitely not a mergesort.
17:46:10 <kmc> joelb, sure
17:46:13 <kmc> just ask your question
17:46:35 <kmc> joelb, did you look at Foreign.Marshal.Array?
17:46:38 <joelb> I have a null-terminated array, without a given length
17:47:12 <joelb> I did, the problem is the functions there either require a length or the value of the last element
17:47:26 <kmc> if the element is null-terminated, isn't the value of the last element null?
17:47:26 <joelb> I have the value of the last *pointer*, ie nullPtr
17:47:29 <kmc> if the *array*
17:47:31 <kmc> oh, i see
17:47:44 <kmc> then i think you want to marshall an array of pointers
17:47:55 <kmc> and then mapM some marshalling function over those
17:48:03 <joelb> Hm that makes sense
17:48:15 <lionel43> can a quicksort be achievable in haskell? lol
17:48:17 <kmc> lionel43, if you use e.g. Data.List.partition you can avoid traversing xs twice
17:48:38 <joelb> any idea why the code above would cause a segmentation fault?
17:48:51 <kmc> lionel43, yes, Haskell has several kinds of mutable arrays
17:49:00 <gwern> lionel43: of course; but you'd have to be in ST or IO or something, and you'd lose a fair bit of elegance
17:49:05 <kmc> Haskell in general supports mutation and imperative programming just fine
17:49:18 <kmc> the way it differs from other languages is that it doesn't assert that mutation is the One True Hammer
17:49:57 <dolio> joelb: Advancing a pointer isn't going to get you to null for a very long time in most cases.
17:50:27 <dolio> You're much more likely to dereference outside of the proper area first.
17:50:53 <joelb> dolio: what do you mean by your last statement?
17:51:04 <joelb> what is the proper area?
17:51:10 <dolio> There are at least two ways to get a segmentation fault.
17:51:14 <dolio> One is dereferencing null.
17:51:30 <dolio> A second is dereferencing a pointer to a location that the system knows you don't own.
17:52:21 <kmc> these are the same way -- most systems know you don't own the memory at address zero
17:52:22 <joelb> dolio: By my logic I check to see if a pointer is null first, then if it isn't I access it.
17:52:30 <dolio> Your loop appears to be like: 'for(p = p0;p != 0;p++) { ... *p ... }'
17:52:30 <gwern> yay, the script is working - up to 115 repos now
17:52:49 <kmc> but you can change that by mapping memory at NULL
17:52:50 <dolio> That will only end when the value wraps around from the maximum pointer value to 0.
17:52:56 <kmc> and then *((int) NULL) will succeed
17:53:02 <joelb> dolio: Oh I see
17:53:11 <kmc> see http://blog.ksplice.com/2010/03/null-pointers-part-i/
17:53:30 <Eduard_Munteanu> joelb: checking for NULL is not a protection for going out of bounds.
17:53:35 <kmc> modern Linux forbids mapping memory at 0 because it's a security risk, for fairly hilarious ways
17:54:07 <joelb> I confused the value of the pointer and the value pointed to
17:54:16 <Eduard_Munteanu> gwern: erm, you want to clone 115 git repos?
17:54:27 <Eduard_Munteanu> Or?
17:54:38 <gwern> Eduard_Munteanu: no, I want to clone a few thousand
17:54:43 <kmc> anyway the standard library already has code for marshalling a null-terminated array
17:54:47 <Eduard_Munteanu> Hah, even more bold :)
17:54:49 <gwern> Eduard_Munteanu: lot of haskell stuff on github
17:54:54 <kmc> which won't segfault, presuming your array really is null-terminated
17:55:05 <Eduard_Munteanu> gwern: do you need it on localhost?
17:55:17 <gwern> Eduard_Munteanu: pfft, that's like asking, does anyone *need* the Internet Archive?
17:55:42 <Eduard_Munteanu> No, it's like asking "should *I* host the Internet archive?". :P
17:56:12 <joelb> kmc: which module?
17:56:30 <kmc> Foreign.Marshal.Array
17:56:45 <gwern> Eduard_Munteanu: I don't follow. how does that analogy work? no one else is backing up repos - you can't git clone from the IA
17:56:51 <gwern> it doesn't spider them or something
17:57:04 <kmc> peekArray0
17:57:21 <gwern> (159 repos)
17:57:46 <Eduard_Munteanu> So you intend to set up a Git repo for all those?
17:57:49 <gwern> Eduard_Munteanu: it's easy to clone c.h.o, and I already wrote the script to mirror patch-tag, but github was the big missing piece
17:57:59 <joelb> kmc: thanks, what I still don't quite understand is what my end marker should be
17:58:00 <Eduard_Munteanu> c.h.o = ?
17:58:07 <gwern> Eduard_Munteanu: code,haskell,org
17:58:10 <Eduard_Munteanu> Ah.
17:58:31 <joelb> kmc: because in C it would be a pointer to 0
17:58:44 <kmc> you have an array of pointers, right?
17:58:47 <joelb> kmc: but I need to pass it a Haskell object
17:58:50 <kmc> where the last pointer has the value 0?
17:59:03 <joelb> kmc: correct
17:59:24 <kmc> your end marker is Foreign.Ptr.nullPtr
17:59:49 <kmc> and the input to peekArray0 has type Ptr (Ptr T)
18:00:09 <joelb> kmc: Oh I see
18:00:22 <kmc> that gives you [Ptr T]
18:00:44 <joelb> I can work with that
18:00:46 <kmc> then you can use (mapM peek) or whatever else you want to do with them
18:01:45 <joelb> Thanks everyone!
18:01:54 <kmc> :)
18:06:02 <btutt> Hrm. anybody know if you can retrieve autoincementing ids from HDBC against sqllite3?
18:06:20 <gwern> (286 repos)
18:09:20 <gwern> hm, 550M so far... a bit more hard drive space than I was hoping to spend
18:10:40 <geheimdienst> gwern, what exactly are you doing? downloading the interweb?
18:10:50 <gwern> no, just the haskell github part
18:11:22 <gwern> this much haskell should give me better statistics about source code too, besides the archival part
18:11:39 <geheimdienst> interesting, you could check how many people actually import this or that module, or what functions nobody uses
18:11:51 <Eduard_Munteanu> btutt: doesn't sqlite automatically use autoincrementing ids?
18:12:19 <kmc> i suggest you try to estimate the total amount of time wasted by the monomorphism restriction
18:12:23 <btutt> yeah, but I'm persisting some more than 1 table records into sqllite
18:12:38 <lionel43> whats the advantage of haskell over von neumann languages? i still don't understand ...
18:12:53 <btutt> So i need the auto-id before I insert into the 2nd table for the 1-N relation
18:13:16 <gwern> geheimdienst: yep. that came up recently with Data.Set.size - how often did people use it, how often did they use that to check for non-emptiness, etc. if I hadn't had a big collection, I might not have learned that some people have a trick where they take the current size as an ID and then insert it - getting unique IDs from the increasing size
18:13:41 <geheimdienst> gwern, awesome :)
18:13:43 <gwern> geheimdienst: and of course that sort of grep search was a key part of my Control.Monad.void lobbying - 'look how many people are redefining it!'
18:14:59 <geheimdienst> haven't come across C.M.void. what's it do? what are you lobbying for?
18:15:05 <kmc> lionel43, that's a pretty vague question, the sort that is good for generating arguments but not insight
18:15:50 <kmc> i'd say that programs are easier to reason about and easier to write correctly when they use less state
18:15:58 <kmc> especially in a parallel or concurrent setting
18:16:02 <kmc> and i hear that's the next big thing ;)
18:16:21 <lionel43> yeah
18:16:38 <kmc> not totally a coincidence that mainstream languages are ripping off old functional features left and right in order to keep up with concurrent programming
18:16:42 <btutt> Von Neumann is usually used to imply a Von Neumann architecture (i.e. a sequential cpu synchronized by clock ticks) vs. asynchronous electrical circuits
18:17:14 <dolio> Hah, that reminds me....
18:17:16 <kmc> Haskell has many features that aid in program reasoning that aren't especially about being denotative versus imperative
18:17:18 <gwern> geheimdienst: Control.Monad.void is m a -> m () basically. good for use with forkIO
18:17:23 <kmc> like a good static type system
18:17:31 <dolio> I was reading an old book I have today: Taming Java Threads.
18:17:36 <kmc> though it's not totally unrelated, because denotative programs have more interesting types
18:17:37 <dibblego> ...in order to keep up with concurrent programming? I think that there are more reasons than that
18:17:41 <dibblego> dolio: LOL
18:17:47 <dolio> And it was talking about the AWT event multicaster.
18:18:05 <dolio> And how it was a great solution to broadcasting effects without concurrency issues.
18:18:08 <dolio> You know what it is?
18:18:17 <dolio> An immutable list of listeners.
18:18:46 <dolio> Er, broadcasting listener messages.
18:18:58 <kmc> of course when you rip off FP features it's important to change the name so you can take credit
18:19:15 <dibblego> gold
18:20:10 <kmc> lionel43, did you have a more specific question about what makes haskell good / bad ?
18:21:20 <lionel43> kmc: your answer was quite good, thanks buddy
18:22:06 <cole> Does anyone have a suggestion for a library for persisting data using haskell? Perhaps an xml or JSON library? Something else?
18:22:10 <nzero> gwern: on downloading each repo, you might delete everything but .hs and .lhs, and including .git/, if you're just interested in haskell files in head and really need the space?
18:23:14 <gwern> nzero: I'm not that hard up for space; I can keep up by watching anime as the repos download :)
18:24:27 <nzero> gwern :)
18:24:29 <kmc> you could also run some of git's space-saving commands
18:25:49 <gwern> kmc: oh? what are those? I'm not a git person so I don't know much beyond 'git clone' and 'git reset --hard' :)
18:26:11 <btutt> isn't it git repack or something?
18:26:25 <geheimdienst> git gc, i believe
18:26:30 <kmc> both
18:26:40 <kmc> though i don't expect garbage collection will do anything in a freshly cloned repo
18:27:25 <geheimdienst> ... i'm sure there's also about 8 more git commands that have something to do with saving space
18:28:09 <kmc> yeah, like git rm
18:28:10 <kmc> :D
18:30:45 <geheimdienst> git rewire-index-blob, git defold-treeish, git renoodle-goblets
18:31:21 <kmc> hahaha
18:31:32 <kmc> i use that last one all the time
18:31:59 <geheimdienst> iirc, treeish is actually a technical term in git
18:32:03 <gwern> the sad thing is, I can't tell if geheimdienst is joking
18:32:05 <btutt> oh goodness. 
18:33:17 <btutt> Treeish is a term.
18:33:25 <btutt> http://book.git-scm.com/4_git_treeishes.html
18:33:30 <btutt> (ugh)
18:33:56 <geheimdienst> gwern, yes, much of my irrational hatred of git comes from that one incident when i asked on #git and they told me something like "how did you even get the idea that 'git ls-files --cached' would list the cached files? of course it doesn't"
18:34:16 <kmc> git's commands are poorly named
18:34:25 <kmc> i feel this is one of its biggest flaws
18:34:34 <btutt> Lets just use Hg that talks to github. ;)
18:34:35 <geheimdienst> it's just too damn complicated. so many overlap between commands, inconsistent switches, lots of technical terms ...
18:34:38 <kmc> (and, since that's a relatively minor problem, i feel that git is an excellent tool overall)
18:34:38 <dankna> "There are a number of ways to refer to a particular commit or tree..."  see please don't take that for granted that I know that commits and trees are synonymous!
18:34:46 <kmc> dankna, they aren't
18:34:46 <dankna> coming from a non-git background that's immensely counterintuitive
18:34:50 <kmc> that's why the word "or" is there
18:34:58 <kmc> commits and trees are the same
18:35:04 <dankna> yeah, I was about to say, please don't take for granted that I understand their relationship in git
18:35:05 <kmc> as any introduction to git's data model will explain
18:35:18 <dankna> darcs is just so much better documented and more user-friendly :(
18:35:22 <gwern> indeed
18:35:28 <gwern> why I still use darcs
18:35:37 <dankna> yeah, I do too, but alas!  it is the way of the past
18:35:44 <kmc> darcs is also better at running out of memory on simple tasks
18:35:47 <dankna> granted
18:35:53 <gwern> kmc: memory is cheap, my time is not
18:35:53 <dankna> but it's a crucial component
18:36:02 <geheimdienst> but that's a good example actually, the writing is not very good. "or" is fatally ambiguous in that sentence
18:36:13 <kmc> gwern, sorry, by "running out of memory" i mean "completely dying and failing to do what it was supposed to on a machine with 4 GB RAM"
18:36:13 <dankna> yeah, that was the point I was trying to make
18:36:20 <kmc> i've used darcs on the GHC repo and i've used git on the Linux repo
18:36:23 <kmc> and there is no comparison
18:36:24 <dankna> much of /my/ irrational hatred of git stems from that one incident where it deleted my changes instead of saving them
18:36:37 <dankna> which actually strikes me as rather rational hatred, even though I'm sure it was somehow my own fault :)
18:36:51 <kmc> anyway i learned long ago that git doesn't get a fair chance here
18:36:55 <btutt> I am forced to use ClearCase at work. *sobs* I rationally hate ClearCase. :)
18:37:06 <dankna> well, I admit that there's a bit of "Haskell pride", but honestly...
18:37:14 <kmc> i hear the GHC devs are again considering switching to git
18:37:19 <dankna> it's decided
18:37:22 <btutt> They've switched
18:37:22 <dankna> and in progress
18:37:27 <dankna> no, it's not yet accomplished
18:37:28 <Axman6> kmc: the switch should be soon i believe
18:37:31 <dankna> but it's very soon
18:37:36 <Axman6> btutt: officially?
18:37:47 <kmc> i'm sure darcs has a lot to offer the world, and i don't mean to dismiss the hard work of many clever people
18:37:51 <kmc> but it's simply not usable on a repo that size
18:37:54 <btutt> The decision has been made, the process is on going atm.
18:37:57 <dankna> not officially unless it's happened since the last weekly meeting, heh
18:38:05 <btutt> (IIRC)
18:38:17 <kmc> i also find it tremendously ironic that so many Haskellers are in the tank for darcs, when git has the immutable append-only data model
18:38:24 <kmc> and sharing of trees, etc
18:38:31 <dankna> granted, heh
18:38:34 <kmc> the main thing that makes git good is the simplicity of its data model
18:39:01 <kmc> there are too many commands and some are a total mess
18:39:08 <kmc> but i always know what git is actually storing
18:39:10 <dankna> if you say so.  but they need to get someone on the project who can write his way out of a paper bag, documentation-wise.
18:39:14 <kmc> if not how it got there or where it came from
18:39:33 <geheimdienst> kmc, i think the gittites put a lot of effort towards speed and handling excessively large repos, and that's admirable. however they did botch the user interface part, and the basic design doesn't look unixly small to me, it looks big and confused
18:39:35 <dankna> I'm perfectly willing to accept that git may have some theoretical benefit, it's just that I can't take advantage of that.
18:39:38 <dolio> Moving GHC to git is a good decision.
18:39:49 <kmc> dankna, and i feel exactly the same about darcs ;)
18:39:57 <kmc> in fact there are some problems i encounter at work that i know darcs would solve better
18:40:00 <dolio> But that means nothing for gwern or dankna's uses, I expect.
18:40:01 <dankna> ghc needs git's performance, that's clear.  it's not so much a good decision as the least-bad decision.
18:40:03 <dolio> Or mine.
18:40:12 <dolio> Unless they're secretly building projects as large as GHC.
18:40:19 <dankna> indeed, I am not :)
18:41:22 <kmc> anyway it's really ironic that people here favor the tool that's "easy to learn" over the tool with a simple data model based on immutable data
18:41:36 <btutt> Is git really append only? Could you sign every change as applied and never need to resign a new signature? I thought git was more complex than that.
18:41:37 <Axman6> my experience with darcs and git are that for small projects, darcs is more pleasant to use, but for large ones, git copes so much better they don't even compare
18:41:37 <dankna> I agree, it's ironic, but ...
18:41:51 <kmc> btutt, objects are identified by their SHA1 checksum
18:41:55 <kmc> so yes, you cannot mutate an object
18:41:58 <kmc> by definition
18:42:03 <kmc> and you can crypto-sign them, and git has commands for doing so
18:42:05 <Axman6> i just wish git had a better ui
18:42:13 <btutt> cool
18:42:25 <kmc> btutt, of course there are commands which generate *new* objects by making copies of old ones with modifications
18:42:37 <geheimdienst> what? i thought git was big on "rewriting history" and such
18:42:39 <kmc> but the new object will have a new name
18:42:47 <btutt> Ah. that would explain it.
18:42:51 <kmc> yep, "rewriting history" involves creating new commits, new trees, etc.
18:43:04 <kmc> then you update your "ref" to point to the new object
18:43:08 <kmc> but the old one is still there
18:43:21 <kmc> also git is not "big on rewriting history"; git supports many alternative workflows
18:43:27 <kmc> some are merge-heavy, some are rebase-heavy
18:43:52 <geheimdienst> but do things in darcs/hg/whatever repos change once committed?
18:44:00 <kmc> you can do practical software development without any of the "rewriting" stuff
18:44:14 <geheimdienst> i always thought being pretty immutable is a core feature of any vcs
18:44:26 <kmc> my understanding is that darcs doesn't even store full files, it stores patches
18:44:30 <kmc> and commutes them 'round each other
18:44:33 <kmc> but i don't know darcs very well
18:44:56 <kmc> (which is why my above rant is mostly "here's why git is good" and not "here's why darcs sucks", other than the one time i tried to use it and it failed miserably)
18:45:34 <dolio> That sounds like what I've heard.
18:48:03 <btutt> "Rewriting history" systems always make me feel nervous. It seems like it exponentially complicates the task of auditing the real history of the set of changes. Rename handling always tends to suck in most vcs systems as well. 
18:48:51 <kmc> and not rewriting history complicates the task of understanding code
18:49:25 <kmc> but anyway git lets you choose how much anachronistic cleanup you want to do
18:49:38 <kmc> and makes it easy to keep a pointer to the original history (there's the immutability again)
18:49:49 <btutt> definately not saying there's an easy answer. vcs sysmtes are just going to be complicated as hell due to the fact that they're vcs
18:49:52 <gwern> now why, one wonders, does the turbinado-blog repo keep dist/ in git?
18:50:21 <kmc> a commit's parent(s) are part of the data being hashed, so if you have a commit you have its "true history"
18:50:53 <kmc> someone else is free to make a new commit object with the same set of changes and a different parent
18:51:01 <kmc> developers can and will do that even without tool support
18:54:17 <gwern> (687 repos and 1.3G so far)
18:56:49 <geheimdienst> ok, i'm getting "No instance for (IsString (IO a))", and what i have defined is "instance IsString (IO String)". i see the point of the error message, but how do i fix it? except for the type families "~" trick
18:57:51 <kmc> in whatever context you're using a string literal as an IO action
18:57:55 <kmc> make sure it has type IO String
18:58:13 <kmc> by using the result somehow, or just by writing a type annotation
18:59:36 <geheimdienst> yeah ... i tried an annotation already, but that's additional boilerplate. can't i get ghc to recognize that IO String fits into IO a, and use it?
18:59:39 <madManchegan> Hello. I'm working from the Learn You a Haskell online book and when declaring a variable (scoped type variable) I get an error that it's not in scope. ie: lucky :: (Integral a) => a -> String
18:59:40 <geheimdienst> some extension maybe?
19:00:20 <madManchegan> Sorry for the beginner question but I've looked it up and I'm just not seeing what I did wrong here.
19:00:21 <kmc> geheimdienst, if you had instance IsString (IO Int) and IsString (IO String), why would it pick one over the other?
19:00:27 <kmc> madManchegan, can you put your code on hpaste.org?
19:00:49 <madManchegan> Oh! Sorry - uh sure.
19:01:19 <kmc> ScopedTypeVariables is a GHC extension to the standard Haskell language
19:01:24 <kmc> is it mentioned in LYAH?
19:02:16 <geheimdienst> kmc, good point, that would clash. but as long as there's only one fitting instance visible, it could use it ...
19:02:19 <madManchegan> yes, I thought the section I just finished. I'm copying right from the examples but return an error
19:02:42 <kmc> geheimdienst, anyone can add a new instance
19:02:48 <kmc> in another module, after yours is compiled
19:03:28 <hpaste> madManchegan pasted "Scoped Type Variable Error"  http://hpaste.org/44559
19:03:54 <geheimdienst> yeah ... i just thought, if i use a function foo, i don't have to qualify it. only when i add an import that pulls a second function named foo do i get compiler errors about ambiguous stuff and i need to clarify by saying Something.foo
19:04:13 <kmc> madManchegan, oh, i thought there was more code
19:04:16 <geheimdienst> don't know if the analogy makes much sense, that was just intuitively what i expected
19:04:28 <madManchegan> No, that's it :)
19:04:33 <kmc> madManchegan, if you compile just that, the error is
19:04:35 <kmc>     The type signature for `lucky' lacks an accompanying binding
19:04:59 <kmc> you have to define "lucky"
19:05:05 <kmc> you can't just write a type signature by itself
19:05:08 <kmc> also, you're not using ScopedTypeVariables either
19:05:36 <madManchegan> ok, I think I'm following so far
19:06:15 <kmc> is that the same error message you got?
19:07:20 <madManchegan> It just gave me back a "Not in Scope"
19:09:43 <kmc> did you type that in at ghci?
19:09:45 <kmc> or in a file?
19:09:51 <madManchegan> ghci
19:09:55 <kmc> oh
19:10:00 <kmc> that goes in a file
19:10:04 <kmc> before the definition of "lucky"
19:10:17 <kmc> ghci's prompt is not the same as a file top-level
19:10:22 <kmc> ghci's prompt is like an IO "do" block
19:10:24 <madManchegan> OH! That's why it worked earlier.
19:10:38 <madManchegan> I see
19:11:33 <madManchegan> I knew it was something — obvious to most but me... Thank you kmc
19:11:53 <kmc> no problem :)
19:12:33 <madManchegan> In case it's not clear... I'm new to Haskell :)
19:12:47 * hackagebot JSON-Combinator 0.2.5 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.2.5 (TonyMorris)
19:21:56 <geheimdienst> what's the standard-ish way of trimming a string?
19:23:44 <dons> dropWhile isSpace ? 
19:24:24 <ManateeLazyCat> Haha, lambdabot back. :)
19:24:49 <geheimdienst> yeah, that only trims the left end, i was looking for both ends
19:25:10 <geheimdienst> > let trim = d . reverse . d . reverse where d = dropWhile isSpace in trim "  lolcats     "
19:25:12 <lambdabot>   "lolcats"
19:25:24 <geheimdienst> ^^ is what i'm doing currently, but it is goofy
19:25:51 <ManateeLazyCat> I remember some package do above work, let me search.
19:27:29 <Kaidelong> geheimdiesnt: I am not sure why that should be goody
19:27:32 <Kaidelong> goofy even
19:27:34 <ManateeLazyCat> Ooops, forgot name.
19:27:35 <geheimdienst> ... ah, found it. it's in missingh under the name of "strip". thanks guys
19:27:59 <geheimdienst> Kaidelong: well it looks funny i thought ... d . reverse . d . reverse
19:29:34 <azaq23> > let trim = f . f where f = dropWhile isSpace . reverse in trim " v "
19:29:36 <lambdabot>   "v"
19:31:32 <geheimdienst> but i wasn't the only one who couldn't find strip. hayoo finds tons of "trim"s, including in the snap package, happstack, ...
19:34:06 <Axman6> azaq23: it's slightly more efficient if you reverse the order of dropWhile and reverse
19:34:55 <geheimdienst> > let trim = f . f where f = reverse . dropWhile isSpace in trim "  lolcats    "
19:34:56 <lambdabot>   "lolcats"
19:35:06 <gwern> Axman6: I imagine a single recursion down the string is probably still more efficient
19:35:17 <gwern> (reverse is rarely an efficient solution)
19:35:24 <Axman6> i
19:35:40 <Axman6> I'm not sure how you'd implement trim with one traversal
19:35:40 <geheimdienst> for short strings, anything is efficient
19:37:37 <gwern> Axman6: I think it'd go something like, 'dropWhile isSpace' until you hit the first non-space, then keep an accumulator for consecutive whitespace, append the accumulator to the previous bit of the string when  you hit a non-whitespace, or you hit [] instead, just throwing out the accumulator and returning what you had up to that point
19:37:41 <gwern> if you follow
19:37:56 <gwern> not a clean solution, but it is a single pass
19:38:22 <Axman6> yeah, i was thinking roughly the same thing
19:39:14 <geheimdienst> not sure if that is actually faster ... we'd have to test it
19:41:16 <Kaidelong> > ((.) <*> id $ dropWhile isSpace . reverse) "    clean  "
19:41:17 <lambdabot>   "clean"
19:43:05 <gwern> geheimdienst: on a long string it'd win. you have to do the accumulation and testing anyway, and reverse could require an entire extra pass, although with haskell I wouldn't want to bet on how big the string has to be to win. I'd hope it win past 1000 chars at least
19:43:42 <kmc> if you care about efficiency on big inputs, you won't be using String anyway
19:44:00 <djahandarie> Seq Char!
19:44:11 <kmc> Array Int Char ;)
19:44:17 <djahandarie> Noooo
19:44:22 <kmc> nearly as bad
19:44:23 <gwern> djahandarie: on Seq we'd still be wondering about this anyway
19:44:42 <kmc> with Seq you can just iterate from both ends to find the first non-space character
19:44:49 <kmc> and i was thinking more of Text
19:45:00 <Kaidelong> trimState1 (' ':xs) = trimState1 xs
19:45:00 <gwern> on Array... hm. actually, on an array it'd be really fast. and that's true of Seq isn't it since you have access to the beginning and end
19:45:16 <Kaidelong> trimState1 xs = trimState2 xs
19:45:17 <kmc> and because taking sub-Seqs is pretty fast
19:45:20 <gwern> nm then about Seq, the single-pass is much cheaper :)
19:45:33 <Kaidelong> trimState2 0 xs, I mean
19:45:37 <Axman6> Array wouldn't be as fast as UArray though
19:46:25 <kmc> trim (viewl -> (' ' :< xs)) = trim xs; trim (viewr -> (xs :> ' ')) = trim xs; trim x = x
19:46:55 <kmc> ♥ Seq
19:47:08 <gwern> something like that. check the first, check the last, and if neither is whitespace, you're done.
19:47:20 <gwern> little harder to do that with a singly-linked list :)
19:47:52 <megajosh2> Hey, does anybody know how to install curl-1.36 on Windows?
19:47:53 <kmc> tested
19:48:13 <kmc> you're still paying the space overhead of boxing with Seq Char, though
19:48:17 <kmc> which is why Text is probably better
19:48:35 <gwern> what *does* Text do? did bos write it up?
19:49:18 <kmc> do for what?
19:50:09 <kmc> http://hackage.haskell.org/packages/archive/text/0.11.0.5/doc/html/Data-Text-Array.html
19:51:21 <gwern> kmc: I mea like what data structure if it's not a Seq. a rope?
19:51:22 <kmc> looks like it uses a unboxed array of Word16
19:51:37 <kmc> sliced in the same way as ByteString
19:51:41 <Axman6> btutt: it's a bytestring with encoding basically
19:51:54 <kmc> i'm not sure how it handles codepoints above 0xFFFF then
19:52:03 <kmc> maybe the same way as UTF-16 but then you lose fast indexing
19:52:14 <btutt> UTF-16 surrogate pairs would be my guess
19:52:39 <Kaidelong> http://codepad.org/7U2k2Qh7
19:52:56 <btutt> You need a text-icu equivalent to do any serious textual analysis of Unicode anyway
19:53:09 <kmc> yeah, it doesn't claim to have fast indexing
19:53:12 <btutt> so the UTF-16 surrogate pairs shouldn't be that big of a wrinkle
19:53:38 <btutt> at least the pairs are better than DBCS encodings like SJIS
19:53:52 <kmc> yeah, bos wrote the icu bindings as well ;)
19:53:52 <btutt> you always know which is the first part of the pair and the last part
19:54:25 <Axman6> i think Text is aimed at fast streaming more than anything (ie parsing etc)
19:55:51 <btutt> Parsing with Text will work just fine (and fairly quickly) the kind of characters in surrogate pairs IIRC don't typically fall into things like Unicode language identifier characters, etc...
19:56:23 <kmc> yeah
19:56:33 <kmc> use whatever you like as long as it isn't Data.ByteString.Char8 ;)
19:57:04 <btutt> even if you need to care about combining characters in your "parsing" then you should consider separating your lexer from your parser. :)
19:57:40 <btutt> (since you'd need to calculate Unicode normalization forms) ugh
19:58:51 <geheimdienst> Kaidelong: nice code. i guess i'd have called it triml and trimr, but whatever :)
19:58:57 <btutt> but you'd have to do that regardless of Text vs. String
19:59:41 <Kaidelong> geheimdienst: Sure. That makes more sense really. I just have a habit of writing (sometimes mutually recursive) "explicit state machines"
20:00:05 <Kaidelong> and that was the pattern that came into my mind immediately
20:00:10 <aavogt> @quote goto
20:00:10 <lambdabot> anonymous says: Primitive recursion is the goto of functional programming.
20:00:53 <Kaidelong> aavogt: pattern matching also provides some goto functionality here
20:00:58 <Kaidelong> although conditional gotos
20:01:56 <kmc> i thought continuations were the goto of functional programming
20:02:24 <kmc> anyway it's a nice idea, that map, fold, etc are "structured" in the same sense as "while" and as opposed to recursion or goto
20:02:43 <gwern> (747 repos, 1.3G)
20:02:49 <kmc> also shouldn't that be general recursion, not primitive recursion?
20:02:52 <kmc> primitive recursion is like fold
20:02:52 <aavogt> yeah, I think it means in the sense of being considered harmful or something
20:03:35 <geheimdienst> i agree, "is the goto" probably just means "is harmful"
20:04:01 <kmc> "considered harmful" considered harmful
20:04:07 <bwright> gotos have very useful functions in programming.
20:04:28 <bwright> A goto and lavel mapped to a void pointer increased python preformance by 17%
20:04:34 <bwright> label*
20:04:53 <kmc> bwright, in the implementation of some interpreter for python?
20:04:55 <Kaidelong> bwright: Python's lack of labeled gotos makes me a bit sad though
20:05:00 <bwright> CPython, they also have purpose in kernel development for getting out of deep nests quickly.
20:05:12 <Kaidelong> especially since recursion can't fill the role of gotos in python
20:05:13 <kmc> or any other big C codebase
20:05:19 <bwright> kmc: CPython from the context of gotos?
20:05:23 <kmc> because C has no exceptions and C++ exceptions are a mess (and slow)
20:05:37 <azaq23> > (runCont $ callCC $ \k -> (fix (\f k x -> if x < 12 then f k (x + 1) else k x)) k 0) id
20:05:38 <lambdabot>   12
20:06:27 <bwright> I agree gotos are never going to be used like they were in the 1960s but they still have use in a preformance sense.
20:06:42 <Kaidelong> anyway gotos can be very handy and more readable than the alternative
20:06:45 <smarmy> but then, a lot of ugly things are done in the name of performance
20:06:48 <kmc> yes, they have a use especially when your language is very weak / low-level
20:06:57 <kmc> :t callCC $ \k -> Left (\v -> k (Right v))
20:06:57 <lambdabot>     Occurs check: cannot construct the infinite type:
20:06:58 <btutt> common cleanup paths in imperative languages are a nice use of gotos
20:06:58 <lambdabot>       m = Either (b1 -> m b)
20:06:58 <lambdabot>       Expected type: m (Either a b1)
20:07:05 <bwright> 17% is a lot of preformance for a little bit of ugly.
20:07:12 <smarmy> :)
20:07:13 <kmc> :t callCC $ \k -> return $ Left (\v -> k (Right v))
20:07:14 <lambdabot> forall b (m :: * -> *) b1. (MonadCont m) => m (Either (b1 -> m b) b1)
20:07:49 <Kaidelong> for example to express that thing I just did in python you'd basically need to write something called a trampoline which is a big while loop which coordinates sending and recieving information from the "states"
20:07:53 <kmc> talking about goto as a trade of ugliness for performance in the context of the Linux kernel is greatly amusing
20:08:00 <bwright> smarmy: Like everything it is all about what you get, and it wasn't a micro optimization :)
20:08:03 <Kaidelong> if you had gotos you could express it much the same way it was done in haskell
20:08:28 <Kaidelong> you could also use recursion but in python that will always build stack
20:08:54 <kmc> right, GHC's unregisterized C output uses a similar trick for tail calls
20:08:57 <geheimdienst> i don't think the author of the "goto considered harmful" paper (hoare?) meant to say "goto must never ever be used anywhere at all". i think he meant "be extra careful with goto and don't overdo it"
20:09:05 <Kaidelong> I think you either want efficient recursion or gotos
20:09:07 <bwright> The creator of python has said that it isn't designed as a fp language but it is kinda fun to play around with
20:09:12 <Kaidelong> having neither is well, dumb
20:09:33 <Kaidelong> and they boil down to the same thing
20:09:50 <kmc> bwright, i don't see why people choose to pigeonhole their languages by rejecting this or that "paradigm"
20:10:25 <Kaidelong> kmc: In some contexts it's because people want a particular implementation
20:10:29 <Kaidelong> IE smalltalk
20:10:42 <kmc> that's shortsighted; implementations will improve but you're stuck with your language spec forever
20:11:04 <smarmy> unless you're python... then you just break compat freely
20:11:12 <monochrom> "goto considered harmful" is by Dijkstra
20:11:14 <kmc> they don't really, not nearly as much as Perl did
20:11:29 <bwright> Well simply because a language is generally designed with some ideas and you don't want to cram their design to your views.
20:11:38 <Kaidelong> smarmy: I like how they make you hand-compile tuple arguments to functions into explicitly breaking them down in the function body now
20:11:53 <Kaidelong> You'd think the compiler would be able to replace (x,y) with x_y
20:12:10 <kmc> bwright, i guess i object to the idea that having lambda that doesn't suck is some kind of big controversial ideological decision
20:12:21 <kmc> instead of a small feature that's very useful in most "paradigms"
20:12:29 <Kaidelong> kmc: but multiline lambdas are ugly!!!
20:12:37 <Kaidelong> It is true because I am Guido
20:12:38 <kmc> what's ugly is the way Python uses whitespace
20:13:04 <kmc> (let's all argue about syntax now)
20:13:16 <Kaidelong> python syntax is relatively nice
20:13:37 <kmc> whitespace dependence with no alternative form is a terrible decision
20:13:53 <kmc> that has ripple effects all over (like the aforementioned lambda)
20:14:29 <bwright> kmc: Whitespace is good if you run a big company with a lot of low end cs grads.
20:14:42 <bwright> COUGH google
20:14:46 <aavogt> having an alternate form steals valuable ASCII space
20:15:03 <gwern> bwright: wait, are you sure you didn't mean 'high end cs grads'?
20:15:06 <kmc> bwright, just force most programmers to use whitespace and require a promotion and special training course to be trusted with the characters {};
20:15:18 <geheimdienst> bwright: haskell has whitespace too, you know ...
20:15:33 <kmc> but you can always write whitespace-insensitive haskell
20:16:00 <bwright> kmc: Don't worry I don't judge I write in C++ so shooting from a glass cannon.
20:16:07 <kmc> haha
20:16:28 <bwright> The shit that language has put me through lol.
20:17:01 <kmc> anyway i'm not sure how i feel about self-styled "master hackers" looking down on the abilities of the "big company code monkeys"
20:17:06 <kmc> i feel that's how we got java
20:17:17 <kmc> a committee decided that the average programmer couldn't be trusted with a good language
20:17:27 <kmc> and tried instead to limit the damage that an average programmer can do
20:17:41 <kmc> there's some truth to that approach but also a lot of waste
20:18:06 <bwright> And flash just blew up my linux pc agan :( brb
20:18:13 * gwern always thought that java was an object lesson in that no language ever stays small; there's a zawinski's law for languages
20:18:29 <kmc> Python is much less restrictive and doesn't limit the damage done by one programmer
20:18:44 <kmc> and it's pretty popular at big companies
20:19:15 <kmc> gwern, is Java really that big as a language?
20:19:29 <gwern> kmc: it's bigger than it used to be, for sooth
20:19:39 <kmc> yeah, they added generics and one or two other things
20:19:50 <kmc> but they're still far behind C# in terms of adding features
20:19:57 <gwern> kmc: if it had not been designed for little settop boxes but to be the One Language, I suspect they would have done some things differently
20:20:00 <kmc> and Java is still missing a lot of features judging from the repeated "design patterns"
20:20:23 <gwern> I imagine it's kind of like the tab/spaces syntax for Makefiles. if they had realized how successful it'd be...
20:20:40 <bwright> Ok now my xmonad super key doesn't work. o.o Why does flash exist :(
20:21:10 <kmc> Ken Thompson was once asked what he would do differently if he were redesigning the UNIX system. His reply: "I'd spell creat with an e."
20:21:42 <smarmy> creet?  that's just silly
20:21:57 <kmc> http://en.wikiquote.org/wiki/File:Ken_n_dennis.jpg ← the original UNIX beards
20:21:59 <bwright> umount is the one that always trips me up.
20:22:24 <geheimdienst> iirc james gosling was asked what he'd do differently about java, and said he'd leave out classes
20:22:56 <geheimdienst> i.e., bigger role for interfaces
20:23:07 <kmc> Bjarne Stroustrup said there are two kinds of languages, those people complain about and those nobody uses
20:23:08 <geheimdienst> i.e. somewhat more like haskell typeclasses :)
20:23:16 <kmc> i feel Haskell is unique in that it's in both categories
20:23:25 <djahandarie> Haha
20:23:58 <smarmy> i've never complained abou thaskell *cought* record syntax *cough*
20:27:10 <geheimdienst> well, complaining is a sign you at least can identify what's bad and maybe try to improve it. complaining is a sign the groupthink hasn't assimilated you yet
20:27:42 <kmc> some people complain about haskell as an excuse not to learn it
20:27:51 <kmc> just like me complaining about darcs
20:31:49 <gwern> or me about git
20:31:55 <Kaidelong> I complained about python for much that reason. And Guido.
20:32:04 <Kaidelong> And then I learned enough of it to feel vindicated
20:32:27 <roconnor> clearly field labels for records should be lenses instead of projection functions
20:32:37 <kmc> for me python and haskell are both pretty good tools that i use daily to get work done
20:32:42 <kmc> which means i complain about both frequently :)
20:33:02 <geheimdienst> there's got to be a difference between an outsider complaining (possibly about things he doesn't understand), and an insider complaining, with the perspective of getting to work fixing it
20:33:19 <kmc> the only people using haskell who don't complain at all are beginners who just wrote quicksort / first 10 project euler problems
20:33:24 <btutt> :) Python is nice for lots of reasons. I've been wishing Python would replace VB(whatever) in Office for ages. :)
20:33:35 <kmc> btutt, these days you can use IronPython, can't you?
20:33:41 <kmc> or F# ;)
20:34:02 <btutt> In theory. I meant specifically for Macros. I dunno if you can do that with other languages..
20:34:16 <kmc> i thought you could use any .NET language
20:34:23 <kmc> but it's been ages since i touched windows or office
20:34:28 <btutt> As addins. Dunno about macros like I said
20:34:33 <kmc> *nod*
20:41:10 <Kaidelong> IIRC VBScript is not so bad
20:41:27 <Kaidelong> as far as scripting goes
20:44:52 <Kaidelong> well I suppose the bar for VBScript to clear is pretty low
20:45:20 <btutt> ? VBScript blows. Its only use in an IE web app is to call MsgBox
20:46:33 <btutt> oh, and the macros are usually in (or were) VBA which isn't the same thing
20:47:22 <Kaidelong> oh
20:47:35 <Kaidelong> yes right sorry, I got the two confused
20:47:54 <btutt> no problemo. VB6, VBScript and VBA all suck
20:48:19 <btutt> VB.Net sucks less and it has features C# doesn't, but its still a basic variant
20:49:00 <btutt> (it has a neat DSL syntax for dealing with XML docs that have schemas)
20:49:32 <Kaidelong> I think the main thing that made my jaw drop with VB.NET was when a program with a missing parenthesis compiled fine
20:49:44 <Kaidelong> but radio buttons were missing from the student's form at runtime
20:50:25 <Kaidelong> "Well you forgot this ')' here..."
20:50:30 <Kaidelong> "Oh now it works fine thanks!"
20:50:54 <btutt> ugh
20:51:17 <btutt> People shouldn't let students program in VB
20:51:32 <Kaidelong> What'd you recommend instead?
20:51:35 <Kaidelong> Delphi perhaps?
20:51:41 <djahandarie> Anyone know of a library function for or a nice way to write  \g m -> m >>= \c -> if g c then return c else mzero
20:51:53 <djahandarie> Similar to guard except that you're inspecting the value in the monad
20:52:04 <btutt> Actually Pascal family languages for intro to com sci has actually made sense to me. The syntax is so easy to wrap your head around.
20:52:47 <Kaidelong> I guess there is also Squeak Smalltalk + eToys
20:52:49 <btutt> Sometimes idiots decide to take into to com sci classes for liberal arts credits and functional programming languages shouldn't be used for those folks. it'll waste tuition money I think
20:52:55 <Kaidelong> but the user interface turns people off
20:52:57 <btutt> Python would work too
20:53:11 <Kaidelong> hmm, yeah, there are some nice python RAD tools out now aren't there?
20:53:22 <ion> ‘m >>= liftM2 (>>) (guard . g) return’ perhaps
20:54:05 <btutt> Dunno. Python is based on ABC which was designed by usability testing
20:55:05 <btutt> aka braces are for annoying languages. ;)
20:55:13 <djahandarie> ion, hm, nifty
20:55:24 <kmc> btutt, i'm not convinced functional languages are harder for beginners
20:55:25 <djahandarie> Probably too golfed for my liking though
20:55:34 <kmc> Haskell is hard for beginners, but Haskell is hardly the typical FP language
20:56:03 <djahandarie> My school is testing out an 'experimential' intro cs course using Scheme
20:56:03 <Kaidelong> kmc: I think the argument isn't that functional programming is hard but that people are turned on to it by looking at shiny user interfaces
20:56:07 <btutt> Depends if they're com sci oriented or not. Recursion tends to hurt the brains of liberal arts visitors brains.
20:56:17 <djahandarie> Apparently people have been dropping out of it
20:56:25 <kmc> djahandarie, MIT and Caltech ditched theirs :/
20:56:25 <Kaidelong> I think for CS students, a functional as a first language might actually make a lot more sense than Java
20:56:26 <ion> djahandarie: that liftM2 pattern is used a lot. Its meaning should be familiar for many without having to think much about it.
20:56:30 <Kaidelong> particularly something like Scheme
20:56:35 <kmc> at least Caltech still teaches it as a second course for CS majors
20:56:37 <Kaidelong> but perhaps CaML
20:56:43 <djahandarie> But the prof is pretty smart and really tough, so it was probably not the language's fault.
20:56:52 <kmc> Scheme has the advantage of *really* simple syntax, even if it's painful for big stuff
20:57:19 <btutt> I did  an intro class that used Scheme. I knew Pascal already all of that parent stuff really annoyed me
20:57:27 <btutt> s/parent/paren
20:57:46 <Kaidelong> IIRC
20:57:46 <Kaidelong> Dijkstra said to teach an unimplemented, declarative language to CS students
20:57:46 <Kaidelong> so that they could not test their programs
20:57:46 <Kaidelong> but instead had to reason about them on paper
20:58:00 <btutt> (adversely impacted the readability of the language for me)
20:58:07 <btutt> heh
20:58:08 <djahandarie> I think that is a terrible idea
20:58:24 <djahandarie> I would not know anything right now if I wasn't able to experiment on a computer
20:58:35 <djahandarie> It's practically the reason I hate math
20:58:44 <djahandarie> (Or, math in schools)
20:58:44 <btutt> kmc: I think a functional language for beginners might work, but i'm not sure scheme is it
20:58:49 <kmc> advantages of Scheme: very regular syntax. disadvantages of Scheme: spend all day arguing about the syntax, don't learn anything more
20:58:51 <Kaidelong> djahandarie: I think that was his point really
20:58:57 <kmc> btutt, i'm also not sure what "a functional language" is.
20:59:15 <kmc> python has nested def and (crippled) lambda, but no TCO
20:59:22 <kmc> javascript is idiomatically functional (callbacks anyone) but also no TCO
20:59:34 <btutt> TCO?
20:59:39 <djahandarie> Tail call optimization
20:59:39 <kmc> tail-call optimization
20:59:40 <Kaidelong> tail call optimization
20:59:46 <ion> TAIL CALL OPTIMIZATION!
20:59:47 <btutt> duh
21:00:00 <ion> (Does it echo in here?)
21:00:00 <djahandarie> @quote glorious.stereo
21:00:00 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
21:00:01 <lispy_> ?quote fugue
21:00:01 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
21:00:01 <kmc> > text $ map pred "ubjm!dbmm!pqujnj{bujpo"
21:00:02 <lambdabot>   tail call optimization
21:00:05 <djahandarie> LOL
21:00:17 <djahandarie> Oh god
21:01:12 <btutt> If there was such a thing as scheme that had a more python like syntax that would be what I might think of
21:01:24 <Kaidelong> btutt: Haskell
21:01:27 <kmc> erm
21:01:30 <kmc> no.
21:01:46 <kmc> Haskell and Scheme are about as different as two languages can be
21:02:00 <kmc> btutt, an advantage of the very regular syntax is that you can come up with some other concrete way to write the same syntax trees
21:02:01 <btutt> Haskell is lazy, i think strictness for beginners might be the best bet
21:02:15 <kmc> there is at least one proposal for whitespace syntax for S-expressions
21:02:24 <btutt> thats cool
21:03:21 <kmc> and you keep the ability to use macros etc.
21:04:06 <Kaidelong> kmc: mostly operationally
21:04:06 <Kaidelong> btutt: I disagree
21:04:07 <kmc> i think it makes sense for a language to have something like s-exprs under the hood, even if you have concrete syntactic sugar over that
21:04:07 <Kaidelong> btutt: at worst, non-strictness will make runtime performance worse. But for "introductory" programs that may not be a big problem.
21:04:08 <Kaidelong> strictness + impurity introduce things like eta expansion actually mattering
21:04:21 <kmc> you can have purity with strictness
21:04:26 <Kaidelong> kmc: that is theoretically true of all languages anyway
21:04:40 <Cale> Strict evaluation makes programs which should run properly end up not terminating
21:04:53 <Kaidelong> kmc: sure, but why would you want that?
21:04:59 <kmc> Kaidelong, are you trolling? ;)
21:05:09 <kmc> asking #haskell why purity is a desirable feature
21:05:17 <Kaidelong> kmc: You misinterpreted
21:05:26 <Kaidelong> why you'd want strictness if you have purity
21:05:29 <kmc> oh
21:05:45 <kmc> for performance
21:06:04 <Kaidelong> but strict doesn't neccessarily mean more performant
21:06:05 <kmc> but i agree that performance isn't important at the beginner level
21:06:09 <kmc> yeah
21:06:23 <Kaidelong> (and in the situations where it does you could make exceptions more easily than exceptions the other way)
21:06:24 <btutt> strictness begets easier to understand runtime  behavior, which you want for beginners
21:06:55 <Kaidelong> btutt: The argument Dijkstra was making was exactly that students shouldn't try to understand runtime behavior of their programs
21:06:59 <kmc> btutt, why not teach people to write correct programs first, then fast programs?
21:07:10 <Kaidelong> which is probably an unorthodox view, to be sure
21:07:15 <kmc> in my experience novice programmers do all kinds of crazy things "for performance" when it's both unnecessary and unhelpful
21:07:37 <kmc> if we wanted beginners to actually understand performance we'd have to teach them about CPU caches and the like
21:07:41 <btutt> i don't mean the fast part, i just mean its easier to understand whats going on. i.e. spoon feed them complicated concepts 
21:08:23 <Kaidelong> but his argument was that operational semantics offers a "false analogy" that people cling onto when computer programs are (in his view) just mathematics
21:08:23 <btutt> i agree that many people make stupid perf changes not based on perf measurements and they are indeed stupid
21:08:46 <kmc> not just not based on evidence, but based on fundamental misunderstandings which are never corrected
21:09:01 <kmc> sometimes things that used to be true 20 years ago and are still taught in school
21:09:14 <Kaidelong> well
21:09:20 <Kaidelong> I shouldn't say just mathematics
21:09:47 <Kaidelong> in the same talk he railed against mathematicians who he claimed couldn't understand that computer programs were formulas
21:09:49 <btutt> Kaidelong: I understand what you're saying, but a math based view of programming isn't going to be the norm for most of the CS population
21:10:00 <kmc> dijkstra's view will never be popular at schools which see themselves as vocational training for coding jobs
21:10:12 <Kaidelong> kmc: I am at one of those, unfortunately
21:10:19 <kmc> they'll teach you Java then C++ because that's what you need for a job, and Java is the easier of the two
21:11:04 <kmc> Kaidelong, my condolences :/
21:11:20 <Kaidelong> I am hoping I will be able to get a better graduate education
21:11:32 <djahandarie> I don't think I'm going to do graduate school
21:11:35 <kmc> i hope they at least let you elect into interesting classes and/or independent projects
21:11:36 <Kaidelong> but even if I do I feel like I'll be at a disadvantage to people who might have better educations
21:11:50 <btutt> I'd love to audit local grad classes. I was bored by the undergrad ones.
21:11:56 <Kaidelong> kmc: Computational Intelligence was pretty interesting and I might go into it in a big way
21:12:14 <Kaidelong> particularly since a lot of the models they use are continuous and I tend to love working with continuous models
21:12:26 <kmc> my school had a pretty theoretical required CS core, but then left you on your own to do whatever courses you liked
21:12:38 <kmc> unfortunately there wasn't much selection, and there's even less now that they lost some profs
21:12:58 <Kaidelong> the CS core here is pretty vocational, and yeah, we have a tiny faculty here who is not very interested in teaching
21:13:18 <Kaidelong> I think I have to take UI design to graduate
21:13:22 <kmc> :/
21:14:03 <btutt> Theory undergrad is all well and good to a point, but traditional undergrad DB classes sucked since they were all theory. Who the hell cares about the distinctions between exact names for all the frick'in normal forms. Normalize by default and denorm when necessary. Seems simple to me. ;)
21:14:48 <Kaidelong> btutt: I prefer going over theory in lectures and being very flexible with implementation in labs
21:14:54 <Kaidelong> I've had a few classes that were like that
21:15:38 <Kaidelong> data structures II, computational intelligence, cryptography, and algorithm analysis
21:15:42 <btutt> Yeah, I had a computer architecture class were we wrote an assembler. I wrote mine using yacc instead of libc calls. Made me hate yacc forever more.
21:16:13 <Kaidelong> unfortunately I now realize that everything I learned in cryptography is basically outdated now
21:16:22 <Kaidelong> and we didn't really go heavy into the mathematical theory
21:16:27 <Kaidelong> just specific algorithms
21:16:32 <kmc> hehe, yacc
21:16:34 <Kaidelong> so I doubt that class will be very useful
21:16:40 <kmc> the bad old days
21:16:58 <roconnor> RSA is not outdated
21:17:13 <djahandarie> My compilers class uses flex/bison
21:17:13 <Kaidelong> roconnor: Elliptic-Curve Diffie-Hellman
21:17:15 <roconnor> I specifically select it for my SSH keys
21:17:21 <kmc> also fundamentals like "what's a stream cypher" and "don't use ECB" are not outdated
21:17:34 <btutt> well i think i used flex/bison but they still sucked.
21:17:40 <djahandarie> Heh
21:17:45 <btutt> Used ANTLR for a Java language extension translator.
21:17:55 <btutt> Predicated LL(k) is where its at. :)
21:18:06 <djahandarie> I haven't taken anything past data structures personally. I need to hurry up. :<
21:18:07 <roconnor> Kaidelong: why should I use that over RSA?
21:18:07 <btutt> much easier to debug as well.
21:18:12 <kmc> i got to use Parsec for most of my languages classes
21:18:19 <kmc> Parsec is not easy to debug, though :/
21:18:30 <djahandarie> Parsec 3 isn't bad
21:18:56 <btutt> IIRC, eliptic curve has a higher complexity to brute force solve? (hope I remembered that right)
21:19:15 <djahandarie> At least if you make sure to mark everything you can with <?>
21:19:51 <kmc> djahandarie, mostly stuff like "where do i need to put 'try'" or "why is my grammar looping forever"
21:20:04 <kmc> i think i'm decent at tracking those down now, but it took a while to learn
21:20:17 <kmc> and yeah, it was Parsec 2
21:20:28 <bss03> IIRC: E-C also has a higher theoretical complexity, it one respect.
21:21:12 <bss03> You can take any RSA problem and turn it into an E-C problem... so if E-C is "solved" (which is almost certainly impossible) RSA become instantly solved.
21:21:26 <bss03> The reverse is not know to be true.
21:21:32 <roconnor> interesting
21:21:39 <roconnor> is this an option for SSH keys?
21:22:04 <roconnor> I thought DH was an online algorithm for key exchange
21:22:24 <bss03> AFAIK, the DSA stuff in OpenSSH is not E-C and that we might have to wait a while for E-C to make it into OpenSSH.
21:22:32 <roconnor> right
21:22:42 <geheimdienst> what would be a nice name for the following function? i was thinking +. because in some languages "." is concatting strings, or +# since in c it's stringification
21:22:44 <geheimdienst> > let x +# y = x ++ show y in "lolcats" +# 42 +# (1,2,3)
21:22:45 <bss03> Patent issues or something?
21:22:45 <lambdabot>   "lolcats42(1,2,3)"
21:22:49 <btutt> DH is the name of a key exchange algorithm
21:22:53 <roconnor> I specifically avoid DSA because one crappy random number generation and you lose your secret key
21:23:17 <djahandarie> geheimdienst, please mappend while you're there ;)
21:23:19 <bss03> I'm still using DSA keys, but I've on the side of recommending RSA keys now.
21:23:20 <roconnor> with RSA, one crappy random number generation and you only lose secrecy for that session
21:23:31 <djahandarie> Erm
21:23:34 <geheimdienst> :t mappend
21:23:35 <lambdabot> forall a. (Monoid a) => a -> a -> a
21:23:36 <djahandarie> Not that it would do anything
21:23:40 <djahandarie> -_-
21:23:57 <geheimdienst> > "lol" `mappend` show "cats"
21:23:58 <lambdabot>   "lol\"cats\""
21:24:05 <geheimdienst> ok, i see what you mean
21:24:14 <bss03> ISTR some DSA implemntations only support 1024 bits because that was the FIPS standard or something, and 1024 bits is not "enough" anymore.
21:24:35 <djahandarie> geheimdienst, no, what I said was a non-suggestion
21:24:43 <geheimdienst> but since "show" is fixed to return a String, i don't think mappend ... er yeah :)
21:36:19 <ddarius> @tell copumpkin If you get this, you're alive.  Congratulations.
21:36:19 <lambdabot> Consider it noted.
21:58:13 <lispy_> ?tell copumpkin if you get this, then they've already gotten to me.  Head to the old warehouse, password "monadic".  We're counting on you.
21:58:14 <lambdabot> Consider it noted.
21:59:14 <lispy_> bss03: well, openssh now supports ECC keys, so soon you can do much better than RSA or DSA
21:59:17 <btutt> heh
22:00:53 <deech> Hi all, does anyone know if I can use the Haskell logo on a t-shirt?
22:01:02 <ddarius> deech: You can.
22:01:09 <deech> ddarius: And sell it?
22:02:08 <ddarius> It's definitely under a permissive license and I'm pretty sure it isn't "copyleft" at all.
22:03:13 <djahandarie> ddarius, is there some reason for copumpkin to not be alive?
22:03:46 <Jafet> (What would you have to do if it was copyleft? Print the FDL on the inside?)
22:03:58 <copumpkin> ohai
22:03:59 <lambdabot> copumpkin: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:04:09 <copumpkin> @messages
22:04:09 <lambdabot> ddarius said 27m 51s ago: If you get this, you're alive. Congratulations.
22:04:09 <lambdabot> lispy_ said 5m 56s ago: if you get this, then they've already gotten to me. Head to the old warehouse, password "monadic". We're counting on you.
22:04:13 <copumpkin> I'm alive!
22:04:19 <Jafet> Are you sure
22:04:23 * copumpkin checks
22:04:31 <glguy> copumpkin: That‘s not what I heard
22:04:43 <copumpkin> yep, the knife wound from the thug who stabbed me on my way home is still bleeding
22:04:47 <copumpkin> I think that means I'm alive, right?
22:05:23 <dankna> you could be a monadic vampire.  I hear they bleed semicolons.
22:05:28 <lispy_> copumpkin: wait, srsly?
22:05:33 <copumpkin> lispy_: lol no
22:05:45 <lispy_> ah, that's good
22:05:47 <copumpkin> @remember you could be a monadic vampire.  I hear they bleed semicolons.
22:05:47 <lambdabot> I will never forget.
22:05:53 <dankna> ha :D
22:06:04 <ddarius> deech: If you find the logo competition pages, it explains the license that the selected logo would be under.  Technically, it is arguably the case that the "simple permissive license" of the wiki applies to the logo as well.
22:06:09 <djahandarie> copumpkin, that would be especially weird if ddarius somehow knew that but wasn't helping you to get treatment
22:06:25 <ddarius> djahandarie: Let the weak perish.
22:06:25 <djahandarie> In fact...
22:06:30 <copumpkin> maybe he was the one who stabbed me!
22:06:40 <ddarius> I do always have a knife on me.
22:06:43 <copumpkin> to see if I was too weak to survive
22:09:26 <Sunhay> anyone here using fedora 14?
22:10:02 <copumpkin> I refuse to use anything before 19
22:10:21 <Sunhay> lol
22:10:22 <glguy> Sunhay, it works best if you just ask the question you had in mind :)
22:11:34 * copumpkin really wants a piece of aerogel
22:11:50 <Sunhay> trying to install a package from hackage but it keeps giving me an error~
22:12:09 <Sunhay> cabal install hakyll
22:12:10 <Sunhay> Resolving dependencies...
22:12:10 <Sunhay> cabal: cannot configure QuickCheck-2.4.0.1. It requires ghc -any
22:12:21 <glguy> OK, I can help with that :)
22:12:43 <Sunhay> ah, cool =D
22:12:52 <glguy> you need the package: ghc-ghc-devel
22:13:26 <ddarius> copumpkin: What would you do with it, though I can completely understand wanting some with no particular purpose in mind.
22:13:36 <copumpkin> no particular purpose in mind :)
22:13:51 <copumpkin> although I'm sure I could think of something fun to do with it once I had it
22:14:29 <Sunhay> ah, k. downloading it now
22:15:54 <Axman6> copumpkin: thinkgeek sell aerogel
22:15:57 <Sunhay> ooh, its started. thanks
22:15:58 <Sunhay> =D
22:16:12 <glguy> You’re welcome.
22:19:25 <copumpkin> preflex: seen edwardk
22:19:25 <preflex>  edwardk was last seen on #haskell 2 days, 13 hours, 25 minutes and 26 seconds ago, saying: xplat: cute
22:20:43 <ddarius> copumpkin: So I looked at our walking path pre-wandering up Mass Ave, and we went in a very inefficient triangle.  We needed to hang a left at Linnaean St.
22:24:27 <copumpkin> oh no
22:25:52 <shachaf> @quote you
22:25:53 <lambdabot> you says: could be a monadic vampire.  I hear they bleed semicolons.
22:26:17 <ddarius> And I am probably wrong about Mass Ave.  It looks like it probably is the same one you were talking about.
22:26:29 <copumpkin> ooh
22:26:29 <djahandarie> lambdabot isn't very good with grammar.
22:26:35 <copumpkin> I'll try walking along it someday and find out
22:26:49 <djahandarie> itsuka.
22:28:35 <copumpkin> djahandarie: :o
22:30:36 <ddarius> よう
22:31:03 <homie> ⊻ ⊽ 
23:09:27 <hpaste> ian_mi pasted "foldr rank 2"  http://hpaste.org/44560
23:09:57 <ian_mi> ^^ FixedList n a is a list of n a's
23:10:59 <ian_mi> I defined a rank 2 polymorphic foldr using these lists which starts with a t Zero a and ends in a t n a
23:11:16 <ian_mi> can anyone figure out how to do the same for foldl?
23:12:58 <ian_mi> I clearly can't do foldl f b (x :< xs) = foldl f (f b x) xs because foldl wants an t Zero a not a t (Next Zero) a
23:13:40 <copumpkin> oh
23:13:43 <copumpkin> I wrote that a while back
23:13:51 <copumpkin> it just takes a newtype
23:14:03 <copumpkin> http://hpaste.org/41453/foldl_on_vec
23:17:21 <ian_mi> copumpkin: I first did as you did without the extra type variable a but then it won't work on :<
23:17:33 <copumpkin> ?
23:17:59 <copumpkin> the t can absorb the type variable
23:18:22 <ian_mi> well I have the n before the a :-/
23:18:32 <copumpkin> yeah, newtypes can flip that stuff temporarily
23:18:42 <copumpkin> you can easily convert what I did on mine to your structure
23:19:05 <ian_mi> oh yeah, I know
23:19:37 <ian_mi> once I read yours that is
23:19:53 <ian_mi> I hadn't thought of using a newtype before
23:27:37 <ian_mi> if you've read http://conal.net/blog/posts/doing-more-with-length-typed-vectors/, he defines bounded numbers (BNats)
23:28:06 <ian_mi> one neat thing you can do with those is type checked indexing
23:28:09 <copumpkin> those are often called Fin
23:28:38 <copumpkin> but yeah
23:28:41 <ian_mi> hmm, I've never heard that before
23:28:41 <copumpkin> it's cool stuff
23:29:07 <copumpkin> over in agda/epigram-land people tend to call them that
23:29:09 <copumpkin> for finite sets
23:31:04 <ian_mi> interesting
23:31:19 <ian_mi> are those better for this type of thing?
23:31:46 <copumpkin> those languages? yeah, definitely, but with all the additional power comes great responsibility ;)
23:32:21 <ian_mi> ha
23:32:32 <ian_mi> the problem is I like haskell too much
23:32:39 <copumpkin> agda looks just like haskell
23:32:51 <copumpkin> but yeah, I switch back and forth between agda and haskell, and just use them for different things
23:33:20 <copumpkin> I recommend it if you enjoy seeing what you can do with funky types
23:33:27 <ian_mi> cool
23:34:01 <ian_mi> I was just going to try Coq actually
23:34:24 <copumpkin> more or less the same, but uglier syntax, more automation, and a more imperative approach to proofs
23:36:05 <Eduard_Munteanu> Isn't Coq more powerful as well? Or is Agda a CoC too?
23:36:17 <copumpkin> it's just different
23:36:44 <copumpkin> agda is martin-lof type theory plus some experimental things
23:37:00 <copumpkin> like universe polymorphism (which I don't think coq has explicitly as such)
23:37:38 <ian_mi> well, I only choose Coq because it was being to covered by several people at the oregon programming languages summer school, but it looks like I've missed the registration deadline anyways
23:37:44 <copumpkin> ah
23:37:56 <copumpkin> there's decent IRC channels for both coq and agda
23:38:02 <copumpkin> epgiram's is a little quiet
23:38:11 <copumpkin> well, they're all quiet, but epigram's is very much so
23:42:28 <copumpkin> ian_mi: does conal mention the very elegant definition of transpose there
23:42:29 <copumpkin> ?
23:42:41 <copumpkin> in that series
23:45:23 <ian_mi> I don't think so
23:45:53 <copumpkin> it's fairly easy to write a Traversable instance for those things
23:46:04 <copumpkin> as well as an Applicative
23:46:11 <copumpkin> @bot
23:46:12 <lambdabot> :)
23:46:25 <ian_mi> I wrote applicative
23:46:32 <copumpkin> > getZipList . Data.Traversable.traverse ZipList $ [[1,2,3],[4,5,6],[7,8,9]]
23:46:33 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
23:46:45 <copumpkin> it's basically sequence on ziplists
23:46:58 <copumpkin> and since your applicative is already a ziplist
23:47:08 <copumpkin> traverse is pretty simple :)
23:47:14 <copumpkin> transpose, I mean
23:47:27 <ian_mi> I wrote one actually
23:48:18 <ian_mi> I'm not sure it is as nice though
23:48:25 <ian_mi> (((<$>) . ind) <$> bnats nat) <*> pure
23:48:53 <ian_mi> nat is the number corresponding the length of the vector
23:49:04 <ian_mi> bnats generates the numbers 0 .. n-1
23:49:04 <copumpkin> ah, I see
23:49:10 <ian_mi> ind is the indexing function
23:50:06 <ian_mi> I had no clue Traversable existed
23:52:34 <copumpkin> :)
23:52:39 <copumpkin> there's a counterpart to it too
23:54:56 <ian_mi> ?
23:56:05 <copumpkin> http://hackage.haskell.org/packages/archive/distributive/0.1.2/doc/html/Data-Distributive.html
23:56:21 <copumpkin> not as many instances for it
