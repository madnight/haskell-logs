00:06:21 <shaleh> tcard: yep, that worked
00:06:36 <shaleh> sorry, had a sigwife there for a few minutes
00:07:01 <lispy_> haah
00:07:23 <lispy_> EMUSTDODISHES
00:16:12 <dankna> @tell Saizan So I did an experiment and modified the program to not actually have modifiable state at all (obviously it doesn't perform its function that way, but just for testing purposes).  It still exhibited that allocation pattern!  What does this mean?
00:16:13 <lambdabot> Consider it noted.
00:19:29 <tcard> shaleh: no worries!
00:19:38 <tcard> shaleh: I am getting a sigwife now...
00:19:47 <tcard> shaleh: good luck figuring out State!
00:19:52 <shaleh> tcard: thanks again, off to sleep
00:19:53 <tcard> shaleh: ^Z
00:35:17 <erus`> how do i cabal build script?
00:36:00 <jeffz> erus`: do you have a .cabal file?
00:36:10 <erus`> no
00:36:15 <erus`> i mean make my own
00:36:37 <jeffz> erus`: copy one you like the look of and modify the fields
00:36:49 <fragamus> @type randomR
00:36:49 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
00:37:17 <jeffz> there seems to be a 'cabal init' command
00:37:43 <jeffz> http://byorgey.wordpress.com/2010/04/15/cabal-init/
00:42:09 <poltak> Anyone know who the youngest ever Haskell programmer is?
00:42:37 <shachaf> poltak: Age is pretty irrelevant.
00:42:59 <shachaf> dibblego's son was writing some Haskell when he was ~5-6, though, I believe.
00:43:33 <poltak> He'd probably be in the running for youngest, right?
01:04:19 <erus`> @hoogle sin
01:04:20 <lambdabot> Prelude sin :: Floating a => a -> a
01:04:20 <lambdabot> Text.Html.BlockTable single :: a -> BlockTable a
01:04:20 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
01:05:16 <erus`> @hoogle pi
01:05:16 <lambdabot> Prelude pi :: Floating a => a
01:05:16 <lambdabot> Data.Fixed type Pico = Fixed E12
01:05:16 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
01:09:27 <mm_freak> poltak: what is a "haskell programmer"?  i'd say only few people use haskell productively
01:09:36 <mm_freak> compared to the size of the community
01:09:49 <poltak> What?! What do most of them use Haskell for?
01:10:00 <mm_freak> education and/or fun
01:10:21 <mm_freak> "few compared to size of community" is not necessarily "few"
01:10:52 <poltak> What do you mean by "education"? Just to learn?
01:11:36 <mm_freak> learn haskell, learn category theory, learn design patterns, learn new ways of thinking, etc.
01:12:05 <poltak> And apply it to Java?
01:12:25 <mm_freak> as far as possible
01:12:58 <mm_freak> java will not be powerful enough for most of what you learn in haskell
01:15:11 <poltak> But you can still do the same with it, can you not? A programming language is a programming language, right?
01:16:23 <silver> it depends what you call "the same"
01:17:01 <Jafet> Or to supplement inferior coreutils
01:17:07 <poltak> But everything you do in Java, C, Haskell, etc could be done on something as primitive as a Turing machine, right?
01:17:19 <poltak> And algorithm can be implemented any way, can it not?
01:17:41 <silver> yes, but "how" is up to language
01:19:05 <poltak> Bah, I should just go back to programming everything using Turing Machines.
01:19:29 <silver> it will be boring
01:19:32 <silver> and slow
01:21:06 <poltak> Nah, I feel heroic when I do it.
01:29:50 <mm_freak> poltak: you can write the same program
01:30:00 <mm_freak> but you can't necessarily use the same design patterns to write it
01:30:13 <mm_freak> or not easily
01:30:20 <poltak> mm_freak: I'm going to make a world of warcraft clone
01:31:10 <mm_freak> and you can write more programs on a PC than on a turing machine
01:31:36 <mm_freak> a turing machine cannot take input from the outside world while running
01:31:53 <poltak> Then I'll alter it
01:32:11 <mm_freak> use lambda calculus instead =)
01:32:29 <mm_freak> with lazy evaluation you don't need to alter the language to have external input
01:33:00 <mm_freak> and it's easier to write programs in lambda calculus anyway
01:34:28 <Jafet1> Lambda calculus isn't webscale
01:34:45 <mm_freak> Jafet1: racket people would disagree
01:35:02 <mm_freak> type "racket web programming" into your favorite search engine
01:35:38 <Jafet> Type "PHP web programming" into yours
01:35:53 <mm_freak> and then?
01:36:33 <mm_freak> PHP is about the worst language you can use for rapid web development…  people just don't realize this
01:36:55 <mm_freak> i find myself much more productive with yesod in haskell than with PHP
01:37:12 <mm_freak> i would also be more productive with continuation-based web programming in racket, but i just prefer haskell over racket
01:38:14 <mm_freak> by now there is even an experimental HTTP framework (not a web framework) for the turing-incomplete agda, called lemmachine
01:38:57 <frerich> I think the only rapid thing about PHP is that it makes your project rapidely approach the next wall.
01:39:33 <mm_freak> right…  you can write the original implementation of your site in PHP at the same pace as in haskell/yesod
01:40:03 <poltak> mm_freak: ah, algorithms teacher mentioned something about lambda calculus... don't know anything about it other then I think it's somehow related to Haskell, no? Sounded interesting either way
01:40:21 <mm_freak> but in PHP you spend 80% of your time debugging, so in the bottom line you are five times more productive with yesod, because you have almost no debugging to do
01:41:18 <mm_freak> poltak: lambda calculus is a formal language just like the turing machine
01:41:45 <mm_freak> poltak: the untyped lambda calculus, a variant of it, is turing-complete, so you can write any program you want
01:42:06 <mm_freak> the typed lambda calculus, on which haskell is based, can be made turing-complete by adding a Y combinator, which is called 'fix' in haskell
01:42:11 <osfameron> ...and even some that you don't want
01:43:09 <poltak> mm_freak: ah bloody hell sounds complicated, but extremely fun. Might have to look this up
01:47:03 <erus`> do i put imports before or after module?
01:47:07 <erus`> like local imports
01:48:10 <erus`> below i take it
01:49:03 <mm_freak> poltak: just think that there are no predefined functions except 'fix', no predefined types, no way to define them either, no 'where' and no 'let'…  that's lambda calculus =)
01:49:09 <mm_freak> haskell reduced to function application only
01:49:18 <mm_freak> and lambda abstractions
01:50:04 <mm_freak> erus`: below…  you should get a fairly descriptive error message otherwise
02:09:14 <erus`> @hoogle loadMatrixf
02:09:14 <lambdabot> No results found
02:10:02 <rtharper>  dcoutts: ping?
02:11:15 <mjrosenb> can anyone think of a container that has implemente Foldable where filter does not make any sense?
02:13:29 <ddarius> If your filter :: Foldable f => (a -> Bool) -> f a -> [a] then it always makes sense, if it is filter :: Foldable f => (a -> Bool) -> f a -> f a then it never makes sense.
02:24:51 <mjrosenb> ddarius: why does it never make sense?
02:25:44 <mjrosenb> i mean, foldable does not specify any way of creating structures/continers, but they *do* exist
02:26:08 <shachaf> mjrosenb: Can you write a filter function with that type?
02:26:57 <mjrosenb> shachaf: i am asking if it were to be included as part of the specification of Foldable, what containers that are currently Foldable could no longer be so.
02:27:14 <erus`> @hoogle newMatrix
02:27:14 <lambdabot> No results found
02:27:33 <erus`> why did they have to bastardize the opengl functions
02:27:51 <erus`> they are the same in every language... but not haskell
02:30:02 <erus`> they should have wrapped them 1:1 and then put all the monad shit in a module ontop
02:30:22 <roconnor> newMatrix :: MatrixComponent c => MatrixOrder -> [c] -> IO (m c)
02:30:43 <roconnor> newMatrix :: (Matrix m, MatrixComponent c) => MatrixOrder -> [c] -> IO (m c)
02:31:15 <erus`> wheres loadMatrixf?
02:33:35 <roconnor> I guess it is (currentMatrix $=)
02:33:45 * roconnor doesn't know openGL nor its bindings
02:35:05 <Janni> Hello. I'm working on a core-to-core pass in GHC and have a little question about how recursion is handled.
02:35:43 <erus`> what a mess
02:36:30 <roconnor> erus`: combining getters and setters into a structure is a mess?
02:36:40 <jeffz> erus`, a mess? you'd rather deal with pointers to C structures and marsh stuff by hand?
02:36:47 <Janni> Apparantly the Bind data-type gives some information about the recursive structure of bindings, like as I assume Let (NonRec f e1) e2 does not bind b in e1
02:37:02 <ddarius> There is an OpenGLRaw package
02:37:06 <erus`> do it like go does: mirror the opengl functions but just use native types
02:37:56 <Janni> My question is about mutual recursion. One can express mutual recursion without having multiple binding on the same level, like this: let f = let g = f in g in f
02:38:18 <roconnor> Janni: let {f = foo g; g = bar f} in
02:38:33 <erus`> there should be a loadMatrixf :: [Float] -> IO ()
02:38:40 <Janni> Now if such an expression (or something more meaningful with the same structure) would occur, would some simplification pass ensure that both f and b occur in the same binding group?
02:38:41 <roconnor> you don't need the { } and ; if you use the 2-D syntax.  Just line up the blocks.
02:38:58 <shachaf> roconnor: I don't think Janni is asking a question about syntax.
02:39:03 <roconnor> oh
02:39:11 <Janni> shachaf: That's right.
02:39:20 <Janni> roconnor: Thanks though.
02:39:45 <fragamus> im writing a genetic algorithm in haskell
02:39:56 <roconnor> erus`: I think you mean loadMatrixF :: (Float,Float,Float,Float,Float,Float,Float,Float,Float,Float,Float,Float,Float,Float,Float,Float) -> IO ()
02:40:08 <Janni> So, I'm wondering if I can make any assumptions on which binder is recursively linked to what other binder.
02:40:23 <fragamus> I need to make two monadic values perform crossover
02:40:54 <fragamus> is it possible to have a monadic function that takes a monadic value as an argument
02:41:21 <Janni> fragamus: If you can look inside your monad everything is possible.
02:41:31 <fragamus> I can
02:41:42 <fragamus> does this violate some kind of monadic law
02:41:45 <shachaf> preflex: seen Cale
02:41:45 <preflex>  Cale was last seen on #haskell 3 hours, 30 minutes and 18 seconds ago, saying: code.haskell.org was down
02:42:07 <Cale> hi
02:42:35 <Janni> fragamus: You have to care about monadic laws only in defining the instance declaration "instance Monad YourMonad"
02:44:13 <Cale> fragamus: why would it?
02:44:25 <Cale> :t (>>)
02:44:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
02:44:43 <fragamus> I dont know, I was worrying about morphism arrows
02:44:54 <Cale> That function takes two monadic values as arguments and produces a monadic result :)
02:45:33 <Cale> :t liftM2
02:45:34 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:45:40 <Cale> ^^ might be useful
02:46:21 <fragamus> ty
02:46:51 <rtharper> @seen dcoutts
02:46:51 <lambdabot> Unknown command, try @list
02:46:51 <preflex>  dcoutts was last seen on #ghc 12 hours, 48 minutes and 38 seconds ago, saying: waern_: ta
02:58:38 <kamilc> hi everyone
02:59:46 <kamilc> can anyone explain to me how can I use Data.List.find with [IO String] ?
03:00:02 <kamilc> I'm an early newbe...
03:00:18 <shachaf> kamilc: I'd suggest reading more about how IO works in general first.
03:00:53 <kamilc> shachaf: I did, but have no idea how to use this >theoretic< knowledge..
03:01:11 <shachaf> Probably what you want is along the lines of do { strings <- sequence myListOfIOStrings; let blah = find foo myList...; ... }
03:01:51 <shachaf> kamilc: Well, more theoretical knowledge would be one solution. :-)
03:02:10 <kamilc> shachaf: I'm sure it would :)
03:02:27 <shachaf> kamilc: I don't really recommend using code like that randomly without understanding how it works to a reasonable degree -- though I suppose if you did that for long enough it *might* help.
03:03:57 <kamilc> the thing is: i really have declared a data type, like so: data Session = Session { field :: String, field2 :: String } deriving (Eq) and I have a [IO Session] and from that list I'd like to choose one be some criteria...
03:04:23 <shachaf> How do you get the [IO Session]?
03:04:30 <shachaf> [IO Session] is the type of a list of IO actions.
03:04:34 <kamilc> so I have sessions <- getSessions and later find (s -> [lambda stuff ] ) sessions
03:04:48 <shachaf> It's different from IO [Session], which is the type of an IO action that produces a list.
03:04:59 <kamilc> shachaf exactly
03:05:08 <shachaf> So there's sequence.
03:05:12 <shachaf> @src sequence
03:05:12 <lambdabot> sequence []     = return []
03:05:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:05:12 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
03:05:15 <shachaf> @ty sequence
03:05:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:05:25 <shachaf> ("m" means "IO" here.)
03:05:42 <ktosiek> :t sequence
03:05:42 <shachaf> @ty sequence :: [IO a] -> IO [a]
03:05:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:05:43 <lambdabot> forall a. [IO a] -> IO [a]
03:05:50 <kamilc> shachaf: yoe're a genius :)
03:06:52 <kamilc> so at firsty - I can define an action that produces a list of sessions from the list of actions
03:07:18 <kamilc> I can get IO [Session] from [IO Session] with forall
03:07:36 <kamilc> and then pure find will work?
03:08:04 * osfameron pimps http://lanyrd.com/2011/geekup-liverpool-may/ all over the shop
03:08:05 <shachaf> Well, it'll work if you execute the IO action, which will produce a list of Sessions.
03:08:26 <shachaf> kamilc: What does forall have to do with any of this?
03:08:49 <mjrosenb> :t forall
03:08:49 <shachaf> forall isn't the name of a function, it's a(n unofficial) keyword.
03:08:50 <lambdabot> Not in scope: `forall'
03:09:03 <mjrosenb> err
03:09:06 <mjrosenb> :t all
03:09:06 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:09:08 <kamilc> oh... thats sequence
03:09:31 <kamilc> shachaf: thank you very much
03:42:44 <dcoutts> http://projects.haskell.org/gtk2hs/
03:42:52 <dcoutts> it's back up! (mostly, I hope)
03:45:18 <rtharper> dcoutts! =)
03:45:30 <dcoutts> rtharper: hia, you were after me?
03:45:41 <rtharper> dcoutts: yes, I emailed you at @well-typed
03:45:42 <rtharper> but
03:45:54 <rtharper> I hae request =)
03:46:00 <dcoutts> aye?
03:49:04 <ClaudiusMaximus> hmm, i thought i had a quad-tree but what i have is more like an abstract pointer to a location in a quad-tree that might exist separately or not - wondering what to call it...
03:58:20 <Cale> ClaudiusMaximus: a point? ;)
03:59:02 <wookydocky123> hello
03:59:23 <wookydocky123> head $ scanr f a b = foldr f a b
03:59:25 <wookydocky123> right?
03:59:41 <wookydocky123> and: tail $ scanl f a b = foldl f a b
03:59:46 <wookydocky123> am I right?
03:59:54 <wookydocky123> @src foldl
03:59:55 <lambdabot> foldl f z []     = z
03:59:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:00:02 <wookydocky123> @src scanl
04:00:02 <lambdabot> scanl f q ls = q : case ls of
04:00:02 <lambdabot>     []   -> []
04:00:02 <lambdabot>     x:xs -> scanl f (f q x) xs
04:02:18 <wookydocky123> anyone please?
04:03:45 <ClaudiusMaximus> Cale: it's essentially (Int, Integer, Integer) - how many levels deep and how far from the origin counted in units at that level - which i guess is a "point" in some space - but i also have operations like "give me all the quads that are needed to completely fill this rectangle at this level"
04:04:03 <Botje> wookydocky123: i think you want last, not tail
04:04:13 <Botje> > scanr (+) 0 [1..5]
04:04:14 <lambdabot>   [15,14,12,9,5,0]
04:04:21 <mm_freak> wookydocky123: i can confirm that the scanl equation is true up to same semantics
04:04:29 <mm_freak> but with last instead of tail
04:05:21 <mm_freak> > foldr (-) 2 [-2 .. 5]
04:05:21 <wookydocky123> eee, ok I see it
04:05:22 <lambdabot>   -2
04:05:28 <mm_freak> > scanr (-) 2 [-2 .. 5]
04:05:29 <lambdabot>   [-2,0,-1,1,0,2,1,3,2]
04:05:35 <ClaudiusMaximus> @check \f a b -> head (scanr f a b) == foldr f (a::Int) (b::Int))
04:05:36 <lambdabot>  Unbalanced parentheses
04:05:49 <wookydocky123> what about foldr?
04:05:53 <wookydocky123> it looks ok
04:05:57 <wookydocky123> but i'm not sure
04:06:02 <Cale> > scanr f z [1,2,3]
04:06:03 <lambdabot>   [f 1 (f 2 (f 3 z)),f 2 (f 3 z),f 3 z,z]
04:06:06 <Cale> yes
04:06:44 <wookydocky123> ok, thanks a lot :)
04:06:49 <Cale> http://cale.yi.org/share/Folds.svg
04:07:06 <Cale> ^^ diagrams of what some folds and scans do :)
04:09:00 <kutsurak> Thanks Cale. That's really helpful
04:13:41 * hackagebot NanoProlog 0.2 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.2 (JurrienStutterheim)
04:14:51 <norm2782> hmm.. my documentation doesn't show up on hackagedb
04:14:57 <norm2782> how can I enable that?
04:15:58 <aavogt> norm2782: wait a bit and the documentation will be generated
04:16:07 <aavogt> as in a couple hours
04:16:21 <norm2782> ah excellent
04:16:24 <norm2782> did not know that
04:16:26 <norm2782> thanks
04:22:13 <parcs> Cale: if you can, you should configure your web server to compress svg images. that particular one can be compressed down to 6% of its original size. just a thought :)
04:25:40 <roconnor> go xml
04:35:51 <marcot> Hi.  I need to read an Int from a ByteString.Char8 which has a length of two.  I'm using read [head bs, head $ tail bs].  Is there a faster alternative?
04:36:54 <merijn> marcot: take?
04:36:57 <merijn> :t take
04:36:58 <lambdabot> forall a. Int -> [a] -> [a]
04:37:03 <parcs> bytestring-nums package
04:37:12 <merijn> > take 2 "foo"
04:37:13 <lambdabot>   "fo"
04:38:28 <marcot> (fromEnum (head bs) - fromEnum '0') * 10 + fromEnum (head $ tail bs) was faster.
04:38:45 <marcot> parcs: I doubt bytestring-nums will be faster, because it is generic, but I'll try anyway, thanks.
04:40:29 <poltak> How to do for loop in Haskell?
04:41:39 <Martty_> list comprehension is pretty close
04:41:42 <poltak> (or equivilent)
04:41:52 <poltak> loop through list?
04:41:59 <Martty_> yah
04:42:07 <poltak> link list?
04:42:13 <Martty_> any collection
04:42:59 <poltak> can give example?
04:43:52 <luite> Cale: not nearly as pretty, but more interactive :p http://jabberwock.xs4all.nl/wiki/Folds
04:44:56 <poltak> luite: not really relate to it, I think
04:45:06 <kutsurak> poltak: a list in haskell looks like this [1,2,3,4,5]
04:45:15 <poltak> kutsurak: etc
04:45:41 <kutsurak> a list comprehension could be something like
04:45:59 <kutsurak> > [2*x | x <- [1,2,3,4,5]]
04:46:00 <lambdabot>   [2,4,6,8,10]
04:46:28 <poltak> Oh yes yes I already know this
04:46:58 <sztupi> poltak: what exactly do you want to do inside the loop?
04:47:35 <poltak> sztupi: not really your concern mate
04:51:00 <merijn> poltak: People aren't really motivated to solve your problems if you don't want to tell what you're trying to do in the first place...
04:51:36 <o-_-o> byorgey: thanks for the patch :-)
04:51:51 <poltak> merjin: no problem, mate. Just want to know equivelent of for loop from Java (very new at Haskell)
04:52:37 <merijn> There is no such thing as a for loop in haskell
04:52:41 <dmedvinsky> poltak: there is no such thing as loop in Haskell
04:52:44 <rexim> I think if you need a for loop, your mind isn't ready for Haskell yet.
04:52:50 <kutsurak> poltak: From my understanding there is nothing equivalent to a loop in Haskell. You use recursion, comprehensions and folds to do what you want. Of course I could be wrong since I am a newbie as well
04:53:01 <o-_-o> map f [0...10]
04:53:05 <merijn> poltak: The correct way to loop depends on what you are doing, hence why people want to know what you are trying to do...
04:53:27 <o-_-o> where f is what is in { } in the for loop
04:53:37 <poltak> looping is basic function in algorithm
04:53:43 <poltak> iteration
04:53:55 <poltak> I'm sure Haskell has iteration
04:54:00 <o-_-o> of course this is not strictly correct, but it may save you for now...
04:54:37 <merijn> poltak: Iteration in haskell is done using (as mentioned earlier) either recursion, comprehensions or folds
04:55:00 <poltak> recursion in algorithm is different to iterative algorithm
04:55:17 <poltak> fold is like 0-_-0 is saying?
04:55:26 <poltak> map f[blah]?
04:55:48 <merijn> poltak: You can easily implement (tail)-recursion as a loop in ASM
04:55:55 <merijn> poltak: Out of interest, what are you reading to pick up Haskell?
04:56:11 <poltak> But it still does not equal to iteration
04:56:15 <poltak> But I understand I think
04:56:31 <poltak> I am reading two book recommend to me Learn you an Haskell and real world haskell
04:56:45 <poltak> and just to trying myself making basic function
04:57:16 <o-_-o> poltak: fold is not map
04:57:19 <merijn> Ah, yeah Learn You a Haskell is excellent
04:57:25 <merijn> poltak: "map f foo" is equivalent to "for (int i = 0; i < length(foo); i++) { f(foo[i]);}" in C/Java style things
04:57:51 <poltak> Ah, I see. How come you say "it won't get you far, boy" to me o-_-o?
04:58:03 <poltak> Recursion use more in Haskell?
04:58:03 <o-_-o> poltak: I said that ?
04:58:16 <merijn> poltak: Recursion is used A LOT in haskell
04:58:18 <poltak> Oh sorry, I mean similar to that
04:58:28 <merijn> poltak: Although not always "manually"
04:58:35 <aavogt> shouldn't the body be:       foo[i] = f(foo[i]);
04:58:43 <o-_-o> poltak: Yeah, because you'll need to start thinking in haskell way
04:58:46 <merijn> aavogt: I suppose
04:59:05 <poltak> Are you say that Haskell way involves what? Recursion over iteration?
04:59:21 <luite> poltak: that page shows the same things as Cales diagrams, only implemented with data constructors instead of functions
04:59:31 <o-_-o> poltak: no :-)
04:59:49 <poltak> what is the different in ways of Haskell way?
04:59:57 <luite> poltak: but there's some ugliness involved that makes them less clear than they should be
05:00:30 <migimunz> politik, I can recommend this as a beginner, learned a lot from it : http://learnyouahaskell.com/
05:00:42 <poltak> That's what I said I'm read currently
05:00:42 <merijn> migimunz: He's already reading LYAH :)
05:00:48 <merijn> poltak: The most important iteration tools in Haskell are map, fold(r/l) and explicit recursion.
05:00:50 <o-_-o> poltak: haskell is functional, so you need to start thinking functionally
05:01:09 <poltak> Yep, this is what I am see so far
05:01:14 <poltak> It's very interesting
05:02:20 <merijn> poltak: At first it takes a bit of getting used to thinking differently, which means it can seem frustratingly hard to do things you think are simple in languages you know
05:02:30 <poltak> Like lambda calculus yes?
05:02:33 <o-_-o> poltak: haskell is more than recursion and folds
05:03:07 <zmv> poltak: lambda calculus is for crazy people, like Haskellites ;)
05:03:25 <poltak> zmv: I like it!
05:03:41 <Eduard_Munteanu> Not really that, but it's pure so you have to do things differently.
05:03:47 <o-_-o> poltak: it is not oh, no loops only recursion, you'll need to spend time learning it and then you'll know how to write programs in a functional language
05:03:49 <hpc> o-_-o: it's also corecursion and scans? :P
05:03:57 <luite> in practice, you probably won't need to think about lambda calculus very often, but you'll need to make some mental model about how things in haskell are evaluated
05:03:58 <merijn> hpc: And fancy words!
05:04:01 <hpc> :D
05:04:10 <zmv> poltak: *everybody* likes lambda calculus, except the people who dislike it :P
05:04:16 <o-_-o> hpc: I have no idea what you are talking about...
05:04:28 <merijn> hpc: Like "zygohistomorphic prepromorphism "
05:04:44 <poltak> zmv: hahaha, if I was brother of you I would buy a everything for you
05:05:08 <o-_-o> merijn: if I didn't know it already, it seems made up
05:05:14 <zmv> poltak: hahahaha
05:05:30 <merijn> I should become a Church's Witness. "Have you accepted our lord and saviour the Untyped Lambda Calculus into your life?"
05:06:24 <poltak> Alonzo Church's witness haha, I like it! Not just the Vatican Church?
05:06:47 <Eduard_Munteanu> You wish we had happy-looking flyers like they have!
05:07:04 <poltak> But yes, Haskell seems very hard but very interest to me. I am look forward to finish my exams and have some time to read more on this
05:07:21 <sipa> Church and he earthly representative, His Spicyness Curry
05:07:26 <sipa> *his
05:07:31 <Eduard_Munteanu> poltak: how did you find it? School?
05:07:41 <Eduard_Munteanu> *it == Haskell
05:07:42 <zmv> lolschool
05:07:52 <zmv> in *my* school, they teach us C
05:07:53 <zmv> ):
05:07:58 <Eduard_Munteanu> Well there are a few universities teaching Haskell.
05:08:16 <poltak> My algorithm teacher is tell me "don't learn Java" if you want stimulation look at Haskell
05:08:18 <Eduard_Munteanu> And as I recently learned, Agda *gasp*
05:08:25 <poltak> Because they teach me Java
05:08:29 <zmv> hahaha
05:08:31 <Eduard_Munteanu> Smart dude.
05:08:36 <poltak> Woman
05:08:40 <erus`> at my college they taught us how to make a calculator in VB. I have allready written my own raytracers and software rasterizers in C++
05:09:00 <Eduard_Munteanu> Ah.
05:09:14 <zmv> hahahaha
05:09:34 <merijn> poltak: Your algorithm teacher is smart
05:09:35 <poltak> They teach Java to me and I find it very fun. But I am think by looking to Haskell much more interesting to me
05:09:48 <zmv> Java? Fun? :P
05:09:57 <merijn> poltak: I have learned more from hanging around in #haskell for a year then 4 years of university :p
05:10:19 <poltak> I am fairly new to programming. I am sorry if Java sound very noob, but is just what I must learn this semester
05:10:24 <o-_-o> merijn: :-)
05:10:25 <Eduard_Munteanu> Anyway, no matter how you look at it, learning Java after some other regular programming language is definitely less intriguing than Haskell.
05:10:36 <poltak> merjin: I can see what you are say from this statement ;P
05:10:47 <zmv> merijn: s/then/than/ \end{grammarNazi}
05:11:09 <poltak> Some teacher at University make me very frustrated... I do not understand the method of teach to me
05:11:13 <merijn> zmv: then/than and to/too are the bane of my English :(
05:11:22 <poltak> But algorithms is stimulation to me
05:11:30 <erus`> poltak: is a troll
05:11:37 <zmv> hahaha
05:11:41 <Eduard_Munteanu> Fortunately, when it comes to programming languages, there's a lot of online material to pick from.
05:11:57 <poltak> I've found this with Haskell
05:12:08 <poltak> Especially big community to support
05:12:56 <Eduard_Munteanu> It's mystery to me how #haskell is such a populated channel.
05:13:17 <zmv> poltak: I think you probably meant "Especially big community support".
05:13:20 <erus`> I used to follow haskell for ages before i started learning it
05:13:26 <erus`> because i liked the idea
05:13:33 <erus`> I bet hundreds do that
05:13:46 <djahandarie> Eduard_Munteanu, it isn't a mystery to me. Try asking for help in an other big channel on Freenode.
05:13:49 <poltak> Eduard_Munteanu: I too think of this: I never hear of Haskell before my teacher telling me. Very surprise to me
05:13:58 <parcs> erus`: yeah, just look at the size of this channel
05:14:34 <Eduard_Munteanu> But then again it's more like #(haskell + cs + whatever existential questions bug some PhDs) :)
05:14:49 <zmv> hahaha, more than double that of #lisp
05:15:09 <poltak> A question to all: Was learning of Haskell particulary hard from imperitive? Pick up fast?
05:15:15 <Eduard_Munteanu> djahandarie: well yes, it's friendlier than other channels.
05:15:29 <poltak> And was it worth time it take?
05:15:32 <merijn> poltak: The first two attempts were very hard for me, the third time it finally clicked
05:15:43 <poltak> attempts?
05:15:44 <Eduard_Munteanu> shapr++
05:15:58 <Eduard_Munteanu> (If I haven't done that already.)
05:16:00 <merijn> poltak: And it was definitely worth the time, I'm a much better C programmer now that I know Haskell :p
05:16:19 <merijn> poltak: I started learning several times, but never got anywhere until my third try ;)
05:16:22 <erus`> poltak: it took me ages to 'get' haskell and I still have alot to learn
05:16:31 <poltak> merjin: I thought Haskell make us worse imperitive programmer :P (that what I read many times on internet)
05:16:41 <Eduard_Munteanu> Heh.
05:16:58 <migimunz> poltak, not at all. if anything, it makes you better at programming in general
05:17:11 <Eduard_Munteanu> Well it can make some programmers become depressed when they go to their real jobs :)
05:17:27 <merijn> I don't think so, I think you should learn as many different programming styles as possible. Functional, OO, dynamic, statically typed, etc.
05:17:42 <poltak> And to ones who have good control of Haskell: is it of usefull to day-to-day life?/do you actually use of Haskell?
05:17:59 <osfameron> poltak: I've never heard that?  (haskell making you "worse" at imperative programming)
05:18:27 <poltak> osama: when I first look on internet for haskell many thread of forum say this
05:18:30 <Eduard_Munteanu> I did some of my assignments in Haskell (without being asked to specifically). I think it helped.
05:18:39 <Axman6> being worse at imperative programming isn't necessarilly a bad thing imo...
05:18:39 <Zao> poltak: Understanding another paradigm tends to help your understanding of your existing paradigms.
05:19:08 <Eduard_Munteanu> Then it's just that other thing: it's interesting in the day-to-day life :)
05:19:11 <poltak> Axman6: but what is so bad of imperitive? Most thing we use (OS, apps etc) make of imperitive languages, no?
05:19:17 <Zao> poltak: Knowing FP helped my understanding of C++ template-meta-programming.
05:19:27 <Axman6> Zao: yeah I've found a lot of my C tends to be quite functional, and the code oftens ends up a lot smaller
05:19:39 <Eduard_Munteanu> But anyway I found it useful in quite a lot of scenarios.
05:19:42 <migimunz> Zao same here
05:19:45 <Axman6> poltak: yes, but that doesn't make imperative programming a good thing
05:19:59 <Axman6> it makes it the thing they had at the time
05:20:08 <migimunz> Axman6, not really a bad thing either. It's a way of programming, some people prefer it
05:20:16 <Eduard_Munteanu> (I wonder if there's an extension of that; i.e. whether Agda makes Haskell programmers feel depressed :D)
05:20:17 <Zao> "everything is about data, and functions just massage it into the shape you want"
05:20:20 <poltak> Axman6: so is like a change you support to make imperitive less of mainstream?
05:20:22 <Axman6> sure, i love programming in C
05:20:45 <osfameron> poltak: a) it's not funny to call me osama, and b) it doesn't highlight my nick
05:21:04 <migimunz> heh
05:21:05 <poltak> osama: I think it is very funny
05:21:11 <osfameron>  /ignore poltak
05:21:25 <Axman6> poltak: i would. I'm quite interested in parallel programming, and functional programming seems to lend itself better to parallel programming
05:21:27 <merijn> Axman6: Have you looked at Go? I started learning it recently and it's like they changed all the tiny warts C had and made it what I always wanted C to be :>
05:21:40 <osfameron> I gave him the benefit of the doubt yesterday, after trolling, but hey ho
05:21:44 <Axman6> i have looked at go. it's not particulatly interesting
05:21:54 <Axman6> the one feature i love from go is the defere statement
05:22:00 <erus`> merijn: lack of inheritance is a pain though
05:22:01 <Axman6> defer*?
05:22:11 <merijn> Lack of inheritance is a feature!
05:22:16 <poltak> Anyway thank you for answer my questions all :) very interest to me. Anyway I must finish my assignment of Java... too much chat :P look forward to learn some more of Haskell
05:22:33 <Axman6> poltak: what's the assignment?
05:22:39 <migimunz> Axman6, you seem very anti-procedural, why so?
05:22:46 <Axman6> i
05:22:46 <merijn> I'm glad they don't support it, not all that useful when you have structural subtyping anyway
05:22:49 <silver> lets turn to haskell compiler
05:23:06 <Axman6> I'm not anti-procedural, but i don't think it's the best way to start programming
05:23:07 <Zao> poltak: It tends to help interactions if you have a somewhat professional behaviour when encountering a channel of unknown disposition.
05:23:21 <merijn> Axman6: Do you mean its not interesting in the sense of "it does nothing new" or not interesting in the "it's not a nice language to work in" sense?
05:23:22 <poltak> Axman6: make a game using 2d array where player must shoot random placed target =.=
05:23:34 <Axman6> merijn: more the former
05:23:58 <Axman6> poltak: ah ok. i was wondering if you were one of my students. but you're not =)
05:24:10 <poltak> You are of what university?
05:24:18 <erus`> i wanna go to university
05:24:19 <Axman6> i tutor at ANU
05:24:34 <erus`> which countries fund higher education?
05:24:46 <erus`> its like £9k a year in UK now
05:24:48 <merijn> Axman6: Oh, I'll agree with you there. But then I don't think it ever intended to be (or tried/claimed to be) new and interesting, it just wants to be C, but better. And I think they might have nailed that goal
05:24:54 <ben> EUR200 a year in germany
05:25:01 <ben> (varies)
05:25:08 <poltak> Oh, very well :) I'm first year at Monash at moment, but yes, fun fun
05:25:14 <Axman6> merijn: i do to. it just doesn't interest me much.
05:25:56 <migimunz> ben, ~ EUR200 a year?
05:26:04 <migimunz> not missing a zero or two there?
05:26:19 <Eduard_Munteanu> Well I don't think you get to be a better C unless you can do embedded and system programming.
05:26:21 <erus`> merijn: do you use go lots? if yes, you should check out go-gb on github
05:26:34 <Eduard_Munteanu> Otherwise there's a whole selection of programming languages out there.
05:26:54 <ben> migimunz: For me, no. It is EUR1000/year in some states but that does not apply universally.
05:27:46 <merijn> erus`: Only just started to learn it, but if I'd have to select a "program for money" language it's definitely a contender (since I don't see so many job openings for newbie Haskell programmers :p)
05:28:13 <erus`> I sugest you learn C# then
05:28:21 <osfameron> are there many Go jobs?
05:28:29 <erus`> no
05:28:33 <osfameron> Scala looks quite interesting too
05:28:35 <zmv> there's also Limbo.
05:28:39 <migimunz> C# is an amazing language
05:28:40 <merijn> osfameron: No, but more then there are Haskell jobs ;)
05:28:41 <Eduard_Munteanu> Haskell got some traction with some companies.
05:28:53 <Axman6> actually, i reckon Go would be a good language for new startups
05:29:10 <Eduard_Munteanu> Depending on the job, you can probably get to solve problems using Haskell.
05:29:26 <merijn> I saw some dudes from Utrecht created a startup using Haskell, wonder if they are looking for people :p
05:37:20 <rostayob> @pl \acc x -> acc + sqrt x
05:37:20 <lambdabot> (. sqrt) . (+)
05:46:05 <alexbagel> is there a more efficient "nub" that works on a sorted list?
05:47:09 <sipa> @src nub
05:47:09 <lambdabot> nub = nubBy (==)
05:47:12 <sipa> @src nubBy
05:47:12 <lambdabot> nubBy eq []             =  []
05:47:12 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:47:42 <alexbagel> @src uniq
05:47:42 <lambdabot> Source not found. Are you on drugs?
05:47:52 <alexbagel> woah harsh
05:48:17 <alexbagel> i was after something like the unix uniq command, in case it already exists
05:48:21 <DevHC> > map fst . group $ [1,1,1,2,3,3,4,5,5,6,6,6,7]
05:48:21 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[a1]'
05:48:36 <DevHC> > map head . group $ [1,1,1,2,3,3,4,5,5,6,6,6,7]
05:48:38 <lambdabot>   [1,2,3,4,5,6,7]
05:48:47 <blackdog> alexbagel: lambdabot's the only one who's allowed to be cruel in here
05:49:09 <DevHC> lambdabot is a troll.
05:49:13 <hpc> :t nub
05:49:14 <lambdabot> forall a. (Eq a) => [a] -> [a]
05:49:19 <DevHC> > group [1,5,3,1,5,6,3]
05:49:21 <lambdabot>   [[1],[5],[3],[1],[5],[6],[3]]
05:49:22 <sipa> @vixen are you a troll?
05:49:22 <lambdabot> yes, i am
05:49:26 <sipa> there you go
05:49:30 <alexbagel> that looks neat enough, cheers
05:49:58 <DevHC> so basically, alexbagel, (map head . group) is a nub on sorted lists
05:50:54 <Favonia> @src group
05:50:54 <lambdabot> group = groupBy (==)
05:50:59 <Favonia> @src groupBy
05:50:59 <lambdabot> groupBy _  []       =  []
05:50:59 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:50:59 <lambdabot>     where (ys,zs) = span (eq x) xs
05:51:05 <alexbagel> *nods*, like the unix uniq command, i just need to squish consecutive elements
05:51:25 <Favonia> @spanBy
05:51:26 <lambdabot> Unknown command, try @list
05:51:32 <Favonia> @src spanBy
05:51:32 <lambdabot> Source not found. :(
05:51:36 <Favonia> @src span
05:51:36 <lambdabot> span _ xs@[]                     =  (xs, xs)
05:51:36 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
05:51:36 <lambdabot>                   | otherwise    =  ([],xs)
05:51:43 <erus`> > x = y where y = x
05:51:44 <lambdabot>   <no location info>: parse error on input `='
05:52:04 <DevHC> > cycle 'F' ++ cycle 'U'
05:52:05 <lambdabot>   Couldn't match expected type `[a]'
05:52:05 <lambdabot>         against inferred type `GHC.Types...
05:52:17 <DevHC> > repeat 'F' ++ repeat 'U'
05:52:18 <lambdabot>   "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...
05:52:23 <DevHC> :D
05:52:24 <wto> lol
05:52:25 <zmv> lol
05:53:32 <ClaudiusMaximus> anyone want to look at http://hpaste.org/46996/tilings and tell me if it looks like a reasonable API for substitution tilings?  eg, regular quad trees and more exotic ones like http://tilings.math.uni-bielefeld.de/substitution_rules/ammann_a3
05:56:02 <Favonia> let elimAdj [] = []; elimAdj (x:y:xs) | x==y = elimAdj (x:xs); elimAdj (x:xs) = x:(elimAdj xs) in elimAdj [1,1,2,3,3,3,4,4,4]
05:56:10 <Favonia> @let elimAdj [] = []; elimAdj (x:y:xs) | x==y = elimAdj (x:xs); elimAdj (x:xs) = x:(elimAdj xs) in elimAdj [1,1,2,3,3,3,4,4,4]
05:56:11 <lambdabot>   Parse error: in
05:56:19 <Favonia> @let elimAdj [] = []; elimAdj (x:y:xs) | x==y = elimAdj (x:xs); elimAdj (x:xs) = x : (elimAdj xs) in elimAdj [1,1,2,3,3,3,4,4,4]
05:56:20 <lambdabot>   Parse error: in
05:56:33 <ClaudiusMaximus> i think you want >
05:56:41 <Favonia> > let elimAdj [] = []; elimAdj (x:y:xs) | x==y = elimAdj (x:xs); elimAdj (x:xs) = x : (elimAdj xs) in elimAdj [1,1,2,3,3,3,4,4,4]
05:56:41 <lambdabot>   [1,2,3,4]
05:56:55 <Favonia> ClaudiusMaximus: yeah! thank you :)
05:57:35 <DevHC> > let elimAdj = map head . group in elimAdj [1,1,2,3,3,3,4,4,4]
05:57:36 <lambdabot>   [1,2,3,4]
05:58:12 <byorgey> ClaudiusMaximus: neat!
05:58:48 <byorgey> ClaudiusMaximus: and you're going to write a function to convert a tiling into a diagram (http://projects.haskell.org/diagrams), right? ;)
05:59:27 <Favonia> DevHC: hmm... maybe alexbagel wanted a more efficient version for sorted list?
05:59:51 <DevHC> how much more efficient than (map head . group) can u get?
06:00:06 <Favonia> DevHC: groupBy uses span
06:00:15 <Favonia> @src groupBy
06:00:15 <lambdabot> groupBy _  []       =  []
06:00:15 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
06:00:15 <lambdabot>     where (ys,zs) = span (eq x) xs
06:00:21 <DevHC> and?
06:00:39 <Favonia> DevHC: in total it might take n^2 time?
06:00:45 <DevHC> no
06:00:53 <ClaudiusMaximus> byorgey: i did think of graphical output, i'm mostly intending to use it for multi-resolution bitmaps (a bit like google maps i suppose)
06:01:25 <DevHC> span (==1) [1,1,1,2,5,1,5,1,1,1]
06:01:27 <DevHC> > span (==1) [1,1,1,2,5,1,5,1,1,1]
06:01:28 <lambdabot>   ([1,1,1],[2,5,1,5,1,1,1])
06:01:42 <luite> ClaudiusMaximus: use diagrams to output svg with some javascripts to request a higher detail version of some part and you're set!
06:01:50 <DevHC> > span (==2) [5,1,5,1,1,1]
06:01:52 <lambdabot>   ([],[5,1,5,1,1,1])
06:01:59 <erus`> any opengl users in here?
06:02:04 <DevHC> etc.
06:02:08 <ClaudiusMaximus> byorgey: i already have the quad tree tiling stuff implemented for that side of things (unreleased so far), but i remembered i had implemented the other one i linked in another project some time ago
06:02:12 <erus`> im having trouble setting the current model view matrix
06:02:15 <Favonia> DevHC: span might take linear time in the worst case
06:02:16 <ClaudiusMaximus> so i thought i'd generalize it
06:02:48 <DevHC> Favonia: in which case the whole list will be consumed, and then we're done with all the spanning
06:02:57 * hackagebot syntactic 0.3 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.3 (EmilAxelsson)
06:03:56 <migimunz> erus` elaborate on that
06:04:01 <Favonia> DevHC: in the worst case groupBy needs n span on strings of length 1,2,3...n, and span needs i comparison for string of length i. in total it is n^2. did I miss anything?
06:04:04 <migimunz> what kind of trouble?
06:04:05 <ClaudiusMaximus> the fun part comes with the irrational ratios - i very vaguely remember something from uni days about fields with square roots and stuff...  need to revise that a bit
06:04:17 <erus`> im C i would do loadMatrixf()
06:04:32 <migimunz> oh, yeah that's what I was gunna say :S
06:04:40 <migimunz> I only have C and java experience with ogl
06:04:46 <migimunz> though I could help tho, sorry :<
06:04:50 <erus`> well i would glPush(); loadMatrixf(); drawMyStuff(); glPop();
06:04:52 <luite> ClaudiusMaximus: algebraic field extensions?
06:05:08 <erus`> migimunz: thats how you would do it in java too
06:05:17 <ClaudiusMaximus> luite: possibly, i last thought about it ~10 years ago...
06:05:30 <luite> ClaudiusMaximus: hmm, I don't know about connections with tilings though
06:06:10 <DevHC> Favonia: yes, u missed that if span runs for k units of time, then span will consume approx. k amount of elements from the list, the next span will run on the remaining (n-k) elements. so groupBy is linear time, even though particular uses of span may take 1 to n long to compute.
06:06:32 <mun> is quantification over sets an example of quantification over predicates?
06:06:52 <ClaudiusMaximus> luite: well, some of the tiles have irrational lengths, quite a few based on golden ratio i think
06:07:40 <DevHC> Favonia: span does NOT need i comparisons for a string of length i, it needs AT MOST i comparisons (span bails out at the first false element)
06:07:48 <luite> ClaudiusMaximus: anyway you can think of an algebraic field extension of the rationals Q as a finite dimensional vector space over Q, for example in Q[sqrt(2)], all elements are of the form a + b sqrt(2), with a,b in Q
06:07:49 <ClaudiusMaximus> luite: and i'd quite like not to have to use Floating point
06:08:13 <ClaudiusMaximus> luite: cool, i think that's what i need - is there a package for that?
06:08:37 <luite> hmm, don't know
06:09:29 <Favonia> DevHC: sorry I don't see why span runs for k units of time, then span will consume approx. k amount of elements. how about span (==n) [1..n] ?
06:09:35 <byorgey> it wouldn't be hard to make
06:09:55 <Favonia> DevHC: span needs to go through the whole list
06:10:07 <Favonia> DevHC: in order to find that element
06:10:07 <DevHC> yes it does, in that case
06:10:16 <DevHC> no
06:10:26 <Favonia> DevHC: ?
06:10:28 <DevHC> > span (==n) [1..1000]
06:10:29 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
06:10:38 <DevHC> span bails out at the first false element
06:10:55 <Favonia> > n
06:10:56 <lambdabot>   n
06:11:36 <DevHC> ffs
06:11:44 <DevHC> > span (==1000) [1..1000]
06:11:45 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
06:12:02 <ClaudiusMaximus> byorgey: well, there might be more than one sqrt in there? - would Q[sqrt(2),sqrt(3)] be something like a + b*sqrt(2) + c*sqrt(3) + d *sqrt(2)*sqrt(3)   ?
06:12:02 <erus`> why did they not include loadMatrixf in the fucking OpenGL bindings
06:12:09 <DevHC> let mySpan pred list == (takeWhile pred list, dropWhile pred list) in mySpan (==1000) [1..1000]
06:12:11 <DevHC> > let mySpan pred list == (takeWhile pred list, dropWhile pred list) in mySpan (==1000) [1..1000]
06:12:12 <lambdabot>   <no location info>: parse error on input `in'
06:12:19 <DevHC> > let mySpan pred list = (takeWhile pred list, dropWhile pred list) in mySpan (==1000) [1..1000]
06:12:21 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
06:12:23 <erus`> it blows my mind
06:12:39 <ClaudiusMaximus> erus`: it's obfuscated
06:12:41 <erus`> every other function is
06:12:49 <erus`> there
06:12:56 <ClaudiusMaximus> matrix ModelView $= (some matrix)
06:13:01 <ClaudiusMaximus> or something like it
06:13:17 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/OpenGL/latest/doc/html/Graphics-Rendering-OpenGL-GL-CoordTrans.html#v:matrix
06:13:34 <ion> http://stackoverflow.com/questions/6108335/haskell-loadmatrixf
06:13:50 <erus`> that was me
06:14:07 <erus`> his code looks like it would work but doesnt compile
06:15:01 <byorgey> ClaudiusMaximus: yes, but you only need to be able to deal with one extension I think
06:15:04 <luite> ClaudiusMaximus: yes, and cube roots will give you higher dimensions
06:15:23 <byorgey> ClaudiusMaximus: since Q[sqrt(2),sqrt(3)] = (Q[sqrt(2)])[sqrt(3)]
06:15:38 <ClaudiusMaximus> ahh cool
06:15:40 <erus`> i dont know what a StateVar is, i dont know what the monadic operators do
06:15:40 <byorgey> i.e. you just extend it twice
06:15:46 <ClaudiusMaximus> :)
06:16:34 <byorgey> o-_-o: http://hpaste.org/46998/converting_a_diagram_to_a_cair
06:16:36 <Favonia> DevHC: I think I understand what your talking about. hmm since the whole result must be evaluated in the end, we may assume a strict computation model for an easier analysis
06:16:48 <byorgey> o-_-o: untested but hopefully this gets you started in the right direction
06:17:05 <Favonia> DevHC: my analysis should work for strict computation
06:17:22 <byorgey> o-_-o: note this only works with the darcs version of diagrams-cairo at the moment, until I make a new release
06:17:25 <ClaudiusMaximus> erus`: the library is too generalized, there is a class Matrix with one instance GLmatrix - so add a type signature (:: GLmatrix GLfloat) ors similar
06:18:56 <ClaudiusMaximus> maybe not too generalized, but it's a bit confusing...
06:20:00 <erus`> Warning: In the use of `currentMatrix' Deprecated: "use `matrix' instead"
06:20:02 <luite> byorgey: simplification might be an issue, you have sqrt(6) in that field, but if you later manually extend it then it might be inconsistent if you're not careful
06:20:15 <Favonia> erus`: for your previous comment about inheritance, I think OO interfaces can be easily simulated by type classes :)
06:21:06 <DevHC> Favonia: i have no idea what u're talking about
06:21:20 <byorgey> luite: can you give an example?  I'm not sure what you mean.
06:21:37 <erus`> Favonia: i found that it lead to alot of code duplication. also if i wanted to inherit from multiple interfaces it was awkward
06:21:58 <luite> byorgey: Q[sqrt(2)][sqrt(3)][sqrt(6)] = Q[sqrt(2)][sqrt(3)]
06:22:29 <ClaudiusMaximus> Q[sqrt(2)][sqrt(2)] would be a problem too
06:22:43 <Favonia> DevHC: span (==1) [1..n] needs O(n) time to evaluate the final result, right?
06:22:48 <byorgey> luite: oh, I see.  Well, as long as you only ever extend it with roots of unique primes you should be ok
06:22:52 <luite> byorgey: but if a native implementation doesn't check for the existence adjoined element in the field, then it would just add another 2d-vector space with basis {1,sqrt(6)}
06:23:05 <Favonia> DevHC: in a strict computation model
06:23:10 <luite> byorgey: yeah but then you cannot make Q[sqrt(6)]
06:23:21 <erus`> Favonia: for example i had a genric entity interface, i wanted PhysicsEntity and GraphicalEntity  interfaces too but i had to keep track of what interfaces and entity used myself
06:23:33 <byorgey> luite: sigh, implementation details =)
06:23:36 <DevHC> Favonia: i don't see why u want to apply the strict computation model...
06:24:25 <DevHC> Favonia: in a strict environment i imagine a span-like function work by returning an index to the first false element
06:25:06 <Favonia> DevHC: you are right about that span will return the result once it found the first false element
06:25:22 <Favonia> DevHC: but the following spans need the list anyway
06:25:37 <DevHC> the remainder of the list, that is
06:26:08 <parcs> what is the difference between case x of { _ -> y } and case x of { _other -> y }?
06:26:15 <DevHC> @src groupBy
06:26:15 <lambdabot> groupBy _  []       =  []
06:26:16 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
06:26:16 <lambdabot>     where (ys,zs) = span (eq x) xs
06:26:48 <parcs> :t _other
06:26:49 <lambdabot> Not in scope: `_other'
06:27:22 <ClaudiusMaximus> > let x = 1 ; y = const in case x of _other -> y _other
06:27:24 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
06:27:24 <lambdabot>    arising from a use of `...
06:27:26 <Botje> parcs: _other will still be a usable variable, but ghc won't complain if you don't use it.
06:28:39 <ClaudiusMaximus> parcs: and _ alone is pattern syntax, so you can't use it as a variable
06:29:06 <parcs> > case 5 of { x@(_) -> x }
06:29:07 <lambdabot>   5
06:29:50 <parcs> oh
06:30:08 <parcs> oh okay, thanks
06:30:10 <alexbagel> > case (1,2) of { (_a,_a) -> _a }
06:30:11 <lambdabot>   Conflicting definitions for `_a'
06:30:11 <lambdabot>  Bound at: <interactive>:1:17-18
06:30:11 <lambdabot>          ...
06:30:25 <alexbagel> > case (1,2) of { (_a,_a) -> "fruit" }
06:30:26 <lambdabot>   Conflicting definitions for `_a'
06:30:26 <lambdabot>  Bound at: <interactive>:1:17-18
06:30:26 <lambdabot>          ...
06:30:31 <alexbagel> > case (1,2) of { (_,_) -> "fruit" }
06:30:31 <lambdabot>   "fruit"
06:34:23 <Favonia> @src span
06:34:23 <lambdabot> span _ xs@[]                     =  (xs, xs)
06:34:23 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
06:34:23 <lambdabot>                   | otherwise    =  ([],xs)
06:35:18 <Favonia> DevHC: I will be right back. I am still not convinced
06:35:26 <DevHC> lol
06:35:44 <alexbagel> fwiw, i'm convinced :)
06:40:34 <Favonia> DevHC: if you agree that making computation strict does not change the whole time complexity, I might be able to show you my points more easily :P
06:40:48 <DevHC> ok
06:42:08 <byorgey> but making computation strict DOES change time complexity =P
06:42:17 <merijn> I was about to say
06:42:21 <DevHC> shh
06:42:24 <merijn> That doesn't make any sense at all
06:42:42 <Favonia> byorgey: no if all functions/evaluations are actually strict
06:42:59 <Favonia> byorgey: which is true in this special case, I think
06:43:05 <byorgey> Favonia: which special case?
06:43:19 <Favonia> print $ group ...
06:43:35 <merijn> Why would that be strict?
06:43:54 <byorgey> > print $ group $ take 10 $ [1,1,1,2,2,3] ++ [7..]
06:43:56 <lambdabot>   <IO ()>
06:44:03 <byorgey> > group $ take 10 $ [1,1,1,2,2,3] ++ [7..]
06:44:05 <lambdabot>   [[1,1,1],[2,2],[3],[7],[8],[9],[10]]
06:44:42 <Favonia> byorgey: take is not strict in its second argument
06:45:03 <byorgey> that's true
06:45:04 <merijn> Because of laziness in whatever's in "..." some fusion might kick making it a different time complexity from a strict version of "..."
06:45:40 <byorgey> Favonia: ok, sorry, why don't you continue, I guess I am not actually sure what you are trying to say
06:46:04 * hackagebot http-enumerator 0.6.5.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.5.1 (MichaelSnoyman)
06:46:40 <Favonia> merijn: sorry. DevHC and I are discussing about print $ (map head $ group list)
06:47:51 <byorgey> @src group
06:47:52 <lambdabot> group = groupBy (==)
06:47:56 <byorgey> @src groupBy
06:47:56 <lambdabot> groupBy _  []       =  []
06:47:57 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
06:47:57 <lambdabot>     where (ys,zs) = span (eq x) xs
06:47:59 <Favonia> byorgey: I am running multiple threads in my head now... I'll be back in maybe in one hour
06:48:29 <byorgey> @src span
06:48:30 <lambdabot> span _ xs@[]                     =  (xs, xs)
06:48:30 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
06:48:30 <lambdabot>                   | otherwise    =  ([],xs)
06:49:16 <byorgey> looks like O(n) to me.
06:49:49 <Favonia> byorgey: if you are interested, my point is that (map head $ group list) could take n^2 to fully evaluate the final result, and DevHC said it is linear
06:50:18 <byorgey> Favonia: I agree it is linear.  span does not traverse the list past the first element that is false.
06:50:53 <byorgey> note the 'otherwise' case which just copies the entire remaining list without making any recursive call
06:51:29 <dolio> At worst, every element is visited twice.
06:51:37 <byorgey> and in the p x case that list (zs) just gets copied without being touched as well
06:52:18 <o-_-o> byorgey: thanks for the patch to diagrams
06:52:21 <dolio> Except the first, I suppose.
06:52:21 <Favonia> byorgey: back. oh I misunderstood the functionality of span
06:52:38 <byorgey> o-_-o: you're welcome
06:52:50 <byorgey> o-_-o: and did you see my paste re: rendering a diagram to a Surface?
06:52:56 <Favonia> byorgey: DevHC: merijn: I was wrong. thanks :) should use @src span earlier
06:53:10 <o-_-o> byorgey: no it has scrolled away, I was out to get some food
06:53:18 <byorgey> Favonia: hehe, no worries =)
06:53:20 <merijn> Favonia: It happens :p
06:53:44 <merijn> If I had a cookie everything I insisted on something wrong in here...(I wouldn't be able to get out of my chair...)
06:53:49 <dolio> > group [1,2,1,2,1,2,1,2]
06:53:49 <lambdabot>   [[1],[2],[1],[2],[1],[2],[1],[2]]
06:53:51 <byorgey> o-_-o: http://hpaste.org/46998/converting_a_diagram_to_a_cair
06:53:54 <dolio> Someone should have done that.
06:54:06 <byorgey> o-_-o: untested but hopefully that will set you in the right direction
06:54:19 * o-_-o takes a look
06:54:41 <byorgey> o-_-o: note it only works with the darcs version of diagrams-cairo at the moment, until I make a new release
06:54:41 <companion_cube> a lo-_-ok ?
06:54:46 <byorgey> haha
06:54:56 <Favonia> dolio: exactly......... :(
06:55:13 <o-_-o> hello
06:55:19 <o-_-o> hello
06:55:30 <byorgey> dolio: hmm?
06:55:51 <dolio> > partition (==1) [1,2,1,2,1,2,1,2,1]
06:55:52 <lambdabot>   ([1,1,1,1,1],[2,2,2,2])
06:56:25 <Favonia> dolio: :( you got my point
06:56:31 <byorgey> oh, I see. well, I would have done that if I understood that the issue was Favonia misunderstanding what span did =)
06:57:11 <byorgey> now, map head . partition, I agree could take O(n^2)
06:57:26 <byorgey> erm, well, hmm...
06:57:46 <byorgey> never mind, that doesn't even make sense
06:58:04 * hackagebot assimp 0.1 - The Assimp asset import library  http://hackage.haskell.org/package/assimp-0.1 (JoelBurget)
06:58:18 <kluge> @src partition
06:58:18 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
06:58:18 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
06:58:18 <lambdabot>                               | otherwise = (ts, x:fs)
07:06:31 <MaskRay> how to recompile all the libraries when ghc is upgraded?
07:07:29 <MaskRay> is there a one-line command to accomplish this task?
07:07:29 <silver> try haskell-updater first
07:08:53 <erus`> @hoogle renderPrimitive
07:08:54 <lambdabot> No results found
07:08:58 <Favonia> wow lazy pattern match! I thought it is seldom used :D # @src partition
07:10:10 <MaskRay> silver: done. `No broken packages found!'
07:10:45 <silver> your binaries should be ok then...
07:11:46 <silver> also there is an option to recompile everything AFAIR
07:12:02 <ezyang> I usually just lazily recompile libraries as I need them.
07:12:06 <ezyang> Helps clear out a lot of junk too.
07:12:18 <MaskRay> i have some packages installed by cabal and there are ~/.cabal/lib/###/ghc-6.12.3/
07:12:48 <MaskRay> they don't work with ghc-7.0.3
07:14:41 <silver> oh
07:14:50 <thoughtpolice> they won't by design. binary files that GHC uses are definitely not guaranteed to have sort of compatibility guarantee, even between minor versions
07:15:00 <thoughtpolice> if you upgrade, you just have to use 'cabal' to install the packages you need again
07:17:14 <MaskRay> why gentoo-haskell overlay doesn't provide binary USE flag for dev-lang/ghc-7.0.3 while binaries are available
07:17:53 <Zao> MaskRay: Because it's not gentoo if it's not compiling constantly. :D
07:20:57 <MaskRay> Zao: I once compiled ghc-6.12 for nearly an hour and only to find it failed.
07:22:09 <shapr> And that's why I have function try () {    $* && fin || die; }
07:22:09 <shapr>  
07:22:10 <MaskRay> Zao: A few days ago I emerged dev-lang/ghc-7.0.3 and it failed again.
07:24:05 <roconnor> what happens when a thread calls system exit?
07:24:36 <roconnor> the whole program ends?
07:25:04 <hpc> try it, perhaps?
07:25:05 <Saizan> no, unless it's the main one
07:25:35 <roconnor> Saizan: if it isn't the main one, are all its children threads killed?
07:26:08 <Saizan> roconnor: nah, System.Exit.exit* just throws an exception
07:26:36 <roconnor> this feels like a retarded spec for threads.
07:27:22 <erus`> does anyone know of a more C like binding to opengl for haskell
07:27:31 <quicksilver> erus`: OpenGLRaw
07:27:43 <erus`> quicksilver: is it for 1 and/or 2?
07:27:48 <quicksilver> although to be honest I think OpenGL is already fairly C-like.
07:28:00 <quicksilver> 1, 2 and some of 3, IIRC.
07:28:00 <roconnor> OpenGLRaw is a raw Haskell binding for the OpenGL 3.2 graphics system and lots of OpenGL extensions. It is basically a 1:1 mapping of OpenGL's C API, intended as a basis for a nicer interface.
07:28:01 <Saizan> well, they are very barebone, if you want to keep track of children you can do it in your code
07:28:34 <roconnor> Saizan: I find it strange the the programs main thread is specialer than any other thread.
07:28:50 <Mattias> hm, I have an odd issue, in the where after the guards,  I'm following this: http://learnyouahaskell.com/syntax-in-functions#where     when it tries to set skinny = 18.5 and those other variables on a new line under where, but indented the same, I get this error in ghci when loading the .hs file: parse error on input `=`   at the place skinny's = is at
07:28:58 <roconnor> Saizan: does it make a difference if I use forkOS vs forkIO?
07:29:07 <quicksilver> roconnor: no.
07:29:16 <quicksilver> that only makes a difference about boundedness.
07:30:56 <erus`> quicksilver: it looks like its just for 3 :(
07:31:05 <erus`> im used to the usual opengl api
07:31:13 <erus`> i cant get used to the haskell version
07:31:13 <quicksilver> 3 is the usual opengl API.
07:31:33 <erus`> 3 is programable pipeline
07:31:52 <erus`> im still using fixed function for now
07:32:11 <erus`> trying to re-implement some old games of mine
07:32:39 <quicksilver> I'm pretty sure openglraw supports all the legacy stuff
07:32:42 <quicksilver> I'm not sure where it's hidden
07:33:05 <quicksilver> but really the standard hopengl is very C-like it's probably easier just to get the hang of using that.
07:33:34 <quicksilver> ah, of course, all the old stuff is in the compatibility module : http://hackage.haskell.org/packages/archive/OpenGLRaw/1.1.0.1/doc/html/Graphics-Rendering-OpenGL-Raw-ARB-Compatibility.html
07:33:57 <erus`> quicksilver: i'm having trouble loading and reading the matrix's and switching matrix modes etc
07:34:21 <erus`> ah perfect thanks quicksilver
07:34:46 <quicksilver> matrixMode $= Projection
07:34:51 <quicksilver> doesn't strike me as that difficult ;)
07:36:03 <quicksilver> I learnt openGL in haskell by following C tutorials and it mostly made sense.
07:37:05 <kami__> hello
07:37:57 <Mattias> gah, I don't get it, nothing on the second where line after guards works...
07:38:08 <magicman> Mattias: Make sure you're using spaces, and not tabs.
07:38:25 <Mattias> magicman, ooh? yeah, I'm using tabs
07:38:28 <Mattias> testing
07:38:42 <magicman> Or set your text-editor to have a tab width of 8 spaces.
07:38:59 <erus`> cheers quicksilver i got it working as expected now
07:39:06 <magicman> (even better, replace tabs by 8 spaces. Mixing spaces and tabs gets messy)
07:39:06 <Mattias> ah! I just changed to 4 yesterday, no wonder haskell is acting up
07:39:21 <Mattias> guess I'll change it to 8 for haskell then
07:39:24 <Mattias> Thanks!
07:39:28 <mauke> no, don't
07:39:36 <mauke> either write tab agnostic code or don't use tabs at all
07:40:12 <Mattias> but a tab is a tab, why does it matter which length the editor renders it in?
07:40:24 <hpc> Mattias: because the width of the tab matters to ghc
07:40:29 <hpc> Mattias: and it is always 8
07:40:29 <aristid> Mattias: the columns have to line up.
07:41:11 <hpc> my theory is that they made tabs deliberately huge to make using tabs difficult
07:41:32 <isomorphic> I'm writing a silly parsec parser - it parses sentences -ie : groups of characters, not necessarily on one line, but terminated with a full stop
07:41:35 <hpc> so the problems start immediately instead of a week into a project
07:41:48 <isomorphic>  what I've got is here - http://hpaste.org/47000/sentence_parser
07:42:02 <isomorphic> When executed, it reports that it was expecting '.'
07:42:13 <isomorphic> How can I correct it to figure out when my file has ended?
07:42:18 <Mattias> I mean, the editor just renders the tab character right? 8 is just the default width an editor renders it in? I compiler can't really see what size the editor uses so... or did I get something wrong -.-
07:42:31 <Mattias> A compiler*
07:42:43 <isomorphic> (in this case, I've embedded test data to reproduce - it's something more fundamental than an eof :/ )
07:43:08 <hpc> isomorphic: it looks like the regex your parser corresponds to is /\w*\./
07:43:10 <Mattias> well, I set it to 8 width, still getting the error
07:43:12 <aristid> Mattias: just set your editor to not use tabs for haskell.
07:43:17 <hpc> isomorphic: which is, one word followed by a period
07:43:33 <xplat> for Data.Enumerator, is there a way to write something like xargs?
07:43:34 <Mattias> aristid, I guess, I'll just make it turn tabs into spaces
07:43:49 <hpc> isomorphic: so what the problem is, i think, is that it expected "Blah." and saw "Blah Bleh."
07:44:08 * hpc has never used parsec; take with salt
07:44:09 <flinstone> j
07:44:58 <cheater__> hpc: \w*\. is not one word followed by a period.
07:45:07 <flinstone> j
07:45:13 <xplat> that is, you have f :: a -> Enumerator blah blah blah , and you want to get an Enumeratee a blah blah blah
07:45:18 <hpc> cheater__: er, whatever the right character class is
07:45:23 <cheater__> no.
07:45:38 <flinstone> Hello guys, who know howto find haskell job?
07:45:39 <cheater__> the wildcard is wrong.
07:45:43 <shapr> flinstone: I prefer Haskell over J... even over APL.
07:46:05 <cheater__> flinstone: have you searched in your drawers?
07:46:06 <xplat> shapr: that's really saying something
07:46:15 <shapr> flinstone: Write lots of Haskell libraries, do a successful GSoC, and then you can get a Haskell job.
07:46:17 <cheater__> @protontorpedo job
07:46:17 <lambdabot> how does j2ee compare to haskell?
07:46:17 <hpc> cheater__: oh, \w+ then
07:46:26 <cheater__> @protontorpedo job
07:46:26 <lambdabot> how does haskell do with large systems?
07:46:27 <isomorphic> cheater_: YOu're thinking non-greedy?
07:46:28 <cheater__> @protontorpedo job
07:46:28 <lambdabot> some dude called topmind says that oo is bs
07:46:30 <Saizan> Mattias: haskell's layout is based on vertical alignment, if you mix tabs and spaces in certain ways what appears vertically aligned with a certain tab width is not actually aligned with another
07:46:46 <xplat> cheater__: @protontorpedo doesn't workthat way
07:46:49 <Mattias> Saizan, I haven't mixed anything
07:46:55 <cheater__> xplat: i noticed :(
07:47:13 <hpc> Mattias: paste the code perhaps?
07:47:15 <flinstone> shapr, what is Gsoc?
07:47:24 <shapr> flinstone: Google Summer of Code
07:47:25 <hpc> (i think hpaste keeps tabs)
07:47:38 <hpc> preflex: seen luite
07:47:38 <preflex>  luite was last seen on #haskell 1 hour, 24 minutes and 30 seconds ago, saying: byorgey: yeah but then you cannot make Q[sqrt(6)]
07:47:52 <flinstone> shapr, i think it is not my way
07:48:12 <cheater__> flinstone: are you a markov bot?
07:48:13 <xplat> how you get a haskell job is you look for a java shop looking for their first ruby hire, and then you rename 'runghc' to 'ruby'
07:48:15 <magicman> Mattias: The indentation of "bmi" in "    where bmi =" is that first indent + 6. The indentation of "skinny" in "          skinny =" is the indent until "where", and the second indent.
07:48:18 <Mattias> hpc, I have some problems with that, I'm developing in arch virtualbox and vim in terminal, so when I try to copy it, it doesn't work properly, the + and * register just doesn't work at all
07:48:23 <shapr> flinstone: ok, find your own way.
07:48:23 <flinstone> shapr, i prefer business application and how to find clients, whick need functional language
07:48:48 <shapr> flinstone: One thing that may help is to increase your fluency with English and perhaps Swedish.
07:48:59 <cheater__> english specifically
07:49:14 <hpc> xplat: LOOOL
07:49:21 <magicman> Assuming the "where" has a single tab in front of it, and "skinny =" has two, that puts "bmi" on column 14, and "skinny" on column 16, so they're not aligned.
07:49:37 <shapr> flinstone: Most Haskell jobs will have international clients. For now, English is the language of international business.
07:49:44 <cheater__> xplat: i know that too well
07:50:01 <magicman> Because tabs are defined as 8 spaces in the standard.
07:50:14 <cheater__> xplat: that's what i do with python currently (i don't know haskell well enough): i just write scripts with shebang interpreter specs, they never find out what's inside.
07:50:18 <magicman> (at least, I believe it's in the standard...)
07:50:18 <Favonia> @help protontorpedo
07:50:18 <lambdabot> protontorpedo is silly
07:50:28 <cheater__> @protontorpedo
07:50:28 <lambdabot> is haskell more powerful than any jedii?
07:50:31 <shapr> flinstone: If you get many clients that need a functional language, hire me! ;-)
07:50:33 <cheater__> magicman: yes, they are
07:50:38 <Mattias> I'll just upload the actual file, pastebin just removes tabs, sec
07:50:44 <flinstone> shapr, Do you already find haskell job?
07:50:58 <shapr> flinstone: Yes, I have had a Haskell job before. But right now I have a Python job.
07:51:05 <hpc> Favonia: name of a famous troll, who managed to earn his own command to immortalize a few choice lines
07:51:09 <cheater__> shapr: i am currently in the process of writing an analysis of how to find clients who need functional languages
07:51:16 <shapr> cheater__: I would like to read your analysis.
07:51:18 <cheater__> shapr: and how to convince them that they do
07:51:29 <flinstone> cheater__,  i too :-)
07:51:31 <cheater__> shapr: well currently it's like 10-15% done, and my hard disk crashed with bad sectors.
07:51:42 <cheater__> but it's ok, because i'm recovering the data.
07:51:45 <shapr> ok
07:51:50 <cheater__> it'll be done.
07:51:54 <Favonia> hpc: thanks for the information :)
07:51:57 <cheater__> just make sure to remind me constantly about it all the time
07:52:13 <flinstone> cheater__, which haskell job is more easy to find?
07:52:16 <cheater__> basically what i'm doing is analyzing algorithms that solve problems in functional languages
07:52:21 <Mattias> hpc, magicman: http://dl.dropbox.com/u/6244950/tutorial.hs  tutorial.hs:84:39: parse error on input `='
07:52:33 <flinstone> cheater__, in machine learning? parsers? finansional analysis?
07:53:17 <xplat> as a lot of haskell jobs are in finance, spelling 'financial' correctly will be a big help in getting them
07:53:38 <shapr> flinstone: Financial analysis is a popular use of Haskell, OCaml and Scala.
07:53:46 <flinstone> shapr, do you used natural language processing in python?
07:54:06 <flinstone> shapr, what about marketing analysis?
07:54:08 <shapr> No, but I have used Haskell's Grammatical Framework some for natural language processing.
07:54:09 <hpc> Mattias: http://dl.dropbox.com/u/37707/Untitled.png
07:54:15 <hpc> Mattias: you see that where clause?
07:54:31 <Mattias> hpc, yeah
07:54:41 <hpc> you have "where bmi = expr"
07:54:46 <hpc> but expr continues on two lines
07:54:55 <cheater__> then i take those algorithms and 1. find specific uses of (for example: a specific form of parallelization works well for finite body problems, etc) and 2. find where such theoretical problems are used (for example, in protein research etc)
07:54:56 <shapr> flinstone: I know Haskell has been used for global economic modeling, does that fit into marketing analysis?
07:54:58 <hpc> now, the first column of expr is after that '='
07:54:58 <flinstone> shapr, i have experience in marketing analysis and now think how to write software for it
07:55:14 <hpc> er, disregard that
07:55:18 <cheater__> flinstone: basically, it's the easiest to get a haskell job anywhere that you find problems that parallelize like crazy
07:55:20 <shapr> flinstone: If you already have experience in that field, that would be a good choice.
07:55:25 <magicman> Mattias: Right. (skinny, normal, fat) starts (to the compiler) on column 16 (2 tabs -> 16 spaces), while "bmi" starts on column 14 (1 tab + 6 characters -> 14 characters).
07:55:29 <cheater__> because imperative languages don't do that well
07:55:32 <hpc> Mattias: so you have two lines in the where clause, is what i mean to say
07:55:37 <cheater__> you need a declarative language for that
07:55:43 <shapr> flinstone: At the same time, you will be more likely to find a job if your English gains fluency.
07:55:44 <hpc> Mattias: but those two lines are differently indented
07:55:53 <flinstone> cheater__, prolog?
07:55:54 <Mattias> ok, so,, haskell wants it aligned, not intented
07:55:57 <Mattias> indented*
07:56:03 <cheater__> flinstone: haskell.
07:56:17 <cheater__> flinstone: haskell is a declarative language.
07:56:20 <flinstone> cheater__, prolog is also declarative
07:56:27 <flinstone> and logical
07:56:30 <cheater__> so is SQL.
07:56:33 <hpc> Mattias: yeah, alignment is the key
07:56:36 <magicman> Mattias: Indeed. Alignment is important.
07:56:40 * magicman got ninja'd.
07:56:49 <Mattias> thanks for explaining ^.^
07:58:02 <flinstone> cheater__, why people should use haskell for finansional analysis if they can use R project,SPSS, WEKA?
07:59:06 <cheater__> ask jmcarthur
07:59:30 <flinstone> cheater__, who is it?
07:59:48 <flinstone> does it often on this irc channel?
07:59:59 <cheater__> yes
08:00:27 <cheater__> flinstone: what country are you from?
08:00:32 <flinstone> cheater__, Russia
08:00:50 <cheater__> are you done with university?
08:00:59 <ezyang> Scala lets you specify whether or not types are covariant or contravariant. That's kind of nifty.
08:01:02 <flinstone> cheater__, yes i finish it 3 years ago
08:01:14 <cheater__> what have you studied? and at what uni?
08:01:16 <flinstone> now working as asp.net c# freelancer
08:01:20 <cheater__> which city
08:01:59 <flinstone> i learned machine leraning, math statistics, image processing(opencv)
08:02:25 <jmcarthur> flinstone: haskell is a general purpose language and can be used for more than just tinkering around with some numbers interactively
08:02:46 <flinstone> jmcarthur, thanks :-)
08:03:42 <jmcarthur> so comparing it to R and such (which i know can actually do quite a lot, but still...) is kind of a disservice. you wouldn't really use R as the core of a high frequency trading platform, for example
08:04:06 <jmcarthur> not sure if you would use haskell for that either, frankly, but it would at least be more feasible
08:04:07 <cheater__> flinstone: what city were you studying in?
08:04:42 <flinstone> cheater__, why you ask it? :-)
08:04:48 <flinstone> are  from Russia too?
08:05:10 <jmcarthur> ask me again in a year or so and i might be able to guess whether haskell would be a good choice for HFT
08:05:22 <flinstone> jmcarthur, yes i also think that i should use R functions(like core)
08:05:31 <hpc> jmcarthur: there are firms that use haskell for HFT, so it is apparently a good choice for them
08:05:40 <flinstone> jmcarthur, what is HFT?
08:05:48 <hpc> flinstone: high frequency trading
08:05:51 <jmcarthur> flinstone: high frequency trading. every microsecond counts
08:06:08 <hpc> where the speed of light counts
08:06:21 <frerich> Mattias: Totally unrelated to your question, but I think "length' xs = sum [1 | _ <- xs]" is pretty funky. I didn't see this way of expressing 'length' before :-)
08:06:49 <xplat> doing stats in R is kind of like doing reporting in raw SQL, it's very quick and responsive if you know what you're doing but it's harder to systematize it or make it accessible to others
08:06:51 <Mattias> freiksenet, http://learnyouahaskell.com/ <-- it's all from here .) reading the tutorial
08:07:47 <xplat> or to integrate it into conventional-looking apps
08:08:12 <cheater__> flinstone: because some universities are useful and some are useless
08:08:18 <flinstone> jmcarthur, what do you think about outsourcng, Which kinds of firms prefer to hire outsourcers?
08:08:37 <cheater__> flinstone: i'm not from russia but i worked with a lot of russian researchers. and some of my teachers were russian.
08:08:58 <jmcarthur> flinstone: in the finance industry? i have no idea
08:09:03 <flinstone> cheater__, i learn C#,Haskell by myself
08:09:21 <cheater__> you're having problems answering questions
08:09:28 <cheater__> that doesn't spell anything good for your job search
08:09:30 <Mattias> there we go, I changed it so haskell uses 4 width tabs and expandtabs, works now :)
08:10:34 <shapr> flinstone: It sounds like you have excellent code skills.
08:10:50 <xplat> > let length'' xs = foldr (const succ) 0 xs in length'' [1..5]
08:10:51 <lambdabot>   5
08:10:55 <flinstone> shapr, thanks :-)
08:11:09 <shapr> flinstone: So, keep it up! You can do it!
08:11:20 <shapr> flinstone: It took me seven years of trying to get a Haskell job to finally get one...
08:11:37 <cheater__> oh yeah
08:11:41 <cheater__> keep on trying definitely
08:11:52 <flinstone> cheater__,  do not looking for job,  am looking for peoples who want hire outsourcers :-)
08:11:58 <xplat> shapr: it probably wouldn't have taken you nearly as long if you were starting now
08:12:01 <cheater__> make sure to work on your english too -- even if your job skills are great, the most important job skill is communication
08:12:12 <cheater__> i'm not joking here or making fun out of you, just saying it's important
08:12:17 <shapr> xplat: True, but there wasn't much commercial usage of Haskell when I started.
08:12:25 <cheater__> flinstone: outsourcing is a job too
08:12:25 <flinstone> cheater__, yes i know.
08:12:49 <cheater__> flinstone: what sort of things have you done with haskell already?
08:13:09 <flinstone> cheater__, i am just start lerning it,read books
08:13:32 <jmcarthur> flinstone: my background is mostly in national defense (where of course you pretty much never outsource to other nations), and i'm only just now getting into the finance industry and don't know about what is typically outsourcable
08:13:34 <shapr> flinstone: Have you read http://book.realworldhaskell.org/ ?
08:13:49 <flinstone> shapr, yes
08:14:13 <Favonia> cheater__: hey, Haskell is the best imperative PL I have even learned! :P ok, ok I know what you meant :P
08:15:15 <jmcarthur> it's pretty easy to find functional programming jobs. it's much harder to find jobs using haskell specifically
08:15:26 <xplat> lots of countries outsource most of their national defense
08:15:42 <flinstone> jmcarthur, i know that in finantional industry peoples very often use finantional analysis etc, but in marketing people use they minf, not formula, or statistcal packages
08:15:49 <xplat> of course in a lot of cases they don't have much choice about it
08:16:10 <jmcarthur> xplat: my only possible response to that is quite political in nature ^_^
08:16:13 <osfameron> finantional++
08:16:28 <ClaudiusMaximus> luite, byorgey: here's what i came up with so far... http://hpaste.org/47004/algebraic_field
08:18:09 <xplat> i don't think a lot of the touchy-feely part of marketing is outsourceable
08:18:48 <jmcarthur> if i was trying to market a product in another country i would outsource to a team in that country ;)
08:18:49 <flinstone> xplat, yes marketing is not outsourceble
08:19:00 <syntaxfree_> xplatz: many countries import substantial amounts of american culture through sitcoms, blogs, etc.
08:19:06 <xplat> even if most of marketing is not stats/math, that small part is the one that will be outsourced easily
08:19:20 <syntaxfree> hell, my girlfriend and I follow the american presidential elections.
08:19:24 <xplat> jmcarthur: hm, not sure i'd count that as outsourcing
08:19:30 <jmcarthur> maybe not
08:20:06 <flinstone> jmcarthur, and what should be outsourceble? web application, mobile apps
08:20:07 <jmcarthur> syntaxfree: meanwhile, americans don't even know the name of your country
08:20:47 <xplat> syntaxfree: sure, but there's always a difference between 'following' a culture and living in it organically
08:20:52 <syntaxfree> it's such a circus, american politics.
08:20:52 <isomorphic> Can anybody shed light on the message "combinator 'many' is applied to a parser that accepts an empty string." ?
08:20:58 <jmcarthur> err, to be clear, that was supposed to be critical of americans, not whatever country you're in
08:21:09 <syntaxfree> I mean, politics here have as much as BS and corruption as anywhere else.
08:21:09 <xplat> there's a lot about life in america you'd have to be some kind of freaking genius to learn from tv, even news
08:21:26 <syntaxfree> but in the USA, politics doesn't really affect anything.
08:21:32 <Ke> wow, politics in freenode, this must be indeed the apocalypse
08:21:37 <xplat> (not that the USA is unique in this)
08:21:39 <shapr> isomorphic: 'many' is one of the Parsec combinators, it wants a combinator that does not accept an empty string.
08:21:39 <syntaxfree> Bush2, Obama? Any difference?
08:21:40 <flinstone> :-)
08:21:44 <copumpkin> syntaxfree: -blah
08:21:49 <jmcarthur> maybe we should -blah this conversation
08:21:52 <xplat> (you could say the same about any country/culture)
08:22:02 <shapr> yes please, politics go to #haskell-blah
08:22:04 <xplat> jmcarthur: er, yes, quite
08:22:12 <shapr> howdy electrogeek
08:22:33 <isomorphic> shapr: Does an expression like many (noneOf ".") look suspicious on that basis?
08:22:40 <isomorphic> I think it's what is causing the issue
08:23:03 <shapr> isomorphic: I'd guess that (noneOf ".") would accept an empty string
08:23:15 <shapr> isomorphic: But you can probably load it into ghci and try it
08:23:20 <xplat> isomorphic: anything that doesn't move the 'cursor' forward shouldn't be used with many
08:23:27 <shapr> I used to have a run function for testing my parsec parsers
08:24:35 <flinstone> shapr, what do y think about browser automation with haskell, or  it is better using imacros,greasemonkey?
08:25:04 <shapr> flinstone: I don't know. I do know that manatee has written a browser in Haskell. Have you tried manatee-browser?
08:25:18 <flinstone> shapr, no
08:26:22 <aristid> shapr: doesn't manatee use webkit?
08:26:32 <shapr> aristid: does it? I haven't used it.
08:26:49 <aristid> and noneOf "." accepts a single character that is not .
08:26:53 <aristid> not an empty string
08:27:31 <erus`> quicksilver:  how do i do a mulMatrix type thing? :)
08:28:35 <erus`> like gl mulmatrix
08:29:29 <ClaudiusMaximus> erus`: http://www.haskell.org/hoogle/?hoogle=mult%20%2Bopengl
08:30:20 <flinstone> Maybe here exist smart peoples. Who know how to contact with developer teams in Europe/USA, just by email and "Write Hello we are outsorcing from Russia" or there are better way? Linkedin or any web sites?
08:30:28 <quicksilver> erus`: glMultMatrix you mean?
08:30:39 <isomorphic> http://book.realworldhaskell.org/read/using-parsec.html  <-- there's  a line cellContent = many (noneOf ",\n")
08:30:42 <erus`> yep
08:30:44 <shapr> flinstone: It's hard to make that work correctly.
08:30:51 <isomorphic> distinguishable from this?
08:31:01 <shapr> flinstone: I tried rentacoder and those websites, and they did not work for me.
08:31:13 <shapr> flinstone: so now I only work with people I already know in person, or online.
08:31:40 <flinstone> shapr, yes i know :-) but maybe there are place where developers spend a lot of time or business owners
08:31:54 <shapr> flinstone: Many developers spend time here.
08:32:12 <flinstone> shapr, i also tried rentacoder(there are just little payment job 30-200$)
08:32:23 <erus`> yey that was easy
08:32:26 <flinstone> and not intresing
08:32:31 <erus`> local object rotations and fps camera
08:32:31 <shapr> flinstone: Yes, same here.
08:33:30 <flinstone> shapr, maybe exist ways to improve this process(finding developer companies)
08:33:34 <alexbagel> preflex: seen preflux
08:33:35 <preflex>  Sorry, I haven't seen preflux
08:33:36 <quicksilver> erus`: well, the function is called multMatrix
08:33:53 <erus`> yeah found it thanks
08:33:59 <flinstone> maybe advertising
08:34:00 <shapr> flinstone: http://www.haskellers.com/
08:34:08 <erus`> time to go home from work :(
08:34:13 <erus`> bye all
08:34:21 * shapr waves to erus`
08:34:23 <luite> ClaudiusMaximus: hmm, you may also want to think about other types of extensions, for example cube roots or Q[i]
08:35:03 <luite> wait I think the more common notation is Q(i) because [] is for rings, not sure though
08:35:09 <flinstone> shapr, are there for c# developers simillar resource?
08:35:23 <flinstone> or main stream developres
08:35:53 <shapr> flinstone: I don't know.
08:36:02 <flinstone> shapr, Do you know famous resource centres for small business?
08:36:17 <flinstone> shapr, are y frm Europe?
08:36:24 <shapr> flinstone: I do not. I get my jobs and my clients from people I know in person or online.
08:36:39 <shapr> flinstone: Not really. I was born in the USA, but I spent seven years living in Sweden and Finland.
08:37:14 <luite> ClaudiusMaximus: in the general case you get a multiplication group for your basis vectors, with scale factors
08:37:45 <luite> ClaudiusMaximus: maybe it's this group that you want to work with instead of multiple extensions
08:37:46 <flinstone> shapr, i do not now english well, but how to find this kind of forums, resources for small business which queries in google :-)
08:38:06 <flinstone> europe small business portals
08:38:19 <flinstone> or Europe business community :-)
08:38:23 <shapr> flinstone: I don't know. All of my clients and employers have been found through people I know in person and online.
08:38:46 <flinstone> yes but you live there :-)
08:39:01 <ClaudiusMaximus> luite: i thought about that (multiplication table), but i think i'll leave it until i need it (or someone sends a patch)
08:39:23 <flinstone> for example(maybe i am wrong, but now forums are old, peoples do not use forums, only social networks)
08:39:31 <kstt> can someone recommand a good lib for postgresql ? There is the fairly complete LIBPQ bindings library, which is really good, but very low level. I'm looking for something at a higher level, but dedicated to postgresql if possible. Cross backends solutions like HDBC are nice, but naturaly lacks too many postgresql-specific goodness.
08:39:32 <ClaudiusMaximus> luite: i'm not really sure which would be more work
08:39:32 <luite> ClaudiusMaximus: hehe the easy way out huh? ;)
08:40:03 <ClaudiusMaximus> luite: the current experiment is quite lightweight, which appeals to me
08:40:55 <flinstone> And else one intresting note. There are no popular news sites for small business, now peopele read mashable,reddit, web20
08:41:09 <flinstone> no standart news
08:42:46 <flinstone> Are there americans or Europe guys?
08:43:50 <flinstone> Haskell comunity WAKE UP :-) next GHC release will be in 2012
08:44:47 <flinstone> Look like Haskell developers intresting just Hakell :-)
08:45:28 <tg__> what tools does one normally use to read/parse haskell files and get their AST?
08:46:01 <Saizan> haskell-src-exts
08:46:04 <aristid> @unmtl Writer s m a
08:46:05 <lambdabot> err: `(m, s)' is not a type function.
08:46:14 <aristid> @unmtl Writer s a
08:46:14 <lambdabot> (a, s)
08:47:39 <tg_> Saizan: this seems overwhelming for me
08:48:59 <shapr> flinstone: Most Haskell developers write several languages.
08:49:15 <shapr> flinstone: I write Haskell, Python, C#, Java, elisp, and many other languages.
08:50:09 <cheater__> flinstone: almost everyone here is from america or europe.
08:50:19 <flinstone> cheater__, good
08:50:39 <djahandarie> tg_, it's because it supports a few of the GHC extensions
08:50:47 <djahandarie> Actually all
08:50:56 <byorgey> tg_: it doesn't look that bad.  just start here: http://hackage.haskell.org/packages/archive/haskell-src-exts/1.10.2/doc/html/Language-Haskell-Exts.html
08:51:04 <byorgey> start by calling "parseFile"
08:51:18 <byorgey> then follow links in the docs to find out what it returns
08:51:29 <tg_> byorgey: ok, better
08:51:39 <cheater__> i write haskell, python, and bash. and all sorts of web shit.
08:51:46 <byorgey> documentation should always be evaluated lazily ;)
08:52:11 <tg_> byorgey: I didn't have a starting point
08:52:30 <djahandarie> Oh, I thought you meant the internals, not usage
08:52:32 <aristid> @src Writer (>>=)
08:52:33 <lambdabot> Source not found. stty: unknown mode: doofus
08:52:38 <byorgey> tg_: I just went to the haskell-src-exts page on Hackage and clicked on the top-level module
08:52:42 <flinstone> Just for clear explanation. What i want to say. In Europe there are no common NEWS, or social network for small business. They exist only for diffren countries(Germany community and journals, France community etc)
08:52:48 <byorgey> that's often a good starting point
08:53:10 <tg_> byorgey: ok. question in PM for a moment?
08:53:15 <byorgey> sure
08:53:29 <byorgey> mind you, I don't actually know anything about haskell-src-exts
08:53:44 <tg_> yeah, it's not specifically about that
08:53:47 <byorgey> ok
08:54:10 <joe6> i am doing something like this: http://pastebin.com/h5cJBWWd
08:54:18 <joe6> is there a simplar way of doing it.
08:54:27 <djahandarie> haskell-src-exts is a pretty intense package
08:54:29 <joe6> toHexString x = (++) "0x" $ showHex x ""
08:54:38 <joe6> usage                         $ map toHexString [0..0xff]
08:55:02 <djahandarie> It'd be pretty interesting to make a full-fledged IDE with it
08:55:06 <djahandarie> I wonder how far you could get
08:55:30 <tg_> i'll just ask here: I want to (for reasons that aren't obvious) split up literate haskell files as much as possible so they can be stored in a git repository. I see doing this by splitting off imports, exports, fixity info, type declerations, etc
08:55:33 <aristid> :t shows
08:55:34 <lambdabot> forall a. (Show a) => a -> String -> String
08:55:37 <tg_> and storing each of them as a seperate file
08:55:46 <tg_> for purposes of unique hashing
08:56:01 <hpc> what's the point of shows?
08:56:14 <tg_> so, for instance, one could determine if two [composite, literate] haskell files share identical import structures or not
08:56:21 <tg_> just by looking at their SHA1 hashes
08:56:25 <hpc> it's just (show a ++), is it not?
08:56:36 <byorgey> tg_: ok, interesting
08:56:57 <flinstone> shapr, can you help me with business Howto in Europe :-)
08:57:22 <tg_> byorgey: the assumption is that the difficulty in this task lies in a few things. One is uniformity of the format of each of those things (ie, a rule about the ordering of the imports, the multiplicty of the import strings w.r.t import qualfified, etc)
08:57:31 <byorgey> hpc: it's more useful to think of its type as  (Show a) => a -> ShowS
08:57:50 <tg_> the second is about the difficulty of handling whitespace gracefully - but I have a solution for this problem, I think
08:57:53 <byorgey> ShowS is like String but with more efficient left-nested concatenation
08:58:24 <hpc> oh
08:58:41 <hpc> so instead of "abc"++"d" you have 'a':'b':'c':"d"
08:58:41 <tg_> but is this impossible from the outset? It seems to me that haskell is so well defined that one should be able to do this splitting
08:59:22 <byorgey> tg_: I don't see why it would be impossible.  It sounds quite feasible to me.
08:59:30 <shapr> flinstone: I got involved in European Union projects as a subcontractor for EU Project partners. That worked well for me. But once again, I knew those people in person first.
09:00:12 <tg_> byorgey: I think a key to doing this in a uniform way will be this: all imports must have a qualifier, and all qualifiers must at least a few letters long
09:00:19 <byorgey> hpc: no, instead of (("abc" ++ "de") ++ "fg" ++ ... you have  ("abc"++) . ("de"++) . ("fg"++)
09:00:33 <copumpkin> ezyang: covariance and contravariance of what?
09:00:51 <tg_> *long enough* that one could be guaranteed to universally cover all namespaces that would ever exist in hackage
09:00:59 <ezyang> Well, in this particular case, in Scala.
09:01:05 <ezyang> http://stackoverflow.com/questions/6113453/wheres-the-contravariance
09:01:12 <hpc> byorgey: so ShowS = DList Char, then?
09:01:27 <copumpkin> ezyang: those are pretty similar to what you'd expect of "positive" and "negative" positions in haskell types, or category theory
09:01:32 <byorgey> hpc: yes, that's the idea
09:01:41 <byorgey> hpc: actually ShowS is just a type synonym for String -> String
09:01:59 <ezyang> Positive and negative positions? :x
09:02:03 <hpc> byorgey: what i was thinking of was, say shows is part of the Show class
09:02:04 <ezyang> I've actually never heard of that before.
09:02:12 <hpc> byorgey: so instead of defining show abc = "abc"
09:02:20 <Silvah> I wonder why there's no nice difference list type in the base library, even though it apparently can't live without them.
09:02:24 <hpc> shows abc = ('a':'b':'c':)
09:02:44 <tg_> like the opposite of prettyprint?
09:02:49 <tg_> uglyPrint
09:03:41 * hackagebot Craft3e 0.1.0.2 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  http://hackage.haskell.org/package/Craft3e-0.1.0.2 (SimonThompson)
09:03:46 <flinstone> shapr, Do you know howto find popular sites, forum,web20 communities in Europe, or in countries(France, or Spain)
09:03:56 <hpc> Silvah: perhaps they could do "type DList a = Endo [a]"
09:04:00 <flinstone> maybe alexa
09:04:04 <shapr> flinstone: I do not know.
09:04:07 <byorgey> ezyang: write down a type as a tree.  Assign + to the root.  Every time you travel down the left branch of an -> constructor, flip the sign.  otherwise keep the sign the same.
09:04:13 <flinstone> what i should type in google :-)
09:04:31 <copumpkin> ezyang: it's all about whether you take something or whether you produce something
09:04:34 <Silvah> hpc: Endo? What's that?
09:04:36 <flinstone> shapr, ok i will try google it
09:04:49 <hpc> newtype Endo a = Endo {appEndo :: a -> a}
09:04:51 <tg_> byorgey: language extensions needed by files are always in pragmas, correct?
09:04:55 <hpc> it's the type of endomorphisms
09:04:58 <tg_> byorgey: or that's a reasonable thing to demand?
09:05:00 <ezyang> Oh, it's sort of like alternating players in a game semantics of logic.
09:05:03 <hpc> except not really, because it is limited to (->)
09:05:11 <byorgey> tg_: sure, that's reasonable to demand
09:05:21 <ezyang> Though you don't really see types like that very frequently in Haskell...
09:05:31 <copumpkin> ezyang: think about contravariant functors in haskell
09:05:44 <byorgey> tg_: although technically you can e.g. specify extensions in a .cabal file that should be used for all source files, and then you don't have to list those in the files themselves
09:05:44 <tg_> byorgey: so that clearly would have to be the first thing I remove from any haskell file because I'll need it to know how to parse it.
09:05:45 <copumpkin> class Contravariant f where contramap :: (a -> b) -> f b -> f a
09:05:46 <luite> tg_: you can also specify language extensions in command line options or in the .cabal file
09:05:53 <byorgey> tg_: but that style is definitely discouraged (or at least it should be)
09:05:56 <luite> tg_: but it's good practice to use pragma's
09:05:58 <copumpkin> ezyang: what kinds of things can you make instances of that?
09:06:16 <tg_> ok
09:06:21 <luite> argh I shouldn't answer the same as byorgey :)
09:06:32 <byorgey> tg_: haskell-src-exts handles that for you.  It determines how to parse based on the extensions listed.
09:06:56 <Silvah> haskell-src-exts takes two years to compile.
09:06:58 <tg_> byorgey: cool!
09:07:11 <ezyang> Functions!
09:07:13 <tg_> cabal says it's already installed
09:07:29 <copumpkin> ezyang: yeah, where basically the parameter to f is in negative position, right?
09:07:53 <copumpkin> newtype Wonky a = Wonky (Int -> a) -> Bool
09:08:43 <byorgey> ezyang: yes, alternating players in a game semantics is a great way to think about it.
09:09:18 <ezyang> ♥ game semantics.
09:09:26 * byorgey should read more about game semantics
09:09:41 <byorgey> ezyang: any reading recommendations for an introduction?
09:09:43 <Silvah> And most time was spent in llc (LLVM bitcode -> assemby compiler). C'mon, it's 2011, quad-cores are common, why GHC can't compile other modules while waiting for llc to end its work?
09:09:56 <shapr> Silvah: fix it!
09:10:05 <edwardk> byorgey: matthias felleisen gave a nice talk, if you can call it that, hrmm.
09:10:09 <shapr> Silvah: Sounds like a simple patch, yah? You can do it!
09:10:31 <tg_> byorgey: ok, so I suppose if this is not such a crazy idea, then I have to ask about the crazy idea: I suppose what I want to do a parsing with a "maximal" whitespace operator
09:10:42 <ezyang> Curien's notes were what I learned originally.
09:10:48 <Silvah> shapr: well, I'm not too familiar with GHC source actually, but I could give a try.
09:10:52 <tg_> so the algorithim would be something like: replace all whitespace with a character string like {--|--}
09:10:54 <ezyang> (they're something like third Google result.)
09:10:58 <ezyang> But his notes are pretty dense.
09:11:08 <tg_> and then grow/shink/antisymmetrize the character string
09:11:10 <byorgey> ezyang: ok, thanks
09:11:10 <luite> tg_: but haskell-src-exts doesn't always completely know how to parse a file, because it doesn't know all fixities in advance. making it parse everything completely will take some work
09:11:25 <tg_> until you produce a file with no whitespace at all
09:11:36 <tg_> of a fixed line-length
09:12:31 <tg_> i would guess that this thing completely and totally ignores whitespace?
09:12:31 <byorgey> tg_: that sounds way too complicated
09:12:50 <byorgey> tg_: why not just work with the ASTs instead of strings?
09:13:08 <tg_> byorgey: like, hash the ASTs?
09:13:08 <byorgey> i.e. parse a file, do some sort of normalizations on the AST, then directly hash the AST
09:13:11 <byorgey> right
09:13:16 <tg_> hadn't occured to me
09:14:07 <tg_> lol that does seem much smarter
09:14:48 <aristid> @hoogle concatMapM
09:14:49 <lambdabot> No results found
09:14:51 <aristid> hmm.
09:16:22 <roconnor> @hoogle exit
09:16:22 <lambdabot> module System.Exit
09:16:22 <lambdabot> System.Exit data ExitCode
09:16:22 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
09:16:32 <roconnor> @hoogle+
09:16:33 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
09:16:33 <lambdabot> System.Exit exitFailure :: IO a
09:16:33 <lambdabot> System.Exit ExitSuccess :: ExitCode
09:17:46 <ezyang> Oh! I just realized something. The game semantics interpretation also corresponds to the moving of terms from the right side of the turnstile to the left, using implication elimination, e.g. |- A -> B ==> A |- B
09:17:56 <ezyang> (and vice vera)
09:18:14 <flinstone> Anybody know why Indian developers do not use Haskell?
09:18:50 <roconnor> From now on the main will have type IO Void!  To end a program use System.Exit.exitWith!
09:18:57 <roconnor> so says dolio
09:19:09 <aristid> roconnor: return undefined *bwahaha*
09:19:20 <roconnor> >:(
09:19:21 <opqdonut> :D
09:19:25 <roconnor> :P
09:20:22 <tg_> luite: as you might have guessed, I'll work on our project from this angle for now
09:20:32 <tg_> luite: uniform storage
09:21:18 <flinstone> Does Hakell developers fell finanional crsis?
09:21:44 <tg_> like, chopped the tree supporting the economy down so it collapsed?
09:22:20 <monochrom> no understand
09:22:24 <luite> tg_: hmm, not sure what you mean
09:22:28 <roconnor> aristid: I think if all goes according to plan, that will end up crashing with a pattern match failure.
09:22:42 <roconnor> or some other error
09:23:05 <flinstone> :-)
09:23:11 <aristid> roconnor: evil! :)
09:23:35 <roconnor> we are just clarifying when a program halts :D
09:23:36 <aristid> roconnor: why not just IO ExitCode, if you want to enforce an exit code?
09:23:48 <tg_> luite: getting a gitit-wiki style persistent storage without all the overhead
09:24:00 <luite> tg_: which overhead?
09:24:05 <tg_> luite: using gitit itself
09:24:09 <roconnor> aristid: the idea is more academic than that
09:24:22 <roconnor> the idea is to make IO a free monad over an IOSpec functor.
09:24:35 <aristid> roconnor: ok :)
09:24:36 <luite> tg_: you want to use filestore instead?
09:25:21 <tg_> luite: not really - I want it to be portable
09:25:29 <tg_> since I don't want to use git terminal commands
09:25:35 <tg_> there is a native git library now, I think
09:25:37 <roconnor> but to do so we need to separate Halt (in IOSpec) from return () (in the Free monad).
09:26:25 <sohum> so, does the debian distrubution of ghc7.0.3-1 come with the dynamic versions of base etc.? I'm getting "Perhaps you haven't installed the "dyn" libraries for package ase'?"
09:26:28 <sohum> *base
09:26:36 <aristid> what's the conventional name for type constructor composition?
09:26:40 <aristid> `o`?
09:27:20 <luite> tg_: it might be best to contribute to the filetore project then, write a new Data.FileStore.Git module, or perhaps just a GitNew module or something
09:27:24 <aristid> Writer `o` Product is cool.
09:27:33 <copumpkin> it has to be O
09:27:39 <tg_> luite: perhaps, I have that here to take a look at
09:27:41 <copumpkin> I think it's rather ugly
09:27:46 <tg_> luite: first thing is getting literate haskell files into a canonical form
09:28:13 <luite> tg_: why?
09:29:25 <tg_> luite: because it's how I want to store haskell code in a git-repo with a wiki frontend
09:29:42 <luite> but why do you need a canonical form for that?
09:30:07 <tg_> so that code blocks in Wolfgang can be referred to by their hashes
09:30:32 <tg_> and so the output of expressions which are textual can be referred to by their hashes
09:30:39 <luite> is that useful? hackage does just fine with module names
09:30:57 <tg_> luite: we'll find out, I guess
09:31:01 <tg_> it's something to do right now
09:31:10 <tg_> and learning how to parse haskell files can only make me get better
09:31:39 <luite> hehe, ok. it's not terribly exciting, haskell-src-exts just does all the work
09:32:04 <luite> keep in mind that line numbers are lossy, if you prettyprint the ast to a haskell file again, line numbers are not preserved
09:32:09 <tg_> luite: the real justification is I want to render the text with automatic justification
09:32:11 <luite> even if you use line number pragma's
09:32:19 <luite> waht?
09:33:34 <tg_> luite: I think I can devise a clever method of laying out haskell files in a browser this way
09:33:37 <tg_> put it that way
09:33:44 <tg_> without slurping in haskell files directly
09:33:47 <sohum> oh, right, it's in a separate package now
09:33:49 <sohum> ghc-dynamic
09:33:56 <luite> tg_: hmm, I have no idea what you mean
09:34:13 <tg_> luite: treat 'code snippets' as the most basic object, more basic than haskell files
09:34:34 <tg_> like the little black boxes in LYAH or snap
09:35:00 <tg_> those are the objects that the wiki will be littered with, not haskell files
09:35:03 <luite> tg_: right, that's wat I do at the moment, but I want to go back to treating complete pages as single .lhs files, that's one of the simplifications that's now partially done
09:35:03 <c_wraith> stepkut: have you seen http://stackoverflow.com/questions/6108745/haskell-monads-msum-in-happstack ?
09:35:25 <tg_> luite: yeah, but I don't have access to that work right now - and I think I can actually make a novel contribution here
09:36:36 <luite> tg_: yeah sorry for that.
09:36:52 <tg_> luite: no need to apologize, we will make progress together soon enough
09:37:58 <luite> tg_: but the problem is, if I have a post, say wiki/Demo, then I want to be able to import that post as Wolfgang.Demo in other pages. having separate snippets really has no advantage in that case. and for the single page, I can't think of many situations where it actually would be an advantage
09:39:13 <tg_> luite: the advantage is that you get to get to import snippets instead of pages, and not worry about getting the required [modules, declerations, fixities, ext] right
09:39:15 <luite> tg_: only in lyah types of things where in one snippet you want to have different modules imported than in another, then it would be useful... but that's a lot of extra work for not much gain I think
09:39:38 <luite> tg_: the problem with the snippets is that they already depend on each other
09:39:43 <tg_> luite: but the main thing is I am thinking about this project as a client/IDE which you could just "impose" or layer on top of haskell
09:39:49 <luite> imports from one snippet are available in the rest
09:40:14 <tg_> luite: yes, but if you have hashes for all snippets, you have a tree which takes a snippet to a import decleration snippet
09:40:50 <tg_> then you can simply compare the import decleration snippet with the [current] import decleration snippet, and if their hashes are equal than you've imported everything you need
09:41:03 <tg_> it's just a clever way to have pointers
09:41:31 <luite> that would make things quite a bit more complicated
09:42:41 <luite> you'll probably need to combine things to proper .lhs or .hs files once you want to combine them to usable code
09:42:54 <tg_> luite: -> snapframework
09:43:09 <luite> and if you pass them through haskell-src-exts for that, you'll lose accurate line information
09:44:31 <aristid> Writer is nice, but the whole wrapping/unwrapping necessary to get things into the proper newtype wrapper (for the Monoid instance) is a bit of a hassle :/
09:56:54 * hackagebot cblrepo 0.2.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.2.1 (MagnusTherning)
10:13:34 <b930913> I'm following some tut off the web but on copypaste ( :p ) it says "Could not find module 'Network':" How do I fix it?
10:15:59 <dafis> b930913: have you the relevant library installed? (that would be the network library)
10:16:41 <b930913> dafis: No idea. I'm on a shell with a fresh install of ghc.
10:17:06 <dafis> b930913: frsh install means: probably not
10:17:22 <dafis> have you anything besides ghc?
10:18:22 <dafis> b930913: which ghc version, btw?
10:19:06 <b930913> dafis: I have no idea, someone gave me a shell and then installed ghc.
10:19:50 <mafs> b930913: What does `ghc --version` say?
10:19:51 <dafis> b930913: when you say "someone gave me a shell", how should I interpret that?
10:20:54 <b930913> dafis: "I can slap up ghc on abacus if you'd like." (abacus is a server)
10:21:12 <b930913> mafs: 7.0.3
10:21:50 <dafis> b930913: so, it's not on a local machine?
10:22:22 <asdf``> exit
10:22:23 <b930913> dafis: I'm on a putty ssh.
10:24:01 <dafis> b930913: I've no idea whether you could install stuff locally in that setup.
10:24:16 <dafis> @hackage cabal-install
10:24:16 <lambdabot> http://hackage.haskell.org/package/cabal-install
10:25:02 * hackagebot regex-genex 0.1.20110525 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.1.20110525 (AudreyTang)
10:25:46 <mafs> dafis: couldn't he just use `cabal install --user`; or are you talking about being unsure if he can install cabal itself?
10:25:50 <ktosiek> dafis: well, cabal installs everything to ~/.cabal/ on my machine, so lack of root is not a problem
10:26:12 <b930913> I could probably get the admin to install a package for me.
10:26:13 <ktosiek> it even installed itself there on some upgrade
10:26:35 <dafis> ktosiek: but ghc isn't even on the same machine, if I understood correctly, that may be a problem
10:27:12 <mafs> dafis: as I understood it, he's SSHed in somewhere and using GHC on that remote shell.
10:27:20 <ktosiek> dafis: well, I think he logs into abacus, and the GHC is there
10:27:21 <luite> hmm, from regex-genex: "- We translate * and + quantifiers into {0,3} and {1,4}, to make output appear more unique."
10:27:25 <b930913> What mafs said.
10:27:30 <luite> how's that "all possible" :)
10:27:32 <mafs> b930913: what's the output of `which cabal`?
10:27:40 <mafs> (Or, rather, is it anything but "cabal not found"?)
10:27:52 <b930913> mafs: Nothing.
10:28:19 <b930913> a930913@abacus:~$ which cabal
10:28:21 <b930913> a930913@abacus:~$
10:28:39 <mafs> Hmm...so when you type `cabal`, it's not found?
10:28:57 <b930913> -bash: cabal: command not found
10:29:08 <ktosiek> b930913: ok, then you can either ask admin to install it or try to install it in your $HOME somewhere
10:29:26 <mafs> b930913: alright. get your admin to install it and then you can install the network package easily by yourself
10:29:27 <b930913> apt-get install cabal?
10:29:42 <mafs> or yeah, what ktosiek said about $HOME.
10:30:32 <ktosiek> b930913: cabal-install on my box (Ubuntu Natty)
10:31:59 <ktosiek> or just: apt-cache show '^cabal*'|grep '^Package'
10:32:23 <ktosiek> and see if it's there :-)
10:34:41 * tonyb486 stares creepily at Gracenotes
10:39:28 <marcot> The package name is cabal-install
10:40:21 <keep_learning> hello all
10:40:40 <keep_learning> is here any one solves problem on www.spoj.pl ?
10:41:00 <keep_learning> i am getting runtime error for problem https://www.spoj.pl/problems/FEELUCK/
10:41:05 <elliottt> dcoutts: are you around?
10:41:12 <dcoutts> elliottt: hia
10:41:16 <elliottt> :D
10:41:21 <keep_learning> http://hpaste.org/paste/47009/spoj_problem_httpswwwspoj
10:41:34 <elliottt> i'm trying to release the halvm network stack, and hackage won't let me include an os(xen) using cabal package
10:41:35 <keep_learning> this program runs perfectly well on my system
10:42:48 <dcoutts> elliottt: it's not an os that Cabal knowns about, I'm not sure what you mean by it either.
10:43:20 <elliottt> well, the halvm has a hacked version of cabal, that lets you have a xen os
10:43:27 <jmcarthur> gbacon: yo!
10:43:48 <b930913> cabal update / cabal install network, right?
10:43:49 <elliottt> dcoutts: it allows us to have packages that build elsewhere, but build differently for the halvm
10:44:25 <elliottt> dcoutts: in this case, the network stack can use a linux tap device, or a xen virtual network card
10:44:28 <dcoutts> elliottt: so it really means "bare metal, but running within Xen VM"
10:44:35 <elliottt> dcoutts: yes
10:44:47 <elliottt> dcoutts: but since stock cabal doesn't support this, it's something that we have to add.
10:44:59 <dafis> b930913: yes, right
10:45:59 <dcoutts> elliottt: which is fine. In the context of public distributed packages though we need to agree on what the os names mean. So if people who get this from hackage are going to be running it on xen too then we need to register a name.
10:46:52 <elliottt> dcoutts: so i'm not going to be able to release a semantically correct package because of this check?
10:46:56 <dcoutts> elliottt: of course, this is also going via cross compilation. We've not thought yet much about whether os means target or host.
10:47:18 <dcoutts> elliottt: not without us registering the name
10:47:31 <elliottt> dcoutts: and how long will that take?
10:47:46 <elliottt> dcoutts: or is that even a possibility.
10:47:54 <dcoutts> elliottt: it's pretty straightforward to actually do. I'd like to understand what it really means though.
10:48:09 <elliottt> dcoutts: how can i clarify it for you?
10:48:20 <dcoutts> elliottt: it means updating the Cabal lib and rebuilding the hackage-scripts
10:49:00 <elliottt> dcoutts: so what can i do to convince you that this is a good idea? :)
10:49:41 <dcoutts> elliottt: I'd like to make sure we're really referring to something in the "OS" category and not some other part of what makes up a platform.
10:49:51 <dcoutts> elliottt: so here you're referring to target os, not the toolchain used to build the program
10:50:04 <elliottt> dcoutts: quite right.  if you have a better way to fix this, i'm all ears.
10:50:06 <dcoutts> you need a special toolchain too of course
10:50:21 <elliottt> dcoutts: however, it prevents us from releasing a potentially useful package
10:50:56 <elliottt> dcoutts: cabal install quite happily ignores os(xen), so i'm not quire sure what the problem is
10:51:09 <elliottt> dcoutts: the only tool that makes use of it is the halvm version of cabal
10:51:16 <dcoutts> elliottt: we have stricter checks on distributed packages vs local packages
10:51:34 <elliottt> dcoutts: the idea is that this should be a distributed package.  it works on linux and the halvm
10:51:41 <b930913> Is haskell good at graphical calculations in realtime due to its parallelisation?
10:51:51 <dcoutts> elliottt: since globally, agreeing on what names mean is more important than it is locally
10:52:31 <sublimepua> what does Just do?
10:52:39 <hpc> b930913: sort of? you'd see more parallelism from the GPU than from haskell
10:52:48 <elliottt> dcoutts: what else should os(xen) mean?
10:52:58 <b930913> hpc: Haskell can utilise the GPU too, no?
10:53:13 <elliottt> dcoutts: is there a cabal channel that we should move to?  i'm not sure if #haskell is the right place to discuss this :)
10:53:19 <dcoutts> elliottt: #ghc
10:53:23 <hpc> b930913: look up data parallel haskell, and the opengl package
10:53:35 <sublimepua> is it related to Maybe?
10:53:53 <hpc> sublimepua: you know how you have a type called Bool, with constructors True and False?
10:54:00 <hpc> sublimepua: the Maybe type has constructors Just and Nothing
10:54:04 <sm> sublimepua: yes indeed.. look up Maybe in hoogle, you'll see
10:55:04 * BMeph would "just" reference the type...
10:55:07 <sublimepua> okay, so Just happens if maybe is true, and nothing if it is false?
10:55:15 <sublimepua> data Maybe a = Just a | Nothing
10:55:19 <sublimepua> was what i found
10:55:27 <hpc> sublimepua: no, that was just a mental hint :P
10:55:38 <hpc> sublimepua: a Maybe thing is kind of like a pointer
10:55:49 <hpc> sublimepua: it can either hold Nothing (null) or a thing (Just something)
10:56:01 <hpc> the type parameter 'a' is the type of the thing it holds
10:56:09 <hpc> so you can have a pointer to a String, or Maybe String
10:56:15 <sublimepua> oh okay. how does it determine which one it holds?
10:56:24 <hpc> (don't take "pointer" literally either :P)
10:56:36 <erus`> Maybe i dont really wanna know, how your garden grows
10:56:37 <sublimepua> lol. is Just a simply equal to a?
10:56:38 <hpc> > Just 5 -- sublimepua
10:56:39 <lambdabot>   Just 5
10:56:44 <hpc> :t Just 5 -- sublimepua
10:56:44 <lambdabot> forall t. (Num t) => Maybe t
10:56:51 <hpc> :t Just False
10:56:51 <lambdabot> Maybe Bool
10:57:13 <hpc> False is a Bool, so Just False is Maybe Bool
10:57:15 * hackagebot Craft3e 0.1.0.3 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  http://hackage.haskell.org/package/Craft3e-0.1.0.3 (SimonThompson)
10:57:15 <hpc> :t Nothing
10:57:15 <lambdabot> forall a. Maybe a
10:57:39 <sublimepua> lol ghci is giving me something different
10:57:48 <sublimepua> Prelude> Just False = Just False
10:58:07 <gbacon> jmcarthur: still awake?
10:58:56 <hpc> sublimepua: the best way to understand Maybe is just to mess with it in functions until you have a good mental picture of it
11:01:43 <jmcarthur> gbacon: i'm alive!
11:04:36 * BMeph was hoping we'd see jmcarthur do a "Dune" reference...
11:04:39 <erus`> @hoogle Position
11:04:39 <lambdabot> Text.Parsec.Prim getPosition :: Monad m => ParsecT s u m SourcePos
11:04:39 <lambdabot> Text.ParserCombinators.Parsec.Prim getPosition :: Monad m => ParsecT s u m SourcePos
11:04:39 <lambdabot> Text.Parsec.Prim setPosition :: Monad m => SourcePos -> ParsecT s u m ()
11:05:14 <jmcarthur> BMeph: i seem to be missing what the opportunity for a dune reference was
11:06:53 <b930913> cabal: Error: some packages failed to install:
11:06:54 <b930913> network-2.3.0.2 failed during the building phase. The exception was:
11:06:56 <b930913> ExitFailure 1
11:06:58 <b930913> Is that a problem?
11:08:30 <dafis> b930913: sure, it didn't install. The biggest problem is that it didn't tell you why. try upping the verbosity
11:08:54 <BMeph> jmcarthur: "The Sleeper has awakened!" :)
11:09:02 <dafis> or, during building, ghc may have spat out an informaitve message
11:09:31 <jmcarthur> heh
11:10:08 <dafis> b930913: was it something about an ambiguous use of closeFdWith?
11:10:32 <b930913> dafis: That's what it says.
11:11:32 <erus`> @hoogle Float -> Int
11:11:32 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
11:11:32 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
11:11:32 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
11:12:46 <sm> ack.. tricked again, 0.3.0.0 > 0.3
11:12:52 <erus`> @hoogle Int -> Float
11:12:52 <lambdabot> Prelude toEnum :: Enum a => Int -> a
11:12:52 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
11:12:52 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
11:13:32 <dafis> b930913: okay, the MIN_VERSION_base macro broke, ghc is 7.0.3, so that'd be Cabal-1.10, which version is cabal-install?
11:13:37 <erus`> how do i GHC.Int.Int32 -> Float ?
11:14:26 <dafis> b930913: the easy way, however, would be installing an older version of network, 2.1.*, I think
11:16:08 <erus`> @hoogle GHC.Int.Int32 -> Float
11:16:08 <lambdabot> Parse error:
11:16:08 <lambdabot>   --count=20 "GHC.Int.Int32 -> Float"
11:16:08 <lambdabot>                 ^
11:16:28 <dafis> erus`: fromIntegral
11:18:34 <kaini> What happens if I do putMVar with an not evaluated value?
11:19:10 <ezyang> an unevaluated thunk is placed in the mvar.
11:19:36 <ezyang> This is why strict mvars can be handy.
11:20:05 <ZombieShark> why are there so many people in here
11:20:21 <dafis> ZombieShark: 'cause it's nice here
11:20:22 <kaini> ezyang, and when I take it (in another thread) it will be evaluated (if needed), but what happens if I put the val in the mvar and then use it after that
11:20:29 <kaini> ezyang, will it evaluated twice?
11:20:30 <ZombieShark> all need help programming?
11:20:45 <ezyang> No, thunks synchronize across threads.
11:20:52 <Peaker> ezyang: maybe putMVar mvar $! val ?
11:21:02 <olsner> ZombieShark: or maybe everyone's done with the programming with time left to talk on IRC :)
11:21:25 <kaini> ezyang, ah okay thats fine
11:21:26 <kaini> thanks
11:21:35 <ZombieShark> what is so good about haskell
11:21:37 <Peaker> Or maybe procrastinating :)
11:22:01 <MarcWeber> nominolo: What's the state of scion-2nd-attempt ? Is it ready yet? The server only does a ping command?
11:22:09 <ZombieShark> i thought it was just some joke language reddit made up
11:22:22 <MarcWeber> ZombieShark: Depends on the task. The power and knowledge of the community is a huge plus.
11:22:59 <MarcWeber> ZombieShark: Just get started and see yourself. haskell.org points to some nice getting started documents.
11:23:19 * hackagebot elerea-examples 2.2.1 - Example applications for Elerea  http://hackage.haskell.org/package/elerea-examples-2.2.1 (GergelyPatai)
11:23:57 <ZombieShark> ehhhh, ill stick to vetted languages
11:24:39 * jmcarthur vets for haskell
11:24:46 <qff> Does anyone know a Char -> Word8 conversion? (The Char's being ASCII )
11:25:04 <monochrom> fromIntegral . fromEnum
11:25:05 <shapr> ZombieShark: As far as I know, there are no veterinarians using Haskell, thus you are safe.
11:25:17 <monochrom> or, fromIntegral . ord
11:25:39 <qff> Aah, I forgot about ord
11:25:46 <qff> thank you
11:27:01 <xplat> ZombieShark: who's vetting these languages?
11:27:19 * hackagebot hans 2.1.0.0 - IPv4 Network Stack  http://hackage.haskell.org/package/hans-2.1.0.0 (TrevorElliott)
11:27:23 <ZombieShark> john carmack
11:27:47 <shapr> ZombieShark: Oh, he's a fan of Haskell... have you seen his talks on the subject?
11:27:49 <ZombieShark> MIT
11:27:58 <ZombieShark> no
11:28:01 <shapr> ZombieShark: Oh, I STARTED the MIT Haskell User's Group!
11:28:01 <ZombieShark> where
11:28:16 <ZombieShark> links
11:28:17 <shapr> ZombieShark: At MIT...
11:28:22 <jmcarthur> shapr: sure you're not thinking tim sweeney?
11:28:31 <shapr> jmcarthur: Oh right, close enouh.
11:28:50 * tg_ thinks this implies shapr == tim sweeney
11:29:01 <tg_> but I didn't go to MIT, so I'm not that smart
11:29:08 <jmcarthur> tg_: i mean instead of john carmack as a fan of haskell
11:29:45 <tg_> jmcarthur: I would be happy to learn JC approves of Haskell
11:29:50 <shapr> tg_: It's okay, I didn't attend MIT as a student. I just happened to be working in the area.
11:29:56 <jmcarthur> and to be precise, tim sweeney isn't a fan of haskell specifically, just a fan of functional programming in general
11:30:03 <shapr> ZombieShark: Seriously, I started the Boston Area Haskell User's Group.
11:30:19 <ZombieShark> ok...and how many people showed up?
11:30:21 <tg_> shapr: MIT really is the premier institute in the entire world, though... seriously.
11:30:39 <shapr> ZombieShark: um, I think we had thirty people or so the first meeting, but it's gotten lots bigger these days.
11:31:14 <ZombieShark> ok so what have you progammed in haskell
11:31:27 <ZombieShark> programmed
11:31:29 <tg_> ZombieShark: I once wrote a program in haskell that crashed.
11:31:33 <shapr> ZombieShark: oh HEY! I gave a talk about emacs in the MIT Computer Science AI Lab Reading Room, like, the place where Richard Stallman started the whole emacs thing! IT FELT SO AWESOME!
11:31:34 <jmcarthur> lol
11:31:35 <luite> shapr: wow that's quite good
11:31:53 <shapr> luite: Yah, I'm happy with how it turned out. I think Matthias Felleisen gave a talk most recently?
11:31:58 <erus`> Double -> Float
11:32:00 <ZombieShark> i wish i knew emacs or vim....but i havent really had a problem with just using nano
11:32:02 <erus`> @hoogle Double -> Float
11:32:02 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
11:32:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:32:02 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:32:06 <ZombieShark> for YEARS
11:32:14 <luite> shapr: hmm, I don't know, it's too far away from here anyway :)
11:32:23 <tg_> I always felt like I never had enough keys on my keyboard to use emacs
11:32:32 <erus`> @hoogle sin double
11:32:32 <lambdabot> No results found
11:32:38 <shapr> ZombieShark: oh, I wrote a large chunk of lambdabot, a smaller chunk of HAppS, and lots of other stuff..
11:32:41 <ZombieShark> im not a fan of IDEs
11:32:45 <McManiaC> can someone help me to get the type of "runCondition"? what am I doing wrong? I cannot see the difference between the infered type and my own type? http://hpaste.org/47013/type_families
11:32:59 <ZombieShark> shapr, ok so why haskell over perl?
11:33:13 <shapr> ZombieShark: I tried to learn perl long ago and far away, but the #perl guys kickbanned me :-(
11:33:16 <shapr> so I learned Python instead.
11:33:16 <ZombieShark> or python or ruby
11:33:28 <shapr> ZombieShark: oh actually... Python got me into Haskell!
11:33:45 <ZombieShark> ive pretty much stuck with things that have C++ like syntax
11:33:52 <ZombieShark> and stayed away from others
11:34:02 <ZombieShark> i dont think whitespace should denote blocks
11:34:11 <jmcarthur> ZombieShark: believe it or not, pugs (the leading (for a time?) perl 6 implementation) is written in haskell
11:34:16 <shapr> I really enjoyed the whitespace layout in Python.. but I didn't like the way variables got changed 'behind my back' in multi-threaded programs.
11:34:18 <mun> does anyone know how to show that P doesn't follow from "P \/ Q" using inference rules?
11:34:30 <xplat> @protontorpedo
11:34:31 <lambdabot> is haskell better than APL or perl or clisp?
11:34:35 <ZombieShark> ok so you do multithreaded stuff?  like what
11:34:45 <shapr> ZombieShark: Haskell gives you the option to use braces and semicolons instead of whitespace.
11:34:52 <ZombieShark> oh thats good
11:34:59 <shapr> ZombieShark: Though I've not seen large amounts of code written in that style.
11:35:00 <jmcarthur> haskell's indentation-aware syntax is a lot nicer than python's though
11:35:09 <jmcarthur> it's less finnicky
11:35:17 <shapr> That's a finicky word.
11:35:46 <shapr> ZombieShark: Oh, the Haskell Application Server I was being paid to work on was multithreaded.
11:36:16 <xplat> the real reason haskell is better than perl is it has a llvm backend so you can compile it into javascript and run it in your browser
11:36:27 <ZombieShark> xplat, wuuut?
11:36:46 <hpc> haskell -> llvm -> js -> ??? -> profit!
11:36:47 <lispy> http://www.reddit.com/r/haskell/comments/hj3yl/announcement_hans_the_haskell_network_stack_hans/
11:37:01 <ZombieShark> ok so like....why not just write it in javascript
11:37:02 <shapr> ZombieShark: In any case, you should totally try Haskell IN YOUR BROWSER: http://tryhaskell.org/
11:37:04 <Peaker> jmcarthur: I prefer Python's indent-based over Haskell's, it is more predictable (colon+indent denotes start, dedent denotes end)
11:37:09 <ZombieShark> or coffeescript if you are using obscure stuff anyway
11:37:13 <Peaker> jmcarthur: Haskell's indent style has more arbitrary rules
11:37:28 <xplat> ZombieShark: because that's exactly what they'd be expecting!!!
11:37:31 <shapr> lispy: whoa that's awesome! Is it based off the stack in hOp/House/Lighthouse?
11:37:34 <jmcarthur> Peaker: you can write haskell with similar indentation rules to python, but not the other way around
11:37:47 <ZombieShark> who is they
11:37:52 <Peaker> jmcarthur: Well, I place more value on readability than writability, so restricting writers is actually a good thing
11:38:24 <shapr> ZombieShark: In any case, I think you should vet Haskell for yourself, see what sort of awesome it supports.
11:38:31 <jmcarthur> i prefer to have the flexibility to write readable code ;)
11:38:34 <shapr> ZombieShark: Haskell is by no means perfect, but it does have a lot of awesome.
11:38:39 <jmcarthur> even if it goes against the grain
11:38:40 <Peaker> ZombieShark: Haskell attempts (quite successfully) to catch more errors at compile-time, using types.  The types are also more meaningful than in other languages -- meaning: A) They help reading code by telling you a lot  B) They make it a little harder to make some kinds of changes, because you have to update the types
11:38:49 <hpc> (tryhaskell is not representative of the entirety of the awesome haskell can produce)
11:39:01 <erus`> https://github.com/tm1rbrt/S3DM critique please. Go easy though, this is my first haskell program that is more than a single file
11:39:03 <shapr> lispy: Hey, this might be good for a scapy clone
11:39:07 <jmcarthur> tryhaskell is not even representative of a good chunk of it
11:39:22 <lispy> shapr: scapy?  Never heard of it
11:39:26 <Peaker> jmcarthur: I think Perl vs Python shows how TIMTOOTDI turns out, in terms of readability :)
11:39:43 <hpc> if you really want to try haskell, mess around with ghci a bit, and read lyah
11:39:45 <hpc> @where lyah
11:39:45 <lambdabot> http://www.learnyouahaskell.com/
11:39:58 <Peaker> jmcarthur: For example, allowing "if" before and after expressions in Perl does not make code more readable at all, despite giving "more freedom to write readable things"
11:39:58 <lispy> shapr: It might be based off it, but I think trevor rewrote it at some point
11:40:24 <jmcarthur> Peaker: i think flexibility is a different thing than just tons of extra sugar to choose from
11:40:28 <lispy> shapr: ah, I just heard it's different.  Not based on the one in house
11:40:32 <shapr> cool
11:40:43 <lispy> it's got good performance too
11:40:47 <hpc> jmcarthur: "flexible" != "boneless"? :P
11:40:48 <xplat> Peaker: there's such thing as 'too much of a good thing' of course
11:40:54 <Peaker> jmcarthur: Multiple indent options is really just extra sugar to choose from
11:40:57 <ZombieShark> id need a reason to use it
11:41:05 <lispy> I know trevor was benchmarking it at some point
11:41:07 <Peaker> jmcarthur: It also makes my "tab" key in the editor less likely to guess the right indent level
11:41:09 <jmcarthur> Peaker: if i had my way, i would have the flexibility to write blocks of code in arbitrary 2d locations so that i can better place things near related things and documentation
11:41:44 <ZombieShark> i cant think of anything to program, let alone learn a new language to do it
11:41:45 <hpc> jmcarthur: you know some asshole would put a crucial piece of code at 65535x65535
11:41:52 <shapr> ZombieShark: that's a point.
11:41:56 <xplat> Peaker: now the tab thing is kind of legitimate.  although that's more because of the colons than other differences
11:42:02 <jmcarthur> hpc: assholes can write obfuscated code in any language
11:42:10 <ZombieShark> i'd rather practice my assembly if i had something crazy to write
11:42:41 <shapr> ZombieShark: If you ever decide to try writing Haskell, it's a really awesome language with lots of powerful features.
11:42:58 <ZombieShark> does it have a cgi interface?
11:43:02 <shapr> lispy: scapy is a packet creation tool written in Python, it's really powerful.
11:43:08 <ZombieShark> to apache
11:43:12 <shapr> ZombieShark: Yes, it has cgi/fast-cgi/etc
11:43:22 <shapr> ZombieShark: As well as full-on fast webservers and web dev frameworks.
11:43:24 <ZombieShark> k, then maybe i can do something with it
11:43:25 <jmcarthur> as well as its own web servers
11:43:40 <xplat> ZombieShark: it has a web app interface that you can use to write stuff that works in cgi, fast-cgi, or a standalone server without changing the code
11:43:50 <jmcarthur> ZombieShark: check out http://hackage.haskell.org/package/
11:43:59 <jmcarthur> there's a ton of libraries and such
11:44:03 <luite> there are at least 3 major webservers in haskell
11:44:05 <Peaker> xplat: also the more restrictive syntax
11:44:07 <luite> and probably some smaller ones
11:44:15 <luite> well, major for haskell ;p
11:44:27 <Peaker> jmcarthur: I am not sure I would want to read code that's all over the place :-)  Ideally it would be a view option at the editor
11:45:07 <benmachine> hey guys, are the semantics of 'error' really odd, or am I just being stupid? specifically, http://hpaste.org/47014/odd_error_semantics
11:45:14 <jmcarthur> Peaker: i think there's merit to being able to control how your view arbitrary source code, but i also think it's nice to be able to view it as the author intended
11:45:34 <Peaker> jmcarthur: sure, but IME authors should be given as little control over it as possible :-)
11:45:36 <Peaker> bbl
11:45:44 <copumpkin> benmachine: how would you do that differently?
11:45:46 <lispy> shapr: ah.  I wrote some packet creation stuff in C the other day (for talking to hans actually).  I keep meaning to blog it.
11:46:17 <benmachine> copumpkin: I'm confused as to whether or not 'error' needs to inspect its argument to throw an exception, I suppose
11:46:26 <ZombieShark> wow twitter is such a joke
11:46:27 * lispy a => a -> Lunch -> Gone
11:46:42 <ZombieShark> its coded by morons
11:46:44 <copumpkin> benmachine: I guess it could throw then start printing, but that would be kind of wonky
11:46:47 <jmcarthur> to me, syntax can be a kind of visual abstraction, kind of like how you can make semantic abstractions. it's not *as* important as semantics abstractions, but i still think it's nice to be able to do it
11:46:48 <copumpkin> ZombieShark: #haskell-blah
11:46:57 <benmachine> copumpkin: what do you mean?
11:46:57 <shapr> ZombieShark: There's an irc channel for non-Haskell discussion, it's #haskell-blah
11:47:26 <copumpkin> benmachine: well, how would it throw the exception _THEN_ start inspecting its parameter to print it?
11:47:43 <copumpkin> throwing the exception is basically passing control off to someone else
11:47:45 <benmachine> copumpkin: the printing is done by the exception handler; the default toplevel one if nothing else
11:47:47 <copumpkin> namely whoever is handling it
11:48:16 <benmachine> so what I expect is for error (fix id) to give ErrorCall (fix id) to the catch statement
11:48:23 <copumpkin> hmm
11:48:28 <copumpkin> I see
11:49:00 <benmachine> copumpkin: what I don't get is how in one case we can work out that it's an error call and one case we can't, despite the fact there's clearly no valid error message in either case
11:49:14 <Eduardo> :)
11:49:26 <benmachine> error ('x' : fix id) works
11:50:48 <copumpkin> error s = throw (ErrorCall s)
11:50:55 <copumpkin> that's puzzling
11:51:54 <xplat> > error undefined
11:51:54 <lambdabot>   *Exception: *Exception: Prelude.undefined
11:52:20 <benmachine> copumpkin: inorite
11:52:41 <xplat> this already shows that the second exception isn't thrown until the first one starts being printed in the exception handler
11:53:06 <xplat> otherwise you'd only see *Exception: once
11:53:19 <fragamus> hey my monad looks messy: http://hpaste.org/47015/messy
11:53:33 <fragamus> can anyone suggest cleaner code?
11:53:42 <benmachine> xplat: right.
11:53:52 <benmachine> oh, hm, maybe it's something to do with buffering
11:54:14 <benmachine> so error (fix id) prints "*Exception: " but then loops forever before it hits the newline
11:54:16 <xplat> > fix (error . ("i hate when they throw an " ++))
11:54:17 <lambdabot>   "*Exception: i hate when they throw an *Exception: i hate when they throw a...
11:54:44 <xplat> benmachine: yes, that is likely
11:54:59 <benmachine> that's much less magical than I had hoped :P
11:55:09 <benmachine> (isn't stderr supposed to be unbuffered, especially in ghci?)
11:57:14 <fragamus> http://hpaste.org/47015/messy
11:57:30 <fragamus> can you say it better ^^^^
11:57:32 <xplat> you could also try something like 'error $ trace "hi" "mom"'
12:00:20 <fragamus> can this be written cleaner: http://hpaste.org/47015/messy
12:01:34 <dafis> fragamus: fmap keysSet (gets firstOfTriple)
12:01:41 <hpc> fragamus: change your triple to a data structure
12:01:44 <dafis> firstOfTriple to be written
12:02:19 <dafis> but of course some type with a named field would be even better
12:02:25 * hackagebot serialport 0.4.1 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.4.1 (JorisPutcuyps)
12:03:04 <Eduard_Munteanu> Well you could also drop the 'let'.
12:03:28 <fragamus> wow thanx guys
12:05:14 <benmachine> fragamus: do (mymap,_,_) <- get; return mymap
12:05:32 <benmachine> er
12:05:43 <benmachine> fragamus: do (mymap,_,_) <- get; return (keysSet mymap)
12:05:48 <fragamus> tyty
12:09:20 <benmachine> xplat: oh wait, it can't be buffering, because I'm not letting it print the *Exception: line
12:10:00 <benmachine> xplat: this is weird. the behaviour I'm seeing suggests that catching an ErrorCall forces the error message, but if that's the case then catching (fix error) should be impossible, no?
12:10:35 <benmachine> (or should at least take forever)
12:11:22 <benmachine> if I let delay x = unsafePerformIO (threadDelay 1000000 >> return x), then ghci> C.catch (evaluate (error (delay "warble")) >> return ()) (\(ErrorCall _) -> putStrLn "wibble") waits a second before printing wibble
12:11:26 <tg_> byorgey: can we discuss diagrams somewhere?
12:11:36 <hpc> tg_: #diagrams
12:11:39 <byorgey> tg_: sure
12:12:13 * benmachine sees dons' hostname wonders if you can also get archlinux/chap/benmachine
12:14:06 <mercury^> benmachine: I don't remember you being part of the fellowship.
12:14:20 <shapr> howdy dons! How's code?
12:14:22 <benmachine> mercury^: I'm not, I am just being silly
12:16:45 <lispy> ZombieShark: I just think of twitter as a connectionless version of IRC. That's the only way I can be at peace with the design.
12:17:00 <shapr> lispy: We moved the twitter discussion to #haskell-blah
12:17:07 <lispy> gotcha
12:17:26 <flinstone> shapr, oh you are steel here
12:17:30 <Younder> Haskell types have me gong again
12:17:57 <flinstone> Can you explain what does it mean Generating Leads(americans point)
12:18:09 <Younder> Is there truly a time where Haskel types make sense?
12:18:23 <benmachine> Younder: yes
12:18:39 <benmachine> there's a time when you'll wonder how you ever managed without them
12:18:40 <benmachine> at least for me
12:18:46 <monoid> Younder: In contrast I can't think of a time when they don't!
12:19:17 <Younder> I though so
12:19:25 <xplat> benmachine if i catch error $ trace "hi" "mom" and print wibble there is no 'hi'
12:19:46 <benmachine> xplat: oh. that only confuses me further
12:20:10 <benmachine> xplat: are you catching it the same way I do?
12:20:20 <flinstone> Is here americans or Europe guys?
12:20:29 <shapr> flinstone: both and more
12:20:35 <xplat> ccatch (evaluate (error $ trace "hi" "mom") >> return ()) (\(ErrorCall x) -> putStrLn "wibble")
12:20:49 <flinstone> shapr, do oyu know about leads?
12:21:02 <xplat> (ccatch is defined by 'let ccatch x = Control.Exception.Catch x' in ghci)
12:21:15 <flinstone> shapr, looks like people do not like them
12:21:29 <shapr> flinstone: I don't understand.
12:21:36 <flinstone> They are from away or another MLM
12:21:41 <flinstone> amway
12:22:07 <shapr> flinstone: I don't understand what you are saying at all :-(
12:22:14 <xplat> flinstone: 'leads' are people to make a sales call to, preferably people who have expressed interest in the product somehow
12:22:15 <flinstone> http://www.interactivemarketinginc.com/lead-generation.html
12:23:13 <flinstone> xplat, yes i know,but it is intresting why shapr do not know it
12:23:49 <xplat> flinstone: but some people are happy to call anyone they think more likely to buy than average, or even anyone they have a name and phone number for, as a 'lead'
12:23:52 <flinstone> i thinked that in Europe and in USa it is very popular
12:24:17 <xplat> (which is why the subject makes some people upset)
12:24:18 <flinstone> xplat, so what is lead? it is phone number?
12:24:29 <flinstone> i thinked that Leader-is human who have a lot of phone numbers and call them and sell stuffs
12:24:45 <flinstone> another peoples do not like Leaders,because they call very often :)
12:25:04 <benmachine> xplat: augh, this is madness - (error $ delay "eep") is behaving differently from (error (delay "eep"))
12:25:58 <xplat> flinstone: there is no 'leader'.  the basic concept of a 'lead' is 'information how to contact someone you think you can sell to'
12:26:43 <flinstone> in Russia Leaders do not call often (just Insurance companyes)
12:26:50 <benmachine> xplat: try ccatch (evaluate (error (trace "hi" "mom")) >> return ()) (\(ErrorCall _) -> putStrLn "wibble")
12:27:25 <flinstone> xplat, so lead it is just information like phone number?
12:28:08 <xplat> benmachine: oh, $ is effectively putting an 'id' in front of 'error'
12:28:31 <xplat> benmachine: with 'id' in front it acts like the $ version
12:28:39 <Favonia> does anyone know how to enable the support of "interruptible" FFI calls in GHC 7 while building Cabal packages?
12:28:41 <NemesisD> anyone know where I can find any info on cabal's options for tests. I've read proposed .cabal syntaxes and that it is implemented in 1.10, but no documentation as to how to invoke/use it
12:28:58 <benmachine> xplat: you mean id (error ...) or error (id ...)?
12:29:12 <xplat> benmachine: id error ..
12:29:44 <benmachine> xplat: how does that make any sense at all ever :P
12:29:49 <xplat> like (id error (trace "hi" "mom"))
12:29:58 <benmachine> xplat: id changes the meaning of programs now?
12:30:15 <xplat> benmachine: id error is the same as error.  unless, apparently, you have an 'evaluate'.
12:30:36 <wookydocky123> hi
12:30:44 <wookydocky123> I wanna define new (++) by using foldr
12:30:50 <dcoutts> NemesisD: http://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/users-guide/#test-suites
12:30:52 <wookydocky123> and I have no idea why this: new_(++) a b =  flip $ foldr concat [] a b
12:30:53 <wookydocky123> doesn't work
12:31:07 <wookydocky123> could You gimmie some hints how to do that?
12:31:13 <benmachine> wookydocky123: new_(++) is a parse error, for starters
12:31:18 <benmachine> wookydocky123: actually it isn't
12:31:22 <benmachine> but it doesn't do at all what you want
12:31:34 <benmachine> operators need to be made *only* of operator characters
12:31:40 <wookydocky123> well, ok, so i will renamed the function
12:31:49 <wookydocky123> but it still doesn't work
12:31:50 <xplat> wookydocky123: also, you don't want concat in there
12:32:02 <benmachine> wookydocky123: well, why would it? your definition doesn't make sense to me
12:32:05 <xplat> wookydocky123: look at what the type of concat is
12:32:12 <xplat> @type concat
12:32:12 <lambdabot> forall a. [[a]] -> [a]
12:32:29 <wookydocky123> flip $ foldr concat [] [a,b]
12:32:31 <wookydocky123> ?
12:32:48 <benmachine> wookydocky123: what's the flip there for?
12:32:49 <xplat> > concat ["what","a","day"]
12:32:50 <lambdabot>   "whataday"
12:32:59 <benmachine> wookydocky123: and concat doesn't type check as an argument to foldr
12:33:31 <wookydocky123> so maybe (:) ?
12:33:47 <benmachine> wookydocky123: maybe. explain how you got what you got and we'll see what we can make of it
12:34:12 <NemesisD> dcoutts: nice. thanks!
12:34:43 <wookydocky123> I have no idea how should it look lie, somewhere I found, that it will be easier when i'll start with flip
12:34:52 <wookydocky123> I mean flip $ foldr [something]
12:35:13 <benmachine> wookydocky123: why? what do you think flip does?
12:36:02 <wookydocky123> change foldr to unfoldr ?
12:36:15 <xplat> good guess, but no.
12:36:16 <Eduard_Munteanu> LOL, that won't.
12:36:27 <benmachine> wookydocky123: that doesn't answer my question
12:36:39 <benmachine> oh wait
12:36:42 <Eduard_Munteanu> :t flip
12:36:42 <benmachine> yes it does
12:36:42 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:36:44 <benmachine> never mind
12:36:48 <benmachine> ignore lambdabot
12:36:54 <Eduard_Munteanu> *sigh*
12:36:55 <xplat> > (++) "hi" "mom"
12:36:56 <lambdabot>   "himom"
12:37:00 <Eduard_Munteanu> :t Prelude.flip
12:37:01 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:37:01 <xplat> > flip (++) "hi" "mom"
12:37:02 <lambdabot>   "momhi"
12:37:18 <flinstone> What is labdabot?
12:37:40 <Eduard_Munteanu> @vixen Tell flinstone who you are.
12:37:40 <lambdabot> stop being racist!
12:37:58 <xplat> lambdabot is a bot that can run haskell and does other things when you talk to her on irc
12:38:00 <flinstone> lambdabot, yes, please:-)
12:38:15 <wookydocky123> so how should it look like?
12:38:24 <flinstone> xplat, how i can iterate with it>
12:38:52 <flinstone> lambdabot, stop generating bullshit
12:39:05 <xplat> > iterate ("a":) ""
12:39:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:39:06 <lambdabot>         against inferred ty...
12:39:15 <xplat> oop
12:39:29 <flinstone> it does not understand my dsl :-)
12:39:33 <joe6> Most of the time, I find myself programming incrementally. I start off with solving a small problem and keep adding stuff to it until it becomes a huge program. I find that until I start working on the second version of such a program, I do not use the type system as much as I should.
12:39:35 <xplat> > iterate ('a':) ""
12:39:35 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
12:39:41 <joe6> does anyone do the same
12:40:00 <joe6> or, do you folks start off with planning a big program?
12:40:17 <flinstone> ok i understnd? does it helpfull?
12:40:18 <joe6> i find that a lot of things cannot be foreseen when the work is started.
12:40:40 <benmachine> joe6: sure, but haskell makes it easier than usual to rewrite the stuff you already have imo
12:40:44 <benmachine> so I rewrite as I go, sometimes
12:41:09 <joe6> oh, ok. just wanted to get the opinions of how others do.
12:41:25 <joe6> yes, I agree that haskell makes it easier to rewrite.
12:41:29 <benmachine> joe6: well, I've never released any real programs so don't read too much into my opinion :P
12:41:33 <xplat> i write about 200 lines of haskell, then i keep adding functions until it goes down to 100 lines :)
12:41:33 <wookydocky123> well, something like that: (++) = flip $ foldr (:)  ?
12:41:42 <benmachine> joe6: but yes, I start small and build up
12:42:15 <benmachine> wookydocky123: that looks interesting, can you explain what it does?
12:42:48 <fragamus> i write 1000000 lines and then hpaste here and you guys give me 2 line equivalent
12:43:01 <dmwit> ?src (++)
12:43:01 <lambdabot> []     ++ ys = ys
12:43:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:43:01 <lambdabot> -- OR
12:43:01 <lambdabot> xs ++ ys = foldr (:) ys xs
12:43:05 <joe6> the second version of the program is more haskell'ish, I find.
12:43:12 <dmwit> wookydocky123: correct, as shown above =)
12:43:27 <xplat> @check let pp = flip $ foldr (:) in (x ++ y :: [Int]) === (x `pp` y)
12:43:27 <lambdabot>   Not in scope: `==='
12:43:35 <benmachine> dmwit: aw, you can't go around giving people the answer all the time :P
12:43:49 <dmwit> Oh, what?
12:43:59 <wookydocky123> w8, i'm not sure how to put arguments here
12:44:39 <wookydocky123> fff a b = flip $ foldr (:) a [b]
12:44:43 <wookydocky123> ?
12:45:03 <benmachine> wookydocky123: are you just guessing
12:45:18 <xplat> @check let pp = flip $ foldr (:) in (x ++ y :: [Int]) == (x `pp` y)
12:45:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
12:45:36 <wookydocky123> benmachine, unfortunately yes
12:45:54 <flinstone> xplat, why y do not use  your ghc version?
12:45:55 <benmachine> wookydocky123: perhaps you should try a simpler function first?
12:46:16 <flinstone> and post code here
12:46:26 <wookydocky123> benmachine, I did, I define length, concat, sum, reverse (by using foldr and foldl)
12:46:34 <wookydocky123> now I stuck on (++)
12:46:39 <xplat> what am i doing wrong here?
12:46:40 <wookydocky123> and have no idea here
12:48:19 <xplat> @check \x y -> let pp = flip $ foldr (:) in ((x ++ y) :: [Int]) == (x `pp` y)
12:48:20 <lambdabot>   "OK, passed 500 tests."
12:49:11 <wookydocky123> xplat, I don't get it
12:49:39 <wookydocky123> I'm not sure how the flip works here
12:50:25 <Favonia> > flip (/) 3 6
12:50:26 <lambdabot>   2.0
12:50:32 <xplat> wookydocky123: i asked lambdabot to generate 500 random tests that ‘flip $ foldr (:)’ gives the same result on lists of numbers as (++) and all the tests passed
12:50:33 <Favonia> > (/) 6 3
12:50:34 <lambdabot>   2.0
12:50:50 <wookydocky123> ok i see thath flip swaps arguments
12:51:09 <xplat> > foldr (:) "hi" "mom"
12:51:10 <lambdabot>   "momhi"
12:51:31 <xplat> > flip (foldr (:)) "hi" "mom"
12:51:32 <lambdabot>   "himom"
12:52:15 <xplat> you give the foldr one argument, then the other two get flipped
12:52:15 <byorgey> wookydocky123: one way to think of foldr f z is that it replaces (:) with f and [] with z
12:52:19 <flinstone> foldr (  "hi" "mom"
12:52:26 <flinstone> foldr (  "hi" "mom")
12:52:26 <byorgey> > foldr f z (a:b:c:[])
12:52:28 <lambdabot>   f a (f b (f c z))
12:52:48 <byorgey> so foldr (:) "hi"  means to leave the (:) alone but replace the end of the list with "hi"
12:52:51 <copumpkin> a  :  b  :  c  :  []
12:52:58 <copumpkin> a `f` b `f` c `f` z
12:53:01 <flinstone> xplat, why lambda bot do not response to me?
12:53:17 <xplat> because you didn't use a >
12:53:18 <saati> can someone recommend some abstract algebra and category theory books? i am having a hard time understanding some concepts behind haskell
12:53:27 <flinstone> >foldr (  "hi" "mom"
12:53:35 <flinstone> >foldr (  "hi" "mom")
12:53:37 <xplat> and a space
12:53:51 <flinstone>  > foldr (  "hi" "mom")
12:54:04 <flinstone> > foldr (  "hi" "mom"
12:54:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:54:12 <parcs> xplat: because lambdabot/QuickCheck uses () as the default data type
12:54:14 <Favonia> flinstone: maybe you meant foldr ( : ) "hi" "mom" ?
12:54:35 <flinstone> > foldr (  "hi" "mom")
12:54:35 <xplat> parcs: read my @check again
12:54:36 <lambdabot>   Couldn't match expected type `t -> a -> b -> b'
12:54:36 <lambdabot>         against inferred ty...
12:54:51 <parcs> oh!
12:55:57 <Favonia> flinstone: xplat's code has a smiley after "(" :O
12:56:37 <xplat> > foldr ( : ) "hi" "mom"
12:56:37 <lambdabot>   "momhi"
12:57:06 <xplat> that's what i wrote, but with no space before or after the :
12:57:11 <xplat> it works either way
12:57:26 <norm2782> hmmm.. cabal update is taking forever on my VPS, while it's acting normally on my laptop.. what could the reason for that be? it's not the first time...
12:57:34 * hackagebot goa 3.1 - GHCi bindings to lambdabot  http://hackage.haskell.org/package/goa-3.1 (ChrisDone)
12:58:00 <tswett> Huh.  Apparently, static single assignment form is equivalent to (a well-behaved subset of) continuation-passing style.
12:58:10 <tswett> I've never even thought of those two things as being the same sort of thing.
12:58:46 <Favonia> > foldr ( : ) "hi" "abc"
12:58:46 <lambdabot>   "abchi"
12:59:03 <Favonia> wookydocky123: here foldr ( : ) "hi" "abc" is evaluated to ('a' : ('b' : ('c' : "hi"))), which is exactly "abchi"
13:00:07 <wookydocky123> Favonia, ok i see it now :)
13:00:13 <wookydocky123> and flip swaps elements
13:00:19 <wookydocky123> so it's "hiabc"
13:00:21 <Favonia> wookydocky123: foldr conceptually goes to the end of "abc", and construct the new list by adding back "abc"
13:00:28 <Favonia> wookydocky123: yes
13:00:40 <wookydocky123> thanks a lot ;]
13:01:55 <dmwit> saati: I think starting with abstract algebra and category theory is a bad plan.
13:02:26 <dmwit> saati: Humans seem better at taking a bunch of specific instances of things and then understanding their generalization than at taking a generalization and seeing how to apply it to specific instances.
13:02:27 <xplat> start with abstract stone duality
13:02:35 <lispy> > foldr f [a,b,c] []
13:02:36 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
13:02:36 <lambdabot>    arising fr...
13:02:40 <lispy> > foldr f [a,b,c] [] :: Expr
13:02:41 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:02:41 <lambdabot>         against inferred ...
13:02:44 <lispy> :t foldr
13:02:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:02:51 <dmwit> saati: So my recommendation is to get some experience with particular instances of the concepts you're having trouble with, instead.
13:03:03 <lispy> > foldr f a [b,c,d] :: Expr
13:03:04 <lambdabot>   f b (f c (f d a))
13:03:14 <dmwit> saati: If you tell us what concepts in particular are giving you trouble, we can recommend some more resources for exploring their instances.
13:03:14 <Favonia> wookydocky123: a minor point is that foldr will pause the evaluation once the part you want is evaluated... this is called lazy evaluation
13:03:28 <Eduard_Munteanu> Well, some basic abstract algebra is assumed in much of math, including CT books I guess.
13:03:41 <saati> dmwit: atm i would like to know what does monomorphic really mean
13:03:48 <lispy> > foldl f a [b,c,d] :: Expr
13:03:50 <lambdabot>   f (f (f a b) c) d
13:03:58 <dmwit> saati: Great question!
13:04:23 <dmwit> saati: "Monomorphic" means that you've nailed a type down concretely -- that there are no type variables.
13:04:29 <Eduard_Munteanu> Monomorphic is a type-theory thingy.
13:04:30 <wookydocky123> ok, thanks a lot, gotta go, bye
13:04:37 <dmwit> saati: For example, the type "Int -> Int" is monomorphic, while the type "a -> a" is polymorphic.
13:04:39 <Eduard_Munteanu> _There_, but not in every context.
13:05:06 <dmwit> saati: (Unless you're talking about the "monomorphisms" from category theory...?)
13:05:21 <Eduard_Munteanu> Which are probably unrelated.
13:05:36 * hackagebot ruff 0.1 - relatively useful fractal functions  http://hackage.haskell.org/package/ruff-0.1 (ClaudeHeilandAllen)
13:05:40 <xplat> there are actually two kinds of monomorphism.  a quality contrasted with polymorphism, and an item dual to an epimorphism.
13:05:56 <dmwit> yes indeed
13:06:01 <Eduard_Munteanu> saati: also, do you know about ##categorytheory ?
13:06:07 <dmwit> I realized that after I had started explaining the former. =P
13:06:15 <Eduard_Munteanu> </shameless spam> :)
13:06:20 <saati> i was looking at eval docs, and saw TypeRep which says it's a representation of a monomorphic type
13:06:31 <dmwit> Great, then I was explaining the right thing.
13:07:09 <tswett> You know, I just thought of something.  Imagine if we had a type constructor called In, such that a value of type "In a" represents a place where a value of type a must be put.
13:07:47 <xplat> tswett: are you reinventing the dual calculus?
13:07:50 <tswett> You could have a function wait :: (In a, a), which gives you a spot to put an a, and a value that gives you back the a that was put in.
13:07:53 <tswett> xplat: possibly!
13:08:04 <dmwit> Or possibly zippers.
13:08:39 <tswett> In-values would be uncopyable and indestructible, but they would be mergeable and creatable.
13:09:04 <Eduard_Munteanu> And what other superpowers? :P
13:09:40 <tswett> xplat: where can I read about dual calculus?  Is it this thing Wadler proposed?
13:10:00 <xplat> http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf
13:10:35 <tswett> Thank you.
13:10:39 <Eduard_Munteanu> That looks interesting.
13:11:17 <tswett> Eduard_Munteanu: I'm not sure about other strengths in-values would have, but you know how ordinary values are strengthened by kryptonite?  I have this hunch...
13:11:33 <Eduard_Munteanu> @where+ Call-by-Value is Dual to Call-by-Name:
13:11:33 <lambdabot> Done.
13:11:36 <Eduard_Munteanu> Bah...
13:11:47 <dmwit> ?where Call-by-value
13:11:47 <lambdabot> is Dual to Call-by-Name:
13:12:00 <dmwit> ?list
13:12:00 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:12:09 <tswett> @where+ dualcalculus http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf
13:12:09 <lambdabot> It is forever etched in my memory.
13:12:12 <tswett> @where dualcalculus
13:12:12 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf
13:12:13 <Eduard_Munteanu> @where+ dual-calculus Call-by-Value is Dual to Call-by-Name (P. Wadler): http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf
13:12:13 <lambdabot> Good to know.
13:12:16 <tswett> Did I do it right?
13:12:24 <tswett> Nah, Eduard's is better.
13:12:26 <Eduard_Munteanu> I know, it was a pasting mistake.
13:12:33 <dmwit> There's no ?where- ... =/
13:12:45 <Eduard_Munteanu> @where+ Call-by-value
13:12:45 <lambdabot> Done.
13:12:51 <tswett> @where+ dualcalculus
13:12:52 <lambdabot> Good to know.
13:12:55 <tswett> @where dualcalculus
13:13:03 * tswett nods solemnly.
13:13:06 <xplat> @where dual-calculus
13:13:07 <lambdabot> Call-by-Value is Dual to Call-by-Name (P. Wadler): http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf
13:13:22 <dmwit> ?where thisnamesurelyhasneverbeenwhereplussedright
13:13:22 <lambdabot> I know nothing about thisnamesurelyhasneverbeenwhereplussedright.
13:14:50 <dmwit> ?where dualcalculus
13:14:51 <lambdabot> I know nothing about dualcalculus.
13:14:52 <dmwit> hax
13:15:06 <xplat> @where glasses
13:15:06 <lambdabot> They're on your head.
13:15:12 <Eduard_Munteanu> Heh.
13:15:25 <dmwit> ?where ?where
13:15:25 <lambdabot> ?where ?where
13:15:28 <dmwit> oh my
13:15:35 <dmwit> Dangerous. =)
13:15:38 <tswett> @where ?where
13:15:38 <lambdabot> ?where ?where
13:15:44 <tswett> I have fooled it!  >:D
13:15:53 <dmwit> @where @where
13:15:53 <lambdabot>  @where @where
13:15:55 <dmwit> Nonsense!
13:16:12 <Eduard_Munteanu> @where lambdabot
13:16:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:16:12 <tswett> Ah, but nonsense is simply the dual of sense!  Reverse the arrows and all shall become clear.
13:16:17 <Eduard_Munteanu> Nonsense, she's here.
13:16:48 <Eduard_Munteanu> No, that'd be consensual :P
13:17:37 <dylukes> So...
13:17:42 <dylukes> how does pattern matching work internally?
13:17:46 <dylukes> Is it handled at runtime?
13:18:13 <tswett> dylukes: I imagine it's usually turned into a bunch of if-then statements.
13:18:34 <tswett> "If it's a Just, do this; otherwise, if it's a Nothing, do that..."
13:18:46 <dylukes> @src if-then-else
13:18:46 <lambdabot> Source not found. Do you think like you type?
13:18:51 <parcs> it definitely is handled at runtime
13:19:02 <xplat> pattern matching works like this: first the argument is evaluated to weak head normal form if it is a thunk, then it runs like an if tree
13:19:02 <dylukes> Mind explaining?
13:19:09 <Eduard_Munteanu> Well it works only on constructors and primitive values so it's easy to turn into a runtime check
13:19:13 <parcs> > let (Just x) = Nothing in x
13:19:14 <lambdabot>   *Exception: <interactive>:3:4-21: Irrefutable pattern failed for pattern (D...
13:19:46 <xplat> the representation of a value in WHNF has a few tag bits to indicate which constructor the value has
13:20:12 <eyebloom> Has anyone read and understood the paper "Comprehending Monads" by Philip Wadler?
13:20:21 <xplat> so the function gets rewritten into an if-then tree that checks tag bits, and checks further things if necessary
13:20:33 <dylukes> I thought of an interesting way to meld functional programming and OO actually.
13:20:38 <dylukes> With some syntactic sugar…
13:20:41 <dylukes> And uniqueness types...
13:20:42 <dylukes> >_>
13:20:46 <Eduard_Munteanu> 'case of' actually, I guess.
13:20:50 <xplat> and every time something is inspected that is not already known to be in WHNF, code is inserted to assure it is in WHNF first
13:20:54 <dmwit> dylukes: The canonical paper explaining how to implement Haskell efficiently is the Spineless Tagless G-machine paper.
13:21:11 <dmwit> It's relatively easy reading, and I recommend it if you're interested.
13:21:13 <Eduard_Munteanu> What about uniqueness types in that mix?
13:21:15 <dylukes> dmwit: Well, not interesting in implementing it, just wanted to know that little bit.
13:21:30 <dylukes> Eduard_Munteanu: Just some brain-farts about giving each instance a unique type.
13:21:36 <xplat> eyebloom: i have but it was a long time ago
13:21:37 <dmwit> eyebloom: Maybe you should just ask your real question, instead.
13:21:55 <Eduard_Munteanu> It's not exactly a unique type, but a type for unique values, i.e. stuff which can only be used once.
13:21:59 <dylukes> and change that every time its "modified"
13:22:13 <eyebloom> Well, I'm just having trouble interpretting some of the symbols in the paper.
13:22:30 <dylukes> Eduard_Munteanu: Basically I'm trying to think of how to have "mutable" objects in a pure functional environment.
13:22:45 <xplat> dylukes: the name 'uniqueness types' is already taken
13:22:52 <dylukes> xplat: I'm not trying to "take" it.
13:22:54 <Eduard_Munteanu> Oh, in that case, that's not really OO-specific, it applies to having any mutable values.
13:22:59 <dylukes> Eduard_Munteanu: Sure.
13:23:09 <dmwit> eyebloom: page number?
13:23:12 <dylukes> Anyways, then having functions of the form
13:23:16 <eyebloom> Notably he starts using left facing arrows in comprehensions without explanation.
13:23:30 <dylukes> Object n1 -> …
13:23:34 <eyebloom> Is that just part of a given comprehension grammar?
13:23:35 <dylukes> be sugared for "actions"
13:23:50 <dylukes> as unbound object methods of sorts.
13:23:57 <dmwit> eyebloom: Page 4 seems to define left-facing arrows.
13:24:02 <xplat> eyebloom: the paper assumes that you are already familiar with list comprehensions
13:24:03 <dylukes> Just me thinking a bit...
13:24:33 <dmwit> From the second-to-last line: [t | x <- u] = map (\x -> t) u
13:24:35 <eyebloom> I see so it's a generato
13:24:40 <eyebloom> generator
13:24:44 <dylukes> Eduard_Munteanu: Do you think I could accomplish it in TH?
13:24:51 <dylukes> (which I've been meaning to try for some time now)
13:24:58 <Eduard_Munteanu> AFAIU, you can do mutation (in-place) in Haskell too, it's just the strictness analyzer and the compiler aren't smart enough.
13:25:30 <Eduard_Munteanu> Ah, I don't really know TH.
13:25:40 <eyebloom> @xplat: [t | x <- u] means t for every x in u?
13:25:40 <lambdabot> Unknown command, try @list
13:25:57 <dylukes> Well, the general idea is that any "action" inevitably has the form
13:25:59 <dmwit> eyebloom: For lists, it does.
13:26:09 <dmwit> eyebloom: For other monads, it may have different meanings.
13:26:13 <dylukes> Object n1 -> … -> (return type, Object n2)
13:26:17 <dylukes> and sugar allows for
13:26:24 <dylukes> x = object.doSomething()
13:26:37 <dmwit> eyebloom: What it means is "map (\x -> t) u", and what *that* means depends on what "map" does for the monad you're interested in.
13:26:40 <Eduard_Munteanu> I've only experimented with Agda's syntax thingy, but I'm not sure it goes as far as TH does. Possibly when using reflection.
13:26:55 <eyebloom> dmwit: what is the the general meaning then, or what words do you say in your head when you are reading that formula?
13:27:14 <xplat> dylukes: the sugar would be easy to do, probably not with TH but with a custom preprocessor.  maybe '.' is a bad symbol choice in the context of Haskell though
13:27:22 <Eduard_Munteanu> dylukes: you want to automate renewing your values?
13:27:28 <dmwit> "t for x computed from u" seems like a decent pronunciation.
13:27:36 <dmwit> There is no general meaning.
13:28:25 <dylukes> xplat: Well, not . haha
13:28:38 <dylukes> Eduard_Munteanu: Basically… anything of the form
13:28:44 <fragamus> I have a problem.
13:28:46 <dylukes> return = object.method()
13:28:49 <dylukes> boils down to doing:
13:28:54 <dylukes> 1) reassigning object
13:28:57 <dylukes> 2) returning the value
13:28:58 <Eduard_Munteanu> On a related note, I've wondered whether there could be an extension to the principal typing property to allow inferring of uniqueness, assuming they would be added to the language.
13:29:13 <fragamus> My problem is this:
13:29:21 <fragamus> I'm a newb.
13:29:41 <xplat> dylukes: how do you hope for this to be useful though?
13:29:45 <byorgey> fragamus: hehe
13:29:46 <dylukes> Dunno, just for fun :D
13:29:48 <eyebloom> xplat or dmwit: I encountered in the definition of the strictness monad -- strict f x = if x not equal (parrallel symbol) then f x else(parrallel symbol).
13:30:04 <eyebloom> with seemingly no definition of the parrallel symbol.
13:30:06 <byorgey> fragamus: that's not a problem so much as an opportunity.
13:30:13 <eyebloom> on page 9.
13:30:32 <xplat> eyebloom: _|_ means 'no value'
13:30:37 <dmwit> eyebloom: That's "bottom", the value that represents an infinite loop or other error condition.
13:30:50 <dmwit> Perhaps "value" isn't the right word for it.
13:31:05 <Eduard_Munteanu> And you probably mean perpendicular, rather than parallel ;)
13:31:07 <xplat> eyebloom: it could mean the computation errors or loops forever or runs out of memory or is interrupted by the user or the computer breaks
13:31:21 <eyebloom> dmwit: your right I do :)
13:31:29 <byorgey> "value" is the right word for it if you're talking about denotational semantics, and it isn't if you're talking about operational semantics =)
13:31:33 <eyebloom> I can't spell either.
13:31:40 <dmwit> eyebloom: It's spelled (undefined) in Haskell, or sometimes (error "YOU SCREWED UP").
13:31:42 <fragamus> schranmove = do (mymap,fitness,g) <- get; put (mymap,fitness,g'); return (z)
13:31:49 <dylukes>  xplat One way this could be "useful",
13:31:58 <dylukes> is if you wanted to interface with another language with inherently mutable objects
13:32:01 <dylukes> (for some reason, who knows)
13:32:05 <fragamus> you see, i have a function that takes a g and returns (z,g')
13:32:20 <xplat> dmwit: or other times 'fix id' or 'head $ cycle []'
13:32:24 <fragamus> and i dont know how to cleanly integrate it into the above
13:32:30 <dmwit> Yes, many spellings.
13:32:42 <eyebloom> so how does that function then yield strict evaluation?
13:33:27 <xplat> eyebloom: because if the argument doesn't return anything, the function using it won't return anything either
13:33:28 <dmwit> eyebloom: Saying a function "f" is "strict" simply means that f bottom = bottom.
13:33:50 <dmwit> eyebloom: This isn't always true in Haskell; consider
13:34:00 <dmwit> > let f = const 3 in f undefined
13:34:00 <lambdabot>   3
13:34:10 <xplat> which is the 'information eye view' of what happens when you evaluate the argument before substituting it into the function
13:34:12 <dmwit> So "f" here is not strict.
13:34:37 <dmwit> But we could make it strict:
13:34:50 <Eduard_Munteanu> fragamus: what are you looking for?
13:34:50 <dmwit> > let f x = if x then const 3 x else const 3 x in f undefined
13:34:51 <lambdabot>   *Exception: Prelude.undefined
13:34:56 <Eduard_Munteanu> :t evalState
13:34:56 <lambdabot> forall s a. State s a -> s -> a
13:34:59 <Eduard_Munteanu> Maybe this?
13:35:07 <Shane_> I've been playing with Snap the past few days.  Are there any good references or tutorials for the framework?
13:36:49 <eyebloom> Hmmm... I've been trying to "comprehend" this for a while now, and I'm wondering if there are more fundamental texts I should read before I can fully understand the Wadler paper?
13:37:30 <dmwit> ?google the io monad for people who just don't care
13:37:32 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
13:37:32 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
13:37:37 <dmwit> ?google you could have invented monads
13:37:38 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
13:37:38 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
13:37:52 <dmwit> ?google all about monads
13:37:55 <lambdabot> http://horna.org.ua/books/All_About_Monads.pdf
13:37:55 <lambdabot> Title: All About Monads Contents
13:38:00 <dmwit> Those are my favorites.
13:38:40 <dmwit> The theme they all have in common is that they present a few useful instances of monads first, and the generalization last.
13:38:42 <dmwit> =)
13:38:59 <eyebloom> dmwit: Awesome thanks. Will read.
13:42:46 <fragamus> http://hpaste.org/47016/modify_state_and_return_a_valu
13:43:05 <fragamus> i need a cleaner one of those ^^^
13:43:26 <fragamus> i dont want my code to look like a newb wrote it
13:43:40 <fragamus> and thats a problem because...
13:43:49 <Twey> fragamus: Are you just using State to avoid passing around the g?
13:43:51 <fragamus> im a newb.
13:44:07 <fragamus> no i need monads real hard man
13:44:31 <mreh> am I missing headers for wx or somesuch?
13:44:43 <mreh> aren't they likely to be in the -dev packages
13:45:44 <Eduard_Munteanu> > evalState (do { (x, y) <- get; return y }) (3, 7)
13:45:45 <lambdabot>   7
13:46:00 <Eduard_Munteanu> > execState (do { (x, y) <- get; return y }) (3, 7)
13:46:01 <lambdabot>   (3,7)
13:47:12 <fragamus> not sure i follow eduard
13:47:12 <mreh> don't forget runState!
13:47:36 <Eduard_Munteanu> Well you don't need to use that constructor directly.
13:48:00 <fragamus> yes i was hoping u say that
13:48:18 * Eduard_Munteanu thinks (flip evalState) makes more sense than evalState.
13:49:04 <fragamus> but i cant put it together myself without the explicit constructor
13:49:14 <Eduard_Munteanu> Eh, it probably depends on the context, it probably works better when you go pointfree in the initial state.
13:49:43 <fragamus> is lost
13:49:46 <dylukes> Um, quick question
13:49:57 <dylukes> before I was using simple arithmetic as a grammar/language to play with
13:50:12 <dylukes> Do you guys have any suggestions for a simpler one to play with (and parse/reduce/eval/etc),
13:50:14 <Eduard_Munteanu> fragamus: what exactly do you want to do?
13:50:15 <dylukes> which involves differing types?
13:50:21 <fragamus> < Eduard_Munteanu> > evalState (do { (x, y) <- get; return y }) (3, 7)
13:50:21 <dylukes> so I can try some type safety stuff?
13:50:21 <fragamus> 13:59 < lambdabot>   7
13:50:21 <fragamus> 13:59 < Eduard_Munteanu> > execState (do { (x, y) <- get; return y }) (3, 7)
13:50:32 <fragamus> oops
13:50:38 <Shane_> ?google Write yourself a scheme
13:50:39 <lambdabot> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:50:39 <lambdabot> Title: Write Yourself a Scheme in 48 Hours - Wikibooks, open books for an open world
13:50:46 <Shane_> It's a full tutorial, but that's a nice parsing resource
13:50:54 <fragamus> http://hpaste.org/47016/modify_state_and_return_a_valu
13:51:06 <fragamus> i want to do that ^^^^
13:51:09 <Eduard_Munteanu> dylukes: simpler? I remember some SKI calculus implemented using GADTs on the wiki
13:51:13 <fragamus> but cleaner
13:51:15 <Eduard_Munteanu> (haskellwiki)
13:51:20 <dylukes> SKI calculus...
13:51:22 <dylukes> I'll look that up
13:51:26 <dylukes> without looking at answers!
13:51:27 <ion> fragamus: This may or may not be useful: http://heh.fi/state-monad </shameless_plug>
13:52:02 <ion> Incidentally i’m using randomR as an example.
13:52:24 * Twey prefers randomRs to State.
13:52:48 <fragamus> ty
13:53:10 <ion> @type state . randomR
13:53:11 <lambdabot> forall s a. (Random a, RandomGen s) => (a, a) -> State s a
13:53:33 <mreh> MonadRandom
13:58:45 <dylukes> If I have modules Foo and Bar
13:58:46 <dylukes> can I do
13:58:48 <dylukes> import Foo as A
13:58:52 <dylukes> import Bar as A
13:58:56 <dylukes> er, import qualified*
13:59:05 <dylukes> and have them both put into the same "namespace"?
13:59:19 <fragamus> @type randomR
13:59:20 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:00:39 <parcs> yes
14:02:28 <fragamus> http://hpaste.org/47017/trying_to_do_this_without_expl
14:02:41 <fragamus> i simplified it a little ^^^
14:02:56 <Younder> hi all
14:03:00 <fragamus> i still cant get rid of the explicit constructor
14:06:56 <Eduard_Munteanu> :t randomR
14:06:56 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:07:58 <Eduard_Munteanu> Why use the State thingy anyway? It seems like a pretty trivial use there.
14:08:21 <fragamus> yes put this will help me be a better haskell programmer
14:08:33 <dmwit> http://hpaste.org/paste/47017/trying_to_do_this_without_expl#p47018
14:08:35 <fragamus> i have removed many details
14:08:45 <fragamus> to simplify my question
14:08:46 <dmwit> But give me a second, there's a better way.
14:09:17 <Eduard_Munteanu> Yeah. Another way to put it is 'return' and that stuff already gets you a State s a
14:09:48 <Eduard_Munteanu> :t get
14:09:49 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
14:09:59 <dmwit> fragamus: schrandom ranrange = lift (getRandomR ranRange) -- this is much better
14:10:34 <dmwit> import Control.Monad.Random
14:10:47 <fragamus> askell
14:11:43 <fragamus> wow that seems magical
14:11:50 <fragamus> i must try it
14:12:08 <Eduard_Munteanu> And Control.Monad.Trans I guess.
14:12:16 <dmwit> schrandom :: (Random a, RandomGen g) => (a, a) -> StateT (b, c) (RandT g []) a
14:12:19 <dmwit> Eduard_Munteanu: Nope.
14:12:26 <dmwit> ah
14:12:28 <dmwit> yes
14:12:30 <Eduard_Munteanu> For 'lift'.
14:12:33 <dmwit> I had imported Control.Monad.State for that.
14:12:39 <Eduard_Munteanu> Ah.
14:14:27 <fragamus> that is wild and wonderful if i can make it work
14:14:41 <dmwit> ...in fact, you don't even need the lift at all.
14:14:45 <dmwit> schrandom = getRandomR
14:15:16 <Eduard_Munteanu> In fact you don't need schrandom...
14:15:19 <Eduard_Munteanu> getRandomR :P
14:15:20 <dmwit> yep =)
14:15:53 <Eduard_Munteanu> :t getRandomR
14:15:54 <lambdabot> forall a (m :: * -> *). (MonadRandom m, Random a) => (a, a) -> m a
14:20:16 <fragamus> how in the blue blazes did you guys learn this crap
14:20:42 <dmwit> Same as you, we whacked our head against the wall until the wall broke.
14:21:56 <fragamus> i wrote a bind operator with great effort only to find that StateT [] did it all for me
14:24:05 <fragamus> does anyone really ever have to write their own bind operator
14:24:15 <dmwit> Well, as edwardk says, you can judge how good your ideas are by how long ago mathematicians came up with them. =)
14:24:20 <dmwit> fragamus: Not very often, no.
14:24:37 <dmwit> Every once in a while someone comes along with something truly new, like the quantum computation monad, and then they do. =)
14:24:54 <fragamus> wow
14:25:03 <fragamus> id love to see that monad
14:25:22 <dmwit> http://hackage.haskell.org/package/QIO
14:25:52 <fragamus> i bet it runs a long time
14:25:57 <dmwit> http://hackage.haskell.org/packages/archive/QIO/1.0/doc/html/QIO-QioSyn.html#t:QIO in particular
14:27:22 <Favonia> interesting...
14:27:23 <fragamus> so for quantum interference there must be interaction between states in the list
14:28:06 <tswett> It would be neat if a classical computer could be turned into a quantum computer merely by using Haskell.  :)
14:28:18 <cheater897> dmwit, is that an emulation of the quantum computing, or is it for interfacing with the dwave?
14:29:14 <dmwit> Given its dependencies, I doubt very much that it's an interface to another device.
14:29:16 <Eduard_Munteanu> No, but there's that exhaustive search of an infinite set... lemme find a link. Pretty amazing stuff..
14:29:37 <Eduard_Munteanu> @google exhaustive cantor
14:29:38 <lambdabot> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
14:29:38 <lambdabot> Title: Seemingly impossible functional programs « Mathematics and Computation
14:29:46 <Eduard_Munteanu> That ^.
14:30:49 <Favonia> tswett: I think it will still be neat if we can run the same code on both kinds of computers... with simulation on classical computers, of course :P
14:31:10 <tswett> Sure.  The classical computers will just take a while to do it.  :P
14:31:32 <Twey> Potentially infinite time.
14:31:46 <Twey> AIUI.
14:32:22 <tswett> Well, the amount of memory you need is exponential in the number of qubits you want to simulate.
14:32:48 <fragamus> I have been corresponding with Dr. David Deutsch about twice a year for about five years
14:32:58 <tswett> Actually, that's only if you use floating-point numbers to store all the amplitude thingers...
14:33:01 <Eduard_Munteanu> Really? Nice.
14:33:12 <fragamus> it is all so mind boggling
14:33:19 <Favonia> Twey: quantum computers cannot guarantee the time bound in general either--- it is more like a randomized algorithm with some small error rate
14:33:23 <verement> newb syntax question... how do I make a qualified reference to a function in another module that consists of only punctuation?
14:33:41 <Eduard_Munteanu> :t (Prelude..)
14:33:41 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:33:44 <Twey> verement: arg1 Foo.+= arg2
14:33:46 <Eduard_Munteanu> verement: you mean that?
14:33:53 <fragamus> i mean jesus, you'd think the universe would run out of storage
14:34:00 <cheater897> While QIO realises the infrastructure we need to control a quantum computer from Haskell, we don’t have to wait until the physicists get their act together, we can use the same interface to run a quantum simulator. Our approach is inspired by the 2nd authors work with Wouter Swierstra on functional specifications of IO [11]. Indeed, we provide some choice here: we can embed QIO into the IO monad using pseudo-random numbers to s
14:34:00 <cheater897> imulate quantum randomness, we can statically calculate the probability distribution of possible results given a quantum program and we can simulate the classical subset of our quantum operations directly. The latter is useful for testing components efficiently since the quantum simulation generates a considerable overhead.
14:34:00 <Twey> The whole thing behaves as an operator
14:34:11 <Twey> Qualification and all
14:34:17 <cheater897> wow i love that idea
14:34:18 <magicman> > ((+1) Prelude.. (*2)) 4
14:34:18 <lambdabot>   Not in scope: `Prelude..'
14:34:28 <verement> yes... but what if the function is, say, (.&.) ?
14:34:28 <magicman> v_v
14:34:32 * Eduard_Munteanu makes a weird connection between quantum and comonadic somehow
14:34:45 <Twey> verement: a Data.Bits..&. b
14:34:51 <Twey> Nothing special
14:35:01 <dylukes> Is there any paper explaining haskell's printf ._.?
14:35:05 <dylukes> So confused my it...
14:35:07 <dylukes> by*
14:35:08 <Twey> dylukes: It's just a typeclass
14:35:21 <Twey> :t printf
14:35:21 <dylukes> How does it manage to have String OR IO
14:35:22 <lambdabot> forall r. (PrintfType r) => String -> r
14:35:22 <dylukes> ._.
14:35:27 <dylukes> Yeah, how can r adopt either type?
14:35:31 <Eduard_Munteanu> I believe it's the variadic args that's confusing, that's all.
14:35:31 <Twey> dylukes: PrintfType has instances for both String and IO
14:35:38 <verement> ok, thanks!
14:35:52 <shachaf> dylukes: You don't really need a paper -- just read the code.
14:35:54 <Twey> As well as a function
14:35:59 <shachaf> @source Text.Printf
14:36:00 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
14:36:12 <Eduard_Munteanu> dylukes: r can be some (a -> ...) and so on
14:36:19 <shachaf> It's pretty clear, even though it does some silly things to stay Haskell 98.
14:36:46 <dylukes> heh
14:36:52 <shachaf> @ty read -- How can read return either Int *or* Bool?
14:36:52 <lambdabot> forall a. (Read a) => String -> a
14:37:02 <Twey> PrintfType has instances for String, IO, and (PrintfArg a, PrintfType r) => a -> r
14:37:24 <Twey> Where PrintfArg is a class of things that can be interpolated using printf
14:37:35 <dmwit> > printf "a b c" "d e f" :: String
14:37:36 <lambdabot>   "a b c*Exception: Printf.printf: formatting string ended prematurely
14:37:39 <dylukes> wait
14:37:45 <dylukes> what about the variable argument size D:
14:37:52 <Twey> dylukes: We just covered that :þ
14:37:55 <dmwit> That's what the last instance is for.
14:37:56 <Eduard_Munteanu> > printf "%s" "Hello"
14:37:57 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:37:57 <lambdabot>    `GHC.Show.Show a'
14:37:57 <lambdabot>      a...
14:38:00 <dmwit> The (a -> r) instance.
14:38:04 <Twey> dylukes: One of the instances of PrintfType is another function.
14:38:11 <Eduard_Munteanu> > printf "%s" "Hello" :: String
14:38:11 <lambdabot>   "Hello"
14:38:12 <dylukes> Twey: hah!
14:38:14 <dylukes> I see :)
14:38:16 <dylukes> neat.
14:38:23 <Twey> See?  Simple, huh :þ
14:38:39 <shachaf> dylukes: The simple way to see this is to unify String -> r with String -> Int -> String.
14:38:49 <shachaf> See, types aren't complicated. :-)
14:39:13 <dmwit> > let unwords = (>>= printf "%s ") in unwords ["Hello,", "world!"]
14:39:13 <lambdabot>   Ambiguous type variable `b' in the constraints:
14:39:14 <lambdabot>    `GHC.Show.Show b'
14:39:14 <lambdabot>      a...
14:39:19 <dmwit> > let unwords = (>>= printf "%s ") in unwords ["Hello,", "world!"] :: String
14:39:20 <lambdabot>   "Hello, world! "
14:40:09 <shachaf> > unwords ["Hello,", "world!"] -- Almost.
14:40:10 <lambdabot>   "Hello, world!"
14:40:27 <dmwit> yep, throw an init on front
14:40:36 <dmwit> But I felt that would be a bit much in the way of \bot-spam.
14:40:53 <shachaf> > let unwords = init . (>>= printf "%s ") in unwords [] :: String
14:40:54 <lambdabot>   Ambiguous type variable `a' in the constraint:
14:40:54 <lambdabot>    `Text.Printf.PrintfArg a'...
14:41:01 <Favonia> dylukes: FYI: AFAIK it is also possible to abuse Template Haskell to generate a printf function which forces the type checking at compile-time
14:41:12 <shachaf> > let unwords = init . (>>= printf "%s ") in unwords ([]::[String]) :: String
14:41:14 <lambdabot>   "*Exception: Prelude.init: empty list
14:41:24 <dylukes> Oh, other thing
14:41:24 <dmwit> > let safeInit [] = []; safeInit [x] = []; safeInit (x:xs) = x : safeInit xs in safeInit []
14:41:25 <lambdabot>   []
14:41:36 <dylukes> with Parsec, is there any way I can make it throw an error if there's "extra"
14:41:40 <dylukes> Since,
14:41:42 <dylukes> something like
14:41:44 <dylukes> "!T 10"
14:41:45 <dmwit> dylukes: eof :: Parser
14:41:54 * hackagebot waitfree 0.1 - A wrapping library for waitfree comnputation.  http://hackage.haskell.org/package/waitfree-0.1 (YoichiHirai)
14:41:54 <dylukes> mmk
14:42:01 <dylukes> I'll just add >> eof
14:42:06 <dmwit> yep
14:42:17 <Eduard_Munteanu> Favonia: hm that's neat. AFAIK, even GCC does typechecking on variadic args in printf-like functions.
14:42:30 <Twey> Yeah
14:42:39 <Twey> We have printf-th though
14:42:39 <dmwit> That sounds halting-problematic.
14:42:48 <dylukes> dmwit: Hm, not sure how to mix this in properly
14:42:50 <dylukes> I have
14:42:52 <dmwit> I assume it only does those checks for instances where the first argument to printf is a static string?
14:42:58 <Twey> Yeah
14:43:08 <dylukes> expr = P.buildExprParser table term
14:43:09 <dylukes>     <?> "expression"
14:43:16 <dylukes> and I want to add eof to the end of an expr :\
14:43:19 <dylukes> actually, nmd
14:43:24 <dylukes> i'll add it elsewhere
14:43:25 <dmwit> expr >> eof
14:43:42 <Favonia> dmwit: I guess so. well usually it is a static string, isn't it?
14:43:43 <dmwit> expr <* eof, actually, is probably what you want
14:43:45 <dmwit> :t (<*)
14:43:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
14:43:56 <dylukes> dmwit: In my parse function
14:43:58 <dylukes> something like
14:44:09 <dylukes> parse (expr <* eof) "()" string
14:44:17 <dmwit> Favonia: I guess it probably is in almost all cases, yeah.
14:44:27 <dmwit> dylukes: Looks good to me.
14:44:32 <dylukes> applicative style is starting to make more sense… but I never quite got *what* an applicative is.
14:44:44 <dylukes> >_>
14:45:02 <c_wraith> dylukes: why do you think that has more of an answer than "*what* a monad is"?
14:45:09 <dylukes> …no >_>...
14:45:12 <Eduard_Munteanu> Well, it's a sort of bind-less monad.
14:45:16 <dylukes> But at least with a monad I have some "general" idea
14:45:18 <dylukes> but oh well, yeah
14:45:19 <dylukes> anyways
14:45:19 <dylukes> https://gist.github.com/989844
14:45:21 <dylukes> there.
14:45:26 <c_wraith> dylukes: it has the exact same answer, in fact.  "It's a pattern of composition"
14:45:27 <dylukes> untype-safe parser.
14:45:36 <Favonia> :t (_>)
14:45:36 <lambdabot> Pattern syntax in expression context: _
14:45:39 <dylukes> c_wraith: good enough :D
14:45:44 <dylukes> anyways, Eduard_Munteanu
14:45:48 <dylukes> copumpkin left, so...
14:45:55 <dylukes> seem reasonable to you? As an "unsafe" parser
14:45:56 * hackagebot collada-types 0.1 - data exchange between graphic applications  http://hackage.haskell.org/package/collada-types-0.1 (TillmannVogt)
14:46:58 <dylukes> rep, forgot Eq in my op table.
14:47:02 <Eduard_Munteanu> Do note copumpkin knows way more than I do, I suppose :)
14:47:34 <dylukes> yep heh
14:48:15 <fragamus> so... you guys suggested this:
14:48:15 <fragamus> schrandom :: (Random a, RandomGen g) => (a, a) -> StateT (b, c) (RandT g []) a
14:48:42 <fragamus> and so you are saying i should restructure my monad
14:48:47 <dmwit> Yes.
14:48:49 <dylukes> I'll use EmptyDataDecls I think though,
14:48:56 <dylukes> so I'm not really "attaching" to haskell's type system
14:48:56 * hackagebot collada-output 0.4 - Generate animated 3d objects in COLLADA  http://hackage.haskell.org/package/collada-output-0.4 (TillmannVogt)
14:49:02 <dmwit> There is no reason to mix up the two kinds of state you have (a random generator and the rest of your stuff).
14:49:11 <Eduard_Munteanu> Style-wise it looks good.
14:49:14 <fragamus> and instead of keeping g in my state, It should be managed by RandT
14:49:18 <fragamus> right?
14:49:24 <dmwit> Yes.
14:50:13 <fragamus> dang i never stacked monad transformers like that before
14:50:25 <fragamus> im going to try
14:53:45 <dylukes> https://gist.github.com/989857
14:53:48 <dylukes> On line 72...
14:53:52 <dylukes> I think that looks pretty good :)
14:54:10 <Eduard_Munteanu> Look what showed up in #agda just a few minutes ago... < ppavelV6> Towards a formally verified functional quantum programming language: http://www.cs.nott.ac.uk/~asg/pdfs/thesis.pdf
14:54:17 <dmwit> The type for typecheck looks a bit dangerous.
14:54:39 <dylukes> dmwit: err, should be Either TypeError Expr a
14:54:41 <dylukes> :P
14:54:55 <shachaf> dmwit: As does the implementation.
14:55:02 <dmwit> typecheck :: RawExpr -> Either TypeError (forall a. (Expr a -> r) -> r)
14:55:10 <dylukes> ...what?
14:55:14 <dylukes> ._.
14:55:32 <dmwit> dylukes: You surely can't return an Expr that's polymorphic in its type argument.
14:55:38 <dmwit> It's either going to be a TNat or TBool.
14:55:41 <dylukes> Right.
14:56:14 <dmwit> typecheck :: RawExpr -> Either TypeError (exists a. Expr a) -- would be nicer, but "exists" doesn't exist =)
14:57:44 <dylukes> Hm… still doesn't make sense to me
14:57:50 <dylukes> for all never really did...
14:57:53 <dylukes> mind explaining briefly?
14:58:00 <dmwit> sure
14:58:13 <dmwit> You could also write something like
14:58:25 <shachaf> dmwit: Weren't you the one saying recently that "exists" is an unneeded keyword when you can always use "forall"? :-)
14:58:29 <dmwit> typecheck :: RawExpr -> Either TypeError (Either (Expr TNat) (Expr TBool))
14:58:34 <dmwit> And that might be the easiest of all.
14:58:45 <dmwit> shachaf: Oh, no. I want exists.
14:58:53 <shachaf> Aha. Must've been someone else.
14:59:05 <dmwit> shachaf: I *was* the one recently saying that we don't have exists because *other* people say we don't need it because forall does it.
14:59:07 <dylukes> I mean, explain what for all *means*
14:59:09 <c_wraith> well, you can do stuff exists can with forall, but it's a lot clumsier.
14:59:14 <shachaf> What's stopping exists from being implemented as a GHC extension?
14:59:20 <Saizan> data Exists f = forall a. Exists (f a)
14:59:59 <dmwit> dylukes: forall a means that you can substitute any type for "a" and the expression will still have that type
15:00:14 <Eduard_Munteanu> It's wrapped.
15:00:25 <fragamus> what i had before: type CreatureList a = StateT Creature [] a
15:00:26 <dylukes> Btw, which extension do I need to use?
15:00:32 <Eduard_Munteanu> So you don't really have some type 'a' naked and quantified by 'exists'.
15:00:32 <dylukes> to make it work?
15:00:33 <dmwit> dylukes: So, for example, "RawExpr -> Expr a" is actually short for "forall a. RawExpr -> Expr a", which means it must be true that in particular "RawExpr -> Expr ()", for example.
15:00:47 <dylukes> mmk.
15:00:47 <fragamus> what i have now: type CreatureList a = StateT Creature (RandT g []) a
15:00:56 <thoughtpolice> shachaf: probably not much. i think there may be a ticket somewhere about it actually...
15:01:00 <chalkboard159> hi all
15:01:00 <fragamus> is this right ^^^
15:01:01 <dylukes> so why (for all a. (Expr a -> r) -> r)
15:01:07 <dylukes> Why the function in there >_>?
15:01:14 <dmwit> fragamus: Seems reasonable.
15:01:20 <dylukes> why not just Expr a
15:01:35 <Eduard_Munteanu> dylukes: ExistentialQuantification IIRC
15:01:41 <dmwit> dylukes: Ah, that's the continuation-passing encoding of "exists" in "forall".
15:01:45 <dylukes> Eduard_Munteanu: It also wants ImpredicativeTypes now
15:01:57 <dylukes> dmwit: Mind explaining…?
15:02:01 <Eduard_Munteanu> Hrm.
15:02:15 <fragamus> thank you dim, ed  I think I can do it from here
15:02:18 <dmwit> dylukes: This says, given that you hand me a function that can handle any kind of Expr, even Expr TNat and Expr TBool, I can hand you back the value you would get by applying that function to the expression I'm building.
15:02:25 <Eduard_Munteanu> Yeah, I suppose it is impredicative.
15:02:31 <chalkboard159> I have to write a function which will find the longest maximum subsequence, for example: for [1,2,3,2,4,1,2,3,5,7,4,9] the result is [1,2,3,4,5,7,9]
15:02:37 <chalkboard159> I coded something like that: http://pastebin.com/dcy7xbXr
15:02:49 <chalkboard159> and I'm wondering is it any chance to reduce number of reverse here
15:02:49 <c_wraith> longest increasing subsequence?
15:03:15 <dmwit> Wasn't there a very nice article on this exact problem on haskit recently?
15:03:20 <Eduard_Munteanu> Basically every forall that's not purely within a (->) amounts to impredicativity, AFAIU
15:03:34 <dylukes> … ._.
15:03:37 <dylukes> impredicativity ??
15:03:39 <c_wraith> that problem is one of the first problems bird's new book covers
15:03:40 <chalkboard159> c_wraith, sequence of successive maxima
15:03:41 <dylukes> *sigh*
15:04:02 <chalkboard159> I coded something like that: http://pastebin.com/dcy7xbXr
15:04:07 <c_wraith> Eduard_Munteanu: that's not the only way to get impredicativity, of course.
15:04:24 <chalkboard159> and I'm wondering if it's possible to reduce number of reverses and how this code should look like with foldL
15:04:30 <c_wraith> dylukes: impredicative just means "type variables can be instantiated with polymorphic types"
15:04:58 <dylukes> gotcha.
15:05:33 <dylukes>     Couldn't match expected type `forall a. (Expr a -> r) -> r'
15:05:34 <dylukes>                 with actual type `Expr TBool'
15:05:35 <dylukes> >_>
15:05:37 <dylukes> lemme paste
15:05:39 <c_wraith> dylukes: by default, Haskell's type system is rank-1, and predicative.  All types variables in function signatures are instantiated to monomorphic types at the site of the function call.
15:05:43 <Eduard_Munteanu> Which happens not to be the case for a -> forall b. b and such stuff, I guess.
15:05:56 <dylukes> https://gist.github.com/989876
15:05:57 <dylukes> here
15:06:05 <dylukes> I don't know what rank-1 means :(
15:06:27 <dmwit> Right (\f -> f (ELitBool True))
15:06:32 <c_wraith> higher-rank types are a limited form of allowing a type variable to be instantiated with a polymorphic type.
15:06:41 <Eduard_Munteanu> I'm not yet sure how or why (->) is privileged though.
15:06:45 <dylukes> dmwit: So… it's not a "clean" transition, I have to return it weirdly?
15:06:54 <dmwit> dylukes: The rank of a type is how many arrows you have to go to the left of to get to a quantifier.
15:06:57 <dmwit> dylukes: yes
15:07:35 <dylukes> c_wraith: still doesn't work .__.
15:07:38 <dmwit> dylukes: For example, forall a. (a -> a -> a) is rank 1, forall b. (forall a. a -> a) -> b is rank 2.
15:08:44 <dylukes>     Couldn't match expected type `t0 -> t1'
15:08:45 <dylukes>                 with actual type `forall a. (Expr a -> r) -> r'
15:08:58 <dylukes> The lambda expression `\ f -> f (ELitBool True)' has one argument
15:08:58 <dylukes> but its type `forall a. (Expr a -> r) -> r' has none
15:09:18 <dylukes> egg, i need to go for a moment
15:09:22 <dylukes> I'll figure this out when I get back.
15:11:02 <Eduard_Munteanu> c_wraith: so is there any particular reason why (->) isn't considered a constructor which makes inner foralls impredicative?
15:11:09 <chalkboard159> anyone please could give mesme hints how to do it with foldl?
15:13:30 <Cale> > map head . groupBy (>) $ [1,2,1,3,1,2,1,4,2,5]
15:13:32 <lambdabot>   [1,2,3,4,5]
15:14:25 <chalkboard159> @src groupBy
15:14:26 <lambdabot> groupBy _  []       =  []
15:14:26 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
15:14:26 <lambdabot>     where (ys,zs) = span (eq x) xs
15:15:14 <Cale> > groupBy (>) $ [1,2,1,3,1,2,1,4,2,5]
15:15:15 <lambdabot>   [[1],[2,1],[3,1,2,1],[4,2],[5]]
15:15:30 <Favonia> Cale: you're abusing current implementation :P
15:15:42 <Cale> I'm making good use of the definition.
15:16:20 <Cale> It's a good definition, and people often ignore the fact that it's meaningful and useful for non-equivalence-relations
15:16:32 <Favonia> AFAIK by definition it assumes "eq" is just an equality test
15:16:41 <chalkboard159> Cale, my ghci says "groupBY not in the scope"
15:16:50 <Cale> :m + Data.List
15:17:05 <Cale> also, groupBy, with a little y
15:17:06 <dylukes> I need a small mental break right now, sory
15:17:39 <chalkboard159> ok import Data.List helps :)
15:18:04 <chalkboard159> but still wondering how to achieve this with foldl
15:18:14 <Cale> Favonia: I think the Report does say that, but it's stupid for it to do so.
15:18:37 <chalkboard159> foldr is easy (already done it), but I stuck on the foldl
15:18:48 <Cale> Practically speaking, the implementations must implement groupBy with this semantics, or people will complain.
15:18:52 <Favonia> Cale: I think it is possible that in another implementation "span (eq x) xs" could be "span (`eq` x) xs"
15:19:27 <a|i> is there production-ready chat server in haskell? by production-ready I mean production-ready, not weeneknd projects, not things that work in theory and academia.
15:19:34 <Cale> yeah, but that would be annoying and unnatural :) Better to put the list elements into the comparator in the order that they occur in the list.
15:19:41 <c_wraith> Eduard_Munteanu: because (->) allows rank-n polymorphism, which is more limited than full impredicative polymorphism.  Note that impredicative implies Rank-N types are supported, but more in addition.  It's an artifact of type checker implementation that the more limited forms get special treatment, as they're easier to handle.
15:20:01 <Cale> Favonia: It would only be valid to do that if you were relying on the assumption that eq was symmetric.
15:20:11 <Cale> (which you shouldn't, even if the Report says it's okay)
15:20:13 <Eduard_Munteanu> Oh, thanks, it makes sense now.
15:20:31 <Eduard_Munteanu> I thought ImpredicativeTypes and RankNTypes were orthogonal.
15:21:19 <chalkboard159> or myabe it's impossible to do such a think which foldl?
15:21:22 <Favonia> Cale: hmm I would prefer making the Report stricter or inventing another function :P
15:21:57 <Cale> Favonia: I would prefer just removing that assumption from the Report.
15:22:07 <Cale> groupBy is good as-is in the implementations
15:22:30 <Cale> It does something quite sensible when given an arbitrary relation.
15:22:35 <fragamus> uh, i am having trouble with: import Control.Monad.Random
15:22:46 <dmwit> cabal install MonadRandom
15:23:01 <fragamus> could not find module
15:23:07 <fragamus> doh
15:23:25 <Eduard_Munteanu> @hoogle Random
15:23:25 <lambdabot> module System.Random
15:23:25 <lambdabot> System.Random class Random a
15:23:25 <lambdabot> package random
15:23:31 <Eduard_Munteanu> Hrm, no.
15:24:03 <fragamus> no?
15:24:10 <fragamus> i need RandT
15:24:20 <Favonia> Cale: by making the report stricter I meant removing the assumption :P so I at least 50% agree with you :D
15:24:27 <dmwit> fragamus: Did you install MonadRandom?
15:24:35 <fragamus> doing it now
15:24:38 <paper_cc> can anyone suggest the "next" thing to read about dependent types after the "LambdaPi" paper ("A tutorial implementation ...")? I feel quite lost even reading the Agda tutorial :(
15:25:27 <dmwit> paper_cc: http://www.seas.upenn.edu/~cis500/current/sf/html/index.html
15:25:34 <Cale> groupBy p xs satisfies the following laws: 1) concat (groupBy p xs) = xs. 2) Each element (u:us) of groupBy p xs satisfies all (p u) us, and 3) map length (groupBy p xs) is lexicographically maximal among all possible results satisfying the first two conditions.
15:28:44 <Eduard_Munteanu> paper_cc: I think the Epigram introduction is nice.
15:29:18 <Cale> chalkboard159: http://hpaste.org/47019/analogous_version_using_foldl
15:30:06 <Eduard_Munteanu> paper_cc: http://strictlypositive.org/epigram-notes.ps.gz
15:30:08 <paper_cc> dmwit: thanks, that should be useful. it looks to focus on proving things (Coq) rather than actually using the same techniques for actual programming (Agda, Epigram, <anything else?>), though.
15:30:09 <fragamus> yeah it worked after i added MonadRandom to dependencies for my package in Leksah
15:32:02 <fragamus> does anyone else use Leksah
15:34:21 <Eduard_Munteanu> paper_cc: note there's #agda if you need help
15:34:23 <paper_cc> Eduard_Munteanu: I think I've already tried reading it a while before, but... maybe it'll be better this time =)
15:35:55 <Eduard_Munteanu> Well it might help to ask specific questions if you have trouble with something in particular.
15:36:27 <paper_cc> Eduard_Munteanu: and it does feel better after you understood what the whole thing is about (that's what seems really hard to do)
15:37:08 <paper_cc> Eduard_Munteanu: well, thanks a lot :)
15:37:33 <Saizan> maybe you should try to get familiar with Curry-Howard in a simply-typed language like haskell first
15:39:17 <chalkboard159> @src map
15:39:18 <lambdabot> map _ []     = []
15:39:18 <lambdabot> map f (x:xs) = f x : map f xs
15:41:34 <Eduard_Munteanu> Yeah, and I suppose once you get values vs types vs kinds as in Haskell, it's easier to grok more general stuff (the tower of sorts).
15:42:16 <chalkboard159> btw, is it possible to define map by using foldr?
15:42:29 <mauke> of course
15:42:36 <nwf> 's there anyone willing to help a GADT-noob try to embed some simple-ish static proofs? :)
15:42:45 <paper_cc> Saizan: it looks like I understood enough of logic/types not to get lost in various Haskell's type system extensions and just a bit more, but that's all.
15:42:55 <chalkboard159> mauke, could You please give me any hint?
15:43:01 <mauke> chalkboard159: where are you stuck?
15:43:21 <chalkboard159> I have no idea how to start with
15:43:44 <chalkboard159> foldr generates only one element, map - whole list
15:43:52 <Eduard_Munteanu> chalkboard159: how about what the folding function's type is?
15:44:01 <Saizan> paper_cc: but do you know how types and terms relate to propositions and proofs?
15:44:09 <chalkboard159> :t foldr
15:44:10 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:44:20 <mauke> chalkboard159: a list is a value
15:44:23 <Eduard_Munteanu> chalkboard159: one element is one thing, but that thing can be multiple things :)
15:44:29 <nwf> chalkboard159: What about the function "foldr (:) []" ?
15:45:07 <kutsurak> Is anyone willing to take a look at my first try at a small Haskell program and make comments, or is this the wrong place to ask something like this?
15:45:22 <Zao> kutsurak: It's a fine place, assuming you use a paste site for the program.
15:45:23 <shachaf> kutsurak: Go ahead and post it.
15:45:25 <Zao> (hpaste)
15:45:26 <Eduard_Munteanu> So a -> b -> b. Now make it less general.
15:45:38 <chalkboard159> nwf, ok, so i can generate whole list
15:45:59 <Eduard_Munteanu> @where hpaste
15:45:59 <lambdabot> http://hpaste.org/
15:46:23 <kutsurak> Thanks! It's a first try at the word count program. There are some unfinished things, but it is sort of functional: http://pastebin.com/HCHv51ej
15:46:47 <chalkboard159> but how to treat each element which a function, like map does?
15:47:07 <Botje> kutsurak: i'd look at the unwords function for line 8
15:47:50 <kutsurak> right... totally forgot about that.
15:47:58 <Eduard_Munteanu> > foldr (:) [] [1,2,3,4]
15:47:58 <lambdabot>   [1,2,3,4]
15:48:04 <chalkboard159> well, got it ;]
15:48:05 <nwf> chalkboard159: Well, expanding the function I gave you a bit, it's "foldr (\e es -> e : es) []", right?
15:48:11 <chalkboard159> foldr ((:) . f) []
15:48:24 <Botje> kutsurak: line 31 can be written as getCounter opt = error ("Unrecognized option " ++ opt)
15:48:26 <chalkboard159> it seems to work ;]
15:49:22 <kutsurak> Botje: wouldn't there be a conflict with the type of the getCounter?
15:49:22 <paper_cc> Saizan: I sort of get the idea (inhabitant of a type <-> proof of a proposition), but this isn't about any formal treatment; different logic systems just look too scary and big a subject (or maybe I haven't got the right references)
15:49:35 <Botje> kutsurak: no, error has type String -> a
15:50:02 <kutsurak> Botje: Ok, I'll keep it in mind. Thanks!
15:50:36 <Botje> as for lines 51 and 52, partition will come in handy there
15:52:26 <Eduard_Munteanu> paper_cc: you can pretty much treat Agda's underlying logic like normal stuff, except you don't have excluded middle (by default). And it's constructive.
15:52:34 <Botje> also, you might want to swap the order in which flag and file are assigned in parseArgs
15:53:08 <Botje> as I read it now, you first do all bytes of all files, then all lines, then all words of all files
15:53:15 <Botje> but that's a personal taste :)
15:53:47 <Botje> good job for a first script, now go and write a compiler ;)
15:53:47 <Eduard_Munteanu> paper_cc: and that's really enough to do quite a bit of math.
15:53:51 <Botje> << bedtime
15:53:58 <kutsurak> Botje: heh, thanks :)
15:54:07 <paper_cc> Eduard_Munteanu: middle?
15:54:48 <Eduard_Munteanu> paper_cc: a v ~a
15:55:40 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Excluded_middle
16:01:10 <paper_cc> Eduard_Munteanu: ok (I just didn't know the English name for it)
16:01:45 <Eduard_Munteanu> Well yeah, it's different in my native language too... more like "excluded third"
16:06:22 <paper_cc> Eduard_Munteanu: but it relates well to bottom _|_ (== false, if I get it right)
16:08:04 <ddarius> Tertium non datur.
16:11:41 <shachaf> alex-shpilkin: In what sense do you mean _|_ == false?
16:12:26 <Bfig> hello, what's up. can i ask somebody with linux/unix hugs to run a test case for me? it's small harmless code but neither i or my university linux servers have hugs (i have winhugs but apparently the bastards decided to use a test case designed for a unix system). for some reason it is failing but i can't see where the problem is, ie, it works perfectly here
16:12:29 <Eduard_Munteanu> Hm, ddarius is around. I might as well ask something myself (but last time I did it was a different time of the day)... :)
16:12:44 <barshirtcliff> any Data.JSON2 users know how to render json from a string (as returned from a server) into an appropriate algebraic type?  the example on the documentation seems incomplete to me.
16:13:16 <Bfig> if anyone's willing to test it i'll send the program thru email along with the unix-formatted test case
16:13:45 <Bfig> thanks in advance
16:14:39 <barshirtcliff> I guess what I need to use is the read method, but it gives me *** Exception: Prelude.read: no parse, no matter what.
16:14:45 <Eduard_Munteanu> Has any programming language been considered such that the programmer would only write types and have the compiler infer code? The idea is the derivation of the actual implementation should be trivial, or even unique up to some constants. The idea is maybe this might just provide extra assurance wrt to what you get.
16:15:19 <Eduard_Munteanu> It would force the programmer to use fine-grained types.
16:15:31 <Bfig> Eduard_Munteanu, are you saying there is a single program for a certain choice of variables?
16:15:33 <Eduard_Munteanu> So have #haskell people seen anything like that ever discussed?
16:15:56 <m3ga> Eduard_Munteanu: djiin? http://lambda-the-ultimate.org/node/1178
16:16:01 <Eduard_Munteanu> Bfig: no, there's a set of programs parametrized by some constants. For example "Hello World" is parametrized by the actual message.
16:16:16 <dmwit> My colleague is working on that a bit.
16:16:21 <dmwit> http://www.cis.upenn.edu/~posera/
16:16:25 <Eduard_Munteanu> The solution might be unique up to some constants.
16:16:57 <mun> is this sentence technically correct? "the function returns the value..." or should it be "the function when applied to x returns the value..". a function doesn't return a value without application, right?
16:17:16 <Peaker> mun: a function is a value
16:17:30 <Peaker> mun: if you take a function and do not apply it, you get the function itself, which is a value
16:17:39 <Eduard_Munteanu> dmwit: I see, that is a bit related to this.
16:17:48 <Peaker> mun: if you apply it you get a different type of value (its result type)
16:18:19 <Peaker> mun: Saying "the function returns" is valid, and means "when applied"
16:18:33 <mun> Peaker, okay. thanks
16:18:40 <Bfig> Eduard_Munteanu, it is parametrized by constants as long as you have the program written previously....
16:18:50 <Bfig> Eduard_Munteanu, it's called a function, ya know?
16:19:31 <Bfig> also, type-dependent output already exists. polymorphism and function overloading
16:20:01 <Eduard_Munteanu> Consider     IO ()     vs     SomeTypeExactlyDescribingMyBehaviorUpToSomeConstants
16:20:22 <alex-shpilkin> Eduard_Munteanu: actually it's 3AM here now, so I might as well go to sleep =)
16:20:29 <Bfig> consider (generic construct) vs (a program written by relying all the info on types)
16:20:31 <Eduard_Munteanu> Heh.
16:21:00 <Bfig> Eduard_Munteanu, i know something that resembles this though, but don't kid yourself, you need all the information that is required to build the programs to be written previously.
16:21:17 <Eduard_Munteanu> Bfig: oh, in that sense I know.
16:21:31 <Eduard_Munteanu> I know it's probably more work than following a traditional approach.
16:21:45 <Eduard_Munteanu> This is targeted more towards verified software than anything else.
16:21:53 <Bfig> Eduard_Munteanu, behold the monstrosity that is c5: http://www.fing.edu.uy/~jcabezas/c5/c5book/index.html
16:22:40 <Bfig> the whole OPM machine at the end is based on constructing the program on types and then parametrizing them
16:22:51 <Bfig> this leads to a confucksion of the nine devils
16:23:42 <Bfig> if you want i can give you a program source that does some basic text rendering and you'll see that while it's relatively elegant you still are programming everything indirectly
16:24:07 <Bfig> by basic text rendering i mean exactly this: http://www.fing.edu.uy/inco/cursos/dgraf/oblig/oblig2011/oblig2011.html
16:24:26 <Eduard_Munteanu> Oh, a dependently typed flavor of C? Heh.
16:25:02 <Eduard_Munteanu> I see.
16:25:40 <Eduard_Munteanu> Well, the reason I asked this is I sometimes think "couldn't this code be more dependently-typed", say, in Agda.
16:26:01 <Eduard_Munteanu> *dependently-typed?
16:26:33 <Bfig> i wouldn't know because i can barely understand the ramblings of the crazy mofo who wrote that compiler but in general the c5 code is awful
16:26:38 <Eduard_Munteanu> So it's not that much about elegance but rather about being sure you covered all aspects.
16:31:45 <djahandarie> I think I'm just going to stuff all these orphans in a package and call it a day
16:35:22 <nkpart> I made a little hoogle REPL if anyone's interested: https://gist.github.com/990015
16:36:54 <ddarius> nkpart: Doesn't hoogle already have a commandline interface as well as lambdabot (as well as GoA.)
16:37:41 <nkpart> yeah this just wraps that command line interface into a repl
16:37:49 <nkpart> partically applying the 'hoogle -n +module' part :)
16:37:57 <nkpart> -n X
16:38:02 <nkpart> *partially
16:38:54 <nkpart> what's GoA?
16:40:27 <jmcarthur> djahandarie knows how to treat orphans
16:42:18 <Eduard_Munteanu> Hrm... that C5 looks like it focuses on something akin to template metaprogramming.
16:42:19 <ddarius> jmcarthur: They pack easier if you cut them into smaller pieces.
16:42:24 * Eduard_Munteanu is not sure though
16:42:37 <ddarius> Eduard_Munteanu: From glancing at it, C5 looks like sin.
16:42:45 <Eduard_Munteanu> Indeed.
16:45:32 <Eduard_Munteanu> I should probably look at Djinn and similar stuff, if only somebody tried making it into a programming language :)
16:46:17 <Eduard_Munteanu> (Who knows how less tractable that is in a dependently-typed setting anyway.)
16:48:48 <gwern> @remember AndrewMorton I was attacked by dselect as a small child and have since avoided Debian.
16:48:49 <lambdabot> I will remember.
16:49:22 <Eduard_Munteanu> akpm? Heh.
16:50:12 <Eduard_Munteanu> There's a really funny quote from him in the latest LWN too :)
16:50:19 <gwern> not a subscriber
16:51:45 <Eduard_Munteanu> "I like the %p thingy - it's neat and is an overall improvement. If it dies I shall stick another pin in my Ingo doll."
16:52:14 <Eduard_Munteanu> and there's a pic of the doll too... http://0.tqn.com/d/urbanlegends/1/0/m/B/porcupine2.jpg
16:53:20 <gwern> hard to believe there are that many quills on a procupine
16:53:57 * Eduard_Munteanu just hopes that wasn't an *voodoo* Ingo doll.
16:54:04 <Eduard_Munteanu> s/an/a/
16:55:58 <hpc> > do {do that voodoo that you $ do {so well}}
16:55:58 <lambdabot>   Not in scope: `that'Not in scope: `voodoo'Not in scope: `that'Not in scope:...
17:02:48 <Eduard_Munteanu> http://www.wikihow.com/Make-a-Voodoo-Doll
17:09:48 <lispy> nkpart: Ghci on Acid
17:10:04 <lispy> nkpart: basically, it inserts lambdabot into your ghci sessions
17:10:11 <lispy> nkpart: which can be really nice
17:10:57 <monochrom> make a voodoo doll of lambdabot so whenever she crashes you can stab at the doll?
17:12:38 <finnomenon> first stab, then crash
17:13:46 <hpc> except it's lambdabot, so you would have to fstab the doll
17:31:33 * ddarius is pretty sure a dog would have let go before then.
17:37:23 <monochrom> haha hpc fstab
17:37:37 <dmwit> Can I ask ghc to just call unlit on a particular file?
17:37:43 <hpc> :D
17:37:47 <dmwit> I want to see the non-literate version of a literate file.
17:40:54 <aavogt> dmwit: your ghc comes with an unlit program?
17:41:30 <vilhelm_s> dmwit: does ghc -E  work?
17:41:54 <hpc> unlitline ('>':' ':s) = s; unlitline _ = ""; unlit = (unlines . map unlitline . lines) <$> getContents; main = unlit
17:41:54 <dmwit> aavogt: I don't see it, where would it be?
17:42:08 <aavogt> mine is in ~/ghc-7.0.1/utils/unlit/dist/build/tmp
17:42:12 <hpc> cat foo.lhs | ./unlit > foo.hs
17:42:18 <dmwit> ghc -E seems to do it.
17:42:34 * hackagebot timeplot 0.3.6 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.6 (EugeneKirpichov)
17:43:52 <dmwit> hpc: You'll be surprised to learn that's not correct.
17:43:56 <dmwit> Or perhaps you won't.
17:44:03 <hpc> dmwit: yeah, i figured
17:44:12 <dmwit> Anyway, I was surprised, because that was more or less the algorithm in my head.
17:44:48 <hpc> my first thought was that i would be hitting some odd filtering behavior of unlines and lines
17:45:10 <hpc> i remember some combination of those dropping empty lines
17:45:20 <fragamus> hey what package has Data.Stack
17:45:29 <hpc> @hoogle Data.Stack
17:45:29 <lambdabot> No results found
17:45:43 <hpc> @google site:hackage.haskell.org Data.Stack
17:45:44 <lambdabot> http://hackage.haskell.org/packages/archive/xmonad/0.9.1/doc/html/XMonad-StackSet.html
17:45:44 <dmwit> Mainly, you forgot \begin{code}/\end{code}, and the first case should be unlitline ('>':' ':s) = ' ':' ':s (surprise!).
17:45:44 <lambdabot> Title: XMonad.StackSet
17:45:53 <ddarius> Haskell is a piece of crap because it has no immutable stack type.
17:46:12 * ddarius walks away.
17:46:15 <dmwit> type Stack a = [a]
17:46:18 <hpc> lol
17:46:38 <hpc> ddarius: if it wasn't so obvious, that would have been a very funny troll
17:48:37 <hpc> incidentally, DList a makes a not-half-bad queue
17:49:18 <dmwit> ([a], [a]) makes a darn good queue
17:49:37 <ddarius> Only when used linearly.
17:49:48 <dmwit> Okasaki-approved
17:49:51 <dmwit> Yes, when used linearly.
17:49:54 <hpc> dmwit: how do you push to that?
17:49:55 <ben> it also makes a reasonable emotion of a dude with square glasses
17:50:00 <ben> emoticon*
17:50:08 <hpc> and pop, for that matter
17:50:13 <dmwit> push a (xs, ys) = (xs, a:ys)
17:50:20 <c_wraith> Actually, Okasaki had a variant that works fine whether used linearly or not.
17:50:22 <dmwit> pop (x:xs, ys) = (x, (xs, ys))
17:50:30 <dmwit> pop ([], ys) = pop (reverse ys, [])
17:50:30 <fragamus> @hoogle Stack
17:50:30 <lambdabot> Control.Exception StackOverflow :: AsyncException
17:50:30 <lambdabot> Control.OldException StackOverflow :: AsyncException
17:50:30 <lambdabot> Control.Exception.Base StackOverflow :: AsyncException
17:50:32 <c_wraith> That's honestly not much more complicated
17:50:34 <monochrom> ([a],[a],[a]) is the best queue
17:50:41 <c_wraith> front, middle, back?
17:50:49 <fragamus> @hoogle Data.Stack
17:50:49 <lambdabot> No results found
17:50:53 <hpc> dmwit: fun
17:51:17 <djahandarie> I see a pattern here. [[a]] is the best queue!
17:51:26 <dmwit> haha
17:51:32 <fragamus> argh all i want is to import Data.Stack but no workie
17:52:02 <djahandarie> fragamus, what's wrong with a normal list?
17:52:08 <hpc> no wookie?
17:52:10 <dmwit> What makes you think there's a Data.Stack?
17:52:11 <hpc> try endor
17:52:29 <fragamus> wookies live on Kashik
17:53:01 <fragamus> http://www.haskell.org/pipermail/beginners/2010-December/005957.html
17:53:47 <djahandarie> fragamus, look at the message it's in reply to.
17:53:51 <djahandarie> He defines Stack in it.
17:53:55 <fragamus> ty
17:54:01 <djahandarie> And unsurprisingly, it's just   type Stack = [Int]
17:54:12 <djahandarie> Which is a pretty stupid name anyways. :)
17:54:50 <dmwit> getRandomR (1,100) >>= modify . (:)
17:55:00 <hpc> heh
17:55:48 <ddarius> Lists are exactly the initial algebra you get from the algebraic specification of a stack.
17:56:17 <hpc> what do you get when you specify a queue?
17:56:36 * BMeph was just about to ask that...but alas, he is slow.
17:57:40 <monochrom> in ([a],[a],[a]) for queue, it is (front, back, suffix of front that is to be evaluated gradually in the future)
17:58:18 <NemesisD> how would one go about upgrading cabal and cabal-install?
17:58:53 <dmwit> cabal install --reinstall cabal-install, I guess
17:59:03 <Saizan> no --reinstall
18:01:41 * hackagebot vty 4.7.0.0 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.7.0.0 (CoreyOConnor)
18:01:53 <NemesisD> hmm thats what i thought. i tried that on my work pc and i'm pretty sure it borked cabal something awful. hopefully i have better luck on this machine
18:04:31 <curiousss> why haskell?
18:05:36 <hpc> who is spain? why is hitler?
18:05:36 <conal> hi all. new blog post: http://conal.net/blog/posts/parallel-tree-scanning-by-composition/
18:05:36 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
18:05:50 <djahandarie> Whee
18:06:10 <hpc> curiousss: because it's awesome!
18:06:12 <NemesisD> oh no:  Cabal-1.10.1.0-e951c182da4a22a7b82c0f2e4be13b7b is unusable due to missing or recursive dependencies
18:06:44 <Saizan> NemesisD: have you used upgrade, perhaps?
18:06:57 <conal> curiousss: http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
18:07:07 <monochrom> \∩/ see my http://www.vex.net/~trebla/haskell/sicp.xhtml for why you get "is unusable due to missing or recursive dependencies"
18:07:34 <NemesisD> Saizan: trying cabal upgrade cabal-install now
18:07:41 <Saizan> NemesisD: no!
18:07:56 <Saizan> NemesisD: upgrade is something to never used.
18:08:00 <Saizan> *use
18:08:30 * djahandarie expects this journey to end up with wiping all cabal/ghc-pkg-related files
18:08:44 <monochrom> hehe
18:09:06 <NemesisD> FFFFFFFFFF
18:09:20 <NemesisD> oh man i really wish you would have qualified your first statement
18:09:27 <NemesisD> so the answer is now yes, i have used upgrade
18:09:43 <djahandarie> It's probably easier to just wipe now.
18:09:47 <djahandarie> Read monochrom's page.
18:10:24 <hpc> someone needs to just de-implement upgrade
18:10:34 <Saizan> it is in newer version
18:10:45 <hpc> oh, groovy
18:10:51 <dmwit> vilhelm_s++
18:11:06 <NemesisD> lol trying to get the newer version is what got me into this mess in the first place
18:11:26 <monochrom> "do not upgrade piecemeal" is my advice
18:12:01 <NemesisD> so i should rm -rf $HOME/.ghc/x86_64-linux-7.0.2
18:12:08 <monochrom> and of course there is one more. "do not upgrade those packages that come with ghc"
18:13:13 <hpc> monochrom: it really seems like the rule to remember is "ask #cabal before doing ANYTHING"
18:13:14 <monochrom> adhering to haskell platform releases is the best. one single coherent transaction of installing ghc and libs.
18:13:20 <djahandarie> NemesisD, you should read the article monochrom linked and wrote.
18:14:48 <NemesisD> anyone know what cabal the latest haskell platform has
18:14:57 <monochrom> yes, asking #cabal is also prudent :)
18:15:11 <Saizan> there's a #cabal ?
18:15:23 <monochrom> cabal-install version 0.10.2 using version 1.10.1.0 of the Cabal library
18:15:32 <NemesisD> rather than reading that well written but lengthy article is the long road. i just wanted to implement some tests for a package i wrote
18:16:17 <NemesisD> ok nice. so if i wanted to go with haskell-platform, i should just scrap the package from my distro's package manager and grab platform off hackage?
18:16:31 <monochrom> well my other article tells you how to install the latest haskell platform: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
18:17:15 <NemesisD> might not be necessary. arch has the latest in the repos
18:18:31 <monochrom> if arch had the latest, you would not "cabal upgrade" in the first place
18:19:00 <monochrom> in fact if you trusted arch's repo at all, you would not even "cabal install"
18:19:31 <NemesisD> monochrom: ghc and friends did not make it onto my system via platform, which was a problem itself
18:19:43 <hpc> monochrom: it would be nice if we made cabal the thing in the arch repo
18:19:51 <hpc> monochrom: and then libs came through cabal
18:20:12 <monochrom> my lengthy article describes how to run into even more troubles by mixing distro packages and "cabal install"
18:20:25 <Saizan> extra/cabal-install 0.10.2-1
18:20:27 <Saizan> bt
18:20:29 <Saizan> *btw
18:20:59 <ville> hpc: noo... I want my packages from arch repos through pacman/clyde
18:20:59 <Saizan> i.e. cabal-install is in the arch repos
18:21:50 <NemesisD> so i should absolutely not trust the arch repos
18:22:08 <drbean> Do you think haskell-platform-2011.2.0.0-3.fc15, built for Fedora 15 will work with Fedora 9?
18:22:42 <Saizan> NemesisD: you should install haskell-platform from them, then stop
18:23:11 <NemesisD> Saizan: ok i'm there. by stop you mean never install any more packages or don't upgrade stuff?
18:23:34 <drbean> What was the lengthy article, again?
18:23:44 <NemesisD> drbean: http://www.vex.net/~trebla/haskell/sicp.xhtml
18:24:19 <Saizan> NemesisD: never install more packages from the repos once you start installing them from cabal-install, also avoid upgrading any package that came through the repos
18:25:11 <Saizan> but better read the sicp :)
18:27:58 <NemesisD> after all that it looks like testing really isn't even all there yet with cabal anyways. the docs mention you can test via exitcode-stdio-1.0 and detailed-1.0, the second of which doesn't seem to be supported in the latest cabal
18:29:13 <mjrosenb> hey, does anyone have some examples of using Arrow on things other than (->)?
18:39:12 <BMeph> mjrosenb: Try String transformers: type SF a b = SF ([a] -> [b])
18:40:28 <Philippa_> or parsers in general - ones that're Arrows and don't have extra structure that messes with it (usually ArrowApply) can statically self-analyse
18:46:23 <drawmeimage> hey :)
18:46:45 <drawmeimage> I have some problems with proving this: scanr f a = map (foldr f a) . tails
18:47:13 <drawmeimage> I've tried some induction and I stucked at (f x (foldr f a xs)) : (scanr f a xs)
18:47:21 <drawmeimage> could You help me please?
18:48:17 <drawmeimage> map (foldr f a) . tails (x:xs) = map (foldr f a) (tails (x:xs))  [from (.)]
18:48:27 <drawmeimage> map (foldr f a) ((x:xs) : tails xs)  [from map]
18:48:56 <drawmeimage> (foldr f a (x:xs)) : (map (foldr f a) (tails xs)) = (foldr f a (x:xs)) : (scanr f a xs) = (f x (foldr f a xs)) : (scanr f a xs)
18:49:02 <drawmeimage> what next should i do here?
18:53:00 <vijayl> @help
18:53:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:53:53 <drawmeimage> may I ask for some hints, please?
18:58:57 <Saizan> you need to show that foldr f a xs = head (scanr f a xs)
19:00:17 <drawmeimage> Saizan, what it will bring me?
19:00:57 <Saizan> f x (head (scanr f a xs)) : scanr f a xs = scanr f a (x:xs)
19:01:40 <Saizan> ?src scanr
19:01:40 <lambdabot> scanr _ q0 []     =  [q0]
19:01:40 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
19:01:40 <lambdabot>     where qs@(q:_) = scanr f q0 xs
19:01:50 <Saizan> using that definition ^^^
19:01:52 * hackagebot time-recurrence 0.2 - Generate recurring dates.  http://hackage.haskell.org/package/time-recurrence-0.2 (ChrisHeller)
19:02:06 <drawmeimage> (f x (foldr f a xs)) : (scanr f a xs) = (f x (head (scanr f a xs))) : (scanr f a xs)  right?
19:02:27 <drawmeimage> but why it's scanr f a (x:xs) ?
19:04:07 <Saizan> by definition of scanr
19:04:36 <drawmeimage> ok
19:05:03 <drawmeimage> so all i gotta prove here is prove lemma: foldr f a xs = head (scanr f a xs)
19:05:06 <drawmeimage> induction again?
19:05:36 <Saizan> i guess so
19:06:45 <Saizan> it's sort of a corollary of the inductive hypothesis, but it takes case-splitting on xs
19:08:44 <drawmeimage> all i can do on the LHS is foldr f a x:xs = (f x (foldr f a xs))
19:10:09 <Saizan> the inductive hypothesis of earlier was map (foldr f a) (tails xs) = scanr f a xs, right?
19:10:21 <drawmeimage> yup
19:10:25 <drawmeimage> but can i use it here?
19:10:34 <drawmeimage> it's (imho) different induction proof
19:11:09 <drawmeimage> may i link this two inductions?
19:12:32 <drawmeimage> RHS
19:12:33 <drawmeimage> head (scanr f a x:xs) = f x ( head scanr f a xs)
19:13:01 <Saizan> yeah, you're right, you need another induction
19:13:03 <drawmeimage> and by induction hyphotesis
19:13:24 <drawmeimage> err, again
19:13:37 <drawmeimage> foldr f a xs = head (scanr f a xs) - this is my induction hyphothesis
19:13:48 <drawmeimage> i wanna prove foldr f a x:xs = head (scanr f a x:xs)
19:13:48 <gbacon> who's leading FP research at Galois after dons's departure?
19:14:01 <drawmeimage> LHS:  foldr f a x:xs = (f x (foldr f a xs))
19:14:14 <drawmeimage> RHS:  head (scanr f a x:xs) = f x ( head scanr f a xs)
19:14:39 * djahandarie doesn't really like doing the whole 'LHS' 'RHS' seperately
19:14:41 <drawmeimage> f x ( head scanr f a xs)  from induction hyphothesis f x ( foldr f a xs )
19:14:45 <drawmeimage> the end
19:14:48 <drawmeimage> is it ok?
19:17:21 <drawmeimage> it looks ok for me, but i'm not pretty sure
19:19:02 <Saizan> you should learn some proof assistant based on type theory to get such proofs automatically verified :)
19:20:01 <drawmeimage> well i'm trying to train some induction on haskell ;]
19:20:45 <Saizan> looks ok anyhow
19:22:06 <drawmeimage> btw, should i prove it for [] and bootom too?
19:22:08 <djahandarie> I think it's really easy to introduce structural recursion based on starting out with mathematical induction, showing the algebra for natural numbers, then making the obvious generalization.
19:22:22 <djahandarie> Erm, structural induction* of course :p
19:22:31 <djahandarie> (Not that they are particularly different...)
19:29:33 <Saizan> drawmeimage: surely for []
19:35:10 <drawmeimage> what about _|_ ?
19:54:41 <Saizan> i often assume totality when doing these proofs, anyhow all the functions involved are strict so it's easy to handle _|_
19:55:02 * hackagebot data-lens-template 0.1 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-0.1 (JoelBurget)
20:16:35 <int80_h> if I have a [String], how can I use map and read to get a [Int] from it?
20:19:03 <stepkut> int80_h: map read ?
20:19:26 <stepkut> > map read ["1", "2", "3"]
20:19:27 <lambdabot>   [*Exception: Prelude.read: no parse
20:19:28 <int80_h> stepkut: more to it than that, I just found the right answer.
20:19:31 <stepkut> :)
20:19:45 <int80_h> map (read) yAxis :: [Float]
20:19:58 <stepkut> > map read ["1", "2", "3"] :: [Int]
20:19:59 <lambdabot>   [1,2,3]
20:22:02 <fragamus> I worked all day to write this: http://hpaste.org/47022/fragamus_monad
20:22:19 <fragamus> And now that it's done, I dont know how to invoke it
20:22:32 <stepkut> fragamus: heh
20:22:48 <fragamus> I barely understand what i wrote because
20:22:53 <fragamus> I'm a newb
20:22:58 <stepkut> one moment
20:28:12 <dibblego> djahandarie: ping
20:29:29 <djahandarie> dibblego, hey hey
20:29:49 <dibblego> hey mate, I want to run liftA2 over First -- how do I achieve this with Control.Newtype?
20:32:32 <djahandarie> Hmm, can I have a little more info? Not sure what you mean by 'liftA2 over First'
20:33:30 <dibblego> actually not first
20:33:36 <dibblego> since it has no Applicative
20:33:39 <djahandarie> Yeah
20:33:40 <dibblego> but say ZipList
20:33:50 <stepkut> fragamus: http://hpaste.org/paste/47022/fragamus_monad_annotation#p47023
20:33:54 <dibblego> @type \k a b -> getZipList $ liftA2 k (ZipList a) (ZipList b)
20:33:55 <lambdabot> forall a a1 b. (a1 -> b -> a) -> [a1] -> [b] -> [a]
20:34:16 <stepkut> fragamus: I changed (StateT Creature []) to (State Creature)
20:34:36 <djahandarie> dibblego, well, liftA* generalizes to traverse. So I'd be inclined to tell you to just use ala with traverse
20:34:50 <djahandarie> :t ala ZipList traverse
20:34:50 <lambdabot> Not in scope: `traverse'
20:34:51 <fragamus> but i need to have an array of them
20:34:57 <fragamus> i mean a list
20:34:58 <djahandarie> :t ala ZipList Data.Traversable.traverse
20:34:59 <lambdabot> forall a (t :: * -> *). (Data.Traversable.Traversable t) => t [a] -> [t a]
20:35:17 <stepkut> fragamus: a list of moves?
20:35:19 <fragamus> the [] is needed
20:35:19 <fragamus> because one of them can become more than one
20:35:46 <stepkut> fragamus: well, you can put that back in
20:35:58 <fragamus> ok cool thanks for your help
20:36:31 <stepkut> fragamus: where does the list come in ?
20:36:40 <djahandarie> dibblego, erm, actually I think I got that wrong. :) Moment
20:36:49 <dibblego> phew, I was struggling there
20:39:29 <AxleLonghorn> is there a library for Word sizes larger than the ones in Data.Word?
20:39:33 <stepkut> fragamus: I am still not clear on what 'them' in 'one of them' refers to
20:41:29 <djahandarie> dibblego, I feel there is a way to do this with the given functions but I'm not sure. You may need   under2 pack f a b = unpack $ f (pack a) (pack b)
20:41:56 <djahandarie> Then it'd just be \k -> under2 ZipList (liftA2 k)
20:42:10 <djahandarie> Let me poke at it more in the meantime
20:42:18 <dibblego> @type under2 ZipList . liftA2
20:42:18 <lambdabot> Not in scope: `under2'
20:42:28 <applicative> > ala ZipList Data.Traversable.traverse (words "goodbye cruel world")
20:42:29 <lambdabot>   ["gcw","oro","our","del","bld"]
20:42:42 <djahandarie> applicative, yeah, it's transpose
20:43:12 <applicative> sort of trimmed
20:43:21 <applicative> > transpose (words "goodbye cruel world")
20:43:21 <lambdabot>   ["gcw","oro","our","del","bld","y","e"]
20:43:25 <djahandarie> Right
20:43:46 <djahandarie> I think you can define another ZipList-ish thing which doesn't do that
20:44:27 <dibblego> pure=repeat, (<*>)=tails or something like that
20:45:47 <dibblego> where is under2?
20:46:00 <djahandarie> dibblego, nowhere at the moment
20:46:03 <Saizan> (<*>) = zipWith
20:46:04 <dibblego> oh
20:46:08 <applicative> he says he won't bother defining it in the comments
20:46:12 <djahandarie> Right
20:46:15 <dibblego> Saizan: yeah, I was just trying to work out newtype
20:46:18 <djahandarie> Maybe this is a good reason to though
20:49:08 <AxleLonghorn> Anyone? Is there a library for words of a size larger than 64?
20:51:15 <Saizan> @hoogle Word128
20:51:15 <lambdabot> No results found
20:51:23 <Saizan> @hoogle Word256
20:51:23 <lambdabot> No results found
20:51:28 <AxleLonghorn> Nevermind. Data.LargeWord in Hackage
20:51:35 <jmcarthur> Integer?
20:51:44 <jmcarthur> or a wrapper around it
20:52:41 <applicative> what do you do with these large words once you find them?
20:54:18 <applicative> aha, the dependencies are mostly via 'crypto-api'
20:54:29 * applicative is suspicious!
20:59:32 <codolio> I think there's a single very large one, too.
21:00:12 <codolio> Word 4096 or something.
21:26:08 <int80_h> I have a [String] called xAxis, and a [String] called yAxis. I am trying to make a [String] such that each String is xAxis ++ yAxis. I'm trying to make a list comprehension but I'm not doing it right. Could I have some help?
21:26:35 <int80_h> each [String] is length 82, and the final [String should be the same length
21:27:15 <mjrosenb> int80_h: list comprehension probably won't do what you want
21:27:34 <int80_h> mjrosenb: aw that sucks. It looked perfect
21:27:43 <mjrosenb> int80_h: you'd end up with a list with 82*82 elements, choosing every possible pair from xAxis and yAxis
21:27:52 <mjrosenb> int80_h: you may want to look into zipWith.
21:27:58 <int80_h> mjrosenb: that's exactly what I have
21:28:08 <int80_h> ah zipWith! I've used that before
21:30:49 <int80_h> mjrosenb: I don't think this will work either. given a "1" and a "2 I want a "1 2"
21:31:52 <int80_h> mjrosenb: does that make sense?
21:32:44 <mjrosenb> what do you have currently?
21:33:13 <int80_h> looks like my "1" and "2" becomes a "3"
21:33:35 <mjrosenb> that sounds ... wrong.
21:33:40 <int80_h> when I do this "1" ++ "2" I get "12", how can I apply that to two lists?
21:34:26 <mjrosenb> > zipWith (++) ["a","b","c"] ["1","2","3"]
21:34:27 <lambdabot>   ["a1","b2","c3"]
21:35:11 <int80_h> oh I see what is happening, I need to seperate the strings with a " "
21:36:16 <applicative> >  zipWith (\s t -> s ++ " " ++ t) (words "all the best people") (words "shop at Jones' Grocers")
21:36:18 <lambdabot>   ["all shop","the at","best Jones'","people Grocers"]
21:36:24 <evaryont> how do I append a Char to a String? trying to do "echo '" ++ Char ++ "'..." which doesn't work :P
21:37:10 <applicative> > "evaryon" ++ ['t']
21:37:12 <lambdabot>   "evaryont"
21:37:17 <evaryont> ah, thanks applicative
21:37:25 <int80_h> applicative: thanks!
21:41:29 <KirinDave> I need a radical haskell paper to read.
21:41:33 <KirinDave> Someone, help me!
21:41:43 <copumpkin> radical?
21:41:58 <copumpkin> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf is fun, if not particularly radical
21:42:01 <KirinDave> copumpkin: Skateboarding turtles not required.
21:42:12 <copumpkin> or the kleisli arrows of outrageous fortune one
21:42:12 <evaryont> how do I get an environment variable as a plain String? tried: (xdg_config:_) <- getEnv "XDG_CONFIG_HOME"  but that nets me a parsing error (@ '<-') :)
21:42:26 <copumpkin> KirinDave: basically, if you want an accessible fun haskell paper, just pick out one of the functional pearls
21:42:34 <KirinDave> functional pearls
21:42:43 <shachaf> KirinDave: I think sqrt is pretty-well understood -- at least, not less understood in Haskell than anywhere else.
21:43:04 <codolio> Read Initial Algebra Semantics is Enough!
21:43:05 <dibblego> APWE is fun
21:45:53 <evaryont> hah, so converting `IO String' to String. I'm at a loss :/
21:46:23 <dibblego> evaryont: it's not possible, do you want to execute a function on your String?
21:46:42 <danharaj> Is there a haskell' proposal to make it so that you can explicitly hide / import instances?
21:46:43 <evaryont> nah. instead, just append it to a string. :P
21:46:58 <dibblego> evaryont: the fmap function will help you
21:47:13 <nwf> Is attoparsec a good package to use to parse TLV streams?  The only way I can see to make it honor the L part is to pull out the whole string and run another, inner, parser.
21:49:27 <evaryont> dibblego: not sure how that would. :S
21:49:40 <dibblego> @type fmap ("hi there" ++)
21:49:41 <lambdabot> forall (f :: * -> *). (Functor f) => f [Char] -> f [Char]
21:49:55 <Lemon> I heard you can encode exists with forall.
21:50:05 <dibblego> evaryont: that above takes an IO String argument and returns an IO String
21:50:09 <KirinDave> copumpkin: Ty
21:50:12 <Lemon> I think it was mentioned, if not explained, in TaPL.
21:50:32 <Lemon> But I do not remember that part of the book very well because it went over my head.
21:50:37 <Lemon> Can somebody explain?
21:50:50 <codolio> exists a. P = forall r. (forall a. P -> r) -> r
21:51:12 <Lemon> oh
21:51:19 <Lemon> that makes a surprising amount of sense.
21:51:44 <codolio> You can actually get there through a two-step process.
21:51:45 <djahandarie> Lemon, you can encode Sigma with Pi types, which is another angle to that
21:51:56 <djahandarie> Probably a totally useless angle though
21:51:57 <codolio> P is isomorphic to forall r. (P -> r) -> r
21:52:05 <codolio> Assuming of course that r is not free in P.
21:52:28 <codolio> And (exists a. P) -> T is isomorphic to (forall a. P -> T), assuming a is not free in T.
21:52:33 <codolio> So you put the two together.
21:52:53 <Lemon> define:isomorphic
21:53:00 <mjrosenb> nwf: !
21:53:05 <mjrosenb> nwf: TLV?
21:53:17 <nwf> Type(tag)-Length-Value
21:53:24 <codolio> There is a pair of functions between the two that are mutual inverses.
21:53:35 <dibblego> iso (equal) morph (form)
21:53:47 <evaryont> dibblego: I don't see how that is helpful :| I am just tossing things I've found together, hoping. :P haven't sat down & read lyah
21:54:15 <codolio> djahandarie: You have to be careful with that.
21:54:32 <djahandarie> Oh yeah?
21:54:39 <Lemon> now, there was something else in TaPL I kind of skimmed over
21:54:50 <codolio> If you encode a sigma with pi, you lose the strong induction principle.
21:54:54 <Lemon> something about exists modeling, of all things, pairs
21:54:55 <dibblego> evaryont: you have a value of the type IO String right? let's call it x. And you have a String that you want to prepend to the String that would be yielded if x were run, call that s, then fmap (s ++) x
21:55:01 <codolio> Usually. Unless you have parametricity internalized.
21:55:09 <Lemon> and somehow deriving the concept of modules of the ML variety from that.
21:55:12 <djahandarie> codolio, what about in Agda?
21:55:43 <codolio> You can't even really encode it properly in Agda, because Agda is predicative.
21:56:29 <djahandarie> Ah. Same with Coq then
21:56:43 <codolio> Well, you can switch on --impredicative-set in Coq.
21:56:43 <djahandarie> Probably Homotopy Type Theory could do it!
21:56:44 <evaryont> dibblego: yes! hah! interesting.
21:57:11 <djahandarie> Ah. I should actually study Coq at some point.
21:57:33 <codolio> djahandarie: Anyhow, you can switch on --type-in-type in Agda, I guess for something similar.
21:57:56 <dibblego> evaryont: there are other helpful functions, and even syntax, depending on the specifics of what you want to do
21:57:58 <codolio> And you will be unable to define the second projection for the pi-encoded sum.
22:00:05 <evaryont> dibblego: well this is a annoying turn: in the end, I'm trying to toss a command to XMonad's spawn() (to, I guess, be passed to System.Command) so I'm trying to be flexible & such, using environment variables to build a path. I'll paste my current code soon..
22:00:24 <dibblego> why use environment variables?
22:00:42 <dibblego> haskell variables are way better, they don't vary!
22:01:48 <Jafet> Constant variables
22:01:53 <evaryont> but I'm trying to honor the XDG spec, which tells apps where to put their config/data/cache files :P
22:01:56 <evaryont> https://github.com/evaryont/dotfiles/blob/master/xmonad/xmonad.hs#L34
22:02:10 <evaryont> that's my current (failing!) attempt. Couldn't match expected type `Char' with actual type `[a0]'
22:02:27 <evaryont> ah, the error is really line 31, not 34. oops.
22:02:51 <evaryont> dibblego: and the whole point is to let the user vary the path :-P
22:03:00 <evaryont> not have it constant for just my set up
22:03:09 <dibblego> write a library function instead
22:07:35 <evaryont> dibblego: library function?
22:07:50 <int80_h> I have this ["1 4\n","2 5\n","3 6\n"], how can I use map and writeFile together correctly to write that to a file?
22:08:00 <dibblego> evaryont: yeah, a function that accepts the parameters that you wish for other users to customise
22:08:25 <int80_h> I tried writeFile "test.out" (map head ...) but that didn't do what I wanted
22:08:50 <Jafet> What do you think map head does?
22:09:07 <int80_h> Jafet: when I use it in ghci it does exactly what I want
22:09:24 <Jafet> > map head ["1 4", "2 5", "3 6"]
22:09:25 <lambdabot>   "123"
22:09:32 <int80_h> say I have ["0 336.0","2 445.2"]
22:09:38 <Jafet> So you want to write certain parts of it to a file.
22:09:45 <dibblego> >> writeFile "/tmp/test.out" (map head ["1 4\n","2 5\n","3 6\n"])
22:09:46 <dibblego> >> readFile "/tmp/test.out"
22:09:46 <dibblego> "123"
22:09:59 <int80_h> yeah I want "0 336" to be line one
22:10:09 <int80_h> "2 445.2" to be line two
22:10:13 <int80_h> and so on
22:10:29 <Jafet> > map head ["0 336.0", "2 445.2"]
22:10:29 <lambdabot>   "02"
22:10:33 <dibblego> > intercalate "\n" ["0 336.0","2 445.2"]
22:10:34 <lambdabot>   "0 336.0\n2 445.2"
22:10:47 <Jafet> Bah, the solution isn't as interesting as the problem.
22:10:58 <Jafet> Oh well.
22:11:03 <int80_h> intercalate?
22:11:14 <dibblego> that's what you want right?
22:11:19 <int80_h> that's it!
22:11:34 <dibblego> >> writeFile "/tmp/test.out" (intercalate "\n" ["1 4\n","2 5\n","3 6\n"])
22:11:34 <dibblego> >> readFile "/tmp/test.out"
22:11:35 <dibblego> "1 4\n\n2 5\n\n3 6\n"
22:11:39 <Jafet> I think he isn't sure.
22:11:53 <int80_h> I'll try right now and report back
22:12:30 <int80_h> how do I find what module intercalate is in, via lambdabot?
22:12:52 <dibblego> @hoogle intercalate
22:12:52 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
22:12:52 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
22:12:52 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
22:15:16 <synonymous> if the sole purpose is to dump to file, i'd use unlines instead of intercalate to get another \n at the end
22:15:29 <int80_h> good to go!
22:15:31 <int80_h> works perfectly
22:15:35 * dibblego high-five
22:15:42 <int80_h> j00 rulez
22:16:06 <int80_h> ah feels good. This is for a work project, after a month of fail it's starting to come together
22:16:27 <int80_h> keep going or go home?
22:16:29 <int80_h> hmmm
22:16:49 <int80_h> Ima call it a night #haskell
22:16:54 <m3ga> work projects done in haskell are the best projects
22:17:00 <int80_h> they really are
22:17:26 <int80_h> If it wasn't for #haskell this project would have dead long ago
22:17:47 * int80_h waves
22:18:11 <evaryont> alright, different approach: Appending an `IO [FilePath]' to a String? :-P there's a haskell library that already messes with XDG for me. Still need to stick it in a string that can be passed around in XMonad.
22:18:57 <dibblego> evaryont: it is not possible to step out of IO, but there are library functions to help you run functions on the value that IO actions will produce when they are run
22:19:12 <dibblego> fmap, (>>=), (>=>), liftA2 for example
22:19:20 <shachaf> @ty secretFunction
22:19:21 <lambdabot> IO [FilePath] -> [FilePath]
22:19:31 <evaryont> shachaf: lol what.
22:19:33 <Jafet> @src FilePath
22:19:33 <lambdabot> type FilePath = String
22:19:34 <shachaf> You have to get to level 3 before you can use that, though.
22:19:55 <Jafet> shachaf is kidding. There is no level 3. It doesn't exist.
22:19:56 <evaryont> shachaf: I'm still trying to beat level 1 :)
22:20:09 <m3ga> @src secretFunction
22:20:09 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:20:20 <dibblego> shachaf: I gave a tutorial on haskell/FP last night to 44 people. At the pub someone mentioned the unsafe functions and I spent the next 10 minutes explaining why we should ignore it
22:20:24 <evaryont> trying to beat level 1 while skipping to level 4...
22:20:49 <shachaf> dibblego: Uh-oh.
22:21:01 <shachaf> evaryont: Listen to dibblego and ignore what I just said. You can't convert IO foo to foo.
22:21:16 <dibblego> thanks :)
22:21:21 <evaryont> better idea: instead of trying to pass a string so that echo does output. why not just do what echo does? why shell out? :P
22:21:49 <evaryont> shachaf: yeah I figured. even if there is some function that'll do that, why hasn't everyone already gone ahead and used it? There had to be a reason somewhere :-P
22:22:02 <dibblego> because it doesn't exist, that's why
22:22:19 * Jafet nods gravely.
22:22:41 <evaryont> well that's a pretty good reason :P
22:35:12 <evaryont> alright. passing an 'IO [FileType]' to writeFile - it doesn't like that (wants a regular FileType). Where should I look?
22:40:40 <shachaf> evaryont: You should give it a regular FileType.
22:40:48 <shachaf> Read about how IO works in Haskell.
22:41:55 <evaryont> shachaf: yeah.. where's a nice document for that?
22:45:22 * hackagebot waitfree 0.1.1 - A wrapping library for waitfree comnputation.  http://hackage.haskell.org/package/waitfree-0.1.1 (YoichiHirai)
22:47:24 <Cale> evaryont: http://www.haskell.org/haskellwiki/Introduction_to_IO should get you started quickly :)
22:49:47 <Cale> evaryont: The main thing to recognise is that a value x of type IO t is like a program which when executed will result in a value of type t, and inside a do-block, you can use the notation v <- x to say "execute the action x getting the result v"
22:50:35 <Cale> evaryont: the do-block as a whole will then have some other IO-type
22:50:49 <Cale> (whatever the type of its last line was)
23:00:39 <evaryont> ok, how do I define a binding for a method?
23:00:50 <evaryont> I have this: 'pianobarCmd :: Char'
23:16:43 * jeffz wants lambda-case + guards already!
23:18:27 <evaryont> yeah, so apparently there is a syntax error of some sort here? http://hpaste.org/47025/pianobarcmd_io_attempt
23:18:59 <evaryont> why would '>>= \path = ...' be incorrect? :/
23:19:51 <jeffz> \path ->
23:19:53 <Lemmih> evaryont: \path ->
23:20:52 <evaryont> ah derp.
23:21:07 <evaryont> hell, it's even in the wiki.
23:24:24 <evaryont> alright, so using that didn't fix much from earlier: http://hpaste.org/paste/47025/pianobarcmd_io_attempt_annota#p47026 - going 'round in a circle, and getting the type signature...binding error. No idea how to resolve.
23:25:24 <jeffz> evaryont: spelling mistake
23:25:42 <jeffz> pinaobar
23:26:02 <evaryont> jeffz: oh man >.<
23:26:24 <jeffz> evaryont: which module is writeLine in?
23:26:33 <evaryont> Prelude
23:26:50 <jeffz> evaryont: not to my knowledge
23:27:04 <evaryont> really?
23:27:12 <jeffz> http://www.haskell.org/onlinereport/standard-prelude.html
23:28:21 <evaryont> it's System.IO
23:28:57 <jeffz> evaryont: there's no writeLine in System.IO, are you thinking of writeFile?
23:29:11 <evaryont> I..uh..yeah...
23:29:17 * evaryont face palms
23:29:19 <Peaker> @hoogle hPutStrLn
23:29:20 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
23:29:20 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
23:29:20 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
23:34:00 <Favonia> preflex: seen nwf
23:34:01 <preflex>  nwf was last seen on #haskell 1 hour, 40 minutes and 46 seconds ago, saying: Type(tag)-Length-Value
23:38:08 <nwf> Favonia: Salutations.
23:38:37 <mafs> Is there a reason that reundant imports are warned about with -Wall? I mean, is there some real benefit by removing them?
