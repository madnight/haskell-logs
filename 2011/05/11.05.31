00:15:03 * hackagebot hmatrix 0.11.1.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.11.1.0 (AlbertoRuiz)
00:19:55 <exeter> Hello, I was browsing for a method to copy an entire directory in another place with Haskell. Google pointed me to this http://www.mickinator.com/wordpress/?cat=5&paged=3 , but alas it seems not at all portable. Do you know of a portable alternative?
00:19:56 <lambdabot> exeter: You have 1 new message. '/msg lambdabot @messages' to read it.
00:21:37 <exeter> and how to send messages with lambabot?
00:22:11 <shachaf> @help tell
00:22:11 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
00:22:25 <exeter> thanks
00:24:48 <exeter> does lambdabot provides feedback after you told him to tell a message (like "ok, I will tell <user> that when I see him/her here")?
00:25:23 <prova> test
00:26:05 <exeter> does not seem to work
00:29:32 <shachaf> exeter: You need to use "@tell".
00:29:47 <shachaf> (If you just tried "tell".)
00:29:53 <deteego> does anyone know if there is an equivalent of reads for Text (instead of the standard String) or does one have to use T.pack?
00:29:54 <exeter> mh, thanks
00:30:08 <deteego> (where T is the qualified import of Text)
00:33:46 <mauke> http://hpaste.org/47291/tryhs
00:33:51 <mauke> what the heck is going on here?
00:34:21 <mauke> I'm using no extensions, the MR should be irrelevant, but if I comment the type signature, it errors
00:34:25 <mauke> works fine in hugs, though
00:35:48 <shachaf> mauke: Apparently GHC isn't inferring the most general type for some reason.
00:36:14 <deteego> mauke: I think that may have to do with GHC's new type inference engine
00:36:23 <mauke> how old is new?
00:36:23 <shachaf> (:t says f :: (Functor f) => (A -> A) -> f A)
00:36:32 <deteego> mauke: 7.x
00:36:37 <mauke> deteego: this is 6.10
00:36:41 <shachaf> deteego: Nope, happens on 6.12.
00:36:50 <deteego> hmmm
00:36:52 <deteego> nvm then
00:42:02 <shachaf> @ty let { f a c = fmap c (f a a) } in f
00:42:03 <lambdabot> forall b (f :: * -> *). (Functor f) => (b -> b) -> (b -> b) -> f b
00:42:22 <shachaf> @ty let { f a c = fmap c (f a a) } in f :: (Functor f) => (a -> a) -> (a -> b) -> f b
00:42:23 <accel> is there a haskell builtin that will take a String, and replace all instanes of "_" with "\_" ?
00:42:23 <lambdabot>     Couldn't match expected type `a' against inferred type `b'
00:42:23 <lambdabot>       `a' is a rigid type variable bound by
00:42:23 <lambdabot>           an expression type signature at <interactive>:1:55
00:42:38 <shachaf> @ty let { f :: (Functor f) => (a -> a) -> (a -> b) -> f b; f a c = fmap c (f a a) } in f
00:42:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> a) -> (a -> b) -> f b
00:42:47 <shachaf> mauke: A simpler example.
00:43:06 <Saizan> loads fine in ghc-7.0.3, btw
00:43:22 <shachaf> Oh, then this is already fixed?
00:43:46 <Saizan> (keeping the signatures on g and h)
00:44:09 <shachaf> Saizan: What type does it infer for my function?
00:44:43 * shachaf should probably install GHC7.
00:46:57 <Saizan> shachaf:  Functor f => (a -> a) -> (a -> a) -> f a
00:47:06 <geheimdienst> accel: the MissingH package can help you http://hackage.haskell.org/packages/archive/MissingH/1.1.0.3/doc/html/Data-String-Utils.html#v:replace
00:47:32 <shachaf> Saizan: Hmm, and what type does it infer for mauke's f?
00:48:04 <Saizan> f :: Functor f => (A -> b) -> f b
00:48:35 <shachaf> Hmm.
00:48:59 <Saizan> shachaf: yours would be a clear example of polymorphic recursion iiuc, which is known to require a type signature
00:49:18 <Saizan> mauke's one is also pretty close to that though
00:49:34 <shachaf> Bah.
00:52:30 <shachaf> @ty let { f a c = c (f a a) } in f
00:52:30 <lambdabot> forall t. (t -> t) -> (t -> t) -> t
00:55:36 <mauke> lol wut
00:55:49 <mauke> if I replace g's body by undefined, it infers the right type for f
00:56:25 <Saizan> yeah, the mutual recursion between f and g is likely the trigger
00:56:46 <Saizan> they need to be typechecked together
00:57:06 <mauke> if should infer a type for f using g's explicit signature
00:57:25 <mauke> then it should use f's type to typecheck g against the signature
00:57:37 <Saizan> it obviouvsly wasn't though :)
00:59:34 <osfameron> hmmm, CTRL to jump is a rather bizarre choice
00:59:46 <osfameron> (this is haskell related - I'm attempting to play Nikki and the Chipmunks)
00:59:56 <osfameron> Ctrl-arrow has bindings in my window manager...
01:01:13 <dankna> there's a superstition among people who programmed for the Mac in the 90s that modifier keys should be used for game controls, because the ADB keyboard hardware only handled two simultaneous presses, except for modifiers
01:01:22 <dankna> that's the only semi-rational explanation that I can think of for that binding choice
01:01:25 <osfameron> ah, heh
01:01:31 <osfameron> it's completely insane though
01:01:34 <dankna> yes
01:01:44 <osfameron> I'm emailing the author to let them know
01:01:47 <dankna> good, yes
01:11:57 <EM03> any web stuff in haskell thats worth taking a look at ?
01:13:08 <osfameron> EM03: what kind of thing do you mean?
01:13:21 <EM03> general web development
01:14:03 <osfameron> EM03: you want examples of sites built in Haskell?  or links to Frameworks for developing web apps?
01:14:06 <osfameron> or something else?
01:14:14 <EM03> any popular web frameworks?
01:14:28 <osfameron> EM03: I've been recommended Snap: f sites built in Haskell?  or links to Frameworks for developing web apps?
01:14:32 <osfameron> dammit
01:14:39 <osfameron> EM03: http://snapframework.com/ even
01:14:46 <EM03> yep just found snap
01:15:05 * osfameron is having some odd copy/paste errors from Chrome to iTerm2, not sure if it's me being fat-fingered or something else ;-)
01:15:10 <nlogax> EM03: yesod, happstack
01:15:14 <shachaf> Nice bot you have there, #snapframework.
01:15:14 <osfameron> EM03: and also Yesod http://www.yesodweb.com/
01:15:22 <shachaf> Snip snap.
01:16:36 <osfameron> heh, that's a cute botfeature
01:16:49 <osfameron> presumably if I say "snap" again, it doesn't mention it for a while?
01:16:53 <osfameron> nope
01:16:56 <osfameron> BAD BOT
01:18:50 * shachaf takes a snapshot.
01:19:10 <shachaf> Snaps?
01:19:15 <shachaf> Snapshot?
01:19:18 <shachaf> Hrm.
01:19:22 <shachaf> Snap's.
01:19:45 <dankna> um, are you trying to trigger a bot that isn't even in this channel?
01:19:53 <shachaf> dankna: It is.
01:19:55 <dankna> oh
01:19:56 <dankna> Snap
01:20:00 <dankna> heh
01:20:00 <shachaf> dankna: It reports all mentions of "snap" to #snapframework.
01:20:07 <dankna> that's... wow
01:20:10 <dankna> obsessive :)
01:20:18 <shachaf> 01:37 < etabot> dankna is talking about snap in #haskell: Snap
01:20:24 <dankna> hah!
01:20:27 <flux> snappin' obsessive you mean?
01:21:03 <Baughn> Stop snapping at them!
01:21:05 <dankna> I wonder how long it's ben doing that
01:21:09 <dankna> *been
01:21:28 * osfameron was going to snap at etabot, but talked to it reasonably instead ;-)
01:21:33 <osfameron> I don't think it paid any attention, though ;-)
01:21:44 <shachaf> @snap etabot
01:21:44 * lambdabot throws some pointy lambdas at etabot
01:22:19 * Saizan wonders if there's a pointy lambda symbol in unicode
01:22:52 <shachaf> ∆õ
01:23:12 <shachaf> Œõ is pointy.
01:23:59 <shachaf> Ooh: ùõå
01:24:11 <shachaf> Hmm, something in my ssh/irssi/screen setup messes that up.
01:24:16 <shachaf> It renders fine in my other terminal.
01:24:26 <Saizan> yeah, i couldn't see that one
01:25:13 <shachaf> It's being turned into fffd. :-(
01:25:23 <osfameron> shachaf: I'm seeing "?["
01:25:30 <shachaf> That was meant to be U+1D6CC.
01:26:20 <osfameron> hmmm, maybe I didn't *start* irssi in a -U screen
01:26:23 <shachaf> > "\x1d6cc"
01:26:24 <lambdabot>   "\120524"
01:26:41 <shachaf> > text "\x1d6cc"
01:26:42 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
01:27:20 <shachaf> ‚Ü±‚Ü≤
01:27:26 <shachaf> ‚Ü≥‚Ü∞
01:28:20 <Saizan>  
01:28:26 <osfameron> can I get a pointy unicode lambda?
01:28:38 <shachaf> osfameron: My IRC client was sending the wrong character.
01:28:44 <shachaf> So it wouldn't have done you much good.
01:28:46 <osfameron> ah
01:28:51 <shachaf> (Also, this one wasn't pointy.)
01:29:04 <sipa> your characters show fine here, shachaf
01:29:12 <shachaf> sipa: Which, ùõå?
01:29:30 <mauke> it's the right character but not available in my font
01:29:37 <osfameron> ok, I just pasted some russian in $otherchan, so I think I'm ok (for next time I get a pointy lambda ;-)
01:29:39 <shachaf> osfameron: Try Ctrl-Shift-U 1d6cc or some equivalent (in a non-irssi/screen/ssh/whatever terminal).
01:30:04 <osfameron> don't think mac has that keybinding?
01:30:33 <shachaf> Nope.
01:31:09 <shachaf> osfameron: Mac OS? How does this look? ‡≤†_‡≤†
01:31:38 <osfameron> shachaf: like 2 boxes with squiggles (mask? java coffee mug? oriental character?) in them
01:32:02 <dankna> the squiggle looks like it's probably Devanagiri to me, but who knows
01:32:11 <sipa> these look fine; ∆õ Œõ ‚Ü±‚Ü≤‚Ü≥‚Ü∞
01:32:46 <shachaf> Sure, those are fine.
01:32:57 <osfameron> yes. that 3rd combination of characters is quite impressive
01:33:01 * shachaf suspects this belongs in #-blah (if anywhere at all).
01:33:19 <shachaf> (Those arrows are the result of typing in random code points and seeing what happens.)
01:33:34 <dankna> eh, it's the witching hour
01:33:47 <dankna> USAians aren't awake yet, and Europeans are on their way to work
01:33:49 <osfameron> on-topic (though probably not on-location for most of you) I'll remind you that http://lanyrd.com/2011/geekup-liverpool-may/ is happening tonight ;-)
01:34:26 <earthy_> at work, I hope
01:34:28 <dankna> ah, sounds cool
01:34:32 <earthy_> it's 10:51 here
01:34:36 <dankna> oh, yeah, that then :)
01:34:38 <shachaf> @localtime dankna
01:34:39 <lambdabot> Local time for dankna is Tue May 31 04:51:46
01:34:47 <dankna> <- nocturne
01:34:49 <earthy_> @localtime earthy_
01:34:51 <shachaf> dankna: goto sleep;
01:34:52 <lambdabot> Local time for earthy_ is Tue May 31 10:51:58 2011
01:34:56 <EM03> so has anyone personally used haskell for web dev?
01:34:58 <dankna> shachaf: label not found
01:35:11 <EM03> I dont know much about haskell at all, if there is a some what ok web framework I might give it a try
01:35:16 <shachaf> dankna: goto *sleep;
01:35:29 <dankna> EM03: http://dankna.com/issues/index/ demos my system FruitTart described at http://dankna.com/software/ -- but it's incomplete and unreleased
01:35:41 <EM03> what framework?
01:35:54 <dankna> FruitTart is both the framework and the application
01:36:04 <EM03> did you make it?
01:36:08 <dankna> yes
01:36:12 * hackagebot file-embed 0.0.4 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4 (MichaelSnoyman)
01:36:17 <dankna> shachaf: type error something something.
01:36:22 <EM03> whats the most popular web framework out there?
01:36:23 <shachaf> dankna: Type error?
01:36:29 <osfameron> EM03: I'm a fairly inexperienced haskell programmer myself.  Snap *looks* very simple (and perhaps is doing less than Yesod and friends?) but I've not actually used either.
01:36:38 <dankna> EM03: no idea
01:37:17 <dankna> shachaf: I was thinking along the lines of "... can't jump to a non-function value", but it doesn't really work because C doesn't really have the concept of jumping to a value at all
01:37:53 <shachaf> dankna: http://gcc.gnu.org/onlinedocs/gcc-3.4.1/gcc/Labels-as-Values.html
01:38:00 <dankna> !
01:38:08 <shachaf> (GCC extension.)
01:38:30 <EM03> yesod looks super complicated
01:38:31 <dankna> wow, wtf, who wanted that :)
01:38:42 <EM03> but I have never used haskell, so I would need 30 minute to learn it :)
01:38:53 * EM03 has used ocaml and other functional languages heavily 
01:39:10 <dankna> EM03: Haskell is not a 30-minute language, even if you already know functional programming - it took me a couple months to get proficient at it coming from a strong Lisp background
01:39:33 <EM03> it looks in many ways similar to ocaml
01:39:33 <dankna> ocaml might be better, not sure
01:39:38 <dankna> at least you won't have syntax worries
01:39:41 <Baughn> Haskell isn't even a three-month language. It's one of its greatest weaknesses.
01:39:54 <Baughn> Or strenghts, depending on whether you consider learning to be fun.
01:40:02 <dankna> there's that
01:40:05 <EM03> programming languages are not hard to me at this point
01:40:11 <EM03> they are all the same in their own way
01:40:32 <mauke> ok, learn haskell in 30 minutes, then I'll believe you
01:40:42 <EM03> my boss wanted an android app made,  I never used java in my life .....the app is done hehe
01:40:43 <EM03> well
01:40:47 <EM03> I was just kidding
01:40:55 <EM03> a few days most likely to get usable with it correctly
01:41:38 <dankna> anyway, it's silly to argue about that, I just didn't want you to be all "Haskell sucks" when it turns out to take longer :)
01:41:46 <dankna> You Have Been Warned :)
01:42:05 <EM03> it took me months to learn lisp properly
01:42:12 <Baughn> EM03: Java is a /simple/ language, haskell is.. not...
01:42:18 * Baughn gets out the popcorn
01:42:27 <EM03> Java is usually by money considered very complex
01:42:32 <EM03> which is why I was surprised
01:44:13 <EM03> I'm really good at exploiting a language for what I know, even if its super simple and not exactly learn as I go just when required
01:44:20 <alind> Hi to all. Which book is best for learning Haskell ( I know c++, python )
01:44:40 <gienah> @where lyah
01:44:40 <lambdabot> http://www.learnyouahaskell.com/
01:46:14 <ski> shachaf : .. isn't it strange that the type of the label is `void *' rather than e.g. `void (*)()' ?
01:46:29 <mauke> labels aren't callable
01:46:40 <alind> thanks. Just opened the lyah page and it looks catchy. :)
01:46:47 <osfameron> hurrah.  nikki and the chipmunks will have configurable keybindings from next week ;-)
01:46:52 <dankna> yeah, that's the right way to learn a big thing like a programming language - don't "clamp a vise" on it by grinding lots of knowledge up front; instead, "put down roots" by exploring in wiggly directions as they occur to you
01:46:58 <dankna> osfameron: hah cool
01:47:02 <shachaf> ski: Well, it's a goto, not a function.
01:47:22 <dankna> yeah, it doesn't save or restore arguments, so you can't call it
01:47:22 <shachaf> ski: It points to an address that you jump to, not one that you call.
01:47:31 <ski> mauke : not in the usual sense, no, but with the distinction between data pointers and function pointers (which are not interconvertible)
01:47:35 <ski> ..
01:47:48 <shachaf> In theory they should have a new type for that sort of thing, but, you know, C.
01:48:00 <dankna> eh?  they're not interconvertible?  is that a new security restriction or something?  I know they used to be
01:48:06 <dankna> (uint8_t *) main :D
01:48:11 <ski> it just seemed to me that an address to code would be more like a function pointer than a data pointer
01:48:13 <mauke> dankna: not valid C
01:48:43 <dankna> I mean I know an access to it would be undefined
01:48:44 <shachaf> ski: Right, but it's not really either, and void * is more generic (can't call it accidentally).
01:48:45 <sipa> no?
01:48:48 <dankna> but you're saying even the cast isn't valid?
01:48:53 <mauke> dankna: right
01:49:01 <ior3k> alind: I liked http://book.realworldhaskell.org/read/ better than Learn You a Haskell
01:49:08 <sipa> you'll definitely get undefined behaviour
01:49:09 <dankna> is this a new restriction, or was it there all along?
01:49:14 <mauke> dankna: C supports architectures with separate code/data segments and different pointer representations for different types
01:49:16 <ski> shachaf : also, a call is typically a jump, plus a save of return address :)
01:49:18 <sipa> but it's possible/allowed, no?
01:49:28 <ior3k> alind: but I really recommend reading both
01:49:29 <EM03> these haskell web frameworks seem a bit lacking
01:49:37 <alind> ior3k: i will surely look into that as well.
01:49:43 <osfameron> ior3k, alind: I wouldn't *start* with RWH though (especially if coming from a Python etc. background).  LYAH first, then RWH
01:50:11 <gienah> alind: yes you will need real world haskell as soon as you actually try to write something like network code, etc
01:50:18 <dankna> mauke: yeah - but it supports them by having the undefined-behavior clause
01:50:37 <shachaf> mauke: Can you cast it to uintptr_t and then to uint8_t*, though?
01:50:43 <ior3k> osfameron: I did start with RWH, but to be honest only got it on the second reading :)
01:50:45 <dankna> mauke: I'm not saying you're wrong; I'm just interested
01:50:54 <alind> osfameron: one thing sure. RWH is bigger than LYAH. ;)
01:50:54 <ior3k> I like how it introduces types very early
01:50:59 <mauke> shachaf: good question. it's unlikely
01:50:59 <shachaf> ski: Right -- which is a very different thing from a call. :-)
01:51:15 <ski> dankna : you can safely convert a data pointer to `void *' and back. and you can safely convert between function pointer types, iirc
01:51:18 <shachaf> mauke: gcc -std=c99 -pedantic doesn't seem to complain.
01:51:36 <dankna> well, who cares what gcc thinks :)
01:51:39 <mauke> shachaf: doesn't say much
01:51:43 <shachaf> mauke: True.
01:52:25 <ski> shachaf : i suppose assuming `really_void' is a type having no values, `really_void (*)()' might be more appropriate ..
01:52:29 <alind>  am interested  in implementing HPC, parallel programming (multiprocessor things) with Haskell
01:53:03 <osfameron> HPC?
01:53:06 * shachaf wrote production code that stores jump addresses as uint64_t. :-)
01:53:13 <alind> So will finish the books/websites you recommended, then come back for help/confusions
01:53:33 <ior3k> alind: not sure if this works for you, but what worked for me was reading the book, finding Haskell a really strange language, then let it sink in for a bit, then going back to the book, then finding Haskell a brilliant language :)
01:53:37 <alind> osfameron: High performance computing,
01:53:59 <osfameron> ah
01:54:02 <ski> alind : fyi, note that you don't have to finish the book(s) before you come back here :)
01:54:09 <alind> osfameron: dividing algorithms in parallel so that they work on multiprocessor clusters
01:54:18 <alind> ski: thanks
01:54:58 <osfameron> that sounds like "fun" ;-)
01:55:35 <alind> osfameron: ya it is. I have been doing it in C++ but debugging sucks
01:56:10 <osfameron> hmmm, I have an upcoming project that might be nice as a multiprocessor thing
01:56:38 <Veinor> ahaha, wow. compiling this thing with ghc6 shows linear memory growth, ghc7 seems constant-ish
01:56:51 <alind> osfameron: can u share the project aim
01:58:30 <osfameron> alind: well, it's rather vague, it's for a "half-day-a-week" thing with my officemate.  We're thinking of doing something with public transport data, so perhaps things like routefinding (which would mean playing with distributed graph algorithms etc.)
02:00:12 <alind> osfameron: real world problems r always fun to deal with. Best of luck.
02:00:28 <osfameron> ty
02:00:47 * osfameron was just reading up on Erlang, might be an interesting task for that
02:00:58 <osfameron> (and then look at writing Erlang nodes in Haskell maybe ;-)
02:01:30 <alind> a tough task for me seeing the present state of my knowledge for these languages.
02:01:33 <alind> :)
02:01:53 <alind> will think, may be after 1 month.
02:02:17 <osfameron> yeah, me too.  But, just as RW are the most fun, they're also the best way to learn ;-)
02:02:43 <alind> i have to go now. Thanks to all for all the directions. Will meet again.
02:10:07 <gienah> osfameron: there is some erlang like stuff for haskell in development: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
02:10:52 <gienah> osfameron: https://github.com/jepst/CloudHaskell/
02:11:00 <osfameron> gienah: interesting.  I wonder, though, whether using a known *platform* like Erlang isn't a better idea?
02:11:19 <gienah> osfameron: possibly
02:11:45 <osfameron> as, in theory, you could write the nodes themselves in Erlang, Haskell, Python, Perl, etc., while having better community knowledge and employment/consultant pool (of how to administer BEAM machines etc.)
02:12:06 <osfameron> that said, for an R&D project it doesn't necessarily matter ;-)
02:12:08 <gienah> osfameron: although I am looking at using haskell for this stuff anyway as haskell has other stuff not in erlang: strong typing, software transactional memory, lots of pkgs on hackage
02:13:10 * osfameron bookmarks cloudhaskell
02:13:15 * hackagebot dtd-types 0.1.0.0 - Basic types for representing XML DTDs  http://hackage.haskell.org/package/dtd-types-0.1.0.0 (YitzGale)
02:13:25 <osfameron> gienah: yeah, I was thinking of http://hackage.haskell.org/packages/archive/erlang/0.1/doc/html/Foreign-Erlang.html for example
02:13:36 <osfameron> so to run each actual node as a Haskell program
02:13:56 <osfameron> or Erlang::Port or whatever in Perl
02:14:53 <xAndromeda> when i do myLength = foldl (\_ -> (+1)) 0 in ghci
02:14:54 <gienah> osfameron: it would be neat if it could talk to erlang, the cloud haskell/remote stuff can't though as it is doing lots of haskell specific stuff like closures, using Binary encoding, etc
02:15:31 <xAndromeda> it works if i define it inside but dosnt work if i load it
02:16:26 <ski> xAndromeda : do you pass an `Integer' to `myLength' ?
02:17:16 <xAndromeda> ski, i pass a general list
02:17:23 <ski> er, sorry
02:17:37 <xAndromeda> ski, what i dont get is why it works if i do let myLength = foldl (\_ -> (+1)) 0
02:17:42 <ski> i meant to ask, do you expect to get an `Integer' out of `myLength' ?
02:17:45 <xAndromeda> but not when i load it
02:17:46 <ski> or an `Int' or what ?
02:17:50 <xAndromeda> yes
02:18:00 <ski> try setting an explicit type signature like `let myLength :: Num n => [a] -> n; myLength = foldl (\_ -> (+1)) 0' in GHCi
02:18:25 <ski> (probably the DMR is kicking in in your case)
02:19:14 <xAndromeda> what's the dmr?
02:19:24 <ski> Dreaded Monomorphism Restriction
02:19:58 <ski> it forbids value bindings to have an overloaded type, unless you explicitly give a type signature
02:20:30 <ski> `f x = ..x..' is a function binding, `f = \x -> ..x..' and `f = foldr ...' and `(a,b) = ...' are value bindings
02:21:01 <ski> you can get around this restriction by adding an explicit type signature
02:21:10 <dankna> argh, okay
02:21:21 <xAndromeda> the one you suggested didnt work O.o
02:21:34 <ski> .. oh
02:21:38 * ski hits head
02:21:46 <ski> you have the arguments in wrong order
02:21:56 <dankna> so I have deduced (well, actually, intuited) that because of callbacks going both ways across the FFI barrier, I can potentially have to deal with the Objective C garbage collector calling back to me at any time
02:22:01 <ski> @type foldr (\_ -> (+1)) 0
02:22:02 <lambdabot> forall a a1. (Num a1) => [a] -> a1
02:22:04 <ski> @type foldl (\_ -> (+1)) 0
02:22:05 <lambdabot> forall a. (Num a) => [a] -> a
02:22:07 <dankna> I know that the flag I want on my foreign imports and exports is either "safe" or "unsafe"
02:22:08 <ski> @type foldr
02:22:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:22:09 <ski> @type foldl
02:22:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:22:31 <dankna> and I know that the last time I saw the documentation as to which it was, it was extremely confusing :)
02:22:33 <dankna> thoughts?
02:22:38 <ski> xAndromeda : compare the type signatures for `foldr' and `foldl' -- note that the argument function takes its arguments in different order
02:22:44 <adrake> given a what is almost certainly a LALR grammar, is a parser generated by happy and alex likely to be the most performant solution?
02:22:51 <dankna> adrake: yes
02:22:53 <ski> > foldr (\_ -> (+1)) 0 [2,3,5]
02:22:54 <lambdabot>   3
02:23:00 <ski> > foldr (\_ n -> n + 1) 0 [2,3,5]
02:23:01 <lambdabot>   3
02:23:04 <adrake> (as opposed to, say, attoparsec)
02:23:06 <ski> > foldl (\_ n -> n + 1) 0 [2,3,5]
02:23:06 <lambdabot>   6
02:23:14 <dankna> (but I'm biased in favor of parser generators)
02:23:21 <ski> > foldl (\n _ -> n + 1) 0 [2,3,5]
02:23:22 <lambdabot>   3
02:23:29 <adrake> dankna: fair enough -- do you have any intuition for how large the gap is?
02:23:33 <Baughn> dankna: 'unsafe' produces faster code, but does it by leaving that haskell capability (thread) in a possibly inconsistent state that doesn't allow callbacks
02:23:36 <ddarius> dankna: Just use "safe"
02:23:44 <dankna> adrake: not sure, no
02:24:01 <Baughn> dankna: Use 'safe', or nothing (which is 'safe') if you don't have a /need/ for unsafe.
02:24:03 <dankna> Baughn, ddarius: thanks, that was what I wanted to know :) and yes, I'm aware of what the distinction is; the problem is that the name is confusing :)
02:24:21 <adrake> dankna: alright :) I'm just looking to see what kind of penalties for using a nice combinator library I'm taking
02:24:22 <ski> xAndromeda : actually, instead of me trying to guess, why don't you describe/paste exactly what you typed into GHCi, what you saw, and what you expected to see ?
02:24:24 <Baughn> dankna: It's an unsafe import, because your can crash your program. ;)
02:24:25 <adrake> or might be taking
02:24:32 <osfameron> gienah: yeah, I guess that's the disadvantage of programming to a platform, rather than doing everything in-language
02:25:17 <dankna> hmm.... but I was leaving it blank, which should be defaulting to safe... I'd better look for another cause of my crash :/
02:25:50 <Baughn> dankna: Having two garbage-collector could be the cause. Unless you /know/ it's safe, you should assume it isn't.
02:26:12 <dankna> Baughn: oh I know a great deal about how both GCs work and am prepared to debug into their internals should it come to that
02:26:21 <Baughn> ..right.
02:26:22 <dankna> Baughn: I'm doing the grunt work of making it safe for those who come after me, in other words
02:26:47 <dankna> Baughn: or to put it another way, I agree that it is a possible cause of the crash but that doesn't mean I shouldn't be doing it :)
02:27:00 <xAndromeda> ski, http://goo.gl/Q3xoM
02:27:10 <xAndromeda> ski, it's a img
02:27:51 <Baughn> dankna: A noble undertaking. You have my keyboard!
02:27:56 <dankna> hehehe :D thanks!
02:28:02 <Baughn> dankna: Not me, mind you. Just my keyboard.
02:28:06 <dankna> haha, noted
02:28:18 <dankna> I'll keep that in mind if I need a melee weapon
02:29:39 <ski> xAndromeda : oh, i appear to have misunderstood you - i thought you got it working when loading from the module, but not when defining in GHCi ..
02:30:05 <xAndromeda> ski, well i just tried what you said
02:30:10 <xAndromeda> with foldr and it works
02:30:21 <ski> xAndromeda : anyway, i still think the problem is bad order of parameters
02:30:37 <xAndromeda> why would it work if you define it in ghci then?
02:30:40 <ski> xAndromeda : in the GHCi with `myLength' defined in it, try `myLength [False,True]'
02:31:11 <ski> or rather ..
02:31:15 <xAndromeda> ski, got 2
02:31:28 <ski> try that *after* replacing `foldr' with `foldl' in GHCi as well
02:31:30 <ski> :)
02:31:31 <xAndromeda> ski, seems to be working
02:31:45 <ski> you have `foldl' in your file and `foldr' in GHCi
02:31:50 <ski> those are not the same
02:32:02 <xAndromeda> ski, oh god im stupid @_@
02:32:22 <xAndromeda> totally missed that
02:32:25 <ski>   foldr :: (a -> r -> r) -> r -> [a] -> r
02:32:26 <ski>   foldl :: (r -> a -> r) -> r -> [a] -> r
02:32:31 <ski> do you see the difference ?
02:33:12 <ski> still, try `myLength [False,True]' again, after you fix the above, to make sure
02:33:43 <ski> (to make reasonably sure you've fixed it the right way, i.e.)
02:33:52 <xAndromeda> ski, yeah it works with foldr! thanks so much lol
02:34:48 <ski> xAndromeda> myLength' []
02:35:29 <xAndromeda> ski, 0! :D
02:35:35 <ski> try it ?
02:36:00 <xAndromeda> ski, man this stuff rocks :D
02:36:00 <ski> (using the version using `zip')
02:37:14 <ski> > let myLength' :: [a] -> Int; myLength' = fst . last . zip [1..] in myLength' [False,True]
02:37:16 <lambdabot>   2
02:37:18 <ski> > let myLength' :: [a] -> Int; myLength' = fst . last . zip [1..] in myLength' []
02:37:19 <lambdabot>   *Exception: Prelude.last: empty list
02:37:36 <xAndromeda> ski, huh neve thought of that
02:38:38 <Jafet> > let myLength' = fst . last . zip [0..] . inits in myLength' []
02:38:39 <lambdabot>   0
02:40:18 <ski> > let myLength' :: [a] -> Int; myLength' = fst . last . zip [0 ..] . (undefined :) in myLength' `map` [[],[False,True]]
02:40:19 <lambdabot>   [0,2]
02:43:58 <nerv> hi
02:44:18 <ski> hello
02:59:02 <dankna> HAH
02:59:06 <dankna> my crash wasn't related to Haskell at all
02:59:09 <dankna> and I just proved it :)
02:59:17 <dankna> ... didn't fix it yet though ><
02:59:35 * ddarius doesn't think too many people are surpised.
02:59:38 <dankna> haha
02:59:41 <Jafet> You suspected a crash in Haskell code?
02:59:51 <dankna> well, no - I suspected a crash caused by an interaction
02:59:59 <dankna> the call stack went C -> Haskell -> C
03:00:14 <dankna> and the crash occured during an invocation of the ObjC GC
03:00:38 <dankna> well,
03:00:49 <dankna> no, the call stack went C -> Haskell -> C -> Haskell
03:00:54 <dankna> and I stripped off the last -> Haskell
03:00:59 <dankna> so it could still be an interaction, hm
03:01:23 <Jafet> Mmm, callbacks of callbacks
03:01:26 <dankna> yeah
03:02:13 <dankna> hmm
03:02:28 <dankna> I can try disabling the ObjC GC while Haskell is on the call stack, haha
03:04:40 <dankna> wait, I can try running with the ObjC GC disabled entirely - that's a more reliable test
03:06:02 <dankna> okay, still crashes (at a slightly different place, obviously)
03:06:40 <theorbtwo> If I were you, I'd run it under valgrind.
03:06:42 <dankna> hmm
03:06:48 <dankna> can I /do/ that, given its hybrid nature?
03:06:53 <dankna> I thought valgrind was a source-level tool
03:07:05 <dankna> and I don't have source for the system libraries either, of course, this being a Mac ><
03:07:07 <theorbtwo> No, it's a runtime tool.
03:07:10 <dankna> oh, hmm
03:07:19 <dankna> looking into it then
03:07:35 <theorbtwo> It won't neccessarly give you great information against libraries that don't have debugging information in, of course.
03:07:53 <dankna> right
03:08:47 <theorbtwo> Compile everything you can with -g3, and run valgrind with --track-origins if you don't get readable information the first time.
03:08:54 <dankna> okay
03:10:57 <Jafet> valgrind is actually a JIT virtual machine into which you can plug a debugger
03:11:18 <Jafet> It operates on binaries
03:11:19 <dankna> ! okay
03:11:20 <dankna> neat
03:11:33 <Jafet> Not really, if you want descriptive diagnostics.
03:11:48 <dankna> well, I mean
03:12:03 <theorbtwo> Jafet: Technically.  It's also the name of the binary, which defaults to a memory-allocation-tracing debugger.
03:12:45 <theorbtwo> I found the diagnostics quite useful when debugging my C, but my situation was much simpler.
03:13:08 <dankna> the specific crash is dereferencing a null pointer, btw
03:13:49 <theorbtwo> (I had a strange mix of C and perl, but the two were seperate processes communicating over a pair of fds, so that wasn't relevant.)
03:13:54 * dankna nods
03:18:18 <dankna> Crookshanks:~/Projects/te$ valgrind dist/build/Te.app/Contents/MacOS/Te
03:18:18 <dankna> Segmentation fault
03:18:18 <dankna> :(
03:19:47 <theorbtwo> dankna: :( indeed.
03:21:18 <jesse_> hm..
03:22:23 <jesse_> I've tried monad transformers ( lift ) for transforming IO a -> MyMonad a but I don't know hot to implement the lift function right.
03:22:37 <dankna> it being a Mac program, I can't run it on another platform where valgrind is more mature :(
03:24:22 <jesse_> has someone some tips for IO a -> MyMonad a
03:25:19 <ski> how is `MyMonad' defined ?
03:25:53 <ski> also, are you sure you don't want to define `liftIO' ?
03:26:07 <ski> @type lift
03:26:08 <lambdabot>     Ambiguous occurrence `lift'
03:26:08 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
03:26:08 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
03:26:20 <jesse_> Yes, but I thought liftIO needs lift
03:26:28 <ski> @type Control.Monad.Trans.lift
03:26:28 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
03:26:30 <ski> @type Control.Monad.Trans.liftIO
03:26:30 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
03:26:45 <jesse_> Okay.
03:26:51 <jesse_> Look's simple.
03:28:55 <jesse_> ski: But then i must implement MonadIO for my datatype.
03:29:18 <dankna> okay!  I found my crasher
03:29:29 <dankna> I was misunderstanding the documentation of a rather low-level function
03:30:33 <ski> jesse_ : if `MyMonad' is defined by `newtype', possibly you can derive `MonadIO' (and `Monad' and `MonadTrans') for it ..
03:31:01 <ski> jesse_ : it's hard to give better suggestions, without seeing the code for `MyMonad'
03:31:07 <dankna> and of course the implementation of it if you can't derive it is simply instance MonadIO MyMonad where liftIO = lift, heh
03:31:17 <dankna> oh, he can't write lift
03:31:18 <dankna> never mind :)
03:31:24 <jesse_> ski: thx, wait...
03:31:56 <jesse_> ski: newtype NetworkPlayground a = NetworkPlayground{ execNetworkPlayground :: (a, NetworkData) }
03:32:08 <jesse_> NetworkData is a tuple of strings
03:32:53 <ski> (dankna : exactly `liftIO = lift' would probably not work .. unless `MyMonad' was a type synonym for `MyMonadTrans IO')
03:33:34 <ski> jesse_ : you can't write a sensible `IO a -> NetworkPlayground a' with that ..
03:34:02 <jesse_> Why?
03:34:05 <ski> you need to have an `IO' buried somewhere inside the definition of your monad, to be able to have `liftIO'
03:34:11 <ddarius> jesse_: Why do you think you could?
03:34:13 <jesse_> Ah, makes sense.
03:34:15 <dankna> (sky: oh, yeah.  indeed.)
03:34:39 <ski> if your monad doesn't contain `IO'-actions somewhere inside, then you can't convert `IO'-actions into it
03:34:55 <jesse_> ddarius: hm, good question. the acts more than a container type, i think..
03:35:05 <jesse_> yeah, makes sense.
03:35:35 <ddarius> Even if it was a "container" say [a] or Maybe a instead of IO a, it still wouldn't be very sensible.
03:35:47 <jesse_> k.
03:36:21 <jesse_> is this valid:
03:36:56 <jesse_> hm...
03:37:51 <jesse_> My data type must contain something like this: (IO String, a, NetworkData)
03:38:29 <ski> maybe `IO (String,a,NetworkData)' is what you want ?
03:38:59 <ski> (what's the `String' for, btw ?)
03:39:07 <jesse_> ski: I think I must read chapter 14 again...
03:39:30 <jesse_> ski: I want to implement a network protocol for an ai competition.
03:39:30 * ski has no idea what chapter 14 contains ..
03:39:39 <jesse_> Monads.
03:39:50 <jesse_> chapter 15 is about monad transformers.
03:40:02 <ddarius> Providing context is not jesse_'s strong point.
03:40:47 <ski> do you want a `NetworkPlayground a' action to (apart from doing some I/O), compute a value of type `a', and *additionally* compute a value of type `NetworkData' ?
03:41:10 <ski> or maybe you want it to *use* a previously computed value of type `NetworkData' instead ?
03:41:19 <jesse_> yeah
03:41:33 <ski> or maybe you want it to use a previous `NetworkData', and also compute a (possibly) new such one ?
03:41:42 <jesse_> nope
03:41:49 <ski> you have to decide what variant (if any) you want
03:42:03 <ski> ok, so it sounds more like `NetworkData -> IO a' then ?
03:42:13 <ski> (what was the `String' above for ?)
03:42:57 <ski> `NetworkData -> IO a' will use a provided `NetworkData', do some I/O, computing an `a'
03:43:10 * ddarius recommends that ski asks a question and then waits for an answer.
03:43:16 <jesse_> ack :P
03:43:25 <ski> `IO (a,NetworkData)' will do some I/O, computing an `a' and a `NetworkData'
03:43:55 <jesse_> ski: no, my program gets data via http from a webserver. this data has the type IO String.
03:44:15 <cpa> hi there
03:44:24 <jesse_> and now I want to parse the incomming data
03:44:25 <dankna> well, the data it gets actually has the type String
03:44:28 <dankna> IO String is /how/ it gets it
03:44:28 <cpa> is there an up to date equivalent of this page:
03:44:30 <cpa> http://www.haskell.org/haskellwiki/GHC/As_a_library#Another_example
03:44:31 <cpa> ?
03:44:36 <jesse_> ^^Yeah
03:45:46 <dankna> cpa: I don't believe there is, but have you tried it and how is it failing, and if you get it working, please update the page
03:46:22 <cpa> I tried it; I have a type error I don't understand
03:46:29 <dankna> hpaste the type error
03:47:03 <ski> jesse_ : so what is an `NetworkPlayground'-action supposed to do, then ?
03:47:15 <ski> parsing, in your case ?
03:47:20 <jesse_> yeah
03:47:41 <ddarius> ski: Leave your questions open-ended, so you get something more than "yeah" or "nope."
03:47:44 <cpa> there it is: http://hpaste.org/47294/ghc_api
03:48:04 <ski> does `NetworkData' contain previously established information that it needs to communicate over the network ?
03:48:31 <jesse_> NetworkData contains the parsed string and an url to the server.
03:48:37 <cpa> actually I also had to add "import DynFlags" in A.hs (otherwise it says that xopt_set is not defined)
03:48:47 <ski> jesse_ : so, elaborate on what your `NetworkPlayground' is supposed to do ..
03:48:57 <jesse_> ski: thx. :)
03:49:22 <ski> hm
03:49:29 <jesse_> ddarius: Sorry, but my english is not the best. Sometimes i can't express what I want to say. ;)
03:49:34 <dankna> cpa: it's treating the statement on the next line as two extra parameters to the foldl
03:49:41 <dankna> cpa: this has to be because of indentation being wrong
03:50:32 <ddarius> jesse_: The problem isn't that people don't understand your explanation of what you are doing, the problem is that you haven't provided an explanation at all.
03:51:43 <cpa> dankna: damn, never copy paste code :)
03:51:49 <dankna> cpa: hehe yeah :)
03:54:11 <cpa> thanks! it's working now; but I had to add import DynFlags (I'm on ghc7.0.3); I'll update the wiki
03:54:48 <dankna> sounds good :)
04:02:30 <jesse_> ddarius: Okay, I thought the problem is not the definition of the data type.
04:03:16 <ski> our problem is that we're not sure what your problem is
04:03:35 <ski> you haven't explained enough about what you want to do
04:04:01 <jesse_> hehe :P
04:04:42 <jesse_> okay, i think i should separate between networking information and parsing data.
04:19:37 <FUZxxl> @source concatMap
04:19:37 <lambdabot> concatMap not available
04:19:40 <FUZxxl> @source conca
04:19:41 <lambdabot> conca not available
04:19:42 <FUZxxl> @source concar
04:19:42 <lambdabot> concar not available
04:19:43 <FUZxxl> @source concat
04:19:44 <lambdabot> concat not available
04:19:49 <FUZxxl> @src concat
04:19:49 <lambdabot> concat = foldr (++) []
04:20:50 <ski> @src concatMap
04:20:50 <lambdabot> concatMap f = foldr ((++) . f) []
04:21:07 <ski>   concatMap f = concat . map f
04:21:21 <ski>   concatMap f = (>>= f)
04:54:31 <Jafet> http://hackage.haskell.org/trac/hackage/ticket/368
04:54:33 <Jafet> ...what.
05:06:47 <adimit> So, if I want to map a *huge* amount of small bytestrings to numbers, it seems the only thing hackage offers me is Data.Map, no?
05:07:35 <adimit> (bytestring-trie seems to have abysmal performance, triemap doesn't have a strict insertion function, and mutable hashmaps are actually not what I want‚Ä¶)
05:11:33 <Jafet> Persistent incremental hash tables!
05:13:01 <Axman6> adimit: there's tibbe's hash array mapped trie which is supposed to be very fast. i think the package is called unordered-cintainers
05:14:42 <Jafet> "O(min(n,W))" doesn't look very encouraging
05:15:07 <Jafet> Oh, I read it wrong
05:15:15 <tibbe> Axman6, unordered-containers is based on a Patricia tree at the moment, I will try to switch it to a HAMT in GHC 7.2
05:15:16 <zygoloid> aka O(1)
05:15:39 <tibbe> Jafet, it has insert time comparable to hash tables and lookup times no worse than 2x
05:15:46 <Axman6> tibbe: ah right. waiting for the memcpy stuff?
05:15:48 <tibbe> (good hash tables that is, not Data.Hashtable)
05:15:52 <tibbe> Axman6, exactly
05:16:17 <Axman6> hey with the memcpy stuff, have you guys verified the copies never overlap?
05:16:22 * zygoloid thinks asymptotic notation is somewhat of a joke for a data structure with bounded maximum size
05:16:27 <adimit> Jafet, Axman6, tibbe thanks, I'll trie (har har) em out.
05:16:55 <Jafet> It's somewhat of a joke anyway
05:16:59 <adimit> (I was also *very* surprised to see bytestring-trie consistently perform at around 50% of Data.Map‚Ä¶ Maybe I'm doing something wrong.)
05:17:03 <Axman6> zygoloid: indeed, it must be O(1) for all operations!
05:18:00 <tibbe> adimit, no, it's just slow
05:18:07 <tibbe> Axman6, we have
05:18:09 <adimit> I basically just need fast insertion, since I'm either inserting or reading, which means I can just marshal everything into an immutable hashmap once I'm done recording.
05:18:18 <tibbe> Axman6, for the cases it can we test for overlap and use memmove
05:18:31 <adimit> tibbe: good to know it's not just me having to clue how to reason over Haskell's performance bottlenecks ^^
05:18:48 <tibbe> adimit, a hashmap is not necessarily faster, unless you have something better than Data.Hashtable
05:19:01 <Axman6> if that's the case, is there any reason not to use memmove for all of them? it seems logical that it would drop through to using memcpy of the regions don't overlap
05:19:05 <adimit> tibbe: ok, i'll play around and see what's best.
05:19:18 <tibbe> adimit, Gregory Collins is going to post some benchmarks of unordered-containers vs different hash tables soonish
05:19:19 <Axman6> probably worth investigating if that's true, but it would make things simpler no?
05:19:47 <tibbe> Axman6, in some cases we know the arrays cannot overlap so we can skip the branch
05:19:57 <Axman6> ok
05:19:59 <tibbe> Axman6, besides, we only unroll memcpy (and memset), not memmove
05:20:53 <adimit> tibbe: the only difference between Data.HashMap.{Lazy,Strict} is that the latter has its values in HNF?
05:21:01 * tibbe wonders if representing tuples as two element arrays will be about as was as using (a,b)
05:21:13 <tibbe> adimit, yes, but's it's WHNF
05:21:45 <adimit> tibbe: good. Well, WHNF of (a+b::Int) is hopefully an Int.
05:21:50 <tibbe> it is :)
05:22:21 <tibbe> I avoid forcing to HNF using rnf as it might cause a completely redundant traversal if the structure is already evaluated
05:23:04 <adimit> yeah, deepseq should be used with care‚Ä¶ It was the only way to get TrieMap to "work as expected" and it still blew my stack with non-trivial input.
05:23:34 <adimit> (I guess throwing 30GB of text at any form of map is going to result in interesting performance problems, though.)
05:23:44 <zygoloid> tibbe: you presumably mean rnf not hnf? i thought hnf was whnf except that if the object is a lambda, you reduce the expression within it to hnf?
05:24:44 <tibbe> zygoloid, I thought rnf was the function and HNF was the name of the form
05:25:09 <tibbe> zygoloid, if you reduce inside lambdas you will evaluate everything
05:25:28 <zygoloid> tibbe: with hnf, you stop once you get to a data ctor (the "head")
05:25:38 <Axman6> except unbound variables?
05:25:39 <adimit> tibbe: reporting around 40% speedup with Data.HashMap. I am impressed :-) Thanks for the nice work!
05:26:47 <tibbe> adimit, :)
05:28:56 <adimit> I still seem to be leaking space somewhere thoug. *bawl* I find it ridiculously hard to understand memory-behaviour of Haskell programs‚Ä¶
05:28:57 <zygoloid> tibbe: also, consider: f x y b = if b then x else y. hnf (f undefined 0) does not evaluate x (or y for that matter).
05:30:52 <medfly> hi, will System.Cmd.rawSystem create a new thread and carry on its fine life or will it wait for the command to return an exit code?
05:32:24 <ben> System.Cmd.rawSystem "bash" ["-c", "sleep 200"]
05:33:14 <hpc> :t rawSystem
05:33:14 <lambdabot> Not in scope: `rawSystem'
05:33:19 <hpc> @hoogle rawSystem
05:33:19 <lambdabot> No results found
05:33:25 <hpc> pah
05:33:57 <Egbert9e9> :t scaryFunctionsThatCanTapIntoLambdabotsServer
05:33:58 <lambdabot>     Not in scope: `scaryFunctionsThatCanTapIntoLambdabotsServer'
05:34:18 <medfly> thanks ben
05:37:35 <hpc> Egbert9e9: lambdabot can :t more functions than it can mueval
05:38:06 <Egbert9e9> what's a mueval..?
05:38:09 <hpc> :t putStrLn
05:38:10 <Egbert9e9> i'll google!
05:38:10 <lambdabot> String -> IO ()
05:38:19 <Axman6> > 1+1
05:38:20 <lambdabot>   2
05:38:44 <hpc> mueval is the package that lets you run haskell code strings
05:39:20 <hpc> mueval "sum [1..5]", etc
05:39:30 <shachaf> hpc: s/more/different/
05:39:41 <hpc> shachaf: yes, that
05:40:10 <hpc> :t unsafeCoerce
05:40:11 <lambdabot> forall a b. a -> b
05:40:28 <hpc> > unsafeCoerce 5 :: String
05:40:41 <zygoloid> um oops?
05:40:43 <lambdabot>   thread killed
05:40:49 <hpc> oops indeed
05:41:01 <Axman6> > unsafeCoerce False :: Maybe
05:41:04 <Axman6> > unsafeCoerce False :: Maybe ()
05:41:05 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
05:41:07 <Silvah> @hoogle unsafeCoerce
05:41:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:41:19 <lambdabot>   thread killed
05:41:20 <hpc> Œªbot is being slow it seems
05:41:22 <hpc> > 5
05:41:22 <lambdabot>   5
05:41:34 <Axman6> > unsafeCoerce (256 :: Int) :: Word
05:41:49 <lambdabot>   thread killed
05:42:09 <Silvah> > unsafeCoerce 5145147852 :: Maybe ()
05:42:24 <lambdabot>   thread killed
05:42:32 <zygoloid> > runST (unsafeCoerce (putStrLn "Hello")) :: ()
05:42:33 <Axman6> > unsafeCoerce (1::Int) :: Int
05:42:47 <lambdabot>   thread killed
05:42:48 <lambdabot>   thread killed
05:42:52 <Axman6> :(
05:43:18 <Axman6> I've seen it work in here before, but it needs very specific types
05:43:24 <zygoloid> someone had @let it
05:43:34 <zygoloid> @undef
05:43:38 <zygoloid> > unsafeCoerce "Hello"
05:43:39 <lambdabot>   Not in scope: `unsafeCoerce'
05:44:07 <Silvah> @let unsafeCoerce x = unsafeCoerce x
05:44:08 <Axman6> bah
05:44:10 <lambdabot>  Defined.
05:44:15 <Axman6> :t unsafeCoerce
05:44:16 <lambdabot> forall t1 t. t1 -> t
05:44:32 <Silvah> @hoogle ST
05:44:32 <lambdabot> module Control.Monad.ST
05:44:33 <lambdabot> module Data.Array.ST
05:44:33 <lambdabot> Control.Monad.ST data ST s a
05:45:25 <Silvah> Now, let's try to guess the old definition of unsafeCoerce!
05:45:35 <Axman6> it's probably that one
05:46:15 <Axman6> :t let unsafeCoerce :: a -> b; unsafeCoerce x = unsafeCoerce x in unsafeCoerce
05:46:16 <lambdabot> forall a b. a -> b
05:46:28 <Silvah> @unedf
05:46:28 <lambdabot> Maybe you meant: undo unpf
05:46:30 <Silvah> @undef
05:46:46 <medfly> ugh... how do I make Haskell ignore the output of some function? it's complaining about types and stuff
05:47:01 <Axman6> in what situation?
05:47:04 <Silvah> @let unsafeCoerce :: a -> b; unsafeCoerce x = unsafeCoerce x
05:47:05 <lambdabot>  Defined.
05:47:09 <Silvah> :t unsafeCoerce
05:47:10 <lambdabot> forall a b. a -> b
05:47:37 <medfly> it's expecting IO () but I give it IO somethingsomesuch
05:47:46 <Silvah> > unsafeCoerce 5 :: Int
05:47:48 <Egbert9e9> medfly: return ()
05:47:50 <lambdabot>   mueval-core: Time limit exceeded
05:47:56 <medfly> :t unsafecoerce
05:47:56 <Egbert9e9> medfly: you can add that
05:47:57 <lambdabot> Not in scope: `unsafecoerce'
05:48:00 <medfly> :t unsafeCoerce
05:48:00 <lambdabot> forall a b. a -> b
05:48:01 <Silvah> Axman6: ouch
05:48:03 <parcs> medfly: Control.Monad.void
05:48:09 <parcs> or >> return ()
05:48:15 <Silvah> It's not that one apparently.
05:48:35 <Silvah> @undef
05:48:57 <Silvah> > let f _ = fix f in f 5
05:49:01 <lambdabot>   mueval-core: Time limit exceeded
05:49:06 <medfly> yeah, I'm starting to understand all the people t hat complained about Haskell
05:49:44 <Axman6> medfly: you think you should be able to ignore the type system?
05:50:27 <shachaf> Axman6: You haven't been writing enough C if that's your attitude.
05:50:37 <hpc> :t let f _ = fix f in f
05:50:38 <medfly> I just want to start a new thread doing this, I am not using the output at all, why is it important what type it has?
05:50:38 <lambdabot> forall a. a -> a
05:50:44 <Axman6> I've been writing plenty of good C
05:51:27 <Axman6> medfly: in that particular case, i never understood it either
05:51:27 <dankna> medfly: then its type is IO ()
05:51:34 <shachaf> medfly: The function is probably mistyped.
05:51:44 <medfly> ah, better
05:51:45 <shachaf> medfly: It should accept forall a. IO a, like main.
05:51:46 <Axman6> the function is forkIO
05:51:58 <Egbert9e9> shachaf: the function returns all sorts of data about the process
05:52:13 <medfly> fixed it
05:52:27 <Egbert9e9> medfly: what did you get
05:53:42 <Axman6> weak, i was just about to ask JaffaCake why forkIO takes IO ()
05:54:33 <parcs> @hoogle forkIO
05:54:33 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
05:54:36 <parcs> Egbert9e9: what?
05:54:42 <JaffaCake> Axman6: as opposed to IO a, you mean?
05:54:50 <Axman6> indeed :)
05:55:05 <Egbert9e9> parcs: uh.. i don't knwo
05:55:13 <Axman6> is there some rationale for that?
05:55:27 <dankna> the rationale is the same as why main should really be :: IO () =p
05:55:31 <JaffaCake> Axman6: I don't know what the original reasoning was, but I know some people prefer not to discard results silently
05:55:57 <djahandarie> dankna, because I/O isn't polymorphic? ;)))
05:55:59 <JaffaCake> main original was IO (), then it changed IIRC
05:56:14 <dankna> djahandarie, amusement!
05:56:14 <JaffaCake> perhaps forkIO should change to match
05:56:15 <Axman6> maybe there should be a forkIO' :: IO a -> IO (ThreadId, MVar a)
05:56:47 <dankna> forkIO' = (\action -> action >> return ()) -- =P
05:56:50 <dankna> oh, hm
05:57:22 <dankna> didn't read that signature before I said that
05:59:11 <medfly> so my friend here wants to run another app and use its output in his Haskell code...
05:59:32 <Axman6> there's plenty of times I've found myself writing forkIO (something >> return ())
05:59:49 <djahandarie> Axman6, now packaged up as 'void' :)
05:59:49 <parcs> write forkIO (void something) instead :D
05:59:51 <Axman6> medfly: getContents will return the contents of stdin
06:00:07 <Axman6> is void defined somewhere?
06:00:08 <medfly> how does he use getContents?
06:00:13 <medfly> :t void
06:00:14 <lambdabot> Not in scope: `void'
06:00:24 <parcs> @hoogle void
06:00:24 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
06:00:26 <Axman6> because, I've been advocating having a void function for a long time :o
06:00:37 <djahandarie> Axman6, in the new libs
06:00:39 <djahandarie> I forget where...
06:00:41 <parcs> it's in control.monad
06:00:47 <medfly> hurray
06:00:56 <Axman6> hoorah
06:02:22 <HugoDaniel> can someone give me an example of something that haskell does better than most non-functional languages (like python for example)...
06:02:48 <Jafet> @protontorpedo
06:02:49 <lambdabot> what echniques can be used to scael application in haskell?
06:02:55 <Axman6> be typesafe?
06:03:23 <Botje> HugoDaniel: tree rewriting is pretty nice.
06:03:24 <Axman6> let you write provably correct code?
06:03:25 <dankna> HugoDaniel: runtime performance is not really the metric that counts to most of us, I suspect; it's developer productivity
06:03:45 <dankna> HugoDaniel: by that metric, it does /everything/ better :)
06:03:49 <Jafet> Type checking is what people think is the greatest benefit of strong typing
06:03:51 <dankna> HugoDaniel: including imperative code
06:03:57 <Axman6> let you write very powerful abstractions quite easily
06:04:02 <adimit> Given I have a strict BS w, imported Data.ByteString.Char8 as S, how can I force (S.map toLower w) completely? I.e. not into WHNF, since it seems that will still leave the heap object a thunk, not a BS.
06:04:09 <HugoDaniel> :D
06:04:39 <dankna> adimit: if you really need it, see the deepseq package
06:04:54 <Axman6> parallelism in haskell is so much nicer in Haskell than pretty much anything else
06:05:02 <Axman6> we've also got STM
06:05:21 <adimit> dankna: ah, I thought there'd be a way to `seq` my way around that.
06:05:44 <HugoDaniel> ok, cool, i have a nice set of features to brag about, thanks :)
06:06:06 <Jafet> The real benefit is type inference. You tell the language that only certain kinds of code are allowed until it ends up at the only program that can exist
06:06:14 <dankna> adimit: there is, but you have to define stuff and do it recursively.  which is what the deepseq package makes simpler.
06:06:42 <dankna> yeah - I also often let the typechecker serve as my to-do list :)
06:06:59 <dankna> that is, when I want to refactor the program in some major way, first I edit the type of some top-level function
06:07:17 <adimit> dankna: ok, thanks.
06:07:20 <dankna> then I try to compile and it spits out a nice list of all the callees which are now typed wrongly, so I go down the list and fix them
06:07:35 <Jafet> And a lot of people don't "get" this benefit until they start using languages like *ML and Haskell
06:07:43 <dankna> eventually I've got all the types correct and all my remaining errors are in the form "expected type does not match actual type", so I fix those too
06:07:44 <Jafet> So I suspect it's a pretty deep one
06:07:53 <dankna> when everything is fixed, my refactoring is done :D
06:08:02 <dankna> much nicer than keeping the list in my head haha
06:08:09 <Egbert9e9> efood!
06:08:15 <dankna> yeah, absolutely, Jafet
06:08:36 <Jafet> (Unfortunately?), this means that you can't use this to sell them Haskell
06:08:42 <dankna> sure you can
06:08:48 <dankna> you just have to pitch it right
06:09:00 <dankna> "Haskell will change the way you think about programming" unfortunately sounds pretty trite, even though it's true
06:09:03 <Jafet> It's an instance of the blub problem.
06:09:09 <dankna> haha
06:09:15 <dankna> not convinced that blubs are a useful concept
06:09:16 <isomorphic> it's not unlike advocating -Wall
06:09:23 <dankna> true enough
06:09:27 * dankna uses -Wall when applicable
06:09:41 <mun_> if i have a logical sentence "f(a)", where f is a function and a is a constant, and I rewrite it to "%x. f(x)" and "a". are these two terms "subterms" of "f(a)"? is that the right terminology?
06:10:14 <Jafet> mun: er, what language?
06:10:28 <Jafet> In the lambda calculus, that resembles an eta abstraction
06:11:32 <quicksilver> mun_: no. They are not.
06:11:38 <mun_> Jafet, yes, lambda calculus.
06:11:42 <quicksilver> mun_: sub term is a syntactical notion.
06:11:47 <quicksilver> 'a' is a subterm of f(a)
06:11:54 <quicksilver> but \x . f(x) is not.
06:12:06 <mun_> quicksilver, right. what would it be called?
06:12:13 <quicksilver> obviously \x . f(x) and 'a' are both subterms of (\x . f(x)) a
06:12:15 <adimit> I hate that deepseq basically forces the compiler to throw orphan instance warnings‚Ä¶ a bit of a wart IMHO.
06:12:34 <quicksilver> I'm not sure what part you're trying to name
06:12:38 * Jafet mumbles something unprintable about the people who insist on clean -Walls
06:12:51 <quicksilver> that's a kind of rewrite which, as Jafet said, resembles eta expansion.
06:12:53 * dankna insists on clean -Walls
06:12:58 <adimit> It's more of an OCD than anything.
06:13:05 <Igloo> mun_: I wonder if you want to eta expand f first, and then take the 2 sub terms?
06:13:10 <dankna> the reason to keep -Wall clean is that otherwise you can't keep it clean!
06:13:36 <adimit> everytime I compile something and it spits out warnings, I have to look, and that makes me worry. And I like being happy, not worried.
06:13:47 * isomorphic throws -pedantic into the mix
06:14:37 <Silvah> wtf I've done?
06:15:21 <Jafet> It's great to have done
06:16:04 <mun_> Jafet, quicksilver, Igloo sure. maybe that isn't a good example. say, i have f(a,b), and I match x(y) to it. one instantiation might be x |-> id and y |-> f(a,b). of course there could be many other instantiations too. but what are x and y actually instantiated to? are those called subterms? since id isn't part of the original term, then these can't be subterms, right?
06:17:05 <Jafet> The subterms of (f a b) are (f a b), f, a, and b
06:17:19 <armence> So, it looks like Haskell records do not have their own namespace. I can't for instance have a Purchase record with the field "customerID" which matches the field "customerID" in a Customer record. How does one usually get around that?
06:17:26 <Igloo> Jafet: and (f a)
06:17:28 <mun_> some other instantiations might be, x |-> \v. f(a,v), y |-> b. then how does the instantiation of x relate to f(a,b)?
06:17:45 <scooty-puff> armence, see DisambiguateRecords extenstion
06:17:51 * Jafet burned by the curry
06:17:55 <alt-nick> there ><
06:18:04 <alt-nick> I just had a talk with the person who was flipping circuit breakers indiscriminately ><
06:18:07 <Jafet> armence: give them different names
06:18:16 <scooty-puff> armence, *DisambiguateRecordFields
06:18:47 <scooty-puff> anyone here familiar with the parameterized monad type class?
06:19:11 <Jafet> Which one?
06:19:21 <armence> scooty-puff, Thanks
06:19:34 <scooty-puff> well, i defined my own (if there's a library, that would be nice) (give me a second to hpaste it)
06:20:15 <Jafet> mun: I've never seen anyone want to do that, so there probably isn't a name for it
06:20:27 <scooty-puff> http://hpaste.org/47299/parameterized_monad
06:20:47 <scooty-puff> it works fine with RebindableSyntax, etc.
06:20:57 <mun_> Jafet, right. ok. thanks.
06:21:19 <quicksilver> mun_: I'd call them substitutions (not instantiations) and I'd talk about 'the values give to x and y in a different substitution'
06:21:21 <scooty-puff> but using DoRec "do rec { ... }", it seems to "tighten the knot" (terminology?) too much, to where the type variables don't line up
06:21:22 <quicksilver> or something.
06:22:09 <mun_> quicksilver, hmm why substitution and not instantiations?
06:22:28 <quicksilver> dunno really.
06:22:40 <adimit> dam, it seems deepseq didn't help at all. boo. May I kindly request somebody look at some of my code? http://hpaste.org/47300/spaceleak ‚Äî This is supposed to count word frequencies in very large files.
06:22:56 <Jafet> scooty-puff: I don't really understand your Monad
06:22:59 <djahandarie> scooty-puff, it's called an 'indexed monad' and it's in category-extras, but that package is enormous and deprecated
06:23:07 <Jafet> Three type variables?
06:23:32 <scooty-puff> yeah, i'm using them as phantom types, so easier in my case
06:23:49 <adimit> using deepseq'ed S.map toLower still makes my ram usage skyrocket, and the program of course takes much longer‚Ä¶
06:23:54 <scooty-puff> i have to use mfix directly though, i'll put an hpaste for it
06:23:55 <dankna> adimit: try compiling with -prof, then running with +RTS -hy, then invoking hp2ps foo.prof, then viewing foo.ps in your favorite PostScript viewer
06:23:59 <owst> This may be obvious, but what's the canonical way to create a new empty file in Haskell?
06:24:41 <Jafet> writeFile f "" isn't sufficiently canonical?
06:24:46 <adimit> dankna: in progress.
06:24:53 <dankna> adimit: k
06:25:01 <djahandarie> scooty-puff, an alternative approach is this: http://hackage.haskell.org/package/monad-param
06:25:51 <parcs> @hoogle openFile
06:25:51 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
06:26:08 <parcs> owst: openFile "file.ext" AppendMode >>= closeHandle
06:26:12 <owst> I did initially think "open in write mode, then close immediately"
06:26:23 <parcs> hClose*
06:26:28 <owst> parcs: Yeah, that, in fact.
06:26:45 <medfly> what is the term for non-do notation way of doing IO?
06:26:51 <medfly> and stuff like that
06:27:13 <djahandarie> medfly, normal Haskell programming?
06:27:20 <medfly> but I want to google it
06:27:27 <medfly> and stop getting results with do notation
06:27:28 <zygoloid> IO combinators?
06:27:50 <djahandarie> You could call it that but it isn't called that
06:28:00 <djahandarie> It'd really be a term for nothing at all
06:28:06 <scooty-puff> http://hpaste.org/47301/dorec
06:28:09 <medfly> sigh
06:28:19 <medfly> I'll just ask my damn question here :P
06:28:19 <zygoloid> sure, but it's something to google, which will probably find the right search results
06:28:35 <Jafet> FRP?
06:28:38 <parcs> i don't think there is such thing as non-do monadic notation. it's normal function application from there
06:28:59 <scooty-puff> djahandarie, thats the DoRec related failure - the type variables are not properly respected when it tightens the rec block (see the error in comments)
06:30:41 <shapr> Jafet: functional reactive programming?
06:31:01 <Jafet> Yeah, throwing search keywords around
06:31:02 <adimit> dankna: here's the two profiles: http://imgur.com/a/aeVSF ‚Äî first is w/o toLower.
06:31:06 <medfly> http://hpaste.org/47302/halp question in comment
06:31:08 <medfly> ^_^
06:31:27 <medfly> should be pretty obvious which, too
06:32:04 <dankna> adimit: hmmmmm okay
06:32:06 <adimit> it doesn't seem that hy-profiling reports very accurate numbers here; I can measure a lot more memory usage in htop.
06:32:16 <adimit> (for the second case)
06:32:27 <djahandarie> scooty-puff, how is rec defined?
06:32:35 <dankna> adimit: well, it's heap profiling; the stack can also have a significant amount of data on it
06:32:44 <adimit> dankna: that's what I'm suspecting.
06:33:07 <scooty-puff> djahandarie, see http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/syntax-extns.html
06:33:11 <scooty-puff> part 7.3.8
06:33:13 <dankna> I confess I'm not really familiar with Iteratees or I would probably see the cause of the problem
06:33:18 <dankna> it's good that your code is so nice and short
06:33:22 <dankna> makes it much easier to diagnose
06:33:25 <scooty-puff> the way i desugar it is pretty close - or at least i beleive it is
06:33:41 <Jafet> @undo do { (in, out, err, h) <- newproc; putStr . hGetLine $ whichone in out err } -- medfly
06:33:41 <lambdabot>  Parse error at "in," (column 7)
06:33:55 <djahandarie> scooty-puff, I've never seen this actually
06:33:55 <adimit> dankna: well, if I paste it for people to see, I might as well cut out all the crap that has nothing to with my question :-P
06:33:56 <Jafet> @undo do { (sin, out, err, h) <- newproc; putStr . hGetLine $ whichone sin out err }
06:33:56 <lambdabot> newproc >>= \ (sin, out, err, h) -> putStr . hGetLine $ whichone sin out err
06:34:05 <dankna> adimit: absolutely
06:34:20 * hackagebot NanoProlog 0.2.2 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.2.2 (JurrienStutterheim)
06:34:28 <medfly> ah
06:34:31 <dankna> adimit: well, for example, I (still) have a performance problem in a "small" program that is far too big to really show
06:34:34 <medfly> thank you :D
06:35:00 <dankna> adimit: anyway, I don't see anything obviously wrong with it :(
06:35:16 <scooty-puff> djahandarie, ok, thanks for the help anyways - i think i acutlaly have to leave it as mfix, because my monad isn't a good MonadFix instance - i can make it one, but it doesn't follow the laws
06:35:37 <dankna> adimit: that sure is a lot of HashMaps.  why is it retaining the old ones?
06:35:52 <adimit> dankna: neither do I :-\ I thought, maybe I'm using deepseq wrong‚Ä¶ I kinda doubt that just mapping toLower on the input is going to reduce performance 2-fold, and make it use 3-times more ram.
06:36:17 <adimit> dankna: I have no idea. I actually don't need to keep any more than one hash map around.
06:36:29 <adimit> maybe I should try something mutable‚Ä¶
06:36:42 <dankna> adimit: mutability is one thought, more strictness is another
06:36:49 <dankna> adimit: worth playing with both
06:37:19 <adimit> dankna: I see no obvious point where to introduce more strictness though :-\ To be fair, so far, I only just kinda sprinkled seq around and hoped it'd help.
06:37:39 <adimit> ‚Ä¶ which is an incredibly awful way of "debugging." I'd like to actually know what's going on.
06:37:56 <Jafet> scooty-puff: do you use higher-rank types to fill the phantom variables?
06:37:58 <adimit> (btw, the input file in this case was some 75M big, and in my actual program, it'd be like 1.6GB big.)
06:38:24 <dankna> adimit: I see.  yeah, I agree it's better to understand than to guess.
06:38:45 <adimit> dankna: maybe this would warrant a post on cafe?
06:38:51 <Jafet> I don't know how do rec works, but you might need extra type signatures
06:38:52 <adimit> I'm really puzzled.
06:39:03 <dankna> adimit: you can certainly try it
06:39:03 <scooty-puff> Jafet, they're actually never referenced - its used to verify the operand stack for an instruction selector for the java virtual machine
06:41:00 <adimit> dankna: looking at the -hb profile, I can sure see a ton of BS and HashMap LAGing around.
06:41:18 <medfly> sigh
06:41:25 <dankna> adimit: yeah, I would expect as much
06:41:36 <dankna> try looking at -hr to get an idea of what's keeping them
06:42:09 <adimit> ugh, can't mix -hb and -hr. Ah well ^^
06:42:21 * hackagebot hfusion 0.0.5 - A library for fusing a subset of Haskell programs.  http://hackage.haskell.org/package/hfusion-0.0.5 (FacundoDominguez)
06:43:45 <medfly> I need something that results in IO String...
06:43:54 <medfly> @hoogle String -> IO String
06:43:54 <lambdabot> System.Environment getEnv :: String -> IO String
06:43:54 <lambdabot> Prelude readFile :: FilePath -> IO String
06:43:54 <lambdabot> System.Directory getAppUserDataDirectory :: String -> IO FilePath
06:46:57 * medfly sighs
06:47:11 <Egbert9e9> is haskell.org for anyone else too?
06:47:33 <Egbert9e9> medfly: what're you trying to do
06:47:34 <ben> return for IO is a -> IO a, so return "foo" is an IO String. Does that help?
06:47:34 <thoughtpolice> http://www.downforeveryoneorjustme.com/haskell.org
06:47:39 <thoughtpolice> it's just you
06:47:51 <Egbert9e9> slow
06:48:02 <Egbert9e9> is haskell.org slow for anyone else too?
06:48:16 <adimit> dankna: this is *funky* http://imgur.com/imX2Q (retainer profile with convert == id)
06:48:19 <djahandarie> Egbert9e9, fine for me.
06:48:30 <Egbert9e9> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/GHC-IO-Handle.html#t%3AHandle just hangs there. i guess it's my end
06:48:41 <medfly> holy shit!
06:48:42 <thoughtpolice> Egbert9e9: yeah, haskell.org loads for me no prob
06:48:46 <medfly> it works!
06:48:51 <medfly> I am so happy.
06:48:52 <Egbert9e9> super annoying
06:49:02 <Egbert9e9> medfly: wooo!
06:49:08 <djahandarie> Egbert9e9, I've had similar problems with hackage.haskell.org
06:49:15 <djahandarie> But that's a different server.
06:49:21 <medfly> I feel a little bit like when I saw my sister write hello world for the first time.
06:49:33 <Egbert9e9> medfly: :-D
06:50:09 <mm_> can somebody explain to me why this (http://codepad.org/OUZHgzlq) doesn't work?
06:50:45 <djahandarie> @hoogle digitToInt
06:50:45 <lambdabot> Data.Char digitToInt :: Char -> Int
06:50:52 <Axman6> mm_: becauwe digitToInt returns Ints, not Num a => a
06:50:54 <djahandarie> mm_, that function constraints it to an Int.
06:51:02 <Axman6> your type should be Int -> Int
06:51:09 <mm_> ah okay, is there an alternative built-in?
06:51:14 <Axman6> no
06:51:19 <Jafet> :t fromIntegral . digitToInt
06:51:20 <lambdabot> forall b. (Num b) => Char -> b
06:51:27 <Axman6> though you can use ... what Jafet  said :P
06:51:34 <Axman6> beat me to it
06:51:47 <mm_> hm but i need to do a divison later, that wouldn't work, would it?
06:51:56 <Axman6> use div
06:52:09 <Jafet> Num does not have a concept of division
06:52:10 <Axman6> > (2^64) `div` 7
06:52:11 <lambdabot>   2635249153387078802
06:52:25 <Jafet> :t (div, (/))
06:52:26 <lambdabot> forall a a1. (Integral a, Fractional a1) => (a -> a -> a, a1 -> a1 -> a1)
06:52:33 <Jafet> Pick one.
06:52:40 <mm_> okay thanks :)
06:59:52 <Cale> Egbert9e9: depending on what you're doing, readProcess might be simpler to use
07:01:17 <Egbert9e9> Cale: reading youtube-dl's output
07:01:53 <Jafet> Seems easier to just write youtube-dl
07:01:57 <Cale> ghci> readProcess "date" [] ""
07:01:58 <Cale> "Tue May 31 10:19:05 EDT 2011\n"
07:02:21 <Cale> The list after the command name is the commandline parameters
07:02:36 <Cale> and then the string parameter at the end is the input to the program (all at once)
07:03:08 <Egbert9e9> Jafet: the point of using youtube-dl is minimizing the mout of stuff i need to learn before i can write a whole GUI app
07:03:32 <Cale> createProcess is really general and flexible, and there are a bunch of specialised versions of it in the System.Process module
07:04:44 <Cale> There's also readProcessWithExitCode, which gives you a triple of the exit code, the stdout of the program, and the stderr
07:04:55 <Cale> (the last two as strings)
07:05:42 <Jafet> Isn't youtube-dl command line?
07:06:26 <Egbert9e9> Jafet: it is. that's why i'm learning how to use System.Process instead of other http modules
07:06:29 <Egbert9e9> -_-
07:07:46 <Egbert9e9> there are some hairy things happening in youtube-dl
07:26:00 <gal_bolle> how old is -XOverloadedStrings?
07:27:19 <pumpkin> at least a couple of years
07:28:20 <gal_bolle> thanks
07:31:53 <thoughtpolice> gal_bolle: ghc 6.8, iirc. so like 3 years or so
07:32:14 <thoughtpolice> (more than enough time to where you should be able to comfortable use them anywhere)
07:32:27 * thoughtpolice hopes people aren't still using ghc 6.6, at least...
07:34:56 <gal_bolle> why does ghc silently ignore misplaced pragmas?
07:39:13 <Jafet> Implementations are supposed to ignore pragmas they don't recognize
07:40:04 <Jafet> Oh here's a gem from the GHC manual: "Pragmas don't normally affect the meaning of the program [...]"
07:42:04 <ccasin> Jafet: that's a good one!  Though it might be true in a certain sense: pragmas affect whether a program has a meaning or not, but are unlikely to change the meaning of a program if the compiler already understands it, perhaps
07:42:37 <ccasin> are there examples of programs that ghc will compile with or without a pragma but which are observationally different in each case?
07:42:41 <ccasin> I wonder
07:42:43 <Jafet> With overloaded strings and defaulting, perhaps
07:43:04 <shachaf> Jafet: Pragmas includes things like INLINE.
07:43:21 <Jafet> Well, we normally don't think of those things when we mention pragmas
07:43:37 <shachaf> Really? They're listed right on that page.
07:43:46 <shachaf> LANGUAGE is the special case, if anything.
07:43:47 <ccasin> I think in both of these cases the program might have different efficiency properties but still theoretically have the same output?
07:43:48 <Jafet> Or at least, that's what the GHC manual reassures us
07:47:11 <gal_bolle> it my case, it's not a pragma that isn't recognized, it's a header pragma (LANGUAGE) that ended up at the wrong place
07:48:10 <Jafet> Well, I thought it assured that. It asserts the opposite
07:48:10 <Jafet> ccasin: an easy one is NoImplicitPrelude
07:48:19 <gal_bolle> at least, i'd like to get a warning
07:48:48 <Jafet> Doesn't -Wall list strange-looking pragmas?
07:50:57 <byorgey> preflex: seen chrisdone
07:50:57 <preflex>  chrisdone was last seen on #haskell 19 hours, 34 minutes and 10 seconds ago, saying: @seen BONUS
07:51:16 <mauke> preflex: seen byorgey
07:51:17 <preflex>  byorgey was last seen on #haskell 20 seconds ago, saying: preflex: seen chrisdone
07:51:41 <Jafet> preflex, seen preflex
07:51:41 <preflex>  what
07:51:52 <shachaf> byorgey: seen mauke
07:52:56 <byorgey> sorry, I haven't seen mauke
07:53:14 <shachaf> @. elite quote byorgey
07:53:14 <lambdabot> by0rGEy $ay$: SOm37IMEs aSkING #HaSke|| ph0r he1p cAN BE LiKE +axiNg A DRiNk Fro/\/\ A phiRe |-|053
07:53:22 <ccasin> Jafet: I'm being slow, but how can I do it with NoImplicitPrelude - won't the file just not compile if prelude functions are used (and if they aren't, there would be no difference)
07:53:55 <Jafet> NoImplicitPrelude causes GHC to use whatever is in scope for syntactic constructs
07:54:19 <Jafet> So you can import qualified Prelude; import Foo (>>=); main = do blah;
07:54:54 <zygoloid> import Foo ((>>=)) ;-)
07:55:01 <Jafet> And the do block would be desugared with (Foo.>>=)
07:55:37 <ccasin> Jafet - ah, nifty.
07:56:08 <shachaf> I don't think anyone has thought about the meaning of "pragma" one way or the other that much.
07:56:25 <shachaf> They're just where you stuff anything you want to tell the compiler. Kind of like IO.
07:57:33 <Jafet> I should make zygoloid my GHC, then I'd get more smilies
07:58:06 <shachaf> @girl19
07:58:06 <lambdabot> am I supposed to be frantic with terror and anxiety?
08:04:36 <DukeDave> Wow, so I wish someone had linked me to [1] at some point in the last five years or writing Haskell!
08:04:38 <DukeDave> [1] http://en.wikibooks.org/wiki/Haskell/Indentation
08:05:32 <DukeDave> That ten minute read would probably have saved me hours of re-indenting!
08:11:26 <Saizan> how did you code haskell for 5 years without knowing that stuff?
08:12:09 <osfameron> adding and deleting spaces at random till it compiles!
08:12:29 <osfameron> you could probably do it non-deterministically in the List monad
08:13:41 * sully mostly just listens to emacs and guesses
08:13:46 <sully> and it works very well
08:14:53 <DukeDave> Saizan: Well I'd picked it up 'intuitively', but was always tripped up occasionally
08:15:05 <DukeDave> I.e, in this case: http://en.wikibooks.org/wiki/Haskell/Indentation
08:15:16 <DukeDave> Wait, this case: http://en.wikibooks.org/wiki/Haskell/Indentation#if_within_do
08:16:30 <scooty-puff> how are type class instances exported from a module?
08:16:39 <scooty-puff> are all instances exported?
08:16:40 <ski> always
08:16:42 <ski> yes
08:16:56 <scooty-puff> if i define them in another module, import them to this one, does this one export them?
08:17:03 <ski> yes
08:17:05 <scooty-puff> ok
08:17:35 <scooty-puff> (i wanted to use Put as a Monoid (instead of Builder), but if thats the case, not going to)
08:18:10 <esteth> in Data.Bits, there is the shift function, but it performs a 2's complement aware shift. Is there a function that performs a logical bitshift (always fills with 0s)?
08:18:19 <scooty-puff> rotate
08:18:23 <scooty-puff> :t rotate
08:18:24 <lambdabot> forall a. (Bits a) => a -> Int -> a
08:18:30 <scooty-puff> hm
08:18:32 <scooty-puff> nevermind
08:18:57 <esteth> yeah, rotate will shift in the bits from one side into the other
08:19:05 <scooty-puff> yeah, forgot that part..
08:19:47 <esteth> I could always do a logical shift and then bitmask, I suppose
08:20:08 <ski> > shift (-1 :: Word8) (-1)
08:20:09 <lambdabot>   127
08:20:09 <ski> > shift (-1 :: Int8) (-1)
08:20:09 <lambdabot>   -1
08:20:47 <esteth> aha. So if I cast to the appropriate Word type, I get a logical shift? :)
08:21:07 <ski> s/cast/`fromIntegral'/
08:21:36 <pumpkin> unsafeCoerce#
08:31:36 * hackagebot CMCompare 0.0.1.2 - Infernal covariance model comparison  http://hackage.haskell.org/package/CMCompare-0.0.1.2 (ChristianHoener)
08:36:49 <Egbert9e9> wow, Graphics.UI.Gtk.ModelView.TreeModel
08:36:59 <Egbert9e9> is an exteremely long page to read
08:46:03 <Egbert9e9> where should i write about the "set foo [ blah := 100 ]" notation in gtk2hs?
08:46:26 <Egbert9e9> :t (:=)
08:46:27 <lambdabot> Not in scope: data constructor `:='
08:46:41 <shachaf> Egbert9e9: In the documentation, if you're writing documentation?
08:46:51 * shapr reads https://github.com/jepst/CloudHaskell
08:47:41 <Egbert9e9> shachaf: do they need help documenting?
08:48:03 <shachaf> Egbert9e9: No idea. How should we know where you should write about it?
08:48:43 * shachaf did not understand the question.
08:52:36 <Egbert9e9> shachaf: oh, i know! thanks!
08:52:51 <shachaf> Egbert9e9: ?
08:52:53 * shachaf is confused now.
08:53:01 <Egbert9e9> i'll look up "set"
08:53:16 <Egbert9e9> was being stupid
08:53:49 <shachaf> Egbert9e9: := is a data constructor.
08:58:03 <ski> @hoogle (:=)
08:58:03 <lambdabot> Control.Parallel.Strategies (:=) :: a -> b -> Assoc a b
09:02:21 <ion> @hoogle unfoldTreeM_BF
09:02:21 <lambdabot> Data.Tree unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
09:03:06 <exeter> hello gentlement, I'm a bit puzzled by the scope of "let". Here is an example function http://hpaste.org/47306/let_scope . It seems that the scope of qqqq and palla ends at the end of the function. I kind of like that, but probably for tidiness reasons I would like (sometimes) to limit the scope to, let's say, just the next line. How to do so?
09:04:03 <ion> exeter: The (b -> m (a, [b])) type indicates, in this case, a function that takes a file or directory name and returns a tuple of the name and a list of its conents (if directory) in a monad. If the [b] is not empty, the function itself is then applied to each of the entires to generate branches for the parent tree entry.
09:04:55 <exeter> thanks ion
09:05:39 <ion> exeter: (let a = 42 in a) {- no a here after the closing paren -}
09:06:04 <exeter> so only parents to "limit" the code? no identation or stuff?
09:06:32 <jmcarthur> it's limited by the "let ... in ..." syntax
09:06:45 <jmcarthur> your code is using the do let syntax
09:06:49 <ion> Adding some parentheses, your function looks like myFunc stuff >= (\res -> (let palla = foobar res; qqqq = barfoo palla in return qqqq))
09:07:04 <exeter> thanks ion
09:09:14 <ion> exeter: You might find the -dump-parsed GHC parameter useful.
09:09:33 <ion> -ddump-parsed
09:10:10 <exeter> what does it do, ion?
09:10:42 <ion> Dumps the parse tree.
09:12:18 <exeter> (which I don't know what it is really. I'll bet google will enlighten me)
09:13:29 <ion> It prints a representation of how GHC parsed your code.
09:21:27 <tibbe> adimit, there?
09:21:32 <adimit> tibbe: aye.
09:21:40 <tibbe> adimit, I have previously written exactly the program you're trying to write
09:21:47 <tibbe> a ngram frequency counter
09:21:50 <adimit> tibbe: cool!
09:22:05 <tibbe> (although mine counted all ngrams, not just unigrams)
09:22:09 <adimit> tibbe: and you were succeful? I'd like to see that code if it's possible, thank you!
09:22:20 <adimit> tibbe: I'd like to generalise to ngrams sooner than later.
09:22:34 <tibbe> adimit, it's not in a releasable state yet (have to clear it with legal), but I can give you some tips
09:22:37 <tibbe> on sec
09:22:39 <tibbe> one*
09:22:48 <adimit> tibbe: ok, that sounds good too :-)
09:22:54 <adimit> thanks for taking the time.
09:23:28 <tibbe> first I'd write a function: foldLines :: (a -> Strict.ByteString -> a) -> a -> Handle -> IO a
09:23:48 <tibbe> and use that to process the file
09:23:54 <tibbe> make sure it's strict in the accumulator
09:23:59 <tibbe> let me try to give an example
09:24:18 <tibbe> (this is the reason I created unordered-containers)
09:24:37 <adimit> sounds interesting. You'd use hGetLine instead of iteratee then, eh?
09:25:41 <tibbe> yes
09:25:45 <tibbe> I'm writing it now from memory
09:25:46 <tibbe> sec
09:27:09 <adimit> tibbe: take your time. Thank you very much.
09:28:33 <mun_> does anyone know why there isn't a model theory for HOL? is it because it's undecidable?
09:28:47 <k0ral> I'd like to pattern match a String like this: "word " ++ rest_of_string
09:29:05 <k0ral> ++ operator in pattern matching seems to be forbidden
09:29:16 <k0ral> how should I do it ?
09:29:34 <kaito_> You could do
09:29:49 <kaito_> 'w':'o'...etcetc: rest
09:30:18 <k0ral> it's quite tedious
09:30:21 <kaito_> yup
09:30:26 <k0ral> isn't there any way to write it "word " ?
09:31:23 <tibbe> adimit, http://hpaste.org/47310/foldlines
09:31:45 <tibbe> adimit, what I'm trying to avoid here is having to understand if the iteratee library does the right thing
09:31:46 <Boxo_> > let f s | "word" `isPrefixOf` s = True; f _ = False in f "word up"
09:31:47 <lambdabot>   True
09:31:48 <c_wraith> nope.  This isn't erlang.  Haskell doesn't have that level of syntactic sugar
09:32:44 <kaito_> Hm, no easy way to match prefixes that I know of. You could run words on your argument and match the whole word maybe
09:33:22 <scooty-puff> c_wraith, if that was to me, in my case, the big thing i want it to print is how its desugaring "do rec" and "do" blocks - if not the general case, are those available?
09:34:01 <c_wraith> scooty-puff: no, it was to k0ral
09:34:35 <k0ral> isPrefixOf is even more tedious to use than a sequence of ":"
09:34:51 <scooty-puff> k
09:34:51 <tibbe> adimit, http://hpaste.org/47311/count_unigrams <-- counts unigrams
09:34:55 <shachaf> k0ral: Use a view pattern.
09:35:20 <c_wraith> as we discussed a while ago, isPrefixOf is the wrong type.  It should be [a] -> [a] -> Maybe [a]
09:35:24 <adimit> tibbe: thank you, i'm looking right now.
09:35:36 <arcatan> shachaf: how?
09:35:48 <shachaf> arcatan: Something like c_wraith suggested.
09:35:51 <k0ral> shachaf: looking at that
09:35:55 <ski> @type stripPrefix
09:35:56 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
09:36:05 <kaito_> isPrefixOf, sounds like it should be a predicate, and it is :P
09:36:12 <tibbe> adimit, ok
09:36:22 <shachaf> ski: Huh. Since when does that exist?
09:36:29 <c_wraith> @index stripPrefix
09:36:30 <lambdabot> bzzt
09:36:34 <adimit> tibbe: interestingly, your go function in foldLines is *basically* an iteratee.
09:36:36 <c_wraith> @hoogle stripPrefix
09:36:36 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
09:37:32 <tibbe> adimit, it is yes
09:37:37 <shachaf> > let { f (stripPrefix "abc" -> Just rest) = "And the rest is: " ++ rest; f blah = "No match: " ++ blah } in (f "abcdef", f "fedcba")
09:37:40 <lambdabot>   ("And the rest is: def","No match: fedcba")
09:37:47 <ski> shachaf : since i-have-no-idea-a-long-time-?
09:37:48 <tibbe> adimit, just without the bells and whistles. An iteratee is just a left fold
09:37:54 <shachaf> ski: I've never heard of it.
09:38:43 <adimit> tibbe: yes, true. Bells and whistles make for great opportunities to leak space. ^^ Thank you very much, I'll try to run this on my data now, and see about the results.
09:40:29 <k0ral> actually ":" constructor will do fine
09:41:48 <tibbe> adimit, I ran my program on a few gigs of input
09:42:06 <tibbe> adimit, I also did much more work per line (i.e. given a sentence, insert all possible ngrams into the map)
09:44:03 <tibbe> adimit, my advice for now is just to stay simple. The iteratee libraries might provide nice abstractions but I'm not if someone have taken a hard enough look at the performance and laziness properties
09:44:15 <tibbe> adimit, gotta go I'm afraid, Thai food is calling
09:44:23 <tibbe> adimit, let me know how it goes
09:45:12 <Egbert9e9> insane amount of tabs all display haskell libs pages -_-
09:48:16 <sm> Egbert9e9:  I know the feeling
09:48:57 <Egbert9e9> sm: it's all so hairy and i'm trying to put everything together in one shot and it doesn't work that way
09:49:14 <Egbert9e9> need to compartmentalize
09:49:31 <Egbert9e9> or else i mentalize
09:50:24 <sm> yeah sometimes the compiling one new line at a time strategy is good
09:55:17 <Egbert9e9> sm: you make a lot of sense! thanks!
09:56:31 <sm> Egbert9e9: I have an auto-recompile-on-file-change setup that's especially useful in that mode
09:56:47 <Egbert9e9> O_O
09:56:50 <Egbert9e9> emacs mode?
09:57:11 <Egbert9e9> too scared of emacs
09:57:16 <sm> no, I mean it's especially useful when making small incremental code changes
09:57:42 <sm> you see the compiler error immediately without leaving your editor
09:58:24 <sm> if interested you might want to try the shaker package first, it's a newer way to do that
09:58:57 <Egbert9e9> $ apt-cache search shaker
09:58:57 <Egbert9e9> burgerspace - Avoid evil foodstuffs and make burgers
09:59:10 <Egbert9e9> :-D
09:59:19 <Egbert9e9> cabal has it
10:10:07 <adimit> the difference between openFile and openBinaryFile only exists on Windows, no?
10:10:38 <dafis> adimit: if memory serves, yes
10:10:46 <shachaf> adimit: Maybe one of them reads bytes and one of them reads Unicode?
10:11:37 <dafis> shachaf: iirc, the only difference is line-ending conversion
10:11:46 <adimit> shachaf: well, the haddock only talks about windows and CRLF. Also: "Binary mode turns off all special treatment of end-of-line and end-of-file characters"
10:12:03 <adimit> I was just curious wether there were any other effects, that might influence, say, performance.
10:12:45 <dafis> adimit: well, checking for \r\n is slower than not checking anything at all
10:13:05 <adimit> probably.
10:20:29 <lysgaard_> Can: let a = fromIntegral bigint1; b = fromIntegral bigint2 in a/b owerflow or something? How do i divide Integer values?
10:20:57 <shachaf> @ty div
10:20:58 <lambdabot> forall a. (Integral a) => a -> a -> a
10:21:32 <shachaf> @google how do i divide integers in haskell :-)
10:21:33 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2004-March/005916.html
10:21:33 <lambdabot> Title: [Haskell-cafe] Dividing integers?
10:21:39 <Egbert9e9> wooohooo!
10:22:10 <parcs> has anyone here tried scion?
10:22:48 <sm> Egbert9e9: tried it ?
10:24:45 <lysgaard_> shachaf: Well i need the ratio. You see i have (bignum/refBignum). I want to see the fraction.
10:24:47 <Egbert9e9> sm: not yet, was trying to make it compile
10:25:01 <Egbert9e9> my think, not shaker
10:25:21 <Egbert9e9> shaker has some prerequisits
10:25:30 <shachaf> lysgaard_: I have no idea what you want, but maybe it's (%).
10:25:40 <shachaf> Or just specifying the appropriate type, e.g. Rational.
10:26:11 <rhapsodyv> Hi, i need some hint about IFs inside IFs . I have a decision making function that do a lot of IFs, and I'm wondering if there is a more clear way to write this IFs:   w = if a then b else if c then d else if l then e else f
10:26:33 <shachaf> What's an IF?
10:26:37 <lysgaard_> shachaf: Seems like I want a Ratio, thanks =)
10:26:39 <shachaf> Oh, if.
10:26:58 <mauke> case () of { _ | a -> b | c -> d | l -> e | otherwise -> f }
10:26:58 <saati> rhapsodyv: write it with guards?
10:26:59 <shachaf> rhapsodyv: Use case. Possibly case () of _ | a -> b, c -> d, ...
10:27:44 <rhapsodyv> hum
10:28:07 <rhapsodyv> but they are dependent
10:28:33 <rhapsodyv> here there is a example with Maybe monad : http://book.realworldhaskell.org/read/monads.html
10:28:54 <shachaf> rhapsodyv: An example of what?
10:28:59 <rhapsodyv> instead of "Maybe chaining"
10:29:01 <rhapsodyv> ops
10:29:03 <shachaf> rhapsodyv: case will use the first guard that matches.
10:29:06 <rhapsodyv> "Maybe chaining"
10:29:15 <rhapsodyv> there is some "if chaining"?
10:29:40 <shachaf> rhapsodyv: Yes, there's what a few people just said, for one.
10:30:19 <shachaf> You might be able to abuse do-notation for it (with Cont or something?), but you don't want to.
10:31:18 <rhapsodyv> shachaf: right, I'll try case and read about Cont monad
10:31:48 <shachaf> rhapsodyv: No, don't read about Cont.
10:31:55 <shachaf> Well, do read about it, but not for that.
10:32:14 <rhapsodyv> hum
10:32:48 <rhapsodyv> he a meaningless example:
10:32:59 <rhapsodyv>     w = if state then (False, liquida simul) else w2
10:32:59 <rhapsodyv>     w2 = if (length directions) < threshold then (False, NoTrade) else w3
10:32:59 <rhapsodyv>     w3 = (True, if curDirection == Up then sell simul else buy simul)
10:33:31 <shachaf> rhapsodyv: Well?
10:34:12 <dafis> rhapsodyv: w | state = (False, liquida simul) | length directions < threshold = (Fase, NoTrade) | otherwise = (True, if ...)
10:34:16 <shachaf> w | state = (False, liquida simul) | length directions < threshold = (False,NoTrade) | otherwise = (True, ...)
10:34:25 <dafis> heh
10:34:28 <shachaf> You win this time, dafis.
10:34:29 <rhapsodyv> :)
10:34:39 * dafis rejoices
10:34:56 <mauke> (if curDirection == Up then sell else buy) simul
10:35:23 <rhapsodyv> ok, i will use case
10:35:33 <shachaf> rhapsodyv: No case needed. :-)
10:35:40 <dafis> just guards
10:36:20 <rhapsodyv> ahh, guards for W?
10:36:46 <mauke> GUARDS FOR THE GUARD GOD
10:38:51 <rhapsodyv> thanks, much better now
10:39:12 <shachaf> You could still read about Cont.
10:39:21 <shachaf> Which is, incidentally, the best Monad.
10:39:31 * dafis prefers []
10:39:52 <dafis> and ST
10:40:03 <hpc> real men write all their monadic code in IdentityT
10:41:58 <dafis> Sigh, why does validating always take so long?
10:44:26 <naive> learning haskell is fun!
10:49:59 * hackagebot hbro 0.3 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.3 (koral)
10:50:31 <parcs> \x or \ x?
10:50:40 <mauke> \x
10:51:04 <shachaf> @unpl id
10:51:04 <lambdabot> (\ a -> a)
10:51:25 <shachaf> That's an example of how not to do things.
10:51:37 <rtharper> ?
10:52:11 <hpc> @unpl is in general an example of how not to do things
10:52:11 <lambdabot>  Parse error at "in" (column 4)
10:52:13 <hpc> @unpl (.)
10:52:14 <lambdabot> (\ a b c -> a (b c))
10:52:30 <hpc> @unpl zipWith
10:52:31 <lambdabot> zipWith
10:52:34 <hpc> :(
10:52:47 <dafis> @unpl (,)
10:52:47 <lambdabot> (,)
10:52:48 <shachaf> Aw, don't be sad, hpc. Here you go:
10:52:51 <shachaf> @src zipWith
10:52:51 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
10:52:51 <lambdabot> zipWith _ _      _      = []
10:52:56 <hpc> :P
10:57:10 <ezyang> Is it just me, or do some space leaks result from people not being able to check if the leak is in the library they're using?
10:57:49 <hpc> can't they install profiling versions of libs?
10:58:01 <monochrom> they can. do they bother?
10:58:05 <ezyang> Well, you have to do that to do a profiling build.
10:58:17 <ezyang> But you need to -auto-all usually to get useful metrics.
10:58:49 <ezyang> monochrom: What do you mean?
10:59:02 <monochrom> I can download linux kernel sources and start fixing its power leaks, too. do I bother?
10:59:28 <ezyang> Many companies do.
11:00:20 <monochrom> and how many people bother to even demonstrate space leaks in haskell libs?
11:01:10 <monochrom> at least 1. I usually don't bother
11:01:10 <ezyang> Not many. But I think we're going to need to build this culture.
11:01:19 <monochrom> err, at most n-1.
11:01:20 <ezyang> And make it easy.
11:02:32 <dafis> ezyang: which particular leaky library triggered your question?
11:02:38 <ezyang> Primarily because not every library writer tests their library on big data.
11:03:47 <ezyang> Most of containers as it stands suffers from space usage opacity.
11:04:04 <dafis> ezyang: true
11:04:22 <ezyang> Not strictly 'leaking', but definitely non-obvious space usage.
11:04:25 <dafis> and lacks STRICTNESS
11:06:13 <Egbert9e9> this gtk under construction app hangs like a boss https://github.com/yuvallanger/wholesale/tree/master/haskell
11:06:21 <sm> ezyang: sounds good
11:06:46 <Egbert9e9> (that's a bad thing ;___;)
11:11:18 <Egbert9e9> any clue to why it hangs? i've set it like the tutorial said
11:14:12 <medfly> I know Haskellers hate hash tables (I think so, anyway). what is your proposed alternative to hash tables?
11:14:34 <dafis> hash cookies
11:14:40 <hpc> hash desk
11:14:41 <copumpkin> medfly: maps?
11:14:48 <hpc> or possibly a hash bench
11:14:50 <copumpkin> tree-based ones, that is
11:14:50 <hpc> :P
11:14:51 <k0ral> why would hash tables be bad ?
11:15:04 <copumpkin> k0ral: they aren't a very good fit for persistence
11:15:16 <medfly> what are maps and do they have O(1) lookup
11:15:25 * medfly makes note to not just google "maps"
11:15:26 <medfly> lol
11:15:26 <dafis> plus, no fast ones (so far)
11:15:40 <copumpkin> O(1) lookup is a bit shady
11:15:47 <copumpkin> but no, they aren't "O(1)" lookup
11:15:49 <hpc> O(1) lookup isn't even possible
11:15:58 <medfly> ???
11:15:59 <cheater_> what about O(2) lookup
11:16:03 <hpc> not for arbitrarily sized containers
11:16:04 <copumpkin> cheater_: that's it
11:16:04 <dafis> sure they are, with bounded memory ;)
11:16:12 <medfly> it's not arbitrarily sized.
11:16:17 <copumpkin> dafis: you can say the same thing about maps
11:16:18 <hpc> bounded memory makes EVERYTHING O(1) :P
11:16:30 <cheater_> hpc, there's no such thing as an unbounded container
11:16:32 <dafis> copumpkin: I said that about maps
11:16:32 <cheater_> sry
11:16:52 <copumpkin> cheater_: then hashtables don't have O(1) lookup
11:17:00 <copumpkin> or do
11:17:04 <medfly> I plan to send the eventual result to a higher authority once I'm done and I should get it done right :P
11:17:21 <medfly> I have a fixed size amount of stuff I want to store, it's just very big
11:17:23 <parcs> they have O(min(n, W))
11:17:35 <scooty-puff> IntMap?
11:17:58 <cheater_> every container is bound by max_{t\in(-oo, +oo} (size(C))
11:18:08 <cheater_> add a parenthesis there or something.
11:18:16 <Egbert9e9> okay, now the video codes list does show up, but gtk still hangs
11:18:43 <medfly> I think I'll try to use hash tables anyway
11:20:00 <monochrom> there are packages "hashmap" and "unordered-containers"
11:20:18 <medfly> unordered-containers? that sounds prpomising
11:20:26 <medfly> I wonder if they are not sorted as well ;-)
11:20:34 <monochrom> the real hash table is currently slow due to technical glitches, but nothing wrong otherwise
11:20:42 <medfly> uh-huh
11:21:23 <Egbert9e9> what gives? sometimes video list shows sometimes it doesn't?!
11:22:08 <companion_cube> when using a ReaderT, if i write  type Foo a = ReaderT Bar Quux a,  should Quux need a type parameter ?
11:22:58 <dafis> companion_cube: if it has kind * -> * -> *
11:23:01 <mauke> @unmtl ReaderT Bar Quux a
11:23:01 <lambdabot> Bar -> Quux a
11:24:05 <monochrom> Egbert9e9: have you read gtk's haddock on concurrency?
11:24:23 <companion_cube> but if it is * -> *, the expression i wrote should be ok ?
11:24:31 <dafis> companion_cube: yes
11:25:05 <Egbert9e9> monochrom: i've read nothing about concurrency in gtk
11:25:12 <Egbert9e9> monochrom: i'll google
11:25:23 <companion_cube> thanks
11:25:37 <dafis> Quux should be a Monad or at least a Functor, of course, or there are not many useful things you can do with it
11:25:42 <monochrom> http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-General-General.html
11:26:01 <companion_cube> Quux is another ReaderT over IO
11:26:02 <monochrom> "If you want to use Gtk2Hs and in a multi-threaded application ..." right under initGUI
11:27:04 <Saizan> companion_cube: is Quux a type synonym though?
11:27:35 <companion_cube> yes
11:27:52 <companion_cube> oh, that should be a newtype ?
11:28:01 <Saizan> if "type Quux a = ReaderT X IO a" then you can't write type Foo a = ReaderT Bar Quux a, because type synonym need to be fully applied, and Quux is defined with a formal parameter 'a'
11:28:14 <parcs> awesome, NamedFieldsPuns and RecordWildCards omit the 'x shadows existing binding' warning
11:28:21 <Saizan> companion_cube: you can define Quux as "type Quux = ReaderT X IO" instead
11:29:28 <companion_cube> that is a bit subtle! thanks very much
11:29:34 <sm> hrm. In this parsec parser I want to fail, but it seems I'm always inside a case expr which fails instead. Any tips for fixing that ?
11:29:40 <rudyl313> hey can anybody help me with the problem I'm having implementing a Functor for my Matrix type https://gist.github.com/1001039
11:30:28 <Saizan> rudyl313: you can't with that definition of Matrix
11:30:39 <rudyl313> Saizan: why not?
11:30:48 <Egbert9e9> monochrom: thanks a bunch!
11:30:59 <Saizan> rudyl313: only paremetrized types can be instances of functor
11:31:28 <Saizan> rudyl313: data Matrix a = Matrix [[a]] | Row [a] | Column [a] would work
11:31:37 <monochrom> in other words, not polymorphic enough
11:31:48 <rudyl313> oh I see
11:31:52 <rudyl313> thats weird
11:31:59 <rudyl313> is there a reason for that?
11:32:08 <monochrom> I would recommend data Matrix a = Matrix [[Scalar]] | Row [Scalar] | Column [Scalar]
11:32:33 <Saizan> he'd have to change the implementation of fmap
11:33:28 <rudyl313> I guess I could implement my own map function and not make my Matrix type a Functor.. I'd rather not make it a parameterized type
11:33:51 <Saizan> yeah, you're quite free to do that
11:34:12 <Egbert9e9> should really start learning about branches
11:37:18 <sm> or am I confused ? fail inside a case expr results in a irrefutable pattern failure - right ?
11:37:40 <ezyang> Irrefutable pattern failure is different.
11:37:53 <ezyang> since it only occurs when you do ~
11:38:03 <hpc> if a pattern doesn't get matched by a case, you get a pattern match failure
11:38:19 <frerich_> I'm sorry for the newbie questio: I'm using ghc and cabal on Mac OS X; cabal installs pacakges to $HOME/.cabal, but ghc (or ghc-pkg etc.) don't look there, so importing packages installed via cabal fails. What's the best way to fix this, can I add $HOME/.cabal to the ghc search path somehow?
11:38:40 <frerich_> I googled around quite a bit but I must be using the wrong search terms, I don't get any useful hits (except a stackoverflow question describing the same problem, but it has no answer).
11:38:46 <sm> well my pattern has some _'s in it, and if I call fail in the right hand side, instead of the usual parse failure I get an irrefutable pattern failure
11:39:00 <dafis> frerich_: cabal should register the packages with ghc, so ghc knows about them
11:39:37 <dafis> frerich_: perhaps you're trying to use user-installed packages for installing something globally?
11:40:31 <frerich_> dafis: Hm, I don't think so; I just did e.g. 'cabal install parsec' and then ran 'ghc-pkg list' (which, by default, shows user and global packages). The list of packages does not include parsec - but I see that it doesn't look into the directory where cabal put things.
11:40:44 <sm> woah. If I replace fail with error - instead of a runtime error, I get the desired parse failure
11:41:01 <frerich_> Maybe I installed cabal wrongly. Actually, I cannot remember how I installed it. :-}
11:41:04 <dafis> frerich_: that's odd
11:41:38 <frerich_> I got ghc via homebrew and cabal via... I have no idea where cabal is coming from :-}
11:42:10 <monochrom> > do { case Just () of Nothing -> [()] }
11:42:10 <lambdabot>   *Exception: <interactive>:3:5-35: Non-exhaustive patterns in case
11:42:35 <monochrom> oh, right, that is not do's doing
11:42:49 <monochrom> > do { Nothing <- Just (); [()] }
11:42:50 <lambdabot>   Couldn't match expected type `()'
11:42:50 <lambdabot>         against inferred type `Data.Maybe...
11:43:00 <monochrom> > do { Nothing <- [Just ()]; [()] }
11:43:01 <lambdabot>   []
11:43:37 <sm> it must be a runtime error I'm seeing. error always does that
11:44:08 * edwardk waves hello.
11:44:24 <sm> oh yeah, hunit is catching it and carying on
11:44:45 <monochrom> then it is not the parser lib catching it
11:44:59 <sm> monochrom: right, I was mistaken
11:46:09 <sm> the point is, if I put error, or undefined, say, on the right hand side, I can see it being evaluated - the pattern is matched. If I instead put fail there, I get irrefutable pattern failed. Why is that ?
11:46:49 <hpc> sm: can you give an example?
11:47:00 <sm> sure..
11:47:15 <monochrom> no, I really like to guess
11:47:28 <hpc> guessing is fun, too
11:48:30 <sm> http://hpaste.org/47314/strange_error_from_fail_inside
11:48:55 <monochrom> because of let
11:49:17 <sm> ohhhhhhhhhh
11:49:24 <sm> that's the pattern failing ?
11:49:47 <monochrom> [y,m,d] does not match whatever parsec's fail does
11:49:57 <dmwit> It says the failing pattern is [y,m,d], and that only appears one place.
11:50:05 <dmwit> How could the error make it more clear which pattern is failing?
11:50:21 <sm> that makes sense.. thanks!
11:50:28 <monochrom> the error message also says "Irrefutable pattern failed for pattern [y,m,d]"
11:50:33 <dmwit> monochrom: Or [y,m,d] doesn't match dateparts.
11:50:37 <monochrom> so I looked for [y,m,d]
11:51:00 <monochrom> this is why I don't understand complaints about error messages.
11:51:08 <sm> monochrom: easy with hindsight
11:51:12 <dmwit> Yeah, I don't understand this complaint either.
11:51:20 <dmwit> monochrom and I didn't have hindsight.
11:51:32 <ezyang> Oh, I guess I don't understand what irrefutable pattern matches mean.
11:51:41 <monochrom> I just empty myself and believe the error message
11:51:51 <hpc> ezyang: no, you probably do
11:52:14 <hpc> ezyang: it's just that let will be irrefutable when you have a bare pattern on the lhs
11:52:26 <hpc> let f (PAT) = foo
11:52:29 <dmwit> ezyang: Irrefutable patterns are basically case statements with only one branch.
11:52:30 <hpc> vs let PAT = foo
11:53:09 <hpc> > let (x,y) = undefined in x
11:53:10 <lambdabot>   *Exception: Prelude.undefined
11:53:16 <ezyang> What's the difference from that and ~,then?
11:53:16 <sm> I was fixed on the idea that the pattern match error must be to do with the case. Thanks for helping me get unstuck
11:53:20 <dafis> let-bound patterns have an implicit ~
11:53:21 <hpc> > let Nothing = Just x in x
11:53:22 <lambdabot>   x
11:53:25 <dmwit> ezyang: No difference.
11:53:25 <ezyang> Oh, I see.
11:53:27 <hpc> er
11:53:35 <ezyang> Didn't know about the implicit ~
11:53:46 <ezyang> but makes sense in retrospect.
11:53:53 <monochrom> > case Nothing of Just x -> x
11:53:54 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
11:53:57 <dmwit> Lambdas, too, I thin.
11:54:02 <monochrom> > let Just x = Nothing in x
11:54:02 <lambdabot>   *Exception: <interactive>:3:4-19: Irrefutable pattern failed for pattern Da...
11:54:06 <dmwit> > (\Nothing -> 3) (Just 4)
11:54:06 <lambdabot>   *Exception: <interactive>:3:1-13: Non-exhaustive patterns in lambda
11:54:14 <dmwit> Ah, nope.
11:54:19 <monochrom> > case Nothing of ~(Just x) -> x
11:54:19 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for patt...
11:54:42 <dafis> > case Nothing of Just _ -> True
11:54:43 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
11:55:16 <monochrom> @define ir ~(Just x) = x
11:55:16 <dafis> > let ![y,m,d] = [] in 3
11:55:17 <lambdabot>   *Exception: <interactive>:3:4-16: Non-exhaustive patterns in pattern binding
11:55:22 <monochrom> @let ir ~(Just x) = x
11:55:23 <lambdabot>  Defined.
11:55:27 <monochrom> > ir Nothing
11:55:30 <lambdabot>   *Exception: <local>:1:0-15: Irrefutable pattern failed for pattern (Data.Ma...
11:55:36 <monochrom> @undefine
11:57:07 <dmwit> See? Computer science *is* a science!
11:57:10 <dmwit> It's experimental!
11:57:27 <sm> monochrom: could you suggest how to rewrite this to preserve the failure message ?
12:00:40 <monochrom> I am a moron. the fail there uses the list monad
12:01:16 <adimit> Long shot, but does aybody here know how to convert from ISO Latin 1 to UTF-8?
12:01:34 <dafis> adimit: iconv or in Haskell?
12:01:52 <adimit> dafis: doesn't even matter‚Ä¶ I can just preprocess my input data.
12:02:10 <adimit> dafis: iconv looks good, thanks :-)
12:03:08 <frerich_> Anybody here using cabal & ghc on Mac OS X (and having installed ghc via homebrew)? I'm having trouble making cabal install things where ghc expects them.
12:04:07 <monochrom> I cannot suggest a rewrite
12:05:21 <dmwit> ?hackage encoding -- adimit, if you prefer Haskell
12:05:21 <lambdabot> http://hackage.haskell.org/package/encoding -- adimit, if you prefer Haskell
12:05:37 <adimit> dmwit: thank you :-)
12:05:39 <earthy> frerich_: I'm using the Haskell Platform, so... no clue
12:05:47 <earthy> (it Just Works)
12:05:57 <dmwit> 0.6.3 seems to have the documentation links available
12:06:06 <dmwit> I doubt the top-level interface has changed much since that version.
12:06:58 <frerich_> earthy: Hm... I now realize I misunderstood what the 'haskell platform' is. I thought it's compiler + a few packages, but now I realize it's a separate download. I'll try that. :-)
12:07:07 <sm> monochrom: good so it's not just me. ahh, that makes even more sense
12:07:15 <sm> it's the empty list
12:07:25 <dmwit> (Latin-1 is called ISO88591 in the encoding package, I think.)
12:08:24 <earthy> possibly
12:09:03 <dmwit> sm: I can suggest a rewrite, if you like.
12:09:05 <dmwit> One second.
12:09:10 <adimit> the encoding package seems neat enough‚Ä¶
12:09:30 <sm> dmwit: thanks.. I can see it now, but if you want..
12:09:48 <sm> in fact that would be good, because mine is clunky
12:10:45 <dmwit> http://hpaste.org/paste/47314/strange_error_from_fail_inside#p47315
12:13:13 <sm> dmwit: you just added line 13 ?
12:13:44 <sm> this looks to me like it will fail with the same error. Should I test it ?
12:13:58 <dmwit> sm: No.
12:14:09 <dmwit> sm: I changed the "let" to a monadic binding, and added "return"s to the non-failing cases.
12:14:19 <dmwit> sm: So it's using a different fail now.
12:14:29 <sm> oh interesting
12:14:47 <sm> of course. Quite a bit better than mine. Thanks!
12:25:39 <yokto> hello - is there a haskell library/framework/application in which the types guarantee that you can produce only valid xhtml syntax?
12:25:59 <monochrom> the "xhtml" lib. it is in the haskell platform
12:26:42 <yokto> ok
12:26:51 <yokto> i'll have a look at it
12:39:59 <yokto> ok but i don't think it guarantees you valid syntax for instance (prettyHtml (toHtml "hello world")) doesn's give you valid xhtml code
12:41:49 <monochrom> I don't know of one that goes further
12:42:17 <yokto> too bad
12:42:59 <yokto> it'd be really cool if you were granted valid xhtml code by the compiler - and it could probably be done
12:43:25 <Egbert9e9> so.. in gtk2hs, what's the best way to display a list i can choose an arbitrary sublist off it? what widget?
12:44:54 <monochrom> it is TreeView and it does list
12:46:20 <dmwit> Egbert9e9: http://developer.gnome.org/gtk/stable/ch02.html is good for answering these kinds of questions
12:46:47 <Egbert9e9> nice!
12:46:49 <Egbert9e9> thanks
12:48:43 <tgeeky> has anyone here gone through the [partial-isomorphisms] or [invertible-syntax] paper?
12:48:51 <tgeeky> && is willing to discuss with me
12:49:06 <Egbert9e9> okay, both pages of treeview are huge, in haddock and developer.gnome.org
12:49:38 <dmwit> Yes, it's a complicated widget.
12:50:01 <Egbert9e9> but it's essential ;____;
12:50:25 <tgeeky> that word has begun to be widely misused
12:50:39 <tgeeky> lots of comp.prog. books titled "Essential ____"
12:51:07 <tgeeky> people selling "essential oils", which are perhaps some of the most non-essential things on Earth :o
12:51:37 <tgeeky> though I just learned that they mean that one differently. :/
12:51:47 <dmwit> TreeView should really be updated to use attributes.
12:51:47 <Egbert9e9> but i really my crossbox list
12:51:50 <dmwit> Those things are awesome.
12:51:50 <Egbert9e9> really want
12:52:13 <tgeeky> dmwit: attributes?
12:52:59 <dmwit> http://hackage.haskell.org/packages/archive/glib/0.12.0/doc/html/System-Glib-Attributes.html
12:54:21 <tgeeky> dmwit: just a flat, kv-map attached to... what kind of objects in glib? anything?
12:54:27 <dmwit> Yes.
12:54:30 <Egbert9e9> tgeeky: oh, that's a nice tidbit of trivia about essential oils
12:54:30 <tgeeky> that is handy
12:54:32 <monochrom> Egbert9e9: my http://hpaste.org/47316/gtk_table_start may help
12:54:48 <dmwit> Google has lots of hits for "gtk treeview tutorial", as well.
12:54:50 <tgeeky> Egbert9e9: yeah, it hadn't occured to me
12:55:30 <tgeeky> dmwit: I'm not big on GTK at the moment, though I think leksah is implemented using it
12:55:33 <tgeeky> and it's nice-ish
12:56:04 <tgeeky> dmwit: the update operator is nice, though
12:56:07 <Egbert9e9> forget about nice, i want results to my aimless coding
12:56:09 <scooty-puff> btw if anyone could use it (its only partially impl'ed now, but could use excuse to finish)
12:56:20 <scooty-puff> wrote a java class file emitter
12:56:42 <scooty-puff> that has operand stack verified by type system, and performs good instruction selection
12:56:47 <scooty-puff> (in haskell)
12:56:58 <scooty-puff> https://github.com/sonyandy/jfuck
12:57:04 <tgeeky> types? in MY java? It's more likely than you think! [click here]
12:57:04 <scooty-puff> its for a brainf*ck impl
12:57:11 <scooty-puff> meh
12:57:18 <scooty-puff> its at least written in haskell...
12:57:20 <tgeeky> scooty-puff: i was wondering why that name
12:57:27 <tgeeky> scooty-puff: hehe, it's a reference to an internet ad
12:57:47 <dmwit> tgeeky: One of the definitions of essential according to wordnet is "being or relating to or containing the essence of a plant", so "essential oils" are indeed essential.
12:57:56 <scooty-puff> or perhaps THE internet ad
12:58:02 <scooty-puff> anyways
12:58:14 <tgeeky> dmwit: yeah, that's why I typed that after
12:58:24 <dmwit> oh
12:58:27 <dmwit> indeed =P
12:58:28 <tgeeky> rather, it's based on the word "essence", not essential
12:58:44 <tgeeky> but I give ;)
12:58:59 <tgeeky> http://knowyourmeme.com/memes/x-in-my-y
12:59:07 <tgeeky> lol nice to know there's a "knowyourmeme" site
12:59:17 <monochrom> the essence of chicken is essential to chicken, though probably not essential to you
12:59:54 <tgeeky> monochrom: but the essence of chicken is chicken-flavored bullion cubes, which I have in my pantry.
13:00:02 <tgeeky> lol
13:00:11 <cheater_> why would you keep chicken nuggets in your pants again?
13:00:22 <tgeeky> whoa. whoa. whoa.
13:00:50 <tgeeky> that would be convenient
13:01:01 <dmwit> TENGO LOS POLLOS EN MIS PANTALONES
13:01:14 <tgeeky> close enough
13:02:52 <tgeeky> hm. this guy who wrote [invertible-syntax] is onto something
13:06:17 <Egbert9e9> monochrom: maaan, that's heavy
13:09:18 <tgeeky> Egbert9e9: may I ask: why bf?
13:09:37 <tgeeky> I notice lots of people trying to do things with it, is it just the challenge factor?
13:09:49 <tgeeky> Or the desire to make sense of (apparent) nonsense?
13:09:49 <Egbert9e9> tgeeky: bf..?
13:09:54 <tgeeky> Egbert9e9: brainfuck
13:10:10 <Egbert9e9> tgeeky: never tried
13:10:20 <tgeeky> oh. wrong person. :|
13:10:27 <tgeeky> scooty-puff: why brainfuck? see ^^
13:15:32 <roconnor> ezyang: I'm working on a pure haskell bitcoin library
13:18:19 <ezyang> roconnor: Excellent!
13:18:48 <roconnor> and might I say, what a crappy protocol ^_^
13:19:02 <roconnor> randomly mixing endieness
13:19:30 <roconnor> a bizarrely obtuse signature system that I don't fully understand yet, etc.
13:19:40 <roconnor> still, it is at the same time exceedingly clever.
13:44:13 <danharaj> could someone explain monadfix to me?
13:44:47 <monochrom> my http://www.haskell.org/haskellwiki/MonadFix
13:44:58 <mauke> all I know is that it lets you reference <-'d values from later in the block
13:46:54 <tgeeky> looks pretty clever
13:47:15 <tgeeky> isn't mdo deprecated?
13:47:35 <ddarius> Yes, it is.
13:47:49 <danharaj> how is mfix defined for IO?
13:48:06 <pozic> tgeeky: yes, we got a broken system back for it.
13:49:26 <ddarius> danharaj: The same way it is defined in Scheme.
13:50:38 * hackagebot hfusion 0.0.5.1 - A library for fusing a subset of Haskell programs.  http://hackage.haskell.org/package/hfusion-0.0.5.1 (FacundoDominguez)
13:50:44 <danharaj> ddarius: umm
13:52:17 <tgeeky> pozic: hm? how broken?
13:52:21 <danharaj> :t mfix
13:52:21 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
13:52:36 <pozic> tgeeky: I liked the mdo feature.
13:52:47 <pozic> tgeeky: the replacement system requires more human thought.
13:52:59 <tgeeky> pozic: what's the "but..." associated with that?
13:53:03 <roconnor> danharaj: it's probably easiest to start to understand monad fix for something other than IO, since the IO implemenation is kinda a hack.
13:53:25 <roconnor> danharaj: for me, learning mfix was like learning recursion all over again.
13:53:31 <danharaj> roconnor: Fair enough.
13:53:54 <tgeeky> what is the 'fix' in this? fixpoint? fixing... something? fixed mdo?
13:54:04 <roconnor> @type mfix
13:54:04 <monochrom> fixed point
13:54:05 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
13:54:05 <pozic> tgeeky: I don't agree there is any advantage to the new system.
13:54:11 <luite> the least defined fixed point
13:54:20 <pozic> tgeeky: it is a matter of opinion, there is little scientific about it.
13:54:58 <tgeeky> so it's like a monad over a data structure of lambdas or something? lol
13:55:00 <tgeeky> it sounds abstract
13:55:16 <monochrom> see my http://www.haskell.org/haskellwiki/MonadFix
13:55:37 <pozic> You can basically tie recursive knots with it in a monad.
13:55:46 <monochrom> don't blind-guess meanings from names. not going to work
13:55:50 <roconnor> > mdo {x <- return y; y <- return 1; x} :: Maybe Int
13:55:51 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
13:55:51 <lambdabot>    arising f...
13:56:01 <pozic> Now, that just sounds like gibberish, if you haven't used it.
13:56:04 <roconnor> > mdo {x <- return y; y <- return 1; return x} :: Maybe Int
13:56:05 <lambdabot>   Just 1
13:56:05 <tgeeky> monochrom: I was reading MonadFix when I asked the question
13:56:14 <roconnor> not a compelling example ...
13:56:28 <ddarius> mfix is just fix in an effectful language.
13:56:31 <pozic> You will miss mdo when you are annoyed with the current system.
13:56:32 <monochrom> I have very concrete examples. nothing abstract there.
13:56:42 <tgeeky> pozic: can't miss what you never used :O
13:57:04 <tgeeky> monochrom: not the examples, the idea of a monadFix in the first place
13:57:18 <tgeeky> monochrom: nevertheless, your point is valid and correct; hence I retract the stupid statement and replace it with ""
13:57:21 <monochrom> I also have "An action may use a value to be returned by the same action, or even returned by another action several lines of code later."
13:57:34 <ddarius> > do rec { x <- return y; y <- return 1; return x } :: Maybe Int
13:57:35 <lambdabot>   <no location info>:
13:57:35 <lambdabot>      The last statement in a 'do' construct must be an ...
13:58:01 <monochrom> it lets you use forward references. that is all it is.
13:58:49 <danharaj> what about wfix for comonads
13:58:51 <monochrom> do-rec is less automatic than mdo, but mdo's automation sucks, so do-rec is not a clear loss
13:58:54 <pozic> That is very useful in complicated datastructures.
13:59:15 <pozic> (ST defined datastructures)
13:59:22 <scooty-puff> do rec does not seem to work well with rebindable syntax
14:00:16 <scooty-puff> i have an indexed (terminology?) monad that implements MonadFix (T i i)
14:00:53 <scooty-puff> but the left shrinking do-rec is allowed to perform shrinks as if >>= and >> were of the same types as before (without rebindable syntax)
14:01:02 <roconnor> danharaj: I think wfix exists
14:01:05 <scooty-puff> *allowed -> does
14:01:14 <roconnor> wfix :: w (w a -> b) -> b ?
14:01:25 <scooty-puff> meh - *is allowed to -> does
14:01:30 <danharaj> wfix :: Comonad w => w (w a -> a) -> a
14:01:42 <danharaj> (according to Control.Comonad)
14:02:06 <danharaj> edwardk 's Control.Comonad, that is
14:02:08 <roconnor> right
14:02:16 <roconnor> that is correct
14:02:28 <roconnor> @go loeb haskell
14:02:29 <lambdabot> Maybe you meant: google googleit do
14:02:32 <roconnor> @google loeb haskell
14:02:33 <lambdabot> http://blog.sigfpe.com/2006/12/tying-knots-generically.html
14:02:34 <lambdabot> Title: A Neighborhood of Infinity: Tying Knots Generically
14:02:51 <danharaj> So why is mfix in its own type class if wfix is defined for all comonads?
14:03:37 <monochrom> I guess there is no mfix for Cont
14:04:39 <roconnor> danharaj: I don't know the answer to that.
14:05:09 <scooty-puff> btw if something wants a use of mfix, i had a code generator's actions (being the instructions) all be of type m <Label>, using mfix, you can do forward jumps
14:06:15 <tsuraan> can I tell ghci which package to load a module from?  I have Control.Monad.Trans in both mtl and monads-tf, so I can't load it at all
14:06:36 <danharaj> alright, thanks guys.
14:07:03 <monochrom> yes, it goes like mdo { when blahblah (jump label5); stuff; label5 <- newlabel; ... }
14:07:29 <edwardk_> http://www.haskell.org/pipermail/haskell/2005-September/016502.html
14:09:34 <scooty-puff> are algorithmic complexities of Data.Graph available?
14:09:57 <scooty-puff> also, how does SCC compare to Graph (a type synonym)?
14:10:05 <scooty-puff> seems like different ways to do the same thing
14:10:11 <scooty-puff> though i am very unfamiliar with the topic
14:10:27 <monochrom> tsuraan: you can suppress some packages by "ghci -hide-package blah"
14:11:43 <tsuraan> cool, thanks
14:12:04 <acowley> I think you can set that interactively, too
14:13:26 <tsuraan> looks like :set can do command-line flags
14:13:28 <tsuraan> nifty
14:13:41 <acowley> It's handy when you've launched GHCi from within emacs, for example
14:16:19 <edwardk_> i tend to have so many redundant copies of packages that fight for module names that -hide-package would be hell. i just set up a .cabal file when i start working
14:16:51 <acowley> mtl was the only time I really had trouble with that, but mtl2 solved it
14:17:17 <acowley> I think I end up nuking my GHC+cabal installations often enough that I avoid trouble
14:17:33 <edwardk_> acowley: that'd do it. i often have 20 old versions of a package still installed
14:17:53 <edwardk_> i like to make cabal work a bit ;)
14:18:04 <Peaker> What's Comonad's "return" equivalent?
14:18:12 <edwardk_> extract
14:18:21 <edwardk_> extract :: w a -> a
14:18:21 <Peaker> I don't see it in: http://hackage.haskell.org/packages/archive/comonad/1.1.0/doc/html/Control-Comonad.html
14:18:36 <monochrom> extract :: w a -> a is the newbie's dream :)
14:18:43 <Peaker> oh, sorry
14:18:44 <edwardk_> scroll down. you're looking at Extend
14:18:58 <edwardk_> Extend is a superclass for just the semigroup-like structure
14:19:19 <Peaker> Which package is the community-approved one for comonads now?
14:19:27 <acowley> I'm starting to get frustrated that I don't particularly understand comonads on any useful level
14:19:32 <edwardk_> that one
14:19:51 <edwardk_> acowley: play with the comonad-transformers lib
14:19:52 <acowley> every time I think I've stumbled into one in my work, I end up not really getting anything out of the bargain
14:19:59 <edwardk_> lots of examples you can play with there
14:20:05 <edwardk_> and i went for clear analogues to the mtl
14:20:16 <roconnor> acowley: I have a nice paper on comonads, but ICFP was too narrow to contain it.
14:20:25 <edwardk_> roconnor: rejected?
14:20:54 <roconnor> yre
14:20:56 <roconnor> yes
14:21:00 <acowley> roconnor: can you share a link to a draft?
14:21:05 <edwardk_> doh. great paper
14:21:29 <acowley> edwardk_: thanks, I'll take a look at the transformers package
14:21:55 <roconnor> edwardk_: one reviewer thought it was a great paper
14:22:10 <acowley> a type I did a lot of work with a few months ago has a relevant flavor
14:22:15 <tgeeky> acowley: so my knowledge that they are "monads, but with arrows flipped" won't be helpful? :o
14:22:29 <acowley> tgeeky: Not really, no :)
14:22:29 <edwardk_> roconnor: and two couldn't read it? =)
14:22:30 <roconnor> acowley: http://arxiv.org/abs/1103.2841
14:22:37 <roconnor> edwardk_: yes
14:22:40 <edwardk_> doh
14:23:08 <edwardk_> it definitely changed the way i think about lenses.
14:23:09 <acowley> tgeeky: the nice thing about monads is that you can get a feel for the structure by thinking about monoids at the type level, and there are lots of useful functions for working with monads
14:23:17 <acowley> oh!
14:23:26 <acowley> roconnor: I've been carrying that paper around the globe with me for like a month now!
14:23:35 <edwardk_> roconnor: btw- someone packaged up a template haskell binding for my comonad-transformer lenses
14:23:45 <Peaker> what are the comonad laws?
14:24:11 <Peaker> Monoid e => (->) e           is a Comonad, right?
14:24:14 <edwardk_> peaker:  f =>= extract   = f. extract =>= f = f; and =>= is associative
14:24:17 <roconnor> extract =>= f  =  f  =  f =>= extract
14:24:22 <edwardk_> where =>= is cokleisli composition
14:24:29 <roconnor> well, what edwardk_ said
14:24:31 <tgeeky> have any of you read 'partial isomorphisms'?
14:25:18 <edwardk_> peaker: more directly extend extract = id; extract . extend f  = f; extend f . extend g = extend (f . extend g)
14:25:26 <dmwit> tgeeky: Why don't you just go ahead and ask your question.
14:25:37 <Peaker> so:  instance Comonad ((->) ()) with the obvious fmap,   duplicate f () = f,   extract = ($())
14:25:44 <Peaker> right?
14:25:52 <tgeeky> dmwit: I don't have one, I just wonder if what he's doing is related
14:26:03 <tgeeky> if you haven't read it, it's not worth reading to answer
14:26:09 <edwardk_> peaker: yeah. that is a special case of an instance provided in the Comonad package.
14:26:13 <roconnor> Peaker: () -> a is isomorphic to a which is isomorphic to Identity a
14:26:21 <roconnor> and Identity is a comonad.
14:26:27 <edwardk_> (using the Monoid for ())
14:26:44 <roconnor> with more or less the instance you gave
14:27:06 <tgeeky> this paper looks excellent though
14:27:21 <tgeeky> it has enough whitespace that you know it's good
14:27:22 <roconnor> tgeeky: I haven't read it
14:27:35 <tgeeky> roconnor: that's a common problem with authors
14:27:48 <dmwit> edwardk_: So, when are you going to make another release of monoids?
14:27:59 <roconnor> agreed
14:28:02 <dmwit> edwardk_: And could you be convinced to derive the instance of Monad for Max/MinPriority?
14:28:04 <tgeeky> roconnor: wait, you haven't read the invertible paper? :o
14:28:05 <dmwit> =P
14:28:09 <edwardk_> dmwit: ack!
14:29:07 <roconnor> tgeeky: the partial isomorphisms paper?
14:29:13 <edwardk_> dmwit: i have a version i was hacking on based on 0.1.36 or so. i need to release an updated 0.2.x branch that just relaxes dependencies. it has been complicated by the fact that i lost the 0.2.x repository when patchtag barfed on me
14:29:25 * roconnor can't find the paper
14:29:28 <dmwit> ah, bummer
14:29:41 <edwardk_> dmwit: i can just pull it from hackage and start over obviously
14:30:03 <tgeeky> roconnor: the introduced class is here: http://hackage.haskell.org/packages/archive/invertible-syntax/0.2/doc/html/src/Text-Syntax-Classes.html
14:30:09 <dmwit> I could upload a version that just relaxes dependencies for you if you wanted.
14:30:24 <tgeeky> roconnor: the paper is here http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf
14:30:30 <edwardk_> dmwit: i'd appreciate it. i'll pull from that one then when i set up my new repository
14:30:43 <edwardk_> 0.3 will likely have a radically different api
14:30:54 <edwardk_> since it'll build on top of semigroups
14:31:01 <dmwit> Ah, cool.
14:31:20 <dmwit> Alright, I'll set some time aside tonight for finding the most recent versions of things that monoids still builds with. =)
14:31:28 <tgeeky> roconnor: I'd be interested to hear what you have to think about it. You can probably start at ~ section 3.1
14:31:36 <edwardk_> hopefully it should be the latest of everything
14:32:02 <dmwit> Yeah, I don't see any real reason it should break.
14:32:04 <edwardk_> if there is anything you need to cap above below the current rev, let me know.
14:32:11 <dmwit> Will do.
14:32:39 <roconnor> tgeeky: If this Iso type is related to biplates or lenses, it is hard to see.
14:32:43 <Twey> @hoogle MonadPlus m => Maybe a -> m a
14:32:44 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
14:32:44 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
14:32:44 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
14:32:48 <edwardk_> dmwit: MinPriority and MaxPriority may wind up getting simplified away, since we now have Min and Max down in semigroups
14:32:56 <dmwit> Oh?
14:33:00 <Twey> ‚òπ
14:33:00 * dmwit checks
14:33:08 <edwardk_> semigroups provides a Min that doesn't require a missing element
14:33:30 <edwardk_> then you can use the lifting from Option on Min to get the the Priority versions
14:33:36 <dmwit> edwardk_: Min and Max aren't the same as MinPriority and MaxPriority.
14:33:40 <edwardk_> i know
14:33:40 <dmwit> oh ho
14:33:50 <Twey> :t maybe mzero return
14:33:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
14:33:52 <edwardk_> but Option takes you from a Semigroup to a Monoid
14:34:00 * adorablepuppy destroys consistency of returns, then promptly shoots self.
14:34:01 <dmwit> I see.
14:34:02 <edwardk_> (what Maybe _should_ do)
14:34:12 <tgeeky> roconnor: ok. one obtuse suggestion for your paper: include more pretty pictures toward the end - the unbalanced placement of pictures to the front makes it appear insurmountably daunting to the quick-scanning-reader
14:34:29 <edwardk_> and Option _is_ a Monad, etc.
14:35:06 <edwardk_> not quite the same, but hopefully should work
14:35:18 <dmwit> hm
14:35:23 <edwardk_> i'm planning on seeing if i can use that to kill the various Priority types in monoids
14:35:26 <dmwit> So it's Option (Max a), then?
14:35:26 <roconnor> tgeeky: everything past page 20 is appedices
14:35:29 <edwardk_> yeah
14:35:34 <tgeeky> roconnor: I know, I mean before the appendcies
14:36:02 <dmwit> edwardk_: But Option has the wrong Ord instance for one or the other of Min or Max.
14:36:21 <edwardk_> true that
14:36:31 <edwardk_> hence, 'hoping' ;)
14:36:34 <roconnor> tgeeky: one common request was to move the example from the end of the paper to the beginning of the paper
14:36:41 <roconnor> this might help balance things out
14:36:43 <tgeeky> roconnor: by that metric, pages 1-10 have a 1:2 prettypicture:page ratio, and 10-20 have a 0:10 :(
14:36:51 <Peaker> Awesome, one thrashing process, and computer is not usable...  takes minutes to move to console, more minutes to log in, another minute to kill thrasher.  Modern computing sucks
14:37:00 <tgeeky> roconnor: ok, like I said, I haven't read it yet (though I plan to, since I need to learn lenses too)
14:37:03 <dmwit> edwardk_: I don't think you've convinced me to switch. =P
14:37:03 <roconnor> :)
14:37:24 <roconnor> tgeeky: edwardk's talk on lenses is pretty nice, even if it is in scala
14:37:38 <edwardk_> dmwit: well, you can use Min and Max as a semigroup. you just can't use <= on the Option (Min Int) and use the Nothing as Infinity
14:37:49 <tgeeky> roconnor: yeah, I'll have to get there. I also need to read the paper on lens isomorphisms
14:37:51 <roconnor> edwardk_: I didn't know your first method of integrating lenses with the state monad. it was pretty cool.
14:37:53 <dmwit> But that's kind of the whole point of MinPriority, for me.
14:37:54 <edwardk_> you can however, use mappend  on Option (Min Int) and it'll do the right thing
14:38:12 <edwardk_> roconnor: the conversion to state or the focusing operation?
14:38:13 <roconnor> edwardk_: even thought I expect the second way is generally a better method.
14:38:29 <lpsmith> Peaker,  I recommend setting a soft ulimit
14:38:31 <roconnor> edwardk_: the first way is the one where "variables" are lenses
14:38:50 <roconnor> edwardk_: the second way is where lenses lift a state monad on S to a state monad on T.
14:38:50 <edwardk_> roconnor: i use both fairly regularly
14:38:57 <lpsmith> Peaker,  that doesn't exactly solve the thrashing problem,  but it does help a great deal
14:39:17 <roconnor> interesting.
14:39:28 <edwardk_> dmwit: what are you using the Ord instance on MaxPriority for directly?
14:39:39 <roconnor> the existance of coercions makes me want to use scala now.
14:39:52 <dmwit> I have a library for doing (possibly half-open) intervals that uses MinPriority as an upper bound and MaxPriority as a lower bound.
14:39:54 <Peaker> lpsmith: it's pretty sad that 40 years after multitasking has been in research, nobody's got good resource accounting -- to make sure resources are not taken away from core responsiveness things
14:39:55 <edwardk_> roconnor: hah, don't worry the price you pay to get them makes it hardly worth it ;)
14:39:56 <tgeeky> roconnor: i am, for better or for worse, a highly-visual thinker without appreciable picture (or "movie") memory recall but excellent verbal memory recall. Hence I think best when I read in pictures, which is not the typical route for programmers (or haskellers) but is quickly becomming more common.
14:40:03 <edwardk_> dmwit: ah
14:40:33 <lpsmith> like, my laptop has 4GB of ram,  and so I have "ulimit -S -v 2097152" in my .bashrc,  which means that ghc gets killed if it starts using more than 2 gb
14:40:38 <roconnor> tgeeky: if/when you read it, if you have suggestions for what diagrams would make the last half of the paper more clear, let me know :D
14:40:40 <dmwit> edwardk_: For tests like containment, you really need the right Ord instances.
14:40:59 <tgeeky> roconnor: ok. I'll put s/read it/understand it/ as to not waste your time, but ok
14:41:10 <Peaker> lpsmith: I have 2GB, maybe I'll try a 1GB limit
14:41:17 <lpsmith> which still sucks if I'm using a lot of ram.  Chrome and Firefox are hungry
14:41:21 <edwardk_> dmwit: i'll keep the scenario in mind. i'll probably axe them out of 0.3 initially, and see about moving them to another package
14:41:34 <dmwit> Yeah, they really don't fit in the monoids package.
14:41:55 <dmwit> I've actually seen them reimplemented in several packages. ^_^
14:42:02 <edwardk_> yeah
14:42:14 <edwardk_> hence why i'd like them to have _some_ place ;)
14:42:15 <dmwit> (But yours was the most well-done of them.)
14:42:23 <lpsmith> and the nice thing about setting a "soft" limit is that you can manually call ulimit to raise it again without having to open a new terminal
14:43:16 <lpsmith> Peaker,  I think good resource accounting and prioritization exists,  but for whatever reason isn't widely deployed
14:44:37 <edwardk_> dmwit: on reflection i may just remove the Min and Max monoids from there, since they are covered by the semigroups package, and keep the FooPriority types
14:45:14 <edwardk_> you make a rather compelling case for their existing Ord instances over the behavior of Option (Max _)
14:45:51 <dmwit> yay =)
14:46:09 <Peaker> lpsmith: Allocations are done all wrong -- so I don't think good accounting exists. The kernel allocates way too much on the behalf of the user, rather than having the user provide all allocations appropriately
14:46:31 <Peaker> lpsmith: Also, nobody tries to keep track of how "important" pages are to the functioning of your "important" processes at all
14:46:44 <Peaker> it's a very naive LRU scheme that evicts pages
14:46:58 <lpsmith> Well, I didn't say anything about a vanilla linux kernel :-P
14:47:18 <Peaker> The naivity is justified, according to the Linux's MM Tzar, due to performance considerations (non-naive algorithms are more expensive) but of course it destroys performance
14:47:39 <edwardk_> peaker: you can get there but it requires a painful juggling of mincore to track what is resident
14:48:05 * hackagebot hbro 0.4 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.4 (koral)
14:48:09 <edwardk_> i used to really want an api to get the kernel to tell me what is going to get pushed out, and to allow me to perform substitutions, etc.
14:48:34 <edwardk_> but i've been able to get by
14:49:08 <edwardk_> it is somewhat horrifying how much the MM and the garbage collector tend to fight though.
14:49:30 <Peaker> does GHC optimize away (()->a) into a?  Or is ()->a safe to use as an "unmemoizer"?
14:49:42 <lpsmith> peaker:  sometimes, and no
14:49:55 <jmcarthur> honestly i think allocation, garbage collection, and paging should all happen on the same side of the user/kernel divide
14:50:45 <edwardk_> peaker: it doesn't always optimize it away. after all you could pattern match on the argument. and then you could observe if it was () or an error. but it is free do lambda lifting to make CAFs out of the bowels of your lambda, etc.
14:51:17 <edwardk_> peaker: so basically you get the worst of all worlds. no guarantees either way
14:51:27 <jmcarthur> thanks a lot, _|_
14:51:47 <lpsmith> thanks a lot non-strictness :-P
14:51:58 <jmcarthur> what does non-strictness have to do with it?
14:52:00 <lpsmith> If haskell were strict,  you could always optimize ()->a to a
14:52:14 <jmcarthur> okay
14:52:32 <jmcarthur> but i hate _|_ more than i hate non-strictness
14:52:32 <lpsmith> (well,  minus the whole using (()->a) to change the order of evaluation things.  Sigh)
14:53:00 <Peaker> so, how do I prevent memoization?
14:53:03 <jmcarthur> okay, then i return to my original point
14:53:12 <lpsmith> well, nonstrictness is whenever f _|_ is not necessarily _|_
14:53:15 <jmcarthur> Peaker: IO?
14:53:54 <jmcarthur> Peaker: maybe aggressively inlining the expression that you don't want shared?
14:53:57 <monochrom> ghc doesn't memoize that much if you don't hardcode sharing yourself
14:54:03 <jmcarthur> and then disabling cse i guess
14:54:25 <dolio> If haskell were strict, and you optimized () -> a to a, then the definition 'f () = undefined' would cause your program to crash, even if f were never called.
14:54:37 <dafis> -fno-full-laziness might be a good idea too
14:54:40 <edwardk_> peaker: the () -> a case should be sufficient with a few compiler options.
14:54:46 <Peaker> jmcarthur: what do you mean? Take as an example:    average xs = sum xs / length xs         -- using ListT  with the (() ->) monad and adjusting that code a bit appropriately, I'd think it would avoid memoization of the list and run in O(1) for:  average (enumFromTo 1 n)
14:55:17 <Peaker> O(1) memory, that was
14:55:21 <monochrom> average xs = sum xs / length xs  is explicit harcoded sharing of xs
14:55:21 <lpsmith> Peaker,  good question.  I don't know of a robust way to prevent memoization myself.   I'd like to know.  For example Melissa O'Neill's sieve is half-broken on many newer versions of GHC because her anti-memoization efforts stopped working
14:55:41 <lpsmith> dolio: yeah,  I kind of caught myself there.
14:55:47 <jmcarthur> i hate calling this memoization. that's not what it is
14:55:52 <Peaker> monochrom: sure, but if xs is not [a] but  ListT (()->) a  then it is O(1) memory
14:56:22 <jmcarthur> Peaker: only with certain evaluation strategies
14:56:29 <monochrom> well then you share a function not a list
14:56:44 <Peaker> monochrom: sure, so there shouldn't be a memory explosion?
14:56:47 <jmcarthur> Peaker: some evaluation strategies would share reductions in the function
14:59:20 <Peaker> maybe GHC could provide an Unmemo comonad type
14:59:53 <Peaker> that is kind of like  (() ->)   but guaranteed to cost O(1) memory in addition to pointing to whatever is needed to compute the result
14:59:56 <lpsmith> well,  you should be using   average = uncurry (/) . fold' (\ (!a,!b) c -> (a + c, b)) (0,0)   anyway
14:59:58 <Peaker> (without memoizing the result)
15:00:11 <Peaker> lpsmith: that's un-modular.. if anything, conal's "beautiful folds"
15:00:48 <lpsmith> err
15:01:17 <lpsmith> average = uncurry (/) . foldl' (\(!a,!b) c -> (a + c, b + 1)) (0,0)
15:01:49 <ezyang> Someone should submit a GHC ticket.
15:01:58 <ezyang> We already have some magic combinators to this effect.
15:02:18 <copumpkin> lpsmith: is that sufficient?
15:02:28 <copumpkin> strictness-wise?
15:02:39 <dolio> Yes.
15:03:09 <edwardk_> peaker: we call that "Name" in scalaz
15:03:38 <edwardk_> peaker: (We have Name, Need, and Value) for the various call-by- conventions.
15:04:13 <copumpkin> lpsmith: it is wrong though :P
15:04:14 <fxr> uhm, hackage down again.
15:04:41 <lpsmith> copumpkin: well, I've written that definition a few times,  but no I didn't test this one :)
15:04:52 <copumpkin> well, you aren't ever increasing the length :P
15:05:04 <jmcarthur> b+1?
15:05:09 <lpsmith> yeah,  I fixed it
15:05:15 <lpsmith> in my second try :)
15:05:18 <jmcarthur> oh copumpkin is just looking at the wrong one
15:05:26 <copumpkin> oh
15:05:29 <copumpkin> I am
15:05:35 <copumpkin> nevermind then
15:06:20 <lpsmith> Peaker:  you might not like that definition,  but it is the way to compute the average of a list in a performance-robust and O(1) fashion
15:06:59 <Peaker> lpsmith: conal's "beautiful" folds allow that too, without writing unmodular code
15:07:15 <Peaker> lpsmith: http://conal.net/blog/posts/more-beautiful-fold-zipping/
15:08:48 <edwardk_> Hrmm. I should write an article to maximize conal's cognitive dissonance... something like 'beautiful operational semantics'.
15:09:04 <djahandarie> Hahaha
15:09:09 <c_wraith> that's just mean
15:09:19 <edwardk_> =)
15:09:21 <djahandarie> @quote edwardk Hrmm. I should write an article to maximize conal's cognitive dissonance... something like 'beautiful operational semantics'.
15:09:22 <lambdabot> No quotes match. There are some things that I just don't know.
15:09:25 <djahandarie> Gah
15:09:26 <djahandarie> @remeber edwardk Hrmm. I should write an article to maximize conal's cognitive dissonance... something like 'beautiful operational semantics'.
15:09:27 <lambdabot> Done.
15:09:34 <danharaj> @remeber
15:09:34 <lambdabot> Incorrect arguments to quote
15:09:36 <mauke> still misspelled but close enough
15:09:43 <djahandarie> :p
15:09:44 <jmcarthur> :t uncurry (/) . last . (`zip` [0..]) . scanl (+) 0
15:09:44 <lambdabot> forall a. (Fractional a, Enum a) => [a] -> a
15:09:52 <jmcarthur> ah yeah enum
15:10:20 <c_wraith> @hoogle CReal
15:10:21 <lambdabot> No results found
15:10:31 <lpsmith> Peaker: thanks for the link
15:10:32 <jmcarthur> :t uncurry (/) . last . (`zip` iterate (+1) 0) . scanl (+) 0
15:10:32 <lambdabot> forall a. (Fractional a) => [a] -> a
15:10:32 <monochrom> at any rate you should expect (\xs -> f xs / g xs) to be efficient
15:10:36 <monochrom> err
15:10:39 <monochrom> at any rate you shouldn't expect (\xs -> f xs / g xs) to be efficient
15:10:42 <lpsmith> I hadn't recalled that article.
15:11:22 <jmcarthur> @check \xs -> (uncurry (/) . last . (`zip` iterate (+1) 0) . scanl (+) 0) xs == (sum xs / length xs)
15:11:23 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
15:11:23 <lambdabot>    arising from a use o...
15:11:32 <jmcarthur> @check \xs -> (uncurry (/) . last . (`zip` iterate (+1) 0) . scanl (+) 0) xs == (sum xs / fromIntegral (length xs))
15:11:33 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
15:11:43 <jmcarthur> meh
15:11:56 <Peaker> monochrom: liftA2 (/) f g    can be efficient apparently
15:12:14 <Peaker> (abstracting away the argument into a more-general applicative)
15:12:24 <conal> Peaker: aka "f / g" with applicative-numbers
15:12:32 <Peaker> yeah
15:14:14 <monochrom> yes, you always have to rewrite your code
15:17:27 <Peaker> liftA2 (/) or (/) may actually be a good explanation for why points-free style is more amenable to generalization that can even lead to optimization
15:19:35 <Peaker> anyway, it could be nice to have Name like in scalaz, and then ListT Name as a nice unmemoized generator
15:25:05 <acowley> Does anyone have any suggestions other than threadscope for digging into effective parallelism found by the RTS?
15:41:45 <jmcarthur> acowley: all i can think of is "+RTS -s" or peek into the event log without threadscope
15:50:03 <acowley> jmcarthur: I'm using -s, and all my sparks are being converted but overall performance isn't changing the way I expect
15:50:10 <acowley> is the event log human readable? I've never actually tried
15:52:28 <c_wraith> acowley: you're better off using threadscope, probably
15:52:51 <acowley> c_wraith: but that requires GTK, right?
15:52:54 <c_wraith> yep
15:53:01 <c_wraith> Main reason I've never used it. :)
15:53:14 * monochrom hugs gtk
15:54:12 * dmwit hugs gtk
15:55:40 <acowley> note to self: not human readable
15:56:00 <djahandarie> It's a good thing there aren't any humans in #haskell
15:56:08 <acowley> I guess I could copy my event log onto a machine that has gtk
15:56:48 <acowley> anyone feel like porting Threadscope to Racket? :/
15:59:08 <Peaker> today I was disappointed to find out that one of Scheme's original authors later authored Java
15:59:43 <acowley> Who?
15:59:46 <blackdog> Peaker: "We were after the C++ programmers. We managed to drag a lot of them about halfway to Lisp." Guy Steele, co-author of the Java spec
15:59:53 <acowley> oh
16:00:02 <blackdog> nothing wrong with a certain amount of pragmatism
16:00:15 <acowley> he gets a pass
16:00:19 <blackdog> and i think it's fair to say that Java really socialised the idea of garbage collection
16:00:21 <Peaker> I'd say they dragged them about 1/100th of the way :-P
16:00:37 <blackdog> you don't have to justify it any more, it's just expected, and it's a big deal if something doesn't have it.
16:01:11 <geheimdienst> at least java convinced the masses of GC, and complete documentation, and a top-notch standard library
16:01:52 <geheimdienst> ... and that pointer twiddling does more harm than good
16:02:12 <geheimdienst> i wouldn't want to program in java, but that's at least something
16:02:56 <blackdog> it's like being happy about your political opponents moving to the centre. you still don't vote for them, but you're happy that the centre of gravity has shifted in your favour
16:03:59 <Veinor> yeah
16:04:05 <geheimdienst> good analogy
16:04:18 <acowley> I wonder how much Java's design has to do with the tendency to complicated, obfuscating architectural patterns and how much that results from who is using it where
16:04:27 <Veinor> on the other hand, it gives people less reason to vote for you...
16:04:32 <Veinor> :P
16:05:05 <geheimdienst> acowley: i think you can be complicated in any language. i don't think it has much to do with java
16:05:29 <acowley> geheimdienst: you don't think the use of anonymous inner classes as a stand-in for lambdas is due to language design?
16:06:42 <acowley> installing threadscope on an old VirtualBox image I had is not showing cabal in a good light due to gtk2hs being complicated and not automatically installing alex
16:06:56 <jmcarthur> Peaker: "Although Fortress is originally designed as an object-oriented framework in which to build an array-style scientific programming language, [...] as we've experimented with it and tried to get the parallelism going we found ourselves pushed more and more in the direction of using immutable data structures and a functional style of programming. [...] If I'd known seven years ago what I know
16:06:58 <jmcarthur> now, I would have started with Haskell and pushed it a tenth of the way toward Fortran instead of starting with Fortran and pushing it nine tenths of the way toward Haskell."
16:07:07 <jmcarthur> Guy Steele ^^
16:07:50 <blackdog> jmcarthur: heh. we had someone from the project come give a talk at fp-syd a while ago
16:07:57 <blackdog> that language looks terrifying.
16:07:59 <edwardk_> jmcarthur: now it is entirely irrelevant as the entire team bailed once they became Oracle ;)
16:08:05 <jmcarthur> :(
16:08:21 <geheimdienst> what kind of a question is that ... i think java does not have lambdas (at least not yet?). i think anonymous classes are a poor stand-in because they need many more keypresses and can only access final variables. that said, you can be complicated and incomprehensible in haskell, too
16:08:24 <jmcarthur> actually, wasn't the talk i pulled that quote from after the oracle buyout anyway?
16:08:25 <acowley> isn't Steele still there?
16:08:25 <geheimdienst> acowley: ^^
16:10:13 <acowley> geheimdienst: the point is that programmers are left to fill in holes. Java focused on its OO strengths, but left its users some complicated holes to fill. The tools it gives its users to fill those holes end up contributing to the problem.
16:11:51 <blackdog> geheimdienst: i think the other argument is that haskell doesn't force you to be complicated - there's usually a nice solution if you stop typing and think for a bit. the syntactic overhead is just too much in java for the nice solution to emerge sometimes
16:12:16 <blackdog> i keep coming back to this question a ruby mate of mine asked about visual prototyping in FP languages.
16:13:01 <blackdog> koninkje mentioned GoI as a visual tool, but it doesn't seem to be common practice, where UML is sorta ubiquitous in the OO world
16:13:35 <blackdog> so hopefully if you've structured it right, the haskell code actually _is_ the simple representation. you don't need a visual abstraction
16:14:10 <hpc> blackdog: yeah, i would guess that "it isn't commonly used" == "it isn't commonly needed"
16:14:32 <hpc> in this case, not in general
16:14:49 <blackdog> something about aligning your intuition with the code rather than with some representation of it
16:15:00 <acowley> blackdog: right, that's the usual story. And it may also be that things like tracing VM research is a reaction to Java's deep hierarchies. But the comparison between languages is always starved of evidence as the user communities are so different.
16:15:44 <blackdog> acowley: yeah, it's all pretty circumstantial
16:15:50 <ezyang> Nah, I think visual structure can still be useful, even in FP.
16:15:59 <ezyang> (Just look at the category theorists!)
16:16:54 * djahandarie waves around his pentagon and hexagon diagrams
16:19:14 <blackdog> ezyang: i think the stuff you've done is really interesting in a pedagogical sense
16:19:37 <blackdog> i don't know many people who habitually sketch stuff out for haskell
16:19:39 <ezyang> Also, Streambase does a graphical programming language forfinancial stuff.
16:33:15 * hackagebot kit 0.7.5 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.5 (NickPartridge)
16:34:18 <Teslah> I've got a question! I'm trying to do this:   results=[sum[a1,b1,c1,d1,e1,f1,g1,h1,i1,j1,k1,l1,m1,n1,o1] | a1<-a,b1<-b,c1<-c,d1<-d,e1<-e,f1<-f,g1<-g,h1<-h,i1<-i,j1<-j,k1<-k,l1<-l,m1<-m,n1<-n,o1<-o]
16:34:37 <Teslah> in which all those letters are small lists of numbers
16:34:37 <dmwit> :t sequence
16:34:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:35:22 <dmwit> :t map sum . sequence
16:35:23 <lambdabot> forall a. (Num a) => [[a]] -> [a]
16:35:24 <aavogt> mapM sum
16:35:36 <dmwit> Whoops, yeah, mapM is better.
16:35:36 <aavogt> hmm, that's not the same, is it
16:35:45 <dmwit> ?src mapM
16:35:45 <lambdabot> mapM f as = sequence (map f as)
16:35:45 <Teslah> thanks!
16:36:02 <Teslah> But why is my way so inefficient?
16:36:05 <dmwit> Oh, no, mapM isn't the same. phew
16:36:16 <dmwit> Teslah: Your way isn't inefficient. Just annoying to write. =P
16:36:17 <aavogt> > let l = [[1,2],[3,4]] in (mapM sum l, map sum . sequence $ l)
16:36:18 <lambdabot>   No instance for (GHC.Num.Num (m b))
16:36:18 <lambdabot>    arising from a use of `e_11234' at <...
16:36:33 <dmwit> :t mapM sum
16:36:33 <lambdabot> forall (m :: * -> *) b. (Num (m b), Monad m) => [[m b]] -> m [b]
16:36:39 <azaq23> @type mapM `asTypeOf` map sum . sequence
16:36:40 <lambdabot>     Precedence parsing error
16:36:40 <lambdabot>         cannot mix `asTypeOf' [infixl 9] and `.' [infixr 9] in the same infix expression
16:36:42 <dmwit> huh
16:36:47 <dmwit> :t mapM
16:36:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:36:54 <Teslah> dmwit: I left it running all day and it didn't give me an answer, though I suspected it should've taken a minute at most
16:37:07 <dmwit> Teslah: Are you sure it's doing what you think it's doing?
16:37:12 <dmwit> Teslah: What do you think it's doing?
16:37:16 <Teslah> yeah, it works on fewer lists
16:37:34 <Teslah> it works totally fine with fewer inputs
16:37:52 <monochrom> all na√Øve algorithms for project euler are known to be slow
16:37:55 <dmwit> Just so I feel better about it, can you describe what it's doing in English?
16:38:20 <Teslah> solving project euler problem # 18 as monochrom guessed
16:38:21 <dmwit> You're probably right, but then I just read a paper about a formula that holds for all n < 10^someenormousnumber
16:38:39 <azaq23> @type mapM sum `asTypeOf` (sequence . map sum)
16:38:40 <lambdabot> forall (m :: * -> *) a. (Num (m a), Monad m) => [[m a]] -> m [a]
16:38:46 <azaq23> @type mapM sum `asTypeOf` (map sum . sequence)
16:38:47 <lambdabot> forall b. (Num [b]) => [[[b]]] -> [[b]]
16:38:50 <dmwit> Okay, great.
16:38:57 <dmwit> Then, yeah, your algorithm just sucks.
16:39:12 <monochrom> there are not enough project euler problems to exceed 10^someenormousnumber. yet.
16:39:13 <dmwit> A bit of thought will get you where you want to go, though. =)
16:39:27 <aavogt> you're recalculating (a1 + b1) too many times
16:39:30 <dmwit> monochrom: I was just pointing out that "works for small inputs" is not a proof of correctness, that's all.
16:39:40 <monochrom> oops
16:40:09 <monochrom> exponential algorithms work pretty quickly for small inputs, yeah
16:42:26 <monochrom> years of watching #haskell trains me the heuristic that if brute-force code is shown it's for project euler
16:43:19 <monochrom> even enterprise webscale programmers don't write brute-force code that often
16:44:37 <dmwit> Teslah: Haha, their suggested brute-force solution was to check every path, for which there are 2^depth such. But your solution checks depth! paths. OUCH
16:44:46 <dmwit> Teslah: Your algorithm isn't just slow, it's also wrong. =P
16:45:11 <Teslah> oh
16:45:16 <Teslah> wow
16:45:18 <dmwit> Teslah: For example, check your output for the following input: [[0], [0, 0], [10, 0, 0], [0, 0, 0, 10]]
16:45:21 <monochrom> depth! is approximately depth^depth
16:46:11 <Teslah> You guys make me feel so math dumb. I can't believe I didn't realize that
16:46:32 <Teslah> thanks!
16:46:37 <Teslah> I'll give it another go
16:47:55 <solrize> stackoverflow appears down?
16:48:37 <Teslah> No, it's up for me
16:50:29 <monochrom> its stack has overflown :)
17:22:10 <sm> there's no successor to old-locale, I take it
17:23:48 <sm> despite the package description: "This package provides the old locale library. For new code, the new locale library is recommended."
17:23:59 <Igloo> Correct
17:24:33 <sm> thanks Igloo
17:27:13 <c_wraith> That's kind of bizarre
17:31:50 <dankna> @hoogle foldM
17:31:50 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
17:31:50 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
17:31:50 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
17:37:50 <acowley> Well that was a roundabout way to discover that tweaking the GC was the way to recover lost parallelism.
18:07:49 <liznewbtcminer> ok so i'm here, now what?
18:08:24 <quantumplation> ohai
18:08:27 <dmwit> liznewbtcminer: Hi!
18:08:30 <dmwit> ?where lyah
18:08:30 <lambdabot> http://www.learnyouahaskell.com/
18:08:53 <dmwit> liznewbtcminer: What do you want to do with your shiny new programming language? Got any ideas?
18:08:59 <dmwit> We can suggest some if you don't. =)
18:09:01 <liznewbtcminer> no clue.
18:09:03 <liznewbtcminer> lool
18:09:10 <liznewbtcminer> take over the universe? XD
18:09:58 <quantumplation> oh sweet, when did he finish the monad stuff?
18:10:01 * dmwit rubs his hands together
18:10:13 * liznewbtcminer perks at monad
18:10:52 <quantumplation> liznewbtcminer: Math background, i take it?
18:11:02 <quantumplation> logic, rather?
18:11:04 <quantumplation> abstract math?
18:11:08 <quantumplation> not really sure how to classify it >.<
18:11:12 <dmwit> liznewbtcminer: Well, a few popular first projects are to try a few of Project Euler problems, do a ray tracer, build a webapp with yesod, create a window manager with the xmonad library...
18:11:32 <liznewbtcminer> Monad... that wouldnt be like, the oversoul would it?
18:11:36 <liznewbtcminer> oh... guess not :D
18:11:39 <dmwit> For the more academic, building a lambda-calculus interpreter is nice. =P
18:11:46 <liznewbtcminer> ummmm no, not math at all >.>
18:11:50 <liznewbtcminer> actually i'm not fond of mathematics
18:11:58 <dmwit> Okay, ignore that suggestion, then. =)
18:11:59 <liznewbtcminer> numbers that can do backflips scare the bejebus out of me
18:12:34 <quantumplation> not sure where you'd have heard monad then lol
18:12:34 <Nisstyre> yes
18:12:48 <liznewbtcminer> Third Degree Correllian Wicca, quantum
18:12:53 * liznewbtcminer is a priestess.
18:12:56 <dmwit> Oh, there's also a popular "build yourself an IRC bot" tutorial.
18:14:11 <liznewbtcminer> oooooo.
18:14:26 <liznewbtcminer> how about a... build yourself a bot-quizzer
18:14:33 <liznewbtcminer> or trivia thingie
18:14:43 <liznewbtcminer> (yes yes i know, such technical terminology -.-)
18:15:32 <dmwit> Like a 20-questions game?
18:16:12 <dmwit> That could be interesting. =)
18:16:28 <liznewbtcminer> yea kinda
18:16:40 <liznewbtcminer> :D
18:16:45 <liznewbtcminer> except more like, 100 questions
18:16:49 <liznewbtcminer> for varying subjects
18:16:50 <dmwit> =D
18:16:56 <liznewbtcminer> that a person could choose from
18:17:17 <dmwit> That sounds like a great first project!
18:25:40 * hackagebot monoids 0.2.0.3 - Monoids, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/monoids-0.2.0.3 (DanielWagner)
18:25:54 <dmwit> edwardk_: Done. There were no problems. =)
18:26:06 <liznewbtcminer> merf?
18:26:28 <NemesisD> is there any way to do list comprehensions with a variable number of generators? what i'm trying to express would be way easier with a LC
18:27:03 <dmwit> NemesisD: Perhaps something like sequence?
18:27:05 <dmwit> :t sequence
18:27:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:27:35 <dmwit> sequence :: [[a]] -> [[a]] returns lists consisting of one element from each of the input lists.
18:27:55 <dmwit> > sequence [[1, 2, 3], [4], [5, 6]]
18:27:56 <lambdabot>   [[1,4,5],[1,4,6],[2,4,5],[2,4,6],[3,4,5],[3,4,6]]
18:29:14 <NemesisD> oh nice!
18:29:41 <aavogt> @undo [ f x y z | x <- xs, y <- ys, z <- zs ]
18:29:42 <lambdabot> concatMap (\ x -> concatMap (\ y -> concatMap (\ z -> [f x y z]) zs) ys) xs
18:29:51 <NemesisD> i constantly under-utilize monads with lists
18:30:04 <azaq23> @src sequence
18:30:05 <lambdabot> sequence []     = return []
18:30:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:30:05 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
18:34:23 <adorablepuppy> When traversing a tree by path name, should I omit the root tree from the path, include it, or optionally include it? Right now I have it optionally included, but I fear double behaviour might be a bit confusing.
18:35:12 <adorablepuppy> In other words, what would the expected behaviour be? *
18:35:12 <dankna> definitely don't optionally include it
18:35:47 <Eduard_Munteanu> Wouldn't you have f' = tail . f ?
18:35:59 <adorablepuppy> dankna: Well, should I not include it at all then? You have to give the root to the function in order for it to work.
18:36:03 <Eduard_Munteanu> I mean that's what optional would be :)
18:36:53 <aavogt> many functions return what you give them, like id for example
18:36:56 <Eduard_Munteanu> Oh, you do it the other way around, traverse a tree by path, not find the path to a node.
18:36:58 <dankna> adorablepuppy: then I'd include it
18:38:09 <Eduard_Munteanu> I guess if this was a zipper, you'd merely have the arces (the turns you take), not the nodes in the path.
18:38:12 <adorablepuppy> dankna: I'll give you an example. traversePropertyTree ["path","strings"] tree. If I include it, I must have a "path" node at the root. If I don't, it'll skip to checking the child nodes.
18:38:12 <jmcarthur> adorablepuppy: i would give the path by direction (left, left, right, left, right, right, etc.) rather than by name (root, ann, bob, carol)
18:38:23 <Eduard_Munteanu> So that'd automatically exclude the root from being represented at all.
18:38:41 <adorablepuppy> jmcarthur: It's an n-ary tree, using lists.
18:38:48 <jmcarthur> adorablepuppy: then by index
18:38:57 <Eduard_Munteanu> The advantage is you don't need an Eq constraint, otherwise you kind have one.
18:39:06 <Eduard_Munteanu> *kinda
18:39:29 <Eduard_Munteanu> And anyway, it might not make sense, how do you compare nodes?
18:39:49 <Eduard_Munteanu> (if it's a general n-ary tree)
18:40:13 <adorablepuppy> Eduard_Munteanu: It's a logical structure and the developer is meant to know how to get to their path.
18:40:30 <jmcarthur> adorablepuppy: e.g. (0, 4, 2, 3, 1, 6, 5, etc.)
18:41:42 <adorablepuppy> jmcarthur: I use mine like this, currently: traversePropertyTree ["gamestate","Character Sheet","Ability Scores"] tree
18:42:00 <Eduard_Munteanu> Ah, so there can't be multiple nodes on the same level with the same value.
18:42:07 <adorablepuppy> Right.
18:42:37 <jmcarthur> why is this a (i assume) heterogeneous tree type and not just a big record structure?
18:43:03 <Eduard_Munteanu> Um, heterogenous?
18:43:05 <adorablepuppy> jmarthur: One structure can't fit all games. This is part of a game engine.
18:43:10 <jmcarthur> Eduard_Munteanu: my bad
18:43:13 <jmcarthur> homogeneous
18:43:35 <adorablepuppy> They build and pass around a PropertyTree as gamestate.
18:43:37 <jmcarthur> adorablepuppy: maybe the tree type itself should just be polymorphic then
18:43:44 <jmcarthur> adorablepuppy: so that the programmer can make their own
18:43:47 <jmcarthur> tailored to the game
18:43:54 <jmcarthur> and type safe and efficient
18:44:35 <Eduard_Munteanu> Correction, not on the same level, but as descendents of the same parent.
18:44:37 <adorablepuppy> jmcarthur, this is generally typesafe and if I don't support a type they want in the engine, they can easily add it.
18:44:46 <jmcarthur> s/polymorphic/a type variable/
18:45:21 <Eduard_Munteanu> Looks to me like this is isomorphic to a chain of maps. Though I can't really suggest you using that pattern, I haven't :)
18:45:28 <jmcarthur> eh, i won't argue, but i'll just let it be said that to me this look inflexible and inefficient
18:45:33 <jmcarthur> *looks
18:46:07 <jmcarthur> adorablepuppy: anyway, to answer your question directly: why not just not name the root node at all?
18:46:26 <jmcarthur> adorablepuppy: the root note has a list of key/value pairs, so just make the first element in the path be the first key to look up
18:46:41 <jmcarthur> *root node
18:47:02 <Eduard_Munteanu> Yeah, you could have   lookup root path_without_root,  or   lookup path_including_root. Arguably the latter could be partial.
18:47:09 <Eduard_Munteanu> (in case you give [])
18:48:04 <jmcarthur> no if you give [] then it would just be root
18:48:19 <jmcarthur> assuming the root node is nameless
18:48:45 <jmcarthur> or maybe that is what you meant
18:48:54 <jmcarthur> but i'm just confused about why you would have both options at once
18:49:52 <adorablepuppy> The root can't be nameless because the root could be any node cut from the tree.
18:50:31 <jmcarthur> i mean the name wouldn't be intrinsic, not that it can't be named by another node
18:50:46 <jmcarthur> but if that is possible then this doesn't even sound like a tree
18:50:51 <jmcarthur> it sounds like a graph
18:51:26 <adorablepuppy> Well, [] currently does work, and I think it's more intuitive that way. I just wanted second opinions on whether or not to name the first node in the path.
18:51:26 <jmcarthur> also, if a name uniquely identifies something, then why do you need a path at all?
18:51:30 <jmcarthur> why not just give the name?
18:52:09 <adorablepuppy> jmarthur: Well, I'm not sure how to get to the node in question. So rather than search for it and waste cycles, shouldn't they specify where they want to go?
18:52:51 <jmcarthur> adorablepuppy: it sounds to me like you are placing the node names in the nodes themselves. i don't think that is nessecary. i think the nodes that point to it can hold the name
18:53:13 <jmcarthur> adorablepuppy: that would eliminate this question altogether, i think
18:54:12 <adorablepuppy> jmarthur: It's path that does uniquely identify something. Duplicate names can exist in child structures. . .
18:54:15 <jmcarthur> adorablepuppy: i'm guessing right now you have something to the effect of:   data Node = Node String (Either [Node] Value)   ?
18:54:52 <adorablepuppy> jmcarthur: I have a big definition for it.
18:55:04 <jmcarthur> sure, i'm just summarizing
18:55:18 <jmcarthur> is my assumption about the overall structure roughly correct?
18:55:25 <adorablepuppy> http://hpaste.org/47322/quick_paste
18:55:28 <jmcarthur> where the String is the node's name
18:55:28 <adorablepuppy> Roughly
18:55:39 <jmcarthur> aha
18:55:45 <jmcarthur> here's what i would change
18:56:02 <copumpkin> preflex: seen Berengal
18:56:02 <preflex>  Berengal was last seen on #haskell 26 days, 11 hours, 8 minutes and 40 seconds ago, saying: applicative: It depends on if you're looking at the graph or the algorithm to find it. If you constrain the start and end node to be initial/terminal, the algorithm produces such a graph, but it'll still work given any two arbitrary nodes
18:56:23 <jmcarthur> get rid of the String parameter on all of them, and then instead of "NodeList String [PropertyTree]", say "NodeList [(String, PropertyTree)]"
18:57:09 <adorablepuppy> jmcarthur: What's that going to allow me to do though?
18:57:27 <jmcarthur> adorablepuppy: it eliminates redundancy and ambiguity
18:57:47 <jmcarthur> adorablepuppy: you don't have all those redundant Strings hanging around, and it answers questions (like the one you just asked here) for you
18:58:01 <jmcarthur> it also removes some power which i doubt you need
18:58:13 <jmcarthur> (getting the name of a node variable)
18:58:54 <jmcarthur> adorablepuppy: also, if you turn that list into a map, you can eliminate the possibility of multiple nodes in the same list having the same name
18:59:13 <jmcarthur> and a map is faster, to boot
18:59:32 <jmcarthur> if you use a hash map of unordered-containers, string lookup will be even faster
18:59:36 <adorablepuppy> I've already eliminated that possibility with the insert function by filtering out the old node first.
18:59:39 <jmcarthur> *hash map from
19:00:00 <jmcarthur> yeah but you had to do that explicitly. this is just inherent to the data definition
19:00:12 <jmcarthur> fewer invariants for you to maintain
19:00:38 <Eduard_Munteanu> Map of maps like I said?
19:00:44 <jmcarthur> yes
19:00:56 <adorablepuppy> hmm. Well. It does look like I've got my work cut out for me. . . I've got to rework a whole module. . .
19:01:01 <jmcarthur> i would go with something like   Free (Map String) Value
19:01:35 <jmcarthur> interesting that it turns out to be a free monad like that
19:02:09 <jmcarthur> not sure if useful though
19:02:45 <adorablepuppy> All I wanted was a structure to store game state . heh. I'm fairly new to haskell and fp in general, so I did it the way I could think of.
19:03:06 <jmcarthur> adorablepuppy: btw, why have different constructors for different types? why not just have a polymorphic leaf?
19:03:47 <jmcarthur> data PropertyTree a = Branch (Map String (PropertyTree a)) | Leaf a
19:03:58 <jmcarthur> oh
19:04:17 <jmcarthur> you'd also have to have an ADT for values that way
19:04:23 <jmcarthur> since you want to allow some different types
19:04:33 <jmcarthur> still, that would at least allow the programmer to supply their own value type
19:04:44 <jmcarthur> including their own ADT if they want multiple kinds of data at the leaves
19:05:35 <adorablepuppy> I wanted to generally restrict the accessible types in the engine functions. And the most complex leaf I have is a (PropertyTree -> PropertyTree)
19:05:57 <Eduard_Munteanu> Yeah, including going full heterogenous if they pass something like    data Box = (forall a. SomeClass a) => Box a
19:06:09 <adorablepuppy> plus I really haven't finished any of the tutorials yet. I just did a bit then started coding.
19:06:36 <Eduard_Munteanu> That's not bad.
19:06:41 <jmcarthur> i think you are missing some of the power of polymorphism then ;)
19:08:31 <adorablepuppy> Really, I was embarrassed about my code earlier today, so I started to make it return Maybe PropertyTrees earlier, because before it either failed or returned [] if it failed.
19:08:59 <jmcarthur> embarrassment is the key to refactoring!
19:10:40 <hellertime> question. if I wanted to use 'maybe' with a monadic function, how would I do that?
19:10:42 <hellertime> :t maybe
19:10:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:11:34 <rudyl313> I feel like this is a dumb question, but how do I import Data.List.Split? I was able to import Data.List (for example), but I can't seem to import Data.List.Split
19:12:37 <hellertime> i think I want a function with the signature:(Monad m) => b -> (a -> m b) -> Maybe a -> m b
19:13:19 <dafis> rudyl313: have you installed the package split?
19:13:40 <rudyl313> dafis: I do that with cabal?
19:13:43 <jmcarthur> hellertime: instead of "maybe x f" try "maybe (return x) f"
19:13:44 <dafis> yes
19:13:50 <dmwit> :t \x -> maybe (return x)
19:13:50 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => a -> (a1 -> m a) -> Maybe a1 -> m a
19:14:02 <rudyl313> dafis: Thanks, I'm super new to Haskell :P
19:14:05 <dafis> cabal install split, and off you go
19:14:13 <dafis> rudyl313: no problem
19:15:15 <hellertime> dmwit: well that was easy! thnx
20:09:16 <grizzlybear5> hello
20:09:45 <grizzlybear5> could You please help me? I have got a problem with understanding how haskell implementation of sublist works
20:09:47 <grizzlybear5> http://pastebin.com/dRkXLAt1
20:09:50 <mauke> The paste dRkXLAt1 has been copied to http://hpaste.org/47325/httppastebincomdrkxlat1
20:10:03 <grizzlybear5> could You please help me to understand that step-by-step?
20:10:21 <mauke> where's the first problem?
20:10:49 <grizzlybear5> mauke, I don't get how that function works
20:10:59 <grizzlybear5> in which order
20:11:01 <mauke> which function?
20:11:14 <grizzlybear5> s, s', s'' (these ones which i pasted)
20:11:31 <mauke> that's three functions
20:11:33 <syntaxfree> @get-shapr
20:11:34 <Axman6> urgh, what horrible code
20:11:34 <lambdabot> shapr!!
20:11:50 <syntaxfree> no dice.
20:11:55 <mauke> anyway, I can't help you if you don't tell me what the problem is
20:12:23 <grizzlybear5> I got intuition how these code works, but i'm not sure how it's in real (step-by-step)
20:12:43 <Axman6> grizzlybear5: haskell code doesn't work "step-by-step"
20:12:51 <grizzlybear5> i mean, that it would be nice, if someone could show me how it works step-by-step for [1,2,3]
20:12:58 <mauke> Axman6: totally does
20:12:59 <Axman6> the same as mathematics doesn't work step-by-step
20:12:59 <grizzlybear5> Axman6, but there's recursion there
20:13:23 <mauke> grizzlybear5: do you understand how [1,2,3] is the same as 1 : 2 : 3 : []?
20:13:32 <grizzlybear5> sure
20:13:35 <Axman6> grizzlybear5: sure, but the order in which things happen isn't important to how the function works
20:13:42 <mauke> Axman6: yes, it is
20:14:20 <mauke> grizzlybear5: the first thing that happens in s (1 : 2 : 3 : []) is the pattern match in line 2
20:14:30 <mauke> [] doesn't match 1 : ... so it fails
20:14:53 <mauke> we try line 3: it matches, binding x to 1 and xs to 2 : 3 : []
20:15:14 <mauke> we go into ++
20:15:41 <mauke> whose source isn't visible here but (++) walks along its first argument looking for the end of the list
20:16:00 <mauke> that's s xs where xs = 2 : 3 : []
20:16:23 <mauke> again a call to s; again line 2 fails; we proceed to line 3
20:16:34 <mauke> this time x is bound to 2, xs to 3 : []
20:16:51 <mauke> next recursive call ... x is bound to 3, xs to []
20:17:08 <mauke> another recursive call, but this time xs is [] so the pattern in line 2 matches
20:17:11 <mauke> we return [[]]
20:17:46 <mauke> the right hand side of (++) is a call to map
20:18:08 <mauke> which in turn acts on the list returned by s [], which we know is [[]]
20:18:31 <mauke> for each element in [[]] (i.e. []) we prepend x (which is 3 here) to it
20:18:45 <mauke> that yields [3 : []] as the result of map
20:19:14 <mauke> [[]] ++ [3 : []] then is [[], [3]]
20:19:39 <mauke> and that's the result of s (3 : [])
20:19:55 <mauke> we return another level
20:20:21 <mauke> [[], [3]] ++ map (2 :) [[], [3]]
20:20:34 <mauke> [[], [3]] ++ [[2], [2, 3]]
20:20:40 <mauke> [[], [3], [2], [2, 3]]
20:20:49 <mauke> and that's the result of s (2 : 3 : [])
20:20:57 <mauke> another level up
20:21:14 <mauke> [[], [3], [2], [2, 3]] ++ map (1 :) [[], [3], [2], [2, 3]]
20:21:26 <mauke> [[], [3], [2], [2, 3]] ++ [[1], [1, 3], [1, 2], [1, 2, 3]]
20:21:42 <mauke> [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
20:21:52 <mauke> and that's the final result of s (1 : 2 : 3 : [])
20:22:03 <grizzlybear5> nice, I got it, thanks a lot :)
20:22:05 <mauke> I've skipped a bit here
20:22:33 <mauke> in reality the repeated calls to (s xs) are really computed twice; here I've simply reused the result
20:22:44 <mauke> also the evaluation order wasn't quite right
20:23:14 <grizzlybear5> ok, but the most important think to understand for me was moving back from recursion
20:23:33 <mauke> ok
20:23:41 <grizzlybear5> could You please explain to me s' and s'' too?
20:24:35 <mauke> ok, same general idea
20:24:47 <mauke> the difference is how the recursive results are combined
20:24:59 <mauke> do you know about list comprehensions in general?
20:25:08 <grizzlybear5> yup
20:25:39 <mauke> ok, so in line 8 the first thing that happens is again a recursive call to s' xs
20:26:02 <mauke> we loop over the resulting list, binding each element to zs
20:27:01 <mauke> then we create a temporary list [x:zs, zs] containing: 1) the current sublist zs with x prepended and 2) the current sublist zs itself
20:27:33 <mauke> then we loop over *that* with ret, which is also our return value
20:27:57 <grizzlybear5> err,  i don't see it, may You show it on the example
20:28:07 <grizzlybear5> as YOu did for s ? [1,2,3]?
20:28:25 <mauke> the underlying idea of line 3 is: if we can compute all sublists of the remaining elements xs, we can generate all sublists of (x : xs) from that
20:28:41 <mauke> all sublists of xs are sublists of (x : xs)
20:28:58 <mauke> but in addition to that we also need the sublists that contain x
20:29:16 <mauke> which we derive from the sublists of xs by adding x to each sublist
20:29:20 <mauke> not sure if that makes sense
20:29:48 <mauke> ah, whatever. we can just go to our concrete example
20:30:19 <mauke> s' (1 : 2 : 3 : []) -> pattern match against (x : xs) with x = 1, xs = 2 : 3 : []
20:30:33 <mauke> recursive call s' (2 : 3 : [])
20:30:53 <mauke> again pattern match: x = 2, xs = 3 : []; recursive call s' (3 : [])
20:31:07 <mauke> again pattern match: x = 3, xs = []; recursive call s' []
20:31:21 <mauke> finally we reach the base case. s' [] = [[]]
20:31:31 <mauke> we return
20:31:43 <mauke> now we run zs <- [[]]
20:31:57 <mauke> this loops over [[]], setting zs to each element
20:32:06 <mauke> in this case there is only one element, so zs = []
20:32:33 <mauke> we use zs in [x : zs, zs] where zs = []; x = 3
20:32:40 <mauke> => [[3], []]
20:32:52 <mauke> we loop over that, setting ret to each element
20:32:59 <mauke> so ret is first [3], then []
20:33:43 <mauke> our "collector" expression is just ret, so the results of our list comprehension are [3] and []
20:33:46 <mauke> i.e. [[3], []]
20:33:54 <mauke> and that's the result of s' (3 : [])
20:34:00 <mauke> we return
20:34:14 <mauke> now zs <- [[3], []]
20:34:23 <mauke> first zs = [3]
20:34:36 <mauke> ret <- [2 : [3], [3]]
20:34:46 <mauke> first ret = [2, 3]
20:34:56 <mauke> (collect that for our result list)
20:35:04 <mauke> then ret = [3] (and collect that too)
20:35:16 <mauke> then back in the outer loop: zs = []
20:35:29 <mauke> ret <- [2 : [], []]
20:35:44 <mauke> first ret = [2] (collect that), then ret = [] (and collect that too)
20:36:10 <mauke> our outer loop is done; we've collected [[2, 3], [3], [2], []] from our list comprehension
20:36:21 <mauke> and that's the result of s' (2 : 3 : [])
20:36:30 <mauke> we return to our toplevel call
20:36:43 <mauke> zs <- [[2, 3], [3], [2], []]
20:36:58 <mauke> first iteration, zs = [2, 3]
20:37:13 <mauke>   ret <- [1 : [2, 3], [2, 3]]
20:37:24 <mauke>   first iteration, ret = [1, 2, 3]. collect.
20:37:34 <mauke>   second iteration, ret = [2, 3]. collect.
20:37:44 <mauke> second iteration, zs = [3]
20:37:53 <mauke>   ret <- [1 : [3], [3]]
20:38:01 <mauke>   first iteration, ret = [1, 3]. collect.
20:38:08 <mauke>   second iteration, ret = [3]. collect.
20:38:18 <mauke> third iteration, zs = [2]
20:38:24 <mauke>   ret <- [1 : [2], [2]]
20:38:32 <mauke>   first iteration, ret = [1, 2]. collect.
20:38:39 <mauke>   second iteration, ret = [2]. collect.
20:38:48 <mauke> fourth iteration, zs = []
20:38:54 <mauke>   ret <- [1 : [], []]
20:39:01 <mauke>   first iteration, ret = [1]. collect.
20:39:07 <mauke>   second iteration, ret = []. collect.
20:39:13 <mauke> outer loop is done
20:39:35 <mauke> we've collected [[1, 2, 3], [2, 3], [1, 3], [3], [1, 2], [2], [1], []]
20:39:43 <mauke> and that's the result of s' (1 : 2 : 3 : [])
20:39:48 <grizzlybear5> :), ok
20:39:51 <grizzlybear5> got it too
20:39:58 <grizzlybear5> s'' looks the same, right?
20:40:01 <mauke> yes
20:40:12 <mauke> the structures of s' and s'' are identical
20:40:26 <grizzlybear5> but please tell me (if it's true) if I can write it as s'' (x:xs) = (s'' xs) >>= \zs -> [x:zs, zs]	
20:40:29 <skateboarding_sy> @paste
20:40:29 <lambdabot> Haskell pastebin: http://hpaste.org/
20:40:53 <grizzlybear5> @src do
20:40:53 <lambdabot> Source not found. There are some things that I just don't know.
20:41:05 <grizzlybear5> @src (>>=)
20:41:05 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:41:12 <mauke> @undo do { zs <- s'' xs; rs <- [x:zs, zs]; return rs }
20:41:13 <lambdabot> s'' xs >>= \ zs -> [x : zs, zs] >>= \ rs -> return rs
20:41:30 <mauke> @src [] (>>=)
20:41:30 <lambdabot> xs >>= f     = concatMap f xs
20:42:00 <mauke> @src [] return
20:42:00 <lambdabot> return x    = [x]
20:42:28 <grizzlybear5> is that any definition of "do" ?
20:42:40 <mauke> what do you mean?
20:42:56 <grizzlybear5> how @undo works
20:43:06 <mauke> ?
20:43:35 <grizzlybear5> what's the connection between (>>=) and do
20:43:49 <grizzlybear5> how can i rewrite codes from do to >>=
20:43:52 <grizzlybear5> and vice versa
20:43:53 <c_wraith> >>= is used to implement the <- syntax in do blocks
20:44:01 <aavogt> see @do and @undo
20:44:30 <grizzlybear5> ok
20:44:33 <mauke> grizzlybear5: can you see this arrow: ‚áí ?
20:44:47 <grizzlybear5> nope
20:44:50 <mauke> :-(
20:44:55 <grizzlybear5> do you mean ->  ?
20:45:09 <mauke> I wanted fancy unicode symbols
20:45:27 <mauke> do { X } =is= X
20:45:34 <grizzlybear5> what's the code of that char?
20:45:41 <mauke> do { let v = X; ... } =is= let v = X in do { ... }
20:45:53 <mauke> do { v <- X; ... } =is= X >>= \v -> do { ... }
20:46:03 <mauke> do { X; ... } =is= X >> do { ... }
20:46:09 <mauke> and that's how 'do' works
20:46:09 <liznewbtcminer> holy CRAP i've just become motivated
20:46:13 <liznewbtcminer> coding for bitcoins!
20:46:16 <liznewbtcminer> XD
20:46:42 <mauke> in your example, rewriting it step by step:
20:46:58 <mauke> do { zs <- s'' xs; rs <- [x:zs, zs]; return rs }
20:47:09 <mauke> s'' xs >>= \zs -> do { rs <- [x:zs, zs]; return rs }
20:47:23 <mauke> s'' xs >>= \zs -> [x:zs, zs] >>= \rs -> do { return rs }
20:47:28 <mauke> s'' xs >>= \zs -> [x:zs, zs] >>= \rs -> return rs
20:47:59 <mauke> that's parsed as ((s'' xs) >>= (\zs -> ([x:zs, zs] >>= (\rs -> return rs))))
20:48:05 <grizzlybear5> can't i write do { zs <- s'' xs; rs <- [x:zs, zs]; return rs } as do { zs <- s'' xs; [x:zs, zs] }
20:48:06 <grizzlybear5> >
20:48:07 <mauke> not sure if the additional parens make it clearer
20:48:17 <mauke> grizzlybear5: yes, you can
20:48:50 <mauke> that shortcut isn't available in list comprehensions, though
20:54:26 <tgeeky> what rule is preventing me from creating an infixr 3 <x> operator?
20:54:54 <dmwit> grizzlybear5, mauke: For fun, I wrote a little Haskell interpreter and ran the "s" function. Check it:
20:54:59 <dmwit> http://hpaste.org/paste/47325/httppastebincomdrkxlat1#p47327
20:55:48 <dmwit> tgeeky: Are you putting parens around the operator? If so, don't.
20:55:57 <tgeeky> dmwit: nope
20:56:04 <dmwit> tgeeky: Paste the code and the error.
20:56:05 <aavogt> tgeeky: http://haskell.org/onlinereport/lexemes.html
20:56:31 <dmwit> tgeeky: Oh, you mean you want to literally name the function "<x>"?
20:56:44 <tgeeky> dmwit: I want to rename what Control.Arrow calls ***
20:56:49 <tgeeky> not to rename it
20:57:03 <tgeeky> just... implement it
20:57:07 <dmwit> Function names must have either all prefix characters or all infix characters.
20:57:13 <grizzlybear5> dmwit, these are all steps of s function for [1,2,3] ?
20:57:21 <dmwit> The string "<x>" has a mix of infix and prefix characters, so that's what's stopping you.
20:57:24 <dmwit> grizzlybear5: yep
20:57:27 <aavogt> there's some unicode times sign you can use instead
20:57:30 <tgeeky> dmwit: oh, that's strange but it makes sense
20:57:42 <mauke> > let (<√ó>) = (++) in "foo" <√ó> "bar"
20:57:46 <lambdabot>   mueval-core: Time limit exceeded
20:57:52 <mauke> why
20:57:52 <Nisstyre> Is there a list of guidelines on how to actually get a program to compile with GHC?
20:58:05 <mauke> Nisstyre: ghc --make the_program.hs
20:58:11 <dmwit> > let (√ó) = liftM2 in "foo" √ó "bar"
20:58:12 <lambdabot>   Couldn't match expected type `a1 -> a2 -> r'
20:58:12 <lambdabot>         against inferred type ...
20:58:17 <aavogt> mauke: try again, sometimes it's random
20:58:20 <dmwit> > let (√ó) = liftM2 (,) in "foo" √ó "bar"
20:58:20 <lambdabot>   [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o'...
20:58:21 <grizzlybear5> dmwit, is it hard to code such interpreter (or maybe find kind of open source stuff like it), 'cis it would be easier for me to understand some functions by using it
20:58:21 <Nisstyre> mauke: yes, but I have no idea what the main module does
20:58:33 <mauke> > let (<√ó>) = (++) in "foo" <√ó> "bar"
20:58:35 <lambdabot>   "foobar"
20:58:39 <mauke> Nisstyre: huh?
20:58:44 <dmwit> grizzlybear5: Well, it's a super-braindead one that's specialized very heavily to your exact code. =P
20:58:47 <Nisstyre> mauke: for example, http://codepad.org/96GKJIdr
20:58:53 <Nisstyre> how do I get that to compile?
20:59:02 <dmwit> grizzlybear5: But I'm not sure whether there's a better-made one out there. There's several smallish compilers.
20:59:28 <tgeeky> hm, now I get invalid argument, character not in code page
20:59:34 <mauke> Nisstyre: you don't, that's a syntax error
20:59:35 <grizzlybear5> dmwit, i don't get what you mean at all
20:59:38 <tgeeky> but thats probably because i copied an ASCII code
20:59:39 <dmwit> grizzlybear5: e.g. jhc and nhc are probably pretty hackable
21:00:18 <dmwit> grizzlybear5: I mean my interpreter is an interpreter for the "s" function, not an interpreter for Haskell. It leaves out almost everything -- it doesn't even have lambdas!
21:00:19 <Nisstyre> mauke: well the code works without the main =
21:00:30 <Nisstyre> loaded into ghci
21:00:34 <Nisstyre> how do I actually compile it?
21:00:36 <mauke> Nisstyre: no, it doesn't
21:00:50 <mauke> fahrtable 0 is still a syntax error
21:00:51 <grizzlybear5> dmwit, ok I see, what about jhc? does it work this way as Your interpreter?
21:01:10 <Nisstyre> mauke: without the function call at the end, it works
21:01:23 <tgeeky> but, dmwit: and mauke: thanks!
21:01:28 <grizzlybear5> dmwit, i mean it would be nice to have something like that, or something comparable to Prolog's trace
21:01:38 <grizzlybear5> which I can spy function step-by-step
21:01:42 <dmwit> ghci has a debugger, as well, which might be just what you're looking for.
21:01:50 <mauke> Nisstyre: http://codepad.org/iUoOeQra
21:02:19 <Nisstyre> mauke: so how do I fix it then?
21:02:21 <mauke> Nisstyre: celsius f = 5/9 * (f - 32)
21:02:35 <Nisstyre> mauke: they have to be Fractionals
21:02:40 <Nisstyre> or else they get truncated
21:02:41 <mauke> Nisstyre: they are
21:02:50 <mauke> Nisstyre: / doesn't truncate
21:03:04 <Nisstyre> so it infers the type from / ?
21:03:10 <aavogt> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=foldr+(%2B)+0+[1%2C2%2C3%2C4%2C5]
21:03:13 <mauke> yes
21:07:27 <tgeeky> if there are any physics-interested people, looks like the Tevatron scooped the LHC - but not on the Higgs
21:10:31 <grizzlybear5> ok, thanks a lot for help, gotta go ;)
21:10:31 <grizzlybear5> bye
21:10:51 <dafis> tgeeky: so the Tevatron created a black hole that destroyed the earth?
21:11:45 <liznewbtcminer> Tevatron?
21:12:47 <dafis> http://en.wikipedia.org/wiki/Tevatron
21:13:08 <tgeeky> dafis: ooh, no just short, I'm afraid. They seem to have found a 5-sigma signal of something that isn't the Higgs but is *not* in the SM
21:14:28 <tgeeky> http://blogs.discovermagazine.com/cosmicvariance/files/2011/05/CDF_Wjj_7fb.png
21:14:32 <dafis> well, confirmed?
21:14:58 <tgeeky> dafis: it was raised from 3 sigma to 5 sigma with more data (3.5 "units" to now 7 "units" of data)
21:15:07 <tgeeky> it was expected that the opposite would happen
21:15:43 <tgeeky> he key in that graph is the lull between the red and blue curves - clear enough to confirm it's not background
21:16:29 <tgeeky> it's not a confirmation yet, but it sets up a nice situation: either the (blue) signal *isn't* the higgs and it *is* discovered (though what ... it is... is totally unclear)
21:17:14 <tgeeky> *OR* it's the bottom-end of the Higgs decaying, and the Tevatron couldn't see it because of energy deficit, in which case the LHC should be producing whatever caused that (blue) signal, in huge quantities
21:17:31 <tgeeky> so it's "new physics" confirmed, just not clear which
21:19:03 <tgeeky> there is good reason to believe that signal *isn't* the higgs, though, which makes it the first (scooped!) option
21:19:41 <tgeeky> but that would take you reading a 50 pages of slides that would look like a leprechaun shat all over your monitor
21:19:47 <tgeeky> in order to see why :o
21:20:26 <dafis> tgeeky: I suppose I'd have to spend a year or two learning the physics to see why
21:20:40 <tgeeky> dafis: that too
21:20:54 <tgeeky> probably more *if* it's not the Higgs, as whatever this is, is rather exotic
21:21:48 <Eduard_Munteanu> tgeeky: interesting.
21:22:01 <Eduard_Munteanu> What do you mean the Tevatron scooped the LHC, though?
21:22:27 <tgeeky> possibly: a 4th generation quark (thought to be ruled out 20 years ago), a heavy-Z boson (thought to be ruled out 10 years ago), a supersymmetric particle (hundreds of proposals), ... and a hundred other weird things
21:22:50 <tgeeky> Eduard_Munteanu: well, this was discovered using Tevatron data, not LHC data
21:23:22 <Eduard_Munteanu> But Tevatron is lower energy. Then LHC should find it too, even more likely.
21:23:26 <tgeeky> Eduard_Munteanu: it's right smack in the middle of the anticipated Higgs range (above LEP exclusion, below ~ 170 GeV/c^2 Tevatron exclusion)
21:23:34 <tgeeky> Eduard_Munteanu: yeah, but the Tevatron found it first, so they get priority
21:23:42 <Eduard_Munteanu> Ah.
21:23:49 <Eduard_Munteanu> Is there a story on this?
21:23:55 <tgeeky> Eduard_Munteanu: because the LHC has already stated that with their (last year) data set of 35 pb^-1, they *do not* see it.
21:24:08 <tgeeky> As of right now, they have collected 500 pb^-1 this year.
21:24:14 <tgeeky> http://blogs.discovermagazine.com/cosmicvariance/2011/05/30/anomaly-at-the-tevatron-might-be-something-real/
21:24:27 <Eduard_Munteanu> Still, it might be one of those unlikely events.
21:24:32 <Eduard_Munteanu> Thanks.
21:24:49 <tgeeky> Eduard_Munteanu: in terms of statistics, this is above "unlikely"
21:25:00 <Eduard_Munteanu> We still need LHC to reproduce it.
21:25:03 <tgeeky> the really key part are the data points between the red and blue hills
21:25:09 <tgeeky> Eduard_Munteanu: yeah, and I'm sure they have
21:25:42 <tgeeky> Eduard_Munteanu: slight caveat: if this *is* one of the things above, then it might be just below the LHC threshold and just above the tevatron threshold
21:26:26 <tgeeky> Eduard_Munteanu: but the LHC is collecting so much data, so fast, that it hardly matters.
21:27:29 <AlexWebr> Hey folks, I'm reading LYAH and I'm having a problem conceptually.
21:27:35 <tgeeky> AlexWebr: hit me.
21:27:36 <Eduard_Munteanu> Ah, so in the LHC stuff gets lost in noise?
21:27:58 <AlexWebr> tgeeky: :) How could we implement the 'reverse' function using a left fold?
21:28:14 <Eduard_Munteanu> I thought it was supposed to be able to reproduce most experiments.
21:28:33 <dmwit> AlexWebr: Impossible. Don't even try.
21:28:36 <tgeeky> yeah
21:28:37 <mauke> @src reverse
21:28:37 <lambdabot> reverse = foldl (flip (:)) []
21:28:44 <tgeeky> just use that :o
21:29:02 <AlexWebr> Wait, really?
21:29:05 <AlexWebr> Impossible?
21:29:05 <tgeeky> AlexWebr: that's satire-speak for 'trivially'
21:29:09 <AlexWebr> Oh.
21:29:11 <AlexWebr> Hahaha
21:29:29 <mauke> the canonical version would be "forget it, it's NP-complete"
21:29:54 <mauke> (I only use that for really trivial stuff, though)
21:29:54 <Eduard_Munteanu> @quote impossible
21:29:54 <lambdabot> JonathanShapiro says: This sort of "let's do a conservative, evaluable experiment" approach makes project funding nearly impossible to obtain in academic circles, which may help to explain why
21:29:54 <lambdabot> computer scientists tend to step on each other's toes rather than standing on each other's shoulders.
21:30:02 <AlexWebr> The author of LYAH wasn't kidding when he said "The Haskell community is great."
21:30:03 <Eduard_Munteanu> Bah.
21:30:27 <stepkut> is there a method for extending a parser, like 'reads', which can return multiple successful parsers, to also provide error reporting (like parsec?)
21:30:40 <stepkut> or.. perhaps a better question is..
21:31:02 <aavogt> @hoogle errort
21:31:03 <lambdabot> Control.Monad.Error newtype ErrorT e m a
21:31:03 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
21:31:03 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
21:31:51 <AlexWebr> @src flip
21:31:51 <lambdabot> flip f x y = f y x
21:31:58 <stepkut> how can I write a parser where, (lit "foo" <> lit "foo" . int) will find the longest parse, but also be able to return an error when there is a parse error
21:31:59 <tgeeky> AlexWebr: if you don't say "oh yeah... that's... that's pretty clever" 30 times before finishing LYAH, then you've missed it.
21:32:39 <mauke> stepkut: I've got one of those
21:32:43 <AlexWebr> tgeeky: I'm just finishing the folds chapter and I'm sure I've doubled that already. Haskell blows my mind.
21:33:11 <stepkut> mauke: where at ?
21:33:22 <mauke> in my haskell directory
21:33:22 <tgeeky> AlexWebr: that's what happens when the cleverest people get together and think about how to make things simple
21:33:26 <mauke> still playing around with it
21:33:34 <stepkut> mauke: >:(
21:34:09 <tgeeky> @quote zygo
21:34:09 <lambdabot> roconnor says: sounds like you need a zygohistomorphic prepromorphism
21:34:25 <stepkut> mauke: can you give me a pointer? a reads like parser will have a type like [(a,[tok])]. An error reporting parser would have a type like, Either Error a.
21:34:26 <tgeeky> damn, byorgey's was funnier
21:34:32 <mauke> stepkut: http://mauke.dyndns.org/stuff/haskell/gradef-bread/
21:34:44 <AlexWebr> tgeeky: :) Like really, quicksort in 5 lines? Is there any language more expressive?
21:34:55 <mauke> APL?
21:34:58 <stepkut> mauke: thanks
21:35:04 <tgeeky> brainfuck, if you're a psychopath?
21:35:16 <Nisstyre> isn't brainfuck just primitives?
21:35:20 <Eduard_Munteanu> Mind that quicksort isn't that efficient.
21:35:23 <opqdonut_> AlexWebr: 1) it's not quicksort 2) some languages are as expressive
21:35:26 <tgeeky> wait, you said 'expressive', not 'oppressive'
21:35:28 <shachaf> Eduard_Munteanu: Nor is it a quicksort.
21:35:38 <Veinor> i forget, why isn't it a quicksort
21:35:39 <AlexWebr> tgeeky: Hah opqdonut_ What is it?
21:35:40 <mauke> it is efficient, and IMO it is a quicksort
21:35:41 <Eduard_Munteanu> Yeah, not quite.
21:35:52 <mauke> well, "efficient". it's just slow
21:36:07 <tgeeky> AlexWebr: http://en.wikipedia.org/wiki/Brainfuck
21:36:14 <opqdonut_> AlexWebr: the point of quicksort is the efficient in-place shuffling. that haskell implementation simulates it on lists
21:36:21 <Nisstyre> it's O(logn)
21:36:34 <opqdonut_> Nisstyre: yeah but mergesort is easily more efficient
21:36:44 <Eduard_Munteanu> Nisstyre: heh, you wish :)
21:37:01 <AlexWebr> tgeeky: I've written a source-to-source compiler for Brainfuck ;) I just can't imagine why anybody would answer "What's the most expressive language?" with "Brainfuck."
21:37:15 <tgeeky> AlexWebr: s/expressive/oppressive/
21:37:29 <tgeeky> as in, I'm being repressed! I'm being repressed!
21:38:00 <AlexWebr> tgeeky: I'm being liberated by simple syntax!
21:38:16 <stepkut> mauke: so, this code finds the parse that consumes the most tokens regardless of the order of the parsers?
21:38:21 <tgeeky> AlexWebr: it gets worse, too, but then it gets better. Then worse. Then better. And by that point, you're a dons.
21:38:25 <mauke> stepkut: no, it finds all parses
21:38:33 <mauke> stepkut: but you can use 'longest'
21:38:37 <stepkut> mauke: ah
21:39:04 <stepkut> mauke: k. Finding all the parsers, and then looking for one that consumed everything is probably sufficient for me
21:39:12 <Nisstyre> *O(nlogn)
21:39:28 <mauke> stepkut: well, if you know you want to consume everything, p <* eof
21:40:09 <stepkut> mauke: hmm
21:40:19 <AlexWebr> So what makes this implemention of quicksort a) not a quicksort and b) inefficient? Is it not in-place?
21:40:38 <tgeeky> AlexWebr: could it be?
21:40:42 <opqdonut_> AlexWebr: it works on (singly linked) lists
21:41:00 <Eduard_Munteanu> It's _pretty much_ a quicksort, the problem is you create new lists at each step.
21:41:14 <mauke> it's still O(n*log n) best case
21:41:21 <Nisstyre> Eduard_Munteanu: so it uses a lot of memory
21:41:25 <Nisstyre> or not?
21:41:41 <Eduard_Munteanu> That's not really the issue in most cases. It uses more time too.
21:41:42 <tgeeky> Quicksort can be implemented as an in-place sort, requiring only O(logn) additional space.[1]
21:41:48 <AlexWebr> tgeeky: Could it be what?
21:41:50 <Nisstyre> I guess lazy evaluation would save memory
21:41:53 <Eduard_Munteanu> Since you have to copy stuff, then garbage collect it etc.
21:42:02 <Nisstyre> ah
21:42:02 <tgeeky> AlexWebr: if it were in place, it couldn't be pure, yes?
21:42:05 <Nisstyre> yeah
21:42:25 <Nisstyre> what sort of garbage collector (if it has one) does ghc use?
21:42:29 <opqdonut_> well one could have an externally pure quicksort using ST
21:42:31 <opqdonut_> for arrays
21:42:41 <tgeeky> opqdonut_: yeah, but I don't think lyah covers that
21:43:01 <AlexWebr> tgeeky: I thought purity only constrained the conceptual language. How the GHC implements it is kind of irrelevant, isn't it?
21:43:02 <Eduard_Munteanu> Complexity-wise I think it uses "just as much" space.
21:43:02 <stepkut> mauke: that does not work with my current parser.. but it should work with yours
21:43:02 <mauke> Nisstyre: copying/generational
21:43:07 <Nisstyre> nvm, found this http://hackage.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
21:43:15 <Nisstyre> I've never heard of either strategies...
21:43:25 <tgeeky> AlexWebr: what chapter is that?
21:43:26 * Nisstyre has some reading to do
21:43:28 <stepkut> mauke: with my current parser I would have to do, (lit "foo" . eof) <> (lit "foo" . int . eof)
21:43:36 <opqdonut_> AlexWebr: well the semantics of the language are pure. that constrains the implementation quite a bit
21:43:39 <stepkut> mauke: which is not acceptable
21:43:55 <mauke> lit "foo" . optional int . eof
21:44:14 <Eduard_Munteanu> If you want an efficient quicksort in Haskell, either (1) use something like ST(U)Array to implement it or (2) FFI to C code.
21:44:29 <AlexWebr> opqdonut_: Right. But if the compiler decides to make the physical implementation in-place or whatever, the code I'm writing is still pure. Right?
21:44:34 <shachaf> Eduard_Munteanu: Interesting definition of "in Haskell" you've got there.
21:44:35 <opqdonut_> and if you want an efficient sort in Haskell, you're pretty well off with merge sort
21:44:37 <Eduard_Munteanu> IIRC, Haskell's 'sort' is a merge sort.
21:44:40 <opqdonut_> (with a 5-line implementation)
21:44:48 <Eduard_Munteanu> shachaf: I didn't say "to write"
21:44:53 <Eduard_Munteanu> :)
21:44:55 <shachaf> True.
21:45:01 <mauke> stepkut: but yeah, (tokens "foo" <|> (tokens "foo" *> some digit)) <* eof should totally work (or however you're going to represent it)
21:45:20 <opqdonut_> AlexWebr: sure, yeah. but that's quite hypothetical :)
21:45:29 <stepkut> mauke: well, it is really more like, data Foo = Bar | Baz Int, (Bar <$> (lit "foo" . eof)) <> (Baz <$> (lit "foo" . int . eof))
21:45:35 <tgeeky> AlexWebr: type this in your ghci
21:45:45 <tgeeky> AlexWebr: random (mkStdGen 100) :: (Int, StdGen)
21:45:59 <stepkut> mauke: so, if there are no successful parsers, how does it decide what error to report ?
21:46:03 <mauke> stepkut: why can't you factor the lit "foo" out?
21:46:10 <tgeeky> AlexWebr: and paste the result
21:46:26 <Eduard_Munteanu> Well in some cases it could transform lists to arrays and such, I think. But I think there are lots of cases in which it's damn right hard to do so.
21:46:40 <Eduard_Munteanu> ("it could" == "it could if implemented")
21:46:41 <tgeeky> (-1352021624,651872571 1655838864)
21:46:51 <mauke> stepkut: it reports the rightmost error
21:47:01 <stepkut> why rightmost ?
21:47:14 <mauke> because that's what made sense to me
21:47:19 <stepkut> :)
21:47:19 <shachaf> Eduard_Munteanu: At any rate it couldn't do the sort in-place.
21:47:32 <mauke> stepkut: everything before it is theoretically acceptable
21:47:52 <AlexWebr> tgeeky: I was getting confused as to why I was getting error messages with that line, and then it occurred to me I hadn't started ghci yet. >.<
21:47:56 <shachaf> Eduard_Munteanu: (For one, because quicksort isn't an in-place algorithm.)
21:48:34 <mauke> stepkut: if you have something like "1 + (2 * 3" you want to report the missing ')' at the end, not the fact that instead of '(' you could also have used a number
21:48:43 <mauke> stepkut: or that the + could have been a -
21:48:46 <tgeeky> AlexWebr: I brought it up because that's the example in LYAH where it hit me exactly how *seriously* haskell takes "purity" (or referrential transparency)
21:49:25 <Eduard_Munteanu> shachaf: um, why not?
21:49:26 <mauke> stepkut: if multiple parsers fail at the same spot, it mappends the errors
21:49:28 <AlexWebr> tgeeky: The example you just posted? I don't understand any of it. I'm not there yet.
21:49:48 <stepkut> if I factor out the lit I still have, pure Bar <> (Baz <$> int), and so Bar will always succeed even if Baz would.
21:49:51 <shachaf> Eduard_Munteanu: Well, depends on your meaning of "in-place". It's not constant-space, anyway.
21:50:08 <mauke> stepkut: ah, I see
21:50:38 <stepkut> mauke: but I want to return Baz since it consumed more input
21:51:02 <AlexWebr> tgeeky: I got a whole bunch of 'not in scope' errors.
21:51:03 <tgeeky> AlexWebr: yeah, you don't have to understand it. The point is, when you type in the code (which ought to generate a random number) in *your* GHCi, it produces *exactly* the same output as it did for the author of LYAH
21:51:08 <Eduard_Munteanu> shachaf: it really is, actually. You merely need to store the pivot point and a couple of indices besides the actual vector.
21:51:23 <tgeeky> AlexWebr: type :m +System.Random
21:51:40 <tgeeky> then type it
21:51:58 <AlexWebr> tgeeky: Why is that? Isn't that dangerous?
21:52:10 <shachaf> Eduard_Munteanu: ?
21:52:23 <Eduard_Munteanu> Ah, my bad, you do need a bit more stuff besides the vector.
21:52:32 <tgeeky> AlexWebr: no, you have to do something slightly different in haskell to get random numbers
21:52:59 <tgeeky> AlexWebr: the point is, haskell takes the idea that if you call a function with some arguments, it should *always* return the same results
21:53:13 <tgeeky> AlexWebr: rather seriously
21:53:21 <AlexWebr> tgeeky: Oh, I see. So, what exactly does this code do then? Because I can't understand it, so I don't understand what makes it such a good example.
21:53:41 <Eduard_Munteanu> But you still need in-place updates to get comparable performance
21:55:13 <Eduard_Munteanu> Anyway, quicksort is probably a bit overrated.
21:55:17 <tgeeky> AlexWebr: -> PM
21:59:29 <lpsmith> is there a convenient way of loading a cabal-built package without registering it?
22:01:08 <Jafet> Isn't the convenient way to register it?
22:01:34 <Jafet> Otherwise, you'd fiddle with telling ghc about the interface and object files
22:02:36 <Jafet> Or register it in a temporary world
22:04:19 <eekTheCat> Hmm. Subtle problems like this http://www.haskell.org/haskellwiki/Let_vs._Where#Problems_with_where make me think I'm not cut out to write haskell code.
22:05:44 <Jafet> If you're not cut out to write Haskell, you're not cut out to do anything!
22:06:07 <eekTheCat> Is that an optimization that a compiler could generally spot and fix?
22:06:10 <Jafet> GHC probably recognizes it as a constant anyway.
22:06:24 <dafis> Jafet: nope
22:06:53 <Jafet> Oh, I'm not referring to fib'. That webpage seems a bit off
22:07:40 <Jafet> Pretty sure the constant here is actually (map fib' [0..])
22:08:11 <Nisstyre> tgeeky: could there be a function that takes no arguments and returns a random integer?
22:08:12 <lispy> who keeps raping lambdabot?
22:08:19 <lispy> Cale: ping?
22:08:38 <tgeeky> Nisstyre: hmmmm
22:08:58 <tgeeky> Nisstyre: I don't know. I'd guess that it's possible
22:09:06 <lispy> Did someone ask for the type of an exponential type again?
22:09:09 <tgeeky> you could write a 0 argument function that loads the content from a webpage
22:09:13 <Nisstyre> yeah, what is the standard way of generating random numbers in haskell?
22:09:16 <dafis> > product [0 .. 20]
22:09:17 <lambdabot>   0
22:09:33 <Nisstyre> something that uses system calls?
22:09:37 <aavogt> eekTheCat: it looks like ghc -O2 makes both of those fibs equally fast
22:09:58 <dafis> @botsnack
22:09:58 <lambdabot> :)
22:10:01 <tgeeky> Nisstyre: that's one way - you pass the random generator around and generate new generators
22:10:23 <Nisstyre> interesting
22:11:27 <dafis> aavogt: not without a type signature, I think
22:13:08 <Nisstyre> tgeeky: so the other way is to have an infinite list of random numbers that you keep calling the next element in?
22:13:14 <Nisstyre> that seems easier to understand
22:14:52 <tgeeky> Nisstyre: that you could do, where the list constructor passes the number generator along the list for you, as you call it
22:15:04 <tgeeky> I don't know much about it, but LYAH did a couple of good examples
22:15:28 <aavogt> dafis: I have not given one, but it assumes integer
22:16:06 <aavogt> and interestingly the   fib :: Int -> Integer or so in the core
22:16:18 <Jafet> Heh, compiling with -O gives a case x_atp of wild_B1 { __DEFAULT -> Main.fib1_go (GHC.Prim.+# wild_B1 1); 9223372036854775807 -> GHC.Types.[] @ GHC.Types.Int }
22:16:37 <dafis> aavogt: the one with the argument ought to be polymorphic
22:16:42 <Jafet> (main = print (fib1 42) }
22:18:01 <aavogt> sure, but my main (like Jafet's) is the only place the fib gets called
22:18:55 <aavogt> if the function is used at different types, it might still be fast if there were specialized versions made
22:19:23 <Jafet> I forced everything to Int to keep things readable
22:19:23 <dafis> aavogt: I assumed it was exported
22:19:29 <stepkut> mauke: I got it working. Thanks!
22:19:36 <lispy> Cale: lambdabot is going wild again.  Maybe have yet another rogue mueval <sigh>
22:20:02 <lispy> Cale: scratch that, it has tons of rogue muevals :( :(
22:20:05 <aavogt> lambdabots gone wild!?
22:20:20 <Jafet> lambdabots gone rouge
22:20:30 <Eduard_Munteanu> @vixen Calm down!
22:20:31 <lambdabot> i'm the type of girl that finds Don Knotts very sexy
22:21:42 <Jafet> If she's raping Cale's machine, he's bound to notice anyway
22:22:20 <lispy> I'm actually a little worried about my linode
22:22:24 <lispy> It's was acting strange
22:28:36 <taotree> I got this error and I'm not familiar with it, not sure what's causing it and google isn't telling me much yet.
22:28:40 <taotree> "cabal: can't find source for Data/Binary/OpenGL in src, dist/build/autogen"
22:30:43 <b0fh_ua> Hi! I'm trying to solve problem 14 on projecteuler.com with this code: http://pastebin.com/cVepmVbS. Everything looks ok - I'm using memoization when trying to find next number (Data.Map), and on input 100000 it worls pretty fast - however on inmut 1000000 it works too long and consumes a lot of memory. What may be wrong with my solution?
22:34:28 <dafis> b0fh_ua: Int overflow
22:35:00 <b0fh_ua> dafis: what do you mean?
22:35:42 <dafis> b0fh_ua: the sequence can get pretty large before it finally drops to 1
22:36:25 <dafis> b0fh_ua: so at some point, you exceed 2^31 and get a negative number => cycle
22:37:05 <dafis> b0fh_ua: change the types to Integer or Int64 and you'll get an answer
22:44:33 <b0fh_ua> dafis: okay, will try with Int64
22:45:59 <b0fh_ua> dafis: thanks! that worked!
22:46:13 <dafis> b0fh_ua: I know
22:47:33 <dafis> b0fh_ua: you'll generally have to think about possible overflow with the PE problems, but excepting a few, 64 bits are enough
22:51:24 <grizzlybear5> @src concatMap
22:51:36 <grizzlybear5> @src concatMap
22:52:14 <roconnor> b0fh_ua: why not use Integer?
22:52:37 <dibblego> concatMap f = foldr (\a b -> f a ++ b) []
22:52:55 <grizzlybear5> :t concatMap
22:53:19 <dibblego> (a -> [b]) -> [a] -> [b]
22:53:39 <grizzlybear5> can i type concatMap as concat.map ?
22:53:54 <c_wraith> almost
22:53:57 <c_wraith> :t concat . map
22:54:02 <roconnor> grizzlybear5: you can only do (concat .) . map
22:54:07 <c_wraith> ...  lambdabot is down?
22:54:29 <dibblego> (concat .) . map
22:54:40 <grizzlybear5> could You please show me ony example of concatMap?
22:54:56 <dibblego> fmap fmap fmap concat map
22:55:20 <dafis> @dibblegosnack
22:55:25 <roconnor> grizzlybear5: concatMap (\n -> [0..n-1]) [0..]
22:55:53 <grizzlybear5> ok ;]
22:55:57 <aavogt> when you have a function (String -> IO Bool) to run in a separate thread, do you use  MVar (Either String Bool), or two MVars?
22:57:15 <grizzlybear5> another question, what's a usage of unfoldr?
22:57:52 <aavogt> it's for making lists one step at a time
22:57:58 <grizzlybear5> i get the idea of foldr
22:58:02 <grizzlybear5> but don't get unfoldr
22:58:10 <grizzlybear5> could You show me example please?
22:58:47 <aavogt> > unfoldr (\x -> Just (not x, if x then '1' else '0')) False
22:59:43 <aavogt> actually you need to swap the tuple for that to work
23:00:14 <grizzlybear5> eer, i still don't get the idea of unfoldr
23:00:27 <grizzlybear5> is it any connection between foldr and unfoldr?
23:00:36 <grizzlybear5> i know how foldr wokrs
23:01:43 <roconnor> foldr and unfoldr are dual in a sense
23:01:58 <jmcarthur> grizzlybear5: foldr collapses a list to some result, unfoldr generates a list from an initial seed
23:02:16 <jmcarthur> :t unfoldr
23:02:26 <jmcarthur> aw lambdabot :(
23:02:44 <aavogt> it's not a big deal since people don't use it very often
23:02:51 <yitz> jmcarthur: seems like lispy took her down not long ago, due to rogue mueval processes
23:03:17 <jmcarthur> i've been using anamorphisms a lot lately, but i'm writing stream fusible code
23:04:29 <geheimdienst> i don't want to know about these things, lispy going down on lambdabot and that
23:04:38 <yitz> aavogt: don't use what very often? unfoldr, or lambdabot? actually, i think both are used often.
23:04:53 <roconnor> the type of foldr is (a -> b -> b) -> b -> [a] -> b, which can be rearranged into ((a,b) -> b) -> b -> [a] -> b, and that can be rearranged into (Maybe (a, b) -> b) -> [a] -> b
23:05:09 <roconnor> compare with unfoldr of type (b -> Maybe (a,b)) -> b -> [a]
23:05:28 <roconnor> ... though this is a pretty academic way of comapring foldr with unfoldr
23:06:50 <roconnor> lambdabot is so unstable because it is written in Haskell.
23:07:00 <grizzlybear5> if i'm able to write function by using foldr am i able to write it by using unfoldr?
23:07:04 <grizzlybear5> imho nope
23:07:06 <geheimdienst> @slap roconnor
23:07:11 <geheimdienst> ... oh, right
23:07:19 <aavogt> yitz: as an example, unfoldr is only used 6 times in cabal-install
23:07:34 <roconnor> there is probably a use of head applied to a nil list in lambdabot somewhere
23:08:01 <aavogt> oops, that's including the Cabal library too
23:09:22 <yitz> roconnor: lambdabot is so unstable because it was written a long time ago when a lot of the techniques we now use for that kind of long-running program were not as well understood.
23:09:34 <aavogt> vs. say 90 times filter, or 200 times functions containing fold*
23:09:41 <yitz> roconnor: also because of a huge amount of cruft and bitrot
23:10:20 <aavogt> is concurrency supposed to work in the IO in the Q monad?
23:10:41 <yitz> aavogt: true, it's certainly not as fundamental as a fold or filter. but it's an extremely powerful tool.
23:16:38 <grizzlybear5> btw, You showed me the definition of concatMap, so please tell me why something like that doesn't work:
23:16:38 <grizzlybear5> p (x:xs) = foldr(\a b -> (ins x)  (a ++ b))  ( p xs )
23:16:45 <grizzlybear5> [a] -> [[a]]
23:17:00 <grizzlybear5> err, and p [] = [[]]
23:18:05 <grizzlybear5> argh, nvm
23:18:11 <grizzlybear5> [] at the end...
23:19:00 <grizzlybear5> but it doesn't generate permutations, why?
23:19:13 <jmcarthur> djahandarie: btw, just to give some concrete to my claims that stream fusion fits in with existing recursion schemes: http://hpaste.org/47328/stream_fusion_with_recursions
23:19:47 <grizzlybear5> p (x:xs) = concatMap (ins x) $ p xs  does generate permutations
23:19:52 <grizzlybear5> so how to convert it to foldr?
23:19:53 <jmcarthur> djahandarie: ^^ fits stream fusion into the framework in edwardk_'s recursion-schemes package (minus some of the necessary inline and potentially some beneficial specializations)
23:19:59 <jmcarthur> *inlining
23:21:26 <geheimdienst> > "meow"
23:21:36 * jmcarthur hopes djahandarie sees that since lambdabot (and therefore @tell) is on the fritz
23:22:16 <shachaf> preflex: tell jmcarthur blah
23:22:16 <preflex>  Consider it noted.
23:22:22 <shachaf> Huh, it works.
23:22:28 <jmcarthur> oh hey preflex
23:22:28 <preflex>  jmcarthur: you have 1 new message. '/msg preflex messages' to read it.
23:23:18 <roconnor> preflex: tell lambdabot :t unfoldr
23:23:18 <preflex>  Consider it noted.
23:23:32 <jmcarthur> preflex: tell djahandarie http://hpaste.org/47328/stream_fusion_with_recursions  <-- just btw... stream fusion with edwardk's recursion-schemes package, minus some inlining and maybe some beneficial specializations
23:23:32 <preflex>  Consider it noted.
23:50:13 <lambdabot> preflex: messages
23:50:13 <preflex>  roconnor said 26 minutes and 56 seconds ago: :t unfoldr
23:50:20 <lambdabot> garbage collection!
23:51:33 <Jafet> dmwit, pl \a s d f -> f g s (f d s)
23:52:13 <jmcarthur> const (ap ((.) . ap . flip ($ g)) (flip (flip . flip id)))
