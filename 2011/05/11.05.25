00:01:23 <Favonia> nwf: I think I successfully simplify your code by abusing type families :P
00:01:56 <Favonia> actually I wanted to use functional dependency only but failed :( not sure why
00:09:32 <nwf> Favonia: oh?
00:09:53 <Favonia> nwf: sorry my IRC client seems strange :(
00:11:06 <Favonia> nwf: would you mind if I use hpaste?
00:15:32 <pacak> If i want to read and understand ghc Core language - where should i start? Is there any documentation or tutorials?
00:25:11 <nwf> Favonia: No, please, hpaste is excellent.
00:27:22 <Favonia> nwf: http://hpaste.org/47029/idtree
00:28:24 <Favonia> nwf: I merged the IDCompat and IDKC, deleted IDSh, etc...
00:29:09 <nwf> But it looks like you can now build IDTreeN IDOne IDOne, which is a bug.
00:29:42 <Favonia> oh sorry I misunderstood your code :(
00:29:45 <Favonia> I see
00:29:48 <nwf> Or at least, I think it's a bug -- the paper says that the normalized form of that is IDOne.
00:30:06 <nwf> Yeah, sorry, it wasn't very well documented.
00:30:30 <Favonia> let me try if I can add this constraint
00:32:31 <Favonia> nwf: by the way, I would like to say that an empty class generally will not save you
00:32:45 <nwf> How's that?
00:32:58 <Favonia> because people can always define new instances
00:33:34 <Favonia> and the context cannot guarantee you new functionalities
00:34:37 <Favonia> (hmm, wait, maybe I am wrong. I am not sure if we can use module-export-control to stop people from declaring their own instances)
00:35:34 <Favonia> anyway if I am wrong please add IDSh back :)
00:37:02 <nwf> Oh, yeah, I think even with module-export-control, GHC's inference system assumes classes are open.
00:37:35 <nwf> Habit has a solution to that, and koninkje suggested reifying the instances as arms of a GADT to close the family.
00:38:16 <nwf> I should try the GADT approach and see if the Core erases the parameters (though I don't think it will).
00:39:23 <Favonia> nwf: oh I believe the context requirement is kept
00:44:30 <Favonia> nwf: oh now I see why you have to enumerate all cases
00:45:22 <Favonia> nwf: but the problem seems to be related to what we just discussed. if classes are all open, there is no guarantee that IDZero/IDOne are the only two cases
00:45:41 <Favonia> I meant, two special cases
00:48:36 <Favonia> nwf: for example, if I go trinary and define IDTwo then there is a new special case
00:48:41 <nwf> Yeah.
00:49:40 <Favonia> hmm seems interesting anyway
00:49:48 <Favonia> nwf: I have an idea
00:50:15 <Favonia> how about hiding the data constructors so that no one can use IDTreeN ?
00:51:03 <Favonia> by providing a customized constructor, you can guarantee that it is truly normalized
00:56:34 <nwf> Is it possible to export the destructors and not the constructors of an ADT?
00:56:58 <nwf> (Not that it necessarily matters for the case at hand.)
01:00:39 <Favonia> nwf: hmm...
01:00:50 <Favonia> nwf: how about something like a fold :P
01:02:47 <nwf> Yeah, for the case at hand there's really a closed vocabulary of operations (split, merge, Eq, Ord)
01:02:49 <helloworld159753> hi
01:02:58 <helloworld159753> could You please show me any example of MaximumBy?
01:03:07 <helloworld159753> for which purpose should i use it?
01:03:12 <issactrotts> hi, i have a concurrency question
01:04:02 <isomorphic> so, I'm trying to write a testcase in Hunit, and I'm having trouble with making it work despite the taint.
01:04:03 <issactrotts> I tried running the code here: http://en.wikipedia.org/wiki/Concurrent_Haskell
01:04:14 <isomorphic> here's what I have http://hpaste.org/47030/testcase_with_io_monad
01:05:04 <issactrotts> It says bob is supposed to end up with 8000 and jill is supposed to have 6000 at the end, but in reality the answers are a little off though still consistent.
01:05:20 <issactrotts> For example: Bob's balance: 8005, Jill's balance: 5995
01:06:15 <issactrotts> Sleeping a bit before printing worked with runhaskell, but curiosly did not help when I used ghc.
01:06:24 * hackagebot egison 0.1.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.1.1 (SatoshiEgi)
01:06:33 <Favonia> nwf: I feel it is like maintaining a complex tree structure. you only export operators like insert and delete
01:06:48 <issactrotts> Of course I'm looking for a real solution...
01:10:39 <nwf> issactrotts: What platform are you on?
01:10:51 <issactrotts> mac os x snow leopard
01:10:57 <ceii> issactrotts, the code on that page is clearly buggy because it doesn't wait for the updating threads to be done
01:11:01 <nwf> The real answer is to wait (join) all the forkIO'd threads.
01:11:13 <ceii> but I have no idea why sleeping doesn't work in ghc
01:11:43 <issactrotts> thanks, i don't know how to wait for the threads, but I will look
01:11:46 <nwf> issactrotts: You used the threaded runtime?  How many threads?
01:12:06 <issactrotts> i don't know. would have to check
01:12:48 <nwf> I would guess that sleeping didn't help because the sleep stalled one/more of the worker threads behind it.
01:15:16 <Favonia> helloworld159753: how about maximumBy (comparing length)
01:15:49 <Favonia> he's gone :O
01:16:08 <fragamus> I have a question
01:16:09 <fragamus> schmove :: (RandomGen g) => Cards -> RandT g (StateT Creature []) Move
01:16:19 <fragamus> that's my monad ^^^
01:16:56 <fragamus> I am trying to invoke it with this:
01:16:58 <fragamus> moves = evalState (evalRandT schmoves gen) creature
01:17:02 <nwf> issactrotts: The typical answer for joining threads is to have them put () into an empty mvar and have some other thread get it.
01:17:14 <fragamus> but somewhere I need to deal with the []
01:17:27 <issactrotts> thanks nwf, i'll try it
01:17:28 <nwf> (I am not sure why there isn't a joinIO "inverse" of forkIO ala pthreads)
01:17:31 <fragamus> see the [] in the type signature for schmove
01:18:00 <Botje> evalSateT (evalRandT ...) ... will give you a [Move]
01:18:10 <Botje> with some other cruft.
01:19:01 <fragamus> but the type is wrong for the invocation line
01:19:08 <fragamus> ghc is pissed
01:20:25 * hackagebot haskell-src-exts 1.11.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.11.1 (NiklasBroberg)
01:24:22 <issactrotts> Using the myForkIO function on http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent#g:5 almost gets it. Now I get Bob's balance: 8001, Jill's balance: 5999
01:28:56 <issactrotts> The supposedly better way is worse by one: Bob's balance: 8002, Jill's balance: 5998.
01:29:27 * hackagebot http-date 0.0.0 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.0 (KazuYamamoto)
01:30:05 <issactrotts> Admittedly, I'm not using the later function because I have no idea where to find it.
01:43:59 <blackdog> heh, so proud of the ruby guys
01:44:04 <blackdog> they broke barley pretty bad :)
01:44:52 <osfameron> barley?
01:45:13 <blackdog> johtib and mtnviewmark's interactive haskell tute.
01:45:44 * osfameron googles, finds https://github.com/mtnviewmark/barley
01:46:03 <osfameron> is there a demo site somewhere?
01:46:32 <blackdog> osfameron: don't think so, it's not particularly secure.
01:46:44 <osfameron> ooo, not heard of Snap.  I was looking into yesod and happstack recently
01:46:51 <quicksilver> is it like tryhaskell ?
01:46:53 <issactrotts> None of the official solutions worked for me, but this hack did:
01:46:58 <blackdog> it's pretty easy to set up, though. cabal install barley, barley init foo, cd foo, barley start
01:47:15 <issactrotts> Just spawn another 100 threads that each transfer $0 from bob to jill.
01:48:33 <issactrotts> Still not a very satisfying answer.
01:57:58 * osfameron starts up barley
02:10:11 <ader111> I have a question regarding iteratees
02:10:50 <ader111> I am wondering if someone already have done that or whether it is a stupid idea
02:10:51 <mm_freak> issactrotts: a proper concurrent application doesn't need any workarounds or timing adjustments
02:10:54 <poltak> ader111: go ahead
02:11:12 <ader111> but I am not only interested in the final result but also in intermediate values
02:12:00 <ader111> is it a good idea to implement another signal than Done and Continue that would carry intermediate values
02:12:22 <ader111> something like scan but with an iteratee
02:12:57 <ader111> I don't know if I am clear enough
02:13:04 <mm_freak> ader111: no
02:13:19 <mm_freak> don't forget that Iteratee is a class of monad transformers
02:14:05 <ader111> no, it is not stupid, or no it is not good
02:14:06 <ader111> ?
02:14:20 <mm_freak> you encode intermediate values in iteratees just like you do it in any other monad
02:14:23 <mm_freak> for example IO
02:14:45 <mm_freak> you could also combine Iteratee and StateT
02:15:06 <ader111> I see
02:15:18 <mm_freak> but to really answer your question it's not helpful to tell us what code you want to write, but what application you need it for
02:15:42 <mm_freak> because there is no such thing as an "intermediate value" in iteratees
02:16:22 <ader111> the thing is that what I am writing is Scala code, but I am sure here is the right place for my question
02:17:03 <ader111> my question is very much conceptual
02:17:10 <mm_freak> well, probablyâ€¦  scala has different semantics, so haskell answers usually don't apply to scala too much
02:17:32 * hackagebot wai-extra 0.4.0.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.0.1 (MichaelSnoyman)
02:17:34 <mm_freak> but to keep track of something while the enumeration is going you probably don't want to encode this in an iteratee at all
02:17:37 <mm_freak> but in an enumeratee
02:17:56 <mm_freak> for example you want to keep track of the current byte position in a byte stream
02:18:18 <Silex> hi
02:18:21 <mm_freak> zipPositions :: Enumeratee ByteString (ByteString, Integer) m b
02:18:40 <mm_freak> hi Silex
02:18:47 <ader111> so Enumeratee is an Iteratee and an Enumerator?
02:19:32 <ader111> the way I understand it is an Iteratee that produces an Enumerator
02:20:19 <mm_freak> an iteratee that maps a Step to another Step, to talk in terms of the 'enumerator' package
02:20:52 <mm_freak> it's an iteratee running with a different input type (the outer input type)
02:21:04 <mm_freak> it gets a Step of the inner input type and produces a new step of the inner input type
02:21:38 <issactrotts> mm_freak: I agree, but so far I have not found any clean way to make it work. Do you have a specific idea?
02:21:50 <mm_freak> issactrotts: i haven't look at the code
02:22:54 <ader111> mm_freak: ok, there maybe something I dont understand. Doesn't iteratee return the value by the end? I mean it is not 'lazy'
02:25:08 <mm_freak> ader111: the final result, yes
02:25:25 <mm_freak> it's a regular monadic concept
02:25:41 <mm_freak> you may want to understand monads first
02:27:28 <osfameron> the tech behind barley is quite cute
02:27:39 <osfameron> I think the tutorials themselves are a bit wordy
02:30:52 <ader111> mm_freak: I do understand monnads. I guess I understand better now. Enumeratee acts on individual steps and not on the final result
02:38:02 <mm_freak> ader111: nothing acts on the final result
02:38:14 <mm_freak> it doesn't exist, until the iteratee is finished, and it cannot be manipulated
02:38:54 <mm_freak> every iteratee produces its own "final" result, and those individual results can be combined using the monadic interface
02:39:28 <mm_freak> like (>>=) or fmap, and there are also some iteratee-specific combinators, for which i don't have a proper adjective
02:39:46 <mm_freak> like (>>==) or (=$)
02:41:25 <ader111> mm_freak: ok thank you, can you point me to some of these combinators?
02:42:35 <exeter> question regarding io monad
02:42:48 <exeter> I have a line in a 'do' block which goes like this let artFolds = filter (isFolderArticle) foldCon'
02:43:04 <mm_freak> ader111: i recommend reading the enumerators tutorial in the yesod book
02:43:23 <exeter> and ghci complains because isFolderArticle has type string -> IO Bool and not string -> Bool
02:43:46 <mm_freak> ader111: http://www.yesodweb.com/book/enumerator
02:44:04 <exeter> how can I "bind" stuff in this case? I'd like to do something like let artFolds = filter ( <- isFolderArticle) foldCon' , but it is obviously incorrect
02:44:16 <mm_freak> exeter: use filterM in the Control.Monad module
02:44:18 <mm_freak> :t filterM
02:44:19 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
02:44:21 <exeter> is there a fromIO, like there is a fromJust?
02:44:26 <mm_freak> no
02:44:33 <shachaf> exeter: There is no fromIO, and there's also no fromJust.
02:45:02 <mm_freak> fromJust is not a total functions, and in general you'll want to avoid these things, too
02:45:03 <exeter> shachaf: wanna bet on the fromJust ? ;)
02:45:10 <mm_freak> e-s
02:45:37 <mm_freak> exeter: what shachaf is getting at is that fromJust is not total, and when programming haskell you should prefer total functions
02:45:38 <shachaf> exeter: fromJust doesn't exist if you know what's good for you.
02:45:56 <blackdog> osfameron: we just got a bus error :)
02:46:11 <shachaf> (Also, "IO" is a type, "Just" is a value constructor.)
02:46:16 <mm_freak> for some haskellers many of the nice properties of haskell break down, when you deliberately introduce bottoms to your code
02:46:30 <mm_freak> this is what fromJust does, when you get a Nothing
02:46:35 <mm_freak> > fromJust Nothing
02:46:36 <lambdabot>   *Exception: Maybe.fromJust: Nothing
02:46:44 <exeter> shachaf: hence, there's no fat in food
02:46:55 <exeter> thank mm_freak , I'll use that filterM
02:47:49 <mm_freak> exeter: from the name of your predicate i suspect that it may not need IO
02:48:03 <exeter> :i filterM
02:48:16 <exeter> mm_freak: do you need additional info / sigs ?
02:48:26 <ader111> thanks mm_freak
02:48:31 <mm_freak> exeter: import Control.Monad
02:48:54 <mm_freak> try to rewrite it without IO, so you can use the 'filter', but if it really depends on IO, you will need to use filterM
02:49:02 <exeter> no i mean, do you need additional info on what my code does, mm_freak ?
02:49:27 <shachaf> exeter: I think it's left as an exercise. :-)
02:49:49 <mm_freak> exeter: me?  no =)
02:49:55 <mm_freak> i only need types =)
02:49:59 <mm_freak> most of the time
02:50:14 <exeter> shachaf: are you referring to what mm_freak said?
02:50:37 <shachaf> I can't speak for mm_freak.
02:50:50 <shachaf> lambdabot can, though.
02:50:53 <shachaf> @quote mm_freak
02:50:53 <lambdabot> mm_freak says: explicit recursion should only be used if necessary
02:51:22 <exeter> I think it's left as an exercise. :-) <- what did you mean with that, shachaf ?
02:51:59 <shachaf> I mean that mm_freak was *probably* just suggesting that getting rid of IO as much as possible in your program was a good idea, and that you should figure out how to do it.
02:52:07 <exeter> oh sorry, I've missed the try to *rewrite it without IO, so you can use the 'filter', but if it really depends on IO, you will need to use filterM* line
02:52:41 <exeter> that's good advice, thanks
02:53:57 <mm_freak> shachaf: as much as possible?  no
02:54:05 <mm_freak> use IO where reasonable
02:54:13 <shachaf> Well, yes, OK.
02:54:16 <shachaf> You're not conal. :-)
02:54:34 <osfameron> blackdog: eeek!  bus error :-(
02:54:38 <exeter> define reasonable
02:54:43 <mm_freak> 90% of my code is monadic, and 50% of it includes IO somewhere in the transformer stack =)
02:55:12 <sipa> "and because i am subbord, the remaining 10% runs in the Identity monad!"
02:55:18 <mm_freak> exeter: in haskell speak, IO tackles the awkward squad, which includes mutable variables, concurrency, exceptions, etc.
02:55:27 <mm_freak> though strictly speaking for most of that you don't need IO
02:55:31 <mm_freak> you can have exceptions without IO
02:55:38 <exeter> :o
02:55:40 <exeter> can you?
02:55:44 <mm_freak> yes
02:55:45 * exeter is puzzled
02:55:47 <mm_freak> see the Either type
02:55:57 <shachaf> mm_freak: You should see what conal says about that. :-)
02:55:59 <exeter> oh, ye olde bigge Either
02:56:09 <mm_freak> > do x <- Right 3; y <- Right 4; z <- Left "error!"; return z
02:56:09 <lambdabot>   Overlapping instances for GHC.Base.Monad
02:56:09 <lambdabot>                              (Data...
02:56:10 <shachaf> exeter: Or Maybe, for that matter.
02:56:14 * exeter duly notes
02:56:15 <mm_freak> manâ€¦
02:56:25 <mm_freak> ok, see the Maybe type, which works in lambdabot =)
02:56:39 <mm_freak> > do x <- Just 3; y <- Just 4; z <- Nothing; return z
02:56:41 <lambdabot>   Nothing
02:57:05 <mm_freak> > do x <- Just 3; y <- Just 4; z <- Just (x+y); return z
02:57:06 <lambdabot>   Just 7
02:57:08 <mm_freak> that's a form of exceptions =)
02:57:41 <exeter> I am more used to C++ exceptions, as in try .... (somewhere above, way above) catch
02:57:49 <mm_freak> sure
02:58:01 <exeter> still, I bet I should try to do "good" haskell
02:58:07 <mm_freak> the 'maybe' function is your 'try' in this case
02:58:10 <mm_freak> :t maybe
02:58:11 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:58:29 <exeter> that seems reasonable!
02:58:30 <mm_freak> or rather fromMaybe
02:58:37 <mm_freak> :t fromMaybe
02:58:38 <lambdabot> forall a. a -> Maybe a -> a
02:58:46 <mm_freak> but in most cases 'maybe' is easier to work with
02:59:04 <mm_freak> :t maybe (putStrLn "failed") print (Just 3)
02:59:05 <lambdabot> IO ()
03:03:02 <exeter> watch out for doomsday, skeptical_p
03:08:40 <exeter> thanks again, I'll be raptured soon.
03:09:45 * hackagebot regex-genex 0.2.0 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.2.0 (AudreyTang)
03:28:07 <kstt> bos : like many people, I've been following your experiences with Riak. I've read from mailrank blog that you were heading to MySQL, with indicative figures to back this choice. I am now wondering why mySQL, and not (for example) postgresql. Any figures to share ? Thanks.
03:38:05 * hackagebot uuagc 0.9.38.1 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.38.1 (ArieMiddelkoop)
03:53:05 <ivanm> lispy suggested to me the other day that I should consider using a typeclass for wl-pprint-text so that it would also work for bytestring and String... what do other people think?  would it be worth doing something like that?
03:53:17 <ivanm> it would need either fundeps or TFs (preferably the latter)
03:54:05 <aleator> ivanm: Hmm.. Just a quick thought, if you do that, could it work with a html builder also?
03:54:49 <ivanm> aleator: my thinking is that it would need IsString to be able to define the int, double, etc. combinators
03:55:39 <aleator> ivanm: Ah. Then maybe not.
03:56:27 <ivanm> aleator: otherwise, they would need to be at the class level, which would be a pain
03:56:43 <ivanm> and would you really want to use a generic pretty-printing library for html?
03:57:06 <aleator> Yeah. Thought that that'd you meant at the class level.
03:57:14 * hackagebot waitfree 0.1.2 - A wrapping library for waitfree computation.  http://hackage.haskell.org/package/waitfree-0.1.2 (YoichiHirai)
03:58:09 <aleator> ivanm: Well, the idea was to pretty print into html or latex to get even fancier output. Don't know if it is anyway useful.
03:59:21 <ivanm> ahhh, so a pretty-printable version of Pandoc?
03:59:32 <ivanm> I've actually thought about that at one point...
03:59:43 <aleator> ivanm: Thats what I meant yes :)
04:00:07 <mm_freak> ivanm: i recently changed even my netlines library to use a type class, so it supports ByteString and Text (for now)â€¦  it really pays off
04:00:16 <mm_freak> i often found cases, where i would prefer Text over ByteString
04:00:19 <mm_freak> now i can use both
04:00:46 <mm_freak> it's not on hackage yet, though
04:00:51 <ivanm> about to say... ;-)
04:01:04 <ivanm> well, it wasn't what I was going to hack on tonight, but I suppose I can do so
04:01:06 <mm_freak> because i want to test it well, before i upload it
04:01:20 <ivanm> what module do you recommend? and what package name?
04:01:45 <ivanm> Text.PrettyPrint.Leijen.Class and wl-pprint-class ?
04:02:39 <mm_freak> ivanm: i structured my package this way:  NetLines, NetLines.Class, NetLines.IO and NetLines.Error (for exceptions)
04:03:01 <mm_freak> i don't think you need a separate package, unless the class will be useful for different packages
04:03:26 <ivanm> mm_freak: well, the package is currently wl-pprint-text... if it also works for String and ByteString, does the name really make sense?
04:03:44 <mm_freak> ivanm: no, in theory it should be wl-pprint ;)
04:03:54 <mm_freak> perhaps you should contact the original author and just generalize everything
04:04:00 <ivanm> hmmm..... anyone know who Otakar Smrz is?
04:04:10 <mm_freak> never heard
04:04:13 <ivanm> he seems to have uploaded a new version of wl-pprint last month ...
04:04:19 <ivanm> even though the original was by sorear
04:05:30 <ivanm> I have the sneaking suspicion that there _is_ no change...
04:05:36 <ivanm> just that someone hijacked the package :s
04:06:03 <ivanm> oh, apparently he added overlapping instances support
04:07:14 <dankna> so much for us all worrying vocally about the etiquette of doing that
04:07:18 <dankna> some people, apparently, are doing it anyway
04:07:39 <ivanm> diff says two lines are different that look the same :s
04:07:44 <dankna> whitespace
04:07:47 <dankna> try diff -w
04:07:58 <ivanm> ahhh, must be
04:08:00 <ivanm> yup
04:08:12 <ivanm> OK, all he's done is added overlappinginstances to the .cabal field
04:08:17 <ivanm> and set his name to be the maintainer
04:08:31 <ivanm> should I try to talk to him about this first? or just mail a rant to -cafe? :p
04:08:48 <dankna> just point it out to -cafe.  I wouldn't rant per se.
04:08:55 <ivanm> OH GREAT WISE ONES OF THE HASKELL! HEAR ME!
04:08:56 <ivanm> :p
04:09:01 <dankna> just note the issue and point out that we need a coherent policy on this because it's happening.
04:09:10 <ivanm> dankna: yes, but does _he_ read -cafe ?
04:09:12 <dankna> he didn't really do anything wrong, in that nobody told him not to do it
04:09:16 <ivanm> true
04:09:16 <dankna> well, you could Cc: him
04:09:19 <ivanm> yeah...
04:09:34 <ivanm> preflex: seen sorear
04:09:34 <preflex>  sorear was last seen on #haskell 179 days, 12 hours, 12 minutes and 45 seconds ago, saying: thanks
04:09:42 <ivanm> OK, can't really ask him... ;-)
04:09:45 <dankna> yeah
04:09:48 <ivanm> does sorear still use haskell?
04:10:03 <dankna> no idea who that is
04:10:10 <dankna> oh, original author of the package
04:10:11 <dankna> I don't know
04:11:15 <ivanm> OK, last mention of him I can find is his name in a release for xmonad-0.9 two years ago...
04:11:29 * dankna nods
04:14:38 <mm_freak> ivanm: just Cc both
04:14:58 <ivanm> sorear as well?
04:15:05 <mm_freak> he might be just a good friend of the original author, who picked up the package
04:15:09 <ivanm> I kinda guessed he'd moved on or something
04:15:14 <mm_freak> yeah, why not
04:16:26 <dankna> hmmmmmm
04:16:33 <dankna> deepseq is allocating lots of memory
04:16:36 <dankna> I suppose that makes sense
04:20:45 <mm_freak> dankna: try deepseq with [1..]
04:20:48 <mm_freak> ;)
04:20:53 <mm_freak> (no, don't do that)
04:21:37 <mm_freak> ((if you don't hit ^C timely, it will crash your system))
04:22:45 <dankna> mm_freak: yes I know lol
04:23:08 <dankna> > deepseq [1..] ()
04:23:08 <lambdabot>   Not in scope: `deepseq'
04:23:38 <mm_freak> > sort [1..]
04:23:39 <dankna> > let deepseq (item:rest) = seq item $ deepseq rest in deepseq [1..] ()
04:23:42 <lambdabot>   mueval-core: Time limit exceeded
04:23:42 <lambdabot>   mueval-core: Time limit exceeded
04:23:42 <aristid> can't the garbage collector immediately discard everything generated?
04:23:52 <mm_freak> aristid: no
04:24:09 <dankna> aristid: well, in the case of my program yes, it can and it does, but the time spent allocating - that is, finding available memory - is still substantial
04:24:19 <dankna> at least that's what I /think/ it's doing
04:24:33 <dankna> but I'm noticing that if I comment out all the actual work of my program, it still runs slow!
04:24:36 <aristid> mm_freak: there's no data dependency between [1..] and (), is there?
04:24:38 <mm_freak> aristid: it's precisely the point of seq/deepseq that the data is evaluated fully or to WHNF /before/ the dependent value is evaluated
04:24:43 <dankna> which is good in a sense, in that it means I can prepare a reduction, which is what I'm doing
04:24:57 <aristid> mm_freak: sure, but when it's evaluated it can immediately be garbage collected.
04:25:04 <dankna> sure, but it's infinite
04:25:06 <dankna> so it can't be evaluated
04:25:20 <aristid> dankna: the garbage collector does not need to wait for that
04:25:21 <mm_freak> aristid: yes, /after/ () is returned
04:25:29 <aristid> mm_freak: why only after?
04:25:37 <dankna> because it's referenced by the call to seq
04:25:38 <mm_freak> aristid: because that's the semantics of seq/deepseq
04:25:40 <dankna> it's not dead until seq is done
04:25:55 <mm_freak> aristid: that's why they exist
04:25:57 <aristid> seq says "what i look at is protected from the gc"?
04:26:02 <dankna> I see your point that being infinite doesn't prevent GC, but what does prevent GC is that it's referenced
04:26:11 <dankna> ANY function call says "what I look at is protected from the GC"
04:26:29 <dankna> as long as the function call itself is referenced from a root
04:26:43 <aristid> sounds like a bug in haskell :P
04:26:44 <mm_freak> aristid: seq artifically builds the dependence of its second argument on its first
04:26:58 <dankna> it's, um, ... not.  that's intended behavior.
04:27:10 <mm_freak> seq acts like its second argument needs the head of its first
04:27:11 <dankna> if you GC something that's still used, what do you do when you need its value later?
04:27:26 <mm_freak> deepseq acts like its second argument needs the entire value of its first argument
04:27:32 <mm_freak> so GC cannot take place
04:27:35 <ivanm> mm_freak, dankna: should libraries@ be CC'd as well do you think?
04:27:45 <mm_freak> it WOULD be a bug, if GC would take place ;)
04:27:45 <ivanm> (since a policy decision would also be useful)
04:27:47 <dankna> ivanm: hmmm....  probably, yes.
04:28:10 <mm_freak> ivanm: isn't -libraries for the haskell platform?
04:28:26 <ivanm> mm_freak: and for haskell', core libraries, etc.
04:28:28 <aristid> mm_freak: why not release the lock of the parts that are evaluated?
04:28:35 <ivanm> it also seems to be the one to set hackage policies and the like
04:29:31 <mm_freak> aristid: because they are still in use
04:29:44 <aristid> mm_freak: deepseq claims they are, but they aren't :)
04:29:47 <mm_freak> deepseq a b makes 'b' specifically request all of 'a'
04:29:52 <aristid> hmm
04:29:53 <mm_freak> yes
04:29:55 <mm_freak> that's the point
04:30:10 <mm_freak> deepseq changes language semantics
04:30:23 <mm_freak> normally 'a' wouldn't be evaluated at all
04:30:28 <mm_freak> unless 'b' really depends on parts of it
04:30:40 <mm_freak> deepseq artifically builds this dependence to force evaluation
04:30:52 <mm_freak> so a deepseq on [1..] will crash your system and GC cannot prevent that
04:31:08 <mm_freak> or at least crash the RTS with a heap overflow =)
04:31:08 <aristid> length [1..] `seq` () does not have this problem, does it?
04:33:43 <b930913> http://hpaste.org/47035/cabal_install_network_fail
04:35:20 <Lemmih> b930913: Not sure what the problem is but you could try the Haskell Platform.
04:35:38 <b930913> Lemmih: What's that?
04:35:56 <Lemmih> b930913: http://hackage.haskell.org/platform/
04:36:00 <dafis> b930913: closeFdWith is imported from GHC.Conc if MIN_VERSION_base(4,3,1); defined in Network.Socket if !MIN_VERSION_base(4,3,1); the MIN_VERSION macro your Cabal puts in there is broken
04:36:17 <Lemmih> b930913: "The Haskell Platform is the easiest way to get started with programming Haskell. It comes with all you need to get up and running."
04:36:32 <dcoutts> dafis, b930913: but you can woraround it using: if !(MIN_VERSION_base(4,3,1))
04:37:00 <dafis> dcoutts: tell that to the author of network :)
04:37:09 <dcoutts> tibbe: ^^ :-)
04:37:18 <b930913> I have a terminal in front of me, what do I punch in? :p
04:37:28 <dafis> b930913: newer cabal, older network, or hack the sources
04:37:55 <b930913> dafis: How do I do the middle suggestion?
04:38:14 <dafis> b930913: cabal install 'network < 2.2'
04:38:20 <mm_freak> aristid: no, it will just run forever =)
04:38:34 <dafis> I'm not sure, perhaps the 2.2 versions will work to
04:38:37 <dafis> *too
04:39:56 <ivanm> what do people think of http://hpaste.org/47036 (to make sure the tone is right before I email it)
04:39:57 <aristid> mm_freak: i think i had a wrong mental model of deepseq (for lists). i was thinking of it like seq . length, but with also the elements deepseq'ed
04:40:03 <ivanm> dankna, mm_freak: ^^
04:41:25 <b930913> dafis: http://hpaste.org/47037/cabal_install_network__22
04:42:11 <aristid> why does the MonadWriter class have a Monoid constraint on w? :(
04:42:15 <aristid> totally not necessary
04:42:38 <aristid> it suffices if the instances have that constraint, IMHO
04:42:43 <rostayob> Let's say I've got a language that permits me cast from a generic type to a monomorphic type, only if the thing i'm trying to cast is of that type. You have a function like cast :: a -> (b -> c) -> Maybe c, that casts a to b, applies the function and returns just if the thing provided can be casted. would that by type safe?
04:42:50 <ivanm> aristid: default method definition?
04:42:59 <aristid> ivanm: there are no default methods.
04:43:04 <dafis> b930913: smoething's wrong with encoding: invalid application of âsizeofâ
04:43:30 <dafis> b930913: I've no idea whether that's the problem or an output artefact, though
04:43:37 <aristid> ivanm: also, it prevents me from making a MonadWriter instance for my newtype ProductWriter p a = PW (Writer (Product p) a)
04:44:14 <b930913> dafis: What do I do then? :(
04:45:13 <aristid> rostayob: at least in haskell, casting from a generic type to a monomorphic type is not necessary, because you can just unify the type. like x :: MyMonomorphicType
04:46:20 <dafis> b930913: okay, just checked the source, 2.2.* don't have the closeFdWith problem, so try $ cabal install network-2.2.3.1
04:46:38 <rostayob> aristid: but let's say I've got a function :: a -> b, and I want to do something if a is a particular type, and something else if it isn't
04:46:59 <joe6> rostayob: check out agda?
04:47:09 <b930913> dafis: Running now.
04:47:10 <aristid> rostayob: i don't understand, sorry :)
04:47:59 <joe6> rostayob: agda allows you to send a type as a parameter.
04:48:07 <rostayob> aristid: ok let's put it this way: I have a collection like data Coll = forall a. Show a => Coll a
04:48:27 <rostayob> I can't do anything but "show" on those types
04:48:40 <aristid> rostayob: oh, maybe you want Typeable
04:48:58 <rostayob> aristid: even with typeable, you can't cast them back to monomorphic types, can't you?
04:49:06 <aristid> rostayob: i think you can :)
04:49:11 <aristid> @hoogle cast
04:49:13 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
04:49:13 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
04:49:13 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
04:49:15 <rostayob> joe6: yeah I just want to know why that is/is not type safe
04:49:23 <aristid> rostayob: the function is even called cast.
04:50:02 <rostayob> aristid: oh, wow. thanks.
04:51:09 <aristid> now, i have a question. if you have a function with a pretty long type. do you split that up into multiple lines?
04:51:43 <aristid> if so, how
04:51:46 <rostayob> aristid: yes! that was easy
04:51:50 <rostayob> the arrows on the new line
04:52:03 <aristid> it's just a style question :)
04:53:11 <joe6> rostayob: or, how about TemplateHaskell?
04:53:30 <rostayob> joe6: i think that templatehaskell is overkill here
04:53:59 <rostayob> also
04:54:07 <rostayob> you can't have any decision about the type at runtime
04:54:11 <rostayob> which is what you do with cast
04:54:38 <rostayob> so let's say a collection of somethings, and you do different things depending on which type the element you're expecting is
04:57:48 <ivanm> does Henning Gunther hang out here?
05:00:44 <poltak> What's the relationship between Haskell and GNU/Linux?
05:01:08 <ivanm> AFAIK there isn't one
05:01:14 <dafis> poltak: Haskell implementations tend to run on GNU/Linux
05:01:26 <ivanm> not in terms of Haskell as a language
05:01:35 <dafis> right
05:01:36 <MasseR> More in terms perhaps, haskell as a community
05:01:58 <ivanm> in terms of implementations, most (all?) assume a POSIX environment
05:01:59 <poltak> I'm talking history or maybe of users/programmer of Haskell
05:02:33 <ivanm> poltak: a lot of Haskell hackers do so under *nix
05:03:01 <ivanm> and as such tools and libraries tend to work better under GNU/Linux rather than Windows or OSX
05:03:25 <poltak> but OSX is *nix, yes?
05:03:33 <dafis> yees
05:03:40 <ivanm> supposedly
05:03:53 <hpc> for a very broad definition of yes
05:03:55 <dafis> but it's kind of wrapped, so it's not quite identical
05:03:57 <ivanm> but it does enough things differently such that GUIs, networking, etc. are all different
05:04:32 <ivanm> but in terms of "using the command line, $PATH, etc." I think it's the same from a Haskell perspective
05:05:11 <poltak> Yeah, it must be
05:05:41 <aristid> ivanm: networking? no BSD sockets? ;)
05:06:07 <ivanm> aristid: I thought I read something somewhere of needing to have a different networking stack than under Linux
05:06:23 <aristid> ivanm: the implementation is certainly different
05:06:34 <aristid> but i'm _pretty_ sure they have socket(3posix), too
05:06:38 <ivanm> as in languages needing different bindigns
05:06:40 <ivanm> *bindings
05:06:45 <ivanm> I'm quite possibly wrong however
05:06:52 <ivanm> networking isn't really something that interests me ;-)
05:07:04 <aristid> ivanm: huh? you can't really not do networking
05:07:12 <ivanm> oh, but even in terms of libraries: dynamic linking took longer to do for OSX than Linux
05:07:32 <ivanm> aristid: as in "I want a Haskell/Python/etc. library to do network stuff under OSX"
05:07:47 <aristid> ivanm: you never needed that? oO
05:08:02 <ivanm> I never needed to do any _programming_ involving networking
05:08:06 <dafis> aristid: what would one need that for?
05:08:11 <ivanm> I just use what's there for my own activities ;-)
05:08:21 <mm_freak> personally i find haskell hacking on windows very frustrating
05:08:32 <aristid> dafis: i don't know, random stuff. :)
05:08:50 <aristid> mm_freak: yet you do it?
05:08:56 <mm_freak> aristid: no
05:09:24 <mm_freak> but i had to do it in my last company, where i wanted to write some personal tools in haskell
05:09:31 <aristid> heh
05:09:47 <mm_freak> i ended up trying all sorts of functional languages for the purpose
05:10:07 <osfameron> mm_freak: F#!
05:10:37 <mm_freak> osfameron: F# is good as a language, but at the time it was not very mature (and i doubt it's now)
05:10:48 <mm_freak> and it didn't beat haskell for me
05:11:17 <osfameron> mm_freak: oh? I thought it was "supported", and it does at least have the .Net libraries (which I haven't used myself. But I believe they are supposed to be at the very least competent as a standard lib)
05:11:37 <mm_freak> likely never will, because F# tastes like the desparate trial to get haskell concepts into .NET
05:12:04 <mm_freak> osfameron: the .NET libs are object-oriented and rely largely on destructive update
05:13:04 <ivanm> osfameron: I think it was only late last year when F# was made "official"
05:13:50 <osfameron> ah.  I haven't followed it closely.  I went to a tutorial/overview talk on it, installed it, played with it for half an hour...
05:14:05 <aristid> osfameron: and went back to haskell? :)
05:14:31 <osfameron> tbh, mostly I did the same with haskell, and went back to Perl ;-)
05:14:38 <osfameron> but haskell is the FP lang I come back to when I have tuits
05:14:58 <aristid> hah.
05:16:09 * osfameron and FP-curious officemate are looking at doing a 1-day-a-week FP project though.  I'd like to spend some *real time* working on this stuff
05:16:50 <osfameron> possibly something to do with public transport planning (sounds thrilling, no? ;-)
05:17:47 <theorbtwo> Actually, it could be thrilling.
05:18:03 <osfameron> indeed
05:18:38 <Jafet> "Haskell â€“ no more bus errors."
05:18:46 <osfameron> heh
05:19:17 <osfameron> lots of opportunity for massive graph traversal things
05:19:21 <osfameron> which will be fun!
05:19:22 <theorbtwo> Exactly.
05:19:34 <osfameron> (last time I tried to do anything with graphs, my brains dribbled out of my ears, admittedly)
05:21:08 <mun> typically, if T is a logical theory and E is an extension of T. would it be right to say that "E is stronger than T"? is E stronger because it has a smaller set of models?
05:23:15 <dafis> mun: I'd agree with that
05:23:31 <tibbe> dcoutts, got an email about network
05:23:48 <dafis> tibbe: probably from me :)
05:23:53 <tibbe> dcoutts, I wish someone would send a patch so I don't have to spend time testing it on older configs
05:23:55 <mun> dafis, cool. thanks.
05:24:01 <tibbe> dafis, please provide patch :) thanks
05:24:16 <tibbe> dafis, otherwise I need to create a setup with an old cabal and test it
05:24:26 <tibbe> dafis, which means it will take longer before I get around to it
05:24:31 <dafis> tibbe: I don't have an old cabal either, sorry
05:24:36 <tibbe> :/
05:24:47 <tibbe> then I'll just do it and hope it work
05:25:02 <dcoutts> b930913: you were able to test it right?
05:25:14 <dafis> tibbe: at least it doesn't look like it could break anything
05:25:50 <b930913> dcoutts: I think it's working, I'll tell you soon.
05:26:13 <dcoutts> b930913: no, I mean you have the setup where it failed, so you'd be able to test a patch that fixes it
05:26:29 <dcoutts> I'm not talking about workarounds
05:26:46 <mm_freak> osfameron: interestingly i found haskell most useful for applications, where most people say that haskell is not very suitable
05:26:51 <tibbe> dafis, right
05:26:54 <mm_freak> networking, web applications, etc.
05:27:16 <b930913> dcoutts: The last command did the trick I think.
05:27:53 <dcoutts> b930913: you're missing the point, we're looking for someone to test a proper fix, rather than just trying to get it working on your particular machine
05:28:19 <b930913> dcoutts: You want me to test something for you?
05:28:24 <absence> http://stackoverflow.com/questions/2104446/how-do-you-use-control-applicative-to-write-cleaner-haskell <- i can't get the ifte' example without <$> mentioned in the comments to work (type mismatch). has the language changed, or is the suggestion simply wrong?
05:28:27 <osfameron> mm_freak: well, applications are the most useful thing in general ;-)
05:28:37 <dafis> b930913: yes, that'd be nice
05:28:40 <dcoutts> b930913: please, if you could work with dafis to test the fix he has in mind
05:28:43 <mm_freak> osfameron: yeah, but there are different kinds of applications
05:28:56 <osfameron> mm_freak: what kind do you mean?
05:29:10 <dcoutts> b930913: then the maintainer can apply the patch without having himself to test that particular configuration of versions of tools
05:29:17 <mm_freak> i'm judging from a practical viewpoint, when i say that haskell is not terribly useful for number crunching or user interfaces, contrary to what most people say
05:29:18 <b930913> No problem, however I do need to go out now. I'll be on later today (when I get back).
05:29:45 <mm_freak> but it's amazingly useful for developing networking programs, database stuff and web applications
05:30:15 <mm_freak> and i found that not many people realize this
05:30:51 <osfameron> mm_freak: interesting.  I have all too little experience in either, so really looking forward to getting more practical experience with it.
05:31:33 <hpc> mm_freak: elaborate how it isn't good for number crunching?
05:31:42 <osfameron> mm_freak: I guess graph processing counts as "number crunching" though - if you suggest that haskell might not be the most optimal for that kind of thing, what would you personally recommend instead for those tasks?
05:32:01 <aristid> hpc: lack of good libraries for that purpose, i guess?
05:32:08 <mm_freak> hpc: say "please" =)
05:32:32 <mm_freak> osfameron: i'm not saying it's not useful
05:33:23 <mm_freak> it's not /terribly/ useful though, because you'll find a lack of libraries, write more code in certain spots and also it is not the first choice for high performance number crunching
05:33:53 <mm_freak> on the other hand, your haskell program may well have long completed its calculation, while the C programmer is still debugging his C program
05:33:55 <aristid> mm_freak: given that some people use python for number crunching (admittedly not performance-critical stuff)...
05:34:23 <mm_freak> aristid: i don't count calculating the average of a list of numbers as number crunching =)
05:34:49 <aristid> mm_freak: :P
05:35:28 * hackagebot erf 1.0.0.1 - The error function, erf, and related functions.  http://hackage.haskell.org/package/erf-1.0.0.1 (LennartAugustsson)
05:36:24 <mm_freak> i tried to implement the quadratic sieve in haskell and it was a PITA to get the algorithms right, because most algorithm documentations present imperative pseudocodeâ€¦  you'll have to work out the functional approach yourself
05:36:25 <osfameron> I think I'm more interested in Haskell/Clojure, while officemate is interested in Scala/Erlang
05:36:31 <osfameron> should be some interesting crossover anyway
05:36:59 <mm_freak> (or just sacrifice elegance and performance, use ST and implement the imperative version, at which point you could just as well use an imperative language)
05:37:09 <quicksilver> osfameron: haskell and erlang are the most interesting ones out of those four.
05:37:27 <mm_freak> osfameron: erlang is strictly only useful for concurrent network applications
05:37:42 <mm_freak> i don't find erlang particularly interesting
05:37:47 <quicksilver> osfameron: Scala/Clojure are born out the desire to compromise. Fair enough, and they fill niches, but they're not terrible interesting for themselves.
05:37:55 <osfameron> quicksilver: well, Clojure is Lisp, which is hardly uninteresting ;-)  But you may be right.  Massive concurrency is quite exciting.
05:38:08 <quicksilver> osfameron: you didn't say lisp, you said clojure.
05:38:12 <osfameron> quicksilver: well, I say "Clojure" and I really mean "a lisp".
05:38:22 <quicksilver> fair enough ;)
05:38:26 <osfameron> quicksilver: perhaps because *I*'m interested in compromising (with good libraries etc.)
05:38:28 <mm_freak> osfameron: if you're interested in lisp, try racket
05:38:36 <mm_freak> it's a great, mature language
05:38:38 <osfameron> yeah, I think racket was my other option
05:38:42 <mm_freak> with a great, mature implementation
05:39:06 <mm_freak> of course none of those give you the design patterns you can use in haskell
05:39:52 <osfameron> mm_freak: racket has pattern matching, and didn't clojure implement laziness and monads, just to annoy haskellers, at some point?
05:41:33 <mm_freak> osfameron: a lot of languages implement some form of monads
05:41:52 <mm_freak> but monads are only the very basics, on which some design patterns in haskell are based
05:43:28 <mm_freak> osfameron: what you don't get in those languages is the concurrency concepts of haskell, iteratees, etc. expressed in a simple, concise syntax
05:43:50 <osfameron> mm_freak: this was one of the things I'd heard Clojure did especially well - the concurrency model
05:44:06 <mm_freak> osfameron: especially well /compared to haskell/?
05:44:18 <osfameron> mm_freak: heh, no idea
05:44:25 <mm_freak> or just "especially well"? ;)
05:44:27 <osfameron> when I've studied both, I'll let you know ;-)
05:44:34 * osfameron doesn't even know haskell concurrency
05:44:43 <mm_freak> C is "especially good" for low level stuff, but i found haskell still better in that area =)
05:44:47 <osfameron> (or really, even Perl's concurrency... particularly well...)
05:46:02 <mun> given that HOL is undecidable, why is provability in HOL is semi-decidable? or is it?
05:46:31 <ivanm> osfameron: you managed to miss all the "STM is slow/useless and you should just use locks!" blog posts? :o
05:47:10 <mm_freak> ivanm: who says that?
05:47:19 <ivanm> mm_freak: quite a few people
05:47:44 <ivanm> most recently it was re-raised on proggit when someone made a submission about TM (hardware though I think)
05:48:06 <mm_freak> ivanm: well, applications i've written for production would disprove thatâ€¦  unfortunately not many open source real world programs use STM
05:48:29 <ivanm> because not many open source real world programs written in haskell need concurrency?
05:48:41 <mm_freak> ivanm: no program ever needs it
05:49:02 <ivanm> OK, more in the sense of "would really benefit from" then
05:49:27 <mm_freak> ivanm: the more you use STM, the more use cases you find for it
05:49:47 <osfameron> ivanm: I don't get STM yet, I'll have to play with it.
05:49:54 <ivanm> mm_freak: most of the detractors are those that hate Haskell or only used STM in a language with a less powerful type system (and thus lost a large point of it)
05:49:59 <mm_freak> up to the point where you can't write a single useful program without it anymore =)
05:50:09 <ivanm> osfameron: I think SPJ's santa clause example is one of the best
05:50:16 <ivanm> mm_freak: O RLY?
05:50:35 <mm_freak> osfameron: get concurrency first
05:50:38 <ivanm> I suppose it depends on how you define "useful"....
05:50:40 <mm_freak> then learn STM
05:50:46 <osfameron> ivanm: I vaguely get the *idea* and it sounds great.  I had a look at a few introductory blogs, and got freaked out.  This was a while back, so I might be able to cope now, dunno
05:50:57 <ivanm> the program I'm writing atm wouldn't be considered useful by most ;-)
05:50:59 <mm_freak> ivanm: as in i'd use STM even in simple small command line utilities
05:51:05 <ivanm> mm_freak: :o
05:51:42 <mm_freak> ivanm: sometimes i need longer to force the application into the sequential nonconcurrent model than just write a few lines more to use STM
05:51:58 <mm_freak> and for larger applications (> 200 lines) i almost always use STM
05:52:30 <mm_freak> ivanm: what program?
05:53:00 <ivanm> code.haskell.org/~ivanm/dangd
05:53:24 <ivanm> the actual program bit isn't there yet, but all it does so far is basically (length .) . generateDangD
05:54:22 <osfameron> hmm, darcs repos aren't as nice to browse as github ones ;-P
05:54:52 <ivanm> osfameron: well, yes, but how do they compare to browsing git repos?
05:55:08 <ivanm> _not_ a web app around a git repo
05:55:10 <osfameron> ivanm: hehe, probably fairly well ;-)
05:55:14 <kakos> Someone should make a github for darcs
05:55:20 <ivanm> kakos: we already have two
05:55:25 * kakos has the perfect name for it too
05:55:26 <ivanm> and a third one that someone is considering releasing
05:55:31 <kakos> ivanm: What are they?
05:55:31 <ivanm> patch-tag.com and darcsden.net
05:55:40 <ivanm> but neither are under much development atm :(
05:55:53 <hpc> i know someone a while back suggested the name darcside.com
05:56:00 <kakos> Let's be honest.  It should be called darcside
05:56:03 * kakos owns that domain
05:56:54 <ivanm> kakos: well, it's obvious: you need to write it!
05:56:55 <ivanm> ;-)
05:57:21 <kakos> ivanm: I had planned on it, but this stupid little thing called a job seems to keep getting in the way
05:57:28 * kakos is now on day 17 without a day off
05:57:56 <ivanm> ahhh, the third possible one is codehole.org by john meacham
05:58:22 <kakos> That name is horrible
05:58:32 <kakos> It sounds like a sleezy gay bar for programmers.
05:58:33 <ivanm> yeah, that was pointed out
05:58:59 <int-e> it also sounds like a good way to lose your code.
06:00:16 <ivanm> int-e: which was the main objection pointed out
06:00:35 <osfameron> ;-)
06:02:20 <mm_freak> ivanm: ok, for pure computations STM is probably not that useful
06:02:29 <mm_freak> but on the other hand i don't do many pure computations
06:02:34 <ivanm> heh
06:02:46 <mm_freak> some parsing and other stream processing
06:02:55 <kakos> I guess my mind is just in the gutter.  ;)
06:02:57 <ivanm> down the track I may have a look at parallelising that, but yeah, concurrency probably not
06:03:05 <ivanm> kakos: you said it, not me! ;-)
06:03:09 <kakos> Everyone thinks of code loss, I think of seedy gay sex in a back alley.
06:03:29 <kluge> code...hole? :)
06:04:18 <mm_freak> kakos: don't worryâ€¦  with the yesod framework you'll have written it in a matter of two daysâ€¦  and two weeks more to get the interaction between nginx and your application right =P
06:04:53 * kakos should make a github-like site for repositories for Coq code and can call it coqhole.com
06:05:27 <kluge> codeholeforcoq.com
06:05:39 <kakos> deepcoqing.com
06:05:43 <kluge> or just holeforcoq.com
06:06:11 <kluge> coq.codehole.com
06:06:17 <aristid> mm_freak: setting up a reverse proxy is probably easiest
06:06:35 <dafis> tibbe: still around?
06:07:11 <osfameron> I suppose "codehole" is a better name than "codebin" or "codetoilet"
06:07:19 <osfameron> me++ # positive thinking
06:07:33 <kakos> Okay.  I'll stop dragging down the level of conversation in this room and let you guys get back to talking about Haskell
06:08:02 <mm_freak> aristid: you'll want to use fastcgi though
06:08:30 <aristid> mm_freak: what are the advantages?
06:08:48 <mm_freak> less network-bound
06:09:05 <mm_freak> it feels wrong to have web applications each take one port
06:09:29 <mm_freak> and fastcgi goes through sockets, so probably the resource usage is better
06:10:16 <tibbe> dafis, yes
06:11:28 <dafis> tibbe: just tested, got the 'ambiguous...' error with cabal-0.8.2 using Cabal-1.8.0.2 (but not when it was built against Cabal-1.8.0.6), worked with the parentheses
06:12:10 <tibbe> dafis, excellent, could you send me a patch against the stable branch on github.com/haskell/network ?
06:12:49 <dafis> tibbe: okay, will take a minute, though
06:13:07 <tibbe> dafis, thanks
06:14:06 <aristid> mm_freak: you mean fastcgi goes through unix sockets? because reverse proxy uses (tcp) sockets, too ;)
06:14:24 <aristid> mm_freak: i would like a unix socket reverse proxy :)
06:14:54 <dafis> tibbe: when you say 'stable branch', that's master in that repo?
06:15:17 <dafis> ('cause master is all 'git branch' reports)
06:16:10 <tibbe> dafis, there's a separate branch call stable in that repo
06:16:22 <tibbe> dafis, try git checkout -b stable origin/stable
06:16:46 <dafis> tibbe: okay, trying
06:17:17 <tibbe> dafis, thanks, let me know how it goes
06:17:26 <tibbe> I assume you did git clone <github url>
06:17:48 <dafis> tibbe: yes, did that, now checked out stable
06:18:04 <tibbe> dafis, git branch -r would list all remote branches
06:18:32 <dafis> tibbe: yes, that said origin/stable
06:19:47 <tibbe> dafis, that's it :)
06:20:29 <dafis> tibbe, aye, say, does it matter if the patch contains the removal of trailing whitespace (my editor does that automatically)
06:21:04 <scooty-puff> i was wondering if anyone could help with a constraint solver i'm working on
06:21:09 <develhevel> how to check if a string e.g. starts with _foo... i want to filter all strings like "_foo123" or "_fooSdfw"
06:21:22 <Ke> isPrefix oslt
06:21:30 <Twey> isPrefixOf
06:21:34 <luite>  /query lambdabot
06:21:36 <luite> oops
06:21:37 <Ke> @type filter
06:21:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:21:42 <Twey> > "_foo" `isPrefixOf` "_foobar"
06:21:43 <lambdabot>   True
06:21:52 <Twey> > isPrefixOf "_foo" "_foobar"
06:21:53 <lambdabot>   True
06:22:02 <scooty-puff> if anyone is interested in the code, its here: http://hpaste.org/47041/constraint_solver
06:22:25 <scooty-puff> i had to make an Expr data type - which annoys me
06:22:40 <scooty-puff> (vs. using list monad on its own)
06:22:41 <tibbe> dafis, that's OK
06:22:49 <mm_freak> aristid: that would be fastcgi =)
06:22:50 <Twey> > unwords . filter (not . isPrefixOf "_foo") $ words "_foobar _foobaz _fobquux"
06:22:54 <lambdabot>   mueval-core: Time limit exceeded
06:22:59 <Twey> x.x what
06:23:07 <mm_freak> aristid: sort of
06:23:08 <Twey> > unwords . filter (not . isPrefixOf "_foo") $ words "_foobar _foobaz _fobquux"
06:23:10 <lambdabot>   "_fobquux"
06:23:14 <aristid> mm_freak: well yeah. sort of :)
06:23:19 <Twey> Î»b is a sad robot today
06:25:26 <djahandarie> Î»âŠ¥
06:26:31 <Twey> Heh
06:26:39 <Twey> Nice
06:28:11 <scooty-puff> updated version: http://hpaste.org/47043/constraint_solver
06:30:55 <dafis> tibbe: patches mailed
06:34:10 <tibbe> dafis, thanks!
06:34:23 <dafis> tibbe: welcome
06:37:38 * hackagebot hsx 0.9.1 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code.  http://hackage.haskell.org/package/hsx-0.9.1 (NiklasBroberg)
06:38:39 <ivanm> I've always wondered what the point of hsx was...
06:40:03 <absence> http://stackoverflow.com/questions/2104446/how-do-you-use-control-applicative-to-write-cleaner-haskell <- i can't get the ifte' example without <$> mentioned in the comments to work (type mismatch). has the language changed, or is the suggestion simply wrong?
06:40:34 <Twey> I wish Hackage would let one use handles.  Requiring realnames is confusing if one is identified by a handle everywhere else.
06:41:02 <djahandarie> Just make up a fake realname based on your handle
06:41:14 <ivanm> Twey: that point has been raised before
06:41:16 <Twey> absence: Looks wrong, to me
06:41:22 <ivanm> and if you ask they sometimes make exceptions
06:41:32 <ben> Just make up a fake handle based on your realname
06:41:34 <Twey> ivanm: Oh, really?  I might try that, then
06:41:35 <ben> B)
06:41:36 <djahandarie> Twey Branwen
06:41:39 <Twey> Heh
06:41:47 <Twey> Ah, did gwern manage that?
06:41:54 <ivanm> I know gour did
06:43:02 <mm_freak> ivanm: well, its package description tells it, doesn't it?
06:43:22 <mm_freak> literal XML syntax in haskell source code
06:43:36 <Twey> The question wasn't what it does, but why it does it :Ã¾
06:43:45 <ivanm> but why would you _want_ literal XML syntax in Haskell source code? :/
06:43:54 <Twey> I'm coming around to Hamlet syntax, slowly
06:46:24 <mm_freak> ivanm: static checking, while using the familiar XML syntax
06:47:31 <mm_freak> as a drastic example you wouldn't want to write a (non-lisp) programming language as its syntax tree
06:47:55 <mm_freak> you'd rather prefer a compile-time parser, which results in that tree
06:48:52 <mm_freak> hamlet was a good exampleâ€¦  it's simplified, layout-based HTML, which is parsed at compile time and turned into a Html value
06:48:57 <Axman6> > logBase 2 40000000
06:48:57 <lambdabot>   25.25349666421154
06:49:31 * Axman6 has decided he doesn't like radix sort
06:49:46 <aristid> Axman6: why?
06:49:49 <ivanm> mm_freak: OK... I was thinking it was just actual Haskell code with some embedded XML in there for some reason :/
06:50:31 <Axman6> aristid: it feels sort of unnatural to make it run in parallel... it's more of a gut feeling though... :P
06:52:34 <mm_freak> ivanm: it probably is =)
06:53:51 <mm_freak> ivanm: well, it doesn't seem to be what its package description describes
06:54:07 <mm_freak> no quasiquotes or anything
06:54:45 <Twey> It's a preprocessor, isn't it?
06:55:24 <mm_freak> oh, ok
07:02:53 <lukesdyl> So, I was thinking about that language thing next year again.
07:02:59 <lukesdyl> And I thought of an interesting "concept" to try out.
07:03:37 <lukesdyl> Essentially, that *any* expression or sub-expression or well-formed (maybe even partial...?) piece of code
07:03:44 <lukesdyl> can be stored as a variable, passed to functions etc
07:03:53 <lukesdyl> essentially macroing, but a bit prettier and more inbuilt.
07:04:46 <lukesdyl> It would be an interesting interpreted language to write.
07:05:07 <aristid> lukesdyl: lisp?
07:05:13 <lukesdyl> aristid: But imperative.
07:05:18 <aristid> lisp is imperative.
07:05:30 <lukesdyl> Well... C-like, I should say
07:05:33 <lukesdyl> well, Python/Ruby-like actually.
07:06:05 <osfameron> aren't there functional variants of lisp? or at least of scheme?
07:06:27 <lukesdyl> It would be relatively interesting to enforce strong typing in this language too :|
07:06:49 <lukesdyl> If everything is an expression, and every expression has a type, it should be possible.
07:06:54 <aristid> osfameron: i think you can use any lisp in a functional way
07:07:10 <Twey> Someone hasn't tried using elisp
07:07:26 <lukesdyl> aristid: Any input/ideas though?
07:07:37 <mm_freak> lukesdyl: how is C different from CLisp?
07:07:44 <aristid> lukesdyl: other than: "look at lisp"? no.
07:07:45 <lukesdyl> mm_freak: No clue, haven't used CLisp.
07:07:53 <mm_freak> C is like a poor subset of CLisp
07:08:01 <mm_freak> (well, C is a poor subset of many languages)
07:08:09 <osfameron> aristid: yeah.  I think I read that Clojure pushes you more towards immutable datatypes than other lisps though, for example
07:08:13 <aristid> mm_freak: clisp, the common lisp interpreter?
07:08:21 <mm_freak> aristid: no, the language
07:08:28 <aristid> mm_freak: i.e. common lisp?
07:08:29 <Twey> >.<
07:08:38 <mm_freak> yes
07:08:42 <lukesdyl> aristid: Well, I'm trying to make something simple...
07:08:55 <aristid> lukesdyl: ?
07:09:02 <lukesdyl> aristid: The goal is not a fully-featured language
07:09:03 <Twey> osfameron: Clojure is the most functional Lisp I know of.
07:09:07 <lukesdyl> as much as a small project to try stuff in :)
07:09:11 <aristid> lukesdyl: then look at scheme.
07:09:17 <Twey> It's mostly immutable &c.
07:09:22 <lukesdyl> aristid: I have, I've read the first third of SICP
07:09:26 <lukesdyl> I'm meaning to finish in the summer.
07:09:33 <lukesdyl> But I go very slowly, since I insist on doing the exercises...
07:09:37 <lukesdyl> and I'm terrible at them...
07:09:42 <aristid> heh
07:09:51 <lukesdyl> I'm sure I'll get the mindset eventually.
07:09:51 <mm_freak> lukesdyl: ah, you want to create the languageâ€¦  in that case a strong C with a reasonable syntax is probably fine =)
07:09:54 <mm_freak> i.e. no C at all
07:10:07 <mm_freak> but rather strongly typed python without the OOP stuff =)
07:10:15 <lukesdyl> mm_freak: yeah, but maybe more rubyesque syntax.
07:10:21 <lukesdyl> But, that's pretty much what I was going for.
07:10:40 <lukesdyl> Maybe try pattern matching.
07:10:42 <lukesdyl> For fun :)
07:10:57 <lukesdyl> I'd use arrays, tuples, numbers, strings, and expressions
07:11:07 <lukesdyl> As I said, I'd make *any* expression a first-class citizen.
07:11:39 <lukesdyl> (to be evaluated lazily mind you!)
07:11:54 <lukesdyl> Probably use back ticks for it.
07:12:38 <lukesdyl> also, adopt ruby's policy of everything being an expression (and drop the need for 'return')
07:16:52 <scooty-puff> it looks like its built via function compositions,  but are the Data.Binary.Builder Builder's append and put operations lazy?
07:21:17 <luite> dcoutts:
07:21:18 <luite> oops
07:22:14 <mm_freak> lukesdyl: rubyesque syntax will certainly make me refrain from using it =P
07:22:22 <lukesdyl> mm_freak: which aspects?
07:23:54 <lukesdyl> I want to remove as many {} and begin/end type things though, since they aren't conducive to "capturing" expressions or sets of expressions.
07:24:21 <lukesdyl> ruby sans the 'end' keyword, or python sans ':' would be accurate.
07:24:35 <develhevel> when i have a function like foo = do putStrLn "hi" and now i make a signature with: foo :: IO () is this right?
07:25:07 <tromp> yes, but you can leave out the do
07:25:55 <lukesdyl> tromp: I wouldn't even have a do/end keyword... I'm not using blocks...
07:25:58 <lukesdyl> or objects for that matter...
07:25:59 <develhevel> tromp: i know in my real function there are more expressions
07:26:06 <lukesdyl> Oh, you mean his,
07:26:08 <lukesdyl> oops.
07:26:08 <lukesdyl> :P
07:26:23 <lukesdyl> develhevel: The type of a monadic function is the type of the _last_ command.
07:26:40 <lukesdyl> so if your last command is `return 10`
07:26:47 <lukesdyl> I'm pretty sure it'd be IO Integer, not IO ()
07:27:01 <develhevel> ok
07:27:16 <lukesdyl> Often it's best to just like GHC infer the type :)
07:28:36 <luite> dcoutts: I'm trying to build the sha2 package, which requires some preprocessor options to build the C file. the .cabal file uses cpp-options for this, but these are only used when building haskell files: http://hpaste.org/47051/sha_fails_to_build
07:28:45 <luite> dcoutts: is this a bug, or what is the correct way to do this?
07:29:20 <mm_freak> lukesdyl: all of them
07:29:37 <lukesdyl> mm_freak: ?
07:29:47 <lukesdyl> >_>
07:29:47 <mm_freak> i like clean syntax, so either layout-based or lisp-like
07:30:00 <mm_freak> but that's a personal preference
07:30:01 <lukesdyl> I mean, it will be layout-based like python...
07:30:07 <lukesdyl> but, I just want minimal syntax, relying only on keywords
07:30:14 <lukesdyl> So, now : or {}, etc
07:30:16 <lukesdyl> no*
07:30:25 <mm_freak> keywords are syntax, too
07:30:44 <lukesdyl> non-keyword syntax. thats just unhelpful pedantry.
07:32:08 <mm_freak> it's not pedantry, i just don't understand what your goals areâ€¦  perhaps sample source code would help
07:34:01 <luite> dcoutts: it has the same behaviour on linux
07:34:18 <develhevel> how to delete all "" from a [String]?
07:36:07 <aristid> develhevel: all empty strings?
07:36:15 <aristid> filter (not . null)
07:36:27 <aristid> > filter (not . null) ["foo","","bar"]
07:36:29 <lambdabot>   ["foo","bar"]
07:37:53 <develhevel> aristid: yes, thx
07:51:09 <develhevel> does somebody know HXT here? i get a attribute value with:getAttrValue "foo" is it possible to get two attribut values?
07:52:45 <Axman6> sure, just use the function twice...?
07:53:26 <develhevel> yes but so i must run a whole new xml parse
07:53:52 <Axman6> eh? really?
07:54:00 <Axman6> that sounds highly unlikely...
07:55:04 <dcoutts> luite: cpp-options is cpp options for Haskell code. cc-options are for the C compiler when compiling C code.
07:55:41 <dcoutts> luite: so if that package is using cpp-options and intends them to be used for C code, then it's doing it wrong
07:58:47 <erus`> z buffer doesnt work on my g45 express intel :(
07:59:01 <erus`> im not sure if its a haskell thing or a everything opengl thing
08:00:51 <mrd> develhevel: time to learn how to combine XML parsers?
08:01:14 <mrd> develhevel: it's arrows .. getAttrValue "foo" &&& getAttrValue "bar"
08:01:40 <develhevel> mrd: did you know a good place to learn more about this?
08:01:56 <aristid> does anybody actually like hxt?
08:02:05 <mrd> I use it when I deal with xml
08:02:26 <mrd> develhevel: http://haskell.org/haskellwiki/Arrows
08:02:29 <aristid> mrd: use /= like
08:02:41 <mrd> develhevel: http://haskell.org/haskellwiki/HXT
08:02:47 <mrd> aristid: well in this case, I also like it
08:02:57 <mrd> I just hate XML
08:03:27 <aristid> i can't stand the arrows
08:03:29 <luite> dcoutts: right, thanks. I'll mail the author
08:03:45 <dcoutts> luite: I wonder how it ever worked for the author
08:04:01 <develhevel> mrd: you made my day :) thx
08:04:12 <luite> dcoutts: the problem is that it compiles fine without the preprocessor options on linux :)
08:04:20 <dcoutts> luite: ah
08:05:22 <aristid> i think there are no really nice xml libraries for haskell yet. but xml-enumerator is supposed to become a lot better soon, or so i am told.
08:05:31 <luite> dcoutts: is there some page where all .cabal file options are described? I googled a bit, but couldn't find one
08:05:44 <b930913> dafis: I'm back.
08:06:00 <mrd> aristid: what's wrong with arrows?
08:06:03 <dcoutts> luite: the user-guide, linked from the cabal homepage
08:06:16 <mrd> develhevel: hmm, you should check out that wiki more often :)
08:06:26 <aristid> mrd: arr alone gives me the shudders
08:06:38 <dcoutts> luite: btw, what did you google for? I'm rewriting the user guide now so I'll see if I can include the right keywords :-)
08:06:51 <dafis> b930913: okay, but we've already tested it otherwise, so we don't need to bother you, except, to verify, could you tell me what cabal --version outputs?
08:06:57 <aristid> mrd: also, they lack the infrastructure that monads have
08:07:14 <aristid> mrd: if you look at hxt, you'll see that the arrows are actually kleisli arrows
08:07:46 <b930913> dafis: v 0.8.0 using v 1.8.0.2
08:07:53 <aristid> @hackage xml-monad
08:07:53 <lambdabot> http://hackage.haskell.org/package/xml-monad
08:07:58 <aristid> (shameless plug :D)
08:08:55 <mrd> aristid: the infrastructure meaning what?
08:09:20 <dafis> b930913: thanks, I used 0.8.2 using v 1.8.0.2, the macro worked with 1.8.0.6, so it was fixed some time between those
08:09:22 <aristid> :t replicateM
08:09:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:09:28 <luite> dcoutts: ah right, found it. I searched for cabal package options, cabal file format. I did find the user's guide, but expected that to be in some reference section at the end, so I did click on the "cabal file format" section, but not on the "Package descriptions" one
08:09:29 <aristid> :t guard
08:09:30 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:09:52 <aristid> mrd: stuff like that. there are TONS of Monad combinators.
08:10:19 <b930913> dafis: Ok, new question. "Not in scope"? :p
08:10:33 <dafis> b930913: what's not in scope?
08:10:43 <develhevel> need some functions in haskell: 1. a function which cut the string off when it find a special char e.g. "hi(test)" the char would be ( so i want only "hi"
08:10:48 <b930913> dafis: hPrintf and printf
08:10:53 <aristid> :t break
08:10:54 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:11:05 <develhevel> aristid: thx
08:11:07 <aristid> :t span
08:11:08 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:11:10 <dafis> b930913: import Text.Printf ?
08:11:19 <mrd> dunno, never felt a shortage of arrow combinators.  sometimes i have to look a little to find them though.  type sigs work nicely.
08:11:24 <monochrom> "not in scope": you haven't imported some modules or defined something yourself
08:11:43 <monochrom> example:
08:11:47 <b930913> Ah.
08:11:47 <monochrom> > f4
08:11:48 <lambdabot>   Not in scope: `f4'
08:11:49 <b930913> I see it.
08:11:53 <dcoutts> luite: the current organisation of the user guide it pretty bad
08:12:12 * b930913 is silly :p
08:12:16 <b930913> Thanks guys.
08:17:54 <dankna> http://hpaste.org/47046/hmmmmm -- this appears to be allocating 32 bytes on the heap per pass through the loop
08:18:13 <dankna> I reduced this from a much larger program, where it was apparently the dominant cost although I am not totally sure of that
08:18:47 <dankna> mapM_ (...) [1..1000000] was even worse, presumably due to the space used for the list itself
08:19:36 <b930913> Couldn't match expected type `IO a0'
08:19:38 <b930913>                 with actual type `String -> IO ()'
08:19:53 <dankna> b930913: you forgot a parameter, of type String
08:20:00 <Axman6> dankna: what happens when you make $ $!?
08:20:02 <Botje> dankna: you could try making loop's argument strict
08:20:09 <dankna> Axman6: no obvious change
08:20:14 <dankna> Botie: no obvious change for that either
08:20:19 <monochrom> when it can't match "X" with "Y->Z", you have parameter mismatch
08:20:20 <dankna> *Botje
08:20:30 <luite> dcoutts: I also searched for cpp-options, but that seems to be undocumented
08:20:44 <Axman6> dankna: it might not actually be allocating anything. that sounds about the size of an Int
08:20:48 <mrd> develhevel: http://haskell.org/haskellwiki/HXT/Practical
08:21:00 <b930913> dankna: I can't see why.
08:21:04 <Botje> dankna: are you sure it's using Ints and not Integers?
08:21:15 <dankna> that's a thought, I'll add a signature, one sec
08:21:27 <Axman6> yeah, that was my next suggestion
08:21:40 <Axman6> shouldn't allocate anything then
08:22:01 <dafis> dankna: let loop :: Int -> IO (); loop 100000000 = return (); loop i = loop (i+1)
08:22:05 <dcoutts> luite: so it is, I'll have to do a thorough check when I get to rewriting that bit, there's probably others
08:22:50 <develhevel> is there a method for a triple to get the first? i know for (a,a) fst gives the first
08:23:14 <dafis> develhevel: you have to write your own
08:23:23 <develhevel> dafis: okay
08:24:38 <dankna> whoa!  adding the signature made it use constant space!
08:24:42 <dankna> very interesting
08:24:52 <dafis> dankna: only to be expected (if -O)
08:24:54 <dankna> unfortunately my real program doesn't have a counter so I'll have to figure out how that's applicable
08:25:03 <dankna> yeah, I'm using -O2 actually
08:25:17 <dafis> dankna: implies -O :)
08:25:35 <dankna> yes indeed :)
08:25:52 <dafis> dankna: what's the thing in the real programme?
08:26:02 <monochrom> each Integer has to allocate something, understandably
08:26:12 <dankna> in the real program I believe it's just MyMonad ()
08:26:21 <dafis> dankna: looping via forM_ (or mapM_) ?
08:26:24 <dankna> oh, no, wait, it does pass some accumulator arguments
08:26:37 <dankna> looping via explicit tail recursion as here - I wasn't familiar with forM_
08:26:43 <dankna> :t forM_
08:26:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
08:26:54 <Botje> weird that it's 32 bytes.
08:26:57 <Axman6> forM_ = flip mapM_
08:27:04 <dankna> yes, that is bizarre
08:27:05 <Botje> Integer has a data constructor for a strict int
08:27:15 <dankna> I'm on 64-bit so each pointer is 8 bytes
08:27:20 <dankna> so somehow it's 4 pointers
08:27:50 <monochrom> just add "default (Int)"
08:27:59 <Botje> a tagged pointer (constructor) + an 8-bit int
08:28:03 <Botje> that leaves two other pointers :P
08:28:04 <dankna> (I only showed the numbers for one run of the program, but it's definitely usage proportionate to the number of iterations and it's definitely 32 bytes per iteration)
08:28:31 <dankna> monochrom: well, the default is probably good to do in general, but as I say the real program isn't using a counter, so.
08:28:40 <Botje> * 64-bit int, of course
08:29:26 <dankna> perhaps the representation of an Intger is as a list of Ints?  then we'd have the Integer constructor, the [] constructor, the datum itself, and ... hm
08:29:30 <dankna> well, anyway, doesn't matter
08:29:52 <dafis> dankna: integer-gmp or integer-simple?
08:30:03 <dankna> whichever is the default in HEAD - I believe that's integer-gmp
08:30:16 <dafis> that's gmp
08:30:20 <dafis> @src Integer
08:30:20 <lambdabot> data Integer = S# Int#
08:30:20 <lambdabot>              | J# Int# ByteArray#
08:30:37 <monochrom> you're within the S# case
08:30:45 <dankna> yeah
08:31:09 <dafis> right, nevertheless, ghc doesn't make it run in registers
08:31:30 <dafis> it doesn't know that you'll never leave the S# range here
08:31:45 <dankna> right
08:32:00 <dafis> so you have to allocate a new S# Int# in each iteration
08:32:44 <develhevel> mrd: one question left with XML, do you know it i can make &&& twice and get a (a,b,c) when i make it i get (a,(b,c))
08:32:58 <monochrom> a thunk for "loopCounter+1" is momentarily allocated, though it is forced promptly
08:33:08 <dafis> exactly
08:33:48 <dafis> while with Int, ghc runs it as Int# in registers, no allocation, primitive machine ops
08:34:51 <monochrom> I wonder what if you "loop $! loopCounter + 1" (and still use Integer)
08:35:41 <dankna> monochrom: I tested that case earlier, it still allocated the same rate
08:36:44 <dafis> monochrom: with optimisations, ghc inserts the ! there
08:38:00 <monochrom> the cores are different
08:38:01 <dafis> the thing is that Integers can't be unboxed, hence you necessarily get allocation, even though it's very short-lived data here
08:38:20 <dafis> monochrom: oh ?
08:39:22 <dankna> yeah - and what I had found was that, as far as I can tell, the expense of the allocation itself, ie finding some free memory to use, is significant
08:39:40 <monochrom> "main3 (plus x y)" vs "case plus x y of blah { __DEFAULT -> main3 blah }"
08:40:02 <monochrom> although both still allocate a thunk
08:41:41 <dafis> monochrom: note that the case is superfluous here, since plusInteger is strict
08:45:50 <dcoutts> jystic: ping
08:56:01 <shapr> Ok, hackage is now reaching the point where it makes more sense to click on Packages and have a search box popup.
08:56:21 <NihilistDandy> lol
08:56:26 <dankna> I like the big list.  It lets me, um, search.... by hand.... wait.... never mind  :)
08:56:42 <djahandarie> shapr, it already does
08:56:49 <djahandarie> shapr, just with the big list also
08:56:52 <monochrom> there is a search box. just not popup. popup is evil anyway
08:57:02 <shapr> djahandarie: Except, it doesn't work right with https-everywhere or my google settings, not sure which.
08:57:03 <dankna> well, yeah, it shouldn't be popup but that's not the main point
08:57:03 <Twey> Heheh.
08:57:21 <djahandarie> shapr, Hackage 2.0 has a built-in search
08:57:28 <djahandarie> But it seems like no one is interested in pushing that live
08:57:33 * shapr pushes
08:57:51 <dmedvinsky> push harder, dammit!
08:57:56 * shapr pushes HARDER!
08:58:08 <shapr> privyet dmedvinsky! kak dela?
08:58:33 <thoughtpolice> i am sad about that. GHC itself seems to be only gaining in # of people who hack on it, yet cabal and related infrastructure hackers are few and far inbetween
08:58:50 <djahandarie> Yeah.
08:58:53 <dcoutts> thoughtpolice: I do get some contributions
08:58:58 <thoughtpolice> i guess people in the haskell community enjoy compilers more than they do build systems/infrastructure work :/
08:58:59 <NihilistDandy> Infrastructure's hard, I guess
08:59:01 <dmedvinsky> shapr: privet :-)
08:59:09 <dcoutts> but not enough to e.g. cover the new hackage-server
08:59:16 <dcoutts> we need more people looking at that
08:59:21 <shapr> dcoutts: What's needed for new hackage-server?
08:59:22 <thoughtpolice> dcoutts: yeah, i've been thinking about hackage-server a lot the past week.
08:59:47 <dcoutts> shapr: people to get it from where it is to deployable
08:59:52 <dmedvinsky> shapr: do I know you?
08:59:52 <dcoutts> it's 90% done
09:00:05 <thoughtpolice> dcoutts: so much work, and people were happy during the gsoc, but then suddenly nobody cared it seems. of course that's not true - hackage-server is regularly brought up all the time (and was recently highly mentioned in -cafe,) it's just nobody is pushing it hard atm
09:00:12 <shapr> dmedvinsky: no, but you should, because I'm awesome.
09:00:17 <thoughtpolice> dcoutts: so the only thing left to do is the remaining 90%?
09:00:17 <mm_freak> shapr: given that all packages are on hackage, you can use the modern browser's search function =)
09:00:19 <shapr> dmedvinsky: Hi, I'm Shae Erisson! Who are you?
09:00:23 <dcoutts> thoughtpolice: right :-)
09:00:37 <shapr> dmedvinsky: I'm also modest.
09:00:50 <mm_freak> firefox has a particularly convenient one (though sometimes i wish it would support regex or at least keywords)
09:00:54 <djahandarie> I still have a sketch for a new Hackage design too, but that's probably a seperate challenge
09:00:59 <dcoutts> thoughtpolice: yes, Gracenotes is busy with school and there are higher priorities that people complain about in cabal, so I've been working on those.
09:01:09 <dcoutts> thoughtpolice: really needs more people
09:01:20 <dmedvinsky> shapr: he-he, I'm Dmitry Medivnsky, nice to meet you :-)
09:01:29 <thoughtpolice> dcoutts: which is fair enough. hackage certainly isn't broken for everyone right now, so it's not surprising there are other priorities
09:01:32 <dmedvinsky> s/Medivnsky/Medvinsky
09:01:34 <shapr> dmedvinsky: Nice to meet you too! Do you write lots of Haskell?
09:01:36 <thoughtpolice> dcoutts: very much agreed!
09:01:48 <inode> hi
09:01:52 <dmedvinsky> shapr: nope, just began learning it
09:01:56 <djahandarie> thoughtpolice, implying cabal is broken for everyone? :p
09:02:01 <inode> I'm a beginner in haskell : ]
09:02:04 <dcoutts> thoughtpolice, shapr: so it's basically a case of taking what we have, trying it out, trying the mirroring code, running it on your own box, mirroring from hackage, bashing it a bit etc
09:02:15 <shapr> dcoutts: find/fix bugs?
09:02:36 <dcoutts> shapr: right, and we know what most of them are even
09:02:49 <shapr> trac.hackage.haskell.org ?
09:03:02 <shapr> dcoutts: Where are the known bugs collected?
09:03:08 <dcoutts> shapr: #hackage and ask me and Gracenotes
09:03:13 <shapr> ok
09:03:38 <dcoutts> http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0
09:03:54 <dcoutts> shapr: there's a TODO list there too ^^
09:03:55 <shapr> dcoutts: ah, excellent
09:03:56 <shapr> thanks!
09:04:07 <dcoutts> though the canonical one is in my and Gracenotes's heads :-)
09:05:01 <dcoutts> shapr: top priority is finishing reliable mirroring so you can start using it locally
09:05:26 <dcoutts> there's some nearly-completed new mirroring code
09:08:03 <b930913> If I have a string, say "asdf 004 fdas dafasd asdfasdf ...." how do I pull the second space delimited value?
09:08:24 <mm_freak> > words "abc def ghi" !! 1
09:08:24 <lambdabot>   "def"
09:08:24 <monochrom> > words "asdf 004 fdas dafasd asdfasdf"
09:08:25 <lambdabot>   ["asdf","004","fdas","dafasd","asdfasdf"]
09:09:08 <b930913> I take it it's 0 based then :p
09:09:08 <mm_freak> lambdabot could use the 'last result' feature of some command line calculators
09:09:12 <b930913> Thanks.
09:09:36 <mm_freak> in PARI/GP you can write "1 + %" to add 1 to the last result
09:10:26 <aristid> mm_freak: in ghci it's "it" iirc
09:10:54 <b930913> > words "abc 004 ghi asdf" !! 1
09:10:55 <lambdabot>   "004"
09:10:59 <monochrom> > it
09:11:00 <lambdabot>   Not in scope: `it'
09:16:44 <b930913> Erm, this is probably a silly question, but how do I compare if two values are equal?
09:16:58 <b930913> Double equals?
09:17:04 <monochrom> yeah, ==
09:17:36 <monochrom> not all types support comparing
09:18:02 <b930913> I dare say the triple equals operator exists too?
09:18:15 <monochrom> no, there is none
09:18:32 <dmedvinsky> you can also use compare function
09:18:50 <dmedvinsky> > compare 1 2
09:18:51 <lambdabot>   LT
09:19:16 <gio123> A relation R on lambda terms is compatible if R(M,M') implies R(ZM,ZM') and R(MZ,M'Z) and R(lambda x M,lambda x M').
09:19:18 <gio123> if a relation R is compatible, its reflexive and transitive closure will be compatible?
09:22:59 <mm_freak> aristid: indeed
09:23:05 <mm_freak> that's very helpful, thanks!
09:23:06 <applicative> > let (===) = foldr in (+) === 0 $ [1..10]
09:23:07 <lambdabot>   55
09:23:34 <Jafet> > 0 === ""
09:23:35 <lambdabot>   False
09:24:27 <applicative> oh there is a (===)?
09:24:35 <mm_freak> @undef
09:24:38 <mm_freak> :t (===)
09:24:39 <lambdabot> Not in scope: `==='
09:24:42 <mm_freak> no ;)
09:24:47 <applicative> ha
09:24:56 <jdavis> I am trying to read bytestrings, is there a way to read ints in LE/BE form, or are they always native?
09:25:05 <jdavis> (using Data.Binary right now)
09:25:59 <mm_freak> jdavis: reading little endian is fairly straightforward with the Data.ByteString module
09:26:14 <mm_freak> 'unpack' will give you a list of Word8
09:26:48 <jdavis> mm_freak: ok, looking back at that module now.
09:27:17 <mm_freak> Data.Binary likely has something ready-made, though
09:28:37 <jdavis> mm_freak: I'm missing how to explicitly read in LE mode with a bytestring (I'm using the lazy version)
09:29:29 <jdavis> mm_freak: or big endian
09:30:53 <Favonia> > (===)
09:30:53 <fragamus> i want to know if i can tighten my code
09:30:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a1 -> a -> GHC.Bool.Bool)
09:30:54 <lambdabot>    arisi...
09:30:58 <mm_freak> > sum . zipWith (*) (iterate (*256) 1) $ [1,1]
09:30:59 <lambdabot>   257
09:31:02 <fragamus> i want to learn
09:31:04 <mm_freak> @ jdavis
09:31:05 <fragamus> http://hpaste.org/47053/schmove
09:31:08 <mm_freak> if you have to do it manually
09:31:19 <Favonia> lambdabot: who taught you (===) ?
09:31:20 <mm_freak> first unpack, the map a fromIntegral
09:31:27 <matthew-_> you know ErrorT, well is there a version which is automatically ErrorT of Identity monad and which you don't need to call runErrorT on ?
09:31:30 <fragamus> is there a tighter way of expressing this ^^^
09:31:38 <Favonia> lambdabot: OK you failed the Turing test :P
09:31:38 <Jafet> > [0 === False, "" === False, 42 === True, 0.0 === [()]] -- second attempt
09:31:40 <lambdabot>   [True,True,True,False]
09:31:56 <mm_freak> > sum . zipWith (*) (iterate (*256) 1) . map fromIntegral $ [1, 1 :: Word8] :: Integer
09:31:58 <lambdabot>   257
09:32:21 <mm_freak> jdavis: and if you need BE, then just reverse the bytestring before unpacking it#
09:32:32 <jdavis> mm_freak: I'll have to look that stuff up. I'm still learning haskell. That looks like a good start.
09:32:49 <jdavis> mm_freak: BE and LE are not just reversing the bytestrings though.
09:33:38 <mm_freak> jdavis: well, assuming that the "endian" is a byte
09:33:52 <mm_freak> but yeah, i've seen some very strange architectures
09:38:41 <jdavis> mm_freak: LE and BE are well-defined, and you can't get one from the other just by reversing the bytes (or reversing chunks of K bytes). It's more like this (probably I'm making a mistake, too, but it's something like this): if it's 8 bytes, then swap the first 4 bytes with the last 4 bytes; if it's 4 bytes or more, then for each 4-byte chunk, swap the first 2 bytes of with the last 2 bytes; if it's 2 bytes or more, then for each 2-by
09:38:41 <jdavis> te chunk, swap the first byte with the last byte.
09:39:35 <mm_freak> jdavis: in that case, you'll need to write the conversion function from BE to LE
09:41:03 <cmatheson> i'm reading "learn you a haskell for great good" right now... i don't really get the point of function composition.  why compose functions rather than just chaining them together?
09:41:22 <copumpkin> chaining them together?
09:41:25 <jdavis> mm_freak: Hmm... OK. I can't imagine I'm the first one -- such conversions are pretty much required for networking.
09:41:46 <mauke> cmatheson: because there are other things you can do with functions besides calling them
09:41:55 <monochrom> "map (f . g) xs" would you rather write "map (\x -> f (g x)) xs"?
09:42:13 <mauke> .oO( f . g . xs )
09:42:37 <monochrom> see also my http://www.vex.net/~trebla/weblog/pointfree.html
09:43:27 <monochrom> anyway you will see its benefit when you really need it. until then, you will stay unconvinced
09:44:02 <cmatheson> mauke: monochrom: thanks, i will read your post.  the specific example i was looking at was unwords . map reverse . words $ "hey there man" (vs unwords $ map reverse $ words $ "hey there man")
09:44:18 <monochrom> indeed people also said "why internet, why not just send paper mail" until they were hooked up and addicted
09:44:49 <mm_freak> jdavis: you could use the FFI to get the stdlib functions
09:45:04 <jdavis> mm_freak: ok, I might have to do that. Thanks.
09:45:05 <cmatheson> ok, i'm not trying to argue it's not needed, the utility just wasn't immediately apparent to me
09:45:35 <Jafet> It lets you save $$
09:45:56 <mm_freak> jdavis: you may be faster by just writing that function yourself
09:48:09 <haja> Hi. Is anybody here to help me get along with gtk2hs and glade? I'm trying to use actions, but when using libglade as project format in glade 3.8.0 it doesn't allow me to. Similar problem for TextView and TextBuffer, although functionality to use these things is present in gtk2hs. Is there any way of using these widgets when using glade? Or does a different version of glade provide these widgets for libglade project format?
09:48:46 <dcoutts> haja: you could try using the new gtkbuilder format rather than the old libglade format
09:49:40 <haja> dcoutts: yes, but then i get a parser error when trying to load the file with xmlGetWidget complaining about the <interface> tag
09:50:11 <haja> dcoutts: ah, sry, i mean xmlNew "pathToGladeFile"
09:50:13 <dcoutts> haja: you have to use the Builder module rather than the Glade module
09:50:31 <dcoutts> the api is essentially the same though
09:50:36 <haja> dcoutts: ah, ok. haven't thought about that :)
09:51:14 <haja> dcoutts: thank you, you saved my day :)
09:54:10 <mm_freak> is the ListLike package the preferred class package for list-like datastructures?
09:54:19 <fragamus> im trying to learn haskell and i want my code to be very well written. can you guys look at this and make suggestions:
09:54:22 <fragamus> http://hpaste.org/47053/schmove
09:54:32 <copumpkin> mm_freak: I'd say Foldable should be called ListLike :P
09:55:18 <dcoutts> haja: :-)
09:55:34 <mm_freak> copumpkin: i need explicit support for 'take' and the like
09:55:44 <mm_freak> copumpkin: and i should add: efficient ;)
09:56:18 <byorgey> fragamus: a few suggestions:
09:56:59 <byorgey> fragamus: first, do-blocks support standalone 'let x = foo' statements, so you can get rid of the "in do" after the let and line up the following two lines right underneath the let
09:57:15 <byorgey> do { let x = y; blah } is just syntactic sugar for  let x = y in do { blah }
09:57:44 <fragamus> cool, i didnt know that
09:57:56 <byorgey> fragamus: another suggestion is to make an instance of Random for whatever type Hit, Split, Stand are from
09:58:18 <byorgey> fragamus: then instead of generating a random number and using it to choose one you can just directly generate Hit, Split, or Stand randomly
09:58:32 <fragamus> interesting
09:58:37 <mm_freak> is there any agda-like language, which is easy to combine with haskell?  i'd like to write my main program in haskell, but fragments of it in the other language
09:58:41 <byorgey> assuming those are the only three values from that type of course
09:58:49 <fragamus> yes
09:58:49 <copumpkin> mm_freak: only agda, sorry
09:58:52 <mm_freak> "agda-like" means: supporting dependent types at least
09:59:05 <dankna> okay, so
09:59:06 <mm_freak> copumpkin: i found idris
09:59:11 <dankna> http://dankna.com/himitsu/emulator.prof.txt http://hpaste.org/47055/some_relevant_definitions
09:59:17 <mm_freak> but it seems not very mature yet
09:59:22 <Jafet> fragamus: I can't parse your code without any context
09:59:35 <byorgey> fragamus: it's common practice to import qualified Data.Map as M, so you can write M.insert, M.lookup and so on, a bit more concise than writing out Data.Map.lookup etc.
09:59:40 <dankna> still slow :( adding type signatures didn't help; the issue with inadvertently using Integer that we identified in here a few hours ago doesn't apply to the real code
09:59:46 <djahandarie> himitsu?
09:59:50 <mm_freak> copumpkin: also "only agda" is only half-true, because it seemed difficult to me to combine haskell and agda
10:00:03 <dankna> himitsu is Japanese for "secret"; that directory is non-listable, so it's where I put stuff that I want to share only with a limited audience
10:00:04 <copumpkin> difficult
10:00:11 <mrd> haja: use gtkbuilder
10:00:19 <djahandarie> dankna, æ—¥æœ¬èªžã‚’è©±ã—ã¾ã™ã‹ï¼Ÿ
10:00:46 <dankna> wow, my IRC client displayed that correctly.  I can't read the kanji after the "wo" though.  and no, I don't speak Japanese, but I fake it.
10:00:56 <fragamus> sweet, this is the kind of stuff i need to learn
10:01:24 <djahandarie> It's ã¯ãªã—ã¾ã™. And okay :(
10:01:37 <dankna> ah, gotcha
10:01:51 <haja> mrd: thanks, dcoutts already explained it to me :)
10:01:58 <mrd> haja: yea i see :)
10:01:59 <gio123> ã¯ãªã—ã¾ã™.
10:02:09 <dankna> that's one of the words I actually remember, because I know that it doesn't mean "do flowers" like you'd think :)
10:02:20 <fragamus> thank you byorgey, i really need to learn to write very well written haskell
10:02:20 <djahandarie> ãŠãŠã€ã“ã‚“ã«ã¡ã¯gio123ã•ã‚“
10:02:22 <Twey> Haha
10:02:31 <Twey> èŠ±ã—ã¾ã™
10:02:40 <gio123> ã¯ãªã—ã¾ã™.
10:03:01 <mm_freak> intSqrt âˆˆ âˆ€a. (â„¤ a) â‡’ a â†’ a
10:03:14 <djahandarie> ãˆã£ã¨â€¦
10:04:34 <dankna> so yeah.  I talked a lot with various people in here about why this code is slow, and we couldn't figure it out
10:04:47 <dankna> but then I tried reducing the problem by making the get* and put* accessors actually be nops
10:04:55 <dankna> and ... it was still slow and allocation-heavy!
10:05:09 <dankna> so I concluded that the expense is not in actually doing the real work of it, but in some silly overhead thing
10:05:11 <shapr> o hai synesthesia
10:05:29 <shapr> synesthesia: how's code?
10:07:11 <dankna> that being the case, I imagine that the performance problem is caused by one or more of the snippets in that paste
10:07:15 <dankna> but damned if I see it :/
10:07:38 <ozataman> has anybody implemented a sorting algorithm that works with Repa arrays?
10:07:41 <dankna> the biggest offender is the runMonadicState' newtype accessor
10:07:45 <dankna> which is bizzare
10:09:30 <dankna> am I correct in thinking that the only way an accessor can be allocating is by forcing the value it accesses?
10:09:47 <dankna> but the value is just a function!  so it should be precomputed
10:10:31 <Jafet> It could be a thunk that evaluates to a function...?
10:10:39 * Jafet guesses without context
10:10:45 <dankna> hmm
10:10:59 <dankna> well, actually the accessor is used by the definition of >>= in my newtype monad
10:11:07 <dankna> so on every line
10:11:16 <dankna> but even so it should be precomputed, shouldn't it?
10:12:02 * Jafet clicks to acquire context
10:12:15 <Runar> @hoogle (b -> Either (a, b) a) -> b -> [a]
10:12:16 <lambdabot> No results found
10:12:17 <dankna> I can paste more of the code if you need to see it
10:12:22 <dankna> and thanks in advance
10:12:50 <Jafet> Well, it has pretty layout.
10:12:55 <dankna> haha yes
10:13:10 <dankna> I didn't lay that out, that massive type signature was created by Template Haskell
10:14:10 * hackagebot hbro 0.2 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.2 (koral)
10:15:43 <Runar> is there an unfold where the resulting list is never empty?
10:16:12 <Runar> Like, unfoldr1
10:16:24 <fragamus> byorgey: I have incorporated all your suggestions except the one about the random generator instance; i need more info on how to do that
10:16:41 <Twey> Runar: What's the use of that?
10:16:59 <Twey> You'd need typesafe non-empty lists for that to be of any use
10:17:03 <Jafet> dankna: what about thunks of runMonadicState's?
10:17:06 <Twey> Which we lack in the standard libraries, annoyingly
10:17:22 <k0ral> anyone's got a code sample of using dbus in haskell ?
10:17:52 <dankna> Jafet: hmm, you think I should change it to runMonadicState (MonadicState !action) = action ?
10:18:18 <dankna> or would that not address the concern?
10:18:26 <Jafet> I don't know that syntax...
10:18:35 <dankna> oh, that just makes it strict in that argument
10:18:49 <Jafet> Well, runMonadicState' is a function, so it gives you a thunk every time you use it
10:19:02 <Jafet> I'm guessing you have to force the result in some way
10:19:15 <Jafet> Without seeing your code, I can't say
10:19:49 <dankna> hmm, I can show you the definition of >>= ?  that's the main place where it's used
10:20:17 <dankna> http://hpaste.org/paste/47055/some_relevant_definitions_ann#p47056
10:21:48 <Jafet> That looks potentially thunky
10:21:55 <dankna> yeah, hmm
10:22:27 <dankna> I note that it's quite similar to the definitions of several monads in widely-used libraries
10:22:33 <dankna> not that that proves anything
10:23:04 <b930913> How do I drop text after a character (e.g. strip the local part out of an email by dropping all after the at sign.)?
10:23:38 <Runar> Twey: I'm copying a structure which is nonempty, into a list.
10:23:42 <dankna> > find '@' "dankna@example.com"
10:23:43 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
10:23:44 <lambdabot>         against inferred ...
10:23:49 <dankna> > elemIndex '@' "dankna@example.com"
10:23:51 <lambdabot>   Just 6
10:24:06 <dankna> > drop 7 "dankna@example.com"
10:24:06 <lambdabot>   "example.com"
10:24:15 <dankna> gluing those together is left as an exercise for the reader
10:24:15 <mauke> > takeWhile ('@' /=) "dankna@example.com"
10:24:16 <lambdabot>   "dankna"
10:24:24 <Jafet> :t span -- b930913
10:24:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:24:50 <dafis> dankna: I suspect that runMonadicState's cost is because it's the top level invocation that finally forces thunks accumulated earlier
10:24:57 <hpc> :t takeWhile
10:24:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:25:03 <dankna> dafis: hmm, yeah, that would make sense
10:25:13 <dankna> dafis: okay, so I want to not have those thunks in the first place, presumably, right?
10:25:18 <hpc> > takeWhile (/= 5) [1..10]
10:25:18 <lambdabot>   [1,2,3,4]
10:25:31 <b930913> mauke: Thanks.
10:25:41 <dafis> dankna: presumably you don't
10:25:56 <b930913> dankna: Local part is the bit before the @ :)
10:26:02 <dankna> b930913: oh :)
10:26:08 <Jafet> > tail.snd $ span ('@'/=) "highlight@dankna"
10:26:10 <lambdabot>   "dankna"
10:26:24 <dankna> dafis: sorry, not sure which sense you mean that in
10:26:50 <dafis> dankna: presumably you don't want the thunks to accumulate in the first place
10:26:57 <dankna> ah, yeah.
10:27:03 <mauke> safeTail = drop 1
10:27:15 <dankna> I wish there were a way to get the profiler to spit out what the thunks actually were
10:27:28 <dankna> since they have very short lifetimes, they don't appear in the heap profile graph
10:27:39 <medfly> gio123: hi dude
10:27:57 <medfly> gio123: stop hitting on Cale and ask your questions in here
10:28:00 <dankna> it's probably a safe assumption, though, that they're the lambdas created by >>=
10:28:06 <Jafet> The el cheapo thunk tracer is to pipe trace through wc -l
10:28:26 <dankna> you mean put trace on every line of the program?  heh
10:28:28 <Jafet> If the number drops greatly, your optimization was correct
10:28:45 <Jafet> No, at where your thunks were being created.
10:28:56 <dankna> hm
10:28:58 <dafis> dankna: perhaps profiling -hc or -hy indicates something
10:29:08 <gio123> medfly: are u crazy? i did not hitted cale I asked my question already here
10:29:31 <medfly> hit on
10:29:50 <medfly> okay Cale, he only hits on you after he tried everyone else in the channel
10:29:52 <dankna> dafis: tried it extensively.  it does not.  the vast majority of this data (1.2G of it) is garbage as soon as it's created, and therefore doesn't show up in the heap profile.  the heap profile shows constant usage of 3M.
10:29:53 <medfly> heh
10:30:03 <dankna> or at least I think that's why it doesn't show up
10:30:27 <dankna> (why do I care then?  because, as far as I can tell, the cost of the allocation itself is significant)
10:30:59 <Jafet> It could be the existential typing; I don't know how that's implemented
10:31:12 <dafis> dankna: sure, it's not free, but ghc allocates rather cheaply
10:31:13 <ClaudiusMaximus> woohoo, my tiling code seems to work :)  http://hpaste.org/paste/46996/tilings_annotation#p47057
10:31:15 <gio123> medfly: wtf do u want?
10:31:30 <medfly> nothing, I'm just being random
10:31:41 <medfly> and implying that you repeatedly asking him questions in PM is you hitting on him :p
10:31:50 <dankna> Jafet: it could be the existential typing, yes, but I think the experiment I tried where I made the monad turn everything into nops rules that out
10:32:05 <gio123> medfly: I am not!!!
10:32:29 <dankna> dafis: well, it's also possible that the time is merely in the same cost-center as the allocation and not caused by it
10:33:00 <dankna> dafis: but either way, I need to make those cost centers (enumerated in the profiling output that I pasted above) perform better, heh
10:33:32 <dafis> dankna: have you an actual performance problem, btw, or are we just poking around because maybe it could be better?
10:33:47 <dankna> oh, yes, this needs to run in 1/60th of a second and currently it takes 11 seconds
10:34:01 <dafis> dankna: that's a real problem
10:34:04 <dankna> it is, heh
10:34:55 <Jafet> @faq can Haskell emulate the NES?
10:34:55 <dankna> it's really not doing /that/ much computation; in C it would probably be fine.  but of course, in C it would have taken me ten times as long to write, and I wouldn't have assurances from the type system that I did it properly :)
10:34:56 <lambdabot> The answer is: Yes! Haskell can do that.
10:35:35 <zenzike> does anybody know if it's possible to do "reflection" on record syntax? ie, I'd like to have a way of getting to the string that's used in a record definition. Maybe template Haskell does this kind of thing: any pointers would be welcome :-)
10:35:37 <luite> is there some haskell parser that can be used to modify the module name of a .hs file, keeping the original file layout intact?
10:35:44 <mm_freak> i'm reading that in the category of sets the empty set is an initial objectâ€¦  what is that unique morphism, which maps from the empty set to any other set?
10:35:57 <dafis> mm_freak: the empty map
10:36:09 <mm_freak> i see
10:36:11 <dankna> zenzike: read the TH haddock and wiki docks, yes, that's the only way to do it
10:37:11 <zenzike> dankna: thanks, I didn't want to go on a wild goose chase unless necessary :-)
10:37:14 <mm_freak> and every singleton set is a terminal objectâ€¦  i would find multiple functions from â„• an to {x}
10:37:19 <dankna> zenzike: np
10:37:21 <mm_freak> 0 â†¦ x, 1 â†¦ x, etc.
10:38:05 <dafis> mm_freak: the function needs to be total, so there's only (const x)
10:38:49 <mm_freak> dafis: d'oh, understood
10:38:50 <mm_freak> thanks
10:39:15 <fragamus> OMG I didnt know lambdabot could do that
10:39:38 <dankna> @faq can lambdabot do that?
10:39:38 <lambdabot> The answer is: Yes! Haskell can do that.
10:39:40 <fragamus> @faq can Haskell emulate the NES?
10:39:41 <lambdabot> The answer is: Yes! Haskell can do that.
10:40:14 <Jafet> @vixen can you do that?
10:40:15 <lambdabot> i sure can
10:40:34 <fragamus> lol
10:40:43 <dafis> dankna: in getAtInstructionStart, after the first test, if that gives True, you always do internalOverflow <- getInternalOverflow, even if that isn't needed because the first condition in the second test is False, that might build unnecessary thunks
10:41:05 <dankna> dafis: hmm, yes.  I was wondering why that function cost so much.  fixing that.
10:41:20 <rudyl> is there a library function for extracting the nth element from a list or do I have to use a combo of take and tail?
10:41:21 <dafis> dankna: can you try !internalOverflow <- getInternalOverflow?
10:41:30 <dafis> or rearrange
10:41:41 <dankna> yeah, can do that, trying now
10:41:43 <dafis> rudyl: (!!)
10:41:44 <dankna> was going to rearrange
10:41:51 <dafis> > [0 .. ] !! 100
10:41:52 <lambdabot>   100
10:42:03 <rudyl> dafis: thanks :)
10:44:13 <KitB> http://hpaste.org/47058/lazy_io_trouble
10:44:21 <KitB> Why is this being wrong?
10:45:08 <KitB> (It won't putStr "$ " until I type a line)
10:45:18 <dafis> KitB: buffering
10:45:43 <dafis> KitB: either hFlush stdout, or hSetBuffering stdout NoBuffering
10:45:57 <dafis> both need import system.IO
10:45:59 <Zao> Nothing lazy about that IO, anyway.
10:46:04 <dafis> System.IO*
10:46:29 <monochrom> equivalently, unix-style I/O is lazy
10:46:51 <dankna> dafis: tested that; no great impact.
10:47:03 <dafis> pity
10:47:10 <dankna> yeah, it was a nice thought
10:47:21 <dankna> maybe if I put seqs everywhere in the definition of >>=
10:47:32 <dafis> dankna: but it had some impact? What did it change?
10:48:01 <iskren> is it possible to define a class, whose only purpose is to 'inherit' several other classes. Like I want something to stand for Eq, Show and Ord at the same time
10:48:05 <dankna> well, it knocked a percent off of the cost of that function, from 16% to 15% timewise and from 2% to 1% allocation-wise
10:48:54 <dafis> dankna: that's some impact regarding allocation, a good start
10:48:55 <dankna> iskren: class (Eq a, Show a, Ord a) => ESO a where
10:48:59 <dankna> dafis: true!
10:49:14 <iskren> dankna, thanks!
10:49:52 <monochrom> you can omit "where" too
10:49:53 <dafis> dankna: if you strictify in gamestateFrameForward, does that help?
10:50:05 <iskren> dankna, is there a good place to read all options of the type system, because I'm rather new to haskell and am trying to implement something non-trivial
10:50:19 <dankna> iskren: the Haskell Language Report, yes
10:50:21 <tg_> haskell 2010 report
10:50:23 <monochrom> "A class declaration with no where part may be useful for combining a collection of classes into a larger one that inherits all of the class methods in the original ones. For example:  class  (Read a, Show a) => Textual a"
10:50:26 <dankna> but it's not easy for the beginner
10:50:35 <tg_> for type *classes*, byorgey's "typeclassopedia"
10:50:58 <dankna> dafis: probably not, I'm pretty sure I tried that at some point (I've been trying various things to optimize this for about two weeks now)
10:54:09 <dafis> dankna: any chance I could try tweaking it myself, or is it too secret?
10:54:31 <dankna> dafis: it's not that it's too secret, so much as the build system is Mac-specific
10:54:45 <dafis> dankna: oh, no dice then
10:55:13 <dankna> dafis: although you can /build/ the library portion of it on any platform, but not run it.  depending on how much effort you expect to put into it, it might be worth my while to make a portable no-graphics front-end though.)
10:55:25 <dankna> hm
10:55:34 <dankna> my IRC client has scrolled up and now I can't scroll it back down
10:56:07 <dankna> oh, no, wait, it does pass some accumulator arguments
10:56:28 <Eduard_Munteanu> dankna: oh... any results with the curried form of the records?
10:56:33 <Eduard_Munteanu> Did it improve anything?
10:56:53 <fragamus> hey eduard
10:57:09 <fragamus> im refining my code, im so happy
10:57:50 <fragamus> i need to refine and refine until it is professional grade
10:59:08 <dankna> there we go
10:59:13 <dankna> sorry.  my connection dropped for some reason.
10:59:45 <siracusa> That question already occured some days ago here, but no one answered it: Why is it necessary to have a Show instance to define an instance for Num? It seems none of the class functions really needs Show.
10:59:49 <dankna> dafis: as I was trying to say before I d/ced, depending on how much time you think you're willing to spend on it, it might be worth my while to make a portable no-graphics front end.
11:00:16 <monochrom> a committee decided to make Show a prerequisite for Num
11:00:31 <dafis> dankna: I'm not sure, how much effort/time would it take to put up a portable frontend?
11:00:47 <dankna> I dunno, half an hour?
11:00:54 <Eduard_Munteanu> Did converting your state to curried form do any good to performance?
11:00:57 <dankna> maybe less
11:01:14 <dafis> dankna: then go ahead, I'm definitely prepared to poke aroumd more than that :)
11:01:31 <dafis> dankna: any exotic dependencies?
11:01:42 <dankna> Eduard_Munteanu: oh, thanks for asking!   it did not, oddly.  but then I tried an experiment where I turned all the accessors into nops (lobotomizing the program) and it still had heavy allocation!
11:01:58 <dankna> Eduard_Munteanu: so now my operating theory is that there's some stupid overhead cost, that the computation that's "interesting" is not the main cost at all
11:02:08 <Eduard_Munteanu> Hrm.
11:02:28 <uylephanthai> hi, i started haskell today, but when I try to make a function that returns the last element of a list, "findLast (_ ++ [x]) = x", it won't compile. How is this an ambiguous pattern? :o
11:02:31 <dankna> dafis: nope, no weird dependencies; array and bytestring and the like.
11:02:40 <fragamus> http://hpaste.org/47061/fragamus_monad
11:02:42 <dafis> dankna: cool
11:02:46 <dankna> dafis: okay, I'll get started on doing that as soon as I've finished this one experiment on it with strictness, and get back to you :)
11:03:02 <Eduard_Munteanu> uylephanthai: you can only pattern match on constructors, not operator/function application
11:03:03 <siracusa> monochrom: Do you know of a reason for deciding so?
11:03:10 <dafis> dankna: fine
11:03:16 <fragamus> im trying to write very professional code here ^^^
11:03:16 * hackagebot iteratee 0.8.4.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.4.0 (JohnLato)
11:03:18 <monochrom> no
11:03:28 <fragamus> please help me refine it
11:03:34 <Eduard_Munteanu> uylephanthai: so (x:xs) is okay, while ++ isn't
11:04:10 <uylephanthai> Eduard: ok, thanks. but is there no way around it apart from doing a recursion?
11:04:49 <Eduard_Munteanu> uylephanthai: you'll have to go through the whole list anyway
11:05:46 <monochrom> if you wonder why Eq is required for Num, I know how it's used: "fib 1 = 1" the pattern matching is translated to ==. but I don't know about Show. perhaps someone decided that a number that cannot be spoken is not a true number.
11:05:46 <Eduard_Munteanu> uylephanthai: if you want something with fast access to both ends then you need to use something like Seq from Data.Sequence
11:06:09 <uylephanthai> Eduard_Munteanu: ok, thank you for the help. i will look into that
11:06:36 <monochrom> or perhaps someone got tired writing "(Show a, Num a) => ..." all the time
11:06:48 <fragamus> http://hpaste.org/47061/fragamus_monad
11:06:52 <dankna> The Tao that can be seen / is not the true Tao, until / you bring fresh toner
11:07:52 <Eduard_Munteanu> uylephanthai: if you  want to get the last element of a list in particular, and write the function yourself, you have to recurse until the last element...
11:08:27 <Eduard_Munteanu> The useful case is... f [x] = x
11:09:01 <Eduard_Munteanu> The rest merely handle recursion (and failure in case the list is empty)
11:11:10 <rostayob> I was thinking that it would be nice to have haddock declarations comments integrated in ghci, so you could do :help function, a la pytho
11:11:12 <rostayob> n
11:13:13 <tswett> Now, with Haskell's FFI, calls from Haskell to C are about as fast as native Haskell, but calls from C to Haskell are much slower than native C, right?
11:13:31 <notyy> cabal update very very slow,  can some one give it a try? I don't know whether it's my ISP's problem or not
11:14:55 <monochrom> 19 seconds here
11:14:55 <dafis> notyy: just did, just the normal slowness
11:15:02 <hpc> tswett: afaik, you initialize the runtime once, then C->hs calls are fast
11:15:02 <dafis> 23 seconds here
11:15:15 <notyy> thank you
11:16:22 * tswett nods.
11:17:14 <fragamus> http://hpaste.org/47061/fragamus_monad
11:17:35 <fragamus> can anyone tell me how to tighten this even more
11:18:12 <dafis> fragamus: mymap <- gets fst
11:19:20 <dafis> fragamus: at the end, modify (\(_,fitness) -> (newMap,fitness))
11:19:45 <Saizan> rostayob: you can get something approximating that with hoogle
11:19:57 <fragamus> cool
11:20:03 <dafis> fragamus: where newMap = M.insert cards (moves !! r) mymap on a previous line
11:21:10 <dafis> fragamus: and instead of calling schmove again, just return the value you inserted into the map
11:22:02 <fragamus> cool
11:22:14 <fragamus> anything else?
11:22:43 <dafis> fragamus: use newtypes and datatypes instead of type aliases more
11:23:12 <dafis> data Creature = Creature{ moves :: MoveMap, fitness :: Fitness }
11:23:19 <dafis> for example
11:23:51 <dafis> newtype Crads = Crads [Int]
11:23:56 <dafis> Cards*
11:26:11 <rostayob> Saizan: yeah I know, but it would be nice anyway, and it's not a change that would be difficult to implement, or that would break something
11:26:23 <rostayob> apart from the fact the haddock comment are meant to be rendered in html
11:28:07 <Saizan> rostayob: well, ghc doesn't keep that info anywhere for compiled code, while hoogle has it in its database
11:29:20 <Saizan> e.g. hoogle --info sum
11:29:47 <rostayob> Saizan: yeah but hoogle works just with indexed packages
11:30:08 <rostayob> I was just thinking that it would be useful to just be able to browse modules like that
11:31:11 <monochrom> you can raise fund to pay people to do it. I am willing to do it for cdn$5000
11:31:35 <shapr> I'll do it for kr$5000
11:32:04 <shapr> Note that's SEK, not Icelandic kronor!
11:32:20 * hackagebot tilings 0.1 - substitution tilings  http://hackage.haskell.org/package/tilings-0.1 (ClaudeHeilandAllen)
11:32:50 <rostayob> haha
11:33:00 <rostayob> I was just coding in python and it's a nice thing to have, that's all
11:33:30 <shapr> rostayob: That would be awesome, I agree.
11:35:30 <rostayob> shapr: so I'm not the only one! eheh
11:36:00 <shapr> rostayob: but I don't know how that could work
11:36:15 <shapr> rostayob: oh wait! You want GHCI-on-Acid
11:36:24 <iskren> can you have cyclical dependencies between modules?
11:36:49 <shapr> rostayob: xerox aka Paolo integrated several of lambdabot's plugins into ghci
11:36:50 <shapr> iskren: Yes, but you'll need an hs-boot file.
11:37:23 <iskren> shapr, should I use a special build tool or?
11:37:54 <shapr> Nah, it'll work fine as long as you use a file Module.hs-boot where it gets cyclic.
11:37:58 * shapr digs foc docs
11:38:10 <shapr> iskren: http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/separate-compilation.html
11:38:19 <shapr> iskren: search for hs-boot in that page
11:38:37 <sully> does haskell have disjunctive patterns?
11:38:42 <monochrom> no
11:39:57 <iskren> shapr, thanks
11:42:23 <Eduard_Munteanu> Disjunctive as in matching either of two patterns?
11:44:27 <Eduard_Munteanu> Oh, found something.
11:44:52 <Eduard_Munteanu> What would be nice is let blocks that extend over multiple cases.
11:45:12 <Eduard_Munteanu> That would avoid repetition.
11:46:04 <Eduard_Munteanu> (and unnecessary globals)
11:51:44 <conal> disjunctive patterns are pretty sweet. i don't know why we don't have them.
11:51:45 <conal> i
11:51:45 <conal>  thi
11:51:45 <conal> nk
11:51:47 <conal> oops
11:52:03 <conal> i think it was chris okasaki who proposed them for ml.
11:52:08 <burp> has anyone a ghc build for openbsd/macppc? (maybe I'm lucky; or I should ask on the mailing list)
11:52:23 <dankna> those are two different architectures; are you asking about both of them?
11:52:49 <conal> dankna: it's a disjunctive pattern.
11:53:12 <byorgey> hahaha
11:53:16 <Eduard_Munteanu> :))
11:53:22 <conal> oops. danka disjoined the room
11:53:32 <conal> (dankna)
11:53:36 <djahandarie> He just did it.
11:53:36 <byorgey> groan =)
11:53:57 <conal> :D
11:54:03 <burp> since when is openbsd an architecture?
11:59:49 <Stythys> in real world haskell in ch. 8 (chapter with regexs) one of the functions (=~) returns a different type depending on what type you append to it (:: String, or :: [String], etc.)
11:59:54 <Stythys> any idea how this is implemented?
12:00:09 <byorgey> Stythys: with a type class
12:00:23 <burp> :t (+)
12:00:24 <lambdabot> forall a. (Num a) => a -> a -> a
12:00:25 <byorgey> Stythys: for example, the 'read' function has the same property
12:00:28 <byorgey> > read 3 :: Int
12:00:29 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
12:00:29 <lambdabot>    arising from the literal `...
12:00:35 <byorgey> > read "3" :: Int
12:00:36 <lambdabot>   3
12:00:38 <burp> this also returns a different type depending on what you append to it ;)
12:00:39 <byorgey> > read "3" :: Double
12:00:40 <lambdabot>   3.0
12:00:58 <burp> > 1+1 :: Double
12:01:00 <lambdabot>   2.0
12:01:01 <burp> > 1+1 :: Int
12:01:01 <lambdabot>   2
12:02:31 <amedxy> hi friends
12:02:41 <amedxy> how to clear screen to ghci ?
12:02:59 <Zao> :help? :D
12:03:18 <Zao> amedxy: Print a hundred newlines?
12:03:20 <byorgey> amedxy: try Ctrl-L
12:03:37 <amedxy> more than 100
12:03:45 <NisseP> amedxy: :!clear
12:03:53 <Zao> I'd say that "clearing the screen" demands more of the terminal environment than what GHCi is aware of.
12:03:58 <Zao> NisseP: That's not portable.
12:04:11 <Zao> Might want to mention that that invokes a shell commands.
12:04:28 <amedxy> nice
12:04:30 <amedxy> tks
12:10:19 <dafis> dankna: already working on the no-grphics frontend?
12:10:26 <dafis> graphics*
12:10:34 <fragamus> lol I have tightened my code to the point that I can barely read it
12:10:52 <dafis> fragamus: use a bigger font ;)
12:11:11 <fragamus> Hlint suggested the use of Control.Arrow.first
12:11:15 <dankna> dafis: yes, almost done with it
12:11:21 <monochrom> no, the goal is to make it tighter. use a smaller font
12:11:23 <fragamus> and wow it is freaksome
12:11:52 <fragamus> I'm not really sure I understand it, but HLint speaks and I obey
12:12:26 <dafis> fragamus: better to get into the habit of thinking about the pros and cons of hlint's suggestions
12:13:05 <monochrom> for example you can safely ignore "why not camel case"
12:15:37 <stulli> Is there a tool which makes implicit imports explicit? E.g. 'import System.IO' becomes 'import System.IO (stdin)' when the code contains stdin
12:16:43 <monochrom> ghc -ddump-minimal-imports, then look for some *.import file
12:18:28 <stulli> thanks!
12:19:12 <djahandarie> monochrom, Do_You_Use_Microsoft_Case?
12:19:21 <monochrom> I use oleg case.
12:19:25 <djahandarie> Randomized?
12:19:33 <hpc> oLegCAsE?
12:19:35 <hpc> :P
12:19:42 <monochrom> monadic'iteratee
12:19:50 <hpc> oh'god'why
12:20:04 <monochrom> because it is superior to all alternatives
12:20:31 <monochrom> in particular see http://uncyclopedia.wikia.com/wiki/ZomboCom for camel case
12:24:49 <byorgey> fragamus: first is rather general, but the particular version hlint is suggesting you use can be understood as   first f (x,y) = (f x, y)
12:25:19 <byorgey> so 'first f' is the function that takes a pair as an argument and applies f to the first element
12:25:34 <byorgey> > first (+1) (2,"hello")
12:25:36 <lambdabot>   (3,"hello")
12:25:47 <jmcarthur> > first (+1) undefined
12:25:48 <lambdabot>   (*Exception: Prelude.undefined
12:25:54 <tromp> first = (&&& id)
12:26:14 <dafis> :t (&&&)
12:26:15 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:26:34 <ion> â€˜aâ€™ being (->)
12:26:46 <dafis> > ((+1) &&& id) (2, "hello")
12:26:46 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:26:47 <lambdabot>    arising from the literal ...
12:27:12 <aristid> (***)
12:27:12 <ion> > ((+1) *** id) (2, "o hai")
12:27:12 <lambdabot>   (3,"o hai")
12:27:55 <parcs> @type uncurry (second . first)
12:27:56 <lambdabot> forall d b c d1. (b -> c, (d, (b, d1))) -> (d, (c, d1))
12:28:39 <ion> @type snd &&& fst -- do you mean this?
12:28:40 <lambdabot> forall a c. (a, c) -> (c, a)
12:29:03 <tromp> i meant (*** id)
12:30:45 <parcs> ion: no, i don't know what i meantâ€¦
12:31:24 <ClaudiusMaximus> byorgey: hey! I made my first diagrams program :)  http://hpaste.org/paste/46996/tilings_diagrams#p47066
12:32:32 <byorgey> ClaudiusMaximus: woohoo!
12:32:36 <byorgey> ClaudiusMaximus: you should join #diagrams =)
12:33:08 <fragamus> http://hpaste.org/47067/fragamus_monad
12:33:35 <fragamus> hey i have tightened this thing so much im having a blast learning
12:33:54 <fragamus> thanks so much to all of you
12:35:00 <fragamus> any more suggestions? I doubt it can be much tighter
12:35:08 <parcs> @hoogle modifys
12:35:08 <lambdabot> Text.Parsec.Prim modifyState :: Monad m => (u -> u) -> ParsecT s u m ()
12:35:08 <lambdabot> Data.STRef modifySTRef :: STRef s a -> (a -> a) -> ST s ()
12:35:08 <lambdabot> Data.STRef.Lazy modifySTRef :: STRef s a -> (a -> a) -> ST s ()
12:35:24 <copumpkin> @let f x = (x, x)
12:35:25 <lambdabot>  Defined.
12:35:27 <copumpkin> @let f1 = f . f
12:35:28 <lambdabot>  <local>:3:5:
12:35:28 <lambdabot>      Ambiguous occurrence `f'
12:35:28 <lambdabot>      It could refer to either `L....
12:35:35 <copumpkin> @let whoops x = (x, x)
12:35:36 <lambdabot>  Defined.
12:35:41 <copumpkin> @let whoops1 = whoops . whoops
12:35:41 <lambdabot>  Defined.
12:35:46 <copumpkin> @let whoops2 = whoop1 . whoops1
12:35:47 <lambdabot>  <local>:5:10: Not in scope: `whoop1'
12:36:00 <copumpkin> @let whoops2 = whoops1 . whoops1
12:36:01 <lambdabot>  Defined.
12:36:07 <copumpkin> @let whoops3 = whoops2 . whoops2
12:36:08 <lambdabot>  Defined.
12:36:14 <copumpkin> @let whoops4 = whoops3 . whoops3
12:36:18 <lambdabot>  Defined.
12:36:21 <copumpkin> :t whoops4
12:36:37 <byorgey> fragamus: you could replace the whole case with  maybe (schranmove cards) return (M.lookup cards mymap),  although whether that is an improvement is a matter of taste
12:37:10 <lambdabot> thread killed
12:37:11 <fragamus> wow cool im doing it
12:37:19 <djahandarie> :t whoops4
12:37:20 <copumpkin> @let whoops5 = whoops4 . whoops4
12:37:24 <copumpkin> :t whoops5
12:37:29 <copumpkin> @botsmack
12:37:31 <djahandarie> Is this seriously killing the type checker?
12:37:37 <fragamus> do not taunt lambdabot
12:38:04 <parcs> i think you killed lambdabot
12:38:21 <fragamus> my beloved lambdabot
12:38:23 <dcoutts> any Windows or OSX users here who'd like to help me with testing some code for use in the ghc rts?
12:38:24 <djahandarie> It has a resource limiter on mueval, should be fine, technically
12:38:25 <dcoutts> http://hpaste.org/47068/get_environment_test_code_f
12:38:35 <copumpkin> djahandarie: that's what I was testing, because :t shouldn't use mueval
12:38:38 <copumpkin> mueval = evaluation
12:38:42 <dankna> I'm willing to test (OS X), but I'm not here for long
12:38:43 <dcoutts> I need to see if this code compiles and works on windows, and on OSX
12:39:01 <parcs> > 5
12:39:06 <djahandarie> copumpkin, are you sure?
12:39:17 <parcs> *grumble* thanks a lot!
12:39:20 <copumpkin> djahandarie: a plain ol' evaluation would have terminated long ago
12:39:25 <byorgey> fragamus: also it's strange to actually write  Control.Arrow.first, usually you would just  'import Control.Arrow' and then use 'first'
12:39:25 <copumpkin> djahandarie: it gets killed
12:39:39 <dcoutts> dankna: ghc envtest.c -o envtest; ./envtest
12:39:40 * copumpkin calls Cale
12:40:06 <dcoutts> dankna: and if that works: diff <(env) <(./envtest)
12:40:47 <copumpkin> although of course with what djahandarie did, it's hard to tell if it died after the first attempt
12:40:51 <copumpkin> or after the other stuff we did
12:40:57 * copumpkin glares at djahandarie 
12:41:39 <copumpkin> I guess so :)
12:41:47 * copumpkin notes what not to do in future
12:41:53 <djahandarie> "thread killed" wouldn't be output unless it was one of the internal limiter things though
12:43:05 * copumpkin looks guilty
12:43:06 <dankna> dcoutts: appears to work fine, the only difference is the line _=/usr/local/bin/env or _=./envtest
12:43:26 <dankna> this is OS X 10.6.7 with XCode 4 installed
12:44:16 <djahandarie> Oh wow, that 'whoops' thing does expand pretty damn fast
12:44:32 <dcoutts> dankna: perfect, thanks
12:44:46 <dankna> np
12:44:53 <Twey> I don't think it's that
12:44:55 <fragamus> http://hpaste.org/47069/fragamus_monad
12:44:58 <Twey> Î»b is not happy today
12:45:07 <fragamus> ok i think it cant get tighter
12:45:16 <dcoutts> dankna: ah, hold on, I'm not totally convinced the ifdef bit works, try:
12:45:28 <dcoutts> dankna: ghc -Ddarwin_HOST_OS envtest.c -o envtest; ./envtest
12:45:33 <fragamus> byorgey i incorporated your latest suggestion
12:45:40 <dcoutts> oh, he's gone
12:46:41 <fragamus> well i doubt he could have tightened it any more
12:47:22 <byorgey> fragamus: cool
12:47:37 <fragamus> it is tight like a tiger
12:48:06 <fragamus> thank you for helping me
12:48:28 <byorgey> fragamus: you could make it even shorter like this: schmove cards = gets fst >>= maybe (schranmove cards) return . M.lookup cards
12:48:31 <byorgey> =D
12:48:44 <byorgey> no need to bother giving mymap a name
12:48:59 <fragamus> haha cool
12:52:10 <fragamus> http://hpaste.org/47070/fragamus_monad
12:52:19 <fragamus> ok really, that has to be it
12:52:33 <byorgey> fragamus: is that a challenge? ;)
12:52:34 <stepkut> fragamus: I am still not clear on why you are using the [] monad..
12:53:08 <fragamus> i have some situations where the other functors will turn one creature into multiple creatures
12:53:15 <byorgey> fragamus: ok, no, I don't really see a way to shorten it any more =)
12:53:22 <fragamus> no it is not a challenge
12:53:46 <stepkut> fragamus: ah
12:53:52 <fragamus> i think it would take a miracle to shorten it more
12:56:19 <fragamus> it would take some kind of extraordinary insight to make it any shorter
12:57:13 <dmwit> fragamus: Doesn't MonadRandom have an efficient implementation of choosing from a list with the uniform distribution?
12:58:22 <fragamus> hmm i shall look into that
12:58:33 <fragamus> thank you!
12:58:59 <Twey> fragamus: schranmove = (>>) (getRandomR (0, length moves - 1) >>= modify . first . M.insert cards . (moves !!)) . schmove
12:59:02 <Twey> :Ã¾
12:59:11 <jmcarthur> umm
12:59:15 <dmwit> I wouldn't really call that shorter.
12:59:18 <fragamus> holy moly
12:59:32 <jmcarthur> when i see "(>>)" i undo
12:59:42 <jmcarthur> well
13:00:02 <jmcarthur> actually, sometimes i end up with "liftA2 (>>)", but that happens so often that maybe i should just define a special operation for it
13:00:04 <dmwit> fragamus: fromList seems closest to what I was thinking of.
13:00:29 <jmcarthur> actually, i mean "liftA2 (*>)"
13:00:39 <dmwit> :t liftA2 (>>)
13:00:50 <Twey> 25 characters shorter, actually ;)
13:01:03 <Twey> I get liftA2 (>>) a lot
13:01:09 <Twey> Except I'm sloppy and tend to use liftM2
13:01:18 <jmcarthur> liftA2 (*>) :: (Applicative f1, Applicative f) => f (f1 a) -> f (f1 b) -> f (f1 b)
13:01:38 <dmwit> move <- fromList (zip moves (repeat 1)) -- looks nice to me, and no (!!) involved =)
13:01:48 <byorgey> fragamus: of course, at this point we are well past making the code more elegant and are just making it shorter for the fun of it =)
13:02:03 <dmwit> Hey! I think fromList is more elegant.
13:02:10 <fragamus> yes but im learning haskell in the process
13:02:22 <dmwit> The real fromList is even better, though. ;-)
13:02:41 <fragamus> i think it is fantastic training
13:02:50 <jmcarthur> another thing that tends to make me second guess is (!!), but it looks like the list just statically has three elements, so that might not be so bad
13:02:58 <Twey> fromList is more elegant
13:03:09 <Twey> But it would have been better written as fromList . zip moves $ repeat 1, of course :Ã¾
13:05:05 <fragamus> this language blows my mind
13:05:31 <dmwit> realFromList = realFromList' (error "empty list") 1; realFromList' acc [] n = acc; realFromList' acc (x:xs) n = do { v <- getRandomR (0,1); (if v < 1/n then realFromList' x else realFromList' acc) xs (n+1) }
13:05:59 <dmwit> There are probably subtle bugs in that implementation.
13:06:06 <dmwit> But the idea is so cool I couldn't not share it. =)
13:06:36 <dmwit> ...like having the arguments to realFromList' switched compared to the arguments to realFromList. whoops =P
13:18:39 * hackagebot pontarius-xmpp 0.0.4.0 - A (prototyped) secure and easy to use XMPP library  http://hackage.haskell.org/package/pontarius-xmpp-0.0.4.0 (JonKristensen)
13:21:39 <Peaker> So why did node.js dude think he needed to hack on ghc?
13:21:49 <parcs> > 5
13:22:40 <Peaker> Bigger than five!
13:23:30 <Volt_> Has anyone gotten HOC (the Haskell-Objective C bindings) to build lately?
13:25:36 <mm_freak> byorgey: what code are you trying to make shorter?
13:25:54 <byorgey> mm_freak: some code fragamus wrote
13:26:07 <mm_freak> that doesn't really answer my question =)
13:26:11 <byorgey> http://hpaste.org/47070/fragamus_monad
13:26:17 <mm_freak> ah, thanks
13:27:22 <b930913> How does a if-then structure work in haskell?
13:27:37 <b930913> an*
13:27:43 <parcs> it's an expression
13:28:01 <parcs> if Bool then a else a
13:28:18 <parcs> where a is a value of any type
13:28:25 <mm_freak> b930913: it's comparable to "the ternary operator" in other languages
13:28:28 <mm_freak> like ?: in C
13:28:55 <b930913> Hmm.
13:29:03 <b930913> So how can I branch?
13:29:13 <mm_freak> with if-then-else =)
13:29:25 <mm_freak> or with pattern matching
13:29:32 <mm_freak> latter is preferred in most cases
13:29:38 <monochrom> both if-then-else and pattern matching are branching constructs
13:30:19 <mm_freak> there are also some convenience functions like 'when'
13:30:22 <mm_freak> :t when
13:30:32 <monochrom> > case 5 of { 0->"0"; 4->"4"; x -> "other" }
13:30:41 <monochrom>  "other"
13:32:05 <b930913> So if I have a string, how do I do a select case on the string?
13:32:31 <mm_freak> usually you don't
13:32:32 <dmwit> > case "string" of { "case 1" -> 32; "string" -> 64; "other" -> 56; _ -> 0 }
13:32:33 <monochrom> case "other" of { "0" -> 0; "4" -> 4; "other" -> 5 }
13:32:44 <dmwit> 64
13:32:46 <dmwit> 5
13:33:11 <dmwit> But yeah, usually you don't.
13:33:15 <monochrom> lambdabot has been cloud-sourced :)
13:33:18 <dmwit> You use real data instead. =)
13:33:28 <dmwit> > DWIM
13:33:42 <monochrom>  what does it mean?
13:33:57 <mm_freak> if you really need to to match strings, it's usually better to build a map with the different cases and use that map to match
13:36:03 <b930913> If I give a command in IRC to a haskell bot, how can I run different code depending on the command given, if any?
13:36:38 <monochrom> by string manipulation
13:36:51 <rothwell> has the ghc runtime ever been audited for security?
13:36:54 * monochrom appeals to the snobol tarpit :)
13:37:03 <monochrom> no
13:37:13 <rothwell> hm
13:37:53 <Phantom_Hoover> I am sorry what have you done to lambdabot this time.
13:38:04 <Phantom_Hoover> @where lambdabot
13:38:13 <Phantom_Hoover> Also why is there now temporary bot.
13:38:21 <Phantom_Hoover> This is not acceptable guys.
13:38:47 <rtharper> ?
13:39:01 <rtharper> orly?
13:40:39 <Phantom_Hoover> Not. Acceptable.
13:40:46 <Phantom_Hoover> You should neuter her or something.
13:43:14 <mm_freak> b930913: http://hpaste.org/47072/string_matching
13:43:19 <mm_freak> this is how i do it usually
13:44:15 <monochrom> it may be overkill for just 3 strings. but 50 strings, yes
13:45:01 <monochrom> pattern matching is evaluated linearly. know your rights.
13:45:08 <mm_freak> monochrom: i do it even for three strings, though
13:45:25 <mm_freak> not for speed, butâ€¦  wellâ€¦  let me call it integrity
13:45:44 <monochrom> I think it's a bit too verbose for 3 strings
13:46:13 <mm_freak> you can write it more compactly, of course
13:46:43 <monochrom> I have no integrity. I cold-heartedly calculate syntactic benefits and efficiency benefits.
13:47:52 <monochrom> I also refuse to take part in that group-hug thread of haskell-cafe
13:48:01 <mm_freak> monochrom: me too
13:48:19 <mm_freak> integrity is part of both
13:48:31 <tromp> > 2/6 :: Rational
13:48:49 <monochrom> but wait, why does it degenerate to "why is length O(n)?"? :)
13:49:37 <monochrom> perhaps there are more people out there as cold-hearted as me after all
13:50:29 <sm> speaking of bots.. anyone interested in brainstorming a highly reliable irc bot ?
13:50:58 <monochrom> yes. first use a highly reliable hardware platform. maybe amazon's cloud
13:51:10 <sm> I've been trying with rss2irc, slowly. I'm thinking of starting over with something erlangish
13:51:19 <sm> CloudHaskell or one of the libs on hackage
13:51:32 <Eduard_Munteanu> Then write it in a theorem prover after a nazi specification.
13:51:49 <monochrom> secondly use agda and coq to write the software. prove that each operation is constant-space constant-time
13:52:10 <monochrom> Eduard_Munteanu++ :)
13:52:20 <sm> I'd be happy with a bot that's nearly as reliable as the hardware it's on. Currently mine can die due to various process termination and hang scenarios
13:52:45 <sm> die/hang
13:53:29 <monochrom> thirdly, choose a highly reliable irc network. maybe irc.gimp.net
13:54:54 <sm> or, code review and advice on the process management at http://joyful.com/darcsweb/darcsweb.cgi?r=rss2irc;a=headblob;f=/rss2irc.hs might be enough
13:54:56 <monochrom> there are too many points of failure for a server-daemon like this. people spend millions of dollars to accomplish 99% uptime
13:57:24 <monochrom> don't forget that you should coq-verify or agda-verify your haskell compiler, too :)
13:57:48 <monochrom> "but who verifies the agda?" :)
13:58:24 <Saizan> just make a bot that reconnects when it doesn't see any traffic for too long
13:58:26 <b930913> sm: I'm writing one now, not that I know how to in haskell :p
13:59:04 <monochrom> (actually, a viable alternative is to verify each output of the compiler as it happens, rather than verifying the compiler once-and-for-all)
14:01:07 <b930913> mm_freak_: In your string match, how could I test only the first word, while still retaining the other information?
14:01:30 <ClaudiusMaximus> how might i implement properFraction for data QF n = QF Rational Rational where (QF a b :: QF n) represents a + b * sqrt n ?  so far I have Eq,Ord,Num,Fractional,Real (toRational errors if b/=0 ...)
14:02:04 <mm_freak_> b930913: by 'words'
14:02:27 <b930913> mm_freak_: But where do I use it?
14:03:18 <b930913> There seems to be so much implied in haskell that I can never seem to find where to put functions.
14:04:16 <dafis> ClaudiusMaximus: is n always positive or can it be negative?
14:04:29 <b930913> actions :: Map String (IO ())
14:04:31 <b930913> actions = words M.fromAscList !! 0 $
14:04:36 <b930913> mm_freak_: Is that right?
14:05:22 <monochrom> no, do the "words" decomposition at the call site of M.lookup
14:05:46 <monochrom> or near the call site
14:05:47 <ClaudiusMaximus> dafis: n is positive and square-free
14:06:00 <tg_> hm. I'm trying to install lambdabot on [arch], and it's failing because haskell-src-exts is failing to compile
14:06:12 * b930913 goggles at the complexity of this stuff...
14:06:18 <iskren> is there a way to create polymorphic types (like type (Eq a) => Foo a = [a])
14:06:53 <tg_> b930913: remember though, if it's the kind of complexity that you can intuit, then it's the good kind of complexity
14:07:00 <ameedxy1> how to print a [String] to a coord of screen, I use printf
14:07:04 <monochrom> just write "type Foo a = [a]"
14:07:14 <b930913> tg_: I'm not there yet though :(
14:07:21 <iskren> monochrom, so I cannot enforce a class there?
14:07:28 <monochrom> cannot
14:07:37 <mm_freak_> b930913: this is, where you can use pattern matchingâ€¦  pattern-match on the result of 'words' and change the type of 'actions' to:
14:07:47 <mm_freak_> Map String ([String] -> IO ())
14:08:15 <b930913> Ah, I see.
14:08:25 <b930913> Passing parameters, right?
14:10:04 <dmwit> Why would you use Map String ([String] -> IO ()) instead of just [String] -> IO () for this?
14:10:24 <luite> tg_: what goes wrong? I installed the new version of haskell-src-exts earlier today just fine
14:10:26 <tg_> ok, i'm getting the following errors: "/usr/bin/gch returned ExitFailure 9. World file is already up to date."
14:10:33 <b930913> What's the handle on [String] to pass it on though?
14:10:34 <ClaudiusMaximus> dafis: equivalently, any of floor, ceiling, round, truncate would do
14:10:38 <tg_> s/gch/ghc/ of course
14:10:55 <dmwit> handle = fromList [("foo", f), ("bar", g)] --> handle ("foo":rest) = f rest; handle ("bar":rest) = g rest
14:10:59 <tg_> "haskell-src-exts-1.10.2 failed during the configure step. The exception was: ExitFailure 9"
14:11:32 <dafis> ClaudiusMaximus: yes, that's clear, the problem is finding something efficient
14:11:37 <ClaudiusMaximus> dafis: tried to figure it out on paper, but all the inequalities gave me a headace
14:12:30 * b930913 doesn't get all this. Show me? http://piratepad.net/VElx1XbfYt
14:12:49 <monochrom> pirate?!
14:13:07 <dafis> ClaudiusMaximus: you could try using a rational approximation of sqrt n, say s, then floor (a + b*s), which should be close to floor (a + b*sqrt n), then improve, but there must be something better
14:13:12 <shachaf> @yarr
14:13:43 <ClaudiusMaximus> dafis: hmm, i guess i could use binary search to get something that works in O(log (abs q)) time?
14:13:53 <shachaf> Cale: lambdabot is dead, by the way.
14:15:12 <b930913> Erm, help?
14:15:50 <tg_> luite: I bet this is happening because I am doing this as root, and I haven't created any users yet - and cabal install installs as user
14:15:51 <dmwit> That's a lot of code.
14:15:54 <dmwit> What are we looking at?
14:15:58 <tg_> luite: how can I undo everything I've done with cabal so far?
14:16:12 <b930913> dmwit: It's an IRC bot.
14:16:15 <dmwit> "help" isn't a very focused question for us to help with. =)
14:16:30 <b930913> Line 100 area.
14:16:41 <dafis> ClaudiusMaximus: yes, though with a good approximation to sqrt n, it should be better than O(log |q|) for reasonably small a and b
14:16:51 <b930913> I'm trying to figure how to implement commands.
14:17:10 <b930913> Which is proving quite hard, not knowing haskell and all.
14:17:11 <Cale> lambdabot, y u no exists?!?
14:17:19 * Cale brings lambdabot back
14:17:53 <Cale> lambdabot's server seems a little slow...
14:18:16 <sm> Cale: what causes lambdabot downtime ?
14:18:21 <Cale> no idea
14:18:26 <djahandarie> sm, I think this last one was copumpkin crashing it
14:18:34 <Cale> lambdabot was still running and still thought it was connected to the network
14:18:40 <djahandarie> Oh?
14:18:45 <djahandarie> Let's try again then!
14:18:46 <dmwit> b930913: There's a tutorial associated with this bot. Why don't you start at the top of the tutorial and let us know when you get to the first thing you don't understand?
14:18:47 <Cale> but it wasn't connected
14:18:54 <djahandarie> Cale, stand by to start it up again :p
14:19:00 <djahandarie> @let whoops x = (x,x)
14:19:06 <lambdabot>  <local>:8:0:
14:19:12 <lambdabot>      Multiple declarations of `L.whoops'
14:19:13 <sm> I was just wishing aloud for a foolproof erlangish framework for irc bots
14:19:14 <djahandarie> Oh, is it still defined?
14:19:16 <b930913> dmwit: I did that. I'm trying to make my own commands now.
14:19:18 <djahandarie> :t whoops4
14:19:22 <lambdabot> Plugin `eval' failed with: thread killed
14:19:29 <djahandarie> > "test"
14:19:36 <lambdabot> thread killed
14:19:38 <lispy> hmm
14:19:39 <lambdabot>   mueval-core: Time limit exceeded
14:19:44 <lispy> lambdabot: you have a run-away thread
14:19:47 <geheimdienst> > "kitties"
14:20:00 <djahandarie> lispy, I think the type checking thread doesn't get killed or something
14:20:03 <Cale> wat
14:20:14 <djahandarie> (That whoops4 expands to a monster type)
14:20:20 <Cale> oh, I see
14:20:24 <Cale> @undefine
14:20:29 <lispy> Cale: linode emailed me saying that resource usage is over a threshold
14:20:29 <ion> There, fixed it
14:20:37 <Cale> > 1
14:20:42 <luite> tg_: did you install globally or as user? if you installed packages as user, then proper users shouldn't notice them, but you can remove everything by removing the .cabal and .ghc directories in your home directory
14:20:45 <lambdabot>   1
14:20:52 <djahandarie> whoops4 = whoops3.whoops3; whoops3 = whoops2.whoops2; whoops2 = whoops.whoops; whoops x = (x,x)
14:21:01 <b930913> dmwit: I tried to modify it so that rather than just the command given, it can interact with the channel or user etc.
14:21:03 <Cale> There we go, accounting for the fact that it's probably still joining channels, it's probably fine.
14:21:10 <lispy> "Your Linode has exceeded the notification threshold (1000) for disk io rate by averaging 1431.75 for the last 2 hours."
14:21:17 <djahandarie> Wow, disk IO?
14:21:20 <djahandarie> It was probably swapping
14:21:21 <Cale> lololol
14:21:26 <lispy> yes, swapping
14:21:38 <ameedxy1> how to make a gotoxy() of C on haskell?
14:21:39 <luite> hehe someone added too many quotes to lambdabot? :p
14:21:46 <lispy> ghc is going crazy
14:21:50 <ion> Thereâ€™s no gotoxy() â€œof Câ€.
14:21:56 <lispy> Cale: are you building something?
14:22:00 <Cale> No
14:22:13 <lispy> what's up with pid6721
14:22:16 <Cale> Someone made a definition with @let which had an exponentially large type
14:22:17 <monochrom> what the hell is "gotoxy"?
14:22:23 <b930913> Out of interest, what would a forkbomb be in haskell?
14:22:24 <Cale> hmm?
14:22:27 <luite> monochrom: terminal thing to move the cursor probably
14:22:32 <mauke> IIRC borland c had that on DOS
14:22:37 <sipa> monochrom: goto (x,y)
14:22:39 <lispy>  6721 cale      18   0  648m 434m 6524 D    0 84.9   1:43.02 gh
14:22:45 <ameedxy1> put a string on the coordinate axis x,y
14:22:48 <mauke> of course then came windows 95
14:22:53 <lispy> that 84.9 is % memory
14:22:59 <Cale> wait, wtf
14:23:01 <Cale> I didn't run that
14:23:03 <monochrom> then there are terminal libs on hackage which I don't want to know of
14:23:14 <luite> whoah lambdabot got hacked!
14:23:29 <luite> now they'll get millions of credit card numbers
14:23:31 <ameedxy1> and gotoxy() ?
14:23:37 <lispy> linux getting hacked is more likely than lambdabot :)
14:23:54 <Cale> I bet it's the type plugin actually
14:23:58 <lispy> Cale: I'll kill that ghc then?
14:24:03 <Cale> I'll do it
14:24:17 <luite> shouldn't you coredump it somehow, for analysis?
14:24:20 <Cale> no
14:24:29 <Cale> I know what it is, I bet
14:24:36 <lispy> gone now
14:24:37 <ion> Perhaps impose an ulimit for memory usage and CPU time on the ghc processes launched by lambdabot
14:24:44 <monochrom> we should coredump copumpkin instead :)
14:24:45 <Cale> Someone did a :t on the thing with the stupidly large type
14:24:50 <Cale> and that runs ghc
14:24:59 <lispy> ah, mueval?
14:25:03 <Cale> no
14:25:15 <ameedxy1> print_in x y s = printf "%c[%d;%df%s" (27::Int) y x s <â€” i can't understanding
14:25:19 <Cale> mueval does evaluation, but the type plugin runs ghc directly
14:25:39 <Cale> ameedxy1: what about it?
14:25:51 <monochrom> that's ANSI terminal code
14:25:59 <ameedxy1> is haskell
14:26:05 <ion> ameedxy1: Never, ever manually print escape codes. The terminfo database is there for that. And the terminal libraries use it.
14:26:46 <parcs> b930913: something like fix (forkIO >=> const (return ()))
14:27:24 * b930913 goggles.
14:27:29 <ion> That probably grows linearly. A proper fork bomb forks itself *twice* in each child. ;-)
14:27:31 <lispy> Cale: thanks for taking care of that
14:27:57 <geheimdienst> nonsense, a proper forkbomb forks 4000 times on each recursion
14:28:14 <Twey> A proper forkbomb uses processes, not GHC threads ;)
14:28:18 <b930913> Remind me not to jump in the deep end next time I try learn a language...
14:28:20 <monochrom> the "fork twice" part is just idiosyncracy of the unix forking api
14:28:21 <ion> twey: That, too. :-P
14:28:38 <ion> :(){:|:;};:
14:28:38 <dmwit> fix (forever . forkIO) -- seems much simpler
14:29:12 <fragamus> @type maybe
14:29:12 <monochrom> b930913: I have always intended to (but too lazy) write a blog on how diving-in does not work
14:29:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:29:45 <tg_> luite: yeah, but I did it as user=root
14:29:50 <b930913> monochrom: It might work if haskell was like most other languages :p
14:29:50 <parcs> dmwit: yeah that's better
14:29:53 <tg_> so I guess that's still user, even though I'm root.
14:30:00 <monochrom> "I came from the USA, I'm learning Chinese by diving in, I am writing a movie review in Chinese on a movie in Chinese"  not going to work
14:30:01 <tg_> I'm just going to try doing this as a regular user, since I should have been doing it all along
14:30:04 <parcs> or even fix (void . forkIO)
14:30:12 <luite> tg_: look in /root for the .cabal and .ghc dirs and remove those
14:30:28 <monochrom> yes, "I'm from USA, I'm learning British English by diving in" this works
14:30:45 <tg_> luite: yeah, did that
14:30:47 <dmwit> parcs: I think the "forever" is important so that each thread clones itself, rather than just spawing a single child.
14:30:59 <luite> tg_: k, then ghc-pkg list shouldn't show them anymore
14:31:01 <fragamus> @type maybe
14:31:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:31:11 <luite> tg_: if it does, then you'll need to remove more :)
14:31:19 <parcs> good point
14:31:45 <tg_> luite: embarassingly, I went ahead and removed all of haskell-platform, so I think I'm covered
14:31:57 <luite> hehe
14:31:58 <monochrom> fb = forever (forkIO fb)  approximately. each thread forks many threads.
14:32:09 <tg_> luite: never used arch before, so i'm not used to pacman
14:32:37 <monochrom> be sure to remove .ghc, the most important directory to erase, even .cabal is not so important
14:33:18 <luite> tg_: oh ok, I use ubuntu myself, and have installed ghc separately, so I might not be able to help with everything :)
14:33:44 <luite> oh wait, on linux the platform doesn't include ghc
14:34:01 <monochrom> right
14:34:05 <tg_> luite: it was automatically gotten by the package manager in arch
14:34:48 <fragamus> schmove cards = gets fst >>= maybe (schranmove cards) return . M.lookup cards
14:35:24 <tg_> luite: I used to use ubuntu, but I wanted something smaller, without any GUI, and simpler w.r.t management of options (no dbus, etc - files only for configuration)
14:35:34 <luite> really, without gui?
14:35:37 <tg_> i would still use ubuntu for a GUI
14:35:55 <fragamus> so, the function value from gets fst ends up on the far right ?
14:35:56 <tg_> yeah, i am running it as a VM and I have 4 monitors so I don't need to see it
14:36:01 <flinstone> Hey guys, anybody know howto break image CAPTCHA with Haskell or without it? any resources?
14:36:04 <monochrom> @quote ray 1970s
14:36:04 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
14:36:06 <luite> ah ok
14:36:19 <tg_> i can just put the VM fullscreen on the console to see it
14:36:27 <stepkut> flinstone: there are services for that
14:36:28 <tg_> but otherwise I don't care
14:36:40 <monochrom> "ubuntu server" has no gui
14:36:49 <tg_> monochrom: yeah, it also has another set of problems
14:36:56 <rudyl313> how do I remove the nth element from a list?
14:37:04 <tg_> i wanted to try arch anyway
14:37:09 <tg_> seemed like a good time to do it
14:37:15 <rudyl313> do I have to use a combo of take and drop?
14:37:28 <luite> rudyl313: splitAt would be a candidate
14:37:30 <Twey> rudyl313: 1) Don't; 2) You might find splitAt + drop easier
14:37:33 <monochrom> yes, a combo of take and drop works
14:37:55 * hackagebot hbro 0.2.1 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.2.1 (koral)
14:38:35 <shachaf> @src splitAt
14:38:35 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
14:38:44 <shachaf> rudyl313: But, yes, as Twey says, don't do that.
14:39:29 <Twey> rudyl313: If you're ever talking about specific indices of a list, you're probably using the wrong data structure
14:39:35 <Twey> Lists are meant to be iterated over
14:39:35 <matthew-_> btw, haskell's type checker - is it hindly-milner on steroids, or really not?
14:39:45 <Twey> matthew-_: Yes.  I believe.
14:40:14 <monochrom> hindly-milner on steroids (type classes)
14:40:20 <Twey> Hehe
14:40:23 <rudyl313> Twey .. I'm trying to form a submatrix of a matrix to calculate the determinant
14:40:32 <Twey> rudyl313: Use the hmatrix package
14:40:44 <rudyl313> Twey: cool
14:40:50 <rudyl313> Twey: thanks
14:40:56 <Twey> Or that other one whose name I forget
14:41:15 <monochrom> actually the steroid is a bit more than type class. if you add some type sigs yourself, you can go polymorphic recursion, which is also a bit outside hindley-milner
14:41:34 <drhodes> I'd like to have an operator (??) inside of a type signature,  foo :: a ?? b -> c, which at compile time expands to foo :: Mytype a b -> c .   But I'd like to specify, (??) l r = ... typelevel nosebleeding ...
14:41:45 <drhodes> is this possible with type operators or TH?
14:42:10 <Twey> drhodes: You can do it with type operators, but it has to start with a :
14:42:25 <Twey> type :?? l r = â€¦ definition â€¦
14:42:27 <Twey> Err
14:42:32 <drhodes> alright Twey thanks.
14:42:33 <Twey> type l :?? r = â€¦ definition â€¦
14:43:35 <flinstone> stepkut, yes but i am intresting in neural tetworks, ocr i am loking for methods and articles
14:44:35 <tg_> luite: nope, still fails to build
14:45:21 <luite> tg_: does lambdabot require an older version of haskell-src-exts?
14:45:36 <tg_> luite: well, this time I just tried to build haskell-src-exts by itself, first
14:46:05 <tg_> luite: which version did you build/install today? it's doing 1.11.1 now
14:46:12 <monochrom> if building haskell-src-ext fails, you have a bigger problem
14:46:24 <tg_> luite: which was updated...today
14:46:27 <parcs> tg_: what is the build error?
14:46:35 <parcs> and are you using [testing]?
14:46:43 <tg_> parcs: no, and ExitFailure 9
14:47:00 <parcs> try cabal install -v
14:47:00 <tg_> i don't actually see the error, it failed while building Lang.Haskell.Exts.Annotated.Syntax
14:47:11 <tg_> parcs: I did --verbose=3
14:47:16 <parcs> oh.
14:47:37 <tg_> there's a warning about InternalParser
14:47:38 <monochrom> then probably try an older haskell-src-exts
14:47:50 <tg_> and then while compiling .Annotated.Syntax, it says "updating world file"
14:47:58 <tg_> and then fails with ExitFailure 9
14:48:17 <parcs> this is during compiling not linking right?
14:48:21 <monochrom> you know, it does everyone much good if you pasted
14:48:24 <luite> tg_: yes
14:48:31 <parcs> oh
14:48:38 <tg_> parcs: yes, I think so. gcc 4.5.0 20100610
14:48:40 <luite> there are some small api changes between 1.10 and 1.11
14:48:56 <tg_> luite: what ghc did you use?
14:49:22 <parcs> okay, never mind. i was going to suggest trying the version of ghc in [testing] that fixes a particular linking bug but that's apparently not the case here
14:49:29 <luite> 7.0.1.20110201 and 7.0.3
14:49:38 <tg_> hm. i'm sitting at 7.0.2
14:50:20 <parcs> yeah, arch hasn't updated to 7.0.3 yet for some reason..
14:50:36 <tg_> parcs: btw, this [testing] thing is an arch term for the testing repos?
14:50:52 <tg_> parcs: i also included the [haskell] repo, but i didn't get from it
14:51:10 <parcs> yep. oh, there's a haskell repo?
14:53:49 <roconnor> what is system-F2?
14:55:40 <Saizan> it's where you can abstract only over types of kind *
14:56:12 <roconnor> oh
14:56:18 <roconnor> so what is system-F?
14:56:38 <kuraj> good evening
14:56:45 <Saizan> it's often short for system-F2
14:57:03 <Saizan> other times for system-F_omega
15:01:07 <tg_> parcs: first time the outcome was BuildFailed, second time, ConfigureFailed
15:02:07 <flinstone> What about optical character recognition, or handwritten algorithms in Haskeel, or another language? are here experts?
15:03:08 <flinstone> Are handwritten recognition has more advances samples(nnot just neural nteworks )?
15:03:53 <flinstone> i am intresting in research papers, or resources.
15:05:03 <ivanm> I don't think anyone has done anything like that
15:05:14 <ivanm> for OCR, maybe bindings to sphinx would be in order?
15:05:18 <ivanm> preflex: seen lispy
15:05:18 <preflex>  lispy was last seen on #haskell 37 minutes and 47 seconds ago, saying: Cale: thanks for taking care of that
15:06:08 <flinstone> ivanm, why i should use shinx search server?
15:07:16 <flinstone> ivanm, you think that peoples do  not use Haskell for OCR?
15:08:06 <ivanm> flinstone: I haven't seen anyone do do anything like that yet
15:08:29 <ivanm> oh, wait, not sphinx...
15:08:55 <ivanm> CMU Sphinx is voice recognition
15:09:39 <ivanm> Tesseract is the one I think I was thinking of
15:09:54 <monochrom> most captcha's have a voice option
15:10:01 <ivanm> but using an existing OCR library and just writing bindings to it would probably be easier/make more sense
15:10:09 <flinstone> ivanm, yes i already used it
15:11:03 <adimit> are strict bytestring implemented in C?
15:11:13 <ivanm> adimit: no
15:11:26 <ivanm> but they _do_ use pinned memory IIRC
15:11:41 <adimit> ivanm: strange. I'm getting ForeignPtr on my heap profile, even though I use haskell-only stuff.
15:11:47 <adimit> where could that come from?
15:11:48 <tommd> preflex: seen hydro
15:11:57 <ben> ForeignPtr does not mean C
15:12:07 <adimit> just was my first guess.
15:12:35 <tommd> hydo: ping
15:12:45 <hydo> tommd: ack
15:12:54 <hydo> heh
15:12:56 <adimit> so my guess is that the ForeignPtrContents stem from my use of strict bytestrings, no?
15:12:57 <tommd> Were you looking for me?
15:12:58 <ben> adimit: A strict ByteString consists of a ForeignPtr and a bunch of stuff, that does not mean it's made in C :)
15:13:14 <hydo> I was... I'm interested if you got anywhere with implementing a DHT
15:13:16 <ben> data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8) {-# UNPACK #-} !Int {-# UNPACK #-} !Int
15:13:17 <luite> why is this an invalid .lhs file? http://hpaste.org/47077/invalid
15:13:23 <tommd> A few times, yes.
15:13:25 <adimit> ben: ok, good to know, thanks.
15:14:14 <ivanm> luite: the ###
15:14:35 <ivanm> luite: because for some reason even if you don't tell it to do so, GHC keeps thinking you want CPP support :s
15:14:41 <ivanm> I've run into that problem before
15:14:41 <luite> ivanm: yes I know, but why aren't they allowed there? the line doesn't start with a >, shouldn't it be ignored?
15:14:47 <luite> oh...
15:14:51 <luite> very funny ;p
15:15:10 <luite> does markdown accept ### things that don't start at the first character
15:15:13 <luite> ?
15:15:17 <ivanm> luite: pandoc?
15:15:30 <tommd> hydo: I've the DHT and a simple simulator (very simple).  What's missing is a coherent module that others can use without pulling their hair out.
15:15:32 <luite> for example, but ideally "every markdown parser" :p
15:15:34 <ivanm> you can use ===== and ----- under the title for first and second level headings
15:15:46 <tommd> right now I kind of use lots of the guts of Horde (the DHT package) when building any given client.
15:15:47 <ivanm> and then use the API later to change them all to 3rd and 4th level...
15:16:11 <hydo> tommd: I'd love to contribute to a packagable.... package.
15:16:22 <geheimdienst> i'm curious, what is the error message for the ### thing?
15:16:28 <ivanm> luite: I have contemplated writing a wrapper around ghci for use with literate markdown, but it would only work for the specified module :/
15:16:36 <hydo> tommd: or even be the person responsible for it.
15:16:36 <luite> geheimdienst: parsetest3.lhs:7:2: lexical error at character '#'
15:16:41 <hydo> or somewhere in between.
15:16:54 <hydo> I'm just not at the level yet where I can implement it from scratch.
15:16:55 <geheimdienst> i see. seems fairly clear :-/
15:16:57 <tommd> hydo: I'll work on making it less embarassing to me and push to github.  Right now the lack of abstractions makes me cringe.
15:17:07 <tommd> That's what I get for coding during cocktail hour.
15:17:45 <mauke> tommd: preflex has finally noticed it's no longer online and should be back in a few minutes :-)
15:17:56 <hydo> tommd: I'm excited enough about the idea and the stuff I want to use it in that I really don't care, but whatever makes you feel better about releasing it :)
15:18:02 <tommd> mauke: thanks
15:18:31 <tommd> hydo: I'll give myself a deadline... probably no later than end of June and hopefully sooner.
15:18:48 <luite> geheimdienst: yes I knew where the error was, but I had no idea why
15:19:19 <mauke> preflex: version
15:19:31 <luite> ivanm: fortunately I don't really need to load the code in ghci, and I can use some javascript to work around the issue
15:19:44 <ivanm> luite: _javascript_ ? :o
15:20:02 <luite> yeah I'm rewriting ghc in javascript ;)
15:20:09 <Twey> Haha
15:20:11 <luite> nah it's for a wiki
15:20:12 <preflex>  2.571
15:20:29 <ivanm> luite: yeah, but it causes problems with testing that your code is correct, right?
15:20:42 <hydo> tommd: sounds good.
15:20:50 <ivanm> I was doing this for a blog post, and I wanted to make sure the code I was providing worked (as it was meant to be a tutorial)...
15:21:26 <adimit> is (Strict.concat . Lazy.toChunks) *the* only way to convert a lazy bytestring into a strict one, and is it very expensive to do this on a lot of very small lazy bytestrings?
15:21:47 <tommd> hydo: repeat 100 (add ; step 3) ; repeat 1000 (randmsg "") ; statistics
15:21:55 <tommd> adding node at address  ... (100 times)
15:21:57 <ivanm> adimit: yes to the former (and you have to be careful that it's not too long)
15:21:58 <tommd> Forwards:   19481
15:21:58 <tommd> Deliveries: 49
15:21:58 <tommd> Average nr hops: 0
15:22:08 <ivanm> for the latter, are you joining them all first?
15:22:16 <adimit> ivanm: thanks again, very much :-)
15:22:27 <luite> ivanm: hmm, yes, and apparently my js markdown parser only accepts this if it's the first char
15:22:31 <tommd> Oops, looks like I broke something (see the deliveries and average hops)! arg
15:22:39 <adimit> No I'm not joining them. I'm parsing words out of a 2.GB text file, then putting them into a Data.Trie
15:23:13 <ivanm> luite: AFAIK it has to be the first char to be a heading
15:23:14 <luite> ivanm: this is more annoying than I hoped it would be
15:23:15 <adimit> Data.Trie (unsurprisingly) wants strict BS as its key type, but I read the file lazily, so far. Maybe I should use some itreatee method instead.
15:23:45 <tommd> Oh, no I just used the wrong command, I see.
15:24:07 <luite> is it even possible to make level 4 headings without #?
15:24:37 <tommd> remembering to step the simulation after sending the messages gives:
15:24:38 <tommd> Forwards:   196955
15:24:39 <tommd> Deliveries: 1000
15:24:39 <tommd> Average nr hops: 2.7831912302070645
15:24:57 <tommd> So my route tables are still aweful... hum.
15:26:26 <ivanm> luite: nope
15:26:48 <ivanm> unless your markdown implementation has some extension for it
15:27:08 <luite> ivanm: bah... and I hoped to annotate the whole wiki with markdown+lhs files...
15:27:24 <luite> does pandoc have one?
15:27:43 <ivanm> luite: do you need to have 1st and 2nd level headings in the lhs file?
15:28:08 <ivanm> if not, use them, and then pandoc's API to downgrade them all to 3rd and 4th level
15:28:32 <luite> :(
15:28:49 <ivanm> I consider this a bug in GHC tbh
15:29:18 <ivanm> though there's also the problem with dealing with block quotes... as they start with bird tracks :s
15:29:26 <geheimdienst> isn't there some option to explicitly turn off the preprocessor stuff?
15:29:36 * ivanm wishes that GHC understood pandoc's "here be code" syntax
15:35:44 <fragamus> ok I have a high level monad design question
15:36:44 <luite> ivanm: I can still use all levels with #### in the wiki pages, and hve the .lhs exporter mangle it somehow so that ghci likes it, for users that want to download the page
15:36:57 <fragamus> I have a list of states and I need to create new states based on multiple old states
15:37:27 <tg_> ok, parcs: and luite: et al... now, the build is failing at the configure stage
15:37:40 <tg_> and it's the linker that's failing
15:37:46 <tg_> ld terminated with signal 9
15:37:47 <ivanm> luite: yeah, probably the best bet
15:37:59 <ivanm> luite: be also wary of block quotes
15:38:05 <fragamus> but in the monad, the states are served up one by one
15:38:45 <luite> ivanm: what exactly are these bird tracks?
15:38:50 <aavogt> fragamus: what state do you want to be the current state after you're done with the list?
15:38:57 <ivanm> luite: the "> " at the front of each line
15:39:15 <fragamus> the new states will be peers of the old states
15:39:32 <ivanm> as they're meant to look like the tracks left by birds' feet
15:39:52 <fragamus> i want to make a bunch of new states based on (weighted) random pairings of old states
15:39:57 <Eduard_Munteanu> fragamus: it sounds more like a politics question :P
15:39:59 <aavogt> @type \list -> do s <- get; map (execState s) list
15:40:00 <lambdabot> forall a a1. (MonadState (State a a1) []) => [a] -> [a]
15:40:15 <fragamus> hehe
15:40:20 <luite> ivanm: oh right... hmm, does pandoc have an alternative syntax for that?
15:40:22 <aavogt> @type \list -> do s <- get; map (flip execState s) list
15:40:22 <lambdabot> forall s a. (MonadState s []) => [State s a] -> [s]
15:40:48 <aavogt> @type \list -> do s <- get; return $ map (flip execState s) list  -- that should be right, finally
15:40:49 <lambdabot> forall s (m :: * -> *) a. (MonadState s m) => [State s a] -> m [s]
15:41:10 <ivanm> luite: indenting the entire paragraph 4 spaces
15:43:52 <aavogt> @unmtl StateT s [] a
15:43:52 <lambdabot> s -> [(a, s)]
15:44:15 <luite> ivanm: hmm, right, I'll have to find some way around that, don't know how though :)
15:45:04 <fragamus> I guess I might not be able to do it monadically
15:45:27 <fragamus> since the states are served up one at a time to a functor
15:45:39 <ivanm> luite: well, just use indentation rather than > to denote block quotes
15:46:00 <fragamus> I need a function that operates on the list as a whole
15:46:19 <luite> ivanm: hmm, yes but I'd like users to be able to > if they're used to that
15:46:22 <fragamus> and can do computations based on multiple states
15:46:59 <aavogt> > let plusMinus = StateT $ \s -> [((), s+1),((), s-1)] in flip execStateT 0 $ do plusMinus; plusMinus
15:47:04 <lambdabot>   mueval: ExitFailure 1
15:47:04 <lambdabot>  mueval-core: Time limit exceeded
15:47:48 <aavogt> > let plusMinus = StateT $ \s -> [((), s+1),((), s-1)] in flip execStateT 0 $ do plusMinus; plusMinus
15:47:50 <lambdabot>   [2,0,0,-2]
15:48:10 <aavogt> fragamus: that gets you multiple states
15:48:33 <fragamus> whoa
15:48:44 <fragamus> i cannot fathom it yet
15:49:08 <aavogt> starting with the state 0, it 'splits' the state up into one where it's incremented and one where it's decremented
15:49:14 <aavogt> and does it twice
15:49:36 <fragamus> ok
15:49:39 <adimit> Guys, what is the best way to track down why your code is producing VOID heap space?
15:49:55 <geheimdienst> aavogt: nice
15:50:06 <aavogt> the StateT is pretty useless here, since it's more direct to write it in []:
15:50:32 <aavogt> > let pm x = [x+1,x-1] in [0] >>= pm >>= pm
15:50:33 <lambdabot>   [2,0,0,-2]
15:50:54 <fragamus> i have about 1000 states at any given time, and I need to select about 200 pairs randomly and make 200 new states based on those pairs
15:51:27 <fragamus> and i also delete 200 states to keep it in equilibrium
15:53:00 <fragamus> also the thing that is selecting them has to examine the states
15:54:21 <aavogt> maybe somebody has a monad-based evolutionary algorithm (that actually simplifies the logic)
15:55:16 <fragamus> you got it
15:55:18 <aavogt> fragamus: is this supposed to happen in the background every time you do a more interesting computation?
15:55:48 <fragamus> the "interesting computation" is an evaluation of fitness
15:55:56 <fragamus> based on a simulation
15:56:11 <evaryont> System.IO.appendFile shouldn't truncate the target filepath, no?
15:56:20 <fragamus> I would not say that one or the other is in the background
15:57:07 <aavogt> stuff like distributing randomness is defnitely nicer done with a monad
15:57:33 <geheimdienst> evaryont: you mean very long FilePaths get cut off?
15:57:44 <fragamus> hmmm i think I cant do it monadically
15:58:27 <tg_> any lambdabot people here?
15:58:56 <fragamus> somebody beat up lambdabot earlier today
15:59:07 <tg_> i am trying to build him :o
15:59:13 <tg_> getting some errors that I don't get
15:59:28 <aavogt> paste them somewhere and we might be able to help
16:00:20 <tg_> about a thousand of them "Error .size expression for PluginziPlziCommon_Lambda_con_entry does not evaluate to a constant"
16:00:28 <tg_> for lots of different Pl plugins
16:00:34 <tg_> which I think is the pointfree refactoring stuff?
16:00:44 <Eduard_Munteanu> tg_: her
16:00:54 <tg_> Eduard_Munteanu: good point
16:01:20 <Eduard_Munteanu> @vixen tg_ has problems building you
16:01:20 <lambdabot> so, what do you think of me?
16:01:42 <tg_> I think you're broken inside.
16:01:54 <ski> preflex: zdec PluginziPlziCommon_Lambda_con_entry
16:01:54 <preflex>  Plugin.Pl.Common_Lambda_con_entry
16:02:08 <ddarius> zdec was hardly necessary for that
16:02:10 <tg_> can I just hack out all of the Plugin.Pl stuff somehow?
16:02:20 <aavogt> fragamus: you can passing a name for your 1000 states if you use (somewhere) StateT [State]
16:03:25 <fragamus> so I have a state that represents the whole, and a state for each individual right?
16:05:10 <aavogt> yeah, or have more layers to simulate populations which are separated somehow
16:05:48 <fragamus> so here is the type for one of my functors:
16:05:50 <aavogt> tg_: do you use the version from code.haskell.org?
16:06:11 <fragamus> schmove :: (RandomGen g) => Cards -> RandT g (StateT Creature []) Move
16:06:46 <fragamus> so you want me to put [State] instead of [] right?
16:06:53 <tg_> aavogt: I am using the version on hackage... I took out Pl
16:07:01 <tg_> aavogt: now Plugin.Activity is complaining about ncurses
16:07:07 <aavogt> @unmtl StateT g (StateT Creature []) m
16:07:07 <lambdabot> g -> Creature -> [(m, g, Creature)]
16:07:36 <geheimdienst> tg_: are you sure you have all the dependencies installed you need for building lambdabot?
16:07:44 <geheimdienst> (cabal might help with that)
16:07:55 <tg_> geheimdienst: no, I am starting to be sure that i do not
16:08:05 <tg_> geheimdienst: how do I say to cabal: install all dependencies but don't install the package
16:08:18 <Saizan> --deps-only
16:09:26 <tg_> Saizan: as a paramter to install?
16:10:16 <tg_> Saizan: ah, --only-dep
16:10:25 <aavogt> @unmtl StateT g (State [Creature]) m
16:10:25 <lambdabot> g -> [Creature] -> (m, g, [Creature])
16:10:28 <Eduard_Munteanu> If you need to transform each state based on the others simultaneously (and this is invariant to the order in which you do the transform), then perhaps a comonadic approach helps.
16:10:41 <Eduard_Munteanu> Somewhat like the cellular automata stuff done with comonads.
16:10:47 <fragamus> COMONADS!
16:10:48 <SailorReality> JOIN #UMATH FOR UNDERGRAD MATH KKK
16:11:07 <Eduard_Munteanu> Undergrad math Ku Klux Klan?
16:11:12 <mauke> yes
16:11:21 <mauke> I can't hardly wait to join
16:11:26 <Eduard_Munteanu> Hrm, the fraternities these days.
16:11:49 <fragamus> I need to learn about comonads, and I tried before but there is very very little on the subject
16:11:56 <evaryont> geheimdienst: ah, hello. nope; that the file is cleared before writing to it.
16:12:14 <Eduard_Munteanu> fragamus: I think this one is nice: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
16:13:17 <fragamus> I will read it
16:16:00 <evaryont> ah balls, appendFile behaves correctly.
16:16:19 <evaryont> probably something I'm doing. thanks
16:22:03 <tg_> geheimdienst: ok, so when I do cabal install --only-dependencies lambdabot, it says that it has none
16:22:06 <fragamus> so my "universe" is a matrix of creature pairs
16:22:40 <tg_> geheimdienst: which is clearly a lie, as the cabal file lists a ton of them
16:24:00 <dcoutts> tg_: can you paste what it says with the --dry-run flag, and with and without the --only-dependencies flag
16:26:47 <tg_> dcoutts: I could, but it's pretty short. --with-dependencies it says "No packages to be installed." without that flag, it says "In order, the following will be installed: lambdabot-4.2.3.2 (new package)"
16:26:59 <tg_> and thats with --verbose=2
16:27:05 <dcoutts> tg_: ok, sounds like it's working then
16:27:18 <dcoutts> tg_: ie all the deps really are installed. What makes you think they are not?
16:27:34 <tg_> dcoutts: it says readline isn't installed
16:27:59 <dcoutts> probably talking about a C lib, not a Haskell package
16:28:15 <geheimdienst> tg_: "ncurses" and "readline" sounds like libraries the system needs to provide. i don't think cabal can help you with that
16:28:29 <tg_> dcoutts: yeah, maybe. My /usr/lib/libncurses.so is just some text (-something)
16:29:04 <tg_> i bet this is a lib32 thing
16:29:08 <dcoutts> sounds like lambdabot has it's own binding to readline (rather than using one of the existing bindings)
16:30:04 <tg_> hm.
16:30:11 <tg_> ghc-pkg check reports all kinds of errors
16:30:13 <geheimdienst> possibly lambdabot depends on a haskell readline binding, with the haskell side installed and the c side missing ...?
16:30:16 <tg_> i'm gonna blow it all up and try again
16:30:26 <tg_> brb after bombing run
16:30:47 <Eduard_Munteanu> fragamus: matrix? Or simply a list?
16:44:49 <monochrom> @type map
16:44:50 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:05:35 <lispy> someone is trolling lambdabot again
17:05:36 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
17:06:07 <amindfv> can anyone recommend a package for word-completion?
17:06:13 <amindfv> GUI or command-line
17:06:28 <lispy> ivanm: I think saying that ByteString is a bad idea for pprint is driven from a desire to get people thinking about unicode.
17:06:36 <ivanm> amindfv: as in "here is a list of possible words that start with what you've already written" ?
17:06:38 <lispy> ivanm: But, String and Text still make sense
17:06:38 <ivanm> lispy: yeah
17:06:53 <amindfv> ivanm: exactly
17:07:12 <lispy> ivanm: I see their point, but the truth is, lots of things still use ByteString (legitemately) as String
17:07:45 <amindfv> either providing a list (like Leksah does), or simply "completing till uncertainty" (like ghci does when tabbing source file names)
17:07:48 <BMeph> amindfv: Google "PATRICIA". :)
17:08:03 <ivanm> amindfv: haven't heard of one; I suggest parsing in a dictionary and using a trie or something
17:08:17 <ivanm> lispy: same
17:08:17 <lispy> ivanm: Darcs falls into this category.  You can't dictate an encoding for patch data files, but the syntax of the patch data is ascii compatible (and hence utf-8 compat).  And it does make sense to use the pprint library in that case.  They actually use an older version
17:08:24 <ivanm> if people are going to do it anyway...
17:09:10 <lispy> they use the HughesPJ style pretty printer, but not one that is on hackage :(
17:09:46 <lispy> ivanm: I think the trick here is to make it so the users can use their favorate IsString instance
17:10:34 <lispy> and then you can be agnostic about it.  You can get on the high-horse yourself if someone uses ByteString and say, "well, why did you use ByteString for unicode?  my library is polymorphic and you could have used Data.Text" :)
17:10:53 <ivanm> lispy: you mean not requiring an extra type-class?
17:11:05 <ivanm> that would require having an IsString-agnostic builder...
17:11:09 <lispy> Well
17:11:12 <ivanm> which I don't think is possible
17:11:24 <amindfv> BMeph: thanks; that's definitely a data structure I'll want to use
17:11:32 <lispy> I'm honestly not such which way you're implementing it.  I've only been skimming the eamils
17:11:51 <lispy> But, hopefully if you use a type class then users can define instances
17:11:51 <amindfv> BMeph: pytestring-trie on hackage is a seemingly-working implementation
17:12:37 <ivanm> lispy: class (IsString source, Monoid (Builder source)) => Prettyable source where type Builder source; toBuilder :: source -> Builder source; fromBuilder :: Builder source -> source
17:12:38 <lispy> ivanm: I kind of use IsString as a short hand for, "some string type in Haskell"
17:12:42 <ivanm> heh
17:12:43 <tg_> omg i got it built!
17:13:12 <tg_> several issues, the first is the problem with the Plugin.Pl
17:13:21 <tg_> ah, damn. actually that's still there.
17:13:36 <ivanm> tg_: got what built?
17:13:41 <tg_> ivanm: lambdabot
17:13:57 <tg_> I took the Plugin.Pl out of the Modules.hs file, so when I did 'cabal build' it worked fine
17:14:02 <ivanm> s/it/her/ !
17:14:03 <tg_> but now when I do 'cabal install' it doesn't work
17:14:29 <iskren> so I have a record returning udf. What is the correct way to invoke it (with the appropriate type cast)
17:14:50 <ClaudiusMaximus> hm, i think approxRational :: Real a => a -> Rational -> (Rational, Rational) would be better as a method of Real than toRational, because the current approxRational calls toRational -> broken
17:15:16 <iskren> oops, wrong chat :)
17:15:37 <ivanm> lispy: all IsString gives you is a String -> a function
17:16:21 <ClaudiusMaximus> i ended up with something like: approxRational' q eps = let q' = q / eps in (fromInteger (floor q') * eps, fromInteger (ceiling q') * eps)
17:16:30 <lispy> ivanm: No no, it also gives lazy people a way to lump together the different string types :)
17:16:57 <lispy> ivanm: but yeah, literally using it in the instance head doesn't work
17:18:30 <ivanm> lispy: well, there isin't realy anything common between any of them apart from what IsString defines :s
17:19:20 <lispy> ivanm: would it make any sense to describe the bulk of the api for monoid?
17:19:27 <lispy> or do you need monoid + sequence?
17:19:36 <lispy> I guess you need a metric function
17:19:50 <ivanm> lispy: just a builder
17:19:52 <hpc> shouldn't IsString define a -> String too?
17:19:59 <ivanm> hpc: it doesn't
17:20:05 <hpc> :(
17:20:07 <ivanm> hpc: IsString exists solely for OverloadedStrings
17:20:24 <shachaf> @src IsString
17:20:24 <lambdabot> Source not found. Take a stress pill and think things over.
17:20:39 <shachaf> @src IsChar
17:20:39 <lambdabot> Source not found. :(
17:21:02 <hpc> overloaded chars would be interesting
17:21:35 <hpc> make Char an instance of Num
17:21:43 <hpc> and 'a' literals :: Num a => a
17:21:56 <lispy> ivanm: well, I have to run
17:22:11 <lispy> ivanm: um...use your best judgement.  I'm happy with using Text for my application
17:22:14 <hpc> > 5 == '5'
17:22:15 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:22:15 <lambdabot>    arising from the literal `5...
17:22:17 <geheimdienst> shachaf: it's something like: instance IsString Foo where fromString :: String -> Foo ; fromString someStringYouWroteInYourSourceCode = someReasonableConversionOfTheStringToAFoo
17:22:25 <lispy> ivanm: I was mostly just anticipating what others will say
17:22:29 * lispy leaves
17:23:15 <ivanm> lispy: OK then
17:25:02 <shachaf> geheimdienst: I know; I was hoping to compare it to IsChar.
17:25:21 <geheimdienst> i've never even heard of IsChar ...
17:25:33 <ivanm> geheimdienst: it's in printf
17:25:36 <shachaf> geheimdienst: It's used to make Text.Printf Haskell 98.
17:25:47 <geheimdienst> hm, interesting
17:25:47 <shachaf> instance IsChar a => PrintfType [a] where ...
17:39:37 <aavogt> has anybody called fortran from haskell? Is there any downside to going through c?
17:42:57 <Eduard_Munteanu> aavogt: there's probably the additional call sequence
17:43:45 <Eduard_Munteanu> Unless Fortran code gets inlined into C code.
17:44:02 <amindfv> can anyone point me to where the source-file-autocomplete is located, in the ghci source?
17:44:54 <aavogt> amindfv: it's quite likely that the code for that is in haskeline
17:46:16 <amindfv> aavogt: thank you! I'll look around
17:51:10 <aavogt> Eduard_Munteanu: as in this works, but it's really boring to write the bindings http://hpaste.org/47079/lm
17:51:36 <aavogt> if only something like f2py existed for haskell
17:53:46 <geheimdienst> i'd ask -cafe about that ... if anyone ever fortranned, i guess chances are they're not online right now
17:54:04 <amindfv> is there a way to nest guards?
17:54:37 <Eduard_Munteanu> Heh, you mean they're probably in their 60s and don't stay up late? :)
17:54:40 <ivanm> amindfv: not really
17:55:33 <geheimdienst> Eduard_Munteanu: i mean the number is small enough that at any time of day, there's not much chance to catch one in #haskell :)
17:55:37 <aavogt> > case () of _ | True, False -> case () of _ | True -> a; | True -> b
17:55:38 <lambdabot>   b
17:55:59 <Eduard_Munteanu> Anyway, it's still hell better than writing Agda bindings :/
17:56:15 <Cale> aavogt: I've called fortran code from Haskell just to see if it'd work. It does work, exactly the same way as calling C code.
17:56:15 * Eduard_Munteanu hasn't looked seriously into Haskell's FFI
17:56:59 <Cale> I used the fortran compiler from GCC.
17:57:11 <Eduard_Munteanu> Yeah, it's barebones like C and probably uses a standard ABI, no mangling or anything like that
17:57:18 <aavogt> Cale: but you've never seen any thing automating the bindings?
17:57:45 <aavogt> gfortran adds underscores after the name in the library
17:57:57 <Cale> I suppose the same tools as you'd use for C would work...
17:58:27 <Cale> Well, nothing that autogenerates bindings of course
17:58:27 <Eduard_Munteanu> I think you need to parse source code.
17:58:48 <Eduard_Munteanu> (since you kinda need to figure out parameter types)
17:59:08 <Cale> hmm
17:59:37 <Eduard_Munteanu> Or dunno, maybe DWARF symbols can deal with that.
18:01:16 <Cale> How much fortran code are we talking about here? Using the FFI directly isn't usually so bad.
18:02:13 <Cale> The hardest part of writing any binding is doing something to make up for the fact that libraries written for imperative languages are typically badly designed to begin with.
18:02:36 <ivanm> @remember Cale The hardest part of writing any binding is doing something to make up for the fact that libraries written for imperative languages are typically badly designed to begin with.
18:02:36 <lambdabot> Nice!
18:02:49 <Cale> (so, writing Haskell-side wrappers for things which make the interface nicer and hide mutation and so on)
18:05:40 <parcs> is there any reason why Iteratee doesn't have a MonadError instance? Should we be discouraged to use throwError within Iteratees?
18:09:14 <parcs> hmm never mind, it seems that such an instance requires the FlexibleInstances language extension. maybe that's why.
18:10:12 <geheimdienst> is using FlexibleInstances discouraged or something?
18:10:30 <parcs> and UndecidableInstances
18:10:43 <parcs> geheimdienst: well the enumerator package seems to use no language extensions
18:10:52 <parcs> maybe the author is trying to be pure haskell 98 or whatever
18:11:07 <geheimdienst> i see
18:14:31 <aavogt> there doesn't seem much point in avoiding extensions in your own code if you depend on features that are implemented with extensions
18:23:33 <fragamus> eduard are you here
18:26:05 <fragamus> Eduard_Munteanu: are you here?
18:28:38 <Eduard_Munteanu> Yeah...
18:29:49 <sw17ch> quick question for everyone: did any one here find it easier to pick up haskell because the community is pretty supporting of new people? was that a quality that you found useful when trying to learn?
18:31:49 <dylukes> So, I mentioned doing this earlier,
18:31:55 <dylukes> but I'm thinking about really getting around to doing it
18:32:10 <dylukes> There's the Kaleidoscope LLVM language implementation tutorial,
18:32:13 <dylukes> in C++ and OCaml
18:32:17 <dylukes> would anyone find use in a Haskell one?
18:33:02 <dylukes> I keep thinking maybe going through it and trying to write it out as a tutorial after actually doing it,
18:33:06 <Eduard_Munteanu> fragamus: note you can just ask the channel
18:33:09 <dylukes> might be a good way to reinforce the learned knowledge.
18:33:57 <fragamus> so i said matrix because
18:34:03 <geheimdienst> sw17ch: i think the community is a huge plus for haskell
18:34:11 <dolio> dylukes: Go for it.
18:34:24 <dylukes> I'm imagining it'd be relatively similar to the OCaml one.
18:34:29 <fragamus> there exists a triangular matrix that is the set of all possible pairings of items in a list
18:34:45 <dylukes> Except, the lexer can be automatically generated by Parsec.Language
18:34:55 <dylukes> and parsing is in general a bit simpler :)
18:35:01 <sw17ch> geheimdienst: when i was learning, i recall having a very hard time learning stuff on my own. it wasn't until i jumped onto #haskell that i really was able to start picking things up faster.
18:35:04 <geheimdienst> also see the thread on haskell-cafe from 1 or 2 days ago, subject "group hug". a guy said how he was trying out scala, which was met with derision by their mailing list ...
18:35:17 <sw17ch> that's what made me think about this.
18:35:18 <geheimdienst> same for me
18:35:18 <sw17ch> :)
18:36:55 <fragamus> im reading the comonad paper, its pretty thin, but well presented
18:37:42 <Eduard_Munteanu> fragamus: that link, or Uustalu & Vene's stuff?
18:37:51 <dolio> "The" comonad paper?
18:38:10 <fragamus> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
18:38:16 <Eduard_Munteanu> I linked him sigfpe's stuff on comonadic cellular automata.
18:38:28 <Eduard_Munteanu> (and IIRC sigfpe hints to a paper)
18:38:46 <fragamus> yeah
18:39:02 <fragamus> i shall tackle the paper next
18:41:14 <Eduard_Munteanu> That's not necessary.
18:41:33 <fragamus> @type join
18:41:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:43:02 <tg_> ok, I've got lambdabot up and running, but it just says "Terminated" whenever I try to do anything that would require mueval
18:43:21 <tg_> but I have that installed too...
18:48:09 <isomorphic> dylukes: re the llvm language implementation tutorial - great idea
18:48:26 <dylukes> isomorphic: Yeah, I'm quickly finding the "haskell" way to do things is a bit.. simpler
18:48:29 <dylukes> for the parsing/lexing at least
18:48:40 <dylukes> the lexer can be defined with Parsec.Expr and Parsec.Language in a couple lines.
18:48:47 <dylukes> And the parser is pretty easy.
18:49:02 <isomorphic> dylu: I'm writing a little parser in parsec at the moment, and I think that the llvm project has some awesome potential
18:49:31 <narens> I am trying out the simple example on the gtk2hs website, but I get the following error when running the example: (seq:23747): libglade-WARNING **: Expected <glade-interface>.  Got <interface>. Any ideas why?
18:49:33 <fragamus> @type join
18:49:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:49:35 <dylukes> Take a look at the stuff in Language and Expr and Token
18:49:37 <fragamus> @type cojoin
18:49:38 <lambdabot> Not in scope: `cojoin'
18:49:44 <dylukes> they're mostly "shortcuts" but useful :)
18:49:49 <dylukes> @type Control.Comonad.cojoin
18:49:50 <lambdabot> Couldn't find qualified module.
18:50:09 <dylukes> Not in lambdabot I guess
18:50:27 <dylukes> cojin is
18:50:27 <dylukes> Comonad w => w a -> (w a -> b) -> w b
18:50:30 <dylukes> in any cas.e
18:50:35 <dolio> Who does lexing anymore?
18:50:36 <dylukes> er wait
18:50:39 <dylukes> thats coreturn
18:50:40 <dylukes> dolio: :P
18:50:47 <dolio> That's for LR chumps.
18:51:14 <dolio> That type is for cobind.
18:51:25 <dolio> cojoin :: w a -> w (w a)
18:51:29 <dylukes> Yeah, I realized that.
18:51:37 <dylukes> my bad :P
18:51:43 <dylukes> coreturn is w a -> a
18:51:44 <dylukes> >_>
18:51:46 <dylukes> derp
18:51:47 <dolio> Yes.
18:51:49 <mauke> extract/extend
18:51:58 <fragamus> what package is cojoin in
18:52:07 <dolio> comonads, probably.
18:52:11 <dylukes> You know what I keep finding in this LLVM tutorial?
18:52:16 <dylukes> The way they do parsing, is soâ€¦ "unsafe"
18:52:18 <dylukes> Idk...
18:52:22 <dylukes> it feels less "secure" :P
18:52:31 <dylukes> Less strict.
18:52:48 <tg_> it has the word unsafe in it
18:53:18 <monochrom> fun, parsing is unsafe too
18:53:32 <dylukes> Well, it just says
18:53:39 <dylukes> "if a token can't be recognized, its a keyword"
18:53:40 <dylukes> .__.
18:53:44 <dylukes> I don't particularly like that.
18:53:49 <dylukes> Maybe this is just me XD
18:53:58 <dylukes> keyword or operator*
18:54:16 <dylukes> I mean
18:54:29 <dylukes> PT.reservedOps = ["+", "-", "*", "/"...]
18:54:30 <dylukes> so hard...
18:56:03 <dylukes> well, if I have time, I'll focus on this a bit.
18:56:09 <dylukes> I have other work to get done (that I'm payed for)
18:58:48 <dylukes> ololol, dolio
18:58:49 * hackagebot wai-app-file-cgi 0.2.0 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.2.0 (KazuYamamoto)
18:58:51 <dylukes> I finished the lexer :3
18:58:55 <dylukes> http://cl.ly/75qZ
18:58:57 <dylukes> so hard huh
18:59:33 <dolio> Looks pretty difficult.
18:59:44 <dylukes> >_>
19:00:38 <dolio> Are you going to be using the Haskell LLVM bindings?
19:00:41 <dylukes> Yeah.
19:00:53 <dolio> I should get around to looking at those some time.
19:01:19 <dolio> My experience with the back-end of compiler stuff is woefully underdeveloped.
19:01:28 <dylukes> Same here.
19:01:31 <dylukes> And I *need* to get familiar with it.
19:01:40 <dylukes> My IS next year, which has become my Senior Project,
19:01:48 <dylukes> is to write a general-purpose programming language ._.
19:01:51 <dylukes> So...
19:01:58 <dylukes> Better get cracking and learn the tools in advance :)
19:02:50 * hackagebot mighttpd2 2.2.0 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.2.0 (KazuYamamoto)
19:03:20 <tg_> ok, so what is the typical next step when ghc-pkg check shows problems
19:03:26 <dylukes> :3
19:03:28 <dylukes> oh this is rich
19:03:39 <dylukes> dolio: Take a look at the first example
19:03:41 <tg_> like show-0.4.1.1 and ueval-0.8.1 have problems because of quickcheck
19:03:44 <dylukes> under Mutable Variables in Kaleidoscope
19:03:44 <dylukes> http://llvm.org/docs/tutorial/LangImpl7.html
19:03:52 <dylukes> the ':' operator they're defining...
19:03:56 <dylukes> reminds me of *>
19:03:57 <dylukes> >_>...
19:04:05 <dylukes> APPLICATIVES. EVERYWHERE I LOOK.
19:04:18 <monochrom> it used to be "monads everywhere I look"
19:04:25 <dylukes> monochrom: Yeah ,that too.
19:04:30 <dylukes> I could say "reminds me of >>"
19:04:36 <dylukes> I've just been doing a lot of Parsec
19:04:40 <dylukes> so...
19:04:53 <monochrom> since there are more applicatives than there are monads, it is only going to be worse. I mean better!
19:04:58 <dylukes> D:
19:05:40 <dylukes> (do {foo; return x})
19:05:42 <dylukes> is much nicer as
19:05:51 <dylukes> (foo *> pure x)
19:05:53 <dylukes> imo
19:05:54 <dylukes> >_>
19:06:18 <dylukes> (or foo >> return x)
19:06:27 <dylukes> dunno, applicatives are pretty nice for control flow.
19:07:42 <fragamus> Eduard_Munteanu: so comonads deal with morphisms that point backwards
19:07:46 <dylukes> Anyways, I'm doing to sleep now.
19:08:30 <pmatey> Hello. I'm trying to load hoogle up in ghci and it is complaining about "Paths_hoogle". Does cabal generate something to do with Paths_package?
19:09:27 <Eduard_Munteanu> fragamus: that's not accurate (or informative)
19:10:27 <Eduard_Munteanu> fragamus: they're dual to monads, in the sense you flip arrows in return and >>=
19:11:12 <dolio> You have to be careful about which arrows you flip.
19:11:20 <dolio> Not all the arrows in the types are created equal.
19:12:57 <Saizan> pmatey: yep, it generates that module
19:14:26 <pmatey> Saizan: My googling isn't yielding any useful results. Do you know where can I find info on this "Paths_package" feature?
19:14:40 <ivanm> pmatey: Cabal user guide
19:14:48 <aavogt> when you configure it gets generated
19:15:05 <Saizan> i think it's generated during build, actually
19:15:11 <aavogt> maybe
19:15:29 <aavogt> another thing that's helpful to understand cabal is to ask it to be verbose when building
19:15:46 <aavogt> (so it prints out the flags to ghc that get it to include  dist/build/autogen...)
19:17:22 <ddarius> Eduard_Munteanu: They're co.  There's op where you flip 1-cells and co where you flip 2-cells.
19:19:48 <amindfv> anyone familiar with Haskeline?
19:27:12 <parcs> somewhat
19:29:44 <Eduard_Munteanu> fragamus: you might want to look for examples of comonads. Either that, or get into category theory. But the latter isn't probably the fastest way to go about solving your programming problem.
19:29:56 <amindfv> parcs: have you used the completeFilename or completeWord functions?
19:31:07 <parcs> no, i haven't
19:31:25 <amindfv> parcs: ok, thanks anyway
19:32:39 <parcs> ask your question anyway
19:38:18 <isomorphic> I'm trying to write a unit test for a parser - I'm having trouble with doing so with the IO monad.
19:38:25 <isomorphic> Could anybody suggest a fix for this code?
19:38:58 <isomorphic> http://hpaste.org/47080/testcase_with_io_monad
19:39:18 <isomorphic> I gather each line in the do block should have the same type
19:39:51 <isomorphic> but parseS has type parseS :: String -> [String]
19:39:59 <isomorphic> any thoughts?
19:40:41 <amindfv> parcs: I was trying to figure out how to use Haskeline's completion functions with a word list, instead of a list of directory contents
19:40:51 <ddarius> Why do you think each line of a do block should have the same type?
19:41:43 <amindfv> parcs: I'm understanding the code pretty well, but it looks like completeWord isn't fully written
19:41:49 <isomorphic> ddarius: I'm not sure - I guess because the lines chain together - perhaps it's okay for each line to have a type corresponding to the last line?
19:42:51 <isomorphic> I keep referring back to the (very helpful) monads as computation essay
19:42:57 <isomorphic> but I'm afraid i'm not quite there with monads ;)
19:43:06 <mauke> ignore monads
19:43:21 <mauke> use IO
19:43:50 <isomorphic> mauk: okay.  But my difficulty is then that I get something tainted with IO
19:44:21 <mauke> an IO String is not a String "tainted" with IO
19:44:48 <ivanm> it's an action that will return a String value via IO!
19:44:49 <mauke> it's also not an IO tainted with String
19:45:03 <isomorphic> my difficulty is getting something in the right form to make a TestList
19:45:21 <isomorphic> mauke: okay - that's helpful.  How should I get the string back out?
19:45:33 <mauke> isomorphic: you don't
19:45:39 <mauke> IO String doesn't contain a String
19:45:40 <isomorphic> I gathered from a few searches that I was stuck with the IO
19:46:00 <mauke> isomorphic: do you happen to know javascript?
19:47:18 <isomorphic>  ok.  That's helpful.
19:47:19 <isomorphic> mauk: I've messed around with jquery a little
19:47:21 <isomorphic> mauke* sorry
19:47:24 <isomorphic> Oh - I'll probably drop out in a sec
19:47:25 <isomorphic> So if I vanish, you know what happened ;)
19:48:15 <parcs> amindfv: well i would use a function like return . filter . flip isPrefixOf as a basis
19:48:31 <isomorphic> mauke, ivanm: can you point me to anything that would explain what I'm missing - understanding-wise?
19:48:42 <mauke> isomorphic: IO is all callback based
19:48:54 <parcs> :t return . filter . flip isPrefixOf
19:48:54 <lambdabot> forall (m :: * -> *) a. (Monad m, Eq a) => [a] -> m ([[a]] -> [[a]])
19:48:56 <mauke> just like async XMLHttpRequest in javascript
19:49:08 <parcs> :t return .L filter . flip isPrefixOf
19:49:09 <lambdabot> Not in scope: data constructor `L'
19:49:16 <parcs> :t return .: filter . flip isPrefixOf
19:49:17 <lambdabot> forall (m :: * -> *) a. (Monad m, Eq a) => [a] -> [[a]] -> m [[a]]
19:49:18 <ivanm> isomorphic: don't try to understand monads, just use them
19:49:30 <ivanm> and understand them from having used them enough
19:49:47 <ivanm> oh, and IO is a special case of monad; if you want to learn IO, learn IO; don't try to learn generic monad stuff
19:50:33 <monochrom> there are two kinds of "understand". the subjective kind is just a feeling and is self-deceiving. the objective kind is when someone poses you a problem you can solve it.
19:51:10 <monochrom> unfortunately most people just seek the subjective kind by repeatedly reading and writing vain words that solve no problem
19:51:12 * ddarius understands everything with violence.
19:52:40 <isomorphic> ivanm: :)
19:52:40 <isomorphic> mauke: Okay.  So, what is (broadly) the thing that I'm going to do to coerce my IO String into a TestList?
19:52:41 <isomorphic> call it somehow?
19:52:51 <isomorphic> monochrom: I see what you're saying - i'm trying to write a testcase
19:52:55 <mauke> you can't coerce IO String
19:53:20 <dmwit> isomorphic: Rather than dropping from IO String to String, think about lifting your functions that act on Strings to act on IO Strings instead.
19:53:38 <dmwit> We have two handy functions that together form a nice basis for doing this.
19:53:56 <monochrom> I haven't seen anyone applying Quickcheck to test IO things.
19:53:58 <dmwit> One is fmap :: Monad m => (a -> b) -> (m a -> m b).
19:54:05 <ddarius> monochrom: Look harder.
19:54:10 <dmwit> The other is (=<<) :: Monad m => (a -> m b) -> (m a -> m b).
19:54:16 <isomorphic> dmwit: cool, I'll look at liftM
19:54:23 <monochrom> well I don't use Quickcheck myself, so I don't really care
19:54:51 <isomorphic> dmwit: the limiting problem is that eventually, it seems like everything will end up "lifted"
19:54:57 <dmwit> Yes.
19:55:05 <dmwit> I don't see that this is a problem.
19:55:23 <isomorphic> dmwit: even main?
19:55:32 <dmwit> main :: IO (), yes
19:55:34 <mauke> main isn't even a function
19:56:42 <isomorphic> cool
19:57:07 <isomorphic> well, I'll look closely at those two functions
19:57:13 <isomorphic> thanks everybody for your help stepping me through this
19:57:37 <monochrom> "main = do { s <- getLine; putStrLn (f s) }" does not require "lifting" f, at least not by yourself
19:58:39 <isomorphic> monochrom: is that because main already has the type IO?
19:58:42 <parcs> isn't io a newtype wrapper over a state transformer?
19:58:48 <ddarius> No.
19:58:50 <mauke> parcs: no
19:58:53 <isomorphic> ie: it's the 'refactoring a block' rule?
19:59:05 <mauke> isomorphic: ?
19:59:08 <monochrom> it is because the do-notation already does the heavy lifting for you
19:59:18 * ddarius has no idea where isomorphic is getting this stuff.
19:59:21 <isomorphic> IO ()* rather
19:59:24 <mauke> not particularly heavy in this case
19:59:36 <mauke> @undo do { s <- getLine; putStrLn (f s) }
19:59:36 <lambdabot> getLine >>= \ s -> putStrLn (f s)
19:59:38 <ddarius> do-notation never does any heavy lifting.
19:59:52 <ddarius> @. pl undo do s <- getLine; putStrLn (f s)
19:59:52 <lambdabot> putStrLn . f =<< getLine
19:59:59 <ian_mi> mauke: getline >>= putStrLn . f
20:00:03 <monochrom> yeah, it bosses >>= to do the heavy lifting
20:00:10 <parcs> i wouldn't be asking such a silly question if hackage didn't point to intexistent documentation pages :(
20:00:12 <Axman6> @@ pl undo do { s <- getLine; putStrLn (f s)}
20:00:12 <lambdabot>  pl undo do { s <- getLine; putStrLn (f s)}
20:00:16 <ian_mi> wonder why undo makes it a lambda?
20:00:22 <Axman6> @. pl undo do { s <- getLine; putStrLn (f s)}
20:00:23 <lambdabot> putStrLn . f =<< getLine
20:00:30 <mauke> ian_mi: because that's what it does
20:00:36 <monochrom> at any rate you write your f as a normal non-IO function and worry nothing
20:00:50 <Axman6> ian_mi: that's how the desugaring rules are defined
20:01:18 <ian_mi> the implied question is why define the desugaring rules that way
20:01:20 <monochrom> it is desugaring all the way down
20:01:21 <ian_mi> but nevermind
20:01:34 <parcs> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
20:01:37 <blackdog> what's undo?
20:01:39 <parcs> at least it's represented that way
20:01:45 <mauke> parcs: in ghc maybe
20:01:48 <mauke> parcs: but it's a lie
20:01:56 <blackdog> ah, lambdabot desugarer.
20:01:56 <mauke> there is no RealWorld
20:03:06 <fragamus> Eduard_Munteanu: I did study category theory regarding monads
20:03:14 <dmwit> ian_mi: They are defined that way because it is more uniform.
20:03:20 <pikhq> parcs: That is little more than a model for thinking about IO and a model for making the type system shut up and cooperate.
20:03:30 <dmwit> ian_mi: For example, how do you desugar do { s <- getLine; print (s, s) }?
20:03:42 <fragamus> but I still havent grasped comonads
20:03:45 <mauke> getLine >>= print . join (,)
20:03:47 <dmwit> ian_mi: (hint: it's very straightforward with a lambda, and requires nontrivial computation if you want to avoid lambdas)
20:03:55 <ddarius> pikhq: It's neither of those things.
20:04:09 <pikhq> ddarius: Then do explain, so I may be less wrong.
20:04:56 <dmwit> mauke: Yep. But why require a potentially non-terminating algorithm when an O(1) algorithm works just fine?
20:04:57 <ddarius> pikhq: It's how GHC implements it as a hacky way of maintaining dependencies, and even that needs hacks to the optimizer to work correctly.  It has nothing at all to do with the type system.  It's a crappy way of thinking about IO.
20:05:24 <pikhq> ddarius: Okay, then.
20:05:58 <pikhq> Well, "terrible hack" suggests "no, you *really* don't want to look at this. It doesn't make your life any easier". :P
20:06:26 <ddarius> pikhq: That's a good way of describing the situation.
20:06:33 <pikhq> Mmkay, then.
20:10:58 * hackagebot kit 0.7.4 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.4 (NickPartridge)
20:16:16 <hydo> hrm... "There are these people, most of X work I am familiar with, but [further expanding on original point]"  X = whos?  My English is failing me at the moment.
20:17:37 <hydo> I'll just go with 'whos' and hope for the best.
20:18:52 <dmwit> It's spelled "whose".
20:19:08 <dmwit> I've never really understood English grammar, so I'm not 100% sure that's the right word.
20:19:17 <dmwit> But that's the right spelling.
20:21:08 <Axman6> I'd agree it's whose as well
20:21:49 <Axman6> (both spelling and it's appropriateness)
20:22:19 <hydo> damn, I think whose is right.  Oh well, too late.  Email sent.
20:22:31 <hydo> I'll try to remember it for next time.
20:22:42 <shachaf> Axman6: Unless you mean "it is appropriateness", it may not be a good idea to take advice on the matter from you. :-)
20:22:55 <Axman6> uh, its* =)
20:23:03 <hydo> hah
20:23:10 * Axman6 has only just worken up
20:23:11 <ddarius> Best to ask a non-native speaker.
20:23:19 <Axman6> ddarius: heh, this is true
20:23:23 <Eduard_Munteanu> But hes right!
20:23:25 <Eduard_Munteanu> :P
20:23:28 <hydo> ddarius: hah... so true.
20:23:35 * shachaf wonders whether he qualifies as a native speaker or not.
20:23:54 <ddarius> shachaf: Did you grow up speaking English?
20:24:19 <shachaf> ddarius: I'm told it was the first language I spoke, but then I didn't speak it from ages ~(3-11).
20:24:30 <ddarius> Hmm, that is tricky.
20:31:30 <tg_> shachaf: I never believe those kinds of things...
20:33:37 * ddarius never believes things of kind (* -> *) -> *.
21:01:24 <copumpkin> :t mystery
21:01:25 <lambdabot> forall a (m :: * -> *). (Monad m) => [[a] -> m a] -> m [a]
21:01:32 <copumpkin> :O
21:01:38 <copumpkin> what could it be!
21:02:09 <shachaf> @ty let m :: (Monad m) => [[a] -> m a] -> m [a]; m = m -- Go back to #agda.
21:02:10 <lambdabot> <no location info>:
21:02:10 <lambdabot>     not an expression: `let m :: (Monad m) => [[a] -> m a] -> m [a]; m = m'
21:02:15 <shachaf> @ty let m :: (Monad m) => [[a] -> m a] -> m [a]; m = m in m -- Go back to #agda.
21:02:15 <lambdabot> forall a (m :: * -> *). (Monad m) => [[a] -> m a] -> m [a]
21:02:24 <copumpkin> :(
21:03:03 <shachaf> Actually, that's a weird type.
21:03:19 <ddarius> :t sequence . map ($[])
21:03:20 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [[a1] -> m a] -> m [a]
21:03:30 <dolio> loebM?
21:04:05 <dibblego> @type Data.Traversable.traverse ($ pure)
21:04:06 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t, Applicative f1) => t ((a -> f a) -> f1 b) -> f1 (t b)
21:04:24 <shachaf> @ty sequence . (`sequence` [])
21:04:25 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [[a1] -> m a] -> m [a]
21:04:28 <dibblego> er no
21:04:43 <copumpkin> @let zomg [] = Identity 1; zomg [_] = Identity 1; zomg xs = let i = length xs - 1 in Identity $ (xs !! (i - 1)) + (xs !! i)
21:04:44 <lambdabot>  Defined.
21:04:51 <dibblego> @type Data.Traversable.traverse ($ mempty)
21:04:52 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Monoid a, Data.Traversable.Traversable t, Applicative f) => t (a -> f b) -> f (t b)
21:05:15 <copumpkin> > runIdentity (mystery (repeat zomg))
21:05:16 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
21:05:38 <copumpkin> > runIdentity ((sequence . map ($[])) (repeat zomg))
21:05:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:05:53 <copumpkin> :O
21:05:56 <copumpkin> what could it be!
21:07:54 <Jafet> > mystery (0:)
21:07:55 <lambdabot>   Couldn't match expected type `[[a] -> m a]'
21:07:55 <lambdabot>         against inferred type `...
21:08:05 <tg_> copumpkin: you can't see it, but there's a 2 10^9000 places later
21:08:13 <copumpkin> tg_: I hope not!
21:08:14 <Jafet> > mystery [(0:),(1:)]
21:08:16 <lambdabot>   [[0,1],[0,0]]
21:08:21 <tg_> copumpkin: you can't prove me wrong
21:08:32 <copumpkin> tg_: you assume I don't know the definition to mystery!
21:08:48 <copumpkin> and since I do know the definition, I could probably prove you wrong with some difficulty
21:08:50 <tg_> copumpkin: I assume your computer can't calculate the 10^9000th place of any number
21:09:02 <copumpkin> a proof doesn't need to be able to do that
21:09:08 <tg_> copumpkin: true
21:09:22 <tg_> copumpkin: but I could just say that I'm not satisfied without a demonstration, but then I'd be an ass
21:09:26 <copumpkin> for example, I could prove that the values are monotonically increasing
21:09:38 <copumpkin> (which they appear to be)
21:09:39 <tg_> copumpkin: yes
21:09:45 <shachaf> copumpkin: You know the definition to mystery, but do you know all of the source to GHC?
21:09:51 <tg_> @oeis 1 1 2 3 5 8 13 21 34 55 89
21:09:51 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
21:09:52 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:09:54 <shachaf> I wouldn't be surprised if they put a copumpkin special case in there just for you.
21:10:04 <tg_> i thought those looked familiar
21:10:06 <copumpkin> shachaf: oh yes, of course
21:10:54 <tg_> I know a sequence of numbers that OEIS doesn't
21:11:13 <tg_> @oeis 0 0 0 -1 2 2 3 4 8 8 9
21:11:14 * ddarius doesn't know how long the book he's reading is.
21:11:15 <lambdabot>  Sequence not found.
21:11:17 <copumpkin> tg_: I'm sure you know many
21:11:20 <tg_> well
21:11:29 <copumpkin> @oeis 4 8 15 16 23 42
21:11:29 <lambdabot>  The Lost Numbers.
21:11:29 <lambdabot>  [4,8,15,16,23,42,108]
21:11:31 <tg_> I know an infinte, monotonically increasing sequence
21:11:43 <tg_> that is dense above 100000
21:12:00 <tg_> @oeis 0 0 0 1 2 2 3
21:12:06 <lambdabot>  Irregular triangle read by rows: floor(j^2 / p) for p prime and j = 1:p-1
21:12:07 <lambdabot>  [0,0,1,0,0,1,3,0,0,1,2,3,5,0,0,0,1,2,3,4,5,7,9,0,0,0,1,1,2,3,4,6,7,9,11,0,0,...
21:12:11 <tg_> wrong
21:12:43 <dolio> @oeis 1 22 7 9 1002
21:12:43 <lambdabot>  Sequence not found.
21:12:45 <shachaf> @oeis 8 75 3 9
21:12:45 <lambdabot>  Sequence not found.
21:12:48 <shachaf> WRONG.
21:12:53 <shachaf> Even dankna could answer that one.
21:12:55 <tg_> well, I actually have an equation
21:12:58 <tg_> that defines my sequence
21:13:17 <tg_> 2(a^2 + b^2 + c^2 + d^2) -(a + b + c + d)^2 = 0
21:13:20 <copumpkin> numberwang, eh
21:13:50 <Rotaerk> thaaat's numberwang
21:14:21 <Rotaerk> @oeis 1 2
21:14:30 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
21:14:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:14:35 <tg_> lol numberwang @ youtube
21:14:47 <tg_> @oeis 137/60
21:14:47 <lambdabot>  Number of partitions of n into parts not less than the smallest prime factor...
21:14:47 <lambdabot>  [1,1,1,2,1,4,1,7,4,12,1,21,1,34,17,55,1,88,1,137,60,210,1,320,30,478,191,708...
21:20:22 <lispy_> halo!
21:21:14 <copumpkin> > numberwang [1,1,1,2,1,4,1,7,4,12,1,21,1,34,17,55,1,88,1,137,60]
21:21:15 <lambdabot>   True
21:21:29 <shachaf> > numberwang []
21:21:31 <lambdabot>   False
21:21:33 <lispy_> ?oeis [1,1,1,2,1,4,1,7,4,12,1,21,1,34,17,55,1,88,1,137,60
21:21:33 <lambdabot>  Sequence not found.
21:21:38 <shachaf> > numberwang [1,1,2,3,5]
21:21:39 <lispy_> ?oeis 1,1,1,2,1,4,1,7,4,12,1,21,1,34,17,55,1,88,1,137,60
21:21:39 <lambdabot>  Number of partitions of n into parts not less than the smallest prime factor...
21:21:39 <lambdabot>  [1,1,1,2,1,4,1,7,4,12,1,21,1,34,17,55,1,88,1,137,60,210,1,320,30,478,191,708...
21:21:39 <lambdabot>   True
21:23:42 <copumpkin> > isItNumberwang []
21:23:44 <lambdabot>   Not in scope: `isItNumberwang'
21:24:00 <shachaf> > numberwang [copumpkin]
21:24:02 <lambdabot>   True
21:24:02 <copumpkin> > isItNumberwang []
21:24:03 <lambdabot>   Not in scope: `isItNumberwang'
21:24:08 <copumpkin> shachaf: asshole
21:24:20 <shachaf> :-(
21:24:33 <copumpkin> > isItNumberwang [2,1,21,1,34,17,55,1,88,1,137]
21:24:35 <lambdabot>   That's numberwang!
21:24:38 <copumpkin> shachaf: :)
21:24:57 <shachaf> > isItNumberwang [copumpkin]
21:24:57 <lispy_> what the heck is numberwang?
21:24:58 <lambdabot>   Not in scope: `copumpkin'
21:25:12 <shachaf> copumpkin: Are you @undefining things?
21:25:18 <copumpkin> shachaf: you did!
21:25:25 <shachaf> copumpkin: Huh? No I didn't.
21:25:28 <copumpkin> :O
21:25:34 <shachaf> 21:37 <shachaf> @let copumpkin = 2
21:25:34 <shachaf> 21:37 <lambdabot> Plugin `eval' failed with: .L.hs: getSymbolicLinkStatus: does not exist (No such file or directory)
21:25:41 <copumpkin> :O
21:25:43 <copumpkin> whoa
21:25:48 <copumpkin> never seen that error before
21:25:55 <copumpkin> > isItNumberwang shachaf
21:25:57 <lambdabot>   Oh, bad luck! That's not numberwang
21:26:03 <shachaf> @slap copumpkin
21:26:03 * lambdabot hits copumpkin with an assortment of kitchen utensils
21:26:24 <copumpkin> I dare you to reverse engineer numberwang
21:27:48 <shachaf> > numberwang []
21:27:50 <lambdabot>   False
21:27:54 <shachaf> Huh?
21:28:01 <shachaf> It's dying in /msg.
21:28:03 <shachaf> Ah, there.
21:28:49 <lispy_> ?oeis 2,1,21,1,34,17,55,1,88,1,137
21:28:50 <lambdabot>  Sequence not found.
21:28:54 <lispy_> whoa
21:29:00 <lispy_> numberwang is not in oeis?
21:29:07 <Axman6> :t numberwang
21:29:09 <lambdabot> forall a. (Integral a) => [a] -> Bool
21:29:11 <copumpkin> numberwang is so much more than a sequence
21:29:17 <shachaf> @oeis 2 1 21 1 34 17 55 1 88 1 137
21:29:18 <lambdabot>  Sequence not found.
21:29:29 <lispy_> oeis is pretty input tolerant
21:29:36 <lispy_> ?oeis 1,1,2,3
21:29:36 <Axman6> @test not . numberwang
21:29:36 <lambdabot> Maybe you meant: let list tell
21:29:44 <Axman6> @check not . numberwang
21:29:51 <lambdabot> Plugin `oeis' failed with: thread killed
21:29:51 <lambdabot>   Not in scope: `numberwang'
21:29:56 <Axman6> :(
21:30:03 <lispy_> are you guys overloading lambdabot again?
21:30:12 <copumpkin> sorry, that was me before
21:30:29 <lispy_> ?oeis 1,1,2,3
21:30:45 <lambdabot> Plugin `oeis' failed with: thread killed
21:30:50 <Axman6> D:
21:31:01 <copumpkin> lispy_: it may just be throttling connections from lambdabot's ip
21:31:06 <lispy_> hmm
21:31:06 <lispy_> yeah
21:31:12 <lispy_> top doesn't show anything weird
21:31:18 <copumpkin> > numberwang [1,2,4]
21:31:18 <Jafet> @vixen are you being overloaded?
21:31:19 <lambdabot> yes, i am
21:31:19 <lambdabot>   False
21:31:26 <copumpkin> > isItNumberwang [1,2,4,1]
21:31:27 <lambdabot>   Oh, bad luck! That's not numberwang
21:31:30 <copumpkin> > isItNumberwang [1,2,4,1,2]
21:31:32 <lambdabot>   That's numberwang!
21:31:37 <tg_> who defined numberwang lol
21:31:50 <shachaf> > map numberwang . map (\n -> replicate n 0) $ [1..10]
21:31:51 <lambdabot>   [True,False,True,False,True,False,True,False,True,False]
21:31:54 <shachaf> > map numberwang . map (\n -> replicate n 1) $ [1..10]
21:31:55 <lambdabot>   [False,False,False,False,False,False,False,False,False,False]
21:33:19 <shachaf> @yhjulwwiefzojcbxybbruweejw
21:33:19 <lambdabot> Exception: <<loop>>
21:33:21 <shachaf> @yhjulwwiefzojcbxybbruweejw
21:33:21 <lambdabot> "\"#$%&'()*+,\""
21:33:24 <shachaf> @yhjulwwiefzojcbxybbruweejw
21:33:24 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
21:33:26 <shachaf> @yhjulwwiefzojcbxybbruweejw
21:33:26 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
21:33:54 <lispy_> > fix show
21:33:54 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:34:09 <lispy_> @yhjulwwiefzojcbxybbruweejw
21:34:09 <lambdabot> "\"#$%&'()*+,\""
21:34:52 <Jafet> > filter numberwang $ replicateM 3 [0..10]
21:34:53 <lambdabot>   [[0,0,0],[0,0,2],[0,0,4],[0,0,6],[0,0,8],[0,0,10],[0,1,1],[0,1,3],[0,1,5],[...
21:35:08 <shachaf> copumpkin: @check can't see numberwang. :-(
21:35:14 <Jafet> > filter numberwang $ replicateM 3 [1..10]
21:35:14 <copumpkin> shachaf: ah well :)
21:35:16 <lambdabot>   [[1,1,2],[1,1,4],[1,1,6],[1,1,8],[1,1,10],[1,2,1],[1,2,3],[1,2,5],[1,2,7],[...
21:35:21 <Axman6> @check not . numberwang
21:35:21 <lambdabot>   Not in scope: `numberwang'
21:35:25 <Axman6> :(
21:35:56 <Axman6> @vixen why don't you love me lambdabot
21:35:56 <lambdabot> maybe i will one day
21:36:00 <Axman6> :'(
21:36:03 <shachaf> Ouch.
21:36:51 <Jafet> @vixen is love unsafe?
21:36:53 <lambdabot> good question
21:37:12 <Axman6> > 2^62
21:37:13 <lambdabot>   4611686018427387904
21:37:37 <lispy_> ?check not . L.numberwang
21:37:38 <lambdabot>   Not in scope: `L.numberwang'
21:38:02 <Jafet> Numberwang roulette?
21:39:58 <shachaf> > numberwang [1,2]
21:39:59 <lambdabot>   False
21:40:01 <shachaf> What?
21:40:04 <shachaf> Hmph.
21:40:25 <Axman6> > numberwang [0,0,0]
21:40:27 <lambdabot>   True
21:40:29 <Axman6> > numberwang [0,0,1]
21:40:31 <lambdabot>   False
21:40:33 <Axman6> > numberwang [0,0,2]
21:40:34 <shachaf> > numberwang [0,1,2]
21:40:34 <lambdabot>   True
21:40:35 <lambdabot>   False
21:40:42 <Axman6> > numberwang [0,1,2]
21:40:44 <lambdabot>   False
21:40:46 <shachaf> > (text "blah",numberwang [0,1,2])
21:40:46 <Axman6> > numberwang [0,2,2]
21:40:47 <lambdabot>   (blah,False)
21:40:48 <lambdabot>   True
21:41:05 <Axman6> numberwang = even . sum?
21:41:13 <Axman6> :t even
21:41:13 <lambdabot> forall a. (Integral a) => a -> Bool
21:41:13 <shachaf> Axman6: Nope.
21:41:29 <Axman6> > numberwang [1,2,2]
21:41:29 <lambdabot>   False
21:41:29 <shachaf> > take 20 $ filter numberwang $ subsequences [0,1,2,3,4,5]
21:41:47 <Axman6> > numberwang [3,2,2]
21:41:47 <lambdabot>   [[0],[2],[0,1,3],[1,2,3],[4],[0,2,4],[1,3,4],[0,1,2,3,4],[0,1,5],[1,2,5],[0...
21:41:47 <lambdabot>   False
21:41:47 <shachaf> > map numberwang . map (\n -> replicate n 0) $ [1..10]
21:41:47 <lambdabot>   [True,False,True,False,True,False,True,False,True,False]
21:42:10 <shachaf> It's also not odd . length . filter even or something like that.
21:42:13 <Axman6> > numberwang [3,2,2,0]
21:42:14 <lambdabot>   False
21:42:34 <Axman6> if the length is odd, the sum should be even, and vice versa?
21:42:45 <lispy_> > numberwang [2,3,2]
21:42:46 <lambdabot>   False
21:42:58 <lispy_> > numberwang [1,3,2]
21:42:59 <lambdabot>   True
21:43:19 <lispy_> So, at least the elements can be permuted without changing the wanginess
21:43:37 <shachaf> lispy_: Not true.
21:43:45 <lispy_> > numberwang [3,2,1]
21:43:46 <lambdabot>   True
21:43:50 <lispy_> hmm, okay
21:44:02 <lispy_> Seemed observationally true
21:44:06 <shachaf> Wait, maybe it is true.
21:44:11 <Axman6> > let f xs = odd (length xs) && even (sum xs) || even (length xs) && odd (sum xs) in all f . filter numberwang . permutations $ [1..10]
21:44:15 <lambdabot>   mueval-core: Time limit exceeded
21:44:19 <Axman6> > let f xs = odd (length xs) && even (sum xs) || even (length xs) && odd (sum xs) in all f . filter numberwang . permutations $ [1..5]
21:44:20 <copumpkin> :O
21:44:20 <lambdabot>   True
21:44:22 <c_wraith> > all numberwang $ permutations [1,2,3]
21:44:24 <lambdabot>   True
21:44:25 * Axman6 wins
21:44:39 <Axman6> > permutations [1,2,3]
21:44:40 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
21:44:41 <Axman6> hmm
21:44:48 <copumpkin> > all numberwang $ permutations [1,2,3,4,5]
21:44:49 <lambdabot>   False
21:44:53 <Eduard_Munteanu> Are you trying to DDoS lispy?
21:44:58 <shachaf> > any numberwang . permutations $ [1..5]
21:44:59 <lambdabot>   False
21:45:05 <Axman6> huh
21:45:08 <shachaf> Axman6: Interesting way of winning you've got there.
21:45:09 <Axman6> there goes that idea
21:45:22 * Axman6 unwins
21:45:58 <Eduard_Munteanu> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
21:46:00 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
21:46:12 <lispy_> ?let fap = fmap
21:46:13 <lambdabot>  Defined.
21:46:16 <lispy_> :t fap fap fap
21:46:17 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:47:10 <Eduard_Munteanu> :t . . .
21:47:11 <lambdabot> parse error on input `.'
21:47:27 <lispy_> :t (.) . (.)
21:47:27 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:47:30 <Eduard_Munteanu> :t (.) (.) (.)
21:47:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:48:21 <copumpkin> > numberwang [2]
21:48:22 <lambdabot>   True
21:48:42 <lispy_> > numberwang [6]
21:48:43 <lambdabot>   True
21:49:05 <copumpkin> > numberwang [2]
21:49:06 <lambdabot>   False
21:49:09 <Axman6> who write numberwang?
21:49:16 <copumpkin> there was a bug in numberwang
21:49:16 <Axman6> whut
21:49:18 <copumpkin> it is now fixed
21:49:20 <copumpkin> sorry about that
21:49:25 <shachaf> @slap copumpkin
21:49:25 * lambdabot smashes a lamp on copumpkin's head
21:49:28 * shachaf is done.
21:49:28 <copumpkin> :(
21:49:28 <lispy_> > numberwang [6]
21:49:29 <lambdabot>   False
21:49:33 <lispy_> hmm
21:49:34 <shachaf> > numberWang [anyEvenNumber]
21:49:34 <lambdabot>   Not in scope: `numberWang'
21:49:41 <shachaf> > numberwang [anyEvenNumber]
21:49:42 <lambdabot>   False
21:49:59 <lispy_> ?check \x -> even x ==> numberwang [x]
21:49:59 <lambdabot>   Not in scope: `numberwang'
21:50:04 <lispy_> oh right
21:50:05 <Axman6> > numberwang [anyEvenNumber, anyEvenNumber]
21:50:07 <lambdabot>   False
21:50:09 <lispy_> how quickly do I forget
21:50:14 <Axman6> > numberwang [anyEvenNumber, anyEvenNumber - 1]
21:50:15 <lambdabot>   False
21:50:32 <shachaf> ...You know that "anyEvenNumber" doesn't *really* check all even numbers, right?
21:50:38 <lispy_> what??
21:50:39 <copumpkin> shachaf: omg
21:50:43 <dmwit> :t numberwang
21:50:44 <lambdabot> forall a. (Integral a) => [a] -> Bool
21:50:49 <shachaf> > filter numberwang $ subsequences [0,1,2,3,4,5]
21:50:50 <lambdabot>   [[1,2,3],[1,3,4],[1,2,5],[1,4,5],[3,4,5]]
21:50:51 <lispy_> > mind == blown
21:50:51 <lambdabot>   Not in scope: `mind'Not in scope: `blown'
21:50:56 <dmwit> It might, with a suitable Integral instance.
21:50:58 <shachaf> > filter numberwang $ subsequences [0,1,2,3,4,5,6,7]
21:51:00 <lambdabot>   [[1,2,3],[1,3,4],[1,2,5],[1,4,5],[3,4,5],[1,3,6],[1,2,3,4,6],[1,5,6],[3,5,6...
21:51:25 <shachaf> > map numberwang . map (\n -> replicate n 0) $ [1..10]
21:51:26 <lambdabot>   [False,False,False,False,False,False,False,False,False,False]
21:51:27 <shachaf> > map numberwang . map (\n -> replicate n 1) $ [1..10]
21:51:29 <lambdabot>   [False,False,False,False,False,False,False,False,False,False]
21:51:55 <shachaf> @ty anyEvenNumber
21:51:55 <lambdabot> forall t. (Num t) => t
21:52:01 <shachaf> dmwit: Nope.
21:52:03 <copumpkin> it's definitely any number
21:52:05 <copumpkin> it says so!
21:52:08 <Axman6> > anyEvenNumber
21:52:09 <lambdabot>   8
21:52:16 <copumpkin> > anyEvenNumber
21:52:18 <lambdabot>   8
21:52:19 <copumpkin> > anyEvenNumber
21:52:21 <lambdabot>   8
21:52:22 <copumpkin> man, we have good luck!
21:52:25 <lispy_> > filter (odd . length) (filter numberwang $ subsequences [0..7])
21:52:26 <lambdabot>   [[1,2,3],[1,3,4],[1,2,5],[1,4,5],[3,4,5],[1,3,6],[1,2,3,4,6],[1,5,6],[3,5,6...
21:52:44 <lispy_> > all (odd . length) (filter numberwang $ subsequences [0..7])
21:52:45 <lambdabot>   True
21:52:48 <shachaf> > filter (even . length) $ filter numberwang $ subsequences [0,1,2,3,4,5,6,7]
21:52:49 <lambdabot>   []
21:52:53 <copumpkin> zomg
21:53:01 <shachaf> > filter (even . length) $ filter numberwang $ subsequences $ join (++) [0,1,2,3,4,5,6,7]
21:53:02 <lambdabot>   []
21:53:18 <lispy_> > all (odd . length) (filter numberwang $ subsequences [0..8])
21:53:19 <lambdabot>   True
21:53:23 <lispy_> > all (odd . length) (filter numberwang $ subsequences [1..8])
21:53:24 <lambdabot>   True
21:53:34 <lispy_> > (filter numberwang $ subsequences [1..8])
21:53:35 <lambdabot>   [[1,2,3],[1,3,4],[1,2,5],[1,4,5],[3,4,5],[1,3,6],[1,2,3,4,6],[1,5,6],[3,5,6...
21:53:46 <lispy_> hmmm
21:54:11 <lispy_> > (sum [1,2,3]) `mod` 3
21:54:12 <lambdabot>   0
21:54:25 <lispy_> > (sum [1,3,4]) `mod` 3
21:54:26 <lambdabot>   2
21:54:47 <lispy_> > (sum [1,2,3,4,6]) `mod` 3
21:54:47 <lambdabot>   1
21:54:51 <lispy_> > (sum [1,2,3,4,6]) `mod` 5
21:54:52 <lambdabot>   1
21:54:53 <shachaf> copumpkin: Can we have the old numberwang back?
21:54:56 <shachaf> I liked that one better.
21:55:02 <copumpkin> that was broken
21:55:10 <copumpkin> the new one just has one additional condition
21:55:26 <shachaf> @djinn (Integral a) => [a] -> Bool
21:55:26 <lambdabot> Error: Undefined type []
21:55:33 <shachaf> @djinn Maybe a -> Bool
21:55:34 <lambdabot> f a =
21:55:34 <lambdabot>     case a of
21:55:34 <lambdabot>     Nothing -> False
21:55:34 <lambdabot>     Just _ -> True
21:55:44 <shachaf> That's numberwang!
21:55:52 <lispy_> ?djinn List Int -> Bool
21:55:52 <lambdabot> Error: Undefined type List
21:55:58 <lispy_> ?djinn-types
21:55:58 <lambdabot> Unknown command, try @list
21:56:06 <shachaf> @djinn-env
21:56:07 <lambdabot> data () = ()
21:56:07 <lambdabot> data Either a b = Left a | Right b
21:56:07 <lambdabot> data Maybe a = Nothing | Just a
21:56:07 <lambdabot> data Bool = False | True
21:56:07 <lambdabot> data Void
21:56:08 <Axman6> @dj
21:56:08 <lambdabot> type Not x = x -> Void
21:56:11 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver do
21:56:13 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
21:56:14 <lambdabot> class Eq a where (==) :: a -> a -> Bool
21:56:35 <shachaf> @djinnahandarie
21:56:35 <lambdabot> Unknown command, try @list
21:56:38 <lispy_> ?djinn-add data List a = Nil | List a (List a)
21:56:38 <lambdabot> Error: Recursive types are not allowed: List
21:56:48 <Axman6> @djinn Monad m => m a -> (a -> m b) -> m b
21:56:48 <lambdabot> f = (>>=)
21:58:30 <shachaf> copumpkin: What was the old numberwang?
21:58:52 <copumpkin> that would tell you too much about the new numberwang
21:59:00 <copumpkin> I'll tell you that it only wants lists of odd lengths
21:59:11 <lispy_> Hey, I already discovered that
21:59:13 <shachaf> We figured that part out already.
21:59:24 <copumpkin> you didn't prove it
21:59:28 <shachaf> (Unless the list contains the element 518, of course.)
21:59:34 <copumpkin> :P
21:59:39 <shachaf> (But that goes without saying.)
22:00:32 <lispy_> > numberwang [f]
22:00:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:00:33 <lambdabot>    `GHC.Real.Integral a'
22:00:33 <lambdabot>   ...
22:00:42 <lispy_> > numberwang [f] :: Expr
22:00:43 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
22:00:43 <lambdabot>         against inferred ...
22:00:51 <lispy_> :t numberwang
22:00:52 <lambdabot> forall a. (Integral a) => [a] -> Bool
22:00:55 <lispy_> hmm
22:01:17 <lispy_> > numberwang [f::Expr]
22:01:19 <lambdabot>   False
22:01:39 <lispy_> > numberwang ([a,b,c]::[Expr])
22:01:40 <lambdabot>   False
22:01:58 <shachaf> > even a
22:01:58 <lambdabot>   False
22:02:09 <Axman6> > odd a
22:02:10 <lambdabot>   True
22:02:16 <shachaf> > (o, even a numberwang)
22:02:17 <lambdabot>   Couldn't match expected type `([a] -> GHC.Bool.Bool) -> t'
22:02:17 <lambdabot>         against ...
22:02:20 <Axman6> > odd (a+1)
22:02:20 <lambdabot>   True
22:02:24 <Axman6> :O
22:02:30 <lispy_> nice
22:02:34 <Axman6> how can this be!
22:02:40 <shachaf> Axman6: Not difficult.
22:02:41 <lispy_> > (odd a, odd (suc a))
22:02:41 <Axman6> > [a..b]
22:02:41 <lambdabot>   Not in scope: `suc'
22:02:42 <lambdabot>   *Exception: not a number
22:02:46 <lispy_> > (odd a, odd (succ a))
22:02:47 <lambdabot>   (True,True)
22:03:40 <lispy_> ?check \x -> odd x == odd (succ x)
22:03:41 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
22:05:38 <lispy_> > numberwang [a,a,a]
22:05:39 <lambdabot>   False
22:06:01 <Axman6> > odd (a+a)
22:06:02 <lambdabot>   True
22:06:22 <lispy_> > odd $ a `div` a
22:06:23 <lambdabot>   True
22:06:33 <lispy_> > odd $ a `mod` a
22:06:34 <lambdabot>   True
22:07:00 <lispy_> > numberwang [1,2,3]
22:07:01 <lambdabot>   True
22:07:04 <lispy_> > numberwang [a,2,3]
22:07:05 <lambdabot>   False
22:07:37 <lispy_> why is this is addictive
22:07:53 <lispy_> I'm sure everyone here hates all the numberwang spam
22:08:00 <lispy_> But, it's hard to stop playing with it
22:08:05 <lispy_> Playing with my numberwang.
22:08:14 <lispy_> in public at that
22:09:18 <copumpkin> :)
22:09:24 * copumpkin goes to sleep
22:10:14 <lispy_> > text a
22:10:15 <lambdabot>   Couldn't match expected type `GHC.Base.String'
22:10:15 <lambdabot>         against inferred typ...
22:10:32 <lispy_> Cale: Is it possible to make an IsString instance for Expr?
22:11:01 <Jafet> > text.show $
22:11:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:11:03 <Jafet> > text.show $ a
22:11:05 <lambdabot>   a
22:11:20 <Jafet> > a
22:11:21 <lambdabot>   a
22:29:06 <ClaudiusMaximus> cabal install takes 30 seconds running haddock for "Updating documentation index" - anything simple i can do to speed it up?
22:29:32 <ivanm> ClaudiusMaximus: disable building/updating the index in ~/.cabal ?
22:29:40 <ivanm> it's regenerating it from scratch each time AFAIK
22:31:18 <fragamus> I'm trying to understand how to apply monads/comonads to my problem
22:31:22 <ClaudiusMaximus> ivanm: can i still build documentation and just not update the index?
22:32:08 <fragamus> I have used monads successfully for combinatorics, but now I'm doing something new
22:33:01 <ivanm> ClaudiusMaximus: I think so
22:35:21 <fragamus> I need to take a list of states and iterate through them in an arbitrary but consistent order
22:36:08 <fragamus> and select one of the states based on some criteria
22:36:33 <mafs> ClaudiusMaximus: You could do: `cabal haddock; cabal install --disable-documentation` to build but not index.
22:36:47 <jmcarthur> so far it sounds like the filter function suffices, but i suspect the problem is somehow more complex than that?
22:36:51 <jmcarthur> fragamus: ^^
22:37:02 <fragamus> no perhaps it is as you say
22:37:39 <ClaudiusMaximus> mafs: thanks! i think the --disable-documentation will do for testing (when i'm not testing the documentation)
22:38:10 <mafs> ClaudiusMaximus: yeah. It's what I use, otherwise I get very impatient with the testing process.
22:38:45 <fragamus> each state has a floating point number, so first I have to get the sum of those floating point numbers and then generate a random floating point number between 0 and that sum, and then go through the list and find the one that represents that part of the total interval
22:39:20 <jmcarthur> ah this is a weighted random choice
22:39:24 <fragamus> yes
22:39:59 <fragamus> so it is not a fancy monadic functor
22:40:01 <jmcarthur> i seem to recall you are using MonadRandom already, right?
22:40:10 <fragamus> yes i am
22:40:27 <jmcarthur> Control.Monad.Random.fromList is exactly what you want
22:40:53 <fragamus> @type Control.Monad.Random.fromList
22:40:54 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
22:41:17 * hackagebot network 2.3.0.3 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.3 (JohanTibell)
22:41:40 <fragamus> no way!
22:41:45 <jmcarthur> yes way!
22:42:07 <fragamus> Rational?
22:42:20 <jmcarthur> yeah just use toRational on your floats
22:42:36 <fragamus> now I understand some of that stuff you guys were saying earlier.
22:42:52 <fragamus> You used zip to associate weights
22:43:00 <fragamus> and the weights were all the same then
22:44:25 <Twey> fragamus: Do you sleep?  :Ã¾
22:44:43 <fragamus> No I am a Haskell programmer
22:44:54 <Twey> I went to bed, woke up, came on IRC, and you were still discussing the same question :Ã¾
22:44:57 <jmcarthur> so am i, but i sleep
22:45:11 <Axman6> heh
22:45:15 <fragamus> Well I'm a new haskell programmer
22:45:29 <jmcarthur> ah that's different
22:45:36 <jmcarthur> you are still too excited to sleep
22:45:48 <Twey> Heh
22:46:16 <fragamus> my code is much much tighter now
22:46:47 <fragamus> I feel I must program at a very high level (with help) so that I may attain that level myself
22:47:15 <jmcarthur> as long as you make sure not to over-engineer
22:47:22 <fragamus> yes
22:47:29 <ClaudiusMaximus> hooray, my first non-trivial substitution tiling implementation works (to some extent..)  http://claudiusmaximus.goto10.org/g/tilings/ammanna3-4.png  (original at: http://tilings.math.uni-bielefeld.de/substitution_rules/ammann_a3 )
22:47:30 <fragamus> I may roll back some mods
22:49:02 <dmwit> What's substitution tiling?
22:49:45 <ClaudiusMaximus> dmwit: http://hackage.haskell.org/package/tilings
22:49:48 <fragamus> @type maybe
22:49:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:50:55 <ClaudiusMaximus> dmwit: need to think a bit more about the API, because otherwise i'll end up at version 7.9 too quickly...
22:51:11 <fragamus> does maybe use some kind of exception handling?
22:51:39 <dmwit> heh
22:51:47 <dmwit> ?src maybe
22:51:47 <lambdabot> maybe n _ Nothing  = n
22:51:47 <lambdabot> maybe _ f (Just x) = f x
22:51:48 <Twey> maybe *is* some kind of exception handling
22:52:16 <dmwit> In other words: no, maybe does not use any exception handling.
22:52:20 <dmwit> It's a boring old function.
22:54:20 <dmwit> ClaudiusMaximus: I see you're using axis-aligned bounding boxes. You might like the trick byorgey uses in diagrams for bounding hulls. It's very nice.
22:54:59 <dmwit> http://hackage.haskell.org/packages/archive/diagrams-core/0.1.1/doc/html/Graphics-Rendering-Diagrams-Bounds.html
22:56:10 <dankna> oh that is a cute trick
22:58:47 <dmwit> quadFile :: Quad -> Maybe ([FilePath], FilePath) -- O_o
22:58:57 * ddarius huggles AABBs.
23:00:10 <ClaudiusMaximus> dmwit: yeah that function is a bit of a wart, because i intended using it for disk-backed tile cache (i had the code already written, splitting it out seemed sensible, now i want to generalize it...)
23:01:21 <jdavis> (newbie question) if I have a file handle "fh", what's a good way to lazily return a list of all blocks in the file of size "blocksize"?
23:02:13 <ClaudiusMaximus> dmwit: interesting Bounds thing, but it breaks my head a bit - some examples would make it clearer i think :)
23:03:14 <Axman6> jdavis: well, you'd be looking at using lazy ByteStrings i guess?
23:03:25 <jdavis> Axman6: yes, that's what I'm using.
23:04:09 <jdavis> Axman6: I am a novice though, so I'm having trouble mixing the monadic style with recursion or some other way to generate the list lazily.
23:04:29 <jdavis> Axman6: if that makes any sense.
23:05:13 <Axman6> hmm, I'm not sure how to do it off the top of my head, though I'd look at some of the iteratees code in the various libraries and see how they do file handle enumerators
23:06:32 <jdavis> I have a feeling like I need to use a mapM or foldM or something like that.
23:07:05 <Axman6> i think you'd have to use unsafeInterleveIO to get exactly what you want
23:07:14 <dmwit> ClaudiusMaximus: http://sketchfu.com/drawing/3589661 <- here's an example for a square
23:07:18 <Axman6> maybe using iteratees mightn't be a bad idea here =)
23:07:37 <dmwit> ClaudiusMaximus: I'll sketch some more in the same style if you want, just name the shape. =)
23:08:34 <jdavis> Axman6: I don't think I need anything that fancy. You might be expecting that I know more than I actually do -- I have a function that can get a page already, returning it as an "IO ByteString". I need to make a function that can return a list of all pages as "IO [ByteString]"
23:08:58 <Axman6> oh
23:09:15 <Axman6> what inputs does the IO ByteString function take?
23:10:13 <jdavis> Axman6, "IO.Handle -> pagenumber -> IO ByteString"
23:10:43 <Axman6> then you could probably use mapM (getPage handle) [1..n]
23:11:16 <jdavis> Axman6, aha! I think that's exactly what I need.
23:12:24 <ClaudiusMaximus> dmwit: right, i think i get it :)
23:18:33 <ClaudiusMaximus> dmwit: i think i'll end up using diagrams-lib for this, as each tile is essentially a closed Trail and there is already instance ... => Boundable (Trail v)
23:19:22 <dmwit> cool
23:21:29 <ClaudiusMaximus> assuming i can figure out how to check if two bounds are disjoint, subsets, or overlapping
23:22:16 <dmwit> Look at the vector connecting their centers.
23:22:30 <dmwit> Subset sounds hard.
23:22:41 <dmwit> But disjoint seems possible.
23:29:31 <Cako> Does anybody have any experience with happy?
23:30:46 <mm_freak_> as a related question, why is happy still being used?  is there any advantage over parser combinators?
23:31:49 <Cako> I dont know Im just a noob who needs help :(
23:32:18 <m3ga> Cako: parsec is probably a better option unless you actually *have* to use happy
23:32:48 <Cako> m3ga Why so ? Parsec looks even more complicated
23:33:10 <pikhq> Cako: It really isn't.
23:33:25 <Cako> m3ga I figured out how to do most of what I needed except throwing error based on line, the monads used confuse me :(
23:33:26 <pikhq> It's just different from the usual parser generator type thing.
23:33:43 <Cako> Do you guys have a good tutorial for parsec then?
23:33:44 <m3ga> parsec is more powerful (not limmited to ll(1) parsers) and you write haskell code, not haskell code embedded in another language.
23:34:00 <pikhq> I generally find that parser generators are so obtuse it's often easier to hand-write a parser...
23:34:30 <m3ga> pikhq: i think you're doing it wrong :-)
23:34:51 <pikhq> m3ga: "Often", not "always".
23:35:10 <m3ga> i've done a lot of parsers in lex/yacc style tools and parsec is sooooo much better
23:35:10 <pikhq> Admittedly, my experience with parser generators is limited to yacc, and that may be my problem. :P
23:35:32 <m3ga> yacc is horrible, even things like ocamlyacc is horrible
23:35:46 <jeffz> Cako: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html is good, so far as parsec2 is concerned.  I don't know anything about parsec3.
23:36:15 <m3ga> parsec3 is mostly comatible with parsec2.
23:36:33 <m3ga> sorry, gotta go
23:36:47 <jeffz> parsec3 has extra features though
23:36:54 <Cako> thanks jeffz
23:40:24 <mm_freak_> Cako: a lot of things will /look/ complicated, when starting with haskell
23:40:39 <mm_freak_> don't worry too much, because you will find that you can work out most things from types
23:41:18 <Cako> I didn't have to do this with Haskell though, perhaps it was a mistake to --considering I am so bad at it apparently :p
23:41:44 <roconnor> > [3] >> [3]
23:41:45 <lambdabot>   [3]
23:42:50 <mm_freak_> Cako: do what?
23:43:35 <roconnor> > let {f :: Int -> [Int]; f = undefined} ([3] >>= f) `seq` 42
23:43:36 <lambdabot>   <no location info>: parse error on input `('
23:43:37 <Cako> It's an interpreter for a language my professor "designed".
23:43:42 <roconnor> > let {f :: Int -> [Int]; f = undefined} in ([3] >>= f) `seq` 42
23:43:43 <lambdabot>   *Exception: Prelude.undefined
23:44:43 <Axman6> > logBase 2 40000000
23:44:44 <lambdabot>   25.25349666421154
23:44:48 <Axman6> > 2^26
23:44:49 <lambdabot>   67108864
23:45:19 <djahandarie> Cako, sounds like a good use for Haskell.
23:45:49 <Cako> Maybe but I'm supposed to turn it in tomorrow and it's 3am :p
23:45:51 <Axman6> > 2^25
23:45:52 <lambdabot>   33554432
23:46:04 <djahandarie> Cako, bad idea then.
23:46:43 <roconnor> > let {f :: Int -> Maybe Int; f = undefined} in (return >>= f) `seq` 42
23:46:44 <lambdabot>   Couldn't match expected type `m a'
23:46:44 <lambdabot>         against inferred type `GHC.Types...
23:46:49 <roconnor> > let {f :: Int -> Maybe Int; f = undefined} in (return 3 >>= f) `seq` 42
23:46:50 <lambdabot>   *Exception: Prelude.undefined
23:47:19 <roconnor> > let {f :: Int -> State Bool Int; f = undefined} in (return 3 >>= f) `seq` 42
23:47:20 <lambdabot>   42
23:47:33 <roconnor> > let {f :: Int -> State Bool Int; f = undefined} in (return 3) `seq` 42
23:47:34 <lambdabot>   Ambiguous type variable `m' in the constraint:
23:47:34 <lambdabot>    `GHC.Base.Monad m'
23:47:34 <lambdabot>      a...
23:47:45 <roconnor> > let {f :: Int -> State Bool Int; f = undefined} in (return 3 :: State Bool Int) `seq` 42
23:47:46 <lambdabot>   42
23:49:40 * hackagebot static-hash 0.0.0 - Immutable hash  http://hackage.haskell.org/package/static-hash-0.0.0 (KazuYamamoto)
23:53:41 * hackagebot ghc-mod 0.6.0 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.6.0 (KazuYamamoto)
23:56:19 <mm_freak_> Cako: learning haskell is not a weekend projectâ€¦  especially when you're coming from an imperative background
23:57:59 <eekTheCat> are there ghc 7 packages for ubuntu?
23:59:13 <jeffz> eekTheCat: apparently there is a ppa
