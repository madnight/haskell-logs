00:46:55 <chegibari> Hello. I update my Ubuntu 10.10 installation (which includes lots of haskell packages) and the haskell mode for emacs is broken. Do you know how to fix this? (Actually several language specific modes got broken at once, including the ocaml mode)
00:48:00 <erenrich> is there a way to pattern match where I don't care which type constructor I match against, but I do want to capture its argument?
00:50:40 <shachaf> erenrich: That's kind of odd. Do all the type constructors have the same arguments?
00:51:02 <yitz> chegibari: i recently switched to ubuntu (i'm on natty, 11.05). The haskell mode package seems to be a *really* old version. planning to install manually, but haven't got around to it.
00:51:19 <shachaf> If so, you could try going from data T = A Int Char | B Int Char | C Int Char to data Foo = A | B | C; data T = T Foo Int Char
00:51:49 <yitz> s/11.05/11.04/
00:52:16 <shachaf> If a bunch of language modes broke at once, it's probably and emacs and/or Ubuntu thing more than a Haskell thing. :-)
00:53:27 <chegibari> shachaf: I agree with you. I asked here just because some other Haskell user could have faced the same problem
00:53:29 <yitz> shachaf: yeah, haskell-mode seems to be poorly supported on ubuntu. that's weird though, i was using debian stable before and never had any trouble.
00:53:53 <yitz> usually ubuntu just follows debian on these kinds of things.
00:54:17 <chegibari> yitz: ok. I'll try to install them manually later then. thanks!
00:54:56 <yitz> chegibari: if you find some trick to get a sane haskell-mode package to install, pls let me know.
00:55:03 <chegibari> ok
00:55:13 <chegibari> :)
01:01:48 <erenrich> shachaf: yes and they have the same number too
01:02:32 <shachaf> erenrich: Then perhaps try tagging it separately like I suggested?
01:04:49 <erenrich> shachaf: good idea
01:32:25 <develhevel> what is an instance in haskell? sometimes i see it in examples that someone write instance at the start of a code
01:32:57 <Veinor> do you know what a typeclass is?
01:32:58 <shachaf> develhevel: You'll find that most Haskell introductions describe what it means.
01:33:03 <shachaf> Look up "type classes".
01:34:17 <develhevel> Veinor: yes
01:34:44 <Veinor> so, instance Num Integer means 'Integer is an instance of the Num typeclass'
01:34:58 <develhevel> ah okay
01:43:15 <Cale> develhevel: Typeclasses are used to constrain parametric polymorphism -- that is, you use them to control which types the type variables range over, specifying that they must be types for which a given bunch of functionality has been defined.
01:44:20 <Cale> develhevel: For example, if you wanted to write a function to sort a list of values of an arbitrary type, well, it can't quite be *any* type, sort :: [a] -> [a] won't do because there are types for which ordering comparisons aren't meaningful (like function types)
01:44:52 <Cale> So you need a way to say that sort will sort lists of elements of any type for which an ordering has been defined, sort :: (Ord a) => [a] -> [a]
01:45:11 <Cale> There's a definition in the Prelude:
01:45:24 <Cale> class (Eq a) => Ord a where
01:45:30 <Cale>   (<) :: a -> a -> Bool
01:45:35 <Cale>   ... etc. ...
01:46:03 <Cale> and when you define a new type, you can provide an implementation of the functions defined in that class by writing an instance
01:46:09 <Cale> instance Ord Foo where
01:46:15 <Cale>   x < y = ...
01:47:36 <develhevel> Cale: ok so i understand it right, ty
01:48:04 * ddarius didn't realize what a pedestrian portmanteau parboiling was.
01:57:10 <roconnor> par- means partial?
01:57:31 <sipa> partially
02:50:07 * hackagebot hashed-storage 0.5.7 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.7 (PetrRockai)
02:57:28 <Twey> Heh, I love Haskell
02:57:43 <Twey> ‘You may note that Iteratee is a final coalgebra…’
02:57:57 <Twey> Yes.  That's just what I was thinking.  How prescient.
02:58:31 <Jafet> (Cue the blog tutorials explaining that final coalgebras are like iteratees)
02:58:36 <Twey> Haha
03:00:33 <Twey> Iteratees hurt my tiny brain
03:00:41 <Twey> T_T
03:01:27 <Tomsik> I'm not getting what coalgebras/comonads do, I haven't seen enough examples. Anyone has them?
03:01:45 <Tomsik> I can look at the type, but that's not giving me a lot of intuition
03:02:02 <Twey> The best tutorial I've found is Snoyman's, but he builds it up from the Iteratee, which makes playing in GHCi quite awkward.  Also, it uses Data.Enumerator, which doesn't seem to actually include any non-trivial enumerators.
03:05:09 <Yrogirg> Hello! I'm trying to build accelerate package from git and it says mtl ==2.0.* is missing. However cabal assures that for mtl:
03:05:09 <Yrogirg> Latest version installed: 2.0.1.0
03:05:09 <Yrogirg> Any ideas what's wrong?
03:06:19 <Tomsik> I've had that kind of trouble after installing newer version of ghc & cabal
03:06:50 <Tomsik> it unregistered them or something, making cabal reinstall them worked
03:09:43 <Yrogirg> reinstalling doesn't help, cabal-install version 0.8.2, ghc version 6.12.3
03:34:23 <adrienhaxaire> hello
03:34:37 <adrienhaxaire> I am a very beginner at Haskell
03:35:08 <companion_cube> hello
03:35:23 <adrienhaxaire> I still have some questions for using the JSON values that I get with 'decode'
03:36:06 <adrienhaxaire> basically, I need to fit it to a class which derives from JSON, right ?
03:36:30 <blackdog> can you give a different arbitrary instance for Char with QC?
03:36:47 <blackdog> i'd like to get this thing working on ascii before i work out why it dies on embedded nulls...
03:38:01 <companion_cube> adrienhaxaire, yes, you have to specify which type 'a' is contained in your Result
03:39:24 <adrienhaxaire> like this :  decode s :: Result [JSValue]
03:39:39 <adrienhaxaire> i get :
03:39:47 <adrienhaxaire> Ok (JSObject (JSONObject {fromJSObject = [("coordinates",JSString (JSONString {fromJSString = "yes"}))]}))
03:40:08 <adrienhaxaire> but then i don't know what to do with it
03:40:44 <adrienhaxaire> sorry, it was: decode s :: Result JSValue
03:40:54 <mauke> what do you want to do with it?
03:41:20 <adrienhaxaire> ha ha, sorry not to be specific
03:41:31 <adrienhaxaire> fill data structures :
03:41:34 <adrienhaxaire> coordinates
03:41:41 <adrienhaxaire> elements
03:41:44 <mjrosenb> hey, is there anything like trace, but will magically count how many times it has been evaluated?
03:41:58 <mauke> mjrosenb: profiling?
03:42:00 <mjrosenb> and let me print it out at a later point in time?
03:42:30 <mjrosenb> would i need to make up a cost center for it?
03:43:28 <adrienhaxaire> i want to use JSON as an input for this data :https://github.com/adrienhaxaire/funfem/blob/master/Elements.hs
03:48:16 <adrienhaxaire> btw i am reading the source file of the JSON module
03:48:29 <adrienhaxaire> very interesting !
04:06:23 <adrienhaxaire> obviously i am not trained enough, i have to get back to reading, to better understand typeclasses, instances, etc
04:06:39 <adrienhaxaire> thanks for the help :)
04:07:10 <adrienhaxaire> still, parsing the source code of the JSON package is very useful
04:36:53 <ezyang> I've suddenly gotten this feeling that, no, it's not that lazy programs leak more than their strict ones, it's that we demand a lot *smaller* memory usage if you're being lazy...
04:37:51 <Jafet> Smaller compared to the equivalent strict program?
04:38:04 <ezyang> Yeah.
04:38:24 <Jafet> Many haskell programs don't have strict equivalents, and of those that do, I'm pretty sure many use more memory than is appropriate
04:38:30 <Jafet> (Having written some pairs myself)
04:38:47 <Jafet> Are you talking about the former or latter type, or something else?
04:39:13 <ezyang> Both, really.
04:39:50 <ezyang> Essentially, many things that are a "space leak" in Haskell are a non-issue in a strict langauge because, well, the input already exists all there.
04:40:55 <Jafet> A lot of space leaks are caused by intermediate data structures as well
04:41:09 <Jafet> ...that is, they are occupied by the data structures
04:41:28 <ezyang> Yeah, I guess part of the problem is that we generate a lot more intermediate data structures.
04:41:46 <ezyang> Whereas in a traditional program you'd do a lot of legwork to make sure those aren't present.
04:43:42 * Jafet kicks [a]
04:52:17 <spirit> how could i achieve this: ["1","
04:52:43 <Jafet> > text "[\"1\",\""
04:52:43 <lambdabot>   ["1","
04:53:07 <spirit> ["A","B","C"] ["a","b","c"] -> ["Aa","Bb","Cc"]
04:53:31 <Feuerbach> > zipWith (++) ["A","B","C"] ["a","b","c"]
04:53:33 <lambdabot>   ["Aa","Bb","Cc"]
04:54:08 <spirit> cheers! i knew map and zip but i did not know how to combine the two... ;-)
04:54:28 <Feuerbach> actually, map+zip would suffice (also less idiomatic)
04:54:37 <mauke> > map (\(x, y) -> x ++ y) (zip ["A","B","C"] ["a","b","c"])
04:54:39 <lambdabot>   ["Aa","Bb","Cc"]
04:55:03 <Jafet> > map (uncurry (++)) $ zip ["A","B","C"] ["a","b","c"]
04:55:05 <lambdabot>   ["Aa","Bb","Cc"]
04:55:07 <Feuerbach> > map (uncurry (++)) $ zip ["A","B","C"] ["a","b","c"]
04:55:09 <lambdabot>   ["Aa","Bb","Cc"]
04:55:10 <Jafet> mauke I am disappoint
04:55:18 <mauke> why?
05:02:07 <spirit> is it possible to map a function that takes 2 params, the second being a list?
05:02:09 <spirit> lookUpLabel :: String -> [String] -> String
05:02:25 <spirit> i want to map lookUpLabel in order to apply it to a list
05:02:42 <spirit> not sure where to plugin the second param though
05:02:43 <Botje> what would you map it over?
05:02:53 <Botje> is one of the two parameters known in advance?
05:03:14 <spirit> yes, the list param is known in advance
05:03:43 <rostayob> spirit: then isn't just map (lookUpLabel label) enough?
05:04:07 <spirit> ah... i want label to be fed from a list too
05:04:24 <rostayob> spirit: so wait, you've got a list of labels
05:04:42 <rostayob> and you want to repeatedly apply map with those labels
05:04:46 <rostayob> or something like that?
05:04:50 <spirit> 1. param = key
05:04:51 <Botje> map (\label -> lookupLabel label known_list_of_labels) labels
05:05:00 <spirit> 2. param = key-value list
05:05:24 <Botje> or, if you want it pointfree: map (flip lookupLabel known_list_of_labels) labels
05:05:35 <Jafet> (`lookupLabel` labels)
05:06:14 <Botje> or that :)
05:07:06 <Jafet> filter (`member` fromList labels)
05:07:16 <spirit> cheers!!! :-)
05:07:23 <mb21> hello everybody! quick question: why does curry only take functions which take 2-tuples, not n-tuples?
05:07:56 <Jafet> Because n-tuple isn't a type?
05:07:58 <rostayob> mb21: because a tuple with two elements is a type of itself
05:08:02 <rostayob> and so on
05:08:38 <mb21> oh, you mean (,) is similar to (:) ?
05:08:40 <sipa> i suppse you could implement some generalized curry with enough type-level hackery
05:08:53 * hackagebot snap-core 0.4.2 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.4.2 (GregoryCollins)
05:09:01 <Jafet> :t (,)
05:09:01 <Jafet> :t (:)
05:09:02 <lambdabot> forall a b. a -> b -> (a, b)
05:09:02 <lambdabot> forall a. a -> [a] -> [a]
05:09:10 <rostayob> mb21: no, they're not similar :P
05:09:46 <mb21> hm.. so does (1, 2, 3) translate to anything?
05:10:00 <mb21> like [1, 2, 3] -> 1:2:3:[]
05:10:05 <mb21> not really, right?
05:10:12 <Liskni_si> > (,,) 1 2 3
05:10:13 <Jafet> (,,) 1 2 3
05:10:13 <lambdabot>   (1,2,3)
05:10:27 <mb21> wow :)
05:10:28 <Jafet> :t (,,,)
05:10:29 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
05:10:41 <Jafet> Don't worry, many people hate this.
05:10:54 * hackagebot xmlhtml 0.1.5 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.5 (GregoryCollins)
05:11:01 <mb21> so how many commas can i put in there?
05:11:17 <mb21> if infinite – how is this implemented??
05:11:19 <rostayob> mb21: it's quite ugly, and in fact when instantiating type classes you'll often see orrible stuff
05:11:29 <rostayob> you usually go up to (,,,,) lol
05:11:34 <rostayob> *horrible
05:11:36 <mb21> :D
05:11:55 <rostayob> i don't know if there is a cap to the number of commas lol
05:11:58 <rostayob> :t (,,,,,,,)
05:11:59 <lambdabot> forall a b c d e f g h. a -> b -> c -> d -> e -> f -> g -> h -> (a, b, c, d, e, f, g, h)
05:11:59 <Jafet> A haskell98 implementation only needs to support up to about 15
05:12:09 <mb21> okay :)
05:12:31 <mb21> well, ghc definitely supports more
05:12:36 <mb21> (just tested)
05:12:40 <sipa> 63 i think
05:12:42 <hpc> ghc supports 62
05:12:49 <hpc> and i think you can go higher with λbot
05:13:09 <Jafet> Okay, ghc's built-in instances only have up to 15.
05:13:20 <Jafet> > (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
05:13:21 <lambdabot>   No instance for (GHC.Show.Show
05:13:21 <lambdabot>                     (t,
05:13:21 <lambdabot>                     ...
05:13:43 <hpc> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) -- sorry this is so long, but making a point
05:13:44 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
05:13:44 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -
05:13:44 <lambdabot> > q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 ->
05:13:44 <lambdabot> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 ->
05:13:44 <lambdabot> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> t91 -> t92 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28,
05:13:46 <lambdabot> t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68,
05:13:48 <lambdabot>  t69, t70, t71, t72, t73, t74, t75, t76, t77, t78, t79, t80, t81, t82, t83, t84, t85, t86, t87, t88, t89, t90, t91, t92)
05:13:54 * hackagebot snap-server 0.4.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.4.2 (GregoryCollins)
05:14:06 <hpc> show instances only go up to 6?
05:14:13 <hpc> iirc
05:14:17 <mb21> so the constructor is there but only show up to 15?
05:14:30 <Liskni_si> is there any reason for λbot to support this many?
05:14:54 * hackagebot snap 0.4.2 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.4.2 (GregoryCollins)
05:14:58 <hpc> oh! ghci supports that many too
05:15:09 <hpc> wonder what's up with that
05:15:22 <hpc> (actually not really; huge tuples are evil)
05:15:40 <mb21> well, actually how i got into this was because i wanted to implement a curry function in javascript (yes, a real curry function not all those 'partial application things' you find when googling 'javascript curry')
05:16:52 <mb21> because javascript hasn't built this in it would be nice to implement a curry for functions that take n arguments.. but i haven't quite managed it yet, so i thought i'd look at the haskell implementation.. which does it only for two :P
05:16:53 <Jafet> You... write it in haskell and then compile it to javascript?
05:17:19 <mb21> hm.. worth a try :)
05:17:35 <mb21> pattern matching up to 15? or do you have a better idea?
05:17:45 <Jafet> I'm sure you can write a generic curry for HList.
05:18:02 <Botje> mb21: you know you can access all the arguments of a function with the "arguments" variable?
05:18:13 <mb21> yes..
05:18:58 <mb21> and in curry(fn), fn.length gives the list of explicit arguments
05:21:34 <mb21> *thinking*..
05:24:59 <mb21> if i were to implement this in haskell, what type would teh curryList function have?
05:25:18 <mb21> i cannot say because it could be arbitrary many arguments..
05:26:11 <mb21> maybe it cannot be done? :S
05:27:47 <rostayob> mb21: you can have variadic functions with some trickery in haskell
05:27:50 <chrisdone> tibbe: Hey, any chance of adding me to the Github Haskell organization? I want to create an 'emacs' project within it for haskell-mode.
05:28:34 <rostayob> or you can use template haskell for stuff like that
05:28:42 <rostayob> http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn
05:29:25 <mb21> wow, thanks!
05:29:29 <tibbe> chrisdone: what does the maintainer of haskell-mode think? or is that you now?
05:29:47 <mb21> i wonder whether that compiles to javascript in the end..? :)
05:30:26 <chrisdone> tibbe: I'm thinking about taking over but I'm testing the waters before I ask the maintainer (Baughn). http://permalink.gmane.org/gmane.comp.lang.haskell.emacs/108
05:30:48 <tibbe> chrisdone: If that could be the official repo for haskell-mode I wouldn't mind.
05:31:10 <tibbe> chrisdone: but I'd like to see that cleared up with the current maintainer first, to avoid confusion
05:32:05 <tibbe> chrisdone: perhaps ping him and ask if we can move the repo?
05:32:30 <tibbe> chrisdone: my unofficial policy so far has been to use the haskell organization for HP packages, but I think haskell-mode fits there
05:32:58 <aristid> is haskell supposed to be the github org for core haskell projects?
05:33:24 <chrisdone> tibbe: Cool. I'll just fork it for now because I have a lot of additions and changes that people might not like or expect and would need time to adjust to, I was just wondering if that could indeed be a place for it eventually.
05:33:40 <tibbe> chrisdone: sounds good
05:33:47 <tibbe> aristid: yes
05:33:53 <aristid> tibbe: if _all_ HP platform packages had at least mirrors on github, that might be cool
05:33:57 <tibbe> aristid: we try to put any core lib stored in git there
05:34:11 <tibbe> aristid: I'd rather see that the libs switched
05:34:20 <tibbe> aristid: maintaing a mirror of a darcs repo is a bit of a pain
05:34:30 <chrisdone> Agreed, mirrors aren't that great.
05:35:39 <aristid> is putting emacs haskell-mode in the platform something you could envision?
05:37:08 <Baughn> chrisdone: That's fine. I expect you'd be more responsive.
05:37:25 <Baughn> chrisdone: I still have some coding I want to do for haskell-mode, but I can do that asynchronously. :)
05:38:12 <aristid> Baughn: oh you're in #haskell too :D
05:38:31 <robertosucks> Can someone please help me understand this recursion? http://www.pastie.org/1903673
05:38:52 <Baughn> robertosucks: Hm?
05:38:57 <aristid> robertosucks: what are you struggling with?
05:39:03 <chrisdone> Baughn: Great. :-) What coding in particular are you talking about? The full-Haskell-parser editing support?
05:39:22 <Twey> chrisdone: You live!
05:39:31 <robertosucks> aristid, how this recursion works, i never did recursion so it is a bit hard for me
05:39:32 <Twey> robertosucks: Walk it through with a short example
05:39:37 <Baughn> chrisdone: Yep. Though I think I can get some useful additions even without going that far.
05:39:38 <robertosucks> i am no getting this
05:40:14 <chrisdone> Twey: Ciao. ;-)
05:40:18 <chrisdone> Baughn: Interesting; how?
05:40:18 <aristid> robertosucks: let us take an example: replicate' 3 "cookie"
05:40:31 <robertosucks> yes i already did that
05:40:46 <robertosucks> what i am not getting is the output
05:40:53 <aristid> ?
05:41:15 <robertosucks> yes, how the functions is showing us the output
05:41:20 <mauke> what
05:41:31 <Botje> robertosucks: oh, you mean because it prints ["cookie","cookie","cookie"] ?
05:41:39 <robertosucks> yes
05:41:44 <Baughn> robertosucks: The function doesn't do that, that's all the interpreter
05:41:50 <Botje> robertosucks: that is just shorthand for "cookie" : ("cookie" : ("cookie" : []))
05:42:35 <robertosucks> here replicate (n-1) works like a for ?
05:42:46 <robertosucks> like 5-1
05:42:53 <robertosucks> 4 times x
05:43:00 <robertosucks> right?
05:43:08 <mauke> n-1 works like subtracting 1 from n
05:43:48 <Baughn> chrisdone: Nothing terribly dramatic, but it should at least be possible to opportunistically load types whenever the file /does/ compile under the standard parser
05:44:17 <Twey> robertosucks: http://hpaste.org/46696/replicate_basic_recursion_ex
05:44:31 <Twey> chrisdone: coi .ui
05:45:11 <chrisdone> Baughn: So, whenever it parses, and compiles, update some metadata about the types of the code in the background?
05:45:17 <Baughn> chrisdone: Right.
05:45:46 <robertosucks> Twey, thank you
05:45:54 <robertosucks> it was very usefull
05:45:56 <robertosucks> :)
05:45:57 <robertosucks> cya
05:46:10 <aristid> robertosucks: don't try to look at equivalents. just look at the equations, and replace what you see on the left side of the = by what you see on the right side.
05:46:21 <aristid> bah
05:46:45 <chrisdone> Baughn: Using the GHC API or an inferior Haskell (hugs/ghci)?
05:46:55 <Baughn> GHC
05:47:08 <Baughn> I wouldn't even know where to start with one of the others
05:48:12 <lars9> why complilation of haskell is rather slow? comparing with other langs like ocaml
05:48:22 <Baughn> lars9: With -O2, or?
05:48:41 <lars9> with and without
05:48:53 <ezyang> Haskell's pretty high level, so we need to do a lot of work when we compile.
05:49:00 <Baughn> lars9: Though I guess fundamentally it's that GHC is a very heavyweight compiler compared to those; it does more than them. Also, it doesn't support parallelization.
05:49:17 * Baughn has eight hardware threads, and would quite like some of that.
05:49:50 <lars9> is hugs much faster?
05:49:56 <Baughn> Yes, but so is GHCi
05:52:00 <chrisdone> Baughn: I thought of an idea for writing only syntactically correct code; suppose Emacs only accepts a source file that it can parse (otherwise it launches missiles), then when you want to edit a part of the code, the code within the nearest parent in the AST of the part you're editing becomes 'editable'. You can only type in there something that will parse in the context of the parent. Once you do, either on a timer or a key binding, it 'commit
05:52:01 <chrisdone> s' that was being valid and the whole doc can be re-parsed.
05:52:46 <Baughn> chrisdone: I thought of that, and I've seen it done too
05:52:54 <Baughn> chrisdone: It's generally too restrictive to be of much use
05:53:32 <mauke> preflex: quote . reasonable
05:53:33 <preflex>  <altreus> That's OK because G-clamps are a reasonable sex toy if you like that sort of thing
05:53:38 <mauke> what. no
05:53:47 <chrisdone> O_O
05:54:18 <chrisdone> Baughn: I see. That sucks. Do you have an example of it being annoying?
05:54:59 <dbeacham> is there a way to get more descriptive error messages out of cabal install?
05:55:34 <Lemmih> dbeacham: Yes, pass them through the #haskell filter.
05:55:45 <Baughn> chrisdone: Nothing terribly standalone. You'll have to use your imagination, and consider how often your own coding veers into syntactically incorrect territory.
05:56:37 <parcs> dbeacham: cabal install -v
06:00:57 <ski> chrisdone : iirc, epigram has something like that in an emacs mode
06:01:57 <ski> somewhat related is the Alfa proof structural editor (using Agda1 as proof engine) -- an example screenshot is <http://imagebin.org/152044>
06:03:20 <mreh> honey, i'm home
06:04:17 <mreh> return (const (fail "Hello")) :: Parser (a -> Either String a)
06:04:19 <mreh> > return (const (fail "Hello")) :: Parser (a -> Either String a)
06:04:21 <lambdabot>   Not in scope: type constructor or class `Parser'
06:04:28 <chrisdone> skaar: Oh, that is interesting. Thanks.
06:04:36 <chrisdone> ski: Sorry, nick completion.
06:05:35 <mreh> (const . fail "Hello") <- this was giving me an exception, but I was trying to use it in the context of Parser (a -> Either String a)
06:05:47 <mreh> i would have expected a Left
06:06:02 <mreh> i realise I could use a monad transformer here
06:06:28 <chrisdone> ski: So, from what I can garner from that screenshot, each part of the AST in the editor is created by typing in the box below?
06:06:56 <mreh> > fail "Hello" 1
06:06:57 <lambdabot>   *Exception: Hello
06:07:00 <mreh> ahh
06:07:04 <mreh> why is that?
06:10:37 <ski> chrisdone : not quite
06:11:22 <ski> you can either click on the constructions (including constants and function (applications)) in the window on the right
06:11:32 <ski> or you can type in the abbreviations that are listed there
06:12:19 <ski> these abbreviations are dynamically constructed, depending on what things are in (including local bindings) scope at the current position, also (optionally) filtering through what would fit type-checking
06:12:42 <ski> arrow keys navigate the source as a tree
06:13:39 <ski> selecting a function whose return type matches the type of the hole will create an application with holes for the arguments
06:14:08 <ski> entering anything in a hole in the source tree can potentially also fill in other holes, because of the dependent typing
06:14:43 <ski> (so selecting which vector you want to pass to a function will also automatically fill in the size of the vector as another argument to the generic function)
06:18:09 <chrisdone> Ahh. Wow.
06:19:12 <chrisdone> That is pretty cool.
06:19:28 <ski> chrisdone : the Alfa site is <http://www.cse.chalmers.se/~hallgren/Alfa/>, but since it's not developed much anymore, some pages are missing there (you can find them with <http://classic-web.archive.org/web/20070406060005/http://www.cs.chalmers.se/~hallgren/Alfa/> e.g.)
06:20:02 <ski> chrisdone : somewhat more recent source and binaries can be found at <http://ogi.altocumulus.org/~hallgren/untested/> (also Fudgets are there)
06:20:52 <ski> chrisdone : yeah, imo it's a bit sad that Alfa hasn't been upgraded/redone to work with Agda2
06:22:02 <Twey> Haha, I just discovered liboleg
06:22:26 <chrisdone> ski: Thanks, this is quite inspiring and definitely what I had in mind. Have you ever worked with it personally?
06:22:28 <ski> i mean, the Agda2 emacs mode is nice too, but it doesn't support the automatic propagation of information
06:23:34 <ski> (nor the auto-indentation and operators which can take arguments above and below (in smaller fonts),&c. .. but that can't be expected of emacs)
06:23:48 <ski> chrisdone : no, i've only used it some
06:24:37 <robertosucks> in http://www.pastie.org/1903848 what take' n (x:xs) means?
06:24:56 <ski> chrisdone : if you want to try it, you can possibly get <http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz> (or another, as appropriate) to run -- it works on this recentish Ubuntu system, at least
06:24:58 <chrisdone> I suppose in Haskell I might write: foo :: Bool -> Int; foo True = …, and then it could infer to fill in foo False = …
06:25:27 <chrisdone> ski: I'm downloading it. :-)
06:26:25 <ski> chrisdone : well, in Alfa / Agda1, if you start with `foo b = ?' and select "case" on `b', it will generate `foo False = ?' and `foo True = ?' automatically for you
06:26:25 <chrisdone> Ah, it runs. :-D
06:26:52 <chrisdone> Right.
06:27:03 <ski> (the actual Agda1 source looks more like `foo = \(b :: Bool) -> case b of {False -> ?; True -> ?}', but the above is how Alfa will display it)
06:27:48 <aristid> is there agda2 yet?
06:27:54 <ski> yes, see #agda
06:29:08 <sphynx> hi! I'm getting some problems with encoding while trying to print out the HTML page got by http: http://paste.in.ua/2379/
06:29:25 <sphynx> it says: *** Exception: <stdout>: hPutChar: invalid argument (character is not in the code page)
06:29:34 <ski> chrisdone : `Options -> Filter through type checker' to only see the constructions which would be type correct to use
06:29:57 <sphynx> that should be some windows problem, but I'm on Cygwin and $LANG is ok, says it's "C.UTF-8", unicode
06:31:21 <ski> chrisdone : to be honest, there's also a few things which are irritating in the current Alfa interface : sometimes, if you delete an expression, all or part of it will immediately reappear, because some other part of the source forces it to be that (because of dependent types) -- this is especially aggravating if those other parts are *hidden* arguments
06:32:23 <ski> chrisdone : this can be worked-around by selecting a large enough expression, and selecting "Edit as text", but then you have to manipulate the raw Agda1 source
06:32:24 <sphynx> can someone please suggest how to fix it? I tried to run it with different LANG settings, in plain windows console ('cmd'), but the result is the same :(
06:32:26 <chrisdone> ski: What does it mean to be a hidden argument?
06:32:50 <ski> consider `reverse :: forall a. [a] -> [a]' in Haskell
06:33:07 * hackagebot hylolib 1.3.3 - Tools for hybrid logics related programs  http://hackage.haskell.org/package/hylolib-1.3.3 (GuillaumeHoffmann)
06:33:09 * hackagebot HTab 1.5.6 - Tableau based theorem prover for hybrid logics  http://hackage.haskell.org/package/HTab-1.5.6 (GuillaumeHoffmann)
06:33:20 <ski> in Agda1 this becomes `reverse :: (a :: Set) -> [a] -> [a]'
06:33:32 <chrisdone> ski: Okay.
06:33:40 <ski> so to call this, you have to type `reverse Bool [False,True]'
06:34:04 <chrisdone> Mhm.
06:34:06 <ski> however, Alfa supports suppresing some of the (initial) arguments of a function -- they are not displayed visually
06:34:33 <ski> Agda2 has something similar (but at the textual source level)
06:34:52 <dbeacham> I've tracked down my cabal issues to /tmp being mounted with noexec. I don't have root privileges on the box - can i get cabal to untar the packcage to another location?
06:35:33 <ski> chrisdone : so, it would be useful to either have a way of querying which other parts of the program is forcing the current expression to have a particular form
06:36:24 <chrisdone> Ah, right.
06:36:28 <ski> an alternative would be to backwards-delete the things that instantiates an expression (possibly querying)
06:37:08 <ski> more generally, a non-linear undo/redo would be useful
06:37:49 <ski> (so that parallel parts of the program can be undone/redone independenty of each other)
06:38:34 <ski> chrisdone : if you look in the `Library' you should see some examples of code/proofs
06:38:35 <chrisdone> You know Emacs has that, right?
06:38:55 <chrisdone> Ahh, okay. I was struggling constructing an example.
06:39:09 <ski> i've recently heard of <http://www.dr-qubit.org/undo-tree/undo-tree.el>, but haven't tried it yet
06:39:19 <ski> were you thinking of that, or anything else ?
06:39:45 <chrisdone> I meant that you can just undo a specific region.
06:40:17 <chrisdone> But yeah, it's not comprehensive.
06:41:41 <ski> chrisdone : constructing types `Natural' and `Vector' and writing `append :: (A :: Set) -> (m :: Natural) -> (n :: Natural) -> Vector m A -> Vector n A -> Vector (m + n) A' shouldn't be too hard, i think
06:41:44 <chrisdone> The dependent if is cool.
06:42:52 <ski> (and you can make `Natural' view the math sign using "Symbol font" (no unicode here))
06:43:09 <ski> chrisdone : did you mean `undo-tree' or something else ?
06:43:50 <chrisdone> ski: I meant plain C-/. It works on regions so that you can undo specific parts of a file independently.
06:44:09 <ski> ah, ok. i didn't know that. ty
06:45:08 * hackagebot test-framework 0.4.0 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.4.0 (MaxBolingbroke)
06:46:04 <chrisdone> Thanks for cluing me into this. I've gotta go shopping now. Ciao!
06:46:08 * hackagebot test-framework-quickcheck2 0.2.10 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.10 (MaxBolingbroke)
06:46:28 <ski> chrisdone : yw. have fun ! :)
06:48:59 <roconnor> @hoogle insert
06:49:00 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
06:49:00 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
06:49:00 <lambdabot> Data.IntSet insert :: Int -> IntSet -> IntSet
06:49:07 <roconnor> @hoogle+
06:49:08 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
06:49:08 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
06:49:08 <lambdabot> Data.Set insert :: Ord a => a -> Set a -> Set a
06:54:58 <Yrogirg> Does anybody knows where I can find these functions --- randomUArrayR and convertUArray?
06:55:19 <ezyang> @hoogle randomUArrayR
06:55:20 <lambdabot> No results found
06:55:41 <ezyang> What context?
06:57:16 <hpc> google yields no results for the first, which means it probably doesn't exist
06:57:28 <hpc> at the very least, it definitely is not on hackage
06:57:46 <Yrogirg> I'm studing examples for accelerate package it has aan example of dot product DotP.hs which starts with
06:57:47 <Yrogirg> {-# LANGUAGE ParallelListComp #-}
06:57:47 <Yrogirg> module DotP where
06:57:47 <Yrogirg> import Random
06:57:47 <Yrogirg> import System.Random.MWC
06:57:47 <Yrogirg> import Data.Array.Unboxed
06:57:47 <Yrogirg> import Data.Array.Accelerate as Acc
06:57:48 <Yrogirg> later it invokes
06:57:48 <Yrogirg>   v1  <- randomUArrayR (-1,1) gen n
06:58:27 <hpc> and is randomUArrayR in scope?
06:58:43 <hpc> i would start with the modules it imports
06:58:49 <hpc> see if it is in one of those
07:00:16 <robertosucks> new doubt about recursion. http://www.pastie.org/1903995 in every iteneration the head is changed like [1,2,3,4] the first time is 1 but the second is 2? i am right?
07:02:22 <Yrogirg> hpc: no, it's not in scope. All modules a loaded, but these functions are unavailable. Can it be that there are different Random modules from various packages? So I need to install another package wich provides another Random?
07:03:18 <robertosucks> guys i need help
07:04:04 <nlogax> robertosucks: yeah, on the last line there, you cann it with the tail only, so the head has been discarded
07:04:08 <nlogax> call
07:05:02 <robertosucks> yes but then with the tail it creates me a new head of the tail list? right?
07:05:13 <robertosucks> and that head is compared with a
07:05:15 <Yrogirg> oh, I've found it. There is a Random.hs not far from DotP.hs
07:05:27 <robertosucks> am i intrepreting is right?
07:06:17 <stulli> robertosucks: As far as i can see you are correct and the function does what you want. Do you have a specific problem?
07:06:23 <nlogax> robertosucks: not sure what you mean by "new head of the tail list". it's just a new list with the same elements except the first one, which has been dropped :)
07:07:02 <robertosucks> like the first list
07:07:06 <robertosucks> [1,2,3,4,5]
07:07:10 <robertosucks> it is compared with a
07:07:14 <robertosucks> it is diferent
07:07:22 <robertosucks> then the tail is [2,3,4,5]
07:07:27 <nlogax> yeah
07:07:33 <robertosucks> aand then the head is 2
07:07:37 <robertosucks> it is compared
07:07:42 <robertosucks> am i right?
07:08:00 <stulli> Yes, the first elem' call has [1,2,3,4,5] as argument, the next recursive call has [2,3,4,5] and so on...
07:08:16 <stulli> > head [2,3,4,5]
07:08:17 <lambdabot>   2
07:08:41 <nlogax> yep. (x:xs) matches (1:[2,3,4,5]), and xs is what you use later
07:08:52 <robertosucks> ok
07:09:08 <robertosucks> thanks
07:15:45 <Alan> I want to define a "pipe" operator which is like $, but the other way around, i.e. x | f = f x
07:15:57 <Alan> how simple would that be?
07:16:15 <nlogax> like that, except | is reserved i think
07:16:19 <mauke> impossible
07:16:28 <ezyang> You could use something like <|>
07:16:36 <Alan> ok
07:16:41 <ben> Surely there is some random-ass unicode character that kinda looks like |
07:16:47 <ezyang> But...
07:16:55 <ezyang> @hoogle a -> (a -> b) -> b
07:16:56 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:16:56 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:16:56 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:18:03 <Alan> none of those are the right type...
07:18:16 <ezyang> unfortunately.
07:18:34 <ezyang> @hoogle a -> f a b -> b
07:18:35 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
07:18:35 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
07:18:35 <lambdabot> Control.Monad.State.Strict evalState :: State s a -> s -> a
07:18:53 <mauke> :t flip id
07:18:54 <lambdabot> forall a b. a -> (a -> b) -> b
07:20:11 <nlogax> > let x |> f = f x in 1 |> (+2) -- is it F# that uses that?
07:20:12 <lambdabot>   3
07:20:20 <Alan> well i'm pretty sure i need a new operator
07:20:24 <parcs> @type (|$)
07:20:25 <lambdabot> Not in scope: `|$'
07:20:27 <Alan> because it needs to be left-associative
07:20:28 <parcs> @type ($|)
07:20:29 <lambdabot> forall a b. (a -> b) -> Strategy a -> a -> b
07:20:31 <Alan> (i think)
07:21:22 <Alan> x <|> h <|> g <|> f = ((x <|> h) <|> g) <|> f
07:21:42 <Alan> i'm not sure if that is left or right
07:21:46 <Alan> i used to know this stuff...
07:23:27 <Alan> what precedence is ($)?
07:23:29 <Alan> is it 0?
07:23:34 <Alan> or higher than that?
07:23:39 <ezyang> @prec ($)
07:23:40 <lambdabot> Maybe you meant: free rc src
07:23:47 <ezyang> :info ($)
07:23:51 <ezyang> blah
07:26:03 <Yrogirg> Alan, is it somehow connected to linear algebra or quantum mechanics (I'm just curious).
07:26:13 <Yrogirg> ?
07:26:33 <Alan> heh, not at all :P
07:30:28 <Alan> damn docs don't tell me what precedence ($) is :(
07:30:44 <Lemmih> Alan: infixr 0
07:31:03 <c3l> in my main glfw loop Im checking some stuff with if then else. however, when I need more than one function call in the then statement, I have to do "then do fn1 fn2" (with newline ofc). why is this extra do needed?
07:31:25 <Alan> Lemmih: ok, so infixl 0 is what I want for my operator then i guess
07:33:06 <Lemmih> c3l: Because branches are expressions.
07:33:35 <Lemmih> c3l: And 'fn1; fn2' is not an expression but 'do fn1; fn2' is.
07:34:28 <Botje> i keep misreading glfw for gfwl, which is a horrible DRM system by microsoft
07:34:51 <c3l> Lemmih: ah, so then takes an expression. that could be one function. or a do expression? if thats correct i get it, thanks
07:44:47 <Alan> woo, that operator works now :D
07:45:00 <Alan> infixl 0 |>
07:45:07 <Alan> x |> f = f x
07:45:10 <Alan> nice and simple
07:45:15 <Alan> <3 haskell...
07:45:47 <hpc> (|>) = flip ($)
07:46:53 <Alan> hpc: i guess so, but still requires the "infixl ..."
07:47:27 <Alan> and maybe it's simpler to read "x |> f = f x" when that's the definition of ($) too
07:47:47 <Alan> i don't know
07:53:54 <develhevel> how can help my with exception handling i want to run this code http://hpaste.org/46697/try but it always say "mbiguous type variable `e0' in the constraint" and i dont know why
07:55:15 <Jafet> :t try
07:55:16 <lambdabot> Not in scope: `try'
07:55:27 <Jafet> @hoogle Control.Exception.try
07:55:27 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
07:55:27 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
07:55:27 <lambdabot> Control.Exception tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
07:55:28 <ion> :t Control.Exception.try
07:55:28 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
07:55:41 <ion> You’ll need to define the e
07:56:10 <develhevel> how could the e look like?
07:56:18 <develhevel> need a example
07:56:55 <Jafet> @instances Exception
07:56:55 <lambdabot> Couldn't find class `Exception'. Try @instances-importing
07:56:55 <Feuerbach> try (print x) :: IO (Either SomeException ())
07:57:01 <Axman6> if you use SomeException, it will match anything thrown
07:57:10 <Jafet> @instances-importing Control.Exception Exception
07:57:11 <lambdabot> ArithException, ArrayException, AssertionFailed, AsyncException, BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, Deadlock, ErrorCall, IOException, NestedAtomically, NoMethodError, NonTermination,
07:57:11 <lambdabot>  PatternMatchFail, RecConError, RecSelError, RecUpdError, SomeException
07:57:23 <Jafet> Pick one.
07:57:56 <Feuerbach> try (print x) :: IO (Either ArithException ()) -- more accurate for your case
07:59:39 <develhevel> okay understood, thx
07:59:40 <Jafet> Mmm, NonTermination
07:59:42 <ion> ghci> either (show :: ArithException -> String) show <$> try (print (5 `div` 0))
07:59:46 <ion> "divide by zero"
08:01:24 <aristid> :t catch
08:01:25 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:02:13 <Axman6> ion: what do you get if you use SomeException?
08:03:27 <Feuerbach> the same, I guess
08:03:40 <scooty-puff> is there a way to deal with circular data structures, i.e. printing them, etc., without having unique labels on the nodes?
08:04:02 <scooty-puff> i have seen: http://okmij.org/ftp/Haskell/CCard-transform-DFA.lhs
08:04:02 <Feuerbach> scooty-puff: yes, you can use StableNames (GHC-specific)
08:04:07 <scooty-puff> OK
08:04:10 <scooty-puff> *ok
08:04:16 <ion> axman6: The same.
08:04:24 <ion> ghci> either (show :: SomeException -> String) show <$> try (readFile "foo")
08:04:24 <ion> "foo: openBinaryFile: does not exist (No such file or directory)"
08:04:41 <ion> And it works, as you said, for all exceptions.
08:11:34 <dylukes> Gentlemen of #haskell.
08:11:42 <dylukes> I present… the most adorable one-line piece of Haskell.
08:11:43 <dylukes> Ever.
08:11:45 <dylukes> > let a ♥ b = True in "you" ♥ "me"
08:11:46 <lambdabot>   True
08:11:49 <dylukes> (awww)
08:12:12 <ion> > let a ♥ b = False in "you" ♥ "me"
08:12:13 <lambdabot>   False
08:12:13 <companion_cube> :)
08:12:19 <dylukes> ion: Too sad.
08:12:48 <Phyx-> someone's been watching disney movies again
08:18:09 <dylukes> Phyx-: Nah, not at all ^_^.
08:28:32 <Twey> Why is there no Show instance for Q? :(
08:33:55 <djanatyn> http://monadicheadaches.blogspot.com/2007/11/random-numbers-where-it-all-started.html <-- I think I understand monads now :D
08:38:03 <balor_> Is it possible to have a Set.singleton as a type?  Or something to that effect?  I'm modelling a formal logic system, so I'd rather not model this type as simply a Set.
08:38:40 <ezyang> Why not just represent it as a?
08:38:45 <ezyang> 'a'?
08:39:00 <cheater79> djanatyn, um, as far as i understand you can make completely pure RNG's
08:39:01 <ezyang> Haskell doesn't really have dependent types, but in this case you don't need a Set.
08:39:10 <cheater79> why he's giving up on purity is beyond me
08:39:45 <luite> cheater79: you do have to do some IO initially if you don't want to get the same stream every time
08:40:02 <balor_> ezyang, Because the system I'm modelling doesn't.  I'd like to stay as close to the proved theorems as possible.  But maybe that's the best way.
08:40:03 <cheater79> luite, the RNG can be pure though
08:40:14 <cheater79> just the seeding process is impure
08:40:56 <luite> cheater79: yes, but even then it makes sense to use a monad (not IO though)
08:41:12 <cheater79> yes sure
08:41:21 <ezyang> balor_: So?
08:41:22 <cheater79> just saying, there's no reason to give up on purity
08:41:26 <djanatyn> cheater79: Yeah, I want an impure seeding process, I think
08:41:34 <djanatyn> And I'm just a beginner, so I just want to get a random number generator to work.
08:41:36 <ezyang> The dependently-typed encoding will be ~essentially the same thing.
08:41:40 <djanatyn> i'm just learning about purity and everything :D
08:41:53 <cheater79> and in fact, most programs are just fine being repeatably pseudorandom
08:42:01 <cheater79> hell, many programs are required to
08:42:13 <balor_> ezyang, thanks, that makes sense.
08:42:22 <cheater79> so no problem with just making the seed a constant :D
08:42:49 <jmcarthur> beginners should not use unsafePerformIO :\
08:43:17 <luite> cheater79: but that opens a whole new debate about which constant is the most random
08:43:39 <balor_> jmcarthur, As a n00b myself, I agree.  Not using unsafePerformIO forces you to think in pure functional terms.
08:43:48 <jmcarthur> djanatyn: *why* do you want this to be impure?
08:44:06 <djanatyn> jmcarthur: I don't want it to be impure.
08:44:09 <djanatyn> At least, not conciously.
08:44:15 <jmcarthur> balor_: also, this use of unsafePerformIO breaks referential transparency
08:44:16 <djanatyn> I just want a random number generator.
08:44:55 <cheater79> luite, 0
08:45:18 <jmcarthur> djanatyn: the idea behind the standard RNG is that you create a generator and then pass it around in your code. whenever you generate a value from it, you get a new generator with the result and then you start using that one instead
08:45:25 <balor_> djanatyn, I've had the same problem - needing a RNG for use with QuickCheck.
08:45:52 <balor_> djanatyn, Fortunately I work with a Haskell master (kowey) who explained the error of my ways
08:46:36 <luite> QuickCheck has the Gen monad for that
08:46:38 <jmcarthur> djanatyn: there are also ways to use Monad to simplify all this, but i wouldn't even bother with it until you have observed the patterns that come up doing it yourself
08:47:49 <balor_> djanatyn, If you can pull anything worthwhile out of my code here (http://hpaste.org/46699/quickcheck_norng_examples) feel free.
08:58:09 <c3l> when working with HOpenGL, is it ugly to have a function like: "myColor :: GLfloat -> GLfloat -> GLfloat -> IO ()" and "myColor r g b = GL.color $ GL.Color3 r g b"? this feels ugly, what is the recomended way to not have to be so verbose when setting color?
09:08:13 <balor_> Is there a positive integer type in Haskell? (rather than just Int)
09:08:37 <Phyx-> you mean unsigned integer?
09:08:44 <mauke> Word.
09:09:14 <Phyx-> there's also CUInt
09:09:14 <Axman6> > (-1) :: Word
09:09:15 <lambdabot>   18446744073709551615
09:09:35 <mekeor`> > (-0) :: Word
09:09:36 <lambdabot>   0
09:09:39 <balor_> thanks
09:10:04 <Phyx-> > (-1) :: CUInt
09:10:05 <lambdabot>   Not in scope: type constructor or class `CUInt'
09:10:07 <Phyx-> boo
09:10:09 <parcs> c3l: you'll find a more specific audience for your question at #haskell-game
09:11:19 * Phyx- wonders why lambdabot doesn't have FFI types in scope
09:11:32 <c3l> parcs: oh, did not know about that. thanks
09:11:44 <Twey> Phyx-: Because they're unsafe?
09:12:12 <Phyx-> Twey: how so?
09:12:30 <Twey> Don't they include pointer types &c.?
09:12:39 <Twey> Seems like you could do naughty things to lambdabot.
09:12:49 <mauke> types are harmless
09:12:55 <mauke> they don't do anything
09:13:16 <balor_> c3l, As someone who teaches game development in C++, we'd normally simply pass the colour rgb triple into the vertex shader (and then to the fragment shader)
09:13:20 <Twey> Depends how they're implemented
09:19:29 <c3l> balor_: hmm, im new to opengl, what do you mean by vertex shader? currently I set a color, and then a bunch of vertecies to get my shapes with desired color.
09:19:40 <jmcarthur> yeah that's the old way
09:20:32 <jmcarthur> c3l: http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html and http://www.arcsynthesis.org/gltut/ are pretty decent intros to the modern way
09:21:36 <c3l> jmcarthur: interesting, thanks!
09:22:57 * edwardk waves hello.
09:24:15 * jmcarthur waves
09:27:29 <balor_> c3l, as jmcarthur says.  The old way is deprecated.  You should try not using it for new code.  And I second the duriansoftware blog posts, I give them (with permission from Joe Groff) to my students.
09:40:48 <sm> in cabal build-depends, filepath >= 1.1.0.0 && < 1.3.0.0 is equivalent to filepath >= 1.1 && < 1.3 isn't it
09:47:10 <c3l> balor_: wow this is great, but hmm - a bit confusing. do you know if there is some example code for haskell using this 'modern way', that a newbie would be able to understand?
10:06:25 <monochrom> sm: there may be some chance ">= 1.1.0.0" rejects 1.1
10:06:48 <sm> ! :(
10:07:24 <monochrom> let me try it
10:07:37 <sm> monochrom: do you mean there's a chance that's true, or it's true that there's a chance of that ? If you know what I mean
10:07:57 <sm> I dimly remembered the manual saying they were ok
10:08:00 <sm> equivalent
10:09:06 <monochrom> it is now definitely true. "gtk >= 0.12.0.0" rejects my gtk-0.12.0
10:12:02 <sm> thanks for testing, and.. bah!
10:13:06 <sm> actually I guess that's not so bad. As long as I can do gtk > 0.12 and it will use 0.12, 0.12.0, 0.12.0.0 etc. Which I believe it does
10:13:28 <monochrom> >= but yeah
10:13:39 <sm> oops, yeah
10:14:16 <cheater79> what's the difference between >= and >>=?
10:14:24 <danharaj> :t >=
10:14:25 <lambdabot> parse error on input `>='
10:14:29 <danharaj> :t (>=)
10:14:29 <lambdabot> forall a. (Ord a) => a -> a -> Bool
10:14:31 <cheater79> oh ok.
10:14:32 <danharaj> :t (>>=)
10:14:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:14:38 <Twey> cheater79: Everything
10:14:40 <dankna> cheater: what's the difference between a duck?
10:14:47 <Phyx-> rofl...
10:14:50 <dankna> hehe
10:17:09 <monochrom> sm: however, "gtk == 0.12.0.*" accepts 0.12.0
10:18:09 <sm> tricky
10:28:54 <eltrkbrd> I'm new to programming, what would be a good first language?  I'm interested in distributed programming.  There are a number of concurrency based programming languages out there but I'm not sure which would be a good one to start with.  Any recommendations?
10:30:08 <c3l> eltrkbrd: python
10:31:46 <eltrkbrd> c3l, ok thanks
10:31:51 <jrick> go
10:32:20 <eltrkbrd> I was looking at Learn to Program by Chris Pine but it's based on Ruby
10:32:22 <eltrkbrd> http://pragprog.com/titles/ltp2/learn-to-program-2nd-edition
10:32:46 <eltrkbrd> any reason in particular why you recommend Python?
10:35:00 <c3l> eltrkbrd: simple, easy to learn, powerful, interpreted, widely used, great docs. start here http://wiki.python.org/moin/BeginnersGuide, and I dont think this is very on-topic for this channel :)
10:35:51 <eltrkbrd> ok c3l
10:35:54 <eltrkbrd> thanks!
10:36:00 <eltrkbrd> sorry to go off topic
10:36:12 <edwardk> c3l: it fails rather epically on the 'concurrent' front though ;)
10:37:12 <eltrkbrd> edwardk, that's why I was hoping I could just start with a distributed programming language
10:37:16 <jrick> if you want concurrency -> use go
10:37:16 <edwardk> eltrkbrd: if you want a one stop shop for distributed programming, erlang is probably the most consistent thing to build on top of. it has a good story for how to handle most distributed programming woes
10:37:43 <eltrkbrd> I'm interested in learning how to program crossplatform p2p cloud computing applications
10:37:45 <edwardk> go would have been a great language… had it been released 20 years ago
10:38:21 <dankna> edwardk: that's one of the most astute things anyone has said about it
10:38:46 <edwardk> dankna: http://www.cowlark.com/2009-11-15-go/ argues the point quite well, but would roll the clock back to around 41 years ;)
10:39:06 <dankna> hehe
10:41:04 <c3l> but as this is the guys first language, something simpler is probably to prefer. also many universities use python as the introductory language, mit rescently swiched from scheme didnt they? I think thats at least a good indication on python being a good first language. its much easier to understand the more complex stuff when you got a good basic understanding of programming, and python will give that quickly
10:41:20 <dankna> edwardk: looks interesting, readin git
10:41:33 <edwardk> c3l: yes, but python does nothing to help him achieve his stated goal.
10:41:47 <dankna> I've been thinking lately about using languages that don't use block structure for true beginners
10:41:55 <dankna> ie non-Visual BASIC
10:42:10 <dankna> then you can introduce them to { ... } and they'll be like, this is such a relief!
10:42:20 <edwardk> dankna: hah
10:42:24 <dankna> :D
10:44:18 <edwardk> eltrkbrd: http://www.erlangprogramming.org/ is probably a good place to start if you decide to try out erlang. its main advantage is that writing code for one machine or writing code for 100 machines basically uses the same model, and it is robust in terms of how to handle distributed failures, which once you grow to that scale are the norm, not the exception.
10:47:04 <edwardk> http://www.tryerlang.org/ might be an easier way to get started though. (now i'll stop rambling on off topic) =)
10:47:28 <aristid> http://tryhaskell.org would be more on topic :)
10:47:53 <edwardk> aristid: it would, but the distributed programming story for haskell is quite a bit more convoluted.
10:48:02 <eltrkbrd> edwardk, thanks for the suggestion.  Is there a web application framework for erlang?
10:48:28 <eltrkbrd> Scala uses Lift which I heard some compare to RoR for example
10:48:33 <edwardk> eltrkbrd: yes, multiple. https://github.com/yariv/erlyweb for example
10:48:54 <aristid> edwardk: both match try.*\.org :)
10:48:56 <eltrkbrd> maybe I'm getting to far ahead of myself though, considering I'm still at the Hello World stage here in my training ;)
10:48:57 <edwardk> nitrogen, and a bunch of others.
10:49:28 <edwardk> hit tryerlang.org, it has a repl you can use and a tutorial you can walk through that will at least show you the basic syntax.
10:50:48 <eltrkbrd> thanks all!
10:50:59 <edwardk> i confess my experience with the erlang community is a couple of years out of date, so google around for better tools, frameworks, etc.
10:51:23 <edwardk> and there is also #erlang ;)
10:56:09 <industrial> I don't understand this; fn x = ceiling (negate (tan (cos (max 50 x)))) is the same as fn = ceiling . negate . tan . cos . max 50. Where does x come into play in the second? does it mean you can do fn 1 2 3 4 5 and it will feed all those to max including 50?
10:59:04 <doserj> industrial: do you understand why f x = max 10 x is the same as f = max 10?
10:59:05 <Lemmih> industrial: Nope. You said it yourself; the first one definition is the same as the last one definition.
10:59:47 <industrial> doserj: no.
10:59:58 <exlevan> industrial: no, fn takes only one argument. The second case is an example of point-free style, see http://www.haskell.org/haskellwiki/Pointfree
11:00:22 <doserj> industrial: do you understand why f x = sin x is the same as f = sin?
11:03:43 <pastorn> edwardk: heyo
11:03:47 <industrial> I understand that it would work like that but not why. f = sin reads like an assignment, but its part of this currying thing that lets functions have more arguments but really they are functions returning functions with one argument?
11:04:01 <pastorn> edwardk: you broke your reactive repo... can't get it to compile with ghc7 :(
11:04:15 <pastorn> but it just seems to be a smaller version of dependency hell
11:04:30 <industrial> (This would be my real intro into functional programming aswell.. Ideally I've made a small program tonight that takes a list of filenames and renames them on disk to md5(filename).ext
11:05:31 <doserj> industrial: f x = sin x is really just syntactic sugar for f = \x -> sin x, and \x -> sin x is the same as sin by eta-expansion/reduction
11:05:38 <parcs> industrial: do you understand the concept of functions as data?
11:06:25 <Peaker> mink k = take k . sort --- what complexity does this have assuming a good lazy sort?
11:06:48 <Peaker> doserj: up to the horrible MR :-(
11:07:45 <doserj> Peaker: yeah, ceterum censeo MR esse delendam ...
11:08:25 <industrial> parcs: I understand map, select, etc but this guide learnyouahaskell is rewriting their defenitions all the time.. I passed curried application a while ago but I guess it didn't stick >_o
11:12:53 <parcs> industrial: then f = sin should be no problem for you
11:16:21 <applicative> industrial, is the problem with max at the end of ceiling . negate . tan . cos . max since it has 2 arguments?
11:16:50 <applicative> industrial, so that " ceiling . negate . tan . cos " by itself is clear
11:19:25 <danharaj> So I made a package and cabal install'd it
11:19:37 <danharaj> and now I'm trying to use it in ghci, but I get an error like
11:19:46 <danharaj> Failed to load interface for ...
11:19:58 <danharaj> There are files missing in the 'Foo' package.
11:20:03 <danharaj> What did I do wrong :[
11:21:06 <ido> what's the preferred haskell web framework for comet/websocket/longpolling/etc (aka real-time websites)?
11:26:32 <industrial> applicative: yes, exactly that
11:27:39 <Peaker> mink algorithm should be O(N) (or O(N+k*log k) if the result needs to be sorted)..   mink k = take k . sort   is given as an example of niceness of laziness, but it has the wrong time complexity
11:30:38 <Saizan> Peaker: why wrong?
11:30:45 <dmwit> mink k = take k . sort has complexity O(N+k*log k), so what's wrong with it?
11:31:44 <dmwit> Also, do you have a link to the mink algorithm? Google fails me.
11:31:58 <Peaker> dmwit, Saizan: I thought it was O(k*logN)
11:32:26 <dmwit> hm
11:33:15 <dmwit> No, I don't think there's a log(n) term.
11:33:25 <dmwit> Or rather, there is, but not with a k* factor in front. =P
11:33:53 <tromp_> what sort algorithm are you assuming?
11:34:18 <dmwit> merge-sort
11:34:22 <dmwit> (i.e. what's in GHC)
11:34:29 <tromp_> @src sort
11:34:29 <lambdabot> sort = sortBy compare
11:34:33 <tromp_> @src sortBy
11:34:34 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:34:46 <dmwit> That's what's in the report, not what's in GHC. =)
11:34:48 <tromp_> not that one:(
11:35:08 <Peaker> dmwit: so what's the complexity?
11:35:19 <dmwit> Well, I'm bad at this stuff.
11:35:47 <dmwit> But it seems like it ought to be O(N + log(N) + k*log k) = O(N + k*log k)
11:37:11 <dmwit> hm, maybe not
11:37:14 <dmwit> Yeah, maybe you're right.
11:37:19 <dmwit> Maybe it is k*log n after all.
11:37:26 <dmwit> I don't know.
11:38:18 <Looser> ich seh nütschts
11:38:31 <shachaf> How does O(k*log N) make sense?
11:39:27 <dmwit> k elements, each of which come from merging log n lists
11:40:11 <shachaf> Shouldn't it be at least O(N)?
11:40:18 <dmwit> Or rather, merging log n times.
11:40:52 <dmwit> Yes, O(N) to split.
11:41:15 <dmwit> I think Peaker's proposed runtime analysis is O(N + k*log N).
12:00:23 <pastorn> edwardk: hello?
12:05:44 <OceanSpray> so
12:05:50 <OceanSpray> how do I parse layout with parsec?
12:06:17 <pastorn> OceanSpray: "layout"?
12:06:30 <OceanSpray> whitespace sensitivity
12:07:02 <pastorn> perhaps data WS a = WS Int a
12:07:13 <pastorn> then parse each line as a WS Stm
12:07:28 <kowey> so I've got a 5 minute presentation on Haskell to make for Functional Brighton
12:07:30 <pastorn> and later do sanity checking
12:07:32 <kowey> I wonder what I should say...
12:07:48 <pastorn> kowey: five minutes? what's the audience?
12:08:13 <kowey> it's a meetup group for people interested in FP (but of very varied skill levels)
12:08:41 <kowey> there will be several 5 min talks on eg. Closure, Scala, F#, Haskell, maybe even Agda
12:08:50 <pastorn> kowey: a real world example of static type checking doing awesomeness?
12:09:02 <kowey> the idea is the "blind men and the elephant", ie. we all have various probably vague ideas about what FP is
12:09:13 <kowey> and if we each tell our ideas, we could get a clearer picture
12:09:54 <kowey> interestingly enough, everybody in Functional Brighton wants to do F#/Scala in real life... but we all agree on Haskell as a language to be interested in
12:10:01 <chegibari> or a more confused picture
12:10:30 <pastorn> kowey: then perhaps a real world usage of haskell?
12:10:46 <pastorn> kowey: maybe something with snap/yesod?
12:11:06 <kowey> hmm, I may not be able to pull that off in the given prep time, never having played with either
12:11:12 <chegibari> kowey: I used F# for a while and as a result I got more interested in ocaml and haskell
12:11:13 <kowey> but I could mention darcs
12:11:15 <chegibari> :)
12:11:42 <kowey> :-) exactly! one of the things that came up is people wanting to learn Haskell as the easiest way to learn Scala
12:12:06 <kowey> well, wait what I said was the opposite of what you said, but same sort of cross-interest
12:13:01 <pastorn> "Learning haskell is a great way to prepare for C# 3.0"
12:13:44 <chegibari> I mean, I often synthesize my opinion on F# saying that it's the best thing they could do given then constraint of making an ml-like language for .NET. But I don't mean that as a compliment
12:14:54 * roconnor considers making his Hash type a monoid under xor
12:16:01 <chegibari> they language designer are probably great people but nemerle is a more accomplished project that unfortunately wasn't born at microsoft research
12:16:07 <Phyx-> pastorn: you're two major versions behind :P
12:16:12 <Phyx-> two major releases*
12:16:36 <pastorn> Phyx-: it's an spj quote from "A taste of haskell"
12:16:40 <opqdonut_> roconnor: are you xorring hashes a lot?
12:16:46 <pastorn> well, actually it's a quote from some blogger dude
12:17:02 <opqdonut_> or did you mean making an instance just for the hell of it :)
12:17:08 <roconnor> opqdonut_: ... no :( I just want access to the 0 hash :)
12:17:10 <Phyx-> pastorn: ah
12:17:37 <opqdonut_> roconnor: instance Pointed Hash?-)
12:17:56 <roconnor> I though people didn't like Pointed :)
12:18:08 <opqdonut_> I think Monoid is quite ok for exposing a zero
12:18:33 <roconnor> opqdonut_: actually one operation that Sha2 does a lot is add the components of the hash pointwise
12:18:37 <roconnor> I could make that the monoid operation.
12:18:49 <roconnor> and then I'd have my hash0
12:19:28 <roconnor> actually maybe I can get rid of hash0 from my code with a little work.
12:19:33 <roconnor> that would be even better
12:19:52 <roconnor> though tricky
12:20:01 <edwardk> pastorn: hrmm. i'll take a look
12:20:19 * kowey thinks he'll say 3 things: purity, higher order functions and advanced type system 
12:20:40 <mm_freak> utf8-light fails to install for quite some time now
12:20:47 <mm_freak> has anyone had this problem, too?
12:21:01 <chegibari> kowey: what about lazyness?
12:21:08 <pastorn> edwardk: awesome... i've been messing around with $ cabal install some-package-some-very-specific-version
12:21:23 <kowey> hmm, chegibari: *maybe*
12:21:28 <pastorn> edwardk: you should consider having stricter version dependencies on your packages
12:21:36 <kowey> chegibari: but in a way, I don't feel advanced enough to talk about it
12:21:45 <kowey> and I want this very much to be personal experience
12:22:18 <kowey> I mean sure, I do zipWith f xs [1..] all the time, but it doesn't really mean that I'm deep down using laziness for cleaner code the way the real hackers are
12:22:43 <chegibari> kowey: ok. I just it because it may punch in your face even if you are familiar with strict functional languages
12:22:57 <chegibari> I just *mentioned* it
12:23:04 <pastorn> $ cabal install semigroups-0.4.0 # didn't work :(
12:23:07 <pastorn> edwardk: ^^^
12:23:29 <kowey> I suppose I should make the point that laziness is about nicely structured programs
12:23:55 <kowey> I don't know if this happens to a lot of people, but when some folks first hear laziness, they think it's some kind of efficiency thing
12:24:25 <kowey> ... but I'm no John Hughes
12:24:54 <edwardk> pastorn: that is actually one of the things i've been doing, but i'm mostly focused on the upgrade side. even getting the tighter ones i _have_ is a pain in the neck because one update becomes 20 =/
12:25:16 <pastorn> edwardk: what was wrong with category-extras?
12:25:57 <edwardk> pastorn: lots of things. limitations of the api design, impossibility to standardize the haskell 98 parts, the fact that Category isn't as nice as Semigroupoid to build on top of, etc.
12:26:21 <pastorn> edwardk: you mean Control.Category?
12:26:23 <edwardk> splitting it out lets the small obviously correct things be adopted without requiring everyone to understand kan extensions ;)
12:26:25 <chegibari> kowey: I started using lazyness with C#. It has to do with efficiency but affects the structure of the programs of course.
12:26:30 <edwardk> yeah
12:26:41 <pastorn> ok
12:27:04 <edwardk> semigroupoid-extras can provide semigroupoid products, for instance, while you can't build category products with the way category is defined
12:27:08 <edwardk> (id blocks you)
12:27:08 <pastorn> edwardk: but if you could just whip up a quick fix in your reactive repo i would be very grateful :)
12:27:14 <edwardk> that i will
12:27:15 <chegibari> kowey: why do you think people should not associate lazyness with efficiency?
12:27:27 <kowey> oh! that's useful to know, maybe I'm just mistaken
12:28:01 <pastorn> edwardk: and perhaps lock it to certain versions of your other libraries (no more of this <= x, >= y nonsense)
12:28:08 <kowey> I think I just somehow got in my head either from reading Why FP matters and also working on the wikibook that really the take home message is the structure of your programs
12:28:33 <pastorn> or maybe that will mess up other stuff for when those packages needs to be installed
12:28:37 <kowey> that laziness makes certain nicer ways of writing program practical
12:28:38 <edwardk> the >= and < stuff is really really important because otherwise i get much worse problems =P
12:28:46 <pastorn> edwardk: hahaha :)
12:29:55 <edwardk> ah now i remember. i ran into some problem with a universal quantification that i didn't understand at the time
12:30:06 <edwardk> that was what kept me from upgrading reactive when i bumped all my other packages
12:31:37 <edwardk> something with the way impredicative types changed on the way to 7.0.x
12:33:18 <pastorn> "impredicative" <-- is that even a word?
12:33:27 <edwardk> yes =)
12:33:28 * pastorn hates haskell at times
12:33:57 <beastaugh> blame Russell
12:34:12 <beastaugh> although we don't mean the same by the term as he did
12:34:30 <edwardk> i think i shoehorned an unsafecoerce in to get it to like the new compiler, one sec
12:35:32 <dons> tommd: do you know if there are arm-based laptops these days? thinking that if I got one, we might get better arm support for ghc
12:35:33 <edwardk> pastorn: try pulling the current repo
12:35:51 <edwardk> what is one little unsafeCoerce between friends? =)
12:36:11 <edwardk> i also silenced a couple of warnings for when tests are turned off
12:36:38 <edwardk> grabbing lunch, lemme know if its still in dependency hell
12:36:45 * shachaf thinks edwardk's type disease is going too far.
12:36:49 <aristid> dons: doesn't stallman have one? :D
12:36:52 <pastorn> edwardk: in a minute... i'm in a game of Race For The Galaxy right now :{)
12:36:54 <pastorn> :)
12:37:27 <edwardk> type disease?
12:37:48 <edwardk> these aren't my types. they are conal's ;)
12:38:05 <dolio> dons: Because you'd be maintaining the ARM backend, or because you'd be a high profile ARM user? :)
12:38:09 <shachaf> edwardk: Making the type system do ridiculous things is one thing. But using unsafeCoerce to make things work the way you want...
12:38:33 <danharaj> unsafeCoerce is a perfectly legitimate function.
12:38:46 <dolio> I thought that was mmorrow disease.
12:39:02 <edwardk> its just to get a single impredicative type smuggled past ghc 7. i might go through and tie everything up with a little newtype bow later on
12:39:07 <edwardk> hah
12:39:26 <shachaf> Isn't there an XO laptop that uses ARM?
12:39:31 <dolio> GHC 7 did break some higher-rank types in weird ways.
12:39:34 <shachaf> Ah, apparently not yet.
12:39:45 <edwardk> warning: may cause loss of community involvement
12:40:03 <olsner> toshiba made an android laptop/netbook, tegra based iirc
12:40:46 <aristid> there are also the ARM-based plug computers
12:40:46 <pastorn> olsner: tegra? sounds awesome
12:41:16 <dons> dolio: cause i'd maintain it
12:43:07 <olsner> pastorn: yep, it was tegra, Toshiba AC100 was the full name btw
12:43:21 <pastorn> olsner: sounds awesome... you have a linky?
12:43:42 <olsner> google has lots of links ;)
12:44:40 <dons> ah yes
12:44:45 <dons> http://www.engadget.com/2010/09/06/toshiba-ac100-android-smartbook-hits-the-united-kingdom/
12:47:46 <dons> only in the uk. weird
12:49:38 <olsner> you could... get a high-end android phone with hdmi-out and usb host-mode support and connect an external keyboard through usb :)
12:50:37 <dons> yeah, i guess ghc on android is higher priority
12:51:07 <dons> first, better arm support, then android
12:58:20 <mreh> Parsec places the text "***Exception.." at the beginning of its error messages
12:58:33 <mreh> i thought it was causing an exception for ages
12:58:38 <mreh> how do I get rid of it?
13:03:36 <c_wraith> drop 14?
13:06:11 <mreh> c_wraith: that and Text.Parsec.Error.showErrorMessages ;)
13:06:18 <c_wraith> :)
13:06:32 <mreh> i'm confused as to where it comes from
13:07:03 <mreh> is it added by Monad (Either String)
13:07:14 <mreh> @instances Monad
13:07:14 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
13:07:47 <mreh> > either id "Success" . fail $ Left "Hello"
13:07:47 <lambdabot>   Couldn't match expected type `b -> a'
13:07:47 <lambdabot>         against inferred type `[GHC.T...
13:08:08 <mreh> > either id "Success" . fail $ "Hello"
13:08:08 <lambdabot>   Couldn't match expected type `b -> a'
13:08:09 <lambdabot>         against inferred type `[GHC.T...
13:08:44 <shachaf> > fail "abc" :: Either String Int
13:08:44 <lambdabot>   Overlapping instances for GHC.Base.Monad
13:08:45 <lambdabot>                              (Data...
13:08:58 <mreh> > either id (const "Success") . fail $ "Hello"
13:08:59 <lambdabot>   Overlapping instances for GHC.Base.Monad
13:08:59 <lambdabot>                              (Data...
13:09:11 <mreh> heh
13:09:46 <mreh> anyway, ghci says -> yes
13:10:22 <shachaf> @quote ghci
13:10:22 <lambdabot> ghci says: yes
13:12:38 * RayNbow looks at slide 21 of http://www.galois.com/~dons/slides/08-07-stewart.pdf ... should that "exists" really be in the definition of Stream?
13:15:03 <pastorn> edwardk: should i pull the repo and try?
13:15:27 * RayNbow looks at dons
13:17:38 <mreh> am I abusing Parsec by using Parser to parse my command line arguments and return sensible error messages?
13:18:38 <mreh> if you try and parse "--hello" with string "--help", you get unexpected "l"
13:19:45 <jaspervdj> edwardk: So, how about another skype session tomorrow?
13:26:01 <ion> oceanspray: http://hpaste.org/46715/parsing_indented_layout
13:27:10 <sshc> Saizan: I have a couple questions, if you wouldn't mind answering them: 1) Is codensity beneficial for every free monad (from a functor)?  If it's not, is it ever harmful for a free monad?  2) Is codensity beneficial for any monad that isn't free?
13:27:42 <jaspervdj> edwardk: I remember you'd like something a little later?
13:30:47 <sshc> edwardk: You're the author of category-theory-extras, right?
13:43:12 <Saizan> sshc: 1) afaik, one issue is that you lose sharing
13:43:29 <Saizan> sshc: but that's not so often needed for intermediate computations
13:43:36 <sshc> Sharing?
13:46:07 <Saizan> let m :: Codensity (Free F) A; m = .. in (runCodensity m return, runCodensity m return) -- here you're going to produce two distinct trees
13:46:14 <Saizan> even if equal
13:48:47 <Saizan> about 2) it seems Codensity (Reader s) is a quite beneficial way to implement State s
13:49:36 <edwardk> back
13:49:40 <edwardk> pastorn: yes
13:49:45 <edwardk> sshc: category-extras, yes
13:50:39 <obbele> Typeclassopedia
13:51:04 <obbele> (oops) I was meaning : in Typeclassopedia
13:51:09 <edwardk> jaspervdj: can we do tuesday?
13:51:21 <pastorn> edwardk:  https://github.com/ekmett/reactive <-- the dates are old :(
13:51:34 <edwardk> jaspervdy: and iirc we were talking something like 3 hours earlier?
13:51:41 <obbele>  ... there is a paragraph about Functor ((->) e), where can I find information or source about this definition ?
13:51:45 <edwardk> pastorn: hrmm
13:51:56 <pastorn> edwardk: push?
13:52:00 <edwardk> try now
13:52:15 <edwardk> er jaspervdj
13:52:26 <Cale> obbele: You can find it here :)
13:52:33 <edwardk> obbele: it is in Control.Monad.Instances
13:52:37 <dmwit> obbele: The source is very short: instance Functor ((->) e) where fmap = (.)
13:52:49 <edwardk> obbele: it is also the only definition that makes sense for that type ;)
13:52:52 <Cale> obbele: (->) e is a partial application of the type constructor for functions.
13:52:54 <edwardk> so that helps a bit
13:53:02 <Cale> So, (->) e a = e -> a
13:53:12 <Cale> If we substitute this into the type for fmap:
13:53:23 <Cale> fmap :: (Functor f) => (a -> b) -> (f a -> f b)
13:53:37 <Cale> fmap :: (a -> b) -> ((e -> a) -> (e -> b))
13:54:10 <Cale> It's exactly the type of function composition
13:54:35 <obbele> hum ... let me think about this ...
13:55:00 <edwardk> sshc: codensity helps sometimes. not always. it should help when you are building a free monad of something that fans out a lot. so that you wind up with a big intermediate state that >>= would normally have to keep traversing over and over.
13:55:07 <Cale> Intuitively, when you have fmap f g = f . g you're thinking of g as a "container" indexed by values of type e
13:55:18 <Cale> (and holding values of type a)
13:55:23 <Cale> That is, a function e -> a
13:55:27 <Cale> and f :: a -> b
13:55:35 <Cale> and we're applying f to all the elements of that container
13:55:38 <edwardk> sshc: in that sense codensity enforces a kind of (>>=)-fusion that right associates all your binds, to make them all happen in one traversal. this is bad if you need to recycle the intermediate monadic values
13:55:46 <Cale> to get a new container e -> b
13:56:13 <obbele> Cale: oki, I think it makes some sense
13:56:28 <ion> (+1) is the container of all integers that is indexed by an integer and holds the respeective successor.
13:56:54 <Cale> Yeah, you can picture it as a giant array if it helps :)
13:57:21 <obbele> so fmap f (+1) would apply f to this giant array ?
13:57:28 <Cale> yeah
13:57:35 <edwardk> sshc: as for the use of things like Codensity Reader. Codensity Reader works for state because Ran ((->)e) ((->)e) is isomorphic to State. (which comes from the way adjunctions are related to codensity. it happens to be faster in some scenarios and slower in others for the same reasons that bos pointed out that sometimes continuation passing style is awesome and sometimes it is not in http://www.serpentine.com/blog/2011/02/25/cps-is-gr
13:57:37 <dRbiG> okay, i have my data structure with a number of fields, now i want to update one field, is there any better method than explicitly creating new instance while copying data from the older?
13:58:00 <edwardk> pastorn: you all set?
13:58:18 <obbele> and I've search for this definition in Control.Monad.Instances as mentioned by dmwit, but never found it :(
13:58:33 <obbele> it disappears from http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#fmap
13:58:34 <Cale> dRbiG: Syntactically, you can use record update syntax: myRecord { foo = bar }
13:58:43 <edwardk> obbele: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Control-Monad-Instances.html
13:58:44 <ion> > fmap show [1..] !! 42
13:58:45 <lambdabot>   "43"
13:58:50 <ion> > fmap show (1+) $ 42
13:58:51 <lambdabot>   "43"
13:59:04 <Cale> dRbiG: But semantically this copies the elements which you didn't change. It doesn't tend to matter since they're all code pointers anyway, and pretty cheap to copy.
13:59:28 <obbele> edwardk: thanks, I did not see this
13:59:54 <Cale> obbele: Yeah, there's a source link on all the documentation pages.
14:00:13 <Cale> er, oh
14:00:21 <dRbiG> Cale: right now i'm doing it like updateThing thing x = Thing (fieldOne thing) (fieldTwo thing) x (fieldThree thing)
14:00:22 <Cale> Yeah, you must have known already :)
14:00:25 <pastorn> edwardk: playing rftg... hard to multitask...
14:00:33 <edwardk> pastorn: =)
14:00:34 <dRbiG> which is not nice, however works
14:00:45 <Cale> dRbiG: okay, so updateThing thing x = thing { fieldThree = x }
14:00:52 <Cale> is equivalent to that
14:01:00 <dRbiG> but saves a lot of writing
14:01:02 <dRbiG> thx! :)
14:01:30 <Cale> er, not quite equivalent to what you actually wrote, but equivalent to what you meant ;)
14:01:56 <dRbiG> which is what matters for me now
14:02:37 <ion> drbig: Also see fclabels.
14:03:01 <jaspervdj> edwardk: right, my mistake, tuesday is fine for me :-) and I can make 3 hours earlier
14:03:25 <edwardk> how is 3 and a half earlier for you?
14:03:33 <dRbiG> hmm is there any way to refer to the values from the 'older' data? i need to do fieldWhatever++
14:03:42 <edwardk> trying to fit my schedule together for tuesday
14:04:09 <dRbiG> so writing fieldWhatever = ((fieldWhatever thing) + 1) again looks to me like doing it wrong ;)
14:04:12 <ion> drbig: With fclabels, modL fieldName (+1)
14:04:28 <edwardk> (heck if you want, we could just sit down right now)
14:04:55 <jaspervdj> edwardk: I was actually just about to go to sleep, sorry
14:05:07 <edwardk> no worries
14:05:11 <jaspervdj> edwardk: But yeah 3 and a half earlier is fine for me as well
14:05:20 <edwardk> sounds good, lets plan on that then
14:05:59 <sm> is there a flag to make ghc report only the first compilation error ?
14:05:59 <jaspervdj> That's, erm, 2h30 PM UTC?
14:09:24 <jaspervdj> edwardk: Hmm, looks like I'll only have one hour then, is that not a problem?
14:09:42 <edwardk> no problem
14:09:52 <edwardk> that is pretty much perfect actually, since i have about the same
14:10:25 <jaspervdj> Alright. I'm off to bed, bye
14:11:49 <obbele> and to continue with ((->) e), the Pointed instance of this 'container' would be pure a = \_ -> a ?
14:13:23 <Cale> obbele: yeah
14:13:28 <edwardk> obbele: yep
14:13:34 <ion> > pure 42 "foo"
14:13:34 <lambdabot>   42
14:14:11 <obbele> ion: but "foo" is not of type ((->) e), is it ?
14:15:23 <obbele> wait I'm confused ... pure 42 "foo" == (pure 42) "foo" == (\_ -> 42) "foo" == 42
14:15:38 <obbele> you were right oO
14:16:43 <obbele> I see the category-extras package is marked as obsolete, is there some new package superseeding it and re-using Pointed ?
14:16:58 <BMeph> obbele: I sense that in a couple of minutes, you might be asking yourself, "Wy didn't I take the RED pill?" ;)
14:17:19 <BMeph> s/Wy/Why/
14:18:47 <Cale> http://hackage.haskell.org/package/pointed
14:19:03 <Cale> category-extras was split up into a million tiny packages
14:19:18 <obbele> BMeph: well at the beginning of this evening, I though about looking at iteratees or typeclassopedia, I still think I choose the simplest option
14:21:00 <edwardk> obbele: also, pointed is one of those things that i only put a package out to support because so many people asked for it, i mostly prefer looking at the semigroup-like structures, bind without return for instance, or ap without pure because you can actually express meaningful laws
14:21:14 <edwardk> Pointed is pointless because the only law relating it to Functor is a free theorem.
14:21:18 <roconnor> @unmtl StateT s Maybe a
14:21:19 <lambdabot> s -> Maybe (a, s)
14:23:13 <yitz> edwardk: yay semigroups!
14:23:41 <obbele> yitz: it's all hebrew/math for me ;)
14:23:41 <edwardk> yitz: oh yeah, i gave you your sconcat =)
14:23:57 <roconnor> @hoogle get
14:23:58 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
14:23:58 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
14:23:58 <lambdabot> Control.Monad.State.Class get :: MonadState s m => m s
14:24:00 <yitz> ooo! \o/
14:24:04 <dolio> Yeah. Why would you want to overload a function name if the only law relating it to some other function is a free theorem?
14:25:21 <edwardk> dolio: in 'pointed' i just removed the Functor superclass constraint. there is an argument for something like Pointed, just like there is an argument for data-default, but in practice i find them less than useful because of the lack of laws. all you get is a reused name
14:25:49 <edwardk> dolio: sarcasm deliberately ignored ;)
14:26:10 <aristid> edwardk: without laws, it's harder to make meaningful combinators?
14:26:14 <yitz> edwardk: now we just need to convince authors of all the packages with important monoid instances to factor them through semigroup instances.
14:26:26 <edwardk> aristid: correct, there weren't any meaningful combinators to build on top of it
14:26:35 <yitz> edwardk: i.e. functor/monad revisited
14:27:01 <aristid> yitz: always fun, isn't it
14:27:06 <edwardk> yitz: well, everything up through my kan-extensions package tries to do the right thing and provide all the appropriate semigroup/semigroupoid instances
14:27:08 <roconnor> @hoogle runStateT
14:27:09 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
14:27:09 <lambdabot> Control.Monad.State.Strict runStateT :: StateT s m a -> s -> m (a, s)
14:27:41 <roconnor> @type atomicModifyIORef
14:27:42 <lambdabot> Not in scope: `atomicModifyIORef'
14:27:57 <yitz> aristid: yeah, it's like a sequel to a bad movie
14:28:10 <yitz> edwardk: oh really? i'll have a look.
14:28:27 <roconnor> @hoogle atomicModifyIORef
14:28:28 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
14:31:20 <dolio> Isn't it only a theorem under the premise that f is a functor?
14:32:08 <dolio> Or, endofunctor.
14:32:42 <roconnor> do I need -XFlexibleContexts to use the mtl?
14:32:58 <dolio> Not necessarily.
14:33:12 <Saizan> but it's likely
14:35:19 <aristid> roconnor: you probably don't need it if transformers suffices for you :P
14:36:12 <roconnor> I was using a MonadState constraint, but I just changed it to use StateMonadT directly
14:36:14 <roconnor> for now
14:36:40 <aristid> can't use FlexibleContexts?
14:37:11 <djanatyn> I'm writing a todo list in Haskell :D
14:37:12 <djanatyn> https://github.com/djanatyn/htd/blob/master/main.hs
14:44:17 <tromp_> todo = map Maybe [...]
14:44:56 <mgsloan> todo = map (const Nothing) [...]
14:46:20 <mgsloan> (fixed it for ya :))
14:58:38 <JoeyA> map f (x:xs) = f x : map f xs
14:58:48 <JoeyA> When this is evaluated, it forms a cons cell of two thunks.
14:59:00 <JoeyA> (optimizations aside)
14:59:15 <JoeyA> The outer expression can be said to have three variables of context: f, x, and xs
14:59:28 <JoeyA> Each thunk only needs two of them.
14:59:47 <JoeyA> What term is used to describe rebuilding the context when constructing a thunk?
15:01:15 <JoeyA> Another example (in JavaScript): var bigThing1, bigThing2, bigThing3; function foo(x, y) { var bigThing4, bigThing5; ... function bar() { return x+y; } return bar; }
15:02:08 <JoeyA> When the closure bar is allocated, it will probably form a data structure holding references to x and y.
15:02:43 <JoeyA> I guess the answer to my question would be "bind".
15:03:08 <JoeyA> When the thunks in map are allocated, f and x are bound to the expression "f x"
15:07:12 <Cale> JoeyA: I'm not sure I understand what you mean by rebuilding the context...
15:08:07 <Cale> I don't often think at the level of thunks though. I prefer to just think in terms of expressions (or if need be, expression graphs)
15:08:55 <JoeyA> I'm trying to implement this stuff
15:09:19 <JoeyA> Cale: suppose, for whatever reason, we have a thunk {f, x, xs} \u {} -> f x : map f xs
15:09:42 <JoeyA> (this means it is allocated with three free variables of context, f, x, and xs)
15:10:03 <JoeyA> To evaluate it, we return a cons of two thunks.
15:10:11 <JoeyA> Each thunk needs its own set of free variables.
15:10:19 <JoeyA> f x needs f and x
15:10:23 <JoeyA> map f xs needs f and xs
15:10:30 <Cale> I suppose so :)
15:10:45 <JoeyA> So at some point, you have to take {f, x, xs} and rip out the variables you need.
15:10:56 <JoeyA> I'm trying to find the name for that :-)
15:11:43 <JoeyA> "There are 2 hard problems in computer science: cache invalidation, and naming things"
15:12:15 <ben> I don't get it
15:12:23 <flippo> Sounds about right
15:12:26 <Cale> I'm not 100% sure that I get it either :)
15:12:43 <roconnor> @hoogle guards
15:12:43 <lambdabot> Control.Exception.Base nonExhaustiveGuardsError :: Addr# -> a
15:13:01 <JoeyA> Naming functions, etc. is hard.
15:13:01 <Cale> You want to scrutinize expressions at runtime to determine what variables are free in subexpressions?
15:13:34 <JoeyA> Cale: I want to allocate a closure's context using pre-determined indices on the parent expression's context.
15:13:58 <JoeyA> Writing a semantic analysis pass is on my to-do list.
15:14:11 <Cale> The code that you compile for the new closure can just refer to the locations used by the closure which constructs it?
15:14:32 <Cale> Or will that not work somehow?
15:14:43 <JoeyA> That risks memory leakage.
15:14:57 <Cale> I'm not sure I understand why.
15:14:58 <JoeyA> f number hugestring = number + 1
15:15:33 <JoeyA> let x = f 3 (readFile' "big-file")
15:16:01 <Zao> @type \x -> const (x + 1)
15:16:02 <lambdabot> forall a b. (Num a) => a -> b -> a
15:16:10 <Cale> readFile' "big-file" should never be evaluated there
15:16:25 <JoeyA> let x = f 3 $! readFile' "big-file" :-)
15:16:28 <Zao> @pl \x -> const (x + 1)
15:16:29 <lambdabot> const . (1 +)
15:16:31 <Cale> even still
15:16:34 <Cale> well, okay
15:16:40 <Cale> It'll immediately become garbage.
15:17:03 <Cale> Why wouldn't it?
15:17:17 <JoeyA> I guess a more realistic example would be:
15:17:21 <Cale> There's no reference to that variable in the resulting expression
15:17:32 <JoeyA> let a = ...; b = ...; c = ...; x = f a; in ...
15:18:03 <JoeyA> in doSomethingWith x
15:18:20 <JoeyA> err, you'll need to use a, b, and c for something too.
15:18:36 <JoeyA> But suppose they're huge, and you don't need them anymore, but need x for a long time after.
15:18:52 <JoeyA> x needs to keep f and a in memory, but not b and c.
15:19:01 <Cale> I'm still not seeing it... you're still going to GC those because they're not the things you're holding references to.
15:19:51 <Cale> Each variable is separate
15:20:11 <JoeyA> If the thunk allocated for `f a' simply uses the parent expression's context {f, a, b, c, x}, it'll hold b and c in memory.
15:20:34 <Cale> What is this {f,a,b,c,x} thing? Is it something explicit in memory, or just a set of things in memory?
15:20:41 <Cale> (I would think the latter)
15:20:50 <JoeyA> it's the free variables allocated for a closure.
15:21:10 <Cale> You statically know what the free variables are though.
15:21:17 <JoeyA> Right
15:21:30 <JoeyA> The free variables for `f a' are just {f, a}
15:21:38 <Cale> So you can compile code which fills them in appropriately with references to just the single things which need to be filled in
15:21:44 <JoeyA> But the free variables for the expression invoking `f a' may include more.
15:21:57 <JoeyA> Cale: Exactly.
15:22:02 <JoeyA> What's that "called" ?
15:22:10 <Cale> I don't think it has a name
15:22:29 <Cale> It's just the obvious way to do things :)
15:23:06 <Cale> If you hang on to every variable ever and never GC anything, you'll waste a lot of space, obviously :)
15:23:41 <Cale> The code for  f x : map f xs  will construct a cons cell with two closures, each of which holds references to only two of {f,x,xs}.
15:24:16 <Cale> but, that's nothing special, it just happens because the other variable in each case doesn't occur in that subexpression
15:26:13 <Cale> The closure constructed for f x can't hold a reference to xs because there's no place for it, as it doesn't occur in the expression.
15:26:59 <Cale> Though I suppose you could allow that somehow, it's not particularly useful.
15:28:47 <_linuxftw> How do I convert a tuple to a list?
15:29:36 <Zao> _linuxftw: Manually?
15:29:39 <Cale> _linuxftw: pattern match on it and use the bound variables to explicitly make a list
15:29:48 <Cale> f (a,b,c) = [a,b,c]
15:30:04 <Cale> Of course, the elements will all have to be the same type
15:30:06 <_linuxftw> So there's no tupleToList?
15:30:08 <Zao> @type \(x,y,z) = [x,y,z]
15:30:09 <Cale> nope
15:30:09 <lambdabot> parse error on input `='
15:30:14 <Zao> @type \(x,y,z) -> [x,y,z]
15:30:14 <lambdabot> forall t. (t, t, t) -> [t]
15:30:18 <Cale> also, all tuple types are separate
15:30:28 <Cale> yeah, you can use a lambda like Zao shows
15:30:40 <Philippa_> _linuxftw: how would you type it?
15:30:49 <Philippa_> (haskell isn't python)
15:30:53 <Cale> Anything you write will only work for one tuple type at a time.
15:30:56 <_linuxftw> I don't know, but now you mention it it might be a problem
15:30:59 * JoeyA prefers using the Dvorak layout
15:31:02 <Cale> (unless you use the magic of typeclasses)
15:31:11 <JoeyA> (a, a, a) -> [a]
15:31:27 <Zao> let t3l (x,y,z) = [x,y,z], t4l (x,y,z,a) = [x,y,z,a], etc.
15:31:28 <_linuxftw> Couldn't you make a special case assuming all the tuple elements were the same type?
15:31:32 <Philippa_> Cale: even then it doesn't generalise properly :-(
15:31:40 <Philippa_> _linuxftw: you'd need one such case for each tuple length
15:31:55 <_linuxftw> ah
15:31:56 <_linuxftw> shame
15:32:15 <Zao> There's no built-in way to get a an element and a 2-tuple from a 3-tuple, for example.
15:32:17 <Cale> We don't tend to use tuples larger than pairs or triples all that often
15:32:27 <Zao> Otherwise you could write something genericish with  tupleHead and tupleTail.
15:32:41 <Cale> If you have even 3 elements in your tuple, it's probably a good time to consider defining your own datatype
15:33:00 <gwern> 'Finally they go on to say that ``although most people now agree that the use of high-level languages is desirable, the fact remains that many major systems are still written in assembly language.'' And of course that's still true today, although the syntax is worse and now it's an ANSI standard. ' hah. http://www2.parc.com/csl/groups/sda/projects/oi/towards-talk/transcript.html
15:33:24 <_linuxftw> "many major systems" doubtful
15:33:57 <JoeyA> Hmm, I wonder how, if possible, you would make a generic tuple-to-array function.
15:34:11 <JoeyA> Would you need type families?
15:34:18 <Zao> Does popular Haskell implementations have a max arity of tuples?
15:34:23 <Cale> yes
15:34:24 <JoeyA> 62
15:34:32 <_linuxftw> that's pretty arbitrary
15:34:46 * ddarius thinks _linuxftw was a) missing the joke and b) missing the date.
15:34:50 <Zao> It's in the report, I reckon?
15:34:50 <Philippa_> Cale: butbutbut I'm doing credit card transformations and I don't want to define a datatype for a single function! (is what extensible records are for, of course)
15:34:52 <gwern> _linuxftw: I take it as a reference to C. I think many major systems are written in C...
15:35:33 <Zao> "However, every Haskell implementation must support tuples up to size 15, .."
15:35:39 <Zao> H98 sayeth.
15:35:57 <JoeyA> > let f (_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_) = 5 in f
15:35:58 <lambdabot>   Overlapping instances for GHC.Show.Show
15:35:58 <lambdabot>                              ((t,
15:35:58 <lambdabot>  ...
15:36:04 <JoeyA> > let f (_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_) = 5 in f undefined
15:36:05 <lambdabot>   *Exception: Prelude.undefined
15:36:05 <_linuxftw> ddarius, point taken
15:36:10 <Philippa_> if you're using ones that big you should've at least nested pairs anyway
15:36:17 <_linuxftw> *maybe* i'll read the link next time
15:36:18 <JoeyA> oops
15:36:46 <parcs> :t (,5)
15:36:47 <lambdabot> Illegal tuple section: use -XTupleSections
15:36:49 <JoeyA> > let f (_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_) = 5 in f (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
15:36:50 <lambdabot>   5
15:36:56 <JoeyA> > let f (_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_) = 5 in f (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
15:36:56 <lambdabot>   A 63-tuple is too large for GHC
15:36:56 <lambdabot>    (max size is 62)
15:36:56 <lambdabot>    Workaround: use nest...
15:37:10 <Zao> I guess I shouldn't have used the "popular" quantifier in my question.
15:37:16 <Zao> As H98 only guarantees 15 :D
15:37:32 <tromp_> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:37:33 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
15:37:33 <lambdabot> t63. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 ->
15:37:33 <lambdabot> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> (a, b, c,
15:37:33 <lambdabot> d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53,
15:37:33 <lambdabot> t54, t55, t56, t57, t58, t59, t60, t61, t62, t63)
15:37:45 <tromp_> ouch:(
15:37:53 <ddarius> If you are using a tuple with anything close to 62 fields, you are doing something wrong.
15:38:10 <Philippa_> ddarius: that, or being a complete arsehole, yeah
15:40:32 <Draconx> Philippa_, being a complete asshole probably counts as "doing something wrong".
15:40:52 <dons> locale hacking, http://stackoverflow.com/questions/6011367/sorting-and-comparing-strings-by-locales-in-haskell
15:40:56 <dons> did i miss anything?
15:41:57 <ezyang> Those two are pretty reasonable answers.
15:42:51 <dons> i'm trying to think if i'm missing any parts of the api
15:43:03 <dons> esp. wrt. string io and locales in the base library, the new stuff JaffaCake1 added
15:44:18 <args0> hello
15:44:23 <dons> ezyang: yeah, ok. i think that's enough.
15:45:45 <roconnor> @hoogle atomicModifyIORef
15:45:46 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
15:46:48 <Draconx> dons, well, suggesting that toUpper does "unicode case conversion" is somewhat misleading, since it will obviously fail on cases where the case conversion is context-sensitive or when the uppercase form has more (or fewer) characters than the lowercase form.
15:49:51 <cheater79> hi
15:49:58 <drunK> I just upgraded ghc from 6.12.3 to 7.0.3 and it compiles programs much slower than 6.12.3 (and also produces slower binaries). is that normal?
15:50:02 <cheater79> is [ 1, 2, 3 ] syntactic sugar for do?
15:50:35 <dons> Draconx: yes, i talk about how it is all wrong for any multi-char conversion
15:51:26 <MatrixFrog1> cheater: no, it's syntatic sugar for (1:2:3:[]) isn't it?
15:52:27 <dons> Draconx: and toUpper does use LC_CTYPE
15:52:39 <dons> so "locale aware" again
15:52:46 <dons> i'll clarify
15:53:04 <Draconx> dons, ah, I see that you mention that in the very last sentence.  However, the first sentence of the second-to-last paragraph seems to be missing this important detail, as it says simply that "[the functions in Data.Char] do unicode case conversion".
15:53:51 <dons> yeah, hmm. more appropriate would be "wide char conversion, based on the LC_CTYPE locale setting"
15:54:31 <ddarius> Just what would be needed, syntactic sugar for syntactic sugar.
15:54:50 <hpc> ddarius: you mean template haskell? :P
16:06:05 <PrairieEagle> hello
16:06:58 <MercedesBenz> hi
16:07:16 <MercedesBenz> what GUI do you prefer for Haskell apps?
16:08:08 <primeq> well, I'm just getting started - using Leksah
16:08:55 <MercedesBenz> I don't see it in the list: http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
16:09:01 <MercedesBenz> what IDE do you use for Haskell?
16:09:05 <dylukes> TextMate~
16:09:20 <dylukes> Leksah is an IDE btw
16:09:25 <dylukes> GUI lib wise most people use gtk2hs
16:09:26 <MercedesBenz> oh...
16:09:27 <MercedesBenz> I see
16:09:38 <dylukes> from what I've seen.
16:10:07 <dylukes> Some of the FRP ones look interesting though.
16:11:30 <MercedesBenz> thanks
16:11:40 <MercedesBenz> very weird : http://www.gtk.org/language-bindings.html doesn't work the link to Haskell
16:11:40 <primeq> anybody up for discussing Haskell as a professional career?
16:11:51 <MercedesBenz> primeq : me, interested.
16:12:06 <MercedesBenz> I am thinking switching from Java or learning both languages.
16:12:21 <primeq> Merceded, what brought you to Haskell 1st place?
16:12:27 <MercedesBenz> http://haskell.org/gtk2hs/ >>> not found ... sad!
16:12:54 <MercedesBenz> primeq : the idea, that there are millions of Java developers and not so many of Haskell ones.
16:13:29 <Philippa_> you fancied the path more avoided?
16:13:57 <primeq> MercedesBenz - true that, but Java long since reached critical mass, and work is easy to find
16:14:14 <ddarius> Philippa_: I don't think most programmers "avoid" Haskell so much as never heard of it.
16:14:39 <primeq> Haskell has many things in its favor, but where can you use it (Galois for one, but taht is a very high entry barrier)
16:14:43 <dylukes> ddarius: Haskell kind of gets scape goated in the place of all FP lands.
16:14:44 <dylukes> langs*
16:15:05 <dylukes> The only groups that like Haskell and employ are Galois and Microsoft Research...
16:15:06 <ddarius> Not really, and whether that's the case or not, only very recently.
16:15:14 <primeq> dylukes how do you mean "scapegoated"?
16:15:20 * MercedesBenz installed Haskell platform, installing Leksah.
16:15:29 <dylukes> I mean, I've heard people criticize Haskell for failings of ML, Erlang and Lisp.
16:15:30 <edwardk> dylukes: and a half dozen financial software companies, and bluespec, and ...
16:15:39 <dylukes> edwardk: Yep yep.
16:15:53 <ddarius> edwardk: There's a whole list online.  (Obviously not comprehensive.)
16:15:55 <Luke> does anyone know of a CSV -> ByteString library?
16:16:07 <ddarius> @hackage csv
16:16:08 <lambdabot> http://hackage.haskell.org/package/csv
16:16:15 <dylukes> Luke: Writing one using Parsec is a very common tutorial too >_>
16:16:18 <dylukes> I think RWH does it.
16:16:24 <ozataman> Luke: http://hackage.haskell.org/package/csv-enumerator
16:16:27 <primeq> anyone have experience introducing haskell at the workplace, even starting small?
16:16:56 <dylukes> primeq: I'm trying to get people at my school interested in it… but the seeds will not grow.
16:16:59 <Luke> ozataman: thanks
16:17:05 <edwardk> primeq: we use haskell for almost all of our idea whiteboarding, and a good chunk of our prototyping, but wind up implementing in scala
16:17:07 <dylukes> The best I've done is getting my CS class to switch from Java to python,
16:17:11 <dylukes> and now I'm pushing using functools.
16:17:12 <dylukes> >_>
16:17:24 <primeq> dylukes, strange that. Schools u'd think would be into new things good for learning
16:17:31 <dylukes> primeq: oh no!
16:17:33 <ddarius> edwardk: In Haskelly Scala for many it sounds like.
16:17:35 <dylukes> schools hate "new" things!
16:17:38 <dylukes> Why?
16:17:43 <dylukes> because teachers aren't up to date!
16:17:46 <edwardk> yeah.
16:17:50 <dylukes> And god forbid experimentation,
16:17:52 <dylukes> or self driven study.
16:17:56 <dylukes> Egads that would be terrible.
16:17:58 <primeq> yup -and vested itnerests control education too much
16:18:05 <edwardk> categories and monoids and comonads abound ;)
16:18:32 <dylukes> Im still vehemently carrying on my one-man campaign,
16:18:41 <dylukes> to turn the AP Computer Science exam into a portfolio review.
16:18:46 <dylukes> >_>
16:18:51 <primeq> dylukes more power to you - good luck
16:19:04 <dylukes> Or at least, I'd prefer if the exam were 6 hours,
16:19:06 <dylukes> with a very large task,
16:19:10 <dylukes> and full access to the internet.
16:19:13 <ddarius> dylukes: That would be retarded.
16:19:26 <dylukes> Well, not the whole internet,
16:19:34 <dylukes> as much as all of the relevant documentation...
16:19:43 <ddarius> dylukes: I meant the whole idea.
16:19:54 <dylukes> Portfiolio review would be better in any case.
16:20:00 <dylukes> ddarius: Hah, you should look at the exam as it is.
16:20:02 <dylukes> It's pathetic.
16:20:09 <ddarius> dylukes: I took it.
16:20:24 <dylukes> How much free time did you have :)?
16:20:42 <tomku> dylukes: I took it as well, back when it was C++... it was sufficient to show that I didn't need to be in first-year Java class, and that's all that the results should mean
16:20:44 <dylukes> I had 50 minutes extra on the multiple choice, 40 on the free response.
16:20:58 <dylukes> tomku: Yeah, except AP Computer Science now _is_ first year Java.
16:20:59 <dylukes> *sigh*
16:21:08 <dylukes> literally...
16:21:13 <tomku> dylukes: could you clarify what you mean?
16:21:20 <dylukes> I mean… it's literally an introduction to java.
16:21:23 <ddarius> dylukes: The AP CS exam is aimed at high schoolers and at best gets you out of -a- single undergraduate class.  There's no reason to expect freshmen in college to already be completely competent software developers.
16:21:27 <dylukes> That's the curriculum.
16:21:37 <tomku> dylukes: that's exactly what it's supposed to be, why do you think it should be something else?
16:21:47 <dylukes> tomku: True enough...
16:22:36 <primeq> anyone out there have a job that involves Haskell - even partially?
16:23:33 <edwardk> primeq: well, they are nice enough to let me work on my haskell libs at work =)
16:23:53 <primeq> ewardk - I guess that counts -
16:23:55 <Mathnerd314> @google haskell job
16:23:56 <lambdabot> http://www.haskell.org/haskellwiki/Jobs
16:23:56 <lambdabot> Title: Jobs - HaskellWiki
16:24:09 <primeq> yup - see what the google has to offer
16:24:15 <primeq> was looking for some personal insight
16:24:22 <primeq> mean "seen . . . "
16:25:16 <primeq> approach I am considering taking (once I have experted-up in Haskell) is to build something that is too good to pass up.
16:25:45 <primeq> have designed, led and built some game-changers in Java over the last 10 years, looking to do same in haskell
16:31:39 <MercedesBenz> hmm interesting ideas...
16:32:20 <MercedesBenz> well the real reason I am looking total another language than Java (Scala,Fantom,etc) is because I would like to have some special knowledge...
16:32:54 <primeq> i think there is big upside to learning Haskell just for mental acuity
16:33:04 <MercedesBenz> I have read the article that if the are 1 000 000 Java developers, it is hard to get hired, and the salaries can be dropped because they can switch one developer to another with same education.
16:33:08 <primeq> I don't think I would drop it if there were no job oppos
16:33:26 <MercedesBenz> That is what I mean: Meantal!
16:33:39 <primeq> some truh there, but *good* java develoeprs (any languatge really) are ***hard*** to find
16:33:41 <Luke> "No instance for (Show UTCTime)" looks like the 7.0.3 docs say Show UTCTime instance does exist. Any ideas?
16:34:02 <MercedesBenz> the Java app source codes are so much GUI pancakes, that I try to understand is that the same story with GTK and for example Haskell/Python.
16:34:33 <primeq> can u explain? "GUI pancakes" ?
16:34:40 <monochrom> Luke: lazy but sure way: import Data.Time
16:35:01 <MercedesBenz> of course hard. For exaxmple a standalone free app called "Sweet Home 3D" is written in Java. 32Mbs in Windows. Source code is 16Mbs.
16:35:09 <Luke> monochrom:  oh the instance isn't in the packages I've imported? thanks
16:35:44 <MercedesBenz> I downloaded and tried to read those literally 1000s of .java files mostly of Swing spaghetti code... and I didn't even imagine how one can write and read and understand this code.
16:35:46 <Luke> monochrom: found it in local time - thanks
16:36:03 <MercedesBenz> I thought maybe I look out new easier language, which maybe Haskell is not.
16:36:09 <monochrom> yeah
16:36:16 <primeq> MercedesBenz : it's very easy to write very bad code. Even easier to write very bad Swing code
16:36:29 <MercedesBenz> nah, that app was good code.
16:36:42 <MercedesBenz> good because not at my level even for reading.
16:36:43 <Luke> monochrom: jk - it's in the time package - thanks
16:37:10 <primeq> if it's hard to read - even for inexperienced then (IMO) it is badly written
16:37:27 <primeq> MercedesBenz - talkinga bout java that is
16:37:27 <MercedesBenz> nah, it is awesomelly written.
16:37:55 <blackdog> primeq: not sure that's true. you'd be condemning point-free style then - most haskell newbs find that very hard when they start
16:38:31 <monochrom> you probably find chinese hard to read, too
16:38:32 <primeq> blackdog - I was referring to java specifically. Haskell - I cannot really comment intelligently yet
16:39:07 <MercedesBenz> take a look : http://pastebin.com/snDkiK0V
16:39:19 <ddarius> monochrom: It's because Chinese is a bad language.
16:39:44 <MercedesBenz> it is one of 1000 files. this one is 32kbs and it doesn't take Swing in account. Swing folder is full of nasty files, but the app is really sophisticated, reminds 3d max.
16:40:07 <monochrom> "Spam Detection For Pastebin ID: snDkiK0V" "Your paste has triggered our automatic SPAM detection filter."
16:40:17 <monochrom> god, it is not my paste
16:40:42 <MercedesBenz> what?
16:40:45 <MercedesBenz> for me it works fine.
16:40:47 <primeq> MercedesBenz - yes, taht it reasoanbly well written code agreed there
16:41:10 <tomku> it's amazing how little 900 lines of Java really does
16:41:13 <monochrom> why should the website impose a capcha human test on the reader rather than the author?
16:41:35 <primeq> tomku - yes, Swing is quite verbose . . ..
16:41:51 <primeq> more verbose than plain java even
16:42:25 <MercedesBenz> yes, and the program has +1000 other files...
16:42:39 <MercedesBenz> if this one is 32kb. I now will pastebin you the biggest one I found was 250kb.
16:42:52 <MercedesBenz> that was one of Swing elements file. Second.
16:44:11 <MercedesBenz> Enjoy : http://pastebin.com/HbLSMmzy
16:44:48 <MercedesBenz> 216kb... PlanComponent.java from Swing folder... there are really more than 50 files but others are 150kb and most of them are about 4-25kb.
16:45:01 <jmcarthur> looks pretty typical java to me
16:45:06 <MercedesBenz> If I ever could understand this app I would get any job in the world in Java.
16:45:14 <MercedesBenz> yes but the amount of code!
16:45:15 <primeq> MercedesBenz : problem is that the Swing class is bundling in whole tracts of jhava that should be in helper classes rather than jamemd into the GUI code
16:45:32 <dylukes> anyone know what value errno is set to for EOF read?
16:45:49 <sipa> dylukes: none
16:45:49 <MercedesBenz> primeq, nah, there are folder for controller, for io, for etc...
16:45:56 <dylukes> wonderful >_>
16:45:59 <primeq> MercedesBenz : you might be stunned to see some of the dreck that is written by _some_ "professional" coders
16:46:04 <MercedesBenz> this guy made it brilliantly. and all folders full of everything.
16:46:19 <MercedesBenz> but why the heck they don't write it to one 16Mb file
16:46:33 <MercedesBenz> I hate looking from file to file from folder to folder, reminds me php.
16:46:52 <MercedesBenz> and those import * * * in every file hate it.
16:47:20 <primeq> a decent IDE will collapse all of that away  . . . .
16:48:16 <monochrom> dylukes: since "zero indicates end of file", rather than -1, you don't need an errno
16:48:26 <dylukes> It's not a usual situation :\
16:48:29 <dylukes> anyways
16:49:00 <MercedesBenz> hehe
16:49:08 <sipa> since all files have a finite size, EOF is pretty usual situation :)
16:49:22 <MercedesBenz> anyway
16:49:35 <MercedesBenz> seeing this app in action and seeing this app source code I am amazed.
16:49:43 <MercedesBenz> I can't imagine how Windows 7 code looks like....
16:50:26 <monochrom> you can go very philosophical on what constitutes "usual situation"
16:50:27 <MercedesBenz> decent games doesn't make so much as programs, because there is not much video and images in programs, allmost all is the code.
16:50:37 <MercedesBenz> sure
16:50:58 <MercedesBenz> anyway I am in doubt whenether I see those super apps.
16:51:04 <monochrom> my favourite is DRMacIver's http://www.drmaciver.com/2009/03/exceptions-for-control-flow-considered-perfectly-acceptable-thanks-very-much/
17:01:26 <MercedesBenz> monochrom thank you
17:01:37 <dylukes> https://gist.github.com/973701
17:01:55 <dylukes> If only the C preprocessor was a wee bit more powerful :\
17:02:22 <MercedesBenz> dylukes : what is that? is it Haskell?
17:02:23 <dylukes> sipa: 1) not dealing with a file, 2) it's not a… usual situation, its hard to explain w/e
17:02:30 <dylukes> MercedesBenz: No, it's C.
17:02:40 <dylukes> Me having fun with macros.
17:02:48 <MercedesBenz> I thought it was C.
17:02:53 <dylukes> Six functions that all look identical? Macro time!
17:03:08 <MercedesBenz> Foundation.h said me it should be C, but you scared me that Haskell could be like C.
17:03:23 <dylukes> Well, it's ObjC… but close enough.
17:03:25 <Draconx> dylukes, doesn't look like C.
17:03:50 <Draconx> ah, that explains it.
17:03:51 <dylukes> Imagine the horror of… ".c.php"
17:03:53 <dylukes> :)
17:04:46 <jrick> I've never seen @keywords in C
17:04:57 <dylukes> Those are ObjC… >_>
17:05:05 <monochrom> .c.php.hs.sml.j.java.js
17:05:14 <dylukes> monochrom: I don't even want to know what that does.
17:05:14 <MercedesBenz> Leksah on windows goes not smoothly.
17:05:19 <MercedesBenz> Java apps goes smoothly.
17:05:36 <dylukes> #define leksah(os) Leksak on ##os## does not smoothly
17:05:39 <dylukes> leksah(Windows)
17:05:42 <dylukes> leksah(OS X)
17:05:45 <dylukes> leksah(Everywhere)
17:05:48 <MercedesBenz> so what
17:05:54 <MercedesBenz> Eclipse doesn't look so retired.
17:05:59 <MercedesBenz> thought it is also everywhere.
17:06:47 <MercedesBenz> not a big problem, I heared Eclipse is making Haskell plugin at the moment.
17:08:40 <MercedesBenz> I wish I never installed Haskell.
17:09:02 <MercedesBenz> I mean Leksah Ide showed me Haskell app visuals on Windows... so retired...
17:09:33 <MercedesBenz> for a second language I better use Python. That one actually rocks for small coding.
17:09:38 <MercedesBenz> see you in Python
17:09:38 <MercedesBenz> ;)
17:09:39 <MercedesBenz> bye
17:11:54 <edwardk> wut
17:12:10 <applicative> see you in Python edwardk
17:12:20 <edwardk> =)
17:13:46 <monochrom> good riddance
17:14:11 <Saizan> leksah++ ?
17:16:35 <jmcarthur> go leksah!
17:16:55 <sshc> ^ This!
17:18:33 <sshc> Why are we supporting leksah?
17:19:12 <edwardk> never used it
17:19:34 <sshc> edwardk: What do you use?
17:19:45 <edwardk> vi
17:19:59 <jmcarthur> i gave it a shot once, but i like emacs too much
17:20:07 <ddarius> edwardk: vi or vim (or other)?
17:20:20 <jeffz> I tried leksah once too, didn't like the gtk look and feel.
17:20:23 <sshc> I use vim.  I haven't tried yi or leksah, but I plan to
17:20:30 <edwardk> vim, but i stick to a pretty strictly vi-ish subset thereof, mostly because of how long i've been using vi
17:20:43 <ddarius> edwardk: I bet you use unlimited undo.
17:20:51 <edwardk> no
17:21:02 <ddarius> You never press u twice?
17:21:18 <edwardk> well, i can't turn it off, but i don't reflexively rely on it
17:22:12 <ddarius> You're vi(m) usage is all crazy anyway, not that I really exploit the full power of vim either.
17:22:21 <edwardk> yeah
17:22:55 <edwardk> i'm starting to be more vimmy these days
17:22:56 <sohum> @pl \xs ys -> xs \\ filter (/= 0) ys
17:22:57 <lambdabot> (line 1, column 14):
17:22:57 <lambdabot> unexpected "\\"
17:22:57 <lambdabot> expecting variable, "(", operator or end of input
17:23:02 <sohum> @pl \xs ys -> xs + filter (/= 0) ys
17:23:03 <lambdabot> (. filter (0 /=)) . (+)
17:23:18 <ddarius> edwardk: Have you learned G yet?
17:23:25 <edwardk> G?
17:23:43 <ddarius> versus 10000h.
17:23:48 <edwardk> hahahaha
17:24:19 <edwardk> nownow, i use escape :100000000\n  — ;)
17:24:49 <djahandarie> I never got used to vi
17:25:03 <monochrom> wait, 10000h is approximately 1G, not G
17:25:16 <edwardk> yeah
17:25:16 <sshc> I use vim...not sure if it'd be considered moderately: I use tabs, windows, syntax hilighting, spelling/completion, and use caps-lock-space for escape (my caps lock is actually left-control)
17:25:19 <edwardk> there is that
17:25:23 <sshc> (and I *don't* use arrow keys)
17:25:42 <sohum> I know there's a way to better represent (. f) . g
17:25:52 <ddarius> monochrom: I use dvorak so that mapping is no longer the same for me.
17:25:52 <edwardk> well 100000k is anyways
17:25:57 <monochrom> actually 10000h is not approximately 1G either. rather 0
17:25:59 <djahandarie> sohum, there isn't a standard combinator for it
17:26:06 <monochrom> oh no wonder, nevermind
17:26:12 <djahandarie> sohum, there is one for (f .) . g though, which is .:
17:26:19 <sshc> ddarius: What isn't?
17:26:25 <sshc> (I use dvorak too)
17:26:25 <sohum> djahandarie: neat!
17:26:35 <sshc> By the way, how is "dvorak" pronounced?
17:26:45 <ddarius> hjkl is dhtn for me.
17:27:01 <monochrom> http://en.wikipedia.org/wiki/Anton%ADn_Dvo%99%A1k ! :)
17:27:01 <jrick> hjkl -> neio for me (colemak)
17:27:18 <jrick> but that's shifted one key to the right, so you don't have to move your hand
17:27:31 <monochrom> nevermind, some characters are lost
17:27:52 <sshc> ddarius: I use snth for movement keys
17:27:58 <sshc> ddarius: Why did you shift the keys one to the left?
17:28:02 <djahandarie> sohum, one possibility is to use the notation from Control.Category.   (<<>>) = (<<<).(>>>)  which is (. f) . g
17:28:16 <djahandarie> sohum, and (<<<<) = (<<<).(<<<) which is (f .) . g
17:28:17 <ddarius> sshc: Because I learned vim with the QWERTY layout.
17:28:22 <djahandarie> But all these damn arrows are annoying
17:28:27 <djahandarie> Not sure of a nicer way though
17:28:30 <sohum> djahandarie: so many arrrrrows...
17:28:34 <sohum> djahandarie: thank you!
17:28:51 <djahandarie> :)
17:29:03 <sshc> (I did too). Ah, so do I.  I actually do use dhtn too
17:29:36 * ddarius doesn't use tabs, rarerly uses windows, doesn't use completions, and hasn't remapped escape.
17:29:58 <ddarius> I did use Ctrl-C for a while, but vim on Windows or something didn't like it.
17:30:45 <sshc> I've mapped caps lock to left control globally (both inside and outside X), and, in vim, mapped C-space to escape.
17:33:02 <edwardk> i've avoided remapping capslock, etc. because i live in terror of emacs pinky and the various wrist disorders that plague the ctrl-alt-meta-shift-x crowd ;)
17:33:41 <jrick> capslock is backspace for me :)
17:33:56 <edwardk> interesting mapping
17:34:02 <sshc> edwardk: Hah.
17:34:04 <jrick> it standard colemak
17:34:16 <mechnik> first visit, hi
17:34:21 <sshc> edwardk: But, ... not remapping would do the opposite?
17:34:54 <sshc> edwardk: remapping capslock *helps* avoid that
17:35:32 * ddarius doesn't use his pinky to press escape.
17:36:10 <mechnik> quit
17:36:18 <mechnik> exit
17:36:28 <mechnik> :quit
17:36:44 <monochrom> /quit
17:36:52 <edwardk> i don't really use my pinky for control most of the time its my thumb, because my left hand has drifted up on the keyboard towards the escape key ;)
17:39:16 <ion> You are afraid of wrist disorders *and* type like that? :-D
17:40:00 <edwardk> well, i haven't incurred any yet ;)
17:40:43 <edwardk> gambling on lots of mobility to reduce my chances of repetitive strain ;)
17:40:59 <mechnik> thank you
17:41:42 <aristid> use shorter identifiers to minimise typing
17:42:23 <hpc> aha! i think i might be able to demonstrate that using java is a health risk due to repetitive typing
17:42:40 <monochrom> hehe
17:42:49 <ion> Use British English because s is on the home row and z is not.
17:43:06 <aavogt> u isn't on the home row
17:43:31 <ion> Good point. One should use a hybrid then.
17:43:34 <mechnik> is home row like the Home Office?
17:43:36 <monochrom> use british-american english. colorise.
17:44:11 <monochrom> home row is like the home town (age of empires 3)
17:44:37 <djahandarie> That makes me feel like booting up Age of Kings
17:44:40 <ddarius> aavogt: It is if you type Dvorak.
17:44:43 <djahandarie> I used to be pretty good with that game
17:44:49 <monochrom> \∩/
17:44:50 <mechnik> aka the town of homies
17:45:19 <mechnik> i used dvorak for a spell in the ages past
17:45:50 <aavogt> what about awkward arrows like => and ->  ?
17:46:17 <monochrom> map z to ->, Z to =>
17:47:33 <monochrom> map capslock to forall if you plan to use rank-n types a lot
17:48:05 <djahandarie> Are we designing a Haskell programming keyboard here?
17:48:31 <monochrom> it may become an agda keyboard, too
17:49:16 <monochrom> at the end we will call it the haskell-agda-coq-isabelle keyboard
17:49:59 <koninkje> Hacik?
17:50:20 <monochrom> \∩/
17:51:11 <edwardk> an agda keyboard layout would wind up looking like one of those crazy japanese keyboards with all the unicode symbols you need to get through even 10 lines of agda.
17:52:07 <koninkje> And a space bar that's only three keys wide?
17:52:31 <edwardk> =)
17:53:04 <koninkje> Need to leave room for those extra modifier keys
17:53:11 <monochrom> my laptop space bar is 4 keys wide. I think I won't mind 3 keys wide either
17:53:37 <djahandarie> Mine is 6
17:53:46 * koninkje actually really likes Japanese keyboard layout
17:54:27 <djahandarie> Why? The kana layout is pretty retarded
17:54:41 <lpsmith> is there a nice way to -ddump-minimal-imports from a cabal build?   I tried cabal build --ghc-options=-ddump-minimal-imports  and I can't find the imports anywhere
17:54:42 <monochrom> once upon a time I also used this: http://en.wikipedia.org/wiki/Sharp_PC-1500  2 keys wide
17:54:46 <chreekat> Could someone explain the original rationale for calling lifting "lifting"? I think if I understand why that phrase was coined, I might have a better chance remembering what it does
17:55:19 <monochrom> -ddump-anything seems to go to stdout or stderr
17:55:45 <koninkje> djahandarie: well I use romaji for input, but I mean the layout of the various peripheral keys
17:55:50 <lpsmith> monochrom,  I thought it went to an .imports file or whatever.
17:55:52 <lpsmith> hold on
17:56:08 <djahandarie> Ah
17:56:16 <ezyang> Try -ddump-to-file?
17:56:31 <ezyang> The dumping situation is a bit messy and inhomegenous
17:56:33 * ezyang apolgizes 
17:56:58 <ezyang> edwardk: Are any Boston Haskell meetings happening over the summer?
17:57:06 <ezyang> I'm trying to decide when I'm going to come up and visit from NY.
17:57:41 <koninkje> chreekat: whose use of the term? It means differently depending on the context (though they're all analogies of one another)
17:57:46 <djahandarie> 無変換, 変換, 半角/全角, etc are somewhat useless for non-Japanaese things though
17:58:14 <monochrom> strange! -ddump-minimal-imports doesn't seem to output anything
17:58:20 <djahandarie> Man, can't even spell 'Japanese' yet I can type all those kanji correctly
17:58:33 <dolio> chreekat: I have no idea where the name came from. But it might simply be that people were writing similar diagrams with one above the other. And some operation relates something in the lower diagram to one in the upper diagram.
17:58:46 <dolio> That's certainly the case for at least one example I can think of.
17:58:51 <monochrom> (could you suggest me how to write a *.hs file that should cause -ddump-minimal-imports to output something?)
17:59:30 <lpsmith> monochrom:   import List;   fun = zipWith5
17:59:49 <edwardk> ezyang: sure. next one will probably be in ~3 weeks or so. i need to send out an announcement once i know we have the space, etc.
17:59:58 <ezyang> Oh that's too early :-(
18:00:07 <ezyang> But I'll keep my eyes peeled.
18:00:10 <edwardk> ezyang: well, its hardly going to be the last for the whole summer =P
18:00:19 <monochrom> still no output, ghc 7.0.3
18:00:25 <ezyang> :-)
18:00:33 <dolio> Don't worry. We determined he's got enough material to fill at least two meetings solo.
18:00:39 <edwardk> hahaha
18:00:42 <chreekat> koninkje: I suppose that might be part of my problem: I see references to 'lifted variables' and 'lifting a function', etc. Lifting seems to be big part of monads
18:01:04 <edwardk> automatic differentiation and the breakout of category-extras if nothing else
18:01:04 <chreekat> dolio: i see :)
18:01:05 <lpsmith> monochrom: add a "module Foobar where
18:01:08 <monochrom> oh sorry, it goes to "Main.import", or "whatevermodule.import"
18:01:12 <lpsmith> right
18:01:17 <edwardk> and there was at least one other talk i've forgotten
18:01:25 <koninkje> chreekat: In general, "lifting" tends to mean taking something "simple" and embedding it a more "complex" structure (in the obvious way)
18:01:30 <dolio> One is on the breakup of category-extras.
18:01:40 <dolio> Another is on monoidal parsing, maybe?
18:01:44 <edwardk> the only reason it isn't sooner is i have another talk at boston scala
18:01:48 <koninkje> chreekat: So, for example, return lifts a plain value into a monadic value
18:01:53 <monochrom> ok if you use cabal, then it probably lands in some subdirectory under dist
18:02:05 <edwardk> monoidal parsing is another topic i suppose
18:02:12 <koninkje> chreekat: And the lift function for monad transformers lifts an (M A) into a (T M A)
18:02:54 <hpc> edwardk: every time you talk in here, instead of learning something new, i discover five new things that are totally out of my depth
18:02:59 <lpsmith> well, n/m,  I did enough manual compiling to get my minimal imports
18:03:19 <lpsmith> still, it would be nice to have a way to do that from cabal
18:03:34 <edwardk> =/
18:03:35 <monochrom> I think it works, it just hides the file somewhere
18:03:40 <chreekat> koninkje: ok, that helps. I think when I first saw the term, the intuitive meaning (for me) was the opposite of what it really is. I envisioned "lifting" a simpler value out of a more complex one, like taking a value out of a box
18:04:39 <koninkje> chreekat: Well, lifting can also mean taking an unpointed type (i.e., a type with no _|_) and embedding it in a pointed type (i.e., by adding _|_)
18:05:15 <koninkje> So, lifting is boxing in that case
18:05:37 <chreekat> Right, that makes sense now. My intuitive understanding was backwards
18:06:21 <monochrom> many different things are called "lifting"
18:06:23 <chreekat> I think the synonym for me to keep in mind is "elevate"
18:06:46 <monochrom> as another example, map :: (a->b) -> ([a]->[b])  some people call that lifting, too
18:07:12 <koninkje> Now that's just wacky (though it follows the general theme)
18:07:48 <koninkje> no, wait, I think I call it that too sometimes..
18:08:12 <monochrom> you have certainly written "liftM", "liftIO" etc
18:09:32 <chreekat> Well I'm outside a cafe that is officially closed; should probably pack up and head home
18:09:35 <chreekat> thanks for the insights
18:10:34 <Mathnerd314> @type liftIO
18:10:35 <lambdabot>     Ambiguous occurrence `liftIO'
18:10:35 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
18:10:35 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
18:10:47 <diabolix> just learning, sorry if this question seems dense, why does one use 'map' for lists but 'fmap' for everything else? there does not seem to be an obvious reason why two functions are required?
18:11:01 <monochrom> if you have a partial order "⊑" over a set S, and then a set D, then you can define a partial order "≼" over D->S by "f≼g iff for all x: f x ⊑ g x". some people also call it lifting ("pointwise lifting")
18:11:09 <koninkje> fmap @[a] == map
18:11:40 <koninkje> The only reason to use map directly is to make sure it's monomorphic (which can help catch typos)
18:12:59 <diabolix> so is it historical then? because I would think there are better ways to guarantee something is monomorphic?
18:13:49 <koninkje> It's mostly historical (it's specified by H98, H2010,... reports). Some folks have advocated unifying them, but it's never gained much momentum
18:14:17 <diabolix> ok, thanks for the explanation.
18:14:24 <ddarius> koninkje: map was originally fmap
18:14:35 <koninkje> hmm?
18:15:01 <dolio> In Haskell 1.4, fmap was named map.
18:15:14 <koninkje> ah, yes.
18:15:30 <dolio> It was changed in the great monomorphizm of 1998.
18:15:48 <dolio> Monomorphysm?
18:16:26 <ezyang> Monomorschism
18:18:42 <dolio> preflex: seen Cale
18:18:43 <preflex>  Cale was last seen on #haskell 2 hours, 44 minutes and 23 seconds ago, saying: yes
18:19:08 <mm_freak> too much generalization also means more errors…  if you use tyes as specifications, then map is better than fmap, if you know it's a list
18:19:16 <mm_freak> types
18:19:36 <diabolix> is it correct to think of applicative functors as something like c++ function objects? it seems like a way to make a type behave like a function.
18:19:45 <dolio> No.
18:20:30 <koninkje> Applicative functors just means you can take F(a->b) and interpret it as Fa->Fb, with all the properties that'd make sense
18:20:33 <dolio> Functions are first-class in Haskell. You don't need to play tricks like in C++.
18:21:11 <dolio> They're also unrelated to the "applicative functors" in ML and its descendants.
18:21:33 <diabolix> so, its a way of taking a function, and wrapping parameters and return values as functors.
18:22:04 <diabolix> I think the STL damaged my brain, lol.
18:22:29 <koninkje> no, it's taking a "structure" of functions and turning it into a function on structures
18:22:48 <koninkje> STL damages everyone's brains
18:23:24 <dolio> I read through it and seem to be fine.
18:23:31 <dolio> At least, part of it.
18:23:38 <mm_freak> diabolix: i found it easy to think of applicative functors as generalizations of the S and K combinators
18:23:43 <monochrom> it did not damage my mind
18:23:54 <koninkje> monochrom: lucky :)
18:24:09 <mm_freak> <*> generalizes S, pure generalizes K
18:24:13 <diabolix> but, did you learn it before or after functional programming?
18:24:26 <monochrom> the real cause of damage is your own wanton associations, i.e., "x seems to be like y"
18:24:47 <monochrom> I never do "is x 'like' y?", so I am not damaged
18:24:52 <koninkje> So STL is like NaN?
18:25:07 <dolio> They're both acronyms.
18:25:36 <mm_freak> > equivalent acronyms
18:25:37 <lambdabot>   Not in scope: `equivalent'Not in scope: `acronyms'
18:27:33 <koninkje> mm_freak: I tend to think of them that way too. The only downside is that it fails to explain how monads are more powerful than applicative functors (since (<*>) and (=<<) are essentially the same for (a->_) )
18:31:30 <ddarius> koninkje: join generalizes W
18:31:52 <ddarius> (is it W?)
18:31:54 * ddarius checks.
18:32:04 <ion> Is W like STL?
18:32:12 <mm_freak> well, the reader monad has no real effects
18:32:33 <mm_freak> but you don't need to compare to monads to understand applicatives
18:32:46 <mm_freak> in fact, it's probably better to understand applicatives independently
18:32:55 <ddarius> Yes W.
18:33:03 <koninkje> Sure you do, if you're trying to understand how applicatives are different from monads
18:33:25 <koninkje> Which is important for understanding what either one of them does
18:33:38 <mm_freak> they aren't different…  the real question is:  what do applicative functors give you, what general functors don't
18:34:18 <koninkje> ddarius: The problem is that SK is complete, so adding W doesn't add any power; whereas adding join clearly does add power
18:34:51 <ddarius> koninkje: Indeed.  And the trick is to look at the definition of W in terms of SK.  At some point you need to actually exploit that it is a function.
18:34:59 <diabolix> SK?
18:35:21 <diabolix> oh, nevermind, I remember the context now.
18:35:23 <koninkje> SKI calculus
18:36:47 <mm_freak> you cannot understand functors/monads by looking at one particular instance, anyway
18:37:28 <koninkje> mm_freak: They are quite different. Applicatives do not have dynamic structure (in general)
18:37:42 <koninkje> Just consider the miffy vs iffy example in the original paper
18:38:51 <mm_freak> koninkje: every monad is an applicative functor…  you wouldn't say that monoids are different from groups, would you?
18:39:40 <koninkje> Yes, I would. Not every monoid has group structure. In fact, I often deal with non-group monoids
18:40:33 <koninkje> Every regular language can be recognized by a Turing machine; are Turing machines different from DFAs?
18:41:10 <mm_freak> i don't know
18:41:10 <Axman6> can't they accept things that aren't regular too?
18:41:20 <koninkje> exactamente :)
18:41:52 <Axman6> i think they do differ, they're more powerful, but i can't remember exactly why
18:42:20 <Axman6> the fact that you've basically got two stacks makes it more powerful i think
18:42:20 <mm_freak> my point is:  if one concept is a special case of another, then i wouldn't call them different…  i would call them specialized or generalized
18:43:46 <koninkje> Axman6: well, Turing machines can have (effectively) an infinite number of states, since thwhat's on the tape counts as part of the state; whereas DFA have finitely many states (by definition)
18:44:15 <Axman6> oh right, i was thinking about PDA's for some reason
18:44:18 <mm_freak> put differently:  the comparison itself doesn't make much sense to me…  you don't compare "fruit" and "banana"
18:44:37 <koninkje> Yeah, PDA's are more powerful too, for similar reasons
18:45:26 <diabolix> I feel like LYAHFGG brushes over some things too quickly. It is sometimes hard to understand why something is useful by a simple description of its behavior and some ghci output confirming its behavior.
18:45:31 <ddarius> mm_freak: It would be like comparing "plants" and "fruits."
18:46:07 <koninkje> (or "fruit bearing plants")
18:46:40 <iongprs> Bat bearing plants
18:47:01 <Axman6> diabolix: talk to BONUS
18:49:40 <diabolix> its been great so far, but I think I'd like some supplementary  material when it comes to monads, applicative functors. I think I understand what they do, I'm struggling with understanding what problems they solve that made them important enough to be baked into the standard modules.
18:49:54 <diabolix> any recommendations?
18:50:46 <koninkje> Well, monads give you do-notation (the overloadable semicolon). Applicative functors came later, so they're not really baked in
18:52:40 <koninkje> diabolix: I think the original paper introducing applicative functors does a good job of motivating why they're helpful:
18:52:43 <koninkje> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
18:54:01 <koninkje> Especially when you think about their bracket notation (instead of (<$>) and (<*>)), which looks great on paper but tends to get clunky in practice
18:55:15 <jmcarthur> i tend to use liftA* the most
18:56:43 <koninkje> diabolix: So monads give you the idea of overloading the sequencing of choices, whereas applicatives give you the idea of overloading what function application means (or rather, what can be thought of as a "function")
18:56:43 <diabolix> are semicolons implicit when you have newlines?
18:57:32 <koninkje> In Haskell semicolons are just there for layout purposes; I was meaning more the idea of semicolons that you find in imperative languages
18:58:04 <koninkje> s/sequencing of choices/sequencing of actions/
18:59:20 <koninkje> diabolix: but yes, semicolons are implicit and inserted when there's a newline (though not everywhere there's a newline)
19:00:11 <koninkje> For example, we usually use newlines and indentation instead of the curly braces and semicolons in: do { a <- foo ; b <- bar ; ... }
19:01:13 <koninkje> Similarly, we tend to define functions on multiple lines instead of saying: foo True = 1 ; foo False = 2
19:02:18 <taktoa> as some of you guys might know
19:02:25 <taktoa> I'm working on a genetic algorithm
19:02:29 <taktoa> in Haskell
19:03:02 <taktoa> anyways, I had the algorithm finished, but, unfortunately, my source code file was deleted
19:03:25 <diabolix> koninkje: thanks.
19:03:26 <taktoa> I've pieced the file back together through segments posted on hpaste and my own memory
19:03:38 <taktoa> but I'm running into a runtime error
19:03:43 <taktoa> here's the paste
19:03:45 <taktoa> http://hpaste.org/46717
19:04:07 <diabolix> I'll probably be back as I try to wrap my feeble mind around this language.
19:04:09 <taktoa> the error is "Main: Prelude.tail: empty list"
19:05:08 <taktoa> if anyone has suggestions, remarks, etc., they would be greatly appreciated, since I have a deadline for this project that is rapidly approaching
19:05:31 <sheikra> edwardk: I read the papers. Indeed that's a fundamental problem
19:06:29 <koninkje> taktoa: the error is in comp (which calls tail)
19:06:31 <sheikra> edwardk: Maybe I can say that Warth et al's packrat parsing changed LL(k) parsing into RR(k) ;-)
19:06:35 <taktoa> I noticed that much
19:06:49 <koninkje> taktoa: there's no guarantee that b is non-null
19:07:02 <taktoa> I see
19:07:10 <taktoa> how could I correct that?
19:07:37 <koninkje> oh wait, I might be thinking of a different function than splitAt (though evidently that's still the problem)
19:08:01 <koninkje> Try replacing the secong guard by (i >= length x)
19:08:10 <koninkje> s/secong/second/
19:08:35 <taktoa> yeah
19:08:37 <taktoa> I did that
19:08:48 <taktoa> but now it just throws the error listed in the second guard
19:09:00 <taktoa> so it seems that my problem is in mutation
19:09:08 <taktoa> or mutation'
19:09:27 <koninkje> Well you're not actually doing any mutation...
19:09:42 <taktoa> but I tested mutation' and found that the error originates from line 55
19:09:53 <taktoa> what do you mean?
19:09:54 <koninkje> In general, you shouldn't treat lists like they were arrays, because that'll kill your performance
19:10:17 <taktoa> well, yes, but mutation is not run often
19:10:26 * koninkje though you meant destructive updates in the language; as opposed to genetic mutation
19:10:31 <taktoa> only 1% of the times
19:10:35 <taktoa> I see
19:10:57 <koninkje> Try inlining comp and decomp into the replace function.
19:11:26 <koninkje> You'll need to have a special case for when the point being replaced is the final index
19:12:00 <koninkje> Right now, the way comp is defined, you can't replace the final index.
19:12:00 <taktoa> hrm
19:12:33 <taktoa> well, I changed loc2 so it can't exceed the length of the chromosome
19:13:07 <taktoa> (I changed line 48 to "loc2' <- randomInt (0, fromIntegral (length chrom) - 1)")
19:13:20 <taktoa> and now
19:13:22 <koninkje> Or, add a fourth guard to comp so that | i<0 = error | i>length = error | i==length = special case |otherwise = splitAt...
19:13:38 <taktoa> it gives me "Main: Index greater than list length"
19:13:46 <taktoa> which makes absolutely no sense
19:14:13 <taktoa> oop
19:14:16 <taktoa> *oops
19:14:36 <taktoa> just realized I forgot to change the input to replace on 55 to loc2 rather than loc1
19:15:09 <taktoa> hrm, now it consistently gives "Index less than zero"
19:15:16 <taktoa> which also makes little sense
19:18:34 <koninkje> Try something like: replace = go [] where go ys 0 x (_:xs) = reverse ys ++ x : xs ; go ys n x (y:xs) = go (y:ys) (n-1) x xs ; go _ _ _ [] = undefined
19:21:38 <koninkje> More specifically: replace n x | n < 0 = error "Index less than zero!" | otherwise = go n [] where go 0 ys (_:xs) = reverse ys ++ x : xs ; go n ys (y:xs) = (go $! n-1) (y:ys) xs ; go _ _ [] = error "Index greater than list length!"
19:21:47 <taktoa> hrm
19:21:59 <taktoa> one sec, implementing
19:23:16 <taktoa> now
19:23:22 <taktoa> it variably outputs
19:23:28 <taktoa> "Index less than zero"
19:23:30 <taktoa> or
19:23:37 <taktoa> "Index greater than list length"
19:24:04 <MatrixFrog1> so i have a question :-/ i'm reading the RWH chapter on Monads, and they keep using the term "type constructor"
19:24:17 <MatrixFrog1> so as in like, data Maybe a = Just a | Nothing
19:24:28 <MatrixFrog1> Just and Nothing are the value constructors, and Maybe is the type constructor
19:24:48 <MatrixFrog1> my question is about the word "constructor"
19:24:50 <taktoa> yes...?
19:24:58 <MatrixFrog1> i understand using that word for the value constructors
19:25:07 * taktoa is also reading RWH, by the way
19:25:08 <MatrixFrog1> but you can't "construct" anything with "Maybe"
19:25:15 <taktoa> sure you can!
19:25:25 <taktoa> Maybe a
19:25:26 <MatrixFrog1> all you can do is say, like, Just 3 :: Maybe Int
19:25:39 <taktoa> Maybe Int
19:25:46 <MatrixFrog1> you need either the just or the nothing to construct the instance
19:25:48 <taktoa> you are constructing a type from Int
19:25:52 <MatrixFrog1> oh ok
19:26:12 <MatrixFrog1> so Int is not a type constructor then
19:26:18 <taktoa> no
19:26:20 <MatrixFrog1> because it's not generic, like "Int a"
19:26:30 <taktoa> it is a type, whereas Maybe is a class
19:26:49 <taktoa> well, you could have a type that takes a type variable
19:26:59 <taktoa> but in your case it's a class
19:27:00 <MatrixFrog1> it seemed like they were using "type constructor" as a synonym for "type". i think this makes more sense now, thank you
19:27:09 <taktoa> you're welcome
19:27:21 <MatrixFrog1> but it's not a class in the same sense as a typeclass like Eq or Ord
19:27:31 <taktoa> it isn't?
19:27:48 <taktoa> oh, I see
19:27:52 <MatrixFrog1> you don't say that something is an instance of the Maybe typeclass do you?
19:27:54 <taktoa> it's a datatype
19:28:05 <taktoa> a polymorphic datatype
19:28:22 <taktoa> data Maybe a = Just a | Nothing
19:28:47 <taktoa> that way you don't have to make numerous "Maybe<type>" datatypes
19:29:10 <MatrixFrog1> you "construct" all those types from the "type constructor" Maybe
19:29:10 <MatrixFrog1> cool
19:29:22 <taktoa> yup
19:30:28 <Philippa_> Int /is/ a type constructor, the same way Nothing is a data constructor, FWIW. But Int is also of kind * - it's a type, proper
19:31:35 <stepcut> Philippa_: I was about to say the same thing.. Int is a type constructor that takes zero arguments
19:31:42 <stepcut> whereas Maybe is a type constructor that takes one..
19:31:51 <djahandarie> We looked this up once in the report but I don't remember what it said
19:31:57 <djahandarie> Do you remember monochrom?
19:32:18 <mm_freak> by the same view Nothing is a function, which takes zero arguments
19:33:01 <stepcut> http://www.haskell.org/onlinereport/decls.html#sect4.1.1
19:33:19 <synod> I have a simple lambda expression languages in the final coalgebra/typed tagless style. I am trying to define a state monad for name-expression bindings for this language so I defined a binding type and put a Map in the State monad. Clearly this doesn't work as the codomain of the map needs a concrete type. What are my options? Do I have to somehow express the type of terms with a datatype?
19:33:20 <stepcut> djahandarie: "The symbol * represents the kind of all nullary type constructors."
19:33:52 <stepcut> also, Maybe is not a class..
19:33:59 <taktoa> weird - hpc considers 0/0 to be 1
19:34:00 <djahandarie> Cool, thanks.
19:34:03 <taktoa> not undefined
19:34:12 <dolio> It's nullity.
19:34:26 <mm_freak> Maybe a is a class of types
19:34:52 <mm_freak> it's just not a haskell type class
19:34:54 * hackagebot repa-devil 0.1 - Support for image reading and writing of Repa arrays  http://hackage.haskell.org/package/repa-devil-0.1 (DonaldStewart)
19:35:20 <Philippa_> mm_freak: no, Nothing is a /data constructor/ of zero arguments. You can have that without having the concept of 'nullary function'
19:35:29 <koninkje> mm_freak: it's only a "class" in the sense that philosophers use the term; It's not a class in the sense of either OOP nor typeclasses
19:35:33 <Philippa_> (just nullary data, which is less oxymoronic)
19:36:27 <taktoa> the terminology is a bit messed up: nullary, monadic, dyadic, etc.
19:36:28 <ddarius> koninkje: I'm pretty sure the usage of each was inspired by the set theoretic/philosophical notion.
19:36:33 <taktoa> nullary doesn't fit
19:36:41 <ddarius> taktoa: It's nullary, unary, binary.
19:36:47 <taktoa> well, yess
19:36:49 <taktoa> *yes
19:36:59 <taktoa> but no one says "binary function"
19:37:05 <mm_freak> taktoa: you got my point
19:37:06 <ddarius> Sure they due.
19:37:08 <taktoa> they say "dyadic function"
19:37:10 <ddarius> s/due/do/
19:37:15 <koninkje> ddarius: inspired, sure, but unless someone's coming from the world of philosophy, calling Maybe a class is just begging for confusion
19:37:20 <danharaj_> Say binary function all the time in math.
19:37:21 <ddarius> No one here says dyadic function unless they're talking about J.
19:37:26 <ddarius> In which case they say dyad.
19:37:47 <taktoa> is there an equivalent to nullary in the set of "monadic, dyadic, triadic, etc."?
19:37:52 <taktoa> just curious
19:38:00 <mm_freak> Maybe is not a class, but 'Maybe a' is a class
19:38:04 <ddarius> koninkje: I agree on that, but I actually think thinking of type classes as sets of type constructors is a better way of thinking about them.
19:38:09 <mm_freak> Maybe Int is also not a class
19:38:23 <copumpkin> mm_freak: a "class"?
19:38:47 <mm_freak> copumpkin: a class of types
19:38:50 <koninkje> copumpkin: the philosophical term for referring to any collection without worrying about set theoretic paradoxes
19:38:59 <copumpkin> oh, in that sense
19:39:27 <taktoa> http://en.wiktionary.org/wiki/adicity
19:39:44 <taktoa> nullary is Latin, monadic is Greek
19:39:45 <mm_freak> and it's quite colloquial to refer to 'State s' as a class of state monads in haskell
19:39:54 <taktoa> conundrum resolved
19:39:58 <djahandarie> I personally like talking about typeclasses with an extra kind.   Monad :: (* -> *) -> Fact   etc
19:39:59 <mm_freak> i don't see why the same should be invalid for 'Maybe a'
19:40:14 <Eduard_Munteanu> Um? 'State s' is *the* state monad.
19:40:24 <mm_freak> Eduard_Munteanu: no
19:40:30 <copumpkin> ddarius: I bribed a police officer!
19:40:31 <mm_freak> there is no "the" state monad
19:40:35 <djahandarie> I think it's a seriously terrible idea to overload the word 'class' anymore than it already is
19:40:38 <ddarius> copumpkin: Congratulations!
19:40:42 <copumpkin> thanks :)
19:40:47 <koninkje> djahandarie: Me too.
19:40:57 <taktoa> apparently, they say "niladic" or "medadic"
19:41:08 <Eduard_Munteanu> Hectadic :P
19:41:08 <djahandarie> copumpkin, did you mug someone?
19:41:11 <taktoa> for the adicity equivalent of nullary
19:41:21 <copumpkin> djahandarie: nope
19:41:35 <Eduard_Munteanu> mm_freak: oh if you mean it's parametrized on 's', sure
19:42:03 <ddarius> Ironically, our conversation about bribing people came up immediately before our conversation about djahandarie.
19:42:52 <Eduard_Munteanu> What about djahandarie? :P
19:43:19 <jmcarthur> copumpkin: really?
19:43:26 <copumpkin> yes, it was awesome
19:43:29 <jmcarthur> wow
19:43:40 <djahandarie> What about geheimdienst?
19:43:48 <copumpkin> djahandarie: I am disappoint
19:43:52 <Eduard_Munteanu> You should totally give up Haskell and all this and go do that for the next 50 years :P
19:44:17 <Eduard_Munteanu> djahandarie: there goes proof!
19:44:33 <djahandarie> I hate to say it but I have entirely lost track of what the hell is going on in this conversation.
19:44:50 <copumpkin> dude.
19:49:26 <Eduard_Munteanu> Dunno, this conversation made everyone fall asleep.
19:49:32 * Eduard_Munteanu should zzZZZ too
20:04:41 <EvilMachine> @pl (\l -> l*2:[])
20:04:41 <lambdabot> return . (2 *)
20:06:34 <EvilMachine> aaah, return x == [x] in the list monad
20:07:13 <EvilMachine> pointfree style, lobster and free jazz clearly have something in common.;)
20:17:21 <applicative> yipe, repa-devil
20:24:24 <co_dh> greeting, I have a haskell question about asynchronous call and time.  suppose I have a asynchronous socket,  a callback handle_write will be called whenever the socket is available to write,
20:24:39 <co_dh> and I need to write a message to the socket every 10 seconds,
20:24:45 <co_dh> how can I do this in haskell?
20:25:27 <co_dh> to summarize :  event (socket_ready_for_write ) and event ( 10 seconds passed) will trigger a send .
20:26:07 <co_dh> bed time?
20:44:57 <dons> co_dh: you can certainly do that. call back into haskell, update an MVar, and continue.
20:47:12 <applicative> oh, dons, the example for repa-devil should be main = runIL $ do ..., not main = runIL $ ...
20:48:28 <co_dh> so maybe I should ask a different way : how haskell handle events ?
20:48:41 <co_dh> FRP coming to my mind .
20:48:57 <co_dh> other than FRP , what else are available?
20:51:27 <jmcarthur> co_dh: most haskell programs dealing with sockets just use threads rather than explicit async io
20:51:32 <co_dh> http://haskell.org/haskellwiki/Simple_Servers seemed to be a good answer.
20:52:27 <jmcarthur> co_dh: ghc threads are very lightweight and block using efficient async syscalls under the hood
20:52:53 <jmcarthur> co_dh: that's a fairly out of date wiki page i think
20:53:23 <jmcarthur> co_dh: ghc now uses epoll even when you just use forkio, i'm pretty sure
20:53:25 <jmcarthur> at least on linux
20:55:55 <co_dh> cool.
20:56:59 <co_dh> I have to use explicit async io, because I need to send 2 messages on one socket , while I'm waiting the response of the first message.
20:57:21 <co_dh> jmcarthur: thanks !
20:57:59 <sheikra> I have a question about sum types in general... why do we put constructors over constructors in Haskell and ML instead using some kind of "union types" that doesn't add any layers on top?
20:58:00 <jmcarthur> co_dh: that doesn't sound like a case where explicit async is necessary. threads are perfectly fine for that
20:58:25 <foxy-om> I just downloaded cabal-install from the website (0.8.2) and it fails to install because of dependency clashes (base/filepath).  Is this a standard gripe?  Solution?
20:58:25 <jmcarthur> sheikra: so you can distinguish them
20:58:40 <sheikra> jmcarthur: but they already have constructors..
20:58:52 <jmcarthur> sheikra: ?
20:59:28 <copumpkin> sheikra: if I have a type with a constructor Foo, what is the type of Foo?
20:59:30 <applicative> sheikra, You can do e.g. data A = F (Int -> Int) | G Int
21:00:09 <sheikra> jmcarthur: I mean ... data A = B | C, data A2 = B2 | C2, then ... I want to put B and C2 into the same list ... I would have to declare a new type data A3 = E3 B | E3 C2 ...
21:00:14 <applicative> Every Foo is a Foo, copumpkin
21:00:22 <copumpkin> applicative: not if we have unions
21:00:33 <co_dh> jmcarthur: I'm not sure what would happen if I have 2 thread write to the SAME socket.
21:01:04 <applicative> so what's the answer, sheikra isnt saying
21:01:17 <copumpkin> it doesn't have a single type
21:01:25 <jmcarthur> sheikra: what if you wanted to do this?   data A = E1 B | E2 B | E3 C
21:01:34 <sheikra> copumpkin: the type is Foo
21:02:01 <copumpkin> sheikra: why isn't it the union of Bar and Foo?
21:02:05 <copumpkin> or Int and Foo
21:02:17 <sheikra> jmcarthur: that's a different issue. That's when you want new type constructors
21:02:17 <copumpkin> or Maybe (Int -> Bool -> Foo) and Foo
21:02:25 <jmcarthur> why is it different?
21:02:40 <jmcarthur> what do type constructors have to do with it?
21:02:40 <djahandarie> Does anyone know if Okasaki's formulation of priority queues is lock-free?
21:02:45 <sheikra> copumpkin: I didn't see Bar in your question?
21:03:22 <jmcarthur> sheikra: the constructors are the only way haskell knows to tell which case you mean
21:03:27 <copumpkin> sheikra: I'm saying if you write data Foo = Foo, the value-level Foo has type Foo, but also has type Foo | Int, or Foo | Maybe Bool, and Foo | anything else
21:03:30 <sheikra> jmcarthur: for example, data Person = Professor Name | Student Name
21:03:43 <jmcarthur> Professor and Student are not type constructors
21:03:52 <sheikra> jmcarthur: the Name's are components of Professor and Student then
21:04:01 <jmcarthur> yeah....
21:04:40 <sheikra> jmcarthur: but some times I don't want a constructor over the types that I already defined
21:04:47 <jmcarthur> in data A3 = E3 B | E4 C2, B is a component of E3 and C2 is a component of E4
21:05:10 <sheikra> jmcarthur: because logically they are not components inside something else. I just want a union of them
21:05:35 <jmcarthur> well haskell doesn't have unions. it has tagged unions
21:06:02 <sheikra> jmcarthur: so my question is just that ... a union type can be quite useful in this case ..
21:06:28 <jmcarthur> sure, assuming that it's always unambiguous
21:06:40 <sheikra> I just wonder whether it's a trade-off not to have unions, or is there any other reason
21:07:02 <jmcarthur> mainly just that we can already do the same thing using tagged unions
21:07:08 <sheikra> I know it's hard to do type inference with unions ..
21:07:12 <jmcarthur> whereas the opposite is not true
21:07:31 <jmcarthur> well, not without ugly hacks and stuff
21:07:33 <sheikra> jmcarthur: but using tags make some programs uglier
21:07:57 <copumpkin> try scala
21:08:02 <jmcarthur> i'd suggest just making a new type with all the cases you want
21:08:06 <ddarius> djahandarie: Does that question even make sense?
21:08:23 <jmcarthur> i don't think adts are ugly, personally
21:08:27 <jmcarthur> but that's jus tme
21:08:29 <jmcarthur> *just me
21:08:57 <sheikra> jmcarthur: I didn't say it's ugly, but sometimes unions can make things nicer
21:09:12 <djahandarie> ddarius, not sure. Why doesn't it?
21:09:13 <Mathnerd314> copumpkin: how is that a solution? :p
21:09:17 <sheikra> when something is not really a component..
21:09:31 <sheikra> copumpkin: scala has union types?
21:09:48 <ddarius> djahandarie: For an immutable type, there's nothing to guard.
21:09:51 <applicative> it sounds horrible; something people might implement because they can
21:09:56 <copumpkin> sheikra: not explicitly, but if you create a dummy supertype that two other types extend, then you might as well call it the union of them
21:10:09 <copumpkin> or even a sealed trait
21:10:29 <copumpkin> sheikra: or use ceylon ;)
21:10:32 <sheikra> copumpkin: then I still have to create another type ..
21:10:56 <jmcarthur> i think you are worrying too much about appearances
21:11:02 <ddarius> Polymorphic variants.
21:11:06 <sheikra> copumpkin: I'm looking at typed racket. It has unions. while it has some other stuff missing
21:11:23 <copumpkin> sheikra: the reason it isn't very common is that it's not inferrable, and people like that
21:11:37 <sheikra> It's not just appearance. It's about whether the design matches nature of things
21:11:38 <jmcarthur> what do unions offer that tagged unions can't aside from saving a couple keystrokes here and there?
21:11:50 <applicative> if the ghc can't infer the type, can the reader?
21:11:59 <sheikra> copumpkin: yeah. I think you got the point!
21:12:06 <jmcarthur> to me the nature of things is that you are using contructors from two different types, so it makes sense to have to distinguish the types
21:12:25 <ddarius> applicative: Usually when types aren't inferrable, it's because there isn't a unique "best" answer.
21:12:46 <sheikra> jmcarthur: the keystrokes mean everything. I could write programs in assembly if I don't care about keystrokes ;-)
21:12:55 <applicative> ddarius, yes.
21:13:17 <jmcarthur> sheikra: keystrokes are not the reason to use a high level language
21:13:23 <sheikra> jmcarthur: but the constructors of the two types can already distinguish them ..
21:13:36 <sheikra> why put another two constructors over them?
21:13:51 <jmcarthur> sheikra: only in the very specific case that you don't make two constructor wrapping the same type
21:13:55 <copumpkin> data Foo = Oink String | Baa String
21:14:01 <sheikra> jmcarthur: as what I said .. Nature is the reason :-)
21:14:10 <jmcarthur> nature?
21:14:11 <copumpkin> appeals to nature in programming are weak
21:14:18 <applicative> this was the case I was baffled sheikra was overlooking.
21:14:27 <applicative> Error String | Good String
21:14:34 <dolio> sheikra: How do you use a value with a union type?
21:14:38 <copumpkin> things like "the universe clearly uses mutation" show a lack of philosophical awareness :P
21:14:38 <ddarius> They decided to make my smoked bean curd spicy.
21:14:40 <jmcarthur> applicative: sheikra has already claimed that that is entirely different somehow
21:14:45 <applicative> lets make a Union!
21:14:45 <sheikra> copumpkin: when you put String inside Oink and Baa, the string is a natural components of them
21:14:58 <ddarius> copumpkin: The universe clearly uses COBOL.
21:15:03 <jmcarthur> sheikra: dude if you need a big enum then make a big enum
21:15:05 * copumpkin wants confederate types
21:15:20 <applicative> jmcarthur: but how can it be entirely different?
21:15:26 <jmcarthur> applicative: ask him
21:15:27 <ddarius> copumpkin: I mean, really, do you think you could make the universe without built-in ISAM support?
21:16:02 <dolio> I don't know what that is, but the answer is obviously no.
21:16:03 <applicative> How can Haskell be so stupid as to allow you to distinguish a type from itself, as in Error String | Good String; and then turns around and won't let you assimilate two types....
21:17:28 <sheikra> applicative: because of it can't let go type inference
21:18:57 <sheikra> applicative: I tend to think about that the essence of utilizing type inference is "to allow a mathematician write proofs without writing theorems". Everything you read a proof, you don't know what it is proving. You have to INFER the theorem from it. lol
21:18:59 <applicative> if there is a union of two types, each with 'equality', do we end up with equal things from the (elsewhere) different types?
21:19:23 <Mathnerd314> copumpkin: wait, why can't you infer types in the presence of untagged unions?
21:19:33 <jmcarthur> Mathnerd314: what's the type of "foo"?
21:19:42 <jmcarthur> as in the string literal "foo"
21:19:55 <jmcarthur> without OverloadedStrings
21:19:57 <sheikra> applicative: unless you have equality defined for {A,B} -> {A,B} -> bool
21:20:19 <applicative> it shouldn't be necessary to write type signatures; or insofar as it is they are ceasing really to be types.
21:20:34 <Mathnerd314> jmcarthur: [Char] ?
21:20:38 <jmcarthur> Mathnerd314: you might think it's String, but it could be String+Int or String+Bool+Double or ....
21:20:55 * applicative grants he has an antiquated conception of the matter
21:21:08 <Mathnerd314> jmcarthur: ok, [Char] | a
21:21:12 <jmcarthur> ha
21:21:24 <jmcarthur> so then i can say   "foo" + 5
21:21:52 <dolio> Why would you be able to say that?
21:21:53 <Mathnerd314> hmm, I think I'll go back [Char]
21:21:54 <jmcarthur> actually i guess that would constrain it
21:21:59 <Mathnerd314> *to [Char]
21:22:20 <jmcarthur> let me rewind
21:23:09 <Mathnerd314> ok...
21:23:16 <jmcarthur> Mathnerd314: say i do this:   ["foo", 5]   -- how do i know whether this is a type error?
21:23:37 <copumpkin> you don't
21:23:43 <copumpkin> and in scala that bites you all the fucking time
21:23:43 <ddarius> :t ["foo", 5[
21:23:44 <lambdabot> parse error (possibly incorrect indentation)
21:23:46 <ddarius> :t ["foo", 5]
21:23:47 <lambdabot>     No instance for (Num [Char])
21:23:47 <lambdabot>       arising from the literal `5' at <interactive>:1:8
21:23:47 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
21:24:00 <copumpkin> damn polymorphic numbers!
21:24:07 <dolio> What are you going to do with your union-typed ["foo", 5]?
21:24:24 <jmcarthur> print it?
21:24:30 <copumpkin> sheikra:
21:24:30 <Mathnerd314> jmcarthur: pretty certain that has type [String | Integer], if you do defaulting
21:24:32 <dolio> I suppose you could do that.
21:25:10 <dolio> The thing is, you can only use it with functions with intersection types, essentially.
21:25:40 <jmcarthur> Mathnerd314: now, say i decide to take the sum of that list elsewhere. where should the error be reported?
21:25:47 <ddarius> If you're going to have union types you may as well have intersection types.
21:26:05 <dolio> Yes, you may as well.
21:26:07 <Mathnerd314> jmcarthur: when you take the sum, obviously
21:26:19 <jmcarthur> Mathnerd314: what if you meant to have a non-union list?
21:26:28 <applicative> new work for  empty types
21:26:31 <jmcarthur> eh i'm getting off track with this
21:26:34 <ddarius> jmcarthur: You should do type error slicing and show all the points that could have led to the error.
21:26:37 <Mathnerd314> jmcarthur: then you'd add a type signature... :p
21:29:06 <ddarius> At least one system of intersection types has inference up to any arbitrary rank-k, but not for unbounded rank since it turns out that the inference algorithm follows beta reduction.
21:29:09 <applicative> what is the technique called in the she preprocessor, which would spare sheikra some of the constructor pile up pain. It seems pretty rational
21:29:31 <copumpkin> pattern synonyms?
21:29:38 <copumpkin> something like that
21:29:39 <applicative> exactly, found it
21:29:40 <copumpkin> aliases?
21:29:52 <c1de0x> copumpkin !!!!
21:29:54 <applicative> http://personal.cis.strath.ac.uk/~conor/pub/she/patsy.html
21:30:03 <copumpkin> hi c1de0x :)
21:30:13 <c1de0x> welcome home?
21:30:17 <c1de0x> (?)
21:30:18 <copumpkin> thanks!
21:30:25 <c1de0x> how was ure trip?
21:30:26 <copumpkin> gonna get my usual computer back tomorrow
21:31:17 <applicative> sheikra, how about implementing pattern synonyms?  of course, the still leave you writing the ugly type, and then the synonyms.
21:31:39 <applicative> rather, *they* still leave you...
21:31:56 <sheikra> applicative: you are already writing type signatures in Haskell, everything you write a case expression, you write type signatures ..
21:32:11 <dolio> ddarius: My point was more that union types don't allow the same operations that coproducts do. You'd be gaining the ability to not write down constructors, while losing the ability to do case analysis. So if we're against the former merely because it's syntactically heavy, it's rather missing the point.
21:32:25 <sheikra> applicative: every time I write "every time", it becomes "everything". lol
21:32:36 <sheikra> sorry
21:33:36 <sheikra> dolio: but we can do case analysis on the constructors separately
21:33:40 <applicative> i use the constructors in a case expression
21:34:00 <sheikra> applicative: the constructors are in essence type signatures
21:34:10 <applicative> i don't name the type.
21:35:10 <sheikra> I mean, "in essence"..
21:35:47 <dolio> sheikra: What formal theory are you basing this on?
21:36:09 <sheikra> Curry-Howard Isomorphism says, a program is a proof, and its type the theorem it is proving
21:36:16 <CakeProphet> Anyone recommend a good GUI toolkit Haskell? I've looked at the haskellwiki list but I'm unsure which to look at.
21:36:45 <dolio> Curry-Howard says you can do case analysis on union types by looking at the constructors of the constituent types?
21:37:10 <sheikra> so my point is that writing a programs and don't write types, and let the type inferencer infer its type. Then it is equivalent for a mathematician to write proofs without writing theorems..
21:37:39 <sheikra> dolio: oh, I was talking about another point ;-)
21:37:58 <sheikra> dolio: what I tried to say is that type signatures should be required
21:38:19 <sheikra> or we will have to infer the theorems every time we read proofs ..
21:39:12 <sheikra> type signatures ~ theorems. we shoudl write Theorem 1. blah ... Proof. ...
21:40:49 <Philippa_> nah. Having the compiler tell you just how general a theorem you just proved is a wonderful, wonderful thing
21:42:01 <sheikra> but the compiler can only tell you the theorem if you write the proof in a way it understands ...
21:42:24 <Philippa_> which we call grammatically correct, typechecking haskell code
21:42:49 <sheikra> but it has reached the limit of type inference..
21:43:06 <sheikra> and people want more ..
21:43:08 <Philippa_> and then some, yes, we know that it's useful to have at least some annotations
21:43:16 <Philippa_> Haskell doesn't prevent that
21:43:50 <sheikra> the point is that once we want to keep type inference, we will sacrific lots of other things..
21:44:10 <Philippa_> not really. Nobody's proposing to keep complete type inference these days
21:45:20 <Philippa_> you really, really don't want to deal with the no-inference-anywhere case for a sufficiently strong type system, either
21:45:38 <Philippa_> Coq doesn't do that, Agda doesn't do that
21:45:43 <CakeProphet> so wait, people are saying we should ditch complete type inference?
21:45:51 <Philippa_> CakeProphet: we ditched it a long time ago
21:46:11 <applicative> there are expressions of diverse types that cannot be employed in programming at all, take a look at a grammar book.
21:46:20 <Philippa_> there are several things that GHC cannot infer the type for. Arbitrary rank-n types and polymorphic recursion are two of the oldest
21:47:14 <Philippa_> those are cases where it's provable that you can't have complete inference, too
21:47:30 <sheikra> Philippa_: surely we should keep the kind of "foward" type inference..
21:47:37 <CakeProphet> I see. I suppose I've simply never encountered those cases in my own code.
21:47:48 <dolio> Having to annotate all your lambdas and sigmas is a pain.
21:48:10 <dolio> Or, pairs, I guess, not sigmas.
21:48:40 <sheikra> dolio: I guess we don't have to annotate pairs. they are polymorphic
21:49:04 <sheikra> dolio: we get their types from the values' types
21:49:06 <dolio> Dependent pairs.
21:49:41 <dolio> What is the type of (5, 6)?
21:49:57 <sheikra> dolio: oh, I see what you mean
21:50:45 <sheikra> dolio: but the type of the constructor of a "pair" would tell you which argument is what
21:51:28 <dolio> What?
21:51:33 <CakeProphet> :t (,)
21:51:34 <lambdabot> forall a b. a -> b -> (a, b)
21:51:37 <CakeProphet> not really
21:51:56 <dolio> I'm talking about one type.
21:52:12 <dolio> _,_ : (x : A) -> (y : P x) -> Sigma A P
21:53:07 <sheikra> dolio: Sigma will tell you what the types are?
21:53:37 <dolio> 5 : Integer, 6 : Integer, (5, 6) : ?
21:54:06 <sheikra> 5 : A, 6 : P A
21:54:12 <dolio> You can't infer the type, but you can have your system do some clever back and forth with the context so you don't have to annotate it every time.
21:54:29 <sheikra> dolio: that's my point ;-)
21:54:47 <sheikra> dolio: we can infer the output type from functions
21:54:52 <dolio> That's a species of inference, though.
21:54:53 <sheikra> from applications
21:55:01 <dolio> It's just not perfect.
21:55:20 <sheikra> but not the kind of HM inference. it doesn't use unification I guess
21:55:50 <dolio> You can't have '(\x -> e) 5' in your language without any inference.
21:56:05 <sheikra> dolio: you shouldn't have that ..
21:56:15 <sheikra> dolio: all parameters should be annotated
21:56:20 <dolio> No. That's terrible.
21:56:29 <sheikra> \(x : Int) -> e for example
21:56:50 <sheikra> dolio: input should be specified.. that's my new belief ;-)
21:57:24 <sheikra> dolio: It's not that terrible
21:57:33 <dolio> It is.
21:57:36 <dolio> Go program some Scala.
21:57:59 <sheikra> dolio: oh, that's another issue with Scala ;-)
21:58:17 <sheikra> dolio: it tried to do it, but doesn't do it quite right
21:58:28 <dolio> I suppose Scala exacerbates the problem by trying to do inference, but failing a lot.
21:59:02 <sheikra> dolio: I just learned Scala yesterday. I think it's still an OOP and not a FP
21:59:25 <dolio> It's probably better to just annotate everything than to give the hope of not annotating, but constantly renege on it.
21:59:50 <sheikra> dolio: the left sides don't need annotations
21:59:53 <dolio> But you can do quite a lot of inference even in fancy systems, and it's quite a bit nicer.
22:00:38 <sheikra> dolio: yes. certainly we wouldn't like to annotate like Java ..
22:01:04 <sheikra> dolio: I don't see the point why we need annotations for each variable delcaration
22:22:03 <MasseR> How do I include extra files with cabal? Ie. graphics/translations/etc
22:23:00 <shachaf> @google How do I include extra file with cabal?
22:23:01 <lambdabot> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
22:23:01 <lambdabot> Title: Neil Mitchell's Haskell Blog: Adding data files using
22:49:47 <zenzike> is there a library that transforms data from constructors to sums and products? eg, data Foo = Foo Int String ==> Int :*: String ?
22:52:20 <ddarius> Yes.
22:54:21 <Cale> http://hackage.haskell.org/package/emgm
22:54:26 <Cale> for example
22:55:27 <dons> useful
22:55:48 <zenzike> very :-)
22:55:51 <ddarius> @hoogle Data
22:55:52 <lambdabot> module Data.Data
22:55:52 <lambdabot> Data.Data class Typeable a => Data a
22:55:52 <lambdabot> Data.Data dataCast1 :: (Data a, Typeable1 t) => c (t d) -> Maybe (c a)
22:57:40 <RayNbow`TU> dons, is the "exists" on slide 21 of http://www.galois.com/~dons/slides/08-07-stewart.pdf really correct?
22:59:21 <RayNbow`TU> (I mean, shouldn't it be "forall" instead?)
23:04:05 <frerich2> Hi, I just saw this in the xmonad source code and I don't think I ever saw this before. Could somebody here maybe explain this to a Haskell beginner like me? :-)
23:04:17 <frerich2> data Workspace i a = Workspace { tag :: !i, stack :: Maybe (Stack a) }
23:04:20 <frerich2> What is the '!' doing in there?
23:04:27 <zenzike> it's a strictness annotation
23:04:46 <zenzike> it means that the value of 'tag' is not evaluated lazily, but strictly
23:04:49 <frerich2> Hm that's something to google for :-)
23:04:57 <frerich2> Hmm
23:05:41 <frerich2> zenzike: Sorry for not having my basic nomenclature straight, but - that means that 'tag' is evaluated as soon as the 'Workspace' data ctor is "invoked" instead of being evaluated whenever its value is needed?
23:05:46 <frerich2> (i.e. possibly never)
23:06:47 <zenzike> yes, that's about right :-)
23:07:38 <zenzike> frerich2: http://www.haskell.org/haskellwiki/Performance/Data_types
23:08:05 <frerich2> zenzike: Aaah, thanks. :-)
23:10:38 <zenzike> frerich2: a consequence of making these values strict is that if you know the value will always get evaluated anyway, you avoid the overhead of storing the fact that the value will need evaluating lazily (the thunk)
23:11:40 <frerich2> zenzike: Hm, I see. Would you say that a good rule of thumb would be "Be lazy by default, profile, make stuff strict to avoid lots of thunks hanging around"?
23:13:12 <zenzike> frerich2: yep, I'd say that's a good rule of thumb
23:18:14 <dons> RayNbow`TU: yes, but you can read it as "exists" :)
23:26:32 <RayNbow`TU> dons: ok :)
23:26:39 <kamatsu> if I have some AST type
23:26:49 <kamatsu> is there an easy way to search through the AST to find something that looks like blah?
23:26:56 <kamatsu> is this the motivation behind syb and similar?
23:27:11 <dons> kamatsu: exactly
23:27:27 <kamatsu> which library should I use?
23:27:27 <dons> syb's "everywhere" and so on is all about finding nodes in ASTs
23:27:46 <dons> well, syb is a classic, but these days there are so many choices. making the choice is a publishable result
23:27:52 <kamatsu> hah
23:28:30 <dons> literally. there was a paper at the haskeell workshop in 2008
23:30:02 <kamatsu> which one is the easiest for a newbie to generic programming to understand?
23:30:07 <kamatsu> syb looks a bit intimidating
23:30:32 <kamatsu> i'll check out uniplate
23:31:16 <dons> hmm. uniplate is fairly simple
23:31:48 <kamatsu> i literally only ever need to use it to identify AST nodes without irritating destructuring functions.
23:32:30 <kamatsu> (I'm working on a translator from GHC core to Isabelle/HOL for work)
23:33:12 <dons> ohhhh..
23:33:23 <dons> did you see the Coq/Core embedding?
23:33:26 <dons> by Megacz
23:33:35 <dons> and ... for work? :) sounds good
23:34:04 <kamatsu> dons: I work for NICTA.
23:34:32 <kamatsu> yup, saw that
23:34:38 <kamatsu> also sore the Isabelle/HOLCF embedding
23:34:40 <dons> ah yes :) heh
23:34:46 * dons forgets all the nicta-ites
23:34:48 <kamatsu> *saw :/
23:35:19 <dons> was hanging out with sjw and toby last week
23:35:43 <kamatsu> right
23:35:50 <kamatsu> i think I saw you briefly actually
23:36:08 <kamatsu> you did a talk at the uni?, I was going to go but I had to teach.
23:36:15 <dons> yeah, i dropped by
23:37:06 <kamatsu> I actually only recently started at NICTA
23:37:21 <kamatsu> so I wouldn't expect you to remember me :P I'm in PLS though.
23:37:57 <dons> i've made 2 PLS group meetings in 4  years :}
23:38:00 <kamatsu> haha
23:39:00 <kamatsu> i rarely show up, but I don't even have an excuse. I live here, I'm just too lazy to get up early.
23:39:48 <blackdog> kamatsu: you in gerwin's group?
23:39:56 <kamatsu> blackdog: i am now
23:40:02 <kamatsu> only started a few weeks ago
23:41:16 <blackdog> kamatsu: ah, fair enough. pete was telling me about his time there - pretty gnarly codebase, apparently.
23:41:39 <kamatsu> blackdog: it's getting better.
23:42:24 <kamatsu> blackdog: my translator will hopefully improve things too, because we can switch from random-regexing-python-script to something that has some semantic understanding of haskell.
23:43:08 <dons> about time.
23:43:18 <kamatsu> so what I'm working on specifically at the moment is reconstructing type-class information from core
23:43:28 <kamatsu> because core has already dictionaryfied that stuff
23:43:52 <kamatsu> so I need to look for function bindings that look specifically like a dictionary getter
23:44:15 <kamatsu> hence generic programming libs
23:49:33 <jan247> hi, how do i parse a string to an int if i'm expecting a result of Maybe Int.
23:49:45 <kamatsu> jan247: a function that wraps around reads.
23:50:00 <Axman6> :t reads
23:50:01 <lambdabot> forall a. (Read a) => String -> [(a, String)]
23:50:10 <jan247> so it's a try/catch thing?
23:50:14 <kamatsu> > reads "3"
23:50:15 <lambdabot>   []
23:50:18 <kamatsu> > reads "3" :: Int
23:50:19 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:50:19 <lambdabot>         against inferred type ...
23:50:25 <kamatsu> > (reads "3") :: Int
23:50:26 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:50:26 <lambdabot>         against inferred type ...
23:50:30 <kamatsu> :/
23:50:33 <Axman6> > reads "1" :: [(Int,String)]
23:50:33 <kamatsu> oh, i'm a fool
23:50:34 <lambdabot>   [(1,"")]
23:50:39 <Axman6> > reads "1 blah" :: [(Int,String)]
23:50:40 <lambdabot>   [(1," blah")]
23:50:45 <Axman6> > reads "   1 blah" :: [(Int,String)]
23:50:45 <lambdabot>   [(1," blah")]
23:50:54 <Axman6> > reads "   lol blah" :: [(Int,String)]
23:50:55 <lambdabot>   []
23:51:09 <Axman6> never understood why it uses a list though
23:51:32 <kamatsu> so, your function could be, simply: foo x = case reads x of [(x,"")] -> Just x; _ -> Nothing
23:51:39 <rothwell> lo. anyone here got any idea how i'm suppose to get the agda standard library to compile? i just get a ghc stack overflow. i've asked in #agda twice now and not gotten a response
23:51:59 <kamatsu> rothwell: er, so, have you set it up in emacs? or is this batch mode?
23:52:00 <rothwell> presumably i need to raise a stack limit somehow, but i've no idea how
23:52:14 <rothwell> kamatsu: no emacs involved
23:52:25 <kamatsu> I can compile lib-0.4 on latest agda
23:52:26 <rothwell> let me do the process again so i can get pastable errors...
23:52:42 <kamatsu> OS?
23:52:48 <rothwell> freebsd 8.2 amd64
23:52:53 <kamatsu> hm
23:53:06 <kamatsu> possible GHC runs with a diffeent stack limit than on Linux? :/
23:53:10 <kamatsu> *different
23:53:12 <rothwell> could well be
23:53:19 <rothwell> there may be OS limits i'm not aware of, too
23:53:47 * rothwell watches compilation messages go past
23:54:04 <dmwit> 64-bit vs. 32-bit will make a difference, too
23:54:11 <kamatsu> wait, so you're compiling the Agda standard library with Agda and the Agda compiler stack overflows?
23:54:28 <kamatsu> dmwit: yeah, but i've compiled on x86_64 arch no probs.
23:57:10 <rothwell> kamatsu: one sec
23:57:44 <rothwell> http://pastebin.ca/2060955
23:58:08 <rothwell> not entirely sure what's going on there
23:58:38 <kamatsu> well
23:58:39 <rothwell> i assumed it was ghc, but i've just realized it could be agda
23:59:02 <kamatsu> it's the GHC runtime system which is hitting stack space overflow
23:59:11 <kamatsu> but the reason for that could either be GHC runtime or Agda bug
23:59:24 <kamatsu> try increasing the stack space size
23:59:35 <kamatsu> add options to the agda compiler line
23:59:43 <kamatsu> +RTS -Ksize -RTS
