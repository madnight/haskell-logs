00:11:04 <ivant_> has anyone been able to make CellWriter work using ICCCMFocus hook?
00:13:15 <Axman6> ivant_: I've never heard of any of those things...
00:13:36 <ivant_> Axman6, http://www.eng.uwaterloo.ca/~aavogt/xmonad/docs/xmonad-contrib/XMonad-Hooks-ICCCMFocus.html
00:13:52 <Axman6> it would be helpful if you mentioned Xmonad then ;)
00:13:53 <ivant_> that's part of xmonad-contrib-0.10, which is in darcs
00:14:11 <Axman6> have you tried asking in #xmonad?
00:14:16 <ivant_> Axman6, oh, pardon, I missed the channel!
00:14:26 <Axman6> :)
00:17:22 * hackagebot text-format 0.2.0.0 - Text formatting  http://hackage.haskell.org/package/text-format-0.2.0.0 (BryanOSullivan)
00:27:23 * hackagebot arbb-vm 0.1.1.2 - FFI binding to the Intel Array Building Blocks (ArBB) virtual machine.  http://hackage.haskell.org/package/arbb-vm-0.1.1.2 (JoelSvensson)
00:44:50 <orclev> quick question if anyone is around, any idea why after a while q program would stop printing to stdout?
00:45:06 <Botje> nothing left to print?
00:45:14 <orclev> it's still running, and I can trigger events that should generate output, but it just doesn't
00:45:46 <orclev> it's fairly consistent to, after printing something like 100 lines of output it just quits until I restart it
00:46:00 <orclev> seems almost like a buffering thing
00:46:20 <Axman6> you'd have to share the code
00:46:45 <Botje> are you printing newlines?
00:46:50 <orclev> yeah
00:46:50 <Botje> otherwise you run into block buffering
00:47:01 <orclev> I'm using putStrLn
00:47:28 <orclev> hmm... there's a utility for quickly posting to a pastebin, anyone happen to remember the name of it?
00:47:59 <orclev> nevermind, found one
00:48:31 <orclev> give me like 30 seconds and I'll have the source uploaded to a pastebin
00:49:55 <orclev> it's messy still as I'm experimenting:  http://paste.pocoo.org/show/393533/
00:51:53 <orclev> also the graphics stuff at the begining of main can be ignored, it's not really doing anything yet
00:55:41 <orclev> a thought just occured to me... it could also be a bug in the SDL library where it just stops processing joystick events after a certain number
00:55:52 <Botje> that looks okay, yes
00:56:25 <orclev> yeah, it kinda looks like that... if I type keys I get more output, it's only moving the joystick more that fails to generate anything
00:56:42 <Botje> oh
00:56:42 <Botje> brr :)
00:56:57 <orclev> brr?
00:58:12 <Botje> doesn't sound like a fun issue
00:58:55 <orclev> hmm, I notice there's a update function defined in the joystick package... going to see what happens if I slap that in there after each joystick event
01:02:43 <poltak> I have a question about the history of Haskell (is that allowed)?
01:04:27 <orclev> near as I can tell just about anything haskell related (and a few things that aren't) are allowed
01:05:37 <orclev> btw Botje, thanks for the help, it does look like a problem either with SDL or the haskell SDL bindings
01:08:03 <ddarius> @where history
01:08:03 <lambdabot> I know nothing about history.
01:08:27 <ddarius> @where+ history http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm
01:08:28 <lambdabot> I will remember.
01:08:31 <ddarius> @where retrospective
01:08:31 <lambdabot> I know nothing about retrospective.
01:09:01 <ddarius> @where+ retrospective http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/
01:09:01 <lambdabot> Done.
01:09:22 * ddarius doesn't know what they teach IRC bots in school these days.
01:34:43 <o-_-o> Hello
01:34:57 <o-_-o> When I try to build OpenGL, cabal is giving me this error
01:36:05 <o-_-o> http://hpaste.org/46958/opengl_errors
01:36:19 <o-_-o> I traced it down to 2 lines in OpenGL.cabal
01:36:33 <o-_-o> includes: HsOpenGL.h
01:36:33 <o-_-o> install-includes: HsOpenGL.h
01:36:39 <o-_-o> but this file exists
01:36:45 <o-_-o> I am not sure what to do
01:37:19 <dcoutts> o-_-o: do you see the suggestion at the end of the error message?
01:37:19 <lambdabot> dcoutts: You have 4 new messages. '/msg lambdabot @messages' to read them.
01:37:21 <o-_-o> The version is 2.2.3.0, http://hackage.haskell.org/packages/archive/OpenGL/2.2.3.0/
01:37:57 <o-_-o> I have set the path als
01:37:59 <o-_-o> also
01:57:41 <o-_-o> dcoutts: thanks, I put -v3 and got a more detailed error message
01:57:46 <o-_-o> that help solve the issue
01:57:58 <dcoutts> great
01:58:04 * dcoutts admits it could be better
01:58:06 <o-_-o> it needs a bunch of X11 includes, which are not mentioned anywhere as dependencies
01:58:36 <o-_-o> and finding the same version as the one installed on the current system is a pain in the neck..
02:06:43 <tomh> hmm there was a function right to perform IO actions on a list of items? was it liftIO ?
02:07:44 <quicksilver> mapM probably
02:07:48 <quicksilver> depends slightly what you mean.
02:07:52 <pacak> mapM and mapM_
02:08:24 <yottis> mapM for running the same action on a list, and sequence for running a list of actions
02:08:35 <tomh> ah yeah thats the one
02:09:47 <pacak> @hoogle [IO a] -> IO [a]
02:09:47 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
02:09:47 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
02:09:47 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
02:10:12 <tomh> hmm, so is there any way to kill threads in ghci upon program exit (I use ctrl+c)
02:10:39 <tomh> don't think my mapM killThread is called
02:15:46 <poltak> I have a question about the history of Haskell (is that allowed)?
02:53:50 <manateeUser> 大家好。
02:54:06 <manateeUser> I tested my IRC client.
02:54:25 <mauke> U+5927 (e5 a4 a7): CJK UNIFIED IDEOGRAPH-5927 [大]; U+5BB6 (e5 ae b6): CJK UNIFIED IDEOGRAPH-5BB6 [家]; U+597D (e5 a5 bd): CJK UNIFIED IDEOGRAPH-597D [好]; U+3002 (e3 80 82): IDEOGRAPHIC FULL STOP [。]
02:54:29 <mauke> success
02:54:58 <geheimdienst> mauke: thanks for explaining that, it's clear to me now
02:54:59 <geheimdienst> ;)
02:55:29 <mauke> the unicode names for CJK ideographs are rather unhelpful :-)
02:55:49 <FUZxxl> mauke: The meaning is something like "Hello all!"
02:56:00 <FUZxxl> em... !->.
02:56:15 <geheimdienst> FUZxxl: how do you say OHAI in chinese?
02:56:30 <FUZxxl> WTF is OHAI?
02:56:49 <ddarius> Good answer.
02:56:51 <flamingspinach> WFT is WTF?
02:56:54 <FUZxxl> I don't know, what OHAI means.
02:56:58 * mauke dons his hay guise
02:57:56 <FUZxxl> I really don't know - I am not a native speaker.
02:58:26 <mauke> http://ephemerist.files.wordpress.com/2009/02/lol-o-hai-i-upgraded-ur-language.jpg
02:58:58 <FUZxxl> Hm...
02:59:10 <FUZxxl> I am not a native chinese either... let's guess....
02:59:15 * osfameron bought PragProg's "7 langs in 7 weeks" book.  Looking forward to reading the Haskell section (and the others, tbh)
02:59:25 <FUZxxl> mauke: rofl
02:59:46 <FUZxxl> osfameron: It's really great.
02:59:49 <geheimdienst> FUZxxl: i was just kidding :) it's a joke thing, there's a lot of lolcats that say "ohai" for "oh, hi"
03:00:09 <FUZxxl> Yes. I saw now.
03:00:26 <FUZxxl> Slang is always difficult to translate... lolcats are funny though
03:01:46 <mauke> 大̃
03:01:51 <mauke> hmm, doesn't render here
03:02:04 <pacak> mauke: it does.
03:02:17 <FUZxxl> mauke: It really renders.
03:02:19 <mauke> what do you see?
03:02:27 <FUZxxl> But what does da2kou3 means?
03:02:39 <Liskni_si> mauke: a guy with a bird
03:02:39 <FUZxxl> s/da2/da4
03:02:43 <geheimdienst> mauke: works for me, it's a triangle wearing a top hat and two incoming cruise missles in the background
03:02:44 <pacak> mauke: Japanese character,
03:02:47 <Liskni_si> (in his hand)
03:03:09 <alex404> Can anyone tell me why even though I have ghc installed and ghc-pkg check seems to think my packages are installed fine, I can't actually get, e.g. ghci to load anything?
03:03:15 <mauke> geheimdienst: I don't see the missiles
03:03:30 <mauke> it was supposed to be a chinese character with a tilde on top
03:03:32 <FUZxxl> Is the second char kou3?
03:03:41 <FUZxxl> mauke: Ah!
03:03:48 <FUZxxl> No. It does not renders.
03:04:02 <mauke> Spin̈al Tap
03:04:24 <FUZxxl> mauke: That works.
03:04:33 <FUZxxl> ̃大
03:04:34 <geheimdienst> mauke: it does render as one character, not two. the missiles are in the top right corner
03:04:39 <FUZxxl> And that works too...
03:05:04 <geheimdienst> FUZxxl: that came through as two characters
03:05:38 <FUZxxl> geheimdienst: In maukes example, I saw some kind of replacement char only.
03:05:45 <mauke> FUZxx̃l
03:06:00 <FUZxxl> yes.
03:06:17 <geheimdienst> i guess combining characters are still kind of high-tech ... don't really work reliably
03:07:04 <FUZxxl> yes. (But TeX can do this since ... ever? Or am I na\"ive?)
03:07:49 <mauke> ï ï
03:09:23 <rtharper> é é?
03:09:41 <Jafet> No, just n̈aıve
03:09:51 <rtharper> uff
03:10:02 * rtharper loves diacritics.
03:10:13 <rtharper> I think we should use them with abandon in English
03:10:31 <alex404> Can anyone tell me why even though ghc-pkg check seems to think my packages are installed fine, I can't actually get, e.g. ghci to load anything? I can't get it to tab complete any of my packages?
03:10:33 <rtharper> I particularly enjoy diæresis to express two vowels in hiätus
03:10:43 <FUZxxl> Renders as \"na\ive on my machine
03:10:50 <FUZxxl> Oh yes.
03:10:58 <FUZxxl> It is supposed to be na\"\ive
03:11:06 <rtharper> or just
03:11:09 <rtharper> \"i
03:11:57 <Jafet> alex404: can ghc build programs with those packages?
03:12:06 <alex404> Jafet: Aye.
03:12:13 <Jafet> Do you mean, to tab complete modules from those packages?
03:12:28 <alex404> Jafet: Yes.
03:12:58 <Jafet> That's too weird for me to suggest anything further, sorry.
03:13:20 <rkrzr> hi haskellers, I was wondering whether there is a way to always show types forall'd in ghci?
03:13:22 <alex404> Jafet: Thanks anyway
03:13:32 <FUZxxl> rtharper: In TeX, this produces an i with three dots.
03:13:44 <rtharper> orly?
03:13:47 <FUZxxl> (assuming you use Knuth's original encoding)
03:13:53 * rtharper uses utf-8 input for LaTeX, anyway
03:14:09 <rtharper> I have mad diacritic keyboard skills and it takes a lot less time than writing them the latex way
03:14:41 <FUZxxl> rkrzr: Don't know.
03:14:56 <byorgey> jaspervdj: that works great, thanks!
03:15:08 <FUZxxl> Isn't there an option -XExplicitQuantification or similar?
03:15:16 <Jafet> alex404: often a cause of mismatch is because you installed packages for a user and then used ghc as another user
03:15:47 <Jafet> At a stretch, try ghc --interactive
03:16:10 <dobblego> anyone in the Brisbane area tomorrow night http://www.bfpg.org/events/17449603/
03:17:27 <rkrzr> FUZxxl, there is -XExplicitForAll and -XExistentialQuantification, but neither actually shows the forall if I do ":t id"
03:18:12 <dobblego> rkrzr: -fglasgow-exts to see explicit forall
03:18:22 <FUZxxl> rkrzr: Hm...
03:18:44 <FUZxxl> Maybe that's because the original type signature does not contains a forall
03:18:56 <rkrzr> dobblego, it worked, thanks!
03:19:00 <dobblego> np
03:19:15 <rkrzr> although I wonder, which extension now finally triggered it...
03:19:15 <ddarius> -fglasgow-exts turns on a whole slew of things.
03:20:03 <ddarius> Probably RankNTypes.
03:20:39 <rkrzr> ddarius, nope, doesn't look like it
03:20:43 <rkrzr> :q
03:21:19 <alex404> Jafet: That doesn't do anything either. I have my cabal config installing everything globally anyway. However...
03:21:46 <alex404> Jafet: Now that I'm looking at it properly, ghc-pkg check says my ghc-7.0.2 install is bad.
03:22:01 <alex404> Jafet: I'm not really sure how I could fix that though. And it's ironic that it's compiling everything.
03:23:09 <int-e> alex404: the ghc package is ghc-as-a-library; the compiler executable is indepenedent of that.
03:24:33 <int-e> alex404: (it's used by haddock, for example, or by libraries that load code dynamically like hint)
03:24:59 <alex404> int-e: Right. So you don't think it's related to my problem?
03:28:41 <Lemmih> alex404: Are you sure you can't use them from ghci?
03:29:24 <int-e> alex404: yeah, I just "broke" my ghc package and I don't think that it affected ghci.
03:29:54 <int-e> ("broke" = I moved the files away, temporarily)
03:30:47 <int-e> alex404: are your packages installed globally, and visible?
03:30:55 <alex404> Lemmih: Hmmm... I did something so that now it appears to work. ghc-pkg check sitll produces weird errors though... I need to keep investigating
03:31:21 <alex404> int-e: Theoretically, yes. Things are coming back on line. I reinstalled cabal and ghc and that appears to have cleaned things up to some extent...
03:34:56 <alex404> When I see soemthing like this with ghc-pkg check:   dependency "template-haskell-2.5.0.0-957162165c2e6480a35f6d14f7e5220f" doesn't exist
03:35:12 <alex404> What are all those charactes after the version number?
03:35:18 <alex404> characters
03:35:50 <dcoutts> alex404: a hash of the ABI
03:36:26 * int-e wonders how to force ghc-pkg to not use colors for indicating hidden and broken packages
03:36:57 <int-e> ghc-pkg list | cat  works, ok.
03:37:37 <burbul> Could I ask if there's a standard way to express the Kleene star operator on a monad (with zero) in terms of the functions available in Prelude/Monad? (I can write it directly... http://hpaste.org/46959/kleene_star ... but I feel like I must be missing a connection to some standard function.)
03:39:01 * hackagebot floatshow 0.2.0 - Alternative faster String representations for Double and Float,  String representations for more general numeric types.  http://hackage.haskell.org/package/floatshow-0.2.0 (DanielFischer)
03:39:04 <rostayob> what's the difference between binary and ghc-binary?
03:39:19 <int-e> burbul: Control.Applicative has a 'many' operator in the 'Alternative' class, although it puts the empty alternative last.
03:41:03 <int-e> burbul: (I think this fits your question since any MonadPlus instance can be made an instance of Alternative as well.)
03:41:19 <poltak> Can I ask a question about Haskell's history?
03:41:34 <tomh> why don't you just ask it
03:41:42 <rtharper> no, historical questions are expressly verboten according to the First Law Of Haskell
03:41:49 <rtharper> (yes, of course you may)
03:41:50 <rtharper> =)
03:41:52 <poltak> What is "verboten"?
03:41:54 <poltak> oh
03:41:55 <int-e> Try to ask and we'll find out.
03:41:59 <tomh> forbidden in german
03:41:59 <poltak> Okay, here goes
03:42:03 <roconnor> @wiki History of Haskell
03:42:03 <lambdabot> http://www.haskell.org/haskellwiki/History_of_Haskell
03:43:14 <poltak> This might sound odd but, in the history of all (GNU/Linux) has there been any major (or famous) robberies of pc gear?
03:43:27 <poltak> such as computers, physical software, source code etc?
03:43:56 <burbul> int-e: thanks!
03:44:53 <roconnor> poltak: I think you need to phrase your question in the form of a Haskell related question.
03:44:57 <int-e> poltak: well, SCO claimed so. ;) but it does feel rather off-topic, as it has little relation to Haskell.
03:48:09 <poltak> What? Is there any?
03:48:35 <poltak> And yes, I know it's strange question. I'm just very curious of big theft
03:50:22 <poltak> Anyone?
03:52:29 <TheZimm> poltak huh?
03:52:32 <rostayob> poltak: wwwwhhhat?
03:52:41 <rostayob> are you from the POLICE?
03:52:49 <roconnor> poltak: your question has nothing to do with Haskell.
03:53:57 <TheZimm> aight, good, im not the only one confused by the irrelevance :P
03:55:16 <poltak> err sorry, guys. I'll explain it better in a sec, I gotta do something for a sec
03:55:27 * TheZimm luls
03:55:35 <poltak> and NO I am not the police rostayob
03:55:49 * TheZimm luls harder
04:06:03 <rostayob> poltak: you're writing a haskell-based thriller?
04:06:13 <poltak> Alright, FINALLY finished my shit, now back to my question :)
04:06:32 <poltak> And no I am not! It's really a simple question...
04:07:03 <poltak> Are there any known cases in the history of gnu/linux that involve theft of something related to the project, such as computers, phones, source code etc
04:07:05 <poltak> ?
04:07:27 <roconnor> poltak: your question isn't haskell specific.
04:07:34 <roconnor> ask in another channel
04:07:42 <quicksilver> poltak: sounds like a question for the GNU misc newsgroup or something.
04:07:43 <poltak> Alright, in the history of GNU/Linux that relates to Haskell
04:07:56 <poltak> Coders of Haskell using Linux
04:08:00 <quicksilver> the history of GNU/Linux is almost entirely unrelated to haskell.
04:08:13 <poltak> You're not understanding
04:09:46 <poltak> Okay,so in the history of Haskell, has any major theft happened involving computers or source code?
04:09:50 <dmedvinsky> poltak: I use GNU/Linux, I code in Haskell, and I did once steal the screen cleaning wipe from the office to clean my monitor at home.
04:10:01 <roconnor> poltak: no
04:10:29 <poltak> Well you've just been proven wrong, roconnor by dmedvinsky
04:10:39 <roconnor> dmedvinsky: his theft wasn't major
04:10:43 <roconnor> er
04:10:46 <roconnor> poltak: ^^
04:11:25 <poltak> more major than any other reported thefts in this channel yet!
04:11:55 <poltak> I'm thinking of starting my own records/journal of all thefts related to GNU/Linux or Haskell for history-sake
04:12:14 <osfameron> poltak: I think we're not understanding because you're not being clear
04:12:36 --- mode: ChanServ set +o roconnor
04:12:40 <poltak> Okay, osama. Here goes:
04:13:03 <poltak> Have there been any major, or famous, reports of missing or stolen equipment or code relating to Haskell?
04:13:09 <osfameron> "osama"?
04:13:15 <rostayob> ahah osama
04:13:18 <poltak> In all the history of the language/OS
04:13:32 <roconnor> poltak: no
04:13:46 <poltak> Anyone else?
04:14:07 <poltak> If you don't want to talk about it openly, please start a private chat
04:14:19 <poltak> I garuntee your privacy
04:14:52 <osfameron> this sounds like you're trying to "get at" something in particular
04:15:01 <mun> hi
04:15:07 <poltak> Yes! I am trying to "get at" thefts relating to Haskell!
04:15:13 <poltak> (also gnu/linux)
04:15:23 <osfameron> what's a "theft relating to Haskell" ?
04:15:33 <poltak> theft of source code or machines
04:15:39 <poltak> or even personal belongings
04:15:45 <poltak> this is going in a historic archive
04:15:51 <rostayob> really.
04:15:53 <mun> in logic, if a variable can be instantiated to a function, then is the variable necessarily a higher-order variable?
04:15:55 <poltak> and you don't have to tell it in English
04:16:10 <poltak> Even Spanish or whatever bloody language you want
04:16:18 <rostayob> poltak: even latin?
04:16:26 <quicksilver> mun: I think "higher-order" means different things to different people but in logic it normally means a variable taking a value which is a proposition.
04:16:26 <roconnor> mun: yes, it is typically considered higher order if function application is part of your language.
04:16:26 <poltak> it's basically so new people to Haskell/gnu/linux can learn about the famous thefts of haskell
04:17:03 <rostayob> poltak: there are no famous thefts of haskell, stop trolling lol
04:17:19 <poltak> Ergh, is there a Haskell forums?
04:18:10 <mun> i see. then, is polymorphism necessarily a higher-order feature?
04:19:34 <roconnor> mun: but to clarify a point, In set theory there are set encodings of functions, but quantification over these sets is still quantification over sets so is therefore first order.
04:19:36 <poltak> Right, found a haskell forums, cya later unhelpfulls
04:21:51 <roconnor> mun: basically the difference is that functions encoded over sets are never function whose domain is *all sets*
04:22:02 <mun> roconnor, so quantification over functions is a first-order feature? i always thought it was a HO thing...
04:22:03 <roconnor> mun: maybe I'm just confusing the issue ...
04:22:46 <roconnor> mun: if function can be encoded by the objects of study, then quantification over these special classes of function is first order.
04:23:20 <roconnor> mun: for instance, you can encode primtive recursive function via a Goedel encoding, and so you can turn quantification over primitive recursive functions into quantification over numbers, which is first order.
04:23:59 <roconnor> mun: but you cannot encode all functions with numbers, so if you want to quantify over *all* functions, you need use a higher-order logic.
04:26:47 <mun> roconnor, right. but then is quantification over types necessarily HO?
04:29:07 <roconnor> mun: I not so knowledgabe but that, but I'd consider it higher-order.  I'd evey consider it beyond what is usually meant by higher-order.
04:29:15 <roconnor> *even
04:29:29 --- mode: roconnor set -o roconnor
04:32:07 * hackagebot NanoProlog 0.1 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.1 (JurrienStutterheim)
04:32:57 <mun> roconnor, right. thanks for your input.
04:44:52 <mun> roconnor, hi again. going back to FO/HO quantification, then is quantification over sets/predicates necessarily a HO feature? or the same situation as quantification over function holds for sets/predicates?
04:47:08 * hackagebot NanoProlog 0.1.1 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.1.1 (JurrienStutterheim)
04:55:23 <burbul> I'm a bit confused about the relationship between Monad and Control.Monad... is it just a interface/implementation split?
04:56:12 * hackagebot regex-genex 0.1.20110523 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.1.20110523 (AudreyTang)
04:56:28 <Botje> burbul: Control.Monad has some nice combinators that can be used with any monad
04:56:42 <Botje> I don't think you're supposed to use Monad anymore
04:56:52 <Botje> (the module, if that's what you meant)
04:57:12 <quicksilver> it's a historical naming thing, yes.
04:57:15 <dafis> Aye, it's just for H98 compatibility
04:57:17 <quicksilver> Monad is the old name (haskell98 name)
04:57:44 <burbul> i see... I was a bit confused because tutorials still refer to Monad, and Monad seems to simply import Control.Monad. Thanks again, guys!
04:59:19 <hpc> if it talks about Monad, it must be a really old tutorial
05:12:56 <COBOL2121> Hi, a quick question...
05:13:08 <COBOL2121> what OS do you all use for Haskell development?
05:13:24 <Axman6> there's plenty of people using Linux, OS X and Windows
05:13:55 <COBOL2121> Axman6, which one is best for staying up-to-date with the latest Haskell Platform?
05:14:08 <COBOL2121> Ubuntu version of Haskell Platform is very old for example
05:14:12 <Axman6> the platform is always released for all three at the same time
05:14:45 <roconnor> COBOL2121: why do you want to use the Haskell Platform?
05:14:58 <COBOL2121> roconnor, easiest for a beginner
05:15:18 <roconnor> easiest for what?
05:15:42 <COBOL2121> for getting started
05:15:54 <Axman6> COBOL2121: what OS do you like best?
05:15:58 <COBOL2121> "The Haskell Platform is the easiest way to get started with programming Haskell. It comes with all you need to get up and running. Think of it as "Haskell: batteries included""
05:16:08 <COBOL2121> Axman6, Ubuntu
05:16:11 <Axman6> because that's a much more important thing
05:16:14 <Axman6> then use ubuntu
05:16:21 <roconnor> to get started all you need to do is aptutite install ghc I think.
05:16:31 <COBOL2121> Ubuntu only has some old version from early 2010
05:17:23 <Axman6> then download the platform from the platform site and install that
05:17:35 <dafis> COBOL2121: as far as I remember, you can add more up-to-date debian repos to ubuntu
05:17:49 <COBOL2121> ok, I will investigate
05:17:51 <COBOL2121> thx all
05:20:00 <roconnor> I'd be inclined to ignore the haskell platform and just install libraries as you need them.
05:21:00 <Botje> COBOL2121: the oneiric repo already has haskell-platform 2011
05:21:56 <COBOL2121> Botje, oneiric is the next version of Ubuntu?
05:21:59 <roconnor> I don't really see a need for the HP on a system with a reasonable package management system.
05:22:33 <Botje> COBOL2121: yes. but you can tell apt to install only the haskell-platform from the oneiric repository.
05:22:48 <Botje> COBOL2121: you can get by with GHC and the libraries you need though
05:22:50 <roconnor> Botje: won't that end in disaster?
05:22:52 <Favonia> COBOL2121: Personally I installed GHC 7.0.3 from this PPA: https://launchpad.net/~someone561/+archive/ppa and then used cabal-install to get the remaining libraries.
05:23:04 <Botje> roconnor: as long as you don't dist-upgrade, no
05:26:11 <roconnor> Botje: he won't be able to install any other haskell packages no?
05:26:23 <roconnor> (from ubuntu)
05:26:39 <Jafet> Using your distro's repository precludes you from upgrading separately with cabal, doesn't it
05:26:40 <Favonia> COBOL2121: Haskell Platform is just GHC + some useful and common libraries. You can only have newer versions by this method, as long as GHC is updated.
05:28:09 <Botje> roconnor: iirc the haskell-platform package just depends on a whole lot of other packages
05:28:27 <Botje> so it should work pretty seamlessly
05:28:46 <Botje> of course this is not a guarantee of success :)
05:31:22 <Favonia> Jafet: I believe cabal install --user (user mode installation) should still work. Personally I avoid any potential problems by not installing any system-wise packages (except those which are bundled with GHC...).
05:43:20 <scottlad>  ./server soulacehosting.org
05:43:21 <scottlad> ./server soulacehosting.org
05:46:17 * hackagebot yesod-auth 0.6.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.6.0 (MichaelSnoyman)
05:46:19 * hackagebot yesod-core 0.8.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.8.2 (MichaelSnoyman)
05:46:21 * hackagebot yesod-form 0.2.0 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.2.0 (MichaelSnoyman)
05:48:18 * hackagebot hamlet 0.8.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.8.2 (MichaelSnoyman)
06:01:20 * hackagebot wai-handler-webkit 0.3.1 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-0.3.1 (MichaelSnoyman)
06:01:57 <Axman6> woah, sweet new package :O
06:02:19 <hpc> noWAI
06:02:54 <hpc> also, lol at no version of the package being able to build right on hackage
06:06:21 * hackagebot NanoProlog 0.1.2 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.1.2 (JurrienStutterheim)
06:08:03 <Axman6> hpc: it's highly unlikely that Qt isn't installed...
06:09:21 * hackagebot waitfree 0.0 - A wrapping library for waitfree comnputation.  http://hackage.haskell.org/package/waitfree-0.0 (YoichiHirai)
06:11:26 <Axman6> s/isn't/is
06:13:13 <dafis> s/unlikely/likely/
06:14:10 <Axman6> that too
06:28:24 * hackagebot levmar 1.1 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.1 (BasVanDijk)
06:50:26 * hackagebot regex-genex 0.1.20110524 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.1.20110524 (AudreyTang)
06:53:13 <identity_> Greeetings!
06:53:57 <identity_> I was wondering if someone could tell me what is the oldest version of glibc one can have for installing the ghc 7.x standalone binary, so that I may install the haskell platform?
06:56:00 <byorgey> identity_: the GHC 7.x download pages say "we're not sure what the minimum version required is".  If the GHC developers don't know then I doubt anyone else does =)
06:56:10 <maxnau> Guys, could somebody please give an advice. I'm reading chapter about functional parsers in Graham Hutton's book.There is an example which I try to load into ghci but get an error http://pastebin.com/RfeNnm9c. I don't know how to remedy this.
06:56:24 <Zao> byorgey: It's not horribly ancient though.
06:56:30 <Zao> byorgey: I ran into it recently, I believe.
06:57:01 <Botje> maxnau: your second 'item' needs to start at the same column as x and y
06:57:05 <byorgey> maxnau: you seem to have an extra 'item' on line 19
06:57:07 <Botje> right now it thinks you're doing x <- item item
06:57:20 <identity_> byorgey: Disappointing
06:57:35 <Zao> I think I was on Ubuntu Jaunty then.
06:57:44 <identity_> byorgey: Well, let us approach it differently then. What am I losing if I use, say, ghc 6.12.x instead of 7.x?
06:57:45 <byorgey> oh, right, maybe it is supposed to parse an item and throw it away, in which case Botje's advice is correct
06:58:44 <identity_> I'm out of the country for the nexst few months and I'm trying to get a haskell programming environment set up on a shell. It's debian, so it only has packages it downloaded through a wormhole whose other end is at ca. 1982
06:59:08 <maxnau> thanks, but the book says if the result produced by a generator is not required it can be abbreviated
06:59:18 <byorgey> identity_: mostly you are losing some advances/bugfixes in typechecking programs that use advanced type system features, and compatibility with a few newer packages
06:59:27 <byorgey> identity_: but on the whole I think it should be fine
06:59:28 <o-_-o> so the haskell diagrams EDSL, is it possible to render the diagram to an OpenGL buffer ?
06:59:46 <maxnau> and i tried z <- item. still get an error
07:00:05 <o-_-o> or even shared memory ? I see only renderToPng
07:00:22 <byorgey> o-_-o: there was a project to make an OpenGL backend a while ago, but it hasn't been kept up-to-date
07:00:35 <o-_-o> byorgey: yeah I saw that :-(
07:00:40 <identity_> byorgey: Hmm, alright. Thanks. I'll soothe my version epenis and try to use what is not newest
07:01:03 <byorgey> o-_-o: so at the moment it is not possible but I hope it will be eventually
07:01:12 <o-_-o> byorgey: but is it possible to write to shared memory and then I can use the shared memory to OpenGL texture buffer ?
07:01:23 <o-_-o> byorgey: ok
07:01:35 <byorgey> o-_-o: in principle there is no reason you couldn't do that
07:01:50 <byorgey> o-_-o: but there don't yet exist tools to let you do it easily
07:01:58 <o-_-o> byorgey: ok
07:02:05 <Botje> maxnau: does it still complain about x <- item item ?
07:02:13 <maxnau> http://pastebin.com/PWZYzN7P
07:02:19 <o-_-o> byorgey: where is the source code renderToPng ?
07:02:26 <byorgey> o-_-o: wait, renderToPng? which version are you using?
07:02:37 <o-_-o> http://byorgey.wordpress.com/2011/05/17/announcing-diagrams-preview-release/
07:02:46 <o-_-o> oh...you are the author :-(
07:02:52 <byorgey> hehe, yes =)
07:02:53 <o-_-o> :-( -> :-)
07:02:57 <maxnau> Botje, yes
07:03:15 <Botje> maxnau: hmm. actually. where is the >>= function defined for your Parser type?
07:03:30 <Botje> because right now it's using the ((->) r) monad
07:03:39 * quicksilver was about to make the same point.
07:03:49 <quicksilver> that's intended to be a parsing monad but there isn't a monad instance for it.
07:04:34 <maxnau> Botje, thanks
07:04:41 <byorgey> o-_-o: I am still not sure where you are seeing this 'renderToPng' function...
07:04:57 <o-_-o> ummm....
07:05:11 <identity_> Hmm. Anyone know which version the haskell platform 2010.2.0.0 comes with?
07:05:27 <Ke> of ghc?
07:05:27 <o-_-o> byorgey:
07:05:27 <identity_> got it.
07:05:29 <identity_> yeah
07:05:34 <o-_-o> byorgey: http://byorgey.wordpress.com/2008/04/30/new-haskell-diagrams-library/
07:05:35 <identity_> it's 6.12.3
07:06:15 <byorgey> o-_-o: oh! That is a very old version
07:06:39 <o-_-o> byorgey: I was looking for small programs to start with, the tic-tac-toe is huge
07:06:41 <byorgey> o-_-o: it has been completely rewritten since then =)
07:06:47 <o-_-o> byorgey: ah
07:06:59 <byorgey> o-_-o: check out http://projects.haskell.org/diagrams/gallery.html
07:07:02 <erus`> anyone else work in tech support on this channel?
07:08:00 <mun> hi
07:08:09 <mun> is checking for unprovability undecidable?
07:09:15 <byorgey> mun: it depends on what formal system you are talking about.  But for sufficiently expressive systems, yes.
07:10:39 <mun> right
07:13:14 <identity_> Oh man. Building the platform now. Haven't written Haskell in 3 months, but spent so many nights at sea fantasizing about some cool idea to implement in Haskell.
07:13:19 <identity_> I think I'm literally getting horny.
07:16:32 <blackdog> identity_: wait, literally at sea?
07:16:33 <mun> but if I have predicate A, how does one formally express that B is *not* a consequence of A? A --> ~B just asserts that not B is a consequence, which is a speical case of B is not a consequence.
07:16:48 <blackdog> identity_: when you're at sea you get horny for haskell??
07:17:17 <identity_> blackdog: I live in a country that is not my motherland. I am now in my motherland, however, working at sea
07:17:35 <identity_> And when you're getting mad from sleep-eat-work-eat-sleep 12-18 hours a day
07:17:58 <identity_> You fall asleep, wishing you were in front of your dual screen setup writing beautiful, elegant haskell
07:17:59 <blackdog> that still leaves 12-6 hours a day for haskell
07:18:11 <blackdog> :) so what're you gonna implement?
07:18:21 <identity_> oh, I mean, work @ 12-18 hours of day
07:18:27 <identity_> you sleep and eat hte rest
07:18:34 <blackdog> identity_: yeah, i'm just being obtuse
07:18:39 <identity_> I have a few ideas. Not sure.
07:19:23 <mun> i guess this is the same as expressing how A --> B cannot be proved.
07:19:43 <identity_> mun: Exactly. Except at sea.
07:20:18 <mun> identity_, but then how does one express "A --> B cannot be proved"?
07:21:11 <identity_> mun: Sorry, too busy conquering the seven seas.
07:21:24 <o-_-o> byorgey: so diagrams can render into a cairo surface ?
07:22:26 <dmedvinsky> mun: ¬(A → B) = ¬(¬A ∨ B) = A ∧ ¬B
07:22:32 <byorgey> o-_-o: yes.  Currently the Cairo backend gives you only an IO action that writes the output to a file, but it would be a trivial tweak to have it also return you a  Render ()  action which you could use to render to a cairo surface instead
07:22:53 <o-_-o> byorgey: ok
07:22:55 <byorgey> o-_-o: and in fact we were planning to do this anyway
07:23:13 <o-_-o> byorgey: because I found this http://fhtr.blogspot.com/2009/06/haskell-opengl-utilities.html
07:23:45 <byorgey> o-_-o: ah, neat
07:24:00 <o-_-o> byorgey: where there is code to convert Cairo Ptrs to texImage2D, so it should be possible...
07:24:07 <mun> dmedvinsky, right. then if it's A & ~B, then why is proving this undecidable?
07:24:21 <mun> dmedvinsky, in a sufficiently expressive logic, that is.
07:24:45 <byorgey> o-_-o: if you feel like trying to make this tweak yourself, go right ahead, the code is in  http://patch-tag.com/r/byorgey/diagrams-cairo/
07:24:48 <byorgey> o-_-o: you can send me a patch
07:25:06 <byorgey> o-_-o: or if you don't mind waiting I can do it for you but not until tomorrow
07:25:08 <o-_-o> byorgey: I just started haskell so don't expect anything yet ! :-)
07:25:12 <byorgey> ok =)
07:25:28 <o-_-o> byorgey: sure...I can wait quite a bit of time
07:25:38 <o-_-o> I am still in lists and strings in the book
07:25:52 <byorgey> hehe, ok =)
07:27:09 <kluge> mun, you are talking about two different things.  proving the negation of a statement is not the same as proving that a statement is unprovable
07:30:13 <mun> kluge, so, if T is predicate (a conjunction of axioms) and t is a particular theorem, T --> t is equivalent to saying t is a theorem of T, right?
07:30:44 <kluge> yes
07:30:45 <mun> kluge, by that, to say that it's unprovable that t is a theorem of T, would it be ~(T --> t)?
07:30:51 <kluge> no
07:31:18 <dmedvinsky> mun: the statement can be correct yet unprovable
07:31:24 <kluge> it would be either showing that it is equivalent to another axiom in T, or that T->t AND (~T)->t
07:31:24 <roconnor> If T is a set of axioms and t is a theorm of T we usually write  T |= t
07:31:26 <byorgey> mun: only if the formal system is negation-complete.
07:31:30 * hackagebot time-recurrence 0.1.1 - Generate recurring dates.  http://hackage.haskell.org/package/time-recurrence-0.1.1 (ChrisHeller)
07:31:48 <roconnor> or T |- t
07:32:30 <byorgey> mun: in sufficiently expressive systems, as shown by Goedel, there can exist sentences t for which neither t nor ~t are provable
07:33:06 <byorgey> so just because (T --> t) is not a theorem does not mean that ~(T --> t) must be a theorem
07:36:10 <mun> right
07:42:39 <mun> so in terms of entailment, if t is unprovable in T, T |+ t, is it then equivalent to T |- t AND ~T |- t?
07:43:14 <roconnor> no
07:43:49 <roconnor> T |+ t  means ~(T |- t) by definition
07:44:03 * zmv doesn't understand anything.
07:44:36 <zmv> damned theorems :P
08:03:53 <mun> roconnor, right. so, ~(T |- t) translates to ~T --> t AND T --> t, but then what does it mean by negating the theory T. is ~T T with at least one of the axioms negated?
08:06:01 <roconnor> no
08:06:45 <roconnor> ~(T |- t) doesn't translate to anything.  In general theories cannot be negated (unless they have finite axioms).
08:11:28 <acowley> roconnor: what do you mean translate? I would have read that as something like, "t is not derivable from T."
08:12:28 <k0ral> I need a name for my browser written in haskell, before uploading it to hackage
08:12:40 <k0ral> as I'm very bad at inventing names
08:12:46 <k0ral> would you have suggestions ?
08:14:08 <zenzike> k0ral: like hinternet-hexplorer?
08:14:36 <nlogax> hrome
08:14:41 <k0ral> zenzike: now I know I was right not to say "I take everything you would suggest"
08:14:43 <k0ral> :)
08:14:44 <ville> k0ral: frank
08:15:01 <roconnor> http://online-generator.com/name-generator/project-name-generator.php
08:15:01 <k0ral> hrome is nice :)
08:15:03 <wjt> Lens?
08:15:09 <roconnor> suggests calling it Ghastly Butter
08:15:22 <ville> don't use frank, I've libfrank in the works which is C++ though,
08:15:29 <k0ral> well, a single name is enough
08:15:31 <nlogax> lambdafox
08:15:34 <k0ral> something short
08:15:35 <nlogax> :/
08:15:44 <Silvah> Call it "".
08:15:50 <Silvah> That is, an empty string.
08:15:56 <Silvah> I think it's short enough.
08:16:02 <ville> i_watch_pr0n
08:16:05 <k0ral> nlogax: I could have juridical problems with mozilla :)
08:16:23 <k0ral> ville: too long :p
08:16:24 <sm> k0ral: how long will this project last ?
08:16:44 <ville> pr0nfiend
08:17:07 <k0ral> sm: no one could say, but I'm thinking about using it in a daily basis so...
08:17:16 <Silvah> ville: "fiend"? :>
08:17:42 <Silvah> ville++
08:18:22 <k0ral> hrome... do you think I could have troubles with Google if I name it hrome ?
08:18:27 <nlogax> honqueror
08:18:54 <ville> glad C or C++ programs don't all begin with C
08:19:23 <sm> k0ral: any unique features as a browser ?
08:19:24 <k0ral> k I'm committing honqueror
08:19:31 <k0ral> sm: uzbl-like
08:19:46 <k0ral> https://git.twyk.tk
08:19:52 <k0ral> see by yourself
08:20:01 <k0ral> haskell-browser repository of course
08:23:23 <sm> haste ?
08:23:36 * sm gives up.. tough one
08:24:09 <k0ral> why giving up ? haste is quite good
08:24:22 <sm> well that's my best/only shot :)
08:25:32 <sm> but http://sourceforge.net/projects/haste-ide/ is also haskell. But it's dead
08:25:37 <ben> hirefox clearly
08:25:58 <ben> it's a word! more or less!
08:26:49 <sm> hustle
08:27:03 <k0ral> hmmm
08:28:02 <k0ral> I wouldn't like to stick to another browser's name actually
08:28:15 <k0ral> not that mine is an extraordinary one
08:28:44 <k0ral> but it's not really fair
08:29:11 <ben> I'm sure it would be more understood as an injoke anyway
08:29:42 <ben> Just name it after your favourite obscure animal
08:29:45 <xplat> is there a good library on hackage for streaming generation of xml?
08:29:50 <sm> husky
08:30:03 <k0ral> sm: lol
08:30:05 <sm> must.. stop
08:30:14 <k0ral> sm: still thinking again and again
08:30:57 <k0ral> damn I hate naming choice
08:31:54 <xplat> name for a browser in haskell ... what is special about it?
08:32:01 <k0ral> nothing
08:32:02 <Silvah> Bubble eye?
08:32:05 <Silvah> Star-nosed mole?
08:32:06 <siracusa> @fresh
08:32:06 <lambdabot> Haeh
08:32:15 <xplat> why are you using it instead of firefox?
08:32:20 <k0ral> just have to choose one right now
08:32:37 <Silvah> xplat: the fact that Firefox sucks is good reason?
08:32:38 <k0ral> xplat: I am using uzbl
08:32:47 <dankna> you don't have to choose the name now.  you can call the directory "browser" and rename it when it actually works.
08:32:52 <xplat> and why did you bother to write it?
08:33:10 <Silvah> dankna: from what I understood, it works already.
08:33:26 <k0ral> xplat: but there are some features I wanted to add to uzbl, I then went into their code but figured out it would be so easier if coded in a more modern language
08:33:42 <ben> huzbl!
08:34:39 <sm> that's the convention alright
08:35:00 <sm> I was in the same situation and should have called my thing notc++ledger
08:35:09 <joe6> k0ral, do you like uzbl? it seems very interesting. I use links2 as an alternative to firefox
08:35:17 <k0ral> what about something that is NOT a joke, either a reference to another browser, or any existing word ?
08:35:22 <sm> k0ral: have you looked at manatee ?
08:35:40 <xplat> webscanner?
08:35:50 <k0ral> joe6: I like its philosophy of doing only one thing
08:36:15 <k0ral> sm: no, I'm googling it
08:36:17 <joe6> k0ral, have you tried links2
08:36:20 <sm> http://haskell.org/haskellwiki/Manatee
08:36:46 <k0ral> joe6: you're talking about the console-based browser, right ?
08:36:58 <xplat> (referring to a use of 'scanner' in old SF where they were people who had their body separated into many tiny boxes that were externally connected so they could survive in space)
08:37:06 <sm> and http://hackage.haskell.org/package/manatee-browser
08:37:07 <joe6> k0ral, links2 is not console based . it opens up a gtk window.
08:37:21 <siracusa> h-bro
08:37:34 <k0ral> xplat: I bothered writing it because I didn't find anything like that
08:38:27 <xplat> manatee is sort of the opposite of uzbl :)
08:38:28 <k0ral> xplat: what's the link with a scanner here ?!
08:38:52 <k0ral> siracusa: hbro (without hiphen) sounds good to me
08:39:31 <xplat> k0ral: the connection with 'scanner' is a uzbl-like browser being divided into a lot of little 'boxes' with a single purpose that are externally connected into an overall browsing system
08:40:31 <k0ral> xplat: oh
08:40:46 <k0ral> xplat: you went far far away :)
08:41:02 <k0ral> (in a galaxy far far away...)
08:41:41 <k0ral> manatee seems indeed to be the contrary to the "one task one app" philosophy, isn't it ?
08:41:49 <k0ral> sm: ^
08:42:15 <xplat> i'm not very satisfied with existing browsers either, but none of the alternative browsers seem to address many of my complaints
08:42:47 <k0ral> same here
08:42:50 <rostayob> firefox + pentadactyl is really nice imho
08:42:55 <sm> you could be right, I had the impression that within the manatee environment it is component-oriented, you can pipe/plug things together
08:43:14 <sm> anyway it's another gtk-based browser and should be interesting
08:43:16 <sm> might
08:43:25 <k0ral> look at their code ? :)
08:43:33 <xplat> uzbl breaks down the UI into nice modular pieces, but the page-rendering component is still just a giant ball of crap
08:43:40 <sm> I have not, but I trust him 100% :)
08:44:18 <k0ral> well, something I definitely don't adhere with in uzbl is the fact that the developers wanted to have the least dependencies possible
08:45:05 <k0ral> some parts of their code are really heavy while using a library could have made things more extensible, lighter and more readable
08:45:40 <k0ral> I'm going hbro for my browser
08:45:57 <k0ral> thank you siracusa
08:46:13 <siracusa> np :-)
08:46:35 <xplat> so, repeating an earlier question: is there a good library on hackage for streaming generation of xml?
08:47:21 <xplat> i want to generate some xml, do some IO, generate more xml, etc.  i don't want to hold the whole thing in memory since it's going to be huge
08:47:26 <Favonia> k0ral: I've heard uzbl is from lolspeak. maybe you can find some words in lolspeak dictionary? lol
08:47:27 <k0ral> joe6: trying links2 and giving you feedback then
08:48:03 <xplat> i don't really want to abuse unsafeInterleaveIO either
08:48:11 <Favonia> k0ral: oh I'm sorry. I missed your last message.
08:48:20 <joe6> k0ral, glad you could make up the time to try it.
08:48:30 <joe6> k0ral, it is pretty fast, imho.
08:48:57 <k0ral> Favonia: no problem, didn't even know lolspeak, giving it a try anyway :)
08:49:49 <k0ral> joe6: there's no package for my linux for links2, gotta be a rare browser :p
08:50:31 <xplat> there is for ubuntu
08:50:57 <joe6> k0ral, interesting. i use it on debian
08:51:04 <joe6> k0ral: and I got it from apt.
08:51:13 <joe6> k0ral, what distro are you on?
08:51:15 <lpsmith> out of curiosity,  does runghc actually complie something first or does it interpret the file?
08:51:16 <k0ral> no package for archlinux
08:51:33 <k0ral> I mean not even in AUR
08:52:49 <joe6> k0ral, oh, ok. i hear w3m is better than links2.
08:53:04 <acowley> xplat: I don't see why you would need unsafeInterleaveIO. But I'm not really sure what I'd want from a library to help me with XML generation. Parsing structured text is designed to give me a structure I can work with in a programming language. But if I'm generating text, I've already got the structure to walk over.
08:53:08 <k0ral> joe6: read descriptions of links2, it's not what I'm looking for
08:53:16 <k0ral> Iread *
08:53:19 <k0ral> I read*
08:53:30 <joe6> k0ral, oh, ok.
08:53:34 <xplat> acowley: i want to product xml that is well-structured and properly escaped
08:53:40 <k0ral> I'm looking for something highly configurable
08:53:40 <xplat> *produce
08:54:05 <k0ral> I mean: I need to customize callbacks in various situations
08:54:09 <xplat> that is what i want out of a library here
08:54:23 <acowley> verifying well-structured is tough if you want streaming output
08:55:02 <acowley> escaping is a good point, and for that you can probably find something in one of the text, json, html, etc. libraries
08:55:11 <xplat> acowley: some kinds of structure (like tags having closing >) are easy, assuming you don't need to stream individual open and close tags (which i don't)
08:55:29 <xplat> even higher-level structure can have some support when streaming
08:56:30 <acowley> I guess the issue is that there's usually a big divide between approaches that keep the whole document in memory for validation, and those that stream by giving up verification for constant memory
08:57:11 <sm> xplat: isn't the the new xml library recently announced on list streaming-capable
08:57:32 <xplat> sm: is that xmlgen?
08:57:44 <sm> yes
08:59:17 <xplat> it sounds like it should be streamable from the description, but when i look at the docs i can't see how streaming could work
09:00:30 * sm thought it was announced on list, but can't find it
09:00:55 <dankna> I wound up doing my own
09:01:02 <dankna> for Jabber read/write
09:01:08 <dankna> I'd share it, but it's not really release quality
09:01:40 <dankna> in my case it was clearly necessary though because there's /definitely/ nothing in Hackage (or wasn't at that time) that does streaming read
09:02:04 <joe6> k0ral, uzbl rendering is pretty impressive. beats links2
09:02:05 <Favonia> there is a package for Jabber, asaik
09:02:19 <dankna> Favonia: there wasn't when I did mine :) this was a year or two ago
09:02:21 <xplat> joe6: it should be, it reuses webkit
09:02:25 <k0ral> joe6: you never gave it a try before ?
09:02:52 <joe6> .k0ral,
09:03:02 <Favonia> dankna: ah I see. good work then :P
09:03:04 <joe6> k0ral, nope, first time trying it.
09:03:10 <dankna> thanks hehe
09:03:12 <xplat> dankna: borrowing a non-release-quality library is probably at least as nice as writing my own
09:03:16 <rothwell> is there even a usable jabber library in hackage that can connect to a server that requires TLS, without bursting into flames?
09:03:32 <joe6> k0ral, cannot navigate with the keyboard?
09:03:38 <shapr> rothwell: Which ones have you tried?
09:03:44 <dankna> xplat: well, I'm willing to share if you really want.  let me split it into its own repo and upload it.
09:03:49 <rothwell> shapr: well, last year i tried them all!
09:03:51 <shapr> rothwell: Also, got pix of flames? Sounds pretty :-)
09:03:56 <xplat> dankna: cool, thanks
09:04:09 <rothwell> shapr: unfortunately not... i might be able to improvise with some ethanol...
09:04:24 <acowley> dankna: I thought tagsoup could do streaming read?
09:04:32 <rothwell> this isn't a haskell problem, specifically... i tried every library i could find
09:04:43 <rothwell> eventually managed to find ONE perl library that could do it, and then that broke months later
09:04:47 <xplat> acowley: that's html, not xml ...
09:04:48 <Favonia> xplat: I think unsafexxxIO has been used to implement hContents... maybe it is inevitable?
09:05:08 <dankna> acowley: not that I'm aware, although possibly?  the name suggests that it's designed for invalid input, and enforcing validity is something I typically want
09:05:19 <quicksilver> dankna: you can't enforce validity and stream.
09:05:32 <dankna> quicksilver: well, true.  sorry, I meant well-formedness.
09:05:44 <quicksilver> you can't even enforced well formedness and stream
09:05:51 <dankna> eh?  you can enforce most of it
09:05:55 <quicksilver> unless by enforce you mean "throw an error later, when you've already done the work"
09:05:59 <xplat> you can enforce output validity or well-formedness and stream
09:06:03 <shapr> rothwell: I don't know, but if you find out, I'd be interested....
09:06:21 <dankna> there may be some parts of it that you can't, but you can at least enforce conformance to the grammar
09:06:38 <Favonia> xplat: oops I meant hGetContents
09:06:51 <xplat> and all of input well-formedness except 'all tags must eventually close'.  well, you can do that too but it's not as useful.
09:06:58 <k0ral> joe6: yes you can
09:07:18 <k0ral> joe6: press "fl"
09:07:26 <k0ral> joe6: like "follow link"
09:07:26 <joe6> k0ral, ok. thanks.
09:07:47 <xplat> you can enforce a lot of validity stuff too, especially if you allow O(depth) resource use instead of constant
09:08:11 <xplat> and that can get you more timely feedback than WF
09:09:01 <quicksilver> agreed.
09:09:06 <quicksilver> And, yes, tagsoup doesn't do any of that.
09:09:19 <joe6> k0ral, any good tutorial about it? I cannot seem to find much on uzbl.org. something that can get me started easily. basic commands: such as the keyboard binding to open a new url and stuff like that.
09:09:22 <quicksilver> however, if you trust your input it does do streaming at least :)
09:09:43 <quicksilver> there is a version of haxml which does "lazy parsing" which gives you a kind of streaming.
09:10:03 <identity_> Hmm. It wasn't possible to make cabal fetch missing dependencies automatically?
09:10:20 <dankna> darcs get http://dankna.com/software/darcs/direct-streaming-xml/
09:10:24 <dankna> this is one source file, about 400 lines
09:10:45 <dankna> it probably doesn't implement all of XML, and it doesn't even have a .cabal file because I hadn't gotten addicted to Cabal yet when I wrote it
09:10:55 <dankna> but it /might/ be easier than starting over
09:10:57 <dankna> it uses Parsec, btw
09:11:19 <dankna> anyway, if you make anything useful out of it, I'd be interested in working it up for a real release
09:11:24 <xplat> i'm probably not using the parsing side at all, just generation, at least for now
09:11:27 <dankna> nodnod
09:11:28 <k0ral> joe6: let's talk about it in a dedicated chan
09:11:43 <dcolish> whats a good library for building restful api clients?
09:12:01 <xplat> dcolish: i've heard http-enumerators is good
09:13:02 <dankna> do tell me how you like it (or hate it), I'm always interested in feedback.  even though, as I say, my excuse-in-advance is that this is old code and I wasn't planning to show it to anybody :)
09:14:02 <xplat> :) okay
09:14:07 <dcolish> oh nice, i'm so tired of using curl
09:20:11 <Eduard_Munteanu> Regarding the unsafeInterleaveIO stuff, I still don't really get why execution doesn't follow evaluation. From all languages, I'd expect Haskell's IO to be lazy by default and go strict by seq-ing.
09:20:38 <Eduard_Munteanu> Instead there's that magic stuff going strict->lazy via unsafeInterleaveIO :/
09:20:47 * sm used http-enumerator for a restful client.. it can talk ssl
09:22:36 <c_wraith> Eduard_Munteanu: it's because IO normally introduces a (faked) data dependency, such that the second argument to (>>=) depends on the first having been executed.
09:22:52 <c_wraith> Eduard_Munteanu: this is generally important for IO, because it allows external data dependencies.
09:23:12 <c_wraith> Eduard_Munteanu: if you write to a file, then read from it, you expect that what you've written will be read
09:23:33 <c_wraith> Eduard_Munteanu: but there's no haskell data dependency there, it's external to the system
09:23:36 <Eduard_Munteanu> Oh.
09:24:24 <dolio> There is a Haskell data dependency way down in the GHC implementation.
09:24:57 <dolio> Because the 'functions' for reading a file are opaque. You don't know that it passes the same token back to you.
09:25:06 <Eduard_Munteanu> Yeah, then I suppose the lazy IO model is just evil.
09:25:08 <dolio> And writing a file.
09:25:46 <dolio> Token passing is a poor model, though.
09:26:07 <dolio> It works as an implementation, I guess, but it doesn't make a lot of sense.
09:26:48 <c_wraith> hence why I called it a fake data dependency
09:27:46 <c_wraith> it does work as a model of ST, though!
09:28:03 <dolio> Yes.
09:28:21 <dolio> You never expect to have infinite productive loops in ST.
09:28:57 <dolio> Where the loop "does something" forever, but you never want the result.
09:29:05 <k0ral> quick question: what interval of versions should I use in my cabal package for build-depends on base ?
09:29:24 <c_wraith> k0ral: I mostly use == 4.*
09:29:41 <c_wraith> unless there's something specific from a later version.
09:29:50 <dolio> < 5 is probably fine.
09:30:01 <dolio> And go however early you've tested with, if you want.
09:30:03 <c_wraith> you need a lower bound on base to shut up compiler warnings on 6.12, though
09:30:37 <k0ral> c_wraith: I need it to shut up hackage too :)
09:30:45 <k0ral> thanks for the answer
09:31:15 <jmcarthur> i usually only specify major version numbers i have actually tested
09:31:25 <jmcarthur> but that's not the common thing, i think
09:31:52 <c_wraith> if there was a testing infrastructure for things with a lot of dependencies, it'd help a lot
09:32:03 <jmcarthur> hmm
09:32:17 <Eduard_Munteanu> So you can't have explicit data dependencies, like hGetContents :: Handle -> IO [Dep -> Char]?
09:32:24 <jmcarthur> like something that builds against all matching combinations of dependency versions and tests automatically?
09:32:31 <c_wraith> yeah.
09:32:41 <jmcarthur> would be nice
09:32:50 <c_wraith> I mean, maybe not even worry about tests, as a first pass.  Just checking to see if it builds would be nice
09:33:00 <c_wraith> though running a test suite would be even better
09:33:21 <Eduard_Munteanu> So when you write something to a file, you get a new version, hence a new dependency you can pass into pure functions.
09:33:22 <dolio> The dependency situation is kind of poor, although I don't really know how to fix it.
09:33:25 <osfameron> is the red-black algorithm updated with "double-black" and "negative-black" a good idea? http://matt.might.net/articles/red-black-delete/
09:35:01 <Athas> Hmm, permutation parsers...
09:35:02 <Athas> Interesting.
09:35:06 <Athas> Looks like just what I need!
09:35:56 * hackagebot hbro 0.1 - A suckless minimalist KISSy browser  http://hackage.haskell.org/package/hbro-0.1 (koral)
09:36:16 <rothwell>  \o/
09:36:27 <k0ral> :)
09:36:36 <Eduard_Munteanu> It also makes it obvious that you don't get different values different times you call it.
09:36:39 <mornfall> Gtk strikes again.
09:36:54 <mornfall> Any difference from surf? :)
09:36:58 <rothwell> k0ral: didn't really mean to single you out... it's a pretty ironic abuse of the word, and it's all over the web
09:37:14 <rothwell> i mean, if there's any word you don't want to be sticking unnecessary parts on, it's "minimal"
09:38:10 <k0ral> oh
09:38:50 <rothwell> it's a bit of an in-joke here... we like to use "minimalisticalistically"
09:38:51 * BMeph has always preferred avoiding long words for...diminutive ones. ;)
09:39:09 <k0ral> really sorry
09:40:21 <k0ral> I can't really make a new version just to remove "ist"
09:40:25 <mornfall> :)
09:40:35 <k0ral> you'll suffer it for some time
09:40:41 <rothwell> hehe
09:40:43 <k0ral> till I upload a real new version
09:40:48 <rothwell> minimalist is fine
09:43:04 <mornfall> k0ral: You may as well upload again, since it is missing a module (Gui).
09:43:20 <mornfall> (So it won't build.)
09:43:48 <k0ral> what ?
09:43:55 <k0ral> !
09:43:56 <mornfall> Doing a cabal configure/build in an unpacked tarball helps.
09:44:00 <mornfall> Before uploading.
09:44:01 <mornfall> :)
09:44:50 <k0ral> oh oh oh
09:44:55 <k0ral> 3 files are missing actually
09:44:58 * hackagebot egison 0.1 - Programming Language Egison  http://hackage.haskell.org/package/egison-0.1 (SatoshiEgi)
09:45:07 <k0ral> only Main.hs was included
09:45:34 <k0ral> shall I list all files in the .cabal file ?
09:45:46 <k0ral> thought it was smart enough to detect all
09:46:32 <mornfall> Yes, you have to.
09:46:39 <mornfall> As other modules, presumably.
09:46:45 <mornfall> (Since you aren't exporting a lib.)
09:46:59 <sm> k0ral: other ways to check before a hackage upload: cabal haddock; cabal sdist; cabal upload --check -v3; rm -rf cabal-dev && cabal-dev install
09:48:30 <k0ral> I did haddock
09:48:34 <k0ral> sdist
09:48:39 <k0ral> not the following ones
09:49:13 <sm> for superior quality, you could also add ghc-options: -Wall -Werror (or so) to the cabal, and run hlint on your code
09:49:46 <sm> and run your tests of course
09:49:57 * sm has uploaded a few broken packages
09:49:58 * hackagebot hsx-jmacro 6.0.2 - hsx+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-6.0.2 (JeremyShaw)
09:50:33 <k0ral> did hlint
09:50:38 <k0ral> used -Wall
09:50:50 <k0ral> and haven't got tests yet
09:50:51 <DevHC> oh lookey, i seem to have submitted the "constructor renaming" ticket to the wrong project
09:50:58 * hackagebot hbro 0.1.1 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.1.1 (koral)
09:50:59 <DevHC> any way to "move" it?
09:51:14 <k0ral> rothwell: do you feel better ? ;)
09:51:37 <rothwell> k0ral: yes!
09:52:08 <k0ral> really like this cabal tool
09:53:41 <k0ral> I really need to talk to a pro webkit-haskell user
09:53:51 <k0ral> -user +programmer
09:53:57 <k0ral> is there any ?
09:54:54 <shachaf> k0ral: I use both Webkit and Haskell, though not simultaneously. Does that count?
09:55:02 <k0ral> shachaf: I'm afraid not
09:55:39 <k0ral> I have questions about the haskell binding of webkit
09:55:57 <k0ral> which seems to lack some features that I used to see in other bindings
09:56:14 <k0ral> so now I'm stuck in hbro's development
09:58:16 <sm> why does cabal not like constraints on Cabal ? eg  --constraint 'Cabal > 1.9' -> "There is no available version of Cabal that satisfies >1.9". Both 1.8 and 1.10 are installed
09:59:28 <k0ral> maybe 1.10 isn't interpreted as greater thant 1.9
09:59:31 <k0ral> than*
09:59:37 <Peaker> lpsmith: http://hpaste.org/paste/46964/sieve_of_eur_with_st_unboxed#p46966 <-- with bitmaps
09:59:50 <sm> maybe, but I think cabal is smarter than that
09:59:56 <identity_> http://hackage.haskell.org/packages/archive/tagsoup/0.12/doc/html/Text-HTML-Download.html <-- link is dead. Anyone happen to know if there's some site with that documentation?
10:00:02 <Saizan> 1.10 is greater than 1.9
10:00:04 <identity_> Looks like it's an addition to allow you to download pages automatically
10:00:07 <identity_> which sounds beautiful
10:00:16 <sm> and --constraint 'Cabal==1.8.*' fails similarly
10:00:18 <k0ral> Saizan: indeed, but maybe cabal isn't smart enough
10:00:29 <Saizan> k0ral: i meant for cabal
10:00:32 <xplat> what's the easiest way to read a bunch of NUL-terminated strings from a file with enumerators?
10:00:34 <k0ral> Saizan: ah
10:00:40 <navaati> hello
10:00:50 <identity_> Hmm. Guess he didn't add it yet
10:01:01 <navaati> are there news about porting gtk2hs to gtk3 ?
10:01:24 <xplat> (i usually use iteratee but i want to use a library that only supports enumerators)
10:01:39 <Saizan> sm: do you have Cabal as a build-depend (or transitively) are you just trying to control which version of Cabal to use for Setup?
10:01:47 <lpsmith> Peaker:  you could mark each composite with a list of primes that divide it,  but it's more space efficient with better memory locality to mark each composite with one prime.
10:01:52 <zygoloid> claim: the ST monad cannot be implemented in haskell'10 (without using the FFI). anyone have a proof or counterexample?
10:01:53 <sm> Saizan: the latter
10:02:10 <lpsmith> You can use that to efficently factor any number in the sieve and then get all your primes. :)
10:02:13 <Saizan> sm: then it's --cabal-lib-version=
10:02:37 <Peaker> xplat: Data.Enumerator.Binary.takeWhile (/=0) ?
10:02:45 <sm> I'm trying to install glade (to test k0ral's thing) and now I notice this "warning Setup.hs is guessing the version of Cabal. If compilation of Setup.hs fails use -DCABAL_VERSION_MINOR=x for Cabal version 1.x.0 when building (prefixed by --ghc-option= when using the 'cabal' command)"
10:03:08 <sm> and your suggestion sounds nicer. I'm not sure why any of this is required
10:03:08 <Peaker> xplat: ann replicateM on that if you need, of course
10:03:55 <lpsmith> On the other hand,  the act of factoring a number using such a data structure isn't so memory-local;  an array of factors could be better from that regard.
10:03:59 <Saizan> sm: --ghc-option=-DCABAL_VERSION_MINOR=10 sounds nicer to be
10:04:19 <Saizan> *me
10:05:20 <xplat> lpsmith: it's very rare to need more than a few wide-area accesses though if you store the largest prime
10:05:22 <sm> so it looks like glade (maybe other gtk packages) have a custom setup that builds Gtk2HsSetup that depends on Cabal 1.89
10:05:23 <sm> 1.8
10:05:44 <xplat> lpsmith (since you very quickly get into the first page at every cache level)
10:05:57 <Saizan> sm: no
10:06:04 <lpsmith> xplat: that's a good point
10:06:45 <Saizan> sm: it has a Gtk2HsSetup which has to guess the Cabal version depending on the ghc version, because the APIs are different
10:06:56 <lpsmith> On the other hand,  if you store the smallest prime you get a more space-efficient structure.
10:07:09 <xplat> yes
10:07:31 <Saizan> sm: if you have a newer Cabal then it'll guess wrong and needs that hint
10:07:37 <xplat> you can get even more space-efficient by special-casing a few of the smallest primes though
10:08:17 <xplat> 2 alone saves you a lot of space
10:08:37 <sm> well it's not working too well.. but your hint gets Setup compiling at least, thanks
10:08:37 <xplat> and you can factor out the maximum number of 2s using simple bit-manipulation
10:09:13 <Saizan> sm: you need to cabal install gtk2hs-buildtools too
10:10:15 <k0ral> sm: sorry for all the inconveniences
10:10:36 <xplat> for fixed-width numbers in the sieve storing the smallest prime divisor can't save any significant space anyway
10:11:00 * Saizan can't build webkit
10:11:08 <xplat> because you can end up with a largest and smallest divisor that are both around the square root
10:11:43 <xplat> whereas skipping even numbers saves half your space
10:11:58 <hpc> Saizan: do what the devs do: add features until it compiles ;)
10:11:59 <Jafet> I started implementing a sieve of Atkin once but got distracted by premature optimization and never finished
10:12:15 <sm> Saizan: I had that, I have some normal cabal incompatible packages issue now, probably needs a total reinstall or use of cabal-dev
10:13:02 <sm> k0ral: alas installing haskell gtk apps is usually hard, I just thought I'd test my setup
10:13:08 <ClaudiusMaximus> would this work in GHC to make my code less slow even if A and B are in different packages?   module A (f) where {-# INLINABLE f #-} f :: SomeClass r => r -> Int ; f = ...  ; module B (module A) where import A ; {-# SPECIALIZE f :: SomeType -> Int #-}
10:13:44 <Saizan> webkit wants System.Glib.GString, which doesn't seem to be anywhere, maybe i've the wrong gtk version
10:14:12 <xplat> webkit is such a degenerate :-þ
10:14:15 <k0ral> sorry brb
10:15:37 <k0ral> well, if you give me an alternative to webkit that is standard compliant and has haskell binding
10:15:49 <k0ral> would be really happy to get rid of webkit
10:16:23 <k0ral> but still, I didn't have much troubles installing it
10:20:19 <Saizan> System.Glib.GString seems to be available only in the darcs version of glib, webkit-0.12.1 builds fine
10:20:19 <xplat> i was just making a GString joke :)
10:20:48 <xplat> i don't like webkit, but it's not *worse* than its competitors, particularly
10:21:17 <xplat> that's just an 'everything sucks' kind of category
10:21:42 <acowley> xplat: tagsoup is for XML, too
10:22:44 <Saizan> ok, hbro at least it's not modal so it's less annoying than uzbl :)
10:25:40 <k0ral> modal ?
10:25:48 <k0ral> ah
10:25:50 <k0ral> well
10:26:08 <k0ral> it has a drawback then
10:26:16 <k0ral> when you focus a form entry
10:26:24 <k0ral> I've not found a way to unfocus it
10:27:04 <identity_> Anyone familiar with tagsoup that knows if there's some easy way that I'm not seeing to grab only certain tags from a list of tags?
10:28:35 <acowley> filter
10:28:43 <identity_> Yeah, that's what I'm using
10:28:49 <acowley> or, if the subsequent context is important, sections
10:29:01 <identity_> just wondering if I'm misunderstanding the wording of any of the functions
10:29:08 <identity_> but the types are unambiguous I guess
10:29:11 <Athas> Is it possible to use GHC with other C libraries than glibc?
10:29:46 <dankna> Athas: only if it's compiled against them from the start, I believe
10:30:21 <Saizan> k0ral: true
10:31:54 <ClaudiusMaximus> is there a way in GHC to get a concise list of which functions have been specialized to which types?
10:32:37 <Athas> dankna: oh, that's perfectly fine.  Do you know whether that process is documented?
10:35:19 <dankna> Athas: I don't think it is, although you might check the wiki for how to build on Solaris, since the situation with regard to cc and libc there is complicated
10:35:37 <dankna> Athas: In princple, you shouldn't have to do anything special if the libc you want is the one that's found with -lc
10:36:08 <dankna> Athas: If you do have to pass flags to the C compiler to find the appropriate libc, read the wiki docs on the build system in general, particularly on options you can put in build.mk.
10:36:20 <k0ral> Saizan: this is one of the things I've not found in haskell bindings while I know how to do in C binding
10:37:35 <Athas> dankna: I see.  Thank you.
10:37:40 <dankna> Athas: Sure thing.
10:45:23 <Saizan> k0ral: if you find manateelazycat here you should ask him how to add that to the bindings :)
10:56:36 <stoneferry> Hi all, does anyone know a good online website that would describe what you need to do to create a Windows event log with Haskell?
10:56:42 <stoneferry> Or a book...
10:58:10 <Jafet> You can be the first to write one!
10:58:24 <hpc> event log as in the system event log?
10:58:42 <stoneferry> Application or security...
10:58:46 <stoneferry> Not likely I'm at 101 stage right now
10:58:58 <stoneferry> Application would go off a windows service...
10:59:40 <stoneferry> There's a good book with python that goes into Win32 programming and how to do this sort of stuff, although you can't compile with python, hence why I'm looking into haskell
10:59:54 <stoneferry> I'm seeing that in this case the Win32 side of it isn't too well supported though
11:00:02 <KirinDave> stoneferry: What you'll want to do is understand the ffi
11:00:43 <KirinDave> stoneferry: And probably the basics of haskell concurrency (since FFI immediately throws you into the distinction between bound and green threads)
11:00:43 <c_wraith> Is this really an FFI thing?
11:01:09 <c_wraith> even bound threads are green.  they're just scheduled differently
11:01:25 <KirinDave> c_wraith: True enough. I misspoke.
11:01:41 <stoneferry> Well all I'm making here is a small compiled program to create Windows event logs... for testing purposes
11:01:55 <k0ral> Saizan: is he related to the manatee project ?
11:01:55 <stoneferry> Maybe Haskell isn't a good choice for this
11:02:05 <c_wraith> Is the only interface to the windows event log via the windows API?  There's no specified format/location you can write to?  There's no network service?
11:02:19 <Saizan> k0ral: yep
11:02:20 <KirinDave> http://msdn.microsoft.com/en-us/library/aa385772(v=vs.85).aspx
11:02:23 <hpc> stoneferry: if the sole purpose of interfacing with the event log is for testing, definitely use a more suitable language
11:02:27 <Botje> stoneferry: find out what the win32 api call for it is and bind to that library with FFI
11:02:50 <KirinDave> c_wraith: It's... kinda involved.
11:02:59 <KirinDave> Big surprise there
11:03:01 <stoneferry> Thanks all... I'll probably look at another language then if ffi is the only option
11:03:02 <hpc> if you need to programatically add events, i would give some thought to the possibility of using that suitable language to make something for haskell to talk to, rather than going haskell the whole way
11:03:02 <Alan> 'I don’t think Computer Scientists can be considered engineers. They’re more like combat discrete mathematicians.'
11:03:11 <KirinDave> THIS JUST IN, UNNECESSARY COMPLEXITY FROM MS'S OS. :)
11:03:13 <Alan> I don't know the source, but awesome quote
11:03:22 <Alan> KirinDave: !!!
11:03:29 <KirinDave> Alan: Shock, I know.
11:03:35 * Alan is shocked, SHOCKED i say
11:10:23 <xplat> for the enumerators library, given f :: A -> B, g :: B -> C, EL = Data.Enumerator.List, EL.map (g . f) = EL.map g ??? EL.map f
11:10:28 <xplat> what is the ???
11:11:39 <ion> Where did you paste that from?
11:11:45 <notmycupoftea> maximalFixedPoint :: (G.Graph gr, Lattice a) =>
11:11:46 <notmycupoftea>      MonotoneFramework gr b c a
11:11:46 <notmycupoftea>   -> (gr b c -> (Label -> TransferFunc a) -> [(Int,Int)] -> M.Map Label a -> r)
11:11:55 <notmycupoftea> oops
11:14:12 <notmycupoftea> Hi guys I get an occurs check with this code fragment: http://hpaste.org/46971/mon , I'm not sure what causes it though, any ideas?
11:14:21 <xplat> in other words, what would i do with EL.map f and EL.map g to get something that behaves like EL.map (g . f)?
11:15:50 <mauke> nick8325: where's the code?
11:15:56 <mauke> argh
11:16:01 <mauke> notmycupoftea: where's the code?
11:16:06 <xplat> or in a third set of words, how do you compose enumeratees like unix filters?
11:19:38 <notmycupoftea> mauke: not sure if that helps much, but here it is: http://hpaste.org/46974/x
11:19:59 <Saizan> xplat: >==> ?
11:22:31 <mauke> notmycupoftea: what are the types of all used functions?
11:23:50 <acowley> notmycupoftea: you apply fixedPoint to fg and fg is a FlowGraph
11:23:57 <acowley> but fixedPoint's first argument is a gr
11:24:31 <notmycupoftea> glanced over it, thanks guys!
11:24:43 <mauke> hah, I just noticed that
11:24:51 <mauke> damn you for beating me
11:24:52 <xplat> Saizan: this doesn't typecheck : ET.splitWhen (0 ==) >==> EL.concatMap T.unpack
11:27:38 <acowley> mauke: helping people on #haskell is competitive!
11:27:47 * Saizan hates type synonyms without an API that let you forget what they expand to most of the time
11:29:47 <xplat> that should probably be EL.map, but it still doesn't typecheck, either with >==> or <==<
11:29:59 <xplat> i hate being reduced to trying things randomly :(
11:31:30 <k0ral> how does dyre know where are the sources when recompiling is necessary ?
11:33:47 <k0ral> has anyone an example of haskell app making use of webkit-gtk ?!
11:33:56 <k0ral> even manatee uses qt-webkit
11:35:07 <k0ral> oh manatee-browser actually does
11:35:38 <k0ral> still, another example would be nice
11:37:39 <xplat> i used EVERY operator in Data.Enumerator on 'map even' and 'map not', in either order without getting anything but type errors
11:37:59 <xplat> so it isn't a simple operator that's in there
11:38:03 <xplat> (and why not?)
11:38:58 <xplat> why does mm_freak like this library so much?  :P
11:40:23 <Saizan> because he's not a categorist?:)
11:40:34 <xplat> >> does something
11:40:55 <acowley> I've never used enumerator
11:41:00 <acowley> but I just typed this in and it checked
11:41:02 <acowley> test f g = (>>== E.map f) . E.map g
11:41:12 <acowley> so that's something?
11:41:25 <xplat> it works either direction, though, so i don't think it's the right thing ((>>), that is)
11:41:27 <acowley> the types aren't helping you because iteratee is weird :(
11:42:16 <Saizan> acowley: that typechecks but it doesn't have the same type as E.map (f . g), which is worrying
11:42:27 <acowley> Saizan: yes
11:44:53 <xplat> i think maybe (E.map f =$) . E.map g = E.map (g . f)
11:51:34 <xplat> the problem is that =$ kinda is an evil operator that discards leftover input
11:52:03 <xplat> i would rather be using $= somehow
11:54:04 <acowley> closer: E.joinI . E.joinI . (>>== EL.map f) . EL.map g
11:55:33 <xplat> that's the same as the one i came up with, only even more eviler (the joinI is the evil in =$)
11:55:51 <xplat> (and also it's less close)
11:57:12 <Cale> > showCReal 200 (60499999499/490050000000)
11:57:12 <lambdabot>   "0.123456789101112131415161718192021222324252627282930313233343536373839404...
12:00:49 <Jafet> Surprisingly small partial convergent
12:01:32 <ion> > showCReal 200 (137174210/1111111111)
12:01:33 <lambdabot>   "0.123456789012345678901234567890123456789012345678901234567890123456789012...
12:02:39 <mun_> i have a question about provability: suppose T |+ a, i.e. a is unprovable from T, how could one go about showing this practically? showing some other theorem b being a theorem of T, i.e. T |- b, can be done by simply proving it by deduction, then how about unprovability?
12:03:13 <roconnor> > approxRational (1/1111111111) (60499999499/490050000000)
12:03:13 <lambdabot>   0 % 1
12:03:20 <roconnor> > flip approxRational (1/1111111111) (60499999499/490050000000)
12:03:22 <lambdabot>   792869 % 6422239
12:03:26 <byorgey> mun_: in general, unprovability can only be shown from "outside" the system
12:04:31 <mun_> byorgey, but isn't unprovability on the same level as provability? to show T |- b, one would need to check that on a meta-level, right?
12:05:00 <byorgey> mun_: no, to show T |- b you just have to exhibit a formal derivation of b from T within the system
12:05:10 <Eduard_Munteanu> I suppose provability can be done constructively.
12:05:20 <Eduard_Munteanu> i.e. you just go ahead and prove it.
12:05:30 <byorgey> but to show that *no such derivation can exist* is (in general) more difficult.
12:06:07 <Cale> Of course, that proof exists as an object outside the system, and the existence of that proof object is what T |- b is asserting.
12:06:08 <Eduard_Munteanu> I believe this sort of stuff is usually approached from a model theory perspective.
12:06:34 <xplat> Jafet: transcendental numbers actually have better rational approximants than algebraic irrationals
12:06:37 <byorgey> mun_: is there some particular situation or formal system you are thinking about?  Or are you just trying to better understand these ideas in general?
12:07:06 <Jafet> Some of them, yeah
12:07:09 <mun_> Eduard_Munteanu, you mean unprovability is approached using model theory?
12:07:11 <xplat> Jafet: in fact showing the approximants are 'too good' is a common way of demonstrating the number is transcendental
12:07:25 <Eduard_Munteanu> mun_: yeah, that sort of question
12:07:35 <Cale> The continued fraction expansion of Champernowne's constant is insane.
12:07:37 <Jafet> A countable subset of them
12:07:54 <Cale> http://en.wikipedia.org/wiki/Champernowne_constant#Continued_fraction_expansion
12:07:57 <byorgey> xplat: if a number has approximants that are 'too good' then it must be transcendental, but the converse is not necessarily true, is it?
12:08:37 <mun_> byorgey, well, I'm trying to produce a proof obligation which speaks about provability of theorems. for example, I want the user to ensure that certain formulas are derivable sentences from the theory and some formulas are not derivable sentences.
12:09:23 <xplat> byorgey: at least some of the algebraics are harder to approximate than any transcendental number iirc
12:09:58 <xplat> at least if you don't worry about computability of the approximants
12:10:01 <tg_> xplat: don't approximate it!
12:10:02 <mun_> byorgey, so for example, a proof obligation might look like "T |+ a & T |- b". now that you suggested that unprovability is on a different level to provability, then does it make sense to talk about provable sentences and unprovable sentences together?
12:10:06 <Jafet> Of course, all but a countable subset of the real numbers don't exist, so I don't regard these as major issues
12:10:29 <Eduard_Munteanu> Don't exist? :)
12:10:39 <tg_> Eduard_Munteanu: yes
12:10:50 <tg_> Eduard_Munteanu: that's easy to prove, no?
12:11:08 <byorgey> mun_: is this for some particular theory? or just for any formal proof system in general?
12:11:15 <Eduard_Munteanu> You mean the set of constructive reals is countable?
12:11:27 <mun_> byorgey, it's for any formal proof system.
12:11:44 <tg_> Eduard_Munteanu: [R] is never countable because of, at least, diagonalization
12:11:45 <Eduard_Munteanu> Or a variation on that?
12:11:50 <byorgey> mun_: if a user must provide a proof that T |+ a  then you must ask yourself what such a proof would look like -- i.e. how does one construct evidence that a cannot be derived from T?
12:11:55 <tg_> the only countable subset is the empty set, I guess
12:12:04 <byorgey> mun_: I don't know of a way to do that in general.
12:12:06 <Eduard_Munteanu> Um?
12:12:10 <xplat> mun_: one problem is that any statement of unprovability in conventional (i.e. not paraconsistent) logics implies that the theory is consistent
12:12:40 <mun_> xplat, sure. the theory T is consistent.
12:12:43 <xplat> mun_: in general that's impossible to prove so you have to weaken the statement to begin with by assuming it
12:13:05 <mun_> xplat, well, i'm just assuming that T is consistent.
12:13:12 <byorgey> mun_: now, you could require a proof of  T |- ~a.  assuming the proof system is consistent that implies  T |+ a.  but it is a stronger requirement.
12:14:11 <xplat> it's a lot tougher to prove a statement is unprovable if it is also unrefutable
12:14:18 <mun_> byorgey, indeed. i'm adopting the open world semantics though. how about requiring that there exists an extension of T, T', such that T' |- a, and that there exists another extension of T, T'', such that T'' |- ~a. does this demonstrate T |+ a?
12:14:44 <byorgey> ah, interesting idea
12:15:30 <acowley> that's quite clever
12:15:34 <tg_> xplat: that sounds eerily similar to the experimental postulate of physics
12:15:45 <mun_> in that case would it be better off writing that out as a proof obligation instead, i.e. instead of "T |+ a & T |- b" and have "T' |- a & T'' |- ~a & T |- b"?
12:15:46 <xplat> mun_: that lets you prove a statement undecidable if you already have another undecidable statement that is stronger
12:15:58 <byorgey> mun_: well, first of all, I don't see what  T' |- a  buys you ?
12:16:15 <byorgey> why not just require that there is some extension T' such that T' |- ~ a.
12:16:26 <mun_> byorgey, sure, it can be simplified to just "T' |- ~a" where T' is an extension of T.
12:17:09 <mun_> is that equivalent to T |+ a though?!
12:17:13 <xplat> similarly, byorgey's simplification lets you prove a statement unprovable if you already have an unprovable statement which is stronger (but not so strong it makes the theory inconsistent)
12:17:20 <mun_> "equivalent", used very loosely...
12:18:09 <xplat> to bootstrap this process you need to do nontrivial meta-level proof theory or model theory, though
12:18:52 <byorgey> mun_: I think it is equivalent IF you add the requirement that T' must be consistent.
12:19:42 <byorgey> but that is also rather difficult to provide evidence for, I think.
12:19:49 <mun_> xplat, hmm why does the first formulation allow you to prove a statement undecidable?
12:20:02 <Eduard_Munteanu> The standard way would be to prove both T + a and T + ~a are consistent from the outside, right?
12:20:11 <mun_> byorgey, having consistency assumed is fine in my application.
12:20:42 <Eduard_Munteanu> I guess 'a' must be undecidable then.
12:21:08 <byorgey> Eduard_Munteanu: If T + a   and  T + ~a are consistent then a is independent of T.  But I think this is slightly stronger than saying a is not provable from T.
12:21:20 <Eduard_Munteanu> Oh?
12:21:33 <xplat> mun_: ‘a undecidable in T’ is equivalent to having both 'T |+ a' and 'T |+ ~ a'
12:22:05 <Eduard_Munteanu> In what way would it be stronger? It seems to be independent <=> not provable.
12:22:17 <byorgey> Eduard_Munteanu: a could be "true but unprovable": i.e. assuming its negation leads to a contradiction.  But if T does not have LEM that still does not make a provable.
12:22:25 <Eduard_Munteanu> Hrm.
12:22:34 <xplat> another way to say 'T |+ a' under the assumption that T is consistent is 'T, a |- _|_'
12:22:59 <xplat> er, yes, in classical logic only
12:23:07 <Eduard_Munteanu> But I thought Godel's completeness theorem stated that every true sentence must be provable.
12:23:35 <xplat> Eduard_Munteanu: every valid sentence
12:23:53 <byorgey> that is a theorem about first-order logic in particular, not formal proof systems in general.
12:23:54 <Eduard_Munteanu> Yeah.
12:24:10 <xplat> truth means 'this statement holds in my preferred model of the theory'.  validity means 'this statement holds in any model of the theory'
12:25:03 <xplat> Godel's incompleteness theorem shows that there are first-order theories none of whose first-order extensions admit only a single model
12:25:20 <Eduard_Munteanu> Oh, so you mean given a particular theory and an external theory, there could be a sentence which is true in both of them but can't be proven in your particular one?
12:25:31 <xplat> (when you combine it with the completeness theorem anyway)
12:25:40 <mun_> xplat, but if T was inconsistent, "T,a" would also be inconsistent right? (the comma acts like conjunction, right?)
12:26:03 <xplat> mun_: yes
12:26:21 <xplat> Eduard_Munteanu: a model is not a theory
12:26:47 <Eduard_Munteanu> So I guess one could say "look, !!a = a, but you can't prove it without excluded middle"?
12:26:50 <mun_> xplat, then if T was inconsistent, T,a would also be inconsistent, then "T,a |- _|_" as well because every sentence would be a theorem?
12:27:04 <xplat> mun_: right
12:27:19 <Eduard_Munteanu> Meh, model/proof theory is shaky ground for me.
12:27:34 <xplat> but if T is consistent and T,a isn't, then T can't derive a
12:27:38 <djahandarie> I live in a perpetual earthquake wherever I go.
12:28:16 <Eduard_Munteanu> I kinda get that feeling too :)
12:28:25 <acowley> djahandarie: diet and exercise?
12:28:33 <mun_> xplat, but T,a could still be consistent though, just that a is not derivable from T, right?
12:28:38 <xplat> Eduard_Munteanu: model theory may be shaky ground, but it's the ground you're treading on when you invoke Godel's Completeness Theorem
12:28:59 <mun_> xplat, note that i'm talking in the open world semantics.
12:29:10 <Eduard_Munteanu> Yeah, I know only really basic stuff about that.
12:29:40 <acowley> I think most of us get to, "FOL is awesome. Everything else? Ehhh...."
12:29:52 <xplat> mun_: yes, 'T,a |- _|_' is stronger than 'T |+ a'
12:30:07 <Eduard_Munteanu> How much of math is actually FOL?
12:30:25 <mun_> xplat, oh, sure.
12:30:44 <Eduard_Munteanu> Or even 2nd order.
12:31:00 <xplat> Eduard_Munteanu: ZF set theory is formulated in FOL, and so are many foundational theories of arithmetic
12:31:31 <Eduard_Munteanu> But in general one doesn't restrict himself to FOL, doesn't he?
12:31:34 <Eduard_Munteanu> *does
12:31:57 <djahandarie> I really want to read TTT now.
12:31:58 <Eduard_Munteanu> It makes me wonder how much of that Godel stuff holds.
12:32:10 <mun_> now in general, would it be better for me to state "T |+ a" or "T' |- ~a" as my proof obligation? i don't know if this is the right way to put it, but i think with "T |+ a", it's not clear what |+ means (|+ lacking semantics here?).
12:32:17 <xplat> actually most mathematicians use FOL if possible, either directly or by invoking set theory
12:32:24 <djahandarie> @google ttt toposes
12:32:25 <lambdabot> http://www.cwru.edu/artsci/math/wells/pub/bib/commath.bib
12:32:28 <djahandarie> Gah.
12:32:30 <Eduard_Munteanu> djahandarie: I only peeked at the CT primer in there. Is it interesting beyond that?
12:32:42 <Eduard_Munteanu> @where ttt
12:32:43 <lambdabot> Toposes, Triples and Theories: http://www.cwru.edu/artsci/math/wells/pub/ttt.html
12:32:49 * Eduard_Munteanu added it :)
12:32:51 <djahandarie> Ah, nice
12:32:51 <the_fco> I've just installed ghc and cabal in fedora 14, and whatever I try to install with cabal I get "There is no available version of ghc that satisfies -any". How do I convince cabal that I have ghc installed?
12:32:55 <Eduard_Munteanu> (a while ago)
12:32:56 <pumpkin> it's an awesome book
12:32:57 <djahandarie> Yes, it's very interesting beyond that
12:33:07 <djahandarie> I can't claim to understand the majority of it though
12:33:09 <xplat> also, SOL and HOL in general have incompleteness at the syntactic level, even if they determine unique models
12:34:03 <mun_> is it usual to have talk about provable sentences and unprovable sentences in the same level? as mentioned before, showing unprovability is done on a level outside showing provability, right
12:34:45 <xplat> that is, you can use SOL to construct a theory of arithmetic where true == valid, but then validity is not even semidecidable
12:35:22 <xplat> so the connection between provable and valid à la Gödel's completeness theorem falls apart
12:35:59 <xplat> so you can escape the completeness theorem if you want, but incompleteness will get you anyway
12:36:45 <xplat> the only way to have an actual complete theory is to have it be very weak
12:37:36 <the_fco> Hey guys, do any of you use fedora 14? I'member:ve just installed ghc and cabal, and whatever I try to install with cabal I get "There is no available version of ghc that satisfies -any". Do you know how do I convince cabal that I have ghc installed? thx in advance
12:37:54 <acowley> mun_: do you really need to go beyond proving a negation?
12:38:28 <dcoutts> the_fco: the ghc library is packaged separately to the ghc compiler on fedora
12:38:34 <mun_> acowley, well, yes, because I'm adopting the open world semantics. indeed, otherwise it'd be much simpler.
12:38:35 <xplat> presburger arithmetic, or some slight extensions with validity, or real closed fields without induction, or classical euclidean geometry.  things like that.
12:38:42 <dcoutts> the_fco: so you need that rpm as well
12:38:48 <xplat> *slight extensions with divisibility
12:39:18 <the_fco> dcoutts: oh, thanks, I'll try that
12:39:29 <Eduard_Munteanu> Well I asked this because I always wondered whether something could be (informally) true yet unprovable.
12:39:41 <mun_> acowley, otherwise I could just have the proof obligation as "T |- ~a & T |- b". but now, i'm tossing between "T |+ a & T |- b" and "T' |- ~a & T |- b".
12:40:03 <mun_> where T' is an extension of T
12:40:09 <acowley> mun_: yeah, and I know I'm not understanding it, but it seems like your assumption of the consistency of T makes the derivation of the negation very useful
12:40:28 <xplat> Eduard_Munteanu: i guess it all depends on whether you think noncomputable sets 'really' exist
12:40:44 <xplat> Eduard_Munteanu: if you do, it's a definite yes
12:40:48 <Eduard_Munteanu> Ah.
12:41:05 <joe6> is this #agda?
12:41:25 <xplat> no, it's #haskell-blah
12:41:36 <acowley> mun_: how do you formalize extensions of T?
12:41:37 <xplat> :)
12:41:42 <acowley> err, yes, I suppose it is
12:41:44 <Jafet> Only if you can prove that it is
12:41:46 <mun_> acowley, well, T must be consistent in order to show unprovability, right.. if it wasn't, then every sentence follows from it.
12:42:02 * pumpkin proves agda consistent from within agda
12:42:17 <byorgey> o noes!
12:42:19 <acowley> we became -blah because xplat's enumerator question would not yield
12:42:24 <mun_> acowley, well, i think that has to be checked on a meta-level.
12:43:06 <ezyang> What's an easy way to turn [1,2,3,4] into [(1,2),(3,4)]?
12:43:12 <acowley> mun_: yeah (and this is just curiosity about how you're doing it) but everything seems to hang on that checking
12:43:15 <pumpkin> ezyang: PAIN
12:43:25 <ezyang> > pain [1,2,3,4]
12:43:25 <ddarius> ezyang: Write the obvious recursive function.
12:43:26 <lambdabot>   Not in scope: `pain'
12:43:30 <Jafet> What do you want to turn [1] into?
12:43:31 <mun_> acowley, i.e. the meta level mechanism would need to check that every theorem of T' is a theorem of T?
12:43:39 <ezyang> Jafet: An error message.
12:43:51 <acowley> mun_: or the other way around if T' is an extension of T
12:43:52 <Jafet> I'm not partial to that kind of thing
12:44:03 <acowley> Jafet: he meant Nothing
12:44:21 <ezyang> Algorithmically speaking, such a case should never happen.
12:44:21 <pumpkin> > let f (x:y:xs) = (x, y) : f xs; f [x] = error "whoops"; f [] = [] in f [1,2,3,4]
12:44:22 <lambdabot>   [(1,2),(3,4)]
12:44:22 <mun_> acowley, sorry, yes.
12:44:27 <pumpkin> > let f (x:y:xs) = (x, y) : f xs; f [x] = error "whoops"; f [] = [] in f [1]
12:44:28 <lambdabot>   *Exception: whoops
12:44:43 <pumpkin> ezyang's been off in la-la land for too long
12:44:44 <ezyang> I was hoping for something nice with zips and cycles. Y'all have let me down! :-)
12:45:09 <acowley> or his type is something like, (x:list a) -> even (length x) -> list (a,a)
12:45:29 <mun_> acowley, the tool i'm using can check for extensions quite easily. now i'm just not sure if "T |+ a" and "T' |- ~a" actually have much difference.
12:45:41 <Jafet> > let f xs = map snd . filter fst $ zip (zip (xs (tail xs)) (cycle [True,False])) in f [1,2,3,4]
12:45:42 <lambdabot>   Couldn't match expected type `[a1] -> [a]'
12:45:42 <lambdabot>         against inferred type `[...
12:45:44 <acowley> ezyang: that exact question has come up here before and, I think, on SO, and people (me included) have proposed zip/cycle solutions but the pattern matching one is better :/
12:46:08 <Jafet> > let f xs = map fst . filter snd $ zip (zip xs (tail xs)) (cycle [True,False]) in f [1,2,3,4]
12:46:10 <lambdabot>   [(1,2),(3,4)]
12:46:27 <byorgey> ezyang: cabal install split; map (\[x,y] -> (x,y)) . chunk 2
12:46:31 <ezyang> heh.
12:46:55 <pumpkin> byorgey: what will happen to odd chunks?
12:46:56 <xplat> mun_: that definition is pretty accurate, but the problem is now you have to reason about consistency of arbitrary extensions of your theory.  reasoning about the consistency of your theory itself is impossible enough.
12:47:12 <byorgey> pumpkin: an error message, just like ezyang wanted
12:47:16 <pumpkin> lol
12:47:19 <pumpkin> pattern match failure?
12:47:22 <byorgey> yes
12:47:24 <pumpkin> yay
12:47:30 <mun_> xplat, which definition are you referring to, "T' |- ~a"?
12:47:39 <xplat> mun_: yes
12:47:53 <Jafet> > let f xs = map fst . filter snd $ zip (zip xs (tail xs)) (cycle [True,False]) in f [1]
12:47:55 <lambdabot>   []
12:47:58 <ezyang> Pattern match failure errors aren't as nice.
12:48:00 <djahandarie> Hi, my name's Bob and I use partial functions to define my denotative semantics!
12:48:07 <acowley> mun_: I think it looks good fwiw (not much), but I'm surprised you're so relaxed about proving ∀a, T |- a -> T' |- a
12:48:07 <ezyang> If I'm going to be partial, I usually supply a custom error message.
12:48:13 <pumpkin> in scala we like partial functions so much
12:48:19 <pumpkin> we even have a special type for them
12:48:24 <mun_> xplat, i agree with you that reasoning about consistency of T is hard/impossible.
12:48:26 <pumpkin> which is a SUBTYPE of regular functions
12:48:29 <djahandarie> щ(ﾟдﾟщ)
12:48:30 <dmwit> > let f xs = transpose (zipWith (\x y -> [x, y])) xs (drop 2 xs)) in f [1..5]
12:48:31 <lambdabot>   <no location info>: parse error on input `)'
12:48:32 <Jafet> Partials Pseudonymous
12:48:42 <dmwit> > let f xs = transpose (zipWith (\x y -> [x, y]) xs (drop 2 xs)) in f [1..5]
12:48:43 <lambdabot>   [[1,2,3],[3,4,5]]
12:48:44 <mekeor> > print "(how) is it possible to use haskell for microcontrollers?"
12:48:45 <lambdabot>   <IO ()>
12:48:51 <Eduard_Munteanu> Now I think this would be a really convenient thing if it were true / provable: the existence of an f such that size(proof) = O(f(size(theorem)))
12:48:58 <mekeor> oops :)
12:49:09 <ezyang> That's like Kolmogorov complexity.
12:49:17 <Eduard_Munteanu> Really?
12:49:20 <ezyang> on the other side of the curry-howard bridge.
12:49:23 <dmwit> > map (take 2) . iterate (drop 2) $ [1..5]
12:49:24 <lambdabot>   [[1,2],[3,4],[5],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
12:49:40 <Eduard_Munteanu> Because if there's no such f, then math is kinda doomed.
12:49:43 <mun_> acowley, i see where you're coming from. well, the meta level mechanism could just check how T' is defined. basically in my tool, I can find all of the dependencies of a theory.
12:49:48 <xplat> pumpkin: actually that makes sense.  in scala any function can be partial, the 'partial' functions are the subset where you can get some extra information about where they are defined
12:49:56 <Eduard_Munteanu> Well, not considering constants at the moment.
12:50:03 <pumpkin> xplat: yeah I know :)
12:50:07 <pumpkin> but it's amusing nonetheless
12:50:40 * Eduard_Munteanu looks into the Kolgomorov thingy further
12:50:43 <dmwit> Why is math doomed if no such f exists?
12:50:50 <pumpkin> Eduard_Munteanu: I have an algorithm to compute that thing
12:50:54 <pumpkin> but it didn't fit on my hard drive
12:50:56 <xplat> Eduard_Munteanu: such an f is uncomputable unless your theory is decidable
12:50:59 <kaini> Is there a prefered way to interchange data over a socket? (JSON, XML, ...?) Or can I use show/read?
12:51:19 <merijn> kaini: ASCII! :>
12:51:22 <Eduard_Munteanu> pumpkin: heh
12:51:23 <dmwit> kaini: Check out the binary and cereal packages, maybe.
12:51:34 <mun_> xplat, by the sound of your last response, you seem to prefer "T' |- ~a" more. i'm just curious to know why you prefer that over "T |+ a".
12:51:40 <merijn> kaini: In all seriousness, it depends on the data and what you want to interoperate with
12:51:47 <Peaker> I wonder if it would be a horrible idea to overload one "pipe" operator for  enumerator -> enumeratee, enumerator -> iteratee, enumeratee -> enumeratee, ...
12:51:49 <xplat> Eduard_Munteanu: (also it might or might not exist depending where you insert quantifiers)
12:51:55 <mun_> xplat, is it because one should speak about provability of theorems rather than unprovability?
12:52:36 <acowley> mun_: if nothing else, proving a negation *is* something you do every day.
12:52:37 <Eduard_Munteanu> Uh, then the outlook is kinda grim.
12:52:38 <merijn> kaini: If it'll be all Haskell and everything can be shown/read, I'd go with that out of laziness, if you need to interoperate with other things I'd use JSON, unless forced to use XML (in which case find a new project :>)
12:52:50 <acowley> kaini: binary!
12:52:51 <xplat> mun_: well, either could be fine if your logic is weak enough, but if it's strong enough unprovability is just really really hard to talk about
12:53:09 <kaini> merijn, I just want to pass (quite simple) messages between a client and a server
12:53:15 <mun_> acowley, right
12:53:36 <kaini> No other language involved
12:53:44 <Eduard_Munteanu> If one considers size(proof) as a measure of how hard it is to prove something then we could hit a truly impractical theorem to prove some day.
12:53:45 <mun_> xplat, i see. what if my logic was expressive like HOL?
12:53:50 <Eduard_Munteanu> (we might've already)
12:53:52 <kaini> dmwit, acowley, yeah, binary looks promising
12:53:55 <merijn> kaini: Oh, then I'd go with show/read, anything else is not worth it, IMO
12:53:55 <kaini> I'll take a look at that
12:54:13 <mekeor> (how) is it possible to use haskell for microcontrollers? -- no ideas?
12:54:14 <identity_> anyone know of a library that aids you in dealing with urls? Splitting them into respective parts, scheme, host, parameters and so on.. Adding and removing parameters perhaps
12:54:25 <identity_> Constructing whole, valid urls from parts such as relative paths and host
12:54:29 <xplat> like a correct obligation for T |+ a would probably be \exists T' ext T. T' |- ~a AND T' |+ a ... which is an infinite regress
12:54:32 <Jafet> kolgomorov(proof)
12:54:35 <identity_> Handling all the tiny edge cases that make you mad.
12:54:36 <merijn> mekeor: You mean like embedded stuff?
12:54:39 <kaini> merijn, fine, I guess I'll be lazy then and just use it :)
12:54:43 <mekeor> merijn: yep.
12:54:44 <Eduard_Munteanu> mekeor: you could use it to generate code, but probably not run Haskell per se on the mcu
12:54:52 <shapr> mekeor: http://hackage.haskell.org/package/atom
12:55:21 <mekeor> shapr: WOW
12:55:54 <shapr> mekeor: There's more for FPGAs
12:56:21 <mun_> xplat, but doesn't the first conjunct T' |- ~a imply T' |+ a? or are you trying to reason about the consistency of T'?
12:56:28 <xplat> mun_: in HOL it is probably kind of hopeless to prove anything unprovable
12:56:31 <ddarius> Eduard_Munteanu: Such theorems exist.
12:57:03 * ddarius breaks out his proof of the inconsistency of HOL to validate xplat's claim.
12:57:18 <Eduard_Munteanu> Meh, but we might not even know we're dealing with one :(
12:57:20 <djahandarie> > (\(x:y:_) -> (x, y)) .: takeWhile (not . null) . iterate (drop 2) $ [1..20]
12:57:21 <xplat> mun_: you can always find extensions of T that prove both a and ~a .  these extensions of course are inconsistent, but how do you plan to eliminate them from consideration?
12:57:22 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20)]
12:57:24 <Eduard_Munteanu> This is kinda sad.
12:57:37 <merijn> kaini: Basically, using strings to transfer data (which is essentially what you'd be doing with show/read) saves a lot of headaches like byte-ordering and what not and performance isn't an issue 99 times out of 100 anyway
12:57:45 <shapr> mekeor: https://leepike.wordpress.com/2009/05/05/an-atomic-fibonacci-server-exploring-the-atom-haskell-dsl/
12:58:00 <mun_> xplat, if i could just assume T and T' being consistent, then both formulations would be very much equal
12:58:05 <ktosiek> shapr: I never thought I'll be asking that, but is there any paper on how Atoms promises are kept?
12:58:30 <shapr> ktosiek: I don't know, but if you find out...
12:58:31 <acowley> mun_: your extension consistency guarantee is making everyone sceptical :)
12:58:38 <ktosiek> description sounds magical :-)
12:58:39 <mun_> acowley, :P
12:58:43 <mun_> acowley, i know i know
12:58:53 <mekeor> shapr: thank you very much :)
12:59:03 <acowley> every time I've used show/read for serialization it's burned me
12:59:16 <shapr> mekeor: I haven't used atom yet, but I have several Arduinos...
12:59:37 <merijn> ktosiek: Black magic, most likely
12:59:43 <acowley> I can offer 3rd party confirmation that atom works with Arduinos
12:59:45 <xplat> mun_: but how do you verify that the T' someone gave you to fill their proof obligation is consistent?
12:59:56 <mun_> xplat, why is showing unprovability in HOL so bad compared to other logics?
13:00:16 <xplat> mun_: i could see assuming T consistent, but not T'
13:00:19 <shapr> acowley: Got any code that works with the most recent atom?
13:00:19 <ddarius> Eduard_Munteanu: You're taking the entirely wrong attitude about this.  Many theorems along these lines are called "employment theorems."
13:00:38 <Eduard_Munteanu> Oh, heh, I kinda remember that.
13:00:50 <mekeor> shapr: cool.. but which prog-lang do you use instead, then?
13:00:59 <mekeor> ;)
13:01:05 <acowley> shapr: I will check
13:01:28 <shapr> mekeor: I use the Arduino IDE, but I'd rather be writing Haskell, of course!
13:01:44 <mekeor> shapr: :)
13:01:44 <xplat> mun_: well, with HOL you don't even have model theory to help tell you when something is unprovable like you do with FOL
13:01:46 <shapr> acowley: Did I meet you at HacPhi?
13:02:11 <acowley> shapr: d'oh... I tried out Atom back when it was 1.0.4
13:02:16 <acowley> shapr: quite possibly!
13:02:33 * shapr looks for pix of acowley from the first HacPhi
13:02:51 <acowley> shapr: if anyone joked around too much and talked about robotics a lot, it may have been me
13:02:56 <djahandarie> acowley, you better hope you're not wearing a horse mask
13:03:00 <kaini> merijn, I guess you are right :) I just was not sure if I may use it (using toString in Java for this purpose would be quite bad practise)
13:03:01 <mun_> xplat, i see.
13:03:14 <shapr> djahandarie: haha, jmcarthur will NEVER live that down :-)
13:03:18 <xplat> in HOL you can write a theory whose only (standard) model (if any) is the natural numbers (say), so you can't construct nonstandard models to show something unprovable if your theory is consistent
13:03:33 <acowley> kaini: do check out binary. It's relatively easy to use and gives you a realistic path for future upgrades/extensions/etc.
13:04:10 <acowley> djahandarie: that will greatly restrict my wardrobe options. Most of my outfits go with the mask.
13:04:21 <djahandarie> Haha
13:04:26 <roconnor> xplat: you mean by second-order induction?
13:04:43 <djahandarie> Horse mask w/ suit, horse mask w/ robe, horse mask w/ birthday suit
13:04:44 <merijn> kaini: If I have to make one global programming recommendation it would be to do the opposite of recommended practice amongst Java programmers :p
13:05:01 <xplat> in HOL provability doesn't have a reflection at the semantic level
13:05:16 <acowley> djahandarie: yes, that's my mon./wed./fri. rotation
13:05:22 <shapr> acowley: I found a pic of you on haskellers.net, but I don't remember meeting you at the first HacPhi.
13:05:23 <roconnor> xplat: and provability is undecidable?
13:05:28 <cheater897> did someone say horse mask
13:05:35 <kaini> acowley, yeah it looks really promising, but I will not use it right now, since read/show makes debugging with netcat (in fact I have not startet writing the client yet) surprisingly easy.
13:05:37 <acowley> shapr: I was only there on Saturday (I think) evening-night
13:05:58 <shapr> acowley: Did you show up after edwardk left?
13:06:04 <acowley> kaini: fair enough, and that is a good reason!
13:06:12 <xplat> roconnor: provability is of course semidecidable once you decide on a set of inference rules for your HOL
13:06:15 <acowley> shapr: no, I got to hear his talk and have him tell me things I tried to understand
13:06:24 <acowley> which is always terrifying
13:06:26 <roconnor> xplat: ya, but there is no completeness theorem.
13:06:30 <benmachine> 21:19:27 -!- Irssi: #haskell: Total of 777 nicks [1 ops, 0 halfops, 0 voices, 776 normal]
13:06:33 <benmachine> do I win the prize
13:06:48 <shapr> acowley: Yah, I worked with edwardk for almost two years, lunchtime was always mentally exhausting.
13:06:56 <djahandarie> benmachine, yes, you win millions of lambdacats!
13:07:02 <benmachine> djahandarie: wooo.
13:07:19 <benmachine> anyway I came in here because I'm trying to use a haskell.org trac but it won't send me an email verification token
13:07:20 <ddarius> I almost worked with edwardk for two days.
13:07:20 * shapr looks for pix of acowley on https://picasaweb.google.com/shae.erisson/HacPhiDayThree
13:07:26 <acowley> I've only met him a couple times, but it's always like being a deer in headlights until I realize he's serious
13:07:27 <djahandarie> Haha ddarius
13:07:32 <benmachine> it keeps saying it has but no such has arrived, on either address I tried
13:07:33 <xplat> right.  for HOL there is no set of inference rules that gives you completeness for (standard) models, so the choice of what inferences to allow is always kind of arbitrary and loses that connection with semantics
13:07:46 <shapr> acowley: Yah that happened at ICFP 2006 for most of the Haskell world.
13:07:59 <benmachine> http://trac.haskell.org/haskell-src-exts/ticket/214 <-- trying to correct this bug, the testcase is rubbish but there's a related genuine issue
13:08:00 <shapr> edwardk was my roommated at ICFP 2006..
13:08:13 <benmachine> anyone know who I poke if trac.haskell.org misbehaves?
13:08:23 <roconnor> xplat: ya.  Without a completness theorem, the nice semantics aren't worth the paper it isn written on. :)
13:08:38 <xplat> you can only get it back by smooshing together your HOL and the set theory you are doing model theory in and doing model theory ON THE MODEL THEORY of the HOL
13:09:02 <shapr> Huh, doaitse hangs out here?
13:09:09 <acowley> shapr: have you put on your resume that you worked with him for two years?
13:09:14 <xplat> and then of course it just becomes an overcomplicated form of FOL
13:09:23 <roconnor> xplat: I'm still working on proving Zermelo set theory inconsistent :)
13:09:28 <shapr> acowley: No, you think I should?
13:09:59 <acowley> shapr: I guess it depends where you're applying
13:10:06 <benmachine> roconnor: how do you think people will react if you manage it?
13:10:27 <roconnor> benmachine: they will give me tenured jobs.
13:10:33 <benmachine> heh
13:10:39 <benmachine> and then grumble about you behind your back
13:10:42 <jmcarthur> omg
13:10:51 <djahandarie> zomg
13:11:27 <xplat> roconnor: i don't know why, but somehow function spaces seem a lot more realistic than powersets ...
13:11:29 <shapr> hoi doaitse, hoe gaat het? How's UU doing?
13:12:05 <xplat> and yet they are the same thing, as long as there's a set of truth values
13:12:20 <roconnor> xplat: if you have definite or indefinite description, then function spaces are as bad as powersets I guess.
13:12:33 <byorgey> o-_-o: I just pushed a patch that generalizes the cairo backend to also return a Render () action, which you could use to e.g. paint a surface
13:12:35 <ddarius> benmachine: People, where by "people" I mean mathematicians, will be surprised for a few minutes, and then return to doing exactly what the were doing.
13:12:47 <roconnor> ddarius: as well they should
13:13:01 <ddarius> roconnor: As well they should.
13:13:06 <roconnor> benmachine: I would hope for a rise in interest in Martin Lof type theory for foundations.
13:13:07 <dmwit> byorgey++
13:13:12 <acowley> I'll stop what I was doing
13:13:14 <benmachine> ddarius: well, I guessed that it wouldn't affect some areas, but I'd've thought some things would be a bit shaken
13:13:46 <roconnor> benmachine: but I fear they will hobble together another set theory such as that KP-whatever set theory.
13:13:50 <xplat> benmachine: it takes a long time for these things to percolate
13:14:04 <xplat> kripke-platek?
13:14:11 <roconnor> I think
13:14:14 <roconnor> the one without a powerset :D
13:14:15 <ddarius> The few that care would do what roconnor says.
13:15:41 <mun_> xplat, just a quick question, is showing unprovability in FOL semi-decidable as well?
13:15:57 <xplat> basically people tend to ignore things that are too bizarre to integrate into their worldview, even if they are indubitably true
13:17:26 <rinzai> hi everyone
13:17:51 * roconnor starts writing out random deductions in Zermelo set theory to check to see if they deduce False.
13:18:08 <xplat> mun_: provable statements in FOL and HOL form a recursively enumerable set, the unprovable statements are co-RE
13:18:17 <ezyang> Is that the "bogoguess" proof method?
13:18:19 <ddarius> xplat: It's likely roconnor's proof would already involve things so bizarre that they are already ignored.
13:18:39 <roconnor> that's my plan
13:18:53 <xplat> mun_: this means unless your theory happens to be decidable you can't even list all the unprovable statements, unless you are willing to name some falsely
13:19:00 <rinzai> is this the best channel for noob questions? Or is there something equivalent to a "haskell-beginners" ? :-S
13:19:10 <pumpkin> rinzai: go ahead :)
13:19:12 <acowley> rinzai: ask away!
13:19:19 <rinzai> :) thanks!
13:21:59 <Jayyyyyyyy> exit
13:22:12 <xplat> mun_: (that is, you must either leave some out of the list or add extras)
13:22:57 <rinzai> I'm learning Haskell in babysteps and was trying to make a list of x unique random numbers. So far, I've managed to create a list of n random numbers between 0 and 100 using: randomlist n = take n . unfoldr (Just . randomR (1,100))
13:23:20 <roconnor> @type randomR
13:23:20 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:23:39 <roconnor> rinzai: nice
13:24:01 <mun_> xplat, sorry, i'm not familiar with the RE/co-RE class. then does that mean showing unprovability is undecidable rather than semidecidable?
13:24:04 <rinzai> but how can I guarantee their uniqueness in the final list... :-S
13:24:05 <ddarius> If n > 101, what do you want to do?
13:24:21 <norm27822> I'm trying to upload a package to hackage, but am getting the following error: 500 Internal Server Error <stdin>: hWaitForInput: invalid argument (Invalid or incomplete multibyte or wide character)
13:24:24 <norm27822> what could that be?
13:25:00 <rinzai> sorry, what I meant is randomlist 10 should give me 10 unique random number between 0 and 100
13:25:15 <rinzai> well ... english fails me
13:25:21 <rinzai> "unique random numbers" :-P
13:25:23 <ddarius> rinzai: Yes, and what do you want randomlist 102 to do?
13:25:36 <rinzai> -____-
13:25:49 <rinzai> tis true what they say about functional programming
13:26:01 <rinzai> you start seeing how stupid is your code :-P
13:26:05 <mauke> ddarius: dohoho, do you know what minesweeper on win98 did in that case?
13:26:23 <rinzai> very good point...
13:26:48 <mun_> xplat, oh right. RE means semidecidability according to wikipedia...
13:26:49 <rinzai> for the purpose of that code, nothing
13:26:55 <Zao> norm27822: Using any silly encoding in your text?
13:27:13 <ddarius> mauke: I probably knew ten years ago.
13:27:18 <xplat> roconnor: something i've wondered ... if you keep adding consistency statements to PA, transfinitely, will you ever reach a place where you can't prove that all the consistency statements you've added are well-ordered?  (sort of like a fixed point in the ordinal strength of the theory)?  or is that impossible?
13:27:28 * Twey never knew, and is happy about this.
13:27:44 <acowley> rinzai: I would add random numbers to a Set until the Set's size is 100
13:27:48 <mauke> ddarius: edit winmine.ini, set it to 102 mines on a 10x10 grid, start winmine.exe
13:27:53 <mauke> watch it hang your entire pc
13:27:57 <mauke> probably busy looping
13:28:00 <Twey> Lovely
13:28:19 <roconnor> xplat: Firstly you need to pick ordinal notations to add consistenty statments, and different notations will lead to different theories.
13:28:23 <mauke> the fun part is that the mouse pointer still moves, but clicks have no visible effect
13:28:28 <rinzai> acowley, that's a good idea
13:28:36 <norm27822> Zao: no, I don't think so... it's the same codebase I uploaded this morning
13:28:37 <rinzai> ok, I'll try it
13:28:42 <rinzai> thanks ddarius acowley
13:28:48 <ddarius> mauke: That's what all versions of Windows are like anyway.
13:29:00 <norm27822> well, plus some patches... I did change the cabal dep from 1.6 to 1.8... would that influence anything?
13:29:02 <roconnor> xplat: Secondly, it is important to remember that adding consistency statements doesn't increase the ordinal strenght of the theory, IIRC.
13:29:23 <dankna> norm2782 norm27822 Zao: apparently hackage has a problem right now; someone in #ghc was getting the same error from it a few minutes ago, but they assumed it was just them
13:29:38 <mauke> this is how I "hacked" pcs back then
13:29:55 <roconnor> xplat: Thirdly, IIIRC you can keep doing this transfintely, but you will always be weaker than PA + PA is Sigma-1 sound.
13:30:02 <ddarius> "Hacking" 98 didn't take rocket science.
13:30:33 <mun_> xplat, did you mean the unprovable statements in FOL only or in both FOL and HOL are co-RE?
13:30:35 <norm27822> dankna: ah ok, thanks. that means I can stop looking for a cause in my code :)
13:30:42 <dankna> norm27822: indeed :)
13:30:59 <mauke> I discovered this problem because I had to deal with this case in my text-based toy minesweeper written in QBASIC
13:31:08 <roconnor> xplat: you may want to read this: http://xorshammer.com/2009/03/23/what-happens-when-you-iterate-godels-theorem/
13:31:11 <mauke> and I wondered how the real minesweeper handled it (answer: it didn't)
13:31:30 <roconnor> xplat: I borrowed the book referenced in that blog post.  If you do you can skip to the last few chapters.
13:35:12 <joe6> i have a function returning IO String and I am trying to do function >> TestCase as I do not care about the return of the function. Any suggestions on how I can do that?
13:35:26 <joe6> I can use "do" and put return () at the end
13:35:35 <joe6> but, just curious if there was a better way
13:35:55 <Twey> :t <$
13:35:56 <lambdabot> parse error on input `<$'
13:35:56 <joe6> something like TestCase $ do _ <- function ; return () will work
13:35:59 <Twey> :t (<$)
13:36:00 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:36:07 <Twey> That's the one
13:36:10 <Twey> It's const for Functors
13:36:15 <mauke> joe6: TestCase (function >> return ())
13:36:23 <Twey> TestCase $ () <$ function
13:36:32 <joe6> cool, thanks a lot.
13:36:42 <Twey> :t ($>)
13:36:43 <lambdabot> Not in scope: `$>'
13:36:49 <Twey> Hrpm.h
13:36:55 <Twey> Hrmph.
13:37:02 <acowley> :t void
13:37:03 <lambdabot> Not in scope: `void'
13:37:22 <acowley> well, lambdabot, add it to your scope
13:37:36 <mauke> @let ignore = (>> return ())
13:37:37 <lambdabot>  Defined.
13:37:51 <acowley> is lambdabot's NLP module not installed?
13:38:27 <cheater897> neurolinguistic programming?
13:38:33 <dankna> natural-language processing
13:38:44 <mauke> MLP > NLP
13:39:37 <Twey> joe6: In general, though, you shouldn't *need* to return ()
13:39:45 <Twey> joe6: If you don't care about the return type, just use ‘IO a’
13:40:10 <Twey> There's no situation in which () provides useful information that a doesn't, AFAIK
13:40:36 <acowley> it's useful in that it indicates you're not accidentally throwing away information
13:40:48 <acowley> hence the warnings added in 7
13:41:27 <Twey> I don't like those warnings
13:41:36 <Twey> I don't care if I'm accidentally throwing away information
13:41:48 <Twey> If I'd wanted the information then I would have stored it
13:41:49 <dankna> I do
13:41:53 <acowley> I agreed with you until you explained yourself
13:41:59 <Twey> If I don't want the information, why do I have to think about it?
13:42:03 <dankna> I like the warnings; I do want to know that I am accidentally throwing out information
13:42:22 <dankna> a little extra typing to make my intention clearer?  win
13:42:23 <acowley> I don't like those warnings because I often intend to throw away information.
13:42:48 <acowley> but now I'm used to them, and think I can move on
13:42:52 <Twey> If you want to keep the information then you have to explicitly store it somewhere
13:43:03 <benmachine> the warnings were introduced to fix a space leak, iirc
13:43:16 <benmachine> where sometimes mapM with a discarded result would use more memory than mapM_
13:43:18 <benmachine> or something.
13:43:24 <dankna> always, actually
13:43:27 <balor_> I've got a Tree type "data Tree = Node Int | Branch Tree Tree". By deriving Functor I can apply any function to the Int in Node (which is cool). Is there some standard idiom for replacing a Node with a subtree?  Or do I just have to walk the tree?
13:43:28 <Twey> It's not like someone's going to go: ‘do getLine; print x’ accidentally instead of ‘do x <- getLine; print x’
13:43:29 <dankna> mapM constructs a list and discards it
13:43:48 <Twey> benmachine: That is a reasonable but relatively uncommon motivation, I think
13:43:52 <benmachine> dankna: well, one imagines that deforestation might cause magic to happen
13:43:59 <dankna> fair enough
13:44:45 <Saizan> balor_: that'd be a Monad instance, but i don't think there's any package or feature that provides the derivation
13:44:58 <Saizan> balor_: btw, i guess you meant data Tree a = Node a | ..
13:45:23 <balor_> Saizan, yes.  So I should turn my tree into a monad.  Thanks.
13:45:32 <acowley> An Int is good enough for real programmers
13:45:43 <Saizan> acowley: not for Functor though
13:45:50 <byorgey> [Bool] is good enough for REAL programmers
13:45:58 <acowley> YES!
13:46:13 <acowley> Saizan: my functor is an int*
13:46:21 <acowley> very polymorphic
13:46:36 <Saizan> instance Monad Tree where return = Node; Node x >>= f = f x; Branch l r >>= f = Branch (l >>= f) (r >>= f)
13:47:12 <acowley> balor_: just to be clear, ignore me, Saizan is giving all the right answers
13:48:05 <ddarius> byorgey: Integer you mean.
13:48:30 <MasseR> My cabal hooks do nothing :/ (cabal-dev)
13:48:57 <Saizan> MasseR: do you have build-type: Custom ?
13:49:02 <MasseR> Ah
13:50:29 <mun_> xplat, going back to a point you made earlier that HOL is semi-decidable once you have decided on a set of inference rules (otherwise undecidable): so how come restricting on a set of inference rules improve the complexity to semi-decidability?
13:51:08 <Volt_> Are there Binary instances for Data.Text floating around in a package somewhere? Or do people encode/decode to ByteString themselves first before serialising?
13:51:34 <acowley> mun_: you can enumerate theorems at that point can't you?
13:52:26 <mun_> acowley, FOL is semi-decidable too. so HOL with a set of inference rules and FOL have the same complexity?
13:52:59 <mun_> acowley, is FOL semi-decidable in general (even without the inference rules)?
13:53:31 <Favonia> Volt_: how about something like Data.Text.Lazy.Encoding ?
13:55:13 <Saizan> mun_: it'd be semi-decidable if a proposition is provable with the inference rules, but since these rules wouldn't be complete in case of failure the proposition might still be valid in the full HOL, afaiu
13:55:14 <mun_> acowley, but then one can't talk about decidability without referring to some inference rules right, since decidability is about having an effective deduction system for that logic. and a deductive system must have some inference rules. am i missing something?
13:56:04 <acowley> mun_: I think there may be some confusion here about FOL vs. FO theories
13:56:45 <acowley> mun_: but to be honest, I don't say "semi-decidable" in public to avoid saying something wrong, so I should yield to byorgey who probably has something reliable to say
13:56:47 <xplat> roconnor: thanks, that post answered pretty much all my questions about this matter (but inevitably spawned a few new ones :)
13:57:10 <Volt_> Favonia: Yeah, I don't mind using encodeUtf8 etc., but I was just wondering if I'd have to do it myself or if there were already Data.Binary instances out there that I'm missing
13:58:12 <xplat> (maybe the book would answer those too, and spawn more.  it does sound interesting.)
13:58:45 <byorgey> mun_: decidability does not depend on having inference rules, just on having a decision procedure, but that decision procedure need not use a deduction system.
13:59:01 <acowley> see?
13:59:04 <byorgey> e.g. it might enumerate some finite set of possibilities and check each one, or something like that
13:59:44 <acowley> byorgey: but that is rather like a bunch of inference rules without premises isn't it?
14:00:25 <byorgey> well, I guess so.  To be honest I haven't read the whole conversation up to this point so I'm not exactly clear on what is being discussed.
14:00:45 <pumpkin> preflex: seen newsham
14:00:46 <preflex>  newsham was last seen on #haskell-blah 34 days, 15 hours, 44 minutes and 48 seconds ago, saying: if you're using the simple thing, you can always try out that complicated thing (and get stuck in it)
14:01:52 <xplat> deciding provability is all about the inference rules, though
14:02:03 <Favonia> Volt_: I see :P
14:02:11 <xplat> other sorts of decision procedures do not provide what you would call a 'proof'
14:02:27 <dankna> http://hpaste.org/46977/800m_on_the_stack http://dankna.com/himitsu/not-much.png http://dankna.com/himitsu/emulator.prof.txt
14:02:34 <dankna> according to this profile, my allocation is in some weird places that don't make sense
14:02:42 <dankna> runCPU is implicated for 20% of it, putting it in first place
14:02:56 <dankna> but runCPU is just an accessor, so the cost must be that it's forcing the newtype constructor to be allocated?
14:03:02 <dankna> I thought newtype constructors were eliminated at compile-time
14:03:24 <dankna> note that the heap profile shows that my 3.5G of allocation is entirely on the stack (I'm very impressed that it didn't overflow)
14:03:54 <xplat> validity in any significant HO theory is always undecidable
14:04:30 <mun_> xplat, right. then when is it semi-decidable like you mentioned earlier?
14:04:50 <acowley> evidently when the HO is insignificant :)
14:04:56 <xplat> provability is decidable if you decide on an effective set of inference rules instead of some noncomputable thing like 'any sound inference rule is okay to use'
14:05:15 <dankna> any sufficiently advanced axiomatic system is indistinguishable from magic?
14:05:28 <acowley> Magic |- False
14:05:29 <xplat> mun_: validity never becomes decidable, only provability does
14:05:57 <merijn> dankna: Yes, for example Epigram and math :p
14:05:58 <sipa> hence, any axiomatic system that is distinguishable from magic is insufficiently advanced?
14:05:59 <acowley> because you can enumerate proofs but not models?
14:06:03 <dankna> merijn: yeah :)
14:06:17 <Eduard_Munteanu> BTW, is paraconsistent logic and its likes all bullcrap, or is there any tiny bit of interesting stuff?
14:06:47 <merijn> What *is* paraconsistent logic?
14:06:54 <dankna> ... re my program, this is a disappointment, because I just spent a week reorganizing things to avoid allocating
14:06:55 <Eduard_Munteanu> (not that I see how, but ...)
14:07:17 <Saizan> dankna: newtype constructors aren't
14:07:28 <Eduard_Munteanu> Well, mostly logic where you kinda go into the realm of saying something can be both true and false.
14:07:28 <dankna> Saizan: oh hi
14:07:31 <merijn> Eduard_Munteanu: Oh, logic with gradients of contradiction. Hell yes they are interesting
14:07:33 <acowley> I think it's when it's not insanely inconsistent
14:07:37 <xplat> acowley: because you can enumerate proofs in an effective inference system, or GROUND truths in a computable model, but you can't enumerate true quantified statements in models, and models of effective theories don't have to be computable anyways
14:07:46 <acowley> which is quite funny
14:08:07 <Saizan> dankna: i.e. they don't exist at runtime, things like map i
14:08:08 <xplat> (well, you can't enumerate true quantified statements in INFINITE models, i should say)
14:08:37 <Eduard_Munteanu> Well, I can see some groups (crackpots etc) needing that sort of stuff when it becomes really inconsistent.
14:08:39 <merijn> Eduard_Munteanu: Very useful for reasoning about/modeling AI kinda things. Simple logic just doesn't come close to cutting it, you want things like paraconsistent and temporal logics
14:08:50 <Saizan> dankna: things like map Foo when Foo is a newtype constructor are still map id though
14:09:00 <acowley> hey, hey, hey, temporal logic doesn't bring in any funny business
14:09:05 <dankna> Saizan: right, okay.  that's what I thought.
14:09:06 <acowley> it's just extra superstructure
14:09:21 <dankna> Saizan: maybe I should also paste the definition of the underlying monad?  adding that, one sec
14:09:29 <Eduard_Munteanu> Temporal logic = formulas parametrized by time?
14:09:29 <merijn> Eduard_Munteanu: You also need them for reasoning about things in the real world, I guess fuzzy logic would be a variant of paraconsistent logic for example
14:09:34 <Boxo> anyone remember the blog post with the ~> combinator with which f ~> g ~> h = \x y -> f (g y) (h y)? Can't find it
14:09:57 <merijn> Eduard_Munteanu: Truth value of statements is time dependent. i.e. some statement *was* true, but no longer is
14:10:03 <xplat> Boxo: yes, hold on ...
14:10:06 <Eduard_Munteanu> Mhm, yeah, though fuzzy logic doesn't plainly put it that way :)
14:10:10 <acowley> paraconsistent logic lets you turn things into swiss cheese as long as there's still some cheese left
14:10:18 <Eduard_Munteanu> Ah.
14:10:40 <merijn> Eduard_Munteanu: "The solar system has 9 planets", this statement was true (in the sense of believed to be true) in the past, but no longer
14:10:45 <acowley> Eduard_Munteanu: usually it's not like a function of time, but a way of sequencing propositions
14:11:01 <acowley> Eduard_Munteanu: using connectives like "always" "eventually" "until"
14:11:02 <dankna> to be fair, the planets example was never rigorously true - there was never a formal definition of "planet" before.
14:11:10 <Eduard_Munteanu> Ah.
14:11:31 <Eduard_Munteanu> Does it involve giving up the axiom of non-contradiction?
14:11:33 <acowley> it's great for dynamic systems, FSAs, etc.
14:11:34 <merijn> dankna: Hence why I said you want fuzzy/paraconsistent logic as well when modeling the "real world" for AI
14:11:39 <dankna> fair enough
14:11:40 <Eduard_Munteanu> Or does it avoid that issue?
14:11:56 <Eduard_Munteanu> Because non-contradiction is something I'd give up *last*.
14:12:00 <merijn> You want to express a concept of "more true" and "less true". 9 planets was true, for given values of true :p
14:12:10 <mun_> xplat, ok. so in HOL, validity is always undecidable, but provability can be semi-decidable if an efficient set of inference rules is used. then with FOL, is it that both validity and provability are semi-decidable?
14:12:23 <acowley> Eduard_Munteanu: I don't think it's anything like that
14:12:25 <xplat> Boxo: http://matt.immute.net/content/pointless-fun
14:12:49 <Boxo> xplat: thanks!!
14:12:50 <Eduard_Munteanu> (I meant paraconsistent, not temporal)
14:12:50 <xplat> mun_: yes
14:13:00 <Saizan> dankna: i wonder if "newtype CPUMonad a = CPUMonad (MonadicState a) deriving Monad" would change anything
14:13:07 <acowley> Eduard_Munteanu: oh, yes that gives up non-contradiction afaik
14:13:09 <dankna> deriving Monad?  hmmmmm
14:13:19 <dankna> I'll try it
14:13:42 <Saizan> dankna: oh, how is runCPU defined? just runCPU (CPUMonad x) = x?
14:13:44 <acowley> this is quite a clear reference http://plato.stanford.edu/entries/logic-paraconsistent/
14:13:55 <dankna> Saizan: scroll down in the paste, its definition is an annotation.  but yes.
14:14:00 <Eduard_Munteanu> Saizan, dankna: is 'a' phantom there?
14:14:16 <dankna> eh?  no, a is the value in the monad
14:14:37 <Eduard_Munteanu> Why make up a new monad? Can't you deal with something like Reader over State?
14:14:52 <dankna> the short answer is no :)
14:15:06 <dankna> it's a new monad because it stores 50 fields on the stack rather than in the heap
14:15:08 <Eduard_Munteanu> Reader over ST then? :)
14:15:42 <dankna> that approach was suggested yesterday and I may try it next, but I'd want to understand why this one isn't working first; otherwise there's no reason to assume it would solve the problem
14:16:06 <overscore> dankna, did you find out why the stack grows?
14:16:12 <Eduard_Munteanu> I'm not sure how another monad lets you rework the allocation pattern.
14:16:14 <dankna> overscore: no, not yet
14:16:25 <dankna> Eduard_Munteanu: well, I'm preparing an hpaste of the definition of the monad; you'll see in a sec
14:16:31 <Eduard_Munteanu> Oh.
14:16:54 <dankna> http://hpaste.org/paste/46977/800m_on_the_stack_annotati#p46979 -- monad definition
14:16:54 <xplat> Eduard_Munteanu: because things are individual function arguments rather than parts of a single record that lives in the heap and gets passed to the function, i would guess
14:17:04 <dankna> yes, exactly what xplat just said
14:17:26 <Eduard_Munteanu> Ok, so some -> A -> B -> C -> D variant of Reader I guess, no?
14:17:35 <dankna> well, it's more like State than Reader
14:17:35 <Eduard_Munteanu> (erm properly paranthesized)
14:17:39 <dankna> but yes
14:17:55 <dankna> there are also (autogenerated) accessors for all these fields
14:18:01 <xplat> erlang actually makes that sort of thing pretty easy
14:18:03 <dankna> both get and put, for each
14:18:38 <xplat> modulo writing everything, but it is easy to get things to live on the heap and not allocate
14:18:38 <Saizan> dankna: i'm pretty sure those huge lambdas are problematic and we can do away with them
14:18:50 <dankna> Saizan: hmm, okay.
14:18:51 <xplat> maybe you should use haskell to generate erlang :)
14:19:16 <xplat> *on the stack and not allocate*
14:19:52 <merijn> xplat: To bad Erlang's syntax is so ugly :(
14:20:03 <xplat> merijn: garrows ftw :)
14:20:03 <Eduard_Munteanu> Ouch.
14:20:12 <Eduard_Munteanu> That's one mean monad.
14:20:20 <dankna> Eduard_Munteanu: yes :/
14:20:53 <xplat> preflex: seen mm_freak
14:20:53 <preflex>  mm_freak was last seen on #haskell 3 days, 10 hours, 20 minutes and 21 seconds ago, saying: as jeffz says they are just substrings
14:20:54 <Eduard_Munteanu> Oh, but you used TH, so I guess it ain't that pissy.
14:20:58 <dankna> right
14:21:08 <dankna> I would go insane if I had to write that by hand :)
14:22:00 <mun_> xplat, going back to validity being undecidable, how come validity in HOL never becomes (semi)decidable. what did you mean by not able to enumerate true quantified statements in models?
14:22:02 * Eduard_Munteanu wonders whether M4 would make a nice Turing-complete general purpose preprocessor for this sort of stuff :P
14:22:09 <dankna> no, it would not
14:22:11 <dankna> m4 is not nice for anything
14:22:14 <dankna> well, that's unfair
14:22:15 <Eduard_Munteanu> I guessed as much :)
14:22:17 <dankna> it's nicer than the shell
14:22:23 <dankna> but that's a low bar
14:22:44 <ezyang> Is there an efficient floating point op for doing the equivalent of (round x > round y)?
14:22:49 <xplat> but the shell has better libraries
14:22:52 <dankna> true
14:24:33 <danharaj> What's a good name for: foo b x y = if b then x else y?
14:24:41 <acowley> bool
14:24:42 <zygoloid> if' or bool
14:24:47 <dankna> danharaj: Excel calls it iff, which is a bit of a misnomer
14:24:54 <pumpkin> I'd typically call it if' if b comes first
14:24:55 <danharaj> why isn't it in the prelude :[
14:24:57 <pumpkin> or bool if b comes last
14:24:57 <Saizan> dankna: http://hpaste.org/paste/46977/800m_on_the_stack_annotati#p46980 <- you can change the type adding more fields while keeping the same instance of Monad
14:25:08 <merijn> danharaj: Pretty sure it is...
14:25:12 <ddarius> dankna: Are you sure it doesn't call it IIf?
14:25:13 <pumpkin> merijn: you'd be wrong
14:25:26 <dankna> Saizan: interesting, reading it!  btw the deriving (Monad) test is running now; it doesn't seem to be an improvement
14:25:29 <acowley> it's not defined anywhere useful
14:25:29 <merijn> pumpkin: Really? Inconceivable!
14:25:34 <acowley> so we all write it over and over again
14:25:46 <pumpkin> merijn: indeed!
14:25:50 <ddarius> Or just don't use booleans.
14:25:53 <pumpkin> especially when @pl refers to it all the time
14:25:57 <ddarius> maybe exists.
14:26:02 <zygoloid> @pl \b x y -> if b then x else y
14:26:02 <lambdabot> if'
14:26:17 <danharaj> @src if'
14:26:17 <lambdabot> Source not found. stty: unknown mode: doofus
14:26:27 <Eduard_Munteanu> ezyang: hrm, CVTSS2SI followed by a packed comparison on integers?
14:26:38 <ezyang> bleagh
14:26:49 <pumpkin> ezyang: you sound happy
14:27:08 <Eduard_Munteanu> I don't know if there's something that does both the rounding and comparison in one insn.
14:27:18 <acowley> I don't think so
14:27:30 <pumpkin> ezyang: think about the representation
14:27:35 <ezyang> maybe I'll just add .5 and hope for the best.
14:27:45 <pumpkin> it's easy to check if one is greater than the other if their exponents are different
14:27:46 <Eduard_Munteanu> It might not be helpful if you don't have multiple such numbers.
14:28:01 <mun_> the wikipedia entry on FOL, it says "This means that there is no decision procedure that determines whether arbitrary formulas are logically valid." so is validity in FOL undecidable, thus only provability is semidecidable?
14:28:03 <danharaj> ddarius: What about using bools in the context of numbers? Sometimes you just gotta do something based off of a comparison.
14:28:19 <acowley> Or just assume the test is always True. That's much quicker
14:28:36 <Saizan> dankna: btw, return x = MState (\k -> k x) might be better than return x = MState ($x), sorry :)
14:28:41 <dankna> hehe okay
14:28:54 <tromp> @pl \(x, y) -> (f y, f x)
14:28:54 <lambdabot> uncurry (flip ((,) . f) . f)
14:29:31 <dankna> I don't totally understand how it's possible to write these lambdas without enumerating all their parameters, although I suppose it has to do with returning a higher-order function somehow, but I'll put it in the code and report back in about ten minutes :)
14:29:39 <zygoloid> mun_: iirc you can construct Gödel numberings for statements such as 'this Turing machine halts'
14:30:01 <zygoloid> (in, for instance, the FOL axiomatization of peano arithmetic)
14:30:11 <byorgey> mun_: I think validity in FOL is also semidecidable
14:30:19 <Saizan> dankna: it's the magic of currying, the types match :)
14:30:27 <dankna> Saizan: heh!  all right
14:30:40 <zygoloid> come to think of it, Turing machines themselves can probably be axiomatized in FOL
14:31:08 <Saizan> anyhow it is about returning functions, runMState m (\a -> runMState (f a) k) has type Int -> Bool -> r  for example
14:31:10 <ion> > join (***) (f :: Expr -> Expr) (x,y)
14:31:11 <lambdabot>   (f x,f y)
14:32:39 <mumucow> oops
14:32:40 <ion> > (snd &&& fst) (x,y)
14:32:41 <lambdabot>   (y,x)
14:32:49 <mun_> byorgey, i'm looking at http://en.wikipedia.org/wiki/First-order_logic#Completeness_and_undecidability the first line of the second paragraph reads "Unlike propositional logic, first-order logic is undecidable (although semidecidable)" so is it undecidable or semidecidable?!
14:33:12 <mun_> the next sentence goes.. "This means that there is no decision procedure that determines whether arbitrary formulas are logically valid."
14:33:40 <byorgey> mun_: undecidable just means "not decidable".  something can be both undecidable and semidecidable.
14:35:04 <byorgey> a decision procedure has to say yes or no in a finite amount of time for any input.  If no such decision procedure exists, it is undecidable.  But there might still exist a semidecision procedure which always says "yes" when the answer is yes but might loop otherwise
14:36:27 <mun_> byorgey, right. ok.
14:37:13 <byorgey> mun_: also, if provability is semidecidable for FOL, then validity must be as well, since by Goedel's completeness theorem for FOL validity <=> provability.
14:37:37 <Favonia> does anyone have ideas about wrapping the ibus library (an input-method framework)? it seems that ibus is using glib version of dbus (and other glib types too), but afaik the dbus part is not wrapped in the glib hackage. how should I do the wrapping so that it will work well with other hackages?
14:44:33 <k0ral> how can I emit a signal in gtk2hs ?
14:45:51 <Eduard_Munteanu> I wonder if there's some efficient tree-like representation for what dankna wants.
14:45:56 <Eduard_Munteanu> I.e. fast mutation.
14:46:07 <Eduard_Munteanu> s/fast/cheap/
14:47:42 <Eduard_Munteanu> Well, in essence a Map.
14:48:18 <acowley> What's the argument against an ST array? The heap indirection?
14:48:19 <Eduard_Munteanu> (but I don't know how cheap it is to mutate a plain Map in terms of space)
14:48:28 <Eduard_Munteanu> I'd go with ST stuff too.
14:48:35 <dankna> acowle: the argument against an ST array is that nobody suggested it a week ago when I was picking an approach :)
14:48:43 <acowley> oh
14:48:48 <Eduard_Munteanu> The only inconveninet is you have to take care of the phantom 's' there
14:48:50 <acowley> I'd like to suggest an ST array
14:48:55 <Eduard_Munteanu> :)
14:49:10 <Saizan> you'd need several STRef's since ST arrays are uniform
14:49:19 <dankna> yes, I'd need many STRefs, one for each field
14:49:24 <dankna> it would be a lot of TH work to set it up that way
14:49:51 <acowley> Hm. I feel like unsafeCoerce is going to make an appearance.
14:49:56 <dankna> not that this approach wasn't a lot of TH work, but at least I've done it :)
14:50:08 <Eduard_Munteanu> I wonder whether we could avoid making 's' explicit if we had implicit arguments like in Agda.
14:50:22 <Saizan> the phantom s can be hidden in the monad definition in this case, fortunately
14:50:49 <Saizan> as long as you provide explicit get/putFieldX combinators
14:51:23 <Eduard_Munteanu> I remember doing something like that, with some STRef-based trees, and I couldn't make 's' go away.
14:51:59 <Eduard_Munteanu> Hopefully this is a different pattern.
14:52:03 <Saizan> depends on how you use the STRef's
14:53:11 <Saizan> newtype Foo a = Foo (forall s. (STRef s FieldX, STRef s FieldY) -> ST s a)
14:56:19 <Eduard_Munteanu> BTW, is there any mutable tree lib for Haskell?
14:57:38 <Eduard_Munteanu> Say, some STTree.
14:58:22 <pastorn> Eduard_Munteanu: there's always HashMap :)
14:58:30 <pastorn> Eduard_Munteanu: bucketfulls of fun
14:58:42 <pastorn> <-- fannei gai
15:00:10 <joe6> hello, I am trying to join these 2 functions together: http://pastebin.com/0QZ84YYr, to get this function type: .... :: InHandle -> OutHandle -> Test
15:00:14 <joe6> any thoughts, please?
15:00:21 <obbele> [23:45] < byorgey> mun_: undecidable just means "not decidable".  something can be both undecidable and semidecidable.
15:00:25 <obbele> [23:46] < byorgey> a decision procedure has to say yes or no in a finite amount of time for any input.  If no such decision procedure exists, it is
15:00:28 <obbele>                    undecidable.  But there might still exist a semidecision procedure which always says "yes" when the answer is yes but might loop
15:01:15 <obbele> oki that's what I get if I try to copy& paste from putty
15:01:18 <ktosiek> joe6: TestLabel "test" . isDWPCommand
15:01:20 <ktosiek> ?
15:01:42 <obbele> sorry everyone for the garbage
15:01:51 <byorgey> obbele: no worries =)
15:02:10 <joe6> ktosiek: tried that, but, it says: http://pastebin.com/fP8eSKPa
15:02:11 <byorgey> joe6: \in out -> TestLabel "test" $ isDWPCommand in out
15:02:26 <joe6> oh, gotcha..
15:02:32 <joe6> I need an undefined in theer.
15:02:37 <joe6> s/theer/there
15:02:41 <joe6> sorry about taht..
15:02:45 <byorgey> undefined?
15:03:01 <ezyang> Hmm, I'm looking for a list-like data structure with efficient access to both ends, and an efficient "split" operation on some index.
15:03:16 <acowley> Seq?
15:03:16 <ezyang> As well as efficient concatenation. I may be asking for too much ^_^
15:03:41 <joe6> byorgey, i have a list of functions of the type :: InHandle -> OutHandle -> Test
15:03:56 <joe6> byorgey, so I am trying to get this function to that format too.
15:04:06 <joe6> i could do the lambda thing you mentioned.
15:04:13 <ktosiek> ezyang: skip list?
15:04:22 <ezyang> Hm, Seq might work reasonably well.
15:04:23 <joe6> byorgey: but, just curious if there is a shorter way of doing so.
15:04:32 <ktosiek> but I don't know about implementations
15:04:35 <byorgey> ezyang: sounds precisely like Data.Sequence to me
15:05:25 <byorgey> joe6: well, you can write  ((TestLabel "test") .) . isDWPCommand  but I don't recommend it
15:05:59 <byorgey> because it's ugly and hard to grok.
15:06:05 <joe6> byorgey, that is pretty cool.
15:06:26 <joe6> does exactly what I need. but, yeah, I will have no clue about what it does next week.
15:07:19 <hickster> whois hickster
15:11:35 <dankna> Saizan: Okay, your solution doesn't reduce memory usage and I think I know why
15:12:23 <dankna> Saizan: the newtype accessor still has all those fields in its type signature, and is called twice by the definition of >>=
15:12:59 <dankna> The latest profile attributes most of the time and allocation to the newtype accessor
15:13:10 <dankna> http://dankna.com/himtsu/emulator.prof.not-smaller.txt
15:13:30 <dankna> er
15:13:32 <dankna> http://dankna.com/himitsu/emulator.prof.not-smaller.txt
15:13:50 <joe6> i have something like this: http://pastebin.com/qKCNgzSf . any thoughts on how I can remove the "hin hout" at the end of each item? http://pastebin.com/Pisg8KiD
15:14:34 <joe6> i tried map ($ hin hout), but that does not seem to fly. I could do a \x -> x hin hout
15:14:43 <joe6> just curious if there was something better than that.
15:14:56 <c_wraith> well, map ($ hin hout) isn't even close to right.
15:15:04 <c_wraith> mapping the lambda is correct
15:15:19 <c_wraith> but you can't apply two args with ($ arg1 arg2)
15:15:25 <Saizan> dankna: that shouldn't really matter, though ghc's stack mechanism might not scale to this many arguments
15:15:25 <pastorn> joe6: let h f = f hin hout in ... [ h (lol), h (lulz) ... ]
15:15:54 <c_wraith> What you're doing is more like map (($ hout) . ($ hin))
15:15:55 <acowley> :t \x y -> ($ (x,y) . uncurry)
15:15:56 <lambdabot>     Couldn't match expected type `a -> b'
15:15:57 <lambdabot>            against inferred type `(t, t1)'
15:15:57 <lambdabot>     In the first argument of `(.)', namely `(x, y)'
15:16:10 <acowley> :t \x y -> (($ (x,y)) . uncurry)
15:16:11 <lambdabot> forall b a b1. a -> b1 -> (a -> b1 -> b) -> b
15:16:11 <pastorn> @pl (\f -> f hin hout)
15:16:12 <lambdabot> flip ($ hin) hout
15:16:25 <pastorn> ^^^^ joe6
15:16:32 <acowley> yeah, pastorn's is better
15:16:32 <c_wraith> that's...  realy ugly :)
15:16:38 <c_wraith> *really
15:16:40 <dankna> Saizan: what's your opinion on the STRef solution?  is it likely to work better than this?
15:17:05 <acowley> The good part of writing unreadable code is that the temptation to tweak it is lessened
15:17:06 <pastorn> joe6: "let h f = f hin hout; in [ h (fun0), h (fun1) ... ]
15:17:36 <joe6> oh, ok. I need the h (..) for each item..
15:17:44 <pastorn> joe6: yes
15:17:59 <pastorn> joe6: *maybe* you could map it
15:18:03 <pastorn> i dunno
15:18:04 <Saizan> dankna: i think it's more predictably good since it's doing something much more conventional
15:18:12 <joe6> i tried the map, but it does not work.
15:18:21 <c_wraith> depends on if the functions can all unify to the same type
15:18:32 <pastorn> joe6: map (\f -> f hin hout) funs ?
15:18:56 <dankna> Saizan: Logical enough.  Okay.  Then I'll try with STRefs.  Thank you for advising me on this approach though!  It's imo prettier than the STRef way.
15:19:05 <joe6> like this: http://pastebin.com/v0qDmeVq , gives me http://pastebin.com/f9U7QSrY
15:19:55 <Saizan> dankna: yeah, it might be worth to grab some ghc hacker and ask his/her opinion on why it doesn't perform well
15:20:06 <pastorn> joe6: why not paste it all in one? i hear all the hip indie kidz these days are using comments
15:20:17 <dankna> Saizan: good thought, I'll go ask in #ghc if they haven't all gone to sleep there already (they're mostly on Europe time)
15:20:25 <joe6> pastorn, haha..
15:21:02 <Saizan> dankna: yeah :)
15:21:03 <pastorn> joe6: change the $ on line 5 to a .
15:21:55 <Saizan> dankna: i wonder how readable is the core
15:22:08 <dankna> Saizan: to me?  not even remotely readable.  I looked.
15:25:21 <ezyang> Twiddle dee, twiddle doo. http://hpaste.org/46984/douglas_pucker
15:26:25 <dankna> Saizan: hmm....  is >>= recursive?  is that related, do you think?  (people in #ghc seem asleep)
15:27:17 <Saizan> dankna: how would it be?
15:27:39 <dankna> well, if we have do { a ; b ; c }, doesn't that expand to (a >>= b) >>= c ?
15:28:00 <acowley> a >> b >> c
15:28:07 <dankna> yes, assume I actually used the values there
15:28:26 <joe6> pastorn, tried that. this is what it says: http://pastebin.com/zz0XXu6j for this code http://pastebin.com/ryiJvqTf
15:28:36 <acowley> I'm actually not 100% sure about the associativity
15:28:47 <dankna> do { a <- getA ; b <- getB a ; c < getC b } ==> (a >>= b) >>= c
15:28:50 <acowley> which shouldn't change the result, but can affect performance
15:29:07 <pumpkin> mm_freak: wouldn't    joinFoldables :: (Foldable t, MonadPlus m) => m (t a) -> m a be nicer than    joinFoldables :: (Alternative m, Foldable t, Monad m) => m (t a) -> m a
15:29:07 <pumpkin>  ?
15:29:21 <dankna> surely it's left-associative; as you say, the opposite would be terrible for performance
15:29:26 <pumpkin> mm_freak: then you could just use msum
15:29:31 <mm_freak> pumpkin: only its type signature would be nicer
15:29:41 <joe6> pastorn, just the second error. please ignore the first error.
15:29:41 <mm_freak> pumpkin: there is also asum
15:29:57 <joe6> pastorn, just this: http://pastebin.com/j0C7uTqq
15:30:03 <pumpkin> mm_freak: yeah, but it saves you from straddling the "two hierarchies" of the "plus" things
15:30:13 <acowley> dankna: There was a sigfpe blog post where he got into this a bit and ran into performance problems due to the associativity resulting from do syntax, so he had to expand out the >>=s manually and the code got faster and uglier :/
15:30:14 <pumpkin> which should admittedly be one
15:30:15 <pumpkin> but aren't
15:30:20 <joe6> pastorn, anyway, just ignore it. i will stick with the end hin and hout.
15:30:24 <Saizan> dankna: it's getA >>= \a -> getB >>= \b -> getC >>= \c -> ...
15:30:39 <dankna> acowley: hmmm........ that's interesting.  not an option for me as the code in question is about 300 lines (!)
15:30:46 <mm_freak> pumpkin: i think doing that contributes to a less braindead base library in the future
15:31:21 <Saizan> dankna: with your monad it doesn't matter anyway, it all ends up right-associated and that's part of the point of it
15:31:24 <dankna> Saizan: okay.  I guess that's right-associative actually.
15:32:14 <dankna> Saizan: hmm, because I had been thinking that maybe >>= was being lazily evaluated or something
15:32:24 <pastorn> joe6: oh, you need tits
15:32:39 <pastorn> @let tits = ((.).(.))
15:32:40 <lambdabot>  Defined.
15:32:43 <pastorn> @type tits
15:32:44 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:33:05 <joe6> pastorn, that is very funny.
15:33:15 <Saizan> dankna: how is one of your field accessors implemented, btw?
15:33:27 <dankna> Saizan: oh, one sec
15:33:29 <Favonia> pastorn: haha
15:33:48 <Saizan> dankna: and setter too
15:33:56 <mm_freak> base 5.0 should really fix the functor class hierarchy
15:34:10 <mm_freak> it's a new major release, so there is really no reason to refrain from that
15:34:38 <dankna> getFoo = MonadicState (\continuation field0 ... field49 -> continuation field<desired> field0 ... field49)
15:34:51 <pastorn> joe6: you might need "f `tits` Constructor"
15:34:54 <blackdog> pastorn: is that a mole in the middle?
15:35:01 <dankna> putFoo value = MonadicState (\continuation field0 ... field49 -> continuation () field0 ... <value in here somewhere> ... field49)
15:35:22 <joe6> pastorn: ok, thanks.
15:35:27 <pastorn> blackdog: i leave the discerning of that as an exercise to the reader
15:37:14 <pastorn> @type on
15:37:15 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
15:37:57 <mauke> :t it's on
15:37:58 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
15:39:13 <Favonia> @type it's
15:39:14 <lambdabot> forall a. a -> a
15:39:35 <mauke> > it's True
15:39:36 <lambdabot>   True
15:41:54 <Saizan> dankna: something that might make some difference, though it depends on the optimizer not undoing it, is breaking up those lambdas in two; "... MonadicState (\continuation -> \ field0 .. field49 -> continuation ...)"
15:42:14 <Saizan> dankna: maybe i should make my own synthetic benchmark to try my theories :)
15:42:25 <dankna> Saizan: I'd be appreciative :)
15:43:20 <dankna> it's probably much faster to do it in a benchmarking program than to do it in my codebase, since the benchmark version won't have to go through TH or my custom build system
15:43:55 <Saizan> yeah
15:45:38 <Saizan> http://hpaste.org/46653/optimization_one_hopes <- this was showing the same problem, right?
15:46:32 <dankna> I think so, but let me run it to be sure.  there was at least one version of that program which turned out to actually perform quite well :)
15:48:01 <dankna> yes, it does exhibit the problem
15:48:22 <dankna> note that to see it you have to run with profiling, as it doesn't have difficulty with runtime
15:48:35 <dankna> but if you run it you'll see that it's allocating 3.4G
15:48:41 <dankna> (maybe half that on 32-bit)
15:51:12 <Saizan> it's performing very well here though.. 1MB total memory in use, no GC time
15:51:18 <dankna> huh!
15:51:22 <dankna> version of ghc?  architecture?
15:51:49 <dankna> wait, you need to be looking at total allocation.  there's no space leak in it, so yes, it won't have high peak usage.
15:52:08 <Saizan> 1,310,815,184 bytes allocated in the heap
15:52:17 <Saizan> i guess that's high
15:52:18 <Saizan> ?
15:52:27 <dankna> reasonably high :)
15:53:57 <dankna> alternatively, it's within conception that the high allocation rate isn't the cause of my slow execution
15:54:37 <dankna> but after several lengthy discussions in here, it was the most obvious remaining suspect
16:18:54 <int80_h>  ghc -package Graphics.Gnuplot.Execute Demo.hs
16:18:54 <int80_h> <command line>: cannot satisfy -package Graphics.Gnuplot.Execute
16:18:54 <int80_h>     (use -v for more information)
16:18:54 <int80_h> mlitchard@apotheosis:~/.cabal/packages/hackage.haskell.org/gnuplot/0.4.2/gnuplot-0.4.2/src$ ghc --make Demo.hs -package Graphics.Gnuplot.Execute
16:18:58 <int80_h> <command line>: cannot satisfy -package Graphics.Gnuplot.Execute
16:19:00 <int80_h>     (use -v for more information)
16:19:03 <int80_h> mlitchard@apotheosis:~/.cabal/packages/hackage.haskell.org/gnuplot/0.4.2/gnuplot-0.4.2/src$ ghc --make Demo.hs -package Graphics
16:19:06 <int80_h> <command line>: cannot satisfy -package Graphics (use -v for more information)
16:19:09 <int80_h> mlitchard@apotheosis:~/.cabal/packages/hackage.haskell.org/gnuplot/0.4.2/gnuplot-0.4.2/src$ ghc --make Demo.hs -package Graphics.Gnuplot
16:19:12 <int80_h> <command line>: cannot satisfy -package Graphics.Gnuplot
16:19:15 <int80_h>     (use -v for more information)
16:19:17 <int80_h> sorry
16:19:20 <int80_h> http://hpaste.org/46986/trying_to_expose_a_hidden_pack
16:19:22 <dankna> yeah, was about to say
16:20:24 <int80_h> dankna: any ideas about my problem?
16:20:29 <dankna> int80_h: you seem to be confused between packages and modules
16:20:43 <int80_h> dankna: I'll accept that
16:20:51 <dankna> a package is a bundle of modules
16:21:00 <dankna> a module is a single source file existing in a hierarchical namespace
16:21:04 <int80_h> this is the error I get when I just try to ghc --make Demo.hs
16:21:48 <Favonia> int80_h: in short, Graphics.Gnuplot is a module in the package gnuplot
16:22:09 <dankna> ghc --make Demo.hs -package gnuplot # maybe
16:22:19 <int80_h> I'll paste the error message I got initially.
16:22:23 <dankna> (to use the installed copy of gnuplot)
16:23:19 <int80_h> http://hpaste.org/paste/46986/trying_to_expose_a_hidden_pack#p46987
16:23:28 <dankna> yeah, try what I said
16:23:30 <int80_h> okay let me try that
16:23:59 <int80_h> dankna: nope, it's still a hidden module
16:24:45 <dankna> that's very curious; please hpaste the complete error
16:24:55 <int80_h> this compiles fine when using cabal, but it ignores my Demo.hs and seems to just download a new file to compile
16:24:58 <Peaker> the cereal package has: Get and Putter.. thinking of it, it sounds like the Getter monad would be a better name than the Get monad
16:25:02 <Peaker> Getter and Putter
16:25:28 <int80_h> dankna: I believe I pasted the complete error. What appears to be missing?
16:25:36 <tg_> ok, I've done LYAH. Can I get a similarly-awesome tutorial on the ins, outs, and pitfalls of cabal?
16:25:47 <dankna> int80_h: I'm wondering whether the error might be subtly different with the "-package gnuplot" in the command line
16:25:50 <jeffz> tg
16:25:59 <jeffz> tg_: try making your own .cabal and see how you fair :)
16:26:11 <tg_> jeffz: i mean using it to download install and manipulate packages
16:26:41 <int80_h> dankna: http://hpaste.org/paste/46986/trying_to_expose_a_hidden_pack#p46988
16:26:52 <Eduard_Munteanu> Hrm, #haskell-math is still alive, though barely
16:26:52 <tg_> last time I used cabal, it was very frustrating - though this was before Haskell Platform
16:27:24 <int80_h> tg_ I find the cab package to be a nice layer above cabal.
16:27:30 <dankna> that's bizzare
16:27:41 <jeffz> tg_: which part was frustrating?
16:27:55 <Eduard_Munteanu> Anyway, I kinda check that out whenever I think "screw Matlab/Octave, there must be something better" :)
16:27:55 <tg_> ok, also - can I get an enumeration of libraries that I should *always* be using, like: haddock, quickcheck, hint
16:28:14 <Eduard_Munteanu> Maybe I should auto-join
16:28:16 <tg_> jeffz: don't remember the specifics, getting it to run without installing haskell
16:28:25 <c_wraith> tg_: hint isn't even close to always-use.  are you thinking hlint?
16:28:27 <tg_> Eduard_Munteanu: I'm working on it right now, and so is luite
16:28:46 <tg_> c_wraith: indeed I do
16:28:59 <tg_> c_wraith: indeed I am
16:29:02 <tg_> what else is there...
16:29:09 <int80_h> dankna: is there a way to use ghc-pkg to do the same this here?
16:29:13 <tg_> a performance monitoring / visualizing tool, if I remember correctly?
16:29:19 <int80_h> dankna: s/this/thing
16:29:22 <Eduard_Munteanu> Of course, I'm not even going to bother until you get a 'control' package :)
16:29:34 <dankna> int80_h: ghc-pkg will make permanent changes that persist until reversed and affect all compilations you attempt; I don't suggest using it for this
16:29:38 <Eduard_Munteanu> (which isn't great in Octave either)
16:30:03 <jeffz> tg_: threadscope? not always necessary.
16:30:17 <tg_> jeffz: but it's pretty
16:30:33 <int80_h> dankna: I suppose if I knew how to decipher a .cabal file correctly I could figure out what cabal is passing to ghc. I looked at it and it's a fairly complex file, to me.
16:30:55 <dankna> int80_h: invoke it as "cabal build -v"
16:31:09 <dankna> int80_h: that will cause it to spit out a list of the commands it executes (note that this list may be extremely verbose)
16:31:33 <int80_h> dankna: wants the configure commands run first
16:31:38 <dankna> "cabal configure"
16:32:32 <zuserm> I had an idea for some syntactic sugar and was wondering what other people thought. Basically: expr {} => \x -> expr x
16:33:26 <dankna> zuserm: I see neither a problem solved by your proposal, nor how it generalizes to more than one argument.  I'm also confused at how it knows where the start of the expr is.
16:33:28 <zuserm> examples: run p a = readProcess p a "" <= run = readProcess {} {} "", map (\n -> [1..n]) <= map [1..{}]
16:34:02 <dankna> ... what?
16:34:14 <dankna> start with [1..{}], what is that?
16:34:29 <mauke> zuserm: why is map [1 .. {}] not (\n -> map [1 .. n])?
16:34:51 <dankna> oh I see, your <= means "would be replaced by, under my proposal"
16:34:58 <dankna> and your comma delimits two separate examples
16:35:26 <zuserm> yeah sorry
16:35:30 <pumpkin> you get all the issues you get with scala
16:35:36 <pumpkin> which is that nobody knows where the _ binds
16:35:39 <dankna> okay, I understand your examples.  basically, I don't see a usage scenario.
16:36:09 <zuserm> by expr I just meant the first function that's being applied
16:36:36 <dankna> what about this though:
16:36:42 <int80_h> dankna: This is the command it wants you to use to build the Demo.hs file "cabal install -fbuildExamples gnuplot" is it possible that doing a "cabal build -v" will not have the flags it uses to build Demo.hs since the buildExamples flag wasn't passed?
16:36:51 <dolio> As far as I can tell, in scala it looks for the nearest enclosing parentheses.
16:36:57 <dolio> Or something similar.
16:37:04 <dankna> int80_h: yes that is possible; to correct that, do "cabal configure -fbuildExamples" first
16:37:19 <zuserm> I wan't aware there was something similar in scala, I'll take a look.
16:37:33 <dankna> zuserm: let foo = bar (baz {})
16:37:35 <dankna> does this mean:
16:37:43 <dankna> let foo = bar (\a -> baz a)
16:37:52 <dankna> let foo = (\a -> bar (baz a))
16:38:04 <dankna> (\a -> let foo = bar (baz a))
16:38:06 <zuserm> yeah, f {} = f
16:38:20 <dankna> so you want it to bind to the closest thing
16:38:20 <dolio> I don't think it's a particularly good feature, except that scala probably handles inference of 'foo(_)' better than 'x => foo(x)'.
16:38:23 <dankna> how, then, is that useful
16:38:29 <mauke> zuserm: then your readProcess example doesn't work
16:38:36 <dankna> won't it usually be the case that you want it to bind to something a few steps away
16:38:41 <dankna> and you have no means of specifying that
16:38:59 <int80_h> dankna: okay it actually tried to build my Demo.hs, which is broken. But that's progress!
16:39:04 <dankna> int80_h: good :)
16:39:43 <zuserm> the use case is partial application of args that not at the beggining
16:39:57 <mauke> you just said f {} = f
16:40:05 <mauke> therefore f {} x = f x
16:40:47 <dolio> It's context sensitive.
16:41:01 <zuserm> mauke: opps sory, I meant f {} = \x -> f x, so f {} y = \x -> f x y
16:41:10 <mauke> so... does that mean f {} x /= (f {}) x?
16:41:29 <zuserm> by = I mean syntacticly
16:42:03 <zuserm> that's an interesting point
16:44:28 <identity_> IS there no guard-like function for IO? As I understand it, you can't use guard for IO because it isn't an instance of MonadPlus
16:44:44 <mauke> that would surprise me
16:44:49 <identity_> I basically want guard (condition) *else cry havoc*
16:44:51 <dolio> IO is a MonadPlus.
16:44:53 <shachaf> identity_: What would you want it to do?
16:44:54 <identity_> wat
16:45:02 <dolio> @instances MonadPlus
16:45:02 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:45:07 <identity_> oh
16:45:12 <identity_> Then I remembered incorrectly
16:45:15 <identity_> Too rusty :(
16:45:20 <shachaf> dolio: Where is that instance declared?
16:45:38 <dolio> In Control.Monad, probably.
16:45:48 * shachaf doesn't seem to have it here in ghci.
16:45:51 <dolio> Unless MonadPlus is in the prelude. I forget.
16:47:21 <dolio> Did it get removed in 7?
16:47:26 <dolio> @version
16:47:26 <lambdabot> lambdabot 4.2.2.1
16:47:26 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:47:48 * shachaf is running 6.12.1.
16:48:01 <zuserm> so verdict: problematic
16:48:28 <zuserm> oh well
16:49:13 <int80_h> dankna: do you have any suggestions as to how to get this in ghci so I can start examining types?
16:49:34 <dolio> Oh, it's in Control.Monad.Trans.Error
16:49:54 <shachaf> Oh.
16:50:03 <dolio> Or probably Control.Monad.Error if you're on an old enough version of mtl.
16:50:10 <dankna> int80_h: running "cabal build -v" will give you a list of commands along the lines of "irrelevant; irrelevant; irrelevant; ghc blah blah blah Demo.hs; irrelevant; irrelevant; irrelevant"
16:50:25 <dankna> int80_h: take the line "ghc blah blah blah Demo.hs" and change ghci to ghci, then call it from the shell
16:50:36 <dankna> (may have to take out -o foo)
16:50:41 <shachaf> And mzero throws an ioError and mplus a b handles an ioError in a by running b?
16:51:04 <identity_> Hmm. Getting overlapping instances for MonadPlus IO, from C.M.Error and ..Trans.Error
16:51:19 <identity_> importing Control.Monad, Control.Monad.State
16:51:24 <identity_> and some other packages
16:51:29 <identity_> What is the best way to deal with this?
16:58:41 <identity_> Anyone?
16:59:12 <parcs> what version of mtl are you using?
16:59:15 <identity_> sec
17:00:08 <identity_> 1.1.0.2
17:00:10 <identity_> Guess that's old
17:00:16 <identity_> seems 2.0.1.0
17:00:19 <identity_> is newest
17:00:19 <parcs> yep
17:00:22 <parcs> update! :)
17:00:31 <identity_> thanks ;)
17:01:07 <dolio> mtl 2 and above uses the transformers package.
17:01:36 <dolio> If you were using C.M.E.Trans and C.M.Error with mtl < 2, you were getting instances from two different packages.
17:01:49 <identity_> I'm not using either
17:01:49 <dolio> C.M.T.Error, even.
17:02:08 <identity_> oh..
17:02:24 <identity_> Now it says the same thing, except it's referring to the old version. Some package must be using it.
17:02:27 <identity_> sec
17:02:56 <identity_> http://hpaste.org/46989/mtl_madness
17:03:57 <identity_> I reiterate, only using Control.Monad and C.M.State + Control.Concurrent.Chan, then tagsoup, http.enumerators
17:04:01 <identity_> THen some others that probably don't matter
17:05:17 <parcs> after updating mtl try cabal-installing all other packages you're importing
17:05:25 <identity_> kk
17:07:11 <identity_> No such luck.
17:08:29 <identity_> actually, never mind.
17:08:30 <identity_> That worked
17:08:32 <identity_> Forgot one package.
17:08:34 <identity_> Thanks a bunch!
17:08:42 <parcs> yay!
17:08:53 <identity_> And there was much rejoicing
17:17:14 <mcksds>  Without Bone Marrow, can red blood cells still produce by supplements ?
17:17:33 <QtPlatypus> mcksds: I think you have the wrong channel.
17:18:19 <zuserm> Is the bone marrow in IO?
17:23:14 <joe6> is there a function that can get the last 3 characters of a string ~ drop ((length xs) - 3) xs
17:23:44 <hpc> > tails [1..5]
17:23:45 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
17:24:34 <hpc> joe6: you have your solution, give it a name and move on? :P
17:26:30 <luite> that solution isn't very good...
17:26:41 <dolio> It leaks space.
17:27:54 <zuserm> how about: reverse . take 3 . reverse ?
17:28:40 <joe6> zuserm, i like that.
17:29:25 <hpc> doesn't reverse leak space?
17:29:51 <c_wraith> no.
17:29:58 <c_wraith> it does force the entire list, though
17:30:04 <c_wraith> (well, the spine, not the values)
17:30:11 <NisseP> then again so does length
17:30:14 <c_wraith> right
17:30:17 <hpc> how does the former leak space?
17:30:25 <zuserm> if you want the last 3 values, there's no way around it
17:30:36 <dolio> > let ziggy n l = stardust (drop n l) l where stardust [] ys = ys ; stardust (_:xs) (_:ys) = stardust xs ys in ziggy 3 [1..20]
17:30:37 <lambdabot>   [18,19,20]
17:30:40 <c_wraith> zuserm: not true.  Pattern match on 3-from-the-end. :)
17:30:58 <c_wraith> zuserm: it forces the whole list, but doesn't keep it all in memory
17:31:34 <zuserm> hpc: it has to hold on to xs to apply drop to it, while it does the length
17:31:50 <hpc> zuserm: ah
17:32:07 <NisseP> dolio: i like that :)
17:32:08 <c_wraith> the double-reverse case does hold on to the whole list at once, also
17:32:34 <hpc> wait, now i am really confused
17:32:38 <c_wraith> So I guess it's a space leak, in that sense.
17:32:55 <dolio> It doesn't hold on to the original list, but it builds up one just as big.
17:32:55 <c_wraith> reverse forces the entire spine of the list at once.
17:33:13 <c_wraith> right, holding the entire reverse.
17:33:19 <dolio> Yeah.
17:36:50 <ezyang> Are there any well known monads for which >> does not turn into a tail call of its right argument?
17:37:36 <zuserm> c_wraith: you're right, not sure why I thought it woudn't have to
17:38:37 <dolio> ezyang: Free monads, probably.
17:39:02 <dolio> And Writer?
17:39:24 <ezyang> Oh really, writer?
17:39:46 <dolio> (w, a) >> (w', b) = (w ++ w', b)?
17:40:04 <c_wraith> yeah, that's the correct expansion of Writer
17:40:15 <c_wraith> and not a tail call.
17:40:34 <ezyang> yesss. I wonder if you could CPS transform that.
17:40:49 <dolio> Of course.
17:40:59 <c_wraith> well.  correct given \bot's definition of ++, anyway
17:41:36 <dolio> The correct definition of (++). :)
17:42:20 <joe6> > (showHex $ ((shiftL (read "0x4") 16) :: Int) ):: String
17:42:21 <lambdabot>   Couldn't match expected type `GHC.Base.String'
17:42:21 <lambdabot>         against inferred typ...
17:43:04 <joe6> > (showHex $ ((shiftL (read "0x4") 16) :: Int) )
17:43:04 <lambdabot>   Overlapping instances for GHC.Show.Show
17:43:04 <lambdabot>                              (GHC.B...
17:43:26 <joe6> > printf "0x2x" ((shiftL (read "0x4") 16) :: Int)
17:43:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:43:27 <lambdabot>    `GHC.Show.Show a'
17:43:27 <lambdabot>      a...
17:43:44 <joe6> > printf "0x2X" ((shiftL (read "0x4") 16) :: Int)
17:43:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:43:45 <lambdabot>    `GHC.Show.Show a'
17:43:45 <lambdabot>      a...
17:44:30 <joe6> > printf "%02x" ((shiftL (read "0x4") 16) :: Int)
17:44:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:44:31 <lambdabot>    `GHC.Show.Show a'
17:44:31 <lambdabot>      a...
17:44:45 <dolio> Return _ >> fb = fb ; Roll m >> fb = Roll ((>> fb) <$> m)
17:44:47 <joe6> > printf "0x%02x" ((shiftL (read "0x4") 16) :: Int)
17:44:47 <Saizan> > showHex ((shiftL (read "0x4") 16) :: Int) ""
17:44:48 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:44:48 <lambdabot>    `GHC.Show.Show a'
17:44:48 <lambdabot>      a...
17:44:48 <lambdabot>   "40000"
17:44:50 <dolio> For free monads, I think.
17:45:18 <dolio> That doesn't look bad, though.
17:45:20 <joe6> > showHex ((shiftL (read "0x4") 16) :: Int) ""
17:45:21 <lambdabot>   "40000"
17:45:30 <joe6> Saizan: thanks
17:47:12 <poincare101> I wish haskell was used more in the industry...
17:53:19 <zuserm> paincare101: any specific reason?
17:55:58 <lispy> Which industry?  Finance uses it a LOT
17:56:53 <dankna> you should be more direct with what you're trying to get at.  for example, "I wish I were used more in the industry" :)
17:57:17 <hpc> it would be interesting if all php programmers were replaced overnight with haskell programmers
17:57:33 <dankna> can't happen.  there will always be languages catering to beginners.
17:57:58 <hpc> duh, i mean what would happen to websites
17:58:29 <dankna> or to put it another way, replacing phpers with haskellers would be (on average) replacing beginners with experts, which would both result in overdesigned websites and divert effort from novel research :)
17:58:40 <hpc> :P
17:58:46 <dankna> but yes, the web would be much more interesting
17:59:10 <hpc> i would think it would reduce overdesign
17:59:17 <hpc> or at least, reduce feature-creep
17:59:19 <identity_> I have some state containing some chans, and then some integers I'm using for counters. I've found the need to be able to incrememnt those counters, but I can't think of a way to do this without having to do some ugly pattern matching on the state using modify, and/or writing a seperate function for each integer
17:59:20 <dankna> well, once we got used to the problem domain, yes
17:59:24 <identity_> anyone have an idea?
17:59:26 <hpc> look at all the junk phpbb has
17:59:47 <dankna> at first we'd spend our time reinventing old ideas that were new to us
18:00:04 <identity_> I will brb for a sec..
18:00:13 <hpc> in all honesty, we might end up just reinventing php
18:00:16 <hpc> except with types
18:00:27 <dankna> heh, well, it would be an improvement at least
18:00:34 <lispy> Have you seen Ur?
18:00:44 <dankna> no
18:00:50 <hpc> static websites would be static again
18:00:51 <lispy> dependently typed language that targets a similar niche to php
18:00:58 <hpc> less silly cms stuff behind the scenes
18:01:00 <dankna> huh, nice
18:01:06 <hpc> fewer injection exploits too
18:01:12 <lispy> http://www.impredicative.com/ur/
18:03:27 <dolio> Wow, he got impredicative.com.
18:03:53 <hpc> go to the site root
18:03:56 <hpc> it's the name of his company
18:04:01 * hpc jelly
18:09:29 <Veinor> what's the standard library for doing type-level nats?
18:26:52 <absentia> xn/win shrink 3
18:28:00 <dylukes> I do Nat's like this.
18:28:01 <dylukes> because I'm weird.
18:28:02 <dylukes> https://gist.github.com/988009
18:28:04 <dylukes> Veinor: *
18:28:28 <Veinor> that's not really type-level though
18:28:35 <dylukes> What do you mean?
18:28:40 <Veinor> i wanted something more like
18:28:44 <Veinor> data Z; data S n;
18:28:55 <Veinor> using EmptyDataDecls
18:28:56 <aavogt> different numbers are different types
18:29:08 <dylukes> aavogt: Oh, :\
18:29:10 <aavogt> there is such a definition in HList
18:29:52 <aavogt> but I think there are some libraries with their own definitions that also have classes for more math and other fancy operations on them
18:30:26 <dylukes> I'm not sure I quite understand >_<
18:34:31 <lispy> Veinor: ghc is getting type level nats as an extension
18:34:52 <lispy> Veinor: http://hackage.haskell.org/trac/ghc/ticket/4385
18:34:53 <Veinor> yaaaaaay
18:35:01 <shachaf> dylukes: Which part? Weren't you just doing Agda recently?
18:35:45 <dylukes> shachaf: Nevermind, I got it now.
18:35:50 <dylukes> and just the very very basics ^^
18:38:39 <lispy> Is that another way of saying all I've done so far is, wade through broken tutorials, get overwhemled with unicode, and wondered about how types work?
18:39:11 <lispy> That's how it went when I tried to learn the very very basics of Agda
18:40:12 * lispy has learned more about Agda from hearing other use it than from the morass of broken documentation
18:40:30 <caylee> Eh? I haven't had any trouble with Agda docs recently.
18:41:45 <lispy> caylee: this one (released in late 2009) is broken: Ana Bove, Peter Dybjer, and Ulf Norell. A Brief Overview of Agda - A Functional Language with Dependent Types (in TPHOLs 2009) with an example of reflection. Code
18:41:48 <lispy> That's from the agda wiki
18:41:58 <lispy> I've had issues with some of the other ones too
18:42:10 <lispy> Universe polymorphism changes breaks a lot of things
18:42:35 <lispy> The standard library gets reorginazied with each release so you have to use just the right version (which can be hard to figure out)
18:42:42 <copumpkin> lispy: it only breaks what turns yellow
18:42:50 <copumpkin> lispy: nothing else should really change because of it
18:42:56 <copumpkin> ...that I can think of
18:43:09 <caylee> lispy: Hrmm...I just did most of the tutorials not that long ago (although perhaps not that one?) and it seemed fine.
18:43:33 <caylee> And by not that long ago I mean "within three months"
18:44:28 <crest> hi
18:44:31 <lispy> What version of Agda did you install?
18:44:44 <caylee> the most recent release
18:44:50 <lispy> That's the one I tried too
18:45:05 <copumpkin> lispy: did you have actual type errors or just yellowness?
18:45:10 <crest> i'm trying to install leksah from cabal but it fails with '<command line>: cannot satisfy -package-id leksah-0.10.0.4
18:45:11 <lispy> I checked that tutorial in 2010 and it was broken, then I checked it again with in the last 3 months
18:45:18 <crest> ' and 'ExitFailure 1'
18:45:20 <copumpkin> cause the basic types really haven't changed
18:45:32 <lispy> copumpkin: Type errors for sure
18:45:37 <copumpkin> o.O
18:45:46 <caylee> Ah, so it was version 2.2.10 that I used
18:45:49 <lispy> copumpkin: Try it out :)
18:45:59 <crest> neither google nor the cabal documentation provide any hints
18:46:03 <copumpkin> lispy: it's a big tutorial, I'm gonna need a better bug report than that :P
18:46:22 <lispy> copumpkin: The source code is available though.  Just download it and try to load it
18:46:39 <copumpkin> which one?
18:46:48 <lispy> The one I linked :)  Just a sec
18:46:53 <hamishmack> crest: Try cabal unpack leksah; cd leksah-0.10.0.4; cabal configure
18:47:07 <lispy> copumpkin: http://www.cse.chalmers.se/~ulfn/code/tphols09/
18:47:11 <hamishmack> crest: It may give a more detailed error
18:47:21 <lispy> copumpkin: goes with this tutorial: http://wiki.portal.chalmers.se/agda/uploads/Main.Othertutorials/AgdaOverview2009.pdf
18:47:59 <lispy> Coq and Isabelle are much more learner-friendly with Coq being the easiest to install and get going with in my experience.
18:48:03 <crest> hamishmack: thx waiting for failure
18:48:10 <lispy> Which is a shame
18:48:22 <lispy> The Agda folks should work on their ease of use
18:48:41 <copumpkin> I find it hard to believe that any type errors are profound
18:49:12 <Favonia> lispy: thanks for the information about TypeNat... :D
18:49:24 <lispy> They don't have to be "profound" to be an issue for beginners who have never used Agda before
18:49:40 <crest> hamishmack: it fails with the same error message as cabal install --verbose=3 leksah (http://nopaste.info/535bf11578.html)
18:50:00 <lispy> Favonia: you're welcome.  BTW, it was posted on the haskell subreddit a while back.  Great place to keep up on haskell stuff.
18:51:17 <lispy> copumpkin: I hope you agree that introductory level material for a programming language listed on the language's website should compile cleanly
18:51:29 <copumpkin> not really :P
18:51:49 <copumpkin> I doubt all the documentation for haskell pre-standardization was consitent
18:51:51 <copumpkin> consistent
18:52:05 <copumpkin> anyone learning an early experimental language should expect kinks
18:52:10 <copumpkin> there are bugs all over the place
18:52:23 <copumpkin> the question is how easily are you put off by minor obstacles
18:52:56 <copumpkin> it definitely isn't what I'd consider end-user ready
18:53:00 <copumpkin> I still think it's awesome
18:53:04 <hamishmack> crest: Can you try using runhaskell Setup build; runhsakell Setup install
18:53:19 <lispy> In the case of Agda there is so much breakage and work just to get to a working example that it's a huge turnoff even if the individual problems are all small.
18:54:38 <caylee> That's too bad - my experience installing and using agda was pretty uneventful. I wonder what the difference was?
18:55:02 <lispy> I have less tolerance for "paper cuts" on stuff like that than I did when I was a student because I have less free time to play with stuff.  I want to get to the fun bits.
18:56:17 <blackdog> lispy: it's a funny shift. you almost glory in that as a student... LFS and Gentoo and all that sort of thing
18:56:22 <blackdog> almost like a badge of honour.
18:56:27 <aavogt> crest: what version of ghc do you have?
18:57:16 <lispy> blackdog: yeah.
18:58:19 <lispy> blackdog: "I upgraded glibc on my linux from scratch machine by hand and it still boots!"
18:59:10 <blackdog> and the slow, steadily crankier metamorphosis that leads you to mac :)
18:59:46 <lispy> blackdog: haha.  I'm on a mac right now...
19:01:43 <blackdog> lispy: if there was a decent package manager i'd be completely happy, i think
19:01:51 <blackdog> a tiling window manager would just be a bonus
19:02:15 <crest> aavogt: version 7.0.3
19:02:43 <crest> aavogt, hamishmack: just found out i had an old version of cabal in my $PATH
19:03:23 <lispy> blackdog: and some OSX gui librarys in Haskell :)
19:03:35 <lispy> blackdog: gtk2hs does not count :(
19:03:43 <blackdog> lispy: i don't even care. the web is enough for me.
19:04:09 <lispy> blackdog: I want to do opengl stuff though
19:04:11 <blackdog> i don't particularly want to get stuck developing for mac... iOS work is different
19:04:27 <blackdog> ah. no raw opengl lib? i haven't ever tried.
19:04:30 <lispy> blackdog: I can use GLFW-b but having support for gui stuff that isn't just a rendering window is important too
19:04:38 <alvarobsp> is there such a function like "getInt" or "getTuple" or the only default functions for this are getChar and getLine?
19:04:42 <lispy> The raw opengl support is there
19:04:52 <lispy> It's the gui to put the opengl in that's harder
19:05:12 <aavogt> @type readIO =<< getLine
19:05:13 <lambdabot> forall b. (Read b) => IO b
19:05:26 <ClaudiusMaximus> @type readLn
19:05:27 <lambdabot> forall a. (Read a) => IO a
19:08:05 <Favonia> alvarobsp: I guess the formats of "Int" and "Tuple" need to be defined before implementing them?
19:08:40 <alvarobsp> aavogt:,ClaudiusMaximus: is this for me? :P
19:09:57 <alvarobsp> Favonia: hm, I'm doing something here, wich works, but I just wondered if there's a better (and smaller) way to do it
19:10:08 <alvarobsp> just a second
19:12:12 <alvarobsp> http://pastebin.com/3uvr42zq
19:12:33 <alvarobsp> especially the "getNumber" and "getTuple", is there any better way to do it?
19:12:45 <applicative> crest, does it work with the other cabal-install?
19:14:23 <lispy> blackdog: which package managers for osx have you tried?  The ones I know of include, fink, macports, and homebrew.  Fink seems crufty.  Macports seems to do weird things but mostly works (except for libiconv issues), and homebrew strikes me as very very sketchy but some people here like it.
19:14:33 <parcs> alvarobsp: you can replace getNumber and getTuple with readLn
19:14:34 <blackdog> homebrew is the best i've found.
19:14:46 <blackdog> mostly because it's the simplest.
19:15:29 <blackdog> it doesn't try to build a firewall between itself and the system stuff, so there are fewer issues around getting the wrong version of a library
19:15:29 <ClaudiusMaximus> alvarobsp: getNumber = readLn ; getTuple = readLn
19:15:46 <Favonia> alvarobsp: yes, readLn is polymorphic and does the magic :D
19:16:07 <blackdog> lispy: it's the best possible in the circumstances, i think. until apple blesses a package manager, you'll only be able to control the stuff around the outside
19:16:23 <blackdog> and given the mac app store, they seem unlikely to do it.
19:16:52 <applicative> @type readLn
19:16:52 <lambdabot> forall a. (Read a) => IO a
19:17:01 <blackdog> (charging money for xcode fills me with dread. i know it's only a little, but it means you can no longer assume dev tools are installed)
19:17:33 <alvarobsp> I'll try it here, thanks a lot
19:17:40 <lispy> blackdog: actually, I use virtualbox with linux inside to do most of my development regardless of linux or osx.  It allows me to keep seperate configurations for each project.  This can be important when half of them use custom apache configs
19:17:59 <blackdog> lispy: that's the other sane approach
19:18:01 <Favonia> alvarobsp: or are you looking for finer control over formats?
19:18:30 <Favonia> in that case maybe you need a parser like Parsec
19:18:37 <blackdog> it's a bit frustrating that you have to put up with the overhead of virtualisation just to get compartmentalisation. it'd be different if Xen was supported.
19:19:32 <lispy> and there can be a lot of startup cost to config the inner machine
19:19:46 <lispy> I need to get all my dot files into repos so that I can reduces that
19:20:35 <blackdog> how do you maintain them currently? vagrant?
19:20:45 <blackdog> babushka looks quite nice for setting up personal dev machines
19:20:47 <lispy> vagrant?  Currently I don't "maintain" them
19:21:05 <blackdog> one of these days i'm going to have to dig into chef/puppet/whatever
19:21:15 <lispy> I started learning vim so that I can just "go" :)
19:21:18 <blackdog> vagrant is a ruby gem that helps you manage virtualboxes
19:21:37 <blackdog> http://vagrantup.com/docs/getting-started/index.html
19:21:59 <blackdog> think it uses chef under the covers.
19:22:10 <lispy> interesting
19:22:23 <lispy> I'll definitely have to share that around.  Several of us here like to use virtualbox
19:22:39 <blackdog> where's here?
19:22:54 <blackdog> and i do agree on virtualbox. much nicer than vmware
19:23:25 <lispy> I work at galois
19:23:32 <blackdog> been trying to learn xen to play around with HaLVM, but it's a pretty steep learning curve
19:23:55 <blackdog> oh, no shit? i'm still aiming to become more awesome to come work at galois :)
19:23:56 <lispy> Yes, xen is hard to grasp at times.  When it goes wrong there is typically very little info available about what failed
19:24:01 <lispy> hehe
19:24:20 <lispy> We're interviewing for some pretty senior level positions right now
19:24:26 <lispy> Having a PhD helps in this round
19:24:31 <blackdog> i interviewed there and jane st last year
19:24:40 <lispy> ah
19:25:02 <lispy> That was probably before I started
19:26:08 <blackdog> fair enough. i think they were a bit sketchy on me because i was australian
19:26:19 <lispy> Gotcha
19:26:28 <blackdog> more fuss with work visas & relocation etc.
19:26:37 <blackdog> what're you working on at galois?
19:26:50 <blackdog> (publically admissible, anyway:)
19:27:11 <lispy> We should move to -blah
19:27:25 <lispy> #haskell-blah that is
19:28:32 <blackdog> lispy: probably :)
19:32:05 <alvarobsp> I can use  "map (elem 1) [[1,2,3],[2,3]]", for example, to check if 1 belongs to each of the lists. But is there any way to use map with elem like "map (elem - [1,2,3,4]) [1,2,3,4,5]"  (to see if each of the elements of the last list belongs to the first list) ?  or should I simply do something like elem2 a b = elem b a and use elem2?
19:32:58 <parcs> yes, with a lambda expression
19:33:11 <parcs> map (\x -> elem x [1..4]) [1..5]
19:33:33 <aavogt> or a section:   (`elem` [1..4])
19:33:34 <ClaudiusMaximus> > map (`elem` [1..4]) [1..8]
19:33:35 <lambdabot>   [True,True,True,True,False,False,False,False]
19:34:47 <alvarobsp> thanks
19:35:13 <ClaudiusMaximus> @src flip
19:35:14 <lambdabot> flip f x y = f y x
19:37:17 <Favonia> @type filter . notElem
19:37:17 <lambdabot> forall a. (Eq a) => a -> [[a]] -> [[a]]
19:37:39 <Favonia> @type \l1 -> filter (notElem l1)
19:37:39 <lambdabot> forall a. (Eq a) => a -> [[a]] -> [[a]]
19:38:24 <Favonia> @type \l1 -> filter (`notElem` l1)
19:38:25 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:39:06 <ClaudiusMaximus> hm, hayoo gives a couple of QuadTree implementations, but neither do what mine does...
19:39:15 <adrian_berg> This was some ugly code I pasted in #python: http://paste.pound-python.org/show/7075/ Someone suggested that an easier way of acquiring multiples of 9 up to 1 million would be to use xrange(1, 1000000, 9).
19:39:25 <adrian_berg> I would like to know how you would do this in Haskell.
19:39:42 <identity_> adrian_berg: [1, 9 .. 1000000]
19:39:44 <ivanm> > enumFromThenTo 9 18 1999999
19:39:45 <lambdabot>   [9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,19...
19:39:53 <ivanm> identity_: 1 isn't a multiple of 9 ...
19:40:03 <identity_> ivanm: well, he started at 1
19:40:04 <ivanm> and the next value will then be 17, not 18!
19:40:06 <identity_> I don't know python
19:40:14 <identity_> ivanm: oh, true
19:40:23 <applicative> > [9, 10 .. 100000]
19:40:23 <ivanm> identity_: yeah, I think that will get him 1,10,19, etc.
19:40:23 <lambdabot>   [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,...
19:40:27 <applicative> > [9, 18 .. 100000]
19:40:28 <lambdabot>   [9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,19...
19:40:53 <applicative> ^^^ that's the handsome syntax for it
19:41:01 <identity_> > aye
19:41:01 <lambdabot>   Not in scope: `aye'
19:41:04 <identity_> eh
19:41:07 <applicative> as identity_ was saying
19:41:40 <identity_> ivanm: do you know if xrange does multiples, or basically add to start value until it reaches end value?
19:41:48 <ivanm> I think the latter
19:41:50 * ivanm goes off to check
19:41:58 <adrian_berg> identity_: That was easy enough! Thanks.
19:42:17 <ivanm> identity_: yeah, it just adds 9 each time
19:42:25 <identity_> adrian_berg: You're very welcome. Note what ivanm said though, xrange doesn't do the multiples
19:42:25 <ivanm> appamatto: "handsome" ?
19:42:39 <ivanm> > map (9*) [1..]
19:42:40 <lambdabot>   [9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,19...
19:42:41 <ivanm> ;)
19:42:43 <applicative> adrian_berg of course this generates a haskell list, there are other things,
19:42:46 <identity_> ivanm: +1
19:43:16 <identity_> iteriate (+9) 9
19:43:19 <identity_> eh
19:43:26 <identity_> > iterate (+9) 9
19:43:26 <lambdabot>   [9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,19...
19:43:26 <ivanm> > iterate (+9) 9
19:43:27 <lambdabot>   [9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,19...
19:43:37 <ivanm> hmmm.... how else can we golf this? :p
19:43:42 <applicative> like Vector, etc, you might want to build.
19:43:58 <identity_> ivanm: don't think you can beat the map
19:43:58 <ivanm> > iterate (iterate succ id !! 9) 9
19:43:59 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
19:43:59 <lambdabot>    arising from a use of `e_199' a...
19:44:01 <adrian_berg> Oh, I didn't read. I just saw more text and figured the conversation went somewhere else. Thank you as well ivanm. This is great.
19:44:09 <ivanm> > iterate (iterate (succ .) id !! 9) 9
19:44:09 <identity_> if you mean golf = shorter
19:44:11 <lambdabot>   [9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,19...
19:44:21 <ivanm> identity_: no, I mean _cooler_ ;)
19:44:25 <identity_> haha
19:44:29 <identity_> the #haskell way
19:44:43 <ivanm> but I think applicative's version is probably the best: [9,18..1000000]
19:45:14 <identity_> ivanm: damn you. Now I'm sshing into my shell to fuck around with it
19:45:23 <ivanm> :D
19:45:42 * ivanm goes back to trying to work out if a) his code is wrong, b) his maths is wrong or c) his understanding of the paper is wrong
19:45:44 <ivanm> I'm hoping for c)
19:46:10 <ivanm> which is likely; I'm kind of guessing what a 0-cell is... :s
19:46:23 <applicative> > let nines = 9 : 18 : (zipWith (+) `ap` tail) nines in take 20 nines
19:46:23 <lambdabot>   [9,18,27,45,72,117,189,306,495,801,1296,2097,3393,5490,8883,14373,23256,376...
19:46:33 <applicative> wait, thats wrong, damn
19:46:51 * applicative wonders what it is
19:46:56 <ivanm> applicative: I think you want some kind of interleave
19:47:02 <ivanm> but then you'll get duplicates IIUC
19:48:40 <ClaudiusMaximus> > filter ((0 ==) . takeWhile (<= 0) . iterate (foldr (.) id . replicate 9 $ pred)) [0..]
19:48:41 <lambdabot>   No instance for (GHC.Num.Num [b])
19:48:41 <lambdabot>    arising from a use of `e_10090' at <in...
19:48:55 <ClaudiusMaximus> > filter ((0 ==) . last . takeWhile (<= 0) . iterate (foldr (.) id . replicate 9 $ pred)) [0..]
19:48:59 <lambdabot>   mueval-core: Time limit exceeded
19:49:26 <ClaudiusMaximus> oops..
19:50:13 <int80_h> http://hpaste.org/46990/data_type_trouble_with_gnuplot
19:50:51 * applicative keeps exceeding mueval's time limit too.
19:50:53 <ivanm> int80_h: in general, it's easier to read if you don't mix your code with your discussion that much
19:50:58 <ivanm> or put the discussion in comments
19:51:34 <ivanm> int80_h: I believe your error is that you don't specify the filename...
19:52:00 <Favonia> > [9,18..36]
19:52:01 <lambdabot>   [9,18,27,36]
19:52:02 <identity_> I think we'll just have to agree that the best way to list all the multiples of nine in haskell is to list all the multiples of nine..
19:52:19 <identity_> > [9, 18, 27, 36, 45, 54]
19:52:20 <lambdabot>   [9,18,27,36,45,54]
19:52:21 <identity_> so on
19:52:24 <identity_> ad nauseum
19:52:28 <int80_h> ivanm: thanks for the tip!
19:52:41 <Favonia> so maybe we should say [9,18..d *-1*] ??
19:53:00 <ivanm> Favonia: hmmmmm> why the -1 ?
19:53:02 <Favonia> oh wait
19:53:16 <ivanm> are you wanting to exactly duplicate the behaviour of the python code?
19:53:27 <ivanm> in that case, you need to duplicate it's bug as well! ;)
19:53:41 <Favonia> ivanm: oh ok... :P
19:54:04 <Favonia> I found the upper bound is d + 9 -1 or something like that
19:54:25 <greenland> im a newb. how do you haskell wizards avoid infinite recursion when looking at graphs in ghci?
19:54:54 <ivanm> greenland: structure your graphs functions properly
19:55:00 <int80_h> ivanm: the function I call has only two arguments. I think I just got clued into the fact I'm using the wrong function here
19:55:06 <ivanm> also, inductive graphs are nice in this sense
19:55:19 <adrian_berg> [9,18..d *-1*]
19:56:30 <sm> evening all. How can I see what top-level names are defined in a module consisting only of a TH $( ) thing (splice?)
19:56:35 <greenland> ivanm: I've data for type X. X contains another X value. i set a to b and i set b to a.... works great until ghci tries to output the value of either
19:56:38 <ivanm> greenland: what are you trying to do?
19:56:45 <ivanm> sm: generate the haddock documentation? :p
19:56:57 <sm> worth a try I guess
19:57:21 <ivanm> greenland: set a to c, set b to a, set c to b ?
19:57:23 <Favonia> adrian_berg: I think it is [9,18..1000000 *+9-1*]. I was wrong.
19:57:26 <ivanm> *shrug*
19:57:34 <ivanm> greenland: oh, wait, your data is cyclic?
19:57:43 <ivanm> yeah, write a better Show instance
19:57:47 <greenland> ivanm: it is quite self-referential
19:58:01 <greenland> ivanm: i had a feeling you'd say that
19:58:11 <ivanm> well, that's the error, isn't it?
19:58:22 <ivanm> the fact that it's showing the infinite nature of the data structure?
19:58:40 <ivanm> greenland: it might help if you give us a better idea of what you're doing
19:59:20 <greenland> yes... im too much of a novice to tell the difference between an error and a "feature" at this point. i've what is affectively a wonky mud server written in python and I thought I'd educate myself by rewriting it in haskell
19:59:35 <ClaudiusMaximus> > let nines = 9 : filter ((`elemSorted` nines) . sum . map digitToInt . show) [10..] ; elemSorted x (y:ys) = if x <= y then x == y else elemSorted x ys in nines
19:59:37 <lambdabot>   [9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,19...
19:59:56 <applicative> ClaudiusMaximus: that makes it all very clear
20:00:03 <greenland> so I bought a book with an elephant in glasses
20:00:47 <sm> ivanm: that worked well, thanks :)
20:01:08 <ivanm> sm: np ;-)
20:01:18 <ivanm> sm: the other alternative that I just thought of is to load it in ghci and do :browse
20:01:26 <parcs> > (enumFromThenTo <*> join (+)) 9 100000 -- the clearest
20:01:27 <lambdabot>   [9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,19...
20:01:37 <edwardk> preflex: xseen roconnor
20:01:37 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:01:37 <preflex>  roconnor was last seen on freenode/#haskell 6 hours, 30 minutes and 16 seconds ago, saying: xplat: I borrowed the book referenced in that blog post.  If you do you can skip to the last few chapters.
20:01:41 <sm> ah :browse! excellent, I didn't know that one
20:01:46 <ivanm> parcs: I don't know if it's _that_ clear...
20:01:52 <ivanm> took me a while to figure out the join bit
20:01:59 <ivanm> hey edwardk
20:03:02 <edwardk> heya ivan
20:03:12 <edwardk> i'll take a look at the planar graph stuff when i'm less frazzled ;)
20:07:05 <ivanm> no worries ;)
20:07:27 <ivanm> I just figured I'd get some people who are more used to graph stuff to see whether the documentation makes sense
20:09:19 <int80_h> ivanm: hey I figured out what I was doing wrong with the syntax. Thanks for your help
20:09:47 <int80_h> plot was interpreting the argument for png as a third arguement for itself.
20:09:59 <ivanm> yeah, guessed it would be something like that
20:11:00 <adrian_berg> Earlier, I stated it wrong, someone from #python suggested xrange(1, 1000000, 9)
20:11:06 <adrian_berg> I mean xrange(0, 1000000, 9)
20:11:41 <Favonia> greenland: are you doing some kind of state machines for a complex maze? :P
20:14:26 <ivanm> adrian_berg: yeah, that makes more sense
20:29:47 <Favonia> > let reduce = sum . map digitToInt . show ; inNines = (==9) . head . filter (<10) . iterate reduce in filter inNines [1..100000]
20:29:49 <lambdabot>   [9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,19...
20:31:39 <Favonia> @let setminus l2 l1 = filter (`notElem` l1) l2
20:31:40 <lambdabot>  Defined.
20:31:51 <Favonia> > [1,2,3] `setminus` [3,2]
20:31:53 <lambdabot>   [1]
20:32:07 <ivanm> Favonia: \\ not good enough for you?
20:32:18 <ivanm> > [1,2,3] \\ [3,2]
20:32:19 <lambdabot>   [1]
20:32:25 <ivanm> though \\ does fail in this case:
20:32:30 <ivanm> > [1,2,3,2] \\ [3,2]
20:32:31 <lambdabot>   [1,2]
20:32:59 <Favonia> maybe I should define \\\ :P
20:33:50 <ivanm> yeah, I usually hate the behaviour of delete and use filter (/= v)
20:34:14 <nwf> Hey advanced type system feature users: is it possible to declare that the codomain of a type family ascribes to some type class?
20:34:25 <exim> Hi all. does anybody knows if there is any progress regarding Haskell Platform package for ubuntu?
20:35:09 <Favonia> ivanm: somebody said something like map (`elem` l1) l2 before. as far as I remember he actually wanted to check whether "set1 `setminus` set2 == []"
20:35:26 <ivanm> ahhh
20:35:38 <ivanm> yeah, that's probably the best way
20:35:50 <Favonia> :)
20:36:02 <ivanm> actually... if you know you dont' have repeats, I'd just use null $ l1 \\ l2
20:36:10 <ivanm> but if you have repeats, yeah, \\ isn't that great :s
20:36:17 <ivanm> exim: there is one; it just isn't the latest platform
20:37:13 <exim> ivanm: Right. I'm asking regarding latest one.
20:37:44 <ivanm> does Ubuntu allow upgrading of packages?
20:37:55 <ivanm> I thought once a release was made then the only updates were bug fixes...
20:37:59 <ivanm> *shrug*
20:38:18 <applicative> exim, what version of ghc do you have?
20:39:31 <Favonia> exim: if you just want the "benefits" of the last release, you can install GHC 7.0.3 and then install all libraries in your home dir when they are needed :) HP is just GHC + common libs.
20:40:16 <ivanm> Favonia: + some libs that need C libs that are a pain to install by hand
20:40:21 <exim> Actually, I was looking for binary/prebuilt package like there is for win and osx. And I had an impression that installing haskell platform would be similarly straighforward like, say on windows... but thats not a case :)
20:40:26 <ivanm> but they're primarily there due to historic reasons AFAIK
20:40:44 <ivanm> exim: it's up to the distro packagers for *nix \ {OSX}
20:40:57 <exim> Yes
20:42:06 <applicative> exim, did you see the discussion of ghc/haskell platform/cabal install on the haskell-cafe list the other day?
20:42:17 <applicative> exim, I mean, on ubuntu
20:42:55 <applicative> exim, http://www.haskell.org/pipermail/haskell-cafe/2011-May/thread.html#92188
20:45:24 <exim> Hm, no. Thank you. I installed ubuntu yesterday, and while searching for HP, I found bug report (which is not solved yet), regarding HP package. So, I was interested if somebody here had more up to date info (or maybe works on that bug...)
20:45:32 <exim> Thanks anyway, I'll take a look.
20:46:00 <aune_> How do I show that if G is simple and 3-regular, then k(G) = k'(G)? For clarification: k(.) is vertex connectivity and k'(.) is edge connectivity.
20:49:29 <ivanm> aune_: well, it's not quite on-topic... ;-)
20:50:01 <ivanm> hmmm... that sounds vaguely right though
20:50:15 <ivanm> I don't recall all my connectivity stuff though
20:50:33 <aune_> ivanm, yeah, I know, but #math kind of ignored me : )
20:52:10 <aune_> I have that k <= k' <= d for all graphs where d is the minimum degree of a vertex
20:52:58 <ivanm> yes
20:54:06 <aune_> but other than that I'm kind of lost.
20:54:59 <ivanm> is it if you have a bridge?
20:55:04 <ivanm> i.e. k = k' = 1 ?
20:55:14 <ivanm> no, wait, you could also have the = 2 case ...
20:57:24 <aune_> yeah, but if I have a bridge then k' = 1, but also k=1 since I can just remove one of the vertices at the end of that bridge, so in this case they are equal.
20:57:45 <aune_> wait
20:58:55 <aune_> the above means that k' = 1 ==> k = 1. So we need to show that k = 1 ==> k' = 1
20:59:52 <ivanm> aune_: yeah, but you also have the k=2 case
20:59:57 <ivanm> and you might have a k=3 case
21:10:41 <aune_> ivanm, If v is on the border of G1 and G2, then either it has one edge into G1 or one edge into G2, and in either case we can put it in one to one correspondence with the lone edge.
21:11:56 <aune_> ivanm, so if an edge is part of a minimal cut, we have a minimal vertex cut from this correspondence
21:13:57 <ivanm> sounds about right
21:15:49 <aune_> ivanm, I'm always worried that these sorts of arguments are a bit to informal...
21:16:07 <ivanm> yeah, it can get that way with graph theory
21:16:16 <ivanm> the arguments are very case-based and seem hand-wavy
21:16:30 <dolio> Formalize it in Coq.
21:17:01 <aune_> But then I have to learn Coq ^^
21:17:49 <dolio> Okay, Agda then.
21:17:53 <aune_> And while that is a good idea, somehow I feel that Im a bit low on time currently.
21:18:40 <aune_> I'm overwhelmed just trying to wrestle haskell
21:20:44 <aune_> But if I ever get the time, which would you suggest I learn first, Coq or Agda?
21:21:32 <gienah> aune_: coq: http://www.seas.upenn.edu/~cis500/current/sf/html/index.html
21:21:58 <aune_> Any particular reasons?
21:22:45 <gienah> aune: or maybe isabelle: http://www4.informatik.tu-muenchen.de/~nipkow/semantics/
21:22:46 <dolio> aune_: I like Agda. But that's just me. And it has tradeoffs.
21:23:27 <copumpkin> another vote for agda, probably for all the wrong reasons
21:23:53 <gienah> aune_: my only reason is my impression that there are more tutorials to help learn coq or isabelle than agda, but if someone can point to tutorials on agda that would show I'm wrong :-)
21:24:08 <dolio> Every time I go to look at Coq code, it looks completely terrible to me. But maybe some people have the same reaction to Agda.
21:25:26 <gienah> I am unqualified to really answer though, as the only one I know something about is coq (isabelle also looks neat)
21:25:52 <babusri> Are there any haskell tutorials that explain rank-2 polymorphism with lots of examples?
21:26:50 <aune_> Well, good tutorials are a requirement, doesnt matter how good it is if I cant learn how to use it.
21:28:07 <Eduard_Munteanu> With Agda it's going to be a fair bit of reading stdlib code, release notes and that sort of stuff.
21:28:27 <Eduard_Munteanu> Tutorials are ok, but they only get you through basic language features and constructs.
21:28:44 <copumpkin> a lot of it is just practice
21:29:01 <copumpkin> the nice thing about it is that once you've learned how mathematical statements can be encoded as types
21:29:08 <copumpkin> you can set your own exercises and try to complete them
21:29:19 <dolio> Agda has a lot of quirks that you can only pick up by writing stuff, or having people explain why certain things don't work.
21:29:23 <dolio> When you run into them.
21:29:38 <dolio> For some bits, at least.
21:29:59 <dolio> Like, when the unifier will work.
21:30:07 <gienah> aune_: coq has awesome tutorials, this is the first in a sequence of 10 video lectures on the coq tutorial I linked to earlier: http://vimeo.com/18138042
21:30:16 <Eduard_Munteanu> Agda's upsides are nicer syntax and being somewhat better at programming.
21:30:40 <Eduard_Munteanu> (though the latter is a bit debatable too)
21:31:11 <aune_> Ok
21:32:38 <gienah> Eduard_Munteanu: although I haven't really looked at agda much, it does seem likely that agda may be easier to program in than coq, coq's fixpoints can be tricky to program
21:34:00 <Eduard_Munteanu> In the long run, Agda will probably be a lot better. I don't know Coq well though.
21:34:26 <Eduard_Munteanu> At the moment however, that stuff isn't really polished.
21:35:31 <gienah> its difficult to prove stuff with coq's fixpoints directly, so it seems its necessary to: 1) prove things with propositions mainly 2) write the fixpoint 3) prove the fixpoint is equivalent to the proposition. An example is here: http://www.seas.upenn.edu/~cis500/current/sf/html/Typechecking.html
21:36:24 <Eduard_Munteanu> Oh, fixpoints probably aren't any easier in Agda per se.
21:38:01 <Eduard_Munteanu> I mean recursion in general. I'm assuming Coq has roughly the same features, though, such as mutual recursion and codata.
21:39:02 <Favonia> nwf: are you still there? I am interested in your question about type families.
21:39:05 <aune_> Well, the most important parts to me is: 1) There should be some tutorials so that I can learn it. 2) I have to be able to understand the proofs I produce.
21:40:55 <Favonia> preflex: seen nwf
21:40:55 <preflex>  nwf was last seen on #haskell 1 hour, 6 minutes and 42 seconds ago, saying: Hey advanced type system feature users: is it possible to declare that the codomain of a type family ascribes to some type class?
21:41:30 <Eduard_Munteanu> gienah: hrm yeah, there's no special fixpoint declaration in Agda.
21:41:33 <nwf> Favonia: I have, in the interim, done something slightly different (though I am not terribly happy with the solution).
21:42:01 <Eduard_Munteanu> You write recursive stuff just like regular stuff.
21:42:34 <Eduard_Munteanu> The checker starts turning things reddish or yellow if it chokes on it.
21:43:07 <gienah> Eduard_Munteanu: right, so agda is probably easier to write programs in than coq, I guess
21:43:47 <Eduard_Munteanu> Well, one other reason is you can FFI straight to Haskell.
21:44:07 <Eduard_Munteanu> (or C recently, with the Epic backend)
21:44:19 <Favonia> nwf: I tried something like "class Eq k => GMapKey k where data GMap k :: * -> * ... " and it looks fine. Is this what you wanted?
21:44:54 <dankna> oh cool.  I'm reading the STG paper and now I understand how the stack works, haha.
21:45:39 <Favonia> nwf: I even tried "instance (GMapKey k, Show v, Show k) => Show (GMap k v) where ... " and it works too.
21:47:21 * Eduard_Munteanu has to go...
21:47:30 <gienah> Eduard_Munteanu: that's really cool that agda can FFI to Haskell and C. With coq maybe you can extract some haskell, bye
21:48:08 <nwf> How would I make that fly with or in liu of a type family decl?  I had a function "(I a, I b) => F a -> F b -> F (TF a b)" and wanted something like "I (TF a b)" in the context, but that was rejected.
21:49:06 <nwf> (For larger context, I am implementing "Interval Tree Clocks: A Logical Clock for Dynamic Systems
21:49:34 <nwf> " and wanted to statically guarantee the well-formedness of the Identity and Event trees; I haven't gotten to the Event ones yet since I fear type-level natural numbers. =P)
21:49:55 <nwf> (I can pastebin my current somewhat-unsatisfactory solution if you're curious.)
21:51:02 <Favonia> I am indeed curious :) thanks. I haven't really tried these fancy type family features
21:52:14 <Favonia> about FFI to C... after reading C99 standard I feel we should discouragement people from passing structures as values
21:52:34 <Favonia> the compiler is free to add any kind of padding :(
21:52:44 <Favonia> except the very beginning
21:53:00 <Favonia> s/ment//
21:54:04 <nwf> http://pastebin.com/PG0L54nE
21:54:45 <nwf> (Not terribly cleaned up, either.)
21:58:02 <Favonia> the *correct* way requires size(). (there is no guarantees that we can add up size() of individual named members within a structure. the BMP header example in Wikipedia is NOT portable. also there seem to be some tutorials which make assumptions on layouts too...). I also doubt the magical alignment macro is portable.
21:58:15 <Favonia> s/size()/sizeof()/
22:02:05 <dankna> libffi is a portable wrapper around such issues
22:02:53 <dankna> in practice, the platform ABI defines it; the C compiler merely does whatever the ABI says
22:04:11 <mjrosenb> SpecConstr
22:04:13 <mjrosenb>     Function `$j_s1AH{v} [lid]'
22:04:15 <mjrosenb>       has six call patterns, but the limit is 3
22:04:23 <mjrosenb> anyone know what is causing that/is it actually an issue?
22:04:49 <dolio> It's not an error, is it?
22:04:51 <Axman6> it's from constructor specialisation i think
22:04:56 <Axman6> but it can safely be ignored
22:05:54 <dolio> It means it isn't optimizing as much as possible.
22:06:04 <Favonia> I have heard that GHC is just trying to optimize your codes by enumerating calling patterns etc. don't count on me though
22:14:05 <Veinor> ugggh, i'm trying to write type-level fizzbuzz and failing
22:14:59 <Favonia> dankna: I agree in practice it just works. that's how we survive until now. :) however I feel giving users of FFI the freedom to write arbitrary sizeOf is a bit dangerous. for example, many people think a structure with two Ints will always occupies 2*sizeof(int). maybe I missed it, but I didn't see this guarantee in C99 standard. the safe way is to do sizeof(the whole structure). since it seems to be the ONLY way to implement
22:15:01 <Favonia> it, maybe we should have some form of automatic deriving?
22:15:18 <dankna> Favonia: that isn't what I said at all
22:15:52 <dankna> Favonia: I said, yes, the constraints are different on different platforms but the libffi team (a branch of the gcc team) has already done the hard work for us
22:16:52 <ulfdoz> Favonia: 2*sizeof() is stupid for other reasons two. Just assume, you have to add an additional field to the struct.
22:17:00 <ulfdoz> s/two/too/
22:17:35 <mjrosenb> how do i ask lambdabot for the sources for a function?
22:17:46 <Favonia> @src id
22:17:46 <lambdabot> id x = x
22:17:47 <Axman6> @src map
22:17:48 <lambdabot> map _ []     = []
22:17:48 <lambdabot> map f (x:xs) = f x : map f xs
22:18:12 <mjrosenb> @src permutations
22:18:12 <lambdabot> Source not found. Maybe you made a typo?
22:18:18 <mjrosenb> @src permutation
22:18:18 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:18:28 <dankna> @src permute
22:18:28 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:18:33 <dankna> @hoogle permutations
22:18:34 <lambdabot> Data.List permutations :: [a] -> [[a]]
22:18:34 <Axman6> it only knows some functions' source
22:18:45 <Axman6> mainly those in the prelude
22:19:00 <NihilistDandy> With good reason :D
22:19:07 <Axman6> indeed
22:20:26 <dolio> @src sort
22:20:26 <lambdabot> sort = sortBy compare
22:20:30 <NihilistDandy> I was running a modified lambdabot on another server, and they spent hours trying to make it do IO :D
22:20:33 <dolio> @src sortBy
22:20:33 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
22:22:12 <Axman6> heh
22:23:48 <Favonia> dankna: hmm I am sorry. I just want to say that currently passing a structure requires some extra efforts which might be able to be avoided automatically. I know gcc is powerful. actually I might suggest abusing its powers if possible. it has #pragma pack and __alignof__  to make it much controllable. (the C99 standard is kind of silent on alignment issues)
22:25:51 <Favonia> ulfdoz: I agree 2*size() is stupid from all aspects :P
22:26:23 <Favonia> @src setminus
22:26:23 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:26:41 <Favonia> where is the function I defined :(
22:26:56 <Axman6> :t (\\)
22:26:57 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
22:26:58 <Axman6> that one?
22:27:08 <Axman6> > [1..10] \\ [2,3,4]
22:27:09 <lambdabot>   [1,5,6,7,8,9,10]
22:27:23 <Favonia> > [1,1,1,1] `setminus` [1]
22:27:24 <lambdabot>   []
22:27:47 <Axman6> > [1,1,1,1,1] \\ [1]
22:27:48 <lambdabot>   [1,1,1,1]
22:28:49 <tcard> I am working with Control.Monad.State.Lazy and wrote a test program that numbers lines of text.
22:28:54 <tcard> Source: http://hpaste.org/46992/number2hs
22:28:57 <Favonia> I used @let to teach lambdabot a new function
22:29:00 <tcard> Would anybody mind giving me some feedback?
22:29:08 <tcard> In particular, is there a more idiomatic way to do this (perhaps using `interact`)?
22:30:05 <Axman6> wll putStr . f . getContents (roughtly) is interact
22:30:54 <Axman6> i you have main = interact (evalState (mapM numberLines) . lines) 0) then i think that will work
22:31:08 <tcard> Axman6: let me try it
22:31:52 <Axman6> uh, (unlines . evalState (mapM numberLines) 0 . lines)
22:31:58 <Axman6> :t evalState
22:31:59 <lambdabot> forall s a. State s a -> s -> a
22:32:18 <Axman6> the easiest way is to just use zipWith and [1..]
22:32:55 <Axman6> > unlines . zipWith (\x y -> show x ++ ": " ++ y) [1..] . lines $ unlines cake
22:32:57 <lambdabot>   "1: One 18.25 ounce package chocolate cake mix.\n2: One can prepared coconu...
22:32:59 <tcard> Axman6: yeah, the zipWith way is the logical way to do this problem, but this problem is just a simple case of a more difficult one
22:35:04 <dankna> > length cake
22:35:05 <lambdabot>   42
22:35:11 <dankna> > last cake
22:35:12 <lambdabot>   "That will deodorize and preserve putrid tissue."
22:35:23 * dankna blinks
22:35:23 <Axman6> > map head cake
22:35:25 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
22:35:40 <Axman6> > reverse . take 20 . reverse . map head $ cake
22:35:42 <lambdabot>   "NTOATTOOTOOTASCIICAT"
22:35:48 <Axman6> > reverse . take 16 . reverse . map head $ cake
22:35:50 <lambdabot>   "TTOOTOOTASCIICAT"
22:35:55 <Axman6> > reverse . take 15 . reverse . map head $ cake
22:35:57 <lambdabot>   "TOOTOOTASCIICAT"
22:36:05 <Axman6> toottootmew!
22:37:22 <tcard> Axman6: I currently have main = interact (unlines . evalState (mapM numberLine) 0 . lines), but it does not type check
22:37:35 <Axman6> well... fix it =)
22:37:39 <tcard> Axman6: the issue is that numberLine :: String -> CounterState String
22:37:52 <tcard> Axman6: not numberLine :: [String] -> CounterState [String]
22:38:09 <tcard> Axman6: :)
22:38:18 <Axman6> but mapM numberLine should be :: [String] -> CounterState [String] no?
22:38:57 <tcard> Axman6: hmmm, yes
22:39:17 <Axman6> :t mapM (undefined :: String -> State Int String)
22:39:18 <lambdabot> [String] -> StateT Int Identity [String]
22:39:29 <Axman6> :t evalState
22:39:30 <lambdabot> forall s a. State s a -> s -> a
22:39:35 <Axman6> ah right
22:40:06 <Axman6> you need (unlines . (\xs -> evalState (mapM numberLine xs) 0) . lines)
22:40:21 <Axman6> @pl (unlines . (\xs -> evalState (mapM numberLine xs) 0) . lines)
22:40:21 <lambdabot> unlines . flip evalState 0 . mapM numberLine . lines
22:40:29 <Axman6> hmm, count be worse
22:40:56 <Axman6> d*
22:41:50 <tcard> Axman6: that fixes the problem, and I understand it, but is it idiomatic/"good style" ? ;)
22:42:35 <Axman6> well, the zipWith version would be more idionatic imo, but there's nothing wrong with that
22:43:16 <tcard> Axman6: yeah, true; thank you very much for your help!
22:44:05 * shaleh is trying to wrap his head around the state monad.
22:44:30 <shaleh> What I want to do does not make sense but I do not know how to rephrase it. I want to parse some data and populate a list. This list will be in the State. But I also want to return some output text as a list
22:45:03 <shaleh> The list data will be passed to other functions via State but I still want result output as a list
22:45:05 <NihilistDandy> > take 5 > take 22 (cycle "NYA")
22:45:06 <lambdabot>   Couldn't match expected type `[a] -> [a]'
22:45:06 <lambdabot>         against inferred type `[G...
22:45:14 <shaleh> do i have to shove both into State?
22:45:15 <NihilistDandy> take 22 (cycle "NYA")
22:45:20 <NihilistDandy> > take 22 (cycle "NYA")
22:45:21 <lambdabot>   "NYANYANYANYANYANYANYAN"
22:45:33 <NihilistDandy> Derp, irssi script errors hurting my typing :/
22:46:16 <tcard> shaleh: parse :: String -> State [String] [String] ?
22:46:50 <shaleh> tcard: the output list is not the same as the parsed state list
22:47:40 <tcard> shaleh: you can `put` different data than you `return`
22:47:53 <shaleh> and for fun, eventually this will be a StateT containing IO
22:48:15 <lispy_> ivanm: Hey, thanks for wl-pprint-text.  I was just saying today that I need a pretty printer and I'm not sure which one to use.  Unicode may be important.
22:48:26 <ivanm> lispy_: np!
22:48:40 <ivanm> I actually hadn't touched the code since February; finally remembered to release it the other day
22:49:03 * lispy_ isn't sure if ghc core uses unicode, but text vs. bytestring shouldn't be an issue
22:49:22 * ivanm really should write that blog post about migrating from String to Text ....
22:49:26 <shaleh> tcard: is there a reasonable example of this somewhere? I do not get where the "magic" state is. It looks like some global variable which does not match the rest of my haskell intuition. Why is there not State foo passed in?
22:50:27 <lispy_> ivanm: What about doing what Parsec does to support String, Text, and ByteString all at once?
22:50:46 <lispy_> NB: I don't actually know how Parsec achieves that
22:50:59 <lispy_> ivanm++
22:51:14 <ivanm> lispy: for a pretty-printer?
22:51:22 <ivanm> you'd need a builder type-class I think
22:51:36 <shaleh> tcard: when i used Maybe, or Either or what not I always pass in an instance of the Monad as a parameter. I don't see why State's are not passed in too.
22:51:51 <tcard> shaleh: I do not know of a good example...
22:51:51 <shaleh> I know I am missing something obvious, but it isn't clicking.
22:52:00 <ivanm> as that's what wl-pprint-text uses under the hood
22:52:16 <shaleh> all of the State examples I have found a "let's increment a counter" which is way too simple
22:52:40 <lispy_> ivanm: ah, nice
22:52:44 <tcard> shaleh: The code that I was just talking about is small: http://hpaste.org/46993/number2hs_annotation
22:52:53 <lispy_> ivanm: my application is translating ghc core to isabelle
22:52:58 <tcard> shaleh: the initial state is set with `evalState`, in main
22:53:02 <lispy_> ivanm: So, performance won't be an issue
22:53:04 <ivanm> lispy_: oooohhhh...
22:53:19 <lispy_> But, knowing that it's done efficiently still makes me happy :)
22:53:48 <tcard> shaleh: the `numberLine` function is in the state Monad, so you can use `put` and `get` to change and get the state respectively
22:54:09 <shaleh> tcard: but where is "get" reading its value from? If the State is not a parameter how is it available to numberLine?
22:54:32 <tcard> shaleh: in this case, the stored state is an Int while the return value is String, so it is easy to see that the stored state and return value can be different
22:54:36 <lispy_> bah, my list of things that require round-tuits is growing faster than my spare-time again.
22:54:48 <lispy_> I wish someone would invent a time banking system.
22:54:59 <ivanm> hmmmmmmm..... it should be possible to have "Doc m" where m is a Monoid, and then you just need to define a class such "(Monoid b) => Printable s b | s -> b where fromS :: s -> b"
22:55:21 <ivanm> oh, wait, add "IsString s" to that constraint
22:55:40 <tcard> shaleh: the Haskell Wiki may help with that question
22:55:49 <lispy_> What does IsString provide?  No concat?
22:55:53 <ivanm> oh, wait, you also need fromS
22:55:57 <tcard> shaleh: http://www.haskell.org/haskellwiki/State_Monad
22:56:05 <ivanm> lispy_: just need that for the primitive int, etc. combinators
22:56:14 <tcard> shaleh: check out the "Complete and Concrete Example 2" at the bottom
22:56:22 <shaleh> tcard: thanks for the example, I will play around in ghci and see if I can wrestle it down
22:56:31 <lispy_> ivanm: I'm not (yet) familiar with the pprint api
22:56:32 <shaleh> tcard: thanks for the pointers
22:56:33 <tcard> shaleh: `inc3` uses the state monad without `do` sugar
22:56:38 <tcard> shaleh: np
22:57:11 <ivanm> lispy_: well, just like in pretty, you have int :: Int -> Doc, etc. ; to be able to define combinators like that you need to either have them at the type-class level or go via Show
22:57:54 <ivanm> might also be a few other low-level things that _do_ need typeclass support, namely how to deal with indentation
22:59:00 <ivanm> but that comes in at the rendering stage
23:02:24 <pelotom> is there a standard function somewhere with this type? (a -> a -> b) -> a -> b
23:02:34 <pelotom> @let foo f x = f x x
23:02:35 <lambdabot>  Defined.
23:02:40 <lispy_> pelotom: you can use hoogle to check
23:02:42 <Cale> pelotom: That's join for the function monad
23:02:45 <pelotom> I looked
23:02:47 <lispy_> ?hoogle (a -> a -> b) -> a -> b
23:02:47 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
23:02:48 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
23:02:48 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
23:02:50 <Cale> > join (*) 5
23:02:51 <lambdabot>   25
23:02:52 <pelotom> nothing doing
23:02:55 <pelotom> ahh
23:03:07 <pelotom> @Cale that makes sense :)
23:03:07 <lambdabot> Unknown command, try @list
23:03:14 <pelotom> thx
23:04:52 <poltak> Any of you know Cantor
23:04:56 <pelotom> > join replicate =<< [1,2,3]
23:04:56 <poltak> 's thesis?
23:04:56 <lambdabot>   [1,2,2,3,3,3]
23:04:58 <ivanm> Cale: did you happen to check the current API of my planar-graph library?
23:06:43 <pelotom> poltak: I've heard of his continuum hypothesis
23:07:36 <poltak> pelotom: beautiful boy
23:07:53 <pelotom> err
23:08:30 * hackagebot NanoProlog 0.1.3 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.1.3 (JurrienStutterheim)
23:08:57 <lispy_> ivanm: Well, text is fine with me, I just wondered  if it was easy to generalize without ruining performance
23:09:37 <ivanm> lispy_: I think it could be generalised, but it might need some more careful plumbing
23:10:04 <ivanm> we have a builder for text, blaze has a bytestring builder and dlists are a builder for string
23:11:24 <Cale> ivanm: I thoroughly examined the error message that my web browser gave me when I tried to visit your link ;)
23:11:32 <Cale> code.haskell.org was down
23:13:41 <ivanm> ugh
23:13:57 <ivanm> Cale: looks like it's up now: http://code.haskell.org/~ivanm/planar-graph-haddock/
23:14:20 <ivanm> oh, wait, did I give you the old link (that is, just the html file without any css, etc.) ? :s
23:26:47 <lispy_> ivanm: oh, looks like I don't have to support unicode: http://hackage.haskell.org/packages/archive/zenc/0.1.1/doc/html/src/Text-Encoding-Z.html#zEncodeString
23:27:06 <lispy_> ivanm: but I think I'll still use your text wl-pprint
23:27:14 <ivanm> sure
23:27:38 <ivanm> lispy_: if you're just using String, you can use plain 'ol wl-pprint... just be warned that indentation in it doesn't always work
23:27:51 <lispy_> Ugh
23:27:52 <ivanm> but if you don't care about indentation, then wl-pprint should be fine
23:27:57 <lispy_> I care about indentation
23:28:08 <lispy_> I want the translation to isabelle to be programmer readable
23:28:11 <ivanm> yeah, I ported over a lot of the indentation-specific stuff from pretty over to wl-pprint-text
23:28:25 <ivanm> because I wanted my Dot code to be nicely indented!
23:28:45 <lispy_> How do you deal with precedence and redundant parens?
23:28:46 <o-_-o> byorgey: Is it too much to ask you for a small example of how to render to a Cairo Ptr or something similar (in diagrams) :-) ?
23:29:01 <lispy_> Someone said I should use showPrec.  I don't know if that's compatible with wl-pprint
23:29:41 <ivanm> ummm.... showPrec is just from the Show class, right?
23:30:56 <ivanm> lispy_: using showsPrec would be to basically use a String builder IIUC
23:31:17 <ivanm> without pretty-printing combinators on top of it
23:31:42 <ivanm> lispy: but I've found that using wl-pprint-text to be faster than using pretty to produce Strings
23:31:43 <shaleh> tcard: BTW, concrete example number 2 does not actually run in ghci
23:31:59 <shaleh> tcard: the State constructor in getNext does not pass.
23:32:10 <lispy_> ?hoogle showPrec
23:32:10 <lambdabot> No results found
23:32:14 <lispy_> ?hoogle showsPrec
23:32:14 <lambdabot> Prelude showsPrec :: Show a => Int -> a -> ShowS
23:32:15 <lambdabot> Text.Show showsPrec :: Show a => Int -> a -> ShowS
23:32:35 <lispy_> ?hoogle ShowS
23:32:36 <lambdabot> Prelude type ShowS = String -> String
23:32:36 <lambdabot> Text.Show type ShowS = String -> String
23:32:36 <lambdabot> Prelude shows :: Show a => a -> ShowS
23:32:57 <lispy_> ivanm: does that help?
23:33:05 <roconnor> preflex: xseen edwardk
23:33:06 <preflex>  edwardk was last seen on freenode/#haskell 3 hours, 29 minutes and 58 seconds ago, saying: i'll take a look at the planar graph stuff when i'm less frazzled ;)
23:33:13 <lispy_> > showsPrec 1 "3+2"
23:33:15 <lambdabot>   Overlapping instances for GHC.Show.Show
23:33:15 <lambdabot>                              (GHC.B...
23:33:27 <lispy_> > showsPrec 1 "3+2" ""
23:33:28 <lambdabot>   "\"3+2\""
23:33:33 <ivanm> lispy_: yeah, already looked it up
23:33:37 <lispy_> > showsPrec 2 "3+2" ""
23:33:38 <lambdabot>   "\"3+2\""
23:33:43 * lispy_ doesn't actually know how to use it
23:33:50 <ivanm> > shows 1 . shows "+" . shows 2 $ ""
23:33:51 <lambdabot>   "1\"+\"2"
23:34:12 <Favonia> > showsPrec 2 (1.23456789) ""
23:34:13 <lambdabot>   "1.23456789"
23:34:16 <Favonia> hmmm
23:34:25 <ivanm> lispy_: all shows and showsPrec is for is to be more efficient at joining together Strings than ++
23:34:45 <ivanm> lispy_: i.e. ShowS is the builder for Strings (it's an explicit DList)
23:35:00 <lispy_> oh
23:35:41 <lispy_> I thought Haskell98 had something to help with printing nested things so that they had the right number of parens
23:36:07 <lispy_> Not something I need very often so I never really looked into it
23:36:09 <ivanm> lispy_: that's what the showsPrec version is for, yes: adds in precedence support
23:36:30 <ivanm> > show (Just (Just 3))
23:36:31 <lambdabot>   "Just (Just 3)"
23:36:45 <ivanm> lispy_: ^^ it's showsPrec that lets it figure out to put parens around the inner Just
23:36:45 <lispy_> oh, showParen
23:36:46 <tcard> shaleh: interesting, change "State" to "state" (lowercase)
23:36:54 <Favonia> > showsPrec 20 (1.23456789) ""
23:36:55 <lambdabot>   "1.23456789"
23:37:20 * ivanm only knows this from writing custom Show instances
23:37:34 <tcard> shaleh: and the import should be "import Control.Monad.State.Lazy"
23:37:49 <lispy_> > shows 1 Just . shows 2 Just . shows 2 3 $ ""
23:37:50 <lambdabot>   Couldn't match expected type `GHC.Base.String'
23:37:50 <lambdabot>         against inferred typ...
23:38:02 <lispy_> :t shows 1 Just
23:38:03 <lambdabot>     Couldn't match expected type `String'
23:38:03 <lambdabot>            against inferred type `a -> Maybe a'
23:38:03 <lambdabot>     In the second argument of `shows', namely `Just'
23:38:21 <lispy_> > shows 1 "Just" . shows 2 "Just" . shows 2 "3" $ ""
23:38:22 <lambdabot>   Couldn't match expected type `a -> b'
23:38:22 <lambdabot>         against inferred type `GHC.Ba...
23:38:27 * lispy_ is too tired
23:38:31 <lispy_> I should just go to bed :)
23:39:03 <Favonia> > shows 1 . shows 10 . shows (1,2,3) $ ""
23:39:04 <lambdabot>   "110(1,2,3)"
23:39:19 <lispy_> :t shows
23:39:19 <ivanm> lispy: you want showsPrec there, not shows
23:39:20 <lambdabot> forall a. (Show a) => a -> String -> String
23:39:36 <lispy_> > showsPrec 1 "Just" . showsPrec 2 "Just" . showsPrec 2 "3" $ ""
23:39:38 <lambdabot>   "\"Just\"\"Just\"\"3\""
23:39:40 <ivanm> @hoogle String -> ShowS
23:39:40 <lambdabot> Prelude showString :: String -> ShowS
23:39:41 <lambdabot> Text.Show showString :: String -> ShowS
23:39:41 <lambdabot> Prelude showList :: Show a => [a] -> ShowS
23:40:07 <fragamus> i have to confess, i am sweet on one of you guys
23:40:15 <lispy_> > showsPrec 1 Just . showsPrec 2 Just . showsPrec 2 3 $ ""
23:40:15 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> Data.Maybe.Maybe a)
23:40:16 <ivanm> > showsParen (show 1 . showString "," . show 2) ""
23:40:16 <lambdabot>    arisin...
23:40:16 <lambdabot>   Not in scope: `showsParen'
23:40:24 <ivanm> > showParen (show 1 . showString "," . show 2) ""
23:40:25 <lambdabot>   Couldn't match expected type `a -> b'
23:40:25 <lambdabot>         against inferred type `GHC.Ba...
23:40:29 <ivanm> @type showParen
23:40:30 <lambdabot> Bool -> ShowS -> String -> String
23:40:35 <fragamus> it's lambdabot
23:40:36 <ivanm> > showParen True (show 1 . showString "," . show 2) ""
23:40:37 <lambdabot>   Couldn't match expected type `a -> GHC.Base.String'
23:40:37 <lambdabot>         against inferre...
23:40:41 <ivanm> gah!
23:40:59 <ivanm> > (show 1 . showString "," . show 2) ""
23:41:00 <lambdabot>   Couldn't match expected type `a -> b'
23:41:00 <lambdabot>         against inferred type `GHC.Ba...
23:41:05 <ivanm> oh, duh
23:41:10 <ivanm> > showParen True (shows 1 . showString "," . shows 2) ""
23:41:12 <lambdabot>   "(1,2)"
23:41:26 <ivanm> lispy_: ^^ the Show instance for (,) would be something like that
23:41:35 <lispy_> ivanm: anyway.  The real question is, do you have any advice about how to do this when using wl-pprint-text?
23:41:46 <ivanm> lispy_: how to do what precisely?
23:41:57 <ivanm> precedence stuff?
23:42:08 <lispy_> ivanm: pretty print an ast so that you don't have extra parens
23:42:17 <ivanm> hmmm.....
23:42:29 <lispy_> When translating languages of course
23:42:33 <lispy_> So not just showing the AST
23:42:48 <ivanm> lispy_: write your own type class with something like: prettyPrint :: Int -> a -> Doc
23:42:59 <ivanm> where the Int is the precedence
23:43:33 <lispy_> Oh, so mimic the showsPrec stuff on top of the wl-pprint stuff?
23:43:38 <ivanm> hmmm.... or could you just have: precedence :: a -> Int
23:43:45 <ivanm> lispy_: yeah
23:43:48 <sanjoyd> Hi! What does this mean: "`foo' is not a derivable class"?
23:43:56 <sanjoyd> Rather, what do I need to do to make it derivable?
23:44:15 <lispy_> sanjoyd: the classes that can be automatically derived are built into the language.  But, there are some things you can do to add other things.
23:44:27 <Jafet> Patch GHC?
23:44:46 <ivanm> Jafet: heh
23:44:51 <lispy_> sanjoyd: Generalized Newtype Deriving, DrIFT, and Template Haskell come to mind
23:44:52 <sanjoyd> lispy_: so I can't define a class foo and have people do "data X = ... deriving foo"?
23:44:59 <ivanm> Jafet: and get that class into Base if it's not already there
23:45:05 <sanjoyd> lispy_: okay, I'll google those terms. :)
23:45:06 <ivanm> sanjoyd: no
23:45:27 <ivanm> see the derive package on hackage
23:45:33 <ivanm> (or is it deriving?)
23:45:38 <lispy_> sanjoyd: drift is the closest match to what you just typed, but template haskell is probably easier to use
23:45:40 <o-_-o> cairo-pdf how does one install this ?
23:45:42 <ivanm> it's similar to DrIFT, but IIRC I had more luck with it
23:45:55 <o-_-o> but cabal and apt-get fail to find anything by name cairo-pdf
23:45:58 <ivanm> o-_-o: umm..... is that the C header files?
23:46:04 <ivanm> o-_-o: cairo-devel or something?
23:46:19 <sanjoyd> lispy_: thanks.
23:46:27 <o-_-o> ivanm: No package 'cairo-pdf' found, is what cabal says
23:46:31 <lispy_> ubuntu/debian add -dev.  -devel is for things like redhat
23:46:35 <sanjoyd> I guess I'll wait till I'm comfortable with the basics.
23:46:36 <ivanm> o-_-o: it's not a haskell package
23:46:47 <ivanm> lispy_: whatever the binary-distro-in-question uses then ;)
23:46:56 <ivanm> sanjoyd: see also http://hackage.haskell.org/package/derive
23:47:02 <sanjoyd> ivanm: thanks.
23:47:23 <lispy_> sanjoyd: yeah, it's slightly non-standard but if you know the basics of haskell it should be doable
23:47:52 <ivanm> lispy_: though in either case don't you need a patch to DrIFT or derive?
23:48:07 <ivanm> using TH let's you avoid that, but isn't a walk in the park either...
23:48:48 * ivanm decides to call it a day
23:49:45 <ivanm> lispy_: I'll probably be around later on if you need help with wl-pprint-text
23:50:10 <lispy_> ivanm: cool
23:50:23 <lispy_> ivanm: I think this example instance here shows me enough to get started: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Text-Show.html#t%3AShow
23:50:32 <lispy_> ivanm: I won't get started till this weekend though.
23:50:39 <ivanm> OK
23:50:40 <sanjoyd> Template Haskell smells a lot like LISP macros.
23:50:48 <ivanm> I probably won't be around this weekend though
23:50:50 <ivanm> ;)
23:50:50 <sanjoyd> At least from "1 What is Template Haskell".
23:51:06 <lispy_> sanjoyd: it's pretty different in good ways
23:51:07 <ivanm> sanjoyd: IIRC, lisp macros are more powerful
23:51:13 <lispy_> sanjoyd: it's type correct for one thing
23:55:30 <NihilistDandy> I was reading a paper on Template Haskell, and then I got distracted reading about hylomorphisms...
23:55:36 <NihilistDandy> Then my ears started to bleed
