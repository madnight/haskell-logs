00:01:32 <Axman6> at the moment it's using a linked list with four pairs per node (and a linked list at the end for the rest remainder)
00:03:12 <Axman6> i think the real problem with this program is IO performance though
00:03:20 <Axman6> hmm, maye  not
00:03:22 <Axman6> maybe*
00:05:16 <ddarius> preflex: seen copumpkin
00:05:16 <preflex>  copumpkin was last seen on #haskell 12 days, 54 minutes and 6 seconds ago, saying: * copumpkin goes to sleep
00:15:21 <Axman6> seems a binary search might be useful here.
00:32:18 <Axman6> argh, maybe i should have written binary search code before now in my life...
00:35:07 <mauke> step a z | a >= z = Nothing | otherwise = case compare (xs ! m) t of { EQ -> Just m; LT -> step a m; GT -> step (m + 1) z } where m = a + (z - a) `div` 2
00:37:38 <Axman6> i have a feeling a linear search might be a bit quicker here, given the number of values to check
00:40:03 <Axman6> urgh. unsafeAt in GHC.Arr only works on Array, not UArray -_-
00:40:06 <thorat> does hasktags not process lhs files?
00:41:54 <Axman6> god damnit >_<
00:44:52 <haskellnoob> hi
00:44:57 <tim> i just installed libghc6-opengl-blahblahblah
00:45:45 <tim> are there any programs/demos i can run to make sure i installed what i needed to?
00:46:45 <haskellnoob> I have a homework question about functors...can anyone help?
00:47:23 <Axman6> not without you asking the question...
00:47:48 <haskellnoob> Haha OK I'll just ask it
00:49:41 <thorat> oh, nevermind, hasktags does indeed process .lhs files.  It just didn't catch everything.
00:49:49 <haskellnoob> If I"m defining and instance of functor for a type class f, I need to define a function fmap that has the type signature fmap :: (a -> b) -> f a -> f b. But when I try this with a type class f that inherits from Ord, it requires that the function needs to be of the type with (Ord a -> Ord b). I can't change the type signature of fmap. So basically, how would one create an instance of functor for a type class that inherits?
00:50:17 <tim> whats a good starting resource for using opengl with haskell
00:50:19 <tim> im on ubuntu
00:50:28 <mauke> haskellnoob: you can't define functor instances for classes
00:50:32 <mauke> haskellnoob: instances are for types
00:51:15 <haskellnoob> @mauke yes but can't types inherit too?
00:51:15 <lambdabot> Unknown command, try @list
00:51:21 <mauke> haskellnoob: no
00:52:54 <tim> is anyone here familiar with using opengl with haskell?
00:53:17 <Axman6> haskellnoob: haskell classes are not like OOP classes. they define a set of functions types can implement to be memberts of the class
00:53:54 <Axman6> tim: I'm not, but there are tutorials out there
00:54:02 <Axman6> @google haskell opengl tutorial
00:54:03 <lambdabot> http://www.haskell.org/haskellwiki/Opengl
00:54:03 <lambdabot> Title: OpenGL - HaskellWiki
00:54:11 <tim> axman i know, ive used google
00:54:17 <tim> that very site
00:54:26 <tim> i cant tell if ive installed what i needed to
00:54:32 <shachaf> tim: If you have a specific question, you should probably just ask it. :-)
00:54:44 <tim> thanks
00:55:03 <Axman6> open ghci and run :m +Graphics.Rendering.OpenGL
00:55:14 <tim> im looking for simple graphics demos i can compile to see if they work fine
00:55:21 <tim> thanks axman i will...
00:55:29 <mauke> haskellnoob: what do you mean by "buzz"?
00:56:38 <mauke> haskellnoob: yes, your name
00:56:49 <haskellnoob> mauke does this work?
00:56:53 <haskellnoob> mauke: does this work?
00:56:54 <mauke> what do you mean by "work"?
00:56:59 * Axman6 senses some /msg'ing going on
00:57:09 * Phyx- senses it too
00:57:12 <haskellnoob> ok i'll just talk through this haha
00:57:17 <Axman6> haskellnoob: keep your questions in the channel
00:57:24 <shachaf> Yes, this haha is the best one.
00:57:44 <shachaf> A /msg window makes a pretty bad haha.
00:57:56 <mauke> data Ord a => Tree a = ....
00:58:06 <mauke> Tree is a type, not a class, and it doesn't inherit anything
00:58:12 <haskellnoob> oh i see
00:58:27 <haskellnoob> so what does the Ord a constraint really do?
00:58:34 <shachaf> Nothing good.
00:58:37 <Axman6> putting class constraints on data types is frowned upon
00:58:52 <tim> Axman6: forgive me, but what does :m do?
00:59:03 <tim> it worked fine
00:59:05 <Axman6> loads a module, it's short for :module
00:59:10 <Phyx-> Axman6: it is? sheesh, what isn't frowned upon...
00:59:36 <tim> thanks, you're probably thinking i have no business messing with opengl if i didnt know that, but i appreciate your help :)
00:59:36 <Axman6> Phyx-: well, there's no good reason to do it, and people tend to yell at you when you do it
00:59:42 <c_wraith> Phyx-: well, it doesn't do anything useful, so it's kind of a wart that it's allowed.
00:59:42 <shachaf> Phyx-: Not putting class constraints on data types isn't frowned upon.
00:59:57 <tim> but yeah, my prompt changed when i entered that
00:59:58 <haskellnoob> ah interesting
01:00:33 <Axman6> tim: if it worked, then the OpenGL package is installed, and probably working fine
01:00:53 <Phyx-> c_wraith,Axman6  lol
01:01:11 <haskellnoob> So back to my original question, the reason why I can't create an instance of Functor for Tree is because the fact that there's a class constraint of Ord onTree?
01:01:18 <tim> cool i tried :m +Fuckass.Dickface and was happy to see an error
01:02:18 <tim> hopefully my next questions here will be more informed ones. ill probably be back under a different name :)
01:02:40 <Axman6> what are you using to learn haskell?
01:03:09 <haskellnoob> I'm using LYAH
01:03:13 <tim> me too
01:05:28 <haskellnoob> also, the error I get says "Possible fix: add (Ord a) to the context of the type signature for 'fmap'". Is it possible to change the type signatures of type class methods when creating instances?
01:06:05 <mauke> no
01:06:13 <mauke> you'd have to change the class definition
01:06:17 <haskellnoob> ah
01:06:19 <haskellnoob> that makes sense
01:06:24 <haskellnoob> thanks
01:26:43 <ddarius> Here's a simple exercise:  Is this function strict in a?  Why or why not?  f [] a = a; f(_:xs) a = f xs a
01:27:08 <mauke> yes
01:27:32 <mauke> because f x undefined = undefined
01:28:52 <nwf> I would have said "no" because the only case expression in its Core representation is on its first argument.
01:29:44 <mauke> nwf: g _ _ _ = undefined  -- strict in all arguments
01:29:52 <nwf> I stand corrected.
01:29:52 <ddarius> mauke: That's not a very compelling argument.  The question is "is f xs undefined = undefined?" for all xs, so you have to explain -why- f xs undefined = undefined for all xs.
01:30:16 <mauke> well, there are three possible cases for xs
01:30:20 <mauke> 1) undefined
01:30:31 <mjk> which difference does map and fmap?
01:30:33 <mauke> since f pattern matches on xs, that results in undefined
01:30:40 <mauke> 2) []
01:30:48 <Botje> mjk: works on all functors, not just lists
01:30:56 <mauke> undefined because of the first equation
01:31:02 <mauke> 3) _ : _
01:31:03 <ddarius> As a related question, does f necessarily evaluate a (assuming no speculative evaluation or anything like that.)
01:31:25 <mauke> undefined because we recurse down to f
01:31:32 <mauke> actually that analysis is bogus
01:31:33 <shachaf> ddarius: Necessarily? Not if the first argument is bottom or infinite.
01:31:49 <mauke> we have to consider the entire composition of xs
01:32:12 <mauke> but the results are correct :-)
01:32:16 <nwf> Well, "f (repeat _) a" is another way of spelling a bottom.
01:32:18 <ddarius> mauke: Indeed.
01:32:43 <ddarius> mauke: It's easy to get the right answer for the wrong reasons, or to "prove" the wrong answer.
01:33:51 <mauke> in case 3 we call f again, so we're back to 3 cases
01:34:14 <mauke> 1 and 2 are already dealt with; what if we keep hitting case 3?
01:34:25 <mauke> then the whole thing is bottom anyway and we succeed
01:34:31 <shachaf> ddarius: How would you "prove" the wrong answer?
01:35:03 <ddarius> shachaf: By using induction.  Particularly, induction on the structure of the first argument.
01:35:07 <mauke> I'd say f doesn't evaluate a
01:36:23 <shachaf> How would you come up with f being non-strict in a?
01:37:01 <shachaf> (Oh, did you mean the second question?)
01:37:24 <ddarius> shachaf: In this case you wouldn't, though I'm sure I can make one where you would.  For the evaluation question, though, you could.
01:37:59 <shachaf> Ah, OK.
01:39:14 <shachaf> Is there a standard word, like strict, for "evaluates its argument"?
02:02:04 <Lemmih> shachaf: Strict in its arguments?
02:02:15 <shachaf> Lemmih: ?
02:02:37 <Lemmih> shachaf: I think you just say that they are strict.
02:02:55 <mauke> Lemmih: g _ _ _ = undefined  -- strict in all arguments
02:03:02 <shachaf> Lemmih: (const undefined) is strict in its argument.
02:03:13 <Lemmih> shachaf: if f(_|_) = _|_ then f is strict in its argument.
02:03:20 <shachaf> Right.
02:03:36 <shachaf> Which doesn't mean that it evaluates its argument.
02:03:57 <c_wraith> it does in non-degenerate cases...
02:04:09 * Lemmih should read more of the back log.
02:04:24 <shachaf> c_wraith: Which is why I was hoping for a more precise term. :-)
02:04:27 <c_wraith> the only way a strict function can fail to evaluate its argument is by always being _|_
02:08:13 <Phyx-> :t (0.0)
02:08:14 <lambdabot> forall t. (Fractional t) => t
02:11:39 <Feuerbach> Here's another one. Is seq strict in its first argument? :)
02:12:13 <c_wraith> yes.  that's the entirety of the semantics of seq.
02:12:30 <Feuerbach> c_wraith: what definition of "strict" are you using?
02:12:54 <c_wraith> a function f is strict if f(_|_) = _|_
02:13:05 <Feuerbach> but seq _|_ /= _|_
02:13:19 <shachaf> > seq (seq undefined) 5
02:13:20 <lambdabot>   5
02:13:27 <Feuerbach> yup
02:14:20 <shachaf> Fortunately (const _|_) is indistinguishable from _|_ without seq. :-)
02:15:10 <roconnor> I don't understand why seq wasn't restricted to non-function arguments.
02:15:39 <roconnor> like how nf more or less works
02:16:22 <Feuerbach> roconnor: but seq still may be useful for functions
02:16:34 <Feuerbach> functions are not always in normal form
02:16:36 <roconnor> It's possible.  I've never seen such a use
02:16:48 <roconnor> Feuerbach: yes but seq doesn't put things in normal form
02:16:55 <roconnor> or even in head normal form
02:17:29 * hackagebot data-accessor 0.2.1.8 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.1.8 (HenningThielemann)
02:17:54 <Feuerbach> I think it does
02:18:24 <Feuerbach> > let f = trace "hey" id in f `seq` ()
02:18:25 <lambdabot>   Not in scope: `trace'
02:18:43 <Feuerbach> (just try it in ghci with :m +Debug.Trace)
02:19:45 <roconnor> oh yes it does something
02:20:00 <Feuerbach> roconnor: or, if you are talking about theoretical contract of seq, then of course it is under-specified
02:20:02 <roconnor> I'm curious of examples where it does something useful.
02:20:19 <roconnor> with function arguments
02:20:36 <roconnor> since it does something, I guess it is plausible it does something useful :D
02:21:00 <Lemmih> roconnor: It's useful for run-time compilation.
02:21:27 <Feuerbach> I don't know of such examples either, but it would be short-sighted to prohibit something just because one cannot immediately see an application
02:22:09 <Feuerbach> Lemmih: interesting, do you have any reference?
02:22:22 <Feuerbach> or could you elabourate?
02:23:25 <Spockz> is someone using gitit here with restrictions on who can edit which pages/sections?
02:23:53 <Spockz> I'm looking at it as a replacement of our twiki sites
02:24:23 <Lemmih> Feuerbach: I had some code which made custom pretty-printers using run-time compilation. seq would be necessary to make sure it doesn't hold on to the input text.
02:25:32 <roconnor> interesting
02:26:03 <roconnor> I wouldn't mind seeing more detail :)
02:26:49 <roconnor> I don't really see how putting a function in WHNF will discharge any inputs
02:26:58 <roconnor> ... though maybe if the inputs are unused.
02:27:05 <Spockz> seq puts things in weak head normal form right?
02:27:27 <roconnor> ya
02:27:34 <shachaf> Is there any reason seq isn't strict in its first argument? That's pretty weird.
02:27:53 <roconnor> when I implement seq I'm going to simply eta expand my functions.  TADA, weak head normal form :P
02:28:31 <roconnor> shachaf: there is no guarentee about the order that the arguments of seq are evaluated in.
02:28:46 <roconnor> I seem to recall there were some important reasons for that ...
02:28:56 <mauke> seq is strict in all arguments
02:29:08 <roconnor> er
02:29:12 <roconnor> ya what mauke said
02:29:12 <Feuerbach> shachaf: you could define seq' x = x `seq` id. That's a "stricter" seq. I think it even satisfies the seq's contract.
02:29:25 <Feuerbach> mauke: what definition of strict are you using?
02:29:44 <roconnor> actually maybe Feuerbach is right
02:29:50 <roconnor> since (seq undefined) isn't undefined.
02:30:02 <shachaf> Feuerbach: Right. Why doesn't seq behave that way?
02:30:04 <mauke> a function f ... x ... = y is strict in x if f ... undefined ... = undefined
02:30:22 <Lemmih> roconnor: Say I have a bunch of users, each with a custom format string like "%s-%d". I use runtime compilation to translate that into a 'Data -> Output' function. However, without seq, the custom format string will still be reachable by the GC.
02:30:23 <roconnor> > seq (pseq undefined) 5
02:30:24 <lambdabot>   5
02:30:29 <roconnor> :(
02:30:49 <shachaf> mauke: Right. seq x = (\y -> ...) isn't strict in x.
02:31:04 <mauke> but seq x y = ... is
02:31:13 <roconnor> Lemmih: I can't imagine code you could write such that using seq would release that string.
02:31:39 <shachaf> mauke: That's a strange way of putting it.
02:32:01 <roconnor> mauke: how do you know how many arguments a function has?
02:32:03 <Feuerbach> mauke: how do you know how many arguments to put? would you also go through a newtype?
02:32:20 <mauke> roconnor: convention
02:32:30 <roconnor> ok
02:32:34 <Lemmih> rprije: The wiki has an example of exactly such code. No imagination needed. (:
02:32:52 <shachaf> > seq True const True undefined
02:32:53 <lambdabot>   True
02:33:54 <Feuerbach> haha :)
02:34:30 <Lemmih> Err, roconnor, not rprije.
02:34:54 <roconnor> http://www.haskell.org/haskellwiki/Special:Search?ns0=1&ns4=1&search=seq&searchx=Search
02:34:56 <Lemmih> roconnor: A simple example would be: f cond = if cond then a else b.
02:35:20 <Lemmih> roconnor: Google runtime compilation.
02:36:06 <roconnor> the word "seq" doesn't appear in that page
02:37:12 * ski . o O ( RTCG ? )
02:37:17 <Lemmih> roconnor: You're looking for code that /could/ release its first argument by using seq. Not code that actually does it.
02:37:54 <roconnor> well, I'm looking for code that in GHC /would/ realease its first argument.
02:38:35 <Lemmih> roconnor: How about this: f str = if str == "multiply!" then (*) else (+)
02:38:57 <roconnor> okay
02:40:06 <roconnor> > let f str = if str == "multiply!" then (*) else (+) in seq (f "multiply!") 5
02:40:07 <lambdabot>   5
02:40:11 <roconnor> > let f str = if str == "multiply!" then (*) else (+) in seq (f undefined) 5
02:40:12 <lambdabot>   *Exception: Prelude.undefined
02:40:15 <roconnor> :D
02:40:46 <Lemmih> This code could benefit from seq: 'g = f getTextOutOfVeryBigByteString'
02:41:14 <roconnor> I'm surprised pseq undefined isn't undefined.
02:42:16 <roconnor> > let seq' x = x `seq` id in seq (seq' undefined) 5
02:42:16 <lambdabot>   *Exception: Prelude.undefined
02:42:24 <Feuerbach> Lemmih: I don't see what you mean here. What are f and g?
02:42:33 <roconnor> > let seq' x = x `seq` id in seq (seq' (undefined::Int -> Int)) 5
02:42:34 <lambdabot>   *Exception: Prelude.undefined
02:42:48 <Feuerbach> i.e. could you give the types?
02:43:08 <roconnor> Lemmih: yes, I see now
02:43:23 <ski> roconnor : another example could be an applicative parser that pre-scans the parser tree to construct the parsing function
02:44:05 <Feuerbach> roconnor: I don't, could you explain?
02:44:14 <Lemmih> Feuerbach: Well, 'f :: String -> (Integer -> Intger)' and 'g :: Integer -> Integer'.
02:44:24 <roconnor> it someways it makes me sad having to fiddle around with morally isomorphic functions.  I guess that is usual for fiddling with operational issues.
02:44:39 <ski> also, `(++) [] = \ys -> ys; (++) (x:xs) = \ys -> x : xs_append ys where xs_append = (++) xs'
02:44:58 <roconnor> Feuerbach: suppose f is defined as
02:45:06 <roconnor> f str = if str == "multiply!" then (*) else (+)
02:45:11 <Feuerbach> Lemmih: if f is defined as "f x y = ...", then seq would do nothing, right?
02:45:19 <ski> hm, or possibly one should `seq' `xs_append' in there ..
02:45:20 <Lemmih> Feuerbach: Right.
02:45:21 <Feuerbach> roconnor: no, that example is clear :)
02:45:22 <roconnor> Feuerbach: yes
02:45:53 <roconnor> I like this new stricter seq' x = x `seq` id
02:45:59 <roconnor> maybe I'll use it :D
02:46:21 <Feuerbach> so you'd have to specifically define f to be amenable to this technique. I see
02:46:59 <roconnor> intresting
02:47:24 <roconnor> so when people say seq distigishes from _|_ and (const _|_) that is true, but
02:48:01 <roconnor> the real isse is that seq distigishes \x -> (case x of p -> e) from (case x of p -> \x -> e)
02:48:23 <Lemmih> yeah
02:48:31 <roconnor> which is the pratical consquences of that techinical description!
02:48:46 <roconnor> and exact the same issue that came up with lifted sums
02:48:57 <roconnor> (and lifted products)
02:49:07 <ski> (what is that issue ?)
02:51:23 <roconnor> that f (if x then e1 else e2) and if x then f e1 else f e2 are different
02:51:34 <roconnor> in Haskell (but not in ML)
02:52:05 <roconnor> actually maybe that isn't exactly analogous to what I wrote
02:52:15 <roconnor> but it still seems related somehow ...
02:52:23 <roconnor> er
02:52:29 <Feuerbach> you don't need seq to observe the latter
02:52:30 <roconnor> I used too many x's in my function example
02:52:51 <Feuerbach> one is strict in x and the other is not
02:52:52 <roconnor> seq distigishes \y -> (case x of p -> e) from (case x of p -> \y -> e)
02:55:40 <roconnor> Feuerbach: for products the issue isn't about seq, it is about (_|_,_|_) and _|_ being distinct
02:56:06 <roconnor> which I'm claiming is analgous to const _|_ and _|_ being distinct.
02:56:27 <roconnor> Lemmih: I'm starting to feel better about seq now
02:57:09 <roconnor> after all, we have tossed away so many cartisian categorical laws; what's wrong with tossing out the rest :D
02:58:37 <m4XXX> hey guys is it possible to have a function with the signature [a -> b] -> [b] ?
02:58:46 <roconnor> yes
02:58:50 <Nereid> const []
02:59:03 <Nereid> there isn't much else, though
02:59:20 <m4XXX> xD
02:59:21 <m4XXX> ok ty
02:59:24 <Zao> Nereid: All you need is an a in the function to invoke things with.
02:59:30 <Nereid> but we don't
02:59:31 <roconnor> @free f :: [a -> b] -> [b]
02:59:32 <lambdabot> (forall k. (forall p q. h . p = q . g                        =>                         k p = q)           =>            $map k xs = ys) => $map h (f xs) = f ys
02:59:44 <Nereid> @free f :: a -> b
02:59:45 <lambdabot> h . f = f . g
02:59:53 <Nereid> ...
02:59:55 <roconnor> m4XXX: you mean for a and b to be polymorphic type variables?
02:59:57 <Nereid> lol
02:59:58 <Zao> Nereid: I interpret his type as missing suitable foralls.
03:00:01 <m4XXX> yes
03:00:08 <ski> roconnor : i've pondered making `(_|_,_|_)' and `_|_' observationally the same ..
03:00:09 <Zao> Nereid: Or rather, being a question if you can have a list of functions.
03:00:18 <m4XXX> ubut they dont have to be named a  and b
03:00:18 <Nereid> sure you can.
03:00:26 <roconnor> ski: you can use Miranda
03:00:57 <siracusa> :t map ($ undefined)
03:00:58 <lambdabot> forall a b. [a -> b] -> [b]
03:01:24 <m4XXX> ty^^
03:01:33 <roconnor> ah good.  Fast and Loose reasoning is still morally correct in the presence of seq.
03:01:54 <ski> roconnor : we could make `case e of (x,y) -> ..x..y..' act like `case e of ~(x,y) -> ..x..y..'
03:02:22 <roconnor> thats what miranda does
03:02:43 <ski> ah, ok
03:03:16 <ski> (alternatively, we could have a different product type, which behaves like this)
03:03:31 <roconnor> that wouldn't be unreasonable
03:03:56 <roconnor> you can sort of simulate that in Haskell already, but you need to remember to write ~'s everwhere, ... the compiler won't make you.
03:04:01 <ski> hm, though i suppose unboxed products sortof fulfill this (with other operational semantics)
03:04:11 <roconnor> but it shows that it is totally compatible with haskell.
03:04:30 <ski> (`(# _|_ , _|_ #)' is the same as `_|_')
03:04:51 <roconnor> does (#  #) accept arbitrary types?
03:06:12 <ski> yes
03:06:18 <ski> @kind (# , #)
03:06:19 <lambdabot> ? -> ? -> (#)
03:06:29 <roconnor> > case undefined :+ undefined of x :+ y -> 5
03:06:30 <lambdabot>   *Exception: Prelude.undefined
03:06:44 <roconnor> > case undefined :+ undefined of ~x :+ y -> 5
03:06:45 <lambdabot>   *Exception: Prelude.undefined
03:06:56 <roconnor> > case undefined :+ undefined of ~(x :+ y) -> 5
03:06:57 <lambdabot>   5
03:06:58 <ski> @kind (# (# Int , GHC.Exts.Int# #), Bool #)
03:06:58 <lambdabot> (#)
03:07:35 <ski> (pondering data types with strict fields ?)
03:07:40 <roconnor> ya
03:07:49 <ski> btw, is there a name for `f _|_ _|_ ... _|_ = _|_' (as opposed to `forall x_0 x_1 ... x_{n-1}. forall i. x_i = _|_ => f x_0 x_1 ... x_{n-1} = _|_') ?
03:08:09 <roconnor> so even strict fields are lifted products?
03:08:54 <ski> well, if all the fields are lifted, and there's only one constructor, it looks like that, yes
03:09:17 <ski> (behaving similarly to unboxed products, modulo the unboxing itself)
03:09:53 <ski> .. maybe "`f' is jointly strict (in such and such arguments)" ?
03:14:47 <roconnor> ugh, I'm still confused about the difference between unlifted products and products with strict fields and categorical products
03:17:31 <roconnor> ah right
03:17:41 <c3l> at http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL-GL-CoordTrans.html#t:Size the type for size is supposed to be GLsizei, how should I interpret this? why the i at the end for example. what actually needs to be used is Graphics.Rendering.OpenGL.Size
03:17:51 <roconnor> so with strict fields (_|_, a) = _|_
03:18:35 <roconnor> but with unlifted products (_|_,a) /= _|_  and only (_|_,_|_) = _|_
03:18:50 <roconnor> ski: what is (# undefined, 5 #) ?
03:20:28 <roconnor> > snd (# undefined, 5 #)
03:20:29 <lambdabot>   Couldn't match expected type `(a, b)'
03:20:29 <lambdabot>         against inferred type `(# a1,...
03:20:34 <roconnor> > #snd (# undefined, 5 #)
03:20:35 <lambdabot>   <no location info>: lexical error at character 's'
03:20:40 <roconnor> > snd# (# undefined, 5 #)
03:20:42 <lambdabot>   Not in scope: `snd#'
03:20:46 <ski> > case (# undefined , 5 #) of (# x , _ #) -> x
03:20:46 <lambdabot>   *Exception: Prelude.undefined
03:21:05 <roconnor> > case (# undefined , 5 #) of (# _ , y #) -> y
03:21:06 <lambdabot>   5
03:21:11 <roconnor> :O
03:21:15 <ski> > case (# undefined , 5 #) of ~ (# x , _ #) -> x
03:21:16 <lambdabot>   Couldn't match kind `(#)' against `*'
03:21:22 <roconnor> pfft
03:21:29 <ski> > let (# x , _ #) = (# undefined , 5 #) in x
03:21:30 <lambdabot>   *Exception: Prelude.undefined
03:21:48 <ski> > let (# _ , _ #) = (# undefined , 5 #) in ()
03:21:49 <lambdabot>   ()
03:21:54 <ski> interesting
03:22:20 <ski> hum, no you used `snd', not `fst'
03:22:23 * ski redoes
03:22:30 <ski> > case (# undefined , 5 #) of (# _ , y #) -> y
03:22:30 <lambdabot>   5
03:22:38 <roconnor> ski: how does (# , #) differ form ( , )?
03:23:09 <ski> ok, so i was wrong, `(# _|_ , _|_ #)' is not `_|_'
03:23:16 <roconnor> or does it only have operational differences?
03:23:19 <Nereid> > case undefined of (# _ , _ #) -> ()
03:23:20 <lambdabot>   Couldn't match kind `(#)' against `*'
03:23:24 <Nereid> m
03:23:45 <roconnor>  > case fix id of (# _ , _ #) -> ()
03:23:49 <roconnor> > case fix id of (# _ , _ #) -> ()
03:23:50 <lambdabot>   Couldn't match kind `(#)' against `*'
03:23:53 <roconnor> :/
03:24:24 <roconnor> > case let x = x in x of (# _ , _ #) -> ()
03:24:25 <lambdabot>   Couldn't match kind `(#)' against `*'
03:25:37 <roconnor> (# a, b #) has no undefined element?
03:26:01 <ski> Prelude GHC.Base> case error "foo !" of (# _ , _ #) -> ()
03:26:02 <ski> *** Exception: foo !
03:26:08 <roconnor> whew
03:26:29 <Nereid> > case error "foo !" of (# _ , _ #) -> ()
03:26:30 <lambdabot>   *Exception: foo !
03:26:32 <roconnor> I don't see why that isn't a type error :)
03:26:38 <Nereid> quite
03:26:58 <roconnor> @type error
03:26:59 <lambdabot> forall a. [Char] -> a
03:27:00 * ski for some reason though the `error' in lambdabot hadn't the right kinds in the type ..
03:27:32 <roconnor> ski: no error works in lambda bot
03:27:42 <roconnor> but fix id and undefined all give type errors
03:28:03 <roconnor> though I don't see why error works but not the others
03:28:37 <Nereid> > case error "foo !" of (_,_) -> ()
03:28:38 <lambdabot>   *Exception: foo !
03:28:42 <Nereid> > case error "foo !" of _ -> ()
03:28:43 <lambdabot>   ()
03:28:44 <Nereid> blah
03:28:46 <Nereid> obviously
03:28:58 <roconnor> so other that strange typing errors, I don't see any non-opertaional difference between (# , #) and ( , )
03:29:07 <ski> > case error "foo !" of !_ -> ()
03:29:08 <lambdabot>   *Exception: foo !
03:29:18 <ben> What do I need to do to get unboxed tuples in ghci?
03:29:33 <ski> roconnor : istr seeing `error :: forall (a :: ?). String -> a' somewhere ..
03:29:35 <Nereid> -XMagicHash, no?
03:29:38 <ski> yes
03:29:57 <ski> well, `-XUnboxedTuples'
03:30:01 <ben> Right, cheers
03:30:02 <Nereid> mm
03:30:22 <ski> `-XMagicHash' is needed to use `(+#)',`Int#',&c.
03:30:31 <roconnor> so what does unboxed tuples do?
03:30:38 <ski> (maybe `UnboxedTuples' imply `MagicHash', i don't recall)
03:30:44 <c_wraith> Allows (# #)
03:30:55 <roconnor> ... I mean semantically
03:31:19 <ski> > let x = (# 1 , 2 #) in ()  -- unboxed tuples disallow this
03:31:19 <lambdabot>   Illegal binding of unboxed tuple x :: (# t_a3c1, t_a3c3 #)
03:31:28 <roconnor> ah
03:32:01 <c3l> where can I read about the $= operator. its really hard do find something as it isnt googleable
03:32:03 <roconnor> > (\x -> ()) (# 1 , 2 #)
03:32:04 <lambdabot>   Couldn't match kind `(#)' against `??'
03:32:17 <roconnor> > (\(# x, y #) -> ()) (# 1 , 2 #)
03:32:18 <lambdabot>   Couldn't match kind `(#)' against `??'
03:32:31 <roconnor> remind me to never program with unboxed tuples
03:32:33 <Nereid> c3l: where do you see $=
03:32:43 <Nereid> it's not in one of the standard libraries, i'm pretty sure
03:33:02 <vitka> @hoogle ($=)
03:33:02 <lambdabot> No results found
03:33:11 <vitka> Hmm.
03:33:32 <ski> > let f :: forall a. a -> (); f _ = () in f (# 1 , 2 #)  -- unboxed tuples also disallow this
03:33:32 <lambdabot>   Couldn't match kind `(#)' against `*'
03:33:48 <ski> > let f :: (# Int , Int #) -> (); f _ = () in ()  -- and this
03:33:49 <lambdabot>   Kind mis-match
03:33:49 <lambdabot>  Expected kind `??',
03:33:49 <lambdabot>  but `(# GHC.Types.Int, GHC.Types.Int #...
03:33:58 <c3l> Nereid: when using glfw and opengl. but ive imported opengl as GL and glfw as GLFW, but the operator $= needs not prefix like GL.$=
03:34:06 <ski> @index $=
03:34:06 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
03:34:11 <Nereid> c3l: did you say "import qualified"?
03:34:12 <ski> c3l : ^
03:34:27 <c3l> just import ... as ..
03:34:31 <Nereid> that's why
03:35:31 <Nereid> if the Foo module exports bar,
03:35:37 <c3l> so I dont actually need to prefix any function? but I can if I want to? aaah ohh. thanks!
03:35:39 <Nereid> then "import Foo as F" makes both bar and F.bar
03:35:48 <Nereid> "import qualified Foo as F" makes only F.bar
03:36:14 <ski> roconnor : i'm not sure there's a valid reason for not being allowed to pass unboxed tuples as arguments .. there is a valid reason to not being able to store them in polymorphic containers like e.g. lists, though
03:37:02 <ben> I thought the reason is that they do not have a representation like all the other values and are just magic syntax to shuffle a bunch of registers around
03:37:23 <ski> roconnor : the idea being that to represent a `(# a , b #)', you just represent an `a' and a `b' separately (e.g. in different registers)
03:38:11 <ski> so there's no uniform size of values of type with kind `(#)', and so polymorphic containers wouldn't be able to work with a uniform representation
03:38:29 <Nereid> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
03:38:48 <Nereid> I guess
03:38:58 <Nereid> mm, I see a typo in the last code listing
03:39:46 <ski> either one would need specialized versions of the types (and possibly of the polymorphic functions as well (and polymorphic recursion as well as existentials make this unbounded));  or one would need to pass evidence at run-time corresponding to the implicit type arguments, the evidence telling the size and layout of the data of the type
03:40:46 <ski> (Mercury does something similar to this, because it has polymorphic unification, so needs to implicitly pass unification procedures for the type variables for polymorphic predicates/functions)
03:42:59 <ski> ben : they have a representation, but it's not uniform -- even more, it's "scattered" ..
03:43:29 <ben> I meant that as you said that (# a, b #) is represented by a and b and not by some tuple structure
03:43:40 <ski> yes
03:43:44 <ski> it's still a representation :)
03:45:17 <ski> the point of the restriction of not being able to store them in polymorphic containers, or being able to pass as argument or result to/from a polymorphic function is to enable this representation
03:49:08 <ski> the idea of "Multi-return Function Call" by Olin Shivers,David Fisher at <http://www.ccs.neu.edu/home/shivers/papers/mrlc-jfp.pdf> is similar, except that here we pass multiple separare continuations to a function (also ensuring they are used uniquely, so we can still stack allocate)
03:52:16 <mjk> i want to define a function, like this: f_maybe :: Maybe a -> a
03:52:17 <mjk> f_maybe (Just a) = a
03:52:32 <mjk> f_maybe Nothing = id ?
03:52:46 <mauke> f_maybe Nothing = error "oh noes"
03:53:09 <mjk> mauke: thx
03:53:10 <Peaker> mjk, "f_maybe Nothing" is of type "a", any "a" at all
03:53:21 <mauke> :t fromJust
03:53:22 <lambdabot> forall a. Maybe a -> a
03:53:27 <mauke> and you shouldn't use that
03:53:30 <Peaker> mjk,whereas "id" is (b -> b), a different type than "a"
04:08:52 <m4XXX> i get with const []  only [a] -> [b -> a] but i need [b -> a] -> [b]... the function ive made is:
04:08:53 <m4XXX> let foobar (x:xs) = [const x]
04:09:17 <m4XXX> it shows me :   foobar :: [a] -> [b -> a]
04:09:37 <Feuerbach> there isn't a way for Haddock to generate single html for multiple modules, is there?
04:10:22 <roconnor> since lisp has quote and eval, they don't need to use macros to create lazy functions?
04:10:44 * roconnor ponders if that is true
04:11:27 <ski> `quote' and `eval' are for staging computations, not related to laziness or closures
04:12:18 * m4XXX has any1 an idea? :s
04:12:19 <Peaker> quoting code will not yield lexical scoping, would it?
04:12:52 <ski> m4XXX : making `forall a b. [b -> a] -> [b]' seems nonsensible
04:13:05 <Peaker> m4XXX, your function also seems wrong, do you really want to take just the first element?
04:13:47 <ski> Peaker : in MetaML/MetaOCaml, there's cross-stage persistence, so free variables inside a quotation will get bound to the values they have outside the quotation
04:13:47 <m4XXX> its the closest solution i could get
04:13:58 <m4XXX> i want the signature [ a->b] -> [b]
04:14:06 <ski> oh, that's another thing
04:14:18 <ski> `const []' is one solution
04:14:28 <ski> didn't people already say this, some while ago ?
04:14:32 <m4XXX> yes
04:14:35 <m4XXX> ive tried it
04:14:41 <m4XXX> but i couldnt get the signature i wanted
04:14:43 <m4XXX> :(
04:15:08 <ski> @type let foo :: forall a b. [a -> b] -> [b]; foo = const [] in foo
04:15:09 <lambdabot> forall a b. [a -> b] -> [b]
04:15:13 <ski> seems to work here
04:15:29 <ski> maybe you forgot to provide an explicit type signature for `foo' ?
04:15:53 <doserj> @type map ($ undefined)
04:15:54 <lambdabot> forall a b. [a -> b] -> [b]
04:16:00 <ski> (Peaker : was that what you were after, or something else ?)
04:16:04 <m4XXX> i want to make a function without type signature, and if i do :t functionNAME i should get the mentioned signature
04:16:05 <roconnor> ski:  consider augustss's any p = or . map p example.  If we had staging I imagine we could build an efficent short-circuted definition of any that uses meta-combinators.
04:16:18 <ski> m4XXX : why without type signature ?
04:16:25 <roconnor> ski: but maybe I'm imagining too much.
04:16:29 <m4XXX> i want to test if it is possible
04:16:34 <Peaker> ski, Yeah, I was going for why lisp quoting doesn't seem like a usable mechanism for laziness
04:16:49 <m4XXX> i know, that you for usual declare a type signature
04:16:50 <Feuerbach> I think quote/eval are restricted to compile time
04:17:42 <ski> Peaker : quotation is unrelated to laziness .. also Lisp quoting typically doesn't quote syntax (with binders) but lists, which will be interpreted later as syntax
04:18:26 <ski> Peaker : quotation in MetaML/MetaOCaml quotes syntax (i.e. it checks that the expression inside the quote is a valid expression, and that it type-checks)
04:18:57 <m4XXX> i want to make a function without type signature that gives me when i check its type "[a -> b]-> [b] ..ive tried const []  but i could get only [a] -> [b -> a]  :/
04:18:58 <ski> so the type checker checks statically that code-generating code will only generate type-correct code
04:19:47 <ski> (you can also optionally use a variant, dynamically-typed, kind of quotation, then scoping will still be checked statically, but types inside the quotation is checked dynamically)
04:19:54 <doserj> m4XXX: there is no useful function whose most general type is [a -> b]-> [b]. you would have to use undefined somewhere, as I demonstrated above.
04:20:20 <m4XXX> it doesnt have to be a "useful" function
04:20:25 <doserj> @type map ($ undefined)
04:20:26 <lambdabot> forall a b. [a -> b] -> [b]
04:20:41 <m4XXX> i only want an exampe for that signature
04:20:52 <ski> (or more correctly, types wrt the quotation and unquotation operations are not checked until run-time, the other parts are still checked statically)
04:21:10 <m4XXX> can i use "map ($ undefined)" just like that in ghci ? o.O
04:21:21 <c_wraith> m4XXX: "useful" doesn't mean "practical" in this context.  It means "able to do anything other than crash or loop forever"
04:21:38 <doserj> > length (map ($ undefined) [1..10])
04:21:38 <lambdabot>   No instance for (GHC.Enum.Enum (a -> b))
04:21:39 <lambdabot>    arising from the arithmetic seq...
04:22:01 <ski> roconnor : hm, what kind of staging did you / augustss have in mind, there ?
04:22:08 <doserj> > length (map ($ undefined) [sin,cos])
04:22:08 <lambdabot>   2
04:22:22 <m4XXX> is there a solutoin with const as well? :P
04:22:33 <roconnor> ski: I have no idea.  I don't do meta-programming :D
04:22:41 <ski> roconnor : passing the list early ? passing the predicate early ?
04:23:28 <roconnor> ski: no no, just building the any function directly so that the resulting function is the same as the direct recursive definition, but is built out of meta combinators that look like foldr and map and whatnot.
04:24:03 <c_wraith> m4XXX: you could use const to generate the args for that function
04:24:19 <c_wraith> > map ($ undefined) $ map const [1..10]
04:24:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
04:25:05 <c_wraith> :t map ($ undefined) . map const
04:25:06 <lambdabot> forall a. [a] -> [a]
04:25:43 <c_wraith> :t id `asTypeOf` map ($ undefined) . map const
04:25:44 <lambdabot>     Precedence parsing error
04:25:44 <lambdabot>         cannot mix `asTypeOf' [infixl 9] and `.' [infixr 9] in the same infix expression
04:26:21 <c_wraith> That's kind of sad.  asTypeOf deserves a lower precedence than default
04:29:11 <ski> roconnor : assuming you want to pass the list early, then in MetaML you can say `fun staged_forAny [     ] = <fn p => []> | staged_forAny (x::xs) = let val forAny_xs = staged_forAny xs in <fn p => p x orelse ~(forAny_xs <p>)> end'
04:29:22 <roconnor> I don't want to pass the list early
04:30:13 <ski> roconnor : and that would get a signature `val staged_forAny : 'a list -> <('a -> bool) -> bool>'
04:31:12 <roconnor> I want the resulting function to be identical to any f = funciton [] -> True | (x:xs) -> x || any f xs
04:31:43 <ski> (actually s/~(forAny_xs <p>)/~forAny_xs p/ ..)
04:32:07 <ski> so that computing `staged_forAny [0,1,2]' generates `<fn p => p 0 orelse p 1 orelse p 2 orelse false>'
04:32:08 <roconnor> but defined something like any f = meta-foldmap f orb True
04:32:27 <ski> (oh, i see s/fn p => []/fn p => false/ as well)
04:33:01 <roconnor> maybe this isn't possible :/
04:33:06 <ski> roconnor : passing `id' as a predicate ?
04:33:43 <ski> hm ..
04:34:06 <roconnor> assuming or = foldr orb True that makes any f = (foldr orb True) . (map f)
04:34:26 <ski> or are you after somehow requiring deforestation of the intermediate list in `any p = or . map p', by using staging in some way ?
04:34:38 <roconnor> well Ideally i want tow rite any = meta-fold orb True `meta-fuse` meta-map f
04:34:56 <roconnor> but I figured I'd make it easier and only require meta-foldmap
04:35:21 <roconnor> and save meta-fuse for later
04:35:44 <ski> i'm not yet seeing what the type of `meta-foldmap' should be
04:35:50 <roconnor> ya me neither
04:35:57 <roconnor> I'm starting to see this as impossible
04:36:09 <ski> though now i think i'm understanding better what you want
04:36:15 <roconnor> but maybe there is a way to do meta-programming of recursive definitions that I'm not seeing.
04:36:50 <roconnor> I've emailed my boss who studies meta-programming
04:36:59 <ski> well, what i'm thinking of (if it works) would require some kind of unquotation at the type-level as well
04:36:59 <roconnor> maybe he'll have some ideas.
04:37:27 <ski> in some sense, you want to generate the list from `map' "early"
04:37:37 <ski> but you still want to generate the list elements late
04:37:59 <ski> so you can't use a type `<[a]>', since then the elements will also be late
04:39:13 <ski> so, assume we write this type as `<[~a]>' for the moment (`<...>' being a quotation and `~...' an unquotation -- compare with `[|...|]' and `$(...)' in TH)
04:39:59 <ski> hm, actually, i'm doing this backwards
04:40:07 <ski> i want `~[<a>]'
04:42:50 <ski> (so we use `~...' first to switch from the normal (run-time) stage of computation to the (early) compile-time / macro-time stage of computation, and at that time we compute the list (or rather, we reduce the list operations at that time -- e.g. the actual length of the list should still be able to depend on run-time values, i think), and then use `<...>' to switch back to run-time, to compute the elements)
04:43:32 <roconnor> @hoogle foldmap
04:43:33 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:43:33 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
04:43:52 <ski> so, to elaborate on this, consider
04:44:48 <ski>   staged_flip_exponentiate :: ~(forall i. Integral i => i -> <forall n. Num n => n -> n>)
04:45:21 <Athas> Ugh, my packages build-depends line is becoming rather large...
04:45:25 <ski> would be more or less a macro, which takes one early input (computed at compile-time), and one late input
04:45:36 <Athas> It takes a while for me to grow comfortable with the large amount of libraries needed in Haskell.
04:45:37 <roconnor> Athas: applicaiton or library?
04:45:37 <c_wraith> Athas: doesn't need to be a single line, you know
04:45:43 <Athas> roconnor: application.
04:46:07 <roconnor> for applications I don't think I mind large numbers of depencies.
04:46:21 <ski> (one can avoid macros, and do with only staged computations and explicit `eval', i think .. at least for that -- maybe not for your `any' case)
04:46:51 <Athas> It's more that can go wrong.
04:46:58 <Athas> Good thing Cabal works well.
04:47:30 <roconnor> sure, reducing depencencies is always a worthy goal.
04:47:59 <ski> roconnor : who's that ?
04:48:04 <ski> Tim O'Sheard ?
04:48:11 <roconnor> who's what?
04:48:18 <ski> <roconnor> I've emailed my boss who studies meta-programming
04:48:24 <roconnor> Jacques Carette
04:48:28 <ski> ok
04:49:29 <ski> hm ..
04:49:46 <ski>   a :: *
04:49:50 <ski>   p :: a -> Bool
04:50:40 <Athas> Many of the dependencies are for things that I expected to be part of another library... eg., I'm surprised array is not part of base, and that X11-xshape and x11-xim is not part of X11.
04:50:44 <ski>   frobbed_map p :: [a] -> ~[<Bool>]
04:51:32 <ski>   futzed_or :: ~[<Bool>] -> Bool
04:51:42 <ski>   futzed_or . frobbed_map p :: [a] -> Bool
04:51:59 <ski>   \p -> futzed_or . frobbed_map p :: (a -> Bool) -> ([a] -> Bool)
04:52:04 <ski>   \p -> futzed_or . frobbed_map p :: forall a. (a -> Bool) -> ([a] -> Bool)
04:52:30 <ski>   frobbed_map :: (a -> Bool) -> ([a] -> ~[<Bool>])
04:52:46 <ski>   frobbed_map :: forall a b. (a -> b) -> ([a] -> ~[<b>])
04:52:55 <Kaidelong> is there an example of a functor that has nothing in the form a -> f b?
04:53:04 <ski> seems to be the types that we want
04:53:07 <Kaidelong> err
04:53:09 <Kaidelong> a -> f a
04:53:23 <ski> Kaidelong : "that has nothing in the form" means ?
04:53:46 <Kaidelong> no general way to take something of type a and get a functor parameterized with type a out of it
04:53:50 <ski> you mean a functor with no `return'/`point' operation ?
04:53:52 <roconnor> ski: now defiend futzed_or using fragged_foldr
04:53:54 <Kaidelong> yes
04:54:09 <ski> roconnor : one step at a time :)
04:55:41 <mauke> Kaidelong: (,) e
04:56:06 <Botje> return x = (undefined, x)
04:56:19 <Kaidelong> Botje: but that's not allowed
04:56:24 <Kaidelong> so (,) e is an example
04:56:25 <mauke> return x = undefined
04:56:31 <mauke> ZOMG GENERIC
04:56:32 <ski> Kaidelong : `data CoYoneda f b = forall a. FMapIncl (a -> b) (f a)', then `CoYoneda IORef' (aka `IOReadRef')
04:56:53 <Botje> well, if you can't bend the rules just a little .. :)
04:57:21 <Kaidelong> that's kind of weird because what you get back is a partially defined value
04:57:49 <joe6> any suggestions on how I can do something like this: > map ($ 1 2) [(\x y -> x + y)]
04:57:59 <joe6> > map ($ 1 2) [(\x y -> x + y)]
04:58:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
04:58:00 <lambdabot>    arising from a use of `...
04:58:06 <joe6> > map ($ 1 ) [(\x  -> x + x)]
04:58:07 <lambdabot>   [2]
04:58:15 <mauke> joe6: map (\f -> f 1 2)
04:58:19 <Botje> @pl \f -> f 1 2
04:58:19 <lambdabot> flip ($ 1) 2
04:58:23 <Kaidelong> I guess the rule here is that fully defined input should produce fully defined output
04:58:28 <Botje> ew
04:58:37 <ski> > let apply_on_1_2 f = f 1 2 in map apply_on_1_2 [(\x y -> x + y)]
04:58:37 <lambdabot>   [3]
04:58:52 <joe6> i have 2 common inputs (params) that I want to supply to a list of functions that take those 2 parameters
04:59:06 <mauke> joe6: why are you saying that?
04:59:11 <joe6> mauke, yes that makes sense.
04:59:21 <ski> > map (($ 2) . ($ 1)) [(\x y -> x + y)]
04:59:23 <lambdabot>   [3]
04:59:28 <joe6> mauke, thanks. it took me a min to comprehend what you had written.
04:59:36 <ski> joe6 : ^
04:59:44 <joe6> ski, thanks
04:59:57 <parcs> or even map (($ 1) >>> ($ 2)) for lexicographical consistency
05:00:07 * ski thought of that
05:00:09 <mauke> preflex: quote . proud
05:00:10 <preflex>  <preaction> [in #perl] don't be too proud of that syntactical terror you've constructed
05:00:12 <Kaidelong> (($2) . ($1))
05:00:14 <Kaidelong> oh
05:00:17 <Kaidelong> ski beat me to it
05:00:50 <joe6>  mauke's version seems to be the most comprehensible.
05:01:08 <ski> *nod*
05:02:05 <Phyx-> *nod*
05:02:59 <Kaidelong> > (($2).($1)).((^).).[1..10]
05:02:59 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a1))
05:03:00 <lambdabot>    arising from a use of `e_12111...
05:03:10 <Kaidelong> > (($2).($1)).(^).[1..10]
05:03:10 <lambdabot>   No instance for (GHC.Enum.Enum (a -> b))
05:03:10 <lambdabot>    arising from a use of `e_121110...
05:03:12 <parcs> > let >.> = (>>>) `on` ($) in ((+) >.> 0 >.> [1..10]) foldl
05:03:13 <lambdabot>   <no location info>: parse error on input `>.>'
05:03:27 <parcs> damn. would that work?
05:03:45 <parcs> > let (>.>) = (>>>) `on` ($) in ((+) >.> 0 >.> [1..10]) foldl
05:03:46 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> b
05:03:50 <Kaidelong> > ($2).($1).(^).[1..10]
05:03:51 <lambdabot>   No instance for (GHC.Enum.Enum (a -> b))
05:03:51 <lambdabot>    arising from a use of `e_121110...
05:04:24 <mauke> > ($2).($1).[(^)]
05:04:26 <lambdabot>   [1]
05:04:53 <Kaidelong> @ty (^).[1..10]
05:04:54 <lambdabot> forall a b. (Num a, Integral b, Enum a) => [b -> a]
05:05:01 <parcs> > let (>.>) = (>>>) `on` ($) in (5 >.> 5) (+)
05:05:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
05:05:01 <lambdabot>    arising from a use...
05:05:09 <Kaidelong> @ty ($1).(^).[1..10]
05:05:09 <lambdabot> forall a. (Num a, Enum a) => [a]
05:05:14 <ski> > [(^)] `flip` 2 `flip` 3
05:05:16 <lambdabot>   [8]
05:05:24 <Kaidelong> oh I see the problem
05:05:50 <ski> > ($ 3) . ($ 2) . [(^)]  -- per mauke
05:05:52 <lambdabot>   [8]
05:06:40 <Kaidelong> did you just write haskell RPN
05:07:07 <parcs> > let (>.>) = (>>>) `on` (flip ($)) in (5 >.> 5) (+)
05:07:08 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
05:09:35 <ski> @type (.)
05:09:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:09:38 <ski> @type flip
05:09:38 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:09:43 <parcs> > let x >.> y = ($ x) >>> ($ y) in (5 >.> 5) (+)
05:09:44 <lambdabot>   10
05:09:45 <ski> @type \f fa -> flip id `fmap` fa `flip` f
05:09:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:09:47 <parcs> success!!!
05:09:50 <ski> @type \ff a -> ($ a) . ff
05:09:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
05:09:55 <ski> cf. ^
05:10:39 <ski> parcs : that doesn't generalize nicely to `x >.> y >.> z', though ..
05:11:05 <parcs> yeah, i wonder if that's possible
05:11:12 <parcs> to implement
05:11:42 <ski>   ff `flip` a = ($ a) . ff
05:12:03 <ski>   f . fa = flip ($) `fmap` fa `flip` f
05:13:15 <ski> @type \f fa -> (flip ($) . fa) `flip` f  -- would be circular ..
05:13:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:13:44 <ski>   futzed_or :: ~[<Bool>] -> Bool
05:13:46 <ski>   frobbed_map :: forall a b. (a -> b) -> ([a] -> ~[<b>])
05:15:52 <ski>   frobbed_map f [    ] = ~[                          ]
05:15:53 <ski>   frobbed_map f (a:as) = ~(<f a> : <frobbed_map f as>)
05:16:09 <ski> that seemed not too hard ..
05:17:14 <ski>   futzed_or ~[    ] = True
05:17:15 <ski>   futzed_or ~(b:bs) = b || futzed_or ~bs
05:17:20 <ski> also easy
05:18:24 <ski> (that's using cross-stage persistance of `b' there .. one could instead match on `b', reflecting it manually)
05:19:07 <ski> .. so i suspect it's the implementation that will be harder :)
05:19:27 <ski>   any :: forall a. (a -> Bool) -> ([a] -> Bool)
05:20:09 <ski>   any p as = futzed_or (frobbed_map p as)
05:20:28 <ski> roconnor : ^ this is what i think they might look like
05:20:34 <Athas> Wow, the performance difference between using Strings and Texts is remarkable.
05:21:01 <ski> hmhm, though now i see that `frobbed_map' is probably the problem, here
05:21:21 <roconnor> ski: nope, you have to use foldr
05:21:22 <roconnor> :P
05:21:56 <ski> naïvely, how can `frobbed_map' decide whether to generate an empty list or a cons list at *compile-time*, depending on an argument matching done on *run-time* ? :)
05:22:10 <ski> it's probably here that the interesting things will happen
05:22:28 <ski> roconnor : i suspect using `foldr' will not be much harder
05:22:56 <ski> (also s/True/False/)
05:23:01 <ski>   or = foldr (||) False
05:23:22 <ski>   futzed_or :: ~[<Bool>] -> Bool
05:23:40 <ski>   ~bs :: ~[<Bool>]
05:23:51 <ski>   futzed_or ~bs :: Bool
05:24:34 <ski>   futzed_foldr (||) False ~bs :: Bool  -- hopefully
05:24:57 <ski>   futzed_foldr (||) False :: ~[<Bool>] -> Bool
05:25:05 <ski>   futzed_foldr (||) :: Bool -> ~[<Bool>] -> Bool
05:25:22 <ski>   futzed_foldr :: (Bool -> Bool -> Bool) ->  Bool -> ~[<Bool>] -> Bool
05:25:46 <ski>   futzed_foldr :: forall a r. (a -> r -> r) -> r -> ~[<a>] -> r
05:27:37 <ski>   futzed_foldr cons nil ~[    ] = nil
05:27:38 <ski>   futzed_foldr cons nil ~(a:as) = cons ~a (futzed_foldr cons nil ~as)
05:27:43 <ski> alternatively
05:27:53 <ski>   futzed_foldr cons nil ~[        ] = nil
05:28:05 <ski>   futzed_foldr cons nil ~(<a>:<as>) = cons a (futzed_foldr cons nil as)
05:28:15 <ski> so
05:28:34 <ski>   futzed_or ~bs = futzed_foldr (||) False ~bs
05:28:37 <ski> and
05:28:44 <ski>   any p as = futzed_or (frobbed_map p as)
05:29:03 <ski>              futzed_foldr (||) False (frobbed_map p as)
05:29:17 <ski> (er, insert a `=' before that line)
05:29:24 <ski> roconnor : ^ ok ?
05:29:28 <roconnor> I don't know
05:29:33 <roconnor> is it really short circuted?
05:29:46 <ski> the semantic problems are still here, of course
05:29:57 <roconnor> semantic problems?
05:30:15 <ski> i've basically just (vaguely) sketched an abstract syntax, and a type system
05:30:36 <ski> i still need an operational semantics (or denotational)
05:30:41 <roconnor> meta-ocaml
05:30:51 <roconnor> or you can ignore the typing and write it in lisp?
05:30:57 <roconnor> s/lisp/scheme
05:31:13 <ski> MetaML/MetaOCaml allow you to use later stages
05:31:19 <ski> here i've used earlier stages
05:31:23 <roconnor> oh
05:31:25 <ski> it's not quite the same thing
05:31:57 <ski> (using a Lisp such as Scheme wouldn't help with this)
05:33:08 <ski> roconnor : i think basically i need something similar to *unboxed* products, but for recursive `data' types (and thus indirectly i need it for variants/sums as well)
05:33:52 <ski> (or i need something which on some level is similar to that, at least)
05:34:31 <ski> roconnor : anyway, ty for making be think about this problem (guaranteed deforestation) in terms of staging -- i hadn't thought of it from that angle before
05:38:40 <Saizan> with foldmap :: <b> -> <(a -> b -> b)> -> <(c -> a) -> [c] -> b> you should get the shortcircuiting, since "foldmap <False> <||>" should produce the same code as writing any directly
05:55:27 <ben> :t (`catch` print)
05:55:28 <lambdabot> IO () -> IO ()
05:55:58 <ben> :t (`Control.Exception.catch` print)
05:55:59 <lambdabot>     Ambiguous type variable `e' in the constraint:
05:55:59 <lambdabot>       `GHC.Exception.Exception e'
05:55:59 <lambdabot>         arising from a use of `Control.Exception.Base.catch'
05:57:21 <Saizan> :t (`Control.Exception.catch` (print :: IOError -> IO()))
05:57:22 <lambdabot> IO () -> IO ()
05:57:49 <ben> What about all the other errors, though?
05:58:48 <Saizan> which?
05:59:04 <hpc> i think he means stuff that doesn't :: IOError
05:59:21 <hpc> i suspect it just falls through, and you have to catch with another handler
05:59:23 <Saizan> ah, you can use SomeException if you want all of them, instead
05:59:32 <hpc> or that
05:59:39 <ben> Why can't it stay dynamic?
06:00:01 <hpc> that's just how it was made
06:00:13 <Saizan> you have to pick a type otherwise it won't know which instance of Exception to use
06:00:17 <hpc> ideally, you don't mess around with exceptions at all, and stick with sane types like Either or Maybe
06:00:58 <ben> Saizan: I kinda hoped it could deal with all the instances, I thought that was the point of polymorphic exceptions
06:01:39 <Saizan> ben: the type "SomeException" is supposed to be at the top of the hierarchy, so you should catch all of them if you use that
06:02:08 <Saizan> i.e. there is an actual type called like that
06:03:46 <ben> Yeah, that works. But why can I not write (`catch` (print :: Exception e => e -> IO ()))?
06:04:00 <ben> Or something of the sort.
06:04:37 <`Zerax`> I'm having problems with deduction failures and ambiguity of type variables for typeclass functions that have zero parameters. Anyone got any advice?
06:04:39 <hpc> ben: because the 'e' type disappears, and ghc has no idea what instance to use
06:06:01 <ben> Oh, dear. I might have been thinking to OOP-polymorphic here.
06:06:22 <ben> I figured it could pull the Show dictionary out of the eventual value at runtime.
06:06:37 <Saizan> heh, no
06:06:45 <Saizan> ?type catch
06:06:45 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
06:06:53 <Saizan> ?type Control.Exception.catch
06:06:54 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
06:07:41 <ben> I just figured, hey, Exception implies Show so this basically says (Show e => e -> IO a) which print would totally fit
06:07:44 <Saizan> with that type, it has to decide which instance of Exception to use when calling catch, not when calling the handler
06:08:05 <ben> I suppose => is not that distributive
06:08:22 <Saizan> if it were "IO a -> (forall e. Exception e => e -> IO a) -> IO a" it'd be more like what you're referring to
06:08:36 <ben> Can I build that, out of catch?
06:08:55 <Saizan> but then you couldn't use catch with an handler that expects a precise type, only with polymorphic ones
06:09:02 <Saizan> mh, let's see
06:09:28 <ben> How does catch figure out whether it's got the right handler when faced with a polymorphic exception, anyway?
06:09:42 <ben> Does it try to coerce the exception into the right type and just goes "welp" and gives up if that fails?
06:10:22 <Saizan> except for the welp, yes, simply by calling fromException
06:11:14 <Saizan> anyhow, you can "mycatch :: IO a -> (forall e. Exception e => e -> IO a) -> IO a; mycatch m h = C.E.catch m (\(SomeException e) -> h e)"
06:11:22 <ben> which is in the dictionary that catch gets handed on its invocation?
06:11:30 <Saizan> right
06:11:32 <ben> Ah, I see
06:12:34 <ben> I think I did not realise that the dictionary gets handed along with the instantiation of a polymorphic function and not just when eventually a value of the polymorphic type arrives
06:14:03 <Saizan> yeah, i guess that's weird coming from IO
06:14:10 <Saizan> s/IO/OOP/
06:15:44 <Saizan> to mud the waters, you can pack a dictionary inside a value by using the ExistentialQuantification or GADTs extensions, which is what SomeException does
06:16:33 <Saizan> so when i pattern match on (SomeException e) there i also got an Exception type_of_e dictionary, which i used to call h on e
06:24:21 <ben> Thanks for the thorough explanation. :)
06:27:37 <Jafet> class Callable f a b | f -> a b where call :: f -> a -> b; instance Callable ((->) a b) a b where call = id
06:27:53 <Jafet> Is there any function f applied in any context that can't be replaced by call f?
06:31:59 <aristid> Jafet: polymorphic functions?
06:33:28 <Jafet> Seems to work for me
06:33:51 <Jafet> Maybe it only fails for the kind of polymorphism beyond my imagination, which is why I'm asking
06:34:24 <aristid> i guess rank-2 types might be a problem
06:38:41 <Jafet> You are correct
06:39:46 <Jafet> ...how could I rewrite Callable for it to work?
06:44:26 <w3rs> does anyone know type class for which provides component-wise ordering? Like this: (1,0) `compare` (0,1) = (GT,LT)
06:46:09 <Phyx-> >  (1,0) `compare` (0,1)
06:46:10 <lambdabot>   GT
06:46:40 <parcs> > fromZipList $ compare <$> ZipList [1,2,3] <*> ZipList [2,3,1]
06:46:40 <Phyx-> @src on
06:46:40 <lambdabot>   Not in scope: `fromZipList'
06:46:41 <lambdabot> (*) `on` f = \x y -> f x * f y
06:47:16 <parcs> or just zipWith compare, i guess…
06:47:22 <parcs> > zipWith compare [1,2,3] [2,3,1]
06:47:23 <lambdabot>   [LT,LT,GT]
06:48:11 <Feuerbach> parcs: the problem is that the components may have different types, I guess
06:48:16 <Jafet> I can relax the fundep, but at the cost of type inference
06:48:27 <Feuerbach> e.g. (1, "a") `compare` (2, "b")
06:48:31 <w3rs> parcs, thanks. But I would like staying with tuples or other N-ary vector types
06:50:08 <Feuerbach> w3rs: I don't think such type class exists, but it should be easy to define one
06:51:16 <w3rs> Feuerbach, probably you right. I just wanted to be sure I won't reinvent the wheel
06:51:46 <Feuerbach> w3rs: out of interest, what are you going to do next with that tuple of Orderings?
06:53:15 <w3rs> Feuerbach, it will help to check whether two N-ary cuboids intersect.
06:55:26 <w3rs> somthing like this: overlap cuboid1 cuboid2 = (v1 cuboid1 <= v1 cuboid2) && (v1 cuboid2 <= v1 cuboid1)
06:57:27 <pokoko222> hello mortals
06:57:56 <Tomsik> Hello portals
06:59:44 <pokoko222> wow last time i was here haskell was like 650 or something people
06:59:49 <pokoko222> now 760 woow
07:02:34 <opqdonut_> I think 10% might be within weekly variation, easily
07:02:46 <opqdonut_> somebody used to collect statistics, I wonder if it's still done
07:03:28 <opqdonut_> http://www.cse.unsw.edu.au/~dons/irc/ <- dons used to do it, seems he's not updating that anymore
07:03:49 <shachaf> Yes.
07:04:26 <shachaf> It's just generated from logs, though, so someone could run the script against updated logs.
07:04:46 <opqdonut_> sure
07:29:46 <ski> `Zerax` : try disabling DMR ?
07:29:48 <ski> Saizan : *nod*
07:30:28 <shachaf> ski: ?
07:31:00 * shachaf guesses ski hasn't scrolled down.
07:31:03 <ski> what ?
07:31:17 <ski> (i have)
07:31:28 <shachaf> Ah, or you were just replying to old messages.
07:31:38 <ski> aye
07:49:07 <tomh> anyone here knows of a as3 parser?
07:49:17 <tomh> in haskell
07:57:07 <Josh__> Hi ! I need some help
07:57:46 <Josh__> I've created gui using Glade. its loading fine but now I'm stuck. its about MenuItem signals
07:58:36 <Josh__> Like there is a main menu.. File/Edit etc. and in File menu there are options like New, Open, Save etc.. I want to attach callbacks to New/open/save
08:00:00 <Josh__> I've tried using onActivateItem which doesnt work as there are no submenus to New/Save etc. and while trying to add onActivate it says 'Expander' expected. Inferred type ImageMenuItem
08:00:12 <Josh__> what to do ? :-(
08:02:13 <Josh__> onActivateLeaf :-\ dunno how I missed it. Sorry
08:18:17 <flosit> is it possible to recover source code from a *.hi file?
08:18:32 <ddarius> A little, but no.
08:21:03 <flosit> damn
08:21:18 <flosit> wanted to delete hi file, but deleted hs...
08:21:43 <ddarius> You were of course using source control...
08:22:03 <flosit> little project, just started yesterday, so no...
08:22:23 <flosit> have a copy from yesterday, but todays work is lost..
08:22:43 <luite> it probably still exists on your disk, only unlinked
08:22:56 <flosit> is there a way to recover?
08:23:08 <dankna> next time, $ darcs init && darcs record -l --all --message "Initial."
08:23:23 <dankna> it takes all of one command to set up a VC repo
08:23:27 <luite> flosit: the standard recovery tools :)
08:23:49 <luite> dankna meant git init of course ;)
08:24:10 <flosit> luite: i am not very familiar with recovery tools. could you drop a name or two?
08:24:15 <dankna> I respect people who use git, in the same way as I respect people who are into BSDM
08:24:21 <jmcarthur> haha
08:24:45 <dankna> :D
08:24:55 <monochrom> BSDM = better safer development methods?
08:25:07 <dankna> if you want
08:25:18 <flosit> dankna: i will take my penance and use one of the both in future ;)
08:25:24 <dankna> flosit: good, good :)
08:26:24 <luite> flosit: hmm, don't know a free one
08:27:11 <dankna> it depends on your filesystem
08:27:14 <shachaf> Depends on your filesystem.
08:27:23 <dankna> if it's FAT32 or NTFS, I believe Norton makes a product
08:27:34 * shachaf wonders how well grep /dev/sdaN would work.
08:27:42 <dankna> if it's HFS+, there used to be a Norton product also but I don't think there is anymore
08:27:50 <ddarius> dankna: Why do you respect people who are into BSDM?
08:28:02 <dankna> ddarius: because it's a legitimate choice, even if I don't understand it
08:28:20 <dankna> ddarius: well, I understand it at an academic level, as much as I want to
08:28:25 <flosit> it's ext4
08:28:27 <luite> I have used GetDataBack for ntfs, but I think that the demo version only shows what it could restore
08:28:41 <ddarius> dankna: That's not a reason to respect someone.
08:28:48 <dankna> http://extundelete.sourceforge.net/
08:29:01 <dankna> ddarius: I would need a positive reason to disrespect them
08:29:39 <ddarius> dankna: I didn't say you should disrespect them.
08:29:53 <dankna> flosit: good luck with the recovery tools, but if they don't work, also remember that it isn't that hard to rewrite it and it might even come out better the second time.  it's still fresh in your mind after all.
08:30:06 <dankna> ddarius: it's a boolean.  there is no third option.
08:30:43 <flosit> thanks guys. a rewrite wont be a problem, it'll be just more practice with haskell (just started recently...)
08:30:48 <dankna> nodnod
08:31:08 <jmcarthur> dankna: i think ddarius is just saying that bsdm doesn't necessarily imply respect. he's being nitpicky with your wording
08:31:58 <dankna> jmcarthur: oh.  hmm.  okay.  thanks, I didn't understand that.
08:32:00 <ddarius> jmcarthur: It's not just a matter of wording.
08:32:07 <dankna> ddarius:  yeah, to be more precise, I don't judge people based on whether they're into BSDM or not.  my default is to be respectful unless I have some reason not to be.
08:32:58 <jmcarthur> ddarius: you mean there was legitimate confusion about what he meant to say?
08:46:01 <ultra> hey, looking for some opinions on the best way to learn haskell coming from a python/java/c background, is Learn You A Haskell a good starting place?
08:46:19 <shachaf> ultra: So people in here seem to say.
08:46:36 <ultra> alright, think I'll poke through the wiki and play with the tutorial a bit then give that a go
09:08:42 <arnihermann> Couldn't match expected type `exp' against inferred type `Exp', `exp' is a rigid type variable bound by the instance declaration at Fold.hs:158:94
09:09:13 <arnihermann> can anyone help with this error? I'm having a bit rough time understanding what it means
09:10:09 <monochrom> typo? change exp to Exp?
09:10:20 <parcs> exp is a type variable
09:10:26 <parcs> Exp is a type
09:10:36 <monochrom> or change Exp to exp?
09:11:10 <arnihermann> what does the "rigid type" part mean?
09:11:12 <monochrom> anyway it means "types don't match up"
09:11:15 <arnihermann> ok
09:11:15 <shachaf> Or @paste your code so people can see what's going on instead of making random guesses.
09:12:21 <parcs> arnihermann: a rigid type any type written by a programmer
09:13:22 <parcs> or rather, any type explicitly specified
09:13:29 <ski> "rigid type" is a type variable which is chosen by someone else (so it effectively acts like a new abstract `newtype'/`data' type, only being equal to itself)
09:13:59 * ski often call those "skolems"
09:14:39 <pozic> How well does par parallelism work for tasks that have some sequential dependencies, but not a lot?
09:14:44 <ski> if you have `foo :: forall a. ..a..', then if you call `foo', you can choose what `a' should be, so `a' is not rigid/skolem
09:15:09 <ski> otoh, if you're *implementing `foo', then the caller will choose some `a', and you can just bow and accept
09:15:22 <ski> (so a skolem / rigid variable)
09:15:42 <ski> arnihermann : ^ does that help ?
09:16:03 <pozic> Explaining Skolem variables in the context of programming languages is a mistake.
09:16:37 <pozic> There is not a chance in hell someone is going to get a clear understanding of them by listening to some guy in an IRC channel.
09:16:38 <arnihermann> ski, parcs: yes thank you very much
09:17:07 * ski is not explaining skolemization, just preferring that terminology ...
09:19:39 <beastaugh> pozic: perhaps a page on the Haskell wiki giving a brief outline of the model theory behind them?
09:26:49 <pozic> beastaugh: my opinion is that programming language implementors need not to know anything about skolemization.
09:27:05 <pozic> beastaugh: Haskell users neither need to know anything about that.
09:29:10 <beastaugh> pozic: well, you may be right, but that's not the prevailing Haskell culture as I've experienced it
09:29:35 <pozic> beastaugh: there is no such thing as prevailing Haskell culture.
09:30:11 <pozic> beastaugh: there are some people that have built big systems and there are people that just want to apply logic to Haskell and write blog posts.
09:32:12 <Saizan> there's the thing that in first rank polymorphism the two distinct concepts of type variables and meta variables get smashed together, so you find yourself needing an adjective to actually talk of type variables when the distinction starts to matter
09:37:50 <arnihermann> suggestion on how "do { vars' <- fold f vars; classes' <- fold f classes; mainbody' <- fold f mainbody; f vars' classes' mainbody' }" can be written without resulting to do notation
09:37:57 <arnihermann> ?
09:38:37 <arnihermann> btw, I fixed the error I had, thanks for explaining "rigid type"
09:38:49 <mauke> @undo do { vars' <- fold f vars; classes' <- fold f classes; mainbody' <- fold f mainbody; f vars' classes' mainbody' }
09:38:49 <lambdabot> fold f vars >>= \ vars' -> fold f classes >>= \ classes' -> fold f mainbody >>= \ mainbody' -> f vars' classes' mainbody'
09:39:00 <mauke> @. pl undo do { vars' <- fold f vars; classes' <- fold f classes; mainbody' <- fold f mainbody; f vars' classes' mainbody' }
09:39:00 <lambdabot> (fold f classes >>=) . ((fold f mainbody >>=) .) . f =<< fold f vars
09:39:44 <Saizan> liftM3 f (fold f vars) (fold f classes) (fold f mainbody)
09:42:20 <arnihermann> Saizan: dunno why but when I do liftM3 I get Occurs check: cannot construct the infinite type: mod = m mod
09:43:11 <mauke> join $ liftM3 f ...
09:43:30 <eekTheCat> is the "do" syntactic sugar implemented directly by haskell code? or is that some kind of behind the scenes compiler magic?
09:43:49 <aristid> eekTheCat: compiler magic.
09:44:00 <shachaf> It's... Not really magic. It's very simple and well-defined.
09:44:12 <shachaf> But, yes, it's part of the language.
09:44:32 <arnihermann> mauke: aaah thanks
09:44:33 <arnihermann> much better
09:44:44 <KirinDave> shachaf: It's "magic" if a programmer could not reproduce an equivalent piece of syntax without cracking open the compiler (extensions, I guess, are an exception)
09:44:47 <arnihermann> possible to simplify using applicatives?
09:45:10 <shachaf> KirinDave: "some kind of behind the scnees compiler magic" implies a bit more than that.
09:45:35 <mauke> well, liftM3 is f <$> fold f vars <*> fold f classes <*> fold f mainbody
09:45:42 * hackagebot data-accessor 0.2.2 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.2 (HenningThielemann)
09:45:45 <arnihermann> yes
09:45:49 <arnihermann> what about the join?
09:45:51 <eekTheCat> shachaf, I don't know what my words conveyed, but I meant more along the way Kirin and aristid are thinking of it
09:46:03 <mauke> if Applicative had join, it would be Monad
09:46:20 <arnihermann> ah
09:46:22 <Ubuntufreak> i have problem with installing Haskell-platform in my Kubuntu 11.04 http://hpaste.org/46682/haskellplatform any help ?
09:46:42 * hackagebot enumset 0.0.3 - Sets of enumeration values represented by machine words  http://hackage.haskell.org/package/enumset-0.0.3 (HenningThielemann)
09:46:45 <aristid> if Applicative didn't have pure, it would be... Semigroup? *not sure*
09:47:03 <mauke> m >>= f = join (f <$> m)
09:48:42 * hackagebot cpuid 0.2.2 - Binding for the cpuid machine instruction on x86 compatible processors  http://hackage.haskell.org/package/cpuid-0.2.2 (HenningThielemann)
09:49:42 * hackagebot poll 0.0 - Bindings to poll.h  http://hackage.haskell.org/package/poll-0.0 (HenningThielemann)
09:50:47 <Eduard_Munteanu> Well, can't TH emulate 'do syntax' at least a bit? I don't have experience with it, but if it bears some semblance to Agda's syntax declarations...
09:52:18 <dankna> sort of
09:52:36 * KirinDave hrms
09:52:44 <dankna> you can do something along the lines of a list of syntactic items delimited by commas
09:57:16 <joe6> >  TestList .  map (\f x y -> f (undefined) (undefined) x y)
09:57:17 <lambdabot>   Not in scope: data constructor `TestList'
09:58:54 <joe6> what is wrong with the above code? :t TestList :: [Test] -> Test and the error is:  http://sprunge.us/XaIf
10:00:28 <Saizan> the error message is quite explicit about it
10:01:03 <Saizan> maybe you meant "TestList .  map (\(f,x,y) -> f (undefined) (undefined) x y)" ?
10:01:12 <joe6> Saizan, i do not understand this: but its type `a0 -> Test' has only one
10:01:35 <joe6> this is the actual code i am using it in:  http://sprunge.us/JQTa
10:01:45 <joe6> I could convert it to a tuple, if that helps
10:01:50 <Saizan> the type of the argument to map has to be "a0 -> Test" for some unknown a0
10:02:06 <Saizan> so it can only take one argument
10:02:13 <Saizan> not 3.
10:02:14 <joe6> oh, ok.
10:02:18 <joe6> thanks
10:04:19 <Eduard_Munteanu> If you want more args you have to partially-apply it.
10:04:32 <KirinDave> :\
10:04:35 <Eduard_Munteanu> like   map (f a b) xs
10:04:43 <KirinDave> I run this program with -XOverloadedStrings, and it works
10:05:00 <KirinDave> But it doesn't work if I just put {-# LANGUAGE OverloadedStrings #-} in the file.
10:05:48 <Eduard_Munteanu> Is it among the first lines, even before 'module ... where'?
10:05:59 <KirinDave> Ahh, it is not.
10:06:03 <KirinDave> Foolish me, hadn't scrolled up
10:07:51 <Eduard_Munteanu> Hm, regarding this, I wonder why extensions/options are declared in comments.
10:08:01 <Eduard_Munteanu> Clearly you want the compiler to bail out if it doesn't understand it.
10:09:11 <dankna> yeah - I wouldn't mind a "language" keyword
10:09:12 <Eduard_Munteanu> Even moreso if particular options involve subtle semantic changes (say detectable at runtime).
10:09:23 <dankna> but this way it doesn't waste a reserved word
10:09:53 <shachaf> It probably made sense in the days when people just added -fglasgow-exts to everything.
10:10:04 <mauke> "use strict";
10:10:57 <Eduard_Munteanu> mauke: is that some Perl / Python thingy?
10:11:03 <mauke> javascript
10:11:08 <mauke> 'use' is a keyword in perl
10:11:08 <dankna> the Haskell LANGUAGE flags do deeper things to the language than "use strict" does to Perl, and I think it makes sense to put it before even the module declaration
10:11:50 <mauke> dankna: http://search.cpan.org/~dconway/Lingua-Romana-Perligata-0.50/lib/Lingua/Romana/Perligata.pm#SUMMARIUM
10:12:05 <dankna> hmm
10:12:06 <dankna> cute
10:12:11 <Eduard_Munteanu> Well supposedly you could scope a 'language' keyword just like now, limiting it to the first lines. That'll most likely trigger errors in most cases of interest.
10:12:42 <dankna> well, I mean, I wouldn't make it a keyword in the proper sense - since it /is/ only used in that context
10:12:57 <Eduard_Munteanu> Yeah.
10:13:30 <dankna> but you're right that it's not like a pragma in that you definitely want to abort if you don't recognize it
10:16:03 <Eduard_Munteanu> I suppose you could also annotate it in case it's no biggie the compiler doesn't get it.
10:16:21 <mauke> oh god, I'm having rtf flashbacks
10:18:01 <Eduard_Munteanu> Hah, that Perl latin thingy looks like magic scrolls
10:18:08 <Eduard_Munteanu> Incantations.
10:18:26 <dankna> indeed
10:25:07 <ddarius> Eduard_Munteanu: Pragmas are covered by the Report.  There's no problem having the Report say that certain pragmas should throw an error if not understood.
10:27:37 * ddarius really needs to get a novel.
10:28:34 <Eduard_Munteanu> @where report
10:28:34 <lambdabot> http://www.haskell.org/onlinereport/
10:29:11 <Eduard_Munteanu> Ah, so this goes back to H98, I was concerned older compilers might just ignore them.
10:30:38 <Eduard_Munteanu> I've got a novel by Awodey, I should finish that :P
10:31:52 * Eduard_Munteanu hasn't picked up a literature book for quite some time :/
10:34:30 <erus`> does haskell have any librarys to do boolean operations (union, difference, intersection) on 3d meshes?
10:38:32 <jmcarthur> erus`: what does that even mean for 3d meshes? do you mean constructive solids?
10:38:42 <jmcarthur> i don't know of anything, in any case
10:39:29 <erus`> a 3d mesh is a set of points joined together with sides to make the faces on the mesh
10:39:56 <jmcarthur> yes i understand that
10:40:22 <Eduard_Munteanu> Quite a few modellers/raytracers allow you to do that sort of thing on objects.
10:40:24 <jmcarthur> the union of sets of points is just more sets of points
10:40:40 <jmcarthur> s/more/bigger/
10:40:46 <danharaj> 'bigger'
10:40:46 <danharaj> :p
10:41:05 <erus`> if a ray intersects through a face with a normal facing towards the ray then its going inside the shape
10:41:39 <jmcarthur> erus`: i just mean that this isn't really union, difference, and intersection of 3d meshes. this is interpreting them as constructive solids instead
10:42:00 <erus`> oh ok
10:42:18 <erus`> i might try marching cubes instead
10:42:27 <erus`> probably much easier
10:54:18 <danharaj> I have a problem.
10:54:19 <danharaj> http://hpaste.org/46685/problemdesc
10:56:16 <stepcut> danharaj: yes.. sounds like you have quite a problem there
10:56:43 <danharaj> I'm betting on NP completeness but I'm thinking of which problem to do the reduction on.
11:03:57 <Eelis> wild speculation time: how much faster would our programs run if we could convince intel/amd to add a few specialized machine instructions specifically suited for executing Haskell programs?
11:05:06 <`Zerax`> I believe they tried the same for lisp back in the day, didn't really take off.
11:05:20 <aristid> Eelis: what would those instructions be?
11:05:21 <`Zerax`> What kind of instructions did you have in mind?
11:06:09 <Eelis> i don't know. but there must be some things that are done over and over again when executing Haskell programs. like fetching and switching [4~on constructor ids
11:06:35 <Eelis> or creating thunks
11:07:19 <amsl> Hi, I'm pretty new to Haskell and I just got an error I don't know how to decypher. This is my code: http://hpaste.org/46686/occurs_check_cannot_construct
11:07:38 <mauke> amsl: what error?
11:07:59 <amsl> Occurs check: cannot constuct the infinate type a = [a]
11:08:09 <mauke> amsl: what's the complete error?
11:08:33 <amsl> One second, I'll add it to the paste.
11:08:43 <mauke> found it, line 13
11:09:15 <amsl> 13? Really? I thought it was 4 & 6.
11:09:40 <mauke> put type signatures in to get better diagnostics
11:09:55 <danharaj> in isPrime on line 13 you are trying to mod a number with a list of numbers.
11:10:22 <amsl> I have to admit type signatures aren't my strength. But thanks a bunch! You guys probably saved me hours of reading and testing :)
11:10:42 <danharaj> When you are learning Haskell it's best to write every top level type signature.
11:10:50 <danharaj> It gets you used to the type system.
11:10:51 <amsl> That is a list isn't it...
11:10:52 <amsl> lol
11:10:56 <mauke> types aren't rocket surgery
11:11:14 <amsl> danharaj: Thanks for the tip, I'll do that.
11:11:14 <danharaj> No, they're zygohistomorphic rocket surgery bifunctors.
11:11:51 <aristid> too bad @quote doesn't really support multiline quotes
11:11:59 <scree> s/When you are learning Haskell i/I/
11:12:32 <amsl> Do you have any suggested readings for understanding type classes?
11:13:10 <aristid> @where lyah
11:13:10 <lambdabot> http://www.learnyouahaskell.com/
11:13:15 <mauke> not really, but I can talk about them
11:13:32 <amsl> lambdabot: My favorite resource thus far :)
11:13:46 <cheater79> amsl, make sure to buy the book
11:14:00 <danharaj> type classes are basically dictionaries of values. An instance of a type class tells you what the dictionary is for a type.
11:14:16 <danharaj> Putting type class constraints in your type signatures is requiring that the dictionary exists for you to use in your function.
11:14:28 <mauke> danharaj: that's a very implementation oriented point of view
11:14:42 <danharaj> mauke: It's an operational point of view. This is how we use type classes.
11:14:44 <mauke> (which incidentally I don't like very much)
11:15:26 <dolio> Not all implementations pass dictionaries.
11:16:07 <danharaj> But we use it as a dictionary.
11:16:40 * ddarius doesn't even know what "using it as a dictionary" means.
11:16:48 <mauke> this is not how I brain
11:18:26 <Enigmagic> ddarius: similar to this http://en.wikipedia.org/wiki/Virtual_method_table
11:18:49 <ddarius> Enigmagic: Actually, it is rather dissimilar to a vtable.
11:18:53 <danharaj> if I have a function, f :: Eq a => a -> a -> Foo Bar Baz a, and somewhere in f x y  I have the expression, x == y, then I am relying on the fact that the meaning of the function is determined by how x == y is translated for that particular type.
11:20:16 <mauke> ddarius: what's the difference?
11:20:27 <ddarius> mauke: vtables are attached to values.
11:20:34 <mauke> no, they aren't
11:20:44 <mauke> vtables are basically static
11:20:56 <mauke> and there's one per class
11:21:13 <ddarius> mauke: Okay, pointers to vtables are attached to values.
11:21:41 <mauke> ok, that wasn't part of my personal definition of "vtable"
11:21:59 <mauke> could I say typeclass dictionaries are like unattached vtables?
11:22:11 <ddarius> It's not absolutely required, but it is usually what is intended when someone mentions vtables.
11:22:15 <ddarius> mauke: Yes.
11:23:22 <dolio> danharaj: But that doesn't have to be implemented by passing dictionaries. So in what sense are we using them like dictionaries?
11:23:24 <ddarius> However, the "attachment" of (pointers to) vtables leads to rather different semantics than having them detached.
11:23:48 <ddarius> (Though, admittedly, you could, in some cases, "optimize" one to the other.)
11:27:08 <danharaj> dolio: A polymorphic function with type class constraints, and actually uses them, when we call it, has a meaning that depends on how to translate the type class values into the instance values. The dictionary might not have an actual existence in the code, but it's still 'there' for our purposes.
11:27:44 <ddarius> What are "type class values"?
11:28:06 <dolio> JHC implements type classes by passing around type representations.
11:28:21 <dolio> Unless you consider functions defined by case analysis "dictionaries".
11:28:35 <ddarius> You could also almost implement type classes by rampant specialization.
11:29:04 <ddarius> (There are a few cases where that wouldn't work, namely polymorphic recursion and existential types.)
11:29:05 <dolio> I doubt that'd be sufficient for all possible uses.
11:29:10 <dolio> Yeah.
11:30:31 <danharaj> ddarius: like (==) in Eq.
11:39:06 <nominolo> anyone here from Madrid?
11:43:05 <Eduard_Munteanu> Eelis' idea sounds like Lisp Machines, but would there be any advantage today? CPUs are getting RISCier, with the notable exception of vector stuff.
11:43:25 <Eelis> Eduard_Munteanu: yeah, hence my question :)
11:44:11 <Eelis> another exception is GPUs, which still have lots of dedicated specialized stuff
11:44:11 <beastaugh> I take it you've looked at http://www.cs.york.ac.uk/fp/reduceron/?
11:44:23 <Eduard_Munteanu> I don't see any particular advantage to dedicating hardware to list handling and such.
11:44:24 <Eelis> nope, not yet. thanks!
11:44:30 * hackagebot llvm 0.9.1.0 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-0.9.1.0 (HenningThielemann)
11:44:36 <Eelis> Eduard_Munteanu: that's not really what i was thinking of
11:45:24 <Eduard_Munteanu> Eelis: yes, but GPUs have been moving towards letting the programmer deal with the details, e.g. doing lighting in shaders
11:45:31 <Eduard_Munteanu> So I think there's a RISC trend there too.
11:46:08 <ddarius> Being RISCier often makes a lot of sense.
11:46:22 <Eelis> Eduard_Munteanu: a trend, yes, but i don't think anyone is expecting that the primitive things like hardware-accelerated sqrt are going away
11:46:45 <gio123> Eduard_Munteanu: what is RISC?
11:46:46 <Eduard_Munteanu> Yeah, there's a huge incentive in making the hardware more flexible since it's often easier to achieve optimization in software.
11:47:51 <Eduard_Munteanu> gio123: http://en.wikipedia.org/wiki/RISC    basically reducing the instruction set to a set of primitives instead of providing macro instructions for programmer convenience
11:48:13 <blbrown_win3> is there #haskell beginners?
11:48:27 <danharaj> blbrown_win3: no. You can ask questions in here.
11:48:44 <Eduard_Munteanu> blbrown_win3: this *is* #haskell for beginners too :)
11:49:05 <blbrown_win3> yea right, hehe
11:49:11 <aristid> i think there is #haskell-beginners or so. but #haskell is probably better
11:49:25 <ion> We’re all beginners.
11:49:29 <Eduard_Munteanu> There have been attempts at eliminating the instruction set altogether, though that's suffering in the code density department.
11:49:39 <psychouroboros> is there an online errata for "Learn you a Haskell for Great Good"?
11:49:43 <Eduard_Munteanu> aristid: heh, I didn't even know about that
11:49:57 <adamvh> Messing around with stream fusion, and I've been wondering - how does one retrieve the final state from unfoldrN?
11:50:05 <blbrown_win3> ion, I have been doing it for years off and on but I missed last year with haskell development.  I am trying to get back into the swing of things
11:50:24 <ion> eduard_munteanu: Eliminating the instruction set, huh? How does one program for such processors?
11:50:42 <adamvh> Or rather, how does one both unstream a stream, and save the final state for later?
11:51:10 <Eduard_Munteanu> ion: see NISC. Basically your machine code touches control lines directly.
11:51:24 <ion> Thanks, will google.
11:51:43 <Eduard_Munteanu> so a bit encodes incrementing the program counter, then next one something else, then some address bits etc.
11:52:02 <Eduard_Munteanu> It's quite interesting since the compiler does all the hard work.
11:52:07 <ion> aye
11:53:59 <Eduard_Munteanu> Eelis: so I guess there's a balance, you must find a way to express a macro-operation in terms of smaller stuff (which gives you flexibility) without exploding the code size (since memory bandwidth is still a huge concern)
11:54:57 <Eelis> right
11:59:34 <jmcarthur> adamvh: why do you want to save the final state?
11:59:51 <jmcarthur> adamvh: you can't even know its type, so i just don't know what you could do with it
12:00:24 <adamvh> jmcarthur: If you call unfoldrN, you specificy the state type
12:00:30 <adamvh> and the stepper function
12:00:39 <adamvh> As to my use case,
12:00:46 <adamvh> I need to construct a vector from a seed
12:01:01 <adamvh> save the final seed
12:01:06 <jmcarthur> okay now i just wonder what unfoldrN is
12:01:35 <aristid> :t unfoldr
12:01:36 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:01:53 <aristid> @hoogle unfoldrN
12:01:54 <lambdabot> Data.ByteString unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
12:01:54 <lambdabot> Data.ByteString.Char8 unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
12:01:55 <adamvh> jmcarthur: given a seed and a stepper function, generate a stream
12:02:04 <adamvh> (or vector)
12:02:19 <aristid> adamvh: and the N is because you already know the length of the result?
12:02:27 <adamvh> aristid: yes
12:02:30 <jmcarthur> adamvh: Data.Vector.Fusion.Stream.Monad.unfoldrN?
12:02:45 <adamvh> jmcarthur: That's the one I've been looking at
12:03:06 <adamvh> It's almost perfect for my application, except I need the final state for subsequent calculations
12:03:08 <aristid> :t \n f s -> take n $ unfoldr f s
12:03:09 <lambdabot> forall a b. Int -> (b -> Maybe (a, b)) -> b -> [a]
12:03:54 <adamvh> (Boundary value problem, if the application domain is of interest)
12:04:14 <Eduard_Munteanu> @hoogle Int -> (b -> Maybe (a, b)) -> b -> (b, [a])
12:04:14 <lambdabot> No results found
12:04:18 <jmcarthur> why not just include the state in the vector, then unzip it and get the last element of the state vector?
12:04:19 <Eduard_Munteanu> @hoogle Int -> (b -> Maybe (a, b)) -> b -> ([a], b)
12:04:20 <lambdabot> No results found
12:04:42 <jmcarthur> and keep the other vector as the result, of course
12:04:53 <jmcarthur> well i can think of one reason not to do that, i guess
12:04:59 <adamvh> jmcarthur: Space
12:05:01 <jmcarthur> you'd lose sharing
12:05:02 <Eduard_Munteanu> IIRC there were recursion schemes giving you access to intermediates, but this is just an anamorphism as far as I can tell. You might want to look into that sort of terminology.
12:05:11 <jmcarthur> no, space isn't the reason
12:05:12 <adamvh> jmcarthur: the state is itself a vector
12:05:23 <adamvh> jmcarthur: of which I'd like to avoid storing N
12:05:23 <jmcarthur> it wouldn't keep the intermediate stuff in memory at all
12:05:29 <jmcarthur> yeah it wouldn't do that
12:05:35 <adamvh> hmmm
12:05:37 <jmcarthur> but it would perform the unfolding twice
12:05:51 <jmcarthur> unless you shared that intermediate vector, in which case it *would* take up all that space
12:06:00 <jmcarthur> so that's a non-solution
12:06:21 <adamvh> Basically, my dream type signature is
12:06:28 <jmcarthur> anyway, that state is not intended to be reused. that's just the design of it
12:06:48 <adamvh> (b -> Maybe (a,b)) -> b -> ([a],b)
12:06:56 <jmcarthur> that would break fusion
12:07:15 <Eduard_Munteanu> @hoogle (b -> Maybe (a,b)) -> b -> ([a],b)
12:07:15 <lambdabot> No results found
12:07:19 <Eduard_Munteanu> Nope :)
12:07:20 <adamvh> jmcarthur: What's the showstopper there?
12:07:31 <jmcarthur> or at least, the result vector would have to be a real vector in memory rather than a stream
12:07:44 <adamvh> (How does reusing the state break fusion)?
12:07:53 <jmcarthur> because it means you have to force the whole thing
12:08:15 <Eduard_Munteanu> It's just keeping around another accumulator I guess.
12:08:29 <Eduard_Munteanu> Since you only care about the final state, not all states.
12:08:35 <adamvh> jmcarthur: Oh yeah, I get it - you have to actually write out the stream to memory when you need the state
12:09:02 <adamvh> So you can't do fusion on a stream that you've already force to get the end state
12:09:02 <jmcarthur> it's either going to break fusion or break sharing, depending on how you crack it
12:10:06 <adamvh> I was hoping I could get stream fusion to keep around one mutable vector of length N
12:10:23 <adamvh> But I guess that's a different optimization entirely
12:10:46 <jmcarthur> well, vector does use mutable vectors as part of its really fancy stream fusion, but that's not core to how stream fusion works
12:13:05 <jmcarthur> in fact, i'm pretty sure that the mutable vectors are only used in places where stream fusion would be broken anyway (e.g. accum has to preallocate the entire result vector. it can read from a stream, but it can't write to one)
12:13:15 <tg_> in interst of being as precise as possible, with the line:
12:13:22 <tg_> data Maybe a = Nothing | Just a
12:14:07 <tg_> "Maybe" is a "type constructor". "a" is a "type paramter". "Nothing" is a "value constructor". "Just" is a value constructor. Correct?
12:14:29 <jmcarthur> sounds about right to me
12:14:32 <Eduard_Munteanu> Yep.
12:14:37 <tg_> ok, second question
12:14:42 <tg_> If I put this in a file:
12:14:58 <tg_> data Moobey a = Narthing | Justar a
12:15:11 <tg_> is that statement exactly identical to the above one?
12:15:14 <adamvh> jmcarthur: The code I'd like to write looks like http://hpaste.org/46688/code_im_looking_to_write
12:15:20 <tg_> or are Nothing and Just and Maybe special and hardcoded?
12:15:33 <jmcarthur> tg_: aside from types, that should be the same i'm pretty sure
12:15:34 <Eduard_Munteanu> tg_: no they aren't, but you've got additional instances for Maybe
12:15:50 <Eduard_Munteanu> like you have to do additional work to get Moobey to be a monad
12:15:53 <jmcarthur> right, as Eduard_Munteanu says, of course they aren't going to have the same infrastructure around them
12:15:59 <tg_> Eduard_Munteanu: so because their signatures are identical, then I've created a renamed version of those things
12:16:01 <jmcarthur> but they *mean* the same thing
12:16:11 <tg_> with no structure
12:16:12 <tg_> ok
12:16:18 <Eduard_Munteanu> Yeah, you could say they're isomorphic.
12:16:24 <tg_> Eduard_Munteanu: ok, that's better
12:16:31 <jmcarthur> and they should have the same performance characteristics
12:16:42 <jmcarthur> at least in ghc, i'm pretty sure
12:16:43 <tg_> isomorphic in terms of type intferrence, not in terms of people writing them in code :o
12:16:43 <Eduard_Munteanu> (trivially so, since they differ just by name)
12:17:05 <tg_> Lastly, is there anything else one could even do in this scenario?
12:17:06 <adamvh> Where the result vector is allocated and written to in the first binding, and then the compiler recognizes that it just has to do a mutable add on the already-allocated vector to get the result
12:17:08 <tg_> If you have "Maybe a"
12:17:09 <jmcarthur> in ghc, i think none of the boxed types are actually primitive
12:17:10 <develhevel> how to deinstall a package with cabal?
12:17:16 <dmwit> impossible
12:17:22 <dmwit> Use ghc-pkg unregister and rm instead.
12:17:28 <ddarius> jmcarthur: Arrays.
12:17:28 <tg_> then you can have a zero-paramter value constructor (Nothing) and a one paramter (Just), but nothing else can be specified at all, correct?
12:17:48 <jmcarthur> ddarius: aren't they implemented by wrapping unboxed ByteArrays?
12:18:02 <jmcarthur> oh
12:18:05 <jmcarthur> boxed arrays you mean?
12:18:10 <tg_> that is, there's between Maybe a and any other {0,1}-value constructor
12:18:24 <tg_> s/there's between/there's nothing between/
12:18:42 <jmcarthur> tg_: you are asking about the number of values of something of type Maybe a?
12:18:43 <Eduard_Munteanu> tg_: not really, you could have different stuff that's not quite isomorphic to Maybe.
12:18:55 <tg_> jmcarthur: something like that
12:19:00 <tg_> I'm saying, the only other thing I could do
12:19:07 <Eduard_Munteanu> like    Moobey a = Nothing1 | Nothing2 | Joost a
12:19:09 <ddarius> tg_: Just to be clear, Haskell's type system is nominal not structural.
12:19:09 <tg_> with a type constructor "Mooby" and a singel value a
12:19:17 <jmcarthur> tg_: possible values are   _|_, Nothing, Just _|_, and Just <any value of a>
12:19:28 <jmcarthur> well, i guess _|_ is a value of a, so one of those is redundant
12:19:29 <tg_> jmcarthur: and re-orderings of those?
12:19:40 <tg_> because Maybe a = Nothing | Just a
12:19:42 <tg_> is not the same as
12:19:46 <tg_> Maybe a = Just a | Nothing, right?
12:19:50 <jmcarthur> umm
12:19:50 <Eduard_Munteanu> Consider 'List a', 'Tree a' etc.
12:19:59 <jmcarthur> in haskell, they are the same. i don't know about in ghc's implementation
12:19:59 <tg_> (granted, that isn't useful either)
12:20:08 <ddarius> tg_: It is other than the fact that deriving clauses can tell the difference.
12:20:12 <tg_> I thought the first element was the minimum, and the last was the maximum
12:20:24 <ion> That’s only if you add deriving (…)
12:20:25 <Eduard_Munteanu> So something like parametricity doesn't really limit your data there.
12:20:30 <jmcarthur> yeah, derived classes are another matter
12:20:43 <jmcarthur> they are *magic*
12:21:05 <tg_> jmcarthur: in the good sense?
12:21:21 <jmcarthur> in the sense that they do things that haskell functions can't
12:21:33 <jmcarthur> (detect the defined order of constructors)
12:22:17 <jmcarthur> tg_: consider deriving clauses to just be preprocessort cruft
12:22:18 <tg_> ddarius: can you give me two sentences on your "nominal not strucural"?
12:22:18 <ddarius> Basically, the "derivers" are given the AST of the data declaration to work with, not the semantic notion the AST represents.
12:22:40 <jmcarthur> *preprocessor
12:25:16 <kamatsu> can anyone here explain to me how the Cook-Levin theorem (that SAT is NPC) is a log-space reduction?
12:25:17 <tg_> ddarius: nominal means for naming purposes only?
12:25:45 <tg_> oh, found http://en.wikipedia.org/wiki/Nominative_type_system
12:25:50 <tg_> which was't linked to "nominal"
12:30:22 <JoeyA> kamatsu: I don't know much about it, but how can a theorem be a reduction?  Where is the log-space reduction being used?
12:30:35 * hackagebot LibClang 0.1.0 - Haskell bindings for libclang (a C++ parsing library)  http://hackage.haskell.org/package/LibClang-0.1.0 (ChetanTaralekar)
12:36:20 <Saizan> tg_: nominal basically means that types are compared by name, not by their structure
12:36:23 <KirinDave> Hmm. Enumerators+Iteratees seem cool. Are they viable in a language without lazy eval/tco?
12:37:30 <Tomsik> Consider that programming folds without lazy evaluation is uncool
12:38:19 <KirinDave> Tomsik: Only if you can't tco or implement the fold such that it doesn't grow the stack.
12:39:08 <Tomsik> KirinDave: implement "if" in ocaml without resorting to "() -> a" types
12:39:17 <Tomsik> and the "lazy" stuff
12:39:49 <KirinDave> Tomsik: I'm thinking more like if it'd be nice for spackling over model problems on an even uglier language. :)
12:39:57 <KirinDave> Tomsik: Namely javascript/node.js
12:40:51 <Saizan> i don't think iteratees rely on laziness, they are all about being explicit about control flow with continuations
12:40:54 <KirinDave> Tomsik: I had occasion to maintain some node.js code the other day.
12:41:01 <Tomsik> I think it's important that you don't eval next element of a stream when you don't need it, in case of iteratees&co
12:41:18 <KirinDave> And their I/O model is...
12:41:21 <KirinDave> Oh man it's arduous.
12:41:41 <Tomsik> a return statement or two should fix it in most languages, but I'm not familiar with javascript to be honest
12:42:28 <Saizan> enumerators is in full control of how much of the stream gets fetched from I/O at any given time, for example
12:42:36 <Saizan> s/is/are/
12:42:50 <KirinDave> Yeah
12:42:51 <Saizan> (or any other source)
12:43:15 <KirinDave> Node's model is already basically explicit cps.
12:43:24 <ddarius> foldl is a pretty common function in eager languages.
12:43:47 <kamatsu> JoeyA: You represent the theorem on a turing machine tape. The exact representation is irrelevant
12:44:12 <KirinDave> Yeah, foldl is actually the only one you can implement cheaply.
12:44:30 <KirinDave> It was weird being told foldr was more common in haskell for primitive recurses.
12:45:12 <ddarius> Actually, in Oz, the "naive" definition of foldr would use constant stack space.
12:45:51 <Tomsik> Well, foldl is less intuitive IMO
12:46:07 <Tomsik> Anyway, it's all about depth of nesting in Haskell, not TCO :p
12:46:12 * ddarius doesn't find either less intuitive.  They are just different.
12:53:35 <b0fh_ua> Hi there! Given a list of pairs [(Int, Int) of size 4, how can I find if these items (points) are corners of a square on plane?
12:54:42 <Botje> check if the diagonals are the same length and that they're perpendicular
12:55:17 <Tomsik> Forall a . exists! b. a.x = b.x || a.y == b.y
12:55:23 <Tomsik> :o
12:55:25 <Tomsik> :p
12:56:51 <DasIch_> having read lyah where should I go from there?
12:57:16 <Saizan> ddarius: but the predicate you're folding over will just get an uninstantiated variable as second argument?
12:57:48 <Tomsik> DasIch_: I sat on IRC and reddid/r/haskell, listened and formulated my own questions.
12:57:53 <Tomsik> That's one way.
12:57:59 <b0fh_ua> Botje: but I don't know how to find length of diagonals except trying every pair of points
12:58:35 <Botje> b0fh_ua: the points aren't in order?
12:58:40 <DasIch_> Tomsik: so I suppose I should just start coding then
12:59:06 <b0fh_ua> Botje: yup
12:59:15 <Botje> b0fh_ua: they aren't?
12:59:22 <ddarius> Saizan: I was a little too general in my statement.  A foldr in Oz would have similar failure modes to foldr in Haskell.
12:59:25 <Botje> then do that first :)
13:00:07 <b0fh_ua> Botje: the points are in random order
13:00:29 <b0fh_ua> Botje: so I don't know for now how to find endpoints of diagonals
13:00:34 <Botje> b0fh_ua: take the center of the four points, draw a line to one of them, then grab the other points by walking around clockwise
13:00:56 <luite> b0fh_ua: you can sort the list
13:02:09 <b0fh_ua> Botje: for taking center it should be enough to sum all X coordinates and then divide them by 4, and the same for y
13:02:21 <Botje> b0fh_ua: heh. actually
13:02:29 <Botje> you don't even need to do that
13:02:51 <b0fh_ua> Botje: really?
13:02:52 <Botje> take the center, grab a point, and see if there is a point on the opposite side
13:02:53 <luite> b0fh_ua: then you will get [p0,p1,p2,p3], you need to check |p1-p0|=|p2-p0|=|p3-p2|=|p3-p1| and that (p1-p0).(p2-p0)=0
13:02:56 <luite> (dot product)
13:03:13 <Botje> then do the same check for the other two points
13:03:18 <Botje> that gives you length of diagonals
13:03:26 <Botje> then simply check the angle between those two lines
13:04:09 <b0fh_ua> Botje: don't get it :(
13:04:41 <luite> this works because sorting sorts on the first coordinate first, then the second
13:04:43 <b0fh_ua> not sure how can I get the center of the square
13:05:19 <b0fh_ua> luite: hmm
13:05:38 <luite> b0fh_ua: |x| is vector length
13:06:33 <b0fh_ua> luite: sqrt ( (x1-x2)^2 + (y1-y2)^2))
13:06:35 <b0fh_ua> like that
13:06:51 <luite> yes but you don't need the sqrt because you only want to check whether they are equal
13:06:58 <Botje> b0fh_ua: center of the square is indeed sum of the coordinates divided by four
13:07:54 <b0fh_ua> Botje: and that mean the distance from the center to every point should be equal
13:07:55 <luite> so you sort the points, so that p0,p3 are on opposite ends of a diagonal (at least if it's a square), and then you check whether the 4 edges have the same length, and you check one corner
13:08:25 <Botje> b0fh_ua: yes. additionally, there should be a point on the 'mirrored' position
13:08:39 <b0fh_ua> Botje: yeah, excellent
13:08:43 <b0fh_ua> Botje: thanks )
13:10:54 <b0fh_ua> Botje: I think that it is not neccessary to find out is there any point on the opposite side
13:11:12 <b0fh_ua> I think it's enough to calculate distances
13:11:53 <luite> bah I like my approach better since all its intermediate vectors have integral components if you start with integral points :p
13:12:09 <Botje> b0fh_ua: you still have to check the angles.
13:12:23 <Botje> if you only check the distances you can end up with four points at weird angles
13:15:03 <b0fh_ua> Botje: but we will have center
13:15:27 <b0fh_ua> which obviously will be in between of point with max(x) and min(x)
13:22:37 <qacek> b0fh_ua: just measure the distance between all combinations of points, you will have 6 values 4 of which must be the same for the sides and the other 2 must be the same for the diagonals
13:22:44 <qacek> no sorting required
13:28:08 <b0fh_ua> btw how can I determine if the list contains only same values?
13:29:37 <b0fh_ua> length . nub list == 1
13:30:08 <Tomsik> but that's n^2
13:30:33 <ion> Perhaps you shouldn’t use a list as the container.
13:30:50 <Tomsik> :t f iseq xs = all (\x -> x == a) xs where a = head xs
13:30:50 <lambdabot> parse error on input `='
13:30:52 <monochrom> same (x:xs) = all (x ==) xs
13:31:09 <vitka> > let same (a:as) = all (==a) as in same [1,1,1,1]
13:31:09 <lambdabot>   True
13:31:17 <vitka> Beat me.
13:31:35 <ion> Whoops, i misread the question.
13:33:37 <parcs> > let same xs = case nub xs of { (_:_:_) -> False; _ -> True } in same [1,1,1,1]
13:33:38 <lambdabot>   True
13:34:03 <parcs> > let same xs = case nub xs of { (_:_:_) -> False; _ -> True } in same 1:repeat 5
13:34:04 <lambdabot>   No instance for (GHC.Num.Num [a])
13:34:04 <lambdabot>    arising from the literal `1' at <inter...
13:34:22 <parcs> > let same xs = case nub xs of { (_:_:_) -> False; _ -> True } in same (1:(repeat 5))
13:34:22 <lambdabot>   False
13:34:31 <b0fh_ua> okay, yet another stupid question, about lists
13:35:54 <b0fh_ua> how can I emulate four nested loops on the same list, with semantics of : for (int i=0; i< length - 4; i++) { for ( int j=i+1; j < length - 3 ; j++) ... ?
13:37:01 <doserj> > tails [1..10]
13:37:02 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
13:37:16 <vitka> > tails grbrstntrn... Beat me again.
13:37:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:37:43 <nihtml> @t tails
13:37:43 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:37:48 <nihtml> :t tails
13:37:49 <lambdabot> forall a. [a] -> [[a]]
13:38:05 <nihtml> prelude ?
13:38:05 <parcs> > inits [1..10]
13:38:06 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
13:38:12 <parcs> seems like you want that instead
13:38:59 <b0fh_ua> not really
13:39:36 <BMeph> b0fh_ua: Try map (:[])
13:39:49 <BMeph> > map (:[]) [1..10]
13:39:50 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
13:40:05 <BMeph> b0fh_ua: Is that what you want?
13:40:23 <nihtml> what do you want exactly?
13:40:30 <b0fh_ua> BMeph: i'm trying to figure out how to do nested loops on lists
13:40:59 <BMeph> b0fh_ua: Yeah, actually, I'll go with nihtml on that one; what DO you want? ;)
13:41:02 <b0fh_ua> let me show some imperative stuff in paste
13:41:04 <shachaf> > let l = 10 in [(i,j) | i <- [0..l-4], j <- [i+1..l-3]]
13:41:04 <lambdabot>   [(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(1,2),(1,3),(1,4),(1,5),(1,6),(1...
13:41:37 <BMeph> b0fh_ua: I'm in Haskell initiate phase; I'm imperative-impaired. ;þ
13:43:50 <Tomsik> Am I the only one to notice that _|_ look like a middle-finger?
13:44:09 <nihtml> huh, you're right
13:44:09 <shachaf> Probably the only one to care.
13:44:27 <Botje> Tomsik: ,|,, is even closer :]
13:44:30 <ion> It looks like a very ugly ASCII approximation of ⊥
13:44:40 <ion> IRC has underline, too: |
13:45:01 <shachaf> ion: That just looks like |
13:45:10 <monochrom> I have set the +c flag for this channel to kill your colour code and underline and bold etc
13:45:14 <vitka> I always thought naming (_|_) bottom was quite... appropriate.
13:45:19 <shachaf> monochrom++
13:45:21 <ion> A channel mode probably filters out the markup.
13:45:24 <b0fh_ua> I want something like: http://pastebin.com/p2nFFV87
13:45:24 <Tomsik> This is to reveal the age-long conspiracy: bottom is just a middle finger
13:46:07 * djanatyn is on a three hour road trip
13:46:10 <djanatyn> Brought my laptop
13:46:12 <djanatyn> And Real World Haskell
13:46:28 <nihtml> fuckyeahguy.bmp
13:46:40 <Botje> b0fh_ua: [ | (x:xs) <- tails list, y <- xs ]
13:46:43 <shachaf> What has this channel come to?
13:46:48 <Botje> or
13:46:59 <monochrom> > zip [1,2,3,4] (tail [1,2,3,4])
13:46:59 <lambdabot>   [(1,2),(2,3),(3,4)]
13:47:06 <shachaf> > ap zip tail [1,2,3,4]
13:47:07 <lambdabot>   [(1,2),(2,3),(3,4)]
13:47:10 <Botje> b0fh_ua: [ | (x:xs) <- tails list, (y:ys) <- tails ys, {- more stuff with ys -} ]
13:47:22 <monochrom> oops the zip doesn't do it
13:47:33 <Tomsik> :t zip`ap`tail
13:47:34 <lambdabot> forall b. [b] -> [(b, b)]
13:47:38 <djahandarie> @quote zip`ap`tail
13:47:38 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
13:47:47 <b0fh_ua> Botje: ahha
13:47:48 <nihtml> :t ap
13:47:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:47:54 <Tomsik> @quote oleg
13:47:54 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
13:48:30 <djahandarie> nihtml, you can replace  m  in that type signature with  x ->
13:49:05 <shachaf> x -> (a -> b) -> x -> a -> x -> b
13:49:18 <nihtml> oh
13:49:20 <djahandarie> Not what I meant :p
13:49:25 <djahandarie> @ty ap :: (x -> a -> b) -> (x -> a) -> (x -> b)
13:49:25 <lambdabot> forall x a b. (x -> a -> b) -> (x -> a) -> x -> b
13:49:42 <nihtml> interesting
13:49:47 <ion> > ((f :: Expr -> Expr -> Expr) `ap` (g :: Expr -> Expr)) x
13:49:47 <lambdabot>   f x (g x)
13:50:13 <ion> :t (<*>)
13:50:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:50:37 * shachaf has the strangest sense of déjà vu.
13:58:06 <kim__> hmm http://learnyouahaskell.com/starting-out   has syntax highlighting in all ghci examples, but my (gentoo) ghci doesn't seem to have color... what's going on?
13:58:09 * kim__ scratches head
13:58:42 <Botje> kim__: it's just the way it's typeset
13:58:48 <JoeyA> I didn't know GHCi had syntax highlighting.
13:59:05 <mauke> kim__: doesn't have syntax highlighting here
13:59:12 <mauke> conclusion: javascript hackery
13:59:39 <hpc> yeah, if you turn off javascript the highlighting disappears
14:00:04 <mauke> this is not a live photograph
14:00:16 <hpc> there's something floating around (package? config?) that gives ghci some highlighting
14:00:24 <kim__> Okay, I was just wondering
14:00:36 <hpc> but it has a few crucial flaws
14:00:58 <kim__> I thought it was pretty nifty that a command line tool would do highlighting for me :-P
14:01:27 <kim__> I can live without. Buut ... In case I want to indulge myself, is there a CLI that can do highlighting? ;-)
14:02:30 <Botje> I would guess emacs' haskell-mode
14:02:34 <Botje> but i never tried it
14:02:44 <JoeyA> I think WinGHCi (Windows) does it, but I don't remember (I'm on Linux)
14:03:48 <kim__> I'll live
14:04:26 * JoeyA pulls out a machine gun and starts firing wildly
14:04:32 <JoeyA> Oh no you won't!  Ahahahahaha!
14:06:14 <Phyx-> irc for emacs? wtf
14:06:20 <dRbiG> okay, i'm giving up a bit: i have a [String] and I want to transform it into ["x1 x2", "x2 x3", "x3 x4" ...], where x1,x2,xn are consecutive elements of [String]
14:06:29 <hpc> Phyx-: you can run emacs within emacs
14:06:37 <Phyx-> rofl
14:06:57 <kim__> Phyx-, you haven't found the kitchen sink yet?
14:07:19 <JoeyA> so f "abcd" == ["a b", "b c", "c d"] ?
14:07:20 <Phyx-> kim__: no, but that explains the plunger i found
14:07:23 <mauke> :t unfoldr
14:07:24 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:07:30 <mauke> JoeyA: type mismatch
14:07:49 <Saizan> > let xs = ["x1","x2","x3"] in zipWith (++) xs (tail xs) -- dRbiG
14:07:50 <lambdabot>   ["x1x2","x2x3"]
14:08:07 <dRbiG> JoeyA: yes
14:08:10 <Saizan> > let xs = ["x1","x2","x3"] in zipWith (\x y -> x ++ " " ++ y) xs (tail xs) -- dRbiG
14:08:11 <lambdabot>   ["x1 x2","x2 x3"]
14:08:25 <mauke> > let xs = ["x1","x2","x3"] in zipWith (printf "%s %s") xs (tail xs) :: [String]
14:08:26 <lambdabot>   ["x1 x2","x2 x3"]
14:08:27 <dRbiG> thx!
14:08:34 <kim__> so I just made a file baby.hs (http://learnyouahaskell.com/starting-out)
14:08:39 <nihtml> > zip [1..5] (tail [1..5])
14:08:40 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
14:08:41 <kim__> which defines a function doubleMe
14:08:48 <dRbiG> heh, it's so simple when you see it
14:08:52 <kim__> why couldn't I define the function in GHCi   ... or are they getting to that?
14:10:00 <mauke> http://learnyouahaskell.com/starting-out#an-intro-to-lists
14:14:12 <robinhoode> AFAIK you can't define functions in GHCi
14:14:56 <robinhoode> although I believe things like >f = \x -> x*2  actually does work. don't hate me if i'm wrong though
14:15:04 <noteventime> Can't you just use let?
14:15:11 <noteventime> let fun ... = ...
14:15:14 <stepkut> is there a function to reduce the precisions of doubles? I want only one number to the right of the decimal point
14:15:18 <scree> let f x = x + 1 works in ghci, yes
14:15:27 <mauke> doubles don't have decimal points
14:15:43 <scree> if it helps, ghci works roughly as if it's in one giant do block
14:15:44 <kim__> Ah, gottit, let will do it for me
14:15:58 <stepkut> mauke: :-/
14:16:11 <kim__> hehe, and my question got answered here as I was looking it up ;-)
14:16:16 * kim__ reads on
14:16:37 <stepkut> mauke: go on!
14:16:47 <mauke> my heart will go on
14:17:16 * kim__ sinks mauke in arctic waters
14:18:34 <noteventime> Does anyone know of any good explanation of why the yoneda lemma gives full faithfullness of the yoneda embedding?
14:18:40 <JoeyA> > 100000 * 0.07
14:18:40 <lambdabot>   7000.000000000001
14:19:10 <JoeyA> > 100000 * 0.07 :: Double
14:19:10 <lambdabot>   7000.000000000001
14:19:14 <JoeyA> > 100000 * 0.07 :: Float
14:19:15 <lambdabot>   7000.0
14:19:17 <scree> stepkut: you can do something with (*10), floor, fromIntegral and (/10) that will work
14:19:30 <mauke> preflex: calc '2 100000 * 0.07
14:19:30 <preflex>  1101101011000
14:19:38 <JoeyA> > printf "%.1g" 3.14159
14:19:38 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:19:38 <lambdabot>    `Text.Printf.PrintfType ...
14:19:41 <stepkut> scree: yeah
14:19:42 <JoeyA> > printf "%.1g" 3.14159 :: String
14:19:43 <lambdabot>   "3.1"
14:19:55 <ion> > 100000 * 0.07 :: Rational
14:19:56 <lambdabot>   7000 % 1
14:20:30 <stepkut> maybe I just want to limit the precision when I convert it to a string on the javascript side
14:21:43 <JoeyA> What about the tinfoil hat people who have JavaScript disabled?
14:22:19 <stepkut> those people won't care about my jmacro demo then
14:22:35 <tommd> dons: Could you add a Typeable instance to PureMT?  It would save me a standalone derivation (or I could add it, if you don't mind)
14:23:02 <Zao> JoeyA: For those kinds of people, you should break so hard that they grudgingly enable JS for your site.
14:23:03 <stepkut> when generating random temperatures for a weather report, it seems wrong to go beyond 1 point beyond the decimal
14:23:08 <kim__> "lists can contain lists of lists of lists" ... said the cat in the hat
14:23:39 * stepkut only visits sites that use <script type="text/x-haskell">
14:24:51 <JoeyA> hehe
14:25:11 <JoeyA> unsafePerformJavaScript :: String -> IO ()
14:25:31 <zenzike> I've got code that uses 'read' to turn a String into an Int, but it's obviously fragile when there's no good parse. What's the recommended way to cope with this, exception handling, or some other read function?
14:25:41 <mauke> zenzike: reads
14:25:56 <kim__> is reverse a fast operation?
14:26:02 <parcs> or readMay from the 'safe' package
14:26:10 <kim__> I know that 5:[1,2,3,4]  is pretty quick
14:26:27 <JoeyA> kim__: reverse is O(n)
14:26:34 <kim__> but how do I do [1,2,3,4] and then add 5 in a quick way , since ++ is slow
14:26:39 <stepkut> ok. I just used 'n.toFixed(1)' in javascript and that fixed my issue :)
14:26:40 <mauke> kim__: you don't
14:26:50 <JoeyA> You could build the list in reverse, then reverse it.
14:26:50 <parcs> you use another data structure
14:27:00 <zenzike> parcs: oh, thanks, I'd never seen that package before. useful :-)
14:27:06 <scree> kim__: saying (++) is slow is a troublesome statment
14:27:09 <JoeyA> Or build the list lazily.
14:27:13 <kim__> Ok, that confuses me, but I suppose all shall be revealed
14:27:14 <JoeyA> @src map
14:27:15 <lambdabot> map _ []     = []
14:27:15 <lambdabot> map f (x:xs) = f x : map f xs
14:27:18 <parcs> zenzike: indeed
14:27:42 <kim__> scree, I'm assuming learnyouahaskell.com is doing some lies to children. Later I shall surely learn more about ++ ;-)
14:28:00 <ion> > let f = (++) [1,2,3,4] . (++) [5] in f []
14:28:01 <lambdabot>   [1,2,3,4,5]
14:28:03 <scree> kim__: so, it's true that in some sense [1..1000000] ++ [5] takes O(n) time.  But that's only if you evaluate the list, which takes O(n) time anyway
14:28:22 <jmcarthur> kim__: the speed of the operation just depends on the data structure. for linked lists, it has to traverse the entire list just to tack stuff onto the end of it
14:28:38 <scree> kim__: so, it's only really a problem if you're planning on doing (([1..1000000] ++ [5]) ++ [4]) ++ ...
14:28:42 <jmcarthur> scree: but it adds a cost to every element of the list you are traversing
14:28:50 <kim__> jmcarthur, oh  [ ] is a *linked list*. Now that makes sense
14:28:57 <kim__> singly linked then, I presume?
14:28:58 <kim__> :-)
14:29:02 <jmcarthur> kim__: yes
14:29:16 <jmcarthur> kim__: there are arrays, finger trees, and other junk in various libraries, too, though
14:29:16 <mauke> kim__: data [] a = [] | (:) a ([] a)
14:29:22 * mauke is unhelpful
14:29:27 <kim__> (actually, someone mentioned cons already, I'll assume there's also a cdr ... not that I ever really understood those. I can't think functionally (yet))
14:29:29 <jmcarthur> kim__: Data.Sequence is good for working from both ends
14:29:50 <scree> jmcarthur: sure; I wasn't saying it was O(1), just that it was misleading to say it was O(n)
14:29:53 <kim__> jmcarthur, ok, I'll probably learn that in the coming while then :-)
14:29:58 <JoeyA> cons -> (:)
14:30:01 <JoeyA> car -> head
14:30:01 <mauke> kim__: head (x : xs) = x; tail (x : xs) = xs
14:30:03 <JoeyA> cdr -> tail
14:30:23 * kim__ guesses JoeyA knows lisp and/or logo ;-)
14:30:24 <jmcarthur> scree: well, it's conventional to pretend that we are forcing the entire result when reporting the complexity of algorithms in a lazy language
14:30:27 <JoeyA> Nope
14:30:39 <jmcarthur> scree: although of course it's not completely correct when not planning to force the entire result
14:31:04 <JoeyA> I've played around with DrScheme, but I'm a complete noob of Scheme and Lisp.
14:31:17 <kim__> JoeyA, but at least you'll understand them already
14:31:25 <kim__> wheras I keep getting stuck somehow
14:31:28 <jmcarthur> and if anybody wanted to know more about it i would just refer to okasaki :)
14:31:42 <JoeyA> And I don't know Logo, but I know where to find out how to move the turtle.
14:31:44 <kim__> or rather, I never get around to learning how to think functionally properly
14:32:02 <JoeyA> http://stackoverflow.com/questions/1003841/how-do-i-move-the-turtle-in-logo
14:32:05 <kim__> JoeyA, I made a perfectly cromulent stack based language to control turtles
14:32:20 <scree> jmcarthur: sure, sure.  nontheless I found the subtlety useful to understand when I was learning.  i almost certainly explained it badly and at the wrong time
14:32:37 <kim__> I even pushed -to -stack right-to-left so that turtle commands would look logoy
14:32:47 <kim__> (aka, forward 100   rather than   100 forward )
14:33:13 <kim__> but right now, I'm learning haskell, so I'll hush about that
14:33:26 <JoeyA> Doesn't the J programming language manage to handle 2+2 in a stack-based manner?
14:33:47 <mekeor> whats the difference btw "class" and "data"? methods?
14:33:52 <kim__> scree, it's useful to know that I'm being lied-to-childrened to ?
14:34:00 <mauke> mekeor: data creates types, class creates classes
14:34:14 <kim__> JoeyA, it prolly converts to RPN internally? (I dunno)
14:34:15 <JoeyA> mekeor: A "class" in Haskell is not the same as a "class" in an object-oriented language.
14:34:47 <JoeyA> A "class" in Haskell refers to a collection of types that implement a set of methods.
14:35:00 <mekeor> oO
14:35:12 <jmcarthur> i've never seen a case where it is impossible for a tutorial to avoid lying to a beginner without being too confusing
14:35:27 <ion> Difference lists: http://hackage.haskell.org/package/dlist
14:35:32 <JoeyA> A "class" in C++, Java, etc. is a type whose instances are values where methods can be called on them.
14:35:49 <JoeyA> (that wasn't very clear)
14:36:10 <jmcarthur> difference lists can be a misleading response to the slowness of (++) since they only maintain their efficient concatenation for certain usage patterns
14:36:11 <JoeyA> An "instance" of a class in Haskell is a type, not a value.
14:36:19 <Zao> Haskell needs a Feynman that can explain any concept in accurate analogies.
14:36:45 <JoeyA> Type classes are like a big balloon
14:36:51 <scree> kim__: it maybe isn't at this stage.  When you're thinking about lazyness, thinking about what happens with (++) is a useful example
14:37:19 <JoeyA> (jk)
14:37:26 <jmcarthur> @src (++)
14:37:26 <lambdabot> []     ++ ys = ys
14:37:26 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:37:26 <lambdabot> -- OR
14:37:26 <lambdabot> xs ++ ys = foldr (:) ys xs
14:37:29 <kim__> scree, I'll keep that in mind, hopefully ;-)
14:37:43 * kim__ goes to read about texas ranges (groan)
14:37:51 <kim__> (what a pun)
14:39:08 <djanatyn> wooooo!
14:39:27 <djanatyn> I just wrote my first (cool) haskell program :)
14:39:34 <djanatyn> pastebin.com/nwHJAk0d
14:39:49 <jmcarthur> (1:2:3:4:[]) ++ (5:[]) = 1 : ((2:3:4:[]) ++ (5:[])) = 1 : 2 : ((3:4:[]) ++ (5:[])) = 1 : 2 : 3 : ((4:[]) ++ (5:[])) = 1 : 2 : 3 : 4 : ([] ++ (5:[])) = 1 : 2 : 3 : 4 : 5 : []
14:40:15 <parcs> djanatyn: that compiles?
14:40:17 <kim__> ha, I just made my first infinite list
14:40:23 * kim__ feels very haskelly now
14:40:31 <djanatyn> parcs: ...I guess?
14:40:37 <jmcarthur> hehe, i remember that felt weird the first time i did it
14:40:40 * Zao pats djanatyn encouragingly on the head
14:40:41 <djanatyn> I just loaded it into ghci
14:41:09 <mauke> parcs: why not?
14:41:13 <djanatyn> I took a recent break from Haskell, but I was bored on my roadtrip.
14:41:22 <djanatyn> Ignore the import.
14:42:27 <parcs> mauke: i recall having to indent thens and elses within do notation
14:45:43 <danharaj> So posted on stack overflow for the first time and getting all these privileges very quickly makes me feel like it's an RPG
14:46:27 <JoeyA> Anyone wanna go on a raid later tonight?
14:46:35 <monochrom> haha
14:46:35 <kim__> hmm, haskell list comprehensions are nice. multiple lists reminds me of SQL
14:46:43 <kim__> (JOIN)
14:47:13 <kim__> I assume predicates can get pretty important pretty fast if you're doing multiple JOIN^Wlists
14:47:28 <mauke> no one uses list comprehensions
14:48:43 <osfameron> mauke: noone?
14:49:00 <shachaf> osfameron: No, even Noone doesn't use them.
14:49:40 <kim__> hardly ever used 'em in python neither
14:50:25 * osfameron doesn't like list comprehensions (map/filter is clearer, mostly, unless you also need to cartesian product behaviour)
14:50:45 <kim__> "Let's remove all odd numbers without flattening the list"
14:50:51 <kim__> but they haven't told me how to flatten a list yet
14:51:01 <parcs> @type lex
14:51:02 <lambdabot> String -> [(String, String)]
14:51:54 <JoeyA> > concat [[1,2,3],[4,5,6]]
14:51:55 <lambdabot>   [1,2,3,4,5,6]
14:52:11 <kim__> lambdabot is running haskell?
14:52:19 <JoeyA> Yup
14:52:24 <JoeyA> > fix error
14:52:25 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:52:39 <kim__> it doesn't like you now :-P
14:52:48 <JoeyA> > Just $ do it
14:52:49 <lambdabot>   Not in scope: `it'
14:53:00 <JoeyA> > let it = "be done" in Just $ do it
14:53:01 <lambdabot>   Just "be done"
14:53:01 <kim__> > 1+2
14:53:02 <lambdabot>   3
14:55:32 * kim__ tries everything with infinite lists. I like that concept so much!
14:55:33 <kim__> :-)
14:56:12 <kim__> ok, a lot of haskell examples are very mathy
14:56:13 <kim__> :-/
14:56:20 <kim__> I'm ok with that... just... hmph
14:56:35 <kim__> one wonders if functional coders are all mathy people or something! ;-)
14:56:55 <kim__> (I'm more of a pictures person, but there you have it)
14:57:56 <kim__> > :t "hello"
14:57:56 <lambdabot>   <no location info>: parse error on input `:'
14:58:13 <kim__> why doesthat not work for lambdabot but does work in ghci?
14:58:16 <kim__> <scratches head>
14:58:20 <shachaf> Because lambdabot isn't ghci.
14:58:21 <hpc> kim__: not so much that they ARE mathy as that they BECOME mathy
14:58:30 <kim__> hpc, scary thought
14:58:44 <shachaf> Also not particularly true.
14:59:14 <shachaf> At least, not of anybody that I've observed in this channel.
14:59:27 * shachaf isn't sure what "mathy" actually means, on the other hand.
14:59:47 <geheimdienst> :t "hello"
14:59:47 <lambdabot> [Char]
15:01:24 * ddarius doesn't see how being a "pictures person" is at all in contradiction with being a "mathy person."
15:01:29 <Twey> kim__: > is an alias for @run.  :t is an alias for @type.
15:02:09 * ddarius probably shouldn't tell kim__ that all programming is just applied logic.
15:02:17 <Twey> kim__: > is an alias for @run.  :t is an alias for @type.
15:02:47 <Twey> GHCi runs things by default and parses out :foo codes to do special operations.  lambdabot's @run isn't like that: it just runs stuff.
15:02:50 <sshc> Codensity can improve the performance of tree-like monads, but can it ever negatively effect the performance of other monads (like State)?
15:02:56 <jmcarthur> kim__: I think the reason is that Haskell makes it easier to use ideas from mathematics than other languages do.
15:02:57 <shachaf> ddarius: I've seen some programming that I'd be hard-pressed to describe as such.
15:03:05 <Twey> Hah
15:03:25 <djanatyn> hpaste.org/46690/guess_20
15:03:32 <djanatyn> :D
15:03:45 <ddarius> shachaf: And yet it is.
15:03:46 <shachaf> djanatyn: Are you reading YAHT or something?
15:03:58 <Twey> djanatyn: It is irritating when you don't put the protocol in your URLs.
15:04:01 <ddarius> sshc: Yes.
15:04:44 <shachaf> ddarius: Would you consider a randomly-generated program that happens to do something useful to be "applied logic"?
15:05:10 <ddarius> shachaf: Would you consider a randomly-generated proof that happened to prove something useful to be "math?"
15:05:17 <jmcarthur> emergent logic :P
15:05:19 <djanatyn> Twey: sorry, touch screen phone
15:05:33 <djanatyn> shachaf: Nope. Several tutorials, though.
15:05:46 <djanatyn> I did this one by myself, in the car.
15:05:53 <Twey> djanatyn: result is undefined for n == theAnswer
15:06:12 <Twey> And lives is undefined for anything other than 1, 2, 3
15:06:16 <djanatyn> Twe	that"'s okauy
15:06:21 <Twey> Er, displayChances, I mean
15:06:22 <sshc> ddarius: Could you elaborate?  How could it negatively effect performance?
15:06:23 <Twey> No, it's not :þ
15:06:25 <Twey> It's bad :þ
15:06:28 <sshc> Are there any specific examples?
15:06:35 <djanatyn> oh, wait.
15:06:39 <kim_bruning> shachaf, if it was merely randomly permutated... ;-)
15:06:41 <djanatyn> That is bsd :)
15:07:07 <sshc> djanatyn: -Wall
15:07:09 <djanatyn> result doesn't need to know the answer
15:07:41 <djanatyn> It'll go straight to youWin if you enter the answer.
15:07:47 <sshc> djanatyn: -Wall is especially helpful as a beginner
15:08:19 <Twey> djanatyn: Not the point
15:08:25 <Twey> Functions should be total wherever possible
15:08:34 <djanatyn> However, displayChances needs more values, or numberOfAttempts needs to be more strict
15:08:35 <Eelis> hm, is there perhaps some more general type class for functors that makes Data.Set a functor?
15:08:38 <djanatyn> Really?
15:08:39 <hpc> and when they aren't possible, pick a different function
15:08:43 <Twey> Eelis: No :-\
15:08:47 <Eelis> Twey: :(
15:08:52 * shachaf wonders how much stricter than 3 you can get.
15:09:07 <djanatyn> But it'll never reach result with that :)
15:09:12 <sshc> djanatyn: At the very least, you should add "| otherwise = error "some descriptive error message; unhandled / unexpected case; etc."
15:09:23 <sshc> djanatyn: Also, that code is a significant improvement over your last version
15:09:25 <ddarius> > 3 undefined
15:09:26 <lambdabot>   3
15:09:35 <djanatyn> shachaf: that's a good idea
15:09:43 <djanatyn> sshc/Twey: thanks
15:09:48 <Eelis> Twey: thanks
15:10:15 <hpc> sshc: aah! not that! leave it blank so you at least get a line number
15:10:29 <shachaf> ddarius: I suppose there is that.
15:13:44 <sshc> hpc: Not a problem if the error message uniquely identifies where the error occurs, and it also resolves a warning
15:17:28 <sshc> hpc: An automatic line number is useful, but it comes at the expense of a warning in that case
15:18:46 <djanatyn> http://hpaste.org/paste/46690/guess_20_annotation#p46691
15:18:53 <djanatyn> woot :)
15:19:19 <djanatyn> shachaf: now it doesn't care what number you give it.
15:19:29 <djanatyn> Or how many chances you have.
15:22:17 <Twey> sshc: It would be nice if we could include line numbers in errors…
15:22:24 <Twey> Maybe some TH?
15:22:51 <Twey> djanatyn: Nice!
15:23:02 <Twey> Now rewrite it to use enumerators and iteratees ;þ
15:23:11 <sshc> Twey: Is there a TH primitive for line numbers?
15:23:22 <Twey> I suspect not
15:23:36 <kim_bruning> typeclasses are interesting
15:23:53 <kim_bruning> :t 3
15:23:53 <lambdabot> forall t. (Num t) => t
15:23:55 <kim_bruning> oops
15:24:52 <kim_bruning> can I get a list of typeclasses someone is a member of?
15:24:59 <sshc> Twey: "error" and "undefined", and least without optimizations, should also print line number along with other useful identifying information, I think
15:25:13 <Twey>  Yeah
15:25:15 <parcs> @info Int
15:25:15 <lambdabot> Int
15:25:18 <sshc> At the very least, there should be 'errorLoc' or something like that that includes location information
15:25:22 <parcs> in ghci you can, with :i
15:26:29 <sshc> Somebody should ticket this
15:26:38 <kim_bruning> parcs, :i 5
15:26:40 <sshc> (just "undefined" isn't enough)
15:26:48 <kim_bruning> "parse error"
15:26:50 <kim_bruning> :/
15:27:01 <kim_bruning> wait, you were answering someone else?
15:27:51 <alpounet> kim_bruning, you have to give the type
15:27:56 <alpounet> not a value of that type
15:28:05 <alpounet> try ":i Int" for examle
15:28:08 <alpounet> example*
15:28:30 <kim_bruning> alpounet, Hey! Bingo! Lots of instances
15:28:48 <kim_bruning> this definitely doesn't work like a "regular" oo langauge
15:29:43 <kim_bruning> it's a member of a whole bunch of classes at once. (well, maybe it's doing multiple inheritence of multiple interfaces/anonymous classes ... but somehow I have a feeling it's going to be set up differently)
15:30:05 <Liskni_si> sshc, Twey: http://anna.fi.muni.cz/~xjanous3/gitweb/?p=dve-hs.git;a=blob;f=Divine/Util/Assert.hs
15:30:39 <ddarius> kim_bruning: Haskell is not an object-oriented language, why would you expect it to work anything like one?
15:31:38 <kim_bruning> ddarius, I'm completely blank slate atm, actually. :-)
15:32:13 <kim_bruning> ddarius, I only just noticed that it's not quite OO, while learning. ;-)
15:32:38 <Twey> Liskni_si: $__LOCATION__?
15:32:41 <shachaf> kim_bruning: It's not like «a "regular" oo language» because it's not an OO language at all.
15:32:49 <Twey> Is that from Loc?
15:33:07 <Twey> Oh no, there it is, silly me
15:33:11 <Twey> Neat
15:33:55 <geheimdienst> kim_bruning: when learning haskell, you'll come across the word "typeclass". don't get confused, it's not like a class in a language like java. just a friendly heads-up
15:34:28 <Twey> What does the [| … |] syntax without a quasiquoter name do, again?
15:34:28 <blackdog> kim_bruning: if you know ruby, it's a bit like a formalised version of duck typing
15:34:29 <tromp_> it's like an interface in jhava
15:34:35 <sshc> Liskni_si: Interesting.
15:34:39 <osfameron> ooo, is this a symbol for a monad? http://www.nachtkabarett.com/ihvh/img/hieroglyphic_monad.gif
15:34:40 * blackdog feels a bit like a blind man describing an elephant...
15:34:46 <ddarius> The term is "type class" anyway.
15:34:47 <osfameron> oh, in John Dee's alchemical symbols
15:34:52 <kim_bruning> geheimdienst, could have warned me SLIGHTLY earlier :-P
15:35:02 <sshc> Liskni_si: Should be uploaded to hackage without "Divine"!
15:35:12 <Twey> .ie
15:35:15 <ddarius> blackdog: And if kim_bruning knows C++ ...
15:35:37 <kim_bruning> blackdog, quack
15:35:37 <Phyx-> osfameron: rofl, that looks evil
15:35:54 <Liskni_si> Twey: turns a haskell expression into its abstract syntax tree (of type Q Exp)
15:35:54 <djanatyn> random numbers in haskell are...cool and weird.
15:36:09 <Twey> Ah, right
15:36:13 <Twey> Quoting
15:36:35 <djanatyn> > randomR (1,100) (mkStdGen 123)
15:36:36 <lambdabot>   (6,4961736 40692)
15:36:41 <Liskni_si> sshc: okay, I'll try to do that tomorrow :-)
15:37:03 <djanatyn> how do I replace 123 with, say, the system time?
15:37:34 <noteventime> djanatyn: Use newStdGen
15:37:34 <Twey> getSystemTime >>= randomR (1, 100) . mkStdGen
15:37:46 <Twey> A.K.A. newStdGen >>= randomR (1, 100)
15:37:50 <sshc> @type getSystemTime
15:37:51 <lambdabot> Not in scope: `getSystemTime'
15:37:55 <djanatyn> umm.
15:38:02 <Twey> Yeah, pseudo-action :þ
15:38:02 <sshc> @hoogle getSystemTime
15:38:03 <lambdabot> No results found
15:38:10 <djanatyn> what is >>= o_o
15:38:28 <djanatyn> I know about (.)
15:38:36 <shachaf> Twey: newStdGen isn't really that.
15:38:36 <sshc> djanatyn: He means "do{sysTime <- getSystemTime; ...}"
15:38:39 <djanatyn> but what is that?
15:39:05 <sshc> djanatyn: The thing is, you can't purely get the system time
15:39:07 <Twey> It's better?
15:39:13 <djanatyn> ah
15:39:18 <shachaf> djanatyn: You'll find the answer in many, many guides.
15:39:20 <Twey> djanatyn: It's a monad composition.
15:39:22 <shachaf> Too many.
15:39:22 <DasIch_> djanatyn: it operates on monads
15:39:26 <djanatyn> Yeah, that purity stuff.
15:39:26 <sshc> djanatyn: If you have "systemTime :: Integer", you can't change it from 10 at one time then 11 at another time
15:39:40 <DasIch_> djanatyn: unless you know what a monad is you don't have to know about it
15:40:03 <shachaf> Ugh. Learn about (>>=) before you learn about "what a monad is".
15:40:19 <Twey> Learn about (>>=) and you know ‘what a monad is’.
15:40:32 <djanatyn> DasIch_: Pretty sure I'm going to have to learn about monads soon.
15:41:03 <djanatyn> Especially with "Write Yourself a Scheme in 48 Hours)
15:42:55 <ion> Btw, guessedNumber <- read <$> getLine :: IO Integer
15:43:34 <ion> (also equivalent in this case to liftM read getLine)
15:45:28 <sshc> @type readLine
15:45:28 <lambdabot> Not in scope: `readLine'
15:45:53 <sshc> I wonder where I saw that
15:46:07 <sshc> @hoogle Read a => IO a
15:46:07 <lambdabot> Prelude readLn :: Read a => IO a
15:46:07 <lambdabot> System.IO readLn :: Read a => IO a
15:46:07 <lambdabot> Prelude readIO :: Read a => String -> IO a
15:46:21 <sshc> @src readLn
15:46:21 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
15:47:07 <ion> Ah :-)
15:47:29 <sshc> "The readIO function is similar to read except that it signals parse failure to the IO monad instead of terminating the program."
15:47:47 <joseph_> why not just leave readIO l as the last line?
15:48:00 <Twey> It's also checked where you execute it, rather than potentially not throwing the error until later
15:48:21 <sshc> joseph_: You could.
15:48:23 <Twey> joseph_: Why not just write readLn = getLine >>= readIO ?
15:48:30 <Twey> ‘Because.’
15:48:30 <joseph_> i guess
15:48:33 <Twey> Perhaps they thought it was more readable.
15:48:37 <Peaker> Using pure exceptions in read is bad. Using IO exceptions is ugly.  Can't they just use Maybe or Either and let the user decide? :-(
15:48:47 <joseph_> but the difference between the >>= and the do version are stylistic
15:49:02 <Peaker> More readable to imperative programmers, probably
15:49:05 <parcs> @hoogle readMay
15:49:05 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
15:49:06 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
15:49:06 <joseph_> whereas r <- readIO l; return r just seems superfluous
15:49:09 <ion> getLine >>= readIO >>= return >>= return >>= return
15:49:36 <sshc> Peaker: Exactly.  There are already definitions of "maybeRead" and "readMaybe"
15:49:37 <Twey> joseph_: The additional points are no more or less stylistic or redundant than the additional ‘return’…
15:49:39 <sshc> They should become standardized
15:50:04 <Peaker> sshc: Either may be good because Parse errors may actually elaborate
15:50:33 <sshc> That too
15:51:20 <jmcarthur> return <=< return <=< return <=< readIO =<< getLine
15:51:54 <sshc> *Huh* "The readLn function combines getLine and readIO."
15:52:03 <sshc> @type readLn
15:52:04 <lambdabot> forall a. (Read a) => IO a
15:52:14 <Twey> Yeah.
15:52:15 <sshc> 'readLn' is *not* a function.  It's an IO action.
15:53:56 <sshc> ddarius: What is a monad that *is* negatively affected by Codensity?
15:54:13 <mikeg> Why would one use readIO over read? What is the advantage of ioError (System.IO.Error stuff) over Control.Exception handling? And specifically for read?
15:56:21 <sshc> mikeg: What should be standard is a 'Maybe' / 'Either' version
15:57:05 <Twey> Yeah
15:57:31 <Twey> mikeg: readIO is better than read because you know when the error will appear and can catch it
15:57:38 <mikeg> "It's also checked where you execute it, rather than potentially not throwing the error until later" <-- Oh, I didn't see this. Why is that better than readIO = evaluate . read?
15:57:57 <Twey> That bit's the same
15:58:17 <Twey> But you can also catch IO exceptions in H98, as opposed to ‘error’, which is what you get with ‘read’
15:58:37 <Cale> The Prelude exception stuff is the old (but standardised) system for handling exceptions
15:58:44 <Cale> Control.Exception is newer
15:58:58 <Cale> (and nicely extensible)
15:59:02 <Twey> Really, ‘error’ should indicate programmer errors, whereas ‘read’ parse failures tend to be user errors
15:59:16 <Twey> Which the programmer should be able to catch, which isn't the case with the Prelude/H98 ‘catch’
15:59:46 <Twey> Cale: Did the new standard standardise ‘catch’ on ‘error’?
15:59:54 <Cale> I don't know.
15:59:55 <mikeg> Oh, so pure exception handling wasn't standard in H98?
15:59:59 <Cale> I don't think it has.
16:00:07 <Cale> The new standard didn't change much at all
16:00:16 <Cale> Right.
16:00:17 <dixie> I would like to solve simple linear equations (e.g. via gauss) and they have integer solution. But I'm getting not an integer solutions because rounding error on computer (Vec or hmatrix). I can not recall from my school days how it is usually solved...
16:00:32 <Cale> Exceptions thrown from pure code normally ought to be treated as complete failure.
16:00:35 <dixie> Anybody can help? :)
16:00:37 <Cale> (nontermination)
16:01:03 <Cale> So, don't throw them with the intention that they'll be caught.
16:01:20 <Cale> The ability to catch them is sort of a measure of last resort :)
16:01:32 <hpc> and especially don't throw them with the expectation that other programmers will even KNOW HOW to catch them
16:02:00 <Cale> If you know that something might fail, use a datatype to represent the failure somehow, like Maybe or Either String
16:02:01 <dolio> There's really no excuse for the current state of read.
16:02:14 <Cale> read is okay for the case that you know it won't fail
16:02:28 <Cale> (like when you emitted the string you're reading in the first place)
16:02:48 <hpc> if you want to get a Maybe out of a read, a valid parse will be when reads matches the pattern [(x, "")]
16:02:50 <Cale> Or for one-off cases where you know the string going in will parse and you're not worried about it.
16:03:02 <Cale> reads is better for the general case of handling user input
16:03:59 <hpc> entertainingly: http://haskell.org/hoogle/?hoogle=Read+a+%3D%3E+String+-%3E+Maybe+a
16:04:07 <hpc> note the module the first is in :P
16:05:51 <ben> teaspoon . read? :)
16:06:18 <Peaker> What's Codensity?
16:06:38 <ben> If that's even the right kind of exception
16:07:06 <Saizan> Peaker: newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r)
16:07:22 <Saizan> Peaker: it's a monad for every f
16:09:39 <Peaker> Saizan: under what f constraint? Just Functor? Probably Monad?
16:10:02 <sshc> Peaker: Nope; no constraint
16:10:13 <sshc> Saizan: Do you know if it can negatively affect the performance of a monad?
16:10:17 <sshc> Saizan: If it does, which one / how?
16:10:23 <Peaker> Then it seems it's just like Cont, except with the seemingly superfluous higher kind?
16:10:40 <sshc> (at least a bit "significantly", that is)
16:10:44 <Peaker> newtype Cont r a = Cont ((a -> r) -> r)
16:10:45 <dRbiG> hmm, okay, i admit i'm impressed by haskell (in practice, finally ;))
16:10:52 <blbrown_win3> can you pattern match with an expression tied to it.   E.g.  func ((mod x 4) == 0 = {more code}  ... where I want to call 'mod' and perform pattern matching
16:11:06 <sshc> Peaker: See Asymptotic Improvement of Computations over Free Monads
16:12:24 <Saizan> sshc: if we had the Set monad, then Codensity Set wouldn't perform any pruning at intermediate steps, duplicating work
16:12:26 <Peaker> sshc: any short explanation of what the higher kind allows?
16:13:08 <Saizan> Peaker: it's more like ContT r f a, so a transformer
16:13:59 <Saizan> Peaker: except that we don't need the r to be free, so we quantify over it, which gives more guarantees wrt control effects
16:14:07 <dolio> Cont is a special case of codensity, but codensity is not a special case of Cont.
16:14:38 <Peaker> Saizan: Why not defined Codensity in terms of ContT, but forall'ing the r on the RHS?
16:14:43 <dolio> If m is a monad, then Codensity m is isomorphic to m.
16:14:51 <dolio> And Cont r is not.
16:14:53 <stepkut> is utf8-string still the best way to convert a String to a utf-8 encoded ByteString?
16:15:32 <Peaker> what about: Cont (forall r. m r)? (I'm just shooting in the dark :-)
16:15:32 <Saizan> Peaker: because newtype constructors and importing Control.Monad.Cont for this is annoying?:)
16:15:36 <Eelis> anyone seen ekmett recently?
16:15:50 <dolio> Does that look like the same type?
16:15:53 <Lemmih> stepkut: text is also nice.
16:16:00 <Saizan> ?unmtl Cont (forall r. m r) a
16:16:00 <lambdabot> err: Parse error
16:16:06 <Peaker> Saizan: well, when code duplication is easier than re-use you know you've installed enough bureaucracy :-)
16:16:08 <Saizan> heh, poor unmtl
16:16:15 <Eelis> @seen ekmett
16:16:15 <preflex>  ekmett was last seen on #haskell 1 year, 127 days, 5 hours, 39 minutes and 22 seconds ago, saying: jmcarthur: accident =)
16:16:15 <lambdabot> Unknown command, try @list
16:16:18 <Eelis> oh
16:16:22 <chegibari> Is there a generic channel for "computer science"?
16:16:51 <Saizan> Peaker: bah, depends
16:16:53 <ben> Try asking in ##math
16:17:00 <stepkut> Lemmih: yeah, but I am starting with a String and have no control over that. Converting to String -> Text -> utf-8 seems a bit silly (until the GSoC project to convert Text to utf-8 is done)
16:17:02 * Saizan is not so obsessed with libraries
16:17:08 <rbarooah> I am a haskell newbie - I've just written my first haskell program (a trivial mandelbrot plotter using Graphics.Gloss).  It works.  Yay.  However...
16:17:56 <chegibari> like "#math" for mathematics
16:18:04 <indigohedgehog> hello
16:18:08 <Peaker> Saizan: If newtype penetrating SECs were automatically defined, and imports were less of a pain, it would probably be worth the re-use
16:18:29 <indigohedgehog> Haskell tut seems nice
16:18:29 <rbarooah> I next wanted to try using Control.Parallel.Strategies to use a pmap to exploit the other cores of my iMac but GHC complains that it can't find the library.
16:18:56 <rbarooah> cabal says I have paralllel version 3.1.0.1 installed
16:19:00 <Saizan> Peaker: for me it's generally more interesting to understand something than packaging it up in the best possible way, so i'm not the one you should have this discussion with :)
16:19:49 <rbarooah> I installed from the latest Haskell Platform.  Does anyone have any pointers on how to debug this?
16:19:49 <monochrom> rbarooah: what does "ghc -v" say?
16:20:02 <Saizan> Peaker: though the two are not unrelated
16:20:23 <rbarooah> monochrom: the first line - Glasgow Haskell Compiler, Version 7.0.3, for Haskell 98, stage 2 booted by GHC version 6.12.3 - do you need more?
16:20:30 <monochrom> all of it
16:21:05 <rbarooah> http://pastebin.com/TNAD6T2a
16:22:00 <monochrom> then it should work. except "pmap" is not in the lib at all
16:22:28 <monochrom> @hoogle pmap
16:22:28 <lambdabot> No results found
16:22:35 <rbarooah> just importing Control.Parallel or control.Parallel.Strategies fails
16:23:04 <rbarooah> sorry my bad - I meant parMap
16:23:36 <Peaker> Saizan: ah. I'm not completely comfortable with Rank*Types, so I don't understand the differences between the above snippets very well
16:23:50 <Peaker> Saizan: So I may as well poke fun at the part I do understand better :-)
16:24:21 <Eelis> is there a pragma that one can annotate a function with to indicate its partiality, so that tools like HLint can warn about it?
16:25:45 <Saizan> Eelis: i don't think so
16:25:53 <Eelis> ok. would such a thing make sense?
16:26:03 <monochrom> just double-checking, what does "ghc-pkg list parallel" say?
16:26:53 <Saizan> Eelis: only if ghc also provided some easy way to access that info for installed libraries, i'd think
16:27:07 <Eelis> Saizan: right
16:27:38 <rbarooah> it says this: http://pastebin.com/37K3y7VE
16:27:53 <rbarooah> and doing the ghc-pkg recache does fix it
16:27:55 <rbarooah> so thanks!
16:28:06 <Eelis> Saizan: i wonder if HLint already does it for Prelude functions like head and tail, and if it just hard-codes those
16:28:21 <rbarooah> that would have taken me quite some time to find, I suspect
16:28:44 <monochrom> another case of cabal not being informative
16:28:50 <Saizan> Eelis: no idea, seems easy to check though :)
16:28:57 <Eelis> Saizan: doing so now :)
16:29:34 <rbarooah> cabals generally are usually secretive
16:29:45 <monochrom> ha ha
16:32:13 <Eelis> Saizan: doesn't look like it :(
16:34:21 <Saizan> sad, though suggestions are customizable
16:34:27 <Eelis> yeah, looking into it now
16:36:47 <sshc> < Saizan> sshc: if we had the Set monad, then Codensity Set wouldn't perform any pruning at intermediate steps, duplicating work — Pruning?
16:37:23 <Saizan> sshc: removing duplicated elements
16:40:03 <SmashLampjaw> chegibari: ##cs
16:40:52 <Saizan> e.g. (m >>= \_ -> return x) >>= expensive <- with Set you'll get only one call to expensive, while with Codensity Set you'll get as many as the elements of m
16:41:36 <Saizan> ans yet both will result in expensive x
16:41:45 <Saizan> *and yet
16:42:53 <Eelis> ugh, looks like HLint doesn't even do name lookup, so if you have a partial fromList in some module and a total fromList in another, HLint can't tell the difference..
16:44:27 <Saizan> yeah, it's quite simplistic on that front
16:45:29 <sshc> Oh, I see
16:46:41 <Saizan> though Set can't be an instance of Monad because of the Ord constraint, even if it is morally one
16:47:32 <tromp_> not because of the Eq constraint?
16:48:37 <Saizan> Data.Set requires Ord for better performance, but yeah, Eq would do
16:48:53 <sshc> Saizan: I understand how pruning can take place at each step.  But I don't see how that isn't possible with Codensity
16:49:04 <sshc> s/understand/\& now/
16:49:48 <Saizan> because Codensity reassociates every use of >>= to the right
16:50:31 <Saizan> so even if you write (m >>= f) >>= g you get (m >>= \x -> f x >>= g)
16:51:16 <Saizan> so the first >>= will do the pruning with the results of g
16:51:32 <Peaker> DList re-associates Monoids to the right.. maybe those should all get a similar name?
16:51:36 <Saizan> and while the second does it with the results of f, it does so for only one element of m at a type
16:51:44 <Saizan> s/type/time/
16:51:52 <Peaker> MonoidRAssoc, MonadRAssoc?
16:52:42 <sshc> Ah, I see; thanks.
16:52:48 <hpc> FlipEndo?
16:52:58 <hpc> it flips the associativity of an endomorphism
16:53:04 <Saizan> mh, actually, that description is good for Set
16:53:45 <hpc> newtype FlipEndo a = Flip {flipEndo :: c a a}
16:54:03 <danharaj> ...
16:54:06 <hpc> with a Category c constraint on the operators
16:54:15 <danharaj> the Tree defined in Data.Tree doesn't allow empty trees...
16:54:21 <sshc> Saizan: For monads that *do* benefit from right-associativity, why couldn't you write "m >>= (\x -> f x >>= g)" directly and still improve performance just as with 'Codensity'?
16:54:31 <sshc> (Such as the binary tree in the paper)
16:54:44 <sshc> (which I haven't fininshed reading)
16:54:55 <dolio> How about if we keep the established category theory name for codensity instead?
16:55:17 <Saizan> sshc: because Codensity does it even for applications that aren't so explicit in the source
16:55:28 <dolio> Instead of naming them after one particular thing they do.
16:55:46 <sshc> Saizan: To clarify: I *could* write that directly without codensity and still have the same improvements / efficiency, right?
16:56:20 <Saizan> sshc: yeah, but that might require writing most of your program in continuation passing style
16:56:54 <danharaj> why in heaven's name doesn't Data.Tree allow empty trees :[
16:57:11 <sshc> Saizan: THat seems to imply that I could write it directly like that but only in CPS (which "m >>= (\x -> f x >>= g)" isn't in)?
16:58:23 <dolio> @hoogle Tree
16:58:23 <lambdabot> module Data.Graph.Inductive.Tree
16:58:23 <lambdabot> module Data.Tree
16:58:23 <lambdabot> Data.Tree data Tree a
16:58:45 <Saizan> sshc: well, here we are only optimizing those two uses of >>=, but m,f and g could have more uses of it in them, which we left alone, while Codensity would handle those too
16:58:45 <sshc> dolio: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Tree.html
16:59:18 <sshc> Saizan: Could you clarify what specificaly you're referring to with "those two uses of >>="?
17:00:12 <Saizan> sshc: the two appearances of >>= in the source code of that expression
17:00:39 <dolio> danharaj: That'd totally ruin the elegant simplicity of the whole thing. :)
17:00:42 <sshc> Ah.  We're talking about the expression  "m >>= (\x -> f x >>= g)"
17:00:59 <dolio> Which is more important than being useful.
17:01:06 <Saizan> sshc: yeah, i took it out of your parens, sorry :)
17:03:16 <sshc> Thanks for your explanation.  I suspected Codensity was involved with right-associativity (it looked similar to the third monad law).  ACtually writing the code with the paper (and trying to write code myself before it is revealed in the paper) has been very helpful in understanding
17:04:45 <Saizan> mh, right associativity is not all of it
17:06:10 <Saizan> the other part is that return skips wrapping elements in constructors of your structure and just calls the continuation on them
17:09:01 <dolio> I believe it deforests repeated maps, too.
17:09:21 <danharaj> it does my laundry.
17:09:25 <Saizan> the asymptotic improvement comes from the reassociation though, which is what prevents retraversing the shared contexts as the tree gets bigger
17:09:38 <dolio> Because mapping is just composition with the continuation or something.
17:09:45 <Saizan> yeah
17:10:38 <dylukes> Quick question
17:10:46 <dylukes> In a function, values depend on values.
17:10:51 <dylukes> In a type constructor, types depend on types.
17:11:01 <dylukes> In a function with dependent typing, types depend on values...
17:11:09 <dylukes> where would values depend on types?
17:11:16 <dolio> Polymorphism.
17:11:17 <sshc> Saizan: Thanks, I now understand.  What do you mean by "mh"?
17:11:26 <dylukes> dolio: So, type classes?
17:11:30 <Axman6> yeah, i was going to say in a class
17:11:33 <dolio> All polymorphism.
17:11:58 <dolio> In parametric polymorphism, terms take type parameters.
17:12:07 <dolio> Haskell just hides it.
17:12:17 <kim_bruning> before I started learning haskell, I thought I could program :-P
17:12:19 * kim_bruning ducks
17:12:47 <Saizan> sshc: that's just onomatopeic :) like "rethinking about it .."
17:13:20 <sshc> Ah
17:13:23 <dolio> dylukes: In a Church-style calculus, you write it out explicitly.
17:13:37 <dylukes> mmk
17:13:58 <ddarius> dolio: I wouldn't associate it with Church/Curry style.  Haskell is a Church-style lambda calculus.
17:13:59 <dolio> So (forall a. a -> a) is the type of terms that look like: /\a -> \(x : a) -> x
17:14:04 <kim_bruning> I'll be back tomorrow, I guess
17:14:07 <kim_bruning> night all!
17:14:26 <Axman6> we barely knew ye
17:15:00 <dolio> ddarius: I'm not seeing that.
17:16:07 <ddarius> dolio: A Church-style lambda calculus is one where the terms have no meaning without the types.  A Curry-style lambda calculus is one where the types classify pre-existing terms.  Haskell programs have no meaning without the types.  It doesn't matter that the types aren't explicit.
17:22:13 <dolio> I suppose I concede, then. Although Haskell is very close to being Curry-style.
17:22:18 <dolio> Potentially, at least.
17:22:41 <ddarius> dolio: If you take out type classes, I'm pretty sure it could be considered Curry-style.
17:22:48 <dolio> Yeah.
17:22:59 <hpc> oh, i see how it works
17:23:23 <hpc> neat
17:23:27 <hpc> themoreyouknow.jpg
17:27:05 <danharaj> Nothing like a couple of shots to grease the cognitive wheels.
17:31:52 <Veinor> Okay, here's a question.
17:32:08 <Veinor> Suppose I have newtype Warrior = Warrior { test :: Warrior -> Bool }
17:32:12 <Veinor> what's the cardinality if the set of warriors?
17:32:15 <Veinor> *of
17:32:32 <ddarius> What set?  Types aren't sets.
17:32:40 <Veinor> the set of possible warriors
17:32:48 <mm_freak> Veinor: it's a class, not a set
17:32:56 <ddarius> N, there are only countably many programs with that type.
17:33:10 <Veinor> oh yeah
17:33:13 <mm_freak> ddarius: sure?
17:33:19 <danharaj> Isn't it just 1?
17:33:20 <Veinor> there are only countably many finite programs
17:33:23 <ksf> pretty-printing ascii tables with automatical column sizes?
17:33:27 <danharaj> I can't name an element other than undefined
17:33:31 <mm_freak> danharaj: two at least
17:33:35 <Veinor> danharaj: const False, const True
17:33:40 <danharaj> ah touche
17:33:42 <mm_freak> three in haskell
17:33:47 <mm_freak> or four, actually
17:33:54 <dolio> There are others.
17:34:05 <Veinor> and then you can construct more starting by evaluating test w (const False) and test w (const True)
17:34:12 <Veinor> so there's definitely infinitely many warriors
17:34:23 <mm_freak> well, there is an unlimited number of them, if you allow bottom
17:34:39 <Veinor> even ignoring bottom
17:35:05 <mm_freak> hmm…  when i think about it, ignoring bottom i'd say there are only two
17:35:12 <mm_freak> const True and const False
17:35:14 <hpc> that looks sort of like the Cantor definition from seemingly impossible functional programs
17:35:40 <mm_freak> oh, no
17:35:47 <Veinor> what about the warrior w such that test w w' is true if test w' w' is true, and false otherwise
17:35:53 <mm_freak> wah, i'm confused
17:35:58 <Veinor> exactly!
17:36:16 <Veinor> it's a very confusing problem
17:36:33 <hpc> well, let true = Warrior (const True)
17:37:03 <Veinor> sure
17:37:06 <hpc> and let not = Warrior (\w -> if test w then False else True)
17:37:21 <hpc> now test not true = False
17:37:40 <hpc> so that's a third value we can give our Warrior
17:37:53 <Veinor> i think that given a list of warriors you can always construct a warrior not equal to any of them through some kind of diagonalization
17:37:54 <hpc> and you can keep composing tests
17:38:18 <Veinor> but i'm not sure
17:39:17 <Veinor> the original context of this was a game someone gave me! the challenge is to design a warrior w such that test w w == True and test w w' == False for all w' that are not w
17:39:23 <dolio> Warrior can be used to write bottom with type Bool.
17:39:42 <Eduard_Munteanu> Well, when are two functions equal, if I may ask?
17:39:56 <Veinor> (in other words, find a w such that test w w' == True if and only if there does not exist an x such that test w x /= test w' x
17:40:09 <dolio> They are equal when they agree on every point, usually.
17:40:14 <Eduard_Munteanu> Or two warriors, equivalently.
17:40:19 * monochrom finds a bug in the haskell report! both 98 and 2010
17:40:36 <Veinor> yeah, they're equal if they agree everywhere
17:41:32 <mm_freak> well
17:41:39 <jmcarthur> a->Bool is a model for sets. this probably has a well-explored set theoretic explanation somewhere
17:42:18 <ddarius> monochrom: Depending on your definition of "bug" there are plenty.
17:42:24 <monochrom> ok hehe
17:42:42 <mm_freak> i think, disregarding bottom, there are four functions:  const True, const False, one flipping the result of its argument function and one returning it verbatim
17:42:45 <dolio> I don't think Warrior can be given a set-theoretic interpretation.
17:42:45 <Eduard_Munteanu> Obviously in that case there are only 4 warriors, without taking undefined stuff into account.
17:42:50 <hpc> there's at least an isomorphism between contains and ($)
17:43:01 <hpc> where contains :: Set a -> a -> Bool
17:43:41 <jmcarthur> dolio: because of _|_ or for some other reason? (i don't have a great grasp on set theory, honestly)
17:43:54 <mm_freak> on the other hand, it has to feed its argument with a value
17:44:12 <dolio> jmcarthur: Because if you try, you are attempting to construct a set that is isomorphic to its own powerset, essentially.
17:44:22 <monochrom> section 4.4.1 has a polymorphic recursion example. the example can be type-checked with or without type sig, but the type sig can turn on polymorphic recursion and be a more general type. ok, without the type sig though, the inferred type should be (Num a) => T Int -> a instead of T Int -> Int
17:44:30 <hpc> Veinor: to solve the original problem
17:45:01 <dolio> Most set theories don't have sets like that.
17:45:02 <Eduard_Munteanu> @where report
17:45:02 <lambdabot> http://www.haskell.org/onlinereport/
17:45:57 <Veinor> well
17:46:04 <Veinor> there's countably many warriors because there's only countably many finite programs ;)
17:46:20 <hpc> hmm, nvm, not thinking straight
17:46:41 <mm_freak> Veinor: we haven't established that there are infinitely many of them
17:47:03 <mm_freak> i'd rather say, if you disregard bottom, there are only finitely many
17:47:05 <Veinor> finite sets are countable too!
17:47:14 <mm_freak> ah, sorry
17:47:16 <hpc> 1,2,3,4
17:47:18 <hpc> there, counted :P
17:47:27 <jmcarthur> dolio: ah, right
17:47:28 <Veinor> i'm still pretty sure there's infintiely many, though
17:48:03 <mm_freak> i think there are more than four warriors:  const True, const False and for each possible warrior one function that passes that warrior to its argument and returns its result flipped or unflipped
17:48:32 <mm_freak> i think at least five
17:48:33 <Eduard_Munteanu> monochrom: um, why the Num constraint?
17:48:41 <hpc> mm_freak: name a fifth?
17:48:42 <mm_freak> because a warrior can pass itself to the argument warrior
17:48:58 <hpc> oh!
17:49:09 <hpc> mm_freak: wait, no
17:49:15 <hpc> mm_freak: because that's still const something
17:49:25 <hpc> er
17:49:29 <mm_freak> hpc: the latter two warriors are not constant
17:49:32 <mm_freak> they depend on the argument
17:49:41 <hpc> no, i see now what you mean
17:49:43 <parcs> .
17:49:48 <monochrom> "f x == 1" forces f :: (Num a) => ? -> a
17:49:54 <Veinor> there's also that for any given list of warriors ws, you can construct a warrior w' = Warrior (\w -> all (test w) ws)
17:50:01 <hpc> let x = Warrior (\y -> test (test y x)))
17:50:11 <monochrom> but not to the point of committing a=Int
17:50:22 <mm_freak> Veinor: that would prove the infinite number of warriors
17:50:29 <Eduard_Munteanu> Oh, right, I only saw the '=='...
17:50:37 <Veinor> yeah
17:50:42 <mm_freak> although, no
17:50:56 <co_dh> greeting, what theorem prover or assistant are you guys using ?
17:50:58 <mm_freak> we haven't established that such a list can contain infinitely many different items
17:51:03 <mm_freak> co_dh: haskell
17:51:06 <hpc> this is looking more and more like seemingly impossible functional programs
17:51:13 <Veinor> hpc: it is, isn't it
17:51:13 <Eduard_Munteanu> co_dh: Agda?
17:51:15 <hpc> haskell isn't much of a theorem proover
17:51:43 <mm_freak> hpc: the five i have mentioned are well possible without bottom
17:51:58 <hpc> mm_freak: agreed, and i think i see how there are more
17:52:01 <Eduard_Munteanu> mm_freak: how could those be pointwise different?
17:52:07 <co_dh> there are not enough document on Agda, which make it  hard to learn theorem prover by Agda.
17:52:11 <mm_freak> hpc: haskell proves enough for me…  because i don't prove theorems, only programs =)
17:52:20 <hpc> hehe
17:52:37 <mm_freak> Eduard_Munteanu: you wouldn't argue that const True and const False are different functions, would you?
17:52:54 <Eduard_Munteanu> co_dh: yeah, docs could be better, though you could work around it by asking in #agda
17:53:01 <Eduard_Munteanu> You could have a look at Coq, maybe.
17:53:25 <Eduard_Munteanu> mm_freak: yeah, those are different.
17:53:43 <co_dh> Eduard_Munteanu:  thanks :)
17:53:48 <mm_freak> Eduard_Munteanu: and you also wouldn't argue that the function, which passes any possible warrior to its argument (so at least one of two) and returns its result verbatim or flipped are different, would you?
17:54:38 <mm_freak> Eduard_Munteanu: it's also easy to see that the latter functions are not constant, because they behave differently with the arguments const True and const False
17:54:40 <Eduard_Munteanu> mm_freak: well you simply can't do that and end up with more than 4 possible functions, unless you allow less than fully-defined values
17:55:00 <mm_freak> why?  you can pass const True to const True
17:55:14 <hpc> in fact, you almost have to
17:55:20 <mm_freak> one function will take the True result and return it
17:55:23 <hpc> you can't get True out of const True without another Warrior
17:55:27 <mm_freak> the other will flip it and return False
17:55:41 <mm_freak> the former would return False, if its argument is const False, the other would return True
17:55:52 <mm_freak> that's fully defined
17:56:52 <dolio> There are more than 4.
17:56:55 <mm_freak> const True does not depend on its argument, but \w -> w (const True) does
17:57:20 <robinhoode> <== Not a big fan of Coq. The programs I see written in it require you to know too much about the internals of Coq rather than about the math it's describing.
17:57:31 <hpc> mm_freak: i see church numerals in there!
17:57:37 <mm_freak> and such a function can also pass itself to its warrior, although i don't think that makes a difference, because as of now we have only constant warriors or ones, which take constant warriors
17:57:51 <hpc> const True = nil, \w -> w x = x+1
17:58:30 <dolio> mm_freak: One might want to disallow things that refer to themselves directly, for the sake of argument.
17:58:33 <robinhoode> I've had similar problems with Agda, particularly with refl and cong, but once I got past those two, I had little trouble reading whatever other Agda programs I found.
17:59:06 <hpc> dolio: only if we don't want to argue reality :P
17:59:56 <dolio> hpc: Depends what reality you want to argue.
18:00:31 <dolio> A directly recursive Warrior definition wouldn't be allowed for an inductive type in Agda, assuming it allowed Warrior at all.
18:01:12 <Eduard_Munteanu> robinhoode: yeah, it's quite readable, maybe that mixfix stuff combined with Unicode is making things look nicer
18:01:37 <mm_freak> dolio: i'm just disallowing bottom…  i'm not restricting to agda's type system (though i don't know if there is a difference)
18:02:00 <dolio> mm_freak: If you allow Warrior, the ship has sailed on bottom.
18:02:07 <Eduard_Munteanu> There's a whole range of bottoms :)
18:02:18 <dolio> mm_freak: For booleans, at least.
18:02:28 <hpc> you can't get a concrete value out of a Warrior WITHOUT bottom
18:02:44 <dolio> let v = W (\w -> test w w) in test v v
18:02:48 <hpc> even if you could make the thing itself exist
18:02:57 <dolio> That's the looping lambda term, disguised a little.
18:03:00 <mm_freak> dolio: true, but i'm trying to find fully defined values of type Warrior
18:03:25 <mm_freak> under the premise that only fully defined values are passed to its function
18:03:47 <mm_freak> and i don't think there are more than four
18:03:57 <dolio> Anyhow, W (\w -> test w w) is neither bottom nor constant, nor just flipping the result of its argument.
18:04:03 <Eduard_Munteanu> let v = Warrior $ const True in warrior v v
18:04:30 <mm_freak> out of my head i can't think of how a function passing a constant function to its argument can be any different to a function, which passes itself
18:06:22 <mm_freak> dolio: what's 'test'?
18:06:44 <ddarius> test :: Warrior -> Warrior -> Bool, it's the unwrapper.
18:06:48 <mm_freak> hpc: isn't True a concrete value?  you get it out of const True
18:06:55 <Eduard_Munteanu> Uh, my bad... newtype Warrior = Warrior { test :: Warrior -> Bool }
18:07:01 <Eduard_Munteanu> warrior = test in my case
18:07:42 <hpc> mm_freak: but what do you pass to const?
18:07:52 <mm_freak> hpc: const True
18:07:58 <mm_freak> Warrior (const True)
18:08:00 <Eduard_Munteanu> So yeah, I didn't mean 4 values earlier.
18:08:09 <hpc> so const True is a concrete value if const True is a concrete value?
18:08:10 <hpc> :P
18:08:36 <mm_freak> > (const True) (const True)
18:08:37 <lambdabot>   True
18:08:47 <mm_freak> isn't that concrete?
18:09:01 <hpc> indeed
18:09:02 <Eduard_Munteanu> hpc: let v = Warrior $ const True in test v v    -- seems entirely fine to me
18:09:36 <ddarius> "Among the most sought-after Roman seasonings was laserpicium, or laser, the extract of a plant that the Romans loved so much, they ate it to extinction."
18:09:41 <Eduard_Munteanu> As a matter of fact, wouldn't it be one of two possible fully defined values?
18:09:42 <mm_freak> dolio: i'm not sure if your function is different from what has already been given
18:09:46 * hpc was just guiding him to finding a fully defined Warrior value
18:11:11 <mm_freak> i guess to get more insight, you need to go ahead and write the code
18:11:21 * Eduard_Munteanu ponders making a Hungry Warrior to make matters worse :)
18:11:44 <mm_freak> uh, now we have a * -> *
18:12:32 <mm_freak> enough for today…  g'night =)
18:12:36 <hpc> ta
18:14:47 <Eduard_Munteanu> Wait so what's the resolution here? I can't see more than 2 fully-defined values...
18:15:15 <Eduard_Munteanu> I recall dolio arguing for more than 4 :/
18:15:38 <hpc> wait, do we mean fully-defined as in concrete or fully-defined as in total?
18:16:08 <hpc> there are two warriors containing total functions, and countably infinite concrete warriors
18:16:22 <Eduard_Munteanu> Hrm, what would you mean by concrete?
18:16:23 <ddarius> Eduard_Munteanu: \w -> not (test w (const True)) is one that has already been mentioned.
18:17:31 <Eduard_Munteanu> Ah, but that sort of stuff is undefined somewhere down the road or equal to either const True or const False, isn't it?
18:17:47 <ddarius> Where is undefined in that expression?
18:18:26 <Eduard_Munteanu> Not specifically there but doing 'test w' isn't exactly total, unless you can prove it.
18:19:52 <hpc> Eduard_Munteanu: we can say that it is total for all non-bottom values of w
18:20:36 <Eduard_Munteanu> It could end up undefined. As a matter of fact, isn't this some sort of parametricity result too? Anything a -> Bool would have to be either const True, const False or something equal to one of the previous.
18:20:55 <ddarius> Eduard_Munteanu: It doesn't really make much sense to talk about that type in a total language unless you can define some meaning for the type.  Note that it isn't (naively) an initial algebra or terminal coalgebra and it's blatantly not strictly positive or even positive at all.
18:22:02 <ddarius> Eduard_Munteanu: We know that a Warrior is a boolean valued function, and thus can be applied, we don't know anything about a.
18:24:22 <ddarius> Eduard_Munteanu: Incidentally, by your logic, id is not total.
18:24:37 <ddarius> Or any strict function for that matter.
18:25:44 <Eduard_Munteanu> Indeed it's not straightforward (or possible?) to write it in Agda, hm.
18:26:16 <ddarius> Eduard_Munteanu: It shouldn't be possible to write in Agda as, as dolio demonstrated, you can define bottom with it.
18:26:32 <ddarius> At least, bottom :: Bool.
18:32:26 <aninhumer> Is there a standard way to compose predicates? I've been using "(<&>) a b c = a c && b c" but this seems like something that might be in a library somewhere?
18:33:26 <ddarius> liftA2 (&&)
18:33:29 <Draconx> aninhumer, that's just liftM2 (&&)
18:36:16 <aninhumer> That's a nicer way to define it, but it seems like something that could benefit from a standard alias?
18:37:13 <ddarius> Have your boolean functions return All or Any and then it's just mappend.
18:39:29 <aninhumer> That assumes I always want to compose them as any or all
18:40:54 <ddarius> Suffice to say, this doesn't actually come up too much, though RWH defines a set of combinators similar to the one you mentioned.
18:41:11 <sshc> ddarius: Really?  Where?
18:41:25 <sshc> I've read it and don't recall seeing such combinators
18:41:59 <sshc> Saizan: Actually, according to the paper (Asymptotic Improvement of Computations over Free Monads), "return" isn't a special part of Codensity, because "liftC (return a)" = return a, and the paper provides a proof for that.  (Am I right?)
18:44:19 <Saizan> Just x and (\k -> k x) are not the same, yet their are both return
18:46:46 <ddarius> sshc: http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html
18:46:54 <AardMark> wazzzuuuuuppp
18:49:04 <aninhumer> My actual example is Mahjong tiles, but I suppose a more relatable equivalent is something like "isRed = isHearts <|> isDiamonds" for a card type
18:49:24 <sshc> Saizan: But when you lower it, or apply it to bind, it makes no difference, right?
18:49:49 <sshc> I don't see how Codensity's return is significant
18:51:32 <jmcarthur> what kind of significance is it claimed to have? who said it was significant?
18:53:08 <AnAdorableNick> INteresting (RWH)
18:53:25 <AnAdorableNick> 00:13:03 < Saizan> mh, right associativity is not all of it
18:53:25 <AnAdorableNick> 00:14:28 < Saizan> the other part is that return skips wrapping elements in constructors of your structure and just calls the continuation on them
18:54:43 <jmcarthur> ah!
18:55:03 <sshc> ^ That.
18:55:16 <aninhumer> Also, is there a way to autocreate is<constructor> predicates for ADTs? or some other way I should be doing that?
18:56:48 <jmcarthur> sshc: there's no call to the inner monad's return in Codensity's return
18:57:34 <jmcarthur> sshc: that means that the usual overhead for whatever effect the monad has is absent in that case
18:58:20 <sshc> Oh, so the significance is in effeciency, and repeatedly unwrapping and wrapping constructors?
18:58:39 <jmcarthur> depending on the monad the wrapping and unwrapping could be more expensive than just a data constructor
18:59:03 <jmcarthur> although...
18:59:10 <jmcarthur> for free monads i guess not so much
18:59:48 <sshc> What exactly is the definition of "free monad"?
19:00:16 <dankna> ten cents or cheaper
19:00:21 <dankna> (due to inflation)
19:00:30 <dankna> sorry, tired ^^'
19:00:55 <jmcarthur> it's a monad generated from a functor. it's sometimes written in haskell as:   newtype Free f a = Free (Either a (f (Free f a)))
19:01:08 <dankna> fascinating
19:01:10 <jmcarthur> sshc: ^^ as long as f is a functor, that forms a monad
19:02:16 <Axman6> aninhumer: I'd just use pattern matching
19:02:39 <sshc> I'm still reading the paper, and just recently came across that definition.  Except it was "data Free f a = Return a | Wrap (f (Free f a))"
19:02:48 <jmcarthur> yeah
19:03:00 <jmcarthur> and some people call the second constructor Roll instead, too
19:03:23 <sshc> Huh.  Can any functor work?
19:03:25 <jmcarthur> yes
19:03:43 * hackagebot swish 0.3.1.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.3.1.1 (DouglasBurke)
19:04:02 <jmcarthur> a free monad is usually tree-like, with values at the leaves
19:04:32 <jmcarthur> a cofree comonad is usually tree-like as well, except that the values are at the branches
19:04:49 <jmcarthur> data Cofree f a = Cofree a (f (Cofree f a))
19:05:49 <sshc> Comonad?
19:06:08 <jmcarthur> yep
19:06:11 <jmcarthur> dual to monad
19:06:17 * edwardk perks up.
19:06:28 <jmcarthur> edwardk: we're talking about free monads, mainly
19:06:33 <jmcarthur> and i mentioned cofree comonads
19:06:40 <edwardk> ah. well, i have a package for those too ;)
19:06:42 <jmcarthur> edwardk: also codensity
19:06:48 <edwardk> and that ;)
19:06:55 <jmcarthur> actually codensity is the main topic
19:07:04 * sshc 's not sure what a comonad is
19:07:13 <jmcarthur> edwardk: where did codensity get shuffled to?
19:07:21 <edwardk> kan-extensions
19:07:24 <jmcarthur> sshc: edwardk can help!
19:07:31 <jmcarthur> edwardk: ah! i forgot that package existed
19:07:34 <edwardk> http://hackage.haskell.org/packages/archive/comonad/1.1.0/doc/html/Control-Comonad.html defines a comonad
19:07:43 <jmcarthur> i wish i could look at all the packages on hackage by a particular author
19:08:01 <edwardk> monads have 'return' and bind aka (>>=), comonads have 'extract' and 'extend'
19:08:07 <jmcarthur> or a particular maintainer
19:08:46 <edwardk> jmcarthur: yeah its a bit tricky to do. i just pull the cabal package list from time to time, and then grep and script my way to that info
19:09:09 <edwardk> http://hackage.haskell.org/packages/archive/free/0.2.1/doc/html/Control-Monad-Free.html has free monads
19:09:19 <jmcarthur> sshc: if your intution for monads is that you can always put things in but not take things out (except with special functions just for your particular type), then an intuition for comonads might be that you can always take things about but not put things in (again, except with special functions particular to the type)
19:09:38 <edwardk> http://hackage.haskell.org/packages/archive/kan-extensions/0.2.1/doc/html/Control-Monad-Codensity.html is the codensity monad
19:09:40 <jmcarthur> *take things out
19:10:01 <jmcarthur> huh, i never saw the free package
19:10:19 <edwardk> i don't use it much. just to define futumorphisms in the recursion-schemes package
19:10:40 <edwardk> i should probably make histomorphisms use cofree from that package rather than the f-branching stream from streams as well
19:10:46 <edwardk> just for symmetry
19:10:58 <jmcarthur> edwardk: technically you have Cofree in a couple packages, don't you? isn't stream in comonad-transformers the same thing?
19:11:15 <edwardk> the one on comonad-transformers is a transformer variant of it
19:11:19 <edwardk> bit heavier
19:11:20 <jmcarthur> oh right
19:11:49 <jmcarthur> hmm... is there a transformer variant of Free?
19:12:12 <edwardk> sure
19:12:30 <edwardk> replace the Either in the construction with EitherT iirc.
19:13:26 <edwardk> the transformers are particularly non-interesting to me
19:13:47 <edwardk> i just needed it to be a transformer to fit it into the comonad-transformers package's mandate ;)
19:14:51 <jmcarthur> i was using the transformerness of it briefly, but then i redesigned the data structure i was using anyway
19:15:52 <edwardk> i wanted the transformer version to highlight that you can compose comonads with transformers just like you can with monads. adding an environment, state, multiple-answers, etc. piecemeal just like with a monad
19:16:06 <danharaj> when do transformers commute?
19:16:30 <edwardk> danharaj: good question
19:16:41 <edwardk> they exist because of some kind of distributive law in the first place
19:18:16 <edwardk> you may have one that sandwiches a comonad in an adjunction, or which uses a distributive law to move one over the other. either pushing it in or out. one typically uses the preservation of limits from being a right adjoint or of colimits from a being a left adjoint.
19:18:25 <jmcarthur> edwardk: btw, do you have or know of any packages that have type classes for commutative monoids and/or commutative monads?
19:18:28 <edwardk> there are other forms, but those are the most common
19:18:41 <edwardk> nah
19:18:50 <jmcarthur> i'm doing some stuff with bags lately
19:18:56 <jmcarthur> alright, guess i'll make my own
19:19:02 <edwardk> fair nuff
19:19:33 <edwardk> i kicked around putting one together at one point, but i didn't have enough of a use case to guide a decent api design
19:19:39 <jmcarthur> ah
19:20:08 <edwardk> i'd like to have them for reducer purposes if nothing ele
19:20:10 <edwardk> er else
19:20:28 <edwardk> i'm currently updating the monoids package (having finally bit the bullet and started reconstructing the repository)
19:20:29 <jmcarthur> mine is for some frp stuff. using bags instead of lists for simultaneous events
19:20:53 <edwardk> so if you have ideas for how to integrate a commutativity class, i'm all ears
19:21:00 <edwardk> ah
19:21:29 <edwardk> sclv managed to make a pretty convincing argument to me against the existence of simultaneous events, wish i could recall the exact nature of it
19:21:54 <jmcarthur> oh i also don't believe in the existence of simultaneous events, but computers can't work with real numbers anyway :P
19:22:07 <edwardk> *nods*
19:22:16 <edwardk> i wish you luck chasing the grail ;)
19:22:35 <jmcarthur> my model also doesn't support relativity ;)
19:22:41 <edwardk> bah
19:22:57 <Philippa_> jmcarthur: so it's no good for implementing a GPS competitor?
19:23:03 <jmcarthur> heh
19:23:06 <edwardk> i keep advocating for functional reactive relativity, but nobody wants to parameterize their FRP engine over a causality domain
19:23:39 <edwardk> s/causality/causal/
19:23:50 <jmcarthur> my time domain is polymorphic. maybe i won't make any assumptions that rule that out
19:24:08 <edwardk> the key is allowing for incomparable times
19:24:20 <jmcarthur> nope, i'm already breaking that one
19:24:36 <jmcarthur> actually, might be okay with behaviors, but certainly broken for events
19:24:50 <edwardk> yeah the list models tend to rule that out pretty fast
19:25:02 <Philippa_> is it 'globally' broken for events?
19:25:05 <jmcarthur> it's not my model in this case
19:25:08 <jmcarthur> it's just my implementation
19:25:18 <edwardk> *nods*
19:25:30 <edwardk> gah, now i want to go back and hack on reactor
19:25:39 <Philippa_> you can probably get by with the analogue of 'you need to pick a frame from within which to compare', for example?
19:26:59 <jmcarthur> Philippa_: it's hard for me to escape notions of the computer itself being the observer
19:27:33 <Philippa_> mmm. Well, it's hard to without escaping the notion of there being a /the/ computer, yeah
19:28:12 <edwardk> jmcarthur: the issue of course is you have lots of cores working, so you have lots of observers in a well-designed model ;)
19:28:24 <jmcarthur> haha
19:29:10 <edwardk> and once you distribute it, you have even more observers, with even more loosely correlated notions of time
19:29:55 <jmcarthur> i do find it interesting that the "next step" in taking advantage of multicore is probably to allow different cores to have different observations without introducing observable nondeterminism
19:30:27 <jmcarthur> well
19:30:36 <jmcarthur> maybe some observable nondeterminism is inevitable though?
19:30:45 <edwardk> i'll confess i've stopped modeling my thinking on frp. i've been playing around a lot with hellerstein's various message passing datalog-alikes and that approach, because then i can always know that i'm going to terminate within a given timestep and the message passing delay/causality is built into the model, and i can reason about where my particular problem is going to run into race conditions, non-determinism, etc.
19:30:52 <edwardk> that probably overflowed my line length limit
19:30:59 <jmcarthur> i got to "etc."
19:31:06 <edwardk> oh good. i didn't =)
19:31:18 <Philippa_> get a client that overflows into new lines :p
19:31:20 <Philippa_> but yeah
19:31:45 <edwardk> requires effort ;)
19:31:48 <Philippa_> jmcarthur: as scale goes up, yeah, it is. Controlling it and deciding where it's allowed to creep into our semantic models is important though
19:32:20 <edwardk> jmcarthur: note the datalog approach above can actually be checked for non-determinism
19:32:23 <jmcarthur> Philippa_: is suppose this may already be a fairly well-studied thing in distributed systems
19:32:39 <edwardk> that is something i've yet to figure out how to do with something more functional
19:33:04 <danharaj> I think I told jmcarthur the other day that my idea of frp is a discrete signal of samples.
19:33:21 <danharaj> where time is also a discrete signal of samples.
19:33:24 <Philippa_> jmcarthur: yeah, and there's a fairly fundamental "you're screwed" theorem, though lots of tradeoffs to be made in which way you're screwed and whether it matters
19:34:05 <edwardk> jmcarthur: for reference http://boom.cs.berkeley.edu/ should have lots of links to papers on the approach i keep ranting about ;)
19:34:37 <jmcarthur> edwardk: thanks
19:38:35 <KirinDave> Hummm
19:39:18 <jmcarthur> danharaj: "I’ve noticed that some folks want programming models to serve the machine, by capturing what the machine can do. I’m more interested in machines as lenses for ideas, i.e., the role of the machine for me is to display ideas for me to observe. I want to express those ideas in a precise & simple way, thus the appeal of denotational design."
19:40:00 <KirinDave> Is there a way to ease the part of setting up cabal where you have to specify all the packages you need?
19:40:02 <jmcarthur> danharaj: probably a decent summary of my PoV in that conversation we had a few days ago
19:42:16 <jmcarthur> oh that was quoting conal, btw. forgot to cite
19:43:53 <edwardk> personally, i find that a beautiful denotational model for which i can't find a decent operational interpretation doesn't do me a lot of good.
19:45:21 <dmwit> I can't believe zombocom is still up.
19:45:55 <danharaj> I still don't believe in calling things denotational models if they are not isomorphic to programs.
19:46:17 <jmcarthur> heh, we have already established that we different notions of what a program is, though
19:46:20 <jmcarthur> *we have
19:46:41 <danharaj> It's a lambda term of course :p
19:49:42 <jmcarthur> danharaj: what do you think of rasterization of vector graphics for display on your computer screen? does that mean the vector denotation of the image is not really a denotation at all?
19:51:30 <Philippa_> edwardk: well, it can be a starting point. In that you can start figuring out ways to hack bits out of it/add limitations on to get an operational model
19:51:47 <Philippa_> apparently if you start thinking that way round it's wrongthink though
19:52:07 <danharaj> jmcarthur: rasterize :: VectorGraphic -> Bitmap
19:52:43 <edwardk> *shrug* i don't mind having a go at it from the other perspective, but i do like to come back to it from an operational perspective every once in a while, if only as a check to make sure i'm not wasting my time
19:52:50 <jmcarthur> danharaj: rasterize :: ContinuousFRP -> DiscreteFRP  ;)
19:53:16 <danharaj> jmcarthur: Yes. And your choice of rasterization function is absolutely critical. That's why I dislike the idea of a library doing it fro me.
19:53:32 <jmcarthur> ah
19:53:42 <danharaj> I can rasterize a vector graphic in many ways.
19:54:58 <jmcarthur> danharaj: but would you say that the rasterize function changes the denotation of VectorGraphic?
19:55:05 <jmcarthur> *the choice of rasterize function
19:55:28 <danharaj> It would not.
19:56:07 <jmcarthur> i think we just found common ground
19:56:50 <danharaj> A bit.
19:56:59 <jmcarthur> danharaj: so your argument is that you want the rasterize function to *have* a denotation
19:57:28 <jmcarthur> whereas i am choosing to ignore it (for the time being, at least) for the sake of being able to focus on the continuous-time semantics
19:58:15 <jmcarthur> or continuous-space, depending on which example we're talking about
19:58:56 <danharaj> My problem is that your 'continuous-time semantics' doesn't describe a program until you choose your 'rasterize'.
19:59:14 <danharaj> It's incomplete. I can't run it. The same way I can't look at a vector graphic until I know how to rasterize it.
19:59:20 <Philippa_> danharaj: is your problem essentially that there's no denotationally unique solution?
19:59:21 <jmcarthur> its interpretation, to me, is its denotation as a mathematical object, not its projection to a bitmap
19:59:34 <jmcarthur> in that sense, it is a program
19:59:43 <jmcarthur> it's an expression that describes the object i want
19:59:50 <danharaj> Your object is not computable.
20:00:14 <jmcarthur> computability doesn't just mean you can make a bitmap out of it
20:00:26 <augur> aristid: http://wellnowwhat.net/linguistics/paper.full.pdf
20:00:32 <Philippa_> danharaj: that's an awfully strong claim
20:01:07 <danharaj> Philippa_: In many continuous models of FRP, you can define behaviors that require perfectly accurate comparison of real numbers.
20:01:15 <Philippa_> (being able to compute relevant properties of a specified point in the relevant space would be enough to make it 'computable', for example)
20:03:12 <jmcarthur> i like what luqui said about 10 days ago on continuous time
20:03:15 <jmcarthur> "What's interesting to me is that the notion of a continuous function is all about finite limitations. The definition of continuity for a function is: for any finite amount of information you want out, there exists a finite amount of information you have to put in. So if you are working with continuous time, all you need is continuous functions to go with it and it is perfectly natural."
20:03:22 <Philippa_> danharaj: yeah, okay, if you were silly enough to put full-generality reals in there to start with then you get what you deserve
20:03:51 <jmcarthur> the computer can't even obtain a real number that it can't compute, can it?
20:04:31 <c_wraith> well.  in some symbolic form, it can.  There are a few well-defined but non-computable reals.
20:04:57 <danharaj> jmcarthur: no, but for example I can tell an event to fire whenever a signal is equal to 0.
20:05:01 <jmcarthur> c_wraith: does that symbolic form permit equality tests? i suppose not necessarily
20:08:28 <jmcarthur> danharaj: and i can do the same thing by discretizing my behavior (in a semantically well-defined way) if i really wanted to do it that way
20:08:36 <jmcarthur> that doesn't mean i should just abandon continuous time though
20:08:47 <danharaj> I don't see the utility in continuous time
20:08:48 <jmcarthur> and there are specific cases where i don't have to do that either
20:09:09 <jmcarthur> http://conal.net/blog/posts/why-program-with-continuous-time/
20:09:28 <edwardk> preflex: xseen shapr
20:09:28 <preflex>  shapr was last seen on freenode/#haskell-blah 2 days, 7 hours, 28 minutes and 31 seconds ago, saying: hahaha
20:09:34 <Philippa_> danharaj: getting to parameterise on how I do the sampling/discretisation seems a big win to me
20:11:58 <jmcarthur> "Another name for 'continuous' is 'resolution-independent', and thus able to be transformed in time and space with ease and without propagating and amplifying sampling artifacts."
20:12:41 <danharaj> I don't have a response to that just now, but I will eventually.
20:13:23 <boz> Hello there!  I have a Monad M and a list [a -> M a] and travel tru it using 'foldr (>
20:13:45 <boz> foldr (>=>) return list
20:14:24 <boz> I suspect there is a standart command for 'foldr (>=>) return' but I couldn't find oone
20:14:31 <jmcarthur> i don't think there is one
20:14:44 <boz> thanks
20:14:52 <jmcarthur> hmm
20:14:56 <boz> do you have a good name for it then
20:14:58 <danharaj> your solution is short and sweet.
20:15:07 <danharaj> do you need to name it?
20:15:18 <jmcarthur> well, it's nice and generic ^_^
20:15:51 <boz> I would like to.  I want to present some people the code and want to say something like
20:16:13 <boz> look, how nice the code tells exactly what it does!
20:16:50 <boz> My first guess was to name it 'sequence' but the name is already taken
20:19:11 <jmcarthur> boz: if there is a newtype wrapper for turning categories into monoids then you could use that and Kleisli, then the function is just Data.Foldable.fold  ^_^
20:19:46 <jmcarthur> but you'd have newtype crap to deal with
20:19:48 <sshc> jmcarthur: Can you confirm whether this is correct for "instance (Functor t) => Functor (Free t)"?: {fmap f (Return a) = Return (f a); fmap f (Roll t)   = Roll (fmap (fmap f) t)}
20:20:06 <edwardk> sadly GEndo is pretty scary to people ;)
20:20:18 <boz> I also thought about something with Kleisli but coudn't find the right thing
20:20:35 <jmcarthur> sshc: data Free f a = Return a | Roll f (Free f a) deriving Functor  -- using -XDeriveFunctor   ;)
20:20:56 <danharaj> :t Gendo
20:20:57 <lambdabot> Not in scope: data constructor `Gendo'
20:21:00 <danharaj> :t GEndo
20:21:01 <lambdabot> Not in scope: data constructor `GEndo'
20:21:04 <sshc> jmcarthur: Then how exactly is fmap defined for (Free f a)?
20:21:05 <danharaj> :k GEndo
20:21:05 <lambdabot> Not in scope: type constructor or class `GEndo'
20:21:11 <sshc> I'm trying to figure out how fmap works for (Free f)
20:21:17 <danharaj> Lambdabot practices gendo discrimination.
20:21:24 <sshc> Is there a library containing an implementation of Free?
20:21:25 <edwardk> newtype GEndo k a = GEndo { runGEndo :: k a a }; instance Category k => Monoid (GEndo k) where mempty = GEndo id; mappend (GEndo a) (GEndo b) = GEndo (a . b)
20:21:29 <sshc> There is.  But I don't rememebr wah ti si
20:21:30 <jmcarthur> sshc: if it compiles it's probably right. fmap tends to only work one way, most of the time
20:21:34 <sshc> what it is
20:21:36 <jmcarthur> sshc: free
20:21:42 <boz> But I'm going to have a look if there is a nice way to do it with 'Foldable'.  Thanks
20:21:59 <sshc> jmcarthur: It does.  I'm not sure if this is correct (by which I probably mean satisfies the functor laws)
20:22:00 <edwardk> then you have something like runKleisli . runGEndo . foldMap (GEndo . Kleisli)
20:22:10 <edwardk> but thats more verbose than the short fold definition
20:22:30 <edwardk> boz: see above
20:22:31 <boz> so I probably just give it a nice name
20:22:41 <sshc> Ah, control-monad-free
20:22:50 <danharaj> if edwardk tells you to do something, it will require a phd to understand.
20:23:13 * danharaj spoilers that was facetious
20:23:21 <edwardk> sshc: you want the 'free' package
20:23:50 <jmcarthur> boz: foldKleisli or something, maybe?
20:23:54 <boz> I see, never heared about GEndo, but try to see how much (or less) I can understand from this, anyway
20:24:17 <jmcarthur> newtype wrappers are a pain. your existing code is lot prettier
20:24:25 <edwardk> boz: i might have had it in an old version of the monoids package, but its not provided by default, i just supplied the definition of it above
20:24:47 <edwardk> its a generalized form of Endo from Data.Monoid, parameterized on the choice of Category
20:24:56 <danharaj> gah. I wish I didn't have to wrap existentials in data constructors all the time.
20:26:22 <danharaj> How difficult would it be to add bare existentials to GHC's type system?
20:26:40 <sshc> Ah, yes
20:26:55 <sshc> THat's how "free" implements it
20:26:57 <sshc> @type id
20:26:58 <lambdabot> forall a. a -> a
20:26:58 <edwardk> danharaj: ghc wouldn't get along very well with them. others have demonstrated that it is possible
20:27:03 <jmcarthur> danharaj: i doubt it would make things *much* more convenient. you're probably still have to unwrap things in order to use them
20:27:10 <edwardk> but even getting existentials into _newtypes_ is beyond ghc at this point
20:27:19 <danharaj> edwardk: what are the obstacles?
20:28:03 <edwardk> danharaj: i don't recall off hand, just recall the general looks of horror from the ghc guys when i asked about what it would take to be able to drop in existentials behind newtypes. ;)
20:28:14 <danharaj> :p
20:28:30 <edwardk> (mainly because i wanted to be able to define colimits without introducing an extra bottom)
20:28:49 <jmcarthur> uhc does it by just silently creating new types
20:28:52 <danharaj> you and your categorical constructions.
20:29:09 <edwardk> they are handy =)
20:30:05 <jmcarthur> newtype existentials would be pretty awesome
20:30:05 <danharaj> edwardk: One thing that intimidates me about your libraries is that Maclane doesn't talk about most of the widgets you've implemented in Haskell :p
20:30:54 <edwardk> danharaj: funny, almost everything i have is straight up out of maclane's book ;)
20:31:12 <edwardk> he ends with kan-extensions, so do my packages =P
20:31:12 <danharaj> really? I never could find 'codensity monad' in it :p
20:31:20 <edwardk> codensity isn't his term
20:31:27 <danharaj> ah that would explain things.
20:31:55 <edwardk> they go back to a paper from 1972
20:32:27 <edwardk> ross street's "The formal theory of monads"
20:32:34 * danharaj writes that down
20:32:43 <edwardk> in there they were called the "monad generated by a functor"
20:33:00 <djahandarie> Isn't codensity something like a right Kan extension of a functor along itself or something like that?
20:33:03 <edwardk> 2 years later dubuc's thesis introduced codensity as a name for the same idea
20:33:11 <edwardk> djahandarie: yep
20:34:01 <edwardk> djahandarie: but because it is a special case you get the monad construction, etc. which you don't get from just a kan extension
20:34:35 <danharaj> edwardk: Have you ever thought about taking all these ideas and making a language a la charity?
20:35:04 <edwardk> well, i have a little toy language project, but it isn't particular categorical in nature, beyond the prelude.
20:35:10 <edwardk> er particularly
20:35:20 * djahandarie tries to remember the name
20:35:25 <djahandarie> Starts with a k!
20:35:27 <djahandarie> I think
20:35:28 <edwardk> kata =)
20:35:29 <jmcarthur> kata!
20:35:37 <djahandarie> Hehe yes that
20:35:38 <sshc> List is also a free monad, right?
20:35:58 <sshc> Well, any functor can be
20:36:00 <sshc> So yes.
20:36:12 <jmcarthur> not like that
20:36:22 <jmcarthur> any functor can be used to *form* a free monad
20:36:32 <jmcarthur> but the monad formed by the functor is not the functor itself
20:36:57 <edwardk> a + f (a + f (a + f (a + …)))
20:37:06 <sshc> I see.
20:37:11 <sshc> < jmcarthur> but the monad formed by the functor is not the functor itself — I don't think so
20:37:21 <sshc> Oh, I read "the" as "a"
20:37:33 <edwardk> ah, good =)
20:37:53 <sshc> (the lattermost one)
20:38:39 <jmcarthur> the free monad formed from List is basically a rose tree with values at the leaves
20:38:53 <jmcarthur> a + [a + [a + [a + ...]]]
20:39:42 <edwardk> and list happens to be a free monad of maybe, Nothing | Just (a * Nothing) | Just (a * Just (b * Nothing)) | ...
20:39:46 <monochrom> @let fl n = fromEnum [n]
20:39:47 <lambdabot>  Defined.
20:39:50 <monochrom> @type fl
20:39:50 <lambdabot> forall t. (Enum [t]) => t -> Int
20:40:15 <sshc> edwardk: Wow, interesting.
20:40:21 <monochrom> this is supposed to be illegal in haskell 98 and haskell 2010. but ghc does this, without any extension too
20:40:34 <monochrom> (hugs reports an error as expected)
20:40:45 <jmcarthur> well, the free monad of maybe is the same as data Foo a = Delay (Foo a) | Now a
20:41:05 <sshc> jmcarthur: "rose tree" sounds familiar.  Is that...Data.Tree.Tree?
20:41:17 <sshc> (each node is labeled; no empty trees)
20:41:18 <edwardk> jmcarthur: that looks more like Free Identity
20:41:20 <jmcarthur> sshc: yeah, but i think that one has values at the branches
20:41:27 <jmcarthur> edwardk: err... right
20:41:32 <jmcarthur> my bad
20:41:39 <edwardk> the Maybe lets you have Nothing in there, which lets you recover list =)
20:42:01 <danharaj> edwardk: what's the schtick of your language?
20:42:02 <sshc> Rose trees are functors too, right?
20:42:24 <jmcarthur> edwardk: where are those products coming from in your series?
20:42:25 <dylukes> Wait, what're rose trees? ._.
20:42:37 <jmcarthur> sshc: yes
20:42:41 <danharaj> Tree a = Empty | Node a [Tree a]
20:42:53 <danharaj> (actually Data.Tree doesn't have Empty for some crazy reason)
20:42:55 <sshc> I see
20:42:59 <sshc> That's not Data.Tree.Tree
20:43:00 <edwardk> jmcarthur: i did that off the cuff so i may have had it wrong. one sec
20:43:19 <monochrom> @undefine
20:43:34 <jmcarthur> i know Cofree Maybe is a non-empty list. is that what you are thinking?
20:43:35 <monochrom> w00t hi manatee
20:43:54 <edwardk> ah you're right, wrong functor
20:44:07 <ddarius> djahandarie: Read Kelly's "Basic Notions of Enriched Categories"
20:44:08 <manateeUser> monochrom: Hi. :)
20:44:25 <danharaj> note: Kelly's book is hard to find :[
20:44:29 <manateeUser> @hackage manatee-all
20:44:29 <lambdabot> http://hackage.haskell.org/package/manatee-all
20:44:30 <sshc> I see< edwardk> and list happens to be a free monad of maybe, Nothing | Just (a * Nothing) | Just (a * Just (b * Nothing)) | ... — Return is equivalent to..'Just'?
20:44:37 * sshc doesn't think he understands
20:44:38 <ddarius> danharaj: It's available online readily.
20:44:48 <jmcarthur> sshc: i think that's wrong
20:44:48 <danharaj> ddarius: pff
20:44:55 <danharaj> ddarius: books are so much better than electrons
20:44:57 <sshc> I think too
20:45:03 <djahandarie> ddarius, that was for danharaj?
20:45:10 <ddarius> djahandarie: No.
20:45:16 <djahandarie> Oh, okay
20:45:16 <manateeUser> monochrom: How are you? ;p
20:45:21 * djahandarie notes down
20:45:23 <monochrom> good good
20:45:29 <manateeUser> Hehe. :)
20:45:51 <sshc> Let's see, "Free Maybe Integer" is equivalent to [Integer], yes?
20:46:11 <djahandarie> ddarius, "basic concepts of enriched category theory"?
20:46:22 <jmcarthur> sshc: no
20:46:37 <edwardk> sshc: it was a mistake on my behalf
20:46:42 <ddarius> djahandarie: If that actually finds something, yes.  It should be by Kelly and available on the tac reprints.
20:46:48 <edwardk> sshc: Cofree Maybe is a non-empty list
20:46:56 <djahandarie> Ah nice, I see it, thanks
20:47:07 <sshc> edwardk: Oh.  If you explained that earlier, I must have missed it.
20:47:33 <sshc> Cofree?
20:47:34 <jmcarthur> sshc: that would be a series of constructors having no values themselves, and the leaf of that would either have a value or not have a value
20:47:36 <sshc> Sounds familiar.
20:47:47 <jmcarthur> sshc: cofree comonad, as we mentioned earlier :)
20:48:05 <jmcarthur> data Cofree f a = Cofree a (f (Cofree f a))
20:48:11 <sshc> Ah, right.
20:48:16 <manateeUser> Good, manatee's keymap help window works well in Gnome3. :)
20:48:19 <edwardk> sshc: data Cofree f a = a :< f (Cofree f a)
20:48:26 <jmcarthur> yeah i like the infix better
20:48:57 <manateeUser> If you want show popup window in Gnome3, you should use windowNewPopup instead windowNew (gtk2hs API)
20:48:57 <edwardk> a * f (a * f (a * f (….
20:49:36 <manateeUser> If you don't use windowNewPopup and just set windowTypeHint with Dialog, it still can't work in Gnome3, of course, just set windowTypeHint can work in Gnome2
20:49:38 * BMeph would like a cofree comonad with extra syntactic sugar
20:49:45 <sshc> 03:55:57 < jmcarthur> sshc: that would be a series of constructors having no values themselves, and the leaf of that would either have a value or not have a value
20:50:15 <sshc>  — Or the chain could end at Nothing?
20:50:20 <jmcarthur> sshc: data Foo a = Later (Foo a) | Now a | Never
20:50:22 <edwardk> BMeph: i'll try to order that next time i'm at starbucks
20:50:49 <djahandarie> ddarius, these diagrams are not forgiving
20:50:59 <manateeUser> Bye all. :)
20:51:03 <jmcarthur> sshc: Nothing is the "no value" case
20:51:04 <sshc> > Roll (Just (Roll (Just (Pure 3))))
20:51:04 <lambdabot>   Not in scope: data constructor `Roll'Not in scope: data constructor `Roll'N...
20:51:12 <ddarius> djahandarie: I recommend for a first reading, ignoring most of the enrichment aspects.
20:51:27 <sshc> Or "Roll (Just (Roll (Nothing)))"
20:51:31 <jmcarthur> right
20:51:39 <jmcarthur> equivalent to the Foo type earlier
20:52:07 <sshc> I see
20:52:08 <jmcarthur> later = Roll . Just; now = Pure; never = Roll Nothing
20:52:18 <sshc> now, What was equivalent to lists, again?
20:52:24 <jmcarthur> i think nothing
20:52:26 <edwardk> sshc: nothing =)
20:52:37 <danharaj> So list is not a free monad?
20:52:40 <danharaj> or free comonad?
20:52:48 <jmcarthur> free monads always have their values at the leaves
20:52:49 <danharaj> (cofree)
20:52:55 <sshc> Or cofree comand or cofree comonad?
20:53:00 <edwardk> danharaj: of course not, it is the free monoid =)
20:53:07 <jmcarthur> ha
20:53:17 <sshc> cofree monad, I meant
20:53:24 <ddarius> A cofree comonad is never empty.
20:53:48 <edwardk> a * f ( …) — rules out cofree, like ddarius said
20:53:51 <BMeph> A comonad is never empty.
20:53:52 <jmcarthur> for that matter, a comonad is never empty
20:53:55 <jmcarthur> beat me to it
20:54:39 <sshc> data Cofree f a = a :< f (Cofree f a)
20:54:42 <sshc> Wait, how would that terminate?
20:54:52 <jmcarthur> sshc: consider f = Maybe
20:54:52 <sshc> (newtype is more appropriate here, right?)
20:54:59 <sshc> je'e
20:54:59 <jmcarthur> and who says it must terminate?
20:55:07 <edwardk> sshc: only if f had something that didn't use its argument
20:55:10 <jmcarthur> newtype would be fine, but then you'd just have to use (,)
20:55:21 <edwardk> sshc: can't use newtype, there are two terms on the right
20:55:37 <jmcarthur> newtype Cofree f a = Cofree (a, f (Cofree f a))
20:55:45 <sshc> Oh
20:55:48 <edwardk> Cofree Identity is an infinite list
20:55:59 <jmcarthur> sshc: the only difference between Free and Cofree is that the former is a sum and the latter is a product
20:56:54 <sshc> So Cofree can't terminate?
20:56:58 <jmcarthur> a + f (a + f (a + f (a + ...)))   vs.   a * f (a * f (a * f (a * ...)))
20:57:09 <jmcarthur> sshc: as i said, consider f = maybe
20:57:25 <jmcarthur> 1 :< Nothing
20:57:34 <jmcarthur> 1 :< Just (2 :< Nothing)
20:57:40 <edwardk> sshc: what about data Boring a = Boring      — Cofree Boring a is only inhabited by terms like  a :< Boring
20:57:50 <sshc> Cofree Maybe Integer would seem to be a a finite list whose "terminating element" (equivalent to []) always has a value; am I correct?
20:58:11 <jmcarthur> sshc: it's just a non-empty list. it may be infinite
20:58:16 <edwardk> sshc: except it is a non-empty list
20:58:31 <sshc> Ah, I see
20:58:33 <edwardk> sshc: try to represent [] with Cofree Maybe
20:58:55 <ddarius> edwardk: "A list whose 'terminating element' always has a value" is a very roundabout way of saying "a non-empty list."
20:59:30 <edwardk> ddarius: ah just parsed it =)
20:59:55 <yrvyzz> Hi! I've just started learning Haskell. :)  Is there a way to let ghci display a space after a comma in lists or tuples? I've found no answer on the web.
20:59:58 <danharaj> edwardk: Show us your toy language :p
21:00:36 <edwardk> danharaj: that is a rather verbose topic. i'd rather drag it off channel. to #kata or something
21:01:03 <edwardk> i've spammed this channel with kata noises enough in the past ;)
21:01:06 <danharaj> ah, I didn't realize there was a secret base :p
21:04:18 <sshc> So is "Cofree (Cofree Maybe) Integer" the non-empty node-labelled Data.Tree.Trees?
21:04:38 * ddarius wishes Eigen had a type of block-diagonal matrices.
21:05:14 <ddarius> sshc: No.
21:05:34 <ddarius> All trees in that type would be infinitely deep.
21:08:40 * sshc thinks how he could represent such a type
21:10:49 <sshc> 3 :> (undefined :: Cofree Maybe (Cofree (Cofree Maybe Integer)))?
21:12:06 <sshc> 3 :> (undefined :: f (Cofree f a)) — f is (Cofree Maybe), so replace 'f' with that for:
21:12:49 <sshc> "3 :> (undefined :: Cofree Maybe (Cofree (Cofree Maybe) Integer))"
21:13:35 * sshc wonders what "Cofree Maybe (Cofree (Cofree Maybe) Integer))" could possibly be
21:15:04 <sshc> How could that (or the previous type) be represented?
21:18:46 <sshc> "3 :< ((undefined :: Cofree (Cofree Maybe) Integer) :< (undefined :: Maybe (Cofree Maybe (Cofree (Cofree  Maybe) Integer))))", possibly
21:18:56 * sshc thinks how that could be presented
21:19:00 <sshc> si represented
21:19:32 <sshc> I think I see a pattern
21:21:30 <sshc> This channel seems unusually quiet
21:21:38 * rothwell blares airhorn
21:21:40 <dolio> sshc: You're trying to do Data.Tree.Tree as Cofree?
21:22:09 <sshc> dolio: And trying to figure out what 'Cofree (Cofree Maybe) Integer'  is
21:22:17 <dolio> The former is easy.
21:22:35 <sshc> a'a
21:23:08 <dolio> Cofree (Cofree Maybe) Integer is the type of Integer-labelled trees with branching factor Cofree Maybe.
21:23:12 <jmcarthur> sshc: Cofree (Cofree Maybe) Integer is an infinite stream of Integers that may branch arbitrarily wider at each point
21:23:56 <jmcarthur> dolio practices better terminology than i
21:24:02 <dolio> And Cofree Maybe a is non-empty lists?
21:24:06 <dolio> Of as.
21:24:28 <jmcarthur> yeah
21:24:30 <sshc> dolio: How could you do the former, then?  (Find the cofree monad that is equivalent to Data.Tree.Ttree)
21:24:37 <jmcarthur> there is none
21:24:41 <dolio> Cofree []
21:24:44 <jmcarthur> (and you mean cofree comonad)
21:25:01 <jmcarthur> Data.Tree.Tree may be empty, i thought
21:25:11 <dolio> No, someone was bemoaning that earlier.
21:25:19 <jmcarthur> oh
21:25:23 <edwardk> jmcarthur: it can't actually
21:25:41 <jmcarthur> oh you're right
21:25:47 <jmcarthur> okay then it is just Cofree []
21:25:49 <dolio> The problem with Cofree (Cofree Maybe) is that the lists are non-emtpy, so every node has at least one child.
21:29:03 <sshc> Oh, I see
21:29:12 <ddarius> "Today, France is the second most profitable country for McDonald's [..].  Incredibly, McDonald's is also the largest private-sector employer in France."
21:29:29 <sshc> Cofree (Cofree []) Integer would be interesting
21:29:38 * sshc clearly still doesn't understand Cofree (Cofree Maybe)
21:29:57 <sshc> Nested Cofree's, particularly
21:30:32 * sshc ponders Cofree (Cofree Identity) Integer
21:31:07 <dolio> Cofree (Cofree Maybe) a is the type of a-labelled trees where every node has 1 or more children.
21:31:18 <ddarius> sshc: That would just be an infinitely-wide, infinitely-deep tree.
21:31:42 <Veinor> oh, huh
21:31:55 <Veinor> that warrior problem, there are definitely infinitely many warriors
21:32:35 <ddarius> Cofree F a is just the type of F-branching streams of a's.  I.e. you get an a and then an F-shaped collection of (F-branching) streams of a's.
21:33:10 <augur> are there any ways to have heterogeneous derivatives?
21:33:48 <augur> like, if i have a type thats isomorphic to (Int,String), is it possible to have a single context type for both slots?
21:34:14 <c_wraith> Either Int String
21:34:28 <c_wraith> it even tells you which of the slots it's for
21:34:45 <augur> ok
21:37:41 <dolio> Either Int String is the zipper for (Int, String), if that's what you're asking for.
21:38:02 <dolio> At least, I think it is.
21:38:09 <dolio> That's not quite a derivative.
21:38:13 <OceanSpray> @hoogle (<.>)
21:38:14 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
21:38:14 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
21:38:27 <OceanSpray> wait what
21:39:42 <OceanSpray> :t pure
21:39:43 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
21:39:46 <OceanSpray> :t return
21:39:47 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:42:34 <sheikra> hey, anybody a wake and familar with parser combinators?
21:50:51 <OceanSpray> sheikra, I am using them right NOW.
21:53:42 <dmwit> sheikra: Don't ask to ask, just ask.
21:54:31 <sheikra> OceanSpray: great! I just looked at a paper "YACC is dead", I wonder if it improves over parser combinators?
21:54:50 <sheikra> dmwit: sorry. I thought most people are sleeping now ;-)
21:55:22 <dmwit> Eh, that paper is pretty unconvincing to me.
21:55:35 <sheikra> OceanSpray: Their method is to get the "derivatives" of the parser combinators
21:55:42 <dmwit> Or rather, I didn't bother to read it because somebody else I trust said it was unconvincing to them.
21:56:11 <sheikra> dmwit: What's the normal time complexity of parser combinators?
21:56:14 <OceanSpray> I have no idea what you are talking about.
21:56:29 <dolio> Isn't their solution parser combinators?
21:56:39 <dolio> The blurb I'm looking at seems to suggest that.
21:56:39 <OceanSpray> For me, they're just real damn easy to use.
21:56:57 <sheikra> OceanSpray: I'm a litte confused too, but it looks like getting the derivative is very much like computing the first and follow sets in LR parsing...
21:57:33 <ddarius> sheikra: It depends on the class of languages being parsed.  At any rate, the combinators in that paper are worst-case exponential which is certainly no better than anything else.
21:57:42 <sheikra> dolio: They are getting the "derivatives" from parser combinators and then use the derivatives to parse ...
21:58:08 <dmwit> The time complexity depends on the grammar and on the particular combinator library you choose.
21:58:11 <dolio> Yes. So it's a parser combinator library.
21:58:16 <sheikra> ddarius: are parser combinators exponential time too?
21:58:18 <dolio> Where the implementation uses derivatives.
21:58:40 <c_wraith> eh.  the approach I'm looking forward to is grammar combinators that support deriving parsers and pretty printers from the same definition.  Wake me up when they get good. :)
21:58:43 <dmwit> "Parser combinators" is not specific enough to identify a time bound.
21:58:56 <dmwit> There are many parsing implementations that use combinators as their front-end.
22:00:05 <sheikra> dmwit: The paper mentions that parser combinators can't deal with left recursion. Is that still true?
22:00:14 <c_wraith> still depends on the definition
22:00:21 <c_wraith> err, implementation
22:00:29 <dmwit> It still depends on which particular library you're talking about.
22:00:49 <dolio> There are parser combinators for parsing expression grammars in Haskell.
22:00:55 <dmwit> I don't see any fundamental reason that combinators require you to forego left recursion.
22:01:01 <dolio> And apparently those grammars can be parsed in linear time.
22:01:08 <sheikra> dmwit: sorry they didn't say that... they said PEG parsing is unable to deal with left recursion
22:01:36 <dmwit> Then that is probably true.
22:01:40 <dmwit> I don't know much about PEG parsing.
22:01:45 <ddarius> dolio: At the cost of having memory usage linear in the number of tokens parsed, or more specifically O(NG) where G is the number of productions and N the number of tokens.
22:02:10 <c_wraith> "parser combinators", in the broad sense, are just a way of embedded the parser description in the host language.  Everything else is an implementation detail.  Including grammars supported and parsing properties.
22:02:28 <sheikra> dmwit: my impression is that PEG is to cuts in prolog as CFG is to logic programming without cuts
22:02:50 <ddarius> It's also for a somewhat different class of languages than CFGs, though one that fits programming language better.
22:03:29 <ddarius> c_wraith: I would say the "parser combinator" aspect is the implementation detail.
22:03:30 <djahandarie> There is always indirect left recursion.
22:03:33 <dmwit> That analogy tells me nothing substantive.
22:04:04 <c_wraith> ddarius: nevertheless, they're orthogonal.
22:04:06 <ddarius> dmwit: PEGs can't be ambiguous.
22:04:13 <ddarius> c_wraith: Agreed.
22:04:14 <dmwit> I see.
22:04:20 <dolio> From what I've been able to glean from edwardk, PEG parsing can handle some left recursion, but mutual left recursion is still a problem.
22:04:56 <dolio> ... S <- T U, T <- S V ...
22:05:45 <sheikra> ddarius: what I wanted to say is that because cuts in prolog may eliminate useful results, PEG has the same danger if not used very carefully
22:05:47 <djahandarie> dolio, would you still be able to do that in linear time?
22:05:54 <dolio> djahandarie: Do which?
22:06:04 <djahandarie> Non-mutual left recursion.
22:06:22 <dolio> I don't know. I've never gotten around to reading the relevant material.
22:07:36 <djahandarie> "Parser Combinators for Ambiguous Left-Recursive Grammars" probably has the answer
22:07:55 <dolio> http://www.vpri.org/pdf/tr2007002_packrat.pdf
22:08:08 <sheikra> thanks
22:08:11 <dolio> There's "Packrat Parsers can Support Left Recursion".
22:08:27 <djahandarie> That looks more applicable.
22:08:52 <dolio> Oh, this paper says it handles even indirect left recursion.
22:08:53 <ddarius> sheikra: Except it's more like programming in Prolog and systematically using neck cuts.
22:09:13 <djahandarie> Yeah, and it seems to do it in linear time "most of the time".
22:09:15 <dolio> But it is sometimes super-linear.
22:11:15 <dolio> Oh man, the swap meet is today.
22:11:35 <ddarius> The flea market, you mean?
22:11:44 <dolio> Yes.
22:12:27 <sheikra> dolio: it looks good. I'll go for a reading.. thanks
22:13:01 <dolio> sheikra: Derivatives are cool, too.
22:13:16 <dolio> edwardk has some sweet monoidal parser stuff that he's never going to release, as well.
22:13:29 <edwardk> djahandarie: the left-recursive packrat stuff is broken
22:13:56 <pjpj> hello: i've a newbie question.  in the following which part is executed first: Just 3 >>= (\x -> Just (show x ++ "!")) : thanks
22:14:02 <sheikra> dolio: It seems to be more complicated though. There seems to be a precompiling process to get the derivatives
22:14:16 <edwardk> djahandarie: http://tratt.net/laurie/research/publications/papers/tratt__direct_left_recursive_parsing_expression_grammars.pdf refutes the major result of the paper that dolio named
22:14:24 <pjpj> whoops meant to be :  Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))
22:14:27 <dolio> Ah, okay.
22:14:38 <edwardk> the indirect left recursion is broken in that paper
22:14:42 <BMeph> pjpj: The ">>=" part. Thank you very much, I'll be here all week! ;)
22:14:46 <edwardk> and in the packrat parser library used by scala
22:14:51 <sheikra> edwardk: really?
22:14:59 <edwardk> sheikra: yeah. see the tratt paper above
22:15:07 <sheikra> edwardk: is there a quick fix then?
22:15:17 <edwardk> sheikra: no, its a systemic problem
22:15:20 <dolio> sheikra: Well, doing preprocessing of the parser isn't a bad thing.
22:15:49 <edwardk> tratt fixes the direct recursive case and shows the problem where the left-recursive packrat parser gives non-left-most parses in the presence of hidden left recursion
22:15:59 <pjpj> sorry, should have made it clear (I knew the >>= get done first),  what I'm really want to know is which is bound first the \x or the \y.
22:16:03 <sheikra> dolio: I'm a little confused and don't know what must be done in order to get the derivatives to work
22:16:08 <dolio> I think it's good that it can still be done for parser combinators if you restrict them suitably.
22:16:30 <dolio> Because otherwise, parser generators would have an advantage.
22:17:36 <dolio> But I'd rather have an embedded language for my parser than a language and a code generator, personally.
22:19:20 <pjpj> does the \x become 3 before \y becomes "!"  or is it the other way round?
22:20:14 <dolio> The 'Just "!" >>= (\y -> ...' is inside a lambda expression.
22:20:27 <dolio> Haskell doesn't reduce things inside lambda expressions.
22:23:47 <pjpj> dolio: ok then.  thanks I think I've got it.
22:25:08 <sheikra> edwardk: so you mean that the indirect left recursion part is still not solved?
22:28:03 <edwardk> sheikra: exactly
22:28:21 <edwardk> right now, don't packrat an indirectly left recursive grammar
22:28:50 <sheikra> edwardk: but it's hard to know which grammar is indirectly left recursive ;-)
22:29:14 <dolio> edwardk: So, it parses incorrectly?
22:29:15 <sheikra> edwardk: Does this only apply to packrat parsers?
22:29:48 <edwardk> dolio: you may get parses, but they won't be the correct choice of derivation, they won't be left-most.
22:30:17 <dolio> That's even worse than looping.
22:30:20 <sheikra> edwardk: Is there anything that can deal with all left recursion and is composible?
22:30:24 <edwardk> sheikra: yes. but then the linearity guarantee only applies to packrat too ;)
22:30:55 <edwardk> sheikra: sure. a classic earley-style parser for one. or any traditional parser that can handle any CFG
22:31:16 <edwardk> CYK, etc.
22:31:29 <edwardk> but the novelty was the asymptotics
22:32:01 <edwardk> general purpose CFG parsers are O(n^3). packrat was O(n) for the left most parse.
22:33:07 <edwardk> that and packrats parse PEGs, which have interesting properties, closure under operations that CFGs aren't closed under, a better fit to the way we actually write parsers....
22:33:37 <sheikra> edwardk: maybe some heuristics can improve the actually efficiency of general CFG parsers..
22:33:44 <edwardk> sure
22:34:30 <edwardk> also, if you only need left recursion, you can just turn to LR ;)
22:34:58 <sheikra>  my impression of PEG is that you must be careful in making the prefixes disjoint ..
22:35:15 <dolio> edwardk: Wikipedia says that Earley parsers perform "particularly well" for left-recursive grammars. Does that mean in comparison to other types of parsers, or non-left-recursive grammars?
22:35:17 <edwardk> which is pretty much the same factoring you do when you work with LL*
22:35:19 <sheikra> nah, I'll never turn to LR ;-)
22:35:30 <sheikra> I'd rather change the grammar
22:36:02 <edwardk> dolio: both really
22:36:29 <edwardk> dolio: a.) earley was the first really efficient general purpose implementation, but also becasue of the way it moves the finger, it loves left recursion
22:36:31 <dolio> Well, obviously they're better in comparison to other parsers, since a lot don't handle left-recursion at all.
22:36:48 <dolio> I was more curious about the latter.
22:39:14 <edwardk> my first monoidal parser was a modified earley parser, which effectively rederived a well known TAG parser, IIRC.
22:47:32 <sheikra> edwardk: Do you have the code or documentation available?
22:48:15 <edwardk> sheikra: i never did package up the monoidal parsing code for public consumption. i blogged the hackish variant that was 10x faster though ;)
22:48:54 <edwardk> http://comonad.com/reader/2009/iteratees-parsec-and-monoid/
22:49:00 <Eelis> edwardk: is it possible that you have some semigroup commits that you haven't pushed to github yet? in the hackage package there's Data.List.NonEmpty, but it's absent on github
22:49:08 <edwardk> eelis: yes
22:49:16 <Eelis> ok :)
22:49:24 <edwardk> i did them on the commute into work, didn't push to the repo. one sec
22:49:45 <edwardk> check now
22:49:53 <Eelis> awesome, thanks!
22:51:10 <sheikra> edwardk: no problem. what's the address of your blog?
22:51:19 <edwardk> http://comonad.com/reader/2009/iteratees-parsec-and-monoid/
22:52:34 <edwardk> hrmm. i just realized i never blogged anything about the 'ad' package, just the old 'rad' package.
22:53:43 <edwardk> sheikra: i also use the speculation package (the most recent post) when dealing with lexing these days
22:54:13 <edwardk> the paper i link to there talks about how you can use it with a lexer
22:55:07 * edwardk &
22:56:13 <sheikra> edwardk: It seems that packrat parsing is othogonal to PEGs. It is packrat's memoization that makes it linear and not because of PEGs?
22:56:53 <ddarius> sheikra: The memoization only makes sense for unambiguous grammars.
22:57:22 <dolio> PEG is the class of grammars, and packrat is the implementation technique more or less, no?
22:57:41 <dolio> PEG being analogous to CFG.
22:58:04 <djahandarie> Still going on about PEGs in here? :p
22:58:17 <dolio> And packrat being analogous to some parsing technique for CFGs.
22:58:32 <dolio> Like Earley parsers or something.
23:01:10 <sheikra> edwardk: thanks
23:01:33 <ddarius> dolio: Yes.
23:07:50 <edwardk> sheikra: the machinery that lets you parse a PEG with left recursion is at fault. not the memoization machinery
23:08:44 <edwardk> sheikra: iirc. the tratt paper goes through and demonstrates the problem first with unmemoized parsers
23:36:00 <Yrogirg> Hello! How do I remove installed packages from cabal?
23:44:50 <hamishmack> Yrogirg: ghc-pkg unregister
