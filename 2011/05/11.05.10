00:15:42 <Pig-Roman> is there any new haskell like languages that can write equations in equation form/etc
00:17:11 <Pig-Roman> what are those old haskell like languages?
00:26:41 <ksf> Pig-Roman: miranda is the main influence for haskell
00:27:31 <ksf> as to recentish languages, there's a veritable zoo, including but not limited to agda, epigram, idris, and timber.
00:28:21 <ksf> oh, and then there's clean.
00:28:45 <ksf> everybody always forgets clean, most likely because you need to register your email or something to get the compiler.
00:29:06 <ksf> it's arguably the most haskell-like contemporary language, though.
00:37:36 <flamingspinach> ksf: http://wiki.clean.cs.ru.nl/Download_Clean looks like a compiler download page...
00:43:24 <ksf> ...well, now it's too late, haskell already won when it comes to adoption.
00:43:56 <ksf> hard to reach critical mass when your only distinguishing feature is uniqueness typing
00:45:10 <Pig-Roman> im asking about graphical programming languages
00:46:11 <ksf> lhs2tex?
00:53:26 * hackagebot cryptocipher 0.2.12 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.12 (VincentHanquez)
01:19:15 <Younder> literate programming is catching on at last.
01:19:44 <opqdonut_> ?
01:20:26 <Younder> ksf: It excepts text and translates it using latex
01:21:56 <Younder> extracting text formatting from code as t were
01:30:15 <ksf> well, I wouldn't use a graphical editor to typeset formulae in any case.
01:31:22 <ksf> it'd be nice if e.g. yi could display everything not currently being edited in lhs2tex-style
01:32:30 * hackagebot DimensionalHash 0.1.5.2 - An n-dimensional hash using Morton numbers.  http://hackage.haskell.org/package/DimensionalHash-0.1.5.2 (GhassenHamrouni)
01:33:06 <ksf> ...the only reason programmers like monospace is alignability, after all, not easy reading.
01:42:02 <triyo> If a haskell library depends on a C foreign library, can one define the dependency in cabal?
01:42:18 <rostayob> what are the pros/cons of lazy bytestrings? when should I use one oranother?
01:42:26 <rostayob> *or the other
01:42:34 <Saizan> triyo: extra-libraries:
01:43:16 <triyo> I am trying to determine the version of OpenSSL that HsOpenSSL (on hackage) depends on
01:43:46 <triyo> Here is the cabal file for ver 0.9 http://darcs.cielonegro.org/HsOpenSSL/HsOpenSSL.cabal
01:43:57 <Saizan> rostayob: when you want to deal with the data in chunks, rather than all at once
01:44:45 <rostayob> Saizan: ok, so let's say I have a function that takes a string, converts to a bytestring, does stuff with the bytestring converts it back to a string
01:44:55 <triyo> Saizan: cause I am getting all sorts of errors what latest version of OpenSSL when trying to do a "cabal install HsOpenSSL"
01:44:57 <rostayob> I should go for the strict version?
01:45:04 <rostayob> the thing that worries me is pack
01:45:15 <triyo> I don't see anywhere the version number of OpenSSL it depends on
01:45:38 <triyo> I get an error such as "error: too few arguments to function ‘ASN1_dup’"
01:46:17 <triyo> That sounds to me like its calling a wrong version of function in installed OpenSSL
01:46:18 <Zao> triyo: Even if you had a "version number", a concept some libraries doesn't have anyway, you do not have any way to detect it reliably.
01:46:41 <Zao> triyo: Check the changelog to see if they've added some argument to it.
01:46:45 <Saizan> rostayob: how long is it?
01:46:52 <Zao> triyo: There cannot be "the wrong version of a function". C doesn't have overloading.
01:47:11 <Saizan> rostayob: is the String already all in memory or produced lazily?
01:47:25 <rostayob> Saizan: it could be quite long, but not huge. I'm parsing markdown. The string is already all in memory.
01:47:52 <mauke> rostayob: then what would lazy bytestrings buy you?
01:48:03 <rostayob> mauke: I don't know, that's why I'm asking
01:48:12 <gienah> cd
01:48:19 <Saizan> in that case go with strict
01:48:23 <triyo> Zao: I don't meen overloading, I mean I'm maybe running wrong version of OpenSSL where ASN1_dup function arg list has changed
01:48:28 <rostayob> ok, thanks
01:48:33 <Saizan> it'd be better if you could eliminate String from the pipeline entirely
01:48:44 <rostayob> also because there doesn't seem to be a function to use a lazy bytestring as a CString
01:48:58 <Zao> triyo: See when it was uploaded to Hackage, see what contemporary OpenSSL is?
01:49:00 <Saizan> yeah, you'd have to concat it first
01:49:21 <exeter> hello haskellers, has anyone got some experience with HXT (Haskell XML Toolbok)? I would like to do an extremely simple action (replace some tags with other tags and such), but completely failed so far.
01:49:23 <rostayob> so in that case the strict version is the only choice
01:49:27 <triyo> Zao: I see, I'll get on with the detective work then.
01:49:28 <mauke> rostayob: yes, that wouldn't make sense
01:49:28 <triyo> :)
01:49:46 <mauke> rostayob: the point of lazy bytestrings is that they're not just a single chunk of memory, which is what C expects
01:49:51 <rostayob> mauke, Saizan: ok cool, I just wanted to be sure
01:50:24 <exeter> in particular, I'm unsure on which signature I should give to a function like deep >>> ...
01:51:13 <exeter> (if you have suggestions on simpler xml parsing/manipulating libraries, I am all ears!)
01:51:26 <Zao> There's no such thing as simple XML anything :)
01:51:35 <exeter> ahaha zao
01:54:40 <uj> hi, i'm new to haskell. i'm wondering what <+> means. i've tried googling but it seems that google ate this: <+>
01:54:56 <mauke> it's just a library function
01:55:02 <mauke> depends on the library you're using
01:55:08 <Entroacceptor> @hayoo <+>
01:55:08 <lambdabot> Unknown command, try @list
01:55:10 <Entroacceptor> :(
01:55:18 <Entroacceptor> uj: most probably it's the one from xmonad?
01:55:25 <exeter> uj: are you learning applicative functors?
01:55:25 <Zao> Applicative?
01:55:37 <uj> yes, from xmonad
01:56:33 <Zao> Ah, http://xmonad.org/xmonad-docs/xmonad/XMonad-ManageHook.html#v%3A%3C%2B%3E
01:56:43 <Zao> "composition of managehoooks"
01:56:49 <uj> exeter, i've just begin learning haskell through xmonad. i don't understand what applicative functor is.
01:56:57 <uj> i see
01:56:59 <Zao> http://xmonad.org/xmonad-docs/xmonad/src/XMonad-ManageHook.html#%3C%2B%3E
01:57:04 <Zao> It's just mappend, it seems.
01:57:19 <uj> so it's defined by the xmonad developer and not a standard in haskell
01:57:25 <Entroacceptor> yes
01:57:34 <Zao> uj: From the perspective of an user, it's "an operator to compose two hooks, lol"
01:58:07 <uj> thanks, Zao, Entroacceptor, and mauke
01:59:02 <uj> haskell is truly a different experience in programming and now i know that the community is so friendly to beginners. thanks again
02:11:00 <exeter> to explain my problem in simple words, I just need to permorm some very basic actions, like translating "<image><source>thing</source>desc</image>" to "<img src="thing" alt="desc" />". I managed to make HXT to "read" my xml document (and from the displayed tree that it is). The tutorial page ( http://www.haskell.org/haskellwiki/HXT ) is outdated. If someome knows a bit of code that works (and that I can study), even inside another mo
02:12:52 <ksf> @hoogle <+>
02:12:52 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
02:12:53 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
02:12:53 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
02:14:25 <ksf> exeter: if you have a DTD, you can use haxml, let it generate an ADT from it, parse the file and then use SYB to do your stuff
02:14:36 * hackagebot upskirt 0.0.2 - Binding to upskirt  http://hackage.haskell.org/package/upskirt-0.0.2 (FrancescoMazzoli)
02:16:03 <uj> nice bot, i'll ask lambdabot first next time
02:16:16 <exeter> ksf, ADT = algebraic data type?
02:17:04 <ksf> yep
02:17:11 <exeter> (also, SYB? Scrap your boilerplate? )
02:17:17 <ksf> yep
02:17:34 <ksf> ...you can write your transformations by hand, too, of course.
02:18:13 <ksf> syb isn't known to be the fastest of generics libraries, but it's powerful and standard.
02:18:26 <ksf> kinda like parsec in that regard
02:20:11 <exeter> then I would have to translate that back to an xml string, even though it seems to be trivial compared to the rest
02:21:27 <gienah> exeter: the masters thesis is helpful on hxt: "Cookbook for the Haskell XML Toolbox" Manuel Ohlendorf
02:21:44 * exeter googles
02:24:02 <m3ga> @ {..}
02:24:36 <m3ga> @hoogle {..}
02:24:36 <lambdabot> Parse error:
02:24:36 <lambdabot>   --count=20 {..}
02:24:36 <lambdabot>              ^
02:25:02 <exeter> oh, that could come handy, thanks gienah
02:26:23 <koral_> hi, I'd like your opinion on a design question
02:27:04 <koral_> I'm trying to write an application and I need to handle keybindings
02:27:38 <koral_> I'm using gtk2hs which provides events on key striking
02:27:48 <ClaudiusMaximus> m3ga: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
02:28:22 <koral_> As I would like the user to configure sequences of keystrokes as keybindings
02:28:38 <koral_> I need to memorize the previously striken keys
02:29:08 <koral_> I'm thinking about using a State monad for this
02:29:39 <koral_> as this is the first time I'm writing an haskell app
02:29:49 <koral_> I'd like to know if I'm going the right way
02:30:14 <koral_> do you think using State monad is the best way to handle this ?
02:31:32 * erus` reads up on the state monad
02:32:16 <quicksilver> koral_: impossible to say without more context. It's probably a reasonable approach.
02:32:48 <quicksilver> koral_: using a State monad is nothing magical - it's just a using function.
02:32:48 <koral_> quicksilver: can't see what you miss here
02:32:48 <quicksilver> State s a is just a function s -> (a,s)
02:33:13 <quicksilver> so 'using a state monad' is no different from 'passing a value of type s around'
02:33:13 <quicksilver> except for syntax.
02:33:21 <quicksilver> so yes, it's quite likely you want to pass around the list of memorized keys
02:33:40 <quicksilver> any application will a current state, which surely contains more than just recently hit keys.
02:33:47 <m3ga> ClaudiusMaximus: thanks, most informative
02:33:47 <ClaudiusMaximus> koral_: i'd probably end up using Data.IORef in IO monad to store the state (from a practical point of view)
02:34:09 <ClaudiusMaximus> koral_: mainly because gtk is callback based
02:34:13 <Phyx-> hmm how does one print without a printer...
02:34:55 <triyo> Is there a way to specify C lib includes path on "cabal install ..."?
02:35:11 <koral_> quicksilver: is this the right way to have something like a world state passed through all functions ?
02:35:36 * hackagebot upskirt 0.0.3 - Binding to upskirt  http://hackage.haskell.org/package/upskirt-0.0.3 (FrancescoMazzoli)
02:35:46 <Phyx-> upskirt?
02:36:37 <rostayob> Phyx-: it's a markdown library :P
02:36:52 <quicksilver> koral_: yes. That is what the State monad encapsulates.
02:36:56 <wjt> I tend to end up combining the two, storing the state in an IORef but reconstituting the State enviroment inside the callbacks: http://cgit.freedesktop.org/bustle/tree/Bustle/Application/Monad.hs (based on an email by quicksilver IIRC)
02:36:57 <quicksilver> but you don't have to use it, you can pass manually.
02:37:02 <rostayob> I didn't chose the name
02:37:31 <quicksilver> there really isn't a huge difference between doing it manually or implicitly.
02:37:47 <koral__> I understand that
02:37:49 <quicksilver> the callbacks present a slight hiccup as ClaudiusMaximus points out, but it can be solved (as wjt points out)
02:38:11 <mm_freak_> since quite some time cabal-install is ignoring my hackage username/password in the config file
02:38:14 <mm_freak_> why?
02:39:20 <Phyx-> rostayob: aha
02:40:46 <rostayob> Phyx-: apart from that, it's a really cool markdown library (:
02:43:06 <erus`> can I return nothing?
02:43:25 <rostayob> erus`: return () ?
02:43:34 <erus`> I mean like IO () or something
02:43:37 <erus`> i want a do
02:43:57 <Zao> erus`: The only value you can return from an IO () is ().
02:44:17 <Zao> Not quite the right words, but the gist should be clear.
02:44:23 <erus`> yeah i don't care about the return value but I need to perform some IO in this function
02:44:38 <erus`> Its kinda like 'main'
02:44:54 <rostayob> erus`: so what's the problem? the type sign of that function would be bla bla -> IO ()
02:45:08 <erus`> ok thats fine
02:45:09 <Zao> erus`: If the last action in the block is an IO (), you need not do anything.
02:45:35 <erus`> do i have to end with a return IO () or can i end with a putStrLn or something?
02:45:44 <rostayob> :t return
02:45:44 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
02:45:48 <Zao> > let x = do { print "lol"; print "lol"; } :: IO () in 3
02:45:49 <lambdabot>   3
02:46:09 <Zao> @type do { print "lol"; print "lol"; }
02:46:10 <lambdabot> IO ()
02:46:13 <Zao> Probably clearer.
02:46:33 <Zao> @type return ()
02:46:34 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
02:46:57 <Zao> Judging by the type, (return ()) seems to satisfy your requirements.
02:47:23 <Zao> Note that no such thing is needed in my lol-example, as it already has the type IO () from print.
02:47:41 <erus`> playRound :: Int -> Int -> IO () <newline> layRound score h1 h2 = do <body of func> <-- it doesnt like that
02:47:57 <Zao> erus`: Well, what's the last action in the do block?
02:48:00 <erus`> ignore the missing p
02:48:01 <HugoDaniel> is there any maybe instance of monad that propagates successes ?
02:48:03 <Zao> Or rather, what's the type of it?
02:48:06 <HugoDaniel> is it even possible ? :P
02:48:22 <erus`> Zao: just a putStrLn
02:48:25 <Zao> Also, you have more parameters than the type says.
02:48:38 <HugoDaniel> something like: (>>=) (Just a) f = let res = f a in if isNothing res then Just a else res
02:48:43 <erus`> oh god what a wally :P thanks
02:48:58 <rostayob> erus`: do {putStrLn "foo"} is fine
02:49:12 <exeter> I bother you again haskellers: I am looking at a very small bit of code ( http://hackage.haskell.org/packages/archive/hxt/9.1.1/doc/html/src/Text-XML-HXT-DOM-FormatXmlTree.html#formatXmlTree ) and I would like to know _where_ the function %BformatTree%B is defined. What's the quickest way to check that?
02:49:27 <rostayob> exeter: the index of the hackage package?
02:49:53 <exeter> rostayob: do you mean this one? http://hackage.haskell.org/package/hxt
02:50:14 <rostayob> exeter: http://hackage.haskell.org/packages/archive/hxt/9.1.1/doc/html/doc-index.html
02:50:18 <rostayob> if the function is in the package
02:50:22 <triyo> Zao: Ok I finally got HsOpenSSL compiled and installed. I had to do something very hackish though. I had to download the source of HsOpenSSL and modify the Include-dirs: of .cabal file and then run install. This is the case when you have multiple versions of OpenSSL installed of course.
02:50:24 <rostayob> alternatively, hoogle, hayoo
02:50:40 <rostayob> exeter: http://hackage.haskell.org/packages/archive/hxt/9.1.1/doc/html/Data-Tree-Class.html#v:formatTree
02:50:47 <rostayob> it's in the index
02:51:00 <triyo> It would be nice if you could do something like "cabal install include-dirs="/my/pwth/to/include"
02:51:30 <triyo> "cabal install MyHsLib include-dirs="/my/pwth/to/include"
02:51:44 <triyo> instead of hacking .cabal file
02:52:44 <exeter> thanks rostayob
02:54:12 <Zao> triyo: It wouldn't surprise me if there's some secret switch.
02:55:29 <triyo> Zao: yes, maybe a *secret* one because as per FAQ http://haskell.org/haskellwiki/Cabal/FAQ ... only way to do it is to hack the .cabal file.
02:58:54 <Zao> The fundamental law of documentation is that no documentation is ever completely accurate :)
03:11:46 <shriphani> hello everyone, I am going through the book "Learn you a haskell.. " and I can't figure out why Haskell is not happy with the signature of my head' function : http://hpaste.org/46570/head_of_a_list_signature
03:12:16 <erus`> http://hpaste.org/46571/rps Line 68 and 72 do not have any effect :(
03:12:46 <pacak> shriphani: Can you show your implementation if this function?
03:13:24 <pacak> shriphani: It seems that you used square brackets instead of round ones in the match pattern
03:14:20 <shriphani> pacak: http://hpaste.org/paste/46570/head_of_a_list_signature_anno#p46572
03:15:06 <pacak> shriphani: Yep. try head' (x:_) = x
03:15:18 <shriphani> won't that be a tuple ?
03:15:45 <erus`> ok ignore my pasted
03:15:56 <pacak> shriphani: No, since constructor is :
03:16:58 <shriphani> oh wait a list [x, _] = x:_
03:17:06 <quicksilver> shriphani: no.
03:17:13 <quicksilver> shriphani: [x, _] has two elements.
03:17:20 <quicksilver> shriphani: x:_ has one or more.
03:17:25 <shriphani> oh right.
03:17:33 <shriphani> yeah I see what I did wrong.
03:17:36 <shriphani> thank you.
03:19:26 <mauke> [x, _] = x : _ : []
03:27:34 * Phyx- uses unsafePerformIO
03:28:43 <erus`> Would someone do a little code review if they have time http://hpaste.org/46573/roshambo . It's my first haskell program with more than 10 LOC
03:29:06 <Zao> Phyx-: It's only acceptable if it makes progress on VHS faster :D
03:29:36 <Phyx-> it's being used to preserve my lazyness...
03:30:10 <Phyx-> I want with SYB to modify the n-th element it visits in a tree
03:30:11 <Zao> erus`: Isn't the logic in the else block of compareHand a bit off?
03:30:17 <Phyx-> so I keep track of that with an IORef
03:30:19 <Zao> erus`: Shouldn't you flip the result of that?
03:30:30 <Phyx-> but the function needs to be non-IO
03:30:45 <erus`> zoa Rock loses to Paper
03:30:54 <Zao> erus`: In your world, both (Rock,Paper) and (Paper,Rock) results in Lose.
03:31:47 <erus`> o shit yeah
03:31:57 <erus`> is there a not function?
03:32:09 <Phyx-> :t not
03:32:10 <lambdabot> Bool -> Bool
03:32:16 <Zao> None that fits you.
03:32:29 <Zao> What's the name of the LE/EQ/GT thing?
03:32:42 <Phyx-> Zao: and yes it helps
03:32:43 <ClaudiusMaximus> @src Ordering
03:32:43 <Zao> erus`: You can write a trivial negateRank
03:32:43 <lambdabot> data Ordering = LT | EQ | GT
03:32:58 <quicksilver> erus`: a nicer way to write comparehand is http://hpaste.org/46574/comparehand
03:33:02 <quicksilver> it is still wrong, though
03:33:11 <quicksilver> the last case should be negateRank (compareHand h2 h1)
03:33:20 <quicksilver> but negateRank is easy to write.
03:33:42 <erus`> quicksilver: I did it like that first but it seemed less readable when i wrote it
03:33:53 <Zao> Line 6 could be    otherwise = negateRank (compareHand h2 h1) too
03:34:03 <Zao> Err, | otherwise
03:36:45 <frerich2> erus`: Maybe you should explicitely instantiate the 'Show' type class for 'Hand' yourself instead of deriving it but then having a custom 'handStrng' method. If 'show' would always yield a lowercase string, you could also have an instantiation of the 'Read' type class which would obsolete the 'handFromString' function.
03:40:08 <erus`> Sounds good. I don't even know how to instantiate a type class yet tho
03:41:08 <shriphani> Hello everyone. Is anyone using Haskell with Emacs on Windows ? I have a few problems getting the inferior mode to work. What exactly do I need to put in my .emacs?
03:41:47 <quicksilver> erus`: frerich2's advice is bad. do not follow it.
03:41:59 <quicksilver> you should never write a different Show class from the deriveable one.
03:42:11 <quicksilver> well, almost never :)
03:42:26 <frerich2> quicksilver: Why not?
03:42:47 <erus`> time for tetris or something now :)
03:42:50 <zygoloid> because that's not what Show is for :)
03:42:56 <quicksilver> because that's not what it's for, frerich2
03:42:59 <erus`> where is the glfw bindings?
03:43:11 <quicksilver> a Show instance is a way to turn a data type into valid haskell syntax
03:43:16 <quicksilver> so you can copy-paste it into code.
03:43:23 <quicksilver> useful for test writing, debugging, etc.
03:43:33 <Phyx-> wth, is that how the report defines it?
03:43:40 <frerich2> Oh. I thought it was for serializing stuff into a string (and Read should do the reverse).
03:44:57 <frerich2> quicksilver: I thikn I just found the part of RWH which made me get this impression: in http://book.realworldhaskell.org/read/using-typeclasses.html it says 'Show is usually used to define a String representation for data that is useful for a machine to parse back with Read.'
03:45:25 <frerich2> Maybe I had too much of a 'stream' mindset, I thought that means Show and Read are like serialization/deserialization interfaces.
03:46:33 <Phyx-> I see no mention of this in the report
03:46:43 <frerich2> erus`: Better listen to quicksilver, I don't have too much experience with Haskell myself :-)
03:46:47 <Phyx-> which just states "The Read and Show classes are used to convert values to or from strings. The Int argument to showsPrec and readsPrec gives the operator precedence of the enclosing context (see Section 10.4)."
03:47:19 <frerich2> erus`: Another idea I have (but now I barely dare suggesting this in the presence of all the experts here) - try to move code which doesn't need IO out of 'playRound'. For instance, consider http://hpaste.org/paste/46573/roshambo_annotation#p46575
03:48:30 <quicksilver> Phyx-: sure, but don't you realise that quicksilver supersedes the haskell report?
03:48:50 <quicksilver> (the report underspecfies Read and Show but it's useful to be more precise about their purpose)
03:49:11 <erus`> frerich2: thats a good idea :)
03:49:32 <Phyx-> quicksilver: to me that seems like a rather random and constrained definition of Read & Show though
03:51:49 <quicksilver> Phyx-: it's not random - it's for the specific purpose of enabling debugging and test case isolation.
03:52:05 <quicksilver> Phyx-: it's quite consistent with some other languages / systems, including the lisp notion of 'read'
03:52:21 <quicksilver> Phyx-: it is, indeed, 'constrained' but that's only a bad thing if you don't like the constraints.
03:52:39 <quicksilver> if someone puts a hackage library up with a broken Show instance that's really annoying for people who want to use it to build test cases.
03:52:52 <zygoloid> if you want to make things readable by your end user, you can easily define a type class which works the way you want it to
03:52:57 <Phyx-> quicksilver: you could say it's *one* of the uses of Show/Read, but not the only one for which it's valid.
03:53:14 <Phyx-> quicksilver: I dissagree that show should be used to generate tests cases in the first place
03:53:19 <zygoloid> Phyx-: in almost any nontrivial application, Show is a terrible way of presenting data to the end user
03:53:58 <quicksilver> Phyx-: it's very useful, when developing in a repl. You work with various expressions, you try your functions, you discover an important edge case or a failing case, and you just copy the output of the repl into your test suite.
03:54:18 <Phyx-> zygoloid: I never said it was, I'm objecting to that the only purpose of Show/Read is to generate Haskell syntax in strings.
03:54:26 <frerich2> quicksilver: You said one should "almost never write a different Show class from the deriveable one". What situation did you think of where deriving Show is possible but writing a custom instantiation is better?
03:54:38 <quicksilver> frerich2: something like Data.Map where the constructors are hidden.
03:54:50 <quicksilver> frerich2: it's not very useful to expose to the user connstructors he can't understand.
03:55:11 <Phyx-> I use pretty printing libraries to write almost every pp i write, but to me having a Show for a lambda calculus that outputs actual lambda calculus syntax is perfectly valid
03:55:11 <quicksilver> Data.Map uses 'fromList' in its show instance, whhich works well enough.
03:55:46 <Phyx-> quicksilver: if you're test and program are written in the same language, since you want to read haskell datatypes, what does it matter what show outputs, aslong as read can read it back
03:56:09 <quicksilver> I'm talking about copying it directly into haskell source.
03:56:13 <quicksilver> there is no 'read' step required.
03:56:19 <quicksilver> it gets compiled.
03:56:25 <Phyx-> why make it output at all?
03:56:33 <Phyx-> have the generated structure fed directly into the test
03:56:43 <zygoloid> Phyx-: my view is less conservative than quicksilver's: Show is for producing output to be read by a programmer, in whichever means is most convenient. usually that's Haskell syntax.
03:57:00 <Phyx-> zygoloid: that i can agree with
04:02:22 <Phyx-> :t everywhere
04:02:23 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
04:03:32 <Phyx-> :t mkQ
04:03:33 <lambdabot> forall r b a. (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
04:03:45 <Phyx-> :t mkT
04:03:46 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
04:03:58 <Phyx-> :t liftM2 mkT
04:03:59 <lambdabot> forall b a2 (m :: * -> *). (Typeable a2, Typeable b, Monad m) => m (b -> b) -> m a2 -> m a2
04:05:23 <Phyx-> hmm that presents a problem
04:06:27 <Phyx-> hmm maybe not
04:07:34 <HugoDaniel> http://hackage.haskell.org/package/old-locale  where is the new locale library ?
04:09:15 <liyang> I think it's been old for a very long time.
04:09:28 <luite> hehe I believe the same question was asked here a few days ago
04:11:11 <luite> (the answer was that there isn't one)
04:13:03 <erus`> Is there a really minimal dialect of ML/Haskell like Scheme is to Lisp?
04:15:28 * hackagebot rfc3339 1.0.0 - Parse and display time according to RFC 3339  http://hackage.haskell.org/package/rfc3339-1.0.0 (HugoGomes)
04:19:18 <Phyx-> well.. it's not pretty.. but it works..
04:22:02 <rostayob> erus`: you can use Hugs instead of ghc
04:23:13 <HugoDaniel> http://hackage.haskell.org/package/rfc3339  my packages descriptions always show up messed up :(
04:23:21 <rostayob> it's not a dialect but it's plain haskell 98, while ghc is bigger
04:24:28 * hackagebot rfc3339 1.0.1 - Parse and display time according to RFC3339  http://hackage.haskell.org/package/rfc3339-1.0.1 (HugoGomes)
04:25:14 <rostayob> HugoDaniel: i didn't even know you could put code blocks in .cabals :P
04:25:29 * hackagebot rfc3339 1.0.2 - Parse and display time according to RFC3339  http://hackage.haskell.org/package/rfc3339-1.0.2 (HugoGomes)
04:25:29 <rostayob> I'm not sure you can do that
04:25:49 <HugoDaniel> sometimes i can make them show up nicely
04:26:11 <HugoDaniel> onliners mostly
04:26:12 <HugoDaniel> http://hackage.haskell.org/package/Noise
04:26:15 <HugoDaniel> like this
04:26:17 <dankna> well, clearly you can do it, as illustrated there, but I don't know that it's supported, haha
04:26:53 <rostayob> HugoDaniel: oh ok, fair enough
04:31:30 * hackagebot rfc3339 1.0.3 - Parse and display time according to RFC3339  http://hackage.haskell.org/package/rfc3339-1.0.3 (HugoGomes)
04:36:43 <HugoDaniel> ok, fixed
04:36:55 <HugoDaniel> now i just need to w8 for hackage to build my documentation
04:48:31 * hackagebot bson-mapping 0.1.2 - Mapping between BSON and algebraic data types.  http://hackage.haskell.org/package/bson-mapping-0.1.2 (FrancescoMazzoli)
04:49:48 <yitz> preflex: seen BONUS
04:49:48 <preflex>  BONUS was last seen on #haskell 9 days, 16 hours, 28 minutes and 3 seconds ago, saying: yeah i think that's better as well
05:09:16 <djanatyn> Is perl a dependency of ghc?
05:09:19 <djanatyn> Apparently, I have perl.exe in my ghc folder
05:15:08 <ketil> Anybody look (deeply) at Bryan O'S's Bloom filters?  Any way to find the number of hash functions begin used?
05:15:46 <ketil> There are some numbers in the record that constitutes a Bloom filter, but I'm unsure of what they are.
05:18:30 <Botje> djanatyn: there is the Evil Mangler
05:21:10 <mrcarrot> when i am trying to compile regex-tdfa i get this error message:
05:21:17 <mrcarrot> ghc: out of memory (requested 1048576 bytes)
05:21:25 <mrcarrot> what could i do about this?
05:21:34 <exeter> i have a helloworld folder, 2 .hs files in it plus a Makefile. How should I compile? I mean, usually i just fire cmd and type "ghc filename.hs" . How should I use this makefile stuff?
05:22:18 <hpc> exeter: have you looked at 'man make' yet?
05:22:33 <exeter> hpc, no
05:22:34 <erus`> exeter: my program: \n \t ghc myfile1.hs myfile2.hs
05:23:29 <Entroacceptor> if you have a makefile, try just 'make'
05:23:43 <int-e> ghc --make filename.hs  often does the trick (but doesn't use the Makefile; that's indeed for 'make')
05:24:28 <hpc> the --make flag just compiles dependencies automatically and adds -o Main
05:24:29 <exeter> but.... I don't have such a command
05:24:40 <exeter> I only have "ghc"
05:24:52 <erus`> you don't have gnu make?
05:25:18 <exeter> err... should I? I don't think so. if I type make it tells me "unrecognized command"
05:25:21 <hpc> there still exist linux distros that don't have make by default?
05:25:24 <int-e> windows probably, perhaps a haskell platform bundle?
05:25:32 <exeter> yes, I'm on win
05:25:42 <exeter> glasgow
05:25:46 <erus`> search gnu make for windows
05:25:57 <erus`> i have it on windows :)
05:25:58 <exeter> thanks
05:26:25 <erus`> I'm sure there are better build systems to use though
05:26:48 <hpc> there's always a better build system lol
05:27:01 <hpc> (more accurately, there's always a less-shit build system)
05:27:28 <int-e> hpc: Ubuntu is an example from the Linux world, I think. (Since https://help.ubuntu.com/community/InstallingCompilers mentions that it installs make along with the compilers.)
05:28:16 <erus`> I just mean maybe there is a haskell centric one
05:29:05 <int-e> There's the Haskell Cabal, of course. (Not sure about "better", make and Cabal are uncomparable really.)
05:29:14 <exeter> ok, installed, so now it should recognise the "make" command from cmd, right?
05:29:18 <erus`> yes
05:29:32 <erus`> you will need to close and open any console windows
05:29:43 <erus`> and make sure make is in you %PATH
05:30:04 <erus`> exeter: whats in your Makefile?
05:30:17 <exeter> let me check
05:31:34 <exeter> http://hpaste.org/46577/makefile there erus`
05:32:14 <hpc> i understand someone is working on visual haskell
05:32:36 <erus`> exeter: It wont work properly, it uses *nix commands like 'rm'
05:32:38 * hackagebot xmlgen 0.4.0.0 - Fast XML generation library  http://hackage.haskell.org/package/xmlgen-0.4.0.0 (StefanWehr)
05:33:16 <erus`> exeter: it might build though. just not clean
05:33:23 <exeter> :( erus. So I go as usual "ghc --make file1.hs"?
05:34:41 <erus`> echo ghc file1.hs file2.hs > b.bat
05:34:46 <erus`> then just type b
05:35:27 <exeter> it works!
05:35:38 * hackagebot xmlgen 0.4.0.1 - Fast XML generation library  http://hackage.haskell.org/package/xmlgen-0.4.0.1 (StefanWehr)
05:35:41 <exeter> sneaky makefile file
05:36:54 <erus`> hurrah
05:38:52 <fenfrie> is there any happy description for c++ header files?
05:44:06 <zygoloid> fenfrie: you're looking for a grammar for c++? you will be better off writing bindings to an existing parser than rolling your own.
05:44:47 <zygoloid> you can't parse c++ without doing a substantial amount of typechecking and semantic analysis, since the parse rules depend on the types of identifiers found by name lookup
05:45:56 <erus`> fenfrie: did you post on stackoverflow? Someone else asked this
05:46:34 <zygoloid> using libclang or dehydra would probably be a reasonable approach
05:47:04 <erus`> is haskell use on the rise or am i going to be a bloody geeky-hipster if I continue learning it?
05:47:46 <magicman> Anyone know of a library to mess with Bayesian networks? A quick search through the package overview gives no result for "Bayes".
05:48:01 <hpc> erus`: if you are lucky, you could be both
05:48:10 <hpc> "i wrote in haskell before it was cool"
05:48:24 <hpc> :P
05:48:27 <erus`> haha
05:48:42 <fenfrie> erus`, no
05:49:01 <Entroacceptor> oh, be careful, there's not much time left
05:49:14 <Entroacceptor> actually, it's already underground-cool
05:49:38 <fenfrie> zygoloid, so they are no free gramma for c++? the problem is, i cant install libClang on my system with the newest haskell plattform
05:49:38 <yogsototh> Hi every one! I wanted to make an equality function between point in Cartesian and Polar system. But it seems impossible to have a function of type (===) :: (Eq a) => a -> b -> Bool, where a is a 'data' type. Like Cartesian2D Double Double.
05:49:59 <yogsototh> Then my question, a can really not refer to 'data' type?
05:51:28 <quicksilver> yogsototh: it can, as long as that type is an instance of Eq
05:52:16 <yogsototh> quicksilver: ah yes! Thank you! That was a newbie question.
05:52:27 <zygoloid> fenfrie: there are a few projects which have taken the approach of writing a grammar for a superset of c++, but fundamentally you can't parse (for instance) 'T<u,v>(w)' without knowing whether T is a template.
05:52:55 <quicksilver> zygoloid: well, or you parse a 'weaker' language which explicitly incorporates that ambiguity.
05:53:19 <quicksilver> although it's pretty horrible with the syntax/binop confusion
05:54:11 <zygoloid> yup. the clean syntax is yet another thing to be grateful of when writing haskell :)
05:54:29 <erus`> should 'cabal update' take a while?
05:56:48 <erus`> oh man
05:57:18 <erus`> SDL requires a unix compatabilty thing to install
06:11:15 <dcoutts> erus`: yes, currently cabal update downloads a 2Mb file, we've not made it incremental yet
06:21:27 <erus`> dcoutts: it took about 5 mins to complete
06:26:33 <dcoutts> erus`: yeah, it's especially annoying on slow connections :-(
06:26:43 <dcoutts> incremental updates would really help there
06:26:48 <fenfrie> i cant install libClang with cabal because i dont have llvm-config (i use mingw) can anybody help me, how can i add these?
06:26:57 <ketil> Any (very broad) class that lets me get some arbitrary element?
06:27:36 <geheimdienst> dcoutts, any plans how it will work? right now it's a big tarball of all the cabal files, istr. the incremental thing would use ...?
06:27:51 <Phyx-> yeah, I was just thinking the same.. how would it work
06:28:13 <ketil> (I have a function a -> Int, but need an a to pass to it.)  Something in Data.Dynamic or Typeable, or something?
06:28:23 <dcoutts> geheimdienst: incremental update would use an uncompressed tarball and use HTTP range requests to get the tail
06:28:34 <fryguybob> fenfrie: Just a second, I'll here.
06:28:42 <dcoutts> geheimdienst: plus a way to check that we have the correct checksum at the end
06:29:16 <dcoutts> geheimdienst: so that if the tarball is only appended to then it'll work, if it's rewritten fully then the checksum will be different and the client will do a full download.
06:29:36 <fenfrie> fryguybob: i wait :)
06:30:02 <geheimdienst> awesome design :) kudos for using http to the fullest
06:30:05 <geheimdienst> nice work
06:30:08 <dcoutts> geheimdienst: I was thinking of using the http header for md5 checksums, but few servers support it. So was thinking of just adding a 00-index.tar.md5 file
06:30:24 <dcoutts> geheimdienst: oh, thanks :-)
06:30:52 <dcoutts> so clients would try getting the 00-index.tar.md5 file, if that exists then they go for the incremental update, otherwise fallback
06:30:54 <geheimdienst> you mean the etag thingy?
06:31:09 <dcoutts> geheimdienst: no, a real md5 checksum header, it's in the HTTP spec, honest :-)
06:31:29 <dcoutts> Amazon S3 uses it for example
06:32:30 <dcoutts> geheimdienst: the idea is you'd do a http HEAD request on the 00-index.tar to get its md5
06:33:05 <dcoutts> geheimdienst: the problem is that apache has really poor support for the md5 header, it does no caching so has to read the whole file and hash it for each req
06:33:29 <HugoDaniel> haxml is over 1 year old
06:33:42 <HugoDaniel> is it dead ?
06:33:49 <dcoutts> so it'd only work well, for custom server impls, which negates the advantage of being able to stick a hackage archive on any server
06:34:16 <dcoutts> HugoDaniel: it's a lot older than 1 year, it's at least 10 years old :-)
06:34:38 <geheimdienst> interesting. hm ... could the last-modified header thingy help? apache should be able to check just the file's last modified date instead of the entire file contents
06:34:45 <dcoutts> HugoDaniel: so, no, it's not dead, it's just reached a degree of maturity
06:35:08 <dcoutts> geheimdienst: you'd hope so, but that's not what it actually does :-(
06:35:17 <geheimdienst> @slap apache
06:35:17 * lambdabot throws some pointy lambdas at apache
06:35:29 <dcoutts> geheimdienst: adding a .md5 file is not so bad
06:35:48 <sdf> hello
06:35:49 <geheimdienst> sure, it's pretty good. why not
06:35:57 <dcoutts> geheimdienst: want to implement it for us? :-)
06:36:06 * dcoutts is busy with other cabal hacking
06:37:10 <ketil> What is the "widest" set of types I can make an arbitrary value for?  I.e. I can do "fromIntegral 0", which gives a Num a => a.  How does CmdArg's "def" work?
06:37:48 <fryguybob> fenfrie: I'm making progress, but not quite there yet.
06:38:21 <geheimdienst> i'm a little uneasy if my skillz suffice :) but i will think about it for sure. i've previously looked at the cabal source a little ...
06:38:26 <geheimdienst> so i'll check it out and get back to you
06:38:26 <hpc> ketil: if you mean "what's the most polymorphic concrete value", then you are pretty much correct with your guess
06:38:56 <hpc> you need a typeclass function to decide what the concrete value will end up being
06:39:03 <fenfrie> fryguybob: this means?
06:39:33 <hpc> :t undefined -- this is the most polymorphic possible thing, but it's bottom, which doesn't count
06:39:34 <lambdabot> forall a. a
06:41:06 <dcoutts> geheimdienst: the code in question is in cabal-install, in Distribution.Client.Update + Distribution.Client.FetchUtils
06:41:19 <int-e> dcoutts: hmm, a bit racy. not a big issue for clients, but can a caching proxy end up with incoherent 00-index.tar.gz and *.md5?
06:41:44 <dcoutts> int-e: good question, I guess we'd want to compare last modified times
06:41:57 <dcoutts> so those headers would have to exist
06:43:09 <argiopeweb> What does the current status of Haskell -> GPU support look like? I remember hearing research being done, but I don't know how it turned out.
06:46:26 <fenfrie> where can i find a good docu. for libClang
06:48:15 <fenfrie> must i have installed libClang bevor i install the cabal package?
06:48:25 <fryguybob> yes
06:48:56 <fryguybob> fenfrie: http://llvm.org/releases/download.html#2.9   Clang Binaries for Mingw32/x86  should be the right one
06:53:42 <fenfrie> fryguybob: got these, now it runs upon i get: cannot find clang-c/Index.h ... install libClang
07:05:22 <gwern> > 0.01*0.01*300000000
07:05:23 <lambdabot>   30000.0
07:05:54 <gwern> > 0.001*0.0001*300000000
07:05:55 <lambdabot>   30.000000000000004
07:08:45 <hpc> > 0.001*0.0001*300000000 :: CReal
07:08:45 <lambdabot>   30.0
07:09:56 <savy> > 0.00007/0
07:09:57 <lambdabot>   Infinity
07:20:55 * hackagebot protocol-buffers 2.0.0 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.0 (ChrisKuklewicz)
07:20:57 * hackagebot protocol-buffers-descriptor 2.0.0 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.0 (ChrisKuklewicz)
07:21:54 * hackagebot hprotoc 2.0.0 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.0 (ChrisKuklewicz)
07:23:31 <mpiechotka> @pl \x -> f (\y -> return $! (x, y))
07:23:32 <lambdabot> f . ((return $!) .) . (,)
07:23:43 <mpiechotka> @pl \x -> f (\y -> return (x, y))
07:23:43 <lambdabot> f . (return .) . (,)
07:23:51 <matthew-_> Is there a version of modify that's :: MonadState s m => (s -> (a, s)) -> m a ?
07:25:07 <mpiechotka> matthew-_: Version of some sort (but the definition of return for some monad)
07:25:08 <erus`> > 1 / 0
07:25:09 <lambdabot>   Infinity
07:25:37 <erus`> one cannot simply divide by zero
07:25:37 <quicksilver> matthew-_: that's called (by some people) hoistState or just hoist
07:26:09 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2008-March/040890.html
07:26:28 <matthew-_> interesting. A quick hoogle finds getStdRandom having a similar type (albeit different monads et al)
07:26:58 <shapr> blackdog: y0
07:26:58 <matthew-_> I'm just surprised it's not in the std libraries... though I'm approaching this from erlang, not haskell, so I suppose the needs are likely different
07:28:47 <blackdog> shapr: heya mate
07:29:09 <shapr> blackdog: g'day!
07:29:24 <blackdog> am completely wired - i presented instigator at RORO tonight, and because i was riding my motorbike, i was drinking coke all night rather than beer
07:29:29 <blackdog> oops
07:30:05 <blackdog> the arduino project sounds cool. shall we say 17th as the deadline?
07:30:10 <blackdog> it's when jfredett started
07:30:35 <shapr> blackdog: Wow! So, who's littlebird?
07:30:43 <blackdog> marcus schappi
07:30:45 <shapr> blackdog: Sure, that works for me.
07:30:52 <quicksilver> @get-shapr
07:30:52 <lambdabot> shapr!!
07:31:00 <shapr> quicksilver: howdy!
07:31:04 <blackdog> he's got that and key options, the iphone dev house i work for
07:31:34 <shapr> Ok, I thought I'd heard of them, wasn't sure.
07:32:22 <fryguybob> fenfrie: I'm not having much luck.  I'm getting linking errors when it tries to use the libclang.  It is probably just a matter of ensuring the right libs are used, but I don't know which ones they should be.
07:32:46 <blackdog> shapr: anyway, they sell a bunch of arduino stuff, so they like to blog about cool projects so they can sell more arduino stuff:)
07:33:03 <shapr> Makes sense to me... now if only I can integrate Haskell and the Arduino ...
07:33:29 <arnihermann> does anyone know of work (viewable online) with SYB where the source language is large (many types and data constructors) -- program analysis, transformations, etc..
07:34:29 <blackdog> shapr: there's a c compiler, right? maybe you can use jhc?
07:34:31 <lifthrasiir> [A
07:34:39 <lifthrasiir> oops.
07:34:59 <shapr> blackdog: Hm, good point
07:36:29 <shapr> Or I could try atom
07:36:51 <argiopeweb> blackdog: It's technically a c++ compiler.. </nitpick>
07:37:16 <blackdog> argiopeweb: for arduino?
07:37:20 <blackdog> i haven't done a lot with it, tbh.
07:37:29 <blackdog> made a few lights go flashy-flashy
07:37:32 <Axman6> i only found out it was C++ recently
07:37:49 <argiopeweb> blackdog: Yep.
07:37:56 * hackagebot syntactic 0.2 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.2 (EmilAxelsson)
07:38:08 <blackdog> Axman6: heya mate. what're you doing up so late?
07:38:08 <Axman6> need to play more with my Arduino, looking at buying a GPS module for it
07:38:23 <Axman6> just got home, been watching dexter at sarah's
07:38:30 <shapr> @hackage atom
07:38:31 <lambdabot> http://hackage.haskell.org/package/atom
07:38:47 <ion> I’ve been meaning to try out Atom with Arduino.
07:38:49 <blackdog> ah, nice. btw, started watching game of thrones yet?
07:38:59 <shapr> I wonder if I could write a network stack with Atom? hmmm
07:39:25 <Axman6> never heard of it
07:40:07 <companion_cube> it's synchronous, so networking seems hard, isn't it ?
07:40:25 <blackdog> Axman6: series based on george rr martin's novels. fantasy, no magic, some fantastic creatures.
07:40:35 <Axman6> i couldn't figure out how to use Atom from the tutorials I've seen
07:40:45 <Axman6> righto, worth checking out then?
07:40:47 <shapr> Does anyone have Atom tutorials?
07:40:49 <blackdog> Axman6: sex and gore and sarcastic dwarfs (as in midgets/little people, not axe-wielding beardies)
07:40:56 <Axman6> heh
07:41:43 <Entroacceptor> awesome books, great series
07:42:22 <shapr> blackdog: Ok, I think my next weekly project will be a better Atom tutorial.
07:42:37 <blackdog> Axman6: btw, do you want to join me and shapr and jfredett in our windmill-tilting?
07:42:49 <Axman6> what're you doing?
07:43:06 <argiopeweb> Don Quixote reenactments?
07:43:28 <shapr> Nah, we're using The Stewart Method as described by dons
07:43:45 <shapr> http://www.shimweasel.com/2011/05/08/the-stewart-method-how-not-to-suck
07:43:49 <Axman6> heh, i see.
07:43:58 <Axman6> yeah i saw that the other day
07:44:02 <shapr> And now - http://www.shimweasel.com/2011/05/09/project-a-week-club
07:44:13 <blackdog> Axman6: i was so annoyed with myself. front page of hacker news and my blog falls over
07:44:19 <Axman6> ha
07:44:22 <blackdog> because it was horrifically badly put together
07:44:25 <Axman6> where's it hosted?
07:44:32 <Axman6> did you write it?
07:44:39 <blackdog> on my ec2 slice
07:44:43 <blackdog> no, it's a typo blog
07:44:59 <Axman6> ah
07:45:01 <blackdog> but the caching was broken, and it was running 10 rails instances where it should really have been running one or two
07:45:14 <blackdog> OOM-killer got sshd and it was all over
07:45:39 <Axman6> ouch
07:45:58 <blackdog> serves me right for posting before i go to bed, really
07:46:07 <blackdog> but i wasn't expecting anyone to read it:)
07:46:33 <Axman6> it had reference to the don in it, what did you expect?
07:48:08 <blackdog> i thought he only appeared if you said "you can't make this run fast in haskell" three times in the mirror
07:48:24 <blackdog> his website-killing prowess is new to me
07:48:37 <Axman6> people want to know his secret sauce, and you gave it to him
07:48:43 <Axman6> them*
07:48:53 <Axman6> and you paid dearly for it
07:49:10 <dankna> hm
07:49:16 <dankna> if I say that three times fast, will he appear and optimize my code?
07:49:31 <dankna> it allocats 400 megs every 1.5 seconds and I need it to not do that
07:49:40 <Axman6> only if you say it on stack overflow, his powers are strong, but limited
07:49:41 <Botje> wow
07:49:43 <dankna> drat
07:50:34 <blackdog> dankna: http://ro-che.info/ccc/02.html
07:50:51 <dankna> haha yeah, I saw that
07:51:28 <blackdog> Axman6: aaaanyway, we've got together to write a project a week or face public shaming
07:51:53 <Axman6> heh. well, uni is somewhat in the way at the moment
07:52:20 <blackdog> Axman6: more than 40 hours a week? :)
07:52:35 <Axman6> no... single course this semester.
07:52:41 <Axman6> what sort of projects?
07:52:47 <blackdog> anything you like
07:52:59 <blackdog> the only constraint is that it has to do something useful, and it has to be finished ina week
07:53:06 <argiopeweb> blackdog: Hmm, I picked up that post in a random google search last night. Apparently having reddit linking you is good for your pagerank.
07:53:13 <savy> r network.
07:53:22 <dankna> those constraints seem mutually exclusive, depending on how realistically "useful" is defined...
07:53:27 <blackdog> Axman6: http://www.shimweasel.com/2011/05/09/project-a-week-club#comments has three of the projects.
07:53:47 <blackdog> dankna: well, the first one i did was Instigator, a project-starting project
07:53:57 <Axman6> well, the one that somewhat interests me is how easily you can rewrite most of the common unix utils in haskell. I wrote tee (again) the other day using the new IterIO package
07:54:06 <dankna> seems like a worthy goal.  although what I could use is a project-finishing project.
07:54:10 <blackdog> it's really just plumbing - sets you up with a basic haskell template, a github project, and a jenkins project
07:54:22 <dankna> yeah, I see
07:54:34 <Axman6> my problem with that project is that i have no motivation to use those tools once written
07:54:38 <shapr> Axman6: So your project for this week is a replacement for cat?
07:54:46 <argiopeweb> Axman6: Rewrite all the GNU apps (shell too) and release them BSD3.
07:54:49 <argiopeweb> :P
07:54:50 <blackdog> dankna: project-a-week is the project-finishing project :)
07:55:11 <dankna> blackdog: haha fair
07:55:19 <blackdog> Axman6: it's probably a good idea to choose something that's actually interesting to you
07:55:23 <blackdog> or helpful to someone
07:55:35 <Axman6> yeah, that's where it gets hard =)
07:55:38 <blackdog> one example - haskell webscraping libs are a bit fail
07:55:40 <shapr> And if you start small, you can be sure you have time to finish
07:56:07 <blackdog> something like mechanize or even restclient in haskell would be pretty cool
07:57:47 <Axman6> blackdog: by the way, I'm looking at buying one of these: http://leaflabs.com/store/
07:57:58 <Axman6> ARM powered Arduino compatible board
07:58:24 <blackdog> Axman6: what do you want to build?
07:58:35 <Axman6> that I don't know yet...
07:58:45 <jmcarthur> are there any popular-ish packages on hackage offering type classes for commutative monoids and/or commutative monads?
07:58:57 <Axman6> my input and output devices are quite limited
07:59:19 <Axman6> though... an interesting one might be a GPS powered NTP server... no idea how difficult that would be however
08:00:43 <adamvh> @src (==>)
08:00:43 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:00:45 <shapr> Axman6: Your one-week project could be to write a GPS to serial sketch?
08:01:08 <dankna> Axman6: it looks to me like that board has a USB A female socket, despite (according to its specs) operating only in device mode and not in host mode.
08:01:10 <Axman6> that's more like a one hour project, Arduino already comes with it all
08:01:28 <Axman6> dankna: hmm?
08:01:31 <dankna> the Amicus18 (Arduino-form-factor PIC board) that I have does the same thing, it's kinda annoying because it requires a custom cable
08:01:35 <shapr> Axman6: That also outputs the current time as well as location?
08:01:48 <dankna> as far as I can tell they designed it that way to make you think it can operate in host mode
08:01:57 <Axman6> shapr: what, what I'd write or the GPS module?
08:02:02 <dankna> I'm sure it's a fine board, but little things like that bug me, haha
08:02:11 <Wooga> Hello, I am new to Haskell and I want to write own BrainFuck interpreter on it in order to study. But I don't know how to make interpreting part as pure as possible: what should i do with such BrainFuck-actions like reading from standart input or writing to standart output? Is there a way to implement them not making whole interpreter impure?
08:02:36 <blackdog> Wooga: you could use something like 'interact'
08:03:07 <blackdog> so you're regarding your interpreter as a mapping from lists of strings to lists of strings
08:03:28 <blackdog> then you can have a trivial IO shell, and all the insides are pure
08:03:29 <shapr> Axman6: I dunno, I guess it seems to me if you can hook up a GPS module easily, you can also dump the time out the serial port.
08:03:38 <Wooga> blackdog: thanks, i'll try that
08:03:51 <Axman6> shapr: sure, that's easy enough. i was looking at doing it over Ethernet
08:04:22 <shapr> Axman6: break it up into weekly pieces?
08:04:40 <Axman6> well, it's too expensive for now anyway
08:05:30 <Axman6> my current project should be my parallel systems assignment -=
08:06:39 <Axman6> oh nice, the Maple board comes with a version of the arduino IDE
08:07:13 <jonkri> @undo do chan <- liftIO newChan; let s' = putSession s (session chan); ((), s'') <- runStateT c s'; runStateT (stateLoop chan) (state s'' chan); return ()
08:07:13 <lambdabot> Unbalanced parentheses
08:07:22 <jonkri> @undo chan <- liftIO newChan; let s' = putSession s (session chan); ((), s'') <- runStateT c s'; runStateT (stateLoop chan) (state s'' chan); return ()
08:07:23 <lambdabot> Unbalanced parentheses
08:07:27 <jonkri> oh
08:07:57 <dankna> Axman6: I found a photo from a different angle which makes it clear it's USB-Micro-B, so disregard my complaint :)
08:11:38 <Silvah> Wooga: but for decent performance you'd want to make the interpreter impure anyway.
08:12:22 <Wooga> maybe go further and write it in a C ? :D
08:13:03 <blackdog> Silvah: if you're writing a performance-critical brainfuck interpreter, you have bigger problems than i know how to solve
08:14:26 <Silvah> I was once playing with this kind of stuff and my interpreter in Haskell was, surprisingly, slightly faster than its C equivalent.
08:14:39 <Wooga> hmm
08:15:04 <Wooga> maybe you didn't used any paralell-ish stuff in C, that is on by default in Haskell?
08:15:24 <Wooga> or just not simply -O'ed gcc
08:15:36 <jonkri> i have a function operating in "m ()", a Chan of type "Chan (InternalEvent m s)" and a (working) line "runStateT (stateLoop chan) (state s' chan)" operating in this MonadIO monad. now, is it possible that i can turn that into an IO instruction, so that i can wrap it into a Control.Exception.try?
08:15:53 <Silvah> I doubt there's any parallel stuff turned on by default.
08:16:00 <argiopeweb> blackdog: #1, I'm more than mildly jealous that you've had the chance to have a beer with Don Stewart. #2, when you say (he says?) release a project every week, what defines "project"? I mean, a project can be a relatively large undertaking. When we talk about large development stuff, does working subset qualify?
08:16:11 <jonkri> when i try to liftIO it for example, i get this:
08:16:12 <jonkri>     Expected type: Chan (InternalEvent s m)
08:16:12 <jonkri>       Actual type: Chan (InternalEvent s IO)
08:16:22 <Silvah> Wooga: I didn't -O'ed GCC, because I wasn't using GCC ;)
08:16:22 <blackdog> argiopeweb: i shared a cubicle with him at UNSW
08:17:02 <argiopeweb> blackdog: I'm guessing he was instrumental in getting you into Haskell... That, or you used it at the univ.
08:17:03 <blackdog> i think the definition of project is something that you can release as a chunk
08:17:12 <Wooga> Silvah: hmm, quite unusual. C-source which wasn't compilled by GCC/MinGW...
08:17:24 <blackdog> argiopeweb: nah, we were just there at the same time. in manuel chakravarty's PLS group...
08:17:35 <Silvah> Wooga: it happens all the time on Windows ;)
08:17:37 <blackdog> argiopeweb: which i know is a dodge.
08:18:00 <blackdog> if you can add a full feature to a piece of software, i think that'd count
08:18:12 <argiopeweb> heh...
08:18:17 <argiopeweb> That would do it too...
08:18:25 <Wooga> Silvah: why not cross-compile with MinGW on some *nix?
08:18:28 <blackdog> argiopeweb: i know don did a lot of haskell wrappers of c libraries for hackage
08:18:49 <blackdog> so he got his methodology down, especially with FFI stuff
08:18:57 <argiopeweb> I'm sure.
08:19:15 <Silvah> blackdog: well, writing a non-naive interpreter is a nice exercise, after all, it doesn't have to be performance-critical by any means.
08:19:33 <blackdog> and i think a big part of it is working within the constraints and getting better and faster so you can accomplish more in that limited time.
08:20:02 <Silvah> Wooga: just because it's not the best idea? You wanna make a Windows program? Compile it under Windows, using well-supported tools.
08:20:06 <blackdog> Silvah: depends what you're trying to achieve, i think.
08:20:16 <djahandarie> agustuss's BASIC DSL ended up being pretty damn fast
08:20:20 <Wooga> Silvah: why not make cross-platform software then?
08:20:26 <blackdog> i'm a big fan of the just-barely-smart-enough school
08:20:37 <argiopeweb> I personally couldn't release a usable product in Haskell every week at this moment. I'm not comfortable enough with the language/idioms as of yet.  Every other week is probably doable though.  I can drop it back as my 40hr/week work load decreases and my mastery of Haskell increases.
08:21:02 <argiopeweb> djahandarie: But it encodes straight to LLVM, doesn't it?
08:21:48 <blackdog> argiopeweb: every second week is better than nothing :) could you reduce scope even more, though?
08:21:54 <Wooga> if you are wrtiting something crossplatform it is much easier to use *nix development tools and compile all the stuff for all arch'es on the same *nix
08:22:25 <blackdog> for instance, I wrapped cmph a while ago - it's about a page of code and 2 entry points. trivial, in other words
08:22:47 <blackdog> but it does something useful. maybe just pick a library you like from C and wrap, or one from ruby/perl and port?
08:22:59 <Silvah> Wooga: instruction sets differ. executable file formats differ. Syscalls differ. It's not possible to make a single cross-platform native binary. If you meant that the code should be cross-platform, then my words still apply - it's generally a nice idea to use mature and well-supported tools. And MinGW only recently started to look like something that may become mature and well-supported in future
08:23:10 <blackdog> argiopeweb: anyway. feel free to chuck a project plan up on http://www.shimweasel.com/2011/05/09/project-a-week-club#comments :)
08:24:09 <argiopeweb> blackdog: I could release the same scope weekly, but it'll be totally unmaintainable. ;)
08:25:20 <blackdog> argiopeweb: heh. well, even that can be ok sometimes
08:25:36 <blackdog> the slightly more business-oriented side of this is website-a-week
08:25:56 <blackdog> where you're really just throwing things against the wall to see what sticks
08:26:14 <argiopeweb> rofl...
08:26:27 <Wooga> Silvah: well, how do you compile for nix, mac and windows at the same time on windows host machine?
08:26:42 <Silvah> Wooga: and Intel compiler is believed to be the best optimizing compiler (with GCC coming close second, if you gonna try some tinkering with optimization flags), hence I used it rather than GCC ;)
08:26:51 <argiopeweb> 1) Install Yesod. 2) Code genetic algorithm. 3) ... 4) Profit!
08:26:52 <Silvah> Wooga: the same way as you would, using a cross compilers.
08:26:58 <Silvah> s/a//
08:27:22 <jonkri> is it possible to run an m a action (where m is an instance of MonadIO) in the IO monad?
08:27:32 <Axman6> my experience with ICC is limited, but GCC did a better job than ICC did
08:28:09 <argiopeweb> blackdog: And I think I need to grok monad tranformers before I get too into things. :P
08:28:21 <Wooga> Silvah: i am shaking in fear when thinking about making cross-compile environment for windows; without such tools as crossdev
08:28:23 <Axman6> jonkri: there should be some function that runs the specific instance of MonadIO in IO. I don't believe it's something defined as part of the MonadIO class though
08:28:36 <blackdog> argiopeweb: *shrug* you can go a long way without knowing the arcana.
08:28:58 <Silvah> Wooga: what's that "crossdev"?
08:29:01 * hackagebot Paraiso 0.0.0.0 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.0.0.0 (TakayukiMuranushi)
08:29:03 <blackdog> i wrote a bridge between ruby and haskell that really doesn't use anything more complex than a pair of typeclasses and a bit of FFI
08:29:10 <argiopeweb> blackdog: But, but... I have to know everything!
08:29:14 <argiopeweb> :P
08:29:17 <Silvah> Axman6: GCC still struggles with some things like automatic vectorization.
08:29:27 <Wooga> Silvah: its gentoo script making cross-compile environment by single 10-50 chars length commandline
08:29:27 <blackdog> argiopeweb: this is the monad tutorial disease
08:29:51 <blackdog> people think they need a graduate degree in category theory before they can approach the Holy REPL
08:29:54 <Axman6> well yeah, that's where ICC is best, it's had a lot more work on auto-vectorisation
08:29:55 <argiopeweb> Meh, monads are just math. I'm sure transformers are as well, I just haven't read the theory.
08:30:26 <jonkri> Axman6: any idea where i could look? (i'm looking at running a "m" runStateT call in IO)
08:30:27 <blackdog> i think it misses the point to say monads are just math
08:30:34 <blackdog> i mean, it's true, but irrelevant
08:30:45 <jonkri> i have checked State(T)
08:30:48 <Axman6> jonkri: wouldn't it be runStateT that does it then?
08:30:51 <blackdog> i prefer 'compiler-checked patterns' :)
08:30:54 <Axman6> :t runStateT
08:30:54 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
08:31:00 <Wooga> Silvah: and then you can simply use *emerge to install needed software/libs in this environment
08:31:18 <Axman6> here m is IO, so you end up with something of type IO (a, s)
08:31:21 <Silvah> blackdog: ah, gentoo.
08:31:25 <Silvah> crap
08:31:27 <Silvah> Wooga*
08:31:33 <argiopeweb> When I walk into Prof. X the theoretical CS doctor's office to talk about Haskell, it's math. :P
08:31:57 <jonkri> Axman6: i want to run "runStateT" in m, ending up with m (a, s), but want to wrap it in an IO function so that i can use Control.Exception.try on it... it sounds absurd, so i guess it's not possible
08:32:04 <argiopeweb> But you're right, I enjoy the theory so much that I have trouble separating it from practice, and thus get little coding done.
08:32:20 <Axman6> jonkri: I'm not sure i understand...
08:32:38 <Wooga> Silvah: i just didn't experienced anything easier to cross- or dist- compile
08:32:40 <argiopeweb> Though I did write an absolutely evil C function parser that scrapes headers last week... Without Parsec. :\
08:33:47 <Wooga> and more powerfull as well
08:33:49 <jonkri> Axman6: hmm... it's a little tricky to explain :) i'm making a "runStateT" call which operates in m, and has to operate in m. however, i want to use Control.Exception.try to catch any exceptions, but try requires an IO operation. calling runStateT in IO wont work, because some of the variables that it uses are "dependent" on m
08:34:03 <blackdog> argiopeweb: heh. everyone who hasn't tried thinks parsing c is easy:)
08:34:13 <webchat77> @hoogle (<>)
08:34:13 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
08:34:13 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
08:34:26 <webchat77> is (<>) = mappend defined anywhere?
08:34:53 <blackdog> argiopeweb: this made me laugh http://eli.thegreenplace.net/2011/05/02/the-context-sensitivity-of-c%E2%80%99s-grammar-revisited/
08:35:16 <Silvah> Axman6: but I have to admit that GCC's platform-independent optimizations are hard to beat, this is probably where GCC leaves other compilers in the dust.
08:35:28 <Axman6> jonkri: catchST s h = liftIO $ do {state <- catch (runStateT s); ...
08:35:30 <argiopeweb> blackdog: They've clearly never seen the C CFG...
08:35:52 <blackdog> argiopeweb: i don't think C has a CFG
08:36:05 <blackdog> it's context sensitive
08:36:20 <argiopeweb> blackdog: I've seen it done. I'll see if I can pull it up.
08:37:33 <blackdog> argiopeweb: http://eli.thegreenplace.net/2007/11/24/the-context-sensitivity-of-cs-grammar/ goes into a bit more detail
08:38:10 <blackdog> you have to keep track of the types as you go to know how to parse, basicalyl
08:39:22 <blackdog> anyway. probably time to pass out now. night.
08:39:42 * shapr waves
08:40:53 <argiopeweb> blackdog: Yeah, the version I saw was in GOLD, which is EBNF + regexp. Which really doesn't count as a CFG.
08:45:45 * byorgey waves back at shapr 
08:46:04 <shapr> byorgey: howdy!
08:46:21 <byorgey> shapr: how goes it?
08:47:09 <shapr> byorgey: Having fun, writing Python but thinking about Yesod :-)
08:47:16 <byorgey> hehe =)
08:47:46 <shapr> Also, I'm getting on board with the project-a-week club blackdog described in last week's blog post.
08:47:56 <shapr> byorgey: How's code for you?
08:48:28 <byorgey> project-a-week sounds intimidating to me.  But I was definitely inspired by that post in general.
08:48:41 <Caker_> hi
08:48:45 <byorgey> The general principle seems to be to publish stuff in smaller chunks more often, which is a good reminder for me.
08:48:47 <Caker_> Can somebody help me :D?
08:48:47 <shapr> howdy Caker_
08:49:06 <shapr> byorgey: Right, that's what I'm getting from it. Complete smaller chunks once a week.
08:49:08 <byorgey> shapr: code is great though =)
08:49:34 <shapr> Caker_: You must ask a question before you can get an answer.
08:50:01 <Caker_> okay: I am trying to use Happy (the parse generator) to interpret a small language
08:50:48 <shapr> Caker_: Great!
08:50:51 <Caker_> in the tutorial it suggested for the use of variables to make the parser return a function which takes what it calls an "variable environment" or something, basically a tuple of string, value
08:51:18 <argiopeweb> shapr: Deep
08:51:23 <Caker_> but this is not really ideal because what I am trying to do is have the ability to define a variable (any variable) and then print it out
08:51:31 <Caker_> So any tips on how to achieve this :D?
08:51:53 <shapr> argiopeweb: :-P How's code treating you? Are you writing any Haskell at the moment?
08:52:21 <shapr> Caker_: I haven't used Happy, have you looked for other examples online?
08:52:34 <Caker_> There seem to be none at all :(
08:53:11 <Caker_> Initially I was going to do the parser myself but it is too large a task
08:53:15 <argiopeweb> shapr: I'm knee deep in papers at the moment... Reading a research document on embedded DSLs and procrastinating about packing so that I can move in 3 days...
08:53:44 <shapr> Caker_: If nothing else, you could find the 'new' version of hackage that shows reverse dependencies.
08:54:01 <shapr> Caker_: Then find the Happy package and look for small hackages that depend on Happy?
08:54:11 <shapr> argiopeweb: Are you moving for a Haskell job?
08:54:15 <argiopeweb> Caker_: You've read through the website, right?
08:54:28 <argiopeweb> shapr: I wish... I'm moving closer to the University. :P
08:54:30 <shapr> Caker_: Writing parsers in Haskell is great fun.
08:54:35 <argiopeweb> Same old C++ job.
08:54:42 <shapr> Ah, too bad.
08:54:50 <shapr> argiopeweb: Haven't been able to sneak in Haskell?
08:55:08 <shapr> I think I'll be sneaking QuickCheck into this Python webdev gig.
08:56:12 <shapr> Caker_: The tutorial still sounds like the best approach to me. The tuple can hold lots of variables at once.
08:56:25 <argiopeweb> shapr: Still trying. Keep getting shot down. You'd think that an aviation-centric academic environment would like a mathematically provable, QuickCheck-able, language with built in code-coverage checking, but no...
08:56:46 <argiopeweb> I'd be interested in seeing how you were going to integrate QC with Python though.
08:57:32 <shapr> Last time I used Haskell for testing a Python webdev project, I used HUnit. But this time I'd like to do property style testing as is best done with QuickCheck.
08:59:22 <Caker_> shapr yeah but with a function after the fact I cant print a variable, then assign a value to it, and print it again and have that reflect
08:59:42 <argiopeweb> shapr: Using MissingPy?
08:59:51 <Caker_> I was hoping it would be a parser that returned a string of the imperative code (this of course forbids user input)
08:59:57 <shapr> Caker_: I'm confused... do you have an hpaste I could read?
09:00:37 <jmcarthur> Caker_: have you looked at parsec?
09:00:50 <jmcarthur> not trying to answer your question at all. just giving an alternative to happy
09:01:01 <Caker_> shapr is because the way Happy works it creates the parser function in a dynamic way such that I can have it be not of a standard type like a parse tree but something like a string since you can specify the return value on the grammar definition itself
09:01:20 <Caker_> jmcarthus it is beyond what I am trying to do though :p
09:01:28 <jmcarthur> happy is way more complicated, IMO
09:02:01 <argiopeweb> jmcarthur: More complicated, but it does run faster.
09:02:09 <argiopeweb> Which is sometimes a concern.
09:02:13 <jmcarthur> argiopeweb: speed isn't what Caker_ was complaining about though
09:02:38 <jmcarthur> seems like Caker_ is just trying to keep things simple
09:02:43 <Caker_> ya it is not a concern of mine because
09:02:45 <jmcarthur> in which case parsec > happy, most of the time
09:02:50 <Caker_> my lexer (which I did myself) is super slow
09:03:24 <shapr> Caker_: I would strongly encourage you to try Parsec :-)
09:03:32 <Caker_> alright I will check it out
09:03:48 <shapr> Caker_: I wrote an RFC822 parser with Parsec in about a week.. that was one of my early Haskell projects.
09:05:29 * edwardk waves hello.
09:05:45 * argiopeweb waves back
09:05:51 * jmcarthur waves bananas
09:06:16 * shapr throws kata programs at edwardk
09:06:22 * Lemmih stands in the corner, wishing he was more social.
09:06:34 <shapr> argiopeweb: Oh hey, I found my previous HUnit code! http://www.scannedinavian.com/~shae/Test_TutorRing.hs.html
09:06:34 <argiopeweb> shapr: I haven't looked as much at quickcheck as I should have, in all honesty. How does its methodology differ from the traditional Unit check provided by HUnit?
09:06:46 <argiopeweb> PINK!!!
09:06:48 * edwardk catches them and forwards them to pchiusano
09:06:49 <shapr> haha
09:07:02 <shapr> argiopeweb: That's a much nicer response than edwardk had when he saw my emacs color theme.
09:07:13 <shapr> edwardk said something like MY EYES ARE BURNING!
09:07:16 <argiopeweb> Yeah, I couldn't deal with that....
09:07:25 <edwardk> shapr: mine was more 'MY EYES!!!!'
09:07:26 <jmcarthur> argiopeweb: with QC you give a property and it generates test cases for it at runtime. much better coverage than your typical unit test with static test data
09:07:37 <edwardk> hah
09:07:52 <argiopeweb> Purple on green on pink for string literals is melting my corneas.
09:07:57 <edwardk> heya lemmih, i had some lhc questions, now i need to remember what they are
09:07:57 <shapr> @check x * y == y * x
09:07:58 <lambdabot>   "Falsifiable, after 0 tests:\n"
09:08:01 <jmcarthur> argiopeweb: it lends itself to a somewhat more rigorous and mathematical approach to testing
09:08:23 <shapr> @check x * y == y * x :: Int
09:08:24 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:08:26 <shapr> :-/
09:08:32 <jmcarthur> @check \x y -> x * y == (y * x :: Int)
09:08:33 <lambdabot>   "OK, passed 500 tests."
09:08:37 <shapr> aha
09:08:43 <argiopeweb> jmcarthur: So it's a dynamic unit test generator based on logical premises
09:08:44 <edwardk> shapr: guessing it is using the x and y that are in scope which are the named ones
09:08:44 <shapr> @check \x y -> x * y == (y * x :: Float)
09:08:45 <jmcarthur> @check \x y -> x * y == (y * x :: Double)
09:08:45 <lambdabot>   "OK, passed 500 tests."
09:08:46 <lambdabot>   "OK, passed 500 tests."
09:08:51 <shapr> er, huh?
09:08:52 <jmcarthur> meh, eventually wouldn't pass for Double
09:08:57 <jmcarthur> or Float
09:09:00 <shapr> IEEE754 sez fail
09:09:05 <jmcarthur> hard to find cases where it fails
09:09:13 <edwardk> > foldl (+) a [b,c,d,e]
09:09:14 <lambdabot>   a + b + c + d + e
09:09:27 <shapr> @check \abc def -> abc * def == (def * abc :: Float)
09:09:28 <lambdabot>   "OK, passed 500 tests."
09:09:33 <shapr> @check \abc def -> abc * def == (def * abc :: Double)
09:09:34 <lambdabot>   "OK, passed 500 tests."
09:09:35 <argiopeweb> hehe...
09:09:38 <shapr> wot?
09:09:43 <edwardk> shapr: note the unbound variables there
09:09:43 <jmcarthur> @check \x y z -> (x * y) * z == (x * (y * z) :: Float)
09:09:44 <lambdabot>   "Falsifiable, after 6 tests:\n-2.5\n-1.3333333\n-2.8\n"
09:09:50 <jmcarthur> @check \x y z -> (x * y) * z == (x * (y * z) :: Int)
09:09:51 <lambdabot>   "OK, passed 500 tests."
09:09:57 <shapr> jmcarthur: aha!
09:10:14 <argiopeweb> @check  \x y -> (x - y) == (y - x)
09:10:14 <lambdabot>   "Falsifiable, after 1 tests:\n0\n1\n"
09:10:20 <jmcarthur> (Float multiplication is not commutative either. just unlikely for QC to find a failing case)
09:10:52 <shapr> argiopeweb: So you see why QC is likely to find more errors than unit testing?
09:11:19 <shapr> QuickCheck is rigorous structured fuzzing.
09:11:24 <argiopeweb> shapr: Indeed, though I'm interested in seeing how it handles edge cases.
09:11:30 <shapr> Especially if you go with SmallCheck and those guys.
09:11:32 <shapr> argiopeweb: like what?
09:11:37 <jmcarthur> QC also does nice things like narrowing. if it finds a failing case, it attempts to simplify the inputs before reporting them to you to give you a simple test case for studying the bug
09:11:55 <shapr> Yes! Shrink is awesome!
09:12:01 <jmcarthur> *shrinking
09:12:24 <argiopeweb> shapr: I have function that misbehaves around 0 and 100. In unit test, I write checks for 99, 100, 101 and similar for around 0. In QC, do I just expect it to check?
09:12:26 <shapr> And ever since Heffalump challenged me to do test-driven-development with QuickCheck 1, QuickCheck 2 has that ability built-in!
09:12:33 <jmcarthur> QC doesn't handle edge cases any better than normal unit tests, unfortunately, at least not when they occur far away from "small" values for a type
09:12:58 <Silvah> @check \_ _ -> False
09:12:59 <lambdabot>   "Falsifiable, after 0 tests:\n()\n()\n"
09:13:06 * hackagebot rfc3339 1.0.4 - Parse and display time according to RFC3339  http://hackage.haskell.org/package/rfc3339-1.0.4 (HugoGomes)
09:13:17 <jmcarthur> argiopeweb: QC is likely to find things in a range like that fairly often
09:13:18 <quicksilver> jmcarthur: if you know what the edge cases are you can write Gen's which tend to generate them.
09:13:20 <edwardk> the only non-commutativity in ieee floating point is with regards to NaN payloads
09:13:31 <edwardk> haskell doesn't distinguish between different NaNs though
09:13:37 <jmcarthur> quicksilver: right, but then QC isn't actually helping you *discover* those edge cases
09:13:42 <quicksilver> jmcarthur: indeed not.
09:13:47 <edwardk> so you should be fine with commuting doubles and floats
09:13:48 <jmcarthur> edwardk: huh?
09:13:53 <quicksilver> although that's sort-of what shrinking does.
09:14:00 <jmcarthur> oh right
09:14:01 <jmcarthur> nevermind
09:14:07 <jmcarthur> i was thinking -0 and +0
09:14:07 <shapr> wait what?
09:14:10 <edwardk> x * y = y * x -- unless x and y are both a NaN
09:14:24 <edwardk> in which case you'll still get a NaN but you'll get a different payload
09:14:24 <quicksilver> before I knew about QC2 shrinking I was writing my own shrinkers based on my domain knowledge of the problem.
09:14:28 <argiopeweb> Hmm, well, I'll read up on it. Last time I used it was via the RWH examples which are all QC 1
09:14:37 <jmcarthur> edwardk: don't you mean unless *either* of them are NaN?
09:14:43 <shapr> argiopeweb: qc2 is far more awesome!
09:15:01 <edwardk> jmcarthur: nah, i mean unless both. if only one is, you'll still propagate the particular NaN\
09:15:05 <argiopeweb> shapr: I gathered that from the major version upgrade with no backwards compatibility. :P
09:15:12 <jmcarthur> > (0/0) * 1 == 1 * (0/0)
09:15:12 <lambdabot>   False
09:15:24 <jmcarthur> NaN /= NaN
09:15:28 <edwardk> jmcarthur: you receive the same answer though
09:15:31 <argiopeweb> shapr: Since you mentioned it, does it lend itself to test-driven development?
09:15:38 <jmcarthur> edwardk: i just mean the test case fails
09:15:43 <edwardk> the = is rewrite equality not == equality
09:15:55 <jmcarthur> oh i didn't notice that you did that
09:16:22 <edwardk> and i mean that commuting floating point arguments for * is a sound rewrite rule if you don't distinguish NaN payloads ;)
09:16:33 <jmcarthur> (IMO = should imply ==, though)
09:16:47 <edwardk> alas == is broken
09:18:09 <edwardk> otherwise you could use a short cut like checking reallyUnsafePtrEquality first =(
09:20:42 <djahandarie> That sounds really unsafe
09:21:00 <edwardk> =)
09:21:50 <djahandarie> What are Haskell Arrows categorically?
09:22:02 <shapr> argiopeweb: Yes, QC2 exposes the (seed,size) tuple used to generate a failing test case.
09:22:12 <shapr> djahandarie: weak freyd categories
09:22:13 <djahandarie> Maybe without 'arr' because I suspect that makes them useless
09:22:41 <edwardk> djahandarie: aka 'crap' ;)
09:23:05 <djahandarie> lol
09:23:34 <edwardk> djahandarie: if you want a more principled approach you might just want to start at from a cartesian closed category
09:23:44 <edwardk> er s/at //
09:24:30 <shapr> argiopeweb: The shrink function takes the (seed,size) input and decrements size before checking the property again. If the property fails again, you have a smaller value that still demonstrates the error.
09:25:25 <shapr> argiopeweb: I hacked up QC-TDD before shrink was available, but I did something similar, I saved (seed,size) to an external file and ran those inputs again on the next run.
09:26:01 <djahandarie> It'd proving to be hard to find anything about Freyd categories that isn't also mentioning Haskell Arrows
09:26:03 <shapr> I never got around to saving failing inputs as permanent test cases, that would require lots more support code.
09:26:28 <djahandarie> Are all Freyd categories cartesian closed?
09:26:46 <djahandarie> It seems to me that they would be but I don't have a proof
09:27:16 <argiopeweb> shapr: Does QC2 save failing, or is it mainly providing the shrink'ed tuple for hand-testing as you fix the code?
09:27:18 <shapr> I'd like to save the input and the generator together somehow, or run the input through the generator and save that.
09:28:04 <edwardk> djahandarie: arr gives you an exponential. (,) is your product
09:28:09 <shapr> argiopeweb: I know QC2 gives access to the tuple, I think some other frameworks (test-framework?) mentioned something about saving failing inputs. I don't know how it's done though.
09:28:26 <edwardk> djahandarie: ArrowApply lets you use the arrow itself as your exponential
09:28:37 <edwardk> so, yes.
09:28:37 <jmcarthur> > 1e-323 * 1e323 * 1e-323 == (1e-323 * 1e-323 * 1e323 :: Double)
09:28:38 <lambdabot>   False
09:28:47 <edwardk> the proof is in the arrow laws
09:28:49 <jmcarthur> oh wait there's a NaN in there, nevermind
09:28:49 <shapr> argiopeweb: If you find a framwork that does that, I want to know :-)
09:29:09 <jmcarthur> oh but it's being compared against Infinity
09:29:21 <jmcarthur> > 1e-323 * 1e-323 * 1e323 :: Double
09:29:21 <lambdabot>   NaN
09:29:25 <jmcarthur> > 1e-323 * 1e323 * 1e-323 :: Double
09:29:26 <lambdabot>   Infinity
09:29:26 <argiopeweb> Okay, I'll look into it. Got to finish reading the EDSL paper, read the chapter on monad transformers in RWH, pack my life into boxes, sell a bunch of furniture, and then I'll have time. :P
09:29:34 <argiopeweb> And I'll let you know if I find something.
09:29:42 <shapr> argiopeweb: Is your furniture being sold near North Alabama? I could use some :-)
09:29:42 <jmcarthur> ^^ edwardk
09:30:23 <argiopeweb> shapr: Central FL. Which part of N. AL? I've got relatives up there.
09:30:35 <jmcarthur> argiopeweb: shapr and i are in huntsville
09:30:36 <djahandarie> edwardk, if I wanted to get Arrow from a cartesian closed category, what would I need to add?
09:30:39 <jmcarthur> well, near it
09:30:50 <shapr> argiopeweb: Well, I'm in The Shoals, specifically Florence AL
09:31:12 <argiopeweb> Ah, okay. My grandparents have a farm up on Hobb's Island Rd.
09:31:15 * shapr checks http://www.haskellers.com/ for nearby ppl
09:31:19 <shapr> argiopeweb: Where's that?
09:31:21 <edwardk> > 1e-323 * (1e-323 * 1e323)
09:31:21 <lambdabot>   Infinity
09:31:32 <edwardk> >  (1e-323 * 1e-323) * 1e323
09:31:33 <lambdabot>   NaN
09:31:41 <shapr> argiopeweb: oh, Huntsville?
09:31:42 <edwardk> that is your associativity
09:31:45 <Eduard_Munteanu> What would be a representative language that has equirecursive types? Preferably something with an advanced type system like dependent types.
09:31:47 <edwardk> not the commutativity
09:32:01 <Eduard_Munteanu> So far I've encountered none.
09:32:01 <argiopeweb> shapr: Between Hunstville and Owen's Cross Roads
09:32:02 <shapr> SyntaxNinja: Oh hey! I'm going to Portland for a week!
09:32:07 <edwardk> you are associating, commuting then associating
09:32:07 <argiopeweb> Huntsville, even.
09:32:46 <SyntaxNinja> shapr: awesome! When are you coming here?
09:32:51 <jmcarthur> ah! i think i have a mental tendency that commutativity implies associativity
09:32:53 <edwardk> djahandarie: arr and first at most. probably just arr
09:33:13 <shapr> SyntaxNinja: End of July... my girlfriend is going to SockSummit, I'll just be wandering around.
09:33:30 <shapr> edwardk: whaat?
09:33:39 * shapr hits wikipedia
09:33:44 <djahandarie> edwardk, arr and first define an Arrow anyways :p
09:33:52 <edwardk> djahandarie: =)
09:33:58 <edwardk> hence why 'probably just arr' ;)
09:34:07 <SyntaxNinja> shapr: let's meet up! Are you bringing your unicycle?
09:34:07 <edwardk> i was just saying that every arrow gives you a CCC
09:34:13 <djahandarie> Right
09:34:18 <tg_> anyone have recommendations for lecture slides or books about denotational semantics?
09:34:20 <djahandarie> I'm wondering how to do it the other way around
09:34:26 <edwardk> not that you could add some simpler operation as a result.
09:35:07 <djahandarie> It feels like you should be able to
09:35:09 <chrsi> can someone help me with a simple haskell problem?
09:35:28 <edwardk> jmcarthur: mobiles aren't one of the usual structures we deal with. =) http://www.kestrel.edu/home/people/meertens/diverse/calc.pdf
09:35:28 <shapr> SyntaxNinja: Er, I don't know... I guess I could?
09:35:42 <shapr> chrsi: what's the simple problem?
09:35:52 <chrsi> how should I show this to you?
09:35:56 <shapr> chrsi: hpaste.org ?
09:36:09 <SyntaxNinja> shapr: well, not sure if it's absolutely necessary ;)
09:36:43 <shapr> SyntaxNinja: Did my unicycle have the 3.7" tire last time you saw it?
09:36:58 <chrsi> http://hpaste.org/46579/xml_simple_problem
09:37:14 <djahandarie> Someone was just riding a unicycle outside a couple hours ago
09:37:21 <tg_> djahandarie: terrorist!
09:37:29 <tg_> djahandarie: oh wait, you might not be in the US
09:37:39 <argiopeweb> 3.7"? That seems small...
09:37:42 <SyntaxNinja> shapr: but let's definitely hang out. maybe email me the dates you'll be around and we'll have a dinner or beer or what-have-you.
09:37:45 <djahandarie> I am in the US but that doesn't make sense to me
09:37:51 <shapr> SyntaxNinja: Sure, sounds good!
09:38:05 <tg_> djahandarie: anyone's behavior is out of the ordinary, they might be a terrorist!
09:38:10 <SyntaxNinja> shapr: I'm not sure I'Ve ever actually seen you ride the unicycle.
09:38:12 <shapr> argiopeweb: Nah, that's the tire width... diameter is 26" inside, and about 29" outside.
09:38:12 <djahandarie> Haha
09:38:30 <augur> can internal definitions be typed?
09:38:37 <augur> like, if you use a where or let?
09:38:40 <argiopeweb> shapr: That sounds more like it.
09:38:46 <shapr> augur: tried it?
09:38:46 <ccasin> augur: yep.  in fact, sometimes you have to
09:39:03 <augur> is it like... where g :: xfs;df ; g = ...?
09:39:22 <edwardk> djahandarie: sure but there are plenty of implications that go one way where the converse derives no benefit. consider Foldable and Traversable. Traversable implies Foldable, but having the Foldable definition gives you no help writing the Traversable
09:39:44 <Eduard_Munteanu> chrsi: you want to do a depth-first search and see how many nodes you visit
09:40:04 <Eduard_Munteanu> chrsi: just like with trees, in fact you have an n-ary tree
09:40:48 <shapr> chrsi: So, what's the problem you have?
09:41:05 <chrsi> Well the problem is, I am not too familiar with Haskel syntax. Its frustrating because he dropped this kind of problem on us out of no where
09:41:39 <chrsi> My professor. I could do this easily if it were in one of the languages I am familiar with, or even if it was in javascript, but not haskell
09:42:16 <Eduard_Munteanu> Ok, if you start writing the function, you'll see you get an XML. Which is either an Element String [XML] or a Text String
09:42:29 <chrsi> okay
09:42:33 <Eduard_Munteanu> Your function can pattern-match on the argument to see that.
09:42:51 <Eduard_Munteanu> f (Element str xml) = ...
09:42:58 <Eduard_Munteanu> f (Text str) = ...
09:44:18 <chrsi> holy crap
09:44:21 <chrsi> I see it, thank you
09:44:25 <Eduard_Munteanu> However your function must also know when counting started and keep the count around.
09:45:02 <argiopeweb> Eduard_Munteanu: The missile knows where it is at all times....
09:45:02 <Eduard_Munteanu> So your actual f :: XML -> Int will probably use an auxiliary function taking the current counter
09:45:46 <Eduard_Munteanu> (which you call from f starting at 0 or 1)
09:46:10 <Eduard_Munteanu> @protontorpedo
09:46:11 <lambdabot> Im really only a bash person and even then Im tin
09:46:17 <chrsi> just give it a second parameter (int) which is your starting value
09:46:31 <Eduard_Munteanu> Yep.
09:46:37 <chrsi> cool thank you
09:46:50 <argiopeweb> Eduard_Munteanu: Your "However your function must also know..." reminded me of it. Humorous USAF training clip. I'll see if I can find it.
09:46:51 <shapr> ?keal
09:46:52 <lambdabot> i want to invent white dye
09:48:04 <argiopeweb> http://asuwlink.uwyo.edu/~jimkirk/guidance.wav
09:49:46 <argiopeweb> shapr: Just got a chance to actually look over that HUnit code. Clever stuff.
09:50:32 <shapr> argiopeweb: Five years after the fact it looks pretty pitiful :-)
09:51:48 <argiopeweb> shapr: Keeping in mind that I've been aware of the functional paradigm for 11 months and programming haskell for ~6, it's not that bad. ;)
09:52:06 <argiopeweb> And absolutely captivated by it for 10, I might add.
09:52:18 <argiopeweb> It being the functional paradigm, not Haskell.
09:52:31 <stepkut> shapr: boing
09:52:38 * shapr h0ps towards stepkut
09:52:42 <shapr> stepkut: Are you going to OSCON?
09:52:47 <stepkut> shapr: nope
09:53:04 <shapr> I'm thinking of disorganizing a sekrit Haskell track for OSCON
09:53:21 <stepkut> heh
10:02:00 <argiopeweb> Anyone have experience with Haskell + Emacs + Flymake and its interaction with the hierarchical module name and/or cabal files?
10:07:12 <shapr> Oh cool, OSCON has a workshop on doing test-driven-development with FP, I'd love to show up and heckle the speaker...
10:08:07 <argiopeweb> rofl...
10:08:18 <argiopeweb> Why must you resort to heckling?
10:10:08 <shapr> argiopeweb: I'm just difficult like that :-)
10:10:35 <argiopeweb> hehe
10:11:20 * argiopeweb has just realized that he can switch to Dvorak now that he doesn't constantly use {}
10:11:36 <argiopeweb> Though I should have switched even with... It's not like the're very far away.
10:12:16 <shapr> Have you tried programmer's dvorak?
10:12:29 <jmcarthur> edwardk: interesting slides. thanks for the link
10:13:06 <argiopeweb> shapr: I have not, though I'm actually reading about it as we speak.
10:13:33 <argiopeweb> Ugh, = is on 6...
10:14:52 <argiopeweb> I'm not sure the positioning of : in Dvorak is optimal for programming in haskell either, though I may just be looking at it from a biased QWERTY point of view.
10:16:28 <nyingen> argiopeweb: I use standard dvorak...haven't had any problems doing programming
10:16:40 <nyingen> location of '=' is slightly more convenient in dvorak if that helps offset the {} thing for you
10:17:31 <Caker_> So I did it with a tuple but...
10:17:56 <Caker_> the parser returns a function that takes a list of pairs of variable and value
10:18:07 <argiopeweb> nyingen: It mainly depends on what language I'm using... I use C++ for work, Java for classes, and Haskell for everything else, so my needs tend to change throughout the day.
10:18:09 <Caker_> I am trying to apply it to itself within the grammer because of the recursive rule
10:18:20 <argiopeweb> Overall I'd say I use = more than {} though.
10:18:27 <Caker_> I get the error "cannot construct the infinite type: t5 = t6 -> t5
10:18:29 <Caker_> any ideas?
10:19:07 <shapr> argiopeweb: I was thinking about going one stop towards programmer's dvorak by just swapping numbers and symbols.
10:19:11 <shapr> er, 'one step'
10:19:13 <nyingen> argiopeweb: I'm forced to use java sometimes. improved location of '.' in that case is a win :)
10:19:32 <Caker_> oh nvm I got it
10:20:34 <nyingen> then again maybe dvorak helps more with Java (if at all) since Java is full of stuff like 'doTheThingWithFooAndBar().executeWithStrategy(StrategyFactory.createStrategy(defaultStrategy)' versus haskell 'f x y'
10:20:40 <argiopeweb> nyingen: w position, right?
10:20:47 <nyingen> 'e' position
10:20:48 <shapr> e
10:20:57 <shapr> I've been using dvorak since 1992
10:21:03 <argiopeweb> Ah, w is comma.
10:21:21 <nyingen> I switched in 2001
10:21:28 <shapr> ',.pyfgcrl/=\ \n aoeuidhtns- \n ;qjkxbmwvz
10:21:30 <argiopeweb> nyingen: The brain-damage is worse than the hand damage, regardless.
10:21:36 <nyingen> heh, true
10:21:54 <argiopeweb> nyingen: I only touch that language because I'm forced.
10:22:35 <argiopeweb> Yeah, I can see ; being in an odd place for c-like languages as well...
10:22:45 <Caker_> yay I did it :D
10:22:50 <Caker_> okay that's enough for today
10:22:52 <argiopeweb> Might have to turn on auto-; in Emacs. :P
10:22:55 <Caker_> thanks for all the help everyone :D
10:27:53 <ekipan> > take 31 (cycle "lo")
10:27:54 <lambdabot>   "lololololololololololololololol"
10:28:24 <argiopeweb> > concat $ take 3 $ cycle '.'
10:28:24 <lambdabot>   Couldn't match expected type `[a]'
10:28:25 <lambdabot>         against inferred type `GHC.Types...
10:28:34 <argiopeweb> *cough* fail.
10:29:06 <argiopeweb> > concat $ take 3 $ cycle "."
10:29:06 <lambdabot>   Couldn't match expected type `[a]'
10:29:07 <lambdabot>         against inferred type `GHC.Types...
10:29:21 <ekipan> > take 3 (repeat '.')
10:29:22 <lambdabot>   "..."
10:29:27 <argiopeweb> Yep.
10:29:34 <argiopeweb> I should probably go back to bed now.
10:29:59 <argiopeweb> I've apparently lost the concept of String not being [[Char]]
10:30:35 <ekipan> or perhaps you were confusing repeat and cycle
10:32:14 <argiopeweb> Probably a little of everything. *goes back to keyboard formats*
10:43:14 <MacGuges> [42,13
10:43:52 <MacGuges> oops
10:48:10 <Yrogirg> Hello! Is there a ghc flag that forces an abortion of computation when NaN appears during the evaluation?
10:49:52 <k0ral> how can I putStrLn a Maybe String ?
10:50:06 * k0ral is feeling sooooo noob
10:50:10 <c_wraith> Yrogirg: that's not part of the semantics of ieee-754 floating-point calculation.  NaN propogates, not causes an exception
10:50:26 <c_wraith> k0ral: try print.  (print = putStrLn . show)
10:50:29 <argiopeweb> > print (Just 'a')
10:50:30 <lambdabot>   <IO ()>
10:50:33 <argiopeweb> hehe
10:51:07 <k0ral> well, it prints Just "my_string"
10:51:08 <argiopeweb> Forgot lambda does returns for IO...
10:51:14 <k0ral> I just want "my_string"
10:51:25 <c_wraith> k0ral: what do you want if it's Nothing?
10:51:35 <webchat77> @type (>>= putStrLn)
10:51:35 <lambdabot> IO String -> IO ()
10:51:47 <k0ral> I've put an if statement before so that I'm sure it's not Nothing
10:51:47 <webchat77> @type (>>= fmap putStrLn)
10:51:48 <lambdabot> forall (m :: * -> *). (Functor m, Monad m) => m (m String) -> m (IO ())
10:51:52 <argiopeweb> > (Just x) <- (Just 'a'); putStrLn x
10:51:53 <lambdabot>   <no location info>: parse error on input `;'
10:52:04 <c_wraith> k0ral: use a case instead
10:52:13 <c_wraith> k0ral: if is usually wrong, in haskell
10:52:28 <k0ral> case Just x -> putStrLn x ?
10:52:31 <c_wraith> yep
10:52:39 <argiopeweb> That'll do it.
10:52:39 <c_wraith> well
10:52:50 <c_wraith> case foo of Just x -> putStrLn x ; Nothing -> whatever
10:53:37 <MacGuges> I'm planning to install Haskell in Gentoo. Are there any gotchas I should keep in mind?
10:54:37 <webchat77> :t maybe
10:54:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:54:54 <webchat77> @type maybe (return ()) putStrLn
10:54:54 <lambdabot> Maybe String -> IO ()
10:56:14 <k0ral> thank you :)
10:58:56 <MacGuges> When I first tried installing Haskell a few years ago I discovered it wasn't enough to emerge ghc, but I had to enable a lot of unsafe packages and rebuild the tools after I'd emerged them. I don't think I got it all working right.
10:59:37 <KirinDave> MacGuges: Choosing to use linux as a primary OS entails a lot of sacrifice.
10:59:41 <argiopeweb> MacGuges: Get Haskell Platform. Break away from the (often) buggy and/or out of date distribution.
10:59:50 <argiopeweb> provided by your platform*
11:00:07 <c_wraith> I don't like the platform much either.  I just install the linux binary and cabal-install, and work from there
11:00:14 <Vq> KirinDave: You're a BSD guy?
11:00:52 <argiopeweb> KirinDave: I don't know... I've been using Xmonad on Fedora as primary for awhile now. I run Google Chrome and XChat just like I would on Windows.
11:01:02 <argiopeweb> Except here I can actually do something useful with my terminals.
11:01:11 <KirinDave> argiopeweb: How's that multichannel sound from any app in the world? :)
11:01:32 <argiopeweb> KirinDave: Works like a charm. This ain't your Grandma's linux. :P
11:01:50 <KirinDave> argiopeweb: Pretty sure I can find a an app that is good in every way except its incompatibility with your particular sound setup.
11:02:10 <argiopeweb> KirinDave: PulseAudio has greatly simplified this, though you're welcome to try.
11:02:15 <KirinDave> argiopeweb: Also, rich copy-paste is still a hopeless mess on desktop linux. But this is dangerously offtopic.
11:02:29 <argiopeweb> Select + middle click works.
11:02:41 <argiopeweb> Richness is generally unnecessary.
11:02:55 <KirinDave> Maybe in your use cases.
11:03:18 <argiopeweb> True, all I do is program and write documents in LaTex.
11:03:33 <argiopeweb> (capital X?
11:03:35 <argiopeweb> )
11:03:42 <monochrom> yeah
11:04:02 <argiopeweb> s/LaTex/LaTeX
11:04:07 <monochrom> it is even supposed to be χ
11:04:25 <argiopeweb> Yeah, but I have no clue what that key combo is. :P
11:04:51 <Zao> Chi fick du.
11:05:01 <Zao> I guess the pun works better if you're speaking the language.
11:05:36 <Zao> I guess it can be interpreted as something rude if you're German. Sorry about that.
11:11:35 * argiopeweb debates the possible dangers of disconnecting and reconnecting every key on his keyboard to rearrange in Dvorak
11:12:31 <Botje> the biggest danger is you stabbing yourself with a sharp object
11:12:35 <Botje> otherwise, go for it :)
11:12:47 <argiopeweb> lol...
11:12:54 <monochrom> there is a bijection between dvorak and qwerty
11:13:01 <argiopeweb> I stab myself with sharp objects for one reason or another pretty much daily.
11:13:05 <argiopeweb> No problems there.
11:13:50 <argiopeweb> monochrom: True
11:14:22 <argiopeweb> The dangers I was referring to stem more from the "I don't like destroying keyboards" realm
11:14:50 <monochrom> the keyboard is sharper than the sword
11:14:52 <argiopeweb> Which tends to happen if you aren't careful with your switching.
11:15:11 <argiopeweb> monochrom: As long as the points aren't toward my fingers, I'm cool. ;)
11:15:51 * monochrom uses a fountain pen. wettier than the sword
11:17:50 <nyingen> If I have an Iteratee of type 'Iteratee Text IO [Text]' and another of type 'Iteratee [Text] IO Int', how do I compose these? The type signature of ($$) doesn't seem to match
11:18:07 <nyingen> (this is with the Enumerator package)
11:32:24 <ginger> hello
11:34:04 <ginger4569> Hi, I have to write function which finds roots of a quadratic function
11:34:10 <ginger4569> I did it in two ways: http://pastebin.com/k5W254SB
11:34:16 <ginger4569> Which one is better and why?
11:34:27 <ginger4569> Or maybe there are the same?
11:34:30 <argiopeweb> Define better.
11:35:11 <ginger4569> Taking less time/memory to calculate
11:35:37 <argiopeweb> Just run them both with +RTS -s and see for yourself. <.<
11:36:17 <ginger4569> But I can't generate all possible inputs
11:36:34 <ginger4569> I mean, which method of coding shouls good Hashell programmer choose
11:36:38 <argiopeweb> Keep in mind you're concerned about Maximum Resident Memory, not any of the other measurements.
11:36:41 <ginger4569> THe first one or the second one
11:36:48 <argiopeweb> That's an idiomatic question.
11:36:56 <argiopeweb> Which is different from performance in some cases.
11:36:58 <edwardk> jmcarthur: no problem =)
11:37:28 <doserj> the different result datatypes shouldn't make a difference. in the first one, you have 1 comparison, though, in the second, you need 3. But the differnce should be negligable.
11:37:41 <ginger4569> SO maybe what advantages/disadvantages this two methods have
11:38:04 <argiopeweb> The data type version will be slightly more reusable and have a better interface to other users.
11:38:30 <djahandarie> Yeah, I like the data type version more. I'd also curry it.
11:38:51 <argiopeweb> Though if you don't need to know whether there is 0/1/2, or if there can be more than 2, the other may be better.
11:38:52 <djahandarie> (Switch from tuples to more function parameters)
11:39:08 <doserj> ginger4569: you could remove the pair constructor in the second example, though.
11:39:28 <argiopeweb> Yep, Two Double Double > Two (Double, Double)
11:39:41 <argiopeweb> Same with the 3-tuples.
11:39:46 <ginger4569> ok
11:40:40 <ginger4569> doserj, why you said there is 1 and 3 comprasions? Shoudn't GHC treat them both as the same amount of comprasion?
11:41:20 <argiopeweb> ginger4569: delta `compare` 0 vice the guards
11:41:49 <argiopeweb> Shouldn't be hard to combine the compare with the data structure though.
11:42:42 <doserj> I'm not sure what ghc does on the asm level there
11:42:57 <ginger4569> so delta `compare` always generate one comprasion?
11:44:11 <argiopeweb> @src compare
11:44:11 <lambdabot> compare x y | x == y    = EQ
11:44:11 <lambdabot>             | x <= y    = LT
11:44:11 <lambdabot>             | otherwise = GT
11:44:28 <argiopeweb> It's 2 comparisons instead of 3.
11:45:19 <argiopeweb> It's a bit clearer from the code standpoint.
11:45:31 <ginger4569> well, but when i put otherwise instead of delta < 0  = No then i'll have 2 comprasion too, right?
11:45:52 <argiopeweb> If the difference between the compare parts of algo 1 and algo 2 is going to be a deciding point in performance, you may want to consider rewriting in assembly.
11:45:54 <djahandarie> If there is a function that already does exactly what you want then use that.
11:46:32 <djahandarie> And yes, judging micro performance in Haskell is impossible to do by just staring at the code.
11:46:45 <djahandarie> If you're /serious/ then you will dump the core and the ASM and look at it.
11:46:48 <argiopeweb> At least pull Core and work from that.
11:46:48 <ginger4569> I'm just tyring to guess what are prons and cons of that two codes, you said the amount of comprasion and better interference
11:47:00 <argiopeweb> Interface*
11:47:18 <argiopeweb> And the answer to the comparisons is: use compare.
11:47:21 <ginger4569> interface, sorry
11:47:29 <argiopeweb> :P
11:47:40 <djahandarie> ginger4569, normally one aims for elegance, not brutal performance.
11:48:00 <djahandarie> And no one here has the exact answers to the performance question without loading in that code themselves and seeing what performs better.
11:48:28 <ginger4569> ok, anything else? (about prons and cons of that codes?)
11:48:47 <argiopeweb> It's 19 lines. There's nothing else to say.
11:48:53 <djahandarie> There is more to say
11:49:08 <ginger4569> Maybe the second one is better, 'cos it has no limit to the amout of arguments?
11:49:08 <argiopeweb> Do it your way, and don't optimize prematurely.
11:49:13 <argiopeweb> djahandarie: I defer to y ou.
11:49:42 <djahandarie> What I'd do is make it clear that you are taking the roots of a quadratic polynomial
11:49:50 <djahandarie> I.e., create a datatype for the polynomial
11:50:27 <djahandarie> Then you'll have   roots :: QPolynomial -> Roots    That says a lot more to me than   roots :: (Double, Double, Double) -> [Double]
11:50:36 <argiopeweb> djahandarie: Good call. I convinced myself that I had mentioned that earlier, but buffer check says I didn't.
11:50:52 <ginger4569> So you mean that the soccond one is more easier rewrite to polynomial, right?
11:51:04 <djahandarie> Huh?
11:51:34 <djahandarie> I'd say use compare, and data types for your polynomial and roots
11:52:16 <djahandarie> I need to run now though.
11:53:56 <ginger4569> ok, thanks a lot
11:56:48 <DevHC> D:
11:57:55 <k0ral> I'd like to use a Data.Map with (A, String) as a key, where A is an Enum type
11:58:16 <k0ral> it complains since A has no order
11:58:24 <DevHC> -D:
11:59:27 <k0ral> I'm thinking about adding it as instance of Ord by transforming it into a String and thn applying Strings order
11:59:34 <k0ral> is that the right way to solve the problem ?
12:03:14 <nyingen> The enumerator docs say that ($$) composes two Iteratees
12:03:37 <nyingen> but the type signature of ($$) is Monad m => Iteratee a m b -> (Step a m b -> Iteratee a' m b') -> Iteratee a' m b'
12:04:54 <nyingen> Why is it not Monad m => Iteratee a m b -> Iteratee b m c -> Iteratee a m c ?
12:07:05 <nyingen> more specifically, why is the second argument a function
12:08:21 <doserj> @type (>>=)
12:08:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:12:43 <nyingen> ok, so suppose I have foo :: Iteratee a m b and bar :: Iteratee b m c
12:12:50 <nyingen> how do I compose these?
12:12:54 <argiopeweb> Hehe, now I've got it... You have to lift the front of the key, stick a knife under the side, and pop the front.
12:13:05 <nyingen> argiopeweb: Are you rearranging your keycaps?
12:13:15 <noteventime> k0ral: Can't you compare on "fromEnum"?
12:13:46 <noteventime> As far as I can tell fromEnum is supposed to be injective
12:14:22 <argiopeweb> nyingen: Yep. Going Dvorak from Qwerty
12:14:28 <k0ral> noteventime: well, as fromEnum gives an Int, I guess yes, I can compare it
12:14:50 <nyingen> argiopeweb: I actually wouldn't recommend rearranging. It's a huge pain to deal with hard-coded qwerty stuff after that, or any situation in which a qwerty mapping is in effect
12:15:12 <k0ral> noteventime: ghc doesn't complain now :)
12:15:13 <nyingen> plus, non-rearranged keys forces one to learn to touch type
12:15:30 <argiopeweb> nyingen: Meh, I've been using Qwerty so long that I can use it on blank keys.
12:15:37 <nyingen> you say that now :)
12:15:41 <argiopeweb> :P
12:16:05 <argiopeweb> Besides, what's hard-coded qwerty?
12:16:20 <nyingen> in my case, it was impossible to play nethack with a dvorak mapping
12:16:27 <argiopeweb> Good call.
12:16:52 <argiopeweb> Though I use hjkl, so everything's by feel again.
12:17:35 <argiopeweb> And I can set up interhack to keymap for me.
12:20:31 <shapr> nyingen: There's an emacs mode to allow dvorak use of nethack.
12:20:50 <shapr> argiopeweb: BIOS is usually hard-coded qwerty... thus my ownership of a kinesis QD keyboard.
12:20:58 <nyingen> there's also the option of not rearranging the keys. then everything is fine.
12:21:35 <nyingen> The combination of ancient muscle memory of qwerty-nethack and looking at the keyboard in case of doubt = ascension to demi-god status :)
12:22:19 <nyingen> shapr: how is the kinesis anyway
12:22:45 <shapr> nyingen: I love 'em, I have two :-)
12:23:27 <argiopeweb> shapr: Good Point.  I've got externals out my ears though
12:23:44 <argiopeweb> Hard to type on the bare rubber...
12:23:54 <shapr> huh?
12:24:56 <argiopeweb> Little rubber nipples under every key.  I'm missing 2 rows of keys at the moment
12:25:07 <shapr> oh
12:25:27 <mjrosenb> argiopeweb: i had a keyboard that was *just* rubber at one point.
12:25:44 <mjrosenb> it was pretty sweet in that the whole thing could be rolled into  a small ball
12:25:53 <argiopeweb> lol...
12:27:43 <argiopeweb> nyingen: The alternative to not changing my keys is not knowing which keys to press.  I'm a Dvorak noob
12:28:06 <shapr> argiopeweb: I'd suggest putting the layout as a background pic, then you can always minimize everything
12:29:24 <mjrosenb> or just use a small piece of masking tape / dry erase markers, etc.
12:33:20 <argiopeweb> Meh, rubber dohickie came loose
12:37:17 <nyingen> I just set up a little reference card next to my monitor, when I was learning dvorak
12:38:25 <nyingen> there was also some website that had dvorak-specific typing exercises. that was very helpful
12:39:28 * nyingen goes back to reading the Yesod enumerator tutorial for the umpteenth time
12:39:46 <k0ral> as a noob, I see I'm using a lot of embedded "case of" structures, to deal with Maybe values
12:40:06 <k0ral> I guess using Monads would simplify the code
12:40:32 <c_wraith> a bit.
12:40:32 <k0ral> but it would force me to redefine every standard function into its monadic form
12:40:38 <c_wraith> But you can also just use combinators
12:40:41 <c_wraith> like maybe
12:40:44 <c_wraith> :t maybe
12:40:45 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:41:14 <k0ral> combinators ?
12:41:16 <c_wraith> that function is exactly equivalent to a pattern match on a Maybe a type
12:41:22 <k0ral> is it normal your maybe has a lower "m" ?
12:41:42 <c_wraith> I generally do that.  I've seen others say they start with mb
12:42:20 <djahandarie> Huh? He was asking about the function name, no?
12:42:30 <k0ral> y
12:42:30 <c_wraith> oh.  yes, he was
12:42:33 <c_wraith> :t maybe
12:42:34 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:42:39 <k0ral> :t Maybe
12:42:40 <lambdabot> Not in scope: data constructor `Maybe'
12:42:43 <k0ral> ?????
12:42:46 <jmcarthur> that's not the Maybe constructor, that's the maybe function
12:42:52 <djahandarie> k0ral, "Maybe" is on the type level.
12:43:01 <k0ral> sure
12:43:02 <jmcarthur> *type constructor
12:43:09 <c_wraith> :t Just
12:43:11 <lambdabot> forall a. a -> Maybe a
12:43:13 <c_wraith> :t Nothing
12:43:14 <lambdabot> forall a. Maybe a
12:43:17 <jmcarthur> > maybe 5 succ $ Just 1
12:43:18 <lambdabot>   2
12:43:19 <jmcarthur> > maybe 5 succ $ Nothing
12:43:20 <lambdabot>   5
12:43:32 <djahandarie> k0ral, on the value level, you have  Just  and  Nothing  to create Maybe values.
12:43:49 <k0ral> I know that, I just didn't get what was this maybe function
12:43:54 <k0ral> never seen it before
12:44:01 <jmcarthur> @src maybe
12:44:01 <lambdabot> maybe n _ Nothing  = n
12:44:01 <lambdabot> maybe _ f (Just x) = f x
12:44:13 <djahandarie> Yeah, 'maybe' is just a new function. The fact it is similar to the type constructor's name doesn't mean much
12:44:14 <k0ral> hmmm
12:44:25 <jmcarthur> see also:
12:44:28 <jmcarthur> @src either
12:44:28 <lambdabot> either f _ (Left x)     =  f x
12:44:28 <lambdabot> either _ g (Right y)    =  g y
12:44:44 <djahandarie> k0ral, I just thought the fact you did ":t Maybe" was a sign that you were kind of confused, so I clarified.
12:44:45 <k0ral> sometimes I need to do things when Nothing is got
12:44:54 <jmcarthur> @src uncurry
12:44:54 <lambdabot> uncurry f p = f (fst p) (snd p)
12:44:55 <k0ral> djahandarie: you thought well
12:45:05 <c_wraith> k0ral: that's what the first argument to maybe is for
12:45:05 <djahandarie> :)
12:45:20 <c_wraith> :t maybe (putStrLn "got Nothing!") print
12:45:22 <lambdabot> forall a. (Show a) => Maybe a -> IO ()
12:45:46 <k0ral> well, that's a great function
12:45:55 * djahandarie thinks that eta-expanding the print might also make things slightly clearer
12:46:05 <k0ral> wonder why I've never met it during my long painful readings :)
12:46:28 <jmcarthur> but your guess earlier that Monad can help was also not off track, btw
12:46:40 <jmcarthur> but Monad is not the only way :)
12:46:54 <djahandarie> There are moways than the monad.
12:47:05 * djahandarie sticks to his day job
12:47:12 <eduard> how to change ["A", "1", "B", "3"] to ["A1", "B3"] ?
12:47:47 <Taslem> How about: f [] = [] ; f (a : b : c) = a ++ b : f c
12:47:51 <c_wraith> eduard: there's nothing fancy for that built-in.  Might as well just do it yourself
12:48:04 <djahandarie> eduard, I imagine you could also have ["AB", "1", "BC", "3"] or something?
12:48:09 <Saizan> > (\ xs -> zipWith (++) xs (tail xs)) ["A", "1", "B", "3"]
12:48:11 <lambdabot>   ["A1","1B","B3"]
12:48:14 <jmcarthur> :t foo ["A", "1", "B", "3"] = ["A1", "B3"] in foo
12:48:15 <lambdabot> parse error on input `='
12:48:17 <Saizan> oops
12:48:20 <jmcarthur> :t let foo ["A", "1", "B", "3"] = ["A1", "B3"] in foo
12:48:20 <lambdabot> [[Char]] -> [[Char]]
12:48:24 <jmcarthur> :P
12:48:42 <k0ral> function string1:string2:x = (string1 ++ string2):(function x) ???
12:49:14 <Taslem> f [] = [] ; f (a : b : c) = a ++ b : f c;  seems like the simplest solution. It's pretty readible.
12:49:32 <k0ral> \o/
12:49:42 <jmcarthur> Taslem: missing case
12:49:50 <jmcarthur> but yes, that may be simplest
12:49:53 <eduard> yep, thanks Taslem
12:49:55 <Taslem> There is no proper solution, though.
12:50:08 <djahandarie> fmap concat . splitEvery 2 -- is how I would do it with the 'split' package.
12:50:09 <Taslem> You can't tell it how to handle ["a"] when there's nothing to pair it with.
12:50:14 <Taslem> And garbage in, garbage out.
12:50:23 <jmcarthur> well, i could see zipping the list with its own tail and taking every other element from the result
12:50:30 <djahandarie> I don't think Data.List.Split is in lambdabot though
12:50:42 <djahandarie> It really should be
12:50:45 <djahandarie> Damn useful little thing
12:51:11 <jmcarthur> i find that i tend to want split when i am using String for string processing. despite the name, that is often a bad idea
12:51:14 <Taslem> Because, you can't correctly answer a query with an odd number anyways, so there's no point just cusioning the error. The result will still be wrong.
12:51:46 <c_wraith> I really am impressed by how much functionality Data.Text builds in.
12:51:56 <jmcarthur> Taslem: we don't *really* know the spec though
12:52:08 <c_wraith> It's like bos wanted us to use it
12:52:20 <jmcarthur> c_wraith: wtf i think you might be right
12:52:59 <jmcarthur> bos makes cool stuff
12:53:36 <gwern> I don't know what to use Data.Text for. bytestring seems to handle my purposes pretty well
12:53:42 <gwern> is it mean for people doing a lot of unicode?
12:53:45 <gwern> *meant
12:53:53 <djahandarie> gwern, it's actually suppose to be for any text data
12:54:02 <gwern> djahandarie: what does that mean?
12:54:03 <c_wraith> gwern: it's meant for cases of manipulating data as *text*, rather than as bytes.
12:54:09 <djahandarie> The rule is that Bytestring should only be used when you have binary data
12:54:11 <Zao> Data.Text is for people who want to do text-y things to text without the painful characteristics of String.
12:54:13 <aristid> gwern: ByteString is only for bytes. are you not dealing with encoded data?
12:54:14 <djahandarie> With no charset
12:54:15 <c_wraith> Those really are very different cases
12:54:16 <gwern> if there is text that is not Unicode or ASCII, I don't want to know about it :)
12:54:43 <gwern> aristid: I guess not
12:54:45 <aristid> gwern: if it's unicode, you don't want to use ByteString, do you?
12:55:28 <c_wraith> gwern: there's a difference between just passing data around, in which case bytestring is fine, and actually processing it, in which case bytestring will treat you very badly with non-ascii text
13:04:38 <edwardk> personally, i use bytestrings more or less regardless. ;)
13:05:43 <mjrosenb> do bytestrings give you easy access to any elements with a constructor?
13:06:11 <c_wraith> If you use Data.ByteString.Internal, you get access to the constructor.
13:06:27 <c_wraith> But the internals are...  a byte array pointer, an offset, and a length
13:06:29 <edwardk> Data.Text requires me to pay to marshal the data for any purpose outside of Haskell, because it is stored in a ByteArray# rather than through a ForeignPtr. so text-icu for instance winds up copying the data all over the place to call an external library
13:07:01 <c_wraith> edwardk: that might get changed this summer.  Since one of the GSoC projects is converting Text to UTF-8 internally
13:07:15 <edwardk> c_wraith: yep! =)
13:07:21 <edwardk> (i'm mentoring it)
13:07:29 <c_wraith> ah.  good to know :)
13:08:03 <edwardk> One of the things we need to benchmark is the difference in performance between the ByteArray# and the ForeignPtr approach.
13:08:50 <c_wraith> is ForeignPtr that much better for FFI interfaces?
13:08:54 <edwardk> also, iirc, there was an issue where the gc didn't have any idea how much data was behind a bytestring (due to the foreignptr)
13:09:27 <c_wraith> Hmm.  Seems like mallocForeignPtrBytes would fix that problem
13:09:31 <edwardk> yes, you can't hand off data that is held in a ByteArray# without copying it out, or without having had the foresight to allocate it as a pinned ByteArray# in the first place, which kind of negates its benefits on other fronts
13:10:00 <c_wraith> since mallocForeignPtrBytes pins the memory, and puts it in the GHC heap, so that the size is known.
13:10:09 <edwardk> yeah
13:10:35 <edwardk> that was a fairly dim recollection
13:11:09 <c_wraith> I suspect GHC's support for things like that has improved with time, as well
13:12:11 <edwardk> yeah. it is one of the things we need to discover. right now he's collecting benchmarks, and i'm dusting off old versions of code that i have that provides utf8 encoded bytestrings
13:12:29 <c_wraith> Right, the other big win with mallocForeignPtrBytes is that no finalizer is necessary.  Being in the GHC heap means it gets GC'd properly automatically.
13:13:59 <edwardk> note: mallocForeignPtrBytes uses a newPinnedByteArray#
13:14:21 <c_wraith> heh.  So it's really the same thing as having the foresight to pin it at creation time?
13:14:22 <edwardk> which may introduce concern over heap fragmentation
13:14:26 <edwardk> yeah
13:14:29 <parcs> is there any way to explicitly export all of a module's top-level definitions?
13:14:31 <c_wraith> yeah, I was just realizing that
13:14:47 <c_wraith> parcs: module Foo (module Bar, ...)
13:15:00 <imc> waaaaaaaaaargh.... 15 minuts of first dvorak training, my brain is !*!@#(*@#
13:15:05 <c_wraith> or, if you want to export its own definitions, you can do that with the same syntax
13:15:09 <c_wraith> parcs: module Foo (module Foo, ...)
13:15:26 <c_wraith> That would mean "export everything top-level in this module, and whatever else I list)
13:15:35 <c_wraith> s/)/"/
13:15:52 <jmcarthur> is there a name for this property of a function f?    f a . f b = f b . f a
13:16:03 <parcs> c_wraith: nice, thanks
13:16:09 <edwardk> if the heap issues are acceptable, one option might be to just always use pinnedbytearrays and run the trick to get its Addr out in reverse to allow optimized passes over it. then it would kind of straddle the two implementation designs
13:16:12 <jmcarthur> it's at least related to commutativity i guess
13:16:27 <dylukes> jmcarthur: What're some real functions that have that properly?
13:16:29 <dylukes> property*
13:16:33 <dylukes> I mean, mathematical functions.
13:16:34 <edwardk> if that makes sense
13:16:43 <c_wraith> dylukes: (+)
13:16:44 <dylukes> I guess f = <any constant>
13:16:50 <dylukes> c_wraith: true.
13:16:51 <jmcarthur> dylukes: any commutative binary operation, plus some others
13:16:56 <dylukes> I mean cartesian coordinate functions.
13:17:06 <dylukes> well, try the wikipedia page for commutative binary operations
13:17:13 <dylukes> maybe it mentions that property somewhere
13:17:21 <jmcarthur> i didn't see any (already looked)
13:17:36 <dylukes> hm, commutativity is
13:17:39 <dylukes> f a b = f b a
13:17:43 <jmcarthur> right
13:17:51 <dylukes> maybe you can just extrapolate f a . f b = f b . f a from that
13:17:52 <dylukes> >_>
13:17:56 <jmcarthur> that is not quite the same thing though
13:18:04 <dylukes> no,I know.
13:18:14 <c_wraith> What's something with that property that's not commutative?
13:18:20 <dylukes> f could also be a constant here,
13:18:21 <dylukes> or id
13:18:25 <jmcarthur> that definition of commutativity requires f :: a -> a -> b, but my property requires f :: a -> b -> b
13:18:32 <adamvh> @src liftM
13:18:32 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:18:35 <dylukes> wait no fd doesn't work
13:18:43 <dylukes> jmcarthur: WHAT HAVE YOU DONE
13:18:57 <c_wraith> I guess flip mod has that property, but isn't commutative
13:19:32 <jmcarthur> i think one example would be set insertion
13:20:02 <jmcarthur> or bag insertion
13:20:27 <adamvh> Are liftM and <$> the same thing?
13:20:37 <Tomsik> No
13:20:38 <jmcarthur> adamvh: the operation, different type constraints
13:20:43 <jmcarthur> *same operation, different constraints
13:20:52 <adamvh> One requires applicative, and the other monad, right?
13:20:58 <jmcarthur> the former requires Functor
13:21:05 <jmcarthur> err
13:21:07 <jmcarthur> the latter
13:21:17 <adamvh> So if something has instances of both, than they are the same
13:21:24 <jmcarthur> should be
13:21:24 <adamvh> but it's possible to have instances of only one?
13:21:26 <c_wraith> > let (&) = flip mod in ((76324 & 35) & 77,(76324 & 77) & 35)
13:21:28 <lambdabot>   (7,35)
13:21:28 <dmwit> (f a . f b) c = (f b . f a) c <==> f a (f b c) = f b (f a c) <==> a `f` (b `f` c) = b `f` (a `f` c)
13:21:31 <jmcarthur> yes
13:21:36 <c_wraith> heh.  I was wrong, it seems
13:21:41 <dmwit> So, if f is associative and a and b commute under f, then you have your property.
13:22:57 <dmwit> Of course, that condition is only sufficient, not necessary.
13:23:16 <dmwit> f might not even have the right type to be associative, yet still have your property. =P
13:23:25 <jmcarthur> yes
13:23:38 <dmwit> It looks a lot like a module for a commutative monoid, actually.
13:24:16 <dmwit> For modules, a `f` (b `f` c) = (a * b) `f` c, where (*) is the monoid operation.
13:24:34 <dmwit> (A module is another name for a monoid action, if that term is more familiar.)
13:25:29 <adamvh> @src Yield
13:25:29 <lambdabot> Source not found. It can only be attributed to human error.
13:26:00 * hackagebot BNFC-meta 0.2.1 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.2.1 (JonasDuregard)
13:26:39 <jmcarthur> dmwit: that bit of insight might be just what i was looking for. thanks
13:27:14 <c_wraith> adamvh: the fact that it starts with a capital letter should tell you it's a data constructor.  Part of one of the iteratee libraries?
13:27:38 <adamvh> c_wraith: whatever it is, it's in the source for Data.Vector
13:27:50 <ddarius> CS people love monoid actions.
13:27:59 <c_wraith> oh, then it's probably related to fusion
13:28:32 * dmwit loves monoid actions
13:28:38 <dmwit> ergo, I am CS people
13:29:02 * ddarius loves monoid actions.
13:29:06 <ddarius> ergo, I am dmwit
13:29:11 <monochrom> snobol people and perl people love free monoids
13:29:25 <ddarius> Everyone loves free monoids.
13:29:29 <adamvh> c_wraith: Yeah, it's in the part related to fusion
13:29:48 <jmcarthur> adamvh: it's a constructor of the Step type, if i'm remembering the names correctly
13:29:49 <dmwit> I am freer with my love: I love monoid presentations.
13:29:49 <adamvh> Ah, I found it
13:30:02 <adamvh> jmcarthur: yeah, just found it
13:30:04 <adamvh> thanks
13:30:10 <monochrom> shell people go beyond loving free monoids; they say everything is a member of a free monoid
13:30:34 <aristid> dmwit: this means you are ddarius
13:30:45 <dmwit> aristid: I don't respond to the name dmwit any more.
13:30:51 <dmwit> wait... crap
13:30:53 <dmwit> Starting now.
13:31:00 <aristid> ddarius: OK
13:31:04 <Tomsik> Except all free monoids are infinite and I like finite things
13:31:07 <dmwit> =)
13:31:09 <adamvh> jmcarthur: gotta love seeing functions called "delay_inline"
13:31:22 <dmwit> Tomsik: Any element of a free monoid is finite. So no problem.
13:31:43 <dmwit> Also, not all free monoids are infinite.
13:32:21 <jmcarthur> > repeat 1
13:32:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:32:29 <byorgey> gotta love that free monoid on zero generators
13:32:42 <adamvh> Is there a paper somewhere on what's going on in Data.Vector?
13:32:50 <jmcarthur> adamvh: yeah just google stream fusion
13:32:51 <dmwit> Wow, byorgey is ddarius too!
13:33:05 <monochrom> everyone is a free ddarius
13:33:18 <Tomsik> Everyone is a monoid! When you think of it
13:33:23 <jmcarthur> adamvh: i like the one called from lists to streams to nothing at all or something like that
13:33:27 <Tomsik> You just append them bits of time
13:33:35 <adamvh> jmcarthur: thanks for the rec
13:33:38 <jmcarthur> adamvh: but there's another one more specifically about arrays that may be more specific to vector
13:33:51 <jmcarthur> adamvh: i'd still recommend the former as an introduction though, i think
13:35:54 <Tomsik> Anyone wondering why Yesod doesn't just use a writer with a custom monoid for forms?
13:36:18 <dmwit> Apparently you are.
13:36:29 <monochrom> ...
13:36:41 <Tomsik> And they're dabbling in separating applicative forms from monadic forms in types
13:36:52 <Tomsik> I know, I'm ignorant, but I don't know why
13:37:45 <dmwit> Making values whose types are kept to the least restrictive interface possible seems to be something of a trend recently.
13:37:52 <dmwit> (A good one, I think.)
13:40:13 <Tomsik> "Least restrictive" as in?
13:40:23 <c_wraith> most general typeclass, in this case
13:40:27 <dmwit> Applicative is less restrictive than Monad, because it demands fewer operations be available.
13:40:55 <Tomsik> But doesn't writer come bundled with everything you might need?
13:40:59 <c_wraith> In some ways, it's more restrictive, in that it puts greater restrictions on what the implementation can do.
13:41:14 <dmwit> I wasn't speaking to the Writer question, only the Applicative vs. Monad one.
13:41:22 <c_wraith> But it's less restrictive for the users
13:42:34 <dmwit> Despite my snark, I think the question about Writers and monoids is probably a good one, but I know nothing about Yesod.
13:43:21 <jmcarthur> http://hackage.haskell.org/packages/archive/EdisonAPI/1.2.1/doc/html/Data-Edison.html  appears to just give my property the name "fold-commutative"
13:46:49 <heatsink> Here's a general type system question.
13:47:21 <heatsink> Some type systems distinguish functions on types depending on whether they will be applied at the type level or applied at the value level
13:48:01 <heatsink> Where the type-level form is a type function, and the value-level one is a 'forall' type
13:48:30 <heatsink> Other type systems don't distinguish the two.  They're both just a function whose domain and range are types.
13:48:58 <heatsink> What difference does this choice make?
13:48:59 <jmcarthur> :k Maybe
13:49:00 <lambdabot> * -> *
13:49:06 <jmcarthur> :t Just
13:49:07 <lambdabot> forall a. a -> Maybe a
13:49:18 <jmcarthur> ^^ is that the kind of distinction you're asking about?
13:49:43 <augur> anyone speak german natively?
13:50:46 <dmwit> heatsink: I thought usually foralls classified type-level lambdas.
13:50:56 <heatsink> jmcarthur, yes
13:51:48 <aristid> augur: sure
13:51:49 <dmwit> Oh, I misunderstood the question.
13:52:12 <dmwit> It's mostly a syntactic distinction.
13:52:14 <jmcarthur> heatsink: what is an example of a language that doesn
13:52:15 <heatsink> In this case, the (forall a. _) part can be seen as a function that lives in the universe of values, whose parameter is a type
13:52:15 <augur> aristid: ill poke you later with some questions
13:52:24 <jmcarthur> *'t distinguish them
13:52:26 <aristid> augur: ok, if i'm still here then :)
13:52:28 <ryant5000> has anyone managed to get hoogle working with their own code?
13:52:33 <dmwit> It's more convenient to write terms in the one kind of language, but more difficult to do things with the mechanically.
13:52:43 <ryant5000> i've made a 'hoo' file for my project, but i can't seem to get hoogle to actually search it
13:52:46 <aristid> augur: i have a bouncer though
13:52:51 <augur> ok ciao
13:52:57 <osfameron> and dammit! To mock a mockingbird isn't available as a (legal) eBook
13:53:04 <heatsink> jmcarthur: Apparently Martin-Lof's dependent type theory doesn't distinguish them.  Both forall and (->) are defined as special cases of the dependent product.
13:53:23 * osfameron has in dead tree already, but would pay a small amount (fiver?) to repurchase it conveniently for kindle
13:53:37 <dmwit> Dependent types are another thing entirely, of course.
13:53:41 <dmwit> I've got to run.
13:53:52 <jmcarthur> heatsink: makes sense. that's because dependently typed languages don't have phase distinction
13:54:09 <heatsink> okay, bye dmwit
13:54:29 <aristid> osfameron: you could ask the publisher
13:55:07 <heatsink> Oh, so if you want to enforce a phase distinction then you need to distinguish the two?
13:56:07 <heatsink> I thought the distinction of forall vs. type-lambda was independent from the choice of whether to allow dependent types
13:56:17 <osfameron> aristid: yeah, I did that with TaPL - they replied saying "yes! but who knows when..."
13:56:24 <osfameron> I suspect that's the case with a lot of back-catalogue
13:56:31 <aristid> osfameron: *sigh*
13:56:41 <osfameron> I understand it takes some work to prepare these things for electronic publication
13:56:56 <heatsink> That would explain why dependent types and forall==lambda seem to coincide.
13:58:34 <Saizan> forall is not a lambda
13:58:40 <jmcarthur> heatsink: they are actually different in DT too
13:59:11 <jmcarthur> heatsink: it's just that compilers can disambiguate them in some languages by context
13:59:30 <jmcarthur> it's tricky business to pretend they are the same
13:59:41 <heatsink> agh, this is complicated.
14:00:48 <heatsink> So in all systems, type(lambda (x : t). e) = forall (x : t). type(e)
14:01:22 <heatsink> In dependently typed languages, is it incorrect to say that
14:01:31 <Saizan> that's correct
14:01:32 <heatsink> type(lambda (x : t). e) = lambda (x : t). type(e)
14:01:35 <jmcarthur> that is an interesting notation
14:01:39 <argiopeweb> Okay, now I feel like my keyboard is possessed.  XD
14:01:41 <Saizan> that's wrong
14:02:00 <heatsink> ok
14:03:10 <heatsink> I think that answers my question, then.
14:03:47 <Saizan> you could make forall a type constructor which takes a function from the domain of the lambda to types
14:04:50 <heatsink> Oh
14:05:02 <Saizan> but you don't instatiate a forall type by applying the type itself to something, you do so by applying the function it is the type of
14:05:22 <KirinDave> Does anyone have a nice gentle explanation of what dependent types are?
14:05:32 <heatsink> Hmm,  I think I see.
14:05:51 <Saizan> KirinDave: the short answer is "types can depend on values"
14:06:39 <jmcarthur> KirinDave: the type of the result of a function can depend on the value of its parameter   (everybody else, is that a safe way to phrase it more specifically?)
14:06:57 <KirinDave> I see.
14:07:14 <monochrom> KirinDave: an example that oop fans will love: f takes an Int parameter, and (f x)'s type is String if x is prime, is Bool of x is composite, is Double if x is 0 or 1.
14:07:15 <heatsink> Not valid to just apply the type, but you could define Forall as a constructor, then define an operator TypeOfApp that applies the underlying constructor
14:07:26 <djahandarie> KirinDave, polymorphism is when values depend on types. Type constructors are when types depend on types. Dependent types are when types depend on values. (And for completion's sakes.. normal functions are when values depend on values.)
14:07:26 <heatsink> *applies the underlying lambda function
14:07:57 <KirinDave> I see.
14:08:07 <monochrom> s/is Bool of x is composite/is Bool if x is composite/
14:08:34 <KirinDave> Thanks.
14:08:44 <Saizan> heatsink: not exactly what i meant but that's true too
14:08:45 <monochrom> you can see why depedent type systems are usually affiliated with theorem proving or runtime type checks
14:08:46 <jmcarthur> djahandarie: that makes it seem like dependent types are just when you have functions from values to types, but it's slightly more general than that, isn't it?
14:09:48 <jmcarthur> djahandarie: since you can actually lift that value to the type level from a term-level parameter
14:09:50 <monochrom> djahandarie's four-corner typecube is the untaught foundation of the universe :)
14:10:07 <jmcarthur> or does that follow from your explanation after all?
14:10:35 <djahandarie> jmcarthur, I don't think my explanation is good enough for it to imply specifics.
14:10:48 <djahandarie> I think it's really good for supplying some intuition though.
14:10:56 <jmcarthur> i agree
14:11:06 <heatsink> Every computational problem halts in four revolutions of the four-corner typecube.  You have been educated STUPID.
14:11:08 <Saizan> with dependent types you can still erase all the types, you might have to keep non computationally relevant witnesses around if you don't have consistency though
14:13:01 <heatsink> Saizan, what's the purpose of the witnesses?  To turn possibly-invalid types into nonterminating computations?
14:13:08 <dylukes> What's the four-courner type cube?
14:13:18 <djahandarie> "Non-computationally relevant witnesses"? If all the types are erased what would that be?
14:13:20 <heatsink> dylukes: www.timecube.com
14:13:41 <dylukes> what
14:13:43 <Lemmih> dylukes: For the sake of your sanity, do not click that link.
14:13:53 <dylukes> ._.
14:14:11 <monochrom> the 4 corners of the typecube: you can map (type or value) to (type or value), 4 combinations
14:14:59 <dylukes> gotcha
14:15:02 <djahandarie> KirinDave, maybe something more useful for supplying some specifics:  with dependent types, you can observe the value of your type inside the type signature itself.    Normaly we have    f :: Int -> Int   With dependent types we can do f :: (x :: Int) -> Int,    and then we would be allowed to use   x   , the value of that first parameter in the type itself. Although we just disregard it in this specific example.
14:15:08 <jmcarthur> join (liftA2 (->)) [type, value]
14:15:16 <dylukes> this website
14:15:17 <dylukes> i
14:15:20 <monochrom> there is actually a 9-corner advanced typecube that says (kind or type or value) to (kind or type or value), but it is too advanced for beginners :)
14:15:24 <dylukes> is so amazing and correct
14:15:36 <jmcarthur> actually it can go infinitely
14:15:41 <djahandarie> And then there is the idea of a pure type system, which you can instantiate at any number of levels!
14:15:46 <KirinDave> monochrom: www.timecube.com, you mean?
14:15:48 <monochrom> "we need to go deeper"
14:15:52 <jmcarthur> join (liftA2 (->)) $ iterate typeOf value
14:16:05 <jmcarthur> err
14:16:12 <dylukes> oh god
14:16:15 <jmcarthur> join (liftA2 (->)) $ iterate higherUniverse value
14:16:15 <dylukes> QT has been compiling
14:16:18 <dylukes> for over an hour and haal
14:16:19 <djahandarie> Don't forget that we can use fibrations to talk about each seperate level of relation between the different sorts!
14:16:20 <dylukes> half*
14:16:21 <jmcarthur> dylukes: ...
14:16:28 <dylukes> jmcarthur: I fixed it on 10.7!
14:16:44 <c_wraith> a 9-cornered cube?  This is an amazing cube.
14:17:15 <heatsink> Thanks Saizan, that clears up some of my confusion
14:17:16 <monochrom> hehe
14:17:17 <heatsink> Saizan++
14:17:28 <djahandarie> (I really don't like the fact that the lambda cube is called a cube. Pretty stupid.)
14:18:15 <djahandarie> KirinDave, does my previous message make some sense?
14:18:30 <KirinDave> djahandarie: yes
14:18:36 <jmcarthur> dylukes: i just built and installed it in about 20 seconds :P
14:18:38 <djahandarie> Cool.
14:18:46 <KirinDave> djahandarie: Doesn't that mean that we could define functions that take and return very different things based onw hat they're passed?
14:18:53 <djahandarie> Yep.
14:18:57 <KirinDave> djahandarie: Like we could define a new union over several types
14:19:02 <KirinDave> That's a good thing
14:19:12 <monochrom> @quote monochrom dependent
14:19:12 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
14:19:33 <KirinDave> Most programmers: get paid for proven theorems. ;)
14:19:38 <Cale> djahandarie: It is a cube though...
14:19:44 <ben> What is a dependent type
14:19:55 <djahandarie> Cale, yes, but that doesn't provide any intuition for the concept.
14:20:05 <djahandarie> ben, see my last two messages to KirinDave :p
14:20:11 <Cale> Um, I guess.
14:20:22 <ben> The timecube talk scared me off
14:20:34 <KirinDave> ben: Educated stupid.
14:20:44 <djahandarie> A lot of things are a lot of other things. I say that we only point out the things that are particularly enlightening. At least for choosing what goes in the name. :)
14:21:05 <dylukes> jmcarthur: wtf.
14:21:12 <dylukes> jmcarthur: You lie.
14:21:16 <dylukes> QT 4.7.3?
14:21:23 <dylukes> are you building it from source?
14:21:32 <jmcarthur> dylukes: lol i thought you said QC
14:21:34 <djahandarie> KirinDave, continuing on with the last example,
14:21:38 <dylukes> no
14:21:39 <dylukes> QT
14:21:40 <dylukes> lol
14:21:41 <djahandarie> Oops, premature enter.
14:22:22 <dylukes> If Agda were made easy to use for practical things,
14:22:27 <dylukes> the world would fall apart.
14:22:35 <dylukes> Dependent typing, in my enterprise code?
14:22:52 <monochrom> they call it dynamic typing in enterprise code
14:23:16 <jmcarthur> agda is surprisingly easy once you're used to it. the problem is just in figuring out what is important enough to prove and what's not
14:23:45 <jmcarthur> well, and the lack of libraries and stuff
14:25:11 <Saizan> heatsink: yeah, you are stuck trying to evaluate the witness to normal form rather than assuming it's valid and getting a segfault :)
14:25:27 <dylukes> I want dynamic AND static typing
14:25:28 <dylukes> silly.
14:25:34 <dylukes> at the same time.
14:26:35 <Saizan> djahandarie: e.g. data TEq a b where TEq :: TEq a a; pattern matching on TEq doens't give any useful information once you've stripped out the types, yet ghc has to produce and pattern match on it, otherwise you could write unsafeCoerce with undefined
14:31:00 <Cale> dylukes: There's a good paper about how best to do that.
14:31:24 <Cale> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.84.4648&rep=rep1&type=pdf
14:32:16 <dylukes> Hey Cale
14:32:25 <dylukes> What do you think of symmetry groups?
14:32:38 <Cale> love them
14:32:43 <dylukes> elaborate.
14:32:45 <Cale> http://video.google.com/videoplay?docid=-5174280497179508511# -- talk about the paper
14:34:09 <Cale> Well, I don't know where to begin. If we have almost any sort of mathematical object, and we have a particular sort of structure-preserving transformation or mapping between those objects, we can typically form a category from those.
14:34:26 <dylukes> I don't actually understand or know anything about symmetry groups.
14:34:28 <Cale> (Whose objects are the mathematical objects in question, and whose arrows are the structure-preserving mappings)
14:34:32 <dylukes> or mathematical objects for that matter.
14:34:39 <dylukes> I can tell you the area of a triangle though!
14:34:52 <Cale> okay, so, perhaps I should start differently :)
14:34:59 <dylukes> may~be
14:35:53 <Cale> But to finish the thought there, if we have any object in any category, there will be a set of arrows from that object to itself which are invertible, and those arrows under composition form a group.
14:36:02 <Cale> (the automorphism, or symmetry group)
14:36:13 <Cale> Let's not be so abstract though.
14:36:34 <Cale> Let's consider shapes in the plane R^2
14:37:46 <Cale> There are various motions and transformations of the plane which we might want to study, but one of the simplest sorts are those transformations which preserve all distances (and all angles), called isometries.
14:37:53 <ezyang> Any guesses where this symbol might have come from: ghczm7zi1zi20110507_BufWrite_zdwa3_info
14:38:15 <Cale> So if we think of the plane as a sheet of paper on which shapes may be drawn, these just move the sheet of paper around without stretching or tearing it
14:38:24 <Cale> (and maybe flip it over)
14:38:32 <Cale> yeah?
14:38:54 <dylukes> reading...
14:39:25 <monochrom> preflex: zdec ghczm7zi1zi20110507_BufWrite_zdwa3_info
14:39:26 <preflex>  ghc-7.1.20110507_BufWrite_$wa3_info
14:39:28 <dylukes> mmk, I think I kind of got it so far ._.
14:39:44 <ezyang> oooh, we have a z-decoder. Useful.
14:39:52 <ezyang> I forget: where does the ghc package come from?
14:40:16 <monochrom> it's the "GHC API" aka "GHC as a library"
14:40:20 <dylukes> > putStrLn "Did I crash again?"
14:40:22 <lambdabot>   <IO ()>
14:40:33 <dylukes> I'll take that as "NO ()"
14:40:59 <Cale> dylukes: Okay, so imagine we have a shape drawn on our paper, and we're going to consider the isometries (ways we can move this sheet of paper), which leave the shape in the same place. For example, if we have an equilateral triangle, there are 6 ways (3 rotations and 3 flips)
14:41:05 <monochrom> it comes out of the box with every GHC
14:41:19 <dylukes> Cale: We're assuming the "shape" is visible on either side, yes?
14:41:22 <Cale> yeah
14:41:23 <dylukes> Since it exists in a plane.
14:41:26 <dylukes> mmk, just making sure :P
14:41:37 <dylukes> I guess… yeah only 2D haha, no way for thickness to exist
14:41:41 <dylukes> alright though, I got that.
14:41:51 <dylukes> What about combinations of rotations and flips?
14:42:10 <Cale> Really our shape is a set of points, and our isometry is a function f such that for any two points p and q, the distance from p to q is the same as the distance between f(p) and f(q)
14:42:13 <dylukes> Say, flip vertically then rotate 30°.
14:42:23 <Cale> Right :)
14:42:30 <Cale> So that will actually be a different flip :)
14:42:39 <dylukes> oh… it'd be a flip over a different "axis"?
14:42:42 <Cale> yeah
14:42:43 <monochrom> the GHC API has a BufWrite module
14:42:48 <dylukes> mmk.
14:43:02 <Cale> And no matter how we compose two isometries, we will get another isometry
14:43:14 <dylukes> ...right.
14:43:23 <Cale> There is the simplest possible isometry which doesn't move anything at all
14:43:26 <dylukes> mmk.
14:43:35 <Cale> and every isometry has an inverse, which "undoes" whatever it did
14:43:36 <dylukes> Kind of a degenerate one hehe.
14:43:54 <dylukes> mmk
14:43:59 <Cale> So that the composition of an isometry and its inverse is the identity (the one which doesn't move things)
14:44:10 <dylukes> mmk
14:44:33 <Cale> So these isometries which leave a shape fixed form a group under the operation of "do this one and then that one", or function composition :)
14:44:52 <dylukes> right right.
14:45:14 <Cale> and hence we can use groups to measure the ways in which things are symmetrical, in a simliar sense to how we use numbers to measure lengths.
14:45:22 <dylukes> So… just a random thing then,
14:45:39 <dylukes> it feels like you could equate keeping the shape "the same" with staying within the same type.
14:45:46 <dylukes> (me randomly thinking)
14:45:52 <dylukes> (probably not worth any thought, sorry)
14:46:10 <dylukes> anyways, what do yo mean "group" here?
14:46:16 <ddarius> Cale is a combinatorist so he likes groups in general and symmetries in particular.
14:46:27 <dylukes> I've noticed.
14:46:31 <dylukes> It's interesting though.
14:46:41 <Cale> Ah, so let's say what we mean by a group
14:47:24 <argiopeweb> > group [1, 2 3, 4, 5, 1]
14:47:25 <Cale> A group is a set G together with a binary operation, often called multiplication, *: G x G -> G, (which takes two elements of the group and gives another)
14:47:25 <lambdabot>   [[1],[2],[4],[5],[1]]
14:47:32 <Cale> Such that the following are true:
14:47:40 * ddarius stumbled across a random math jokes page which is actually pretty good.
14:47:41 <argiopeweb> > group [1, 2, 3, 4, 5, 1]
14:47:42 <lambdabot>   [[1],[2],[3],[4],[5],[1]]
14:47:54 <argiopeweb> ddarius: Link please.
14:47:54 <Cale> 1) The group operation is associative: for any a,b,c in G, we have a*(b*c) = (a*b)*c
14:48:17 <Cale> 2) There is an identity element 1 in G such that for any a in G, we have 1*a = a*1 = a
14:48:23 <ddarius> "Q: What is the difference between a PhD in mathematics and a large pizza? A: A large pizza can feed a family of four."
14:48:25 <dylukes> monoid ?
14:48:31 <dylukes> ddarius: Harsh.
14:48:32 <argiopeweb> badum-dum
14:48:38 <Cale> 3) For any a in G, there is some b in G for which a*b = b*a = 1
14:48:46 <Cale> 1 and 2 together say that it's a monoid under *
14:48:58 <Cale> and 3 is the extra bit which turns a monoid into a group
14:48:59 <argiopeweb> Likely true though.
14:49:09 <Cale> (every element has an inverse)
14:49:15 <dylukes> hm, interesting
14:49:28 <dylukes> so, then would positive rational numbers be a group?
14:49:51 <dylukes> Since you have for 3), (2, 1/2), (3, 1/3) etc
14:50:16 <dmwit> yes
14:50:36 <Cale> yes, nonzero rational numbers
14:50:39 <dmwit> An abelian group, no less (which just means that a*b = b*a).
14:50:42 <Cale> or positive, sure
14:50:47 <djahandarie> dylukes, make sure you always specify what operation you're talking about when you talk about these groups.
14:50:55 <dylukes> djahandarie: *!
14:50:56 <dylukes> sorry.
14:50:56 <Cale> (I missed that you said "positive" initially)
14:51:14 <dylukes> And then I guess if you're dealing with addition or subtraction,
14:51:16 <Cale> Yeah, rational numbers under addition also form a group
14:51:26 <Cale> subtraction, no, because subtraction isn't associative
14:51:27 <dylukes> the b for each a is the negative.
14:51:45 <dylukes> (for negatives it'd be the negated negative… positive)
14:51:56 <Cale> bbiab
14:52:11 <dylukes> aw
14:52:23 <dylukes> brb
14:52:35 <djahandarie> Saizan, ah, I see
14:52:54 <ddarius> argiopeweb: http://cseweb.ucsd.edu/~mstepp/math_jokes.html
14:53:45 <dylukes> pfff.
14:53:47 <dylukes> ddarius: nice.
14:54:19 <PrairieEagle> holy sh** this is a lot of people
14:54:30 <pastorn> PrairieEagle: indeed :)
14:54:36 <skurt> In_Flames: where are you from?
14:54:48 <In_Flames> skurt, northeast Brazil
14:55:03 <In_Flames> u?
14:55:46 <Cale> Man, this list doesn't even have my favourite ones :)
14:55:51 <PrairieEagle> pastorn: Just started "try haskell" interactive tutorial, I've been interested in functional languages.
14:55:56 <argiopeweb> ddarius: Christmas && Halloween joke == awful.
14:56:29 <pastorn> PrairieEagle: tov many exercises have you done?
14:56:34 <pastorn> *how*
14:56:54 <Cale> Like, what's yellow and complete under the metric induced by the norm?
14:57:03 <Cale> A: A banananach space
14:57:19 <ksf> @remember catamorphism FP is related to FP in the same way that UML is related to OOP.
14:57:20 <lambdabot> Nice!
14:57:25 <PrairieEagle> pastorn:  I just started.
14:58:10 <Cale> PrairieEagle: Feel free to ask any questions which come to mind. Beginners are always welcome here :)
14:58:46 <PrairieEagle> Cale: thanks, I will.
14:58:56 <pastorn> Cale: now if we could just get all the people who's read the typeclassopedia a gazillion times to stop interacting with the beginners...
14:59:09 <argiopeweb> PrairieEagle: Beginners are always welcomed, then we fatten them up and eat them.
15:00:06 <geheimdienst> we tend to sacrifice them and offer them to dons to get some packages out of him
15:00:13 <monochrom> hahaha
15:00:29 <pastorn> dons :: N00bz -> Code
15:00:29 <PrairieEagle> argiopeweb:  With either bratwurst, or chocolate cake I hope!
15:00:55 <scree> what is a good anagram of banach-tarski?
15:01:05 <scree> A: banach-tarski banach-tarski
15:01:12 <monochrom> hahahaha
15:01:19 <geheimdienst> slightly too fast. i was gonna say that ...
15:01:36 <PrairieEagle> I don't get the joke
15:02:04 <monochrom> you need to know the banach-tarski paradox first
15:02:09 <scree> @google banach-tarski
15:02:10 <lambdabot> http://en.wikipedia.org/wiki/Banach%E2%80%93Tarski_paradox
15:02:10 <lambdabot> Title: Banach–Tarski paradox - Wikipedia, the free encyclopedia
15:02:10 <beastaugh> PrairieEagle: the Banach-Tarski paradox is a counterintuitive result of employing the Axiom of Choice
15:02:12 <pastorn> PrairieEagle: it's a weird thing happening in axiomatic set theory
15:02:26 <geheimdienst> PrairieEagle: after around 2 years of hanging out in a math department or in #haskell, you'll understand it. after around 6 years, you'll find it funny
15:02:32 <Cale> pastorn: Why? That's how information gets passed on :)
15:02:40 <Cale> dylukes: actually, I'm still here if you have moar questions
15:02:49 <dylukes> Cale: ah one moment
15:02:50 <scree> that list doesn't contain the black sheep joke either :(
15:02:53 <dylukes> I got QT installed (FINALLY)
15:02:55 <dylukes> trying to get PyQT now.
15:03:07 <PrairieEagle> "Can a ball be decomposed into a finite number of point sets and reassembled into two balls identical to the original?"
15:03:09 <hpc> geheimdienst: it didn't take six years for me
15:03:13 <PrairieEagle> excuse me?
15:03:20 <pastorn> PrairieEagle: "axiomatic" = sets can only be built according to certain rules; axioms
15:03:29 <monochrom> PrairieEagle: http://xkcd.com/804/ may help
15:03:32 <beastaugh> pastorn: AC was used by mathematicians for a long time before it was formalised by Zermelo
15:03:40 <argiopeweb> monochrom: That was quick. <.<
15:04:10 <pastorn> PrairieEagle: consider the ball to be a set of infinitely many points in space
15:04:10 <augur> aristid: hey
15:04:18 <aristid> augur: i'm still here :)
15:04:27 <hpc> heh, the title text on that comic is wonderful
15:04:33 <scree> "A biologist, a physicist and a mathematician are on a train in Wales.  The biologist looks out of the window and sees a black sheep in a field.
15:05:04 <scree> "He says: 'On the basis of this data, I propose a bold new hypothesis: in Wales, all sheep are black.'
15:05:24 <PrairieEagle> pastorn: wellthen I completly agree that it should be possible to make two from just one.
15:05:40 <scree> "The physicist replies, 'you can't possibly justify that statement.  All we can say so far is that, in Wales, at least some of the sheep are black.'
15:05:51 <pastorn> http://brownsharpie.courtneygibbons.org/?p=82
15:06:01 <geheimdienst> monochrom: is there a version of the xkcd comic involving a pumpkin and a copumpkin?
15:06:12 <hpc> the mathematician says "all we really know is that at least one side of at least one sheep is black"
15:06:13 <monochrom> not yet
15:06:18 <hpc> (ruining the joke)
15:06:35 <monochrom> haha
15:06:36 <aristid> scree: that's like the oldest maths joke in the world :P
15:06:43 <PrairieEagle> can someone explain what a tulpe is exaclty?
15:06:50 <PrairieEagle> tuple
15:06:59 <scree> aristid: which is why it should be on every list of maths jokes :P
15:07:01 <hpc> a tuple is a thing that holds two things
15:07:07 <pastorn> it's a pair of data
15:07:21 <beastaugh> anyway, the counterintuitive part of the theorem is that the ball can be cut into a FINITE number of pieces and reassembled to form two balls
15:07:21 <monochrom> a record without field names
15:07:25 <hpc> data TwoThings a b = Things a b
15:07:34 <hpc> fst (Things a b) = a
15:07:34 <PrairieEagle> so like OO's list or something?
15:07:34 <hpc> etc
15:07:48 <pastorn> PrairieEagle: it's how you make a computation return multiple data (amongst other things)
15:07:52 <monochrom> no, it's like C++'s pair
15:07:53 <geheimdienst> PrairieEagle: if you know c, you could think of it as something like a struct. it contains other stuff. a tuple doesn't have names for its fields, though
15:08:00 <hpc> PrairieEagle: in OO, it's class Tuple<A, B> {A a; B b;}
15:08:09 <pastorn> PrairieEagle: a good example is the function divMod
15:08:11 <argiopeweb> hpc++
15:08:13 <pastorn> @type divMod
15:08:16 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
15:08:20 <pastorn> divMod 15 12
15:08:23 <pastorn> > divMod 15 12
15:08:25 <lambdabot>   (1,3)
15:08:31 <PrairieEagle> monochrom:  but a pair can only be two, the tutorial says it can be more ?
15:08:38 <cinch> tuple's items can be of different types, whereas lists are of the same type
15:08:42 <argiopeweb> >(1, 2, 3, 4, 5)
15:08:50 <geheimdienst> > (1,"lolcats", [])
15:08:54 <lambdabot>   (1,"lolcats",[])
15:08:54 <cinch> scree: so where's the end of the joke?
15:08:56 <hpc> PrairieEagle: those aren't tuples, but people lump the entire pattern under the name "tuple"
15:09:01 <pastorn> PrairieEagle: there are many different tuples implemented in haskell... (,), (,,), (,,,) ...
15:09:07 <geheimdienst> hpc: hm?
15:09:07 <hpc> PrairieEagle: a thing with three things inside is a triple
15:09:09 <scree> cinch: hpc stole it :P  see above
15:09:10 <pastorn> the biggest one holds 16 kinds of data
15:09:17 <argiopeweb> > (,,) 1 "lolcats" []
15:09:18 <lambdabot>   (1,"lolcats",[])
15:09:23 <hpc> a thing with four things is a quadruple
15:09:30 <argiopeweb> pastorn: Not on my system. <.<
15:09:31 <PrairieEagle> ah, got it
15:09:35 <hpc> a thing with seven hojillion things is a "seven-hojillion-tuple"
15:09:42 <geheimdienst> hpc, it's more common (and more clear) to just say 2-tuple, 3-tuple, etc.
15:09:51 <beastaugh> hpc: a tuple is just a finite ordered list of elements
15:10:05 <hpc> or what geheimdienst said
15:10:07 * monochrom wouldn't want to write "hexadecituple"
15:10:12 <duffytellme> source ++
15:10:16 <olsner> pastorn: only 16!? last time I checked it was 63
15:10:22 <blackdog> geheimdienst: Hoare used triples...
15:10:25 <duffytellme> @source ++
15:10:26 <lambdabot> ++ not available
15:10:28 <pastorn> hmm... i only seem to have Show instances for up to 15...
15:10:30 <olsner> at least I have successfully used 17-tuples
15:10:30 <duffytellme> @source (++)
15:10:31 <lambdabot> (++) not available
15:10:37 <geheimdienst> blackdog: tell him i don't like it
15:10:44 <monochrom> Hoare didn't say "triple" actually
15:10:55 <blackdog> geheimdienst: you tell him, i'm not worthy
15:11:10 <blackdog> monochrom: really? who came up with the name?
15:11:22 <monochrom> some anonymous user
15:11:22 <hpc> duffytellme: [] ++ xs = xs; (x:xs) ++ ys = x:(xs++ys)
15:11:25 <argiopeweb> pastorn: Show instances only go up to 16.
15:11:37 <argiopeweb> pastorn: There are constructors up to 63.
15:11:42 <pastorn> PrairieEagle: anyway... if you ever find yourself needing to put more than 3 fields of data together it might be a good idea to declare a datatype for that particular use
15:12:02 <PrairieEagle> got it, thanks
15:12:02 <hpc> imo, it was a mistake to specify tuple types larger than 2
15:12:13 <PrairieEagle> I was going to tell a joke, but I forgot it.
15:12:24 <hpc> if you really really wanted larger tuples, you should have been able to nest them like (->)
15:12:28 <hpc> without parens
15:12:32 <PrairieEagle> oh yeah, I remember.
15:12:45 <pastorn> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:12:47 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
15:12:47 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100. a -> b -> c -> d -> e -> f -> g -> h -> i ->
15:12:47 <lambdabot> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 ->
15:12:47 <lambdabot> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 ->
15:12:47 <lambdabot> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> t91 -> t92 -> t93 -> t94 -> t95 -> t96 -> t97 -> t98 -> t99 ->
15:12:49 <lambdabot> [3 @more lines]
15:12:52 <PrairieEagle> hpc: great, now your gunna have to explain 'nesting'
15:12:53 <djahandarie> Heh.
15:12:57 <ezyang> snerk.
15:13:00 <hpc> heh, forget i said it :P
15:13:27 <hpc> i have reached my "thinking about stuff that isn't finals" quota for today
15:13:34 <pastorn> i was done right there!!
15:13:39 <monochrom> 1+(2+3) and (a, (b, c)) are examples of nesting
15:13:47 <pastorn> -> t100
15:13:48 <pastorn>      -> (a,
15:13:50 <pastorn>          b,
15:14:02 <pastorn> 100 fields, easy pattern matching!
15:14:06 <PrairieEagle> Whats the opposite of infinity? Zero, one never ends, the other never starts.
15:14:22 <jmcarthur> the concept of "opposite" always troubled me
15:14:22 <Twey> Ytinifni
15:14:32 <ion> −∞
15:14:35 <koala_man> negative infinity
15:14:36 <Twey> ‘Opposite’ is not an issue
15:14:53 <jmcarthur> for many things, opposite can take on many different meanings
15:14:55 <Twey> The problem is ‘opposite’ applied to objects rather than properties
15:14:58 <argiopeweb> Proof by eminent authority:   "I saw Karp in the elevator and he said it was probably NP-complete."
15:15:01 <hpc> 3 is the opposite of E!
15:15:17 <ion> Opposite is the opposite of opposite of opposite!
15:15:27 <osaunders> Yeah, there’s a one to many relationship between any thing and opposites
15:15:42 <hpc> osaunders: a many to many relationship, even
15:15:44 <PrairieEagle> that would be the functional answer for opposite of infinity, the logical is 0 :p
15:16:15 <monochrom> one day I overheard two students discussing logic homework. "the opposite of 'everyone does blah' is 'no one does blah', right?" he was right, it was some kind of opposite, just not negation
15:16:23 <osaunders> hpc: Indeed
15:16:32 <pastorn> Are tuple types created runtime?
15:16:37 <scree> at this stage in the discussion i feel obliged to ask what is yellow and equivalent to the axiom of choice
15:16:45 <monochrom> "opposite" simply means involution (invertible non-identity map), that's it
15:17:05 <geheimdienst> monochrom: yes, simply
15:17:47 <pastorn> Cale: it's all too often that somone comes here and asks for 'take'/'drop'/something in that style and gets treated to applicative functors
15:17:59 <pastorn> which i consider being just bad manners
15:18:01 <Twey> That's how they learn :þ
15:18:15 <ddarius> Why learn the wrong way?
15:18:24 <monochrom> "the opposite" is just hyperbole like "the wrong thing to do is ...". there is no "the" opposite or "the" wrong thing; there are many opposites and many wrong things
15:18:36 <jmcarthur> given monochrom's definition of opposite, i will now say "an opposite" in place of "the opposite"
15:18:42 <beastaugh> scree: that reminds me of that other bad AC joke: "The Axiom of Choice is obviously true, the Wellordering Principle is obviously false, and as for Zorn's Lemma, who knows?"
15:18:52 <Twey> monochrom: There is precisely one opposite to any *property*
15:19:01 <jmcarthur> and that is what i will teach any children i have in the future
15:19:04 <Twey> At least, any scalar property
15:19:06 <jmcarthur> and they will be better than your kids
15:19:32 <Twey> ‘Short’ is the opposite to ‘tall’; ‘big’ is the opposite to ‘small’
15:20:05 <jmcarthur> green is the opposite to what?
15:20:07 <scree> beastaugh: indeed :)
15:20:21 <monochrom> gib is the oppostie to big
15:20:28 <Twey> jmcarthur: Not a scalar property: the scale of ‘green’ only goes to zero
15:20:46 <heatsink> jmcarthur: purple!  Don't you watch Babylon 5?
15:20:52 <ion> yellowish blue
15:20:56 <Twey> monochrom: "gib" is the *reverse* of "big"; English conflates the name and referent
15:21:06 <geheimdienst> pastorn: there's tons of answers that are technically correct and not helpful at all ("where are we?" -- "on earth")
15:21:12 <geheimdienst> i.e. i agree
15:21:14 <Twey> This conversation is much easier in Lojban
15:21:30 <PrairieEagle> crap, what did I start?
15:21:39 <djahandarie> PrairieEagle, nothing, this happens all the time.
15:21:44 <pastorn> Twey: heh... i've looked at the wikipedia entry on it - then i stopped
15:21:54 <djahandarie> Although it should happen in #haskell-blah , not #haskell :p
15:21:56 <jmcarthur> Twey: it's a scalar property if taken as an RGB component (or as a vector in other color spaces)
15:22:01 <pastorn> seriously, what's the idea with it? what is it trying to solve?
15:22:20 <geheimdienst> the problem with lojban is that you can only talk to the kind of people who's invest time in learning lojban
15:22:24 <geheimdienst> (paraphrasing xkcd)
15:22:37 <Twey> jmcarthur: Yep
15:22:39 <geheimdienst> s/who's/who'd
15:22:53 <PrairieEagle> ...
15:22:56 <Twey> So ‘green’ is not a single property
15:23:04 <Twey> It can mean many things.
15:23:09 <Twey> pastorn: This :þ
15:23:12 <jmcarthur> Twey: so can big
15:23:19 <mizugumo> Hi y'all. First time using IRC, be nice :)  I'm interested in the FFI, calling Haskell from C and vice versa.  Can anyone point me to a good resource or recommend a book that covers the FFI in detail?  Or are the articles on haskellwiki as good as it gets?
15:23:19 <monochrom> this is the problem with your theory of scalar properties
15:23:26 <PrairieEagle> the  fu** ? I'm belive I've heard this conversation before
15:23:28 <jmcarthur> Twey: big based on what measurement?
15:23:35 <Twey> jmcarthur: ‘Relatively large in size’
15:23:46 <jmcarthur> bah nevermind i saw the error of my ways as i typed that
15:23:47 <ddarius> monochrom: Which is readily solved by my theory of properties-with-opposites
15:23:52 <Twey> It has some figurative meanings, too, but luckily there's a figurative meaning of ‘small’ to match all of them, as far as I'm aware :þ
15:23:57 <scree> mizugumo: you could try Real World Haskell, ch 17
15:24:08 <scree> @where rwh
15:24:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:24:52 <mizugumo> scree: thanks, I've read that.  It's ok, was just hoping for something more detailed.
15:25:17 <argiopeweb> mizugumo: The GHC manual?
15:25:35 <jmcarthur> Twey: so far all your examples have been magnitudes. do you have any that are not?
15:25:42 <geheimdienst> mizugumo: if you have a specific problem, post some code and we might be able to help you
15:26:08 <Twey> jmcarthur: ‘Alive’ vs. ‘dead’?
15:26:30 <jmcarthur> "half dead" :P (kidding kidding)
15:26:34 <Twey> Hehe
15:26:38 <jmcarthur> "barely alive"
15:27:15 <Twey> You can have a scale (and, indeed, the Lojban treats it thus) but the meaning of the English words ‘alive’ and ‘dead’ is binary
15:27:27 <Twey> Hence the use of modifiers like ‘barely’
15:27:47 <jmcarthur> yeah it's not typical to ask how alive somebody is
15:27:50 <grundicwalker> hi everyone
15:28:03 <pastorn> helloez
15:28:05 <geheimdienst> jmcarthur, you're killing me
15:28:09 <mizugumo> geheimdienst: I've no specific example, yet.  I want to learn about passing structures between the two worlds, and what it means w.r.t lazy evaluation and potentially infinite lists, etc.  I see small FFI examples, but what I found so far is light on FFI discussion and elaborated explanations.
15:28:20 <jmcarthur> geheimdienst: you are in a transitory state!
15:28:22 <Twey> I posited a theory the other day that all properties in language start off being binary, then develop into scales when people think about them some more and assign a meaningful half-way point
15:28:52 <grundicwalker> I have to prove that for every finite lists: reverse (reverse xs) = xs and the hint is that first I should prove an appropriate lemma about the
15:28:54 <grundicwalker> function ++
15:29:06 <grundicwalker> Could anyone tell me that lemma?
15:29:21 <pastorn> grundicwalker: proof by indection?
15:29:25 <pastorn> *induction
15:29:32 <hpc> @src reverse
15:29:32 <lambdabot> reverse = foldl (flip (:)) []
15:29:33 <PrairieEagle> Twey: I beleive that they are ternary. alive being 2, paralized being 1, dead being 0.
15:29:42 <grundicwalker> yup, but what's that lemma?
15:29:51 <grundicwalker> about function ++
15:30:01 <ezyang> grundicwalker: That probably depends on the definition of reverse you're working with.
15:30:06 <pastorn> perhaps associativity?
15:30:07 <ezyang> How is reverse defined?
15:30:17 <grundicwalker> reverse [] = []
15:30:19 <grundicwalker> reverse (x:xs) = reverse xs ++ [x]
15:30:27 <ezyang> ok, focus on that ++ in the second line.
15:30:35 <ezyang> what kind of information about that would be good to know?
15:30:47 <pastorn> grundicwalker: yeah, you should probably prove that (xs ++ ys) ++ zs == xs ++ (ys ++ zs)
15:31:26 <grundicwalker> OK, I'll try to do it myself now
15:31:42 <grundicwalker> but one more thing - what if that lists aren't finite?
15:31:55 <hpc> grundicwalker: then you are shit out of luck
15:32:28 <hpc> but i don't think that will matter for this problem
15:32:43 <grundicwalker> I mean by solving that with induction I need to say that that lists ore finite
15:33:04 <geheimdienst> mizugumo: oh i see. have you thought about picking a haskell binding to a c library and looking at its source code? this might give you some more understanding how things work out in practice
15:33:05 <pastorn> grundicwalker: obviously
15:33:10 <pastorn> > reverse [1..]
15:33:15 <lambdabot>   mueval-core: Time limit exceeded
15:33:17 <hpc> grundicwalker: well, the structure of a list is (x:y:z:...:[])
15:33:35 <grundicwalker> hpc, this is a structure of a finite list
15:33:37 <hpc> grundicwalker: so you could do proof by induction starting from the part you always know is there (ie, the end [])
15:33:38 <pastorn> grundicwalker: reverse can't return until [] has been reached
15:33:47 <hpc> an infinite list doesn't have a final []
15:34:00 <grundicwalker> I know that, but maybe something formal for that?
15:34:04 <PrairieEagle> 'a' : 'b' : sort[] == "ab"  :) I'm learning to experiment already
15:34:31 <pastorn> PrairieEagle: hehe
15:35:28 <mizugumo> geheimdienst: good idea, thanks.
15:35:56 <hpc> grundicwalker: i am fairly sure you can just say "infinite lists don't terminate, so they don't have a last element"
15:36:00 <grundicwalker> well, so reverse(reverse([])) = reverse [] = [] - by definition and now I gotta prove reverse(reverse x:xs) = x:xs, right?
15:36:06 <argiopeweb> [1..]
15:36:28 <grundicwalker> but i'll have to say that somewhere in induction proof, right?
15:36:28 <hpc> grundicwalker: indeed
15:36:47 <argiopeweb> grundicwalker: base case, k case, k + 1 case.
15:37:11 <hpc> or just base case, k+1 case
15:37:23 <grundicwalker> so LHS: reverse(reverse x:xs) = reverse(reverse(xs ++ [x]))
15:37:26 <argiopeweb> hpc: Well yeah, k case comes with the proof.
15:37:45 <grundicwalker> and here I stuck
15:37:54 <djahandarie> +1 makes no sense when talking about structural induction on lists
15:38:06 <hpc> grundicwalker: you didn't do that step correctly
15:38:18 <hpc> (xs++[x]) = reverse (x:xs)
15:38:18 <grundicwalker> huh? why?
15:38:25 <argiopeweb> djahandarie: I'm doing the hand-wavy proof. :P
15:38:28 <hpc> er
15:38:41 <djahandarie> There are no numbers involved. And what is a hand-wavy proof? An incorrect one? :p
15:38:42 <hpc> reverse (x:xs) = (reverse xs)++[x]
15:38:59 <grundicwalker> err, right, sorry
15:39:05 <hpc> so applying that to the above:
15:39:09 <argiopeweb> djahandarie: Here's what we start with *wave hands rapidly* and there's the answer!
15:39:16 <hpc> reverse((reverse xs)++[x])
15:39:33 <grundicwalker> ok, and what now, try with RHS?
15:39:36 <djahandarie> Right, that's hand-waving. But a hand-waving proof seems like an oxymoron to me :p
15:39:38 <argiopeweb> Speed of hand waving varies directly with difficulty of peoblem.
15:39:57 <grundicwalker> x:xs = x:reverse(reverse xs)
15:40:24 <PrairieEagle> so, because a string is really just a list, haskell treats it like a list.... that f***in' brilliant. C++ can't do that as easly.
15:40:26 <argiopeweb> djahandarie: Also know in some circles as "Proof by Reader", as in "The remainder of this proof is left as an exercise for the reader"
15:40:30 <hpc> ooh, that's a nicer thing to work on, perhaps
15:40:58 <argiopeweb> PrairieEagle: C++ just treats it as an array... Same deal.
15:41:10 <parcs> @hoogle (</>)
15:41:10 <argiopeweb> Unless you're using std::string.
15:41:11 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
15:41:11 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
15:41:11 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
15:41:26 <grundicwalker> reverse((reverse xs) ++ [x]) = x : reverse (reverse xs)
15:41:32 <argiopeweb> In which case it's a wrapped array of chars. Still the same deal.
15:41:49 <grundicwalker> there is nothing more i can do here
15:42:44 <monochrom> by an induction hypothesis, reverse (reverse xs) = xs
15:43:10 <monochrom> so yes, restate your proof as an induction proof if necessary
15:43:32 <grundicwalker> i don't get what you mean, could You please show me hte next step?
15:44:02 <hpc> grundicwalker: i think from there you can do
15:44:21 <djahandarie> You know
15:44:23 <hpc> reverse((reverse xs) ++ [x]) = reverse((reverse xs) ++ (x:[]))
15:44:46 <djahandarie> Screw it, I'm going to write something about structural induction, it's so easy to explain and I don't think anyone does it properly
15:44:48 <hpc> and then use the definition of (++) to reduce that further
15:45:50 <grundicwalker> but then i will get the same
15:45:57 <grundicwalker> thing i started with
15:46:48 <osfameron> has anyone worked through to Mock a Mockingbird?
15:46:57 <dons> http://www.haskell.org/pipermail/haskell/2011-May/022799.html
15:46:58 <pastorn> grundicwalker: it can't be that difficult;
15:47:03 <osfameron> I'm on my 3rd attempt, and I really don't get what your approach is supposed to be
15:47:08 <dons> Proposal to incorporate haskell.org. Feedback (on the list) welcome
15:47:13 <pastorn> 1) prove that it holds for the base case (here it's [])
15:47:23 <pastorn> 2) assume that it holds for some case (xs)
15:47:38 <pastorn> 3) show that P(xs) -> P((x:xs))
15:47:41 <grundicwalker> pastorn, 1), 2) already done
15:48:07 <grundicwalker> 3) I got this reverse((reverse xs) ++ [x]) = x : reverse (reverse xs)
15:48:32 <grundicwalker> and there is nothing I can do by using 2)
15:48:37 <pastorn> no, what you have there is equality, i think
15:48:43 <pastorn> ==
15:49:15 <grundicwalker> maybe: LHS: reverse((reverse xs) ++ [x])  RHS: x : reverse (reverse xs)
15:49:21 <grundicwalker> gotta prove LHS=RHS
15:49:33 <pastorn> grundicwalker: consider 'revrev', the composition of the two
15:49:45 <pastorn> proving things about the composition might be easier
15:49:46 <Lemmih> dons: Does hackage count as a haskell.org resource?
15:50:00 <dons> Lemmih: that's who manages it, yes.
15:50:09 <dons> though it is a resource donated by galois
15:50:11 <PrairieEagle> How come filter ('a') "abracadabra" doesn't work?
15:50:21 <shachaf> @ty ('a')
15:50:21 <dons> :t filter ('a') "abracadabra"
15:50:23 <lambdabot> Char
15:50:23 <lambdabot>     Couldn't match expected type `a -> Bool'
15:50:23 <lambdabot>            against inferred type `Char'
15:50:23 <lambdabot>     In the first argument of `filter', namely `('a')'
15:50:34 <dons> filter takes a function as an argument
15:50:39 <grundicwalker> pastorn, I'm not sure what you mean
15:50:40 <hpc> > filter (=='a') "abracadabra"
15:50:40 <lambdabot>   "aaaaa"
15:50:45 <hpc> > filter (/='a') "abracadabra"
15:50:45 <lambdabot>   "brcdbr"
15:50:57 <Igloo> The current haskell.org machine was actually bought with h.o money, wasn't it? Although Galois kindly donates hosting, sysadmin time, etc
15:51:01 <Lemmih> dons: I have code on hackage that isn't covered by an opensource license. Will that code be removed from hackage?
15:51:12 <Igloo> The current hackage.haskell.org, I mean
15:51:14 <hpc> this can be very confusing (the filter is ACCEPT IF, not REJECT IF)
15:51:21 * Lemmih would be very sad if that happened.
15:51:37 <dons> Igloo: right. h.o paid for abbot
15:51:42 <pastorn> grundicwalker: nevermind then :/
15:52:09 <dons> Lemmih: I understand such code can be a (tiny) minority, without being trouble. E.g. non-free in Debian.
15:52:28 <dons> Lemmih: is it an open source project with a funky license, or is it proprietary?
15:52:37 <Igloo> Lemmih: What code, OOI?
15:52:42 <PrairieEagle> hpc: so it only takes Boolean parameters?
15:52:53 <Lemmih> dons: It is not licensed. It is in the public domain.
15:53:02 <Igloo> PD is open source
15:53:02 <grundicwalker> well, i got a idea, what about induction in induction?
15:53:05 <Lemmih> Igloo: acid-state, safecopy, bunch of other packages.
15:53:06 <dons> oh, i think public domain is suitably open source :)
15:53:12 <hpc> :t filter -- PrairieEagle
15:53:13 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:53:19 <hpc> it takes (a -> Bool)
15:53:33 <grundicwalker> let's say that ys = reverse xs
15:53:35 <PrairieEagle> hpc: you couldn't have just said yes?
15:53:44 <djahandarie> PrairieEagle, what you said was wrong.
15:53:47 <dons> good question Lemmih . thanks for asking
15:53:48 <Lemmih> dons: It's not on the list of acceptable licenses.
15:53:54 <grundicwalker> and prfove that reverse(ys ++ [x]) = x: reverse ys ?
15:54:11 <PrairieEagle> djahandarie: how?
15:54:17 <hpc> PrairieEagle: i could have, but (a -> Bool) isn't a boolean parameter
15:54:21 <djahandarie> PrairieEagle,  (\x -> x == 2)  is not the same as  True  or  False .
15:54:39 <djahandarie> PrairieEagle, the first is a function that evaluates to a boolean once fed a parameter. The other two are just booleans.
15:55:03 <dons> http://www.gnu.org/philosophy/categories.html
15:55:09 <geheimdienst> let f x = (if x == 'c' then True else False) in filter f "lolcats"
15:55:13 <geheimdienst> > let f x = (if x == 'c' then True else False) in filter f "lolcats"
15:55:14 <lambdabot>   "c"
15:55:20 <djahandarie> PrairieEagle, so saying that   filter   accepts a boolean would be wrong. It accepts a function that evaluates to a boolean once fed a parameter.
15:55:21 <PrairieEagle> got it
15:55:25 <djahandarie> :)
15:55:41 <grundicwalker> yeah, I solved it :)
15:55:51 <geheimdienst> PrairieEagle: see example. f is a function that takes on argument (x) and gives True or False
15:55:51 <beastaugh> one might even go so far as to call a function :: (a -> Bool) a predicate
15:55:52 <pastorn> PrairieEagle: http://en.wikibooks.org/wiki/Haskell/More_on_functions
15:55:53 <PrairieEagle> djahandarie: thats kinda what I meant though,
15:56:02 <shachaf> PrairieEagle:: It wasn't waht you said.
15:56:11 <djahandarie> PrairieEagle, it's best to be precise.
15:56:12 <PrairieEagle> shachaf: but its what I meant
15:56:38 <geheimdienst> PrairieEagle: we'll help you get the names of things straight as well
15:57:15 <djahandarie> The idea is functions accepting other functions as parameters is something that people can be unfamiliar with, so it's good to make clear what's happening early in the game.
15:57:27 <djahandarie> The idea of*
15:57:55 <ddarius> Lemmih: Why would not having a license be on the list of acceptable licenses?  Also, the concept of "public domain" doesn't exist everywhere.
15:58:00 <PrairieEagle> djahandarie: I am familair with the concept, I am new to haskell, not so new to programming/
15:58:28 <djahandarie> PrairieEagle, okay. Some very popular languages don't have this concept so even experienced programmers can get tripped up.
15:59:08 <argiopeweb> Good old fonctions as data.
15:59:26 <argiopeweb> functions*
15:59:50 <Lemmih> ddarius: It obviously shouldn't be on the list which in turn makes it problematic to say that all software should be licensed according to said list.
16:00:00 <hpc> hmm, for april fools, someone should replace all instances of "function" with "fiction" on haskell.org
16:00:09 <PrairieEagle> djahandarie: C++ has for(;;) which is just a funtion that accepts parameters that evaluate to booleans. It isn't so far off.
16:00:24 <argiopeweb> Stupid Dvorak typing speed.
16:00:27 <PrairieEagle> function*
16:00:33 <djahandarie> PrairieEagle, except it's not a function, it's a statement. More importantly, you can't define things like that. But yeah, the concept is similar.
16:01:30 <pastorn> argiopeweb: aoeu
16:01:37 <djahandarie> (An aside: I don't like the phrase "functions as data". It makes it sound like functions are very tangible and can be inspected in their entirety, which they can't. I think "functions are values" is nice in this respect.)
16:01:41 <argiopeweb> currying is the word of the day.
16:02:11 <PrairieEagle> djahandarie: isn't that why functions are given values in C++ :P
16:02:13 <Lemmih> ddarius: The servers are hosted in the US so PD should be fine. Mirrors in other countries can relicense the code under GPL3 for all I care.
16:02:25 <argiopeweb> pastorn: aoeu is easy on it's own...
16:02:34 <shachaf> PrairieEagle: filter doesn't "accept parameters that evaluate to booleans".
16:02:36 <pastorn> argiopeweb: htns
16:02:44 <pastorn> :D
16:02:53 <ddarius> Lemmih: No they can't.
16:03:05 <shachaf> PrairieEagle: It accepts functions that, once given an argument, evaluate to booleans. It's completely different from for(;;) (or a LISP macro, for that matter).
16:03:08 <argiopeweb> Finding 'p' is an issue though...
16:03:13 <Lemmih> ddarius: Why not?
16:03:18 <argiopeweb> htns. :P
16:03:30 <ddarius> Lemmih: Because I can't license your code unless you license me to do so.
16:03:33 <djahandarie> shachaf, I think it's implied that since it's a function it will need an argument.
16:03:46 <pastorn> argiopeweb: dvorak?
16:03:47 <PrairieEagle> shachaf: CONCEPTS. the idea, or and aspect is similar.
16:03:49 <argiopeweb> And ;/: is jacked.
16:03:50 <shachaf> djahandarie: Right, but that's different from an expression in C++ in for(;;).
16:03:51 <PrairieEagle> an*
16:04:07 <argiopeweb> pastorn: Indeed
16:04:41 <pastorn> PrairieEagle: in a for-loop (assuming you're iterating over some array index) you can do both map, filters and folds
16:05:06 <djahandarie> That isn't the aspect of for loops he was talking about.
16:05:13 <pastorn> in haskell you have the fold functions, which are general, but also map and filter, which can be implemented using folds
16:05:15 <pastorn> oh
16:05:19 <Lemmih> ddarius: But it's not my code. I've relinquished all ownership of it.
16:05:20 * pastorn shuts up
16:05:39 <argiopeweb> PrairieEagle: Don't compare to C, compare to Lisp!
16:05:42 <PrairieEagle> pastorn: I havent' gotten to the fold part of the tutorial yet/
16:05:50 <Lemmih> ddarius: I can no more license the code than you can, then.
16:06:01 <PrairieEagle> argiopeweb: but I don't use/ kind of don't like lisp
16:06:03 <pastorn> PrairieEagle: understanding folds is usually quite difficult
16:06:18 <argiopeweb> *shock*
16:06:32 <pastorn> PrairieEagle: one easy way to see what it does is to write fromList :: [a] -> Set a using folds
16:06:58 <pastorn> PrairieEagle: but the easiest start is probably writing sum/product
16:07:45 <Lemmih> ddarius: I guess law abiding citizens of such countries will just have to do without (:
16:07:58 <Draconx> Lemmih, you might want to consider Creative Commons Zero, which is designed to be a a valid public domain declaration when that works, or as an all-permissive license otherwise.
16:10:27 <gwern> I like CC-0. I use it on gwern.net
16:12:28 <Lemmih> Draconx: This might be somewhat militant of me but I'm fine with inconveniencing those who follow unjust laws.
16:13:19 <gwern> if anyone cares, they can make a 1 line change and claim new copyright...
16:13:32 <ben> Lemmih: :(
16:15:13 <Draconx> Lemmih, the problem isn't limited to those who "follow unjust laws", due to international copyright treaties.
16:15:15 <jmcarthur> Lemmih: that is a stance i had not considered before
16:17:28 <Draconx> Lemmih, essentially, even though I live in a country which permits me to disclaim copyright on my work, in order to legally distribute someone else's supposedly public domain work, I need to make sure that /they/ live in such a country, and furthermore, that they wrote the code in that country.
16:18:12 <parcs> how would i tell cabal to strip an executable after linking?
16:18:14 <argiopeweb> Draconx: Which country is thatZ
16:18:29 <dcoutts> parcs: it does it automatically when installing
16:18:31 <ozataman> Is there an easy way to use cabal-dev to distribute a project with all the dependencies inside, but automatically cleaning/excluding the linked executables, etc. in the cabal-dev directory?
16:19:04 <ozataman> so in a form that is ready for building with a simple "cabal-dev install" on the destination machine
16:19:14 <dcoutts> ozataman: distributed packages are cabal packages, and those are distributed as separate tarballs
16:19:14 <parcs> dcoutts: ah, okay
16:19:41 <argiopeweb> s/thatZ/that?/
16:19:49 <dcoutts> ozataman: I've been thinking about a package collection format however that would allow such bundles to be distributed as one file rather than many
16:19:51 <ozataman> dcoutts: not sure if I follow. isn't that pretty much just cabal?
16:20:03 <dcoutts> ozataman: yes
16:20:09 <gwern> I wonder what's with Niklas Broberg. he hasn't replied to my emails from 5 days ago
16:20:35 <dcoutts> ozataman: my point is, cabal-dev does not have its own distribution format, distribution uses the standard Cabal packages
16:20:40 <ozataman> dcoutts: well, I'm aware what cabal does :-) I was wondering if there were a way to use cabal-dev to simplify this use case
16:20:46 <ozataman> dcoutts: got it, thank you
16:21:00 <PrairieEagle> anyone know what the C++ irc chat is? I need to ask a question there
16:21:05 <ben> ##c++
16:21:22 <PrairieEagle> Thanks
16:21:26 <Saizan> cabal can install from a list of tarballs now, right?
16:21:31 <dcoutts> Saizan: yes
16:21:39 <dcoutts> local or http
16:22:01 <dcoutts> with other deps resolved from hackage (or whatever archives you've configured locally)
16:22:37 <Lemmih> Draconx: Sounds bothersome. As I advise gays from Saudi Arabia, it's ok to disregard unjust laws but try not to get caught (:
16:22:47 <ozataman> dcoutts: it would be outstanding to have a simple way to pack all dependencies into a single package for distribution. especially when working with local/private dependencies..
16:23:10 <dcoutts> ozataman: my guess is that you can hack something up, where you rm dist/ but keep the other .cabal-dev (or whatever it calls it) dir and package that into a tarball. It would not be a cabal package of course, but unpacking and using cabal-dev install may work.
16:24:09 <dcoutts> ozataman: right, I guess "all dependencies" here really means "the ones listed locally", not all deps transitively
16:24:09 <Draconx> Lemmih, unfortunately, I don't think it's reasonable to ask Hackage to ignore them.
16:24:30 <ozataman> dcoutts: yep, that was going to be my next step. I was hoping for an existing solution.. I'll likely not rm, but copy instead to a tmp dir - I don't want to recompile the entire dep tree on my local dev machine after each deploy!
16:25:29 <ozataman> dcoutts: it might even be nice to have a flag to include literally all deps... sometimes you don't want to deal with internet connections, etc. and just want to do a simple cabal/cabal-dev install
16:25:34 <argiopeweb> Lemmih: In what way are those laws unjust? And what keeps your logic from spreading arbitrary of reason?
16:25:36 <dcoutts> ozataman: so I've been thinking of a index/collection format that covers the cabal-dev, hackage, and bundle distribution use cases.
16:25:41 <Lemmih> Draconx: Indeed. And I wouldn't. Thank goodness the US has decent laws regarding works in the public domain.
16:26:03 <dcoutts> ozataman: right but the problem is where do you stop chasing deps, you cannot go all the way to the base package for example.
16:26:17 <Draconx> Lemmih, the problem isn't with works written in the US.  The problem is with works written in Germany with a non-valid copyright disclaimer.
16:26:25 <ozataman> dcoutts: right, guess you're right
16:26:26 <dcoutts> ozataman: you'd need some configurable policy, like "don't include deps of the Haskell platform version x.y"
16:26:27 <Draconx> Lemmih, the non-valid copyright disclaimer is still non-valid in the US.
16:26:34 <ozataman> dcoutts: that'd be great
16:26:53 <Draconx> Lemmih, and the german work with a non-valid copyright disclaimer is copyrighted in the US by international treaties.
16:26:58 <Lemmih> Draconx: Thank goodness I'm not from Germany, then (:
16:27:39 <ben> I am :(
16:27:53 <argiopeweb> Lemmih: This is why public domain isn't listed as a free license. It isn't free (as in speech) in any given situation.
16:28:29 <ozataman> dcoutts: something like that would really be useful, e.g. when deploying web apps / other services, etc.
16:28:48 <dcoutts> ozataman: yes, we need more cabal hackers however, so we can get to these kinds of features
16:28:56 <Twey> Cale: Are you about?
16:28:58 <ozataman> dcoutts: especially since lots of people develop in one OS and deploy on another. binary distributions are not always possible
16:29:05 <Twey> Oh, WHOIS says yes.
16:29:13 <Cale> yeah
16:29:19 <Cale> What's up?
16:29:32 <Twey> Cale: Do you remember the URL of that work you once linked me where various words are used to convey a specific feeling rather than any logical sense?
16:29:39 <Twey> The title of the chapter was ‘gods’
16:30:19 <Taslem> Have a history on your browser?
16:30:34 <shachaf> Taslem: Browser histories are evil.
16:30:37 <Twey> Taslem: It was over a year ago
16:30:38 <Lemmih> Draconx: If Hackage starts rejecting code in the PD, I'll license my code asap. If Hackage is fine with PD, great.
16:30:43 <Twey> Probably two
16:30:49 <Twey> My browser history doesn't go back that far
16:30:50 <Taslem> So? Can't you still find it?
16:30:54 <Taslem> Oh.
16:30:58 * shachaf does almost everything in Chrome's Incognito mode so as not to keep a local history.
16:30:58 <Cale> Twey: The Age of Wire and String
16:31:04 <Taslem> Why not? What browser do you have?
16:31:17 <Cale> Twey: There are some excerpts from it online, but it's a small book.
16:31:19 <ozataman> dcoutts: are you thinking of this as the next step to cabal or another stand alone package?
16:31:41 <Twey> Cale: Do you have the links to them?  I can't seem to find them on Google
16:31:45 <Lemmih> argiopeweb: I think it isn't listed as a free license because it is not a license.
16:31:51 <dcoutts> ozataman: I'd include this into the cabal-install package (the 'cabal' executable)
16:32:03 <dcoutts> ozataman: the cabal-dev features belong in cabal-install really
16:32:21 <argiopeweb> Lemmih: You're sidestepping around the fact that it's not free.  Free comes before license in "Free License"
16:32:41 <dcoutts> ozataman: also, the two ideas in cabal-dev can be generalised to cover more use cases.
16:32:41 <Cale> ah, one sec, I'll see if I can find them
16:34:24 <Lemmih> argiopeweb: The code is not mine to license. Even the most permissive license asserts my ownership of the code.
16:34:45 <argiopeweb> Lemmih: Who created the code?
16:35:10 <Cale> Twey: http://www.webdelsol.com/marcus/
16:35:15 <argiopeweb> And how was it initially released?
16:35:23 <Cale> http://www.webdelsol.com/marcus/acct.htm is my favourite :)
16:35:25 <Twey> Cale: Excellent, thank you
16:36:25 <Draconx> Lemmih, anyway, since you apparently live somewhere where you can disclaim copyright, the resulting public domain code is most definitely free software.
16:36:31 <Lemmih> argiopeweb: Who created pi? Or jokes? Or ghost stories?
16:37:02 <argiopeweb> Humans. Which human typed the code in question?
16:38:09 <Lemmih> argiopeweb: I was the first human to type in the code.
16:38:27 <Lemmih> argiopeweb: But I don't see how that gives me the right to stop someone else doing the same.
16:39:59 <argiopeweb> Lemmih: Then release it under a license that says, "I wrote this code on paper, but I don't care what you do with it. Further, if you create clones of this code I still don't care what you do with it, regardless of whether you copied my code directly, wrote it from scratch, or both."
16:40:05 <Lemmih> Draconx: Yeah. I'm banking on this being a philosophical position rather than a practical one (:
16:41:07 <Lemmih> argiopeweb: I will not jump through hoops to comply with (what I consider) unjust laws.
16:41:24 <Draconx> Lemmih, the only issues are when someone wants to verify that the code is actually in the public domain: they need to know that the disclaimer is valid.
16:41:29 <argiopeweb> Lemmih: There is no law associated with that. It's simply stating your position on your code.
16:41:35 * djahandarie thinks this should move to #haskell-blah
16:41:58 * argiopeweb would tend to concur, but is tired of arguing the point...
16:53:50 <lispy> hello
16:53:59 <shachaf> @yarr lispy
16:54:00 <lambdabot> This is the END for you, you gutter-crawling cur!
16:54:28 <shachaf> lambdabot: And I've got a little TIP for you, get the POINT?
16:54:52 <lispy> Lemmih: Thanks again for your ghc core parsing library
16:55:34 <lispy> Lemmih: I was thinking about it more and I'm kind of torn on the issue of how to read in types that have special support in Haskell.  Like how you parse (->) to Tarrow.
16:56:03 <Lemmih> lispy: Oh?
16:57:09 <elliott> what's a better name encompassing constructor and de(con)structor (i.e. pattern matching) than "structor"? :-)
16:58:40 <lispy> Lemmih: Yeah, I'm torn :)
16:59:20 <lispy> Lemmih: Since they are special in Haskell I like the idea of giving them a special constructor (like Tarrow) but they are just types to core so maybe it's better to represent them uniformly with the types that are not baked in.
16:59:54 <Eduard_Munteanu> WTFPL might be more free than plain public domain, and it certainly has more bearing where public domain isn't properly defined.
17:00:24 <elliott> how is wtfpl freer than plain public domain...
17:00:40 <Eduard_Munteanu> elliott: you can even misattribute it
17:00:46 <elliott> Eduard_Munteanu: Same with public domain?
17:00:52 <Eduard_Munteanu> Not really.
17:00:56 <elliott> Public domain is the forfeit of all copyright.
17:00:57 <Zao> elliott: I do not believe that all jurisdictions recognize putting things in public domain.
17:01:05 <elliott> Zao: Of course.
17:01:17 <elliott> But where it /is/ available, there is no way the WTFPL is freer.
17:01:24 <Eduard_Munteanu> elliott: AFAIR, public domain still has some implied rights
17:01:25 * djahandarie wonders why the copyright discussion keeps on cropping up in here
17:01:34 <Eduard_Munteanu> Like proper attribution.
17:01:35 <elliott> Eduard_Munteanu: I'll have to citation needed that one :P
17:01:35 <Zao> djahandarie: I blame Cabal.
17:01:41 <Zao> And/or Hackage.
17:01:43 * Eduard_Munteanu looks up
17:02:47 <hpc> Eduard_Munteanu: public domain is blahblah "and/or if the intellectual property rights are forfeited"
17:03:01 <hpc> public domain = "i have no rights"
17:03:05 <heatsink> Forcing programmers to put types and licenses in their code is definitely a way to introduce them them to formal logic and copyright law.
17:03:35 <hpc> heatsink: and both provide some measure of safety
17:03:45 <heatsink> yea
17:03:49 <ddarius> djahandarie: Because this is a channel full of programmers, though #haskell tends to be less ravaged by this disease than some other places.
17:04:12 <hpc> just be glad we aren't talking about patent; that's when you know the war is lost
17:04:20 <Lemmih> lispy: Tarrow has been quite helpful in LHC.
17:05:36 <warrenharris> TemplateHaskell question: If I have a string which at runtime contains haskell text (e.g. nested constructor calls, "Foo (Bar 3)" perhaps obtained by showing some AST), is there a simple way to turn this string into a Q Exp (like [|...|] does with literal expressions)?
17:06:14 <Eduard_Munteanu> Bah, I can't find it.
17:06:37 <Eduard_Munteanu> But anyway, I remember that in at least some jurisdictions public domain means you must still correctly attribute the work to the author.
17:08:13 <Eduard_Munteanu> Whereas with WTFPL you can say "hey, this is mine"
17:08:45 <Saizan> warrenharris: you could parse with haskell-src-exts and then convert it to TH's AST, haskell-src-meta does this but i'm not sure if it's still maintained
17:10:35 <Draconx> Eduard_Munteanu, plagiarism is generally considered extremely rude, even if it's not illegal.
17:11:00 <lispy> Lemmih: That's what I wondered.  Can you give an example?
17:11:03 <warrenharris> Saizan: Thx. Let me check that out...
17:12:00 <Lemmih> lispy: Well, it's just used so often that matching for it as a regular constructor would be slightly bothersome.
17:12:38 <Saizan> pattern synonyms would be cool.
17:13:01 <Saizan> but i guess we already have views..
17:13:09 <danharaj_> we have views/
17:13:10 <danharaj_> ?
17:13:40 <heatsink> > case Just 3 of (fromJust -> x) -> x
17:13:41 <lambdabot>   3
17:14:00 <Saizan> "view patterns" to be precise
17:14:06 <heatsink> > case [Just 3] of (head -> Just x) -> x
17:14:07 <lambdabot>   3
17:15:05 <shachaf> > case [Just 3] of (listToMaybe -> Just x) -> x; _ -> 0
17:15:06 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
17:15:06 <lambdabot>    arising from a use of...
17:15:25 <shachaf> > case [3] of (listToMaybe -> Just x) -> x; _ -> 0
17:15:26 <lambdabot>   3
17:15:46 <Eduard_Munteanu> Draconx: sure, I'm not arguing with that.
17:20:50 * hackagebot EsounD 0.2 - Type-safe bindings to EsounD (ESD; Enlightened Sound Daemon)  http://hackage.haskell.org/package/EsounD-0.2 (MasatakeDaimon)
17:55:58 <modec> hi! does anyone know if the stuff described here http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/index.htm on static contacts have been implemented anywyere?
18:11:30 <Axfan> hey guys im getting a strange error when linking SDL
18:12:18 <Axfan> its saying in function soz_info: there is an undefined refrence to '__stginit_SDLzm0zi6zi2_GraphicsziUIziSDL_'
18:12:39 <dmwit> use --make
18:12:44 <Axfan> *face palms*
18:12:46 <Axfan> LOL
18:13:11 <Axfan> wow thanks dmwit
18:13:12 <Axman6> preflex: zdec __stginit_SDLzm0zi6zi2_GraphicsziUIziSDL_
18:13:12 <preflex>  __stginit_SDL-0.6.2_Graphics.UI.SDL_
18:13:26 <Axfan> i have been using gcc to much i guess
18:13:35 <Axfan> thanks guys
18:14:25 <shachaf> > "Axfan" == "Axman6"
18:14:26 <lambdabot>   False
18:14:30 <Axfan> im not
18:14:33 <shachaf> @vixen Really?
18:14:33 <lambdabot> i think you know the answer to that one, silly
18:14:39 * shachaf sighs.
18:14:48 <Axfan> last time I came here they got us confused too
18:14:54 <Axman6> shachaf: just one of my groupies :P
18:15:00 <mauke> it's only two characters off
18:15:01 <Axfan> nah
18:15:06 <Axfan> i got this name a long time ago
18:15:07 <mauke> lambdabot would accept it
18:15:15 <shachaf> Axman6: Are you sure you're not one of *its* groupies?
18:15:22 <shachaf> Axman6: You're numbered, after all.
18:15:25 <Axman6> positive
18:15:31 <shachaf> @vixen Is Axfan the same as Axman6?
18:15:31 <lambdabot> yes
18:15:37 <Axman6> positively numbered too
18:15:40 <shachaf> mauke appears to be correct.
18:15:40 <Axman6> ha
18:15:52 <shachaf> @vixen Is Axman6 the same as Axfan?
18:15:52 <lambdabot> nevermind about that
18:16:00 <Axfan> well im going to go back to be a newb and forgeting too add make
18:16:05 <Axfan> cya later
18:16:21 * mauke is now known as AxFan6
18:18:27 <shachaf> mauke: Wrong color.
18:18:47 <drhodes> Trying to compile: ghc -> llvm -> arm. $ ghc -fllvm Foo.hs -keep-llvm-files; llc Foo.ll -march=arm;
18:19:05 <drhodes> llc errors with "Unsupported calling convention", anyone know what's going on here? Am I missing a step?
18:19:50 <Axman6> cross compiling isn't supported
18:19:54 <Axman6> yet anyway
18:20:03 <drhodes> ok, thanks Axman6
18:20:52 <Axfan> what do you guys code your haskell in?
18:21:06 <monochrom> telnet
18:21:21 <mauke> mspaint
18:21:47 <Axfan> @mauke: touche
18:21:47 <lambdabot> Unknown command, try @list
18:21:56 <Axfan> oh cant @
18:22:25 <monochrom> emacs
18:22:52 <dolio> preflex: nickometer Axfan
18:22:52 <preflex>  Axfan is 0% lame
18:23:21 <Axfan> oh man
18:24:07 <shachaf> Hmm. How does nickometer work?
18:24:20 <shachaf> preflex: nickometer
18:24:21 <preflex>  shachaf is 0% lame
18:24:26 <shachaf> preflex: nickometer preflex
18:24:26 <preflex>  preflex is 0% lame
18:24:28 <shachaf> preflex: nickometer mauke
18:24:28 <preflex>  mauke is 0% lame
18:24:32 * shachaf senses a pattern.
18:24:52 <monochrom> preflex: nickometer n1ck0m3t3r
18:24:52 <preflex>  n1ck0m3t3r is 99.959133% lame
18:25:02 <monochrom> that is the pattern you thought you saw
18:26:22 <Axman6> preflex: nickometer n1c40m3t3r
18:26:22 <preflex>  n1c40m3t3r is 99.959332% lame
18:26:30 <Axman6> preflex: nickometer n1c4m3t3r
18:26:30 <preflex>  n1c4m3t3r is 99.958830% lame
18:26:42 <Axman6> preflex: nickometer 1337
18:26:42 <preflex>  1337 is 63% lame
18:26:46 <Axman6> heh
18:27:35 <mauke> preflex: nickometer Axman6
18:27:36 <preflex>  Axman6 is 12% lame
18:28:40 <mauke> preflex: nickometer __main__
18:28:40 <preflex>  __main__ is 99.5624% lame
18:28:51 <monochrom> preflex: nickometer NextGenHacker101
18:28:52 <preflex>  NextGenHacker101 is 99.8504% lame
18:29:39 <monochrom> that is an actual nick on youtube. see for example http://www.youtube.com/watch?v=SXmv8quf_xM
18:31:23 <Axman6> zomg, you can SEE other people's IP address? that's private information!
18:32:21 <rostayob> preflex: nickometer rostayob
18:32:21 <preflex>  rostayob is 0% lame
18:32:26 <rostayob> oh, great.
18:33:14 <Axman6> monochrom: bwahaha, that's classic
18:33:16 <dolio> NextGenHacker101 taught me the wisdom of tracer t.
18:33:31 <monochrom> Axman6: "tracer t" is the crowning achievement. think TracerT, a monad transformer!
18:33:57 <Axman6> look at all those people using the google!
18:34:33 <monochrom> it is actually pretty old now, but yes it is a classic
18:34:56 <Axman6> i'ma go view sooo many IP's
18:39:45 <shachaf> monochrom: 500 Internal Server Error?
18:39:49 <shachaf> That's next-gen indeed.
18:43:46 <danharaj> I closed that video immediately after hearing a nasally prepubescent voice.
18:44:43 <gwern> @wn clepe
18:44:45 <lambdabot> No match for "clepe".
18:44:49 <gwern> @wn yclept
18:44:50 <lambdabot> *** "yclept" wn "WordNet (r) 2.0"
18:44:50 <lambdabot> yclept
18:44:50 <lambdabot>      See {clepe}
18:44:57 <gwern> auuuggggh
18:45:45 <ddarius> danharaj: Don't worry.  It's worse than you think.
18:49:53 <NemesisD> anyone know how i'd get a Data.ByteString.Lazy.Internal.ByteString into a String? i don't see anything in Data.ByteString.Lazy that would do it
18:50:23 <mauke> what encoding is it in?
18:50:41 <Lemmih> NemesisD: Data.ByteString.Lazy.Char8.unpack
18:51:19 <Lemmih> NemesisD: Then hope to God that the bytestring is in latin1.
18:56:36 <foreveryoung> hi
18:56:50 <foreveryoung> how can i type here undefinet value (rotatet T)?
18:56:55 <foreveryoung> *undefined
18:57:00 <argiopeweb> Good eventide
18:57:13 <NemesisD> man im doing disgusting things with *Strings right now
18:57:25 <mauke> foreveryoung: what?
18:57:38 <argiopeweb> foreveryoung: What mauke said
18:58:14 <foreveryoung> what does a rotated T symbol means?
18:58:19 <foreveryoung> in hashell proove
18:58:21 <foreveryoung> *proofs
18:58:21 <argiopeweb> Bottom
18:58:42 <mauke> ⊥
18:58:42 <foreveryoung> What does it mean?
18:58:47 <argiopeweb> Bottom
18:58:50 <aavogt> maybe it's a turnstile
18:58:56 * argiopeweb repeats
18:58:58 <mauke> it's an unvalue
18:59:16 <mauke> it means non-termination/errors/etc
18:59:21 <foreveryoung> ok, so how can i type that symbol on irc channel?
18:59:25 <argiopeweb> A lack of computability
18:59:34 <mauke> the same way you type it elsewhere
18:59:38 <argiopeweb> _|_
18:59:54 <monochrom> ⊥ means "no information"
18:59:58 <shachaf> foreveryoung: Use the ⊥ key on your keyboard.
19:00:00 <argiopeweb> or ⊥, if you're fancy
19:00:01 <mauke> haha
19:00:13 <shachaf> It's to the right of the \ key.
19:00:15 <argiopeweb> shachaf: Hey, I want your kind of keyboard. :D
19:00:21 <mauke> U+22A5 (e2 8a a5): UP TACK [⊥]
19:00:33 <mauke> shachaf: there's no key there :-(
19:00:53 <shachaf> mauke: You need to #haskell expansion pack. Only $49.99.
19:00:53 <monochrom> use the ⊥ icon on your touch screen
19:00:57 * ddarius has 7 there.
19:00:59 <argiopeweb> I have page up there, but I'm using it for other stuff.
19:01:04 <foreveryoung> damn, my irc client doesn't support UTF8
19:01:07 <applicative> NemesisD, or why not unp =  unpack . decodeUtf8 . B.concat . L.toChunks  using unpack and decodeUtf8 from Data.Text
19:01:10 <shachaf> ddarius: 7? What kind of keyboard is that?
19:01:13 <ianmathwiz7> "a lack of computability" if you're talking about computability logic, then it technically means that the machine loses the game
19:01:22 <ianmathwiz7> dang it, I just lost the game
19:01:27 <shachaf> Oh, one with a number pad.
19:01:40 <applicative> NemesisD: unp :: L.ByteString -> String
19:01:47 <monochrom> UTF8 expansion pack is only $29.99
19:01:50 <argiopeweb> ianmathwiz7: I'm now firmly convinced that you are of no use to this planet and that you would be better dead. 'grats
19:02:12 <argiopeweb> monochrom: Do you have to get both?
19:02:16 <monochrom> yes
19:02:20 <argiopeweb> Drat.
19:02:22 <ianmathwiz7> argiopeweb:  that's fine
19:02:34 <argiopeweb> ianmathwiz7: Okay, as long as it's cool with you, it's cool with me.
19:02:35 <foreveryoung> ok, nvm, i'll copy it. I have some problems why ⊥ ++ ys = ⊥
19:02:47 <shachaf> foreveryoung: Homework type of problems?
19:02:49 <mauke> @src (++)
19:02:49 <lambdabot> []     ++ ys = ys
19:02:49 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:02:49 <lambdabot> -- OR
19:02:49 <lambdabot> xs ++ ys = foldr (:) ys xs
19:02:51 <argiopeweb> Because bottom + anything == bottom
19:02:57 <ianmathwiz7> lol
19:02:59 <mauke> argiopeweb: ++, not +
19:03:02 <foreveryoung> it's logical for me, but should I now any proof for that?
19:03:08 <shachaf> aristid: ...That's what he/she/it just said.
19:03:10 <argiopeweb> Fine, bottom appended to anything == bottom.
19:03:18 <foreveryoung> it's just definition?
19:03:18 <shachaf> s/aristid/argiopeweb/
19:03:20 <mauke> argiopeweb: wrong, anything ++ bottom /= bottom
19:03:48 <argiopeweb> mauke: I misspoke. I meant the one that meant bottom ++ anything.
19:03:53 <argiopeweb> prepended?
19:04:03 <mauke> foreveryoung: if you look at the source of ++, you see that it pattern matches on its first parameter
19:04:06 <shachaf> > anything ++ bottom
19:04:09 <monochrom> "x"++⊥ has a little bit more information than "no information", namely, you still get a cons cell and it has content 'x'
19:04:11 <lambdabot>   mueval-core: Time limit exceeded
19:04:13 <shachaf> > anything ++ bottom
19:04:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:04:20 <shachaf> > bottom
19:04:22 <lambdabot>   *Exception: Warning: Nuclear missile -- launched.
19:04:27 <argiopeweb> hehe
19:04:30 <monochrom> "no information" would be you don't even get a cons cell
19:04:35 <argiopeweb> > bottom ++ anything
19:04:37 <lambdabot>   *Exception: Warning: Nuclear missile -- launched.
19:04:46 <argiopeweb> ^^ That's what I tried to say.
19:05:00 <shachaf> argiopeweb: Sure, but that's what foreveryoung said too.
19:05:09 <argiopeweb> And failed miserably, admittedly.
19:05:16 <foreveryoung> but x:⊥ = ⊥ ?
19:05:23 <argiopeweb> shachaf: Except he asked why, and I answered with: Because.
19:05:32 <argiopeweb> Proof by certainty. QED
19:05:34 <mauke> foreveryoung: no
19:05:39 <monochrom> x:⊥ is not ⊥
19:05:43 <foreveryoung> I mean it should be partial list, right?
19:05:46 <shachaf> > x:bottom
19:05:48 <lambdabot>   [x*Exception: Warning: Nuclear missile -- launched.
19:05:49 <Axman6> > 1:undefined
19:05:50 <lambdabot>   [1*Exception: Prelude.undefined
19:05:54 <monochrom> you still get a cons cell, not no information
19:06:05 <foreveryoung> and it's x ++ ⊥
19:06:07 <Axman6> > head $ 1:undefined
19:06:08 <lambdabot>   1
19:06:34 <mauke> > "whatever" ++ undefined
19:06:36 <lambdabot>   "whatever*Exception: Prelude.undefined
19:07:10 <foreveryoung> I need to know that, 'cos I'm trying to prove, that for every partial lists xs ++ ys = xs and for finite it's false
19:07:48 <mauke> what
19:08:20 <foreveryoung> FOr any partial list xs we have xs ++ ys = xs
19:08:27 <foreveryoung> right?
19:08:32 <foreveryoung> 'cos I gotta prove it
19:08:44 <mauke> what do you mean by "partial list"?
19:08:45 <dolio> Depends what you mean by partial list.
19:09:10 <foreveryoung> finite list ++ bottom
19:09:19 <mauke> ok, yes
19:09:35 <foreveryoung> how to solve that? induction?
19:09:36 <mauke> then you prove bottom ++ anything = bottom and follow the recursion
19:09:39 <mauke> yeah
19:10:06 <foreveryoung> how to prove that bottom ++ anything = bottom
19:10:09 <foreveryoung> by definition?
19:10:11 <argiopeweb> foreveryoung: Is it finite list ++ bottom, or bottom ++ finite list?
19:10:31 <argiopeweb> Ah, both.
19:10:53 <mauke> foreveryoung: by looking at the definition of ++
19:11:03 <foreveryoung> argiopeweb, both
19:11:19 <argiopeweb> And the definition of bottom.
19:11:28 <ddarius> finite list ++ bottom does not equal finite list
19:11:34 <foreveryoung> mauke, so for (⊥) i got ⊥ ++ ys = ⊥ by definition
19:11:43 <mauke> I don't think so
19:11:55 <foreveryoung> err?
19:12:02 <argiopeweb> foreveryoung: Life's not that simple.
19:12:12 <foreveryoung> so how to prove that part?
19:12:16 <mauke> foreveryoung: by looking at the definition of ++
19:12:46 <monochrom> most pattern-matchings against ⊥ give you ⊥ right away. for example (\ Just x -> blah) ⊥ = ⊥, you don't even need to read inside blah.
19:12:46 <foreveryoung> @src (++)
19:12:47 <lambdabot> []     ++ ys = ys
19:12:47 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:12:47 <lambdabot> -- OR
19:12:47 <lambdabot> xs ++ ys = foldr (:) ys xs
19:13:00 <foreveryoung> there is nothing about bottom here
19:13:01 <applicative> > let x = x ++ "1,2,3" in x
19:13:04 <lambdabot>  Terminated
19:13:23 <monochrom> right, the rule is not written there
19:13:23 * applicative knows what x was
19:13:45 <foreveryoung> I mean ⊥ ++ = ⊥
19:13:52 <foreveryoung> I mean ⊥ ++ ys = ⊥
19:14:07 <shachaf> > let x = x ++ "1,2,3" in lаst x
19:14:09 <lambdabot>   '3'
19:14:17 <applicative> grrrrr
19:14:18 <argiopeweb> foreveryoung: You can say it however many times you want. Proof by repetition isn't accepted in most circles.
19:14:25 <Axman6> the reason for bottom ++ anything being bottom is that you have to pattern match on the first argument, so (++) is strict in its first argument
19:14:59 * monochrom uses proof by repetition just fine
19:15:28 <shachaf> monochrom: The Lewis Carroll method?
19:15:33 <monochrom> here is an example:
19:15:55 <monochrom> I repeat that the rule about ⊥ and pattern matching is not written there. it's written somewhere else.
19:16:02 <monochrom> (end of proof)
19:16:03 <ddarius> monochrom: That's a syntax error.
19:16:23 <monochrom> sorry, what is "that"?
19:16:23 <shachaf> monochrom: You have to say it three times: http://www.literature.org/authors/carroll-lewis/the-hunting-of-the-snark/chapter-01.html
19:16:32 <foreveryoung> Axman6, I don't get what You mean
19:17:06 <argiopeweb> monochrom: Doesn't prove it's true though. It still could be here.
19:17:24 <argiopeweb> Though I suppose proof by exhaustive search sort of does prove it true.
19:17:54 <ddarius> \Just x ->
19:18:19 <monochrom> Oh haha, (\(Just x) -> blah) ⊥ = ⊥
19:18:20 <Axman6> foreveryoung: well, to match a pattern, you need to evaluate the argument to weak head normal form (so you can tell what constructor the argument is, in this case either (:) or []). Trying to evaluate bottom to WHNF gives you bottom
19:18:59 <shachaf> ddarius: To be fair, it's not a syntax error.
19:19:12 <shachaf> More like a type error.
19:19:38 <foreveryoung> Axman6, ok I got it, but is there any formal way to prove that?
19:19:56 <monochrom> I still like to correct the error, no matter what you call it. call it symtype error
19:19:58 <Axman6> probably, but i don't know it =)
19:20:26 <foreveryoung> ⊥ : x = ⊥ right ?
19:20:31 <monochrom> no
19:20:34 <argiopeweb> shachaf: let x = x ++ "1,2,3" in last x doesn't evaluate in my ghci. Lambdabot magic?
19:20:43 <argiopeweb> @src (:)
19:20:43 <lambdabot> Source not found. You speak an infinite deal of nothing
19:20:47 <argiopeweb> Aww, come on...
19:20:54 <argiopeweb> I've seen that source.
19:20:55 <shachaf> @src []
19:20:56 <lambdabot> data [] a = [] | a : [a]
19:20:56 <monochrom> (:) doesn't need source
19:21:02 <argiopeweb> monochrom: It still has it though.
19:21:06 <argiopeweb> Thanks shachaf
19:21:08 <shachaf> argiopeweb: Not really.
19:21:08 <dibblego> > undefined : [1,2,3] !! 2
19:21:09 <lambdabot>   No instance for (GHC.Num.Num [a])
19:21:09 <lambdabot>    arising from a use of `e_11232' at <in...
19:21:29 <shachaf> > (!!2)$undefined:[1,2,3]
19:21:29 <lambdabot>   2
19:21:38 <dibblego> ta
19:21:41 <foreveryoung> so I have no idea how to prove that ⊥ ++ ys = ⊥ by definition of ++
19:21:43 <argiopeweb> shachaf: ADT declarations aren't source any more? :P
19:21:52 <shachaf> argiopeweb: That particular one isn't.
19:22:04 <monochrom> you need more than the definition of ++, yes
19:22:19 <argiopeweb> shachaf: It may be unused in the actual implementation, but it's still source.
19:22:21 <shachaf> argiopeweb: Saying "(:) is cons" is about as much as source code as that line is.
19:22:27 <foreveryoung> monochrom, so what else?
19:22:45 <monochrom> like I said, rules about pattern matching against ⊥
19:23:16 <monochrom> and this is why I insist on using proof by repetition. I'm usually forced to repeat myself
19:23:24 <argiopeweb> foreveryoung: To understand the methodology required to formulate your proof, you must grok ⊥
19:23:53 <argiopeweb> monochrom: I'm starting to see your point. :\
19:24:07 <monochrom> I'll be glad to say it again
19:26:50 <argiopeweb> Types of proof. Likely not work safe. You have been warned.
19:26:51 <argiopeweb> http://uncyclopedia.wikia.com/wiki/Proof
19:28:36 <monochrom> eh? I like uncyclopedia!
19:28:56 <argiopeweb> monochrom: As do I. Doesn't make it any more work safe. :)
19:30:22 <monochrom> http://uncyclopedia.wikia.com/wiki/ZomboCom is why I denounce camel case
19:31:40 <dmwit> Anything is possible... with... CAMELCASE
19:32:25 <argiopeweb> *dramatic cord*
19:32:54 * shachaf wonders why CamlCase is so popular with Haskell anyway.
19:33:00 <argiopeweb> Preferably from MP SFTHG
19:33:40 <argiopeweb> shachaf: Because there's no context for function names, so you just have to read them. And it's easy to break words apart when they start with big shiny letters.
19:34:42 <jose__> asd
19:34:49 <shachaf> @vixen asd
19:34:49 <lambdabot> what type of music do you like?
19:34:50 <argiopeweb> aoeZ
19:36:18 <argiopeweb> @google asd
19:36:19 <lambdabot> http://www.asdk12.org/
19:36:19 <lambdabot> Title: ASD Online -- The website of the Anchorage School District
19:36:35 <argiopeweb> Ah, so it's not just the first 3 letters of the home row on QWERTY...
19:39:22 <Nisstyre> So, what's the difference between if statements and pattern matching?
19:40:06 <argiopeweb> Nisstyre: If operates on a boolean?
19:40:20 <argiopeweb> If you mean case and pattern matching, it's just syntax. They're the same thing.
19:40:29 <Nisstyre> argiopeweb: well yeah
19:40:47 <Nisstyre> what I really meant was cases
19:40:51 <shachaf> What's the difference between #haskell and ddarius?
19:40:58 <Nisstyre> I'm just trying to understand pattern matching right now
19:41:18 <argiopeweb> Nisstyre: I hear people don't like it when you use if statements. :P
19:41:52 <argiopeweb> But yeah, no difference between case and pattern matching other than the syntax and where it can be used (in a case statement vs. on a function)
19:42:18 <scooty-puff> is it possible to define If in the type system using type families?
19:42:19 <Nisstyre> okay, that makes sense
19:42:25 <scooty-puff> i had thought i had, but it is refusing to reduce..
19:44:06 <siracusa> scooty-puff: What definition do you use?
19:45:15 <scooty-puff> http://hpaste.org/46588/if
19:46:00 <Axman6> @src Fractional
19:46:00 <lambdabot> class  (Num a) => Fractional a  where
19:46:00 <lambdabot>     (/)             :: a -> a -> a
19:46:00 <lambdabot>     recip           :: a -> a
19:46:00 <lambdabot>     fromRational    :: Rational -> a
19:46:28 <scooty-puff> i should maybe paste the full code where it doesn't reduce
19:47:10 <scooty-puff> http://hpaste.org/paste/46588/if_annotation#p46589
19:47:14 <scooty-puff> though its not the full code
19:47:23 <scooty-puff> it might give an idea of the issue
19:50:01 <siracusa> scooty-puff: Maybe you need more ~s for the If conditions
19:50:26 <scooty-puff> ok
19:54:07 <tg_> in the take' example in (http://learnyouahaskell.com/recursion)
19:54:16 <tg_> is there a way to combine the first two cases?
19:54:33 <tg_> when I tried:
19:54:58 <tg_> take n list | n <= 0 = [] | list == [] = []
19:55:01 <tg_> i got a whole slew of errors
19:55:20 <monochrom> can't be combined
19:55:35 <tg_> what am I not understanding by trying to do it that way?
19:55:40 <tg_> the nature of _ ?
19:55:44 <siracusa> tg_: Replace the second | by ||
19:55:59 <scooty-puff> siracusa, does assigning via ~ cause "evaluation"?
19:57:14 <siracusa> scooty-puff: I don't recall the details but it helps the compiler in some way.
19:57:16 <tg_> monochrom: what am I missing?
19:57:21 <scooty-puff> ok
19:57:27 <ddarius> shachaf: #haskell is much more tolerant than I am.
19:58:33 <dropdrive> What are the more performant balanced tree implementations for GHC?
19:58:37 <ddarius> "Great Sages, Great Knowers in their essence. Thus surely there is th sky, There is also its Heart Sky.  This his name The god as it is said."
19:58:48 <argiopeweb> tg_: I think you're misunderstanding _.
19:59:10 <tg_> argiopeweb: me too. Does it mean "the compiler can ignore this argument for purposes of this guard"?
19:59:17 <argiopeweb> tg_: Essentially.
19:59:24 <monochrom> haskell doesn't provide merging two patterns
19:59:49 <aavogt> or patterns
20:00:15 <argiopeweb> The first guard is, essentially, "Regardless of the contents of the second parameter (or lack thereof), if n <= 0, return an empty list"
20:00:32 <tg_> ok
20:00:42 <tg_> i only wanted to change it because it looks strange written that way
20:00:49 <tg_> but too foolish of me
20:00:55 <tg_> ty
20:04:27 <tg_> also, is there any somewhat-commonly used alternate to the (x:xs) notation?
20:04:36 <tg_> like I could use (first:rest) or something...
20:04:49 <tg_> (not that it's better) just asking if there is a common alternate
20:05:35 <monochrom> people like x:xs or c:cs or ... because it's short. but feel free to use names you like
20:05:53 * argiopeweb grumbles about network connections.
20:06:15 <tg_> monochrom: when explaining the notation, I should say "we have a list made up of x and x-es ... x:xs"?
20:06:19 <tg_> that's the idea behind it?
20:06:48 <tg_> or is it for hysterical raisins?
20:06:52 <monochrom> yeah
20:06:58 <tg_> ok
20:07:14 <ddarius> head (cat:cats)
20:07:16 <argiopeweb> tg_: Not sure if this got through: http://hpaste.org/46590/take
20:07:42 <tg_> argiopeweb: it did not. null!? oh my
20:07:46 <argiopeweb> head (topdog:otherdogs)
20:08:06 <tg_> :t null
20:08:07 <lambdabot> forall a. [a] -> Bool
20:08:18 <argiopeweb> tg_: It also works as two guards, but I combined it up as per siracusa.
20:08:22 <argiopeweb> > null []
20:08:22 <tg_> so that's a test on l
20:08:23 <lambdabot>   True
20:08:29 <argiopeweb> > null [1..]
20:08:30 <lambdabot>   False
20:08:34 <tg_> i see
20:09:09 <argiopeweb> @src take
20:09:10 <lambdabot> take n _      | n <= 0 =  []
20:09:10 <lambdabot> take _ []              =  []
20:09:10 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
20:09:35 <tg_> yeah
20:09:41 <tg_> your code is equivalent
20:09:45 <tg_> to using two guards
20:09:48 <argiopeweb> Not sure.
20:09:53 <tg_> i just compiled it that way
20:09:55 <argiopeweb> I think there are some strictness implications.
20:10:00 <argiopeweb> sec...
20:10:17 <tg_> take' n l
20:10:35 <tg_>            | n <= 0 = []
20:10:41 <tg_>              | null l = []
20:10:43 <tg_> ...
20:10:50 <tg_> compiles, and behaves expectedly
20:11:14 <argiopeweb> Yeah, it appears they're equivalent. I'm not sure why the version in Data.List isn't written that way.
20:11:18 <argiopeweb> Other than clarity.
20:11:39 <tg_> if I want the compiler to be as smart as possible, in general, should I write as many guards as possible?
20:11:43 <tg_> or just don't worry about it?
20:11:58 <argiopeweb> C route or Erlang route... hmmm..
20:12:00 <argiopeweb> :P
20:12:28 <argiopeweb> I'm not sure how to answer that question the way you wrote it, but I can say this: Never write more code than you need.
20:12:42 <tg_> it took me about 6 years to learn that erlang might be related to the Erlangen programme
20:12:45 <tg_> ness implications.
20:12:47 <tg_> 23:16 < argiopeweb> sec...
20:12:48 <tg_> spurrious paste.
20:12:53 <tg_> argiopeweb: ok
20:13:34 <argiopeweb> Yeah, Erlang route is, "Write as many pattern matches as it should match if it's working right, and let it crash all the rest of the time"
20:14:02 <tg_> and C is, you can only have one? :O
20:14:08 <argiopeweb> Which is Bad (tm) in Haskell, since we don't really have a "watch it and restart it if it dies" architecture like Erlang.
20:14:18 <argiopeweb> No, C is "Match everything, because you're screwed if you don't"
20:14:27 <tg_> well yeah, that's what I meant
20:14:32 <tg_> exhause everything in one case statement :o
20:14:37 <argiopeweb> Switch statements in C, but you know... It's almost the same...
20:16:14 <tg_> I'm not very far in, but I'm happy that while I started out essentially retyping LYAH code, now I am just writing the types and trying (successfully, most of the time) to fill in the blanks
20:16:20 <tg_> excellent book :O
20:16:31 <argiopeweb> Indeed.
20:16:57 <argiopeweb> I read through RWH, then LLYAH(fgg!) and then went back and skimmed RWH again.
20:17:10 <argiopeweb> It really made it sink in.
20:17:12 <tg_> i did Haskell Road to Logic first
20:17:17 <tg_> and almost killed myself
20:17:21 <argiopeweb> hehe
20:17:49 <tg_> then went out and learned some abstrac algebra, group theory, set theory, and a *tiny* bit of category theory
20:17:56 <tg_> and now am back to play
20:18:22 <tg_> I am so tired of trying to get things done in Mathematica
20:18:41 <argiopeweb> rofl...
20:18:55 <argiopeweb> Well, you've got the math background.. Now all you need is the syntax.
20:19:31 <tg_> and I'm trying to understand denotational semantics
20:19:42 <tg_> at least, trying to understand how to apply its principles always
20:19:53 <tg_> seems like it often means doing no more or less than haskell requires you to do
20:25:03 <dolio> tg_: Denotational semantics is a way of assigning meaning to programs.
20:25:26 <dolio> Where the meanings are mathematical objects.
20:25:30 <tg_> dolio: yeah, I understand that... I think.
20:25:52 <tg_> I am thinking of denotational semantics as [function[range -> domain]] semantics
20:25:57 <tg_> where you explicitly lay out the domains
20:26:09 <tg_> i have a set of slides from U of I
20:26:22 <tg_> http://www.cs.uiowa.edu/~slonnegr/plf/Lecture09.pdf
20:26:25 <tg_> they seemed sort of helpful
20:27:21 <tg_> I have the question lingering, if denotational semantics are the bees knees, then why have axiomatic and algebraic semantics?
20:27:27 <tg_> Just because you can't prove everything with denotational?
20:27:58 <dolio> Denotational semantics isn't everything.
20:28:17 <tg_> dolio: no, but conal is pretty smart and he strongly advocates using that technique :O
20:30:39 <dolio> I think some people get caught up by his advocacy of that to an unhelpful degree, to be honest.
20:31:48 <dolio> A while back I recall someone really enthused with his stuff coming in here and talking about how the pure parallelism annotations would be somehow easier to understand if only there was some denotational account of them.
20:31:50 <tg_> dolio: perhaps, but I am working on a web-based haskell UI (like tryhaskell) where you have explicit specification of the domains for a set of lines
20:32:12 <dolio> But the whole point of those is that they are denotationally just constant functions. They're merely operational hints.
20:32:44 <tg_> like, you might say something like "Everything in this section is defined over [Z]U[inf]"
20:33:27 <tg_> or, the possible domains are [Z], [ZZ] (squares), and [Colors] (set of colors"
20:33:31 <tg_> something along those lines
20:33:48 <tg_> seemed like denotational semantics would be a swell way to lay out those kinds of restrictions
20:34:46 <tg_> dolio: but I do take your advice... haskell is not a strictly idiomatic language, there is room for pragmatisim
20:35:23 <dolio> I'm not talking about pragmatism.
20:35:59 <dolio> Denotational semantics isn't always the appropriate way to think about the meaning of a program.
20:36:12 <tg_> Are you not? You are saying - don't get too focused on a specific set of guiding principles because you may miss the forest through the trees?
20:36:12 <dolio> Even from some abstract perspective.
20:36:41 <tg_> dolio: Can you think of when it "generally" is or isn't?
20:36:46 <NemesisD> Network.Curl is kind of a nightmare
20:38:19 <dolio> tg_: Sometimes you're interested in more than just, "what is the answer?"
20:38:32 <dolio> But that is all denotational semantics is about, at its core.
20:38:50 <tg_> dolio: like, is this the right question? is this a meaningful question?
20:39:06 <dolio> Operational is more like, "how do we arrive at the answer?"
20:39:35 <dolio> And algebraic is more like, "what transforms of our programs preserve the answer?"
20:39:50 <tg_> lol
20:40:02 <tg_> damn algebraists
20:41:38 <dolio> Sometimes you can look at one to see the other.
20:42:04 <dolio> You can look at what the denotational semantics of two expressions are to see if there is a valid algebraic equation between them.
20:42:14 <NemesisD> aristid: ping, i hear word on the internets that you know a thing or two about Network.Curl
20:42:56 <dolio> But sometimes you care more about the transformations, and not about what the specific model underlying those transformations is.
20:50:01 <tg_> dolio: if you care to indulge me, do you view the denotational -> "compilation", operational -> "interpretation" analogy in http://en.wikipedia.org/wiki/Formal_semantics_of_programming_languages
20:50:07 <tg_> as reasonable?
20:51:54 <dolio> It makes some sense, yes.
20:52:43 <dolio> Although you can have a denotational take on interpretation, too.
20:52:56 <dolio> If you look at normalization by evaluation, for instance.
20:53:46 <dolio> Using that, you define a datatype that contains only normal forms, or something of the sort.
20:54:17 <checkertimeer> @src Maybe
20:54:18 <lambdabot> data Maybe a = Nothing | Just a
20:54:24 <checkertimeer> @src Nothing
20:54:24 <lambdabot> Source not found. Do you think like you type?
20:54:31 <checkertimeer> @src Just
20:54:31 <lambdabot> Source not found. :(
20:54:42 <dolio> Then you write functions to combine normal forms in an appropriate way, and define an evaluator from syntactic terms to the normal forms compositionally, like with denotational semantics.
20:54:49 <checkertimeer> @src unfoldr
20:54:50 <lambdabot> unfoldr f b  = case f b of
20:54:50 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
20:54:50 <lambdabot>    Nothing        -> []
20:55:28 <dolio> Then you get a syntactic term back by embedding the normal form back into the syntax, if you wish.
20:55:34 <checkertimeer> hi, could You tell me any example of using unfoldr?
20:56:22 <dolio> This would be opposed to some strategy where you look for redexes in the syntactic term, and perform substitutions or something.
20:57:59 <Axman6>  unfoldr (\x -> case x of 0 -> '0'; n -> Just (divMod n 2)) 1234
20:58:11 <Axman6> > unfoldr (\x -> case x of 0 -> Nothing; n -> Just (divMod n 2)) 1234
20:58:12 <lambdabot>   [617]
20:58:18 <Axman6> hmm
20:58:38 <Axman6> > unfoldr (\x -> case x of 0 -> Nothing; n -> Just ((\(x,y)->(y,x)) divMod n 2)) 1234
20:58:38 <lambdabot>   Couldn't match expected type `t -> t1 -> (a, b)'
20:58:39 <lambdabot>         against inferred t...
20:58:47 <Axman6> > unfoldr (\x -> case x of 0 -> Nothing; n -> Just ((\(x,y)->(y,x)) (divMod n 2))) 1234
20:58:48 <lambdabot>   [0,1,0,0,1,0,1,1,0,0,1]
20:58:55 <Axman6> > unfoldr (\x -> case x of 0 -> Nothing; n -> Just ((\(x,y)->(y,x)) (divMod n 2))) 16
20:58:56 <lambdabot>   [0,0,0,0,1]
20:58:58 <Axman6> hmm
20:59:05 <tg_> dolio: that last part left me more confused, but I'll take it up again another day
20:59:11 <tg_> For now, sleep. Thanks.
21:03:35 <checkertimeer> damn, I still don't get it
21:08:31 <checkertimeer> could YOu describe how it works?
21:09:39 <argiopeweb> checkertimeer: Just check the documentation. It's pretty clear.
21:09:44 <argiopeweb> It works backwards from foldr.
21:09:47 <argiopeweb> >  unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
21:09:48 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
21:10:05 <argiopeweb> @src unfoldr
21:10:05 <lambdabot> unfoldr f b  = case f b of
21:10:06 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
21:10:06 <lambdabot>    Nothing        -> []
21:10:45 <liyang> Does anyone know if Ashley Yakeley IRCs?
21:11:08 <argiopeweb> liyang: Girls on the internet? I refuse to believe it's a possibility.
21:11:29 <liyang> I imagine he gets that comment a lot.
21:11:32 <argiopeweb> ;)
21:11:43 <argiopeweb> But know, I don't know.
21:11:50 <argiopeweb> No, even. Wow.
21:14:19 <checkertimeer> >  unfoldr (\b -> if b == 0 then Nothing else Just (b `mod` 10, b `div` 10))
21:14:20 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> [b])
21:14:20 <lambdabot>    arising from a use of...
21:14:36 <checkertimeer> >  unfoldr (\b -> if b == 0 then Nothing else Just (b `mod` 10, b `div` 10)) 1234
21:14:37 <lambdabot>   [4,3,2,1]
21:15:06 <checkertimeer> >  unfoldr (\b -> if b == 0 then Nothing else Just (b `mod` 10, b `div` 10, b+1)) 1234
21:15:07 <lambdabot>   Couldn't match expected type `(a, b)'
21:15:07 <lambdabot>         against inferred type `(b, b,...
21:15:20 <checkertimeer> >  unfoldr (\b -> if b == 0 then Nothing else Just (b `mod` 10)) 1234
21:15:21 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b)
21:15:23 <argiopeweb> Not a use I would have thought of, but clever.
21:15:29 <checkertimeer> >  unfoldr (\b -> if b == 0 then Nothing else Just (b `mod` 10, bottom)) 1234
21:15:30 <lambdabot>   Not in scope: `bottom'
21:15:37 <checkertimeer> >  unfoldr (\b -> if b == 0 then Nothing else Just (b `mod` 10, b)) 1234
21:15:38 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
21:15:46 <checkertimeer> ok, get it :)
21:16:04 <checkertimeer> it's like a loop, isn't it?
21:16:25 <checkertimeer> >  unfoldr (\b -> if b == 0 then Nothing else Just (b `mod` 10, b-1)) 1234
21:16:26 <lambdabot>   [4,3,2,1,0,9,8,7,6,5,4,3,2,1,0,9,8,7,6,5,4,3,2,1,0,9,8,7,6,5,4,3,2,1,0,9,8,...
21:16:27 <argiopeweb> fold reduces lists to values. unfold builds lists form values.
21:16:33 <dmwit> > unfoldr (\b -> guard (b /= 0) >> return (b `mod` 10, b)) 1234
21:16:34 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
21:16:54 <argiopeweb> s/form/from/
21:16:59 <checkertimeer> May I see any example of foldr?
21:17:02 <argiopeweb> It must be getting late. That's 2.
21:17:08 <dmwit> > foldr f [x, y, z]
21:17:08 <checkertimeer> :t foldr
21:17:09 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
21:17:09 <lambdabot>    arising fr...
21:17:09 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:17:19 <dmwit> > foldr f z [w, x, y]
21:17:20 <lambdabot>   f w (f x (f y z))
21:17:25 <argiopeweb> > foldr (+) 0 [1..10]
21:17:26 <lambdabot>   55
21:17:49 <checkertimeer> > foldr (+) 1000 [1..100]
21:17:50 <lambdabot>   6050
21:17:52 <argiopeweb> dmwit: Cool. Got to love higher order functions.
21:18:03 <checkertimeer> > foldr (/) 1000 [1..100]
21:18:04 <lambdabot>   79.58923738717874
21:18:04 <Axman6> > foldr f z [a,b,c]
21:18:05 <lambdabot>   f a (f b (f c z))
21:18:14 <Axman6> > foldr (`f`) z [a,b,c]
21:18:15 <lambdabot>   <no location info>: parse error on input `)'
21:18:18 <Axman6> :(
21:18:28 <Axman6> > foldr (*) z [a,b,c]
21:18:29 <lambdabot>   a * (b * (c * z))
21:18:30 <NemesisD> has anyone had success with Network.Curl posting data? i'm having a really though time posting data with a given content type
21:18:31 <dmwit> Axman6: It wouldn't do what you want even if that was valid syntax.
21:18:48 <Axman6> it would be nice if it did
21:18:59 <Axman6> but i can see why it can't
21:19:06 <checkertimeer> nice, thanks a lot
21:19:38 <dmwit> > unfoldr (\b -> guard (b > 0) >> return (b `divMod` 10)) 1234
21:19:39 <lambdabot>   [123,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
21:20:03 <argiopeweb> Denied.
21:20:06 <dmwit> > unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) 1234
21:20:07 <lambdabot>   [4,3,2,1]
21:20:09 <dmwit> better
21:20:13 <argiopeweb> Yep.
21:20:17 <argiopeweb> You need modDiv
21:20:32 * dmwit gets lost in thought contemplating Muad Dib
21:20:35 <checkertimeer> reverse unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) 1234
21:20:43 <checkertimeer> > reverse unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) 1234
21:20:44 <lambdabot>   Couldn't match expected type `[a]'
21:20:44 <lambdabot>         against inferred type `(b -> Dat...
21:20:50 <checkertimeer> > reverse $ unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) 1234
21:20:51 <Axman6> reverse $ ...
21:20:51 <lambdabot>   [1,2,3,4]
21:21:03 <dmwit> > map digitToInt $ show 1234
21:21:03 <checkertimeer> > reverse ( unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) 1234 )
21:21:04 <lambdabot>   [1,2,3,4]
21:21:04 <lambdabot>   [1,2,3,4]
21:21:08 <argiopeweb> @google Maud Dib
21:21:09 <lambdabot> http://en.wikipedia.org/wiki/Muad'Dib
21:21:09 <lambdabot> Title: Muad'Dib - Wikipedia, the free encyclopedia
21:21:32 <argiopeweb> Great success.
21:22:05 <checkertimeer> > map intToDigit $ reverse $ unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) 1234
21:22:05 <lambdabot>   "1234"
21:22:11 <Axman6> > let intToBase b x = reverse $ unfoldr (\y -> guard (y > 0) >> return (y `mod` b, y `div` b)) x in intToBase 2 1234
21:22:12 <lambdabot>   [1,0,0,1,1,0,1,0,0,1,0]
21:22:12 <dmwit> haha
21:22:19 <Axman6> > let intToBase b x = reverse $ unfoldr (\y -> guard (y > 0) >> return (y `mod` b, y `div` b)) x in intToBase 16 1234
21:22:20 <lambdabot>   [4,13,2]
21:22:21 <argiopeweb> dmwit: 'grats, you just implemented the Digit library. :P
21:22:29 <Axman6> > let intToBase b x = reverse $ unfoldr (\y -> guard (y > 0) >> return (y `mod` b, y `div` b)) x in intToBase 8 1234
21:22:30 <lambdabot>   [2,3,2,2]
21:22:49 <Axman6> > let intToBase b x = reverse $ unfoldr (\y -> guard (y > 0) >> return (y `mod` b, y `div` b)) x in intToBase 3 1234
21:22:50 <lambdabot>   [1,2,0,0,2,0,1]
21:23:22 <dmwit> issue 452: xmonad is not 1000 lines short any more
21:23:23 <checkertimeer> > map intToDigit $ reverse $ unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) -1234
21:23:24 <lambdabot>   Couldn't match expected type `[a]' against inferred type `b -> [b]'
21:23:25 <dmwit> =D
21:24:48 <checkertimeer> > IntToString n | n<0 = '-':g | otherwise = g where g = map intToDigit $ reverse $ unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) $ abs b
21:24:49 <lambdabot>   <no location info>: parse error on input `|'
21:25:06 <argiopeweb> dmwit: That's not an issue. I like having Gnome support. :P
21:25:14 <checkertimeer> why it doesn't work?
21:25:34 <Axman6> you need to use let and functions have tp start with lowercase letters
21:25:51 <checkertimeer> > let intToString n | n<0 = '-':g | otherwise = g where g = map intToDigit $ reverse $ unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) $ abs b
21:25:52 <lambdabot>   not an expression: `let intToString n | n<0 = '-':g | otherwise = g where g...
21:26:05 <checkertimeer> ?
21:26:13 <argiopeweb> Isn't lambda still on 6.*?
21:26:28 <argiopeweb> I.E. no guards in let?
21:28:02 <dmwit> No guards in let?
21:28:15 <checkertimeer> so how can I do it here?
21:28:18 <dmwit> Gaurds in let are certainly H98 if not Hearlierthanthat.
21:28:36 <c_wraith> your let is missing an "in"
21:28:46 <c_wraith> therefore it's not a valid expression
21:28:47 <argiopeweb> dmwit: Ah, good point. It was multi-line let that got added.
21:28:59 <checkertimeer> c_wraith, what's wrong with it?
21:29:29 <c_wraith> it's incomplete.  you're not telling it any expression to use that definition in
21:29:37 <argiopeweb> > let intToString n | n<0 = '-':g | otherwise = g where g = map intToDigit $ reverse $ unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) $ abs b in intToString 10
21:29:38 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:29:38 <lambdabot>         against inferred type ...
21:30:15 <checkertimeer> what about this: http://pastebin.com/3bG5yyFS
21:30:25 <checkertimeer> I don't wanna paste such big code here
21:30:35 <argiopeweb> Yeah, that function's incredibly invalid anyway. It won't type check. look at the where vs. guard.
21:31:06 <checkertimeer> please look at that: http://pastebin.com/3bG5yyFS - is it ok now?
21:31:32 <checkertimeer> i'm trying to write my own "show"
21:32:04 <argiopeweb> @hoogle intToDigit
21:32:05 <lambdabot> Data.Char intToDigit :: Int -> Char
21:32:21 <argiopeweb> Yeah, that works.
21:32:34 <dmwit> > let intToString n | n<0 = '-':g | otherwise = g where g = map intToDigit $  reverse $ unfoldr (\b -> guard (b > 0) >> return (b `mod` 10, b `div` 10)) $  abs n in intToString 10
21:32:35 <lambdabot>   "10"
21:32:43 <Axman6> > map intToDigit $ ['0'..'9'] ++ ['a'..]
21:32:44 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:32:44 <lambdabot>         against inferred type ...
21:32:53 <Axman6> > map digitToInt $ ['0'..'9'] ++ ['a'..]
21:32:55 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,*Exception: Char.digitToInt: not a d...
21:32:59 <dmwit> argiopeweb: I don't see why that function is incredibly invalid. All I see is an "abs b" that should be an "abs n". =)
21:33:03 <Axman6> > map intToDigit $ [0..]
21:33:04 <lambdabot>   "0123456789abcdef*Exception: Char.intToDigit: not a digit 16
21:33:24 <argiopeweb> dmwit: It isn't. I'm incredibly tired and shouldn't be speaking.
21:34:02 <argiopeweb> I saw a character comparison where there was none.
21:35:01 * argiopeweb debates the wisdom of buying a TypeMatrix keyboard...
21:35:48 <checkertimeer> thanks a lot for help ;]
21:35:50 <checkertimeer> bye
21:39:16 <Axman6> argiopeweb: those look quite cool :o
21:41:24 <argiopeweb> Axman6: They really are. I'm reading up on what other people have to say and the reviews are pretty decent.
21:41:47 <Axman6> i wanted a frogpad ages ago, but it seems they've basically gone bust :(
21:42:01 <argiopeweb> My problem is that almost everything's out of stock. Their current recommendation to get a Dvorak keyboard is to buy a blank + a clear dvorak cover (because black isn't in stock)
21:42:31 <argiopeweb> I emailed them and they said they're looking at 1-2 months to get covers in stock, and end of August for the Dvorak keyboards in the best case scenario.
21:42:44 <nodename> hey I have a package installation problem, can anyone help?
21:42:48 <blackdog> argiopeweb: weirdly enough, i'm a dvorak user and a typematrix
21:42:50 <blackdog> *user
21:42:57 <argiopeweb> blackdog: The 2020 or the 2030?
21:43:00 <blackdog> i highly recommend them - get the old one if you can though
21:43:13 <blackdog> the keyboard's more spread out. good if you've got wide shoulders.
21:43:15 <argiopeweb> 2020, 2030v1, or 2030v2? :P
21:43:24 * hackagebot repa 2.0.0.4 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.0.0.4 (BenLippmeier)
21:43:25 <blackdog> 2020 i think
21:43:57 <blackdog> the one with two backspaces in the middle
21:44:25 <Axman6> i love the dual qwerty/dvorak layout
21:44:27 <argiopeweb> Yeah, that's the 2020.
21:45:36 <argiopeweb> Oh, grr.
21:45:51 <argiopeweb> blackdog: 2020 is ps/2. No laptop usage there.
21:46:52 <blackdog> argiopeweb: i got an adaptor
21:47:04 <nodename> C:\\Users\alan\AppData\Local\Temp\cairo-0.11.1128\cairo-0.11.1\Gtk2HsSetup.hs:190:70:
21:47:05 <nodename>     Couldn't match expected type `[PackageDB]'
21:47:05 <nodename>                 with actual type `PackageDB'
21:47:05 <nodename>     Expected type: PackageDBStack
21:47:05 <nodename>       Actual type: PackageDB
21:47:05 <nodename>     In the sixth argument of `registerPackage', namely `packageDb'
21:47:07 <nodename>     In the expression:
21:47:09 <nodename>       registerPackage
21:47:11 <nodename>         verbosity installedPkgInfo pkg lbi inplace packageDb
21:47:13 <nodename> C:\\Users\alan\AppData\Local\Temp\cairo-0.11.1128\cairo-0.11.1\Gtk2HsSetup.hs:190:70:
21:47:15 <nodename>     Couldn't match expected type `[PackageDB]'
21:47:17 <nodename>                 with actual type `PackageDB'
21:47:19 <nodename>     Expected type: PackageDBStack
21:47:21 <nodename>       Actual type: PackageDB
21:47:23 <nodename>     In the sixth argument of `registerPackage', namely `packageDb'
21:47:25 <nodename>     In the expression:
21:47:27 <nodename>       registerPackage
21:47:29 <nodename>         verbosity installedPkgInfo pkg lbi inplace packageDb
21:47:31 <nodename> C:\\Users\alan\AppData\Local\Temp\cairo-0.11.1128\cairo-0.11.1\Gtk2HsSetup.hs:190:70:
21:47:33 <argiopeweb> > concat ["dot","dot","dot"]
21:47:35 <lambdabot>   "dotdotdot"
21:51:02 <oldpew> blackdog: I was going to say that the old version had better arrow key placement than the new, but apparently they fixed in 2030 v2.
21:51:51 <blackdog> oldpew: i'm not such a fan of the actual movement of the keys on the typematrix, but vertically aligned keys are just so much better that i'll wear it
21:52:07 <blackdog> the kinesis is pretty nice, but i think it ruins you for anything else, and it's a huge piece of kit to boot.
21:52:28 <oldpew> Word has it the new ones are between the low-pro laptop and a regular keyboard.
21:52:31 <oldpew> How are the old ones?
21:52:49 <blackdog> in terms of what?
21:52:55 <oldpew> Key throw
21:53:34 <blackdog> oh. worse than average. better than a laptop
21:53:52 * oldpew tends to modify keyboards to have less throw than average...
21:54:18 <oldpew> And yes, this is #treasureisland now.
21:54:24 <blackdog> oldpew: weirdo :)
21:54:34 <blackdog> treasure island?
21:56:06 <oldpew> Excerpt: "Some months later, Bones is visited by a mysterious sailor named Black Dog. Their meeting turns violent, Black Dog flees, and Bones suffers a stroke. While Jim cares for him, Bones confesses that he was once the mate of the late notorious pirate, Captain Flint, and that his old crewmates want Bones's sea chest.
21:56:07 <oldpew> Some time later, another of Bones's crewmates, a blind man named Pew"
21:56:58 <oldpew> Forgot ... at the end. It continues for another 8 pages.
21:59:44 <argiopeweb> blackdog: I went ahead and switched to dvorak earlier today (keyboard keys too, though I'm currently typing in Qwerty purely in order to be conversational) It's legitimately frustrating how little hand movement I need. Particularly so because the laptop keyboard is constraining if you're staying in one place.
22:01:25 <blackdog> argiopeweb: heh, nice. i got 'blackdog' from led zeppelin and les murray...
22:02:17 <argiopeweb> hehe... They never make it down to my neck of the woods. :\
22:02:29 <argiopeweb> The cover band, that is.
22:02:34 <argiopeweb> The song is obvious.
22:14:52 <blackdog> argiopeweb: i like the darker side of it too - les murray used to talk about his depression as a black dog stalking him
22:16:21 <argiopeweb> blackdog: Heh, you've got more back-story behind your name than I behind mine...
22:18:29 <argiopeweb> Oh, and I fully intend to join y'all in your project a week goal; however, I will be deferring starting the timer till Sunday after I move.
22:19:07 <blackdog> argiopeweb: cool. going to try to synchronise a bit so we all finish at the same time, i think
22:19:19 <blackdog> jfredett said the 17th - that works for me
22:19:29 <argiopeweb> Ah, sounds good. In that case, I'll defer to some day after Saturday. :P
22:19:37 <blackdog> maybe just jump in when you're ready
22:19:44 <argiopeweb> So, Wed-Tue cycle?
22:19:46 <blackdog> or cheat and get some work in early:)
22:20:12 <argiopeweb> Well, I was going to write specifications in week 1, but if I have 3 free days... :P
22:22:23 <argiopeweb> Though I may find a main project related library to port. Not sure there are any worth porting at the moment.
22:37:54 <argiopeweb> I'm probably going to start a flame war here if anyone's still awake/alert, but does the must-share + must-provide-source nature of the GPL not inherently unfriendly to the general coding community (in that I have to re-invent the wheel for both more open [BSD/MIT] and proprietary products)?
22:38:48 * Axman6 doesn't understand the question
22:40:16 <c_wraith> s/does/is/
22:40:51 <argiopeweb> I make a library and release it under the GPL. You want to use that library in your proprietary code and [pay me|credit me|ignore the fact that I exist]. None of this can happen without you switching your proprietary product to a GPL product (with version number >= mine).
22:41:12 <argiopeweb> c_wraith: Thanks. I'm down to a 1/4 sentence memory buffer at the moment.
22:41:26 * kfish yawns
22:42:04 <dons> kfish: yo yo
22:42:08 <kfish> argiopeweb, it's up to you as the copyright holder to offer other non-GPL licenses if you want
22:42:11 <kfish> hi dons!
22:42:18 <dons> howzit?
22:42:24 <kfish> not bad mate
22:42:30 <pikhq_> argiopeweb: The principle of the creator of the GPL is that, *by aiding in proprietary products*, you are being unfriendly to the general coding community.
22:42:54 <kfish> hey quick q dons: bytestring-mmap seems to be a stripped down version of mmap, is that right?
22:42:57 <dons> kfish: i'm moving to nyc, to do finance/hasskell stuff, did you see?
22:43:04 <dons> kfish: yep.
22:43:05 <kfish> dons, omg no i didn't see that
22:43:07 <pikhq_> argiopeweb: And that it's pretty irrelevant whether or not you're being unfriendly to someone who's going to be unfriendly to you.
22:43:08 <kfish> who are you working for?
22:43:12 <Axman6> dons: leaving Galois?
22:43:12 <dons> scb
22:43:16 <dons> Axman6: yep
22:43:18 <argiopeweb> pikhq_: In that all proprietary products are inherently bad? Seems extreme even coming from rms.
22:43:26 <pikhq_> argiopeweb: That is the stance of RMS.
22:43:36 <kfish> dons, congrats :)
22:43:53 <dons> cheers
22:44:00 <Axman6> argiopeweb: have you ever seen RMS in person? he's an extremeist nut
22:44:00 <kfish> dons, will you be able to keep doing random lib hacking?
22:44:11 <argiopeweb> Axman6: Never met him.
22:44:35 <dons> kfish: i reckon so. as much as ndm or malcolm or augustsson can.
22:44:39 <dons> Axman6: https://twitter.com/#!/donsbot/status/63984141179432960
22:44:40 <pikhq_> argiopeweb: Though it's actually a fairly common stance, really — what's argued is more whether or not it's an ULTIMATE EVIL or just an unfortunate practice or a minor annoyance or whatever else.
22:44:42 <Axman6> he did a talk at ANU last year
22:45:06 <kfish> dons :)
22:45:23 <dons> kfish: will be in singapore for some % of the year
22:45:27 <c_wraith> dons: I'm not going to run into you on the street anymore at lunch time?  That's too bad.
22:45:42 <kfish> dons, really? we are starting an office in singapore next month, and i might be moving there soonish
22:45:49 <Axman6> dons: you could go and give talks to the rest of the Tsuru crew
22:45:49 <dons> c_wraith: sadly no.
22:45:56 <dons> kfish: inneresting..
22:46:03 <kfish> heh :)
22:46:04 <pikhq_> dons, kfish: Good luck not running afoul of the freakish laws.
22:46:12 <dons> kfish: will be there july-sep 2011
22:46:18 <kfish> ok
22:46:28 <Axman6> kfish: i thought you were going to stay in Japan?
22:46:33 <argiopeweb> pikhq_: Looking at it from the point of view of a SE major and long time programmer (who is saddened by the speed at which commercial software is developed/updated), I'd rather give the corps. some freedom and let them help the copyleft/free/oss community by improving the world in general.
22:47:34 <dons> also nyc peeps. let's make fpnyc work.. :) (if you're awake)
22:47:43 <argiopeweb> pikhq_: No freakish laws here. Just red-light cameras, surveillance cameras, and the TSA looking at you under your clothes.
22:47:51 <dmead> dons, coming to hac phi?
22:47:59 <kfish> Axman6, meh, depends on family etc., too ...
22:48:07 <dons> dmead: maybe. depends on singapore. timing might be tricky, but i'm trying
22:48:12 <jmcarthur> dons: we totally should
22:48:14 <dons> otherwise singapore fp group
22:48:22 <dons> jmcarthur: woot
22:48:22 <argiopeweb> dons: Heh, the east coast should all be asleep. Only oddities like myself are up.
22:48:23 <jmcarthur> i am also moving to new york soon
22:48:57 <dons> nice. what you doing there?
22:49:07 <jmcarthur> jane street
22:49:58 <dons> jmcarthur: very nice. i'll be in mid-town doing haskell stuff
22:50:12 <dons> so you totally want to switch teams ;)
22:50:21 <jmcarthur> heh
22:50:31 <jmcarthur> well... i haven't quite accepted the offer yet
22:50:45 <dons> you should. they're very nice guys
22:50:45 <jmcarthur> waiting on word from one more opportunity before i do
22:50:52 <dmwit> Probably most NYC folks are asleep -- it's 0200. =)
22:51:02 <dons> #1 wall street, iirc
22:51:09 <dons> nice office
22:51:42 <jmcarthur> heh, it was undergoing some modifications when i was there
22:52:13 <argiopeweb> dons: The BNY Mellon Building?
22:52:19 <Axman6> dons: do you know (and can you say) what sort of work you'll be doing?
22:53:20 <dons> Axman6: fp for traders.
22:53:23 <augur> any spanish speakers? :D
22:53:33 <augur> or french speakers
22:53:42 <Axman6> dons: somewhat like what Tsuru are doing?
22:53:48 <jmcarthur> augur: weren't you also asking for german earlier?
22:53:54 <augur> i was!
22:53:56 <augur> then i found one!
22:54:01 <jmcarthur> why so many languages?
22:54:26 <augur> jmcarthur: different languages have different properties
22:54:52 <jmcarthur> well time for bed. i need to stop staying up until 1am
22:56:31 <argiopeweb> Meh, same here (just it's 2 for me.)
22:56:37 <argiopeweb> Y'all have a good one.
22:57:41 <synonymous> augur, what is it that you're doing? I'm not a native spanish speaker, but I could try to help…
22:57:51 <augur> nope, i need a native speaker :p
22:57:53 <augur> but thanks anyway
22:58:10 <synonymous> could help with russian 100%))
23:00:09 <Axman6> dons, kfish: you should both be happy you're not back in Aus at the moment, it's bloody freezing at the moment (15 in sydney, 8 her ein Canberra with an apparent temp of about 0)
23:00:35 <kfish> 15 and rainy in tokyo atm :(
23:02:22 <synonymous> Axman6: at least not as windy as in the last few days!
23:02:38 <Axman6> it's really windy here
23:02:51 <synonymous> too bad..not in syd
23:03:40 <dons> Axman6: it is 15 in summer in pdx. i'm in a tshirt
23:04:20 <Axman6> ouch
23:04:39 <dons> you harden up a bit
23:04:40 <c_wraith> though there's always one week where it's 40
23:04:48 <c_wraith> and you wonder where that came from
23:04:58 <c_wraith> and why you don't have air conditioning, for just that week
23:04:59 <dons> yup
23:05:25 <Axman6> it's hard to harden up when the temps go from -5 in winter to over 40 in summer -_-
23:05:28 <shachaf> Ah, the lovely pacific northwest weather.
23:05:30 <luite> freezing is good!
23:05:42 * shachaf 's family may or may not be moving to Portland soon.
23:05:50 <luite> (at least if you have snow to ski or ice to skate)
23:06:19 <shachaf> dons: How much longer are you in PDX?
23:06:35 <dons> about 2 weekss
23:07:37 <pikhq_> Curse your lack of units.
23:07:56 <pikhq_> So very confusing seeing "40 in summer" referring to a place in the US.
23:07:57 <shachaf> pikhq_: Fine, 15 *degrees*.
23:07:57 <c_wraith> pikhq_: those wera all C
23:08:07 <pikhq_> c_wraith: Yes, I gathered as much.
23:08:09 <shachaf> (Real degrees, of course.)
23:08:16 <pikhq_> After initial confusion.
23:08:23 <c_wraith> pshaw.  real degrees are Kelvin :)
23:08:25 <pikhq_> "40°F in summer? Holy crap that's cold."
23:08:29 <shachaf> c_wraith: Those aren't degrees.
23:08:33 <c_wraith> ...  nevermind that Kelvin isn't in degrees
23:08:36 <pikhq_> 40 K in summer would be even worse.
23:08:43 <shachaf> pikhq_: Confusion is good for you.
23:08:45 <c_wraith> is 40 Rankine better?
23:08:53 <pikhq_> Not really.
23:08:56 <shachaf> Nothing Rankine is better.
23:09:26 <c_wraith> though honestly, from the perspective of "weather", 40 K and 40 R are pretty much the same.  "the sun went out"
23:10:18 <pikhq_> "The Sun went out, and we are doomed."
23:13:53 <synonymous> is it possible to load/unload packages from within GHCi?
23:14:47 <companion_cube> synonymous, you mean modules ?
23:15:46 <synonymous> companion_cube: no, alternative to saying ghci -package <pkg name>, but from ghci command prompt.
23:16:17 <synonymous> companion_cube: problem is Could not find module `Data.Array.Parallel.Unlifted'
23:16:18 <synonymous>     It is a member of the hidden package `dph-prim-interface-0.5'.
23:16:18 <synonymous>     It is a member of the hidden package `dph-prim-seq-0.5'.
23:16:18 <synonymous>     It is a member of the hidden package `dph-prim-par-0.5'.
23:16:37 <companion_cube> then i don't know, soryy
23:16:39 <companion_cube> sorry*
23:17:07 <c_wraith> :set -hide-package foo
23:17:27 <c_wraith> or, in that case
23:17:31 <c_wraith> :set -package foo
23:18:09 <synonymous> c_wraith: that did it, thank you!
23:47:39 * hackagebot time 1.2.0.5 - A time library  http://hackage.haskell.org/package/time-1.2.0.5 (AshleyYakeley)
23:57:56 <ivanm> if you can re-export a module, why can't you stop that re-exported module from being imported using hiding?
23:58:46 * hackagebot certificate 0.9.0 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.9.0 (VincentHanquez)
