04:09:26 --- topic: '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
04:09:26 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Mar 26 17:29:18 2011]
04:15:35 <djanatyn> man, haskell is mystically magical :P
04:29:51 <mekeor> djanatyn: i fully agree — i love haskell
04:29:58 <djanatyn> Hmmm...Anyone wanna debug my super cool function? :)
04:30:22 <Phyx-> if it was super cool it wouldn't need debugging
04:30:33 <djanatyn> Yeah.
04:30:39 <djanatyn> http://hpaste.org/46272/haskell_rocks_sadly_i_dont <-- blah!
04:30:39 <Snufsen> Maybe it's a super cool bug?
04:30:56 <djanatyn> Perhaps.
04:31:05 <djanatyn> I think all bugs in Haskell are super cool.
04:31:24 <djanatyn> I think it has something to do with my typeclass declaration thingy.
04:31:31 <Botje> djanatyn: what's there to debug?
04:31:48 <djanatyn> When I try to load it up in ghci, it gives me the following error:
04:32:13 <djanatyn> http://hpaste.org/paste/46272/haskell_rocks_sadly_i_dont#p46273
04:32:31 <dabblego> guessingGame :: (Ord a, Num a) => a -> String
04:32:43 <Botje> oh, right
04:32:46 <Botje> yeah, that.
04:32:46 <djanatyn> Hmm
04:32:46 <dabblego> guessingGame :: (Eq a, Ord a, Num a) => a -> String
04:32:49 <dabblego> you'll need that too
04:32:53 <djanatyn> Okay, now I'm confused :)
04:33:07 <Botje> dabblego: Num already includes Eq
04:33:08 <djanatyn> So, why exactly am I attaching the Eq and Ord typeclass?
04:33:08 <dabblego> actually no you won't, since Ord implies it
04:33:16 <dabblego> just Ord
04:33:21 <dabblego> because you are comparing for order
04:33:28 <djanatyn> And that's because I'm comparing for order, right
04:33:31 <djanatyn> oh, yeah, right :D
04:33:37 <djanatyn> yep, it works :D
04:33:39 <merijn> djanatyn: I see the problem. You are using "<" and ">" to compare for order, but not all numbers are ordered
04:33:49 <merijn> (Example, complex numbers...)
04:33:50 <djanatyn> Ah, you know what I should do?
04:34:08 <djanatyn> I should put that over 9,000 thing *above* the "number > 5"
04:34:21 <djanatyn> Otherwise, it'll just jump to that statement first and my over 9,000 statement will never execute.
04:35:34 <mekeor> right. and furthermore it should be "| number >= 9000", shouldnt it?
04:35:38 <merijn> Adding "Ord a" to the signature basically restricts your function to a's which are not just numbers, but also ordered.
04:36:00 <djanatyn> as much as I love Haskell, school starts in 20 minutes
04:36:10 <mekeor> :)
04:36:20 <djanatyn> gotta get to my computer science class. we're doing CISCO comptia A+ certification :P
04:36:45 <djanatyn> As a sophmore in highschool, I should probably be excited, but who cares how many devices a firewire port can support? :)
04:36:46 <Phyx-> a what?
04:36:49 <jaj> is there a reason why Control.Concurrent.Forkable is only defined for forkIO but not forkOS?
04:36:52 <Zao> djanatyn: Over nine thousand.
04:37:04 <roconnor> the only reason set is an important category is because the collection of arrows between two objects is a set?
04:37:31 <djanatyn> Anyway, I've got WinHugs and the Haskell platform installed on my Windows partition.
04:37:39 <djanatyn> That way I can learn more Haskell in my comp. sci class :D
04:37:39 <roconnor> ie. it's because categories are Set-enriched categories?
04:38:13 <Accidus> roconnor, No, I would say it's because almost all of mathematics is implemented with set theory
04:38:49 <roconnor> Accidus: I think that claim is disputable.
04:39:06 <Accidus> roconnor, Sure, lets argue about it
04:39:15 <merijn> Well, the set theory view of mathematics is one of the first taught ones
04:39:26 <lightstep> mathematics is implemented?
04:39:28 <Accidus> I'm not saying that it has to, or should be
04:39:35 <Axman6> well, it's not correct
04:39:36 <Accidus> All I'm saying is that, empirically, it is
04:39:37 <Axman6> zip (x:xs) (y:ys) = (x,y):zip xs ys; zip [] _ = []; zip _ [] = []
04:39:40 <Axman6> bleh, knew there was a shorter way -_-
04:39:51 <roconnor> Accidus: okay, Reverse mathmatics shows that almost all of mathematics can be done in Second-order arithmetic, in paritcuular Pi^1_1-CA.
04:40:08 <Accidus> That doesn't disagree with what I said.
04:40:19 * edwardk waits for the last 10% of the last video so he can get some sleep
04:40:57 <roconnor> Accidus: I guess the modivation of my question comes from the Yoneda lemma.
04:41:15 <roconnor> as in why is the Yoneda lemma about Set?
04:41:23 <Accidus> It isn't
04:41:28 <Nereid> there's a version of the yoneda lemma for enriched categories
04:41:29 <roconnor> :)
04:41:35 <Accidus> You have a yoneda lemma in every enriched category
04:41:41 <roconnor> horray
04:41:52 <Nereid> nothing special about Set
04:42:02 <Nereid> wrt the yoneda lemma
04:42:07 <roconnor> and so the usual Yonega lemma is an instance of the more general lemma on Set-enriched categories?
04:42:15 <roconnor> *Yoneda
04:42:15 <Nereid> sure
04:42:16 <Accidus> roconnor, it's one of the first things Mac Lane says about it
04:42:22 <roconnor> ah
04:42:26 <Nereid> anyway http://www.ncatlab.org/nlab/show/Set
04:42:35 <Accidus> The yoneda lemma for Set enriched categories is the yoneda lemma
04:42:37 <roconnor> That's great! ^_^
04:43:07 <Accidus> I guess.
04:43:09 <roconnor> Accidus: and what people call categoreis are Set encriched categories?
04:43:28 <Accidus> All locally small categories are set-enriched
04:43:35 <Accidus> Large categories are not set enriched
04:43:46 <Accidus> I mean, ones that are not locally small
04:44:19 <Nereid> insert something about universes here
04:44:30 <Accidus> <something about universes>
04:44:31 <roconnor> Nereid: isn't the claim that Set makes good foudnation ofr mathematics because it is locally small a bit circular?
04:44:43 <Accidus> Who said this?
04:44:48 <Nereid> Accidus: link
04:44:53 <Nereid> roconnor: well what do you want ;(
04:44:53 <roconnor> http://www.ncatlab.org/nlab/show/Set
04:45:12 <roconnor> maybe it isn't
04:45:55 <Nereid> that article is just giving a characterization of Set
04:46:09 <Phyx-> @index Int8
04:46:10 <lambdabot> Data.Int, Foreign
04:46:31 <roconnor> Nereid: it says "This category has many marvelous properties, which make it a common choice for serving as a ‘foundation’ of mathematics. For instance:"
04:46:48 <Accidus> I take it to be a bit tongue in cheek, and say the opposite:
04:47:04 <Accidus> categories that have these properties are equally suitable for a foundation of mathematics
04:47:24 <Nereid> of course, since there is only one such category (up to equivalence)
04:47:36 <Nereid> the article already notes
04:47:37 <Accidus> Only classically :P
04:47:38 <Nereid> "Note, however, that the definitions of “locally small” and “(co)complete” presuppose a notion of small and therefore a knowledge of what a set (as opposed to a proper class) is."
04:48:11 <Accidus> Nereid: even the notion of small and large can be axiomatised categorically (cf. algebraic set theory)
04:48:25 <roconnor> Nereid: ah, I missed that note.
04:48:50 <Nereid> further down: "In Lawvere’s theory ETCS, which can serve as a foundation for much of mathematics, Set is asserted to be a well-pointed topos that satisfies the axiom of choice and has a natural numbers object."
04:49:41 <Nereid> and then a note about "locally small"
04:49:45 <Nereid> but you can read
04:51:20 <Nereid> anyway it's almost 6am here so I better sleep
04:51:25 <roconnor> thanks
04:58:00 <mekeor> f :: a -> b -> c
04:58:00 <mekeor> f x y = z
04:58:00 <mekeor> i want to give this function only the second variable, y, and want to curry the first one. is this possible with haskell?
04:58:14 <roconnor> mekeor: es
04:58:17 <roconnor> yes
04:58:21 <mekeor> roconnor: how?
04:58:27 <roconnor> (flip f) is one way
04:58:36 <roconnor> (flip f foo)
04:58:37 <roconnor> or
04:58:46 <roconnor> (`f` foo) is another way
04:58:58 <hpc> \x -> f y x
04:59:00 <mekeor> thank you very much, roconnor. :)
05:01:56 <mekeor> why actually does `(+)` not work? :)
05:02:17 <opqdonut_> because the report disallows it
05:02:21 <opqdonut_> just like (`foo`)
05:02:37 <mekeor> "the report"??
05:02:47 <opqdonut_> the haskell report
05:02:59 <opqdonut_> the language standard
05:03:08 <opqdonut_> @where report
05:03:08 <lambdabot> http://www.haskell.org/onlinereport/
05:03:22 <mekeor> oO, oh, ok, thx
05:08:52 <Eduard_Munteanu> Has that been updated according to Haskell2010?
05:09:00 <hpc> Eduard_Munteanu: no
05:10:11 <opqdonut_> http://www.haskell.org/onlinereport/haskell2010/
05:10:30 <Eduard_Munteanu> Ah, I see.
05:10:47 <opqdonut_> @where+ haskell2010 http://www.haskell.org/onlinereport/haskell2010/
05:10:47 <lambdabot> Good to know.
05:10:51 <opqdonut_> @where+ report2010 http://www.haskell.org/onlinereport/haskell2010/
05:10:51 <lambdabot> Done.
05:15:00 <mekeor> does a chart of all type-classes exist in the web?
05:15:00 <mekeor> it should show which type-class is the subset of which other type-class…
05:17:22 <mekeor> wow! i just found such a chart!
05:17:22 <mekeor> here: http://www.haskell.org/onlinereport/classes.gif
05:17:24 <wjt> mekeor: the Typeclassopedia is a good guide to many standard typeclasses http://www.haskell.org/haskellwiki/Typeclassopedia
05:17:50 <mekeor> oh, thanks wjt; i didnt know about the Typeclassopedia…
05:19:59 <mekeor> @where+ typeclasschart http://www.haskell.org/onlinereport/classes.gif
05:19:59 <lambdabot> Okay.
05:20:07 <mekeor> @where typeclasschart
05:20:07 <lambdabot> http://www.haskell.org/onlinereport/classes.gif
05:20:09 <mekeor> cool
05:23:01 <Eduard_Munteanu> BTW, how would one query lambdabot for all stuff stored in 'where'?
05:23:35 <Eduard_Munteanu> @where
05:23:35 <lambdabot>  @where <key>, return element associated with key
05:23:41 <Eduard_Munteanu> @where *
05:23:41 <lambdabot> I know nothing about *.
05:24:02 <Eduard_Munteanu> @help
05:24:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:24:15 <Eduard_Munteanu> @list
05:24:15 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:36:40 * hackagebot authenticate 0.9.0.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.0.1 (MichaelSnoyman)
05:36:42 * hackagebot http-enumerator 0.6.3 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.3 (MichaelSnoyman)
05:43:34 <keep_learning> hello all
05:43:37 <keep_learning> http://hpaste.org/paste/46277/treap_annotation#p46278
05:43:53 <keep_learning> i am trying to print the treap inside main function
05:44:01 <keep_learning> but i am getting error
05:44:31 <keep_learning> kindly some one please tell me
05:44:41 <keep_learning> what is wrong with this code
05:45:29 <crystal-cola> keep_learning: you have treap = foldr inserT NIL list
05:45:37 <crystal-cola> then you write mapM printt treap
05:46:00 <crystal-cola> treap is a Treap so it does not make sense to use mapM
05:46:09 <crystal-cola> you should just printt treap
05:46:10 <keep_learning> crystal-cola: first i created the treap using foldr function
05:46:50 <keep_learning> crystal-cola: thank you
05:46:57 <keep_learning> crystal-cola: now i got it
06:48:24 <mbryant> Hey guys I am having a hard time solving a problem, well I have the problem solved I am just having a hard time converting it to haskell, anyone care to help?
06:48:38 <ezyang> Don't ask to ask!
06:48:46 <crystal-cola> what is the problem?
06:49:00 <crystal-cola> mbryant:
06:50:03 <mbryant> okay, so here is the issue, I take in three values, here are my types, type Song = (String,Int,Double)
06:50:03 <mbryant> type InstanceType = (Int, [Song])
06:50:03 <mbryant> type ResultType = String
06:50:43 <mbryant> I need to take the int and the double from the song, and multiply them together, and then sort the list based on that result
06:51:05 <crystal-cola> so what you need to define is a comparison function
06:51:11 <merijn> :t sortBy
06:51:12 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
06:51:14 <crystal-cola> compare :: Song -> Song -> Ord
06:51:16 <crystal-cola> ering
06:53:44 <foobarrior> good time
06:54:10 <mbryant> okay, forgive me but I a little lost, here.. inside the compare that is where I calculate and it will sort it automatically?
06:55:03 <merijn> mbryant: There is a sortBy function which takes as arguments a comparison function and a list and then sorts the list based on the comparison function. So you will need to implement that comparison function
06:55:22 <foobarrior> i was just building ghc and running tests and got lots of assembly errors like      Error: .size expression for Main_main6_entry does not evaluate to a constant
06:55:28 <merijn> The type of the comparison functions is "a -> a -> Ordering" (or in your case "Song -> Song -> Ordering")
06:55:55 <mbryant> got it, thanks, if I run into any issues, I will poke you guys again, I apprecciate it
06:56:19 <merijn> mbryant: The type "Ordering" has three values, LT, EQ, GT
06:56:23 <foobarrior> is it ok?
06:56:47 <merijn> mbryant: So you just do the multiplication in your function and return the appropriate one of those three
06:58:17 <mbryant> merijn: okay, mind screw here..  what am I comapring it to, by reutnring one of the three, if I only have knowledge of one item of the list?
06:58:51 <merijn> mbryant: The comparison function takes two elements (i.e. two Songs)
06:59:24 <merijn> So you compare the first with the second
06:59:24 <mbryant> ah, I see, I got it
06:59:26 <roconnor> why is there a butterfly on the reddit haskell logo today?
06:59:41 <mbryant> impretive languages have screwed me over it seems lol
07:00:07 <edwardk> roconnor: in honor of silk
07:00:23 <merijn> mbryant: It'll all make sense once your brain has been melted and replaced by a martian supercomputer :)
07:05:38 <foobarrior> is it to be successful to build ghc 7.03 with ghc 6.12.3?
07:06:28 <byorgey> foobarrior: if it is not, it is a bug
07:06:49 <foobarrior> i'm afraid i failed
07:07:36 <foobarrior> test cases are halting with assembly errors
07:08:50 <Saizan> which OS are you on?
07:08:57 <foobarrior> Natty
07:09:30 <foobarrior> i've installed all build-deps for ghc6
07:11:26 <Phyx-> Natty?
07:11:38 <foobarrior> Ubuntu 11.04
07:16:41 <foobarrior> it is very sad, i have such errors on each second test on average
07:19:24 <Saizan> sounds like it's a problem with new binutils
07:19:36 <Saizan> https://bugs.archlinux.org/task/23907
07:23:27 <foobarrior> my binutils are a bit older=) 2.21.0
07:27:09 <foobarrior> but i was only trying make && make install, none of smth like cabal install wasn't using
07:28:02 <foobarrior> just looking throught your link...
07:28:03 <int-e> yeah, but it's indeed not a binutils bug. a workaround is to get rid of the uses of -fvia-C in utf8-light.
07:28:20 <int-e> (at least for the problem Saizan linked to)
07:31:22 <int-e> (there are two, one in the .cabal file and one pragma in the module itself.)
07:33:27 <frerich> Is there an existing function for taking a sub list of some list given a start and an end index? I.e. subList 3 7 [1..10] should yield [4,5,6,7]; I wrote a function myself (see http://hpaste.org/46284/sublist) but I think it's a bit clumsy, there must be a nicer way for this.
07:34:00 <frerich> I'm using this function to strip the first 19 and the last 12 lines of some program output (which I have as a [String])
07:34:10 <merijn> Hoogle to the rescue
07:34:11 <merijn> @hoogle Int -> Int -> [a] -> [a]
07:34:12 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
07:34:12 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:34:12 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
07:34:15 <mauke> I'd use take/drop
07:34:20 <mauke> without the checks
07:34:23 <ben> I suspect you'd try to avoid the length call to not force the entire list
07:34:44 <sipa> > let list = [1..10] in map (list !!) [3..7]
07:34:45 <lambdabot>   [4,5,6,7,8]
07:34:57 <merijn> sipa: ...
07:34:57 <ben> That seems O(ohgod)
07:35:01 <merijn> That's awful >.>
07:35:09 <merijn> ben: O(god), you mean?
07:35:09 <sipa> it's O(n^2) yes
07:36:55 <Axman6> > let subList a b = take (b-a) . drop a in subList 3 7 [1..10]
07:36:57 <lambdabot>   [4,5,6,7]
07:38:00 <frerich> Hm ok, thanks. So at least there are worse solutions than mine. :-}
07:38:19 <Axman6> that version will work for all inputs too
07:38:47 <merijn> I would say there is no "worst" solution, because it can always be made worse :p
07:39:18 <merijn> So, by definition there is always a worse solution around. (That suddenly cheers me up about my C code...)
07:39:41 <sipa> @let diffList l@(a:b) = (a,zipWith (-) l b)
07:39:42 <lambdabot>  Defined.
07:39:48 <sipa> > diffList [1,2,3]
07:39:49 <lambdabot>   (1,[-1,-1])
07:39:57 <sipa> @let diffList2 l@(a:b) = (a,zipWith (-) b l)
07:39:58 <lambdabot>  Defined.
07:40:02 <sipa> > diffList2 [1,2,3]
07:40:03 <lambdabot>   (1,[1,1])
07:40:40 <Axman6> > diffList2 [x*2 | x <- [1..10]]
07:40:41 <lambdabot>   (2,[2,2,2,2,2,2,2,2,2])
07:40:51 <Axman6> > diffList2 [x*x | x <- [1..10]]
07:40:52 <lambdabot>   (1,[3,5,7,9,11,13,15,17,19])
07:41:11 <Axman6> > diffList2 [x*x*x | x <- [1..10]]
07:41:13 <lambdabot>   (1,[7,19,37,61,91,127,169,217,271])
07:41:56 <Axman6> > iterate (diffList2 . snd) (0,[x*x*x | x <- [1..10]])
07:41:58 <lambdabot>   [(0,[1,8,27,64,125,216,343,512,729,1000]),(1,[7,19,37,61,91,127,169,217,271...
07:42:19 <Axman6> > map snd $ iterate (diffList2 . snd) (0,[x*x*x | x <- [1..10]])
07:42:21 <lambdabot>   [[1,8,27,64,125,216,343,512,729,1000],[7,19,37,61,91,127,169,217,271],[12,1...
07:42:28 <Axman6> > map snd $ iterate (diffList2 . snd) (0,[x*x*x | x <- [1..5]])
07:42:30 <lambdabot>   [[1,8,27,64,125],[7,19,37,61],[12,18,24],[6,6],[0],[],*Exception: <local>:3...
07:42:45 <Axman6> oops
07:43:11 * Phyx- wonders why those SpecConstr messages are being shown at the default verbosity level.
08:18:26 <aristid> > uncurry (foldr (+)) (2,[2,2,2,2,2,2,2,2,2])
08:18:27 <lambdabot>   20
08:18:42 <aristid> > uncurry (scanl (+)) (2,[2,2,2,2,2,2,2,2,2])
08:18:43 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
08:19:19 <aristid> >scanl1 (+) [2,2,2,2,2,2,2,2,2,2]
08:19:22 <aristid> > scanl1 (+) [2,2,2,2,2,2,2,2,2,2]
08:19:23 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
08:27:13 <Tordek> wondering if there's any function that'd do this... Take a list like [[1],[2,3],[4]], and generate [[1,2,4],[1,3,4]]. ie (regexp syntax) "all strings matching [1][23][4]"
08:27:43 <mauke> > sequence [[1],[2,3],[4]]
08:27:44 <lambdabot>   [[1,2,4],[1,3,4]]
08:27:50 <mauke> magic!
08:27:53 <Tordek> haha
08:28:01 <Tordek> thanks
08:47:08 * hackagebot timecalc 0.1 -   http://hackage.haskell.org/package/timecalc-0.1 (ChrisEidhof)
08:49:09 * hackagebot timecalc 0.1.1 -   http://hackage.haskell.org/package/timecalc-0.1.1 (ChrisEidhof)
08:49:11 * hackagebot dropsolve 0.1 - A command line tool for resolving dropbox conflicts.  http://hackage.haskell.org/package/dropsolve-0.1 (DanielTrstenjak)
08:52:09 * hackagebot haskelldb 2.1.1 - A library of combinators for generating and executing SQL statements.  http://hackage.haskell.org/package/haskelldb-2.1.1 (JustinBailey)
09:24:08 <vicvicvic>  
09:24:48 <vicvicvic> whoops.. I wrote this function to get the subdirectories of a folder, but I have a feeling it could be more beautiful: http://hpaste.org/46287/get_subdirectories_of_filepath any ideas?
09:30:41 <parcs> @type getDirectoryContents >=> filterM f
09:30:41 <lambdabot> Not in scope: `getDirectoryContents'
09:30:50 <parcs> @type (>=>)
09:30:51 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:31:06 <wafflesburger> (m :: * -> *)
09:31:07 <wafflesburger> lol
09:31:19 <wafflesburger> looks like a ginger kid that just saw something awesome
09:31:27 <ciphergoth> hmm, so hPutStr appears to utf-8 encode its output by default
09:31:32 <ciphergoth> how do you output raw bytes?
09:36:26 <vicvicvic> parcs: well, that's to get it pointfree? but I need dir in the filter to do the doesDirectoryExist test anyway
09:37:07 <c_wraith> ciphergoth: you the ciphergoth who helped out with the first version of the openid spec?
09:37:32 <c_wraith> ciphergoth: it should use the system encoding, actually.
09:38:37 <c_wraith> ciphergoth: if you don't want it to use the system encoding, you're best off encoding the strings to the format you want manually, then using using bytestring IO
09:39:11 <ceii__> isn't there a hSetEncoding or something in the new base lib?
09:39:24 <ceii__> @hoogle hSetEncoding
09:39:24 <lambdabot> No results found
09:39:52 <c_wraith> ceii__: there is, but I don't think it works with stdout.  Oh, that was hPutStr.  In that case, it's an option too
09:40:40 <c_wraith> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetEncoding
09:40:40 <jssanders> Anyone have know how to get emacs keys (at least the basic ones) working in Leksah??
09:49:38 <viorel> hi everybody
09:50:49 <viorel> I'm a complete newbie
09:51:16 <viorel> if anybody has 2 minutes to spare, can you give me a quick intro on the "code of conduct" over here?
09:51:41 <luite> don't be too annoying, that's about it :)
09:52:13 <viorel> I don't plan to be annoying, it's only that I haven't used irc in about 10 years
09:52:50 <hpc> viorel: more or less what luite said; off-topic stuff goes in #haskell-blah, but that convention is rarely followed :P
09:53:26 <luite> viorel: if you want to show some haskell code you have questions about, and it's more than one or two lines, use http://hpaste.org
09:53:58 <jmcarthur> viorel: basically, don't be a troll, stay on topic, don't flood the channel
09:54:28 <viorel> thanks guys
09:54:39 <jmcarthur> viorel: if you want to go off topic, we have #haskell-blah. also, even as a newb, don't be afraid to answer questions if you think you know the answer
09:54:53 <jmcarthur> viorel: if you get it wrong, somebody else can clean up, and that means two people can learn instead of just one :)
09:55:26 <viorel> exactly because I don't want to flood the channel, can I ask one of you in private about how to behave on this channel?
09:55:44 <jmcarthur> if you misbehave you will be told
09:55:52 <jmcarthur> the ops here are very lenient
09:56:10 <luite> but it's pretty difficult to misbehave here without knowing
09:56:14 <jmcarthur> yeah
09:56:19 <viorel> ok, then I'll start
09:56:30 <jmcarthur> basically, just observe how most people are acting and follow suit :)
09:56:38 <viorel> I'm completely new to Haskell, but it looks like it's a very cool language
09:56:59 <viorel> so I started to read (and work through) the book/blog "Learn You a Haskell"
09:57:09 <jmcarthur> a good choice
09:57:12 <viorel> for the moment I don't have any questions
09:57:23 <viorel> just wanted to make an initial contact with the haskell group
09:57:45 <jmcarthur> viorel: we're a helpful bunch here. don't be afraid to ask anything
09:57:59 <HaudRex> viorel: When you have questions, people here are more than happy to help.
09:58:08 <viorel> actually I do have a question, nothing urgent
09:58:16 <HaudRex> nothing here is urgent
09:58:17 <viorel> I saw that there is an IDE called Leksah
09:58:22 <jmcarthur> even "stupid" questions. sometimes even what might sound very dumb in other channels can lead to some very thoughtful, insightful answers here
09:58:53 <viorel> I installed it on a windows machine, it looks like the install has been successful
09:59:11 <viorel> but it doesn't look similar to Visual Studio, or Eclipse
09:59:45 <parcs> did you install the haskell platform?
09:59:56 <jmcarthur> i believe there are also plugins for VS and eclipse if you are much more comfortable with those
10:00:03 <jmcarthur> vim and emacs are probably the most common editors here
10:00:06 <HaudRex> an IDE will probably get in your way while you're just learning
10:00:07 <viorel> ah, that's great
10:00:19 <viorel> yes, for the moment I use only a text editor
10:00:24 <MasseR> HaudRex: I'm gonna quote that :)
10:00:45 <jmcarthur> that's what i would recommend. just a text editor, or maybe an operating system if you use emacs
10:00:52 <MasseR> Our programming teacher spent more time on solving eclipse hickups than teaching
10:01:10 <HaudRex> MasseR: That's a totally predictable result.
10:01:12 <luite> viorel: it's best if you configure yours to use spaces for indenting and not tabs
10:01:26 <viorel> thanks luite
10:01:31 <jmcarthur> seconded
10:01:41 <jmcarthur> haskell is hard to get right with tabs
10:02:49 <viorel> I use an editor called jedit, and so far everything works fine; I didn't tweak anything, so I suppose it automatically converts tabs into spaces
10:03:18 <tg_> are there any opinions on the most capable way of writing GPU-accelerated things for web browsers?
10:03:25 <tg_> I think there are several different frameworks...
10:04:50 <wafflesburger> mm jedit is so heavy
10:05:10 <wafflesburger> if you're on windows try e-texteditor :D #1 programming editor evah
10:05:20 <wafflesburger> http://www.e-texteditor.com/
10:05:30 <viorel> great, thanks
10:14:46 <crystal-cola> @where Integer
10:14:47 <lambdabot> I know nothing about integer.
10:14:55 <crystal-cola> where to get Integer?
10:15:24 <tg_> crystal-cola: well, first, you have to define the number 0 and a successor function...
10:15:36 <tg_> @where Int
10:15:37 <lambdabot> I know nothing about int.
10:15:42 <tg_> :t Int
10:15:43 <lambdabot> Not in scope: data constructor `Int'
10:18:00 <ciphergoth> c_wraith: yes, I worked on the early versions of OpenID, and got it wrong :-)
10:19:11 <c_wraith> ciphergoth: I was one of the early contributors there too.  I mostly found corner cases the spec just didn't handle that left things in a broken state
10:21:21 <fryguybob> crystal-cola: Are you looking for the GHC source for Integer or something else?
10:21:39 <crystal-cola> Haskell 9000
10:21:48 <crystal-cola> I am using Prelude now though
10:22:05 <crystal-cola> import Prelude (Integer)
10:22:19 <longh> hi, I have some problems with Haskells FFI, can someone point out the issues in code or did I hit a ghc bug? You can find the code here: http://dl.dropbox.com/u/22703994/ffi_and_iterators.tar.gz
10:22:23 * hackagebot ginsu 0.8.0.1 - Ginsu Gale Client  http://hackage.haskell.org/package/ginsu-0.8.0.1 (DylanSimon)
10:25:33 <longh> the tarball contains a small "library" (which consists of functions working on iterators) used by a haskell program and a c++ program. the C++ program prints the contents of a vector iterated over, but the equivalent (?) Haskell program does not
10:34:14 <tswett> Time to see if I can figure out Haskell's FFI.
10:36:07 <c_wraith> tswett: it's not bad at all.  Just remember one rule:  use safe foreign calls rather than unsafe.  (you can change this later, if you're an expert)
10:36:39 <tswett> I guess the first thing I must do is figure out how to link the C code.  Apparently, the header file is lua.h, and I'm guessing there's a liblua or something somewhere.
10:36:58 <longh> c_wraith: what is the difference between safe and unsafe calls? is there a complete list of modifiers somewhere?
10:37:20 <c_wraith> longh: I don't know that I've seen a single complete list of the differences anywhere.  it's pretty extensive
10:38:25 <c_wraith> longh: the short version is "unsafe calls skip basically every protective measure safe calls take.  Unless you know all the details of this *and* have a good reason to go to unsafe, use safe"
10:38:30 * tswett RTFMs.
10:38:59 <djahandarie> This Spivak talk is great
10:38:59 <lambdabot> djahandarie: You have 1 new message. '/msg lambdabot @messages' to read it.
10:39:01 <longh> c_wraith: okay, thanks, maybe this helps ^^
10:41:28 <longh> tswett: have you  added "-llua" to the gcc flags?
10:41:36 <longh> i mean ghc
10:41:48 <tswett> longh: nope.  Can I do that as a pragma?
10:41:57 <tswett> And will that both import the header and link the library?
10:42:08 <c_wraith> no, that's just for the library
10:42:35 <longh> tswett, I don't know about this too much
10:42:37 <tswett> So I also need to import the header, which is what this IMPORT pragma does?
10:43:05 <c_wraith> probably.  I've only done FFI stuff with hsc2hs, though, which has a slightly different interface
10:43:44 * tswett nods.
10:46:04 <longh> *added 'safe' all over the place... not that it made a difference :D*
10:46:49 <tswett> What happens if I specify neither safe nor unsafe?
10:46:56 <longh> the same
10:47:01 <longh> that's what I did before
10:47:14 <tswett> It's the same as safe, you mean?
10:47:28 <tswett> "Warning: -#include and INCLUDE pragmas are deprecated: They no longer have any effect".  Okay, I guess I'm not doing that.  :P
10:48:26 <longh> tswett: no idea, what's your goal anyway?
10:49:00 <longh> I am currently writing bindings to xapian in my spare time for example
10:49:17 <longh> and cabal/ghc don't help me in that regard ^^
10:49:29 <tswett> longh: my goal is to write a binding to Lua.
10:49:44 <tswett> That's already been done, of course, but I want to get the practice.
10:51:15 <longh> ah ok, do you blog about that? maybe I can learn some things as well :P
10:51:31 <tswett> I haven't done any blogging in a while.  Unless Twitter counts.  :P
10:51:42 <smop> can i run lambdabot on windows?
10:52:37 <longh> tswett: my internet is pretty slow atm, for me it's pretty fortunate to have twitter these days ^^
10:54:25 <nihtml> :t (>=>)
10:54:25 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:54:56 <sully> fish
10:55:06 <nihtml> miam
10:55:48 <tswett> "Unacceptable result type in foreign declaration: IO LuaState".  The function I'm trying to bind returns a lua_State*.  I *think* I want LuaState to represent a lua_State*, here.
10:56:14 <longh> tswett, IO (Ptr LuaState)
10:56:51 <tswett> Yeah, that probably makes sense.
10:57:56 <c_wraith> Yeah, that's what you need.
10:58:25 <tswett> I think I'm going to make LuaStateContents the empty data declaration here, and then make LuaState a newtype for Ptr LuaStateContents.
10:58:32 <longh> Anyone thinks this is a GHC bug: http://dl.dropbox.com/u/22703994/ffi_and_iterators.tar.gz ? <-- the two programs should yield the same result (except for the output representation)
10:59:20 * longh wants to avoid spamming the GHC bug tracker ^^
11:00:22 <tswett> And now I want to define a finalizer for LuaState.  Or maybe LuaStateContents.  :P
11:00:52 <tswett> Nah, for LuaState.  When a LuaState l is garbage collected, we need to call lua_close on l.
11:01:17 <c_wraith> if you need a finalizer, wrap the Ptr in a ForeignPtr
11:01:28 <c_wraith> That's the entire purpose of ForeignPtr
11:01:33 <longh> foreign import a FunPtr, it has to be prefixed with an ampersand
11:01:48 <ciphergoth> it's so amazing that you can take the same parser library and throw it at ByteStrings instead of Strings!
11:02:03 <tswett> longh: I don't think I want a pointer to a function here.
11:02:19 <c_wraith> ciphergoth: the fun of ad-hoc polymorphism (when someone's already done the work for you)
11:02:24 <tswett> @docs foreign
11:02:24 <lambdabot> foreign not available
11:02:29 <tswett> @docs Foreign
11:02:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign.html
11:02:56 <longh> type FinalizerPtr a  = FunPtr(...)
11:03:43 <tswett> Also, I'm getting the error "luaapi.o: unknown symbol `_luaL_newstate'".  Does that mean the header file's not being imported?
11:05:09 <c_wraith> that's probably a linker error, meaning the lib isn't being linked in
11:05:26 <tswett> So "{-# OPTIONS_GHC -llua #-}" isn't doing what I thought it would do.
11:05:38 <longh> you probably have to add the -llua flag
11:05:51 <tswett> Doesn't the pragma effectively do that?
11:06:00 <ciphergoth> am trying to parse atoms of the form 9:charcount
11:06:03 * tswett tries giving that flag to ghci.
11:07:15 <tswett> I guess the pragma doesn't do that after all.  Now GHCi's saying it couldn't find liblua.dylib.  I couldn't find that either, so I guess I'll search for it.
11:07:18 <ciphergoth> so I need to feed the result of one parse into the later one
11:09:10 <c_wraith> ciphergoth, sure, that's easy.  one of the ways monadic combinator libraries are nice for parsing.
11:09:29 * tswett does a find / | wc -l, and finds that he has a lot of files.
11:12:53 <tswett> Found it!  /opt/local/lib/liblua.dylib and /opt/local/include/lua.h.
11:12:57 <c_wraith> ciphergoth: I don't follow exactly the syntax you're using to describe the value, though.  Still, a simple example would look something like do { count <- parseCount ; chars <- replicateM count parseChar }
11:13:05 <tswett> OS X is so consistent with other Unices, isn't it.
11:13:27 <longh> you run find/ | wc -l before find / | grep foo ?
11:14:04 <tswett> Now I guess I need to specify /opt/local/lib as a search directory for GHCi, I guess.
11:14:22 <pastorn> @pl (f >>= \n -> replicateM n g)
11:14:23 <lambdabot> flip replicateM g =<< f
11:14:27 <tswett> longh: of course.  The first step in solving any problem is setting an upper bound on the amount of time it takes to solve the problem, even if that means doing something that takes longer than the problem itself.  :P
11:14:32 * hackagebot mysql-simple 0.2.0.2 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.0.2 (BryanOSullivan)
11:15:13 <longh> tswett: we could assume our filesystem is full of 0-byte files
11:15:28 <hpc> saw the announcement for mysql-simple on -cafe
11:15:34 <hpc> it is intriguing
11:15:53 <tswett> Ah, then we can just divide our hard disk capacity by the maximum possible number of files.
11:16:07 <tswett> Anyway, I'm getting a "wrong architecture" error.  Bleh.
11:16:20 <parcs> i'm waiting for a postgesql-simple
11:16:22 <Jafet> What's wrong with locate?
11:16:37 <Jafet> (You need to predict off-peak hours to run the updater)
11:17:05 <tswett> I guess /opt/local/lib/liblua.dylib is a 64-bit file and GHCi can't link those today for some reason.  This is a 64-bit platform; I wonder what's wrong.
11:17:23 <tswett> Can I tell GHCi what platform to target when compiling?
11:17:36 <hpc> ghci?
11:17:47 <tswett> Yep.
11:17:52 <tswett> Let me just pastebin my whole situation.
11:17:56 <c_wraith> ghc does generate 64-bit code on os x, as far as I know
11:18:04 <c_wraith> best to install the universal lib of lua
11:18:19 <c_wraith> *doesn't
11:18:36 <sully> I am curious
11:18:41 <sully> when people use @pl
11:18:54 <sully> do they then actually go and use the result expression in their programs?
11:19:03 <Botje> if it's not too silly.
11:19:05 <monochrom> depends
11:19:10 <c_wraith> occasionally.  Maybe rarely
11:19:13 <Botje> @pl \x -> length x < 5
11:19:13 <lambdabot> (< 5) . length
11:19:15 <Botje> for example
11:19:26 <c_wraith> I do it mostly out of curiosity.  sometimes the result looks nice, and I use it
11:19:35 <c_wraith> sometimes it's not nice, and I just back away
11:20:10 <longh> @pl \x -> length x < 3
11:20:11 <lambdabot> (< 3) . length
11:20:12 <hpc> i use it to save time
11:20:12 <tswett> @pl \e t a o i n s h r d l u -> (n o t (t h i s), t h i s (i s) (s i l l i))
11:20:15 <lambdabot> const (const . ((((((const . const . (const .)) .) .) .) .) .) . ap (flip . ((ap . ((flip . (ap .)) .)) .) . ((((ap .) .) .) .) . ((((((.) .) .) .) .) .) . ((((((,) .) .) .) .) .) . ap (flip . ((.) .
11:20:15 <lambdabot> ) . (flip .) . (((.) .) .) . (((.) .) .) . flip (flip . flip id)) ((flip .) . flip)) (flip ap (join (flip . (flip .) . flip flip id . (ap .) . flip id)) . (ap .) . ((flip .) .) . ((((.) .) .) .) .
11:20:15 <lambdabot> join . (ap .) . ((flip .) .) . (flip .) . flip))
11:20:15 <lambdabot> optimization suspended, use @pl-resume to continue.
11:20:26 <hpc> if i have something i want to shorten and am too lazy to work it out myself
11:20:33 <hpc> or for curiosity like c_wraith
11:24:03 * sully doesn't really understand the haskeller obsession with pointless style
11:24:44 <Jafet> We use it to proselytize to the perl hackers.
11:25:26 <parcs> > liftM2 (>=>) (const [1..10]) (fmap filterM) even
11:25:27 <lambdabot>   Couldn't match expected type `a -> m b'
11:25:27 <lambdabot>         against inferred type `[a1]'
11:26:06 <Twey> sully: It's the precursor to combinators and higher-order types like Monads and Arrows.
11:26:17 <Twey> And Applicative.
11:27:01 <Kerris> *brain melts*
11:27:35 <tswett> If you thought monads were tough, just wait until you've seen dryads.
11:28:05 <Twey> Haha
11:28:36 <ciphergoth> hmm, that's weird, if what I'm getting here is bytes, how come I can do matches like "digit" against them?
11:29:23 <Twey> class Dryad m a b where flup :: m a b -> (a -> m b c) -> m b c
11:29:55 <Twey> ciphergoth: Because ‘digit’ is polymorphic?
11:30:10 <ciphergoth> digit :: Stream s m Char => ParsecT s u m Char
11:30:23 <tswett> Twey: perfect!  But you also have to say that it satisfies the obvious rules, of course.
11:30:33 <c_wraith> yes, it results in a Char, but it parses whatever the stream type is.
11:30:40 <ciphergoth> ah!
11:30:44 <ciphergoth> wild!
11:31:09 <tswett> What the obvious rules are, I have no idea.
11:31:39 <ciphergoth> hmm, so what's the equivalent of anyChar that matches a single stream token and doesn't change it?
11:31:47 <Twey> tswett: Obviously.
11:32:47 <c_wraith> ciphergoth: I'm not sure that's possible, given the definition of the Stream class
11:33:29 <ciphergoth> c_wraith: ah OK.
11:33:42 <ciphergoth> how should I consume the next N bytes no matter what they are?
11:34:28 <ciphergoth> maybe I should be looking at the sources for these things!
11:34:43 <c_wraith> I'm not sure.  I haven't looked at parsec 3 closely.  There must be a way to get a token out of the Stream interface
11:34:59 <c_wraith> But I don't know what it is
11:35:00 <tswett> Now I guess I need to make a makefile.  Are makefiles read by GHC --make?
11:35:11 <monochrom> no
11:35:30 <tswett> So I just use `make` like I would with a C program?
11:35:40 <c_wraith> You'd be better off using cabal
11:35:49 <c_wraith> it handles building FFI code just fine
11:35:53 <tswett> That sounds like a good idea.
11:37:27 <tswett> How do I cabal?  :P
11:37:44 <c_wraith> do you have cabal-install installed?
11:37:52 <c_wraith> (yes, the question reads really dumbly)
11:38:24 <tswett> No.
11:38:38 <crystal-cola> I've haskell code
11:38:40 <crystal-cola> What now??
11:38:43 <crystal-cola> hwo should I preserve it
11:39:12 <Jafet> In a mosquito, encased in resin
11:39:24 <tswett> Installing Cabal packages on a fresh system can be so fun.
11:39:38 <c_wraith> tswett: how did you install ghc on that system?
11:39:51 <tswett> c_wraith: using the Haskell Platform package, I think.
11:39:57 <parcs> how can a function a -> b be written with unsafePerformIO ?
11:40:01 <c_wraith> that should come with cabal-install
11:40:20 <c_wraith> parcs: using a value of type IORef a at the top level
11:40:50 <tswett> First, I install OS X; then I install Xcode; then I install MacPorts; then I use it to install the Cabal, then I use that to install all the Haskell stuff.  Aye?  :)
11:41:05 <tswett> c_wraith: well, I don't have cabal-install for whatever reason, but I'm pretty sure I'm installing it now.
11:41:17 <tswett> For now, instead of a makefile, I'm doing this:
11:41:19 <tswett> echo 'ghci -L/opt/local/lib -llua luaapi.hs' > Fakefile
11:42:19 <longh> tswett, as you are working with FFI atm, can you try (if there is a c++ compiler on your system): http://dl.dropbox.com/u/22703994/ffi_and_iterators.tar.gz, I don't whom to ask about my problem, and at least I want to verify that it is indeed reproducible on other systems
11:42:44 <Eduard_Munteanu> Hmm, this looks interesting: http://formalmethods.wikia.com/wiki/Formal_Methods_Wiki
11:44:15 <NihilistDandy> Any regular yi users around?
11:44:28 <Eduard_Munteanu> Do you guys know about B-Method or Z Notation? I'm interested how they compare to stuff like Agda or Coq.
11:46:20 <tswett> longh: I see that I'm getting a bunch of undefined symbol errors.
11:46:39 <ciphergoth> huh, it's still a "Char" token type even with ByteString, weird
11:46:40 <longh> huh? ^^
11:47:02 <longh> tswett, can you hpaste that?
11:47:39 <tswett> longh: http://pastebin.com/v4mieuAj
11:48:51 <maurer_> I remember there being a good reason for this, but cannot remember precisely what it was--why do we only have an evaluate that goes to weak head normal form, and not one that goes to normal form ala deepseq
11:48:56 <maurer_> *?
11:51:33 <Saizan> you can compose evaluate with deepseq to get it
11:52:05 <maurer_> Saizan: Yes, but it seems like
11:52:08 <tswett> maurer_: perhaps because it would be ill-defined, or violate some rule, when interacting with functions and IO and the like.
11:52:11 <tswett> Just a guess.
11:52:13 <maurer_> 1) Deriving deepseq is nontrivial
11:52:29 <maurer_> 2) The evaluator has access to all the data to do this already as a primitive
11:52:43 <maurer_> tswett: Yes, but which one of those, and an example would be nice :)
11:53:07 <maurer_> I remember being extremely convinced of why deepseq was its own thing previously, but I can't remember what convinced me :(
11:53:54 <tswett> Well, what should deepSeq'ing (const undefined :: Void -> Void) do, if Void is an empty type?
11:54:12 <tswett> Or something like (return undefined :: IO Integer)?
11:54:23 <tswett> I don't know if those would actually be a problem at all, though.
11:54:28 <maurer_> tswett: Either of those does nothing, they're already in NF
11:54:38 * tswett nods.
11:55:33 <maurer_> In fact, this seems an argument as to why the runtime machinery should do this for us--writing a deepSeq instance for "a -> b" is not possible, but flattening down to a function is frequently reasonable
11:55:54 <roconnor> @hoogle deepSeq
11:55:55 <lambdabot> No results found
11:55:56 <longh> tswett: maybe one has to use g++, don't know if c++ points to a compiler incompatible with what ghc uses, thanks for the help anyway
11:55:57 <roconnor> @hoogle deepseq
11:55:57 <lambdabot> No results found
11:56:11 <maurer_> Although, I suppose that whnf = nf for a -> b, so we're fine there
11:56:14 <roconnor> Doesn't deepseq have a class constraint that Void -> Void doesn't satify?
11:57:15 <maurer_> roconnor: Nope, "NFData" has no constraints, and the only method is a -> (), which is supposed to be some way of forcing a all the way down
11:57:24 <crystal-cola> how do display a table of numbers [[a]] as a grid??
11:57:39 <roconnor> ya, but Void -> Void isn't an instance of NFData
11:57:52 <maurer_> roconnor: No reason it couldn't be.
11:57:56 <tswett> crystal-cola: I don't know if there's a function for doing that.  You may have to write it yourself.
11:58:04 <crystal-cola> ughhh
11:58:07 <tswett> But I don't know the Haskell libraries as well as some people.
11:58:11 <crystal-cola> i have tow rite everything
11:58:20 <maurer_> roconnor: Its whnf is its nf, and its whnf is accessible via seq
11:58:34 <roconnor> I guess anything with a finite (compact?) domian and an NFData codomain could be made NFData.
11:59:00 <maurer_> crystal-cola: unlines $ map (unwords . (map show)) [[1,2,3], [4, 5, 6]]
11:59:07 <maurer_> > unlines $ map (unwords . (map show)) [[1,2,3], [4, 5, 6]]
11:59:09 <lambdabot>   "1 2 3\n4 5 6\n"
11:59:12 <maurer_> Have fun.
11:59:16 <roconnor> maurer_: why do you say that whnf is it's nf?
11:59:27 <crystal-cola> > unlines $ map (unwords . (map show)) [[1,2,3], [4, 5, 6]]
11:59:29 <lambdabot>   "1 2 3\n4 5 6\n"
11:59:30 <crystal-cola> > unlines $ map (unwords . (map show)) [[1,2,3], [4, 56545, 6]]
11:59:32 <lambdabot>   "1 2 3\n4 56545 6\n"
11:59:32 <crystal-cola> its not good ^
12:00:22 <maurer_> roconnor: Once you've got that it's a function from its data representation, you've collapsed it as far as you can without evaluating, now?
12:00:57 <maurer_> > unlines $ map ((intercalate "\t") . (map show)) [[1,2,3], [4, 56545, 6]]
12:00:59 <lambdabot>   "1\t2\t3\n4\t56545\t6\n"
12:01:12 <monochrom> is (\x -> (\y -> y) x) in whnf? in hnf? in nf?
12:01:50 <balor__> Just wondering, how would you sell functional programming to undergrad game developers in 15 mins?
12:02:09 <maurer_> balor__: Never segfault again.
12:02:18 <maurer_> :P
12:02:31 <balor__>  maurer_: that's a bonus :)
12:02:34 <Jafet> Never work for a big-time game company again.
12:02:44 <roconnor> \x -> case 5 + 4 of { _ -> x } -- this has type Void -> Void, it is in weak head normal form but it isn't in normal form.
12:02:45 <balor__> I was thinking more FRP and automated testing
12:02:47 <Jafet> (Half of them will immediately leave. They will regret it.)
12:03:01 <balor__> But is there a better example of parallelisation on GPU?
12:03:48 <maurer_> balor__: If you don't know FP already, FRP will look like voodoo.
12:04:04 <maurer_> roconnor: What definition of normal form are you using?
12:04:55 <tswett> Let's see, what should I do next writing this Lua binding?  I should probably loathe the stack.
12:05:47 <monochrom> how to sell ___ to undergrad in 15 minutes or less: by claiming that the industry is moving towards ___. reason: undergrad knows too little to understand ___ in 15 minutes, let alone see why it makes life easier
12:06:09 <tswett> Hey, I'm an undergrad.  You can use me for target practice.
12:06:12 <koeien> I was immediately hooked by a smaller example. no more memory management!
12:06:21 <shachaf> monochrom: Wouldn't that be a reason you *couldn't* sell it?
12:06:22 <monochrom> indeed, this is how they sold oop to undergrad in 15 minutes
12:06:23 <koeien> purity!
12:06:28 <Jafet> Webscale!
12:06:51 <koeien> declarative programming (the "what", not "how")
12:07:00 <monochrom> it is a reason you can sell it. undergrads care about getting jobs
12:07:06 <roconnor> maurer_: no redexs
12:07:46 <tswett> "Internally, Lua uses the C longjmp facility to handle errors."  longjmping out of a running Haskell function sounds like something that could be really bad.
12:07:48 <balor__> monochrom, kinda, but I'm more looking for what's the best angle.  I *could* demo Frag, but that's yet another game in another language.
12:07:58 <tswett> Oh well.  I'll grin and bear whatever segfaults or whatever I get.
12:08:31 <maurer_> roconnor: In that case, you just became compiler/runtime dependent
12:08:46 <shachaf> monochrom: You must be thinking of a strange variety of undergrads.
12:09:01 <maurer_> roconnor: In your example, the compiler would have emitted "f x = x"
12:09:07 <maurer_> If you took it one step further and did
12:09:15 <monochrom> I must also add that when I say undergrads know little, it is not their own fault. schools don't challenge undergrads enough. (schools can challenge undergrads more, as they did 50 years ago or 100 years ago)
12:09:18 <Jafet> They're strange, but they massively outnumber the normal ones. Sort of like zombies.
12:09:22 <maurer_> \x y -> y + (x * x)
12:09:52 <maurer_> It would start in NF, but after applying it to 2, whether it is in normal form would depend on whether or not the runtime supported evaluation of thunks without all arguments present
12:09:53 <pastorn> @pl \x y -> y + (x * x)
12:09:54 <lambdabot> (+) . join (*)
12:09:58 <pastorn> :D
12:10:35 <balor__> Ah! bingo. If anyone else is interested, GLSL or CUDA kernels *must* be side-effect free.  Thus FP is awesome for GPU processing.
12:10:58 <maurer_> balor__: B|
12:11:26 <maurer_> balor__: That's all kinds of lies, plus our FP langauges don't target GPUs without going through GLSL or CUDA as an intermediary.
12:11:27 <Twey> monochrom: They should be doing their own study
12:12:36 <pastorn> balor__: you sell it with type safety
12:12:48 <pastorn> balor__: look at Sweeneys presentation from a few years back
12:13:46 <pastorn> balor__: http://lambda-the-ultimate.org/node/1277
12:14:23 <pastorn> for best viewing, use M$ office and the ppt (OpenOffice & the pdf looks kinda wonky)
12:14:28 <RichardO> is (=<<) = concatMap when dealing with lists?
12:14:30 <jmcarthur> yeah tim sweeney is definitely the man to point to for functional programming in games
12:14:49 <jmcarthur> RichardO: yes
12:15:43 <RichardO> jmcarthur: k, seemed so. wasn't sure if I was missing some edge case.
12:16:11 <balor__> pastorn, That's excellent. Thanks.  (works fine in LibreOffice btw :)
12:16:44 <pastorn> balor__: iirc there's a follow up to that one, search LtU for it :)
12:17:10 <tswett> Is doing, say, "import Data" the same thing as importing every module under Data?
12:17:20 <maurer_> tswett: No.
12:17:41 <maurer_> tswett: module Foo is entirely separate, and possibly unrelated from, Foo.bar
12:17:43 <maurer_> err
12:17:45 <maurer_> Foo.Bar
12:18:30 <maurer_> (In practice, if Foo exists, it should export the clean/expected use interface to the Foo stuff, which evidently includes some Bar stuff, but nothing forces this)
12:18:31 <ciphergoth> but sometimes I find that I'm using symbols that are in the documentation for modules I haven't directly imported
12:18:40 <monochrom> it seems to work for some modules because the author explicitly arranges for it
12:18:47 <ciphergoth> ok
12:26:55 <tswett> I can treat a C 'int' as a Bool, right?
12:28:30 <maurer_> tswett: What do you mean specifically?
12:29:08 <tswett> If I have a C function returning an int, when I'm foreign-importing it, can I say it returns a Bool and expect that 0 will be False and everything else will be True?
12:29:54 <maurer_> tswett: To be safe, typesign the foreign import exactly as it is in the header file, then use "fromEnum" on the return value
12:30:08 <maurer_> (when you write the haskell-land wrapper)
12:31:16 * tswett nods.
12:31:27 <ricree> is there any particular reasoning not to have profiling turned on in my cabal config?
12:31:49 <shachaf> fromEnum might not handle non-zero true values.
12:32:43 <Saizan> ricree: it'll just take longer to build libs
12:35:45 <magicman> > fromEnum 5 :: Bool
12:35:46 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
12:35:47 <lambdabot>         against inferred type ...
12:36:06 <magicman> > (fromEnum 5) :: Bool
12:36:06 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
12:36:06 <lambdabot>         against inferred type ...
12:36:13 <shachaf> > toEnum 5 :: Bool
12:36:13 <magicman> :t fromEnum
12:36:13 <lambdabot>   *Exception: Prelude.Enum.Bool.toEnum: bad argument
12:36:14 <lambdabot> forall a. (Enum a) => a -> Int
12:36:18 <magicman> Oh, right >_<
12:36:23 <shachaf> > (((fromEnum 5)) :: ((Bool)))
12:36:24 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
12:36:24 <lambdabot>         against inferred type ...
12:36:25 * magicman fails.
12:36:45 <tswett> shachaf: you forgot the parentheses around the 5.
12:36:54 <shachaf> tswett: "fromEnum 5" is atomic.
12:36:54 <magicman> Yeah, here I briefly thought it read it as "fromEnum (5 :: Bool)". Which I thought was odd, but then again, I forgot it should've been toEnum ;)
12:37:16 <tswett> shachaf: oh, sure, I believe you.
12:37:19 <tswett> :)
12:37:39 <pmetzger> I can use type to partially apply a type constructor of kind * -> * -> * to get one of type * -> * and give it a name yes?
12:37:48 <shachaf> tswett: I was just extending magicman's example. Once something is in parentheses you can't change it anymore.
12:38:06 <shachaf> pmetzger: Well, yes, but you won't be able to do that much with that name.
12:38:13 <shachaf> pmetzger: It's almost on the level of #define.
12:40:40 <tswett> pmetzger: I'm sure you can do that by saying "type Foo a = Bar T a", for instance.
12:41:01 <tswett> I don't know if "type Foo :: * -> * = Bar T" or something would also work.
12:41:29 <koeien> yes, but you cannot partially applyt hem
12:41:35 <Saizan> type Foo = Bar T works
12:41:58 <Saizan> basically type synonyms don't give you any extra expressive power, just syntactical convenience
12:54:05 <pastorn> edwardk: awesome reactive git repo :D
12:54:17 <pastorn> (i could build + install it!)
12:54:22 <edwardk> pastorn: i need to spend some more time hacking on it
12:54:34 <pastorn> edwardk: oh? something missing?
12:55:03 <edwardk> i basically just did the minimum to flip it over to my new libraries from category-extras
12:55:12 <pastorn> edwardk: i were supposed to work on reactive-sdl for a school project, but then the hackage version was borked, and i got your link, which seems to work :)
12:55:29 <edwardk> there are a few cases that could stand to be cleaned up to use more minimal typeclasses here and there
12:55:54 <pastorn> edwardk: ah, but for doing an adapter i won't care, right?
12:57:32 <edwardk> yeah
12:58:03 <edwardk> it is mostly stuff that unless you're me, you probably will never need/notice.
12:58:13 <pastorn> haha
12:58:20 <edwardk> a monoid instead of a semigroup here or there, etc.
12:58:41 <edwardk> where the correct interface would have necessitated too big of a change to the reactive api
12:58:43 <pastorn> are they the same?
12:58:53 <edwardk> nah monoid has mempty, semigroup does not
12:59:01 <pastorn> oh
12:59:10 <pastorn> ah, SEMI-group
12:59:19 * pastorn is t3h clevarz
12:59:35 <Phyx-> "    where fold (CSharp a b c d e f g h i j k l) = csalg a b c d e f g h i j k l" <-- there has to be an easier way
12:59:39 <edwardk> monoid = associative binary operation with unit, semigroup = associative binary operation
13:01:06 <edwardk> phyx: perhaps passing the algebra the dictionary still tupled up instead?
13:01:45 <edwardk> then fold cs = csalg cs
13:01:50 <edwardk> or fold = csalg
13:01:58 <pastorn> Phyx-: template haskell?
13:02:15 <DasIch> here http://learnyouahaskell.com/a-fistful-of-monads#the-monad-type-class an example is given ``Just 9 >= \x -> return (x*10)`` is that considered good style or would ``Just 9 >>= return . (*) 10`` be better?
13:02:53 <Saizan> fmap (*10) (Just 9)
13:02:55 <pastorn> DasIch: i'd do 'fmap (*10) (Just 9)'
13:03:28 <pastorn> DasIch: writing monadic code is often easy, but many times you don't need it
13:03:36 <edwardk> > liftM (*10) (Just 9)
13:03:37 <lambdabot>   Just 90
13:04:21 <DasIch> well obviously the monad stuff is unnecessary overhead, i was more concerned about the usage of the lambda
13:04:23 <edwardk> whenever you find yourself writing foo >>= return . bar, just refactor to liftM bar foo
13:04:51 <DasIch> :t liftM
13:04:52 <edwardk> DasIch: usually depends on if the right hand side is linear in its use of the argument, and if the pointfree form is hideous or not
13:04:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:05:01 <pastorn> @src liftM
13:05:01 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:05:40 <DasIch> thanks guys :)
13:05:43 <pastorn> @src liftM2
13:05:44 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:05:46 <pastorn> etc. etc.
13:06:11 <edwardk> personally, i tend to write most things on the right hand side of >>= in explicitly pointed form unless it dissolves away to a liftM or liftM2 or something
13:06:25 <Zeus_> good evening guys
13:06:39 <pastorn> Zeus_: hello :)
13:06:47 <Zeus_> hi pastorn
13:06:55 <Zeus_> may I ask you a question?
13:07:02 <edwardk> don't ask to ask, just ask ;)
13:07:23 <edwardk> (yes) =)
13:08:17 <Zeus_> I want to know if Haskell like Ruby.
13:08:39 <pastorn> Zeus_: if haskell is like ruby? or if haskell likes ruby?
13:08:48 <pastorn> @faq can haskell like ruby?
13:08:48 <lambdabot> The answer is: Yes! Haskell can do that.
13:08:52 <Zeus_> i don't know a lot of Ruby but I'm trying to learn it and I'd like to ask if there are similarities and/or diffencies between them
13:08:57 <zomg> Haskell is nothing like Ruby :P
13:09:22 <edwardk> zeus: in some senses. both haskell and ruby offer some of the same tools here and there, but haskell generally offers better control over side-effects and catches more problems at compile time due to strong typing
13:09:41 <Zeus_> is it more powerful? or are there more functionalities than Ruby has?
13:09:43 <c_wraith> wait, Robert Harper can't write haskell programs without unsafePerformIO?  that's...  odd.
13:10:04 <pastorn> Zeus_: you can control what happends better in haskell
13:10:10 <KirinDave> Also
13:10:15 <KirinDave> Haskell has better libraries for a lot of things
13:10:27 <KirinDave> better meaning that they tend to be more robust, better written, and more thought out.
13:10:27 <edwardk> Zeus_: both are good at different things. imho haskell is the more powerful of the two because of the better control over side-effects and safer programming style
13:10:35 <pastorn> Zeus_: if you ever read a file or start a network connection or paint some graphics, your return values gets tainted with IO
13:10:35 <KirinDave> Not to mention Ruby is suffering under the Implementation Curse.
13:10:41 <edwardk> ruby is pretty good at doing cute domain specific languages though
13:10:41 <Zeus_> can you guys recommend me some books/videos/tutorials?
13:10:53 <pastorn> Zeus_: so you know that you've been naughty (and had side effects)
13:11:02 <edwardk> Zeus_: http://learnyouahaskell.com/
13:11:02 <stepkut> if I want to submit a simple patch to a (haskell) project on github, am I really supposed to create a github account, fork the project, and then submit a pull request? Or is there a more lightweight approach?
13:11:22 <KirinDave> stepkut: What's not lightweight about what you just said?
13:11:26 <DasIch> stepkut: that's usually the way to go
13:11:41 <jmcarthur> c_wraith: yeah, that completely killed any image of expertise i had previously been projecting onto him
13:11:41 <sipa> stepkut: clone it locally, edit, ask git to create a patch, mail that patch to maintainer
13:11:49 <DasIch> stepkut: although github has added an edit and fork button or something for that recently
13:11:50 <edwardk> stepkut: that is the nicest way to do it for the guy who needs to consume your patch
13:12:06 <stepkut> sipa: last time I did that I got a merge conflict when the maintainer applied my patch and I did a pull..
13:12:13 <Zeus_> Actually I don't know too much of these things
13:12:47 <Zeus_> I've been a programmer in C++ and Java and I know a little bit of PHP and Javascript, but nothing so special.
13:12:53 <stepkut> KirinDave: creating a new, long living fork for one patch seems a bit overkill.. I am used to darcs where I just do, darcs record ; darcs send ..
13:12:58 <edwardk> Zeus_: that link is to an introduction that has the benefit of being both good AND fun. ;)
13:13:02 <pastorn> Zeus_: then i can recommend "Real World Haskell"
13:13:11 <KirinDave> stepkut: Don't worry about that.
13:13:17 <pastorn> it's a haskell book for people who already know programming
13:13:20 <stepkut> KirinDave: I worry!!
13:13:21 <KirinDave> stepkut: The network tool makes it easy to discard dead forks.
13:13:30 <stepkut> KirinDave: what network tool?
13:13:40 <Zeus_> I'll give it a try
13:13:55 <edwardk> http://book.realworldhaskell.org/read/ (which was recommended by pastorn) is also pretty good, and assumes you know a lot more programming than LYAH
13:13:56 <stepkut> git is sooo wacky
13:14:22 <KirinDave> stepkut: http://fayr.am/6QaE
13:14:23 <Zeus_> and then sooner or later I'll come back so I will have the possibility to discuss properly with you
13:14:34 <sully> LYAH covers typeclasses before recursion, which I think is backwards
13:14:39 <Kaidelong> why does fmap's type not look more like semimap's?
13:14:40 <pastorn> Zeus_: but i can tell you that i learned most of my haskell from lambdabot and wikibooks
13:14:55 <edwardk> Kaidelong: from semigroupiods?
13:14:59 <Kaidelong> yeah
13:15:06 <DasIch> sully: it's not like recursion is such a hard topic...
13:15:22 <pastorn> sully: well, you might want to know about num, since your 'sum' function you define with recursion is gonna have it in its signature
13:15:27 <edwardk> http://hackage.haskell.org/packages/archive/semigroupoid-extras/0.2.1.0/doc/html/Data-Semifunctor.html requires extensions
13:15:29 <Zeus_> woa! that sounds good!
13:15:38 <dons> lovely article on laziness, http://news.ycombinator.com/item?id=2507607
13:15:45 <Kaidelong> so fmap could have the same type but not in haskell?
13:15:52 <Zeus_> so, i can imagine, it's more like a script language, right?
13:16:00 <edwardk> Kaidelong: it could have it in haskell, just limited to ghc haskell ;)
13:16:38 <Kaidelong> so the only difference between fmap and semimap is that semimap is not subject to all the functor laws?
13:16:40 <sully> although I guess when I read haskell tutorials, I skipped over "this is how you recurse" and "this is a data type!" once I had seen what the syntax was
13:16:43 <pastorn> Zeus_: i don't have a clear definition of a script language, but i don't think haskell is one
13:16:50 <Kaidelong> most specifically, semimap(id) != id
13:17:02 <Kaidelong> neccessarily
13:17:32 <jmcarthur> pastorn: even with runhaskell? ;)
13:17:37 <Zeus_> ok pastorn
13:17:55 <Kaidelong> (conceptually speaking; I can see that fmap has a more restrictive type)
13:19:07 <edwardk> dons: i'm really glad lennart wrote that. the laziness is better for reuse argument is my main selling point when i give one of my little 2 hour haskell tutorials.
13:19:25 <jmcarthur> pastorn: btw, i'm not a huge fan of that notion of IO as "taintedness" like you said above. it doesn't really explain the idea of "IO actions" very accurately as things you can pass around in pure code and data structures (*without* tainting your pure code)
13:19:35 <edwardk> i was just too exasperated by bob's latest rant to go poking holes in it
13:19:44 <Kaidelong> also, Functor f => Semifunctor (WrappedFunctor f) (->) (->) is saying all functors are semifunctors, and the WrappedFunctor is used to make their class compatible with the functor class?
13:20:07 <edwardk> Kaidelong: correct
13:20:47 <edwardk> the WrappedFunctor class is to let you use a Functor as its logical superclass Semifunctor without requiring the rest of the haskell world to comply with my anal retentive streak
13:20:55 <pastorn> jmcarthur: i found it good to explain why 'wc :: FilePath -> IO Int' and not 'wc :: (IO String) -> Int' or something similar
13:21:26 <edwardk> by analogy WrappedMonad in Control.Applicative serves a similar purpose, letting you use any monad as an Applicative, even if they didn't think to supply an Applicative instance for you
13:21:48 <edwardk> and it was added because Applicative came along after Monad was defined
13:22:01 <rata_> hi
13:22:21 <Kaidelong> almost seems worth making a dialect of haskell that fixes these issues
13:22:56 <edwardk> Kaidelong: well, sadly there are issues with type inference here and there and the api that results from going after the 'most general api' isn't always the most natural
13:23:01 <pastorn> edwardk: will we get Pointed, and proper Applicative stuff in base5?
13:23:11 <edwardk> pastorn: i want Pointed to die
13:23:18 <edwardk> pastorn: I would _love_ to see Apply though ;)
13:23:29 <Kaidelong> what's wrong with pointed?
13:23:51 <edwardk> it is far more useful to have an associative law without a unit, than a unit that provides no laws that can't be expressed with a free theorem
13:24:23 <pastorn> applicative: BUTWAI?!
13:24:44 <pastorn> edwardk: pointed is pretty awesome, if it was in the standard libraries and was required everey here and there
13:24:49 <Kaidelong> hmm actually now that I think of it, couldn't you model Pointed using Functor?
13:25:11 <edwardk> pastorn: have you looked at the refactored libraries i pulled out of category-extras?
13:25:24 <Kaidelong> (() -> a) -> (F () -> F a) if you have an element F ()
13:25:30 <pastorn> edwardk: no, i don't know what they're called, but they're in the reactive .cabal file?
13:26:07 <Kaidelong> oh, which you do
13:26:08 <edwardk> pastorn: pointed and functor don't interact in any non-trivial ways
13:26:09 <Kaidelong> undefined
13:26:51 <Kaidelong> > (fmap (const 5)) undefined :: [Int]
13:26:52 <lambdabot>   *Exception: Prelude.undefined
13:27:02 <Kaidelong> oh
13:27:07 <Kaidelong> right
13:27:10 <pastorn> edwardk: fmap f (point x) ?
13:27:13 <edwardk> pastorn: this is why the current 'Pointed' which only exists to silence the hordes doesn't even have the Functor constraint, because there are no laws you need to state.
13:27:39 <edwardk> pastorn: when you state how those interact, there is no way that any valid functor and pointed instance for a given type can fail the law
13:27:48 <osfameron> those pesky hordes!
13:27:51 <pastorn> so you should only be able to lift values that you later are guaranteed to be able to apply over?
13:27:53 <edwardk> pastorn: the free theorem is strong enough
13:27:56 <pastorn> *apply functions*
13:28:03 <Kaidelong> edwardk: Wouldn't it be sensible to express laws for a "pointed functor" somehow?
13:28:09 <dons> edwardk: yes, its a great post
13:28:12 <dons> and timely reminder
13:28:23 <Kaidelong> or even leave Functor as an empty class that just adds some rewrite rules
13:28:31 <Kaidelong> and has semifunctor as a superclass
13:28:36 <edwardk> Kaidelong: there is only the law that fmap f . point = point . f, but that is a free theorem for point.
13:28:39 <Kaidelong> not sure if you can actually do that
13:28:49 <pastorn> when will we get typeclass synonyms?
13:28:56 * pastorn wantz it
13:29:09 <edwardk> pastorn: you can already kinda fake it
13:29:25 <edwardk> pastorn: class (Foo a, Bar a) => Baz a; instance (Foo a, Bar a) => Baz a
13:29:47 <edwardk> that lets you use Baz interchangeably with the pair of types Foo and Bar
13:30:00 <edwardk> (given undecidableinstances)
13:30:07 <edwardk> but it always resolves safely
13:30:46 <pastorn> i want it for the Num class
13:30:55 <pastorn> so we can have Additive, Multiplicative etc.
13:31:14 <pastorn> and that way i can use (+) instead of 'mappend'
13:31:57 <edwardk> just import http://hackage.haskell.org/packages/archive/monoids/0.2.0.2/doc/html/Data-Monoid-Sugar.html ;)
13:32:30 <pastorn> hahaha, nice :)
13:32:59 <edwardk> that is, as soon as i update the old monoids package to work over the newer semigroups stuff
13:33:45 <edwardk> pastorn: you can convert between (+) and (*) by using Log and Exp ;)
13:38:58 <Kaidelong> so the apply typeclass is just applicative without pure?
13:40:25 <edwardk> Kaidelong: yep
13:41:01 <edwardk> Kaidelong: and Foldable1 and Traversable1 are strengthened foldable and traversables which can work with just a Semigroup or Apply instance instead of a Monoid or Applicative
13:41:26 <navaati> hello
13:41:34 <edwardk> Kaidelong: they basically say that the container in question contains at least 1 element, and so doesn't need return or pure or mempty providing the base case
13:42:04 <edwardk> so stronger containers can be traversed with weaker algebraic structures
13:42:55 <Kaidelong> edwardk: Foldable1 actually seems like a good way to model stream IO then
13:43:02 <acowley> hey edwardk, you didn't happen to read http://golem.ph.utexas.edu/category/2011/04/higher_categories_for_concurre.html did you?
13:43:08 <navaati> what is the difference between NoImplicitPrelude and RebindableSyntax ?
13:43:20 <Kaidelong> well
13:43:20 <Kaidelong> a restricted version of it
13:43:22 <edwardk> acowley: new to me
13:43:40 <edwardk> navaati: rebindablesyntax goes a lot farther
13:44:09 <acowley> edwardk: okay, I've got a research project that will want some type-level reasoning about concurrent processes, and a part of that presentation left me with a question
13:45:02 <edwardk> fair nuff. have you looked at morrisett's work on hoare type theory, etc?
13:45:55 <navaati> so i I want to use Arrow syntax with another class than Control.Arrow, how can I do with ghc 6 ?
13:46:18 <Accidus> acowley, try to just ask the question...
13:46:32 <Zeus_> Guys, I appreciate your help.
13:46:38 <acowley> Probably not closely enough. I'm familiar with the basics (I'm a TA in the class) , and I've had some good success with my work with linear logic and additive conjunctions etc.
13:46:48 <Zeus_> See you next time... bb!
13:46:59 <acowley> Accidus: right, wrt that link, the typing rule for the | construct is quite limited
13:47:39 <acowley> in Hoare-style presentations, one tends to reason about disjoint heaps
13:48:14 <acowley> I can build up a product at the end of two parallel derivations on disjoint assumptions (aka domains, heaps, whatever)
13:48:49 <acowley> but, in my work, I will need to do a bit more work with the type describing my processes
13:49:52 <edwardk> navaati: it should just be RebindableSyntax
13:50:11 <edwardk> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/syntax-extns.html#rebindable-syntax
13:50:18 <navaati> oh, i thought RebindableSyntax was only for ghc 7
13:50:34 <edwardk> oh sorry i didn't see the 6
13:50:37 <edwardk> there you're screwed ;)
13:51:04 <edwardk> NoImplicitPrelude works in ghc 6 to get arrow sugar
13:51:08 <navaati> ok, I'll update, it's just that ghc7 is marked unstable in my distro
13:51:10 <edwardk> well at least as of 6.8.1
13:51:23 <edwardk> http://www.haskell.org/ghc/docs/6.8.1/html/users_guide/syntax-extns.html
13:52:13 <navaati> i tried and it doesn't work, i get errors about a missing context…
13:52:33 <edwardk> the main thing missing between noimplicitprelude back in 6.x and rebindablesyntax is rebinding 'if'
13:52:57 <navaati> maybe it will be fixed ghc7, i'll see after it's compiled
13:53:00 <navaati> oh… :(
13:53:27 <edwardk> also i think arrowloop is fried in rebindablesyntax, or was
13:53:41 <edwardk> http://hackage.haskell.org/trac/ghc/ticket/4851
13:53:43 <edwardk> found it
13:57:30 <Phyx-> :t everything
13:57:31 <lambdabot> forall r a. (Data a) => (r -> r -> r) -> GenericQ r -> a -> r
13:57:42 <Phyx-> :t everything (||)
13:57:43 <lambdabot> forall a. (Data a) => GenericQ Bool -> a -> Bool
14:00:20 <jmcarthur> ezyang: excellent writeup! http://blog.ezyang.com/2011/05/haskell-not-pure-enough/
14:02:57 <kniu> The Pursuit of Lazyness
14:06:14 * hackagebot digestive-functors 0.1.0.0 - A general way to consume input using applicative functors  http://hackage.haskell.org/package/digestive-functors-0.1.0.0 (JasperVanDerJeugt)
14:07:14 * hackagebot digestive-functors-blaze 0.1.0.0 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.1.0.0 (JasperVanDerJeugt)
14:08:38 <navaati> baaaah, building ghc is looooong
14:09:06 <Kaidelong> looks like a discussion I got myself into
14:09:15 <Phyx-> takes ~30-60mins here
14:09:15 * hackagebot digestive-functors-happstack 0.1.0.0 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.1.0.0 (JasperVanDerJeugt)
14:09:55 <navaati> a lot more than a linux kernel or even gcc, then
14:10:15 * hackagebot digestive-functors-snap 0.1.0.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.1.0.0 (JasperVanDerJeugt)
14:10:16 <monochrom> you are not meant to build ghc yourself. because it takes too long, yes
14:10:33 <monochrom> but do get a movie or two to watch while you wait
14:10:51 <Phyx-> navaati: it takes considerably less if you don't build documentation
14:10:53 <monochrom> I recommend Elizabeth Taylor's Cleopatra!
14:11:11 <monochrom> iirc doc is not built by default
14:11:50 <Saizan> ben hur?
14:11:55 <crystal-cola> HBow can I get haskell to open up a window to display graphics
14:11:57 <ben> ?
14:11:58 <monochrom> that also works
14:12:12 <Phyx-> crystal-cola: use a windowing toolkit like gtk2hs
14:12:12 <monochrom> generally any movie that includes an intermission!
14:13:07 <monochrom> glut also opens a window. some people go further (more abstract and portable) to glfw
14:13:24 <Phyx-> oh yeah, forgot about glut
14:13:28 <Phyx-> drew a chess game with it once
14:14:20 <monochrom> it depends on what lib you use to draw the stuff inside the window. then you choose the companion window lib
14:14:35 <monochrom> (easiest route)
14:17:56 <dagit> glfw-b is actually the package you want, not glfw
14:18:18 * hackagebot hakyll 3.1.1.2 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.1.2 (JasperVanDerJeugt)
14:18:43 <dagit> crystal-cola: I have a bunch of opengl examples using glfw-b on hackage and github if you want to take a look
14:19:00 <crystal-cola> that's okay
14:19:26 <dagit> crystal-cola: https://github.com/dagit/nehe-tuts
14:27:01 <o1iver> hi guys. I am confused by something. What is the difference between (liftM (* 3) [1,2,3]) and (map (* 3) [1,2,3])? Although LiftM is a monadic function the results are of the exact same type...
14:27:34 <Saizan> liftM = map when used for the [] monad
14:27:42 <KirinDave> o1iver: It might be illustrative for you to look at the implementation of the Monad instance for lists.
14:27:49 <acowley> put another way, map is liftM for []
14:27:51 <o1iver> does [1,2,3] automatically convert to M [Int] when called with LiftM?
14:27:57 <Phyx-> :t mkQ
14:27:58 <lambdabot> forall r b a. (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
14:27:59 <navaati> > (liftM (* 3) [1,2,3])
14:28:00 <lambdabot>   [3,6,9]
14:28:01 <Saizan> o1iver: no
14:28:02 <acowley> [] Int
14:28:07 <Nereid> [] is a monad
14:28:12 <navaati> > (map (* 3) [1,2,3])
14:28:12 <lambdabot>   [3,6,9]
14:28:13 <Saizan> o1iver: in that expression [] is the 'm'
14:28:32 <Nereid> by the way
14:28:34 <o1iver> Saizan: mmmh isnt [] just an empty list?
14:28:37 <Saizan> [Int] is also written as [] Int
14:28:45 <Saizan> o1iver: i mean [] the type constructor
14:28:54 <byorgey> [] can mean two things, empty list or the list type constructor
14:29:15 <KirinDave> Yeah
14:29:20 <KirinDave> [Int] is also [] Int
14:29:29 <o1iver> byorgey: so you mean like when it is used like this (1:2:3:[])?
14:29:30 <Nereid> also: all monads are (or should be) functors, where fmap = liftM
14:29:33 <KirinDave> Remember that things have slightly different meanings when you're talking about types.
14:29:43 <byorgey> o1iver: that is the empty list
14:29:55 <KirinDave> Otherwise what is [Int]?
14:30:00 <KirinDave> A list containing a type? :)
14:30:15 <KirinDave> o1iver: Seriously look at the instance of Monad for List.
14:30:15 <parcs> @type undefined :: [] 5
14:30:16 <lambdabot> Only unit numeric type pattern is valid
14:30:22 <Nereid> @type [1,2,3] :: [] Int
14:30:23 <lambdabot> [Int]
14:30:27 <o1iver> KirinDave: ok I will have a look
14:30:31 <Nereid> uhh
14:30:38 <Nereid> ok
14:32:19 <Kaidelong> so what would you call a functor that preserves inverses
14:32:36 <Nereid> functors always preserve inverses
14:32:43 <monochrom> what does that axiom look like symbolically?
14:32:50 <Kaidelong> hmm
14:32:57 <Nereid> assuming you mean F(f^-1) = F(f)^-1
14:33:04 <danharaj> It's not an axiom, it's a theorem :p
14:33:20 <Nereid> functors take isomorphisms to isomorphisms, because
14:33:42 <Nereid> if fg = 1, then F(f)F(g) = F(fg) = F(1) = 1
14:33:42 <Nereid> and vice vers
14:33:42 <Nereid> a
14:33:45 <monochrom> iow I don't know what the english "preserves inverses" means
14:33:55 <Nereid> monochrom: I just wrote it
14:34:10 <monochrom> yeah but you don't have a usb connection to Kaidelong's brain
14:34:14 <Kaidelong> so because (f . f^-1) = id, F(f) . F(F^-1) should also = id?
14:34:22 <Nereid> yes
14:34:41 <Kaidelong> so then preserving inverses is inevitable if you preserve identities
14:34:47 <Nereid> monochrom: it's obvious what he meant
14:34:55 <Kaidelong> okay, that makes sense
14:35:04 <Nereid> and preserving identities is part of the definition of a functor
14:35:09 <Kaidelong> yeah
14:35:25 <crystal-cola> F(f) . F(f^-1) = F(f . f^-1) = F(id) = id
14:35:30 <crystal-cola> you can prove this stuff
14:36:04 <Nereid> I love how #haskell sometimes becomes #category-theory
14:36:18 <Kaidelong> hmm, that's category theory?
14:36:19 <Kaidelong> sorry
14:36:30 <Nereid> well
14:36:33 <Nereid> you're talking about functors
14:36:43 <Nereid> no, nothing wrong with it :>
14:36:44 <monochrom> it's ok once in a while
14:37:18 <Accidus> Aye Nereid, I usually get better answers for my CT questions here than in #math
14:37:58 * mgsloan tries to join #category-theory. fails.
14:38:03 <navaati> it's the way i like haskell community
14:38:12 <Kaidelong> mgsloan: ##categorytheory
14:39:49 <tg_> any snap people here?
14:40:01 <Kaidelong> tg_: #snapframework
14:40:05 <tg_> Kaidelong: ty
14:42:38 <tg_> anyone have advice on setting up an isomorphism over a [1-1, onto?] set of functions in haskell <-> javascript (like processing)
14:43:22 <Accidus> tg_, I'm not sure I follow your intention
14:43:33 <Kaidelong> Applicative might be a good idea but I have no idea how you would write "pure"
14:44:03 <Kaidelong> hmm, perhaps with an instance where the type variable has a class constraint applied
14:44:32 <monochrom> "pure" is like "return" of Monad
14:44:58 <Kaidelong> are you looking to dump javascript code from a subset of haskell?
14:45:26 <monochrom> for example if you're turning "data B a = Z | B a (B a) (B a)" into an Applicative, pure x = B x Z Z
14:45:42 <tg_> Kaidelong: i'll handle tthat part
14:46:01 <tg_> Kaidelong: i'll only be using fixedpoints
14:46:02 <Kaidelong> oh yeah, no reason why you wouldn't want a monad
14:46:27 <tg_> anything stronger if I'm insisting on fixedpoints only?
14:46:34 <byorgey> well, there would also be an Applicative instance with  pure x = B x (pure x) (pure x)
14:46:57 <tg_> byorgey: so there is one with pure (a,b,c,d) = ...?
14:47:00 <tg_> a 4-applicative?
14:47:07 <Kaidelong> what do you mean fixedpoints only?
14:47:09 <monochrom> yikes!
14:47:24 <tg_> monochrom: crazy, I know
14:47:25 <byorgey> tg_: I don't understand the question.
14:47:37 <tg_> all of the computations I want to look at
14:47:40 <monochrom> no I mean byorgey's infinite tree :)
14:47:40 <tg_> will be of the form
14:47:42 <c_wraith> tg_: that doesn't appear to have the right kind to be Applicative.  Unless 3 of those variables aren't polymorphic
14:47:46 <Kaidelong> anyway sounds like you might want a monad that lets you turn it into javascript
14:47:49 * Kaidelong has to leave
14:47:52 <tg_> Fold[Fold[Fold[Fold(fixpoint)]]]]
14:48:03 <byorgey> monochrom: I don't see what's so scary about infinite trees.
14:48:13 <tg_> actually
14:48:14 <monochrom> haha
14:48:17 <tg_> I want to apply functions
14:48:29 * monochrom axiomatizes scary=funny
14:48:40 <tg_> F[(a,b,c,d)] onto Fold[Fold[Fold[Fold(e)]]]]
14:48:43 <byorgey> hehe
14:48:49 <tg_> does that make any sense?
14:48:54 * shachaf does tend to laugh when monochrom axiomatizes scary.
14:48:59 <edwardk> mgsloan: it is ##categorytheory
14:49:21 <mgsloan> edwardk/Kaidelong: ty :D
14:49:39 <monochrom> (oh, you don't see why it's funny either? well humour can't be formalized further. take call it the monochrom thesis, like Turing thesis)
14:49:42 <byorgey> tg_: not really.  what is Fold?
14:50:07 <mgsloan> I think I've tried to learn category theory enough that I might benefit from observing some irc conversations on it
14:50:49 <tg_> byorgey: hm. nevermind, I'll just figure it out. Didn't you publish a dictionary of... monads?
14:50:50 <acowley> Every time I idle in ##categorytheory it is crickets. Perhaps I am an eliminator.
14:51:24 * hackagebot roundtrip 0.1.0.0 - Bidirectional (de-)serialization  http://hackage.haskell.org/package/roundtrip-0.1.0.0 (StefanWehr)
14:51:26 <byorgey> tg_: I perhaps you're thinking of the Typeclassopedia?  It isn't a dictionary of monads though.
14:51:34 <tg_> byorgey: yeah, that's what I meant
14:51:55 <acowley> It's a Who's Who of types
14:53:24 * hackagebot roundtrip-xml 0.1.0.0 - Bidirectional (de-)serialization for XML.  http://hackage.haskell.org/package/roundtrip-xml-0.1.0.0 (StefanWehr)
14:53:43 <tg_> byorgey: by fold, I meant, generate a function that is multiplicative over: F[a,b,c,d]. Then, recurse with a,b,c,d { F[x],F[x],F[x] }, then each of those with {F[x],F[x]}, and then F[x] with the last point.
14:54:08 <tg_> like, an inverse quaternion or something, lol
14:54:29 <acowley> quaternions are a group
14:54:43 <tg_> acowley: I said like, not the same as
14:56:10 <tg_> byorgey: i shall just search for typeclassopedia
14:58:04 <danharaj> acowley: a pleasant coincidence that you are here.
14:58:31 <danharaj> acowley: I took your glutil library and mangled it beyond recognition for a project I'm working on. How should I credit you?
14:58:53 <acowley> However makes sense to you
14:59:30 <acowley> Or, you could name the project after me
14:59:38 <danharaj> I will erect a statue of you.
14:59:39 <acowley> those are the options
14:59:41 <acowley> oooh
14:59:43 <acowley> okay, three options
15:01:21 <acowley> There should be an Open Source license based on acknowledgements-in-the-form-of-statuary
15:01:45 <danharaj> acowley: should I just put in my copyright notice underneath my copyright "Some parts Copyright (c)2011 Anthony Cowley"? Would that satisfy? :p
15:01:50 <danharaj> I haven't done this before.
15:01:57 <danharaj> Steal other peoples' code in an ethical manner that is.
15:02:52 <acowley> danharaj: That sounds fine. If my name is in there somewhere, I consider it ethical (I realize you will now write, "No part of this is due to acowley")
15:03:26 <acowley> Mainly, I'm just glad it was useful to you!
15:03:27 <danharaj> The only part that survived intact was basically your shader code. I'll mark it in that file that you pretty much did all the work.
15:03:40 <acowley> You didn't like the texture stuff?
15:03:41 <danharaj> acowley: quite useful!
15:03:47 <acowley> I thought it turned out neat
15:04:15 <danharaj> acowley: I generalized your interface so you could choose different formats.
15:04:20 <danharaj> I forgot precisely where, it was a while ago.
15:04:47 <acowley> is your code public?
15:05:02 <danharaj> acowley: yes, just fixing up the credit stuff before I tell anyone that it exists.
15:05:10 <danharaj> It is important to me that people get credit where they deserve it.
15:05:48 <acowley> It's hard to do these days, as one finds so many fragments on the net
15:07:10 <acowley> I should probably be more diligent about specifying licenses, even if something is intended to be PD
15:08:36 <danharaj> I really need to learn how to use git
15:08:46 <danharaj> it annoys me that msysgit doesn't actually integrate into msys.
15:09:26 <acowley> I still find git complicated and barely use 1% of what it can do even though I use it for everything
15:10:02 <Feuerbach> What's so special about '0' start code in Alex?
15:11:02 <Nereid> I feel like I should learn git
15:11:04 <Nereid> I already know how to use mercurial...
15:11:05 <Nereid> :/
15:11:17 <danharaj> ok... can anyone tell me how to stage all changes to files for commit?
15:11:44 <DevHC> danharaj: in git?
15:11:52 <Feuerbach> danharaj: git add -u/-A, depending on the definition of "all"
15:12:22 <vincekg> or git commit -a, to do the stage and the commit at the same time
15:12:45 <danharaj> ah ok
15:12:49 <danharaj> thanks.
15:13:04 <danharaj> acowley: https://github.com/dharaj/HiGL
15:13:14 <danharaj> I'm experimenting with ways of encoding shader information in Haskell types
15:13:33 <dylukes> danharaj: Other than as a string?
15:13:37 <dylukes> oh, information
15:13:41 <dylukes> I thought you meant the shader buffer itself.
15:13:42 <dylukes> >_>
15:13:55 * roconnor rewrite's wikipedia's statement of the four colour theorem to be less incorrect.
15:14:34 <danharaj> dylukes: things like what sort of attributes and uniforms should be set when rendering data with the shader, and automatically generating vertex array descriptors from the type of an aggregate of attributes.
15:14:51 <dylukes> *whoosh*
15:15:02 <dylukes> that was the sound of stuff going a bit over my head.
15:15:03 <acowley> be somewhat careful with git commit -a
15:15:08 <danharaj> Personally I think my experiment was a failure -- it's too cumbersome and restrictive I think. But we do what we must because we can.
15:15:09 <dylukes> Not too much, but a bit nonetheless.
15:15:15 <acowley> it's easy to pull in things you didn't want
15:15:26 <danharaj> acowley: like my porn stash I keep in the same directory?
15:15:50 <acowley> if you had previously added it and modified it as part of an experiment, then yes
15:15:58 <danharaj> ah I see.
15:15:59 <monochrom> all shading algorithms whoosh over my head, too :)
15:16:12 <acowley> danharaj: where is the magic shader code?
15:17:09 <danharaj> acowley: Internal/ShaderAttributes.hs should be representative.
15:17:51 <acowley> oh jeepers, you don't need to credit me for that Shader code
15:18:04 <acowley> I had that in various projects for years
15:18:17 <acowley> it's nothing anyone wouldn't write themselves
15:18:38 <danharaj> acowley: fair enough. but if you feel that way you should just public domain your helper library. :)
15:18:55 <danharaj> I mean, Linux is nothing anyone wouldn't write themselves if they had to :p
15:19:05 <acowley> yes, I should
15:19:32 <acowley> So you get reasonable types for attributes, with string names
15:19:35 <gwern> CC-PD0 yay
15:19:37 <acowley> with what you've added
15:20:46 <danharaj> oh. caveat: the code is ugly-- probably uglier than it has to be, because I sprinkled type annotations overzealously to make GHC happy, and the only part I know works is the attribute code. I wrote the uniform and sampler code recently and haven't gotten around to testing it. Mostly because I don't want to write texture loading code yet.
15:20:46 <vicvicvic> i found a "Monad version of all" (allM) in a module MonadUtils in GHC source... but it's marked as "mostly for backwards compability"; seems pretty useful to me though? is there something better?
15:20:47 <acowley> I'd like to see some code using it. It does look like a good start at typing that stuff
15:20:54 <acowley> danharaj: have you looked at GPipe?
15:20:55 <o1iver> hi guys, out of interest. is this how you would implement a string split function (split string into list of strings seperated by seperator): http://hpaste.org/46294/splitstr
15:21:15 <vicvicvic> file is here btw: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/src/MonadUtils.html
15:21:23 <o1iver> acutually I am quite certain this wouldnt be it, but what are some obvious improvements?
15:21:24 <danharaj> acowley: I have a little bit, but its philosophy is much more courageous than mine :)
15:21:25 <acowley> danharaj: my OpenGL sample includes loading textures
15:21:41 <acowley> danharaj: yeah it is, but I could never wind myself up to use it
15:21:48 <jmcarthur> vicvicvic: check out the monad-loops package
15:21:59 <jmcarthur> it might be monad-loop
15:22:14 <danharaj> acowley: I am a chronic yak shaver. If I want to load textures, I need to provide a robost framework for loading from all the major formats.
15:22:20 <danharaj> robust*
15:22:23 <gwern> o1iver: first, your nick is hard to autocomplete on. second, I wouldn't write a string split, but a general list splitter; third, I wouldn't write a general list splitter, but use Data.List.Split; fourth, that strikes me as pretty complicated, I think when I was investigating various splits, they usually took 2-3 lines
15:22:31 <vicvicvic> jmcarthur: cool stuff, thanks
15:22:46 <acowley> danharaj: use stb_image (or whatever it's called) and then something like the code I wrote
15:23:16 <acowley> danharaj: my concern with shader abstractions is that one typically only writes shader code when performance is a key issue
15:23:31 <danharaj> acowley: I don't trust that library very much. I don't know how complete and correct it is.
15:23:37 <acowley> and at that point, you need your abstraction to *not* get between you and exactly what the hardware can do
15:23:53 <o1iver> gwern: good point about my nick (have been using it for years), well I guess a string is a list right? The thing I am unsure about is this tstr (the temporary charlist that I am adding too until I find the next sperator...). I know there are lib functions that do this, but I am just practicing...
15:24:32 <acowley> so, on the one hand, writing GLSL is awkward and painful. On the other hand, it directly exposes hardware capabilities and compiles+links very quickly so iterating shader code is faster than recompiling the Haskell executable hosting it
15:24:43 <o1iver> gwern: actually I am going to have a look at Data.List.Split first
15:24:45 <gwern> o1iver: and in general, your function is pretty horrible. something like splitStr' should be in a where clause
15:25:03 <acowley> danharaj: the image one? does it matter if it's not complete/correct?
15:25:14 <danharaj> acowley: Yes. That's true. All I want to do really is reduce the boilerplate of defining a data type to hold shader info and using that to render stuff.
15:25:20 <danharaj> acowley: chronic. yak. shaver. :D
15:25:25 <acowley> hah
15:25:31 <gwern> o1iver: here's one of the many versions of split I found/wrote: http://hpaste.org/paste/46294/splitstr_annotation#p46296
15:26:59 <acowley> danharaj: Yaks look best with clipped hair, not clean shaven
15:27:16 <acowley> danharaj: or at least you should train yourself to have that opinion :)
15:27:57 <gwern> if you shave yaks, it takes longer for their hair to grow back
15:28:12 <jmcarthur> acowley: "my concern with shader abstractions is that one typically only writes shader code when performance is a key issue"  <-- the fixed function pipeline is deprecated
15:28:13 <danharaj> man who wants hairy yaks
15:29:04 <acowley> gwern: so you're saying that once danharaj has etched his own silicon and invented frameworks for everything, his yaks will be permanently hairless?
15:29:09 <acowley> jmcarthur: I know
15:29:24 <jmcarthur> i figured you did, but it's a relevant point
15:29:38 <gwern> acowley: no I mean that clipping their hair can be a false economy. will he sell the yak before the clipping bites him and he has to do more clipping or shaving?
15:29:40 * ddarius wonders how hard it actually is to shave a yak.
15:29:53 <jmcarthur> it's nice to be able to use a high level interface when you need to touch a shader even for simple things
15:29:54 <acowley> byorgey: can we rent a yak to shave at HacPhi?
15:29:59 * shachaf wonders whether "shaving a dead yak" is an idiom.
15:30:17 <pmetzger> not yet, no.
15:30:24 <pmetzger> but I'm sure you can make it into an idiom if you wish.
15:30:34 <acowley> jmcarthur: absolutely it can be nicer for development, but it probably won't be as nice as using CPU-hosted Haskel
15:30:35 <pmetzger> just make sure it satisfied the laws for the idiom typeclass. :)
15:30:35 <gwern> 'beating a naked yak'
15:31:25 <acowley> jmcarthur: so my concern is that if I'm going to bend over backwards for a 20x performance improvement, then I don't want to give up half that benefit up front
15:32:58 <acowley> beating a naked yak = attempting to reimpliment even lower level capabilities when you've already reached bottom?
15:33:20 <danharaj> my chief concern is reducing boilerplate. For example, my code gives you a way of loading shaders by specifying the attributes, uniforms, and samplers it uses. The way you do the specification is cumbersome though and I want to make it lighter weight.
15:33:40 <gwern> acowley: no, I was inventing a new sexual fetish. but if you want to interpret it as something programming, go ahead you perv
15:33:53 <danharaj> (I distinguish between samplers and other uniforms because they work differently)
15:34:13 <NihilistDandy> gwern: Hey, sweet thing, what's your object orientation?~
15:34:28 <gwern> NihilistDandy: contravariant - so I don't swing your way
15:34:34 <NihilistDandy> lol
15:36:47 <jmcarthur> acowley: high level doesn't necessarily mean slow
15:36:55 <jmcarthur> or limited
15:37:11 <jmcarthur> but i need to go cook dinner
15:37:17 <navaati> example : haskell :D
15:37:23 <acowley> of course it doesn't
15:37:42 <danharaj> You need to be a wizard to make Haskell fast.
15:37:58 <danharaj> and by fast I mean competitive with C. Who cares if it's faster than all the other fat kids? :p
15:38:04 <acowley> but there is a presumption that a compiler (or danharaj in a wizard hat) will efficiently map your abstractions onto the hardware.
15:38:27 <danharaj> I actually have one of those from Disney World. I can put it on if it makes this better for you.
15:38:38 <edwardk> acowley: you can get a decent enough win to make it worth doing even with just an apprentice ;)
15:38:40 <NihilistDandy> It's like a racing stripe
15:38:51 <acowley> and most of us trying to write things that generate GLSL from a more Haskelly DSL are just trying to get things to work
15:39:36 <edwardk> and yeah there are far too many of us hacking on various opencl, glsl, cuda, etc. dsl bindings for haskell at this point
15:39:51 <acowley> edwardk: Admittedly this is my own yak-shaving proclivity coming to light, I just find this a particularly egregious inefficiency
15:40:04 <acowley> I typically want to use the GPU in a very specific place
15:40:09 <edwardk> NihilistDandy: or red paint
15:40:21 <danharaj> hey, red ones do go faster. insurance companies agree.
15:40:50 <navaati> bye
15:41:38 <Kaidelong> I think they agree that people think that they go faster
15:41:43 <edwardk> i wind up throwing a lot of different workloads at the gpu
15:41:51 <Kaidelong> which is as different from that as an IO Int is different from an Int
15:42:32 <acowley> edwardk: and what API do you favor for doing so?
15:44:07 <edwardk> acowley: my current approach abuses observable sharing and a rank 2 type to try to let me compile as much buffer manipulation in a mutable fashion as possible. api wise, i'm partial to directcompute because it gets the hell out of my way, but opencl won't be bad if apple can make it stick
15:44:30 <acowley> In my (almost certainly more limited) experience, one can write reasonable pixel shader code in GLSL that has the advantage of being more readable to anyone familiar with shading languages and more in common with the detailed examples provided by GPU vendors
15:45:07 <edwardk> glsl is a passable lingua franca, but the performance of dynamically compiling it over and over is pretty hideous in windows
15:45:34 <edwardk> it works fine if you don't recompile all the time though
15:45:36 <djahandarie> edwardk, hey, thanks for uploading that stuff!
15:45:38 <edwardk> or on a mac, etc.
15:45:45 <djahandarie> Spivak talk was awesome
15:45:54 <shachaf> Spivak talk?
15:46:00 <acowley> edwardk: admittedly all my use cases have been compile-once
15:46:02 <edwardk> djahandarie: no problem. i have a couple of other scala talks as well, but i'm not in a hurry to babysit my internet connection for another 7 hours ;)
15:46:23 <acowley> Oh yea, I'm looking forward to watching both those talks when I get a chance
15:46:25 <shachaf> edwardk: Why does uploading require babysitting?
15:46:28 <djahandarie> shachaf, http://www.youtube.com/watch?v=wJIpI0Fj6Hg
15:46:28 <edwardk> schroedinbug: http://www.youtube.com/user/edwardkmett?feature=mhum
15:46:39 <shachaf> Oh, to that website.
15:46:47 <djahandarie> Or http://www.youtube.com/playlist?p=6FCB2ACD5E2082D9
15:46:50 <acowley> copumpkin's been on such an Agda tair of late, I'm looking forward to his take on an intro
15:47:02 <djahandarie> He hates his intro for some reason
15:47:07 <djahandarie> I'm watching it right now and it seems fine to me :p
15:47:14 <edwardk> i enjoyed it
15:47:14 <acowley> so much for my optimism
15:47:37 <NihilistDandy> Well, that's my evening set, then
15:48:15 <djahandarie> Spivak talk might be a little hard to follow without being familiar with CT
15:48:21 <djahandarie> He introduces it all but moves fast
15:48:29 <edwardk> i have a talk by alexandre bertails on DSLs in Scala and one by Apocalisp on Functional Programming in Scala that i'll also upload, but neither is likely to be earthshattering new stuff to anyone hacking in Haskell
15:48:36 <acowley> djahandarie: do you have any at your fingertips any examples of fusion in Haskell offering a big speedup beyond the natural deforestation provided by lazy evaluation?
15:48:36 <NihilistDandy> djahandarie: Math major with an independent interest in CT
15:48:44 <NihilistDandy> :)
15:48:46 <edwardk> yeah spivak was kind of egged on by a very CT savvy audience
15:49:01 <djahandarie> edwardk, haha, who was that guy sitting to your left btw?
15:49:05 <NihilistDandy> That's actually what drew me to Haskell
15:49:33 <edwardk> scruffy beard you could see when i spun the camera around to get to the whiteboard in frame?
15:49:41 <dons> acowley: its a huge deal with strict structures
15:49:49 <dons> acowley: e.g. vectors or other array types
15:49:53 <edwardk> djahandarie: Alec Heller
15:50:01 <djahandarie> edwardk, the guy who was asking questions while Spivak was on the whiteboard
15:50:02 <djahandarie> Okay
15:50:04 <dons> and it reduces memory traffic a lot for lazy structures with heap allocated cells
15:50:16 <dons> acowley: chek the stream fusion papers (bytestring, vector and lists)
15:50:50 <djahandarie> acowley, see what dons' said in the case of non-branching structures. I'm not sure about any examples for fusion of other Mu-recursive types
15:50:52 <acowley> dons: Right, but the usual motivation in, say, Wadler, is something like a sum over a list: the prototypical cata . ana
15:50:57 <edwardk> yeah the peanut gallery was pretty much me, ddarius, alec, and copumpkin, plus a much quieter silent majority that let us railroad things in directions that were interesting to us ;)
15:51:17 <NihilistDandy> Where was this talk?
15:51:20 <acowley> and in those cases, it's just the individual per-cell heap roundtrip
15:51:26 <edwardk> NihilistDandy: BostonHaskell
15:51:32 <pastorn> acowley: hello
15:51:41 <edwardk> NihilistDandy: basically every couple of months we tend to get together and do a couple of hours of Haskell talks
15:51:43 <acowley> pastorn: hello!
15:51:43 <pastorn> acowley: i saw what you said about shader languages
15:51:48 <acowley> oh no
15:51:55 <acowley> I'm going to get a lot of heat over this!
15:51:55 <djahandarie> Speaking of Boston Haskell... I wonder if we can get dons to show up ;) Maybe for the hackathon
15:51:56 <NihilistDandy> edwardk: Might have to try to make it down to one of those.
15:52:02 <pastorn> i just wanted to say that that's what i'm aiming for with the new OpenGL
15:52:14 <edwardk> NihilistDandy: where are you coming from?
15:52:19 <pastorn> keeping GLSL as it is, just modifying the rest
15:52:26 <acowley> pastorn: I'm very glad to hear it!
15:52:29 <danharaj> hell throw out the rest
15:52:36 <shachaf> djahandarie: Wait, there's a hackathon in Boston now?
15:52:37 <dons> acowley: laziness gets you a big win, already, certainly
15:52:45 <dons> for lazy data structures, fusion cleans up the final overhead
15:52:45 <danharaj> Just keep loading buffer and texture data, and setting relevant modes :)
15:52:46 <djahandarie> shachaf, vague talk of one
15:52:46 <NihilistDandy> Well, I'm in NH at the moment, but I'll either be in Amherst, MA or Burlington, VT by August
15:52:51 <dons> for strict structures, its essential
15:52:53 <Eduard_Munteanu> Less C++ ugly cruft.
15:52:54 <edwardk> shachaf: leaning towards one for the end of the year or early next
15:52:54 <acowley> djahandarie: come to HacPhi
15:53:02 <djahandarie> acowley, yep, I plan on going
15:53:05 <Eduard_Munteanu> oops, I was waaay scrolled up
15:53:24 <acowley> dons: thanks, that matches my understanding
15:53:27 <edwardk> shachaf: there was going to be one right before i took over as organizer for boston haskell, but ravi wandered off to singapore and it kinda fell apart during the confusion
15:53:50 <edwardk> then i started autocratically declaring when meetings would be and things got organized again
15:53:53 <NihilistDandy> :D
15:54:29 <edwardk> djahandarie: vague mostly because i'm trying to juggle how to get the space, money and wifi simultaneously
15:54:40 <NihilistDandy> I'll lobby with the CS and Math departments wherever I end up and see if some Haskell talks could be arranged. :D
15:54:46 <shachaf> Space, money, wifi: Pick any two.
15:55:04 <acowley> there's wifi in space?
15:55:18 <edwardk> acowley: if you have enough money, yes ;)
15:56:01 <acowley> wardriving from the ISS must be tricky
15:56:16 <NihilistDandy> I dunno, it's satellite adjacent
15:56:39 <acowley> Oh, good point, I was more worrying about them ganking my bandwidth
15:56:51 <edwardk> i think i can get clarifi to fund it, so its mostly just trying to figure out how we can get wifi out of mit, or finding another venue. the akamai guys across the way had volunteered to host us for the normal sessions, but i haven't approached them about commandeering their conference room and wifi for days on end
15:57:54 <djahandarie> Can't we just find one person with access to the wifi and then tunnel through his connection? :p
15:58:02 <edwardk> acowley: well, not sure. a good directional antenna and you should be good. its not like you have many obstructions, and there is no atmospheric attenuation
15:58:25 <edwardk> djahandarie: as everyone tries to get on through my jailbroken iphone
15:58:37 <djahandarie> Haha
15:58:40 <djahandarie> Sounds like a good time
15:58:41 <acowley> including the dudes in space
15:59:42 <NihilistDandy> I wonder if there's an Agda bundle for TextMate
15:59:50 <djahandarie> ...highly doubt that
16:00:15 <shachaf> djahandarie: Well, there's an emacs mode. :-)
16:00:28 <edwardk> i'll follow up with akamai and see where that goes
16:01:50 <edwardk> and then once we have a better idea of when we can make it work i can chase down hotel discounts, and make it more official
16:03:06 <edwardk> gotta run
16:04:01 <rata_> how can I compute the index of the first element of a list for which a predicate is true? is there a built-in function for that?
16:04:38 <acowley> findIndex
16:05:27 <acowley> hoogle knows this, even if you don't guess the type exactly
16:06:07 <gwern> so, has anyone here used haskell-src-exts? I was thinking of using it to parse .hs/.lhs, and see whether a function name is used (but not defined), and print out the usage and some context
16:06:47 <ohday> hi guys
16:06:57 <ohday> i started learning c a couple of years back and never quite "got it"
16:07:09 <ohday> ive been hearing nice and interesting things about haskell and its community
16:07:16 <rata_> thahnk you acowley =) that's exactly what I needed
16:07:23 <NihilistDandy> Hi, ohday
16:07:38 <ohday> about how much of a powerful language it is, and how it is easy to transition your thought pattern to code without much change
16:07:57 <ohday> now, i started c about 5 years ago, but never got it, and just play around as a user now (meaning i dont write programs)
16:08:02 <hpc> ohday: is there a question in there? we already know how awesome we are :P
16:08:12 <ohday> should i just dive into haskell? and can i expect to learn the language and be useful quickly (really wanna do things asap)
16:08:19 <ohday> hpc: ^
16:08:27 <acowley> rata_: np! You should give hoogle a try for this kind of thing, it's a fantastic tool
16:08:37 <NihilistDandy> ohday: Yeah, sure.
16:08:38 <hpc> ohday: yes, and maybe
16:08:43 <NihilistDandy> What do you have to lose?
16:08:52 <ohday> im not good at math, and i hear that its centered around mathematicians?
16:09:02 <hpc> @where lyah
16:09:02 <lambdabot> http://www.learnyouahaskell.com/
16:09:06 <hpc> ohday: ^ is amazing
16:09:15 <ohday> hpc: been reading tht
16:09:18 <NihilistDandy> hpc: Have you gotten the hardcopy, yet? :)
16:09:21 <ohday> some bits confuse me
16:09:22 <hpc> yes :D
16:09:34 <dons> ohday: hmm. around programmers, mostly open source programmers
16:09:37 <acowley> ohday: that some mathematicians find it suitable doesn't make it less useful for the rest of us
16:09:40 <NihilistDandy> hpc: So good. Best explanation of monads I've ever seen
16:09:42 <dons> but we have proportionally more fans of math than most communties
16:09:55 <NihilistDandy> hpc: Well, for certain values of "best"
16:09:57 <Jafet> Who are unwittingly dragged into mathematics
16:10:02 <ohday>  Say you have an im- mutable list of numbersand a functionwhich multiplies every element by 2 and then returns a new list. If we wanted to multiply our list by 8 in an imperative language and did, it would probably pass through the list once and make a copy and then return it. Then it would pass through the list another two times and return the result. In a lazy language, callingon a list without forcing it to show you the result ends up in the program sor
16:10:09 <ohday> that confuses me
16:10:12 <ohday> dons: huh
16:10:21 <ohday> acowley: ok then
16:10:31 <hpc> ohday: "ends up in the program sor..."
16:10:47 <ohday> hpc: ?
16:10:51 <ohday> hpc: that is from lyah
16:10:51 <hpc> ohday: got cut off
16:11:03 <NihilistDandy> > map (*2) [1..10]
16:11:04 <ohday> hpc:  Say you have an im- mutable list of numbersand a functionwhich multiplies every element by 2 and then returns a new list. If we wanted to multiply our list by 8 in an imperative language and did, it would probably pass through the list once and make a copy and then return it. Then it would pass through the list another two times and return the result. In a lazy language, callingon a list without forcing it to show you the result ends up in the progra
16:11:04 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
16:11:14 <hpc> still cut off
16:11:24 <hpc> ill find it
16:11:33 <acowley> ohday: where are you pasting from?
16:11:36 <ohday> hpc: http://codepad.org/cLKZxutq
16:11:38 <ohday> acowley: lyah
16:11:53 <hpc> http://learnyouahaskell.com/introduction
16:11:53 <ohday> acowley: first chapter
16:11:55 <ohday> ya
16:11:57 <DasIch> ohday: in a non-lazy language the entire list would be computed by each function processing the list
16:11:58 <Jafet> Wouldn't it be a lot lazier to just mention the chapter and section?
16:12:01 <hpc> search for doubleMe(d
16:12:26 <DasIch> ohday: in haskell that doesn't happen due to it's laziness
16:12:27 <ohday> DasIch: i implemented it in c (took about 10 full minutes, is how bad i am :/ )
16:12:30 <hpc> ohday: so say we have a list [1..]
16:12:42 <hpc> ohday: we want to multiply each element by two, so we do so
16:12:49 <NihilistDandy> ohday: Isn't it just a for loop in C?
16:12:50 <hpc> ohday: now we have a thunk
16:13:00 <DasIch> ohday: this allows you awesome things such as infinite data structures
16:13:10 <hpc> ohday: a thunk is a "calculate me when you need to" structure
16:13:32 <ohday> NihilistDandy: http://codepad.org/rveuOmjr
16:13:38 <ohday> hpc: hmm
16:13:40 <hpc> ohday: and as you repeatedly multiply each element by two, the thunk isn't "calculate the list, then the next list..."
16:13:51 <ohday> ooh
16:13:57 <rata_> acowley: I'll do it, thanks
16:13:59 <hpc> ohday: the thunk is "calculate the first element of the final list, ..."
16:14:09 <ohday> that's madness!
16:14:34 <ohday> i need more resources
16:14:39 <ohday> going in for the long haul
16:14:54 <NihilistDandy> Okay, either my C is rusty as hell, or I don't quite follow your code for some other reason
16:15:09 <ohday> NihilistDandy: im probabbly just shit in c
16:16:09 <DasIch> it's fine as far as i can see
16:16:19 <hpc> ohday: the implementation is rather clever, actually; the unevaluated thunk is a pointer to the function that evaluates the thunk and returns the value
16:16:29 <hpc> ohday: an evaluated thunk is a pointer that just returns that value again
16:16:34 <hpc> ohday: but that's extra credit ;_
16:16:36 <hpc> ;)
16:16:38 <ohday> well, it took me about 10 full minutes to get that working right, without looking online or anything. so judge my expertise from that :p
16:16:55 <ohday> hpc: a pointer returning a value?
16:17:18 <hpc> ohday: er, pointer to a function that just returns the value
16:17:34 <hpc> ohday: it's always a function pointer, but it modifies itself to use the precomputed value :D
16:17:44 <Jafet> The details can be found in the STG papers, but that's the honors class.
16:17:55 <ohday> hpc: just got ghc The Glorious Glasgow Haskell Compilation System, version 7.0.3
16:17:58 <ohday> :D :D :D
16:18:14 <ohday> Jafet: stc paper?
16:18:15 <hpc> who came up with that name, actually?
16:18:18 <hpc> it is a magnificent name
16:18:33 <NihilistDandy> ohday: Just GHC, or did you get the whole Haskell Platform/
16:18:34 <NihilistDandy> *?
16:18:34 <Jafet> Well, it started out as just the G-machine I think
16:18:43 <ohday> Jafet: hpc: other than lyah, what other resources should i keep handy?
16:18:50 <hpc> @where hoogle
16:18:51 <lambdabot> http://haskell.org/hoogle
16:18:53 <hpc> @where wikibook
16:18:53 <lambdabot> http://en.wikibooks.org/wiki/Haskell
16:18:55 <ohday> NihilistDandy: i got the haskell platform, and ghc
16:18:56 <hpc> @where rwh
16:18:56 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:19:14 <ohday> hpc: so i should read both books?
16:19:18 <hpc> the wikibook and rwh will fill in details that lyah might leave out
16:19:25 <ohday> ah
16:19:26 <Jafet> ohday: you can read those a bit later.
16:19:29 <vikingly> Hi guys! A quick question. I'd like to express datalog-like queries and rules, and wonder if there is a haskell framework with datalog-like properties.
16:19:32 <ohday> in conjunction where i find myself confused
16:19:32 <hpc> and hoogle is a search engine for haskell functions
16:20:13 <ohday> lol
16:20:15 <ohday> you guys
16:20:22 <ohday> looks like i'll have to buy rwh
16:20:28 <ohday> can't get a free epub/kindle ver
16:20:56 <ohday> hate using the ipad browser for these things and i'm never home long enough to use the desktop (dont hve a laptop)
16:21:06 <ohday> but i do ssh into a terminal to use ghci and irssi
16:21:12 * ohday thinks
16:21:40 <hpc> rwh is kind of a reference, more than a book
16:22:02 <hpc> it's something i would read a chapter at a time, in not even remotely the intended order
16:22:04 <NihilistDandy> Gives a couple of neat projects, too
16:22:42 <hpc> lyah should be your main focus; the order in which it introduces concepts is impeccable
16:22:44 <ohday> lol theres a twitter for rwh
16:22:48 <ohday> are you guys on twitter too?
16:22:57 <ohday> hpc: yeah, im on chapter two of it
16:23:03 <Eduard_Munteanu> I have a question on verified software that really bugs me: in stuff like seL4, is the C implementation machine-checked against the proof and upper layer? If so, how? :)
16:23:24 <Jafet> Apparently, the proof is written in isabelle or something
16:23:35 <ohday> hpc: guess ill go back to it then
16:23:47 <ohday> beats learning ruby, and being bored by the same old story
16:24:06 <ohday> i've tried to learn python and ruby and just dropped it because i didn't have any real reason other than wanting to learn a language
16:24:10 <ohday> even perl
16:24:16 <ohday> but i think haskell might be the one
16:24:20 <rata_> when I have a function that returns IO [State], how can I generate the list without storing the whole list in memory to benchmark the function?
16:24:20 <ohday> the one language to rule them all :P
16:24:23 <ohday> kk ttyl
16:24:44 <Eduard_Munteanu> Yeah, Isabelle/HOL.
16:25:11 <Jafet> The checking should be automatic then
16:25:11 <Eduard_Munteanu> But I just don't see how the C code can be machine-checked, unless a really special compiler is used.
16:25:27 <acowley> Perhaps a subset of C is used?
16:25:41 <acowley> that essentially identifies a DSL whose semantics are consistent with a subset of C
16:25:45 <mornfall> LYAH is the same as learnyouahaskell.com? (I remember LYAH differently, from awhile back...)
16:25:51 <nazgjunk> it is
16:25:56 <cubi> ?lyah
16:25:56 <lambdabot> Unknown command, try @list
16:26:00 <mustapha> mornfall: Differently how?
16:26:04 <mornfall> Dunno. :)
16:26:08 <Eduard_Munteanu> Hrm, and from which you can extract pristine C.
16:26:10 <acowley> mornfall was younger then
16:26:13 <Eduard_Munteanu> That sounds doable.
16:26:17 <Jafet> I might be guessing here, but it might use a compiler like compcert.
16:26:18 <cubi> this command used to work :v
16:26:21 <nazgjunk> @where lyah
16:26:21 <lambdabot> http://www.learnyouahaskell.com/
16:26:25 <cubi> ah yeah
16:26:28 * djanatyn just checked out a copy of "Real World Haskell" from the library
16:26:29 <cubi> stupid me :)
16:26:30 <Eduard_Munteanu> I wish seL4 source was public :(
16:26:36 <mustapha> mornfall: It was more or less a series of tutorials Boxo wrote (it was in BETA for a few years), until nostarch published it, iirc.
16:26:36 <mornfall> No print edition, for one. And definitely don't remember it as big enough to cover 400 pages.
16:26:37 <djanatyn> I also got Learning GNU Emacs, and Programming perl.
16:26:38 <hpc> λbot has so many command characters
16:26:44 <djanatyn> But that's for a different channel :)
16:26:48 <mustapha> s/Boxo/BONUS/%g
16:26:54 <nazgjunk> djanatyn: .. uni library, I'll assume
16:27:02 <djanatyn> nazgjunk: nope
16:27:04 <djanatyn> public library
16:27:09 <mustapha> djanatyn: Well, Perl is a hideous language, meant for space monkeys.
16:27:14 <rata_> how can I generate a list but forget about its elements as soon as they are computed?
16:27:16 <djanatyn> mustapha: Woah, watch your mouth ;)
16:27:20 * djanatyn plans on becoming a sysadmin.
16:27:22 <nazgjunk> I wish my public library had an awesome collection like that.
16:27:26 <mustapha> djanatyn: And, I'm mildly impressed with the emacs haskell-mode
16:27:36 <Jafet> rata: traverse it only once.
16:27:41 * mornfall is mildly underimpressed OTOH
16:27:42 <mustapha> nazgjunk: There's usually a suggestion box near the entrance.
16:27:48 <nazgjunk> not here >.>
16:27:49 <Jafet> (And lose all references to the head)
16:28:00 <djanatyn> mustapha: I don't like emacs, particularly.
16:28:12 <mustapha> djanatyn: Why not?
16:28:25 <djanatyn> I use vim every day, and I'm just trying to expand my horizons (like I did with Haskell!)
16:28:25 <Eduard_Munteanu> Jafet: compcert is just a certified compiler, as in "hey, we wrote it in Coq", isn't it?
16:28:30 <djanatyn> mustapha: Too complicated to learn :P
16:28:38 <djanatyn> I'm already *very* happy with the simplicity of vim.
16:28:45 <djanatyn> I also have a good operating system :D
16:28:51 <Eduard_Munteanu> In that sense, I also have a certified Hello World written in Agda :P
16:28:52 <mustapha> djanatyn: So, you haven't managed to learn how to use it, and base your opinion on the fact that you're unable to?
16:29:14 <djanatyn> mustapha: I've used it before ;)
16:29:15 <Jafet> Eduard_Munteanu: well, that seems enough to provide an operational semantics for C.
16:29:18 <Eduard_Munteanu> But I'm not sure compcert checks C code against some specification.
16:29:20 <mornfall> Sadly, LYAH book is not exactly cheap. I'd so buy it as a present for my girlfriend...
16:29:33 <djanatyn> My main point is, I'm currently using vim, and I'm *very* happy with vim.
16:29:44 <djanatyn> I've used emacs, but I don't agree with the whole philosophy in general ;)
16:29:53 <djanatyn> I think it would be fun, and useful, to learn emacs.
16:29:54 <nazgjunk> mornfall: it's not terribly expensive, and if you get it from Starchfree directly you get the ebook versions too
16:29:57 <dons> $25 or so?
16:30:03 <dons> or has it gone up
16:30:04 <djanatyn> it was also give me an excuse to learn more Lisp.
16:30:04 <mornfall> More like 45.
16:30:10 <djanatyn> dons: I thought it was ~$50
16:30:11 <dons> ah, well, it was cheap for a while
16:30:18 <nazgjunk> It was cheap during pre-order, yeah
16:30:22 <dons> 40-50 seems standard for technical books these days
16:30:39 <shachaf> Which book?
16:30:41 <acowley> I thought emacs's philosophy was to be awesome
16:30:43 <djanatyn> Yeah. That's why I just came home from the library ;)
16:30:52 <djanatyn> acowley: I thought that was vim's!
16:31:17 <djanatyn> I'm not trying to start an editor war.
16:31:18 <shachaf> Editor wars go in #-blah.
16:31:30 <djanatyn> In fact, I'm trying to be impartial and I got a book on the editor I don't particularly like.
16:31:47 <djanatyn> so, instead of talking about my "Learning GNU Emacs" book, let's talk about my "Real World Haskell" book!
16:32:01 <djanatyn> I was learning about fold and map today. (mind = blown)
16:32:08 <pmetzger> learn you an emacs for great haskell.
16:32:13 <rata_> Jafet: does "do genList; return ();" accomplish that?
16:32:31 <Jafet> rata: uh, you don't want to use anything from the list at all?
16:32:40 <mornfall> Yi! It's only missing an integrated mail client.
16:32:42 <Jafet> That seems... a suspicious thing to do.
16:32:58 <acowley> Eduard_Munteanu: also bear in mind that certification is with respect to some properties
16:33:19 <mustapha> djanatyn: Using it doesn't mean you know how to use it.
16:33:30 <rata_> Jafet: no, I just want to benchmark it
16:33:31 <pmetzger> doesn't compcert claim that the output code has the same semantics as the C program fed in?
16:33:40 <pmetzger> or rather doesn't the proof claim...
16:33:47 <mustapha> djanatyn: I asked you why you didn't like it, you said it was too difficult to learn. You haven't stated what's wrong with it, only that you're unable to figure it out.
16:33:49 <Eduard_Munteanu> acowley: well, I'm assuming it's certified in the sense that it faithfully obeys the spec.
16:34:00 <djanatyn> There's nothing wrong with it o_o
16:34:01 <mornfall> pmetzger: As long as C has, and the output assembler has, any reasonable semantics. :)
16:34:06 <djanatyn> It's just that it doesn't fit with me.
16:34:24 <pmetzger> mornfall: naturally. if the c code writes random locations all is lost.
16:34:24 <djanatyn> emacs and vim are both great editors; this is off topic, and let's get back to our favorite topic, haskell :D
16:34:27 <Eduard_Munteanu> Not that it can't behave unexpectedly (say, if you bork the spec)
16:34:32 <acowley> Eduard_Munteanu: I just mean that a "Hello World" program in Agda might not be certified against a spec that specifies that the string "Hello World" never appear in memory
16:34:43 <Jafet> rata: criterion has some tools for this; else the good old deepseq or length.show
16:34:47 <mornfall> pmetzger: I was more thinking in terms of the formalism itself.
16:34:58 <djanatyn> frankly, if you're writing haskell with notepad, that's fine with me.
16:35:02 <mornfall> pmetzger: C is somewhat underspecified, at least concerning things like memory models.
16:35:14 <mornfall> pmetzger: And common CPUs aren't all that much better.
16:35:16 <pmetzger> C did not grow up in a world with threads.
16:35:26 <pmetzger> so memory models were less important
16:35:27 <pastorn> djanatyn: when i was taking "advanced functional programming" a guy on the mailing list said he was using wordpad...
16:35:28 <hpc> i think some of that was also deliberate
16:35:37 <djanatyn> pastorn: Okay, that's kind of extreme.
16:35:38 <hpc> wanting the language to be general
16:35:52 <nazgjunk> pastorn: that's both overpowered and underpowered for the job, neat
16:35:56 <pmetzger> anyone using wordpad for programming is a fool, but it isn't my problem.
16:35:59 <shachaf> pastorn: What's wrong with Wordpad?
16:36:10 <acowley> Write Haskell with a pen or pencil, scan it in, then OCR it.
16:36:15 <djanatyn> shachaf: Oh, you.
16:36:15 <pastorn> shachaf: hang on, let me just change that to italics 18 pt
16:36:17 <hpc> shachaf: it munges line endings
16:36:21 <dons> write it with pen and paper. done.
16:36:24 <dons> no need to compile it.
16:36:32 <shachaf> hpc: No, that's Notepad. Wordpad handles \n.
16:36:33 <dons> see: the oxford school.
16:36:34 <acowley> dons: version control
16:36:34 <hpc> among other things, apparently
16:36:42 <djanatyn> shachaf: There are many better alternatives.
16:36:44 <dons> acowley: you got multiple sheets of paper for a reason
16:36:45 <dons> ;)
16:37:04 <djanatyn> It's not even a matter of taste, like emacs vs. vim. There are some features in other editors that Wordpad simply does not have - syntax highlighting, for example.
16:37:05 <NihilistDandy> And photocopies and faxes
16:37:06 <mornfall> dons: A monk or two would help.
16:37:11 <djanatyn> It's like...using sed to write Haskell code.
16:37:11 <monochrom> if you don't erase what you wrote, you get version control for free
16:37:18 <djanatyn> You could do it. Do you really want to?
16:37:23 <pmetzger> highlighting is not important.
16:37:24 <acowley> actually, Conor McBride uses transparencies for version control to great effect
16:37:26 <shachaf> djanatyn: No, ed. And people used ed for years.
16:37:28 <pmetzger> editor macros are important.
16:37:30 <dons> i think jeremy gibbons and ralf hinze have monks to help him.
16:37:32 <nazgjunk> heh, version control by strikethrough
16:37:34 <NihilistDandy> djanatyn: Why the obsession with editors?
16:37:37 <pmetzger> auto indent is important
16:37:37 <NihilistDandy> Just use one that works
16:37:42 <NihilistDandy> It's just text
16:37:42 <djanatyn> NihilistDandy: I don't have an obsession with editors -_-
16:37:44 <DasIch> dons: mailing people those hand written diffs is a pain in the ass though :/
16:37:46 <mornfall> Editors.
16:37:53 <djanatyn> I just got a conversation started when I said I got a book on emacs :D
16:37:55 <mornfall> Someone did mention #-blah already. :P
16:37:57 <monochrom> gibbons and hinze have grad students, better than monks :)
16:38:03 <djanatyn> What I REALLY want to talk about it "Real World Haskell" :\
16:38:10 <NihilistDandy> Then talk about that
16:38:10 <monochrom> anyway I use notepad++ when in windows
16:38:10 <dons> DasIch: you have to publish the diffs as "corrections"
16:38:13 <djanatyn> *and* foldr and map
16:38:26 <pmetzger> anyone who doesn't get why you would use a real editor hasn't used one. you're simply not as productive without a real editor.
16:38:31 <pmetzger> vi or emacs are both fine editors
16:38:32 <djanatyn> I was working on the Project Euler problems in Haskell today
16:38:35 <pmetzger> notepad is not.
16:38:37 <NihilistDandy> monochrom: Check out Sublime Text, as well. It's very nice
16:38:49 <NihilistDandy> djanatyn: I've been doing that, too
16:38:58 <dons> if you're not using vim, emacs or an established IDE, people probably won't take you seriously in the programming industry.
16:38:58 <NihilistDandy> Which one are you on?
16:38:59 <monochrom> I don't actually use windows seriously enough to need any better editor
16:39:03 <djanatyn> NihilistDandy: 3? :)
16:39:06 <djanatyn> I'm not very good at Haskell.
16:39:17 <pmetzger> dons: who cares about being taken seriously, you won't get as much work done.
16:39:19 <Eduard_Munteanu> monochrom: there's Vim for windows, even portable versions
16:39:20 <djanatyn> I'm also attempting the problems in both Python, *and* Haskell
16:39:26 <dons> pmetzger: well, there's that obvious fact too
16:39:35 <bos> preflex: seen Baughn
16:39:35 <preflex>  Baughn was last seen on #haskell 14 days, 15 hours, 50 minutes and 15 seconds ago, saying: ..that's still most of them
16:39:38 <NihilistDandy> djanatyn: I'm trying to do them in Haskell and by hand
16:39:43 <shachaf> Project Euler won't help you learn a programming language much.
16:39:43 <NihilistDandy> Where possible, that is
16:39:57 <djanatyn> shachaf: Well, it's still a lot of fun and reinforces what you already know.
16:40:03 <hpc> PE will teach you number theory
16:40:08 <djanatyn> It's applying your knowledge in a practical situation :D
16:40:09 <hpc> and that's pretty much it
16:40:11 <bos> anyone know who maintains haskell-mode for emacs these days, or where the repo is?
16:40:11 <pmetzger> I taught a class on Unix as a programming environment to freshmen about a year ago. I spent part of the first class explaining the difference between professional tools and amateur tools.
16:40:28 <dons> nice
16:40:28 <hpc> pmetzger: :D
16:40:41 <NihilistDandy> djanatyn: Don't you dare call PE "practical" :P
16:40:44 <pmetzger> There is a reason that a professional stove is not the same as a home stove, and it doesn't matter that the home stove looks much prettier.
16:40:46 <djanatyn> wait, wait, wait
16:40:47 <bos> amateur tools - "stuff i can't stand". professional tools - "stuff i grudgingly tolerate".
16:40:48 <dons> bos: google doesn't find it I guess? has it gone missing?
16:40:52 <djanatyn> tensorpudding: ...do you play Nethack?
16:41:04 * djanatyn hates to get off topic - just answer yes or no :)
16:41:04 <Axman6> is there a more efficient data structure in haskell than a Sequence if you're treating it strictly as a queue? (ie, pushing onto the pack, pulling from the front)
16:41:06 <bos> dons: google finds a lot of junk for it
16:41:09 <dons> hmm
16:41:18 <pmetzger> there is a reason that an amateur's woodworking tools are a joke to a professional cabinetmaker.
16:41:20 <hpc> NihilistDandy: hey, you never know when someone will say "i want the billionth prime number; you have a week"
16:41:23 <djanatyn> NihilistDandy: You get points :)
16:41:28 <pmetzger> and it makes no difference how pretty they are.
16:41:32 <dons> Axman6: there's structures that are more efficient by constant factors
16:41:32 <djanatyn> and geek points.
16:41:41 <bos> dons: baughn is allegedly the maintainer, but the code hasn't been touched in ages
16:41:45 <f> where can i find exemplary/good/ninja haskell code to read?
16:41:50 <bos> and i don't know who baughn is
16:42:01 <NihilistDandy> hpc: lol. And then I got fired~
16:42:04 <shachaf> pmetzger: So you taught people to use ed, yes?e
16:42:07 <Axman6> f: Xmonad is usually given as an example of well written haskell
16:42:08 <dons> http://projects.haskell.org/haskellmode-emacs/ ?
16:42:09 <hpc> Axman6: a difference list perhaps?
16:42:11 <pmetzger> shachaf: no.
16:42:21 <NihilistDandy> djanatyn: We should compare notes some time :D
16:42:26 <pmetzger> shachaf: but ed users were much more productive than many people using early screen editors
16:42:38 <pmetzger> shachaf: because ed is a well thought out tool, and the early screen editors weren't.
16:42:42 <hpc> Axman6: where instead of composing with (++), you compose with (:)
16:42:46 <hpc> or something
16:42:51 <thoughtpolice> bos: http://code.haskell.org/haskellmode-emacs/ is it i believe
16:42:54 <dons> yeah, looks like the july 2010 was the last release
16:42:57 <hpc> er
16:42:59 <hpc> nvm
16:43:02 <pmetzger> shachaf: I knew someone using ed day to day as late as about 1989.
16:43:09 <hpc> difference list will work
16:43:12 <bos> dons: thoughtpolice - yeah, i was suspicious of that because it looks dead
16:43:16 <dons>   http://projects.haskell.org/pipermail/haskellmode-emacs/2010-July/000050.html
16:43:24 <mornfall> Seems that I need to update haskell-mode in Debian. :(
16:43:26 <pmetzger> shachaf: he was more or less as productive as the rest of the team in terms of output, and it was a very good team.
16:43:27 <Axman6> hmm, possibly for what I'd be using, a list and using reverse would be fine. if i were to write this in haskell, I'd be doing all the enqueuing before dequeuing
16:43:29 <hpc> read from the front, and append to the back as a continuation
16:43:39 <f> Axman6: it fit in exemplary good or ninja?
16:44:00 <Axman6> since i have no idea what you mean by 'ninja', i have no idea
16:44:08 <Jafet> Axman6: this was one of the textbook examples in PFDS
16:44:13 <f> very very good
16:44:31 <Jafet> Or was it a deque...?
16:44:35 <Axman6> f: what do you consider to make code very very good?
16:44:45 <shachaf> pmetzger: Makes sense. I would take that to mean that editors don't matter that much, as long as they don't get in your way.
16:44:45 <pastorn> Are haskell implementations required to do tail call optimization (according to Haskell98)?
16:44:50 <pmetzger> gah. the world would be better with 1/10th the number of available monad tutorials and it needs them to be 10x as good.
16:44:56 <pmetzger> shachaf: no. ed is a very good editor.
16:45:00 <kfish> morning all
16:45:03 <pmetzger> shachaf: editors matter a lot.
16:45:05 <dons> pastorn: there's nothing in the standard that says anything about how to execute, other than to be non-strict
16:45:05 <Axman6> Jafet: yeah, i seem to remember reading something about that... might have been a concurrent queue though...
16:45:19 <Axman6> morning kfish
16:45:22 <hpc> pastorn: i understand TCO isn't required nor even implemented directly
16:45:30 <Eduard_Munteanu> I wish Vim could do what Emacs does to Agda.
16:45:30 <hpc> pastorn: but a logical site-effect of other things
16:45:30 <f>  Axman6: the question is to find out that
16:45:34 <Jafet> pastorn: Haskell implementations aren't even required to be lazy...
16:45:36 <shachaf> pmetzger: Plenty of people use gedit or whatever editor perfectly well.
16:45:45 <Jafet> Though every sensible implementation is.
16:45:46 <dons> pastorn: e.g. you could use O(n) memory and fork a thread on every function call, and be happily parallel and compliant with the spec
16:45:56 <pmetzger> shachaf: I know many people who write PHP code for a living too. If you can call it living.
16:46:16 <NihilistDandy> ^ you can't
16:46:16 <pastorn> dons: yay! what i always wanted to do!
16:46:17 <hpc> pmetzger: i wouldn't mind a job like that, if it was laid back enough
16:46:26 <Axman6> f: well do you consider it to be code that it as short as possible? code that's as clear as possible? code that's provably correct? there are many different criteria
16:46:27 <shachaf> Plenty of people use gedit and write good code productively perfectly well.
16:46:31 <hpc> get paid thousands of dollars a year to troll the java community
16:46:40 <dons> hpc: it is implemented directly in ghc via the TailCalls.h fun fun header module
16:46:43 <djanatyn> Today, I wrote the code for a fibonacci number calculator using recursion!
16:46:46 * shachaf thinks #haskell-blah would be a better place for discussing that.
16:46:47 <Eduard_Munteanu> Thousands a year? Sounds pretty low :)
16:46:52 <djanatyn> And the code for a factorial by messing with that code
16:46:55 * hackagebot cityhash 0.0.1 - bindings to Google CityHash  http://hackage.haskell.org/package/cityhash-0.0.1 (AustinSeipp)
16:46:56 <hpc> Eduard_Munteanu: didn't say how many thousands :D
16:47:03 <djanatyn> Then I found out my almost *exact* same code was in LYAH
16:47:06 <shachaf> djanatyn: Does it work for numbers greater than 30?
16:47:28 <danharaj> http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
16:47:31 <hpc> djanatyn: fibonacci numbers are a passtime here
16:47:32 <djanatyn> shachaf: It does indeed.
16:47:35 <hpc> @quote fib
16:47:35 <lambdabot> lament says: category theory is just a fibered coproduct of the epimorphic functors in the category of categories of monoidal categories enriched with calcium
16:47:40 <hpc> @quote fib
16:47:40 <lambdabot> Catfish_Man says: Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
16:47:44 <f> axman6; can't be a mix? I want to know what people consider to be really good, to learn something
16:47:47 <Jafet> @quote undoubtedly
16:47:47 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
16:47:50 <djanatyn> I could put mine on hpaste.org, but you can probably already guess what it is
16:47:59 <pmetzger> if one doesn't understand why gedit is not a programmer's editor, well, I think most of my students got that within a few weeks. A good editor is programmable, it will allow you to refactor code at high speed.
16:47:59 <hpc> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
16:47:59 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:48:02 <pmetzger> a bad editor will not.
16:48:07 <shachaf> djanatyn: That?
16:48:16 <djanatyn> shachaf: No way. I haven't gotten to zip yet
16:48:50 <NihilistDandy> I've been trying to get into using yi, but hacking together the keymap is time-consuming
16:49:04 <mornfall> djanatyn: I would guess it has horrible complexity.
16:49:09 <Axman6> f: there is lots of code that demonstrates all those traits, there's lots of code that demonstrates some of them, and is horribly bad with respect to the others. I would suggest you have a look at some of the base library, since it's fairly well reviewed so the code meets a certain fairly high standard
16:49:26 <djanatyn> mornfall: not really
16:49:28 <djanatyn> I'll paste it
16:49:56 <mornfall> NihilistDandy: Indeed.
16:50:57 <NihilistDandy> It looks like a perfectly serviceable editor --- I'd be willing to say a cut above Emacs, even --- I just can't devote the time :D
16:51:11 <mornfall> NihilistDandy: You aren't a Dvorak user by any chance?
16:51:13 <Axman6> f: if you want examples of fast code, pretty much anything written by dons is a good place to start =)
16:51:29 <f> Axman6 : well, i think i would be more interest in idiomatic code
16:51:45 <Axman6> then look in the base libraries
16:51:45 <NihilistDandy> mornfall: Not at the moment, but I've been considering picking it up. I'd just have to click a button to change my layout
16:51:55 <f> axman6, uses of thinks defined in the base libraries
16:51:57 <Axman6> well, those are somewhat optimised as well
16:52:23 <mornfall> NihilistDandy: I was asking since I could use a modal yi keymap for Dvorak. :P
16:52:35 <f> like "look, it uses arrow/transversable/idiom/.... !"
16:52:58 <mornfall> Hm. Apparently I have an approximation of that already.
16:52:59 <tswett> > let [x,y] = [ (1 + n*sqrt 5)/2 | n <- [1, -1] ] in map (\n -> x^n ++ y^n) [0..]
16:52:59 <mornfall> Let me see.
16:53:00 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:53:00 <lambdabot>    `GHC.Float.Floating t'
16:53:00 <lambdabot>  ...
16:53:11 <tswett> Stupid ambiguous type variables.
16:53:22 <NihilistDandy> mornfall: Don't hesitate to hpaste it :D
16:53:30 <djanatyn> coi tswett
16:53:33 <Axman6> tswett: ++?
16:53:39 <tswett> coi djanatyn
16:53:39 <mornfall> NihilistDandy: Seems that I actually made it by patching the yi sources, not in my yi.hs.
16:53:50 <tswett> (We are greeting each other in our cant.)
16:53:51 <mornfall> Which turned out to be beyond my capacity.
16:54:03 <tswett> Axman6: hm, maybe ++ isn't what I wanted here.  :P
16:54:13 <NihilistDandy> mornfall: Interesting strategy to say the least
16:54:19 <Axman6> no... either + of a tuple...
16:54:26 <tswett> Real numbers *are* a monoid, though, aren't they?  :P
16:54:36 <tswett> > let [x,y] = [ (1 + n*sqrt 5)/2 | n <- [1, -1] ] in map (\n -> x^n + y^n) [0..] :: [Float]
16:54:37 <lambdabot>   [2.0,1.0,3.0000002,4.0000005,7.0000005,11.000001,18.000004,29.000006,47.000...
16:54:52 <tswett> Voila.  A bad way of calculating the Lucas numbers.
16:55:06 <shachaf> > let [x,y] = [ (1 +- sqrt 5)/2 | (+-) <- [(+), (-)] ] in map (\n -> x^n + y^n) [0..]
16:55:12 <lambdabot>   [2.0,1.0,3.0,4.0,7.0,11.0,18.0,29.000000000000004,47.0,76.0,123.0,199.0,322...
16:55:22 <djanatyn> hmm
16:55:29 <djanatyn> my fibonacci doesn't work anymore
16:55:42 <tswett> A less bad way of calculating the Lucas numbers.  :)
16:55:45 <shachaf> tswett: Say what you mea. None of that n* | n <- [1,-1]. :-)
16:55:51 <NihilistDandy> djanatyn: What do you mean?
16:55:57 <tswett> > let [x,y] = [ (1 +- sqrt 5)/2 | (+-) <- [(+), (-)] ] in map (\n -> x^n + y^n) [0..] !! 100
16:55:58 <lambdabot>   7.92070839848372e20
16:55:58 <djanatyn> NihilistDandy: I can't remember my code ;)
16:56:00 <f> axman6; If you do not have any more sugestions, thank you gotta go read
16:56:24 * mornfall heads for the piano...
16:56:38 <djanatyn> http://hpaste.org/46297/kinda_like_this <-- it was *kinda* like that
16:56:45 <djanatyn> except that doesn't work
16:57:08 <shachaf> djanatyn: Now everyone's going to tell you what's wrong. :-( Ignore this channel and figure it out.
16:57:24 <shachaf> djanatyn: (Also, that won't work for n > 50 or something around that.)
16:57:30 <djanatyn> shachaf: Oh, I have the original code around here somewhere.
16:57:32 <djanatyn> And why not?
16:57:47 <shachaf> djanatyn: It's a puzzle. :-)
16:57:53 <djanatyn> -_-
16:58:20 <hpc> [SPOILER] You can check wikipedia for the definition of fibonacci sequences if you get stuck after half an hour
16:58:59 <danharaj> aren't n+k patterns deprecated?
16:59:04 <pastorn> hpc: awww, now i know how it ends!
16:59:05 <pmetzger> danharaj: they are.
16:59:11 <pmetzger> danharaj: in haskel2010
16:59:27 <djanatyn> ohhhhh
16:59:28 <djanatyn> here it is!
16:59:32 <monochrom> hahahaha hpc
16:59:41 <Eduard_Munteanu> Do you guys know any open (/ public) source verified software that isn't written directly in a theorem prover? Something like seL4?
16:59:45 <NihilistDandy> djanatyn: F(n) = F(n-1) + F (n-2)
16:59:49 <monochrom> @remember hpc [SPOILER] You can check wikipedia for the definition of fibonacci sequences if you get stuck after half an hour
16:59:50 <lambdabot> It is stored.
17:00:07 <hpc> haha
17:00:14 <djanatyn> NihilistDandy: That wasn't very nice
17:00:17 <djanatyn> But yeah, that's what I did.
17:00:19 <NihilistDandy> :P
17:00:31 <shachaf> djanatyn: Anyway, what's F(50)?
17:00:35 <djanatyn> http://hpaste.org/paste/46297/kinda_like_this_annotation#p46298
17:00:46 <monochrom> the definition is barely the beginning anyway
17:00:53 <djanatyn> shachaf: a big number, likely.
17:01:08 <djanatyn> What, do I need to switch from Int to Integer?
17:01:22 <pmetzger> the ackermann function is so much more fun than the fibonacci sequence.
17:01:23 <shachaf> djanatyn: Oh. Yes, probably, but that wasn't the point.
17:01:25 <monochrom> actually defaults to Integer. do nothing
17:01:37 <djanatyn> my computer is having trouble calculating the 50th fibonacci number
17:01:47 <shachaf> @ty actually
17:01:48 <lambdabot> Integer
17:01:51 <shachaf> monochrom: Huh, so it does.
17:01:54 <djanatyn> umm, I think I know what it messes up!
17:02:01 <djanatyn> I bet recursion can only go so far...maybe?
17:02:16 <monochrom> pmetzger: I invite you to my http://www.vex.net/~trebla/haskell/calculator/Calculator.html#g:6 :)
17:02:28 <shachaf> djanatyn: It's not a stack space issue, if that's what you mean.
17:03:08 <hpc> djanatyn: try calculating smaller numbers
17:03:13 <tswett> I wish I had never studied closed forms of linear recursive sequences.  Now it seems like (phi^n - (-phi)^(-n))/(phi + 1/phi) is obviously the fastest way to calculate the Fibonacci sequence.
17:03:19 <pmetzger> monochrom: for real fun, try the ackermann function in the C++ template language. :)
17:03:21 <monochrom> "fibonacci x = fibonacci (x-1) + fibonacci (x-2)" is pretty slow. this is why I say the definition is barely the beginning
17:03:31 <djanatyn> man, my computer is still calculating the 50th fibonacci number
17:03:31 * monochrom fears c++
17:03:50 <pmetzger> monochrom: the template language is turing equivalent. :)
17:04:37 <Jafet> But doing anything useful in it is Turing-hard.
17:04:44 <pmetzger> of course, for those that don't like ackermann's function, the n-state busy beaver function is enormous fun.
17:04:46 <monochrom> a decade ago I heard someone factored integers into primes in the template language. "w00t it is O(1) run time!"
17:04:50 <NihilistDandy> monochrom: I have a faster way :D
17:05:31 <NihilistDandy> Construct the Fibonacci sequence, then take the 50th element
17:05:31 <luite> tswett: not obviously, you need some real number calculation there. exponentiating the matrix is often faster for finding a specific number
17:05:32 <NihilistDandy> Simple
17:05:50 <monochrom> do you mean you have a faster way than tswett's way?
17:06:10 <NihilistDandy> I actually didn't see his
17:06:28 <Jafet> The number of digits in F_n is linear in n anyway, so you can't really do much.
17:06:37 <monochrom> oh do you mean you have a faster way to factor integers into primes?
17:06:40 <pmetzger> I wonder if anyone has yet found a function that grows faster than the busy beaver function.
17:06:49 <NihilistDandy> monochrom: No, but that would be lovely
17:06:55 <danharaj> pmetzger: Constructing such a function is not hard.
17:07:05 <Jafet> succ . beaver
17:07:06 <tswett> luite: yes, but my mathematical mind is saying that since it's a closed form, it must run in constant time.
17:07:20 <monochrom> I think in fact I still haven't suggested any fast way to fibonacci, so I fail to see what is a faster way than my suggestion...
17:07:21 <pmetzger> danharaj: well, there are trivial ways like "busy beaver ^ busy beaver" but I mean interesting ones.
17:07:33 <monochrom> (or perhaps therefore any way is faster!)
17:07:42 <luite> tswett: yes I see, the version without matrix looks faster because it's just numbers :p
17:07:46 <NihilistDandy> "fibonacci x = fibonacci (x-1) + fibonacci (x-2)" is pretty slow. this is why I say the definition is barely the beginning"
17:07:52 <pmetzger> not that it matters, once you're in the realm of non-computable functions...
17:07:53 <Jafet> pmetzger: Busy beaver for a super-Turing machine
17:08:01 <NihilistDandy> That's what I was responding to
17:08:08 <Jafet> (A machine that can have Turing-complete oracles)
17:08:10 <tswett> luite: exactly.  :P
17:08:15 <monochrom> yes, I'm precisely saying it's slow
17:08:30 <NihilistDandy> Indeed. And I am precisely saying I have a faster way.
17:08:39 <monochrom> yes everyone please tell me about the existence of faster ways, now that I have said it is slow!
17:08:39 <Jafet> Or busy beaver for a more complicated machine.
17:08:49 <NihilistDandy> -_-
17:09:13 <monochrom> I also happen to know slow ways to compute the number 0. are you interested too?
17:09:25 <NihilistDandy> Certainly. Do tell.
17:10:04 <luite> hmm, cabal-dev is quite useful :)
17:10:08 <monochrom> "zero n | n<0 = zero (n+1) | n>0 = zero (n-1) | 0 = 0" is a pretty slow way to return 0
17:10:29 <NihilistDandy> I think you can make a slower one
17:10:34 <monochrom> damn you
17:10:35 <NihilistDandy> I believe in you
17:10:52 <pmetzger> NihilistDandy: it is always possible to make an algorithm slower. just give it to a CS freshman to code up.
17:10:55 <monochrom> anyway ha ha ha ha ha
17:11:03 <Jafet> > exp (pi * (0 :+ 1)) + 1 :: Complex CReal
17:11:04 <lambdabot>   0.0 :+ 0.0
17:11:13 <monochrom> @remember pmetzger it is always possible to make an algorithm slower. just give it to a CS freshman to code up.
17:11:14 <lambdabot> Done.
17:11:37 <NihilistDandy> :D
17:11:39 <hpc> now now
17:11:47 <hpc> if you give it to a freshman, it will take the whole semester
17:11:51 <hpc> ...give it to adobe
17:12:01 <monochrom> hahaha
17:12:04 <pmetzger> give it to adobe and it will have six more security holes than lines of code.
17:12:06 <c_wraith> I once wrote an O(n!^2) sort algorithm.
17:12:25 <monochrom> ok n!^2 sorting algorithm wins
17:12:25 <pmetzger> cwraith: n! is easy, how did you get to squaring it?
17:12:40 <pmetzger> for n!, just try each permutation until the sorted condition is true.
17:12:47 <pmetzger> but how do you get to square of n!?
17:12:48 <c_wraith> pmetzger: do the permutation wrong.
17:13:03 <c_wraith> pmetzger: so that it generates each permutation many times
17:13:05 <tswett> pmetzger: do it twice and make sure it matches, for good measure?
17:13:36 <monochrom> we are about to compute fib(n) in fib(fib(fib(n!))) time
17:13:43 <Jafet> Generate all permutations and bubble sort them!
17:13:46 <c_wraith> basically, I tried every order of elements to try every order of the elements in.
17:14:00 <hpc> monte carlo sort: run bogosort until you have a statistically significant consensus as to what the sorted order of the list is
17:14:13 <hpc> it may take all year
17:14:33 <hpc> and many many IBM server farms
17:14:39 <tswett> I once tried to write a factorial function where every operation used in the algorithm was performed by a separate worker function.
17:15:06 <tswett> I stopped when I realized that any recursively defined function (e.g. addition) would hang while waiting for itself.
17:15:29 <tswett> Clearly, I should have made each thread capable of saving its state and resuming again.
17:15:37 <tswett> hpc: does that even halt with probability 1?
17:15:52 <pmetzger> there is clearly a semester's worth of compiler pessimization theory that is not being taught to today's students!
17:16:04 <pmetzger> I smell a whole new academic discipline!
17:16:12 <hpc> tswett: maybe; we need a genetic algorithm to find out!
17:16:36 <NihilistDandy> pmetzger: Hush, that's gonna be my dissertation :P
17:16:39 <pmetzger> for example, how can one know that one's register allocation is the worst possible?
17:16:53 <hpc> or at least, the GA can find us a random number generator that will terminate it most reliably
17:16:53 <pmetzger> how can one assure the greatest number of cache line conflicts?
17:17:05 <hpc> pmetzger: oh, that one is easy! python
17:17:12 <danharaj> zing.
17:17:33 <danharaj> pmetzger: not thinking hard enough. Store the list on a server on the other side of the world.
17:17:45 <NihilistDandy> On the ISS
17:18:04 <NihilistDandy> Only accessible when within range of a randomly assigned satellite
17:18:20 <NihilistDandy> Which changes every six hours
17:19:08 <pmetzger> my game is this: one wants to generate code that is exceptionally slow without being obvious why it is slow. far better than simply throwing in a delay loop between every two instructions or what have you.
17:19:40 <pmetzger> maximize the number of lock conflicts, cache line misses, register spills...
17:20:11 <Jafet> Drum memory rotations.
17:21:03 <shachaf> pmetzger: Sounds like a fun alternative to the underhanded C contest.
17:23:52 <mornfall> Jafet: Someone's been reading Story of Mel? :P
17:25:03 <gwern> ok, haskell-src-exts is not as easy as I thought it would be
17:26:03 <gwern> you are confronted with a twisty maze of datatypes, each alike
17:26:17 <NihilistDandy> in dignity?
17:26:47 <gwern> in moral worth. we hold these truths self-evident...
17:27:12 <djanatyn> uhh. hey shachaf!
17:27:20 <dylukes> um so
17:27:22 <djanatyn> looks like my computer is *still* calculating the 50th fibonacci number >_>
17:27:22 <dylukes> I have a terrible joke
17:27:25 <djanatyn> Hey, it's dylukes.
17:27:25 <dylukes> in terrible taste
17:27:37 <djanatyn> so far it's up to 63245986
17:27:40 <dylukes> about the bin laden fiasco (which I think is ridiculous, why are we celebrating death...)
17:27:42 <dylukes> anyways...
17:27:43 <dylukes> here goes
17:27:45 <dylukes> obama@whitehouse:~$ sudo chmod +x /bin/laden
17:27:57 <dylukes> yeah. I went there.
17:28:19 <gwern> dylukes: that'd be funnier if I didn't see it like 10 hours ago on reddit
17:28:24 <NihilistDandy> http://i.imgur.com/Oj3qx.png
17:28:26 <dylukes> gwern: ruining all the fun.
17:28:29 <djanatyn> ...that's not even a fibonacci number
17:28:30 <NihilistDandy> Better?
17:28:43 <dylukes> NihilistDandy: ._.
17:29:09 * mornfall must be missing something real obvious.
17:29:21 <hpc> NihilistDandy: :D
17:29:50 <djanatyn> oh, it was.
17:29:56 <djanatyn> dylukes: ...
17:30:10 <c_wraith> Can you pass CPP flags to cabal at package build time?
17:30:16 <dylukes> mornfall: …that'd make him executable.
17:30:24 <NihilistDandy> m.n.m
17:30:36 <mornfall> dylukes: Still doesn't add up.
17:31:14 <gwern> dammit, there is no Functor instance on Decl.
17:31:38 <c_wraith> rather, at configure-time
17:32:44 <shachaf> djanatyn: It'll take it a while. Can you figure out why?
17:33:42 <djanatyn> shachaf: ...maybe?
17:33:54 <djanatyn> I'm thinking that there would be better things to do, though.
17:33:57 <djanatyn> With all due respect :D
17:34:06 <shachaf> djanatyn: It'll be educational!
17:34:36 <djanatyn> shachaf: Learning the *rest* of Haskell would be educational!
17:34:38 <djanatyn> And more fun ;)
17:34:44 <djanatyn> I've got so much more Haskell to learn.
17:34:53 <NihilistDandy> Well, learn this part now
17:34:55 <NihilistDandy> Why wait?
17:35:07 <djanatyn> Okay, okay.
17:35:11 <gwern> ack. I'm having a brain fart. given a [Decl], how do I filter out all of Decl's constructors except FunBind [Match] ?
17:35:16 <djanatyn> I'm not sure why, at all.
17:35:29 <gwern> could do primitive recursion with a case match, but that's not right
17:35:36 <djanatyn> I don't see any reason why the math would suddenly stop working - it's not like recursion has a limit in the real world.
17:35:43 <djanatyn> It's probably a limitation of haskell, or ghci, or something.
17:35:58 <djanatyn> maybe the interpreter just gets bored?
17:37:00 <NihilistDandy> Machines hate it when you anthropomorphize them~
17:39:57 <BMeph> gwern: I'd just makea cheapo "predicate" function. :)
17:40:30 <monochrom> @quote anthro
17:40:30 <lambdabot> ion says: ddarius: Yeah, abstract concepts absolutely hate being anthropomorphized.
17:40:47 <NihilistDandy> Heh.
17:41:11 <gwern> auugh the right hand side is different from the let or where binds, so now I have to treat each one separately
17:41:20 <gwern> my kingdom for a Functor instance
17:41:37 <aavogt> gwern: what is the kind of Decl?
17:41:41 <Saizan> gwern: [ x | x@FunBind{} <- xs ]
17:41:45 <djanatyn> woot, got another project euler problem :D
17:41:59 <gwern> aavogt: dunno. http://hackage.haskell.org/packages/archive/haskell-src-exts/1.10.2/doc/html/Language-Haskell-Exts-Syntax.html#t:Decl
17:42:01 <Saizan> and if you can have a [Decl] there's not Functor instance to be had
17:42:03 <djanatyn> with the help of my handy dandy (map) function ;)
17:42:22 <Saizan> *no
17:42:35 <gwern> Saizan: oh yes, that looks better than my case expression, although I also extract the [Match] inside the FunBind
17:43:01 <Saizan> gwern: easy to adapt
17:43:02 <djanatyn> let square x = x * x in (square (sum [1..100])) - (sum (map square [1..100]))
17:43:05 <djanatyn> > let square x = x * x in (square (sum [1..100])) - (sum (map square [1..100]))
17:43:06 <lambdabot>   25164150
17:43:09 <gwern> Saizan: yeah, I'll do that
17:43:13 <djanatyn> \o/
17:43:43 <djanatyn> Solving problems using Haskell is so rewarding.
17:43:44 <Maxdamantus> > join (*) 5
17:43:45 <lambdabot>   25
17:43:54 <Maxdamantus> > (^2) 5
17:43:55 <lambdabot>   25
17:44:20 <djanatyn> what does join do?
17:44:22 <djanatyn> > :t join
17:44:23 <lambdabot>   <no location info>: parse error on input `:'
17:44:28 <Maxdamantus> Crazy stuff.
17:44:32 <Maxdamantus> :t join
17:44:32 <Saizan> :t join
17:44:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:44:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:44:34 <djanatyn> Maxdamantus: Isn't that most of Haskell?
17:44:41 <gwern> 'fmatches xs = concat [y | FunBind y <- xs]'
17:44:42 <djanatyn> Eww, monads.
17:44:43 <Maxdamantus> Probably.
17:44:47 <djanatyn> I haven't gotten there yet.
17:44:48 <Saizan> djanatyn: in the above it's just \f x -> f x x
17:45:54 <Maxdamantus> > ((\f x -> f x x) :: forall (m :: * -> *) a. (Monad m) => m (m a) -> m a) (*) 5
17:45:54 <lambdabot>   Couldn't match expected type `(->) t' against inferred type `m'
17:45:54 <lambdabot>    `m' is a...
17:46:16 <alex_r> I'm trying to think of a way to have a high level description of a turing machine that accepts any strings with an even number of  0's and an odd number of 1's but i can't think of any way to keep count of eveness and oddness with a turing machine, any help?
17:46:52 <NihilistDandy> Ask nicely?~
17:46:53 <parcs> @type join :: (a -> a -> b) -> a -> b
17:46:54 <lambdabot> forall a b. (a -> a -> b) -> a -> b
17:48:36 <gwern> oh good grief the rhss nest and have more [exp]
17:48:58 <gwern> I give up. going to email Niklas and ask whether there's any non-insane way of traversing the parsed Module looking for any usage of a function.
17:49:17 * gwern hasn't even figured out how to turn a String function name into something that could be searched for in the AST anyway
17:49:32 <Saizan> alex_r: you've to use different states to represent the different possible outcomes of measuring such things
17:49:57 <Axman6> alex_r: you only need four states, for each of the four possible intermediate states
17:50:17 <monochrom> alex_r: there are about only 4 states to keep. in fact this job is doable by any finite state machine or human
17:50:42 <gwern> http://hpaste.org/46299/aborted_source_code_search is how far I got if anyone cares
17:51:42 <aavogt> gwern: why don't you use Data.Generics (or it's competitors)?
17:52:03 <gwern> aavogt: I've never used them and don't even know what they do
17:52:06 <aavogt> if there isn't a Data instance, there should be
17:52:14 <aavogt> though you could make it yourself
17:52:16 <alex_r> Okay the four states make sense: either even number of 1's, even number of 0's , odd number od 1's, odd number of 0's. but how do you describe at the high level of how to keep tabs of whether you are at an even or odd state for one or zero
17:52:37 <cjay> anyone using haskellmode on emacs 23.3?
17:52:54 <alex_r> basically how do you say "okay so i counted two 0's, this is even"
17:52:54 <aavogt> gwern: this "generic programming" is intended to address your grief
17:53:14 <monochrom> emphasis "high level": "when I see 0, change state accordingly; when I see 1, change state accordingly"
17:53:27 <alex_r> okay
17:53:31 <gwern> aavogt: there is a Data instance for Module, at least, so presumably that covers everything lowerlevel inside the Module like all the function decalrations http://hackage.haskell.org/packages/archive/haskell-src-exts/1.10.2/doc/html/Language-Haskell-Exts-Annotated-Syntax.html#v:Module
17:53:37 <gwern> not that I know how Data helps
17:54:03 <monochrom> btw there is much oxymoron with "high level" and "turing machine" in the same sentence. peace-loving hitler
17:54:07 <aavogt> so you could write a couple cases picking out things you like to see, and have the functions already written as part of the Data instance will traverse all the ocntents of your Module
17:54:56 <aavogt> it's a bit tricky if you need to get some context of where you've applied whatever function, but maybe Saizan has ideas
17:55:18 <alex_r> okay thanks i'll work on it a bit more
17:55:30 <aavogt> by tricky, I mean "I dunno how"
17:56:01 <djanatyn> Woah.
17:56:05 <Axman6> alex_r: if you're in the odd0, odd1 state, and you see a 1, where do you go?
17:56:10 <djanatyn> zipWith is pretty crazy.
17:56:18 <djanatyn> These higher-order functions are really insane.
17:56:36 <djanatyn> It's like Haskell is giving you a magic toolbox
17:56:38 <Axman6> djanatyn: wait until you get the folds...
17:57:25 <djanatyn> I already checked out the folds :)
17:58:14 * gwern mails Niklas. I can investigate these wild and wooly Data functions if he says that's the way to go
18:04:56 <djanatyn> blah, haskell has my brain all muddy
18:07:05 <aavogt> @ty gfoldl
18:07:06 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
18:07:21 <aavogt> djanatyn: ^^ that one :)
18:15:25 <shachaf> aavogt: That type is more confusing than the implementations.
18:24:29 <nyingen> what does it mean if a package is enclosed in {} in the output of ghc-pkg list ?
18:26:23 <Zao> Hidden, isn't it?
18:26:41 <nyingen> hidden is () according to the docs
18:26:45 <nyingen> I don't see {} mentioned
18:28:27 <gwern> @quote
18:28:28 <lambdabot> jdh30 says: parallel Haskell would seem to have immediate practical applications
18:29:13 <nyingen> I'm trying to figure out why this build is failing in the linking step, with the following message
18:29:34 <nyingen> <command line>: unknown package: foopkg-1.0
18:29:43 <nyingen> in ghc-pkg list, foopkg-1.0 is listed in {}
18:32:10 <monochrom> nyingen: what is your build command?
18:32:27 <mauke> how does ghc-pkg list broken packages?
18:32:46 <monochrom> yeah, wondering if {foopkg} means broken
18:33:16 <nyingen> I'm using 'runghc Setup.hs build'
18:33:21 <nyingen> monochrom: that's my guess
18:33:36 <nyingen> but I didn't get a message about a broken package during the configure step
18:35:14 <nyingen> oh wait, I got it to work
18:35:34 <nyingen> looks like it might have had to do with stale object files
18:35:42 <nyingen> as well as a broken package.
18:40:27 <parcs> nyingen: it seems that ghc-pkg gives broken packages a red color if it thinks you're using a terminal that supports colors; otherwise, it fixes a broken package with curly braces
18:40:47 <nyingen> parcs: gotcha
18:58:23 <overscore> Is there anything in the prelude like [Word8] -> [Char] ?
18:58:47 <overscore> if not I'll use the map (toEnum . fromEnum) trick..
18:58:52 <geekosaur> not directly, but you can build it
18:58:53 <luite> @type chr
18:58:53 <lambdabot> Int -> Char
18:59:11 <geekosaur> still needs fromEnum
18:59:38 * geekosaur has "twiddle = toEnum . fromEnum" in his personal library
18:59:39 <luite> I'd use fromIntegral, but I expected this to be polymorphic
19:05:07 <aristid> :t toEnum . fromEnum
19:05:08 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
19:24:24 <gienah> @tell Eduard_Munteanu agda darcs ebuild is a little tricky, it wants syb 0.2.2 which conflicts with haskell platform wanting syb 0.3, will ask the gentoo devs about slotting syb, will probably take a few days or so (I managed to build it with syb slotted)
19:24:25 <lambdabot> Consider it noted.
19:25:58 <dmwit> overscore: Do you need to do any actual decoding?
19:26:27 <overscore> dmwit, yes
19:26:31 <overscore> well, no
19:26:48 <overscore> i'm just getting ASCII data from a lazy BS
19:26:57 <overscore> in the form of [Word8]
19:27:04 <overscore> and need to pattern match against that
19:27:08 <dmwit> Why not use Data.Bytestring.Char or whatever?
19:27:18 * shachaf recommends the use of whatever.
19:27:55 <dmwit> I can never remember what order the names are organized in.
19:28:02 <overscore> ah great, this will do
19:28:08 <dmwit> Data.Char.ByteString? Data.ByteString.Lazy.Char?
19:28:13 <dmwit> Something like that.
19:28:17 <overscore> the later.
19:29:00 <dmwit> It's not very robust, though.
19:29:10 <dmwit> I find it very hard to believe that you really have ASCII data.
19:29:28 <overscore> prolly better than my coerce function :)
19:29:34 <dmwit> Not impossible, just very uncommon in this enlightened day and age. =P
19:29:44 <overscore> dunno, i doubt the AMIGA had a way to render japanese
19:30:30 <dmwit> It may have had codepages.
19:30:36 <dmwit> That's not a very new technology.
19:31:08 <overscore> not in this context though. ASCII will be fine for now I thing
19:31:10 <overscore> think
19:31:14 * dmwit nods
19:32:31 <overscore> weird question, but ...
19:32:44 <overscore> is the 'qualified' modifier optional ?
19:32:49 <dmwit> Yes.
19:33:08 <dmwit> The "qualified" modifier prevents un-qualified names from being put in scope.
19:33:27 <dmwit> The "as" keyword adds additional qualified names under your specified alias.
19:33:32 <dmwit> They are completely orthogonal.
19:39:11 <shamster> How does one trim whitespace chars from the init of a ByteString?
19:39:18 <overscore> cool BS.Char8 works well
19:39:28 <overscore> well, the lazy one.
19:40:09 <overscore> shamster, filter ?
19:40:49 <shamster> overscore: I'm pretty new at this. What predicate could I use?
19:40:59 <ill_logic> Does anybody know the best way to render a Hexpat Tree to text? Show will show the data structure.
19:41:11 <ill_logic> I don't see an obvious render to text function.
19:41:13 <shamster> overscore: I'd need to drop any tabs, spaces, newlines, etc
19:41:39 <dmwit> :t filter (not . isWhitespace)
19:41:40 <lambdabot> Not in scope: `isWhitespace'
19:41:49 <dmwit> :t isWhite
19:41:50 <lambdabot> Not in scope: `isWhite'
19:41:52 <dmwit> bleh
19:41:55 <dmwit> ?hoogle white
19:41:55 <lambdabot> Text.Html white :: String
19:41:56 <lambdabot> Text.XHtml.Transitional white :: String
19:41:56 <lambdabot> Text.Parsec.Token whiteSpace :: GenTokenParser s u m -> ParsecT s u m ()
19:42:01 <overscore> shamster, actually I could use the same function...
19:42:19 <dmwit> :t filter (not . isSpace)
19:42:20 <lambdabot> [Char] -> [Char]
19:42:24 <dmwit> :t dropWhile isSpace
19:42:25 <lambdabot> [Char] -> [Char]
19:42:37 <dmwit> > dropWhile isSpace "  \t\n\tWell LA DE DA"
19:42:38 <lambdabot>   "Well LA DE DA"
19:42:53 <shamster> :t isSpace
19:42:54 <lambdabot> Char -> Bool
19:43:18 <shamster> now what would be the bytestring equivalent
19:43:31 <shamster> or is that a silly question?
19:43:56 <overscore> naah
19:44:10 <overscore> Data.ByteString.Lazy.Char8 has 'filter'
19:44:14 <dmwit> That's a silly question, because ByteString isn't for text.
19:44:17 <dmwit> Text is for text.
19:44:41 <shamster> so Data.ByteString.Lazy.isWhite?
19:44:45 <shamster> or similar?
19:45:03 <dmwit> Anyway, the equivalent to "dropWhile isSpace" is "dropWhile isSpace".
19:45:16 <dmwit> The function is named exactly the same thing in ByteString as it is in Data.List.
19:50:24 <shamster> :t isSpace
19:50:25 <lambdabot> Char -> Bool
19:50:31 <shamster> ?hoogle isSpace
19:50:31 <lambdabot> Data.Char isSpace :: Char -> Bool
19:50:31 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
19:50:31 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
19:50:55 <dmwit> :t Data.ByteString.Char8.dropWhile
19:50:56 <lambdabot> (Char -> Bool) -> BSC.ByteString -> BSC.ByteString
19:51:09 <dmwit> :t Data.ByteString.Char8.dropWhile isSpace
19:51:10 <lambdabot> BSC.ByteString -> BSC.ByteString
19:57:14 <shamster> :t Data.ByteString.Lazy.readFile
19:57:15 <lambdabot> FilePath -> IO BSLC.ByteString
19:57:28 * hackagebot cityhash 0.0.2 - bindings to Google CityHash  http://hackage.haskell.org/package/cityhash-0.0.2 (AustinSeipp)
19:58:47 <mgsloan> hmmm, what's an elegant way to do (a -> IO b) -> (a, c) -> IO (b, c) ?
20:00:26 <kmc_> :t flip $ \(x,y) -> fmap (\z -> (z,y))
20:00:27 <lambdabot> forall t t1 a (f :: * -> *). (Functor f) => f a -> (t, t1) -> f (a, t1)
20:06:12 <mgsloan> :t (\f (a, b) -> f a >>= return . (,b))
20:06:13 <lambdabot> Illegal tuple section: use -XTupleSections
20:06:25 <mgsloan> humbug
20:08:03 <aristid> @pl flip $ \(x,y) -> fmap (\z -> (z,y))
20:08:04 <lambdabot> flip (fmap . flip (,) . snd)
20:08:11 <aristid> :t flip (fmap . flip (,) . snd)
20:08:12 <lambdabot> forall a (f :: * -> *) a1 a2. (Functor f) => f a -> (a2, a1) -> f (a, a1)
20:08:54 <mgsloan> @pl (\f (a, b) -> f a >>= \a' -> (a', b))
20:08:54 <lambdabot> (`ap` snd) . (. fst) . flip flip (flip (,)) . (((.) . (>>=)) .)
20:09:04 <mgsloan> :t (`ap` snd) . (. fst) . flip flip (flip (,)) . (((.) . (>>=)) .)
20:09:05 <lambdabot> forall a a1 a2. (Monad ((,) a2)) => (a1 -> (a2, a2)) -> (a1, a) -> (a2, a)
20:09:54 <mgsloan> @pl (\f (a, b) -> f a >>= (\a' -> (a', b)))
20:09:54 <lambdabot> (`ap` snd) . (. fst) . flip flip (flip (,)) . (((.) . (>>=)) .)
20:10:13 <mgsloan> doh
20:10:24 <mgsloan> @pl (\f (a, b) -> f a >>= (\a' -> return (a', b)))
20:10:24 <lambdabot> (`ap` snd) . (. fst) . flip flip ((return .) . flip (,)) . (((.) . (>>=)) .)
20:12:03 <mgsloan> well that's the right one.  not really too illuminating of a definition :P
20:38:32 * hackagebot riak 0.4.1.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.4.1.0 (BryanOSullivan)
20:40:33 * hackagebot resource-pool 0.1.0.2 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.1.0.2 (BryanOSullivan)
20:41:33 * hackagebot riak 0.4.1.1 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.4.1.1 (BryanOSullivan)
20:47:39 <nyingen> drawing a blank here...I have a list of things, and a State function I want to run over them, getting the final state at the end
20:47:51 <nyingen> foldM? mapM?
20:48:54 <overscore> should I always use Int or Integer is suitable too ?
20:49:12 <overscore> in general code, not interfacing C or anything
20:49:26 <monochrom> try mapM_ first
20:49:49 <monochrom> try Integer first
20:50:02 <nyingen> mapM_ will carry the state left to right through the list?
20:50:07 <nyingen> sorry for muddled terminology
20:50:07 <monochrom> yes
20:50:15 <nyingen> ok
20:50:28 <overscore> Int is for bignum stuff right?
20:50:38 <monochrom> > runState (mapM_ put [3,2,1,0]) undefined
20:50:39 <lambdabot>   ((),0)
20:50:45 <monochrom> \∩/
20:50:51 <monochrom> Int is smallnum
20:50:54 <Veinor> no, Integer is unbounded
20:50:55 <nyingen> monochrom: cool.
20:50:57 <Veinor> Int is bounded
20:51:09 <monochrom> Int is wimpy
20:51:30 <nyingen> Integer is nice, but for some reason some of the Prelude functions return Int
20:51:40 <monochrom> real gods create all of the natural numbers
20:51:44 <nyingen> :t length
20:51:45 <lambdabot> forall a. [a] -> Int
20:52:09 <overscore> aah, so ill stick to integer then
20:58:56 <overscore> http://hpaste.org/46302/error_drop_mult
20:59:01 <overscore> I'm clueless :(
20:59:38 <Axman6> overscore: is n an Int or an Integer?
20:59:59 <overscore> Integer
20:59:59 <Axman6> there's no implicit conversion in haskell, an Int is completely different to an Integer
21:00:07 <Axman6> :t drop
21:00:08 <lambdabot> forall a. Int -> [a] -> [a]
21:00:25 <overscore> I know. How is this sort of thing handled then
21:00:35 <overscore> Making n an Int fails too
21:00:43 <overscore> because it expects an Int64
21:00:44 <Axman6> either use fromInteger, or use Ints
21:00:53 <Axman6> huh? you'll have to share the code
21:01:21 <overscore> drop :: Int64 -> ByteString -> ByteString
21:01:42 <Axman6> ah, that's a different drop then.
21:01:43 <overscore> that's from the ByteString.Lazy.Char8 namespace though
21:01:56 <Axman6> why are you using ByteString?
21:02:11 <overscore> doing binary file I/O :p
21:02:33 <Axman6> it would be a good idea to get the basics of haskell down before trying to more onto more advanced things like ByteString
21:02:58 <overscore> this is basic stuff though
21:03:14 <Axman6> not in haskell.
21:03:38 <Axman6> my advice is, if you don't know how to fix that error, you're certainly not ready to use bytestring
21:04:19 <overscore> fromInteger worked. thanks
21:04:28 <Axman6> do you understand why though?
21:04:40 <overscore> I think I do
21:04:43 <Axman6> i would strongly advice going over a haskell tutorial to learn the basics of haskell
21:05:05 <monochrom> > drop (fromIntegral 5) "abcdefghij"
21:05:06 <lambdabot>   "fghij"
21:05:07 <overscore> I went over "Learn You a Haskell"
21:05:41 <monochrom> use fromIntegral to convert Integer to Int
21:06:15 <monochrom> use fromIntegral to convert Int to Integer, too. this magic will demysify when you know "type class"
21:08:19 <overscore> I get that part.
21:08:21 <overscore> But..
21:08:49 <overscore> how do you call specifying the types ?
21:08:53 <overscore> example :: IO ()
21:09:03 <overscore> hrm
21:09:27 <overscore> example :: (Eq a, Eq b) => a -> b
21:09:31 <overscore> is a better example
21:09:47 <Cale> Giving a type signature?
21:09:55 <overscore> makes sense.
21:10:00 <overscore> can you "inline" that ?
21:10:05 <Cale> That thing is called a type declaration
21:10:18 <monochrom> > drop (6 :: Int) "abcdefghi"
21:10:19 <lambdabot>   "ghi"
21:10:32 <monochrom> if you inline, we call it type annotation
21:10:38 <Cale> um, what do you mean by inline? You can apply type signatures to any expression, as well as to function declarations and pattern bindings
21:10:48 <overscore> Here I thought I had to give a type signature to my 'n' to make it compile, rather than go for "fromIntegral"
21:15:17 <Cale> overscore: Well, sometimes that'll do. fromIntegral will convert between two types of numbers (from any integer-like type to any numeric type)
21:16:00 <Cale> overscore: If the problem is that you haven't specified the type of number you're using, a simple type signature somewhere to make the choice explicit can be what's needed
21:16:32 <Cale> But if you're actually working with multiple types of number, then fromIntegral (and occasionally realToFrac) will be needed to do the appropriate conversions
21:16:59 <Cale> Note that integer and fractional literals are polymorphic, so  6 :: Double  is fine
21:17:24 <Cale> as is  6.283 :: Rational
21:17:45 <Cale> > 6.283 :: Rational
21:17:46 <lambdabot>   6283 % 1000
21:17:54 <Cale> > 6.283 :: Double
21:17:55 <lambdabot>   6.283
21:18:15 <Cale> > 6 :: Double
21:18:15 <lambdabot>   6.0
21:18:18 <Cale> > 6 :: Rational
21:18:19 <lambdabot>   6 % 1
21:18:20 <luite> > 0.3333333333333333333 :: Rational
21:18:21 <lambdabot>   3333333333333333333 % 10000000000000000000
21:18:25 <luite> aw ;)
21:18:51 <monochrom> > 0.999... :: Int
21:18:52 <Cale> It actually starts with the appropriate rational, and converts the literal to a Double
21:18:52 <lambdabot>   <no location info>: parse error on input `::'
21:19:14 <Cale> > 0.333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333 :: Rational
21:19:15 <lambdabot>   333333333333333333333333333333333333333333333333333333333333333333333333333...
21:19:56 <overscore> > 3.141592
21:19:57 <lambdabot>   3.141592
21:20:03 <overscore> lol
21:21:30 <Cale> > pi :: Double
21:21:31 <lambdabot>   3.141592653589793
21:21:34 <Cale> > pi :: Float
21:21:35 <lambdabot>   3.1415927
21:21:38 <Cale> > pi :: CReal
21:21:38 <lambdabot>   3.1415926535897932384626433832795028841972
21:21:51 <Cale> > showCReal 200 pi
21:21:52 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
21:21:59 <Cale> :t pi
21:22:00 <lambdabot> forall a. (Floating a) => a
21:22:15 <Cale> :t 6
21:22:15 <lambdabot> forall t. (Num t) => t
21:22:21 <Cale> :t 6.28
21:22:22 <lambdabot> forall t. (Fractional t) => t
21:22:30 <jmcarthur> maxBound :: Fixed E64 Word64   ==>   0.9999999999999999999457898913757247782996273599565029144287109375
21:22:34 <overscore> :i forall
21:22:59 <Cale> forall just explicitly introduces the type variable
21:23:26 <Cale> Normally if you write a type signature with some variables, there will be an implicit "forall" at the top of your type signature
21:24:26 <Cale> 6 :: forall t. (Num t) => t  means "for all types t, if t belongs to the class Num, then t can be the type of 6"
21:25:30 <proq> hrm, learnyouahaskell.com doesn't load at all on iceweasel
21:26:35 <Cale> Isn't iceweasel just rebranded firefox?
21:26:54 <Cale> It loads fine in FF 4.0.1 for me.
21:26:58 <proq> yes
21:28:10 <proq> well no matter, I don't like firefox/iceweasel anyways
21:28:23 <m3ga> proq: LYAH loads fine here in iceweasel from debian testing
21:28:27 <overscore> works fine on Arora
21:28:47 <proq> this is a fresh install of debian 6, amd64
21:28:56 <proq> loads ok on google chrome
21:29:07 <mzero> is there a common combintor for this:    reverse . fst . foldl' (\(rs, s) e -> (f s e : rs,  g s e)) ([], s0)
21:29:07 <m3ga> i'm on amd64 as well
21:29:41 <mzero> that is - f computes the next output, g computes the next state
21:30:04 * proq waves goodbye to iceaweasel - I barely knew ye
21:30:05 <sully> @pl reverse . fst . foldl' (\(rs, s) e -> (f s e : rs,  g s e)) ([], s0)
21:30:05 <lambdabot> reverse . fst . foldl' (uncurry ((`ap` g) . (liftM2 (,) .) . flip (flip . ((:) .) . f))) ([], s0)
21:30:16 <Nereid> lol
21:31:00 <mzero> the thing I wrote isn't even efficient -- and I end up coding a small recurisive func each time
21:31:34 <Nereid> why foldl?
21:32:04 <mzero> because the state evolution works from head to tail
21:32:39 <mzero> (in this set of use cases I ahve)
21:34:50 <mzero> I suppose    map fst . drop 1 . scanl (\(_,s) e -> (f s e, g s e)) (undefined,s0)
21:34:57 <mzero> also works - but that feels ugly
21:37:31 <sully> mapAccumL seems related to what you want
21:37:55 <mzero> aha!
21:38:06 <djahandarie> AHA
21:38:09 <mzero> snd . mapAccumL    is exactly what I want!
21:38:11 <mzero> thanks
21:38:29 <sully> I knew there was something like that
21:39:01 <sully> because I remember writing the function in SML and calling it foldlMap
21:39:15 <sully> and I remember noticing that haskell has it in the library
21:39:39 <djahandarie> @ty runState .: filterM . (state .)
21:39:40 <lambdabot> forall s a. (a -> s -> (Bool, s)) -> [a] -> s -> ([a], s)
21:39:51 <djahandarie> @ty mapAccumL
21:39:53 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:40:11 <djahandarie> Oh, oops, slightly different function
21:40:14 <djahandarie> I forget what mine was...
21:41:19 <mzero> > take 5 $ snd $ mapAccumL (\s c -> (s*10, s*c)) 1 [1..]
21:41:19 <lambdabot>   [1,20,300,4000,50000]
21:41:51 <djahandarie> @ty runState .: (state .)
21:41:52 <lambdabot> forall s a (g :: * -> *). (Functor g) => g (s -> (a, s)) -> g (s -> (a, s))
21:41:55 <mzero> look, it even works on ∞ lists... I was worried that the returned tuple (and need to snd it) would cause it to be strict
21:42:05 <djahandarie> Arg, damn you lambdabot
21:43:00 <djahandarie> @ty let { (.) = (Prelude..); (.:) = (.).(.); } in runState .: (state .)
21:43:01 <lambdabot> forall s a a1. (a1 -> s -> (a, s)) -> a1 -> s -> (a, s)
21:43:35 <djahandarie> Ah damn, this one loses the list :p
21:44:01 <djahandarie> @ty let { (.) = (Prelude..); (.:) = (.).(.); } in runState .: Data.Traversable.traverse . (state .)
21:44:03 <lambdabot> forall a (t :: * -> *) s a1. (Data.Traversable.Traversable t) => (a -> s -> (a1, s)) -> t a -> s -> (t a1, s)
21:44:29 <djahandarie> Okay, I give up :p
21:44:39 <djahandarie> (I wonder what the hell that even does)
21:45:10 <sully> djahandarie: you are a crazy person.
21:46:20 <djahandarie> > runState .: Data.Traversable.traverse . (state .) $ (\x y -> (x * 2, y + 2)) [2,4,6,8] 10
21:46:21 <lambdabot>   Couldn't match expected type `a -> s -> (b, s)'
21:46:21 <lambdabot>         against inferred ty...
21:46:24 <shachaf> sully: Isn't that a requirement for this channel?
21:46:36 <sully> yeah, probably
21:48:23 <djahandarie> > (runState .: Data.Traversable.traverse . (state .)) (\x y -> (x * 2, y + 2)) [2,4,6,8] 10
21:48:25 <lambdabot>   ([4,8,12,16],18)
21:49:45 <djahandarie> > (runState .: Data.Traversable.traverse . (state .)) (\x y -> (x * e, y + f)) [a,b,c,d] z :: Expr
21:49:47 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
21:49:47 <lambdabot>         against inferred ...
21:49:52 * djahandarie sighs
21:50:35 <djahandarie> > (runState .: Data.Traversable.traverse . (state .)) (\x y -> (x * e, y + f)) [a,b,c,d] z :: ([Expr], Expr)
21:50:37 <lambdabot>   ([a * e,b * e,c * e,d * e],z + f + f + f + f)
21:50:48 <djahandarie> And in the end... not very interesting
21:52:30 <mzero> > (runState .: Data.Traversable.traverse . (state .)) (\x y -> (x * f, y + f)) [a,b,c,d] z :: ([Expr], Expr)
21:52:32 <lambdabot>   ([a * f,b * f,c * f,d * f],z + f + f + f + f)
21:52:48 <mzero> > (runState .: Data.Traversable.traverse . (state .)) (\x y -> (x * y, y + f)) [a,b,c,d] z :: ([Expr], Expr)
21:52:50 <lambdabot>   ([a * z,b * (z + f),c * (z + f + f),d * (z + f + f + f)],z + f + f + f + f)
21:52:57 <mzero> there we go
21:53:00 <djahandarie> Oh, good point
21:53:26 <mzero> have to use y in the result
21:54:01 <djahandarie> Might as well mix x in the other parameter now that we're here...
21:54:17 <djahandarie> > (runState .: Data.Traversable.traverse . (state .)) (\x y -> (x * y, y + x)) [a,b,c,d] z :: ([Expr], Expr)
21:54:19 <lambdabot>   ([a * z,b * (z + a),c * (z + a + b),d * (z + a + b + c)],z + a + b + c + d)
21:54:53 * djahandarie stops being distracted and returns to /more important/ things
22:17:17 <ski> > genericDrop 5 "abcdefghij"  -- overscore
22:17:18 <lambdabot>   "fghij"
22:17:37 <ski> > genericDrop (5 :: Integer) "abcdefghij"
22:17:38 <lambdabot>   "fghij"
22:19:07 <ski> @type [genericDrop,genericTake]
22:19:08 <lambdabot> forall i a. (Integral i) => [i -> [a] -> [a]]
22:19:13 <ski> @type genericLength
22:19:13 <lambdabot> forall b i. (Num i) => [b] -> i
22:19:42 <ski> @type genericIndex
22:19:43 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
22:20:02 <ski> @type genericSplitAt
22:20:03 <lambdabot> forall i b. (Integral i) => i -> [b] -> ([b], [b])
22:21:22 <ski> @type genericReplicate
22:21:22 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
22:23:46 * hackagebot xine 0.0.0.3 - Bindings to xine-lib  http://hackage.haskell.org/package/xine-0.0.0.3 (JoachimFasting)
22:25:47 <NihilistDandy> @hoogle hoc
22:25:47 <lambdabot> No results found
22:25:51 <NihilistDandy> Sigh
22:26:30 <ski> "hoc" ?
22:28:01 <NihilistDandy> Haskell Objective-C
22:28:08 <NihilistDandy> Cocoa for Haskell
22:28:18 <ski> ok
22:30:17 <djahandarie> ski, feeling generic?
22:31:04 <ski> nah, just noting things that arguably should be merged back into the `Prelude'
22:31:34 <ski> (i.e. replace `drop' with `genericDrop', renaming back, &c.)
22:39:12 <Temkk> wxHaskell,      context menu?   windowOnContextMenu,         .
23:12:47 <fosskers> how can one check the source for library functions?
23:15:04 <fosskers> nevermind
23:25:53 * hackagebot htime 0.2 - Timing utility for the command line  http://hackage.haskell.org/package/htime-0.2 (JosePedroMagalhaes)
23:43:14 <Temkk> hi, wxHaskell, context menu, example?
