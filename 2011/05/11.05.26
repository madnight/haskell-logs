00:01:30 <Cako> yeah I guess Im screwed :(
00:01:47 <eekTheCat> I'm failing at google.. ghc haskell ppa 7
00:03:45 <eekTheCat> jeffz, any idea where?
00:03:52 <Cako> Question: If I understand right... if I use Parsec then the parser without a lexer because you can define the terminals right there and then?
00:05:15 <jeffz> eekTheCat: this one, but I have not tested it personally http://ppa.launchpad.net/someone561/ppa/ubuntu/
00:10:47 <Cako> Let me rephrase my statement: Does Parsec do the lexical analysis as well?
00:11:38 <minsa> What does this mean ? "Furthermore, since Haskell has only universally quantified types, there is no need to explicitly write out the symbol for universal quantification, and thus we simply write [a] in the example above."
00:11:44 <ddarius> Lexing is just a special case of parsing.
00:12:28 <minsa> Also, " In other words, all type variables are implicitly universally quantified."
00:12:31 <minsa> thnx.
00:12:41 <shachaf> minsa: It means that when you write "[a]", it implicitly means "forall a" at the beginning. The type variable "a" could have no other meaning.
00:12:44 <shachaf> (In Haskell 98.)
00:13:31 <Peaker> and Haskell 2010
00:13:49 <shachaf> And Haskell 1.3.
00:13:58 <minsa> I understand that it's not need to explicitly write out "universal quantification" like "for all a".
00:14:13 <minsa> I mean I come to understand that from your explanation.
00:14:21 <Peaker> minsa: GHC extensions let you write:   forall a.  [a]
00:14:36 <Peaker> Even more extensions let you write (useless) things like:  [forall a. a]
00:14:48 <minsa> Next question is the state claim "since Haskell has only universally quantified types".
00:14:52 <minsa> what does that mean ?
00:15:03 <ddarius> Peaker: What's useless about that?
00:15:17 <jeffz> minsa: lack of particular quantification?
00:15:47 <Peaker> ddarius: well, a list of bottoms is usually not very useful
00:15:48 <minsa> jeffz: I can still follow that. lack of specific type quantificaiton ?
00:15:58 <ddarius> Peaker: It's Nat.
00:16:09 <Peaker> Nat?
00:16:20 <shachaf> Lazy natural numbers.
00:16:25 <shachaf> ddarius: So's forall a. [a], though.
00:17:24 <minsa> the question is why would Haskell have only universally quantified types ?
00:17:25 <Peaker> ddarius: not a very nice way to represent Nat, though
00:18:00 <minsa> Int would be a specific quantification, right ?
00:18:02 <Peaker> minsa: Existentially quantified types (and rank2/rankN types in general) are less often useful -- though they are supported by GHC extensions..
00:18:36 <ddarius> Peaker: It represents Nat as the free monoid on one generator, which is exactly what it is.
00:19:16 <ddarius> It has nothing to do with usefulness.  Higher rank types are very useful.  It has more to do with the difficulty in implementing them.
00:19:38 <ddarius> Though, by now, the problems have more or less been solved.  There's little reason for a new Haskell standard not to include them.
00:20:18 <Peaker> ddarius: Existential types are less useful than universal types, IME
00:20:42 <minsa> Peaker: I will work through that. Here is another question. The author says Haskell values are first-class but Haskell types are not first-class.
00:20:43 <ddarius> Peaker: Well that contradicts the experience of the vast majority of programmers.
00:20:48 <Peaker> ddarius: Though Rank2/RankN may be very useful...   There are still problems, IMO.  f . g $ ... is not equivalent to  f $ g $ ..  with RankN types
00:21:05 <ddarius> Peaker: That has to do with predicativity.
00:21:08 <Peaker> ddarius: the majority which only has existential types? :)
00:21:13 <minsa> Does it just mean that type variables cannot be used in all places where values can be used ?
00:21:34 <ddarius> Peaker: Most mainstream languages nowadays have both rank-1 universals and existentials.
00:22:00 <Peaker> ddarius: how do you represent a universal in Java?
00:22:15 <ddarius> The same way you do in Haskell.
00:23:13 <Peaker> In Java, when you have a generic type variable Foo, it's more like: (exists f. f extends Foo), isn't it?
00:23:24 <ddarius> No.
00:23:47 <Peaker> How can you say you want to take some type in Java, without also accepting sub-classes of that type?
00:24:09 <pamiz> you can define the class to be final
00:24:36 <ddarius> Peaker: You can do that with variance annotations or other tricks, but subtyping is orthogonal to universal or existential quantification.
00:26:06 <Peaker> ddarius: I don't think inheritance, in the face of mutability, is really "subtyping"..
00:26:23 <ddarius> Peaker: I didn't say that it was.
00:26:41 <ddarius> I didn't say anything at all about inheritance.
00:26:41 <Peaker> ddarius: btw: You said: "That has to do with predicativity." -- but doesn't that mean that Rank* types are NOT a "solved" problem?
00:26:58 <ddarius> At any rate, forall f. f extends Foo is just as legitimate a statement.
00:27:08 <ddarius> Peaker: No, it doesn't mean that.
00:27:25 <Peaker> ddarius: Do you not think it is a problem that equivalences that hold without Rank* types cease to hold?
00:28:21 <ddarius> Peaker: Predicativity or impredicativity is orthogonal to rank-n types.  It's not rank-n types fault that that behavior occurs, it's predicativities fault.  Anyway, equivalence is typed in my view, so I see no equivalences broken.
00:28:51 <ddarius> s/predicativities/predicativity's/
00:29:06 <Peaker> ddarius: So don't call it "equivalence", then.  The ability to re-factor f $ g $ x   to   f . x $ x   is nice.  It *always* holds with just Rank1 types, doesn't it?
00:29:22 <Peaker> so it seems to not be orthogonal to rank-n types..
00:29:37 <ddarius> Peaker: Maybe.  I'm certain I can come up with equally innocuous changes that don't though.
00:30:40 <Peaker> But I don't understand why you don't see this as an unsolved problem with RankN types, if it doesn't happen with Rank1 types, but does happen with RankN types
00:30:52 <minsa> What does this mean ? map :: (a -> b) -> [a] -> [b]  : Can I say, it takes a value of type a and type b. After that it will produce a list of type a, which in turn will result to a list of type b ?
00:31:01 <ddarius> Peaker: Again, if the type system was impredicative, as there is an extension that provides that, then that "equivalence" would hold.
00:31:28 <Peaker> ddarius: isn't that extension deprecated?
00:31:39 <Veinor> minsa: it means that map, given a function of type a to b, will return a function of type [a] -> [b]
00:32:07 <Peaker> maybe RankN types  +  impredicative types   has no problems -- but RankN types without imp. types does have problems
00:32:13 <ddarius> It was and then I think they changed their minds.  At any rate, impredicativity is understood (at least in a System F like system).  It just makes implementation much harder.
00:32:47 <Peaker> I thought the impredicative extension allows imp. at specific locations (in data constructors) and not everywhere?
00:33:06 <minsa> Veinor: thnx. How about  just   [a] -> [b] part ? It will be take a function of type [a] and return a function of type [b] ?
00:33:07 <ddarius> Peaker: There are plenty of "extensions" that break "equivalences" by allowing more expressive terms.
00:33:21 <ddarius> Peaker: That doesn't make sense.
00:33:34 <Veinor> it takes a list of type [a] and returns a list of type [b]
00:33:48 <Peaker> ddarius: can you give some examples?
00:34:19 <minsa> in the expression with map, what denotes function ?    ::   or   (  ) ?
00:34:42 <ddarius> Note that in the simply typed lambda calculus, binding f . f to a name and replacing occurrences with that name is a valid refactoring that always succeeds.  It fails with rank-1 polymorphism.
00:34:48 <ddarius> Peaker: Of what?
00:35:09 <Veinor> minsa: map :: (a -> b) -> [a] -> [b] means that map has the type (a -> b) -> [a] -> [b]
00:35:15 <Peaker> of "extensions" that break "equivalences" by allowing more expressive terms.
00:35:20 <Veinor> x -> y is the type of functions from type x to type y
00:35:21 <ddarius> (or rather \f -> f . f)
00:36:03 <ddarius> twice f = f . f does not mean the same thing as its inlining in the face of rank-1 polymorphism.  It does in the simply-typed lambda calculus.
00:36:26 <Peaker> @type \f -> f . f
00:36:27 <lambdabot> forall b. (b -> b) -> b -> b
00:36:53 <ddarius> Rank-1 types must be an unsolved problem.
00:37:07 <ohshizlgizen>  ?DCC SEND "ultimatekeylogger2001edition.exe" 0 0 0
00:37:12 <Peaker> because if you inline it -- you might get more polymorphic/ambiguous types?
00:37:16 <minsa> thnx Veinor. I need more reading and thinking.
00:37:41 <shachaf> @ty (:[]) . (:[])
00:37:41 <lambdabot> forall a. a -> [[a]]
00:37:54 <Veinor> (:[]) is the monkey combinator
00:38:34 <Peaker> ddarius: inlining twice while giving a type annotation would always work, though, right?
00:38:35 <ddarius> Peaker: When inlined, the fs can be instantiated to different types, but they must be the same type if they are the same parameter.  This scenario can't come up in the simply-typed lambda calculus, so that refactoring doesn't fail.
00:38:56 <ddarius> Peaker: You can't inline it twice.
00:39:10 <Peaker> ddarius: inlining the function named twice, that is
00:41:50 * hackagebot hlint 1.8.9 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.9 (NeilMitchell)
00:41:52 * hackagebot derive 2.5.2 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.2 (NeilMitchell)
00:42:27 <minsa> what is :[] ?
00:42:36 <minsa> is it related to   x:xs ?
00:43:02 <shachaf> x:xs is not descended from monkeys! Take that back!
00:43:09 <minsa> ok.
00:43:30 <isomorphic> shachaf: this is the intelligent design approach to Haskell?
00:43:33 <minsa> the author is saying  : + [] is like cons in LISP.
00:44:05 <monqy> (:) is cons and [] is the empty list
00:44:18 <minsa> cons nil.
00:44:19 <minsa> ok
00:45:05 <minsa> but it's a mystery to see   (:[]) . (:[]) turns into type   a-> [[a]] .
00:45:18 <Peaker> minsa: x : []       is     cons x nil
00:45:20 <shachaf> @ty mystery
00:45:21 <lambdabot> Not in scope: `mystery'
00:45:25 <shachaf> copumpkin: :-(
00:45:45 <Peaker> minsa: (:[])  means   (lambda (x) (cons x nil))
00:45:52 <minsa> @ty (:[]) (:[])
00:45:52 <lambdabot> forall a. [a -> [a]]
00:46:04 <Peaker> @type (:[]) . (:[])
00:46:05 <lambdabot> forall a. a -> [[a]]
00:46:08 <minsa> @ty (:[]) . (:[])
00:46:08 <lambdabot> forall a. a -> [[a]]
00:46:45 <Peaker> minsa: (.) is function composition..   if you take a value and use:       value : []      you get [value], a list with just that value in it.  so (:[]) is:   a -> [a].    If you do it twice, you get a->[[a]]
00:47:04 <minsa> ok.. thnx.
00:47:09 <monqy> > ((:[]) . (:[])) 5
00:47:10 <lambdabot>   [[5]]
00:49:06 <Peaker> > (5 : []) : []
00:49:06 <lambdabot>   [[5]]
00:49:20 <minsa> @type ((:[]) . (:[])) . (:[])
00:49:21 <lambdabot> forall a. a -> [[[a]]]
00:49:46 <minsa>  > (((:[]) . (:[])) . (:[])) 5
00:49:55 <minsa> > (((:[]) . (:[])) . (:[])) 5
00:49:56 <lambdabot>   [[[5]]]
00:50:45 <shachaf> @ty (((:[]).(:[]))(:[]))
00:50:46 <lambdabot> forall a. [[a -> [a]]]
00:50:51 <shachaf> @ty sequence(((:[]).(:[]))(:[]))
00:50:51 <lambdabot> forall a. [[a -> [a]]]
00:51:38 <minsa> (((:[]).(:[]))(:[])) 5
00:51:42 <minsa> > (((:[]).(:[]))(:[])) 5
00:51:42 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
00:53:51 * hackagebot erf 2.0.0.0 - The error function, erf, and related functions.  http://hackage.haskell.org/package/erf-2.0.0.0 (LennartAugustsson)
00:55:32 <frerich> heh, I think 'erf' is an awesome name for a function to yield errors.
00:56:42 <minsa> shachaf, you just replace 5 with (:[]) .
00:57:08 <minsa> @ty (:[])
00:57:08 <lambdabot> forall a. a -> [a]
00:57:11 <ddarius> It hopefully doesn't yield errors.
00:57:29 <erus`> if i have a function that draws a truangle to a buffer of pixels, and i pass the buffer and return a new one, is that gonna be really slow or will the compiler optimize it?
00:58:31 <pastorn> erus`: it depend on how the buffer is implemented
00:58:48 <pastorn> *depends
00:58:52 <erus`> a list of pixels
00:58:58 <pastorn> probably slow
00:59:21 <erus`> whats a uick way to store a fixed length list of items?
00:59:50 <pastorn> erus`: how many changes are you going to do on the list?
01:00:02 <pastorn> erus`: if you really want speed, look at ST
01:00:04 <erus`> from 0 to every item
01:00:08 <pastorn> and STArray
01:00:41 <pastorn> erus`: from the outside ST is pure, but once you're in the ST monad you have O(1) array writes
01:01:30 <erus`> can you point me to the api docs?
01:02:34 <Veinor> > map (const 8) [1..20]
01:02:35 <lambdabot>   [8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]
01:02:40 <Veinor> access will still be O(n) though ;)
01:03:16 <pastorn> @hoogle STArray
01:03:18 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
01:03:18 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
01:03:18 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
01:03:20 <pastorn> @hoogle ST
01:03:20 <lambdabot> module Control.Monad.ST
01:03:20 <lambdabot> module Data.Array.ST
01:03:20 <lambdabot> Control.Monad.ST data ST s a
01:03:34 <pastorn> erus`: http://haskell.org/hoogle
01:04:20 <erus`> pastorn: you just said ST so i assumed that was a shortened name for something
01:06:51 <pastorn> erus`: http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-ST.html
01:07:02 <pastorn> erus`: and at the bottom of that page, click on MArray
01:08:40 <erus`> @hoogle sleep
01:08:41 <lambdabot> No results found
01:09:39 <erus`> @hoogle threadSleep
01:09:39 <lambdabot> No results found
01:09:39 <pastorn> erus`: Control.Concurrent.threadDelay
01:09:45 <Peaker> I don't understand what this erf thing is
01:10:45 <Peaker> base >= 4 && < 10, hehe
01:22:58 * hackagebot hoogle 4.2.4 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.4 (NeilMitchell)
01:23:31 <Veinor> that reminds me
01:23:47 <Veinor> i need to see if i can write a patch to hoogle that allows a user to set cookies for their packages
01:32:04 <Xaratas> hi, i have a global search function implemented in two ways, one slow but correct and the other optimized. But the second version does not jield the same result. Would someone look at my code?
01:34:50 <quicksilver> Xaratas: nobody will look at it if you don't paste it :) Stick it in an hpaste and hopefully people will look.
01:35:09 <quicksilver> Xaratas: it would be best to include the example when the fast version gives the wrong answer.
01:37:58 <Xaratas> http://hpaste.org/47081/globalsearchhs @quicksillver here is the code
01:38:49 <Xaratas> example functions are at the bottom of GlobalSearch.hs -> testfunktion is ok, testfunktion2 not, queenTestSlow is ok, queenTest not
01:43:56 <frerich> Xaratas: hihi, abgabe tonight? ;-)
01:44:11 <fragamus> @type fromList
01:44:12 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
01:46:20 <Phyx-> dcoutts: Quick question, in the test-suite section of a Cabal file, are conditional statements allowed? The Cabal.cabal contains an reference to the unix package there which prevents it from building under windows. My guess is it should be "  if !os(windows){   Build-Depends: unix }" instead
01:47:16 <Xaratas> frerich: jep
02:01:56 <dcoutts> Phyx-: you're probably right. Though the code for that particular testsuite may require other changes on windows too.
02:05:25 <Phyx-> dcoutts: It did build without the dependency though, Didn't try running it
02:07:19 <dcoutts> Phyx-: oh right, ok, thanks for checking
02:41:17 <Xaratas> ?string -> int
02:41:17 <lambdabot> Unknown command, try @list
02:41:42 <Xaratas> how to convert a number sting like "22" to an int?
02:41:58 <shachaf> > read "22" :: Int
02:41:59 <lambdabot>   22
02:42:09 <shachaf> Note that that'll fail horribly if the argument isn't valid.
02:42:44 <Jafet> Only if there is no spoon
02:43:27 <Entroacceptor> > read "Sheep" ::Int
02:43:28 <lambdabot>   *Exception: Prelude.read: no parse
02:44:20 <shachaf> > rеad "Dog" :: Int
02:44:21 <lambdabot>   3
02:44:27 <shachaf> > rеad "Sheep" :: Int
02:44:28 <lambdabot>   5
02:44:54 <Entroacceptor> erm
02:45:10 <shachaf> > rеad "Snake" -- ?
02:45:11 <lambdabot>   0
02:45:14 <shachaf> Weird.
02:45:28 <Entroacceptor> you're cheating
02:45:49 <Entroacceptor> > read "schachaf" :: Maybe Int
02:45:49 <lambdabot>   *Exception: Prelude.read: no parse
02:46:12 <shachaf> You're not even spelling my name right.
02:46:19 <Phyx-> > reads "schachaf" :: Maybe Int
02:46:19 <Entroacceptor> I know
02:46:20 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
02:46:20 <lambdabot>         again...
02:46:30 <Phyx-> > reads "schachaf" :: [Int]
02:46:31 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
02:46:31 <lambdabot>         against inferred type ...
02:46:34 <Phyx-> :t reads
02:46:35 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:46:37 <Phyx-> ah
02:46:40 <Entroacceptor> can't you just change your name?
02:46:51 <Phyx-> > reads "schachaf" :: [(Maybe Int, String)]
02:46:52 <lambdabot>   []
02:47:45 <shachaf> > reаd "schachaf"
02:47:46 <lambdabot>   too difficult to read
02:47:55 <shachaf> > reаd "Entroacceptor"
02:47:56 <lambdabot>   Entroacceptor
02:48:29 <Jafet> > "Entroacceptor" == "Entroaccеptor"
02:48:30 <lambdabot>   False
02:50:20 <Xaratas> fredrich: have it fixed
02:50:55 <KitB> gtk2hsC2hs: System/GIO/Types.chi not found in:
02:51:03 <KitB> During cabal install
02:51:09 * hackagebot syb 0.3.1 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.3.1 (JosePedroMagalhaes)
02:51:11 <KitB> cabal install gtk
02:51:14 <KitB> should I say
02:51:29 <KitB> So uh
02:51:37 <KitB> Why won't the gtk package install?
02:52:05 <KitB> cabal also tells me I have indirect dependencies on different versions of packages for every single package
02:52:16 <KitB> When it lists them, they all depend on the same version
02:56:13 <Entroacceptor> shachaf: care to explain to me what you did with the poor bot?
02:56:23 <Entroacceptor> (see, I even wrote your name correctly!)
02:56:31 <Entroacceptor> I'm seriously a bit confused
02:56:33 <shachaf> Entroacceptor: Ask Jafet.
02:57:02 <Entroacceptor> Jafet?
02:57:26 <shachaf> (I used a Unicode word that looked a lot like "read".)
02:57:44 <shachaf> > ["read","rеad","reаd"]
02:57:45 <lambdabot>   ["read","r\1077ad","re\1072d"]
02:57:54 <erus`> >let double x = [0,2..] !! x in double 100000
02:57:56 <Entroacceptor> gnnnnnnnnnnnn
02:58:03 <erus`> > let double x = [0,2..] !! x in double 100000
02:58:04 <lambdabot>   200000
02:58:11 <erus`> hurr hurrr
03:00:37 <ClaudiusMaximus> there's a known algorithm to find efficiently all intersections within a set of line segments - is there something similar for efficiently finding all intersections between two sets of line segments (ignoring self-intersections within each set) or would i have to adapt the first algorithm for this purpose myself?
03:02:33 <erus`> ClaudiusMaximus: it can't be that hard to adapt the original ?
03:03:47 <ClaudiusMaximus> erus`: true, and i'm not sure if it's even what i want, thinking about it harder
03:06:12 <erus`> map (filter lineSetIntersection lines2) lines1
03:08:21 <erus`> is there anything in the prelude for writing image files? BMP or PNG or whatever?
03:08:24 <kuraj> splitAt((length xs) `div` 2) [1,2,3,4,5]
03:08:30 <kuraj> er
03:08:38 <kuraj> well
03:09:50 <stianhj> erus`, not in the prelude(?) .. http://hackage.haskell.org/package/bmp
03:09:57 <kuraj> why does "halve xs = splitAt((length xs) `div` 2) xs" work
03:10:05 <kuraj> but "halve xs = splitAt((length xs) / 2) xs" doesn't?
03:10:26 <erus`> kuraj: compiler error?
03:10:37 <kuraj> yes
03:10:46 <magicman> :t length
03:10:46 <lambdabot> forall a. [a] -> Int
03:10:51 <magicman> :t (/)
03:10:51 <lambdabot> forall a. (Fractional a) => a -> a -> a
03:10:54 <erus`> if so its because it isnt a dividable type i forget the name
03:11:00 <magicman> @instances Fractional
03:11:01 <lambdabot> Double, Float
03:11:11 <kuraj> derp
03:11:18 <magicman> :t div
03:11:18 <lambdabot> forall a. (Integral a) => a -> a -> a
03:11:21 <magicman> @instances Integral
03:11:22 <lambdabot> Int, Integer
03:13:24 <shachaf> http://correlate.googlelabs.com/search?e=haskell&t=weekly
03:13:30 <shachaf> Clearly this proves something.
03:13:49 * shachaf isn't sure what.
03:14:09 <erus`> wtf
03:14:16 <Twey> Haha
03:14:22 <Twey> Rockstar energy drink hats?
03:28:22 <erus`> Codec.BMP is easy to use :)
03:29:17 <ksf> http://www.aosabook.org/en/
03:29:41 <ksf> that'd be an awesome thing to have for haskell, too.
03:30:18 <ksf> while some stuff sure carries over, architecture in functional languages does tend to be different.
03:34:55 <poltak_> What environments do you guys program Haskell under?
03:35:26 <shachaf> poltak_: HOME=/home/shachaf
03:36:08 <ksf> vim.
03:38:12 <poltak_> shachaf: no, ksf: thank you
03:38:29 <shachaf> poltak_: What do you mean, no?
03:38:37 <shachaf> I assure you that's part of my environment.
03:38:43 <poltak_> no thanks to your answer
03:39:26 <ksf> heretic!
03:39:31 <shachaf> There's no need to be rude.
03:39:57 <Phyx-> so... there are 46 xml libraries.. anyone know a good one?
03:40:12 <merijn> Phyx-: There's no such thing as good XML libraries :p
03:40:41 <quicksilver> I quite like haxml.
03:40:44 <quicksilver> it depends what you're trying to do.
03:41:08 <Phyx-> I'm currently using my own, so i'm looking for something that allows me to construct xml values in a similair fashon http://pastebin.com/WcnrgALi
03:41:42 <Phyx-> quicksilver: I basically want to define serialization and deserialization code
03:41:49 <ksf> that's easy enough to translate to anything.
03:41:54 <poltak_> shachaf: I was NOT being rude! I just tell you this
03:43:18 <quicksilver> Phyx-: I don't know :( I've not tried to use XML in that kind of fashion. Sorry.
03:46:32 <Phyx-> Guess I should just finish my lib
03:46:55 <ksf> Phyx-: no, don't!
03:46:59 <ksf> yaks have to be shaved.
03:47:48 <Phyx-> lol, eh?
03:49:07 <ksf> http://www.catb.org/jargon/html/Y/yak-shaving.html
03:49:21 <ksf> the NIH syndrome is a myth.
03:49:48 <erus`> god damn opengl depth buffer doesnt work on my work pc
03:49:56 <erus`> gonna write my own software rasterizer
03:50:03 <merijn> It's only NIH syndrome when the alternatives don't suck :p
03:50:21 <ksf> alternatives suck by definition.
03:50:28 <Phyx-> ksf: if there aren't any libs that do what I want it's not really a yak :P
03:51:33 <brad_larsen> Is there already Haskell code out there to reinterpret an int as a float (e.g., like *(float *)&some_integer in C), or do I have to write the code myself?  Is there a way to do it without using the FFI?
03:52:13 <osfameron> brad_larsen: fromIntegral ?
03:52:29 <osfameron> or fromInteger
03:52:43 <quicksilver> brad_larsen: well obviously the haskell language doesn't define float format.
03:52:44 <Botje> brad_larsen: can't you determine that it's a float when you read it?
03:52:59 <quicksilver> brad_larsen: and reinterpret only works when the two types are the same number of bytes.
03:53:02 <ksf> Phyx-: fwiw, yours seems to be quite similar to a thing I once wrote: http://hpaste.org/47084/ebml_dtd
03:53:15 <quicksilver> brad_larsen: with those two caveats in mind, use the Ptr stuff.
03:53:23 <brad_larsen> quicksilver, I'm aware of the reinterpret restriction
03:53:30 <quicksilver> I thought you probably were.
03:53:41 <quicksilver> I was giving hints about why the haskell language doesn't provide the feature.
03:53:42 <brad_larsen> I have a case where I'm given a Haskell Int, but want to reinterpret it as a float.
03:53:47 <ksf> ...though it's actually supposed to parse real ebml dtds
03:53:52 <quicksilver> it's at the wrong level of abstraction for the language.
03:53:58 <quicksilver> the question only makes sense at the level of an ABI
03:54:04 <Phyx-> ksf: I also need the inverse though, from file >- datatype
03:54:08 <quicksilver> and the Ptr type is your interface to the C ABI
03:54:10 <brad_larsen> quicksilver, oh, absolutely.  I was just wondering if there is code to do said conversion, e.g., somewhere in the GHC API
03:54:10 <quicksilver> (in a sense)
03:54:27 <quicksilver> there's unsafeCoerce# but you better understand what it means ;)
03:54:28 <ksf> (real dtds being the place where it pulls the numerical tags for the identifiers from)
03:54:32 <quicksilver> the Ptr stuff feels 'safer'.
03:54:53 <Botje> you could pick apart the int yourself and build the float, but ..
03:55:12 <ksf> Phyx-: you're basically looking for a dtd definition that lets you generate a) something adt-like b) a parser c) an unparser
03:55:34 <ksf> or a sax interface instead of the dtd.
03:55:36 <ksf> er adt.
03:56:29 <ksf> the problem, I found, isn't the adt-compatible part, but further restrictions on the dtd
03:56:51 <Phyx-> ksf: dtd ?
03:57:16 <brad_larsen> I want to tweak the output of vacuum-cairo, as for certain types such as negative signed integers it doesn't display them properly
03:57:32 <ezyang> I'm looking for information on how GHC desugars 'data X a b = X !a b' into seqs. Anyone have any pointers?
03:57:36 <ksf> there's a dtd thingie designed but not finished by inria, which uses nested DFAs to specify structured data
03:57:43 <brad_larsen> as what it gets back from vacuum represents the value of a negative signed int as a Word
03:58:03 <ksf> Phyx-: document type definition
03:58:52 <Phyx-> ksf: yes... i don't get why you're refering to one in my case
03:59:11 <ksf> something that specifies, in full, what a valid document looks like, without containing any content itself
03:59:43 <ksf> (well, possibly default values, and it might be dependently-typed if you overkill)
03:59:53 <Phyx-> I know what dtds are
03:59:58 <Phyx-> but i'm not using one
04:00:05 <ksf> you *are* using one.
04:00:21 <SoleSoul> Hi. I am trying to write a haskell code which takes a file with some xml code, read a few lines, decide, according to a given grammar, that they should be labeled 'A', and surround them with the tag <A>. Continue to next few lines, decide what should be their name and surround them with a tag. I'm quite new to haskell and I feel I miss some tools to deal with it. Should I simply pass the whole file content from function to function a
04:00:31 <SoleSoul> is a recommended way to structure the application? Thank you very much for any advice.
04:00:40 <ksf> you're just not bidirectionalising it.
04:00:50 <Phyx-> ksf: I am not using a DTD
04:01:04 <erus`> http://judaism.stackexchange.com/questions/1184/computer-working-on-shabbos
04:01:05 <ksf> Phyx-: imagine running a TH function over your http://pastebin.com/WcnrgALi
04:01:43 <ksf> rather, two. one for the parser, and one for the unparser.
04:02:10 <brad_larsen> quicksilver, the docs says unsafeCoerce# is not safe to use to coerce floats and integrals
04:02:21 <brad_larsen> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:unsafeCoerce-35-
04:02:31 <ksf> add a third to generate code to access the data programmatically.
04:02:35 <brad_larsen> I'll have to think about things.
04:03:57 <quicksilver> brad_larsen: I gave you the answer! Use the Ptr stuff.
04:04:11 <brad_larsen> quicksilver, yes, thank you!  I was just saying.  :-)
04:04:44 <ksf> hey, they added docs.
04:04:53 <Botje> SoleSoul: you got cut off after 'should i simply pass the whole ..'
04:05:09 <ksf> brad_larsen: it should be just fine in compiled programs
04:05:15 <ksf> ...at least last time I tried it was
04:05:46 <ksf> in interpreted code, though, pointer tags will show themselves quite randomly
04:05:56 <SoleSoul> Should I simply pass the whole file content from function to function and push tags in-between or maybe this kind of problem has a name and there is a recommended way to structure the application? Thank you very much for any advice.
04:06:10 <SoleSoul> Botje: Thanks
04:06:53 <Botje> SoleSoul: for xml I would use an xml parser
04:06:59 <Botje> but ive never done that before in haskell so ..
04:07:16 <ksf> SoleSoul: depends. do you want to stream your data, do you need random access, or do you not care+
04:07:19 <ksf> ?
04:07:51 <SoleSoul> I don't think I care. there is an input file and an output file.
04:08:32 <SoleSoul> it is basically parsing according to grammar
04:08:40 <ksf> ...then just operate on the whole beast at a time.
04:09:17 <Phyx-> ksf: that seems like a pretty roundabout way of doing it, which also requires me to learn TH
04:09:21 <SoleSoul> the functional thinking is a bit new for me so I am having hard time to think of a proper structure for such a parser
04:09:46 <ksf> Phyx-: well, you can also implement it without TH.
04:09:57 <Botje> SoleSoul: input, modify, output
04:09:57 <Phyx-> ksf: my current solution is just to define serialization interfaces for datatypes, and just have a backtracking parser
04:10:05 <Botje> that's what you do in imperative programs as well :)
04:10:19 <ksf> generating code from an description and writing code that is parametrised by a description are essentially the same.
04:11:18 <SoleSoul> Botje: problem is, I can't change the string I have inside a function as in imperative languages. I have to pass it to a function.
04:11:39 <SoleSoul> and get the return value and operate on it
04:12:27 <Eliel> ah, no, not operate, that sounds like changing it.
04:12:55 <Eliel> I think of data flow when I form my code.
04:12:59 <ksf> you're not supposed to change your file, you're supposed to generate a new one depending on the old one.
04:13:07 <Eliel> functions as pipes that take data in and give data out
04:13:38 <Eliel> how to connect them so they do the job
04:13:51 <SoleSoul> Botje: in an imperative language I would have done something like: decide -> add opening tag -> let other functions change the content in the middle -> add closing tag.
04:13:52 <ksf> ...which is more efficient than you think because the old and new versions of your data share their common subparts.
04:14:02 <ksf> consider, for example
04:14:17 <SoleSoul> ksf: good to know
04:14:17 <ksf> foo xs = 'a':xs
04:14:43 <SoleSoul> xs will be kept in memory once?
04:15:02 <ksf> foo "bar" is "abar", and both strings end up sharing the 'b':'a':'r':[] part.
04:15:16 <SoleSoul> didn't know that
04:15:33 <SoleSoul> I just had faith in ghc :)
04:17:29 <kuraj> can someone please help me with understanding this? http://pastebin.com/Q6mA2bHy
04:17:36 <kuraj> im having trouble figuring out what cross does
04:18:16 <ksf> kuraj: just look at the type, it says all.
04:18:38 <pastorn> kuraj: first off you should keep all your code at the same indentation level (unless it's in a "where")
04:18:46 <kuraj> ksf: not to someone who is fairly new to functional programming and haskell :(
04:19:04 <kuraj> what i do know is that the "." operator combines two functions
04:19:32 <ksf> ...it takes a tuple of functions, a tuple, and results in both functions in the first tuple applied to the stuff inside the second tuple.
04:20:42 <kuraj> oh i think i do see it now
04:20:45 <ksf> :t cross (f,g) (x,y) = (f x, g y)
04:20:46 <lambdabot> parse error on input `='
04:20:54 <ksf> :t \(f,g) (x,y) -> (f x, g y)
04:20:55 <lambdabot> forall t t1 t2 t3. (t -> t2, t1 -> t3) -> (t, t1) -> (t2, t3)
04:21:39 * ksf thinks the clarity of that code is questionable.
04:22:02 <ksf> in the category of "too smart for the trivial thing it does"
04:22:10 <shachaf> @ty \(f,g) -> (f.fst)&&&(g.snd)
04:22:10 <lambdabot> forall a c b c'. (a -> c, b -> c') -> (a, b) -> (c, c')
04:23:04 <ksf> rarely-used abstractions are quite often the wrong abstractions.
04:24:50 <kuraj> its the f.fst and g.snd part that confuses me
04:25:27 <ksf> :t \f -> f . fst
04:25:28 <lambdabot> forall a b b1. (a -> b) -> (a, b1) -> b
04:26:01 <int-e> > (succ *** pred) (1, 4)
04:26:02 <lambdabot>   (2,3)
04:26:04 <ksf> that's the easy part. the harder part is seeing that &&& distributes its third argument over its first and second.
04:26:46 <kuraj> oh dear
04:26:47 <ksf> in short, utterly evil persons are trying to confuse you with arrows.
04:26:57 <kuraj> that would be my supervisior
04:27:04 <int-e> not 'confuse', 'shoot'.
04:27:12 <ksf> shachaf is your supervisor?
04:27:56 <kuraj> now that i think about it, i wouldnt be surprised at all if he was a visitor of this irc channel
04:28:30 * ksf suggests #haskell-closet-supervisors
04:29:22 <kuraj> oh dear..
04:29:35 <erus`> is anyone else on github?
04:29:44 <kuraj> i wrote the halve and merge functions because i knew what they have to do, but i really don
04:30:07 <kuraj> dont understand whats happening in the inside
04:30:17 <kuraj> the msort function
04:30:17 <develhevel> i have a function like: "[String] -> (String,String)" now i get a empty list how to return a empty ()? like: "foo [] = ?"
04:30:43 <int-e> develhevel: you can't. ("", "") may be reasonable.
04:31:01 <int-e> develhevel: but it really depends on what the function is supposed to do.
04:31:01 <ksf> kuraj: don't worry too much, if you derived it from the type and specs, and works as intended, everything's fine.
04:31:22 <int-e> develhevel: depending on that, perhaps the type is wrong.
04:31:35 <kuraj> ksf: thats what i was thinking a week ago :)
04:31:37 <ksf> -> Maybe (String, String)
04:31:56 <kuraj> i was given a bunch of fairly simple tasks that involved "designing a function that does things"
04:32:05 <kuraj> so i did
04:32:19 <ksf> and you suceeded in semantical reasoning.
04:32:19 <kuraj> but the supervisior insisted on formally proving that these two are in fact identical
04:32:37 <ksf> seems like a supervisor that doesn't much care about operational details.
04:32:53 <develhevel> ok i will explain it better: foo :: [String] -> (String, String) then i got foo (x:xs) = do ... and i have foo [] = ... dont know how to make the output at the end of the list []
04:33:19 <kuraj> we ended up spending 30 minutes of formal proof for each of those
04:33:33 <kuraj> ;_;
04:33:57 <ksf> well, types are prepositions and programs are proofs.
04:34:25 <kuraj> i think he just really wants us to understand typing
04:34:40 <kuraj> and thats not a bad thing at all
04:35:02 <ksf> (though arguably haskell types are quite underspecified, with say agda you could write a function "List a -> SortedList a" and have the compiler verify that the list is, indeed, sorted)
04:35:57 <kuraj> ok so
04:36:10 <kuraj> here im trying to interpret that again
04:36:37 <SoleSoul> in order to turn three "string" into ["string", "string", "string"], must I do ["string"] ++ ["string"] ++ ["string"] ? is there a more elegant way?
04:37:16 <ksf> > replicate 3 "string"
04:37:17 <lambdabot>   ["string","string","string"]
04:37:35 <SoleSoul> ah, they are not necesarrily the same
04:37:47 <SoleSoul> sorry for misexplaining
04:38:03 <sjoerd_visscher> SoleSoul: what's wrong with just ["string", "string", "string"]
04:38:21 <ksf> > let f x y z = [x,y,z] in f "a" "b" "c"
04:38:22 <lambdabot>   ["a","b","c"]
04:38:38 <SoleSoul> sjoerd_visscher: oh, the simplicity.... stupid me
04:38:43 <ksf> > let f x y z = x:y:z:[] in f "a" "b" "c"
04:38:44 <lambdabot>   ["a","b","c"]
04:39:12 <SoleSoul> "string" : "string" : "string" : []
04:39:16 <SoleSoul> > "string" : "string" : "string" : []
04:39:17 <lambdabot>   ["string","string","string"]
04:39:19 <SoleSoul> >"string" : "string" : "string" : []
04:39:37 <SoleSoul> ksf: thanks! that's what I was looking for
04:43:48 <kuraj> OHHHHHHHHHH
04:43:51 <kuraj> I GET IT
04:44:27 <ezyang> Hmm. Fusion doesn't play nice with spine-strict structures.
04:44:30 <ksf> the rapture is here!
04:44:35 <kuraj> halve $ xs returns two elements, the 1st and the 2nd element of the list
04:44:40 <ksf> lambda be blessed!
04:44:52 <kuraj> so cross(msort,msort)
04:45:14 <kuraj> applies msort to both halves
04:45:35 <merijn> kuraj: Sounds right from what I've glanced just now
04:45:50 <kuraj> dont get me wrong, i do know how mergesort works
04:46:06 <merijn> kuraj: It's not you, though. I would say that code is not very clear
04:46:10 <kuraj> i just had a really hard time figuring out this thing because apparently i started from the wrong part
04:46:18 <kuraj> ok so
04:46:59 <ksf> yep. the next steps would be refactoring the code to be more obvious, and then to grok how that implementation manages to be actually, real-world, efficient.
04:47:28 <merijn> ksf: I grok how haskell code manages to be efficient! The answer is magic! :D
04:48:05 <kuraj> meh
04:48:13 <kuraj> the dot operator still gives me shivers when I see it
04:48:19 <ksf> implementing a compiler by sending emails to oleg to mind-compile things isn't magic.
04:48:27 <merijn> kuraj: It's not that hard, think of it as a pipeline
04:48:28 <ksf> @src (.)
04:48:29 <lambdabot> (f . g) x = f (g x)
04:48:29 <lambdabot> NB: In lambdabot,  (.) = fmap
04:48:52 <ksf> left-to-right shell |, that is.
04:48:53 <merijn> kuraj: To put it into shell terms "f . g" is the same as "g | f"
04:49:43 * ksf decides to write his next shell script with first-order functions.
04:49:52 <kuraj> so (f . g) x equals... f $g$x?
04:50:16 <merijn> kuraj: Yes
04:50:30 <merijn> Except that the . lets you leave out the x
04:50:35 <kuraj> aha
04:50:53 <merijn> (f . g) == \x -> f $ g $ x
04:51:28 <merijn> Just take another look at its type signature now and see if you understand it
04:51:29 <kuraj> so "merge . cross (msort, msort) . halve $ xs" essentually equals "merge $ cross(msort,msort) $ halve $ xs"
04:51:31 <merijn> :t (.)
04:51:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:51:40 <merijn> oh, damn
04:51:43 <merijn> Stupid lambdabot
04:51:52 <merijn> How do I get the understandable signature?
04:52:10 <kuraj> well, that was fairly confusing
04:52:26 <kuraj> i should have read that richard book i DID manage to get in the end
04:52:26 <merijn> Ignore that one, I meant this one: (.) :: (b -> c) -> (a -> b) -> a -> c
04:52:32 <ksf> :t (Prelude..)
04:52:33 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:52:45 <ksf> (oh how I hate that syntax)
04:53:17 <ksf> (b -> c) -> (a -> b) -> (a -> c) might be easier to read.
04:53:27 <kuraj> ksf: i afree
04:53:29 <kuraj> agree*
04:53:43 <ksf> or, rather, their equivalence is what makes that approach rock.
04:53:45 <kuraj> now that looks like the very definition of what a function combination is
04:53:59 <merijn> kuraj: Because it is, of course ;)
04:54:01 <kuraj> in laymans terms
04:54:06 <kuraj> (well almost)
04:54:10 <Twey> @index runReaderT
04:54:10 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
04:54:43 <ksf> the functor thing is the same stuff when you insert (->) for f
04:55:16 <merijn> kuraj: If you're looking for a nice book (and no one told you yet) Learn You a Haskell is excellent and Real World Haskell is a nice more advanced/practical one
04:55:32 <kuraj> i do read learn you a haskell
04:55:42 <kuraj> it seems really friendly, actually
04:56:22 <kuraj> but im not sure its sufficient to what i have to go through... our supervisior has a really formal approach
04:56:40 <kuraj> we pretty much skipped the basics because we learned prolog in the first place
04:57:30 <kuraj> (read: no tasks like "write a function that reverses a list")
04:57:35 <kuraj> :D
04:57:50 <ksf> it never hurts to learn the theoretical foundations, but it doesn't hurt to learn hacking, either.
04:58:02 <kuraj> whats funny, our prolog course almost exclusively consisted of simple stuff like that, and we all kept having problems with it
04:58:17 <kuraj> most of us actually learned prolog only when we started doing our first major assignment
04:58:28 <merijn> kuraj: Once you get slightly further in LYAH it quickly ramps up to more advanced based on more formal things (functors, applicative, etc)
04:58:41 <kuraj> i see
04:58:58 <merijn> And understanding how to code with them helps a lot in understanding the type system (in my experience anyway)
04:59:21 <kuraj> well
04:59:30 <kuraj> haskell introduced me to lambda notation
05:00:11 <kuraj> and now i find it pretty fun to use with other programming languages
05:00:22 <kuraj> that i didnt even know they supported it
05:00:42 <kuraj> ok moving on to the next task
05:00:43 <merijn> Anonymous functions are our friends :)
05:01:08 <kuraj> i also heard theyre soon to be introduced to c++
05:01:14 <Silvah> kuraj: yeah
05:01:26 <Twey> Gr
05:01:27 <kuraj> (it wont make me despise c++ any less)
05:01:41 <ksf> but c++ only ever introduces stuff to make it less usable.
05:01:41 <Silvah> kuraj: But the syntax will be horrible (not that it's very different from the other parts of C++ syntax).
05:01:47 <ksf> it's just a back-handed intercal.
05:01:56 <Twey> Why does haskell-mode wrap Haddock comments wrongly?  It always repeats the introduction character
05:01:57 <kuraj> c++ syntax IS horrible
05:02:09 <Twey> Which Haddock faithfully reproduces in the documentation >.>
05:02:32 <merijn> With the existence of Go I find it hard to justify the continued use of C++ :p
05:02:40 <ksf> Twey: because it uses eight megabytes and continuously swaps.
05:03:02 <Twey> ksf: Eight megabytes?! *gasp*
05:03:38 <kuraj> i think the only thing in favor of c++ these days are its low level features
05:03:48 <Silvah> kuraj: so why not C, then?
05:03:57 <kuraj> and semi object oriented model
05:03:59 <kuraj> i was going to mention
05:04:00 <merijn> C is better in that case :p
05:04:03 <kuraj> because yes
05:04:12 <kuraj> i know and u se C
05:04:13 <kuraj> :p
05:04:15 <Silvah> ksf: yeah, but it lacks COME FROM.
05:04:24 <Twey> Factor does it better >.>
05:04:32 <companion_cube> the good feature of C++ is the specialization in templates
05:04:37 <Twey> Hahahah
05:04:49 <merijn> Twey: Factor is still on my "to potentially learn" list, worth the effort?
05:04:53 <kuraj> hmm
05:04:54 <kuraj> ok
05:04:55 <Twey> merijn: Yeah, I'd say so
05:05:01 <Silvah> kuraj: have you read the C++ FQA?
05:05:07 <kuraj> i have to design a function that will generate an infinite list of tuples
05:05:29 <Twey> merijn: It's still young, but Slava has done a crapton of work on it — it has loads more libraries than you'd expect
05:05:41 <kuraj> that goes like (0,0), (0,1), (1,0), (0,2), (1,1), (2,0)... and so on
05:05:49 <Twey> And it is a neat language.
05:05:53 <Twey> I miss my types though.  ☺
05:05:56 <Silvah> Dynamically typed.
05:06:06 <Silvah> IOW, everything but neat.
05:06:17 <kuraj> so.. all tuples sum of which equals 0, then 1, then 2, then 3
05:06:20 <Twey> Well, it's neat for a language that isn't Haskell.  :þ
05:06:26 <kuraj> (sum of the 1st and second element of each)
05:06:35 <merijn> My goal is to eventually know at least: C, Python, Haskell, Go, Racket, Clojure, Forth, Factor and J (got the first two covered, my Haskell is becoming reasonable and I'm well under way with Go)
05:06:49 <Twey> Go doesn't seem that worthwhile
05:06:57 <merijn> Twey: Why not?
05:06:59 <Silvah> My goal is to know no languages at all. Too bad it's too late for that now.
05:07:10 <Twey> It doesn't really do anything that new :-\
05:07:19 <Twey> It's just Yet Another Imperative Language
05:07:25 <merijn> Twey: I also need to know language to get stuff done in :p
05:07:38 <merijn> What I've learned so far makes it everything I wanted C to be :p
05:07:43 <Twey> You can do that with a combination of the other languages :þ
05:08:15 <merijn> Twey: The upside of being Yet Another Imperative Language is that it is fairly trivial to pick up :p
05:08:15 <Twey> They ought to all be languages to get stuff done in
05:08:20 <Twey> Apart from J, maybe
05:08:54 <merijn> I'm fairly confident I can write usable Go code in half a week if I have a syntax reference nearby :p
05:09:26 <Silvah> merijn: The downside of being YAIL is that it is pretty boring.
05:09:30 <merijn> Oh, I've been told I should learn Chapel as well
05:09:41 <Silvah> Any good Go compilers?
05:09:42 <Twey> I haven't tried Chapel
05:10:54 <mm_freak> i'd prefer C++ over C for most applications
05:10:59 <mm_freak> if not all
05:11:10 <Twey> >.>
05:11:13 <merijn> I need to come up with some actual stuff to write in the languages I learn, though >.>
05:11:15 <develhevel> when i'm working with do notation and i want to make a if ... then .. else .. can i make a new do in then? i mean if ... then do ... else ...
05:11:25 <erus`> is there a fixed length list/array type?
05:11:27 <merijn> develhevel: Yes
05:11:31 <Silvah> mm_freak: heresy!
05:11:35 <erus`> thats optimized?
05:11:47 <merijn> develhevel: That's actually pretty common
05:12:05 <Twey> erus`: There are several
05:12:35 <mm_freak> well, honestly i see no reason to prefer C over C++
05:12:43 <mm_freak> it's just less than C++
05:12:45 <merijn> I never know what to actually code, "limitless power at the tips of my fingers!!!! so...now what do I do..."
05:12:56 <mm_freak> less powerful, less safe, etc.
05:13:05 <Silvah> mm_freak: C compiles pretty quickly. C++ compiles sssssssssssssssssssllllllllllllllllllloooooooooooooooooooooooowwwwwwwwwwwwwwwllllllllllllllllllllyyyyyyyyyyyyyyyyyyyyyyyyy.
05:13:09 <erus`> twey is using a list gonna be really slow? like checking for bounds every time i access an element?
05:13:19 <obbele> Hi everyone, I'm looking at the "monoids and word numbers" solutions to the ITA problem and can't make a sense of the Module or Derive data types, can anyone explain why, oh why, is Leibniz's rule used ?
05:13:22 <mm_freak> and normally i don't use languages, which even lack exceptions
05:13:34 <obbele> ( ref: http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers2/ )
05:14:06 <Twey> erus`: Lists are for iterating over
05:14:15 <mm_freak> Silvah: so?  i prefer slower compilation over a less powerful language
05:14:15 <mm_freak> that's why i use haskell
05:14:16 <mm_freak> with the same argument you should prefer C over most high level languages
05:14:17 <mm_freak> probably all
05:14:20 <obbele> mm_freak: you can write FFI code for C, whereas for C++, it's still a pita (and there is no binding to Qt4 for example ,)
05:14:30 <Twey> A list does not have/do bounds checking: it's not relevant.  It's a singly-linked list, not an array.
05:14:42 <merijn> erus`: Lists are linked lists, they not really meant to access by index
05:14:45 <Silvah> mm_freak: you prefer waiting ten years for the code to compile than waiting ten seconds? Oh well.
05:14:49 <Twey> If you want an array, use one of the array types, like IArray, MArray, or STArray.
05:14:51 <merijn> erus`: There is an array implementation, though
05:15:00 <mm_freak> obbele: i'm assuming that i don't have haskell in that statement…  if i had to choose between C and C++, i'd choose C++
05:15:10 <merijn> mm_freak: I would call lack of exceptions a feature
05:17:15 <Silvah> mm_freak: FFI is not only a Haskell "feature", almost all practical languages have some form of FFI, and it's almost always calling/being called from C code, not C++.
05:17:39 <mm_freak_> 426 143018 <mm_freak> merijn: i'd agree, if C had algebraic types or something
05:17:40 <mm_freak_> 426 143032 <mm_freak> Silvah: first of all it's not ten years…  g++ ran through hundreds of source files in a few seconds for me…  not much slower than gcc
05:17:42 <mm_freak_> 426 143041 <mm_freak> it always depends on how complicated your class hierarchy is
05:18:52 <Silvah> mm_freak_: http://en.wikipedia.org/wiki/Hyperbole
05:19:01 <frerich> kuraj : Something like http://hpaste.org/47085/listofpairs ?
05:19:06 <mm_freak_> merijn: problem with the lack of exceptions in C is that there is no sane way to tell an error from an ordinary result, so you have to encode language logic as application logic, which is very bad
05:19:17 <Silvah> Apart from that, try that with some template-heavy code (oh hai, boost!).
05:19:48 <mm_freak_> in haskell lack of exceptions would be fine, because exceptions can be encoded as algebraic types
05:20:34 <mm_freak_> Silvah: really in C++ i mostly use classes only for encapsulation, some polymorphism and other than that i practically write C code with exceptions
05:21:21 <gienah> obbele: qt4 haskell binding: http://qthaskell.berlios.de/
05:21:22 <merijn> mm_freak_: Yes, but the proper solution is multiple return values like Go (or ADT's so we can have Maybe, etc), not exceptions
05:21:45 <Silvah> mm_freak_: you can achieve the same thing in C (with the nice bonus of less frequent recompilation), except for non-local gotos that you're calling "exceptions".
05:23:24 <frerich> Silvah: When throwing an exception, you don't know who handles it (unlike with goto, where the caller has to define the destination). That's the decoupling part about them. Furthermore, all stack frames get properly destructed. So there's quite a difference between non-local gotos (which you could have with setjmp/longjmp) and exceptions.
05:23:33 <mm_freak_> merijn: would you vote for removing "continue", "break" and "return" from C?
05:23:52 <obbele> gienah: I though the Qt bindings was still highly experimental and partial (and closed source too, but that's another issue)
05:23:53 <Silvah> frerich: I assure you I know how exceptions work.
05:24:39 <aavogt> Silvah: how do they work?
05:24:42 <merijn> mm_freak_: No, but unlike exceptions people *know* those are dangerous
05:24:43 <mm_freak_> Silvah: exceptions allow you to separate concerns:  ordinary work flow and exceptional conditions
05:24:49 <mm_freak_> you would just open a file and use it
05:24:59 <Twey> Tagged unions + continuations > exceptions
05:24:59 <merijn> mm_freak_: The biggest problem with exceptions is that people don't realize how impossibly tricky they are
05:25:03 <mm_freak_> you don't want to care at every tiny step, whether something has failed
05:25:10 <mm_freak_> in C you /have/ to do that
05:25:21 <mm_freak_> that's why exceptions are useful
05:25:22 <Twey> This is true
05:25:25 <merijn> mm_freak_: I think Go's defer/panic is a nice model
05:25:31 <merijn> s/nice/nicer
05:25:41 <mm_freak_> that's why the monadic interface of Maybe is useful
05:25:43 <mm_freak_> or of Either
05:25:45 <mm_freak_> or ErrorT
05:25:46 <mm_freak_> etc.
05:26:06 <mm_freak_> merijn: i don't know that one
05:26:17 <mm_freak_> but exceptions are the best you can get in C/C++
05:26:30 <gienah> obbele: qthaskell is in the gentoo overlay, it compiles and works on little examples last time I tried it
05:26:35 <mm_freak_> unless you prefer signals over language constructs, of course =)
05:26:57 <mm_freak_> merijn: what's so tricky about exceptions?
05:26:59 <Silvah> aavogt: well, it depends on implementation (SEH? setjmp/longjmp? DWARF2?), of course. But it all boils down to unwinding the stack (based on some data lying somewhere) and then passing the execution to the handler.
05:27:21 <mm_freak_> merijn: if you're saying that exceptions are tricky, then you have to admit that 'break', 'continue' and 'return' are tricky, too
05:27:25 <mm_freak_> because they are exceptions, too
05:27:59 <Silvah> mm_freak_: how so?
05:28:00 <Phyx-> I feel weird writing parsers in an imperative language
05:28:03 <Phyx-> feels so unnatural
05:28:08 <merijn> mm_freak_: They are either invisible (if the language doesn't require you to specify what can throw what) or you have to always specify them thus not really saving you the overhead of dealing with them
05:28:13 <Silvah> break, continue and return are identifiers like all the other.
05:28:23 <merijn> mm_freak_: break continue and return are all restricted to the local scope
05:28:28 <merijn> exceptions are not
05:28:32 <Silvah> Phyx-: I actually find it easier to write parser in an imperative language ;)
05:28:33 <slom> mm_freak_: the special thing with exceptions is that they "jump" over returns
05:28:47 <Twey> Silvah: Parsec?  :þ
05:28:47 <mm_freak_> Silvah: they all break out of the code flow
05:28:54 * frerich cannot believe people are still argueing over the benefits of exceptions in 2011.
05:28:54 <Phyx-> Silvah: I was thought using functional languages, which is the difference I think
05:28:54 <MaskRay> Is there any sorting library utilizing MArray instead of List?
05:29:08 <Phyx-> taught*
05:29:15 <Silvah> mm_freak_: what?
05:29:25 <Twey> frerich: Exceptions are great when your language isn't powerful enough to make using proper return types feasible ;)
05:29:30 <Silvah> > return 5 :: [Int]
05:29:31 <lambdabot>   [5]
05:29:39 <Silvah> How does that break out of the code flow?
05:29:47 <slom> Sil
05:29:57 <mm_freak_> Silvah: 'continue' corresponds to 'throw' and 'for' corresponds to try/catch
05:30:05 <slom> Silvah: he means return statements
05:30:12 <frerich> Twey: Yes, of course. Comparing C++ to anything like you describe is unfair though. ;-)
05:30:19 <slom> mm
05:30:21 <mm_freak_> and 'return' corresponds to throw and the function corresponds to try/catch
05:30:22 <Twey> Heheh.
05:30:33 <merijn> mm_freak_: The defer/panic model is: defer pushes an expression on a stack on return of the function (no matter how/where) all defer's are popped from the stack and executed. Panic unrolls your entire function stack (calling all defer's on the way) until it hits the main function where your program aborts. There is a third function (forgot the name) which stops panic from unrolling the stack further (which can obviously only be called in a
05:30:34 <merijn> defer)
05:31:10 <mm_freak_> merijn: i don't understand that
05:31:26 <slom> mm_freak_:  that would be the same as saying that functions are equal to gotos
05:31:41 <Silvah> mm_freak_: fortunately compiler writers don't think that break/continue/return have anything to do with exceptions.
05:31:51 <mm_freak_> Silvah: just so you see how unnatural return/break/continue are:  in haskell the most natural way to encode them is through the Cont monad
05:32:25 <hpc> doesn't that really express how unnatural Cont is? :P
05:32:26 <mm_freak_> only the last 'return' in a function doesn't need this
05:32:36 <mm_freak_> hpc: no, how powerful =)
05:32:40 <Silvah> mm_freak_: it depends on POV, for me, continuations are *far* more unnatural.
05:32:49 <slom> mm_freak_: the most natural way in haskell to modell continue is to return a value instead of tail-calling
05:32:52 <mm_freak_> i use CPS a lot
05:33:09 <merijn> mm_freak_: Like: "func foo() { file = openFile(); defer closeFile(file); /* do stuff */}" the closeFile function will always be executed on function exit (even if you decide to panic) which means you can return on exit condition without worrying about calling the proper cleanup code because defer will make sure they are called
05:33:13 <Twey> Continuations are a fairly natural result of functional programming
05:33:24 <Twey> Exceptions are magic bolt-ons
05:33:28 <Twey> :þ
05:34:05 <slom> s\continue\break
05:34:48 <Silvah> mm_freak_: I hope you know the costs associated with using exceptions?
05:35:12 <frerich> merijn: Sounds like the 'bracket' function in Haskell.
05:35:12 <Silvah> (in case of C++)
05:35:36 <merijn> frerich: It has the same goal, yes
05:36:09 <merijn> Actually, they're mostly the same now that I think about it
05:36:19 <haja> Hi. I try to create a GtkTreeView with a GtkListModel using glade. Do I have to create the mapping from the model to the view entirely in haskell-code, or is it possible to use column definitions with CellRenderers from glade?
05:36:33 <frerich> Silvah: The runtime cost imposed by the additional bookkeeping required by exceptions is much lower than the cost imposed by mixing error handling and business logic plus the cost imposed by developers deliberately (or not) ignoring return values. :-}
05:36:46 <Silvah> frerich: false.
05:37:11 <merijn> Except you need some language magic in non-lazy languages to make it happen
05:37:34 <Silvah> Exceptions in C+
05:37:39 <mm_freak_> Silvah: i don't care about the costs, to be honest
05:37:39 <Silvah> err
05:37:57 <mm_freak_> if return takes one microsecond and throw takes ten, that's fine for me
05:38:04 <hpc> frerich: the cost imposed by having exceptions transcend types is more than the cost of making your own, that does what you want and forces you to handle things sanely
05:38:28 <Silvah> Exceptions in C++ are *very* *very* *very* expensive (at least for most compilers).
05:38:51 <Silvah> And it's not at all about throw - it's the cost exceptions impose when you just *turn them on*.
05:39:19 <Silvah> And if you don't care about the costs, you're wasting you time using C++, you'd better be off using something safer and easier.
05:39:20 <mm_freak_> merijn: that seems like a great way of dealing with that, but how do you encode exceptions?
05:39:34 <Silvah> your*
05:39:43 <mm_freak_> so far i see only a clean way to do cleanup
05:40:04 <mm_freak_> Silvah: exceptions have never been my bottleneck
05:40:16 <Silvah> mm_freak_: well, same here.
05:40:21 <quicksilver> Silvah: you are talking rubbish.
05:40:23 <mm_freak_> i think that's pretty reasonable, since i throw exceptions only, when, well, there is an exception =)
05:40:38 <quicksilver> Silvah: exceptions are zero-cost in the 'not thrown' case on modern C++ compilers.
05:40:44 * ksf thinks haskell should make exceptions optional, too.
05:40:54 <ksf> that is, move them to the library level.
05:40:55 <Silvah> quicksilver: Microsoft's compiler is not a modern one, then?
05:41:06 <Silvah> Intel's one (on Windows) is not a modern one, too?
05:41:18 <merijn> ksf: How do you do that?
05:41:27 <merijn> ksf: At some point you need to be able to handle an Out of Memory exception
05:41:34 <Silvah> Heck, all compilers on Windows (except GCC) are not modern ones, yeah?
05:41:36 <ksf> no, you don't.
05:41:45 <ksf> that's a signal.
05:42:21 <merijn> Of course OoM exception can't happen all machines, linux will just start killing stuff for example :p
05:43:12 <ksf> there once were programs that tried to clean up space when they got an OOM, but that's a thing of the past
05:43:16 <ksf> ...or embedded programming.
05:43:31 <joe6> what is OOM?
05:43:37 <merijn> joe6: Out of Memory
05:43:48 <merijn> ksf: Mostly OS overcommit is to blame for that
05:44:49 <ksf> # free -m | grep Swap
05:44:50 <ksf> Swap:        47692        140      4755
05:45:04 <ksf> oh, there's a 1 missing at the end.
05:45:11 <mm_freak_> ksf: exceptions in haskell are on the library level, i think
05:45:32 <ksf> there's no way that'll ever run full, because I'd kill the offending process manually, first.
05:45:56 <ksf> it's easy to get bored while a program fills nearly 50gigs of swap.
05:46:13 <ksf> mm_freak_: not all of them
05:46:34 <mm_freak_> ksf: well, of course there is no non-magic way to write 'error'
05:46:35 <merijn> Here I am with my 4GB or so swap thinking that's a lot... :>
05:46:50 <ksf> mm_freak_: that doesn't need to be catchable, though.
05:46:57 <ksf> and isn't *intended* to be, anyway.
05:47:11 <Silvah> quicksilver: uh, and even then - do you know that turning on exceptions can make Boost.MultiArray (it happened when I've used it last time) run three times slower, *even though* the used compiler uses "zero"-cost unwinding?
05:47:12 <mm_freak_> ksf: well, IO exceptions are side effects
05:47:30 <Silvah> That's what you call zero-cost? Bad.
05:47:44 <ksf> mm_freak_: you cat put them all into return values of IO actions.
05:47:46 <quicksilver> Silvah: no, not very ;) They're clunky and legacy. However, even the cost on them shouldn't be too much; some bloke from MS did a long presentation about it which I can no longer find.
05:48:03 <quicksilver> Silvah: well, Boost is Boost - it does weird stuff which normal code doesn't touch.
05:48:05 <mm_freak_> ksf: then they are not exceptions anymore
05:48:13 <ksf> exactly.
05:48:26 <Silvah> quicksilver: I can't agree that they're clunky and legacy.
05:48:26 <ksf> but then you can implement an ErrorT or something on top of it
05:48:50 <Silvah> They're probably the best tools for Windows.
05:48:57 <mm_freak_> ksf: what i wanted to say is that IO is allowed to catch 'error' and 'undefined' exceptions in some sense
05:49:02 <koeien> I don't understand why attoparsec gives the following results: http://hpaste.org/47086/weird_attoparsec_behavior . can somebody take a look?
05:49:13 <Silvah> quicksilver: Boost is also what normal code often uses.
05:49:41 <ksf> mm_freak_: which is an abysmally bad idea.
05:50:15 <mm_freak_> koeien: what i find weird about that is that it actually gives you a Done
05:50:30 <mm_freak_> otherwise i don't know what exactly you find weird
05:50:39 <ksf> boost hides fundamental design flaws with superficial ones.
05:50:45 <mm_freak_> ksf: why?
05:50:46 <Silvah> quicksilver: ...well, they use zero-cost unwinding on x64, because that's what's provided by the OS.
05:50:52 <ksf> mm_freak_: laziness.
05:51:04 <koeien> mm_freak_: I'd expect that "number" gives me a 0.101 as well
05:51:06 <mm_freak_> ksf: that's why it's a side effect
05:51:22 <ksf> you need to deepseq to be sure you actually catch it in the try.
05:52:27 <ksf> if at all, the only point to catch them should be at the top-level of any thread.
05:52:45 <dented42> I don't know if this is the place to ask questions about the enumerator package, nevertheless I shall:
05:52:46 <dented42> I'm writing a server that listens for messages from a client, so there is an enumerator that yields a stream of bytestrings, and I have written a parser in attoparsec that produces messages, and that is where I run into trouble. I want to write an enumeratee that takes a stream of bytestring and yields a stream of messages. However I am at a loss as to how to do it. Can someone recommend a resource where I can learn enough of the t
05:52:46 <dented42> and practice behind enumerators to implement this?
05:52:56 <ksf> better would be only to support one catch site per shared-memory node.
05:53:13 <Silvah> quicksilver: so no, I'm not talking rubbish, I'm just familiar with the actual (as opposed to theoretical) state of affairs.
05:53:47 <mm_freak_> koeien: obviously the 'number' parser doesn't support the syntax
05:54:09 <koeien> mm_freak_: it claims it does, though. I will investigate in the source code
06:01:05 <KitB> running "cabal install gtk" fails with "ExitFailure 9"
06:01:17 <KitB> Can anyone help?
06:02:01 <obbele> KitB: on which OS ? have you yum install gtk-dev ?
06:02:11 <KitB> obbele: arch
06:04:56 <obbele> KitB: well, you should check first that you have gtk+2 headers, on Fedora, you are required to install gtk+2-devel, on Debian libgtk+2-whatever. I'm sorry I don't know the exact thing in Arch
06:05:35 <KitB> arch installs the headers along with
06:05:52 <KitB> I have gtk2 installed, so I have what would be gtk2-dev installed on other distros
06:06:22 <obbele> KitB: that's remind me, you can also directly use the package-manager (pacman -Sy gtk2hs-gtk ?)
06:07:06 <KitB> I need profiling
06:07:41 <KitB> Rather oddly I've just run the command a second time
06:07:44 <KitB> and it's worked.
06:07:55 <KitB> This is on a fresh arch install inside a VM
06:14:54 <parcs> dented42: attoparsec-iteratee :)
06:17:15 <dented42> parcs: it looks like attoparsec-iteratee makes an interatee that takes a stream of bytes and yields a single parsed whatever. What I want is to have an enumeratee that parses out a complete message, and presumably there will be some left over bytes, which is fed into the parser again.
06:18:23 <parcs> dented42: that's what it does
06:18:46 <mm_freak_> koeien: it might be a bug, so perhaps it should be reported
06:19:18 <parcs> dented42: you can compose multiple Parsers to parse multiple, consecutive values
06:19:51 <KitB> ok so
06:19:53 <parcs> well, multiple Iteratees I should say
06:19:59 <KitB> regex-tdfa is reliably doing it
06:20:21 <dented42> parcs: ok, that is what I'm not sure how to accomplish
06:20:30 <parcs> dented42: do { val1 <- parserToIteratee parser1; val2 <- parserToIteratee parser2; return (parser1, parser2) }
06:20:32 <KitB> I think it was regex-tdfa that was doing it before and I thought it was gtk (gtk was a dependency of the package I was trying to install)
06:20:45 <parcs> err, return (val1, val2)
06:21:51 <dented42> parcs: but I want to have an enumeratee that produces a stream of parsed things that can in turn be processed by another iteratee
06:23:05 <koeien> I found it ; it was a bug in the attoparsec package, upgrading to latest revision solved my problem.
06:23:13 <dented42> parcs: I don't want to stop producing the parsed messages until the handle that is ultimately supplying returns EOF
06:26:37 <spirit> i have a list ["one","two","three"] and would like to convert it to "one\ntwo\nthree" -- how would i go about it?
06:26:49 <Botje> unlines
06:27:06 <parcs> dented42: there's the convStream function which converts an Iteratee into an Enumeratee
06:27:19 <Botje> or intercalate "\n", or concat . intersperse "\n"
06:27:34 <dented42> spirit: intercalate
06:28:05 <mm_freak_> dented42: nothing wrong with that…  if you need an example of how to do that, look into the ismtp library
06:28:23 <spirit> cool :-)
06:28:27 <spirit> cheers!!!
06:28:34 <mm_freak_> it uses an smtpResponses enumeratee to turn a stream of lines into a stream of parsed SMTP messages
06:28:52 <dented42> parcs: I'm using the enumerator library, which as I understand is not compatible with the iteratee library
06:29:05 <dented42> mm_freak_: I shall look at it
06:29:30 <parcs> dented42: then attoparsec-iteratee won't work for you either :)
06:29:38 <mm_freak_> dented42: although i switched from parsing via attoparsec-iteratee to delimited parsing
06:29:41 <parcs> i have to go now, sorry
06:29:50 <dented42> parcs: hehe, it's ok
06:30:35 <mm_freak_> but that's because of the design of the 'netlines' library, which i'm currently revising completely
06:31:13 <mm_freak_> right now it has an enumeratee, which turns a raw ByteString stream into a stream of ByteString lines, which is not the best solution
06:31:36 <mm_freak_> i will rewrite it to turn a raw ByteString stream to a raw ByteString stream, then i can just use attoparsec-enumerator
06:32:57 <dented42> mm_freak_: but presumably the action of parsing a stream repeatedly using the enumerator library is similar regardless of the specific parser used, or at least similar enough to set me on the right track :)
06:34:25 <mm_freak_> dented42: well, i will still use delimited parsing, but without feeding the parser myself =)
06:34:50 <mm_freak_> instead just use iterParser
06:34:54 <mm_freak_> which is right now impossible
06:35:37 <dented42> mm_freak_: in what module do should I look in?
06:37:46 <mm_freak_> dented42: Network.Smtp.Tools
06:38:11 <mm_freak_> smtpResponses
06:38:25 <dented42> mm_freak_: ok, thanks!
06:39:06 <erus`> how do i get the current matrix as a list of floats or whatever?
06:39:09 <erus`> in opengl sorry
06:39:44 <mm_freak_> dented42: wait a minute…  the newest version doesn't use attoparsec at all
06:40:04 <mm_freak_> you'll have to check out 1.0.2
06:40:18 <erus`> @hoogle IO [Float]
06:40:18 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
06:40:18 <lambdabot> Control.Concurrent.Chan getChanContents :: Chan a -> IO [a]
06:40:18 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
06:40:29 <mm_freak_> dented42: but it has a completely different interface
06:40:30 <erus`> @hoogle IO [GLfloat]
06:40:31 <lambdabot> Warning: Unknown type GLfloat
06:40:31 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
06:40:31 <lambdabot> Control.Concurrent.Chan getChanContents :: Chan a -> IO [a]
06:41:04 <mm_freak_> dented42: http://hackage.haskell.org/packages/archive/ismtp/1.0.2/doc/html/src/Network-Smtp-Protocol.html#waitForWelcome
06:42:09 <erus`> the opengl docs dont even have descriptions by the function names
06:42:18 <erus`> this is really poor
06:42:46 <mm_freak_> erus`: you can read the corresponding man pages
06:42:55 <mm_freak_> every opengl function has a manpage
06:43:22 <erus`> haskell helpfully leaves out loadMatrix and getfloatv functions in its opengl implementation
06:43:37 <erus`> and replaces them with undocumented matrix* monad things
06:44:29 <mm_freak_> yes…  it's more convenient, but some documentation would be nice
06:46:52 <f> @list
06:46:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:47:06 <f> @djinn (a -> b -> b)-> (a -> c -> c)->(a -> (b,c) -> (b,c))
06:47:06 <lambdabot> f a b c (d, e) = (a c d, b c e)
06:47:16 <deech> Hi all, has anyone used qtHaskell on a Mac?
06:51:06 <dented42> mm_freak_: hehe, or I could have read the documentation better. in Data.Enumerate there is a function called 'sequence' that does precisely what I want.
06:54:23 <f> @djinn [(a -> b -> b)]->(a -> [b] -> [b])
06:54:23 <lambdabot> Error: Undefined type []
06:56:26 <haja> hi, gtk2hs question: I'm trying to create a GtkTreeView with a GtkListModel using glade. Do I have to create the mapping from the model to the view entirely in haskell-code, or is it possible to use column definitions with CellRenderers from glade?
06:57:22 <dcoutts> haja: you need to create the model and set up the mapping in Haskell code
06:58:33 <byorgey> @type \fs a bs -> map ($a) fs >>= \f -> bs >>= f
06:58:33 <lambdabot> forall a a1 b. [a -> a1 -> [b]] -> a -> [a1] -> [b]
06:58:56 <byorgey> not quite
06:59:32 <haja> dcoutts: so I have to add TreeViewColumn's to to the TreeView in haskell? I cannot somehow connect the CellRenderers to my model?
07:00:05 <byorgey> @type \fs a bs -> map ($a) fs >>= \f -> bs >>= return . f
07:00:06 <lambdabot> forall a a1 a2. [a -> a1 -> a2] -> a -> [a1] -> [a2]
07:00:23 <byorgey> @type \fs a bs -> map ($a) fs >>= \f -> fmap f bs
07:00:24 <lambdabot> forall a a1 b. [a -> a1 -> b] -> a -> [a1] -> [b]
07:00:48 <byorgey> @type \fs a bs -> map ($a) fs >>= (<$> bs)
07:00:49 <lambdabot> forall a a1 b. [a -> a1 -> b] -> a -> [a1] -> [b]
07:00:55 <byorgey> f: ^^^ ?
07:01:28 <f> byorgey: thanks, I will try that :)
07:01:47 <dcoutts> haja: take a look at the gtk2hs demo code for the treeview/model stuff, it's quite sane in the end.
07:02:14 <dcoutts> haja: you connect it up in Haskell using Haskell functions, you can't do it in glade.
07:02:23 <byorgey> > let distrib = \fs a bs -> map ($a) fs >>= (<$> bs) in distrib [(+), (*)] 3 [4,5,6]
07:02:24 <lambdabot>   [7,8,9,12,15,18]
07:03:06 <byorgey> oh, wait!
07:03:11 <byorgey> @type \fs a bs -> fs <*> pure a <*> bs
07:03:11 <dcoutts> haja: but you also get to have a TreeListStore of custom Haskell data types, and custom Haskell functions for selecting attributes to connect to renderers. So it's actually a lot nicer. But you do have to do it in Haskell code, not glade.
07:03:12 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> a -> f a1 -> f b
07:03:17 <byorgey> much better =)
07:03:26 <byorgey> f: try that instead =)
07:03:42 <byorgey> > [(+), (*)] <*> pure 3 <*> [4,5,6]
07:03:43 <lambdabot>   [7,8,9,12,15,18]
07:03:47 <haja> dcoutts: ah ok, thanks I've already found some tutorials in which they do it in haskell, but no one really used glade... so i was wondering how much can be done within glade.
07:04:25 <dcoutts> haja: you can obtain the TreeView from glade, that's it.
07:04:37 <dcoutts> but not the model
07:05:28 <haja> dcoutts: ok, so nothing beyond. although there are castTo* methods for cellRenderer if I've not mistaken the docs
07:06:05 <dcoutts> haja: sure, castTo* is the general down casting operator
07:06:19 <dcoutts> which happens to be used in the context of glade/gtkbuilder
07:06:56 <dcoutts> doesn't mean that just because castToCellRender exists that it can/should be used with glade/gtkbuilder
07:07:20 <dcoutts> they're generated automatically for all the gobject types
07:07:21 <f> byorgey: thanks! now I have to figure out if this is exactly what I want: combining multiple functions to fold them over a list at the same time
07:07:47 <haja> dcoutts: thanks. I've guessed something like that. I was just curious ;)
07:11:14 <SoleSoul> in ghc, if I write "fst (someFunc argument) : snd (someFunc argument)" assuming someFunc and argument are identical in the two calls, will the function someFunc run twice?
07:12:11 <hpc> @quote oasis
07:12:11 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:12:25 <hpc> SoleSoul: add a trace statement inside someFunc and see what happens
07:13:06 <hpc> SoleSoul: worst-case, you can write let foo = someFunc argument in fst foo : snd foo
07:13:25 <byorgey> SoleSoul: yes, the function will probably run twice.
07:13:50 <SoleSoul> hpc: I currently use "where", just wanted to know if it is required
07:13:55 <SoleSoul> byorgey: thanks
07:13:59 <byorgey> SoleSoul: GHC does very little common subexpression elimination because in some cases it can cause very poor memory performance
07:14:28 <haja> SoleSoul: I don't think it should make a difference between let, where or just the method statement...
07:15:23 <SoleSoul> haja: that means you don't agree with byorgey?
07:16:09 <siracusa> SoleSoul: I think in that case `let (x,y) = someFunc argument' is preferable
07:16:32 <haja> SoleSoul: I'm by far no expert on haskell, but all I know about it it's just a synonym, and evaluation is done regardless of how you actually structure your code. But I wouldn't weight my answer too high ;)
07:16:36 <SoleSoul> siracusa: over 'where'?
07:16:55 <siracusa> No, let and where shouldn't make any difference
07:16:58 <hpc> SoleSoul: let and where both work
07:17:33 <SoleSoul> ok, thank you all
07:17:37 <byorgey> haja: let x = foo in ... x ... x   and  ... foo ... foo  will always evaluate to the same value, but their memory usage may be different.
07:18:21 <SoleSoul> byorgey: what about execution time?
07:19:02 <byorgey> yes, execution time can be different too, both inherently and because of memory usage
07:19:04 <haja> byorgey: ok, didn't know that. As I've said, I'm by far no expert.
07:19:59 <byorgey> for example, (length [1..100000000], sum [1..100000000]) has to evaluate the list [1..100000000] twice, but can operate in constant space since each list can be incrementally garbage colleted as length and sum traverse over them accumulating a result
07:20:47 <byorgey> however, let x = [1..100000000] in (length x, sum x) only has to evaluate the list once, but the whole list will end up in memory since while length is evaluating, the list cannot be garbage collected since (sum x) still refers to it
07:21:27 <byorgey> this is why GHC won't transform the first into the second, because it might not be an improvement
07:21:45 <SoleSoul> interesting
07:21:50 <JaffaCake> come to CamHac! 12-14 August, Cambridge, UK http://www.haskell.org/haskellwiki/CamHac
07:21:51 <haja> yes, indeed.
07:22:21 <Axman6> come to AusHac too! >_>
07:22:28 <byorgey> JaffaCake: wish I could!  Sounds like fun!
07:22:44 <JaffaCake> byorgey: :(
07:23:11 <jaspervdj> JaffaCake: looking forward to it, thanks for organizing!
07:24:49 <frerich> Is anybody aware of opensource expert systems written in Haskell?
07:26:12 <JaffaCake> frerich: https://github.com/almost/Haskell-Fun/blob/master/eliza.hs
07:30:01 <yitz> @remember frerich: Is anybody aware of opensource expert systems written in Haskell? JaffaCake: https://github.com/almost/Haskell-Fun/blob/master/eliza.hs
07:30:01 <aninhumer> JaffaCake: bah, I'm at Homerton all term, but I'd still have to travel in August :P
07:30:01 <lambdabot> I will never forget.
07:31:18 <JaffaCake> aninhumer: not too far I hope...
07:31:50 <aninhumer> Probably not, but still feels kind of silly :P
07:32:30 <SoleSoul> Is there a function in the standard library for "breakAfter"? i.e. breakAfter (== ';') "cout<<a;a++;" => ("cout<<a;", "a++;")  ?
07:32:49 <aninhumer> Are you related to the College in any way, or is it just a venue? JaffaCake
07:33:12 <JaffaCake> just a venue - it came out the cheapest
07:33:45 <aninhumer> I'll look into it anyway
07:34:53 <aninhumer> I was intending to work on a Haskell Riichi Mahjong game over summer, so that would actually fit quite well
07:36:14 <Gracenotes> SoleSoul: partition?
07:36:18 <eekTheCat> does cabal never work? http://hpaste.org/47088/cabal_never_works
07:36:33 <Gracenotes> er actually nevermind
07:36:41 <eekTheCat> ghc 6.12.3 and ubuntu natty
07:37:01 <Gracenotes> I think that would just be "break"
07:37:09 <SoleSoul> Gracenotes: I need to break after the first occurance of a char
07:37:19 <SoleSoul> break breaks before the occurange
07:37:42 <SoleSoul> i.e. => ("cout<<a", ";a++;")
07:37:59 <manju_> byorgey, you wouldn't happen to have the paste of the program that you gave me with respect to rendering dia code to a surface would you ?
07:38:24 <dcoutts> eekTheCat: did you do something like rm ~/.ghc ?
07:38:34 <dcoutts> eekTheCat: or rm ~/.cabal ?
07:38:38 <Gracenotes> SoleSoul: you can write your own list function.
07:38:49 <alexbagel> SoleSoul: i dont think there's anything "standard" that will help you but theres a data.list.split lib with lots of helpers
07:39:09 <Gracenotes> the nice thing about break's behavior is that you can pattern match against (';':str) on the second half to strip it
07:39:22 <eekTheCat> dcoutts, not that I'm aware of
07:39:28 <Gracenotes> and add a semicolon to the end of the first, if that's absolutely crucial in your program
07:39:29 <SoleSoul> Gracenotes: Since I'm new I happen to rewrite many standard library functions. I'm trying to reduce that habit :)
07:39:42 <dcoutts> eekTheCat: it looks like you deleted the files of the package but left the package registered.
07:40:23 <eekTheCat> dcoutts, hmmm. how do I unregister the package to reinstall it then?
07:40:26 <dcoutts> eekTheCat: ghc-pkg check can tell you which packages are affected. The solution is to unregister (ghc-pkg unregister) the affected packages and reinstall
07:40:37 <eekTheCat> dcoutts, thank you
07:40:58 <dcoutts> eekTheCat: unregistering might break other packages,  cabal will ignore broken packages
07:42:43 <f> @type \ fs a bs -> map (\(f,b) -> f a b) (zip fs bs)
07:42:44 <lambdabot> forall t t1 b. [t -> t1 -> b] -> t -> [t1] -> [b]
07:43:01 <SoleSoul> Gracenotes: how would you use (';':str), not is a function declaration?
07:43:37 <manju_> byorgey, found it!
07:43:39 <manju_> yay
07:46:29 <Gracenotes> SoleSoul: case break (==';') [...] of (first, (_:second)) -> match; _ -> no match
07:47:50 <SoleSoul> Gracenotes: never used `case'. I'll learn it. thanks
07:48:16 <kaito_> SoleSoul: you can use groupBy for that: groupBy (\x y -> y /= ';') "a;b;c;" -> ["a",";b",";c",";"]
07:49:00 <SoleSoul> > groupBy (\x y -> y /= ';') "a;b;c;"
07:49:00 <lambdabot>   ["a",";b",";c",";"]
07:49:33 <SoleSoul> but it has the same problem,
07:49:48 <kaito_> You can put the semicolons in their own string
07:49:57 <kaito_> by comparing x too
07:49:58 <SoleSoul> > break (== ;) "cout<<a;", "a++;"
07:49:59 <lambdabot>   <no location info>: parse error on input `;'
07:50:11 <hpc> ';' /= ;
07:50:11 <SoleSoul> > break (== ;) "cout<<a;a++;"
07:50:12 <lambdabot>   <no location info>: parse error on input `;'
07:50:18 <f> > let par fs a bs = map (\(f,b) -> f a b) (zip fs bs) in foldr (par [(+),(*)]) [1..10]
07:50:19 <geheimdienst>  break (== ';') [ "cout<<a;", "a++;" ]
07:50:19 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
07:50:19 <lambdabot>    arising from a use ...
07:50:30 <geheimdienst> > map (break (== ';')) [ "cout<<a;", "a++;" ]
07:50:31 <lambdabot>   [("cout<<a",";"),("a++",";")]
07:50:36 <SoleSoul> > break (==  ';') "cout<<a;a++;"
07:50:37 <lambdabot>   ("cout<<a",";a++;")
07:51:15 <f> > let par fs a bs = map (\(f,b) -> f a b) (zip fs bs) in foldr (par [(+),(*)]) [0,1] [1..10]
07:51:16 <lambdabot>   [55,3628800]
07:51:19 <geheimdienst> > break (== 'b') "abc abc abc" -- break only cuts off the first match
07:51:20 <lambdabot>   ("a","bc abc abc")
07:51:56 <f> sweet. thanks byorgey for your help
07:53:04 <kaito_> > groupBy ((==) `on` (==';')) "a;b;c;"
07:53:05 <lambdabot>   ["a",";","b",";","c",";"]
07:53:24 <SoleSoul> geheimdienst: it's ok. that's what I need
07:54:06 <geheimdienst> kaito_: interesting, i'd have never looked at it that way. seems a little complicated, though
07:54:08 <SoleSoul> but I need the input ("ab","c abc abc")
07:54:38 <geheimdienst> > takeWhile (/= 'b') "abc abc"
07:54:39 <lambdabot>   "a"
07:54:45 <geheimdienst> hm ...
07:55:09 <geheimdienst> > dropWhile (/= 'b') "abc abc"
07:55:10 <lambdabot>   "bc abc"
07:55:29 <geheimdienst> i.e., break is like doing takeWhile and dropWhile at the same time
07:55:39 <hpc> @src break
07:55:39 <lambdabot> break p =  span (not . p)
07:55:49 <geheimdienst> @src span
07:55:49 <lambdabot> span _ xs@[]                     =  (xs, xs)
07:55:49 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
07:55:49 <lambdabot>                   | otherwise    =  ([],xs)
07:55:55 <geheimdienst> bah
07:56:05 <osfameron> in general, would Haskell module authors welcome patches that added 1) a 4-line sample program that used their module and 2) SEE ALSO links to relevant tutorials/blog posts?  i.e. to add to the entry-point docs on Hackage
07:56:32 <SoleSoul> funcc a = a*2
07:56:32 <hpc> osfameron: i would LOVE if packages had more entry-point documentation, as you say
07:56:35 <SoleSoul> > funcc a = a*2
07:56:35 <lambdabot>   <no location info>: parse error on input `='
07:56:54 <SoleSoul> > funcc a b = a ++ b
07:56:55 <lambdabot>   <no location info>: parse error on input `='
07:56:55 <geheimdienst> osfameron: i'll hug you if you improve the documentation of random stuff on hackage!
07:56:58 <geheimdienst> do it man
07:57:21 <byorgey> osfameron: that's an excellent idea
07:57:22 <SoleSoul> > let funcc a b = a ++ b
07:57:23 <lambdabot>   not an expression: `let funcc a b = a ++ b'
07:58:05 <osfameron> hpc, geheimdienst, byorgey: hurrah.  I'll try to draft something (for Parsec maybe, for starters)
07:58:06 <sm> good morning
07:59:01 <hpc> more documentation needs to follow the pattern of "this is what it is for" => "trivial program" => "expand to show features individually
07:59:29 <geheimdienst> osfameron: good idea. you're aware of the original pdf that explained parsec? i believe it's still the go-to documentation, even though in the meantime the module names have changed, and stuff
07:59:59 <quicksilver> osfameron: if such documentation showed you how you can *actually* try stuff in ghci, that would be good as well if applicable.
08:00:00 <osfameron> geheimdienst: nope.  I ended up googling for sample code, which was helpful in pointing in the right direction
08:00:28 <quicksilver> osfameron: in parsec in particular people don't seem to realise that a runParser wrapper will let them experiement easily in the REPL
08:00:37 <quicksilver> and they get stuck in the slow develop-compile-debug cycle.
08:01:02 <osfameron> quicksilver: ah, nice!  in fact I haven't realised that either ;-)
08:01:07 <hpc> quicksilver: i much prefer the develop-:r-playwithit cycle
08:01:13 <hpc> :D
08:01:21 <geheimdienst> quicksilver: could you hpaste a few lines of how you would do such a runParser wrapper? osfameron might want to include that
08:01:37 <quicksilver> geheimdienst: not today, no, I have rather a lot on. However, osfameron knows where to find me ;P
08:01:43 <osfameron> hpc: yeah, that's what I do in general
08:01:54 <osfameron> quicksilver: hehe
08:03:04 * geheimdienst tends to hack around in vim and have another window open that does runhaskell on the file whenever it changes ...
08:03:20 <osfameron> ah, that's nice too
08:03:27 <osfameron> I sometimes think I'd like something like SLIME
08:03:34 <osfameron> though that'd involve learning emacs, I imagine
08:03:40 <quicksilver> there are lots of good ways to develop but too many people don't seem to appreciate the power of the repl
08:04:00 <quicksilver> library documentation may be a way to push people in that direction.
08:04:34 <hpc> i also mentioned this in another channel, but better documentation will also help push the perception that these libraries are actually meant to be USED
08:04:39 <monochrom> I don't appreciate the repl because my code crammed into one "line" is too messy. I don't even know what it says.
08:04:45 <geheimdienst> what i do use ghci for is trying out random small things with xlib, for instance. the haskell X bindings are quite complete. you can use ghci where you'd normally write small test programs in c
08:04:50 <hpc> nobody is going to look at a module with no docs and think it will be useful
08:04:59 <osfameron> hpc: hehe (re "meant to be USED")
08:05:13 <hpc> virtually every module on CPAN has pages and pages of docs, for example
08:05:21 <hpc> all written by hand, not with a tool
08:05:32 <osfameron> and all about how to *use* the module, and its idioms
08:05:36 <osfameron> as opposed to its methods
08:05:45 <hpc> indeed
08:05:58 * hackagebot regex-genex 0.2.1 - From a regex, generate all possible strings it can match  http://hackage.haskell.org/package/regex-genex-0.2.1 (AudreyTang)
08:06:01 <hpc> bottom line: be more like CPAN, and not in the "have lots of stuff" way
08:06:01 <osfameron> (well, in the best base, about both ;-)  but I'd rather have just the latter, if I had to choose)
08:06:07 <Jafet> Haddock does that with header comment thingies, but people often don't write them.
08:06:09 <geheimdienst> monochrom: i tend to use "let" a lot in ghci. even for small things like curry one or two arguments onto a 6-argument function
08:06:29 <Jafet> Is this telling me to reduce alloc? http://hpaste.org/47089/chs
08:06:34 <osfameron> Jafet: yeah, I can see that Parsec and riak have those, they're just quite short, and not all that informative
08:07:25 <sm> writing docs in haddock markup is kind of painful
08:07:27 <monochrom> the problem with "let" at the prompt is it doesn't stay on the screen for long
08:07:31 <Jafet> Perhaps people think that their types are self-documenting enough... but in the Real World, they're not
08:07:53 <osfameron> Jafet: they're great for reference
08:07:56 <hpc> strut :: (Backend b v, InnerSpace v, OrderedField (Scalar v), Monoid m) => v -> AnnDiagram b v m -- not self-documenting
08:08:18 <geheimdienst> monochrom: that's true. it would be awsum if ghci showed the current bindings fixed to the top of the window, or something
08:08:21 <monochrom> so 5 minutes and 20 tests later I don't even remember the names of the things I define with "let" at the prompt
08:08:25 <hpc> :t (=~) -- also not
08:08:26 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
08:08:40 <monochrom> just use a real editor
08:08:55 <monochrom> hell, just use a real ide
08:09:09 <monochrom> and yes, people here under-appreciate ide's
08:09:11 <geheimdienst> hm you mean leksah ...?
08:09:26 <monochrom> I mean eclipse
08:09:50 <hpc> eclipse is awesome, but so fat
08:09:57 * osfameron *loved* using an IDE when he was programming Java (briefly, not paid for)
08:10:03 <osfameron> IntelliJ was incredible
08:10:08 <osfameron> also not especially lean ;-)
08:10:15 <hpc> all the context stuff eclipse is able to do is very impressive
08:10:16 <geheimdienst> e
08:10:30 <geheimdienst> eclipse is awesome for java work. never tried it for haskell
08:10:31 <hpc> auto imports, javadoc when you hover over a method name, etc
08:10:40 <osfameron> ooo! http://code.google.com/p/ideah/  Haskell plugin for IntelliJ
08:10:40 <hpc> the haskell plugin is kind of shit
08:10:46 <quicksilver> hpc: unfortunately quite a lot of that is much harder in haskell.
08:11:00 <hpc> yeah
08:11:05 <quicksilver> prefix functions and binary operators just don't let themselves well to intellisense
08:11:07 <SoleSoul> > ((\p l -> let splitted = break p l in (fst splitted ++ ((head $ snd splitted):[]), tail $ snd splitted)) (== ';')) "ab;ab"
08:11:08 <lambdabot>   ("ab;","ab")
08:11:12 <quicksilver> postfix method invocation is just... perfect for it.
08:11:13 <hpc> java had the advantage of being lowest common denomenator
08:11:23 <quicksilver> it's like java and C# were designed to enable powerful IDEs.
08:11:28 <geheimdienst> well auto-imports for haskell could be a matter of "i don't know that identifier, let's hoogle for it and show the guy a menu with the results"
08:11:34 <hpc> ^
08:11:41 <hpc> and haddock is equally possible
08:11:44 <quicksilver> auto-imports could be done.
08:11:52 <MarcWeber> geheimdienst: :) Use tags and vim and vim-addon-haskell and you're done
08:11:54 <hydo> Here's a question re the docs issue: I have one module on hackage.  Lots of docs in the source.  No errors when docs are generated locally.  No apparent docs on the hackage site.  Is there any way to get an error report on the docs generation so I can fix whatever is keeping them from being generated on hackage?
08:11:57 <quicksilver> it's the intellisense/autocomplete that's not as nice.
08:11:59 <monochrom> current I am still at emacs because my programs are not large enough to call for an IDE, that's all
08:12:13 <hpc> also, much of eclipse error detecting is type errors
08:12:19 <hpc> which we could have a field day with
08:12:26 <geheimdienst> MarcWeber: yeah, it can be done with vim in theory ... it's just much more messy than with eclipse
08:12:39 <hpc> insert-type
08:12:42 <hpc> specialize-type
08:12:48 <MarcWeber> monochrom: Emacs is not much worse than IDE cause no useful refactoring stuff etc does exist AFAIK.
08:12:55 <hpc> generalize-type
08:13:01 <MarcWeber> geheimdienst What has that to do with "Eclipse"?
08:13:28 <dankna> the future is treeedit (needs a better name that doesn't have three "E"s in a row)
08:13:34 <monochrom> that has to do with "IDE"
08:13:44 <MarcWeber> geheimdienst: Eclipse's based on Java which is touring complete as well as VimL :)
08:13:51 <JuanDaugherty> leksah's nolonger the deal?
08:13:56 <MarcWeber> The Vim solution still does a great job in most cases..
08:14:09 <hpc> it would also be interesting to come up with algorithms for common haskell-specific refactor operations
08:14:17 <hpc> like splitting into types/instances modules
08:14:28 <hpc> fixing circular dependencies
08:14:36 <geheimdienst> MarcWeber: i mean in eclipse it's more or less set up for you. in vim, you're downloading this script from vim.org and that script, and fiddle until vim finds them, and you need to set some paths, and you need to run ctags or whatever, and you need to set some more paths ...
08:14:46 <geheimdienst> at least that's my experience of things
08:15:10 <MarcWeber> geheimdienst: use nixos and hack-nix. Then you do: hack-nix --build-env. . ./default-env; vim .. and you're done.
08:15:13 <MarcWeber> Tags are ready.
08:15:14 <hpc> when i was first learning vim, it took me half an hour to figure out how to get syntax highlighting to work
08:15:25 <MarcWeber> geheimdienst: Does Eclipse do autoimport?
08:15:32 <hpc> it does
08:15:36 <geheimdienst> yeah great, now we've arrived at "first, install a new operating system ..."
08:15:37 <geheimdienst> :)
08:15:38 <osfameron> hpc: these days it's just   :syn on   ;-)
08:15:47 <osfameron> though, yes, that could take half an hour to figure out
08:15:47 <geheimdienst> hpc: that's what i mean exactly
08:15:58 <MarcWeber> hpc: Is that based on scion?
08:16:03 <sm> hydo: you could try some different versions of haddock, to match whatever hackage has
08:16:13 <hpc> what's scion?
08:16:23 <MarcWeber> geheimdienst: You'll get much more benefits: Being able tou build multiple configurations at the same time easily.
08:16:31 <SoleSoul> What about Yi?
08:16:41 <geheimdienst> you mean the multiple versions thing of nix?
08:16:45 <hydo> sm: good idea.
08:16:46 <MarcWeber> hpc: A server written by nominolo providing faster feedback loops by keeping a ghc instance running.
08:16:46 <hpc> yi isn't an ide, it's a text editor
08:16:47 <hpc> i think
08:16:54 * osfameron downloads the community edition of IntelliJ IDEA
08:17:00 <hpc> MarcWeber: nifty
08:17:31 <eekTheCat> How would I just destroy my entire user local ghc registry and start over from scratch
08:17:35 * JuanDaugherty found the regular haskell-platform pkg to work (best?) on NixOS.
08:17:45 <monochrom> scion is the source-code-processor behind eclipsefp. eclipsefp is the haskell plugin for eclipse
08:17:56 <hydo> eekTheCat: rm -rf ~/.ghc rm -rf ~/.cabal
08:18:00 <JuanDaugherty> (x86-64 anyway)
08:18:07 <monochrom> for example scion tells you types
08:18:09 <osfameron> JuanDaugherty: it seems to work ok on OSX
08:18:09 <hydo> err... && between the two or ;
08:18:23 <MarcWeber> JuanDaugherty hack-nix supports all packages of hackage (in theory).. in practise you have to add some constraints eg set flags manually.
08:18:29 <eekTheCat> hydo, thanks
08:18:35 <JuanDaugherty> osfameron, leksah? yes that's the only place I've gotten it to work.
08:18:50 * JuanDaugherty only uses nix on NixOS
08:19:09 <osfameron> JuanDaugherty: ah, I meant the -package.  I've not tried leksah
08:19:48 <JuanDaugherty> yes, haskell-platform has worked everywhere I last tried it.
08:20:16 <JuanDaugherty> (i.e. debian/mac/nixos)
08:20:19 <Twey> Hey, we should move Hackage to Nix
08:20:22 <Twey> \o/
08:20:27 <MarcWeber> JuanDaugherty: The mess starts if you require more libraries than those contained in the platform..
08:20:45 <JuanDaugherty> haven't had a problem with that either
08:21:05 <JuanDaugherty> if it doesn't cabal install on hp I don't assume something is wrong with hp
08:21:15 <MarcWeber> JuanDaugherty: When updating compilers and such. Then you have to start reinstalling things manually :)
08:21:22 <MarcWeber> That's what I call a mess.
08:21:56 <JuanDaugherty> imma stic with hp 4 now, kthx
08:22:01 <JuanDaugherty> *stick
08:27:05 <eekTheCat> man, the link phase is pretty rough on my poor netbook
08:27:23 <monochrom> if linux, consider the "gold linker"
08:29:21 <Phyx-> man bacardi_gold
08:29:22 <eekTheCat> this isn't some haskell/ghc specific issue you think?
08:30:47 <eekTheCat> gold linker is faster, does it use less memory? because I'm guessing that's my problem, swapping to disk like crazy
08:31:24 <thoughtpolice> depends, on linux i notice gold is faster and uses a bit less memory on *most* executables, but linking big things can make it use up lots of memory
08:31:35 <thoughtpolice> i don't know how that compares to vanilla ld though, i've been using gold for like a year now
08:31:57 <thoughtpolice> for GHC stuff, it definitely makes it faster, and if you throw in split-objs, it'll help a lot too i imagine
08:32:35 <Jafet> On a 64-bit platform, I do: data Foo = Foo !Word8 !Word8; data Bar = Bar !Foo !Foo; will GHC use 2 bytes to store Foo and 4 bytes for Bar, or 8 for Foo (and 16 for Bar)?
08:32:36 <thoughtpolice> (when i say 'big things', I mean things like clang/llvm. the debug binary is something like 400mb, so the linker uses like 600mb of memory on the final link. for GHC itself it's not nearly that bad I don't think)
08:36:12 <hpc> Jafet: depends on what optimizations/where in the code, i suppose
08:37:42 <Jafet> Well, I think that the best way to optimize this is by reducing allocation: http://hpaste.org/47089/chs
08:37:46 <quicksilver> Jafet: ! does not change space usage (in the normal case)
08:38:31 <quicksilver> Jafet: you want {-# UNPACK #-} or the optimisation flag -funpack-strict-fields
08:38:39 <Jafet> What is the space usage "in the normal case", though?
08:39:07 <quicksilver> 24 bytes per Word8
08:39:11 <quicksilver> IIRC.
08:39:19 <quicksilver> so 72 for 'Foo', I guess
08:39:30 <quicksilver> and, erm, 168 for Bar?
08:39:32 <Jafet> Oh, so GHC doesn't unbox them automatically.
08:39:54 <quicksilver> that's what I hoped to communicate with  ! does not change space usage (in the normal case) ;)
08:39:58 <Jafet> I thought unpack-strict-fields would be implied by -O...
08:40:09 <quicksilver> nope. not sure why not though.
08:40:20 <quicksilver> reduces sharing I suppose
08:41:05 <Jafet> With my current main datastructure (Array), that option probably won't help much
08:41:31 <Jafet> It seems that I can't make it UArray without switching from data Piece = ... to type Piece = Word8
08:47:22 <k0ral> I have a failed dependency chain on installing haskell-dbus-core
08:47:57 <k0ral> it needs  haskell-libxml-sax<0.7 and haskell-xml-types<0.2
08:49:34 <monochrom> and aren't they well-available and well-installed?
08:49:49 <k0ral> this is tricky to explain
08:49:55 <k0ral> here goes
08:50:33 <k0ral> xml-types is 0.3 today
08:50:43 <k0ral> so I have to downgrade it
08:50:54 <k0ral> to 0.1.4
08:51:17 <k0ral> even so, it complains about a broken package for text and bytestring
08:51:30 <k0ral> (xlm-types complains)
08:51:36 <dankna> @hackage cabal-macosx
08:51:36 <lambdabot> http://hackage.haskell.org/package/cabal-macosx
08:52:12 <monochrom> you know, complete error messages would help a lot
08:53:36 <k0ral> well
08:54:27 <k0ral> the problem is I'm not  sure wether the error messages I get are from haskell packaging system, or from the archlinux one
08:55:05 <Jafet> Yeah, unbox-strict-fields resulted in no improvement
08:55:36 <k0ral> monochrom: text-0.11.0.5: dependency "bytestring-0.9.1.10-6aa1efbfa95d1689fc03d61e7c4b27c4" doesn't exist (use --force to override)
08:57:44 <monochrom> you have installed too many packages and duplicates. I need to see complete output of "ghc -v" and "ghc-pkg list -v"
08:58:23 <monochrom> in general you can read my http://www.vex.net/~trebla/haskell/sicp.xhtml for how it happened
08:58:57 <joe6> is there a better testing framework other than Test.HUnit?
08:59:25 <k0ral> oh I'm reading at "ghc-pkg check" output and it's quite awful
08:59:50 <joe6> something with more flexible failure options
09:00:00 <k0ral> posting all of it
09:00:27 <Jafet> Does GHC make (xs!!) fast, if xs is a literal?
09:00:29 <monochrom> even "ghc-pkg check" is incomplete and misses some problems
09:00:32 <joe6> k0ral: installing ghc?
09:00:32 <Jafet> I guess that's too much to ask for
09:00:41 <joe6> k0ral: installing ghc or haskell platform?
09:02:03 <k0ral> monochrom: http://hpaste.org/47094/broken_packages
09:02:17 <k0ral> joe6: neither
09:02:23 <k0ral> joe6: installing dbus-core
09:04:52 <k0ral> monochrom: it seems archlinux' package for bytestring suddenly has disappeared
09:04:53 <monochrom> you need a clean start
09:05:24 <k0ral> and so ?
09:05:54 <monochrom> note that if for example bytestring is missing, it is not sufficient to just add bytestring back. my article implies why
09:06:58 <monochrom> what is sufficient: if you add bytestring back, you need to rebuild everything that uses bytestring, too
09:07:33 <monochrom> but since so many packages are involved then, you might as well erase everything and start again
09:08:11 <k0ral> so following your article, I should uninstall everything I installed using my distro packaging system, and reinstall everything with cabal install, right ?
09:08:16 <quicksilver> it works OK to use your distro packages for global and add extra packages as user as long as those are all different.
09:08:29 <quicksilver> as soon as you have to install a newer version of a distro package, you're in trouble.
09:08:34 <monochrom> or stick with your distro exclusively
09:08:36 <quicksilver> monochrom: is that a fair summary?
09:08:49 <k0ral> quicksilver: yes, and the fact bytestring disappeared from arch packages made me reinstall it while it was already there
09:09:30 <k0ral> monochrom: well, in a way, I sticked to it since I've always converted cabal files into pkgbuilds
09:10:24 <k0ral> I guess I really should reinstall everything with cabal install not to be bothered forever
09:10:47 <monochrom> there is a safe way and an unsafe way to convert cabal files into pkgbuilds. the safe way requires manual dependency chasing
09:11:10 <monochrom> quicksilver: I think yes
09:11:17 <k0ral> I simply used cabal2arch
09:11:27 <k0ral> without doing aby dependency chasing
09:11:29 <k0ral> any*
09:11:40 <monochrom> I do not use cabal2arch and I do not know what it does and I don't want to know
09:12:04 <monochrom> actually maybe I want to know so I can endorse or condemn it in my article
09:12:07 <k0ral> I won't then try to explain it
09:12:36 <k0ral> well, PKGBUILDS are very similar to cabal files
09:12:53 <k0ral> cabal2arch just converts a cabal file into a PKGBUILD one
09:13:11 <k0ral> the latter is sufficient to create an archlinux package
09:13:49 <dcoutts> k0ral: the point is, you still need somehow to make sure you're using a consistent collection of packages
09:14:20 <dcoutts> whether it is cabal-install or a package manager that manages the actual files is somewhat orthogonal
09:14:52 <k0ral> well, not that independent, as a matter of fact
09:15:16 <monochrom> I suppose the empirical fact that you have always exclusively cabal2arch'ed and you still get into trouble means that we have enough reason to condemn cabal2arch
09:15:57 <dcoutts> k0ral: cabal2arch operates on individual packages, right? So you're manually picking versions of packages that you expect to work together.
09:16:10 <k0ral> monochrom: not really
09:16:27 <k0ral> monochrom: the problem didn't come "alone"
09:16:37 <k0ral> monochrom: I still installed twice the same package
09:16:52 <dcoutts> k0ral: for example, another approach would be to use the cabal-install solver to decide what versions to use, and then use cabal2arch on those package versions
09:17:12 <k0ral> monochrom: anyway, I prefer partitioning my packaging system into one for archlinux packages and the other for haskell ones
09:17:38 <monochrom> that is really easier said than done
09:17:39 <k0ral> cabal2arch is uselessly redundant
09:18:20 <k0ral> dcoutts: cabal2arch converts cabal dependencies into pkgbuild dependencies
09:18:31 <k0ral> dcoutts: so that one doesn't have to track down every dependency
09:18:33 <dcoutts> k0ral: recursively?
09:18:45 <dcoutts> k0ral: how does it decide what versions of dependencies to use?
09:19:00 <k0ral> dcoutts: don't know
09:19:15 * dcoutts notes that this is important for whether it'll work or not
09:23:57 <k0ral> ll
09:24:01 <k0ral> oops
09:25:03 <k0ral> this is an interesting question actually
09:25:43 <k0ral> what is the best way to distribute programs/libraries between distro-based packages or language-based packages
09:27:07 <k0ral> btw am I supposed to use cabal or ghc-pkg to manage hakell packages ?
09:27:39 <dcoutts> k0ral: depends on what you want to do
09:27:56 <dcoutts> ghc-pkg is a lower level tool for installed/registered packages
09:28:02 <k0ral> installing programs/libraries
09:28:06 <zerohp> I think cabal == apt-get, ghc-pkg == dpkg
09:28:14 <dcoutts> (sort-of)
09:28:15 <k0ral> cabal will do fine then :)
09:28:39 <k0ral> didn't see any way to uninstall a package with cabal though
09:28:43 <k0ral> is there ?
09:28:49 <monochrom> there isn't
09:28:52 <k0ral> ouch
09:29:12 <monochrom> this is why all analogies and all prejudices break down
09:29:51 * dcoutts welcomes patches for uninstall feature
09:30:10 <dcoutts> k0ral: in the mean time, you can use ghc-pkg unregister
09:30:18 <djahandarie> It'd be nice if someone tried to work out a Haskell package manager whose number one goal was to prevent stuff from breaking. Or make it very clear that it's all your fault if you want to do something dangerous :)
09:30:55 <k0ral> monochrom: your disliking attitude towards things that are not haskell is funny
09:30:56 <copumpkin> not sure why that would need to be separate from cabal
09:30:56 <monochrom> the latter is greatly exemplified by windows vista UAC
09:32:07 <monochrom> I like javascript
09:32:18 <k0ral> dcoutts: well, if the cabal tool is not that hard to code, I'm quite interested in hacking it
09:32:27 <k0ral> monochrom: how dare you ? :)
09:32:50 <monochrom> indeed, how dare I defy your presumptions about me
09:32:54 <dcoutts> djahandarie: it ought to be a matter of making cabal check whether registering this set of packages would break any existing installed packages, however it's actually not trivial to predict whether registering a package will replace an existing one.
09:32:58 <k0ral> okay now I4ve uninstalled every archlinux package related to haskell (except for haskell-platform of course)
09:33:16 <k0ral> I still have ghc-kg complaining about broken packages
09:33:27 <k0ral> shall I unregister all of them ?
09:34:21 <dcoutts> djahandarie: sometimes they get added, sometimes they replace. It depends not on what instances exist so much as which package db they are in. We have the peculiar situation currently where you can have two instances of the same package version so long as they do not both exist in the same package db.
09:34:25 <Saizan> to start from a clean state you also need to rm the database of user installed packages in ~/.ghc
09:34:43 <k0ral> ghc-pkg unregister doesn't really remove files from the system, does it ?
09:34:49 <monochrom> Saizan, this instance has no .ghc actually
09:34:53 <dcoutts> k0ral: right
09:35:19 <k0ral> then how can I make sure files are also removed ?
09:35:33 <Saizan> then if ghc-pkg check is still having problems you should reinstall the haskell-platform?
09:35:45 <Saizan> s/having/showing/
09:36:51 <monochrom> using the archlinux haskell platform package(s) is fine. you just lost some of it and you should re-install it. and not lose it again
09:37:52 <djahandarie> copumpkin, I don't think it would need to be. It just feels like that isn't cabal's primary goal or design philosophy at the moment. I'm sure it could be refactored.
09:38:12 <monochrom> "the road to hell is paved with good intentions and cabal install" :)
09:38:38 <dcoutts> yup
09:38:55 <Twey> IME the road to hell is formed when you try to use cabal install and distro packages together :þ
09:39:08 <dcoutts> each time we've made it better/safer people have pushed it harder and found more existing and complicated ways to break things
09:39:48 <dcoutts> existing/exciting
09:40:02 <monochrom> yes Twey I'm horrified that some people actually recommend doing it
09:40:25 * Twey just sticks to cabal install
09:40:53 <c_wraith> yeah.  The fact that you can't use both together basically means that you should only use distro packages if they're always exactly perfect.
09:40:56 <Twey> We should have something like Python virtualenv
09:41:01 <dcoutts> Twey, monochrom: you're referring to having distro packages and local packages that depend on them, and then upgrading the distro packages?
09:41:02 <monochrom> well "existing" would be also right if you were a platonist. all the beautiful ways of breaking cabal already exist, you just have to discover them
09:41:14 <Twey> Heh
09:41:28 <monochrom> I am certainly referring to unsafeInterleaveInstall
09:41:29 <cheater__> Twey, i thought virtualenv was a linux thing
09:41:33 <dcoutts> monochrom: yes, they were just much harder to find before, but now with the power of automation we can find them easily! :-)
09:41:34 <cheater__> unrelated to python?
09:42:04 <Twey> dcoutts: IME Bad Things happen when you mix distro and cabal packages.  E.G. you get global and user installs of the same package and different packages link against different installs and promptly break with confusing error messages.
09:42:18 <k0ral> err, haskell-platform has 25 dependencies of other distro-based haskell packages
09:42:21 <Twey> cheater__: No?  It's a Python tech AFAIK
09:42:48 <dcoutts> Twey: the issue of user packages masking global ones is not unique to distro packages
09:43:02 <Twey> dcoutts: It's not even that simple
09:43:18 <k0ral> to what extend is haskell-platform compulsory ?
09:43:22 <Twey> I had a case where I had both global and local instances for a package, so Haskell thought that neither was installed
09:43:28 <Twey> k0ral: It's not
09:43:34 <cheater__> Twey, what about just using chroot
09:43:45 <monochrom> to a practical extent the haskell platform is compulsory
09:43:46 <Twey> It's recommended, but not compulsory.  It's just a convenient way to install everything.
09:43:49 <k0ral> I understand it is kind of a haskell distribution
09:43:49 <dcoutts> Twey: did ghc-pkg think it was ok?
09:43:54 <Twey> You can always install it later
09:43:56 <Twey> dcoutts: Yes
09:43:57 <monochrom> (except for its opengl part)
09:44:07 <dcoutts> Twey: and cabal-install thought neither were installed
09:44:13 <dankna> I don't use HP
09:44:17 <k0ral> well, I don't mind installing every piece one by one
09:44:20 <Twey> cabal-install knew both were installed, IIRC
09:44:29 <dcoutts> Twey: then I don't follow
09:44:33 <Twey> Neither did I
09:44:33 <k0ral> as soon as I have a robust packaging system afterwards
09:44:34 <dankna> so it's not really compulsory
09:44:50 <Twey> I just nuked it, uninstalled all the distro packages, and installed everything via cabal, and it worked next time :þ
09:45:33 * dcoutts thinks none of this will really work properly 'til we have nix-style package management
09:45:50 <monochrom> 80% of haskell platform is in practice compulsory, i.e., people freely assume you have mtl, stm, parsec, text
09:45:51 * Twey thinks we should just embrace & extend Nix
09:45:58 <monochrom> and network
09:46:08 <k0ral> monochrom: cabal packages still check them
09:46:15 <cheater__> what is Nix?
09:46:18 <k0ral> monochrom: so it will anyway be reported
09:46:37 <Twey> cheater__: http://nixos.org/
09:46:48 <cheater__> oh someone was blogging about that in -blah
09:47:01 <Twey> Read the paper, it's nice
09:47:06 <k0ral> monochrom: in my sense, haskell-platform is made of compulsory items, but isn't itself compulsory as each item cn be installed independently
09:47:22 <c_wraith> I don't actually know any haskell dev locally who uses the platform (and I know several haskell devs locally, including at companies other than mine)
09:47:43 <monochrom> I forgot the regex-* ones
09:48:14 <jdavis> I am trying to use Data.ByteString.Lazy. Right now, I'm using the file size to know when to stop; is there a better way? Basically I want to read K-byte chunks until there are no more left, and it will be an error if the file is not a multiple of K bytes.
09:49:46 <k0ral> aaah
09:50:06 <c_wraith> jdavis: the whole point of lazy bytestrings is that you don't need to know what the chunk size is.
09:50:08 <k0ral> I uninstalled everything and just reinstalled ghc and it still complains about broken packages :( :(
09:50:35 <jdavis> c_wraith: but I need to process the data in chunks though. I'm not doing so for efficiency.
09:50:48 <jdavis> c_wraith: the unit that I can understand is a fixed K bytes.
09:51:29 <jdavis> c_wraith: I might be able to try to pretend that it's a stream of bytes, but that would be a little awkward.
09:52:46 <jdavis> Also, I don't really know how to stop at EOF effectively.
09:53:14 <k0ral> ohhhhh
09:53:36 <k0ral> just noticed everything was installed in ~/.cabal/
09:53:47 <k0ral> that's pretty *bad* !
09:54:51 <c_wraith> k0ral: actually, ~/.cabal is just caches.  ~/.ghc is where they're installed
09:55:04 <k0ral> c_wraith: sorry
09:55:17 <k0ral> c_wraith: that's still pretty *bad* !
09:55:24 <Cale> What's bad about it?
09:55:37 <k0ral> installing applications/libraries in a user directory
09:55:48 <Cale> That's where you want them to be installed :P
09:55:58 <Cale> Installing them globally is bad :P
09:56:05 <k0ral> why so ?
09:56:41 <Cale> Because that keeps them separate from the ghc installation, and so if things go wrong with your packages, you don't end up reinstalling ghc
09:57:16 <Cale> In the absolute worst case, you can just blow away .ghc and start reinstalling things from hackage, and everything will be fine
09:57:17 <k0ral> don't tell me, I4ve just reinstalled everything -_-'
09:57:21 <k0ral> I've*
09:57:43 <luite> c_wraith: .cabal does contain the actual libraries, not just caches
09:58:05 <k0ral> anyway, what if several users in the same computer want to use the same programs/libraries ?
09:58:11 <luite> but .ghc has the registration files
09:58:23 <k0ral> luite: that's what I thought, indeed
09:58:37 <luite> k0ral: you can use --global if you want that
09:59:03 <Cale> k0ral: You can copy the executables into a global directory if you want. It shouldn't be necessary to use the same libraries, each user can install them separately.
09:59:17 <Cale> But you *can* install them globally, sure.
09:59:44 <k0ral> well, instead of a command argument, I guess there is a configuration file, right ?
09:59:48 <Cale> I just wouldn't recommend it, because it's much easier to manage if things are nicely separated.
10:01:44 <monochrom> ~/.cabal/config
10:01:59 <luite> k0ral: yes, but unless you have lots of users and a large number of libraries I'd just install in the user dirs
10:03:23 <luite> hmm, can a user hide a package that's globally installed?
10:03:26 <k0ral> is there an example config file somewhere ?
10:03:50 <luite> k0ral: isn't it already filled with the options commented out?
10:03:51 <dafis> k0ral: cabal produces one on the first run
10:04:04 <c_wraith> yeah, just doing cabal update will create it
10:04:08 <k0ral> luite: well, I really think this is better to install programs/libraries in a global space
10:04:23 <c_wraith> k0ral: in the case of ghc libraries, that's really not true at all.
10:04:44 <c_wraith> k0ral: in fact, in the case of ghc libraries, the fewer that are installed globally, the better.
10:05:09 <k0ral> c_wraith: still expecting the why
10:05:22 <luite> k0ral: I agree for C libraries where you usually have some globale include and library path, but not for ghc where everything is managed nicely (usually...) by cabal
10:06:16 * osfameron considers http://www.haskell.org/haskellwiki/CamHac
10:06:52 <k0ral> luite: in a global space everything would still be nicely managed by cabal
10:07:30 <k0ral> you know, I'm waiting for your arguments before installing anything
10:08:10 <luite> k0ral: but there are some issues, I think individual users can't hide global packages, but I'm not sure
10:08:19 <monochrom> "fewer global" is better because you can easily erase ~/.ghc when in trouble
10:08:32 <monochrom> "more global" is better because you can easily erase /usr/lib/ghc when in trouble
10:08:48 <dankna> I personally install everything globally, but it would be annoying if I were in the habit of messing things up to the point of needing to erase everything.
10:09:09 <luite> dankna: can you hide a pkg as a regular user?
10:09:12 <monochrom> "the only way to win is not to play"
10:09:16 <dankna> luite: I've never wanted to hide a pkg
10:09:34 <luite> I can't test because I've everything installed as user :)
10:09:40 <dankna> luite: I don't even know why I would.  If I build with Cabal, it makes sure that everything is ....
10:09:43 <dankna> whoa, netsplit
10:10:18 <luite> dankna: hmm, really? I often experiment with .hs files in ghci, that are not part of some project with a .cabal file
10:10:31 <dankna> I don't :)
10:10:36 <luite> its annoying when multiple packages export Control.Monad.Reader
10:10:40 <luite> for example :)
10:10:40 <dankna> fair enough
10:10:57 <dankna> yes, I see the problem now.  has never happened to me.
10:11:35 <monochrom> more seriously, I don't care whether you like global or user. I care more about developing hygenic habits, i.e., dependency awareness, correct installation order, not being an upgrade whore
10:12:01 <monochrom> in other words, it is better to not screw up
10:12:18 <dcoutts> with nix-style package management it'd be safe to be an upgrade whore :-)
10:12:45 <dcoutts> (it wouldn't break anything you've got installed already)
10:12:59 <monochrom> use a virtual machine and checkpoint before adding a package
10:13:04 <luite> monochrom: but I want to be an upgrade whore ;p
10:13:26 <luite> at least I regularly want to upgrade dependencies to see if newer versions still work
10:13:52 <monochrom> there is cabal-dev
10:13:56 <acowley> anyone have any advice for naming an "and" function to avoid conflicting with prelude's and?
10:14:07 <monochrom> conjuncto
10:14:12 <monochrom> et
10:14:19 <monochrom> cum
10:14:34 <luite> yeah I know, I should perhaps use that more often... although, with proper upgrade-whoring support, should cabal-dev even be necessary?
10:14:47 <k0ral> if there were a way to uninstall properly a package, one would never have to erase everything manually
10:14:48 <acowley> the tricky part is I'm wrapping another library that prefixes its function names
10:14:54 * k0ral is feeding the troll
10:15:03 <monochrom> there is no such thing as proper upgrade-whoring support. can't be done
10:15:10 <luite> hehe
10:15:12 <acowley> I'd like to avoid prefixes as they're kind of ugly and pointless in the presence of a module system
10:15:24 <acowley> but it's nice if the names I choose are at least evocative of the wrapped functions
10:15:47 <dcoutts> luite: I'm not quite sure of monochrom's definition, but I think it's possible
10:15:55 <acowley> so conjuncto, which gets points for creativity and avoiding that whole brevity thing, isn't ideal
10:16:03 <dcoutts> luite: and without needing separate "silos" as with cabal-dev
10:17:03 <monochrom> "cum" is evocative, though not of the wrapped functions
10:17:06 <acowley> I kind of like et, but it's a bit of a stretch in terms of discoverability
10:17:19 <acowley> yes, I'll avoid that one
10:17:31 <monochrom> aggregate
10:18:21 <byorgey> how about aaaaand
10:18:32 <acowley> I did think about andd
10:19:13 <acowley> I could use the same operator syntax as Data.Bits
10:19:20 <acowley> as that's less likely to clash
10:20:07 <monochrom> conjoin
10:20:07 <acowley> except I'm often using this partially applied for optimization purposes
10:20:37 <acowley> there's probably a unicode character I could slip in
10:20:54 <acowley> but I'm not seeking to make new enemies
10:21:19 <acowley> well, I guess "and" and "or" will keep their prefixes
10:21:23 <luite> dcoutts: is there already some option to tell it to use the latest hackage version of all direct dependencies, regardless of what's already installed?
10:21:45 <monochrom> andalso (from sml)
10:21:52 <dcoutts> luite: --upgrade-dependencies
10:22:05 <dcoutts> luite: all direct and indirect dependencies
10:22:42 <byorgey> has anyone encountered "Missing (or bad) header file: HsUnixCompat.h" when installing unix-compat?
10:22:50 <dcoutts> byorgey: yes
10:22:53 <acowley> byorgey: you need bsd-devel or something
10:23:12 <dcoutts> byorgey: or ping jystic
10:23:13 <luite> dcoutts: ah great :)
10:23:20 <dcoutts> @seen jystic
10:23:21 <lambdabot> Unknown command, try @list
10:23:21 <preflex>  jystic was last seen on #haskell 57 days, 20 hours, 57 minutes and 49 seconds ago, saying: rostayob: jump on to #snapframework, there's quite a few of us using them
10:24:13 <dcoutts> unix-compat should avoid #including HsUnix.h from the unix package. It doesn't need it afaics.
10:26:00 * dcoutts wonders if there's an equivalent of "darcs send" for github repos
10:27:43 <byorgey> there is, IIRC
10:28:02 <byorgey> git send-email apparently
10:28:06 <byorgey> http://www.megacz.com/thoughts/git.for.darcs.users.html
10:29:12 <luite> cool, dvcs rosetta stone :)
10:29:23 <luite> almost
10:29:33 <Igloo> We also have http://hackage.haskell.org/trac/ghc/wiki/GitForDarcsUsers
10:29:46 <merijn> Is there a Darcs for Hg users? :p
10:30:01 <k0ral> oh dear
10:30:06 <k0ral> cabal is so lovely
10:30:30 <k0ral> cabal install on my project and it automatically downloads and installs missing libraries
10:31:26 <luite> my cabal is less lovely, it always complains about tabs in my .cabal files ;)
10:32:09 <k0ral> luite: real tabs ?
10:32:21 <k0ral> luite: you don't replace them with spaces ?
10:32:37 <monochrom> there are still real tabs? :)
10:32:45 <luite> I don't have indenting set up properly for .cabal files
10:33:24 <merijn> In addition to outlawing non-UTF-8 encodings my program for the election of Global President will also contain a section on outlawing tab characters
10:33:45 <acowley> Is there a GHC flag that will just output the RuleFired part of -ddump-simpl-stats?
10:33:52 <k0ral> merijn: you'll have my vote
10:33:56 * monochrom votes for merijn
10:33:58 <merijn> "But how will we use Makefile's?!" Well, I guess we'll just have to create a better alternative for them :p
10:33:58 <Twey> merijn for overlord!
10:34:02 <cheater__> merijn, aren't tab characters required for makefiles
10:34:18 <cheater__> oh... i see. very smart.
10:34:21 <merijn> cheater__: Two birds, one stone, etc ;)
10:34:27 <cheater__> <3
10:35:26 <monochrom> makefiles could switch to another character
10:35:39 <k0ral> makefiles are useless in haskell, aren't they ?
10:35:45 <merijn> Also, while I'm at it, no one will be allowed to use XML without a license (of course only obtainable after a grueling exam on the topic of "Things Which XML Is Not Suitable For")
10:36:03 <acowley> Makefiles can be more convenient that cabal for small programs
10:36:11 <acowley> as much as I do love cabal
10:36:26 <merijn> Also if you have a multi language program you might not be able to use only cabal
10:36:31 <k0ral> merijn: you should publish such law proposals in a blog
10:36:31 <monochrom> if you call haskell from c, you may still like makefiles
10:36:33 <thoughtpolice> makefiles can also do parallel builds, and you can have GHC generate the makefiles with dependency info with '-M'
10:36:38 <lispy> dcoutts: I always recommend people new to git read, pro git and the visual git guide (both easy to find via google).  For you, I would also recommend: http://wiki.darcs.net/RosettaStone
10:37:01 <dcoutts> lispy: ta
10:38:20 <dcoutts> acowley: cabal init lowers the overhead a bit, but in the longer term I'd like to be able to build simple progs without needing a .cabal file
10:38:46 <merijn> k0ral: Pretty sure that http://harmful.cat-v.org/ (and other parts of cat-v.org) already do all the condemning of technologies for me ;)
10:38:51 <k0ral> is there a way to have colors in cabal or ghc outputs ?
10:39:14 <dcoutts> acowley: but still benefit from e.g. pre-processor support etc
10:39:39 <k0ral> merijn: well, I was more suggesting to put them in a funnier way
10:40:07 <thoughtpolice> ah the cat-v trolls, such an interesting community.
10:40:09 <merijn> k0ral: That's exactly what they do :p
10:40:15 <acowley> dcoutts: I think the rough patches for little programs are cabal file setup/maintenance, the deep directory structure, and Makefile's handyness with adding actions to build steps
10:40:16 <luite> dcoutts: with the cabal-install program?
10:40:38 <dcoutts> luite: right
10:40:40 <merijn> thoughtpolice: They're more extremists then trolls I think :p
10:41:00 <dcoutts> acowley: right, so cabal init helps with the first. What do you mean about the dir structure?
10:41:24 <acowley> dcoutts: I mean where the executable ends up
10:41:32 <dcoutts> acowley: ah, the dist/mess/
10:41:36 <luite> dcoutts: it would be interesting if cabal init could then automatically infer the dependencies as used for this simple build without .cabal
10:41:37 <acowley> dcoutts: yeah
10:41:42 <k0ral> merijn: well, it could be even funnier if shaped like a real President programme :)
10:41:47 <dcoutts> acowley: I'd like to reorganise that to e.g. dist/bin/
10:42:05 <acowley> but also cabal init is still too involved compared to just copy/pasting a ghc invocation from a terminal into a file
10:42:14 <acowley> which is how I typically end up with a Makefile
10:42:16 <dcoutts> luite: it'd need to read the .hs files which is totally plausible but needs to wait for a proper build system impl
10:42:30 <acowley> dcoutts: dist/bin would be much friendlier!
10:42:33 <k0ral> merijn: I really like this website though :D
10:42:43 <aristid> acowley: a bash file may suit you even better
10:43:03 <dcoutts> acowley: the dev version of cabal init has fewer compulsory questions (just 1: lib or exe)
10:43:11 <thoughtpolice> merijn: considering how good they are at citing weird quotes from people at bell labs in the 70s/80s in response to, well, pretty much anything they disagree with, i just tend to think of them as trolls first and foremost
10:44:04 <acowley> aristid: possibly, but I'm not looking for anything new! cabal is fantastic for projects (not just one-off executables), and Makefiles are great because I know how to do what I need to do with them :)
10:44:21 <acowley> dcoutts: what about dealing with dependencies?
10:44:35 <acowley> dcoutts: it's nice to just let ghc figure that out
10:44:45 <dcoutts> acowley: yeah, mm, we'd really need that bit to be automated too, fair point
10:45:43 <acowley> I'm not sure if it's worth trying to duplicate what make (or even shell scripts as aristid suggests) is good at
10:46:21 <dcoutts> acowley: oh I'm sure it is, make has some pretty serious shortcomings
10:46:30 <acowley> I suppose it would be clever if there was a cabal init variant that could pick up GHC flags from a Makefile
10:46:43 <aristid> dcoutts: a bash script that just invokes ghc --make :)
10:46:51 <acowley> dcoutts: right, which is when I'd probably switch to a cabal file
10:47:02 <dcoutts> acowley: but replacing it is not trivial and I'm well aware that the "simple" build system is a pretty poor implementation of a build system
10:47:04 <luite> dcoutts: oh I was thinking about this a few days ago, is it possible to always install some package with a specific flag, for example always install vector -fsafe, even if vector is automatically upgraded when reinstalling some other package?
10:47:54 <acowley> dcoutts: as long as you're available on IRC, I've been able to do everything I've ever wanted through cabal :)
10:48:39 <k0ral> arrrg, a problem during compilation of webkit
10:48:48 <k0ral> Could not find module `System.Glib.GString'
10:49:42 <dcoutts> acowley: heh
10:50:24 <dcoutts> luite: the ~/.cabal/world file is intended for that kind of thing, but I'm not sure it's really working well yet.
10:51:56 <luite> dcoutts: ok, good to know
10:53:51 <k0ral> anyone's got a clue ?
10:57:14 <dafis> @hoogle System.Glib.GString
10:57:14 <lambdabot> No results found
10:57:21 <sm__> one of the reasons to use make is the ease of building random scripts that you need, and managing them all in one place. cabal has only a fixed vocabulary. I think you said that acowley
10:58:27 <acowley> yes, and something shell-like is probably more appropriate for such tasks than writing the same thing in Haskell, actually.
10:58:54 <lispy> k0ral: sorry, I haven't used webkit from Haskell
10:58:54 <lispy> k0ral: it sounds like a dependent package didn't install.  Does webkit use cabal?
10:59:42 <thoughtpolice> k0ral: cabal install gtk2hs-buildtools; cabal install glib i think?
11:00:48 <k0ral> lispy: well, it has a cabal file if that's what you mean
11:00:59 <k0ral> thoughtpolice: trying this and feeding back soon
11:01:54 <dafis> no System.Glib.GString in glib-0.12.0
11:02:05 <k0ral> yes, I already have installed it
11:02:42 <dafis> k0ral: did you notice which module requested GString?
11:03:07 <thoughtpolice> weird
11:03:11 <k0ral> gtk2hs-buildtools fixes the problem
11:03:25 <k0ral> should be put in dependency
11:03:35 <k0ral> mailing the maintainers
11:04:01 <k0ral> ah no
11:04:07 <k0ral> it doesn't actually
11:04:16 <k0ral> it just took more time this time to complain
11:04:30 <sm__> heh.. do not underestimate the wiles of gtk
11:04:37 <Twey> Haha
11:04:38 <k0ral> dafis: Graphics/UI/Gtk/WebKit/WebDataSource.chs:68:8
11:04:51 <Jafet> It is already a dependency
11:05:26 <Jafet> However, cabal quietly ignores it
11:05:35 <k0ral> Dependenciesarray, base (4.*), cairo (0.12.*), containers, glib (0.12.*), gtk (0.12.*), haskell98, mtl, pango (0.12.*)
11:05:44 <k0ral> Jafet: where do you see that ?
11:06:25 <k0ral> looking at bindings-glib
11:07:00 <k0ral> no that's not in
11:07:22 <dafis> hmm, the newest webkit which built on hackage is 0.11.1
11:07:28 * hackagebot unix-compat 0.2.1.2 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.2.1.2 (JacobStanley)
11:08:44 <k0ral> dafis: I used to have webkit 0.12.0 working
11:10:00 <eekTheCat> can you have pattern matching lambdas?
11:10:36 <dafis> eekTheCat: \(x:xs) -> x
11:10:45 <dafis> sure, but only one pattern
11:11:18 <eekTheCat> oh. thanks
11:11:22 <dafis> eekTheCat: you can however: \x -> case x of { pat1 -> alt1; pat2 -> alt2; ... }
11:11:41 <dafis> > (\(x:xs) -> x) []
11:11:42 <lambdabot>   *Exception: <interactive>:3:1-12: Non-exhaustive patterns in lambda
11:12:29 <byorgey> preflex: seen kolmodin
11:12:30 <preflex>  kolmodin was last seen on #haskell 40 days, 9 hours and 30 seconds ago, saying: :)
11:12:33 <eekTheCat> aha. I never remember haskell has a case statement
11:12:43 <Cale> We really need to get case sections :)
11:12:49 <Cale> case expression*
11:12:53 <dafis> eekTheCat: I can't live without it
11:12:59 <Saizan> k0ral: install the previous version of webkit
11:13:03 <b930913> Why is it that whenever I write more than one line of code in haskell, it never works?
11:13:14 <Cale> b930913: What's wrong?
11:13:22 <Cale> b930913: Does it compile?
11:13:26 <sm__> b930913: newbie!
11:13:39 <sm__> I can sometimes go as high as four
11:13:41 <Jafet> Hm, it seems that gtk now checks for buildtools in Setup.
11:13:44 <Saizan> k0ral: and maybe mail the maintainer saying that the latest released version of webkit requires a module from the darcs version of glib
11:13:49 <acowley> why would you need more than one line?
11:14:01 <b930913> Cale: I follow a tutorial, try to edit it in the slightest and it never works.
11:14:09 <dafis> b930913: example?
11:14:11 <Cale> b930913: Well, what are you trying to do?
11:14:16 <b930913> sm__: And yet I've never had this problem with other languages.
11:14:19 <acowley> b930913: link us the tutorial and your efforts thus far
11:14:36 <b930913> On this specific attempt I'm doing a simple factorial thing.
11:14:43 <Cale> okay
11:14:57 <b930913> I'll hpaste it for you.
11:15:01 <k0ral> Saizan: well, I formerly mailed the gtk2hs mailing list, which is also the webkit mailing list, and got no answer
11:15:02 <Jafet> b would never get away with that comment in #perl.
11:15:03 <sm__> b930913: haskell is much more dense than many languages, also more different so more mental rewiring needed
11:15:21 <k0ral> Saizan: so, I'm not really confident with contacting the maintainers
11:15:35 <sm__> you do have to think harder per line of code, at least for the first while. But the lines are fewer, and much better
11:15:43 <k0ral> Saizan: and that's really strange since I really used to make it work with 0.12.0
11:15:45 <b930913> sm__: That's an understatement :p
11:15:52 <dafis> preflex: seen ManateeLazyCat
11:15:52 <preflex>  ManateeLazyCat was last seen on #haskell 9 days, 7 hours, 49 minutes and 33 seconds ago, saying: ectospasm: I need go home, bye, good to see you. :)
11:16:04 <acowley> I still think way harder per line of code
11:16:08 <Cale> Is hpaste.org having trouble?
11:16:28 <b930913> Cale: Was just about to question so.
11:16:43 <b930913> 502s
11:16:45 <geheimdienst> b930913: my experience is that it's always hard to get anything to compile, but when it does, there's usually no bugs in it anymore. in python or other languages, pretty much anything "compiles" instantly, but then you spend some years on debugging ...
11:16:53 <Cale> downforeveryoneorjustme.com also sees it
11:16:58 <Saizan> k0ral: webkit-0.12.1 installs fine with glib-0.12.0
11:16:58 <Cale> (as down)
11:17:11 <Saizan> k0ral: webkit-0.12.2 doesn0t
11:17:12 <sm__> b930913: it does get a lot easier with practice
11:17:26 <k0ral> Saizan: investigating this way, thank you
11:17:42 <b930913> sm__: That would usually be all right, other than that I can't practice...
11:18:03 <Cale> b930913: Well, what is the compiler telling you the problem is?
11:18:14 <b930913> http://pastebin.com/WiXq5SMq
11:18:19 <hydo> b930913: You can't practice?  Man, your situation must be crazy.
11:18:32 <acowley> it is often harder to rely on your past language experiences when diving into Haskell
11:18:48 * sm__ suggests alternate coding, reading code, reading docs, and asking for help
11:18:50 <b930913> hydo: That's what I'm saying, anything past a line of code fails.
11:18:56 <Cale> b930913: Okay, so the problem is that readLn isn't a number, and so you can't pass it to factorial as a parameter
11:19:08 <Cale> (factorial only knows how to deal with numbers)
11:19:08 <hydo> I would go so far as to say that relying almost at all on past experience will hamper your progress with Haskell.
11:19:20 <Cale> So what you want to do is to run readLn first, to get a number
11:19:21 <acowley> which seems to be exactly what is happening here
11:19:27 <Cale> and then pass that number to factorial
11:19:38 <sully> hydo: unless his past experience is with lisp or ML, in which case it will help up to a point
11:19:45 <Cale> m <- readLn
11:19:48 <hydo> sully: this is true.
11:19:52 <Cale> print (factorial m)
11:20:02 <hydo> > :t readLn
11:20:03 <acowley> he already has n
11:20:03 <lambdabot>   <no location info>: parse error on input `:'
11:20:07 * sm__ adds: trying things interactively in ghci
11:20:08 <Cale> Right, he does
11:20:14 <acowley> I think it's just a typo
11:20:36 <acowley> well, a kind of typo
11:20:43 <b930913> ^
11:21:04 * sully came from ML and his process was like: 1) figure out how the syntax differs; 2) dive into typeclasses and monads and friends
11:21:05 <b930913> Still don't understand what half of it means though.
11:21:11 <Cale> b930913: readLn is an action, which when executed, will produce a number (or anything with an instance of the Read typeclass)
11:21:15 <dafis> b930913: change line 6 to print (factorial n)
11:21:25 <b930913> dafis: Yeah, that fixed it.
11:21:39 <Cale> If you write factorial readLn, it means to pass *this action* to factorial, which could then decide to execute that action as many times as it liked (or not at all)
11:21:57 <b930913> I'm interested to see how haskell handles such a large number so fast :)
11:22:06 <joe6> sully, have u tried agda?
11:22:13 <Cale> But factorial in this case isn't prepared to do that, it just wants a number. So you have to execute readLn first, and only pass the result to factorial.
11:22:18 <Cale> Does that make sense?
11:22:30 <b930913> Cale: No, but I'm sure I'll get it in time.
11:22:34 <sully> joe6: I have done some playing around with agda; not a whole lot
11:22:45 <Cale> Well, let me give you an example.
11:22:51 <joe6> do you find it easier to understand given your ML background?
11:23:08 <Cale> Let's write a function which takes a number and an action, and performs the action the appropriate number of times (a loop)
11:23:09 <b930913> print ends in \r\n?
11:23:22 <Cale> ends in whatever the line ending for your system is
11:23:33 <Cale> print is just a composition of putStrLn and show
11:23:39 <Cale> (show turns things into strings)
11:23:46 <dafis> b930913: if you don't want the newline, putStr (show n)
11:24:00 <b930913> Thanks.
11:24:16 <b930913> Does it really pass the buck like that, or is that optimised out?
11:24:29 <Cale> It really does.
11:24:39 <b930913> Ok....
11:24:39 <Cale> But optimisations like inlining apply generally
11:25:10 <b930913> So other than parallelisation, haskell is actually slow?
11:25:15 <Cale> ??
11:25:19 <dankna> dafis: ah hi!  got your email yesterday.  I think the build troubles you had must have been due to the fact that you're presumably using a released version of ghc whereas I'm using the head
11:25:28 <Cale> Do you have a program which runs too slowly that we can look at?
11:25:32 <Cale> ;)
11:26:07 <eekTheCat> can ghci print the source of a function?
11:26:09 <dankna> I have a program which runs too slowly that you can look at, haha
11:26:14 <c_wraith> on average, haskell is about is about -90% slower than ruby. :)
11:26:15 <b930913> Cale: As in theoretical speed of a language.
11:26:19 <dafis> dankna: 7.0.3, I could try a HEAD from like two weeks ago, don't want to build a ew one right now
11:26:33 <Cale> b930913: Languages don't have speeds, only language implementations do.
11:26:47 <dankna> dafis: well, or we could try to figure out why it crashes for you and fix that
11:26:54 <Cale> GHC produces quite good code, all things considered.
11:27:20 <dafis> dankna: an immediate segfault doesn't give many hints
11:27:42 <dankna> if you run under gdb you should get a minimal stack trace at least
11:27:44 <b930913> Cale: Compared to C or C++?
11:28:04 <dankna> won't be useful unless the segfault is in the rts, but I'm betting it is
11:28:10 <Cale> *Occasionally* we can be faster than C. Usually we're within some small facter.
11:28:14 <Cale> factor*
11:28:29 <b930913> Cale: On a multi core processor?
11:28:37 <c_wraith> *especially* on a multi core processor
11:28:41 <Cale> Even on a uniprocessor
11:28:51 <c_wraith> GHC's thread model is *far* better than most C threading libs
11:28:55 <Cale> But yeah, multicore makes it easy enough :P
11:28:56 <dafis> dankna: never got the hang of gdb, forgot what little I ever knew about using it
11:29:11 <dankna> dafis: ah, well, if you'd rather just try the HEAD instead, go for it
11:29:12 <kmc> most of what i know about gdb is from playing http://io.smashthestack.org:84/
11:29:35 <Cale> Data.ByteString for example has some rather clever rewriting rules in it which can make naively-written programs perform much faster than their naively written C counterparts.
11:29:37 <dankna> haha, interesting "game" that
11:29:58 <kmc> it's a game :)
11:30:05 <kmc> there are levels and rules
11:30:15 <kmc> you save your game by getting a password to each level, just like old NES games
11:30:19 <Cale> (by secretly processing things in a clever way in chunks)
11:30:20 <dankna> haha nice haha
11:30:55 <kmc> what i'd *really* like to see in the realm of automatic chunk cleverness is reordering / adjusting loops to fit caches
11:31:03 <kmc> i think DPH / Repa is supposed to do this?
11:31:26 <kmc> i think good optimizing compilers for Fortran do it too
11:31:27 <tibbe> kmc: lazy bytestring chunk sizes are tuned to fit L2 caches
11:31:28 <eekTheCat> is the magic of the $ that it's a right associative operator?
11:31:37 <Cale> kmc: Well, Data.ByteString.Lazy has some constants in it which were tuned to fit the average L2 cache
11:31:39 <kmc> there's no magic of $
11:31:43 <kmc> cool
11:31:51 <saati> eekTheCat: it's very low precedence
11:32:00 <Botje> eekTheCat: yes, foo $ bar $ baz parses as foo (bar baz)
11:32:10 <Botje> although some people are in favor of left-associative $
11:32:17 <Cale> Yeah, the more important thing is that it's low precedence. I don't recommend relying on the associativity of $
11:32:38 <kmc> no, it parses as (($) foo (($) bar baz))
11:32:40 <Cale> It's better to write  f . g $ x than f $ g $ x
11:32:51 <Cale> because f . g is meaningful on its own there, and f $ g won't be.
11:33:21 <kmc> or more readably (apply foo (apply bar baz)) where apply = id = ($)
11:33:22 <eekTheCat> makes sense. thank you
11:33:30 <thoughtpolice> kmc: i think it takes those things into consideration, yes (at least caches are mentioned in the repa paper, i can't remember the details)
11:33:48 <kmc> ($) is a real higher-order function, not a syntactic trick, which is useful
11:33:54 <kmc> > map ($ 3) [pred, succ]
11:33:54 <lambdabot>   [2,4]
11:34:10 <Cale> > zipWith ($) [(+2),(*2),(^2)] [5,6,7]
11:34:10 <lambdabot>   [7,12,49]
11:34:11 <thoughtpolice> and apparently DPH is going to be 'ready' with 7.2. hopefully it can finally be used in some greater capacity (i wonder what the status is of the syntax sugar...)
11:34:21 <kmc> it also means that occasionally (f $ x) is not equivalent to (f x), if you're using certain GHC type extensions
11:34:58 <c_wraith> kmc: or libraries that do, like ST
11:35:31 <kmc> yeah
11:35:32 * hackagebot unix-compat 0.2.1.3 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.2.1.3 (JacobStanley)
11:36:09 <kmc> @oeis 7,12,49
11:36:09 <lambdabot>  T(n,k)=Number of nXk binary arrays without the pattern 1 1 0 diagonally, ver...
11:36:10 <lambdabot>  [2,4,4,7,16,7,12,49,49,12,20,144,211,144,20,33,400,847,883,400,33,54,1089,32...
11:36:27 <b930913> So how would I go about making a prime finding brute?
11:36:50 <kmc> http://www.haskell.org/haskellwiki/Prime_numbers
11:37:09 <Cale> I'm a fan of:
11:37:32 <babusri> Are there any haskell tutorials that explain rank-2 polymorphism with lots of examples?
11:37:34 <babusri> In "Lazy Functional State Threads" it says "runST :: Vs, a. (ST s a -> a). Now, what we really want to say is that runST should only be applied to a state transformer which uses newvar to create any references which are used in that thread... That is, runST should work regardless of what initial state it is given. So the type of runST should be runST :: Va. (Vs. ST s a) -> a". Question: how does moving Vs inside prev
11:37:35 <babusri> ent a reference from one thread being used in another?
11:37:58 <kmc> here V represents ∀?
11:38:03 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
11:38:04 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
11:38:27 <kmc> babusri, not exactly a tutorial but maybe you'd like http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
11:38:29 <Cale> It's not the fastest implementation, but it's cute :)
11:38:40 <byorgey> jystic++
11:38:47 <dafis> Cale: yes, as long as you only want very small primes
11:39:02 <c_wraith> babusri: I learned most of what I know about higher-ranked types from this channel, actually.  someone, I think maybe ddarius, explained rank-2 types in terms of game theory, and that made a lot of sense to me
11:39:24 <kmc> right, it's a question of which player gets to choose the type
11:39:46 <Cale> Yeah, it's decent up to around a million or so.
11:39:59 <kmc> if i'm a function of type «∀a. (T a → R)», then you give me some A and I'm obliged to give you a function of type (T A -> R)
11:40:10 <thoughtpolice> babusri: if you were to return an STRef or something from 'runST' for example (which carries the 's' type parameter,) then because the type variable 's' is closed by the forall, it will not unify when you attempt to use the STRef in another block of code under 'runST'. that's one way to think of it
11:40:15 <c_wraith> rank-1 types, the caller chooses the type that goes into each type variable.  rank-2 types, the function being called gets to choose the type that goes into the type variable.
11:40:30 <kmc> if i'm a function of type «(∀a. T a) → R», then I demand that you give me a value for which *I* get to choose any A
11:40:31 <b930913> Cale: And how do I convert that into a compilable standalone?
11:40:31 <thoughtpolice> in other words, the two type variables 's' will be different and thus cannot unify. so you cannot leak STRef's for example, outside of the ST block they were created in
11:40:50 <jmcarthur> i can't wait for dph to be usable
11:41:00 <jmcarthur> i have so many things i just want to play around with using it
11:41:18 <kmc> i like the explicit-polymorphism style of System F, because it makes the question of who is providing and demanding types obvious
11:41:19 <erus`> Guys how can i coerce [Float] into [GLfloat]? It wasnt complaining about this at work :(
11:41:39 <Cale> b930913: The quickest way would be to add "main =" to the beginning and replace "in primes" with "in print primes"
11:41:50 <Jafet> erus: map floatToGLfloat
11:41:52 <c_wraith> erus`: different versions of the GL library.  older versions had GLFloat as a type alias for Float.  newer versions have it as a different type.
11:42:30 <Cale> b930913: But you might also want to separate the definitions in that let up to the top level in your file, and just write  main = print primes
11:42:59 <merijn> Cale: Will that actually work (since primes is an infinite list...)?
11:43:02 <Cale> yes
11:43:03 <erus`> ah super
11:43:10 <kmc> you can print an infinite list
11:43:11 <Cale> It will just print primes forever
11:43:21 <merijn> Nice :)
11:43:33 <dafis> merijn: but it will die of heap exhaustion some time
11:43:33 <Jafet> main = putStr (cycle ":-) ")
11:43:37 <kmc> > show (undefined :: [Bool])
11:43:38 <lambdabot>   "*Exception: Prelude.undefined
11:43:49 <kmc> hmm, why don't i get "[*Exception: Prelude.undefined"
11:44:05 <Cale> and then you can run  ghc -O2 --make primes
11:44:06 <Jafet> > show [undefined]
11:44:07 <lambdabot>   "[*Exception: Prelude.undefined
11:44:09 <kmc> someone's pattern match is too strict!
11:44:11 <Cale> assuming that your file is primes.hs
11:44:18 <kmc> > show (undefined :: String)
11:44:19 <lambdabot>   "\"*Exception: Prelude.undefined
11:44:22 <dafis> kmc: because the show instance pattern matches before the '[' is delivered
11:44:28 <kmc> it shouldn't ;)
11:44:32 <Cale> and you should get an executable called primes (or primes.exe if you're on windows)
11:44:39 <kmc> > fix error
11:44:40 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:44:53 <merijn> kmc: Does that ever get old? :p
11:44:56 <Cale> E X C E P T I O N
11:44:57 <dafis> kmc: library proposal
11:45:04 <hpc> kmc: if that extra strictness changes behavior in your program, something is terribly wrong ;)
11:45:09 <Cale> We have to go deeper!
11:45:22 <merijn> :t fix
11:45:23 <lambdabot> forall a. (a -> a) -> a
11:45:30 <b930913> Cale: Explain it to me in ##930913 where it's quieter?
11:45:36 <Cale> sure
11:45:39 <kmc> Cale++
11:45:41 <Jafet> hpc: with show, or with the program?
11:45:46 <merijn> I still don't fully get the type of fix
11:46:04 <kmc> @remember Cale <lambdabot> "*Exception: *Exception: *Exception: <Cale> E X C E P T I O N
11:46:04 <lambdabot> Good to know.
11:46:05 <babusri> Thanks kmc, thoughtpolice, c_wraith. I will read the blog article. Would ddarius explanation of rank-2 be available in irc archives?
11:46:09 <hpc> @src fix
11:46:09 <lambdabot> fix f = let x = f x in x
11:46:21 <merijn> Well...I get it, I just don't understand how it ever produces something useful
11:46:25 <kmc> babusri, it's almost certainly in there; but I'm not sure how you'd find it
11:46:26 <hpc> merijn: fix is more clearly written as "fix f = f (fix f)
11:46:27 <c_wraith> babusri: it really wasn't much more in-depth than what kmc and I provided here.  Just play with it a bit
11:46:34 <hpc> fix (1:)
11:46:38 <babusri> ok, thanks
11:46:39 <kmc> merijn, what about it?
11:46:44 <hpc> 1:(fix (1:))
11:46:49 <kmc> http://www.vex.net/~trebla/haskell/fix.xhtml
11:47:13 <hpc> > let whoknows = fix (1:) in head (1:whoknows) -- merijn
11:47:14 <lambdabot>   1
11:47:16 <kmc> merijn, what if i specialize it to ((s -> t) -> (s -> t)) -> (s -> t)
11:47:17 <Jafet> @where stepeval
11:47:17 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
11:47:21 <hpc> > let whoknows = undefined in head (1:whoknows) -- merijn
11:47:22 <lambdabot>   1
11:47:30 <hpc> merijn: that's how it makes useful values
11:47:32 <kmc> merijn, in strict languages you'd only use fix on function types
11:48:10 * merijn has achieved enlightenment
11:48:16 <hpc> :D
11:48:24 <monochrom> fix produces because recursion produces
11:48:42 <Twey> We use fix on non-function types?
11:48:48 <Twey> > fix 1
11:48:49 <lambdabot>   1
11:48:51 <Twey> Oh
11:48:53 <Twey> Okay
11:48:54 <merijn> 1 is a function :p
11:48:55 <hpc> AHAHAHAHA
11:48:58 <Twey> Oh yeah
11:48:59 <kmc> anyway it lets you translate explicit recursion of the form "let f x = ... f ..." to implicit recursion of the form "let f self x = ... self ..."
11:48:59 <Twey> Hahahaha
11:48:59 * merijn blames Cale
11:49:03 <Twey> That always trips me up
11:49:10 <kmc> "... in fix f"
11:49:11 <merijn> > fix true
11:49:11 <Twey> > fix "foo"
11:49:12 <lambdabot>   Not in scope: `true'
11:49:12 <lambdabot>   Couldn't match expected type `a -> a'
11:49:12 <lambdabot>         against inferred type `[GHC.T...
11:49:20 <kmc> Twey, i meant the type 'a' ;P
11:49:20 <Twey> merijn: :-D
11:49:26 <Twey> Ah, right
11:49:28 <merijn> > fix True
11:49:29 <lambdabot>   Couldn't match expected type `a -> a'
11:49:30 <lambdabot>         against inferred type `GHC.Bo...
11:49:32 <Twey> But that's just because a can be a function, surely
11:51:11 <kmc> if you define «fix f = f (fix f)» then the term «fix f» is useless unless a) «fix f» has a function type, or b) your language is non-strict, like Haskell
11:51:11 <hpc> :t let f = fix (const f) in f
11:51:11 <lambdabot> forall a. a
11:51:38 <hpc> kmc: it has to have a function type anyway
11:51:49 <kmc> "fix f" does?
11:51:52 <kmc> :t fix succ :: Int
11:51:53 <lambdabot> Int
11:51:58 <hpc> kmc: oh, nvm
11:52:05 <hpc> kmc: i thought you meant f
11:52:24 <Jafet> merijn: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+fix+f+%3D+f+%28fix+f%29+in+take+3+%28fix+%280%3A%29%29
11:52:34 <Twey> 200212 < kmc> merijn, in strict languages you'd only use fix on function types
11:52:41 <Twey> Is that not about f?
11:52:59 <dafis> dankna: built, profiling running now
11:53:07 <hpc> Jafet: awesome site
11:53:19 <Jafet> In strict languages, you implement Haskell, then use fix as usual
11:53:21 <monochrom> in strict languages, you'd only use fix to make a function
11:53:33 <Twey> Jafet: Greenspun's Eleventh?
11:53:42 <monochrom> @remember Jafet In strict languages, you implement Haskell, then use fix as usual
11:53:42 <lambdabot> I will remember.
11:53:48 <kmc> haha
11:54:06 <RayNbow> > fix (f :: Expr -> Expr)
11:54:06 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
11:54:11 <kmc> it's true that languages and systems tend to grow ad-hoc implementations of lazy evaluation
11:54:17 <Twey> It is
11:54:18 <merijn> Twey: Any sufficiently well documented Lisp program contains a Hindley-Milner implementation in the comments ;)
11:54:20 <dankna> dafis: ah cool :) you had observed that resident memory isn't bad at all - this is true.  the main problem is time performance, which I attribute to the massive amount of allocation it's doing, but see what you think.
11:54:24 <Twey> Python3 makes me chuckle
11:54:38 <merijn> Twey: How so?
11:54:46 <kmc> merijn, I work on a Python codebase which has Haskell types in the comments
11:54:52 <Jafet> (defun (fix f) (delay (f (fix f))))
11:54:57 <Jafet> If I got that right
11:54:57 <merijn> kmc: I have corrupted by brother :>
11:55:02 <Twey> merijn: They've basically gone through everywhere Py2 had lists and replaced them all with generators
11:55:10 <merijn> kmc: He's planning on writing a type JS to JS compiler :>
11:55:15 <kmc> haha
11:55:18 <merijn> s/type/typed
11:55:25 <merijn> To avoid having to do that in the comments
11:55:37 <dafis> dankna: allocation is probably part of it, but I think there's more to the slowness
11:55:43 <kmc> Jafet, I think that's the wrong syntax for "defun", isn't it (defun fix (f) ...)
11:55:47 <kmc> oh i forgot "lisp doesn't have syntax" ;)
11:55:59 <dankna> dafis: hmm.  well, that's absolutely possible.  I'm at a loss for what it could be though.
11:56:05 <merijn> I considered creating a Hindley-Milner python, but then I realized I could just write Haskell with everything in the IO monad...
11:56:06 <erus`> @hoogle floatToGLfloat
11:56:06 <lambdabot> No results found
11:56:09 <hpc> kmc: that's okay, it doesn't have standards either
11:56:15 <kmc> Common Lisp isn't a standard?
11:56:16 <hpc> just invent a lisp where defun works that way
11:56:17 <erus`> i cant find it
11:56:28 <hpc> ;)
11:56:37 <kmc> merijn, edwardk wrote some Javascript-with-bells-and-whistles to Javascript compiler
11:56:41 <kmc> i don't recall if it had static types
11:56:48 <kmc> but it has first-class continuations and tail-call optimization
11:56:49 <dafis> dankna: for example, gamestateFrameForward has 30% of allocation, but only 7.4% of time attributed to it
11:56:57 <dankna> dafis: hm, true
11:57:23 <hpc> kmc: you mean to say, edwardk wrote useful things before becoming a categorical mastermind?
11:57:27 <hpc> impossible!
11:57:32 <dafis> dankna: let me poke around a bit more, perhaps I'll find something
11:57:38 <Jafet> kmc: beware the lisp tarpit where everything is expressible but nothing of interest is communicable
11:57:46 <dankna> dafis: feel free :)
11:58:01 <kmc> knowing the value of everything and the cost of nothing
11:58:40 <hpc> kmc: that sure as hell beats knowing nothing of value ;)
11:59:45 <hpc> merijn: holy crap, haskell IO really is kind of like python with the bad bits removed
12:00:47 <merijn> hpc: That was also when I understood the entire "Haskell is my favorite imperative language" thing. Just add IO in front of every time and write everything with do notation :p
12:00:58 <merijn> s/time/type
12:01:04 <merijn> Wonder how I typo'ed that
12:01:18 <hpc> timecube = lambdacube?
12:01:23 <hpc> :D
12:01:40 <dankna> closed timelike curves :D
12:01:46 <dafis> dankna: out of curiosity, why do you foreign export everything from Emulator and then foreign import it instead of exporting the Haskell functions?
12:02:08 <dankna> dafis: oh, that's to be sure that the dummy front-end is doing everything exactly the same way as the real one
12:02:25 <dafis> ah, sensible
12:02:27 <dankna> dafis: since the real front-end is written in a platform-specific language (Objective C right now, since the Mac is the only platform I support)
12:02:28 <dankna> yeah
12:02:50 <hpc> dankna: whoa, didn't even think that was possible
12:02:57 <dankna> hpc: it is, but it takes some doing
12:03:10 <thoughtpolice> dankna has an emulator? for what :)
12:03:15 <dankna> hpc: I had to convince XCode to integrate with cabal
12:03:21 <dankna> thoughtpolice: the 8-bit Nintendo
12:03:25 <thoughtpolice> hpc: yeah i've seen it done before
12:03:37 <thoughtpolice> dankna: you would probably be a hero if you wrote up all the steps to integrate cabal w/ xcode, seriously.
12:03:51 <dankna> thoughtpolice: heh, noted.  well...  it's a really really ugly solution.
12:04:00 <thoughtpolice> i know lots of people are interested in forming a sort of OS X strike force, and one thing people want is to be able to interface with objective C, and have some way of writing UIs
12:04:22 <thoughtpolice> dankna: it seems that way, yes. :( it's possible to write full cocoa apps without xcode (you can't have menus without .nibs though,) just not documented anywhere
12:04:40 <dankna> thoughtpolice: yeah.  well, if you meet any of those people, send them my way and I'll give them my .xcodeproj file at least.
12:04:54 <thoughtpolice> and recently I fixed GHC so it can understand objective-C code properly, so it should be possible to write shims and package them with their executable
12:05:01 <dankna> thoughtpolice: actually you CAN have menus without .nibs, but that's orthogonal because you can also have .nibs without XCode
12:05:11 <thoughtpolice> (that is you can now feed GHC raw .m files and it'll do the right thing)
12:05:15 <dankna> (right, nice)
12:05:17 <thoughtpolice> dankna: oh, didn't know that
12:05:54 <acowley> Being able to write gui apps on the mac in Haskell would be fantastic
12:05:56 <dankna> thoughtpolice: yeah.  the ibtool program is a command-line compiler from .xib to .nib.
12:06:04 <thoughtpolice> dankna: i've been thinking of stealing all the native code out of _why's shoes, which implements a small shim of code for UIs across win32/gtk/osx
12:06:05 <acowley> it's such a sad state of affairs
12:06:17 <dankna> acowley: I agree.
12:06:37 <thoughtpolice> acowley: it's *doable*, benl did it for a repa demo and it definitely works (foreign export your functions to objective-C, and have it call them,) but nobody has documented it and that's certainly not ideal
12:06:52 <dankna> thoughtpolice: I think it's better to write a shim for each app rather than trying to write an all-purpose shim; you get better platform-native behavior that way
12:06:58 <acowley> I think the ambition of some people holds back getting the basics working
12:07:04 <thoughtpolice> preferrably there could be a tool that could generate an initial framework for you, much like cabal init, that could then be built with 'xcodebuild' or something
12:07:30 <dankna> honestly, having done it both ways now (XCode calling Cabal, and Cabal calling ibtool), I think the latter makes more sense
12:07:30 <acowley> e.g., we all want FRP, but somehow it's turned into an FRP-or-nothing scenario
12:07:55 <thoughtpolice> dankna: are .xib files documented publicly anywhere?
12:08:24 <merijn> acowley: I think the bigger problem is that writing GUI toolkits isn't fun or cool so no one bothers to do it
12:08:24 <dankna> thoughtpolice: possibly, but they don't need to be - you can edit them in Interface Builder but not use XCode as your build tool
12:08:28 <thoughtpolice> ah
12:08:41 <dankna> IB is actually a very nice tool, it's the rest of XCode that is crap :/
12:08:50 <acowley> merijn: well that's the main issue yes, but we're diluting what effort we might be able to muster by aiming high
12:08:55 <aristid> merijn: web frameworks are cooler?
12:09:17 <thoughtpolice> xcode 4 is a substantial improvement at least. i know at one point someone an UNSW had integrated GHC into xcode with a plugin, so you could build haskell code with xcode and interface with objc and stuff
12:09:20 <dankna> .xib is also a self-explanatory XML format, so it plays nice with version control and such
12:09:26 <thoughtpolice> but that was never released publicly, and it was several years ago :/
12:09:27 <merijn> aristid: Of course
12:09:29 <dankna> I actually can't stand XCode 4
12:09:32 <acowley> If a per-app shim is the right thing, then we desperately need a pretty detailed tutorial
12:09:37 <aristid> acowley: i think there are some low-level cocoa bindings projects
12:09:38 <merijn> aristid: At the very least less annoying/painful to write
12:09:44 <geheimdienst> dankna: but i thought IB got folded into Xcode with version 4...?
12:09:56 <dankna> but I haven't decided yet whether that's due to its inherent flaws or just to its being different
12:10:19 <thoughtpolice> dankna: i use it for some self-contained C/C++ code because it has decent online error completion etc. i don't use it for much else. i would LOOOOOOOVE if someone could integrate that into an emacs mode though
12:10:41 <dankna> geheimdienst: true, although it's actually a .framework (a Mac shared library) that can be run from an external program, but nobody has done that yet.  but the main point is that you can just use it as an editor and not a build tool..
12:10:54 <dankna> geheimdienst: you can just open the .xib file without it being part of a project
12:11:11 <dankna> thoughtpolice: integrate what with an emacs mode, precisely?
12:11:31 <thoughtpolice> dankna: autocomplete, and online error reporting.
12:11:33 <geheimdienst> yes, absolutely. i meant that more as a question because you said you like IB but not Xcode
12:11:38 <thoughtpolice> that's mostly it, and clang can do basically all of that
12:11:54 <dankna> geheimdienst: ah okay.  yeah.  haven't wrapped my brain around them being one tool yet :/
12:12:02 <dankna> thoughtpolice: ah, yeah
12:12:03 <thoughtpolice> in fact, i recently discovered: clang -w -fsyntax-only -Xclang -code-completion-at=<filename>:<line>:<char> <filename> (thanks sigfpe!) which will do code completion from the command line
12:12:13 <dankna> oh nice!
12:12:36 <thoughtpolice> so, i think it's definitely doable. some more advanced stuff may need to be delegated to a helper tool built with libclang, though :/
12:12:44 <geheimdienst> just to be clear, i have to use IB/xcode at work and find both of them underwhelming ... it's not in any way impressive
12:12:50 <geheimdienst> :)
12:13:11 <dankna> anyway, I don't know about writing up my notes, but I'm actually working now on a simple Cabal-calling-ibtool thing for the Mac front-end of treeedit (or whatever we're calling it - I'm calling my version TE)
12:13:33 <dankna> and I can absolutely release an early version of it as a demo of how to make the build infrastructure work
12:14:18 <dankna> geheimdienst: if you don't do a lot of GUI design you may not appreciate the really nice features of IB for layout and the like, as compared to other tools like the Qt one.
12:14:34 <dankna> geheimdienst: I agree that it has its problems, but I think it's good for what it's designed for.
12:15:41 <eekTheCat> is it a good idea to always specify the type of functions I declare?
12:15:56 <dankna> eekTheCat: yes.  you'll get much more helpful error messages that way, and often better performance as well.
12:16:10 <kmc> eekTheCat, it's common to declare the type of all functions at the top level of the file
12:16:17 <kmc> it's a good idea
12:16:24 <kmc> less common to write signatures inside "let" or "where" or on lambdas
12:16:37 <eekTheCat> dankna, by performance do you mean compile time?
12:16:41 <kmc> i do that in cases where it's particularly helpful for thinking about the code
12:17:03 <geheimdienst> i don't know how it compares to Qt, but i some years ago i used eclipse, and xcode of today is no match at all in my opinion ...
12:17:09 <dankna> eekTheCat: that too, but no, I meant runtime performance.  if a type is inferred it may not choose the most specific useful type; for example, I had a case the other day where it was choosing Integer instead of Int.
12:17:17 <geheimdienst> how do you mean "nice features for layout"?
12:17:31 <dankna> geheimdienst: I've never used Eclipse, I fear (well, I started it up once.  took about ten minutes as I recall.)
12:17:31 <kmc> or it might produce more generic code (that works on both Integer and Int) but is slower
12:17:32 <eekTheCat> kmc, how would one specify the type of a lambda expression if one were so inclined?
12:17:40 <kmc> :t (\x -> x+3) :: Int -> Int
12:17:41 <lambdabot> Int -> Int
12:17:44 <dankna> geheimdienst: things like the little snap-guides as you're dragging widgets around.
12:17:47 <kmc> eekTheCat, you can put a type signature on *any* expression
12:17:52 <kmc> > (2 + 2) :: Float
12:17:53 <lambdabot>   4.0
12:18:20 <dmwit> With appropriate extensions, you can even put type signatures on patterns.
12:18:32 <dmwit> > (\x :: Double -> x + 3) 5
12:18:32 <lambdabot>   Illegal result type signature `Double'
12:18:32 <lambdabot>    Result signatures are no longer s...
12:19:38 <dankna> > (\(x :: Double) -> x + 3) 5
12:19:38 <lambdabot>   8.0
12:19:41 <dankna> there you go
12:21:05 <eekTheCat> dankna, kmc, thanks
12:21:11 <dankna> np
12:25:53 <joe6> any suggestions on how I can have a multi-line label with Test.HUnit? Having a label "label description\nnext line description" does not seem to help.
12:26:20 <joe6> it just prints it as a single line.
12:27:00 <joe6> it would be great if i can do something as: TestLabel (putStrLn "label description\nnext line description") . TestCase ...
12:27:13 <joe6> > TestLabel
12:27:14 <lambdabot>   Not in scope: data constructor `TestLabel'
12:28:07 <dylukes> So, I might decide to just do a language,
12:28:12 <dylukes> entirely based on self-mutation :\
12:28:27 <dylukes> Fun would arise from not having data structures, just rewritable functions :3
12:28:45 <dylukes> The necessity of "functions" is also dubitable.
12:28:52 <dylukes> Since you can represent them via substitutions...
12:29:09 <dafis> dankna: the three big allocators showing up in the heap profile are all decodeINESFile, but what they allocate is peanuts compared to runMonadicState' and gamestateFrameForward. Nevertheless, I'm going to strictify INES and see what that gives.
12:30:12 <dankna> dafis: yes, as far as I can tell the bulk of the stuff that shows up in the heap profile is the lists [0..whatever] that I create to pass to the "array" constructor in decodeINESFile
12:30:22 <dankna> dafis: I don't understand why those are being retained though
12:30:33 <dankna> dafis: by all means mess with that and see what happens
12:30:48 <dankna> dafis: as I certainly will want to solve that issue at some point, whether it's the main one or not
12:31:32 <dafis> dankna: it might help meaking the main point easier to find, at least that's my hope
12:31:36 <dankna> indeed so
12:36:51 * hackagebot spelling-suggest 0.5.1.0 - Spelling suggestion tool with library and command-line interfaces.  http://hackage.haskell.org/package/spelling-suggest-0.5.1.0 (GregWeber)
12:41:35 <b930913>    Could not find module `Control.Parallel.Strategies':
12:42:34 <b930913> cabal install Control doesn't work either.
12:43:07 <dafis> b930913: cabal install parallel
12:43:22 <joe6> is it possible to tell a library to use a different function not defined in that library? something, like overloading of functions?
12:45:22 <b930913> dafis: Thanks.
12:45:46 * eekTheCat wishes haskell programmers were less terse with their variable names
12:45:52 <dankna> me too
12:46:06 <dankna> I use variable names in the 10-to-40-character range, heh
12:46:22 <acowley> sry
12:46:25 <dankna> I tend to be a bit extreme in the opposite direction, as we have frequently discussed :)
12:46:58 <c_wraith> map theFunctionToApply (theFirstValueInTheList:theRestOfTheList) = theFunctionToApply theFirstValueInTheList : map theFunctionToApply theRestOfTheList
12:47:17 <djahandarie> When I run out of single letter English variables, I switch to Greek!
12:47:45 <mauke> σουγοι
12:48:04 <acowley> djahandarie knows what's up
12:48:17 <acowley> I'm going to start using semantically significant unicode whitespace
12:48:22 <acowley> it will be zen
12:48:30 <eekTheCat> dankna, do you any public projects? I learn by reading code. Maybe it would help to stare at code that has one less hurdle to comprehension
12:48:38 <acowley> Follow the types, Luke.
12:48:55 <djahandarie> acowley, the types will of course all be in whitespace as well
12:49:23 <acowley> naturally
12:49:24 <dankna> eekTheCat: sometimes, yes, I have things on hackage such as direct-sqlite or language-sqlite, but also you can see everything I've released at http://dankna.com/software/darcs/
12:49:55 <dafis> dankna: kind of success, the heap profile now shows about ~80k max instead of ~850k and is not flat anymore, gc significantly reduced, running time a few %
12:50:43 <eekTheCat> dankna, thanks
12:51:16 <eekTheCat> acowley, you're starting to make me think that language support for unicode source files is a bug not a feature
12:52:03 <acowley> eekTheCat: in all seriousness, unicode support is fantastic if you have a reasonable entry mode (and I think emacs' TeX-input mode is just reasonable)
12:52:05 <djahandarie> eekTheCat, every feature is a bug in the hands of the wrong person.
12:52:09 <kmc> with great power comes great responsibility
12:52:13 * acowley is probably the wrong person
12:52:27 <djahandarie> I think Unicode is far overused in Agda code personally.
12:52:37 <acowley> we have so many debates about operator symbols, it's nice to have more options
12:52:58 <kmc> unicode support isn't just a matter of cute math symbols
12:53:06 <kmc> it's a matter of allowing the majority of the world population to use their native languages
12:53:18 <djahandarie> That oddly seems to never happen.
12:53:20 <acowley> djahandarie: I think I agree, but I know most of the pain I experienced with Agda's unicode was part of the learning curve
12:53:31 <copumpkin> anyone know who owns comonads.com?
12:53:42 <djahandarie> copumpkin, maybe ray?
12:53:43 <saati> kmc: they don't want to
12:53:53 <saati> it just creates mess if code is not in english
12:54:09 <kmc> that sounds just a wee bit imperialist
12:54:17 <eekTheCat> yeah, I've talked to german programmers who say they are punished if any non english slips into their code
12:54:20 <acowley> kmc: True. I once spent a long time trying to decipher a symbol ccshan used in a paper, only to have my wife glance at it and ask why there was a Chinese character in the code.
12:54:27 <kmc> heh
12:54:31 <monochrom> indeed their are people opposing unicode with the reason "you should stick to english in source code"
12:54:36 <monochrom> s/their/there/
12:54:39 <saati> english is not my mother tounge, so i could have said we don't want to
12:54:49 <monochrom> "if your comments are in chinese, I can't read it"
12:55:13 <monochrom> of course their exact wording is "other people can't read it" but we know what they really mean
12:55:48 <ben> kmc: Would we not need to translate APIs to all kinds of languages with funny glyphs
12:56:05 <JuanDaugherty> a chinese programmer told me a long time ago programming in chinese didn't make sense
12:56:05 <kmc> it seems strange to contemplate a world in which the majority of software is written by Chinese people and commented in English
12:56:43 <kmc> ben, I don't think anyone cares enough to translate APIs
12:56:45 <ben> unless I am missing something, between all the chinese variable names and whatever you'll still have calls to an english-named standard library etc
12:56:47 <edwardk> preflex: xseen gehemdeinst
12:56:47 <preflex>  Sorry, I haven't seen gehemdeinst
12:57:13 <JuanDaugherty> but a modern compile with full support ought to be able to accept hanzi user defined names
12:57:16 <edwardk> preflex: xseen geheimdienst
12:57:16 <preflex>  geheimdienst was last seen on freenode/#haskell 40 minutes ago, saying: how do you mean "nice features for layout"?
12:57:21 <monochrom> I want to write comments in chinese if I want manateelazycat to read it
12:57:21 <ben> Yeah, I agree
12:57:38 <JuanDaugherty> *compiler
12:57:40 <edwardk> geheimdienst: so, i hear i'll need to acquire edwar.dk from you ;)
12:57:41 <kmc> there are some efforts to localize keywords and standard library identifiers to various natural languages
12:57:43 <ben> I do think it's pretty questionable to tell other people what language to write/comment their code in
12:57:45 <nihtml> np: Led Zeppelin - Kashmir (8:330
12:57:51 <nihtml> oh sorry
12:58:03 <kmc> but they're usually someone's nationalist pet project, not something that will be widely adopted
12:58:04 <ben> that's a lot of seconds
12:58:16 <danharaj> who needs descriptive names anyway when you have descriptive types
12:58:23 <notmycupoftea> is there someone who knows how I can make this work: instance Show [MyType Int] where ?
12:58:36 <kmc> notmycupoftea, there's already an «instance (Show a) => Show [a]»
12:58:39 <PhillipA> notmycupoftea: you don't need to
12:58:39 <kmc> yours would overlap
12:58:48 <kmc> i suspect the fact that most code today is commented in English implies that most code in the future will be commented in English
12:59:06 <kmc> for the same reason that it's hard to get people not to use C
12:59:09 <ben> daten Vielleicht a = Gerade a | Nichts
12:59:11 * ben shudders
12:59:11 <PhillipA> notmycupoftea: why not instance (Show a) => Show (MyType a)?
12:59:12 * JuanDaugherty disagrees that the existing English should be translated, have to work out a first register of the effective lang anyway
12:59:14 <dafis> notmycupoftea: use the showList method in MyType's Show instance
12:59:39 <notmycupoftea> and what if I want my own specialized version? not the predefined one?
12:59:42 <dafis> ben: Juist a | Nixdorf
12:59:43 <edwardk> monochrom: the two _reasonable_ counter arguments to unicode in source code is that you're screwed one way or the other depending on if you normalize or don't normalize the names. one way you can have identical _looking_ glyphs be different variables, and the other you can have glyphs that look different that are the same. both introduce obfuscation opportunities
12:59:57 <kmc> notmycupoftea, just write your own function of that type
13:00:00 <kmc> it doesn't need to be named "show"
13:00:23 <danharaj> How do you add a branch to a github project? I know how to make a local branch. How do I make github recognize it?
13:00:24 <notmycupoftea> oke, but what's the purpose of having Show then?
13:00:26 <jmcarthur> notmycupoftea: i would make a newtype wrapper
13:00:41 <jmcarthur> the purpose of show is for debugging, mainly
13:00:42 <ben> danharaj: you just push it, git push yourremoteatgithub branchname I think
13:00:49 <PhillipA> notmycupoftea: what's wrong with showList?
13:01:13 <edwardk> my fix has been, to date, when trying to specify a language which uses unicode variable names and symbols, is to require that both the normalized and unnormalized versions of the code should have the same meaning -- but then the normalization rules that are standardized are a bit more broad than you probably want
13:02:12 <notmycupoftea> well.. I want to do some additional formatting
13:02:43 <PhillipA> notmycupoftea: what's wrong with showList?
13:03:00 * hackagebot X11-xdamage 0.1.2 - A binding to the Xdamage X11 extension library  http://hackage.haskell.org/package/X11-xdamage-0.1.2 (EwanHiggs)
13:03:06 <jmcarthur> Show isn't guaranteed to be appropriate for output
13:03:26 <jmcarthur> like i said, it's mainly for debugging. it may happen to work out to be the right format for output sometimes
13:03:38 <dankna> dafis: oh!  was afk a sec, just saw your last.  wow, just by strictifying decodeINESFile?  I could have sworn I already did that!
13:04:09 <dafis> dankna: no, strictified the entire module :)
13:04:13 <dankna> oh okay.
13:04:32 <notmycupoftea> PhillipA: I want to do this http://hpaste.org/47099/x, I guess that doesn't fit showList
13:04:45 <dafis> dankna: I suppose for fine-tuning, you'd want to remove a number of bangs
13:04:48 <PhillipA> notmycupoftea: why not?
13:05:30 <dankna> dafis: perhaps, yeah, but we can worry about finding the minimal set of bangs that are necessary once we have one that works at all
13:05:43 <monochrom> instance Show (MFP ConstantProp) where showList xs = ...
13:05:47 <dafis> dankna: oh, and replaced all the calls to array (0,x) $ zip [0 .. ] with listArray
13:05:53 <dankna> oh!  right, good call
13:07:22 <dafis> dankna: but the bottleneck is still runMonadicState' and, to a lesser degree gamestateFrameForward, unfortunately, runMonadicState' is TH-generated
13:07:49 <cheater__> that's what you get for using TH
13:07:51 <dankna> dafis: the definition of it is simply runMonadicState' (MonadicState action) = action
13:08:27 <dankna> dafis: it's called twice by the definition of >>= in the Monad MonadicState instance
13:08:39 <danharaj> ben: thanks. I wasn't giving enough parameters.
13:08:56 <dafis> dankna: yes, that instance is what I'd like to be able to futz around with
13:09:17 <dankna> dafis: would you like me to hpaste you a nicely-indented version of the instance source, then?  one sec
13:11:31 <notmycupoftea> PhillipA: I see now ;) thanks!
13:11:46 <develhevel> when i make somethin with do notation, at the end of the do it alaways want to have a output, so i write putStr "" is there a more elegant way?
13:12:00 <dankna> develhevel: return ()
13:12:02 <PhillipA> develhevel: it doesn't want output
13:12:28 <Guest34588> hi guys, I have a desing question, may I ask?
13:12:44 <monochrom> I feel that sometimes http://xkcd.com/763/ applies
13:13:00 <kmc> develhevel, can you put your code on hpaste?
13:13:31 <develhevel> return () was what i mean :) thx guys
13:13:55 <develhevel> kmc: no need, thx. i used a wrong english :)
13:14:44 <Guest34588> I have a problem designing my types
13:14:58 <kmc> Guest34588, go ahead and ask :)
13:15:22 <Guest34588> Let's say I want have few implementations of Inverted Indexes
13:16:02 * hackagebot spelling-suggest 0.5.2.0 - Spelling suggestion tool with library and command-line interfaces.  http://hackage.haskell.org/package/spelling-suggest-0.5.2.0 (GregWeber)
13:16:15 <Guest34588> the inverted indexes can be represented as ADT (abstract data types)
13:16:22 <jargonjustin> I'm having trouble running a script with runghc, it claims "Could not find module". I've got a directory containing various InstalledPacakgeInfo files and doing a `ghc-path -f $mydir find-module $mymodule lists the package with the appropriate module. I've set GHC_PACKAGE_PATHS to $mydir and runghc -v states "Using binary package database: $mydir/packacge.cache. What am I doing wrong?
13:16:45 <Guest34588> thus, they have 4 basic operations: first, last, next, prev
13:17:59 <Guest34588> each of those functions takes or returns an argument of type Position
13:18:18 <aristid> parsec quiz of the minute: what is wrong with some (oneOf charset) `sepBy1` skipMany1 space
13:18:26 <Guest34588> the problem is that the Position can mean different things
13:18:41 <Guest34588> for one type of Inverted Indexes it is just an integer
13:19:03 <Guest34588> for others it is a tuple (Integer, Integer)
13:19:23 <PhillipA> aristid: is parsec an Alternative?
13:20:06 <Guest34588> thus, to summarize: only 4 funcitions and definition of Position is specific to each type of Indexes, the rest of functions are all the same
13:20:19 <Guest34588> what would be the proper way?
13:20:57 <aristid> PhillipA: yes
13:21:19 <aristid> PhillipA: i know what the problem is, and this is not it. it's a quiz :)
13:21:48 <PhillipA> well, I blame all parsec problems on its early-commit behavior but I don't know what's wrong here
13:22:07 <monochrom> I say, what's wrong is that I wouldn't write that code
13:23:23 <monochrom> although I don't know what that code intends and fails to do, I bet once it's revealed it's another case of http://xkcd.com/763/
13:23:41 <dankna> dafis: is http://hpaste.org/47100/manually_indented any help to you?
13:24:30 <monochrom> on a tangent, there is a similar thing with error messages
13:25:18 <Guest34588> Do I have to use something like Type Families?
13:25:47 <monochrom> people show you an abridged error message and ask "how to fix it" like the pros can look at one word of the error message and know
13:25:56 <dafis> dankna: don't know whether that helps, will have to stare at it a while
13:26:10 <PhillipA> monochrom: sometimes they can
13:26:18 <monochrom> fact is the pros don't even write code to cause such errors, they probably have never seen that error message before
13:26:55 <PhillipA> monochrom: e.g. in C "two or more data types in ..." almost always indicates a missing ';' after a struct definition, possibly in an include file
13:26:57 <dankna> dafis: heh okay.  in the course of indenting it I realized that strictFunctionCallExpression might have a bug, heh.  in particular I can't figure out where the excess "temp"s on lines 21 and 26 of the paste came from :/
13:27:19 <dankna> dafis: although if it didn't belong there, I would think that the result wouldn't typecheck.
13:27:45 <monadic> dankna: Why do you bind so many expressions to the temp identifier? It does _not_ help code readability at all.
13:27:56 <dankna> monadic: this is code generated by Template Haskell.
13:28:01 <monadic> dankna: Oh, okay.
13:28:04 <dankna> hehe
13:28:11 <monadic> dankna: I just came in as soon as you posted the link.
13:28:12 <jargonjustin> Ah, got it. Using -package-conf instead of GHC_PACKAGE_PATH seems to do the trick.
13:28:15 <dankna> I couldn't obfuscate it better if I were trying, believe me, haha
13:28:43 <kmc> we do need another obfuscated haskell contest
13:28:53 <dankna> dafis: I can explain what this monad is actually doing if you would find that helpful?
13:29:04 <kmc> i have what i think is a respectable entry, but i'm sure others can do much better
13:29:13 <dafis> dankna: probably
13:30:11 <dankna> dafis: it's continuation-passing style.  the type MonadicState a is defined as...
13:30:46 <dankna> dafis: forall r . (a -> field0 -> field1 -> ... -> field49 -> r) -> field0 -> field1 -> ... -> field49 -> r
13:31:09 <dankna> so an action in the monad takes as its first parameter a continuation, and returns as its result a value of type r
13:31:11 <monochrom> 50 fields?!
13:31:16 <dankna> monochrom: Template Haskell
13:31:17 <acowley> I have a demo of some OpenCV code that does in-place updates on compositions of operations and a whole bunch of wacky stuff to a webcam feed and it *almost* fits into two tweets.
13:31:23 <monadic> monochrom: I guess thats why hes using Template Haskell!
13:31:24 <dafis> dankna: newtype wrapped, I suppose?
13:31:25 <monochrom> alright that's better
13:31:28 <dankna> dafis: yes, newtype wrapped
13:31:30 <kmc> acowley, nice!
13:31:31 <kmc> what language?
13:31:38 <acowley> kmc: Haskell of course!
13:31:44 <kmc> cool, can i see?
13:31:50 <acowley> I really wanted it to be a tweet :/
13:31:51 <acowley> sure
13:31:59 <acowley> I saved videos
13:32:02 <acowley> or do you mean the code?
13:32:05 <kmc> the code
13:32:07 <kmc> but videos too
13:32:12 * Eduard_Munteanu whispers *ST*
13:32:16 <acowley> Here's a simple one
13:32:17 <acowley> main2 = createCameraCapture (Just 0) >>= runWindow . fmap proc
13:32:18 <acowley>     where proc = canny 70 110 3 . convertRGBToGray
13:32:18 <acowley>  
13:32:18 <dankna> dafis: so the return type of the action, once it's unwrapped, is "r", which is given by the forall, meaning the caller gets to specify that type, not the action
13:32:42 <dankna> dafis: therefore the action's only means of getting such a value is to get it out of the continuation that it's passed as its first parameter
13:32:51 <acowley> That's a real-time display of canny edges
13:33:03 <acowley> and only one duplicate video frame is created
13:33:23 <dankna> dafis: the first parameter takes an "a", which is the value you want to actually return in the monad, and it takes all the state fields, and it returns an "r"
13:33:28 <kmc> what library are you using?
13:33:32 <acowley> the canny and convert calls are joined up
13:33:35 <dankna> dafis: blame Saizan for this architecture by the way :)
13:33:45 * dafis blames Saizan
13:33:47 <acowley> my OpenCV bindings
13:33:53 <acowley> I forked someone elses a long time ago
13:34:03 <acowley> and have been using them in various projects at work for a year or so now
13:34:05 <kmc> cool, are they on hackage?
13:34:07 <dankna> dafis: hehe.  anyway, the purpose of all this is to avoid what had been a huge expense in a prior version of the program, which was heap-allocating all these records.
13:34:09 <acowley> so I'm finally cleaning them up
13:34:18 <acowley> kmc: no, but I forked one of the ones on hackage
13:34:23 <dankna> dafis: this way the fields of the records are kept on the stack and passed from one line of the action to the next to the next to the next.
13:34:29 <acowley> kmc: the problem with everyone's OpenCV bindings is that they're all wildly incomplete
13:34:39 <acowley> kmc: which mine is, too
13:34:50 <dafis> dankna: oh, I just wanted to ask whether packing all those args in a record might help :(
13:34:53 <acowley> kmc: it ends up being a rather unfriendly thing for a Haskell+CV newcomer to discover
13:34:56 <dankna> dafis: making this transparent is the raison d'etre of Data/FlattenedRecords.hs and is the only reason I'm using TH at all
13:35:01 <dankna> dafis: unfortunately not :(
13:35:03 <kmc> why are they all incomplete?
13:35:16 <acowley> kmc: because OpenCV has more surface area than the earth
13:36:04 <acowley> kmc: and to make using it from Haskell at all worthwhile, a considerable amount of time needs to be spent massaging argument orders and types, etc.
13:36:30 <dankna> dafis: as an experiment, by the way, I tried making the field accessors nops and changing the type to just newtype MonadicState a = MonadicState (forall r . (a -> r) -> r)
13:36:38 <dafis> dankna: holy shit, 724.7k of splices
13:36:40 <dankna> dafis: the performance problem was, to my amazement, still present.
13:36:41 <acowley> kmc: so I track number of color channels and pixel depth in the types, and have this unsafePerformIO rewrite rules dance
13:36:42 <dankna> dafis: yes I know!
13:36:47 <develhevel> how to replace chars in a string? e.g. i want to replace "-.-" with "_" so that "hi-.-2" will be "hi_2"
13:36:59 <acowley> kmc: but it takes me some time to add any new functionality
13:37:12 <acowley> kmc: just to think about how I'd want to use it from Haskell
13:37:21 <merijn> @hoogle [Char] -> [Char] -> [Char]
13:37:21 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
13:37:22 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
13:37:22 <lambdabot> System.FilePath.Posix combine :: FilePath -> FilePath -> FilePath
13:37:24 <Eduard_Munteanu> dankna: have you tried sprinkling cost center annotations around? What's allocating so much?
13:37:29 <merijn> Hmm, that's not helpful >.>
13:37:32 <dafis> > let xchange '-' = '_'; xchange c = c in map xchange "hi-there"
13:37:33 <jargonjustin> Hmm, now runghc is giving me "Not in scope: `main'" when I invoke it on a haskell script (no module declaration.) How can I troubleshoot this?
13:37:33 <lambdabot>   "hi_there"
13:37:43 <dankna> Eduard_Munteanu: doesn't -auto-all do everything I need for cost-center annotations?
13:37:44 <dafis> develhevel: ^^
13:37:51 <merijn> dafis: That doesn't work with multiple characters like his example
13:38:05 <Eduard_Munteanu> dankna: well it does for whole functions but not portions AFAIK
13:38:15 <Eduard_Munteanu> like let clauses
13:38:19 <dankna> Eduard_Munteanu: hmm.  well, but the biggest allocator is runMonadicState', which is a newtype accessor.
13:38:26 <dafis> merijn: ah, misread
13:38:34 <dankna> Eduard_Munteanu: so I don't think there's anything to annotate.
13:38:51 <dafis> develhevel: for a naive implementation, isPrefixOf from Data.List is helpful
13:39:18 <Eduard_Munteanu> Hrm, well, the newtype itself shouldn't allocate anything, it doesn't exist at runtime.
13:39:27 <dankna> Eduard_Munteanu: yes.  it is a mystery to me.
13:39:55 <Eduard_Munteanu> dankna: is there any paste around of what that thing looks like?
13:40:13 <dankna> Eduard_Munteanu: probably several, let me check my old pastes
13:40:30 <develhevel> dafis: thx
13:41:00 <dankna> Eduard_Munteanu: http://hpaste.org/47055/some_relevant_definitions has the definition of the accessor; for the definition of the type itself, please continue to hold :)
13:41:26 <chrisdone> Q: How often does the haskell-indent function for Emacs actually get the right position for you first time?
13:41:36 <monochrom> more than 90%
13:42:06 <acowley> chrisdone: it works great for me, but I think I always have to pick a certain mode in my .emacs
13:42:07 <monochrom> 98% within one keystroke; 100% within 2
13:42:12 <dankna> chrisdone: NEVER!  my typical pattern before I switched away from Emacs was to press return, press tab, see that it was the wrong position, try ten or twenty more times, give up and use spacebar and delete.
13:42:26 <dankna> chrisdone: I don't think I have ever seen it get the position I wanted, not once
13:42:44 <acowley> right, I use 'turn-on-haskell-indent
13:42:52 <chrisdone> Interesting.
13:42:57 <sm> chrisdone: using which indentation implementation ?
13:43:00 <chrisdone> dankna: You're using haskell-indent with the tab cycle?
13:43:13 <monochrom> (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
13:43:20 <chrisdone> sm: -indentation or -indent.
13:43:21 <dankna> chrisdone: I'm doing whatever the default is.  I can't easily check right now because I no longer use emacs.
13:43:28 <acowley> the default one didn't work for me at all
13:43:49 <sm> same here
13:43:53 <sm> -indent should be default
13:45:01 <Eduard_Munteanu> dankna: I wonder if your (>>=) might do things the wrong way around and end up allocating lots of thunks
13:45:01 <monochrom> -indent is known to be primitive and even the doc recommends something else
13:45:33 <acowley> but -indent works great, and -indentation not at all (for me)
13:45:48 <dankna> Eduard_Munteanu: that strikes me as very probable.  how could I tell?  what could I do about it?
13:46:31 <chrisdone> It seems people's experiences differ substantially.
13:46:44 <dankna> chrisdone: you don't say :)
13:46:54 <Eduard_Munteanu> Hrm, can you paste it? Or maybe it's not really wrong, just not strict enough.
13:47:02 <dankna> Eduard_Munteanu: by the way http://hpaste.org/47102/the_newtype_definition_itself
13:47:16 <dankna> Eduard_Munteanu: I did already paste the definition of >>=, it's at http://hpaste.org/47100/manually_indented
13:47:30 <dankna> Eduard_Munteanu: there are two versions there, the strictified one that is actually being used and the non-strict one for clarity
13:48:02 <dankna> Eduard_Munteanu: I created the strictified one because I had already suspected that of being the problem, but I'm not convinced it does what I want, or even that it's correct, although it typechecks
13:48:47 <acowley> chrisdone: emacs is home to many mysteries
13:48:59 <acowley> chrisdone: I usually choose not to investigate too far if a solution is at hand
13:49:10 <acowley> I am probably not a good OS user in that sense :/
13:49:18 <Eduard_Munteanu> @src Cont
13:49:18 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
13:49:33 <dankna> @src Monad Cont
13:49:33 <lambdabot> Source not found. It can only be attributed to human error.
13:50:12 <dankna> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Cont.html#Cont
13:50:29 <dankna> the mtl definition of >>= for Cont looks very similar to my definition, heh
13:50:33 <chrisdone> I was hoping there was a consensus so that I could include just one in my hs-mode. I'm writing an extensive set of test cases for what an indentation mode should do for a given set of code, and then will build up from that.
13:51:53 <sm> chrisdone: cool. What's hs-mode ? a haskell-mode alternative ?
13:52:06 <chrisdone> -indentation certainly isn't great. I'm seeing cases where it picks invalid layout.
13:53:47 <dankna> Eduard_Munteanu: I do note that mtl does newtype Cont r a = Cont { runCont :: (a -> r) -> a }
13:53:48 <chrisdone> sm: Yeah, with extra goodness. I'm kind of only half way through, but here is the repo: https://github.com/chrisdone/haskell-emacs Just don't try to use it.
13:53:56 <copumpkin> dankna: o.O
13:54:07 <copumpkin> dankna: that's J
13:54:13 <sm> neat
13:54:18 <dankna> Eduard_Munteanu: whereas I do newtype MonadState a = MonadState { :: runMonadState' :: forall r . (a -> r) -> a }
13:54:23 <dankna> Eduard_Munteanu: could that make a difference?
13:54:30 <dankna> copumpkin: sorry what?  heh
13:54:35 <acowley> chrisdone: what new features are you aiming to include?
13:54:36 <copumpkin> dankna: (a -> r) -> r
13:54:37 <chrisdone> foo = do foobar
13:54:37 <chrisdone>       mubar
13:54:38 <copumpkin> not (a -> r) -> a
13:54:41 <copumpkin> very different type
13:54:45 <chrisdone> ^ -indentation suggested that for a position of 'mubar'.
13:54:53 <dankna> copumpkin: oops yes, that was a typo on my part.
13:55:02 <dankna> or rather a thinko
13:55:06 <copumpkin> :)
13:55:25 <copumpkin> here's a nice paper on the thinko type you had: http://www.cs.bham.ac.uk/~mhe/papers/msfp2010/Escardo-Oliva-MSFP2010.pdf
13:55:31 <dankna> lol
13:55:32 <dankna> I see
13:55:55 <Eduard_Munteanu> dankna: hm, that's about the only difference I see too
13:56:08 <chrisdone> acowley: See the list, but mostly things to do with managing cabal project(s) and having a more aware REPL, completion, docs, generic stuff that decent IDEs have that Haskell in Emacs lacks.
13:56:16 <Eduard_Munteanu> Oh
13:56:22 <copumpkin> chrisdone: you learned italian yet!?
13:56:46 <chrisdone> io non parolo italiano anche se shut up
13:56:51 <jmcarthur> lol
13:56:52 <chrisdone> :D
13:56:55 <copumpkin> nice
13:57:34 * copumpkin tries to figure out what that's supposed to say :)
13:57:36 <mreh> that is italian, i can confirm this
13:57:52 <copumpkin> parolo, shut, and up are not italian words
13:58:28 <Eduard_Munteanu> I'm not sure how the polymorphic r could influence performance there. :/
13:58:41 <jmcarthur> the best way to translate italian to english is by using translationparty.com, of course.
13:58:43 <jmcarthur> Anche The word itself is not silent parolo, IO is
13:58:47 <dankna> Eduard_Munteanu: well, I'm going to make my definition more similar to the mtl one, just to experimentally see what it might be doing
13:58:52 <jmcarthur> the more you know
13:59:30 <monochrom> chrisdone: http://hpaste.org/47103/emacs_haskellmode_demo
13:59:32 <chrisdone> Nah, I do know some but I'm not a performing monkey, copumpkin. :-P *Feigned pride*
14:02:08 <chrisdone> monochrom: Sure, that's quite good for composing a simple tree. Let me try editing it.
14:03:15 <chrisdone> monochrom: Suppose your two `h' lines are now too long to sit there next to the do, so how do you bring both lines to under withFile?
14:04:00 <chrisdone> I tried and the first h went in the right place, but the second took 6 presses to get under the first h.
14:04:08 <develhevel> how to make from ["w","o","w"] "wow"? tryd filter (++) []
14:04:17 <monochrom> please tell me exact keystrokes
14:04:22 <ddarius> You always enter a newline after do.
14:04:43 <monochrom> assume my cursor is right at the end of "withFile "blah" $ \h -> do"
14:04:55 <monochrom> (should I hit <ret> now?)
14:05:20 <chrisdone> monochrom: Ah, I think in this case you're not supposed to use tab but use delete.
14:05:21 <Twey> develhevel: join
14:05:29 <chrisdone> monadic: Yeah, at do|, hit <return>.
14:05:32 <Twey> > join ["w", "o", "w"]
14:05:33 <lambdabot>   "wow"
14:05:36 <chrisdone> monochrom: Er, you.
14:05:51 * Twey propagates the no-concat movement.
14:05:52 <develhevel> :) thx
14:05:53 <chrisdone> monochrom: And then, what do you press to bring the other h in line?
14:06:13 <roconnor> @hoogle EXIT_SUCCESS
14:06:13 <lambdabot> No results found
14:06:22 <Twey> ExitSuccess
14:06:23 <ddarius> @hoogle exitSuccess
14:06:24 <lambdabot> System.Exit exitSuccess :: IO a
14:06:24 <lambdabot> System.Exit ExitSuccess :: ExitCode
14:06:25 <Twey> System.Exit
14:06:33 <roconnor> @hoogle ExitCode -> IO a
14:06:34 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
14:06:34 <lambdabot> Control.Exception evaluate :: a -> IO a
14:06:34 <lambdabot> Control.OldException evaluate :: a -> IO a
14:06:44 <monochrom> I suppose the "main = do<ret>" example and the "withSockets $ do<ret>" example answer your question?
14:06:48 <edwardk> > ["w","o","w"] >>= id
14:06:49 <lambdabot>   "wow"
14:07:48 <chrisdone> monochrom: No, because that's composing, this case is editing/re-indenting existing code.
14:07:59 <dafis> > foldl1 (++) ["w","o","w"]
14:08:00 <c_wraith> It's fun manually unifying the types in (>>= id)
14:08:01 <lambdabot>   "wow"
14:08:24 <ddarius> c_wraith has a strange sense of "fun."
14:08:44 <edwardk> the danger of the (++) version is its asymptotics
14:09:04 <ddarius> edwardk: That it is asymptotically ideal?
14:09:08 <ion> > foldl1 (flip (++)) ["w","o","w"]
14:09:08 <edwardk> .... says the man with the strangest sense of "fun" in the whole channel
14:09:09 <lambdabot>   "wow"
14:09:10 <monochrom> http://hpaste.org/paste/47103/emacs_haskellmode_demo_more#p47105
14:09:27 <c_wraith> The foldr version is fine, asymptotically.  The foldl version is not.
14:09:45 <ddarius> There's no reason you'd foldl (++).
14:09:57 <shachaf> ddarius: For any monoid?
14:10:24 <monochrom> paste #p47105 is still composing. I'll tell you what happens to editing now
14:10:38 <monochrom> at the first h, I hit <ret>
14:11:01 <roconnor> @type forever
14:11:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:11:13 <monochrom> actually <bksp><ret> to get rid of the space after "do"
14:11:18 <copumpkin> chrisdone!
14:11:41 <monochrom> at the second h, <bksp><bksp>
14:11:55 <monochrom> (alternatively, under first h, <del><del>)
14:12:27 <monochrom> (i.e., one line under first h, <del><del>)
14:14:38 <Twey> Grr, why does Haddock still not support UTF-8 input ☹
14:14:48 <dankna> Eduard_Munteanu, dafis: http://hpaste.org/47107/cant_do_this
14:15:08 <dankna> this is a problem I'm running into in trying to make my definition not use a forall.
14:15:17 <chrisdone> monochrom: Ah, okay. So I go to the starting column of the line and then hit backspace to go back.
14:16:18 <dankna> I understand the error message but am not sure how I can organize things to not have that issue
14:16:21 <edwardk> preflex: xseen cale
14:16:21 <preflex>  cale was last seen on freenode/#haskell 2 hours, 30 minutes and 48 seconds ago, saying: sure
14:16:24 <sw17ch> hey all
14:16:27 <chrisdone> monochrom: http://chrisdone.com/crap/out.ogv — It seems just relying on the tab cycle leads to an infuriating editing experience.
14:17:10 <monochrom> tab-cycle is passe
14:17:28 <dafis> dankna: newtype MonadicState a = MS (MonadicState' (a,State) a) would allow the instance declaration
14:17:46 <dankna> dafis: ah, hm, yes.  okay!
14:17:59 <Cale> Hi edwardk
14:18:05 <monochrom> although I still do it sometimes out of old habit
14:18:30 <Eduard_Munteanu> In fact you can probably use Cont wrapped in a newtype and derive Monad.
14:18:51 <edwardk> was trying to figure out how far away you are from McMaster University ;)
14:18:52 <Eduard_Munteanu> No?
14:18:54 <dankna> Eduard_Munteanu: I can't, because that would require all my fields to be in a single parameter
14:19:03 <chrisdone> monochrom: I'm thinking <tab> vs <backtab> might be nice. Would you use that? The bad thing about <backspace> is having to be at the start of the line.
14:19:10 <dankna> Eduard_Munteanu: which would incur some construction overhead on whatever aggregate type I use for that parameter, be it a record or a tuple
14:19:10 <edwardk> Not that Canada is a small place or anything, but I figured I should check ;)
14:19:16 <Eduard_Munteanu> Oh, right.
14:19:34 <Cale> edwardk: ummm... not too far.
14:19:37 <sshc> edwardk: Why does "pointed" depend on all those packages?
14:19:38 <sshc> edwardk: stm,
14:19:42 <dafis> Cont (field0 -> ... -> r) a
14:19:47 <sshc> transformers, etc.
14:20:11 <Eduard_Munteanu> Hm, that's worth a shot.
14:20:12 <monochrom> I am old. I may or may not be able to learn to use <backtab>. but if <backtab> does not require repositioning cursor first, w00t!
14:20:20 <edwardk> sshc: because it is a later layer in the onion. if you want pointed instances for them, they'd have to either migrate into those packages (which will never happen) or live in pointed or be orphans
14:20:22 <Cale> http://goo.gl/maps/cisW
14:20:26 <edwardk> i despise orphans
14:20:43 <danharaj> @src take
14:20:43 <lambdabot> take n _      | n <= 0 =  []
14:20:43 <lambdabot> take _ []              =  []
14:20:43 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
14:20:48 <edwardk> and pointed is the whipping child of my package set, because i wasn't going to include it at all ;)
14:20:50 <dankna> dafis: hmmm!  that is indeed worth a shot.  I'll try that right after I finish this other version that I'm trying.
14:20:54 <monochrom> normally <M-m><bksp> is not so bad
14:21:13 <sshc> edwardk: Ah.
14:21:39 <aib> What splits string by whitespace (or just space) ? :: String -> [String]
14:21:45 <danharaj> :t words
14:21:45 <lambdabot> String -> [String]
14:21:49 <aib> words, thanks
14:21:58 <danharaj> :t unwords
14:21:58 <lambdabot> [String] -> String
14:22:03 <Eduard_Munteanu> @hoogle splitBy
14:22:03 <lambdabot> No results found
14:22:11 <Eduard_Munteanu> @hoogle Split
14:22:12 <lambdabot> Data.Graph.Inductive.Internal.Thread type Split t i r = i -> t -> (r, t)
14:22:12 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
14:22:12 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
14:22:17 <Eduard_Munteanu> Meh.
14:22:23 <danharaj> @hoogle splitAt
14:22:23 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
14:22:23 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
14:22:23 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
14:22:23 <dafis> @hoogle splitOn
14:22:23 <lambdabot> No results found
14:22:26 <danharaj> boom.
14:22:32 <danharaj> My preposition is the best.
14:22:44 <chrisdone> monochrom: Yeah, I guess. I'm surprised nobody's implemented before the notion that re-indenting `case' should re-indent all the lines that are children of it.
14:22:46 <Eduard_Munteanu> There's a split package in case you need to split on something else.
14:23:02 <Eduard_Munteanu> It's preposterous :P
14:23:17 <chrisdone> monochrom: (Likewise for M-^ and M-j, child lines should be brought up or brought back.)
14:23:32 <aib> I think I need a whole tutorial on Haskell indentation, the use and misuse of
14:23:55 <Eduard_Munteanu> By the way, how in the world you 'undo' in Emacs without getting carpal tunnel and messing stuff up?
14:24:14 <Eduard_Munteanu> I mean, multiple undos.
14:24:21 <monochrom> C-M-_
14:24:23 <edwardk> sshc: pointed probably shouldn't exist at all, since it offers no useful rules. one of the side-goals of my refactoring of category-extras was to switch to talking about the semigroupoid-like structures of Apply, Bind, etc. instead.
14:24:31 <dankna> you don't - you get carpal tunnel and mess stuff up, or you don't undo
14:24:36 <danharaj> @hoogle a -> [a]
14:24:36 <lambdabot> Prelude repeat :: a -> [a]
14:24:37 <lambdabot> Data.List repeat :: a -> [a]
14:24:37 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
14:24:38 <dankna> Emacs loves its key chords
14:24:38 <rudyl313> I have a basic program where I get user input and then call a pure function on the string... how do I make those two event loop .. so the user can keep inputing new strings to be evaluated?
14:24:47 <mrd> Just C-_
14:25:00 <monochrom> sorry, C-_
14:25:08 <dankna> someone in here argued to me the other week that C-M-_ is logically a single key.  yes, okay, but it takes two hands and three fingers to type!
14:25:09 <Eduard_Munteanu> Ah, that's better, I remember the menus showed a really annoying combo
14:25:27 <dankna> er four fingers, because _ is shifted
14:25:38 <Cale> edwardk: Anyway, google maps says about half an hour, which seems about right
14:25:47 <mrd> yea it's C-shift-_
14:25:48 <ion> :t interact --rudyl313
14:25:49 <lambdabot> (String -> String) -> IO ()
14:26:01 <dafis> dankna: you know what emacs stands for, don't you?
14:26:01 <mrd> not so bad if you have your keyboard correctly configured
14:26:15 <Eduard_Munteanu> @src interact
14:26:15 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:26:17 <edwardk> cale: I'll be up at McMaster from the 10th to the 15th. It be neat to get a chance to meet in person.
14:26:19 <dankna> eight megs and constantly swapping?
14:26:33 <kmc> el oh el
14:26:34 <dankna> (you can tell how old that is from the fact that eight megs was a lot of memory)
14:26:35 <edwardk> er It'd
14:26:36 <dafis> escape-meta-alt-control-shift
14:26:39 <dankna> hahaha, nice
14:26:55 <mrd> yea, emacs is still eight megs, while eclipse is 800 ;)
14:27:00 <mrd> funny how that works
14:27:02 <Cale> Yeah, that might be cool. We can probably work something out. :)
14:27:06 <dankna> it's actually "editor macros" because the original original EMACS (predating the GNU version) was a set of TECO macros
14:27:11 <kmc> Emack and Bolio's
14:27:13 <danharaj> My harddrive is 1 TB and cost me less than my monthly train pass.
14:27:16 <Eduard_Munteanu> Is that some sort of "I like my ... how I like my editor"? :P
14:27:21 <edwardk> cale: Wren Ng Thornton will also be there
14:27:31 <sshc> edwardk: If the functor/monad hierarchy were ever rewritten, Pointed might be useful (Functor ⊆ Pointed ⊆ Applicative ⊆ Monad)
14:27:46 <danharaj> Type classes are such a pain.
14:27:59 <danharaj> They need to make it so that you can hide and import instances explicitly.
14:28:08 <danharaj> "They" being the community consensus :p
14:28:11 <edwardk> sshc: Functor ⊆ Apply ⊆ Applicative ⊆ Monad and Functor ⊆ Apply ⊆ Bind ⊆ Monad is more useful though.
14:28:14 <chrisdone> monochrom: I've got the children thing working on my simple indentation module. It's really something I can't do without now I have it: http://www.youtube.com/watch?v=GK7rU_Q_uJM#t=0m50s The nice thing is it's easy to implement: you just take stock of the child lines, run the tab function, work out how many columns it changed, then change the sub lines'.
14:28:28 <edwardk> sshc: and adding Pointed to that means you wind up with classes that are _just_ laws.
14:28:32 <chrisdone> (I mean easy as in, works for any indentation mode.)
14:28:52 <Cale> Ah, that's koninkje
14:29:31 <dankna> Eduard_Munteanu, dafis: okay - I need to run out to buy and install a network switch now, I'll be back in about an hour.
14:29:33 <edwardk> yeah
14:29:45 <kmc> danharaj, what if I build a Data.Map using an Ord instance i imported from module A, and you hide that instance and import a different one, and use my Data.Map?
14:30:01 <kmc> we have this problem now with "orphan instances" but there's a clear way to avoid those
14:32:26 <chrisdone> copumpkin: !
14:32:28 <danharaj> kmc: Do you mean I'll have my own Ord instance in scope, but your map will be using a different one, or that I can change the Ord instance you used outside of your module?
14:32:52 * edwardk just made the connection that winterkoninkje is wren in dutch.
14:33:05 <kmc> or let's make it more symmetric: we each create a map, using different Ord instances, and then try to union them
14:33:21 <danharaj> kmc: aha. Yes quite. Those Maps should have different types.
14:33:34 <kmc> De winterkoning of vaak winterkoninkje (Troglodytes troglodytes) is de enige Europese winterkoningsoort. Het is een klein gedrongen vogeltje van ongeveer tien centimeter met een opgewipt staartje.
14:33:36 <MarcWeber> Is there any json library which provides real parsing hints such as foo.bar.x should be an obj?
14:33:57 <chrisdone> I'm pretty sure Text.JSON at least says "x should be an object".
14:34:01 * chrisdone checks
14:34:22 <MarcWeber> chrisdone: It does..
14:34:23 <MarcWeber> [{"Nothing":null},{"cmd":"abc"}]
14:34:24 <MarcWeber> setting scion_result_str to {"Left":"JSON decoding error: malformed JSON for type ...: ..."}
14:34:29 <MarcWeber> However I don't find this helpful :(
14:34:29 <kmc> danharaj, that's close to dependent types though
14:34:48 <kmc> an instance is essentially a value
14:34:48 <edwardk> danharaj: confluence is easily lost the moment you allow folks to hide instances. it is one of the key things that makes typeclasses better in many ways than, say, implicits in scala.
14:34:52 <chrisdone> λ> decode "1" :: Result (JSObject String)
14:34:52 <chrisdone> Error "Unable to read JSObject"
14:34:54 <chrisdone> Yeah, that's not so helpful.
14:35:07 <kmc> maybe it's workable if you only have selective imports, and not full local scoping of instance
14:35:09 <edwardk> danharaj: you can give them different types... by using a newtype! =)
14:35:30 <MarcWeber> chrisdone: I can add my own functions. But heck - its very common that JSON decode errors  happen. The more debugging hints the faster you're done.
14:35:45 <edwardk> newtypes are how we pick instances for types that have the same representation behind the scenes.
14:35:52 <edwardk> the plumbing is unfortunate but necessary
14:35:53 <danharaj> edwardk: But then if I'm using n instances that are the same, and just have 1 instance that I want to change, doesn't that mean I have to write n +1 instances for the newtype?
14:36:11 <edwardk> or you use generalized newtype deriving to inherit all the other crap
14:36:54 <sw17ch> +1 to GeneralizedNewtypeDeriving
14:37:27 <chrisdone> MarcWeber: Yeah, all my JSON work, the JSON serialization is automatic, not user-facing. But I'd still like that. Let me know if you find one that does (or write your own). (at chrisdone@gmail.com)
14:37:35 <chrisdone> (If you don't mind.)
14:40:37 <chrisdone> … Was it something I said?
14:41:02 <MarcWeber> chrisdone: I don't think it pays off for my use case (I'd like to readd vim support to current scion branch)..
14:41:25 <Guest34588> kmc: you are Dutch, aren't you?
14:41:30 <MarcWeber> I'm faster adding a small function.. Its a forest of json libs on hackage. Its hard to find out which library to use..
14:42:22 <copumpkin> Guest34588: he is Dutch wikipedia
14:42:40 <danharaj> edwardk: For your `Extend' class, is `extend' a minimal definition?
14:44:06 <chrisdone> MarcWeber: Yeah. There are a few. None of them look like they have friendly parse error messages.
14:44:29 <chrisdone> (Aeson is as terse as Text.JSON: http://hackage.haskell.org/packages/archive/aeson/0.3.2.6/doc/html/src/Data-Aeson-Parser.html)
14:47:43 <chrisdone> copumpkin: A job hunter who just emailed me said this of Italy: "Great coffee, wonderful food...very jealous!! But yes we do have pasties, chips and gravy, baked beans and a good brew!!"
14:47:54 <copumpkin> :o
14:48:09 * chrisdone misses pasties and chippy
14:48:21 <copumpkin> good ol healthy food
14:48:24 <monochrom> what about sausages?
14:48:25 <chrisdone> :D
14:48:35 <kmc> who wants a banger in the mouth?!?!
14:48:49 <chrisdone> Cumberland sausage, mm.
14:48:49 <monochrom> every respectable european culture must feature sausages!
14:49:08 <monochrom> and even china has its version of sausages!
14:49:09 <copumpkin> the sausages are very different though
14:49:21 <copumpkin> italian sausages are a lot meatier than english ones, for example
14:49:28 * copumpkin winks
14:49:47 <monochrom> yes, different cultures have different sausages, that's fine, the important thing is each must feature sausages
14:51:11 <monochrom> you should also write back to ask "where are all the Italian haskellers?"
14:51:24 <sw17ch> i've walked into a channel and it's about sausages. unless we're using sausage links as an analogy for linked lists, i'm confused. :P
14:51:37 <rostayob> monochrom: I'm here
14:51:41 <monochrom> applicatives are like sausages
14:51:48 <chrisdone> copton: Yeah, there's quite the selection of salamis here, eh?
14:51:56 <rostayob> just to say, I have no idea what you're talking about ehe
14:52:03 <chrisdone> copumpkin: Sorry, I gotta stop using xchat, tab-completion fail.
14:52:18 <copumpkin> chrisdone: it's wonderful
14:52:27 <copumpkin> they're all different and all delicious
14:52:27 <monochrom> xchat tab-completion works fine. choose the "recently spoken" order
14:52:32 <copumpkin> same with prosciutto
14:52:50 <kmc> http://www.popsci.com/bacon
14:52:52 <rostayob> prosciutto > salame
14:52:58 <kmc> thermic lance made of prosciutto
14:53:04 <kmc> which is described as "an engineering grade of bacon"
14:53:05 <monochrom> settings -> preferences -> input box -> nick completion sorted: last-spoke order
14:53:09 <chrisdone> copumpkin: And cheeses! I'm into asiago pressatto (give or take s or t) and mezzano at the moment. I tried gorgonzola and nearly died of hatred for having being born with taste buds. :D
14:53:19 <copumpkin> rostayob: they both have their pros (no cons)
14:53:24 <copumpkin> chrisdone: even breads
14:53:31 <copumpkin> gorgonzola is wonderful
14:53:52 <copumpkin> anyway, this talk of wonderful italian food should probably move to #haskell-blah
14:53:53 <copumpkin> :)
14:54:00 <sw17ch> fmap gorgonzola prosciutto
14:54:01 <chrisdone> :-)
14:54:03 <rostayob> copumpkin: salame is just bits stuffed together. prosciutto is delicious aged pork.
14:54:10 <copumpkin> rostayob: it's so much more
14:54:13 <copumpkin> mmm
14:54:18 <aristid> sw17ch: gorgonzola is a function?
14:54:21 <rostayob> with no offence to salame
14:54:25 <chrisdone> monochrom: Thanks, that works a treat. :-)
14:54:37 <copumpkin> kmc: I'd seen that
14:54:43 <copumpkin> I'm still annoyed that they call it bacon though
14:54:45 <copumpkin> :P
14:54:47 <rostayob> prociutto > bresaola > salame > mortadella > coppa
14:54:54 <monochrom> "salame is just bits stuffed together" list monad. "prosciutto is delicious aged pork" write monad
14:54:59 <sam2> Hi
14:55:04 <copumpkin> not a huge fan of bresaola
14:55:04 <sam2> Hi
14:55:18 <sam2> Can I ask a question about Haskell?
14:55:25 <Saizan> yes!
14:55:26 <rtharper> yes
14:55:28 <chrisdone> Heh, monochrom desperately trying to make Haskell analogies so that we can get away with talking about food in #haskell. :-P
14:55:29 <kmc> No, this room is currently bacon-only
14:55:30 <copumpkin> sam2: as long as you reference italian food too
14:55:32 <kmc> ;)
14:55:41 <rostayob> eheh
14:55:42 * copumpkin strangles kmc
14:55:44 <shachaf> sam2: Questions about Haskell are allowed. Questions about asking questions about Haskell are generally discouraged.
14:56:10 <chrisdone> @faq Can Haskell be the subject of questions?
14:56:10 <lambdabot> The answer is: Yes! Haskell can do that.
14:56:12 <sam2> I'm new to haskell and getting some errors on using "where" keyword
14:56:17 <aristid> shachaf: and questions about questions asbout asking questions about haskell?
14:56:24 <sam2> greet :: String -> String
14:56:29 <sam2> oops
14:56:35 <aristid> http://hpaste.org
14:56:43 <rostayob> copumpkin: anyway, enjoy Italy, I'm in Rome for a while as well. back to haskell
14:56:54 <chrisdone> Well, I have a movie called 'The Doors' that I intend to watch. See you chaps later.
14:56:55 <monochrom> http://www.vex.net/~trebla/humour/lazy-question-stream.html
14:56:55 <copumpkin> rostayob: I'm from rome!
14:56:59 <chrisdone> rostayob: Oh, how long are you Italy for?
14:56:59 <shachaf> aristid: Was that a question?
14:57:01 <copumpkin> rostayob: chrisdone is the one visiting :P
14:57:13 <chrisdone> Visiting for a year now. :-)
14:57:28 <monochrom> I have to work very hard to get error messages
14:57:38 <sam2> http://hpaste.org/47108/code
14:57:44 <copumpkin> :t find
14:57:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:57:46 <rostayob> copumpkin: oh, whereabout?
14:57:56 <aristid> shachaf: yes.
14:58:03 <copumpkin> rostayob: well, I grew up near trigoria
14:58:09 <copumpkin> I don't live there anymore
14:58:19 <monochrom> sorry, "where" is not shared by all 3 equations
14:58:24 <aristid> shachaf: it was also an instance of its own subject :)
14:58:39 <rostayob> copumpkin: ahah they train there, cool. I lived in montesacro most of my life. anyway, maybe we're getting to off topic ehe
14:58:50 <copumpkin> rostayob: yep :P cool though
14:58:50 <blackh> sam2, unfortunately 'where' is scoped only inside that particular definition.  You'll have to use a 'case'.
14:59:22 <rostayob> chrisdone: I'm here until the 4th of June. Wait a second are you coming because you found a haskell job?
14:59:33 <aib> How can I run a String -> String on stdin and stdout until EOF? I remember "interact" but it only runs for a single line.
14:59:40 <sam2> hm
14:59:41 <sam2> I se
14:59:43 <sam2> see
14:59:45 <sam2> hold on please
14:59:47 <chrisdone> rostayob: Yeah, I work in Trento. Haskell jawb.
14:59:49 <monochrom> interact runs until EOF
15:00:04 <aib> oh, then I'm doing something wrong
15:00:08 <monochrom> "main = interact reverse"
15:00:14 <rostayob> chrisdone: nooooo way! where?
15:00:21 <kmc> jerb
15:01:08 <chrisdone> rostayob: The research centre is called ‘CREATE-NET’. Academics love their acronyms, you know. It's in with FBK and the tech universities.
15:01:43 <monochrom> and managers love their camel-case names
15:02:54 <chrisdone> rostayob: If you're interested in application development in Haskell we have jobs going. But yeah, you have to move to Italy. We get applications, but they don't want to move. Can't do anything about it, I'm afraid.
15:03:04 <sam2> hm
15:03:22 <sam2> Okay I got it
15:03:24 <sam2> thanx for the help!
15:03:42 <rostayob> chrisdone: I'll talk to you im private :P
15:12:02 <aib> is there a way to /show/ a Double to some decimal places? e.g. show (rounded 2 3.16) -> "3.2"
15:12:14 <aib> s/Double/Fractional
15:12:42 <blackh> aib: import Numeric, and use the showFFloat function.
15:12:50 <dafis_> > showFFloat (Just 1) 3.16 ""
15:12:51 <lambdabot>   "3.2"
15:13:44 <acowley> or use Text.Printf.printf
15:13:47 <applicative> aib printf
15:13:52 <dafis_> aib: showFFloat &c require a RealFloat instance, however
15:15:53 <aib> aha! thanks a bunch.
15:19:50 <dylukes> Hm.
15:20:01 <dylukes> So, I've got *expression* parsing and evaluation down pat.
15:20:21 <dylukes> But, I'm not sure how to go about dealing with other things such as function definitions as statements
15:20:53 <dylukes> (I got a simple lang working that did macroing, as in "let x -> x + x in ..."
15:20:55 <dylukes> )
15:21:46 <aristid> dylukes: why is the arrow in left-to-right direction?
15:21:53 <aristid> looks weird
15:21:58 <dylukes> dunno, thats just how I made it :\
15:22:02 <dylukes> it's not haskell monad.
15:22:15 <dylukes> I guess it should be the other way… given the usual syntax in docs...
15:22:17 <dylukes> why is that btw
15:22:19 <dylukes> why is it written
15:22:21 <dylukes> E <- E + E
15:22:29 <dylukes> :\
15:23:24 <monochrom> it is "E -> E+E" because you expand that way
15:23:35 <monochrom> it is "E <- E+E" because you abbreviate that way
15:24:01 <erus`> let x -> x + x in x
15:24:41 <dylukes> monochrom: heh?
15:24:46 <erus`> > let double x = [0,2..] in double 1000000
15:24:46 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
15:25:02 <erus`> > let double x = [0,2..] !! x in double 1000000
15:25:03 <lambdabot>   2000000
15:25:24 <monochrom> "E <- blah blah" = "I store blah blah into macro name E"
15:26:20 <monochrom> this is why I disbelieve in "intuition" "natural". there are conflicting intuitions and conflicting natural's.
15:26:52 <monochrom> if you allow yourself enough time, you can explain away every contraption
15:27:09 <dylukes> heh
15:27:26 <dylukes> Well, I definitely feel comfortable implementing any simple little expression evaluator.
15:27:36 <dylukes> I guess the next step up is handling "more" than that.
15:27:51 <dylukes> Not sure how to handle things like top-level statements atm.
15:29:03 <monochrom> first you need the grammar of an individual statement. then you chainl it
15:29:17 <monochrom> or maybe sepBy
15:29:57 <dylukes> so, a statement could be either...
15:30:09 <dylukes> a prototype, a function definition, ...
15:30:13 <dylukes> or a top-level expression
15:30:14 <aristid> sepBy can be dangerous, if the separator can occur after the last element :)
15:30:21 <dylukes> not sure how to handle top-level expressions elegantly.
15:30:33 <dylukes> I guess you could collect each one into an anonymous function
15:30:35 <monochrom> oh, there are endBy, sepEndBy too...
15:31:02 <dylukes> How would you suggest handling top-level naked expressions?
15:31:24 <dylukes> If this is a C-style language, they'd be an error...
15:31:47 <dylukes> but in something more Pythonesque (line by line interpretation), I guess you'd evaluate them then and there
15:31:56 <dylukes> I think the former is a bit easier
15:31:59 <monochrom> I would first ask how much lookahead is needed to tell "this is a naked expression, as opposed to the other two cases"
15:32:16 <dylukes> If you have keywords for other statements,
15:32:22 <dylukes> then it should be pretty obvious if its a naked expression
15:32:30 <monochrom> generally I would design or re-design the whole grammar to minimize lookahead
15:32:55 <dylukes> Say you have proto and func keywords
15:32:59 <dylukes> then lookahead isn't necessary
15:33:06 <dylukes> anyways, I'm going to go eat then come back :)
15:33:08 <dylukes> thanks
15:33:18 <monochrom> well then you can do it naïvely. statament = prototype <|> definition <|> expression; prototype = string "prototype" >> ...
15:33:37 <lysgaard> How do I export both the datatype and the contstructor of the same name from a module?
15:33:40 <monochrom> actually make it prototype = try (string "prototype") >> ...
15:33:41 <aristid> monochrom: sepEndBy? awesome, i did not know of that! thanks
15:34:00 <monochrom> yes it pays to read the doc from cover to cover
15:35:16 <aristid> monochrom: i bet i read that before and forgot it 5 minutes later.
15:35:36 <dafis> lysgaard: module Foo ( Bar(..)) where
15:37:11 <lysgaard> dafis: So it would be Bar(Bar, BarTwo) ?
15:38:04 <dafis> lysgaard: if you want to only export some of the constructors, yes, if you want to export all, Bar(..) is a useful shorthand
15:38:15 <lysgaard> dafis: Ah, thanks! =)
15:41:38 <anon__> hello
15:42:11 <dafis> > reverse "olleh"
15:42:12 <lambdabot>   "hello"
15:42:28 <anon__> ?
15:42:47 <dylukes> Alright so...
15:42:50 <dafis> you said hello
15:42:58 <dylukes> I guess what's daunting,
15:43:21 <dylukes> is that I'd like to make, next year, a language in which expressions and statements are first-class
15:43:31 <dylukes> and can be captured and evaluated later.
15:43:46 <dylukes> The thing is, that entails having a self-hosted interpreter .__.
15:43:51 <dylukes> Not sure where to go with that
15:44:19 <dylukes> unless I have some language-agnostic internal representation of the AST ...
15:44:35 <dylukes> I could use something like that as a bootstrapping phase
15:44:54 <dylukes> nonetheless, not sure how to even make a self-hosted interpreted language at all.
15:46:28 <kmc> "a language in which expressions and statements are first-class"
15:46:31 <kmc> like LISP?
15:46:38 * hackagebot X11-xfixes 0.1.1 - A binding to the Xfixes X11 extension library  http://hackage.haskell.org/package/X11-xfixes-0.1.1 (ArenOlson)
15:47:03 <kmc> why does that imply having a self-hosted interpreter?
15:47:22 <kmc> all it means is that the interpreter needs to expose its own "evaluate" function as a language primitive
15:47:27 <dylukes> kmc: !
15:47:33 <dylukes> Ah, didn't think of what :O
15:47:35 <dylukes> that*
15:47:45 <kmc> which is a very common thing -- standard interpreters for Perl, Python, Lisp, all do this
15:47:51 <dylukes> Anyways, basically what I'm thinking is *somewhat* Lisp like.
15:47:55 <dylukes> But with more rubyesque syntax.
15:48:06 <kmc> you can eval a string from Haskell with "hint" or directly using the GHC API
15:48:21 <kmc> how much do you know about Lisp?
15:48:42 <dylukes> I can make basic programs in Scheme (gone through 1/3rd of SICP so far)
15:48:46 <dylukes> and a bit more in CL.
15:48:58 <kmc> cool
15:49:02 <dylukes> I've had a good amount of exposure, not enough to be fluent in it.
15:49:08 <dylukes> or, proficient even
15:49:09 <kmc> maybe you should just invent an alternate syntax for S-expressions
15:49:13 <kmc> or use an existing alternate syntax
15:49:32 <kmc> that way you don't need to re-specify all the complicated semantics stuff
15:50:02 <dylukes> kmc: Maybe I could actually write a language that uses M-exps?
15:50:03 <dylukes> :P
15:50:06 <kmc> right :)
15:50:14 <kmc> just don't re-invent Lisp poorly
15:50:17 <kmc> because that's been done far too many times
15:50:29 <dylukes> This is a high school senior project >_>
15:50:32 <dylukes> The only obnoxious thing,
15:50:39 <dylukes> is the teacher insists it has some sort of "wow-factor" >_>
15:50:54 <dylukes> I tried pointing out "Implementing a turing-complete, general-purpose language, while in high school"
15:50:59 <dylukes> but, apparently that's not good enough.
15:51:03 <kmc> that means, designing and implementing a programming language isn't cool, unless it has 3D graphics or talks to Twitter?
15:51:27 <dylukes> What I ended up satisfying him with,
15:51:34 <kmc> write a tracing JIT compiler for your language and show performance comparable to C
15:51:35 <dylukes> is saying I'll write some basic self-modifying AI in it...
15:51:37 <kmc> that should impress them ;)
15:51:44 <dylukes> Yeah, tried that already.
15:51:49 <dylukes> >_>
15:54:40 <dylukes> Dear god
15:54:44 <dylukes> documentation on M-exprs is terrible
15:54:51 <dylukes> I can't find a single definitive grammar definition
15:55:11 <shachaf> dylukes: That's OK, just make up your own like everybody else.
15:55:17 <dylukes> :P
15:55:54 <int80_h> http://hpaste.org/47111/help_me_suss_out_this_type_sig
15:56:37 <dylukes> histogram :: (Atom.C x) => (Graph2DType.T Int Int (x, String))
15:56:41 <dylukes> does that make more sense >_>?
15:57:25 <mauke> int80_h: what's the difference between those two signatures?
15:57:29 <dylukes> Graph2DType.T is probably partially applied here.
15:57:57 <dylukes> er, not G2DT.T
15:58:03 <dylukes> btu part of histogram itself
15:58:08 <dylukes> dunno >_<
15:58:14 <dylukes> I'm going to go back to syntax.
15:58:31 <dylukes> ALGOL-style syntax is easier >_>
15:59:18 <int80_h> mauke: the one I recognize is a type signature for a function. The one I'm struggling with is unfamiliar to me.
15:59:28 <byorgey> int80_h: the sig for histogram is of the form histogram :: (Constraints) => x
15:59:34 <byorgey> it is not a function.
15:59:42 <mauke> int80_h: sorry, I just don't see the problem
15:59:46 <byorgey> it is a "polymorphic constant"
16:00:07 <byorgey> int80_h: for example, consider the type of 3
16:00:09 <byorgey> @type 3
16:00:09 <int80_h> mauke: if it's not a function, what does it do?
16:00:09 <lambdabot> forall t. (Num t) => t
16:00:21 <mauke> int80_h: what do numbers "do"?
16:00:28 <byorgey> int80_h: it doesn't "do" anything, it just *is*
16:00:48 <mauke> it looks like it's a histogram of some sort
16:00:50 <dafis> on hai on
16:00:50 <dylukes> The things to the left of => of the form Type x
16:00:51 <dylukes> say
16:01:05 <int80_h> okay so it's a description then?
16:01:06 <dylukes> 'x' must be of a type in the type-class TypeC
16:01:24 <dylukes> add :: (Num a) => a -> a -> a
16:01:24 <mauke> int80_h: what does foo :: Either Int String do?
16:01:37 <dylukes> means add will work for any type 'a' which is an instance of Num
16:02:48 <int80_h> mauke: I would interpret that as a function that doesn't take passed in input (read from a file maybe?) and then either returns an Int or a String.
16:03:14 <dylukes> int80_h: If it read from a file it'd be IO (Either Int String)
16:03:16 <mauke> int80_h: it's not a function
16:03:18 <dylukes> or, its cheating and using unsafePerformIO
16:03:23 <dylukes> It's a top-level definition
16:03:28 <dylukes> (or zero-ary function)
16:03:41 <mauke> int80_h: you don't seem to be used to the idea that there are non-function values
16:03:41 <int80_h> mauke: I don't know what it is then
16:03:45 <mauke> this confuses me
16:03:46 <aristid> there are no zero-ary functions.
16:03:58 <c_wraith> int80_h: it's a polymorphic value
16:04:06 <mauke> c_wraith: mine was monomorphic
16:04:08 <int80_h> mauke: oh is this a value that can either be an Int or a String?
16:04:22 <mauke> int80_h: yeah, basically
16:04:42 <dylukes> mauke: Except it can't just be used as either of them...
16:04:50 <dylukes> mauke: It's a unique type, different from String or Int
16:05:05 <int80_h> mauke: so in my example, histogram takes 4 values
16:05:12 <mauke> int80_h: no
16:05:29 <mauke> it's not a function, so it takes no values
16:05:47 <mauke> unless T is a synonym for (->)
16:06:03 <int80_h> mauke: let me look something up in the gnuplot docs. brb
16:07:50 <rothwell> what's the preferred way to get a fixed-sized 3D unboxed array these days?
16:08:12 <rothwell> ... -d
16:08:43 <applicative> wow, the gnuplot material is by henning thielemann
16:08:58 <int80_h> mauke: Graph2DType is private so I need to dig through the source, it will be a minute
16:09:35 <applicative> newtype T x y a = Cons String
16:09:44 <applicative> is the signature
16:09:54 <applicative> sorry, the type definition.
16:10:11 <applicative> so histogram :: (Atom.C x) => Graph2DType.T Int Int (x,String)
16:10:21 <applicative> means that a histogram is a string.
16:10:30 <dylukes> monochrom: Any thoughts on what type of syntax I'd want to adopt?
16:10:37 <edwardk> danharaj: yes
16:11:06 <int80_h> mauke: okay what I have so far is newtype T x y a = Cons String
16:11:10 <jmcarthur> rothwell: what do you mean fixed-size? you mean static dimensions?
16:11:19 <rothwell> jmcarthur: yeah
16:11:33 <edwardk> danharaj: and if you define extend and extract you can use liftW as a default definition for fmap. (but if you use duplicate you're on your own defining fmap)
16:11:35 <jmcarthur> well you could wrap repa or something maybe
16:12:25 * rothwell eyes it
16:13:44 <int80_h> mauke: Is Cons a keyword in Haskell?
16:14:15 <mauke> int80_h: no...
16:14:16 <augur> how can i make these fun operator data constructors
16:14:19 <byorgey> int80_h: no, Cons is the constructor for the newtype
16:14:24 <mauke> int80_h: have you considered reading a basic haskell tutorial?
16:14:27 <augur> i try to use stuff like <+> but it fails :|
16:14:43 <aristid> @hoogle <+>
16:14:43 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
16:14:43 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
16:14:43 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
16:14:48 <byorgey> augur: data construtors must start with an uppercase letter or a :
16:14:53 <aristid> augur: arrow stuff.
16:15:00 <applicative> rothwell, have you seen the repa tutorial recently started, http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial
16:15:11 <augur> byorgey: oh lame
16:15:12 <rothwell> applicative: am actually on section 1.3 right now
16:15:24 <augur> i suppose i vaguely remember soemone complaining that haskell doesnt _really_ allow infix constructors
16:15:26 <augur> hmm
16:15:36 <applicative> rothwell: you're moving more quickly than me...
16:15:41 <byorgey> it does really allow infix constructors.
16:15:44 <mauke> int80_h: I recognize your nick so I thought you'd be more experienced in haskell, especially since the code you pasted isn't beginner stuff
16:15:47 <byorgey> but only ones that begin with a colon.
16:15:52 <mauke> int80_h: do you know how to define your own types?
16:15:55 <augur> byorgey: oh! ok
16:16:14 * applicative thinks int80_h does well to be a bit baffled by the gnuplot package.
16:16:48 * byorgey is baffled that a histogram is defined to be some monstrous type synonym for String
16:16:56 <int80_h> mauke: My progress isn't linear. I find myself dealing with strange corners of the language+extensions. I can't hold in my head everything, and haven't compartmentalized what's basic and what's advanced.
16:17:29 <mauke> int80_h: ok, defining your own types is basic :-)
16:17:35 <mauke> you should know how that works
16:17:57 <int80_h> mauke: I'm reviewing
16:19:16 <int80_h> mauke: the creator of the gnuplot wrapper gave me that type I posted as a solution my problem. And I got confused pretty quick.
16:19:28 <applicative> Cons is such a familiar word I thought HT must be doing something else too, but then reflected that it was a newtype
16:19:39 <int80_h> I'm looking at the haskell wikibook now though.
16:20:56 <rothwell> :t (!?)
16:20:57 <lambdabot> Not in scope: `!?'
16:21:01 <rothwell> fine!
16:21:16 <c_wraith> int80_h: it's quite probable it was meant as a partial answer - "Use this type as the core data structure you work with," for instance.
16:21:42 <int80_h> c_wraith: I'm trusting that if I can make sense of this type, the rest will be evident.
16:22:41 <int80_h> c_wraith: I almost understand what he means, having played around with his examples.
16:23:41 <applicative> int80_h a histogram itself is just a string, of course this is nowhere visible in the type histogram :: (Atom.C x) => Graph2DType.T Int Int (x,String)
16:26:11 <applicative> the T Int Int blah type means that the 2D graph can use Ints as the x and y axis so to speak.   For something other than a histogram you'd want T Double Double blah, for example
16:26:30 <reacocard> I'm curious what the reason for Setup.hs is, when cabal can figure things out on its own just. Is it just there for those who prefer not to use cabal or is there some higher purpose?
16:26:44 <applicative> runhaskell Setup.hs configure
16:26:58 <sm> reacocard: it lets you customise what cabal does for more complex projects
16:27:01 <applicative> reacocard: that's the older way ^^
16:27:05 <reacocard> ah ok
16:27:23 <sm> and historically, it was the ui before cabal came along
16:27:34 <reacocard> it was just bothering me slightly to have the same boilerplate Setup.hs in every package :)
16:27:40 <sm> me too
16:27:45 <applicative> it's usually very simple, but some are really complicated
16:28:05 <byorgey> reacocard: cabal init  can auto-generate Setup.hs for you, btw
16:28:19 <reacocard> byorgey: but why do things the easy way? :P
16:28:19 <sm> I think I'd like if cabal inferred it if missing
16:28:27 <byorgey> hehe
16:28:37 <reacocard> sm: well cabal configure and build and install work fine without it
16:28:44 <reacocard> sm: but hackage wont accept it :/
16:28:49 <sm> ah rats
16:29:29 <Saizan> reacocard: cabal sdist will put one in the tarball for you
16:29:40 <reacocard> Saizan: no it doesn't
16:29:43 <reacocard> it jsut complains
16:29:49 <reacocard> this may be how i found out about this
16:30:06 <Saizan> weird
16:30:49 <applicative> reacocard: here's a somewhat complicated Setup.hs just to prove they exist: https://github.com/jgm/pandoc/raw/9ff589359f3907816b819eab5371ea7372cafea1/Setup.hs
16:30:59 <Saizan> steal one from somewhere then :)
16:31:09 <reacocard> applicative: oh my
16:31:27 <reacocard> Saizan: yeah i jsut pulled a three-liner off wikibooks and copied it into everything
16:48:07 <hellertime> What is the status of the Test Suite framework for Cabal? The cabal-test package on hackage currently won't compile (can't find Tests module), and I only see mention of cabal-test-hunit
16:49:42 <hellertime> I wanted to try and create a 'detailed' test suite, but am unsure where to begin
16:50:23 <parcs> cabal has a tests support built-in
16:51:23 <hellertime> parcs: are there docs for using HUnit with its built in test runner? I've seen mention to the cabal-test-hunit package, but have no idea where it is located
16:52:17 <gwern> > 1.458 + 2.37
16:52:18 <lambdabot>   3.8280000000000003
16:52:21 <int80_h> http://hpaste.org/paste/47111/help_me_suss_out_this_type_sig#p47114
16:54:33 <hellertime> Thomas Tuegel isn't in the room is he? :)
16:54:44 <mauke> int80_h: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
16:56:33 <marchdown> I'm trying to set up haskell-mode for emacs. What purpose does haskell-site-file serve?
17:04:03 <byorgey> marchdown: it loads a whole bunch of stuff related to haskell-mode
17:04:18 <byorgey> marchdown: so all you have to do is a single load of haskell-site-file
17:05:37 <marchdown> thanks.
17:07:13 <marchdown> Is there a preferred way to avoid hardcoding ~/.emacs.d/elpa/haskell-mode-x.y.z/haskell-site-file ?
17:07:35 <marchdown> there are no (provide)s in haskell-site-file
17:08:06 <byorgey> I don't know.
17:08:12 <marchdown> Okay.
17:31:28 <int80_h> mauke: is the type I am having trouble with a partially applied type constructor?
17:33:26 <int80_h> > seen mauke
17:33:27 <lambdabot>   Not in scope: `seen'Not in scope: `mauke'
17:33:33 <int80_h> hmm
17:33:43 <hpc> preflex: seen mauke
17:33:43 <preflex>  mauke was last seen on #tma 10 minutes and 4 seconds ago, saying: kakazza: http://www.youtube.com/watch?v=C704-o_SuuU
17:34:06 <int80_h> preflex: last mauke
17:34:25 <int80_h> I was trying to figure out if he had left the channel or not
17:34:55 <byorgey> int80_h: I think the answer is no, it is not partially applied
17:35:30 <byorgey> int80_h: since newtype T x y a = Cons String  that means T takes three type arguments
17:36:06 <byorgey> and your type was (Atom.C x) => Graph2DType.T Int Int (x,String)
17:36:16 <byorgey> note that T has three type arguments: Int, Int, and (x,String)
17:37:37 <Saizan> int80_h: "newtype T x y a = Cons String" is what's defining Cons there, as the only data constructor of T, i.e. Cons :: String -> T x y a
17:37:52 <NemesisD> hi all. i'm trying to figure out all possible groupings of members of a list. could anyone point me in the right direction? been trying to figure it out with list comprehensions, inits and tails
17:40:28 <Saizan> what do you mean by all possible groupings, exactly?
17:40:35 <monadic> NemesisD: if you have the list x:xs, then you could have [[x]] ++ groups xs or you can add x to one of the groups of groups xs.
17:41:10 <monadic> NemesisD: I bet you can do the last part with a map + concat or a list comprehension
17:41:17 <NemesisD> Saizan: given [1,2,3]: [1], [1,2], [1,2,3], [1,3], [2,3], [2], [3]
17:41:30 <c_wraith> oh.  you just mean all subsets
17:41:34 <c_wraith> that's much easier
17:41:50 <NemesisD> ah yes, sorry, that was the terminology i was going for
17:41:55 <Saizan> > subsequences [1..3]
17:41:56 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
17:42:17 <monadic> NemesisD: Are you looking for a set or a list, though. Does ordering matter to you?
17:42:29 <c_wraith> > filterM (const [False, True]) [1..3]
17:42:30 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
17:43:15 <NemesisD> i'm pretty sure ordering is irrelevant, and they should be sets. i'm going to be passing this through a predicate after its done
17:44:20 <NemesisD> the real application is i want to buy products A, B, and C. i want to find the fewest number of orders i'd need to place given a list of stores which may or may not have sufficient stock for each item
17:44:35 <NemesisD> so i think subsequences will work beautifully
17:45:14 <monadic> NemesisD: Is there something wrong with using Data.Set if you are using Sets then? It might be more efficient.
17:46:08 <fragamus> schmove :: (RandomGen g) => Cards -> RandT g (StateT Creature []) Move
17:46:44 <fragamus> So I'm using RandT, StateT and []
17:47:14 <calsaverini> exNihilo :: () -> a
17:47:15 <calsaverini> :P
17:47:24 <fragamus> and I want to know if there is more than one g
17:47:49 <fragamus> does the listness apply to the random number thingy
17:48:44 <tg_> @vixen does the listness apply to the random number thingy?
17:48:44 <lambdabot> that's because i have a random generator
17:48:45 <NemesisD> hmm, actually i don't think i want a set. say someone wants to buy 2X product A, i'd want to generate the possibility of buying 1xA from Store 1, 1xA from Store 2, 2x from Store1 and 2x from Store 2
17:49:04 <NemesisD> seems like the simplest way to achieve this is for the starting list to not be a set
17:49:22 <fragamus> if for example I have a functor that receives a single state, and produces 10 states, does it also have 10 random number generators
17:49:42 <parcs> fragamus: good question. i think it depends on the order of the stack
17:49:50 <parcs> but you should make some tests yourself
17:49:57 <fragamus> yeah
17:50:17 <NemesisD> in my case the subsequences will be orders and i will reject them if the store cannot fulfil that order (i.e. [A,A] is not possible for Store 1 if Store 1 only has a single A in stock)
18:03:26 <parcs> fragamus: in your monad stack no, but if you had something like ListT (RandT g (State Creature)) Move then yeah
18:05:57 <parcs> actually maybe not
18:06:09 <parcs> @until ListT (RandT g (State Creature)) Move
18:06:09 <lambdabot> Maybe you meant: unmtl unpl
18:06:12 <parcs> @unmtl ListT (RandT g (State Creature)) Move
18:06:12 <lambdabot> g -> Creature -> ([Move], g, Creature)
18:06:28 <parcs> @unmtl RandT g (StateT Creature []) Move
18:06:28 <lambdabot> g -> Creature -> [(Move, g, Creature)]
18:06:43 <hpc> @unmtl Rand g a
18:06:44 <lambdabot> g -> (a, g)
18:06:48 <hpc> @unmtl State s a
18:06:49 <lambdabot> s -> (a, s)
18:07:25 <hpc> practical joke: change Rand to be an alias for State
18:08:11 <fragamus> parcs: thanks
18:09:24 <dmwit> hpc: Um, it already is.
18:09:47 <dmwit> newtype RandT g m a = RandT (StateT g m a)
18:10:05 <dmwit> The only difference is it inherits its MonadState instance from the underlying monad rather than creating a fresh instance.
18:10:39 <c_wraith> holy crap.  the new simon^2 paper is exciting
18:11:23 <parcs> RandT wraps the lazy StateT as opposed to the strict one. any reason why?
18:12:05 <dolio> I don't know, man. If the collector isn't totally concurrent, it won't "scale" and will therefore be useless. :)
18:12:32 <c_wraith> core-local heaps sound concurrent to me.
18:12:43 <c_wraith> don't have to pause the rest to collect your heap.
18:12:54 <dolio> Those are only minor collections. *waves hands*
18:13:28 <c_wraith> I wonder what that does to scheduling, though.
18:13:44 <c_wraith> It seems like if you're using core-local heaps, it would pay to not migrate green threads between cores very often
18:14:18 <c_wraith> So that threads don't tend to allocate within different heaps
18:15:17 <dolio> Heh, paragraph 2 of the intro says concurrent GC may not be a very good option.
18:20:43 <dankna> dcoutts: ping?
18:24:05 <c_wraith> Oh, wow.  It uses a read barrier on global -> local pointers that requires that the thread doing the read either own the heap, or request the owning thread to promote it to global.
18:24:15 <calsaverini> is there a curry-like function for Arrows?
18:24:46 <c_wraith> Sounds like it would *heavily* favor scheduling the same green threads on the same native thread
18:24:57 <c_wraith> whenever reasonable
18:25:01 <calsaverini> something like (a,b) ~> c -> (a~> (b ~> c))
18:27:17 <dibblego> missing a couple of parens there, and have a couple of redundant ones that you could borrow :)
18:27:47 <calsaverini> ahaha
18:27:56 <calsaverini> ~> confuses me
18:28:19 <calsaverini> I meant (Arrow m) => (m (a,b) c) -> (m a (m b c))
18:28:53 <c_wraith> yeah, the outer parens aren't necessary in either of those cases. :)
18:29:09 <c_wraith> I don't think there's an existing combinator for that
18:29:45 <calsaverini> hum... I feel like it shouldn't be hard to write this, but I cant... :/
18:32:57 <Cale> curryA f = proc x ->
18:32:58 <Cale>             do returnA -< proc y ->
18:32:58 <Cale>                             do f -< (x,y)
18:34:40 <calsaverini> hummm
18:34:42 <Cale> curryA :: (Arrow a, Arrow a') => a (u,v) w -> a' u (a v w)
18:35:12 <calsaverini> I was strugglying with nesting thw arrow procs
18:35:27 <ion> Oh, cool. I didn’t know about TypeOperators.
18:36:36 <ion> first :: Arrow (~>) => (b ~> c) -> ((b, d) ~> (c, d)) is more readable than (Arrow a) => a b c -> a (b, d) (c, d), but omitting the redundant parentheses would make it less readable IMO due to -> being visually very similar to ~>
18:38:02 <ion> Without using TypeOperators, Arrow (~>) => (~>) b c -> (~>) (b, d) (c, d) is quite nice, too.
18:39:40 <Cale> curryA :: (Arrow a, Arrow a') => a (u,v) w -> a' u (a v w)
18:39:40 <Cale> curryA f = arr (\x -> arr (\y -> (x,y)) >>> f)
18:39:46 <Cale> ^^ another, less sugary option
18:55:09 <bmars> learning haskell, looking for a project to help out with, anyone know of some good ones?
19:01:55 <NemesisD> hmm i think my initial algorithm for this project is wrong.
19:02:31 <mm_freak_> bmars: i suggest starting with some small own programs
19:03:03 <danharaj> I find it strange that you can define an instance for a class that requires other classes, and then define the prerequisites in terms of the instance of the class that demands them :p
19:03:49 <bmars> mm_freak_: i've written some
19:13:49 <bmars> why does hackage use hayoo! instead of hoogle?
19:17:14 <mm_freak_> bmars: real world applications or just some tools for practicing the language?
19:17:41 <bmars> definitely something interesting, most likely a real world application
19:19:02 <danharaj> @src fix
19:19:03 <lambdabot> fix f = let x = f x in x
19:22:38 <bmars> where can i find the logs for this channel? tunes.org can't seem to find them
19:23:02 <mauke> what do you mean by "can't seem to find them"?
19:23:51 <bmars> when i click on the link i get a page not found
19:24:03 <mauke> I don't
19:24:17 <bmars> can you provide the link please?
19:24:21 <mauke> conclusion: your autolinkifier is stupid
19:24:38 <mm_freak_> bmars: i think the larger haskell projects like darcs and GHC would be grateful for any contributions
19:24:40 <mauke> and you didn't notice the %22 in the address bar
19:24:54 <ddarius> mauke: Reading is for the plebs.
19:25:37 <bmars> mauke: it was a literal quote, missed it
19:25:48 <jesse_> Is it possible to define a recursive function without binding it to a name, and without calling any other functions (such as fix)?
19:26:11 <mauke> jesse_: I'd like to see you define a function without calling any other functions
19:26:42 <ddarius> mauke: Quite easy to do.
19:26:50 <ddarius> Taken very literally, that's the only option.
19:26:50 <jesse_> mauke: \x -> x
19:27:02 <Axman6> (\x -> x), (\x y -> y x) ...
19:27:09 <mauke> Axman6: that calls y
19:27:35 <mm_freak_> jesse_: in typed lambda calculus without Y (fix) it's impossible
19:27:39 <Axman6> but y isn't another function there, it's a something that eventually will be bound to another funcion :P
19:27:53 <mauke> I can only think of two categories of functions, and neither of them do anything
19:28:27 <mauke> option 1: ignore your arguments, return a constant
19:28:46 <mauke> option 2: return (a part of) your argument
19:29:22 <ddarius> if falls into that group.
19:29:27 <Eduard_Munteanu> As polymorphism goes up, option 1 goes down.
19:29:52 <ddarius> As does fromMaybe
19:29:54 <sm> bmars: for a while, hayoo covered hackage packages and hoogle didn't. It would be good to update that now
19:29:54 <fragamus> schmove :: (RandomGen g) => Cards -> RandT g (StateT Creature []) Move
19:30:11 <fragamus> I need to make a constructor for that ^^^
19:30:34 <bmars> sm: yeah, it seems odd
19:31:02 <mm_freak_> option 3: return one or more arguments applied to one or more arguments
19:31:29 <ddarius> mm_freak_: That's calling a function.
19:31:32 <jesse_> Hmm maybe I'm asking the wrong question. Suppose when defining a function such as f = \x. ...., you were not allowed to reference f in the function body. Would such a language allow divergent functions to be defined? Or any recursion at all, for that matter?
19:31:44 * sm wishes for haskell.org/hayoo
19:31:54 <mauke> jesse_: depends on your type system
19:32:05 <ddarius> and your terms
19:32:14 <ddarius> and your primitives
19:32:17 <mauke> jesse_: (\x -> x x) (\x -> x x)
19:33:07 <Eduard_Munteanu> That's omega IIRC.
19:33:08 <bmars> has a little schemer been translated into haskell yet?
19:33:12 <Eduard_Munteanu> No?
19:33:23 <danharaj> edwardk: Is there a non-obsolete package that defines your Zip typeclass?
19:33:52 <seafood> Can you test for exceptions using HUnit or some other Test Framework?
19:34:08 <jesse_> :t (\x -> x x) (\x -> x x)
19:34:09 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
19:34:09 <lambdabot>     Probable cause: `x' is applied to too many arguments
19:34:09 <lambdabot>     In the expression: x x
19:34:19 <NemesisD> hmm this is odd. zipWith splitAt [0..] [1..3] gives me :no instance for (Num [a0]) arising from the literal `3'
19:34:31 <jesse_> mauke: ^ is that what you mean by "it depends on your type system"?
19:34:33 <Eduard_Munteanu> jesse_: well, that's not typable in Haskell
19:34:34 <mauke> NemesisD: why do you think that's odd?
19:34:39 <mauke> jesse_: yes
19:34:53 <ddarius> O'Caml can type that expression.
19:34:55 <Eduard_Munteanu> I don't really know a typesystem where that's typable.
19:35:03 <Eduard_Munteanu> Except the untyped lambda calculus :)
19:35:06 <mauke> Eduard_Munteanu: all you need is recursive types
19:35:17 <Eduard_Munteanu> Hrm.
19:35:25 <BMeph> NemesisD: ...you _do_ know that neither 1, 2 or 3 are lists, right? ;)
19:35:35 <Eduard_Munteanu> In fact... equirecursive, no?
19:35:40 <ddarius> BMeph: They could be lists.
19:36:04 <ddarius> Eduard_Munteanu: That's how O'Caml is able to type that, but there are other ways.
19:36:16 <mauke> newtype F = F{ call :: F -> F }; call (F (\f -> call f f)) (F (\f -> call f f))
19:36:16 <Eduard_Munteanu> So O'Caml goes the equirecursive way? My appreciation for their bravery :)
19:36:49 <ddarius> Eduard_Munteanu: Only as an extension, and, I believe, it will never infer equirecursive types; you always have to declare them.
19:36:51 <BMeph> ddarius: Well unless there's a Maude-style Haskell interpreter, someone needs to inform NemesisD's system how to do that.
19:36:59 <Eduard_Munteanu> It's quite hard to find such languages, I don't know a theorem prover who does it...
19:37:00 <NemesisD> BMeph: zipWith :: (a -> b -> c) -> [a], -> [b] -> [c], doesn't [1,2,3] represent the [b] in that?
19:37:10 <ddarius> instance Num [a] where ...
19:37:13 <Eduard_Munteanu> Yeah, even so.
19:37:13 <NemesisD> oh wait i see the problem
19:37:14 <mauke> NemesisD: it does
19:37:26 <Eduard_Munteanu> Agda and Coq don't seem to have them.
19:37:35 <ddarius> Eduard_Munteanu: Why would you think they would want them?
19:37:52 <jesse_> Okay so turns out my question is more complicated than I thought.
19:38:04 <Eduard_Munteanu> Peace of mind, completion? No, but I think it's interesting.
19:38:28 <Eduard_Munteanu> bcpierce hints at difficulties involved in doing equirecursive types.
19:39:12 <mauke> jesse_: does my newtype solution count?
19:41:46 <Eduard_Munteanu> I wonder, unconstrained equirecursive types would make typechecking undecidable, wouldn't they?
19:42:32 <ddarius> I'm pretty sure they would not.
19:42:37 <Eduard_Munteanu> Especially in something like Agda where it doesn't get any simpler when you go to kinds or sorts.
19:42:52 <Eduard_Munteanu> Ah.
19:44:08 <dolio> sorear wrote type inference for equirecursive types way back.
19:44:24 <dolio> The problem is that too much stuff becomes well-typed.
19:44:27 <ddarius> It's more or less just unification over rational trees.
19:44:27 <Eduard_Munteanu> I presume there would be terms which would have divergent types, whose kinds would be divergent and so on... so at least you couldn't write some types/terms
19:44:40 <ddarius> Eduard_Munteanu: Why do you presume that?
19:46:33 <ddarius> In fact, what is a "divergent" type?  I mean, in a dependently typed context, yes you'd have problems because equirecursive types make fix typeable and thus you can do arbitrary computation and thus you could have dependent types depend on those terms.
19:46:34 <Eduard_Munteanu> Well you can already write omega as a term and have something with a recursive type. Couldn't there be terms with diverging types?
19:47:01 <diabolix> so, I'm writing some code that uses the IO monad, and I find myself often taking things that could be pure functions and making the return type 'IO a' instead of just 'a'. Should I be writing pure functions and then doing 'res <= return $ func arg'? That feels weird, but I don't think I should be using monads everywhere either.
19:47:05 <jesse_> mauke: Well if I'm not mistaken you've just substituted referencing a function from within its definition with referencing a type (F) within its definition.
19:47:16 <mauke> jesse_: yes
19:47:18 <Eduard_Munteanu> A divergent type is a recursive type which diverges.
19:47:25 <Eduard_Munteanu> Just like in terms.
19:47:30 <mauke> jesse_: there's a type-level 'fix' too :-)
19:47:54 <mauke> diabolix: why not just 'let res = func arg'?
19:50:08 <Eduard_Munteanu> ddarius: so you'd say it's not really possible to have even something simpler, like "write a term whose corresponding kind is recursive"?
19:50:20 <Eduard_Munteanu> That's what I'm thinking.
19:50:47 <Eduard_Munteanu> I'm not sure I can produce an example though.
19:50:50 <ddarius> I don't know even what you are talking about.
19:51:59 <dolio> A lot of type systems don't contain much computation.
19:52:00 <Eduard_Munteanu> Write down omega. You've got something with a recursive type just by thinking of a term.
19:52:11 <Eduard_Munteanu> (namely omega)
19:52:11 <ddarius> Equirecursive types do lead to divergent terms in even roughly common term systems.  They can combine with other features to lead to undecidability of type checking.  They don't immediately imply that in and of themselves.
19:52:22 <dolio> And mu doesn't really add any.
19:52:46 <Eduard_Munteanu> Now, can one say something like that about kinds (i.e. types of types) of such terms?
19:53:08 <djahandarie> SleepingKitty, wouldn't it be SleepingInsect?
19:53:53 <sm> when the types get too much: http://kottke.org/11/05/worlds-best-tetris-player
19:57:56 <Eduard_Munteanu> Obviously this isn't of any interest to Agda and Coq since you don't get to do unconstrained recursion there anyway :)
19:58:28 <Eduard_Munteanu> (erm, well you can if you try really hard)
19:59:56 <bmars> is there a wiki for the second edition of the typeclassopedia?
20:00:59 <fragamus> schplit :: (RandomGen g) => RandT g (StateT Creature []) ()
20:00:59 <fragamus> schplit = StateT (\(a,b) -> [((),(a,b))])
20:01:19 <fragamus> need help making this explicit constructor
20:22:02 <NemesisD> gah ok i think i need some guidance on this algorithm
20:23:38 <eekTheCat> is it a guidance algorithm?
20:24:03 <NemesisD> so i've got a list of products and a list of stores. i'm trying to get all the ways in which the products can be distributed to the stores: distribs :: [Store] -> [Product] -> [[(Store,[Product])]]
20:24:07 <NemesisD> lol in a way it is
20:24:53 <dibblego> @type liftA2 (,) -- perhaps
20:24:54 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
20:25:01 <NemesisD> the closest i've got is: distribs stores prods = [ (store, subset) | store <- stores, subset <- subsequences prods]
20:25:25 <dibblego> that is liftA2 (,), is this insufficient?
20:25:27 <lispy_> Is GHC's core lambda lifted?
20:25:32 <NemesisD> that is almost perfect but it doesn't group them properly of course
20:25:49 <dibblego> NemesisD: what function "groups them"?
20:26:14 <lispy_> I'm looking at SPJ's "Implementing Functional Languages: A tutorial" and it talks about lambda lifting, but I thought GHC's actual core had local lambdas
20:26:17 <NemesisD> dibblego: that's the part i haven't figured out yet :P i'm missing a map in there somewhere i think
20:27:19 <NemesisD> subsequences seems to be a poor choice actually since it tosses the remainder
20:27:44 <NemesisD> i almost want splitAt but with an arbitrary amount of tupling
20:32:43 <bwright> How do I sum 2 integers on the first line of a file i.e "2 3" I tried main = writeFile "addout.txt" . show . sum . map read . lines =<< readFile "addin.txt"
20:33:58 <aavogt> map read means you're calling read on each line
20:33:59 <bwright> But I need it per space instead of per line
20:34:44 <aavogt> use words to split on the space
20:35:03 <aavogt> > map read (words "2 3") :: [Int]
20:35:03 <bwright> ah I am a nub ty
20:35:04 <lambdabot>   [2,3]
20:42:34 <NemesisD> dibblego: got any more hints you could send my way?
20:52:00 <seafood> Can anyone explain to me what shrinking is in the context of quickcheck?
20:52:19 <ddarius> Producing smaller counter examples.
21:00:02 <eekTheCat> NemesisD, do you have to have some click one liner?
21:00:34 <NemesisD> eekTheCat: what do you mean?
21:02:00 <eekTheCat> the problem seems easy to me when I mentally break it up into 3 functions
21:03:03 <NemesisD> my first idea was to do it in a list comprehension but i'm all for breaking it up. i've just been staring at this problem all night and need a nudge in the right direction
21:04:35 <deech> Hi all, I was just reading about implicit parameters and can't seem to think of a good use case. I read ezyang's blog post (http://blog.ezyang.com/2010/07/implicit-parameters-in-haskell/) and I'm still not convinced. Is there any reason I need to know how to use them?
21:05:56 <Axman6> I've never seen them used anywhere, except to find the types of values in expressions:
21:06:07 <Axman6> :t let f x = x + ?y in f
21:06:07 <lambdabot> forall a. (Num a, ?y::a) => a -> a
21:06:28 <dankna> wait what?  that's valid Haskell?
21:06:46 <shachaf> dankna: FSVO "Haskell".
21:06:51 <dankna> hm
21:07:22 <deech> Axman6: I have never seen that, it seems useful for debugging.
21:07:39 <thoughtpolice> ah, implicit parameters, such an infrequently seen extension
21:07:39 <Axman6> I've only ever seen it used in here
21:07:45 <shachaf> Implicit parameters are occasionally useful.
21:07:53 <Axman6> > let f x = x + ?y in let y = 3 in f 2
21:07:53 <lambdabot>   mueval-core: internal error: PAP object entered!
21:07:54 <lambdabot>      (GHC version 6.12.3 f...
21:07:54 * edwardk1 waves hello.
21:07:57 <Axman6> heh
21:08:01 <Axman6> o/ edwardk1
21:08:06 <edwardk1> preflex: xseen roconnor
21:08:07 <preflex>  roconnor was last seen on freenode/#haskell 6 hours, 57 minutes and 15 seconds ago, saying: @type forever
21:08:07 * shachaf particles at edwardk1.
21:08:18 <Axman6> i see the original edwardk has finally been assissinated and replaced.
21:08:21 <NemesisD> eekTheCat: what is the gist of each 3 functions?
21:08:23 <thoughtpolice> and of course there are alternatives, like edwardk1's reflection package :)
21:08:30 <Axman6> there were 6 previous Axman's before I
21:08:44 <lispy_> edwardk1: do you know much about GHC core?
21:08:59 <edwardk1> lispy: More than I'd like to. ;)
21:09:03 <lispy_> edwardk1: in particular, do you happen to know if it's lambda lifted?
21:09:08 <edwardk1> but possibly less than you need =)
21:09:43 <edwardk1> well, case expressions would make that hard
21:09:47 * lispy_ is reading some older spj tutorials to gain a deeper understanding of core
21:10:23 <edwardk1> hrmm
21:10:30 <lispy_> in this document, the "core" language isn't GHC's core, but it assumes the translation to Core involves lambda lifting.  (It does have case expressions) http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
21:11:19 <lispy_> I think that GHC's core is lambda lifted in the way this tutorial uses it because I don't think core has local function definitions
21:11:33 <lispy_> it has let though
21:11:36 <lispy_> So I get confused
21:11:43 <ddarius> lispy_: You do realize that that was written in 1992.
21:12:19 <edwardk1> well. http://www.cs.cmu.edu/afs/andrew/course/15/411/ghc/share/doc/ghc/ext-core/core.pdf includes lambdas as an expression type
21:12:27 <edwardk1> so i'm guessing its not
21:12:53 <edwardk1> (and its a damn sight more recent)
21:13:35 <lispy_> edwardk1: yes, but look at page 17 of the link I gave you.
21:14:08 <lispy_> ddarius: Yes, if I wanted to know details of GHC core I would use the link edwardk gave (I'm already familiar with it).  I'm reading this older material to study the evalutation model.
21:14:30 <ddarius> lispy_: Why do you think it is still the same?
21:14:37 <lispy_> ddarius: I don't
21:15:01 <lispy_> ddarius: But, the general concepts of how a core-like language is translated to a G machine is useful
21:15:29 <lispy_> I know that G machine != STG
21:15:45 <lispy_> But, I wanted to go back to the roots and start with the simplier variants
21:16:01 <edwardk1> i find the STG to be much nicer to think about
21:16:34 <ddarius> lispy_: What makes you think that current core is just a "more complex variant" of what that tutorial describes?
21:17:09 <lispy_> ddarius: If they're wildly different then I hope I'll notice.
21:18:32 <lispy_> So far, they seem reasonably similar to me considering that this one is a lot simpler.
21:18:56 <lispy_> they're both for strongly typed lazy languages, too
21:19:31 <tg_> there's a interesting formatting error on this page, for me: http://hackage.haskell.org/packages/archive/Cabal/1.10.1.0/doc/html/Language-Haskell-Extension.html
21:19:48 <tg_> which isn't there for Classic style
21:19:59 <dankna> tg_: what's the error?
21:20:26 <tg_> dankna: import "network" Network.Socket is floating above the page
21:21:18 <lispy_> oh yeah, that is weird
21:21:21 <dankna> oh hey, so it is.  about halfway down.
21:21:31 <edwardk1> @tell roconnor my talk on lenses: http://www.youtube.com/playlist?p=PLEDE5BE0C69AF6CCE
21:21:31 <lambdabot> Consider it noted.
21:21:51 <edwardk1> @tell roconnor sorry, no category theory ;)
21:21:51 <lambdabot> Consider it noted.
21:22:15 <ion> Thanks for the link
21:22:40 <tg_>  http://i.imgur.com/P3oVq.jpg
21:22:42 <bwright> If I wanted to grab all the words in a file and put them into a list as integers how would I go about that? (New to haskell, just going through informatic olympiad problems trying to convert my C to haskell)
21:22:45 <tg_> who should I @tell about this?
21:22:59 <mauke> bwright: map read . words
21:23:24 <ion> map read . words <$> readFile "foo" :: IO Integer
21:23:37 <mauke> ion: type error
21:23:48 <ion> Heh, indeed. :: IO [Integer]
21:23:50 <tg_> bwright: a more gentle introduction can be found by going throug this: http://learnyouahaskell.com/modules
21:24:07 <tg_> but i'm sure one of their suggestions will just get you to it
21:24:56 <danharaj> edwardk1: I want to use your Zip class, but it's in the obsolete category-extras. Is it elsewhere?
21:25:18 <ion> Of course, to get informative error messages for invalid input, use one of the parser libraries.
21:25:39 <tg_> is attoparsec being used in all cases with new stuff?
21:25:48 <tg_> It seems to have superceded parsec in many newer libraries
21:26:04 <ddarius> tg_: No, it is not.
21:26:07 <edwardk1> danharaj: its buried in 'keys' right now
21:26:21 <tg_> dankna: who should I report this error to? the maintainer of the Cabal package?
21:26:29 <tg_> or the maintainer of hackage styles?
21:26:29 <edwardk1> danharaj: this is suboptimal. i need to move it out as it doesn't need the extensions that keys needs
21:26:46 <danharaj> edwardk1: what's a keyed functor :o
21:28:24 <dankna> dankna: the maintainer of haddock
21:28:28 <dankna> ><
21:28:31 <dankna> addressing fail
21:28:33 <tg_> yeah
21:28:34 <tg_> i got it
21:28:36 <dankna> tg_: the maintainer of haddock
21:28:52 <dankna> dankna: stop repeating everything I say!
21:28:54 <dankna> dankna: you stop first!
21:29:01 <edwardk1> danharaj: it gives you a notion of 'mapWithKey'
21:29:12 <tg_> dankna: if you do that one more time, the world might explode
21:29:16 <dankna> :D
21:29:26 <copumpkin> edwardk1: it seems that without a "key" to "join on", it's hard to define Zip?
21:29:41 <edwardk1> danharaj: other classes in there let you use the key in other ways.
21:29:55 <edwardk1> copumpkin: yeah hence why Zip should be in a higher package
21:30:00 <edwardk1> but I needed Key for ZipWithKey
21:30:09 <edwardk1> which is in a subclass of Zippable
21:30:15 <danharaj> edwardk1: I have a hard time thinking of a Keyed functor that isn't Indexable :p
21:30:17 <edwardk1> and i defined it first here
21:30:28 <copumpkin> oh, what I meant is that I would have assumed Zip would depend on keys
21:31:17 <edwardk1> danharaj: Map k is safely Keyed, but really _shouldn't_ be Indexable
21:31:28 <edwardk1> because it doesn't yield a value for _every_ choice of key
21:31:50 <edwardk1> it can safely inhabit "Lookup" though
21:32:07 <edwardk1> which is a bit of a hack to cover the Map case
21:32:09 <edwardk1> ;)
21:32:41 <danharaj> edwardk1: :p. Anyway. I look forward to the day when Zip is liberated of its Keyed oppressors.
21:33:16 <edwardk1> it'll probably happen next time i'm willing to spend 3 hours bubbling up all 20 downstream package dependency changes
21:33:52 <danharaj> :p
21:33:53 <edwardk1> i eventually want to break up the Data.Key module, its way too big
21:34:11 <edwardk1> so that'll probably be a good point to split out Zippable
21:34:35 <NemesisD> eekTheCat: the suspense is killing me :P
21:35:25 <ivanm> edwardk1 == edwardk ?
21:36:44 <danharaj> oh come on. There should totally be a prelude function `pair :: a -> b -> (a, b)'
21:36:53 <ddarius> :t (,)
21:36:54 <lambdabot> forall a b. a -> b -> (a, b)
21:37:13 <ivanm> danharaj: see, there is!
21:37:16 <koninkje> > (,) 1 2
21:37:17 <lambdabot>   (1,2)
21:37:23 <danharaj> It did not occur to me that (,) was a data constructor because it's `special'
21:37:27 * danharaj d'oh
21:37:28 <mauke> did you mean: pair :: (a -> b -> c) -> (a, b) -> c
21:37:37 <danharaj> :t uncurry
21:37:38 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
21:37:54 <edwardk1>  usually
21:38:17 <edwardk1> i have a bad tendency to forget to log off when switching computers
21:38:31 <ivanm> heh
21:38:42 * ddarius just uses one computer.
21:38:46 <ivanm> edwardk1: did you have a chance to look through the API for planar-graph ?
21:38:56 <edwardk1> ivanm: not yet
21:39:11 <ivanm> ddarius: I occasionally forget to close the IRC client on my uni machine before heading off home; ssh'ing then pkill'ing works wonders though!
21:39:27 * ddarius just uses one computer.
21:39:38 <monochrom> I am the opposite. I terminate programs prematurely
21:41:01 <edwardk1> i bounce between something closer to 5 + an ipad to get online.
21:41:31 <monochrom> a social butterfly among computers :)
21:41:46 <augur> hm
21:41:59 <augur> is there anything in type theory that depends crucially on types being sets?
21:42:05 <monochrom> no
21:42:18 <ddarius> Oftentimes it's crucial that the types aren't sets.
21:42:25 <edwardk1> monochrom: i was going to say computer slut, but that has a better ring to it ;)
21:42:37 <augur> ddarius: well, sets, classes, etc. :p
21:42:52 <ddarius> Oftentimes it's crucial that the types aren't sets.
21:42:57 <augur> or more precisely, the idea that types are objects as well
21:42:57 <Eduard_Munteanu> Usually they don't say they're anything.
21:43:52 <Eduard_Munteanu> Sure 'x has type y' has a set-y interpretation but it isn't really a set in the ZF sense.
21:43:58 <monochrom> it is like "monads being burritos"
21:44:56 <augur> ddarius: i ask cause im reading Boolos on plural logic, and im curious whether or not his conception of plural variables (and i suppose also plural constants) has anything interesting to say as a type theory
21:45:41 <Eduard_Munteanu> Don't trust anything Greek or Greek-sounding :P
21:45:45 <augur> :P
21:46:00 <monochrom> such as λ calculus?
21:46:11 <augur> monochrom: ?
21:46:15 <Eduard_Munteanu> Boolos sounds like a Greek name.
21:46:16 <monochrom> Greek-sounding
21:46:45 <monochrom> in fact, make it better: λ kalkulos
21:46:54 <Eduard_Munteanu> Heh.
21:47:21 <djahandarie> The λ calculus, forged in ancient greece, forgotten until rediscovered by the archaeologist Alonzo Church
21:47:50 <augur> ahh there would probably be an issue with the constructive component of the proof theory for plural variables
21:47:51 <augur> yes
21:48:19 <monochrom> α equivalos, β redukcios
21:50:19 <ddarius> "Fat washing can work well in these circumstances."
21:57:06 <NemesisD> i think my brain has seized up
21:57:25 <eekTheCat> NemesisD, one function to build all the product combinations, one to group all the stores with the products
21:57:32 <eekTheCat> NemesisD, unless i'm misunderstanding the problem
21:57:56 <fragamus> one group to bring them all and in the darkness >>= them
21:58:05 <monochrom> hahaha
21:58:39 <fragamus> function i mean ^^^
21:59:44 <NemesisD> eekTheCat: function one I figure needs to have access to at least the number of stores
22:02:15 <NemesisD> so if products are [1,2], the result would be [[[],[1,2], [[1],[2]], [[1,2],[]]. the second function would do something like: zip (permutations stores) productCombinations
22:02:46 <NemesisD> wait thats not quite right
22:04:56 <eekTheCat> NemesisD, I might be talking out of my ass, let me try to implement this
22:05:49 <NemesisD> eekTheCat: yeah the grouping of products bit has proven fairly challenging for me given an arbitrary number of groups it needs to do
22:19:39 <eekTheCat> NemesisD, here is my terrible implementation http://hpaste.org/47118/horrible_implementation
22:19:59 <eekTheCat> my brain isn't working so well either at 1:30 AM.
22:20:07 <eekTheCat> i'm not very good at haskell even when it is working
22:20:09 * ddarius thinks he has hit the time when the servers are busy.
22:20:57 <NemesisD> eekTheCat: i appreciate the effort, i'll take a look
22:21:01 <fragamus> I have a stack of monad transformers and I'm trying to make an explicit constructor for it but I guess I don't understand well enough
22:21:08 <NemesisD> this problem was way harder than i thought it would be
22:22:07 <fragamus> schplit :: (RandomGen g) => RandT g (StateT Creature []) ()
22:22:29 <fragamus> that's my type for the functor schplit
22:22:47 <fragamus> and this is as far as i got on the constructor:
22:22:58 <fragamus> schplit = (StateT (\(a,b) -> [((),(a,b))]))
22:23:18 <fragamus> I dont know how to add the RandT part
22:23:42 <tsuraan> does anybody have an idea as to why Text.JSON implemented JS Objects using a list of (k,v) pairs instead of using Data.Map?
22:24:07 <koeien> aeson doesn't afaik.
22:24:28 <ivanm> aeson uses vector
22:24:36 <ivanm> tsuraan: my guess is to preserve the ordering
22:24:43 <ivanm> in case you needed the ordering preserved
22:25:08 <tsuraan> it lets weird things happen, like this:
22:25:21 <tsuraan> encode $ toJSObject [("foo","bar"),("foo","baz")]
22:25:22 <tsuraan> "{\"foo\":\"bar\",\"foo\":\"baz\"}"
22:25:37 <ivanm> tsuraan: so that's an error in how you're generating it
22:25:48 <ivanm> and maybe some things that read in JSON allow/accept that?
22:26:13 <tsuraan> is there an efficient way to replace items in a k,v list?
22:26:34 <ivanm> nope
22:26:42 <fragamus> schplit :: (RandomGen g) => RandT g (StateT Creature []) ()
22:26:45 <fragamus> schplit :: (RandomGen g) => RandT g (StateT Creature []) ()
22:26:53 <ivanm> the most efficient would be to use a splitting function
22:26:58 <ivanm> but that's still O(n)
22:27:02 <eekTheCat> NemesisD, my implementation definitely isn't very space friendly. it would easily blow the stack.
22:27:06 <tsuraan> that's better than filter and cons though?
22:27:10 <tsuraan> that was my best thought :)
22:27:21 <ivanm> tsuraan: so you can always import the list into a Map, play with it, and then get the assocs back out again
22:27:31 <tsuraan> true
22:27:34 <tsuraan> maybe I should do that
22:27:40 <NemesisD> eekTheCat: i'm a bit confused about productCombinations. why does it call productCombinations twice and append those to eachother, it seems arbitrary to me
22:27:43 <ivanm> tsuraan: well, filter would be better if more than one of each value may be there
22:29:09 <eekTheCat> NemesisD, the first line combines the first product with all the subcombinations. The second line is all the sub combinations without the first product.
22:29:39 <tsuraan> but if the list starts with unique keys, using a split (or even just map, I suppose) would probably be good
22:30:59 <tsuraan> so the JSON RFC says names in an object SHOULD be unique, so repeated names are definitely legal.  crazy :)
22:31:11 <eekTheCat> NemesisD, did that make sense? I could try to restate it
22:31:32 <ivanm> tsuraan: huh? as in uniqueness is nice but not mandatory?
22:31:44 <tsuraan> yeah, I guess so
22:32:13 <tsuraan> from RFC4627: "The names within an object SHOULD be unique."
22:32:31 <NemesisD> eekTheCat: yeah i think i get it, it recurses depth first
22:32:45 <NemesisD> im trying to think of alternatives because that does seem rather stack-explodey
22:32:54 <NemesisD> even though it definitely does the job
22:35:30 <eekTheCat> NemesisD, that second function should easily have been a simple list comprehension http://hpaste.org/47120/horrible_implementation_annot
22:36:48 <NemesisD> eekTheCat: ah yes!
22:40:28 <NemesisD> oh man, i should not have tried that out with lists of 100 and 50 respectively
22:45:41 <ivanm> @hoogle \ p x -> if p x then Just x else Nothing
22:45:41 <lambdabot> Parse error:
22:45:41 <lambdabot>   --count=20 "\ p x -> if p x then Just x else Nothing"
22:45:41 <lambdabot>              ^
22:45:49 <ivanm> @pl \ p x -> if p x then Just x else Nothing
22:45:49 <lambdabot> flip flip Nothing . (`ap` Just) . (if' .)
22:46:21 <ivanm> @hoogle (a -> Bool) -> a -> Maybe a
22:46:21 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
22:46:21 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
22:46:21 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
22:50:12 <ion> @pl \p x -> (<*>) (<$) (guard . p) x
22:50:12 <lambdabot> ((<$) <*>) . (guard .)
22:50:56 <ion> > (<*>) (<$) (guard . (==1)) 2 :: Maybe Integer
22:50:57 <lambdabot>   Nothing
22:51:55 <ivanm> (<*>) (<$) (guard . (==1)) 1 :: Maybe Integer
22:52:01 <ivanm> > (<*>) (<$) (guard . (==1)) 1 :: Maybe Integer
22:52:02 <lambdabot>   Just 1
22:52:22 <ivanm> OK, so what is it doing there?
22:52:26 <ivanm> @type (<*>)
22:52:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:52:35 <ivanm> @type (<$)
22:52:36 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
22:52:50 <ion> f <*> g $ x = f x (g x)
22:53:07 <ivanm> oh, like ap
22:53:27 <ion> x <$ f = const x <$> f
22:53:37 <ivanm> yeah, guessed that
22:53:44 <ivanm> @type (<*>) (<$)
22:53:45 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a -> f b) -> a -> f a
22:54:30 <ivanm> OK, I see how it does it.... but it looks like line noise :p
22:56:40 <ion> Not pointfree, but much clearer: \p x -> x <$ guard (p x)
22:57:10 <ivanm> @pl \ (a,b) -> f $ g b a
22:57:11 <lambdabot> uncurry ((f .) . flip g)
22:57:22 <ivanm> ^^ why does @pl put the "f ." inside the uncurry ?
22:57:28 <ivanm> ion: ta
22:58:41 <ion> The parameter to uncurry is the function \a b -> f (g b a)
22:58:49 <ion> Then uncurry uncurries it to be \(a,b) -> …
22:58:51 <ivanm> ahhh, right
23:04:31 <Axman6> >2^28
23:04:33 <Axman6> > 2^28
23:04:34 <lambdabot>   268435456
23:04:46 <Axman6> > 2^26
23:04:46 <lambdabot>   67108864
23:08:47 * hackagebot happstack-server 6.1.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.1.3 (JeremyShaw)
23:10:45 <fragamus> 9^9
23:11:19 <fragamus> >9^9
23:11:24 <tg_> need a space
23:11:26 <tg_> > 9^9
23:11:26 <lambdabot>   387420489
23:11:41 <fragamus> >9^9
23:11:46 <Axman6> > 2^24
23:11:46 <lambdabot>   16777216
23:11:50 <Axman6> > 2^25
23:11:51 <lambdabot>   33554432
23:11:52 <fragamus>  > 9^9
23:11:53 <Axman6> > 2^26
23:11:53 <lambdabot>   67108864
23:12:06 <fragamus>  > 9^9^9
23:12:24 <tg_> that's probably a little much
23:12:38 <Axman6> fragamus: "> expr"
23:12:44 <Axman6> > 1+1
23:12:45 <lambdabot>   2
23:12:46 <tg_> > 9^9^9
23:12:53 <tg_> she's dead, jim!
23:12:59 <lambdabot>   mueval: ExitFailure 1
23:12:59 <lambdabot>  mueval-core: Time limit exceeded
23:13:08 <fragamus> oh man
23:13:11 <tg_> that should be easy to calculate, though
23:13:18 <tg_> let me try mathematica :o
23:13:25 <fragamus> > 2 + 2
23:13:28 <lambdabot>   4
23:13:36 <tg_> nope
23:13:36 <Axman6> > 3^(3^3) == 3^3^3
23:13:37 <fragamus> see thats easier
23:13:37 <lambdabot>   True
23:13:46 <tg_> well
23:13:49 <tg_> > 9^9
23:13:50 <lambdabot>   387420489
23:13:53 <tg_> even squaring that
23:13:58 <tg_> > (9^9)^2
23:13:59 <lambdabot>   150094635296999121
23:14:02 <tg_> > (9^9)^3
23:14:02 <lambdabot>   58149737003040059690390169
23:14:14 <tg_> > (sqrt(-163))
23:14:15 <lambdabot>   NaN
23:14:19 <tg_> LIAR
23:14:37 <tg_> > (sqrt(-1))
23:14:38 <lambdabot>   NaN
23:14:39 <Axman6> > sqrt (-163 :+ 0)
23:14:40 <lambdabot>   Precedence parsing error
23:14:40 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
23:14:45 <Axman6> > sqrt ((-163) :+ 0)
23:14:46 <lambdabot>   0.0 :+ 12.767145334803704
23:14:54 <tg_> yeah, but that's still wrong
23:15:04 <Axman6> > (sqrt ((-163) :+ 0))^2
23:15:05 <lambdabot>   (-162.99999999999997) :+ 0.0
23:15:13 <Axman6> looks pretty right to me
23:15:20 <Axman6> > (sqrt ((-163 :: CReal) :+ 0))^2
23:15:21 <lambdabot>   (-163.0) :+ 0.0
23:15:34 <fragamus> > e^(pi * i)
23:15:37 <tg_> it's a number field, though, so you're missing a lot of information
23:15:38 <lambdabot>   mueval-core: Time limit exceeded
23:16:51 <fragamus>  :+   looks like a smiley
23:17:24 <tg_> with his nose punched in?
23:17:42 <fragamus> looks like he sucked a lemon
23:18:13 <tg_> i'm not a fan of any functions with :+ in them
23:18:18 <tg_> because : is a reserved key in vim :o
23:18:45 <fragamus> i love vim but now im using leksah
23:18:49 <Eduard_Munteanu> 'i' is one too...
23:19:33 <tg_> yeah, but I have a bad habit with :
23:19:43 <Axman6> Haskell2012: "We have removed all use of : and i in the language to aoid problems with vim. the new list constructor is now ~+~+"
23:19:55 <tg_> Axman6: upvote
23:20:30 <fragamus> fragamus: upvote
23:20:57 <Eduard_Munteanu> I don't think that works, I mean 'upvote'.
23:21:13 <Axman6> it doesn't
23:21:22 <Axman6> > 2^24
23:21:23 <lambdabot>   16777216
23:21:27 <fragamus> i dont know i feel different somehow
23:21:48 <tg_> lol
23:21:56 <tg_> probably because it's late, but that got a good laugh from me
23:22:00 <Eduard_Munteanu> Neither does patting yourself on the back :P
23:23:43 <tg_> byorgey: ping?
23:25:33 <fragamus> i have to say this channel rocks
23:25:58 <fragamus> i also have to say that the literature on haskell sucks
23:26:12 <tg_> gasp!
23:27:01 <fragamus> see isomorphic left because i said that
23:27:15 <fragamus> he probably wrote some literature
23:29:39 <Veinor> oh
23:29:41 <Veinor> it's fizzbuzz
23:29:43 <Veinor> http://hpaste.org/47121/derp
23:30:16 <tg_> Veinor: ...
23:30:29 <Veinor> (I didn't write it, wish I did)
23:31:19 <ivanm> wtf is that? :o
23:31:24 <monqy> fizzbuzz
23:31:46 <ivanm> I mean, a class called _Forty_ ? :o
23:32:15 * ivanm -> home
23:32:46 <tg_> ivan: it's a 40-dimension fizz-vector buzz-space
23:32:52 <tg_> s/dimension/dimensional/
23:33:29 <Jafet> And we will use that program to scare future newbies into upgrading their 6-series GHC.
23:34:37 <Eduard_Munteanu> Did type-level naturals make it in any GHC release yet?
23:35:05 <ddarius> :k 1
23:35:07 <lambdabot> *
23:35:15 <Veinor> Eduard_Munteanu: i don't think so
23:35:46 <Eduard_Munteanu> :(
23:35:56 <Jafet> "Milestone: 7.4.1"
23:36:22 <Eduard_Munteanu> So... maybe in a year or two? :P
23:36:52 <Jafet> Oh, who's counting?
23:37:03 * Eduard_Munteanu runs back in Agda's arms...
23:38:20 <Jafet> It would be nice if they made the hierarchy of Ordinal.
23:38:22 <fragamus> Eduard_Munteanu: I have to ask, since you know my monad transformer stack, does the "listness" apply only to the StateT or does it also apply to the RandT?
23:39:59 <Eduard_Munteanu> What was it again?
23:40:04 <fragamus> http://hpaste.org/47122/one_to_many
23:40:37 <fragamus> i want one creature to become many in that functor called schmany
23:41:25 <fragamus> i have standardized my nomenclature so that any monadic functor begins with sch
23:41:35 <fragamus> functor -> scmunctor
23:41:45 <fragamus> schmunctor
23:42:06 <Eduard_Munteanu> Mm, those are functions, what do you mean by functor there?
23:42:24 <fragamus> nvm
23:42:44 <Eduard_Munteanu> A functor is something of kind * -> *.
23:43:06 <fragamus> sorry i derailed the real discussion
23:44:11 <Eduard_Munteanu> As for the other thing, normally you don't need more than one occurence of a monad (transformer) in a stack.
23:44:30 <fragamus> i am trying to replicate a creature
23:45:02 <fragamus> so im not trying to add another monad (transformer)
23:46:27 <Veinor> oh look i've been given the source
23:46:29 <Veinor> http://sprunge.us/BFjU
23:48:29 <fragamus> so one creature goes in to schmany and many creatures are produced, each of which continues down the do chain
23:49:37 <Eduard_Munteanu> *sigh* so much harder to do that in Haskell
23:50:38 <Eduard_Munteanu> I guess I know why edwardk does this stuff :)
23:50:51 <fragamus> really? like i need explicit constructors
23:51:04 <Eduard_Munteanu> Wait, no, I was referring to what Veinor posted.
23:53:47 <tg_> does anyone have cabal options like Tests=True or Debugs=True or Docs=True set? Or do you just do them as needed?
