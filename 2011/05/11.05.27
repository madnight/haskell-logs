00:01:51 <fragamus> i tried to do it today using explicit constrictors but i cant figure out how to stack them.
00:02:11 <fragamus> or rather "nest" them
00:07:36 <roconnor> edwardk "functional imperative" is also the name of a talk I gave on Haskell and monads. :D
00:07:36 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:11:07 <roconnor> oh wait
00:11:17 <roconnor> mine was called "functional programming imperative"
00:11:31 <roconnor> http://r6.ca/Haskell/FPI.pdf
00:11:48 <roconnor> @tell edwardk http://r6.ca/Haskell/FPI.pdf
00:11:49 <lambdabot> Consider it noted.
00:22:14 <manju_> Sorry if this is a dumb question, but I have written this OpenGL program, which renders an haskell diagram to an OpenGL window. My Haskell foo is still weak and I can seem to figure out how to use = inside a do {...} ? Can anyone help ? http://hpaste.org/47123/using__in_do
00:22:26 <manju_> s/can/can't
00:22:51 <manju_> TexBind.hs:116:9: parse error on input `='
00:22:54 <manju_> I get this error
00:23:32 <manju_> In this main function I want to bind w and h to 100
00:23:57 <Axman6> use let
00:24:04 <reacocard> manju_: you need to use a let there, like you do in all he other funcs
00:24:05 <manju_> ah
00:25:04 <manju_> thank you
00:32:05 <manju_> Does anyone know how to convert GLsizei to Int ?
00:32:54 <manju_> type GLsizei = Int32
00:34:37 <fragamus> @type mapM_
00:34:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
01:05:36 <develhevel> can i make something like this: foo (x:xs) = x ++ if x == "a" then "aa" else "" ++ foo xs ?
01:06:21 <ziman> i'd consider concatMap for this purpose
01:06:44 <ibid>  yes you can.  you just need some parentheses
01:06:47 <ziman> (and probably the if-expression should be parenthesized)
01:07:26 <develhevel> what does parenth.. mean?
01:07:27 * hackagebot yesod-static 0.1.0.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.1.0.1 (MichaelSnoyman)
01:07:47 <ibid> develhevel: the parentheses are ( and )
01:09:05 <frerich> Hm, 'if' could be expressed as a function itself (Bool -> a -> a) instead of being a language construct, right? Just like in Tlc?
01:09:17 <frerich> @hoogle Bool-> a -> a
01:09:18 <lambdabot> Control.Exception assert :: Bool -> a -> a
01:09:18 <lambdabot> Control.OldException assert :: Bool -> a -> a
01:09:18 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
01:09:26 <develhevel> ibid: this helped :)
01:09:26 <ibid> frerich: yes
01:09:28 <c_wraith> yes.  it's rather annoying that if is a function
01:09:37 <c_wraith> @hoogle a -> a -> Bool -> a
01:09:37 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
01:09:38 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
01:09:38 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
01:09:47 <jlaire> @hoogle Bool -> a -> a -> a
01:09:47 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
01:09:47 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
01:09:47 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
01:09:51 <frerich> c_wraith: You mean, that if is *not* a function, right?
01:09:59 <c_wraith> uh, yes.  I do
01:10:13 <c_wraith> well, really, I meant, "It's annoying that if is syntax" :)
01:10:19 <c_wraith> but that's the same thing
01:10:20 * frerich nods
01:11:03 <c_wraith> I mean.  having if encourages beginners to write code like...
01:11:18 <c_wraith> :t \x -> if x == True then True else False
01:11:19 <lambdabot> Bool -> Bool
01:11:30 <c_wraith> I tell you, that's some brilliant code :)
01:12:07 <ion> @pl \x -> if x == True then True else False
01:12:07 <lambdabot> flip (flip if' True . (True ==)) False
01:12:08 <jlaire> > let if' cond t e = if cond then t else e in (\x -> if' (x == True) True False) True
01:12:09 <lambdabot>   True
01:12:09 <frerich> Maybe they didn't know about 'const x' but needed a function? :-)
01:12:21 <c_wraith> that's actually "id"
01:12:37 <c_wraith> except specialized to bools, and strict.
01:13:31 <shachaf> c_wraith: I'd be impressed if you provided an id that wasn't strict.
01:13:39 <osfameron> having a bit of syntax around 'if' makes it easier to scan, mentally
01:14:09 <c_wraith> shachaf: oh.  hmm.  right.
01:14:12 <c_wraith> good point
01:14:26 <fragamus> i seriously need help; i need to use replicateM_ but im missing something
01:14:40 <c_wraith> why do you need to use it?
01:14:42 <fragamus> schmany :: (RandomGen g) => RandT g (StateT Creature []) ()
01:15:01 <fragamus> schmany = ????
01:15:35 <c_wraith> That type doesn't look right.  You really want [] as the base of your transformer stack?
01:16:07 <fragamus> yes because one creature can become many
01:16:23 <c_wraith> that's...  not really what the [] monad does.
01:16:36 <c_wraith> It's more about treating lists as non-determinism
01:16:55 <fragamus> i used it successfully before
01:17:02 <fragamus> to do combinatorics
01:17:28 <fragamus> where I had states that could split into multiple states
01:17:40 <fragamus> and here i just want to replicate states
01:17:47 <strogers> anyone could help me?
01:18:19 <c_wraith> right..  I guess you mean "A monster could turn into one of many options" rather than "a monster could turn into multiple monsters"
01:18:33 <c_wraith> that's a hard distinction to quantify in english
01:18:34 <manju_> byorgey, I was successful in getting dia to render to an OpenGL texture :-)
01:19:21 <merijn> strogers: Well it would help if you stated what you want to be helped with...
01:19:22 <fragamus> yes
01:20:03 <fragamus> in this case a monster really will become many identical monsters
01:20:17 <fragamus> but then later they will specialize
01:20:29 <fragamus> into distinct individuals
01:20:48 <fragamus> or options as you say
01:20:59 <c_wraith> Well.  First off, does Creature have a Random instance?  I would assume it does.
01:21:48 <c_wraith> Actually, that's not the first question.  The first question should be "What part of this process is randomized?"
01:21:56 <fragamus> I'm not completely sure whether my code makes a Random Instance per creature but I am happy either way
01:22:39 <fragamus> If I can get replicateM to work it will be quickly evident
01:23:00 <c_wraith> I'm still unconvinced by this type signature.  It feels wrong.
01:23:14 <c_wraith> But really, what is it you wish to randomize?
01:23:21 <strogers> I'm writing this: http://hpaste.org/47127/sytnax but I'm blocked now
01:25:11 <fragamus> there are other functions that modify the state and they make use of the randomness
01:25:21 <c_wraith> I mean, the layers just feel strange.  Why do you want both randomness and non-determinism?  That doesn't seem right.
01:25:41 <c_wraith> Ah, so do you not actually need the randomness for this?
01:25:54 <fragamus> not just now
01:26:31 <c_wraith> But it still feels strange.  It seems like you want to split the state into multiple alternatives, where you've updated the current creature to be several different things.
01:26:48 <c_wraith> But with StateT on the outside, that's not what will happen.
01:27:50 <c_wraith> You'll generate a list of () values, but the state will execute for all of them, meaning the last one wins.
01:28:22 <fragamus> well lets accept the strangeness and just make replicateM_ work
01:28:31 <c_wraith> (since I'm assuming it doesn't look at the incoming state, and just sets it.  If it actually does look at the incoming state (say to evolve a monster) it will evolve it multiple times)
01:29:23 <c_wraith> The thing is, I think the whole model doesn't make any sense.  That's you're not seeing how to use replicateM_.  It just doesn't do something that makes sense.
01:29:35 <c_wraith> err, that's *why*
01:31:06 <c_wraith> well, anyway.  let's proceed a bit.  first, simplify things by stripping out the RandT layer.  Since you don't need it here, let's make things simpler.  schmany :: StateT Creature [] ()
01:31:24 <c_wraith> you can lift the result where you use it, if necessary
01:33:15 <c_wraith> schmany = replicateM_ 37 $ modify evolveCreature
01:34:00 <c_wraith> where evolveCreature :: Creature -> Creature ; evolveCreature = whatever
01:34:14 <fragamus> http://hpaste.org/47129/schmany_stub
01:34:23 <c_wraith> But that doesn't use the underlying list monad at all
01:34:35 <c_wraith> All it does is modify the state that many times
01:35:18 <fragamus> ok interesting
01:35:31 <fragamus> how would I fix that
01:35:50 <c_wraith> You have the stack backwards from what you want, I think.
01:36:09 <c_wraith> I think you *want* nondeterministic state modification.
01:37:16 <c_wraith> which would mean: ListT (State Creature) ()
01:37:46 <c_wraith> ...  Unfortunately, State is *not* commutative
01:37:49 <c_wraith> So that's not a monad
01:38:14 <c_wraith> LogicT might fix that.
01:38:32 <magicman> @unmtl ListT (State Int) String
01:38:32 <lambdabot> Int -> ([String], Int)
01:38:35 <fragamus> so can I use ListT (StateT (Itentity)) ()
01:39:15 <Axman6> assuming Itentity is Identity, then that's just ListT (State s) ()
01:39:29 <magicman> @unmtl StateT Int [] String
01:39:30 <fragamus> @unmtl (RandomGen g) => RandT g (StateT Creature []) ()
01:39:30 <lambdabot> Int -> [(String, Int)]
01:39:30 <lambdabot> err: Parse error
01:39:49 <fragamus> @unmtl RandT g (StateT Creature []) ()
01:39:49 <lambdabot> g -> Creature -> [((), g, Creature)]
01:39:57 <c_wraith> Ugh, did I get myself backwards again?
01:40:03 <c_wraith> heh.  unmtl is still broken.  nice
01:40:39 <c_wraith> for whatever reason, unmtl thinks ((a, b), c) and (a, (b, c)) should be written as (a, b, c)
01:41:45 <c_wraith> ok, yes.  I manage to get monad transformers backwards too much.
01:42:04 <c_wraith> StateT Creature [] () does what you want.
01:42:29 <fragamus> ok
01:42:40 <fragamus> http://hpaste.org/47129/schmany_stub
01:42:40 <hvr> does anyone know, where the current threadscope source code repository is?
01:42:41 <c_wraith> The thing is, I don't think you want replicateM_
01:42:54 <c_wraith> It will apply the state changes multiple time.
01:42:59 <c_wraith> err, multiple times.
01:43:04 <hvr> there was a darcs repo once, but I can't seem to find it
01:43:21 <c_wraith> You would want something like...
01:43:26 <fragamus> I want something that will make many identical copies
01:43:42 <fragamus> and then later they specialize
01:43:47 <c_wraith> I think you just want replicate
01:44:53 <hvr> JaffaCake: ...where can I find threadscope's darcs or git source code repo?
01:45:26 <c_wraith> schmany = do { c <- get ; c' <- lift $ replicate 5 (evolve c) ; put c' }
01:45:38 <c_wraith> or, more generally
01:45:51 <fragamus> well i do not wish to evolve the state at all at this point
01:46:01 <fragamus> i just want copies
01:46:16 <c_wraith> schmany = do { c <- get ; c' <- lift $ evolve c ; put c' } where evolve :: Creature -> [Creature] ; evolve = replicate 5
01:46:33 <fragamus> cool
01:46:35 <c_wraith> all of this is assuming you stripped off the RandT layer
01:46:50 <c_wraith> if you didn't, all of those would need another lift in front
01:46:51 <fragamus> ok
01:47:14 <fragamus> i didnt
01:49:42 <c_wraith> heh.  actually, simplest would be
01:49:49 <c_wraith> schmany = lift $ do { c <- get ; c' <- lift $ evolve c ; put c' } where evolve :: Creature -> [Creature] ; evolve = replicate 5
01:50:47 <JaffaCake> hvr: http://code.haskell.org/ThreadScope
01:51:00 <fragamus> cool i will try it
01:51:16 <fragamus> im reticent to take out my RandT though
01:51:53 <c_wraith> well, the last version, by putting that extra lift in the front, moves it into RandT
01:52:05 <c_wraith> just sort of as an afterthought
01:52:09 <fragamus> wow thats wild
01:52:44 <c_wraith> doing it like that makes it clear that the code doesn't really use the RandT layer
01:55:39 <fragamus> it compiled!
01:57:43 <fragamus> it runs but there is only one creature in the output
01:58:00 <c_wraith> oh
01:58:08 <c_wraith> yes, there would be
01:58:16 <c_wraith> the state only holds one creatue
01:59:32 <fragamus> no
01:59:43 <c_wraith> the list there models non-determinism, not a set of creatures
02:00:03 <fragamus> the list thingy works I tried it before with my combinatorics application
02:00:41 <c_wraith> (StateT Creature)
02:00:52 <c_wraith> The state portion can only hold a single Creature
02:01:28 <c_wraith> and, in fact, must hold exactly 1 creature
02:01:49 <fragamus> ok I guess I have to change my monad stack
02:02:02 <c_wraith> Do you want non-determinism?
02:02:35 <fragamus> lemme think about the difference
02:03:09 <c_wraith> I suspect you might just want RandT g (State [Creature])
02:04:40 <fragamus> pondering...
02:05:17 <fragamus> so what i used befoer for combinatorics was a good fit for nondeterminism...
02:05:56 <fragamus> but it did result in a list of states
02:08:19 <augur> strogers: you can try
02:09:06 <fragamus> i really have to think this over. You have made me doubt what I thought I knew.
02:09:29 <c_wraith> :t \f fi action -> do { s <- get ; let (a, s') = runState action $ f s ; put $ fi s' ; return a }
02:09:30 <lambdabot> parse error on input `;'
02:09:51 <c_wraith> heh.  woo, parsing rules that don't work like I think they should!
02:09:57 <hvr> JaffaCake: thx... for some reason I didn't recognize it as a darc-repo when I went there with my web-browser
02:10:03 <c_wraith> :t \f fi action -> do { s <- get ; let { (a, s') = runState action $ f s } ; put $ fi s' ; return a }
02:10:04 <lambdabot> forall s a a1 (m :: * -> *). (MonadState s m) => (s -> a) -> (a -> s) -> State a a1 -> m a1
02:10:22 <JaffaCake> hvr: I think it has an index.html to confuse you
02:11:15 <hvr> JaffaCake: indeed :-) wasn't expecting that
02:11:44 <hvr> JaffaCake: is a new threadscope release on the horizon? I see the version was bumped recently
02:12:34 <JaffaCake> hvr: yes it is
02:12:50 <develhevel> when i work with case .. of, is it possible to make something like: otherwise when no case match?
02:12:53 <JaffaCake> hvr: dcoutts has been busy refactoring, improving the layout and generally polishing
02:13:09 <mauke> develhevel: _
02:13:10 <hvr> looks great...
02:13:35 * hackagebot syb 0.3.2 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.3.2 (JosePedroMagalhaes)
02:13:54 <hvr> dcoutts did a great job
02:14:23 <dcoutts> :-)
02:14:44 <Axman6> develhevel: you can actually use 'otherwise' in that case, but it's a bit misleading in that it bings the name 'otherwise' to the value of the expression you're testing
02:14:46 <hvr> dcoutts: hi... btw, is it easy to add a few keyboard shortcuts such as 'ctrl-q' for exiting the application?
02:14:59 <hvr> for us xmonad/keyboard users =)
02:15:00 <dcoutts> hvr: should be, yes
02:15:10 * dcoutts wants crl-r for reload
02:15:21 <Axman6> > case 4 of 3 -> "oh no D:"; otherwise -> "default!"
02:15:22 <lambdabot>   "default!"
02:15:57 <Veinor> > otherwise == True
02:15:58 <lambdabot>   True
02:16:17 <Axman6> > case 4 of otherwise -> otherwise
02:16:17 <lambdabot>   4
02:16:27 <develhevel> Axman6: yes ok, i will use _ like mauke says
02:16:36 <Axman6> good plan ;)
02:16:56 <Axman6> is anyone else getting pm's from strogers?
02:17:18 <Axman6> he's refusing to ask his question in here and wants help in private
02:17:56 <shachaf> Axman6: Didn't they ever tell you not to talk to strogers?
02:18:10 <mauke> :-)
02:19:18 <Axman6> apparently not
02:25:39 <magicman> @hoogle (a -> Maybe a) -> a -> a
02:25:39 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
02:25:39 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
02:25:39 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
02:26:21 <magicman> @type \f a -> fromMaybe a (f a)
02:26:22 <lambdabot> forall a. (a -> Maybe a) -> a -> a
02:26:45 <mauke> @djinn (a -> Maybe a) -> a -> a
02:26:46 <lambdabot> f a b =
02:26:46 <lambdabot>     case a b of
02:26:46 <lambdabot>     Nothing -> b
02:26:46 <lambdabot>     Just c -> c
02:27:21 <magicman> Ooh.
02:27:41 <magicman> I'd expected it to give \a b -> b, or something.
02:27:48 <magicman> It does something smart with using parameters?
02:34:30 <Cale> magicman: It tries to use all the parameters you give it, somewhat.
02:35:38 <magicman> And bound variables from patterns, too. Quite neat. *approves*
02:43:29 <maus> Hi, then I run cabal update, I get "cabal: does not exist" message. Any ideas?
02:44:12 <dcoutts> maus: does running with -v3 give any more info?
02:44:51 <maus> dcoutts, it does!Thanks, looks like I misconfigured my proxy. Sorry for noise
02:45:21 <maus> I tried -v before, but it didn't show anything interesting
02:46:22 <dcoutts> maus: so any idea what it is that does not exist? :-)
02:46:34 <dcoutts> we should try and make that error more helpful
02:46:41 <dcoutts> error message I mean
02:48:01 <maus> dcoutts, absolutely no ideas :) I thought about some missing files or web server responding 404 or so..
02:48:45 <dcoutts> maus: did you have a wrong HTTP_PROXY env var or something?
02:49:15 <dcoutts> maus: do you still have the log from the update -v3? I might be able to work it out
02:49:53 <maus> yeah, my proxy changed the address
02:49:58 <maus> -v3 was very informative
02:50:09 <shachaf> dcoutts++ for reacting to errors like that.
02:50:39 <dcoutts> maus: do you still have it? It might give me a clue about what the source of the exception was.
02:51:09 <maus> dcoutts, a minute
02:51:16 <dcoutts> ta
02:53:07 <Axman6> does anyone else really dislike the name yesod?
02:54:35 <osfameron> ooo, Snap looks nice
02:54:44 <shachaf> Axman6: What do you dislike about it?
02:54:47 <osfameron> Axman6: I was vaguely put off by the Cabalistic/religious overtones
02:55:02 <osfameron> but I understand it translates as "foundation" or something? which sounds quite reasonable
02:55:05 <Axman6> i just think it's a horrible name
02:55:12 <maus> dcoutts, http://hpaste.org/47130/cabal_reaction_on_an_incorrect
02:55:22 <Axman6> I've never seen where the name came from though
02:56:03 <dcoutts> maus: ta
02:56:03 <shachaf> Axman6: It means "foundation" in Hebrew.
02:56:15 <Axman6> i see
02:56:40 * maus feels uneasy about that religious context too
02:56:54 <Veinor> http://upload.wikimedia.org/wikipedia/commons/f/f9/There%27s_no_cabal.png
02:56:57 <shachaf> maus: I don't think it's religious.
02:58:16 <shachaf> Admittedly the Wikipedia entry is, but that's just because religion tends to care enough to transliterate names.
02:59:24 <osfameron> true.  If you google "monad", that has Gnostic religious significance too (but also other meanings)
02:59:33 <maus> shachaf, what's about other names inside the package? I find some of them pretty strange too. I'm not sure about the genesis, though.
02:59:49 <shachaf> What other names?
03:00:21 <maus> dsls for css and js, for example
03:00:47 <shachaf> What are they?
03:00:53 * shachaf doesn't actually know anything about Yesod.
03:00:53 <Axman6> every time i see the word yesod, i immediately try and figure out what it means: "Yet another ... shitty ... enterprise ... development?"
03:01:03 <osfameron> heh
03:01:06 <hepek> did anyone notice that Repa.IO.BMP writeImageToBMP doesn't work (or am I missing something)
03:01:13 <mauke> Axman6: it's dosey backwards
03:01:32 <shachaf> Axman6: Would יסוד be better?
03:01:41 <Axman6> i think that's why it annoys me, I've never likes the yet another foo bar baz naming of programs
03:01:44 <shachaf> Hmm, my terminal renders that left-to-right.
03:02:03 <hepek> if you open readImageFromBMP and then save the same thing back using write it saves rotated image
03:02:14 * Axman6 is aware that e is not the same as a btw
03:02:47 <Cale> osfameron: But CT 'monad' has different etymology than religious or philosophical 'monad'
03:02:50 <shachaf> maus: Ah, "Hamlet", "Julius", "Cassius"?
03:03:12 <Cale> osfameron: 'monad' in CT was constructed as a portmanteau of monoid and triad
03:03:16 <maus> shachaf, yeah, couldn't find how to spell them
03:03:29 <shachaf> Well, "Hamlet" is a reference to "HAML".
03:03:32 <osfameron> Cale: oh!  didn't realise that.
03:03:59 <Cale> (triad being one of the earlier names for monad, and monoid being a closely related concept)
03:04:01 <osfameron> ... of course I thought a triad was an east-Asian gang-member
03:04:30 <Cale> They were called triples or triads or "the standard construction" a lot before anyone came up with a decent name for them
03:04:47 <Cale> Because a monad is defined as (T,eta,mu)
03:04:54 <osfameron> why triples?  value/function/next context ?
03:04:54 <Cale> (satisfying some conditions :)
03:05:15 <Cale> The functor itself, and then return and join, in Haskell terms
03:05:30 <osfameron> ah, ok
03:06:00 <osfameron> and the name "monad" emphasizes the unity of those 3 things, rather than their three-ness ?
03:07:03 <shachaf> osfameron: Don't bring the religion back into it.
03:07:59 <osfameron> heh
03:08:08 <osfameron> I'm just wondering about the naming
03:08:31 <Cale> Well, it emphasises their monoid-like-ness more
03:09:11 <Cale> A monoid is classically a set together with an operation (called multiplication) that is associative and has an identity element (which is where the mon- comes from)
03:10:00 <Cale> So this means we have some maps:
03:10:02 * osfameron doesn't see the clear connection between monoid and monad tbh
03:10:25 <Cale> eta: 1 -> M -- where 1 is a one-element set, this function picks out the identity for the multiplication
03:10:26 <Cale> and
03:10:33 <Cale> mu: M^2 -> M
03:10:36 <Cale> the multiplication itself
03:10:51 <Cale> Compare this with the case of a monad where we have:
03:11:03 <Cale> return :: a -> M a
03:11:09 <Cale> join :: M (M a) -> M a
03:11:55 * osfameron sees Monoids as being more about addition/concatenation than multiplication... is that the wrong way to look at it?
03:12:15 <Cale> Well, addition and concatenation are examples of multiplications ;)
03:12:21 <mauke> addition and multiplication are the same thing
03:12:31 <mauke> monoids don't even commute
03:12:31 <Cale> For this purpose :)
03:12:52 <Cale> When we choose to use additive notation, we usually want commutativity
03:13:04 <Cale> That is, we usually expect a + b = b + a
03:13:13 <Cale> but we don't expect that of multiplication, necessarily
03:14:43 <osfameron> indeed.  as Lists are monoids, concatenation isn't commutative
03:15:24 <osfameron> I don't understand your 1->M and M^2->M notation
03:15:43 <Cale> Oh, well, 1 is a one element set
03:15:50 <Cale> and M^2 is the set of pairs of elements of M
03:16:02 <Cale> M is the set of elements of our monoid
03:16:05 <shachaf> Cale: Why 1 -> M and not just M?
03:16:16 <Cale> Because I want to make a comparison :)
03:16:22 <Cale> between monads and monoids
03:16:31 <Cale> and turning elements into arrows is important for that
03:16:57 <Cale> each function  1 -> M  is uniquely determined by an element of M of course though
03:17:18 <osfameron> so what does your eta:1 -> M  function correspond to with a Monoid in Haskell?
03:17:34 <Cale> (in some particularly category-theoretic presentations of set theory, the elements of M are defined to be the arrows 1 -> M)
03:17:43 <Cale> return :: a -> M a
03:17:46 <albel727> a stupid question from a haskell newb (I'm not even sure I'm asking the question correctly). suppose there's an instance of complex type, that has some problems with Show. I.e show <var> in ghci errors out with "No instance for (Show <complex type here>)". Is there some other command I can use to view the instance nevertheless?
03:18:17 <Cale> albel727: You can derive or write an instance for Show
03:18:28 <Cale> data MyDataType ...
03:18:32 <Cale>   deriving (Show)
03:18:43 <shachaf> If the type contains e.g. functions, you can't derive Show, though.
03:19:01 <osfameron> Cale: though Monoid doesn't have 'return' does it?
03:19:11 <Cale> osfameron: It has a unit for the multiplication
03:19:14 <albel727> Cale: you mean, I have to modify the type I want to show? problem is, it's not mine. it's from a compiled lib.
03:19:28 <Cale> osfameron: note that multiplication corresponds to join
03:19:42 <merijn> albel727: You can specify it to be an instance of show outside of the library it is defined in, if you know what you want to display
03:19:46 <Cale> osfameron: The correspondence isn't *quite* straightforward though.
03:20:19 <albel727> merijn: the problem is I don't know what I want to show. I have no idea what this type contains.
03:20:21 <osfameron> Cale: from http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html for example, I don't see a unit/return
03:20:21 <merijn> albel727: What Cale suggested is easier/less work but requires changing the original. If that's not an option making it an instance of Show is still possible, though
03:20:35 <osfameron> unless that's mempty?
03:20:43 <Cale> osfameron: In that we've replaced Cartesian product in MxM -> M in the case of monoids with composition of functors: M (M a) -> M a in the case of monads
03:21:06 <Cale> osfameron: You see mempty
03:21:08 <merijn> albel727: If the module doesn't export anything about the type, then it is probably meant to be opaque as an abstraction. Can you be more specific about which library, doing what and what you want to know?
03:21:08 <Cale> yeah
03:21:46 <albel727> merijn: the lib is XMonad. I wanna look at what default layoutHook contains.
03:21:50 <osfameron> ah ok, so that was what shachaf meant about eta being "M" instead of "1 -> M"
03:21:57 <Cale> yeah
03:21:58 <osfameron> as mempty is really just a value in M
03:22:17 <Cale> Yeah, but category theory doesn't ever talk about 'values' on that level :)
03:22:34 <Cale> It's only concerned with the objects as a whole, and the mappings between them
03:22:41 <Cale> (so the types and functions, but not their values)
03:22:44 <merijn> albel727: Ah, yeah. XMonad uses a lot of opaque types for encapsulation/abstraction. I think the best way to figure it out would be to look at the source
03:22:55 <merijn> (or ask in #xmonad)
03:22:59 <mauke> albel727: isn't that clear from the type?
03:23:18 <albel727> merijn: that's what I thought too. I'm extracting the source right now. sorry for bothering you and thanks.
03:23:27 <merijn> albel727: Don't worry :)
03:24:21 <albel727> mauke: not exactly. Tall layout has some kind of numeric parameters, which can't be determined from :type defaultConfig
03:24:40 <Cale> I was going to say that you can also look at the source from the Haddock documentation on hackage, but it seems like you can't for some reason
03:24:43 <mauke> albel727: and?
03:25:06 <albel727> mauke: and I want to know them somehow, obviously.
03:25:51 <mauke> 1 0.5 0.03
03:26:02 <mauke> oops
03:26:07 <mauke> Tall 1 0.03 0.5
03:26:12 <albel727> mauke: thanks, but I'm more interested in how did you learn that. )
03:26:23 <Cale> osfameron: If you want, I can be more precise about the connection, at the expense of introducing a few more concepts :)
03:26:25 <mauke> looked at the source
03:26:30 <albel727> meh
03:26:36 <albel727> that's what I was going to do )
03:26:51 <albel727> I was wondering, is there a way to find this out without looking at source.
03:27:11 <osfameron> Cale: in general, I would settle for an intuitive, and imprecise explanation ;-)  (possibly with concrete examples)
03:27:37 <osfameron> Cale: I'm having trouble seeing return==mempty, never mind join==mconcat
03:27:39 <mauke> albel727: http://xmonad.org/xmonad-docs/xmonad/XMonad-Layout.html#t%3ATall
03:28:09 <Cale> osfameron: Well, they're not meant to be *equal*, these are two different specialisations of something more general
03:28:18 <Cale> But...
03:28:25 <Cale> Look at the general shape of the types:
03:28:31 <albel727> mauke: ok. let me be more specific. is there a way to learn that from ghci (as opposed to looking at source and reading docs)? =)
03:28:44 <Cale> unit :: 1 -> M
03:28:48 <Cale> return :: a -> M a
03:28:52 <Cale> and
03:29:00 <Cale> multiplication :: M x M -> M
03:29:06 <Cale> join :: M (M a) -> M a
03:29:17 <Cale> Count the M's on either side of the arrows ;)
03:29:30 <mauke> albel727: yes
03:29:48 * shachaf notes how mathematically precise "Count the M's" is. :-)
03:29:56 <mauke> albel727: contrary to your claims there is a Show instance
03:30:40 <albel727> mauke: hmm. show defaultConfig didn't work for me. what can I be missing?
03:31:02 <Cale> Well, the correspondence is really a lot deeper once you start considering the laws that these things satisfy and the diagrams you'd have to draw to express them :)
03:31:15 <mauke> albel727: that you don't want to see the entire config, which is impossible anyway as it contains functions
03:31:23 <mauke> albel727: try 'layoutHook defaultConfig'
03:31:48 <osfameron> ah, mappend rather than mconcat
03:33:04 <osfameron> Cale: ok, M counts add up ;-)  but isn't M x M rather different from M(M) ?
03:33:19 <Cale> yes, but not so different that we can't formalise a connection between these ideas
03:33:36 <Cale> The laws which are satisfied turn out to be identical, even. :)
03:34:38 <mauke> M . M $ a
03:34:43 <albel727> mauke: as fun would have it, I have tried "show layoutHook defaultConfig" before. but I forgot braces (facepalm). show (layoutHook defaultConfig) worked. thanks.
03:34:53 <mauke> albel727: you don't need 'show'
03:34:58 <mauke> albel727: try 'layoutHook defaultConfig'
03:35:02 <albel727> trying...
03:35:20 <albel727> worked
03:35:34 <shachaf> Cale: Monad would seem to have more laws than Monoid?
03:35:43 <Cale> shachaf: nope
03:35:55 * albel727 has a long way to go
03:36:04 <Cale> shachaf: left and right unit, and associativity :)
03:36:09 <shachaf> Cale: Oh, right.
03:43:58 <merijn> albel727: ghci defaults to show-ing any expression you enter in it :)
03:44:35 <poltak> Is BB code consider of programming language?
03:44:43 <poltak> (As in forum tagging)
03:44:49 <albel727> merijn: yeah, I figured =) in the retrospect, it was so obvious, that I can only facepalm about me not realizing it.
03:45:05 <merijn> albel727: Also useful to know (if you are allergic to parentheses, like me): "show $ layoutHook defaultConfig" is identical to "show (layoutHook defaultConfig)"
03:45:07 <parcs> no it's markup language like html
03:45:31 <merijn> Depends on your definition of a programming language, I suppose
03:46:28 * osfameron wishes ghci could show function bodies...
03:46:43 <osfameron> (though I suppose, given composition and partial application, that may be tricky to do in general case)
03:47:12 <osfameron> that said, if any language can do tricky, haskell ought to be able to ;-)
03:48:26 <osfameron> Cale: so monoid/monad are similar in that they have left/right unit, and associativity.  Monoid doesn't do the nested binding that Monad does though
03:49:14 <Cale> osfameron: When you write the laws out in just the right way, they look exactly the same
03:49:33 <albel727> merijn: no, I'm fond enough of braces =) but $ operator is interesting, and I'm willing to learn haskell deeper (I've been meaning to for a long time)
03:49:37 <merijn> osfameron: Couldn't partial application/composition just be done with judicious adding of lambda constructs? (Although that wouldn't make it clearer)
03:50:04 * osfameron discovers the repo for typeclassopedia!  Yay, perhaps I can turn the sources into something readable on a kindle
03:50:31 <Cale> osfameron: http://en.wikipedia.org/wiki/Monoid_object
03:50:40 <Cale> osfameron: If you look at the diagrams there
03:50:48 <Cale> (with the polygons of arrows)
03:50:56 * osfameron panics
03:51:13 <hepek> anybody familiar with Repa.IO.BMP ?
03:51:45 <osfameron> merijn: arguably show (foo . bar) should be "foo . bar"
03:51:59 <Cale> The idea is that in the case of monoids, each of the ⊗ is replaced by Cartesian product and the I with a one-element set
03:52:18 <Cale> and in the case of monads, the ⊗ is composition of functors, and I is the identity functor
03:52:27 <osfameron> Cale: my term is rendering that as ?JW :-(
03:52:31 <Cale> oh
03:52:36 <Cale> It's a circled times
03:52:37 * osfameron was sure he had utf8 setup
03:52:38 <osfameron> ok
03:52:56 <merijn> albel727: Basically the implementation is: "f $ x = f x" but because $ is infix it has lower priority then function application and it is right associative causing "f $ g $ x" to become "f (g(x))" rather then "(f (g)) x"
03:53:10 <maus> another cabal related trouble: http://hpaste.org/47131/cabal_internal_error
03:53:39 <mauke> osfameron: what do you see here: ä
03:53:41 <dcoutts> maus: cabal --version ?
03:53:51 <osfameron> mauke: that's an umlauted a
03:53:58 <mauke> correct
03:54:10 * osfameron copies some русский
03:54:17 <osfameron> nope, that's mostly broken too :-(
03:54:26 <Cale> Shows up okay here though
03:54:26 <osfameron> never mind, I'll fix that later (again)
03:54:35 <maus> cabal-install version 0.8.0 <cr> using version 1.8.0.2 of the Cabal library
03:54:45 <maus> ghc-6.12.3
03:55:01 <dcoutts> maus: ok, use version 0.10.x, it understands packages with intra-package deps
03:55:53 <Cale> cabal install cabal-install :)
03:56:08 <Cale> Hey, does anyone know what happened to the Frown parser generator?
03:56:46 <osfameron> ok, I can see how those diagrams relate to the rules.  (not sure what all the greek symbols annotating the arrows mean, but guess it's not that important?)
03:56:47 <dcoutts> Cale: yes, I've been trying to persuade one of Ralph's current PhD students to resurrect it.
03:57:00 <maus> dcoutts, I'm on ubuntu-11.04, is there a binary package for it?
03:57:15 <Cale> dcoutts: So it's not online anywhere anymore?
03:57:20 <dcoutts> Cale: and it looks like he will, once he's passed his transfer
03:57:45 <dcoutts> Cale: you might be able to find bits in web archives here or there. There's no home page.
03:58:00 <albel727> merijn: wow. that's the cleanest explanation of that operator of all that I've seen. I've started reading all the tutorials from haskell meta just today, but haven't encountered a proper expalantion for why would anyone use $. thanks.
03:58:37 <Cale> Okay, it's just that someone was asking (in PM) about generating LALR(1) parsers in Haskell.
03:59:00 <Cale> I think they can get away with another style of parser generator though. :)
03:59:40 <dcoutts> Cale: found it on a gentoo mirror: /usr/portage/dev-haskell/frown/frown-0.6.1-r1.ebuild
03:59:45 <dcoutts> doh
03:59:50 <dcoutts> wrong url...
03:59:56 <dcoutts> http://gentoo.virginmedia.com/distfiles/frown-0.6.1.tar.gz
04:00:08 <merijn> albel727: Skip anything else and go directly to Learn You a Haskell, it is the most excellent complete newbie intro :)
04:00:10 <magicman> Hrm. I can see how functor composition can be a coproduct (haven't done the uniqueness proof yet), but not if it's a product, like in the MxM -> M rule.
04:01:06 <albel727> merijn: as fun would have it, LYAH is next in my list. =)
04:01:54 <Cale> magicman: It's a good enough product to make the category of endofunctors into a monoidal category
04:02:00 <magicman> Fair enough.
04:04:40 <maus> dcoutts, cabal-0.10 is happily building leksah now. Thanks!
04:04:49 <dcoutts> great
04:12:18 <Cale> osfameron: Oh, I missed one line of what you said somehow... the greek symbols are just names for the relevant operations
04:12:37 <Cale> osfameron: eta is return/unit and mu is join/multiplication
04:12:41 <osfameron> Cale: yeah, that makes sense
04:12:48 <osfameron> I should probably learn the names of the letters...
04:12:55 <Cale> osfameron: alpha here is the associativity of Cartesian product/composition
04:14:18 <Cale> and lambda/rho are the left and right identities (in the case of Cartesian product, the isomorphism 1 x M -> M or M x 1 -> M)
04:15:27 <osfameron> is lambda as left-identity related to lambda as function abstraction?
04:22:22 <Cale> no
04:22:37 <Cale> (it's just lambda for left)
04:22:52 <Cale> and rho for right :)
04:23:14 <osfameron> fair enough
04:24:28 <Cale> http://en.wikipedia.org/wiki/Exponential_object -- for the functional programming sort of lambda (sort of)
04:25:48 * hackagebot persistent 0.5.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.5.1 (MichaelSnoyman)
04:25:50 * hackagebot persistent-template 0.5.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.5.1 (MichaelSnoyman)
04:30:52 * hackagebot wai-handler-launch 0.0.0 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-0.0.0 (MichaelSnoyman)
04:49:20 <roconnor> Cale: dolio and I (or at least I do) have a new request for Caleskell: make the type of main into IO Void.
04:51:10 <Cale> roconnor: I don't see how I can do that in L.hs
04:51:39 <roconnor> Cale: you are only writing a new Prelude, not a new Haskell report?
04:53:44 <Cale> I'm not writing either
04:56:29 <Cale> Though, I have my own laundry list of suggestions
04:57:19 <Cale> I don't see any problem with the current way that main is allowed to have type IO A for any type A.
04:58:00 <Cale> I think maybe we could make use of the case where it has some special types. IO Int in particular could be interpreted as resulting in an exit code.
04:58:08 <roconnor> with IO Void main programs will necessarily be "terminated" correctly by calling System.Exit.exitWith, or calling forever, or some such thing.
04:58:31 <dankna> I actually like that it's IO ()
04:58:41 <Cale> It's actually not IO ()
04:58:42 <dankna> I think it's entirely appropriate that the existence of exit codes is treated as something special
04:58:49 <dankna> ah, yes, hm
04:58:52 <dankna> well, it should be! :)
04:58:59 <Cale> It just *can* be IO () :)
04:59:21 <dankna> roconnor: or of course you could return undefined, so it doesn't really achieve the goal
04:59:23 <Cale> and if you want to give it type IO Void, that's fine too at present
04:59:29 <ben> The intention behind IO Void would be that Void does not have any values?
04:59:49 <dankna> yes
04:59:54 <roconnor> dankna: you can end you program with return undefined if you want to have you program crash with an error: undefined exception.
04:59:58 <Cale> yeah, so the program would be forced to run forever, or else return undefined, or call exitWith
05:00:19 <Cale> roconnor: Except that it would never do that...
05:00:44 <Cale> roconnor: Because whatever is supposed to be interpreting the IO Void is not going to evaluate the result :P
05:01:00 <Cale> (or is it?)
05:01:07 <roconnor> Cale: depends on if the implementation does case void of {}
05:01:12 <Cale> yeah
05:01:54 <hpc> i would rather main remain IO ()
05:02:15 <hpc> it makes main the same type as other actions
05:02:17 <Cale> I think that forkIO should have type  IO a -> IO ThreadId
05:02:26 <hpc> :t forkIO
05:02:27 <lambdabot> Not in scope: `forkIO'
05:02:34 <ben> IO () -> IO ThreadId
05:02:34 <Cale> :t Control.Concurrent.forkIO
05:02:35 <lambdabot> IO () -> IO GHC.Conc.ThreadId
05:02:49 <parcs> heh
05:02:49 <shachaf> The behavior of runghc with main :: IO a where a is in Show but not () is particularly annoying.
05:02:57 <roconnor> The theory for the free monad model of IO work out a lot better with IO Void
05:02:57 <Cale> Be generous in what you accept and precise in what you produce.
05:03:04 <parcs> main :: IO Int; main = return $ fix (+1) terminates
05:03:17 <ben> I do not know that I want main = print whatever to be a type error
05:03:23 <roconnor> probably forkIO should have type IO Void -> IO ThreadId, but I haven't worked out concurency yet.
05:03:33 <dankna> I don't actually like the "be generouns in what you accept" part of that
05:03:37 <dankna> it's sometimes a necessary compromise
05:03:41 <dankna> but should not be done for new systems
05:04:02 <Cale> Well, when it comes to talking about polymorphism, it makes a lot of sense
05:04:22 <dankna> okay
05:04:23 <roconnor> ben: your program should be print whatever >> exitWith ExitSuccess
05:04:41 <dankna> or of course there's the Elmer Season candidate, main :: IO ExitCode
05:04:42 <Cale> In general, it's nice to have functions which produce things of type which is concrete as possible, and accept things with type as polymorphic as possible.
05:05:20 <Cale> There are places where you're going to be backwards from that, but generally that's a good plan.
05:05:37 <ben> roconnor: I don't have to do that in C++!
05:07:30 <roconnor> ben: I'm not sure holding up C is the best example of langauge design :D
05:09:31 <aninhumer> Hmm print has return type IO (), why wouldn't 'main = print "whatever"' work?
05:09:37 <roconnor> right now the RTS is implicitly adding an >> exitWith ExitSuccess to all main programs
05:10:02 <roconnor> aninhumer: I'm proposing requifing the type of main to be IO Void
05:10:02 <ben> aninhumer: It works right now, but it would not work if main had to have type IO Void, ie. call exitWith at the end
05:10:07 <roconnor> *requiring
05:10:12 <luite> is there a good way (on linux) to limit the number of forks a process can do, and to collect the pids of all newly created processes?
05:10:29 <ben> ulimit does the former I believe
05:10:41 <shachaf> luite: Limit as in quota, or limit as in something the process does?
05:10:48 <flux> the latter could be implemented with ptrace, but that's hardly a good way
05:10:51 <luite> ben: there doesn't seem to be an option for it
05:11:28 <luite> shachaf: limit a single process. I have another process that starts the program, that could do things to set or enforce the limits
05:11:34 <shachaf> luite: ulimit lets you limit the number of processes a particular user has.
05:12:07 <aninhumer> Hmm, what exactly is Void, and why would that be different/better than ()?
05:12:11 <luite> shachaf: yes but I don't want to set it for a user, but for a process
05:12:21 <dankna> in general that's a hard restriction for the kernel to enforce - on each fork() it would have to check against the restrictions of every parent in the chain
05:12:21 <shachaf> aninhumer: Void is uninhabited.
05:12:24 <roconnor> aninhumer: Void is the type with no constuctors
05:12:25 <flux> hmm, I don't think ulimit limits per user, rather per session?
05:12:39 <dankna> which is potentially a very large number; you could DoS the kernel even if you couldn't fork-bomb
05:12:50 <roconnor> aninhumer: it would mean all programs "end" properly without dangling data.
05:13:01 <roconnor> aninhumer: and by "end" I also mean run forever.
05:13:37 <shachaf> flux: Oh, yes, it's per session.
05:13:45 <shachaf> OK, then that should work.
05:13:56 <luite> shachaf: I want something that looks like > createProcess "myProgram" { max_forks = 3, fork_callback = somefun }
05:14:02 <roconnor> aninhumer: at the moment my proposal is more of a theoretical nicity IMHO rather than solving any particular problem.
05:14:05 <shachaf> Oh, wait, it's not per-session.
05:14:06 <luite> where somefun receives the pids of the forked processes
05:14:33 <shachaf> luite: You could wrap around fork(), I guess.
05:14:48 <dankna> luite: I just explained why the kernel can't provide those semantics.  why do you not have control of the processes you are running?  are you a shell?
05:15:17 <luite> dankna: oh sorry missed your message
05:15:26 <shachaf> luite: Should be possible with ptrace.
05:15:51 <luite> shachaf: yeah that's what I found out, seems relatively complicated to implement though, and perhaps not efficient
05:16:10 <dankna> in highschool, by the way, I thought to myself "hmm...  I wonder how the system defends itself against users who write programs that fork() endlessly..."
05:16:11 <shachaf> luite: Right on both, probably.
05:16:16 <manju_> byorgey, ?
05:16:20 <dankna> almost lost my server privileges, hahaha
05:16:26 <luite> dankna: hehe
05:16:28 <aninhumer> roconnor: In that programs would have to explicitly quit, instead of implicitly after main returns?
05:16:31 <dankna> (answer: it has no such defense, of course)
05:16:36 <roconnor> aninhumer: yes
05:16:48 <shachaf> luite: Well, it's probably not *that* complicated and probably not *that* inefficient, depending on how much you're forking.
05:17:07 <shachaf> luite: You could make a new user for this process and give the top parent a ulimit.
05:17:35 <luite> shachaf: nah then I'd have to make new users for http requests, doesn't sound like a good security model ;)
05:17:35 <dankna> you could attach to your child as the debugger
05:17:45 <dankna> and install a breakpoint on fork()
05:17:52 <dankna> (note: not easy)
05:18:06 <dankna> and secretly call your own wrapper function instead that enforces the security restriction
05:18:09 <mauke> LD_PRELOAD
05:18:41 <dankna> hm, yes, but LD_PRELOAD won't protect you against the child calling the kernel fork() instead of the libc() one
05:18:46 <dankna> er
05:18:52 <dankna> s/libc()/libc/
05:19:28 <shachaf> That was my suggestion with ptrace.
05:19:33 <shachaf> It's not *that* difficult.
05:19:33 <dankna> right, okay
05:19:58 <shachaf> Oh, is this your Haskell Wolf thingy?
05:20:02 <luite> dankna: anway the issue is for wolfgang, where the user can evaluate haskell code on the web. some haskell code can call external programs. I kill the haskell process if it doesn't produce a proper response within the allotted time, but some programs may fork other processes internally (for example vacuum uses graphviz dot)
05:20:07 <luite> shachaf: yar
05:20:25 <luite> dankna: and I want some protection against those forked off processes spinning out of control
05:20:26 <dankna> luite: hmmmmmm.....  but you aren't allowing /arbitrary/ external programs, are you?
05:20:33 <luite> dankna: no :)
05:20:39 <shachaf> luite: Just don't let the Haskell programs run things that spin out of control.
05:20:50 <shachaf> And kill the entire process group when you kill the Haskell program.
05:20:55 <shachaf> Or the tree. Or something.
05:21:05 <luite> dankna: I whitelist the modules that users can import, and most of them are relatively safe. but the type system isn't a security mechanism
05:21:29 <dankna> luite: aren't you using mueval?
05:21:46 <luite> no plain mueval is too slow
05:21:48 <dankna> oh
05:21:50 <dankna> okay
05:21:58 <aninhumer> roconnor: perhaps you'd be better having a function 'program = main >> exitWith ExitSuccess' in Prelude which is the entry point? Essentially defining the current behaviour in language?
05:21:58 <dankna> well, anyway, I think it's a much much easier problem than you're making it
05:22:06 <luite> perhaps :)
05:22:23 <roconnor> aninhumer: perhaps something like that could be done.
05:22:34 <dankna> simply write a function that invokes a subprocess and also keeps track of it
05:22:51 <dankna> and then modify the few known places where subprocesses are invoked to go through that function
05:23:06 <dankna> yes, you may have to make a modified version of ie the graphviz package
05:24:32 <luite> hmm, don't know about that. the code that runs in the interpreter is untrusted, and personally think the installed packages should mostly be treated as that as well, even though they limit what users can do through the types
05:24:36 <dankna> but you're already tightly bound to your imports because of the security implications, so that's not "really" bringing i a new set of concerns
05:24:48 <dankna> hmm
05:24:58 <luite> but it's quite likely, if I want to allow a reasonable set of import, that there's some security issues in some of them
05:25:01 <dankna> in what sense is it untrusted?
05:25:30 <luite> for example array packages that might not check bounds everywhere as good as they should
05:26:03 <dankna> I don't think you want to allow those packages
05:26:05 <luite> I don't really want to allow unsafe array operations, but it's likely that not everything is safe
05:26:07 <dankna> that's a major issue
05:26:35 <dankna> if it were me, I would have a problem with putting it live knowing that it was exploitable, heh
05:26:39 <luite> it's more that I still want to be able to keep track of everything if it does go wrong
05:27:49 <dankna> when-not-if it does go wrong, the cgi will transmute itself into a kiddy porn server as if by magic, and any code you put in place as a watchdog will be kill -9'ed and rm -rf'ed
05:28:02 <luite> hehe
05:28:17 <dankna> you should focus your efforts therefore on keeping things from going wrong :)
05:28:32 <luite> well in any case, the code runs on a virtual machine that has no internet access, only network access to the machine that has the web service that calls it
05:28:44 <dankna> that's good!  definitely good
05:29:01 <dankna> I didn't realize that; that's a great security measure.  it's nice that we have that technology today.
05:29:54 <dankna> anyway, I would absolutely not allow any package that uses unsafe arrays
05:30:19 <shachaf> luite: You should do it with strace just because that's neat.
05:30:20 <dankna> and I would treat your whitelist as if every additional entity in it uses up your finite supply of reaction mass
05:30:47 <dankna> and do at least a skim-audit of each package you do whitelist
05:30:56 <luite> nah the problem isn't about explicitly allowing it, it's more that some user might find some new exploit with strange Ix instances or something, that defeats the security model
05:31:05 <luite> something that I haven't thought about in advance :)
05:31:08 <dankna> that's fair enough
05:31:22 <dankna> (although I don't think that particular example is possible, but yes, I take your point)
05:31:27 <luite> anyway as a last resort, the virtual  machine could just be restarted
05:31:31 <dankna> yeah
05:31:45 <luite> and perhaps that's enough security
05:31:52 <dankna> oh if you're not already doing this, the virtual machine's only read-write filesystem should be ram-based
05:32:02 <dankna> it should have no write access to the boot filesystem
05:32:24 <dankna> that way each fresh start of the VM is truly fresh
05:33:06 <luite> hmm, I have to think about that, there's a rw filesystem for writing the .hs files and other binaries
05:33:18 <dankna> hmmm
05:33:24 <luite> but the user running the code can only read those of course
05:33:25 <dankna> yeah but that fs can be a ramdisk
05:33:54 <luite> could be, then the vm would need to copy all code from the server at boot
05:34:12 <dankna> yes, exactly
05:34:27 <luite> code/data is updated when a user modifies a page or uploads a binary
05:34:31 * dankna nods
05:37:31 <luite> thanks for the suggestions, I've made some notes in my todo files :) I guess I'll look into ptrace later, for now just securing the vm will have to do
05:39:39 <dankna> okay :)
05:40:09 <shachaf> luite: I don't think ptrace is really practical if it's a per-web-request thing.
05:44:24 <roconnor> I feel there should be some pure way of implementing ST and STRefs but I can't quite figure it out.
05:48:36 <luite> shachaf: the processes live longer than one request in the current version, but I may change that (if forking for every request is efficient enough)
05:49:02 * shachaf hopes luite isn't expecting heavy traffic.
05:49:38 <luite> are forks still so inefficient? I thought they were done with copy on write and stuffs
05:50:12 <shachaf> They're inefficient compared to not forking. :-)
05:50:20 <luite> hehe fair enough
05:50:41 <shachaf> I don't know if it's really fair enough, but it's how it is.
05:53:16 <byorgey> manju_: awesome!
05:54:21 <manju_> byorgey, trying to do animation now
05:54:31 <manju_> byorgey, all thanks to you :-)
05:54:38 <dankna> @hoogle </>
05:54:38 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
05:54:38 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
05:54:38 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
05:57:56 <tromp> > 4 - (log 12 / log 2)
05:57:56 <lambdabot>   0.4150374992788435
05:58:52 <sjoerd_visscher> anybody know how long this Show instance for IOCallback is in base: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-Event-Manager.html#IOCallback
05:59:43 <sjoerd_visscher> It's causing Overlapping instances errors when I try to install the checkers package
05:59:48 <dankna> you can find out for yourself by checking the docs of successively older versions
06:00:01 <byorgey> manju_: =D
06:00:16 <manju_> byorgey, so rotateBy takes a type of Angle, I want to increment it, like say 1/6, 2/6, 3/6
06:00:37 <byorgey> manju_: ok
06:00:44 <manju_> byorgey, I have an Int stored as a state var (angle)
06:01:02 <sjoerd_visscher> ah, it's new in 4.3
06:01:26 <byorgey> manju_: why an Int?
06:01:36 <manju_> byorgey, when I do rotateBy ((angle+1)/6), I get Couldn't match expected type `Diagrams.Prelude.Angle'
06:01:36 <manju_>            against inferred type `Int'
06:01:37 <manju_>     In the first argument of `rotateBy', namely `((angle + 1) / 6)'
06:01:41 <sjoerd_visscher> Is it just me, or is it not a good idea to have a Show instance for a function type in base??
06:01:44 <byorgey> oh, I see
06:01:52 <byorgey> manju_: ((fromIntegral angle + 1)/6)
06:01:58 <manju_> byorgey, ah
06:02:19 <byorgey> fromIntegral converts integral types (like Int or Integer) to any other numeric type (such as Angle, which is just a synonym for Double).
06:02:39 <aasdaf> > show (+1)
06:02:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:02:40 <lambdabot>    arising from a use of `...
06:03:21 <byorgey> manju_: actually, in the next version there will be three different angle types, one for circle fractions, one for radians, and one for degrees
06:03:29 <byorgey> manju_: so the type will be different but that code will still work
06:03:42 <manju_> byorgey, ok...that will be nice
06:05:24 * roconnor likes to use (n `degrees`) (n `radians`) ...
06:05:32 <manju_> byorgey, wwwwwwwwwooooooooooooooooooo....wwwwwwiiiiiiiiiiiii
06:05:42 <manju_> let me paste the code, one moment
06:07:02 <manju_> byorgey, http://hpaste.org/47135/spinning_sierpinski_opengl
06:07:03 <byorgey> roconnor: with diagrams you will be able to write  (tau / 3 :: Rad) or (120 :: Deg) and so on
06:07:19 <manju_> byorgey, spinning sierpinski
06:08:04 <byorgey> manju_: cool! Let me see if I can compile it...
06:08:19 <manju_> byorgey, one more file is required
06:09:11 <manju_> byorgey, http://hpaste.org/47136/sierpinski_opengl_triangle
06:09:53 <Spockz> kosmikus: are you coming to CamHack too?
06:10:34 <byorgey> manju_: hmm, seems I don't have the haskell GLUT bindings installed
06:10:55 <luite> hmm, I get a type error, maybe I have an old diagrams package installed
06:11:18 <byorgey> luite: what type error?
06:11:29 <byorgey> luite, manju_: actually, why don't we move to #diagrams
06:11:31 <manju_> byorgey, sudo apt-get install libghc6-glut-dev did the magic for me
06:11:39 <manju_> byorgey, ok!
06:15:02 <d13724> hi, haskell noob here with a question about types
06:15:50 <tromp> type away
06:16:29 <d13724> if I have a data X = A ... | B ... | C ... i can use pattern matching and write f (A ...) (B ...) = ... f (A ...) (C ...) and so on
06:16:46 <frerich> roconnor: That's a pretty nice idea (using stuff like "degrees" and "radians" as infix), it never occurred to me to do that.
06:17:03 <d13724> is there a way I could write the same thing if I had data A = ... and data B = .... and so on ?
06:17:11 <dankna> removeDirectoryRecursive dir removes an existing directory dir together with its content and all subdirectories. Be careful, if the directory contains symlinks, the function will follow them.
06:17:14 <dankna> .... why?
06:17:21 <dankna> that's a bizarre design, wrt symlinks
06:20:21 <byorgey> d13724: well, if the first argument to f has type A, then you can only pass it arguments of that type.
06:20:40 <byorgey> d13724: if you want to be able to pass "either an A or a B" as an argument to f, then you can pass it (Either A B)
06:20:57 <byorgey> d13724: and pattern-match on it like  f (Left (A ...)) = ...    f (Right (B ...)) = ...
06:26:22 <d13724> byorgey, maybe I'm not very clear on what I'm trying to do. let's say I want to make a small simple geometry lib, I have primitives like Lines, Circles, Rays whatever, and i'd like to have a single "intersect x y" function that could take 2 of any shapes
06:27:26 <tromp> yes, that works, just have a definition of intersect for every shape combinTION
06:27:44 <d13724> but I'd need a data Shape = Line ... | Circle ... | other primitives ?
06:27:59 <byorgey> d13724: you have two options.  The simplest is to have a single data type Shape.
06:28:39 <byorgey> d13724: that makes it easy to add new functions over shapes but more difficult to add a new type of shape (since you have to extend every single function you have already written with some new cases).
06:29:13 <byorgey> d13724: the other option is this: if you can figure out some set of operations that all shapes should support -- i.e. what does it "mean" for something to be a shape -- you can make a Shape type class
06:29:50 <byorgey> then you can write something like  intersect :: (Shape s1, Shape s2) => s1 -> s2 -> Bool  but you would have to be able to implement intersect in terms of the operations provided by the Shape type class
06:31:08 <exeter> I have a little problem with imports: there is a package I've downloaded with cabal ( Text.XML.Light  ). I've created a file named text-xml-light-ancillaries.hs which exports module Text.XML.Light.Ancillaries
06:31:36 <exeter> but when I call import Text.XML.Light.Ancillaries it says "could not find module" etc etc
06:31:48 <exeter> should I rename my file?
06:31:58 <exeter> (and in which way)
06:32:41 <d13724> byorgey, yes that's what I figured for functions that operate on a single shape like computing the bounding box, i can have instances where boundingbox = ... for each shape. But as you say with an "intersect Shape Shape" I couldn't tell what Shape actually is and pattern match on it
06:33:37 <d13724> isn't there a way to "reuse" existing types for A B C in data X = A | B | C ?
06:34:01 <byorgey> exeter: a file providing module Foo.Bar.Baz  must be in Foo/Bar/Baz.[l]hs
06:34:25 <exeter> thanks byorgey
06:34:45 <byorgey> d13724: well, you can say "data X = XA A | XB B | XC C"
06:34:50 <exeter> but windows won't accept that char , byorgey  ?
06:35:07 <exeter> oh
06:35:08 <exeter> folders
06:35:10 <exeter> how silly
06:35:11 <exeter> thanks
06:35:12 <byorgey> exeter: sorry, by .[l]hs I just meant either .lhs or .hs
06:35:19 <byorgey> oh, you meant the /
06:35:24 <exeter> yes
06:35:24 <byorgey> yes, folders =)
06:35:29 <exeter> I am naive byorgey :P
06:35:33 <exeter> Good good
06:35:35 <byorgey> exeter: no worries =)
06:36:29 <d13724> byorgey, thanks I'll try this method and see if I manage to get anywhere
06:47:59 <exeter> another one: I'm trying to get a date to RFC 822 (for xml purpose). It seems you can recreate it pretty easily (its just Sat, 07 Sep 2002 09:42:31 GMT ) but probably there's some more reliable function in the library. Do you know where that it?
06:48:01 <exeter> *is
06:48:47 <dankna> you might hope that, but I suspect you would be disappointed
06:50:49 <develhevel> is there a function like: join ["a","b"] = ["ab"] ?
06:50:50 <byorgey> exeter: see http://hackage.haskell.org/packages/archive/time/1.2.0.5/doc/html/Data-Time-Format.html
06:51:26 <byorgey> develhevel: do you really want ["ab"]? Or just "ab" ?
06:51:33 <byorgey> > concat ["a", "b", "c"]
06:51:34 <lambdabot>   "abc"
06:51:44 <develhevel> byorgey:  just "ab"
06:51:50 <develhevel> thx
06:54:55 * byorgey makes lambda-chip cookies sprinkled with sea salt
06:55:27 * byorgey first tried C salt but those were inedible
06:57:40 <dankna> haha
06:58:25 <spasquali> salted chips are hard to crack
07:07:37 <dankna> dcoutts: you round?  I'm working on a package cabal-app that does the same thing as cabal-macosx but not, and although I expect that I took enough liberties that it's probably not worth the effort to get it added to the core Cabal, it's at least worth discussing that possibility.
07:10:03 <dcoutts> dankna: so I don't think I ever understood the -macosx thing
07:10:13 <dcoutts> dankna: in principle I don't see why it shouldn't be integrated
07:10:20 <dankna> okay.  well it's like this.
07:10:38 <dcoutts> dankna: though obviously I prefer non-hacky solutions :-)
07:10:42 <dankna> on the Mac, both libraries and executables can be packaged in "bundles", which are special directory structures that are treated as files by the graphical file manager.
07:10:50 <dcoutts> (since someone has to maintain it)
07:10:55 <dankna> it's not that it's hacky, quite the opposite - I'm writing my own because I found cabal-macosx too hacky
07:11:02 <dcoutts> :-)
07:11:22 <dankna> it's that I had to write a filesystem portability layer because System.Directory didn't meet my needs (it traverses symbolic links)
07:11:29 <dankna> (on recursive delete!  very dangerous)
07:11:35 <dcoutts> mm
07:12:04 * dcoutts thinks we could add symlink support to System.Directory
07:12:05 <Eelis> that sounds very bad
07:12:14 <dcoutts> all OSs support symlinks these days
07:12:28 <merijn> OSes don't support symlinks, filesystems do
07:12:29 <Eelis> i mean it sounds bad that it traverses symbolic links on recursive deletes
07:12:31 <dankna> that would be fine with me.  of course, System.Directory is in the directory package, which... does cabal already depend on that?
07:12:52 <dcoutts> merijn: right, so any API will have to be able to fail anyway
07:13:09 <dcoutts> so it should work even on OSs (or filesystems) that don't support symlinks
07:13:33 * merijn wasn't following the conversation but just spotted that one line and felt compelled to correct
07:13:33 <dcoutts> "create symlink" would fail, and "is it as symlink" would always say "no"
07:13:40 <dankna> who's the maintainer of the "directory" package, btw?
07:14:05 <dankna> Ross Paterson according to hackage
07:14:18 <dankna> is he an IRCer?  I don't recognize that name /at all/ which surprises me for such an important package
07:14:21 <dcoutts> dankna: GHC HQ
07:14:41 <dankna> gotcha.  so you would have the ability to accept a patch yourself if I wrote it.
07:14:50 * dcoutts is not GHC HQ
07:14:50 <dankna> or at least to push it along to the proper people.
07:14:55 <dankna> hah k
07:14:56 <dcoutts> darcs send!
07:15:02 <dankna> right, gotcha
07:15:15 <dcoutts> I'm happy to talk about a symlink API some time
07:15:36 <dcoutts> I've got other extensions to the portable file/dir api that I'd like to make
07:15:42 <dcoutts> particularly file permissions
07:15:47 <dankna> well, honestly, what I really like is the API in System.Posix.File
07:15:58 <dankna> it would be great if everything imitated that
07:16:33 <dankna> in that API you have two functions ... let me get the docs open so I can give their real names
07:16:46 <dcoutts> dankna: lets talk about your -app thing first
07:16:49 <dankna> sure, okay
07:16:52 <dcoutts> osx bundles
07:17:01 <dcoutts> I'm vaguely aware of the concept
07:17:07 <dankna> okay, so, bundles.  now there are two cases, .framework bundles which are for libraries, and .app bundles which are for executables.
07:17:27 <dankna> in the spirit of avoiding feature creep, for now I'm just supporting .app bundles, but with an eye towards supporting .framework ones later
07:17:35 <dankna> I think that's most of what people want, anyhow
07:17:38 <dcoutts> ok
07:18:02 * dcoutts has previously wondered if it woudn't make sense to be able to make each haskell package into a framework
07:18:11 <dankna> it would, actually
07:18:13 <dcoutts> lib frameworks I mean
07:18:18 <dankna> on platforms that support dynamic linking at least
07:18:27 <dankna> does GHC do dynamic linking on the Mac, currently?
07:18:30 <dcoutts> yes
07:18:32 <dankna> oh good!
07:18:41 <dankna> so yes, that would be a very nice feature, and not too hard once the basics were in place
07:18:52 <dankna> okay, so by the way, a bundle can also include other bundles - it's a very nice property
07:19:01 <dcoutts> so what I've not understood is to what degree it can be done genericly
07:19:13 <dcoutts> or whether the package author has to provide much extra special info
07:19:29 <dankna> cabal-macosx pulls in fgl and MissingH to do some graph-theoretical stuff to chase dependencies and import those.  I take the simpler stance that if you want that feature, you can, uh, implement it yourself :)
07:20:08 <dankna> the package author provides a plist file, which is XML in a schema defined by Apple that is basically an attribute/value tree
07:20:19 <dankna> that file contains various metadata
07:20:51 <dankna> it would be possible in principle to keep that metadata in the .cabal file, but what I think makes more sense because Apple may extend the set of possibilities at any time is to have the user author the file themselves
07:20:58 <dankna> and simply put a pointer to it in the .cabal
07:21:10 <dcoutts> or keep the extra info separately
07:21:15 <dankna> separately how?
07:21:16 <dcoutts> and have cabal extend it
07:21:21 <dankna> oh, yeah, hmm
07:21:38 <dcoutts> got a pointer to the documentation for this plist file?
07:21:42 <dankna> yes, one sec
07:21:45 <dcoutts> what metadata it contains
07:22:22 <merijn> dcoutts: The Apple developer documentation had a pretty nice overview of plist files, IIRC
07:22:32 <dankna> a ton of stuff - a reverse-DNS-name along the lines of com.dankna.niftyprogram which is used to identify the program; a filename pointing to an icon file within the bundle; ...
07:22:42 <dankna> it's a few dozen possibilities
07:24:10 <dankna> http://developer.apple.com/library/mac/#documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html%23//apple_ref/doc/uid/10000123i-CH101-SW1 -- scroll down to "The Information Property List File"
07:24:16 <dcoutts> ta
07:24:26 <dankna> that list appears to be incomplete
07:24:56 <dankna> it also includes things such as copyright string; version string; what OS version is required; names of ObjC classes and of .nib files to be instantiated
07:25:19 <dankna> and, importantly, a list of document types the application recognizes and what its role is with regard to each (editor/reader/whatever)
07:25:49 <dankna> document types can be identified in quite a few ways - file extension; legacy four-character code; UTI (like public.text or com.dankna.fancyapp.document)
07:26:04 <hepek> need cabal help
07:26:11 <dankna> oh, and a list of UTIs exported, which is separate from the list of document types but used by it
07:26:14 <hepek> i've fixed a bug in a cabal package
07:27:16 <dankna> anyway, if we're seriously looking at integration with Cabal, I can absolutely come up with a mapping for all these fields onto fields that would go in the .cabal file
07:27:40 <dankna> although does the .cabal parser handle things like the tree of document types, with each document type itself having several fields?  it would need to
07:27:59 <dankna> this would all go in the Executable section, hence potentially being instantiated more than once
07:28:23 <dankna> if we're not looking at eventual integration, honestly having the user author the .plist themselves meets my own needs
07:28:38 <dcoutts> dankna: mm, looking at the list of info, I think you're right that it needs to be separate, we can't realisticly generate it from the .cabal file
07:28:48 <dankna> dcoutts: okay.  well, that resolves that then.
07:28:57 <dcoutts> dankna: though you could generate an intial version that the user edits
07:29:03 <dcoutts> user/package-author
07:29:28 <dankna> what would be the UI for that?  would it be a prompt in "cabal init" along the lines of "Do you want to add stuff for a .app bundle on the Mac?"
07:30:22 <dcoutts> dankna: so I think this falls into the category of deployment using some installer technology, like windows msi, deb, rpm etc
07:30:23 <dankna> note that - let me explain about resources and .nibs and .xibs?
07:30:33 <dankna> that's logical
07:30:42 <dankna> it's not really an installer, but it's sort of like an installer
07:30:47 <dcoutts> dankna: where we take the result of a package build, add some extra files into the install image
07:30:50 <dankna> (it's executable in-place)
07:30:57 <dcoutts> and then run some external tool to make the installer
07:31:16 <dcoutts> dankna: ok, well the last step might be a no-op here
07:31:19 <dankna> well, actually because it's just a directory structure with files in particular places
07:31:29 <dankna> we don't need an external tool to make the bundle
07:32:04 <dankna> it's more akin to if we had a feature that linked extra Windows "resources" like icons and data files into an existing .exe
07:32:23 <dcoutts> dankna: right, windows assemblies
07:32:27 <dankna> right, okay
07:32:28 <dcoutts> with manifests
07:32:35 <dcoutts> resource compiler etc
07:32:38 <dankna> yep
07:32:52 <dankna> and speaking of resource compiler
07:33:05 <dankna> okay so one of the subdirectories inside the .app is Contents/Resources/
07:33:12 <dankna> this may contain, in general, arbitrary files and directories
07:33:20 <dcoutts> so logically I think this is a kind of system-specific deployment, like cabal2rpm, cabal2arch, windows assembly
07:33:21 <dankna> it almost always contains icons and nibs
07:33:59 <dankna> a .nib is a serialization of GUI objects (also of non-GUI objects), and is produced by a compilation-like pass from an XML file called a .xib
07:34:09 <dankna> the compilation pass is done by an external program called ibtool
07:34:15 <dankna> so this adds to our build phase, effectively
07:34:43 <dankna> we have to run ibtool on all the provided .xibs (this is the particular feature that cabal-macosx doesn't have at all that I really want)
07:35:17 <dankna> and then we have to move all the other resources into place, like auxilliary icons and any data files the app wants.  that part is no big deal, we just add a list-of-files field to the .cabal
07:35:24 <dcoutts> dankna: mm, so does this only make sense for installing/deploying, or is any of this needed to run a devel/debug version inplace in the build tree?
07:35:33 <dankna> the latter
07:35:44 <dankna> in a GUI app, you need to do all these steps to run it at all
07:35:48 <dcoutts> really, that's a bit disapointing
07:35:54 <dankna> running without a .app bundle is /possible/ but quirky
07:36:06 <dankna> and is not a good way of developing because things behave differently than if you do have one
07:36:12 <dcoutts> so it's not just a case of the gui prog being able to find its resources at runtime
07:36:15 <dankna> why is it disappointing?
07:36:28 <dcoutts> well it means it can't easily be separated into a deployment phase
07:36:45 <dankna> right, no, it's not.  it's also a case of the system libraries really wanting to have that metadata from the .plist
07:36:57 <dcoutts> and it means the package is really not portable
07:37:01 <dankna> yes, it's really part of the build phase, but done after the rest of the build
07:37:36 <dankna> it can be designed so it's portable
07:38:05 <dankna> let me hpaste the Executable section of the project I'm testing this on, so you can see what I had in mind
07:38:10 <dcoutts> ok
07:38:25 <dankna> http://hpaste.org/47138/xappwhatever
07:38:39 <dankna> as you can see, I used the x-* hook for this because I wasn't looking at integration yet
07:39:16 <dankna> the x-app-c-headers and x-app-c-sources fields exist to let you add additional files that are only compiled and linked when you're building a .app
07:39:46 <dankna> there should perhaps also be an x-non-app-other-modules and x-non-app-c-{sources|headers} equivalent or something?
07:40:03 <dankna> that's verbose though.  I hadn't thought through the non-app case.
07:40:17 <dcoutts> so x-app-resource-dir: Mac/Resources is the dir where all these files live?
07:40:43 <dankna> x-app-resource-dir is a convenience field, specifying a pathname that is prefixed to x-app-icon, x-app-xibs, and x-app-other-resources.
07:41:03 <dankna> so that you can keep all this stuff in a subdirectory and not have it clutter up the root of your repo
07:41:32 <dankna> the paths specified there are the pre-install paths; the post-install paths are Foo.app/Contents/Resources/*
07:42:02 <dankna> there are some exotic scenarios with including entire directory trees in the resources, but I think we can safely leave that as a feature for later
07:42:51 <dankna> note by the way that nothing in this specifies whether main() is defined Haskell-side or C-side; either is possible
07:43:07 <dcoutts> dankna: I was thinking about a system based more on convention, like use the existing data-dir and data-files features, but recognise these files with specific extensions and make the tool do the right thing.
07:43:12 <dankna> in this project I'm doing it Haskell-side, but it's also possible to put it C-side, in which case there would be no main-is field
07:43:47 <dcoutts> dankna: that's a cabal ticket for executables with a C main()
07:44:38 <dankna> okay.  yeah.  I also have another project which actually does do that, but I did it by building as a library and then having linking done by XCode, which was nightmarish and what I'm trying to avoid here.
07:45:15 <dankna> how were you thinking of handling the C main() case?  something like a field "c-main: yes"?
07:45:21 <dcoutts> c-main: foo.c
07:45:24 <dcoutts> erm
07:45:27 <dcoutts> main-is: foo.c
07:45:31 <dankna> why does it need to know the filename foo.c?
07:45:37 <dcoutts> so it can be compiled
07:45:43 <dankna> and what if main is in a library?  as it is with SDL for example
07:45:58 <dcoutts> well that's just madness! :-)
07:46:06 <dankna> haha, it's a pretty silly design, yes
07:46:11 * dcoutts notes that DSL is indeed mad
07:46:34 <dankna> if by DSL you mean the .cabal file, nah, I like .cabal files
07:46:47 <dcoutts> erm, SDL
07:46:50 <dankna> oh, yes
07:46:52 <dankna> it is
07:47:47 <dankna> anyway, ignoring SDL for now, I'd be more inclined to list main.c in c-sources and have a field that specifies that although there is a main(), it is not Haskell-side
07:48:07 <k0ral> dcoutts: you're the one who brought back the gtk2hs website, right ?
07:48:15 <dcoutts> k0ral: aye
07:48:19 <dankna> we really don't need to know which file has main() in it, so we shouldn't demand that information
07:48:33 <k0ral> dcoutts: well, I just wanna tell you big thanks
07:48:37 <dcoutts> :-)
07:49:06 <dcoutts> dankna: mm, I suppose that's right. Just seems quite odd.
07:49:21 <dankna> it is a little odd, but you'll get used to it :)
07:49:45 <dcoutts> dankna: and means we'll do crazy things when people forget the main-is for ordinary Haskell executables
07:50:02 <dankna> no, that's why there's a line c-main: yes
07:50:10 <dcoutts> oh but that's horrible :-)
07:50:15 <dankna> (it could be just c-main with no colon, but that would require extending the parser)
07:50:33 <dankna> haha I don't see it as horrible :)
07:50:48 <dcoutts> dankna: let the SDL people cheat using: main-is: dummy.c :-)
07:50:54 <dankna> hahaha
07:51:01 <dankna> okay, I'll compromise for now
07:51:12 <dankna> we can just do main-is: main.c
07:51:15 <dankna> wait, no
07:51:26 <dankna> we can't, because!
07:52:00 <dankna> my concept with making x-app-c-sources separate from c-sources was that on platforms that don't support bundles, you just ignore all the x-app fields
07:52:28 <dankna> that way you can have a single Executable section that works in both cases
07:52:53 <dcoutts> this is also doable with conditionaly
07:52:58 <dankna> yes, it is
07:52:58 <dcoutts> conditionals
07:53:39 <dankna> although I would prefer to add a new condition "bundles" rather than using "os(osx)", because there are exotic scenarios where you want a bundle on a non-Mac platform
07:53:59 <dankna> (specifically, when you're building against the Cocotron framework, which is an open-source reimplementation of Apple's APIs)
07:54:12 <dankna> I don't plan to explicitly support those scenarios for now
07:54:24 <dankna> but I don't want to casually rule them out when it's easy enough to arrange things so they're possible, either
07:54:27 <dcoutts> mm
07:55:22 <dankna> now that I think about the "ignoring the x-app-* fields" thing in light of the "where do we get our main()" issue, I see that you really can't escape some conditionals
07:55:51 <dankna> well, you can, but only by providing a Haskell-side main that uses CPP to determine what platform it's on
07:55:52 <dcoutts> dankna: perhaps you can send an email to cabal-devel and outline the build steps that are required and the layout required.
07:56:28 <dcoutts> dankna: as much as possible I'd like to partition it into some simple build system extensions (like knowing what to do with compiling .xib files) and then a separate deployment phase
07:57:02 <dankna> you want it emailed because you don't have time to finish this now, or because you'd like it as a nice summary, or so other people can read it too?
07:57:02 <dcoutts> dankna: but it's not quite clear yet how possible that partition is
07:57:10 <dcoutts> dankna: yes, both
07:57:14 <dankna> okay
07:57:45 <dankna> well, I'll put that mail together, then.  I am in favor of partitioning it as much as possible, but I don't think reusing existing fields is a good idea.
07:58:31 <dankna> I'm fairly close to having a working prototype, so maybe I'll finish that and put a link to the prototype in the mail
07:58:59 <dcoutts> dankna: ok, specific example: data-files: Application.icns, MainMenu.xib, Document.icns
07:59:16 <dcoutts> dankna: and have the deployment phase just put them in the right place based on file name.
07:59:25 <dcoutts> would that work?
07:59:35 <dankna> hm
08:00:03 <dankna> I don't like lumping .xibs in there
08:00:16 <dcoutts> because they're platform-specific?
08:00:18 <dankna> it can put them in the right place, since the right place is the same
08:00:26 <dankna> no, because they have the compilation phase and nothing else does
08:00:37 <dcoutts> dankna: that's not fundamental
08:00:55 <dankna> what if you actually wanted an uncompiled .xib in the Resources/ for some reason, not that I think it's likely?  it would be impossible
08:00:56 <dcoutts> dankna: there's other kinds of data files that could have a processing phase
08:01:05 <dankna> data-files: should be things that aren't processed at all
08:01:10 <dcoutts> dankna: e.g. happy & alex have generated data files
08:01:14 <dankna> hmmm
08:01:20 <dankna> well, I can't say I like that :)
08:01:51 <dankna> btw - who is this Atze Dijkstra who's posting to cabal-devel?  is he related to /the/ Dijsktra?
08:02:28 <dankna> what I'd want to know is, what happens to data-files: on, say, Linux?
08:02:32 <dankna> do they go in /usr/share/?
08:02:58 <dcoutts> dankna: they go in the ${datadir} which is specified at configure time
08:03:31 <dankna> oh, okay.  well, I guess that's fine, as long as you never have a scenario where you want to use a ${datadir} that isn't the Resources dir in the bundle
08:03:40 <dankna> which seems plausible
08:03:45 <byorgey> dankna: http://www.cs.uu.nl/wiki/Atze/WebHome
08:04:20 <byorgey> dankna: I think Dijkstra is a not uncommon Dutch name, but I am not sure
08:04:23 <dcoutts> dankna: right, it'd be reasonable for the bundle deployment style to configure with --datadir=${resourcedir}
08:04:28 <dankna> byorgey: ah okay!
08:04:59 <tomh> dijkstra is a common dutch name yes
08:05:02 <dankna> dcoutts: right, okay.  noting of course that the bundle may be relocated!  and that in general you have to make an API call to find the path to it
08:05:24 <dcoutts> dankna: then it ought to use --prefix-independent, which isn't implemented yet :-)
08:05:29 <dankna> dcoutts: haha, hmm
08:05:40 <dcoutts> dankna: cabal can make relocatable packages on some systems aready
08:05:51 <dcoutts> notably windows
08:05:58 <dcoutts> and find the data files at runtime
08:06:05 <dankna> the other thing that has me nervous is that you keep saying "deployment phase"
08:06:09 <dankna> I really think this is part of the build phase
08:06:24 <dankna> deployment would be copying it to /Applications/ or whatever
08:07:34 <dcoutts> dankna: I mean the steps needed to prepare (but not necessarily install) a prog to be used
08:07:48 <dcoutts> dankna: point is it crosses the build and configure boundary
08:07:57 <dankna> right, okay
08:08:11 <dcoutts> dankna: the current cabal approach is that the package author and builder are separate roles
08:08:17 <dankna> I envision this being done automatically during (at the end of) the "cabal build" phase
08:08:46 <dankna> hm, yes.  how does this relate to that?
08:08:58 <dcoutts> dankna: builder gets to choose the install paths and layout, package author does not get to decide that at all
08:09:11 <dankna> oh, yes, I see
08:09:34 <dcoutts> dankna: the author has to cope with whatever paths the user picked, but there's obviously support for finding data files etc at runtime
08:10:25 <dcoutts> dankna: so the difficulty with this stuff is the degree to which it conflates these two, we're saying the build will only work if you use this particular layout
08:10:28 <dankna> right, gotcha.  whereas with bundles, the author gets to pick, but the reason for that is that his choice is such that the builder can subsequently relocate the whole thing wherever he wants
08:11:25 <dankna> which gives the builder the capability that he would be trying to get by specifying paths himself, anyway
08:12:08 <dcoutts> dankna: so if possible I'd like to see if we can make it fit the existing division of roles, so that the builder decides they want a bundle so they pick the paths just right
08:12:18 <dankna> mm
08:12:25 <dankna> that would require the builder to be like
08:12:30 <dcoutts> (not manually obviously)
08:12:34 <dankna> $ cabal configure --datadir=...
08:12:35 <dankna> oh
08:13:04 <dankna> well, one possible interface would be like $ cabal configure --bundle
08:13:42 <dankna> and --bundle would be assumed by default on the Mac, because, uh, you can't run a Mac program without a bundle
08:13:47 <dankna> at least, not a graphical one
08:14:21 <dankna> but there would also be --no-bundle to turn it off in the case that the builder really doesn't want that behavior
08:14:29 <dankna> hmm
08:14:37 <dcoutts> dankna: so the layout is actually important, it's not just the case that the locations can be specified in the Info.plist ?
08:14:53 <dcoutts> dankna: if we want to be able to run inplace from the build tree
08:15:00 <dankna> yes, the plist specifies the locations relative to the layout, which is important and fixed
08:15:14 <dankna> it's not possible to run inplace from the build tree unless there is a .app bundle as part of the build tree
08:15:45 <dcoutts> dankna: and I'm guessing Xcode arranges its build tree so it just happens to exactly be a app bundle layout?
08:15:52 <dankna> quite so
08:16:04 <dankna> well, it contains one
08:16:13 <dcoutts> so does it also do a separate step?
08:16:38 <dcoutts> to make a local install
08:17:00 <dankna> XCode actually first creates the bundle, then compiles everything and links, with parameters such that the final linked file is placed into the bundle directly
08:17:13 <dankna> then it compiles xibs into nibs, again placing them into the bundle directly
08:17:13 <dcoutts> I see
08:17:17 <dankna> then it copies all other files
08:17:42 <dcoutts> dankna: I wonder if you could fake it with symlinks :-)
08:17:49 <dankna> uhhhh
08:17:56 <dankna> probably, but to what end
08:18:30 <dcoutts> dankna: ie use a standard ./dist/bin ./dist/lib build tree layout and have a separate /dist/app which just has symlinks into the normal stuff
08:18:39 <dankna> what cabal-macosx does, because it was a minimally-invasive hack, is run as a post-build hook that copies the executable from dist/whatever/whatever to dist/whatever.app/...
08:19:06 <dcoutts> dankna: right, that's actually not unreasonable (though a little expensive)
08:19:09 <dankna> right
08:19:33 <dankna> I don't mind copying the files in a pass after the build
08:20:03 <dankna> in my ideal layout, dist/name/name would be the binary and dist/name.app/ would then be created with a copy of it
08:20:20 <dcoutts> dankna: note that this will only work for the simple build system, otherwise you don't know the layout of the ./dist/ files
08:20:27 <dankna> oh absolutely
08:20:37 <dankna> my prototype integrates heavily with simple
08:20:54 <dcoutts> but the deployment would work, because all cabal build systems have to support the --datadir etc flags and support copy --destdir=
08:21:16 <dankna> I see
08:21:19 <physicist> Does Data.Packed.Matrix has an instance for Num (Matrix Double) or not
08:21:51 <dankna> physicist: what package is Data.Packed.Matrix in?
08:21:57 <physicist> for it's documentation it seems it should but ghc is giving error on its account
08:22:04 <physicist> Hmatrix
08:22:11 <dankna> @hackage hmatrix
08:22:11 <lambdabot> http://hackage.haskell.org/package/hmatrix
08:22:49 <dankna> well, what it has is an instance for (Container Matrix a, Num (Vector a)) => Num (Matrix a)
08:22:59 <dankna> what that means is that you have to have the instance Vector Double imported also to use that one
08:23:31 <dankna> er the insance Num (Vector Double)
08:23:37 <dankna> looks to me like that instance is defined in Data.Packed.Vector
08:23:42 <dankna> so you need to import that package as well
08:23:53 <physicist> i have the whole Data.Packed imported
08:24:01 <physicist> but still there is error
08:24:16 <dankna> go to http://hpaste.org/ and paste the full text of the error for us
08:24:18 <dcoutts> dankna: as for UI, having something like: cabal appbundle [subcommands] would be fine
08:24:33 <dankna> dcoutts: :( can't it be part of build?
08:24:44 <dcoutts> dankna: I mean at least for specific things
08:24:54 <dcoutts> where you need extra ui
08:24:58 <dankna> oh okay
08:24:59 <sshc> @tell edwardk Do you have a list of all the packages into which category-extras was split?
08:24:59 <lambdabot> Consider it noted.
08:25:30 <dankna> yeah, I don't really anticipate needing extra command-line UI.  am I doing the thing with the --bundle and --no-bundle flags to cabal configure?
08:25:57 <dankna> it would default to --bundle when os(osx) and to --no-bundle otherwise
08:26:20 <dankna> and then the conditions for putting in the .cabal file would add "bundle" as one of them
08:26:33 <dcoutts> dankna: but don't we need the extra Info.plist for a bundle, I didn't think we could do it generically?
08:26:58 <dankna> dcoutts: yes, how does that relate?
08:27:14 <dcoutts> dankna: well it means we can't default to making everything a bundle on osx
08:28:40 <dankna> dcoutts: hmm.  sorry, I meant to say:  when --bundle is given (or defaults to true), we (a) match the bundle condition in if-blocks, and (b) when the bundle-info: field is found in an Executable section, build that Executable as a bundle
08:29:12 <dankna> when it's not given, we (a) match the negated bundle condition, and (b) when the bundle-info field is found, describe the error
08:29:59 <dankna> I just thought of making it an error to have a bundle-info when not building as a bundle right now, but I think it makes sense; that way users realize they're supposed to conditionalize on it and can stick the data-files: thing in the conditional that they'll already have
08:30:51 <dcoutts> dankna: hmm, I think I'll have to read more about bundles to see where the right partition is
08:31:16 <dankna> hmm.... all right.  why, what unanswered questions are there?
08:31:39 <dankna> the link I gave before also has the general information on their structure, and I'll summarize the steps in that email that I'm writing, of course
08:31:45 <dcoutts> ta
08:31:46 <physicist> dankna: http://hpaste.org/47140/random_matrix
08:31:58 <dankna> np
08:34:20 <dankna> physicist: oh!  I looked at it again and realized it also needs the Container Vector Double instance, which is in Numeric.Container
08:34:59 <physicist> I have imported Numeric.Container also
08:35:09 <dankna> oh hmm, so you have
08:36:13 <dankna> physicist, I just noticed you're having the problem specifically in ghci.  let me try it out myself.
08:37:49 <k0ral> what would happen if I install a package over an old one with the same name ?
08:38:31 <dankna> k0ral: are there other packages depending on that one, already installed?
08:38:50 <k0ral> dankna: yes, lots of
08:38:57 <dankna> k0ral: then don't do that
08:39:04 <k0ral> dankna: arrrgh !
08:39:16 <k0ral> was afraid to hear that
08:39:26 <physicist> dankna: putting the expression in main does not help
08:39:33 <k0ral> I just want to upgrade a package installed from hackage to its darcs version
08:40:08 <dankna> k0ral: you can do it, but understand that the packages depending on it will be in the "broken" state after you do that
08:40:17 <byorgey> k0ral: you'll just have to rebuild all the packages that depend on it.
08:40:31 <dankna> you can enumerate them with "ghc-pkg check" and then "cabal install --reinstall" them one at a time
08:40:46 <k0ral> oh then it's more than feasible
08:40:55 <dcoutts> it's better to install them all at once rather than one by one
08:40:55 <k0ral> why didn't you tell me that at first ? :)
08:41:11 <k0ral> fair enough
08:41:22 <dcoutts> if you install them all together cabal will guarantee they all have consistent dependencies
08:41:34 <dankna> because I didn't know at first that your reason for wanting to do it made sense :)
08:41:51 <k0ral> I'll do that, hopefully I won't have to reinstall all haskell environment from scratch again
08:42:00 <k0ral> dankna: my bad
08:42:41 <dankna> physicist: okay, I've got hmatrix installed, trying your code now.
08:43:15 <dankna> physicist: oh wait, no I don't, the build failed >< hazards of running ghc HEAD
08:43:54 <physicist> what is ghc Head
08:44:02 <dankna> the latest unstable development build of ghc
08:45:13 <physicist> dankna: thanks anyway
08:45:16 <dankna> anyway, I'd test whether you still have the problem if compiling the file
08:45:24 <dankna> sure thing, sorry I couldn't fix it for you
08:45:35 <k0ral> btw how does cabal/ghc-pkg manage upgrades from hackage ?
08:46:01 <dankna> k0ral: it doesn't really "manage" them
08:46:14 <physicist> again  why does this give an error: http://hpaste.org/47140/random_matrix
08:46:31 <k0ral> dankna: what does it allow to do then ?
08:46:58 <dankna> you can "cabal install" an upgrade which will install it, overwriting the previous version, and leaving its dependents broken
08:47:06 <dcoutts> k0ral: I think you might need to ask a more specific question or give an example of what you're trying to do
08:47:09 <dankna> there used to be a command "cabal upgrade" but it was an easy way to break things
08:47:53 <k0ral> well
08:47:54 <dcoutts> k0ral: because you can install multiple versions of each package, there's no real difference between an install and an upgrade
08:47:56 * hackagebot haxr 3000.8.2 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.8.2 (GracjanPolak)
08:48:47 <k0ral> well, I was expecting cabal/ghc-pkg to somehow have a command like "apt-get safe-upgrade"
08:49:06 <k0ral> packages on hackage get upgraded, and I don't want to chase every broken package each time it happens
08:49:42 <k0ral> don't you find this quite tedious N
08:49:45 <k0ral> ?*
08:49:46 <lambdabot> Maybe you meant: . ? @ v
08:49:51 <dankna> no - I never in practice want to do that
08:50:16 <dcoutts> k0ral: so when you say cabal install blah, it installs the latest version of blah and if necessary will install or reinstall dependencies to make sure that 'blah' can be installed.
08:50:21 <k0ral> isn't there an a library you use that evolves rapidly ?
08:50:25 <dankna> I have things installed because I am developing against them; I don't want to unnecessarily change versions in the middle of development, as that might create extra work for me for compatibility
08:50:48 <k0ral> dankna: apt-get asks you before upgrading
08:50:49 <dankna> if I did have a dependency that was changing rapidly, I would never want it to be upgraded except by my explicit action
08:51:14 <k0ral> well, the explicit action isn't a problem
08:51:24 <dankna> in practice, I set checkpoints every month (or, if I'm lazy, every few months) where I spend a day installing the latest bleeding-edge GHC and then rebuilding my world
08:51:30 <k0ral> you could just never launch the command "safe-upgrade"
08:52:06 <dankna> also if the dependency is changing that rapidly, that means it's not finished yet, and that means nothing else is depending on it except em
08:52:07 <dankna> *me
08:52:12 <k0ral> well, instead of spending a day, you could expect an automatic processing
08:52:17 <dankna> well, no.
08:52:27 <dankna> there isn't enough automation in place yet
08:52:37 <dankna> and packages are frequently broken against the HEAD so I have to patch them
08:52:48 <dcoutts> dankna: really? I thought the problem was there was too much automation :-)
08:52:58 <dankna> dcoutts: haha, perhaps!
08:53:13 <k0ral> dankna: frequent upgrades doesn't mean that it's not finished
08:53:16 <Jafet> Too much dumb automation
08:53:17 <k0ral> not necessarily
08:53:21 <dankna> it's true enough that I wouldn't have this problem if computers didn't exist!
08:53:32 <sm> k0ral: this alias is quite handy for cleaning out broken packages: https://gist.github.com/d371d095c1f560534eeb
08:53:44 <dcoutts> k0ral: there's not a concept of upgrade because you just install an extra version
08:54:01 <k0ral> I'm well aware of that now
08:54:33 <dankna> if you feel there should be upgrade functionality, you're welcome to donate your time and implement it
08:54:48 <dcoutts> dankna: I'm not sure what it'd mean
08:54:59 <dcoutts> k0ral: and the default policy when you "cabal install blah" is to use the versions of dependencies that are already installed (when that is possible)
08:54:59 <dankna> well, that's true too
08:55:09 <k0ral> well, I feel it and I really would like to contribute, but I need time to learn more haskell, I'm still new here
08:55:17 <Jafet> If different versions of packages can be installed, why do their dependents break?
08:55:23 <ccc>  /msg NickServ identify rv2733
08:55:24 <dcoutts> k0ral: but if you really want to use the latest versions of all dependencies then that's also possible (but tends to break things)
08:55:36 <djahandarie> ccc, ...
08:55:45 <dcoutts> Jafet: because currently there can only be one instance of each version of each package.
08:56:22 <k0ral> dcoutts: well, it tends now because haskell libraries and applications are not as old as in other languages
08:56:49 <k0ral> but eventually, and you should always think about the far future, I think haskell community will need such a feature
08:56:56 <dcoutts> k0ral: no, it's more of a packaging issue than anything to do with the libs/apps themselves
08:56:57 <Jafet> dcoutts: that sounds tautological
08:57:29 <dcoutts> Jafet: it's not :-) imaging having multiple instances of foo-1.0, but each one compiled against different versions of their dependencies.
08:57:57 <k0ral> sm: this only unregisters a bunch of packages
08:58:18 <k0ral> sm: I still expect a packaging system to remove package files
08:59:09 <Jafet> I mean, if you have bar-1.0 which depends on foo-1.0, and you install foo-1.1, does the build system let you do things like link bar-1.0 and foo-1.1?
09:00:36 <dcoutts> Jafet: this stuff is rather subtle: you can link multiple versions of a package into one program, but you may not have been able to compile it in the first place.
09:01:10 <dcoutts> Jafet: but even what can be linked/compiled is orthogonal to the issue, the question is what can be installed & registered.
09:02:04 <sm> yeah, everyone expects cabal to remove packages.. it doesn't have that power yet. I think most users would appreciate a dumb uninstall command calling ghc-pkg unregister.. but cabal is compiler independent
09:02:35 <k0ral> sm: compilers don't output the same files ?
09:02:48 <k0ral> I mean, all different compilers
09:03:02 <sm> I doubt it, but more to the point they don't all manage packages I suppose
09:03:52 <sm> I think having the compiler manage packages is a bit funny
09:04:17 <k0ral> I'm quite happy that cabal is compiler-independent
09:04:32 <k0ral> but I thought there was still a way to track files
09:05:20 <dcoutts> Jafet: suppose I have two programs that uses your example foo and bar packages. I install progA against foo-1.0 and bar-1.0. Then I decide to build progB against foo-1.1 and bar-1.0.
09:06:15 <dcoutts> Jafet: my problem now is that I need one instance of bar-1.0 built against foo-1.0 and another instance of bar-1.0 built against foo-1.1.
09:06:36 <hvr> dcoutts: a cabal question: If I have 10 executables in a .cabal file, do I really have to repeat the build-depends libraries 10 times? :-/
09:06:50 <dcoutts> Jafet: so this is nothing to do with linking multiple versions of the same package, just about being able to install these things simultaneously
09:07:09 <dcoutts> hvr: no, you can have them all build-depend on a lib in the same package.
09:07:25 <hvr> dcoutts: and inherit its build-depends implicitly?
09:07:33 <dcoutts> hvr: no
09:08:03 <Jafet> Another question: if bar-1.0 depends on foo <= 1.0, then what happens?
09:08:09 <dcoutts> hvr: anything the exes depend on they have to list explicitly, but if one of them is the library then that might mean fewer deps.
09:08:42 <dcoutts> hvr: and note that we currently can't have a private lib in a package, it'd be installed & registered.
09:08:45 <monochrom> you can put one bar-1.0 in user, another in global
09:09:01 <k0ral> monochrom: and what if progC needs bar-1.2 ? :)
09:09:07 <k0ral> dcoutts: I see your point but still
09:09:16 <monochrom> irrelevant
09:09:53 <dcoutts> Jafet: so this brings up an interesting question, can we have a solution where bar-1.0 is built against foo-1.0 and progB uses foo-1.1
09:09:53 <k0ral> dcoutts: it could be nice to have something that automates the process of looking for every package if a new version is available
09:10:17 <hvr> dcoutts: thx... I'm a bit too used to Makefiles, where you can just use variables to declare common information
09:10:19 <k0ral> monochrom: meant foo-1.2
09:10:37 <dcoutts> hvr: I've been thinking of having an explicit common section
09:11:04 <hvr> dcoutts: I guess that might handle 99% of the cases already
09:11:17 <sm> why *goes* ghc need to know so much about packages ? could ghc-pkg be moved into cabal ?
09:11:30 <Jafet> cabal refuses to install foo-1.1, or installs it (and breaks bar)?
09:11:31 <sm> *does*
09:11:51 <dcoutts> Jafet: so in principle, if that solution compiles, then yes it's possible. It'll all link.
09:11:56 <dankna> the way I would design the "common section" is to have named constants, the values of which are lists of fields
09:12:03 <Jafet> preflex, seen Jafet
09:12:04 <preflex>  Jafet was last seen on #haskell 34 seconds ago, saying: cabal refuses to install foo-1.1, or installs it (and breaks bar)?
09:12:07 <dankna> then you could have multiple common sections if you needed them
09:12:28 <dcoutts> Jafet: the problem cabal-install has is that it doesn't know whether that solution will compile or not
09:12:53 <dcoutts> Jafet: because our progB might take types from foo-1.1 and pass them to bar which expects types from foo-1.0
09:13:11 <hvr> dcoutts: ...or you could implement a "CPP" language extension for use inside .cabal files =)
09:13:17 <dcoutts> Jafet: e.g. imagine bar is zlib and foo is bytestring
09:13:20 <Jafet> Yeah.
09:13:22 <dankna> hvr: ugh :)
09:13:28 <dankna> hvr: no please
09:13:31 <hvr> hehe
09:13:50 <dcoutts> Jafet: so if cabal knew that this would work then it could pick such a solution, but currently it doesn't.
09:14:28 <dcoutts> Jafet: as it happens, kosmikus and I are working on just such a system to allow "private" or "encapsulated" package dependencies.
09:14:44 <Jafet> That's a rather unconservative thing for a computer to do
09:14:46 <hvr> dankna: by 'common section', do you mean something that can be 'imported' into the actual targets by name?
09:14:55 <dankna> hvr: yes.
09:15:00 <Jafet> (finding that sort of solution)
09:15:09 <hvr> dankna: I'd really like that...
09:15:22 <dankna> hvr: noted, but I don't personally have the time to do it...  heh
09:15:36 <dankna> the Cabal code is very clean and not too big, you could work on adding it yourself
09:15:40 <Jafet> I would say that what most people want is for cabal to be more conservative -- only install packages if they won't break anything else
09:15:41 <dcoutts> Jafet: generally you'd try to use just one version, except where it's not possible, and then you can only pick multiple versions if you know it's ok, and that's what the encapsulation is for.
09:16:20 <dcoutts> Jafet: but now you're talking about something else, about breaking packages by rebuilding things. That's orthogonal.
09:17:04 <Jafet> Right, I'm replying out-of-phase
09:17:20 <hvr> dankna: when I get time, I'll give it a try...
09:17:50 <Jafet> By "encapsulation", you refer to a package being exclusively a dependency of another?
09:18:04 <dcoutts> Jafet: the canonical example is some package that uses QC1 and another that uses QC2 (or parsec 2 & 3) and currently cabal will fail because it cannot pick a single version of QC
09:18:13 <kosmikus> dcoutts, Jafet: just reading up, so I may be missing context, but the new solver will at least have a flag to avoid dangerous reinstalls
09:18:25 <dcoutts> Jafet: but if we know that the use of QC is encapsulated, then it's ok
09:18:45 <dankna> hvr: cool :)
09:18:47 <dcoutts> kosmikus: by failing or by trying to find different versions?
09:19:12 <dcoutts> kosmikus: I've been thinking of doing a post-solver check in the current version, to see if what we've picked involves reinstalling anything
09:19:17 <hvr> dankna: I guess 'Macro' would be a better name for it
09:19:33 <kosmikus> dcoutts: well, you can specify that it won't ever upgrade to the same version, which I think is the dangerous situation, right?
09:19:45 <dankna> hvr: hmm.... I would call it...  a "fieldset"
09:20:02 <dcoutts> kosmikus: yes, reinstalling an existing version of a package (against different versions of its deps)
09:20:16 <dcoutts> kosmikus: of course sometimes that's necessary to get a solution.
09:20:28 <dcoutts> kosmikus: but yes we should make the user make that choice explicitly.
09:20:44 <kosmikus> dcoutts: exactly, yes. so it's easy to rule those out. and yes, it'll be a flag we can turn on or off, and decide what should be the default.
09:21:07 <hvr> dankna: or maybe just a 'Define'? :)
09:21:16 <dankna> hvr: yes or that :)
09:21:25 <kosmikus> dcoutts: possibly even try first without, and only if that fails with, and in the latter situation print another warning before proceeding.
09:21:47 <dcoutts> kosmikus: I think you'd have to do it twice, try first with no mutations, if that fails try with mutations and fail telling the user what would be mutated and they should retry with --allow-breaking-reinstalls
09:21:54 <hvr> dankna: all conditionals in .cabal files can be resolved at parse-time?
09:22:11 <dankna> hvr: at configure-time, which is different.
09:22:26 <kosmikus> dcoutts: I think what you're saying is exactly what I've just been saying, only in better words.
09:22:31 <dankna> hvr: they're parsed into a structure which includes the conditionals; then they're configured into an unconditional version of that same structure.
09:22:31 <dcoutts> kosmikus: :-)
09:22:57 <dcoutts> kosmikus: so in the current version I could add this behaviour but without the attempt to try to avoid solutions involving reinstalls.
09:23:03 <hvr> dankna: ok, but all inputs to the conditionals come from outside the .cabal file?
09:23:40 <dankna> hvr: in principle.  one of the conditions possible is a flag, which has a default value specified inside the .cabal, but its actual value is specified at the command line.
09:24:09 <dankna> hvr: flags are simple true-false values, I think
09:24:13 <dcoutts> dankna, hvr: it's more tricky yet, the flags can be resolved automatically
09:24:19 <dankna> ah, okay
09:24:36 <dcoutts> based on the installed/available packages
09:24:49 <monochrom> you still get simple true-false values, don't worry
09:37:30 <dankna> dcoutts: so I just noticed that data-files: is a package field.
09:37:45 <dcoutts> dankna: yeah, it really should be per-component
09:37:47 <dankna> dcoutts: this would need to be an Executable section field (and, eventually, a Library section field)
09:37:53 <dankna> ah okay
09:38:02 <dcoutts> dankna: BuildInfo is the place you're looking for
09:38:16 <dankna> yes, indeed
09:38:41 <dankna> okay.  in my prototype I'll kludge it and in the real version I'll ... move data-files to BuildInfo?
09:40:09 <dcoutts> dankna: moving data-files to BuildInfo ought to be a separate patch that we can review separately from the app bundle work
09:40:19 * dankna nods
09:40:34 <dankna> okay.  I'll get to it today I expect.
09:40:42 <dcoutts> dankna: what makes it harder (why I've not done it yet) is that we need to preserve compatibility for current .cabal files that have it in the global section
09:41:02 <dcoutts> dankna: and I'm think there's some issue to do with having the data-dir be different for different components
09:41:18 <dankna> hmm.  all right, I'll look at how that behaves currently.
09:41:33 <dcoutts> dankna: since the code to find the data files is shared between all components currently (see autogen/Paths_pkgname.hs)
09:41:43 <dankna> indeed
09:42:11 <dcoutts> dankna: I'm not sure if it makes sense to keep it shared or not
09:42:16 <dcoutts> opinions welcome
09:42:32 <dankna> I don't think it does
09:42:36 <dcoutts> dankna: the --datadir is per-package not per-component
09:42:48 <dankna> hmm
09:42:59 <dcoutts> so all the data files end up copied into the datadir anyway (though respecting any subdir structure)
09:43:47 <dankna> --datadir is the install directory and data-dir: is the source directory?
09:44:11 <dankna> and currently the data-dir: can be different for each component, but the --datadir is global?
09:44:44 <dankna> I'd like to note that with bundles, in principle each component has its own installed location for data files
09:44:55 <dcoutts> dankna: yes, --datadir is the install location for data files (e.g. /usr/local/share/$pkgname-$ver/) data-dir is the root for locating data files
09:45:04 <dankna> right, okay
09:45:25 <dcoutts> dankna: e.g. data-dir: foo/;  data-files: bar/baz, then we find it as foo/bar/baz
09:45:34 <dcoutts> dankna: but install to ${datadir}/bar/baz
09:45:46 <dankna> right
09:46:05 <dcoutts> dankna: so data-dir: is purely to let the data files not clutter the root of the project tree
09:46:24 <dankna> I see that getDataDir is :: IO FilePath
09:46:34 <dcoutts> dankna: and we support running inplace and finding the data files in that datadir in the build tree
09:46:46 <dankna> that's good, because it'll need to make an API call to work correctly on the Mac
09:46:51 <dankna> gotcha
09:46:54 <dcoutts> dankna: like it does on windows
09:47:01 <dankna> yes, all right
09:47:52 <ClaudiusMaximus> @hoogle Ord k => (Maybe a -> Maybe b -> c) -> Map k a -> Map k b -> Map k c
09:47:53 <lambdabot> No results found
09:47:56 <dcoutts> dankna: the location returned by getDataDir can be controled by an env var, that's what allows running inplace and finding the data files in the build tree
09:47:57 <augur> anyone know how d-wave computers work?
09:48:20 <dankna> dcoutts: an env var at configure time or runtime?
09:48:23 <dcoutts> dankna: runtime
09:48:25 <magnicida> hello
09:48:31 <dankna> hmm
09:48:33 <dankna> I see
09:48:35 <dcoutts> dankna: for configure time you use --datadir
09:48:48 <dankna> isn't that a security issue?
09:49:10 <magnicida> does anybody know the best way to read a whole binary file as a list of bool?
09:49:15 <magnicida> lazily...
09:49:24 <dankna> a setuid executable could be tricked into reading data that it thinks was installed with it from a user's home directory instead
09:49:41 <magnicida> i thought of using ByteString but unpack is not lazy ...
09:50:04 <dcoutts> dankna: probably, but setuid progs have to be careful to scrup their env anyway
09:50:11 <dankna> true
09:50:14 <Jafet> concat . map unpack . toChunks
09:50:32 <magnicida> jeffz: that is not lazy
09:50:34 <dcoutts> magnicida: it's lazy for lazy bytestring
09:50:36 <Jafet> Wait, unpack isn't lazy?
09:50:40 <magnicida> nope
09:50:53 <magnicida> or that's what i've read
09:51:21 <dcoutts> npack :: ByteString -> [Word8]
09:51:21 <dcoutts> unpack cs = L.concatMap S.unpack (toChunks cs)
09:51:22 <Jafet> Uh, it is.
09:51:52 <dcoutts> that is, List.concatMap Data.ByteString.unpack (toChunks cs)
09:52:12 <monochrom> there are 2 unpacks. 4 if you take types into account. you know that?
09:52:21 <dcoutts> magnicida: so it's lazy in the chunks, strict within each chunk
09:53:13 <magnicida> dcoutts: ok that is enough for me, I just do not want to have the whole file in memory
09:53:35 <dcoutts> magnicida: right, that's the main advantage that lazy bytestring gives you
09:53:44 <magnicida> dcoutts: I still do not undarstand why just "unpack bs" and i should first convert it to chunks, then concaptMap
09:54:41 <Jafet> Lazy.ByteString is implemented as [Strict.ByteString].
09:54:48 <dcoutts> magnicida: you don't need to do that, if you read the file as a lazy bytestring then you just use unpack
09:55:01 <Jafet> But as dcoutts said, you don't need to know that.
09:55:13 <dcoutts> magnicida: and you don't need to deal with the chunks directly, it's an implementation detail
09:55:21 <magnicida> ok, actually I was already using BS.interact
09:55:28 <magnicida> cool, thanks a lot :D
09:55:54 <magnicida> i was mislead in someoen's stackoverflow post to believe that unpack evaluated everything
09:57:25 <monochrom> two days later, someone else will "I want the whole file in memory, I want it eager, but I've read that unpack is lazy"
09:58:52 <c_wraith> unpack should be lazy even for strict bytestrings. >_>
09:59:04 <monochrom> oh heh
09:59:12 <luite> hmm, I have a function f :: MonadInterpreter m => m () in which I want to evaluate some code, but the evaluation should not be done in the same process. I'd like to use System.Posix.Process.forkProcess :: IO () -> IO ProcessID, but since that just takes an IO action, I cannot use the interpreter there. is there any way around this?
09:59:52 <c_wraith> ....  Interestingly enough, unpack is *strict* for strict bytestrings.  But it should be strict lazily. >_>
10:00:13 <c_wraith> Does that even make sense?
10:00:25 <monochrom> (MonadIO m, MonadInterpreter m) => m () ?
10:00:38 <Jafet> Well, strict bytestring is a flat type
10:00:39 <monochrom> (that is part of a solution)
10:00:41 <luite> monochrom: yeah  MonadInterpreter implies MonadIO
10:01:10 <c_wraith> luite: so your problem is you have an m (), but you need an IO () ?
10:01:13 <luite> so I can just liftIO forkProcess
10:01:17 <luite> the problem is in the other action
10:01:45 <monochrom> you should have some "MonadInterpreter m => m a -> IO a" function
10:01:57 <c_wraith> I doubt there's a function that polymorphic
10:02:07 <c_wraith> You might have to give up being polymorphic in m
10:02:17 <monochrom> I don't doubt. MonadInterpreter is his design. surely he can do it
10:02:53 <c_wraith> well, I suppose you could add runMonadInterpreter to the typeclass
10:02:54 <dcoutts> c_wraith: yes, I've always though it should unpack mostly lazily
10:03:08 <luite> monochrom: oh it's not mine, it's hint, the haskell interpreter
10:03:16 <monochrom> darn
10:03:18 <c_wraith> Yeah, that's what I thought.
10:03:21 <Jafet> In file included from /usr/local/lib/ghc-6.12.3/include/Stg.h:230:0:
10:03:24 <dcoutts> c_wraith: dons benchmarked it and found that unpacking strictly was faster, but what we should do is do it in chunks :-)
10:03:30 <luite> and I don't think it has such a function
10:03:32 <Jafet> Guess I should reinstall ghc sometime
10:03:43 <c_wraith> You need to give up being polymorphic in m, then.  Or else rewrite the library
10:03:49 <luite> and I'd accept unsafeCoerce or other shady solutions :)
10:03:50 <c_wraith> dcoutts: that makes sense
10:04:01 <dcoutts> c_wraith: e.g. stricly in blocks of a few 100 bytes or something
10:04:03 <c_wraith> unsafeCoerce doesn't help you here
10:05:16 <luite> the monomorphic type seems to be InterpreterT IO
10:05:28 <c_wraith> That sounds right, from what I know of hint
10:05:39 <c_wraith> ....  And I've contributed patches to it in the past. :)
10:05:44 <luite> hehe
10:06:10 <luite> it's a ReaderT and ErrorT
10:07:14 <c_wraith> Admittedly, the patches I contributed were for for stuff deep in the internals, not at the interface level. >_>
10:09:30 <monochrom> hint doesn't use monad-peel but it can. monad-peel may offer a more polymorphic solution
10:09:57 <adamcopp> hi folks. I'm writing a MIPS assembler interpreter in haskell, and so far I've got most things working, except memory. in C, I could create a fairly large array and have fast indexes into it. What are my options in haskell for simulating memory
10:10:02 <monochrom> (currently hint uses the special case monadcatchio-mtl)
10:10:47 <Jafet> adamcopp: you don't need to simulate arrays, just use real arrays
10:11:02 <luite> hmm, I haven't used monad-peel before, let me see
10:11:39 <monochrom> it is very abstract, but it is very powerful
10:12:07 <Jafet> import Data.Array.ST (STUArray) -- fast raw arrays
10:13:45 <c_wraith> I don't like MonadCatchIO much.
10:14:23 <c_wraith> It implements a bunch of things wrong...  And when I pointed it out, people went "yep" and then spent several days debating the color the bikeshed should be.
10:15:06 <augur> is it possible to know, for an arbitrary function (mathematically speaking) whether or not it's simply recursive?
10:15:52 <augur> if you know, plox to @lambdabot me a message
10:15:54 <augur> bai
10:16:10 <luite> wait how do I do the monomorphic thing?
10:16:57 <luite> the constructor for InterpreterT is not exported
10:25:21 <luite> c_wraith / monochrom : the code http://hpaste.org/47141/how_to_be_eval
10:26:32 <Jafet> (You named a module Int?)
10:26:46 <luite> yeah that was not an ideal choice, but it's just a benchmark program
10:26:49 <luite> :p
10:28:30 <mekeor> i'm looking for a simple function which replaces a special char with another in a string. is there such a func in an official haskell-module?
10:28:59 <mekeor> i just found http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html but "import Data.String.Utils" fails...
10:29:29 <tg_> luite: by the way, in Simon Marlow's PDF "Parallism and Concurrency in Haskell", he specifically mentions concurrent processes with (time, space) execution limits, and handling/killing them successfully
10:29:58 <luite> c_wraith: the problem is that I want to load a large .hs file in the main program, and then fork new processes for evaluation. so a new runInterpreter would defeat the point of these forks :(
10:30:15 <luite> and I don't know another solution
10:30:44 <luite> tg_: this is a specific issue related to a single ghc primitive and a single library
10:30:56 <tg_> luite: yeah, I actually was't referring to your current problem at all
10:31:08 <tg_> luite: I read some of the hservice /hintservice code last night, and what he was describing looked familiar
10:31:17 <tg_> luite: just unfortunate timing
10:31:34 <luite> tg_: that code is quite outdated now
10:32:04 <luite> tg_: and it's probably the biggest thing that still needs to be done
10:32:07 <physicist> mekeor: wouldn't replace x z =  map (\y  -> if  y == z then z else y) x do
10:32:41 <tg_> luite: ok, nevertheless, you mean be interested in reading http://community.haskell.org/~simonmar/par-tutorial.pdf
10:33:07 <physicist> mekeor: my bad
10:33:53 <dankna> @hoogle </>
10:33:54 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
10:33:54 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
10:33:54 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
10:34:29 <dankna> @hoogle maybe
10:34:29 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
10:34:29 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
10:34:29 <lambdabot> module Data.Maybe
10:35:41 <physicist> it should be                    replace x y z = map (\p -> if  p == x then y else p) z
10:36:50 <physicist> where x is the character you want to replace , y is the one you want to replace it with z is the string
10:36:57 <mekeor> physicist: thx :)
10:38:17 <H_> whois H_
10:42:10 <essag> \whois longh
10:47:16 <monochrom> who is monochrom? :)
10:48:25 <mekeor> :)
10:50:00 <drhodes> does ghc, with some extension, have type functions like .. tfunc Float Int = Double
10:50:44 <monochrom> maybe type family does it. not sure
10:51:08 <luite> hmm, I guess I'll have to modify the hint library then
10:51:11 <drhodes> I've tried reading though tyfun.pdf, it's heavy.
10:51:44 <monochrom> I didn't read a paper. I just read ghc user guide
10:52:42 <magnicida> sorry i have another question
10:52:56 <magnicida> do i loose lazyness by doing reverse . drop n . reverse ?
10:53:11 <monochrom> yes
10:53:38 <mauke> reverse is deeply unlazy
10:53:51 <magnicida> that is whay I expected :p
10:54:04 <magnicida> so is there any lazy way to drop at the end of alist?
10:54:07 <magnicida> ok i am stupid
10:54:11 <magnicida> that is concetually wrong :p
10:55:17 <c_wraith> you can do it semi-lazily
10:55:31 <yrlnry> What is the difference between "lazy" and "lax"?
10:55:44 <mauke> http://i.imgur.com/Wo9hS.png
10:56:13 <magnicida> c_wraith: yep, actually I only need to strictly evaluate N if n is the number i want to drop
10:56:41 <monochrom> if you know the length, you can take (length - n)
10:57:18 <c_wraith> copumpkin has some clever trick for it that's properly lazy
10:57:39 <copumpkin> it's as lazy as it can be, anyway
10:58:22 <copumpkin> oh, you want to drop a specific number of elements at the end of the list?
10:58:32 <c_wraith> yeah
10:59:02 <c_wraith> You had some clever expression that would produce list elements as soon as it had traversed more than that number of values
10:59:12 <copumpkin> hmm, I don't remember that
10:59:18 <copumpkin> I vaguely do actually
10:59:22 <copumpkin> not sure it was me though
10:59:30 * copumpkin thinks
10:59:32 <c_wraith> heh.  maybe not.  It was a while ago
10:59:40 <Jafet> That involves a queue
10:59:56 <c_wraith> the queue doesn't necessarily need to be explicit, though
10:59:59 <Jafet> You can pipe the list through Sequence
11:00:09 <c_wraith> that'll strictify it, won't it?
11:00:13 <copumpkin> Jafet: that's no fun
11:00:15 <Jafet> Oh, maybe
11:00:25 <c_wraith> I'm pretty sure Data.Sequence is strict
11:01:02 <c_wraith> well.  strict in its structure, not strict in the values it holds
11:01:10 <c_wraith> Which, if you're using it as a queue, would be sufficient
11:01:36 <c_wraith> But I think there should be a way to do this with the queue implicit in the structure of the code.
11:02:03 <copumpkin> well
11:02:05 <copumpkin> you could iterate init
11:02:15 <copumpkin> but that's not as pretty
11:02:32 <albel727> a newb question. what is the best way to get help for a symbol? Suppose, I wanna look up what fromIntegral function does, where should I look? Google barely helps, but is there a quicker way? like :help <symbol> or something. I'm using ghci, if that helps.
11:02:50 <yrlnry> hoogle?
11:03:03 <copumpkin> > let dropBack n = iterate init !! n in dropBack 4 [1..10]
11:03:04 <lambdabot>   Couldn't match expected type `[a]'
11:03:05 <lambdabot>         against inferred type `[a1] -> [...
11:03:23 <zerohp> as a fellow newb, I keep this page open in my browser all the time http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
11:03:36 <Jafet> > let ekat n xs = go (splitAt n xs) where go (acc, []) = acc; go (acc, (x:xs)) = go (tail acc ++ [x], xs) in ekat 10 [1..10000]
11:03:38 <lambdabot>   [9991,9992,9993,9994,9995,9996,9997,9998,9999,10000]
11:03:49 <Jafet> But (++)!
11:04:07 <albel727> yrlnry: zerohp: that was very helpful, thanks.
11:04:21 <monochrom> whereas I keep file:///usr/local/haskell-platform-2011.2.0.1/share/doc/ghc/html/libraries/index.html open
11:04:23 <copumpkin> @ty let dropBack n xs = iterate init xs !! n in dropBack 4 [1..10]
11:04:24 <lambdabot> forall t. (Num t, Enum t) => [t]
11:04:25 <zerohp> it should be on your hard drive somewhere as well, its part of the platform
11:04:28 <copumpkin> > let dropBack n xs = iterate init xs !! n in dropBack 4 [1..10]
11:04:28 <lambdabot>   [1,2,3,4,5,6]
11:04:50 <yrlnry> albel727:  You are welcome!
11:05:26 <c_wraith> iterate inits does not feel like it will evaluate only on demand.
11:05:32 <monochrom> docs on someone else's web server are overrated
11:05:36 <copumpkin> c_wraith: why not?
11:05:53 <drhodes> albel727: in ghci you can do,   :t (+)
11:05:53 <longh> albel727: or you could use hoogle: http://www.haskell.org/hoogle/
11:05:55 <copumpkin> > let dropBack n xs = iterate init xs !! n in dropBack 4 [1..]
11:05:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:06:28 <c_wraith> oh, hmm.  you're right.  It doesn't evaluate an of the previous ones.  That works, but it's certainly not pretty. :)
11:06:35 <copumpkin> it's succinct
11:06:49 <copumpkin> but I think we can do better
11:06:57 <c_wraith> it is, but iterate is always kind of scary :)
11:06:58 <albel727> drhodes: yeah, type information is cool, but I knew that already. thank you, in any case. =)
11:07:13 <albel727> longh: yeah, I've already been advised to use it. thanks )
11:08:45 <dankna> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/850 -- I'm not totally sure what the fix should be
11:09:52 <copumpkin> c_wraith: actually, I don't think you can do better
11:10:02 <copumpkin> the trick I was thinking of was for "I want to keep the last N elements of a list"
11:10:25 <copumpkin> without calling length on it
11:10:48 <Jafet> > let splitBack n xs = go xs (drop n xs) where go as [] = ([],as); go (a:as) (b:bs) = first (a:) $ go as bs in splitBack 5 [1..20]
11:10:49 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[16,17,18,19,20])
11:10:59 <Jafet> Walks two pointers down the list
11:11:06 <monochrom> if you construct the list yourself, you can keep track of its length yourself
11:13:13 <c_wraith> time to get out criterion and benchmark :)
11:13:35 <KirinDave> Isn't iterate init xs !! n a very slow thing to do?
11:13:46 <c_wraith> Not really
11:13:59 <Jafet> Only for large inputs
11:14:00 <c_wraith> iterate and !! should fuse
11:14:23 <c_wraith> So it shouldn't create the cons cells
11:14:39 <c_wraith> And so that really just means "call this function on this input n times"
11:14:49 <Jafet> > iterate init [1..1000] !! 990
11:14:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:14:53 <c_wraith> and init should fuse with itself
11:15:01 <Jafet> > iterate init [1..10000] !! 9990
11:15:05 <lambdabot>   mueval-core: Time limit exceeded
11:15:12 <Jafet> Looks quadratic
11:15:13 <c_wraith> ...  I guess it can't fuse with itself
11:15:33 <c_wraith> since build/foldr fusion is compile-time
11:15:42 <Jafet> > let splitBack n xs = go xs (drop n xs) where go as [] = ([],as); go (a:as) (b:bs) = first (a:) $ go as bs in snd $ splitBack 10 [1..100000]
11:15:43 <lambdabot>   [99991,99992,99993,99994,99995,99996,99997,99998,99999,100000]
11:15:44 <KirinDave> How does init produce its output efficiently?
11:15:44 <c_wraith> and the number of times it's called is run-time
11:15:50 <c_wraith> KirinDave: it doesn't
11:16:19 <KirinDave> Because init . init . init [1..99999] seems to me like a pretty cool way to waste time?
11:16:28 <Jafet> For sure
11:16:34 <Jafet> But only for large inputs, as shown above
11:16:37 <c_wraith> I bet if you actually wrote it out, it would be more efficient
11:16:49 <c_wraith> because then it could fuse the inits with each other
11:17:14 <dolio> I doubt there's any rule for fusing inits.
11:17:24 <KirinDave> How do !! and iterate fuse?
11:17:43 <c_wraith> oh, I guess init would need to be written in terms of foldr to fuse
11:18:24 <c_wraith> And I don't see an obvious way to do that efficiently.
11:18:46 <Jafet> You can rewrite init.init to dropBack 2, but I wouldn't call that fusion
11:18:48 <dolio> Well, even if you fuse the foldrs, I suspect calling init K times incurs an O(k) penalty on each element of the output.
11:19:17 <c_wraith> well, yes.  it has to go through that many processing layers.
11:19:21 <dolio> To avoid that, you'd need to do something smarter.
11:20:34 <dolio> Like, write a g_init :: Int -> [a] -> [a].
11:20:47 <dolio> Then g_init m . g_init n = g_init (m + n)
11:22:06 <Jafet> How do I make cabal install build haddocks?
11:24:14 <Jafet> Oh, I need to uncomment documentation: True.
11:25:05 <dafis> dankna: ping
11:25:19 <dankna> dafis: pong, what's up?
11:25:51 <dafis> dankna: have you tried the alternative definitions of MonadicState yesterday?
11:26:52 <dankna> dafis: no, not yet; I got bogged down in actually implementing the TH to do it
11:27:31 <dafis> dankna: okay, if you do it, mind letting me know if it changed anything?
11:27:50 <dankna> dafis: the one that seemed the most promising to me was not the Cont-based one, which I think will just construct a closure as an aggregate type, but rather the one using a second newtype parameter instead of a forall.
11:27:55 <dankna> dafis: yes, absolutely!
11:28:13 <dankna> dafis: it won't be for a couple of days, I decided I needed a break from this and am working on some patches to Cabal now.
11:29:24 <dafis> dankna: I put more hopes into the second newtype too, I won't be looking into it before Sunday either
11:29:51 <dankna> dafis: okay, cool then
11:38:25 <adamcopp> will the STT transformer be safe for use with a data.Map in the state? There's a warning at the top of it's docs saying don't use it with lists, but I'd like to be sure.
11:38:44 <adamcopp> or is having an ST monad high in my monad stack a bad thing?
11:38:59 <c_wraith> STT?
11:39:04 <c_wraith> Does that really exist?
11:39:15 <c_wraith> It's about as sane as IOT would be
11:39:21 <adamcopp> it does on hackage
11:40:07 <c_wraith> well, that note actually means "Don't use STT s []"
11:40:20 <c_wraith> What you store in it isn't important
11:40:25 <c_wraith> what's important is what you wrap
11:40:35 <c_wraith> since wrapping list would lead to all kinds of broken semantics
11:40:52 <c_wraith> Since the list monad models non-determinism and backtracking
11:41:20 <c_wraith> It would completely destroy the safety ST is designed to provide
11:41:29 <c_wraith> ..  Honestly, I wouldn't use STT
11:41:46 <Jafet> Hm, cabal doesn't parse the config file
11:41:48 <Jafet> cabal: Command.optionToFieldDescr: feature not implemented
11:42:06 <Jafet> ...zsh alias tiem
11:42:43 <danharaj> http://hpaste.org/47143/typerr
11:42:47 <danharaj> I don't understand what's going on here.
11:42:55 <jdavis> When I do "Data.ByteString.Lazy.empty" in ghci, it evaluates to "Empty". But where is the constructor "Empty" defined? I want to pattern match against it.
11:43:15 <adamcopp> right. I'd rather avoid it though if it's insane. currently I have "type Mips = StateT Environment (Either MipsError)" for functions which interact with state and may fail or return a result. There's no EitherT, so how would I model this now?
11:43:49 <c_wraith> jdavis: it's in the internal package for lazy bytestrings
11:44:25 <jdavis> c_wraith: so how do I refer to it? Data.ByteString.Lazy.Empty doesn't appear to work.
11:44:55 <Jafet> danharaj: you, uh, unwrapped z and forgot to wrap it back
11:45:06 <c_wraith> jdavis: you need to import the internal package
11:45:12 <danharaj> Jafet: ahahaha d'oh.
11:45:13 <c_wraith> err, .Internal module
11:45:22 * danharaj hits self
11:45:23 * danharaj gets a soda
11:45:47 <jdavis> c_wraith, ok, thanks! Is it bad style to do that? Should I use a guard instead?
11:45:49 <Jafet> jdavis: why do you want the constructor?
11:45:59 <danharaj> I can't read GHC type errors for shit.
11:46:15 <jdavis> Jafet: just trying to pattern-match against it, so that I can use recursion on the list and know when I'm out of bytes.
11:46:42 <c_wraith> jdavis: generally, you should only use the .Internal modules if you're actually doing stuff with the internal representation you can't do without it.  In the specific case of looking for an empty lazy bytestring, you can do that without using the .Internal module
11:46:47 <jdavis> Jafet: I mean "bytestring" not "list", I suppose.
11:46:53 <dafis> jdavis: normally, you shouldn't use the .Internal modules, only if you're doing very low-level stuff that needs them
11:47:12 <c_wraith> jdavis: additionally, you could have an empty lazy bytestring that's not the Empty constructor.
11:47:33 <jdavis> OK, then should I just use a guard like "foo | foo == Data.ByteString.Lazy.empty ..."
11:47:35 <Jafet> jdavis: it sounds like you're using the bytestring as a list
11:47:47 <Jafet> Perhaps you want to unpack it before doing those things
11:48:04 <dafis> jdavis: Data.BS.L.null foo
11:48:21 <c_wraith> jdavis: well, I'd use | Data.ByteString.Lazy.null foo
11:48:36 <jdavis> Oh, ok, that looks better. Thanks.
11:49:00 <Jafet> jdavis: bytestring is a list of (possibly large) chunks. Taking single bytes off the front doesn't sound like a marvellous idea
11:49:10 <jdavis> Jafet: I'd prefer not unpack it until I really need to. I was going to use Data.Binary.Get to do that.
11:49:17 <jdavis> Jafet: oh, I see.
11:49:20 <ben> Huh
11:49:25 <Jafet> (I assume that's what you mean by "recursion on the")
11:49:31 <jdavis> Yes.
11:49:46 <jdavis> Well, not single bytes, but close.
11:50:19 <ben> Dropping bytes off the front sounds pretty cheap?
11:50:40 <ben> You'd make a new strict bytestring that is the old first chunk with a different offset and attach the rest of the old string's list to the end?
11:50:56 * hackagebot hakyll 3.1.2.6 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.2.6 (JasperVanDerJeugt)
11:51:14 <dafis> ben: yup, but that's still a lot of work for one byte
11:52:26 <c_wraith> at least when the front chunk is a couple k
11:52:46 <jdavis> So, should I find a way to use Data.Binary.Get a little more extensively? I don't see examples using it to iterate through a lot of items.
11:53:02 <Jafet> Chunks have offsets? Must've missed that when reading the code
11:53:26 <c_wraith> Huh.  Actually, given the way strict bytestrings work, yeah..  chopping the front byte off of one doesn't copy it
11:53:59 <c_wraith> it only creates a new bytestring constructor, which is a few words.  doesn't need to copy the backing array
11:57:51 <jdavis> Thanks for your help everyone. I'm going to try to rely on the Get monad a little more. It seems like the right way to do it.
11:58:05 <adamcopp> I'm struggling with ST here. Is it possible to use it in the same manner as State, in that I can establish a state, then call a function which manipulates that state, which returns and the state is changed for the parent? All of the examples make  a point of this not being possible :S
11:58:57 <monochrom> fudge with the meaning of "parent"
11:59:41 <monochrom> do { r <- newSTRef True; f r; readSTRef r } where f r = writeSTRef r False
12:00:18 <adamcopp> monochrom: That's valid then? And the result is False?
12:00:23 <monochrom> yes
12:00:47 <Jafet> > let f r = writeSTRef r False in runST $ do r <- newSTRef True; f r; readSTRef r
12:00:48 <lambdabot>   False
12:01:03 <adamcopp> Lovely :) Thanks. The docs are confusing me :P
12:02:27 <Jafet> There's also StateT, but I've never used that
12:03:15 <elliott> When linking a very simple program with GLUT (ghc -package GLUT and ghc --make) both behave identically I get hundreds of errors along the lines of
12:03:16 <elliott> /usr/local/lib/GLUT-2.1.2.1/ghc-7.0.3/libHSGLUT-2.1.2.1.a(State.o): In function `sexz_info':
12:03:16 <elliott> (.text+0xa18): undefined reference to `glutDeviceGet'
12:03:19 <adamcopp> I'm currently using StateT, trying to transition to ST :)
12:03:20 <elliott> with various glut function names in place.
12:03:28 <kl0n> nowplaying
12:03:29 <elliott> What could this mean? I have the glut development libraries installed and everything.
12:03:41 <kl0n> date?
12:14:28 <elliott> cc-options:
12:14:29 <elliott> ld-options:
12:14:30 <elliott> well that does not look right...
12:14:32 <elliott> in my glut package
12:14:47 <elliott> oh, it seems to link with HSGLUT separately
12:14:50 <elliott> hmm
12:16:42 <dankna> @pl (\cSource -> do { deps <- getDeps cSource ; return (cSource, deps) })
12:16:42 <lambdabot> (line 1, column 17):
12:16:42 <lambdabot> unexpected "{"
12:16:42 <lambdabot> expecting variable, "(", operator or ")"
12:16:57 <dankna> @pl (\cSource -> do deps <- getDeps cSource ; return (cSource, deps))
12:16:58 <lambdabot> (line 1, column 41):
12:16:58 <lambdabot> unexpected ";"
12:16:58 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
12:18:40 <Jafet> @undo do deps <- getDeps cSource; return (cSource, deps)
12:18:40 <lambdabot> getDeps cSource >>= \ deps -> return (cSource, deps)
12:18:51 <Jafet> @pl \cSource -> getDeps cSource >>= \ deps -> return (cSource, deps)
12:18:52 <lambdabot> liftM2 (>>=) getDeps ((return .) . (,))
12:18:57 <justfortestingre> do "system" or "runCommand" from "System.Process" run the command int he current-directory?
12:19:07 <dankna> ah thanks :)
12:19:11 <Jafet> Yay, twisty tits combinator
12:19:41 <dankna> justfortestingre: yes
12:19:48 <Jafet> testing: it spawns a shell to run the command, so it does whatever the shell does
12:19:53 <justfortestingre> dankna: thx
12:20:01 <Jafet> (the shell is spawned in the current directory)
12:20:19 <mekeor> Jafet: thanks very much
12:20:46 <mekeor> and moreover, whats the difference between system and runCommand? which's recommended?
12:21:02 <Jafet> :t (system, runCommand)
12:21:03 <lambdabot> Not in scope: `system'
12:21:03 <lambdabot> Not in scope: `runCommand'
12:21:12 <Jafet> Er, d'oh
12:21:23 <saati> that would be a nice sechole:D
12:21:55 <mekeor> whats a sechole?
12:22:02 <saati> security hole
12:22:05 <Jafet> > print ":-)"
12:22:06 <lambdabot>   <IO ()>
12:22:07 <mekeor> ah, ok
12:22:11 <Jafet> Not really
12:22:41 <mekeor> which should i use?
12:22:45 <saati> running arbitrary commands on an i presume linux? few seconds to root.
12:22:52 <Jafet> mekeor: it seems that runCommand is non-blocking
12:23:09 <mekeor> Jafet: blocking what?
12:23:15 <Jafet> saati: you mean few seconds to chroot
12:23:29 <saati> i am sure there is an exploit for that too
12:23:32 <Jafet> mekeor: blocking your process.
12:24:24 <Jafet> saati: but mu-eval doesn't even execute IO, as shown above
12:24:28 <stulli> I made a newtype PicURL = PicURL URL, now i always have to do sthg like 'liftM PicURL $ importURL "foo"' when i want to use function on 'normal' URLs. Is there a way around this or is it good practice?
12:25:01 * hackagebot canonical-filepath 1.0 - Abstract data type for canonical file paths.  http://hackage.haskell.org/package/canonical-filepath-1.0 (ThomasSchilling)
12:25:45 <Jafet> stulli: well, the point of making a newtype is to force you to do that
12:25:45 <saati> Jafet: i see
12:26:02 <Jafet> If you don't want to box and unbox URL left and right, make PicURL a type synonym
12:26:55 <mekeor> if i do sth like
12:26:55 <mekeor> runCommand "foobar" >> exitWith ExitSuccess
12:26:56 <mekeor> in my program called "test", does "test" exit before "foobar" has exited?
12:27:30 <Jafet> It could.
12:27:37 <mekeor> ?
12:27:57 <stulli> Jafet: I want PicURL and GalleryURL to be different types so i can't mix them so i didn't use type synonyms. The lifting just got a bit tedious and i was wondering if there is some magic which makes it easier.
12:28:25 <Jafet> Well, what kind of magic do you want?
12:29:24 <stulli> Maybe making the GalleryURL type so that there is somehow automatic lifting when needed
12:29:42 <Jafet> Also liftM is (<$>)
12:30:15 <stulli> or i'll mirror the functions i need with additional lifting
12:30:34 <stulli> Oh, that's nice
12:34:31 <Jafet> I'm fairly sure GHC doesn't give you implicit type coercion of any sort
12:35:00 <Jafet> Even if (especially if?) it's to reduce syntactic noise
12:36:05 <pozic> Jafet: you mean by default?
12:36:43 <Jafet> I mean by default?
12:37:04 <pozic> Jafet: I don't know. Do you?
12:37:22 <pozic> Since you can pretty easily model PHP semantics in GHC Haskell.
12:38:03 <stulli> Jafet: The more i think about it the more it makes sense. I'm now restructuring my code so i don't need the lifting too much.
12:38:27 <pozic> E.g. 1 + "2" could easily have type String or Int, or some trivial generalization of that.
12:38:54 <sshc> How is (x -> y) isomorphic to (a -> x) -> (a -> y)?  The "to" mapping, from the former to the latter, is obviously composition: to f = (f .)  or  to f = (>>> f).  This can be applied to, for example from "[Integer] -> Maybe Integer" to "(String -> [Integer]) -> (String -> Maybe Integer)" by a function that takes a string (this can work for any value), gives it to the function, and applies the
12:38:56 <Jafet> Well, you can make a class ConvertsToGalleryURL
12:39:00 <sshc> output of that to the original function (the [Integer] -> Maybe Integer one) to get Maybe Integer.  But how does this work the other way?  That is, taking (a -> x) -> (a -> y) back to the original (x -> y) (such that the composition of the two mappings is equivalent to id)?  I can't think of a function "((String -> [Integer]) -> (String -> Maybe Integer))  ->  ([Integer] -> Maybe Integer)".
12:39:16 <Jafet> But that's just asking for it
12:40:05 <dafis> sshc: (x -> y) isn't isomorphic to (a -> x) -> (a -> y)
12:40:39 <dafis> (unless you ignore seq and bottm, and a is a one-element type, in which cas (a -> x) ~ x)
12:40:44 <dafis> case*
12:40:51 <dafis> bottom*
12:41:52 <sshc> Then I think I'm misunderstanding the Yoneda lemma, as described in TMR issue 13
12:41:57 <sshc> dafis: one-element type?
12:42:22 <dafis> sshc: ()
12:42:40 <dafis> terminal object in Set
12:42:45 <AnAdorableNick> I see
12:44:44 <sshc> dafis: Terminal object is an object such that, for every other object, there exists exactly one morphism from the other object to the terminal object, right?
12:44:53 <dafis> right
12:45:59 <sshc> dafis: "GeneralizedIso (→) (∀ a.arr a x → arr a y) (arr x y)"
12:46:49 <dafis> sshc: ? (sorry, don't know CT above what everybody needs)
12:46:55 <sshc> dafis: The paper provides a definition for "yoneda :: ∀ arr x y.(Category arr) =>  GeneralizedIso (→) (∀ a.arr a x → arr a y) (arr x y)"
12:51:48 <mekeor> robinhoode: good morning :)
12:52:42 <robinhoode|away> mekeor: Good morning! But no time now.. Must write code...
12:52:58 <mekeor> oO -- have fun ;)
12:53:16 <sshc> I think the universal quantifier (the upside down A symbol representing "forall" in Haskell) might be relevant..
12:54:32 <dafis> sshc: Yoneda talks about natural transformations, you've somehow lost that, http://en.wikipedia.org/wiki/Yoneda_lemma might help disentanglng this
12:57:56 <NemesisD> eekTheCat: ping, you around?
13:05:08 <Jafet> Hm, lambdabot isn't supposed to build on ghc7.
13:05:29 <Jafet> Is it hard to fix that, or has no one bothered?
13:05:45 <Jafet> /tmp/ghc23972_0/ghc23972_0.s: Error: .size expression for PluginziPlziCommon_operators19_entry does not evaluate to a constant
13:11:16 <tg_> can some take a look at: http://hpaste.org/47144/remove_prelude_import_warning
13:11:20 <tg_> I just want to remove the compiler warning
13:11:58 <tg_> MPPPC.Printable has a class Printable in it which has a "replicate" type
13:12:16 <c_wraith> with that version of GHC, you can't silence that warning
13:12:20 <c_wraith> It's just plain wrong.
13:12:29 <tg_> c_wraith: that I can't silence it?
13:12:38 <c_wraith> But it's only 6.12 that emits that warning wrongly
13:12:49 <tg_> I'm using 7.0.3?
13:12:49 <c_wraith> 6.10 and 7.0 don't
13:13:06 <c_wraith> Oh, they didn't fix it?
13:13:09 <c_wraith> fun
13:13:13 * tg_ shrugs
13:13:23 <c_wraith> but yes, that warning is just plain wrong.  ignore it
13:13:29 <tg_> that makes me sad :(
13:13:33 <tg_> but ok, it's a warning for a reason
13:13:53 <Jafet> -Wall is just bricked.
13:14:13 <tg_> just out of curiousity, is three a way to mask that warning in the build?
13:14:24 <c_wraith> It's a warning because the thing that calculates when to display that warning message doesn't take into account hiding clauses
13:15:14 <tg_> c_wraith: yeah, that makes sense - I was saying, it's *only* a warning so I ought not get hung up about it
13:15:30 <tg_> I am, as an exercise, trying to understand (and document) someone else's fully undocumented code :o
13:16:18 <dafis> tg_: you could probably silence it with {-# OPTIONS_GHC -fno-warn-unused-imports #-} (or however the wrning is actually called)
13:17:14 <tg_> dafis: that worked exacly! cheers!
13:17:14 <Jafet> Why silence it?
13:17:32 <tg_> Jafet: because I'm a noob and I want all of the warnings to be my own doing
13:17:39 <dafis> Jafet: if it's wrong, that would be a good reason
13:22:20 <Jafet> Hm, lambdabot builds now.
13:25:22 <dafis> tg_: Maybe the module doesn't actually use anything from the Prelude, does it compile with "import Prelude ()"?
13:25:29 <flinstone> Hey gusy, Should i use haskell for science research? for example in nanotechnology?
13:25:35 <flinstone> guys
13:26:02 <mnslaww> do haskell regexp's support match groups? i can't find any good tutorials/documentation on them
13:26:16 <dafis> @faq Can Haskell help in scientific research, e.g. nanotechnology?
13:26:16 <lambdabot> The answer is: Yes! Haskell can do that.
13:26:44 <tg_> Jafet: yes, I built it yesterday
13:26:48 <tg_> Jafet: there are some patches though!
13:27:01 <tg_> Jafet: and I still can't get Plugin.Pl* to work
13:27:18 <Jafet> Why doesn't it work?
13:27:30 <tg_> Jafet: hundreds of errors about something not evaluting to a constant
13:27:45 <tg_> shall I get an example for you?
13:27:57 <Jafet> Remove via-C
13:28:10 <Jafet> (that makes it compile, at least)
13:28:15 <tg_> well, I got it to compile
13:28:15 <dafis> mnslaww: I think most everything is supported by one or the other regex package, but the docs are lacking
13:28:21 <tg_> by just not including the entire Pl plugin chan
13:28:22 <tg_> chain
13:28:30 <tg_> (i just removed it from the Modules.hs)
13:28:36 <mnslaww> any pointers on where to go to find info?
13:28:41 <tg_> what do you mean "via-C"?
13:28:43 <Jafet> Then again, I don't know why it uses via-C, so it might not actually work.
13:28:44 <mnslaww> or suggestions about which regex to use?
13:29:09 <dafis> @google haskell regex tutorial
13:29:11 <lambdabot> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
13:29:11 <lambdabot> Title: teideal glic deisbhéalach » Blog Archive » A Haskell regular expression tutor ...
13:29:12 <Jafet> Pl/Common.hs turns on -fvia-C. I turn it off and it compiles.
13:29:29 <dafis> mnslaww: I think that one is useful
13:29:56 <tg_> Jafet: ok let me try to rebuild. Did you get the patches for the State files?
13:30:10 <Jafet> There are patches?
13:30:43 <tg_> Jafet: yeah, it won't run without them
13:31:08 <tg_> Jafet: http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/89409
13:31:37 <Jafet> That's dandy. I wonder why they don't just update the package.
13:32:01 <tg_> Jafet: *shrug*
13:32:10 <flinstone> Where is diffrence between comuter researcher and developer?
13:32:12 <tg_> Can someone tell me what tools or scripts are handy for messing with cabal stuff?
13:32:36 <tg_> flinstone: Steve Ballamer wants 9 of latter for every 1 of the former
13:32:45 <Jafet> Perhaps we could just ask the listed author, maintainer, or package uploader of lambdabot
13:32:54 <Jafet> All three of them are in this channel!
13:33:19 <tg_> Jafet: i think dons was one of them, I don't want to bother patriarchs.
13:37:06 <flinstone> I have problem i do not know how to start programming in nanotechnology
13:37:15 <flinstone> i do not know what they need
13:37:25 <c_wraith> very small things
13:37:27 <flinstone> modeling,machine learning
13:37:36 <flinstone> AI?
13:37:52 <tg_> flinstone: one does not program their way into nanotechnology
13:38:12 <flinstone> ((
13:38:31 <tg_> but, if you want to be a programmer who is useful to experts in nanotechnology
13:38:37 <flinstone> Where to start
13:38:45 <jmcarthur> programming is a good start
13:38:56 <flinstone> jmcarthur, hey yes i know
13:39:06 <tg_> http://www.nano.gatech.edu/
13:39:07 <tg_> ask those people
13:39:14 <flinstone> thank y
13:40:20 <flinstone> There are no portals like stackoverflow for nonanoscience? or popular portals for scientists?
13:41:15 <jmcarthur> i have never even heard of beginning programmers specifically choosing nanoscience as a goal
13:42:48 <flinstone> jmcarthur, yes developers often choose web or winforms, or programming tools like COMPILEr,ORM
13:43:02 <flinstone> jmcarthur, i am not standart developer :-)
13:43:30 <jmcarthur> in fact, i don't even know any programmers doing nanotech
13:43:35 <jmcarthur> ;)
13:43:47 <flinstone> jmcarthur, i saw a few computer science projects-thy all written very bad
13:43:52 <jmcarthur> i say that just to demonstrate that your questions are difficult to answer
13:44:08 <flinstone> cs projects for scientists(in chemistry etc)
13:44:08 <jmcarthur> s/demonstrate/show/
13:44:36 <flinstone> jmcarthur, yes i agree it is difficult question :-)
13:44:46 <saati> you want to create simulations?
13:44:46 <mnslaww> dafis: that one doesn't cover match groups, which is the feature i'm looking for :-(
13:45:28 <flinstone> saati, simulation or anything else. I know that peoples use machine learning in cancer research etc
13:46:44 <mnslaww> anyone know of which package/tutorial to look for with respect to regex match groups?
13:46:51 <dafis> mnslaww: sorry, then perhaps the haskell wiki? or the hard way, dig through all the haddocks of regex* (yuck)
13:47:10 <jmcarthur> regex is uncommon in haskell
13:47:31 <saati> what is commonly used in it's place?
13:47:32 <dafis> writing parsers is easier
13:47:40 <flinstone> saati, so i think there are ways to create nanomaterials and scientistc can predict which properties would be in nanomaterial(if process, or ingredients will be X)
13:48:13 <mnslaww> i'm trying to write something that matches URLs for a webapp
13:48:25 <mnslaww> and lets the programmer specify parameters as regexes
13:48:29 <flinstone> software will automate this task and should predict best process conditions and ingredients
13:48:46 <mnslaww> "/page/([a-z]+)" for example
13:49:00 <mnslaww> is there a more haskell-way to do this?
13:49:37 <saati> flinstone: do you know enough of the sciences involved to make simulations?
13:49:49 <saati> i don't think #haskell can help you much in that part
13:51:09 <flinstone> saati, no but i can learn it :-)
13:51:27 <monochrom> captcha yesterday, nanotech today?
13:51:34 <flinstone> saati, so you think i should learn nanotech first?
13:52:28 <flinstone> monochrom, capcha i want break with machine learning(neural networks) i think machine learning can be useful in nanotechnology too
13:52:52 <jmcarthur> i would just learn neural networks in isolation of nanotech
13:53:06 <flinstone> jmcarthur, yes i already know it
13:53:13 * hackagebot splot 0.1.16 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.16 (EugeneKirpichov)
13:53:14 <flinstone> and use WEKA
13:53:45 <monochrom> at this rate you will have wondered about 1000 projects next year and started none
13:53:52 <flinstone> Is it link for me?
13:54:20 <jmcarthur> no that's just new stuff on hackage that gets announced
13:55:03 <flinstone> monochrom, which rate?
13:55:25 <monochrom> your rate of wondering about projects
13:55:28 <flinstone> so you think i do thomething wrong now?
13:55:38 <monochrom> no
13:57:23 <flinstone> What is the best opinion for computer research(IMHO) 1. Already exist open source lib 2. Good books 3. Easy to find application for it
13:57:52 <flinstone> So i learned WEKA and now want to find application, where i can implement my knoledge
13:59:05 <flinstone> monochrom, Nanotechnology in Russia is mainstream :-) this industry have greate PR and finance
13:59:47 <flinstone> so it is the reason why i am looking for computer science applications in nanotechnology
14:01:12 <physicist> I want  to draw some graphs using plot. Currently I can do this by writing figures them to disk but I want to present them without writing them to disk. Any help?
14:02:59 <monochrom> indeed plot doesn't seem to require a file at all. just a function
14:03:42 <physicist> what function?
14:03:52 <monochrom> a haskell function you want plotted
14:04:19 <monochrom> "fs = sin . (15*2*pi*)" "test_graph = do .... fs ...."
14:04:21 <physicist> plot gives me figure () but it does not plot it
14:05:17 <physicist> I can't put something with type figure () in main
14:05:19 <monochrom> I see, add plot-gtk
14:05:45 <monochrom> "A figure is preprocessed in preparation for rendering by the Cairo renderer. The Cairo library can be used to output the figure to PS, PDF, SVG, and PNG file formats, or to display the figure in a GTK Drawable context. (see package plot-gtk)."
14:07:06 <physicist> display seems to be what I need
14:07:08 <physicist> thanks
14:08:14 <Jafet> Heh, the package is more screwed up than I imagined.
14:08:36 <Jafet> There's a bunch of undelivered messages in State/tell
14:11:06 <mekeor> i want to execute a process (namly "grep") and want to get its output in a string. how to do so? -- which function can i use for this?
14:11:09 <flinstone> What i think about Hakell(IMHO) It is not popuplar in business application and maybe it is popularin for scientists, but looks like scientists choose another language
14:11:30 <mekeor> i couldnt find such a func in System.Process
14:12:05 <melker> hello worl
14:12:06 <melker> d
14:12:09 <melker> ;)
14:12:11 <mekeor> :)
14:12:24 <monochrom> you get a Handle. you can hGetContents it for String
14:12:52 <melker> so is it worth while learing haskell?
14:13:14 <monochrom> a Handle is preferred so you can choose encoding, decoding, decompression, even using bytestring instead of string
14:13:20 <hpc> no; we just hang around for the food
14:13:24 <hpc> :D
14:13:29 <melker> the tutourial sure is fun, but what is in the scope of haskell in terms of usage
14:13:37 <melker> hpc lol
14:13:47 <mekeor> monochrom: cool
14:13:52 <melker> what food btw?
14:14:04 <parcs> melker: haskell is lexically scoped
14:14:21 <melker> and by that you mean?
14:14:49 <mekeor> monochrom: so, how to get a string out of a "ProcessHandle"?
14:14:55 <melker> explicar por favor mr parcs
14:15:04 <monochrom> not ProcessHandle. Handle
14:15:26 <saati> melker: http://en.wikipedia.org/wiki/Scope_(computer_science)
14:15:56 <DukeDave> Hey gang, is there a nice way to kill main in ghci, I have an opengl window open, but when I close it ghci exits as well, rather than just terminating main.
14:16:00 <mekeor> monochrom: so, i could e.g. use [[ runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle) ]] ??
14:16:07 <monochrom> yes
14:16:59 <monochrom> sometimes ctrl-c kills main
14:17:37 <melker> well thanks ;) I meant scope as in the future for haskell though
14:17:45 <DukeDave> monochrom: It just echos "^C" in ghci :(
14:18:03 <tg_> Jafet: did you compile and run it?
14:18:08 <tg_> s/it/lambdabot/
14:18:28 <Jafet> Yes, following the State patch.
14:19:55 <Lemmih> @seen gwern
14:19:55 <lambdabot> Unknown command, try @list
14:19:55 <preflex>  gwern was last seen on #xmonad 1 hour, 35 minutes and 10 seconds ago, saying: beleive it's in the FAQ
14:20:55 <tg_> Jafet: I'm getting an error about State in Pl/Transform.hs?
14:20:57 <melker> Im sorry if I sound tarded but what makes haskell worth learing? is it for mathematical programming?
14:21:28 <mauke> melker: what languages do you already know?
14:21:59 <Jafet> tg: steps to reproduce?
14:22:01 <melker> not much, java, some c, matlab (if u consider that a language)
14:22:18 <tg_> Jafet: cabal clean && cabal install
14:22:30 <tg_> Jafet: I deleted the -via-C pragma
14:22:39 <Jafet> You still can't compile it?
14:22:48 <Jafet> It worked for me™
14:22:51 <tg_> nope, it gets through Pl.Common and stops on Pl.Transform
14:23:18 <mauke> melker: I'd say Haskell is much more fun than Java or C
14:23:34 <Jafet> Why would compilation depend on State/, that's a weird way to organize stuff
14:23:37 <mekeor> mauke: i agree
14:23:39 <tg_> Plugin/Pl/Transform.hs:75:10 and 75:21 "Not in scope: data constructor State"
14:23:51 <melker> :D
14:23:54 <mauke> you get a good type system, no manual memory management, flexible code
14:24:14 <melker> that's always something, but what fun can I have with it?
14:24:18 <saati> and type inference, that saves you tons of boilerplate
14:24:19 <tg_> melker: my favorite reasons is this
14:24:30 <mauke> saati: that's included in "good type system" :-)
14:24:36 <mekeor> how do i write down a newline-character i HS-code? '\n' doesnt work…
14:24:44 <mauke> mekeor: yes, it does
14:24:46 <Jafet> @index State
14:24:46 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.
14:24:46 <lambdabot> Parsec, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
14:24:53 <tg_> it's been true for 30 years now, that the most optimal (efficiency wise) way to make some computer code to do something, was to write it in C, possibly with some things in ASM.
14:24:54 <monochrom> > '\n'
14:24:55 <lambdabot>   '\n'
14:24:58 <monochrom> works
14:25:03 <monochrom> > ord '\n'
14:25:03 <lambdabot>   10
14:25:06 <monochrom> is correct
14:25:07 <tg_> For the first time ever, that might not be true any longer
14:25:20 <mekeor> ok
14:25:29 <djahandarie> tg_, it's pretty much still true.
14:25:31 <melker> so is it fast?
14:25:32 <Jafet> tg_: that's only been true on a number of popular platforms
14:25:34 <mekeor> hmm, thx anyway :)
14:25:48 <tg_> djahandarie: well, the key change is the emergence of two fats:
14:25:52 <Jafet> (And of course, those platforms are designed to run C well.)
14:25:56 <melker> is it good for symbolic handling of mathematical functions?
14:25:57 <tg_> djahandarie: one, mandatory multicore
14:26:09 <mauke> melker: I haven't tried that yet
14:26:20 <tg_> djahandarie: two, much smaller lines-of-code per performance gained (vs. C)
14:26:27 <monochrom> haskell is just a programming language
14:26:28 <melker> aight
14:26:29 <mauke> melker: I've got a window manager and an irc bot written in Haskell
14:26:59 <tg_> that is, if you treat C as an asymtope (you can never beat it), then you have to characterize the different ways to approach the curve - one is in simplicity of syntax/semantics and LOC vs. % slower
14:27:03 <Jafet> Haskell is just the standardized, compiler-indepedent language you use to program GHC.
14:27:19 <melker> GHC?
14:27:21 <djahandarie> tg_, I'm not really sure what you're trying to say.
14:27:34 <mauke> melker: ghc is the "standard" haskell compiler
14:27:43 <mauke> it generates native code
14:27:57 <melker> native?
14:28:01 <tg_> djahandarie: that haskell/GHC can often get to ~ 90% as fast as the most optimum code, but without some complexity and with type safety
14:28:12 <mauke> melker: as in, not a bytecode that requires a VM to run
14:28:25 <djahandarie> tg_, I guess I misinterpreted 'efficiency wise' then.
14:28:25 <melker> ah, like dll?
14:28:29 <tg_> s/most optimal code/most optimal performance/
14:28:38 <mauke> melker: more like .exe
14:29:10 <melker> ok, had someone explain dll the other day and just put it out there ;)
14:29:39 <melker> ok I see. but why would u wanna program in haskell as opposed to say java?
14:30:00 <monochrom> more succint
14:30:07 <monochrom> more refactorings
14:30:17 <ben> The community is friendlier
14:30:24 <mauke> melker: because java pisses me off
14:30:28 <monochrom> better types
14:30:30 <melker> ben, I noticed ;)
14:30:42 <mauke> I hate its verbosity and its type system and its lack of functional abstraction
14:30:56 <Jafet> I wonder if people would stop spelling "you" as "u" if they realize it makes them sound like Prince.
14:31:05 <saati> new ReallyLongClassName anotherLongIdentifier = UnbelievablyLongSubClassName(tons of arguments) -- that's why you don't want to code java
14:31:11 <ben> who's prince?
14:31:18 <mauke> and the stupid java interpreter that takes a class name instead of a file
14:31:23 <djahandarie> ezyang, you should migrate to a different host :p
14:31:37 <bd_> saati: You're missing a few factory classes there ;) And win32 is pretty bad too...
14:31:42 <monochrom> try not to pronounce "you" or "u". then it will not sound like prince. at worst look like prince.
14:31:55 <melker> can u make classes in haskell?
14:31:58 <dafis> ben: was a musician way back in the eighties
14:32:14 <monochrom> no
14:32:15 <melker> ben either you young or old ;)
14:32:25 <ben> young :)
14:32:35 <dafis> get off my lawn!!!
14:32:45 * dafis old
14:32:50 <ben> I'm gonna be amazed if 80s celebrities start showing up in #haskell though
14:32:54 * djahandarie wonders how ben has not heard of Prince
14:33:12 <Jafet> No lawns here, only field extensions
14:33:15 <mauke> ah, the artist formerly known as "the artist formerly known as \"prince\""
14:33:21 <melker> can you make haskell work on objects defined in other languages?
14:33:30 <monochrom> yes
14:33:31 <dafis> djahandarie: perhaps he knows him as symbol or TAFKAP
14:33:33 <mauke> melker: only C, really
14:33:53 <mauke> using C libraries in Haskell is pretty easy though, compared to most other languages
14:34:01 <melker> aha ok, and in C you cant have classes right?
14:34:06 <mauke> yes
14:34:16 <mekeor> a func returns me a 'IO String'. But i just want the String and i still dont understand how do to so! :(
14:34:34 <mauke> mekeor: you register a callback on the IO String that calls you with the String once it has one
14:34:48 <ben> woah
14:34:51 <mekeor> ???
14:35:10 <dankna> instance Monoid CDialect where.... am I insane? :)
14:35:10 <mauke> the_IO_String >>= your_function
14:35:32 <tg_> Jafet: now I'm confused how yours built... I built it earlier by removing Pl.hs and Plugin/Pl/*
14:35:36 <mekeor> mauke: and whats the type of the_IO_String now?
14:35:44 <Jafet> dankna: that would be a very, very interesting Monoid
14:35:46 <mauke> mekeor: IO String
14:35:55 <ddarius> You're so sneaky mauke.
14:36:02 <mauke> inorite
14:36:02 <dankna> Jafet: I'm actually writing it - to go in Cabal, hopefully
14:36:33 <dankna> Jafet: note that by dialect I just mean C, C++, ObjC, or ObjC++.  I don't (yet) have to deal with revisions of the language standards.
14:36:55 <mekeor> mauke: and whats your_function?
14:36:55 <Jafet> tg: dike out via-C, patch State and build.
14:37:01 <mauke> mekeor: your function
14:37:16 <mekeor> mauke: the function which gives me a IO String?
14:37:24 <Jafet> dankna: er, what is it exactly?
14:37:26 <ddarius> mauke: If I didn't know better, I'd almost have taken mekeor's second question as a joke.
14:37:54 <mauke> mekeor: no, the function you write to process the String
14:38:03 <tg_> Jafet: I bet you built from darcs repo, didn't you?
14:38:04 <dankna> Jafet: as I wrote in the haddock, The Monoid instance expresses backward compatibility, in the sense that 'mappend a b' is the least inclusive dialect which both 'a' and 'b' can be correctly interpreted as.
14:38:11 <mekeor> mauke: PERFECT -- i understand
14:38:13 <mekeor> thanks
14:38:16 <Jafet> tg: there's a darcs repo?
14:38:25 <tg_> Jafet: http://code.haskell.org/lambdabot
14:38:32 <tg_> the Transform.hs looks totally different there
14:38:33 <Jafet> (in other words, no)
14:38:51 <Jafet> (do I win something?)
14:38:53 <tg_> and Common.hs doesn't have that pragma
14:38:55 <melker> so Im doing the tutourial now, is that like a consol?
14:39:02 <tg_> Jafet: yeah, I guess I gotta checkout using darcs now. :|
14:39:36 <melker> could I reuse stuff like let "add1 x = x + 1 in add1 5"
14:39:42 <Jafet> dankna: hm, your mappend isn't going to be total then
14:39:51 <tg_> Jafet: someone needs to have their hands slapped for not uploading this to hackage :O
14:40:06 <melker> define add1 x=x+1 and then use add1 3 or what ever
14:40:17 <dankna> Jafet: it actually is, the dialect ObjC++ exists solely to make it so
14:40:26 <melker> when I write script like code
14:40:44 <Jafet> mappend C C++ isn't in that set though
14:40:52 <dankna> mappend C C++ is C++
14:41:07 <ddarius> C is presumably the unit.
14:41:11 <dankna> indeed
14:41:31 <danharaj> C and C++ aren't compatible though.
14:41:39 <dankna> welllllll, that's true
14:41:47 <dankna> I only need this for header files, though
14:41:48 <Jafet> But Who Cares.
14:42:17 <dankna> specifically what I'm doing is fixing http://hackage.haskell.org/trac/hackage/ticket/850 if anyone is curious
14:42:28 <ddarius> As little as I liked Sun,  Oracle owning Sun is even worse.
14:42:39 <dankna> I'm fixing it by inferring the dialect of C that each header file belongs to
14:42:59 <aristid> ddarius: how does it matter to you
14:43:22 <dankna> which I do by looking at which files include it (as reported by gcc's makedep mode) and inferring the dialects of /those/ files, based on their file extensions
14:45:17 <flinstone> Zre there any computer science researchers?
14:45:31 <flinstone> just want to talk
14:47:41 <flinstone> flinstone, WAKE UP :-)
14:48:10 <ddarius> aristid: Because now when I need to deal with Java annoyances, I now also get to deal with Oracle annoyances, and Oracle is more annoying than Sun or Java.
14:49:16 <ameedxy> how to put a string on a screen coordinate ?
14:49:59 <ddarius> Aren't there strings already at the coordinates of a screen?  Isn't that what makes it a screen?
14:51:23 <ameedxy> ddarius:  e.g. the string ***** in the right corner
15:01:53 <melker> anyone doing mathematical stuff in haskell?
15:02:28 <applicative> what do you think of a 'mathematical'?
15:03:29 <tg_> mlh: beware, that person's name is a 'mathematical', so he's probably serious!
15:03:38 <tg_> s/mlh/melker/
15:04:09 <applicative> melker, have you looked into haskell much, or studied it?  just wondering so people can understand.
15:05:28 <melker> no not really, been reading some at the homepage. but dont really get much of it...
15:05:58 <applicative> do you study mathematics?  again, just trying to figure out where you're coming from...
15:06:03 <erus`> melker: its not really a mathematical language. You should look into Visual Basic
15:06:09 <djahandarie> erus`, O.o
15:06:25 <melker> like graph theory, symbolic handling of functions, linear algebra etc
15:07:41 <melker> erus, u kiddin me?
15:07:47 <Kaidelong> there are libraries for all of those melker
15:08:03 <applicative> there are those things yes, I'm not sure they bring out the mathematical charms in haskell way more than in other languages.
15:08:14 <applicative> erus` is kidding you
15:08:15 <erenrich> is there a way to force a functor to accept functions only of a certain type (mapping to a specific type)
15:08:30 <erus`> i kid, i kid
15:08:43 <melker> so you are the funny man
15:08:45 <melker> ha
15:08:55 <Kaidelong> well there are some examples where the language really does help
15:08:58 <applicative> erenrich: wait, you want a functor where fmap f ___  is always e.g. Integer?
15:09:00 <Kaidelong> like with conal's ad stuff
15:09:26 <applicative> I was going to mention ad; that is very beautiful and haskelly.
15:10:27 <erenrich> applicative: well yeah. if the underlying data type cannot hold certain data types
15:10:39 <applicative> melker you might take a look at conal's blog, also of course sigfpe just to get an idea of some of the mathematical ideas abroad.
15:10:58 <melker> okej thanx
15:11:16 <conal> melker: and if you have questions, you can often catch me here.
15:11:21 <conal> applicative: thx for the plug.
15:11:27 <melker> xD
15:11:38 <applicative> http://conal.net/blog/  http://blog.sigfpe.com/
15:11:42 <applicative> conal is here.
15:12:49 <mekeor> oO -- cool
15:13:26 <melker> does there exist newton solvers written in haskell? how do or would they compare to solvers written in c?
15:14:44 <mlh> melker: google found this http://hackage.haskell.org/packages/archive/species/0.3.2/doc/html/src/Math-Combinatorics-Species-NewtonRaphson.html
15:15:25 <mlh> er .. description here : http://hackage.haskell.org/packages/archive/species/0.3.2/doc/html/Math-Combinatorics-Species-NewtonRaphson.html
15:15:26 * ddarius thinks that that will be something rather different in the particulars.
15:15:46 <Favonia> melker: (for a previous comment) technically speaking, you can model Java's inheritance & interfaces (subtype polymorphism), generics (parametric polymorphism, sort of) and other stuffs by powerful typeclasses.
15:15:48 <Favonia> you might be interested in this page: http://www.haskell.org/haskellwiki/OOP_vs_type_classes
15:15:50 <Favonia> however in my opinion type classes can do more wonder that is hard to accomplish by popular OO PLs. also automatic type inference of Haskell can make your life easier too
15:16:45 <melker> thanks :D
15:18:03 <melker> can you wrap haskell code in python?
15:18:04 <mlh> worth mentioning http://www.haskell.org/hoogle/ perhaps -- for searching though oddly it didn't find NewtonRaphson
15:18:48 <mlh> Ik weet it niet
15:19:30 <applicative> can't go wrong with augustss blog either http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
15:19:37 <melker> Ik weet it niet either, hence I ask
15:19:52 <melker> jag vet det inte
15:20:31 <mlh> yeah I was being silly, you can with a lot of effort, but if you're asking whether it's easy or there's an existing lib, probably goog or hoog is your friend
15:21:00 <melker> These bindings allow Haskell code to call CPython code. It is not currently possible to call Haskell code from CPython, but this feature is planned.
15:21:05 <melker> thank you google
15:21:10 <melker> hoogle even
15:21:15 <mlh> :-)
15:21:31 <melker> Im learning you see ;)
15:21:52 <mlh> you probably knwo more than me then
15:22:10 * mlh is neither a mathematician or a haskeller
15:22:24 <melker> what are you then?
15:22:26 <mlh> though I did a bit of category theory at uni
15:22:32 <melker> dutch?
15:22:40 <mlh> I'm a unix admin .. technical dilettante
15:22:46 <mlh> nah, Australian
15:22:59 <melker> speak dutch though?
15:23:04 <melker> or was it africaans
15:23:08 <mlh> yeah I lived there for three years
15:23:16 <melker> I see
15:23:19 <mlh> thought you might be one from your nick
15:23:22 <Axman6> mlh: are you in Sydney?
15:23:31 <mlh> Axman6: yes
15:23:40 <Axman6> are you coming to AusHac? =)
15:23:43 <melker> melker is just taken
15:23:49 <Axman6> also, you should join us in #haskell.au
15:23:55 <mlh> oh  ok tah
15:23:56 <melker> melker doesnt sound that dutch, or does it?
15:23:59 * applicative notices antipodal haskellers are coming out of the woodwork....
15:24:32 <mlh> melker: erm melk is dutch for milk is all
15:24:42 <mauke> melker is also german
15:24:51 <mlh> yeah I thought so too
15:25:06 <melker> it is used in sweden too
15:25:15 <melker> mostly old people would carry that name today though
15:25:20 <DukeDave> Can anyone suggest a nicer way to do this kind of monadic 'switching': http://pastebin.com/9JexFD39
15:27:07 <DukeDave> I.e. Some abstraction of the (n==0) test, ma and mb
15:27:16 <Favonia> melker: as the last resort you can always run Haskell as a separate process :P
15:27:45 <Axman6> RPCs!
15:28:04 <aavogt> @src when
15:28:04 <lambdabot> when p s = if p then s else return ()
15:29:13 <Favonia> DukeDave: use 'when' as aavogt suggested or use pattern matches (if you want to do other fancier stuffs) :)
15:29:59 <applicative> @type Control.Monad.when
15:29:59 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:30:22 <applicative> I think hlint gives that when you have if bool then ma else return ()
15:31:07 <Evious> Axman6, do you mean this thing? http://hackage.haskell.org/package/rpc
15:31:08 <DukeDave> Erm, what is this 'when' you speak of
15:31:25 <DukeDave> Sorry, it's been a while since I've written any haskell,
15:31:39 <Axman6> Evious: i meant the idea in general, implementation is just a detail
15:31:47 <DukeDave> Ah good, hoogle still exists :)
15:32:24 <aavogt> when exists because if needs the else
15:32:31 <applicative> DukeDave: so it's foo n = when (n == 0) $ print ["true ", show n]  -- but why print? not putStrLn ("true " ++ show n) or something
15:32:46 <aavogt> for extra quotes
15:33:05 <aavogt> > show ["true ", show 5]
15:33:06 <lambdabot>   "[\"true \",\"5\"]"
15:33:13 <aavogt> > show ["true ", 5]
15:33:14 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
15:33:14 <lambdabot>    arising from the literal ...
15:33:16 <applicative> kind of ugly
15:33:27 <DukeDave> applicative: Ah I forgot about (++)
15:33:40 <Favonia> > show ["true", "5"]
15:33:40 <lambdabot>   "[\"true\",\"5\"]"
15:34:03 <Evious> That RPC library actually looks really, really nice.
15:34:18 <applicative> but print is for taking numbers and other 'real data' to the screen, not for 'printing' strings; print x = putStrLn (show x)
15:34:52 <shachaf> @let print = system "lpr"
15:34:53 <lambdabot>  <local>:5:8: Not in scope: `system'
15:35:47 <Favonia> Evious: cool! I might take a look on it later. I was thinking of dbus for my next personal project...
15:36:09 <applicative> DukeDave also, if you don't mind doing "echo 0 | dukedave" instead of "dukedave 0" you can get rid of getArgs and use the mighty interact
15:36:23 <Evious> I'm more likely to have one Haskell program and a dozen others, than several Haskell programs RPCing... But still, nice possibility.
15:36:32 <Evious> Type safety is the biggest pain in the ass about RPC, after all.
15:37:28 <applicative> DukeDave: then you don't need any of this IO it's just:  main = interact foo   where foo 0 = "true 0" , foo _ = ""
15:37:37 <applicative> @type interact
15:37:38 <lambdabot> (String -> String) -> IO ()
15:37:52 <applicative> ^^^ awesome.
15:38:05 * applicative does all his io with interact and Debug.Trace.trace
15:38:22 <DukeDave> applicative: This is why I quit my job so I could get back into Haskell ;)
15:38:29 * DukeDave performs happy dance
15:39:45 <applicative> but I suppose you were trying to figure out getArgs and things like that.
15:40:11 <melker> is haskell good for compiling other languages?
15:40:21 <Favonia> applicative: great simplification :D
15:40:25 <melker> seems to be alot of haskell compilers..
15:40:27 <applicative> you mean for writing a compiler
15:41:11 <applicative> most haskell compilers are written in haskell, so the opinion of haskellers must be: yes
15:41:18 <ion> If i were to implement a language, i’d probably go with Haskell and the LLVM bindings. Not that there’s a need for that since Haskell already exists. ;-)
15:43:47 <DukeDave> Is there a generalisation of 'when' to choose a monadic action, for example from a list?
15:44:15 <DukeDave> If I wanted to do "if this ma, else mb"
15:44:35 <ion> What do you mean?
15:44:44 <monochrom> if x then ma else mb
15:44:48 <aavogt> what's the type of this?
15:44:56 <sully> melker: typed functional languages really shine at symbolic computation like compilation
15:45:03 <Favonia> ion: agree.
15:45:29 <applicative> DukeDave, the list is a list of monadic actions?
15:45:50 <koninkje> @type forM_
15:45:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
15:45:59 <DukeDave> applicative: Yes, in a more general case
15:45:59 <Kaidelong> main reason to use something like haskell is that it makes it easy to write your programs in a way that they are simple to test
15:46:33 <DukeDave> monochrom: Heh, that's how I started: http://pastebin.com/9JexFD39
15:47:09 <monochrom> if n==0 then print ["true ", show n] else return ()
15:47:16 <ion> foo 0 = …
15:47:20 <ion> foo x = …
15:47:30 <Favonia> melker: I think many languages have libraries for parsing etc. In Haskell world there are Parsec, Happy for parsing. As a bonus I can abuse the Haskell type checker to express typed expressions in the target language.
15:48:11 <monochrom> @faq can haskell do programs?
15:48:11 <lambdabot> The answer is: Yes! Haskell can do that.
15:48:12 <Kaidelong> @ty when
15:48:13 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:48:25 <Kaidelong> when (n==0) ma
15:49:14 <aavogt> your program will fail if you supply arguments that can't be converted to Integer
15:51:43 <Kaidelong> does Haskell permit main to be of type IO int to give a return code in unixey environments?
15:51:52 <Kaidelong> I know I could probably look this up easily
15:51:55 <koninkje> nope
15:52:01 <koninkje> main is always IO()
15:52:08 <aavogt> have you tried it koninkje?
15:52:12 <koninkje> @hoogle exitSuccess
15:52:12 <lambdabot> System.Exit exitSuccess :: IO a
15:52:12 <lambdabot> System.Exit ExitSuccess :: ExitCode
15:52:15 <shachaf> koninkje: main :: IO a
15:52:23 <mauke> main is IO a but the value is ignored anyway
15:52:24 <koninkje> aavogt: nope :)
15:52:26 <shachaf> But it won't do anything with the value.
15:52:42 <shachaf> (Unless you use runghc.)
15:52:52 <aavogt> yes ghci prints the output
15:53:05 <koninkje> Kaidelong: the functions you want for unixy exiting are in System.Exit
15:53:16 <Kaidelong> thanks
15:53:33 <Favonia> ghci just treats main as another normal monadic function :P
15:53:34 <DukeDave> koninkje: Ha, that's appropriate, I was wondering how to exit gracefully :)
15:55:37 <mauke> exitSuccess is the default
16:10:41 * edwardk waves hello.
16:10:42 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:11:36 <aristid> hey edwardk
16:12:09 <sshc> coi
16:12:23 <sshc> co'o
16:13:04 <ianmathwiz7> sshc:  that looks like lojban
16:13:13 <DukeDave> Grr, why fail http://pastebin.com/sT1X4Dv5
16:13:15 <ianmathwiz7> if I may say so
16:13:22 <DukeDave> Indentation still confuses me :|
16:13:35 <DukeDave> It reads so nicely, I'm a little miffed it failed
16:13:43 <monochrom> when (n == 0) $ do
16:13:48 <monochrom> or use parentheses
16:14:11 <aavogt> does that restriction actually simplify the grammar?
16:14:16 <monochrom> I know more poems that read nice but don't parse
16:14:34 <DukeDave> monochrom: Ah damn, that's obvious
16:15:00 <DukeDave> Thank you, it's amazing coming back to Haskell after a year how much I've lost :|
16:17:27 <ion> Yeah, i’d love \ and ‘do’ to bind tightly to what follows so you could just say foo \a -> … and foo do …
16:17:38 <milkpost> is there an easy way to uninstall an old version of a package with cabal?
16:17:50 <monochrom> with ghc-pkg unregister
16:19:29 <ddarius> ion: You should see lambdaProlog's syntax.
16:21:09 <danharaj> @pl (\_ -> (f :: b -> c))
16:21:09 <lambdabot> (line 1, column 16):
16:21:09 <lambdabot> unexpected ">"
16:21:09 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
16:21:24 <danharaj> @pl (\_ -> f :: b -> c)
16:21:24 <lambdabot> (line 1, column 15):
16:21:24 <lambdabot> unexpected ">"
16:21:24 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
16:21:59 <danharaj> @pl (\x -> (f :: b -> c))
16:22:00 <lambdabot> (line 1, column 16):
16:22:00 <lambdabot> unexpected ">"
16:22:00 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
16:22:05 * danharaj gives up because he's dumb.
16:22:16 <ion> const (f :: b -> c)?
16:22:26 <copumpkin> I don't think pl likes type annotations
16:22:30 <copumpkin> not sure why it would care
16:22:32 <ddarius> danharaj: @pl doesn't understand type annotations, which is just as well as @pl is untyped.
16:22:39 <danharaj> fair enough.
16:22:44 <ddarius> @pl [x | x <- xs]
16:22:44 <lambdabot> [x | x <- xs]
16:22:55 <ddarius> @pl \x -> [x | x <- xs]
16:22:56 <lambdabot> return . (<- xs) . join (|)
16:23:18 <ion> @pl \x -> x :: Integer -- i want this sugar to exist
16:23:18 <lambdabot> (:: Integer)
16:23:36 <danharaj> ion: that works. I have `const (const f)' in my code now :p
16:24:34 <shachaf> @ty (`asTypeOf`undefined::Integer)
16:24:34 <lambdabot> parse error on input `::'
16:24:44 <shachaf> @ty (`asTypeOf`(undefined::Integer))
16:24:45 <lambdabot> Integer -> Integer
16:24:45 <aavogt> pl could write the appropriate flip asTypeOf (undefined :: What You Wrote)
16:24:46 <shachaf> Hmph.
16:25:00 <ddarius> Why not just id :: Integer -> Integer?
16:25:28 <shachaf> ddarius: Then you have to write the type out twice.
16:25:58 <aavogt> it looks like that's shorter often though
16:28:31 <aavogt> > length $ break (uncurry (==)) $ map (\x -> (length "flip asTypeOf (undefined :: "++x++")", length "id :: "++x++" -> "++ x)) (tails (repeat '_'))
16:28:31 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:28:32 <lambdabot>         against inferred type ...
16:28:52 <aavogt> > length $ break (uncurry (==)) $ map (\x -> (length $ "flip asTypeOf (undefined :: "++x++")", length $ "id :: "++x++" -> "++ x)) (tails (repeat '_'))
16:28:53 <lambdabot>   Couldn't match expected type `[a]'
16:28:53 <lambdabot>         against inferred type `([(GHC.Ty...
16:31:50 <aavogt> > length $ takeWhile (uncurry (>=)) $ map (\x -> (length $ "flip asTypeOf (undefined :: "++x++")", length $ "id :: "++x++" -> "++ x)) (inits (repeat '_'))
16:31:51 <lambdabot>   20
16:32:09 <aavogt> rather than doing algebra to show how long the identifier needs to be to break even :p
16:32:19 <ion> hah
16:32:31 <danharaj> @pl zip
16:32:31 <lambdabot> zip
16:32:41 <Favonia> @ty asTypeOf
16:32:41 <lambdabot> forall a. a -> a -> a
16:32:54 <Favonia> aha, I see :P
16:33:04 <ion> @djinn a -> a -> a
16:33:04 <lambdabot> f _ a = a
16:33:21 <ion> @djinn a -> a -> a -> a
16:33:21 <lambdabot> f _ _ a = a
16:34:38 <Favonia> @src asTypeOf
16:34:38 <lambdabot> asTypeOf = const
16:35:04 <aavogt> what's the least popular function in the Prelude?
16:35:07 <aavogt> is it lex?
16:35:18 <DukeDave> maximilion: Hello, so you can actually execute things in here by starting your line with '>'
16:35:18 <sm> within a package, is it a good idea to import the most specific local modules possible ?
16:35:22 <c_wraith> wtf is lex? :)
16:35:23 <c_wraith> :t lex
16:35:24 <lambdabot> String -> [(String, String)]
16:35:30 <DukeDave> > zip "dave" "maxi"
16:35:31 <lambdabot>   [('d','m'),('a','a'),('v','x'),('e','i')]
16:35:32 <sm> or can I safely import ParentModule everywhere ?
16:35:34 <parcs> :t parse
16:35:35 <lambdabot> Not in scope: `parse'
16:35:43 <c_wraith> > lex "shrimp"
16:35:44 <lambdabot>   [("shrimp","")]
16:35:47 <aavogt> you need to avoid cycles, sm
16:36:37 <sm> as long as I avoid cycles.. does it make compilation less efficient if I include say My.Data instead of My.Data.A and My.Data.B... ?
16:37:10 <sm> oh wait.. yes I am creating a bunch of cycles here
16:37:44 <sm> question answered, I think - when importing stuff from the same directory, use specific module name
16:38:31 <sm> perhaps it's time to check out automatic import list addons
16:38:53 <sm> which I think means leksah or ghc-mod
16:41:40 <DukeDave> Okay, I've been raging too long: I'm using ghci and hopengl, but every time I 'exit' (by any means) main then ghci crashes, this must be known?
16:41:55 <DukeDave> I'm sure it was happening way back and I just gave up using ghci
16:42:55 <DukeDave> Ha, okay, it's:    actionOnWindowClose $= MainLoopReturns
16:46:21 <parcs> DukeDave: awesome!
16:46:54 * parcs has been resorting to runhaskell for opengl testing
16:48:21 <DukeDave> parcs: Haha, glad to have helped. I'm just following [1], I might pop on and add it in as a side note, because it has bugged me for ages.
16:48:21 <DukeDave> [1] http://www.haskell.org/haskellwiki/OpenGLTutorial1
16:48:48 <DukeDave> Is the hsakellwiki editable by all?
16:48:52 <DukeDave> *haskellwiki
16:49:10 <ezyang> There's a manual account creation process, but otherwise, yes.
16:49:26 <monochrom> yes
16:50:13 <aavogt> I'm installing chart with cabal, and would like documentation. If I specify --enable-documentation it goes on to install it's own gtk2hs (archlinux's gtk2hs has documentation though), otherwise it seems satisfied with the gtk2hs that's installed globally
16:51:27 <aavogt> ezyang: manual account creation doesn't seem to have been the case for a while now http://haskell.org/haskellwiki/index.php?title=Special:Userlogin&type=signup&returnto=Haskell
16:51:46 <ezyang> Oh, OK.
16:52:26 * aavogt doesn't remember when/how long that spammy situation was
16:53:20 <lpsmith> Lambda the Ultimate now combats spam by vetting all new accounts before they can log in or post
16:53:35 <milkpost> I cannot seem to understand this function -- fileToDirectory = (flip combine) "index.html" . dropExtension . toFilePath
16:53:46 <milkpost> you can ignore toFilePath if that helps I think
16:53:55 <milkpost> but what I don't understand is the `.` operator being used here
16:54:04 <mauke> function composition
16:54:04 <lpsmith> Not an ideal situation in some respects,  but all in all it's worked out well so far.   There are a few things about the mechanics of the process I wish was a little bit better.
16:54:17 <milkpost> yeah, i read that, but it's composing the "index.html" function?
16:54:34 <mauke> milkpost: no, flip combine "index.html"
16:54:55 <mauke> @unpl (flip combine) "index.html" . dropExtension . toFilePath
16:54:56 <lambdabot> (\ f -> combine (dropExtension (toFilePath f)) "index.html")
16:55:28 <mauke> @. pl unpl (flip combine) "index.html" . dropExtension . toFilePath
16:55:28 <lambdabot> flip combine "index.html" . dropExtension . toFilePath
16:55:30 <milkpost> ahhh, so everything before the 'dot' is considered a function
16:55:43 <mauke> milkpost: function application binds tighter than all operators
16:55:54 <milkpost> oooo k
16:55:56 <mauke> a b . c d is (a b) . (c d)
16:56:18 <milkpost> oh that makes perfect sense now
16:56:41 <milkpost> so why even have parenthesis around (flip combine)?
16:58:14 <mauke> no idea
16:58:41 <aavogt> it might be for emphasis
17:00:24 <aavogt> if anybody sees my cabal issue 15 minutes ago, disregard it since it seems to be working now for whatever reason
17:00:33 <milkpost> ahhh this is crazy stuff
17:00:55 <milkpost> so is it fair to call things "partial" functions or is that a no-no?
17:02:15 <mauke> people talk about partial application all the time
17:02:42 <byorgey> "partially applied function" refers to a function that has been applied to only some arguments, returning a function
17:02:49 <milkpost> ok
17:02:51 <milkpost> cool
17:02:53 <milkpost> batter, brb
17:02:54 <byorgey> "partial function" usually means something else, namely, a function that is undefined for some inputs
17:03:14 <aavogt> with a runtime failure
17:03:18 <aavogt> > head []
17:03:19 <lambdabot>   *Exception: Prelude.head: empty list
17:03:28 <byorgey> partial functions bad
17:03:31 <byorgey> partially applied functions good
17:03:43 * aavogt is partial to functions
17:03:50 <byorgey> =D
17:04:35 * shachaf is totally partial to total functions and partially partial to partial functions.
17:05:14 <aavogt> is it possible for code you've written months/years to make sense when you go back to it?
17:05:32 <shachaf> aavogt: Sure.
17:05:40 * shachaf digs up his old Hello World collection.
17:05:45 * aavogt must be rather special then
17:06:05 <shachaf> Not sure whether it works for more complicated examples than Hello World, though.
17:27:02 <aavogt> ghc errors seem rather odd sometimes: The function `("layout1_", "axis")' is applied to two arguments
17:31:00 <c_wraith> heh.  quite a function, there
17:33:03 <aavogt> does anybody else see the irony in naming my module Graphics.Rendering.Chart.ShortNames ?
17:34:16 <byorgey> aavogt: hehe
17:38:52 <aavogt> a related question is whether I can ask ghc whether I'm writing a duplicate instance from TH
17:39:40 <aavogt> for chart which uses  fake_qualified_names_like_this_which_are_a_pain_to_type_and_read, there are 3 overlaps if you just take the last word
17:40:10 <aavogt> stuff like  x_axis and y_axis
17:40:41 <aavogt> it would be nice to detect those automagically, but I'm afraid this means calling ghc from a TH splice
17:40:44 <monochrom> haha short names
17:42:09 <monochrom> Graphics.RenderingJobs.ChartographicalArtefacts.CommnlyUsedConvenientAbbreviations
17:42:50 * hackagebot splot 0.1.17 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.17 (EugeneKirpichov)
17:43:43 <danharaj> let's say I have a function in a module that clashes with a prelude name. how can I refer to it with a qualified name?
17:43:53 <olsner> monochrom: too many vowels! Grphcs.RndrngJbs.ChrtgrphclRtfcts.CmmnlSdCnvnnntBbrvtns
17:44:00 <ezyang> ModuleName.function
17:44:08 <danharaj> can I alias that qualified name?
17:44:11 <ezyang> you might need to throw in a qualified
17:44:17 <danharaj> I mean within the module.
17:44:23 <danharaj> not when I import it.
17:44:32 <monochrom> same
17:44:33 <ezyang> Oh, from within the module.
17:45:25 <monochrom> module Usurp where id x = if True then Prelude.id x else Usurp.id x
17:45:50 <monochrom> the lhs does not need and cannot take "Usurp.id", note.
17:46:10 <danharaj> monochrom: can I alias the qualifier to something shorter?
17:46:28 <monochrom> I have not heard of a way
17:46:55 <danharaj> That's unfortunate.
17:47:23 <monochrom> I now try module Usurp where import Usurp as U
17:48:16 <monochrom> "Module imports form a cycle"
17:48:40 * monochrom escalates the war and adds a Usurp.hs-boot
17:49:33 <dobblego> If I wanted to link to QuickCheck these days, where would I go? The original Chalmers page is dead.
17:52:00 <aristid> dobblego: hackage?
17:52:13 <dobblego> yeah I guess, ta
17:57:54 <monochrom> import {-# SOURCE #-} Usurp as U  does not make "U.id" appear
17:58:28 <monochrom> Usurp.hs-boot is already module Usurp where id :: a -> a
17:58:37 <NemesisD> hey i was wondering if someone could help me figure out this algorithm that i've been messing with for a few days. distributions :: [Recipient] -> [Item] -> [[(Recipient, [Item])]]. it needs to produce all the distinct ways in which a list of Item can be distributed to any number of Recipient (i.e. recipient 1 gets nothing, 1 item, 2 items, etc)
17:59:24 <monochrom> so I suggest this solution instead: module Usurp(id) where id = this'name'has'no'clash; this'name'has'no'clash = ...
17:59:36 <byorgey> NemesisD: how have you approached it so far?
17:59:46 <aavogt> http://hpaste.org/47157/chart_abbreviation_fundep_worr
17:59:47 <NemesisD> subsequences almost gets me there but I think it would need to tuple each result so that it contained the subsequence and then the remainder unused in that subsequence
18:01:02 <NemesisD> byorgey: not too far, i defined the two empty list cases. having trouble with the recursive part
18:01:47 <aavogt> one issue about going to mptcs for better instance selection is that this gets in the way is that this Accessor type isn't exported properly
18:01:58 <niteria> you're looking for partitons
18:02:03 <aavogt> it's an alias for data-accessor-0.2.1.7:Data.Accessor.Private.T r a, but is that really a problem?
18:02:20 <NemesisD> if subsequences produced a list of (subsequence, unused), i could pop the head off the recipient list, assign them the subsequence and then concatenate with a recursive call using the remainder of the recipients and the leftover from the subsequence
18:03:33 <NemesisD> niteria: me? do you mean partition from Data.List?
18:03:54 <niteria> both lists are finite?
18:04:13 <byorgey> NemesisD: ok, so write your own version of subsequences which does that
18:04:15 <NemesisD> niteria: yep. hopefully *quite* finite for the sake of the stack
18:04:33 <byorgey> NemesisD: it sounds like a good approach to me
18:05:02 <niteria> i meant partitions as in number partitions
18:05:29 <niteria> theres a direct correspondence
18:05:30 <NemesisD> byorgey: i'm rather new. i'm staring down the definition of subsequences and i'm having a tough time understanding it. i'm not great at reasoning with foldr's yet
18:05:37 <NemesisD> niteria: ah. i'm not familiar with that concept
18:05:47 <byorgey> NemesisD: so don't use foldr, just make it directly recursive
18:07:29 <byorgey> NemesisD: subsequences (x:xs) = ... ?  what can you say about x and a recursive call to subsequences xs ?
18:08:17 <byorgey> niteria: you mean like 4 = 3+1 = 2+2 = 2+1+1 = 1+1+1+1 ?
18:08:24 <niteria> yes
18:08:31 <byorgey> I don't see the correspondence.
18:08:55 <niteria> for sum of lengths
18:09:17 <byorgey> sum of lengths of [Recipient] and [Item]?
18:09:39 <niteria> yes
18:10:11 <NemesisD> byorgey: i guess i'd say that from x, i'd generate a list of x:y where y is each additional element in xs
18:10:19 <niteria> and -1 each
18:12:49 <niteria> hm, i might be wrong
18:12:57 <byorgey> NemesisD: that doesn't seem to type check, in x:y, y must be a list
18:13:42 <byorgey> NemesisD: suppose you have already generated all the subsequences (paired with their complements) of xs.  How can you combine this with x to generate all subsequences of (x:xs) ?
18:14:21 <niteria> and i am, it doesnt preserve order, sorry
18:14:38 <byorgey> for example let's say we have  [ ([2,3], []),  ([2], [3]), ([3], [2]), ([],[2,3]) ]
18:14:55 <byorgey> NemesisD: and we want to combine this with 1 somehow to generate all subsequences of [1,2,3]
18:15:33 <NemesisD> hmm
18:15:46 <niteria> subsequences are subsets
18:16:04 <NemesisD> does subset imply uniqueness in the elements?
18:16:27 <niteria> represented as lists
18:16:48 <byorgey> NemesisD: let's assume for now that we always start with a list having no repetitions
18:16:53 <NemesisD> byorgey: would i prepend 1 to every one of the fsts and snds of those subsets then combine them with those subsets
18:17:03 <byorgey> NemesisD: right
18:17:31 <byorgey> now all you have to do is translate that into Haskell =)
18:18:27 <byorgey> subsequences (x:xs) = ...something involving x and subs'...   where subs' = subsequences xs
18:18:46 <byorgey> niteria: indeed
18:27:09 <NemesisD> byorgey: ok i think im starting to go down the right path. right now ive got something like ss (x:xs) = concatMap (appHead x) (ss xs) where appHead h (sub, unused) = [(h:sub, unused), (sub, h:unused), (sub, unused)]
18:29:16 <NemesisD> by jove i think i might have it. the base definition is ss [] = [([], [])]
18:29:48 <byorgey> NemesisD: almost, I don't think you want to keep (sub, unused)
18:29:59 <byorgey> because that doesn't take x into account at all
18:30:21 <NemesisD> you're right
18:30:38 <NemesisD> woo!
18:30:48 <byorgey> but if you take that out then it looks right to me
18:31:02 <byorgey> well done =)
18:31:09 <NemesisD> thanks! i appreciate it a lot. i was starting to smell smoke coming out of my head
18:31:30 <NemesisD> now i just gotta remember my original idea for the distributions algo and see if this still makes sense
18:31:42 <byorgey> hehe, sometimes a little smoke is good, but I know how it feels to bang your head against a problem and just get really frustrated
18:32:00 <byorgey> (21:17) <  NemesisD> if subsequences produced a list of (subsequence, unused), i could pop the head off the recipient list, assign them the subsequence and then concatenate with a recursive call using the  remainder of the recipients and the leftover from the subsequence
18:32:28 <byorgey> sounds like it will work
18:32:46 <byorgey> I'm off to bed, good luck!
18:32:52 <NemesisD> see ya. thanks again
18:33:20 <dented42> I'm trying to use the enumerator library to handle sockets, but I'm having trouble writing a simple echo server. What I have done so far is here : http://hpaste.org/47158/simple_broken_echo_server . I am at a loss as to why it doesn't work, because it works (locally) if I use stdin and stdout instead of the socket handle. Could someone point out what I have done wrong?
18:41:35 <jeffz> dented42: which library is Data.Text.Enumerator in?
18:41:53 <jeffz> er, Data.Enumerator.Text...
18:42:14 <jeffz> oh, just in enumerator, guess it's time I installed it.
18:44:05 <aavogt> it works if you output to stdout
18:44:12 <aavogt> from the telnet input
18:44:41 <dented42> jeffz: it's part of enumerator
18:44:54 <dented42> aavogt: I thought that was strange as well
18:49:57 * hackagebot bash 0.1.2 - Bash generation library.  http://hackage.haskell.org/package/bash-0.1.2 (JasonDusek)
18:54:38 <aavogt> dented42: the issue seems to be with Network, since this also doesn't work:
18:55:21 <aavogt>     (h, _, _) <- accept =<< listenOn n
18:55:23 <aavogt>     forever $ hGetLine h >>= hPutStrLn h
18:55:55 <aavogt> but if you  putStrLn instead, it works just like the enumerator version
18:57:09 <jeffz> this works for me:
18:57:16 <jeffz> forever $ hGetLine h >>= hPutStrLn h >> hFlush h
18:58:42 <jeffz> so
18:58:46 <jeffz> adding   hSetBuffering handle NoBuffering
18:58:56 <jeffz> makes the original enumerator one work as expected
18:59:03 <jeffz> i think?
19:00:06 <jeffz> just a matter of deciding what sort of Handle behavior you want, not a bug in Network :P
19:01:28 <MaskRay> Here is the BNF of a C-like programming language: http://imagebin.org/155554, can you give me some hints on implementing it in ADT?
19:02:25 <MaskRay> And my faulty code: http://paste.pocoo.org/show/396493/
19:03:30 <MaskRay> I don't know how to handle variable types and `return'
19:03:48 <dented42> jeffz: I shall try that
19:04:24 <jeffz> dented42: if you look at the network-enumerator package, it uses sockets rather than handles, which is probably wiser.
19:04:36 <jeffz> as an aside.
19:04:37 <pastorn> MaskRay: use BNFC
19:04:46 <dented42> jeffz: probably
19:04:51 <pastorn> it converts a BNF to an ADT + parser
19:05:31 <MaskRay> Function calls are tricky
19:05:33 <dented42> jeffz: yes, no buffering works
19:05:49 <dented42> jeffz: but I'm curious, why does LineBuffering not work?
19:06:25 <jeffz> dented42: I don't know, you'd have to look more closely at what's going on.
19:06:26 <dented42> or does line buffering not work with sockets?
19:06:44 <MaskRay> pastorn: thanks. i'll take a look
19:08:09 <MaskRay> pastorn: What if I must convert it to ADT and evaluate (expr/stmt/function call) by hand instead of using BNFC?
19:08:56 <pastorn> MaskRay: then just do it?
19:11:51 <aavogt> type class contexts never help to choose instances, right?
19:12:07 <mauke> right
19:12:13 <MaskRay> pastorn: How to handle `return' and different variable types?
19:19:49 <MaskRay> pastorn: I only handle `Int/Bool expr' at present and assume any type is Int. Perhaps I can use `Maybe Int' to indicate the return value of `executing a statement' where (Just x) stands for the statement should `return' with a value x?
19:28:17 <aavogt> http://hpaste.org/paste/47157/chart_abbreviation_fundep_worr#p47160
19:30:19 <youssif> come watch me get wet  http://bit.ly/liutDC
19:33:15 <NemesisD> gah im stuck again
19:54:11 <varnie> I have a very simple question - can I use some console command in ghci to have a look at some function's description?
19:54:19 <NemesisD> any of you guys good with mutual recursion
19:56:48 <shachaf> NemesisD: Only if it's confluent.
19:57:00 <shachaf> varnie: :info
19:57:11 <shachaf> Well, it won't be an English description or anything.
19:57:24 <shachaf> But it'll be a bit more informative than :type.
19:57:35 <varnie> thank you
19:57:59 <cmccann> Once I knew someone who was good with mutual recursion, any time I had a problem I just asked him, and when he had a problem he asked me
19:58:29 <NemesisD> lol
19:59:25 <NemesisD> ok i'll just explain my problem. given [Recipient] and [Item], i'm trying to determine all the ways in which the items can be distributed to the set of recipients
20:00:43 <NemesisD> i've written a helper subseqRemainders which generates all subsequences of the [Item] tupled with their remainders. so if items were [1,2,3], it would generate [([1,2,3], []), ([2,3], [1]) ...]
20:03:04 <NemesisD> i can express the algorithm in english but not haskell. for each subsequence and remainder, and for each recipient, generate all possibilities in which the first recipient gets the subseq (first part of the tuple) and the rest is divided up amongst the remaining recipients
20:04:36 <danharaj> what do I do if I want to have a class constraint on a type constructor f that `Monoid (f a)' for all types a?
20:05:06 <cmccann> NemesisD, so wouldn't you just apply the whole thing again with the remaining recipients and leftover items?
20:08:36 <NemesisD> cmccann: that seems likely, but my mental stack seems to explode when i think about it at the top level
20:09:22 <parcs> danharaj: data Monoid a => F a = F a
20:09:40 <cmccann> NemesisD, I don't see how the following recursive step is conceptually any different from the starting point, you have two lists of the same types
20:10:23 <danharaj> parcs: I meant for a class, like class Functor f => Applicative f, except I want to put a constraint on f a.
20:10:24 <parcs> then instance Monoid a => Monoid (F a) where …
20:10:48 <NemesisD> cmccann: i have 1 list of [Recipient] and the other of [([Item], [Item])]
20:10:53 <parcs> ah, my reading comprehensions sucks
20:11:02 <danharaj> or I wasn't clear.
20:11:58 <cmccann> NemesisD, well, not that list, you're recursing separately on each remainder of items
20:12:54 <cmccann> so you map your recursive step over that list, putting one list of items with the first recipient, then recurse on the other list of items with the other recipients
20:13:57 <cmccann> since the recursive step creates a list of results you'll need to concatenate at each step as well but that's easy
20:14:21 <NemesisD> cmccann: map recursive step over that list: list in that case being [([Item], [Item])] ?
20:14:29 <cmccann> yeah
20:16:28 <NemesisD> cmccann: when you say concatenate at each step you mean each step of the recursive step or each step of the main function?
20:16:51 <cmccann> NemesisD, it might help to start by writing a non-recursive function that takes the pair of item lists and the current recipients and produces (Recipient, [Item]) for what the first person gets, plus ([Recipient], [Item]) for the remaining recipients and items
20:17:49 <cmccann> NemesisD, it doesn't really matter where it goes, it's all the same thing, you could write it all as one function if you liked
20:18:35 <cmccann> just that you need to flatten at each step because each recursive step creates many results from a single input
20:18:42 <NemesisD> cmccann: wait i think i might have it
20:18:47 <jmcarthur> danharaj: there's always Alternative or MonadPlus
20:19:06 <jmcarthur> danharaj: some packages have similar classes for Functor. TypeCompose has Monoid_f, for example
20:19:11 <cmccann> NemesisD, awesome, give it a try and see how it goes
20:21:06 <NemesisD> cmccann: it only compiled because i misspelled the function name :P
20:21:16 <cmccann> heh
20:22:02 <cmccann> NemesisD, if you want to hpaste your code so I can see it, that might help me pinpoint what you're missing
20:23:56 <NemesisD> great odin's beard. it compiled and might work: cmccann http://hpaste.org/47161/distributing_items_to_recipien
20:24:02 <NemesisD> does that look right to you?
20:27:07 <cmccann> NemesisD, at a quick glance the structure seems right
20:28:15 <NemesisD> as far as i can tell it seems to be working right. it generates cases in which not all the items can be distributed, which thankfully is what i need
20:29:16 <cmccann> NemesisD, it'd probably be easy to make it not do that, anyhow
20:29:50 <NemesisD> lol
20:31:16 <NemesisD> the end result of 2 full evenings of thinking about this is 9 lines of haskell
20:31:33 <cmccann> NemesisD, I could probably make it shorter if you want :)
20:32:45 <NemesisD> haha. thanks for walking me through it cmccann
20:33:17 <cmccann> NemesisD, if you want to stretch your Haskell a bit more, you could try rewriting it with list comprehensions
20:37:30 <NemesisD> cmccann: once my mental state recovers i may give that a shot
20:38:27 <cmccann> NemesisD, ok good, the mental pain is how you know it's working
20:38:36 <cmccann> definitely good to rest up before getting back into it :)
20:41:06 <_anon3921> Hi all, I'm learning Haskell, and while I'm finding the mechanics of the language fairly easy to grasp, I'm running into some philosophical problems which I'm sure are my fault. My particular issue is with Monads (surprise!). I understand how a Monad is useful as an abstraction (I'm skimming the "Gentle Introduction" and it's making sense), but I fail to see how it helps with "purity."
20:41:51 <gwern> http://erlang.org/pipermail/erlang-questions/2011-May/058769.html <-- always interesting to see a great mind finally go off the deep end
20:41:52 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:41:56 <gwern> @messages
20:41:56 <lambdabot> roconnor said 4m 18d 14h 37m 26s ago: you might be intrested in http://r6.ca/blog/20081109T015636Z.html
20:41:56 <lambdabot> Lemmih said 6h 13m 14s ago: Your bitcoinweekly article was very enjoyable. Kudos.
20:42:03 <_anon3921> That is, as a language feature, I don't understand how putting something like IO into a Monad helps us more than, say, just defining a type that declares something has a side effect. Again, I see the abstraction as being useful for simplifying programs, but I fail to see how it helps with functional purity.
20:42:47 <gwern> heh. yes, people do seem to like my article http://bitcoinweekly.com/articles/bitcoin-is-worse-is-better/
20:43:11 <cmccann> _anon3921, IO is the type that declares something might have a side effect
20:44:32 <gwern> @flush
20:44:54 <gwern> 5
20:45:00 <_anon3921> cmccann: Right, so is the rest of the that (the return, >>, etc) just another abstraction? I guess what I'm getting as is, I don't understand how pulling something "up into" a Monad type helps more than just saying that IO is something that "has a possible side effect." I'm not sure I'm making sense.
20:46:13 <cmccann> _anon3921, the short version is that to make sure side effects are always marked, the language needs to enforce that by making sure there's no way to go from IO a -> a
20:46:53 <cmccann> so to do anything with stuff in IO, you use black-box functions that take an IO value and a function that does something to it, and combine them to create a new IO value
20:47:29 <_anon3921> cmccann: Oh, duh, that makes sense.
20:47:34 <_anon3921> Thanks!
20:48:19 <cmccann> _anon3921, it's a "coincidence" in a sense that the resulting operations give you a Monad instance
20:50:23 <parcs> @type const id
20:50:23 <lambdabot> forall a b. b -> a -> a
20:50:47 <cmccann> _anon3921, that sense being that it's a direct logical consequence of using a system like that to restrict IO, so by using that model you have a monad whether you wanted one or not
20:52:03 <cmccann> ...and I'm kinda simplifying things to the point of being rather silly, but I think the rough idea here will send you in the right direction
20:52:28 <_anon3921> cmccann: So by creating a separate "world" for IO to live in you've, um, created a world that has to behave like IO, and thus end up with the parts common to IO, which happen to be a Monad?
20:52:44 * cmccann adds a disclaimer because he knows this channel is full of people who could nitpick dozens of things he's hand-waving here
20:53:42 <KirinDave> Are we explaining IO?
20:53:50 <KirinDave> Hopefully not as a vehicle for monads. :)
20:54:38 <cmccann> _anon3921, by creating a "separate world" and then restricting the interactions with it in that way, you create a Monad pretty automatically
20:55:02 <aavogt> http://hpaste.org/47163/why_doesnt_this_instance_matc <-- can somebody clarify why this instance doesn't get selected?
20:55:34 <aavogt> aha, the Plot is getting in the way
20:55:44 <_anon3921> cmccann: So in essence, what the IO Monad creates is an abstract version of an imperative programming language that can't touch my purely-functional code?
20:55:52 <_anon3921> Sorry for the barrage of silly questions.
20:56:26 <cmccann> _anon3921, there are lots of arguments of how to interpret what something in IO "means" so that's kind of a long story there
20:56:45 <gwern> aavogt: damn plot! I suggest you introduce a new tsundere character to mix things up
20:56:52 <KirinDave> _anon3921: The IO program is like the root of a tree, and your functional code hangs off of it. :)
20:57:28 <gwern> aavogt: like a moe anthropomorphism of lambdabot. lambdabot is totally tsundere
20:57:41 <aavogt> who is moe?
20:57:42 <ClaudiusMaximus> aavogt: i had a problem similar to that, one type was too general/ambiguous, so i added (`asTypeOf` somethingConcrete) in the right place and it worked
20:57:46 <KirinDave> _anon3921: Without IO's to kick off evaluation, none of your functional code is ever provoked
20:57:56 <gwern> aavogt: see the OS-tans
20:57:59 <cmccann> _anon3921, but yes, one way of looking at it is that "IO a" represents an impure, imperative program that gives you an "a" when run
20:58:10 <aavogt> ClaudiusMaximus: I'm trying to write these instances so I don't need to add annotations
20:58:19 <cmccann> _anon3921, and your purely functional code can only construct more complicated IO values, not run them itself
20:58:33 <aavogt> if instead of (Plot w[a3RC] w[a3RD]) there was just a type variable there, all would be well
20:59:00 <cmccann> _anon3921, and then whatever IO thingie ends up being the value of "main" gets run for real when you run the compiled program
20:59:58 <aavogt> but I'm not writing these instances directly (via TH), and I'd like to keep that code sort of independent of this plot library (which may change)
21:01:27 <cmccann> _anon3921, though do take any interpretation like that with a grain of salt, it's just an intuition-building exercise for ways to think about how IO relates to pure code
21:03:09 <_anon3921> cmccann: Of course, and that's exactly where I'm at. I feel like to go further with Haskell, I need to understand each piece of the language that I'm using on an intuitive level. Do you have any specific resources you'd recommend?
21:04:15 <cmccann> _anon3921, not really, I'm a pathological autodidact and basically just spent months bashing on toy code and thinking about how stuff fit together
21:05:37 <cmccann> _anon3921, the main advice I'd give is to not fixate on Monad as a big important thing, because it really isn't
21:06:45 <ClaudiusMaximus> aavogt: try:   Left plt `asTypeOf` Right plt
21:07:06 <ClaudiusMaximus> aavogt: well, or write more instances
21:07:10 <_anon3921> cmccann: Well, that's sort of the issue. I'm having a hard time of thinking of the Monad as anything other than "this is what the language designers used in this particular situation for this problem because they liked it and it sort of fit", but everyone seems to obsess over it, so I figured there must be /something/ there.
21:07:27 <cmccann> _anon3921, it's useful, that's all
21:07:31 <cmccann> other things are useful, too
21:07:44 <_anon3921> cmccann: That's what I figured.
21:08:58 <cmccann> _anon3921, out of curiosity what other programming languages do you know, if any?
21:09:53 <aavogt> ClaudiusMaximus: with the given instance, if I specify  b0 ~ Plot a b, it works
21:09:55 <sm> gwern: great article!
21:09:59 <nyingen> _anon3921: Haskellers tend to leverage mathematics when applicable. Monoids, catamorphisms, monads, and so on
21:10:14 <aavogt> so     Left plt `asTypeOf` Right (undefined :: Plot a b)
21:10:17 <nyingen> _anon3921: in response to your 'they liked it / it sort of fit' comment :)
21:11:13 <_anon3921> Interesting ones: C, Scheme, Common Lisp are the ones I know the best. Some PHP, Python, C++ and that sort of thing too. I'm no stranger to learning languages, and I'm no stranger to mathematics (studying pure mathematics), but my biggest issue with Haskell is getting over a feeling of silly novelty with the language features.
21:11:53 <dolio> The way they got in started most obviously with Moggi.
21:11:57 <cmccann> _anon3921, okay yeah, then my advice is definitely just don't worry about it too much
21:12:17 <dolio> He noticed that monads were good for building up descriptions of effects in denotational semantics.
21:12:33 <cmccann> Haskell has a lot of ways to work with things at a very abstract level, and occasionally pilfers bits of math for ways of talking about very abstract things
21:12:36 <nyingen> _anon3921: Haskell is pretty different, but I find it's very orthogonal, especially as compared to spun-together languages like Go
21:12:46 <dolio> Then Wadler, I think, noticed that you could do the same thing, except with embedded languages within Haskell.
21:12:59 <aavogt> but I'm not sure of how to write the instances so that one gets selected, but staying specific enough that there is no issue with overlap/duplicate instances
21:13:08 <dolio> Which is all that's going on, really.
21:14:22 <dolio> And the Moggi stuff probably just a special case of the use of monads in category theory to characterize algebraic structures.
21:14:35 <dolio> Languages are algebraic structures.
21:15:10 * aavogt supposes this involves replacing terms like (Plot w[a3RC] w[a3RD]) with variables, then checking that there is no 'duplicate instance'
21:17:13 <ion> @hoogle convertStrictly
21:17:13 <lambdabot> No results found
21:17:37 <ion> http://hackage.haskell.org/packages/archive/iconv/0.4.1.0/doc/html/Codec-Text-IConv.html convertStrictly :: … -> Either ByteString ConversionError
21:17:40 <ion> Seriously? :-P
21:17:43 <_anon3921> nyingen: I'm not sure about Go, because I haven't seen much of a reason to check it out (if I want a language where I don't have to malloc()/free(), I use Common Lisp), but I'll take your word for it. One things that's always seemed weird to me about Haskell's design is throwing a big ugly error message on certain basic functions instead of using the nifty Maybe type.
21:18:17 <cmccann> _anon3921, the only reason people obsess over Monad instead of other bits of pilfered math is because it's used to describe doing IO, which people expect to be simple instead of relying on "difficult" language features
21:18:59 <_anon3921> dolio: Hmm, thanks for the background, I'll look into that.
21:19:14 <cmccann> _anon3921, ha ha ha oh boy, that's a can of worms
21:19:27 <cmccann> errors from basic functions, that is
21:19:35 <_anon3921> cmccann: Uh oh.
21:20:13 <aavogt> there aren't that many partial functions in the prelude
21:20:57 <cmccann> there are lots of minor complaints people have about the prelude, and that's one of them
21:21:40 <dolio> (!!) should be total, I guess.
21:21:48 <dolio> head and tail are just kind of useless.
21:22:12 <aavogt> foldr1 shouldn't exist?
21:22:54 <dolio> I don't use foldr1 much.
21:23:19 <dolio> In theory it should take a non-empty list.
21:23:24 <gienah> _anon392: some prelude functions using Maybe: http://hackage.haskell.org/package/safe
21:23:29 <dolio> Or return Maybe.
21:23:44 <cmccann> dolio, I'd rather (!!) didn't exist at all in the Prelude because having it there makes newcomers think it's a good idea to use it
21:23:44 <ion> :t either Right Left  -- workaround for convertStrictly’s stupid type, i guess
21:23:45 <lambdabot> forall a a1. Either a a1 -> Either a1 a
21:24:27 <cmccann> but that may be a symptom of how much time I spend on Stack Overflow :|
21:24:29 <dolio> cmccann: Yeah. There are uses, but it's not good for what people initially expect.
21:25:27 <cmccann> I guess a lot of my complaints about stuff in the Prelude boil down to "they give people the wrong impression", really
21:25:55 <dolio> I guess the main use of (!!) is due to the fact that there's no induction-on-naturals operation.
21:29:01 <aavogt> is there a proper way to use   class TypeCast, which does not involve unsafeCoerce?
21:29:23 <_anon3921> Well, I'm off to finish working on some C stuff. Thanks for answering my silly questions.
21:29:27 <cmccann> _anon3921, anyway, to get back on point, that's not really part of "Haskell's design". There's nothing special about most stuff in the Prelude.
21:29:34 <cmccann> ah, oh well
21:29:53 <aavogt> it's special since you don't import it
21:30:26 <cmccann> and you can also opt not to import most of it
21:30:39 <cmccann> it's just there by default
21:31:14 <aavogt> you're not going to get away from fail
21:31:54 <aavogt> I guess -XNoImplicitPrelude, but that's pretty noisy too
21:32:29 <cmccann> well yeah, some things that are special also annoy me
21:32:50 <gienah> something like: import Prelude hiding ((!!)) import Safe (atMay)
21:33:01 <aavogt> their absence would be more annoying
21:33:03 <copumpkin> WHAT HAPPEN
21:33:40 <aavogt> copumpkin: have you generated maximally overlapping instances with TH?
21:33:51 <copumpkin> SOMEBODY SET UP US THE BOMB
21:34:08 <dylukes> SOMEDAYS
21:34:13 <dylukes> YOU JUST CANT GET RID OF A BOMB.
21:34:46 <cmccann> in other news, trying to comprehend the GHC API is giving me a headache
21:35:19 <aavogt> hint is a much more convenient wrapper
21:36:17 <cmccann> aavogt, no kidding
21:37:33 <cmccann> but I was wondering about some stuff that would be a bit more involved than what hint does but I'm not sure if it'll be worth the hassle
21:38:17 <aavogt> what stuff?
21:39:16 <cmccann> aavogt, nothing all that specific really, just mucking with manipulating Haskell source code in ways that didn't seem to be possible in any higher-level library
21:39:46 <fragamus> hello
21:40:28 <lewis1711> array :: (Ix i) => (i, i) -> [(i, e)] -> Array i e --not quite sure how to parse this. would just like to make an array, I have seen examples using list comprehensions but is that really neccessary?
21:41:10 <aavogt> you can do quite a bit with not too much code using haskell-src-exts and syb
21:41:40 <Axman6> > array (0,10) (zip [0..] ['a'..'z'])
21:41:41 <lambdabot>   array *Exception: Ix{Integer}.index: Index (11) out of range ((0,10))
21:41:45 <Axman6> bah
21:41:50 <jkff> lewis1711: This means you can create an array whose indices are of an arbitrary "index" type (belong to Ix typeclass), and whose set of indices is an arbitrary interval on this type (i,i)
21:41:52 <Axman6> > array (0,10) (zip [0..] ['a'..'j'])
21:41:53 <lambdabot>   array (0,10) [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h...
21:42:00 <aavogt> > array (1,3) [(1,'a'),(2,'b'),(3,'c')]
21:42:01 <lambdabot>   array (1,3) [(1,'a'),(2,'b'),(3,'c')]
21:42:06 <Axman6> :t listArray
21:42:07 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
21:42:23 <Axman6> > listArray (0,10) ['a'..]
21:42:23 <jkff> > array ('a', 'c') [('a',1), ('b',5), ('c',9)]
21:42:23 <lambdabot>   array (0,10) [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h...
21:42:24 <lambdabot>   array ('a','c') [('a',1),('b',5),('c',9)]
21:43:05 <lewis1711> I know it sounds like I'm trolling, but... is there a simple way to create an array? this seems like a lot of work
21:43:05 <jkff> array ('a','c') [('c',5), ('b',9), ('a',1)]
21:43:13 <jkff> > array ('a','c') [('c',5), ('b',9), ('a',1)]
21:43:14 <lambdabot>   array ('a','c') [('a',1),('b',9),('c',5)]
21:43:19 <jkff> lewis1711: listArray might be
21:43:33 <lewis1711> oh i missed that
21:43:36 <jkff> lewis1711: or you can define a one-line helper function yourself. What would you like the interface of the "simple way" to be?
21:44:24 <jkff> > let basicArray xs = listArray (0,length xs-1) xs in basicArray ['a'..'z']
21:44:25 <lambdabot>   array (0,25) [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h...
21:44:26 <lewis1711> jfkk: something like ML's "fromArray". I guess listArray is close enough
21:44:35 <lewis1711> whoops, jkff
21:45:50 <lewis1711> Array.fromList rather. but yeah
21:47:25 <cmccann> aavogt, some of the stuff I was thinking about needed a bit more awareness of types, to the extent that my options seemed to be "a huge pile of dirty hacks" or "look at the output of GHC's type checker".
21:47:53 <aavogt> http://hpaste.org/47165/subtrees
21:49:52 <cmccann> it feels like there's not a lot of middle ground in working with Haskell source between "type-blind syntax mangling in isolated snippets of code" and "run the whole damn thing through a full compiler"
21:51:40 <aavogt> @google ghc-goals
21:51:41 <lambdabot> https://github.com/sebastiaanvisser/ghc-goals
21:52:28 <lewis1711> http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial this is more like it
21:54:08 <cmccann> aavogt, hmm
21:55:13 <cmccann> aavogt, yeah, that looks like it's doing roughly the same sort of stuff I was toying with
21:56:37 <aavogt> it should be a library-ish functionality, such as providing an AST with every expression having a type
21:57:35 <aavogt> but perhaps ghc-goals doesn't get all that information and tell you just a little bit of it
21:58:44 <milkpost> how do you remove the first 5 characters from a string?
21:59:05 <aavogt> drop 5
21:59:32 <aavogt> @unmtl StateT s [] a
21:59:32 <lambdabot> s -> [(a, s)]
22:00:41 <cmccann> aavogt, from a brief inspection I doubt I could use it directly for much, then again I didn't really have a clear plan as opposed to just aimless tinkering
22:01:14 <cmccann> but if I give it another go at least this is a MUCH better working example to turn to for this kind of thing
22:02:06 <aavogt> @unmtl StateT s (ListT Q) a
22:02:07 <lambdabot> s -> Q [(a, s)]
22:02:41 <cmccann> rather than hint, which is nice but oriented more toward writing something like ghci
22:07:00 <varnie> bye
22:07:19 <jkff> @unmtl ReaderT r (WriterT w (StateT s)) a
22:07:19 <lambdabot> err: `StateT s (a, w)' is not applied to enough arguments.
22:07:32 <jkff> @unmtl ReaderT r (WriterT w (StateT s Identity)) a
22:07:32 <lambdabot> r -> s -> (a, w, s)
22:07:36 <jkff> cool
22:08:29 <aavogt> there's a RWST which is supposedly more efficient
22:08:50 <ivanm> hooray for removing an optimisation making the program generate the correct values but _way_ more slowly... *sigh*
22:09:23 <Axman6> shame on you for implementing incorrect optimisations :P
22:09:34 <ivanm> I guess that's another reason not to prematurely optimize: get the damn thing working properly first in case your optimisations don't work properly :s
22:09:42 <cmccann> wouldn't something that causes incorrect results to be generated quickly normally be called a "bug", not an "optimization" :)
22:10:02 <ivanm> cmccann: heh; what happened was that it was generating _too many_ values
22:10:05 <aavogt> @unmtl ListT (StateT s (ListT Q)) a
22:10:05 <lambdabot> s -> Q [([a], s)]
22:10:13 <ivanm> i.e. 156 instead of 140
22:10:33 <ivanm> and trying to trawl through working out which ones are different would be too much of a PITA
22:10:51 <cmccann> ivanm, not sure what the code you're working on is so that doesn't mean much out of context
22:11:04 <ivanm> yeah
22:11:11 <cmccann> but I think I get the rough idea
22:11:11 <ivanm> well, I'm generating specific planar graphs...
22:11:31 <ivanm> and the actual internal representation for the same graph can be different depending on how it's constructed
22:11:38 <ivanm> so you can't just diff the results
22:11:54 <cmccann> yeah, that's about the sort of thing I expected
22:13:11 <ivanm> admittedly, this is only meant to be a reference prototype anyway...
22:13:11 <cmccann> having code that generates a whole bunch of Xs occasionally include some Ys or Zs as well is always a headache :(
22:13:20 <ivanm> but it's still long, and this anti-optimisation didn't help :s
22:13:48 <ivanm> even better: I think what happened was that it was generating _duplicates_
22:13:56 <milkpost> if i have a regex pattern I want to match with the beginning of a string and I want to remove it, what is the best way to do it?
22:14:03 <cmccann> ivanm, oh joy
22:14:08 <ivanm> milkpost: use a regex library?
22:14:28 <fragamus_> hey I just loaded the ListT done right, but it links to an alternative.  which is better?
22:14:42 <ivanm> cmccann: now, I expect/want _some_ isomorphic duplicates... but when two graphs are the same except for internal labelling of the node and edge IDs... :s
22:14:45 <milkpost> ivanm: ok, well, just checking of that was the right way, thought there might be something built in or something
22:14:59 <ivanm> milkpost: you're thinking of perl :p
22:15:13 <milkpost> hah
22:16:18 <cmccann> ivanm, well, good luck
22:16:53 <ivanm> thanks
22:17:24 <ivanm> yay, the 9 node case is 12 min and going strong, when it used to take about 2 to generate _more_ values
22:17:25 <ivanm> *sigh*
22:17:40 <cmccann> ivanm, :(
22:32:34 <ivanm> damn, it died due to lack of memory..... *sigh*
22:32:59 <cmccann> ivanm, get more memory
22:33:03 <cmccann> it's the obvious solution
22:33:07 <ivanm> heh, yeah
22:34:49 <cmccann> "wait for the hardware to improve" is by far the most successful optimization known for software
22:34:56 <cmccann> can't argue with that kind of success
22:59:21 <milkpost> if i am relying a module, Text.Regex.PCRE then how do I get ghc to include it.  '-package regex-pcre' doesn't seem to do it.  i have "import Text.Regex.PCRE ((=~))" in my source file,
22:59:22 <Jafet> @let xo s=let[p,q,l]=[sum[2^k|k<-j,s!!k==c]|c<-"XO|"];o= -1;j=[0..10];w p=any(ap(==)(p.&.))[7,112,273,292,546,1057,1092,1792];n=first(0-);i(n,-1)|n<0=":-("|n>0="-_-'"|True=":-|";i(_,q)=[head[c|(v,c)<-zip[p,q,l,2047]"XO|.",k.&.v/=0]|k<-(2^).j]++if w q then" :-)"else"";x a p b q|w p=(1,o)|w q=(o,o)|True=z[p+k|k<-(2^).j,all((==0).(k.&.))[p,q,l]]where z[]=(0,o);z r=foldr y a r;y p a|a<b=max a(-fst(x(n b)q(n a)p)/2,p)|True=a;in i$x(o,o)q(1,o)p
22:59:23 <lambdabot>  <local>:5:273:
22:59:23 <lambdabot>      Ambiguous type variable `d' in the constraints:
22:59:23 <lambdabot>        `...
22:59:40 <Jafet> Sigh
22:59:50 <ion> jafet: Perl?
22:59:53 <Jafet> milkpost: the easy way is to ghc --make
23:00:06 <milkpost> the tutorial says to use ":mod +Text.Regex.PCRE".
23:00:31 <Jafet> Or that.
23:00:41 <milkpost> Jafet: i am doing that, but it says that RegexMaker and a few other things aren't defined
23:01:28 <ivanm> milkpost: ghc --make
23:01:47 <ivanm> milkpost: that's how to get it inside ghci
23:01:47 <milkpost> ivanm: see above
23:01:50 <ivanm> which do you mean?
23:02:01 <ivanm> what's RegexMaker? :/
23:02:07 <milkpost> no fucking clue
23:02:12 <ivanm> maybe that was something in an old version of PCRE?
23:02:15 <ivanm> have a look at the docs
23:02:21 <ivanm> or you have to import something else
23:02:47 <milkpost> ok, here's the thing, in ghci, if i do "mod +Text.Regex.PCRE" then (=~) works fine
23:03:13 <milkpost> but in a source file, if I do: import Text.Regex.PCRE   OR   import Text.Regex.PCRE ((=~)) it won't compile
23:03:17 <Jafet> ghci automatically loads the package. ghc --make also automatically loads the package.
23:03:31 <Jafet> What's happening is that it compiles, but doesn't link.
23:03:32 <milkpost> ok, well, i'll try some other imports, maybe it's missing something
23:03:41 <ivanm> milkpost: paste your code and the error somewhere
23:03:55 <Jafet> ...or maybe it doesn't compile.
23:04:31 <milkpost> http://hpaste.org/47167/code
23:05:06 <milkpost> http://hpaste.org/47168/error
23:05:07 <ivanm> milkpost: and the error?
23:05:19 <ivanm> note that you usually don't leave a space before the import list when importing modules...
23:06:00 <milkpost> space before teh import list?
23:06:02 <ivanm> milkpost: so you're using it wrong
23:06:11 <ivanm> milkpost: "import Data.List (sortBy)"
23:06:20 <ivanm> usually it's just written as "import Data.List(sortBy)
23:06:21 <ivanm> "
23:06:50 <dmwit> That's not usual for me.
23:06:56 <ion> ditto
23:06:59 <Axman6> me either
23:07:00 <ivanm> dmwit: oh? most code I see does it like that
23:07:01 <ivanm> *shrug*
23:07:04 <ivanm> fine then ;-)
23:07:17 <Jafet> @let xo s=let[p,q,l]=[sum[2^k|k<-j,s!!k==c]|c<-"XO|"];o= -1;j=[0..10];w p=any(ap(==)(p.&.))[7::Int,112,273,292,546,1057,1092,1792];n=first(0-);i(n,-1)|n<0=":-("|n>0="-_-'"|True=":-|";i(_,q)=[head[c|(v,c)<-zip[p,q,l,2047]"XO|.",k.&.v/=0]|k<-(2^).j]++if w q then" :-)"else"";x a p b q|w p=(1,o)|w q=(o,o)|True=z[p+k|k<-(2^).j,all((==0).(k.&.))[p,q,l]]where z[]=(0,o);z r=foldr y a r;y p a|a<b=max a(-fst(x(n b)q(n a)p)/2,p)|True=a;in i$x(o,o)q(o,1)p
23:07:19 <lambdabot>  Defined.
23:07:29 <Jafet> > xo "X..|...|..."
23:07:30 <ivanm> Axman6: yeah, but you learnt from Clem, and his taste in code style is... "interesting" :p
23:07:31 <lambdabot>   "X..|...|..O"
23:07:35 <ion> Are you using OverloadedStrings for the regexp? Perhaps you need to import more than just (=~) for the proper instance.
23:07:48 <dmwit> TABS > SPACES
23:07:49 <Axman6> i learnt from #haskell and the Internet :P
23:08:06 <Jafet> milkpost: you have to add some type signatures to fix the RegexMaker instance
23:08:18 <Axman6> > xo "X..|X..|..O"
23:08:20 <lambdabot>   "X..|X..|.OO"
23:08:44 <Axman6> > xo "X..|X..|XOO"
23:08:45 <lambdabot>   ":-("
23:08:49 <Axman6> :D
23:09:28 <ivanm> are you trying to get lambdabot to play noughts and crosses?
23:09:50 <Jafet> Hm, it's not playing correctly.
23:10:02 <Axman6> sure he is, he's LOSING!
23:10:07 <Axman6> s/he/she/
23:10:17 <ivanm> Axman6: need a "g" on the end...
23:10:29 <Axman6> it's not supposed to be global
23:10:43 <milkpost> Jafet: i don't understand why though, i'm looking in the hakyll source and there they just import that =~~ and compiles fine...
23:10:44 <ivanm> Axman6: you had "he" in your previous statement _twice_
23:10:48 <ivanm> you should fix both of them up!
23:10:57 <Axman6> i was only correcting myself
23:11:14 <ivanm> milkpost: maybe you need the OverloadedStrings extension like ion suggested
23:11:22 <ivanm> the hakyll example could be enabling that elsewhere
23:11:31 <milkpost> i should ask, what's the difference between "import Text.Regex.PCRE" and ":mod +Text.Regex.PCRE"
23:11:41 <ivanm> <Axman6> sure he is, he's LOSING! <-- you have "he" in there twice!
23:11:49 <ion> He’s using the extension but i was speculating that perhaps he’s not importing the ToString instance from whereever it’s defined.
23:11:50 <ivanm> milkpost: latter loads it in ghci
23:11:50 <Jafet> milkpost: perhaps because hakyll uses them in a way that type inference fixes the instances
23:11:52 <ivanm> former in a source file
23:11:55 <Axman6> oh right, oh well!
23:12:09 <Axman6> stop being a pedant! :P
23:12:14 <ion> s/ToString/IsString/
23:12:48 <ivanm> Axman6: no!
23:12:53 <Jafet> @undefine
23:14:25 <Jafet> @let xo s=let[p,q,l]=[sum[2^k|k<-j,s!!k==c]|c<-"XO|"];o= -1;j=[0..10];w p=any(ap(==)(p.&.))[7::Int,112,273,292,546,1057,1092,1792];n=first(0-);i(n,-1)|n<0=":-("|n>0="-_-'"|True=":-|";i(_,q)=[head[c|(v,c)<-zip[p,q,l,2047]"XO|.",k.&.v/=0]|k<-(2^).j]++if w q then" :-)"else"";x a p b q|w p=(1,o)|w q=(o,o)|True=z[p+k|k<-(2^).j,all((==0).(k.&.))[p,q,l]]where z[]=(0,o);z r=foldr y a r;y p a|a<b=max a(-fst(x(n b)q(n a)p)/2,p)|True=a;in i$x(o,o)q(1,o)p
23:14:26 <lambdabot>  Defined.
23:14:35 <Jafet> > xo "X..|...|..."
23:14:37 <lambdabot>   "X..|.O.|..."
23:16:56 <ion> > xo "X..|.O.|..X"
23:16:57 <lambdabot>   "X..|.O.|.OX"
23:17:48 <ion> > xo "XX.|.O.|.OX"
23:17:49 <lambdabot>   "XXO|.O.|.OX"
23:17:53 <adnam> is it possible to export everyhing a module exports and imports without explicitly declaring all imports in the module header?
23:18:40 <adnam> the report seems to say no, but i may be missing something >:|
23:18:47 <Jafet> milkpost: your error is probably that b0 is ambiguous. b0 is the type of the regexp pattern
23:18:54 <milkpost> i think  the problem I'm having is not specifying hte output type?
23:18:57 <Jafet> Use ".(.*)" :: String?
23:19:21 <novodinia> Was there ever a conclusion reached on learning C and OpenGL before using Haskell as opposed to diving into Haskell first and attempting to interpret the Haskell OpenGL bindings without the C/OpenGL background?
23:19:22 <milkpost> i think  the problem I'm having is not specifying hte output type?
23:19:29 <milkpost> whoops, sorry wrong window
23:19:45 <c_wraith> adnam: not quite, but you can use module exports to shortcut it pretty well
23:19:54 <ion> > xo "XXO|.O.|XOX"
23:19:55 <lambdabot>   "XXO|OO.|XOX"
23:19:56 <ivanm> adnam: no
23:19:58 <shachaf> > xo "OOO|OOO|OOO"
23:20:00 <lambdabot>   "-_-'"
23:20:05 <shachaf> > xo "OOO|OOO|OO."
23:20:06 <lambdabot>   "-_-'"
23:20:18 <ivanm> adnam: you need to explicitly list modules you want to re-export
23:20:26 <adnam> okay, thanks
23:20:29 <ion> > xo "XXO|OOX|XOX"
23:20:31 <lambdabot>   ":-|"
23:21:56 <milkpost> goddamn this is annoying
23:23:07 <Axman6> novodinia: you asked in #haskell-blah not here
23:23:32 <Axman6> right, as you then realised and said in #haskell-blah :P
23:23:58 <milkpost> shouldn't "removeDatePrefix id = (toFilePath id) =~ ".*" :: String" force the return type?
23:24:22 <Jafet> It doesn't specify the regexp type. And you're using OverloadedStrings.
23:24:35 <Axman6> (".*" :: String)
23:24:47 <Jafet> Your type signature already forces the return type.
23:25:44 <Jafet> :t (=~)
23:25:45 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
23:25:58 <Jafet> Hm, this offers interesting opportunities for golfing
23:27:12 <ion> @instances IsString
23:27:12 <lambdabot> Couldn't find class `IsString'. Try @instances-importing
23:27:41 <milkpost> well, i found something that worked... weird though, .. this didn't work: removeDatePrefix = flip (=~~) (".(.*)" :: String) . toFilePath
23:28:41 <Jafet> Er, okay.
23:29:21 <milkpost> removeDatePrefix id = (toFilePath id) =~ (".*" :: String)  -- does
23:29:42 <milkpost> so something I'm doing wrong with =~~ i'll go read more, thanks, but this is a start
23:29:55 <ion> =~~, =~?
23:29:59 <Jafet> > "X..|X..|X.." =~ "([XO])(..(\\1|.\\1.)..\\1|.\\1.\\1..$|\\1\\1(...)*$)" :: String
23:30:00 <lambdabot>   "X..|X..|X"
23:30:06 <Jafet> > "X..|.X.|X.." =~ "([XO])(..(\\1|.\\1.)..\\1|.\\1.\\1..$|\\1\\1(...)*$)" :: String
23:30:08 <lambdabot>   ""
23:30:41 <milkpost> yeah
23:32:32 <Jafet> :t (=~~)
23:32:33 <lambdabot> forall source1 source (m :: * -> *) target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
23:32:57 <Jafet> That doesn't look like it's ever compatible with (=~)
23:34:21 <milkpost> :t (=~)
23:34:22 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
23:35:40 <milkpost> i don't understand the difference but one is for a monad or something
23:36:06 <Jafet> > "X..|.X.|X.." =~~ "([XO])(..(\\1|.\\1.)..\\1|.\\1.\\1..$|\\1\\1(...)*$)" :: Maybe String
23:36:07 <lambdabot>   Nothing
23:36:14 <Jafet> Probably.
23:57:38 * hackagebot waitfree 0.1.3 - A wrapping library for waitfree computation.  http://hackage.haskell.org/package/waitfree-0.1.3 (YoichiHirai)
