00:00:29 <chrissbx> http://haskell.org/haskellwiki/What_a_Monad_is_not calls the "monad actions" "mobits"
00:00:37 <Saizan> in particular it's a type with a parameter, since you can have Maybe Char, Maybe Int, Maybe Bool, .., the monad there is Maybe, but it's applied to different types
00:01:21 <Saizan> that's the first time i see that term
00:01:24 <chrissbx> Saizan: but isn't this orthogonal to the whole monad story/theory?
00:01:43 <jan247> hi guys, say i have some helper function 'f' having the type: a -> Maybe (b, a). what's the best way to write the function 'g' that has type: a -> ([b], a), wherein the logic involves recursively executing the function 'f', initially on the first argument of 'g', then the results of the execution of 'f' prior to it. it should end when 'f' results to 'Nothing'
00:01:50 <chrissbx> like, you could write a maybe monad library that's already hardcoded for Int
00:02:23 <Saizan> chrissbx: no, it's pretty much central to it
00:02:46 <chrissbx> I fail to see how
00:04:05 <RayNbow`TU> :t unfoldr
00:04:06 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:04:15 <ourfrank> If my library has a module that uses template haskell to create code at compile-time and at the same time simply has the "hint" library as a build dependency in the cabal file, compilation breaks with a "ghc panic!", "no string tables, or too many" error. Has anyone encountered this maybe?
00:04:17 <Saizan> having a maybe monad specialized to Int would be like having a programming language which can only deal with Int's, you couldn't do most things we do with monads
00:04:50 <ourfrank> Just removing hint from the build-depends completely fixes the problem.
00:05:09 <Jafet> It would be a maybe monad, but it wouldn't be the maybe monad.
00:05:14 <chrissbx> I mean: in Haskell, isn't it maybe the case that using type constructors is tied to type classes, and you need to use type classes to be able to reuse the >> etc names?
00:05:37 <Saizan> ?type mapM -- pretty basic monadic combinator which makes use of the fact monads are supposed to handle any type
00:05:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:05:52 <chrissbx> but you could implement a monad library that uses different names than >> etc, like in ML with +. etc., and do away with type classes, and hence also do away with type constructors?
00:06:14 <Saizan> typeclasses are inessential, but type constructors aren't.
00:07:01 <Saizan> Jafet: it wouldn't be a monad
00:07:18 <chrissbx> Well I'll need more time to figure this out (probably requires me to study type constructors more extensively)
00:07:30 <mm_freak> jan247: your types don't make much sense
00:08:15 <mm_freak> there is only one fully defined function of type a -> Maybe (b, a)
00:08:19 <mm_freak> const Nothing
00:08:49 <jan247> hm, it seems that unfoldr may indeed be close to what i'm looking for.
00:09:22 <jan247> perhaps a simpler problem would be how to construct the infinite list: [x, f x, f (f x), f (f (f x))),...]
00:09:29 <mm_freak> that's iterate
00:09:37 <mm_freak> > iterate (*2) 1
00:09:37 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
00:09:54 <jan247> oh great. thanks mm_freak :)
00:09:56 <chrissbx> (I'm not sure what I'm missing because when I implement monads in Scheme, I don't have type constructors; I didn't even use records, just functions. I'm separating the non-monad from the monad parts mentally. I guess the border between those parts is where the type constructor works. Well just babbling)
00:11:21 <chrissbx> Anyway, thanks. I'm going to sleep over it.
00:11:26 <Saizan> chrissbx: the important part is that (>>=) and return work for any type parameter of the monad
00:12:15 <Saizan> chrissbx: which is probably what you end up having in scheme, since there's no difference there..
00:12:33 <Saizan> unless you're adding explicit checks to restrict their use
00:13:36 * RayNbow`TU wishes for support for restricted monads though
00:13:44 <chrissbx> Saizan: but that's the type classes part; you can solve it in Scheme with an object system (runtime dispatch) or by using macros (select op at compile time)
00:13:45 <Athas> How do you manage version numbers in your Haskell packages?  Having to manually manage the .cabal file, manpage, and possibly program text is annoying.
00:14:08 <Saizan> chrissbx: no, that's not handled by typeclasses in haskell
00:14:19 <chrissbx> Saizan: as I said, if I choose to use a different name of >>= for each kind of monad, then this doesn't apply
00:14:30 <Saizan> chrissbx: typeclasses handle the overloading for different monads, but not for different type parameters of the same monad
00:14:42 <chrissbx> hm
00:15:45 <Saizan> (>>=) for the Maybe monad is still required to handle both Maybe Int and Maybe Bool, even in the same call
00:16:03 <Saizan> > Just 0 >>= \i -> return (even i)
00:16:04 <lambdabot>   Just True
00:16:40 <BMeph> > filterM (const [False, True]) [1,2,3]
00:16:41 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
00:17:28 <Saizan> but that's probably true of your scheme implementation too, unless it's doing something fishy with the value contained
00:19:20 <chrissbx> but there may be monads where there's no need for type parametrization? Say I'll write a Mydb_transaction monad; it threads transactions, and the transaction type is fixed. Nothing to give as a type parameter.
00:19:54 <chrissbx> (say the transaction type is called Transaction)
00:21:17 <chrissbx> I had both kinds in my Scheme implementation: a state monad, that obviously would take various kinds of state, and the transaction monad, which *could* still take various kinds of transaction (well commit) values,
00:21:48 <chrissbx> but is hard tied to a particular implementation of a commit in some places iirc, and definitely I wouldn't have a reason to reuse it for something else,
00:22:04 <chrissbx> so I could imagine it implementing without a type parameter in Haskell.
00:22:06 <Saizan> the support of different kinds of state is not related to what i'm talking about.
00:23:11 <Saizan> anyhow, you can call that a monad, but it won't support most things we do with monads, like most of the combinators defined Control.Monad
00:23:19 <Saizan> *defined in
00:23:42 <chrissbx> ok
00:24:14 <Saizan> btw "you can call that a monad" but it won't match any definition of monad i've seen so far :)
00:24:28 <chrissbx> ok, I'll keep this in mind.
00:24:33 <chrissbx> Thanks again, off to bed now.
00:31:59 <mamalujo> hi! is anyone here familiar with the upcomming superclass equalities stuff? There's a section in the paper that suggests this subsumes the constraint synonyms/families proposal. I'd like to be able to read more on this; does making coercions to be terms subsume the 'Fact Kinds' proposal too then?
00:33:15 <chrissbx> Hm, back from bed, it just occurred to me that Haskeller introduced the type constructor *artificially* to separate the monadic from the non-monadic worlds.
00:33:33 <chrissbx> To prevent mistakes from happening.
00:33:46 <chrissbx> )Correct?)
00:33:53 <chrissbx> (Correct?)
00:34:28 <chrissbx> The monadic world is then forever tagged with the constructed type.
00:35:01 <chrissbx> (Well until you destructure it, in bind)
00:35:12 <chrissbx> (with bind)
00:36:55 <Jafet> Preventing mistakes is just an effect of being able to express the concept of monads in the type system.
00:37:31 <Jafet> (Actually, the type system cannot express the monad laws, so mistakes are still possible.)
00:38:18 <nazgjunk> o.O
00:38:33 <nazgjunk> er.  Mischannel.  Stupid lag.
00:42:33 <poltak> can you use a different package manager than your distro's default? (eg, use portage on fedora)
00:42:59 <chrissbx> Yeah, but it kind of explains it to me: the type constructor is not essential in the sense that Haskell's monads couldn't have been implemented without it; just that it made sense to do so, to express the intent in the types, yes.
00:44:38 <Jafet> In Haskell, Monad is defined as
00:44:41 <Jafet> @src Monad
00:44:41 <lambdabot> class  Monad m  where
00:44:41 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
00:44:41 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
00:44:41 <lambdabot>     return      :: a -> m a
00:44:41 <lambdabot>     fail        :: String -> m a
00:45:04 <Jafet> As you can see, type constructors are pretty essential: Monad m => m a
00:45:23 <Jafet> m is a type constructor
00:45:37 <chrissbx> They could have left away, at the cost of the type system not catching a class of bugs.
00:45:57 <Saizan> even without a type system the point still stands, if you're not allowing the "result type" to vary between the arguments of (>>=), it's pretty useless as a monad, it's more like a monoid
00:46:11 <mamalujo> and (>>=) is the relevant there, return existing as pure in the more liberal Applicative too
00:46:16 <Jafet> Then there would be no Monad in Haskell, only in your mind.
00:46:28 <Jafet> Also known as greenspunning.
00:52:18 <quicksilver> a Monad is the ability to interleave/combine computations with effects; being able to do any computation at any type is part of what makes them monads.
00:52:31 <quicksilver> if you *only* have effects and you don't have arbitrary computation then that is simply a monoid.
00:56:30 <mamalujo> hm, though, typeclassopedia says a monad can be viewed as a kind of monoid. but then there's monadplus for monoid monads too. a bit puzzling...
00:56:50 <quicksilver> that's a different monoid, yes.
00:57:01 <quicksilver> all monads have the property that ()-actions are a monoid
00:57:12 <quicksilver> "return ()" is the identity and ">>" is the operation.
00:57:34 <quicksilver> some monads may have other monoidal structures on them - and that's what MonadPlus is.
00:58:05 <quicksilver> it's a bit like numbers being monoids under (+) and also monoids under (*).
00:58:08 <mamalujo> ahh, right, makes sense. the former doesn't seem like a particularly interesting monoid instance
00:58:19 <quicksilver> depends what you're interested in :)
00:58:23 <mamalujo> heh
00:58:24 <quicksilver> it's the monoid of the effects.
00:58:35 <quicksilver> putStrLn "hello" >> putStrLn " world"
00:58:44 <quicksilver> >> is the monoid which combines actions together to make longer actions.
00:58:59 <quicksilver> "do this then that"
00:59:02 <mgsloan> i.e. It doesn't matter how you associate time :D
00:59:07 <quicksilver> correct.
00:59:24 <quicksilver> and it doesn't matter how often you do nothing :)
01:01:02 <chegibari> Are numeric values tagged/boxed in haskell?
01:01:05 <mgsloan> some might dispute that!  But I suppose haskellers are known for their laziness ;)
01:01:30 <mamalujo> rofl
01:01:36 <mm_freak> i don't like to use the words "monad" and "effect" in the same sentence
01:01:48 <mm_freak> that's almost always more confusing than helping
01:02:10 <quicksilver> chegibari: that's more of an implementation question. Typical implementations box numbers, yes. Optimising can sometimes unbox them.
01:02:26 <quicksilver> mm_freak: do you have a better word for the things monadic actions perform, than effect?
01:02:32 <quicksilver> it's jargon, certainly.
01:02:37 <chegibari> quicksilver: thanks
01:02:44 <quicksilver> but it's moggi's original jargon and I don't know a better way to talk about it.
01:02:48 <mamalujo> if defaulting superclass instances were possible, this hierarchy could be made explicit in the prelude, with actual code defining eg applicative, monoidal structures of every monad..
01:03:07 <mm_freak> quicksilver: i don't split "monad" into mainstream computation and effects
01:03:25 <mm_freak> the sum of these is the monad's semantics
01:03:55 <mm_freak> so what you would call effect would be part of what i would call semantics
01:04:04 <quicksilver> mm_freak: that sounds unhelpful to me.
01:04:18 <quicksilver> the insight about monads is the combination of computation and effect.
01:04:31 <quicksilver> if you don't have separate words for the two parts how can you discuss the combination?
01:04:34 <mgsloan> there are often many monoid views per data structure.  E.g. [a] has both (>>) and (++)
01:04:50 <mm_freak> quicksilver: it's not necessary to have a different way to talk about monads, but i'd prefer a better word than "effect"
01:05:01 <mm_freak> because most people equate "effect" and "side effect"
01:05:25 <mamalujo> yes, I was just puzzlng whether this discussion of effects conflates monads generally w IO
01:06:33 <quicksilver> I don't have a fundamental objection to a different word, but effect is the one I see generally used and it works for me.
01:07:43 <mm_freak> neither is it a bad wordâ€¦  it just has the annoying property that most people have wrong associations
01:08:04 <mm_freak> hence all this "monads allow you to do IO" crap
01:09:19 <mamalujo> I don't have much of an intuition about monads; I just think of it as sequencing computations and plumbing the results around
01:10:37 <mamalujo> I'm not sure if anything beyond its definition is really needed though
01:10:48 <mm_freak> mamalujo: but that's wrongâ€¦  monads don't sequence computationsâ€¦  they sequence effects, if at all
01:10:58 <c_wraith> that's a very state-centric view, anyway
01:11:00 <quicksilver> exactly :)
01:11:04 <quicksilver> that's why you need the word!
01:11:17 <quicksilver> monads sequence *something* - but it's not evaluation that they sequence.
01:11:22 <quicksilver> so you need a word for what they sequence.
01:11:59 <mm_freak> quicksilver: you can describe what they do entirely by semanticsâ€¦  in fact, providing a Monad instances explains everything, at least for the nonmagic monads
01:12:09 <c_wraith> monads are a pattern composition of composition.  Many things (with no other relation between them) can fit into that pattern.
01:12:16 <mamalujo> right, its not sequencing evaluations. in any case, its some ordering. I don't think elements of a list have much to do with effects, in the normal sense of the word at least
01:12:17 <mm_freak> personally i understand better in terms of semantics
01:12:36 <mm_freak> others might understand better in terms of an interpretation (i.e. "computation" and "effect")
01:12:52 <c_wraith> ...  I'm too tired to be typing
01:13:01 <quicksilver> mm_freak: yes, you can explain the semantics of each monad individually - but you also want to understand what they have in common
01:13:25 <Lajla> Allow me to be philosophical
01:13:44 <Lajla> But wouldn't you say that monads describe sequences and it's up to some interpretation mechanism to sequence them appropriately?
01:13:52 <mm_freak> c_wraith: the effect of the list monad has little to do with the order of the elemets themselves, but rather how the set of elements got to be there in the first place
01:13:55 <Lajla> And in that monads are basically a datatype like let's say lists?
01:14:00 <mm_freak> oops
01:14:05 <mm_freak> that was for mamalujo
01:14:26 * BMeph would say absolutely not...but that's just him.
01:14:39 <mm_freak> quicksilver: obviously you should know the Monad class, before reading a Monad instance =)
01:14:48 <mm_freak> that's what they have in common, plus add the monad laws
01:15:55 <mm_freak> quicksilver: in fact, if you forget all the interpretations and just look at the type of (>>=), i find it pretty straightforward to understand what it's all about
01:16:07 <mm_freak> you don't even need a certain instance to understand it
01:16:40 <mm_freak> 'Monad m => m a -> (a -> m b) -> m b' is a perfectly reasonable and understandable type to me
01:17:11 <mamalujo> mm_freak: right, still 'got to be there' sounds a bit, hm mutable I guess
01:18:33 <mm_freak> mamalujo: now you're splitting hairs
01:19:18 <mm_freak> haskell doesn't forbid things to slip into existence, it just forbids them to change their mind later =)
01:22:14 <mamalujo> mm_freak: hmm, well sry no, the entire discussion is whether a word 'effect' is the best way to put it; i think I'm no worse in asking whether 'getting to be' is any different.
01:22:51 <mamalujo> I didn't think hs said things spring into existence; I thounght it was just defining what things are
01:24:02 <mamalujo> in any case, its a terrible sidetrack to begin with, sry for persisting
01:24:13 <mm_freak> mamalujo: true, getting to exist belongs to the execution world
01:24:45 <mm_freak> normally i would use the word semantics (again)
01:25:53 <mm_freak> if you're particularly picky about terminology, then "behaviour" is also wrong, just like almost all other "real world" words
01:26:29 <mm_freak> probably that's why we have "monad" and not some fancy marketing term
01:27:20 <mm_freak> on the other hand it's quite colloquial in the haskell community to talk about monadic values as "actions"
01:27:35 <mm_freak> this is probably much worse than "effect"
01:28:18 <mm_freak> i like how "mobit" makes fun of qubits
01:29:14 <mm_freak> however, "mobit" is indeed a good word for 'Monad m => m Bool'
01:29:17 <mm_freak> ok, enough spam
01:31:13 <mamalujo> lol
01:42:47 <Lajla> mm_freak, not that I can claim expertise, but a friend of mine is doing a Ph.D. in category theory and he says that the monads of Haskell are not the monads of category theory.
01:43:54 <mamalujo> I think the definitions are equivalent, apart from hs not guaranteeing that monad laws hold, however the (equivalent) operations they are defined by commonly in category theory are not those familiar to us in hs.
01:44:47 <Saizan> haskell Monad's are what you get if you specialize CT's monads to the category usually called Hask
01:45:16 <Saizan> i.e. the one where objects are types of kind * and morphisms are functions between those types
01:45:31 <quicksilver> and choose your definition of equality between morphisms a bit carefully w.r.t. _|_
01:49:42 <Saizan> that's not the only useful specialization you can have in haskell, you could e.g. use types of kind * -> * as objects instead
01:50:41 <mamalujo> righ, was just about to ask about that - so there could be a family of monad classes in hs, like w typeable etc?
01:50:52 <mamalujo> why aren't they defined then?
01:52:47 <Saizan> they are not popular enough :)
01:53:02 <mamalujo> :)
01:55:12 <mamalujo> in any case, 'hs monads are ct monads' is true, but the reverse not
01:56:02 <Jafet> Not all Monads are monads, either...
01:56:12 <poltak> Jafet: you're wrong there
01:56:39 <mamalujo> if they're breaking the monad laws, I presume, Jafet ?
01:56:40 <MHD0> Any of you know stuff about parser monads?
01:57:27 <Jafet> Nevermind, I didn't read the conversation
02:01:06 <mamalujo> btw any chances upcomming extensions of the type systems would enable collapsing such kind hierarchies like this, or typeable or monoid/alternative-monadplus/arrowplus ?
02:01:53 * hackagebot loch-th 0.1 - Support for precise error locations in source files (Template Haskell version)  http://hackage.haskell.org/package/loch-th-0.1 (TomasJanousek)
02:03:30 <Liskni_si> sshc: ^^ as promised
02:03:48 <Saizan> mamalujo: you'd need kind variables :)
02:04:19 <mamalujo> but they're talking about collapsing types and kinds into typekinds, so, that's covered ?
02:04:35 <poltak> java vs haskell... opinions?
02:05:07 <Jafet> I prefer tea
02:05:13 <Saizan> mamalujo: depends on how you can use them
02:05:23 <mamalujo> hmm, right
02:05:32 <MHD0> java has it's applications
02:05:49 <MHD0> and an absolutely TREMENDOUS standart library
02:05:58 <mamalujo> Jafet: brillant idea :off to make earl grey:
02:06:18 <poltak> Jafet: please don't start this again
02:06:35 <MHD0> Haskell is the nicer language IMO
02:06:51 <poltak> MHD0: do you view the "TREMENDOUS" library a good or bad thing?
02:06:52 <Jafet> I've always been drinking tea.
02:07:06 <poltak> Jafet: alright, I'm going to continue to ignore you
02:07:13 <MHD0> poltak: A good thing in the "java has its applications" part
02:07:23 <Jafet> Why don't you go ask the channel for Java?
02:07:36 <Jafet> Or perhaps you're doing that too.
02:07:41 <poltak> Can I hear air?
02:07:48 <poltak> *swiiish*
02:08:10 <mamalujo> um, is this a coffee vs tea thing?
02:08:21 <MHD0> Anyway, you guys know how Parsec is continuation based right?
02:08:29 <poltak> No, player. We're talking about programming languages
02:08:40 <poltak> Yes, go on MHD0
02:08:50 <Jafet> Maybe he's referring to the island.
02:09:19 <MHD0> How would an ST based parser fare in comparison?
02:09:45 <poltak> Jafet: Let me make it clear to you that we are NOT refering to the island
02:10:15 <Saizan> MHD0: i don't see the dichotomy
02:10:15 <mamalujo> poltak: Jafet seemed to be diverting the topic to beveriges though :) (i guess such should go to -blah chan, but discussions so far have been very loose anyway)
02:10:24 <Jafet> Then why the hell are you here, poltak?
02:10:49 <MHD0> I was thinking that a more stateful parser perhaps would be just as efficient?
02:10:56 <poltak> I'm sick of this! Reported
02:11:02 <poltak> going for a walk for a little bit to cool down
02:11:14 <MHD0> poltak: You do that
02:11:53 <Jafet> MHD0: what's "more stateful"? Continuations are just a way to pass around state.
02:12:04 <mamalujo> what just happened? or rather nvm...
02:12:08 <Saizan> continuations are used to handle backtracking.
02:12:10 <MHD0> Jafet: Nvm :)
02:12:35 <Saizan> i don't see how ST helps with that
02:13:13 <MHD0> Saizan: I'll com back when I have some code
02:43:06 <manateeUser> å¤§å®¶å¥½ã€‚
02:43:14 <manateeUser> Hello everybody
02:43:53 <dmwit> Hi!
02:44:25 <manateeUser> dmwit: Hey. :)
02:44:29 <poltak> is that russian?
02:44:41 <dmwit> Chinese is my bet.
02:44:51 <dmwit> Based on appearance and knowing manateeUser is a Chinese guy. =)
02:44:52 <poltak> doubt it
02:45:14 <manateeUser> dmwit: Haha, i'm show my irc translate features to my friends. :)
02:45:31 <dmwit> manateeUser: Oh, cool!
02:45:34 <dmwit> Hi, friends.
02:45:42 <poltak> I'm not your friend
02:45:45 <luite> come all learn haskell!
02:45:46 <quicksilver> dmwit: I always thought manateeUser was, potentally anyone using 'manatee'
02:45:58 <manateeUser> quicksilver: Yes.
02:45:58 <quicksilver> dmwit: it's not necessarily Andy - although perhaps he is the main user :)
02:46:05 <osfameron> in parsec, why are the parser combinators not actually functions?
02:46:08 <manateeUser> yes. :)
02:46:19 <dmwit> Oh, manateeUser is the default nick for the manatee program?
02:46:26 <quicksilver> for its embedded IRC client, yes
02:46:29 <osfameron> i.e. you can't: parseExpr "foo" directly, as the result of the combinator isn't a function
02:46:36 <manateeUser> dmwit: Yes, it's a default nick for my irc client.
02:46:37 <dmwit> I didn't realize that. I just assumed ManateeLazyCat had decided to shorten his name. =)
02:46:52 <osfameron> ah, me too
02:46:53 <quicksilver> osfameron: abstraction.
02:46:59 <manateeUser> dmwit: Haha. :)
02:47:22 <Entroacceptor> poltak: it's "I'm not your friend, palooka"
02:47:41 <osfameron> quicksilver: ah. I guess that makes sense. So you could, instead of running the parser, give it to a routine that visualized the parser etc?
02:47:49 <dmwit> pal... palooka?
02:47:58 <poltak> Entroacceptor: What the bloody hell are you on about?
02:48:12 <quicksilver> osfameron: yes. In principle.
02:48:23 <Entroacceptor> that: http://www.imdb.com/title/tt0110912/quotes
02:48:38 <quicksilver> osfameron: actually parsec parsers are not really introspectable - in general, monadic parsers cannot be.
02:48:46 <quicksilver> osfameron: but that's the basic idea.
02:49:22 <osfameron> quicksilver: ah. I guess you'd have to run the parser in a function that extracts information from it as it runs instead?  Is that practical?
02:49:37 <osfameron> i.e. *are* there existing abstractions other than the parsing one?
02:49:52 <quicksilver> some non-monadic parsers can be much more introspectable
02:50:06 <quicksilver> that's one of the big disadvantages of the monad as an abstraction
02:50:18 <quicksilver> because it embeds arbitrary computation, it's hard to pick it apart
02:50:37 <quicksilver> osfameron: in point of fact, the parser implementation is not quite just a simple function : http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/src/Text-Parsec-Prim.html#ParsecT
02:56:28 <ManateeLazyCat> Today fix a bug belong to GTK+ , damn it, i will crash if i can't fixed it today. :)
02:56:29 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
03:03:06 <zygoloid> ManateeLazyCat: you will crash? i always suspected you were a haskell irc bot which had got out of hand. no human is so productive :)
03:04:02 <ManateeLazyCat> @where+ manatee http://haskell.org/haskellwiki/Manatee
03:04:03 <lambdabot> It is forever etched in my memory.
03:05:32 <poltak> learn you a haskell for great good!
03:05:42 <ManateeLazyCat> zygoloid: Hehe. :)
03:09:38 <ManateeLazyCat> zygoloid: I'm not robot. :)
03:15:05 <dcoutts> Athas: cabal provides a way to get the program version at runtime
03:16:27 <ManateeLazyCat> zygoloid: I'm developing new Software-Center that much better than Ubuntu's software-center. :)
03:16:32 <Athas> dcoutts: maybe that will be enough...
03:16:33 <magthe> what's the easiest way to get ghc7 onto a system running debian stable?
03:16:39 <ManateeLazyCat> zygoloid: Unfortunately, it's written by Python. :)
03:16:58 <Athas> magthe: apt-get install ghc/unstable
03:17:17 <dcoutts> Athas: and if you automate the generation of your man page from the Setup.hs code then you can insert the version automatically there too I suppose
03:17:18 <Athas> Check that doesn't have unstable dependencies, of course.
03:17:27 <Athas> dcoutts: yes, that sounds rather trivial, thanks.
03:17:48 <ManateeLazyCat> zygoloid: http://bbs.ylmf.net/forum.php?mod=viewthread&tid=1927204
03:18:11 <ManateeLazyCat> zygoloid: Second picture is my software-center. :)
03:18:19 <magthe> Athas: I was hoping there'd be an unofficial repo somewhere for it, but I guess I'll have to try the unstable route
03:18:50 <Athas> magthe: that's an offical repo!
03:19:10 <ManateeLazyCat> @where manatee
03:19:11 <lambdabot> http://haskell.org/haskellwiki/Manatee
03:19:16 <ectospasm> ...I can see why folks said realworldhaskell is drier and harder to follow than learnyouahaskell
03:19:17 <Athas> I use it to get GHC7 on my Debian testing, so it should work for you too.
03:19:33 <ManateeLazyCat> @tell ski Thanks, i have add manatee information in command @where. :)
03:19:33 <lambdabot> Consider it noted.
03:19:47 <ectospasm> of course, Haskell still makes my brain hurt
03:20:24 <ManateeLazyCat> ectospasm: Every haskell newbie will hurt, :)
03:20:51 <ManateeLazyCat> ectospasm: Special you're java expoert. :)
03:20:58 <ectospasm> ManateeLazyCat: I'm finding my (ancient) Lisp experience is absolutely no help. (-;
03:21:20 <ectospasm> ...of course, I always had a love-hate relationship with Lisp
03:21:31 <ectospasm> it wasn't until my programming language theory class that it made sense
03:21:45 <ManateeLazyCat> ectospasm: Hehe, I'm write lisp code before, you just need stay here some time, so many kind guys will help you. :)
03:21:50 <ectospasm> heh, my first foray with Lisp was to flowchart this Lisp program
03:21:51 <magthe> Athas: sure, unstable is official, but mixing it onto a stable system is always a bit tricky... an unofficial repo containing ghc7 compiled for stable would have been preferable
03:22:04 <ectospasm> I didn't know what recursion was, so...
03:22:38 <ManateeLazyCat> ectospasm: When i first time learn Haskell, it confuse me completely.
03:23:28 <ManateeLazyCat> ectospasm: And now, it's my favourite language. :)
03:23:48 <Cradam_> how powerful is haskell?
03:23:54 <ectospasm> yeah, working through the exercises in the beetle book have me shouting expletives
03:23:56 <ManateeLazyCat> Cradam_: Everything
03:24:13 <dmwit> Haskell is 7 horsepower.
03:24:16 <dmwit> Next question.
03:24:22 <ectospasm> ...mainly because I don't want to have relearn everything I've forgotten from my CS program...
03:24:39 <ManateeLazyCat> ectospasm: We always need learn new language. :)
03:25:10 <ectospasm> ManateeLazyCat: I think *need* is a strong word here...
03:25:13 <ManateeLazyCat> ectospasm: Haskell worth you learn.
03:25:24 <ectospasm> I'm only learning Haskell so I can better understand xmonad
03:25:28 <Cradam_> i am trying out tryhaskell.org
03:25:30 <ectospasm> ...and maybe extend it
03:25:35 <ManateeLazyCat> ectospasm: Haha. :)
03:25:47 <ectospasm> the extend it part probably won't happen
03:25:53 <dmwit> yay, xmonad is a gateway drug to Haskell ^_^
03:26:05 <dmwit> ectospasm: Feel free to join us in #xmonad in case you aren't there already.
03:26:15 <ectospasm> But I want to be able to modify xmonad.hs and at least know what I'm doing
03:26:18 <dmwit> I see you are there already. So never mind. =P
03:26:20 <Cradam_> im only trying it because i dont have a compiler
03:26:21 <ectospasm> dmwit: yeah, I'm already there.
03:26:28 <Cradam_> so i cant use a proper language like C
03:26:28 <ManateeLazyCat> ectospasm: Yes, you need learn Haskell if you want to play XMonad well. :)
03:26:32 <ectospasm> dmwit: but this discussion is about Haskell.
03:27:23 <ectospasm> ManateeLazyCat: I now know how to add arbitrary keys for my myriad workspaces.  That's about all I've been able to do
03:28:14 * ManateeLazyCat pasted "my xmonad configure file" at http://paste2.org/get/1421079
03:28:20 <ectospasm> getting the list syntax and concatenation operator ("++") working took some help from folks in #xmonad
03:28:25 <ectospasm> ...but I got it now
03:28:34 <ManateeLazyCat> ectospasm: http://paste2.org/get/1421079 is my configure file, maybe help
03:28:35 <ManateeLazyCat> :)
03:28:36 <ectospasm> hopefully I won't forget if I need to extend it again.
03:28:50 <ManateeLazyCat> :t (++)
03:28:51 <lambdabot> forall m. (Monoid m) => m -> m -> m
03:29:07 <ManateeLazyCat> > "I love " ++ "haskell"
03:29:08 <lambdabot>   "I love haskell"
03:29:27 <Cradam_> IE doesnt like tryhaskell
03:29:46 <ectospasm> my Holy Grail is to be able to get a calendar widget to popup when I click the clock region of xmobar.  I hear it may be far simpler to achieve that with dzen...
03:30:13 <ManateeLazyCat> ectospasm: So (++) is operator to connect two *list*. :)
03:30:25 <uberwan> Cradam_: IE doesn't like the internet
03:30:36 <uberwan> and the internet doesn't like IE
03:30:36 <ectospasm> ManateeLazyCat: yep!
03:30:45 <Cradam_> i hate public computers
03:31:01 * ectospasm tries to avoid public computers
03:31:21 <ManateeLazyCat> ectospasm: I need go home, bye, good to see you. :)
03:31:31 <ectospasm> if I can't be 100% sure there are no keyloggers...
03:31:35 <ectospasm> ManateeLazyCat: OK, cya l8r!
03:32:25 <Cradam_> i dont have a comp at home
03:32:52 <Cradam_> well i do its just mom wont give me the power leads#
03:33:26 <uberwan> you can buy a new power lead, they're not expensive
03:34:03 <ectospasm> lack of independence is difficult
03:34:24 <uberwan> doesn't your mother understand that keeping your away from your computer will stop you from becoming a great rockstar programmer millionaire?
03:35:01 <uberwan> How old are you?
03:35:43 <dmwit> ectospasm: Why don't you run trayer + an in-tray clock?
03:35:59 <dmwit> Or use Gnome's thing or whatever.
03:36:00 <Cradam_> 18 in 2 months
03:36:19 <dmwit> No reason to shoehorn a calendar widget into xmobar...
03:36:36 <Cradam_> plus their is a big gap between not expensive and no money
03:36:41 <uberwan> And you can't use a computer at home? That's quite silly. I should have a serious talk with your parents.
03:37:48 <Cradam_> i should have a serious talk with the wall then
03:37:52 <ectospasm> dmwit: that's a good point, hadn't thought of that
03:38:07 <Cradam_> or have a serious talk with the park bench and my sleeping bag
03:38:37 <uberwan> can't you get a job?
03:38:56 <dmwit> Dude, knock it off.
03:39:10 <ectospasm> uberwan: he's trying to learn Haskell so he can get a job...
03:39:12 <dmwit> Cradam_ is doing the best he can, you don't know his situation, and he's having a good time learning Haskell.
03:39:20 <dmwit> Why not encourage him instead of berating him?
03:39:35 <uberwan> Easy there, I am the one who told him to go here
03:40:17 <Jafet> I'm not sure if Haskell is a good way to get a job.
03:40:53 <UberBaron> Also, I would encourage him to get a job, but I don't know if there are jobs wherever he is.
03:48:26 <Cradam_> there arent
03:49:43 <UberBaron> the american dream fails again
03:50:17 <UberBaron> tough situation, sorry man
03:50:50 <UberBaron> If you want get a programming job though, you'd best learn the opposite language to Haskell: PHP
03:51:05 <UberBaron> sad but true
03:52:02 <UberBaron> you don't need to compile that either
03:52:11 <UberBaron> you just need a server with write access than can run PHP
03:52:19 <UberBaron> should be available for free
03:52:26 * gienah thinks its a good idea to do what you love, haskell seems like a more loveable language than PHP
03:53:25 <UberBaron> Well he doesn't even know if he'll love Haskell yet, and PHP is... not that terrible a language anymore. I mean compared to a few years ago.
03:53:36 <UberBaron> Plus they're hiring PHP people like crazy
03:54:14 <gienah> its probably a good idea to write some stuff in whatever language and publish it on github
03:54:55 <UberBaron> Idk, if you want to get hired, they usually have pretty specific demands, especially if you don't have a degree
03:55:16 <UberBaron> don't get me wrong, that's just reality as I perceive it
03:56:54 <UberBaron> learning PHP won't make you a good developer. In fact, it might actually help you make the worst out of you. But it might land you a job!
03:57:34 <obbele> UberBaron: what's the difference betwwen a good and a bad programmer ? :p
03:58:02 * obbele should not troll this early in the morning
03:58:18 <dmwit> obbele: About $60k/year salary, and about $180k/year to the company, I'd bet.
03:58:46 <UberBaron> I said developer, not programmer anyway ;)
03:59:41 <Entroacceptor> UberBaron: otoh php can make you a great developer
04:00:02 <UberBaron> In fact PHP might make you a war-hardened veteran developer/sociologist
04:00:14 <UberBaron> right I was thinking about the other side of the medal there
04:00:18 <Entroacceptor> :)
04:02:11 <ski> @messages
04:02:11 <lambdabot> ManateeLazyCat said 42m 38s ago: Thanks, i have add manatee information in command @where. :)
04:02:38 <UberBaron> there's still the difference of learning PHP and having experience using it in production, the latter which can be invaluable
04:05:22 <spirit> if i have a list that looks like this: [(1,"a"),(2,"b"),(3,"c")] and i read it as a string from a file -- is there an easy way of transforming it into a list of pairs for haskell? so far i tried split, was wondering if there's something a little more simple.
04:06:00 <osfameron> spirit: read ?
04:06:39 <mm_freak> > read "[(1, \"a\"), (2, \"b\")]" :: [(Int, String)]
04:06:39 <lambdabot>   [(1,"a"),(2,"b")]
04:09:46 <spirit> brilliant! :-)
04:12:52 <hpc> > read [1..10]
04:12:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
04:12:53 <lambdabot>    arising from the literal `1...
04:12:57 <hpc> :(
04:13:04 <ion> > show [1..10]
04:13:04 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10]"
04:13:32 <hpc> ion: wanted to see if Char had a Num instance
04:14:12 <siracusa> spirit: Your code will break if the input is incorrect, better use reads.
04:16:46 <spirit> i write those files automatically, so the input should be correct.
04:16:52 <ski> > case (reads :: ReadS [(Int, String)]) "[(1, \"a\"), (2, \"b\")]" of [(x,"")] -> Just x; _ -> Nothing  -- spirit, like this e.g.
04:16:53 <lambdabot>   Just [(1,"a"),(2,"b")]
04:18:21 <spirit> cheers, got that :-)
04:23:59 <rostayob> is there a way to read a file to a bytestring incrementally?
04:24:15 <quicksilver> lazy bytestrings, yes.
04:24:28 <rostayob> so readFile will read the file incrementally
04:24:33 <quicksilver> strict bytestrings, no. Unless you count bytestring-mmap.
04:25:11 <rostayob> so let's say i have to parse a really big binary file, the parsing itself is really simple
04:25:24 <rostayob> the best way is to use a lazy bytestring?
04:25:36 <hpc> it's certainly the simplest
04:25:46 <hpc> just change a type or two and you are pretty much done
04:26:00 <rostayob> well in cases like these I don't think that you need a complex solution to go fast
04:26:09 <rostayob> the best way would be to read the file in chunks maybe
04:26:15 <rostayob> and use continuations to parse it
04:27:17 <rostayob> but apparently you can't read a file in chunks with simple ByteStrings mhm
04:28:35 <ski> @type Data.ByteString.Lazy.hGetContents
04:28:36 <lambdabot> GHC.IO.Handle.Types.Handle -> IO BSLC.ByteString
04:28:38 <Lemmih> You can. You just have to do it manually.
04:28:42 <gienah> rostayob: maybe bytestring-mmap (I have not used it)
04:28:54 <rostayob> gienah: what if the file is biggest than the available ram?
04:29:41 <gienah> rostayob: as far as mmap is concerned at the operating system level, there is a difference between virtual memory and committed memory
04:29:43 <rostayob> ski: yeah i'll probably use lazy bytestrings
04:30:01 <rostayob> gienah: yeah but if i'm on a 32bit system and i have to mmap a 8GB file
04:30:20 <gienah> rostayob: oh, that is a problem :-/
04:30:53 <rostayob> Lemmih: what do you mean?
04:31:07 <gienah> rostayob: as of course the 32 bit os will not be able to mmap an 8 GB file
04:31:08 <mauke> rostayob: hGet
04:32:13 <rostayob> mauke: oh, that's what I'm looking for it seems
04:58:57 * hackagebot MonadPrompt 1.0.0.3 - MonadPrompt, implementation & examples  http://hackage.haskell.org/package/MonadPrompt-1.0.0.3 (JamesCook)
05:06:21 <spirit> how do i get the contents of a file, as a string, line by line?
05:07:07 <obbele> @type lines
05:07:08 <lambdabot> String -> [String]
05:07:42 <Jafet> Is IO allowed today?
05:07:48 <Jafet> ...
05:08:09 <Silvah> Jafet: No it's not.
05:08:27 <sipa> @type liftM lines getContents
05:08:28 <lambdabot> IO [String]
05:09:50 <hpc> :t lines <$> getContents
05:09:50 <lambdabot> IO [String]
05:10:24 <ski> @type lines `fmap` getContents
05:10:25 <lambdabot> IO [String]
05:10:27 <Silvah> :t getContents >>= return . lines
05:10:28 <lambdabot> IO [String]
05:10:30 <ski> @type lines . getContents
05:10:30 <lambdabot> IO [String]
05:10:40 <ski> @pl getContents >>= return . lines
05:10:40 <lambdabot> lines `fmap` getContents
05:11:23 <obbele> @type \filename -> lines `Äfmap` readFile filename
05:11:24 <lambdabot> parse error (possibly incorrect indentation)
05:11:27 <Silvah> :t undefined getContents
05:11:28 <lambdabot> forall t. t
05:11:34 <obbele> @type \filename -> lines `fmap` readFile filename
05:11:35 <lambdabot> FilePath -> IO [String]
05:11:43 <FUZxxl> Someone with knowledge in c2hs?
05:11:51 <ski> @type (lines `fmap`) . readFile
05:11:52 <lambdabot> FilePath -> IO [String]
05:11:59 <ski> @type (lines .) . readFile
05:12:00 <lambdabot> FilePath -> IO [String]
05:12:05 <ski> @type lines .: readFile
05:12:06 <lambdabot> FilePath -> IO [String]
05:12:12 <obbele> FUZxxl: yep, I have used it a bit
05:12:15 <Silvah> I think that undefined is the best way to read a file line by line, it doesn't have IO (but it can) in it's type.
05:12:34 <sipa> ...
05:13:03 <Silvah> IO was not allowed yesterday.
05:13:13 <obbele> why not ?
05:13:25 <ski> hm .. i suppose one could use TH to read the file at compile-time .. no I/O when the program runs ! :)
05:13:53 <Silvah> I dunno.
05:14:17 <mm_freak> i love how obbele was the first to really answer spirit's question =)
05:14:37 <mm_freak> :t fmap lines . readFile
05:14:37 <lambdabot> FilePath -> IO [String]
05:15:35 <spirit> apologies for asking newbie stuff
05:15:45 <obbele> spirit: no apologies needed
05:15:49 <mm_freak> spirit: none needed
05:15:50 <hpc> #haskell loves answering newbie stuff
05:16:00 <hpc> @quote friend
05:16:01 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
05:16:01 <lambdabot> will stab you in the back with a mantissa
05:16:16 <hpc> not the right quote...
05:16:28 <obbele> spirit: what's really helpful for this kind of question is hoogle, how do you ask lambdabot/hoogle the function with type String -> [String]
05:16:40 * ski . o O ( "Mantissa warrior" )
05:17:00 <mm_freak> spirit: i just found it funny how people like to divert from answering the actual question to finding an elegant solution to a different problem
05:17:34 <ski> well .. we like to have our fun, too
05:17:42 <spirit> :-)
05:17:53 <ivan_m> if I have (Map a [a]) denoting a directed graph (I also have another Map for reverse edges if it helps), how can I create another Map denoting all the nodes reachable from a specified node?
05:18:06 <obbele> @hoogle :: String -> [String]
05:18:07 <lambdabot> Prelude lines :: String -> [String]
05:18:07 <lambdabot> Prelude words :: String -> [String]
05:18:07 <lambdabot> Data.List lines :: String -> [String]
05:18:26 <mm_freak> ivan_m: build a Set recursively?
05:18:29 * obbele thanks Hoogle
05:18:43 <ivan_m> mm_freak: yeah; it's the stopping that's the problem
05:18:50 <ski> mm_freak : .. and cycles ?
05:18:57 <mm_freak> ivan_m: stop at nodes, which are already in the set
05:19:05 <ivan_m> I actually want all those that are reachable but _not_ adjacent, but that's relatively easy once I have all the ones that are reachable
05:19:15 <ivan_m> mm_freak: oh, a fixed point?
05:20:05 * ski wonders what would be good abstraction for folding over graphs, allowing non-idempotent operations
05:21:15 <ski> (e.g. computing liveness in a control-flow graph .. preferably lazily, with only a single traversal of the graph)
05:22:38 <ivan_m> ski: hmmm.... what do you mean by "liveness" ?
05:23:05 <ivan_m> preflex: seen Baughn
05:23:06 <preflex>  Baughn was last seen on #haskell 1 day, 23 hours, 28 minutes and 24 seconds ago, saying: chrisdone: Nothing terribly standalone. You'll have to use your imagination, and consider how often your own coding veers into syntactically incorrect territory.
05:23:40 <ski> ivan_m : graph nodes can access "variables", outgoing graph edges (how many depends on the kind of node) can set "variables"
05:23:51 <ski> which variables are live at each point ?
05:23:55 <ivan_m> mm_freak: though you have to do that for each individual node, right? (unless you're very careful with tying the knot) ?
05:24:36 <ivan_m> I was trying to work out some way of doing a single fold over the list of nodes, updating the successors/predecessors of the specified node at each point
05:24:41 <ivan_m> probably too complicated though
05:25:18 <ivan_m> ski: hmmm...
05:25:41 <ski> ivan_m : imagine a block in C, with assignments and `if's and labels and `goto's ..
05:25:51 <FUZxxl> obbele: That's great.
05:25:56 <FUZxxl> Do you have time in about 2h?
05:26:56 <ski> (a variable is live at a node if there is a descendant node which accesses it, with no intermediate set of the variable in between)
05:27:54 <mm_freak> ivan_m: i would just recurse through the nodesâ€¦  you visit each node once
05:27:55 <ivan_m> so you have a control flow graph?
05:28:08 <mm_freak> on the second visit, you just ignore the node
05:28:26 <ski> <ski> (e.g. computing liveness in a control-flow graph ...)
05:28:41 <ivan_m> mm_freak: hmmmm.... probably won't work too well on loops...
05:29:07 <mm_freak> ivan_m: it should be finite at least
05:29:23 <mm_freak> unless your graph itself is infinite
05:29:32 <ivan_m> maybe I misunderstood what you meant
05:29:49 <ivan_m> to find the nodes reachable from n, see if it's in the Map
05:30:00 * hackagebot tuple-th 0.1 - Generate (non-recursive) utility functions for tuples of statically known size  http://hackage.haskell.org/package/tuple-th-0.1 (DanielSchuessler)
05:30:10 <ivan_m> if it isn't in there, then set it to be union (map reachable $ successors n)
05:30:25 <mm_freak> findAdjacent :: Ord a => Map a [a] -> State (Set a) ()
05:30:44 <mm_freak> wait a minute
05:30:47 <mm_freak> is that even a graph?
05:31:02 <mm_freak> oh, wait, i had a different data structure in mind
05:31:15 <mm_freak> Mu (Map a)
05:31:16 <ivan_m> heh
05:31:34 <ivan_m> well, this isn't the actual data structure I'm using; it's just an intermediary representation
05:31:51 <ivan_m> what's Mu again?
05:32:02 <ivan_m> Map a (Map a (Map a ... )) ?
05:32:28 <Jafet> Mu (Map a)
05:32:30 <mm_freak> yeah
05:32:34 <mm_freak> well, almost
05:32:48 <Jafet> = In (Constr (In (Constr ...
05:32:55 <ivan_m> how, pray tell, does that even end?
05:33:03 <ivan_m> and how does it represent a graph?
05:33:13 <mm_freak> with an empty map it ends
05:33:27 <ivan_m> oh, right
05:34:23 <sohum> @src transpose
05:34:23 <lambdabot> transpose []             = []
05:34:23 <lambdabot> transpose ([]   : xss)   = transpose xss
05:34:23 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
05:34:55 <ivan_m> sohum: are you coming to AusHac 2011?
05:35:44 <sohum> ivan_m: I don't think so. I have some personal reasons why I'm not free this winter, not to mention that it's honours year
05:35:51 <ivan_m> sohum: :(
05:36:06 <sohum> yea, :(
05:36:09 <ivan_m> mm_freak: so how do you represent a loop in Mu (Map a) ?
05:36:58 <ivan_m> actually, I seem to recall implementing something like this before; just that it recomputed the results for each node
05:38:12 <mm_freak> ivan_m: just let it loopâ€¦  a loop is an infinite recursion
05:38:23 <ivan_m> *nod*
05:38:48 <mm_freak> if you view lists as graphs, then 'cycle [1,2,3]' is a loop
05:38:55 <mm_freak> it's a circle-like graph
05:39:00 <ivan_m> *nod*
05:39:00 <mm_freak> s/like/shaped/
05:40:10 <ivan_m> to deal with loops, I think that reachable would have to delete each node from the graph before recursing...
05:40:36 <ivan_m> and then be clever about how to deal with edges that go to nodes that have been deleted
05:40:36 <ski> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]  -- sohum
05:40:37 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
05:41:26 <mm_freak> ivan_m: you're misunderstanding my algorithm, i think
05:41:30 <ski> mm_freak : how to you sum contents of nodes ? :)
05:41:36 <mm_freak> it's really nothing clever
05:41:50 <ivan_m> mm_freak: quite possibly
05:41:52 <sohum> ski: oh, that is clever
05:41:55 <ivan_m> what are you suggesting?
05:42:02 <ivan_m> and does it rely upon using Mu ?
05:42:51 <mm_freak> with the list approximation the algorithm would stop at the first element found, which has been already observed
05:43:08 <mm_freak> hence only four elements would be checked (the fourth is the first again)
05:43:21 <mm_freak> this can be generealized to arbitrary graphs
05:43:23 <ski> @type (getZipList . foldr (liftA2 (:)) (pure []) . map ZipList) [[1,2,3],[4,5,6],[7,8,9]]
05:43:23 <lambdabot> forall a. (Num a) => [[a]]
05:43:27 <ski> > (getZipList . foldr (liftA2 (:)) (pure []) . map ZipList) [[1,2,3],[4,5,6],[7,8,9]]
05:43:29 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
05:43:36 <ski> > (getZipList . sequenceA . map ZipList) [[1,2,3],[4,5,6],[7,8,9]]
05:43:37 <lambdabot>   Not in scope: `sequenceA'
05:43:52 <mm_freak> ivan_m: Mu is just the only type lambdabot provides =)
05:43:56 <mm_freak> you would write your own data structure
05:43:57 <ski> > (getZipList . Data.Traversable.sequenceA . map ZipList) [[1,2,3],[4,5,6],[7,8,9]]
05:43:58 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
05:44:09 <ski> sohum : ^ that's another view of that
05:44:12 <ivan_m> mm_freak: so what exactly is your proposed solution?
05:44:33 <ski> > transpose [[0,1,2,3],[4,5,6],[7,8],[9],[]]
05:44:34 <lambdabot>   [[0,4,7,9],[1,5,8],[2,6],[3]]
05:44:35 <ivan_m> IIRC, I got better performance for code that did a lot of transposition using something like what ski said rather than transpose
05:44:37 <mm_freak> example: data Graph a = Graph a [Graph a]
05:44:40 <ski> > (getZipList . Data.Traversable.sequenceA . map ZipList) [[0,1,2,3],[4,5,6],[7,8],[9],[]]
05:44:42 <lambdabot>   []
05:45:01 <ski> sohum : but on ragged tables, they behave differently
05:45:26 <ivan_m> mm_freak: oh, yeah, I can't really use that I don't think...
05:45:39 <ivan_m> the actual values I have are closer to [(a,a)]
05:45:44 <sohum> ski: okay, I'm not quite sure what ziplists or sequenceA are/is
05:45:45 <ivan_m> I then convert that to Map a [a]
05:46:09 <ski> sohum : `ZipList' is like lists where `liftA2' is `zipWith'
05:46:11 <ivan_m> sohum: ZipLists are a newtype on lists that have the Monad interface be zip-based rather than concatMap based
05:46:21 <ivan_m> IIRC it's covered in RWH
05:46:23 <ski> sohum : instead of taking every combination, you zip
05:46:29 <sohum> ivan_m: right, that makes sense
05:46:44 <sohum> I should really finish RWH one of these days..
05:46:50 <ivan_m> heh
05:46:58 <Botje> my boss got a LYAH book and I didn't :(
05:47:01 <ski> > [[a,b] | a <- "Aa" , b <- "Bb"]
05:47:01 <lambdabot>   ["AB","Ab","aB","ab"]
05:47:03 <Botje> I've been waiting for over a month now
05:47:04 <ski> > [[a,b] | a <- "Aa" | b <- "Bb"]
05:47:04 <lambdabot>   ["AB","ab"]
05:47:25 <ski> > liftM2 (\a b -> [a,b]) "Aa" "Bb"
05:47:25 <lambdabot>   ["AB","Ab","aB","ab"]
05:47:44 <ski> > getZipList (liftA2 (\a b -> [a,b]) (ZipList "Aa") (ZipList "Bb"))
05:47:45 <lambdabot>   ["AB","ab"]
05:48:04 <ivan_m> Botje: I got one within a few weeks after it came out, after pre-ordering after BONUS advertised the deal via the publisher
05:48:04 <ski> sohum : compare those ^
05:49:05 <ski> (`ZipList's form an `Applicative' functor, but not a monad .. if you only consider infinite-sized (or `n'-sized, for a fixed `n') lists, then it becomes a monad as well)
05:49:06 <sohum> ski: *nod*
05:49:34 <sohum> ski: I do like that the zip-based solutions preserve streaming - transposeViaZip xs !! n only calculates as much as it needs to
05:49:45 <ivan_m> mm_freak: if you have a graph that's just the equivalent to [(a,b), (b,c)], would your representation be "Graph a [Graph b [Graph c []]]" or [Graph a [Graph b [Graph c []]], Graph b [Graph c []], Graph c []]" ?
05:50:14 <Botje> I got a message from no starch press a month ago that my books had shipped
05:50:18 <Botje> since then .. nothing :/
05:50:23 <ivan_m> Botje: :s
05:50:44 <Botje> but we've had lost packages in the past
05:50:50 <Botje> I'll ask around
05:50:53 <ski> ivan_m : i suppose it would be nicer to only have as roots nodes with no parents .. but then if there is no such in a component, one needs to select some other node anyway ..
05:51:11 <ivan_m> ski: yeah
05:51:13 <ski> (s/component/connected component/)
05:52:06 <ivan_m> I just wasn't sure if mm_freak meant to have each node listed at the top-level as well, or just whenever it gets listed
05:52:25 <ivan_m> I _think_ mm_freak means the latter
05:52:54 <ski> sohum : hm, i'll have to think about that on streaming. (anyway, i think a common term for "preserves streaming" is "is incremental / isn't batchy")
05:53:06 <ivan_m> but if we have something like "Graph a [Graph b [Graph a []]]", how would reachable work (in that b should be reachable from b) ?
05:53:32 <ivan_m> preflex: seen Cale
05:53:32 <preflex>  Cale was last seen on #haskell 1 day, 6 hours, 59 minutes and 48 seconds ago, saying: for example
05:53:53 <ivan_m> oh, in case people didn't realise: playing with planar graphs get very messy very quickly :s
05:54:08 <sohum> ski: oooh, that's a good word. "incremental". "incremeeental". "incremeeeental."
05:54:10 <ivan_m> (since where the edge goes on the node becomes important)
05:54:10 <ski> ivan_m,mm_freak : hm, this is a nice idea for navigating in a graph with cycles
05:54:52 <ski> sohum : e.g. `reverse' isn't incremental (it's a batch operation, you get nothing or you get everything), while `(++)' is
05:54:54 <ivan_m> ski: well, I'm not so sure I understand how to use cycles in this kind of representation...
05:55:40 <sohum> ski: *nod* I recently had to deal with some poor performance where something I assumed was incremental wasn't
05:55:41 <ski> ivan_m : while you traverse down a part, carry with you the other parts you're passing by (a zipper)
05:56:13 <ivan_m> ski: hmmmm..... so you don't actually represent it in the data structure, just make functions on it smarter?
05:57:02 <ski> ivan_m : i was thinking on representing this in a zipper .. maybe the "main" datastructure as well (which possibly could *be* any such zipper ?)
05:57:19 <ivan_m> hmmmm.....
05:57:21 <ski> hm, there'll need to be some way of handling disconnected components, though
05:57:23 <ivan_m> could work
05:57:46 <ski> s/down a part/down a path/
05:57:46 <ivan_m> ski: under the hood you have [Graph a]
05:57:57 <ski> s/Graph/ConnectedGraph/
05:58:00 <ivan_m> or a list of zippers
05:58:02 <ivan_m> yeah
05:58:13 <ivan_m> so you deal with each component in turn
05:58:14 <ski> sohum : *nod*
05:58:24 <ivan_m> ski: dealing with directed graphs would be interesting though...
05:58:28 <mm_freak> ivan_m: the representation of that would be infinite
05:58:29 <ski> ivan_m : yeah .. it depends on what you want to do
05:58:46 <ski> some operations potentially want to view the whole graph, in a single large operations
05:58:48 <mm_freak> Graph a [Graph b [Graph a [Graph b [â€¦
05:58:59 <ski> other times you might want to traverse incrementally, based on user-input
05:59:02 <ivan_m> mm_freak: ahhhhh
05:59:17 <ivan_m> OK, that probably won't work for my purposes
06:00:00 <ski> ivan_m : huh, i thought this was for directed graphs ..
06:00:24 <ivan_m> ski: if you use a zipper, then presumably Graph a [a] then refers to a directed edge
06:00:25 * ski usually thinks undirected graphs are harder
06:00:32 <ivan_m> so what happens when you put a zipper on it?
06:00:36 <ivan_m> oh, duh, forget that
06:00:43 * ski doesn't understand
06:00:56 <ivan_m> yeah, I was thinking about zippers wrong
06:01:22 <ski> by zipper i here only mean that when you walk down the graph, you keep the parts you're passing down
06:01:39 <ivan_m> ski: so how would you represent something like [(a,c), (b,c)], with the Zipper focused on the c ?
06:01:42 <ski> so that when you pass from `a' to `b' to `a', you'll automagically insert `b' under that `a' again
06:01:56 <ivan_m> or even the focus on the a
06:02:17 <ivan_m> [Graph a [Graph b []], Graph c [Graph b []]] ?
06:02:28 <ivan_m> ummm.... swap around b and c above
06:02:29 <ski> well, a subgraph with root `c', together with two "extra parts" referring to `c'
06:02:50 <ski> the problem would be to know which other parts reference `c' (and where)
06:03:15 <ski> maybe one could cache all the nodes references in a subgraph, together with paths to them
06:03:43 <ski> hm .. maybe i'm here assuming a node identity
06:03:45 <Baughn> ivan_m: You rang?
06:03:53 <ivan_m> *sigh* I just might go with re-calculating the reachable components for each node
06:04:37 <ivan_m> Baughn: with haskell-mode for emacs, I have the situation that when I :quit from ghci and then try to load the file again (usually when I updated a dep so need to re-launch ghci), it seems to do a "cd .." and thus can't find the module :s
06:04:51 <ski> ivan_m : well, it'd be nice to do that in some adaptive way, then (as in "adaptive/incremental computation" .. ther's a paper by Acar and Blelloch, and an adaptation to Haskell by Magnus Carlsson, iirc)
06:04:54 <ivan_m> so I have to do ":cd foo" in ghci before loading again
06:05:06 <ivan_m> ooohhh.....
06:05:36 <ivan_m> ski: "Monads for Incremental Computing" ?
06:05:52 * ski has no idea how easy it would be to use adaptive/incremental computation here .. the idea just popped into head
06:05:55 <ski> yes
06:06:05 <ski> but also see the original paper (using SML)
06:07:08 <ivan_m> *nod*
06:07:26 <ski> (to clarify, the adaptive computation would be for recomputing, in this case, the reachable components for each node, while reusing as much as possibly of the work from the last time this was done)
06:09:14 <ski> (the adaptive computation sets up a network (maybe remniscent of RETE ?) such that if you "update" an incoming node, that will trigger recomputation in descendent nodes (unless the same value as last time was recomputed, in which case the ripple ends at that point))
06:10:27 <ClaudiusMaximus> interesting graph discussion - my lambda calculus interpreter has a bug in its graph reducer where it checks to see if a node can be reduced as many times as there are paths to it => O(2^N) slowness...
06:11:32 <ski> ClaudiusMaximus : you should use references or `IVar's or something like that, to share the computation
06:11:37 <ivan_m> ski: yeah, that's how I interpreted it
06:12:01 <ski> (where references can be as simple as `Int's pointing into a list/array, or can be `STRef s's/`IORef's or similar)
06:12:19 <ski> (cf. `IVar's and `MVar's)
06:13:09 <ski> anyway, this is an interesting topic -- but i'll have to leave for the moment :/
06:14:53 <joe6> i get this warning, just curious if there is anything I can do to avoid it: http://pastebin.com/nTYkpdYd
06:15:06 <joe6> other than not having to use contains, ofcourse.
06:16:47 <hpc> joe6: you could bribe the maintainer into undeprecating 'contains'
06:16:51 <hpc> but... that's about it
06:18:12 <joe6> and I am already on ghc-pkg list | grep -i missing     MissingH-1.1.0.3
06:18:34 <joe6> will see if I can send a patch.
06:22:07 * hackagebot data-clist 0.0.6 - Simple functional ring type.  http://hackage.haskell.org/package/data-clist-0.0.6 (JohnVanEnk)
06:24:05 <ClaudiusMaximus> ski: i do use references (Map Integer Term, data Term = ... | Reference Integer  or similar), but i don't (yet) keep track of whether i've followed a reference already or not - so yes, I'm thinking of rewriting the one-step-reducer with STRefs or something like it
06:26:20 <spirit> module Amodule where ... is by default everything that's in Amodule exported?
06:26:27 <joe6> hpc, fyi, the contains has been replaced with isInfixOf
06:27:10 <ClaudiusMaximus> spirit: yes, you can control it by module Amodule (aThing) where
06:28:54 <spirit> if i import Amodule and Amodule imports Bmodule, can i then use stuff from Bmodule in Main? is importing transitive?
06:29:58 <ivan_m> spirit: no
06:30:09 <ivan_m> you have to explicitly re-export Bmodule from Amodule for that
06:30:10 <ClaudiusMaximus> spirit: no, but you can re-export imported modules
06:30:22 <ivan_m> which requires you to have an explicit export list for Amodule
06:30:50 <Twey> module Amodule (module Bmodule) where import Bmodule
06:31:12 <Twey> And â€˜moduleâ€™ now looks like a non-word
06:31:30 <mm_freak> ivan_m: why wouldn't it work?  it's just a more intrinsic representation of a graph
06:31:33 <dafis> spirit:  however, instances imported from Bmodule are automatically reexported from Amodule
06:31:34 <ClaudiusMaximus> but, you can do this (i think, perhaps):  module Amodule (module Amodule, module Bmodule) where import Bmodule ; aThing = 33333
06:32:00 <Twey> module Amodule (module Amodule) seems like it might break the Internet
06:32:39 <dafis> Twey:  the Internet has survived a couple of those
06:33:06 <Twey> Thank goodness for that decentralised architecture
06:33:17 <ivan_m> mm_freak: for my code, it's too complicated ;-)
06:33:42 <mm_freak> ivan_m: i think it's simpler actually
06:34:33 <ivan_m> mm_freak: to create my Map a [a], I think it would be too difficult to make it Graph a [Graph a] instead
06:35:37 <mm_freak> ivan_m: it's less error-prone and more straightforward
06:36:33 <mm_freak> ivan_m: it relates to your map solution as haskell lists relate to C loops
06:36:52 <mm_freak> you just need a different thought process when using it
06:37:08 <ivan_m> well, I'm going from something isomorphic to [(a,a,b)] to (Map a [a], [(a,a,b)]), where the returned list removes parallel edges (keeping earlier edges)
06:37:24 <ivan_m> mm_freak: it's the _creation_ that I can't work out how to do
06:38:22 <mm_freak> it's not a discrete data structure in memory, so you would construct it with rules, just like you would construct lists using foldr/iterate/â€¦
06:39:12 <djahandarie> Wouldn't you need a final coalgebra to anamorphically build the graph?
06:39:57 <spirit> module Amodule (Bmodule) where import Bmodule doesn't seem to work. would it be bad practice to just import Bmodule and Amodule from Main? leave out the export?
06:41:31 <ivan_m> look, all I'm trying to do is remove transitive edges from a DotGraph! ;-)
06:41:46 <djahandarie> I imagine you could build a spanning of a graph anamorphically but I don't know about the graph itself
06:42:00 <djahandarie> Oh. I don't really know what you're doing. :p
06:42:41 <ivan_m> man tred
06:42:42 <ivan_m> :p
06:42:52 * ivan_m figures he should probably hit the sack about now
06:42:55 <ivan_m> g'night all
06:43:15 <djahandarie> Night ivan_m!
06:43:48 <ClaudiusMaximus> spirit: you need the module keyword in the export list like "module A (module B) where import B"
06:44:10 <ClaudiusMaximus> spirit: otherwise "module A (B)" looks for a type or class called B
06:45:40 <ClaudiusMaximus> spirit: personally i mostly don't re-export modules, but for large libraries like OpenGL or GTK it would be a nightmare if there wasn't a couple of modules that re-export the 100s of other modules
06:46:00 <spirit> cheers! and i actually also need to specify i want the module itself exported? :-D
06:46:37 <dafis> spirit:  you can specify that as module Amodule (module Amodule, module Bmodule) where
06:46:56 <dafis> if you want to export every top-level definition from Amodule
06:47:20 <dafis> if you want to export only some, you need to list them explicitly
06:49:25 <spirit> brilliant stuff :-)
07:03:51 <jaspervdj> preflex: seen edwardk
07:03:51 <preflex>  edwardk was last seen on #haskell 14 hours, 39 minutes and 5 seconds ago, saying: er woops, window was scrolled, question was an hour and a half ago =)
07:04:05 <xplat> what does import {-# source #-} foo mean?
07:04:23 <jaspervdj> xplat: It's a hack so you can have mutually importing modules
07:04:39 <jaspervdj> xplat: e.g. module A can import B and vice versa. It's usually not recommended
07:04:43 <copumpkin> jaspervdj: you need him? I'll be seeing him in a little while
07:04:54 <xplat> oh, an alternative to .hs-boot?
07:05:39 <jaspervdj> copumpkin: (if he hasn't forgotten,) I should meet him on skype in half an hour, he's my gsoc mentor
07:05:54 <copumpkin> ah okay
07:06:27 <jaspervdj> xplat: Yeah, there might be other uses for it that I don't know
07:06:31 <xplat> jaspervdj: what are you working on for gsoc?
07:06:34 <copumpkin> I'll remind him if I see him
07:06:47 <jaspervdj> xplat: http://jaspervdj.be/files/text.html
07:08:37 <xplat> jaspervdj: excellent, i've often wanted that
07:09:10 <xplat> well-written proposal too
07:09:22 <jaspervdj> thanks
07:20:29 <cheater__> hey guys
07:20:37 <cheater__> has anyone received their preview copy of LYAH yet?
07:20:44 <Lemmih> cheater__: Yep.
07:20:51 <cheater__> hmmm
07:21:00 <cheater__> how long ago was that?
07:21:13 <Lemmih> cheater__: A week or two.
07:21:19 <cheater__> which country are you in?
07:21:56 <cheater__> it's ok, you can tell us :)
07:22:15 <Lemmih> I'm in Denmark.
07:23:25 <Perlkonig> Question: I have a function that returns a "Maybe [(Int, Int)]". Whenever I try to access the list, though, I get type mismatch errors. How do I access the list inside the Maybe?
07:23:46 <mauke> pattern matching
07:24:03 <Perlkonig> Could you elaborate?
07:24:15 <Perlkonig> If I wanted to map over the list, for example, what would I do?
07:24:20 <byorgey> suppose  f :: Maybe [(Int, Int)]
07:24:38 <xplat> or use fromMaybe
07:24:39 <byorgey> then you could say  case f of  Nothing -> ...    Just l ->  do something with the list l
07:24:53 <kstt> Perlkonig: you probably want to map over it, through fmap.
07:24:58 <cheater__> Lemmih: hmm, i'm in germany
07:25:01 <xplat> or, yeah, fmap
07:25:02 <kstt> Maybe is a functor
07:25:05 <byorgey> Perlkonig: the point is that something of type  Maybe [(Int,Int)] may not contain a list.  It might just be Nothing.
07:25:14 <Lemmih> cheater__: You should have gotten it by now, then.
07:25:31 <cheater__> Lemmih: what company did you have them delivered by?
07:25:33 <byorgey> but yes, you can also use   fmap (map blah)
07:25:49 <byorgey> > fmap (map ((+2) . fst)) Nothing
07:25:51 <lambdabot>   Nothing
07:26:00 <byorgey> > fmap (map ((+2) . fst)) (Just [(1,2), (3,4)])
07:26:01 <xplat> or you could use 'maybe' which combines both
07:26:01 <lambdabot>   Just [3,5]
07:26:08 <Lemmih> cheater__: It came in a USPS box. Not sure which company delivered it.
07:26:19 <kstt> Perlkonig: I highly recommand reading byorgey's typeclassopedia. A great article, both easy to read and full of useful information.
07:26:32 <Perlkonig> I will do more reading on fmap and fromMaybe and will go to pattern matching if that's what is best. Thank you for your help. I'm still getting my head around all this.
07:26:39 <byorgey> thanks kstt =)
07:27:09 <cheater__> Lemmih: ok. then i will have to go to the post office and investigate.
07:27:20 <kstt> Perlkonig: make yourself a favor, a start from the typeclassopedia
07:27:35 <Perlkonig> kstt: Thanks. What is the definitive link? Google gives lots of noise.
07:28:04 <kstt> The Monad Reader, issue 13 if my memory deserves
07:28:43 <Perlkonig> got it. Thanks again for your help.
07:28:50 <kstt> isn't there a bot here ? Could we teach it the link to Typeclassopedia ?
07:29:02 <xplat> @where typeclassopedia
07:29:02 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:29:33 <kstt> great :)
07:31:49 <Perlkonig> Wow, pathfinding in TeX...now I've seen everything.
07:33:16 <djanatyn> My code is awesome.
07:33:20 <djahandarie> edwardk, jaspervdj poked you a moment ago to remind you to have a meeting with him. In case you haven't already been told by copumpkin
07:33:24 <djanatyn> "htd -l" prints the entire contents, organized by number.
07:33:30 <djanatyn> "htd -l [number]" prints that number task from the file.
07:33:35 <djanatyn> "htd -a 'task'" adds a new task with the next number.
07:33:41 <djanatyn> Now it organizes your to-do file before outputting.
07:33:44 <djanatyn> :D
07:33:58 <djanatyn> Haskell is so cool.
07:34:34 <djanatyn> I'm using Data.List and lines to organize the contents of the file - just with simple lists.
07:35:00 <dafis> djanatyn:  really cood would be "htd -d" doing the things for you
07:35:10 <djanatyn> djahandarie: hmm
07:35:26 <dafis> cool*
07:35:42 <djanatyn> Maybe in C...
07:35:50 <djahandarie> All these damn 'd's...
07:35:59 <djanatyn> We'd need more functionality :)
07:36:29 <djanatyn> djahandarie: all this cool haskell code written by d*
07:36:42 <xplat> @nick djaxplat
07:36:42 <lambdabot> Maybe you meant: dice dict
07:36:52 <xplat> er
07:37:00 <xplat> well, no point actually doing it now :)
07:37:54 <djahandarie> djanatyn, what's the cause for the 'dja' at the start of your name?
07:38:05 <djanatyn> djahandarie: lojban
07:38:11 <Jafet> To annoy you
07:38:49 <djanatyn> It's a logical, constructed language based on logic and eliminating ambiguity.
07:39:52 <djahandarie> djanatyn, your nick says something in Lojban?
07:40:31 <Ke> still the creators of lojban failed in creation of simple phonemic writing
07:40:33 <Ke> =oP
07:40:41 <Ke> not worth learning
07:40:48 <xplat> i remember when lojban was called loglan
07:41:33 <dafis> Ke:  as far as I looked, all artificial languages (meant for communication between humans) suck BIG time
07:41:53 <dafis> but that's just *my* opinion of course
07:42:01 <_linuxftw> I'm getting this error, http://codepad.org/WZCt29BF , why?
07:42:31 <scree> esperanto isn't that bad, but that's arguably because it's a rip-off of a load of european languages rather than a brand new one
07:42:36 <osfameron> bah. the Monad Reader isn't published in an ebook format :-(
07:42:41 <osfameron> are the sources available?
07:42:43 <dafis> _linuxftw:  that depends on the code where it appears
07:43:06 <_linuxftw> this is the line "neighborsAndEdges = filter (\(e1,e2,p,q) -> p>0 && q>0 && p<10 && q<10) [(1,3,x+1,y), (3,1, x-1,y), (2,0,x,y+1), (0,2,x,y-1)]"
07:43:41 <Guest70300> hello?
07:43:46 <dafis> _linuxftw:  and where do x and y come from?
07:43:57 <_linuxftw> (x,y) :: (Int,Int)
07:43:58 <dafis> hello Guest70300
07:44:11 <Peaker> dafis: in what sense do they suck?
07:44:32 <scree> _linuxftw: could you paste their definitions? that's almost certainly where the problem is
07:44:50 <scree> _linuxftw: it seems as though they're not (Int, Int)
07:44:56 <shapr> dafis: xu do tavla mi bau la lojban
07:45:11 <shapr> djahandarie: mi'e capr
07:45:15 <shapr> whoops, wrong nick
07:45:17 * shapr shrugs
07:45:37 <_linuxftw> Here's the whole function, http://codepad.org/gfEpk5mr
07:47:12 <shapr> Are there any tools to automate FFI wrappers?
07:47:32 <_linuxftw> scree, as you can see they're declared as (Int,Int)
07:47:44 <xplat> [from Wikipedia] The Lojban IRC (or its archive) has a gathering of Lojbanic expressions too, but its grammatical correctness is not always guaranteed.
07:47:47 <byorgey> shapr: I'm pretty sure there are, although I know nothing about them
07:47:49 <shapr> For example, I'm looking at hackage://pulse-simple that uses /usr/include/pulse/simple.h, and I'd like to extend it handle /usr/include/pulse/volume.h
07:47:52 <byorgey> how's that for a helpful response?
07:48:07 <shapr> byorgey: Well, it's something :-) At least I know such tools probably exist.
07:48:10 * shapr checks the wiki
07:48:23 <Jafet> byorgey: typical mathematician's answer
07:48:24 <shapr> hoi RayNbow!
07:48:28 <xplat> shapr: there are a bunch of autowrapping tools, for various values of 'auto'
07:48:36 <shapr> xplat: Like what?
07:48:54 <byorgey> Jafet: =)
07:49:00 <kstt> byorgey: do you plan to update the typeclassopedia at some point ? Some things have probably changed in two years of haskell history.
07:49:17 <xplat> but probably the quickest way to get a library bound is to convince ManateeLazyCat that that library would be helpful for a manatee module :)
07:49:18 <byorgey> kstt: yes, I'm currently working on a second edition
07:49:44 <shapr> xplat: haha
07:49:58 <scree> _linuxftw: ah, ok the problem is in filterBuild i think
07:49:58 <djahandarie> byorgey, has edwardk tricked you into making it just documentation for all his libraries yet?
07:49:59 <mauke> _linuxftw: you have the opposite problem
07:50:03 <dafis> Peaker: using latin letters for phonemes entirely different from those they're used for in roman or germanic languages, for example; throwing together parts of different languages, so that you never know where you can draw on languages you know a bit and where not; claiming they're easy to learn [none I looked at was even remotely easy to learn; but then I'm not a good learner of languages at all, east-asian languages shut me out co
07:50:03 <dafis> mpletely]
07:50:13 <byorgey> djahandarie: not quite yet =)
07:50:16 <mauke> _linuxftw: ghc thinks x is an Int, but it wants a function for some reason
07:50:27 <_linuxftw> it's treating - as a function then?
07:50:33 <mauke> _linuxftw: - is a function
07:50:41 <mauke> how is this related to anything
07:50:52 <scree> _linuxftw: filterBuild has a filter applied to only one argument.  so it's a function expecting another list
07:50:55 <Peaker> dafis: All sound like they may have reasonable justifications
07:50:56 <byorgey> djahandarie: we had discussed writing a followup article to the Typeclassopedia explaining a bunch of his categoryish libraries though
07:51:10 <_linuxftw> ah
07:51:58 <mauke> _linuxftw: btw, don't use isJust
07:52:06 <_linuxftw> why?
07:52:29 <mauke> because 99.9% of its uses are bad
07:52:29 <xplat> http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
07:52:34 <mauke> like this code
07:52:42 <xplat> shapr: ^
07:53:00 <_linuxftw> I don't know any other way to do what I want
07:53:20 <_linuxftw> Can you suggest another way?
07:53:22 <mauke> _linuxftw: pattern matching
07:53:30 <scree> _linuxftw: on second thoughts what I said might be premature; I'm not 100% sure what your code is doing
07:53:49 <shapr> xplat: aha, handy!
07:54:03 <zygoloid> _linuxftw: what is the type of edgeSelector and cellAt?
07:54:21 <xplat> lojban definitely seems to be in the 'throwing together parts of different languages' bin, along with english
07:54:28 <Hey> list
07:54:33 <Hey> ls
07:54:57 <dafis> xplat:  english didn't throw, it absorbed
07:55:34 <_linuxftw> edgeSelector :: Int -> ((a,a,a,a) -> a), cellAt :: [[a]] -> (Int,Int) -> a
07:55:56 <earthy> dafis: got thrown about a bit, right. ;)
07:56:02 <xplat> dafis: you couldn't tell the difference if you weren't there, though :)
07:56:33 <copumpkin> omg 4-tuples
07:56:36 <zygoloid> _linuxftw: ok, what's BorderLineState?
07:56:52 <dafis> xplat:  being not entirely unfamiliar with Platt, I can tell the difference in that case
07:57:27 <_linuxftw> zygoloid: BorderLineState :: [[(Bool,Bool,Bool,Bool)]]
07:57:46 <Axman6> _linuxftw: what's this homework about?
07:57:56 <xplat> there are still systematic difference of flavor between latinate (medieval french), modern french, scientific latin, and spanish borrowings, and that's just in the romance-languages area
07:58:01 <_linuxftw> Axman6, it's not homework, I'm doing it for fun. Is there something wrong with that?
07:58:30 <Axman6> _linuxftw: no, i was just curious. seems a hell of a lot like the assignment my students had to hand in several hours ago :P
07:59:25 <xplat> not to mention the old saxon roots, scientific greek, and the long tail of idiosyncratic borrowings that most languages have
07:59:32 <_linuxftw> Lucky I'm not one of your students then, otherwise I'd have missed the deadline :)
07:59:44 <zygoloid> _linuxftw: is edgeSelector supposed to produce Maybe something?
08:00:02 <_linuxftw> er, it can do
08:00:23 <_linuxftw> It can be used with (Maybe Bool, Maybe Bool, Maybe Bool, Maybe Bool) or with (Bool,Bool,Bool,Bool)
08:02:04 <xplat> so although i guess english does show definite signs of the historical nature of its borrowing, it does still give a pretty 'thrown-together' feel
08:02:54 <dafis> xplat:  the bulk of its structure and the majority of its vocabular are still lower german
08:03:56 <ski> ClaudiusMaximus : btw .. just using `Reference Integer' would also give you caching of thunks (assuming you don't remove references willy-nilly when you encounter them)
08:03:56 <xplat> majority of vocabulary by weighted frequency average, sure, completely different if you threshold somewhere in the 10,000s and count words though
08:03:59 <ski> mm_freak : what is `Graph a [Graph]' supposed to be ?, it looks ill-kinded
08:04:26 <ski> mm_freak : "it's not a discrete data structure in memory" -- huh ?
08:04:55 <scree> _linuxftw: what's PartialBLS?
08:05:00 <ClaudiusMaximus> ski: right, it does - but when traversing the graph to find reducible thunks, i re-enter references multiple times...
08:05:03 <blueonyx> what can i do when the CouchDB lib (which uses Network.HTTP) throws this error: *** Exception: user error (internal error: server error: GET http://foo.bar
08:05:14 <_linuxftw> scree, (Maybe Bool, Maybe Bool, Maybe Bool, Maybe Bool)
08:05:20 <xplat> bacon, lettuce, and sandwich sandwich
08:05:23 <tg_> hm. The random number generation part of the LYAH tutorial *really* made me realize how powerful pure functions are...
08:05:40 <tg_> realizing that the tutorial was producing "random" functions but those which produced the exact same results as my computer did :o
08:05:44 <xplat> it's an attempt to make a BLT into a monad
08:06:41 <tg_> plus, it gives me the impression that other languages are just fooling you
08:06:58 <ski> '11
08:07:08 <scree> _linuxftw: so, that code now compiles on my machine, which is bizarre
08:07:34 <mm_freak> ski: Graph a [Graph a]
08:08:00 <scree> _linuxftw: are those type signatures for cellAt and edgeSelector type signatures written into your code, or are they aspirational type signatures?
08:08:06 <mm_freak> it's a node together with its neighbours, to which it points
08:08:14 <_linuxftw> written in the code
08:08:23 <_linuxftw> at least, they are now
08:08:53 <scree> _linuxftw: hmm.  would it just be possible to paste the whole code?
08:09:13 <_linuxftw> I've made some other modifications, once I've fixed the errors in them I'll paste it for you
08:09:21 <_linuxftw> (assuming my original error doesn't vanish)
08:11:29 <xplat> gah, gnu emacs source distribution is 45 megs?!
08:11:44 <xplat> gzipped!
08:11:57 <xplat> that's a lot of sources
08:12:19 <dafis> xplat:  a semicolon takes four bytes in their compression
08:12:47 <ski> ClaudiusMaximus : yeah, each time you rewrite a term inside a reference, update the global map/list/array/memory at that reference, so that other access to it through other occurances of the reference can share the fruits of the labour
08:12:51 <Jafet> > du -hs gcc-trunk
08:12:52 <Jafet> 1.3G	gcc-trunk
08:12:52 <lambdabot>   Not in scope: `du'Not in scope: `hs'Not in scope: `gcc'Not in scope: `trunk'
08:13:53 <xplat> i would have thought )))))))))))))))))))))) would compress well with gzip ...
08:13:55 <ski> mm_freak : surely `[] :: * -> *' so from `[Graph a] :: *' follows `Graph a :: *', so how can `Graph a' be applied to `[Graph a]' in `Graph a [Graph a]' ?
08:14:12 * ski must be missing something ..
08:14:22 <_linuxftw> scree: I've discovered that by changing it from x-1 to (-1)+x the error vanishes
08:14:55 * dafis wonders, how well would brainfuck compress with gzip?
08:14:57 <xplat> lol wut
08:15:08 <mauke> _linuxftw: if you change it back, does the error reappear?
08:15:23 <_linuxftw> It does
08:15:37 <dafis> ski:  value constructor vs. type constructor, I suspect
08:15:37 <mauke> _linuxftw: did you redefine - or something?
08:15:47 <_linuxftw> not that I know of
08:15:57 <ski> dafis : .. ohh
08:16:12 <_linuxftw> wait.... I did
08:16:21 * ski sometimes would like to ban naming data constructors the same as type constructors ..
08:16:38 <_linuxftw> This line appears above it: validCellStates -1 = concat $ map validCellStates [1,2,3]
08:16:44 <xplat> redefining - is considered harmful
08:16:56 <_linuxftw> I think by not putting -1 in brackets I was redefining it somehow
08:17:15 <xplat> yes, actually
08:17:18 <dafis> _linuxftw:  exactly
08:17:40 <xplat> that parses as (validCellStates) - (1) = ...
08:17:44 <_linuxftw> dafis: Ok, but I wouldn't have spotted that. How on earth does someFunction -1 = 5 manage to redefine -1?
08:17:49 <ski> > let f (x + (-1)) = x in f 2
08:17:50 <lambdabot>   <no location info>: Parse error in pattern
08:18:07 <ski> _linuxftw : it redefines `(-)', not `(-1)'
08:18:07 <dafis> _linuxftw:  parsing rules
08:18:08 <_linuxftw> > let f -1 = 5 in 3-1
08:18:09 <lambdabot>   5
08:18:22 <xplat> hlint should warn on that if it doesn't already
08:18:55 <_linuxftw> so you mean validCellStates -1 is treated as a special case (?) of the - function?
08:19:05 <mauke> _linuxftw: well, as the only case
08:19:16 <mauke> > let x - 1 = 5 in 0 - 0
08:19:18 <lambdabot>   *Exception: <interactive>:3:4-12: Non-exhaustive patterns in function -
08:19:38 <dafis> _linuxftw:  a-b = rhs is interpreted as defining the function (-) applied to the two arguments a and b
08:19:58 <dafis> _linuxftw:  that shadows Prelude.-
08:20:08 <xplat> foo - 1 would parse as subtraction in any other expression, and haskell doesn't parse differently based on whitespace
08:20:08 <_linuxftw> Right, it makes sense now, but I'd have never spotted that
08:20:33 <quicksilver> xplat: (except with .. ;)
08:20:52 <dafis> and .
08:21:13 <xplat> well, yeah, and xPrelude.- 1 parses differently than x Prelude.- 1, but you know what i mean
08:21:34 <xplat> *from x
08:22:17 <tg_> quicksilver: what property/feature causes a simple getStdGen main function (like in LYAH I/O) to print out the same string in GHCi upon execution (by typing main), but lets it change when I do :r then main?
08:22:44 <xplat> hm, emacs includes all the .el files as precompiled .elc also
08:22:59 <zygoloid> i vaguely recall a haskell' proposal to make "x -y" (where y is numeric, and there's a space before but not after the -) do the 'obvious' thing
08:23:08 <shapr> xplat: yah?
08:23:17 <quicksilver> tg_: well, when you run in ghci you're running with a persistent copy of the standard library
08:23:25 <quicksilver> tg_: so the RNG state sticks around
08:23:26 <mauke> zygoloid: I'd support that if unary - is removed
08:23:31 <quicksilver> if it's RNG state you're talking about.
08:23:47 <tg_> quicksilver: tis. that make sense. :r reloads the same library, but with a different RNG.
08:23:50 <tg_> ok
08:23:52 <_linuxftw> Here's the fixed function: http://codepad.org/YgKCCwh1 , mauke: Is this code better now without the fromJust/isJust?
08:24:15 <quicksilver> well :r is reloading your module
08:24:21 <quicksilver> it's not affecting the standard library.
08:24:23 <mauke> _linuxftw: looks more complicated :-/
08:24:27 <_linuxftw> It is
08:24:28 <xplat> mauke: troublemaker.  those proposals don't even make sense together!  :P
08:24:40 <shapr> xplat: Speaking of which, have you seen rainbow-delimiters.el ?
08:25:11 <xplat> shapr: no.  is it what it sounds like?
08:25:18 <Botje> _linuxftw: you could use Data.Ix.inRange ((1,1),(9,9)) as your filter function on line 9
08:25:30 <ski> _linuxftw : .. i would use `$' much less
08:25:46 <_linuxftw> ski: What's wrong with $, Botje: Thanks, i'll do that now
08:25:52 <shapr> xplat: If it sounds like each nested level of parens/braces/etc gets a different color, then yes!
08:26:30 <ski> _linuxftw : lots of `f $ g $ h $ ...' is ugly (`f . g . h $ ...' is better)
08:26:34 <scree> _linuxftw: "maybe" instead of that pattern match?
08:26:50 <ski> _linuxftw : `val == (edgeSelector e1 $ possibleState)' is ugly, `val == edgeSelector e1 possibleState' is better
08:26:53 <mauke> _linuxftw: filterBuild (e1,e2,p,1) = case edgeOfNeighbor of Nothing -> id; Just en -> filter (\ps -> en == edgeSelector e1 ps)
08:27:28 <Botje> _linuxftw: you can also move filterBuild to the same level as allFilters, as it doesn't use anything from allFilters
08:27:29 * hackagebot diagrams-core 0.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.1 (BrentYorgey)
08:27:37 <_linuxftw> These are all good suggestions, thank you
08:28:04 <ski>   filterBuild (e1,e2,p,1) = maybe id (\en -> filter (\ps -> en == edgeSelector e1 ps)) edgeOfNeighbor
08:28:14 <kakos> Is there something for haskell like javadocs?
08:28:17 <ClaudiusMaximus> ski: right, that's what i do - it's only the search for reducible subexpressions that is currently problematic... it needs a rewrite with an STRef at each Reference or a Set Integer being threaded through everything, the latter is probably easier with State (Set Integer)
08:28:23 <ski> dunno is that is better than the explicit `case' mauke suggested
08:28:31 * hackagebot diagrams-lib 0.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.1 (BrentYorgey)
08:28:33 <siracusa> kakos: haddock
08:28:33 <geheimdienst> kakos: yeah, it's called haddock
08:28:33 * hackagebot diagrams-cairo 0.1 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.1 (BrentYorgey)
08:28:44 <kakos> <3
08:28:45 <xplat> unpacked, emacs is 97M lisp, 15M C source, 14M precompiled info, 14M other docs, 2M images ...
08:28:53 <scree> _linuxftw: also, foo a = \b -> blah is unusual, foo a = \b -> blah b even more so
08:29:10 <Botje> 97 megabytes of lisp? what the hell..
08:29:22 <ski> _linuxftw,scree : sometimes that is nice, though (the former)
08:29:31 <shapr> Botje: Emacs does everything.
08:30:03 <Jafet> Botje: not your grandpa's Symbolics.
08:30:21 <dafis> shapr:  if you ask the vimmies, except providing a good editor
08:30:28 <geheimdienst> kakos: the haddocks for each package is on hackage. here's the base package, for example: http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/index.html on the right-hand side, there's links to the source code. you can search with hayoo or hoogle
08:30:30 <geheimdienst> @where hayoo
08:30:31 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:30:32 <Jafet> dafis: M-x term vim
08:30:41 <shapr> dafis: Yah, I've heard that, but I like emacs.
08:31:02 <shapr> dafis: I actually switched to emacs from vim after researching a comparison blog post.
08:31:07 <dafis> shapr:  yeah, I don't think even the vimmies continue to really believe that
08:31:13 <xplat> if .elc is excluded, lisp is only 60M
08:31:19 <scree> ski,_linuxftw : I agree in a sense, but even when it's clear in my mind what distinction I'm making between f a = \b -> ... and f a b = ..., it's not necessarily clear to anyone else
08:31:49 <Perlkonig> Another type question: Obviously it is taking me some time to get my head around the type system. I have some code that is trying to sum the values of nodes in a tree. The adder is complaining that it's not getting the type it really should be getting. I would appreciate any assistance. http://hpaste.org/46760/
08:31:50 <_linuxftw> I was trying to make it explicit that the function built another function
08:32:00 <kakos> What's the old joke?  Emacs is a great operating system, lacking only a decent editor?
08:32:44 <zygoloid> kakos: viper mode isn't so bad :)
08:33:03 <xplat> only 10M of lisp is neither .el nor .elc, which means 50M of *.el source!
08:33:05 * kakos is actually a devout follower of the Church of Emacs
08:33:39 <dafis> Perlkonig:  don't use Ratio Int unless you're 176% sure it won't overflow
08:33:56 <sipa> can you be a follower of the church of emacs while using ehm... a different editor?
08:34:06 <scree> Perlkonig: i think your problem is that foldr takes (a -> b -> b)
08:34:28 <kakos> Vim lacks the ability to easily have Zippy talk to a psychiatrist "AI" ad nauseum
08:34:40 <scree> Perlkonig: you're doing (b -> a -> b)
08:34:47 <Perlkonig> dafis: Thanks. I'm using ratio here for a quick inversion for the purposes of pathfinding.
08:34:54 <dafis> Perlkonig:  I think you got the argument order wrong (or use foldl['] instead of foldr)
08:35:11 <Perlkonig> scree: Thanks, taking a look
08:36:46 <Perlkonig> scree: Oh, I see what you're saying. My lambda is not type cast as expected.
08:37:47 <Perlkonig> My brain is burning
08:37:50 <xplat> i was thinking that most of the source distribution would be full of pictures for the X interface or something, but no, it's mostly code.  mind = blown.
08:38:46 <ski> scree : imo, it's just a matter of becoming more proficient / used to it
08:39:57 <Perlkonig> scree: So in this case, where my adder needs the extra parameter (mymap) how do I make that fit what fold expects? I thought I could just curry it in when I called it and everything would be OK.
08:40:08 <xplat> also, it contains a single 740K C source file
08:40:38 <xplat> normally this is kind of bad style, isn't it?
08:42:36 <ski> 640K ought to be enough for everyone ..
08:43:32 <_linuxftw> xplat: I bet it's auto generated
08:43:32 * hackagebot diagrams 0.2.2.3 - An EDSL for creating simple diagrams  http://hackage.haskell.org/package/diagrams-0.2.2.3 (BrentYorgey)
08:50:14 <byorgey> http://byorgey.wordpress.com/2011/05/17/announcing-diagrams-preview-release/
08:50:44 <xplat> it's heavily commented, which accounts for a lot of the size
08:51:15 <xplat> doesn't look autogenerated, more like someone going absolutely nuts with ctags and not realizing how big the file got
08:52:21 <Zao> byorgey: Aaw, no screenshots.
08:52:50 <byorgey> oh, dang, you're right
08:53:00 <byorgey> I knew I'd forget something
08:53:42 <byorgey> let me add a few quick before it gets picked up by Planet Haskell...
08:54:12 <xplat> also, there's a lot of glue code interfacing between xlib and elisp so it's pretty verbose
08:57:35 * hackagebot archiver 0.3.1 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.3.1 (GwernBranwen)
09:00:52 <byorgey> Zao: ok, examples added =)
09:01:50 <byorgey> shucks, planet haskell beat me
09:01:50 <quicksilver> byorgey: I see no exaples at http://byorgey.wordpress.com/2011/05/17/announcing-diagrams-preview-release/ ?
09:02:07 <byorgey> quicksilver: try reloading
09:02:28 <quicksilver> byorgey: weird. Why would it be cached? I didn't load it before...
09:02:47 <quicksilver> anyhow, yes, I see two examples now :)
09:02:51 <byorgey> no idea.  ok, good =)
09:03:05 <byorgey> the source for those is in the examples/ directory in the diagrams-cairo package
09:07:08 <xplat> hm, i wonder if instead of/in addition to 'freeze' there should be a 'render' kind of thing that strokes out a shape and creates a shape representing the strokes
09:07:19 <xplat> like inkscape's 'object to path'
09:08:16 <xplat> quicksilver: maybe you have an rss reader thing that caused it to be preloaded?
09:08:39 <quicksilver> xplat: nope... I just clicked the link here
09:08:46 <djanatyn> I need to learn more about error handling
09:08:48 <FUZxxl> obbele: Are you here?
09:08:56 <djanatyn> especially type errors
09:09:19 <xplat> quicksilver: if you have like a livebookmark to planet haskell or something it might load the page and stick it in the browser cache without you having done anything
09:09:29 <djanatyn> Can I have a program gracefully handle incorrect types of input, instead of ragequitting?
09:10:57 <djanatyn> I have htd yell at you for the incorrect number of arguments, but what if you specify a string when it wants an Int?
09:11:33 <xplat> use readS instead of read, or use a commandline parsing library
09:11:53 <obbele> FUZxxl: so what's the pb with c2hs ?
09:11:55 <ClaudiusMaximus> @hoogle exitFailure
09:11:55 <lambdabot> System.Exit exitFailure :: IO a
09:11:56 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
09:12:19 <FUZxxl> I want to write bindings to the libnova, just for fun.
09:13:02 <FUZxxl> So first: Is it possible to set up cabal in a way, that a certain header file is always passed as an argumnet to c2hs, so I don't have to manually include it anywhere.
09:13:08 <FUZxxl> And second:
09:14:20 <FUZxxl> I wanted to bind the struct ln_date.
09:14:30 <xplat> libnova kind of sounds like the sort of library that should have been written in haskell to begin with :)
09:15:03 <FUZxxl> So I created an algebraic data type that resembles this type and tried to write a Storable instance.
09:15:11 <FUZxxl> I wrote:
09:15:11 <FUZxxl> instance Storable LNdate where
09:15:11 <FUZxxl>   sizeOf _ = {#sizeof ln_date #}
09:15:16 <xplat> bunch of calculations that are tricky to get right, but not flop-intensive
09:15:45 <FUZxxl> But there's actualy no typedef on ln_date, so c2hs quits with an error at that place.
09:16:06 <FUZxxl> So I changed it into {#sizeof struct ln_date #}
09:16:10 <ClaudiusMaximus> how do i foreign import a C function as a pointer?  (it seems that the qd bindings really should be preserving FPU flags on the foreign side instead of trying (fragile..) to do it on the Haskell side)
09:16:30 <FUZxxl> But then it sad something about "struct not allowed at this place"
09:16:32 <FUZxxl> ...
09:16:43 <xplat> did you try sizeof (struct ln_date) just for fun?
09:16:44 <dcoutts> FUZxxl: you don't need to pass the header to c2hs, the .chs file can include as many headers as needed, which is the right approach.
09:16:53 <FUZxxl> dcoutts: Yes.
09:17:11 <ClaudiusMaximus> some lisp bindings i saw had lots of repetitive C functions (one for each function), which i really don't feel like writing...
09:17:14 <xplat> and if all else fails you could make your own little header with a typedef for the struct
09:17:19 <FUZxxl> I've put
09:17:19 <FUZxxl> #include <libnova/libnova.h>
09:17:19 <FUZxxl> at the top of my chs file.
09:17:23 <dcoutts> FUZxxl: and for the second, you can include some C code to define a typedef
09:17:32 <dcoutts> and then c2hs can bind to that
09:17:39 <dcoutts> rather than struct foo
09:18:11 <obbele> is it really needed to make a storable instance of struct ln_date, can we not just pass around a pointer to it ?
09:18:12 <shapr> Did John Hughes leave Chalmers?
09:18:20 <shapr> His website is inaccessible...
09:18:50 <dcoutts> FUZxxl: note that you can include the C code in the .chs file, without needing any wrapper .h file
09:19:03 <FUZxxl> obbele: ln_date is a human-readable representation of a date.
09:19:25 <FUZxxl> It's the output of many functions, so it must be accessible to the programmer.
09:21:52 <FUZxxl> xplat: The library is about 2 MiB and I certainly don't want to recode it in haskell. Most of that are actually huge tables of data.
09:22:03 <FUZxxl> dcolish: How?
09:22:15 <xplat> FUZxxl: yeah, that wasn't a suggestion for you, just a musing
09:22:58 <FUZxxl>  dcoutts: How?
09:23:18 <FUZxxl> xplat: If I had enough time and the right books. I would go for it, but I don't have.
09:24:56 <dcoutts> FUZxxl: check the c2hs user guide but I think it's #beginc ... #endc
09:25:31 <obbele> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/implementing.html#cpp
09:26:16 <Gramler> exit
09:26:26 <dcoutts> obbele: ah thanks, #c ... #endc
09:26:31 <obbele> I've never used it, how does it work ? it extracts the C code, compile it aside and bind it latter
09:26:34 <obbele> ?
09:26:44 * obbele go rtfm
09:26:58 <dcoutts> it just chucks it into the header file that c2hs generates
09:27:04 <FUZxxl> obbele: It says, that no code is allowed.
09:27:12 <dcoutts> FUZxxl: that bit is wrong
09:27:26 <dcoutts> but it's also pointless to put code in there
09:27:30 <FUZxxl> Cite: "Inline C code can currently not contain any code blocks; i.e., only declarations as typically found in header files may be included."
09:27:35 <dcoutts> because there's no .o file that it will end up in
09:27:44 <dcoutts> FUZxxl: yes, that bit is out of date
09:27:48 <FUZxxl> Ah.
09:27:50 <xplat> no code?  laaame
09:27:57 <dcoutts> no! that's old
09:28:05 <dcoutts> you can include whatever C code you like
09:28:06 <obbele> oh
09:28:20 <dcoutts> but note that you're not compiling any .o file
09:28:39 <xplat> that doesn't seem pointful if it doesn't end up anywhere
09:28:45 <dcoutts> so it does not make sense to put code in there except e.g. for inline functions
09:28:58 <dcoutts> that also get defined in some .o file somewhere, that you actually link to
09:30:16 <Athas> sjanssen: ping
09:32:36 <FUZxxl> ohh.
09:32:38 <FUZxxl> Okay.
09:32:53 <FUZxxl> I am beginning to understand the deep mysteries behind the FFI.
09:52:23 <k0ral> hey, I'm having my first segmentation fault using haskell
09:52:32 <ion> Congrats
09:52:58 <k0ral> I thought I would never see again such a thing by getting commited into functionnal programming
09:53:08 <FUZxxl> k0ral: WHat did you do?
09:53:08 <ben> You're probably cheating.
09:53:11 <kulakowski> Haskell seems a rare language to have ones first segmentation fault in.
09:53:15 <FUZxxl> What version of ghc?
09:53:27 <k0ral> well, my first segmentation fault *in haskell*
09:53:48 <k0ral> 7.0.2
09:53:54 <k0ral> I'm using gtk2hs
09:54:02 <Jafet> @can Haskell be used to generate segmentation faults?
09:54:02 <lambdabot> Maybe you meant: faq map run wn
09:54:06 <dafis> kulakowski:  I think it was parenthesized (my first segfault using Haskell)
09:54:08 <Jafet> @faq can Haskell be used to generate segmentation faults?
09:54:08 <lambdabot> The answer is: Yes! Haskell can do that.
09:54:44 <ion> If Gtk2 or the Gtk2 bindings crash, how do you suppose functional programming would work around that?
09:54:50 <dafis> k0ral:  well, gtk2hs uses the FFI, so...
09:54:50 <k0ral> the segmentation fault has been occurring since I created that callback function
09:55:08 <k0ral> I not only use gtk2hs, but also webkit
09:55:20 <k0ral> so if the bug comes from one of them
09:55:30 <k0ral> I just have no hope of fixing it myself, right ?
09:57:20 <k0ral> so ?
09:58:15 <k0ral> ion: well, I don't, I would just have expected the Gtk2 binding not to crash so early in my application development
10:00:34 <siracusa> k0ral: Update your compiler. I vaguely recall a bug in 7.0.2 that caused problems in gtk2hs.
10:00:44 * hackagebot bindings-K8055 0.1.2 - Bindings to Velleman K8055 dll  http://hackage.haskell.org/package/bindings-K8055-0.1.2 (JorisPutcuyps)
10:00:52 <k0ral> ooohhhhhh
10:01:04 <k0ral> sorry for bothering you
10:01:11 <k0ral> actually it comes from flash
10:01:31 <k0ral> fu**ing flash
10:01:55 <k0ral> I recently updated flash and in other browsers it also crashes
10:04:25 <ion> I donâ€™t think â€œfungingâ€ is the proper adjective for something that has fungus on it.
10:17:09 <Luke> is there an easy way to go from epoch millis to UTCTime?
10:22:23 <k0ral> ion: :)
10:23:24 <Perlkonig> so I want to override Data.List.maximum to return 0 when passed an empty list. I declared a maximum' routine with the same type signature and then did a pattern match on [] to return 0, but I'm getting "Could not deduce (Num a)...arising from the literal '0'". How can I accomplish this?
10:24:11 <ion> Whatâ€™s the type of maximum'?
10:24:24 <Lemmih> Perlkonig: What would (maximum' [True,False]) be?
10:24:34 <Perlkonig> the same as maximum: "maximum' :: (Ord a) => [a] -> a"
10:24:41 <dafis> Perlkonig:  since maximum only has an Ord constraint, you can't give 0 as a default for all cases
10:25:00 <ion> Ord a isnâ€™t enough of a constraint for 0, you need to have Num a.
10:25:04 <dafis> Perlkonig:  maximum' :: (Ord a, Numa) => [a] -> a
10:25:20 <Perlkonig> *facepalm* Of course.
10:25:21 <ion> :t 0
10:25:21 <lambdabot> forall t. (Num t) => t
10:26:19 <Perlkonig> Thanks for your patience with my n00b inquiries :) I'm learning lots, but it's taking a lot of hacking to encounter some of these situations.
10:26:41 <saiko-chriskun> Luke: date -d @`date +%s`
10:26:51 <dafis> Perlkonig:  you could write mbmaximum :: Ord a => [a] -> Maybe a
10:27:06 <Luke> saiko-chriskun: what is that?
10:27:20 <saiko-chriskun> converts date from epoch :P
10:27:36 <Luke> to what?
10:27:53 <Perlkonig> dafis: Thanks. I'm doing Project Euler problems to learn, so this is a very special-use situation. When I move on to larger scale projects, I certainly see the beauty of Maybe.
10:28:40 <saiko-chriskun> Luke: to 'Tue May 17 10:35:49 PDT 2011'
10:28:52 <djahandarie> Project Euler is pretty bad at teaching Haskell.
10:29:03 <dafis> djahandarie:  why?
10:29:09 <Luke> saiko-chriskun: I'm looking for UTCTime. Thanks though
10:29:13 <ion> :t maximumMay
10:29:14 <lambdabot> Not in scope: `maximumMay'
10:29:37 <dafis> :t maximumBy
10:29:38 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
10:29:55 <djahandarie> dafis, the most you learn from it is how to use recursion properly. And foldr and such.
10:29:56 <ion> The safe package provides maximumMay :: Ord a => [a] -> Maybe a. Also maximumDef :: Ord a => a -> [a] -> a
10:30:03 <saiko-chriskun> Luke: just add the --utc flag
10:30:05 <Perlkonig> djahandarie: Well it gives me concrete tasks to tackle in a new language. I've done lots of book reading, and there's still more to go, but I find I learn best when I have concrete tasks to focus on.
10:30:07 <saiko-chriskun> Luke: date -d @`date +%s` --utc
10:30:16 <Luke> saiko-chriskun: UTCTime is a haskell type
10:30:16 <ion> One could do maximumDef 0 list, or maybe 0 id (maximumMay list)
10:30:25 <dafis> djahandarie:  and how to avoid laziness leaks
10:30:25 <Luke> saiko-chriskun: looks like you're using bash
10:30:41 <Perlkonig> djahandarie: That's not all. It also helps you learn how to think about problems in a functional way.
10:31:08 <djahandarie> Perlkonig, not really.
10:31:10 <Perlkonig> djahandarie: Learning Haskell is as much about learning functional programming as the language itself, which you're right can be learned in lots of other ways too.
10:31:30 <ion> Using spoon instead of safe, one could do maybe 0 id . teaspoon $ maximum list
10:31:38 <djahandarie> The reason I say "not really" is due to how I think of "functional".
10:31:54 <djahandarie> For me "functional style" /= "using recursion"
10:32:24 <edwardk> djahandarie: wot? you don't want to see kan extensions in typeclassopedia?
10:32:27 <djahandarie> Well, using general recursion at least. Which is what most people mean when they say recursion.
10:32:39 <djahandarie> edwardk, who said I didn't? ;)
10:32:42 * edwardk just tuned in.
10:32:44 <edwardk> hahaha
10:33:28 <Perlkonig> djahandarie: I agree that functional /= recursion, and that's not what I'm saying. For me, who has spent his whole coding life using imperative languages, it often takes me a second to wrap my head around how to tackle the problem in a non-imperative way. While Project Euler may not be ideal as a general way to learn a language, I'm finding it a good way to hack around and figure things out before moving on to larger-scale projects.
10:34:06 <djahandarie> Perlkonig, okay. It's probably fine for just getting a feel. But I think someone could do all the Euler problems in Haskell and not learn much about Haskell.
10:34:49 <djahandarie> I'm a big fan of representing problems in terms of a structure (read: data type), often recursive, and then your whole program is in terms of breaking down or building up that structure
10:35:02 <djahandarie> I don't think the Euler problems would invite someone to do that sort of thing at all
10:35:15 <cccrazy> @src > [1,2,3] ++ [4,5,6]
10:35:15 <lambdabot> Source not found. Do you think like you type?
10:35:16 <Botje> some of them do.
10:35:29 <Botje> most of them are just "haha, you're not using C. have fun optimizing your program"
10:35:34 <cccrazy> how to use lambdabot here?
10:35:48 <dafis> @src (++)
10:35:49 <ion> What do you want to do?
10:35:49 <lambdabot> []     ++ ys = ys
10:35:49 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:35:49 <lambdabot> -- OR
10:35:49 <lambdabot> xs ++ ys = foldr (:) ys xs
10:35:50 <rostayob> what's GHC.Prim.Any?
10:36:08 <Zao> > let x = 9001 in x * x
10:36:08 <edwardk> rostayob: it is something you can unsafeCoerce to safely
10:36:09 <lambdabot>   81018001
10:36:26 <cccrazy> nvm :)
10:36:48 <Perlkonig> djahandarie: The hardest part about learning a langauge is having concrete tasks to complete. The 99 Haskell Problems are a good place too. Since I'm out of school and have limited time, it's nice to have a list of concrete, non-trivial tasks to work on. You are right that the problems do not explicitly invite you to think in the way you describe, but that's how *I* tackle the problems, so it *is* helpful as far as it goes. Is there
10:36:50 <Perlkonig> another place you would suggest I visit? I am very interested in getting a grip on Haskell.
10:36:56 <rostayob> edwardk: wait a sec... unsafeCoerce to what :P?
10:37:12 <ion> rostayob: it
10:37:36 <edwardk> rostayob: GHC.Prim.Any exists because you can't just make up a type and unsafeCoerce to it, when you need to outsmart the type system
10:37:44 <dafis> rostayob:  to which you safely can unsafeCoerce
10:38:15 <edwardk> Any is magical, because ghc won't try to do anything dangerous to it if you go to store a function in it or something with constructors, etc.
10:38:48 <copumpkin> it's also used to instantiate things like [] when you need a value for the type variable
10:39:03 <copumpkin> but that's not really observable
10:39:16 <edwardk> its basically used behind the scenes by ghc
10:39:17 <copumpkin> although I vaguely recall coming across it once in ghci somewhere
10:39:35 <akdom> I'm having an issue with cabal complaining of GHC version, see http://paste.pocoo.org/show/itSbMI9eW8um3RHQDHRS/ . Can anyone help?
10:39:44 <edwardk> i've needed to use it all of ones in the last 5 years of hacking on haskell
10:39:47 <edwardk> er once
10:40:28 <rostayob> ok... the thing is that
10:40:30 <rostayob> I get it out of nowhere
10:40:33 <dafis> akdom:  that's about the ghc library
10:40:38 <djahandarie> Perlkonig, I think it's fun to think about real-world problems in this fashion. I often just look at the nearest program I'm using, decide it sucks, and try to rebuilt it or parts of it.
10:40:45 <rostayob> i'm not "using" it :P
10:40:53 <edwardk> rostayob: in what context?
10:40:55 <akdom> dafis: alright, so what do I need to do?
10:41:17 <dafis> akdom:  what does "ghc-pkg list ghc" say?
10:41:29 <rostayob> edwardk: I'm trying to write a little parser with continuations, and at some point I get that
10:41:48 <Perlkonig> So when GHCI says "Exception: Prelude.(!!): index too large", is there a way to find out what the exact index was?
10:41:52 <edwardk> Any should never pop up in your own code unless you explicitly ask for it.
10:42:01 <akdom> dafis: "/usr/lib64/ghc-6.12.3/package.conf.d"
10:42:11 <edwardk> it'll pop up down in the bowels of core somewhere, but you should never see it in type errors, etc.
10:42:13 <rostayob> edwardk: it does pop up in my case
10:42:25 <edwardk> can you hpaste part of the code and the error?
10:42:51 <rostayob> edwardk: yeah but it's really ugly, just a sec
10:42:58 <dafis> akdom:  that means you have no ghc library package, how did you get your ghc?
10:43:36 <akdom> dafis: yum...  maybe I just didn't install the libs?  let me check.
10:43:43 <dafis> akdom:  (because you can't simply "cabal install" the ghc library)
10:44:07 <dafis> akdom:  probably, that should be available from the distro
10:44:36 <rostayob> edwardk: have you got 5 spare minutes?
10:45:08 <edwardk> i'm flitting between tasks at the moment, but if you can hpaste it i'll see if its something obvious
10:45:36 <rostayob> edwardk: http://hpaste.org/46763/ghcprimany , i'm probably doing something really idiotic here, but I wrote it quickly
10:46:44 <edwardk> and the error?
10:46:54 <dafis> rostayob:  and where does Any enter the picture?
10:47:03 <rostayob> rostayob: the error arises when I try to parse something
10:47:21 <dafis> message?
10:47:32 <akdom> dafis: thank you... I'm pulling down most of the available ghc packages now.  Hopefully this will resolve it.
10:47:39 <rostayob> if I do parse parsePkt "B6034111111111111", I get a Partial back
10:47:47 <dafis> akdom:  I'm optimistic
10:48:12 <rostayob> and that Result is of type Result GHC.Prim.Any
10:49:07 <jmcarthur> shouldn't it be Result ByteString?
10:49:12 <rostayob> jmcarthur: it should
10:49:17 <rostayob> that's what I'd like it to be anyway
10:49:24 <dafis> rostayob:  and how are you told that?
10:49:32 <edwardk> *Main> let x = parse parsePkt "B6034111111111111"         *Main> :t x          x :: Result ByteString
10:49:50 <rostayob>     No instance for (Show (Parser GHC.Prim.Any))
10:50:26 <edwardk> if i just run  *Main> parse parsePkt "B6034111111111111" â€” i get     No instance for (Show (Result ByteString)) â€” not Any
10:51:06 <rostayob> edwardk: ok, wait a sec, I'll try to reproduce that error. In short, I can't resume the parsing in one case
10:51:28 <akdom> dafis: awesome, looks like it was resolved.  That error seems a bit obtuse for that problem, but oh well.  Thank you for your help.
10:51:57 <dafis> akdom:  you're welcome
10:52:39 <edwardk> brb fire drill or something
10:53:19 <rostayob> edwardk: ok, try :t parse parsePkt "B6034"
10:53:25 <rostayob> that give me GHC.Prim.Any
10:54:07 <dafis> *Main> :t parse parsePkt "B6034"
10:54:07 <dafis> parse parsePkt "B6034" :: Result ByteString
10:54:13 <Perlkonig> Is there a Haskell debugger of some kind? I want to step through my code to find an error.
10:54:34 <dafis> rostayob, which ghc version?
10:55:48 <rostayob> dafis: ooops wait a sec, it's not that
10:58:30 <gimmiewater> hey, i'm not sure if it's true, but I heard that there are some software which could translate prolog to haskell, is it right?
10:58:34 <rostayob> dafis: ok: let Partial p = parse parsePkt "B60341111111"; let Partial p = parse p "B6034"; :t parse p "B6034"
10:59:41 <gimmiewater> i mean Prolog as a programing language
10:59:42 <rostayob> dafis, edwardk: that sequence gives me parse p "B6034" :: Result GHC.Prim.Any
11:00:44 <dafis> *Main> let Partial p = parse p "B6034"
11:00:44 <dafis> *Main> :t p
11:00:44 <dafis> p :: Parser GHC.Prim.Any
11:00:58 <dafis> slightly shorter
11:01:08 <rostayob> yep
11:01:14 <rostayob> i'm tired :P
11:01:19 <rostayob> anyway, what is that?
11:01:27 <rostayob> or better, why is that?
11:01:40 <dafis> rostayob:  now, how could GHC know what type p should parse? It can't, so it says Any
11:02:28 <rostayob> so there are cases in which the type inference can't decide?
11:02:33 <jmcarthur> how could it?
11:02:46 <jmcarthur> i'd rather it be polymorphic than guess
11:03:02 <dafis> rostayob:  without context, how would you know which type [] has?
11:03:14 <rostayob> :t []
11:03:15 <lambdabot> forall a. [a]
11:03:49 <jmcarthur> it seems in this case it guessed Any. i've seen that before, but i don't know why it happens
11:03:50 <rostayob> shouldn't it be just a polymorphic type?
11:04:18 <dafis> rostayob:  it could also say Parser a, I guess
11:04:19 <jmcarthur> you could give an explicity annotation
11:04:26 <jmcarthur> *explicit
11:04:45 <rostayob> btw, I've kind of coded out of instinct there, and I think there is something conceptually very wrong in that code
11:04:47 <zygoloid> when it says Any, doesn't it "really" mean (forall a. a)
11:04:55 <dafis> jmcarthur:  ghci's extended defaulting rules, I think
11:05:11 <rostayob> the thing is that
11:05:58 <rostayob> if I feed "B6034", then the 12-chars code, and then 3 chars
11:06:03 <rostayob> it should just return the 12 chars code
11:06:29 <rostayob> I mean the result should be = Done (code, whateverIsLeft)
11:06:44 <rostayob> instead, the first element of the tuple is GHC.Prim.Any
11:06:55 <zygoloid> http://hackage.haskell.org/trac/ghc/ticket/2178
11:07:27 <dafis> zygoloid:  I think Any means rather (exists a. a)
11:07:43 <rostayob> I think I'm losing some information on the way :P
11:08:16 <dafis> rostayob:  try giving different names to the things you let-define
11:08:23 <zygoloid> dafis: yeah, i think you're right.
11:08:26 <rostayob> dafis: ok, lets see
11:08:48 <Luke> how can I use map to thread state through a function application to each element in the list?
11:09:00 <Botje> can't
11:09:01 <dafis> rostayob: the p in let Partial p = parse p "B..." is *not* the one you defined on the line above
11:09:05 <Botje> you can't
11:09:19 <Luke> Botje: what has the same affect?
11:09:22 <shachaf> @ty mapAccumL
11:09:23 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:09:30 <rostayob> dafis: oh, that works.
11:09:35 <rostayob> I mean it gives the expected result
11:09:43 <Botje> if you need to thread state you can use a fold
11:09:47 <rostayob> and there is no GHC.Prim.Any
11:09:52 <Luke> Botje: thanks
11:09:58 <rostayob> this is weird
11:10:16 <dafis> rostayob:  now you're not shadowing previous bindings, so the things have a fixed type
11:10:37 <dafis> since they refer to things previously defined
11:11:01 <rostayob> I'm not sure I fully understand this, but I'm happier anyway
11:11:17 <rostayob> wouldn't ghci just rebind to the new type?
11:11:21 <Luke> Botje: is there a special fold I need to use with a state monad?
11:11:36 <Botje> you don't /need/ a state monad, probably
11:11:43 <Luke> it's true
11:11:49 <Botje> if you're already in the state monad you can just mapM over your input
11:12:05 <dafis> rostayob:  in "let Partial p = parse p ..", the p on the RHS is the p on the LHS, not any p previously in scope
11:12:34 <rostayob> dafis: ohhhh ok this makes more sense now.
11:12:36 <magicman> @type mapAccumR
11:12:36 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:12:38 <rostayob> that was a stupid mistake
11:13:04 <dafis> rostayob:  :set -Wall will warn you about shadowing
11:13:04 <rostayob> dafis: thanks (:
11:13:10 <dafis> welcome
11:13:11 <magicman> Luke: That one is map, and also state threading. From Data.List. There's also mapAccumL, depending on which direction you want to thread state.
11:13:28 <rostayob> dafis: yeah it warned me already, but i didn't think it was an issue
11:13:32 <rostayob> i mean i didn't consider that
11:13:43 <magicman> Oh, I saw shachaf mentioned it already. Sorry for the noise v_v
11:14:03 <Luke> magicman: thanks - that seems pretty complicated
11:14:41 <shachaf> Luke: All it does is let you keep an accumulator as you map.
11:15:41 <shachaf> > mapAccumL (\acc x -> (acc ++ " and " ++ show x, x+1)) "blah" [5,4,3,2,1]
11:15:42 <lambdabot>   ("blah and 5 and 4 and 3 and 2 and 1",[6,5,4,3,2])
11:19:28 <Luke> shachaf: which would be the state monad then? the accum term?
11:20:03 <shachaf> Luke: None of that would be "the state monad".
11:20:17 <KirinDave> How is mapAccumL different from foldl?
11:20:35 <shachaf> You could look at the flip of the argument (:: x -> acc -> (acc,y)) as similar to "the state monad".
11:20:39 <ion> :t mapAccumL
11:20:39 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:20:42 <ion> :t foldl
11:20:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:20:43 <shachaf> KirinDave: Returns a mapped version of the list.
11:21:30 <shachaf> Luke: What's with the monad obsession? It's not magic, and you don't "need it to have state".
11:22:10 <KirinDave> shachaf: I guess it could just be trivially implemented with foldl.
11:22:21 <KirinDave> It's just a more convenient notation.
11:22:23 <ion> > mapAccumL (\acc x -> (acc+x, x+42)) 0 [0..9]
11:22:24 <lambdabot>   (45,[42,43,44,45,46,47,48,49,50,51])
11:22:32 <shachaf> Presumably you'd prefer foldr.
11:23:02 <shachaf> KirinDave: Anything can be trivially implemented with a fold. A fold of a list *is* the list, more or less.
11:23:23 <dafis> KirinDave:  foldl (\(acc,ys) x -> let (acc',y) = foo acc x in (acc',y:ys))
11:23:51 <dafis> with initial accumulator (acc,[])
11:23:57 <Luke> shachaf: the function I'm trying to map keeps state across the applications but you're right - i could just accumulate the state
11:24:01 <Luke> thanks
11:24:16 <ion> > foldl (+) 0 &&& map (+42) $ [0..9]
11:24:17 <lambdabot>   (45,[42,43,44,45,46,47,48,49,50,51])
11:24:58 <KirinDave> Whoah wait wat is &&&
11:25:07 <dafis> :t (&&&)
11:25:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:25:23 <ion> The â€˜aâ€™ being (->) in this case
11:25:25 <shachaf> (&&&) :: (a -> b) -> (a -> c) -> a -> (b,c)
11:25:55 <KirinDave> That is a weird function.
11:26:09 <Luke> that's crazy
11:26:18 <mauke> :t liftA2 (,)
11:26:18 <Luke> from a it produces b and c
11:26:21 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
11:26:26 <ion> Note that the non-mapAccumL version is worse, i was just pointing out that itâ€™s equivalent to doing a fold and doing a map.
11:26:34 <dafis> > liftM2 (,) (foldl (+) 0) (map (+42)) [0 .. 9]
11:26:35 <lambdabot>   (45,[42,43,44,45,46,47,48,49,50,51])
11:27:06 <shachaf> @. pl djinn (a -> b) -> (a -> c) -> a -> (b,c)
11:27:07 <lambdabot> f = liftM2 (,)
11:27:16 <shachaf> @botsnack
11:27:16 <lambdabot> :)
11:27:17 <mietek> I wish every paper was written as clearly as today's Parallel and Concurrent Programming in Haskell
11:27:26 <ion> @djinn (a -> b) -> (a -> c) -> a -> (b,c)
11:27:26 <lambdabot> f a b c = (a c, b c)
11:28:39 <aristid> :t liftM2 (,)
11:28:40 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
11:28:51 <aristid> :t liftA2 (,)
11:28:53 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
11:28:59 <aristid> moar general
11:29:47 <shachaf> aristid: Yes, much more general. Particularly for (r ->).
11:30:29 <jmcarthur> Luke: actually, from b it produces c and c'
11:31:01 <shachaf> jmcarthur: ...Given functions that from produce c and c'.
11:31:07 <jmcarthur> well yeah
11:31:09 <shachaf> Which is slightly less crazy. :-)
11:31:18 <jmcarthur> but luke said it was from a and that it produced b and c
11:32:19 <shachaf> @ty crazy
11:32:20 <lambdabot> forall a b c. a -> (b, c)
11:32:39 <roconnor> Is Data.Map going to be reasonably good at a million interleaved inserts and deletes?
11:34:14 <dafis> roconnor:  depends on your notion of reasonableness, amongst other things
11:34:25 <roconnor> I guess I try it and see
11:34:36 <roconnor> ... though usually when I write haskell code it is very slow :(
11:34:48 <dafis> roconnor:  will the map become large?
11:34:59 <roconnor> I think so
11:35:04 <roconnor> I should compute some stats
11:35:18 <dafis> then it could be less than satisfactory
11:35:38 <dafis> roconnor:  but usually, Data.Map isn't bad
11:35:50 <roconnor> well I guess it is a good start
11:36:00 <roconnor> I'm not sure what other structure I could even consider
11:36:57 <dafis> roconnor:  what sort of keys? I suspect (ST[U])Arrays are not an option.
11:37:25 <roconnor> I have hash paird with WordSomthings
11:37:43 <edwardk> rostyab: glad to see you were able to obtain a resolution
11:37:54 <roconnor> Hash paired with a Word32
11:37:55 <dafis> roconnor:  you could try the HashMap from unordered-containers, perhaps
11:38:00 <edwardk> roconnor: its not bad at dealing with such
11:38:30 <roconnor> dafis: interesting idea
11:38:30 <edwardk> roconnor: it'll be as good as any persistent data structure that doesn't cheat _can_ be ;)
11:38:44 <roconnor> how good is HashMap at sharing?
11:38:48 <edwardk> roconnor: you may want to use HashMap though, if the key is ugluy
11:38:50 <edwardk> er ugly
11:39:05 <edwardk> roconnor: HashMap is fine as long as your hash function is good
11:39:20 <edwardk> HashMap is basically an IntMap of lists of key value pairs
11:39:37 <edwardk> so if your hash function sucks, you'll go linear for searches. if its okay, then you have no problems
11:39:58 <roconnor> edwardk: I need to hash to Int then?
11:40:13 <edwardk> roconnor: the Hashable class does that
11:40:16 <roconnor> I suppose I could xor together all the parts of the hash
11:40:32 <roconnor> sha2 hash
11:40:33 <edwardk> roconnor: i recommend doing something more robust, so that you don't get a symmetric hash
11:40:51 <edwardk> you don't want (a, b) and (b, a) hashing the same typically
11:41:04 <edwardk> hashable deals with that for tuples, iirc
11:41:10 <roconnor> a and b are different types for my pairs
11:41:50 <edwardk> use Data.Hashable
11:41:52 <roconnor> anyhow I'll stick with Data.Map for now
11:41:54 <edwardk> and use 'combine' rather than xor
11:41:57 <roconnor> until I get some timeings
11:41:59 <roconnor> oh
11:42:04 <edwardk> it adds the desired asymmetry
11:42:15 <dafis> would just taking the first four (or eight) bytes of an sha2 hash provide a reasonably good hash?
11:42:30 <edwardk> dafis: sure, but it'd be slow as all get out
11:42:53 <roconnor> edwardk: a sha2 hash is stored as blocks of word32s (in my case I think)
11:42:56 <dafis> edwardk:  as I understood, the sha2 is already there as part of the key
11:43:05 <roconnor> yes
11:43:08 <edwardk> dafis: ah, then he's all set =)
11:43:24 <edwardk> i hadn't read anything about his actual usecase
11:44:59 <roconnor> @type runStateT
11:45:00 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
11:45:48 <edwardk> anyways, HashMap will probably be several times faster than Map
11:45:57 <edwardk> especially with such a large key
11:45:58 <roconnor> :O
11:46:13 <edwardk> no rebalancing
11:46:21 <edwardk> since its just an Int trie
11:46:44 <roconnor> no rebalancing doesn't sound good
11:46:58 <edwardk> nono, it is a crit bit tree. it IS good ;)
11:47:21 <edwardk> IntMap doesn't balance either
11:47:36 <dafis> roconnor:  however, if you need to ask the size often, that wouldn't be good
11:47:37 <edwardk> it relies on the fact that it has a nice maximum depth from the structure of an Int
11:47:42 <sanjoyd> What does <|> mean?
11:47:51 <edwardk> yeah HashMap/IntMap have O(n) size
11:47:54 <c_wraith> sanjoyd: "or", give or take
11:47:56 <roconnor> so all nodes are at depth 32?
11:47:59 <edwardk> no
11:48:00 <roconnor> or 64
11:48:06 <sanjoyd> c_wraith: or that works with Maybe?
11:48:14 <edwardk> if a given bit isn't 'critical' there is no branch there
11:48:19 <dafis> sanjoyd:  alternative, sort of
11:48:19 <roconnor> ah
11:48:20 <c_wraith> sanjoyd: it works with any instance of Alternative.
11:48:24 <roconnor> interseting
11:48:32 <sanjoyd> c_wraith: can you give me a term I can google?
11:48:34 <roconnor> edwardk: okay I'll switch to this ... later
11:48:40 <roconnor> :D
11:48:48 <c_wraith> sanjoyd: with Maybe, it means "if the first arg isn't nothing, return it.  otherwise, return the second arg"
11:49:01 <c_wraith> sanjoyd: look up the Alternative typeclass
11:49:01 <edwardk> should make a factor of 10 performance improvement for you with such a complicated tree, if you aren't constantly asking for size
11:49:05 <edwardk> er complicated key
11:49:12 <sanjoyd> c_wraith: thanks.
11:49:52 <dafis> edwardk:  is the factor of 10 just a guess, or have you extensive experience?
11:50:28 <roconnor> heh
11:50:29 <edwardk> its based on the fact that out of the box it hovers around 5-6 for me, with simple keys, and you're more than twice worse ;)
11:50:40 * roconnor ends his do block not with a return command but with a StateT command :D
11:51:08 <dafis> highly educated guess, then
11:51:18 <edwardk> dafis: yeah
11:51:20 <dafis> with two PhDs
11:51:27 <edwardk> no PhDs here
11:51:30 <roconnor> edwardk: should the size be cached?
11:51:37 <edwardk> roconnor: only if you need it
11:51:39 <dafis> edwardk:  the guess, not you;)
11:51:51 <roconnor> I don't need the size except for debugging
11:52:02 <edwardk> roconnor: it isn't currently done so in HashMap because intersection, etc. wouldn't have a cheap way to update it
11:52:06 <merijn> Saying "no PhDs here" in #haskell is the biggest lie ever :p
11:52:12 <edwardk> merijn: =)
11:52:16 <dafis> roconnor:  then it's fine, I'd think, debugging may run slower
11:52:38 <djahandarie> @quote phd/nick
11:52:38 <lambdabot> <companion_cube> says: edwardk, you mean it's 2 phD/nick in average ? :) <edwardk> clearly this is why SPJ stays away, he doesn't want to dilute that metric.
11:52:47 <edwardk> =)
11:52:49 <merijn> (Actually, I suppose it'd be worse in #coq or #agda, but still...)
11:53:13 <efie> id like to purchase a beginners book which also touches slightly advanced topics. i read some review about real world haskell, and as a lot of them were negative i think i will read this one online when im through with a book for beginners. so my question: do you prefer programming in haskell or learn you a haskell?
11:53:33 <merijn> efie: I don't know the former, but Learn You a Haskell rocks!
11:53:39 <roconnor> one thing I miss about global mutable state, is that it is easy to add global debugging counters.
11:53:44 <edwardk> efie: learn you a haskell is a great introduction, in that it is patient and goes over the material a lot
11:53:52 <dafis> efie:  I'd say LYAH
11:53:55 <merijn> I think Real World Haskell is a decent follow up to LYAH which shows more ugly/practical details
11:54:01 <edwardk> efie: real world haskell dives in deep, getting you to the interesting parts fast, but sometimes skips over material on the way
11:54:01 <roconnor> well, easy to add broken unthreadsafe global debugging counters
11:54:17 <edwardk> efie: personally, i find the two complement each other nicely.
11:54:41 <edwardk> hutton's book feels a bit dated to me
11:54:58 <efie> that sounds good! however, is there anyone here who has read programming haskell and can compare these two?
11:55:00 <merijn> Of course you can check both LYAH and RWH out online for free to see which you like better
11:55:12 <edwardk> efie: that is the 'hutton's book' i mentioned above ;)
11:55:22 <ddarius> roconnor: It's easy enough to do that in Haskell too.
11:55:23 <efie> ah.. :)
11:55:40 <roconnor> ddarius: how do I do that?
11:55:58 <ddarius> roconnor: The unsafePerformIO hack.
11:56:03 <dafis> roconnor:  unsafeP...
11:56:04 <edwardk> efie: personally i'd recommend the combination of LYAH + RWH over Hutton.
11:56:18 <efie> ok, thanks
11:56:21 <edwardk> efie: and if you don't want to buy both, pick one, and read the other online
11:56:42 <efie> yeah that was my idea too
11:56:49 <edwardk> efie: but i'd give serious consideration to paying for both, because the authors of each frequent here, and are really nice folks
11:57:25 <ddarius> edwardk: Myself excepted, pretty much everyone in the Haskell community is nice folks.
11:57:43 <dafis> edwardk:  I don't remember seeing John Goerzen around here
11:57:43 <shapr> hah
11:57:50 <shapr> CosmicRay: hiya!
11:57:54 <edwardk> ddarius: well, we give you a special exemption, so we get can our category theory questions answered.
11:58:01 <shapr> dafis: /wi CosmicRay
11:58:02 <gongyiliao> hello, does someone know if there's a interactive with syntax highlight shell (like ipython) for haskell ?
11:58:11 <djahandarie> ddarius, you aren't nice?
11:58:17 <ddarius> djahandarie: No.  I'm not.
11:58:22 <edwardk> dafis: dons is around enough to average it out ;)
11:58:27 <djahandarie> You didn't beat me up when I saw you in Boston
11:58:37 <dafis> shapr:  thx, though I don't really remember seeing him here
11:58:39 <shapr> ddarius didn't beat me up either.
11:58:42 <djahandarie> Maybe I just dodged a bullet there
11:58:47 <shapr> dafis: CosmicRay has been here for years.
11:58:51 <dafis> edwardk:  yep, and bos isn't rare either
11:59:05 <ddarius> CosmicRay spends a lot of time with his kids, as he should.
11:59:09 <edwardk> djahandarie: you did. ddarius got mugged, and then chased the muggers down for his wallet. tough dude ;)
11:59:20 <dafis> shapr:  sure, just he's in a different time-zone than I am
12:00:00 <djahandarie> edwardk, I thought the story was that someone tried to mug ddarius and they ended up getting mugged instead
12:00:06 <ddarius> edwardk: Chased them down while talking to the police on the phone.
12:00:12 <edwardk> ddarius: =)
12:01:59 <jmcarthur> that's what the mugger gets for unsafePerformIOing
12:03:29 <djahandarie> unsafePerformMug :: ddarius -> Maybe Death
12:04:16 <ddarius> djahandarie: I might've, but I get paid enough that even spending an hour dealing with the paperwork around breaking people's arms wouldn't be worth the money.  However, the hassle of having to get new IDs and new credit cards, etc. would have been worth it.
12:04:56 <dankna> this really happened?  that's awesome
12:05:03 <jmcarthur> you mean you don't keep your entire salary in your wallet?!
12:05:13 <edwardk> dankna: yes
12:05:30 <merijn> jmcarthur: I do, but its just a reference :p
12:05:37 <jmcarthur> ha
12:05:39 <edwardk> dankna: the best part was that he spend like 90 minutes the next day talking to someone before mentioning casually in passing that he'd been mugged ;)
12:05:43 <merijn> Or a thunk, I suppose
12:05:44 <dankna> haha I see
12:05:52 <jmcarthur> an indirection or something
12:06:00 <jmcarthur> i guess a thunk of it's a credit card?
12:06:09 <jmcarthur> eh
12:06:12 <aristid> it's using lazy I/O tho
12:06:14 <jmcarthur> broken analogy
12:06:29 <jonkri> my function is supposed to return a (CE.Exception) e, but when i return "CE.SomeException $ CE.PatternMatchFail "str"", i get an error saying that it's expecting "e" and not "CEB.SomeException". how can i resolve this?
12:06:30 <aristid> we need iteratee-based money
12:06:50 <merijn> credit card would be a reference, no? A debit card (like I have) would be a thunk (since it still requires some computation i.e. pin code)
12:07:07 <ddarius> edwardk: I didn't realize until a few days later, though, that they'd had taken my yen.
12:07:34 <byorgey> jonkri: if it's supposed to return (CE.Exception e) that means it must be able to return one for *any* type e which the caller gets to choose.
12:07:52 <byorgey> jonkri: you are apparently trying to return something with a specific type for e.
12:07:55 <djahandarie> They probably just ended up confused as to why you were carrying yen on you in the first place
12:07:55 <edwardk> ddarius: hah, there is an international currency place here in the mall, want me to grab you some?
12:08:03 <ddarius> edwardk: No.
12:10:27 <jonkri> byorgey: aha :)
12:10:46 <jonkri> if i want to return some different exception, i either make it SomeException or make my own type then?
12:11:00 <jonkri> exceptions*
12:13:39 <byorgey> jonkri: I guess so, I don't know enough about what you're doing to be able to tell
12:13:44 <BMeph> jonkri: Make a type class to which all of your types belong.
12:13:56 <BMeph> (My best guess.)
12:15:13 <jonkri> thanks
12:20:19 <joe6> hello, I am using Test.HUnit and I have a situation where I want the system to just stop doing anything further. Something like the "error" function. When I use the error function, it is being captured as a Test error and the system continues processing to the next test.
12:21:03 <joe6> as, the error function is in one of the functions that are wrapped around with the runTestTT . TestList. TestCase
12:21:44 <joe6> any suggestions on how I can just fail the testsuite?
12:21:52 <joe6> does assertFailure do that?
12:23:18 <jonkri> is it possible to have a (forkIO'd) thread get killed when my program is killed with like ctrl+c?
12:23:35 <merijn> jonkri: It's not just possible, but guaranteed
12:23:37 <roconnor> @type unfoldr
12:23:38 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:24:09 <jonkri> merijn: oh, ok, great :)
12:24:41 <merijn> jonkri: At least, it is on any sane OS :p forkIO'd threads run inside the same process (all threads do, actually). When the OS kills a process any thread associated with it dies
12:26:13 <roconnor> > unfoldr (\x -> if x == 0 then Nothing else Just (fromInteger x :: Word8, r `shiftr` 8)) 123456789
12:26:14 <lambdabot>   Not in scope: `shiftr'
12:26:16 <byorgey> joe6: perhaps try exitFailure from System.Exit?
12:26:21 <byorgey> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Exit.html#v:exitFailure
12:26:39 <joe6> byorgey, thanks a lot.
12:26:50 <roconnor> > unfoldr (\x -> if x == 0 then Nothing else Just (fromInteger x :: Word8, r `shiftR` 8)) 123456789
12:26:51 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
12:26:51 <lambdabot>         against inf...
12:27:02 <byorgey> joe6: that may get caught too, I am not sure, but it's worth a try
12:27:29 <joe6> byorgey, looks like that might do it.
12:27:33 <roconnor> > unfoldr (\x -> if x == 0 then Nothing else Just (fromInteger x :: Word8, x `shiftR` 8)) 123456789
12:27:35 <lambdabot>   [21,205,91,7]
12:27:50 <joe6> byorgey,  I mean bypass the IO exception mechanism
12:27:52 <roconnor> > 0x123456789
12:27:53 <lambdabot>   4886718345
12:27:57 <byorgey> joe6: right.
12:30:49 <roconnor> bytes are in the wrong order :(
12:30:51 <tomh> are there some tools to work with antlr files in haskell?
12:31:13 <ddarius> Why would you want to?
12:31:21 <joe6> byorgey, just tried it, It is getting caught as a failure by the runTestTT
12:31:36 <tomh> ddarius: because I already have an antlr parser
12:31:39 <byorgey> joe6: drat =(
12:34:37 <dafis> roconnor:  how would you want it to behave on negative Integers?
12:34:57 <dankna> bah.  it's really a shame that I have to reword this 300-line pure function to be monadic :/
12:35:07 <byorgey> joe6: if you are on a POSIX system you could try exitImmediately, http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Process.html#v:exitImmediately
12:35:09 <mm_freak> from what i'm reading in the haddock docs, Text can be faster than ByteString, because it supports fusion
12:35:12 <mm_freak> right?
12:35:17 <dankna> ByteString also supports fusion
12:35:27 <mm_freak> oh, ok
12:35:58 <byorgey> ByteString is for when you want to efficiently deal with a bunch of bytes.  Text is for when you want to efficiently deal with some text.
12:36:01 <dankna> I haven't profiled them against each other, but Michael Snoyman did a while ago, in the context of web frameworks.  Results may have changed since then.
12:36:06 <byorgey> they are not really interchangeable.
12:36:34 <dafis> dankna:  the results are very platform-dependent, too
12:36:51 <dankna> ah, okay
12:37:08 <roconnor> 256^256 isn't very big
12:37:45 <jmcarthur> i with ByteString was called ByteArray instead
12:37:57 <jmcarthur> it would leave people without fewer preconceptions about what it's for
12:38:02 <jmcarthur> *with fewer
12:38:27 <dafis> dankna:  I benchmarked Text vs. ByteString for a couple of things, occasionally, and Text was, well, not exactly fast here. Text's fusion relies on enough registers being available, so on 64-bit, it's plenty fast, on 32-bit, not
12:38:37 <jmcarthur> because "string" is commonly intended to mean text
12:39:07 <dankna> dafis: hmmm, okay.  definitely good to know.
12:39:08 <dafis> > 256^256
12:39:09 <lambdabot>   323170060713110073007148766886699519604441026697154840321303454275246551388...
12:39:17 <jmcarthur> the performance is not the reason to use text over bytestring though
12:39:20 <dafis> roconnor:  larger than you can count
12:39:27 <joe6> byorgey, that worked like a charm. Thanks a lot.
12:39:33 <byorgey> joe6: great =)
12:39:33 <dankna> certainly there are factors besides performance, but performance is an issue for some applications
12:39:56 <dankna> I confess I haven't really looked at Text, but I presume it handles multiple encodings in a much nicer way and all that
12:40:37 <jmcarthur> to me, the reason to use Text isn't really a "factor" so much as it is *the* reason (unicode)
12:40:40 <dafis> dankna:  yes, it has the more convenient API, ByteString's API is fine if you deal with ASCII or latin1, though
12:40:49 * dankna nods
12:43:52 <jmcarthur> text's API is also a bit specialized for working with... well... text! search and replace, case conversion, justification, stripping, etc.
12:53:23 <roconnor> > do {2 <- Just 7; return 5} :: Maybe Int
12:53:24 <lambdabot>   Nothing
12:53:59 <xplat> emacs.c mainly seems to consist of defining a million global variables and exporting them to lisp :(
12:54:57 <djahandarie> roconnor, I didn't know you could do that, totally makes sense though
12:55:43 <roconnor> > do {l@(_:_) <- Just []; return l} :: Maybe Int
12:55:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:55:45 <lambdabot>         against inferred type ...
12:55:50 <roconnor> > do {l@(_:_) <- Just []; return l} :: Maybe [Int]
12:55:50 <lambdabot>   Nothing
12:55:56 <roconnor> > do {l@(_:_) <- Just [2]; return l} :: Maybe [Int]
12:55:56 <lambdabot>   Just [2]
12:56:06 <jmcarthur> djahandarie: it's just the fail method
12:56:17 <jmcarthur> fail is nice except when it doesn't make sense
12:56:39 <copumpkin> like that fucking String parameter
12:56:45 <roconnor> when deserializing an integer I want to check that its tag is 2
12:56:50 <roconnor>   get = do 0x02 <- getWord8
12:56:52 <roconnor> ...
12:58:50 <ddarius> > either id id $ do False <- return True; return "doh"
12:58:51 <lambdabot>   Overlapping instances for GHC.Base.Monad
12:58:52 <lambdabot>                              (Data...
13:00:45 <ion> ghci> either id id $ do False <- return True; return "doh"
13:00:45 <ion> "*** Exception: Pattern match failure in do expression at <interactive>:1:18-22
13:05:40 <monochrom> do {False -> return True; y} = (return True >>= \ False -> y) = bad for many monads
13:06:19 <monochrom> basically if you get down to ((\ False -> y) True) it's hopeless
13:06:36 <roconnor> monochrom: that isn't how do notation is translated.
13:06:37 <roconnor> AFAIK
13:06:47 <roconnor> @undo do {False -> return True; y}
13:06:47 <lambdabot>  Parse error at "->" (column 11)
13:06:52 <roconnor> @undo do {False <- return True; y}
13:06:53 <lambdabot> return True >>= \ a -> case a of { False -> y; _ -> fail ""}
13:07:24 <monochrom> yes, I misremembered
13:08:05 <monochrom> although, the real message given to fail is also "pattern match failure etc"
13:08:27 <roconnor> fair
13:09:25 <parcs> @src ErrorT fail
13:09:25 <lambdabot> fail msg = ErrorT $ return (Left (strMsg msg))
13:09:37 <parcs> @type strMsg
13:09:38 <lambdabot> forall a. (Error a) => String -> a
13:09:47 <monochrom> > do { False <- return True; Just () }
13:09:48 <lambdabot>   Nothing
13:10:20 <parcs> @type throwError. strMsg
13:10:21 <lambdabot> forall a (m :: * -> *) a1. (MonadError a m, Error a) => String -> m a1
13:26:24 <Aune> Im playing around a bit with memoizing through data structures in the spirit of fibs = 1:1: zipWith (+) fibs (tail fibs), and I decided to try a bit of a harder problem, the Ackermann function http://en.wikipedia.org/wiki/Ackermann_function . How do I approach this problem, I have a straight forward recursive definition, so I think it should be possible to just calculate how the haskell code should look, is there a way to do this?
13:27:08 <bos> @djinn [Bool] -> Bool
13:27:09 <lambdabot> Error: Undefined type []
13:27:22 <bos> @hoogle [Bool] -> Bool
13:27:24 <lambdabot> Prelude and :: [Bool] -> Bool
13:27:24 <lambdabot> Prelude or :: [Bool] -> Bool
13:27:24 <lambdabot> Data.List and :: [Bool] -> Bool
13:29:07 <monochrom> Aune: "fibs = 1:1: zipWith (+) fibs (tail fibs)" is specific to linear recurrences. you need a more general method for Ackermann
13:31:01 <Aune> monochrome: Yeah, I kind of assumed so, the Ackermann function might have been to hard a choice since it is not primitive recursive, but this is why I selected it.
13:39:07 <Aune> monochrome: I think it ought to be possible to state te Ackermann table as "let ack = [1 ..] : {some expression}" but Im not sure that it is, and completely lost as to how it could be done if possible.
13:39:46 <k0ral> I would like to launch rawsystem in  separate thread, could you redirect me toward the right function to use ?
13:46:09 <c_wraith> k0ral: what *precisely* do you want?
13:46:22 <c_wraith> k0ral: forget "threads" and such.  what semantics do you want?
13:46:34 <Aune> monochrome: I think I'll give up on this and try an easier exercise
13:47:24 <Cale> > let iter f 0 = f 1; iter f n = f (iter f (n-1)); ack 0 = succ; ack m = iter (ack (m-1)) in [[ack m n | n <- [0..4]] | m <- [0..3]]
13:47:25 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,5,7,9,11],[5,13,29,61,125]]
13:48:42 <Cale> ^^ Ackermann function by primitive recursion ;)
13:50:09 <Aune> Cale: Awesome ^
13:51:53 <poltak> what do you think about java?
13:52:25 <Cale> > let iter f 0 = f 1; iter f n = f (iter f (n-1)); acks = iterate iter succ in [[(acks !! m) n | n <- [0..4]] | m <- [0..3]]
13:52:25 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,5,7,9,11],[5,13,29,61,125]]
13:52:35 <k0ral> c_wraith: well, I want to launch a shell command, but in a different thread
13:52:47 <c_wraith> k0ral: that's the opposite of what I asked
13:52:54 <k0ral> c_wraith: :)
13:52:59 <c_wraith> k0ral: what *semantics* do you want?
13:52:59 <k0ral> c_wraith: what did you expect ?
13:53:09 <jmcarthur> poltak: very much unlike haskell
13:53:41 <poltak> but way better?
13:53:45 <jmcarthur> lol
13:54:24 <Cale> > let iter f n = iterate f 1 !! (n+1); acks = iterate iter succ in [[(acks !! m) n | n <- [0..4]] | m <- [0..3]]
13:54:25 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,5,7,9,11],[5,13,29,61,125]]
13:54:25 <c_wraith> k0ral: Is what you really want to run a shell command, but not block your main processing?
13:54:44 <Aune> poltak: Didnt you ask the exact same question yesterday?
13:54:45 <Cale> hmmm...
13:55:33 <c_wraith> k0ral: do you ever want to examine the exit code?  Do you care about the result?
13:55:59 <Aune> Cale: I hardly have time to grok one of your solutions before you produce another one ^^. Keep it up ^^
13:56:10 <poltak> Aune: I didn't get an answer, you cheeky chicken
13:56:12 <k0ral> c_wraith: well, this is indeed what I really want, I use gtk2hs which is callback-based, and i don't want a callback to bloke the whole program
13:56:26 <jmcarthur> poltak: what kind of answer do you expect from #haskell, really?
13:56:36 <Cale> Aune: I'm just transforming each one into the next, trying to get at one which operates mainly on lists, and hopefully without !!
13:56:48 <Aune> poltak: Yeah, degenerated into a discussion about tea vs coffe if I remember it correctly ^^
13:56:50 <poltak> why not, mr arthur?
13:56:54 <copumpkin> poltak: java the language?
13:56:56 <copumpkin> or the jvm?
13:57:03 <poltak> copumpkin: NOT THE COFFEE
13:57:20 <copumpkin> java is an indoensian island
13:57:20 * ddarius doesn't like any.
13:57:22 <copumpkin> indonesian
13:57:25 <jmcarthur> it's an odd enough question as it is, but then it starts to get trollish when you suggest that it's vastly superior right off the bat considering what channel you're in
13:57:25 <poltak> everyone kept talking about coffee and indonesia!
13:57:44 <poltak> well I was having the same discussion with my teacher
13:57:49 <poltak> he didnt know haskell
13:57:58 <jmcarthur> yeah most teachers don't, sadly
13:57:58 <copumpkin> teachers tend to be wrong
13:58:01 <poltak> but said imperitive is the way to go and functional isn't very functional
13:58:11 <copumpkin> what I just said
13:58:12 <jmcarthur> sounds dogmatic
13:58:20 <poltak> and I'm wondering: why do you learn haskell?
13:58:30 <poltak> I want to know from you guys not my teacher
13:58:35 <c_wraith> k0ral: you can probably use forkIO for what you want, though the docs in the process module make me suspect you'll need the threaded runtime in order for the rawSystem call to not block the whole RTS, regardless
13:58:35 <mauke> so I can fly like an eagle
13:58:36 <jmcarthur> alright that's fair
13:58:51 <poltak> and why is java everywhere and I've never heard of haskell untill now?
13:58:52 <copumpkin> I learned it because I enjoy a challenge, and it made a lot more sense than anything else I'd encountered at that point
13:59:16 <ddarius> copumpkin: Wouldn't it be more challenging if it didn't make sense?
13:59:17 <copumpkin> poltak: why do millions of people eat mcdonalds every day?
13:59:23 <jmcarthur> poltak: i learned haskell because i was curious. i now use it as my primary language because it makes it easier to reason about my code and i find that i have far more clarity of thinking and abstraction power
13:59:29 <poltak> copumpkin: because it's bloody yummy
13:59:30 <copumpkin> ddarius: it would be more challenging in a more frustrating manner
13:59:49 <Cale> poltak: Haskell is different, and therefore not so easy to just pick up in a weekend. Java is everywhere because it's very similar to things which people already knew.
13:59:56 <jmcarthur> poltak: java is popular because its only change over languages people already knew at the time was basically garbage collection
14:00:29 <poltak> as in C-like languages?
14:00:34 <jmcarthur> languages rarely gain popularity due to merit
14:00:34 <Cale> yeah
14:00:36 <jmcarthur> yeah
14:00:54 <jmcarthur> they tend to gain popularity due to familiarity and incremental improvements
14:00:55 <ddarius> They gain popularity due to people.
14:00:58 <poltak> makes sense
14:01:03 <mauke> Haskell wasn't created to be popular
14:01:03 <aristid> jmcarthur: let's say, they rarely gain popularity due to merit alone
14:01:06 <poltak> well I'm actually loving haskell so far
14:01:15 <jmcarthur> aristid: oh that's what i intended to say. thanks
14:01:24 <Cale> It's an imperative OO language. If you know one imperative OO language, you can learn another very quickly. They're not much more than re-skinnings of each other anyway.
14:01:25 <mauke> Java had massive marketing behind it
14:01:33 <c_wraith> I learned haskell because we were using it at work a bit, and it's *actually* different from all the mainstream things, which are mostly just different forms of syntax around the exact same idea
14:01:51 <ben> If only there were some sort of "haskell for imperative oo language programmers" document!!
14:01:53 <edwardk> I learned haskell because I had been fiddling with toy languages for years, and Haskell had a more coherent story for how all its features put together than any of my designs. It is awesome.
14:01:56 <jmcarthur> c_wraith: that's an unusual introduction to haskell :)
14:02:58 <poltak> alright thanks for your opinion guys. I'm gonna go to uni and argue with this fella a bit more on the issue
14:03:05 <jmcarthur> it takes a lot longer to fully appreciate haskell compared to familiar languages, i think
14:03:11 <aristid> poltak: which position does he take?
14:03:12 <jmcarthur> i wouldn't bother
14:03:42 <edwardk> Haskell was the first language I picked up where I felt like I learned something in a decade or two. =/
14:03:43 <Perlkonig> So I have a string consisting of a single digit and a single letter (eg., "5B"). I want to turn that into a tuple (Int, Char). I'm trying to "read (string!!0) :: Int" to extract the number, but ghci complains it's a Char and not a String. How do I do this?
14:03:44 <jmcarthur> arguing with a teacher is one of the most unproductive things i know of
14:03:57 <edwardk> jmcarthur: hah
14:04:01 <aristid> Perlkonig: use pattern matching :)
14:04:06 <poltak> aristid: first year programming (java) and flash
14:04:29 <mauke> Perlkonig: use digitToInt instead of read
14:04:37 <ben> Perlkonig: I really like your nick but have an Ã¶
14:04:38 <jmcarthur> aristid: "functional is not functional" is the alleged position
14:04:45 <Perlkonig> mauke: Thanks!
14:04:50 <aristid> Perlkonig: yeah, it should be Perlkoenig
14:04:56 <Perlkonig> ben: Aye, but I can't make my client see the umlaut.
14:05:04 <ben> Aw, too bad
14:05:08 <aristid> Ã¶ can be transliterated as oe :)
14:05:09 <ben> and yeah, what aristid said :)
14:05:47 <fushunpoon> Hey; I'm trying to get SDL working with cabal.
14:06:20 <dafis> Perlkonig:  or use digitToInt from Data.Char
14:06:30 <fushunpoon> so far I've not had much luck with forcing the hack made in the SDL package work together with Distribution.Simple. Anybody tried this before?
14:06:32 <dafis> oh, too late again
14:06:41 <Perlkonig> dafis: That's what I'm about to do. Thank you. Lots of built-in functions to learn about!
14:07:07 <Cale> Perlkonig: another option would be to use reads
14:07:16 <k0ral> c_wraith: the type system complains whenever I try forkIO $ rawsystem ...
14:07:20 <Cale> > reads "5B" :: [(Int, String)]
14:07:20 <lambdabot>   [(5,"B")]
14:07:31 <c_wraith> k0ral: yes, the types don't line up.  fix that. :)
14:07:34 <k0ral> c_wraith: but if you tell me this is the right function to use I will investigate
14:07:43 <Cale> (this gives a list of parses, if it's empty it means there was no integer part)
14:07:45 <c_wraith> k0ral: forkIO needs an IO ()
14:07:48 <Perlkonig> Cale: Thanks! That will be very helpful.
14:07:58 <c_wraith> k0ral: so make sure the action you give it has the type IO ()
14:08:14 <k0ral> koala_man: and rawsystem gives an ExitCode
14:08:20 <shachaf> Cale: For rather limited values of "list".
14:08:24 <k0ral> oops
14:08:27 <k0ral> c_wraith: ^
14:08:47 <Cale> yeah, theoretically, it gives a list of possible parses, but the existing instances just give the one greedy parse when they succeed
14:08:48 <mauke> fortunately ignoring return values is easy
14:08:51 <c_wraith> yes.  this is a very common manipulation
14:10:00 <dafis> did void make it into a standard library, by the way?
14:10:03 <c_wraith> :t readFile "foo"
14:10:04 <lambdabot> IO String
14:10:12 <c_wraith> :t readFile "foo" >> return ()
14:10:13 <lambdabot> IO ()
14:10:36 <c_wraith> :t do { _ <- readFile "foo" ; return () }
14:10:37 <lambdabot> IO ()
14:10:58 <dafis> @hoogle void
14:10:59 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
14:11:05 <dafis> yup
14:11:06 <k0ral> c_wraith: is it okay to add "_ <- " before rawsystem and "; return ()" ?
14:11:16 <mauke> k0ral: you don't need _ <-
14:11:27 <k0ral> mauke: fine
14:11:32 <c_wraith> k0ral: if it's in its own do block.  ">> return ()" is the smallest operation
14:11:37 <dafis> k0ral:  that's just to silence a stupud warning
14:11:48 <dafis> stup*i*d
14:11:49 <ion> :t readFile "foo" *> pure ()
14:11:50 <lambdabot> IO ()
14:11:59 <c_wraith> :t () <$ readFile "foo"
14:12:00 <lambdabot> IO ()
14:12:10 <ion> Ah, indeed
14:12:18 <c_wraith> But both of those require an import :)
14:12:19 <k0ral> dafis: well, I like to silence them
14:12:28 <ion> An import you do anyway. ;-)
14:12:39 <parcs> @type (<$)
14:12:40 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
14:12:43 <k0ral> now it compiles, let's see what it does
14:12:50 <aristid> :t (<*) . return
14:12:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f, Monad f) => a -> f b -> f a
14:12:53 <dafis> k0ral:  that particular warning should be silenced on the command line, -fno-warn-unused-do-bind
14:13:14 <c_wraith> k0ral: like I said, the docs for process suggest that if you're not using the threaded runtime, that won't actually help
14:13:36 <k0ral> dafis: well, isn't that dangerous ? maybe one day I'll run into a situation where it is relevant
14:14:04 <k0ral> c_wraith: so I first have to figure out what is the thing you call "threaded runtime"
14:14:17 <c_wraith> k0ral: add -threaded to the ghc flags
14:14:41 <mauke> k0ral: you see, there's threads and then there's threads
14:14:56 <dafis> k0ral:  maybe, but as far as I can tell, the only relevant occurrence of that one is a forgotten _ in mapM_ or forM_, that's not yet happened to me
14:15:46 <dafis> I only turn off any warnings after compiling things and making sure that there's none relevant
14:15:54 <smoge> Hi!!
14:15:57 <smoge> I can't install base here
14:15:58 <smoge> I get a strange error with cabal
14:16:08 <k0ral> with forkIO and -threaded, it still blokes the application :(
14:16:09 <mauke> smoge: why are you trying to install base?
14:16:10 <smoge> base-4.3.1.0
14:16:12 <dafis> smoge:  you can't install base
14:16:17 <mauke> k0ral: *blocks
14:16:20 <smoge> well
14:16:21 <k0ral> sorry
14:16:31 <smoge> I get a lot of errors with other packages
14:16:33 <smoge> like:
14:16:33 <pastorn> k0ral: i always use "_ <- f" when writing do-notation
14:16:35 <dafis> smoge:  it's part of the compiler
14:16:39 <smoge> containers-0.4.0.0 depends on base-4.3.1.0 which failed to install
14:16:42 <k0ral> pastorn: so do I
14:16:43 <geheimdienst> smoge: the haskell compiler ghc comes with base. normally people use the base version provided by ghc
14:16:53 <pastorn> k0ral: that way i can get all my "<-" in one nice line :)
14:16:54 <dafis> smoge:  upgrade ghc
14:17:02 <ezyang> I love how, in philosophy, there is a term "referential opacity". It's like the opposite of "referential transparency."
14:17:02 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
14:17:05 <ezyang> @messages
14:17:06 <lambdabot> FUZxxl said 5h 7m 59s ago: Can you help me with some c2hs related questions?
14:17:08 <c_wraith> k0ral: GHC has two different runtime systems it can link your program against.  the standard one is not threaded.  It supports forkIO'd green threads, but all FFI calls (which process uses) block the whole runtime.  The alternative runtime uses multiple OS threads, and has lots of crazy extra rules.
14:17:08 <k0ral> pastorn: I see I'm not the only fool here :)
14:17:13 <smoge> I have the The Glorious Glasgow Haskell Compilation System, version 7.0.2
14:17:16 <ezyang> @tell FUZxxl np
14:17:17 <dafis> smoge:  or use containers-0.3.0.0
14:17:17 <lambdabot> Consider it noted.
14:17:20 <smoge> it's the latest?
14:17:32 <RichardBarrell> c_wraith: er, I thought only FFI calls marked unsafe would block the runtime?
14:17:40 <smoge> 7.0.2-2 (arch)
14:18:07 <k0ral> well, I guess I'll spend my next work day reading about threads
14:18:08 <mauke> RichardBarrell: everything blocks the unthreaded runtime. it's unthreaded
14:18:10 <smoge> the same:
14:18:10 <dafis> smoge:  7.0.2 has base-4.3.1.0
14:18:11 <smoge> containers-0.3.0.0 depends on base-4.3.1.0 which failed to install
14:18:12 <k0ral> working*
14:18:17 <smoge> hum..
14:18:23 <smoge> what's wrong then??
14:18:32 <smoge> why I get those errors?
14:18:40 <mauke> smoge: I don't know; what are you trying to do?
14:18:53 <dafis> smoge: try "ghc-pkg check"
14:18:57 <c_wraith> RichardBarrell: most documentation about the GHC runtime is actually about the threaded runtime.  the non-threaded one is quite primitive in comparison, but it's also a lot simpler
14:19:03 <dafis> to see if you have broken packages
14:19:10 <smoge> a lot!
14:19:12 <Cale> http://bellard.org/jslinux/ -- run linux in your browser
14:19:23 <dafis> smoge:  paste?
14:19:24 <hpc> Cale: technically any OS
14:19:27 <dafis> @where paste
14:19:28 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
14:19:34 <Cale> yeah, they ported Qemu to javascript
14:20:08 <parcs> what is the syntax of kind annotations within typeclass definitions?
14:20:15 <smoge> http://hpaste.org/46768/errors
14:20:27 <geheimdienst> cale, nice link, thanks
14:20:35 <smoge> dependency "base-4.3.1.0-c33a1741503ded8a0170884e8a2e4fa2" doesn't exist
14:20:43 <smoge> I have just reinstalled GHC
14:20:47 <smoge> this does not make sense
14:21:08 <parcs> never mind, guessed it
14:21:16 <dafis> smoge: how did you reinstall it?
14:21:27 <smoge> pacman -S ghc
14:21:35 <dafis> smoge:  ghc-pkg list base
14:21:36 <smoge> just that
14:22:02 <c_wraith> smoge: remove ~/.ghc
14:22:12 <smoge> http://hpaste.org/46769/error
14:22:14 <smoge> ok
14:22:17 <smoge> Ill try
14:22:25 <c_wraith> well, rename it, if you want to be cautious :)
14:22:26 <smoge> Done
14:22:34 <c_wraith> now run ghc-pkg check
14:22:36 <smoge> and now?
14:23:20 <smoge> http://hpaste.org/46770/error
14:23:21 <parcs> @type const id
14:23:22 <lambdabot> forall a b. b -> a -> a
14:23:26 <parcs> @type flip const
14:23:27 <lambdabot> forall b a. a -> b -> b
14:23:43 <smoge> what should I do now?
14:24:02 <c_wraith> smoge: were you installing packages globally before?
14:24:19 <smoge> I'm installing all with --user
14:24:24 <c_wraith> smoge: having broken packages with an empty .ghc directory is scary
14:24:38 <c_wraith> (empty or absent)
14:24:44 <smoge> how can I just reinstall everything?
14:24:49 <dafis> scary puts it mildly
14:25:25 <ion> rm -fr ~/.cabal ~/.ghc really cleans it up. :-)
14:25:29 <smoge> there are stuff in /usr/lib/ghc-7.0.2
14:25:58 <smoge> delete that folder too? :S
14:26:15 <ion> You should never, ever touch that except via the systemâ€™s package manager.
14:26:24 <smoge> yes I know
14:26:40 <smoge> but what's wrong then?
14:27:16 <Cale> aww, in-browser linux doesn't have a network interface...
14:27:17 <c_wraith> well, (one of) your global package dir(s) got corrupted somehow.  That's...  confusing, if you only ever installed stuff locally
14:27:23 <dafis> smoge:  which package databases are listed if you do ghc-pkg list
14:27:25 <ben> Cale: lo is a network interface ;)
14:27:28 <smoge> there is a /usr/lib/ghc-7.0.2/base-4.3.1.0 folder
14:27:32 <ben> ping 127.0.0.1!
14:27:45 <Cale> Sure, but that's not terribly useful for downloading nethack
14:27:55 <c_wraith> hmm.  nethack in browser.
14:28:04 <smoge> http://hpaste.org/46771/list
14:28:35 <ben> Cale: Maybe you could manipulate the image it loads?
14:29:09 <monochrom> uninstall ghc and re-install
14:29:27 <roconnor> the parameters to Data.Serialize.Get.runGetState are in the wrong order :/
14:29:47 <dafis> smoge: okay, somehow base got lost, and you have *lots* of packages there, does pacman have a wipe this shit out command?
14:30:15 <roconnor> @seen trevor
14:30:15 <lambdabot> Unknown command, try @list
14:30:15 <preflex>  trevor was last seen on #haskell 182 days, 19 hours, 42 minutes and 35 seconds ago, saying: That old logo sure is ugly
14:30:19 <smoge> but that should be fixed reinstalling ghc, right?
14:30:23 <smoge> damn .,,
14:31:15 <roconnor> @tell dons the parameters to Data.Serialize.Get.runGetState are in the wrong order.  the result should be ByteString -> Either String (a,ByteString) to be comaptible with the monad transformer.
14:31:15 <lambdabot> Consider it noted.
14:32:06 <dafis> smoge: right, damn, wipe and rebuild if pacman can do
14:32:06 <KirinDave> Hmm
14:32:20 <smoge> thanks
14:32:35 <KirinDave> Is it inappropriate to model functions with a newtype if they're very restricted in scope?
14:32:52 <smoge> +1gb of stuff, will take some time
14:32:57 <roconnor> KirinDave: how do you mean?
14:33:09 <dafis> oh shit, 1gb???
14:33:31 <smoge> yes, because lots of packages depend on ghc
14:33:33 <hpc> KirinDave: generally you would only use a newtype when you want a recursive type or a custom instance
14:33:35 <monochrom> ghc alone is already half of that or something
14:33:45 <KirinDave> roconnor: I was doing this thing that models fees on payments.
14:34:14 <KirinDave> roconnor: I thought maybe that'd be modeled with an Amount -> (Amount, Amount) sort of function.
14:34:18 <roconnor> hpc: or data abstraction
14:34:23 <dafis> monochrom: but it compresses not too badly, so the network traffic should be far less
14:34:48 <KirinDave> roconnor: But it'd be nice to model that directly, you know? So that I can work with the concept of payments and fees and their computations directly.
14:35:05 <monochrom> I mean after installing
14:36:10 <dafis> monochrom: yes, after, but the download is what takes most of the time, unless you have an enormous line
14:36:15 <hpc> KirinDave: you might want a type alias
14:36:22 <hpc> type Fee = Something -> Whatever
14:36:34 <KirinDave> Yeah
14:37:49 <aristid> KirinDave: maybe generalise it to a single type for fees and rebates and subsidies and taxes first?
14:44:01 * dafis wishes ghc would build faster, hates validating patches therefore
14:45:16 <pastorn> dafis: you're building from source?
14:45:25 <dafis> pastorn: sure
14:45:29 <pastorn> dafis: ehm...
14:45:43 <dafis> pastorn: not much choice if you're hacking base
14:45:57 <pastorn> you are? what are you hacking on?
14:46:06 <dafis> atm, fixing gcd
14:46:12 <parcs> is it possible to implement a function (Applicative f, Functor f') => f x -> f' x ?
14:46:45 <Cale> no
14:46:52 <ben> like, IO String -> Maybe String?
14:46:58 <dafis> except for const undefined
14:47:06 <dafis> and the like
14:47:17 <roconnor> @free f x -> g x
14:47:17 <lambdabot> Extra stuff at end of line
14:47:27 <pastorn> dafis: what's wrong with it?
14:47:29 <aristid> dafis: damn i wanted to enumerate all the ways to do this with bottom :D
14:47:31 <roconnor> @free foo :: f x -> g x
14:47:31 <lambdabot> Extra stuff at end of line
14:47:44 <dafis> pastorn: gcd 0 0 is an error
14:48:04 <aristid> @free f x -> g
14:48:04 <lambdabot> Extra stuff at end of line
14:48:07 <dafis> @free \f x -> g x
14:48:08 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:48:08 <aristid> @free f x
14:48:08 <lambdabot> Extra stuff at end of line
14:48:13 <aristid> @free f -> g
14:48:13 <lambdabot> Extra stuff at end of line
14:48:18 <smoge> what this means: cabal: cannot configure hint-0.3.3.2. It requires ghc >6.6
14:48:18 <aristid> oO
14:48:20 <smoge> ???
14:48:27 <monochrom> > "hi"
14:48:27 <lambdabot>   "hi"
14:48:28 <parcs> ben: didn't think of that!
14:48:29 <aristid> smoge: do you use ghc 6.6?
14:48:33 <smoge> I have ghc 7.0.2
14:48:37 <smoge> no...
14:48:41 <smoge> hint is broken?
14:48:48 <dafis> smoge: it means you don't have the library named ghc installed
14:48:54 <monochrom> hint is not broken. your ghc installation is broken again
14:49:01 <smoge> dman it
14:49:07 <smoge> any advices?
14:49:21 <monochrom> could you show us "ghc-pkg list -v" ?
14:49:25 <smoge> I did 'sudo pacman -S ghc'  just now
14:49:27 <dafis> smoge: you should be able to install it with pacman
14:49:46 <monochrom> also "ghc -v"
14:50:03 <dafis> smoge: you have to install some extras, no idea how they're called
14:50:14 <smoge> http://hpaste.org/46773/v
14:50:46 <dafis> smoge: the equivalent of apt-get search *ghc*
14:50:57 <monochrom> please rm -rf /home/smoge/.ghc/x86_64-linux-7.0.2
14:51:30 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for why
14:51:33 <smoge> http://hpaste.org/46774/pacman
14:51:56 <yellowriver> hi
14:52:11 <yellowriver> almost in every haskell resource I see this line: map f . concat = concat . map (map f)
14:52:26 <yellowriver> but I have no idea how to check tha is right
14:52:38 <yellowriver> could You please give me any hints?
14:52:59 <yellowriver> how to prove that: map f . concat = concat . map (map f)
14:53:22 <monochrom> you could try proving "map f (concat x) = concat (map (map f) x)" by induction
14:53:40 <ddarius> @free concat
14:53:41 <lambdabot> $map f . concat = concat . $map ($map f)
14:53:44 <ddarius> Done.
14:53:57 <dafis> smoge: you have the ghc library in your package-db, so it should be there, if cabal thinks it isn't, it's probably broken, ghc-pkg check
14:54:50 <monochrom> dafis, it's the lack of container in --global.
14:55:09 <dafis> monochrom: right, well spotted
14:55:19 <yellowriver> damn, sorry, my irc-client crashed
14:55:31 <yellowriver> so from definition of (.) i have map f (concat x) = concat (map (map f) x)
14:55:38 <yellowriver> right?
14:55:40 <monochrom> I don't understand why container is not in --global. the installation is broken again.
14:55:41 <dafis> @free concat
14:55:42 <lambdabot> $map f . concat = concat . $map ($map f)
14:56:04 <dafis> yellowriver: that's the proof, as given by ddarius
14:56:23 <monochrom> I'll mention induction again.
14:56:27 <monochrom> you could try proving "map f (concat x) = concat (map (map f) x)" by induction
14:56:37 <monochrom> hope this doesn't crash your irc client again
14:56:47 <hpc> heh
14:56:49 <yellowriver> ok, induction sounds better for me :)
14:56:50 <dafis> monochrom: how old-fashioned, proving things yourself
14:57:45 <yellowriver> monochrom, but from what I get map f (concat x) = concat (map (map f) x)? from definition of (.) ?
14:57:53 <monochrom> I reserve the free theorems for things even induction can't prove. such as why fst (a,b) must either diverge or give a.
14:58:00 <monochrom> yes
14:59:30 <monochrom> http://groups.google.com/group/comp.lang.haskell/msg/a1444af2476a6a53 :)
14:59:38 <yellowriver> ok, so for [] it's easy and now I gotta check, that map f (concat x:xs) = concat (map (map f) x:xs) is true
15:00:05 <yellowriver> @src map
15:00:05 <lambdabot> map _ []     = []
15:00:05 <lambdabot> map f (x:xs) = f x : map f xs
15:00:21 <yellowriver> @src concat
15:00:21 <lambdabot> concat = foldr (++) []
15:00:48 * hackagebot hsignal 0.1.3.4 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.1.3.4 (VivianMcPhail)
15:01:11 <yellowriver> err, concat (xs:xss) = xs ++ concat xss looks better
15:01:32 <dafis> monochrom: nice proof
15:02:09 <monochrom> :)
15:02:33 <dafis> yellowriver: which is exactly what you get if you unfold the foldr definition
15:03:12 <yellowriver> dafis, I see :)
15:03:55 <yellowriver> LHS     map f (x ++ concat xs) = map f (x : concat xs) = f x : map f xs
15:03:56 <yellowriver> right?
15:04:58 <dafis> yellowriver: not quite, map f (xs ++ xss), now you have to treat xs = [] and xs = y:ys
15:05:50 * hackagebot hsignal 0.1.3.5 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.1.3.5 (VivianMcPhail)
15:07:19 <yellowriver> err, I have got map f (concat (x : xs)) = map f ( x : concat xs) = map f ( x ++ xs ) = map f ( x : xs )
15:07:22 <yellowriver> what's wrong here?
15:07:46 <Cale> concat (x:xs) = x ++ concat xs
15:07:52 <Cale> not x : concat xs
15:08:08 <yellowriver> @src (:)
15:08:08 <lambdabot> Source not found. Do you think like you type?
15:08:18 <yellowriver> @src (++)
15:08:18 <lambdabot> []     ++ ys = ys
15:08:18 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:08:18 <lambdabot> -- OR
15:08:18 <lambdabot> xs ++ ys = foldr (:) ys xs
15:08:33 <djahandarie> > 1 : [2,3,4]
15:08:35 <lambdabot>   [1,2,3,4]
15:08:39 <djahandarie> > [1] ++ [2,3,4]
15:08:41 <lambdabot>   [1,2,3,4]
15:08:48 <yellowriver> imho it's the same
15:09:03 <yellowriver> > [1,2,3] : [4,5,6]
15:09:04 <lambdabot>   No instance for (GHC.Num.Num [t])
15:09:04 <lambdabot>    arising from a use of `e_1123456' at <...
15:09:05 <djahandarie> yellowriver, it's pretty clearly not the same.
15:09:08 <dafis> yellowriver: [1,2,3] ++ [4,5,6]
15:09:50 <yellowriver> err ok, see the difference
15:11:08 <yellowriver> so I got map f (x ++ concat xs) but dunno what to do next with that
15:11:30 <yellowriver> You said to treat x = [] and xs = y : ys
15:11:32 <yellowriver> but why?
15:11:35 <dafis> yellowriver: either x is [], or x = y:ys
15:11:55 <dafis> if x is [], [] ++ concat xs = concat xs
15:12:20 <dafis> if x = y:ys, (y:ys ++ concat xs) = y : (ys ++ concat xs)
15:12:22 <yellowriver> ok, so if x is [] then i got my induction hypothezis on the left, right?
15:12:53 <dafis> yellowriver: depends on how you formulated it
15:13:22 <yellowriver> ind. hyp. is map f (concat xs) = concat (map (map f) xs)
15:14:03 <dafis> hooray, building's done, now it's only a matter of hours until the testsuite's run
15:14:52 <lispy> hello
15:15:07 <dafis> yellowriver: then indeed, x = [] directly gives you that, now you just have to derive the RHS from the RHS of that
15:15:27 <lispy> [] = map f []
15:15:34 <yellowriver> wait please, I'm thinking why (y:ys ++ concat xs) = y : (ys ++ concat xs)
15:15:38 <lispy> (oh wait, I don't know what you're deriving)
15:15:55 <dafis_> hi lispy
15:15:56 <monochrom> "[] = map f []" may be useful :)
15:16:08 <dafis_> s/may/will/
15:17:22 <yellowriver> ok, so LHS:   map f ( y : ys ++ concat xs ) = map f ( y : ( ys ++ concat xs) ) )   [from definition of (++)], right?
15:17:55 <monochrom> the road to elementary proofs is torturous. there is no going back. if you need induction, use induction. if you need induction again, use induction again.
15:18:31 <lispy> monochrom: but, does that generalize? ;)
15:19:23 <monochrom> yeah, supposedly you should also generalize that to: if you see Buddha, kill Buddha. if you see Dijkstra, kill Dijkstra.
15:19:33 <yellowriver> concat (map (map f) x : xs) = concat ( (map f) x : map (map f) xs )
15:19:41 <hpc> monochrom: first you have to catch him though
15:19:41 <yellowriver> i'm not sure if it's right
15:19:49 <hpc> monochrom: and he knows the shortest paths to everywhere
15:20:00 <monochrom> haha
15:20:18 <dafis> yellowriver: missing a pair of parentheses
15:20:41 <dafis> concat (map (map f) (x : xs)) = ...
15:21:10 <dafis> hpc: but we have goto
15:21:27 <hpc> dafis: oh yes, this is true
15:21:44 <hpc> dafis: perhaps a more realistic solution would be graph reduction? he has nowhere to run if the universe is one node
15:21:48 <yellowriver> concat ( (map f) x : (map (map f)) xs )  here?
15:21:58 <dafis> hpc: :D :D
15:22:02 <hpc> :D
15:22:22 <dafis> yellowriver: that's right
15:22:30 <hpc> (this reminds me of doctor who: "where are we going?" "WE ARE LEAVING THE UNIVERSE")
15:23:16 <yellowriver> and now I have no idea what the next step should be, any hint please?
15:23:33 <yellowriver> maybe from def. of concat?
15:23:36 <roconnor> definition of concat
15:23:57 * roconnor feels like this should be done in coq or agda
15:24:19 * dafis feels that should be done with pencil and paper
15:24:28 <yellowriver> concat ( (map f) x : (map (map f)) xs ) =  ((map f) x) ++ concat ((map (map f)) xs)
15:24:30 <yellowriver> right?
15:24:31 <roconnor> dafis: sounds error prone
15:24:41 <roconnor> @src concat
15:24:41 <lambdabot> concat = foldr (++) []
15:24:44 <roconnor> pfft
15:24:53 <dafis> roconnor: remember erasers?
15:24:55 <roconnor> yellowriver: yes you are right
15:25:09 <roconnor> dafis: yes
15:25:33 <dafis> roconnor: good for treating errors in your proofs
15:25:44 * lispy used to do math homework in pen just so he had a trail of his mistakes
15:25:58 <yellowriver> but what it brings? I cannot do anything with that
15:26:00 <roconnor> dafis: not so good for finding/preventing errors
15:26:03 <lispy> The temptation to erase was too high
15:26:07 <lispy> (with pencil I mean)
15:26:16 <roconnor> yellowriver: now for the INDUCTIVE HYPOTHESIS!
15:26:26 <dafis> roconnor: for that, peer review, or tutors before that
15:26:32 <lispy> ?quote hypothesis
15:26:32 <monochrom> heh, you should use darcs or git for your math homework
15:26:32 <lambdabot> Meehl says: [The null hypothesis significance test is] a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring
15:26:43 <roconnor> dafis: also not so great at finding/preventing errors
15:26:51 <yellowriver> ((map f) x) ++ map f (concat x : xs)
15:26:54 <roconnor> though better than erasers
15:27:20 <yellowriver> err, ((map f) x) ++ map f (concat  xs)
15:27:31 <dafis> roconnor: so far, they've found errors in all proofs of the Riemann hypothesis, so there's a success story
15:28:21 <lispy> dafis: Wait, the erasers or the peer reviewers?
15:28:31 <roconnor> dafis: your samples are biased
15:28:37 <dafis> lispy: reviewers
15:28:54 <yellowriver> what next? check for x = [] or x = y:ys ?
15:28:57 <dafis> roconnor: the secret of the successful statistician
15:28:59 <c_wraith> when I was doing math in pen, I learned to keep scratch paper around for thinking, and then do a pass to make my answer neat and in the final form after I was done thinking.
15:29:19 <c_wraith> turns out copying your answers doesn't take nearly as long as thinking of them in the first place
15:29:23 <dafis> c_wraith: me too
15:29:56 <roconnor> yellowriver: what are we trying to prove again?
15:30:02 <monochrom> I do that too. it's like a graphics engine. there is a compute stage and a render stage
15:30:05 <c_wraith> especially since it frees up your initial work from needing to be in a formal form, so you can just sketch your thoughts broadly
15:30:12 <yellowriver> roconnor, map f (concat x : xs) = concat (map (map f) x:xs)
15:30:33 <roconnor> yellowriver: oh right
15:30:42 <roconnor> yellowriver: you now need the map-append lemma
15:30:55 <yellowriver> but I got, that LHS is map f ( y : ( ys ++ concat xs) ) )
15:30:56 <roconnor> do you have one laying around?
15:30:58 <jmcarthur> c_wraith: purely functional math
15:31:41 <Saizan> http://hpaste.org/46775/proof <- agda spoiler :)
15:31:44 <jmcarthur> writing in pen, that is
15:32:12 <jmcarthur> scratch paper = gc nursery
15:32:32 <jmcarthur> and it's a copy collector
15:32:45 <jmcarthur> conclusion: c_wraith is ghc
15:33:10 <yellowriver> roconnor, whagt's map-append lemma? (map f x) ++ (map f y) = map f (y : x)  ?
15:33:16 <c_wraith> I have a special time-travel device that allows me to work out answers in the infinite future and then send them back to your compiler.
15:33:35 <roconnor> @free (++)
15:33:35 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:33:35 * monochrom adds "ghc -fvia-c_wraith"
15:33:41 * roconnor sighs
15:33:53 <roconnor> yellowriver: (map f x) ++ (map f y) = map f (x ++ y)
15:35:26 <yellowriver> ok, another induction on x, right?
15:36:29 <yellowriver> RHS:   map f (x:xs ++ y) = map f (x: (xs ++ y)) = f x : map f ( xs ++ y )
15:37:47 <yellowriver> from ind. hyp. f x : ((map f xs) ++ (map f y))
15:37:49 <yellowriver> right?
15:37:59 <roconnor_> yellowriver: for this lemma I think you want to induct on y.
15:38:53 <dafis> why would some tests fail with "broken pipe" when called via the testsuite-driver, but work when invoked directly from the Makefile in their directory?
15:39:52 <yellowriver> (map f x) ++ (map f y:ys) = map f (x ++ y:ys); LHS: (map f x) ++ (f x : map f ys); right?
15:40:10 <Dr_H> hey
15:40:17 <dafis> Bueller? Anyone?
15:41:02 <chomp> +1
15:41:06 <pastorn> yellowriver: that seems correct
15:41:14 <hpc> yellowriver: that last x should be y
15:41:19 <hpc> f y : ...
15:41:27 <pastorn> right
15:41:29 <hpc> otherwise yes
15:42:25 <yellowriver> eee, that way: (map f x) ++ (f y : (map f ys))
15:42:36 <yellowriver> and there is nothing i can do with this side, right?
15:42:38 <gigamonkey> When did folks starting thinking about type systems as a way of improving program correctness?
15:42:59 <roconnor_> yellowriver: definition of (++)
15:43:10 <gigamonkey> I'm guessing that in the days of FORTRAN they were more worried about efficiency and optimization.
15:43:18 <roconnor_> oh opps
15:43:25 <cinch> does the or function (||) evaluate the left or the side operand first?
15:43:26 <roconnor_> yellowriver: sorry you are supposed to induct on x
15:43:33 <pastorn> cinch: left
15:43:34 <roconnor_> my bad
15:43:38 <roconnor_> > True || undefined
15:43:39 <lambdabot>   True
15:43:45 <yellowriver> roconnor_, np, lets try again :)
15:43:56 <roconnor_> > undefined || True
15:43:57 <lambdabot>   *Exception: Prelude.undefined
15:44:04 <chomp> gigamonkey, right around the time type safety became a salient problem in complex programs would be my guess :)
15:44:06 <cinch> roconnor_: thanks :)
15:44:47 <gigamonkey> chomp: so I'm wondering when that was. Clearly it didn't start with the invention of Haskell because there's ML which predates it. Can anyone help me push it back farther?
15:44:48 <c_wraith> gigamonkey: type systems have *always* been about correctness.  What's advanced is peoples' understanding of the types of correctness a good type system can prove at compile time.
15:45:28 <yellowriver> (map f x:xs) ++ (map f y) = map f (x:xs ++ y); RHS:  f x : map f (xs ++ y) = f x : ((map f xs) ++ (map f y)); correct?
15:45:43 <roconnor_> looks good
15:45:58 <roconnor_> now the definition of ++
15:46:10 <gigamonkey> c_wraith: if that was true, why would folks design languages that allow you to escape the static type system? (E.g. with casts.)
15:46:11 <roconnor_> er
15:46:13 <roconnor_> wait
15:46:24 <dafis> gigamonkey: people are stupid
15:46:31 <roconnor_> yellowriver: I don't think that is right
15:46:43 <jmcarthur> casts don't escape the type system. they don't create an untyped variable
15:46:45 <c_wraith> gigamonkey: because the type systems they created were not sufficient to express the ideas they wanted to
15:46:50 <chomp> i would argue that it's computers which are stupid
15:46:58 <roconnor_> (map f x:xs) ++ (map f y) = (f x : map xs) ++ (map f y) -- defition of map
15:47:01 <RichardBarrell> gigamonkey: because life is hard and occasionally bad things happen. :)
15:47:07 <dafis> gigamonkey: more seriously, a couple of escape hatches may be necessary for performance
15:47:19 <RichardBarrell> Haskell too has unsafeCoerce#, but you have to look in the deep, murky corners of GHC for it.
15:47:21 <roconnor_> f x : (map f xs ++ (map f y)) -- definition of
15:47:23 <roconnor_> f x : (map f xs ++ (map f y)) -- definition of ++
15:47:42 <roconnor_> f x : (map f (xs ++ y)) -- inductive hypothesis
15:48:04 <roconnor_> map f (x : (xs ++ y))) -- definition of map
15:48:17 <roconnor_> map f ((x : xs) ++ y)) -- definition of ++
15:48:50 <aavogt> @index unsafePerformIO
15:48:51 <lambdabot> System.IO.Unsafe, Foreign
15:48:56 <RichardBarrell> gigamonkey: occasionally it's performance as dafis says; occasionally you run into a situation where you can prove on paper that two types are equal but you can't phrase the proof in a way that your compiler can understand, so you use an escape hatch.
15:49:38 <chomp> pragmatism not idealism
15:50:02 <gigamonkey> RichardBarrell: right.
15:50:02 <gigamonkey>  Anyway, looking at this diagram http://www.digibarn.com/collections/posters/tongues/tongues.jpg ML has no predecessors. Is that really right?
15:50:48 <gigamonkey> It must have had at least some intellectual influences if not other languages--I'm trying to figure out what they were.
15:50:54 <jmcarthur> i doubt that ML was designed without any knowledge of existing languages
15:51:06 <jmcarthur> charts like that are misleading
15:51:11 <jmcarthur> s/misleading/wrong/
15:51:20 <gigamonkey> jmcarthur: no doubt.
15:51:23 <yellowriver> err, i don't get inductive hypothesis.
15:51:39 <Philippa> I suspect it was predominantly influenced by lambda calculus practice at the time, though
15:51:51 <yellowriver> nvm, got it
15:51:55 <Philippa> if anything else was using algebraic datatypes first, that's a possible influence
15:52:01 <chomp> that graph makes my eyes bleed
15:52:40 <jmcarthur> it also claims no relationship between haskell and ml whatsoever
15:52:54 <hpc> it claims haskell influenced java
15:52:54 <c_wraith> Didn't the development of Hindley-Milner type inference also predate ML, making ML one of the original proving grounds for building a real language on top of HM?
15:53:21 <RichardBarrell> Philippa: Prolog, maybe? If you use Lisp lists and symbols in the right pattern then they also resemble ADTs really strongly.
15:53:22 <gigamonkey> So basically it all starts with Church and the simply typed lambda calculus?
15:53:55 <yellowriver> ok, got the lemma :)
15:54:01 <c_wraith> gigamonkey: not at all.  Brainfuck is *clearly* derived from Turing Machines, which are a different, independently-developed, abstraction
15:54:06 <Philippa> c_wraith: it did, but only narrowly in Milner's case - and IIRC Hindley discovered it from the logic side
15:54:44 <Philippa> I don't think Fortran was originally particularly formulated in lambda calculus terms either
15:54:48 <gigamonkey> c_wraith: sorry, by "it all" I meant the statically typed programming tradition.
15:54:51 <dafis> c_wraith: what's Malbolge derived from?
15:54:54 <yellowriver> so please let's back to the main proof, RHS was ((map f) x) ++ map f (concat xs)  so from lemma it's map f (x++xs)  right?
15:54:57 <gigamonkey> Or I'm misunderstanding what Brainfuck is all about.
15:55:19 <ddarius> gigamonkey: Usually it's considered as starting with Russell.
15:55:27 <c_wraith> Philippa: still, as I understand it, ML was at least partly an experiment in "let's get this neat theoretical system into something real"
15:55:32 <jmcarthur> type theory emerged at the beginning of the 20th century
15:55:46 <jmcarthur> yeah, with russell
15:55:50 <gigamonkey> ddarius: as in Bertrand?
15:55:56 <c_wraith> yes, that Russel
15:55:59 <Philippa> c_wraith: I think the main criterion for 'real' was 'mechanized' at that point
15:56:02 <dafis> certainly not Crowe
15:56:03 <pastorn> what's up with that graph? i need a newer version with haskell' in it!
15:56:05 <RichardBarrell> dafis: Malbolge is derived from malicious intent.
15:56:13 <pastorn> also: i need haskell'
15:56:22 <jmcarthur> gigamonkey: history: http://en.wikipedia.org/wiki/Type_theory
15:58:01 <yellowriver> ok, wait a moment please, 'cos I get lost, I'll do the proof again (on the paper)
15:58:09 <gigamonkey> jmcarthur: yup, thanks.
15:58:10 <dafis> pastorn: H98 would be a nice first step
15:58:37 <pastorn> dafis: bah! it doesn't even have monad comprehensions
15:58:51 <pastorn> And what happened with haskell prime?
15:59:08 <dafis> pastorn: Haskell-1.4 then
15:59:27 <c_wraith> pastorn: it's the name of the continuing effort to release updated specs.  2010 was the first release by the Haskell' process.  (that's what they declared it to be after the fact, anyway)
15:59:37 <jmcarthur> lol "Quine dismisses this notion of 'bound variable' as 'pointless'"
15:59:46 <dafis> pastorn: H' was split int map (("Haskell" ++) . show) [2010 .. ]
15:59:49 <ezyang> +1
15:59:55 <c_wraith> @pl bound variable
15:59:55 <lambdabot> bound variable
16:00:17 <pastorn> c_wraith: oh, so there's gonna be more standards from the Haskell' effort?
16:00:31 <dafis> can't argue with that, Quine was right
16:00:40 <pastorn> I would like it if they broke some stuff for base6
16:00:56 <dafis> pastorn: what in particular?
16:00:57 <c_wraith> pastorn: their original goal was yearly, but...  Yeah, there's not going to be another one before 2012
16:00:58 <jmcarthur> pastorn: supposed to be some conservative changes every year, i think
16:00:58 <pastorn> like making either mappend or mplus to (+)
16:01:15 <Saizan> base is handled by the libraries@ proposal mechanism, not haskell'
16:01:19 <jmcarthur> i wish they would just break everything
16:01:25 <pastorn> and to have proper classes for Pointed and Monad
16:01:32 <dafis> pastorn: (+) definitely not, (++) may be
16:01:34 <pastorn> so Monad doesn't require return
16:01:41 <jmcarthur> base is ghc. haskell2010 is haskell'
16:02:01 <pastorn> dafis: class AdditiveGroup a where; (+) :: a -> a -> a; zero :: a
16:02:10 <jmcarthur> well, i think base is/was also hugs?
16:02:14 <ddarius> jmcarthur: They could replace Haskell with COBOL.  That'd probably break everything.
16:02:15 <jmcarthur> and other?
16:02:16 <Saizan> and nhc
16:02:20 <jmcarthur> yeah that's it
16:02:23 <dafis> pastorn: would break too much code :(
16:02:27 * ddarius waits for Haskell/COBOL polyglots.
16:02:34 <pastorn> dafis: i said i wanted stuff to break
16:02:52 <Philippa> ddarius: my dad's translated from COBOL to Haskell, if that counts?
16:02:57 <jmcarthur> haskell' is disappointingly conservative. it ain't gonna happen
16:03:06 <pastorn> dafis: we can't have the language becoming popular now, can we?
16:03:11 <Philippa> oh, wait, no, that was FORTRAN. COBOL was the sparse matrix library, ported from FORTRAN...
16:03:25 <pastorn> jmcarthur: :(
16:03:27 <jmcarthur> haskell is no longer a research language
16:03:30 <dafis> pastorn: it is already happening
16:03:42 <ddarius> Matrices .. represented as ISAM files!
16:03:59 <jmcarthur> ddarius++ for epic ideas
16:04:08 <Philippa> jmcarthur: the problem is as much that we've hit the point where we've accumulated enough research that you'd /really/ want a clean slate
16:04:14 <pastorn> ddarius: ISAM?
16:04:20 <Philippa> and tbh, nobody wants to do that and still call it Haskell
16:04:26 <jmcarthur> true
16:04:27 <ddarius> Why don't people already know what ISAM stands for?
16:04:57 <Philippa> Implausible Small Acronym Memory?
16:04:59 <dafis> ddarius: nobody ever told us
16:05:00 <pastorn> Philippa: let's branch! well'll call it "Alonzo"
16:05:14 <Peaker> Philippa: what kind of stuff would you clean up in the clean slate?
16:05:16 <RichardBarrell> ddarius: because it's only 15 keypresses to look it up?
16:05:19 <Philippa> jmcarthur: there's also the whole thing of waiting for the GADTs+families combo to settle down
16:05:34 <Philippa> Peaker: I'd figure out a good module/type class integration, then build out from there
16:05:46 <Philippa> I'd also do things like make n-tuples synonyms for something with more structure
16:06:02 <pastorn> Philippa: proper records?
16:06:10 <pastorn> well, good records...
16:06:36 <Philippa> pastorn: that comes under "building out from there" really - once you've figured out how to handle the module/qualified types story, extending to qualifications other than classes and equality isn't quite so tricky
16:06:44 <Peaker> Philippa: I don't feel like I'm missing modules at all :-)
16:06:48 <Philippa> though I think I'd do it mostly via a standard syntax and room for libs
16:06:57 <Philippa> Peaker: good for you
16:06:58 <RichardBarrell> Philippa: while you're writing another language, could we have the ability to write functions that work for arbitrarily-sized n-tuples rather than k-tuples?
16:07:06 <Peaker> Philippa: I see the stuff they do with modules in Agda/ML and it seems worse than equivalent type family stuff
16:07:08 <Philippa> RichardBarrell: that's what "more structure" would get you
16:07:23 <RichardBarrell> Philippa: ah, thought you meant something different by that.
16:07:44 <Peaker> Philippa: what do you mean about N-tuples having more structure?  unlifted products? I'd totally love unlifted products
16:08:00 <Peaker> (all product pattern matches being irrefutable, basically)
16:08:08 <Philippa> Peaker: I want to do that with actual modules. Even if it's mostly syntactic sugar on top of type classes, I want a story that doesn't involve explicitly encoding things that are clearly modules
16:08:39 <Philippa> because it keeps coming up in my actual code, and having to explicitly build the classes and instances and so forth? Sucks.
16:09:01 <Peaker> Philippa: It seems the syntactic overhead for modules is even bigger than type classes and instances
16:09:09 <Peaker> (and things like "Open" on modules seem like a terrible hack)
16:09:12 <Philippa> Peaker: it's not, if you're doing module things with them
16:09:25 <luite> http://jabberwock.xs4all.nl/exp/wolfgang/  <- I added a diagrams tutorial, by byorgey
16:09:39 <Philippa> which I want to, on about as regular a basis as I actually code
16:10:08 <Philippa> (and at least one of my greenspun module hacks got used by someone else in anger, which given how little code I write...)
16:10:36 <yellowriver> wow, it's working, and I understand that - thanks a lot :)
16:11:06 <pastorn> jmcarthur: what's with the nicking?
16:11:21 <jmcarthur> was just curious what the view was like from those capital letters
16:11:22 <Philippa> RichardBarrell: "more structure" would mean having them be something approximately equivalent to spine-strict type-and-term cons lists so you could indeed write on arbitrary tuple sizes if you're parametric in what's in them
16:11:28 <Peaker> Philippa: I'd love to see compelling examples.. ByteString seems like it could be close, but then I'd really prefer to make BS functions polymorphic to more than just lazy/strict BS
16:12:12 <ddarius> @google "Zip Calculus"
16:12:13 <lambdabot> http://www.cs.yale.edu/~tullsen/zip-rr.ps
16:12:30 <Philippa> Peaker: you'd just declare a few signatures for things that the ByteStrings or the Maps (or even /both/) have in common and declare that a client module's looking for one and it'd plug/play just like that - no instance definition required
16:12:30 <jmcarthur> i noticed that (quotes to prevent annoying highlighting) P'hilippa, P'eaker, and S'aizan tend to stand out more than p'hilippa, p'eaker, and s'aizan would
16:12:56 <jmcarthur> heh i guess two of the three are reading anyway
16:13:13 <Philippa> heh. Yeah. Also, on some parts of the net it makes everyone think I'm a dom instead of a sub. *shrug*
16:13:57 <Philippa> I think it depends partly on what conventions were like the first few chans you were on, y'know?
16:14:26 * ddarius started with Darius, but then Darius Bacon kept coming around.
16:14:35 <Peaker> Philippa: given my lack of actual experience with first-class modules, I don't really know how that would look like... All the examples are unfortunately in ML syntax (yechs) and usually accompanied by stuff like "Open Module;" which I find horrible
16:15:22 <Philippa> Peaker: who said anything about first-class there?
16:15:40 <Philippa> (Open is... just the let version of import, you could have import-in-let equivalently)
16:15:44 <djahandarie> ddarius, why don't you register your nick?
16:16:10 <ddarius> djahandarie: Why would I?
16:16:30 <djahandarie> To prevent others from using it.
16:16:31 <jmcarthur> so i don't steal it
16:16:39 <djahandarie> So jmcarthur doesn't steal it.
16:16:48 <ddarius> It hasn't been a problem for the last decade or so.
16:17:13 <jmcarthur> next time you get off freenode it will be :P
16:17:25 <ddarius> I'll just /nick jmcarthur.
16:17:32 <jmcarthur> mine is registered
16:17:33 <djahandarie> You can't, it's registered!
16:18:35 <shachaf> ddarius: You should go back to Darius.
16:18:50 <djahandarie> Let's not, that'll be even more confusing.
16:18:53 <shachaf> preflex: seen Darius
16:18:53 <preflex>  Darius was last seen on #haskell 1 year, 90 days, 20 hours, 41 minutes and 56 seconds ago, saying:   any ideas?
16:18:55 <Philippa> I think /one/ of the things a new-Haskell would want is a story for handling qualifications that don't have coherent evidence
16:19:06 <Philippa> or rather, where /which/ evidence is used matters
16:19:29 <Philippa> it shouldn't be obligatory to do it everywhere, because that's painful - you basically end up with the equivalent of ML modules again
16:19:33 <Peaker> Philippa: import open unqualified should be discouraged at the very least, banned ideally (at least allow a flag to ban it)
16:19:59 <Philippa> Peaker: *shrug* - yeah. It's actually better when you have signatures to open /against/, at that point
16:20:14 <Peaker> Philippa: what do you mean "open against"? Isn't open basically like an unqualified open import?
16:20:17 <Philippa> signatures are effectively "typed import lists"
16:20:38 <Philippa> open Module vs open Module::Signature
16:21:28 <Philippa> the latter, you don't get anything that isn't in Signature. And signatures have subtyping
16:21:33 <Philippa> (structural subtyping)
16:21:51 <Philippa> but, Signature doesn't have to be an inline constant - it can be defined elsewhere
16:21:56 <Peaker> Sub-typing as in a subset of the signature, or a signature that extends another signature?
16:22:05 <parcs> @hoogle <*<
16:22:05 <lambdabot> No results found
16:22:12 <Peaker> (sub-type means extension or subsetting of a signature?)
16:22:56 <Philippa> it doesn't matter, because the corresponding variance'd flip with it :-)
16:23:25 <Philippa> it does the semantically safe thing, if that's what you're worried about
16:23:53 <Peaker> open Module::Signature -- basically like an import of an import list specified somewhere?
16:23:55 <Philippa> (and give or take quibbling about the exact way of doing it, you can already do that in ML: I forget what the ML-speak for "view this module through that signature" is, but it's just another module expression)
16:24:06 <Philippa> of a /typed/ import list, yeah
16:24:15 <Philippa> signatures are approximately equivalent to type classes in that regard
16:24:26 <Philippa> (with modules as approximately equivalent to instances)
16:24:27 <Peaker> Well, it would still make name lookup for the reader horrible, without a smart IDE
16:24:37 <Saizan> sealing? the <: operator
16:24:43 <Philippa> Saizan: that's the one
16:25:04 <Philippa> Peaker: Boo hoo. The signature got named somewhere
16:25:36 <Peaker> Philippa: well, if banning everything but closed unqualified/qualified imports, I can just reverse-search a name in the same file, and figure out where it comes from
16:25:55 <ddarius> Aren't you all about smart IDEs anyway?
16:26:07 <Peaker> Also, there's a safety issue regarding name additions to the signatures you're importing
16:26:10 <Philippa> yeah, so code that way if you want or write the preprocessor
16:26:17 <Peaker> ddarius: They don't exist YET :-)
16:26:42 <Philippa> Peaker: just have a compiler warning when imports shadow, BFD
16:26:58 <Philippa> or use the same rule as you do at top-level
16:27:00 <aavogt> it isn't too difficult to ask the ghci where names come from
16:27:17 <Peaker> Philippa: what do you mean? What if I opened two unrelated signatures, and later on, one of them adds a name that I used from the other?
16:27:26 <Peaker> Philippa: that would break the compilation with an ambiguous name resolution
16:27:28 <Philippa> aavogt: quite, and the stronger the module system the more likely you are to run a 'dynamic' environment where that sort of stuff's more natural
16:27:59 <Philippa> Peaker: zomg! Yeah, and one sed command later it's all fixed. This isn't world-breaking
16:28:19 <Philippa> Signature changes already have the right to fuck you over
16:28:28 <Peaker> Philippa: well, it's nice to be able to "cabal install" stuff without figuring out which names were supposed to be used and sed'ing some other author's packages
16:28:46 <Peaker> Philippa: you cannot be fucked by new names if you import qualified/closed-unqualified
16:28:57 <Philippa> so adopt that standard on release. I don't see why I should have to do the same when I'm writing a five-liner script
16:29:35 <Peaker> Yeah, that's what I meant by some flag (ideally mandated by cabal-install) that disallows namespace pollution from third party signatures
16:29:56 <Peaker> I'm OK with such a flag being turned off for quick&dirty stuff (until we have good IDE's that make it moot)
16:30:05 <Philippa> a warning flag is fine, banning more widely not so much
16:30:33 <Peaker> I think the main mess in Haskell is the stdlibs
16:31:07 <Philippa> well yeah. I mean, we don't even have a standard set of greenspun extensible records! :-)
16:31:08 <Peaker> Haskell has some of the most powerful support for polymorphism, yet less polymorphism in its stdlibs than .. Java
16:31:49 <Peaker> Java/.NET people have even learned as a general rule "code to an interface, not to an implementation", but in Haskell it is still very customary to code to specific data types
16:32:00 <Philippa> yeah. You know why that is?
16:32:12 <Philippa> it's because the module system sucks and encoding it via type classes is painful
16:32:14 <Peaker> Well, immutability makes conversions more commonly possible
16:32:26 <RichardBarrell> Peaker: have to say, I'm pretty happy with Python's choices about names in import statements. "import foo from bar; foo()" and "import bar; bar.foo()". (The interpreter will let you have "import * from bar; foo();" but the community will eat your bones.)
16:32:27 <Peaker> There's no reason to code to IMaybe interface rather than Maybe..
16:32:36 <Peaker> But there IS a reason to code to containers' interfaces/etc
16:33:04 <Philippa> depends what exact interface for Maybe you'd be using, there
16:33:05 <RichardBarrell> Peaker: I think that it works for Python mainly because you can import just the constructors for relevant object types, and the messages that you can send to those objects don't need to be imported at all.
16:33:06 <Peaker> RichardBarrell: yeah, I prefer Python's import syntax as well
16:33:13 <Philippa> *cough*MonadError*cough*
16:33:17 <ddarius> Laziness also makes data structures more like control structures, so writing a list consuming function is much like writing against an IEnumerable, but I agree with you overall.
16:33:22 <Philippa> that's a repeated lesson of the standard libraries
16:33:23 * monochrom may code to IMonad
16:33:35 <Peaker> @src MonadError
16:33:35 <lambdabot> class (Monad m) => MonadError e m | m -> e where
16:33:35 <lambdabot>     throwError :: e -> m a
16:33:35 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
16:33:46 <Peaker> Philippa: well, reverse conversion (maybe throwError return) is easy, too
16:33:54 <Philippa> the standards make tolerable substitutes for many, many things but usually we only want to use a limited interface that they happen to implement in any given context
16:34:09 <jmcarthur> @src Maybe catchError
16:34:09 <lambdabot> Source not found. :(
16:35:07 <Philippa> sure, worker/wrapper etc etc etc. Knowing which interface you're pulling that along is really critical for tricks like that
16:35:15 <Peaker> ddarius: yeah, but converting things to lists just so you can do stuff like "length" to them is awful
16:35:39 <Peaker> ddarius: IEnumerable has Count(), which can be efficient, iirc
16:35:47 <Philippa> Peaker: eh, if it fuses it's kinda beautiful actually
16:35:54 <Peaker> the Haskell stdlib also has terrible names like "init"
16:36:05 <jmcarthur> Philippa: unless the container already stores its own length
16:36:18 <Philippa> jmcarthur: true
16:36:41 <Peaker> I wonder if you could write a rewrite rule, for Data.Map, for example:   length . toList -> Map.length
16:36:55 <jmcarthur> sure you could
16:37:10 <jmcarthur> the problem with rewrite rules is that they require foresight
16:37:25 <jmcarthur> and sometimes knowledge about how the optimizer actually works (in order to use well, at least)
16:37:37 <Philippa> so yeah, it's obvious the Haskell standard libs... aren't for software engineering. At all.
16:37:39 <ddarius> IEnumerable shouldn't have a Count method.  C#'s doesn't.  It doesn't make sense to as an enumerator may be unbounded.
16:37:49 <Peaker> how "smart" are rewrite rules? Would they fire if the toList result is stored in an intermediate thing?   Are there rewrite rules like:   length . map f --> length?  Will then length . map f . toList  (all intermediate results stored in variables) condense too?
16:38:17 <Philippa> tradeoff: our error messages still kinda suck in those circumstances
16:38:30 <Peaker> ddarius: It makes sense as _|_ in that case, perhaps, just like length on unbounded lists?
16:38:32 <Saizan> lots of Java's interfaces always felt horrible to me because of all those "optional" methods
16:38:46 <Saizan> wrt Count
16:39:00 <ddarius> Peaker: Yes, and if you write your own length against IEnumerable, it too will loop forever.
16:39:22 <jmcarthur> Peaker: our rewrite rules aren't terribly smart, but i think the existing fusion rules already catch length . map f
16:40:23 <Peaker> jmcarthur: are fusion rules not rewrite rules?
16:40:35 <jmcarthur> well they are, but they aren't as specific as the one you proposed
16:40:56 <Peaker> surely there are many conflicting rewrite rules GHC could choose -- how does it choose them?
16:40:59 <jmcarthur> they rely on the library being written in a particular way so that certain rewrite rules expose more optimization opportunities
16:41:23 <jmcarthur> well, rewrite rules can be given phase hints of course. i think aside from that it is considered undefined
16:41:39 <jmcarthur> although i sure there are some heuristics for it
16:41:42 <jmcarthur> not just random
16:42:49 <RichardBarrell> Peaker: AIUI, the system for rewrite rules is pretty "dumb". Rules get run either before or after each of the inlining stages and they're just pattern matches, GHC runs all of the available rewrite rules until no more apply.
16:42:50 <jmcarthur> rewrite rules also interact nontrivially with inlining
16:43:39 <RichardBarrell> Peaker: GHC does *not* prevent you from writing a rewrite from (foo -> bar) and another (bar -> foo) and causing an infinite loop that way.
16:44:41 <RichardBarrell> Peaker: you can configure exactly which of the inlining stages a given rewrite rule will be attempted before and after, too (at least that was the situation when I last looked, which was around GHC-6.6 or 6.8).
16:46:11 <RichardBarrell> You need a lot of understanding of GHC's guts in order to be able to work out in advance which stages you *should* pick, but eh whatever you can determine what works and what doesn't by experimentation. :)
16:46:11 <Peaker> There's so much more that could be done in a pure language
16:46:33 <jmcarthur> supercompilation!
16:46:42 <Peaker> I never understood what that was supposed to mean :)
16:46:56 <Peaker> I understand partial evaluation being a particular thing within supercompilation?
16:47:12 <jmcarthur> some supercompilers work by partial evaluation, but i don't think all require it
16:47:36 <RichardBarrell> I thought that supercompilation specifically referred to exhaustive searches of parts of the solution space.
16:47:37 <jmcarthur> to be honest, i know some of the things supercompilation can do, but not how to define the idea itself
16:48:21 <jmcarthur> oftentime it involves partial evaluation with detecting expressions that have been evaluated already and sharing them, having the effect of fusing loops without particular fusion rules and things like that
16:48:23 <RichardBarrell> Or is it just a general term for writing compilers that run many times slower but produce code that is slightly faster than anything commercially viable? Things like Stalin Scheme.
16:48:32 <Dr_H> how much simpler do you think function composition could be if there were a bash- or perl-like pipe operator in Haskell?
16:48:40 <jmcarthur> no simpler at all
16:48:44 <mauke> I saw this SPJ talk where he said supercompilation is about specializing all functions everywhere
16:49:05 <mauke> Dr_H: what's a perl-like pipe operator?
16:49:18 <Dr_H> forget it, it was a typo
16:49:23 <Dr_H> bash, I meant
16:49:25 <jmcarthur> Dr_H: in what sense would you hope it would be simpler?
16:49:48 <Dr_H> jmcarthur: to make the code more comprehendable and readable
16:49:56 <jmcarthur> you mean syntactically?
16:50:00 <jmcarthur> :t (>>>)
16:50:00 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:50:15 <jmcarthur> i'm guessing you just mean reverse the argument order, in which case there you go ^^
16:50:16 <Peaker> mauke: specializing everything that can be specialized sounds sort of like a generalization of partial evaluation
16:50:43 <conal> oh dear, i've forgotten again. with ghc on a mac, what's the magic remedy for link failures involving iconv ?
16:50:44 <RichardBarrell> Bash's "|" is like Haskell's ".", but with the arguments the other way around and only for functions of type (ByteString -> ByteString).
16:50:44 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:50:45 <Dr_H> jmcarthur: like this: fact0 = flip =<< (*) | fix (flip . (. subtract 1))
16:51:16 <jmcarthur> completely lazy evaluation can specialize more than supercompilation can since it can do so dynamically (which includes specializing for things not known until runtime)
16:51:41 <jmcarthur> Dr_H: i have no idea how to parse that
16:52:33 <ddarius> Forms of supercompilation subsume partial evaluation.
16:53:03 <ddarius> (Also, "supercompilation" is short for "supervised compilation.")
16:53:08 * geheimdienst has always thought that for the shell's "cat | grep", haskell has "grep . cat"
16:53:30 <jmcarthur> ddarius: supervised in the sense of a human supervisor?
16:54:30 <Peaker> RichardBarrell: not pure ByteString... more like Enumeratees
16:54:56 <RichardBarrell> Peaker: I meant Data.ByteString.Lazy?
16:55:19 <Peaker> RichardBarrell: with unsafeInterleaveIO?   Nah, unix pipes don't suck that bad :)
16:55:30 <ddarius> jmcarthur: No.  The idea came out of AI research.  The idea was the compiler would reflect upon what it was doing.
16:55:34 <Peaker> unsafeInterleaveIO is a mistake...
16:55:37 <Dr_H> jmcarthur: think of (*) as a 2-ary g function: if it gets 3 arguments, it returns (g(x1, x2), x1)
16:55:51 <Dr_H> jmcarthur: think of (*) as a 2-ary g function: if it gets 3 arguments, it returns (g(x1, x2), x3)
16:55:56 <xplat> roconnor: you can still do that with unsafePerformIO :)
16:56:11 <xplat> er, nevermind, that was 5 hours old :O
16:57:03 <jmcarthur> @unpl flip =<< (*)
16:57:03 <lambdabot> ((*) >>= \ a b c -> a c b)
16:57:10 <RichardBarrell> Peaker: well, if we're going into it then I also glossed over a buncha details like the fact that bash's "|" operator runs the left and right hand sides of the pipeline concurrently.
16:57:11 <Dr_H> jmcarthur: and then fix (flip . (. subtract 1)) would get two arguments: g(x1, x2) and x3 from flip =<< g
16:57:16 <parcs> @type flip =<< (*)
16:57:17 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
16:57:17 <lambdabot>     Probable cause: `*' is applied to too few arguments
16:57:17 <lambdabot>     In the second argument of `(=<<)', namely `(*)'
16:57:19 <parcs> hmmm
16:57:47 <jmcarthur> @unpl fix (flip . (. subtract 1))
16:57:47 <lambdabot> fix (\ g b c -> g (subtract 1 c) b)
16:57:57 <Dr_H> RichardBarrell: concurrently?
16:58:11 <jmcarthur> yes concurrently
16:58:25 <conal> lispy: ping
16:59:20 <Peaker> RichardBarrell: well, enumeratees do so too, though not in parallel
16:59:20 <Dr_H> RichardBarrell: then how about this: head -n 1 `file.txt` | echo - ; the part before the pipe needs to be executed before its value is passed to the part after the pipe
16:59:50 <RichardBarrell> Dr_H: If you run "cat foo.txt | grep bar" then bash will start both the 'cat' process and the 'grep' process and wait for both of them. I said 'concurrently' rather than 'in parallel' because you don't _necessarily_ gain any parallelism this way.
17:00:26 <RichardBarrell> Firstly, "echo -" in bash actually echoes a "-" character on a line by itself.
17:00:45 <Dr_H> RichardBarrell: thank you, now I see what you meant. I don't want to gain any parallelism, I just want to make a more readable tacit code using the philosophy of | and -
17:00:59 <RichardBarrell> Secondly, just because there's a data dependency between two processes in a pipeline doesn't mean that they aren't running concurrently - you'll just have one blocked waiting for data from the other one for some proportion of the time.
17:01:05 <jmcarthur> haskell already has (.) though
17:01:13 <jmcarthur> and you could just use (>>>)
17:01:49 <RichardBarrell> (.) is much more idiomatic for Haskell. (>>>) is just as good for Haskell assuming that everybody loves Control.Arrow (and who doesn't? COMMIES, THAT'S WHO! GET THEM!)
17:01:52 <mm_freak> what's the state of the art for testing haskell programs?  i need both pure and IO
17:01:54 <lispy> conal: hi
17:02:16 <conal> lispy: nm. i'm emailing you.
17:02:21 <lispy> okay
17:02:42 <mm_freak> i know about quickcheck and hunit, but there are also other alternatives
17:02:46 <RichardBarrell> I love using IRC to tell people that I have sent them email.
17:03:09 <RichardBarrell> It makes me feel warm and fuzzy and redundant and old fashioned and a little bit redundant.
17:03:18 <lispy> conal: Your second email mirrors my own thoughts, BTW.  I would like to improve the situation.  I'm leaning towards making a purely Haskell implementation of GLUT as being the best long-term solution.
17:03:21 <ddarius> I love sending 3MB PDF files over IRC.
17:03:44 <dafis> Thirdly, you can't pipe into echo
17:03:59 <conal> lispy: of GLUT rather than GLFW or SDL?
17:04:20 <RichardBarrell> ddarius: if you can actually get DCC working, that's actually faster than email.
17:04:37 <lispy> conal: I picked glut in that sentence as representative member of an equivalence class :)
17:04:41 <aristid> ddarius: HTTP is for weaklings.
17:04:53 <conal> lispy: ah :)
17:05:19 <RichardBarrell> ddarius: Because there exist mail daemons which aren't 8-bit-clean, and which have bizarre limitations on line lengths, everyone sends email attachments _base64-encoded_, so they inflate in size by 33%.
17:05:30 <ddarius> DCC isn't IRC.
17:05:56 <RichardBarrell> IRC clients' DCC mechanisms just send the bytes directly to the other person, though. 33% more victory per byte!
17:06:09 <jmcarthur> lispy: i also think that would be pretty awesome
17:06:24 <RichardBarrell> *33% more byte per byte than the next leading competitor!
17:07:10 <lispy> jmcarthur: osx would be the trickies of the platforms, I think.  But only because using Objective-C APIs might pose a problem.  Perhaps we can use the carbon API to dance around that.
17:07:55 <jmcarthur> lispy: well, every obj-c method is accessible via c, isn't it? ;)
17:08:13 <RichardBarrell> lispy: I thought that there was documentation for how to call the obj-c dispatch mechanism directly from ANSI-C?
17:08:15 <conal> lispy: i'm trying out nehe-tuts. they compile & run okay but fail in ghci, giving "Loading package GLFW-b-0.0.2.5 ... can't load .so/.DLL for: glfw (dlopen(libglfw.dylib, 9): image not found)".
17:08:44 <lispy> RichardBarrell: Oh.  That would be nice.  I admit, I'm a bit undereducated with respect to OSX dev
17:08:56 <jmcarthur> i've done it before for the sdl bindings
17:09:37 <lispy> conal: Yes.  That's due to a bug in the GLFW-b package.  It's in the issue tracker on github but I've been too lazy (busy?) to read up on the proper fix.  It should be a matter of improving the Makefile.
17:09:46 <jmcarthur> had to have a C main because sdl liked to call it directly from its *own* main (ugh), and i had to set up some obj-c stuff from that, but i wanted it in straight C so ghc could compile it itself
17:10:07 <mm_freak> what exactly is a free functor and how does it relate to monads?
17:10:17 <lispy> conal: the naive way of doing it produced a situation where things wouldn't link under normal compilation
17:11:09 <conal> lispy: ah, bummer. i need compatibility with ghci, since i experiment a lot, and my graphics & gui apps are usually half-liners.
17:11:32 <lispy> conal: Sure and it's 100% achievable.  We just need to tweak the build scripts to support it.
17:11:40 <lispy> conal: GLFW itself shouldn't have any issues
17:12:02 <conal> lispy: i see. so maybe we're close.
17:12:07 <lispy> (and if it does, then see my other point about writing this from scratch in Haskell :)
17:12:25 <lispy> I think we're very close
17:13:37 <conal> lispy: wch Makefile do you mean?
17:13:41 <conal> (which)
17:13:49 <conal> (emacs abbrev)
17:13:53 <lispy> conal: do you have clone of the git repo?
17:14:02 <mm_freak> strange
17:14:13 <lispy> conal: https://github.com/bsl/GLFW-b/blob/master/Makefile
17:14:23 <conal> lispy: thx. i'll grab it
17:14:54 <lispy> conal: So, this line is buggy: GLFW_FLAG := -m32 -O2 -Iglfw/include -Iglfw/lib -Iglfw/lib/cocoa $(CFLAGS)
17:15:05 <lispy> conal: we need that -m32 to be a -m64 in some cases.
17:15:11 <mm_freak> i always found that when i ask a CT question, half of the channel responds and engages in heatet discussions, but if i ask a real world-relevant question, nobody seems to care =)
17:15:27 <mm_freak> but today even my CT question was ignoredâ€¦  today must be an imperative day
17:15:32 <lispy> heh
17:16:30 <Dr_H> RichardBarrell: compare f = flip =<< g | fix (flip . (. h)) with f = fix ((`ap` g) . ((.) .) . (. h)); which one looks readable?
17:16:47 <lispy> conal: what you need for ghci is the commented out dylib.  Having it in there creates a situation where OSX assumes that the dylib will always be used from the path it was created at.  Cabal/ghci can't tolerate that assumption.
17:17:08 <RichardBarrell> Dr_H: neither. Put some points in.
17:17:36 <hpc> :t \g -> flip =<< g
17:17:36 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> f (a -> b)) -> a -> f b
17:17:48 <RichardBarrell> Dr_H: and stop leaning so hard on the Monad (a ->) instance, it's difficult to read.
17:17:56 <hpc> @src (->) (>>=)
17:17:56 <lambdabot> f >>= k = \ r -> k (f r) r
17:17:59 <RichardBarrell> Dr_H: (personal tastes may vary)
17:18:42 <hpc> :t fmap fmap fmap
17:18:42 <conal> lispy: hrmf. i'm afraid i don't understand these issues.
17:18:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:18:52 <hpc> :t (<=<)
17:18:53 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
17:19:20 <lispy> conal: Do you want me to explain more?
17:21:03 <conal> lispy: for now, i'd rather find someone else who does understand the issues to fix the problem.
17:21:25 <lispy> conal: Fair enough.  I suspected that might be the case :)
17:21:54 <conal> lispy: these system issues eat my ram fast!
17:22:06 <lispy> conal: The earliest I can take a stab at it is in early June :(
17:22:47 <lispy> The issue is not deep, but it requires a bit of reading and experimentation to find the right settings.
17:23:28 <conal> lispy: i'll reply on the haskell-cafe thread, and maybe someone will offer to help.
17:24:08 <lispy> conal: That sounds good to me!  I added the OSX support and I'd love to crowd source the ghci support :)
17:24:41 <conal> lispy: okay. it's a plan. thanks.
17:24:48 <lispy> you're welcome
17:26:47 <parcs> we need a way to install binary versions of cabal packages
17:27:22 <dons> hmm.
17:27:23 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:27:30 <dons> that would be a multi-arch, multi-os distribution system
17:27:34 <dons> somewhat tricky to do right
17:28:31 <ddarius> dons: Just make the Haskell VM.
17:28:59 <aavogt> besides gtk2hs packages, which are really slow to build?
17:29:02 <parcs> i dont think it would be that tricky
17:29:15 <lispy> dons: book is on your desk.  Will you be in tomorrow?
17:29:45 <lispy> parcs: what do we gain from having binary packages?
17:30:04 <parcs> convenience, i guess
17:30:09 <ezyang> Huh, vacuum doesn't detect thunks? Lame!
17:30:12 <dankna> not much, considering they'd be compatible only with a single version of ghc
17:30:22 <parcs> some things take _really_ long to build, especially with split-objs
17:30:46 <dankna> the longest build time I've run into is the OpenGL-related packages, which take about ten minutes, yes
17:31:42 <lispy> dankna: snap is very slow
17:31:45 <lispy> and darcs isn't fast
17:31:50 <dankna> hmm okay
17:31:56 <lispy> (i mean the build times of course)
17:31:58 <dankna> right
17:33:44 <dons> parcs: how many platforms do we support?
17:33:57 <dons> and how do we force the end users to all have the same (C library) dependencies
17:34:19 <dons> i think this is really hard: you're building a Debian, that runs on Linux, Windows and Mac. Never been done before.
17:34:23 <Dr_H> bye now
17:34:27 <dankna> yeah.
17:34:55 <dons> easier: port apt-get to windows and mac, and improve cabal2deb :)
17:35:01 <parcs> i guess all libraries with an external dependency would simply lack a binary package
17:35:13 <dankna> porting apt-get has been done but isn't really satisfactory
17:35:20 <dons> parcs: ah, now that's easier. so we'd build ghc-os-arch combinations?
17:35:38 <parcs> yeah
17:35:40 <dons> since each build is tied to a version of ghc, a version of all the C ABI hashes, the arch, and the OS.
17:35:41 <dankna> because it doesn't integrate with the various native install systems
17:36:05 <dons> so libgmp, pthreads (and the other C libs that everything depends on )
17:36:12 <dons> that's slightly more doable. since we do that for ghc already
17:36:45 <dons> how do you handle rebuilds?
17:36:58 <dons> when someone uploads a new version of a package, do you rebuild everything that depends on the old version?
17:37:06 <dons> and then that whole tree is pushed to the user's machine?
17:37:22 <dons> sort of a live 'git pull' for your haskell environment
17:37:25 * hackagebot hstatistics 0.2.2.8 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.2.8 (VivianMcPhail)
17:37:46 <dankna> and what if you have A depending on B depending on C; a new C is uploaded and rebuilt, then B is rebuilt, then A tries to rebuild but fails.
17:38:15 <dons> yes, things will break no matter what. so that needs to be handled gracefully
17:38:26 <dons> the only thing i think that can work, we already do: binary builds for the core platform of libs
17:38:37 <dons> based on stable versions that are specified, not snapshots
17:38:39 <dankna> yeah, a "blessed set" of recommended libraries
17:38:53 <dankna> in principle we could have a much larger set of libraries
17:39:02 <dons> right. and we will get there.
17:39:05 <dankna> still basing it, as you say, on versions that we've tested
17:39:06 <dankna> yeah
17:40:44 <aristid> if i install a new package, and cabal automatically recompiled everything that depends on it (maybe not by default, but as an option), that might be useful
17:40:53 <aristid> -new+updated
17:46:06 <ashp> I've never written a bit of Haskell in my life but my boss wanted me to compare some internal ldap data against some data provided by an external system (via REST) - I was wondering, is there any decent libraries to do REST queries?
17:46:18 <ashp> It seemed like an interesting challenge for a first bit of haskell but I don't want to reinvent wheels
17:47:27 <aristid> ashp: http-enumerator or HTTP might be good packages for this. the former is slightly harder to use, but also supports SSL and streaming
17:47:59 <ashp> aristid: I'll go take a look, thanks.  I found an ldap package as well so the two major pieces should be there to build upon
17:48:17 <ashp> considering I can't really program with non-functional languages either it should be quite a challenge ;)
17:48:41 <aristid> well :D
17:49:04 <ashp> I don't have too many bad habits to break, I suppose, as one good thing about being useless
17:50:11 <ashp> So far from an outsider pov I am horrified by the lack of documentation for libraries, both things I need to use have zero docs :)
17:50:43 <aristid> not true
17:50:50 <aristid> http-enumerator at least does have docs
17:51:02 <ashp> Oh ok, I found a README that was blank so far
17:51:13 <aristid> http://hackage.haskell.org/packages/archive/http-enumerator/0.6.5/doc/html/Network-HTTP-Enumerator.html
17:51:46 <ashp> Oh, aha, I managed to get to the github instead, thanks again - some bedtime reading!
17:52:06 <aristid> if you want to install the documentation with cabal, use cabal install http-enumerator --enable-documentation
17:54:00 <ashp> will give it a shot :)
18:04:39 * hackagebot hstatistics 0.2.2.9 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.2.9 (VivianMcPhail)
18:05:11 <ezyang> I'm having trouble getting GHC to tell me strictness information about functions. It should be in --show-iface, right?
18:06:38 <dafis> ezyang: if that hasn't changed, what would surprise me
18:06:56 <dafis> but of course, only when compiled with optimisations
18:07:01 <ezyang> Oh duh, need optimisations.
18:07:16 <dafis> strictness analyser doesn't run without
18:10:34 <ezyang> Huh, confused. Apparently a parameter of type Int# can be lazy?
18:10:43 <jmcarthur> o_O
18:10:49 <Axman6> that sounds very unlikely
18:11:12 <dafis> f :: Int# -> Int# -> Int#; f x y = x
18:11:13 <jmcarthur> maybe it just means that the Int# doesn't need to be forced (as it must be evaluated already or it wouldn't exist)
18:11:22 <ezyang> [Arity 2  NoCafRefs  Str: DmdType SL] Main.$wf =   \ (w_suG :: [GHC.Integer.Type.Integer])     (ww_suJ :: GHC.Prim.Int#) ->
18:11:48 <ezyang> that seems more plausible, though in that case it should say P, no?
18:11:54 * jmcarthur shrugs
18:13:04 <jmcarthur> i actually don't know how core tells you something is lazy or strict. where would be P be?
18:13:07 <dafis> I never understood the strictness info, I always have to look at the core to see what's going on
18:13:27 <jmcarthur> err, oh is that --show-iface stuff?
18:13:43 <ezyang> yeah, should be DmdType SL
18:13:50 <ezyang> guess it's time to consult the source.
18:15:58 <ezyang> Well, it looks like the docs are out of date on account of P.
18:16:48 <dafis> ezyang: how can you tell?
18:17:47 <ezyang> I looked at the printing function for demand types, and there was no code for outputting 'P'.
18:18:03 <dafis> oh, that's pretty conclusive
18:18:05 <ezyang> I then double checked by looking to see if it ever did output P
18:18:11 <ezyang> and indeed, the old strictness analyzer did.
18:19:20 <dafis> potential bug, you should ask HQ about it
18:19:48 <ezyang> done.
18:20:15 <dafis>  #ghc or a ticket?
18:21:11 <ezyang> tix
18:21:19 <dafis> ?
18:21:31 <ezyang> ticket
18:22:16 <dafis> added to cc
18:24:40 <dankna> http://hpaste.org/46779/can_this_be_written_as_a_fold -- I tried this a couple ways but confused myself, I'm sure it's very simple.  Any ideas?
18:25:06 <jmcarthur> dankna: what to do in the empty list case?
18:25:11 <jmcarthur> error?
18:25:22 <dankna> jmcarthur: yes.
18:25:57 <dankna> (because this is compile-time code, the error will prevent compilation from proceeding, which is what I want)
18:26:24 <dankna> (so I don't feel that leaving it an error is quite as big a deal as it would be if the failure were pushed to runtime)
18:26:59 <jmcarthur> foldr1 $ AppT . AppT ArrowT   -- i think
18:27:05 <dankna> hmm
18:27:07 <Axman6> :t foldr1
18:27:07 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:27:12 <dankna> will test it out, thanks
18:27:27 <Axman6> yeah i was thinking of that, but i was unaware foldr1 existed =)
18:30:00 <dankna> that worked, thank you
18:30:11 <jmcarthur> np
18:31:08 <Luke> anyone know of a good way to go from epoch millis to UTCTime data type?
18:32:05 <aristid> Luke: Data.Time.Clock.POSIX module
18:32:51 <aristid> @hoogle posixSecondsToUTCTime
18:32:52 <lambdabot> Data.Time.Clock.POSIX posixSecondsToUTCTime :: POSIXTime -> UTCTime
18:33:50 <Luke> just seconds?
18:34:06 <Luke> i need millis - possibly more if available
18:34:52 <aristid> Luke: NominalDiffTime has sub-second precision
18:35:00 <aristid> i think picoseconds are the precision
18:35:02 <Luke> ah awesome
18:35:06 <Luke> thanks so much
18:35:14 <Luke> i would never have caught that
18:35:41 <aristid> but when you know it, it seems pretty obvious, doesn't it? after the fact, things look different :)
18:35:53 <Luke> yeah totally
18:36:05 <Luke> i've been googling all day too =)
18:36:18 <Luke> thanks so much
18:36:32 <Jafet> Data.Time may be obvious, but never pretty
18:37:19 <Luke> yeah it totally supports picos
18:43:53 <aristid> Luke: which is hopefully good enough _for now_ :)
18:45:09 <Luke> what's the standard way to convert to a POSIX time? I don't see any NominalDiffTime constructors exposed
18:46:10 <aristid> POSIXTime IS NominalDiffTime
18:46:16 <Luke> oh i just coerce it
18:46:18 <aristid> it's a type synonym
18:46:24 <aristid> no, you don't need to coerce it
18:46:29 <Luke> i didn't know how to get to a nominaldifftime
18:46:41 <Luke> I'm doing " 234234 :: NominalDiffTime"
18:46:44 <Luke> seems to work
18:46:48 <aristid> Data.Time.Clock.POSIX.utcTimeToPOSIXSeconds
18:47:03 <aristid> right, NominalDiffTime is an instance of Num
18:51:24 <Peaker> I wonder if the "better preludes" and Num classes have a notion of "absolute" and "relative".  Example use: A relative time type which you can multiple against a scalar, add with each other, subtract, etc. And an absolute time, which can only be added to relative times. Can subtract abs times, but it yields relative times.
18:51:45 <ddarius> We clearly should have a Torsor class.  Possibly two.
18:52:04 <dankna> heh
18:52:22 * dafis is tired and read that as Tonsor first
18:52:30 <Peaker> what's a torsor
18:52:33 <Jafet> Affine?
18:52:59 <ddarius> Peaker: It's a G-Set equipped with a "subtraction" or "division" that takes elements of the G-Set to the group G.
18:53:14 <ddarius> E.g. (-) :: Point -> Point -> Vector
18:53:48 <ddarius> Points a G-Set with respect to vectors via translation.
18:55:05 <ddarius> The obvious law is that (p1 - p2) + p2 = p1
18:55:42 <aristid> so there's also a (+) :: Point -> Vector -> Point in that class?
18:56:06 <ddarius> aristid: No, (+) is the action of the G-Set, i.e. what makes the set (Point) a G-Set.
18:58:13 <dolio> They help you write ray tracers in C++.
18:58:24 <Peaker> ddarius: what is the type of (+) you applied there?
18:58:35 <ddarius> Vector -> Point -> Point
18:59:05 <skierscott> Anyone out there?
18:59:49 <ddarius> A group action (i.e. a G-Set) is a group homomorphism G -> Endo(X) (so X is a G-Set).
19:00:03 <Peaker> ddarius: and can you multiple a vector by a scalar?
19:00:16 <ddarius> Peaker: Yes, but that structure isn't relevant here.
19:00:16 <aristid> Peaker: it's a G-Set
19:04:25 <aristid> @hackage JsonGrammar
19:04:26 <lambdabot> http://hackage.haskell.org/package/JsonGrammar
19:07:51 <ddarius> dolio: I had one torsor related type error, albeit, since I had just declared the variable incorrectly, it would have been fine had I used a less refined approach.
19:08:34 <dolio> How's the thing coming, by the way?
19:08:50 <Peaker> Axman6: I struggled with poor explanations of Fourier transforms for about a day or even two until I figure out how simple it was.. I think I might have an even easier explanation than his :)
19:10:08 <jmcarthur> Peaker: the vectorspace package has an AffineSpace class (re: relative and absolute)
19:10:25 <Peaker> jmcarthur: ah, but Num really ought to be fixed
19:10:32 <jmcarthur> of course
19:11:00 <Peaker> pattern-matching being Eq on nums is such a quirk.. useful for toy examples to show people "hey, look how cool pattern matching is" when it's in fact a lie to children
19:11:12 <Peaker> and the resulting Eq super-class, bah
19:11:43 <ddarius> Peaker: What's your easy explanation of Fourier transforms?
19:12:07 <ddarius> dolio: The past few weeks have been me most reading vast quantities of literature on Gaussian processes and how to efficiently use them.
19:12:33 <Axman6> Peaker: i somewhat understood them intuitively and could sort of see how they work, but that explanation makes the complex part make a lot more sense
19:13:02 <Peaker> Axman6: complex as in real/imaginary, or complex as in complicated?
19:13:08 <Axman6> the former
19:13:10 <ddarius> Which explanation are we talking about?
19:13:35 <Axman6> http://www.reddit.com/r/programming/comments/hdcn7/understanding_the_fourier_transform_a_clear/
19:18:16 <ddarius> dolio: I do think I've found an approach that would work, but I don't know that it would be any faster than, say, MLT, except that it would require less rays to be cast.
19:18:46 <dolio> Believe it or not, I know almost nothing about ray tracing.
19:19:11 <ivanm> dolio: what you do is, you get some tracing paper and carefully place it over the ray you want to trace...
19:19:12 <ivanm> :p
19:19:46 <dolio> Somehow I ran out of interest in graphics stuff a lot earlier than most computer enthusiasts, I think.
19:20:04 <ivanm> I dont' think I was ever really into graphics stuff
19:20:11 <ivanm> the closest I get is trying to visualise graphs
19:20:40 * ivanm glares meaningfully at Graphviz' seeming reluctance to draw planar graphs without edge crossings
19:29:24 <Peaker> ddarius: My explanation (wording it at 5am now, can probably be worded better, formatted, etc): http://hpaste.org/46780/dft_explanation  -- it turned out longer/more-complicated than I remember, but I still think it is simple :)
19:29:51 <Peaker> I think the cis() representation is much easier than the:  e^i*2*pi*...
19:32:01 <ivanm> @hoogle trace
19:32:01 <lambdabot> Debug.Trace trace :: String -> a -> a
19:32:01 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
19:32:01 <lambdabot> module Debug.Trace
19:32:28 <dankna> gawd.  Template Haskell /really/ needs usable quasiquoting.
19:32:35 <dankna> five lines of code expand to a hundred lines of TH!
19:32:54 <ivanm> heh
19:33:59 <Peaker> actually I forgot the rotation speed should be divided by the number of samples so that when K=1 it completes a single circle, but that's not crucial to my explanation
19:37:58 <dafis> Peaker: what's cis? is it cis(x) = e^ix = cos(x) + i*sin(x)?
19:39:55 <Peaker> dafis: yeah
19:40:35 <dafis> aha, is that notation commonly used in engineering?
19:40:40 <handygandy> I'm trying to build an application called ebnf2ps on debian testing I get link errors. The first: (.text+0x2a2): undefined reference to `containerszm0zi3zi0zi0_DataziMap_findWithDefault_closure' .  which corresponds to the line: lookupWithDefaultFM theMap theDefault theKey =   Data.Map.findWithDefault theDefault theKey theMap
19:40:47 <handygandy> How do I fix this?
19:41:11 <dafis> handygandy: ghc --make, if your ghc is pre-7
19:41:48 <dafis> handygandy: remove .o and .hi or add the -fforce-recomp flag, though
19:43:28 * dafis wonders why one would transform EBNF to ps, though
19:43:31 <Peaker> dafis: I think so
19:43:46 <ddarius> dolio: When did you start programming?  Also, you should write a ray tracer.  It's a fun, easy exercise in geometry and pretty rewarding.
19:43:53 <applicative> handygandy, do you have the cabal install executable? he has a cabal file in there
19:44:01 <applicative> funny its not hackaged.
19:44:08 <ddarius> dolio: You could have interesting pictures (far more interesting than the ones I had) in a few hours.
19:44:27 <ddarius> (I spent most of the time on the BIH and I was putting off things for other reasons.)
19:44:46 <Peaker> ddarius: it took me a lot more than a few hours, because developing all the intersection formulas with my super-rusty math was sloow :)
19:45:01 <applicative> handygandy, he also has a Setup.hs, so it should build with the standard "Cabal" procedures.  e.g. runhaskell Setup.hs configure , etc.
19:45:11 <Peaker> If your math is sharp, it should be quick though, yeah
19:46:21 <ddarius> Peaker: I have to agree with the (implicit) message of the first reddit responder.
19:46:44 <applicative> ebnf2ps, is nice, its name doesn't make clear that it makes those grammatical 'railroad' diagrams.
19:46:56 <scooty-puff> is a monad transformer still a monad transformer if it has constraints on the sub-monad?  i.e. MonadConstantPool m => data CodeT m i j a = Code { unCode :: S -> m (a, S) }
19:47:27 <scooty-puff> not sure if i should still call it that (with the T) if its not really that..
19:48:06 <ivanm> sure, why not?
19:48:14 <ivanm> it still transforms a monad
19:48:25 <ivanm> preflex: seen Cale
19:48:25 <preflex>  Cale was last seen on #haskell 4 hours, 40 minutes and 39 seconds ago, saying: not x : concat xs
19:48:40 <scooty-puff> well, it implies that it requires a means to write to a constant pool, just not sure how general i have to be
19:48:43 <scooty-puff> but thats really it
19:48:44 <Peaker> ddarius: about the dot product?
19:48:54 <ddarius> Yes.
19:49:22 <Peaker> ddarius: Of course a Fourier Transform is a dot product, but that doesn't explain why the result of that dot product gives you the frequency->phase,amplitude composites
19:49:32 <jmcarthur> ListT is considered a monad transformer even though it actually only forms a valid monad if the underlying monad is commutative
19:49:40 <ddarius> The Fourier transform is a linear functional and just projection onto a basis of periodic function.
19:50:05 <scooty-puff> ok, going with it then
19:50:21 <jmcarthur> not that i'm encouraging you to write bad transformers, but surely a declared constraint is better than what ListT does :)
19:50:42 <Peaker> ddarius: Well, maybe it is my lack of maths background, but I don't understand why dot-producting against a rotating cis() gives me a phase/amplitude of that cis(). What even explains why the periodic functions ARE a valid linear space basis?
19:51:21 <Peaker> ddarius: I guess if you have a lot of extra background, then it may work as an explanation.. but working from scratch, I think my explanation is much simpler
19:51:40 <ddarius> Peaker: The latter question is trickier (and arguably the answer is "the inverse Fourier transform") but the former is a direct generalization of the finite case.
19:52:32 <Peaker> ddarius: Well, if you already know enough linear algebra that all of that is immediately clear to you, that explanation may work..  My linear algebra is weak so I had to develop that other explanation I pasted, which uses pure, simple arithmetic to show why DFT's definition ends up having that effect
19:53:46 <Peaker> ddarius: the point made by that reddit post that you support is kind of like the joke "a monad is just a monoid in the category of endo-functors, what's the problem?" about an explanation of monad laws, what they generalize, etc.
19:54:08 <Peaker> ddarius: of course an explanation is superfluous if you have so much background that you can just connect a few dots :)
19:54:33 <ddarius> Peaker: Your explanation does (generalize to) a description of why the complex exponentials are orthogonal (and thus form an orthogonal basis.)
19:55:27 <sshc_> Liskni_si: Great!
19:55:51 <applicative> handygandy, still around? I seem to have built it.
19:56:03 <Peaker> btw: Part of why I love Haskell, is because it expanded my mind to the point where me and friends can explain complex software stuff by just "connecting a few dots"
19:57:12 <sshc_> Liskni_si: You've provided the Haskell community with a decent means of having errors that include identifying information like line numbers, a habit which should replace having, comparitevly speaking, much less informative / helpful error mesages (loch-th package)
19:57:23 <sshc_> Liskni_si: That said, I haven't looked at it deeply yet.
19:58:55 <wookydocky> hey everyone :)
19:58:58 <sshc> Liskni_si: Also, while that module name does seem significantly better than Divine.Something, but I don't think "Debug.Trace.Location" is appropriate either.  I wouldn't consider it as a means of debugging.  Errors / undefined seems to be a fundamental part of practical Haskell programming.
19:59:13 <wookydocky> could You please explain me step by step how mergesort (msort) works here: http://pastebin.com/gg2VRvcy ?
19:59:21 <wookydocky> I don't get 21st line
20:00:12 <sshc> I would suggest starting with "Language.", but I'm not an expert at choosing module names, so I'd leave that to #haskell.  I would consider changing it promptly, though, before it becomes too widely used to make a change significantly affect that (even then, a simple re-export would suffice)
20:00:21 <ddarius> Peaker: So the thing here is to analyze linear algebra.  Particularly in the infinite-dimensional case if you want to get rigorous with this example, though that's not really necessary.  One of the problems with your explanation and the original one is that it makes the Fourier transform seem rather special.
20:01:19 <sshc> Liskni_si: Also, I would try to make it simple enough to understand for less experienced Haskell users, particularly those who haven't learned Template Haskell.  Documentation might possibly be enough for that here (or small changes might also be needed).
20:01:40 <Peaker> ddarius: it is a valid special case.. generalizing later is possible -- but learning is easier from the concrete
20:01:46 <sshc> Liskni_si: Generally speaking, though, it's a step in the right direction.
20:01:49 <applicative> wookydocky
20:01:54 <applicative> this one: msort xs = merge . cross (msort,msort) . halve $ xs
20:02:00 <applicative> ?
20:02:10 <applicative> wookydocky123:  there you are
20:02:27 <Peaker> cross = uncurry (***) ?
20:02:29 <wookydocky123> applicative, yup, these one :)
20:02:33 <wookydocky123> *this
20:02:43 <applicative> does it help if we make it completely point-free :  msort  = merge . cross (msort,msort) . halve
20:02:51 <sshc> Liskni_si: You might consider a brief explanation and example for how those particular features of TH can be used there
20:02:51 <applicative> Peaker is beating me to it.
20:03:16 <Peaker> applicative: I asked to understand, not to make it points-free :P
20:03:28 <ddarius> Peaker: My point is that these explanations don't even allude to this being a special-case of something.
20:03:44 <applicative> wookydocky123: you get that merge . foo .halve means, operationally, first halve it, then foo it, then merge it
20:03:49 <sshc> Liskni_si: (I don't expect that it'd require a deep explanation; only particular parts should be necessary.  Perhaps a note that one expression that can be used as onether, or showing several translations exemplifying converting old errors to new errors)
20:03:56 <applicative> i mean, you understand that much ofit?
20:04:13 <wookydocky123> what does halve $ xs mean ?
20:04:25 <wookydocky123> that I make function halve on xs first?
20:04:34 <monochrom> 50 cents xs
20:04:46 <applicative> $ here is just bracketting.  Yes, first xs is halved, then ...
20:04:59 <ddarius> monochrom: 0.5 cents
20:05:14 <wookydocky123> how should it look like without $
20:05:18 <applicative> you read f . g 'backward' when you view it operationally.  f . g . h $ xs = f (g (h xs))
20:05:35 <Peaker> ddarius: do the linear-algebra explanations make it clear why when K=FREQ, you get the phase/amplitude in there?
20:05:42 <Peaker> ddarius: (simply)?
20:06:00 <wookydocky123> merge . cross (msort,msort) . halve ( xs) right ?
20:06:06 <applicative> merge (cross (msort,msort) (halve xs) )
20:06:42 <wookydocky123> ok, so i spit my list into two parts
20:06:50 <wookydocky123> what's next? i don't understand that cross
20:07:02 <applicative> no the . s shouldn't extend to xs.
20:07:10 <sshc> Liskni_si: Again, this is only a surface observation.  I haven't looked in detail at it.
20:07:55 <wookydocky123> ok, let's say that halve spit the list into two parts xss and yss
20:07:59 <applicative> the cross is a higher order function, it takes two functions, or rather a pair (a -> c, b -> d) and makes a single function on pairs  (a,b) -> (c,d)  -- thus cross :: (a -> c, b -> d) -> (a,b) -> (c,d)
20:08:07 <sshc> Liskni_si: In particular, I'll look at the actualy documentation when I have time.
20:08:12 <wookydocky123> then i put that two parts into that cross?
20:08:13 <sshc> Liskni_si: s/actualy/actual/
20:08:19 <Peaker> ddarius: (represented as the phase/amplitude of the complex values)
20:08:29 <applicative> wookydocky123: right, it does, it makes a pair halve :: [a] -> ([a], [a])
20:08:50 <applicative> you apply the result of cross to the pair (of lists)
20:09:09 <wookydocky123> and cross takes the first part of the list and the second part of the list, right?
20:09:19 <applicative> you apply the result of cross (msort,msort) to (xs,ys)
20:09:40 <wookydocky123> then by recursion msort is called on the first part, and on the second part, right?
20:09:49 <wookydocky123> after that I merge them all
20:09:53 <wookydocky123> correct?
20:09:55 <applicative> no cross takes the two functions msort and msort and makes a new function out of them, one that is fitted to apply to (xs, ys)
20:10:25 <wookydocky123> err, again, halve gives me two parts of list: xs and ys, right?
20:10:35 <wookydocky123> then cross calls msort on xs and msort on ys ?
20:11:19 <applicative> let pair (f,g) x = (f x, g x); cross (f,g) = pair (f . fst, g . snd) in cross (ord,chr) ('a',66)
20:11:30 <applicative> > let pair (f,g) x = (f x, g x); cross (f,g) = pair (f . fst, g . snd) in cross (ord,chr) ('a',66)
20:11:31 <lambdabot>   (97,'B')
20:12:09 <applicative> ^^ so here I applied cross to the ord function (Char -> Int) and chr function (Int -> Char).
20:12:48 <wookydocky123> err, again, halve generates two lists xs and ys ('cos it divided input list), then it puts in into pair/tuble, so i got (xs, ys), then by using cross i can get the first element of that pair and the second one, so i got xs and ys
20:12:54 <wookydocky123> now i do msort on xs and ys
20:13:23 <wookydocky123> when i'm coming back from recursion merge joins sorted lists, right?
20:13:32 <ddarius> Peaker: No more or less than your version.  You get those out because you put them in.  Unless you are asking why, when the frequency matches, you get that specific one, then that because you are projecting a basis vector onto itself.
20:13:38 <applicative> you don't use cross directly on (xs, ys) you use the function cross (msort, msort) as above I used cross (ord,chr)
20:14:08 <applicative> > let pair (f,g) x = (f x, g x); cross (f,g) = pair (f . fst, g . snd) in cross (even, even) (1,2)
20:14:10 <lambdabot>   (False,True)
20:14:11 <wookydocky123> but the idea of using it is the same, right?
20:14:22 <monochrom> just say "yes"
20:14:37 <ivanm> monochrom: heh
20:14:37 <wookydocky123> ok, I see it :)
20:14:46 <ivanm> @remember monochrom just say "yes"
20:14:46 <lambdabot> Done.
20:15:06 <Peaker> ddarius: Not clear why the basis vector would show up the phase in there.. it's not exactly "onto itself" because there's the phase-shift
20:15:41 <ddarius> Peaker: The "phase" corresponds to a different basis vector, namely one that is a translation of one with different phase but the same frequency.
20:15:48 <wookydocky123> but could You please show me how it works on a small exmaple, just to make sure that i understand that, let's say [1,3,2,4]
20:16:06 <applicative> maybe if we renamed cross it'd be clearer, and if we used it infix cross (even,even) (1,2) is (even,even) `appliedCrossWiseTo` (1,2)
20:16:43 * monochrom gives you the gift of Ã—
20:16:51 <Peaker> ddarius: I thought the basis vectors corresponded just to the different K constants
20:17:16 <applicative> so you could thing of (even, even) or (msort, msort) or (ord,chr) as the 'real' function or functions, then cross or `appliedCrossWiseTo` applies them.
20:17:50 <ivanm> monochrom: there was someone coming in here yesterday having problems with his code because he used that symbol (as part of an infix constructor though)...
20:17:55 <wookydocky123> applicative, well, done, i understand how cross work's but now I'm not sure how merge works here
20:17:56 <Peaker> ddarius: btw: I agree that with L.A background it is better to give your explanation which is more amenable to generalization. But if you want to explain FT to someone without much background, do you start by teaching him enough L.A to understand all that? or just skip all the fuss and teach FT as arithmetic?
20:18:21 <monochrom> the constructor will have to be :Ã— unfortunately
20:18:30 <applicative> > let pair (f,g) x = (f x, g x); cross (f,g) = pair (f . fst, g . snd) in cross ((*1), (*1000)) (2,3)
20:18:32 <lambdabot>   (2,3000)
20:19:22 <applicative> @type let halve xs = splitAt (length xs `div` 2) xs in halve
20:19:23 <lambdabot> forall a. [a] -> ([a], [a])
20:19:32 <applicative> so that's halve ^^
20:19:38 <ddarius> Peaker: The former.
20:20:06 <wookydocky123> well, I understand everything right now, thanks a lot @applicative :)
20:20:11 <ddarius> In my opinion, as much as I love signal processing and the Fourier (and related) transforms, linear algebra is far more important.
20:20:15 <applicative> merge here has the 'opposite' signature merge :: Ord a => ([a], [a]) -> [a]
20:20:48 <applicative> sure wookydocky123, our friends are always here
20:20:58 <wookydocky123> :)
20:21:00 <sw17ch> hi all
20:21:28 <ivanm> hey sw17ch
20:21:35 <ivanm> thanks for the releases of data-clist!
20:21:55 <sw17ch> ivanm: thanks for tolerating my forgetfulness
20:22:00 <sw17ch> :)
20:22:01 <ivanm> heh, np
20:22:18 <ivanm> I wasn't working on the project that needed it until recently
20:22:32 <sw17ch> do you mind me asking what it's being used for?
20:22:45 <ivanm> a planar graph data structure
20:22:48 <Peaker> ddarius: That's different.. Assuming your ultimate goal is for him to understanding FT's basic properties, the shortest path to understanding it is probably my arithmetic and not L.A -> FT.
20:22:53 <ivanm> code.haskell/~ivanm/planar-graph
20:23:02 <poltak> ivanm: I learnt planar graphs in my maths lecture yesterday
20:23:20 <ivanm> poltak: oh? what subject?
20:23:30 <poltak> discrete maths (compsci)
20:23:33 <Peaker> applicative: newtype SortedList a = SortedList [a] ;  merge :: (SortedList a, SortedList a) -> SortedList a ? :-)
20:23:57 <shachaf> sw17ch: I think shapr was looking for you recently, by the way.
20:23:59 <Peaker> msort :: [a] -> SortedList a
20:24:15 <sw17ch> shapr: you there?
20:24:31 <Peaker> ddarius: btw: Haskell libs to do signal processing are awful
20:24:46 <ddarius> Peaker: So don't do signal processing in Haskell.
20:25:45 <Peaker> ddarius: :-(
20:25:57 <ddarius> Peaker: In my opinion, assuming your ultimate goal is for him to understand the Fourier Transform you either need no explanation beyond that it is a black box that gives you phase and angle, or you need linear algebra.
20:26:35 <ddarius> s/understand/understand enough to use/
20:26:42 <sw17ch> ivanm: so, an example of a planar graph would be a street map where intersections are ndoes?
20:26:43 <sw17ch> nodes*
20:27:02 <sanjoyd> @src liftM2
20:27:03 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:27:05 <ivanm> sw17ch: as long as you have no over/underpasses, then yes
20:27:10 <sw17ch> oh, right
20:27:25 <sw17ch> is there a specific application you're going to use the PG for?
20:27:37 <ddarius> Peaker: It's not like linear algebra is terribly complicated.
20:28:15 <ivanm> yeah, I'm working on a generator for d-angulations of girth d
20:28:22 <ivanm> for my PhD
20:28:50 <sw17ch> i won't pretend to understand what you just said, ivanm. :)
20:28:55 <ivanm> heh
20:29:11 <ivanm> sw17ch: OK: d-angulation means that each face (including the outer face) is of size d
20:29:17 <ivanm> so triangulations, quadrangulations, etc.
20:29:49 <ivanm> the girth of a graph is the size of the smallest cycle within it; so this only works if you can't somehow draw a triangle inside a pentangulation for example
20:29:55 <ivanm> this == my generator
20:30:19 <sw17ch> i believe i'd need to see that geometrically to fully understand
20:30:47 <sw17ch> i haven't had enough mathematical training as i'd like
20:31:03 <ivanm> http://en.wikipedia.org/wiki/Girth_(graph_theory)
20:31:06 <sw17ch> and graph theory, while very interesting, isn't necessarily my strong point unless i can apply it to something
20:32:18 <wookydocky123> btw, may I ask another question, 'cos I collected some haskell excercises on my HD and I'm trying to solve them now I stuck with this one: http://pastebin.com/RL7MBqsF
20:32:20 <sw17ch> ivanm: a graph without girth is a a tree, correcT?
20:32:35 <wookydocky123> I mean, what's wron with that solution: msortn x n = msort (take n x)  (or maybe it's ok)
20:33:01 <ivanm> better example: top of page 14 here: http://arxiv.org/abs/1007.1292v4
20:33:06 <ivanm> that's the kind of thing I'm generating
20:33:23 <ivanm> sw17ch: hmmm..... good question; I _think_ so
20:33:56 <sw17ch> i can't readily think of a circumstance where you could have a graph that is not also defined as a tree without a cycle
20:34:06 <sw17ch> unless directedness comes in to play
20:34:12 <poltak> Can I SSH into somebody's computer here?
20:34:29 <sw17ch> well, even then...
20:34:30 <ivanm> poltak: uhhh.... _why_ ?
20:34:31 <sw17ch> hmm
20:34:38 <ivanm> sw17ch: I don't think that's correct
20:35:00 <wookydocky123> poltak, via IRC? or coding own SSH client in haskell?
20:35:05 <sw17ch> now that i think of it, directedness doesn't seem to come into play
20:35:06 <wookydocky123> via IRC - you cannot
20:35:16 <poltak> ivanm: I've never done it before, I wanna do it
20:35:18 <ivanm> wookydocky123: sure you can... /exec ssh :p
20:35:25 <poltak> wookydocky123: no, via bash
20:35:36 <ivanm> poltak: get yourself another computer and enable the ssh daemon!
20:35:38 <wookydocky123> ivanm, wow, something new for me :)
20:35:43 <ivanm> @google free shell account
20:35:45 <lambdabot> http://shells.red-pill.eu/
20:35:45 <lambdabot> Title: Free Shell Accounts - the biggest list on the net :-) - Rankings - All Sites
20:36:01 <poltak> ivanm: For seriously? just get another computer
20:36:05 <ivanm> poltak: ^^
20:36:22 <poltak> If that's the only way then I might as well sometime in the near future
20:36:23 <wookydocky123> ivanm, my irc client doesn't support exec command ;p
20:36:34 <ivanm> wookydocky123: oh, must be an xchat-ism
20:37:00 <ivanm> poltak: well, the only reason to ssh to another computer is to do stuff there...
20:37:14 <poltak> can't you get their credit card and all?
20:38:05 <ivanm> ummm, only if they decided to save their CC details on their computer...
20:38:16 <poltak> yeah, I read it in a news article
20:38:39 <poltak> that's how they caught osama, ssh
20:38:55 <poltak> that's what my teacher told me anyway
20:40:13 * ivanm is suddenly glad he didn't go to monash then
20:40:22 <monochrom> you only need one physical computer to play with ssh.
20:40:40 <ivanm> monochrom: true, though it's kind of redundant to ssh right back into your own box
20:40:56 <monochrom> but not self-ssh per se
20:41:09 <monochrom> begin by installing a virtual machine...
20:41:36 <poltak> ivanm: you're not nice
20:42:12 <monochrom> ivanm is nice. I testify it.
20:42:24 <sw17ch> and writes good patches. i'll vouch for him. :)
20:42:26 <copumpkin> thus spake monochrom
20:42:43 <Jafet> copumpkin: dah-dah!!!
20:43:07 <wookydocky123> btw, could You give me any hint for that: http://pastebin.com/RL7MBqsF ? All I've already got is msortn x n = msort (take n x)
20:43:16 <monochrom> hah-hah
20:43:17 <ivanm> poltak: hey, I'm not the one that wants to ssh into someone's box in the hopes of stealing their credit card info!
20:43:18 <wookydocky123> why it's worse than version with length?
20:43:26 <poltak> monochrom: bullys aren't nice people in general!
20:43:38 <monochrom> ivanm is not a bully.
20:44:45 <poltak> monochrom: you don't know unless you've been on the receiving end
20:45:03 <ivanm> poltak: what makes me a bully? the fact that you said your teacher told you that they found Osama's location via SSH, and that I saw from your /whois that you're at Monash uni, so I figured that if that's the kind of teaching staff you have there I'm glad that I went to a different uni?
20:45:46 <poltak> ivanm: that's so mean
20:45:46 <monochrom> the receiving end may make mistakes, too
20:45:48 <noses> @src splitAt
20:45:48 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
20:46:01 <noses> @src take
20:46:02 <lambdabot> take n _      | n <= 0 =  []
20:46:02 <lambdabot> take _ []              =  []
20:46:02 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
20:46:29 <ivanm> seriously? you think that's _mean_ ?
20:46:31 <Jafet> That they admit oblivious people like poltak is reason enough...
20:46:33 <noses> wookydocky123: take doesn't reuse the same :, so it basically does copy the list
20:46:46 <copumpkin> this is meant to be a friendly channel
20:46:49 <sw17ch> this seems unproductive
20:46:50 <copumpkin> let's keep it that way
20:47:00 <wookydocky123> noses, so how should i do it correct?
20:47:05 <copumpkin> so
20:47:08 <ivanm> copumpkin: yes, O gourdish one!
20:47:10 <copumpkin> yoneda lemma!
20:47:20 <monochrom> is unfriendly to me
20:47:22 <copumpkin> I decree that the next topic of conversation shall be representability
20:47:28 <sw17ch> has any one else played with the awesome that is the omega monad?
20:47:35 <copumpkin> sw17ch: I have!
20:47:36 <sw17ch> oh dang, beaten by seconds
20:47:46 <sw17ch> copumpkin: i made something _awesome_ with it
20:47:51 <copumpkin> what is it?
20:48:17 <sw17ch> it takes a type signature, and a universe of functions, and produces all combinations of those functions that resuults in the type signature
20:48:27 <copumpkin> ooh!
20:48:31 <sw17ch> i'm still working on it
20:48:32 <copumpkin> sounds fun
20:48:35 <sw17ch> but i want to make reverse quick check
20:48:39 <wookydocky123> noses, 'cos i got no idea how to use legth there
20:48:44 <noses> wookydocky123: I'm not sure if they are asking you to use IORef for mutable lists of which there are some unrelated examples here http://www.haskell.org/haskellwiki/MonadFix
20:48:50 <sw17ch> give a spec and a type, and it filters out only stuff that matches the spec
20:49:31 <sw17ch> copumpkin: i wrote some about it here: https://github.com/sw17ch/Volcano/blob/master/stash/search.lhs
20:49:46 <sw17ch> though, you can see i got frustrated with my train of thought half way down and just finished it.
20:49:48 <noses> if you use a mutable list, you can split the list in half without copying half of the spine of the list (the : and the [])
20:49:51 <gigamonkey> Is there a reason 'x = 10' isn't acceptable to http://tryhaskell.org/
20:49:52 <sw17ch> and it doesn't parse haskell yet
20:50:03 <noses> gigamonkey: try   let x = 10?
20:50:11 <copumpkin> let x = 10 in blah
20:50:12 <monochrom> because http://tryhaskell.org/ doesn't take definitions
20:50:15 <wookydocky123> noses, mutable list?
20:50:37 <gigamonkey> monochrom: not of anything? So I can't define functions either?
20:50:55 <monochrom> right, can't define functions
20:51:11 * gigamonkey is looking for somewhere to try a bit of Haskell while waiting 2h for Xcode to download.
20:51:20 <noses> wookydocky123: using:  data Node = Node Int (IORef Node)   rather than the built-in list type
20:51:23 <monochrom> unless it's part of an expression like "let f x = x in f ()"
20:51:34 <sw17ch> gigamonkey: codepad.org
20:52:11 <sw17ch> gigamonkey: http://codepad.org/wYNwT4aZ
20:52:42 <saiko-chriskun> gigamonkey: tryhaskell.org
20:52:49 <gigamonkey> saiko-chriskun: see above.
20:52:57 <wookydocky123> noses, why data is better?
20:53:02 <saiko-chriskun> oups
20:53:05 <saiko-chriskun> :P
20:53:08 <shachaf> gigamonkey: You can use lambdabot. :-)
20:53:22 <noses> wookydocky123: I don't think it's better, it's more awkward to use
20:53:29 <shachaf> gigamonkey: @let foo = bar, > expr
20:53:50 <gigamonkey> sw17ch: cool, I was just about to ask about how to define a main properly. Thanks.
20:53:51 <shachaf> gigamonkey: (tryhaskell will only evaluate expressions, apparently.)
20:53:56 <applicative> gigamonkey: also http://ideone.com/adccx --uses a somewhat out of date ghc
20:54:16 <sanjoyd> @src <*>
20:54:16 <lambdabot> Source not found. You type like i drive.
20:54:27 <sw17ch> gigamonkey: :)
20:54:35 <wookydocky123> noses, but is it possible to solve this excercise without data types?
20:54:43 <noses> wookydocky123: but the using length part is suggesting you to write   proper_sort x = msortn x (length x)
20:55:49 <wookydocky123> but length returns number of elements, not elements
20:55:49 <gigamonkey> sw17ch: yay, success! http://codepad.org/HiHmKt2T (Stupid I know.)
20:56:10 <sw17ch> gigamonkey: yay!
20:56:43 <shachaf> @src print
20:56:43 <lambdabot> print x = putStrLn (show x)
20:56:44 <noses> wookydocky123: you have to write  msortn :: Ord a => [a] -> Int -> [a]
20:57:12 <wookydocky123> noses, right, ok
20:57:30 <wookydocky123> and what next? what information this types tell me?
20:57:53 <noses> then you can get a sort that doesn't need the length of the list by the defintion of propert_sort I gave above
20:58:19 <noses> but I don't understand what your question is saying by "achieve the same goal"
20:58:19 <shachaf> Ah, poltak is gone.
20:58:33 <shachaf> Anyone want to SSH into my computer?
20:58:55 <noses> a difference list is like   \f x0 -> foldr f x0 xs?
20:59:01 <monochrom> not until next time you have an unsolvable cabal problem
20:59:02 <wookydocky123> noses, http://pastebin.com/RL7MBqsF i still don't understand how propert_sort solves that task
20:59:03 <noses> @hackage DList
20:59:03 <lambdabot> http://hackage.haskell.org/package/DList
20:59:15 <noses> http://hackage.haskell.org/package/dlist
20:59:23 <saiko-chriskun> shachaf: lol you need to test your port forwarding or something?
20:59:38 <noses> are those 'difference lists' the same as prolog difference lists?
20:59:40 <shachaf> saiko-chriskun: Nah, just want somebody to steal my credit card numbers.
20:59:49 <saiko-chriskun> oh
20:59:51 <saiko-chriskun> good
20:59:52 <applicative> gigmonkey, ideone.com, in addition to the excellent ads, lets your main take input from stdin.  http://ideone.com/ROPuZ
20:59:53 <saiko-chriskun> :D
21:00:20 <applicative> gigamonkey: and a facebook tie-in.  Tell your friends you wrote "hello world" in 36 programming languages!!
21:00:26 <wookydocky123> i don't know if there are the same
21:00:38 <wookydocky123> i don't get the idea of haskell's diff. lists
21:01:04 <applicative> wookydocky123: I think they are not the same.  I don't know the prolog lists.
21:01:56 <applicative> the haskell diff lists replace the list xs with the function that prepends xs to any given list. so instead of xs ++ ys ++ zs
21:02:02 <shachaf> wookydocky123: ("abc"++) would be the representation of "abc". The general idea is that you append them with composition, as in (("abc"++) . ("def"++)).
21:02:05 <shachaf> > (("abc"++).("def"++)) ""
21:02:06 <lambdabot>   "abcdef"
21:02:17 <applicative> you use xs' . ys' . zs' $ []
21:02:19 <noses> shachaf: so how do you split one of these difference lists in half?
21:03:00 <applicative> noses, easy, you apply it to zero, take half, and prefix it to (++)
21:03:08 <applicative> apply it to [] rather
21:03:45 <wookydocky123> well, still nothing for me... maybe I should try to read about it more myself :)
21:03:45 <shachaf> noses: These aren't really the same as Prolog's difference lists.
21:03:46 <noses> well that does nothing for reducing allocation of extra (:) []
21:04:12 <wookydocky123> I mean it's to difficult for me right now, anyway thanks a lot :)
21:04:14 <applicative> they are supposed to evade the expense of appending ++ xs
21:05:07 <applicative> pretty printing libraries often use (Haskell) difference lists.  The difference from what are rightly called that, Prolog;s difference lists, was discussed on -cafe not too long ago.
21:05:32 <noses> wookydocky123: it should be easy enough to find some merge sorts in haskell, such as the sort in Data.List
21:06:01 <noses> (or at least ghc's version of it)
21:07:00 <wookydocky123> noses, i know how to code merge sort ;]
21:07:13 <wookydocky123> i dunno how to solve that excercise (with length) ;)
21:07:56 <noses> well you need to split the list in half, such as with   splitAt n
21:08:27 <noses> where n is a parameter supplied to the  msortn (and also on recursive calls)
21:08:39 <applicative> wookydocky123: a comparison between the two kinds of difference lists, if you care to investigate comes up in the haskell-cafe dispute beginning here http://www.haskell.org/pipermail/haskell-cafe/2010-October/085757.html
21:09:15 <wookydocky123> applicative, ok, i'm gonna read it
21:09:21 <wookydocky123> so thanks a lot for help ;]
21:09:42 <wookydocky123> need to go ;], bye
21:11:57 <dons> huh. there are two kinds?
21:12:17 <noses> this term 'junk' http://www.haskell.org/pipermail/haskell-cafe/2010-October/085768.html is for functions which don't belong but have the right type?
21:13:32 <dons> applicative: great reference. hadn't seen that thread
21:16:22 <RayNbow> hmm, is it just me or is the indentation of the code blocks on hawiki incorrect?
21:16:23 <desaiu> What does this line do? fib 0 = 0
21:16:42 <RayNbow> (the first line of each code block should be indented by 2 more spaces)
21:17:08 <sw17ch> desaiu: it's a pattern match. that says 'when function fib is given a 0 as the first argument, return 0'
21:19:03 <desaiu> Wow, so much in just that!
21:19:47 <sw17ch> desaiu: yes, it's quite powerful
21:20:07 <sw17ch> you can then proceed to define more matches which are always evaluated from top to bottom
21:20:10 <desaiu> I have a feeeling Haskell is going to be a lot like learning Mandarin.
21:20:12 <sw17ch> fib 1 = 1
21:20:29 <sw17ch> and so on
21:20:45 <sw17ch> desaiu: i've never learned Mandarin, so i won't have anything to base that on. :)
21:22:54 <desaiu> In short, they both have difficult initial learning curves, but once you are past the hill, you can express yourself quite naturally without having to worry about so many things you commonly would worry about in other languages.
21:24:21 <mjrosenb> is there a monad instance for any implementation of Random?
21:24:55 <sw17ch> good night, all
21:25:05 <ddarius> mjrosenb: No, it would have the wrong kind.
21:26:26 <desaiu> Goodnight, thank you sw17ch.
21:26:48 <sw17ch> you are welcome, desaiu
21:28:47 * hackagebot bmp 1.1.2.1 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.1.2.1 (BenLippmeier)
21:33:59 <mjrosenb> ddarius: hrmm, i basically want something like State where the state of the prng gets threaded through, i'd be suprised that something like this does not already exist.
21:34:43 <ddarius> :t state random
21:34:44 <lambdabot> forall s a. (Random a, RandomGen s) => State s a
21:35:15 <ddarius> noses: More or less.  It has a technical meaning, but I'm somewhat abusing it there anyway.
21:35:28 <mjrosenb> :t state
21:35:29 <lambdabot> forall s a. (s -> (a, s)) -> State s a
21:36:48 <mjrosenb> ok, next question: where are the docs for state?
21:36:50 <mjrosenb> http://haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
21:36:57 <mjrosenb> does not seem to mention them anymore
22:03:41 <Peaker> difference lists ought to be generalized to Monoids and called reassociate-right-monoid or such?
22:04:39 <mjrosenb> difference lists?
22:08:16 <copumpkin> Peaker: fmlist?
22:08:32 <Peaker> fmlist?
22:08:49 <copumpkin> @hackage fmlist
22:08:49 <lambdabot> http://hackage.haskell.org/package/fmlist
22:09:04 <Peaker> mjrosenb: the [a]->[a] lists like ShowS where you parameterize the list by its ending element, so changing the end (concating) is O(1)
22:25:54 * hackagebot CV 0.3.0.2 - OpenCV based machine vision library  http://hackage.haskell.org/package/CV-0.3.0.2 (VilleTirronen)
22:27:44 <mjrosenb> gah, i keep wanting to use >> as flip liftM
22:28:11 <Peaker> copumpkin: seems nice.. not sure I understand what's the advantage over a simple wrapped mappend
22:28:32 <Peaker> @type [(>>), flip liftM]
22:28:32 <lambdabot> forall a1 r. [(a1 -> a1) -> (a1 -> r) -> a1 -> r]
22:28:59 <Peaker> mjrosenb: what do you mean?
22:29:20 <mjrosenb> Peaker: i mean, i want flip liftM to be infix, and called ">>"
22:29:29 <mjrosenb> because, i basically never use >>
22:29:36 <mjrosenb> but i use flip liftM all the time
22:29:54 * hackagebot mysql-simple 0.2.2.0 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.2.0 (BryanOSullivan)
22:30:02 <mjrosenb> and i think of it as "take this monadic value, and force it through this non-monadic function
22:30:05 <Peaker> :t (<$$>)
22:30:06 <lambdabot> Not in scope: `<$$>'
22:30:20 <Peaker> I think I saw (<$$>) = flip (<$>)
22:30:32 <mjrosenb> so it is like >>=, but does a bit of extra work
22:30:52 <Peaker> mjrosenb: it's like fmap/<$>, just flipped.. why not put the function on the left side? Because it's point-ful?
22:31:21 <Peaker> > let (<$$>) = flip (<$>) in [1,2,3] <$$> \x -> [x*100, x+1]
22:31:22 <lambdabot>   [[100,2],[200,3],[300,4]]
22:31:54 <Peaker> mjrosenb: it's like >>= but does a bit LESS work :)
22:32:05 <mjrosenb> because i want it to look like >>=; since i'm thinking of this as running a monadic value through a pipeline, i'd like it to look like that
22:32:21 <Peaker> but you're running it through a Functor pipeline :P
22:32:49 <mjrosenb> rather than a whole mess of function applications / a series of composed functions
22:33:30 <mjrosenb> wait, doesn't flip liftM have to unbundle the value (just like >>=), then apply the function (just like >>=), then rebundle the value?
22:33:43 <yitz> mjrosenb: i always prefer a beautiful stream of function applications and composed functions by far over a whole mess of forcing values through monadic computations. :)
22:34:18 <Peaker> mjrosenb: fmap "just" applies a function inside a Functor wrapper. (>>=) does fmap and then joins the result
22:34:31 <Peaker> @type (>>=)
22:34:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:34:43 <Peaker> @type (join.).fmap
22:34:44 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
22:35:29 <mjrosenb> Peaker: that seems like a silly way of looking at things.
22:35:54 <yitz> mjrosenb: not very silly, considering that monads are actually defined that way
22:36:14 <mjrosenb> yitz: :(
22:37:32 <yitz> mjrosenb: i'm surprised that you rarely use >>. it's one of the most useful tools when working with monads. i think i hardly ever use a monad with out using >>.
22:38:19 <yitz> mjrosenb: i guess this whole discussion just shows that there are many different styles of programming that can be beautiful when used consistently.
22:38:31 <mjrosenb> yitz: i use >>= a whole lot more.
22:38:55 <yitz> mjrosenb: sure
22:38:56 <Peaker> mjrosenb: if you assume you can "unwrap" the value, apply func, "rewrap" or avoid last "rewrap" it seems like less work. but you cannot unwrap.  So you have to "lift the function" into the wrapper. apply. then either you're done, or you have a double-wrapper, and you need to join them into one
22:39:37 <Peaker> whether you use >> or not probably correlates almost exactly to whether your monad makes actions of type m () useful
22:41:08 <yitz> Peaker: what monad never makes actions of type m() useful?
22:41:16 <ian_mi> yitz: Identity monad
22:41:19 <yitz> haha
22:41:27 <Peaker> yitz: Behavior?
22:41:29 <yitz> very good!
22:41:31 <Peaker> (From Reactive)
22:41:40 <shachaf> data Null a = Null?
22:41:53 <shachaf> Identity seems much more useful.
22:42:03 <yitz> Peaker: oh, could be, i haven't immersed myself deeply enough into reactive stuff yet
22:42:25 <Peaker> Any monad whose semantic model is the Reader monad (Behavior a's semantic model are supposed to be (Time->a), so it's a Reader monad with a smarter implementation)
22:42:34 <Peaker> (reader specialized for time)
22:43:01 <Peaker> (that includes the Reader monad itself, of course)
22:43:12 <yitz> Peaker: right, monands with only "pull" effects, like Reader, can't do much with ().
22:43:18 * mjrosenb has been meaning to poke at reactive stuff.
22:43:33 <yitz> mjrosenb: be careful, they say it pokes back
22:44:08 <mjrosenb> so i've heard.
22:44:21 <yitz> mjrosenb: so Peaker is right. i definitely never use >> with the Reader monad.
22:45:38 <mjrosenb> hrmm, most of the time, my monads are State/List/Maybe
22:46:18 <yitz> mjrosenb: >> is very useful for those
22:46:34 <Peaker> for List/Maybe it is useful, but rather rarely
22:47:15 <yitz> also State - when you just want to set the state
22:48:10 <yitz> Peaker: for any MonadPlus, you'll sometimes want to say "guard cond >> ..."
22:49:05 <mjrosenb> most of the time with state, it is too long, and i resort to do.
22:49:20 <yitz> Peaker: haven't spoken to you in a while. how're things?
22:49:57 * hackagebot HDBC-mysql 0.6.5.0 - MySQL driver for HDBC  http://hackage.haskell.org/package/HDBC-mysql-0.6.5.0 (BryanOSullivan)
22:50:42 <yitz> Peaker: with snoyberg on our team, our company is doing more and more haskell stuff. exciting!
22:50:50 <yitz> no need to "hide" anymore :)
22:51:49 <mjrosenb> yitz: where do you work?
22:51:56 <Peaker> yitz: awesome! I pretty much gave up on trying to get my company to use Haskell for anything
22:52:01 <Peaker> Python and C are too deeply ingrained
22:53:53 <Peaker> People think writing anything, even a script, in Haskell dooms it to nomansland forever.. that getting employees to learn Haskell like they learn Python would be unpractical..
22:55:09 <RayNbow`TU> Python does have (unfortunately) some advantages over Haskell at the moment
22:56:52 <Peaker> sure, I think Haskell is very crappy in many ways, but it makes up for it, and then some. I think overall, Haskell would almost always be a preferable choice to Python
22:57:00 <yitz> Peaker: it's definitely harder to learn for people brought up on conventional imperative languages.
22:57:25 <ectospasm> Peaker: remember, it's harder to think in Haskell than it is procedural or OOP languages.
22:57:31 <dankna> hmm
22:57:40 <yitz> Peaker: we're a solutions company, so any technology that produces a solution on time and within budget is welcomed.
22:57:42 * RayNbow`TU would love to see an equivalent of Python's M2Crypto for Haskell
22:57:46 <dankna> anyone have any good techniques for figuring out where your infinite loop is?
22:58:17 <dankna> I poked around in the heap with gdb a bit, but this was not particularly helpful
22:58:26 <ectospasm> Peaker: the same could be said about any functional language.
22:58:28 <RayNbow`TU> (but I don't trust my crypto skills to write something like that)
22:58:40 <yitz> Peaker: if you want to point them to a local company that is using Haskell in practice and making a lot more money because of it, feel free to be in touch.
22:58:47 <ectospasm> RayNbow`TU: you know, it's probably be so simple it's sick
22:58:50 <Peaker> ectospasm: we shape our tools, and then our tools shape us
22:59:18 <ectospasm> Peaker: or, you're only as expressive as your tools let you be
22:59:24 <Peaker> yitz: sure, would like that, can you give me a link? :)
22:59:47 <Peaker> ectospasm: I don't think it's harder to think in Haskell.. Haskell sometimes condenses more "hardness" into less space
22:59:48 <ectospasm> kinda like Wittgenstein, if your language is bounded, your thoughts will be bounded
23:00:28 <ectospasm> Peaker: yes, but if you have any programming experience whatsoever (save maybe functional languages), Haskell is a very foreign beast.
23:00:32 <yitz> Peaker: we don't show anything about haskell on our page, but our site is: http://www.suite-sol.com/
23:01:20 <ectospasm> Peaker: I'm not saying that someone who knows Haskell very well has a hard time thinking in it, but it's hard--at least initially--to get to that state
23:01:39 <ectospasm> I'm still just a beginner
23:06:57 <yitz> ectospasm: but once you get there, it expands your thinking in other languages too.
23:07:37 <Peaker> ectospasm: learning to program is hard, you expect it to be significantly easier to learn your 2nd/3rd languages, but with a different paradigm it isn't, so it seems much harder than the languages of the same paradigm which were easy to learn. But probably not much harder than the first language you learned
23:07:51 <Jafet> yitz: "damn why doesn't this language have delimited continuations"
23:09:07 <ddarius> Jafet: Because delimited continuations are impure.
23:09:53 <Jafet> Wait, I thought it was the other way round.
23:10:29 <Jafet> What kind of continuation is Cont?
23:10:44 <Eduard_Munteanu> Or is this some form of hypocritical purity? E.g. impure state but not conts?
23:10:45 <ddarius> Impurities can be modeled by delimited continuations if that's what you mean.
23:11:12 <ddarius> Jafet: Undelimited continuations.  They are also impure, which is why they are modelled by a monad.
23:13:34 <Eduard_Munteanu> I thought undelimited continuations were stuff like unrestricted goto and such :/. I guess it isn't the same 'un' :)
23:14:31 <Eduard_Munteanu> (or setjmp() tricks)
23:22:03 <Jafet> Hmm
23:23:17 <Jafet> lambdabot can't direct command output at a particular nick
23:23:31 <yitz> Eduard_Munteanu: i'm not a big fan of continuations, but i sure miss those more in imperative languages than i miss setjmp() in haskell.
23:23:40 <yitz> Jafet: sure it can
23:23:53 <yitz> Jafet: /msg lambdabot @botsnack
23:23:54 * BMeph is a big fan of continuations.
23:24:05 <Jafet> That isn't yours.
23:24:07 <yitz> BMeph: yeah i know you are
23:24:39 <Jafet> In unrelated news, I may have pointed a lambdabot memo at someone named "run".
23:24:42 <Jafet> preflex, seen run
23:24:43 <preflex>  run was last seen on ##c++ 1 year, 297 days, 18 hours, 8 minutes and 47 seconds ago, saying: [14:23] <Run> Foo is POD, right?
23:25:25 <yitz> BMeph: i view them as a messy workaround for the impurity of Lisp, bolted on to Haskell </troll>
23:26:13 <ddarius> They're not in Lisp, unless you mean Scheme, in which case they certainly aren't a "work-around" for impurity.  They are an impurity.  They also aren't in Haskell.
23:26:50 <yitz> Jafet: ah. no, you can't irc-spam people with lambdabot.
23:27:40 <Jafet> Many utility bots let you direct output at someone.
23:28:00 <isomorphic> @type (\_)
23:28:01 <lambdabot> parse error on input `)'
23:28:02 <pikhq> ddarius: They most certainly are in Lisp. Manually.
23:28:11 <pikhq> ddarius: And most certainly are in Haskell. As a monad.
23:28:24 <pikhq> </pedant>
23:28:46 <isomorphic> @type \_
23:28:47 <lambdabot> parse error (possibly incorrect indentation)
23:29:29 * BMeph taps pikhq on the pedant-shoulder, to point out that he must have mean "Monad" and not "monad". Just saying... ;Ã¾
23:29:58 <BMeph> must have *meanT, rather.
23:30:29 <Jafet> The mean transformer?
23:30:58 <pikhq> BMeph: Okay, yes, good point. "Monads" certainly aren't necessarily real monads.
23:31:11 <pikhq> BMeph: Just objects with >>= and return defined.
23:31:27 <pikhq> (admittedly, not being a monad is a bug, but hey)
23:32:48 <mjrosenb> pikhq: i remember looking at haskell's continuations, and thinking that it really wasn't.
23:33:54 <pikhq> mjrosenb: It certainly seems to me that it's a straight-forward implementation of the continuation transform.
23:34:31 <pikhq> Erm, continuation-passing style transform.
23:34:42 <adrake> given typeclasses "class A a where foo :: a -> Integer; foo _ = 6" and "class (A a) => B a where bar :: a -> Integer; bar _ = 7", and a priori knowledge that the A I am holding is a B, is there a way to "cast"? Alternately, is there a better pattern for what I want to do?
23:35:31 <mjrosenb> pikhq: where are the docs for continuations? they seem to not be in the std library docs anymore.
23:35:38 <adrake> A clean solution to modeling this has eluded me for some time
23:35:42 * BMeph thinks the better pattern for that is "use C++" but doesn't want to be rude...
23:35:56 <pikhq> mjrosenb: Pretty sure it's a third-party library.
23:36:14 <pikhq> mjrosenb: Of course, if you want to do that otherwise you *could* just do CPS yourself...
23:36:26 <pikhq> All you need is closures, after all.
23:37:01 <osfameron> adrake: sounds like an XY problem.. what are you trying to achieve?
23:37:54 <adrake> osfameron: I have Instructions, which can have various properties. Immediates, branch targets, input registers, output registers, etc
23:38:23 <adrake> osfameron: all instructions have an opcode, and a list (possibly empty) of inputs, and other such
23:38:44 <adrake> some instructions have branch targets, I gave those instances of the class ControlInstruction
23:39:34 <adrake> I would like to look at a list of Instructions, find the ControlInstructions among them, and then access their targets, as an example application
23:40:30 <adrake> My first thought was data Instruction = FooInstruction X Y Z W V U T S ... | BarInstruction X Y Z V Q N | ..., but they're unwieldy and I don't get instruction classes
23:41:31 <osfameron> give the int containers a Functor instance?
23:41:48 <adrake> "int containers" ?
23:42:57 <osfameron> hmm, maybe not. might be worth you hpasting some code?
23:43:08 <issactrotts> anybody game for a cabal question?
23:43:09 <lambdabot> issactrotts: You have 1 new message. '/msg lambdabot @messages' to read it.
23:43:29 <adrake> osfameron: I don't have any code for you to read. I am still struggling to usefully model the types
23:44:14 <adrake> osfameron: I could write an example, if that would help?
23:44:32 <Liskni_si> sshc: thanks for the comments, I'll go through them later, just wanted to note that module naming etc. is simply inspired by dons' loch package
23:45:11 <issactrotts> When I try cabal install snap, it fails with "haskell98-1.1.0.1-6c0d823d8a0fe4966441285c9ec0b534 is shadowed by package haskell98-1.1.0.1-bf1e96b282ba3b444551c369795329a5"
23:48:40 <osfameron> adrake: yeah. i'm unlikely to have a good answer, but paste an example here and /somebody/ will
23:49:36 <issactrotts> help?
23:51:28 <issactrotts> i guess i'll try compiling snap directly from a tarball...
23:52:19 <mjrosenb> issactrotts: what distro?
23:52:32 <issactrotts> mac os x, snow leopard
23:57:04 <mjrosenb> erruh...
23:57:04 <mjrosenb> oh.
23:57:31 <mjrosenb> get something with a package manager? :-p
23:57:50 <issactrotts> dude, that's lame
23:58:07 <issactrotts> i have macports
23:58:25 <issactrotts> unfortunately, macports is still using ghc6 last time i checked
23:58:42 <dankna> use the Haskell Platform to get prebuilt binaries of GHC and common libraries
23:58:43 <issactrotts> and anyway, isn't cabal supposed to be the pkg manager for haskell?
23:58:45 <nkpart> issactrotts, this can end in tears, but 'cabal install snap --upgrade-dependencies --reinstall'
23:58:50 <dankna> cabal is a build tool, not a package manager
23:58:55 <mjrosenb> the issue withosx is it has package managerS
23:59:11 <mjrosenb> cabal-install on the other hand... :(
23:59:32 <dankna> cabal-install is really still just a build tool with a few package-management-like features
23:59:45 <dankna> it's best thought of as a lower layer than, say, apt-get
23:59:47 <mjrosenb> nkpart: i've never used cabal-install, but that sounds like all sorts of fun.
23:59:47 <Veid> Doesn't cabal just install everything into a single folder
23:59:50 <dankna> rather than a peer to it
23:59:58 <Veid> .cabal?
