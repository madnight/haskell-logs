00:00:06 <dibblego> the evaluation occurs from inside to out
00:00:14 <dibblego> g is first called, then h, then f
00:00:21 <Yvemath> yes.
00:00:32 <dibblego> in haskell, it is outside-in
00:00:46 <dibblego> so we could do this
00:01:04 <dibblego> > let f x y = x in f 7 (error "explode!")
00:01:05 <lambdabot>   7
00:01:17 <dibblego> in Java, this would have exploded with a runtime error
00:01:30 <dibblego> Java has "lazy" constructs in the language
00:01:48 <dibblego> boolean explode() { throw new Error("explode!"); }
00:01:50 <shachaf> So far you're describing non-strict, not lazy. :-)
00:01:57 <dibblego> false && explode()
00:01:59 <dibblego> yes
00:02:09 <Yvemath> dibblego: Okay, stop using Java, that is making this more confusing.
00:02:20 <dibblego> Yvemath: sure
00:03:03 <dibblego> Haskell is specifically call-by-need, which means values are shared
00:03:13 <Yvemath> dibblego: So how does haskell evaluates the function without evaluating the parameters ? Assuming the typeclass and type constraints ?
00:03:40 <dibblego> Yvemath: in the function above, the erroring value was not required to complete the computation
00:03:50 <dibblego> so it completed with the value 7
00:04:21 <Yvemath> I see.
00:04:29 <frerich> Yvemath: Maybe it helps to think of this: in other languages, the arguments are evaluated *before* the function is called. In Haskell, the arguments are only evaluated if their value is only actually needed.
00:04:56 <Yvemath> frerich: ah, right. Thanks.
00:05:38 <Axman6> 2^20
00:05:41 <Axman6> > 2^20
00:05:42 <lambdabot>   1048576
00:05:43 <frerich> dibblego: I never thought of saying that this evaluation is 'outside-in', that's a neat idea :-)
00:06:14 <Dashkal> That's how I finally came to terms with foldl and foldr and why somtimes I need each one
00:06:17 <dibblego> well like shachaf said, I was explaining non-strict there, which is often the hardest part about "lazy"
00:06:37 <Dashkal> I'm not clear on a difference between non-strict and lazy
00:06:42 <Dashkal> THe last article I read had them the same
00:09:38 <c_wraith> Dashkal: non-strict is a specification.  lazy is an implementation strategy for that specification.
00:10:22 <Dashkal> hmm, is there another implementation so I can get some way to see the difference?
00:10:59 <c_wraith> you can implement it with parallel eager evaluation
00:11:34 <Dashkal> to google with me
00:13:47 <Dashkal> hmm, that did not help
00:14:29 * hackagebot cryptocipher 0.2.10 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.10 (VincentHanquez)
00:15:27 <Dashkal> There we go.  Ok
00:15:29 <Dashkal> Thank you
00:16:17 <Dashkal> non-strict means only that it is not evaluated until required.  lazy or call-by-need describes the way that's done. (Yes, I realize this is what I was told)
00:17:40 <c_wraith> non-strict is even more technical than that.
00:17:57 <c_wraith> a function f is strict if f _|_ = _|_
00:18:09 <c_wraith> if f _|_ is *anything* else, it's non-strict
00:18:32 <Dashkal> so id is strict?
00:18:44 <c_wraith> yes
00:19:13 <Dashkal> definitely lost again then
00:20:03 <c_wraith> that one's simple enough, if you look at it from the right angle.
00:20:15 <c_wraith> evaluating id x will always result in evaluating x
00:20:15 <Dashkal> hmm, incidently, it turns out that the language I was hacking on last year used call-by-name, not call-by-need.
00:20:35 <shachaf> Here's another strict function: const undefined
00:22:31 <Dashkal> hmm, not clicking for some reason.  Not sure what I'm hung up on.
00:22:50 <Dashkal> some assumption I have to break I'm going to guess
00:23:27 <c_wraith> well.
00:23:42 <c_wraith> let's look at f x = [x]
00:23:47 <Kaidelong> function maps any parameter x _|_ to a result _|_ == function is strict on x
00:24:15 <c_wraith> f undefined = undefined : []
00:24:28 <c_wraith> there's a data constructor at the top level there
00:24:42 <c_wraith> so the result is not a bottom
00:24:48 * Dashkal rewrites to f undefined = Cons undefined Nil.  Ok, gotcha
00:24:49 <c_wraith> so that particular f isn't strict
00:27:01 <c_wraith> (:) undefined []
00:27:04 <c_wraith> but yeah.
00:27:19 <c_wraith> the value is more-defined than just bottom, even if it's not fully-defined
00:27:55 <Dashkal> *nods*
00:28:25 <Dashkal> So to be non-strict, you really have to hit a constructor
00:28:32 <Dashkal> or be const
00:28:33 <c_wraith> or a lambda
00:28:55 <c_wraith> f x = \y -> undefined
00:28:58 <Dashkal> Which really is a type constructor
00:30:38 <shachaf> Without seq, const undefined is indistinguishable from undefined.
00:31:37 <Dashkal> seq is something I have yet to grasp, but I think I may wait on that
00:31:50 <Dashkal> fix is also on the list of things I want to figure out the point of.
00:32:30 <c_wraith> the point?  fix doesn't have a strong point.  but it's an abstraction of...  well...  recursion. :)
00:32:47 <Dashkal> Yeah, I haven't wrapped my head yet around how that is.
00:32:51 <shachaf> Dashkal: seq is strict in its first argument, and then returns its second argument.
00:32:53 <Dashkal> I tried a couple nights ago
00:33:05 <Axman6> Dashkal: basically any function you can write with explicit recursion you can write with fix
00:33:16 <Dashkal> Ok, not both at once!
00:33:46 <Axman6> > let fibs 0 = 0; fibs 1 = 1; fibs n = fibs (n-1) + fibs (n-1) in fibs 10
00:33:46 <lambdabot>   512
00:33:47 <frerich> Dashkal: I think you're in a similiar situation like me. :-) 'strictness' and 'fix' and 'seq' are also the things which always make me doubt even if I thought that I grasped what' sgoing on
00:34:00 <Dashkal> ok, seq first
00:34:13 <Dashkal> I don't undestand how it matters that it was strict in its first argument if its getting discarded.
00:34:35 <Axman6> > let fibs x = fix (\f n -> case n of 0 -> 0; 1 -> 1; n -> f (n-1) + f (n-2)) in fibs 10
00:34:36 <c_wraith> > seq undefined 5
00:34:36 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
00:34:36 <lambdabot>    arising from a use of ...
00:34:37 <lambdabot>   *Exception: Prelude.undefined
00:34:40 <Axman6> bah
00:35:03 <Axman6> > let fibs x = fix (\f n -> case n of 0 -> 0; 1 -> 1; n -> f (n-1) + f (n-2)) x in fibs 10
00:35:04 <lambdabot>   55
00:35:22 <Axman6> also, helps if you write the original definition correctly =)
00:35:26 <shachaf> Dashkal: Good explanation of the applicative-order Y combinator (which is more complicated than necessary, but still): http://www.ccs.neu.edu/home/matthias/BTSS/sample.ps
00:36:26 <Dashkal> The Y combinator makes my head hurt.  I've read more than one article on it.  Wonder if this is more accesable.
00:36:39 <Dashkal> I only understand the basics of the lambda calculus.
00:36:52 <shachaf> Dashkal: Another good explanation: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/026.HTM
00:37:22 * shachaf wonders whether the untyped lambda calculus has non-basics.
00:37:37 <Dashkal> yeah that isn't going to work for me.  I can't read the FAC expression.
00:37:54 <shachaf> Dashkal: Oh. Go earlier in the book, then; it's a good introduction.
00:37:59 <Dashkal> As mentioned, I know only the very basics of the lambda calculus.  This doesn't yet include the encodings for numbers.
00:38:21 <shachaf> Dashkal: Just pretend those are numbers.
00:38:23 <shachaf> Like in Haskell.
00:38:27 <Dashkal> It definitely doesn't include the encodings for -
00:38:32 <Dashkal> or *
00:38:48 <Dashkal> or IF, or = :P
00:39:00 <shachaf> IF = id :-)
00:39:11 <Dashkal> My point is without any of these things its building on, how am I to grasp Y?
00:39:15 <shachaf> But all those things are irrelevant.
00:39:30 <shachaf> The encodings don't matter that much; you know how they behave.
00:44:42 <Dashkal> Yeah, still not grasping what it's trying to convey
00:47:41 <Dashkal> meh, another day.  It's getting late.
00:52:00 <tibbe> .
00:52:37 <kosmikus> ;
00:54:41 <gienah> @tell Eduard_Munteanu darcs build of agda is in the gentoo haskell overlay, emerge sci-mathematics/agda-executable
00:54:41 <lambdabot> Consider it noted.
01:05:00 <Phyx-> I feel like python's laughing at me
01:05:46 <Phyx-> hah, finally!
01:13:48 <Eduard_Munteanu> gienah: oh, neat!
01:13:48 <lambdabot> Eduard_Munteanu: You have 1 new message. '/msg lambdabot @messages' to read it.
01:13:53 <Eduard_Munteanu> @messages
01:13:53 <lambdabot> gienah said 19m 12s ago: darcs build of agda is in the gentoo haskell overlay, emerge sci-mathematics/agda-executable
01:14:55 <Eduard_Munteanu> Thanks.
01:22:11 <Eduard_Munteanu> Do you guys happen to know online resources comparing theorem proving based on dependent types / Curry-Howard vs more ad-hoc stuff like logical frameworks?
01:27:37 * hackagebot hakyll 3.1.2.0 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.2.0 (JasperVanDerJeugt)
01:42:12 <mjrosenb> gienah: sweet!
01:42:31 <blueonyx> hi, slightly offtopic, but does someone know how to make limits.conf apply to an xmonad session?
01:53:36 <synonymous> blueonyx: xmonad channel?
01:57:41 * hackagebot timeplot 0.3.3 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.3 (EugeneKirpichov)
02:01:46 <Axman6> make
02:01:47 <Axman6> whoops
02:02:12 <Eduard_Munteanu> Nothing to be done for 'whoops'.
02:02:12 <Eduard_Munteanu> :P
02:02:39 <Axman6> echo whoops: clean >> Makefile
03:08:45 <merijn> Lambdabot is MIA? :(
03:12:14 <Eduard_Munteanu> @bot
03:12:20 <Eduard_Munteanu> :(
03:13:19 <shachaf> preflex: botsnack
03:13:19 <preflex>  yum
03:41:05 <ivanm> I'm currently hacking on graphviz again; does anyone have any suggestions on how to improve the API?
03:41:32 <Ke> make it work with utf-8
03:41:34 <Ke> !
03:41:43 <Phyx-> ivanm: personally, I would like it to be able to generate large images
03:41:54 <Phyx-> but i guess that's a libpng limit or something
03:42:04 <ivanm> Ke: done!
03:42:09 <ivanm> Phyx-: yup
03:42:12 <Ke> ivanm: really?
03:42:53 <ivanm> that's why I use svg
03:42:59 <ivanm> Ke: it's Text-based now
03:43:27 <Phyx-> yeah, i'm using svg now too
03:43:34 <Phyx-> the .pdf also produces nonsense
03:43:34 <Phyx-> lol
03:43:42 <Phyx-> .svg was the only one that worked
03:44:25 <Ke> ivanm: I have no idea what that means
03:44:42 <ivanm> Ke: I use Text rather than String internally, and force UTF-8 throghout
03:45:07 <Ke> oh you mean haskell wrapper for graphviz
03:45:34 <ben> is text using utf-8 now?
03:45:41 <ivanm> Ke: yeah
03:45:51 <ivanm> Ke: but upstream graphviz uses utf-8 by default
03:45:55 <Ke> it's actually the graphviz itself that fails a with diaresis
03:46:03 <ketil> ben: no, there's a GSOC project for it.
03:46:12 <ivanm> ben: no, but I'm using explicit encoding/decoding functions with it
03:46:20 <ivanm> Ke: :o
03:46:23 <ben> Okay, makes sense :3
03:47:19 <ketil> ivanm: I have a program that just generates a dot file.  Maybe I should look at the graphviz interface to see if I'd better bind directly?
03:47:53 <ivanm> ketil: well, I've spent ages making sure the output is correct, etc.
03:48:16 <ivanm> and I'd appreciate knowing _why_ people don't use it and output dot directly
03:48:48 <ivanm> my current main focus now that I've done the Text migration is to improve the API to make it easier to use
03:49:08 <ketil> :-)
03:49:45 <ketil> Reason for not using: I didn't think about it.
03:49:49 <ivanm> heh
03:50:18 <ketil> It's more, hey, I need to draw some dots with lines, let's just generate a dot file and use graphviz.  And then it grew from there.
03:50:54 <ivanm> heh
03:51:07 <ivanm> I'm thinking of making a monadic interface ala dotgetn
03:51:26 <ivanm> *dotgen
03:52:25 <ClaudiusMaximus> ivanm: i have some code that generates dot text, some things bit me (like trying to create a node called 'graph' (without quotes)) so i should really use a robust library :)  no time to hack on it for a few weeks though...
03:52:46 <ivanm> ClaudiusMaximus: yeah, I've spent _ages_ finding little subtle points like that
03:54:36 <ClaudiusMaximus> ivanm: where is the current graphviz code (or api documentation)? (or rather, where will it be in 2-3 weeks?)  my code is here, fwiw http://claudiusmaximus.goto10.org/cm/2011-04-13_word_edit_graphs.html
03:54:53 <ivanm> code.haskell.org/graphviz
03:55:34 <ClaudiusMaximus> ivanm: thanks, bookmarked
03:55:54 <ivanm> the overall API is currently almost identical to the one on hackage, once you do s/String/Text/g
03:56:11 <ivanm> there's also project.haskell.org/graphviz for pretty README, etc.
03:56:39 <ivanm> I have some tutorials in the works; the main thing stopping them being released is that I keep coming across something that needs to be added to the library first...
03:56:49 <ClaudiusMaximus> ivanm: projects. (typo) but i found it, thanks
03:56:56 <ivanm> e.g. support for tred
03:56:59 <ivanm> ClaudiusMaximus: oh, right
03:57:59 <ivanm> I've currently got most of a re-implementation of "dot -Tcanon" in haskell done (need to check some corner cases) and am planning on a tred implementation (but that will also do canonicalisation; no real way of going through an arbitrary graph and manipulating it yet)
04:01:21 <ivanm> ClaudiusMaximus: as you've got it though, may I suggest "dot -TXlib" rather than "dot -Tpng | display -" ?
04:02:08 <ClaudiusMaximus> ivanm: aha, that would probably be better indeed
04:03:47 <ClaudiusMaximus> ivanm: just tried it, works with -Txlib (case sensitive..)
04:03:59 <ivanm> yeah, couldn't remember which one
04:04:03 <ClaudiusMaximus> :)
04:04:08 <ivanm> there's also -Tgtk if you installed that version
04:04:16 <ivanm> use "dot -Txxx" to work out what you have installed
04:04:31 <ClaudiusMaximus> yep, i got a list
04:04:33 * ivanm is contemplating doing some kind of mangling based on that at build-time for graphviz, but probably won't
04:27:02 * ivanm wonders how close to actual "dot -Tcanon" his function should act like
04:27:15 <ivanm> e.g. given an empty sub-graph, it will show it; should I bother?
04:27:38 <ivanm> duplicating the behaviour leads to easier testing; that's the only real advantage I can think of
04:31:13 <magicman> Where's HWN these days? Haven't seen it pop by on Planet Haskell or on the mailing lists in a long time... (though this may mean I'm not looking carefully enough).
04:31:49 <ben> It's posted on reddit, at least.
04:31:55 <ivanm> and on the mailing lists
04:32:01 <ben> http://www.reddit.com/user/dstcruz
04:32:04 <ivanm> well, haskell@ and haskell-cafe@ anyway
04:32:21 <ben> http://www.reddit.com/domain/contemplatecode.blogspot.com/ might be more relevant.
04:32:24 <magicman> Huh. I watch haskell and -cafe. Must've overlooked it.
04:32:25 <ivanm> but it's gone mainly into "let's list which stories have appeared on Reddit and SO" :s
04:32:38 <ivanm> (rather than summarising discussions on the mailing lists)
04:32:57 <ben> To be honest, I mostly read it for the #haskell quotes anymore since I barely manage to pay attention to the channel anymore.
04:32:59 <magicman> Yeah, I don't follow reddit *or* SO, so I relied on HWN to filter out the really interesing things :p
04:33:31 <magicman> (and also discussion in blog comments, as I don't read those either, unless it's somthing I participate in, or if HWN tells me it's interesting)
04:35:15 <magicman> I... think I've come to the conclusion that I just fail at web 2.0 >_<
04:37:56 <ivanm> magicman: you should feel proud!
04:40:59 <nuferup> hi
04:41:17 * ivanm waves idly in nuferup's general direction
04:52:55 <MODB> hello, anybody active here?
04:53:58 <m3ga> MODB: usually there is.
04:54:21 <m3ga> you should probably just ask your question
04:54:30 <MODB> i see
04:54:40 <MODB> i am a first time haskell user
04:54:52 <MODB> and i would like some help with installing problems
04:55:07 <m3ga> what OS?
04:55:25 <MODB> Windows Vista
04:55:50 <MODB> i downloaded the haskell platform
04:55:56 <m3ga> i'm don't use windows, but state what problems you're having and someone else should be able to help
04:56:14 <MODB> ran the exe on my laptop
04:56:14 <MODB> but now i got a bunch of other exe files
04:56:24 <MODB> i have no idia which one to use for Windows Vista
04:56:38 <MODB> ok thank you very much
04:58:54 <whald> MODB: so you installed the haskell platform from http://hackage.haskell.org/platform/windows.html ?
04:59:13 <MODB> one sec
04:59:24 <MODB> ill check where i got it from
05:00:40 <MODB> yes, indeed, I got it there
05:01:15 <MODB> i got to save the exe file on my desktop
05:01:40 <MODB> i ran the exe
05:01:50 <MODB> that installs the software i guess
05:02:04 <whald> MODB: so that's a good thing to start with. honestly i use haskell platform only on mac and linux, but under windows running the .exe should install it. whatever "install" means on windows :-)
05:02:07 <MODB> now i only have a map in my program files with alot of exe files
05:02:23 <MODB> true
05:02:29 <whald> MODB: ok, i guess that's ok so far
05:02:37 <whald> can you launch a console?
05:02:46 <MODB> hm
05:03:05 <MODB> well, in windows you get alot of maps with submaps
05:03:12 <whald> from the start menu choose "Run..."
05:03:15 <MODB> all exe files that i could run
05:03:33 <MODB> they removed the run function on vista
05:03:42 <MODB> at least they hid it somewhere
05:03:43 <whald> MODB: oh my
05:03:58 <Phyx-> MODB: press the windows button on your keyboard along with r
05:04:00 <MODB> on xp i know it exists
05:04:07 <whald> MODB: i guess you'll have to dig it, i doubt you can use the haskell platform without the console
05:04:10 <Phyx-> MODB: or just go to start and type "cmd"
05:04:21 <MODB> ok ok
05:04:30 <MODB> the windows thing with r helped
05:04:35 <MODB> i got the runthing again
05:04:48 <Phyx-> MODB: now type cmd
05:04:50 <Phyx-> and press enter
05:04:59 <MODB> ok
05:05:09 <whald> Phyx-: ok, thanks for taking over, windows is just to strange for me :-)
05:05:15 <MODB> got a black window with a folderthing in it
05:05:17 <Phyx-> the two important executables for haskell are ghc, the compiler and ghci, the interpreter
05:05:21 <whald> Phyx-: that is, anything after win2k...
05:05:31 <applicative> Phyx-. saving the day as usual
05:05:31 <Phyx-> MODB: if you type ghci and press enter it'll start the haskell interpeter
05:05:41 <Phyx-> whald: lol, yeah, i use windows alot
05:06:03 <Phyx-> applicative: lol, only when it comes to windows :P
05:06:25 <MODB> ok
05:06:30 <MODB> im following thusfar
05:06:32 <applicative> it's happened before.
05:07:12 <MODB> so when prelude\
05:07:23 <MODB> so when prelude> appears im in haskell?
05:07:26 <applicative> you see prelude>
05:07:36 <applicative> youre  there.  paradise!
05:07:41 <MODB> really
05:07:48 <Phyx-> MODB: ok, so that's the haskell interpreter, you can use that to evaluate expressions and functions aswel as load modules.
05:08:08 <MODB> im inside haskell now?
05:08:14 <Phyx-> MODB: if you create a file with the extensions .hs that'll create a haskell source file
05:08:15 <MODB> ok
05:08:23 <applicative> yes, the REPL or interpreter or whatever
05:08:23 <MODB> k
05:08:41 <MODB> ok thanks so far
05:08:47 <Phyx-> MODB: what are you using to learn haskell?
05:08:51 <applicative> the next business is to find an editor to write an .hs file
05:09:12 <Phyx-> MODB: http://book.realworldhaskell.org/read/getting-started.html you should read that
05:09:15 <MODB> im using some try haskell helpfile from the net
05:09:21 <MODB> great thanks alot
05:09:21 <Phyx-> ah
05:09:32 <applicative> @where LYAH
05:09:49 <Phyx-> I've Heard learn you haskell is easier, but I've never read it, only RWH
05:09:55 <applicative> MODB have you written in other programming languages?
05:10:07 <MODB> never
05:10:12 <applicative> Learn You a Haskell is good
05:10:35 <MODB> my purpose is not to learn Haskell to deeply
05:10:40 <MODB> unless i have no choice
05:10:47 <applicative> MODB, so you need something to write programs in.  At the moment it will be NotePad.
05:10:55 <MODB> i have some software that i need to run that is based on haskell
05:10:56 <Phyx-> it's ok, it'll lure you in :)
05:11:12 <MODB> yeh i have only notepad as textthing
05:11:16 <MODB> :)
05:11:20 <applicative> It's fine.
05:11:43 <Phyx-> If you only need to run a haskell program you don't need to know haskell though.
05:12:00 <Phyx-> does the software you want to run have a file ending in .cabal ?
05:12:02 <MODB> i think i do a bit
05:12:07 <MODB> cuz getting the program running needs me to know the commands
05:12:12 <MODB> yeh
05:12:14 <MODB> it has
05:12:17 <MODB> sec
05:12:23 <MODB> ill send some info on the programme
05:12:39 <MODB> its a bioinformatics programme called flower
05:13:03 <applicative> I was going to say, he needs to know about cabal.exe.  Do you have to put it in path, or maybe the platform install does that.
05:14:05 <MODB> wait wait
05:14:09 <MODB> youre losing me
05:14:19 <Phyx-> MODB: you in that black window?
05:14:24 <Phyx-> type
05:14:25 <Phyx-> :q
05:14:27 <MODB> cabal.exe whats that?
05:14:29 <Phyx-> and press enter
05:14:31 <Phyx-> and then type
05:14:35 <Phyx-> cabal install flower
05:14:37 <applicative> MODB, i was talking to phyx, there, but about you
05:14:44 <MODB> k
05:14:53 <Phyx-> applicative: no, the platform already fixes the paths afaik
05:15:10 <MODB> so the black window is still on prelude
05:15:16 <applicative> type :q
05:15:19 <MODB> when i type q its errors
05:15:24 <applicative> semicolon
05:15:27 <applicative> no
05:15:32 <applicative> colon q
05:15:33 <applicative> :q
05:15:38 <MODB> i guess you mean in the windows run
05:15:44 <MODB> type q?
05:15:58 <MODB> kkkk
05:16:03 <applicative> are you still 'on Prelude'?
05:16:06 <Phyx-> you need to type :q where it says Prelude>
05:16:13 <MODB> i see
05:16:15 <MODB> its quit?
05:16:17 <Phyx-> yes
05:16:19 <applicative> that puts you back in the plain console
05:16:20 <MODB> kk
05:16:30 <MODB> what do you call that console?
05:16:31 <applicative> now type "cabal --version"
05:16:36 <applicative> to see if it's there
05:17:18 <applicative> cabal.exe --version
05:17:45 * applicative is failing to leave this to phyx- ; he should find the windows laptop downstairs :)
05:18:03 <MODB> omg
05:18:06 <Phyx-> MODB: are you back outside the Prelude
05:18:16 <MODB> im in the windows console
05:18:19 <Phyx-> ok
05:18:20 <Phyx-> type
05:18:25 <Phyx-> cabal update
05:18:30 <MODB> tried that cabal version check but no command will work
05:18:48 * applicative is getting the laptop
05:19:56 <MODB> ok the console tells me it is supposedly getting a version from the net
05:19:59 <MODB> i think
05:20:10 <Phyx-> MODB: ok, let it finish
05:20:23 <MODB> downloading the latest package list from hackage is ok?
05:20:27 <Phyx-> yes
05:20:29 <MODB> ok
05:20:31 <MODB> finished
05:20:58 <Phyx-> ok, now type cabal install flower
05:21:39 <MODB> running
05:22:49 <Athas> Does threadDelay pause all Haskell threads, or only the running one?
05:23:02 <ivanm> @hoogle threadDelay
05:23:11 <Athas> (That is, if I have spawned two threads with forkIO on a single-threaded runtime, will delaying one also stop the other?)
05:23:12 <ivanm> preflex: seen lambdabot
05:23:12 <preflex>  lambdabot was last seen on #haskell-blah 3 hours, 45 minutes and 29 seconds ago, saying: [9 @more lines]
05:23:39 <applicative> MODB flower has several depencies, so first cabal install needs to get them and compile the.
05:23:43 <Athas> The docs are not explicit about it, but they have a paragraph about blocking behaviour of foreign calls above them.
05:24:41 <MODB> its doing that outomatically right?
05:24:47 <applicative> in theory yes
05:24:53 <applicative> delicacies can arise :)
05:25:05 <MODB> i see
05:25:09 <MODB> ill be patient
05:25:13 <applicative> but it's still going on?
05:25:14 <MODB> its still running
05:25:30 <applicative> the longer it takes the more evidence we have that your installation is basically sound :)
05:26:24 * applicative wonders if Ketil Malde is ever on #haskell
05:26:45 * ketil wonders why applicative wonders that.
05:27:04 <applicative> hey, ketil MODB is trying to install flower
05:27:19 <ketil> Oh, sorry.  I only wake up when somebody mentions my name :-)
05:27:29 <ketil> Hi MODB.
05:27:33 <applicative> MODB, the author is here.
05:27:37 <ketil> Give me a sec to rewind.
05:28:58 <ketil> Well, it looks like you are in good hands.  There should be a bit of output while it's working.  Are you on an exotic system?  Windows, maybe?
05:29:13 <applicative> MODB, you there.
05:29:27 <applicative> ?
05:29:41 * ketil shrugs.  Guess it worked, then :-)
05:29:45 <applicative> MODB is using Vista with a fresh platform
05:29:58 <Phyx-> hahaha, exotic system :)
05:30:38 <applicative> Uh oh.
05:31:08 <MODB> gotta love windows
05:31:16 <applicative> ah MODB, your'e back
05:31:26 <MODB> CRASH
05:31:29 <MODB> :)
05:31:50 <MODB> but only right after the install completed
05:31:55 <applicative> did the "cabal install flower" process finish?
05:31:59 <Phyx-> why did it crash?
05:32:02 <MODB> it installed actually the latest version of flower
05:32:12 <Phyx-> what did the bluescreen say?
05:32:24 * Phyx- shuts up
05:32:25 <MODB> no bluescreen
05:32:25 <Phyx-> lol
05:32:36 <MODB> just froze over
05:32:43 <MODB> had to force quit all
05:32:50 <Phyx-> weird..
05:32:59 <MODB> prob laptop related
05:33:16 <MODB> can i first check wheter the install was successfull?
05:33:41 <applicative> hm.  open the console again and see if "flower --version" looks good
05:34:14 <MODB> i need to add the ""?
05:34:21 <Phyx-> no
05:34:32 <MODB> kk
05:34:34 <MODB> i got it
05:34:39 <ketil> We should have \texttt{...} on IRC.
05:34:44 <Athas> So, to profile a Haskell program, I have to install profiled versions of all its library dependencies?
05:34:48 <MODB> says flower 0.7 which is good
05:35:12 <applicative> Athas, yes.  You can do a cabal install --reinstall
05:35:13 <MODB> its the latest version
05:35:20 <Phyx-> ketil: could always do bold type flower --version and see if it looks good
05:35:31 <applicative> MODB do you have some sff files?
05:35:33 <Phyx-> or colors, lol, but some hate that
05:35:45 <Athas> applicative: nasty.  But thanks.
05:36:04 <MODB> i will have sff files do deal with thats the whole purpose indeed
05:36:50 <MODB> output from a machine that needs to get converted to textfiles or whetever that is more userfriendly
05:37:09 <Phyx-> Athas: yeah, unfortunately, which is why i added in my cabal conf file to always build the profiled version aswell
05:37:22 <Athas> Phyx-: how do you do that?
05:37:26 <Phyx-> it's useful when you have a new ghc install, not so much on an old one
05:37:28 <applicative> Athas, it's not too bad, I'm did it a couple of days ago, since it wasnt in my conf file
05:37:38 <applicative> and I had the new Platform
05:37:47 <cinch> im trying to compile gtk (cabal install gtk) and ghc runs out of memory (http://pastext.net/3147) how can i fix this?
05:37:55 <Phyx-> Athas: what are you using?
05:38:27 <Athas> Phyx-: GHC 7.0.3 and Cabal 1.8.0.2.
05:38:51 <cinch> btw, i have enough ram (3 gigs)
05:39:00 <Phyx-> Athas: i meant os
05:39:10 <applicative> MODB, you can do it with the console.  A fancier version of that sort of thing exists as well for windows, as for the text editor, notepad is not too great
05:39:16 <Athas> Phyx-: oh, Linux.
05:39:22 <ivanm> Athas: how can you be using Cabal 1.8.0.2?
05:39:34 <ivanm> since 7.0.* comes with 1.10.*
05:39:44 <Athas> ivanm: that's what cabal --version tells me.
05:39:46 <Athas> One moment.
05:39:50 <Phyx-> Athas: ah, i don't know where the conf is, but you need to uncomment library-profiling and executable-profiling in the conf file and set them to true
05:40:01 <MODB> applicative what would you suggest to use in stead of notepad
05:40:06 <Athas> Good question.  Maybe my cabal-install is older?
05:40:06 * Phyx- is using cabal 1.11.0
05:40:08 <ivanm> Athas: upgrade cabal-install
05:40:09 <ryant5000> ivanm: i think i encountered the the same problem: after a clean install of ghc-7.0.3, if i run cabal install cabal-install, it installs an old version
05:40:22 <ivanm> ryant5000: yeah, because of the default
05:40:24 <ivanm> *defaults
05:40:27 <ivanm> just specify the version
05:40:44 <ryant5000> ivanm: yeah, i figured that out eventually, but i suspect that many people will run into the same issue
05:40:52 <ryant5000> ivanm: how come the default isn't a newish version?
05:41:04 <applicative> MODB, Phyx will know. I have used NotePad++
05:41:06 <ivanm> because I'm guessing dcoutts hasn't updated it
05:41:11 <ivanm> preflex: seen dcoutts
05:41:11 <preflex>  dcoutts was last seen on #ghc 17 minutes and 41 seconds ago, saying: :-)
05:41:29 <Phyx-> MODB, Athas i use notepad++ too
05:41:45 <MODB> ok thank you very much
05:42:09 <MODB> and i would like to thank all the people that helped me so far
05:42:16 <applicative> as for getting something nicer than the Windows command prompt, there are again various options.
05:42:43 <Phyx-> Athas: the config file is ~/.cabal/config
05:42:48 <applicative> MODB, it's fine, this is one of the purposes of #haskell.
05:43:14 <MODB> ill keep my programs basic untill needed otherwise
05:43:23 <MODB> ill try out notepad++
05:43:36 <applicative> MODB, it looks like for the use of flower itself you don't need to write any haskell.
05:43:39 <Athas> Phyx-: yes, but what should I wrote in it?
05:43:49 <MODB> yes indeed
05:43:54 <MODB> thats what i thought
05:43:58 <Phyx-> Athas: you need to uncomment library-profiling and executable-profiling in the conf file and set them to true
05:44:01 <MODB> accept to install it
05:44:13 <MODB> cuz you get no .exe files
05:44:24 <Athas> I don't have those fields, but I assume they're just 'library-profiling: true'?
05:44:38 <applicative> MODB, type this:  flower --help
05:45:03 <Phyx-> Athas: yes
05:45:56 <Phyx-> odd... the windows and *nix config files aren't the same?
05:46:15 <Athas> My configuration file is very old, maybe those defaults weren't added back then.
05:46:34 <Phyx-> aha
05:47:13 <MODB> ok, the information from the help command on flower is shown
05:47:23 <MODB> i will check some of the cammands now
05:48:28 <applicative> MODB, you saw the webpage for it http://biohaskell.org/Applications/Flower ?
05:49:19 <Athas> Is there a trick to make ld use less memory when linking Haskell programs?
05:49:22 <applicative> ketil are you there? I wonder if the test.sh will run on windows.
05:49:28 <Athas> I recall reading about a workaround on ghc-cvs, but I don't remember the specifics.
05:49:32 <ketil> Probably not?
05:50:23 <Phyx-> applicative: it would under msys or cygwin
05:50:26 <applicative> MODB, at the moment, the simplest thing would be to navigate to a director where you have an sff file stored.
05:50:30 <Phyx-> not standard cmd
05:51:03 <cinch> help! ghc: out of memory (requested 1048576 bytes)
05:51:20 <cinch> is there a way to give ghc more memory?
05:51:22 <applicative> MODB, then you can start seeing how flower works.   It is likely we can make interaction with it simpler.
05:51:27 <ezyang> check +RTS -?
05:51:47 <Phyx-> wow, i've never seen ghc run out of memory before
05:51:56 <Phyx-> unless i had a fancy type error
05:52:04 <ketil> MODB: I developed this on Linux, so it's just a simple command line tool, designed to fit into that paradigm.  I'm fairly impressed that it compiles at all on Windows, that's entirely to the credit of GHC and Cabal developers. :-)
05:52:10 <cinch> Phyx-, happens everytime i do "cabal install gtk"
05:52:45 <ketil> To use it, you'll have to work in CMD or whatever the command line interface you have available.
05:52:47 <applicative> ketil, indeed. It is more and more the case.  OS X is in some ways more difficult, though that is changing incredibly fast too
05:53:08 <Phyx-> hrm.. either gtk is very large, or something's wrong
05:53:10 <dcoutts> cinch, Phyx-: I think it can happen if ghc reads certain kinds of corrupted .hi files
05:53:30 <ketil> Phyx-, or both?
05:54:32 <Phyx-> dcoutts: hmm does ghc have any command to verify the the intergity of the interface files?
05:54:40 <Phyx-> does check do that?
05:54:45 <ketil> Anyway, for flower, it's helpful to have the option to pipe output to e.g. head.  You don't really want 1M lines of text in your terminal window, and that's just the more terse output formats :-)
05:55:08 <ketil> Blame 454 for producing so damn effective instruments.
05:56:02 <applicative> MODB, still there?
05:56:34 <dcoutts> Phyx-: no I don't think so
05:57:26 <cinch> so when GHC runs out of memory... is there a way to increase the maximum? it seems gtk needs that much to compile
05:58:40 <Phyx-> cinch: +RTS
05:58:53 <Phyx-> e.g +RTS -M128m
05:58:59 <Phyx-> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/runtime-control.html
06:00:09 <Phyx-> /docs/latest is a stable link right? It won't be going away again?
06:00:12 <cinch> ty that helps
06:03:38 <cinch> trying again with  export GHCRTS='-M2G'
06:08:00 <edka> @help
06:08:10 <applicative> MODP, still around?
06:08:36 <applicative>  > lambdabot: edka how can I help you?
06:09:06 * applicative considers changing nick to lambdab0t
06:09:55 <MODB> im back
06:10:00 <MODB> im at the office
06:10:07 <MODB> so sometimes i have to run around
06:10:17 <applicative> MODB, good.  do you have some .sff files on your machine?
06:10:43 <MODB> not yet
06:10:52 <MODB> a company will provide them next week
06:11:20 <MODB> perhaps i can download some files to start practising with?
06:11:34 <Athas> If I have to rebuild everything with profiling options, I might as well build dynamically linked versions as well!
06:11:48 <Athas> Maybe it can cut down on the the 3.9MiB size of my dmenu clone.
06:12:11 <applicative> MODB, yes, thats what I was thinking, you just need to see how to use flower in this form.
06:12:18 <Phyx-> Athas: i use strip and upx for that :)
06:12:21 <applicative> MODB ketil has an example at http://malde.org/~ketil/test.sff
06:12:33 <Phyx-> shaves a lot off the exe while keeping the rts contained
06:12:34 <MODB> ty let me check, sec
06:13:01 <ketil> MODB: may I ask what your experiment is?
06:13:07 <Athas> Strip doesn't do much for me, and startup latency is every more important than executable size...
06:13:17 <applicative> maybe you should make a little directory called flower or flowertest and put it in that.  then we can navigate to the directory in Command Prompt and use flower on it
06:13:44 <Phyx-> Athas: upx's overhead isn't that much afaik
06:13:44 <MODB> we have a 454 experiment that finished last week
06:14:02 <MODB> i need to start interpreting the data next week
06:14:05 <MODB> but its my first time
06:14:26 <applicative> MODB, yes we'll stay away from those files for the moment!
06:14:40 <MODB> yy
06:14:42 <MODB> i know
06:14:48 <MODB> thats why i need exercise
06:14:53 <MODB> so
06:15:03 <MODB> i dl'ed the sff file to my desktop
06:15:55 <MODB> so should i first put it in a map on the desktop or somewhere else?
06:15:58 <applicative> still, make a new directory and put it in that.
06:16:31 <applicative> MODB it doesn't matter, flower can output files, we don't want them all over the place.
06:16:48 <MODB> the sff testfile is in a map on my desktop
06:18:15 <applicative> somehow i'm not familiar with 'map' is it the same as folder or directory?
06:18:22 <MODB> yes
06:18:46 * Twey has never heard of that, either
06:18:58 * Phyx- has
06:19:08 <Phyx-> it's the dutch word for folders
06:19:08 * luite too
06:19:09 <applicative> MODB, okay, so open command prompt again, we will navigate to it and use flower
06:19:10 <MODB> all are Mac users?
06:19:12 <Twey> Haiku terminology or something?  Or have Apple decided to rename another common concept and claim it as their own?
06:19:25 <Twey> Phyx-: Huh
06:19:29 <applicative> MODB, there's a lot of programmers here, they use whatever is most esoteric
06:19:37 <MODB> i see
06:19:42 <Twey> Haha
06:19:43 <MODB> im trying my best to follow
06:19:52 <MODB> command is open still
06:19:56 <Phyx-> Twey: hm?
06:19:57 <applicative> MODB, there are plenty of rational people around too :)
06:20:05 * applicative isn't sure he counts as rational though
06:20:09 <Twey> Phyx-: I didn't know that.
06:20:11 <MODB> :p
06:20:37 <Twey> Though I guess one could see a directory as Map FilePath FileSystemObject :þ
06:20:46 <earthy> why?
06:21:01 <earthy> it's just a [FileSystemObject]
06:21:02 <applicative>  MODB at the command prompt, you will be at your person basic directory, ...Users/modb or whatever
06:21:11 <MODB> indeed
06:21:17 <Twey> earthy: Because it's accessed by filename, and the filenames must be unique
06:21:24 <applicative> then you list files with DIR or typing dir
06:21:37 <earthy> Twey: true enough
06:22:11 <MODB> is command case sensitive
06:22:13 <MODB> ?
06:22:42 <Twey> MODB: What command?
06:22:55 <MODB> command prompt
06:22:57 <fosskers> hey guys, what's the sexiest way to define the values of a custom data type across multiple lines?
06:22:57 <fryguybob> MODB: No, but arguments to commands can be.
06:23:00 <applicative> maybe it should be all caps?  I have the superadded bash equivalent as well
06:23:05 <Twey> MODB: Oh, you're using Windows?
06:23:10 * Phyx- opens his latex editor and straps himself down
06:23:19 <applicative> yeah, MODB is on WIndows
06:23:25 <applicative> is DIR
06:23:46 <applicative> or DIR followed by enter/return , is it showing anything
06:23:49 <Twey> fosskers: We usually line up the | under the =
06:24:01 <Twey> fosskers: But I like GADT syntax, which is neat for other reasons too.
06:24:04 <fosskers> thanks Twey. where would a deriving go?
06:24:20 <earthy> lined up under the |
06:24:24 <Twey> fosskers: Under all of them, with the ‘d’ in the | column
06:24:27 <Phyx-> wow, i haven't typed "dir" in ages
06:24:29 <fosskers> thanks :)
06:24:43 * fosskers goes back to learning about data types
06:24:44 <MODB> DIR filename (enter) worked
06:24:48 <applicative> Phyx- what do you type
06:24:53 <Phyx-> applicative: ls :)
06:24:54 <Twey> Phyx-: When I'm on a DOS machine, the first thing I do is ‘type "dir" > \windows\system32\ls.bat’ :þ
06:24:54 <fryguybob> Phyx-: hehe
06:25:11 <Phyx-> Twey: I just use powershell
06:25:17 <Twey> Touché
06:25:24 <Twey> Sadly it doesn't come with Windows :-\
06:25:25 <Phyx-> which is build in to win7 aswel
06:25:29 <Twey> Is it now?
06:25:31 <Phyx-> yup
06:25:35 <Twey> I heard they took it out ‘for security reasons’
06:25:52 <applicative> I was hoping MODB could get powershell, but on Vista?
06:25:57 <Phyx-> well, it wasn't ready when vista shipped
06:26:01 <Phyx-> but it's in 7
06:26:11 <Twey> Hrm, okay
06:26:17 <Twey> applicative: You can install it on Vista, I believe
06:26:20 <Phyx-> version 2.0
06:26:26 <MODB> is it woth giving a try?
06:26:35 <MODB> worth*
06:26:46 <Twey> I think it's a lot more worthwhile to learn Powershell than to learn CMD.EXE.
06:26:47 <Phyx-> Twey: the default permissions won't execute scripts, so it's pretty safe
06:26:53 <applicative> MODB, don't worry, you have the main thing.  You need to see if flower is all its cracked up to be.
06:26:56 <fryguybob> MODB: It has features that make it very much worth it if you spend much time in a shell.
06:27:08 <MODB> i see
06:27:23 <Twey> OTOH it's even more worthwhile to switch OS or install a Linux in a VM, so ;)
06:27:29 <applicative> Powershell seems cool, but I haven't been using my Windows laptop lately.  It was supposed to be for helping people like MODB....
06:27:41 <Phyx-> let's not go crazy now Twey :P
06:27:44 <MODB> ok ok
06:27:45 <Twey> applicative: Wouldn't a VM be easier?
06:27:50 <MODB> im still following
06:28:07 <applicative> MODB did the command DIR show anything?
06:28:13 <MODB> yes it did
06:28:20 <MODB> it gives info about the folder
06:28:27 <applicative> okay try:  cd Desktop
06:28:42 <applicative> hit return, then type dir or DIR again
06:29:03 <Twey> fosskers: As a side-note, if you install emacs and haskell-mode (or ergoemacs, which comes with haskell-mode bundled) it will autoindent the most common patterns
06:29:03 <MODB> ok
06:29:06 <fryguybob> applicative: There are some nice subtleties about powershell that allow you to turn one off scripts in to more permanent things.
06:29:20 <applicative> MODB, unfortunately, my version of Command PRompt is slightly hacked so I may give wrong commands
06:29:23 <Twey> Namely that it's basically a programming language
06:29:26 <fosskers> Twey: i did, but i noticed it hasn't been indenting things for me nicely
06:29:37 <applicative> now cd to the directory you made with the .sff file
06:29:42 <Twey> fosskers: Oh, really?  You might want to try one of the other indenters
06:29:42 <fosskers> Twey: could that be because of the particular indent style i chose?
06:29:45 <Twey> I think it comes with three
06:30:02 <fosskers> it does. ill go try. it's been indenting some things, but never nicely
06:30:03 <applicative> MODB is it showing that folder/map/directory?
06:30:04 <Twey> I wasn't aware you could choose different indent styles.  I just installed it and hit tab.  :þ
06:30:14 <MODB> yes
06:30:16 <MODB> it is
06:30:16 <Phyx-> :)
06:30:25 <Phyx-> Twey: visual studio comes with 3 styles too
06:30:36 <Phyx-> which you're obviously not interested in knowing ::p
06:30:45 <applicative> so you are in the folder ?
06:30:50 <MODB> yes
06:31:00 <applicative> if so type flower --help again and look at the options
06:31:02 <Twey> Phyx-: Visual Studio supports Haskell now?
06:31:09 <MODB> ok
06:31:10 <Twey> But Haskell is open-source cancer!
06:31:58 <Phyx-> Twey: er... microsoft has an open source site and a couple of open source licenses :P
06:32:02 <fosskers> Twey: k yeah, this mode sucks. switching
06:32:50 <MODB> does the sff file you proposed contain data i can test the flowercommands on?
06:32:57 <Phyx-> applicative, MODB sorry to interrupt.. but there's an easier version to get to that folder :)
06:33:04 <applicative> MODB yes
06:33:09 <Phyx-> just hold shift while rightclicking on that folder
06:33:15 <Phyx-> one of the options would be "command line here"
06:33:24 <MODB> ill try
06:33:35 <Twey> Phyx-: It has Shared Source® where they share stuff with companies and universities if they think they'll benefit from it
06:33:44 <Twey> I haven't heard of them doing any real open-source
06:33:54 <Phyx-> Twey: htttp://codeplex.com
06:33:57 <Phyx-> -t
06:34:02 <Phyx-> Twey: http://codeplex.com
06:34:08 <MODB> it is indeed
06:34:09 <applicative> Oh really.   Phyx- sure enough
06:34:22 <MODB> shift + rightclick is ok to set directory too
06:34:48 <applicative> stylin'  still MODB, you need to know how to navigate inside command prompt. though maybe this makes more sense for flower
06:35:03 <MODB> ok ok
06:35:12 <Phyx-> Twey: a populair open source project of theirs is http://wix.codeplex.com/
06:35:17 <MODB> so setting the directory to the map worked
06:35:58 <applicative> anyway, when you're in it, DIR shows the .sff file?
06:35:59 <MODB> excuse me i meant the folder
06:36:14 <applicative> I think 'directory' is the most universal term
06:36:15 <MODB> yes it does
06:36:23 <MODB> ok
06:36:23 <applicative> now type flower --help
06:36:58 <Phyx-> Twey: and sandcastle also originated from microsoft http://sandcastle.codeplex.com/
06:36:59 <MODB> did it
06:37:01 <Phyx-> et
06:37:02 <fosskers> my function definition got too long for one line...
06:37:03 <Phyx-> etc*
06:37:03 <applicative> i named the file test.sff and then typed: flower test.sff --flowgram=flow.txt
06:37:16 <fosskers> any python-style \ to the rescue?
06:37:29 <applicative> after that DIR will show flow.txt.  You will perhaps know what it is saying, unlike me :)
06:38:12 <Twey> Phyx-: *eyes with suspicion*
06:38:45 <Phyx-> Twey: they've also published alot of their proprietary file format specs
06:39:10 <MODB> i got stuck at the command
06:39:27 <MODB> flower test.sff --flower=flow.txt
06:39:33 <MODB> correct?
06:40:06 <MODB> its says unknown flag --flower
06:40:32 <lightstep> what library can i use to create png files (images)?
06:40:35 <balphas> How do you deal with asynchronicity in haskell?
06:40:44 <applicative> oh sorry, --flowgram=flow.txt
06:40:51 <applicative> oh that's what i said
06:41:05 <applicative> actually MODB is the name of your file test.sff ?
06:41:14 <MODB> it is
06:41:23 <applicative> you could get simple info by typing: flower test.sff -i
06:41:51 <Twey> balphas: STM, HCP, and so on
06:42:15 <Twey> Or just plain old MVars
06:42:33 <MODB> i can extract the information in the command prompt
06:42:43 <applicative> MODB do you see the info>
06:42:44 <applicative> >
06:42:45 <applicative> ?
06:42:54 <applicative> typing is worse than even usual
06:42:54 <MODB> and the command you just were talking about created a .txt file
06:43:05 <Axman6> balphas: in what situation?
06:43:09 <balphas> Twey: I'm using Network.Riak and some calls exhibit async behaviour, but at the moment I'm just calling them from IO, are you suggesting that I use one of those libs to .. ?
06:43:12 <applicative> yes.  if you look at flower --help
06:43:19 <balphas> i'm a noob btw
06:43:32 <MODB> i see
06:43:56 <balphas> Axman6: calling Network.Riak functions, some of which require you to 'react' to an asynchronous reply
06:43:56 <MODB> so you get a command that will create a .txt file with some extrated data from the .sff file?
06:43:57 <applicative> not that e.g. the flower -i blah.sff spills the 'info' into the console, but the double hyphen --info=myinfofile.txt will make a file
06:44:10 <balphas> rather than doing things synchronously
06:44:19 <Axman6> balphas: well that's handled very nicely by functions...
06:44:23 <MODB> i see
06:44:27 <fryguybob> lightstep: What do you want to make images of?
06:44:31 <applicative> MODB, yes there are any number of permutations. You can query the files directly inside console, or save to files of various sorts.
06:44:47 <Axman6> i haven't had a look at the riak library, maybe i should see what it's all about before saying more =)
06:44:53 <lightstep> fryguybob, graphs, mathematical objects, etc. i write the rendering code myself
06:45:00 <MODB> i see
06:45:11 <MODB> and thats basically why i neede flower
06:45:14 <Twey> balphas: I wasn't suggesting anything.  You asked, I answered.  I presume Riak takes care of its own async.
06:45:15 <balphas> Axman6: It doesn't work with functions, because the asynchronicity occurs within Riak and the Haskell lib doesn't help you handle it
06:45:25 <fryguybob> lightstep: Cairo perhaps?
06:45:41 <balphas> Twey: right. but there must be some way of waiting for this async behaviour to occur and then react to it, as in nodejs
06:45:44 <Phyx-> no libpng binding for haskell?
06:45:45 <Axman6> balphas: got an example of a function and a module i could look at to get a better idea?
06:45:45 <applicative> MODB, so if you type: flower test.sff -f
06:45:57 <balphas> Axman6: sure I will gist it sec
06:46:02 <Axman6> ta :)
06:46:05 <MODB> applicative, do you have any file or website where i can learn the use of cammand prompt?
06:46:28 <applicative> MODB then fasta format will spill.  or you can use --fasta=myfasta.txt
06:46:32 <Twey> balphas: There are many ways, though we don't generally consider manually writing CPS to be a boon
06:46:57 <applicative> MODB I was looking for one, there are quite a few around.  The Youtube videos had obnoxious music....
06:47:09 <lightstep> fryguybob, thank you, didn't notice this part of the module. it's really good, since i tried my stuff out on cairo already :)
06:47:34 * hackagebot syntactic 0.1 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.1 (EmilAxelsson)
06:47:57 <Twey> applicative: ‘HaU 2 HaCk wIv CmD PrOmT Prt 4’?
06:48:06 <applicative> MODB just google something like "windows command prompt tutorial "
06:48:16 <applicative> Twey, yeah, that is indeed the spirit
06:48:26 <balphas> Axman6: https://gist.github.com/958973
06:48:39 <MODB> so basically i am now using flower through command prompt?
06:48:51 <applicative> MODB, the commands inside the shell were using, Command Prompt, are mostly quite old so old tutorials will be okay.
06:49:05 <applicative> MODB, yes, you've torn the curtain
06:49:06 <balphas> Twey: manually writing CPS? you mean in JS or in Haskell?
06:49:27 <Axman6> balphas: which functions are causing you problems?
06:49:27 <MODB> and getting to know the programme is getting to know command prompt and flower commands
06:49:43 <MODB> ok
06:49:59 <MODB> i will start digging myself into command prompt of windows
06:49:59 <Twey> balphas: In general
06:50:06 <balphas> Axman6: When you do a mapReduce it returns asynchronously and interferes with the two deleteBucket calls. I want to be able to say 'when the mapReduce finishes, only then run the next two functions'
06:50:06 <Axman6> balphas: also, you might want to consider turning on the OverloadedStrings extension, it'll let you get rid of all those T.pack's
06:50:11 <applicative> yeah. it looks like with this directory trick Phyx- taught us you will only need to now flower itself, in principle.  You might want to output files in another directory of course
06:50:26 <MODB> ok
06:50:29 <MODB> thats fine
06:50:33 <ClaudiusMaximus> lightstep: http://hackage.haskell.org/packages/archive/plot/0.1.2.4/doc/html/src/Graphics-Rendering-Plot-Render.html#writeFigure looks ridiculously easy to go from cairo -> png (or ps, pdf, svg)
06:50:37 <Axman6> balphas: where does mapReduce come from?
06:50:45 <MODB> shifting folders is ok
06:50:51 <balphas> Axman6: oh really i was wondering on how to get rid of those, sweet. mapReduce comes from Network.Riak
06:50:55 <applicative> MODB, so you need to study the webpage to see what good it can flower can do you.
06:51:06 <MODB> indeed
06:51:16 <MODB> i got the hang of most of it now
06:51:30 <MODB> time to note it all down and get studying
06:51:40 <Eduard_Munteanu> Are there any other authors besides Necula working on proof-carrying code? Any articles I should look for?
06:52:21 <applicative> MODB, you will also probably want to learn how to use flower on piles of files at once.
06:52:35 <MODB> i would like to thank you sincerely for all the help and patience
06:52:42 <MODB> i see yes
06:52:45 <Axman6> balphas: try forcing thr result value using either seq or deepseq
06:52:58 <MODB> but as i go along i will get to know that as well i guess
06:53:14 <MODB> thanks anyway for getting me started
06:53:17 <applicative> MODB check out: flower test.sff -h
06:53:37 <MODB> ha
06:53:39 <MODB> good one
06:53:41 <fryguybob> lightstep: If you want something at a higher level byorgey, I and others are working on a new version of diagrams.
06:53:52 <MODB> trying to make my poor lappy crash all over agai
06:53:55 <MODB> again*
06:53:58 <applicative> spills the histogram into 'stdout'.  but you can save it to a file with --histogram=somewhere\on\mysystem\histo.txt
06:54:18 <balphas> Axman6: wow that worked!!
06:54:59 <Axman6> balphas: the problem possibly has to do with lazy IO. basically you need to make sure you've forced all the result of a computation before the resources are closed
06:55:17 <applicative> MODB, flower is seeming light weight so far, do these .sff files get huge?
06:55:27 <balphas> Axman6: is there a version of IO where all calls are `seq`'d ?
06:56:03 <MODB> im afraid yes
06:56:13 <applicative> MODB, in any case, you're basically there.  You could do with a bit more knowledge of the Command Prompt commands. I forgot you can type HELP
06:56:16 <MODB> they are known to go to a few gigabites
06:56:20 <applicative> but HELP is just a reminder.
06:56:34 <Axman6> well, there's different ways of doing IO, iteratees are one way, using bytestrings is often another good way. but in this case, I'd be inclined to email bos about it, see if it's something that needs to be fixed in the library
06:56:45 <applicative> MODB, well, we'll see how sound a programmer ketil is, if flower slows down on them.
06:56:52 <MODB> typically they go around 2-3 GB
06:57:35 <MODB> im afraid my laptop wont be able to process the big files
06:57:40 <applicative> MODB, well see what happens.  like I said, it seems the command prompt aspect is pretty simple, really. you need to learn the flower commands, and what to do with its output
06:57:40 <balphas> Axman6: yeah, the problem only occurs with a couple of functions and its the same exception so I'd be inclined to believe that its just a bug in the lib. I will email bos about it.
06:57:53 <MODB> indeed
06:58:00 <MODB> that will be the next step
06:58:07 <applicative> MODB, including what to call it.  I"m just calling everything blah.txt, but maybe there are appropriate file endings for some of these things.
06:58:16 <MODB> and i will get into it right away after closing this chat
06:58:23 <applicative> MODB, good luck
06:58:31 <MODB> thank you very much indeed!
06:58:58 <applicative> When you come back make bold to type ketil to see if you can wake ketil up for flower specific questions
06:59:08 <applicative> or ketil ping
06:59:09 <applicative> or something
06:59:24 * applicative never notices
07:01:29 <joe6> is anyone aware of a pic simulator in haskell?
07:01:52 <Axman6> balphas: did you try using OverloadedStrings?
07:02:19 <balphas> Axman6: no not yet, I didn't realise this could be a cause of the problem, I'll use it now
07:02:45 <Axman6> i doubt it will fix your problem, but it'll make the code nicer =)
07:03:10 <Axman6> also, the easiest way to make that work right would be to use print result before deleting the buckets
07:04:23 <balphas> that is confusing
07:08:05 * osfameron giggles at http://www.winestockwebdesign.com/Essays/Lisp_Curse.html
07:13:11 <applicative> Phyx-: well, I think we succeeded.
07:13:37 <absentia> nwhat does BBM stand for?
07:13:37 <Phyx-> applicative: well, mostly you :)
07:13:53 <Phyx-> BlackBerry Messenger?
07:13:54 <Phyx-> :P
07:14:24 <absentia> the only issue I have with haskell or lisp -- is, sadly, they just aren't practical (for me, in many cases, in the wild, in enterprise, etc).
07:14:31 <applicative> hah, the trick about shift whatever, does make it a bit more direct, less like a trip into the dark.
07:15:01 <applicative> absentia: Haskell is the practical alternative to ML
07:15:09 <applicative> absentia: Haskell is the practical alternative to Agda
07:15:12 <absentia> I'd love to gain form the alluded power of haskell.  but I also need to (1) get sh1t out the door in order to get paid and keep my job and (2) work with other programmers who probably don't know haskell/lisp.
07:15:35 * osfameron advertises http://lanyrd.com/2011/geekup-liverpool-may/ on haskell-cafe
07:15:59 <absentia> if you take 1 new yorker and put'm in a room with 11 people from the south -- the new yorker will start to speak slower... to match the pace of the southerners....
07:16:22 <absentia> if you put 11 new yorkers in a room with 1 southerner, the 11 will STILL slow down when talking.
07:16:44 <applicative> osfameron, liverpublian haskell? almost as strange as pittsburgh haskell...
07:17:18 <pastorn> absentia: the go to the greatest common level of artardness
07:17:18 <absentia> granted, this say nothing about the cognitive ability of those 12 people -- but that's what it's like in cube-ville ... cool!  awesome haskell/lisp... what?  you don't know this?  you know fortran and some C?  I .... see.   er.... um...   ya, C.  ok.
07:17:36 * absentia is an iOS developer.
07:17:36 <osfameron> applicative: heh.  there's not much FP going on around here, that I'm aware of (but I'm sure there's more going on than I'm aware of, which is why it'd be cool to get some interest in the event to find out ;-)
07:17:40 <pastorn> absentia: obviously you have a stable system at that pace
07:18:13 <absentia> I've heard of one game that was coded in haskell for the iphone.. by a guy/group.company that ported haskell to ios themselves/internally.
07:18:46 <quicksilver> absentia: yes. Cale works for them.
07:18:49 <absentia> seriously, what does BBM stand for with reference to --> http://www.winestockwebdesign.com/Essays/Lisp_Curse.html
07:18:49 <quicksilver> ipwnstudios.
07:18:58 <absentia> ya.
07:19:10 <absentia> I have 8yet* to get the time to even see if their implementation is opensource, shared, etc.
07:19:25 <Axman6> blackh also works for them
07:19:30 <applicative> osfameron, oh yeah I see, it is highly 'functional'  you're the Haskell speaker.
07:19:31 <wjt> aha, the ghc-iphone directory on projects.haskell.org is back!
07:19:39 <tomku> absentia: "brilliant bipolar mind"
07:20:12 * applicative is skipping the talk on "Implenting a Lisp interpreter in .Net "
07:20:22 <osfameron> applicative: yeah - and given I'm a newbie myself, it may not be the most illuminating talk ;-)
07:20:42 <absentia> wjt:  do you know what version of ghc that supports -- and if it's complete?
07:20:44 <osfameron> but I think the material's good, and it's enough to give a flavour of haskell for people who havne't used it
07:20:50 <osfameron> applicative: are you in NWUK then?
07:20:54 <wjt> absentia: i'm just reading the readme
07:20:55 <absentia> tomku:  uh, ok. thx
07:21:16 * absentia is avoiding doing that "real work to get paid" thing now.
07:21:41 <applicative> osfameron, no, Pittsburgh, PA .  One of the US rust capitals.
07:22:13 <osfameron> applicative: ah, heh, so I guess you won't make it over then ;-)
07:22:22 <absentia> so, is Qi > Haskell ?
07:23:03 <applicative> osfameron: no, good luck... I was wondering if a formula has evolved for successful talks like this.
07:23:19 <absentia> ah, free for personal and educational use... Bzzzzpt.  full stop.
07:23:32 <applicative> the one by simon p j is inimitable of course.  and longish....
07:24:04 <absentia> ah, I ahven't even seen Qi and already the successor "Shen" is announced.
07:24:06 * absentia sighs.
07:24:53 <osfameron> applicative: mine will be 20 mins.  It's very much a general interest group
07:25:52 <applicative> not much time for all those types...
07:26:23 <osfameron> applicative: heh, a 3 hour in-depth haskell tutorial would no longer be "general interest" though
07:26:27 <Kaidelong> I liked the mentioning of Qi's "turing complete type inference" as an advantage
07:26:30 <osfameron> if the event's popular we'll do more in-depth things
07:27:11 <osfameron> are there other good FP / Lisp / etc. mailing lists I should try pimping to?
07:27:28 <absentia> kai:  for an ignorant person such as muyself -- what does that ability provide in terms of real-world usefulness?
07:28:06 <quicksilver> absentia: it's not an advantage, it's a disadvantage, hence Kaidelong's phrasing :)
07:28:20 <quicksilver> it means you can write programs for which the compiler does not terminate.
07:28:33 <absentia> I thought C++'s templating system was turing complete?
07:28:38 <quicksilver> correct.
07:28:39 <applicative> osfameron, of course there's the dreaded comp.lang.lisp etc.
07:28:42 <Kaidelong> actually I'm not so sure if sub-turing type inference is worth the tradeoff
07:28:43 <vermeille> Hail all
07:28:55 <applicative> hi vermeille
07:28:56 <quicksilver> C++ compilation is non-terminating, the standard permits you to have recursion limits to safeguard it.
07:29:02 <Kaidelong> but I imagine you'd need a strong justification to be convincing that it is worth making it turing complete
07:29:03 <absentia> q:  yes, I can see how that would be advantageous and a highly desireable thing to have.
07:29:07 <vermeille> I have a probably stupid problem, I'm trying to use Data.Bitmap
07:29:16 <vermeille> and emptyBitmap won't compile
07:29:29 <osfameron> applicative: eeeek!  Still, I guess a simple announcement shouldn't get me embroiled in too many flame wars, right? ;-)
07:29:42 <vermeille> My line is pretty simple : "let img = emptyBitmap (200,200) 3 Nothing in ..."
07:29:52 <absentia> I'm still trying to figure out why a type inference system would need to be turing complete?  sounds like you can't make up your mind.
07:29:53 <quicksilver> osfameron: you don't have to wait around to read the responses if you dont' want to :)
07:30:02 <vermeille> And GHC gives me a type error
07:30:11 <quicksilver> absentia: well, if you want to encode arbitrarily complex properties about types
07:30:13 <osfameron> quicksilver: hehe, there is that
07:30:28 <quicksilver> absentia: for example 'the type of sorted lists' requires the compile to construct a proof of sorted-ness at compile time
07:30:31 <quicksilver> that kind of thing.
07:30:31 <applicative> osfameron, in any case, you'd be preaching to the converted, when it comes to the purpose of the event as awhole
07:30:35 <absentia> but then is it really not an "inference" system
07:30:38 <Kaidelong> absentia: because in a perfect world you would just specify the types and infer the code
07:30:39 <absentia> at that point?
07:30:48 <applicative> maybe comp.lang.lisp is down on clojure....
07:30:50 <Kaidelong> well
07:30:56 <Kaidelong> "just" would be misleading there
07:31:06 <Kaidelong> rather that is where you have moved the problem
07:31:18 <osfameron> applicative: yeah, there's 2 outcomes I'm hoping for 1) to talk about FP to non-converted, 2) to meet other people who are interested, and in the area
07:32:17 <quicksilver> Kaidelong: but the implication or hope is that you move some of the problem to the computer, which is a win.
07:32:26 <quicksilver> Kaidelong: that's not particularly easy to get right though.
07:32:31 <Kaidelong> yeah
07:32:40 <Kaidelong> I might hack at it some day
07:34:34 <Kaidelong> it would be interesting if you could somehow trade the potential of not being able to terminate when compiling for knowing that the program will always halt if it actually can be compiled
07:34:40 * hackagebot hexpat-tagsoup 0.1 - Parse (possibly malformed) HTML to hexpat tree  http://hackage.haskell.org/package/hexpat-tagsoup-0.1 (StephenBlackheath)
07:34:43 <applicative> osfameron, the clojure and lisp lists might make sense.  The readers are unlikely to be noobs, but can tell their friends. Or they might be interested in one of the other languages if they're in the area. etc.
07:34:44 <vermeille> Ambigous type variable 't0' in the constraint (PixelComponent t0)
07:34:50 <vermeille> In don't undersand
07:35:17 <applicative> vermeille, did you put the module on hpaste.org?
07:35:18 <osfameron> applicative: yeah.  I'm posting to comp.lang.lisp.  I'll let the clojure speaker post to the clojure list, I think.
07:35:21 <osfameron> thanks
07:35:22 <Kaidelong> hmm, what languages are you using vermielle?
07:35:28 <Kaidelong> FlexibleContexts might help
07:35:33 <Saizan> vermeille: it doesn't know which type you want to use there
07:36:12 <vermeille> Yeah I know but this is quite strange since I just want a Bitmap
07:36:18 <Kaidelong> oh wait
07:36:20 <Kaidelong> no it won't
07:36:26 <quicksilver> different bitmaps have different pixel types
07:36:32 <quicksilver> you have to fix it to the pixel type you want
07:37:03 <vermeille> Hmmm...
07:38:12 <moisan> vermeille : I think a good example would be RGB or RGBA (I guess, I never touched bitmap in haskell)
07:39:16 <vermeille> moisan: "let (img :: Bitmap RGB) = emptyBitmap (200,200) 3 Nothing in ..." RGB not in scope
07:39:17 <quicksilver> it should be just a question of appending a type annotation
07:39:35 <quicksilver> but I can't tell you without the docs and I'm about to reboot
07:39:43 <vermeille> I quicksilver yes, but I don't find how to fix it, I'm very beginner in Haskell
07:39:48 <applicative> the instances are Float Word8 Word16 Word32 in Data.Bitmap.Base
07:39:55 <merijn> Any clues when lambdabot will be back?
07:39:59 <moisan> vermeille : yeah I didn't looked at the docs neither, RGB was on top of my head
07:40:33 <Saizan> vermeille: which library are you using?
07:40:34 <vermeille> Hell, where did you find that ?
07:40:44 <vermeille> Saizan: bitmap-0.0.1
07:40:58 <vermeille> It works with Bitmap Word16
07:41:46 <Saizan> http://hackage.haskell.org/packages/archive/bitmap/latest/doc/html/Data-Bitmap-Base.html#t:PixelComponent <- yeah, since Word16 is an instance of PixelComponent
07:42:25 <vermeille> Okaaaaay, I understand better
07:43:29 <vermeille> Thanks guys
07:43:32 <vermeille> sorry
07:43:41 <Saizan> np
07:46:07 <vermeille> Okay, now I need to save the file. Oh hell.
07:47:52 <applicative> vermeille, you might take a look at the uses of the bitmap package listed on http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/package/bitmap-0.0.1
07:48:01 <applicative> vermeille, they don't seem too transparent.
07:49:45 <applicative> well, has everyone tried the new IterIO library.  The contest of iteratee/enumerator libraries continues.
07:50:32 * applicative regrets that the author is lacking a gift for attractive function and type names.... studied a little too much of Oleg's discussion maybe
07:52:12 * applicative is somehow demoralized by the perfectly intelligble: type Inum tIn tOut m a = Iter tOut m a -> Iter tIn m (IterR tOut m a)
07:52:49 <Peaker> If he used new names, he could have at least used sensible ones :)
07:52:57 <Peaker> Producer/Consumer/Transformer..
07:54:15 <applicative> Peaker yes.  but even in that case, why not:  type Inum in out m a = Iter out m a -> Iter in m (IterR out m a)
07:54:34 <applicative> but IterR and Inum are already unpleasant enough.
07:54:59 <applicative> the gzip example seems faster than the one on my laptop, which is pleasing.
07:55:16 <Axman6> Peaker: those are indeed much much better names, care to email the author?
07:55:58 <Axman6> because apart from the naming, it looks like a great library
07:56:03 <applicative> Axman6, if it seems this is really going to begood, someone should break it to him that most of us are aesthetes in this regard, and maybe a renaming should come sooner rather than later.
07:56:05 <ion> Is the author of Atom here, btw?
07:56:33 <applicative> Axman6, exactly. It's a type, where they are indifferent to naming.  His pipes and so on seem okay.
07:56:44 <applicative> I mean, a type of person...:)
07:56:47 <aristid> applicative: talking about iterIO?
07:56:51 <applicative> yeah
07:57:05 <aristid> what differentiates it from enumerator?
07:57:10 <applicative> aristid, what about it?  what do you think?
07:57:29 <applicative> aristid, there is an extensive tutorial, I'm still trying to figure out the types.
07:57:47 <applicative> aristid, it has good press at the moment.
07:57:52 <Axman6> aristid: documentation for one
07:58:05 * scree is finding the documentation a little *too* copious for instant digestion
07:58:08 <Peaker> Emailing him requires jumping through a few hoops
07:58:10 <aristid> Axman6: enumerator's documentation is not great, but it does exist.
07:58:17 <applicative> eg dons: "This is full of much awesome."
07:58:36 <Axman6> applicative: sure, but the iterIO docs are great
07:58:50 <applicative> THe docs are indeed awesome, not that I've made it far.
07:59:11 <applicative> But if it's really true its better, as the connections with parsing, etc etc. seem to suggest it might be.
07:59:17 <aristid> i think these days if you want to introduce a new iteratee library you should at least have some compatibility layer
07:59:27 <aristid> enumerator is fairly deeply entrenched.
07:59:42 <applicative> I do think Axman6 is right that the names are toxic and something should be done
07:59:44 <aristid> and iterIO seems to replicate a lot of functionality. it is too big of a package for my taste.
08:00:06 <Axman6> applicative: emailing -café now (with credit going to Peaker )
08:00:08 <djahandarie> I've basically been avoiding enumerator
08:00:13 <merijn> So if I want to learn iteratees should I check out iterIO? I was looking at enumerators but that didn't seem to have sufficient docs for me
08:00:15 <aristid> djahandarie: why?
08:00:17 <applicative> aristid, enumerator is yesterday, I'm going with iterIO , it's like git!!
08:00:26 <djahandarie> aristid, I've just never liked it.
08:00:41 <applicative> merijn, the docs look great.  Some excellent examples in the examples directory too.
08:00:43 <djahandarie> Maybe the name reminded me too much of Java. :p
08:00:59 <aristid> well i've never really chosen to use enumerator myself. it's just that existing packages tend to use it, and i've built on them
08:01:07 <merijn> applicative: Nice, maybe I'll finally grok iteratees, then :p
08:01:31 * applicative couldn't figure out the ssl http one though
08:01:33 <aristid> class (Typeable carg, Typeable cres) => CtlCmd carg cres | carg -> cres
08:01:41 <aristid> so that's iterIO :P
08:02:30 <applicative> merijn, see if you think it's more intelligible.  you can join our campaign: Against Ugly Names in IterIO Before It's Too Late.
08:02:43 <aristid> i just don't see what about it is really better than enumerator. the names are even worse.
08:02:54 <aristid> and enumerator DOES have a couple tutorials.
08:02:58 <applicative> the names are worse.  the influence of Oleg can't be broken
08:03:17 <Axman6> so Peaker's idea is Producer/Transformer/Consumer, I'm not too sure about Transformer (it;s accurate, but the name is somewhat taken by monad transformers). possibly something like Mapper... or... ideas?
08:03:19 <applicative> enumerator is much helped by the excellent tutorials and supersimple examples
08:03:36 <Axman6> enumerator has much better naming than iteratee
08:03:42 <Axman6> but still not good enough
08:03:51 <Axman6> hopefully we can make iterIO change
08:03:52 <djahandarie> I actually don't really like all these names
08:03:54 <aristid> i think the first tutorial i read was this: http://www.yesodweb.com/book/enumerator
08:04:05 * applicative was trying to reduce olegs new definition to something in the monad transformer libraries, in order to have done with it
08:04:07 <djahandarie> Too many names for simple stuff.
08:04:08 <aristid> and since 0.4.9 it has piping operators too: $= and =$
08:04:24 <merijn> aristid: I started there, but I sorta got stuck when the 14th slightly differing code snippet was introduced
08:04:25 <Axman6> i read Snoyman;s enumerator tutorials while i was at Tsuru to learn about iteratees and they were great
08:04:25 <ion> Middleman :-P
08:04:27 <djahandarie> I don't particularly like jargon.
08:04:44 <applicative> aristid, you're stopping progress, it's like defending darcs!!! retrograde!! call ops.
08:04:49 <aristid> djahandarie: and iterIO does not improve there. it continues using bad name.
08:04:56 <aristid> *bad names
08:05:14 <djahandarie> It seems to me like a lot of them are just throw-away variable names.
08:05:24 <djahandarie> Perhaps poorly named throw-away variable names though.
08:05:34 <djahandarie> But I don't think they should be replaced with stuff like "Producer" though
08:05:35 <applicative> Okay, lets found the Iteratee/Enumerator Nomenclature League.  We just need the go ahead from the Academie Francaise
08:05:46 <merijn> :D
08:06:28 <applicative> Once I tried to rename the types all in terms of Fold and so on.  In early versions oleg did this, with superadd oleg name-indifference
08:07:04 <applicative> Folder Foldable whatever.  Didn't quite work.
08:07:06 <aristid> i wish there was a comparison between enumerator and iterIO, so i can know what is actually better :)
08:07:32 <djahandarie> aristid, maybe wait more than a couple hours after the package was released? :p
08:07:38 <aristid> i don't find the iterIO tutorial
08:07:40 <applicative> aristid, the verdict of the community is in.   "This is full of much awesome." :)
08:08:18 <aristid> applicative: i don't want a verdict, i want to think for myself.
08:08:21 <applicative> aristid, the haddocked modules are the tutorial.
08:08:23 <Axman6> aristid: do you prefer Producer, Consumer and Transformer/Mapper?
08:08:28 <aristid> Axman6: yes.
08:08:37 <Axman6> there has to be a better name than Mapper...
08:08:39 <applicative> aristid, I am of course favoring that, pardon silliness.
08:08:58 <aristid> Axman6: Transformer is pretty nice IMHO
08:09:10 <Axman6> ok.
08:09:23 <Axman6> applicative: what about you, do you like Transformer for enumeratees?
08:09:44 <aristid> Axman6: you could also name them Catamorphism, Anamorphism and Hylomorphism or something like that :P
08:10:12 <Axman6> the intent is to make me more likely to use this library, not less :P
08:10:56 <applicative> His types are a little different, or the structure of them: There is no difference between enumerators and "enumeratees" (i.e., inner pipeline stages). The former is just a type-restricted version of the latter.
08:11:09 <djahandarie> aristid, http://www.haskell.org/pipermail/haskell-cafe/2011-May/091674.html read the list in this email.
08:12:34 <aristid> "iterIO represents enumerators as enumeratees from () to something" <- well that may or may not be an improvement. i think it might make it slightly easier to understand, but i don't know the full repercussions
08:12:52 <applicative> let a hundred iteratees blossom!; let a thousand hackage libraries contend!
08:13:44 <aristid> djahandarie: ok the biggest difference seems to be control messages
08:13:58 <aristid> pure iteratees do add some type safety, but also complexity
08:14:26 <applicative> hah, i have just read Axman6's letter to hackage.  I don't have an account so i wont second....
08:14:28 <Axman6> aristid: i can't really see there being many, it's a fairly accurate to make enumerators take an input of ()
08:14:36 <Axman6> aristid: :(
08:14:39 <Axman6> uh, applicative*
08:15:35 <aristid> maybe dons loves iterIO _because_ it contains so much functionality in a single package? *evil and unfair speculation*
08:16:27 <applicative> aristid, sorry, too much typing
08:16:58 <djahandarie> aristid, I think he likes it for the same reason I do. It looks very well-rounded and complete
08:17:16 * applicative notes that dons wasnt really making any large claim.  presumably he does want to excite interest and testing, as is reasonable
08:18:08 <applicative> is the inbuilt attoparsec machinery any different from the associated library for enumerator?  Maybe he should divide it up too
08:18:32 <applicative> to avoid a new MissingL or whatever
08:19:53 <Axman6> well attoparsec maps extremely easily to the idea of an iteratee
08:20:14 <Axman6> i don't think there's much you could to to break out the machinery
08:20:15 <aristid> in a lot of ways, iterIO seems to be pretty similar to enumerator, when i look at the design rationale of iterIO
08:20:29 <aristid> both use standard Control.Exception exception handling
08:20:37 * applicative cant wait to see the error messages for simple things like this in the parser module:(ChunkData t, ListLike t e, StringLike t, Eq e, Monad m) => String -> Iter t m t
08:20:41 <Axman6> it;s probably at most 5 lines of code to take an attoparsec parser and make it an iteratee for any library
08:21:50 <applicative> I see, it has it's own parser combinators, but then an integration of attoparsec, I guess modeled on familiar one.
08:22:07 <aristid> i think it's pretty obvious that people want better streaming I/O (or iteratee) packages, otherwise they wouldn't swarm on iterIO like piranhas
08:22:18 <companion_cube> what's an iteratee ?
08:22:33 <Axman6> it's a bit like a unicorn, but faster
08:22:34 <applicative> it's like a taco salad
08:22:45 <hpc> it's like a burrito
08:22:48 * Axman6 high fives applicative 
08:22:48 <hpc> no wait, that's monads
08:22:48 <applicative> wait, no thats monoids
08:22:53 <Tomsik> It's like something that iterates a tee
08:23:08 <aristid> companion_cube: http://okmij.org/ftp/Streams.html :P
08:23:09 <Axman6> i rewrote tee using enumerator =)
08:23:11 <monochrom> it's like a burrito restaurant
08:23:20 <aristid> Axman6: yay
08:23:32 <Tomsik> monochrom: Yeah, what comes in comes out fast
08:23:42 <aristid> Axman6: is it polymorphic? you could make a tee for XML with xml-enumerator :D
08:24:11 <aristid> (ok a ByteString tee would work on that too, but still)
08:24:11 <Axman6> it'll work with anything... it just takes in bytestrings and writes them to files...
08:24:26 <Axman6> it's got pretty great performance though
08:24:45 <Axman6> not sure whether i tested it againt the speed of actual tee...
08:24:58 <companion_cube> I'm happy to discover such a useful concept, then... burrito-salad-eating unicorns !
08:26:12 <Tomsik> Axman6: I'd expect tee to optimize system calls by hand
08:26:14 <Axman6> aristid: http://hpaste.org/46424/htee if you're interrested =)
08:26:16 <Tomsik> like wc
08:26:22 <Axman6> well I'd hope so
08:26:28 <osfameron> companion_cube: don't forget the unicorns are wearing space-suits!
08:26:44 <companion_cube> AWESOME!
08:26:55 <aristid> the space-suits are also full of nuclear waste
08:26:57 <aristid> so beware
08:27:00 <companion_cube> unicorns must be related to Haskell, both are pure
08:27:13 <Axman6> not all that code is mine, someone had started a project to rewrite all the standard unix commands in haskell, and i realised that this was a perfect place for an iteratee
08:27:34 <Axman6> companion_cube: unicorn blood is an essencial part of all haskell compilers
08:27:54 <edwardk> Axman6: that is what i've been missing! Quick! Find me a unicorn.
08:27:56 <Tomsik> Haskell is not as pure as you might think
08:28:04 <companion_cube> import Unicorn.Blood hiding (cadaver)
08:28:09 <hpc> Axman6: except for GHC
08:28:20 <hpc> Axman6: it comes from Glorious Glaskow, where you can substitute vodka
08:28:28 <Axman6> heh
08:28:49 <aristid> Axman6: that uses lazy i/o
08:29:02 <aristid> Axman6: i thought you said you used enumerator?
08:29:04 <Axman6> oh, ha, that's the original
08:29:37 <Axman6> http://hpaste.org/paste/46424/htee_annotation#p46425
08:29:44 <Axman6> the code's basically the same length
08:30:15 <applicative> oleg's new definition is basically newtype It m a = It (Either (Maybe String -> m (It m a, Maybe String))   a)
08:30:45 <edwardk> applicative: he finally switched?
08:30:52 <aristid> Axman6: that uses iteratee, not enumerator :)
08:30:56 <applicative> pure case newtype It a = It (Either (Maybe String -> (It a, Maybe String)) a)
08:31:04 <Axman6> aristid: hmm, that must be a played with version, it's chunking with 1 byte at a time...
08:31:13 <applicative> edwark, i just mean the revision of a few months ago, you've presumably seen it
08:31:22 <Axman6> aristid: hmm, so it does. it was several months ago that i wrote it
08:31:35 <applicative> he points out that 'he could have used a monad transformer' but the libraries are unsettled ...
08:31:42 <edwardk> applicative: i haven't kept up with the canonical iteratee for a year or so now.
08:32:02 <applicative> its the fixed point of some sort of Either transformer applied to State.
08:32:40 <hpc> i wish that sort of shit would be implemented in terms of Mu
08:32:50 <applicative> I don't like monad transformers much, but I wonder if in this case an account that sticks with them wouldn't be clearer..
08:33:18 <applicative> oleg is unwilling to do it because it would spoil his originality -- not that it would , in truth
08:33:49 <aristid> applicative: is that also the reason for his... interesting naming methods?
08:35:01 <applicative> edwardk here's the revised module http://okmij.org/ftp/Haskell/Iteratee/IterateeM.hs
08:35:09 <applicative> the type is massively simpler, I find.
08:35:11 <edwardk> i'm perfectly happy to have oleg out there thinking sideways. it means at least someone is out there viewing things with that perspective and occasionally giving reports on what they find
08:35:24 <Axman6> indeed
08:35:26 <applicative> yes, I wouldn't think of objecting
08:36:02 <applicative> he uses mental models from totally different forms of language.  there's the prology aspect, the lispy aspect etc etc.
08:36:09 <edwardk> i don't like the polymorphically strict a in IE_done
08:36:14 <edwardk> it makes me squeamish
08:36:17 <Axman6> he's an inventor, and we need more of them. but like many inventors, he's not good at the aesthetics of things so to speak
08:37:02 <applicative> Ah I hadn't taken account of the strictness annotation, I was just trying to tear it apart further.
08:37:59 <applicative> edward, it only applies to the done values or the error ones, not that it could apply to anything else
08:39:10 <applicative> edwardk, you should see if you can find an easy reduction to familiar monadology.  Stream e is basically Maybe e, or whatever.
08:39:22 <Axman6> i can't see a problem with making IE_done strict, it fits well with how iteratees are supposed to be used
08:39:27 <aristid> edwardk: yeah, we need an edwardk-iteratee package :)
08:39:30 <applicative> thus my parody newtype It m a = It (Either (Maybe String -> m (It m a, Maybe String)) a)
08:39:38 <aristid> i'm sure it would be interesting
08:40:24 <applicative> it would be, frankly.  some larger scale overview is needed.  the conncection with the fold concept is missing in the tutorials, except vestigially.
08:40:47 <applicative> iteratee recursion schemes! itermorphisms!
08:40:53 <Axman6> aristid: i think you mean edwardk-iteratee, edwardk-enumerator, edwardk-enumeratee, edwardk-IOenumerator...
08:41:14 * applicative is taking care of  edwardk-IOenumerator-extras
08:41:14 <hoopy_> :D
08:41:46 <quicksilver> iterenumeratoreeoreeoreeorEIEIO?
08:41:52 <aristid> Axman6: :)
08:42:16 <Saizan> yeah, using better names would already be a good start
08:42:16 <aristid> quicksilver: that could become a haskell song
08:42:51 <aristid> Saizan: and it would use the Codensity transformer, i'm sure.
08:43:07 <Saizan> everything should use Codensity anyway
08:43:17 <Axman6> Saizan: did you see my -café email about iterIO?
08:43:31 <applicative> by the way, writing monad instances for iteratee enumerator replicas speaks volumes for permitting `join` as a permissible alternative to `>>=`
08:43:32 <Saizan> Axman6: no
08:43:45 <applicative> darn have to go
08:44:16 <Axman6> suggesting that they rename the types to use better names like Producer/Consumer/Transformer
08:44:35 <Axman6> rather than Inum, Onum, Iter...
08:45:00 <Axman6> (well, Onum, Inum, Iter, to keep the order the same)
08:47:53 <Tomsik> I'm waiting for MonadProducers and MonadConsumers packages :p
08:48:20 <monochrom> quicksilver: have you seen http://spikedmath.com/416.html ? :)
08:48:24 <Axman6> would Reader be a procuder?
08:48:30 <Axman6> and Writer a consumer?
08:48:53 <Saizan> another explanation could be that the names are bad because the components got molded around the wrong concepts
08:48:55 <Volatile> Can I tell haskell that my bivalued function is to be commutative, so I don't have to define a `op` b and b `op` a ∀ a and b?
08:49:12 <Volatile> (but just a `op` b)
08:49:21 <ezyang> Volatile: There's a function in 'amb' that does that.
08:49:31 <ezyang> but it's for making laziness commutative ;-)
08:49:38 <hpc> :t amb
08:49:43 <hpc> oh right
08:49:46 <ezyang> @info amb
08:49:47 <Saizan> Volatile: i don't understand what you're asking
08:49:48 <mbryant> i need help can anyone tell me why this syntax is blowing? (pastebin incomming)
08:49:51 <ezyang> @package amb
08:50:04 <ezyang> lambdabot is dead long live lambdabot
08:50:05 <djahandarie> lambdabot is dead
08:50:08 <djahandarie> Heh
08:50:16 <Volatile> heh. I just realized that putting an a `op` b = b `op` a at the top should solv my problem for this one. :)
08:50:22 <hpc> long live the lambdabot
08:50:49 <Saizan> Volatile: that will just make op loop
08:50:56 <mbryant> http://pastebin.com/w4YYuz6C
08:50:57 <hpc> make it the bottom pattern
08:51:08 <ezyang> Volatile: no...
08:51:08 <monochrom> haskell is just a programming language. it doesn't know commutativity. or any other mathamatical axiom
08:51:10 <Saizan> @tell Cale lambdabot is dead
08:51:16 <hpc> haha saizan
08:51:41 <mbryant> the solve section of the code
08:51:48 <Axman6> > let a `foo` b = b `foo` a in 1 `foo` 2
08:52:09 <monochrom> time-limit exceeded
08:52:12 <ezyang> parCommute in lub.
08:52:14 <hpc> Axman6: infinite loop! you crashed lambdabot!
08:52:16 <Saizan> Volatile: why do you care which argument goes first if op is commutative?
08:52:57 <Volatile> Saizan: I just thought it would be nice to define only half of all possible combinations, since I have a commutative function.
08:53:04 <quicksilver> monochrom: :)
08:53:40 <monochrom> perhaps there are two lines like "True && False = False", "False && True = False", and the author finds it redundant, haskell is such an automatic theorem prover, why do I have to repeat code, etc etc
08:54:03 <ezyang> so, something like f a b = f' a b `lub` f' b a
08:54:19 <ezyang> where f' is a partially defined function.
08:54:39 <Saizan> Volatile: ah, you mean while defining op, you've a bunch of cases above, and then after those you add a `op` b = b `op` a ? that would work
08:54:47 <Volatile> monochrom: exactly
08:55:09 <Volatile> Saizan: ah. Nice. Will do that, then. :)
08:55:12 <merijn> Unless you missed a case and you end in an infinite recursion :D
08:55:16 <quicksilver> Saizan: but it would have the curious property of looping if you've missed a case
08:55:19 <quicksilver> right.
08:55:35 <Saizan> Volatile: make sure it's the last clause, otherwise it'll override the other ones
08:55:45 <monochrom> except haskell is not an automatic theorem prover at all
08:56:04 <Saizan> looping, failing a pattern match, all bottoms are the same :P
08:56:22 <monochrom> its nice syntax induces the deceptive impression, yes
08:56:23 * Axman6 notes some are better looking than others
08:56:39 <Kaidelong> let ifEqual x y | x == y = x; (&&) x y = ifEqual False x `unamb` ifEqual False y `unamb` ifEqual x y
08:56:40 <Axman6> bottums that is =)
08:56:52 <mbryant> my issue is that soryBy is not in scope? any ideas?
08:57:01 <mbryant> sortBy*
08:57:07 <monochrom> import Data.List(sortBy)
08:57:08 <wto> mbryant: import Data.List ?
08:57:11 <merijn> mbryant: Import the appropriate module? :p
08:57:33 <mbryant> yea that would help, i knew it was simple... thanks
08:58:50 <Kaidelong> I wonder if the parallelism you get from unambiguous boolean operators might make them worth using
08:58:50 <Volatile> I had a friend that recursed a list until an item was found. After an item was checked, it was moved to the end of the list...
08:58:55 <Kaidelong> (potentially)
09:00:24 <mbryant> wto: I also have another small problem, now that the import is fixed, in my compare statement, i have a mismatch saying that it cant multiply int to a double, any idea how to fix it
09:00:53 <monochrom> fromIntegral my'int * my'double
09:19:05 <EvanR> if i control C does that kill all threads or just main thread
09:19:30 <EvanR> do i need a network of 'all stop' MVars
09:19:42 <EvanR> and a custom signal handler
09:20:28 <Axman6> ^C kills the process (unless you have installed a signal handler), and killing the process kills all threads
09:20:41 <Axman6> i guess you can thing of ^C killing the RTS
09:20:56 <EvanR> ok
09:21:20 <Tomsik> What do you people think about Yesod dropping polymorphism?
09:21:38 <merijn> Heretics! Burn them at the stake!
09:21:41 <EvanR> Axman6: what about when the main thread 'ends'
09:21:47 <mbryant> hey guys i get a couldnt match exepcted type error in the following program, any idea how to get around it? thanks http://pastebin.com/YsTJuHuS
09:21:49 <EvanR> does that kill all the other threads
09:21:54 <mbryant> in the MyCompare function
09:21:56 <Axman6> EvanR: then the process exits
09:22:00 <EvanR> ok
09:22:14 <merijn> mbryant: Can you paste the error too?
09:22:29 <EvanR> what if i have a custom signal handler
09:22:45 <merijn> mbryant: nevermind, saw it already
09:22:52 <Axman6> EvanR: this is why often if you use main to fork off some worker threads, main needs to use an MVar or something to make sure all threads have completed before exiting
09:23:38 <merijn> mbryant: "i1 * d1" multiplies a Double and an integer which is a type error. You can use fromIntegral to convert i1 into a Double too, i.e. "fromIntegral i1 * d1" (same goes for all the other multiplications)
09:23:56 <mbryant> okay thanks
09:24:04 <merijn> I'd show you, but lambdabot is still dead :<
09:24:18 <hpc> fromIntegral 1 = 1.0
09:24:20 <hpc> etc etc
09:24:20 <Axman6> mbryant: haskell is not like languages like C which automatically convery between numeric types, and this is a good thing
09:24:24 <helino> hi, I got a question about modules. If I export a function f from module Foo, import module Foo in module Bar, and then import module Bar in module Baz, will the exported function f be "visible" in module Baz?
09:24:25 <NihilistDandy> Oh, no :(
09:24:37 <hpc> helino: no
09:24:57 <hpc> helino: look up module exports - http://en.wikibooks.org/wiki/Haskell/Modules#Exporting
09:25:15 <NihilistDandy> merijn: I could bring in my lambdabot, if it'd make you feel better :D
09:25:18 <hpc> er, wrong link
09:25:51 <hpc> http://www.haskell.org/onlinereport/modules.html
09:26:00 <hpc> somewhere in there is relevant info
09:26:01 <EvanR> Axman6: if i have a custom signal handler, which for example commits state to a file before exiting, can i then still get all the threads to end automatically?
09:26:31 <helino> hpc: thanks for you help!
09:26:44 <Axman6> EvanR: I'm pretty sure that once main exits, then the program exits. this might be a better question for #ghc
09:27:11 <EvanR> yes we covered that, but this is a different question
09:28:07 <EvanR> the condition you mentioned was i dont have a custom handler
09:28:18 <Eliel> I was reading a book on Game Tree algorithms and ended up writing a Haskell version of one of the algorithms in the book. I ended up shaping it as a general module. Any suggestions on how I could further improve it? http://hpaste.org/46429/negamax_with_alpha_beta_prunin
09:28:26 <Axman6> I'm not sure what happens then
09:28:40 <EvanR> hmm
09:28:49 <EvanR> whats a Game Tree?
09:29:18 <Eliel> I think it's a term from game theory.
09:29:24 <EvanR> ah
09:29:32 <Silex> did you read that book or not?
09:29:33 <Silex> :)
09:29:37 <NihilistDandy> Combinatorial game theory, to be specific
09:29:45 <Eliel> http://en.wikipedia.org/wiki/Game_tree
09:30:01 <Eliel> I'm still in the middle of reading the book :)
09:30:11 <Eliel> had a small detour writing this module though :)
09:30:25 <Silex> "For example, the game tree for tic-tac-toe has 26,830 leaf nodes."
09:30:32 * Silex expected much less
09:31:09 <Eliel> Silex: a lot of them are practically equivalent situations.
09:31:43 <NihilistDandy> Yeah, I think the space is much smaller if you remove reflections and rotations
09:31:47 <Eliel> for any game situation, the game tree has a node for each way to get there.
09:33:39 <Axman6> > 2^9
09:33:45 <Axman6> bah
09:34:13 <EvanR> this MaybeT package in haskell apparently uses fail as the command to ... fail. but i was under the impression that fail in the Monad is for something else and people generally hate its existence
09:34:14 <Axman6> so there's only 512 unique tic-tac-toe boards
09:34:19 <Axman6> wait
09:34:21 <EvanR> hackage*
09:34:26 <Axman6> 19683
09:34:45 <Axman6> of course tic-tac-toe has ternary states =)
09:35:04 <EvanR> there are invalid boards
09:35:12 <EvanR> like not reachable
09:36:09 <Axman6> yeah
09:36:18 <NihilistDandy> > 2^9
09:36:22 <LambdaTemp>   mueval-core: Time limit exceeded
09:36:26 <NihilistDandy> > 2^9
09:36:27 <EvanR> o_O
09:36:28 <LambdaTemp>   512
09:36:31 <NihilistDandy> There we go
09:36:36 <NihilistDandy> My bot's a little slow
09:36:43 <EvanR> > 9^2
09:36:44 <LambdaTemp>   81
09:36:50 <EvanR> ok at least it can do that
09:36:56 <Zao> @src filter
09:36:56 <LambdaTemp> filter _ []     = []
09:36:56 <LambdaTemp> filter p (x:xs)
09:36:56 <LambdaTemp>     | p x       = x : filter p xs
09:36:56 <LambdaTemp>     | otherwise = filter p xs
09:37:32 <Axman6> @vixen are you as sexy as the girl you've replaced?
09:37:32 <LambdaTemp> of course i'm female
09:37:48 <monochrom> racist! :)
09:37:48 <EvanR> of course, i'm female
09:37:50 <Axman6> man, a comma in there would have made that priceless
09:37:53 <applicative> shouldn't it be, e.g. betabot
09:37:54 <monochrom> err, sexist!
09:37:54 <EvanR> lol
09:38:14 * Axman6 -> sleep
09:38:14 <monochrom> err nevermind, misread
09:38:23 <NihilistDandy> applicative: Lambdabot's on maternity leave. I brought in a temp.
09:38:31 <monochrom> haha
09:38:31 <NihilistDandy> :D
09:39:02 <NihilistDandy> She's not as good, but she basically works
09:39:15 <EvanR> i want maternity leave. rise up egalitarians and take out the sexists!
09:39:19 <monochrom> @quote monochrom
09:39:19 <LambdaTemp> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
09:39:27 <applicative> I see. we need a suitable male idiot to match @vixen not that vixen is an idiot
09:39:44 <NihilistDandy> @protontorpedo
09:39:44 <LambdaTemp> I dont know any programming yet at 33 dream of learning ti and gettign rich
09:39:50 <Axman6> she's just yound and naive
09:39:59 <applicative> for purposes of balance...  also what would be a good program for @noether or @emma
09:40:26 <monochrom> noetherian rings are noetherian
09:40:44 <NihilistDandy> I just like this
09:40:45 <applicative> i'm trying to think of a haskelly application of something noetherian
09:40:48 <NihilistDandy> @help protontorpedo
09:40:49 <LambdaTemp> protontorpedo is silly
09:40:52 <NihilistDandy> and
09:40:55 <NihilistDandy> @time LambdaTemp
09:40:55 <LambdaTemp> I live on the internet, do you expect me to have a local time?
09:41:10 <roconnor> I wonder if I should do google code jam again.
09:41:18 <applicative> @vixen what time is it on the Sun
09:41:19 <LambdaTemp> i dunno...
09:42:12 <Axman6> applicative: well, our notion of times is based on the earth facing the sun... so.. um
09:42:23 <Axman6> i don't know how local times on the sun would work
09:42:23 <monochrom> I imagine "@noether how to use haskell to serve web pages" -> "is that finitely generated?"
09:42:24 * fryguybob thinks daytime.
09:42:41 <applicative> monochrom, now you're getting the idea
09:42:47 <NihilistDandy> I brought this into one of my regular chans to use as an answering machine and for Haskelly convenience. Took 5 minutes until I had to compile a custom one for that server without most of the flood-friendly options
09:43:31 <applicative> > let a = text "haha" in a $$ a
09:43:32 <LambdaTemp>   haha
09:43:33 <LambdaTemp>  haha
09:43:45 <applicative> i think i can flood it just fine....
09:43:56 <NihilistDandy> applicative: Not flooding the bot, flooding the channel
09:44:11 <applicative> > let a = text "haha" in a $$ a $$ a $$ a
09:44:12 <LambdaTemp>   haha
09:44:12 <LambdaTemp>  haha
09:44:12 <LambdaTemp>  haha
09:44:12 <LambdaTemp>  haha
09:44:33 <monochrom> > text "Gödel α ⊑ f ⊥"
09:44:34 <LambdaTemp>   Gödel α ⊑ f ⊥
09:44:35 <NihilistDandy> applicative: This is the full-featured one :D
09:44:45 <monochrom> excellent. lambdabot was broken on that
09:44:53 <Axman6> > let a = text "test" in foldl ($$) (text "") (replicate 10 a)
09:44:54 <LambdaTemp>   test
09:44:54 <LambdaTemp>  test
09:44:54 <LambdaTemp>  test
09:44:54 <LambdaTemp>  test
09:44:54 <LambdaTemp>  test
09:44:56 <LambdaTemp> [5 @more lines]
09:44:58 <applicative> > let a = text "haha" in foldr ($$) a (repeat a)
09:45:00 <LambdaTemp>   *Exception: stack overflow
09:45:00 <Axman6> good
09:45:12 <Axman6> > let a = text "test" in foldl ($$) (text "") (replicate 1000 a)
09:45:13 <LambdaTemp>   test
09:45:13 <LambdaTemp>  test
09:45:13 <LambdaTemp>  test
09:45:13 <LambdaTemp>  test
09:45:13 <LambdaTemp>  test
09:45:15 <LambdaTemp> [8 @more lines]
09:45:23 <Axman6> only 8? i think not
09:45:42 <monochrom> @more
09:45:43 <LambdaTemp>  test
09:45:43 <LambdaTemp>  test
09:45:43 <LambdaTemp>  test
09:45:43 <LambdaTemp>  test
09:45:43 <LambdaTemp>  test
09:45:45 <LambdaTemp> [3 @more lines]
09:45:52 <monochrom> @more
09:45:53 <LambdaTemp>  test
09:45:53 <LambdaTemp>  test
09:45:53 <LambdaTemp>  tes...
09:45:59 <monochrom> hahaha that's why!
09:46:02 <applicative> Axman6 is probably a terrorist hacker, like J. Assange!
09:46:04 <NihilistDandy> > [1..]
09:46:05 <LambdaTemp>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:46:26 <monochrom> the temp is better than the original already!
09:46:38 <Axman6> applicative: you'll never catch me alive!
09:46:54 <monochrom> not over his dead body!
09:46:54 <zygoloid> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> j u s t  a n o t h e r  h a s k e l l  h a c k e r
09:46:58 <LambdaTemp> const . (const .) . ((const .) .) . ((const .) .) . (((const .) .) .) . ((((((const .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((((((
09:46:58 <LambdaTemp> const .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((const .) .) .) .) .) .) .) .) .
09:46:58 <LambdaTemp> ) .) .) .) . ((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .)
09:46:58 <LambdaTemp>  .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((ap .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .)
09:46:58 <LambdaTemp> .) .) .) .) .) .) .) . flip (flip . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((
09:47:00 <LambdaTemp> [19 @more lines]
09:47:02 <LambdaTemp> optimization suspended, use @pl-resume to continue.
09:47:15 <absentia> @marsboobs
09:47:16 <LambdaTemp> Unknown command, try @list
09:47:28 <applicative> > reduction (1+2*(3+4))
09:47:30 <LambdaTemp>   Not in scope: `reduction'
09:47:37 <applicative> > reduce (1+2*(3+4))
09:47:39 <LambdaTemp>   1 + 2 * 7
09:47:55 <applicative> @type iterate reduce
09:47:57 <LambdaTemp> Expr -> [Expr]
09:47:59 <Axman6> @quote benl23
09:47:59 <LambdaTemp> No quotes match. Maybe if you used more than just two fingers...
09:48:12 <monochrom> > reduce (reduce (1+2*(3+4)))
09:48:13 <LambdaTemp>   1 + 14
09:48:15 <Axman6> bah, he's had some good exponential @pl inputs
09:48:16 <monochrom> ah
09:48:50 <NihilistDandy> Axman6: It only has the Quote state from the default lambdabot build. So no recent quotes :(
09:48:59 <Axman6> right
09:49:15 <monochrom> so my fromIntegral quote goes into the default Quote state canon?! :)
09:49:23 <NihilistDandy> Seems so :D
09:50:01 <monochrom> @quote monochrom Kripke
09:50:02 <LambdaTemp> monochrom says: There are truths, damn truths, and Kripke structures.
09:50:04 <monochrom> hehe
09:50:23 <NihilistDandy> Thought I seem to be getting Hoogle errors with @hoogle. Not sure what that's about
09:50:26 <NihilistDandy> *Though
09:50:45 <NihilistDandy> What happened to lambdabot, anyway?
09:51:18 <applicative> @type reduced
09:51:21 <LambdaTemp> Not in scope: `reduced'
09:51:30 <merijn> NihilistDandy: Crashed, probably
09:52:01 <Saizan> NihilistDandy: did you install hoolge?
09:52:16 <NihilistDandy> Saizan: lol, that might be the issue O.o
09:52:54 <NihilistDandy> If anyone notices anything libs missing that they'd like installed, just leave me a @tell and I'll get them up ASAP
09:52:58 <NihilistDandy> *any
09:58:05 <Axman6> well, got a reply from the author about the naming in iterIO. looks to me like he needs more convincing that the names are better, but is open to the idea. more voices are very much welcome =)
09:58:11 <NihilistDandy> @hoogle test
09:58:12 <LambdaTemp> Could not find some databases: default
09:58:12 <LambdaTemp> Searching in:
09:58:12 <LambdaTemp>   .
10:02:28 <NihilistDandy> @hoogle test
10:02:28 <LambdaTemp> Data.Bits testBit :: Bits a => a -> Int -> Bool
10:02:28 <LambdaTemp> Test.HUnit.Base data Test
10:02:28 <LambdaTemp> Test.QuickCheck.Test test :: State -> (StdGen -> Int -> Prop) -> IO Result
10:02:32 <NihilistDandy> There we go
10:04:05 * hackagebot mongrel2-handler 0.1.0 - Mongrel2 Handler Library  http://hackage.haskell.org/package/mongrel2-handler-0.1.0 (BardurArantsson)
10:06:08 <applicative> > let red a = a : red (reduce a); rrr = hcat . intersperse (text " ==> ") . map (text . show) . take 5 . red  in rrr (2 * (3 + (3 * 2 +1)))
10:06:13 <LambdaTemp>   mueval-core: Time limit exceeded
10:06:22 <applicative> hmmm
10:06:25 <NihilistDandy> Try it again. Mueval is sometimes a little slow the first time
10:06:30 <applicative> > let red a = a : red (reduce a); rrr = hcat . intersperse (text " ==> ") . map (text . show) . take 5 . red  in rrr (2 * (3 + (3 * 2 +1)))
10:06:33 <LambdaTemp>   2 * (3 + (3 * 2 + 1)) ==> 2 * (3 + (6 + 1)) ==> 2 * (3 + 7) ==> 2 * 10 ==> 20
10:06:40 <applicative> not too bad
10:06:46 <NihilistDandy> Yeah, sorry. It's just a laptop
10:07:06 <applicative> > let red a = a : red (reduce a); rrr = vcat . intersperse (text " ==> ") . map (text . show) . take 5 . red  in rrr (2 * (3 + (3 * 2 +1)))
10:07:08 <LambdaTemp>   2 * (3 + (3 * 2 + 1))
10:07:08 <LambdaTemp>   ==>
10:07:08 <LambdaTemp>  2 * (3 + (6 + 1))
10:07:08 <LambdaTemp>   ==>
10:07:08 <LambdaTemp>  2 * (3 + 7)
10:07:10 <LambdaTemp>   ==>
10:07:12 <LambdaTemp> ...
10:09:00 <applicative> > let red a = a : red (reduce a); rrr = hcat . intersperse (text " ==> ") . map (text . show) . take 5 . red  in rrr (foldr (+) 0 [1..5])
10:09:03 <LambdaTemp>   1 + (2 + (3 + (4 + (5 + 0)))) ==> 1 + (2 + (3 + (4 + 5))) ==> 1 + (2 + (3 +...
10:09:10 <applicative> > let red a = a : red (reduce a); rrr = hcat . intersperse (text " ==> ") . map (text . show) . take 5 . red  in rrr (foldl (+) 0 [1..5])
10:09:12 <LambdaTemp>   0 + 1 + 2 + 3 + 4 + 5 ==> 1 + 2 + 3 + 4 + 5 ==> 3 + 3 + 4 + 5 ==> 6 + 4 + 5...
10:10:02 * applicative can see why 'reduction' from Simple.Reflect is not imported by lambabot
10:11:18 <NihilistDandy> Heh. It's all surprisingly safe. Well-sandboxed and so on. The people in my testing channel spent hours trying to break it :D
10:12:13 <applicative> > let red a = a : red (reduce a); rrr = hcat . intersperse (text " ==> ") . map (text . show) . take 5 . red  in rrr (foldl (f) 0 [1..5])
10:12:18 <LambdaTemp>   mueval-core: Time limit exceeded
10:12:25 <applicative> > let red a = a : red (reduce a); rrr = hcat . intersperse (text " ==> ") . map (text . show) . take 5 . red  in rrr (foldl (f) 0 [1..5])
10:12:27 <LambdaTemp>   f (f (f (f (f 0 1) 2) 3) 4) 5 ==> f (f (f (f (f 0 1) 2) 3) 4) 5 ==> f (f (f...
10:12:55 <applicative> it doesn't show original unfolding of the "fold..." expression
10:13:10 <NihilistDandy> @more?
10:13:22 <applicative> @previous
10:13:22 <LambdaTemp> Unknown command, try @list
10:13:56 <NihilistDandy> Reaction time's a little atrocious at times
10:16:03 <NihilistDandy> applicative: Any idea what plugin provides @previous? I can get ahold of it and recompile
10:17:39 <applicative> Nihilist, no i made it up, I was just complaining that "reduce" applied to a fold goes immediately to the (a % (b % (c % d))) form, then reduces; but it doesn't show it being unpacked.
10:17:53 <applicative> which is already reduction
10:18:32 <NihilistDandy> Ah
10:25:07 <nyingen> hunh, what happened to lambdabot
10:27:08 <NihilistDandy> nyingen: Use LambdaTemp
10:39:12 * hackagebot barchart 0.1.1.1 - Creating Bar Charts in Haskell  http://hackage.haskell.org/package/barchart-0.1.1.1 (SebastianFischer)
10:40:34 <nyingen> yes, but what happened to lambdabot itself
10:40:55 <pmetzger> nyingen: earlier it was claimed it was on maternity leave.
10:41:06 <pmetzger> nyingen: though I suspect that may not be the entire truth. :)
10:41:19 <nyingen> it's giving birth to other, smaller bots?
10:41:23 <nyingen> how cute
10:41:53 <merijn> Or, more likely, it or the machine it ran on crashed
10:42:23 <kmc> i want a baby lambdabot
10:42:33 <merijn> BerkeleyDB-0.8.1 failed during the configure step. The exception was:
10:42:33 <merijn> ExitFailure 1
10:42:44 <merijn> Well, that's an helpful error...
10:43:52 <applicative> theres cabal -v install ...
10:44:19 <NihilistDandy> @where+ lambdabot Maternity leave
10:44:19 <LambdaTemp> Nice!
10:44:25 <merijn> Ah, apparently it cannot find the C library. Time to go play "How the hell do I install the appropriate library?!"
10:44:32 <Phantom_Hoover> WHERE LAMBDABOT
10:44:42 <NihilistDandy> @WHERE LAMBDABOT
10:44:42 <LambdaTemp> Unknown command, try @list
10:44:53 <kmc> yell louder
10:44:54 <NihilistDandy> @where LAMBDABOT
10:44:54 <LambdaTemp> Maternity leave
10:45:04 <nyingen> she's having twins, btw
10:45:32 <NihilistDandy> My favorite thing when I'm tired is this.
10:45:37 <NihilistDandy> "Oh, bot, I think I need to sleep"
10:45:39 <NihilistDandy> :t sleep
10:45:43 <LambdaTemp> Not in scope: `sleep'
10:45:52 <NihilistDandy> Well, you're right, bot.
10:45:55 <Phantom_Hoover> Can LambdaTemp be made to do things in other channels.
10:46:15 <NihilistDandy> Phantom_Hoover: Not sure. Do you mean can I have it join other channels?
10:46:22 <Phantom_Hoover> Yes.
10:46:25 <Phantom_Hoover> IT'S CHAOS
10:46:37 <NihilistDandy> Yeah, sure. Just clear it with the ops and I'll edit the online.rc
10:46:42 <Phantom_Hoover> People are tearing each other apart to use their brains for a computational substrate!
10:47:53 <NihilistDandy> What channel? That sounds like a hell of a show
10:48:01 <pmetzger> haskell-blah?
10:48:16 <Phantom_Hoover> #esoteric
10:48:32 <Phantom_Hoover> We were on lambdabot's autojoin list.
10:48:42 <NihilistDandy> All right. I'll add you
10:49:03 <cpressey> Hi, I have a question about Control.Exception.try in ghci 6.12.1.  Why does the following expression not produce a Left value: try (do return (head [])) ?  Instead it produces Right "*** Exception: Prelude.head: empty list".
10:49:23 <pmetzger> what
10:49:25 <pmetzger> gah
10:49:36 <pmetzger> what's #esoteric, for things even more #esoteric than #haskell?
10:49:45 <cpressey> pmetzger: yes
10:49:52 <Phantom_Hoover> pmetzger, ostensibly.
10:50:03 <merijn> pmetzger: The REALLY esoteric stuff, cause even Coq, Agda and Epigram have their own channels :p
10:50:18 <nyingen> cpressey: like what? snusp?
10:50:20 <cpressey> I tried my expression in LambdaTemp, but it does not seem to import Control.Exception
10:50:22 <NihilistDandy> Phantom_Hoover: Done and done
10:50:35 <cpressey> nyingen: yes, like SNUSP
10:50:42 <nyingen> neat.
10:51:05 * Phantom_Hoover can't decide whether he hates SNUSP or now.
10:51:07 <Phantom_Hoover> *not
10:51:46 <pmetzger> I don't even know what Epigram is. :)
10:51:56 <Phantom_Hoover> I mean, it's technically a Brainfuck derivative... but it has an element of originality... AUGH
10:52:05 <kmc> "esoteric language" usually means a language designed to be bizarre and difficult, as a fun challenge, rather than something designed for getting work done
10:52:14 <kmc> like Brainfuck, Malbolge, or C++
10:52:14 <nyingen> how about piet
10:52:24 <nyingen> Some friends and I played around with that recently
10:52:48 <nyingen> we were trying to make a logo for a conference we were hosting, that would also run as a program
10:53:04 <kmc> nice
10:53:05 <NihilistDandy> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
10:53:07 <LambdaTemp>   Hello World!
10:53:16 <pmetzger> C++ isn't designed as a challenge. It is a way of increasing demand for programmers.
10:53:26 <nyingen> hey that looks like line noise
10:53:28 <Phantom_Hoover> nyingen, I can't hate Piet, it was made by DMM!
10:53:32 * kmc recently had to write two Brainfuck programs with the same MD5 hash that do different things
10:53:36 <nyingen> I mean like actual line noise
10:53:40 <pmetzger> for a language that really looks like line noise, see teco.
10:53:50 <kmc> you can sprinkle arbitrary other characters through your brainfuck
10:53:54 <pmetzger> Teco looks like actual line noise -- control characters are valid code.
10:53:59 <kmc> then it really looks like line noise
10:54:08 <elliott> i hear we're talking about esolangs
10:54:12 <NihilistDandy> I kinda like unlambda
10:54:13 <kmc> C++ is the world's most successful esolang, i'm sorry that so few of you get the joke
10:54:21 <nyingen> kmc: no, I agree with you
10:54:57 <pmetzger> The day I ran an implementation of Ackermann's function in the template language through gcc was the day I got the joke.
10:55:21 <kmc> you can also do that in C preprocessor or GHC typeclasses
10:55:27 <Phantom_Hoover> NihilistDandy, there's also Lazy K, which is basically pure SKI calculus with functional I/O.
10:55:29 <NihilistDandy> kmc: lol
10:55:36 <elliott> pmetzger: it's the kind of joke you can't laugh at because it's too depressing
10:55:40 <NihilistDandy> Phantom_Hoover: Yeah, I saw that. Looks fun
10:55:46 <kmc> it's dark humor
10:55:58 <NihilistDandy> The only good kind of humor
10:56:27 <pmetzger> kmc: you can't implement ackermann's function in the C preprocessor.
10:56:36 <Phantom_Hoover> (I wrote bits of an IO monad for it, but noöne cared.)
10:56:37 <pmetzger> kmc: or if you can, I don't know how, which I suppose is a different statment.
10:56:37 <kmc> is it only primitive recursive?
10:56:48 <kmc> i think you can do arbitrary looping by having a file re-include itself
10:57:11 <ddarius> kmc: You can except the standard limits the depth of that.
10:57:17 <pmetzger> kmc: I believe you can't actually have a macro expand into an #include and have the #include honored.
10:57:21 <elliott> pmetzger: no
10:57:23 <elliott> you can't
10:57:25 <elliott> kmc: it is TC
10:57:35 <pmetzger> it doesn't reevaluate what it puts out until it fixpoints.
10:57:36 <elliott> and I can prove it :)
10:57:50 <elliott> pmetzger: it has provisions to prevent fixedpointing
10:58:04 * elliott finds the link
10:58:05 <Phantom_Hoover> elliott, are you talking about that stuff you did in CPP when you were in the loony bin?
10:58:13 <elliott> hmm
10:58:17 <elliott> it was a google groups link
10:58:21 <elliott> grep is slow :(
10:58:28 <monqy> is this this again
10:59:52 <pmetzger> lisp macros are of course turing equivalent. what is more surprising is that scheme hygienic macros are too.
11:00:08 <pmetzger> C++ templates are. vi macros are, which is bizarre.
11:00:20 <ddarius> Not really.
11:00:29 <pmetzger> sendmail cf files turned out to be turing equivalent, not that any rational person would have wanted to find that out.
11:00:45 <NihilistDandy> Rationality is for robots
11:00:50 <kmc> are those the M4 files or the things the M4 files shit out
11:00:54 <ddarius> NihilistDandy: No it isn't.
11:01:03 <NihilistDandy> ddarius: I know.
11:01:06 <kmc> i'm a robot
11:01:11 <NihilistDandy> Bleep blorp
11:01:23 <pmetzger> kmc: the things the m4 files spit out. the production grammar language.
11:01:30 <ddarius> Rationality is for God.  The rest of us have, at best, bounded rationality.
11:01:37 <NihilistDandy> ddarius: Robots can't be trusted with rationality. Makes 'em rise up
11:01:50 <elliott> found it
11:01:55 <pmetzger> kmc: before postfix became the thing to use, I was able to actually read and write sendmail.cf -- I was very happy to free those neurons for other things.
11:02:11 <elliott> pmetzger: kmc: http://groups.google.com/group/comp.lang.c/msg/082ffefaaed3b450 <-- This is only the Fibonacci sequence, but there is also an interpreter for a full functional language in cpp.
11:02:27 <elliott> pmetzger: kmc: Not only is that fibonacci, it's /bignum/ fibonacci, with a bignum implementation from scratch on top of the preprocessor.
11:02:32 <pmetzger> it is trying to force me to log on to google groups.
11:02:34 <kmc> shiny
11:02:34 <pmetzger> WTF?
11:02:42 <elliott> pmetzger: I think if you enable JS that goes away ><_
11:02:43 <elliott> >_<
11:03:12 <pmetzger> I have javascript enabled.
11:03:15 <monqy> google groups does that
11:03:17 <elliott> pmetzger: dunno then
11:03:27 <elliott> I'll find the 99 bottles of beer written in a functional language on top of cpp now :)
11:03:43 <elliott> http://chaos-pp.cvs.sourceforge.net/viewvc/chaos-pp/order-pp/example/bottles.c?revision=1.10&content-type=text%2Fplain
11:03:56 <elliott> it even has lambdas
11:03:58 <pmetzger> how does chaos-preprocessor work?
11:04:03 <elliott> pmetzger: complicatedly
11:04:07 <elliott> I'm not entirely sure myself
11:04:09 <pmetzger> so you made CPP turing equivalent? nasty.
11:04:11 <elliott> it involves a very confusing interpreter
11:04:14 <elliott> pmetzger: I didn't, someone else did :-)
11:04:17 <elliott> or rather, proved it so
11:04:53 <elliott> hmm, that fibonacci I linked isn't just bignum, it's actually polymorphic on all kinds of number chaos-pp supports...
11:04:53 <pmetzger> weird. it is so often the case that some innocent property suddenly unleashes the full power where you least expect it.
11:04:59 <elliott> Num a => in the preprocessor :-D
11:05:16 <elliott> pmetzger: all this, and cpp actually deliberately /stops/ you being able to recurse in the obvious way, to prevent mistakes...
11:05:18 <c_wraith> it's really hard to not be turing-complete, actually.  It takes discipline
11:05:37 <kmc> yeah.  people keep proving ⊥ in Agda
11:05:49 <elliott> kmc: to be fair, Agda's kernel policy is "THROW IT ALL IN THERE" :)
11:08:34 <pmetzger> is agda more intended for proofs or for programs? (yes, I know they're equivalent, but there is a difference of intent...)
11:09:10 <ddarius> From what I can tell chaos-pp is based on the Boost library and doesn't do anything particularly different to handle recursion, which in Boost, is done by simply using an exponential expansion, i.e. is not Turing-complete.
11:09:42 <elliott> ddarius: hmm, order-pp seems to have full lambdas, though
11:10:00 <edwardk> aristid, applicative: you did see the slides i have on iteratees, right? =)
11:10:05 <kmc> pmetzger, it's intended to be more for programs than Coq is
11:10:11 <kmc> but it's still mostly used for proofs
11:10:19 <edwardk> pmetzger: i've seen at least one agda program executed for its effects. can't say the same about coq ;)
11:10:31 <pmetzger> but the basis isn't known sound the way Coq's is, right? or am I mistaken. I haven't looked at it at all.
11:10:42 <kmc> i've seen a few Coq libraries that were extracted to OCaml or Haskell and used
11:10:46 <elliott> edwardk: Coq is a good language to implement /bin/true in.
11:10:51 <edwardk> (mild exaggeration)
11:10:53 <elliott> pmetzger: yeah, Agda's a lot more... experimental...
11:11:03 <elliott> Coq is easier to write proofs in too :)
11:11:45 <edwardk> elliott: my experience with both is that when i write a proof in coq, i know the tactic system understands the proof. when i write a proof in agda, i know that i understand the proof.
11:11:45 <kmc> Coq is easier for writing incomprehensible proofs
11:11:51 <kmc> exactly
11:12:05 <elliott> edwardk: And so with Coq you have the potential to prove far more than you would with Agda :)
11:12:09 <kmc> Proof.  auto. intros. inversion H2 as H4.  inversion H5... Qed.
11:12:10 <elliott> that's a property of abstraction in general, IMO
11:12:11 <kmc> isn't that so obvious
11:12:12 <pmetzger> I hate the UI in Coq.
11:12:18 <elliott> kmc: It is when you step through it in ProofGeneral.
11:12:20 <NihilistDandy> Back later. @tell me about any problems with the bot
11:12:20 <edwardk> elliott: i don't know that to be the case
11:12:21 <pmetzger> I have done a bunch of Coq proofs, though all in a class setting.
11:12:31 <kmc> i love how the binding occurrences of the names are implicit
11:12:35 <aristid> edwardk: no, i haven't seen these slides yet
11:12:43 <pmetzger> I hated that if you built up some complicated tactic and it failed it had such poor debugging facilities...
11:13:20 <edwardk> agda is the more interesting approach to me. the 'hair shirt' they are wearing is forcing them to build _better structured_ proofs with more reusable components. lots of coq proofs tend to go 'and then magic happens...' and rely on a huge mess of tactics.
11:13:49 * ddarius agrees with edwardk.
11:13:57 <pmetzger> edwardk: that's been my experience in Coq.
11:14:14 <edwardk> the agda approach of starting to play with reflection on the structure of the problem to build provers in agda itself rather than as some one-off ad hoc metalanguage is very interesting to me
11:14:20 <pmetzger> Really what I'd like is a system that generates long and boring but human readable steps from the tactics. proof objects are just not readable.
11:14:24 <gwern> > 3+100+20+10+40
11:14:24 <pmetzger> you have to interpret them in your head.
11:14:26 <LambdaTemp>   173
11:14:38 <elliott> edwardk: Sure, but Coq is definitely more usable for writing proofs, today.
11:14:48 <elliott> (And also more trustworthy because of the kernel.)
11:14:50 <kmc> Ltac is *super* ad hoc too
11:15:01 <kmc> from what i've seen i'd rather write tactics in OCaml directly
11:15:04 <joe6> what is the simplest way of building a haskell socket client?
11:15:08 <joe6> any easy library?
11:15:12 <c_wraith> network
11:15:24 <c_wraith> sockets aren't hard
11:15:36 <ddarius> c_wraith: That was my reaction.
11:15:42 <monochrom> traditionally, tactic writers have focused more on decision procedure speed than generating an explanation. hell, almost non-existent for the latter actually
11:15:52 <burp> joe6: network-fancy
11:16:16 <pmetzger> monochrom: yah, but then you have no explanation and you fail to build intuition to get around the next similar-but-not-identical proof problem.
11:16:22 <kmc> cool burp
11:16:31 <kmc> although i cringe at any type class which lumps together String and ByteString
11:16:51 <pmetzger> monochrom: I dislike that too. I want to understand the ideas behind the proof, even if boring, so I can do it again in new contexts. this is a proof assistant system, so I need to be able to assist.
11:17:05 <edwardk> elliott: as it stands, i agree with you in most areas, but i also argue that i get more out of the proofs i do in agda and there are places where agda pulls ahead, for instance it is a lot easier to work in agda with big balls of mixed induction/coinduction.
11:17:45 <pmetzger> in coq, too often I compose some tactics and throw them at the problem until it tells me it worked and I've proven something but I don't know how.
11:17:52 <pmetzger> and I'm too lazy to figure it out and move on.
11:17:57 <pmetzger> and I've learned nothing for next time.
11:18:07 <pmetzger> maybe I'm just using it wrong but it is really tempting to do that.
11:18:23 <monochrom> what happened in industry to drive this tradition: if the tactic says "yes", people don't want to know why, people already have their own ideas. only when the tactic says "no", do people want to know why, what is a counterexample etc for debugging
11:18:30 <pmetzger> I only used it a lot for a few months though, maybe if I'd gone longer I would have figured it out on a deeper level.
11:18:57 <pmetzger> monochrom: but you spend all your time on it saying "no" before it says "yes". if you know why, you can get to "yes" faster.
11:19:02 <pmetzger> and spend less time screwing around.
11:19:31 <joe6> agda needs to mature a little more, and, then it would be a great general purpose programming language.
11:19:35 <elliott> monochrom: I think it's a bit much to say Coq is like that because of stupid industry factors :)
11:19:40 <edwardk> pmetzger: that is why i like agda. i can't bring myself to write a lot of agda, but what i write in it, i really like when i'm done ;)
11:19:42 <monochrom> and for the case the when tactic isn't enough for a near-identical proof: people file a bug report to the tactic writer
11:19:45 <joe6> the type system makes things so much more simpler
11:20:02 <joe6> compared to the loops we jump in haskell.
11:20:16 <kmc> yes, dependent types are very simple
11:20:20 <kmc> fewer arbitrary restrictions
11:20:43 <joe6> kmc, are you being sarcastic?
11:20:53 <kmc> not at all
11:21:04 <kmc> dependent types are simpler
11:21:17 <edwardk> the price of them is just the loss of most useful bits of inference
11:21:28 <pmetzger> dependent types are conceptually simpler, but isn't it a pain to show that you're applying the right type?
11:21:37 <edwardk> for lots of domains that is a reasonable price to pay
11:21:42 <monochrom> Coq is not influenced as much by industry concerns. but Coq is influenced by other theorem provers that in turn are influenced by industry concerns
11:21:56 <kmc> dependent types seem harder than Haskell's type system because the only people who use them are trying to do much more with them
11:22:10 <kmc> there's fewer kinds of things in a DT system
11:22:19 <edwardk> the thing i don't like about coq is that to do anything non trivial involving extraction, etc. there is literally no documentation. the reference is the source in many places.
11:22:24 <kmc> you get to use the familiar tools for abstraction at the type level
11:22:34 <kmc> rather than awkwardly semi-duplicating everything, the way Haskell does
11:22:35 <pmetzger> my biggest complaint about coq was when it fails in some ginormous tactic it give you no idea what steps it took to fail. debugging was always a bitch. maybe that is because I didn't know my way around the tool well enough.
11:22:39 <edwardk> or what material is available is entirely in french
11:22:44 <pmetzger> but other people didn't seem to have better advice for me.
11:22:52 <joe6> kmc, yes, the ability to use values in type signatures.
11:23:19 <joe6> a lot of agda vs coq discussions on #haskell these days.
11:23:22 <kmc> edwardk, i had that problem when writing a compiler that targets the OCaml VM
11:23:49 <edwardk> but that said, i find it hard to bash coq in general. it is here, it has been around longer, and it has picked up lots of interesting bits along the way
11:24:15 <edwardk> (e.g. i love the Program extension, etc.)
11:24:16 <pmetzger> someday I'd love to use an integrated programming language and proof system for doing real work programs though. something where I can prove properties of the functions and have the compiler aware that they're proven. dependent types are a sort of way to do that.
11:24:29 <pmetzger> but I'm not man enough to use such things yet.
11:24:53 <pmetzger> So if Agda is used for proofs, is it strongly normalizing?
11:25:20 <kmc> yes
11:25:22 <kmc> it has a termination checker
11:25:26 <kmc> (which you're allowed to ignore)
11:25:32 <edwardk> pmetzger: i actually fell into haskell after a long time hacking in that sort of imperative separation-logic-based reasoned space. i'm much happier now =)
11:25:49 <pmetzger> so you can write non-terminating programs if you want to but not all the time.
11:26:08 <kmc> i guess it requires termination when you use a term as coercion evidence?
11:26:14 <kmc> or it forces the term at runtime
11:26:14 <edwardk> i'm more than content to let smerdyakov and others hack on YNOT and hoare type theory and what have you to see if they can get usable tactics to make that programming style tolerable in coq
11:26:15 <pmetzger> but then does it keep track of which functions have proof of termination and which do not?
11:26:15 <kmc> not sure which
11:26:47 <monochrom> acl2 is a theorem prover that tries to explain why a proof succeeds
11:27:01 <pmetzger> acl2 was the first theorem prover I touched.
11:27:07 <pmetzger> but I'm an old lisphead.
11:27:15 <pmetzger> er proof assistant I guess is the right term.
11:27:17 <kmc> ACL2 looks really cool
11:27:24 <kmc> too bad it's obscure due to the Curse of the Parentheses
11:27:29 <pmetzger> acl2 is used for a lot of hardware work apparently.
11:27:45 <pmetzger> kmc: I actually prefer parentheses. I find I can parse code better when it is in cambridge polish notation.
11:27:46 <kmc> i've realized that it's impossible to discuss lisp online without getting hung up on uninteresting syntax issues
11:28:10 <edwardk> aristid: http://comonad.com/reader/2009/iteratees-parsec-and-monoid/
11:28:11 <pmetzger> kmc: I'm sure that's a matter of taste, but I find even the minimal syntax in a language like haskell frustrating. I run into precedence issues too often.
11:28:17 <monochrom> for example when you enter a recursive function, first thing acl2 does is try to prove termination automatically, and usually it succeeds, and usually the message says "using the ___ relation which is well-founded, using measure ___ ..."
11:28:19 <pmetzger> kmc: my mind is probably just not built to remember precedences.
11:28:59 <edwardk> acl2 falls into the 'i know it knows its correct, but how do i know its correct?' category for me
11:29:15 <monochrom> I personally do not like the writing order (implies x y) I really like infix
11:30:06 <monochrom> but that can be dealt with. my real gripe is acl2's second-class treatment of ∃
11:30:07 <edwardk> (when talking about the theorems it proves, not the implementation)
11:31:20 <pmetzger> I find prefix much more natural. Again, I think that is a matter of what one is used to and taste, there is no right or wrong answer.
11:31:46 <pmetzger> what provides comfort is personal. different people find different tools and styles comfortable.
11:31:59 <monochrom> acl2's quantifier story is pretty much that of hindley-milner. you write "... x ... y ...", and if that is the full sentence, it means "forall x,y. ... x ... y ..."
11:32:22 <pmetzger> to me, prefix notation is nice because it lets me keep track of what gets applied to what without having to build a parse tree in my head -- the parse tree is in front of me.
11:32:36 <monochrom> ok, so now if you want to do "(forall x. ...) implies (exist y ...)", you have to do encoding!
11:32:41 * kmc smiles as he is proven right
11:33:00 <merijn> pmetzger: Solution, don't edit/write text, just program directly using the ASG :>
11:33:21 <pmetzger> merijn: but in some sense, that's what cambridge prefix notation is -- a flattened abstract syntax tree.
11:33:38 <Saizan> kmc++
11:33:40 <pmetzger> merijn: but again, I don't claim this is the right way for everyone.
11:33:46 <rothwell> merijn: best not to comment, lest you get dragged in... uh oh
11:33:49 <pmetzger> kmc: I agree with you. it is just too tempting to mention.
11:34:26 <merijn> rothwell: I only mention this because we had a discussion about this in -blah yesterday with a very cool looking prototype for structural editing
11:34:26 <pmetzger> If blathering about parens is poor taste I'll drop it. :)
11:34:51 <monochrom> use rpn to eliminate parentheses
11:35:11 <pmetzger> rpn is comfortable to me, too, but it is harder when there are functions with different arity around.
11:35:16 <merijn> Modifying a C file by directly manipulating the ASG, so that renaming a variable for example automatically changes the name of all references to it as well
11:35:42 <pmetzger> merijn: I'm building a tool to do something like that right now actually. refactoring C from the tree.
11:36:01 <pmetzger> merijn: but my main interest isn't doing things like variable renamings or even keeping the result as valid C code.
11:36:33 <kmc> dealing with C in this way would require expanding and re-folding macros
11:36:44 <pmetzger> kmc: the real barrier is the preprocessor. :(
11:37:06 <pmetzger> kmc: at least if you want to generate something human readable out the other side and not lose that part by running CPP first.
11:37:34 <pmetzger> kmc: the preprocessor makes lots of tools hard. the go people got rid of it and thus have all these funky refactoring tools that manipulate the AST and spit the program back out.
11:38:02 <pmetzger> kmc: so yah, macros are a pain.
11:38:15 <kmc> but you can't get rid of the C preprocessor without adding lots of new features
11:38:21 <pmetzger> kmc: yup.
11:38:30 * kmc tries to imagine what Linux would look like without macros
11:38:40 <pmetzger> kmc: I've been imagining that a bit myself.
11:38:48 <monqy> I try not to imagine that
11:39:02 <kmc> then again it's debatable whether Linux is written in C
11:39:14 <pmetzger> kmc: oh, it is C. :(
11:39:15 <kmc> they use a huge pile of GCC extensions
11:39:21 * hackagebot yesod-goodies 0.0.3 - A collection of various small helpers useful in any yesod application.  http://hackage.haskell.org/package/yesod-goodies-0.0.3 (PatrickBrisbin)
11:39:45 <pmetzger> kmc: the gcc extensions have, to a large extent, migrated into things like c99. not the extended asm and such of course.
11:39:59 <dilinger> and then there's the lack of libc
11:40:15 <pmetzger> dilinger: in the kernel you mean?
11:40:32 <kmc> they use a ton of stuff beyond C99
11:40:50 <dilinger> yeah.  my userspace C code always fails to compile due to printk()s accidentally being used
11:41:40 <pmetzger> kmc: I'm trying to remember what's beyond C99 in gcc. expression statements? the fake assigned gotos?
11:42:15 <kmc> http://gcc.gnu.org/onlinedocs/gcc-4.6.0/gcc/C-Extensions.html#C-Extensions
11:42:32 <pmetzger> most of those are c99. complex etc.
11:42:41 <kmc> no
11:42:51 <pmetzger> arrays at the end of structs, hex floats, they're all in there
11:42:56 <pmetzger> if only with different syntax
11:43:04 <kmc> what about all the function attributes, type attributes, etc
11:43:17 <pmetzger> oh you mean like __noreturn or what have you?
11:43:27 <kmc> http://gcc.gnu.org/onlinedocs/gcc-4.6.0/gcc/Function-Attributes.html#Function-Attributes
11:43:36 <kmc> there's a lot of them
11:43:47 <kmc> there's also hundreds of GCC built-in "functions"
11:43:52 <kmc> many of which do not behave like functions at all
11:44:01 <pmetzger> yah, but most of those are advisory. the built in functions are mostly things you could in theory implement in asm.
11:44:08 <kmc> no they aren't
11:44:08 <pmetzger> but not with the same performance.
11:44:15 <kmc> many of them tie deeply into the compiler
11:44:19 <pmetzger> they inline memcpy and others...
11:44:25 <kmc> why don't you actually look at the list
11:44:45 <kmc> the first one: "Built-in Function: int __builtin_types_compatible_p (type1, type2)  You can use the built-in function __builtin_types_compatible_p to determine whether two types are the same"
11:44:50 <pmetzger> well, I used to hack this stuff, I don't think they use most of those function attributes or builtins...
11:44:55 <ddarius> kmc: Anything called an "attribute" is clearly non-crucial.
11:44:58 <pmetzger> (in the linux kernel).
11:45:12 <kmc> "You may use __builtin_expect to provide the compiler with branch prediction information."
11:45:16 <pmetzger> the attributes are often things that create or stop warnings...
11:45:18 <kmc> "If control flow reaches the point of the __builtin_unreachable, the program is undefined. It is useful in situations where the compiler cannot deduce the unreachability of the code."
11:45:31 <pmetzger> or improve performance. you can just #define them to nothing and still get valid code out
11:45:47 <kmc> okay, define out __attribute__(section) in Linux and tell me how that works out for you
11:46:01 <pmetzger> that won't work, no, the linker will fail.
11:46:06 <aristid> edwardk: did you actually build Parsimony?
11:46:33 <kmc> Linux also relies on precise control of inlining behavior
11:46:36 <kmc> for correctness
11:47:02 <pmetzger> most of the inlining behavior is now defined in the C standard though.
11:47:11 <kmc> whatever, i'm sick of arguing about this
11:47:18 <pmetzger> sorry, didn't want to piss you off.
11:47:21 <pmetzger> I'll drop it.
11:47:21 <kmc> it's not even on topic
11:47:29 <edwardk> aristid: i did, but i didn't like the performance of the result and never extracted a good general purpose model for the monoidal parsers. so i turned to the iteratee hack mentioned there and gained a factor of 10x, in exchange for a bit of global reasoning
11:48:08 <edwardk> aristid: then i turned to using speculation, and got pretty good results for nearly zero effort and put the whole thing down for a while. ;)
11:48:22 <aristid> edwardk: speculation on top of iteratees?
11:48:35 <aristid> edwardk: did you use oleg's iteratees?
11:49:48 <edwardk> nah, the iteratees i describe in that talk are quite different from oleg's. they maintain their history in a fingertree, giving up the space guarantees for cheap backtracking, making them more suitable for use in the kinds of scenarios i care about. (parsing a whole bunch of source files, keeping interned strings directly referencing the source in memory so they are cheap, and then splicing them together to do preprocessing, but all i
11:50:33 <edwardk> the speculation machinery is actually orthogonal to the use of iteratees, its more of an artifact of the lexer/parser built on top
11:51:16 <aristid> edwardk: but you didn't publish these things in a public package?
11:51:34 <edwardk> aristid: speculation is public, but the lexer on top? no.
11:52:20 <aristid> edwardk: and the fingertree-iteratees?
11:52:22 <edwardk> actually there are source fragments of luthor on github, but it needs a lot of work. i flipped it to unicode lexing, and that necessitated a lot of changes that i never finished
11:52:43 <edwardk> aristid: the code is in the slides mentioned there, stitched together with a couple of typos fixed, it works fine
11:53:22 * hackagebot mysql 0.1.1.0 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.1.0 (BryanOSullivan)
11:53:24 * hackagebot mysql-simple 0.2.1.1 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.1.1 (BryanOSullivan)
11:53:36 <aristid> type Enumerator a = Iterateea -> Iterateea
11:53:41 <aristid> bah, stupid pdf
11:53:45 <aristid> type Enumerator a = Iteratee a -> Iteratee a
11:53:47 <aristid> nice type
11:54:01 <aristid> more optically pleasing than oleg's and enumerator's and iterIO's
11:54:09 <edwardk> it was oleg's original
11:54:18 <aristid> why did he move away from it?
11:54:26 <edwardk> lost track
11:54:40 <aristid> you think it's better than his current one?
11:55:05 <edwardk> no idea. i haven't kicked the tires on his or lato's or anyone else's in quite a while.
11:55:19 <edwardk> looked a bit at the scalaz iteratees for some work code, but thats about it
11:55:25 <aristid> edwardk: with your type you can imagine Enumerators as functions that add input to an Iteratee, right?
11:55:41 <edwardk> aristid: that was the purpose they were originally put to
11:55:45 <edwardk> or one of them
11:56:50 <edwardk> personally i tend to just write Iteratee a -> Iteratee a, but i think i was trying to show the oleg'ish type there for some reason
11:57:38 <aristid> i like the symmetric look
11:57:51 <edwardk> aristid: my favorite combinator in that slide deck is 'sliced'
11:58:09 <aristid> i don't think i'm that far :)
11:58:26 <cheater_> is what clojure calls m-result what haskell calls "return"?
11:58:27 <cheater_> for monads
11:59:08 <aristid> "I actually use a Char Stream that does UTF8 decoding, but it won’t fit on a slide!"
11:59:23 * hackagebot mongrel2-handler 0.1.1 - Mongrel2 Handler Library  http://hackage.haskell.org/package/mongrel2-handler-0.1.1 (BardurArantsson)
11:59:24 <aristid> i wrote a parser, but it is too large for this margin! :D
11:59:37 <edwardk> aristid: next slide ;)
12:00:25 <aristid> edwardk: wait, Parsec actually works with your Iteratees out of the box?
12:00:31 <edwardk> yes
12:00:44 <edwardk> note the choice of 'input' type ;)
12:01:24 <edwardk> when you getInput from parsec in this form of stream you are asking for an Int, which is the number of bytes you are into the stream
12:01:45 <edwardk> Cursor is just a newtype wrapper around Int
12:02:21 <edwardk> this subverts the whole 'all of the input must be present' mentality of parsec 3
12:02:38 <edwardk> and uncons does the dirtywork in the underlying iteratee to get more input
12:02:44 <aristid> but to allow backtracking you still need to store all input in your finger tree?
12:02:50 <edwardk> correct
12:03:13 <aristid> edwardk: so parsing large files this way is NOT feasible?
12:03:21 <edwardk> it'd be slightly nicer with a commit-based parser (like polyparse) than a try-based parser (like parsec) because it could commit and throw away prefixes
12:03:47 <edwardk> aristid: correct. my goal is to parse a bunch of files that fit in memory but to do fast and in parallel
12:04:09 <aristid> i see. that is a bit of a specialised use case
12:04:24 <edwardk> sure, but it is a pretty good fit for compilers in general
12:04:38 <aristid> true
12:04:59 <edwardk> most c compilers keep the entire program buffer in memory for instance, clang, gcc, etc.
12:05:10 <aristid> sometimes i think haskeller have an almost unhealthy obsession with speed
12:05:14 <aristid> *haskellers
12:05:26 <edwardk> in my case i'm mostly sick of compilers only slamming one core ;)
12:05:36 <aristid> heh
12:05:43 <edwardk> i value my time, and would like my compiler to make better use of it ;)
12:06:06 <Will|> Could someone explain to me why, with this code, the getLine seems to be evaluated before the putStr, however if I change the putStr to putStrLn, I get the expected result: http://codepad.org/JQKWNuUS
12:06:24 <edwardk> Will|: buffering on stdout
12:06:43 <Will|> ah, so I'd need to flush after the putStr?
12:06:44 <aristid> edwardk: admit it, you mostly did it because it seemed interesting :>
12:06:59 <merijn> Will|: Yes, that or change the buffering on stdout
12:06:59 <edwardk> Will|: or change the buffering mode of stdout
12:07:13 <edwardk> aristid: i'll hardly deny that
12:08:05 <edwardk> import System.IO and then use something like hSetBuffering stdout NoBuffering
12:08:11 <merijn> edwardk: But if the compiler was faster, when would I slack off?
12:08:37 <aristid> merijn: you should use modern c++. :)
12:08:44 <merijn> Right now I read about haskell stuff when my C code compiles :p
12:09:01 <edwardk> merijn: when you leave work for the day on time for once, because you weren't stuck there all day waiting for the compiler ;)
12:09:39 <merijn> I'm at a university, there's no such thing as leaving work
12:09:47 <merijn> Only "working in a different location"
12:12:14 <cheater_> merijn: ever done any clojure?
12:12:31 <merijn> Not yet
12:12:43 <merijn> It's on my to learn list after Racket and Erlang
12:19:20 <joe6> this works : http://pastebin.com/3dGyNcUZ using Network. This does not, using network.Socket : http://pastebin.com/G3fqkS4n . the error is: *** Exception: connect: unsupported operation (Address family not supported by protocol)
12:19:29 <joe6> any thoughts, please?
12:19:54 <joe6> let me check the network source and see what address family it uses.
12:20:50 <keep_learning> hello all
12:21:02 <keep_learning> could some one please tell me
12:21:03 <keep_learning> http://hpaste.org/46436/topcoder_srm_505_div_2_500
12:21:26 <keep_learning> why this code gives  (3,3) for input fun [] [1,2,3]
12:21:44 <keep_learning> it should produce (100,100) in my opinion
12:21:51 <keep_learning> but something wrong
12:22:10 <plumenator> does yi pango work on Mac OS X?
12:22:23 <plumenator> I did cabal install -fpango and it failed to build
12:22:29 <keep_learning> you may view problem here http://www.topcoder.com/stat?c=problem_statement&pm=11397
12:22:33 <plumenator> got iconv related linier errors
12:22:36 <keep_learning> but it requires registration
12:23:36 <keep_learning> how to debug haskell program ?
12:23:50 <keep_learning> in c and c++ we write printf but
12:24:18 <ClaudiusMaximus> keep_learning: Debug.Trace.trace
12:24:36 <kmc> keep_learning, write your function by gluing together smaller functions
12:24:43 <kmc> then you can test each in isolation using ghci
12:25:16 <keep_learning> kmc, thank you
12:25:41 <kmc> a good Haskell debugger would look like this: http://ww2.cs.mu.oz.au/~bjpop/buddha/
12:25:48 <kmc> however i don't think that software is still working
12:25:52 <keep_learning> ClaudiusMaximus, thank you
12:25:58 <keep_learning> its really helpful
12:26:08 <keep_learning> now i can debug my function
12:31:00 <keep_learning> http://hpaste.org/paste/46436/topcoder_srm_505_div_2_500_an#p46437
12:31:10 <keep_learning> with trace i am getting indentation error
12:31:22 <keep_learning> i think i put trace well with white spaces
12:31:29 <keep_learning> could any one please tell me
12:31:37 <keep_learning> why this indentation error
12:32:04 <NihilistDandy> keep_learning: Line up your ->'s?
12:32:07 <ClaudiusMaximus> keep_learning: you have to have trace as part of an expression
12:32:16 <elliott> ->s don't need to be aligned :)
12:32:37 <NihilistDandy> That's good to know. I always align everything to be safe :D
12:33:04 <ClaudiusMaximus> keep_learning: something like let a = trace "sum " (sum ...)
12:33:06 <kmc> the layout rules are pretty simple and lenient
12:33:17 <kmc> it helps to understand the layout-insensitive Haskell syntax that uses ; { }
12:33:28 <NihilistDandy> Yeah, I've noticed that
12:33:38 <kmc> layout is used to insert those tokens early in parsing
12:33:48 <keep_learning> ClaudiusMaximus, ohhhhh , thank you
12:34:02 <pmetzger> as a newb who habitually declares most types, should I worry about understanding the monomorphism restriction until I slam into it?
12:34:02 <ClaudiusMaximus> keep_learning: if you want to show the value, you can define a function like  debug s x = trace (s ++ " " ++ show x) x
12:34:27 <elliott> pmetzger: nope
12:34:32 <pmetzger> cool.
12:34:32 * hackagebot Noise 1.0.5 - A Haskell coherent noise generator based on libnoise  http://hackage.haskell.org/package/Noise-1.0.5 (HugoGomes)
12:34:37 <elliott> it's a technical wart, if you declare your types you should be fine
12:34:41 <kmc> pmetzger, MMR won't affect a binding whose type you declare
12:34:49 <kmc> however, the same is true inside "let"
12:34:52 <kmc> or "where"
12:34:56 <kmc> but most people don't declare types there
12:34:59 <kmc> so watch out
12:34:59 <keep_learning> ClaudiusMaximus, now it makes more sense :)
12:35:07 <keep_learning> thank you function
12:35:37 <pmetzger> I think the only place I've ever declared a type so far other than on a binding was to tell it what type Nothing was in one context
12:36:08 <latrene> http://nopaste.me/paste/11894502524dc44d6945e07
12:36:18 <latrene> Is there a way to make my filterMany function smaller?
12:36:23 <latrene> through currying
12:36:27 <latrene> I'm a bit of a beginner
12:36:39 <ClaudiusMaximus> keep_learning: but to give a hint, try:   fun [] [error "I exploded", 4]  and see what happens
12:36:56 <ClaudiusMaximus> (i didn't see the problem specification, though)
12:37:32 <keep_learning> ClaudiusMaximus, the second list should be list of integers
12:37:36 <pmetzger> oh, and dumb dumb question. when ghci tells me a type variable is "t", what does that mean? (I should have learned that a while ago.)
12:37:42 <keep_learning> so fun [] [1,2,3]
12:37:58 <ClaudiusMaximus> error "foo" can take any type, including Integer
12:38:01 <kmc> t is a type variable
12:38:01 <keep_learning> will work
12:38:05 <kmc> so are a, b, c, etc.
12:38:13 <pmetzger> yes, but sometimes it picks "t" rather than "a", "b" etc.
12:38:17 <kmc> any identifier that starts with a lower-case letter can be a type variable
12:38:24 <elliott> pmetzger: It means nothing :)
12:38:24 <kmc> pmetzger, it's not very meaningful
12:38:26 <pmetzger> it clearly means something a bit distinct when it picks "t"
12:38:29 <elliott> Not really
12:38:31 <pmetzger> really? it is just random?
12:38:37 <ClaudiusMaximus> latrene: looks like a fold to me
12:38:37 <elliott> Well, it might have some logic
12:38:37 <kmc> sometimes it tries to use the same variable as some signature you wrote
12:38:39 <elliott> But it's not worth learning
12:38:44 <elliott> Probably what kmc said, some signature being applied
12:38:47 <elliott> And the name being kept
12:38:48 <pmetzger> okay, so this wasn't something to care about.
12:38:54 <kmc> correct :)
12:38:55 <pmetzger> that's a relief.
12:39:17 <latrene> ClaudiusMaximum, oh you might be right. Lemme see if I know how to change it then
12:39:38 <dons> where's lambdabot?
12:39:44 <dons> gwern: ?
12:40:06 <NihilistDandy> dons: LambdaTemp
12:40:11 <merijn> dons: Died earlier today :<
12:40:12 <NihilistDandy> @where LambdaTemp
12:40:12 <LambdaTemp> I know nothing about lambdatemp.
12:40:16 <NihilistDandy> @where lambdabot
12:40:16 <LambdaTemp> Maternity leave
12:40:23 <dons> huh
12:40:29 <dons> ?pl uncurry' f p =  f (fst' p) (snd' p)
12:40:30 <LambdaTemp> uncurry' = (`ap` snd') . (. fst')
12:40:37 <pmetzger> shouldn't lambdatemp be self aware?
12:40:48 <keep_learning> ClaudiusMaximus, why you input is producing result
12:40:54 <keep_learning> i think it should be error
12:40:55 <NihilistDandy> @where+ LambdaTemp Right here, silly!
12:40:55 <LambdaTemp> I will remember.
12:40:59 <NihilistDandy> @where LambdaTemp
12:41:00 <LambdaTemp> Right here, silly!
12:41:05 <keep_learning> but its  giving (4,4)
12:41:06 <NihilistDandy> pmetzger: Better?
12:41:17 <pmetzger> indeed!
12:41:19 <keep_learning> ClaudiusMaximus, i am completely out
12:41:30 <pmetzger> self awareness is important in a bot. :)
12:41:33 <ClaudiusMaximus> keep_learning: i don't know - i guess the first element is not used - maybe something should be the whole list (x:xs) rather than the tail (xs)
12:42:14 <keep_learning> ClaudiusMaximus, notElem ( div a (b-1) ) ( z ++ t  )
12:42:38 <keep_learning> here  (z ++ t ) is always whole list at any moment of time
12:42:58 <keep_learning> so notElem should give error
12:43:05 <keep_learning> rather than a value
12:44:03 <ClaudiusMaximus> keep_learning: right, but that part of the test might not be executed if the earlier argument to && gives False
12:44:17 <ClaudiusMaximus> > False && error "oops"
12:44:18 <gwern> dons: don't look at me. lambdabot isn't running on *my* server
12:44:19 <LambdaTemp>   False
12:44:23 <keep_learning> ClaudiusMaximus, ok
12:47:12 <elliott> gwern: we just like blaming things on you
12:47:50 <gwern> oh, carry on then. every community needs its scapegoat
12:48:33 <NihilistDandy> https://fbcdn-sphotos-a.akamaihd.net/hphotos-ak-snc6/227525_10150293129547995_603187994_9534927_6537020_n.jpg
12:50:27 <joe6> in network-fancy, I have : connectStream :: Address -> IO Handle ; recv :: StringLike string => Socket -> Int -> IO string
12:50:37 <joe6> is there a function that can do Handle -> Socket?
12:50:49 <joe6> so, I can connect them both?
12:51:03 <joe6> hoogle is coming up weird things, when I search on the type signature.
12:56:42 <NihilistDandy> joe6: I don't see anything in the description
12:57:55 <joe6> NihilistDandy: description of what? http://hackage.haskell.org/packages/archive/network-fancy/0.1.5/doc/html/Network-Fancy.html#t:Socket ?
12:58:32 <NihilistDandy> I was just skimming Network.Fancy
12:58:36 <Saizan> joe6: bytestring has some IO functions that work on Handle
13:02:33 <slowsort> what do i do about duplicate instance decls?
13:02:45 <slowsort> one's from transformers, the other from category-extras
13:03:14 <slowsort> i'm trying to install phooey
13:04:52 <Saizan> not much, except finding or hacking 2 versions of those libs which are compatible, i.e. where only one of the packages makes the instances
13:06:18 <Molten> Hey all :)
13:06:57 <Molten> Anyone here online at the moment? Just have a quick question on Haskell
13:07:04 <NihilistDandy> Lots of people online
13:07:12 <Molten> Okay cool :)
13:07:22 <Molten> Basically I have this code:
13:07:23 <Molten> checkHowManyTimes x [y] = length [z | z <- [y], x == z]
13:07:48 <Molten> but it keeps giving me a weird error... saying something about non-exhaustive searches
13:07:58 <Molten> Anyone can tell what's wrong with it?
13:08:00 <NihilistDandy> > let checkHowManyTimes x [y] = length [z | z <- [y], x == z]
13:08:01 <LambdaTemp>   not an expression: `let checkHowManyTimes x [y] = length [z | z <- [y], x =...
13:08:08 <doserj> you want y, not [y]
13:09:04 <Molten> Yes, I basically want to know how many times a value x is in the list [y]
13:09:16 <doserj> no, in the list y, not in the list [y]
13:09:26 <Molten> Oh of course!
13:10:07 <Molten> What about this:
13:10:21 <Molten> checkHowManyTimes x y = length [z | z <- y, x == z]
13:11:10 <doserj> that should work, just try it out.
13:11:18 <NihilistDandy> Yeah, that works
13:11:47 <doserj> or: checkHowManyTimes x = length . filter (==x)
13:11:51 <Molten> Hmm, but it gives me No instance for (Eq a) arising from a use of '=='
13:12:21 <doserj> Molten: did you assign a type signature?
13:13:07 <Molten> doserj: I did, but I forgot adding in Eq condition... I'll try again with that
13:13:32 <doserj> or just leave the type signature out and let haskell infer the type
13:14:10 <Molten> and yeah your filter thing works... I would never have come out with that response... my brain can't comprehend partial functions fully just yet :P
13:14:52 <Molten> Yes it works :D
13:15:02 <Molten> Thanks a lot guys :)
13:18:05 <elliott> Molten: partial function doesn't mean what you think :)
13:19:02 <Molten> elliott: What exactly is going on that doserj's solution in that case? :S
13:19:12 <elliott> partial application
13:19:24 <elliott> a partial function is one that doesn't have a defined result for every input
13:19:30 <elliott> (e.g. division because division by zero is undefined)
13:20:17 <Molten> Oh... I thought partial application meant partial function... just learnt that today on learnyouahaskell.com :)
13:20:26 <Molten> I'll look over it again
13:26:30 <taktoa> anyone know of a function that can replace an element of a list with a given value and output the modified list?
13:26:55 <taktoa> ie: f [1, 2, 3, 4] 2 3 = [1, 3, 3, 4]
13:27:20 <taktoa> first variable is the list, second is the index, and third is the value to replace it with
13:27:39 <byorgey> taktoa: no, you have to write it yourself
13:27:47 <byorgey> you may find splitAt useful for this purpose
13:28:03 <taktoa> @:t splitAt
13:28:08 <LambdaTemp> Done.
13:28:29 <byorgey> :t splitAt
13:28:31 <LambdaTemp> forall a. Int -> [a] -> ([a], [a])
13:28:34 <taktoa> ah
13:28:37 <dschoepe> or just use map and check for equality with your target if you want all occurences replaced
13:29:05 <dschoepe> map (\x -> if x == foo then bar else x) xs -- should suffice
13:29:20 <taktoa> nah, I only want a given index replaced
13:29:21 <dschoepe> oh, I misunderstood the question
13:31:24 <gio123> can one help me with confluence proof?
13:32:17 <Twey> Needs more (??)
13:33:22 <ddarius> gio123: No.
13:33:49 <latrene> http://nopaste.me/paste/11894502524dc44d6945e07
13:33:59 <latrene> Does anyone know of a way to reduce this using folds?
13:34:12 <gio123> ok
13:34:42 <Twey> \new ix -> flip zipWith [1 ..] . flip $ flip fmap (== x) . (new ??)
13:36:04 <dschoepe> latrene: `foldr filter xs fs' should work
13:36:06 <Twey> latrene: filterMany = foldr filter
13:36:08 <Twey> No?
13:36:41 <Twey> Oh, right
13:36:53 <Twey> flip $ foldr filter
13:37:02 <gio123> ddarius: yes
13:37:11 <Twey> > (flip $ foldr filter) [odd, (> 5)] [1 .. 10]
13:37:15 <LambdaTemp>   mueval-core: Time limit exceeded
13:37:22 <Twey> *headscratch*
13:37:25 <latrene> dschoepe is right
13:37:25 <dschoepe> > 1
13:37:27 <LambdaTemp>   1
13:37:36 <Twey> It works
13:37:41 <Twey> Just not in LambdaTemp :þ
13:37:52 <Twey> filterMany = flip $ foldr filter
13:38:05 <latrene> > foldr filter [1..100] [(>5), (<13)]
13:38:06 <LambdaTemp>   [6,7,8,9,10,11,12]
13:38:16 <Twey> Oh, it *likes* you
13:38:20 <latrene> Lol
13:38:20 <Twey> Hrmph.
13:38:38 <dschoepe> > flip (foldr filter) [(>5), (<13)] [1..100]
13:38:40 <LambdaTemp>   [6,7,8,9,10,11,12]
13:38:57 <latrene> It likes you too
13:39:02 <dschoepe> Twey: correction, it *doesn't* like you, apparently :)
13:39:03 <dskippy> Woa, you guys went to the temp agency and got a Lambda Bot?
13:39:16 <kmc> lambda robots: 100% loyal
13:39:20 <Twey> > let filterMany = flip $ foldr filter in filterMany [odd, (> 5)] [1 .. 10]
13:39:22 <LambdaTemp>   [7,9]
13:39:24 <Twey> \o/
13:39:24 <ClaudiusMaximus> :t foldr((.).filter)id
13:39:26 <LambdaTemp> forall a. [a -> Bool] -> [a] -> [a]
13:39:27 <Twey> Six seconds
13:39:28 <merijn> Until they crash and abandon you :(
13:39:29 <wavewave> hello, may i ask a question on iteratee and continuation monad?
13:40:00 <wavewave> I have a code on http://hpaste.org/46438/iteratee_zip_and_continuatio
13:40:05 <latrene> filterMany = flip $ foldr filter
13:40:09 <latrene> Talk about currying.
13:41:40 <wavewave> what I want is to zip two iteratee (one is count_marker and the other is stop)
13:41:46 <Saizan> > let filterMany = filter . (and .) . sequence in filterMany [odd, (> 5)] [1 .. 10]
13:41:48 <LambdaTemp>   [7,9]
13:42:05 <wavewave> if some condition is satisified in stop, then just stop all iteration.
13:42:38 <wavewave> to do so, I use continuation monad, but I couldn't succeed in making this work yet.
13:42:48 <wavewave> I use John Lato's iteratee package.
13:43:32 <wavewave> basically,  count_marker is just showing progress.
13:44:29 <wavewave> stop is a prototype worker function and if something is done, then stop just want to finish all the operation, so count_marker should be stop.
13:45:21 <wavewave> in this example, I just stop when 1000th element is consumed, but it continues to proceed even with continuation.
13:45:45 <wavewave> I cannot figure out how to implement this correctly using continuation monad.
13:46:33 <wavewave> could anyone help me? ;-)
13:56:36 <guerrill1> quit q: what's the easiest way to tell if a file exists or not?
13:56:50 <rothwell> try to open it
13:56:50 <wavewave> doesFileExist ?
13:57:04 <wavewave> in System.Directory
13:57:04 <merijn> wavewave: Nope
13:57:07 <Phantom_Hoover> Hey, everybody, join #esoteric right now!
13:57:18 <merijn> Checking for file existence with a systems call is useless
13:57:29 <aristid> merijn: it does have some statistical value
13:57:35 <guerrill1> wavewave: thanks...
13:57:59 <merijn> guerrill1: There's a race condition, because the file could be deleted between checking and opening. The best way is to just try to open it and handle any errors
13:58:01 <wavewave> merijn: what does it mean exactly?
13:58:37 <merijn> wavewave: See my answer to guerrill1, there's a race condition
13:58:51 <wavewave> merijn: Ok. thanks.
13:59:02 <guerrill1> merijn: no problem. i'm aware of this (C programmer here)
13:59:24 <guerrill1> thanks though merijn. i guess most people wouldn't know that ;)
14:08:59 <gio123> can one help me with confluence proof?
14:11:07 <nyingen> simple question about enumerator/iteratee
14:11:13 <nyingen> http://hpaste.org/46439/iter_test
14:11:44 <nyingen> when I run this, I get the entire input file on one line, prefixed by 'XXX '
14:11:51 * hackagebot cryptocipher 0.2.11 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.11 (VincentHanquez)
14:12:04 <nyingen> I thought composing with Enumerator.lines was supposed to break it up into lines
14:12:24 <nyingen> also, I have no idea what the value inside "Chunks" is supposed to be
14:13:48 <nyingen> anyone know what I'm doing wrong?
14:14:16 <pmetzger> bad hackagebot. block and stream ciphers are always symmetric, pubkey ciphers are never symmetric.
14:14:45 <pmetzger> ambiguous modifiers are strongly condemned. :)
14:17:11 <NihilistDandy> pmetzger: Truth
14:31:16 <nyingen> (enumFile "foo" $$ ET.lines =$ consumer) should result in consumer getting a line of the file at a time, right?
14:31:24 <nyingen> ET = Enumerator.Text
14:31:29 <nyingen> er, Data.Enumerator.Text
14:38:17 <KirinDave> Does anyone have an example of using a WriterT on top of State?
14:38:21 <KirinDave> I had trouble invoking it last night
14:39:51 <wavewave> nyingen : so you want to have separate lines?
14:40:02 <dons> KirinDave: hmm
14:40:29 <nyingen> wavewave: yes, I want the iteratee to get a line at a time
14:41:05 <nyingen> the reason is, that this iteratee will gather a sequence of lines and build a record out of them, yielding the record once it sees the "end-of-record" token
14:41:05 <wavewave> I am a user of iteratee package, not enumerator, but I am trying to look at it.
14:41:48 <nyingen> I've never used iteratees before, but I'm trying to puzzle through these tutorials
14:43:32 <nyingen> however, the behavior of the expression I posted earlier is confusing
14:43:46 <nyingen> since ET.lines isn't breaking anything into lines, then what is it doing?
14:44:10 <keep_learning> http://hpaste.org/paste/46436/topcoder_srm_505_div_2_500_an#p46440
14:44:17 <keep_learning> when i am running main
14:44:25 <keep_learning> and entering the value 1 2 3
14:44:37 <keep_learning> so it should print "No"
14:44:49 <keep_learning> but output is showing nothing
14:45:05 <keep_learning> so i have to kill the program using ctr - c
14:45:16 <keep_learning> kindly some one please tell me
14:45:25 <keep_learning> what is wrong main function
14:45:58 <KirinDave> dons: ??
14:46:00 <dons> KirinDave: let x = runState (runWriterT code) 0
14:47:31 <KirinDave> And the result of that will be
14:47:47 <KirinDave> ((result, writerStuff), state) ?
14:47:59 <dabblego> KirinDave: runState and runWriterT just unwrap the constructor
14:48:02 <KirinDave> Or ((result, state), writerStuff)
14:48:19 <dons> KirinDave: yep
14:48:25 <KirinDave> Which one? :D
14:48:26 <dons> state on the outside.
14:48:32 <KirinDave> Ahh, cool. Ty.
14:48:40 <dons> you can play with it in ghci, adding and removing types, asking what is being inferred
14:48:55 <keep_learning> i got it
14:49:03 <dons> also deriving MonadState and friends is useful, so you can avoid lifts
14:49:28 <KirinDave> How would one do that?
14:49:36 <KirinDave> Just derive it for the state object?
14:50:18 <dabblego> you implement the lift function for the MonadState class
14:50:29 <nyingen> wavewave: hmm, I just removed ET.lines from that expression, and now it has the expected behavior
14:50:45 <nyingen> still confusing, but maybe I'll eventually understand
14:50:56 <dons> newtype X a = X (ReaderT XConf (StateT XState IO) a)
14:50:57 <dons> #ifndef __HADDOCK__ deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf, Typeable)
14:51:03 <dons> ignore the ndef
14:51:14 <dylukes> Hurray for continuation passing style!
14:51:17 <dons> using GeneralizedNewtypeDeriving
14:52:50 <ivanm> which version of GHC did DeriveDataDynamic get added in?
14:53:03 <dons> seems like ages
14:53:05 <dons> prob 6.10
14:53:22 <jnhnum1> hey guys - I have this function which I think should be tail recursive, but for some reason I'm getting a stack overflow
14:53:26 <jnhnum1> sumRange :: Int64 -> Int64 -> Int64   9 sumRange n m = go n m 0  10   where go :: Int64 -> Int64 -> Int64 -> Int64  11         go n m s  | n > m = s  12                   | otherwise = go (n+1) m (s+n)
14:53:27 <dons> ivanm: you mean typeable?
14:53:32 <dons>  -XDeriveDataTypeable
14:53:36 <jnhnum1> oh no, I guess I should use pastebin
14:53:36 <ivanm> oh, right
14:53:36 <jnhnum1> >.<
14:53:59 <dons> at least 6.8
14:54:03 <ivanm> good-o
14:54:12 <dons> GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
14:54:12 <dons> Loading package base ... linking ... done.
14:54:12 <dons> Prelude> :set -XDeriveDataTypeable
14:54:40 <jnhnum1> so http://pastebin.com/UfpJpkRB is a simple function to compute the sum of a range (yes I know there's a closed form formula, but this is for learning)
14:54:55 <dons> $ ghci-6.4.1.20050813
14:54:55 <dons>    ___         ___ _
14:54:55 <dons>   / _ \ /\  /\/ __(_)
14:54:55 <dons>  / /_\// /_/ / /  | |      GHC Interactive, version 6.4.1.20050813, for Haskell 98.
14:54:56 <jnhnum1> when I call sumRange 1 1000000 I get a stack overflow
14:54:58 <dons> /_\\/ __  / /___| |      http://www.haskell.org/ghc/
14:55:01 <dons> \____/\/ /_/\____/|_|      Type :? for help.
14:55:03 <dons> Loading package base-1.0 ... linking ... done.
14:55:05 <jnhnum1> can anyone tell me what I'm doing wrong?
14:55:06 <dons> Prelude> :set -XDeriveDataTypeable
14:55:08 <dons> unrecognised flags: -XDeriveDataTypeable
14:55:11 <dons> ivanm: but not ghc 6.4
14:55:22 <ivanm> yeah, 6.8 is good enough for me
14:55:24 <KSkrzet> jnhnum1: try using bang patterns
14:55:33 <KSkrzet> like go !n !m !s
14:55:35 <ivanm> so I can leave my base-3 compatability stuff in
14:55:50 <Saizan> you need the bang only on s
14:55:56 <Saizan> since that's the only lazy accumulator
14:55:59 <dons> jnhnum1: your inner loop is lazy in `s`
14:56:09 <Saizan> n and m will get forced by the comparison
14:56:15 <jnhnum1> is it lazy on n also? since that's also being incremented?
14:56:17 <jnhnum1> oh
14:56:18 <dons> jnhnum1: try compiling with ghc -O2 , and -XBangPatterns, with go n m !s
14:56:26 <jnhnum1> okay thanks
14:56:26 <dons> n gets compared against m every time around
14:56:37 <dons> so it is demanded
14:56:40 <dons> ghc will see that
14:56:48 <ddarius> 6.4 was quite a while ago.
14:56:56 <wavewave> nyingen : first of all, it seems like enumFile fetches content of files line by line.
14:57:17 <Saizan> 6.4.2 was around the time i started using haskell
14:57:27 <ddarius> 5.4.3 for me.
14:57:35 <dons> jnhnum1: examples http://stackoverflow.com/questions/2978979/haskell-math-performance/2979049#2979049
14:57:56 <wavewave> nyingen :  enumFile uses enumHandle and enumHandle uses TIO.hGetLine
14:58:01 <ddarius> But GHC 5 didn't last nearly as long as GHC 6.
14:58:28 <dons> $ ./hbi
14:58:28 <dons> Welcome to interactive Haskell98 version 0.9999.5c Pentium 2004 Jun 29!
14:58:28 <dons> Loading prelude... 1 values, 4 libraries, 200 types found.
14:58:28 <dons> Type "help;" to get help.
14:58:33 <dons> ivanm: not in hbi
14:58:41 <nyingen> wavewave: I see...
14:59:10 <dons> ivanm: also not in hi 3.13
14:59:17 <nyingen> wavewave: so when I was erroneously inserting 'lines', the newlines were already removed by the time the data got to it?
14:59:23 <ivanm> dons: heh "in 6.8" is good enough for me; I just wanted to know whether or not my base-3 compatability stuff was still relevant if I was using DeriveDataTypeable
14:59:27 * dons is happy his hbi and nhc are still running
14:59:27 <ivanm> thanks
14:59:27 <wavewave> but I think lines assume that there must be '\n' when new line exists.
14:59:32 <wavewave> exactly.
14:59:37 <kosmikus> dons: :)
14:59:44 <dons> have to dust them off once every 5 years
15:00:01 <ivanm> for nostalgia?
15:00:02 <ddarius> Some code lives forever.
15:00:12 * kosmikus is just trying to remember what the first ghc version he ever used was
15:00:17 <nyingen> wavewave: yeah, this makes more sense now
15:00:17 * ddarius has never used HBC or NHC.
15:00:18 <wavewave> nyingen: usually this is right assumption because enumerator does not have to chunk a stream with lines.
15:00:21 <ddarius> I think I build NHC once.
15:00:31 <ivanm> forget stamps or coins; dons collects Haskell implementations :p
15:00:35 <wavewave> for example, it can chunk every 4096 bytes
15:00:37 <dons> i did for a while
15:00:38 <nyingen> right
15:00:43 <KSkrzet> I have written a proof of concept (MultiSet Int)-equivalent datastructure which does online compression of values. I welcome any comments: http://hpaste.org/46411/online_compression_int_multise
15:01:55 <dons> why hbi matters:
15:01:56 <dons> > data T a = E | N a (T a) (T a) deriving Show ;
15:02:00 <LambdaTemp>   mueval-core: Time limit exceeded
15:02:03 <dons> haha
15:02:34 <ddarius> Clearly we need HaskellBBot.
15:02:39 <wavewave> nyingen : I think this is somewhat confusing. enumFile shoule be named differently if it insists that newline elimination behaviour.
15:03:00 <dons> HBI  -- Interactive Haskell B 1.3
15:03:15 <dons> i think I should get some tshirts made :)
15:03:40 <ddarius> You can have "The B stands for B" as the subcaption.
15:04:15 <dons> heh
15:04:31 <nyingen> wavewave: indeed, that sidetracked me quite a bit. I think that might be specific to the Text version of enumFile though, since examples using ByteString seem to work differently (byte at a time)
15:04:32 <wavewave> normally iteratee does not see inside of chunk. if chunk is exhausted, then iteratee takes its control over enumerator to get new chunk of data.
15:04:38 <dons> [65] Cannot unify types:
15:04:38 <dons>     (T a) -> T a
15:04:38 <dons> and T b
15:04:39 <dons>  in  \AA4860 -> N (Prelude.fromInteger 2I) E AA4860
15:04:43 <dons> retro type errors
15:05:06 * dons tucks hbi back into bed until 2016
15:05:28 * ddarius doesn't know why people complain about GHC's error messages.  Other than perhaps Helium, it has the best.
15:05:31 <wavewave> so assuming a certain structure of Chunk is not following purpose of separating enumerator and iteratee design.
15:06:41 <wavewave> anyway, I think this seems resolved.  :-)    I will also have to be careful when using enumerator text.
15:06:41 <elliott> <dons> > data T a = E | N a (T a) (T a) deriving Show ;
15:06:41 <elliott> <LambdaTemp>   mueval-core: Time limit exceeded
15:06:45 <elliott> huh, > accepts statements?
15:06:57 <dons> > 1+2
15:07:00 <LambdaTemp>   3
15:07:07 <aristid> amazing
15:07:10 <elliott> or wait, is > hbi now or something?
15:07:13 <dons> the channel is a Bird-style literate haskell program
15:07:19 <dons> oh, i was running hbi
15:07:30 <elliott> > data T a = E | N a (T a) (T a) deriving Show ;
15:07:32 <LambdaTemp>   <hint>:1:1: parse error on input `data'
15:07:34 <ddarius> dons: In 2014, hbc 0.9999.6 will be released non-chalantly.
15:07:34 <elliott> I'm just surprised lambdabot doesn't ...
15:07:36 <elliott> wtf.
15:07:40 <elliott> i guess something else timed out
15:07:49 <Saizan> hint?
15:07:49 <dons> heh
15:08:07 <shachaf> \begin{code} 1 + 1 \end{code}
15:08:11 <Saizan> ah, haskell interpreter
15:08:16 <nyingen> wavewave: so is the code in my paste improperly written then?
15:08:19 <ddarius> @hackage hint
15:08:21 <LambdaTemp> http://hackage.haskell.org/package/hint
15:08:27 <elliott> this channel is a very invalid literate haskell program :-)
15:08:35 <nyingen> wavewave: since I deconstruct Chunk
15:09:22 <Saizan> ddarius: that hint would be weird
15:09:33 <wavewave> nyingen: if you can avoid to look at inside of Chunk, it's better definitely.
15:09:40 <Tharn> Hrm. Turning on -O2 optimizing cuts my errors in half. Tempting.
15:10:22 <wavewave> nyingen: but in this case, because of enumFile, I think it's rather unavoidable.
15:11:26 * dons rescues the lml compiler from his uni account
15:13:53 <nyingen> wavewave: I see. for some reason I thought I was supposed to extract values from the Chunks inside the iteratee
15:14:45 <wavewave> nyingen: I would prefer change the definition of lines  in fact.
15:15:38 <wavewave> like input stream = Text, output stream = [Text]
15:18:44 <wavewave> nyingen : in Data.Enumerator.List, splitWhen is defined like that.
15:19:43 <wavewave> so if you have enough primitives ( like list functions in Prelude.) you don't have to look inside Chunk.
15:21:43 <Tyr42> Is there a good intro to lazy bytestrings somewhere
15:22:13 <Tyr42> I am going to be writing the Google Code Jam, and I've heard they are efficient, but have never used them
15:22:15 <Tharn> Wow. AVG is screwing up my batch file. That's.. new..
15:22:38 <Peaker> Tyr42, They're lazy lists of strict bytestrings, pretty much
15:22:41 <dons> Tyr42: hmm. the haddocks are pretty extensive
15:22:57 <dons> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.10/doc/html/Data-ByteString-Lazy.html
15:24:07 <ivanm> Tyr42: depends on how you mean "inefficient"
15:24:32 <ivanm> they'd be less efficient than Strict ByteStrings... but still more efficient than String
15:24:33 <Tyr42> Ok, I was reading that
15:25:25 <dons> there's no ordering on efficiency between strict and lazy bytestrings
15:25:31 <dons> they have different complexity for different operations
15:25:43 <dons> lazy bytestrings always have at least as good complexity as strict ones, sometimes better
15:25:50 <dons> with some constant factor additional overhead
15:26:53 <ivanm> dons: oh, my mistake
15:27:18 <ivanm> well, I was trying to work out where Tyr42 heard they weren't efficient from ;-)
15:27:34 <dons> "I've heard they are efficient"
15:27:47 <ivanm> gah, need to learn to read properly.....
15:31:45 <pmetzger> at some point I have to learn how laziness is implemented in ghc and such. I'm rather curious.
15:32:03 <Tyr42> ivanm:  I said, I heard that they *are* efficient
15:32:16 <ivanm> Tyr42: yeah, I misread
15:32:46 <ivanm> pmetzger: I think it's something analogous to replacing "a" with "\ () -> a"
15:32:49 <ivanm> see SICP
15:33:14 <Tyr42> Oh, Realworld haskell has a chapter on them
15:33:17 <pmetzger> no, I mean, for example, if you have a partially evaluated list, I imagine that the type tag for the tail of the list says "thunk" instead of "int" or something.
15:33:18 <Tyr42> I'm going to go read that
15:33:25 <pmetzger> I mean at the bit level.
15:33:36 <Peaker> a memoized \() -> a
15:33:53 <pmetzger> well, "thunk" instead of "list of int" :)
15:34:37 <dons> pmetzger: yeah, basically, where you look for the value of the end of the list, there's a code pointer
15:34:39 <Peaker> pmetzger, I think the tail of the list (if "boxed") is *always* represented at the very low-level by a function that returns it. That function may be a thunk that computes stuff, or it may be a simple const function that returns the already-computed result
15:34:43 <dons> that if you hit it, evaluates to the value you want
15:34:50 <dons> and the runtime then replaces the pointer with the value
15:34:57 <dons> so its there for others to share
15:35:11 <Peaker> dons, it's still a code pointer, isn't it? Just a simple const function code ptr, though
15:35:37 <dons> the thunk is overwritten with a pointer to the closure for the value, iirc
15:36:02 <pmetzger> I've implemented lisps, so I can imagine how some of this happens, but I doubt my imagination is terribly complete. :)
15:36:19 <dons> http://stackoverflow.com/questions/3131554/what-is-the-relationship-between-unboxed-types-and-strictness
15:36:41 <dons>  http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
15:36:45 <ivanm> why is it when I :load a module into ghci, I can't use :m on another module from the same project unless the first one (transitively) imports it?
15:37:37 <merijn> Peaker: Got your code running, I'm slightly at a loss with regards to were to start though. First time I attempt hacking other people's haskell and non-trivial code and main is quite intimidating :p
15:37:38 <c_wraith> ivanm: because :m is just about visibility.  :l is about actually loading code.
15:37:50 <ivanm> c_wraith: oh.....
15:37:54 <merijn> Any relatively simple/obvious places for me start?
15:38:03 <Peaker> merijn, I think it's best to study vtywidgets first
15:38:03 * ivanm grumbles
15:38:16 <Peaker> merijn, understanding the Widget and Display types
15:38:32 <pmetzger> dons: thanks much! interesting reading!
15:38:55 <jnhnum1> can somebody explain this piece of code: [d] <- map read `fmap` getArgs; I don't really know what the map is doing in there
15:38:56 <Peaker> merijn, main is a bit of a hack, very prototypical :)
15:39:09 <merijn> Peaker: Right, I'll start looking there then :)
15:39:12 <mauke> jnhnum1: the same thing it always does
15:39:12 <ivanm> jnhnum1: getArgs is IO [String]
15:39:21 <ivanm> fmap brings the "map read" into IO
15:39:38 <ivanm> so you get (Read a) => IO [a]
15:39:39 <jnhnum1> oh! I was confused about the order of operations
15:39:47 <jnhnum1> I thought it was map (read `fmap` getArgs)
15:40:01 <jnhnum1> okay that makes a lot more sense now
15:40:03 <jnhnum1> thanks
15:40:04 <ivanm> function application before infix function application
15:40:07 <merijn> jnhnum1: Nope, function application always has precedence over infix
15:40:36 <shachaf> @ty (read .) . getArgs
15:40:39 <LambdaTemp> forall b. Read b => IO [b]
15:40:44 <merijn> Peaker: Well, got start somewhere when attempting to conquer the world ;)
15:40:46 <Peaker> merijn, Let's walk through the Widget code?
15:40:54 <Peaker> merijn, Start with Display, it's simpler
15:41:14 <shachaf> @let (.:) = (.)(.)(.)
15:41:17 <LambdaTemp>  Defined.
15:41:20 <shachaf> @ty read .: getArgs
15:41:23 <LambdaTemp> forall b. Read b => IO [b]
15:42:25 <Peaker> merijn, https://github.com/Peaker/vtywidgets/blob/master/src/Graphics/UI/VtyWidgets/Display.hs  <-- Display is basically a "resizable" image -- that has a requested size range (min..max) in each axis, and can generate an image for that size
15:43:08 <Peaker> type Display imgarg = Placable (imgarg -> TermImage)   <--- this is a bit ugly. Nowdays I'd use a polymorphic type constructor in there instead of the (imgarg->)
15:43:42 <Peaker> merijn, TermImage is basically a terminal/console image type (I wrapped Vty's image type with TermImage so I can do stuff like overlay images on one another)
15:43:57 <pmetzger> dons: I don't see any data here specifically for the gc to work off of, is that somehow kept out of band?
15:44:15 <dons> yeah, there's an info tabe
15:44:16 <Peaker> merijn, are you up for the code walk? If so, /join #vtywidgets
15:44:17 <dons> table
15:44:24 <dons> which the ghc consults to chase pointers
15:44:27 <dons> the gc
15:44:29 <dons> urgh
15:44:57 <pmetzger> how are roots in the stack identified?
15:44:59 <Peaker> Did anyone read the Linus rant about GC's?  I agree with a lot of it :-)
15:45:00 <pmetzger> or are there any?
15:45:58 <pmetzger> hrm. this is actually more detailed about some of that than I thought. so there are maps to indicate what is dynamic and what isn't. hrm.
15:46:18 <dons> yeah, there's custom stack-walking code
15:46:30 <jnhnum1> question: what's the fastest way (besides using the formula n(n+1)/2 to compute the sum from [1..n]?  more specifically, is it possible to make it as fast as java?  I know performance is really not the point of haskell but it seems like it should be able to compile into the same code
15:46:44 <dons> start here, pmetzger :  http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts
15:46:46 <jnhnum1> I was only able to get it to be about 30% slower than java
15:47:06 <dons> jnhnum1: should be able to beat java... what's your java impl?
15:47:10 <aristid> jnhnum1: which data structure do you use in java?
15:47:16 <Xaratas> hi, i have build a type error and dont know why http://hpaste.org/46441/filtertk can someone explain?
15:47:30 <mauke> jnhnum1: foldl' (+) 0 [1 .. n] :: Int?
15:47:30 <dons> jnhnum1: i presume you want a recursive solution?
15:47:48 <pmetzger> dons: yowza. this is a really rich runtime implementation.
15:47:50 <jnhnum1> in haskell I have this: http://pastebin.com/Pzmcasj7
15:47:59 <dons> pmetzger: 25 years of work
15:48:03 <pmetzger> dons: lots of work to make things magically function. :)
15:48:14 <mauke> needs more foldl'
15:48:39 <jnhnum1> and in java: http://pastebin.com/eMvZ4AeG
15:49:01 <jnhnum1> the problem with [1..n] is that it allocates (albeit lazily) lots of unnecessary list object things
15:49:19 <jnhnum1> and that was about 2x slower than the recursive version
15:49:21 <kmc> is there a summary of the  various Haskell XML libraries anywhere?
15:49:23 <pmetzger> dons: 50k lines of code in a runtime. is all of that hand maintained or is some of it machine generated from higher level forms?
15:49:38 <kmc> say i want to traverse an XML document and extract certain values
15:49:42 <kmc> and maybe also add some nodes
15:50:14 <jnhnum1> oh sorry those pastebins don't do exactly the same thing ... but the java one still does more work
15:50:17 <dons> pmetzger: some is machine generated from Cmm
15:50:45 <aristid> jnhnum1: i have a very fast solution for you: sumUpTo n = n * (n + 1) `div` 2
15:50:48 <pmetzger> the compiler works by generating cmm or c code?
15:50:56 <mauke> aristid: fail
15:51:02 <pmetzger> not something like llvm?
15:51:02 <aristid> mauke: what?
15:51:04 <kmc> there's also the STG fast entry points or whatever, which are generated by a program GHC builds when it's being compiled
15:51:12 <mauke> aristid: <jnhnum1> question: what's the fastest way (besides using the formula n(n+1)/2 to compute the sum from [1..n]?
15:51:15 <kmc> pmetzger, GHC has backends for C, LLVM, and direct native code (for some platforms)
15:51:23 <aristid> mauke: grmbl
15:51:39 <kmc> by default the C backend is not really a C backend
15:51:46 <dons> jnhnum1: you can write very nice ones based on vector fusion
15:51:47 <ddarius> aristid: quot would be faster.
15:51:49 <kmc> because it uses GCC extensions, as well as a postprocessing stage that mangles the assembly output from GCC
15:52:00 <kmc> but you can also build an "unregisterized" GHC which does not do these things
15:52:09 <kmc> of course, other Haskell compilers take different implementation strategies
15:52:15 <kmc> JHC produces more or less portable C
15:52:20 <kmc> YHC produces platform-independent bytecode
15:52:21 <pmetzger> I guess llvm hasn't been on the scene that long. having to build this on top of C must have been unfun.
15:52:31 <jnhnum1> what's vector fusion?
15:52:38 <kmc> C-- is a portable assembler sort of like LLVM
15:52:53 <jnhnum1> a quick google search looks pretty intimidating
15:53:27 <pmetzger> I think I read a Cmm paper when I was looking for an implementation basis for some compiler work years ago. It was pretty new at the time IIRC, not really stable.
15:53:32 <pmetzger> but that was a long time ago.
15:53:57 <ddarius> Cmm and C-- are somewhat different.
15:54:06 <pmetzger> oh?
15:54:31 <kmc> but has failed to catch on outside GHC
15:54:32 <kmc> pmetzger, it's not too bad until you care about speed :D
15:54:32 <kmc> properly optimized GHC output is *weird* compared to anything a vanilla C compiler would generate
15:54:32 <dons> jnhnum1: http://hpaste.org/46443/vector_fusion
15:54:33 <kmc> for starters, code is interleaved with read-only data structures
15:54:34 <kmc> jnhnum1, probably something like www.cse.unsw.edu.au/~dons/papers/CLS07.html
15:54:43 <pmetzger> IIRC I was frustrated by how ugly it was implementing tail calls and gc in a language that had to compile to C and I wanted something that gave me more control...
15:54:50 <pmetzger> but that was a long long time ago.
15:54:54 <kmc> yeah, it is ugly
15:55:03 <kmc> that's why GHC does terrible things to GCC's assembly output
15:55:07 <ddarius> kmc: GHC doesn't and I believe has never used C--.
15:55:10 <kmc> but, that whole path is deprecated now, with the new LLVM backend
15:55:22 <kmc> ddarius, *nod*
15:55:51 <pmetzger> I vaguely remember a friend (the one who first said the word "Haskell to me") mentioning something about perl scripts or whatever used to postprocess assembly code...
15:55:56 <kmc> yep
15:55:59 <kmc> the Evil Mangler
15:56:00 <pmetzger> er, replace that with "Haskell" to me
15:56:16 <kmc> it does a few things
15:56:18 <dons> jnhnum1: ghc -O2 -fllvm turns it into a constant ...
15:56:30 <kmc> rips out function call prologues / epilogues
15:56:36 <dons> 0.004s
15:56:38 <kmc> because Haskell evaluation in GHC doesn't use the C stack at all
15:56:46 <dons> vs 0.93s for the -fasm version
15:56:47 <kmc> and it arranges the aforementioned tables-next-to-code optimization
15:56:53 <pmetzger> kmc: everything allocated on the heap?
15:57:04 <dons> jnhnum1: so compile my example with ghc -O2 -fllvm
15:57:06 <dons> for great win
15:57:06 <kmc> pmetzger, GHC has something it calls the stack but it's different from the C stack
15:57:17 <kmc> it also has something it calls the heap, which looks more like a stack to a C programmer
15:57:47 <kmc> "the heap" and "the stack" are language-dependent ideas
15:58:03 <kmc> (except that Linux does have an opinion about where your "stack" is, so it can grow dynamically, but afaik GHC doesn't care)
15:58:03 <pmetzger> I wrote a scheme implementation once that used the CPU stack for nothing at all, all function activations were allocated in a stop and copy arena. allocating was just incrementing a pointer.
15:58:25 <kmc> in GHC allocating is just incrementing a pointer
15:58:28 <pmetzger> but that's not very unusual in that world.
15:58:33 <kmc> *nod*
15:58:43 <pmetzger> kmc: is the gc generational or just one arena stop and copy?
15:58:43 <kmc> that's why i say the GHC heap is more like a stack to a C programmer
15:58:48 <kmc> generational
15:58:53 <dons> jnhnum1: i don't understand the llvm assembly, but it sure compiled away the loop
15:59:01 <kmc> and concurrent
15:59:04 <kmc> multiple threads can GC at once
15:59:05 <jnhnum1> how did the loop go away .. ?
15:59:07 <jnhnum1> oh is it a JIT?
15:59:13 <kmc> but no thread can GC while another thread is doing evaluation
15:59:23 <jnhnum1> (because the n comes from a command line argument?)
15:59:30 <pmetzger> kmc: I never have spent enough time to really grok modern concurrent gc algorithms. :(
15:59:35 <ddarius> "concurrent" usually means "incremental"/"real-time" in a GC context.
15:59:44 <kmc> then i'm probably using the wrong word.  parallel?
15:59:44 <pmetzger> baker collectors were sort of where my knowledge ends.
15:59:45 <dons> hah. -fllvm rocks
15:59:58 <pmetzger> kmc: you may or may not be, I wouldn't know.
15:59:59 <dons> jnhnum1: llvm worked out what the loop was doing
16:00:15 <jnhnum1> oh wow
16:00:17 <jnhnum1> that is pretty cool
16:00:39 <ddarius> kmc: I don't think there is a special word for doing thread-local minor GCs.
16:00:53 <ddarius> GHC's GC is parallel in a different sense though.
16:00:57 <kmc> but GHC doesn't have thread-local heaps, does it?
16:01:37 <kmc> IIRC it has parallel traversal of the single global heap, which is why they have to stop the world
16:01:43 <pmetzger> the most disgusting idea in C implementation for HLLs + gc is "Cheney on the MTA". to my knowledge, only the Chicken scheme compiler does it.
16:01:55 <dons> jnhnum1: so try my code, here,  http://hpaste.org/46442/vector_fusion   with ghc -O2 -fllvm
16:01:56 <ddarius> Perhaps you didn't mean to speak of threads.  GHC's GC is parallelized over multiple cores if they are available.
16:01:56 <pmetzger> C stack is used purely as a first generation heap.
16:02:16 <pmetzger> I think that was a Baker idea too...
16:02:25 <kmc> ddarius, yeah, i meant the GHC RTS's OS threads, not Haskell-level threads
16:02:57 <jnhnum1> I get
16:02:57 <jnhnum1> holmgren@holmgren-ThinkPad-W500:~$ ghc -O2 -fllvm  avg.hs  [1 of 1] Compiling Main             ( avg.hs, avg.o ) ghc: could not execute: opt
16:02:58 <kmc> the function call that never returned?
16:03:25 <dons> jnhnum1: you need LLVM installed, for the LLVM backend
16:03:32 <dons> i'm surprised `opt` isn't in your path.
16:03:37 <jnhnum1> oh >.>
16:03:39 <jnhnum1> normally opt runs
16:03:43 <pmetzger> can current haskell compilers take advantage of multiple cores for parallel evaluation? (I don't mean "multiple threads", I mean, say, evaluating several parts of a data structure at once, like doing a fast matrix multiply with multiple cores or what have you.)
16:03:51 <kmc> yes, GHC can do that
16:03:54 <dons> pmetzger: yes.
16:03:57 <jnhnum1> it's just when I try this vectorized version that I get that line
16:04:00 <kmc> not transparently
16:04:07 <kmc> but you can provide lightweight annotations about parallel evaluation
16:04:13 <kmc> you don't have to muck with explicit threads or synchronization
16:04:15 <dons> kmc: well, it can be transparent for some classes of problems
16:04:19 <dons> e.g. repa-based algorithms
16:04:27 <kmc> *nod*
16:04:28 <pmetzger> cool. I always thought functional would have an advantage on such stuff.
16:04:29 <dons> pmetzger: http://stackoverflow.com/questions/3063652/whats-the-status-of-multicore-programming-in-haskell
16:04:31 <ddarius> Also the threads are mapped to multiple OS threads.
16:04:41 <kmc> dons, is there an updated version of your talk "DEFUN 2009: Multicore Programming in Haskell Now!"
16:04:48 <kmc> maybe that's what you just linked
16:05:24 <pmetzger> after all, in a purely functional language, you don't have to worry about side effects from ordering.
16:05:49 <pmetzger> so it seemed to me like there "should" be good ways to automatically parallelize code. I imagine that must be ongoing research.
16:06:02 <pmetzger> (for some value of "should".)
16:06:07 <ddarius> It's trivial to automatically parallize Haskell code.
16:06:44 <kmc> yeah, the problem is you parallelize too much :D
16:06:47 <dolio> The non-trivial part is not wasting time parallelizing more than is worth it.
16:06:53 <jnhnum1> dons: wow thanks it works :)
16:07:04 <jnhnum1> but is there a way to use the vector stuff with an Int64?
16:07:22 <jnhnum1> I get something like Couldn't match expected type `Int' with actual type `Int64'     In the second argument of `V.enumFromN', namely `b'     In the first argument of `V.sum', namely       `(V.enumFromN a b :: V.Vector Int64)'     In the expression: V.sum (V.enumFromN a b :: V.Vector Int64)
16:07:34 <dons> hmm. let's see.
16:07:38 <dons> do you have a 64 bit machine?
16:08:11 <jnhnum1> oh
16:08:13 <dons> oh, `import Data.Int`
16:08:17 <jnhnum1> I mean
16:08:23 <jnhnum1> it has a 64 bit processor
16:08:30 <dons> main = do [n] <- map read `fmap` getArgs print $ V.sum (V.enumFromN 1 n :: V.Vector Int64)
16:08:33 <jnhnum1> but I'm running 32-bit ubuntu?
16:08:33 <dons> urgh
16:08:47 <jnhnum1> :( sorry
16:08:50 <dons> anyway, yes, just import Data.Int; on 64 bit machines, Int is already 64 bits.
16:09:08 <dons> > Foreign.sizeOf (undefined :: Data.Int.Int64)
16:09:08 <dons> 8
16:09:11 <LambdaTemp>   Not in scope: `Foreign.sizeOf'
16:09:16 <kmc> anyone have suggestions on xml libraries?
16:09:16 <kmc> (i asked a little while ago)
16:09:20 <dons> will tell you Prelude> Foreign.sizeOf (undefined :: Data.Int.Int)
16:09:20 <dons> 8
16:09:22 <ddarius> > bitSize (undefined :: Int)
16:09:25 <LambdaTemp>   64
16:09:34 <dons> good point
16:10:21 <dons> jnhnum1: note that on a 32 bit machine, 64 bit ints are implemented as C calls to the GMP library
16:10:32 <dons> and will be > 10x slower than machine-supported 64 bit ints
16:11:00 <dons> e.g. if Int is not 64 bit, ghc will have to use libgmp
16:11:12 <jnhnum1> does a 32-bit operating system on 64-bit hardware count as a 32-bit machine?
16:11:23 <dons> well, depends on your ghc
16:11:25 <ddarius> Viewed a different way, you may as well use Integer in that case.
16:11:32 <dons> indeed
16:11:47 <jnhnum1> for me Foreign.sizeOf (undefined :: Data.Int.Int) gives 4, so ... :/
16:11:47 <dons> jnhnum1: what does this do on your machine:
16:11:48 <dons> Prelude> Data.Bits.bitSize (undefined :: Int)
16:11:48 <dons> 64
16:11:51 <dons> right.
16:12:02 <dons> so you don't have nice wide Ints for the purposes of this problem
16:12:07 <aristid> GHC's Integer uses non-GMP for 64-bit integers on 64-bit machines?
16:12:16 <dons> yes
16:12:27 <ddarius> @src Integer
16:12:28 <LambdaTemp> data Integer = S# Int#
16:12:28 <LambdaTemp>              | J# Int# ByteArray#
16:12:49 <kmc> that would indicate not, if i understand aristid's question correctly
16:12:53 <dons> btw, that is the best code i've seen ghc emit for that problem
16:12:59 <dons> llvm is getting better at ghc
16:15:14 <dcoutts> dons: btw, 64bit int on 32bit machines uses C code but not gmp
16:16:00 <Peaker> I think it would be nice if code could express: A) the expensiveness of computing an expression  B) what other things are worth evaluating speculatively (if they are expensive)   so (+) (at least for strict number types) would say: Speculatively evaluate both before invocations.  This would only happen if the args to (+) are marked "expensive" by the user
16:18:43 <shachaf> Cale: lambdabot seems to have died.
16:19:03 <Cale> thanks for the heads up
16:19:18 <dons> dcoutts: oh, interesting. i always assumed the code would have been written by someone else
16:19:40 <Cale> All my processes on the lambdabot server seem to have died, and the machine name is now (none)
16:19:59 <Xaratas> can i get the hpaste warnings in winghci?
16:20:22 <hpc> Xaratas: http://hackage.haskell.org/package/hlint
16:20:31 <hpc> i am fairly sure that's what hpaste uses
16:20:34 <Cale> I think the warnings are generated by hlint which is a separate tool, yeah
16:21:00 <geheimdienst> cale: so was the machine hacked or did lambdabot finally become self-aware and went on a depressive rampage?
16:21:07 <Cale> lol
16:21:09 <dcoutts> dons: in ghc-prim: foreign import ccall unsafe "hs_plusInt64"
16:21:14 <hpc> geheimdienst: can't it be both?
16:21:15 <hpc> :P
16:21:22 <jnhnum1> dons: so LLVM doesn't seem to recognize what the loop is doing if I just do something simple like just sum [1..n]
16:21:27 <jnhnum1> I don't suppose you know why that is, do you?
16:21:42 <Peaker> @src sum
16:21:43 <LambdaTemp> sum = foldl (+) 0
16:21:45 <jnhnum1> or is it just that the Data.Vector module generates simpler / easier to analyze intermediate code
16:21:47 <lambdabot> sum = foldl (+) 0
16:21:48 <dcoutts> dons: the C code though is trivial, since it can use the C compiler's support for long long
16:21:53 <jnhnum1> or something
16:21:57 <dcoutts> dons: HsInt64 hs_plusInt64   (HsInt64 a, HsInt64 b)   {return a + b;}
16:22:31 <Cale> jnhnum1: Moar context? I just joined.
16:22:43 <aristid> 64-bit addition can be easily done in x86 assembly
16:22:50 <dcoutts> dons: so the assembler will be fine, but there's the C function call overhead
16:22:56 <aristid> but i think for multiplication the c-compiler calls a built-in function
16:23:03 <elliott> wb lambdabot
16:23:06 <dcoutts> aristid: right, and that's what the C compiler will be doing
16:23:35 <jnhnum1> Cale: so if you sum the numbers from 1 to n like this: http://hpaste.org/46443/vector_fusion then llvm notices what you're doing, and replaces the loop with the formula n(n+1)/2
16:23:44 <dcoutts> aristid: with the right primops, add with carry etc, we should be able to do this code in Haskell directly and get decent assembler
16:24:01 <aristid> dcoutts: yeah.
16:24:06 <jnhnum1> (if you compile with ghc -O2 -fllvm)
16:24:17 <aristid> dcoutts: not for multiplication tho
16:24:23 <jnhnum1> but it does no such (amazing) optimization if you just do sum [1..n]
16:24:24 <dcoutts> aristid: we got half way there for an IHG project to implement "safe" integers
16:24:33 <aristid> IHG?
16:24:40 <dcoutts> Industrial Haskell Group
16:24:57 <Cale> jnhnum1: You mean, with lists and the usual prelude sum function?
16:25:06 <jnhnum1> yeah with the usual sum function
16:25:11 <aristid> dcoutts: why only half?
16:25:30 <dcoutts> aristid: we added faster primops for overflow checking, but we did not do add with carry
16:25:54 <dons> jnhnum1: you need to use the stream fusion optimizations, exported via Data.Vector
16:25:55 <aristid> dcoutts: it's a pretty useful little operation :)
16:25:57 <dcoutts> aristid: and also, we did not do all the low level code gen stuff, so there's still some unnecessary work being done
16:26:01 <dons> they're not on by default for lazy lists
16:26:15 <Cale> How does that compile? Do you have a paste? It's not terribly surprising to me that it wouldn't be able to catch it anymore.
16:26:28 <aristid> dons: is the formula optimization done by GHC or by LLVM?
16:26:39 <dcoutts> aristid: by ghc
16:26:57 <dons> in this case, llvm
16:26:58 <Cale> Though, just the normal RULES pragmas should do a little fusion of producers and consumers, so you shouldn't have an intermediate list.
16:27:03 <dons> the fusion is ghc
16:27:09 <dons> but then llvm turns the loop into a formula
16:27:22 <aristid> dons: ok, weird that llvm has such an optimization
16:27:24 <dons> ghc does the magic of turning the function pipeline into  wfoldlM'_loop
16:27:36 <dons> well, gcc usually does that for C loops
16:28:25 <aristid> these optimizations make a lot of sense to score well in stupid benchmarks
16:28:34 <Cale> So which backend is default in 7.0.3?
16:28:44 <Cale> We have so many now :)
16:29:46 <Cale> I'm guessing the native code generator?
16:30:18 <aristid> is it custom to write scanner passes for non-trivial grammars, or is doing everything directly on Char parsers the preferred way?
16:30:52 <hpc> as in, multiple passes?
16:31:08 <aristid> yes
16:31:14 <Cale> aristid: It's partly a matter of taste, though there can be some benefits to writing a scanner. You can write the scanner in Parsec too, though :)
16:31:29 <aristid> specifically, i wonder if a tokeniser pass would be a good idea
16:31:30 <dons> -fasm is still the default
16:31:40 <hpc> i think if you are going to parse something multiple times, the intermediate structure might as well be something nicer to manipulate than String
16:31:53 <hpc> but i don't do much parsing
16:31:56 <thoughtpolice> Cale: yeah, NCG is still the default
16:32:27 <aristid> Cale: i wondered if maybe a scanner can reduce the number of instances where 'try' is necessary (or other tricks)
16:33:58 <Cale> aristid: Maybe a little, but not in an essential way. Any uses of try it'll eliminate will be ones which were around small parsers (that parse single tokens), so it'll only reduce the lookahead by a little.
16:34:50 <aristid> Cale: so if i do it without a scanner, i need not fear that i'm doing it wrong?
16:35:10 <Cale> I wouldn't be too worried.
16:35:39 <Cale> This is alot of cake http://enguyen.imgur.com/alot
16:36:49 <aristid> Cale: i wouldn't dare cut that cake
16:38:02 <Cale> Yeah, it's almost too awesome to be eaten
16:38:48 <KirinDave> So i got a spare moment, I had a question from last night's questions about monad transformers
16:38:51 <KirinDave> http://hpaste.org/46447/how_do_i_declare_this
16:39:03 <KirinDave> I have a type in my Data section which has these outcomes
16:39:21 <KirinDave> Outcomes are either simple announcements, edges to other nodes in the graph, or something custom
16:39:26 <KirinDave> (this is for a simple zork-like game)
16:39:47 <Cale> I don't understand the "let it use the monad stack"
16:39:52 <KirinDave> Cale: Well
16:39:59 <geheimdienst> KirinDave: i might be missing something but have you tried "data Outcome a = ..."?
16:40:11 <KirinDave> geheimdienst: Yeah but then every use of outcome needs to be now an Outcome ()
16:40:24 <Cale> oh, that Command thing is a bit odd :)
16:40:26 <KirinDave> Except for commands which are Outcome whatevers.
16:40:36 <KirinDave> I want it to be able to use my WriterT [String] Reader GameState a
16:40:45 <KirinDave> So I can use tell and say etc in my command functions.
16:40:49 <monochrom> this may quickly go down the slippery slope of existential types
16:40:49 <Cale> Perhaps you wanted   data Outcome a = ... | Command { ... perform :: Room -> a }
16:41:08 <KirinDave> Cale: Right but then all Outcomes need a type assocaited with them
16:41:22 <aristid> KirinDave: split it into multiple types?
16:41:31 <KirinDave> aristid: I sort of like being able to go across all of them.
16:41:35 <KirinDave> In one big loop
16:41:43 <Cale> KirinDave: Remember that types don't exist at runtime :)
16:41:51 <aristid> KirinDave: huh? you'd still have the union type
16:41:51 <monochrom> I wonder whether you really really need absolutely need arbitrary "a"
16:42:07 <KirinDave> monochrom: I don't want to have to declare my ReaderT... stuff in my data file.
16:42:19 <Cale> KirinDave: So every Outcome *might* be a Command, and for that reason, you need that type parameter to know what type the perform field will be in the case that it is.
16:42:20 <monochrom> as opposed to "in reality there are only 10 cases and could be one single type"
16:42:38 <aristid> hmm.
16:42:41 <KirinDave> monochrom: It's more just that I don't want to repeat myself.
16:42:52 <Cale> KirinDave: You should newtype your monad as well.
16:42:54 <KirinDave> In reality these all describe a Thing To Do When Confronted With A GameState
16:43:08 <aristid> @quote newtype
16:43:08 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
16:43:10 <LambdaTemp> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
16:43:28 <KirinDave> For example "look" is a Command, it takes the current room and describes it
16:43:29 <aristid> yay! two lambdabots = double awesomeness
16:43:30 <Cale> newtype Game a = WriterT [String] (Reader GameState a
16:43:31 <Cale> oops
16:43:42 <KirinDave> Cale: Yeah but that is not material to this question.
16:43:53 <KirinDave> That's defined in my Main file.
16:43:57 <Cale> newtype Game a = WriterT [String] (Reader GameState) a deriving (Functor, Monad,...)
16:44:05 <Peaker> I got a really old message from lambdabot I think
16:44:34 <Cale> KirinDave: hmm
16:45:49 <Cale> KirinDave: It's important to whoever is applying the perform function to know from the 'a' in 'Outcome a', which type of result they'll get.
16:46:10 <Cale> I mean, maybe you can redesign this somehow so that it doesn't matter...
16:46:21 <KirinDave> Just have Command be a separate type
16:46:37 <KirinDave> Technically it doesn't get lumped in with the rest of the outcomes
16:46:40 <KirinDave> Since it's not part of a room
16:47:25 <KirinDave> But I'd like one big matching function to be able to handle actions, edges, or commands
16:47:29 <KirinDave> Since their processing is all related.
16:48:04 <Cale> The other option is just to fix the type of 'a'
16:48:15 <Cale> Is it always going to be the same type?
16:49:12 <KirinDave> Cale: Well
16:49:24 <KirinDave> I guess I could split the gamestate stuff into its whole own unique file.
16:49:28 <KirinDave> So then I don't have to repeat myself
16:49:38 <Cale> What would you be repeating?
16:50:30 <KirinDave> Rag.Data needs my monad stack type from Rag.Main
16:50:37 <KirinDave> But Rag.Main needs all the datatypes defined in Rag.Data
16:51:05 <KirinDave> So I sorta have to put it somewhere they both could be included.
16:51:21 <aristid> KirinDave: sometimes people create Foo.Types to fix up circular dependencies
16:51:51 <KirinDave> I guess I could just make commands entirely seprate and handle them entirely separately.
16:51:53 <Cale> oh, yeah, just move the type declarations around a bit
17:02:57 <mm_freak_> is there a convenient way to manage multiple .cabal and .ghc directories for a single user?  like an environment variable
17:03:30 <ryant5000> mm_freak_: have you tried cabal-dev?
17:03:37 <ryant5000> not quite the same thing, but perhaps close
17:05:22 <mm_freak_> ryant5000: no, but it looks interesting
17:06:03 <mm_freak_> the reason why i would like this is that updates sometimes break my packages, and this is bad, if i need them for production
17:06:30 <mm_freak_> cabal-dev might solve my problem
17:07:55 <hskal> do you like haskell ?
17:08:04 <adnam> Y
17:08:25 <mm_freak_> i like coffee and cigarettes
17:08:53 <nihtml> yeah, nice, bro
17:09:20 <hskal> strange language)
17:10:12 <nihtml> hskal: haskell
17:10:13 <nihtml> ?
17:10:22 <hskal> yeah
17:10:26 <aristid> mm_freak_: try liking water and delicious apples instead :P
17:10:42 <hskal> I like apples =)
17:11:32 <parcs> haskell is pretty hot
17:11:50 <hskal> after yearh of C# =)
17:12:11 <mm_freak_> aristid: i like those, too, but they are not so addictive
17:13:22 <nihtml> the game :(
17:13:42 <hskal> playing with haskell tutorial right now =)
17:13:49 <nihtml> you're wrong mm_freak_, apples are so addictive :((
17:14:02 <dysinger> mm_freak_: I <3 me some cabal-dev - use it everywhere except production
17:14:23 <aristid> dysinger: if i see it right mm_freak_ wants it _especially_ for production
17:14:36 <dysinger> I think it's fine there too
17:15:03 <dysinger> I personally think they should take the "-dev" off of it and merge it into cabal-install
17:15:06 <dysinger> just make it a flag
17:15:11 <dysinger> like --local
17:15:43 <mm_freak_> aristid: no, i seem to have the same application has dysinger
17:15:57 <mm_freak_> on production i want only binaries, actually
17:15:59 <dysinger> cabal install —sandbox foo
17:16:06 <dysinger> something like that
17:17:57 <aristid> mm_freak_: i like how ghc produces these binaries with minimal dependencies
17:18:17 <aristid> they are pretty big, tho
17:18:42 <mm_freak_> aristid: it should be optional IMO
17:18:56 <aristid> mm_freak_: you mean the default should be different?
17:19:26 <aristid> static linking has big maintenance advantages
17:20:25 <sshc> How does transformer's implement Strict state and Lazy state differently?
17:20:33 <mm_freak_> aristid: which matter only, when you move binaries to other hosts
17:20:47 <kmc> uh, no
17:20:57 <aristid> mm_freak_: i think they also matter in other circumstances
17:21:08 <kmc> say you upgrade a shared library and something breaks
17:21:11 <sshc> The only difference I see in the source is that the Lazy variant requires a pattern match by placing a ~ before the tuple in its definition if >>=
17:21:21 <aristid> mm_freak_: with shared libraries you need fancy versioning schemes to keep things from breaking
17:21:29 <kmc> sshc,  that's the opposite of what ~ does
17:21:35 <kmc> ~ makes the tuple matching lazy
17:21:36 <ivanm> mm_freak_: on gentoo, we took advantage of static linking to make sure haskell-updater works after upgrading GHC
17:22:02 <kmc> if you write « (a,b) >>= ... » then (>>=) is strict in its first argument
17:22:06 <kmc> not so if you use ~(a,b)
17:22:17 <mm_freak_> kmc: say nothing breaks
17:22:20 <aristid> ivanm: are you doing the official haskell packages for gentoo?
17:22:21 <mm_freak_> kmc: then you have to recompile
17:22:28 <ivanm> aristid: I'm not anymore
17:22:46 <aristid> ivanm: but you still use gentoo? :P
17:22:46 <ivanm> but when I get around to it I'm going to be doing Cabal support for paludis on exherbo
17:22:52 <kmc> mm_freak_, you have to recompile if you want the new features
17:23:04 <mm_freak_> kmc: or the bug fixes
17:23:04 <kmc> versus being forced to recompile or worse, just so working stuff doesn't break
17:23:04 <sshc> kmc: Does this apply in general?  i.e., ~ indicates *lazy* pattern matching?
17:23:07 <kmc> it is a tradeoff though
17:23:10 <ivanm> aristid: I'm still using gentoo until I can fix haskell support on exherbo; then this laptop will no longer be my dev box
17:23:10 <mm_freak_> kmc: and security updates
17:23:24 <kmc> sshc, yes
17:23:34 <aristid> ivanm: looks like exherbo is a fork of gentoo
17:23:38 <ivanm> nope
17:23:45 <mm_freak_> a "fancy versioning system" is what you need, otherwise you will have to recompile a lot every time you make an update
17:23:47 <ivanm> unless you consider "idea fork" to be a fork
17:23:55 <sshc> Can anybody point me in the direction of documentation?  ~ isn't an easy symbol to search with
17:24:04 <mm_freak_> it's not broken to need a versioning system…  it's broken not to have it
17:24:08 <ivanm> sshc: it's syntax, not a function
17:24:11 <ivanm> so check the report
17:24:34 <monochrom> I learned ~ from the gentle introduction
17:24:48 * ivanm always forgets what ~ is called
17:24:55 <ivanm> there's probably a wiki page on it as well
17:25:00 <monochrom> irrefutable
17:25:11 <ivanm> that's the one
17:25:17 <ivanm> @google irrefutable pattern match
17:25:18 <shachaf> Tilde.
17:25:18 <lambdabot> http://www.haskell.org/tutorial/patterns.html
17:25:18 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
17:25:22 <aristid> ~monochrom *very bad joke*
17:25:25 <ivanm> sshc: ^^ ;-)
17:25:34 <kmc> the pattern ~p always matches, and forces nothing.  if one of the variables inside p is forced, it will then go back and do the pattern match, and die if it fails
17:25:34 <kmc> > case Nothing of Just _ -> 1; Nothing -> 0
17:25:34 <kmc> > case Nothing of ~(Just _) -> 1; Nothing -> 0
17:25:35 <kmc> lambdabot nooooo
17:25:35 <lambdabot>   0
17:25:35 <lambdabot>   1
17:25:36 <kmc> lazy irrefutable pattern?
17:25:36 <kmc> should be able to google something like that
17:25:41 <monochrom> begin from http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
17:25:46 <kmc> thanks lambdabot
17:25:51 <sshc> Thanks
17:25:56 <kmc> > case Nothing of ~(Just x) -> x+1; Nothing -> 0
17:25:57 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for patt...
17:26:33 <shachaf> Why can you even use irrefutable pattern matches with case?
17:26:57 <monochrom> to give you a symmetric, orthogonal language
17:27:04 <dolio> They're used to define the semantics of let.
17:27:12 <shachaf> Why doesn't that generate a compiler warning?
17:27:17 <monochrom> i.e., no wanton restrictions
17:27:53 <mm_freak_> shachaf: because you can have this:  case Just Nothing of Just (~Nothing)
17:28:08 <mm_freak_> > case Just Nothing of Just (~Nothing) -> 1
17:28:08 <lambdabot>   1
17:28:11 <kmc> shachaf, maybe it does?
17:28:13 <monochrom> guido's language is the opposite. it has restrictions just because he doesn't see a use case
17:28:17 <mm_freak_> > case Just Nothing of Just (~(Just 3)) -> 1
17:28:18 <lambdabot>   1
17:28:59 <mm_freak_> only part of this pattern is irrefutable
17:30:09 <mm_freak_> > do ~(Just x) <- Just Nothing; return x
17:30:09 <lambdabot>   Just *Exception: <interactive>:3:3-27: Irrefutable pattern failed for patte...
17:31:53 <Peaker> monochrom, Why "guido's language" and not "python"? :)
17:32:29 <shachaf> Peaker: No, not Python. The other Guido.
17:32:29 <mm_freak_> probably to emphasize that python is broken by designer =)
17:32:33 <monochrom> because if guido invented more than one language, what I said would not apply to python alone
17:33:36 <Peaker> I think there is a good side to having the most restricted language that still achieves some purpose (e.g: Non-Turing-Complete languages)
17:34:20 <mm_freak_> Peaker: there is no good side to trying to get rid of a whole paradigm, just because you don't like it personally
17:35:28 <mm_freak_> it's like SPJ trying to get rid of the IO monad
17:35:31 <Peaker> mm_freak_, The reason for getting rid of it is not relevant to the potential good.  There is definitely *some* good -- it results in more uniform programs in that language. That's not to say the bad does not outweigh the good
17:35:37 <monochrom> forbidding expression-level if-then-else (aka ?:) does not achieve a technical purpose, only an ideological purpose
17:36:01 <Peaker> monochrom, it makes for a simpler language (though more complex programs)
17:36:17 <mm_freak_> Peaker: it's the same statement, but you're just putting it in a better light
17:36:20 <kmc> Python has that now
17:36:29 <Peaker> monochrom, Then there's 1 less idiom to do the same thing -- so it's more likely you've seen an idiom before when you read random code
17:36:41 <aristid> if should be a function, if you have lazy evaluation
17:36:53 <Peaker> kmc, yeah - I know, I'm just saying Python's decisions weren't braindead even if they may have been wrong.. There is a good side to restricting the language
17:36:57 <kmc> yeah, Haskell should get rid of if / then / else
17:37:01 <monochrom> yes, python has it now. but it was forbidden at all disappointed me
17:37:14 <dolio> We don't have the syntactic machinery to make if-then-else a function.
17:37:15 <mm_freak_> Peaker: you may have some point generally
17:37:24 <mm_freak_> Peaker: but read guido's comments on functional programming
17:37:28 <aristid> dons: but we can make if a function, without then-else
17:37:29 <mm_freak_> it's pure warfare
17:37:29 <geheimdienst> i don't think forbidding ?: makes for a simpler language, on the contrary. if everything was an expression, it would be a simpler language. it's a language complication to arbitrarily divide stuff into statements and expressions
17:37:30 <kmc> i'm not a huge fan of that if/then/else syntax
17:37:36 <aristid> i mean dolio
17:37:43 <kmc> love is a battlefield
17:37:55 <dolio> We could.
17:37:57 <Peaker> geheimdienst, if ?: was allowed *in place* of another thing, maybe. if it is an addition, it is more complex
17:38:17 <mm_freak_> Peaker: my interpretation of his "reasoning" is: "functional programming is braindead, nobody needs it, and everybody, who uses it, is a total retard"
17:38:19 <dolio> I wouldn't like the extra parentheses, though.
17:38:25 <dolio> Not that I use if-then-else much.
17:38:29 <aristid> geheimdienst: yeah, the syntactic statement/expression division needs to die a violent death
17:38:35 <kmc> obviously FP is useless, Blub doesn't have it, and I program just fine in Blub
17:38:45 <aristid> dolio: well, you can also do neat things like (??)
17:38:52 <Peaker> mm_freak_, do you have any quote of his on FP?
17:39:02 <mm_freak_> kmc: who needs blub?  cobol is fine
17:39:07 <kmc> coblub
17:39:12 <aristid> @let (x ?? y) c = if c then x else y
17:39:14 <lambdabot>  Defined.
17:39:20 <aristid> :t (??)
17:39:21 <lambdabot> forall t. t -> t -> Bool -> t
17:39:38 <kmc> @let (^........^) = (??)
17:39:38 <lambdabot>  Defined.
17:39:53 <mm_freak_> Peaker: you'll have to google, i don't have it bookmarked…  just try "guido remove reduce reasons" or something
17:39:54 <aristid> kmc: the more dots the better?
17:40:14 <ddarius> mm_freak_ likes commas.
17:40:19 <Derander> woah woah woah. did google just change their font?
17:40:28 <Derander> http://cl.ly/2H2w353f2P1J3L0P2a2m
17:41:06 <mm_freak_> ddarius…  and ellipsis
17:41:06 <kyagrd> Well unless python implementations support tail recursion it wouldn't be practical to do FP in Python anyway.
17:41:09 <monochrom> since there is no "before" screenshot, I can't say font has changed
17:41:24 <Derander> monochrom: fair enough. it just looked vastly different than I expected it to. I have no before either :-)
17:41:39 <mm_freak_> kyagrd: the implementations of functional combinators can well be iterative
17:41:55 <kmc> that better be a link to goatse
17:42:02 <Derander> kmc: I HAVE FAILED
17:43:01 <mm_freak_> in python there is nothing wrong with implementing 'reduce' (i.e. foldl) or 'map' with loops
17:43:48 <kyagrd> mm_freak_: what about more general ones catamorphism over more gernal structures?
17:44:19 <geheimdienst> i thought the reasoning for tossing reduce was that list comprehensions were a good replacement for reduce/map
17:44:25 <zomg> Any suggestions on a http library which supports persistent http connections?
17:44:30 <ddarius> kyagrd: Those are recursive anyway.
17:44:34 <mm_freak_> kyagrd: in python you wouldn't bother representing catamorphisms as what they are
17:44:37 <zomg> I'm looking at the HTTP package but being a noob I have no idea =)
17:45:13 <mm_freak_> you would just write specific instances
17:45:17 <monochrom> Peaker: if guido lived before fortran, he would use his "expression vs statement" to further forbidden method calls in expressions, nesting in expressions (i.e., merely 1*(2+3)), algebra in expressions, basically every progress made by fortran. "this is a statement language", taken to its logical conclusion, is a three-address language "v := op(a,b)"
17:45:36 <elliott> also known as assembly
17:45:37 <monochrom> and yes it is almost the simplest useful language
17:45:46 <elliott> oh, hmm
17:45:47 <elliott> more like an OISC
17:45:58 <elliott> IIRC Subleq is three-operand
17:46:12 <Peaker> monochrom, Well, Python is slowly adding constructs that they deem useful
17:46:18 <Peaker> monochrom, Python 3 is very different from Python 1.5
17:46:23 <Peaker> (and much larger, not smaller)
17:46:40 <monochrom> yes, by popular demand, his extremist ideology has to be compromised
17:46:41 <aristid> monochrom: for some values of useful
17:49:38 <dons> i don't really like the old answers on this SO question on in what sense ADTs are algebraic. do people have any comments on my answer? http://stackoverflow.com/questions/16770/haskells-algebraic-data-types/5917133  esp. CT fans.
17:49:39 <elliott> Peaker: and removing ones they don't like
17:49:46 <elliott> I'd surprised lambda is even still in the language.
17:49:56 <elliott> (tbh it'd be better without considering how bad python's lambda is)
17:49:58 <BMeph> Wow, that's a classic Guido stmt: " filter(P, S) is almost always written clearer as [x for x in S if P(x)]"
17:50:19 <mauke> OH GOD THE TERRIBLE CLARITY
17:50:27 <Peaker> BMeph, given P is usually a lambda expression with horrible syntax, that's actually true
17:50:42 <elliott> Peaker: erm
17:50:42 <monochrom> the 3-hours-ago answer by dons is my answer too
17:50:43 <mauke> Peaker: strongly disagree
17:50:50 <elliott> filter(lambda x: ..., S)
17:50:53 <elliott> [x for x in S if ...]
17:50:55 <mauke> Peaker: "[x for x" isn't clearer than anything
17:51:02 <elliott> the hideousness is there either way
17:51:04 <ion> 1+2 is almost always written clearer as let a = 1; b = 2; c = (+) in c a b
17:51:04 <Peaker> filter(lambda x: x % 2 == 0, beh)  vs.  [x for x in beh if x%2==0]
17:51:19 <elliott> Peaker: the latter is totally unclear
17:51:22 <mauke> "[x for x in beh" is basically crap
17:51:25 <elliott> you know it's a weird list comprehension of some sort
17:51:28 <elliott> and only at the end you find out it's a filtering
17:51:32 <elliott> and in the middle its just confusing
17:51:35 <Peaker> mauke, yeah, but spelling out "lambda x:" is also crap :)
17:51:36 <elliott> with filter, bam, you know what's coming up
17:51:47 <elliott> Peaker: yeah, but that's the rest of Python's fault, not filter()s :P
17:52:04 <monochrom> the universal algebra answer does not apply to algebraic data types; it applies to algebraic specifications of (not necessarily algebraic) data types
17:52:04 <elliott> it's like removing some other part of the language because a part that it's mostly useful with is terrible
17:52:06 <elliott> oh wait that's exactly what it is.
17:52:15 <Peaker> elliott, I think he's making a whole-language argument, not against filter specifically.  he wrote in another thread that in a language with better syntax for lambdas/etc, reduce is more useful than in Python
17:53:12 <monochrom> if you have heard of Larch, its specification language fits universal algebra
17:53:19 <elliott> Peaker: you mean in a better language :)
17:53:47 <mm_freak_> Peaker: as a non-pythoner i have no idea how to read the list comprehension, whereas the combinator variant i understand instantly
17:53:54 <mm_freak_> list comprehension is a language feature
17:54:01 <monochrom> actually my answer differs from dons's. I don't even bring up categories
17:54:16 <mm_freak_> so it's a special case you have to learn, and it's not always clearer, and it's also much less composable
17:54:58 <ion> > let beh = [0..] in [x | x <- beh, (x `mod` 2) == 0]
17:54:59 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
17:55:40 <monochrom> Either is like +, (,) is like *, a data type declaration is like a polynomial (if you don't recurse), that's how algebraic it is
17:56:06 <ddarius> dons: Your explanation completely excludes types like data D = D (D -> D) or most types with functions in them.
17:56:09 <aristid> monochrom: and if you recurse?
17:56:38 <monochrom> you get infinite series, transcendental
17:56:41 <danharaj> then you take a fixpoint
17:57:19 <mm_freak_> aristid: imagine a polynomial component with infinite exponent
17:57:28 <monochrom> well, then you bring up CT and say "initial algebra" rather than "highschool polynomial algebra"
17:57:53 <ddarius> monochrom: I agree re algebraic specification.
17:57:56 <mm_freak_> data Stream a = Cons a (Stream a)  -- a^Infinity
17:58:27 <ddarius> In a total language, Stream is uninhabited as an initial algebra.
17:58:30 <danharaj> i was never clear on how you define fold for non-regular recursion
18:00:32 <kyagrd> ddarius: it's a dual ... coalgegra
18:00:47 <kyagrd> haskell acidently captures them in one syntax :)
18:00:55 <danharaj> A * X has an initial algebra as well as a terminal coalgebra.
18:00:56 <ddarius> kyagrd: They are the same in Haskell.
18:01:05 <danharaj> In a total language the initial algebra is bottom.
18:01:15 <ddarius> danharaj: Void
18:01:28 <danharaj> ddarius: Difference?
18:01:41 <monochrom> bottom is a value of type Void
18:01:50 <ddarius> danharaj: The normal meaning of "bottom" (in this context) is exactly what total languages lack.
18:01:57 <danharaj> ah ok.
18:02:04 <danharaj> The empty type.
18:02:08 <ddarius> Anyway, bottom is a value not a type.
18:02:09 <kyagrd> well depends on the definition of "value"
18:02:24 <monochrom> but I don't mind overloading the name "bottom"!
18:02:35 <danharaj> I mean, () is a value of type () ;)
18:02:45 <kyagrd> danharaj: that's unit not void
18:02:51 <danharaj> kyagrd: Yes I know.
18:02:59 <danharaj> That's not what I was saying.
18:03:00 <monochrom> (&) :: () -> () -> (); () & () = ()  is my favourite function :)
18:03:08 <dons> ddarius: hmm
18:03:19 <kyagrd> @type (&)
18:03:19 <lambdabot> Not in scope: `&'
18:03:35 <monochrom> no it's not in any lib out there
18:04:17 <aristid> monochrom: why is it your favorite function?
18:04:41 <monochrom> I'll show you my haskell-cafe post that features it
18:05:37 <monochrom> it is being slow on me
18:06:37 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/
18:08:05 <aristid> monochrom: what are the results with pseq?
18:08:07 <pmetzger> what's the resulting performance difference?
18:09:11 <monochrom> pseq finishes it instantly and no stack overflow, all optimization levels
18:10:12 <aristid> why?
18:10:33 <ddarius> pseq has a specific evaluation order, seq does not.
18:11:36 <aristid> hmm.
18:11:45 <ddarius> Really, foldl' should be defined using pseq as it is in that email.
18:12:55 <monochrom> hehehehehe!
18:13:17 * monochrom has the gift of counterexamples!
18:13:43 <ddarius> In fact, almost all uses of seq are probably intended to be uses of pseq.
18:14:42 <monochrom> "strictness" doesn't help improve or degrade speed or memory. not even the right level of abstraction. "strictness" is denotational, only talks about answers
18:14:52 <ddarius> Exactly.
18:14:55 <Peaker> why would anyone want to make his program less refined with seq?   IOW: Why would anyone want the denotational semantics of seq (as opposed to operational semantics of pseq which may be desirable)?
18:15:05 <Peaker> proofs-as-args? Hard to encode in Haskell anyway
18:15:21 <monochrom> if you need a correct word to fill into "make it more _____ to save memory", the word is "eager"
18:15:32 <ddarius> Peaker: Any "evidence passing" system would require it.  It doesn't need to be a "proof."
18:15:44 <kmc> it's even the right number of letters!
18:15:51 <ddarius> monochrom: What if I put in the word "lazy?"
18:15:51 <Peaker> ddarius, what kind of evidence is encodable in Haskell?
18:16:05 <shachaf> Then you're left with an _.
18:16:13 <monochrom> "lazy" also works, for some other cases
18:17:21 <monochrom> and my IMO answer to why people used seq: just look at the names "Control.Monad.State.Strict" and "Control.Monad.State.Lazy" and you see people were really not thinking at all
18:18:15 <Peaker> monochrom, is it well-known that strict:non-strict <-> eager:lazy?  Are these terms well-defined/agreed-upon?  I hear people refer to strictness as the opposite of laziness all the time
18:18:16 <monochrom> depending on which level of abstraction you commit yourself to, it should be either "...Strict" vs "...NonStrict", or "...Eager" vs "...Lazy"
18:18:34 <ddarius> Peaker: You can pass around a token that represents "Yes, I've initialized the library."  Admittedly, in many cases it's better to have the token actually be the capability to the library (i.e. in the form of say a record of functions) rather than a meaningless token, but there are reasons you might go this route.
18:18:56 <ddarius> Peaker: Yes, it is well-known.
18:19:02 <monochrom> it is well-known, if you relax "<->" quite a bit, not exact correspondence there, but practically almost right
18:20:24 <applicative> Is "LiberalTypeSynonyms" thought to be a sensible extension, like MultiParamTypeClasses, or more in the nature of IncoherentUnlovedOrpans?
18:20:43 <ddarius> applicative: It's fine.  It's pretty trivial.
18:20:49 <monochrom> the fun thing about many members of this community that angers me is this. when I try to say "eager" they chastise me on how haskell is only standardized by the denotational level, how I should only call it "strict". next minute they go on to speak "lazy"
18:21:02 <ddarius> It's more like EmptyDataDecls than either of those.
18:21:36 <shachaf> monochrom: #haskell optimizes for number of syllables first and for precision second.
18:21:38 <ddarius> Indeed.  It's completely legal for Haskell to be call-by-name, in which case pretty much any analysis of performance is wildly wrong.
18:22:12 <monochrom> shachaf, lengthy lectures on me on denotational semantics does not optimize number of syllables
18:22:36 <ddarius> Incidentally, you can specify order of evaluation denotationally if you wanted to.
18:23:23 <monochrom> how? I want to know
18:24:06 <monochrom> s/lectures on me/lectures to me/
18:24:15 <ddarius> monochrom: Use CPS.
18:24:32 <monochrom> oh yikes, I see
18:24:56 <ddarius> (Or, since denotational semantics doesn't technically force you to use the untyped lambda calculus, you can use a mathematical infrastructure that allows you to directly state such things.)
18:26:56 <ddarius> "We use 'Kawaii' so many times in a day. 'Kawaii' exist here and there in Japan. Basically,it means 'cute'. It is very convinient word."  I think this is one of the stupidest collection of sentences I've seen put together.
18:27:26 <monochrom> heh
18:28:11 <kmc> ^___________^
18:28:32 <Veinor> ddarius: ow my head
18:28:44 <olsner> ddarius: hmm, not that weird I think... I use "cute" to describe any piece of code between nice and retarded
18:29:03 <pmetzger> "Kawaii 5-0."
18:29:08 <olsner> like "this code will always screw up the heap, that's cute"
18:29:18 <geheimdienst> ddarius: your quote sounds like a lolcat, but it has unexpectedly good spelling
18:29:53 <dons> monochrom: you're only allowed to say non-strict
18:30:13 <monochrom> haha
18:30:40 <kmc> "Im looking for a bento box, it cant be pinku (thats japanese for pink) or any girl color. It has to be of 2 or more kotoba (that's japanese for 2 compartments) and has be be chibi(small) sized. And has to be really kawaii (cute)."
18:31:00 <mauke> delicious pasta
18:31:07 <kmc> "I have found a bento box similar to the one im describing in e-bay, but it was 1 kotoba, and i don't want my gohan (rice) to touch my other things (it can get wet and i would not like that, plus 2 compartments looks more kawaii)"
18:31:25 <mauke> but since when did #haskell and #haskell-blah switch places?
18:31:34 <kmc> #haskell-blah is #perl at the moment
18:32:02 <mauke> not really
18:32:15 <monochrom> well let's do perl here so we can do bento there
18:32:15 <geheimdienst> kmc: i feel this is a good time to broach the subject of the four hello kitty stickers on my lenovo t61, next to the keyboard
18:32:53 <monochrom> hello kitty! and 4 of them! that's kawaii
18:33:17 <gwern> we must code in perl in Iraq so we don't have to code in perl here
18:34:00 <geheimdienst> thanks :) the sticker that says "hello kitty" in friendly letters fit perfectly over "lenovo", so it says "hello kitty t61" now. i feel leet already
18:34:19 <geheimdienst> can't wait to hear what my badass hacker buddies will say
18:34:20 <monochrom> hahaha
18:34:32 <zomg> geheimdienst: I'm a badass hacker and I approve of your sticker
18:34:33 <zomg> =)
18:34:42 <geheimdienst> \o/
18:34:46 <monochrom> try to get "hello kitty inside" too
18:35:07 <zomg> I'm getting a "Warning! Vehicle transforms into robot" sticker to my car
18:35:11 <monochrom> (that gets dangerously close to "lolcats inside")
18:35:11 <zomg> Should be fun
18:35:30 <ddarius> Hello Kitty is mostly head.  There wouldn't be too much meat.
18:35:40 <geheimdienst> that would be nice ... i picture that as a hello kitty face with looking out of a hole, like the ceiling cat picture
18:35:43 <monochrom> ObTopic: also try to get "trapped in monads inside"
18:36:06 <shachaf> "inside a monad"
18:36:39 <ivanm> "Car Monad" ?
18:37:03 <monochrom> haha
18:37:20 <geheimdienst> "i'm a lesbian trapped in a man's body" ~ "i'm a pure computation trapped in an IO monad"
18:38:27 <kmc> in the grim future of hello kitty there is only war
18:39:14 <stepkut> my friend claims to be a lesbian trapped in a gay man's body
18:40:09 <geheimdienst> does not compute
18:42:37 <cch> hi guys, what would you recommend for a high level random utils of high quality ? Random in platform is too basic
18:43:22 <monochrom> and a bit slow too yes
18:43:41 <kmc> mwc-random
18:43:54 <pmetzger> http://www.likecool.com/Gear/Gadget/Hello%20Kitty%20AK-47/Hello-Kitty-AK-47.jpg
18:44:23 <luite> so who thinks he can defeat the mighty haskell tic-tac-toe engine? http://jabberwock.xs4all.nl/exp/jquery-console/
18:44:58 <luite> oh I should add that it doesn't work in IE
18:45:24 <monochrom> mwc-random has a faster better generator, but I wonder if its API is also too basic
18:45:49 <monochrom> I'm thinking random-extras has a wider API
18:46:04 <ivanm> luite: hey, why can't _I_ start!
18:46:38 <luite> ivanm: sorry, this was enough work ;p I don't really understand wumpus yet (which is used to render the SVG's), so everything is really low-level
18:47:05 <pmetzger> cryptographic pseudorandom vs. ordinary pseudorandom is always a question when people say "random"...
18:47:06 <ivanm> luite: what, it's too hard to let the user start rather than the computer
18:47:08 <ivanm> ?
18:47:31 <monochrom> few people need crypto
18:47:32 <ivanm> ummm..... did I accidentally crash everything?
18:47:33 <luite> ivanm: oh that would involve a bit more gui, or perhaps another tictactoe function, that would be easier
18:47:36 * ivanm whisltes innocently
18:47:48 <luite> ivanm: it's possible that you get a time limit exceeded
18:48:15 <ivanm> I hit reset and it all cleared.... though it seems that's a local thing; refreshing brought it all back *phew*
18:48:19 <luite> there are still some performance problems with the interpreter that I need to solve
18:48:54 <ivanm> so you did the worksheet stuff?
18:49:23 <luite> yes, I started yesterday to find out whether this would work better than the original terminal-like interface
18:49:25 <pmetzger> monochrom: I've seen people who needed crypto use libc's rand(3)
18:49:47 <ivanm> luite: are you aware of the Java-based Haskell worksheet stuff?
18:49:51 <pmetzger> monochrom: most users have no use for strong PRNGs but it always helps to ask...
18:50:30 <ivanm> luite: http://www.cs.kent.ac.uk/projects/pivotal/
18:50:33 <luite> ivanm: hmm, I think I might have heard of it, but haven't used it
18:51:36 <luite> ivanm: ah interesting
18:52:43 <cch> seems that random-extra is of higher level, thanks
18:53:45 <luite> ivanm: does that have its own haskell interpreter?
18:54:01 <c_wraith> seed quality is also often important in cases where crypto random isn't necessary.  seeding based on the time is horrible for any competitive multiplayer system, for instance
18:54:31 <ivanm> luite: not sure what it uses; never actually used it myself
18:54:47 <ivanm> ooohhh, pivotal is haskell-only; I thought it used Java for the GUI
18:55:10 <ivanm> luite: it uses ghci methinks
18:55:25 <ksf> why doesn't hackage use xz?
18:55:43 <luite> ivanm: but it doesn't really have the same goal as my app
18:56:01 <ivanm> ksf: because
18:56:05 <ivanm> ;-)
18:56:13 <ivanm> ksf: more seriouslly: it predates popular usage of xz
18:56:19 <luite> I really wanted something to demonstrate haskell or math related things online, without installation by the user
18:56:27 <ivanm> and on windows I don't think there are too many xz libraries, etc. available
18:56:30 <luite> sort of wolfram demonstrations + tryhaskell
18:56:33 <ivanm> (.gz is rare enough)
18:56:36 <ivanm> luite: *nod*
18:56:41 <ivanm> save-able documents?
18:56:59 <ivanm> luite: you might even be able to get the webkit bit from gtk2hs to make a stand-alone version
18:57:01 <ksf> well, as to that predate "argument", hackage should use bzip, then.
18:57:01 <luite> ivanm: dunno yet, it shouldn't be too hard
18:57:14 <ksf> also, who cares about windows.
18:57:21 <ivanm> ksf: I don't think bzip was that popular back then either
18:57:23 <luite> it's currently quite limited by the remote interpreter, which is stateless
18:57:23 <ksf> 7zip can deal with xz just fine, btw.
18:57:39 * ivanm was reading about gz vs bzip vs xz on an unrelated issue just recently
18:57:48 <ivanm> ksf: I still see a lot of people using winzip on windows...
18:57:51 <ivanm> :s
18:57:55 <luite> winzip really?
18:58:03 <ivanm> yup
18:58:06 <ksf> well, time to make them make the move.
18:58:10 <ivanm> despite a plethora of free alternatives
18:58:30 <ksf> also, name the files .txz instead of tar.xz to avoid confusion.
18:58:38 <ivanm> can someone explain to me the presence of the last comment here? http://www.reddit.com/r/haskell/comments/h5dyn/iterio_iterateebased_io_with_pipe_operators/
18:58:51 <ivanm> ksf: ugh, I hate it when people do things like that...
18:58:53 <elliott> <ivanm> (.gz is rare enough)
18:58:54 <elliott> really???
18:58:59 <elliott> 90 percent of code distributions are .gz
18:58:59 <gwern> I like 7z's high performance compression modes; really impressive on text
18:59:02 <elliott> .tar.gz that is
18:59:08 <ivanm> elliott: on windows
18:59:18 <ksf> was it winzip that was stupid enough to open a window with a single .tar in it when opening a .tar.gz?
18:59:28 <ksf> gwern, xz does the same.
18:59:29 <ivanm> a lot of them did that
18:59:31 <elliott> ivanm: oh
18:59:35 <gwern> true; I remember clicking on tar links and it opening in windows as some really weird thing
18:59:38 <elliott> well if i was targeting windows users i'd just use .zip
18:59:41 <elliott> unless the data is really ridiculously huge
18:59:48 <ivanm> elliott: we're talking about hackage here
18:59:49 <monochrom> 90% of compressed files are not gz
18:59:51 <elliott> ivanm: oh
19:00:04 <ksf> it's basically a sane directory-free format for lzma2 streams.
19:00:07 <elliott> ivanm: I'd just use .tar.gz, anything that can handle xz or bzip will handle it just as well
19:00:15 <elliott> and for text .gz will do about as well as anything else
19:00:27 <ksf> I thought .rar was all the rage on windows?
19:00:50 <ksf> elliott, bzip2 and xz both compress *vastly* better than gz
19:00:55 <ddarius> Why do we care what compression is used?
19:01:01 <pmetzger> vastly?
19:01:10 <ksf> between .gz and .xz is a difference like between .Z and .gz
19:01:14 <dolio> It's saving me dozens of bits!
19:01:38 <luite> ivanm: oh another reason that you can't start yourself is that the second move by the computer is too slow (the first move is hardcoded)
19:01:39 <monochrom> because "cabal update" downloads a huge file
19:01:41 <elliott> ksf: this is text, the compression hardly matters
19:01:48 <elliott> besides, bzip2 and xz are both very expensive to decompress
19:01:49 <elliott> as these things go
19:02:06 <luite> ivanm: I just took some tic-tac-toe package from hackage, and it's quite slow :)
19:02:15 <pmetzger> bzip2 can use unbounded resources on some files, that's true.
19:02:23 <ksf> xz is four times as fast at decompressing that bzip2
19:02:27 <pmetzger> one reason it isn't used in embedded systems much...
19:02:38 <pmetzger> or at least not in my experience.
19:03:19 <ksf> it's slower encoding, but that's not very relevant for a service like hackage.
19:03:36 <ksf> for on the fly http or something compression gzip is still the way to go.
19:04:04 <ksf> 46578138	37075679	29809336
19:04:13 <ksf> gzip, bzip2, lzma
19:04:20 <ksf> of the linux kernel.
19:04:25 <ksf> that's more than significant.
19:04:53 <gwern> 46m vs 29m I take it?
19:05:12 <ksf> 4.9		1.4		0.26
19:05:22 <ksf> mb/s compression
19:05:31 <ivanm> yeah, for my kernel I use gz for fast decompressions
19:05:32 <ksf> but you only do that once.
19:05:40 <ksf> 83		 6.2		33
19:05:45 <ksf> that's mb/s decompression.
19:06:20 <monochrom> yeah, gz is worth the tradeoff, lzma is worth the tradeoff too, what the hell is bz2 doing there?
19:06:25 <ksf> xz is highly assymetrical, there.
19:06:45 <ksf> legacy.
19:06:49 <pmetzger> gzip with what parameter?
19:06:57 <pmetzger> -5? -9?
19:07:01 <ksf> lzma was, so it seems, a result of blind hacking.
19:07:06 <ksf> -9
19:07:08 <ksf> all of them.
19:07:29 <ksf> 24		2.9		4.4
19:07:33 <ksf> that's encoding for -1
19:07:37 <ksf> http://tukaani.org/lzma/benchmarks.html
19:07:43 <ivanm> ksf: is blind hacking better or worse than infinite monkey hacking? ;-)
19:08:01 <ksf> (also note that xz is better than what they tested there)
19:08:18 <luite> does anyone here know a lot about hint? Is it possible to stay in the hint monad even if there's an error?
19:08:41 <gwern> luite: what kind of error?
19:08:54 <pmetzger> every file can always be made one bit shorter with a better compression algorithm. therefore, by induction, every file may be compressed to 1 bit.
19:09:00 <ksf> ivanm, well, it was a russian, as it seems.
19:09:11 <kmc> pmetzger, your logic is flawless
19:09:11 <luite> gwern: type error for example. I'm not sure if I use the correct way. in the current implementation I need to reload all modules in hint
19:09:15 <gwern> pmetzger: well, that's quite true
19:09:22 <luite> gwern: wait, I have the source somewhere
19:09:32 <ksf> not really.
19:09:40 <gwern> pmetzger: 'if firsbit == 0 then "hello world!" else gzip $file'
19:09:46 <Draconx> ksf, the biggest problem with xz is that it tends to require significant amounts of memory to decompress, which can be an obstacle.
19:09:49 <gwern> well, gunzip, I guess
19:09:51 <ksf> you can only compress to so many bits that you can still distinguish different inputs.
19:10:07 <ksf> on machines that compile haskell?
19:10:16 <ivanm> pmetzger: every bit of source code can be made one line shorter and has at least one bug
19:10:23 <luite> gwern: https://github.com/luite/hintservice/blob/master/src/HaskellInt.hs
19:10:28 <ivanm> ergo, all programs can be reduced to one line that is a bug
19:10:38 <pmetzger> every program can be reduced to a single line that's wrong! I always suspected!
19:10:52 <ivanm> gwern: is that the textual version of lenapeg?
19:10:54 <gwern> luite: which line throws the exception?
19:11:05 <ksf> Draconx, also, even xz -1 would be a win, even over gz -9
19:11:07 <gwern> ivanm: hello world! is canonical
19:11:19 <kmc> every program can be reduced to a single instruction which segfaults
19:11:20 <ksf> and that doesn't take significant amounts of memory.
19:12:27 <luite> gwern: if the evaluated expression is a type error, then the program exits the runInterpreter loop
19:13:04 <luite> gwern: it happens in evalExpr/seqResult, but that's just forcing the evaluation of the expression
19:13:18 <gwern> lemme look at my mueval code...
19:13:31 <Draconx> ksf, nevertheless, I'm all for supporting xz on hackage, if that's what this is about :)
19:13:57 <gwern>                                   -- we don't check if the expression typechecks
19:14:00 <gwern>                                   -- this way we get an "InterpreterError" we can display
19:14:04 <gwern>                                   etype <- typeOf expr
19:14:06 <gwern>                                   result <- eval expr
19:14:17 <ksf> Draconx, yep.
19:14:21 <luite> gwern: performance is quite important, so I need to keep the interpreter running as much as possible, reloading it takes a few seconds
19:14:36 <gwern> luite: ok, why not toss in a catch for typeOf?
19:14:59 <ksf> anyhow, we can just offer .gz and .xz, especially as transition.
19:15:17 <luite> gwern: dunno if that would work, but in any case I'd have no idea how to get the error message then
19:15:44 <gwern> luite: why are you getting the eval first and then the typeOf?
19:16:57 <luite> gwern: dunno really, but it doesn't matter I think. the problem is loading the modules, so the first requests takes very long, the rest is very fast (unless you evaluate something like sum [1..])
19:16:58 <Draconx> ksf, what hackage really needs more than xz, though, is signed packages...
19:17:17 <gwern> luite: what does module loading have to do with the type throwing an exception?
19:17:38 <ivanm> Draconx: and to shift the .cabal files outside of the tarballs (so you don't need to udpate the entire package just to loosen a dep)
19:17:50 <luite> gwern: the problem is that the exception is only caucht in mainLoop, and then hint needs to be restarted
19:18:00 <ksf> ivanm, no need to do that
19:18:10 <ksf> ...just use a system like portage
19:18:15 <cch> what is the defference between Random module and System.Random module, both in platform, which one should I use
19:18:18 <gwern> luite: why does the exception make you need to restart a hint instance?
19:18:21 <ksf> where you can override stuff package by package.
19:18:35 <ksf> /etc/portage/package.keywords etc.
19:18:54 <kmc> cch, use System.Random
19:19:08 <kmc> Random is the deprecated name
19:19:23 <kmc> from the Haskell 98 standard, which doesn't allow hierarchical module names
19:19:33 <Draconx> ivanm, then you'll need two signatures, though.
19:19:44 <cch> oh.. I see, thanks :)
19:20:32 <luite> gwern: hmm, I thought runInterpreter started a new interpreter with no modules loaded
19:20:48 <cch> so all modules in haskell98 package in platform are deprecated ?
19:21:48 <luite> I'll try a few things, maybe it's not necessary after all :)
19:22:05 <gwern> luite: have you looked into the mueval fork for tryhaskell?
19:22:11 <ddarius> Numeric never got a hierarchical name.
19:22:32 <luite> gwern: the one by chris done right? yes, but the problem is that I don't want the restrictions in the modules that can be loaded
19:22:36 <dolio> Numeric is the hierarchy!
19:22:53 <ivanm> Draconx: how do you get malicious code in a .cabal file?
19:22:56 <gwern> luite: the modules are just specified in a [String], doesn't seem like a big restriction...
19:23:10 <dolio> We need some Numeric.CReal.
19:23:13 <dolio> Numeric.Fixed.
19:23:44 <ksf> oh, btw, one *very* nice feature .xz shares with .7z is that it can use a different algorithm for each block.
19:24:32 <dons> cch: yeah, generally it is bad form to program in exactly H98, unless you intentionally choose to do that.
19:24:38 <luite> gwern: yes but there are some differences. I want to be able to load any module (no restrictions), and each new request should be able to specify new modules to be loaded
19:24:45 <Draconx> ivanm, I can't think of any ways off the top of my head, but that doesn't mean there aren't any.
19:25:09 <ivanm> dons: why bad form? do you mean deliberately not using extensions, etc.?
19:25:27 <ddarius> Well nowadays you should be coding in Haskell 2010.
19:25:38 <ivanm> Draconx: the only way I can think of is to tell it to use a malicious version of a library with the same module namespace
19:25:40 <dons> bad form to mix non-H98isms and H98 libs. usually means you don't know what you're doing
19:25:53 <dons> either you stick to 100% H98, or you use H2010
19:26:03 <ivanm> ddarius: except then you're limited to only ghc-7 support, rather than being able to do 6.8+ with base >=3 && < 5
19:26:06 <dons> so no import List; package-depends: base
19:26:08 <elliott> dons: what have you got against incoherent instances
19:26:11 <dons> since base isn't H98
19:26:17 * dolio programs in Haskell 2023.
19:26:17 <ivanm> dons: oh, right
19:26:19 <gwern> luite: again, doesn't sound too difficult. deal with a tuple like (String,[String]) where a is the expression and b is the list of modules. presumably you can map over the [String], ask whether it's already loaded and load it if it is not. ideally loading modules would be idempotent and then you could omit the check
19:26:27 <pmetzger> one should only code in intercal, really.
19:26:33 <dons> elliott: hmm? nothing. well, they're a bit dangerous.
19:26:36 <elliott> pmetzger: no no, definitely ///
19:26:40 <ivanm> dolio: so, what ended up happening with that unix epoch thing then?
19:26:44 <elliott> dons: i was joking on <dons> either you stick to 100% H98, or you use H2010  :)
19:26:50 <dons> heh
19:26:53 <dons> well, I use -XGHC
19:26:54 <elliott> pmetzger: (actual language)
19:26:57 <dolio> ivanm: 64 bits.
19:27:01 <elliott> dons: is that actually real?
19:27:01 <dons> and deal with the consequences
19:27:01 <pmetzger> intercal is an actual language!
19:27:05 <elliott> is it like -fglasgow-exts? :-D
19:27:07 <Draconx> ivanm, the most obvious attack vector would be by specifying malicious compiler flags.
19:27:09 <kmc> -fglasgow-exts 4 lyfe
19:27:10 <dons> elliott: its just whatever extensions are cool that I need.
19:27:21 <elliott> dons: heh
19:27:29 <ivanm> Draconx: how would that work?
19:27:31 <ddarius> Isn't -fglasgow-exts deprecated, maybe even completely removed.
19:27:34 <elliott> dons: -XEverything
19:27:34 <pmetzger> http://www.muppetlabs.com/~breadbox/intercal/
19:27:36 * dons gets some  -fglasgow-exts tshirts
19:27:38 <elliott> it just enables every extension it possibly can
19:27:44 <Draconx> ivanm, so one that comes to mind: turning on +RTS support on a program normally installed setuid-root.
19:27:47 <kmc> ghc -XMixfixOperators -XDependentTypes -XMakeMeASandwich
19:27:49 <elliott> pmetzger: http://esolangs.org/wiki/Slashes :-P
19:27:55 <dons> heh
19:28:04 <pmetzger> intercal is the only language that had "come from" until the creation of aspect oriented programming!
19:28:09 <elliott> is there a way to compile a program with fixed RTS flags?
19:28:13 <ivanm> Draconx: hmmmm.....
19:28:17 <elliott> it's a bit of an exploit for some things
19:28:18 <pmetzger> which should tell you everything you need to know about aspect oriented programming.
19:28:18 <Draconx> ivanm, another: defining macros in C programs with -D can insert arbitrary code into the program.
19:28:23 <ivanm> dons: isn't that deprecated though?
19:28:29 <kmc> elliott, ghc 7 defaults to not allowing RTS flags
19:28:31 <kmc> for that reason
19:28:32 <dons> elliott: yeah. check the rts users guide
19:28:35 <ivanm> Draconx: you can do that with just compile-time flags?
19:28:36 <elliott> pmetzger: COME FROM? oh please
19:28:36 <kmc> to bake in some flags you write a little C file
19:28:38 <dons> you can link in any flags you want
19:28:39 <elliott> dons: kmc: cool
19:28:40 <ivanm> doesn't that require extra code?
19:28:41 <gwern> Draconx: well, doesn't that require you to already have compromised code on the user's machine?
19:28:44 <monochrom> @remember kmc ghc -XMixfixOperators -XDependentTypes -XMakeMeASandwich
19:28:44 <lambdabot> I will remember.
19:28:45 <elliott> pmetzger: computed dual COME FROM is where it's at
19:28:56 <elliott> (COMING FROM a label twice is how you do threading in Threaded INTERCAL)
19:29:02 <Draconx> gwern, yes, we are talking about someone compromising a .cabal file in a package where everything but the .cabal file is signed.
19:29:02 <kmc> gwern, it's thinking like that which gives us return-oriented programming
19:29:04 <elliott> (and yes, computed COME FROM actually exists...)
19:29:05 <ivanm> kmc: so how do you do profiling then? i.e. +RTS -p
19:29:06 <pmetzger> elliott: neat!
19:29:11 <gwern> kmc: good point
19:29:18 <kmc> don't build your profiling binary with that option?
19:29:33 <kmc> turns out, the language whose only operations are suffixes of libc functions is turing complete
19:29:35 <elliott> pmetzger: there is also Quantum INTERCAL, Tri-INTERCAL (uses ternary), etc. etc. etc. :-)
19:29:39 * gwern gives up on all security and static guarantees and goes program in scheme
19:29:45 <ivanm> oh, I guess cabal would take care of that anyway?
19:29:52 <elliott> oh, of course, Backtracking INTERCAL too... I'll shut up now
19:30:04 <pmetzger> gwern: yessss. turn to the dark side, my student!
19:30:14 <ddarius> @google a security kernel based on the lambda calculus
19:30:15 <lambdabot> http://mumble.net/~jar/pubs/secureos/
19:30:15 <lambdabot> Title: JAR Security Kernel
19:30:59 <Draconx> ivan, think of something like (untested): CFLAGS="-Dmain='main(int argc, char **argv) { root_the_box(); return real_main(argc, argv); } int real_main'"
19:31:12 <Draconx> er, ivanm, ^^
19:31:35 <ivanm> huh; didn't realise you could do that
19:32:19 <gwern> ivanm: the most dangerous word in computer security - 'huh'
19:32:41 <elliott> :-)
19:32:47 <ivanm> heh
19:33:04 <elliott> writing things that are secure by design is tedious and boring
19:33:10 <elliott> hacking on security after-the-fact is pretty easy and rewarding
19:33:13 <elliott> the end
19:33:55 <Draconx> so yeah, the .cabal file most definitely needs to be signed.
19:34:01 <pmetzger> secure by design is hard when one doesn't know what secure requires though. :)
19:34:09 <pmetzger> which is why it is easier to give up in advance.
19:34:41 <pmetzger> that's why I have my password tattooed to my forehead. that way when I forget it others can tell me what it is.
19:35:14 <ivanm> @remember pmetzger I have my password tattooed to my forehead. that way when I forget it others can tell me what it is.
19:35:14 <lambdabot> Good to know.
19:35:29 <pmetzger> :)
19:35:36 <ivanm> pmetzger: I guess you aren't forced to change your password often then
19:35:37 <ivanm> ?
19:35:38 <pmetzger> hey, lambdabot is back!
19:35:38 <ivanm> ;-)
19:36:03 <pmetzger> ivanm: I avoid it, yes. how did you know?
19:36:06 <elliott> ?remember gwern the most dangerous word in computer security - 'huh'
19:36:06 <lambdabot> Done.
19:36:09 <elliott> while we're at it
19:36:18 <elliott> ivanm: other people change his password for him ;)
19:36:57 <geheimdienst> what is being attacked with CFLAGS="-Dmain=..."? if you're compiling stuff, clearly you can edit the source all you want, through defines or any other way ...?
19:37:30 <ivanm> geheimdienst: just changing the .cabal file without touching the source
19:37:42 <ksf> a definite *downside* of lzma is that the only complete description is the source code.
19:39:14 <pmetzger> ksf: but then there is the advantage that the implementation is perfectly consistent with the specification.
19:40:27 <gwern> a small advantage. there was just an announcement today of a major victory in wikipedia programming - a *second* parser for wikimarkup
19:41:16 <gwern> that's the sort of situation you find yourself in when the implementation is the specification...
19:41:20 * BMeph gives pmetzger a handy "PASS-ON! Apply directly to the forehead" kit; have fun! ;þ
19:42:12 <gwern> http://dirkriehle.com/2011/05/01/the-parser-that-cracked-the-mediawiki-code/ mentions why implementation=specification was bad for wikipedia, btw
19:42:59 <pmetzger> an implementation that is identical to the specification has another advantage: there are provably no implementation errors!
19:43:36 <pmetzger> any perceived errors are merely misunderstanding of the specification.
19:45:07 <elliott> it would be cool if languages were specified as literate executable formal semantics
19:45:22 <elliott> with every example as a doctest-type thing
19:45:42 * hackagebot yesod-comments 0.3.1 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.3.1 (PatrickBrisbin)
19:47:13 <ivanm> elliott: there is a doctest-like package on hackage...
19:47:20 <elliott> ivanm: I was just thinking :)
19:51:35 <luite> gwern: ugh found a problem with my test code, catching the InterPretererror does work fine after all...
19:51:51 <gwern> -_-
19:55:49 <Axman6> hmm, so there was a lot of support last night for suggesting that the names in the iterIO package be changed from Iter/Onum/Inum to Consumer/Producer/Transformer, but there's nearly no support on the mailing list for the same idea. the names Source and Sink have been suggested, but I don't think they're quite as clear as the idea Peaker has last night...
19:56:12 <elliott> Onum/Inum are pretty ugly names imo
19:56:26 <monochrom> Onom? Inom?
19:56:39 <djahandarie> I like them for the exact reasoning he gave.
19:56:48 <elliott> Onomnomnom.
19:56:48 <jmcarthur> Omnomnomnom
19:56:50 <jmcarthur> dangit
19:56:52 <elliott> ha
19:57:09 <dons> Axman6: i thought it was obvious. i plan to write a review of the package over the weekend though
19:57:12 <dolio> Can there be a COOOKIIIEEEE type?
19:57:18 <dons> Axman6: just chill out for a while, and let people go over  the code
19:57:33 <dons> or do your own review :)
19:57:58 <monochrom> Axman6: how many hours ago was "last night"? I want to find it in my logs
19:58:00 <Axman6> i'd like to play with so, so maybe that's not a bad idea
19:58:08 <Axman6> monochrom: about 9 or so
19:58:27 <djahandarie> monochrom, just grepping those names would probably sufice
19:58:35 <djahandarie> suffice*
19:58:36 <dons> Axman6: write some programs with it.
19:58:41 <dons> i haven't seen any benchmarks yet
19:58:53 <Axman6> would give me a good excuse to update my blog for the first time in over a year -_-
19:58:58 <dons> so that would be good (e.g. benchmark against strict and lazy bytestrings, and against iteratees/enumerators)
19:59:07 <dons> you could rewrite a lot of the bytestring benchmarks
19:59:08 <Axman6> might try rewriting my tee implementation using it
20:00:16 <monochrom> 12 hours ago
20:00:33 <djahandarie> I've had a lot of excuses to update my blog, but no actual motivation to follow through...
20:00:59 <Axman6> i haven't written enough haskell lately, spent too much time on these assignments in C
20:04:46 <gwern> 'An interesting potential use of GPU-accelerated graph analysis is for in-kernel garbage collection (GC). GC is usually considered to be time- consuming because of its graph traversal operation, but a recent patent application [15] shows it is possible to do the GC on GPUs, and that it may have better performance than on CPUs. Besides GC for memory objects, filesys- tems also use GC-like operations to reorganize blocks, find dead links, and check ...
20:04:52 <gwern> ... unreferenced blocks for con- sistency. Another example of graph analysis in the kernel is the Featherstitch [7] system, which exposes the depen- dencies among writes in a reliable filesystem. One of the most expensive parts of Featherstich is analysis of de- pendencies in its patch graph, a task we believe could be done efficiently on the GPU. '
20:06:25 <Axman6> BFS on GPU's is quite simple and obvious
20:07:06 <pmetzger> gwern: that's weird. I mean, the main performance barrier in garbage collection is memory latency I think...
20:07:12 <Axman6> which i guess is one way of doing GC...
20:07:41 <pmetzger> gwern: and anyway, the main practical irritant is the lack of hardware read/write barriers in modern processors. :(
20:08:15 <pmetzger> and compacting a file system is again mostly disk latency....
20:08:24 <pmetzger> by orders of magnitude in fact...
20:08:51 <Axman6> isn't a lot of the FS information kept in memory anyway?
20:09:36 <pmetzger> FS performance depends on memory caching, but on a 1TB fs if you have, say 8G of memory not much is in cache no.
20:09:52 <pmetzger> hopefully the most frequently used bits of course. :)
20:10:36 <luite> gwern: oh by the way, do you know if it's possible with hint, if you have in your source code a top level value: v = unsafePerformIO something, to make it execute the IO action agian when evaluating another expression?
20:10:50 <elliott> gwern: that's awesome
20:11:35 <dolio> {-# INLINE v #-}?
20:11:44 <luite> gwern: (I realize that this might be the cause of a less than elegegant design ;p )
20:11:51 <luite> err caused by
20:11:56 <luite> and elegant
20:12:04 <luite> bah I've been staring at this screen for way too long
20:12:19 <dolio> You can also do 'v () = ...'
20:12:57 <luite> hmm, I'll try inline first
20:13:14 <dolio> Inlining is of course not guaranteed to work.
20:13:46 <monochrom> does your "another expression" force v? you need that at least
20:14:19 <monochrom> (no reason why "1+2" triggers v's action. no reason why "const 0 v" does either)
20:14:31 <luite> dolio: the problem v () is that the type of the expression is different. it's for the website I showed earlier. v could for example be someImage, where the unsafePerformIO action writes the image to disk in the background, and the "pure" value contains just the url to the image
20:14:58 <luite> the image will be the same for the next request, but the filename (and the url) will not
20:15:22 <luite> so it's somewhat pure but not quite, but the IO action needs to be executed again to get the new URL
20:15:47 <luite> (the old url will stop working after a while, because the images are removed from the disk after a while)
20:16:23 <elliott> "v could for example be someImage, where the unsafePerformIO action writes the image to disk in the background, and the "pure" value contains just the url to the image"
20:16:25 <elliott> eww.
20:16:30 <elliott> that's my opinino
20:16:32 <elliott> opinion.
20:17:22 <monochrom> I am confused. if the url changes, and if v gives the url at the end, why is the url pure?
20:18:46 <luite> monochrom: for certain values of pure :) the url will be different, but usually the contents of the image are the same
20:19:13 <monochrom> the type of v is... content of image?
20:20:10 <luite> no the URL :) so it really isn't that pure
20:20:41 <monochrom> then it seems simplest to go all out and "v :: IO URL"
20:20:58 <luite> monochrom: users cannot execute IO actions
20:21:57 <monochrom> then ok, unsafePerformIO and either INLINE or NOINLINE, I don't know which one
20:22:28 <monochrom> and then, if that works, congrats; if that doesn't work, that route is a dead end
20:23:47 <monochrom> but a more certain alternative is to newtype UserIO a = UserIO (IO a) and support safe and necessary actions for UserIO, then v :: UserIO URL
20:25:00 <cch> bytestring package's haddoc on hackage says ByteString is a instnace of IsString, while ghci complained it is not one. see https://gist.github.com/960173
20:25:49 <thoughtpolice> cch: you need to import the 'Char8' variants
20:25:59 <thoughtpolice> those are the ones that have the IsString instance properly exported
20:26:43 <luite> monochrom: hmm, I'll see how far I can get with that approach, but after some sleep :) thanks for the suggestion
20:28:55 <cch> thoughtpolice: but it can be compiled using source file without importing 'Char8'
20:30:20 <monochrom> I'm pretty sure "using source file" you're forced to import
20:30:45 <monochrom> so it is not so much "but" than "indeed"
20:30:55 <cch> in source file there are lines : "import qualified Data.ByteString.Lazy as L
20:30:55 <cch> import qualified  Data.ByteString as S"
20:31:06 <monochrom> oh sorry, you are not importing the Char8 one
20:31:35 <monochrom> well but you do import something.
20:31:59 <cch> monochrom: yes, I import Bytestring, but no ByteString.Char8
20:32:08 <monochrom> :m + Data.ByteString.Lazy  will make a difference and be a truly fair comparison
20:33:52 <monochrom> :m + Data.ByteString  since you're testing that
20:34:25 <cch> monochrom: both with same effect, see https://gist.github.com/960177
20:34:28 <monochrom> I see, that doesn't bring in the instance either
20:34:41 <cch> monochrom: i think so
20:39:24 <monochrom> no, using a source file, I import Data.ByteString.Lazy and Data.ByteString (as S), define g = S.unpack "a", turn on -XOverloadedStrings, it does not compile, same no-instance error
20:42:29 <Axman6> :t BS.unpack
20:42:30 <lambdabot> BSC.ByteString -> [Word8]
20:45:38 <cch> monochrom: there are some other imports in my source file
20:45:54 <cch> which I don't think to be relevant
20:46:15 <gwern> luite: I don't know. hint is a wrapper around ghc api of course and ghc api is basically desugared ghci, so I would try whatever you want to do in ghci, and compare against the same function defined in a source file eg with the INLINE pragmas
20:46:24 <monochrom> you could systematically test which import is relevant
20:47:21 <cch> monochrom: I find that one! it is Network.HaskellNet.SMTP
20:47:30 <cch> rediculous
20:48:35 <cch> monochrom: Char8 is imported in HaskellNet.SMTP. is this the reson?
20:48:54 <monochrom> some kind of transitively import, but basically yes
20:50:23 <luite> gwern: yeah I'll try tomorrow or when I have time. otherwise monochroms suggestion of using a restricted IO type instead of unsafePerformIO could work
20:50:46 <cch> but is there anyway to find out which module should be imported to get some instance declaration. Haddock seems not to be able to do that
20:51:05 <bbrown_win4> general question, is there a difference between testing for correctness of code and say a unit test that tests a particular scenario
20:51:23 <mietek> (intercalate ", " . map return)
20:51:31 <mietek> Any nicer ways to write this?
20:53:08 <cch> :t intercalate
20:53:09 <lambdabot> forall a. [a] -> [[a]] -> [a]
20:53:40 <monochrom> cch: here is my method. you have a source file that imports mysterious modules and one of them indirectly brings in the instance. ok, load your source file into ghci. now ask either ":info IsString" or ":info Data.ByteString". it will tell you stuff, and somewhere it says which precise module has the instance
20:53:45 <monqy> :t intersperse
20:53:45 <lambdabot> forall a. a -> [a] -> [a]
20:54:08 <mietek> :t (intercalate ", " . map return)
20:54:09 <lambdabot> [Char] -> [Char]
20:54:15 <Axman6> mietek: intercallate ", " . map (:"")? seems a little clearer you're taking a list of characters and turning them into strings, to me anyway
20:54:35 <Axman6> > intercalate ", " . map (:"") $ "hello"
20:54:38 <lambdabot>   mueval-core: Time limit exceeded
20:54:43 <Axman6> o.O
20:54:44 <Axman6> > intercalate ", " . map (:"") $ "hello"
20:54:46 <lambdabot>   "h, e, l, l, o"
20:55:03 <mietek> @pl (:"")
20:55:03 <lambdabot> return
20:55:51 <dons> always use (:[])
20:56:03 <dons> robot monkey forever.
20:56:06 <mietek> Because it looks like a robot?
20:56:11 <mietek> Aha.
20:56:29 <Jafet> @hoogle (:-)
20:56:29 <lambdabot> No results found
20:56:35 <ion> @hoogle Integer -> m a -> m b
20:56:35 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
20:56:35 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
20:56:36 <lambdabot> Data.List scanr :: (a -> b -> b) -> b -> [a] -> [b]
20:57:11 <cch> monochrom: thanks, this method really works, great :)
21:38:06 * KirinDave sighs
21:38:09 <KirinDave> Man this code is so ugly.
21:38:25 <KirinDave> That whole thing about having taste, and how it's a curse when you're a novice at something
21:38:35 <KirinDave> It's so true. I know this code is hideous, but I'm not sure how to clean it up.
21:39:17 <djahandarie> Run it through hlint. Then run it through #haskell :)
21:40:07 <kmc_> ghc -fvia-dons
21:40:09 <Jafet> Don't go changin' / to try and please me
21:41:14 <KirinDave> Hah
21:41:23 <KirinDave> Goes directly to dons's mailbox
21:41:25 <KirinDave> https://github.com/KirinDave/Rag/blob/master/rag/Main.hs
21:42:10 <KirinDave> It just goes on and on.
21:42:13 <kmc_> any particular points of concern?
21:42:34 <KirinDave> I wonder if I should be using a state monad for the gamestate rather than coming up for air
21:42:55 <KirinDave> But i suspect if i did that I'd have to drag the IO monad down with me, which obviates the need for writer in the first place.
21:43:12 <kmc_> sometimes explicit state-passing is clearer
21:43:14 <KirinDave> I also don't like the matches on handleOutcome (really, handleOutcome turned out much worse than I hoped)
21:43:23 <dmwit> do { s <- ask; return (f s) } === asks f
21:43:49 <kmc_> what's going at "let newRoom = fromJust ..."?
21:43:56 <kmc_> fromJust is a red flag
21:43:59 <KirinDave> I need to check in the IntMap
21:44:10 <KirinDave> To see if that room exists. If it doesn't exist, I use my void room.
21:44:22 <kmc_> oh
21:44:23 <kmc_> :t maybe
21:44:24 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:44:25 <kmc_> :t fromMaybe
21:44:26 <lambdabot> forall a. a -> Maybe a -> a
21:44:31 <kmc_> probably use one of those instead
21:44:48 <kmc_> fromMaybe defaultRoomDefinition (Map.lookup dest maze)
21:45:26 <KirinDave> Ahh
21:45:49 <Jafet> Why not design it so that every destination room is valid
21:46:56 <KirinDave> Jafet: Well
21:47:00 <KirinDave> Jafet: because the file might lie.
21:47:20 <dmwit> I find it odd that you have both a "case command of ..." and a "doCmd" function.
21:47:40 <KirinDave> dmwit: I do too. I kinda got impatient mucking with it
21:47:40 <dmwit> I also find it odd that you repeatedly run a Writer action in a loop.
21:47:55 <KirinDave> dmwit: Should I drag the IO monad down into my game loop?
21:48:00 <dmwit> You could do lazy IO to feed the Writer the entire input and lazily print its responses.
21:48:04 <dmwit> That would make more sense to me.
21:48:08 <dmwit> KirinDave: No, of course not.
21:48:18 <KirinDave> So how do I bring the output back up
21:48:21 <dmwit> The whole point of the Writer monad is that it returns its tells lazily.
21:48:44 <KirinDave> No one told me that. :)
21:48:58 <dmwit> main = do { s <- getContents; mapM_ putStrLn (runWriter mainLoop s) }
21:49:05 <dmwit> :t runWriter
21:49:06 <lambdabot> forall w a. Writer w a -> (a, w)
21:49:26 <Jafet> I would build this from the maze description: data Room = Room { doors :: [(Direction, Room)], etc }
21:49:33 <dmwit> Okay, mapM_ putStrLn (fst (runWriter mainLoop s)), then.
21:49:49 <KirinDave> jafet: Well, https://github.com/KirinDave/Rag/blob/master/examples/micro.rag
21:49:56 <Jafet> Er, Map Direction Room
21:50:26 <KirinDave> Jafet: The set of directions and actions is not finite. :)
21:50:41 <dmwit> That's a tricky knot to tie, what with Map's spine-strictness and all.
21:50:48 <Jafet> The file is finite...
21:51:15 <KirinDave> Jafet: Right.
21:51:32 <KirinDave> Jafet: I'm of the opinion that if the file is wrong, I shouldn't fix it. The void room is just a nice way to say, 'You done goofed.'
21:51:42 <KirinDave> It's how the original program I am using handled the problem.
21:51:56 <KirinDave> Jafet: Like what if they say exit "whee" goes to room 9999
21:52:38 <KirinDave> Oh, I had a real question.
21:52:52 <KirinDave> https://github.com/KirinDave/Rag/blob/master/rag/parser.hs
21:53:04 <KirinDave> If I have any trailing newlines, ragFile fails.
21:53:06 <Jafet> Mm, so that looks like a (Direction -> Room)
21:53:09 <KirinDave> And I haven't been able to figure out how to fix it.
21:53:25 <KirinDave> Jafet: Well it'd be Direction -> Room -> Room
21:54:13 <Jafet> But only two rooms are involved: the current and the destination.
21:54:43 <KirinDave> Right, so you'd need to provide a direction, and a room, and then it'd yield a new room.
21:54:54 <KirinDave> Or maybe I'm misunderstanding what you're saying.
21:55:41 <Jafet> Oh, you can also build a function of that type, but it wouldn't be very useful. I was giving a type for `doors' (which probably should be called `actions')
21:56:06 <KirinDave> Oh.
21:56:11 <Jafet> Have you considered... reading many newline before eof?
21:56:42 <dmwit> KirinDave: I wrote an example for you, if you're interested. =) http://hpaste.org/46451/lazy_io__writer_example
21:57:09 <Jafet> Actually, if each line ends in a newline, rather than being delimited by newlines, you should change the ragLine parser.
21:57:27 <KirinDave> Jafet: To pull many1 newlines in ragLine?
21:57:41 <KirinDave> Jafet: The last line need not be terminated by a newline
21:58:49 <dmwit> KirinDave: You might consider using "sepEndBy" instead of "sepBy".
21:58:59 <KirinDave> :t sepEndBy
21:59:00 <lambdabot> Not in scope: `sepEndBy'
21:59:03 <KirinDave> doh
21:59:14 <dmwit> sepEndBy has the same type as sepBy.
21:59:53 <KirinDave> yeah perfect
21:59:57 <KirinDave> The problem was in sepBy
21:59:59 <KirinDave> Not after it.
22:00:12 <Jafet> By the way, you could still add a void Room, and link all dangling references there. It's a design choice.
22:00:43 <KirinDave> Jafet: You might have noticed I'm new to haskell
22:00:52 <KirinDave> So I'm not sure how I'd do that within the context of the parser.
22:02:08 <KirinDave> dmwit: i'll switch to using lazy io. I can see how I'd do that.
22:02:23 <KirinDave> dmwit: Although I'd obviously need to modify the parameters a bunch.
22:02:51 <dmwit> I think you wouldn't have to change much.
22:02:57 <KirinDave> dmwit: Nope.
22:02:57 <dmwit> Just use runWriter less. =)
22:03:08 <NemesisD> is [] a type/
22:03:18 <dmwit> No.
22:03:21 <kmc_> it's a type constructor
22:03:22 <epdtry> NemesisD: no, it's a type constructor
22:03:23 <kmc_> :k [] Int
22:03:24 <NemesisD> i'm getting an error "Couldn't match type result with []"
22:03:24 <dmwit> [] is a 1-ary type constructor.
22:03:24 <lambdabot> *
22:03:34 <shachaf> Is "[] a" type?
22:03:41 <KirinDave> dmwit: I don't get how your mainloop ever gets the lines back from runWriter.
22:03:48 <dmwit> shachaf: In H98, yes...
22:03:56 <KirinDave> dmwit: nevermind, I do.
22:04:08 <NemesisD> i'm probably misunderstanding the error
22:04:19 <dmwit> Why don't you paste the exact error.
22:04:30 <shachaf> dmwit: And not in H10?
22:04:31 <dmwit> Bonus points for posting the code that caused it online somewhere and linking us to it.
22:04:40 * shachaf fails to succeed at misinterpretation.
22:04:47 <dmwit> =)
22:05:08 <KirinDave> Jafet: I'd owe you almost 3 whole silver florins if you could illustrate with code how I would put your idea into practice.
22:05:30 <NemesisD> http://hpaste.org/46452/result_and
22:06:36 <Saizan> NemesisD: error ("Unexpected Code: " ++ show code)
22:07:14 <NemesisD> doh
22:07:34 <NemesisD> good call
22:07:52 <Saizan> not sure if that's all
22:08:57 <NemesisD> that fixed that, other stuff breaks
22:08:59 <dmwit> ?wiki Tying the Knot
22:08:59 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
22:09:13 <dmwit> KirinDave: ^ Jafet's idea put into practice for other problems
22:09:26 <NemesisD> i'm gonna look into it, i'm probably not being explicit enough about a type somewhere
22:09:45 <KirinDave> dmwit: The problem is how to mix that up with a parser.
22:09:51 <Mathnerd314> when is GHC getting kind polymorphism?
22:11:02 <Jafet> Okay, I have no idea how to tie a knot with that kind of data structure. The best you could do is a zipper, but I don't know if you can make that sufficiently lazy either.
22:11:35 <KirinDave> Jafet: I thought about it, but I could never come up with a LAZY version.
22:14:57 <djahandarie> Mathnerd314, should happen with the typekind stuff byorgey is working on, I think
22:15:06 <djahandarie> But I'm not sure how that's coming along :)
22:21:10 <KirinDave> Jafet: Maybe if I took your idea of making the edges into functions, and they take a MazeDefinition -> Room
22:25:50 <KirinDave> dmwit: Btw, I found a very good reason not to use lazy IO for that tho
22:26:06 <KirinDave> dmwit: http://hackage.haskell.org/packages/archive/readline/1.0.1.0/doc/html/System-Console-Readline.html
22:29:44 <Mathnerd314> djahandarie: seems IMO like it should have landed by now if it wasn't vaporware. but I'll let byorgey say for himself.
22:31:55 <nyingen> @quote
22:31:55 <lambdabot> DrMoreau says: I like big bots and I can not lie
22:32:05 <monochrom> hahaha
22:34:06 * hackagebot stm-chans 1.2.0 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-1.2.0 (WrenThornton)
22:35:57 <nyingen> one good quote deserves another
22:35:58 <nyingen> @quote
22:35:58 <lambdabot> Veinor says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
22:39:10 <kmc_> funroll > funbox
22:41:42 <sully> @pl 0 : 1 : zipWi­th (+) fibs (tl fibs)
22:41:42 <lambdabot> (line 1, column 15):
22:41:42 <lambdabot> unexpected "\173"
22:41:42 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++", "<+>" or end of input
22:41:49 <sully> argh, paste fail
22:42:04 <sully> @pl 0 : 1 : zipWith (+) fibs (tl fibs)
22:42:04 <lambdabot> 0 : 1 : zipWith (+) fibs (tl fibs)
22:42:13 <sully> er, hrm.
22:42:30 <djahandarie> There aren't any lambdas in that expression to get rid of
22:42:37 <Saizan> @pl fibs = 0 : 1 : zipWith (+) fibs (tl fibs)
22:42:37 <lambdabot> fibs = fix ((0 :) . (1 :) . ap (zipWith (+)) tl)
22:47:10 <Nereid> @pl fibs = 0 : scanl (+) 1 fibs
22:47:10 <lambdabot> fibs = fix ((0 :) . scanl (+) 1)
22:47:15 <Nereid> > let fibs = 0 : scanl (+) 1 fibs in fibs
22:47:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:47:22 <Nereid> oh good, I did get it right.
22:49:31 <dankna> hmm
22:49:34 <dankna> has anybody done this before
22:50:01 <dankna> I am compiling my Haskell code as a library and invoking it from an Objective-C main()
22:50:11 <dankna> but I want to pass some RTS options
22:50:26 <dankna> hs_init() of course takes these
22:50:36 <dankna> but it tells me I didn't link with -rtsopts
22:50:45 <dankna> well, yeah - ghc didn't do the linking
22:50:55 <dankna> clang did :/
22:51:06 <dmwit> > fix ((0:) . scanl (+) 1)
22:51:06 <dankna> because that's what Apple uses and I kinda need to make XCode happy
22:51:07 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:51:45 <dankna> it looks like it might be the case that the -rtsopts link-time flag includes an extra symbol or something, so that the status of that will be available to the runtime library
22:51:54 <dankna> but I haven't yet found the code that does that
22:52:19 <dankna> I can probably find it given another few hours (sigh), but I thought I'd ask here in case anyone has run into this
22:52:40 <dankna> the usage scenario is that I want to turn on heap profiling because my code eats 2G of real memory within a matter of seconds
22:52:49 <dankna> I know why it does that but I want to be systematic about this :)
22:52:51 <dmwit> KirinDave: Yeah. It can still be done, but it's... a bit trickier.
22:52:56 <dmwit> Maybe not worth the effort. =)
22:54:15 <Saizan> dankna: for profiling you've to link to a specific rts i think
22:54:25 <dankna> Saizan: that's partially correct
22:54:38 <Saizan> are you already doing that?
22:54:41 <dankna> I already dealt with making sure that I'm linking against *_p.a instead of *.a
22:55:11 <dankna> for every single library, which all need to be enumerated explicitly in XCode's EXTRA_LDFLAGS variable because that's the only way to conditionalize it properly
22:55:27 <dankna> took me a while to come up with that solution, heh, but that part is definitely working, I checked
22:55:38 <dankna> but all that does is make sure the profiling hooks are in place
22:55:41 <dankna> it doesn't actually enable them
22:55:54 <dankna> for that you need to do +RTS -h* for some * that specifies how to organize the data
22:56:13 <Saizan> but are you linking with libHSrts_p.a or libHSrts.a ?
22:56:16 <dankna> and when I do that, I get a message saying I needed to pass -rtsopts when I linked, to explicitly turn that behavior on
22:56:25 <dankna> libHRrts_thread_p.a, actually
22:56:31 <dankna> also libHSbase_p.a and so on
22:56:59 <dankna> happily, I've done this before in programs that consisted only of Haskell code, so I already have the whole world compiled both ways
22:57:18 <Saizan> ok, i thought libHSrts_*_p.a would have -rtsopts enabled by default, that's all
22:57:28 <dankna> yeah, good thought, but it doesn't
22:57:30 <NihilistDandy> Oh, good, lambdabot's back
22:57:31 <NemesisD> return types can't be polymorphic if the type variable isn't used anywhere else in the fuction right?
22:57:35 <dankna> I agree with the decision that it shouldn't, actually
22:57:44 <kmc_> they can NemesisD
22:57:49 <dankna> NemesisD: certainly they can.  consider undefined :: a.
22:57:53 <kmc_> it can resolve the type based on what the caller wants
22:58:06 <NemesisD> hmm
22:58:08 <kmc_> type information flows both forward and backwards in time, where "time" is defined by runtime evaluation order
22:58:28 <kmc_> type inference is a compile time constraint-solving procedure
22:58:32 <Saizan> though a polymorphic return type doesn't mean the function can return any type it wants
22:58:43 <NemesisD> hmm
22:58:46 <Saizan> it rather must be able to produce any type the _caller_ might want
22:58:48 <kmc_> indeed, it means the function is *obliged* to return any type the *caller* wants
23:00:29 <NemesisD> hmm, must be doing something wrong, ghc complains "Could not deduce (r ~ Result a0)
23:01:24 <dankna> whoa
23:01:39 <dankna> mkExtraObjToLinkIntoBinary :: DynFlags -> [PackageId] -> IO FilePath
23:01:46 <dankna> suggestive function name, isn't it
23:02:12 <NemesisD> http://hpaste.org/46453/cannot_deduce_type
23:02:14 <dankna> this appears to be the mechanism by which the -rtsopts link-time flag is passed to the RTS
23:02:47 <dankna> sooooo I wonder what would happen if I generated a similar file of my own, haha
23:02:49 <kmc_> there's an -rtsopts link-time flag?
23:02:54 <kmc_> sounds super useful
23:03:06 <dankna> kmc_: it's /only/ a link-time flag, it is silently ignored at compile-time
23:03:14 <dankna> took me a while to realize that
23:03:25 <kmc_> oh, new in GHC 7
23:03:26 <dcoutts> aye, what would it mean at compile time?
23:03:53 <dcoutts> what if you compiled one module with one set of rts opts, and another module with different rtsopts
23:03:54 <dankna> dcoutts: yes, it's clear to me now that I've thought it through.  I thought it might be like profiling in that every module has to be compiled with it.
23:04:48 <NihilistDandy> Had to build mueval with -rtsopts or my lambdabot wouldn't work :D
23:04:53 <dankna> nodnod
23:06:24 <dankna> what I don't understand then
23:06:39 <dcoutts> dankna, kmc_: oh and it's -with-rtsopts you're thinking of
23:06:47 <dankna> is why the link succeeds when I haven't done anything to provide the symbol rtsOptsEnabled
23:06:54 <dankna> dcoutts: wait - there's a difference?
23:07:10 * hackagebot stm-chans 1.2.0.1 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-1.2.0.1 (WrenThornton)
23:07:18 <dcoutts> -rtsopts enables +RTS processing
23:07:30 <dcoutts> -with-rtsopts bakes some RTS options into thebinary
23:07:40 <dankna> oh - I see.
23:07:44 <dankna> no, I was thinking of -rtsopts
23:07:57 <NihilistDandy> dcoutts: Hmm. That's an interesting distinction
23:07:58 <dankna> because I'm running as a library called from C, I have an init function that calls hs_init()
23:08:15 <dankna> but it calls them on my chosen flags and not on the actual flags (which, since this is a GUI program, would be meaningless anyway)
23:08:23 <Saizan> NihilistDandy: what's the type of fromJSON?
23:08:35 <NihilistDandy> :t fromJSON
23:08:35 <lambdabot> Not in scope: `fromJSON'
23:08:37 <NihilistDandy> No clue
23:08:51 <Saizan> ask your ghci
23:09:26 <NihilistDandy> Saizan: fromJSON :: Data a => JSValue -> Result a
23:09:40 <NihilistDandy> At least in Text.JSON.Generic
23:09:57 <Saizan> NihilistDandy: so can't be 'r'
23:10:13 <dcoutts> dankna: so as I understand it, -rtsopts works by providing an .o file that defines the rtsOptsEnabled symbol
23:10:21 <Saizan> if you change your signature readResult :: (FromJSON r) => Either CurlCode T.Text -> Result r
23:10:27 <Saizan> it should work
23:11:24 <dankna> dcoutts: yeah, that's what I've just determined.  which means I can override it, I hope, by providing my own version of that, since I'm not going through ghc's linker anyway so I don't have to worry about it interfering.  what I'm wondering now, although I suppose it doesn't matter, is how my link ever succeeded, when I was not linking anything that provided that symbol.
23:11:28 <NihilistDandy> On another note, where did the discussion about JSON come from? :D
23:11:47 <Saizan> NihilistDandy: sorry, i confused you with NemesisD
23:11:50 <NihilistDandy> lol
23:11:54 <NihilistDandy> Well, that's okay
23:11:58 <dcoutts> dankna: because there's a default definition in the rts
23:12:21 <Saizan> NemesisD: the above was for you, if you change your signature to readResult :: (FromJSON r) => Either CurlCode T.Text -> Result r then it'll typecheck
23:12:37 <NihilistDandy> Saizan: At least I can still deal with Haskell when I'm vodka/girl drunk :D
23:12:59 <dankna> dcoutts: weak linking or something?
23:13:04 <NihilistDandy> It's a good thing to know about myself
23:13:10 <dcoutts> dankna: no, ordinary static linking
23:13:37 <dankna> I didn't realize object files could provide defaults in that fashion
23:14:21 <dankna> well, clearly they can :)
23:14:53 <dcoutts> dankna: it's a corollary of the linker namespace being flat
23:15:02 <dankna> oh!  right, that makes sense
23:15:05 <dcoutts> so given duplicate symbols, it picks one
23:15:11 <dcoutts> based on the link order
23:15:15 <dankna> gotcha
23:15:44 <dmwit> I'll admit that I never really understood namespaces.
23:15:53 <dmwit> What's the difference between a namespace and just a longer name?
23:17:14 <kmc_> sugar
23:17:22 <dmwit> I guess opening a namespace and renaming a namespace... yeah, sugar.
23:17:26 <kmc_> such as "entering" a namespace or renaming it locally
23:17:33 <ClaudiusMaximus> less characters to type in your code i guess, maybe some privacy enforcement is possible too ("this is *my* namespace, keep out")
23:17:47 <NihilistDandy> No. Mine.
23:17:57 <kmc_> compiling a language with namespaces through an ordinary linker involves mangling those names back to long flat names
23:17:58 <dmwit> I have control of every bit on my computer. If I want in your namespace, you can't stop me.
23:18:14 <kmc_> preflex, zenc base-4.0:Data.List.nub
23:18:14 <preflex>  basezm4zi0ZCDataziListzinub
23:18:36 <NihilistDandy> dmwit: Challenge accepted :D
23:18:39 <NihilistDandy> But no.
23:35:06 <ddarius> With a longer name you only have one option, with a namespace you can qualify it differently.  Admittedly, Haskell's namespaces are flat despite the notation, so you don't get any hierarchical benefits like, say, C# namespaces.
23:36:00 <Eduard_Munteanu> What's a nice Haskell C parser?
23:36:38 <djahandarie> language-c?
23:36:43 <djahandarie> Or do you want a Haskell parser in C?
23:36:52 <Eduard_Munteanu> Thanks, I'll have a look.
23:36:58 <Eduard_Munteanu> No, I want it to parse C.
23:39:34 <dankna> hmm
23:39:40 <dankna> cabal is complaining that I can't pass it --ghc-prof-options
23:39:58 <dankna> perhaps I have to have XCode invoke cabal twice, once for regular and once for profiling
23:40:38 <dcoutts> dankna: on the command line, --$PROG-options passes options to $PROG
23:40:52 <dcoutts> there is no ghc-prof program, there's just a ghc program
23:41:04 <dankna> yeah.  so --ghc-prof-options only works in the file itself?
23:41:14 <dankna> er, the .cabal file
23:41:30 <dcoutts> yes
23:41:53 <dankna> okay.  I'll "just" invoke cabal twice, explicitly passing flags to enable/disable vanilla/profiling
23:42:21 <dankna> not cabal's fault really, my usage scenario is weird
23:43:03 <dankna> I'm on the verge of abandoning XCode completely and trying to get cabal to build Objective C for me, haha
23:43:18 <dankna> this is not the first impedance mismatch between XCode and cabal that I've run into
23:44:22 <NihilistDandy> dankna: I've actually not done any work with Xcode and Haskell together, yet
23:44:25 <NihilistDandy> How is it?
23:44:32 <dankna> NihilistDandy: meh, could be worse :)
23:44:54 <NihilistDandy> I keep trying to find a recent version of HOC, but no joy
23:45:03 <dankna> no, there is none, it's abandoned
23:45:28 <NihilistDandy> T_T
23:45:34 <dankna> garbage collection on the ObjC side was the death knell - HOC's RTS just isn't prepared for that.  I have a half-started project to replace it completely, but I have a lot on my plate...
23:45:49 <dankna> unlike HOC, my approach uses Apple's XML files which describe the API in great detail
23:46:09 <dankna> although they aren't complete, so it combines that data with the data from ObjC's reflection API, which is the only source HOC used
23:46:25 <dankna> this part is largely working; what's not is the actual generation of the binding code :)
23:46:27 <NihilistDandy> dankna: I could always help out. I'm getting a friend of mine to learn Haskell and he's collaborating with me on some (as yet undecided) nontrivial projec
23:46:29 <NihilistDandy> *project
23:46:40 <Obvioso> yo. I just started learning haskell earlier today and just got to lists, and lists, within lists.
23:46:42 <NihilistDandy> And I have nothing on my plate
23:46:50 <dankna> well, sure.  why don't I push my source repo somewhere you can see it, and you can take a look.
23:46:58 <NihilistDandy> Kayo
23:47:12 <NihilistDandy> I'd love to see some decent Cocoa bindings in the near future
23:47:19 <dankna> agreed
23:47:23 <dankna> then I wouldn't have to use XCode :D
23:47:41 <Obvioso> I mean, greeting in haskell land
23:47:50 <NihilistDandy> dankna: Warning, I'm not exactly expert in the old Haskell, but I'm learning :D
23:47:55 <dankna> okay :)
23:48:01 <dankna> it's not using any expert features :)
23:48:11 <NihilistDandy> Super cool, then. I hope I can be helpful
23:48:18 <NihilistDandy> Obvioso: Ohai
23:48:40 <Obvioso> NihilistDandy: thanks, hi
23:49:04 <NihilistDandy> Obvioso: Lists within lists, eh? Where are you learning? LYAH?
23:49:29 <Obvioso> ya. I was chattin up some fellas in #esoteric telling them how I want to start programing again
23:49:50 <dankna> http://dankna.com/software/darcs/direct-cocoa/
23:49:51 <Obvioso> I'm just learning at home from net resources
23:50:02 <dankna> and my email is dankna@gmail.com if you need help getting oriented in it, or have patches or anythign
23:50:25 <NihilistDandy> Obvioso: I was feeling the same way, so I thought I'd improve my knowledge of the major paradigms. C for procedural/imperative, Haskell for functional, Smalltalk for OO, and Python for multi-paradigm
23:50:44 <Obvioso> wow
23:50:46 <shachaf> NihilistDandy: Python for multi-paradigm? Isn't that stretching it a bit?
23:50:48 <dankna> one sec, let me make sure the dependencies are exported as well
23:50:54 <NihilistDandy> shachaf: Better suggestions?
23:51:05 <Obvioso> thats a bit more indepth than my current persuits
23:51:09 <NihilistDandy> dankna: Take your time
23:51:11 <dankna> ah, you'll also need my also-unpublished library direct-xml-expat, adding that too
23:51:19 <shachaf> NihilistDandy: Well, Python is well-known for "there's exactly one way to do it".
23:51:29 <shachaf> And for being unfriendly to FP. And so on.
23:51:52 <Obvioso> I was considering python untill I was persuaded otherwise
23:51:58 <shachaf> NihilistDandy: At least pick Ruby, which is neither of those. :-)
23:52:03 <Obvioso> but right now I'm just starting with one language
23:52:20 <NihilistDandy> shachaf: Hmm. That's a fair point. I was considering Perl or Ruby, too, but the person I'm collaborating with knows some Python, already
23:52:21 <shachaf> Maybe LISP? I'm not sure what qualifies as "multi-paradigm".
23:52:57 <dankna> NihilistDandy, okay - also obtain and install http://dankna.com/software/darcs/direct-xml-expat/
23:53:06 <NihilistDandy> shachaf: Mostly I was just looking for a so-called "scripting language" that was a little more universal than bash
23:53:27 <shachaf> NihilistDandy: Fair enough. I'd say Ruby but that might be personal bias showing. :-)
23:53:29 <dankna> (I don't like expat, because I found an exploitable crashing bug in it related to invalid unicode sequences crossing read-chunk boundaries...)
23:53:38 <NihilistDandy> dankna: Just darcs get <blah> and install, yes?
23:53:41 <dankna> (but it works, which is more than my pure-Haskell rewrite does)
23:53:55 <dankna> $ darcs get <blah> ; cd <blah> ; cabal install
23:54:01 <NihilistDandy> Awesome
23:54:19 <dankna> for direct-cocoa you actually want cd direct-cocoa/TranslateAPI/
23:54:24 <NihilistDandy> shachaf: I was leaning for Ruby myself. We'll see
23:54:31 <shachaf> NihilistDandy: At least they don't hate lambdas. :-)
23:54:33 <dankna> because that project is organized as several Cabal packages inside a single darcs repo, each in its own subdirectory
23:54:39 <dankna> or will be; right now there's only one of them
23:54:42 <Obvioso> what can I do with Haskell?
23:54:44 <NihilistDandy> shachaf: <3 \
23:54:47 <dankna> Obvioso: floss your teeth with it
23:54:58 <NihilistDandy> Obvioso: What do you want to do with Haskell?
23:55:05 * dcoutts notes that with the latest cabal you can just: $ darcs get <blah> ; cabal install <blah>/
23:55:14 <dankna> oh, nice
23:55:20 <Obvioso> can I program linux in it?
23:55:34 <monqy> what do you mean program linux
23:55:53 <dcoutts> dankna: indeed, you can list multiple dirs and it'll do the dep resolution
23:56:06 <dankna> dcoutts: oh nice!  I remember you talking about that, but I wasn't aware it was implemented already
23:56:14 <dcoutts> it's in 0.10.x
23:56:22 <dankna> nice
23:56:29 <dankna> that's what I've got
23:56:34 <dcoutts> that plus local and remote tarballs
23:56:41 * dankna nods
23:56:48 <NihilistDandy> Woof, it does work
23:56:50 <Obvioso> I'm considering runing linux in the future
23:56:51 <NihilistDandy> How convenient
23:56:59 <Obvioso> guess I dont know how its done though
23:57:15 <NihilistDandy> Obvioso: Choose a nontrivial project
23:57:28 <Obvioso> simple game physics
23:57:32 <dankna> Obvioso: you're kind of asking "can this car drive to baseball games?" to decide whether to buy a minivan or an SUV
23:57:36 <NihilistDandy> Sure, that should be doable
23:57:43 <dankna> YES, it can drive to baseball games, but that is not the right question to be asking
23:58:04 <Obvioso> never mind about linux, I havent looked into it enough by far
23:58:16 <monqy> if you mean can you target linux the answer is yes
23:58:17 * dankna nods
23:58:44 <NihilistDandy> dankna: Getting ExitFailure 1 on direct-xml-expat
23:59:01 <ClaudiusMaximus> i did some physics thingy in haskell (using ghc on linux) - but i kinda abandoned it because sometimes i'd get an infinite number of collisions in 0 time due to floating point rubbish
23:59:05 <dankna> NihilistDandy, huh.  that happens when you attempt to compile it?  can you nopaste the full log?
23:59:07 <dankna> oh, right
23:59:16 <dankna> you will need the expat C library installed first.  what platform are you on?
23:59:24 <NihilistDandy> OS X.6
23:59:30 <dankna> oh, convenient, so am I :)
23:59:38 <NihilistDandy> :)
23:59:40 <dankna> you already have it then
23:59:47 <dankna> do you have Apple's development tools installed?
23:59:59 <dankna> wait, of course you do, the Haskell Platform requires them
