00:13:41 <Axman6> @check \x y -> x + (y - x) == (y :: Integer)
00:13:42 <lambdabot>   "OK, passed 500 tests."
00:13:50 <Axman6> @check \x y -> x + (y - x) == (y :: Int)
00:13:50 <lambdabot>   "OK, passed 500 tests."
00:13:53 <Axman6> @check \x y -> x + (y - x) == (y :: Int8)
00:13:54 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary GHC.Int.Int8)
00:13:54 <lambdabot>    arising from a ...
00:13:57 <Axman6> bah
00:18:51 <kniu> If I get something like
00:18:52 <kniu> fd:7: hFlush: resource vanished (Broken pipe)
00:19:01 <kniu> how do I catch this error and handle it?
00:42:43 * hackagebot tls 0.6.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.6.2 (VincentHanquez)
00:42:45 * hackagebot tls-extra 0.2.1 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.2.1 (VincentHanquez)
00:52:45 * hackagebot posix-timer 0.0.3 - Bindings to POSIX clock and timer functions.  http://hackage.haskell.org/package/posix-timer-0.0.3 (MikhailVorozhtsov)
01:59:07 <josh__> i finish the LEARN YOU A HASKELL FOR GREAT GOOD !
01:59:14 <josh__> wat next ?
01:59:49 <quicksilver> profit!
01:59:56 <josh__> ha
01:59:56 <proq> go forth, my son!
02:00:06 <quicksilver> real world haskell is a different style of book which covers some topics in more depth
02:00:13 <proq> go forth and spread the haskell code
02:01:08 <josh__> proq: i will try to make a little project 1st
02:01:13 <Entroacceptor> josh__: try to write a program :)
02:01:15 <Entroacceptor> yes
02:01:52 <josh__> quicksilver: u mean to go depper need to study the real world haskell book?
02:02:20 <quicksilver> josh__: no.
02:02:20 <josh__> deeper
02:02:26 <quicksilver> josh__: there are lots of ways to go deeper.
02:02:36 <quicksilver> including practice, reading blogs, discussing things in this channel.
02:02:52 <quicksilver> and RWH isn't uniformly deep - it just covers a few areas in depth.
02:03:00 <quicksilver> with a slant towards solving 'real' problems.
02:03:08 <Jafet> Go deeper – with coq.
02:03:18 <josh__> ok.
02:03:29 <proq> boooooo
02:03:51 <Entroacceptor> Jafet--
02:04:05 <ddarius> @tell Accidus Start by presenting G+H via Freyd's Adjoint Functor Theorem.  The adjunction is + ⊣ Δ : Grp -> Grp×Grp.  A solution set is the singleton set with f : (G,H) -> Δ(G×H) where f(g,h) = ((g,1), (1,h)).  Any morphism (φ,γ) : (G,H) -> ΔK can be written as Δt ∘ f where t(g,h) = φ(g)*γ(h).  Freyd then says to take the equalizer of all endomorphisms of f which is the equalizer of all
02:04:06 <lambdabot> Consider it noted.
02:04:18 <ddarius> @tell Accidus φ : G×H -> G×H that satisfy φ(g,1) = (g,1) and φ(1,h) = (1,h).  By continuity of Δ, this equalizer is the coproduct of G and H.  The injections are then induced by that equalizer via g ↦ (g,1) and h ↦ (1,h).  That these homomorphisms are mono implies that the injections are mono.  The pullback of the injections is the same as the pullback of these homomorphisms.
02:04:18 <lambdabot> Consider it noted.
02:06:14 <Nereid> ddarius: what's all this?
02:06:18 <Nereid> :O
02:08:55 <unfo-> only on #haskell ... o_____O
02:09:28 <Nereid> no, like actually
02:09:39 <Nereid> what are we proving here
02:09:58 <blueonyx> science! it works bitches :)
02:13:18 <proq> was haskell intelligently designed?
02:13:48 <aristid> no, it was intelligently evolutionised.
02:14:29 <sipa> by a blind watchmaker
02:15:29 <aristid> (which explains some things)
02:16:10 <Nereid> or never mind
02:16:11 <Nereid> I'm going to bed
02:47:59 <frerich> Hm, sorry for being offtopic, but I need the advice of a native english speaker. I'd like to yield an error message which explains that some X/Y coordinate of an object is obscured by a window of another process. Right now I'm writing "Cannot pick <object_type> object; the object is obscured by a window of <name_of_other_process> at the computed position (<x_pos>/<y_pos>).". Is this proper english?
02:48:03 <cheater_> hi
02:48:16 <cheater_> who is responsible for haskell releases, packaging, etc?
02:48:22 <cheater_> i mean the haskell platform
02:48:48 <Nereid> frerich: looks alright
02:48:52 <Nereid> I'd write (x,y) for the coordinates though, not (x/y)
02:49:13 <frerich> Nereid: Ok, thanks :-)
02:54:20 <Jafet> (Why should it refuse to pick that object anyway?)
02:55:29 <HugoDaniel> i have a pure function that i want to call, but i want to stop it if it spends too much time computing, how do i do that in haskell ?
02:55:36 <Jafet> @hoogle timeout
02:55:37 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
02:55:37 <lambdabot> module System.Timeout
02:55:37 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
02:56:43 <Jafet> (with evaluate.deepseq?)
02:56:45 <HugoDaniel> hmm, my function is pure
02:56:54 <HugoDaniel> i could probably just use return and see if it works
02:57:17 <Jafet> But what you're doing to it is technically impure. So use unsafePerformIO
03:00:30 <Eduard_Munteanu> Nereid: I'm not a native speaker, but maybe you could use "by a window belonging to"?
03:00:48 <Eduard_Munteanu> or "created by"?
03:00:59 <Eduard_Munteanu> frerich, even
03:01:08 <HugoDaniel> ish :(
03:01:23 <HugoDaniel> i think lazyness bytes me again
03:01:24 <Nereid> you could
03:01:28 <Nereid> that might be a little better
03:02:21 <HugoDaniel> http://hpaste.org/46353/lazyness_byte
03:06:12 <Jafet> HugoDaniel: yep, Just _ is whnf
03:06:20 <Jafet> Looks like you want something like deepseq
03:06:45 <Phyx-> @hoogle deepseq
03:06:45 <lambdabot> No results found
03:07:06 <osfameron> Any haskeller's in UK NW: I'll be giving a (fairly noddy) talk at http://lanyrd.com/2011/geekup-liverpool-may/ on 31st May
03:07:30 * osfameron will send an announce to haskell-cafe in a bit (when we've got confirmation about the 2nd talk, on a lisp implementation)
03:08:10 <HugoDaniel> i found deepseq in hxt docs
03:08:39 <Eduard_Munteanu> There's a separate deepseq package IIRC
03:08:54 <HugoDaniel> http://hackage.haskell.org/package/deepseq  here
03:09:10 <Eduard_Munteanu> Yeah.
03:09:52 <Phyx-> ah
03:09:54 <hydo> hehe I read that as "a fairly naughty talk" the first time.
03:10:00 <Jafet> HugoDaniel: http://hpaste.org/paste/46353/lazyness_byte_annotation#p46354
03:10:27 <HugoDaniel> great :)
03:10:37 <HugoDaniel> how do i do to make ghc return the it after if evaluates an expression ?
03:10:45 <Jafet> Er, think I left out C.M.I
03:10:52 <Nereid> timeout t (let x = sum [1..] in x `seq` return x)
03:10:55 <Nereid> is what you want
03:10:59 <Nereid> remember t is in microseconds
03:11:18 <HugoDaniel> yeah
03:11:19 <Nereid> (I just tested it and it seems to work)
03:11:23 <HugoDaniel> i juse *10^6 and its a go
03:11:42 <Jafet> Yeah, you don't need seq for sum [1..]
03:11:47 <Jafet> s/seq/deepseq/
03:12:12 <HugoDaniel> well i wanted to "timeout" arbitrary pure functions, sum was just an example
03:12:19 <Nereid> yeah
03:12:32 <Nereid> it's not nice, but
03:12:33 <Nereid> yeah
03:12:38 <Nereid> you could compose it with unsafePerformIO and fromJust
03:12:42 <Nereid> or something
03:12:43 <Jafet> There was a discussion in here about making NFData a ghc builtin
03:12:51 <Nereid> or just keep the Maybe
03:13:05 <Nereid> but that's a bad idea maybe
03:13:10 <Jafet> But for now, you may have to write those instances
03:13:21 <HugoDaniel> i see
03:14:20 <HugoDaniel> thanks :)
03:14:22 <quicksilver> I remark that if your pure function computes a function, or an IO actions, or various other types for which it's not possible even in principle to write a DeepSeq instance then there isn't much you can do.
03:14:36 <HugoDaniel> oh :/
03:15:02 <HugoDaniel> im working on a Data.Text diff&patch package
03:15:19 <osfameron> DRMacIver: you made the new scientist!
03:15:30 <HugoDaniel> it has no IO, but i wanted it to timeout
03:15:47 <Nereid> if you want it to timeout with an error
03:15:51 <Nereid> then yeah
03:16:38 <shachaf> osfameron: http://www.drmaciver.com/2011/04/im-mentioned-and-misrepresented-in-the-new-scientist/ ?
03:17:20 <DRMacIver> osfameron: Yeah, but it wasn't really very exciting.
03:17:37 <DRMacIver> osfameron: It's really just some guy's new scientist branded blog. I got a factor of about 100 more hits from HN than the new scientist
03:18:02 <Jafet> Also http://hpaste.org/paste/46353/lazyness_fun#p46355
03:18:02 <osfameron> ah ok
03:19:04 <DRMacIver> Also I was really just being included for flavour because the author didn't want to just write an article saying "Vote AV. Duh"
03:19:22 <mekeor> how do i get "a" when i have "Right a"?
03:19:34 <osfameron> DRMacIver: hehe, still, it's always amusing to see names you recognize when reading random posts
03:19:39 <ion> >>=, maybe, …
03:19:42 <shachaf> case foo of (Left b) -> x; (Right a) -> y
03:19:45 <ion> <$>
03:19:48 <Nereid> mekeor: case x of { Right a -> a }
03:19:49 <Nereid> =(
03:19:54 <shachaf> unsafeEvilFromRight
03:19:58 <ion> :-D
03:20:00 <Nereid> but that's evil yeah
03:20:01 <Nereid> and unsafe
03:20:03 <Jafet> The right isn't evil!
03:20:05 <mekeor> oO??? which one??
03:20:16 <Nereid> well shachaf didn't quite get it
03:20:17 <ion> Whichever applies to your need.
03:20:19 <Nereid> (what's x and y?)
03:20:39 <shachaf> Oh, I meant expressions in terms of a and b.
03:20:41 <Nereid> mekeor: however, note that Either a is a monad so maybe you want to do monady things with it
03:21:00 <ion> You’ll need to tell us more about what you’re doing.
03:21:15 <shachaf> Note also that (r ->) is a monad so maybe you want to do monady things with it. Every single time you use a function.
03:21:19 <ion> Whoops, brainfart with “maybe”. “either” that is.
03:21:25 <mekeor> i unfortunately dont have any expiriences with monads, yet… (
03:21:27 <Nereid> shachaf: but you do
03:21:28 <mekeor> * :(
03:21:32 <Nereid> sometimes
03:22:21 <Nereid> good night, for real
03:22:25 <shachaf> Nereid: Right. But if you don't understand how functions work on their own yet, I wouldn't recommend getting monad functions into it.
03:22:29 <shachaf> Nereid: goto sleep;
03:22:57 <mekeor> ion: well, actually i wanna parse a CSV-file. i do this with the function "parseCSVFromFile" from http://hackage.haskell.org/packages/archive/csv/0.1.1/doc/html/Text-CSV.html
03:23:41 <mekeor> ion: and now i get "Right [[...],[...],...]" but i want this without the Right :(
03:23:51 <Nereid> where's it coming from?
03:23:55 <shachaf> mekeor: Make sure you handle Left as well.
03:23:56 <Nereid> what would you do if it was a Left _?
03:24:02 <Nereid> man
03:24:04 <mekeor> from the function…
03:24:04 <Nereid> I suck at going to sleep
03:24:14 <shachaf> @localtime Nereid
03:24:15 <lambdabot> Local time for Nereid is Wed May 4 04:27:37 2011
03:24:19 <shachaf> Yep.
03:24:22 <mekeor> if its Left, the program should exit.
03:24:25 <Nereid> how does that work? D:
03:24:33 <shachaf> Nereid: Gremlins in your computer.
03:24:38 <Jafet> mekeor: and  how should it exit?
03:24:45 <Nereid> mekeor: Left means there's a parse error.
03:24:46 <mekeor> Jafet: error
03:24:58 <mekeor> i know.
03:25:03 <Jafet> Catastrophically, then.
03:25:03 <shachaf> Jafet: Clearly it should melt the CPU.
03:25:16 <Nereid> case x of { Left _ -> error "parse error"; Right a -> a } or something ;/
03:25:17 <Jafet> shachaf: ooh, Haskell can do that?
03:25:18 <mekeor> but how do i test, whether its Left or Right???
03:25:23 <shachaf> unsafeHaltAndCatchFire
03:25:26 <Nereid> mekeor: pattern match
03:25:30 <shachaf> mekeor: I recommend question marks.
03:25:37 <Eduard_Munteanu> :t either
03:25:38 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
03:25:42 <Nereid> or either
03:25:47 <HugoDaniel> Jafet: that paste is amazing, how come it works ? does ghci keeps the memory structures for the computation after it times out ?
03:25:49 <ion> Add more question marks, yes. And cowbell.
03:26:17 <Jafet> HugoDaniel: x just keeps pointing to the same thunk, of which timeout tries to evaluate more and more each time
03:26:30 <Jafet> You can examine x between each evaluation with the debugger
03:26:54 <ion> > either error id (Right 42)
03:26:55 <lambdabot>   42
03:27:05 <ion> > either error id (Left "oh noes")
03:27:06 <lambdabot>   *Exception: oh noes
03:27:39 <mekeor> ion: thx
03:28:03 <HugoDaniel> great :)
03:28:23 <shachaf> ...Or you can pattern-match.
03:28:25 <ion> That assumes you want to have IO all over the place, which might not be a good idea.
03:28:32 <mekeor> shachaf: but how?
03:29:14 <Jafet> HugoDaniel: so, laziness in ghc works by binding a thunk to a name, somehow
03:29:22 <Eduard_Munteanu> f (Left _) = error "foobar"
03:29:23 <ion> With ‘case’, as pointed out a number of times above.
03:29:32 <Eduard_Munteanu> f (Right x) = ...
03:29:38 <Eduard_Munteanu> or case expressions
03:30:13 <mekeor> COOL, cool, cool! thx very much! now i understand, thx again :)
03:30:19 <Nereid> uhh
03:30:21 <Nereid> weird...?
03:30:28 <Nereid> No instance for (Monad ((->) Integer))
03:30:37 <Nereid> when I try to ghci that code Jafet pasted
03:30:38 <HugoDaniel> Jafet: is it related to ghc let bindings ?
03:30:44 * hackagebot timeplot 0.3.2 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.2 (EugeneKirpichov)
03:30:52 <Nereid> ghci 6.12.3
03:30:57 <Nereid> ghc*
03:31:09 <Jafet> You can have fix (\f -> case timeout 10000 $ evaluate.join seq $ x of Nothing -> f; Just a -> a) where x = sum [1..10^6], and it terminates too
03:31:37 <Jafet> Nereid: yeah, I pruned my caleskell prelude imports but missed C.M.I
03:31:57 <Nereid> but the ((->) r) instance for monad is defined in prelude, no?
03:31:58 <Jafet> HugoDaniel: iirc, laziness in ghc happens whenever a name gets bound to something
03:32:02 <Jafet> Nope
03:32:07 <Nereid> oh
03:32:08 <Nereid> ohhh.
03:34:41 <Nereid> k
03:34:43 <Nereid> that's neat
03:34:44 <Nereid> now I go to bed
03:34:49 <Nereid> hopefully for real
03:35:05 <Nereid> oh, and @localtime sends a ctcp time request.
03:35:11 <Nereid> I guess.s
03:35:13 <Nereid> since I got one.
03:38:01 <HugoDaniel> :)
03:57:47 <magicman> Mogge!
03:57:52 <magicman> Erp. Mischan.
03:58:46 <mekeor> I've got a "IO String". How do i convert this to a "String"?
03:58:55 <ion> >>=
03:59:13 <mekeor> ion: ok, thx
03:59:20 <quicksilver> normally by using "<-"
03:59:27 <quicksilver> which is a special symbol in a do-block
03:59:31 <quicksilver> which, yes, compiles down to >>=
03:59:32 <Jafet> kmc really ruined that question for us...
03:59:40 <mekeor> kmc?
03:59:47 <ion> You don’t actually convert it to String per se, you combine it to a new action that does something with the string the action in question generates instead.
04:00:23 <ion> Also, <$> might be useful depending on what you’re doing.
04:01:26 <ion> length $ "foobar"  -- :: Int
04:01:34 <ion> length <$> readFile "bla"  -- :: IO Int
04:02:06 <ion> that being equivalent to ‘do contents <- readFile "bla"; return (length contents)’
04:02:14 <ion> or readFile "bla" >>= return . length
04:05:15 <ketil> Generally, <$> is fmap.
04:05:33 <djahandarie> Generally?
04:05:58 <ketil> Specifically, then :-)
04:19:48 <roconnor> @hoogle power
04:19:48 <lambdabot> No results found
04:19:51 <roconnor> @hoogle powerSet
04:19:52 <lambdabot> No results found
04:20:13 <mekeor> @where typeclasschart
04:20:13 <lambdabot> http://www.haskell.org/onlinereport/classes.gif
04:20:13 <roconnor> @type filterM
04:20:13 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
04:20:54 <roconnor> > filterM (const [False,True]) [1,2,3]
04:20:54 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
04:21:32 <roconnor> @src filterM
04:21:32 <lambdabot> Source not found. Wrong!  You cheating scum!
04:21:32 <roconnor> @src Control.Monad.filterM
04:21:32 <lambdabot> Source not found. Maybe you made a typo?
05:10:41 --- topic: '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
05:10:41 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Mar 26 17:29:19 2011]
05:11:41 <mm_freak> jaj: in most cases it's wrong to use putMVar with readMVar
05:11:52 <mm_freak> putMVar could only be used once then
05:12:02 <mm_freak> use takeMVar instead of readMVar
05:13:02 <jaj> mm_freak: hmm ok, I will remember this. however this shouldn't be the issue here as I do only one of each put and read.
05:13:43 <mm_freak> jaj: read = take, then put back
05:14:00 <mm_freak> in virtually all cases readMVar should not appear in your code
05:14:11 <kosmikus> why forkOS and not forkIO, btw?
05:14:12 <jaj> mm_freak: yes, I read that in the the documentation
05:14:35 <mm_freak> if you use readMVar, you most likely don't want MVar at all
05:14:40 <mm_freak> either you want Chan or TVar
05:14:44 <jaj> I just switched readMVar for takeMVar and the behaviour is the same
05:15:19 <mm_freak> yes, understandable…  the MVar is written only once ever?
05:15:33 <mm_freak> in other words:  you start with newEmptyMVar and use putMVar exactly once?
05:15:59 <sohum> @pl \x -> foo n . bar
05:16:00 <lambdabot> const (foo n . bar)
05:16:07 <sohum> @pl \x -> foo x . bar
05:16:07 <lambdabot> (. bar) . foo
05:16:53 <jaj> mm_freak: yes
05:17:21 <jaj> mm_freak: or wait, no
05:17:40 <kosmikus> jaj: I think it's difficult to speculate without seeing what you're really doing. Can't you produce a small example that demonstrates the problem?
05:18:03 <jaj> kosmikus: yes you're right, I see if I can create a small example
05:18:59 <mm_freak> jaj: using newMVar and then putMVar and reading only once is wrong
05:19:07 <mm_freak> using newEmptyMVar and putMVar and reading once is right
05:19:46 <mm_freak> note that putMVar blocks on a nonempty MVar
05:20:07 <mm_freak> (and no, using writeMVar is NOT right)
05:21:37 <jaj> mm_freak: I do newEmptyMVar before the fork. then inside the child I do a tryTakeMVar, then putMVar. then in the parent I do takeMVar. I do the tryTakeMVar in the child since my MVar contains a list and I want to add a value to the list or create a new list depending on whether there is already a list or not.
05:22:56 <jaj> after the takeMVar i do a "fromMaybe []" to get the list. I then add a value to the list and putMVar it.
05:23:04 <mm_freak> jaj: it seems like you don't want MVar at all
05:23:14 <mm_freak> jaj: you much more likely want STM
05:23:43 <mm_freak> first of all, MVar is not transactional, so you will run into race conditions
05:24:01 <mm_freak> secondly MVar is a message channel, not a mutable variable
05:24:14 <mm_freak> you can abuse it as such, but you will run into problems
05:24:41 <jaj> mm_freak: actually it's a GUI program that has to listen to a socket which can have multiple connections and depending on GUI entry it needs to send traffic to the sockets, so I use the MVar to add handles to the connections as they are created and tell them to the GUI part running in the main thread.
05:25:40 <mm_freak> the application concept seems fine
05:26:26 <mm_freak> MVar would be valid for that, but you have to find a way, in which the next value of the MVar does not in any way depend on the previous value
05:26:39 <mm_freak> i.e. first tryTakeMVar, then putMVar is wrong
05:26:57 <mm_freak> when i used MVar for that, i added a message type
05:27:17 <mm_freak> data MyMessage = AddHandle Handle | SendSomething ByteString | Quit (IO ())
05:27:25 <jaj> mm_freak: hmm, well the main thread should never do a putMVar so I shouldn't run into race conditions there
05:28:17 <jaj> and I need to get the list to be able to add something to it so tryTakeMVar before putMVar seems unavoidable
05:28:39 <mm_freak> it is avoidable
05:29:21 <mm_freak> data MyMessage = WantAddHandle ([Handle] -> Handle -> ([Handle] -> IO ()) -> IO ()) | …
05:29:32 <mm_freak> but as you see, MVar is not really suitable for this
05:29:41 <mm_freak> you want a real transactional variable like TVar or TArray
05:30:05 <mm_freak> there you can get the current set of handles and modify it in a transaction and be safe
05:30:08 <mm_freak> and likely even faster
05:30:25 <jaj> mm_freak: I never looked into STM, I'll have a look at it
05:31:58 <mm_freak> in any case, try*MVar, readMVar and writeMVar have the same dirtiness as 'trace' and so on…  you use them, if you don't feel like doing the proper thing
05:40:09 <roconnor> @wn homoiconicity
05:40:11 <lambdabot> No match for "homoiconicity".
05:40:14 <roconnor> :(
05:42:05 <roconnor> what does homoiconicity mean?
05:42:35 <Silvah> http://en.wikipedia.org/wiki/Homoiconicity ?
05:43:04 <Jafet> A fancy word used to promote lisp.
05:43:22 <zygoloid> ironically, a word defined to describe Tcl, which the lisp weenies now claim doesn't describe Tcl
05:44:23 <Jafet> Well, knowing Tcl's primary data type, it doesn't say much anyway.
05:45:14 <zygoloid> equally true knowing Lisp's primary data type :)
05:45:35 <zygoloid> (omg your ast is a tree?)
05:46:48 <osfameron> my officemate recently found out that the "tree" that the CMS he was hacking on produces is actually a cyclic graph
05:47:00 <osfameron> so processing it results in amusing infinite loops
05:48:46 <zygoloid> i wonder if virus scanners can be defeated by hard-linking directories in NTFS
05:50:28 <osfameron> zygoloid: virus scanners can usually bring your computer to its knees even *without* infinite directory recursion ;-)
05:50:38 <zygoloid> :D
05:51:16 <mm_freak> NTFS is a good example of an overly complicated filesystem
05:51:42 <mm_freak> even files can act like directories by having a sort of attachment files
05:51:45 <opqdonut_> didn't they try to make it transactional or something?
05:52:24 <Jafet> The Mac filesystem had forks long before that
05:52:53 <mm_freak> dunno, but that would be a good feature…  so far NTFS appears to be just an ubercomplicated little sister of ext3
05:53:44 <Jafet> Heh, ever used zfs?
05:54:12 <Jafet> It's like an emacs of file systems
05:55:59 <zygoloid> Jafet: NTFS can send mail? :)
05:57:32 <Jafet> I wouldn't be surprised if someone wrote fuse-smtp
05:58:09 <sipa> there is gmailfs?
05:59:05 * Jafet is hereby unsurprised
05:59:21 <Silvah> mm_freak: if NTFS were younger than ext3, then maybe. But it was already a mature filesystem when ext3 was introduced, so no.
06:00:15 <sipa> in reiser4 files and directories were actually the same i believe
06:00:29 <sipa> you could cd into a file, and see its metadata
06:00:40 <ben> could you cd into the metadata?
06:00:47 <sipa> good question :D
06:01:29 <sipa> i don't think so, files and directories still existed both at the filesystem level as separate concepts, but the posix emulation layer used filesystem level directories to represent posix level files
06:01:55 <ben> Way to spoil the confusion by using precise terminology
06:02:12 <luite2> sipa: that was quickly removed because many tools were not used to this behaviour
06:02:17 <sipa> yeah, indeed
06:03:26 <mm_freak> Jafet: how can you use a filesystem to surf the web, send email or chat on IRC?
06:03:35 <mm_freak> despite being simple in its core, of course
06:04:07 <luite2> cd www.google.com
06:04:14 <luite2> less search?test
06:04:24 <mm_freak> Silvah: not questioning that NTFS is far better than FAT
06:04:27 <luite2> err q=test
06:04:43 <Jafet> cd: www.google.com: permission denied
06:04:55 <mm_freak> but compared to any mature linux filesystem NTFS is like a bad joke
06:05:17 <luite2> meh ext2 and 3 were very simple, with linear directories (linked list)
06:05:26 <luite2> indexes were added later
06:05:29 <mm_freak> sipa: you can't cd into a file on NTFS…  these attachments are only accessible via special system calls
06:05:42 <sipa> i know
06:06:22 <mm_freak> perfect for hiding worms
06:25:51 <Silvah> mm_freak: what's a "mature linux filesystem"?
06:26:52 <mm_freak> Silvah: i can only judge about two, because the others i haven't used, but reiserfs3 and ext4 would be mature in this context
06:28:21 <Silvah> mm_freak: yeah, I knew that joke before :D
06:28:52 <Silvah> I've heard*
06:28:53 <mm_freak> you might want to elaborate
06:31:04 <Silvah> These filesystems are *Linux* filesystems, right? Therein lies the answer.
06:31:28 <mm_freak> Silvah: yes
06:31:29 <mm_freak> so?
06:34:26 <prljavi_hari> How to define a function in winghci command line ?
06:34:56 * Silvah thinks it's better to stop before a flamewar starts. Silvah just doesn't like Linux and thinks it's big piece of crap that lacks any thought.
06:35:52 <luite2> mm_freak thinks the same about NTFS, both without substantial arguments so far ;p
06:36:40 <fryguybob> prljavi_hari: Use let
06:36:50 <fryguybob> let f x = x*x
06:36:56 <prljavi_hari> ok
06:37:49 <prljavi_hari> but there is a pps on haskell org that doesn't use let
06:38:45 <Silvah> Well, I'd be interested to learn what's wrong with NTFS.
06:39:07 <prljavi_hari> like factorial  :: Int  Int
06:39:07 <prljavi_hari> factorial n = product [1..n]
06:39:32 <fryguybob> prljavi_hari: the ghci prompt is like being in a do block.  So you are not at the top level.
06:39:46 <prljavi_hari> ok
06:42:36 <fryguybob> prljavi_hari: Most examples are expecting you to put the code in a file and use :load and :reload
06:44:53 <prljavi_hari> ok
06:45:56 <mm_freak> Silvah: i wouldn't even disagree, if you replaced "big piece of crap that lacks any thought" by "weak by design"…  i don't like any of the major operating systems, which includes linux
06:46:12 <mm_freak> or kernels, to be exact
06:46:55 <Silvah> mm_freak: "weak by design" is too... weak :)
06:47:24 <mm_freak> Silvah: then it's too weak for all of the popular systems
06:47:54 <mm_freak> at least some distributions have put some thought into their design, one notable good example being NixOS
06:48:03 <mm_freak> i'm not using it (yet), but i think it's a great idea
06:48:46 <mm_freak> it seems to be the haskell of the operating systems =)
06:49:01 <mm_freak> literally
06:49:29 <Silvah> mm_freak: it makes it too easy to create a huge space leak? :>
06:55:37 <mm_freak> Silvah: indeed, yes
06:55:52 <mm_freak> not through laziness, but missing automatic garbage collection ;)
06:56:11 <mm_freak> but it even has a garbage collector
07:19:54 <tim__> anyone heard of sproutcore
07:19:55 <tim__> ?
07:30:14 <djanatyn> > read "3" :: Int
07:30:14 <lambdabot>   3
07:30:30 <djanatyn> > read '3' :: Int
07:30:31 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:30:31 <lambdabot>         against inferred ty...
07:30:37 <djanatyn> :\
07:30:45 <djanatyn> what's up with that?
07:30:48 * osfameron doesn't get how the Either version here is more elegant: http://www.vex.net/~trebla/haskell/exception.xhtml
07:30:55 <hpc> djanatyn: v
07:30:58 <hpc> :t '3
07:30:59 <lambdabot>     lexical error in string/character literal at end of input
07:31:02 <opqdonut_> djanatyn: '3' isn't a string but a Char
07:31:02 <hpc> :t '3'
07:31:03 <lambdabot> Char
07:31:06 <hpc> :t "3"
07:31:07 <lambdabot> [Char]
07:31:10 <opqdonut_> :t read
07:31:11 <lambdabot> forall a. (Read a) => String -> a
07:31:16 <hpc> @src String
07:31:17 <lambdabot> type String = [Char]
07:31:24 <opqdonut_> hpc: high five
07:31:35 <hpc> :D
07:31:56 <djanatyn> oooh
07:33:14 <djanatyn> Hmm.
07:33:41 <djanatyn> How can I read a Char to an Integer?
07:33:53 <Zao> Depends on what your interpretation of the Char is.
07:33:57 <zygoloid> @type digitToInt
07:33:58 <lambdabot> Char -> Int
07:33:58 <Zao> Numeric value if it's a digit?
07:34:04 <Zao> Ordinal in unicode?
07:34:11 <djanatyn> ooh
07:34:13 <Zao> Hex digit?
07:34:14 <djanatyn> I see.
07:34:17 <Saizan> osfameron: that's the point of the page
07:34:27 <djanatyn> Decimal, in ASCII
07:34:30 <zygoloid> Zao: i'm imagining djanatyn means 'read' in the haskell sense
07:34:35 <djanatyn> 1-9
07:34:47 <mm_freak> osfameron: more elegant than what?
07:34:47 <opqdonut_> djanatyn: use digitToInt
07:34:47 <djanatyn> uhh, brb
07:34:49 <Zao> > map digitToInt ['c'..'g']
07:34:49 <lambdabot>   [12,13,14,15,*Exception: Char.digitToInt: not a digit 'g'
07:34:58 <djanatyn> Yeah, I'll use rhat
07:35:00 <zygoloid> :D
07:35:05 <Zao> zygoloid: I prefer not guessing the intentions of others.
07:35:06 <osfameron> Saizan: that was my best hypothesis... hurrah
07:35:16 <prljavi_hari> I'm trying to define qsort which uses filter and I get error: filter not in scope. Do I have to load some library ? What do backquote before and after some fuction mean ?
07:35:19 <Zao> Particularly if they go away with the first incorrect suggestion.
07:35:20 <osfameron> mm_freak: than the IO version with exceptions
07:35:37 <zygoloid> Zao: it seemed sufficiently clear to me that it felt like not-a-guess, but i certainly agree with your general strategy
07:36:04 <djanatyn> errm
07:36:07 <Saizan> osfameron: i.e. once you're in IO adding an ErrorT layer doesn't help
07:36:08 <Zao> @hoogle filter
07:36:08 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
07:36:09 <lambdabot> Data.ByteString filter :: (Word8 -> Bool) -> ByteString -> ByteString
07:36:09 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
07:36:17 <mm_freak> well, one thing about exceptions, that has always bothered me is that it uses impure stuff under the hood
07:36:19 <djanatyn> digitToInt isn't in scope.
07:36:29 <Zao> @hoogle digitToInt
07:36:29 <lambdabot> Data.Char digitToInt :: Char -> Int
07:36:31 <djanatyn> Should I import something?
07:36:49 <mm_freak> and you would use something insane to get type safety
07:36:50 <djanatyn>  Ah, yep
07:36:55 <djanatyn> Thanks!
07:37:28 <mm_freak> `catch` (\(ex :: WhateverType) -> …)
07:37:52 <Saizan> what do you mean impure stuff under the hood? they are in IO
07:38:11 <mm_freak> Saizan: unsafeCoerce
07:38:18 <mm_freak> essentially
07:38:44 <mm_freak> this is how SomeException implements the semi-OOP-style exceptions
07:38:54 <Saizan> yeah, it uses Typeable
07:39:05 <Saizan> not exactly what i'd classify as impure
07:39:35 <Saizan> (i.e. it'd need some contortion to find a side-effect there)
07:39:39 <Axman6> prljavi_hari: back quotes make functions infix, so x `max` y is the same as max x y
07:40:22 <mm_freak> Saizan: changing a type signature changes the semantics of your program, even though you are not using polymorphism
07:40:43 <mm_freak> 'catch' will behave differently depending on the type of its second argument
07:41:11 <Saizan> that's what every typeclass method does already
07:41:48 <Saizan> or any function defined in terms of those
07:42:17 <mm_freak> Saizan: it just feels impure to me, or at least dirty…  i prefer being explicit about exceptions
07:43:00 <Saizan> the only part where Typeable matters here is essentially having a open sum type for exceptions
07:43:06 <Saizan> so that users can add their own
07:43:41 <Saizan> and you can build on top of this to make actions being explicit about the subset of exceptions they might throw
07:45:30 <Saizan> i guess different instantiations of ErrorT do give some of that, but at a coarser granularity, unless all your actions happen to possibly throw the same exceptions
07:47:07 <Saizan> http://hackage.haskell.org/package/control-monad-exception <- btw
08:04:06 <djanatyn> snipt.org/xsog -_-
08:04:25 <djanatyn> This type thing is messing with me.
08:05:00 <djanatyn> So, I've got a big string filled entirely.with numbers
08:05:09 <Axman6> djanatyn: the type of your function says it takes only one argument, something of type a, and returns something of type b
08:05:30 <quicksilver> djanatyn: you do not want that word 'do' there.
08:05:58 <Axman6> i would strongly suggesy using pattern matching on the list input... though your type mentions nothing about a list
08:05:59 <quicksilver> djanatyn: 'do' is a special notation for using monadic actions, and you're not doing that.
08:06:14 <Axman6> quicksilver: though in this case should work i believe
08:06:16 <djanatyn> My function should go through the string, and add add each digit to f list
08:06:40 <mm_freak> System.Locale is a module from the old-locale package, which suggests that there may be a new 'locale' package, just like with 'old-time' and 'time'
08:06:55 <mm_freak> but i cannot find anything like that in the base libraries
08:07:00 <mm_freak> can anyone enlighten me?
08:07:14 <Axman6> djanatyn: well your type in no way says that it can do that...
08:07:17 <quicksilver> mm_freak: there isn't a new-locale, no one wrote it.
08:10:29 <Twey> How would one express division of a list of elements as a fold?  E.G. divideAll [x, y, z] = ((x / y) / z) / 1
08:10:35 <portnov> hi all
08:10:36 <mm_freak> quicksilver: thanks
08:10:44 <mm_freak> quicksilver: anything wrong with old-locale?
08:10:53 <Twey> What sort of a fold is that?  It associates to the left but puts the identity on the right?
08:11:17 <sipa> Twey: you want divideAll (x:r) = x / multiply r :D
08:11:30 <portnov> Q: should `-l' option work in {-# OPTIONS_GHC #-} pragma? For example, I want {-# OPTIONS_GHC -lXtst #-}.
08:11:36 <Axman6> > foldl (flip (/)) 1 [x,y,z]
08:11:38 <lambdabot>   z / (y / (x / 1))
08:11:39 <tromp_> sillydivide (x:xs) = x / product xs
08:11:45 <Twey> Axman6: Associates the wrong way :-\
08:11:47 <Axman6> > foldl ((/)) 1 [x,y,z]
08:11:48 <lambdabot>   1 / x / y / z
08:11:52 <Axman6> hmm
08:12:02 <Twey> tromp_, sipa: Yeah, I know I can do that, but I'm interested in how the fold would be expressed
08:12:13 <quicksilver> mm_freak: It seems to work for me :) I think the view was that the API was wrong.
08:12:38 <mm_freak> quicksilver: wrong or just not haskellish enough?
08:12:44 <quicksilver> dunno
08:13:15 <quicksilver> > foldl (flip(/)) 1 $ reverse [x,y,z]
08:13:16 <lambdabot>   x / (y / (z / 1))
08:13:23 <Twey> Still the wrong way
08:13:23 <quicksilver> > foldr (flip(/)) 1 $ reverse [x,y,z]
08:13:25 <lambdabot>   1 / x / y / z
08:13:32 <quicksilver> lol
08:13:35 <Twey> Heh
08:13:40 <quicksilver> too hard. Brain exploded.
08:14:22 <quicksilver> I'm sure it's some permutation of left or right and flip or reverse or both :)
08:14:51 <Twey> Yeah
08:14:56 <Twey> I figure that much :þ
08:15:10 <frerich> Hm, Twey's question shakes my belief that I understood folds.
08:16:54 <frerich> I might be missing something, but is it "foldl (/) 20 [5,2,1]" ?
08:17:06 <Twey> 20?
08:17:17 <Twey> 20 isn't an identity
08:17:25 <Twey> > foldl (/) 20 []
08:17:26 <lambdabot>   20.0
08:17:31 <Twey> Not the right answer :þ
08:17:38 <djanatyn> Hmm!
08:17:50 <frerich> Twey: I made the identity of (/) the last  element of the list :-}
08:17:56 <Twey> Oh, I see
08:18:01 <Twey> Yes
08:18:09 <frerich> Twey: but maybe I'm too confused
08:18:20 <Twey> That's the right answer, but not really the right approach
08:18:32 <Twey> I think
08:18:35 <Twey> Hm
08:19:06 <fryguybob> > let f _ i (x:[]) = x / i; f (/) i (x:y:xs) = f (/) i ((x / y):xs) in f (/) 1 [x,y,z]
08:19:07 <lambdabot>   x / y / z / 1
08:20:08 <djanatyn> snipt.org/xsoj -_-
08:21:05 <luite2> > foldl1 (/) [x,y,z] / 1 -- :p
08:21:06 <lambdabot>   x / y / z / 1
08:21:30 <luite2> I don't think it's a regular fold
08:21:41 <Twey> djanatyn: I don't think your function terminates…
08:21:48 <Twey> luite2: Haha
08:22:09 <Twey> Yeah, I guess not :-\
08:24:18 <djanatyn> Twey: oh
08:24:50 <djanatyn> wait, it should
08:26:21 <djanatyn> once it gets down to one number, like "2", it returns an empty string
08:26:35 <djanatyn> > tail "2"
08:26:36 <lambdabot>   ""
08:28:15 <thierry`> Hi, I'm fighting with my Mac to upgrade ghc, simply reinstalling anew version of the haskell platform doesn't seem to work, any tips on how I could do that cleanly?
08:29:10 <frerich> thierry`: I'm using homebrew since some time (and I got ghc via that). Updating ghc was a matter of 'brew update ghc' I think.
08:30:20 <thierry`> frerich : cool I use brew too (for other programs) but I installed ghc via the haskell platform before installing brew. How can I uninstall the haskell platform?
08:30:22 <Twey> djanatyn: I think your function is ‘map digitToInt’
08:30:33 <Twey> djanatyn: Or possibly ‘reverse . map digitToInt’
08:30:53 <frerich> thierry`: That I don't know, sorry
08:31:55 <Axman6> homebrew doesn't use the 64 bit version of ghc by default sadly
08:32:21 <Axman6> though, they do now have the --64bit flag, which is very nice
08:32:31 <Twey> > let addToList "" xs = xs; addToList x xs = addToList (tail x) (digitToInt $ head x) : xs in addToList "123" []
08:32:32 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
08:32:32 <lambdabot>         against inferred typ...
08:34:45 <Twey> > let addToList "" xs = xs; addToList (c : cs) xs = addToList cs $ digitToInt c : xs in addToList "123" []
08:34:46 <lambdabot>   [3,2,1]
08:34:55 <Twey> > reverse . map digitToInt $ "123"
08:34:57 <lambdabot>   [3,2,1]
08:35:12 <Twey> djanatyn: ^
08:35:20 <Twey> :t reverse . map digitToInt
08:35:22 <lambdabot> [Char] -> [Int]
08:35:45 <Twey> :t let addToList "" xs = xs; addToList (c : cs) xs = addToList cs $ digitToInt c : xs in addToList
08:35:46 <lambdabot> [Char] -> [Int] -> [Int]
08:39:02 <dbpatterson> I'm trying to figure out how to organize test cases with quickcheck and I see that the Test.QuickCheck.Batch described in Real World Haskell (http://book.realworldhaskell.org/read/testing-and-quality-assurance.html#x_k21 ) no longer exists in current QuickCheck. What do people use instead?
08:45:15 <McManiaC> monad comprehensions are in the main GHC repo: http://hackage.haskell.org/trac/ghc/ticket/4370#comment:54
08:45:18 <McManiaC> :)
08:47:17 <Ferdirand> win 13
08:47:19 <Ferdirand> oops
09:01:01 <quicksilver> McManiaC: yay :)
09:01:01 <earthy> dbpatterson: test-framework
09:02:38 <dbpatterson> earthy: thanks
09:10:07 <tromp_> @check
09:10:08 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:11:24 <tromp_> @check \((a,b)::(Double,Double)) -> a+b-a==b
09:11:25 <lambdabot>   Parse error in pattern at "->" (column 27)
09:24:07 <mm_freak> type Logger = String -> LogLevel -> [forall a. Loggable a => a] -> IO ()
09:24:22 <mm_freak> this one requires ImpredicativeTypes
09:24:28 <mm_freak> what's the deal?
09:32:23 <colinhect> Is it a convention to prepend 'mk' to a function name if the functions purpose is to construct a data type?
09:34:58 <Axman6> not really, sometimes it makes sense, other times it makes more sense to use a 'smart constructor' function, so if you have data Tree a = Leaf a | Node Int (Tree a) (Tree a), you might not export the constructors, and have leaf and node functions that maintain the property that the Int counts the number of elements in the subtrees say
09:36:48 <colinhect> I see
09:36:51 <ion> It might (or might not) be appropriate to use just “node” instead of “mkNode” even then.
09:37:12 <ion> :t state  -- for instance
09:37:13 <lambdabot> forall s a. (s -> (a, s)) -> State s a
09:37:24 <colinhect> It just feels kind of wrong to reserve the identifier 'node' for the data type Node
09:37:38 <colinhect> it seems common to do something like 'where node = Node "blah"
09:38:02 <colinhect> I guess that doesn't make sense for Tree
09:38:15 <ion> OTOH, the users might import it qualified and use T.node
09:38:34 <colinhect> Yeah
09:38:58 <colinhect> ok... thanks
09:40:49 * roconnor does NOT want to know what is going behind the scenes in GHC's IO monad.
09:40:51 <roconnor> :)
09:42:03 <ion> I haven’t looked at the specifics but i’m under the impression the implementation’s semantically similar to the state monad.
09:44:49 <roconnor> ion: my understanding is that the implementation relies on GHC core being a strict functional langauge.
09:45:01 <roconnor> ion: not to disagree with what you said
09:58:45 <c_wraith> roconnor: have you ever looked at inlinePerformIO?  pure fun, there :)
09:58:46 <c_wraith> inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
10:07:37 <Volatile> yo. Is it possible to "glue together" several matches in a branch expression? Say that I want to perform the same action if I have a Foo and a Bar, but a different for an Etaoin...
10:10:42 <Eliel> Volatile: you mean when pattern matching function arguments?
10:11:00 <Volatile> Eliel: in a case expression
10:11:21 <Volatile> case blah of ... This && That -> -- <-- something like that
10:11:40 * hackagebot cpsa 2.2.3 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.3 (JohnRamsdell)
10:12:11 <Volatile> heh, but not &&. ||. And working. :)
10:13:03 <wjt> Volatile: I think your main options are to use guards: | isThis blah || isThat blah = ...; | otherwise = ...; or to move the shared body to a function: case blah of This -> f; That -> F; ... where f = ...
10:15:42 <Volatile> wjt: oh. :/ Well, thanks anyway. :)
10:20:34 <mm_freak> what is an impredicative type?
10:29:50 <lispy> mm_freak: http://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/
10:51:07 <mm_freak> lispy: thanks
11:02:17 <buzl> can someone tell me why i cant create an instance of my type class ? http://hpaste.org/46363/instance_error
11:02:46 <buzl> < new to haskell
11:03:35 <KirinDave_> buzl: I suspect that the problem is
11:04:00 <KirinDave_> buzl: That you aren't putting enough type parameters in the instance
11:04:11 <buzl> mhh
11:04:18 <buzl> thought i got 2
11:04:26 <KirinDave_> [] is a type constructor that needs its own type.
11:04:35 <lispy> who will be the first one here to implement this and put the library on hackage? http://www.igvita.com/2011/04/07/life-beyond-http-11-googles-spdy  Go!
11:04:38 <KirinDave_> [a], for example
11:04:44 <buzl> mhhh
11:04:48 <buzl> kk ill try
11:04:49 <buzl> it
11:04:58 <KirinDave_> I dunno if maybe you meant to say M a in the decl
11:05:09 <pmetzger> Agda lets you define mixfix constructors like [], right?
11:05:34 <buzl> doent work
11:05:40 <buzl> Kind mis-match
11:05:40 <buzl>     The first argument of `MultiSet' should have kind `* -> *',
11:05:57 <pmetzger> buzl: you get what a kind is, yes? kind is the type of a type.
11:06:27 <pmetzger> (type of a type constructor perhaps, I'm not that old a hand at this yet.)
11:07:15 <buzl> but i thought [] is a ctor for an list
11:07:21 <Saizan> all types have a kind
11:07:22 <buzl> and then my second arg would be a
11:07:29 <pmetzger> buzl: you defined empty as taking an m and an e, right?
11:07:42 <buzl> y
11:08:01 <pmetzger> and you defined empty below as just getting one thing, a type rather than a constructor or a function.
11:08:46 <pmetzger> above you said empty :: m e
11:08:53 <buzl> the idea was that you can instanciate multiset for different types like a btree or list,...
11:09:20 <pmetzger> so what do you expect "m" and "e" to mean.
11:09:23 <ricree> pmetzger:  I think he wants to use list as a type constructor here.  I'm not sure how to go about that
11:09:55 <pmetzger> also, I don't get his instance notation.
11:10:04 <buzl> m should be the type of implementation like a binary tree or a list and e the type stored in it
11:10:11 <gwern> > logBase 2 7000000000
11:10:12 <lambdabot>   32.70470777604387
11:10:36 <buzl> so that you can use different containers for special cases
11:10:53 <pmetzger> buzl: so "a" is a valid name for a list of b, right?
11:11:04 <pmetzger> buzl: scratch that. go back.
11:11:16 <pmetzger> what type are you trying to define as an instance of multiset here?
11:11:26 <buzl> list
11:11:31 <buzl> therefore the [] ctor
11:12:05 <pmetzger> so you want to say that list is an instance of multiset.
11:12:12 <pmetzger> is that what you're saying with that declaration?
11:12:45 <buzl> yes that i define a multiset with a list as container
11:12:59 <pmetzger> why the Eq biz?
11:13:12 <buzl> to compare the list elements
11:13:15 <ricree> buzl:  what was the error you got in the hpaste version?
11:13:22 <buzl> if you implement a btree for example
11:13:25 <pmetzger> buzl: is it valid to put that into an instance declaration?
11:13:37 <buzl> yes it is
11:14:05 <buzl> Illegal instance declaration for `MultiSet [] a'
11:14:06 <buzl>       (All instance types must be of the form (T a1 ... an)
11:14:06 <buzl>        where a1 ... an are *distinct type variables*,
11:14:06 <buzl>        and each type variable appears at most once in the instance head.
11:14:24 <buzl> i dont get what the ghc is trying to tell me :D
11:14:27 <pmetzger> so it seems to be telling you that the syntax is wrong.
11:14:29 <pmetzger> isn't it?
11:14:32 <pmetzger> illegal declaration.
11:14:43 <buzl> think so but i dont know how to fix it
11:15:08 <pmetzger> well, can you name a valid instance declaration you've seen in other code?
11:15:11 <pmetzger> one that compiles?
11:15:23 <pmetzger> say an instance declaration on lists from the prelude.
11:15:43 <pmetzger> (I don't think you're using the right syntax. that's what I'm leading you to.)
11:15:52 <buzl> yes but only with a single param / or not with an list
11:16:03 <buzl> ye i think that to
11:16:05 <buzl> o
11:16:13 <pmetzger> there are instance declarations on list in the prelude I'm pretty sure. lets look for one.
11:16:17 <Saizan> buzl: try with {-# LANGUAGE FlexibleInstances  #-}
11:16:37 <buzl> mhhh thought about taht
11:16:41 <Saizan> assuming MultiSet is a multi parameter typeclass
11:16:48 <buzl> but what does this option?
11:17:04 <monochrom> buzl: ordinary instances should look like "instance MultiSet [] Int where" but of course this is not what you want. generally it's the same error as "instance Show a where"
11:17:07 <Saizan> enables a larger class of instances
11:17:38 <buzl> works
11:17:43 <buzl> with the option
11:17:48 <monochrom> generally it expects a "type constructor" like [], Int, rather than a "type variable" like a
11:17:49 <buzl> th
11:17:50 <buzl> x
11:18:17 <buzl> thought it would be enough to switch XMultiParamTypeClasses on
11:18:26 <pmetzger> monochrom: that's what I thought. but I don't think he needs the type variable does he?
11:18:37 <pmetzger> monochrom: he's really just trying to say that lists are multisets.
11:18:41 <monochrom> "All instance types must be of the form (T a1 ... an)" this means [], [a], (a,b), Int etc.
11:18:52 <monochrom> I don't think anyone knows what he needs
11:19:03 <pmetzger> monochrom: fair enough. we don't know what he's trying to solve.
11:19:11 <Saizan> we haven't seen how MultiSet is defined
11:19:27 <monochrom> so instead I just say what the language allows
11:19:37 <pmetzger> Saizan: he defined the typeclass in the paste
11:19:58 <buzl> no not trying to say lists are multisets
11:20:27 <buzl> its just that you can implement different containers for different needs
11:20:27 <pmetzger> what are you trying to say then?
11:20:37 <pmetzger> can you expand on that more?
11:20:43 <buzl> so like a queue if you just need the first element
11:20:54 <pmetzger> normally, you define something like Eq and then say "this type is an Eq type"
11:21:05 <buzl> or btree for seach optimization
11:21:06 <pmetzger> or define Monoid and say "this type is a monoid"
11:21:16 <pmetzger> so what type is an instance of multiset?
11:21:30 <buzl> like the one i posted with list
11:21:35 <pmetzger> tell me in words.
11:21:35 <buzl> or one with a binary tree
11:21:41 <buzl> or one with a queue
11:21:57 <KirinDave_> buzl: So what "m e" is in your class
11:22:06 <pmetzger> expanding: so what type specifically should be an instance of multiset as an example?
11:22:09 <KirinDave_> Is you are saying "a type M that contains a's.
11:22:11 <pmetzger> just as an example.
11:22:23 <buzl> in this special case a list and any type you want to store
11:22:23 <pmetzger> a specific concrete type we all know.
11:22:24 <KirinDave_> So for example, [a] is a valid multiset of a
11:22:27 <monochrom> the preferred way to do containers such as multiset, at the type class level, is "class MultiSet c e | c->e where empty :: c; add :: e -> c -> c" etc and then "instance Eq a => MultiSet [a] a where"
11:22:59 <pmetzger> KirinDave_: he didn't say that yet.
11:23:10 <KirinDave_> pmetzger: I am asking :)
11:23:10 <monochrom> which still needs FlexibleInstances
11:23:19 <pmetzger> KirinDave_: ah, sorry.
11:23:19 <buzl> ye
11:23:25 <buzl> thats it kirindave
11:23:36 <pmetzger> so arrays should be multisets?
11:23:44 <pmetzger> just as they are, for example, monads and eqs?
11:23:49 <buzl> where m is any container you want to define
11:24:01 <pmetzger> er, not arrays, I meant lists.
11:24:04 <pmetzger> (I keep doing that.)
11:24:21 <buzl> but you could use arrays too
11:24:33 <buzl> its just an experiment nothing serious
11:26:53 <buzl> thx all of you for the help
11:27:44 <KirinDave_> buzl: Is this what you wanted?
11:27:45 <KirinDave_> http://hpaste.org/paste/46363/instance_error_annotation#p46364
11:28:11 <monochrom> personally I would "newtype MSv0 a = MSv0 (Array a)" or something and then "instance MultiSet (MSv0 a) a" so as to add a free layer of abstraction
11:28:34 <buzl> yes kirin
11:28:45 <KirinDave_> Well that code works. :)
11:29:04 <monochrom> so that it is not so much "array is a case of multiset" as "MSv0 is a multiset implemented with an array inside"
11:29:13 <buzl> ye i forgot the fexible... option
11:29:31 <KirinDave_> Does flexibleinstances imply multiparamtypeclasses?
11:29:31 <monochrom> but either way I don't mind too much
11:29:50 <buzl> it does
11:29:51 <monochrom> no
11:29:52 <buzl> imply it
11:30:09 <KirinDave_> Indeed it does not.
11:30:13 <buzl> unrecognised flags: -XMultiParamTypeClasses
11:30:18 <KirinDave_> So for my own edification
11:30:20 <buzl> if i use fexible...
11:30:31 <pmetzger> Hrm. So I'm not getting a number of things here. I think this means I should stare at more type classes used for containers. :)
11:30:41 <pmetzger> off to the corner with me.
11:30:41 <KirinDave_> Is his MultiSet class a higher kinded type?
11:30:41 <buzl> no sry
11:30:46 <buzl> youre right
11:31:00 <monochrom> m's kind is *->* yes
11:31:17 <bos> KirinDave_: what are you trying to use that typeclass for?
11:31:21 <KirinDave_> bos: Not mine
11:31:26 <KirinDave_> bos: I just wrote buzl's so it worked
11:31:29 <bos> oh
11:32:21 <monochrom> I wonder how well it pans out
11:32:31 * bos tosses a coin over whether to implement iteratees or just a plain old left fold for mysql-simple
11:34:02 <bos> KirinDave_: what are y'all doing in haskell?
11:34:15 <KirinDave_> bos: ?
11:34:27 <bos> KirinDave_: do you work with al3x?
11:34:31 <KirinDave_> I do work with Al3x.
11:34:36 <KirinDave_> Currently: we do nothing in haskell.
11:34:47 <KirinDave_> I'm just chatting during a lull in my work of uncertain duration.
11:34:51 <bos> ah
11:35:03 <buzl> i think in the case of an priority queue it would be great to have an implementation for larger and smaller queues as there are special algorithms for the 2 cases
11:35:06 <KirinDave_> bos: I'm interested. But no promises of intent to use in the context of our work.
11:35:10 <bos> i've been curious as to why al3x has been asking lots of haskell questions lately
11:35:54 <KirinDave_> We're all interested. Scala is a gateway drug
11:36:15 <bos> heh
11:40:27 <k0ral> hi guys, I've got some trouble using Dyre, it claims my real main expects a String while I've made it so it expects a datatype called Configuration
11:41:03 <k0ral> is it a well-known newbie mistake, or shall I paste my code ?
11:47:13 <tibbe> bos: I vote for plain old left fold
11:47:28 <bos> tibbe: i'm torn :-)
11:47:33 <tibbe> bos: iteratees come with lots of extra complexity
11:47:38 <bos> true
11:47:57 <Lemmih> k0ral: Better paste it.
11:47:58 <bos> but they have a few nice things about them, e.g. early exit
11:48:26 <Volvic> hi
11:48:42 <tibbe> bos: return Either ;)
11:48:48 <bos> tibbe: heh
11:48:55 <tibbe> bos: otherwise you'll pull in extra deps and ListLike and other ugly things
11:49:37 <bos> tibbe: the enumerator library has very very few deps
11:49:48 <bos> transformers, bytestring, text
11:49:50 <tibbe> bos: it might be better than in early versions
11:49:58 <bos> tibbe: it's fairly small
11:51:19 <tibbe> select'read'pending :: [Fd] -> IO (Either Errno [Fd])
11:51:20 <tibbe> ?
11:51:44 <monochrom> \∩/ another oleg case lover!
11:51:59 <tibbe> bos: my brain is too small for this big baroque APIs
11:52:05 <tibbe> what happened to simple?
11:52:27 <bos> tibbe: hee hee!
11:52:31 <teratorn> tibbe: it died
11:52:45 <tibbe> bos: it even has a StringLike that conflates bytes and Unicode code points
11:52:53 <bos> tibbe: where's that?
11:52:58 <tibbe> http://hackage.haskell.org/packages/archive/ListLike/3.1.1/doc/html/Data-ListLike-String.html#t:StringLike
11:53:19 * tibbe wonders what fromString :: String -> ByteString does
11:53:21 <bos> tibbe: but enumerator doesn't depend on ListLike
11:53:35 <Volvic> why is this not possible?
11:53:36 <Volvic> shuffled <- readFile "sffled.txt"
11:53:37 * tibbe is looking at the old lib
11:53:41 <Volvic> takeWhile (/=" ") shuffled
11:53:43 <bos> tibbe: ah
11:53:49 <bos> tibbe: look at 0.4.10
11:53:56 <bos> it's relatively small
11:53:58 <tibbe> looking
11:54:41 <prljavi_hari> Why do I get "Non-exhaustive patterns in function factorial" for "let factorial n= n*factorial(n-1)", "let factorial 0=1" and "factorial 10" ?
11:54:48 <tibbe> >==>
11:54:53 <tibbe> the attack operator? :)
11:55:00 <k0ral> here is the code: http://hpaste.org/46365/dyre_problem
11:55:21 <tibbe> bos: you do what you must :)
11:55:35 <epdtry> prljavi_hari: if those two definitions of factorial are in separate "let"s, they're two separate functions
11:56:35 <k0ral> I've just annotated the error
11:57:02 <k0ral> why does it expect a [Char] instead of a Configuration ?
12:00:57 <prljavi_hari> How then to do indented code in winghc command line ?
12:01:27 <luite2> prljavi_hari: if you need indentation you probably should load a file instead of typing it directly into the terminal
12:01:39 <parcs> prljavi_hari: delimit multiple let bindings with ;
12:01:52 <prljavi_hari> ok
12:01:59 <parcs> > let factorial 0 = 1; factorial n = n * factorial (n - 1) in factorial 9
12:02:00 <lambdabot>   362880
12:02:47 <prljavi_hari> thanks
12:02:51 <parcs> on a related note, i'm surprised at the number of recursion/FP tutorials that mistake 0! to be 0
12:03:29 <Saizan> and so factorial = const 0 ?
12:03:31 <Lemmih> k0ral: Because Dyre.realMain should is a 'String -> IO ()' field?
12:03:59 <pozic> Why does it take 200MB of memory to link cabal?
12:04:10 <dcoutts> split ojbs
12:04:56 <pozic> dcoutts: what are those? I heard of them, but I don't see any fundamental reason for it being like that.
12:05:06 <bos> tibbe: okay, the enumerator library is suitably infuriating :-)
12:05:09 * bos kills it
12:05:37 <dcoutts> bos: I thought it was just me :-)
12:05:44 <mrd> the gtk2hs homepage is _still_ down?
12:05:54 <dcoutts> bos: because of enumerators in general, or this specific impl?
12:06:01 <pozic> mrd: you can download the releases just fine.
12:06:03 <c_wraith> I prefer 0! is undefined to 0! is 1.  But 0! is 0 is just wrong.
12:06:29 <dcoutts> pozic: split ojbs means e.g. libHSbase.o contains over 10k tiny .o files. This makes the linker cry, as it's not optimised for this use case.
12:06:37 <k0ral> Lemmih: according to the doc: realMain :: cfgType -> IO ()
12:07:08 <bos> so i guess i want stream :: (QueryParams q, QueryResults r) => Connection -> Query -> a -> (a -> r -> IO a) -> q -> IO a
12:07:12 <pozic> dcoutts: does gold also do that?
12:07:26 <bos> dcoutts: enumerators/iteratees in general, i think
12:07:28 <dcoutts> pozic: no idea
12:07:31 <Geralt> Hi, I'm currently installing haskellmode-vim and it needs a local haddock copy, how/where can I get that? Is it the GHC documentation?
12:07:34 <mrd> pozic: looking for the docs
12:07:34 <dcoutts> bos: ah ok, so it's not just me :-)
12:07:49 <bos> dcoutts: the enumerator library seems to have become relatively minimal, but it's still a brainwreck
12:07:49 <k0ral> Lemmih: I think I got it
12:07:58 <dcoutts> mrd: it's not so much "down" as not having been transferred to the new server. I got the gtk2hs mysql db moved over, but we still need to install wordpress in a way that will not compromise the server security too much.
12:08:14 <k0ral> Lemmih: I need to set a defaultParams
12:08:40 <Lemmih> k0ral: Your 'confError' assumes cfgType is a String.
12:08:50 <dcoutts> bos: perhaps it's no longer true, but I recall it having far too much IO in there too, when for the most part these things should be pure
12:09:34 <bos> dcoutts: a fair bit of it is Monad-parameterised now
12:09:50 <obbele> Gerald: just install haddock using apt-get/yum/cabal install haddock/...
12:10:04 <k0ral> Lemmih: how come ?
12:10:23 * obbele oops, Gerald ain't Geralt 
12:11:13 <Lemmih> k0ral: Look at the type of 'showError'.
12:11:23 <Lemmih> k0ral: Then look at the type of 'confError'.
12:11:46 <k0ral> Lemmih: indeed
12:14:26 <k0ral> Lemmih: that was it, it compiles well now, thank you :)
12:14:36 <Geralt> obbele: on ubuntu there's only a virtual package by that name. I have a haddock dir in /usr/share/doc/ghc6-doc/hmtl, but that directory does not match the format expected by the haskellmode-vim plugin
12:15:59 <prljavi_hari> If I try to load file in winghc, does it has to have a function "main" or something ?
12:16:09 <monochrom> haddock is part of "ghc6" on ubuntu
12:16:38 <Geralt> monochrom: the command `haddock' or the generated documentation?
12:16:45 <monochrom> I mean the command
12:17:11 <monochrom> there are numerous "libghc6-*-doc" packages you can add for docs
12:17:38 <obbele> IIRC, haskellmode will regenerate the doc and it takes lots of time
12:18:11 <monochrom> if haskellmode-vim is so inflexible about doc location, too bad
12:19:48 <Geralt> I tried setting g:haddock_dir = "/usr/share/doc/ghc6-doc/hmtl" but lookups fail
12:20:02 <monochrom> hmtl? typo?
12:20:09 <Volvic> why is this not possible?       putStrLn $ takeWhile (< 3) [1,2,3,4,1,2,3,4]
12:20:22 <Geralt> typo
12:20:52 <rothwell> Volvic: putStrLn . show $ takeWhile (< 3) [1,2,3,4,1,2,3,4]
12:20:55 <monochrom> have you done an "ls /usr/share/doc/ghc6-doc/html" to see that the content there looks good?
12:21:05 <mauke> Volvic: because putStrLn takes a String
12:21:20 <Volvic> ok thx
12:21:40 <mauke> Volvic: you could use 'print'
12:22:22 <Geralt> The problem seems to be the version numbers, e.g., file://localhost/usr/share/doc/ghc6-doc/html/libraries/base-4.2.0.0/Prelude.html instead of file://localhost/usr/share/doc/ghc6-doc/html/libraries/base/Prelude.html
12:23:54 <helino> hi everyone! How would you represent a Java interface with two generics in Haskell. For example "interface Foo<A, B> { A foo(B b); }" ?
12:25:00 <Lemmih> helino: (I know nothing about Java) class Foo a b where foo :: a -> b ?
12:25:23 <helino> Lemmih: can you have a type class that takes two type variables?
12:25:32 <ricree> foo :: b -> a
12:25:41 <monochrom> I concur. don't forget to add {-# LANGUAGE MultiParamTypeClasses #-}
12:25:58 <helino> the reason I
12:26:32 <helino> 'm asking is that it try to relate two typeclasses Foo and Bar but don't understand how to do it :)
12:27:29 <Lemmih> helino: Relate how?
12:27:32 <helino> monochrom: ok, then I go with this! why isn't this part of the "base" language?
12:28:47 <helino> Lemmih: by "class Foo a where foo :: (Bar b) => a -> b" and "class Bar b where bar :: b -> b"
12:30:18 <Lemmih> helino: I still don't understand what you're trying to do.
12:30:50 <Volvic> how can I convert a read .txt file which contains strings(seperated by newlines and tabs) into a list of strins? Is there such a function?
12:31:00 <Zao> @type lines
12:31:01 <lambdabot> String -> [String]
12:31:02 <Zao> @type words
12:31:03 <lambdabot> String -> [String]
12:31:05 <mauke> Volvic: words
12:31:17 * hackagebot test-framework-th 0.2.1 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/test-framework-th-0.2.1 (OscarFinnsson)
12:31:18 <Zao> Lines splits on lines. Words splits on whitespaces.
12:31:35 <Zao> > words "omg\twtf   bbq "
12:31:36 <lambdabot>   ["omg","wtf","bbq"]
12:31:41 <Volvic> fast answers here (-:
12:31:43 <Volvic> thx
12:31:49 <Zao> If you only want to split on tabs, you have a Fun Time in front of you.
12:33:34 <mauke> Data.List.Split to the rescue
12:33:37 <josuf107> > "lambdabot?"
12:33:38 <lambdabot>   "lambdabot?"
12:33:51 <mauke> @bot
12:33:51 <lambdabot> :)
12:33:52 <josuf107> cool
12:34:10 <helino> Lemmih: it is hard to explain, since I'm not that good at Haskell to begin with...I will try to cook up a minimal example of my problem, just a sec
12:38:32 <gwern> @quote
12:38:32 <lambdabot> kmc: says: (): worst monoid ever
12:38:39 <gwern> hah
12:39:12 <tswett> Worst monoid ever?  Dude, it's a complete ordered field!  Tell me that's not excellent.  :P
12:39:30 <tswett> Actually, I think an ordered field requires that 0 < 1, doesn't it.
12:40:04 <mauke> preflex: quote kmc
12:40:04 <preflex>  <kmc> i think "do the opposite of C++" is a decent design guideline
12:41:22 <pmetzger> C++ is written in a subset of Unicode. Therefore, a superior language would be written in a superset of Unicode or a charset disjoint from Unicode. Which is superior?
12:41:48 <mauke> ｉｎｔ ｍａｉｎ（） ｛ ｒｅｔｕｒｎ ０； ｝
12:42:05 <monqy> C++ exists. this is a bad design decision.
12:42:09 <shachaf> tswett: It's not even a field, much less a complete ordered field.
12:42:20 <pmetzger> what is the operator defined on ()?
12:42:26 <tswett> pmetzger: () ++ () = ().
12:42:47 <pmetzger> isn't ++ list concatenation?
12:42:49 <tswett> shachaf: oh, definitions, definitions.
12:42:56 <tswett> pmetzger: not in lambdabot.  :P
12:42:58 <tswett> @type (++)
12:42:59 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:43:14 <helino> Lemmih: ok, I got an example now, I pasted it at http://hpaste.org/46367/problem_with_type_constraints
12:44:16 <ricree> interesting.  the prelude (++) is [a] -> [a] -> [a] on hackage
12:44:18 <pmetzger> lambdabot defines things differently from haskell?
12:44:23 <kmc> yes
12:44:28 <kmc> :t (Prelude.++)
12:44:28 <lambdabot> forall a. [a] -> [a] -> [a]
12:44:29 <pmetzger> what's the motivation?
12:44:45 <kmc> lambdabot basically imports the Prelude hiding some things
12:44:49 <tg_> conal: here?
12:44:51 <kmc> and then imports other things with those names from other modules
12:44:52 <ricree> is there a way to get it to show which (++) it's getting that from?
12:44:59 <tswett> lambdabot's definitions are more general, because Cale likes it that way, I think.
12:45:00 <helino> Lemmih: when loading this in ghci, I get an error about "Ambiguous type variable..."
12:45:03 <conal> tg_: hi
12:45:05 <pmetzger> hrm. () is indeed a monoid.
12:45:15 <tg_> conal: did you ever upload your latest GUI work?
12:45:21 <pmetzger> I wonder what the point of that is...
12:45:23 <Lemmih> helino: That code doesn't really make sense. It seems as if you're using type-classes as you would objects in OO languages.
12:45:23 <conal> pmetzger: and usefully so!
12:45:26 <tg_> the non-iPad stuff?
12:45:33 <Lemmih> helino: Type-classes in Haskell are quite different.
12:45:36 <pmetzger> conal: I believe you, but what's a use for it?
12:45:41 <kmc> that's a common mistake
12:45:49 <kmc> beginners tend to overuse type classes
12:45:58 <helino> Lemmih: I think of type-classes as I think of interfaces in OO
12:46:00 <kmc> maybe just pretend they don't exist when you're starting out
12:46:01 <helino> more or less
12:46:11 <bustakheops> hi , plz someone can help me, I try to read file using Data.ByteString.Lazy but I always used to much memory ! How to use a buffer something like this plz ?
12:46:15 <Volvic> I don*t get why this is String: ["09ceooty","aanrtz","abgimt","ahinst","aiorrrsw","bdelno","beeinr","eeegnu","eeginss","enoprty"] ; why is it not [String]?
12:46:17 <Lemmih> helino: The problem is that 'foo' can give you any kind of Bar and you haven't told it which kind you want.
12:46:26 <conal> pmetzger: one example i've used: i give IO (and other applicatives) a monoid instance that depends on there being a monoid instance for the argument type.
12:46:34 <helino> Lemmih: thanks, I completely understand that
12:46:40 <kmc> :t ["09ceooty","aanrtz","abgimt","ahinst","aiorrrsw","bdelno","beeinr","eeegnu","eeginss","enoprty"]
12:46:41 <lambdabot> [[Char]]
12:46:45 <kmc> it's [String]
12:46:46 <helino> but I don't know how to make this correct
12:46:47 <tswett> Volvic: it appears to be [String] to me.
12:46:50 <tg_> conal: in particular you were working on a problem with memoizing?
12:46:54 <conal> pmetzger: i can use that instance even when the arg type is ()
12:47:01 <helino> how would you make this correct?
12:47:22 <Volvic> toSortList list = show $ Set.toList $ Set.fromList $ map sort $ words list
12:47:27 <Volvic> toSortList :: String -> String
12:47:28 <helino> by correct I mean, in a more idiomatic (and working :)) way
12:47:34 <conal> tg_: i'm not remembering what you're talking about. more clues may help.
12:47:34 <pmetzger> conal: so more or less, cases where you might get a bunch of types and it is convenient to have () meet the class.
12:47:37 <Lemmih> helino: I don't understand what you want.
12:47:51 <monochrom> Foo Bar Baz are clearly too abstract
12:47:52 <tg_> conal: you were searching for a solution to encapsulate computation in a graphical environment?
12:47:52 <pmetzger> er, be an instance of the class.
12:48:07 <tg_> conal: ie, to divide up rendering into smaller chunks
12:48:12 <tswett> :t show $ Set.toList $ Set.fromList $ map sort $ words list
12:48:13 <lambdabot> Couldn't find qualified module.
12:48:13 <helino> Lemmih: Let's say I would like to my own Num type-class, and my own Boolean type-class
12:48:29 <tswett> Volvic: well, it seems correct to me.  What's the error you're getting?
12:48:45 <helino> Lemmih: And I define that the my Num type class, lets call it MyNum, should have an == operator
12:48:52 <conal> pmetzger: yes. it's handy for () to fit into the general pattern. simpler interfaces, less code. that sort of thing.
12:48:56 <monochrom> I answered how to do the like of "interface foo<a,b>" in haskell because I assumed it was an academic curiosity.
12:49:03 <Volvic> I don't get why it is toSortList :: String -> String and not toSortList :: String -> [String]
12:49:11 <conal> pmetzger: sort of like the usefulness of zero -- which was a radical idea.
12:49:16 <Volvic> beause it returns [String]
12:49:19 <mauke> Volvic: what does 'show' do?
12:49:21 <tswett> Volvic: ah.  Well, the last thing you're doing is "show", which turns anything showable into a String.
12:49:35 <pmetzger> is there any easy way to find out what all the defined functions/operators on some type are?
12:49:37 <tswett> :t show ["blah","foo"]
12:49:38 <lambdabot> String
12:49:41 <tswett> > show ["blah","foo"]
12:49:41 <lambdabot>   "[\"blah\",\"foo\"]"
12:49:42 <monochrom> in practice I recommend against premature abstraction. solve your real problem in the concrete first. you don't know what abstraction you need yet.
12:49:47 <pmetzger> this made me want to know what is defined over () and i realized I didn't know how to check.
12:49:54 <Volvic> ok
12:50:02 <tswett> pmetzger: well, there's Hoogle.
12:50:05 <helino> Lemmih: then I want the == to return a type of my Boolean type class, let's call it MyBool, as in "class MyNum a where (==) :: (MyBool b) => a -> a -> b"
12:50:07 <conal> tg_: oh! maybe you're talking about my bi-infinite quadtree renderings.
12:50:17 <pmetzger> tswett: hoogle is a bit overinclusive. :)
12:50:27 <conal> tg_: the one mentioned in http://conal.net/blog/posts/topless-data/
12:50:30 <tg_> conal: yes, that
12:50:30 <pmetzger> tswett: in particular, I tried that and i got too much smog from things like IO ()
12:50:33 <tg_> conal: yes...
12:51:00 <tswett> pmetzger: well, that *is* a function on (), sort of, isn't it?  Perhaps you want to search for () -> a or something, though.
12:51:10 <tg_> conal: I think I found a solution... I'll work on it a few days and let you know
12:51:23 <NihilistDandy> :( Readline won't build
12:51:25 <pmetzger> tswett: no, I mean, it shows me too many things that return () or something like IO ()
12:51:39 <pmetzger> tswett: it isn't easy to say "show me only things that TAKE a parameter of type ()"
12:51:39 <helino> Lemmih: but then I get the problem I showed you in my paste, which I totally understand why I get, but I don't how I would represent MyNum and MyBool?
12:51:42 <tg_> conal: I may need some handholding in Haskell, but I have a bunch of mathematica code to start with
12:51:47 <conal> tg_: what's the problem/question for which you're pursuing a solution/answer?
12:51:58 <tswett> pmetzger: okay, I see.  Then I'm afraid I don't have any other suggestions.
12:52:06 <niteria> is there a tool that generates latex formulas of highlighted haskell code?
12:52:10 <tg_> conal: fractal geometry, physics
12:52:27 <pmetzger> tswett: doing () -> a does not do what you expect. it mostly shows you things that take "a" :(
12:52:32 <jmcarthur> niteria: you could probably tweak lhs2TeX to do that
12:52:40 <tswett> Huh.
12:52:51 <Lemmih> helino: Are you sure you get that problem?
12:52:57 <conal> tg_: okay. and are you looking for a data/cached representation of infinite, continuous images (as i was)?
12:53:12 <conal> tg_: since the easy representation (functions) don't cache in haskell?
12:53:15 <tg_> conal: no, I have the representation, I need to impelement it
12:53:31 <tg_> conal: what about monoids?
12:53:45 <tg_> conal: anyway, it may not rely on that, but one step at a time
12:54:12 <tg_> conal: the solution involves building a group out of a division algebra (with subtraction) first
12:54:29 <helino> Lemmih: yep, I'm sure, do you want to see the code? it's on github for everyone too see :)
12:54:34 <tg_> conal: then using it over streams of wavefunction exponentials
12:54:45 <pmetzger> tswett: I've only been at this a couple of weeks but I'm starting to really wish I could give a type "pattern" to hoogle and have it respect it -- say, expressing that I really only want to see functions returning Int and not ones taking Int etc.
12:54:51 <conal> tg_: do you blog? sounds like a good blog topic.
12:54:59 <tg_> conal: no, but this'll make my debut
12:55:06 <helino> Lemmih: But I've realized that I've run in to the exact issue you describe
12:55:07 <Lemmih> helino: You could use 'data AnyBar = forall b. Bar b => AnyBar b' but this is the wrong way to use type-classes usually.
12:55:19 <conal> tg_: great! please let me know when you post.
12:55:22 <tg_> conal: I am going to use your FRP semantics and a new time semantics to build the application I mentioned earlier (d-rive)
12:55:49 <conal> tg_: neat. blog about that topic, too, okay?
12:55:53 <tg_> conal: question: do you know if any of the GPU or CUDA libraries are any good?
12:56:05 <tg_> conal: it's the same thing :o
12:56:06 <helino> Lemmih: what I'm trying to cook up is a very small "virtual machine" that can calculate with user defined types, as long as stuff like *, +, / are defined for the types
12:56:27 <Lemmih> helino: You really don't wanna play around with type-classes for that.
12:56:37 <conal> tg_: oh. so the time & space issues are not separable?
12:56:50 <conal> tg_: depends what kind of good you're looking for.
12:56:55 <conal> tg_: ie good at what?
12:56:56 <helino> Lemmih: I've realized that I might designing this wrong, so please correct me :)
12:57:14 <tg_> conal: I need to do operations on rather huge matrices of integers
12:57:19 <tg_> just general purpose number crunching, not rednering
12:57:29 <NihilistDandy> Anyone have any trouble building readline on OS X? config.log says readline couldn't be found, which is patently ridiculous -_-
12:57:47 <conal> tg_: ah. then cuda or opencl is probably your best bet. they're both low-level.
12:57:55 <dons> conal: lovely comment on purity on ezyang's post. the clearest statement yet i've seen in favor of purity modulo machine configurations.
12:58:00 <tg_> conal: ok. thanks. talk to you soon.
12:58:33 <conal> dons: thanks for that feedback! :) i keep trying to convey this message. and i don't know how best to get it heard.
12:58:40 <conal> tg_: take care.
12:58:57 <ezyang> conal: Agreed with dons.
12:59:21 <tg_> ezyang: about what? :O
12:59:27 <tg_> not that it's ever a good idea to disagree with dons
12:59:49 <conal> ezyang: :)
12:59:51 <dons> conal: the operationally-minded people will particularly like the distributed haskell story here. at least, i did. helps make things nicely, troublesomly concrete :)
13:01:04 <conal> dons: hah. yeah. that bit was a concession. i wish people believed that theory necessarily impacts practice (theory violations beget bugs), but i realize that many don't. nice to have an example in this case.
13:01:11 <dons> :)
13:01:25 <conal> for the curious, we're talking about ezyang's post http://blog.ezyang.com/2011/05/haskell-not-pure-enough/
13:01:32 <dons> yeah
13:01:53 <ezyang> Floating point!
13:02:02 <dons> always better to show why it matters right now, i feel, than to say in effect: "just trust me, you'll run into this sooner or later"
13:02:17 <ezyang> I think that's a really good example of what happens when you fail to make concrete denotational guarantees.
13:02:27 <dons> there are a lot of engineer-minded folks out there, after all.
13:02:55 <ezyang> conal: Are you familiar with the paper "Rethinking the sync"?
13:03:08 <ezyang> Your comments on my latest post reminded me of that paper.
13:03:10 <conal> ezyang: and such a shame, since haskell could otherwise a killer language for effortlessly running in distributed settings.
13:03:30 <conal> ezyang: no, i haven't heard of that paper. will find it.
13:03:54 <ezyang> http://pdos.csail.mit.edu/6.828/2010/readings/rethink-the-sync.pdf
13:04:05 <conal> thx
13:05:41 <conal> dons: congrats on the new job. when do you move to new york?
13:05:54 <helino> hmm, maybe I should make my question a little more general. If I would like to make my own "calculator", but with abstract types, allowing for the definition of new types as long as the implement some operators, how would I do that?
13:06:22 <niteria> jmcarthur: can lhs2TeX break long lines automatically?
13:06:38 <dons> conal: in about 3 weeks, give or take visa processing
13:06:42 <dons> just in time for spring
13:06:52 <ezyang> Wait, really? Where to!
13:06:54 <helino> I should mention, that the types need to interop with each other, for example, == should not return a bool, but instead some abstract bool type
13:07:01 <gwern> > logBase 2 128000000
13:07:02 <lambdabot>   26.931568569324174
13:07:15 <mauke> returning abstract types? what is this witchery
13:07:22 <dons> ezyang: i'm moving to nyc to work for standard chartered bank.
13:07:32 <gwern> dons: eh? what happened to galois?
13:07:46 <dons> just time for a change for me.
13:07:50 <helino> mauke: just not the standard Bool type, but you can define a Bool type however you want, as long as it supports && and not
13:07:59 <bustakheops> Someone can say me what is wrong in my code, I want to use constant memory :
13:08:09 <bustakheops> frenquency :: ByteString -> Map Word8 Integer
13:08:14 <bustakheops> frenquency bytestring =
13:08:17 <bustakheops>   aux (unpack bytestring)  Map.empty
13:08:21 <bustakheops>   where
13:08:22 <mauke> you misspelled "frequency"
13:08:24 <bustakheops>     aux [] map = map
13:08:27 <bustakheops>     aux (hd:tl) map = aux tl (Map.insert hd (toInteger (count hd bytestring)) map)
13:08:30 <mauke> and you're pasting code into the channel
13:08:40 <bustakheops> ok sorry
13:08:40 <mauke> where it's interleaved with other messages and scrolls out of sight
13:08:45 * gwern spreads rumors on reddit: Haskell failing, Don Stewart leaves Galois among infighting over switch to O'Caml
13:08:54 <bustakheops> i do that now
13:08:58 <mauke> s/O'Caml/PHP/
13:09:16 <dons> gwern: i'll be starting a haskell group at sbc in manhattan
13:09:20 <augur> what are some more exotic type theories?
13:09:29 <dons> so a chance to grow the haskell group in nyc
13:09:39 <gwern> dons: nifty. I'm sure whatever haskell user group is in NYC will be happy to see you
13:09:48 <shachaf> There's a Haskell group in NYC?
13:10:08 <dons> an on again, off again group, around sclv and others
13:10:15 <gwern> shachaf: I assume there is. there's like 3 meetup groups for LessWrong, and the Haskell community ought to be bigger than LessWrong
13:10:52 <ezyang> hehe.
13:10:57 <gwern> heck, I met one financial fellow who kept extolling the virtues of K over Haskell
13:11:33 <mauke> bustakheops: try 「aux tl $! (flip (Map.insert hd) map $! (toInteger (count hd bytestring)))」 - does that change anything?
13:11:59 * shachaf suddenly feels out of date with mere «/».
13:11:59 <bustakheops> mauke : ok i try now :)
13:13:49 <mauke> shachaf: I got the idea from J. Friedl - Mastering Regular Expressions
13:15:35 <NihilistDandy> Oh, found a link to solve my little readline issue :)
13:15:42 <helino> can anyone help me understand how I would design a Java interface such as this, http://hpaste.org/46369/translate_java_interface, in Haskell?
13:16:30 <dskippy> helino: That'd be a type class in Haskell, most likely.
13:16:34 <mauke> you wouldn't
13:17:14 <dskippy> helino: Type classes do a little bit of what an interface might do but they don't translate one-to-one. You might want to read about them.
13:17:22 <helino> mauke: what I'm trying to say is, what would be the Haskell "way" of doing this?
13:17:34 <mauke> I'm not sure you would do this in haskell
13:17:35 <dskippy> helino: It's hard to say.
13:17:44 <mauke> helino: how do you implement that interface in java?
13:17:50 <dskippy> helino: Because that's just an interface. So the Haskell way to do it might be to not.
13:18:02 <mauke> helino: especially eq
13:18:19 <dskippy> helino: In order to ask the Haskell way to do something, I think the code must actually do something, rather than being so language centric.
13:18:46 <dskippy> helino: That being said, type classes allow you to define classes of types that all have certain operations defined for them.
13:19:00 <kmc> what's the haskell way to write PHP
13:19:03 <kmc> ;)
13:19:06 <mauke> kmc: putStr
13:19:11 <dabblego> Java interfaces translate to data types. There is nothing in Java that translates directly to type-classes.
13:19:30 <bustakheops> mauke : It's too slow :s
13:19:44 <mauke> bustakheops: yes, but does it use less memory?
13:19:49 <dabblego> data Operation a b = Operation { add :: a -> a -> a, subtract a -> a -> a, ... you can do the rest
13:19:56 <dskippy> dabblego: Not directly, no. At the type level it's really hard to get 1-1 translation for anything.
13:20:06 <mauke> @let a === b = cast a == Just b
13:20:09 <lambdabot>  Defined.
13:20:12 <mauke> kmc: like this^
13:20:17 <kmc> i love (===)
13:20:19 <dabblego> the closest thing java has to type-classes is subtyping
13:20:34 <dskippy> dabblego: I think interfaces are pretty close.
13:20:38 <bustakheops> I don't know for a 100Ko file i am waiting for 10min
13:20:46 <kmc> the closest thing java has to type-classes is a swift kick in the bollocks
13:20:55 <dabblego> interfaces are not anything like type-classes
13:21:05 <kmc> funny enough, the same holds for most language features
13:21:15 <mauke> bustakheops: your algorithm is at least quadratic
13:21:20 <dskippy> dabblego: How is subtyping more like type classes than interfaces?
13:21:27 <mauke> for each character in the input string you iterate over the whole string again
13:21:45 <dabblego> dskippy: implicit type conversion (dictionary), which is the essential property of type-classes
13:21:56 <dabblego> Java interfaces correspond to data types, as shown above
13:22:59 <bustakheops> mauke : ok I have to found other algo, but what I have to do to use less memory , don't use lazy ?
13:23:18 <dskippy> I don't know. I'm not convinced.
13:23:28 <gwern> > logBase 2 43000000
13:23:29 <lambdabot>   25.35783332402627
13:23:56 <dabblego> dskippy: I once had this discussion here and t took me about 90 minutes to convince, there may be logs
13:24:16 <helino> thanks for all your help! I will read more about data types and type classes
13:24:23 <dskippy> Sadly, I don't have 90 minutes.
13:24:28 <helino> I really appreciate you all taking the time to help out a newbie
13:24:39 <dabblego> dskippy: if there is a correspondence for type-classes in Java, I'd sure love to see it, since I am sick of all the hacks around it -- I wrote Functional Java, we could use such a thing desperately
13:24:45 <dskippy> helino: Yeah, just read about both and make your own choice. :)
13:25:36 <eyebloom> Hola
13:25:42 <dskippy> dabblego: I'm not saying that there's such a strong connection that you can program the same way in Java using interfaces the way you'd use type classes.
13:26:03 <dabblego> dskippy: the *essential property* of type-classes is *completely absent* from Java
13:26:12 <dskippy> Okay.
13:26:16 <dabblego> further, there is an *exact* correspondence to data types, as shown above in the example
13:26:25 <dskippy> Agreed. Done.
13:26:32 <eyebloom> Does anyone know roughly how many lines of code are in GHC.
13:26:33 <dabblego> data Eq a = Eq { a -> a -> Bool }
13:27:49 <ezyang> Ohloh claims 180k
13:30:16 <eyebloom> That's not including libraries?
13:34:47 <Tyr42> Looking at the region of people using haskell in last year's google code jam
13:34:49 <Tyr42> http://www.go-hero.net/jam/10/lang/Haskell
13:34:57 <Tyr42> most are in Japan
13:37:58 <obbele> in gstreamer-gtk2hs source code, there is line as "where _ = {# call caps_append_structure #}"
13:38:12 <obbele> someone know why there is a '_' character in place of a function name ?
13:38:48 <mauke> it's a pattern
13:39:02 <mauke> not sure what's going on there, though
13:39:18 <dskippy> It's a pattern where the value is ignored. It's a pattern of ignorance. :)
13:39:21 <obbele> what is the pattern matching ?
13:39:26 <mauke> obbele: everything
13:39:33 <mauke> like any identifier
13:39:47 <NihilistDandy> Anyone experienced in setting up a lambdabot?
13:40:50 <shapr> NihilistDandy: I haven't done it recently...
13:41:12 <NihilistDandy> shapr: Basically, I'm just getting "Terminated", and I'm wondering if I've missed something obvious
13:41:46 <shapr> NihilistDandy: Have you changed the nick/server settings?
13:41:49 <obbele> mauke: but the expression is useless, noone use the function and there seems to be no valuable side effect
13:42:03 <mauke> yeah
13:42:09 <nyingen> NihilistDandy: sounds like your mueval is not working
13:42:48 <NihilistDandy> shapr: It connects to the server and gets nicked properly. Not sure what other settings I need.
13:43:02 <NihilistDandy> nyingen: Hmm. That's unpleasant
13:43:07 <shapr> NihilistDandy: does the @echo command work?
13:43:34 <nyingen> NihilistDandy: I believe you get that message if mueval could not run for some reason
13:43:45 <NihilistDandy> shapr: Yup
13:43:46 <obbele> oki i think I've understand, there is a side effect, C2HS will append at the end of the .hs file a foreign declaration, so one can then call "caps_append_structure" as if it where a Haskell function -_-
13:44:08 <shapr> NihilistDandy: Sounds like basic functionality works... what command is not working for you?
13:44:19 <NihilistDandy> For instance
13:44:21 <NihilistDandy> > 2 + 2
13:44:23 <lambdabot>   4
13:44:30 <NihilistDandy> Instead, I get "Terminated"
13:44:38 <NihilistDandy> @echo "hello"
13:44:38 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "NihilistDandy!~ND@c-75-69-129-101.hsd1.nh.comcast.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \"
13:44:38 <lambdabot> hello\""]} rest:"\"hello\""
13:44:45 <NihilistDandy> That's working, anyway
13:45:11 <shapr> I wrote the @echo command when I was trying to get the plugin system to work the first time :-)
13:45:49 <NihilistDandy> :)
13:46:01 <luite2> does mueval work from the command line?
13:46:02 <shapr> NihilistDandy: Yes, as nyingen said, mueval is having some sort of problem.
13:46:26 <NihilistDandy> derp
13:46:30 <NihilistDandy> I don't have mueval built
13:46:38 <nyingen> that would explain it
13:46:41 <NihilistDandy> I'm dumb :D
13:47:08 <NihilistDandy> Well, phew. At least it's just PEBKAC and not something serious
13:47:17 <NihilistDandy> Thanks for the help, you two.
13:48:23 <gwern> eh? how did you install lambdabot without pulling in mueval? I added mueval as a library dep precisely so you couldn't do that
13:48:59 <shapr> gwern: speaking of which, how do I solve the dependency errors so lambdabot will build on my laptop?
13:49:07 <NihilistDandy> gwern: I dunno. I just cabal'd it.
13:49:10 * gwern reads shapr's mind
13:49:17 <NihilistDandy> Looks like the new version on hackage doesn't list mueval as a dep
13:49:18 <gwern> shapr: try adding a base dep constraint
13:49:19 <shapr> I want to fix the bugs I left in @quote :-(
13:49:45 <NihilistDandy> shapr: What system are you running?
13:50:14 <shapr> NihilistDandy: I'm running ubuntu 10.10 at the moment.
13:50:26 <shapr> but I haven't done any lambdabot dev in years.
13:50:32 <NihilistDandy> :D
13:50:34 <shapr> oh wow, it just worked!
13:50:38 <shapr> awesomeness!
13:50:51 * gwern can do magic, did he mention that part?
13:50:51 <shapr> gwern: maybe someone NMU'd lambdabot ?
13:51:06 <gwern> hackage claims it was me
13:51:17 <gwern> lies! I remember nothing! you can't prove it was me!
13:51:30 <aristid> "NMU"?
13:51:40 <shapr> aristid: debian speak... non-maintainer upload
13:51:52 <monochrom> heh
13:51:54 <scooty-puff> is there a way to export a class, for use in constraints, and some data types that are instances of that class, without allowing any other data types to be instances of that class?
13:52:04 <monochrom> well, hackage records who uploaded
13:52:05 <scooty-puff> in other modules
13:52:38 <scooty-puff> the only way i have figured out is to have a class Private a where ... that is a requirement of the exported class
13:52:40 <scooty-puff> that is not exported
13:53:23 <monochrom> except for one initial version, gwern uploaded all lambdabot versions
13:53:46 <monochrom> in fact mainainer kept changing, but gwern marches on! :)
13:54:00 <Phyx-> lol
13:54:06 <shapr> gwern++ ## for awesomeness!
13:54:08 <NihilistDandy> Oh, dear, looks like I'll have to relink. It's always something :D
13:54:13 <Phyx-> gwern choo choo
13:55:50 <KirinDave_> Man
13:55:58 <KirinDave_> Applicative alternation on Maybe values.
13:56:04 <KirinDave_> Such good shit.
13:56:16 <ketil> Any way to get a profiling run to output profiling info by interrupting the process with some signal?
13:56:20 <scooty-puff> Eithers too
13:56:28 * ketil thinks 'kill' just terminates it.
13:56:33 <KirinDave_> I do not understand why most languages do not have some stuff to do this sort of thing
13:56:40 <KirinDave_> I remember using ||= in ruby to do the same effect.
13:56:48 <KirinDave_> But god help you if it was a boolean.
13:57:23 <aristid> KirinDave_: yeah, perl 6 is supposed to get //= for that reason if i read it correctly (i read that a few years ago, too)
13:57:38 <KirinDave_> It just reads really well too
13:57:50 <mauke> supposed to get? perl5 already has it
13:58:01 <aristid> mauke: perl 5 has ||=, which is different
13:58:04 <shapr> KirinDave_: Applicative is sooo sexy!
13:58:06 <aristid> mauke: or does it have //= now?
13:58:09 <mauke> aristid: yes, and?
13:58:12 <mauke> it has both
13:58:24 <aristid> mauke: since when? :)
13:58:44 <shapr> privyet gemelen!
13:58:54 <aristid> mauke: when i use perl, i'm mostly stuck on 5.8. i don't think i ever saw it in the docs there
13:58:57 <mauke> aristid: 2007
13:59:02 <mauke> 5.10.0
13:59:07 <aristid> heh
13:59:08 <KirinDave_> globalMillis . read $ qParam "limit" <|> qParam "since" <|> Just (show today)
13:59:37 * monochrom switches to 7.0.3 reluctantly. there are some minor funny bugs
13:59:40 <mauke> aristid: 5.8 is from 2002. time to upgrade maybe :-)
13:59:56 <aristid> mauke: uh, this is not my choice.
14:00:53 <aristid> mauke: on my ubuntu 10.04 machine that i'm using right now i have perl 5.10.1. but i almost never use perl there. when i use perl, it's at my part-time job
14:00:57 <kyagrd> > 4.0**0.5
14:00:58 <lambdabot>   2.0
14:01:04 <kyagrd> > (- 1/0)
14:01:05 <lambdabot>   -Infinity
14:01:10 <kyagrd> > (- 1/0)**0.5
14:01:11 <lambdabot>   Infinity
14:01:15 <kyagrd> tada
14:01:31 <mauke> aristid: 5.10 is also "old"
14:01:41 <mauke> current is 5.12.3, 5.14 has a RC out
14:02:31 <pmetzger> infinity! I wonder if one could teach haskell an axiomatized version of the non-standard reals. not something I should spend time on though.
14:03:06 <shapr> hej Volatile
14:04:03 <aristid> mauke: maybe ubuntu 11.04 has a more recent perl *shrug*. i care much more about having a recent GHC
14:04:32 <luite2> pmetzger: hmm, do they have infinity?
14:05:49 <gwern> so, no further problems with mueval or lambdabot?
14:06:12 <mauke> müval  -- optimized
14:07:00 <NihilistDandy> gwern: Had to tweak my ghc flags a bit (rtsopts and so on)
14:07:06 <NihilistDandy> And now building IOSpec
14:07:24 <NihilistDandy> The messages I'm getting from mueval are informative if nothing else :D
14:07:35 <gwern> is that sarcasm?
14:07:40 <NihilistDandy> No, not at all
14:07:42 <NihilistDandy> It's very helpful
14:08:05 <gwern> oh. it's been a while since I wrote mueval so I don't remember what the error messages are like
14:08:25 <NihilistDandy> "mueval: Most RTS options are disabled. Link with -rtsopts to enable them."
14:08:30 <NihilistDandy> Simple and to the point
14:08:40 <gwern> think that's just GHC.
14:08:47 <c_wraith> Yeah, that's a GHC option
14:08:50 <c_wraith> added in ghc 7
14:09:04 <NihilistDandy> Yeah, I had to do some reading to see the right way to relink it
14:09:06 <olsner> heh, "Is that sarcasm?" "No, not at all." :) I can't help reading that response as sarcasm :P
14:09:18 <NihilistDandy> olsner: I promise it's not. :P
14:09:22 <c_wraith> There are two parts to it.  One sets runtime flags at compile time.  The other one enables setting additional flags at runtime
14:09:42 <gwern> NihilistDandy: it'd be worthwhile to run the tests.sh to see whether ghc 7 broken any protection mechanisms, inidentally
14:10:36 <NihilistDandy> gwern: Shall do.
14:11:15 <Volvic> I'm doing something wrong; I want to read two .txt files, sort the strings of both files (the chars, one .txt file has the chars shuffled) and compare them sorted (like sort "brother" to "behort" and compare). Was able to compare them, but can't find the unscambled ones anymore...
14:11:16 <Volvic> http://pastebin.com/QYYQs3wD
14:11:40 <Volvic> dont know the indices
14:15:06 <bos> does dan doel hang out here?
14:15:36 <pmetzger> luite2: non-standards have both infinitesimal and unbounded numbers.
14:15:38 <monochrom> yes. look for dolio
14:16:22 <pmetzger> luite2: http://en.wikipedia.org/wiki/Non-standard_analysis
14:16:25 <bos> monochrom: thanks
14:16:33 <gwern> Volvic: what's wrong with something like 'do x <- fmap (sort . map sort . lines) $ readFile foo; y <- fmap (sort . map sort . lines) $ readFile bar; print $ union x y'?
14:16:48 <gwern> or do I misunderstand what you want?
14:17:04 <c_wraith> Oh, hey.  SimonPJ got back to me on how to make impredicative polymorphism work in ghc 7.  It still works, but it does less inference than before.
14:17:52 <gwern> er, 'print $ unlines $ union x y'
14:18:51 <bos> trying to figure out how to make vector-algorithms functions operate on immutable vectors.
14:19:11 <conal> ezyang: new comment: http://blog.ezyang.com/2011/05/unraveling-the-mystery-of-the-io-monad/comment-page-1/#comment-2350
14:19:44 <gwern> bos: oh, that's easy, just simulate the mutable updates using Data.Map. that's only a what, log n slowdown? :)
14:19:52 <luite2> pmetzger: ah right, I already suspected that infinitesimals implied unbounded numbers, but wasn't sure
14:19:55 <conal> ezyang: i wonder if i misunderstood the intent of your response.
14:20:07 <monochrom> Volvic: what do you want the program to do? I am still not sure. example? formal specification?
14:20:13 <ezyang> Unclear.
14:20:15 <Nereid> Volvic: why are you using a Set?
14:20:20 <monochrom> "compare" is very open-ended
14:20:20 <pmetzger> there are both finite and non-finite numbers in the non-standards.
14:20:29 <Nereid> why not sort . map sort $ words list
14:20:38 <Volvic> simply to sort them
14:20:51 <monochrom> going through Set has the benefit of weeding duplicates
14:20:59 <gwern> Nereid: there's a lot of ways to do it, that was just what was easy to type :)
14:21:03 <bos> i think i need create (thaw >>= sort)
14:21:06 <ezyang> For example, for your specific example, the correct answer is "Stop using IORefs and go use STM"
14:21:40 <ezyang> I am intending to be descriptive, but that doesn't mean the questions you ask aren't valid.
14:21:52 <ezyang> I was planning on sleeping on it and composing an answer tomorrow :-)
14:21:57 <Nereid> Volvic: it's not "obvious" that Set.toList . Set.fromList sorts the list
14:22:00 <Volvic> I think what gwern did is what I wanted
14:22:09 <conal> ezyang: that answer (use STM) would not come from a (mistaken) belief that IO = State World.
14:22:15 <Nereid> anyway, you still want to keep track of indices?
14:22:32 <ezyang> True.
14:23:17 <conal> ezyang: and i don't know whether STM has a denotation either. i expect not, which means that similar confusions/bugs would arise.
14:23:21 <Nereid> Volvic: ?
14:23:42 <Volvic> what is the question?
14:23:46 <Nereid> or
14:23:50 <ezyang> Mmm, I think they did come up with a denotational semantics for STM in the paper, but I'd have to look it up.
14:23:50 <Volvic> Find the original (unscrambled) words, which were randomly taken from a wordlist.<-- Send a comma separated list of the original words, in the same order as in the list below.
14:23:54 <jmcarthur> STM is probably at least a bit easier to come up with a denotation for since it is so much more restricted.
14:24:01 <Nereid> Volvic: right
14:24:04 <Volvic> thats what I wannt to do
14:24:05 <Nereid> so maybe instead of just scramboling
14:24:12 <Nereid> you want a list of pairs [(String, String)]
14:24:20 <Nereid> where the first String is the sorted one, and the second is the original
14:24:21 <Nereid> or something
14:24:31 <c_wraith> ezyang: did you ever settle whether "x `seq` return x" is incorrect when all you want to do is ensure that x is evaluated?
14:24:36 <Nereid> and then you can sort such a list using sortBy (comparing fst)
14:24:37 <Nereid> or something
14:25:19 <conal> jmcarthur: could be. perhaps except for defining what 'atomically' means.
14:25:45 <Nereid> (actually, just sort would do it too)
14:25:50 <monochrom> Volvic: is that for programming contest practice?
14:26:14 <Nereid> > sortBy (comparing fst) [(3,'a'), (1,'b'), (4,c'), 2,]
14:26:15 <lambdabot>   <no location info>: parse error on input `]'
14:26:18 <Nereid> > sortBy (comparing fst) [(3,'a'), (1,'b'), (4,c'), (2,'d')]
14:26:19 <lambdabot>   Not in scope: `c''
14:26:22 <Nereid> > sortBy (comparing fst) [(3,'a'), (1,'b'), (4,'c'), (2,'d')]
14:26:22 <Volvic> It's the first programming challenge from http://www.hackthissite.org/missions/prog/1/
14:26:23 <lambdabot>   [(1,'b'),(2,'d'),(3,'a'),(4,'c')]
14:26:29 <Nereid> noo stop pressing enter when you haven't finished typing :(((
14:26:45 <jmcarthur> maybe 'atomically' could be defined in terms of a simple (not comprehensive) model of IO
14:26:49 <mauke> "You must be logged in to use this page."
14:27:14 <conal> jmcarthur: maybe so.
14:27:21 <gwern> @quote
14:27:21 <lambdabot> Olathe says: binary search on linked lists is the work of SATAN !
14:27:26 <gwern> Nereid: well, it's not obvious that it does so, but it's a useful haskell trick to know - faster than sort if you don't need stability, iirc
14:27:48 <Nereid> gwern: there's unstableSort too ;)
14:27:52 <Nereid> which is also faster than sort
14:27:53 <gwern> there is?
14:27:55 <Nereid> yes
14:27:59 <roconnor> ezyang conal: State as such has little to do with IO as GHC core is a strict functional langauge with side-effects.
14:28:00 <gwern> @hoogle unstableSort
14:28:00 <lambdabot> No results found
14:28:01 <Nereid> Data.Sequence
14:28:10 <Nereid> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html#v:unstableSort
14:28:13 <Nereid> wait
14:28:14 <Nereid> wait
14:28:16 <gwern> pfft, who wants the overhead of Seq
14:28:18 <jmcarthur> roconnor: let is not lazy in core?
14:28:23 <Nereid> I just noticed that.
14:29:08 <NihilistDandy> Success!
14:29:13 <conal> roconnor: i don't understand. can you restate in terms of language & semantics rather than implementation notions (like GHC core)?
14:30:07 <roconnor> conal: isn't the topic at hand GHC core?
14:30:14 <Nereid> gwern: in that case, one might want to separately define unstableSort = Set.toList . Set.fromList
14:30:34 <aristid> roconnor: core is actually a strict language?
14:30:57 <conal> roconnor: not that i noticed. we were talking about the persistent myth that IO = State World
14:31:04 <roconnor> aristid: maybe I'm wrong about strictness
14:31:11 <jmcarthur> roconnor: i think conal took ezyang's explanation of the implementation of IO in GHC as though he intended it to be a model, and then ezyang ran with it when it was brought up
14:31:23 <roconnor> conal: I don't think ezyang's post was about that myth.
14:31:36 <monochrom> Volvic: in the wordlist (wordlist.txt), does every word appear at most once?
14:31:38 * conal looks again
14:31:53 <jmcarthur> the first occurrence of "model" on that page is conal's first comment
14:32:04 <Volvic> yes
14:32:16 <Volvic> exactly once
14:32:26 <conal> "As a prelude to the IO monad, we will briefly review the State monad, which forms the conceptual basis for the IO monad (indeed, the IO monad can be thought of as merely the strict State monad with a special form of state.)"
14:32:33 <kmc> yeah ugh
14:32:37 <jmcarthur> yeah i just read that
14:32:46 <jmcarthur> "conceptual basis" sounds a lot like "model"
14:33:03 <kmc> GHC's implementation of IO looks a little bit like State RealWorld until you lean in close to take a look and then it punches you
14:33:28 <roconnor> conal: Ah, that is bad.
14:34:11 <conal> i suppose ezyang could have just added "incorrectly", as in "the IO monad can be *incorrectly* thought of as merely the strict State monad with a special form of state." ;)
14:34:33 <conal> because of course IO can be thought of as IO State. lots of wrong things can be thought of.
14:34:37 <olsner> aristid: I'm not sure, but I think core is strict because it is explicit when operating on thunks, forcing them and creating them
14:35:19 <dmwit> Maybe more constructive would be pointing out a few of the things that make IO not a State RealWorld.
14:35:24 <dmwit> I know I'd be interested.
14:35:31 <aristid> olsner: which allows optimization passes to remove unnecessary create/force cycles?
14:35:39 <danharaj> I like to think of these things as taylor expansions.
14:35:41 <roconnor> dmwit: forever (print "forever")
14:35:47 <danharaj> IO is State RealWorld up to O(n^2) terms :p
14:36:02 <conal> dmwit: see my first comment.
14:36:12 <conal> "What confuses me about this story is that State is a model of *purely sequential*, determinstic computation, while IO has two forms of nondetermistic concurrency: forkIO (concurrent threads) and interaction (program/world concurrency)."
14:36:31 <roconnor> conal: you don't even need to get into forkIO to find problems with State as a description of IO
14:37:03 <conal> roconnor: nor interaction with the world?
14:37:24 <dmwit> roconnor: I admit I'm a bit dull. How does your forever example explode?
14:37:44 <conal> roconnor: ah. the forever example.
14:38:19 <roconnor> dmwit: according to the state explaintion forever (print "foo") must be bottom, but it is clearly different from bottom.
14:38:35 <conal> roconnor: if you could turn that example into a precise & succinct argument, it might help dispel the myth.
14:38:52 <roconnor> ya, I've had trouble doing that in the past :/
14:39:04 <xAndromeda> sorry to disturb but every time i create a new package in leksah it uses the hello world template, is there any way to change it to a blank/more generic one?
14:39:06 <roconnor> Perhaps someone smarter than me can make it blindingly clear
14:39:44 <dmwit> I dunno. The State explanation doesn't clearly make that bottom.
14:39:46 <jmcarthur> there is a point of view from which is it bottom
14:39:52 <jmcarthur> *it is
14:40:24 <dmwit> It looks like it is pleasantly productive (depending on how RealWorld is defined, I suppose).
14:40:25 <conal> roconnor: so many of these hand-waving arguments turn out to be bogus. i'm unsure about yours.
14:40:26 <roconnor> dmwit: it's true that it isn't clearly bottom, but it is bottom.  I wish I knew a clear explaintion as to why it is bottom.
14:40:32 <jmcarthur> hmm i'm wrong
14:41:12 <conal> roconnor: do you blog? may be a good place to start clarifying that forever/print argument.
14:41:12 <dmwit> > execState (forever (modify ("forever":))) []
14:41:16 <lambdabot>   mueval-core: Time limit exceeded
14:41:25 <dmwit> Ah!
14:41:30 <dmwit> Perhaps I'm beginning to see the light.
14:41:42 <applicative> xAndromeda, maybe someone is away in #leksah? Though from the look of things they'd be awake here too...
14:41:46 <roconnor> conal: to be more precise forever (print "foo") is something less than const _|_
14:41:52 <dmwit> > execState (forever (modify (++["forever"]))) []
14:41:56 <lambdabot>   mueval-core: Time limit exceeded
14:42:00 <roconnor> conal: if it weren't for seq, that would be the same as _|_
14:42:01 <dmwit> :t execState
14:42:03 <lambdabot> forall s a. State s a -> s -> s
14:42:16 <olsner> hmm, this reminds me of an explanation of codata vs data I read (but never quite understood :P)... the forever example is "productive" since it prints infinite "foo", and this is different from a bottom that does nothing useful
14:42:38 <conal> roconnor: does dmwit's formulation capture the semantics of print that you have in mind?
14:42:47 <roconnor> conal: I should go over my haskell IRC logs from last time I discussed this
14:42:50 <olsner> in the same way that an operating system main loop is not bottom even though it loops forever
14:42:53 <jmcarthur> roconnor: in a sense it is bottom because IO doesn't give you an opportunity to read out the value of RealWorld at the end of execution anyway
14:43:06 <roconnor> jmcarthur: yes
14:43:19 <conal> roconnor: i was just thinking the same. iirc, i was skeptical at the time and came to see your point.
14:43:28 <aristid> jmcarthur: and that's where the analogy becomes totally useless
14:43:43 <jmcarthur> aristid: analogies are almost always useless
14:43:52 <roconnor> I think I came up with an equation that showed that it must be bottom
14:44:00 <aristid> jmcarthur: just like generalisations!
14:44:10 <olsner> (and this has apparently been used to argue that total languages cannot be used to write operating systems)
14:44:43 <jmcarthur> aristid: i think i phrased that fairly precisely rather than generally
14:44:44 <roconnor> olsner: fortunately that argument doesn't quite hold water.
14:44:47 <conal> roconnor: how do you then argue that _|_ doesn't agree with IO?
14:45:00 <conal> roconnor: i'm guessing you have to posit an *concurrent* observer.
14:45:03 <luite2> microsoft knew this and made windows 95 hang after 49.7 days
14:45:09 <aristid> jmcarthur: did you? "analogies" is a pretty broad category
14:45:18 <roconnor> conal: becaues forever (print "foo") is observationally different from undefined.
14:45:34 <roconnor> s/undefined/fix id
14:45:46 <conal> roconnor: it depends on what's observable, doesn't it? and particularly, *concurrent* observation.
14:46:13 <conal> roconnor: i'm prodding to see whether there really is an argument for IO /= State World that doesn't involve some form of concurrency.
14:46:19 <roconnor> conal: in one case I see "foo" printed forever, and in the other I don't.
14:46:36 <roconnor> clearly these are different values
14:46:39 <conal> whether between threads or between thread & external agent (e.g. roconnor)
14:46:49 <roconnor> and it would be erronous for me to substitute one for the other and expect the program to be the same.
14:46:55 <conal> roconnor: i know it's clear. i want to find out whether it's true.
14:47:07 <olsner> how can you see foo printed forever except by watching the final RealWorld value that contains the infinite stream of "foo"?
14:47:13 <conal> roconnor: or really, under what assumptions it's true. e.g. concurrency
14:47:21 <jmcarthur> aristid: i'm taking "analogy" to mean "similarity," which in my experience is usually too vague to be meaningful. a mere similarity between two things does not equate them, yet people take analogies as if they were models
14:47:25 <acowley> the Communicating Sequential ROconnor model of computation
14:47:46 <conal> "clearly" often hides assumptions.
14:47:46 <aristid> jmcarthur: which does not imply they cannot be useful
14:47:54 <jmcarthur> i didn't say they cannot be useful
14:48:00 <danharaj> what is the value of forever (print "foo") >>= return?
14:48:26 <aristid> jmcarthur: you said they are "almost never" useful, which is only slightly less strong
14:48:27 <roconnor> conal: All I think I can argue is that forever (print "foo") and forever (print "bar") are different programs, and if someone presents a semantacts that equates the two (such as State Whatever) then I'd argue that is a bad model.
14:48:36 <frerich_> I'm trying to compute a list of 'unique divisors' (I have no idea what the correct term is). Instead of [6,5,4,3,2,1] I want [6,5,4] since '3' evenly divides 6, '2' evenly divides 6 and 3 and '1' evenly divides everything. To do so, I tried to define a recursive list, like this: http://hpaste.org/46370/uniquedivisors
14:48:38 <roconnor> conal: but I don't see how I can prove that it is a bad model
14:48:45 <rata_> hi
14:48:47 <roconnor> conal: maybe I define IO a = ()
14:48:50 <frerich_> Unfortunately, I did something wrong All the list functions fall over that list (e.g. 'head' on the list never returns)
14:48:52 <roconnor> that is a model of IO, right?
14:48:52 <conal> roconnor: which means you wouldn't argue it, you'd just claim it. right?
14:48:54 <acowley> danharaj: An action that prints "foo" forever
14:49:08 <aristid> :t nubBy -- frerich_
14:49:09 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
14:49:13 <jmcarthur> aristid: it's not objectively provable, but i disagree that it's a sweeping generalization (which i assume is what you meant by "generalization")
14:49:19 <roconnor> danharaj: f >>= return = f
14:49:40 <conal> roconnor: sry. i don't mean to be an ass here. i think you & i are looking for the same thing: a rigorous & simple argument.
14:49:41 <frerich_> aristid: Ah, that looks interesting
14:49:42 <dmwit> roconnor: I guess it depends a lot on how you define observation.
14:49:59 <aristid> jmcarthur: that, and i love the how "all generalisations" is a generalisation itself.
14:50:03 <roconnor> conal: how would you rigerously show that IO a = () is a bad model of IO?
14:50:14 <roconnor> dmwit: same with you
14:50:20 <roconnor> let's make it easy to start :D
14:50:21 <dmwit> roconnor: Absolutely.
14:50:34 <dmwit> roconnor: I haven't defined anything yet, and I know exactly why. =P
14:51:01 <dmwit> frerich_: Ask yourself: should 6 be in the "divisors" list?
14:51:21 <dmwit> frerich_: In particular, what do you think of the expression "all (\d -> d `mod` x /= 0) divisors" when "d" is 6?
14:51:26 <conal> roconnor: perhaps start with a (precise) model of observation?
14:51:32 <dmwit> Remember that we haven't yet decided whether 6 is in divisors or not yet.
14:51:36 <frerich_> dmwit: Well my idea was: Yes, since no element in the existing list (which happens to be empty at this point) evenly divides 6.
14:51:47 <roconnor> conal: sounds reasonable
14:51:52 <dmwit> frerich_: I'm asking you to answer based on your code, not based on your intuition. =)
14:51:56 <conal> roconnor: and i guess observation would have to be *concurrent*
14:52:00 <roconnor> conal: reminds me of coalgebraic semantics
14:52:02 <dmwit> frerich_: Trying to do so will help you understand why it's an infinite loop. =)
14:52:28 <roconnor> conal: I think you could define sequential observations if you wanted to.
14:52:28 <dmwit> frerich_: (And how to fix it, maybe.)
14:52:39 <olsner> conal: is concurrency required though? how about just allowing interleaving? (or maybe those are equivalent)
14:52:39 <conal> roconnor: since w/o concurrency, i think your forever example would be exactly bottom
14:52:50 <roconnor> conal: I think that isn't true
14:53:27 <olsner> intuitively, I think >> on IO is special because it allows other things to happen to the world before continuing
14:53:28 <roconnor> conal: the observations of my forever example should be an infinite stream (coinductive type) of "foo" strings.
14:53:31 <dmwit> roconnor: I guess by "concurrency", conal means the two threads might be "roconnor" and "roconnor's computer".
14:53:41 <olsner> while State does not allow anything to happen there
14:53:47 <conal> i'd love to see a counterargument that doesn't need concurrency
14:53:50 <frerich_> dmwit: It seemed to me that 'all' returns True for empty lists, so 'all (\d -> d `mod` x /= 0) divisors` would yield true, so 'x' should get included in the list.
14:53:52 <conal> dmwit: exactly.
14:54:23 <conal> dmwit: as in "while IO has two forms of nondetermistic concurrency: forkIO (concurrent threads) and interaction (program/world concurrency)."
14:54:24 <dmwit> frerich_: But we don't know whether or not "divisors" is empty yet.
14:54:49 <dmwit> frerich_: To decide what "all" should return, we must first know whether "divisor"'s first constructor is (:) or [], and we haven't decided that yet.
14:54:54 <frerich_> dmwit: Ah, I think I get it, so it has to evaluate 'divisors' again, which is an endless recursion.. I somehow still had an imperative mindset.
14:55:05 <conal> olsner: exactly! State World doesn't allow the world to change mid-computation.
14:55:12 <conal> olsner: while IO does.
14:55:15 <frerich_> dmwit: I was thinking that on the first 'x' it's empty, on the second it's [6], and so on.
14:55:18 <monochrom> Volvic: http://hpaste.org/46371/word
14:55:23 <ezyang> c_wraith: We suspect that should be fine, modulo inliner wonkiness.
14:55:38 <c_wraith> ezyang: good.  I've done it a few times. :)
14:55:58 <rata_> please could anybody help me with this program? https://gist.github.com/955853 it's consuming more than 500mb of memory
14:56:02 <dmwit> frerich_: Yeah, it took me a few seconds of staring at your example to convince me that I believed you, too. =D
14:56:08 <rata_> I've tried some fixes but nothing have helped
14:56:16 <dmwit> rata_: Have you tried giving a smaller heap?
14:56:31 <shapr> What's the Haskell solution to something like Python's fabric for automatic web application deployment?
14:56:33 <rata_> dmwit: no, how do I do that?
14:56:33 <dmwit> (i.e. does it really consume 500mb of memory, or does it just look like it because the GC is so darn lazy?)
14:56:45 <jmcarthur> a concurrent model of IO gets pretty complicated when you consider that IO actions can't even be broken down into atomic units. you pretty much have to have a continuous-time semantics for it
14:56:57 <dmwit> rata_: Something like adding command line arguments "+RTS -H10M" or something like that. "+RTS -?" should tell you more
14:57:07 <jmcarthur> shapr: what does fabric do?
14:57:25 <conal> jmcarthur: are you using "concurrent" to mean something other than nondetermistic interleaving?
14:57:38 <dmwit> rata_: The next step after that is to learn about profiling and do it a bit.
14:57:47 <olsner> shapr: hmm, is "fabric" a name, rather than a "fabric for ... deployment"?
14:57:47 <dmwit> rata_: There are some great tools on Hackage.
14:57:48 <Volvic> wow cool thx, short and works
14:58:01 <shapr> olsner: Yes, it's an actual tool name.
14:58:05 <twobitsprite> http://hpaste.org/46372/readbin
14:58:13 <jmcarthur> conal: yes
14:58:20 <twobitsprite> I've looked this over and over and can't figure out why it's expecting an Int
14:58:25 <ezyang> Yeah, you don't even get that much out of IO, unfortunately :-(
14:58:35 <dmwit> :t readInt
14:58:35 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
14:58:45 <conal> jmcarthur: ah. like *really* concurrent/simultaneous, as in FRP?
14:58:49 <shapr> jmcarthur: It appears to automate "test && git commit" and "tar czf webapp.tar.gz gitrepo/ && scp webapp.tar.gz webserver:/var/www-data/" and adds failure handling.
14:58:51 <jmcarthur> conal: in GHC, forkIO is not just nondeterministic interleaving
14:58:53 <ezyang> Reading over this conversation (was afk for a bit), I see I've done something very bad by comparing IO to strict State RealWorld :-)
14:58:58 <jmcarthur> conal: because it can use multiple core
14:59:06 <twobitsprite> yeah, looks to me like the inferred type "Char -> a" should match that "(Char -> Int)" in the 3 arguments
14:59:11 <jmcarthur> *cores
14:59:15 <conal> jmcarthur: ah.
14:59:28 <olsner> jmcarthur: can you tell the difference though?
14:59:40 <monochrom> twobitsprite: "toBinChar c = read . (:[])" has spurrious "c"
14:59:49 <rata_> dmwit: do I compile the program with those options?
14:59:53 <twobitsprite> monochrom: ahh ha
15:00:04 <jmcarthur> conal: but yes, i have a suspicion that an accurate model for IO *might* lead us in a similar direction to dctp
15:00:08 <conal> jmcarthur: if two computations interact (e.g. use the same refs), those interactions will serialize, won't they?
15:00:08 <twobitsprite> monochrom: misdirected by bad error messages
15:00:11 <twobitsprite> thanks
15:00:18 <jmcarthur> hmm
15:00:24 <ezyang> conal: Depends on your definition of "ref"
15:00:25 <monochrom> I disagree. I found it by the error message
15:00:26 <conal> jmcarthur: in other words, lead us *away from IO*?
15:00:29 <ezyang> IORef will give you that guarantee.
15:00:44 <monochrom> "In the third argument of `readInt', namely `toBinChar'"  therefore I carefully scrutinize toBinChar
15:00:45 <ezyang> But, say, a memcpy to some range of memory, might not.
15:00:47 <dmwit> rata_: No, run it with those arguments.
15:01:05 <conal> ezyang: i see.
15:01:15 <jmcarthur> conal: what i'm getting at is that even GHC primitives aren't atomic
15:01:20 <jmcarthur> not all of them, anyway
15:01:26 <conal> jmcarthur: sure.
15:01:49 <ezyang> Another way to approach this problem is this way: when we bring in FFI code, we usually start off with no denotational guarantees, and need to work very hard (sometimes it's impossible) to get the guarantees associated with pure code.
15:01:51 <jmcarthur> i suppose a model could break them down further though...
15:02:03 <monochrom> people impeach the fine error message when what they need is a fresh pair of eyes (to look at the fine error message)
15:02:14 <ezyang> So, is there a middle ground, not as rigid as pure, that still has nice denotational properties?
15:02:25 <rata_> dmwit: it's the same
15:02:26 <ezyang> Right now, the usual thing to do is define your own monad.
15:02:31 <twobitsprite> monochrom: I suppose... but I still think the error message was ambiguous, even if it is technically correct
15:02:48 <dmwit> rata_: Does it crash with a heap smaller than 500MB? If not, then it's not actually using 500MB.
15:02:59 <twobitsprite> because the third argument to readInt *was* "Char -> a", not Int
15:03:17 <conal> ezyang: i think so.
15:03:19 <twobitsprite> but ohh well
15:03:28 <rata_> dmwit: it consumed the same amount of memory
15:03:37 <monochrom> oh, "inferred" vs "expected" is not a sweet story, I agree
15:03:37 <conal> my guess is that if we really cared about understanding & reasoning about our programs and if the intractability of IO were acknowledged, the community would get back to work looking for alternatives, which has been roughly stalled since the 80s. which is why i agitate.
15:04:03 <dmwit> rata_: What I'm getting at is that, although the total amount of memory may be high, that doesn't necessarily indicate that all of that memory is going towards live values.
15:04:03 <monochrom> should just say "couldn't match Int against Char->a" end of story
15:04:15 <ezyang> Whoo local optimimum :-)
15:04:20 <dmwit> rata_: You may have no memory leak; instead, you may just be misunderstanding what garbage collection does.
15:05:45 <dmwit> rata_: Also, you should definitely have read the information in "+RTS -?", because I slipped you some misinformation.
15:05:47 <rata_> dmwit: I think I understand your point... the problem is -H10M is not making haskell consume less than 10M
15:05:57 <acowley> rata_: how are you judging memory consumption?
15:06:03 <dmwit> I'd like to claim it was on purpose, to see if you actually RTFM, but it was just a mistake. =P
15:06:05 <rata_> acowley: htop
15:06:18 <jmcarthur> conal: if two IO threads interact with the same human observer, i don't think that forces them to serialize
15:06:19 <acowley> rata_: You can try running with +RTS -t to see residency
15:06:28 <dmwit> rata_: Try -M10M instead, which sets the maximum heap size, rather than setting the minimum heap size as -H10M does. =P
15:07:02 <dmwit> ?slap dmwit
15:07:03 * lambdabot would never hurt dmwit!
15:07:22 <rata_> dmwit: heap exhausted
15:07:29 <dmwit> Great.
15:07:33 <conal> jmcarthur: i'm thinking of atomically writable memory locations causing serialization. maybe corresponds to individual neurons or some such.
15:07:41 <dmwit> Then the next step is profiling.
15:07:47 <Volvic> Why do only a few people use haskell?
15:07:58 <conal> jmcarthur: or perhaps neurons are more flexible and can handle simultaneous writes/stimulation.
15:08:13 <djahandarie> Volvic, what gives you that impression? I'd say that isn't true.
15:08:22 <djahandarie> I guess it depends on what you consider 'a few'.
15:08:22 <conal> jmcarthur: anyway, as you can see, it's not a very precise idea.
15:08:54 <ezyang> I wonder if hardware description languages have the right idea.
15:09:08 <Volvic> Most people I know don't know haskell and there arent many librarier for it, like game engines
15:09:23 <conal> jmcarthur: and the possibility of actual simultaneity in addition to interleaving probably strengthens the argument against IO = State World
15:09:26 <monochrom> "why do fewer people use haskell" has the same answer as "why do fewer people use chinese"
15:09:58 <dmwit> Eh, not really. Since the answer to "Why do fewer people use Chinese?" is "That's plain wrong.".
15:09:58 <djahandarie> Volvic, it has only picked up speed in the industry fairly recently.
15:10:02 <ezyang> I've reworded the bad statement to "As a prelude to the IO monad, we will briefly review the State monad, which forms the operational basis for the IO monad (the IO monad is implemented as if it were a strict State monad with a special form of state, though there are some important differences—that’s the magic of it.)" Still not 100% happy with it though...
15:10:04 <c_wraith> Wait, I thought chinese was the most spoken language on the planet.
15:10:21 <saati> there is no such language
15:10:25 <shapr> Volvic: Because only a few people use computers ;-)
15:10:35 <conal> Volvic: perhaps also because haskell (other than IO) requires clear thinking, which is hard
15:10:36 <shapr> Volvic: But seriously, do you have specific questions about Haskell?
15:10:37 <monochrom> and answer: 1. not really true, but ok; 2. cultural; 3. status quo; 4. humans are extremely ignorant of their choices
15:11:31 <djahandarie> Volvic, a lot of individual groups and people are working on games in fact, but I agree that not much is available for new people trying to make a game in Haskell.
15:11:32 <monochrom> there is no technical-merit reason why ___ is more popular or less popular. it's all and only social dynamics
15:11:42 <ezyang> monochrom: Disagree.
15:11:42 <Volvic> other programming languages don't require clear thinking?
15:11:44 <conal> in contrast, when i program in C/Java/etc, a lot of the time i'm just wrangling details.
15:12:14 <conal> Volvic: maybe "clear & deep" better captures what i was trying to say.
15:12:20 <monochrom> oh? what other factors do you propose? do they really have influence?
15:12:34 <jmcarthur> i think it's the other way around. haskell doesn't require clear thinking. it enables it.
15:12:41 <Tyr42> Succinctness?
15:12:44 <djahandarie> Volvic, but as conal says, writing Haskell 'the right way' (avoiding the IO monad) can be tough, but people try to do it because it often ends up nicer. Which occasionally results in stuff not getting done :p
15:12:47 <conal> Volvic: ie clear thinking at the *essence* of the problem, rather than about inessentials imposed by the language.
15:12:57 <rata_> acowley: what should I read in that line?
15:12:59 <jmcarthur> but either way, people aren't usually used to the discipline of thinking clearly
15:13:00 <danharaj> Volvic is right in that Haskell library support for game development is pretty terrible beyond bare bindings to relevant C libraries.
15:13:09 <conal> djahandarie: not getting done. yeah. i relate to that point! :)
15:13:12 <danharaj> Quite a few of us are trying to fix that. We're in #haskell-game
15:13:22 <ezyang> monochrom: It's for the same reason why popular scientific research programs aren't entirely due to social reasons.
15:13:22 <Tyr42> Also, proving stuff about your code.
15:13:23 <dmwit> And everybody knows that the only use of programming languages is to build games. ;-)
15:13:25 <danharaj> Pastorn is leading the charge :p
15:13:28 <conal> "A moment's thought would have shown him.  But a moment is a long time, and thought is a painful process." - J. E. Houseman
15:13:31 <ezyang> It is social, yes, but not entirely.
15:13:35 <acowley> rata_: the avg/max bytes residency
15:13:36 <monochrom> game development doesn't seem to support a large number of jobs to begin with
15:13:47 <jmcarthur> jobs schmobs
15:14:30 <danharaj> Since game development tends to require library support from quite diverse domains, I think it's a fair indicator of the richness of the ecosystem of a language.
15:14:38 <thjohnson> jobs are one of those 'social factors' mentioned previously
15:14:45 <danharaj> Fore example Haskell has hardly any OpenGL support above C bindings :p
15:14:50 <Volvic> Besides openGL there is nothing for 3d game development available, is there?
15:14:57 <thjohnson> jobs and the educational programs which often lead to them
15:14:58 <shapr> danharaj: I'm not convinced, mostly because Linux doesn't have many games available.
15:15:04 <lispy> danharaj: I'm not sure about that.  What about Gloss?
15:15:05 <monochrom> alright, restrict my over-generalization to just choice of programming languages. then it's social dynamics only. sometimes social dynamics among managers.
15:15:11 <lispy> danharaj: and Gpipe?
15:15:24 <shapr> Volvic: Do you mean "in Haskell" or "in any computer" ?
15:15:26 <ezyang> monochrom: Still diagree.
15:15:30 <ezyang> *disagree
15:15:36 <Volvic> in haskell
15:15:41 <rata_> acowley: ~ 25M/100M (with -M100M)
15:15:47 <ezyang> Mostly because I believe it is possible to have a rational conversation between two managers about what language should be used in a project.
15:15:58 <acowley> Most games are written in one of a small number of languages. Why pick on Haskell for this when it's true of virtually every language?
15:16:01 <shapr> Volvic: I've seen several games written in Haskell, raincat comes to mind immediately.
15:16:08 * ezyang is being very philosophical right now 
15:16:24 <thjohnson> ezyang: but what will those managers be discussing?
15:16:25 <lispy> Would a weekly blog entry or weekly video blog entry about 1 specific haskell library (so, hackage journalism) be useful in this community?  Would people care?
15:16:25 <danharaj> lispy: Stop making my ignorance apparent. :p Gloss is a good example of a well supported library, but GPipe is experimental and isn't really actively supported at the moment, no?
15:16:37 <acowley> rata_: so that confirms that the GC really did have to walk over 100M of live data
15:17:00 <jmcarthur> lispy: as long as they get turned into wiki pages
15:17:02 <lispy> danharaj: Not sure about the details of Gpipe.  I never tried it.
15:17:11 <jmcarthur> i have used gpipe
15:17:16 <jmcarthur> it has its problems
15:17:19 <ezyang> Oh man! That would be an awesome new wiki system.
15:17:28 <lispy> jmcarthur: hmm...what about the wiki makes it useful from your perspective?
15:17:41 <rata_> acowley: yeah, that's my problem... I don't know how to generate a list and garbage-collect it as soon as each element is generated
15:17:44 <ezyang> Blogs that feed into a wiki. You get to develop reputation, and then you get to outsource keeping the information up to date...
15:17:44 <jmcarthur> lispy: because a blog isn't not a very handy reference
15:17:52 <lispy> jmcarthur: normally reviews like that are written by the author and posted somewhere
15:17:54 <jmcarthur> *is not
15:18:01 <thjohnson> ezyang: wouldn't it be mostly issues which could be summed up as 'social factors'? what kinds of libraries are already available; how easy is it to hire (adequate, cheap, etc...) programmers
15:18:02 <Volvic> But I think haskell has the nicest community
15:18:04 <shapr> lispy: Also because I can't fix a blog post
15:18:14 <acowley> rata_: I think something is holding on to your list, it's not just the GC being lazy
15:18:17 <lispy> jmcarthur: and I was leaning towards making them video or audio based
15:18:28 <ezyang> thjohnson: "Choose between X and Y. None of the developers on my team know Y. Therefore X."
15:18:40 <procyon112> Sooo... using attoparsec to parse png files.  Have a block of 4 bytes with the CRC of another block.
15:18:42 * lispy doesn't know if he can find time for this project.  It's very much in the "hmm..." phase.
15:18:45 <jmcarthur> lispy: sounds like an experiment
15:18:45 <ezyang> ah, so you want to discount rational social factors.
15:19:04 <shapr> procyon112: yah?
15:19:07 <ezyang> thjohnson: "We're building an embedded system, better not use Python"
15:19:08 <danharaj> acowley: I think Haskell would be the best language for indie game development if it got the right libraries.
15:19:16 <lispy> Also not sure what wiki I would put these one.  Haskell wiki is too hard to edit.
15:19:20 <thjohnson> ezyang: no, I just want to count them as social factors
15:19:41 <ezyang> I think that's a very clear technical factor.
15:19:48 * lispy doesn't enjoy fighting a captcha system as a registered user.
15:19:49 <rata_> acowley: but I'm discarding the generated list immediatly with "do genList; return ();"
15:19:53 <procyon112> What would be nice would be something like (crc, structure) <- split parseCRC parseStruct
15:19:59 <acowley> I don't know that it really is a libraries issue
15:20:07 <procyon112> so that the stream is consumed without backtracking
15:20:17 <shapr> lispy: Huh? HaskellWiki is hard to edit? :-/
15:20:19 <monochrom> ezyang: when two managers of galois.com have rational discussions and make rational choices, you are right that it is possible, but this does not lead to popular or majority on the global scale. when this ideal scenerio becomes the minority, when you wonder why more managers elsewhere don't do it, you are looking at social dynamics
15:20:32 <lispy> shapr: yes.  It's a pain.  I avoid the haskell wiki whenever I can. :(
15:20:40 <shapr> lispy: What's difficult?
15:20:50 <procyon112> Is something like this possible, or do I need to pull the entire block, CRC it, then run that bytestring as a sub parser?
15:20:54 <ezyang> monochrom: OK, you've modified your thesis. Global choices in programming languages are due entirely to social factors.
15:21:03 <lispy> shapr: The last time I wanted to edit a page there I had to skip 6-7 captchas just to find one I could read with confidence.
15:21:15 <monochrom> have I modified my thesis?
15:21:21 <jmcarthur> and captchas have been seen with unicode characters...
15:21:35 <ezyang> Mmmm.... I still don't believe it. What does this "globality" mean? If it's just some social construct, then what you've said seems to be tautologically true.
15:21:39 <thjohnson> ezyang: I don't want to say that there are *no* technichal factors. there are probably some. But I think monochrom's statement was a fair rhetorical flourish
15:21:43 <acowley> On the one hand, game developers are reluctant to embrace new technologies that may be somewhat less inefficient (see: holding on to ASM, then holding on to C, then holding on to C++). On the other hand, game developers do chase audiences, so they went after flash for its ease of deployment and now Objective-C for its built-in iAudience.
15:21:44 <ezyang> monochrom: Well, my interpretation of it has changed.
15:21:47 <Kaidelong> figured I'd report that haskell-mpi works like a charm and people who want to do distributed programming should take a look at it
15:21:49 <ezyang> As I said, I'm being philosophical.
15:21:54 <jmcarthur> i think this conversation on management should go to -blah
15:22:10 <ezyang> :-)
15:22:14 <ezyang> I'm going to bed anyways ;-)
15:22:15 <monochrom> the original subject was "Why do only a few people use haskell?", exact wording. I have always assumed it meant globally.
15:22:37 <aristid> haskell is one of the more popular languages on github
15:22:47 <Taslem> Does it make sense for a function to take different number of arguments, so long as its type remains the same? As in:  f (Just x) = Just (x + 1); f = id;
15:22:48 <djahandarie> acowley, Haskell does have garbage collection issues though.
15:23:02 <applicative> lispy, I think it's a great idea.
15:23:03 <thjohnson> ezyang: if we want to get super-philosophical, computers/languages/etc... are all socially designed and therefore all design decisions are down to 'social factors' :P
15:23:05 <djahandarie> Which can be bad in the rendering loop of a game.
15:23:11 <aristid> Taslem: it's not valid
15:23:12 <acowley> danharaj: I think Haskell doesn't have many game devs at the moment because its deployment story is little (any?) better than C or C++, and it takes work for Haskell to match those languages' performance
15:23:14 <kmc> Taslem, you can't write it that way, due to a somewhat arbitrary limitation
15:23:20 <kmc> Taslem, but the function you mean is well-defined
15:23:21 <Kaidelong> djahandarie: Aren't there ways to work around it in practice?
15:23:28 <shapr> lispy, jmcarthur: sounds like HaskellWiki captcha should be changed?
15:23:30 <kmc> in this case just write "f = fmap succ"
15:23:38 <lispy> applicative: Which parts of the idea are important to you?  That's it's a weekly review or the way the information is communicated/presented?
15:23:41 <djahandarie> Kaidelong, afaik that 'way' is to write your rendering loop in C. :p
15:23:47 <djahandarie> I may be ignorant here though.
15:23:50 <acowley> djahandarie: I think that's a factor, but not the whole story
15:23:54 <lispy> shapr: Or replaced by https
15:23:59 <Kaidelong> Mmm, I thought Haskell had some ways to enforce sharing through mutable state
15:24:02 <monochrom> I promise I don't abuse "social dynamics" semantically. I mean things like follow-the-herd, hearsay, networking effect.
15:24:11 <lispy> shapr: the last time I had a mediawiki instance just using https discouraged spam
15:24:28 <applicative> lispy, I think just some exposition of the library, together with actual applications :: IO () would be incredibly useful for a lot of the libraries
15:24:29 <Kaidelong> oh, then again, if the GC itself is implemented badly
15:24:31 <djahandarie> Kaidelong, how would that solve the issue of your rendering loop getting bogged down by stop-the-world GC?
15:24:31 <lispy> shapr: or let us approve users as non-spam bots?
15:24:39 <ezyang> --> #haskell-blah
15:24:43 <Kaidelong> Yeah
15:24:45 <Taslem> What exactly are you people talking about? Captcha, some sort of thesis, and something else?
15:24:50 <Kaidelong> that's just what I was thinking
15:25:07 <kmc> Taslem, we're being super insecure about whether Haskell is popular enough
15:25:11 <kmc> whether the cool kids will like us
15:25:15 <lispy> applicative: okay.  Thanks.  I think the cruxt of the value comes from highlighting things with applications.  The rest is just implementation details.
15:25:25 <acowley> djahandarie: don't generate as much garbage for one :P
15:25:31 <Taslem> In terms of programming, it's good. But people don't like it because it's different.
15:25:32 <jmcarthur> i don't think the GC is as bad for games as people make it out to be
15:25:32 <applicative> lispy shapr can make corrections in the comments, and you can revise if he's right
15:25:32 <NihilistDandy> kmc: I had to take up smoking to offset my use of Haskell~
15:25:45 <Taslem> And I'd know because I have a brother and a friend who program yet refuse to use Haskell.
15:25:47 <djahandarie> kmc, we're not insecure! I swear...
15:25:47 <acowley> djahandarie: but look, forget the audience that will not accept a periodic frame rate hitch
15:26:07 <Kaidelong> I think people have successfully used haskell in real time applications haven't they?
15:26:07 <acowley> djahandarie: do we have a kickass animation programming model that is totally awesome except for periodic frame rate hitches?
15:26:09 <NihilistDandy> Taslem: Did you tell them all the good parts?
15:26:17 <Kaidelong> so there must be ways to work around the garbage collector
15:26:19 <lispy> applicative: yeah, and lots of things offer that.  The presentation could be presented as github repos.  Let people send pull requests when there are errors.
15:26:21 <Kaidelong> perhaps with concurrency
15:26:23 <djahandarie> acowley, no. :p
15:26:26 <Taslem> I've tried. They don't like it on principal due to the fact it's functional.
15:26:33 <Taslem> And they're not good with functional problem solving.
15:26:56 <kmc> yeah, it takes time to learn that skill
15:26:58 <Taslem> Most notably, they call it an "unfunctional" language for its "excessive" function use.
15:27:10 <Taslem> Usually in jest. :P
15:27:18 <applicative> lispy, of course it could end up being a lot of trouble. ...
15:27:21 <kmc> employers like people who know Haskell (even if they don't use Haskell at the company) because it indicates that you're willing to put in a lot of effort to learn a new way to think, just for fun
15:27:39 <NihilistDandy> Smalltalk, too
15:27:50 <Taslem> Prolog, maybe?
15:27:50 <kmc> in the same way, employers like people with a college degree because it indicates that you're willing to do a large amount of very arbitrary work for a vague promise of future gain
15:28:01 <NihilistDandy> lol
15:28:02 <jmcarthur> kmc: makes it suck when looking for haskell jobs, too
15:28:03 * hackagebot sink 0.1.0.0 - An alternative to lazy I/O that doesn't conflate  execution with evaluation  http://hackage.haskell.org/package/sink-0.1.0.0 (JakeMcArthur)
15:28:08 <procyon112> shapr: take n >>= (\bs -> if crc32 bs == crc then parseOnly parseStruct bs else fail "") seems like it would work, but consuming the stream twice requires the block to stay in memory through potentially multiple partial parses... I dont like it.  Am I approaching this wrong?
15:28:14 <kmc> jmcarthur, because you show up and they want you to write Java instead?
15:28:20 <jmcarthur> yeah
15:28:32 <applicative> lispy I thought about getting a small crowd together to do this.  When you figure out a library, you write an account, with a few sensible short employments of it.
15:28:32 <Taslem> So write both!
15:28:39 <NihilistDandy> Bleh, Java
15:28:40 <Taslem> Simultaneously if possible.
15:28:59 <rata_> am I discarding the generated list immediatly if I write "do genList; return ();"?
15:30:11 <jmcarthur> rata_: depends on if genList causes whatever monad you are using to hold on to the list for whatever reason
15:30:26 <Taslem> I've been learnign all sorts of languages to prevent that issue.
15:30:33 <acowley> rata_: your code is too wide :/
15:30:39 <jmcarthur> e.g. in the State monad you could store the list as the state
15:31:02 <shapr> procyon112: I want to see your PNG parser when it's working!
15:31:53 <acowley> rata_: what are you using Enumerator for?
15:32:33 <procyon112> shapr: So do I :)  Any suggestions as to my dellima though?
15:32:49 <rata_> acowley: I just fixed the problem of the code being too wide
15:33:18 <acowley> rata_: thanks, it was just that I'd missed the right ends of lines when initially reading the gist
15:33:21 <rata_> acowley: I'm using the Enumerator to have an analog of iterate for monadic fns
15:33:22 <lispy> applicative: Yeah, I need to do a bit more planning before I could start anything.  I want to experiment a bit and also make sure the criteria for grading can be applied consistently.  Then make a few reviews and get things in a pipeline so that I can have weeks off without disrupting continuity.
15:33:36 <shapr> procyon112: Sadly, I don't have the brainpower to come up with suggestions :-( I'm too distracted.
15:34:08 <rata_> jmcarthur: I think I'm not holding onto the head
15:34:34 <applicative> lispy, jmarthur's new sink library from 5 minutes ago could do with a few illustrations for example :)
15:34:39 <acowley> rata_: that seems like overkill to me, but I'm not familiar with enumerator
15:34:43 <rata_> every step uses the last step only
15:34:44 <jmcarthur> heheh
15:35:02 <procyon112> shapr: lol.  np.  really wish there was a "run these 2 parses on stream in parallel, consuming once and return the pair of parses" combinator.... :P
15:35:06 <rata_> *last state
15:35:15 <rata_> acowley: how would you do it?
15:35:46 <jmcarthur> dang, i publish a package with a darcs repo listed, but then i can't push my repo to patch-tag :\
15:35:54 <rata_> iterate express the idea very well
15:35:56 <applicative> jmcarthur, don't you need a wc or cat example, like the iteratee / enumerator libraries...
15:36:18 <acowley> rata_: Yes, iterate is the right idea, I'm grepping my code
15:36:24 <lispy> jmcarthur: what prevents you?
15:36:49 <jmcarthur> lispy: can't take a lock on the server side. i'll just wait and if it's still a problem i'll report it
15:37:14 <jmcarthur> applicative: yeah i was thinking about doing a wc example
15:37:36 <jmcarthur> but then i got distracted and forgot i was going to do that and went ahead and uploaded like a dummy
15:37:38 <Kaidelong> I'm thinking of developing "patterns" to string together uniform computations into certain shapes (like rings, grids, or binomial trees)
15:37:41 <Kaidelong> for MPI
15:38:34 <lispy> jmcarthur: interesting.  That sure sounds like a server side bug
15:38:48 <acowley> rata_: the last time I did this, I wrote it recursively. See iterateUntil from my post with a simple GA: http://www.arcadianvisions.com/blog/?p=303
15:39:03 <jmcarthur> applicative: are you interesting in seeing an example soon? i was thinking about making a short blog post on it anyway. i could bring that higher on my todo list
15:39:13 <jmcarthur> applicative: it's nothing revolutionary or anything
15:39:19 <Kaidelong> trying to come up with ideas for how to go about this. One I had was to allow stringing them up in sequence using "barrier" to force the first shape to finish its work before moving on the next
15:39:38 <jmcarthur> it's actually a lot like procrastinating-variable, just with a simpler, faster implementation
15:39:58 <jmcarthur> dang, i meant to mention procrastinating-variable in the description, too
15:40:07 <applicative> jmcarthur, no I was just looking at it, while thinking about lispy's proposal. I guess I was kidding.
15:40:12 <jmcarthur> ah
15:40:33 <lispy> I would probably start my series with the libraries in the HP
15:40:55 <applicative> iteratee has a wc example, but enumerator is winning because it has a cat example.
15:40:55 <lispy> In fact, I think I would adopt some of the HP policies as part of my grading criteria
15:40:59 <rata_> acowley: thanks, I'll read it
15:41:37 <acowley> rata_: It's not necessarily relevant to you, I just linked for that one function
15:43:19 <rata_> acowley: what's <$>?
15:43:38 <djahandarie> :t (fmap, <$>)
15:43:39 <lambdabot> parse error on input `)'
15:43:44 <djahandarie> :t (fmap, (<$>))
15:43:45 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f, Functor f1) => ((a -> b) -> f a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1)
15:44:20 <djahandarie> (It's fmap)
15:44:38 <djahandarie> I ought to get a blog one day...
15:44:45 <procyon112> :t (.)
15:44:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:45:22 <djahandarie> :t [(.), (Prelude..)]
15:45:23 <lambdabot> forall a b a1. [(a -> b) -> (a1 -> a) -> a1 -> b]
15:45:32 <rata_> djahandarie: sorry, I don't get it
15:45:40 <djahandarie> rata_, <$> = fmap
15:45:46 <djahandarie> I was just showing the types
15:46:09 <djanatyn> map digitToInt "1234567890"
15:46:24 <Zao> djanatyn: Needs more > before
15:46:25 <acowley> djahandarie: it's easier to just to twitter on a regular basis
15:46:49 <acowley> rata_: It is operator syntax for fmap from the Control.Applicative module.
15:46:51 <applicative> > ord <$> "hello world
15:46:52 <lambdabot>   <no location info>:
15:46:52 <lambdabot>      lexical error in string/character literal at end o...
15:47:01 <djahandarie> acowley, accept it's hard to say something really interesting in 140 characters. (Without requiring a lot of background knowledge at least...) :p
15:47:01 <applicative> > ord <$> "hello world"
15:47:02 <lambdabot>   [104,101,108,108,111,32,119,111,114,108,100]
15:47:10 <acowley> djahandarie: I find it virtually impossible
15:47:21 <applicative> > ord <$> (Just 'a')
15:47:22 <lambdabot>   Just 97
15:47:47 <acowley> djahandarie: but consider, you said something about fusion being cata . ana => hylo the other day. If you instead wrote a blog post, you'd spend much longer it
15:47:55 <acowley> djahandarie: twitter saves you time! :)
15:47:58 <djahandarie> :p
15:48:23 <nkpart> I seem to be stuffing up my package database with alarming frequency
15:48:30 <djahandarie> I'm pretty sure the meaning of that is entirely useless to anyone who hasn't already thought about it though. :p
15:48:33 <jmcarthur> that happens, nkpart
15:49:58 <nkpart> yeah? I try to do a 'cabal install <all packages that didnt seem to mix> --reinstall' to fix it up
15:50:03 <nkpart> is that reasonable?
15:50:04 <acowley> djahandarie: Well, yes. I'm pretty sure I'm the only person on the planet who gets anything out of anything I ever write. With that assumption, I usually manage to satisfy my audience.
15:50:13 <rata_> djahandarie: where could I read about fmap?
15:50:13 <djanatyn> > map digitToInt "1234567890"
15:50:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,0]
15:50:18 <djanatyn> yay!
15:50:32 <djanatyn> Solved a Euler problem -_-
15:50:55 <acowley> rata_: read about Functors, perhaps on LYAH?
15:51:30 <ion> > map digitToInt "afgzA"
15:51:31 <lambdabot>   [10,15,*Exception: Char.digitToInt: not a digit 'g'
15:52:54 <djahandarie> acowley, hah. I for some reason doubt that is entirely true. :p
15:52:56 <ion> Why stop at f?
15:53:21 <djahandarie> rata_, read Learn You a Haskell. It covers Functors, which fmap is related to.
15:53:34 <hai> what does it mean a type be unlifted?
15:53:35 <djanatyn> > let factorial 0 = 1; factorial 1 = 1;  factorial n = n * factorial (n-1) in sum $ map digitToInt (show $ factorial 50)
15:53:36 <lambdabot>   216
15:53:42 <acowley> djahandarie: fair enough, I too am often disappointed at things I write. You have drawn attention to my ultimate failure.
15:53:44 <djahandarie> It would be safe to just skip to the Functor chapter if you already understand typeclasses.
15:53:47 <djanatyn> \o/
15:53:53 <djahandarie> acowley, not what I meant. :p
15:53:56 <djanatyn> yay :D
15:54:03 <applicative> rata_: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux
15:54:16 <joe6> crystal-cola, you around?
15:55:25 <acowley> rata_: the time investment in functors and monoids is more than worth it. They are often neglected as being too simple, though they are true stars
15:55:42 <Philippa> hai: it means _|_/undefined is not a member of that type
15:55:54 <monochrom> doesn't take a long time to invest in functor and monoid either
15:55:59 <Philippa> (at least, the 'add undefined' functor's the usual one to lift types into)
15:56:06 <djahandarie> I have millions invested in Functor and Monoid.
15:56:07 * hackagebot HaskellNet 0.2.5 - network related libraries such as POP3, SMTP, IMAP  http://hackage.haskell.org/package/HaskellNet-0.2.5 (RobertWills)
15:57:02 <hai> what does it mean the RealWorld datatype is primitive but not unlifted?
15:57:16 <gwern> haha. my plan to monopolize the market for essays examining anime from information theoretic point of view continues apace: http://www.gwern.net/Death%20Note%20Anonymity
15:58:13 <acowley> I invested djahandarie in Functor and Monoid
15:58:49 <applicative> wow, gwern, a link to 'Murder considered as one of the fine arts.'
15:59:06 <acowley> monochrom: that's the issue, though, they're easy to read and not particularly confusing, but recognizing everywhere they can be used is surprisingly non-obvious
15:59:33 <gwern> applicative: what? it's hilarious
15:59:46 <applicative> gwern, I know.
16:00:33 <aristid> gwern: did you use information theory to determine the market size, too?
16:00:58 <gwern> aristid: nah, I figured if everyone was like me, it'd be enormous. I can always calculate it later
16:01:30 <aristid> gwern: makes sense
16:01:56 <procyon112> So no attoparsec gurus around?
16:02:10 <applicative> gwern, the half-sentence attack on Locke is unforgettable
16:02:42 <gwern> applicative: I figure one of these days I'll travel the third world until I get attacked. then I will have ensured I'd become a great philosopher
16:03:11 <applicative> "...against Locke's philosophy in particular, I think it an unanswerable objection (if we needed any), that, although he carried his throat about with him in this world for seventy-two years, no man ever condescended to cut it."
16:03:14 <aristid> gwern: narrowing down to a third... isn't that a gain of 1.58.. bits, not 1.5?
16:03:50 <jedahu> any yesod experts around?
16:03:55 <gwern> aristid: eh, I was rounding. 1.5, 1.6. there's at least that much error in the various other roundings and population estimates
16:04:47 <aristid> gwern: round to 1.6, not 1.5, then :P
16:04:58 <gwern> aristid: oh fine
16:05:20 <parcs> hai: i think unlifted means that it can't have ⊥ as a value
16:05:38 <aristid> gwern: i figure that if everybody is like me, making such mistakes cuts down your market size enormously
16:05:51 * gwern is fixing it, he said
16:06:41 <gwern> aristid: and I suppose you want the 0.5 correct4ed to 0.3 too
16:06:56 <djahandarie> I want correct4ed corrected to corrected.
16:07:22 <djanatyn> hey, is my factorial function correct?
16:07:34 <aristid> gwern: i ignored most of the numbers :)
16:07:37 <djanatyn> Also, is the factorial 0 = 1 elidable?
16:07:40 <djanatyn> in:
16:07:42 <gwern> djahandarie: you can't correct stuff on IRC! 'the moving writes and having writ moves on...'
16:07:46 <gwern> *moving finger
16:07:47 <djanatyn> > let factorial 0 = 1; factorial 1 = 1;  factorial n = n * factorial (n-1) in sum $ map digitToInt (show $ factorial 50)
16:07:48 <lambdabot>   216
16:07:56 <djanatyn> that: --^
16:08:00 <shachaf> @google evolution haskell
16:08:01 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
16:08:01 <lambdabot> Title: The Evolution of a Haskell Programmer
16:08:15 <shachaf> djanatyn: See that document.
16:08:52 <djanatyn> shachaf: ...okay.
16:08:53 <o1iver> hey guys. what wrong with this: map (putStrLn . show) [1,2,3]? Its giving me no instance of Show error
16:09:12 <shachaf> @ty map (putStrLn . show) [1,2,3]
16:09:12 <Twey> :t map (putStrLn . show) [1, 2, 3]
16:09:13 <lambdabot> [IO ()]
16:09:13 <djanatyn> oh, seen it
16:09:13 <lambdabot> [IO ()]
16:09:16 <Twey> Haha
16:09:21 <proq> what is a peano player?
16:09:26 <Twey> Hahaha
16:09:32 <shachaf> o1iver: Nothing wrong with it. It can't be shown, though, since it's a list of actions.
16:09:38 <djanatyn> shachaf: I'm not becoming a Haskell programmer or something, am I?
16:09:39 <shachaf> proq: One who plays the peano.
16:09:39 <dibblego> print = putStrLn . show
16:09:48 <companion_cube> peano player, excellent!
16:09:52 <o1iver> shachaf: so how can I print all items of a list?
16:09:53 <nihtml> :t iter
16:09:54 <lambdabot> Not in scope: `iter'
16:09:56 <shachaf> o1iver: Look into sequence, sequence_, map, mapM_.
16:10:03 <dibblego> o1iver: mapM_ print
16:10:06 <shachaf> djanatyn: Nah, not so far.
16:10:09 <proq> shachaf: huh... well what is a peano?
16:10:13 <shachaf> @let factorial n = product [1..n]
16:10:15 <lambdabot>  Defined.
16:10:25 <shachaf> proq: http://en.wikipedia.org/wiki/Giuseppe_Peano
16:10:25 <djanatyn> hahahahahahaha
16:10:43 <proq> shachaf: funny you paste that link, I'm looking at that right now
16:10:49 <o1iver> shachaf: dibblego: ok thanks guys
16:10:55 <djanatyn> Now that I'm more knowlegeable, I get the Scheme one
16:11:10 <shachaf> djanatyn: (Your function is fine, though it has a redundant case (no need to mention 1 explicitly).)
16:11:35 <byorgey> proq: it's an instrument with a bunch of keys.  there is a lowest key, and each key has a key unique key one half-step above it
16:11:46 <proq> byorgey: no, that's a piano
16:12:00 <djahandarie> Heh
16:12:06 <byorgey> no it isn't, pianos have a finite number of keys ;)
16:12:39 <ben> :D
16:12:42 <shachaf> byorgey: What's the lowest key on a peano?
16:12:51 <djahandarie> (It is well-ordered though...)
16:12:54 <aristid> haskell has infinite pianos that are built only to the width that you use in your music
16:12:59 <shachaf> djanatyn: What isn't?
16:13:04 <shachaf> s/djanatyn/djahandarie/
16:13:17 * shachaf curses the dja.
16:13:20 <djahandarie> Anything you can't use induction on.
16:13:20 <ddarius> @hackage Haskore
16:13:20 <lambdabot> http://hackage.haskell.org/package/Haskore
16:13:23 <djahandarie> </tautology>
16:13:42 <proq> I see, so this is an inside joke
16:14:12 <shachaf> proq: It's a joke on how "peano" sounds a bit like "piano".
16:16:18 <djanatyn> I have to say, I'm abandoning Python
16:16:30 <djanatyn> Haskell is so much fun :D
16:18:41 <proq> >1 / 0
16:18:52 <proq> 1 / 0
16:19:02 <shachaf> > iNFINITY
16:19:05 <lambdabot>   Infinity
16:19:09 <shachaf> Whoops, caps lock.
16:19:33 <proq>  ^ a test of a good language
16:19:33 <hpc> :t Infinity
16:19:34 <lambdabot> Not in scope: data constructor `Infinity'
16:21:13 * hackagebot mysql-simple 0.2.1.0 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.1.0 (BryanOSullivan)
16:24:25 <procyon112> @hoogle (a->b)->(a->c)->a->(b, c)
16:24:26 <lambdabot> No results found
16:24:55 <dibblego> procyon112: (&&&)
16:25:01 <monochrom> lambdabot, the bot who knew infinity
16:25:13 * hackagebot typeof 0.1.2 - Small script for inferring types  http://hackage.haskell.org/package/typeof-0.1.2 (KangyuanNiu)
16:25:15 <monochrom> oh there is the amazon trick I can play
16:26:19 <monochrom> http://www.amazon.com/lambdabot-the-bot-who-knew-infinity/dp/0671750615/
16:26:55 <joe6> anyone tried to use the haskell llvm modules from agda?
16:27:58 <hpc> monochrom: haha, i see what you did there
16:33:52 <procyon112> dibblego: so say I have a function (M a -> b -> R a) and a variable (M c) and another (M d) can I lift (&&&) somehow to give me (M a -> M b -> c -> (R a, R b)) ??
16:34:36 <dibblego> procyon112: not for arbitrary values of R and M
16:36:01 <procyon112> dibblego: Stupid logic... always getting in my way
16:36:40 <monochrom> (what happened to M d ?)
16:37:13 <procyon112> Monochrom: I unified it to b
16:38:20 <dmwit> procyon112: Maybe you'd better just ask your real question.
16:38:37 <dmwit> Quit pussyfooting around with this abstract M and R nonsense. What are the real types you're after?
16:39:12 <procyon112> dmwit: hehe.  I did earlier.. no one answered, so I started down the path of abstraction
16:39:14 <monochrom> people feel that real questions violate privacy
16:39:44 <dmwit> Perhaps your question was too long.
16:39:44 <monochrom> and full complete pastes violate, period
16:39:51 <ddarius> I, for one, read people's souls from the real questions they ask.
16:39:57 * dmwit has a scroll upwards
16:40:14 <procyon112> parsing a ByteString with attoparsec, I have a function, parse with type (Parser a -> ByteString -> Result a)
16:41:37 <procyon112> I have 2 valid parses that I have to do along the same section of the ByteString.  One to parse out the actual data, and one that folds down that chunk to get the CRC (which is matched in another parse... ansullary to this)
16:42:18 <dmwit> It sounds like you're trying to do too much in your parse.
16:42:40 <dmwit> Parsing should consist only of converting bytes into Haskell values; any validation should come in a second processing pass.
16:42:48 <procyon112> I Would like to consume the BS only once, preferrably do the parses in parallel, and avoid grabbing the substring and initiating a sub-parse
16:42:51 <dmwit> Validation, cross-checking, CRC checks, etc.
16:44:27 <procyon112> dmwit: but I would like an intermediate result that shows invalid to bail out of the calculation.  Since the parser is reading from an enumerator, then not bailing means reading the entire invalid file.
16:44:41 <monochrom> I don't draw such clear lines because when parsing "123" to 123, there is inevitable validation already
16:45:11 <dmwit> Then it's clear I didn't understand your description.
16:45:20 <procyon112> dmwit: the CRC is only on an internal chunk, not the entire stream.  There are many internal CRC's
16:45:44 <dmwit> So the stream looks like "{- a few bytes of CRC -}{- a few bytes of data -}"?
16:45:48 <Ramphastida> so you have two ByteString arguments then? One hidden in the parser?
16:45:57 <monochrom> I would just code up one parser that constructs both data and crc. when to check the crc is optional
16:46:20 <dmwit> Yes, I think I was suggesting the same thing as monochrom.
16:47:10 <procyon112> The stream looks like {- length :: Word32, Data :: [Word32], CRCofData :: Word32 -}
16:48:40 <gio123> dmwit: hi
16:48:42 <procyon112> Ramphastida: The ByteString is passed in in the parse function which {- Magic Happens Here -} threads it through the monad.
16:49:00 <dmwit> So why isn't this just something like "do length <- parseLength; data <- parseDataWithLength length; crc <- parseCRC; guard (crcOf data == crc); return data"?
16:49:25 <dmwit> gio123: Hello, friend.
16:49:53 <gio123> do you know: Lambda Calculus with Patterns
16:49:54 <gio123> ?
16:49:55 <monochrom> oh, you have to compute crc yourself, and then ask does it == the crc read
16:50:04 <nihtml> hm
16:50:13 <nihtml> is Write You a Scheme a good book?
16:50:13 <procyon112> dmwit: I can do that, but that means keeping a list of raw bytestrings around that may be invalid in structure and not in CRC.
16:50:28 <gio123> http://web.mac.com/janwillemklop/Site/Bibliography_files/100.patterns.pdf
16:50:31 <Ramphastida> why don't you just use try?
16:50:32 <gio123> this paper
16:50:49 <dmwit> procyon112: I don't understand that sentence.
16:50:56 <dmwit> What does it mean for a bytestring to be "in CRC"?
16:50:57 <Ramphastida> with some usage of guard (crc == crcICalculated)
16:51:20 <ian_mi> how do I get cabal to link in the RTS?
16:51:30 <Ramphastida> hmm, would that even work?
16:51:48 <dmwit> gio123: I haven't read that paper, no.
16:52:04 <procyon112> dmwit: The CRC may be correct (tested by your code) but I am not interested in the data ByteString... I want to parse that data.  I only need to calculate the CRC on the BS.
16:52:17 <gio123> dmwit: do you have an idea what is going on there :)?
16:52:30 <gio123> I meant in general in such extension of lambda calculus
16:52:55 <gio123> dmwit: actually I am tring to prove confluence of beta rule
16:53:21 <ian_mi> I've tried extra-libraries: HSrts-ghc6.12.3 but it says missing C library
16:53:22 <dmwit> procyon112: Got it.
16:53:27 <dmwit> procyon112: Now I understand. =)
16:53:42 <nihtml> :t read
16:53:43 <lambdabot> forall a. (Read a) => String -> a
16:53:53 <procyon112> dmwit: so I am wanting to cheat...  For each byte I consume from the stream, I would like to parse it *AND* update the CRC without having to store the stream for a second pass (Ram intensive).
16:54:05 <ian_mi> I've also tried /usr/lib/ghc-6.12.3/libHSrts-ghc6.12.3.so and some other things
16:54:22 <dmwit> procyon112: How about StateT Attoparsec? (Or use whatever built-in stuff attoparsec has for State, if it has any -- that may be more efficient.)
16:54:41 <monochrom> ian_mi: that's strange, ghc's rts is always linked if you ask for an executable
16:54:56 <ian_mi> monochrom: I'm compiling a shared library
16:55:12 <monochrom> then you don't need ghc's rts
16:55:53 <dmwit> procyon112: Alternately, let your parseDataWithLength function return the data and the crc manually.
16:56:02 <procyon112> dmwit: Yeah, I need to StateT it anyway, since the parse is context sensitive... but I'm not seeing how to consume the BS on 2 parsers at once.
16:56:08 <dmwit> procyon112: I do not believe there is any magic that lets you fuse this kind of thing automatically.
16:56:11 <ian_mi> monochrom: well it's missing a symbol from there
16:56:18 <ian_mi> when I try to load it in python
16:57:09 <dmwit> procyon112: I would say you need to update the CRC state each time you call an attoparsec primitive (by hand). You won't be running two parsers at once, you'll be running one parser that both parses and updates state.
16:57:26 <ian_mi> monochrom: I'm assuming that's only for other haskell programs?
16:57:39 <dmwit> Does that make sense?
16:57:44 <monochrom> alright I don't know how to load any *.so in python, much less load ghc-generated *.so in python
16:58:11 <monochrom> but I know it is difficult either way
16:58:14 <ian_mi> monochrom: I've figured out that part
16:59:04 <monochrom> is there anything wrong with specifying, separately, to load both ghc's rts and your own lib?
16:59:27 <ian_mi> when I compile by hand with -l:/usr/lib/ghc-6.12.3/libHSrts-ghc6.12.3.so and with -rpath=/usr/lib/ghc-6.12.3 it works fine
16:59:40 <ian_mi> so it's only getting cabal to do that that's the problem...
17:00:06 <ian_mi> monochrom: I'm not sure
17:00:26 <procyon112> dmwit: Unfortunately, I don't think that attoparsec is flexible enough to consume the stream twice.  If I consume the Byte for the CRC, it's not there for the larger struct and vice versa. :P
17:01:01 <Ramphastida> you can ask for the ByteString which is the input yourself, right?
17:01:03 <monochrom> cabal probably doesn't know how to do this at all
17:01:19 <dmwit> procyon112: If you consume the byte for your larger struct, YOU HAVE THE BYTE.
17:01:24 <Ramphastida> at least with parsec you can do that, but then you need to mess around with updating what the position of the input is
17:01:24 <dmwit> You don't need to consume it twice.
17:02:03 <dmwit> procyon112: e.g. you change this: "do byte <- word8; munge byte" into this: "do byte <- word8; updateCRCWith byte; munge byte"
17:02:38 <dmwit> gio123: I'm sorry, I haven't read that paper, and I don't know anything about that calculus.
17:02:50 <Ramphastida> dmwit: I think the issue is getting running two Parser on the same input
17:03:06 <procyon112> dmwit: Yeah, but turn all my "do bigHonkinStruct <- parseTheThing;" into bytewise parses....
17:03:15 <dmwit> Ramphastida: I am modifying the problem. Because that problem doesn't have a good solution.
17:03:29 <dmwit> procyon112: Yes, you have to modify "parseTheThing".
17:03:36 <dmwit> procyon112: It doesn't have to be bytewise, certainly not.
17:03:53 <dmwit> procyon112: But every time you call an attoparsec primitive, you have to do an additional thing.
17:03:56 <dmwit> Yes
17:03:56 <dmwit> .
17:04:22 <dmwit> For example, if you called word32 instead of word8 or whatever, then you'd update the CRC to account for all four of those bytes at once.
17:04:24 <gio123> dmwit: ok
17:04:46 <gio123> dmwit: btw, do u know martin lof technicue to proof confluence of beta rule
17:04:47 <gio123> ?
17:04:59 <dmwit> No, sorry.
17:05:48 <monochrom> I wonder if you would like "StateT Word32 Parser a" and use the Word32 there for running crc
17:05:58 <dmwit> ...or if you called takeWhile, then you'd update the CRC with all the bytes in the resulting ByteString at once.
17:06:26 <dmwit> monochrom: That's exactly what I've been suggesting. =P
17:07:28 <procyon112> dmwit: Yeah.. I think that's the best way.  I may lose some little built in utility parsers, but it would be pretty clean... Just gotta carry that CRC around in all my parser functions.
17:08:00 <monochrom> yikes, I didn't read
17:08:09 <procyon112> dmwit: takeWhile won't work... again, don't wanna pull in the whole string at once.  Big memory consumption
17:08:13 * monochrom continues looking for victims in haskell-cafe
17:08:36 * dmwit sighs
17:09:12 <dmwit> I don't care which primitives you use. I'm just pointing out that each one of them has a corresponding semi-primitive that does both parsing and CRC updating in a stateful Attoparsec monad.
17:09:27 <procyon112> monochrome: yeah, I'll probably stack it with state to carry it around.
17:10:19 <ddarius> monochrom: Victims for?
17:10:37 <procyon112> dmwit: I think I've got it.  Gotta run, but thanks for your help!
17:10:51 <procyon112> monochrom: thank you too!
17:11:16 <ddarius> Hmm, the Galois talk looks like it's very apropos for the problems I'm working on right now.  Too bad the 10th is in the future.
17:12:34 <nihtml> :t (<|>)
17:12:35 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
17:13:32 <monochrom> ddarius: victims for my wrath :)
17:13:55 <monochrom> indeed I found one, and it's coppin again
17:14:04 <dmwit> What ever happened to "go with your heart"?
17:14:07 <dmwit> =P
17:14:33 <ddarius> I recommend just ignoring Coppin.
17:15:05 <dmwit> :q
17:15:06 <monochrom> I ignore 99% of coppin, yes. but this one takes little effort to answer. you'll see
17:15:09 <dmwit> sorry
17:15:59 <ddarius> monochrom: I unsubscribed from Haskell-Cafe several months ago.
17:18:34 <kniu> If I get something like
17:18:37 <kniu> fd:7: hFlush: resource vanished (Broken pipe)
17:18:54 <dmwit> Should I expect GHC to do different things with "\x y -> f (g x) y" and "\x -> let g' = g x in \y -> f g' y"?
17:18:56 <kniu> is there a way to catch that as an exception and handle it?
17:19:10 <dmwit> I guess you've already tried "catch", right?
17:19:16 <kniu> yes
17:19:18 <kniu> didn't work.
17:19:30 <dmwit> Have you tried catching SIGPIPE?
17:19:49 <kniu> how do I do that?
17:20:06 <dmwit> Google says: http://therning.org/magnus/archives/285
17:21:22 <monochrom> I am confused. there is supposedly a gtk2hs bug concerning Cabal version, new Cabal i.e., new ghc, new haskell platform should fail building gtk2hs, yet it doesn't happen to me, I just used 7.0.3 and latest haskell platform a few hours ago
17:21:30 <monochrom> http://hackage.haskell.org/trac/gtk2hs/ticket/1203
17:22:37 <monochrom> is it just because the victims didn't re-build gtk2hs-buildtools?
17:22:47 <monochrom> (because I re-build it every time)
17:23:16 <luite2> dunno, didn't happen to me either
17:24:14 <ion> dmwit: let f a b = trace "f" $ a + b; g a = trace "g" $ a + 1; z = \x y -> f (g x) y in z 1 <$> [2,3,4]
17:24:20 <monochrom> well, I probably see, someone says in haskell-cafe to --global to work around 1203. well I have always only --global'ed
17:24:24 <ion> dmwit: Then substitute the alternative definition for z.
17:24:25 <kniu> encoding 6.5 doesn't build.
17:24:40 <kniu> I unpacked the package, commented out a chunk of code, and now it works fine.
17:25:05 <kniu> am I supposed to upload the change to hackagedb?
17:25:59 <dmwit> ion: cool =)
17:26:05 * dmwit is happy
17:26:33 <dmwit> kniu: I've had good luck with the "encoding" maintainer. Send him a patch.
17:26:44 <dmwit> If he thinks it's a Pretty Good Idea, he'll include it in his next release.
17:27:43 <kniu> k.
17:27:45 <ddarius> The standard non-empty list type is (a,[a]), but if you are consuming it, you just get an extra parameter.
17:29:10 <kniu> okay, another problem
17:29:45 <kniu> I forkIO'd several threads, each with their own file descriptors.
17:30:02 <kniu> how does the signal handler know which thread's fd is broke?
17:31:19 <dmwit> Do threads really get different FD namespaces? I thought only processes did that.
17:31:53 <monochrom> (where is the signal handler?)
17:33:04 <kniu> what do you mean, "where"?
17:33:56 <mauke> wait, what
17:33:56 <monochrom> I mean a signal handler is brought up so suddenly
17:34:03 <mauke> you're not supposed to catch SIGPIPE
17:34:10 <mauke> you should ignore it
17:34:41 <c_wraith> Not supposed to catch it?  There aren't valid reasons to recover from it?
17:34:46 <kniu> ignoring it causes the thread that's using the fd to die.
17:34:51 <mauke> c_wraith: that's unrelated
17:34:59 <mauke> ignoring it makes the write(2) return -1
17:35:02 <c_wraith> oh
17:35:06 <mauke> which turns into an exception on the haskell side
17:35:06 <c_wraith> got it
17:35:12 <monochrom> wrap an exception handler around code that uses the fd
17:35:24 <kniu> tried it, didn't work.
17:35:33 <mauke> maybe you did it wrong
17:35:34 <dmwit> Maybe you should paste some code.
17:35:43 <monochrom> combine both ignoring sigpipe and wrapping an exception handler
17:35:57 <kniu> hm
17:36:04 <dmwit> Is the exception handler in the thread that's dying?
17:36:08 <dmwit> (Not the main thread?)
17:36:44 <kniu> I might have put the wrapper around the wrong computation.
17:39:35 <monochrom> the haskell posix signal lib does not significantly hide things available to c and unix. indeed in c a signal handler has just as much idea which fd caused the sigpipe
17:47:25 * hackagebot hsnoise 0.0.2 - A coherent 3d noise library.  http://hackage.haskell.org/package/hsnoise-0.0.2 (ColinHill)
17:49:33 <kniu> okay, problem solved.
17:49:45 <kniu> I really did just put the catch around the wrong IO action.
17:53:50 <tswett> So, I gave Wolfie the sequence "0, 0, 0, 0, 1".  It came up with a possible continuation, and the generating function of this continuation was a rational function whose denominator is (1 - z)^2(z^2 + 1)(z^2 + z + 1).  Where the heck did that come from?
17:55:29 <tswett> Expanded, that's x^6 - z^5 + z^4 - 2z^3 + z^2 - z + 1.  That *might* make sense.  :P
17:55:53 <dmwit> z^6, surely ;-)
17:56:08 <tswett> Let x = z.  :P
17:56:40 <ddarius> What was the numerator?
17:57:00 <tswett> z^4(z^4 - z^3 + z^2 - z + 1), of course.
17:57:44 <tswett> (No, I don't find that obvious.)
18:19:30 <sshc> Why is category-extras flagged as obsolete?
18:20:18 <djahandarie> Because edwardk is splitting it up
18:21:03 <sshc> Has that been done yet?
18:21:04 <djahandarie> See: categories, semigroups, semigroupoids, semigroupoid-extras, comonads, recursion-schemes
18:21:17 <djahandarie> Yeah
18:21:20 <djahandarie> @hackage categories
18:21:20 <lambdabot> http://hackage.haskell.org/package/categories
18:30:03 <plus_> haskell case expressions are tested in order?
18:31:40 <mauke> yes
18:41:31 <ddarius> Generalized loopy belief propagation!  Just what I need!
18:44:26 <luite2> hmm, I've heard of that, is that for multi-connected bayesian nets?
18:46:17 <ddarius> Probably.  What I'm calling generalized loopy belief propagation is better known as expectation propagation which generalizes loopy belief propagation and assumed-density filtering.
19:24:16 <Tharn> Question. I was trying to combine the example from http://www.haskell.org/haskellwiki/Calling_Haskell_from_C with the parallel example of nfib from http://www.haskell.org/ghc/docs/6.6/html/users_guide/lang-parallel.html
19:24:38 <danharaj> :t (.)
19:24:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:24:59 <Tharn> But i'm getting hung up on undfined reference to '__stginit_parallel ..'
19:25:00 <danharaj> :t (f .) .
19:25:01 <lambdabot> parse error (possibly incorrect indentation)
19:25:07 <Tharn> brb
19:25:11 <danharaj> :t ((f .).)
19:25:12 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, Functor f1) => f1 (f a) -> f1 (f b)
19:25:52 <danharaj> :t (f .)
19:25:53 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f) => f a -> f b
19:26:33 <danharaj> :k (-> b)
19:26:34 <lambdabot> parse error on input `b'
19:26:58 <danharaj> :k (->) a
19:26:59 <lambdabot> Not in scope: type variable `a'
19:27:04 <danharaj> :k (->)
19:27:05 <lambdabot> ?? -> ? -> *
19:27:12 <danharaj> What the hell is a ?
19:27:36 <mauke> where?
19:28:13 <danharaj> lambdabot: ?? -> ? -> *
19:28:13 <lambdabot> Plugin `compose' failed with: Unknown command: ""
19:28:20 <danharaj> quiet you.
19:29:21 <mauke> oh, I think it's a kind variable
19:29:33 <mauke> :k Int#
19:29:34 <lambdabot> Not in scope: type constructor or class `Int#'
19:29:38 <mauke> aww
19:29:45 <mauke> something about unboxed types
19:35:20 <lispy_> hello
19:35:46 <lispy_> how are my haskellers?
19:35:50 <Tharn> Hey
19:36:09 <lispy_> anyone implement a SPDY library yet?
19:36:39 <Tharn> Trying to the the FFI to run parallel haskell from C.. getting hung up on an undfined reference.. I don't think i know how to export the Parallel library.
19:36:43 <lispy_> http://www.chromium.org/spdy  <-- faster than HTTP!  Less latency more goodness.  Go!
19:36:55 <lispy_> Tharn: hmm
19:37:25 <lispy_> Tharn: I've not heard of anyone doing that before.  You should blog about it or ask on StackOverflow
19:37:54 <lispy_> Parallel Haskell called from C.  That certainly sounds interesting
19:38:01 <Tharn> Undefined reference to `__stginit_parallelzm3zi1zi0zi1_ControlziParallel_'
19:38:26 <lispy_> preflex: ?zdecode parallelzm3zi1zi0zi1
19:38:34 <lispy_> preflex: help
19:38:35 <preflex>  try 'help help' or see 'list' for available commands
19:38:39 <lispy_> preflex: list
19:38:40 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
19:38:41 <Tharn> If it works it'll make things exponentionally easier, even being my entire experiance with haskell has about two weeks so far.
19:38:41 <preflex>  ZCode: [zdec, zenc]
19:38:48 <lispy_> preflex: zdec parallelzm3zi1zi0zi1
19:38:48 <preflex>  parallel-3.1.0.1
19:39:05 <lispy_> preflex: zdec __stginit_parallelzm3zi1zi0zi1_ControlziParallel_
19:39:05 <preflex>  __stginit_parallel-3.1.0.1_Control.Parallel_
19:39:16 <lispy_> Tharn: I know what version of parallel you're using now :)
19:39:32 <Tharn> haha
19:42:13 <Tharn> Wait. Would Control.Parallel be considered a 'root module', requiring the hs_add_root line?
19:48:57 <monochrom> depends
19:49:30 <monochrom> you don't need to if you already hs_add_root your own module and it imports Control.Parallel
19:49:53 <Tharn> Currently i have no hs_add_root line in my code.
19:50:01 <monochrom> that's bad.
19:50:23 <Tharn> The example i originally started from didn't have it, reading more. Think i found my problem.
19:50:36 <monochrom> (how do you even call haskell functions if you don't have your own module for some "foreign export" lines?)
19:51:25 <Tharn> I started from http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
19:51:39 <monochrom> otoh if you use ghc 6.6, I don't know
19:54:25 <monochrom> I'm going to add it.
19:54:44 <monochrom> perhaps once upon a time it was not needed. anyway it's ghc-specific
19:55:33 <monochrom> technically #include "A_stub.h" is also ghc-specific
19:56:17 <monochrom> wait, why is the module called Safe and then A?
19:58:06 <monochrom> and calling the executable "test" is just wrong!
20:04:10 <lispy_> > (10000 - 2500)*0.2 + 2500
20:04:11 <lambdabot>   4000.0
20:10:37 <Tharn> Adding the hs_add_root with _stginit_ (whatever my module is called) doesn't seem to fix the linkage error. But i suppose that actually kind of makes sense.
20:19:13 <ddarius> Word of the Day: cokriging
20:20:33 <lispy_> ddarius: co-kriging?
20:47:00 <c_wraith> so...  Anyone familiar with the GHC 7 implementation of impredicative polymorphism?
20:47:20 <c_wraith> if so, or if you're just curious about the trouble I'm having...  http://hpaste.org/46375/scopedtypevariables_strikes_ag
20:48:01 <c_wraith> I can't figure out why I need to put the type annotations on lines 17 and 23 in the binds.
20:48:21 <c_wraith> I've tried putting them at the use sites, in lines 18 and 24, respectively, but I get a type error if I do.
21:11:05 <djahandarie> Does anyone have a list of what shared libs the Haskell RTS depends on?
21:12:06 <epdtry> djahandarie: running 'ldd' on libHSrts-ghc6.12.3.so shows: libm, librt, libdl, libc, libpthread
21:12:10 <gwern> djahandarie: why not just ask ldd on a haskell binary? main = return (), eg.
21:14:04 <djahandarie> epdtry, ah right, thanks, forgot it was seperated out like that
21:14:24 <djahandarie> gwern, just wanted to get /only/ what the RTS was requiring, not anything else
21:14:39 <gwern> djahandarie: what else could main = return () require?
21:14:57 <djahandarie> I'm not sure, but is that fool-proof?
21:15:08 <danharaj> oi... number theory homework has guaranteed I will get no sleep tonight
21:15:25 <djahandarie> gwern, seems to require a lot more stuff than what epdtry just listed
21:15:27 <epdtry> gwern: libHSffi, libHSghc, libHSbase, libHSinteger-gmp all get pulled in as well
21:15:41 <gwern> wow. how strange. what on earth is gmp being pulled in for
21:15:56 <epdtry> gwern: I think it's used to implement Integer
21:16:26 <gwern> yeah, but why is Integer there at all?
21:20:47 <Ptival> Hi everyone, I'm running Debian stable, installed GHC from source, and face this problem: "Loading package integer-gmp ... <command line>: can't load .so/.DLL for: gmp (libgmp.so: cannot open shared object file: No such file or directory)"
21:21:09 <gwern> Ptival: vague memory - you need to symlink something to something
21:22:02 <Ptival> I guess the actual libgmp.so to /.../libgmp-sthg.so
21:22:10 <Ptival> -actual
21:26:34 <Ptival> k it works thanks
21:31:58 <dibblego> > 7
21:31:59 <lambdabot>   7
21:32:40 <Ptival> :o
21:33:15 <djahandarie> @tell edwardk Codensity is now located in Control.Monad.Trans.Conts in adjunctions, right?
21:33:15 <lambdabot> Consider it noted.
21:55:19 <maurer_> Does anyone know how to get ghc to make a true statically linked executable these days? -static doesn't seem to do it anymore
21:58:39 <dons> marienz: hmm -static -fvia-C -optc-static -optl-static ?
22:02:38 <maurer_> dons: Failure due to lack of pthreads and not automatically pulling from the extra-libraries field for packages it's linking against (hmatrix in this case)
22:02:52 <KirinDave> In an applicative alternate, how is some used?
22:02:53 <maurer_> dons: -fvia-C is also a noop now, according to compiler's output
22:03:09 <KirinDave> I understand <|>, but I don't understand some and many.
22:04:57 <Axman6> :t some
22:04:58 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
22:05:05 <Axman6> :t many
22:05:05 <Nereid> :t many
22:05:06 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
22:05:06 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
22:05:08 <Nereid> ;(
22:05:19 <Nereid> one of them probably means "at least one"
22:05:22 <KirinDave> Yeah I've looked at the signature but it's not clicking for me.
22:05:23 <Axman6> one of them needs to match at least once, the other doesn't
22:05:42 <Nereid> KirinDave: look at the definition
22:05:53 <KirinDave> Well how might one use it?
22:06:15 <KirinDave> I think what confuses me the most
22:06:31 <KirinDave> is that if I type "some [1,2,3]" on ghci, it seems to go off forever.
22:09:32 <Nereid> KirinDave: say you were writing a parser
22:09:35 <Nereid> using Parsec, say
22:09:52 <Nereid> and you wanted to match, say, a string of 'X'es.
22:09:54 <KirinDave> Okay
22:09:56 <Nereid> but you don't know how many.
22:10:10 <Nereid> well, char 'X' is the thing that matches a single 'X'
22:10:26 <Nereid> and returns 'X', I guess
22:10:35 <Nereid> some (char 'X') would match a string of one or more "X'es
22:10:38 <KirinDave> What would it mean in the context of, say, the list applicative?
22:10:40 <Nereid> and return that string.
22:10:42 <Nereid> mm
22:11:04 <monochrom> I'll explain the infinite loop with something simpler: some (Just 4)
22:11:24 <KirinDave> I am now looping forever. :)
22:11:38 <Nereid> well yeah
22:12:20 <monochrom> so, in the parser example, (char 'X') is executed repeatedly until it fails (empty), and all the results are collected
22:12:50 <monochrom> so, in the Just example, (Just 4) is executed repeatedly until it fails (empty, Nothing), and all the results are collected
22:13:15 <monochrom> a parser is a stateful thing, and if you keep executing the same thing, eventually it fails
22:13:25 <KirinDave> Ahh
22:13:46 <KirinDave> So with some Applicatives, not all of Alternate makes sense.
22:13:48 <monochrom> a Just is a fairly referentially transparent thing. you execute it two billion times and it still won't fail
22:13:48 <KirinDave> Like Maybe
22:14:14 <monochrom> [1,2,3] is just "Just 4" on steroid
22:14:23 <KirinDave> Yeah
22:14:40 <KirinDave> So it's only useful with stateful monads.
22:15:00 <monochrom> or something that randomly decides to empty
22:15:20 <monochrom> something not referentially transparent
22:15:22 <djahandarie> IO? :P
22:15:36 <KirinDave> Could you leverage that with something like a channel?
22:15:44 <monochrom> unfortunately they didn't write an IO instance. but I can donate one if you like...
22:15:51 <djahandarie> Heh
22:15:58 <monochrom> however, STM is close enough
22:16:13 <KirinDave> How about an MVar?
22:16:42 <monochrom> I just wonder what STM's empty means
22:18:31 <c_wraith> I'm going to bet STM's empty is retry, and STM's <|> is orElse
22:18:38 <Nereid> it is
22:20:18 <monochrom> interesting
22:21:59 <danharaj> It's cruel how you can feel simultaneously clever and stupid when doing math problems.
22:22:26 <danharaj> I gave up on a problem and just kept reading on, and a bit into it I realized the key to the solution. I felt completely stupid but also satisfyingly clever.
22:22:35 <monochrom> some (do { x<-readTVar v; if x==0 then retry else writeTVar v (x-1); return x })
22:23:54 <c_wraith> :t some
22:23:54 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
22:24:18 <c_wraith> that'll give you a countdown from whatever was in the TVar to 1?
22:28:57 <monochrom> yeah. http://hpaste.org/46376/some_example_literally
22:32:14 <c_wraith> that was mostly a question about if I guessed the meaning of "some" properly.  guess I did.
22:32:36 <c_wraith> that was the most obviously useful thing it could do with that signature, but...  I'm never sure :)
22:32:44 <monochrom> if you know what empty and <|> do, you can solve for some
22:33:05 <c_wraith> it could have always returned an empty list!
22:33:21 <c_wraith> Or it could be replicateA
22:33:32 <c_wraith> All of those are dumb.  But possible!
22:34:04 <monochrom> "some and many should be the least solutions of the equations: some v = (:) <$> v <*> many v; many v = some v <|> pure []" using this you can solve for some and many
22:35:04 <monochrom> if necessary you can translate it to Monad
22:35:49 <monochrom> some v = do { x<-v; xs<-many v; return (x:xs) }; many v = some v <|> return []
22:35:59 <c_wraith> So the only difference is their behavior if the first application results in empty?
22:36:04 <monochrom> you have probably seen this code in parsec
22:36:08 <monochrom> yeah
22:36:19 <monochrom> parsec's many1 and many
22:39:03 <monochrom> some (readTChan c) is a very nice non-blocking read
22:40:01 <monochrom> err oops, that's blocking read but if there is stuff to read, it slurps as much as possible
22:40:20 <c_wraith> well.  close. :)
22:40:26 <monochrom> many (readTChan c) is the nice non-blocking read and also slurps as well
22:41:09 <KirinDave> Yeah that's what I was asking earlier.
22:41:23 <monochrom> this is beautiful. I solved a pair of fixed-point equations today
22:41:52 <c_wraith> It's really hard to believe the original STM (non-haskell) didn't have retry and orElse.  They seem so obvious.  I guess they *were* obvious in the Haskell implementation
22:42:16 <monochrom> in a sense parsec or any parser reads from a channel too, the input stream, yes
22:49:38 <KirinDave> I guess I gotta read the STM papers now
22:57:40 <ddarius> KirinDave: Just read all the papers.
22:58:12 <KirinDave> I'd been ignoring it because most of he good high-performance concurrent programmers I talk to are very dismissive of STM
22:58:17 <KirinDave> As "too slow" and "impractical"
22:59:07 <KirinDave> I hope that's just them being grumpy folks.
22:59:14 <c_wraith> That's a criticism of an implementation, not the idea
22:59:24 <KirinDave> c_wraith: But you cannot write a production system with just an idea.
22:59:40 <c_wraith> GHC's implementation of STM performs very badly with high contention, but very well with low contention.
22:59:52 <KirinDave> Bummer.
23:00:02 <c_wraith> So it depends on what you're doing.
23:00:19 <KirinDave> So you wouldn't use it for things like high-volume networked services.
23:00:25 <KirinDave> MVars are the order of the day there?
23:00:27 <c_wraith> If you have many mutable cells and transactions that read from/update a small fraction of them, STM is terrific
23:00:45 <c_wraith> If you have a single mutable cell that every transaction updates, yes, use an MVar
23:01:15 <KirinDave> even reads?
23:01:20 <KirinDave> I mean, don't get me wrong.
23:01:30 <KirinDave> I'm fine with different strategies for different scenarios.
23:01:38 <c_wraith> If you're mostly reads and the occasional write, IORef might work best with atomicModifyIORef
23:01:42 <KirinDave> There isn't a silver bullet for concurrent programming.
23:01:48 <c_wraith> since you don't need to get a lock to read from it.
23:02:39 <KirinDave> People argue the actor model necessitates inefficient implementations (which is provably false, practically true), but that doesn't mean that sometimes Actor model implementations aren't best.
23:03:02 <c_wraith> basically, STM uses optimistic locking.  If you have a use pattern where optimistic locking will rarely retry, STM performs very well.
23:03:08 <c_wraith> er, GHC's STM
23:03:20 <KirinDave> So lots of reads are fine.
23:03:29 <KirinDave> Lots of writes, also not so bad.
23:03:32 <KirinDave> But both
23:04:15 <c_wraith> also, STM is good in the case of "thousands of mutable cells, each transaction updates a few of them, and rarely overlaps in which it updates with other transactions"
23:05:03 <dons> +1 for c_wraith
23:05:11 <Axman6> i noticed the other da that intel has an experimental C++ compiler available which lets you use STM
23:05:15 <KirinDave> Wasn't there a paper or something recently aobout a new implementation of STM that is singificantly better?
23:05:22 <dons> MVars for high volume, STM for tricky stuff that's hard to get right
23:05:46 <dons> KirinDave: there's a wide number of better algorithms and tweaks to improve behavior around contention
23:05:57 <dons> v. hot research area for the last couple of years
23:06:06 <KirinDave> There was one some of my java friends were making fun of
23:06:31 <c_wraith> I'd like to see MVCC in STM.  gotta keep up with the Clojures of the world!
23:06:56 <dons> the main problem is how to distinguish regular vars from watchable stm vars. that's a hard problem, and haskell gets it right thanks to types and monads, but for everyone else, its painful
23:08:05 <dons> at least, that's what killed .net stm, iirc
23:08:45 <c_wraith> well, that and controlling IO
23:09:02 <c_wraith> and exceptions.  And a million other tiny details
23:09:24 <c_wraith> .net STM *worked*.  It was just fragile and easy to misuse.
23:09:49 <c_wraith> And every attempt to remove ways to misuse it made the code more fragile
23:09:50 <KirinDave> Microsoft released a product that was brittle and hard to use correctly?
23:09:54 <KirinDave> You don't say.
23:09:58 <NihilistDandy> Oh, hey, anyone who's worked with lambdabot: do I just have to put a line in online.rc to make it identify to the server, or is the process more involved?
23:09:58 <Axman6> yeah the ability to be able to modify STM and non-STM variables at the same time should not just be avoiided, but made completely impossible
23:10:00 <c_wraith> technically, they never released it :)
23:10:18 <KirinDave> Basically they compute the product of everything interesting MSR says, that the reciprocal of that, and put it in C#.
23:10:29 <Eduard_Munteanu> Heh.
23:10:31 <dons> hehe
23:10:50 <dons> sigh
23:11:09 <KirinDave> If someone DOES manage to get an interesting idea out of the MSR vortex, product managers immediately demand full LINQ compatibility.
23:11:12 <c_wraith> well.  At least MSR funding gets us constant improvements to GHC.
23:11:20 <NihilistDandy> :D
23:11:21 <KirinDave> Which then ruins whatever chance it has.
23:11:25 <Axman6> as long as MS keep ignoring the MSR work on GHC, we'll be ok
23:11:51 <dons> most def
23:12:12 <Eduard_Munteanu> I'd blame the codemonkeys though. :P
23:12:25 <KirinDave> Eduard_Munteanu: Oh man, I ran afoul of those.
23:12:41 <KirinDave> Eduard_Munteanu: But they don't have the power to demand "business synergy."
23:20:07 <ddarius> Linq was a good-ish idea.
23:20:26 <ddarius> C# in general is a surprisingly nice language.
23:21:05 <NihilistDandy> haet .NET
23:22:41 <NihilistDandy> Anyone running a lambdabot?
23:23:18 <Axman6> ddarius: I've never used it, but I've heard pretty much nothing but praise about it
23:25:01 <NihilistDandy> I'm kinda curious about F#, myself
23:25:17 <NihilistDandy> Only a little, though
23:36:00 <KirinDave> ddarius: Linq is not, in essence, a terrible idea.
23:36:12 <KirinDave> ddarius: What it is, in implementation, is really obnoxious.
23:37:16 <KirinDave> ddarius: Not only that, but many of the MS-provided libraries are actually quite poorly written, so you end up paying huge performance costs for the dubious benefit (in C#) of writing some types of operations in an SQLish code.
23:37:51 <KirinDave> ddarius: F# is a much more promising tack, but the VS folks told me when I worked there that they were pretty sure they'd release F# support and see almost no one use it.
23:40:50 <dibblego> Linq monad-comprehension are better than Scala at least
23:42:04 <KirinDave> dibblego: Maybe true, but I don't think that really saves the project.
23:42:30 <dibblego> what more is there to Linq besides untyped monad comprehensions? just like Scala, only less broken
23:43:46 <KirinDave> dibblego: The atrocious sqlish syntax in C#? :)
23:43:55 <dibblego> monad-comprehensions
23:44:04 <KirinDave> dibblego: The verb names get all tainted too.
23:44:10 <dibblego> what verb names?
23:44:29 <KirinDave> All the verbs in the linq library are named after SQL statement verbs.
23:44:52 <KirinDave> (at this point it's only half-serious, but it is irritating)
23:44:59 <dibblego> I pay no attention to things like that
23:45:07 <dibblego> otherwise, I'd complain very loudly about Scala calling it "for"
23:45:10 <KirinDave> dibblego: It really bugs me.
23:45:14 <KirinDave> yeah well maybe that's okay.
23:45:18 <dibblego> no it isn't
23:45:18 <KirinDave> That also bugs me.
23:45:28 <dibblego> why do you let names bug you?
23:45:28 <KirinDave> No I mean it's okay to grumble about that.
23:45:44 <KirinDave> dibblego: Because the names we choose to express things have power by association.
23:45:59 <KirinDave> (And here you caught a longtime lisp programmer red-handed.)
23:46:03 <dibblego> you mean because most C# users don't understand that Linq has nothing to do with SQL?
23:46:11 <KirinDave> dibblego: Yep.
23:46:22 <dibblego> that's because they are poorly educated, not because of naming
23:46:31 <KirinDave> dibblego: Did you see that big article recently where they optimized stack overflow page renders by many factors?
23:46:37 <dibblego> no
23:46:41 <KirinDave> They were using Linq2SQL.
23:46:50 <KirinDave> Play the sad trombone, ladies and gentlemen.
23:47:09 <dibblego> whatever that is
23:47:11 <NihilistDandy> T_T
23:47:31 <KirinDave> dibblego: http://sadtrombone.com/ should help
23:47:39 <dibblego> no Linq2SQL
23:47:59 <KirinDave> I think it's linq-to-sql
23:48:29 <jaj> Linq in BASS?
23:49:19 <KirinDave> dibblego: http://msdn.microsoft.com/en-us/library/bb425822.aspx btw.
23:49:49 <KirinDave> They were also doing a host of other stupid things, of course.
23:50:13 <KirinDave> Website makers are surprisingly stingy with their lore on what a pragmatic site needs to be like.
