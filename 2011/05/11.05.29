00:00:38 <solrize> in ghci i think you can say  "y <- x" at the top level
00:00:45 <dankna> chreekat: well, if the final result of the line you enter is an :: IO a, where there's an instance Show a, ghci will show the value,
00:00:53 <solrize> but that's not allowed in programs
00:00:54 <dankna> chreekat: which is precisely the same as if you had typed x >>= print
00:01:03 <chreekat> solrize: ah! that's what i was looking for
00:01:16 <chreekat> "y <- x".
00:01:45 <dankna> chreekat: in an actual program you would have to do it like:  do { y <- x ; something y }
00:02:02 <cmccann> the GHCi prompt is a lot like being inside a do block
00:02:12 <chreekat> Ah, that makes sense.. everything done within ghci is basically inside a do { ... }, isn't it. Yes, gotcha
00:02:16 <dankna> (that notation is the same as if I had written a newline where the semicolon is; I just didn't do that because I don't like to fill a lot of lines)
00:02:29 <cmccann> likewise how you have to define things with "let" and such
00:02:37 <dankna> (or at least, I'd rather fill those lines with explanations of why I don't like to... or something...)
00:02:55 <chreekat> heheh
00:04:03 <ddarius> Eduard_Munteanu: Yeah, technically there still is arguably an existential for technical reasons.
00:04:23 <dankna> interesting
00:04:58 <ddarius> Eduard_Munteanu: Basically, the reason why the old existential syntax made sense was due to the fact that, forall a. F a -> B is equivalent to (exists a. F a) -> B, but, of course, this requires a not to be free in B.
00:05:01 <solrize> what existential is this?
00:05:19 <ddarius> Eduard_Munteanu: The same pretty much holds for GADTs as well.
00:07:00 <Eduard_Munteanu> I'm still a bit baffled by existentials in Haskell. In Agda they aren't anything special.
00:07:14 <ddarius> Eduard_Munteanu: They aren't anything particularly special in Haskell either.
00:07:44 <koninkje> Eduard_Munteanu: are you refering to sigma types in Agda? because those are different (popular conceptions to the contrary)
00:07:53 <Eduard_Munteanu> koninkje: yeah
00:07:55 <tgeeky> dankna: looking through this module more, one thing that is very surprising is that the TwoDim case is rather simpler than the OneDim case
00:08:12 <tgeeky> dankna: and it's not because it re-uses code from OneDim
00:08:40 <koninkje> Eduard_Munteanu: sigma types are more like pairs. Existentials are different because they don't allow you to project the second component (the one tht depends on the existentially qualified thing)
00:09:00 <Eduard_Munteanu> Plus you get to have some   data Foo : Set where foo : {A : Set} -> A -> Foo
00:09:05 <koninkje> or rather, don't let you project it out in a way that it doesn't get re-captured by an existential
00:09:07 <Eduard_Munteanu> erm, Set\_1
00:10:25 <Eduard_Munteanu> Ah, yeah.
00:10:39 <Eduard_Munteanu> Techincally in Agda nothing prevents existentially quantified stuff to escape.
00:10:43 <dankna> tgeeky: huh, interesting!
00:10:56 <koninkje> Eduard_Munteanu: thus, technically, they're not existential types :)
00:10:58 <Eduard_Munteanu> Haskell makes it a special case.
00:11:02 <ddarius> What koninkje said.
00:11:04 <Eduard_Munteanu> Heh, yeah.
00:11:32 <koninkje> every language that wants existential encapsulation behaves like Haskell does (assuming it's not buggy)
00:11:48 <ddarius> It is literally the defining property of existential quantification.
00:11:54 <koninkje> If you're familiar with Coq, compare Coq's exists to Coq's sigma types
00:11:57 <ddarius> (or half of it)
00:12:02 <Eduard_Munteanu> Well, what's the practical difference / downside in *not* doing it like Haskell?
00:12:17 <Eduard_Munteanu> Ah, I don't know Coq.
00:12:20 <koninkje> You loose some parametricity/free theorems
00:12:28 <ddarius> Eduard_Munteanu: You don't get data abstraction.
00:14:25 <Eduard_Munteanu> Which makes me wonder a bit... since I'm working on something in Agda. Heterogenous collections don't seem to be easy to get there either.
00:15:09 <ddarius> Since a "heterogenous" collection makes little sense, that's not surprising.
00:16:15 <Eduard_Munteanu> I don't know how to avoid needing it, either. Basically I'm writing an evaluator for a BASIC-like language, and I kinda have to keep track of variables, which can have different types and such.
00:16:45 <Eduard_Munteanu> So I do need to implement some sort of store which contains stuff of different types (the types themselves don't change).
00:17:33 <Eduard_Munteanu> Well, not BASIC-like-a-lot since this is supposed to be strongly-typed.
00:17:36 <dankna> @hoogle filterM
00:17:36 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
00:17:36 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
00:18:29 <koninkje> Eduard_Munteanu: in Agda, existential types would be something like: data Exists (P : Set -> Set) : Set where ex : .{A : Set} -> P A -> Exists P
00:18:47 <koninkje> Except, I'm pretty sure that's not legal Agda
00:19:02 <adnam> someone put a monad in my monad
00:19:28 <koninkje> Note that the first component is irrelevant, which means that no operation on the second component is allowed to know anything about the first component
00:19:34 <Eduard_Munteanu> koninkje: hm, is that an irrelevant argument? How does it make things different?
00:19:47 <Eduard_Munteanu> Ah.
00:19:49 <koninkje> thence, data abstraction
00:20:22 <koninkje> You can only manipulate an Exists P in ways that you could manipulate an (forall x. P x)
00:20:40 <koninkje> i.e., all you'r knowledge comes from the definition of P
00:21:12 <koninkje> In Haskell, the only Ps you can have are typeclass and type-equality constraints
00:22:01 <koninkje> (effectively)
00:22:34 <solrize> http://hpaste.org/paste/47203/gadtbased_interpreter_annota#p47212   i got rid of those intermediate variables
00:26:37 <solrize> http://hackage.haskell.org/packages/archive/Coroutine/0.1.0.0/doc/html/Control-Monad-Indexed.html    neat
00:26:40 <dankna> ah, yes
00:27:22 <djahandarie> koninkje, IIRC you are not allowed to do that sort of thing with the irrelevant pi
00:28:39 <koninkje> djahandarie: I figured as much. I was just offering it as an illustration
00:29:16 <koninkje> ...of how existentials are different from sigmas
00:40:03 <sm> is there an easy way to do this pattern match ? Right j <- some action
00:40:44 <sm> I want to extract the Right value, ignoring the other case
00:41:33 <roconnor> sm: do Right j <- some action; ...
00:41:34 <Zao> > do { (Just x) <- return . return $ 9001; return x } :: [Int]
00:41:36 <lambdabot>   [9001]
00:42:19 <roconnor> sm: fail will be run if the patter doesn't match
00:42:29 <roconnor> > do { (Just x) <- return Nothing; return x } :: [Int]
00:42:30 <lambdabot>   []
00:42:50 <solrize> http://blog.sigfpe.com/2009/02/beyond-monads.html  there's a ton of stuff about indexed monads, and it's pretty neat, thanks for telling me about it
00:44:18 <Eduard_Munteanu> :t either
00:44:19 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:45:29 <Jafet> do notation: essential for compact pattern matching
00:45:41 <sm> thanks.. it's too late for me to grok this but I'll reread
00:46:03 <roconnor> @undo do { (Just x) <- return . return $ 9001; return x }
00:46:03 <lambdabot> return . return $ 9001 >>= \ a -> case a of { (Just x) -> return x; _ -> fail ""}
00:46:24 <roconnor> @undo do { (Just x) <- return (Just  9001); return x }
00:46:24 <lambdabot> return (Just 9001) >>= \ a -> case a of { (Just x) -> return x; _ -> fail ""}
00:47:04 <Eduard_Munteanu> Uh, yeah, I didn't read through :)
00:48:38 <Jafet> :t do undefined
00:48:38 <lambdabot> forall a. a
00:49:05 <Jafet> :t do x <- undefined; undefined
00:49:06 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
00:51:58 <poltak> Favourite feature of Haskell, everyone?
00:52:49 <k0ral> hi, I'm using dbus-client and have a problem using its data MemberName: it can only be built from a Text, but not from Data.Text: it needs a Data.Lazy.Internal.Text
00:53:17 <Jafet> poltak: trolling its channel is hard
00:53:31 <k0ral> first, I can't see any way to build such a Text from a String (pack only exists for Data.Text or Data.Text.Lazy)
00:53:35 <Axman6> k0ral: you probably need the Data.Text.Lazy.Text type
00:53:51 <Axman6> Data.Text.Lazy is the one you need
00:54:10 <k0ral> second, I find it strange that dbus-client uses this internal type since, quoting: "You should not use this module unless you are determined to monkey with the internals, as the functions here do just about nothing to preserve data invariants. You have been warned!"
00:54:12 <Jafet> You mean Data.Text.Lazy.Internal.Text? That's probably a synonym for Lazy.Text
00:54:39 <Axman6> poltak: cycle purity rings lol
00:54:49 <k0ral> so I should include Data.Lazy.Text to have access to pack ?
00:55:06 <Axman6> i assume it's Data.Text.Lazy
00:55:21 <k0ral> oh yes, sorry
00:56:50 <k0ral> ahhhh I have to prepend a "pack" to every String I use in dbus
00:56:55 <k0ral> that's tedious
00:57:11 <k0ral> but thanks, data.text.lazy fixed it
00:57:23 <Axman6> Data.Text.Lazy just reexports Data.Text.Lazy.Internal btw, and you're usually not supposed to use .Internal modules, by convention
00:57:41 <Axman6> k0ral: turn on the OverloadedStrings extension
00:58:44 <k0ral> well, I'm not supposed, but dbus-client uses it so I'm not choosing
00:59:29 <Axman6> huh?
00:59:57 <k0ral> dbus-client expects a Data.Text.Lazy.Internal as argument of several of its functions
01:00:43 <Axman6> if you turn on OverloadedStrings, then you can write "Hello" and it will be automatically made a Text.Lazy value
01:01:18 <Axman6> just put {-# LANGUAGE OverloadedString #-} at the very top of your file, and you can remove most of the packs in your code for static strings
01:02:09 <solrize> http://intoverflow.wordpress.com/2010/05/21/announcing-potential-x86-64-assembler-as-a-haskell-edsl/   <----   teh awesum
01:05:36 <k0ral> Axman6: that's wonderful, thank you !
01:09:29 <solrize> so do you guys think i
01:09:58 <solrize> oops
01:10:02 <Axman6> deep man, that's real deep
01:11:05 <Jafet> Spoken like a true bynbo
01:11:06 <solrize> what is current wisdom about agda vs. coq?
01:33:14 <Eduard_Munteanu> Hrm, I should renew my LWN subscription...
01:36:40 <poltak> Eduard_Munteanu: hasn't it gotten really bad lately?
01:55:52 <Eduard_Munteanu> poltak: um, what do you mean?
02:08:50 <frank00> how can I tell (after having used getDirectoryContents) if an item is a folder or a directory? I am currently using elem '.' but that seems cheap
02:09:18 <Jafet> It's also wrong
02:09:39 <shachaf> frank00: If it's a folder, it's also a directory.
02:09:45 <shachaf> I think the other direction holds too.
02:09:55 <Eduard_Munteanu> I think he meant file or directory.
02:09:57 <Jafet> Folders are plastic containers
02:10:17 <cheater__> folders are like burritos
02:10:17 <frank00> shachaf: sorry, i meant folder or a file
02:10:26 <cheater__> which means monads are like folders
02:10:27 <shachaf> Jafet: Directories are books from which to plagiarize your index.
02:10:31 <Jafet> frank00: every filesystem I've ever used lets you put dots in directory names, and omit them from filenames
02:10:42 <Entroacceptor> I think I've gained some weight after joining #haskell, just because of that joke ^^
02:10:50 <Jafet> cheater: and a symlink is a Cont?
02:11:09 <mauke> http://haskell.org/ghc/docs/6.10.2/html/libraries/directory/System-Directory.html#4
02:12:11 <frank00> thanks mauke
02:12:38 <shachaf> Jafet: ISO 9660 Level 1?
02:13:10 <shachaf> I'd say DOS 8.3-style, but apparently that allows directories to have extensions.
02:13:22 <Jafet> shachaf: bah, who uses that anymore
02:13:34 <Jafet> Everyone uses de facto extensions
02:13:42 <Jafet> I forget the name
02:14:07 <shachaf> The question is whether you've "ever used" it. :-)
02:14:27 <Eduard_Munteanu> Joliet?
02:14:44 <Eduard_Munteanu> or Rock Ridge (I don't even know if Windows groks that these days)
02:16:31 <chrisdone> dankna: FWIW I have another timespan describer: http://hpaste.org/47213/datatimerelative
02:17:12 <Jafet> Looks tricky to localize
02:18:06 <Jafet> shachaf: I don't use CDs or DVDs *cough*
02:18:25 <shachaf> Jafet: And you've never used DOS either?
02:18:48 <Jafet> Nope. Should I have?
02:18:58 <shachaf> Yes.
02:19:06 <Jafet> You're a meanie.
02:19:29 <shachaf> How can you not use DOS?
02:19:32 <shachaf> Even *I* used DOS.
02:19:40 <shachaf> ...Maybe that's what made me such a meani.
02:19:44 <shachaf> s/.$/e./
02:20:17 <chrisdone> Jafet: How's it tricky to localise?
02:20:20 <Cale> When I first read Jafet's line "Looks tricky to localize", I thought of http://en.wikipedia.org/wiki/Localization_of_a_ring
02:20:21 * Jafet nods with empathy.
02:20:55 <Jafet> Is there a ring of UTCTime?
02:21:36 <Cale> Not a particularly natural one.
02:23:55 <Jafet> Oh, ranges is somewhat flexible.
02:30:16 * hackagebot egison 0.1.2 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.1.2 (SatoshiEgi)
03:11:49 <rajstopka> ale was tu duzo
03:12:26 <shachaf> nirpi tag os yemava
03:12:48 <rajstopka> yemava
03:13:19 <rajstopka> tag?:D
03:14:04 <shachaf> yefrok
03:14:10 <shachaf> ul?ↁ:
03:14:51 <rajstopka> no
03:14:54 <rajstopka> ?
03:15:05 <rajstopka> nirpi shachaf
03:15:56 <shachaf> #haskell-blah ktem nulu ta antyehov
03:16:46 <rajstopka> ktem niripi
03:16:50 <rajstopka> nirpi*
03:17:10 <shachaf> "ktem"?
03:17:15 <shachaf> What sort of crazy language is that?
03:17:34 <rajstopka> palestinian uluru
03:20:25 <rajstopka> to ktos chce sie ze mna kochac ?
03:20:27 <rajstopka> tak w sieci?
03:20:33 <rajstopka> mam mokre rajstopki juz
03:20:34 <rajstopka> takie jasne
03:52:09 <sanjoyd> If the value of an expression is of the type Q Exp, where Q is an instance of Quasi; how do I get back the Exp?
03:54:35 <Chaze> sanjoyd: if this question is what i think it is: pattern matching
03:55:03 <sanjoyd> Right, so something like "let Q LitE e = <whatever> in e" ?
03:55:16 <sanjoyd> LitE is a constructor for Exp.
03:55:36 <Chaze> yeah
03:55:53 <c_wraith> Uh.
03:56:03 <c_wraith> You can't pattern-match a *type* constructor
03:56:07 <c_wraith> and Q is a type constructor
03:56:20 <sanjoyd> c_wraith: yes, it does not work.
03:56:34 <c_wraith> This is the same thing as "how do I get a String out of an IO String"  The answer is "You don't."
03:57:10 <sanjoyd> So there is not way I can embed an expression which is a Q Exp inside an expression whose value is a Exp?
03:57:21 <sanjoyd> s/not/no/
03:57:27 <Eduard_Munteanu> Q is a monad, isn't it?
03:57:30 <c_wraith> yes
03:57:31 <sanjoyd> Eduard_Munteanu: yes.
03:57:40 <Eduard_Munteanu> Then pretend it's like IO :)
03:57:47 <c_wraith> No, there's no way to use a Q Exp in an expression with type Exp
03:57:55 <sanjoyd> c_wraith: thanks for clearing that up. :)
03:57:58 <c_wraith> But you can use a Q Exp in an expression with type Q Exp
03:58:04 <sanjoyd> c_wraith: okay.
03:58:07 <c_wraith> And since TH splices are always of type Q Exp
03:58:09 <c_wraith> That works out ok
03:58:21 <sanjoyd> Eduard_Munteanu: that would've worked had I not been a noob. :D
03:58:23 <c_wraith> (well.  expression splices are)
03:58:24 <Eduard_Munteanu> qexp >>= \exp -> ...
03:58:39 <c_wraith> obviously, non-expression splices have other types :)
04:00:26 <sanjoyd> Eduard_Munteanu: yeah, that should do.
04:00:38 <sanjoyd> I guess I can use a do block too.
04:00:46 <sanjoyd> But I'll stick to >>= and >> for now.
04:01:06 <c_wraith> also, note that many cases don't require working with Exp structures directly.
04:01:28 <c_wraith> Often, you can get away with [| ... |] quotes
04:01:35 <c_wraith> with subsplices in them
04:01:56 <sanjoyd> I'll try to do that too; right I'm trying to go the hard way and construct everything manually.
04:02:13 <c_wraith> I've done that.  I was amazed how much easier it was when I stopped doing that. :)
04:02:27 <c_wraith> You sometimes need to, of course, if the structure of the generated code is dynamic.
04:11:08 <catWoman> hello
04:11:19 <dobblego> hi catWoman
04:11:41 <catWoman> I really need help, I write a program for my
04:11:45 <catWoman> homework
04:11:56 <catWoman> and just need to know where I make mistake
04:12:30 <catWoman> my program do what I want, no errors
04:14:43 <Axman6> catWoman: if you have a problem, ask a question
04:15:13 <Eduard_Munteanu> You can also use a pastebin to paste code:
04:15:15 <Eduard_Munteanu> @where hpaste
04:15:15 <lambdabot> http://hpaste.org/
04:15:27 <catWoman> I haven't problem, it's just read back
04:15:40 <catWoman> ok I will paste my code
04:18:55 <catWoman> I do it, but I am a beginner :x
04:27:27 <Jafet> Given a directed graph and a vertex. How do I find the vertex that is furthest away from it?
04:28:29 <Jafet> I can use Dijkstra's algorithm to compute all shortest paths and pick the longest one, but I might have millions of vertices and tens of millions of edges.
04:28:40 <mercury^> I think some co-a* algorithm does the trick.
04:29:33 <Jafet> Hm, can I make that work with cycles?
04:29:40 <mercury^> Start walking away from your vertex and develop the most promising path first.
04:29:53 <mercury^> Backtrack if it does not work out.
04:30:01 <sanjoyd> Weighed edges?
04:30:05 <twanvl> mercury^: but then you don't know if there is not a shorter path
04:30:19 <ectospasm> algorithms always made me want to stab myself in the eyes *_*
04:30:33 <sanjoyd> Algorithms are for people who don't know how to buy RAM.
04:30:35 <twanvl> I don't think you can do better than Dijkstra's in this case
04:30:44 <Jafet> Also to flip A*, I imagine you need an upper bound on the path, mercury, and I only have lower bounds
04:30:57 <mercury^> Hmm.
04:32:17 <Jafet> (And if I could have upper bounds and lower bounds at the same time, this would be easier than it is)
04:49:04 <develhevel> when i make a if .. in a do notation, is there a way to dont use the else? i always then must run: if ... then (make some things) else putStr ""
04:49:24 <Botje> check out the when and unless combinators in Control.Monad
04:49:31 <Botje> :t when
04:49:31 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:50:49 <beastaugh> return () is the null case, as it were, for anything :: IO ()
04:50:57 <beastaugh> so yes, use when and unless
04:51:19 <beastaugh> if you find you're doing something that feels suboptimal a lot, try using hlint
04:51:25 <beastaugh> it catches a lot of stuff like that
04:52:42 <develhevel> hling sounds very interestint thx
04:52:46 <develhevel> interesting
04:53:06 <develhevel> can someone explayn me what a functor or?
04:53:40 <Botje> what a functor is?
04:53:57 <Botje> most collections of objects are also functors.
04:54:03 <develhevel> yes
04:54:12 <Jafet> Tortillas
04:54:47 <beastaugh> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
04:55:16 <beastaugh> and http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux
04:56:03 <Botje> there's also the typeclassopedia
04:56:57 <develhevel> thx for the links
04:57:23 <Eduard_Munteanu> develhevel: it depends on what exactly you're interested in, there are at least 3 related things called functor
04:57:57 <Eduard_Munteanu> First the actual category theory concept, then stuff of kind * -> * in Haskell, then the actual typeclass Functor
04:58:42 <Botje> and then there's functors in prolog
04:58:46 <Botje> and in c++ too :p
04:59:01 <Botje> but they are false idols and are only worshipped by heathens.
04:59:42 <beastaugh> the prolog usage is worse
04:59:48 <beastaugh> because those guys really should know better
05:11:45 <solrize> ML
05:14:20 <cheater__> what about ML
05:16:03 <solrize> ML functors are different from all of the above afaik
05:16:34 <jules2> there is a strictness monad that lets you write strict computations in a lazy language. is there also a laziness monad that lets you write lazy computations in a strict language?
05:19:54 <jules2> i was thinking that maybe laziness is captured by a comonad: (x =>> f) = delay (f x) and extract x = force x, but perhaps a monad can work as well?
05:20:22 <Eduard_Munteanu> I don't think so, at least not in languages like C. You'd have to figure a way to make up thunks and to evaluate them.
05:21:58 <jules2> well, i was thinking more about languages like ml, since you can't really use monads in C in the first place (or you'd have to invent your own closure mechanism)
05:21:59 <Eduard_Munteanu> Maybe in a language that's strict by default, but allows lazy semantics.
05:23:57 <Eduard_Munteanu> I'd also note your x =>> f works with stuff that's already lazified to say so.
05:24:33 <jules2> how do you mean?
05:25:01 <Eduard_Munteanu> To actually make up x values you'd need to 'delay' yourself.
05:25:28 <Eduard_Munteanu> That might not be a problem though.
05:25:41 <Eduard_Munteanu> Anyway, I think it's an interesting point of view.
05:26:50 <jules2> i think you'd only need to be able to delay values that have already been evaluated, not entire computations. you can build delayed computations from =>>
05:36:59 <jules2> the continuation monad is said to be the mother of all monads because you can write every monad in terms of it, is there a mother of all comonads?
06:16:37 <iwtu> Hi guys. Can i ask you how does "myLast' = foldr1 (const id)" workds ?
06:17:25 <iwtu> It is not really clear what it works
06:17:33 <iwtu> *why
06:18:15 <saati> :t const
06:18:16 <Axman6> > foldr1 f [a,b,c]
06:18:16 <lambdabot> forall a b. a -> b -> a
06:18:17 <lambdabot>   f a (f b c)
06:19:27 <Axman6> well, if you give it [a,b,c], that turns into <const id a (const id b c)>, thich then becomes <id (const id b c)> which becomes <const id b c> which becomes <id c> which finally becomes c
06:29:18 <iwtu> ok; at first :) how does <const id 'b' 'c'> works :)
06:29:48 <Axman6> const returns its first argument, which is id
06:30:20 <Axman6> so, you have ((const id b) c) -> (id c)
06:31:20 <iwtu> oh, thnaks a lot :)
06:35:51 <k0ral> I have an ambiguous type error when writing: toVariant "TEST", using toVariant from DBus.Types
06:36:22 <k0ral> any clue ?
06:36:52 <monadic> What is the recommended way to set up testing for internal module functions that aren't meant to be exported? Currently I am forced to export everything because of the need to access functions from tests...
06:39:09 <Axman6> k0ral: this is using OverloadedStrings right? you probably have to say exactly what type you want that string to be, so toVariant ("TEST" :: Text) or something
06:39:53 <k0ral> Axman6: yes it's using OverloadedStrings as you suggested to me earlier
06:40:20 <k0ral> but in DBus documentation, toVariant can be used with String directly
06:40:58 <k0ral> http://hackage.haskell.org/packages/archive/dbus-core/0.8.5.4/doc/html/src/DBus-Types-Internal.html#Variable
06:41:33 <k0ral> however your fix works
06:41:34 <Axman6> then use toVariant ("TEST" :: String) and see if that works
06:41:37 <k0ral> but I can't get why
06:41:43 <k0ral> I tried it doesn't
06:41:47 <Axman6> it shouldn't, if it's supposed to take a string
06:41:49 <k0ral> :: Text does
06:42:31 <k0ral> both String and Text are made instances of the Variable class
06:43:53 <Axman6> jesus, that code has the worst formatting I've ever seen :|
06:45:31 <k0ral> Axman6: don't bother, I'm fine with :: Text
06:55:20 <catWoman> Somone know how to do something like : data Tree a  = Leaf b | Node a (Tree a) (Tree a) deriving (Eq,Ord,Show)
06:56:31 <merijn> catWoman: Make it: data Tree a b = Leaf b | Node a (Tree a) (Tree a) deriving (Eq,Ord,Show)
06:58:10 <catWoman> it doesn't work
06:58:38 <parcs> data Tree a b = Leaf b | Node a (Tree a b) (Tree a b) deriving (Eq, Ord, Show)
06:59:17 <catWoman> thank you!
06:59:52 <merijn> oh, doh
06:59:57 <merijn> I was to lazy there >.>
07:00:11 <catWoman> lol
07:06:51 <gavri> how does one use quickcheck to create lists of lists of integers? my first attempt is woefully limited http://hpaste.org/47217/lists_of_lists_generation_atte
07:08:51 <Axman6> do you want lists of a certain length?
07:09:34 <Axman6> also, it might be possible that just using arbitrary and saying you want the return type to ba [[Int]] might work
07:09:56 <Axman6> if there's an instance for Arbitrary a => Arbitrary [a]
07:12:52 <gavri> that worked. thanks!
07:13:35 <gavri> I do want to restrict the integers that are present in the sublists though
07:14:42 <gavri> and that integer should be unique in the sublist
07:15:37 <Axman6> well you can use map (nub . filter (< n))
07:15:54 <Axman6> there may be better ways to do it however
07:28:00 <esteth> how do I deal with using both Arrays and Maps in the same code? Both use the ! subscript operator, but I can only import it once. Must I qualified import both and use backticks?
07:36:44 <Jafet> esteth: or rename the operators
07:37:58 <Jafet> (^-^) :: Ord k => M.Map k a -> k -> a; (^-^) = M.(!)
07:39:07 <Jafet> (Or better, use M.lookup)
07:40:38 <Jafet> Hm, there's no all-pairs shortest path better than the Dijkstra algorithm? I am disappoint.
07:44:56 <k0ral> I'm sorry I need your help again with dbus in haskell
07:45:27 <Jafet> That's okay, we all know dbus is a pain in the ass.
07:45:38 <k0ral> :) here goes
07:46:07 <k0ral> I've managed to register my app in a session bus, and to get it respond to some requests
07:46:10 <k0ral> BUT
07:46:43 <k0ral> formerly I always returned the same answer, a hardcoded string
07:46:57 <k0ral> now I want to return something different depending on the current state of the application
07:47:06 <k0ral> and this doesn't work
07:47:25 <k0ral> I had to lift all dbus functions to IO (something)
07:47:34 <k0ral> it compiles fine
07:47:41 <k0ral> but it doesn't give the expected result
07:48:05 <k0ral> is it possible to use dbus with IO callbacks ?
07:48:21 <k0ral> Jafet: if you know an alternative to dbus...
07:49:18 <gigabytes> Jafet: there are
07:51:41 <Jafet> Hidden in the dense foliage of citeseer and arxiv, yeah
07:51:57 <gigabytes> uh?
07:51:58 * Jafet dons khakis
07:52:42 <gigabytes> Jafet: my algorithms book talks about the Floyd-Warshall algorithm.
07:53:04 <gigabytes> but maybe there wasn't the question
07:53:09 <gigabytes> it*
07:54:10 <Jafet> That's slower, and it uses a ton of memory
07:54:23 <gigabytes> ok
07:54:43 <Jafet> Especially for sparse graphs
07:55:36 <luite> Jafet: don't you need |V|^2 memory anyway for storing the result?
07:56:07 <Jafet> Yes, but you don't need to be able to read from all of it at any one time
07:56:16 <luite> I know there are some more efficient data structures, but I'm not sure how easy it is to calculate them directly
07:57:21 <Lemmih> k0ral: What are you communicating with? Another Haskell program?
07:57:58 <Jafet> I believe Dijkstra's algorithm in fact uses O(|V|) space for the priority queue and result
07:59:02 <k0ral> Lemmih: for now, nothing in particular, I'm using dbus-send to see what the answers are
07:59:16 <Jafet> You can run it successively on each vertex and write its shortest paths to a mag-tape or whatever
07:59:29 <Lemmih> k0ral: Perhaps you could use zeromq.
07:59:48 <Lemmih> The Haskell binding to zeromq is quite nice.
07:59:57 <k0ral> Lemmih: I think I spotted the problem: my IO callback is kind of "executed" at the moment I register it, so that it always return the same value: that one corresponding to the very initial state of my application
08:00:45 <seit> I'm interested in creating matrices and displaying them in GUI image form.  Any recommendations for display libraries to use?
08:01:15 <Jafet> GUI, as in widgets? There are bindings to gtk and wx.
08:01:36 <Jafet> Apparently, the gtk bindings are more mature, but I don't know about that.
08:01:38 <seit> Jafet, correct.  So GTK and wx are the 'main' options?
08:01:40 <luite> what kind of matrices?
08:02:11 <seit> I'm going to be practicing some image processing and would like to generate and display results
08:02:20 <Jafet> You can of course use the win32 or xlib bindings, if you really want...
08:02:31 <luite> oh matrices with image data?
08:03:02 <seit> luite, yes.  Single component grayscale is fine for me to start with
08:03:20 <Jafet> You want to display matrices as bitmap images?
08:03:36 <seit> Jafet, yes, that is a good way to put it
08:08:51 <k0ral> Lemmih: sounds interesting, but I'm so close to have dbus working...
08:11:54 <dolio> > abs (minBound :: Int)
08:11:55 <lambdabot>   -9223372036854775808
08:14:06 <adorablepuppy> merijn: Thanks to your advice yesterday, I wrapped my head around insertion (and removal) of nodes in n-ary trees and pounded out an implementation. Thanks!
08:14:58 <merijn> adorablepuppy: np :)
08:25:32 <LeNsTR> > abs $ toInteger (minBound :: Int)
08:25:33 <lambdabot>   9223372036854775808
08:25:35 <LeNsTR> dolio: ;)
08:25:54 <FUZxxl> > foo
08:25:55 <lambdabot>   Not in scope: `foo'
08:25:57 <FUZxxl> > bar
08:25:58 <lambdabot>   Not in scope: `bar'
08:26:08 <FUZxxl> > let 4 = 5 in 4
08:26:09 <lambdabot>   4
08:26:13 <FUZxxl> hm?
08:26:31 <FUZxxl> > let 4 = undefined in 4
08:26:32 <lambdabot>   4
08:26:43 <FUZxxl> > let False = True
08:26:44 <lambdabot>   not an expression: `let False = True'
08:26:49 <FUZxxl> > let False = True in True
08:26:50 <lambdabot>   True
08:26:55 <k0ral> > let 4 = "hm?" in 4
08:26:55 <FUZxxl> > let False = True in False
08:26:56 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
08:26:56 <lambdabot>    arising from the literal ...
08:26:56 <lambdabot>   False
08:27:13 <Axman6> let 4 = x is just pattern matching x with 4
08:27:36 <FUZxxl> @Axman6 This kind of pattern matching is kind of... useless
08:27:36 <lambdabot> Unknown command, try @list
08:27:40 <Axman6> > let !4 = 5 in 4
08:27:41 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
08:27:47 <FUZxxl> ah!
08:28:00 <FUZxxl> > let !True = error "hm?" in False
08:28:01 <lambdabot>   *Exception: hm?
08:28:06 <Axman6> you want to be able to redefine numbers?
08:39:36 <erus`> let 4 = 6 in 6
08:39:44 <erus`> > let 4 = 6 in 4
08:39:45 <lambdabot>   4
08:41:31 <tswett> Hmph.  Who decided that abs and signum should go in Num?
08:41:36 <tswett> I guess people complain about that daily.
08:42:01 <merijn> tswett: People complain about the entire Num hierarchy, because in hindsight it could've been done more logically
08:44:23 * tswett sets |x| = x and sgn x = 1.
08:45:08 <k0ral> the more I read dbus documentation, the more I'm convinced it's impossibled to register an IO (*) callback
08:45:38 <k0ral> isn't there a confirmed haskell-dbus user here ?
08:50:29 <amedxy> what's my error in http://hpaste.org/47219/error_if
08:51:38 <dankna> dcoutts: ping!
08:51:40 <merijn> amedxy: Kinda of hard to tell if you don't also paste the error, but I think the second if is not indented enough
08:52:07 <mauke> indentation looks fine
08:52:31 <mauke> amedxy: missing "in" for "let" in line 2
08:52:40 <mauke> also that let is completely pointless
08:52:42 <dcoutts> dankna: pong
08:52:43 <merijn> oh, duh
08:53:26 <dankna> dcoutts: so as you may have seen, I submitted a whole bunch of patches and tickets.  I've hit an issue, ticket #852, where I think I should probably get your go-ahead before I implement anything.
08:54:08 <amedxy> i want to do (pseudocode) {if m=1 then print string1, elseif print string2, if m=n then print string 3}
08:54:09 <dcoutts> dankna: ok, I'll take a look in a bit, just answering some emails...
08:54:18 <dankna> dcoutts: oh no problem, yeah
08:54:58 <mauke> amedxy: what are m and n?
08:55:07 <amedxy> m copies n
08:55:13 <mauke> amedxy: impossible
08:55:15 <parcs> what's the ghc flag to force the use of ncg?
08:55:22 <mauke> amedxy: you can't copy things in haskell
08:55:39 <amedxy> then how to ?
08:55:55 <ben> copy :: ByteString -> ByteString
08:55:58 * DevHC copies a value of a variable in haskell
08:56:25 <mauke> amedxy: how what?
08:56:25 <merijn> Isn't copying the only thing you *can* do? :>
08:56:40 <amedxy> ammm ok
08:57:16 <tswett> amedxy: you're letting m = n, and then testing if m == n?  Isn't that going to always be true?
08:57:43 <merijn> tswett: It is
08:58:08 <amedxy> tswett: n decreesing
08:58:27 <k0ral> Lemmih: I'm dropping dbus for zeromq, you win :)
08:59:13 <tswett> amedxy: ah.  Well, the thing is, in every call to printFork, m is set to n.
08:59:37 <tswett> So if you call printFork with n = 5, it will run with n = 5 and m = 5; if you later call it with n = 4, it will run with n = 4 and m = 4.
08:59:50 <amedxy> ok
09:00:25 <tswett> I think what you'll want to do is make m and n separate arguments.  Then printFork can call itself with a lower value of n while keeping m the same.
09:03:22 <dcoutts> dankna: the problem for stub.h files at configure time goes away if they're included in .c files rather than a .h file
09:03:53 <dcoutts> dankna: but if one does want to put them in a .h file that is installed, then it's a problem, but in that case they also have to be installed and I'm not sure we do that
09:04:11 <dcoutts> dankna: or at least they'd have to be listed in install-includes
09:05:22 <dankna> dcoutts: oh, read down.  the problem is at build time now.  (it's a little hard for me to keep track of what would be happening without any of my changes, but I believe the same thing)
09:06:01 <dcoutts> dankna: the simple solution there would be to build C code after the Haskell code
09:06:12 <dcoutts> dankna: since Haskell code can only depends on the C .h files
09:06:32 <dankna> dcoutts: oh hey, yeah.  indeed.  and here I was going to do the topological sort to intermingle the builds :)
09:06:41 <dcoutts> :-)
09:07:01 <dankna> dcoutts: (not sure if you saw yet, but one of my earlier patches already implements asking gcc for the dependency information of the .c files.  it only uses it for a very minor purpose though.)
09:07:19 <dcoutts> dankna: yeah, I'm slightly suspicious :-)
09:07:39 <dankna> dcoutts: haha, yeah, I expected you might be.  when you have time I'll be happy to defend the approach.
09:08:09 <dcoutts> dankna: presumably this is only relevant for packages that build objc/C++ code
09:08:15 <dcoutts> dankna: since the FFI only talks about C
09:08:26 <dankna> dcoutts: anyway I'll go ahead and write a patch that does the C compilation after the Haskell compilation instead of before.  not sure why I didn't think of that last night, other than fatigue.
09:08:52 <dankna> dcoutts: yes, that's correct.  but that's not a reason not to do it, given that I'm the one doing the work (except for the hidden expense of maintaining it of course...)
09:09:29 <dcoutts> dankna: well I mean perhaps we need to consider the slightly wider issue of including non-C C-like language in .cabal packages
09:09:59 <dcoutts> dankna: the current way of listing Obj/C++ code in the c-sources field is either broken or only works by accident.
09:10:02 <dankna> dcoutts: it seems to work.  there was a ghc commit seven weeks ago, closing a longstanding ticket asking for support for non-C C languages.
09:10:13 <dcoutts> right, happens to work for ghc
09:10:16 <dcoutts> with some version of ghc
09:10:32 <dcoutts> not for hugs/nhc/yhc etc because Cabal doesn't know about it
09:10:38 <dankna> right, that's true.  I can see a case for something more general.  what did you hvae in mind?
09:10:40 <dcoutts> also, cabal should be compiling C code using gcc
09:10:41 <dcoutts> not ghc
09:10:49 <dcoutts> that's madness :-)
09:10:49 <dankna> ah, yes, I wondered about your position on that
09:11:05 <dcoutts> at which point we need to use the right compiler
09:11:19 <dankna> you may have seen that I already added a file Distribution.Simple.CCompiler, which is currently just stuff related to the taxonomy of C dialects...
09:12:01 <dankna> (instance Monoid CDialect :D)
09:12:07 <dcoutts> heh
09:12:15 <dankna> (mappend expresses backward compatibility)
09:12:34 <dcoutts> dankna: so presumably autoconf has different macros for testing for the presence of different .h files, one per language.
09:12:47 <dankna> yes, I believe that's true
09:14:14 <dcoutts> dankna: would dep chasing even work? You need to be able to CPP first, and that's already dialect specific.
09:15:08 <dankna> dcoutts: oh but I already have that part!  haha.  what it does is determine the dialect of each file in c-sources heuristically by its filename, and its dependencies by asking gcc with -MM -MF or something
09:15:52 <dankna> dcoutts: then it inverts the dependencies to get the list of c-sources from which each header is included, and decides the header is the mconcat of the dialects of those files
09:16:19 <dankna> (the heuristic of using filename to determine dialect should be fine, since it's what gcc does too!)
09:16:29 <dankna> (indeed I took the list of extensions allowed from the gcc docs)
09:17:08 <dankna> dcoutts: it turned out to be remarkably little code to do this, actually.
09:17:11 <dcoutts> dankna: blimey
09:17:19 <dankna> dcoutts: hehe!
09:17:28 <dcoutts> it's crazy, but it might just work
09:17:39 <dankna> it does work, for me at least :D
09:17:57 <dcoutts> it's pretty gcc specific of course
09:18:02 <dcoutts> but we currently rely on gcc
09:18:16 <dankna> well, yes, but as you say, we rely on gcc already, and anyway most C compilers have this capability in some form.
09:19:09 <dcoutts> dankna: we could in principle take that approach rather further and complain when system headers are used that were not mentioned
09:19:32 <dcoutts> ie validate the includes line
09:19:52 <dankna> dcoutts: do you mean non-system headers?
09:20:12 <dcoutts> dankna: no, system ones. The dependencies of the package are the system headers.
09:20:22 <dankna> dcoutts: and yes, we absolutely could do that.  I thought you'd be excited about the possibilities :)  I don't want to work on that just yet though because I don't want to get my repo too far "ahead" of yours :)
09:20:32 <dcoutts> yep
09:20:59 <dankna> dcoutts: oh, hmm.  although that's true, bear in mind that the information we get is the /complete/ transitive list of headers, which includes dozens of files.  (we can also ask gcc to filter it to only paths inside the source tree).
09:21:09 <dankna> (which is what I do currently)
09:21:50 <parcs> does anyone know if acid-state works with infinite data structures?
09:21:58 <dcoutts> dankna: right, though I think we can find out what includes what, so we only get the top level headers that are included.
09:22:26 <dankna> dcoutts: that's true, we can.
09:22:49 <dcoutts> parcs: you'd have to be able to serialise a finite representation of the whole thing plus finite reps of the updates/changes
09:23:50 <Lemmih> parcs: You can also choose never to create any checkpoints.
09:26:53 <frank00> I'm trying to avoid the "do notation" when dealing with monads. Using hanging lambdas is ok, but I wonder, for a line like "foo <- func bar" is there a where equivalent? Like where foo = <- func bar" ?
09:27:17 <mauke> frank00: no
09:27:18 <dankna> frank00: how do you want to use the value of foo, exactly?
09:28:17 <Lemmih> frank00: func bar >>= \foo -> ...
09:29:19 <frank00_> bloody connection
09:29:21 <frank00_> dankna: foo is something bound to func bar, like foo <- func bar in do notation
09:29:22 <frank00_> it would make my dos more tidy
09:29:38 <frank00_> by having stuff in the "where part"
09:29:41 <Lemmih> frank00: func bar >>= \foo -> ...
09:29:41 <dbpatterson> does anyone have any recommendations for libraries to access postgresql? I see (on hackage) bindings for hsql, haskelldb, and HDBC, as well as the packages libpq, postgresql, Takusen, and TemplatePG, and it's a little intimidating to figure out where to even start comparing them…
09:30:16 <Lemmih> dbpatterson: HDBC is nicest, imo.
09:30:18 <dankna> frank00_: consider then this technique: do { let getFoo = func bar ; blah blah blah ; foo1 <- getFoo ; foo2 <- getFoo ; doSomethingWith foo1 foo2 }
09:30:38 <parcs> what about corecursive data structures like: data A { foo :: Int, b :: AcidState B }; data B { bar :: String, a :: AcidState A } ?
09:30:42 <dbpatterson> Lemmih: anything specific that sets it apart?
09:30:47 <dankna> frank00_: see what's happening?  the let-statement is binding getFoo to an IO :: Foo action, which of course isn't called immediately, but you can call it repeatedly later on.
09:31:01 <cmccann> dbpatterson, see which one has the most reverse deps, then at least you know you'll be able to find usage examples
09:31:07 <parcs> (i want to model something similar to a relational db)
09:31:12 <dankna> frank00_: you can do the same thing with where too, of course
09:31:29 <frank00_> so where getFoo = func bar?
09:31:46 <dankna> frank00_: yes.
09:31:50 <Lemmih> parcs: You can't have nested acid-states.
09:32:26 <cmccann> (n.b., reverse dependencies can be found at http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html )
09:33:25 <frank00> thanks, to be honest I hoped there would something even more concise ( my IO functions are clumsy and long compared to other functions ), but that's a nice trick, thanks
09:36:29 <Saizan> parcs: if you have cyclic structures you could detangle them during serialization with data-reify
09:40:06 <parcs> ah, cyclic's the word, not corecursive :) i'll check that out Saizan
09:41:02 <Lemmih> parcs: You'd be much better off just by not using checkpoints.
09:41:59 <Lemmih> It isn't mentioned in the documentation but using data-reify will actually tarnish your soul.
09:42:18 <Saizan> hah, really?
09:43:19 <parcs> Lemmih: what is the difference between creating a checkpoint and calling update?
09:44:23 <Saizan> (if you have a cyclic structure as argument of one of your events you're screwed even without checkpoints though)
09:44:40 <Lemmih> parcs: One schedules an update. The other writes a snapshot of the state to disk. They really aren't that similar.
09:47:48 <Lemmih> parcs: Are you sure you really want cyclic structures? This sounds a bit like the X Y problem.
09:50:14 <dylukes> merijn: Seriously ._…. it's kind of obnoxious
09:50:28 <dylukes> Can we at some point, just have a fuck-all-backwards-compat GHC 8 update? >_>
09:50:57 <dylukes> fix the functor/applicative/monad hierarchy, put comonads into the standard lib, fix the number hierarchy...
09:50:58 <stepkut> Lemmih: avoiding checkpoints isn't going to really help you when you move to a cluster though, right ?
09:51:22 <stepkut> Lemmih: for multimaster, it would be fine, but if you have to get remote data..
09:51:45 <dankna> dcoutts: okay so I went to make the c-sources build after the haskell sources, and discovered that the reason we currently do it in this order is that we invoke ghc just once, letting it do the topological sort on Haskell modules.
09:51:55 <cmccann> dylukes, would be better to find ways to fix that sort of thing without a horrendous monolithic breaking change
09:52:08 <dylukes> cmccann: I don't see any.
09:52:17 <dylukes> Besides, horrendous monolithic breaking changes are needed once in a while.
09:52:18 <cmccann> since chances are it'll be wrong the second time around anyway, just hopeless a bit less so
09:52:21 <dcoutts> dankna: I don't see the issue
09:52:27 <dylukes> Otherwise, you get what I call "The Windows NT phenomenon"
09:52:46 <cmccann> dylukes, I'd rather see graceful ways of handling frequent, modularized breaking changes :)
09:52:47 <dylukes> For example, how Windows 7 actually has dll's in it with timestamps from last century.
09:52:56 <Lemmih> stepkut: The state could be cyclic even if the method arguments and return values aren't.
09:52:59 <dylukes> A breaking change is a breaking change,
09:53:03 <dylukes> better a big collective single one,
09:53:06 <dylukes> then many small ones.
09:53:12 <dylukes> Only one period of adjustment instead of dozens.
09:53:39 <stepkut> Lemmih: true.
09:53:41 <dankna> dcoutts: well, we first do ghc foo.c, ghc bar.c, etc.  then we do ghc --make Data.Nifty.A Data.Nifty.B etc etc, which does both the compilation and linking passes in one.
09:54:03 <dankna> dcoutts: what we want for the quick-fix solution is for C compilation to happen after Haskell compilation but before final linking.
09:54:05 <dcoutts> dankna: oh right, well there's no need to do it in one pass like that
09:54:20 <dcoutts> dankna: we can link executables separately at the end
09:54:28 <stepkut> Lemmih: still avoiding checkpoints only gets you so far.. eventually the replay time will become unbearable
09:54:33 <dankna> dcoutts: yeah, but we have to do the topological sort of Haskell modules ourselves if we do it separately, don't we?  not that I'm adverse to that, it would be nice anyway.
09:54:50 <dcoutts> dankna: no, there's no need to change from using ghc --make yet
09:55:07 <dankna> dcoutts: does ghc have some flag that means "update everything but don't link" then?
09:55:19 <dcoutts> dankna: we'll be switching to ghc -c anyway in future, but that's a much bigger job, and we've got a GSoC student on the case for that.
09:55:29 <dcoutts> dankna: yes
09:55:34 <dylukes> yesssss
09:55:37 <dankna> gotcha, yes.  good :)  I was willing to do that work, but I'm relieved not to have to.
09:55:41 <dylukes> oh-my-zsh added a brew plugin ^^
09:55:48 <dylukes> Switching to zsh: no regrets. Ever.
09:56:07 <dankna> okay, I'll check ghc docs and find that flag and use it.  that should solve things then.
09:58:08 <dcoutts> dankna: it's --no-link or something along those lines
09:58:15 <dankna> dcoutts: okay, cool
09:58:25 <dcoutts> dankna: but yes, check the ghc docs
09:58:38 <dcoutts> dankna: or it might be ghc --make -c, I forget
09:59:13 <dcoutts> dankna: thanks for putting time into all this, that's the main thing we're lacking :-)
09:59:41 <dankna> dcoutts: oh no problem :D it's quite selfishly motivated, I want to use the functionality, haha
10:06:17 <sale87> Hi all, I'm having problem compiling simple Gloss program on my Mac OS X. Does anybody has any idea what I'm doing wrong? http://hpaste.org/47220/gloss_mac_os_x_compile_problem
10:07:42 <dankna> sale87: it looks to me like you need to invoke it as $ ghc -package gloss hello.hs -o hello
10:09:56 <sale87> dankna: Thanks! It works now :)
10:10:17 <dankna> sale87: welcome :)
10:12:13 <gavri> in trying to generate a list of lists of elements from 0 to 4 (elements are unique within the sublist) using QuickCheck, I've tried this http://hpaste.org/47221/lists_of_lists_generation_atte and it seems to work, but I'm sure it can be improved. (the mod call should probably go away etc). any ideas about how I can fix this?
10:20:09 <joe6> need some help with this code, please? http://pastebin.com/aLyp9QsZ
10:20:36 <joe6> getAddressLocation has a return type of IO String.
10:21:07 <joe6> i am not sure how I can mix it with a return type of "Test" in a "do" statement.
10:21:29 <joe6> if the value was not needed, I could have probably used a '>> return ()"
10:21:40 <joe6> but, in my situation, the value is being used later.
10:22:23 <monochrom> IO Test. return (TestLabel ...)
10:22:25 <Feuerbach> joe6: your return type should probably be something like IO Test
10:22:54 <joe6> Feuerbach: i think Test of Test.HUnit includes the IO ..
10:23:06 <joe6> btw, this is using the Test.HUnit.
10:23:50 <Feuerbach> joe6: no, it doesn't
10:23:57 <Feuerbach> it's just a simple algebraic data type
10:24:07 <joe6> http://pastebin.com/53nXASkZ
10:24:10 <Feuerbach> http://hackage.haskell.org/packages/archive/HUnit/latest/doc/html/src/Test-HUnit-Base.html#Test
10:24:39 <monochrom> > "Assertion" == "Test"
10:24:40 <lambdabot>   False
10:25:43 <joe6> or, make the return type Assertion? the calling function is expecting the return type of Test.
10:26:04 <doserj> a test case that contains an IO actions is not the same as an IO action returning a test case
10:26:06 <monochrom> "type Assertion = IO ()" has clearly nothing to do with testing
10:26:09 <joe6> hence, wondering if there are any other ways of doing it for a return type of Test.
10:26:24 <doserj> simply use return
10:26:44 <monochrom> because then (writeFile "hello") has type "Assertion" too
10:27:00 <joe6> doserj, how? i am not sure I understand what you said.
10:27:11 <doserj> return (TestLabel ...)
10:27:33 <monochrom> <monochrom> IO Test. return (TestLabel ...)
10:28:05 <joe6> but, my functions' return type would be: return $ TestLabel undefined :: Monad m => m (Test -> Test)
10:28:10 <joe6> m Test?
10:28:17 <joe6> i am trying to get to Test
10:28:24 <joe6> is that possible?
10:28:31 <doserj> no.
10:28:33 <joe6> without the unsafeperformIO
10:28:49 <doserj> you get IO Test
10:29:36 <joe6> ok, I will break the function setByte to return an Assertion.
10:30:42 <KirinDave> joe6: Tests don't require IO, right?
10:31:14 <joe6> KirinDave, why do you say that? Assertion is IO, isn't it?
10:31:21 <joe6> that's how I have it working.
10:31:42 <monochrom> this is why "meaningful names" are harmful
10:31:56 <joe6> something like this works: http://pastebin.com/yBwPa7ZP
10:32:11 <dankna> monochrom: I profoundly disagree
10:32:23 <dankna> monochrom: I'm not sure I even see the case
10:33:03 <KirinDave> joe6: What is Test?
10:33:08 <monochrom> "type Assertion = IO ()" suddenly makes people think it is related to the ADT called "Test" just because of "assertion" and "test"
10:33:16 <KirinDave> Yeah
10:33:26 <KirinDave> I was gonna say, monochrom, it looks to me like that function returns IO ()
10:33:49 <doserj> well, Assertion is simply not a meaningful name :)
10:33:55 <doserj> (in this case)
10:33:58 <KirinDave> Hah
10:34:09 <KirinDave> One would more properly call it "ToAssert,RightNow"
10:34:13 <KirinDave> ;)
10:34:15 <dankna> monochrom: mm... the confusion demonstrably exists, so I won't say that sounds unlikely, but I think it's not the name that's to blame, but rather the person who makes unwarranted assumptions
10:34:22 <dankna> monochrom: that, and what KirinDave just said
10:34:43 <KirinDave> An assertion is just a function. To use it to assert is IO (), with the possibility of exception
10:35:11 <KirinDave> If you wanna know what's poorly named
10:35:14 <KirinDave> IO. ;)
10:35:27 <KirinDave> Although what you would call it, I dunno. It is an odd thing.
10:35:32 <joe6> oh, so, I should not be using a returntype of Assertion, but using IO()?
10:35:52 <KirinDave> joe6: If you are asserting, then yes.
10:35:54 <dylukes> I would have some sort of indication of the error, som Error type
10:35:57 <joe6> assertEqual :: (Show a, Eq a) => String -> a -> a -> Assertion
10:35:57 <dylukes> and then wrap it in IO...
10:36:01 <dylukes> IO Assertion
10:36:02 <dylukes> or somethin
10:36:03 <dylukes> :|
10:36:04 <KirinDave> If you are just making assertions for later use in the active act of asserting, then no.
10:36:22 <joe6> that is all I am doing. Wrapping up the assertions
10:36:59 <joe6> my functions are basically wrappers on assertEqual or assertBool.
10:37:00 <KirinDave> joe6: And note
10:37:01 <KirinDave> joe6: type Assertion = IO ()
10:37:05 <KirinDave> http://hackage.haskell.org/packages/archive/HUnit/latest/doc/html/Test-HUnit-Base.html#t:Assertion
10:37:59 <KirinDave> joe6: So you said earlier you were "trying to get to test"
10:38:13 <KirinDave> joe6: What did you mean there?
10:39:16 <KirinDave> Because if you have an IO Test, and you'd like to alter that value, fmap works.
10:39:23 <joe6> I have functions that return Assertions, and then functions that wrap them into Test, and then functions that wrap them into Test using TestList.
10:39:58 <joe6> Assertion -- TestCase -- TestList
10:40:13 <KirinDave> Right
10:40:20 <joe6> and this function that has IO String in it, is returning a Test.
10:40:30 <KirinDave> Well it must return an IO Test
10:40:36 <KirinDave> If it has an IO String you are evaluating.
10:40:41 <KirinDave> IO is a stickler like that.
10:40:59 <joe6> then I would have to change the TestList function to reading IO Test functions instead of Test.
10:41:06 <KirinDave> You do not
10:41:17 <joe6> I would rather just change this function into an TestCase $ Assertion
10:41:21 <KirinDave> In an IO action you can use the do notation and <- to get the value.
10:41:42 <djahandarie> (Or use >>=)
10:41:48 <KirinDave> (yes, or use >>=)
10:41:54 <joe6> http://pastebin.com/UNm3gLgD
10:41:57 <KirinDave> You're chaining monadic functions here, you don't work with the return values directly
10:42:05 <KirinDave> That's why we have a Monad typeclass and instances.
10:42:10 <dylukes> I've found a couple things
10:42:12 <joe6> this includes the function that is calling this function
10:42:18 <dylukes> If you ever find yourself using manual binding instead of do notation,
10:42:23 <bustakheops> Hi ! I need to read bit per bit a bytestring until I found the list of bit [0,1,1,1,1,1,1,1,1,1] how I can do this?
10:42:25 <dylukes> you could probably be using applicative instead.
10:42:29 <dylukes> and it'd be prettier that way~
10:42:31 <KirinDave> Write a function that takes Assertion -> IO TestCase
10:42:55 <KirinDave> And then go makeMyAssertion >>= myAssertionToTestCase
10:42:57 <djahandarie> dylukes, I don't see how that's a useful metric for switching to Applicatives.
10:43:07 <dylukes> Not a useful metric, no
10:43:12 <dylukes> but it usually seems to apply >_>
10:43:18 <dylukes> Just pointing out the strange correlation.
10:43:28 <djahandarie> ...which would make it useful, and that's what I'm disagreeing with.
10:43:36 <joe6> KirinDave, that is more work compared to just changing setData to TestCase $ Assertion
10:43:40 <joe6> ?
10:43:53 <joe6> KirinDave: does that make sense?
10:44:01 <KirinDave> I am looking at your code
10:44:06 <joe6> oh, ok.
10:44:08 <joe6> thanks.
10:44:44 <KirinDave> joe6: I mean, the way you are doing it there is fine, it works.
10:45:00 <KirinDave> joe6: Just keep min mind you're in an effectful world, so you're doing monadic code.
10:45:10 <joe6>  address <- getAddressLocation hin hout "usb_controlled_eeprom_data"
10:45:15 <KirinDave> Right.
10:45:21 <joe6> that sentence is the problem.
10:45:34 <joe6> i would have to wrap it all with TestCase $ Assertion.
10:45:39 <dafis> bustakheops: that's kind of inconvenient, are there any restrictions on where that bit sequence can start?
10:47:08 <KirinDave> joe6: http://pastebin.com/RwQeCeQz
10:47:15 <KirinDave> joe6: If your data generator is monadic
10:47:20 <KirinDave> Oh shoot
10:47:28 <KirinDave> I forgot to add IO Test to the top type signature.
10:47:31 <bustakheops> dafis : there isn't restriction, I just know it's beetween Byte number 6 and byte number 6+255
10:47:51 <KirinDave> Well you get the idea. Line 1, it should end in -> IO Test instead of -> Test
10:48:11 <KirinDave> The other alternative you have here, sir
10:48:33 <KirinDave> And of course I dunno how you are applying f so I didn't add it.
10:48:34 <KirinDave> but
10:48:58 <KirinDave> What you need to do is either grab the value of getAddressLocation "above" your functional code in your effectful code.
10:49:08 <KirinDave> OR you have to drag IO around with you throughout your test generations.
10:49:10 <joe6> KirinDave: oh, ok. I get it.
10:49:14 <joe6> KirinDave: thanks.
10:49:17 <KirinDave> I'd recommend the former
10:49:31 <KirinDave> You're on the right track with what you're already doing, you just need to get IO removed.
10:49:49 <KirinDave> joe6: I hope it was helpful.
10:49:53 <joe6> KirinDave: yes, I prefer the former.
10:49:58 <joe6> KirinDave: Thanks
10:50:17 <joe6> KirinDave: ofcourse, any criticism/comments/thoughts/insights is good.
10:50:20 <KirinDave> Holy crap did I just successfully explain something involving monads in #haskell?
10:50:24 <joe6> and appreciated.
10:52:16 <monochrom> hahaha KirinDave welcome to the club
10:52:33 <KirinDave> monochrom: I didn't even know it could be done
10:53:08 <monochrom> more seriously, shows you the difference between subjective "understand" and objective "understand"
10:53:15 <dafis> bustakheops: well, you could check each byte for possible beginnings and then for completion, byte i = 127, byte (i+1) >= 192, (byte i & 127 == 63, byte (i+1) >= 224), (byte i & 63 == 31, byte (i+1) >= 240), ..., (byte i & 1 == 0, byte(i+1) == 255, byte (i+2) >= 128; or you could unpack the bytes, unpack each byte to eight bytes (b -> [(b >> 7) & 1, (b >> 6) & 1, .., b&1]) and look for the sequence there
10:56:25 <joe6> @hoogle zipWithM
10:56:25 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
10:56:25 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
10:56:25 <lambdabot> Data.Generics.Twins gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
11:00:34 <KirinDave> monochrom: Not sure I get what you mean. :)
11:01:52 <joe6> if anyone cares, this is what I ended up with: http://pastebin.com/9MaCqMay
11:02:20 <KirinDave> joe6: Not a bad way to go about it.
11:03:27 <esteth> I've managed to construct an instance of Monad where return and bind are not functions, but constructors. How does this work when I use bind, since I haven't really defined how to plumb two statements together, have I?
11:03:54 <amedxy> how to solve parse error ? http://hpaste.org/47223/parse_error_if
11:04:25 <doserj> esteth: you have
11:04:50 <ion> esteth: ‘printStr x y ",--\n" if n == 1’ is not a valid expression. You may want ‘do printStr …; if …’
11:05:13 <ion> Whoops. s/esteth/amedxy/
11:05:29 <adorablepuppy> Hey there, I need a bit of help fixing this. Basically I've made a n-ary tree implementation. Each leaf has a specific type it can store. And I was working on my lastest type, a function, when it gives me an error about deriving show. http://hpaste.org/47222/propertytree_functionleaf The only problem is, I don't know how to derive Show from this spot. The applicable code line is 10, the FunctionLeaf.
11:05:51 * edwardk waves hello.
11:06:06 <esteth> doserJ: Have I said "a >>= b is equiavalent to Data a b" ?
11:06:20 <ion> adorablepuppy: You can’t autoderive Show if one of the fields isn’t an instance of Show. You’ll have to implement the Show instance manually.
11:06:50 <doserj> esteth: if you said "instance Monad Blah where (>>=) = Data", then yes.
11:06:56 <adorablepuppy> ion: So, take out the derive ( Show ) for the Tree, then instance it myself?
11:07:04 <merijn> adorablepuppy: Yes
11:07:37 <adorablepuppy> ion, merijn: Many thanks. I'll mark you in the commit messages for credit on helping me with this.
11:07:41 <doserj> adorablepuppy: are you sure about FunctionLeaf?
11:07:53 <adorablepuppy> doserj: Sure about?
11:08:12 <ion> f :: PropertyTree -> () can’t really do anything useful.
11:08:17 <doserj> adorablepuppy: what purpose does something of type PropertyTree -> () have?
11:08:41 <KirinDave> esteth: Sometimes it's pretty surprising how that works out
11:08:52 <KirinDave> esteth: But really, monads are a shape. If yo match the shape, it will work. :)
11:08:56 <adorablepuppy> doserj: Quite right, I'm changing it to ( PropertyTree -> PropertyTree )
11:09:13 <adorablepuppy> Thanks again guys.
11:09:19 <Nereid> esteth: does your implementation satisfy the monad laws? c:
11:09:24 <esteth> doserj / KirinDave: This is strange.
11:09:51 <esteth> Nereid: I haven't checked
11:10:25 <KirinDave> esteth: Does it work?
11:11:01 <esteth> KirinDave: It appears to, for the cases I've ran through it
11:11:12 <esteth> but I don't understand why any of it works
11:11:24 <esteth> I've copy-pasted little bits and pieces from all over
11:11:31 <adorablepuppy> Changed it to instance and changed it to ( PropertyTree -> PropertyTree ) and it works great. :) This is going better and easier than I expected.
11:15:55 <esteth> I have a function "Instruction -> Mips ()" and Mips is an instance of monad, so each of those works. But I seem to have built my own state monad type thing that pattern matches over the constructors of Mips and implements the actual operations. Only this function is never declared as part of the monad instance declaration.
11:17:28 <KirinDave> esteth: As dibblego and apocalisp would say, "Programming... with functions!" ;)
11:17:35 <esteth> specifically I'm confused about the interaction between machineExecute, executeInstruction and the monad declaration. http://hpaste.org/47224/confusion
11:24:37 <dafis> esteth: machineExecute' is basically runState and machineExecute execState, executeInstruction, writeRegister etc. would be normal functions (args -> State MipsState resultType)
11:27:06 <esteth> Right. So a function defined as args -> Mips a actually constructs a tree type structure of Mips constructors, which machineExecute' unwraps?
11:30:35 <dafis> esteth: yep
11:31:53 <keep_learning> i want to represent Double in form of ( nominator , denominator ) .
11:32:01 <keep_learning> how can i do this in Haskell
11:32:20 <keep_learning> i am not sure what keyword use to search
11:32:48 <Liskni_si> keep_learning: http://haskell.org/ghc/docs/latest/html/libraries/base-4.3.1.0/Data-Ratio.html
11:33:22 <keep_learning> Liskni_si, thank you
11:34:27 <Guest82005> Hey everyone.  I'm trying to run the code at http://hpaste.org/47225/loancalc and ghci is telling me I have non-exhaustive patterns, but I can't see it.  Can anyone tell me what I'm missing?
11:36:25 <NisseP> in the last clause of runChanges you have a lowercase c
11:36:59 <Guest82005> aha!  I knew I was missing something obvious.
11:37:27 <dankna> that's the right attitude.  it's /always/ something simple.  it's just a question of which simple thing.
11:38:00 <Cale> btw, repeating that part is unnecessary -- you can blank out everything before the | there
11:38:07 <merijn> Isn't that line with the lower case c unneces...dammit
11:38:48 <merijn> Cale has telepathic question answering skills >.>
11:47:16 <esteth> dafis: Sorry for more questions, but how might I compose multiple args -> Mips a functions?
11:48:13 <dafis> esteth: (>>=) ? (perhaps I don't understand what you're asking)
11:48:34 <Guest82005> keep_learning:  Data.Ratio.approxRational will give you a ration from a Double & a precision.  From there you can use numerator and denominator.
11:48:53 <Guest82005> A rational, not a ration.
11:49:14 <esteth> dafis: That's what I thought, but I get a http://hpaste.org/47226/error
11:49:21 <keep_learning> Guest82005, thank you
11:50:42 <dafis> esteth: in that case, (>>) instead of (>>=)
11:51:32 <esteth> oh!
11:51:40 <esteth> that seems obvious now, sorry
11:53:33 <dafis> esteth: np
11:56:38 <adorablepuppy> If I use FunctionLeaf "Test" ((\ x -> x) :: (PropertyTree -> PropertyTree)), my FunctionLeaf works, but if I leave it FunctionLeaf "Test" (\ x -> x ) it won't. Is that because ghc can't infer the type of (\ x -> x ) implicitly?
11:58:03 <adorablepuppy> I know (\ x -> x) is a useless function, but this was just a test of a (PropertyTree -> PropertyTree)
11:59:10 <Cale> GHC can infer the type of (\x -> x)
11:59:15 <Cale> :t (\x -> x)
11:59:15 <lambdabot> forall t. t -> t
11:59:27 <jrick> :t id
11:59:28 <lambdabot> forall a. a -> a
12:00:48 <Cale> (\x -> x) is a very useful function, so much so that it has a 2-letter name in the Prelude, as jrick shows :)
12:01:29 <ben> :t ($)
12:01:30 <lambdabot> forall a b. (a -> b) -> a -> b
12:01:39 <ben> close enough
12:01:54 <adorablepuppy> errr. Wait. For some reason it's not throwing a type error when I give it that now.
12:02:09 <Cale> Without seeing the context of your program, I'm not sure why that would require a type signature. It could be that there's a typeclass around and GHC needs to know which instance to use, but can't tell because id is too polymorphic
12:02:35 <adorablepuppy> Cale: It is working. I think I had a misplaced parenthesis or something.
12:02:53 * adorablepuppy sneaks away shamefully.
12:03:01 <Cale> That's all right :)
12:04:12 <chrisdone> Who's coming to CamHac? :-) http://www.haskell.org/haskellwiki/CamHac
12:04:40 <luite> I hope to, but I'm not sure if I can :(
12:07:04 <increpare> chrisdone: I really want to
12:07:08 <increpare> but need to think of something to do at it
12:07:19 <increpare> (haven't been haskelling properly in a while, but I live in cambridge)
12:07:35 <luite> I probably only have my own projects to work on
12:10:31 <chrisdone_> Sounds good to me!
12:12:01 <beastaugh> chrisdone_: I'll probably be there
12:12:31 <chrisdone_> Got anything planned to work on?
12:12:45 <chrisdone_> I'm just looking at hotel reviews and prices in the area.
12:18:40 <Lemmih> chrisdone_: I'll attend as well if I can find cheap accommodation.
12:18:50 <tgeeky> how can done do multiline definitions with lambdabot?
12:19:38 <Jafet> @let foo = ("Like":)
12:19:39 <lambdabot>  Defined.
12:20:01 <Jafet> @let bar = unwords . ($["this?"])
12:20:03 <lambdabot>  Defined.
12:20:11 <Jafet> > bar foo
12:20:13 <lambdabot>   "Like this?"
12:20:28 <Jafet> @undefine
12:22:03 <tgeeky> Jafet: perhaps easier to accomplish, is there anything builtin to lambdabot that does primality testing?
12:22:12 <tgeeky> someone wants me to demonstrate that with a lambdabot :|
12:22:23 <chrisdone_> Lemmih: Doesn't look like there're much cheap ones. Even the guest houses are 50~, whereas the Travelodge is 60-70 a night, which even that doesn't seem to have internet connection. Kinda lame.
12:22:37 <Jafet> You can't write that in one line?!
12:22:40 <chrisdone_> JaffaCake: Does Cambridge central have free wireless access points?
12:22:58 <tgeeky> Jafet: for meserenne primes?
12:23:01 <tgeeky> no
12:23:37 <tgeeky> not and expect it to finish
12:23:56 <Jafet> Ok, I accept
12:23:58 <chrisdone_> shapr: Coming to CamHac? :-)
12:24:13 <tgeeky> Jafet: lol
12:24:42 <chrisdone_> Twey: You better be going!
12:25:22 <shapr> chrisdone_: I doubt I'll make it to either Cambridge, but I appreciate the invitation :-)
12:25:46 <Jafet> > let llp p = let n = 2^p-1 in iterate (\s -> s*s-2 `mod` n) !! (p-2) in map llp [0..]
12:25:47 <lambdabot>   Couldn't match expected type `[a]'
12:25:47 <lambdabot>         against inferred type `a1 -> [a1]'
12:25:50 <esteth> I might be able to go to CamHac, the price of hotels is prohibitive though
12:25:54 <Jafet> > let llp p = let n = 2^p-1 in iterate (\s -> s*s-2 `mod` n) 4 !! (p-2) in map llp [0..]
12:25:55 <lambdabot>   [*Exception: Prelude.(!!): negative index
12:26:08 <Jafet> > let llp p = let n = 2^p-1 in iterate (\s -> s*s-2 `mod` n) 4 !! (p-2) in map llp [3..]
12:26:09 <beastaugh> chrisdone_: no, nothing planned yet
12:26:09 <lambdabot>   [14,194,37634,1416317954,2005956546822746114,402386166774103602282563565610...
12:26:17 <Jafet> Oops.
12:26:22 <increpare> chrisdone_: there's a hostel in cambridge that may not be as expensive as the hotels
12:26:25 <beastaugh> I'm casting around for a new project at the moment, so probably whatever I come up with
12:26:32 <chrisdone_> increpare: What's the name?
12:26:53 <increpare> chrisdone_: http://www.yha.org.uk/find-accommodation/east-of-england/hostels/cambridge/index.aspx
12:27:02 <increpare> I'll add it to the accommodation list
12:28:13 <esteth> in fact, I'll be staying in ipswich during camHac. Is it reasonable to "commute" to cambridge and back?
12:28:27 <esteth> it seems so from the public transport sites, but I'd like to make sure that it's feasible
12:28:34 <increpare> will be a bit awkward I'd guess, but I'm not sure
12:28:38 <chrisdone_> 1 MALE Bed(s) in shared single sex rooms - Adults 	£18.40
12:28:38 <chrisdone_> 1 Room 2 beds 	£46.00
12:28:41 <chrisdone_> Ney bad, ney bad.
12:30:30 <Jafet> > let llp p = let n = 2^p-1 in iterate (\s -> (s*s-2) `mod` n) 4 !! (p-2) == 0 in filter llp [3..]
12:30:34 <lambdabot>   mueval-core: Time limit exceeded
12:30:56 <Jafet> I don't really think there's much you can do about that
12:31:29 <tgeeky> Jafet: yeah, don't worry
12:31:39 <Jafet> > let llp p = let n = 2^p-1 in iterate (\s -> (s*s-2) `mod` n) 4 !! (p-2) == 0 in map llp [11213, 19937, 21701]
12:31:43 <lambdabot>   mueval-core: Time limit exceeded
12:31:48 <Jafet> > let llp p = let n = 2^p-1 in iterate (\s -> (s*s-2) `mod` n) 4 !! (p-2) == 0 in map llp 11213
12:31:49 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
12:31:50 <lambdabot>    arising from the literal `...
12:31:53 <Jafet> > let llp p = let n = 2^p-1 in iterate (\s -> (s*s-2) `mod` n) 4 !! (p-2) == 0 in llp 11213
12:31:55 <lambdabot>   True
12:32:14 <dankna> Gah!  I accidentally hosed my Cabal library while, uh, modifying it :)
12:32:18 <chrisdone_> increpare: We can go halves on the two-bed room if you want. Avoids staying in a bunk bed with inevitable a snoring Santa Claus above you a la the shared rooms.
12:32:31 <increpare> chrisdone_: I live in cambridge
12:32:33 <chrisdone_> dankna: git reset --hard? :)
12:32:34 <increpare> actually, one sec
12:32:44 <dankna> I observed that I couldn't see how it was ever managing to build executables, and as soon as I saw that, it stopped being able to
12:32:46 <chrisdone_> increpare: Oh, sorry, I'm talking to the wrong person.
12:32:48 * chrisdone_ scans up
12:32:53 <increpare> oh ok!
12:33:28 <increpare> chrisdone_: what do you think you'll be working on at it?
12:33:37 <dankna> chrisdone_: well it's in darcs not git, and I can revert the changes but I can't build the binaries with the reverted changes because I've been installing my intermediate versions over the global ones so I can test them in real usage scenarios
12:34:05 <chrisdone_> esteth: Meant you! Then again if you're shacked up in Ipswich and you can commute, maybe not necessary to hotel, yeah.
12:34:23 <dankna> chrisdone_: but I saved a binary of the GHC .pkg installer for this purpose, and I can reinstall all the packages that that will uninstall by copying the appropriate files back into package.conf.d...
12:34:31 <dankna> chrisdone_: so I'm fine.  but it's an "oops" at least.
12:34:52 <increpare> chrisdone_: with regards to getting free wireless in cambridge central, there're a couple of cafes that do it
12:34:52 <esteth> chrisdone_: After looking into it, The commute seems like the best deal, if I'm honest. I can get a return for £15 per day with my railcard
12:34:54 <chrisdone_> increpare: I have no idea, I have about ten projects that I switch between depending on my mood, and I'll see what other people are working on and might join in
12:35:00 <increpare> chrisdone_: :)
12:35:14 <chrisdone_> esteth: Ah, sounds alright. :-)
12:35:17 <esteth> chrisdone_: Thanks for the offer though :)
12:38:26 <chrisdone_> Anyway, I'm off. See you chaps in Cambridge.
12:39:45 <kniu> what if
12:40:00 <kniu> tagged unions were anonymous types, like tuples?
12:40:22 <kniu> or records?
12:43:07 <ddarius> There's nothing "anonymous" about either tuples or records.
12:44:40 <Jafet> > let ll p = let n = 2^p-1; reduce k | k <= n = k | otherwise = reduce $ (n .&. k) + shiftR k p in iterate (\s -> reduce (s*s-2)) 4 !! (p-2) `elem` [0,n] in ll 19937
12:44:43 <lambdabot>  Terminated
12:45:17 <ddarius> Doing iterate f z !! n is a bad pattern.
12:46:02 <Jafet> Not rewritten out?
12:46:57 <ddarius> I'm pretty sure it isn't, but the problem isn't the traversal.  Even if it was fused, it would still be bad.
12:47:46 <ddarius> (It's bad with a strict f I should say.)
12:48:04 <Jafet> > let ll p = let n = 2^p-1; reduce k | k <= n = k | otherwise = reduce $ (n .&. k) + shiftR k p; go s 0 = s; go !s !i = go (reduce $ s*s-2) (i-1) in go (reduce 4) (p-2) `elem` [0,n] in ll 19937
12:48:06 <lambdabot>   True
12:48:44 <Jafet> Finally in my life I got to use bang patterns to optimize a lambdabot expression
12:49:00 <ddarius> (And actually, if I really wanted to be accurate, its eagerness, not strictness that's the issue.)
12:50:22 <Jafet> I still don't see what you mean, though
12:51:15 <Jafet> What happens is that iterate builds a list of thunks pointing backwards...
12:52:06 <adorablepuppy> What would you expect a show message for FunctionLeaf "Test" (\ x -> x ) to show you? I've got it as: FunctionLeaf "Test" (func :: PropertyTree -> PropertyTree)
12:52:36 <Jafet> Then (!!) takes one of them and ships it off to be evaluated, which is when the thunks get collected
12:52:55 <Jafet> Is that what you mean by "the problem"?
12:53:19 <ddarius> > iterate succ 1 !! 10000000
12:53:25 <lambdabot>   mueval-core: Time limit exceeded
12:53:29 <dylukes> So, how are thunks actually implemented underneath?
12:53:39 <dylukes> As some sort of light-weight lazy future?
12:53:53 <parcs> how does one nicely compose RWSTs with a different Reader value? i'm currently manually performing this: http://paste.pocoo.org/show/397326/
12:53:55 <Jafet> adorablepuppy: as a rule of thumb, read and show should be inverses of each other.
12:53:59 <dylukes> ohbtw, whats the STG paper? I'd like to read that.
12:54:10 <dylukes> this should be true: read . show == id
12:54:17 <Jafet> Since you can't read the function back, though, this rule becomes tricky to follow
12:54:22 <ddarius> Jafet: That doesn't matter if you don't implement Read.
12:56:08 <adorablepuppy> ddarius, Jafet: I think what I have describes what it is well enough for me, but since this is an open source project, I figured I'd get second opinions.
12:57:10 <solrize> @hoogle (:::)
12:57:11 <lambdabot> No results found
12:57:20 <sx> hi, does anyone know wheter there exist some fuse haskell bindings, and where i can get them from?
12:57:32 <ddarius> @hackage hfuse
12:57:33 <lambdabot> http://hackage.haskell.org/package/hfuse
12:58:10 <ddarius> @hackage HFuse
12:58:10 <lambdabot> http://hackage.haskell.org/package/HFuse
12:58:27 <Jafet> adorablepuppy: there isn't any definitive way to show functions, so just use whatever message that gives the information you need
12:59:07 <sx> ddarius: k thx
13:00:05 <Jafet> adorablepuppy: you could tag a function with a descriptive string, and show that string
13:02:08 <adorablepuppy> Jafet: I suppose I could use the String I've already got to describe the inner function, it's already showing, yes.
13:02:49 <adorablepuppy> But then it might be hard to access the function by key value. . . Hmmm
13:10:50 <MHD0> how can I update base? cabal tells me it's impossible
13:11:13 <mauke> MHD0: it is impossible
13:11:23 <MHD0> 'kay
13:11:33 <Zao> MHD0: The `base' version is kind of inherent in the Haskell compiler you have.
13:11:42 <MHD0> oh. okay
13:11:42 <Zao> If you want a newer/older base, get a newer/older compiler.
13:12:38 <Jafet> In cabal we trust
13:13:56 <MHD0> I thought the Stream library looked interesting, so I tried to cabal install it, but then I got a cryptic error message about base dependency
13:14:31 <Twey> Gah, chrisdone… never tells me where/when this stuff is going on
13:15:23 <Jafet> @hackage streams
13:15:23 <lambdabot> http://hackage.haskell.org/package/streams
13:15:36 <Twey> Ah, there is a wiki page now
13:15:36 <Jafet> MHD0: your base is <4?
13:15:48 <MHD0> how do i check?
13:15:57 <Jafet> ghc-pkg describe base
13:16:30 <MHD0> yeah it is o///o
13:16:36 <MHD0> got 3.0.3.1
13:16:47 <MHD0> and GHC version 6.10.4
13:16:48 <Jafet> .oO(Man, which ghc is that from?)
13:16:54 <MHD0> update time much?
13:17:00 <mauke> MHD0: yay, a 6.10 buddy
13:17:40 <MHD0> Also just found that my MikTex was dated...
13:18:10 <gio123> hi
13:18:23 <Jafet> While we're at it, try to avoid upgrading prim, rts, or ffi.
13:18:34 <ddarius> MHD0: The Hackage page lists on which GHCs the code built.  Since this is automated, if your GHC isn't listed, then it probably doesn't build on your GHC.
13:19:38 <MHD0> Jafet: What's those stand for? I know FFI = Foreign Function interface
13:22:05 <tgeeky> MHD0: RHS = haskell runtime system
13:22:15 <dafis> s/RHS/RTS/
13:22:52 <dafis> MHD0: and don't try to upgrade containers, array, process, directory either, all baked into the compiler
13:22:53 <MHD0> and prim is GHC.Prim?
13:23:06 <dafis> MHD0: and a few other modules
13:23:08 <MHD0> okay
13:23:09 <MHD0> :P
13:23:12 <MHD0> I get it now
13:23:22 <MHD0> ANFSCD
13:23:36 <dafis> ANFSCD???
13:23:38 <MHD0> Anybody used the LLVM module?
13:24:41 <dafis> yay, testsuite not half through and 259 unexpected failures :)
13:25:19 <MHD0> dafis: And Now For Something Completely Different
13:25:28 <MHD0> dafis: ANFSCD
13:25:41 <dafis> aah, that
13:25:50 <MHD0> dafis: They use it all the time on the python IRC's
13:26:38 <dafis> MHD0: just not used to acronyms/initialisms
13:27:41 <MHD0> Anybody ever used the LLVM compiler in haskell?
13:36:09 <joe6> MHD0: why do you ask?
13:37:19 <mdgeorge> hello
13:37:52 <mdgeorge> has anyone done a lot of generic programming in C++ and can help me translate some concepts?
13:37:56 <Cale> hi
13:38:07 <Cale> Um, I can't say that I have, but I can try to help anyway
13:38:16 <Eelis> mdgeorge: i've done a fair bit
13:38:52 <mdgeorge> I'm a little bit shaky on both the C++ and haskell side, so I might not be able to describe too well
13:38:58 <Eelis> mdgeorge: not much of it translates easily to Haskell though, because Haskell doesn't have an equivalent of template specialization
13:39:19 <mdgeorge> I'm looking at the CGAL library, which is heavily parameterized
13:39:32 <mdgeorge> Eelis: ah, that's what I was afraid of
13:39:51 <Eelis> mdgeorge: for this reason, things like IntMap and Map cannot be neatly unified in Haskell
13:39:57 <Eelis> which is embarrassing
13:40:09 <Cale> Well...
13:40:11 <mdgeorge> yeah, I was expecting the haskell situation to be superior to C++
13:40:11 <mauke> not even with type families?
13:40:23 <Jafet> Not even with overlapping instances?
13:40:24 <Cale> There is a way to do that with sufficient type hackery
13:41:18 <mauke> mdgeorge: it's kind of superior because vector<T> and vector<bool> can't be neatly unified in C++ either ... but that's not what I'd call "superior" actually
13:41:40 <Cale> I think part of the reason it's not already like that is that we'd kinda like to keep the basic containers package working in hugs and other less-fancy Haskell implementations.
13:42:11 <mdgeorge> ok, let me be concrete, and maybe people can provide answers using these different mechanisms
13:42:15 <Eelis> mauke: eh? the whole point of the vector<T>/vector<bool> debacle is that they unified things which shouldn't have been unified in the first place. so it's a particularly lousy example to point to as something that cannot be neatly unified, because it's not supposed to be unified in the first place
13:42:32 <Eelis> this is a known defect in the C++ stdlib.
13:42:38 <Eelis> but it is not caused by the language.
13:42:49 <Eelis> it was just a poor choice made by the library designers.
13:43:03 <mdgeorge> let's say I want to write a convex hull algorithm, which is agnostic to the types of the points
13:43:11 <Jafet> I believe the GHC overlapping instance matching rules are similar to C++ template specialization matching rules
13:43:13 <mdgeorge> maybe the types of the numbers used to define the points
13:43:29 <Jafet> Since I don't know either exactly, though, I could be wrong
13:43:39 <Eelis> Jafet: you need more than that though. you also need type families probably.
13:43:48 <Eelis> and even then it'll be awkward
13:44:13 <Eelis> still, i'd very much like to see people try
13:44:17 <Cale> Probably you'd just get away with using a parametric type:  convexHull :: (Num a) => [Point2 a] -> [Point2 a]
13:44:24 <Cale> (in a simplistic case)
13:45:09 <mdgeorge> so in cgal, the library I'm trying to emulate, they have a notion of a "kernel", which is a type that contains a whole bunch of related types and methods
13:45:40 <Cale> You could generalise that further in various ways -- decide what operations are required of a type of points in general in order to define/compute their convex hull, and use a typeclass, or represent points literally as records of those operations.
13:46:23 <mdgeorge> ok, let me try a more complicated example
13:46:53 <mdgeorge> let's say I wanted to write an algorithm that uses points and lines, but that the types of the points and the lines should be flexible, yet they have to agree
13:47:04 <Cale> okay
13:47:05 <mdgeorge> in other words, the points and lines need to use the same number types
13:47:46 <mdgeorge> oh I see, you would suggest (Num a) => Point2 a -> Line2 a -> a
13:47:47 <Cale> isPointOnLine :: (Num a) => Point a -> Line a -> Bool
13:47:48 <mdgeorge> or whatever
13:47:51 <Cale> yeah
13:47:53 <mdgeorge> I see
13:48:41 <Cale> You can be more polymorphic still, and do something to generalise your algorithms over the representation of point and line values themselves, and not just on the number types going into those.
13:48:53 <mdgeorge> can you give an example of that?
13:49:07 <Jafet> class AffineSpace point vector where (++>) :: point -> vector -> point; (-->) :: point -> vector -> point; (<->) :: point -> point -> vector; ...
13:49:15 <Cale> Well, doing that requires that we decide ahead of time what the basic operations we demand of a point type...
13:49:21 <Jafet> Replace my operator names with less ridiculous ones
13:49:26 <Cale> class Point p where
13:49:50 <Cale>   distance :: p -> p -> Double
13:49:55 <Cale> ^^ let's be simplistic ;)
13:50:01 <mdgeorge> I think I see
13:50:18 <Cale> and then you can use that point class:
13:50:19 <Eelis> Cale: sounds more like MetricSpace :)
13:50:24 <Cale> yeah
13:50:42 <mdgeorge> or ElementOfMetricSpace?
13:50:55 <mdgeorge> which is the usual convention for naming things?
13:51:02 <Cale> Well, we'd literally be saying that the type p is a metric space
13:51:03 <Eelis> hm, i don't think so
13:51:07 <Eelis> yeah
13:51:07 <Cale> So MetricSpace is a good name
13:51:19 <Cale> within :: (MetricSpace p) => Double -> p -> p -> Bool
13:51:29 <Cale> within epsilon x y = distance x y < epsilon
13:51:47 <Eelis> you can also take within as the primitive
13:52:11 <mdgeorge> I love how discussions here always end up on tangents :)
13:52:21 <Eelis> sorry :(
13:52:28 <mdgeorge> no, I really do love it :)
13:52:33 <mdgeorge> I wasn't being facetious
13:52:36 <mdgeorge> I think it's cool
13:52:36 <Eelis> ok :)
13:53:45 <erus`> i love the word facetious
13:53:58 <erus`> and arrested development
13:54:57 <Cale> class ConvexHullTraits p where
13:55:07 <Cale> er...
13:55:14 <Cale> class (Eq p) => ConvexHullTraits p where
13:55:35 <Cale>   lessXY :: p -> p -> Bool
13:55:40 <Cale>   lessYX :: p -> p -> Bool
13:56:08 <Cale>   lessYX y x = lessXY x y -- default implementation
13:56:26 <Cale>   leftTurn :: p -> p -> p -> Bool
13:56:49 <Cale>   lessSignedDistanceToLine :: p -> p -> p -> p -> Bool
13:57:09 <Cale>   lessRotateCCW :: p -> p -> p -> Bool
13:57:21 <Cale> http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Convex_hull_2_ref/Concept_ConvexHullTraits_2.html
13:57:30 <mdgeorge> just was looking at that :)
13:57:53 <mdgeorge> so I guess concepts in C++ map roughly to type classes in haskell
13:57:57 <Cale> Yeah
13:58:23 <Cale> (The idea of concepts was stolen from Haskell's typeclasses)
13:58:24 <mdgeorge> but concepts can contain types, whereas typeclasses can't really
13:58:34 <Cale> We can have associated types too :)
13:58:40 <Cale> (but that's an extension)
13:58:44 <mdgeorge> how?
13:58:56 <Cale> class Foo a where
13:59:04 <Cale>   type Bar a
13:59:12 <Cale> instance Foo MyType where
13:59:16 <mdgeorge> I tried that and ghc complained.
13:59:21 <Cale>   type Bar MyType = Double
13:59:41 <mdgeorge> oh wait.
13:59:43 <mdgeorge> hm.
14:00:01 <esteth> Is there a reason that haskell would be treating a let clause in the middle of a do block as the end of that do block? I'm getting "The last statement in a 'do' construct must be an expression" on the line before my first let clause
14:00:05 <mdgeorge> oh I see.  I was trying to just do "type Bar"
14:00:31 <Jafet> {-# LANGUAGE TypeFamilies #-}
14:00:34 <Cale> mdgeorge: Basically, this gives you arbitrary functions on types
14:00:37 <mauke> esteth: you probably did it wrong
14:00:46 <Cale> yeah, and you'll need to stick that LANGUAGE pragma at the top of your file
14:00:48 <Jafet> esteth: perhaps it really is
14:00:58 <mdgeorge> I see.  good, I had basically the right idea then
14:01:10 <mdgeorge> thanks for helping me clear that up
14:01:11 <Jafet> esteth: my crystal ball suggests that your indentation is wrong
14:01:16 <esteth> http://hpaste.org/47232/do_let_problem is what I have
14:01:26 <esteth> oh
14:01:28 <mauke> ...
14:01:29 <mdgeorge> esteth: my ball was too :)
14:01:30 <esteth> that looks wrong in hpaste
14:01:43 <Cale> TABS!!!!11
14:01:43 <esteth> tabs vs spaces in my editor, I bet
14:01:59 <Cale> Always configure your editor to convert tabs to spaces automatically
14:02:01 <mauke> esteth: you mixed spaces and tabs. the penalty is: blackholing
14:02:09 <mdgeorge> sounds painful
14:02:13 <esteth> haha
14:02:14 <mdgeorge> I hope I never get blackholed
14:02:21 <mdgeorge> or backhoed
14:02:26 <esteth> *checks how to tell vim never ever to use tabs*
14:02:30 <mdgeorge> et
14:02:33 <mdgeorge> smarttab
14:02:35 <mdgeorge> ai
14:02:52 <mauke> esteth: :set et
14:03:11 <mauke> esteth: you probably want something like :set et sw=4 sts=4
14:03:20 <mdgeorge> what is sts?
14:03:30 <mauke> mdgeorge: :h 'sts
14:03:34 <esteth> thanks :)
14:03:36 <Zao> softer ts?
14:03:46 <esteth> never again shall I be blackholed for mixing tabs and spaces
14:04:09 <MHD0> joe6: Sorry, was afk a bit
14:04:12 <Cale> Blackholing is excruciating and it takes *forever* (from our perspective at least, for you it'll be quite fast)
14:04:34 <MHD0> joe6: I'm making a programming language
14:04:51 <mdgeorge> depends how big the black hole is
14:06:38 <rtharper> dcoutts: ping?
14:06:40 <Cale> You can put  set expandtab  in your .vimrc to make it permanent
14:07:29 <mdgeorge> I prefer to put it in the files themselves, because different languages have different conventions
14:07:48 <c_wraith> can't you set it so that it only applies to .hs files?
14:07:49 <mauke> I use ftplugins
14:07:53 <mdgeorge> and different projects
14:08:16 <mauke> c_wraith: yes, with ftplugins or just autocommands/wildcards in your .vimrc
14:08:18 <mdgeorge> c_wraith: prolly, but I'm too lazy to figure out how :)
14:08:45 <Cale> autocmd ColorScheme * highlight TrailingWhitespace ctermbg=darkgreen guibg=darkgreen
14:08:45 <Cale> autocmd ColorScheme * highlight UnwantedWhitespace ctermbg=red       guibg=red
14:08:45 <Cale> autocmd Syntax * syntax match UnwantedWhitespace /\t/ containedin=ALL
14:08:45 <Cale> autocmd Syntax * syntax match TrailingWhitespace /\s\+$/ containedin=ALL
14:09:03 <Cale> ^^ I also have those lines for alerting me to the presence of tabs and trailing whitespace.
14:09:40 <mdgeorge> hey guys thanks for your help.  I'm sure I'll be back
14:09:45 <mauke> mdgeorge: I'm too lazy to set the same 15 or so settings each time
14:46:12 <sshc> Does fclabels support GADTs?
14:57:51 <RedMercury> does anyone know if GHC contains any GPL software?  if i were to write a commercial app in haskell, would i have to open source it?
14:58:04 <parcs> how does one bind an implicit parameter?
14:59:54 <parcs> nevermind :)
14:59:58 <luite> RedMercury: there's the LGPL GMP library, bot nothing that's "just" GPL that will end up in your programs
15:01:05 <c_wraith> you can also avoid GMP with newer versions of GHC
15:01:26 <c_wraith> though performance with Integer math suffers
15:04:43 <RedMercury> ok, thank you for the info
15:06:44 <RedMercury> i'm attracted to learning haskell because it looks like engineering productivity is high - but i wonder what is the state of gui programming in haskell?
15:07:02 <RedMercury> i saw the gui list on the haskell site, and it seemed like the "correct" way was in flux somewhat
15:07:21 * hackagebot triangulation 0.1 - triangulation of polygons  http://hackage.haskell.org/package/triangulation-0.1 (TillmannVogt)
15:07:50 <dolio> I think people mainly program in fairly imperative ways for guis, for the most part.
15:08:36 <dolio> People often get excited about what is called "functional reactive programming" for guis, but I'm not sure there's ever been a prime time framework for that.
15:09:07 <sshc> Are there any libraries that can dynamically interpret / parse Haskell code at run-time, perhaps resulting in some abstract syntax tree or some handleable / runnable monad?
15:09:08 <Jafet> But it's functional and it's reactive, it must be good
15:09:13 <jrick> hm, turns out monads aren't magical after all
15:09:18 * jrick becomes bored with haskell
15:09:19 <jrick> :)
15:09:21 <Jafet> sshc: haskell-src-exts/hint
15:09:31 <Jafet> s/-exts//
15:09:31 <sshc> Jafet: Thanks
15:09:57 * osfameron writes a limited destructuring bind (for binary trees only) in Perl
15:10:21 <osfameron> (basically to help me write a RedBlack tree algorithm... all the good ones, for Haskell or Racket, use loads of deep pattern matching ;-)
15:11:44 <Jafet> @google cpan red-black tree
15:11:46 <lambdabot> http://search.cpan.org/~bholzman/Tree-RedBlack-0.5/RedBlack.pm
15:11:46 <lambdabot> Title: Tree::RedBlack - search.cpan.org
15:12:43 <osfameron> Jafet: yeah.  it's destructive, and documents that the deletion method is buggy ;-)
15:12:56 <osfameron> (which figures... as deletion in red-black is a massive PITA ;-)
15:13:17 <Jafet> Why, even Okasaki couldn't do it!
15:13:29 <osfameron> hehe
15:13:56 <osfameron> the best article I've found on it so far is http://matt.might.net/articles/red-black-delete/
15:14:01 <osfameron> which brings in 2 new colours!
15:14:16 <Jafet> Well, they're isomorphic to 2-3-4 trees, or something.
15:14:32 <osfameron> but the pattern matching looked far more intensive than the (special cased) thing I'd kludged, so I ended up having to implement pattern matching
15:15:02 <osfameron> Jafet: oh? I guess that makes sense - as the colours effectively express levels of imbalance
15:15:35 <maxJadi> Hi, There is no memory sharing in haskell; but why the result of forkIO() names "thread" instead of process - like Erlang ? Thanks
15:16:16 <dolio> Why did Erlang name it process?
15:16:22 <Jafet> What's "memory sharing"?
15:16:32 <Ke> they still share virtual memory
15:17:06 <dolio> Actually, there's a good reason for them to be named process in Erlang, probably.
15:18:09 <maxJadi> dolio, I have no idea :( and it is the source of confusing for me
15:19:33 <dolio> maxJadi: In Erlang, you don't know that a 'process' is just a thread running locally and within your memory space.
15:19:50 <dolio> It could, in fact, be an entirely different process on the same machine. Or not on the same machine at all.
15:19:53 <osfameron> can't Erlang processes be running on arbitrary machines too?
15:20:00 <dolio> So they just call them all processes.
15:20:07 <osfameron> ah, sorry, misparsed, yes
15:20:13 <dolio> Haskell threads are more limited than that.
15:20:37 <dolio> Unless, possibly, if you're using one of the bit-rotted distributed computing things.
15:20:43 <osfameron> wasn't there a bridge to allow Haskell programs to run as Erlang processes?
15:20:50 <dolio> Yes.
15:21:00 <osfameron> that sounded like a sweet spot.  Is it used much in practice?
15:21:09 <dolio> No idea.
15:21:46 <sshc> When is "foldl'" better for performance / efficiency than foldr?
15:21:55 <sshc> Since foldr folds from the right, wouldn't the entire list need to be traversed before any evaluation is done?
15:22:08 <Jafet> foldl folds from the right.
15:22:14 <Jafet> (Duh.)
15:22:36 <dolio> sshc: foldl' is generally better when you can't produce incremental output.
15:23:18 <Jafet> > (foldr f z [a,b,c], foldl f z [a,b,c]) :: (Expr, Expr)
15:23:22 <lambdabot>   mueval-core: Time limit exceeded
15:23:52 <Jafet> Not you
15:24:12 <osfameron> ah!  looks like the Haskell/Erlang thing was for Yhc? http://www.haskell.org/haskellwiki/Yhc/Erlang/Proof_of_concept
15:24:21 <dolio> Really? Huh.
15:24:31 <osfameron> at least, that's the best googlehit for it
15:24:32 <maxJadi> Thanks guys :)
15:24:41 <osfameron> I may well be missing a newer reference for ghc
15:25:39 <dolio> osfameron: http://hackage.haskell.org/packages/archive/erlang/0.1/doc/html/Foreign-Erlang.html
15:26:47 <osfameron> dolio: aha.  if it's on hackage it's presumably ghci then?
15:27:13 <dolio> Hackage says it builds on ghc-7, even.
15:27:20 <osfameron> where do you see that?
15:27:31 <dolio> http://hackage.haskell.org/package/erlang
15:27:55 <osfameron> ah cool, I couldn't find a way to navigate to the index page from the one you linked
15:28:05 <osfameron> but that could just be because hackage is swimming in treacle
15:28:23 <dolio> I just searched the big list after seeing that the package was called "erlang".
15:28:46 * osfameron hugs hackage.  Having *all* your packages listed on one page is so CUTE!
15:29:08 <Will|> lol
15:30:56 <osfameron> hmmm. I just discussed the port of (haskell-like) red/black tree algorithms to Perl
15:31:07 <osfameron> and was asked "Why have you got Empty as a separate class?"
15:31:37 <osfameron> OO polymorphism seems to fulfil the same kind of role as haskell pattern matching for those simple cases
15:31:55 <dolio> Did you say: "it's the messy way to implement algebraic datatypes"?
15:32:17 <companion_cube> it's the way it's done in scala,e.g.
15:32:27 <companion_cube> subclasses with pattern matching
15:32:32 <osfameron> I said something like "It's easier to reason about the algorithms I'm trying to port" ;-)
15:32:40 <osfameron> I *could* use a mass of if statements...
15:32:53 <dolio> Ruby figured it out, too.
15:32:56 <osfameron> but OO, if not perfect, is at least a little closer to ADTs than a mess of if statements ;-)
15:33:15 <dolio> You've got a TrueClass and a FalseClass or something, as I recall.
15:33:25 <shapr> PS. Hakyll is really awesome, it's like Pete Gammies PLog, but with extra awesomeness.
15:34:09 <osfameron> ah, based on Jekyll presumably (Ruby) ?
15:34:37 <shapr> Probably.. but in the past hour I have hacked up a new blog/site: http://www.scannedinavian.com/
15:35:08 <osfameron> hurrah
15:35:16 * shapr cheers happily
15:35:31 <shapr> I haven't posted any self-hosted blog entries since 2009 or so :-/
15:35:34 * osfameron keeps on vaguely thinking about porting his blog from wordpress to $something
15:35:50 <shapr> osfameron: I strongly suggest stealing extralogical.net wholesale, as I have done.
15:36:02 <osfameron> I'd looked at Jekyll, but was feeling anti-Ruby prejudice, and was too lazy to rewrite it in Perl ;-)
15:37:48 <dankna> @hoogle (!)
15:37:49 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
15:37:49 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
15:37:49 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
15:37:55 <dankna> @hoogle (!!)
15:37:55 <lambdabot> Prelude (!!) :: [a] -> Int -> a
15:37:56 <lambdabot> Data.List (!!) :: [a] -> Int -> a
15:38:02 * osfameron bookmarks hakyll
15:38:32 <luite> shapr: what are you going to blog about?
15:38:58 <shapr> luite: I'm doing the #projectaweek stuff, according to blackdog's research on dons' insane productivity.
15:39:23 <companion_cube> is sleeping a proper project ?
15:39:40 <shapr> companion_cube: If you're reading and analysing fitbit data with Haskell, then yes.
15:39:45 <luite> shapr: waht is that? trying one new thing per week, and then blogging about it?
15:40:06 <shapr> nah, completing one and documenting one project each week.. lemme find the blog post.
15:40:32 <shapr> luite: http://www.shimweasel.com/2011/05/08/the-stewart-method-how-not-to-suck
15:41:32 <luite> ah
15:41:55 <luite> hmm, I'll never be able to release my project within a week :p
15:42:47 <shapr> luite: The point is to encourage release early and often... just get it out there, cut releases into *much* smaller chunks.
15:43:19 <shapr> So anyway, my project for this week was to create a new blog and document last week's project.
15:43:25 <shapr> I've done the first part.
15:43:43 <luite> I know, it's just not possible for every project
15:44:38 <shapr> luite: I agree, but it's possible for many projects...
15:45:38 <luite> do people here have experience with hetzner.de? where the code.haskell.org server is hosted. good, uptime, customer service? do they respond fast if your server has problems?
15:46:29 <Zao> luite: They're supposedly quite nice if you have a root (proper) server.
15:46:34 <Zao> luite: Their VPSes are abysmal though.
15:46:51 <Zao> Customer service seems to be office hours, weekdays.
15:46:56 <Zao> Helps to speak german, it seems.
15:47:07 <luite> hehe that's no problem
15:47:21 <NemesisD> what would be an idomatic way of combining several a -> Bool functions such that the result is true if the argument returns true for all the functions?
15:47:26 <luite> I was thinking of getting a server for my site there
15:47:29 <Zao> I cancelled my VPS after having an uptime of 1-2 nines, roughly.
15:47:41 <luite> a real one that is
15:47:53 <Zao> NemesisD: Glue all and map together?
15:47:55 <aavogt> @hoogle finalizer
15:47:55 <lambdabot> Foreign.ForeignPtr type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
15:47:55 <lambdabot> Foreign.Marshal.Alloc finalizerFree :: FinalizerPtr a
15:47:55 <lambdabot> Foreign.ForeignPtr type FinalizerPtr a = FunPtr (Ptr a -> IO ())
15:48:02 <Zao> @type all
15:48:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:48:03 <NemesisD> would taking a monad approach be the way to go?
15:48:04 <Zao> Actually, just all :D
15:48:23 <Jafet> @src all
15:48:23 <lambdabot> all p =  and . map p
15:48:35 <Zao> @src repeat
15:48:36 <aavogt> is there a way to get a resource deallocated etc. when something goes out of scope?
15:48:36 <lambdabot> repeat x = xs where xs = x : xs
15:48:50 <ion> @src and
15:48:50 <lambdabot> and   =  foldr (&&) True
15:48:58 <companion_cube> :t and . map
15:48:59 <lambdabot>     Couldn't match expected type `[Bool]'
15:48:59 <lambdabot>            against inferred type `[a] -> [b]'
15:48:59 <lambdabot>     Probable cause: `map' is applied to too few arguments
15:49:01 <Zao> Never mind my ramblings.
15:49:03 <luite> Zao: I'm a bit worried about a server getting problems, you can cancel in a month, but you lose the setup costs
15:49:25 <osfameron> this is rather nice http://www.infoq.com/interviews/Erlang-Haskell-John-Hughes
15:49:26 <ion> :t and .: map
15:49:27 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:49:32 <aavogt> there's this addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO (), I'm not using the FFI
15:50:04 <Jafet> :t bracket
15:50:05 <lambdabot> Not in scope: `bracket'
15:50:11 <Jafet> :t Control.Exception.bracket
15:50:11 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:50:14 <luite> Zao: which provider did you choose instead, for your vps?
15:50:17 <dankna> luite: I'm a linode fan (and user).  I've never actually needed their support, but they appear to be very responsive.
15:50:46 <NemesisD> Zao: i was following you for a bit there :P
15:50:59 <companion_cube> @pl \fs \x -> and $ map fs x
15:50:59 <lambdabot> (line 1, column 5):
15:51:00 <lambdabot> unexpected "\\"
15:51:00 <lambdabot> expecting operator, pattern or "->"
15:51:36 <ion> and .: map
15:51:37 <NemesisD> all (all preds) list_of_stuff
15:52:09 <luite> dankna: yeah but I need to run a virtual machine on the server, which needs a lot of ram, and preferably hardware virtualization. hetzner is 49 euro per month for a core i7 920 server with 8GB RAM, linode $159.95 per month for a VPS with 4GB
15:52:22 <hpc> @pl \fs x -> and $ map fs x
15:52:22 <lambdabot> all
15:52:43 <dankna> luite: ah okay, yes, that's fair
15:52:58 <luite> dankna: don't know if I need that much, but for smaller servers there's still a price difference, although smaller
15:53:52 <luite> dankna: linode is probably much more reliable though
15:54:12 <dankna> luite: yeah.  well, you've looked into it, so I won't further proselytize :)
15:54:59 <luite> I've never used linode myself :)
15:55:56 <NemesisD> seems like i might want something from applicative
15:55:56 <companion_cube> @pl \fs x -> and $ map ($ x) fs
15:55:57 <lambdabot> (and .) . flip (map . flip id)
15:56:01 <companion_cube> ugly.
15:56:29 <companion_cube> :t \fs x -> and $ map ($ x) fs
15:56:30 <lambdabot> forall a. [a -> Bool] -> a -> Bool
15:56:39 <companion_cube> is this what you were looking for, NemesisD ?
16:00:23 <Saizan> ?type \fs x -> all ($x) fs
16:00:23 <lambdabot> forall a. [a -> Bool] -> a -> Bool
16:00:26 * hackagebot stm-io-hooks 0.7.3 - An STM monad with IO hooks  http://hackage.haskell.org/package/stm-io-hooks-0.7.3 (PeterRobinson)
16:00:27 <ion> @djinn [a -> b] -> a -> b
16:00:27 <lambdabot> Error: Undefined type []
16:00:40 <Saizan> so "just all" was right :)
16:02:15 <NemesisD> companion_cube: hmm, its a bit opaque but it does work
16:02:30 <osfameron> (john hughes)++
16:03:36 <Saizan> @karma hughes)
16:03:36 <lambdabot> hughes) has a karma of 1
16:03:58 <osfameron> no parens on ++ ? :-(
16:04:00 <NemesisD> wait is the fs supposed to be the predicates?
16:07:52 <Saizan> yes
16:08:33 <Saizan> a list of them
16:08:41 <aavogt> is it illegal to call ghci from ghci?
16:09:10 <aavogt> http://hpaste.org/47237/calling_ghci_from_ghci
16:09:20 * copumpkin sends the police to aavogt's house for even considering it
16:10:13 <ion> ccc: …
16:11:12 <aavogt> just ignore the user / it's parts
16:11:27 <aavogt> copumpkin: but is it supposed to work?
16:11:43 <amed> u'm back
16:11:47 <amed> i'm back
16:12:30 <amed> hola
16:12:30 * aavogt wasn't intending to call ghci from ghci, but the same issue happens when calling it from a TH splice
16:12:36 <amed> es en espaol esta sala?
16:13:14 <aavogt> amed: supposedly there's a #haskell.es
16:13:34 <copumpkin> amed: you ask that _after_ saying "I'm back" in english?
16:13:35 <amed> aavogt tks
16:14:21 <amed> copumpkin it's a weather effect lol
16:14:45 <aavogt> copumpkin: are you aware of a more direct method to check whether some instances would be unacceptable to ghc?
16:15:18 <copumpkin> aavogt: something in the GHC API, but I'm not sure what
16:15:21 <copumpkin> :P
16:15:33 <cmccann> aavogt, I seem to recall that the GHC API is supposed to only be used once in a process or something fairly limited
16:15:35 <Zao> luite: None. I settled for having my kitchen server and the university boxen.
16:15:49 <aavogt> copumpkin: isn't that going to run into the same issue as I have loading a file?
16:15:52 <Zao> luite: Of course, it helps to have unmetered 100/100 in the apartment.
16:15:57 <luite> hehe
16:16:11 <cmccann> as in I don't think you can have something use hint run two pseudo-GHCi-things at the same time
16:16:12 <amed> i hate xchat
16:16:13 <Zao> luite: The alternative I looked at was linode when trying VPSes, but never bothered to try them.
16:16:16 <NemesisD> bbl
16:16:32 <dankna> aavogt: oh yeah - right - because of the static flags, which are an unsafePerformIO'd global variable, you can only have one top-level instantiation of the GHC API in a process
16:16:50 <aavogt> hint has some exception regarding ghci not being threadsafe or so (running twice)
16:17:23 <cmccann> aavogt, I'm not sure whether that applies to what you're doing though
16:17:26 <dankna> aavogt: I think however that there might be a way to start up another copy of it if you don't mind sharing the static flags
16:18:03 <dankna> aavogt: the last time I looked at starting it up from another program besides ghc itself, I didn't understand about the static/dynamic flag distinction, so I don't really remember.
16:18:06 <aavogt> I'm using runInteractiveCommand, which doesn't start another process?
16:18:08 <dankna> @hackage direct-plugins
16:18:08 <lambdabot> http://hackage.haskell.org/package/direct-plugins
16:18:45 <dankna> http://hackage.haskell.org/packages/archive/direct-plugins/1.1/doc/html/src/System-Plugins.html#unsafeLoad has an example of how to instantiate the GHC API but I don't know how these issues bear on it
16:20:06 <luite> Zao: ah
16:20:13 <ddarius> dolio: That representation of booleans in object-oriented languages goes back to, at least, Smalltalk.
16:20:50 <dolio> Yeah, that isn't surprising.
16:22:49 <dolio> I guess that's probably where Ruby got it, since it borrows a lot of smalltalk.
16:23:02 <__yhvh__> hey, http://dpaste.com/548102/
16:23:45 <dankna> __yhvh__, I'm not sure what version of the Cabal library comes with GHC nowadays, but it looks like that might be an old one
16:24:49 <Cale> You have 1.8.0.2, but you need >= 1.10
16:25:02 <Cale> 8 < 10 here
16:25:41 <parcs> is the RWST monad faster than the corresponding transformer stack?
16:25:58 <c_wraith> yes, since it involves fewer function calls
16:26:09 <ddarius> Incidentally, explicitly representing something like the empty node of a tree is a common pattern in OO, called the Null Object pattern (or at least its similar to that.)
16:26:20 <aavogt> if it wasn't faster, there wouldn't be much point in having RWST
16:26:44 <ddarius> There's not much of a point in having RWST.
16:26:47 <amed> somebody speaks spanish ?
16:26:48 <hpc> aavogt: besides to provide a built-in alias for an otherwise tremendously huge type?
16:26:53 <Cale> but honestly, there's still not much point in RWST
16:27:07 <c_wraith> RWST makes the wrong choices in a lot of cases.
16:27:26 <c_wraith> you rarely ever want the lazy writer, but that's what it gives you
16:27:49 <c_wraith> of course, you rarely want the lazy writer because it's rare to actually be doing something useful with the writer portion
16:28:00 <c_wraith> and lazy writer with () is a space leak.
16:28:24 <hpc> i only used the transformer stack on my first haskell project; every monad i have needed to make since then has been hand-coded
16:29:01 <aavogt> don't you ever write functions that are more conveniently done with some monad transformers?
16:29:03 <ezyang> I suspect RWST can have a pedagogical purpose, but not beyond that.
16:29:04 <Cale> Monad transformers are useful in some cases, but I feel that you should almost never be transforming the IO monad.
16:29:19 <ezyang> Cale: Disagree, see, for example, languages like Orc.
16:29:19 <Cale> StateT over list is awesome
16:29:30 <ben> Not even to wrap some better/pure error handling over the IO monad?
16:29:57 <ezyang> ben: I think the existing exception mechanisms work reasonably well for that sort of thing.
16:29:59 <hpc> aavogt: not often enough to be irritating
16:30:04 <ben> right
16:30:04 <Cale> The extensible exceptions that the IO monad already has are awesome enough
16:31:01 <aavogt> hpc: http://hpaste.org/47239/example_of_monad_transformer rewriting this to avoid monad transformers would be quite annoying I imagine
16:31:02 <Cale> There are exceptions to every rule, but I see a lot of cases where people do ReaderT over IO or StateT over IO and the resulting code is not as nice as it would be written straightforwardly.
16:31:30 <hpc> aavogt: i don't even know what those monads are
16:32:02 <Cale> That's a nondeterminism monad transformer though
16:32:12 <Cale> I'm fine with those.
16:33:00 <aavogt>  LogicT is it's own package, StateT is from mtl, and Q is for generating/looking at haskell code and IO
16:33:12 <hpc> Cale: i think they usually just want a Writer anyway
16:33:46 <hpc> i imagine a lot of that style of code will do not much more than print to stdout
16:33:59 <cmccann> at one point I think I had something involving a ReaderT applied variously to IO, ST, or STM such that I could change between the three while keeping the same environment from the reader
16:34:13 <cmccann> it was kinda kludgy but I don't know how else it would have worked better
16:34:35 <amedxy> do not understand how to refer to the n-th element, I set a result for n = 1 and alsofor others, but as I establish a result for the nth element
16:34:47 <Cale> cmccann: Well, translate the Reader away, and you end up with functions parametrised over the environment.
16:35:14 <amedxy> http://hpaste.org/47238/print_without_n_element
16:35:15 <Cale> amedxy: Could you rephrase your question?
16:36:11 <amedxy> as referring to the last element?
16:37:05 <Cale> amedxy: What are you trying to do?
16:37:18 <rostayob> is there an explanation to GHC huge size (~500MB)? python 2, for example, has a huge library and is roughly 60MB
16:37:21 <Cale> It looks like you're trying to print a specific string...
16:37:23 <amedxy> print a fork with coordinates
16:37:27 <cmccann> Cale, I dunno, at first I did have a bunch of functions taking the environment as a parameter, but passing the extra argument around gets tiresome
16:37:43 <cmccann> and when I start writing significant amounts of code using the Applicative instance for ((->) t) I end up wondering why I'm not just using a ReaderT
16:37:50 <monochrom> rostayob: static linking of haskell libs
16:37:56 <Cale> cmccann: More tiresome than applying liftIO in a whole bunch of places though?
16:37:57 <hpc> rostayob: ghc ships with the source, profiling, static, and dynamic libs
16:38:06 <hpc> and on top of THAT, the binary compile of ghc
16:38:34 <cmccann> Cale, well in this case there was actually very little IO going on
16:38:35 <hpc> *dynamic complilations of all the libraries
16:38:58 <rostayob> oh ok, so with every GHC there's a version of each library compiled for profiling?
16:39:15 <hpc> http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
16:39:26 <amedxy> cale http://hpaste.org/paste/47238/fork#p47240
16:39:41 <rostayob> oh, ok. thanks
16:39:52 <hpc> oh yeah, and ghci version
16:40:52 <Tyr42_> Does an introduction to LINQ for Haskell programmers exist?
16:40:54 <cmccann> Cale, actually it was mostly shoving things in and out of TVars/TChans/etc. with an "atomically" here and there and rarely anything else
16:41:40 <cmccann> Tyr42_, how about this: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/syntax-extns.html#generalised-list-comprehensions
16:41:49 <amedxy> cale and get this http://hpaste.org/paste/47238/fork_for_me#p47241
16:44:23 <Tyr42_> cmccann:  I would like to learn what LINQ is, preferably with references to familiar haskell idea
16:44:32 <Cale> amedxy: So,  forkTop x = ',' : replicate (x-1) '-'; forkBottom = '`' : replicate (x-1) '-'; fork x y = unlines ([forkTop x] ++ replicate (y-2) "|" ++ [forkBottom x])
16:44:53 <cmccann> Tyr42_, yes, that's why I linked that
16:45:04 <Cale> amedxy: and then printFork x y = putStrLn (fork x y)
16:45:05 <cmccann> Tyr42_, it's an extension to list comprehensions that was inspired by LINQ
16:45:10 <Cale> amedxy: Something like that?
16:45:18 <amedxy> cale wait me
16:46:37 <increpare> Anyone recommend any ways of generating C# from haskell?
16:46:54 <amedxy> cale: this is my complete code http://hpaste.org/paste/47238/complete_code#p47242
16:48:20 <parcs> would a RWST () .. be more performant than a WriterT (StateT ..) .. ?
16:48:36 <parcs> it certainly is more convenient to work with
16:50:11 <KirinDave> What the heck is an RWST monad?
16:51:12 <dolio> It's a custom-fused reader-writer-state monad.
16:51:12 <Kaidelong> reader-writer-state
16:51:36 <dolio> To avoid whatever overheads there are for using several transformers.
16:51:57 <blackdog> increpare: i don't think there's any royal road - suppose you'd just have an AST and generate C#
16:52:00 <parcs> i don't really need the reader part as i find implicit params to be way more convenient
16:52:04 <blackdog> increpare: what are you actually trying to do?
16:52:32 <KirinDave> How expensive really are stacked monad transformers
16:53:12 <increpare> blackdog: not trying to do anything in particular - thinking of ways of getting haskell to work doing things in unity (the 3d engine) - someone did a DLL already, but that has downsides that I don't like.
16:53:44 <increpare> (not as a general purpose interface, but possible uses)
16:54:28 <amedxy> cale i want to do with a printFork function but only need print the first line of fork graph
16:54:58 <parcs> KirinDave: there's a blog post someone on the yesod website showing that reducing a stack of 7 ReaderTs to a single ReaderT improved performance significantly
16:55:04 <parcs> i can't seem to find it, though..
16:55:06 <amedxy> cale this is a unique line such i can't print
16:55:28 <Cale> amedxy: Write a function just to construct the string first, then worry about IO after
16:55:50 <Cale> amedxy: Note that the replicate function will construct a list of n copies of a given element
16:55:55 <Cale> > replicate 10 '-'
16:55:56 <lambdabot>   "----------"
16:56:02 <Cale> > ',' : replicate 10 '-'
16:56:03 <lambdabot>   ",----------"
16:56:08 <Cale> > '`' : replicate 10 '-'
16:56:09 <lambdabot>   "`----------"
16:56:20 <blackdog> increpare: the standard way is to use the C api
16:56:23 <parcs> KirinDave: i was wrong on the specifics, but here it is: http://www.yesodweb.com/blog/hamlet%2Dlucius%2Dwidgets
16:56:34 <amedxy> cale mmm ok
16:56:45 <blackdog> so C# talks to C and haskell talks to C and everyone's happy at the lowest common denominator
16:56:48 <increpare> blackdog: by c api you mean ffi stuff, or c code generation stuff?
16:56:57 <blackdog> ffi stuff
16:56:59 <parcs> 230* speed increase!
16:57:58 <increpare> blackdog: everyone's happy at the lowest common denominator on a single platform ;)
16:58:50 <KirinDave> parcs: Yikes
16:58:59 <KirinDave> parcs: That's not a small difference.
16:59:26 <increpare> parcs: gosh!
16:59:33 <blackdog> increpare: so what was the problem with the DLL approach?
17:01:02 <increpare> blackdog: 1: have to do it separately for windows / osx (though a once-off cost ), 2: unity only allows dll linking with the non-free version (which I have)
17:01:29 <increpare> [ as I mentioned, someone's already working on a dll and has something functional ]
17:02:22 <KirinDave> Why would monad transformers actually be so slow?
17:02:30 <KirinDave> Do they like, interfere with common optimization operations?
17:02:59 <KirinDave> Because that's 3 orders of magnitude and some change on the improvements.
17:05:05 <aavogt> @quote known.for
17:05:05 <lambdabot> dcoutts says: monad transformers are not known for their blistering speed
17:05:20 <increpare> hah
17:06:16 <sshc> Does fclabels support GADTs?
17:07:30 <copumpkin> sshc: what does that mean?
17:07:38 <KirinDave> It seems like, given that, that it's pretty important to write your monad in terms of transformers and typeclasses
17:08:43 <KirinDave> So that if someone does need to smoosh your monad into a big combined monad, they have that ability.
17:11:10 <sshc> copumpkin: Does "$mkLabels" work on GADT types?
17:34:37 <Taslem> What values are suppoed to be read by 'read' in the RandomGen typeclass?
17:34:49 <Taslem> Isn't it supopoed to accept any value?
17:37:51 <jeffz> The Show/Read instances of StdGen provide a primitive way to save the state of a random number generator. It is required that read (show g) == g.
17:37:56 <jeffz> http://www.haskell.org/onlinereport/random.html
17:38:51 <Taslem> "It guarantees to succeed on any string. "
17:39:04 <Taslem> Which I've found it hasn't. But I'm not sure it's working correctly.
17:39:12 <monochrom> the exact format is implementation-dependent
17:39:48 <Taslem> I'm using one provided in System.Random, StdGen.
17:41:34 <Taslem> The code:    read "rtewtew" :: StdGen produces a parse error, which appears to originate from the read.
17:42:33 <byorgey> I think I've heard someone run into this before
17:42:49 <byorgey> "It guarantees to succeed on any string" is apparently false.
17:43:03 <byorgey> I don't remember whether it was decided which was wrong: the implementation or the documentation.
17:43:27 <byorgey> but you might try searching through the haskell-cafe archives.
18:13:22 <ivanm> Jafet: I think I worked it out on my own, thanks: just need an ordering on (w,b) values
18:14:33 <ivanm> I'm wanting a monadic version of mapAccumL (as in the mapping function produces a Monadic value); would my best bet be just to use sequence on the result of mapAccumL ?
18:15:27 <shachaf> ivanm: I don't think that's sufficient.
18:15:35 <shachaf> What type you you want for this function?
18:17:31 <ivanm> the mapping function is of type (acc -> b -> (acc,Put)
18:18:10 <ivanm> though I suppose I can first fold over the list and then do mapM_ put ...
18:18:47 <shachaf> Oh, so the accumulator doesn't need to care about the result of a monadic action.
18:20:48 <ivanm> nope
18:21:06 <ivanm> it's just that how I put later values depends on the earlier ones
18:21:57 <shachaf> So, yes, just mapAccum and sequence_ . snd it.
18:25:29 <drdo> (2 ,)
18:25:33 <drdo> Illegal tuple section
18:25:36 <drdo> What does this mean?
18:26:01 <shachaf> You can't section the tuple operator.
18:26:05 <shachaf> Without -XTupleSections, that is.
18:26:38 <drdo> eh, why?
18:27:04 <shachaf> Because it's not really an operator.
18:27:17 <shachaf> It's just defined that way in Haskell 98. Tuples are special syntax.
18:27:22 <shachaf> > (2,) 5
18:27:23 <lambdabot>   Illegal tuple section: use -XTupleSections
18:27:46 <drdo> I also never understood -
18:27:53 <shachaf> With -XTupleSections you can also do things like (2,,3,) 5 8
18:28:05 <drdo> Why isn't (-2) a function?
18:28:15 <drdo> What is - anyway?
18:28:16 <copumpkin> how would you write negative 2?
18:28:42 <aristid> > 0 - 2
18:28:42 <copumpkin> > (-2)
18:28:43 <lambdabot>   -2
18:28:43 <lambdabot>   -2
18:28:51 <shachaf> copumpkin: (–2)?
18:29:17 <copumpkin> I'm asking drdo how he'd disambiguate between 2, negated, and the function that subtracts 2
18:29:30 <shachaf> copumpkin: I was using a fancy Unicode character, not -. :-)
18:29:37 <copumpkin> oh yay
18:29:47 <copumpkin> different characters that look almost identical
18:29:56 <mauke> copumpkin: step 1: introduce negative literals. step 2: rename 'negate' to 'neg'. step 3: make (-) a normal operator
18:30:15 <shachaf> Actually, I think the special case is so ugly that I'm not sure whether unary prefix - is really justified.
18:30:24 <drdo> copumpkin: What is - then?
18:30:28 <shachaf> Silly mathematicians who never needed to write parsers for their notation.
18:30:33 <copumpkin> drdo: the negation symbol? o.O
18:30:37 <mauke> drdo: terrible
18:30:48 <drdo> copumpkin: It obviously means different things depending on context
18:31:02 <drdo> Is it just an ugly hack and that's it?
18:31:04 <shachaf> drdo: Right, it has two mostly-unrelated meanings.
18:31:05 <copumpkin> yeah
18:31:05 <mauke> yes
18:31:07 <shachaf> Pretty much.
18:31:18 <shachaf> We love ugly hacks here in #haskell.
18:31:30 <copumpkin> mmmhm
18:33:31 <drdo> So how does one write the function that subtracts 2? Only possible using lambda?
18:33:42 <mauke> drdo: subtract 2
18:33:47 <bmars> !gods
18:33:51 <mauke> we've thought of everything
18:33:59 <drdo> oh
18:41:23 * ivanm grumbles at trying to understand the minimalistic spec of a binary representation
18:50:09 <ivanm> preflex: seen bcoppens
18:50:10 <preflex>  bcoppens was last seen on #haskell-blah 2 days, 6 hours and 18 minutes ago, saying: mafs: hmmmm bizarre
19:04:51 <ivanm> @hoogle (Monad m) -> Int -> m a -> [m a]
19:04:52 <lambdabot> Warning: Unknown type Monad
19:04:52 <lambdabot> Data.Sequence update :: Int -> a -> Seq a -> Seq a
19:04:52 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
19:04:57 <ivanm> @hoogle (Monad m) => Int -> m a -> [m a]
19:04:58 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
19:04:58 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
19:04:58 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
19:05:19 <bmars> @hoogle readdocument
19:05:19 <lambdabot> No results found
19:08:25 <ivanm> @hoogle (Monad m) => (a -> Bool) -> m a -> m [a]
19:08:25 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
19:08:26 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
19:08:26 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
19:08:52 <shachaf> What are you looking for?
19:09:11 <ivanm> well, replicateM suites my fiirst need
19:09:35 <ivanm> now a way to keep using get until 0 is reached
19:10:06 <shachaf> And keep a list of all the values?
19:10:46 <ivanm> yeah
19:11:20 <ivanm> I can do it manually, just wondering if there's a function to do it for me
19:12:07 <shachaf> Not that I know of.
19:20:54 <ivanm> preflex: seen copumpkin
19:20:55 <preflex>  copumpkin was last seen on #haskell 49 minutes and 25 seconds ago, saying: mmmhm
19:22:21 <copumpkin> yo
19:22:43 <brweber2> copumpkin: yao
19:22:54 <ivanm> your suggestion about having a way of only returning non-inverse edges? won't work for when you read in a serialised graph from a format that doesn't differentiate between them
19:23:22 <copumpkin> hm?
19:23:30 <ivanm> for my planar graph library
19:24:06 <copumpkin> my point was that the fact that undirected graphs were represented with two directed edges in opposite directions was an implementation detail (or so it seemed) and that it should not appear in the API
19:24:25 <ivanm> yeah, but it's a _useful_ implementation detail
19:24:35 <ivanm> since you often need ingoing edges, etc.
19:24:35 <copumpkin> then provide another layer that lets people get at it if they care
19:24:53 <copumpkin> isn't ingoing edges just "edges" since conceptually you don't have direction?
19:25:04 <copumpkin> and for every ingoing edge you have an outgoing one anyway?
19:25:21 <ivanm> copumpkin: no, even when dealing with directed edges I still use the inverse edges
19:25:58 <copumpkin> I guess what I'm getting at is whether this can be segmented more to provide better separation of concerns
19:26:38 <copumpkin> it may take more work on your part to hide the underlying directed representation in the API and still maintain the same underlying algorithms, but it might simplify the API a bit
19:26:53 <copumpkin> but if you don't think so, then it looked good anyway :)
19:27:21 <ivanm> copumpkin: no, I think you misunderstand: in my code that _uses_ that library, I often deal with the inverses
19:27:46 <ivanm> e.g. tracing a face: you need to keep getting the inverse edge and following it
19:28:05 <copumpkin> I'm wonder if that's typical or not, and whether you're using the inverses because of inherent need of "inverseness" or whether you're doing some operation that could be described on undirected graphs without needing to know about inverses
19:28:40 <copumpkin> basically, whether there's a higher-level operation you can provide
19:28:44 <copumpkin> that would save people having to be aware of this
19:29:02 <ivanm> I've talked with bcoppens about this, and he says that dealing with planar graphs is often messy
19:29:16 <copumpkin> ivanm: yeah, but we're haskell. we don't settle for "often messy"
19:29:18 <copumpkin> :P
19:29:20 <ivanm> heh
19:29:25 <copumpkin> we find better ways and abstractions that work nicely :)
19:29:35 <KirinDave> Oh. Snap uses Text, doesn't it?
19:29:38 <KirinDave> I shoulda known.
19:29:40 <ivanm> maybe once I've dealt with them more often I'll get an idea of what kind of abstractions would be necessary
19:29:41 <copumpkin> but if you've already tried to find something nicer and weren't able to
19:29:43 <ivanm> KirinDave: why?
19:29:48 <copumpkin> ivanm: sounds good
19:30:08 <KirinDave> ivanm: Some kid from #node.js was making fun of snap's benchmarks becuase they claimed that node was doing unicode<->network byte conversion and Snap wasn't
19:30:33 <ivanm> KirinDave: wtf is a "network byte conversion" ?
19:30:47 <webop21> excuse me, is the `on` fuction still in Data.List?  I've been following a tutorial but one of the examples doesn't work and it says that `on` is not in scope, but i have already imported it's module.
19:30:54 <copumpkin> webop21: Data.Function
19:30:56 <ivanm> webop21: never was
19:31:03 <KirinDave> ivanm: Evidently node unpacks utf-8 to 16
19:31:06 <ivanm> as copumpkin says, it's in Data.Function
19:31:29 <luite> as ivanm and copumpkin said, it's in Data.Function
19:31:32 <copumpkin> KirinDave: I'd say the internal representation is irrelevant, as long as the framework isn't losing unicode information in the process
19:31:43 <copumpkin> as luite, ivanm, and copumpkin have said, it's in Data.Function
19:31:46 <KirinDave> copumpkin: Well I agree, etc. It's just that Snap uses Text
19:31:51 <webop21> copumpkin: really? the tutorial must be worng then
19:31:52 <ivanm> KirinDave: ahhh... so is he claiming that node  _does_ do that, or that it doesn't and the benchmark claims wrongly?
19:31:58 <webop21> thank you all
19:31:59 <shachaf> As copumpkin, luite, ivanm, and copumpkin have said, it's in Data.Function.
19:32:00 <copumpkin> webop21: where is it?
19:32:08 * shachaf was about to say it but then decided not to.
19:32:25 <webop21> copumpkin: it's the learn you a haskell for good
19:32:33 <KirinDave> ivanm: That node DOES it and snap was not
19:32:33 <copumpkin> webop21: I doubt it's wrong
19:32:43 <ivanm> map (reference `on` explain) [ (p1,p2) | p1 <- #haskell, p2 <- #haskell, p1 /= p2 ]
19:32:44 <copumpkin> webop21: can you give me a link to the page that says it's in Data.List?
19:33:03 <ivanm> KirinDave: ahhh, yeah, snap doesn't because atm Text uses UTF-16
19:33:09 <webop21> copumpkin: my mistake, tired eyes and fast reading - sorry to have bothered
19:33:16 <copumpkin> webop21: no problem :)
19:33:26 <copumpkin> webop21: the author hangs out in here so if you do find errors it's good to let him know!
19:33:35 <ivanm> preflex: seen BONUS
19:33:36 <preflex>  BONUS was last seen on #haskell 29 days, 7 hours, 22 minutes and 26 seconds ago, saying: yeah i think that's better as well
19:33:41 <KirinDave> ivanm: But doesn't it get the bytes at utf-8?
19:33:41 <ivanm> copumpkin: O RLY?
19:33:47 <copumpkin> :P
19:33:53 <ivanm> doesn't look like he hangs out here much anymore :p
19:34:06 <copumpkin> he's too good for us now that he's an internationally published author
19:34:06 <ivanm> KirinDave: *shrug* no idea about snap's internals
19:34:10 <ivanm> copumpkin: heh
19:34:20 <ivanm> wait, but dons, bos and CosmicRay still hang out here...
19:34:32 <ivanm> copumpkin: must be internationally published author _and cartoonist_ !
19:34:37 <copumpkin> oh!
19:36:16 <shachaf> ivanm: Is there a better way to take the Cartesian product without the diagonal?
19:36:26 <KirinDave> ivanm: If Snap is properly handling encoding, the argument is ridiculous.
19:36:27 <shachaf> Or just to take half of it?
19:36:36 <ivanm> copumpkin: going back a bit: unless you can work out some way of designating "this means it's the _real_ edge", as soon as you do any kind of re-numbering of IDs (compactness, etc.) then you can't tell which is which
19:36:40 * shachaf is sure this has been brought up before, but can't remember a conclusion.
19:36:48 <KirinDave> Which is not to say it wasn't ridiculous before.
19:36:54 <ivanm> shachaf: yeah, I think you can use zip`ap`tails somehow
19:37:03 <ivanm> @type zip`ap`tails
19:37:04 <lambdabot> forall a. [a] -> [(a, [a])]
19:37:25 <ivanm> @type concatMap (\(a,as) -> map ((,) a) as) . zip`ap`tails
19:37:26 <lambdabot>     Precedence parsing error
19:37:27 <lambdabot>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
19:37:35 <ivanm> @type concatMap (\(a,as) -> map ((,) a) as) . (zip`ap`tails)
19:37:36 <lambdabot> forall a. [a] -> [(a, a)]
19:37:43 <ivanm> shachaf: ^^ something like that
19:37:55 <ivanm> @pl \(a,as) -> map ((,) a) as
19:37:55 <lambdabot> uncurry (map . (,))
19:38:19 <ivanm> @type concatMap (uncurry (map . (,)) . (zip`ap`tails)
19:38:20 <lambdabot> parse error (possibly incorrect indentation)
19:38:25 <ivanm> @type concatMap (uncurry (map . (,))) . (zip`ap`tails)
19:38:26 <lambdabot> forall a. [a] -> [(a, a)]
19:38:56 <ivanm> > concatMap (uncurry (map . (,))) . (zip`ap`tails) $ [1..5]
19:38:58 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4...
19:39:04 <ivanm> oh, that has the diagonal...
19:39:10 <ivanm> > concatMap (uncurry (map . (,))) . (zip`ap`(tail.tails)) $ [1..5]
19:39:11 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
19:39:17 <ivanm> that's better
19:40:23 <copumpkin> hmm
19:40:47 <copumpkin> > liftA2 (=<<) zip (tail . tails) [1..5]
19:40:48 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(1,3),(2,4),(3,5),(1,4),(2,5),(1,5)]
19:41:15 <ivanm> oooohhhhh.....
19:41:29 <ivanm> @type liftA2
19:41:30 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
19:41:34 * shachaf should've mentioned that clarity is part of "better".
19:41:38 <ivanm> OK, where does the (,) come from?
19:41:45 <copumpkin> ivanm: zip!
19:41:45 <shachaf> zip
19:41:49 <ivanm> oh, right
19:41:50 <ivanm> duh
19:41:51 <shachaf> pkzip.exe
19:41:59 <ivanm> @slap schroedinbug
19:41:59 * lambdabot pokes schroedinbug in the eye
19:42:00 <ivanm> gah
19:42:00 <shachaf> (Or is it .com?)
19:42:04 <ivanm> @slap shachaf
19:42:04 * lambdabot pushes shachaf from his chair
19:42:12 <ivanm> sorry schroedinbug
19:42:16 <copumpkin> ivanm: you're zipping, then uncurrying (,) back into it
19:42:22 <shachaf> @slap schroedinbug
19:42:22 * lambdabot decomposes schroedinbug into several parts using the Banach-Tarski theorem and reassembles them to get two copies of schroedinbug!
19:42:42 <ivanm> copumpkin: right; I take it the (=<<) only applies to the second list?
19:42:45 <ivanm> @src liftA2
19:42:45 <lambdabot> liftA2 f a b = f <$> a <*> b
19:42:48 <shachaf> ivanm: You couldn't even have typed *two characters* before pressing tab?
19:43:03 <ivanm> shachaf: I did; I accidentally typed "sch<tab>" ;s
19:43:04 <ivanm> * :s
19:43:08 <shachaf> Hmm.
19:43:24 <shachaf> People keep thinking there's a "sch" in there for some reason.
19:43:35 <djahandarie> djahanchaf?
19:43:35 <ivanm> shachaf: the later ch confuses us!
19:45:05 <copumpkin> djahanchafemdienst
19:45:22 <shachaf> copumpkin: Hey, don't bring me into it!
19:45:28 <ivanm> @pl \ a -> map ((,) (f a)) (g a)
19:45:29 <lambdabot> ap (map . (,) . f) g
19:45:32 <ivanm> heh
19:45:41 * shachaf doesn't want copumpkin to find out that he's secretly the same person as djahandarie/geheimdienst.
19:45:48 <copumpkin> omg
19:45:50 <copumpkin> you failed!
19:45:50 <ivanm> shachaf: a bit late now...
19:45:51 <copumpkin> now I know!
19:46:03 * copumpkin considers going to find something evil to eat at the grocery store
19:46:07 <ivanm> damn cloners...
19:46:13 <shachaf> copumpkin: Speaking of which, we never reverse-engineered those functions, and they got undefined.
19:46:21 <ivanm> copumpkin: wait, food has a conscience now? :o
19:46:46 <copumpkin> > numberwang [1,2,12,2,2,52,6]
19:46:47 <lambdabot>   Not in scope: `numberwang'
19:46:51 <copumpkin> > numberwang [1,2,12,2,2,52,6]
19:46:53 <lambdabot>   False
19:47:01 <copumpkin> ivanm: yeah
19:47:02 <shachaf> @google do babies have a conscience
19:47:03 <lambdabot> http://answers.yahoo.com/question/index?qid=20090218181021AANp0lq
19:47:03 <lambdabot> Title: Do babies have a conscience before they can talk? - Yahoo! Answers
19:47:14 <ivanm> @type numberwang
19:47:15 <lambdabot> forall a. (Integral a) => [a] -> Bool
19:47:20 <shachaf> Oh, Yahoo! Answers. That sounds reliable.
19:47:25 <shachaf> Apparentlky they do.
19:47:27 <ivanm> shachaf: sure does!
19:47:31 <copumpkin> how do babby conscient
19:47:33 <copumpkin> how do babby conscient
19:47:37 <ivanm> wait, babies == food now? :o
19:47:48 <copumpkin> how babby fel guilt
19:49:53 <shachaf> copumpkin: Did you just @undefine it?
19:50:00 <copumpkin> nope
19:50:04 <shachaf> > numberwang []
19:50:05 <copumpkin> did someone kill it again?
19:50:05 <lambdabot>   Not in scope: `numberwang'
19:50:08 <shachaf> Useless.
19:50:08 <copumpkin> wtf
19:50:17 <copumpkin> > numberwang [1,2,12,2,2,52,6]
19:50:18 <lambdabot>   False
19:50:26 <shachaf> > isItNumberwang []
19:50:27 <lambdabot>   Not in scope: `isItNumberwang'
19:50:28 <ivanm> > numberwang []
19:50:30 <lambdabot>   False
19:50:42 <ivanm> numberwang = const False !
19:51:07 <shachaf> @ivanmsnack
19:51:08 <lambdabot> Unknown command, try @list
19:51:27 <ivanm> @botsnack
19:51:27 <lambdabot> :)
19:54:10 <Axman6> > filter numberwang (replicateM 3 [1,2,3])
19:54:12 <lambdabot>   [[1,1,2],[1,2,1],[1,2,3],[1,3,2],[3,1,2],[3,2,1],[3,2,3],[3,3,2]]
19:54:14 <dylukes> Hurray~
19:54:16 <dylukes> $300 get.
19:54:18 <adorablepuppy> Got on here to ask a question, turns out I fixed my own problem.
19:54:25 <dylukes> I got $300 for 3000 lines of C++.
19:54:28 <shachaf> adorablepuppy++
19:54:32 <dylukes> Which would normally be a bit too little but...
19:54:37 <shachaf> If only all users were like you.
19:54:41 <dylukes> I wrote 200 lines of python to generate more then 2000 lines of the C++
19:54:43 <dylukes> ^^
19:54:47 <Axman6> ha
19:54:50 <dylukes> hurray for metaprogramming/code generation
19:55:10 <Axman6> i was going to ask if you got pain and suffering money too, but if it was generated, shouldn't be needed
19:55:22 <ivanm> Axman6: until he needs to fix a bug in it!
19:55:29 <monochrom> write 20 lines of haskell to generate 200 lines of python to generate 2000 lines of c++
19:55:47 <Axman6> to compile haskell!
19:55:50 <ivanm> monochrom: sure; are there any limits on line length? :p
19:55:53 <ivanm> Axman6: lol
19:56:18 <ivanm> who had that program that multi-language quine?
19:56:51 <monochrom> some c programs want each line to be at most 254 bytes
19:56:55 <dylukes> monochrom: I feel like there's a Lukes's Law in there somehow.
19:57:04 <dylukes> Or some law I can name after myself.
19:57:44 <dylukes> About language quality relating to codeine rate.
19:57:46 <dylukes> codegen*
19:57:55 <dylukes> ivanm: Oh, where was it...
19:58:12 <dylukes> I think it ws byorgey
19:58:13 <dylukes> Was it?
19:58:37 <dylukes> @quote Quine
19:58:38 <lambdabot> Baughn says: There's also the language, Quine, whose interpreter is implemented as a symlink to /bin/cat
19:58:38 <ivanm> no... apfelmus?
19:58:40 <dylukes> ^^
19:58:57 <shachaf> dylukes: Why symlink?
19:59:00 <shachaf> #!/bin/cat
19:59:17 <shachaf> Or maybe #!/home/shachaf/cat
19:59:17 <dylukes> dunno, I didn't say it.
19:59:28 <shachaf> As everyone knows, $HOME is where your `cat` is.
20:00:26 <dylukes> chmod -R u+x death_row/
20:00:33 <dylukes> Now they can be executed...
20:00:41 <shachaf> Enough -blah.
20:01:24 <parcs> it was sigfpe
20:01:32 <ivanm> parcs: oh, that's right
20:01:57 <dylukes> Ah thats the one
20:02:12 <Eduard_Munteanu> He came in here?
20:02:19 <ivanm> Eduard_Munteanu: a blog post
20:02:25 <Eduard_Munteanu> Ah.
20:02:30 <ivanm> @google sigfpe quine ruby haskell
20:02:32 <lambdabot> http://blog.sigfpe.com/2011/01/quine-central.html
20:02:32 <lambdabot> Title: A Neighborhood of Infinity: Quine Central
20:04:53 <dylukes> how the hell...
20:04:57 <dylukes> there must be some trick to it...
20:04:58 <dylukes> .__.
20:34:08 <hellertime> Anyone around to help me resolve a typechecking error? http://hpaste.org/47246/typecheck_error
20:46:44 <isomorphic> hellertime: I'm not particularly great at haskell - what's the intended concrete type of daily?
20:47:29 <hellertime> It is supposed to be whatever type 'a' is
20:47:55 <isomorphic> Frequency?
20:48:16 <isomorphic> Yes- I mean on line 335 according to ghc
20:48:34 <isomorphic> I'm guessing that is now line 339 or so?
20:49:16 <Eduard_Munteanu> hellertime: you should probably use asTypeOf then
20:49:21 <Eduard_Munteanu> :t asTypeOf
20:49:22 <lambdabot> forall a. a -> a -> a
20:49:47 <hellertime> hmm. shouldn't just providing type signatures on all my functions set things straight?
20:50:13 <hellertime> this is the monomorphism restriction at work is it not?
20:50:26 <hellertime> isomorphic: sorry I'm not sure exactly what you're asking
20:50:31 <Eduard_Munteanu> Mm, no, I don't think so.
20:51:07 <isomorphic> hellertime: i'm trying to figure out what caused the error from ghc - the line numbers in the error aren't accurate on hpaste
20:51:09 <Eduard_Munteanu> Looks like 'daily' is polymorphic and independent of your 'a'.
20:51:22 <Eduard_Munteanu> isomorphic: load that github link
20:52:14 <isomorphic> Eduard_Munteanu: thanks
20:52:18 <hellertime> isomorphic: ah, yes, I added that comment into hpaste which shifted the line numbers
20:52:30 <Eduard_Munteanu> hellertime: try...    enumPeriodFrom (daily{moment = mi} `asTypeOf` m) m (scaleTime m $ (7 - delta') * oneDay)
20:53:41 <Eduard_Munteanu> I don't know if that's what you need though.
20:54:34 <hellertime> Eduard_Munteanu: not quite, the result of 'daily' and 'm' are not the same, (moment daily) and 'm' would be the same
20:55:30 <Eduard_Munteanu> Ah, then   mi `asTypeOf` m
20:55:39 <aavogt> the asTypeOf needs to be applied before you clobber the daily
20:56:15 <aavogt>   (daily `asTypeOf` (undefined :: a -> InitialMoment a) m){ moment = mi }
20:56:44 <hellertime> aavogt: i'll give that a shot
20:57:37 <aavogt> it might be nicer to enable -XScopedTypeVariables, so you can write
20:58:23 <aavogt>   (daily :: InitialMoment a){ moment = mi }
20:58:44 <aavogt> enumWeek :: forall a. ( ... ) => ...
20:59:10 <aavogt> otherwise the 'a' isn't forced to be the same (even if you use the right letter)
20:59:38 <Eduard_Munteanu> Um, what's wrong with daily{ moment = mi `asTypeOf` m } ? If I got that right, the field itself has the same type as 'm', so that should make them unify
21:00:07 <hellertime> aavogt: that worked.
21:00:14 <aavogt> Eduard_Munteanu: the type of  daily  is unspecified
21:00:20 <hellertime> I'll look into ScopedTypeVariables...
21:00:56 <hellertime> aavogt: would you mind explaining a bit what I've stumbled into here?
21:02:13 <Eduard_Munteanu> That thing ends up too polymorphic to say so.
21:02:14 <aavogt>    (daily :: InitialMoment a){ moment = (mi::b) } :: InitialMoment b
21:02:33 <aavogt> the compiler has no way to know what you want a to be
21:03:06 <aavogt> the choice of 'a' can affect the other fields in daily
21:04:10 <hellertime> I see. and using `asTypeOf` gets GHC to identify a == b in this case
21:05:44 <hellertime> is using ScopedTypeVariables in this case the same effect as using `asTypeOf` or are there subtle differences?
21:08:10 <aavogt> in your case I don't see there could be a difference
21:08:52 <aavogt> maybe there would be a difference using -XScopedTypeVariables where you end up specifying a variable that would otherwise get defaulted
21:10:10 <dmwit> Alternately, you could choose a concrete 'a' and write "(daily :: InitialMoment ()) { ... }".
21:10:13 <dmwit> or whatever
21:10:14 <dmwit> instead of ()
21:10:42 <dmwit> That seems a little less annoying to me.
21:11:09 <dmwit> (daily :: InitialMoment UTCTime) { ... } -- for example
21:11:45 <hellertime> dmwit: well the function calling daily in this case is also polymorphic on a ...
21:11:56 <dmwit> Yep.
21:11:58 <dmwit> And it still will be.
21:12:01 <dmwit> Believe it or not.
21:12:06 <hellertime> oh?
21:12:16 <dmwit> In fact, I see you already have dailyUTC which has a more concrete type.
21:12:25 <dmwit> So you could just get away with dailyUTC { moment = ... }.
21:12:26 <dmwit> Try it. =)
21:13:05 <dmwit> It will still be polymorphic because you're overwriting the only polymorphic field with a polymorphic value.
21:13:18 <hellertime> I do, but I intend to also have a dailyLocalTime at some point... if I were to use dailyUTC in the code at that point, and then later called it with 'a' being the concrete type LocalTime wouldn't that fail to typecheck?
21:13:21 <aavogt> hellertime: this is a possible catch http://hpaste.org/47247/scoped_type_variables
21:13:22 <dmwit> Record update need not preserve the types of the fields it updates.
21:13:32 <dmwit> hellertime: No.
21:13:52 <hellertime> dmwit: ah... I didn't know that about record update. makes sense though
21:13:52 <dmwit> Because you're overwriting the UTCTime value with a more polymorphic value.
21:14:25 <aavogt> but if you're aware of the rules for -XScopedTypeVariables, it isn't tricky I think
21:14:26 <dmwit> That fact is, in fact, exactly the source of your problem.
21:14:33 <dmwit> It doesn't know which concrete type it's overwriting.
21:14:39 <dmwit> It shouldn't matter, but it does. =P
21:14:48 <aavogt> add a Num constraint!
21:15:22 <dmwit> In fact, I could arguably say this error is a bug.
21:15:29 <dmwit> I'm sure it's specified in the Report, though.
21:15:31 <aavogt> ie.   daily :: (Num a, Moment a) => InitialMoment a
21:15:35 <dmwit> Anybody want to check? =)
21:15:45 <aavogt> dmwit: it's part of the language
21:16:08 <aavogt> instance Moment Integer
21:16:33 <dmwit> I hope that suggestion is very tongue-in-cheek. =P
21:16:41 <hellertime> aavogt: i don't yet follow how that improves things
21:16:45 <hellertime> :)
21:17:20 <danharaj> I have taken to qualifying all my imports, including Prelude. Do I have OCD :[
21:17:23 <aavogt> hellertime: ambiguous type variables which have Num constraints get turned into Integer
21:17:45 <hellertime> so it seems I can use the asTypeOf function, rely of ScopedTypeVariables, or just use a concrete function in this case, since the concrete type matters not at this point to GHC! oh the options.
21:18:49 <dmwit> danharaj: OCPD seems more appropriate.
21:19:30 <dmwit> If you have to lick your lips three times before you get in the car, that's OCD.
21:19:40 <hellertime> aavogt: and in this case again, it would get turned into Integer, and right back into the concrete type that was expected by the caller, owning to the record update semantics?
21:19:42 <dmwit> If you have to arrange your pencils so that their erasers line up, that's OCPD.
21:19:54 <danharaj> Is that a synonym for "Stop fucking taking all the good function names without making them general enough, Prelude" stress disorder?
21:20:16 <dylukes> dmwit: I do that :D
21:20:30 <dylukes> I tend to just import Prelude hiding the names I need elsewhere,
21:20:34 <dylukes> and then import those ones qualified
21:20:37 <dylukes> >_
21:20:39 <dylukes> >_>*
21:20:48 <dmwit> Do you also put your dollar bills facing the same way and in denomination order.
21:20:57 <dylukes> dmwit: … yep.
21:21:00 <dylukes> >_>
21:21:08 <dmwit> Do you also put your import lists in alphabetical order.
21:21:14 <dylukes> ah, close
21:21:21 <dylukes> alphabetical, then within each module, by length of name.
21:21:36 * dmwit may be borderline OCPD =P
21:21:56 <danharaj> I put mine in "Prelude, then GHC libraries, then Haskell Platform libraries, then Hackage libraries, then project modules" order.
21:22:29 <danharaj> In order of "What are the odds someone is going to have this dependency?"
21:22:53 <Favonia> Well, DSM IV-TR for OCPD: http://www.behavenet.com/capsules/disorders/o-cpd.htm
21:22:57 <Cale> I try to as well.
21:23:17 <Cale> Though often they just end up in the order in which I needed the modules as I wrote the code >__>
21:23:37 <dmwit> Yeah, perhaps claiming I'm borderline OCPD isn't really very nice to the people that really do suffer a serious problem.
21:23:40 <danharaj> I tend to mutilate modules as I am writing them, so having internal modules at the end of the list lets me refactor dependencies easier.
21:23:44 <Cale> (I mean danharaj's order)
21:23:49 <aavogt> @hoogle lift
21:23:49 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
21:23:50 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
21:23:50 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
21:24:25 <Cale> It's sort of the same as the order in which parameters to functions should be given
21:24:28 <Cale> in a funny way
21:24:42 <danharaj> yes I see the analogy.
21:24:46 <dmwit> hm
21:24:57 <nxn> is there any standard operator in haskell that is similar to F#'s pipe op? Instead of doing things like "last . filter pred . takeWhile (<100) $ primes" I'd like "primes |> takeWhile (<100) |> filter...."
21:25:01 <danharaj> Personally I think there should be sugar for swizzling function arguments arbitrarily.
21:25:08 <dmwit> :t (>>>)
21:25:09 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
21:25:21 <dmwit> (...and (->) is a Category)
21:25:42 <danharaj> so the specialized type is (a -> b) -> (b -> c) -> a -> c
21:25:54 <dmwit> danharaj: As ddarius pointed out the other night, lambdas *are* that sugar. =)
21:26:12 <danharaj> I want super sweet sugar
21:26:14 <dmwit> (...and records are the sugar for keyword arguments)
21:26:20 <danharaj> like f_321
21:26:29 <danharaj> f.321?
21:26:33 <danharaj> f.333
21:26:40 <dmwit> yes... apply f to the 32nd argument first, and the 1st argument next
21:26:55 <danharaj> I can only count to 9
21:27:10 <dmwit> More than twice as high as drummers, so that's something.
21:27:37 <danharaj> almost three times as much as a real mathematician
21:28:19 <dmwit> > let swizzle f = \1 2 3 -> f 2 1 3 in swizzle (const . const . show) 1 2 3
21:28:20 <lambdabot>   "2"
21:28:32 <tensorpudding> maybe not a specialist in number theory
21:29:38 <tensorpudding> 333667 is one of my favorite big small primes
21:30:30 <nxn> anyone?
21:30:41 <aavogt> danharaj: write a quasiquoter
21:31:04 <danharaj> aavogt: I'll eventulaly learn TH.
21:31:10 <danharaj> At least that's what I tell myself
21:31:20 <aavogt> nxn: dmwit gave you a suggestion
21:31:41 <nxn> woops, didn't realize that was for me, thank you
21:32:07 <aavogt> > ( (+1) >>> (*2) ) 1
21:32:08 <lambdabot>   4
21:32:25 <danharaj> > 1 >>> (+1) >>> (*2)
21:32:26 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
21:32:26 <lambdabot>    arising from a use of `...
21:32:36 <danharaj> not quite as nice as the F# sugar I guess.
21:32:53 <aavogt> maybe there's a low precedence flip ($) around
21:33:02 <dylukes> So
21:33:08 <dylukes> whats the *best* FRP lib so far?
21:33:14 <dylukes> Or are people still bickering about implementation details?
21:33:16 <aavogt> @hoogle a -> (a -> b) -> b
21:33:16 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
21:33:16 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
21:33:16 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
21:34:00 <danharaj> dylukes: Who knows. I personally don't like the emphasis on continuous time.
21:34:01 <Favonia> @let x |> f = f x
21:34:02 <lambdabot>  Defined.
21:34:11 <dylukes> danharaj: ?
21:34:12 <Favonia> > [1..100] |> length
21:34:14 <lambdabot>   100
21:34:18 <Favonia> :)
21:34:19 <Cale> dylukes: It's not so much bickering about implementation details, but trying to discover what FRP ought to be, and having an answer to that question for which there exists at least one decent implementation.
21:34:21 <dylukes> Favonia: why?
21:34:29 <dylukes> Cale: Hm.
21:34:32 <dylukes> Any thoughts on the matter?
21:34:35 <dylukes> I'm curious about it.
21:35:03 <Favonia> dylukes: oh I thought people are looking for some operators in other languages...
21:36:07 <aavogt> @undefine
21:36:08 <dmwit> dylukes: I've played with conal's push-pull FRP and found it pleasant.
21:36:27 <dylukes> whats it called?
21:36:33 <aavogt> @let infix 1 |>; x |> f = f x
21:36:33 <lambdabot>  Defined.
21:36:40 <dmwit> dylukes: reactive, I think
21:36:45 <dylukes> There are at least 20 packages in the FRP category on hackage
21:36:48 <Cale> Conal's reactive is like what you'd want FRP to be, I think, but the implementation currently suffers from severe issues which make it kinda unusable.
21:36:48 <dylukes> seems to be pretty popular.
21:36:49 <dmwit> ?hackage reactive
21:36:49 <lambdabot> http://hackage.haskell.org/package/reactive
21:36:54 <Cale> and it's not clear how to fix them
21:37:01 <dmwit> Cale: yes
21:37:15 <aavogt> > [1..100] |> length >>> (^2) >>> div 2
21:37:16 <lambdabot>   Precedence parsing error
21:37:16 <lambdabot>      cannot mix `L.|>' [infix 1] and `Control.Cate...
21:37:27 <aavogt> @unlet
21:37:28 <lambdabot>  Defined.
21:37:32 <aavogt> @undefine
21:37:43 <aavogt> @let infixr 1 |>; x |> f = f x
21:37:44 <lambdabot>  Defined.
21:37:46 <aavogt> > [1..100] |> length >>> (^2) >>> div 2
21:37:48 <lambdabot>   0
21:37:59 <dylukes> Cale: Interesting.
21:38:05 <dylukes> I'm still not quite sure what "FRP is supposed to be"
21:38:15 <dylukes> or rather, since thats a hard question,
21:38:20 <dylukes> "what its supposed to accomplish"
21:38:40 <dylukes> Should I read Conal's paper?
21:38:45 <dmwit> minBound and maxBound really ought to be in separate classes.
21:39:06 <dmwit> dylukes: I found it next to impossible to use before I read the paper, and still occasionally quite confusing even after reading it.
21:39:09 <Cale> dylukes: Our in-house FRP system is an arrowish library for incremental computation which works pretty well, but doesn't in and of itself really deal with time per-se.
21:39:11 <dmwit> So yes, I recommend reading the paper.
21:39:20 <dylukes> heh
21:39:25 <dafis> > [1 .. 100] |> length
21:39:26 <lambdabot>   100
21:39:36 <dafis> > [1 .. 100] |> length >>> (^2)
21:39:37 <lambdabot>   10000
21:39:43 <Favonia> aavogt: hmm maybe you want infixl ?
21:39:51 <dafis> > [1 .. 100] |> length >>> (^2) >>> (`div` 2)
21:39:52 <lambdabot>   5000
21:40:01 <Cale> At least at the core level -- we have some extra libraries which add in some explicitly time-oriented features.
21:40:10 <nxn> Data.Sequence already defines |> I think
21:40:10 <dolio> dmwit: No way. Everyone knows that a type is either bounded from both above or below, or not bounded in either direction.
21:40:18 <aavogt> Favonia: infixl won't play nice with >>> I think
21:40:19 <danharaj> Cale: I'm rolling my own FRP library currently too, and I agree with your design decisions. At some point in the past couple of days I threw out any notion of time. FRP to me is just doing computation in steps.
21:40:23 <dolio> Above and below...
21:40:39 <Favonia> > [1..100] |> length |> (*2)
21:40:40 <lambdabot>   200
21:41:43 <Cale> Arrows kinda make me sad too, but I'm learning to live with it.
21:41:51 <tgeeky> defeatist!
21:42:05 <danharaj> What's wrong with arrows?
21:42:09 <dylukes> So, what're arrows?
21:42:11 <danharaj> (What's right with arrows amirite)
21:42:15 <dylukes> I never really got around to understanding them.
21:42:20 <tgeeky> danharaj: left?
21:42:26 <Cale> danharaj: heh
21:42:27 <dmwit> Arrows are just another interface.
21:42:46 <tgeeky> those last 6 responses really compactly describe typical responses
21:42:50 <tgeeky> - 2 jokes
21:42:57 <tgeeky> - 1 boring, just another foobarbaz
21:42:59 <Favonia> aavogt: this is strange...
21:43:07 <tgeeky> - 1 i never learned them
21:43:22 <tgeeky> - 1 comment by a person who can't count
21:44:00 <aavogt> @ty length |> (*2)
21:44:01 <lambdabot> forall a. [a] -> Int
21:44:04 <Cale> The main problem as I see it is that you end up with lots of things which don't break down nicely in a compositional way, because you can't directly make definitions that give (non-local) names to arrowy results. proc syntax sorta helps locally, but that's often not really what you'd like
21:44:14 <aavogt> @ty \n -> length |> n
21:44:15 <lambdabot> forall a t1. (([a] -> Int) -> t1) -> t1
21:44:29 <djahandarie> Arrows have a pretty nasty categorical interpretation
21:45:06 <Favonia> aavogt: I believe you're actually using infixl. I made up a stand-alone .hs file with infixr and it doesn't work
21:45:29 <Favonia> aavogt: maybe the @let stuff in lambdabot is misleading :(
21:45:47 <Favonia> aavogt: I meant maybe it is impossible to specify infixr/infixl
21:46:11 <aavogt> > [1..100] |> (length |> (*2))
21:46:12 <lambdabot>   200
21:46:26 <aavogt> looks infixr here
21:47:02 <Cale> djahandarie: They actually have kind of a nice categorical interpretation... they're monoid objects in a particular category of functors anyway.
21:47:03 <Favonia> hmm
21:47:12 <aavogt> the type of (*2) is interesting
21:47:18 <dylukes> :t (*2)
21:47:19 <lambdabot> forall a. (Num a) => a -> a
21:48:01 <aavogt> @ty (2*) length
21:48:01 <lambdabot> forall a. [a] -> Int
21:48:11 <djahandarie> Cale, AFAIK they are precisely something like a Freyd category. I think it was called an 'indexed Freyd category'
21:48:29 <aavogt> my ghci says (2*) length :: Num ([a] -> Int) => [a] -> Int
21:49:55 <dafis> > 2 undefined
21:49:56 <lambdabot>   2
21:50:19 <Favonia> aavogt: my ghc only accepts infixl
21:50:30 <dafis> > 2 "what?"
21:50:31 <lambdabot>   2
21:50:46 <Favonia> > 2 "I-don't-care!"
21:50:46 <lambdabot>   2
21:50:50 <djahandarie> Cale, ah sorry, it was actually 'enriched Freyd category'.
21:50:53 <aavogt> Favonia: you're missing a Num instance in \bot
21:51:13 <Favonia> ?
21:51:16 <aavogt> @ty (2*) sum (map length)
21:51:17 <lambdabot>     Couldn't match expected type `[a]'
21:51:17 <lambdabot>            against inferred type `[[a1]] -> [Int]'
21:51:17 <lambdabot>     In the second argument of `(2 *)', namely `(map length)'
21:51:18 <djahandarie> Where enriched has a similar meaning to enriched categories, i.e., doing something with the symmetric monoidalness
21:51:22 <djahandarie> I should read this paper
21:51:29 <aavogt> @ty (2*) (sum . map length)
21:51:30 <lambdabot> forall a. [[a]] -> Int
21:51:40 <aavogt> @ty (*) (sum . map length)
21:51:41 <lambdabot> forall a. ([[a]] -> Int) -> [[a]] -> Int
21:51:59 <dafis> Favonia: if you want to use it x |> f |> g |> h, it has to be infixl, if you want to use it with (>>>), it needs to be infixr or have a different precedence
21:52:39 <aavogt> you can't go lower than 1 in precedence which you'd want to play nice with >>>
21:52:53 <dafis> aavogt: there's 0
21:53:15 <djahandarie> Ah, they are also isomorphic to 'Closed Indexed Freyd Categories'.
21:53:48 <danharaj> shouldn't precedences be rational numbers.
21:53:52 <djahandarie> I wonder what a typeclass for just plain indexed Freyd categories would look like, and if it'd be any nicer than the closed version
21:54:10 <aavogt> true, I forgot about that number
21:54:26 <Favonia> dafis: hmm but infixr doesn't make sense to me.
21:55:23 <aavogt> if it's infixr 1, you end up with     x |> (f1 >>> (f2 >>> f3))
21:55:25 <dafis> Favonia: nor to me
21:55:54 <djahandarie> Cale, one paper said Arrows are monoids in the bifunctor category C^op x C -> V where V is symmetric monoidal closed and C is V-enriched.
21:56:13 <Favonia> aavogt: wait, I thought we are looking for consecutive |>'s, not one single |> and then multiple >>>
21:57:17 <djahandarie> So I guess that's where the terminology 'enriched Freyd category' came from, if Arrows are Freyd categories when V = Set
22:00:26 <sshc> zlib's and binary's not using user-handleable types to purely handle errors (like Maybe / Error) is very frusterating
22:01:39 <sshc> Somebody should do something about that!
22:01:47 * sshc sleeps
22:02:14 * dylukes crashes.
22:02:54 <copumpkin> dylukes is clearly not total
22:03:11 <copumpkin> or rather his parents weren't
22:03:39 <Favonia> > 1 2 3 4 5 3 2 3
22:03:40 <lambdabot>   1
22:04:14 <sshc> Favonia: Shush, please; you're wasting valuable screen space when something important is being discussed!
22:04:20 * sshc really sleeps
22:06:30 <Favonia> sshc: Sorry. I just wanted to demonstrate that lambdabot has some weird instances for Num.
22:11:18 <ziman> Favonia, i suppose sshc was joking :)
22:20:09 <tgeeky> anyone know Max Bolingbroke's name on here?
22:32:54 <hellertime> is it possible to partially apply bind and pass it into another function?
22:33:04 <ddarius> Yes.
22:33:10 <ddarius> It's just another function.
22:33:11 <hellertime> Something like:  (\x -> f >>= x) (y >>= z)  being the same as: f >>= y >>= z
22:33:24 <tgeeky> not just possible, it's encouraged
22:33:38 <dmwit> hellertime: Yes, exactly like that.
22:34:11 <hellertime> hmm. GHC seems to simply dislike me then :)
22:34:13 <dmwit> Although (\x -> f >>= x) (y >>= z) is actually the same as f >>= (y >>= z)
22:34:28 <dmwit> Perhaps you'd like to use (>=>) instead.
22:34:42 <ddarius> As long as (f >>=) /= undefined, that always holds.
22:34:42 <ddarius> In general, as long as E /= undefined in \x -> E x (and x is not free in E), you can eta reduce to just E.
22:34:52 <ddarius> Though actually you're beta reducing not eta reducing.
22:35:49 <shachaf> ddarius: That's not eta reduction?
22:36:23 <accel> (Tried hoogle arleady). Is there something of the form [IO a] -> IO a; where each IO a is a an operation taht can either fail or return an "a"; and it just runs it until the first failure?
22:36:41 <accel> i.e. each io operation is either "SUCCESS" or "ERROR failure_msg"
22:36:49 <accel> and I want either a "SUCCESS" or the first "ERROR failure_msg"
22:36:58 <accel> is this basically a "monad plus"?
22:37:05 <djahandarie> accel, long time no see.
22:37:09 <dmwit> :t fmap mconcat . sequence
22:37:10 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f, Monad f) => [f a] -> f a
22:37:16 <hellertime> perhaps I could get a little enlightenment then: http://hpaste.org/47248/passing_bind
22:37:27 <ddarius> msum
22:37:28 <djahandarie> dmwit, not sure if that actually works with 'fail'.
22:37:36 <accel> djahandarie: how was haskell w/o my trolling?
22:37:43 <dmwit> djahandarie: So don't use "fail".
22:37:45 <accel> :t msum
22:37:46 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
22:37:59 <accel> okay; so I understand sequence, concat, and map
22:38:04 <accel> I don't get fmap and mconcat
22:38:20 <dmwit> :t liftM concat . sequence
22:38:21 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
22:38:21 <ddarius> @hoogle [IO a] -> IO a
22:38:22 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
22:38:22 <lambdabot> Network withSocketsDo :: IO a -> IO a
22:38:22 <lambdabot> Control.Exception block :: IO a -> IO a
22:38:28 <shachaf> It does work with fail, doesn't it?
22:38:39 * ddarius henceforth assumes that accel is a liar.
22:38:51 <djahandarie> shachaf, it could. I just have no idea what fail actually does since I never use it.
22:39:10 <shachaf> @src IO fail
22:39:10 <lambdabot> fail s  = failIO s
22:39:15 <shachaf> There you go.
22:39:17 <accel> ddarius: how does msum do what I want?
22:39:30 <shachaf> By using the MonadPlus instance for IO.
22:39:41 <ddarius> accel: Ah, it does the dual of what you want.
22:39:58 <shachaf> Oh, msum isn't what you want?
22:40:04 <ddarius> accel: You just want sequence then.
22:40:05 <shachaf> Hmm.
22:40:10 <accel> okay. I understand the following. IO Monad, State Monad, Maybe Monad. I understand concat, map, sequence. I don't understand more complicated things.
22:40:26 <dmwit> hellertime: The argument to fromSchedule has to be a Schedule.
22:40:33 <dmwit> hellertime: ...which isn't a Monad
22:40:44 <dmwit> hellertime: So what exactly did you think that code was doing?
22:40:46 <shachaf> Oh, right, I misread.
22:41:17 <hellertime> dmwit: yes, but 'repeatSchedule' returns a Schedule (it is simple wrapping up a 'runReader')
22:41:29 <shachaf> accel: Well, sequence does what you want, so there you go.
22:41:37 <dmwit> hellertime: The result of calling (>>=) is always a mote.
22:41:43 <accel> no ... I'm doing a buch of IO ops
22:41:45 <accel> some of them might fail
22:41:47 <dmwit> hellertime: The top-level function in your syntax tree is (>>=).
22:41:52 <shachaf> accel: Right.
22:41:54 * ddarius vomits on the "mote" terminology.
22:41:54 <accel> so I guess it's really an [IO Maybe String]
22:41:55 <dmwit> hellertime: Therefore the argument to fromSchedule is a mote.
22:42:02 <accel> where if it succeeds, it's an Nothing
22:42:02 <dmwit> ...bad news
22:42:06 <accel> and if it fails, it's a Just error_msg
22:42:13 <shachaf> Wait, what?
22:42:13 <accel> I don't see how sequence_ does what I want
22:42:21 <shachaf> Just do that in a separate step, I guess.
22:42:27 <shachaf> Also, no one said sequence_.
22:42:30 <shachaf> (Other than you.)
22:43:12 <dmwit> hellertime: ("mote" just means an expression that has a type whose top-level type constructor happens to also be an instance of Monad)
22:43:24 <accel> :t sequence
22:43:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:43:26 <hellertime> dmwit: thanks. I was just about to show my ignorance here :)
22:43:28 <accel> :t sequence_
22:43:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
22:43:45 <ddarius> hellertime: It's not a common usage.
22:43:53 <accel> sequence won't stop at the first error, will it
22:43:58 * shachaf ahs never heard "mote" before.
22:44:06 <ddarius> accel: Of course it will.  The "error" will throw an exception.
22:44:11 <djahandarie> accel, what is 'error'? fail?
22:44:13 <dmwit> I think it's a nice word to add to our shared vocabulary.
22:44:18 <djahandarie> Because fail in IO seems to just stop everything
22:44:24 <ddarius> dmwit: I think it is dumb.
22:44:26 <hellertime> so then how can I pass that computation in as an argument as I was expecting to do?
22:44:32 <accel> got it
22:44:44 <ddarius> fail simply throws an ioError.
22:44:53 <handonson> what would be the reason  if "cabal install gtkglext" keeps re-installing all libraries it is dependent upon?
22:45:08 <dmwit> ddarius: Yes, you've mentioned that, without saying why.
22:45:11 <djahandarie> accel, I think it'd be nicer to ditch IO and use Maybe if you can.
22:45:15 <accel> in my code, when a system $ fails, it returns a "Just error_msg" of the Maybe Monad. However, I didn't tell any of you that; so you interpreted "fail" to mean the "fail" function in haskell. Sorry for this confusion.
22:45:21 <dmwit> hellertime: You need a more top-er-level runReader, clearly. =)
22:45:31 <hellertime> clearly :)
22:45:31 <shachaf> accel: Maybe what you want is mapM (\x -> fmap Just x `catch` const (return Nothing)) ?
22:45:44 <shachaf> Except that that won't stop at the first error, of course.
22:45:47 <dmwit> :t runReader
22:45:48 <lambdabot> forall r a. Reader r a -> r -> a
22:46:11 <dmwit> fromSchedule $ runReader (one thing >>= other thing) initialValueForReader
22:46:12 <hellertime> it seems to work if I replace 'repeatSchedule' with its body in ghci
22:46:31 <accel> damn it; this is frustrating (for you guys too I bet). I will do this. I will write a bunch ofs tupid code that does what I want, then I will hpaste it, and after wards, you guys can tell me "you should have used these three functions concatenated togehter"
22:46:49 <dmwit> I don't see "repeatSchedule" in your github page.
22:46:53 <Cale> accel: Sorry, what are you trying to do?
22:47:04 <shachaf> accel: You know you're not being very clear about what you want from these three functions, right? :-)
22:47:04 <hellertime> dmwit: err... let me check, perhaps I forgot to push
22:47:20 <accel> Cale , shachaf : yeah, I know it's my fault; which is why I'm writing code to do it the stupid way first :-)
22:47:31 <Cale> accel: [IO (Maybe a)] -> IO (Maybe a)?
22:48:09 <shachaf> Cale: I think accel has a list of IO actions that can fail.
22:48:17 <hellertime> dmwit: yeap. sure would be helpful to have the code available to look at :) its there now.
22:48:24 <shachaf> And he either wants to stop at the first one that fails or replace the failing ones with Nothing, or something else.
22:48:26 <Cale> accel: I think it kinda sounds like you want is sequence in the MaybeT IO monad, from your most recent description
22:48:44 <handonson> what would be the reason, if cabal install something, it keeps re-installing all libraries it is dependent upon?
22:49:08 <dobblego> handonson: they probably install an executable
22:49:12 <accel> http://hpaste.org/47250/accel
22:49:18 <dmwit> hellertime: I bet when you replaced repeatSchedule with its definition, you also removed the (>>=). =)
22:49:40 <handonson> dobblego: but it doesn't
22:49:49 <accel> shachaf , ddarius , Cale , dmwit : is there a cleaner way to do: http://hpaste.org/47250/accel ?
22:49:57 <dmwit> hellertime: If so, then just remove the (>>=) without expanding the repeatSchedule and you'll be in good shape. =)
22:50:12 <Cale> accel: The name of that function and what it does seem to be at odds with one another...
22:50:14 <Cale> oh
22:50:20 <Cale> Just str is the error case?
22:50:23 <shachaf> accel: Wait, you haven't even been talking about IO exceptions the entire time?
22:50:50 <accel> no; I have a bunch of IO a's; which call the system function, which might return an error, which I wrap up in a Maybe
22:50:56 <accel> how should I have asked my question?
22:51:03 <accel> clearly I am using the wrong terminologies
22:51:08 * dmwit didn't think he was talking about IO exceptions
22:51:17 <dmwit> accel: I don't believe any standard function does what you want.
22:51:17 <accel> Cale: yes, Just String = the error case
22:51:21 <shachaf> Oh.
22:51:25 <dmwit> accel: Short-circuiting has to be done by yourself.
22:51:43 <accel> got it; thanks
22:51:56 <Cale> Yeah, that's backwards from most uses of Maybe
22:51:56 <hellertime> dmwit: this is what I was trying: http://hpaste.org/paste/47248/passing_bind_annotation#p47251
22:52:01 <Cale> Nothing is usually the "failure" case.
22:52:12 <accel> Cale: how should I reromulate this?
22:52:15 <Cale> hmm
22:52:17 <KirinDave> I'm trying to solve a thundering horde problem.
22:52:17 <accel> since in the failure case, I want the railure message
22:52:23 <Cale> right.
22:52:26 <KirinDave> I'm not really sure how to do it in STM
22:52:31 <Cale> and you have no result in the success case
22:52:31 <KirinDave> err, w/STM
22:52:37 <accel> yeah; it's just an IO ()
22:52:39 <Cale> So Maybe isn't inappropriate
22:52:45 <accel> okay; so what should I use?
22:52:45 <tommd> What does the syntax in "ghc-pkg list" mean?  iirc, an entry of "(package)" is hidden, but what is "{package}" ?
22:52:55 <KirinDave> Anyone have any advice on how this is done?
22:53:12 <dmwit> hellertime: Oh, you're just missing parentheses around the bind, th... uh
22:53:14 <dmwit> wait
22:53:25 <KirinDave> I'm trying to convert something like https://gist.github.com/3bf296e1ba875b211934 into the appropriate haskell code.
22:53:44 <Cale> accel: One thing you could do is to throw an exception on failure with the error message, and then just catch that.
22:53:53 <Cale> (the IO monad has nice exceptions)
22:55:52 <KirinDave> I was thinking maybe making a STM map and then inserting new stmvars into that map.
22:56:07 <KirinDave> And then I could use the readvar to have all my worker threads block on the result.
22:56:25 <KirinDave> is that unreasonable?
22:56:25 <dmwit> hellertime: Yep, it's the difference between (a >>= b) >>= c and a >>= (b >>= c).
22:56:56 <dmwit> hellertime: Try this:
22:57:20 <dmwit> hellertime: take 15 $ fromSchedule $ repeatSchedule yearlyUTC $ \s -> expand (...) s >>= restrict (...)
22:57:56 <dmwit> hellertime: Or, as I suggested right from the beginning, take 15 $ fromSchedule $ repeatSchedule yearlyUTC $ expand (...) >=> restrict (...)
22:58:01 <dmwit> ;-)
22:58:07 <Cale> KirinDave: I'm not sure that I understand, but a simple MVar containing a Data.Map is often surprisingly efficient.
22:58:09 <hellertime> wow. that was subtle.
22:58:32 * dmwit gloats that he pointed out this subtlty right at the beginning
22:58:34 <c_wraith> KirinDave: the current implementation of STM has to fail before it will block.  and it only fails at commit time.  that leads to *bad* performance if there's a single point all STM transactions touch.
22:58:49 * dmwit then stops gloating when he realizes it still took him a while to figure out that that subtlty was actually the problem =P
22:59:03 <KirinDave> c_wraith: So how does one appropriately solve the thundering horde problem?
22:59:03 <hellertime> dmwit: as you can tell this is my first time slogging through a Monad on my own... :)
22:59:09 <dmwit> subtlty? subtlety?
22:59:26 <dmwit> hellertime: You seem to be doing pretty well for it, I'd say. =)
22:59:39 <Cale> KirinDave: What is the thundering horde problem?
22:59:40 <hellertime> nice catch... the >=> operator is the way to go
22:59:44 <c_wraith> KirinDave: as Cale suggested, just putting an immutable structure in an MVar is actually *quite* fast, even though it doesn't expose any room for a multi-cpu speedup
22:59:55 <KirinDave> c_wraith: But can that actually do what i want to do?
22:59:59 <KirinDave> I need to atomically test-or-set
23:00:00 <Cale> Well, it sometimes does.
23:00:17 <Cale> In fact, it sometimes exposes a lot of room for multi-cpu speedup
23:00:33 <dmwit> For example, with lots of readers. =)
23:00:47 <KirinDave> Cale: It's where multiple threads all ask for a value to be computed of a worker, and sometimes they all ask for the exact same value at once
23:01:04 <hellertime> dmwit: thanks. I'll go with >=>, there is something fitting about using a operator that looks like an arrow in a time library :)
23:01:09 <c_wraith> KirinDave: sure.  have your protocol be "every thread starts by removing the value from the MVar.  When it's done, it puts a value into the MVar"
23:01:09 <KirinDave> Cale: So it makes a lot of sense, if the computation is expensive/effectful, to forgo caching and instead make simultaneous identical requests block on one computation.
23:01:14 <dmwit> hellertime: =)
23:01:28 <dmwit> hellertime: Also, my favorite time joke: "Time flies like an arrow. Fruit flies like a banana."
23:01:34 <Cale> KirinDave: If the computation is effectful, then there's no way to speed it up, because the effects will have to happen n times?
23:01:47 <KirinDave> Cale: Not necessarily?
23:01:52 <hellertime> dmwit: ugh... :)
23:01:52 <Cale> Well, I guess.
23:02:08 <KirinDave> Cale: For example, hitting google apis :)
23:02:18 <ddarius> dmwit: I wasn't aware that that was considered a joke.
23:02:33 <KirinDave> Cale: So in that case, it is a BIG difference.
23:02:37 <Cale> KirinDave: It sounds like what you want is an IVar.
23:02:44 <Cale> But an MVar will do :)
23:03:04 <Cale> Just have it start off empty, and every thread who wants the answer will read from it.
23:03:05 <KirinDave> But can you atomically test-and-set a value in an mvar?
23:03:15 <KirinDave> And if there are several of these in flight at once?
23:03:21 <c_wraith> KirinDave: you take the value out, do whatever you want with it, and then put a new value in.
23:03:31 <KirinDave> I need ?Var Data.Map String ?Var
23:03:54 <c_wraith> that's exactly what we're recommending against
23:04:02 <Cale> An MVar is a box which may be empty or full. Normally taking a full MVar will empty it (getting the value), and taking an empty MVar will block until it fills.
23:04:04 <ozataman> anyone know why Main would output "Main: <<loop>>" instead of running a fairly complex computation?
23:04:11 <KirinDave> c_wraith: I can't get by only an outer mvar.
23:04:11 <Cale> while the situation is reversed on writing
23:04:15 <c_wraith> ozataman: black-hole re-entered
23:04:16 <ddarius> ozataman: Because you have a loop.
23:04:23 <KirinDave> Right
23:04:25 <ddarius> (of a particular form)
23:04:31 <Cale> Writing a full MVar will block until empty and writing an empty MVar will fill it
23:04:45 <KirinDave> Which means the first person in can test-or-set.
23:04:49 <KirinDave> I know read automatically gets and sets.
23:04:54 <KirinDave> err, readMVar
23:04:55 <Cale> But you can also read the current value of an MVar without taking it.
23:05:02 <c_wraith> read is *not* atomic, though
23:05:03 <KirinDave> Right
23:05:07 <KirinDave> Right
23:05:30 <Cale> But it's okay that it's not atomic if you only have one writer
23:05:37 <KirinDave> I will have so many writers. :)
23:05:40 <KirinDave> That's the whole point.
23:05:41 <Cale> Why?
23:05:58 <Cale> You can use one MVar per writer.
23:06:06 <KirinDave> No, they should share mvars.
23:06:12 <Cale> Or per-(result that you want to wait on)
23:06:17 <KirinDave> yeah
23:06:25 <Cale> Don't share the MVars
23:06:26 <KirinDave> So MVar (Map String IVar)
23:06:35 <KirinDave> If I don;t, how have I solved the problem?
23:06:47 <KirinDave> What I want is to atomically create futures in a map
23:06:51 <c_wraith> by changing your problem to an easier one
23:06:58 <KirinDave> c_wraith: I have these semantics I need to support
23:07:03 <Cale> If you don't share the MVars and you only write once then what you have is pretty much exactly an IVar
23:07:19 <KirinDave> I want N writers to result in ONE call to the google API _IF_ they all call for the same value at once
23:07:24 <KirinDave> This is a distinct problem from caching.
23:07:44 <c_wraith> KirinDave: it sounds more like what you have is an implementation you think you have to support, and an unwillingness to explore other implementations with the same semantics
23:07:57 <Cale> KirinDave: What does "at once" mean?
23:07:57 * ddarius says, "Make a concurrent manager process."
23:08:04 <KirinDave> Cale: In the same tie period.
23:08:09 <KirinDave> err, time
23:08:20 <Cale> Measured in seconds?
23:08:29 <KirinDave> let me explain it this way
23:08:34 <KirinDave> Only 1 writer comes in
23:08:35 <Cale> So each value in your cache will have a timer which expires?
23:08:38 <KirinDave> No
23:08:50 <KirinDave> So let's say only one query comes in
23:09:25 * ddarius huggles communicating sequential processes.
23:09:27 <KirinDave> t0, request received, t8 request filled from google maps, t9 result reported
23:09:44 <KirinDave> Now imagine if between t0 and t8, other writers come in asking for the same value from google maps
23:09:56 <Cale> okay
23:09:58 <c_wraith> KirinDave: What you're looking for is "identical calls made before the first one returns don't make extra calls"
23:10:08 <c_wraith> KirinDave: "and instead, just share results"
23:10:19 <c_wraith> KirinDave: *those* are the semantics you're looking for, right?
23:10:20 <KirinDave> c_wraith: Except I don't care about caching
23:10:23 <ddarius> This concurrency/RPC pattern actually has a very specific name.
23:10:28 <KirinDave> And I _very much_ do care about computation sharing.
23:10:29 <ddarius> If I can recall it.
23:10:32 <c_wraith> Notice I didn't say *anything* about caching.
23:10:48 <KirinDave> c_wraith: "same value"
23:10:48 <c_wraith> I said "identical calls made before the first one returns"
23:10:48 <KirinDave> Anyways
23:11:00 <c_wraith> see, *those* are semantics.
23:11:01 <KirinDave> So I don't see how I can get around the idea of a shared ?Var
23:11:25 <dmwit> A simple thread-local Map Query [MVar] in the query-answering thread seems simple enough to me.
23:11:39 <companion_cube> so it's caching the future, not the returned value, in some sense
23:11:43 <dmwit> The list being the mvars of threads waiting for replies to that query.
23:11:48 <KirinDave> companion_cube: Indeed.
23:11:50 <Cale> The obvious implementation of that semantics is by temporarily caching a reference to the location of the result of the computation until the computation is completed, and the result can be read, and then discarded once all the subscribed readers are satisfied.
23:12:01 <KirinDave> Cale: Indeed.
23:12:10 <Cale> Which is a cache
23:12:19 <Cale> Why is that not a good solution to the problem?
23:12:32 <KirinDave> Cale: What if the requests come in before a value can be inserted into the cache?
23:12:33 <c_wraith> dmwit's suggestion is good.  Pay attention to it.
23:12:59 <KirinDave> dmwit: Wouldn't it be just as good to have the threads blocking on an empty ivar?
23:13:10 <dmwit> I know nothing about IVars. Perhaps it would.
23:13:18 <KirinDave> dmwit: Or even a single mvar?
23:13:19 <c_wraith> Eh.  Same as an MVar, in this case
23:13:22 <Cale> KirinDave: You insert MVars into the cache which are empty, and only ever written to once.
23:13:56 <Cale> (or IVars)
23:13:57 <KirinDave> Cale: Yeah, but that's a bit more work than a typical cache. Most of them don't handle this problem.
23:13:58 <dmwit> If you want them all to block on a single mvar, then you have the question of how to communicate that mvar to them. Not a hard thing to do, and more-or-less identical to my suggested solution.
23:14:10 <KirinDave> dmwit: Well if they all go to that single shared map
23:14:16 <tommd> Compiling GTK... compiling GTK for profiling... compiling GTK for a shared library.  I am now on a uniprocessor machine - my other cores died of bordom.
23:14:19 <KirinDave> dmwit: Then the first one to get there and find an empty map makes the mvar.
23:14:26 <KirinDave> dmwit: In https://gist.github.com/3bf296e1ba875b211934 that's how it works.
23:14:29 <dmwit> KirinDave: No. Only the query-answering thread updates the map.
23:14:36 <dmwit> KirinDave: The queriers don't even know it exists.
23:14:42 <dmwit> (That's what thread-local means.)
23:14:57 <KirinDave> dmwit: There are many query-answering threads as well, because there can be many queries going at once
23:15:17 <dmwit> One thread can answer many queries.
23:15:32 <c_wraith> KirinDave: Chan is your friend.
23:15:53 <KirinDave> c_wraith: I don't really get why I wouldn't just forkIO for every distinct google maps query
23:16:00 <dmwit> You would, of course.
23:16:06 <c_wraith> KirinDave: you're thinking *really* low-level.
23:16:13 <c_wraith> KirinDave: think about an API first
23:16:19 <KirinDave> c_wraith: Already got one.
23:16:28 <KirinDave> c_wraith: I'm re-implementing a web service.
23:16:32 <KirinDave> I'm asking how to implement this.
23:17:23 <dmwit> Oh, Chan is neat.
23:17:57 <KirinDave> c_wraith: So how would Chan be involved?
23:20:44 <companion_cube> the google-API-calling thread pushes the answer on the chan; every reader thread reads a value, push it back in the Chan, and looses its reference to the Chan
23:20:46 <Cale> http://hpaste.org/47252/caching
23:20:50 <KirinDave> Ahh
23:20:57 <companion_cube> which is eventually garbage collected
23:21:14 <Cale> ^^ that's what I'd start with
23:21:14 <companion_cube> that's just a proposition, i'm not sure it works
23:21:34 <KirinDave> Cale: Indeed. It's cool that MVars get me so close
23:22:18 <ddarius> 'caching' = future
23:22:37 <Cale> yeah
23:22:38 <KirinDave> Cale: But that's got to have a component that puts the new mvar in a shared place (or a new mvar) in a shared place.
23:22:42 <KirinDave> In this case
23:22:47 <KirinDave> With that specific code you just hpasted
23:22:52 <KirinDave> It'd make sense for many waiters to share one mvar
23:23:03 <KirinDave> Otherwise someone's got to take the initiative to put to many mvars, as I see it
23:24:11 <Cale> The IO action which is the result of caching there can be distributed to many readers that when executed wait for the result to be available.
23:24:29 <KirinDave> Ohhhhh
23:24:32 <KirinDave> That's interesting
23:24:41 <KirinDave> Although that itself would also require a shared point.
23:25:07 <KirinDave> So executing that IO action multiple times would result in only the readmvar part?
23:25:14 <ddarius> What you are doing requires some "centralized" authority.
23:25:15 <Cale> yeah
23:25:22 <Cale> If you do:
23:25:27 <Cale> x <- caching (threadDelay (10^7) >> return "hey")
23:25:30 <Cale> and then run x
23:25:34 <Cale> it's only slow the first time
23:25:40 <Cale> because it needs to wait for the result
23:25:48 <Cale> and thereafter, the result is available to any reader
23:26:26 <KirinDave> Ahh
23:26:32 <KirinDave> The trick is the type signature there, isn't it?
23:26:38 <Cale> yeah, sorta
23:26:38 <KirinDave> IO (IO a)
23:26:58 <ddarius> There is no trick.
23:27:12 <Cale> That's a little clever if you haven't seen something like it before :)
23:28:07 <Cale> So the IO (IO a) action itself just sets up the new thread for computing the result and capturing it, and the IO a it returns is an action for reading the result back once it's available
23:28:16 <KirinDave> So
23:28:41 <KirinDave> MVar (Map String (IO Result))
23:29:08 <Cale> yeah, that might do well, except now we have the problem of how to deal with expiring things
23:29:19 <ddarius> Incidentally, 'caching' is an example where Reppy's "higher order concurrency" would be an improvement.
23:30:01 <Cale> I guess we could use Weak
23:31:26 <KirinDave> Yea I was going to solve that problem in the future. :)
23:31:56 <KirinDave> In Java I'd do it by making a max timeout on every task.
23:32:20 <KirinDave> And removing it from the map at that stage (on the assumption that the upper time bound would be high enough that interested parties in this data would have already timed out)
23:33:56 <ddarius> This is why I like concurrent services.  You can put off making these decisions until later without affecting the interface, and the code is localized.
23:46:39 <koala_man> what's that large database with facts about the world used in machine learning?
23:47:14 <KirinDave> freebase?
23:48:28 <solrize> cyc?
23:48:48 <solrize> http://en.wikipedia.org/wiki/Cyc
23:51:05 <koala_man> KirinDave, solrize: excellent, thanks!
