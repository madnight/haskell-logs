00:00:11 <argiopeweb> After CS222, I honestly didn't cover any FSMs until my Formal Modelling class (400 level SE)
00:00:32 <ian_mi> I think someone interested in CS would be better served by a math degree than a CS degree anyway
00:00:47 <neophyte> argiopeweb, the 200 level CS course you took was mathematical rigorous?
00:00:50 <argiopeweb> ian_mi: Theoretical math, yes.
00:00:56 <neophyte> ours was, except ours was a 300 level.
00:01:05 <NihilistDandy> All the CS majors I know got railroaded into the C/Java track
00:01:21 <neophyte> yeah, i was afraid i wouldn't integrate well since i was pure math major, but im very interested in cs now
00:01:23 <NihilistDandy> Not very good at the old math
00:01:32 <argiopeweb> neophyte: 300 level was obviously more mathematically rigorous, though the 200 level was pretty steeped in set theory.
00:01:37 <pikhq_> ian_mi: Eh, a proper CS degree would really be a math degree focusing on math related to computing.
00:02:00 <ian_mi> pikhq_: yes, many aren't however
00:02:05 <NihilistDandy> neophyte: Where are you going to school?
00:02:07 <pikhq_> True, true.
00:02:22 <liyang> a proper CS degree would have a math level of over 9000.
00:02:30 <pikhq_> Hence why I'm "supplementing" my CS degree with an entire math degree.
00:02:30 <neophyte> argiopeweb, i think your 200 level is equivalent to the 200 level course in discrete mathematics that CS majors have to take, and the 300 level course is the mathematically rigorous version of cs theory here
00:02:57 <argiopeweb> neophyte: Likely, since it was titled "Discrete Mathematics" ;)
00:04:23 <tolkad> I was reading this article: http://en.wikibooks.org/wiki/Haskell/Category_theory
00:04:36 <argiopeweb> If you can get your hands on a good OS course (and you have time for it,) those are always fun as well.  The theory behind operating systems is fun.
00:04:58 <argiopeweb> Wow, I must be getting tired... Fun twice in a paragraph to describe the same concept... Repetition much?
00:05:50 <tolkad> It seems to say that with some categories, you can infer that a particular composition is equivalent to a certain morphism. Is it possible to have categories in which you know that the composition exists, but you don't know which morphism it is?
00:05:59 <neophyte> the compiler course here recommends the theoretical cs course i'm in, what relations would those two courses have? the stuff in grammars?
00:06:09 <neophyte> we covered chomsky's normal form in class
00:06:10 <tolkad> s/infer/deduce/
00:06:15 <neophyte> when we dealt with grammars
00:07:06 <c_wraith> yeah, the links between parsing and automata are probably the reason why a compilers course would recommend the theory course
00:07:12 <argiopeweb> Compiler courses generally take what you know about grammars and then explore ways to lex/parse based on them.
00:07:54 <argiopeweb> So they would tend to recommend something that could give you a good grounding in CFGs so that they don't have to re-explain it all.
00:08:14 <neophyte> okay that makes sense.
00:09:55 <Nereid> tolkad: huh, what do you mean?
00:10:05 <neophyte> unfortunately most CS majors/people in general think the entire field of CS is restricted to just programming (least the ones I came across)
00:10:35 <zomg> Wait, you mean it isn't?!
00:10:38 <argiopeweb> neophyte: Next time you meet one, ask them if they've read Knuth.
00:10:42 <tolkad> Nereid: Like the line under the diagram: http://en.wikibooks.org/wiki/Haskell/Category_theory#Category_laws
00:10:44 <neophyte> Alright.
00:10:52 * hackagebot dia-base 0.1.1 - An EDSL for teaching Haskell with diagrams - data types  http://hackage.haskell.org/package/dia-base-0.1.1 (PeterDivianszky)
00:10:52 <argiopeweb> neophyte: Have you read Knuth?
00:10:56 <tolkad> Nereid: "So which is the morphism f \circ g? The only option is idA"
00:11:05 <Nereid> yes, that's because there's only one morphism from A to A
00:11:07 <neophyte> argiopeweb, no but i've seen the name, what book do you recommend of his
00:11:15 <zomg> I wonder if I could uses that to coerce some CS student to clean the office
00:11:16 <Nereid> tolkad: but in general
00:11:18 <argiopeweb> neophyte: There are only 4. ;)
00:11:22 <zomg> "Yeah you know that CS involves other things than programming too!"
00:11:28 <zomg> "Just read some Knuth"
00:11:42 <neophyte> alright, i'll get my hands on it
00:11:49 <Nereid> tolkad: composition is defined by a bunch of functions hom(B,C) x hom(A,B) -> hom(A,C).
00:11:53 <tolkad> Nereid: But is the information of which morphism is equivalent to which composition part of the category? Or is it ambiguous?
00:11:54 <argiopeweb> The Art of Computer Programming. It's still a work in progress.
00:11:55 <Nereid> that's part of the data of a category
00:12:07 <argiopeweb> Slated to be finished by 2020, as of last estimate.
00:12:43 <argiopeweb> It's a stiff read, but it's everything you'd ever want to know about algorithms, data structures, and pretty much everything CS related.
00:12:45 <Nereid> tolkad: yeah, that's specified by the data of a category.
00:13:33 <tolkad> Alright, category theory seems pretty simple then
00:13:57 <Nereid> well, the basic definitions of a category are pretty simple
00:14:16 <tolkad> yup, so now that I know them I guess I know category theory
00:14:18 <luite> the taocp approach is too low level/detailed for me, I'd rather have a higher level understanding that I can actually use...
00:14:23 <Nereid> not really :/
00:15:56 <danharaj> Category theory isn't about morphisms, it's about natural transformations :p
00:16:04 <shaleh> so did lambdabot 2 ever happen? The darcs repo appears to be a little old
00:16:23 <Athas> How do I get Haddock to put stability/author/portability-information into its generated pages (like on http://hackage.haskell.org/packages/archive/X11/1.5.0.0/doc/html/Graphics-X11-Xlib-Cursor.html )?
00:16:56 <tolkad> shaleh: it was too succesful. The channel couldn't handle its intellect and it was shut down before it destroyed us
00:17:16 <tolkad> successful*
00:17:26 <shaleh> tolkad: right, skynet and all that. Good call.
00:27:28 <tolkad> Ok, functors made sense. The weirdest thing about this is that it's in terms of associations rather than functions
00:28:10 <Nereid> huh
00:28:14 <dmwit> associations?
00:28:39 <Nereid> a functor is defined by a collection of functions
00:28:58 <Nereid> one of them tells you how to map objects
00:29:07 <Nereid> so a functor F: C -> D consists of:
00:29:14 <Nereid> a function F: Ob(C) -> Ob(D)
00:29:24 <Nereid> and then, for each pair of objects A, B of C,
00:29:35 <Nereid> a function hom(A,B) -> hom(F(A),F(B))
00:29:50 <Nereid> hmm
00:30:05 <Nereid> in case you haven't seen that notation, hom(A,B) = the collection of morphisms from A to B.
00:30:52 <Nereid> really one should specify the category and write hom_C(A,B)
00:30:53 <tolkad> http://en.wikipedia.org/wiki/Functor#Definition
00:30:55 <Nereid> but whatever
00:31:08 <Nereid> the word "associates" means
00:31:12 <Nereid> you have a function
00:31:31 <Nereid> if I have a function f: X -> Y
00:31:37 <tolkad> Oh good.
00:31:41 <Nereid> I can sort of rephrase that by sayin
00:31:49 <Nereid> f associates, to each element of X, an element of Y
00:31:53 <Nereid> saying*
00:32:41 <tolkad> So this is basically just graph theory with a bunch of silly rules about what graphs you can make
00:32:50 <Nereid> well a graph is a kind of category
00:32:55 <tolkad> (that was a joke)
00:32:57 <Nereid> except not really
00:32:59 <Nereid> sorry
00:33:03 <Nereid> a category is a kind of graph.
00:33:12 <NihilistDandy> There's a category of graphs, I think
00:33:19 <Nereid> sure, but that's not the point
00:33:26 <NihilistDandy> :D
00:34:13 <Nereid> a category is a graph with a composition rule
00:34:23 <Nereid> (which satisfies some axioms etc.)
00:36:54 <tolkad> So because categories are defined in terms of collections of sets (a class of objects and a class of morphisms), to use category theory you need to use the axioms of set theory?
00:37:15 <Nereid> uh
00:37:57 <Nereid> well, category theory depends on set theory in the sense that it is phrased in terms of sets
00:38:02 <Nereid> but that kind of misses the point
00:38:11 <tolkad> But if you want to prove things in category
00:38:23 <tolkad> You may need to use set theory axioms?
00:38:26 <napping> you prove them from the axioms of category theory
00:38:42 <Nereid> that's like saying
00:38:47 <tolkad> Oh I see
00:38:51 <Nereid> if you want to prove things in math
00:39:00 <Nereid> you may need to use set theory axioms
00:39:09 <napping> You can have categories that don't exist as sets
00:39:12 <tolkad> Because you never have to look inside morphisms/objects within category theory
00:39:27 <tolkad> You don't have to care that they are sets?
00:39:29 <napping> like, the category Set of all sets
00:39:50 <Nereid> napping: well you can "make" it a set by talking about universes, but whatever
00:40:26 <Nereid> tolkad: I think of category theory to be more of a language
00:40:31 <napping> There are many categories where the objects and morphisms are not sets and functions between sets
00:40:46 <Nereid> indeed
00:40:59 <napping> for example, the objects can be points in a topological space, and the morphisms homotopy classes of paths between them
00:41:09 <Nereid> you mean homotopy classes of maps
00:41:29 <Nereid> but even so
00:41:42 <napping> Or, just take as objects the members of an ordered set, and say there's a morphism a -> b if a < b
00:41:48 <napping> a <= b, rather
00:41:55 <Nereid> that's concretizable
00:41:56 <tolkad> wait the objects and morphisms have to be sets. the definition of category theory says categories are made of a class of objects, and a class of morphisms. Classes are collections of sets.
00:41:57 <Nereid> not that anyone cares
00:42:04 <napping> oh, is it?
00:42:16 <napping> well, I guess you could pick particular functions
00:42:19 <Nereid> yes
00:42:32 <napping> ZF doesn't have classes
00:42:36 <NihilistDandy> tolkad: They certainly don't have to be sets :P
00:42:47 <Nereid> napping: it does have classes, if you define "class" to be "one-argument predicate"
00:43:01 <tolkad> Then what is the definition of class they are using?
00:43:02 <Nereid> and stuff
00:43:09 <Nereid> tolkad: it doesn't matter
00:43:37 <Nereid> if you like, you can talk about classes with NBG (a conservative extension of ZFC, which has two types)
00:43:41 <Nereid> (namely, sets and classes)
00:44:13 <Nereid> but really,
00:44:18 <tolkad> Doesn't category theory need axioms though?
00:44:38 <Nereid> well of course you have to work in some logical system
00:45:03 <Nereid> but that question doesn't really mean anything
00:45:04 <Nereid> :/
00:45:10 <tolkad> Oh good
00:45:14 <tolkad> I was hoping it didn't
00:45:17 <Nereid> about the "one-argument predicate" thing
00:45:22 <Nereid> you can think of a class C
00:45:56 <Nereid> uh
00:45:59 <tolkad> Oh, so category theory is based on first order logic
00:46:00 <Nereid> how do I want to phrase this
00:46:35 <Nereid> and set theory
00:46:36 <Nereid> in some sense
00:46:37 <Nereid> I guess
00:46:39 <Nereid> but who cares
00:47:16 <Nereid> you can think of a class C has just a thing that tells, given a set X, whether X is "in C" or not
00:47:27 <Nereid> that is, it assigns to each set a truth value
00:47:37 <Nereid> so it's a one-argument predicate.
00:48:20 <Nereid> now, each set defines a class in an obvious way (given a set X, we can define a predicate which takes a set Y to the truth value of the statement "Y is in X")
00:48:30 <Nereid> but there are lots of classes which don't come from sets like that
00:48:33 <Nereid> like the class of all sets
00:49:06 <napping> tolkad: anyway, people prove things by looking at diagrams and using uniqueness properties and so on
00:49:09 <Nereid> but
00:49:13 <Nereid> whatever
00:49:18 <Nereid> that's not the point
00:49:26 <napping> rather than by doing tricky things with logic, or using set theory axioms
00:49:30 <Nereid> the point of category theory is
00:49:35 <Nereid> you have some thing
00:49:38 <Nereid> (where "thing" is very vague)
00:49:58 <Nereid> and you come up with a way of talking about the thing in terms of categories and whatnot
00:50:28 <Nereid> then you prove things about it, using general results in category theory
00:50:30 <Nereid> or something
00:50:43 <Nereid> so like I sort of said earlier
00:51:02 <Nereid> category theory is in some sense a unified language which you can use to talk about things
00:51:05 <Nereid> whatever things may be
00:51:06 <Nereid> :/
00:51:46 <NihilistDandy> It doesn't matter what the thing is, but it satisfies these axioms and has these properties. Therefore, everything that has these properties satisfies these axioms and is also one of these things
00:52:04 <NihilistDandy> Or something to that effect
00:52:19 <NihilistDandy> I may have something backwards. It's late :D
00:53:19 <Nereid> there's a fair bit of stuff that I haven't really looked deeply into about category theory and logic/foundations
00:53:24 <ddarius> Category theory is like group theory.  The elements of a group don't need to be a set, and in fact, the group itself doesn't need to be a set.  Talking about sets is neither here nor there for these purposes.
00:53:33 <NihilistDandy> Right
00:53:38 <Nereid> maybe something about topoi or so
00:53:40 <Nereid> I don't really know
00:54:09 <NihilistDandy> Hence my attempt to remove "set" from my description
00:54:19 <Nereid> well
00:54:20 <NihilistDandy> Made it all sound a bit wishy-washy in the end :D
00:54:31 <Nereid> groups and elements of groups, when we usually define them,
00:54:32 <Nereid> are sets
00:54:43 <Nereid> but we don't care about the internal structure of those sets
00:54:46 <NihilistDandy> But we're not concerned with what's *in* the groups
00:54:52 <NihilistDandy> Right
00:54:54 <Nereid> well, of the elements
00:55:02 <NihilistDandy> It's about the properties of the structures themselves
00:55:06 <Nereid> of course we care about what's "in" the group
00:55:09 <NihilistDandy> Regardless of content
00:55:36 <Nereid> but we don't care about the details of the individual elements
00:55:40 <Nereid> only how they're related to each other
00:55:44 <NihilistDandy> Yes, that
00:55:50 <Nereid> category theory is pretty much the same thing
00:55:52 <Nereid> in a category,
00:55:55 <NihilistDandy> But bigger
00:56:07 <Nereid> we don't care about what internal structure an object or morphism has
00:56:15 <Nereid> only how they are related to other objects/morphisms
00:56:51 <Nereid> because sure, if you define everything as usual, objects and morphisms are actually sets
00:57:01 <Nereid> but we don't care which particular sets they are
00:57:19 <NihilistDandy> I wouldn't go that far, really
00:57:26 <Nereid> ?
00:57:34 <NihilistDandy> Objects and morphisms need not be sets
00:57:59 <Nereid> ZFC doesn't give us any way of talking about things that aren't sets
00:58:07 <Nereid> because everything is a set
00:58:08 <ddarius> ZFC is silly.
00:58:12 <Nereid> or whatever set theory.
00:58:28 <ddarius> There are plenty of set theories with ur-elements.
00:58:44 <NihilistDandy> Also, category theory != set theory
00:58:49 <Nereid> of course not.
00:59:07 <Nereid> category theory doesn't really depend on any particular set theory
00:59:12 <NihilistDandy> So trying to force it into set theory is an exercise in obtuseness or futility
00:59:34 <tolkad> The only way to do real, formal mathematics, is precisely specify exactly which axioms you believe are true
00:59:54 <Nereid> ddarius: I just use ZFC because I don't really care about foundations
00:59:57 * hackagebot certificate 0.8.0 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.8.0 (VincentHanquez)
01:00:16 <ddarius> Nereid: You don't use ZFC.  No one uses ZFC.
01:00:31 <Nereid> define "use"
01:00:42 <tolkad> Yeah, the axiom of choice is obviously false. Real mathematicians use ZF
01:00:59 <ddarius> Nereid: Let's start with "can remember the axioms."
01:01:20 <Nereid> I don't use the axioms directly.
01:01:33 <Nereid> set theory is something I care very little for
01:01:49 <ddarius> Nereid: Set theory is something the vast majority of mathematicians care very little for.
01:02:13 <tolkad> So how do mathematicians know category theory is correct?
01:02:30 <ddarius> tolkad: The same way mathematicians know set theory is correct.
01:02:37 <NihilistDandy> tolkad: They told you so
01:02:50 <Nereid> I generally just use whatever results are relevant to me, taking it on faith that they follow from the axioms
01:03:06 <issac> Quick question about installing cabal on OS X:
01:03:15 <issac> I'm getting this error
01:03:18 <issac> [ issactrotts jaynes ~ ] cabal install cabal-install cabal: ^: does not exist
01:03:19 <NihilistDandy> issac: Haskell Platform. Use it
01:03:31 <ddarius> Nereid: Most of mathematics doesn't go into the places where set theory gets wonky.
01:03:35 <Nereid> right
01:03:41 <Nereid> I try not to go into such places
01:04:02 <tolkad> What are you talking about, you can't assign "correctness" to theories. You can only say whether they are internally consistent, and whether they can be used to model a specific real-world system
01:04:06 <issac> Thanks NihilistDandy, I'll try that.
01:04:10 <tolkad> mathematical theories*
01:04:12 <NihilistDandy> :)
01:04:14 <ddarius> This is why set theorists are considered esoteric by esoteric mathematicians even though, at first blush, it seems that set theory is used everywhere.
01:04:37 <ddarius> tolkad: I agree.  So why did you bring it up?
01:05:15 <tolkad> ddarius: it sounds funny to say you "believe" an axiom is true =D
01:07:03 <ddarius> The set theory that is used everywhere is basically a somewhat careful usage of naive set theory.
01:08:54 <dankna> are there any set theories that are strongly typed?  heh
01:08:59 <dankna> just curious, as an outsider
01:09:02 <tolkad> ddarius: this wikipedia page says it's important to be precise about such things: http://en.wikipedia.org/wiki/Formalism_%28mathematics%29
01:09:27 <dankna> it just strikes me that they lend themselves to paradoxes primarily because they aren't, so ideas like "set of all sets that satisfy ..." are well-typed
01:09:32 <Nereid> sure, but the precise formalism you use usually isn't extremely impotrant
01:09:41 <Nereid> see some things like http://www.ncatlab.org/nlab/show/foundations
01:09:50 <ddarius> tolkad: It's probably more important to floss, but many people don't do it and their lives still go on.
01:09:54 <Nereid> or
01:10:02 <Nereid> well maybe not the best article, but perhaps it's a start
01:10:31 <ddarius> dankna: Higher order logic/type theory is basically what type set theory would be.
01:10:41 <ddarius> s/type set/typed set/
01:10:41 <dankna> yes
01:11:08 <dankna> so I guess the answer is "it exists, but set theorists find it uninteresting because it apparently works pretty well"
01:11:37 <Nereid> no, it's the set theorists and logicians and whatever who care about such things
01:11:43 <dankna> heh
01:11:46 <dankna> I'm too tired to get myself into this
01:12:10 <tolkad> So they are being lazy by not specifically using the ZFC axioms and if they did we would be living in a technological utopia?
01:12:20 <Nereid> uh no
01:12:32 <o-_-o> Easy to isolate effects when not being pure; useful for forcing invariants <- What does it mean when someone says useful for forcing invariants ?
01:12:47 <ddarius> The people who actually call themselves "set theorists" are interested in things like large cardinals and continuum hypothesis, not in better languages for doing mathematics.
01:12:49 <Nereid> tolkad: actually, a lot of what you're saying doesn't really make sense? D:
01:12:58 * hackagebot certificate 0.8.1 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.8.1 (VincentHanquez)
01:12:59 <tolkad> Nereid: yeah, it's fun =D
01:13:00 * hackagebot tls 0.6.3 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.6.3 (VincentHanquez)
01:13:12 <ddarius> Nereid: A lot of what tolkad says in general doesn't make sense.
01:13:15 <Nereid> lol
01:13:24 <ddarius> Nereid: That wasn't a joke.
01:13:29 <Nereid> :v
01:13:52 <dankna> Able was I ere the barn fell?  (Sorry - did I mention I'm tired.)
01:13:55 <tolkad> Sometimes I feel like making sense, sometimes it's more interesting to see what people will say if I don't
01:14:01 <ddarius> o-_-o: Probably "useful for -en-forcing invariants"
01:15:27 <tolkad> ddarius: sometimes people say "forcing" if they are trying to imply manipulation, rather than ensuring adherence
01:15:40 <tolkad> Depending on the context that may or may not have meaning
01:15:59 * hackagebot tls-extra 0.2.2 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.2.2 (VincentHanquez)
01:16:00 <Nereid> enforcing makes a lot more sense though
01:17:02 <tolkad> Sometimes that implication isn't even literal; it's fits with the authors mental model of the system
01:17:12 <tolkad> it just fits* author's*
01:18:25 <dankna> there actually are "AIs" that mix Markov-chain text with code to simulate human typos.  tolkad could be one of those :)
01:18:35 <dankna> I demand a Turing Tribunal to find out.
01:18:40 <Nereid> lol
01:19:00 <zenzike> oh boo. yesod failed to cabal install on my machine. now I need to start dependency chasing ...
01:19:16 <tolkad> dankna: Im not a bot lol i talk like a human
01:19:28 <ddarius> If you just trained a Markov-chain model on actual text "in the wild" there would be no need to have code for adding typoes.
01:19:41 <dankna> ddarius: yeah, but then he corrects them.
01:20:09 <ddarius> dankna: That should arise too.
01:20:36 <dankna> I'm not sure you've played around with Markov chains enough to intuitively understand their limitations :)
01:20:47 <dankna> you'd need a very long chain length, six words or more, to get that behavior
01:21:07 <ddarius> It wouldn't happen often, but I'm sure tolkad doesn't correct most of his typoes.
01:21:16 <ddarius> And yes, you would need a decent chain length.
01:21:19 <dankna> to get realistic text with such a long chain, you would need a very large sample set
01:21:22 <dankna> well, okay, that's a point
01:21:25 <tolkad> Actually I'm just really impulsive at times and say things I think sound funny while in IRC channels.
01:21:52 <dankna> hmm, is it chaining off the last thing /we/ say or the last thing /it/ says :)
01:21:59 * dankna pokes tolkad with a logic probe
01:23:21 <ddarius> At any rate, if tolkad was simply a Markov-chain bot, we'd know regardless of code to simulate correcting typoes.
01:23:24 <dankna> the real trick would be some sort of a mixed model - the Eliza model is good at seeming to stay in-context, while the Markov model is good at grammatical plausibility.  of course the only application domain is annoying people, which is not directly monetizable, probably accounting for the lack of formal research.
01:23:53 <dankna> that's true, of course.
01:24:17 <luite> how does the eliza model work?
01:24:32 <tolkad> I think it's mostly just preprogrammed responses with fill-in-the-blanks
01:24:36 <dankna> I was trying to remember the exact details, but they seem to have been GCed out of my mind, which is just as well.
01:24:43 <tolkad> Or something like that
01:24:53 <dankna> it is indeed what Tolkad just said, I remember reading a huge data file of sentence templates once.
01:24:59 <dankna> "Earlier you mentioned your X."
01:25:38 <dankna> it keys off certain words, for some categories of response; for example, attempts to change the roles in the conversation usually produce "We were discussing you - not me."
01:25:41 <Nereid> the dream would be to have an AI that knows human universal grammar, so that it can learn a language like humans do.
01:25:46 <Nereid> :/
01:25:51 <dankna> Nereid: they're working on grammar acquisition
01:26:00 <dankna> there seems to have been some progress recently in algorithms for that,
01:26:06 <ddarius> Humans have a universal grammar?
01:26:14 <dankna> but, oddly, not from people with the slightest linguistic background - they're using it for DNA analysis
01:26:16 <Nereid> ddarius: many linguists believe so.
01:26:23 <dankna> I actually believe otherwise
01:26:47 <zomg> I recall reading an article saying the opposite on newscientist or something quite recently
01:26:59 <dankna> but I'd simply reword your description of the dream from "human universal grammar" to "how to infer a grammar from samples of it"
01:27:10 <zomg> I don't really know anything about it, only that I read an article which talked about it =)
01:27:17 <c_wraith> yeah, there was just some paper published providing evidence to doubt the idea of a universal grammar
01:27:25 <dankna> the theory that there is a universal grammar ("innate language") was what made Chomsky famous
01:27:32 <tolkad> There are obviously some universal elements. No language is going to have to require too much short term memory use to parse for common speech
01:27:38 <dankna> he is still quite powerful in linguistic circles, but it is becoming acceptable to disagree with him
01:28:03 <tolkad> I guess that's rather trivial though
01:28:10 <Nereid> well my point was really just to have something that can acquire knowledge of a language as humans do.
01:28:13 <dankna> what tolkad said is roughly my own view: any things we find that are more-or-less universal don't say anything about humans, but may say a lot about communication
01:28:46 <dankna> as far as we know, every natural language has both nouns and verbs.  or at least as far as /I/ know :) I took some undergrad courses on this subject, so I am totally a reputable source!
01:28:59 <dankna> that's pretty much the only thing though
01:29:01 <dblhelix> dankna: not just to disagree with him; I recently read about some research providing evidence of exactly the opposite of his claims
01:29:24 <Nereid> dankna: I'm pretty much in the same situation D:
01:29:25 <dankna> dblhelix: Actually, my own mother is a PhD in developmental psychology and did her thesis on that topic as well.  Twenty years ago.
01:29:34 <Nereid> except my mother was not that.
01:29:46 <dblhelix> Nereid: heh :)
01:29:57 <dankna> dblhelix: so I think I can confidently state that this research is not novel, although it is certainly a good thing that it's coming to light :)
01:30:17 <Nereid> well
01:30:19 <Nereid> worst case
01:30:21 <Nereid> we simulate a human
01:30:36 <Nereid> (like that'll happen any time in the next n years)
01:30:36 <dblhelix> danka: I don't think they claimed their research is novel
01:30:38 <Nereid> (where n is pretty large)
01:30:42 <dankna> yeah.  but we don't have the transistor density for that yet :)
01:30:53 <ddarius> dankna: Actually...
01:30:57 <tolkad> Unless the ones-that-came-before preprogrammed us to develop certain self-concealing underlying patterns in all our culture and communications. When computer programs recognize these patterns and inform humans about them, it will drive us all insane
01:31:05 <dankna> dblhelix: yeah, I wasn't saying they did.  I imagine it wasn't even new when she did it, although her approach to it might have been.
01:31:26 <dankna> tolkad: there was an Asimov story about that.  the pattern pre-programmed was having a sense of humor.
01:31:27 <Nereid> dankna: well hopefully *something* about it was new
01:32:04 <dankna> the punchline of the story that they asked their computer "what is the purpose of humor?" and it told them the correct answer, and...
01:32:18 <dankna> (and the computer was the size of a city - Asimov predicted their importance, but not the microchip!)
01:33:01 <rostayob> usually how do you handle null pointes when you handle a C struct with a data type?
01:33:01 <dankna> ... the full answer was "... it's a psychology experiment conducted on you humans, by aliens.  as soon as you learn this, it will cease to be useful as such, and therefore will be turned off and replaced with something else."
01:33:03 <tolkad> His robot brains were analog
01:33:04 <rostayob> a Maybe?
01:33:14 <dankna> they were "positronic", which was an intentionally vague term
01:33:14 <rostayob> *null pointers
01:33:25 <dankna> but yes, they didn't behave /at all/ like computers
01:33:47 <dankna> and the humans in the story then tried to tell each other jokes and were unable to find them funny.  cue Twilight Zone music.
01:33:51 <tolkad> dankna: He refers to potentials of some sort in a very analog-sounding way
01:33:57 <dankna> hmmm, okay.
01:34:09 <dankna> putting actual positrons in them sounds pretty dangerous :)
01:34:56 <dankna> and then there was the Foundation trilogy, which mysteriously had neither computers nor robots, but did have a "typewriter" that took voice dictation and produced cursive.
01:35:18 <dankna> he didn't always feel obligated to think about how his inventions would work!
01:36:01 <dankna> (in the "oh, so close!" department, Vernor Vinge once wrote a short story with a "video cassette" - by that exact name, before such a thing existed - but its tape needed to be manually spooled!)
01:36:18 <Nereid> lol
01:36:21 <tolkad> Lol, he also assumed we would send humans everywhere rather than just simulating human minds on more efficient hardware
01:36:21 <dankna> yeah :D
01:36:39 <dankna> what were we talking about
01:36:46 <dankna> oh yes, linguistics
01:36:55 <dankna> it's great to see progress in the field :)
01:39:12 <dankna> "Through the early-1980s, electronics that output a television channel signal were required to meet the same shielding requirements as broadcast television equipment, thus forcing manufacturers such as Apple to omit an RF modulator, and Texas Instruments to have their RF modulator as an external unit, which they had certified by the FCC without mentioning they were planning to sell it with a computer." -- huh!
01:39:36 <dankna> that explains an extremely bulky RF modulator I once owned
01:39:53 * Nereid is too young for that D:
01:39:57 <dankna> aw, hehe
02:09:54 <jonkri> what would a simple identity do-block look like?
02:10:14 <sipa> \x -> do return x
02:10:19 <sipa> or just return
02:14:10 <jonkri> sipa: i mean a sequential do-block
02:15:45 <quicksilver> "identity" in what sense jonkri ?
02:15:49 <scree> jonkri: well, do { x <- foo; return x } is equivalent to foo
02:16:11 <jonkri> quicksilver: Control.Monad.Identity
02:16:29 <quicksilver> well, you can't do much with Control.Monad.Identity
02:16:34 <jonkri> scree: so it's not possible for the identity monad to carry some kind of state then?
02:16:37 <quicksilver> it has no interesting actions
02:16:57 <jonkri> or context
02:17:09 <scree> jonkri: didn't realize you meant the Identity monad; but no, it does nothing interesting
02:18:11 <shachaf> jonkri: In Identity, <- is more or less like let.
02:18:28 <scree> > runIdentity $ do { x <- 6 + 7; y <- "blah"; return (x, y) }
02:18:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
02:18:29 <lambdabot>         against inferred ty...
02:18:30 <shachaf> jonkri: Monads/do-blocks have nothing to do with carrying state.
02:18:46 <scree> > runIdentity $ do { x <- return (6 + 7); y <- return "blah"; return (x, y) }
02:18:47 <lambdabot>   (13,"blah")
02:19:09 <jonkri> got it, thanks
02:19:28 <scree> hmm, on second thoughts that wasn't very instructive.  all monads do that :P
02:20:22 <jonkri> and if they carry a state it's because it's wrapped in the monadic datatype, right?
02:20:58 <exeter> hello haskellers, I've got one very simple question which puzzles me. I have downloaded and installed something from cabal (today, Haskell XML toolbox): where do I find the documentation generated via hackage?
02:21:06 <jonkri> the actual list in the list monad could be called a context, right?
02:21:14 <exeter> oh, i am on windows 7
02:21:40 <exeter> is there any folder / specific way to invoke it from winghci?
02:21:41 <jonkri> exeter: try http://haskell.org/hoogle/
02:22:03 <jonkri> oh, i don't know where it's stored locally
02:22:17 <exeter> jonkri, thanks! but sometimes I'm offline... (that's why I asked)
02:22:25 <quicksilver> scree: well, it is precisely characteristic of the Identity monad that it only does things that all monads do.
02:22:29 <exeter> oh, so the "standard" way is to hoogle it?
02:23:39 <jonkri> exeter: if you're using firefox you can right click on the hoogle input text field and choose "add a keyword for this search", specify the name "h", and then you can hoogle by saying "h myquery" in the address bar
02:24:16 <jonkri> (you can access the address bar with alt+d)
02:24:22 <exeter> thanks jonkri , sad is he who has no connection then :P
02:24:30 <quicksilver> exeter: well the doc system is intended to work
02:24:36 <quicksilver> exeter: it's just people are lazy and don't know how to use it.
02:24:49 <jonkri> exeter: of course, just a little tip for when you actually are online :)
02:24:51 <quicksilver> exeter: I think there is a cabal flag to get the docs built
02:25:10 <quicksilver> exeter: but I am lazy like the others here and I use the online stuff.
02:25:41 <quicksilver> --enable-documentation, I believe
02:25:51 <exeter> mhhh, thanks, I'll look into that
02:26:42 <exeter> The question stems from me reading wikibooks on haskell xml and finding an unrecognised command (formatXmlTree http://en.wikibooks.org/wiki/Haskell/XML )
02:39:35 <cch> @pl \f g -> \x -> g (f x)
02:39:35 <lambdabot> flip (.)
02:40:39 <helino> hi, is it possible to define a function in Haskell as commutative?
02:41:22 <helino> for example, if I know that f a b = f b a, can I tell Haskell this in some way so I don't have to define f for all inputs?
02:41:55 <flux> you can possibly use the function recursively in your definition
02:43:31 <helino> flux: ok, unfortunately in my case, I have "data Sign = Pos | Neg | Zero | Any | None", and then I want to define a function "add :: Sign -> Sign -> Sign"
02:43:43 <quicksilver> helino: yes, you can write "f a b = f b a" as the final case
02:43:50 <quicksilver> after you've analysed all the one-sided cases
02:44:01 <helino> quicksilver: oh wow, sounds awesome!
02:44:04 <quicksilver> if you miss any you'll get an infinite loop.
02:44:13 <quicksilver> someone asked the same question on friday, is there some class going on? ;)
02:44:27 <flux> I think any kind of available coverage analysis wouldn't even catch that, but it would be cool if it did :)
02:44:54 <helino> quicksilver: I dunno, I'm doing this for an assignment, but I think I'm the only one in my class using Haskell
02:47:36 <helino> quicksilver: it worked great, thanks for your help!
02:50:21 <exeter> I disappear, thanks again!
03:10:32 <hvr> dcoutts: is cabal's {default,other}-language documented anywhere?
03:12:36 <mpiechotka> @pl: \(x, y) -> f (g x) y
03:12:36 <lambdabot> uncurry (f . g)
03:40:34 <triyo> I'm trying to install the iterIO library from hackage on a Mac OS X but get a compilation error for the cbits/HsOpenSSL.c
03:40:48 <triyo> I have openssl installed with the header files
03:41:15 <triyo> cbits/HsOpenSSL.c:220:0:      error: ‘i2d_of_void’ undeclared (first use in this function)
03:41:25 <triyo> Anyone have an idea what it might be please?
03:41:51 <triyo> I'd really like to give this cool new lib "iterIO" a try
03:45:01 <erus_> is there a prettier way todo a map than this: http://hpaste.org/46523/map
03:45:38 <Lemmih> erus_: You can derive Read and Show.
03:55:30 <jonkri> is there some way i can write this in a simpler way: example :: [Integer] -> [Integer]
03:55:30 <jonkri> example l = l >>= \ x -> [x + 1] >>= \ x -> [x * 3] >>= \ x -> if odd x then [] else [x]
03:56:12 <triyo> I'm not the only one with this problem it seems http://mailrepository.com/haskell-cafe.haskell.org/msg/3566667/
03:56:42 <mjrosenb> is there any way to calculate a 'laziness quotient' for a structure?
03:57:15 <mjrosenb> that is, to mark it such that when it gets GC'ed, the gc counts up how many of its nodes were thunks that were waiting to be evaluatied?
03:58:19 <shachaf> jonkri: example l = [y | x <- l, let y = (x+1)*3, even y] ?
03:58:33 <DRMacIver> triyo: Sounds like it's not building using the C backend.
03:58:34 <shachaf> jonkri: I'm not sure why you're doing that weird thing with >>= and single-element lists.
03:58:35 <jonkri> shachaf, i want to illustrate the use of the list monad
03:58:40 <DRMacIver> triyo: Which it'll need to for macros to work
03:58:59 <shachaf> jonkri: Well, "the list monad" is pointless with functions of the form (\x -> [f x])
03:59:05 <parcs> jonkri: use return (f x) instead of x -> [f x]
03:59:13 <parcs> or rather, return . f
03:59:16 <shachaf> You can use guard (even x) >> ... instead of that if.
03:59:25 <shachaf> parcs: Or, rather, fmap. :-)
03:59:31 <triyo> DRMacIver: thanks for your response. What do you mean exactly by C backend?
03:59:51 <parcs> what shachaf said
04:00:01 <jonkri> shachaf, it's ok for it to be pointless, as long as it illustrates how the list monad work. but i guess it don't...
04:00:30 <shachaf> jonkri: No, please.
04:00:36 <shachaf> Are you writing another monad tutorial or something?
04:00:39 <DRMacIver> triyo: (disclaimer in advance: I'm just guessing) GHC can compile in one of a variety of ways. One of them involves compiling to C source. Macros are basically never going to work unless you're using that one.
04:00:55 <shachaf> Don't "illustrate how the list monad work" unless there's actually a point to it.
04:00:56 <jonkri> shachaf, yes
04:01:22 <shachaf> jonkri: Why?
04:01:36 <jonkri> shachaf, i'm writing something i wish i had read when learning monads
04:01:44 * shachaf shudders.
04:02:04 <shachaf> You don't know what you're doing here, jonkri. Step away from the keyboard.
04:02:20 * shachaf may be exaggerating slightly.
04:02:29 <jonkri> well, obviously i still don't understand them, but i still think this tutorial will be useful when it's done. i'm going to put it up for review before i publish :)
04:02:59 <DRMacIver> triyo: ...but depending on how the FFI is being used it may or may not work even with that, and I've no idea about this specific case
04:04:22 <parcs> > let example l = l >>= \ x -> [x+1} >>= \x -> [x * 3] >>= \ x -> if odd x then [] else [x] in example [1..5]
04:04:23 <lambdabot>   <no location info>: parse error on input `}'
04:04:33 <parcs> > let example l = l >>= \ x -> [x+1] >>= \x -> [x * 3] >>= \ x -> if odd x then [] else [x] in example [1..5]
04:04:34 <lambdabot>   [6,12,18]
04:04:51 <triyo> DRMacIver: I just tried to install HsOpenSSL-0.9 using cabal and got that error. Hmm, will need to look into this in more depth
04:06:26 <parcs> > let example = fmap ((*3) . (+1)) >+> guard . even in exmaple [1..5]
04:06:27 <lambdabot>   Not in scope: `>+>'Not in scope: `exmaple'
04:07:06 <shachaf> jonkri: By the way: Using list comprehensions *is* "using the list monad".
04:07:23 <DRMacIver> triyo: Might be an argument you can pass to cabal install to get it to build with a different backend? But I'm just guessing at this point
04:07:42 <erus_> how can i test for equality on my custom type?
04:08:08 <triyo> DRMacIver: thanks for giving me some ideas.
04:08:15 <DRMacIver> No worries
04:08:34 <jonkri> shachaf, my goal is to keep it simple. i don't want to involve fmap and list comprehensions if i can avoid it
04:09:23 <jonkri> erus_, make an instance of the Eq type class... instance Eq YourType where \n a == b = True
04:09:28 <shachaf> fmap is simpler than >>=.
04:09:49 <shachaf> List comprehensions are usually introduced before >>=, too.
04:10:04 <jonkri> shachaf, it depends on how you look it. i'm writing about the overall concept, not functors and stuff like that. this is how my tutorial is different
04:10:27 <jonkri> my tutorial is only complementary to other monad tutorials out there
04:10:32 <shachaf> Huh? Fine, use "map" instead of "fmap".
04:10:41 <shachaf> Or use liftM, which is just (>>=) and return.
04:10:59 <jonkri> shachaf, for someone that doesn't understand what a monad is and how they are used that wont make any sense at all
04:11:19 <shachaf> What won't make sense? The function map :: (a -> b) -> [a] -> [b]?
04:12:12 <jonkri> no, but i'm thinking mentioning that will stray away from the point of my article
04:12:30 <shachaf> @where burrito
04:12:30 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
04:16:03 <cinch> nice article^
04:16:18 <byorgey> thanks =)
04:16:33 <cinch> :)
04:17:57 <jonkri> shachaf, i have read that article before mostly agree with it. i have been very frustrated with some counter-productive tutorials on monads. i think though that there are some things i can say about monads that will not be hurtful, but instead increase the speed of this intuition-building proces
04:19:13 <jonkri> actually, i completely agree with the article
04:19:28 <shachaf> What can you say about "monads"?
04:19:31 <Nereid> ah, that article.
04:19:48 <jonkri> shachaf, i will show you my article when i'm done and you'll see
04:20:09 <Nereid> that's far from restricted to monads :o
04:21:13 <sordina> Can the pcap package be used to parse pcap dump files?
04:21:31 <Phyx-> @todo
04:21:32 <lambdabot> 0. SamB: A way to get multiple results from a google search
04:21:32 <lambdabot> 1. dons: improve formatting of @dict
04:21:32 <lambdabot> 2. dons: write Haskell Manifesto
04:21:32 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
04:21:32 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
04:21:34 <lambdabot> [31 @more lines]
04:21:40 <Phyx-> wow, that actually worked?
04:22:01 <Nereid> although, I don't really have an analogy for monads that gives me intuition
04:22:06 <Nereid> it's just kind of this abstract thing
04:22:08 <Nereid> :c
04:22:32 <shachaf> Nereid: Exactly.
04:29:51 <jonkri> Nereid, shachaf: how about thinking about monads as a framework for doing imperative programming (a sequence of operations in a certain context), where the context and the operations possible depend on the monadic type?
04:30:30 <Nereid> it's more than that though
04:30:45 <parcs> context is an ugly word
04:30:50 <Nereid> and imprecise
04:30:53 <shachaf> jonkri: Monads have nothing to do with imperative programming.
04:31:02 <jonkri> shachaf, they allow it, don't they?
04:31:11 <osaunders> Is there a name or type class for functions like changeXmlTxt in http://hpaste.org/46524/change_xml_string ?
04:31:11 <shachaf> "they"?
04:31:47 <jonkri> i'm not saying that monads are only a framework for imperative programming, but they, monads, can be used for that purpose... right?
04:31:51 <shachaf> jonkri: You could do Haskell-style IO without "monads" or a >>= function.
04:32:04 <Nereid> osaunders: it looks a lot like some sort of fmap
04:32:13 <shachaf> What you're saying doesn't make much sense.
04:32:21 <osaunders> jonkri: They are just a structure for effectful programming. The effects themselves are carried out by the runtime
04:32:25 <shachaf> What's "they"? The monad type class? Not really. Identity? Not really.
04:32:40 <osaunders> Monads
04:32:44 <shachaf> IO? Sure. But that doesn't mean much.
04:33:01 <Nereid> osaunders: that is, if you made Xml take a type parameter instead of just String, then changeXmlTxt would make Xml into a functor (with fmap = changeXmlTxt)
04:33:25 <osaunders> Nereid: Ah
04:34:08 <osaunders> But I don’t want the type to vary, I want it to be a string
04:34:23 <Nereid> I'm just telling you what it looks like
04:34:28 <Nereid> :P
04:34:34 <jonkri> shachaf, how do you do IO without "monads" or ">>="?
04:34:35 <osaunders> Yeah, sure, and I appreciate it
04:34:53 <shachaf> jonkri: Well, clearly things that you can describe as "monads" remain.
04:34:56 <shachaf> Functions, for example.
04:35:39 <Nereid> jonkri: Clean does IO without monads
04:35:59 <shachaf> Nereid: Sure, but you can do it Haskell-style.
04:36:05 <Nereid> sure
04:36:12 <osaunders> Nereid: OK, let me revise this I have another question that needs a different example
04:36:18 <shachaf> Just pass a continuation to each IO action. It's good enough for the Node.js people, right? :-)
04:36:24 <Nereid> osaunders: sorry, I really need to get to bed.
04:36:27 <Nereid> :c
04:36:29 <osaunders> lol ok
04:36:31 <Nereid> it's 05:42
04:36:36 <Nereid> bye!
04:36:39 <osaunders> See ya
04:36:40 <shachaf> Say, getLine :: (String -> IO a) -> IO a, putStrLn :: String -> IO () -> IO (), and so on.
04:36:44 <shachaf> Or something like that.
04:36:59 <shachaf> See? No (>>=)ing.
04:38:19 <jonkri> shachaf, but is it sequential?
04:38:55 <shachaf> Sure, in the same way that >>= is.
04:39:22 <shachaf> main = getLine (\s -> putStrLn ("you typed " ++ s))
04:39:35 <shachaf> Er, main = getLine (\s -> putStrLn ("you typed " ++ s) doNothing)
04:40:31 * hackagebot cabal2arch 1.1 - Create Arch Linux packages from Cabal packages.  http://hackage.haskell.org/package/cabal2arch-1.1 (PeterSimons)
04:40:39 <jonkri> ok, but i never said you can't do sequential programming without monads, i just said monads is a framework to do it
04:41:10 <shachaf> Grr.
04:41:31 <jonkri> i get that monads are more though
04:41:55 <shachaf> foo :: a -> f a; bar :: f (f a) -> f a; baz :: (a -> b) -> f a -> f b
04:42:06 <shachaf> Along with a couple of laws.
04:42:16 <shachaf> What do those functions have to do with "sequential programming"?
04:42:19 <osfameron> I hadn't realised that on of the main things putting IO in a monad does is to *thread* sequentiality through it by having a strict operation (like a case statement) as the 'bind' operation
04:42:45 <quicksilver> osfameron: strict is not the word you are looking for.
04:42:47 <osfameron> i.e. the monad framework itself doesn't impose sequentiality, merely permits it to be nicely encapsulated
04:42:50 <shachaf> What do you mean by "thread"? This doesn't have much to do with strictness.
04:42:56 <quicksilver> osfameron: monads sequence effects, they do not sequence computation.
04:43:01 <quicksilver> computation is demand-driven.
04:43:12 <osfameron> quicksilver: perhaps I've misunderstood the article I thought I understood then ;-)
04:43:12 <quicksilver> (but often, especially in IO, the effect does indeed demand)
04:43:59 <quicksilver> return (error "doesn't happen") >> putStrLn "Hi there"
04:44:09 <quicksilver> is an example to show that IO doesn't sequence evaluation
04:44:32 <osfameron> quicksilver: I'm thinking of what I understood of http://blog.ezyang.com/2011/05/unraveling-the-mystery-of-the-io-monad/
04:44:39 <fosskers> hey guys
04:44:45 <fosskers> having some more type issues :(
04:44:50 <osfameron> which suggested that the IO monad makes state strict, by making it use a case statement in the bind
04:45:10 <fosskers> http://hpaste.org/46526/int_to_list__type_issues
04:45:15 <osfameron> perhaps I didn't understand it all that well though
04:45:46 <quicksilver> ezyang is a smart guy, but my opinion is that's a terrible way to try to explain.
04:45:49 <quicksilver> State# isn't haskell.
04:45:52 <quicksilver> the IO monad isn't really that.
04:46:03 <quicksilver> that's just the GHC implementation - and it depends on some very specific properties of GHC
04:46:23 <quicksilver> GHC, essentially, is tuned to compile this non-really-haskell stuff in the way that does the right thing
04:46:35 <quicksilver> but it's a false analogy and using it to gain insight about IO is not easy.
04:46:50 <Botje> fosskers: sounds like you need strategic placement of fromIntegral
04:46:52 <Botje> :t fromIntegral
04:46:53 <lambdabot> forall a b. (Integral a, Num b) => a -> b
04:47:03 <fosskers> again, eh? he's been my enemy for a while now
04:47:11 <fosskers> curse you, fromIntegral...
04:47:32 <shachaf> data OneIOAction = PutStrLn String | Exit Int; type IO = [OneIOAction]; thisThenThat :: IO -> IO -> IO; thisThenThat a b = a ++ b; putStrLn :: String -> IO; putStrLn foo = [PutStrLn foo]; exit :: Int -> IO; exit i = [Exit i]
04:47:35 <osfameron> quicksilver: does it give an insight into Monads though? (i.e. that they don't impose sequencing, but can facilitate it) ?
04:47:41 <shachaf> Poof, there's a simple output-only IO framework for you.
04:47:43 <fosskers> he said some underhanded things about my sister. understand my reluctance in working with him
04:48:06 <quicksilver> osfameron: if you understand it all correctly I daresay there is insight to be had :)
04:48:24 <osfameron> I guess the trick is just to not understand it incorrectly ;-)
04:48:46 <Botje> fosskers: for example, putting a call to fromIntegral inside the [..] would allow you to change the output type to [Int8]
04:49:08 <quicksilver> osfameron: under the hood GHC is actually in impure language.
04:49:27 <fosskers> Botje: you mean... say in line 6?
04:49:33 <shachaf> jonkri: By the way, you know that functions "are monads", right?
04:49:34 <fosskers> or 12 13?
04:49:45 <osfameron> quicksilver: that's a given, surely (unless you're compiling down to a lambda-calculus architecture, I supposE)
04:49:49 <quicksilver> osfameron: in that under-the-hood language, there is something you can do to an IO action makes it happen. You can 'perform the side effects'.
04:50:02 <jonkri> shachaf, no, i thought that types were monads, and that functions operated in monads
04:50:05 <Botje> fosskers: 13, actually
04:50:13 <shachaf> jonkri: Fine, the type (r ->) is a monad.
04:50:23 <quicksilver> osfameron: in a sense, yes. But the confusing part is the GHC has this langauge that looks very much like haskell, but is impure
04:50:36 <fosskers> [fromIntegral(n `mod` 10)]
04:50:37 <fosskers> ?
04:50:40 <quicksilver> osfameron: and it permits you to work with it as if it was haskell (hence unsafePerformIO)
04:50:44 <Botje> yeah
04:50:50 <quicksilver> osfameron: which is useful, but can be the source of confusion.
04:50:55 <Botje> or [ fromIntegral $ n `mod` 10 ] (iirc)
04:51:02 <osfameron> quicksilver: confusion?! in haskell?! oh noes!
04:51:02 <fosskers> Botje: and why will that solve the problem?
04:51:17 <quicksilver> :)
04:51:27 <Botje> fosskers: you want itol to return a [Int8], right?
04:51:33 <fosskers> Botje: i do
04:51:54 <Botje> well, n`mod` 10 will still be the same type as n (something Integral)
04:52:13 <Botje> but if you use fromIntegral, you can decide which type the resulting list will have
04:52:28 <Botje> > fromIntegral (15 :: Integral) :: Int8
04:52:29 <lambdabot>   Class `GHC.Real.Integral' used as a type
04:52:35 <Botje> > fromIntegral (15 :: Integer) :: Int8
04:52:36 <lambdabot>   15
04:53:03 <fosskers> and having [Int8] in the return type is enough to force the type change?
04:53:09 <fosskers> without adding :: Int8?
04:53:22 <Botje> yes
04:53:33 <Botje> because having your result type be [Int8] forces the elements to be of type Int8
04:53:42 <Botje> so fromIntegral can figure it out because of the constraints you impose
04:54:07 <jonkri> how would you define an effect?
04:54:53 <quicksilver> jonkri: only by example.
04:54:59 <fosskers> Botje: okay, i did some fiddling in ghci and i think i get it
04:55:27 <Botje> cool
04:56:11 <fosskers> thanks
04:56:13 <fosskers> time to tinker
04:57:32 <fosskers> hurray!
04:57:33 <fosskers> success
04:58:56 <fosskers> Botje: what about the ltoi part?
04:59:03 <Botje> :t chr
04:59:04 <lambdabot> Int -> Char
04:59:04 <fosskers> that's still exploding for me
04:59:16 <Botje> lucky for you, Int is also an Integral
04:59:21 <fosskers> righ
04:59:22 <fosskers> t
04:59:27 <Botje> so you can do fromInteger (n + 48)
04:59:31 <Botje> err
04:59:33 <Botje> fromIntegral
04:59:44 <Botje> in itoc
05:00:12 <fosskers> without chr?
05:00:15 <Botje> although it's probably nicer to work with the digits again
05:00:22 <fosskers> yeah?
05:00:29 <fosskers> i figured using read would be sneakier
05:01:04 <Botje> > foldl (\a b -> a * 10 + b) 0 [1,2,3,4,5]
05:01:05 <lambdabot>   12345
05:01:17 <Botje> or, in your case
05:01:18 <jonkri> would it be correct to say that the typical use cases of the "monads" IO, Maybe, State, Reader, Writer are all sequential?
05:01:24 <Botje> > foldl (\a b -> a * 10 + fromIntegral b) 0 [1,2,3,4,5]
05:01:25 <lambdabot>   12345
05:01:26 <sipa> @pl \a b -> a * 10 + b
05:01:27 <lambdabot> (+) . (10 *)
05:01:29 <fosskers> oh jeez im an idiot
05:01:31 <fosskers> folds. duh
05:01:47 <Botje> the read thing is okay too, though
05:01:49 <sipa> > foldl ((+) . (10*)) 0 [1,2,3,4,5]
05:01:50 <shachaf> jonkri: No. "sequential" is misleading. And especially when you're talking about monad tutorials.
05:01:51 <lambdabot>   12345
05:01:55 <Botje> but this way is a bit more symmetrical with your itol
05:02:25 <jonkri> shachaf, i'm going to talk about how monads are so much more, but i think this aspect of monad usage might be relevant
05:02:44 <shachaf> It's not "so much more", it's "so much different"!
05:02:49 <shachaf> I propose you don't even use the word "monad".
05:02:57 <shachaf> Just talk about individual instances.
05:03:02 <shachaf> As quicksilver said, by example.
05:03:11 <shachaf> Later you can pull the magic type class out of your sleeve.
05:05:59 <quicksilver> typical uses of state and reader don't strike me as having a sequential feel
05:06:06 <quicksilver> writer and IO do
05:06:13 <quicksilver> list and maybe don't, to me.
05:06:25 <quicksilver> we talk of 'sequencing' effects but the sense of 'sequence' varies per effect
05:06:35 <quicksilver> it's a convenient verb, not a definition.
05:06:57 <jonkri> ok
05:07:10 <jonkri> i still don't understand monads at all
05:07:11 <fosskers> its working... but an Int8 seems to be holding more than 8bytes should allow
05:07:13 <jonkri> obviously
05:07:18 <jonkri> thanks for stopping me :P
05:09:11 <fosskers> if I only want a single type definition from a library and nothing else, how should my import statement look like?
05:10:48 <quicksilver> import Module(foo)
05:10:53 <quicksilver> to import just 'foo' from Module
05:11:05 <quicksilver> slightly more complex for types + constructors.
05:12:12 <fosskers> yeah, im looking to just import a single type from a library
05:12:58 <quicksilver> import Module(Type(..))
05:13:03 <quicksilver> gets you the Type and all its constructors
05:13:14 <quicksilver> import Module(Type()) gets you just the type and none of its constructores.
05:16:49 <Baughn> poucet: Oh, hi.
05:16:57 <poucet> Hi :)
05:17:32 <fosskers> awesome quicksilver, thanks
05:19:09 <Botje> > (minBound, maxBound) :: (Int8, Int8)
05:19:10 <lambdabot>   (-128,127)
05:19:21 <Botje> fosskers: looks okay to me
05:19:36 <fosskers> well Botje
05:20:11 <josip> Hello, someone recommended the "The Complete Haskell" book, but I can't find it using google, I guess I miss some terms
05:20:14 <josip> can anyone help ?
05:20:34 <Botje> josip: i've never heard of such a thing
05:20:44 <fosskers> *Main Data.Char> :t itol 10
05:20:44 <fosskers> itol 10 :: [GHC.Int.Int8]
05:20:45 <fosskers> *Main Data.Char> :t ltoi $ itol 123456789098765432
05:20:45 <fosskers> ltoi $ itol 123456789098765432 :: GHC.Int.Int8
05:20:54 <josip> it was recommended on hackernews
05:21:16 <josip> okay, maybe someone was misinformed. "An encyclopedic work that spans the full range from category theory to network programming, everyday scripting, and distributed systems."
05:21:29 <quicksilver> sounds like someone was joking
05:21:34 <fosskers> better yet
05:21:35 <fosskers> *Main Data.Char> let x = ltoi $ itol 12351231251234124123
05:21:36 <fosskers> *Main Data.Char> :t x
05:21:36 <fosskers> x :: GHC.Int.Int8
05:21:47 <josip> can you suggest a book that discusses also category theory, not only the language itself?
05:22:08 <Botje> fosskers: and what's the value of x ?
05:22:17 <Baughn> josip: To make sure: You don't need to understand category theory at all to use Haskell. Are you sure you want to learn it?
05:22:21 <fosskers> oh... shit
05:22:22 <fosskers> 91
05:22:25 <Botje> :)
05:22:25 <Baughn> josip: It can clarify some of the decisions, admittedly.
05:22:27 <josip> Baughn: yes
05:22:35 <fosskers> sorry Botje ^^
05:22:42 <fosskers> so yeah, that means
05:22:43 <Botje> no problem :)
05:22:48 <fosskers> i need ltoi to be pumping out Integers
05:22:53 <fosskers> not Int8's
05:22:55 <Botje> fosskers: what's your type for ltoi atm?
05:23:05 <fosskers> ltoi :: Integral a => [a] -> a
05:23:11 <Botje> that's no good
05:23:12 <fosskers> attempts at fildling with that exploded
05:23:20 <josip> I am interested. I think I have some level of mathematical maturity, so it shouldn't be really terrible
05:23:23 <Botje> make it Integral a => [Int8] -> a
05:23:41 <fosskers> exploded
05:24:05 <fosskers> big ugly-ass error
05:24:23 <Botje> can you update your hpaste with code and the error?
05:25:24 <fosskers> sure
05:26:03 * hackagebot archlinux 1.2 - Support for working with Arch Linux packages.  http://hackage.haskell.org/package/archlinux-1.2 (PeterSimons)
05:26:09 <aleator> Heh. eval :: (Num a) => Env -> Expr -> a gets interesting when Expr is instance of Num :)
05:27:08 <fosskers> Botje: i added an annotation to the original post
05:27:17 <fosskers> http://hpaste.org/paste/46526/int_to_list__type_issues_an#p46528
05:29:45 <jonkri> quicksilver, how is the maybe and list monads not sequential, for you?
05:30:31 <jonkri> do they not operate on a Maybe or list value, applying functions on its content at every step?
05:30:58 <hammar> I'm trying to do a GHC dry run just to generate warnings and errors. I try "ghc -n Hello.hs", but this gives me "Hello.o: getFileStatus: does not exist"
05:31:21 <hammar> am I using the option wrong or is something else going on?
05:39:09 <erus_> jonkri: how do i make my 'type' derived from Eq?
05:39:33 <sipa> write 'deriving Eq' after its definition
05:39:33 <mauke> you can't derive types from classes
05:39:44 <mauke> you can derive instances from types, though
05:41:00 <erus_> data Rank = Win | Draw | Lose
05:41:07 <erus_> i need to check for equality also
05:41:30 <mauke> data Rank = Win | Draw | Lose deriving (Read, Show, Eq, Ord, Enum, Bounded)
05:42:54 <erus_> it should derive from those automagicaly imho
05:43:16 <mauke> overruled
05:43:30 <hpc> it might automagically provide an incorrect implementation
05:43:41 <mauke> I'm pro-choice
05:43:47 <hpc> or perhaps you don't want people to be able to read or show your stuff at all
05:43:56 <erus_> mauke: your going straight to hell buddy
05:44:01 <hpc> or you want it in a separate module
05:44:05 <mauke> what about my going?
05:44:14 <zygoloid> :)
05:44:30 <erus_> foiled again
05:44:39 <erus_> damn athiests with their high IQs
05:44:49 <mauke> did you mean: atheists
05:45:25 <hpc> perhaps he meant agnostics?
05:46:17 <erus_> gnostic thiest
05:47:35 <mauke> gnomic tourist
05:47:48 <erus_> can i do a case with mutliple thingys?
05:47:51 <hpc> Gnome Chompsky?
05:47:56 <erus_> like case x, y of blah
05:48:10 <mauke> case (x, y)
05:49:52 <erus_> what's the name of the default case? is it just _ ?
05:49:54 <hpc> case (x,y) of (5, False) -> blahblah
05:50:04 <mauke> erus_: yes
05:50:20 <hpc> though it's technically a wildcard
05:50:23 <erus_> does it have to be (_, _) ?
05:50:27 <hpc> there's no "default case"
05:50:31 <dino-> I have a project on Hackage that's been rolled into another one. I've seen things there that are marked obsolete with a note on using the new things. How does one get something marked like this?
05:50:33 <mauke> erus_: no
05:51:05 <hpc> > case (1, 2) of (_, _) -> "Yay!"
05:51:06 <lambdabot>   "Yay!"
05:51:11 <hpc> > case undefined of (_, _) -> "Yay!"
05:51:11 <lambdabot>   "*Exception: Prelude.undefined
05:51:16 <hpc> > case undefined of _ -> "Yay!"
05:51:16 <lambdabot>   "Yay!"
05:51:35 <hpc> ^ a brief demonstration of the difference
05:51:51 <erus_> thanks guys
05:52:33 <Phyx-> here comes the boom
05:52:43 <hpc> boom!
05:52:48 <Phyx-> eek
05:52:53 <hpc> :P
05:53:00 <Phyx-> lol
05:53:07 <ion> > case undefined of ~(_, _) -> "plop"
05:53:08 <lambdabot>   "plop"
05:53:25 <Phyx-> almost done with the upgrades to my tool, after that, it's back to coding on visual haskell, finally
05:53:28 <ion> > case undefined of ~(a, _) -> show a
05:53:29 <hpc> > case undefined of (x, _) -> x
05:53:29 <lambdabot>   "*Exception: Prelude.undefined
05:53:29 <lambdabot>   *Exception: Prelude.undefined
05:55:57 <Phyx-> what is ~ again? I keep forgetting
05:56:44 <erus_> can someone help me with pseudo random Ints please: http://hpaste.org/46529/random
05:56:47 <nlogax> irrefutable pattern
05:56:59 <fosskers> Botje: ?
05:57:20 <mauke> :t randomRIO (0, 2)
05:57:20 <lambdabot> forall t. (Num t, Random t) => IO t
05:58:01 <erus_> perfect thanks
05:58:25 <mauke> randomRIO (Rock, Scissors)
05:58:58 <mauke> erus_: handFromInt is basically toEnum
05:59:35 <hpc> handString is map lowerCase . show
05:59:56 <hammar> The ghc -n option gives me an error in getFileStatus (7.0.2, built from source). Works fine in 6.12.1. Can anyone confirm?
05:59:57 <hpc> compareHand is basically compare
06:00:43 <erus_> hpc: hand from string
06:00:53 <erus_> is there titleCase or eqv.?
06:01:33 <hpc> you could do "instance Read Hand where read "rock" = Rock ..."
06:01:44 <hpc> "instance Show Hand where show Hand = "hand"..."
06:02:06 <hpc> i don't think there's an existing function for title case
06:02:18 <hpc> at least, not in the base modules
06:04:59 <erus_> @hoogle lowerCase
06:04:59 <lambdabot> Data.Char LowercaseLetter :: GeneralCategory
06:05:00 <hammar> > 1+1
06:05:00 <lambdabot>   2
06:06:58 <erus_> hpc: i cant get that to work (map lowerCase . show)
06:07:10 <erus_> lowerCase not in scope
06:07:21 <hammar> > map toLower "Hello"
06:07:22 <lambdabot>   "hello"
06:07:47 <hammar> @hoogle toLower
06:07:47 <lambdabot> Data.Char toLower :: Char -> Char
06:09:18 <erus_> also what was the thing with compare?
06:09:37 <mauke> that's what deriving Ord gives you
06:10:06 <erus_> rock paper scissors isnt ordered though
06:10:12 <erus_> its circular
06:10:30 <mauke> now that I use my brain for thinking, you're right of course
06:14:39 <hammar> can anyone see what I'm typing?
06:14:51 <erus_> nope
06:14:58 <hpc> what who is typing? :P
06:15:12 <hammar> :)
06:16:02 <hpc> hammar: "The ghc -n option gives me an error in getFileStatus..." <- could you tell us what you are trying to compile?
06:16:15 <Feuerbach> Why do iteratees operate on chunks rather than on individual tokens? Is it for some performance reasons? Operating on individual tokens seems cleaner
06:16:35 <hammar> hpc: main = putStrLn "Hello"
06:16:43 <hpc> oh lol
06:17:19 <hpc> yeah, whatever that error is from, it will definitely be beyond my ability to debug
06:17:43 <mm_freak_> Feuerbach: performance…  imagine a Char iteratee, which would need a round-trip between enumerator and iteratee for every single character
06:17:45 <poucet> Feuerbach: most IO is more efficient with chunks, and there's less memory overhead with fhunks
06:17:56 <poucet> s/fhunks/chunks
06:18:20 <hammar> hpc: just trying to determine if it's ghc or my setup
06:20:05 <Feuerbach> mm_freak_: poucet: that is just API, right? Nothing prevents Enumerator from doing buffered reads but exposing the stream char-by-char
06:20:28 <mm_freak_> Feuerbach: exactly
06:20:51 <mm_freak_> hence in enumList you have a chunk size
06:31:55 <Tordek> I'm calling maximum over a really big list (2^1000 big); it seems to be acting dumb (which I bet is related to my not knowing how to use haskell): it's filling up all of my ram.
06:32:11 <hpc> @src maximum
06:32:11 <lambdabot> maximum [] = undefined
06:32:11 <lambdabot> maximum xs = foldl1 max xs
06:32:22 <hpc> :t foldr1
06:32:23 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:32:25 <hpc> :t foldl1
06:32:26 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:33:08 <hpc> use foldr1 max xs
06:33:12 <Lemmih> Tordek: Did you compile with optimizations enabled?
06:33:17 <hpc> perhaps
06:33:27 <Tordek> Lemmih: yes
06:34:28 <Lemmih> Tordek: Does "foldl1' max" behave better?
06:34:44 <hpc> :t foldl1;
06:34:45 <lambdabot> parse error on input `;'
06:34:46 <hpc> :t foldl1'
06:34:47 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:36:10 <webchat77> @src foldl
06:36:11 <lambdabot> foldl f z []     = z
06:36:11 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:38:40 <Tordek> (running on ghci) doesn't fare any better
06:38:56 <Tordek> foldl1' max . map sum . powerset $ [1..100]
06:39:47 <Tordek> powerset = filterM (const [True, False]) fwiw, but it does work lazily
06:41:04 <hpc> :t filterM
06:41:05 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:43:14 <Lemmih> Tordek: Your problem is not "maximum". You just generate a /lot/ of data.
06:43:46 <Lemmih> Tordek: Try with 'length' instead of 'maximum' and you'll see the same behavior.
06:44:02 <hpc> > 2 ^ 1000
06:44:03 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
06:44:13 <hpc> > 2 ^ 64
06:44:14 <lambdabot>   18446744073709551616
06:44:17 <hpc> O.O
06:44:18 <Tordek> Lemmih: but tht should be irrelevant. at any step, I have at most 100 elements; "maximum" should only need to compare 2 elements at once, and once compared it can discard them
06:44:32 <shachaf> Tordek: You might be keeping a reference to the head of the list around.
06:48:16 <quicksilver> Tordek: try it with length, like Lemmih said.
06:48:35 <quicksilver> Tordek: and observe - length doesn't even need two elements of the list to be around,
06:48:40 <quicksilver> it needs none - it just counts the spine.
06:48:55 <quicksilver> the problem is in the way your powerset generates its lists.
06:48:56 <Lemmih> Tordek: Your powerset definition is problematic.
06:50:21 <Lemmih> Tordek: This is related to your problem: http://www.haskell.org/pipermail/haskell-cafe/2003-June/004484.html
06:51:31 <Tordek> hmm, okay
06:52:41 <Tordek> then this gives me a new problem. What I need, precisely, is all the ways to split a set in 2. So I used zip (filterM (const [True, False]) x) (filterM (const [False, True]) x)
06:56:46 <aleator> Could someone help me with rankNtypes? http://hpaste.org/46531/how_the_bleep_do_i_type_this
07:02:05 <Lemmih> aleator: Try stating the problem in a way that doesn't assume familiarity with Numeric.AD.
07:03:02 <ClaudiusMaximus> aleator: maybe try "lift"
07:04:42 <frege> hello
07:04:48 <aleator> Lemmih: Well.. If I'd have a clue what is going on then.. The point seems to be that grad (\x -> foo <constant expression>) works, byt \e -> grad (\x -> foo e)  does not.
07:05:24 <ClaudiusMaximus> aleator: http://hackage.haskell.org/packages/archive/ad/latest/doc/html/Numeric-AD-Internal-Classes.html#v:lift
07:05:58 <aleator> AD seems to do similar trick as ST and use a s variable to avoid mixing stuff and that gets over aggressive
07:06:59 <aleator> ClaudiusMaximus: I'm not sure how to use lift here. It lifts a constant to ad but what is the constant I want to lift?
07:08:09 <ClaudiusMaximus> aleator: not sure - probably 'e'; here's an example in my code https://gitorious.org/maximus/emndl/blobs/master/MuAtom.hs
07:09:21 <ClaudiusMaximus> i'd try   \e -> grad (\x -> foo (lift e))   but i don't know if it'll work
07:09:26 <Saizan> aleator: what's the type of eval?
07:09:45 <aleator> Saizan: eval :: Floating a => [(String, a)] -> Expr a -> a
07:10:56 <aleator> ClaudiusMaximus: Ah. Now I see what you meant. The problem is that my foo doesn't work with lifted values (see the paste for the actual code)
07:11:28 <aleator> I think I had pretty similar problem with ST..
07:15:59 <ClaudiusMaximus> aleator: hm, not sure how to solve this - i've not done that much with 'ad'
07:16:01 <Saizan> aleator: i don't think the 's' is the problem here
07:16:12 <Saizan> aleator: is your Expr an instance of Num?
07:16:39 <aleator> Saizan: Yes.
07:20:27 <Saizan> aleator: i think that in your working example you're using eval :: Floating a => [(String, Expr a)] -> Expr (Expr a) -> Expr a
07:21:46 <aleator> Saizan: Hmm.. You might be right..
07:27:19 <Saizan> mh, no there mist be an AD there
07:27:50 <aleator> Saizan: Yeah the first Expr (Expr a) must be AD s (Expr a) I think.
07:28:07 <aleator> I put this up at stackoverflow if you want virtual beanies there :)
07:32:39 <Saizan> aleator: try calcGrad expr = grad (\vs -> df (fmap lift expr) vs) vars
07:32:51 <Saizan> aleator: assuming your Expr is an instance of Functor
07:33:14 <aleator> Saizan: Well, I can make it so I guess.
07:33:16 <aleator> Let me try
07:34:11 <Saizan> the type error was indeed caused by 's' in the end
07:40:04 <aleator> Saizan: You have now acquired a free beer.  Thanks again!
07:41:25 <Saizan> an expression like "(EVar "x"*2+sin(EVar "y"))" is polymorphic on the 'a', so it matches anything, but once you take that expression as an argument it can't have 's' in its type, but there's lift which can be used with the type  (Mode s, Num a) => a -> AD s a
07:41:39 <Saizan> aleator: great, hoping it also does the right thing :)
07:43:31 <aleator> Saizan: Well, I think it does. However, it is just the tip of the rope I'm trying to hang myself with.
07:44:01 <aleator> Rest consists of a parser reading expressions and an llvm compiler compiling them with the gradient calculating code + optimization.
07:50:09 <Saizan> hah, funny, getting back the symbolic differentiation out of the automatic one
07:51:07 <aleator> Saizan: Arguably, might have been easier to just write the symbolical version myself..
07:51:24 * hackagebot semigroupoids 1.2.2 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.2 (EdwardKmett)
07:51:27 * hackagebot bifunctors 0.1.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.1 (EdwardKmett)
07:52:25 * hackagebot happstack-server 6.1.0 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.1.0 (JeremyShaw)
07:52:47 <Saizan> aleator: but at the end of this you'll learn RankNTypes! :)
07:53:27 * hackagebot semigroupoid-extras 0.2.4 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.4 (EdwardKmett)
07:53:29 * hackagebot keys 0.2.6 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.2.6 (EdwardKmett)
07:53:31 * hackagebot pointed 0.1.3 - Haskell 98 Pointed and copointed data  http://hackage.haskell.org/package/pointed-0.1.3 (EdwardKmett)
07:53:43 <Eduard_Munteanu> Oh is that possible?
07:53:54 <Saizan> what?
07:54:04 <Eduard_Munteanu> Have 'ad' do symbolic diff.
07:54:25 * hackagebot comonad-transformers 1.6.3 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.6.3 (EdwardKmett)
07:54:27 * hackagebot comonads-fd 1.6.3 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-1.6.3 (EdwardKmett)
07:54:39 <edwardk> ad is better than symbolic
07:54:58 <edwardk> and yes. you can use it with traced
07:55:11 <Saizan> @hackage traced
07:55:11 <lambdabot> http://hackage.haskell.org/package/traced
07:55:58 <edwardk> which shows the (unsimplified) operations
07:56:15 <Eduard_Munteanu> Neat. At some point I thought 'ad' was symbolic diff, but then somebody corrected and I thought it couldn't do symbolic diff. :)
07:58:05 <Saizan> edwardk: ad is better than symbolic diff for all the usual reasons why a shallow embedding is better than a deep one, or is there more?
07:58:25 * hackagebot representable-functors 0.4.3 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.4.3 (EdwardKmett)
07:58:27 * hackagebot adjunctions 0.9.3 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.9.3 (EdwardKmett)
07:58:55 <edwardk> asymptotics. if you compute a symbolic derivative of something like x * e^x, it can be bigger or require more steps to evaluate than the original function. the symbolic derivative is just a constant times more work than the original
07:59:04 <ezyang> Is it accurate to say a CAF has no free variables.
07:59:07 <edwardk> er the automatic derivative is just
08:00:25 * hackagebot representable-tries 0.3.6 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.3.6 (EdwardKmett)
08:00:56 <edwardk> ezyang: sounds reasonable
08:01:14 <ezyang> Cool.
08:01:48 <dino-> Anybody know how you get something marked as "Obsoleted" on Hackage?
08:02:00 <edwardk> dino-: beg duncan or one of the cabal folks
08:02:09 <ezyang> Hmm, I wonder if CAFs get shared.
08:02:26 * hackagebot ad 1.0.6 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.0.6 (EdwardKmett)
08:02:45 <edwardk> they do
08:02:54 <edwardk> this is both a blessing and a curse
08:03:04 <ezyang> Ahhhh. OK.
08:03:17 <dcoutts> dino-: at the moment it's a manual process involving emailing Ross, in future the web ui will let maintainers do it
08:03:26 * hackagebot streams 0.7.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.7.1 (EdwardKmett)
08:03:26 <edwardk> since a dangling reference to one will keep it alive, regardless of its size
08:03:31 <edwardk> on the other hand it can save you a lot of rework
08:04:28 * hackagebot kan-extensions 0.2.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-0.2.1 (EdwardKmett)
08:08:04 <edwardk> i sometimes miss the days of having most of this in a single package
08:08:26 * hackagebot comonad-extras 0.2.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.2.1 (EdwardKmett)
08:12:20 <argiopeweb> Does anyone know the overhead difference (relative/exact/guestimate are all fine) between Haskell and Erlang threads off the top of their heads?
08:12:27 * hackagebot eq 0.3.3 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.3 (EdwardKmett)
08:13:20 <edwardk> they are pretty similar.
08:14:13 <edwardk> both are really cheap. the erlang ones usually have more interpretation overhead and the message passing model mucks with cost comparisons. also gc is different, haskell stops the world. erlang stops a process. and erlang manages memory for each separately, so if you have a lot of 'shared' data the erlang ones can be expensive
08:14:47 <edwardk> for for thread rings, etc. they are practically interchangeable
08:14:53 <edwardk> er but for
08:15:27 * hackagebot syb-extras 0.2.1 - Higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.2.1 (EdwardKmett)
08:15:36 <argiopeweb> edwardk: So I'm guessing the HIPE version drops the interpretation overhead and picks up a bit more speed?
08:16:07 <edwardk> yeah
08:16:19 <edwardk> the gc done by erlang is more efficient as well
08:16:42 <edwardk> since it runs a single pass compacting collector, which is downright unique
08:16:49 <argiopeweb> I would imagine, simply based on the simpler type system if nothing else.
08:17:02 <argiopeweb> Whoa, single pass compacting? I've got to look that up...
08:17:07 <edwardk> nah, its based on strictness and purity
08:17:18 <edwardk> it can always ensure that pointers always point 'down' heap
08:17:30 <argiopeweb> Ah, cool.
08:17:52 <edwardk> and it can get away with no read barrier and no write barrier because each process is isolated and can be stopped separately
08:18:24 <argiopeweb> True. Part barely affects the whole, given a large enough number of processes.
08:18:28 * hackagebot free 0.2.1 - Haskell 98 monads for free  http://hackage.haskell.org/package/free-0.2.1 (EdwardKmett)
08:19:45 <Younder> argiopeweb, that sounds terribly wrong
08:20:21 <argiopeweb> I imagine the GC model also partly stemmed from where they were coming from. Temporary interruption for a major GC isn't too big of a deal most of the time (graphics applications being a big exception as discussed yesterday), whereas any downtime on a telecomm system is bad.
08:20:26 <argiopeweb> Younder: How so?
08:21:03 <edwardk> argiopeweb: as a former telecom guy, thats pretty accurate ;)
08:21:08 <Younder> Only if your problem is trivially parallisable
08:21:54 <argiopeweb> Younder: If I start 50000 threads to do a calculation and assemble a result based on the returns, minor delays in any individual thread matter very little to the end result, no?
08:21:58 <edwardk> Younder: it mostly favors problem decomposition. you delegate and fan out your services as much as possible. its tricky, sometimes you have choke points, etc. but its a pretty solid model
08:22:29 * hackagebot reactor 0.1.3 - Reactor - task parallel reactive programming  http://hackage.haskell.org/package/reactor-0.1.3 (EdwardKmett)
08:22:54 <Younder> edwardk, Depends on those choke points. Hard to say anything in general here. Except watch out..
08:22:55 <int-e> edwardk: oh come on. sure//y no//dy would noti/    /wntime of just a couple of dozen milliseconds. :)
08:23:07 <jaspervdj> edwardk: Hey, we're meeting on skype 2h30 from now, right? I'm going to list some stuff I want to discuss somewhere.
08:23:23 <edwardk> jaspervdj:  sounds good to me
08:23:37 <argiopeweb> int-e: hehe...
08:23:53 <edwardk> jaspervdj: send me a username or whatever to contact
08:24:05 <edwardk> int-e:  =)
08:24:30 * hackagebot regex-posix 0.95.0 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-posix-0.95.0 (ChrisKuklewicz)
08:28:21 <Younder> Oh and 'The art of multiprocessor programming' is a good starting point
08:28:42 <jaspervdj> edwardk: I'm jaspervdj on skype, but I'm currently offline
08:28:46 <edwardk>  kk
08:29:32 <edwardk> brb
08:32:40 <k0ral> is there always a way to avoid using states in an elegant way ?
08:33:24 <argiopeweb> k0ral: Always is a big word.
08:34:21 <k0ral> argiopeweb: only 6 letters though :)
08:34:35 <argiopeweb> And even if you change it to "generally", I would have to say no. There are some times when you legitimately need to keep state around.
08:34:44 <argiopeweb> k0ral: Oi, no nitpicking. ;)
08:35:06 <argiopeweb> Hence the State monad, your friend and mine.
08:35:07 <k0ral> so that drives me to the next question
08:35:34 <k0ral> where should I use IORef and where should I use the State monad ?
08:35:50 <JigBoot> Are there any Negro Haskell developers?
08:36:27 <argiopeweb> k0ral: I can't say that I have the experience required to answer that question accurately.
08:36:38 <edwardk> mauke: ?
08:36:56 <k0ral> argiopeweb: well, don't say it then :)
08:37:20 <k0ral> argiopeweb: I can say I have no experience at all
08:37:24 <quicksilver> k0ral: generally State is more pleasant
08:37:32 <quicksilver> if you have a terrible mess of IO callbacks
08:37:36 <quicksilver> especially some via FFI calls
08:37:37 <argiopeweb> k0ral: I now the theory, I just don't know the particular Haskell implementation. ;)
08:37:42 <quicksilver> then IORef may be a simple way to cut through that.
08:37:56 <argiopeweb> Specifically IORef, since I've never used it. State is pretty straight forward.
08:38:12 <JigBoot> are there any Negro Haskell developers?
08:38:24 <JigBoot> Is there any diversity or affirmative action program for them?
08:38:28 <k0ral> so next step: learn how to use State monad
08:38:31 <erus_> jewish haskell union
08:38:48 <k0ral> In case you have good links not already mentioned in the wiki, just drop them :)
08:38:50 --- mode: ChanServ set +o quicksilver
08:38:53 --- mode: quicksilver set +b *!*451dd617@*.69.29.214.23
08:38:53 --- kick: JigBoot was kicked by quicksilver (troll elsewhere)
08:38:58 <quicksilver> sorry, I wasn't identified.
08:39:18 <erus_> monads are unpure
08:39:22 <erus_> so is IO
08:39:31 <quicksilver> monads are not impure, erus_
08:39:42 <argiopeweb> erus_: No spreading of mis-information now.
08:39:45 <KirinDave> quicksilver: Thank you.
08:39:50 <erus_> :D
08:40:06 <Younder> Category theoretic unpure is inexact
08:40:28 <osfameron> that was an odd troll
08:41:17 <Younder> No curry for him ;)
08:41:36 <erus_> He raises a valid point thought
08:41:42 <erus_> not only haskell
08:42:01 <erus_> but software developers in general are usualy white or indian
08:42:55 <osfameron> oh, "unpure" is a technical term?
08:43:26 <KirinDave> Is unpure even a well-formed word?
08:43:33 <Younder> osfameron, sort of. It relates to functions with side effects
08:43:45 <quicksilver> osfameron: the word is normally impure, and yes, it's quite precise.
08:44:04 <quicksilver> osfameron: a "pure function" (a -> b) is a mathematical function - so it must always give the same b for the same a
08:44:11 <KirinDave> I'm kinda amazed how many people haven't heard about pure vs. impure functions.
08:44:13 <osfameron> ok, I know "impure", I was wondering whether "unpure" was a specfiic coinage that meant something different ;-)
08:44:15 <quicksilver> osfameron: and have no observable side effect
08:44:32 <osfameron> sure. pure == referentially transparent ?
08:44:46 <Younder> now you got it
08:44:46 <erus_> osfameron: it's the bastardized american version
08:44:52 <KirinDave> I just had to educate Ryan Dahl of node fame a week ago. He was using it to mean "functions that do not block (in the os)"
08:44:59 <quicksilver> the two concepts are not identical, osfameron, but they are closely related.
08:45:06 <KirinDave> Kinda surprising since he's the maintainer/author of a computer language.
08:45:25 <osfameron> ok
08:45:42 <osfameron> the reason I asked if they were different words, is I was wondering if monads were "unpure" (but not "impure") ;-)
08:45:56 <erus_> node.js isnt a programming language. Its just google v8 javascript
08:46:14 <KirinDave> erus_: I'm not sure where "new language" starts.
08:46:39 <KirinDave> erus_: Certainly node is starting to demand a non-stock version of v8. It does not yet have many syntactic extensions, but this coffeescript compiler seems like a likely candidate.
08:47:00 <KirinDave> erus_: I'm comfortable calling it a language or environment or whatever ill-defined word we use for these sorts of concepts. :)
08:47:13 <webchat77> can anyone give an example of the usage of ala?
08:48:55 <Younder> Pure functions don't need to block. That is a SIDE EFFECT of being pure
08:49:09 <shapr> er, hi?
08:49:19 <quicksilver> afternoon shapr
08:49:25 <shapr> Howdy quicksilver, how's code treating you?
08:49:26 <webchat77> > ala Any ($) True
08:49:28 <lambdabot>   True
08:49:30 <Vq> Hello formarn.
08:49:31 <edwardk> heya shapr
08:49:37 <shapr> hej Vq! god morgon!
08:49:39 * hackagebot debian 3.54 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.54 (JeremyShaw)
08:49:43 <shapr> howdy edwardk! I see your code!
08:49:45 <Vq> shapr: evening :)
08:50:11 <dino-> Ross Paterson got back to me about the Obsoleting something on Hackage. So, I'm all set.
08:50:20 <edwardk> Younder: unless the need to wait for a page of memory to swap in ;)
08:50:22 <shapr> dino-: Good deal!
08:50:48 <Younder> edwardk, That's usually dealt with at the CPU level
08:51:03 <shapr> Er, what's the discussion?
08:51:26 <edwardk> shapr: flooding hackage mostly
08:51:35 <shapr> Oh, nice!
08:51:40 * hackagebot regex-posix 0.95.1 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-posix-0.95.1 (ChrisKuklewicz)
08:51:51 <Younder> Agreed it is not truly referentially transparent if you can MEASURE a delay is it..
08:51:59 <edwardk> reduced dependencies in semigroups and semigroupoids, which caused me to bubble a bunch of version numbers up
08:52:20 <shapr> Younder: Er, hi? What do you do with Haskell?
08:52:58 <Younder> shapr, we were discussing the meaning of pure functions
08:53:10 <shapr> Oh, that's cool.
08:53:17 <mauke> "unpure" actually
08:53:46 <shapr> Younder: Do you write Haskell for fun or for work?
08:54:15 <Younder> I am writing a new language as a research project
08:55:32 <shapr> Younder: That's cool, what's the language like? Dependent types maybe?
08:56:07 <Younder> I am particularly interested to see if automated proof of programs can be accomplished with computation category theory with types and relations inherited from topology
08:56:26 <shapr> Huh, you should ask DrSyzygy about that.
08:57:43 <jmcarthur> edwardk: Data.Stream.Infinite exposes group but not groupBy :(
08:57:55 <edwardk> jmcarthur:  doh
08:59:23 <jmcarthur> edwardk: omg you've been releasing updates at an even higher rate than normal
08:59:28 <edwardk> there. don't be sad
08:59:31 <jmcarthur> dependency hell worked out yet?
08:59:43 <jmcarthur> you da man
08:59:43 * hackagebot streams 0.7.2 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.7.2 (EdwardKmett)
08:59:44 <edwardk> that is mostly why. i made some changes way down deep in the hierarchy
08:59:56 <edwardk> semigroups and semigroupoids shed dependencies
09:00:19 <edwardk> that way the 20-30 packages built on top of them wouldn't need to drag in tagged and void and bifunctors, etc.
09:01:22 <jmcarthur> well thanks! updating immediately
09:03:49 * jmcarthur is curious about reactor
09:04:00 <edwardk> reactor is very much a work in progress
09:04:17 <jmcarthur> looks like kind of an event processing sort of thing? maybe concurrent?
09:04:25 <Younder> shapr: The Unseen University (UU) is a school of wizardry in Terry Pratchett's Discworld series of fantasy novels
09:04:29 <jmcarthur> ah yes task parallel
09:04:32 <edwardk> the best reference is to watch the videos on the .net reactive framework on channel 9
09:04:41 <jmcarthur> ah! i remember you talking about this before
09:04:52 <jmcarthur> think i even started watching a vid but i had to stop
09:05:08 <jmcarthur> i'll check it out some time
09:05:11 <edwardk> basically task parallelism + intell tbb but with the reactive framework approach for continuation plumbing
09:05:49 <edwardk> it needs a lot of work but right now serves as sort of a model for a different way to do parallelism
09:06:07 <edwardk> it does provide a nice workstealing deque though
09:07:11 <shapr> Younder: Sticks are sometimes straight.
09:07:58 <shapr> Younder: But I suspect that both of these conversations belong on #haskell-blah rather than #haskell
09:08:24 <shapr> Younder: Unless you're drawing some sort of parallel between uu.nl and uu.discworld? parsing libs perhaps?
09:10:43 <Younder> shapr, True, this is my off time. And I sometimes discuss books fond to me in computer science or maths. So if I am wasting your time please ask me to shut up.
09:11:08 <shapr> Younder: Nah, I'm very fond of Pratchett, but that sort of conversation should be held on #haskell-blah
09:11:55 <Phyx-> wth is uu.discworld?
09:12:45 <conal> another comment on efficiency and denotation http://blog.ezyang.com/2011/05/haskell-not-pure-enough/comment-page-1/#comment-2390
09:13:03 <Younder> shapr, Oh, that was related to your reference to DrSyzygy . I looked at the whois and found a reference to unseen-university.
09:13:17 * shapr points to #haskell-blah
09:13:38 <edwardk> conal: nicely said
09:13:52 <conal> edwardk: thx :)
09:42:33 <damex> hi, i was trying to get independant screens working with xmonad but failed somewhere. i have that config http://paste.pocoo.org/show/385900/ and its not reacting to xmonad --restart / or by keybind now or desktop switch ... what am i done wrong? i was tryed following (and not knowing haskell at'all)  http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Layout-IndependentScreens.html that doc... i was added withScreens 2 on 144 string  and onCurrentScreen
09:42:33 <damex> to 299 and 304 strings. thats all. hope someone can help/explain me how to fix it ... not much help on #gentoo/ru #xmonad and i hoped that i can get help here...
09:42:40 <robertosucks> hello
09:42:46 <robertosucks> Prelude> addVectores (x1,y1) (x2,y2) = (x1+x2,y1+y2)
09:42:47 <robertosucks> <interactive>:1:29: parse error on input `='
09:44:09 <robertosucks> what is wrong?
09:44:45 <djahandarie> robertosucks, are you trying to write a definition that will persist in the ghci session?
09:44:53 <djahandarie> Because you need 'let' at the beggining of the line to do that.
09:45:06 <mauke> robertosucks: that code only works in a file
09:45:10 <jmcarthur> robertosucks: ghci pretends that you're in do notation, essentially
09:45:19 <djahandarie> beginning*
09:46:09 <robertosucks> oh
09:46:12 <robertosucks> thanks
09:49:06 <alexbagel> also he mispellt vectors
10:11:31 <osaunders> Is there a type class for a functor that doesn’t have a type variable?
10:11:49 <Phyx-> uhm.. isn't this Int -> [<something>] ? the pretty printer is printing [<something>] -> Int
10:11:50 <shachaf> osaunders: What do you mean?
10:11:52 <Phyx-> mkCounter x@(Exts.TyList _) = Exts.TyFun (Exts.TyCon $ Exts.UnQual $ Exts.Ident "Int") x
10:11:54 <shachaf> Oh, is this still your XML thing?
10:12:24 <osaunders> shachaf: Kind of yeah, I’m actually trying to do something more complicated than a functor but the questions need to start at the simplest type class
10:12:34 <osaunders> :t fmap
10:12:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:12:50 <shachaf> osaunders: How would that type class work?
10:13:46 <osaunders> So question is: is there a fmap :: Something f => (f -> f) -> f -> f
10:14:04 <Taejo> osaunders: id?
10:14:07 <mauke> is this like uniplate
10:14:26 <shachaf> osaunders: What sort of implementations are you thinking of?
10:14:55 <osaunders> It would just allow you to access the things inside the type
10:15:13 <osaunders> So data Foo = Foo String String
10:15:23 <osaunders> this fmap would allow you to change those strings for other strings
10:16:00 <osaunders> instance UntypedFunctor Foo where fmap f (Foo x y) = Foo (f x) (f y)
10:16:29 <shachaf> But the type of f isn't (Foo -> Foo).
10:16:39 <shachaf> It's (String -> String).
10:16:46 <shachaf> Which is what Functor is usually parameterized on. :-)
10:16:50 <Taejo> osaunders: so when you said fmap :: Something f => (f -> f) -> f -> f --- you meant closer to fmap :: Something f a => (a -> a) -> f -> f
10:17:00 <Taejo> ?
10:17:17 <shachaf> I suppose you could do something like what Taejo suggests.
10:17:21 <osaunders> This is why I need to think about this more
10:17:38 <osaunders> Taejo: Yeah, I think so
10:18:20 <Taejo> osaunders: you need to make a parameter to the class, otherwise, you have to be able to do something with f :: (YouDon'tKnowThisType -> YouDon'tKnowThisType)
10:21:31 <osaunders> I’ll get back to you, reading about this Uniplate things seems interesting
10:28:25 <edwardk> osaunders: there is a notion of a lens.    a -> (b, b -> a)
10:28:50 <edwardk> osaunders: that lets you access a 'b' from an a like a getter, and 'set' the b to a new value yielding a new a
10:28:56 <Phyx-> oohh, CIntPtr....
10:29:33 <edwardk> osaunders: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation/5769285#5769285
10:32:19 <osaunders> edwardk: TY
10:58:09 * hackagebot regex-compat 0.95.1 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-compat-0.95.1 (ChrisKuklewicz)
11:27:33 <adamvh> Is there a canonical instance of Applicative for Parsec?  Something like what appears in Real World Haskell?
11:28:38 <kosmikus> adamvh: parsec (at least version 3) offers an Applicative interface
11:28:59 <monochrom> parsec 2 doesn't have the Applicative instance
11:29:06 <adamvh> kosmikus: Thanks, good to know
11:29:21 <adamvh> So, RWH is out of date in that regard?
11:30:26 <monochrom> heh
11:30:51 <monochrom> in principle, the authors of RWH can easily update the website though
11:30:55 <Taslem> Would it make sense to make a datatype D, then have a system where when accessed like type X, modifies it?
11:31:39 <Taslem> Like, saying:  N acts like Int, but also consists of a hash, so stating N + 1 -> returns of type N?
11:31:57 <adamvh> I think I'll leave a comment on the website if there isn't already one to that effect
11:32:22 <kosmikus> adamvh: what exactly are you saying is outdated?
11:32:36 <merijn> Taslem: You could make N an instance of the typeclass Num and have a "fromIntegral" definition then do "N + fromIntegral 1"
11:32:59 <Taslem> Well, not quite what I meant.
11:33:10 <Taslem> Say there's a type, data Capsule a = Capsule a
11:33:43 <Taslem> Then, let's say you make type data Q = Q Int Int.  Then what if you could say, "interpret Q a b as Capsule a where 'a' is an Int"
11:34:15 <merijn> Taslem: That sounds completely nonsensical to me
11:34:28 <merijn> What does "Interpret Q a b as Capsule a" mean?
11:34:52 <Taslem> Well, I guess the idea is to allow types to interface each other. So one value can correspond directly to another.
11:35:04 <Taslem> Without applying extra functions and such.
11:35:27 <adamvh> kosmikus: there's a section in the chapter on Parsec where they have you define your own Applicative instance for Parsec
11:35:28 <merijn> You have newtype's, but then both types have to be exactly the same
11:35:45 <merijn> I think you want structural subtyping, but Haskell does not have that (I think ML does, or at least OCaml)
11:35:49 <Taslem> For instance, producing a non-monadic state system that can interface correctly with pure functions.
11:36:04 <Taslem> Structural subtyping... hm...
11:38:34 <kosmikus> adamvh: ok
11:38:40 <merijn> Go supports structural subtyping too? That's awesome...
11:39:17 <joe6> how about agda?
11:48:41 <chrisdone> Hi guys. What IP does hpaste.org resolve to for you? I'm migrating to another server, DNS change should have made its way through the intertubes by now.
11:48:57 <Zao> 109.74.197.248
11:49:01 <hpc> 85.13.135.152
11:49:16 <hpc> hmm
11:49:27 <Zao> I haven't used hpaste on this machine though in the past.
11:49:28 <hpc> i can visit hpaste fine
11:49:40 <hpc> wait, i suck
11:49:46 <hpc> 109.74.197.248
11:49:49 <djahandarie> chrisdone, why don't you hang out here anymore
11:49:52 <hpc> i was pinging hpaste.com
11:49:56 <jmcarthur> ha
11:49:59 <chrisdone> So far so good, that's the right IP.
11:50:00 <Botje> 109.74.197.248 here
11:50:04 <jmcarthur> same here
11:50:09 <jmcarthur> 109.*
11:50:49 <chrisdone> At the moment it's just a proxy to the old host, seems to have updated since the weekend. I'll start it up on the new host.
11:51:36 <chrisdone> djahandarie: Busy, init. ;-)
11:51:48 <monochrom> chrisdone we miss you!
11:52:09 <chrisdone> LIES! ;_;
11:52:45 <chrisdone> Yeah, I really need to fix that annotation bug where it doesn't default to Haskell. Are there any other annoyances people noticed while I'm on it?
11:52:58 <djahandarie> Agda doesn't have its own highlighting mode
11:52:59 <djahandarie> Fix it
11:53:17 <djahandarie> (This is definitely easy.)
11:53:18 <chrisdone> djahandarie: Isn't that a Really Hard Problem that even copumpkin hasn't solved?
11:53:26 <monochrom> I want "expire in 5 minutes" to be turned on by default, but that's just me
11:53:50 <djahandarie> copumpkin kind of did something with it but yeah it's not easy
11:54:14 <djahandarie> chrisdone, what happened to hpastebot or whatever?
11:54:16 <monochrom> I don't find any annoyance
11:54:20 <jmcarthur> isn't his solution to "just" load the file in agda (and hence only works if it's valid and also takes a ton of time and memory)?
11:54:43 <monochrom> hpastebot may be more controversial
11:54:44 <chrisdone> monochrom: Doesn't seem a bad default, I'll add it. Can also make the choice cookie-remembered.
11:55:17 <jmcarthur> surely 5 minutes is a bit too short...
11:55:22 * monochrom will have to try suggesting "expire in 5 seconds" next time
11:55:29 <djahandarie> jmcarthur, not for #haskell
11:55:39 <djahandarie> You'll get at least 5 answers in 5 minutes
11:55:39 <chrisdone> jmcarthur: It's an hour, btw.
11:55:57 <monochrom> hehe
11:56:11 <ClaudiusMaximus> chrisdone: one tiny annoyance - with my customized browser settings (just changed colour to white text/black background) i get white text on white background in the text entry fields unless i disable all page colours
11:56:13 <djahandarie> 5 completely different answers with no clear Right Answer
11:56:13 <kuraj> i know its not very nice to pirate ebooks, but this is impossible for me to get, either physically or digitally...
11:56:17 <jmcarthur> often a paste ends up being a topic of discussion for an hour or more though, then newcomers have to scroll back and find the link to context. would suck if that expires too soon
11:56:20 <jmcarthur> and hour is okay i guess
11:56:23 <jmcarthur> *an
11:56:25 <kuraj> has anyone got a copy of richard bird - introduction to functional programming (using haskell)?
11:56:47 <adamvh> Is there a good introduction to all of the GHC extensions somewhere?
11:56:50 <chrisdone> ClaudiusMaximus: Are you changing the page colours via CSS?
11:56:59 <ClaudiusMaximus> chrisdone: no, via firefox preferences
11:57:00 <kuraj> this book is crucial for my course, and there are only 3 copies in our library :/
11:57:00 <adamvh> Or is reading the GHC documentation about the best one can do?
11:57:09 <kuraj> (for 300 people to share)
11:57:18 <jmcarthur> adamvh: i would just read the docs and if you need more info google the specific extension or ask here
11:57:20 <monochrom> read the GHC documentation. actually it has simple but powerful examples
11:57:35 <jmcarthur> the docs are pretty good overall
11:57:47 <djahandarie> adamvh, http://blog.ezyang.com/2011/03/type-tech-tree/ is a nice overview of the type-related extensions
11:57:48 <ClaudiusMaximus> chrisdone: some other sites are affected in similar ways, so it's not that a big deal, i can always change my preferences to something more generally common
11:57:57 <chrisdone> ClaudiusMaximus: Err… I can solve that by removing the background image on the inputs. Not a big deal.
11:57:59 <monochrom> everything I needed to know about type families I learned from the ghc user guide
11:58:54 <monochrom> existential type, too
12:01:37 <jmcarthur> it would be awesome if there was a description of ghc's entire pipeline (including all optimization passes and stuff) intended for end users instead of for ghc developers
12:01:50 <jmcarthur> but i guess that probably changes so much it would be a pain to maintain that documentation
12:01:57 <ClaudiusMaximus> chrisdone: if you need/want to test, http://img844.imageshack.us/img844/7603/colourprefs.png is a screenshot of my preferences - i'll be away for a week or so, so might not be able to help out
12:03:51 <chrisdone> I appear to have a leak of some kind on hpaste.org. There are currently 12 postgres processes open due to it, totalling 150MB~ in memory. This is with Takusen. I'm using withSession which apparently closes the connection, seems not to, though. Curious.
12:04:31 <chrisdone> ClaudiusMaximus: That's okay, I think removing the background image will solve it, thanks. I can test anyway.
12:04:32 <adamvh> djhandarie: thanks for the link
12:05:08 * djahandarie introduces adamvh to dja[tab]
12:05:26 <adamvh> Ah, thank you good sir
12:05:28 <shachaf> djahandarie: You mean djanatyn?
12:05:33 <djahandarie> Oh god damn it there is someone else with 'dja' at the beginning of their name now too.
12:05:45 * djahandarie punches shachaf
12:05:52 <shachaf> djahandarie: Right, djancak.
12:06:00 <shachaf> (He's not in this channel, at least.)
12:06:00 <chrisdone> http://hpaste.org/46536/takusen_leak
12:06:32 <chrisdone> I'd expect the following line to close the connection: liftIO $ DB.withSession dbsess $ return ()
12:17:53 <KirinDave> Dear, sweet innocent #haskell
12:17:54 <KirinDave> http://forrst.com/posts/Javascript_Pointers-9q3
12:18:09 <KirinDave> I hope someone out there has a clever answer for why this kind of code might exist.
12:18:13 <c_wraith> chrisdone: it's not quite as bad as 150MB, because most of that is COW space that's never copied.  But leaking connections is unfortunate.
12:18:20 <KirinDave> But if not, please join me in a wry twisting of the mouth, trying to hide a grim smile.
12:20:14 <chrisdone> c_wraith: What's COW?
12:21:08 <c_wraith> chrisdone: copy-on-write.  It's a quick way to make a copy of memory space.  Don't actually copy it, until the process wants to make a change to it.  Then it's copied into the new memory space and updated.
12:21:25 <djahandarie> KirinDave, probably a link better for #haskell-blah . But the next post looks even more interesting.
12:21:48 <chrisdone> c_wraith: Ah, right. I just looked that up. You're saying that's what postgres is doing for its processes?
12:22:16 <c_wraith> chrisdone: yes, that's the majority of the memory used for postgres connections.  It reports using a lot more memory than it actually is
12:22:33 <chrisdone> c_wraith: Good to know.
12:24:24 <adamvh> KirinDave: Perhaps he is not serious.
12:24:33 <joe6> @hoogle [(a -> b)] -> a -> [b]
12:24:33 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:24:33 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:24:33 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:24:34 <KirinDave> adamvh: I wish that were true.
12:25:01 <joe6> @hoogle a -> [(a -> b)] -> [b]
12:25:02 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:25:02 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:25:02 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:25:38 <joe6> is there a function that can take a list of functions and run each one on one parameter, giving out the results as a list?
12:25:54 <joe6> all the functions have the same input parameter
12:25:56 <ion> > (map . flip ($)) 42 [(+1), (+2), (+3)]
12:25:58 <lambdabot>   [43,44,45]
12:26:06 <joe6> ion, thanks.
12:26:21 <pastorn> joe6: map ($x) funs
12:26:40 <joe6> pastorn, there you are . Thanks a lot..
12:26:43 <aristid> > (flip sequence) 42 [(+1), (+2), (+3)]
12:26:45 <lambdabot>   [43,44,45]
12:26:54 <aristid> joe6: i think sequence is even nicer
12:27:09 <aristid> @src sequence
12:27:09 <lambdabot> sequence []     = return []
12:27:09 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:27:09 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:27:14 <joe6> aristid, ok, thanks
12:27:34 <ion> :t sequence
12:27:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:27:41 <djahandarie> Of course sequenceA is the proper choice
12:27:49 <aristid> djahandarie: why?
12:27:51 <djahandarie> I wish it had another name which didn't make sequence look better
12:27:54 <ion> :t sequenceA
12:27:55 <lambdabot> Not in scope: `sequenceA'
12:28:04 <djahandarie> aristid, because sequence is using the wrong typeclass
12:28:11 <djahandarie> Same with mapM
12:28:12 <rajeshsr> hi
12:28:18 <rajeshsr> In the blog: http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
12:28:33 <djahandarie> @type Data.Traversable.sequenceA
12:28:34 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
12:28:37 <aristid> djahandarie: sure, but if you're using it in a monomorphic way, that's just an aesthetic problem
12:28:45 <rajeshsr> I don't understand how the abstraction Lazy makes the map evaluate "force x" only once...
12:29:03 <aristid> djahandarie: also, sequenceA is actually slightly too generic for my taste
12:29:04 <djahandarie> aristid, its encouraging the use of wrong tools
12:29:10 <djahandarie> Why?
12:29:14 <aristid> Traversable
12:29:16 <djahandarie> It's the proper level of abstraction
12:29:52 <rajeshsr> anyone?
12:30:44 <chrisdone> Is there a "cabal install just the dependencies not the package" yet?
12:30:52 <dcoutts> yes
12:31:14 <djahandarie> aristid, sequenceA IS a definition for Traversable.
12:31:29 <dcoutts> chrisdone: in version 0.10
12:32:01 <aristid> djahandarie: it is more confusing this way :)
12:32:11 <chrisdone> dcoutts: Ah, great. I'll update. Thanks. :-)
12:32:15 <djahandarie> dcoutts, I swear you have a highlight on 'cabal' or something man
12:33:55 <djahandarie> aristid, I think the confusion only comes from alienness
12:34:21 <djahandarie> I don't see why it is actually more confusing. The more abstract something is, the clearer it is what properties you are exploiting.
12:34:32 <aristid> djahandarie: i think it comes from using TWO type classes :)
12:34:42 <Saizan> rajeshsr: it'd be weird if you could, since it's not explained, it's left as an implementation detail
12:35:12 <rajeshsr> > (\x -> x + (let y = 3 in y))(8)
12:35:13 <lambdabot>   11
12:35:40 <aristid> djahandarie: i do understand sequenceA (by now), but if i'm telling joe6 to use sequence to apply a single value to multiple functions, i think the Traversable would make it unnecessarily confusing
12:35:40 <mauke> rajeshsr: force x is evaluated multiple times
12:35:44 <chrisdone> dcoutts: Where do you keep your changelog for cabal-install?
12:35:50 <mauke> rajeshsr: but expensive is only evaluated once
12:35:51 <rajeshsr> i guess (let y = 3 in y) is evaluated only once, when inside a mapper. That's the only way to explain it?!
12:36:04 <aristid> djahandarie: just like there should be a beginner's dialect of haskell without Monad, where (>>=) is monomorphically IO a -> (a -> IO b) -> IO b
12:36:05 <dcoutts> chrisdone: in the darcs repo
12:36:21 <rajeshsr> mauke: yeah: is that of the form (let y = expensive in y)
12:36:22 <rajeshsr> ?
12:36:31 <djahandarie> aristid, I don't think joe6 is much of a beginner
12:36:43 <mauke> rajeshsr: what?
12:36:45 <aristid> hmm. dunno :)
12:36:45 * chrisdone does a darcs get and puts the kettle on
12:36:50 <Saizan> rajeshsr: to achieve this they use mutation and unsafePerformIO, not let bindings
12:36:51 <dcoutts> chrisdone: oh and http://www.haskell.org/cabal/release/cabal-install-0.10.2/changelog
12:37:06 <djahandarie> Or at least he's an enthusiastic beginner. He's also learning Agda and Coq
12:37:08 <rajeshsr> Saizan: uh!
12:37:36 <chrisdone> dcoutts: Ah, nice one, that's more like it. Cheers. :-)
12:37:59 <rajeshsr> Saizan: so, how's the implementation like?
12:38:17 <merijn> @remember mattmight Coq is a tool for turning ordinary programs into POPL papers.
12:38:17 <lambdabot> Good to know.
12:38:26 <monochrom> heh
12:38:39 <djahandarie> Should have been 'a DSL'
12:40:53 <djahandarie> aristid, all sequence really is, is  ala WrapMonad traverse  constrained to a list rather than a traversable
12:40:58 <djahandarie> @type ala WrapMonad Data.Traversable.traverse :: Monad m => [m a] -> m [a]
12:40:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:41:11 <aristid> djahandarie: sure :)
12:41:24 <djahandarie> And it's the WrapMonad that spells all sorts of wrong to me
12:41:28 <aristid> :t traverse
12:41:29 <lambdabot> Not in scope: `traverse'
12:41:33 <aristid> gah
12:41:38 <aristid> :t Data.Traversable.traverse
12:41:39 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:41:54 <aristid> :t Data.Traversable.sequenceA
12:41:55 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
12:42:00 <aristid> :t Data.Traversable.traverse id
12:42:01 <lambdabot> forall (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => t (f b) -> f (t b)
12:42:22 <djahandarie> @type Data.Traversable.sequenceA :: Applicative f => [f a] -> f [a] -- maybe this would be slightly more beginner friendly since there is only one type class
12:42:22 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f [a]
12:42:38 <chrisdone> Insight: -fobject-code is indispensable for loading large projects in GHCi.
12:43:03 <djahandarie> But it feels awfully dumb throwing away the Traversable structure when that is exactly what's being exploited
12:43:33 <aristid> djahandarie: that type was the sequenceA i was thinking of
12:44:24 <chrisdone> Without it, I can load my project in GHCi *once*, and subsequent loads quickly starts slowing my system down, gobbling memory. Unusable.
12:44:40 <Saizan> rajeshsr: something involving updating a reference after the first evaluation
12:44:55 <Saizan> rajeshsr: and later just reading from that reference
12:45:15 <aristid> chrisdone: it forces ghci to compile instead of interpret?
12:45:34 <rajeshsr> Saizan: a reference?! looks like i suck in Haskell :(
12:46:16 <chrisdone> aristid: Right, generates object code (leaves .o files lying around). Subsequent loads are instant.
12:46:18 <Saizan> rajeshsr: well, Lazy is not something you'd make in haskell, but in ML :)
12:46:49 <chrisdone> In combination with "cabal-dev ghci" it's really a very pleasant thing.
12:46:53 <Saizan> rajeshsr: by reference i mean something like haskell's IORef
12:47:05 <rajeshsr> Saizan: hmm, i have no clue of ML!
12:47:20 <rajeshsr> oh, ok. Lemme read about it!
12:47:26 <rajeshsr> thanks
12:48:58 <Saizan> rajeshsr: that part of the post is saying "yeah, you can implement lazyness via an abstract type in a strict language with effects, ending up writing code like this"
12:50:17 <rajeshsr> Saizan: ha! ok
13:03:10 <eikke> is it just me, or can an MVar be 'written to' whilst another thread runs withMVar on the MVar, as such resulting in a deadlock?
13:03:47 <c_wraith> eikke: a single MVar won't ever deadlock, so long as there is eventually another reader (if it's blocked on write) or writer (if it's blocked on read)
13:04:07 <c_wraith> And it's not really a deadlock if there isn't eventually another participant
13:05:16 <eikke> c_wraith: agree, sorta
13:05:49 <eikke> c_wraith: although now I should figure out how to get around a case kinda similar to https://gist.github.com/54ea68091e7f317ffd52
13:05:51 <c_wraith> remember, *single* MVar.  It's easy to deadlock when using multiple MVars
13:07:01 <eikke> basically: doing some IO action once an MVar is 'set', without unsetting it in-between
13:07:27 <eikke> (line 18 could become newEmptyMVar then)
13:07:31 <c_wraith> Your case involves multiple MVars.  everyone knows that can deadlock.  Which is why MVars aren't recommended for that situation.
13:07:54 <eikke> c_wraith: the lock is only related to the 'a' var, i think
13:08:54 <c_wraith> Oh.  I see, you have multiple writers, but no readers.
13:09:00 <monochrom> if every thread sticks to withMVar, there is no problem
13:09:01 <eikke> indeed
13:09:07 <c_wraith> That's not a deadlock.
13:09:24 <monochrom> if a thread uses withMVar, another thread comes long to putMVar, yes there is a problem
13:09:48 <c_wraith> monochrom: this case is just no reader from a particular MVar
13:10:35 <c_wraith> That's hardly a deadlock.  If there was a reader, things would proceed.
13:10:42 <eikke> is there any other route I could take to achieve this, i.e. executing some action when an mvar is set, without unsetting it in-between?
13:11:01 <eikke> (I know there's only a single thread which will be waiting for the mvar to be set)
13:11:01 <c_wraith> It's not clear what you're really trying to do.
13:11:15 <c_wraith> You want a notifier?
13:11:23 <monochrom> there is always a route
13:11:52 <c_wraith> Where multiple parties could notify without blocking, before the party waiting for the notification gets around to handling it?
13:11:53 <eikke> c_wraith: not really, there's other code which checks whether the mvar is set (isEmptyMVar)
13:12:20 <c_wraith> Use a Chan instead, if there's only a single reader.
13:13:06 <eikke> should check whether that provides everything I need, not sure
13:13:20 <eikke> the fact something is scheduled to happen needs to be known by other parties as well
13:13:57 <c_wraith> You can always use the withMVar approach, with a more complicated structure inside the MVar
13:15:57 <c_wraith> That approach is pretty common.  You guarantee that the MVar starts full, and each operation removes the contents, does whatever it needs, and then puts new contents in.  This can't ever run into unexpected blocking states, because the only thread that can write to the MVar is the same one that previously read from it.
13:17:34 <dankna> you can also do the exact opposite, in principle, where the only thread that can read from the MVar is the same one that just wrote to it, so no unexpected blocking.  but it's not clear to me that this is useful.
13:17:36 <monochrom> I have a program that uses modifyMVar. but like I said, it requires every thread sticking to the same convention
13:17:55 <eikke> uhu
13:18:04 <eikke> I might want to use STM, actually
13:18:31 <eikke> problem is this is just some proof-of-concept-throw-away-code which will later be rewritten using ocaml, which I know less well than haskell, so I prototype in Hs
13:19:08 <eikke> so I shouldnt rely on the concepts which make hs so much more attractive (imho) than ocaml too much :D
13:19:13 <dankna> mm
13:20:54 <monochrom> ocaml offers mutex, condition variable, event
13:21:24 <eikke> lwt (the lib we're using) offers several basic constructs indeed
13:22:16 <monochrom> you will have to either build a haskell layer to emulate mutex, condition, event; or build an ocaml layer to emulate mvar, tvar.
13:22:46 <eikke> There's lwt_mvar with a similar API to Control.Concurrent.MVar
13:22:56 <monochrom> then nice
13:23:20 <eikke> and lwt_stream provides something Chan-like, so I might want to take a look at that approach
13:25:17 <mjrosenb> what module is showHex defined in?
13:25:48 <mauke> @index showHex
13:25:49 <lambdabot> Numeric
13:26:17 <shachaf> What module is @index defined in?
13:26:49 <djanatyn> > [(a,b,c) | a <- [1..1000], b <- [1..1000], c <- [1..1000], (a^2 + b^2) == (c^2), a + b + c == 1000]
13:26:53 <lambdabot>   mueval-core: Time limit exceeded
13:27:07 <djanatyn> yeah, seemed mighty inefficient :P
13:27:54 <djanatyn> Trying to figure out the pythagorean triplet for which a + b + c == 1000
13:27:55 <shachaf> djanatyn: It's only a billion possibilities.
13:27:58 <djanatyn> :)
13:28:47 <djanatyn> I still get thrown off by list comprehension with multiple variables.
13:29:34 <mauke> it's just nested loops
13:30:01 <monochrom> djanatyn, you can ask lambdabot to try a scaled-down version, like 10 instead of 1000
13:30:23 <monochrom> or else you can use your own ghci for the full version
13:30:51 <monochrom> in any case, the fact that it is a timeout error rather than a type error is already good news
13:31:32 <mauke> unless it's a loop in the typechecker
13:31:55 <monochrom> ah, you don't get that with a mere list comprehension
13:32:21 <shachaf> monochrom: Is that a challenge?
13:32:28 <monochrom> no
13:32:35 <shachaf> @quote OlegFacts
13:32:35 <lambdabot> OlegFacts says: Oleg's first datatype in haskell started like this: data ChuckNorris ...
13:32:41 <monochrom> hahaha
13:33:59 <aristid> oleg jokes never get old :)
13:34:28 <wires> REST API's for haskell, what's the best way to do that?
13:34:31 <Phyx-> ChuckNorris can never fit in a data
13:34:38 * hackagebot cblrepo 0.2.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.2.0 (MagnusTherning)
13:34:40 <shachaf> Phyx-: We're talking about Oleg.
13:34:41 <shachaf> @quote OlegFacts
13:34:41 <lambdabot> OlegFacts says: Oleg implemented first-class continuations in Haskell... in the type system
13:35:11 <wires> Right now I'm using Network.Wai + manual JSON.. but is there something better?
13:36:02 <monochrom> I don't know what is REST. could you teach me briefly?
13:36:25 <wires> model to interface services using HTTP,
13:36:57 <wires> you use HTTP methods like GET / PUT / DELETE on "resources", basically urls
13:37:54 <wires> so you would have a resource /person/346 representing the person with id=346
13:38:12 <wires> a HTTP DELETE request on /person/346 would delete that resource
13:38:33 <wires> it is a very common way to interface applications over the web
13:38:45 <monochrom> so if I query his name, I do a GET; if I modify his name, I do a PUT, is that right?
13:39:07 <wires> GET /person/346 would for instance return you a JSON document representing that person
13:39:36 <wires> PUT /person/ with a JSON document in the body could create a new person
13:40:18 <wires> there is a lot more to it... read Roy Fielding - "a principled architecture for the web" (or something)
13:40:26 <wires> well.. "a lot"
13:49:14 <rs461> hi. I get the error: parse error in constructor in data/newtype declaration: (Int, Int) when trying to declare a data type:
13:49:20 <rs461> data Test = (Int, Int) | (Int, String)
13:49:26 <rs461> What is wronng with this syntax?
13:49:36 <shachaf> rs461: You're not naming a constructor.
13:49:37 <Botje> you need ata constructors
13:49:39 <Botje> *data
13:49:45 <shachaf> data Test = Foo Int Int | Bar Int String
13:49:56 <shachaf> Alternatively, type Test = Either (Int,Int) (Int,String)
13:51:45 <parcs> Botje: don't you mean type constructors?
13:52:35 <mauke> parcs: no
13:53:02 <parcs> damn.
13:54:03 <monochrom> "Test" is already the type constructor
13:54:24 <mauke> so are Int, (,) and String
13:55:52 <parcs> okay
13:56:00 <parcs> but isn't (,) also a data constructor
13:56:29 <monochrom> yes
13:57:18 <mauke> data (a, b) = (a, b)
13:58:53 <shachaf> data (a) = (a)
13:59:05 <monochrom> data () = ()
13:59:33 <shachaf> data  =
14:00:42 <mauke> da = ta
14:36:03 <joe6> is there something that can do : (c d e) -> [(a -> b -> c -> d -> e -> f)] -> [f]
14:36:17 <Nereid> joe6: what is c d e?
14:36:27 <Nereid> do you mean (c -> d -> e)?
14:36:37 <joe6> actually, it is : (a b c d e) -> [(a -> b -> c -> d -> e -> f)] -> [f]
14:36:43 <Nereid> what is a b c d e
14:36:51 <joe6> Nereid, yes, the parameters to a function
14:36:56 <aristid> joe6: no, not possible. wrong kinds
14:36:57 <Nereid> so a -> b -> c -> d -> e
14:37:00 <joe6> I have a function that takes 4 paramaters
14:37:01 <monochrom> nothing can do it. wrong kinds
14:37:18 <byorgey> perhaps you want (a,b,c,d,e) -> [...] -> [f] ?
14:37:24 <Nereid> @djinn a -> b -> [(a -> b -> f)] -> [f]
14:37:25 <lambdabot> Error: Undefined type []
14:37:29 <Nereid> :/
14:37:39 <Nereid> @djinn a -> b -> (a -> b -> f) -> f
14:37:39 <lambdabot> f a b c = c a b
14:37:51 <Nereid> and then compose that with map
14:37:52 <joe6> i think I am not explaining it. I have a list of functions that take 4 parameters and I do not want to repeat the 4 parameters
14:38:03 <joe6> as the parameters are the same for each function
14:38:14 <aristid> :t sequence . map uncurry
14:38:14 <lambdabot> forall a a1 b. [a1 -> b -> a] -> (a1, b) -> [a]
14:38:22 <aristid> :t curry . sequence . map uncurry
14:38:23 <lambdabot> forall a b c. [a -> b -> c] -> a -> b -> [c]
14:38:33 <aristid> joe6: like this?
14:38:35 <byorgey> joe6: ok, so something like   map (\f -> f a b c d e) funcs
14:38:41 <aristid> except with different parameter order
14:38:52 <joe6> byorgey, yes that is what I am talking about.
14:38:58 <joe6> thanks.
14:39:02 <byorgey> sure.
14:39:08 <Nereid> @pl map (\f -> f a b c d e) funcs
14:39:08 <lambdabot> map (flip (flip (flip (flip ($ a) b) c) d) e) funcs
14:39:11 <Nereid> lol
14:39:12 <aristid> joe6: why do you have so many parameters?
14:39:24 <byorgey> what's wrong with having four parameters?
14:39:30 <Nereid> there are 5
14:39:44 <Nereid> ...because 4 is fine and 5 isn't, totally
14:39:55 <monochrom> @pl map (\f -> f a b c d e e1) funcs
14:39:55 <lambdabot> map (flip (flip (flip (flip (flip ($ a) b) c) d) e) e1) funcs
14:39:58 <joe6> sorry, it was actually 3 parameters
14:40:01 <Nereid> :/
14:40:23 <monochrom> your number of parameters is like the stock market
14:40:25 <aristid> joe6: why did you make the example more complicated for us, then? :D
14:40:33 <Nereid> ($ a) = flip ($) a
14:40:54 <Nereid> in case you wanted more flips
14:41:03 <aristid> Nereid: moar flips
14:41:10 <Nereid> :v
14:41:46 <Nereid> @pl \a b c ->map  (\f -> f a b c) fs
14:41:47 <lambdabot> flip flip fs . ((flip . (map .) . flip) .) . flip . flip id
14:41:53 <Nereid> whoa
14:42:08 <Nereid> @pl \a b c d -> map (\f -> f a b c d) fs
14:42:09 <lambdabot> flip flip fs . ((flip . ((flip . (map .) . flip) .) . flip) .) . flip . flip id
14:42:12 <Nereid> :|
14:43:01 <djahandarie> @pl \a b c d fs -> (\f -> f a b c d) . fs
14:43:01 <lambdabot> ((((((.) .) . flip) .) . flip) .) . flip . flip id
14:43:59 <djahandarie> > (((((((.) .) . flip) .) . flip) .) . flip . flip id) 1 2 3 4 [(\a b c d -> a + b + c + d), (\a b c d -> a*2 + b + c + d)]
14:44:01 <lambdabot>   [10,11]
14:45:32 <Nereid> fun with pl D:
14:45:43 <djahandarie> > ((fmap .: flip) .: flip) .: flip . flip id  1 2 3 4 [(\a b c d -> a + b + c + d), (\a b c d -> a*2  + b + c + d)]
14:45:43 <lambdabot>   No instance for (GHC.Show.Show
14:45:44 <lambdabot>                     (f (a -> a1 -> a2 -> f1 ...
14:45:46 <djahandarie> Oops
14:45:54 <djahandarie> > (((fmap .: flip) .: flip) .: flip . flip id) 1 2 3 4 [(\a b c d -> a + b + c + d), (\a b c d -> a*2  + b + c + d)]
14:45:55 <lambdabot>   [10,11]
14:48:09 <KirinDave> What is pl anyways?
14:48:20 <monochrom> "pointless"
14:48:21 <djahandarie> @pl (\x -> x)
14:48:21 <lambdabot> id
14:48:31 <djahandarie> Point-free being the proper term for it
14:48:33 <monochrom> "point" refers to parameters
14:48:38 <djahandarie> Removes lambdas.
14:49:25 <KirinDave> Is there a local version?
14:49:35 <KirinDave> Or is it only exposed via this bot interface?
14:49:38 <Nereid> you can install your own lambdabot if you like :o
14:49:45 <Nereid> @pl c f g x = f (g x)
14:49:46 <lambdabot> c = (.)
14:49:49 <ddarius> "Points" refers to points.
14:50:01 <KirinDave> I'm just curious what happens if you turn it against huge code bases for fun and profit
14:50:06 <Nereid> haha
14:50:17 <_linuxftw> What does lambdabot do?
14:50:31 <parcs> what doesn't it do is the better question
14:50:40 <ddarius> @vixen What do you do?
14:50:40 <lambdabot> yes i do
14:50:52 <KirinDave> Where is the code for lambdabot?
14:50:57 <monochrom> lambdabot computes
14:51:03 <parcs> @hackage lambdabot
14:51:03 <lambdabot> http://hackage.haskell.org/package/lambdabot
14:51:07 <danharaj> @where lambdabot
14:51:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:51:11 <ddarius> @version
14:51:11 <lambdabot> lambdabot 4.2.2.1
14:51:11 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:51:12 <dons> > fold (+) 0 x
14:51:13 <dons> [6.0,15.0,24.0]
14:51:13 <lambdabot>   Not in scope: `fold'
14:51:16 <ddarius> monochrom computes
14:51:31 <monochrom> not as good as lambdabot
14:51:32 <Cale> KirinDave: @pl doesn't understand all of Haskell
14:51:33 <_linuxftw> foldl / foldr
14:51:40 <monochrom> I can't do @pl
14:52:32 <dons> urgh. err wrong terminal
14:57:21 <djahandarie>  @pl doesn't even understand the Haskell it claims to understand
14:57:31 <djahandarie> It makes errors fairly regularly in its transformations
14:57:40 <djahandarie> Usually related to laziness, but sometimes it's just... wrong
14:57:52 <Saizan> e.g.?
14:58:06 <c_wraith> I've seen @pl spit out code that doesn't compile
14:58:15 <djahandarie> I don't remember exactly, but the thing that always results in that infinite type error
14:58:44 <geheimdienst> guess too much pointless style is confusing both to humans and machines
14:58:44 <djahandarie> With join
14:58:44 <c_wraith> yeah, I remember join being involved
15:00:45 <Saizan> ah, makes sense, it's untyped afterall
15:00:45 <Saizan> f x x = join f x assumes x is used at the same type in both cases in the original
15:00:56 <approximist> hey, anybody there'"?
15:01:06 <Draconx> approximist, no.
15:01:07 <jmcarthur> no. just 754 silent people
15:01:08 <approximist> im new and already loving haskell?
15:01:14 <approximist> *!
15:01:17 <approximist> kewl
15:01:17 <jmcarthur> awesome? ;)
15:01:22 <KirinDave> @pl f x y = (x y, x)
15:01:22 <lambdabot> f = flip =<< ((,) .)
15:01:26 <KirinDave> Gnarly.
15:01:30 <geheimdienst> jmcarthur: we don't like that word around here
15:01:37 <geheimdienst> try "xmonad"
15:02:06 <KirinDave> Man that is an inscrutable piece of code @pl jsut spat out.
15:02:11 <Nereid> lol
15:02:13 <approximist> will the "chat" command work when im running haskell from my terminal"?
15:03:50 <Twey> Meh, not so terrifying
15:03:50 <Draconx> KirinDave, well, it's called pointless for a reason.
15:03:50 <aristid> approximist: no
15:03:50 <approximist> so how do i join irc from a terminal
15:03:50 <aristid> approximist: you can use irssi from your terminal.
15:41:51 --- topic: '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
15:41:51 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Mar 26 17:29:19 2011]
15:42:03 <ion> @hoogle [a] -> Maybe a
15:42:04 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
15:42:04 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:42:04 <lambdabot> Prelude head :: [a] -> a
15:42:18 <ion> @hoogle headMaybe
15:42:18 <lambdabot> No results found
15:42:20 <adamvh> With Applicative, it's almost as convenient as Perl, and type safe!
15:42:34 <joe6> @hoogle readHex
15:42:34 <lambdabot> Numeric readHex :: Num a => ReadS a
15:42:35 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
15:43:20 <Saizan> jonkri: basically ghc doesn't want to provide guarantees on which exception gets thrown if in something like (error "x" + error "y") :: Int
15:44:00 <jonkri> i don't see why a function that is "referential transparent" could not throw an exception
15:44:10 <jonkri> the exception would be the value of the function, and it would be the same every time
15:44:21 <Saizan> jonkri: so that non-determinism gets solved by putting catch in the IO monad
15:45:04 <c_wraith> saizan's example just above covers that
15:45:08 <jonkri> but maybe that's not the way functions are supposed to work :)
15:45:19 <Saizan> jonkri: not really, (error "x" + error "y"):: Int could throw both ErrorCall "x" and ErrorCall "y", depending on how the compiler feels like
15:45:21 <ion> @hoogle headMay
15:45:22 <lambdabot> No results found
15:45:28 <ion> http://hackage.haskell.org/packages/archive/safe/0.3/doc/html/Safe.html
15:45:52 <c_wraith> jonkri: anyway, the spoon package is about doing this in a way that *tries* to retain referential transparency
15:45:55 <c_wraith> @hoogle spoon
15:45:55 <monochrom> in fact (seq (error "x") (error "y")) too
15:45:55 <lambdabot> No results found
15:46:00 <c_wraith> @hackage spoon
15:46:00 <lambdabot> http://hackage.haskell.org/package/spoon
15:47:15 <jonkri> ok, thanks
15:47:21 <djahandarie> The real solution is to just have a compile-time error when you try to run head on an empty list ;)
15:47:55 <mm_freak_> ok, the last part, which is missing, is a good tutorial to eacid-state
15:47:55 <mm_freak_> one that makes you know what you are doindoing
15:48:03 <mm_freak_> -e
15:48:10 <djahandarie> -doin
15:48:11 <Saizan> i guess spoon have problems only if one of the bottoms is non-termination
15:48:15 <KirinDave> djahandarie: "We call it the oracle machine..."
15:48:31 <KirinDave> djahandarie: Alternative punchline: "Quantum computing can fix that too."
15:48:37 <djahandarie> KirinDave, hey, it's possible for the most part :)
15:49:00 <NihilistDandy> Very diplomatic
15:51:09 <djahandarie> I wish there was a package on hackage that packed up a simple Vec implementation without any ugly extra stuff making it look like crap
15:51:17 <alpounet> just gotta use a non-empty-list type
15:52:52 <djahandarie> Actually I was writing such a thing awhile ago, I wonder what happened to that
15:53:57 <Tordek> how can I generate all the ways to split a set in two? e.g: [(a, setDifference x a) | a <- powerSet x] (just that it seems it'll be slow, what with the set difference)
15:57:40 <jmcarthur> i'm trying to figure out what mfix on lists is good for
15:57:46 <byorgey> Tordek: modify the powerSet function to compute both the subsets and their complements at once.
15:58:35 <Tordek> byorgey: I don't actually have a powerset function right now
15:58:53 <mm_freak_> Tordek:
15:58:55 <mm_freak_> > foldM (\(xs,ys) x -> [(xs ++ [x], ys), (xs, ys ++ [x])]) ([], []) "abc"
15:58:57 <lambdabot>   [("abc",""),("ab","c"),("ac","b"),("a","bc"),("bc","a"),("b","ac"),("c","ab...
15:59:06 <Saizan> splits [] = [([],[])]; splits (x:xs) = [ (x:a,b) | (a,b) <- splits xs ] ++ [ (a,x:b) | (a,b) <- splits xs ]
15:59:14 <mm_freak_> but use a better data structure than lists
15:59:17 <byorgey> mm_freak_: ugh, xs ++ [x], really ?
15:59:18 <hpc> @src [] mfix
15:59:18 <lambdabot> mfix f = case fix (f . head) of
15:59:18 <lambdabot>            []    -> []
15:59:18 <lambdabot>            (x:_) -> x : mfix (tail . f)
15:59:31 <mm_freak_> byorgey: you can use (:), too, but then you reverse the order
15:59:46 <hpc> :t mfix
15:59:46 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
16:00:00 <mm_freak_> > foldM (\(xs,ys) x -> [(x:xs, ys), (xs, x:ys)]) ([], []) "abc"
16:00:00 <hpc> > mfix (:[]) [1..]
16:00:01 <byorgey> mm_freak_: well, you just have to fold in the right direction
16:00:01 <lambdabot>   [("cba",""),("ba","c"),("ca","b"),("a","cb"),("cb","a"),("b","ca"),("c","ba...
16:00:01 <lambdabot>   Couldn't match expected type `[t1] -> t'
16:00:01 <lambdabot>         against inferred type `[a]'
16:00:04 <Saizan> > let splits [] = [([],[])]; splits (x:xs) = [ (x:a,b) | (a,b) <- splits xs ] ++ [ (a,x:b) | (a,b) <- splits xs ] in splits "abc"
16:00:06 <lambdabot>   [("abc",""),("ab","c"),("ac","b"),("a","bc"),("bc","a"),("b","ac"),("c","ab...
16:00:08 <hpc> > mfix (:[])
16:00:12 <lambdabot>   mueval-core: Time limit exceeded
16:00:14 <mm_freak_> byorgey: unfortunately there is no foldrM
16:00:18 <hpc> > mfix (:1:[])
16:00:21 <lambdabot>   mueval-core: Time limit exceeded
16:00:30 <mm_freak_> foldM is monadic foldl
16:00:35 <byorgey> mm_freak_: I know.
16:00:43 <mm_freak_> but anyway, the problem disappears, if you use Set instead of []
16:00:50 <jmcarthur> > mfix (const [1,2])
16:00:51 <lambdabot>   [1,2]
16:00:57 <mm_freak_> then foldM is fine
16:01:05 <aristid> > fix (const [1,2])
16:01:06 <lambdabot>   [1,2]
16:01:08 <aristid> :t mfix
16:01:09 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
16:01:17 <byorgey> mm_freak_: unfortunately Set is not an instance of Monad =(
16:01:25 <jmcarthur> > mfix (\n -> [1,n])
16:01:28 <lambdabot>   mueval-core: Time limit exceeded
16:01:29 <mm_freak_> byorgey: it doesn't need to be
16:01:30 <hpc> @src Maybe mfix
16:01:31 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
16:01:44 <mm_freak_> byorgey: Set is a Traversable
16:01:46 <byorgey> mm_freak_: oh, right, sorry
16:01:47 <hpc> > mfix (const Nothing)
16:01:47 <lambdabot>   Nothing
16:02:08 <alpounet> > take 10 $ mfix (\n -> [1,n])
16:02:12 <lambdabot>   mueval-core: Time limit exceeded
16:02:42 <jmcarthur> > head $ mfix (\n -> [1,n])
16:02:43 <lambdabot>   1
16:02:52 <jmcarthur> > take 2 $ mfix (\n -> [1,n])
16:02:56 <lambdabot>   mueval-core: Time limit exceeded
16:03:00 <aristid> oO
16:03:02 <parcs> > head . head $ mfix (\x -> [1,n])
16:03:03 <lambdabot>   Couldn't match expected type `[a]'
16:03:03 <lambdabot>         against inferred type `SimpleRef...
16:03:16 <hpc> > head . tail $  mfix (\x -> [1,n])
16:03:18 <lambdabot>   n
16:03:25 <jmcarthur> haha
16:03:56 <Saizan> > head . tail $  mfix (\x -> [1,x])
16:03:59 <lambdabot>   mueval-core: Time limit exceeded
16:04:29 <jmcarthur> > mfix (\str -> ["foo"++str, "bar"++str])
16:04:30 <lambdabot>   ["foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoof...
16:04:35 <jmcarthur> :D
16:04:55 <jmcarthur> > mfix (\str -> [take 20 $ "foo"++str, take 5 $ "bar"++str])
16:04:57 <lambdabot>   ["foofoofoofoofoofoofo","barba"]
16:05:26 <aristid> @src [] mfix
16:05:27 <lambdabot> mfix f = case fix (f . head) of
16:05:27 <lambdabot>            []    -> []
16:05:27 <lambdabot>            (x:_) -> x : mfix (tail . f)
16:05:47 <djahandarie> Hmm, mfix could be pretty useful for golfing, maybe
16:07:46 <aristid> :t \f -> fix (f . head)
16:07:47 <lambdabot> forall a. (a -> [a]) -> [a]
16:08:10 <adamvh> @pl \f -> (flip g . f <$>)
16:08:11 <lambdabot> (<$>) . (flip g .)
16:08:29 <adamvh> duh
16:08:43 <adamvh> nothing like @pl to make me feel thick
16:09:29 <Saizan> ?type \f g -> (flip g . f <$>)
16:09:30 <lambdabot> forall (f :: * -> *) a b a1 (f1 :: * -> *). (Functor f, Functor f1) => (a1 -> a) -> f (a -> b) -> f1 a1 -> f1 (f b)
16:11:25 <adamvh> basically I have the first argument to a function living in a monad and the second pure
16:12:20 <c_wraith> :t \f x y -> f <$> x <*> pure y
16:12:22 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> a1 -> f b
16:12:44 <c_wraith> sadly, there don't seem to be idioms significantly better than that for those cases
16:12:53 <hpc> @pl \f x -> f <*> pure x
16:12:53 <lambdabot> (. pure) . (<*>)
16:13:45 <dibblego> @type \k f a -> f <*> (k <$> a)
16:13:45 <lambdabot> forall (f :: * -> *) a b a1. (Applicative f) => (a1 -> a) -> f (a -> b) -> f a1 -> f b
16:16:25 <phr> does anyone use new-style listcomps?
16:16:40 <phr> http://hpaste.org/46542/parallel_listcomp_prob   should make zs and zs' the same thing, right?
16:17:26 <phr> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html#generalised-list-comprehensions
16:17:45 <phr> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html#parallel-list-comprehensions  rather
16:19:10 <NihilistDandy> Oh, how I love dependency chasing :D
16:20:04 <hpc> dibblego: i smell a category instance :P
16:21:02 <hpc> newtype Apply f a b = Ap (f (a -> b))
16:22:44 <hpc> :t \f g x -> f <*> g <*> x
16:22:45 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f a -> f a1 -> f b
16:22:54 <hpc> :t \f g x -> f <*> (g <*> x)
16:22:54 <lambdabot> forall (f :: * -> *) a b a1. (Applicative f) => f (a -> b) -> f (a1 -> a) -> f a1 -> f b
16:23:22 <hpc> :t flip
16:23:22 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:23:58 <hpc> :t (<*> (flip ($))
16:23:59 <lambdabot> parse error (possibly incorrect indentation)
16:24:05 <hpc> :t (<*> (flip ($)))
16:24:05 <lambdabot> forall b a b1. (a -> ((a -> b1) -> b1) -> b) -> a -> b
16:25:29 <hpc> @hoogle (f a -> f b) -> f (a -> b)
16:25:29 <lambdabot> No results found
16:25:44 <hpc> i don't suppose that's actually possible
16:26:18 <hpc> or it's the categorical dual of (<*>)
16:26:20 <dafis> hpc:  probably not, what would foo tail be?
16:26:49 <hpc> oh well
16:35:07 <Twey> \ f -> functor $ unfunctor . f . functor
16:35:09 <Twey> Maybe?
16:35:53 <dafis> Now define unfunctor
16:36:23 <Twey> It would be a method, I guess
16:36:34 <edwardk> hpc: the dual of <*> is not available in haskell
16:37:05 <edwardk> hpc: in the proper sense that is (no coexponentials)
16:44:02 <mm_freak_> acid-state makes quite a good impression to me
16:49:53 <jonkri> cool
16:53:28 <user317> is there a data.binary transformer?  i would like to be able to throw and catch errors while parsing
16:54:58 <Nereid> hpc: yeah, it can't work if f is just a comonad either.
16:55:27 <Nereid> (,) t is a comonad, so that would look like ((t,a) -> (t,b)) -> (t, a -> b)
16:55:35 <Nereid> which is impossibl
16:55:36 <Nereid> e
16:55:47 <Nereid> ... unless t is pointed
16:55:49 <Nereid> or
16:55:56 <Nereid> yeah
16:56:02 <Nereid> which is silly
16:56:42 <hpc> shame, it would have made a nifty category
17:05:03 <rostayob> how do I compile automatically .c files along with cabal?
17:05:17 <rostayob> like I'm doing tests giving the .c files directory to ghc
17:05:24 <rostayob> but if I want to package it
17:05:36 <Saizan> c-sources: ?
17:05:46 <rostayob> Saizan: ok I did that, but I get linking errors
17:06:29 <rostayob> that's what the file looks like: http://hpaste.org/46544/c_files
17:08:12 <adamvh> Is there any way I can get GHC to echo the types it infers for things as it compiles?
17:08:31 <adamvh> Or do I just need to put in type declarations and see if it rejects them?
17:08:39 <parcs> :type
17:08:43 <rostayob> adamvh: you can load up the file with ghci and use :type
17:09:07 <kmc> adamvh, if you build with -Wall, it will print the inferred type of any top-level declaration which lacks a type signature
17:09:56 <adamvh> hmm, I don't think either of these things work for a type error partway through...
17:10:55 <rostayob> adamvh: what do you mean?
17:11:32 <adamvh> Well, I'm failing to compile with a type error, and I'm looking for a way to figure out where I'm going wrong
17:11:44 <adamvh> so which thing has some type other than the one I think
17:12:03 <kmc> adamvh, you can replace parts of your expression with "undefined" until the type error goes away
17:12:08 <kmc> then you know
17:12:21 <adamvh> kmc: ah - that's helpful
17:12:38 <parcs> adamvh: just omit the type annotation then
17:13:05 <parcs> otherwise the error message that ghc spits out should suffice
17:14:04 <latrene> i have a question about $
17:14:37 <latrene> is the only reason $ works, is because it has declared low precedence in the standard prelude?
17:15:13 <hpc> latrene: the low precedence is what makes the f $ g x trick work
17:15:42 <BMeph> latrene: That depends on what your definition of "works" is. ;)
17:15:45 <hpc> it isn't essential to what ($) actually does, which is apply the first arument to the second
17:16:15 <BMeph> :t map ($(?f))
17:16:16 <lambdabot> forall a b. (?f::a) => [a -> b] -> [b]
17:16:32 <latrene> I see. So....fundamentally "mathematically" $ doesn't really mean anything. Its just a neat workaround that relies on low precendence in the language
17:16:49 <gienah> rostayob: maybe the linking errors might give some hints
17:17:06 <ddarius> "Mathematically" ($) is id (modulo a very special case)
17:17:36 <latrene> what is id?
17:17:42 <kmc> identity function
17:17:50 <kmc> returns its argument
17:17:52 <kmc> > id 3
17:17:53 <lambdabot>   3
17:17:54 <kmc> > id "foo"
17:17:55 <lambdabot>   "foo"
17:18:07 <rostayob> gienah: after cabal install, if I try to compile something with that library I get stuff like this: http://hpaste.org/46545/linking
17:18:07 <kmc> > succ `id` 3
17:18:09 <lambdabot>   4
17:18:10 <kmc> > succ $ 3
17:18:11 <lambdabot>   4
17:18:16 <rostayob> it simply looks as if it didn't link it
17:18:16 <hpc> > id succ 3
17:18:17 <lambdabot>   4
17:18:23 <hpc> > (id succ) 3
17:18:23 <lambdabot>   4
17:19:02 <hpc> more precisely, ($) = \f -> \x -> f x
17:19:09 <geheimdienst> latrene: i just think of '$' as "if i replace the '(' with '$', then i can leave out the ')'". slightly less clutter
17:19:11 <hpc> beta reduce to get ($) = \f -> f
17:19:14 <gienah> rostayob: is the main function in haskell or C?
17:19:15 <hpc> er, eta reduce
17:19:16 <ddarius> latrene: I don't know what you think ($) is "working around."
17:19:39 <rostayob> gienah: in haskell, I'm compiling a sample program that uses my bindings
17:19:50 <latrene> ddarius, its a workaround for exactly how geheimdienst is using it
17:20:07 <ddarius> latrene: And what is that "working around"?
17:20:27 <latrene> It's reducing parentheses to make code more readable for the programmer
17:20:41 <kmc> that's not the only use for ($) though
17:20:43 <BMeph> latrene: Much like using a traffic cone as a wheel chuck, you can use it that way, but that doesn't mean that that's all it does. :)
17:20:45 <latrene> It is working around unreadable code
17:20:50 <hpc> :t zipWith ($)
17:20:51 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
17:21:01 <hpc> :t fmap ($)
17:21:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f (a -> b)
17:21:17 <hpc> :t \x -> fmap ($ x)
17:21:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
17:21:45 <BMeph>  :t \x -> fmap . ($ x)
17:21:52 <BMeph> :t \x -> fmap . ($ x)
17:21:53 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => a1 -> (a1 -> a -> b) -> f a -> f b
17:22:03 <kmc> there are also a few cases (in GHC) where replacing parens with ($) doesn't work the way you'd expect
17:22:06 <gienah> rostayob: for the: undefined reference to `__stginit_upskirtzm0zi0_TextziUpskirtziMarkdownziForeign_' <- when I write C code that calls haskell, to fix those I would add stuff like: hs_add_root(__stginit_prettyzm1zi0zi1zi1_TextziPrettyPrintziHughesPJ_);
17:22:09 <kmc> because of higher-rank type nonsense
17:22:11 <latrene> BMeph, when do you use $ other than a way to get rid of parens?
17:22:16 <hpc> :t foldr (.) ($)
17:22:17 <lambdabot> forall a b. [(a -> b) -> a -> b] -> (a -> b) -> a -> b
17:22:25 <kmc> > map ($ 3) [succ, pred] -- latrene
17:22:26 <lambdabot>   [4,2]
17:22:44 <BMeph> latrene: Look at what hpc and I have been :t'ing for the past ten minutes. :)
17:23:00 <gienah> rostayob: oh: maybe because your bindings have not been registered yet, maybe your examples would be easier if they were in a different package
17:23:17 <latrene> > map 3 [succ, pred]
17:23:18 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:23:18 <lambdabot>    `GHC.Enum.Enum a'
17:23:18 <lambdabot>      ar...
17:23:36 <hpc> :t flip
17:23:36 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:23:46 <rostayob> gienah: my example is not in the same package, I've just "cabal install"ed my library and then tried to use it
17:23:52 <BMeph> > map ($3) [succ, pred] -- Did you mean this, latrene? ;)
17:23:53 <lambdabot>   [4,2]
17:23:59 <hpc> in lambdabot, flip = \fs x -> fmap ($ x) fs
17:24:06 <latrene> lol yes
17:24:38 <BMeph> hpc: So, flip = flip . flip id? ;þ
17:24:50 <hpc> BMeph: so it would seem
17:24:51 <hpc> :D
17:25:11 <BMeph> ...or is that flip id . flip?
17:25:21 <hpc> sections of ($) like ($ x) segue rather nicely into Cont
17:25:35 <hpc> ($ x) stores x, but in the context of applying it to another function
17:25:51 <hpc> :t flip . flip id
17:25:51 <lambdabot> forall a b a1. a1 -> a -> (a1 -> a -> b) -> b
17:25:56 <hpc> :t flip id . flip
17:25:58 <lambdabot> forall b (f :: * -> *) a b1. (Functor f) => f (a -> b1) -> ((a -> f b1) -> b) -> b
17:26:57 <latrene> well this has been educational
17:27:00 <latrene> thanks, all
17:27:12 <kmc> :)
17:28:35 <BMeph> hpc: Sorry, it's flip = flip (fmap . flip id)
17:29:09 <michaelnorrish> Style question: how can I improve http://hpaste.org/46547/a_novices_attempt_at_an_x_eve
17:29:23 <michaelnorrish> I'm an SML programmer normally, and you can probably tell.
17:29:35 <michaelnorrish> (hpaste did tell me about "when", which was nice.)
17:30:18 <hpc> :t flip (fmap . flip id)
17:30:19 <lambdabot> forall b (f :: * -> *) a. (Functor f) => f (a -> b) -> a -> f b
17:30:22 <rostayob> gienah: oh wait. If I add to the Exposed-modules all the modules it works.
17:31:43 <adamvh> So, when I'm using the Applicative Parsec interface, how do I handle
17:31:45 <adamvh> "count"
17:31:51 <adamvh> if I have to parse the integer argument?
17:32:10 <gienah> rostayob: great
17:32:26 <monochrom> I wonder if "a == XAtm.wM_NAME" is another pattern match, i.e., "case a of XAtm.wM_NAME -> ..."
17:32:37 <adamvh> I can wrap my head around it in do notation
17:32:52 <adamvh> but I'm running up against a wall of how to do it in Applicative
17:32:55 <michaelnorrish> a case inside another case?
17:33:09 <monochrom> yes
17:33:11 <hpc> you can also use guards, and where
17:33:16 <rostayob> gienah: how come? shouldn't I be able to hide modules?
17:33:23 <c_wraith> adamvh: well, applicative is strictly less powerful than monad.  you might have found one of the reasons why.
17:33:27 <michaelnorrish> I was wondering how to get guards in on the story.
17:33:28 <hpc> foo x | x == z = blah
17:33:35 <hpc>       | otherwise = fuzz
17:33:43 <adamvh> c_wraith: huh
17:33:47 <hpc>     where z = somethingWith x
17:34:03 <Watermind> is there any special name for     \f -> f . f
17:34:04 <michaelnorrish> Can I introduce guards after a case?
17:34:27 <hpc> Watermind: join = \f x -> f x x
17:34:28 <adamvh> c_wraith: I was trying to do something like
17:34:33 <hpc> Watermind: your thing = join (.)
17:34:34 <adamvh> getN p = flip count p <$> natural
17:34:50 <BMeph> michaelnorrish: Sorry, only your uncle, chucknorrish, can do that. ;þ
17:34:58 <adamvh> but slotting "getN p" into my other parser is failing
17:34:59 <michaelnorrish> BMeph: lol
17:35:07 <adamvh> since it's under two levels of monad
17:35:26 <michaelnorrish> I seem to have too many levels of control-structure (case, let, if ...)
17:35:29 <c_wraith> adamvh: yes, if you get two levels, that's exactly what Applicative isn't powerful enough to handle.
17:35:34 <Watermind> hpc: man that was impressive
17:35:55 <c_wraith> adamvh: because what Monad gives you that Applicative doesn't is join :: m (m a) -> m a
17:36:26 <adamvh> c_wraith: So does that mean that I have to use do notation for that kind of thing?
17:36:48 <hpc> adamvh: or just use join as a combinator
17:36:49 <monochrom> 5 birds in one case: case ev of PropertyEvent{ev_window=w, ev_event_display=d, ev_atom=XAtm.wM_NAME} -> do ...
17:36:57 <geheimdienst> michaelnorrish: you could get rid of the case-of if you say: f (PropertyEvent {}) = ... ; f _ = return $ All True
17:36:58 <kmc> you never have to use do notation
17:37:01 <geheimdienst> ... and what monochrom said :)
17:37:16 <adamvh> hpc: so basically just `join`?
17:37:21 <kmc> it is just syntactic sugar for the operator (>>=)
17:37:22 <michaelnorrish> monochrom: v. nice!
17:37:24 <hpc> :P
17:37:33 <adamvh> Or is there a synonym described somewhere for it?
17:37:42 <adamvh> á la <*> and friends
17:38:27 <monochrom> I rarely spot such non-peephole simplifications, actually
17:38:41 <hpc> adamvh: no such luck, unfortunately
17:38:46 <hpc> :t (><)
17:38:47 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
17:39:00 <gienah> rostayob: it seems haskell wants the FFI stuff to be exposed
17:39:11 <hpc> actually, since join takes one parameter, using a symbolic operator wouldn't be very productive
17:39:14 <michaelnorrish> Sadly,  Qualified name in binding position: XAtm.wM_NAME
17:39:15 <adamvh> Well, now I feel less dumb, anyways!
17:40:09 <jnhnum1> how would you write an efficient while loop in the ST monad?  Everything I can think of now involves a thunk getting really huge
17:40:21 <monochrom> yikes, wM_NAME is not a data constructor, sorry
17:40:41 <monochrom> 5 birds in one case: case ev of PropertyEvent{ev_window=w, ev_event_display=d, ev_atom=a} | a==XAtm.wM_NAME -> do ...
17:40:42 <michaelnorrish> Right, so the equality test is going to have to end up in a guard or if-test I guess
17:40:43 <rostayob> gienah: yeah, I just found out about other-modules ..
17:41:04 <adamvh> I almost had it: join getN p = flip count p <$> natural typechecks correctly
17:41:05 <aavogt> michaelnorrish: or a view pattern
17:41:19 <adamvh> or rather
17:41:25 <monochrom> so, also sorry for suggesting "case a of XAtm.wM_NAME" because I forgot that XAtm.wM_NAME was a variable
17:41:26 <adamvh> getN p = join flip count p <$> natural
17:41:53 <monochrom> there is, in fact, one case for 6 birds...
17:42:10 <joe6> @hoogle isSuffixOf
17:42:10 <lambdabot> Data.ByteString isSuffixOf :: ByteString -> ByteString -> Bool
17:42:11 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
17:42:11 <lambdabot> Data.ByteString.Char8 isSuffixOf :: ByteString -> ByteString -> Bool
17:42:11 <michaelnorrish> urk, why I am now getting " Not in scope: `when'"
17:42:14 <geheimdienst> actually i find that kinda weird about haskell syntax ... you write: let <name you're making up> = <existing stuff>. but here it's reversed: f (Event { <existing stuff> = <name you're making up> })
17:42:26 <hpc> michaelnorrish: import Control.Monad
17:42:28 <geheimdienst> michaelnorrish: are you importing Control.Monad?
17:42:29 <kmc> record syntax is just terrible
17:42:35 <jnhnum1> possible answer to my own question: do you use runST and then do something tail recursive?  is that always applicable?
17:42:41 <michaelnorrish> No, but it worked before.
17:42:54 <michaelnorrish> (Or perhaps it didn't, and I didn't notice the xmonad recompilation error.)
17:43:10 <kmc> jnhnum1, you'd put the loop inside the runST, no?
17:43:47 <kmc> an idiom i like for looping is:   fix $ \loop -> do ...; when (whatever condition) loop
17:43:50 <jnhnum1> well I don't know - how would you, say, use the ST monad to sum the numbers from 1 to n in a constant-space way?
17:43:57 <michaelnorrish> Urk, I think it thinks it's in a different monad now.
17:43:59 <kmc> you don't need ST to do that
17:44:01 <jnhnum1> (even though yes I know)
17:44:04 <kmc> ok
17:44:04 <jnhnum1> you don't need ST to do that
17:44:18 <kmc> then my stupid answer will involve only "return"
17:45:02 <monochrom> michaelnorrish: my final mutilation http://hpaste.org/paste/46547/6_birds_in_one_equation#p46548 or just reload and scroll down
17:45:59 <kmc> jnhnum1, mapM gives you a simple loop
17:46:03 <kmc> (for example)
17:46:13 <kmc> or forM = flip mapM
17:46:21 <kmc> :t runST $ forM [1..20] ?x
17:46:21 <lambdabot>     Could not deduce (?x::t -> ST s b) from the context ()
17:46:21 <lambdabot>       arising from a use of implicit parameter `?x'
17:46:21 <lambdabot>                    at <interactive>:1:21-22
17:46:30 <hpc> :t forM
17:46:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
17:46:36 <kmc> :t runST $ forM [1..20] return
17:46:37 <lambdabot> forall t. (Enum t, Num t) => [t]
17:46:55 <jnhnum1> jnhnum1: but mapM isn't constant space, is it?
17:47:14 <hpc> > forM [1..10] (\x -> Just (x+2))
17:47:14 <lambdabot>   Just [3,4,5,6,7,8,9,10,11,12]
17:47:27 <geheimdienst> monochrom: could we turn line 11 (W.focusWindow w . W.shiftWin "²mail" w) into: (W.focusWindow >> W.shiftWin "²mail")?
17:47:28 <michaelnorrish> monochrom: no good: http://hpaste.org/46550/error_for_monochroms_code
17:48:14 <geheimdienst> michaelnorrish: have you tried putting a $ before windows?
17:48:44 <michaelnorrish> Ah!
17:48:50 <monochrom> I don't know
17:49:02 <michaelnorrish> That's better.
17:49:28 <geheimdienst> (the thing to look for is line 3 of the error: In the second argument of `when', namely `windows'. it thought that "windows" alone is the 2nd arg, but you want it to be the whole "windows (W.focus...)" )
17:49:41 <michaelnorrish> geheimdienst: where's it going to pick up the "w" argument from?
17:50:04 * geheimdienst waves his hands non-comittally
17:50:18 <jnhnum1> kmc: do you get what I mean by the constant space requirement? like it's my understanding that with the forM_ function, it will expand the whole loop into a giant piece of code before it evaluates it
17:50:23 <geheimdienst> you're right. it works only in keybindings and the like :)
17:50:24 <michaelnorrish> Absolutely: learning a language also requires one to learn the compiler's error reporting :)
17:50:28 <geheimdienst> not in your use
17:50:38 <jnhnum1> as opposed to running the same line of code in a different context a lot of times
17:51:01 <jnhnum1> (there's also the issue of the range expression involving unnecessary allocation, but I'll ignore that for now)
17:51:17 <hpc> jnhnum1: it only expands the whole loop if (>>=) is strict in your monad
17:51:22 <monochrom> how do you know that forM_ expands into a giant piece of code
17:51:34 <monochrom> "where is your data?" etc
17:51:41 <hpc> > forM_ [1..] (\x -> Just x)
17:51:44 <lambdabot>   mueval-core: Time limit exceeded
17:51:52 <jnhnum1> ok, I see
17:53:31 <hpc> > forM_ [1..] (\x -> [x])
17:53:32 <lambdabot>   *Exception: stack overflow
17:53:45 <hpc> how much memory does lambdabot give to mueval?
17:53:55 <shachaf> hpc: ALL OF IT.
17:54:34 * hackagebot upskirt 0.0.1 - Binding to upskirt  http://hackage.haskell.org/package/upskirt-0.0.1 (FrancescoMazzoli)
17:54:41 <shachaf> I've never seen it fail due to an out-of-memory error. I wonder if it reports those as timeouts.
17:57:42 <adamvh> @src join
17:57:42 <lambdabot> join x =  x >>= id
17:58:01 <c_wraith> that's the more-opaque version of it.
17:58:09 <geheimdienst> :t join
17:58:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:58:18 <c_wraith> :t \x -> do { x' <- x ; x' }
17:58:19 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
17:58:45 <c_wraith> that version is the exact same thing, but easier to read if you're comfortable with do notation.
17:59:18 <geheimdienst> join = smishify an IO (IO x) together into an IO x
17:59:42 <shachaf> geheimdienst: More like smishify an (r -> r -> x) together into an (r -> x).
17:59:54 <geheimdienst> yes yes, works for other monads too
18:00:13 <shachaf> Including (r ->).
18:00:33 <geheimdienst> (r ->) scares me. i don't know about that.
18:00:49 <c_wraith> :t join (*)
18:00:50 <lambdabot> forall a. (Num a) => a -> a
18:00:57 <c_wraith> > join (*) 5
18:00:58 <lambdabot>   25
18:01:06 <shachaf> geheimdienst: (r ->) is like a burrito.
18:01:21 <geheimdienst> shachaf, thanks for clearing that up
18:01:44 <parcs> @src Reader
18:01:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:02:36 <adamvh> Man, my endless struggles with type errors stemming from operator precedence is making me miss Lisp
18:02:39 <adamvh> just a tiny bit
18:03:04 <shachaf> adamvh: Feel free to write your code LISP-style.
18:03:14 <adamvh> I'm considering it
18:03:34 <jnhnum1> how is this as an implementation of a while loop: http://hpaste.org/46552/monadic_while_loop
18:03:36 <adamvh> Perhaps I should look into Typed Racket - do you know how it compares to Haskell?
18:04:01 <parcs> inferior. :P
18:04:11 <monochrom> it works
18:04:26 <hpc> jnhnum1: you could make it return the value of the last executed body
18:04:38 <hpc> wait, nvm
18:04:43 <dolio> Isn't it, "let's layer types on top of scheme"?
18:06:20 <adamvh> dolio: that impression is what kept me away
18:06:35 <kmc> i'm going to say "too different for an easy comparison"
18:07:01 <sdbo> I have a question about using overlapping instances or fundeps in order to specialize classes on some types
18:07:39 <dolio> adamvh: It doesn't sound interesting to me, either. But there are quite a few people who are interested in hybrid languages that combine unchecked and checked portions.
18:08:07 <dolio> Which is the arena they're in.
18:08:29 <sdbo> Basically, how can you/do you do it? I want to have an instance that works both over general types and one that'll take over for Char and Int
18:14:29 <mm_freak_> i like the way acid-state works, but it seems very immature right now
18:15:18 <mm_freak_> the problems already start, when your transactions have too many (>>=)
18:15:39 <mm_freak_> but that seems to be a problem of mtl's State, not of acid-state
18:16:57 <djanatyn> Hmm.
18:17:22 <djanatyn> I'm guessing most people wouldn't recommend "Write Yourself a Scheme in 48 Hours" as a good introductory Haskell textbook :)
18:17:40 <shachaf> djanatyn: I seem to remember it as being pretty confusing.
18:17:50 <shachaf> djanatyn: Feel free to write yourself a Scheme without it, though. :-)
18:18:03 <kmc> yeah, implementing a little functional language is a great Haskell exercise
18:18:07 <kmc> once you get sick of Project Euler
18:18:12 <kmc> @where cs11
18:18:13 <lambdabot> I know nothing about cs11.
18:18:13 <mm_freak_> i don't know why most haskell introductions try to teach functional programming instead of haskell
18:18:23 <kmc> mm_freak_, because they assume nobody learns FP in school
18:18:28 <kmc> which is largely true
18:18:29 <hpc> and with good reason
18:18:37 <kmc> most CS courses will teach you four kinds of Java
18:18:43 <mm_freak_> yes, but there is no good tutorial to doing real world stuff in haskell
18:18:45 <hpc> haha
18:18:47 <jnhnum1> blargh why do I suck so much at using the ST monad / why doesn't this short piece of code work: http://hpaste.org/46556/st_monad_summing
18:18:59 <hpc> @remember kmc most CS courses will teach you four kinds of Java
18:18:59 <lambdabot> I will remember.
18:19:32 <kmc> mm_freak_, RWH? ;P
18:19:38 <dibblego> functional programming is much harder to learn and teach than haskell
18:19:45 <kmc> @where+ cs11 http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
18:19:46 <lambdabot> Okay.
18:19:48 <kmc> i like these exercises
18:19:59 <mm_freak_> jnhnum1: perhaps because of laziness?
18:20:08 <mm_freak_> i don't see any obvious code errors
18:20:35 <mm_freak_> kmc: does RWH teach writing concurrent applications?  if yes, does it do that well?
18:20:48 <kmc> yes resp. don't know
18:20:49 <jnhnum1> oh apparently it's because I left out Ord a
18:21:04 <kmc> it does cover both "vanilla" concurrency and STM
18:21:04 <mm_freak_> indeed
18:21:08 <jnhnum1> I got intimidated by a really long error message that wasn't actually so bad
18:21:20 <MaskRay> ~/.cabal/lib/unix-2.4.2.0/ghc-6.12.3/HSunix-2.4.2.0.o: unknown symbol `rtsTimerSignal'
18:21:37 <mm_freak_> jnhnum1: btw, you can write "A a => B b =>" as "(A a, B b) =>"
18:22:15 <mm_freak_> kmc: i needed a long time to find real uses for STM, until i found out that most of my code would be more elegant with STM
18:22:40 <kmc> more obviously correct too
18:22:57 <mm_freak_> that's because i have read many introductions on how to use STM
18:22:58 <kmc> since you just say "make this atomic" rather than having to invent a complex locking protocol to make it so
18:23:05 <mm_freak_> but none of them covered /where/ to use it
18:31:21 <jnhnum1> so while still using ST, how do I get rid of the memory leak / stack overflow error in this code: http://hpaste.org/46558/stack_overflow_summation
18:32:22 <kmc> i believe modifySTRef is building a thunk of ((((a+1)+1)+1)+...)
18:32:40 <dolio> The one that adds up 1 isn't a problem. The other one is.
18:32:51 <kmc> oh, because that one is forced by comparison to b
18:33:00 <dolio> Right.
18:33:04 <kmc> there ought to be a strict version of modifySTRef
18:33:08 <kmc> but you can anyway define it
18:37:28 <sdbo> How can I make CharCountMap be used when a = Char : http://hpaste.org/46560/how_can_i_make_charcountmap_sp?pid=46560&lang_46560=Haskell
18:39:05 <jnhnum1> how would I define a strict version of modifySTRef?
18:41:26 <jnhnum1> it seems like just using bangpatterns isn't good enough because what I actually need to be strict isn't the evaluation of the arguments to modifySTRef
18:41:29 <jnhnum1> right?
18:41:38 <c_wraith> you need to strictify the second arg
18:42:13 <c_wraith> modifySTRef' r a = modifySTRef r $! a
18:43:03 <dons> there's no way to write a strict version of those modify functions
18:43:14 <dons> you have to read the value out to make it strict (or rewrite the functions)
18:43:31 <c_wraith> oh.  f
18:43:36 <c_wraith> yeah, you do
18:43:48 <c_wraith> I was thinking writeSTRef
18:44:22 <jnhnum1> so how do I get rid of the stack overflow problems here :(
18:44:49 <monochrom> @remember geheimdienst haskell makes hard things easy and easy things a strong lax monoidal endofunctor ...
18:44:49 <lambdabot> Done.
18:45:13 <dons> jnhnum1: you read the value immediately after the modification. e.g. ..modify .. ; !x <- readSTRef x
18:45:18 <dons> which forces the contents
18:45:25 <kmc> oh, that's simple
18:45:37 <kmc> you can also write the strict modify function, but not in terms of the lazy one
18:45:41 <dons> you can rewrite modifyIORef (but not atomicModifyIORef)
18:45:54 <mm_freak_> dons: why is there no way?  the obvious way would be:  readSTRef var >>= \x -> let y = f x in y `seq` writeSTRef var y
18:45:56 <c_wraith> modifySTRef' r f = do { x <- readSTRef r ; let x' = f x ; writeSTRef r $! x' }
18:45:59 <dons> see this thread from a few years ago http://www.haskell.org/pipermail/haskell-cafe/2009-June/063143.html
18:46:11 <dons> mm_freak_: yes, you can write your own strict version
18:46:11 <c_wraith> mm_freak_: the point is it can't be done in terms of the lazy one
18:46:13 <mm_freak_> you need to force on binding, not on application
18:46:18 <dons> but you can't use the existing one, and make it strict.
18:46:18 <jnhnum1> oh god...so complicated.  will this at least be compiled down into something efficient?
18:46:25 <kmc> probably
18:46:32 <dons> jnhnum1: yeah, they're just direct reads from memory
18:46:34 <kmc> it's not that complicated
18:46:37 <mm_freak_> yes, but you can at least force the last value before updating
18:46:51 <dons> use c_wraith's function above
18:47:12 <mm_freak_> jnhnum1: the efficiency will be decend, approaching C speed
18:47:17 <mm_freak_> decent
18:47:19 <dons> the docs for modify* family of functions should talk about these issues
18:47:30 <dons> same applies to IORefs, MVars and so on.
18:47:56 <kmc> the bigger problem is that you can't make atomicModifyIORef strict without seriously degrading its performance
18:47:59 <dons> test programs: http://www.haskell.org/pipermail/haskell-cafe/2009-June/063139.html
18:48:03 <dons> kmc: indeed. it has to be lazy
18:48:05 <mm_freak_> dons: i don't think they need to, because haskell is a lazy language, so you should naturally expect that
18:48:15 <dons> so if you care about strict atomicity, use MVars from the strict package
18:48:26 <monochrom> @quote monochrom faster
18:48:26 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
18:48:43 <dons> mm_freak_: well, my argument is that most uses of these cell-upating functions are intended to be NF strict
18:48:52 <geheimdienst> monochrom: can c be faster than c?
18:48:56 <dons> the lazy versions are useful, but mostly not what people want
18:48:59 <dons> so the default is wrong
18:49:20 <mm_freak_> unfortunate for most people, but not wrong…  it is very fortunate for me
18:49:34 <dons> its key to the io manager queue, in the rts as well
18:49:40 <dons> you have to have very fast atomic sections
18:49:45 <dons> so do as little eval as possible
18:51:54 <mm_freak_> there should be a way to tell the RTS to run a certain set of threads always in the same OS thread
18:52:09 <mm_freak_> like a forkOS for multiple threads
18:52:10 <kmc> why?
18:52:22 <kmc> forkOS doesn't give you any guarantee about where your Haskell thread runs
18:52:30 <kmc> it only guarantees that FFI calls come from the same thread
18:52:36 <mm_freak_> kmc: because if the threads communicate a lot, then the performance is better, when they run in the same OS thread
18:55:16 <jnhnum1> so when I actually tested the ST summing code above, it was about 36 times slower than C :( (this is compiling with -O2 and -fllvm)
18:55:41 <kmc> how does it compare to the simple functional sum?
18:55:44 <jnhnum1> I wish I were better at reading assembly / core so I could figure out what's going on
18:55:57 <mm_freak_> jnhnum1: likely the fastest summing code will be the one with explicit recursion
18:56:44 <mm_freak_> jnhnum1: don't expect C programs written in haskell to perform like they were written in C…  the converse is also true
18:56:45 <jnhnum1> the simple functional sum (sum [1..100000000]) is a litle faster than with ST
18:56:55 <jnhnum1> 30 times slower than C sitll though
18:56:58 <mm_freak_> try:  fold' (+) 0
18:57:01 <mm_freak_> foldl'
18:57:21 <mm_freak_> and compile the code with -O
18:57:25 <mauke> jnhnum1: is that Int or Integer?
18:57:33 <jnhnum1> but why shouldn't C programs written in haskell be able to perform like they were written in C
18:57:33 <mauke> mm_freak_: what's wrong with -O2?
18:57:47 <jnhnum1> oh my bad about the Int vs Integer thing
18:58:18 <jnhnum1> when I just use an Int the functional version is about 3 or 4 times slower than C
18:58:49 <mauke> jnhnum1: does the C program produce the correct result?
18:58:59 <jnhnum1> it seems like the compiler should (probably?) be able to do a good job reducing the code to the same ish assembly
18:59:04 <jnhnum1> mauke: yeah they make the same results
18:59:27 <monochrom> with 64 bits it may produce the correct answer. it's wimpy summing
18:59:33 <mm_freak_> mauke: i didn't mean to imply that -O2 is worse than -O
18:59:41 <mm_freak_> but -O should suffice most of the time
18:59:47 <argiopeweb> jnhnum1: Probably. You could check it. Wouldn't account for GC time though.
18:59:59 <argiopeweb> jnhnum1: Try running with +RTS -s and see what's up.
19:02:17 <jnhnum1> +RTS -s info: http://hpaste.org/46561/sum_profiling_info
19:02:35 <jnhnum1> what's MUT?
19:03:12 <mm_freak_> jnhnum1: my C version takes around 170 ms, while my haskell version takes around 340 ms
19:03:16 <argiopeweb> Main execution time. It has a real term it stands for...
19:03:17 <mm_freak_> in average
19:03:25 <mm_freak_> for summing 100 to 100000000
19:03:45 <argiopeweb> jnhnum1: Which code are you using for that one?
19:03:53 <jnhnum1> I was using the ST version
19:04:17 <jnhnum1> um I'll upload a new paste one sec
19:05:00 <jnhnum1> http://hpaste.org/46562/profiled_sum is what I profiled
19:05:22 <jnhnum1> is there a way (while still using the ST monad) of reducing this ridiculous amount of allocation?
19:06:34 <jnhnum1> also is allocation (not GC) time included in MUT?
19:06:41 <argiopeweb> Yes
19:06:54 <argiopeweb> And which rediculous amount are you talking about?
19:07:29 <argiopeweb> ridiculous*
19:07:29 <argiopeweb> Spelling... Pshaw.
19:08:24 <jnhnum1> like
19:08:27 <jnhnum1> the 20 GB
19:08:34 <jnhnum1> in http://hpaste.org/46561/sum_profiling_info
19:09:41 <jnhnum1> is that the cause of the poor performance?
19:10:18 <parcs> @src sum
19:10:18 <lambdabot> sum = foldl (+) 0
19:11:33 <argiopeweb> jnhnum1: That's heap allocation. Nothing to worry about there. It happens. It's good to have it low, but if it doesn't effect performance you're good.
19:11:44 <argiopeweb> Maximum Residency is the one for concern.
19:12:07 <jnhnum1> does it affect performance though?
19:12:30 <gwern> @quote performance
19:12:31 <lambdabot> ndm says: performance is such an old concern
19:12:40 <argiopeweb> I'm sure it does, but the one I just wrote allocated 8gb and runs in 0.11 seconds...
19:13:10 <argiopeweb> The way to duplicate C loops in functional languages is via accumulator-based tail recursion.
19:13:46 <mm_freak_> argiopeweb: no, that's /one/ way, but by far not /the/ way
19:14:00 <jnhnum1> what if the body of a loop isn't just updating a single value like this toy example though, and instead is updating an array?
19:14:06 <mm_freak_> in haskell, in fact, it's almost always the wrong way
19:14:06 <argiopeweb> mm_freak_: This is true, but in the general case it's the fastest way.
19:14:22 <argiopeweb> mm_freak_: If you're going strictly on clock-time performance.
19:14:23 <jnhnum1> then then a tail recursive approach would involve a lot of copying of some immutable array
19:14:35 <jnhnum1> so I'd like to instead use a loop that updates the vector
19:14:41 <jnhnum1> but I need to know how to make loops efficient!
19:14:53 <argiopeweb> Well then you need to rethink your algorithm, because arrays in tight loops is not cool in Haskell.
19:15:06 <mm_freak_> usually when you write your code in the most idiomatic way in haskell, you will also get the best or at least good performance
19:15:23 <mm_freak_> there is no reason to force yourself to use a less elegant approach
19:15:38 <jnhnum1> that's what everybody always says, but for example dijkstra's algorithm
19:15:49 <jnhnum1> is a really foundational algorithm
19:15:57 <jnhnum1> but I don't know of any good way to implement it efficiently in haskell
19:16:14 <mm_freak_> jnhnum1: there is nothing wrong with having an imperative loop in haskell
19:16:22 <mm_freak_> most idiomatic /= never imperative
19:16:41 <kmc> <mm_freak_> usually when you write your code in the most idiomatic way in haskell, you will also get the best or at least good performance  <---- uh, no
19:16:48 <argiopeweb> mm_freak_: http://hpaste.org/46563/loops
19:16:52 <argiopeweb> Case in point.
19:17:03 <kmc> "at least good" may hold, especially if you're used to Python or PHP or the like
19:17:12 <kmc> GHC can beat typical Python or PHP interpreters by a factor of 100 without trying
19:17:37 <kmc> "best" is pretty dubious
19:17:45 <kmc> look at the Shootout code and tell me if it's idiomatic Haskell
19:17:59 <argiopeweb> mm_freak_: I might add that without strict foldl, it takes less time running, but picks up .4 in GC
19:18:16 <mm_freak_> kmc: i'd say many of the implementations i've seen in the shootout were not even close to optimal
19:18:19 <jnhnum1> mm_freak_: so what's the most idiomatic / best way to implement Dijkstra's algorithm
19:18:28 <djahandarie> kmc, some of them are actually decent
19:18:30 <kmc> mm_freak_, then i think people would very much welcome improvements
19:18:41 <djahandarie> It's actually the one that perform like shit that tend to look terrible
19:18:45 <mm_freak_> jnhnum1: i don't know that one
19:18:49 <kmc> also some of them are cruftified because they were written against older GHC
19:19:01 <kmc> while newer GHC will do those optimizations automatically or not need them
19:19:04 <djahandarie> Yeah
19:19:22 <djahandarie> I'd like to see the LLVM stuff become availiable for those shootouts. I feel like it'd definitely help a lot on some
19:19:23 <kmc> but still, i would classify GHC Haskell as a language where you can write pretty fast code, and get it working quickly, and then focus on optimizing the tricky parts
19:19:30 <kmc> (and probably make it less pretty in the process)
19:19:43 <kmc> you can even use your old implementation as an automated test-case generator for the new one
19:21:13 <mm_freak_> jnhnum1: i've looked at the algorithm, and it seems to be a candidate for a zipper
19:21:19 <mm_freak_> but i'm not sure, as i've never implemented it
19:21:21 <argiopeweb> jnhnum1: I've never actually done Dijkstra's algorithm in Haskell... Random guess says that a custom data type is in order (because that's the case for everything. ;))
19:21:48 <kmc> i do agree with the statement that imperative code is not necessarily non-idiomatic
19:22:09 <kmc> a lot of effort has been invested in first-class imperative programming in Haskell
19:22:16 <kmc> you should feel free to use it when it's the most suitable tool
19:22:47 <mm_freak_> jnhnum1: using one of the common graph libraries it's unlikely that you get good performance with an imperative approach, while the functional approach may work very well
19:23:00 <kmc> and you can use functional techniques in your imperative code
19:23:15 <argiopeweb> jnhnum1: Oh, that's nice.... It's in Data.Graph.Inductive.Query.SP.
19:23:17 <Gwern-away> @quote idiom
19:23:17 <lambdabot> ChrisKuklewicz says: Are there little known Haskell idioms for doing math? Is there an undocumented -funleash-fortran parameter?
19:23:23 <argiopeweb> jnhnum1: http://hackage.haskell.org/packages/archive/fgl/latest/doc/html/src/Data-Graph-Inductive-Query-SP.html#dijkstra for source.
19:23:59 <jnhnum1> argiopeweb: ok, I'll take a look at that code
19:23:59 <kmc> heh, GHC should accept -funleash-fortran as an alias for turning on DPH
19:24:29 <argiopeweb> jnhnum1: It seems pretty dense, but a couple of extra windows with the hackage pages for Graph and Heap should get you there. ;)
19:28:14 <Gwern-away> > 770 + 884 + 270
19:28:15 <lambdabot>   1924
19:28:45 <dylukes> Dear #haskell, do your worst
19:28:46 <dylukes> http://memegenerator.net/Haskell-Curry
19:28:57 <adamvh> argiopeweb: you weren't kidding about it being dense
19:29:11 <argiopeweb> adamvh: Nope. Pretty much all the good stuff is in there.
19:29:47 * hackagebot iteratee 0.8.3.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.3.0 (JohnLato)
19:30:18 <argiopeweb> Even without going into Graph/Heap, you've got a custom data structure, pattern matching, the p@(<pattern>) notation, recursion... All sorts of good stuff. :P
19:30:37 <argiopeweb> Guards.
19:33:11 <mm_freak_> apropos iteratee…  what's the advantage of having CPS-transformed iteratees?
19:33:18 <argiopeweb> Apparently I can't walk out of this room if i want to maintain an internet connection. :\
19:33:27 <kmc> dylukes, just as long as /r/haskell doesn't fill up with these ;P
19:33:37 <dylukes> kmc: I doubt it.
19:33:51 <geheimdienst> dear #haskell, i have made this for your perusal: http://memegenerator.net/instance/7710889
19:36:19 <kmc> hahaha
19:40:47 <ddarius> geheimdienst: Haskell was dead before Haskell took his name, and according to Mary Virginia Curry, he didn't really like the name Haskell.
19:44:57 <NihilistDandy> @where+ wtfmonad http://memegenerator.net/instance/7710889
19:44:57 <lambdabot> Done.
19:45:25 <thorat> Is it possible to get the System FC internal representation of function?
19:46:01 <kmc> from GHC?
19:46:08 <thorat> yes
19:46:09 <geheimdienst> ddarius: well, "what if he said that". these pictures are hypothetical. if you see "trapd in io monad plz halp" on the picture of a cat, it does not mean that this cat actually said that. no cat ever says anything, cats don't talk. the picture is to be taken as "what if she said that"
19:46:17 <kmc> thorat, GHC doesn't use System FC exactly
19:46:22 <kmc> but what you probably want is -ddump-simpl
19:46:26 <thorat> at least ghci isn't able to
19:46:30 <thorat> ah, ok
19:46:33 <thorat> thanks
19:46:34 <kmc> which dumps GHCi's "Core" intermediate language
19:46:39 <thorat> yes, I meant the core
19:46:40 <kmc> or use the ghc-core utility on Hackage
19:46:42 <thorat> right
19:46:48 <jnhnum1> what's a good learning resource for learning how to read core
19:46:53 <kmc> hmm i guess it does pretty much use FC
19:46:57 <kmc> i was confusing FC with Fω
19:46:59 <geheimdienst> it is not necessary to criticize lambdacats for being inaccurate in that cats don't actually talk
19:47:05 <argiopeweb> jnhnum1: Real World Haskell
19:48:29 <ddarius> geheimdienst: How do you know that cats don't talk?
19:48:39 <MatrixFrog> i had no idea that lambdacats was a thing
19:48:54 <geheimdienst> ddarius: it would be on youtube if they did!
19:49:22 <argiopeweb> Flawless logic
19:49:52 <ddarius> @google site:youtube.com cat talking
19:49:53 <lambdabot> http://www.youtube.com/watch?v=1JynBEX_kg8
19:49:53 <lambdabot> Title: YouTube - Re: Cat Talking, Translation
19:50:16 <NihilistDandy> Oh, lawd. lambdacats... the next 10 minutes will be wasted
19:52:31 <geheimdienst> ddarius: i can't believe it, but you seem to have found unassailable proof that cats do talk. you may be in for a nobel prize there.
19:53:22 <monochrom> nobel prize in what? medicine?
19:53:34 <NihilistDandy> Chemistry
19:53:47 <NihilistDandy> Because I'm turned on by his research skills~
19:53:47 <geheimdienst> related: here's what cats really think about humans and how they talk to pets -- http://www.youtube.com/watch?v=pxNg7ZP6E5E
19:54:36 <geheimdienst> monochrom: the alfred nobel prize in gorram kittology
19:54:44 <monochrom> ok!
19:55:02 * ddarius has no idea what the contents of the link google returned are.
19:55:21 <geheimdienst> ddarius: please do yourself a favor and click it
19:55:21 <NihilistDandy> And so modest, too~
19:55:35 <geheimdienst> monochrom: in memory of the damn bank of sweden or somesuch
19:55:46 <kmc> hehe
19:55:48 <kmc> fake nobel prize
19:55:49 * hackagebot http-enumerator 0.6.4.2 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.4.2 (MichaelSnoyman)
20:03:10 <adamvh> How does one inquire after the associativity / precedence of an operator in ghci or from lambdabot?
20:03:25 <shachaf> :i in gdb.
20:03:32 <geheimdienst> @src (+)
20:03:32 <lambdabot> Source not found. :(
20:03:54 <geheimdienst> @src (<$>)
20:03:55 <lambdabot> f <$> a = fmap f a
20:04:03 <geheimdienst> bah
20:04:09 <adamvh> shachaf: I assume you meant ghci...?
20:05:44 <MatrixFrog> how do i get the source of the (</>) operator from System.FilePath
20:06:38 <geheimdienst> matrixfrog, you can click the "source" link on the haddock page, on the right side next to the function
20:06:55 <MatrixFrog> can i get it from lambdabot at all?
20:07:11 <shachaf> @google System.FilePath hs
20:07:11 <geheimdienst> @src (</>)
20:07:13 <lambdabot> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/filepath-1.2.0.0/src/System-FilePath.html
20:07:13 <lambdabot> Title: System/FilePath.hs
20:07:13 <lambdabot> Source not found. Maybe you made a typo?
20:07:21 <geheimdienst> apparently not ...
20:07:49 <adamvh> huh, all of the applicative thingies are left-associative
20:07:51 <adamvh> good to know
20:07:52 <MatrixFrog> :(
20:08:14 * ksf wonders how fast nix could be if it would use a haskell EDSL and a sufficiently smart combination of compiling and interpreting.
20:08:48 <ksf> that is, interpret the leafs (package descriptions), and compile the rest
20:10:33 <ksf> ...the authors mention going statically-typed in their paper, once to catch bugs like passing a perl instead of a ghc to a package description and then to auto-generate (gui) interfaces from the type info
20:12:25 <ksf> nix is great when you see it as a configuration language for a package manager (being pure, lazy and functional), but falls rather short (and apparently slow) when it comes to the aspects that require more general-purpose programming.
20:14:21 <medfly> general programming question: I currently have a single thread doing IO and also computing, what do I need to utilize the OS's scheduling thing (which would probably prioritize the IO)? a separate thread for IO?
20:14:26 <medfly> :3
20:14:41 <ddarius> Just fork threads.
20:14:59 <medfly> is that a yes
20:15:03 <medfly> I'm unsure :o
20:15:28 <ksf> and compile with --threaded
20:15:48 <argiopeweb> If you think you need multiple threads, you can use forkIO and create a new thread, or just par and pseq to create sparks (fine-grained threads)
20:15:58 <argiopeweb> Sounds like you've got a forkIO situation.
20:15:59 <medfly> I want to send this as a suggestion to something I use, not really coding myself ^^
20:16:34 <ksf> you're whoring stackoverflow karma by exploiting #haskell?
20:16:34 <argiopeweb> You use something coded in haskell that isn't open source? <.<
20:16:36 <ksf> smart move.
20:16:37 <argiopeweb> *shock*
20:16:42 <medfly> no no, it's not even Haskell
20:16:48 <argiopeweb> Then why ask here?
20:16:51 <NihilistDandy> lol
20:16:58 <medfly> well, this channel is smart and it's a general question
20:17:00 <argiopeweb> Go to #os or somesuch.
20:17:02 <medfly> I'm not writing any code myself
20:17:17 <medfly> I don't even know what's it's written in, but it sure as hell isn't written in Haskell ;-)
20:17:25 <NihilistDandy> Then go to #programming
20:17:29 <medfly> fine :P
20:17:31 <NihilistDandy> #haskell seems like the wrong place
20:17:35 <NihilistDandy> :p
20:17:35 <ddarius> medfly: Suggest that they use Haskell.
20:17:44 <argiopeweb> ddarius: Good call.
20:18:37 <geheimdienst> http://memegenerator.net/instance/7711882 <- more random silliness
20:18:53 <NihilistDandy> beep blorp
20:19:26 <gwern> @quote
20:19:27 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
20:19:36 <MatrixFrog> (for the ignorant, who is that? is it the person the Haskell language is named after?)
20:19:59 <NihilistDandy> MatrixFrog: Yes.
20:20:03 <NihilistDandy> Haskell Curry
20:20:13 <MatrixFrog> sweet
20:25:17 <geheimdienst> http://memegenerator.net/instance/7712055
20:26:53 * hackagebot dia-functions 0.2 - An EDSL for teaching Haskell with diagrams - functions  http://hackage.haskell.org/package/dia-functions-0.2 (PeterDivianszky)
20:32:14 <geheimdienst> http://memegenerator.net/instance/7712182
20:33:52 <NihilistDandy> All up inside Haskell
20:34:26 <MatrixFrog> dudes and dudettes
20:34:28 <MatrixFrog> let's be inclusive
20:34:47 <MatrixFrog> well, dudes and maybe dudettes
20:35:06 <geheimdienst> dudes and Maybe dudettes. otherwise Just dudes
20:35:17 <geheimdienst> (that didn't make any sense, even by my standards)
20:35:17 <MatrixFrog> that's what i was going for but i wasn't sure how to phrase it
20:35:23 <NihilistDandy> Just dudes and Maybe dudettes
20:35:29 <MatrixFrog> i don't know haskell well enough to make jokes about it just yet
20:35:31 <NihilistDandy> Oh, wait, already been done
20:35:31 <MatrixFrog> or Just yet
20:35:37 <NihilistDandy> Wasn't paying attention
20:36:00 <argiopeweb> DudeDudet a => (Maybe a, Maybe a)
20:37:05 <ivanm> if I have (trace "foo" fromJust) and it's provided a Nothing, the trace should still happen first, right?
20:37:59 <ivanm> nvm, tracked down the location of my bug
20:38:17 * ivanm begins to wish for stack traces, or at least for line numbers in exceptions
20:38:23 <geheimdienst> http://memegenerator.net/instance/7712284
20:38:50 <geheimdienst> http://memegenerator.net/instance/7712313
20:38:52 <ivanm> geheimdienst: *groan*
20:39:26 <geheimdienst> ivanm, my capacity to produce bullshit is limitless, to my knowledge
20:39:38 <geheimdienst> and i have found my calling with this meme generator thing
20:43:26 <ivanm> I think I've worked out a way of writing a monadic interface for graphviz that would look rather close to actual Dot code
20:44:14 <ivanm> but to do so, I'd need to write a Num instance for "Attributes -> DotMonad ()" just so I can write something like `3 [Label="hi"];'
20:44:24 <ivanm> would that be an OK abuse of Num?
20:45:05 <geheimdienst> ivanm: i'm not sure if this man here will like your monadic interface http://memegenerator.net/instance/7710889
20:46:08 * ddarius ponders what a combinatory logic for S5 would look like.
20:46:28 * argiopeweb just found a Lambda Electronics power supply in a long-forgotten box...
20:46:35 <ivanm> geheimdienst: even with adblock turned off, that page is just full of black and white rectangles for me...
20:46:42 <ivanm> ddarius: as in the presentation format?
20:47:03 <ddarius> As in the modal logic to which monads correspond.
20:47:15 <ivanm> oh, different S5 then
20:47:43 <ivanm> where does that name come from?
20:47:53 <ivanm> oh, fifth system developed?
20:48:17 <ddarius> Wouldn't that be SysV?
20:48:34 <argiopeweb> That's the 'V'th system developed, duh. <.<
20:48:44 <geheimdienst> sixth system developed will be S5 2.0
20:48:56 <danharaj> will it be web scale?
20:49:23 <Mathnerd314> ivanm: you need memegenerator.net and webserver.imagesauce.net.
20:49:29 <argiopeweb> We'll use AJAX to visualize the data in our GUI we'll build with visual basic!
20:49:33 <ivanm> Mathnerd314: for?
20:49:43 * ivanm goes back to trying to understand the gnarly, undocumented planar graph code he wrote at the end of last year
20:49:44 <NihilistDandy> argiopeweb: Will we be able to track an IP?
20:49:55 <Mathnerd314> ivanm: for the pics geheimdienst posted
20:50:00 <argiopeweb> NihilistDandy: You'd better believe it. After all, I'm fluent in 1337.
20:50:06 <ivanm> Mathnerd314: I turned adblock off completely though...
20:50:26 <Mathnerd314> ivanm: do you have JS turned off or something?
20:50:32 <ivanm> shouldn't do
20:50:41 * argiopeweb thinks it's epicly cool that his new apartment has the street address 1337.
20:51:12 <zomg> argiopeweb: nice :D
20:51:39 <zomg> at one of my previous jobs, I got to choose a PIN number for the key fob to the office building
20:51:44 <argiopeweb> It's probably a bit sad that I'm legitimately excited about that, but meh.
20:51:52 <zomg> I used "1337"... The guard didn't even wince. Apparently he wasn't a nerd :D
20:51:59 <argiopeweb> rofl... Nice
20:52:16 <ivanm> zomg: so we now know how to break into anything you needed to set a 4-digit number for?
20:52:28 <zomg> haha, maybe
20:52:33 <argiopeweb> And yeah, apparently not. You've at least got to go "Heh..." under your breath when people do that.
20:52:34 <zomg> although I haven't used the same one for anything else :P
20:52:57 <ddarius> @google Modal Types for Mobile Code
20:52:59 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.141.5953&rep=rep1&type=pdf
20:52:59 <lambdabot> Title: cache:http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.141.5953&rep=rep1 ...
20:53:43 <ddarius> argiopeweb: I would smack someone who did that.
20:55:27 <argiopeweb> ddarius: Also an acceptable choice. :P
20:55:38 <geheimdienst> http://memegenerator.net/instance/7712633
20:58:31 <geheimdienst> http://memegenerator.net/instance/7712677
21:00:37 <ddarius> geheimdienst: If only your mother could see you now.
21:03:02 <potato> Does Haskell have an analogue of ML's signatures?
21:03:24 <potato> I tried Google but couldn't find much...
21:04:48 <ddarius> No.
21:04:58 <ddarius> It should, but it doesn't.
21:05:20 <jmcarthur> potato: nothing that sophisticated. only a very naive module system and type classes
21:05:48 <potato> That's very disappointing.  And frankly, somewhat disappointing.
21:06:11 <potato> somewhat surprising*
21:06:19 <ddarius> (Note that by Haskell "should have signatures" I don't mean to imply that it should have the entirety of ML's module system, just a way to specify an interface for a module.
21:06:20 <ddarius> )
21:06:30 <potato> Right, I got that.
21:07:00 <danharaj> ddarius: could something like that be added orthogonally?
21:07:08 <potato> Do you know of any plans to add something like that?
21:09:03 <ddarius> danharaj: It would just be formalizing something like hte hs-boot files.
21:09:58 * hackagebot dia-functions 0.2.1 - An EDSL for teaching Haskell with diagrams - functions  http://hackage.haskell.org/package/dia-functions-0.2.1 (PeterDivianszky)
21:11:23 * argiopeweb ponders doing away with gnome integration when he reinstalls xmonad in a week or two
21:13:43 <danharaj> ddarius: ah. I have heard about hs-boot files w.r.t. recursive modules, but don't actually know what they are.
21:13:53 <Eduard_Munteanu> A parametrized module system a-la Agda might be nice.
21:13:54 <ivanm> @remember spoolio Haskell programmers know the cost of nothing, the type of everything, and might know the value of a few things later.
21:13:54 <lambdabot> Good to know.
21:14:16 <geheimdienst> hehe :)
21:14:21 <ivanm> danharaj: the report says that (IIRC) recursive module loading is allowed, but how to do so is up to the compiler
21:14:39 <ivanm> so GHC does so by requiring you to write hs-boot files to tell it how to sort out recursive modules
21:15:16 <mauke> example: A imports B, B imports A
21:15:24 <mauke> you write a hs-boot file for A
21:15:42 <mauke> this contains the interface (names, types) for A
21:16:01 <mauke> ghc compiles B using the information from the hs-boot file
21:16:20 <mauke> ghc compiles A using the compiled information from B
21:16:39 <mauke> ghc compares the hs-boot against the compiled information from A to make sure everything is ok
21:23:25 <MatrixFrog> i'm /msg'ing lambdabot and it's not responding :(
21:23:44 <MatrixFrog> oh i was doing it wrong
21:23:58 <mauke> hint: "> " and "@eval" are wrong :-)
21:24:10 <mauke> or was it "> " that works and ":t" that's broken?
21:24:17 <ivanm> AFAIK > works
21:24:31 <mauke> ty
21:24:33 <ivanm> looks like :t is broken
21:24:44 <MatrixFrog> i was trying to do :info instead of @info
21:24:51 <mauke> uh, there is no @info
21:25:01 <ivanm> @info Maybe
21:25:01 <lambdabot> Maybe
21:25:05 <shachaf> mauke: Yes, "@ty" is what you use for :t.
21:25:07 <ivanm> mauke: looks like there is...
21:25:15 <mauke> ivanm: that's not @info
21:25:19 <shachaf> @info do x
21:25:19 <lambdabot> x
21:25:22 <ivanm> oh?
21:25:33 <ivanm> what does it get matched to?
21:25:35 <ivanm> @help info
21:25:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:25:36 <MatrixFrog> well anyway i for sure thought interactWith was defined somewhere other than in the RWH examples
21:25:37 <shachaf> @info do Foo x <- y; z
21:25:37 <lambdabot> y >>= \ a -> case a of { Foo x -> z; _ -> fail ""}
21:25:52 <ivanm> oh, undo?
21:25:59 <ivanm> heh
21:26:17 <mauke> @hoogle interactWith
21:26:17 <lambdabot> No results found
21:26:32 <ivanm> MatrixFrog: try hayoo
21:27:04 <ivanm> that reminds me: why does hoogle now need a web server?
21:27:10 <ivanm> what happened to the old command-line one?
21:27:27 <shachaf> alias hoogle=curl
21:28:25 <ivanm> shachaf: well, it would need a URL as well, would it not? :p
21:30:11 <shachaf> alias hoogle='curl http://hoogle.com/'
22:14:09 <danharaj> any ideas/prior art on efficient representations of graphs? What if they're restricted to DAG's?
22:15:50 <mauke> data Graph a = X
22:15:50 <astertronistic> do you know what operations you are going to be doing? The most common one I've encountered is the adjacency list
22:15:59 <mauke> it doesn't get more efficient
22:17:14 <danharaj> astertronistic: Ah yeah, I'm familiar with the big picture of representations, but I'd like to get familiar with the things I can do in Haskell to make the representation more compact.
22:17:41 <astertronistic> cool, unfortunately, I don't know haskell and I'm just listening to help learn
22:17:44 <danharaj> For example, I wouldn't use an adjacency list but perhaps adjacency unboxed arrays with Ints as my id's
22:18:45 <astertronistic> cool, like a matrix?
22:19:17 <ksf> ...also note that plain vanilla ADTs can express DAGS without any tricks just fine
22:19:45 <danharaj> ksf: really? Like you can guarantee that nodes are shared?
22:20:08 <ksf> haskell has known sharing semantics.
22:20:35 <danharaj> I was not aware it was official. I thought GHC had its own thangs that I would eventually have to learn.
22:21:20 <ksf> well it's not *completely* specified in the same way that haskell is only non-strict, not necessarily lazy.
22:22:04 <ksf> in any case, reify-graph will help.
22:22:29 <ksf> data-reify, /me means.
22:23:57 <danharaj> hmm... what's observable sharing defined as?
22:24:12 <ksf> well, observing sharing.
22:24:30 <danharaj> bwuh
22:24:42 <ksf> roughly said, looking at pointer equality.
22:24:47 <mauke> > repeat 0
22:24:48 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
22:24:54 <mauke> > [0, 0 ..]
22:24:54 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
22:25:17 <ksf> data-reify could get a finite representation out of that infinite list
22:28:31 <ksf> danharaj, data-reify is particularily useful for getting a finite representation out of an EDSL that isn't necessarily acyclic, but it won't do CSE on that graph, so you can reliably see when your stuff isn't shared.
22:29:46 <danharaj> ksf: ah.
22:30:04 <danharaj> I don't know if I'll need data-reify. Still working out the details of what I want to do.
22:30:41 <danharaj> I'm building scene graphs and I'm not sure what sort of transformations I want to make efficient.
22:31:35 * ksf would imagine there to be a whole libraries of papers about scene graph operations.
22:32:57 <ksf> specifying cyclic scene graphs would be cool, btw.
22:33:23 <danharaj> ksf: for fractal images?
22:33:24 <ksf> ...think of 3d fractals and stuff.
22:34:17 <ksf> ...but you wouldn't want the ghc runtime to unroll that spine, of course.
22:34:57 <ksf> danharaj, or stairs involving italian plubmers.
22:35:06 <danharaj> hehe
22:35:47 <danharaj> I think what I want to do is have explicitly labelled lazy sub trees, but have the rest of the tree be strictly constructed.
22:36:27 <danharaj> and you could specify a fractal as a lazy infinite sub tree that is evaluated to some LOD.
22:37:35 <ksf> dynamic-dynamic lod would be great.
22:38:03 <danharaj> is that a replication error or is there such a thing as dynamic-dynamic lod?
22:38:12 <ksf> that is, support increasing the lod in some direction when zooming in.
22:38:25 <ksf> I'm just bitching about fallout3's lod engine
22:38:40 <ksf> ...which doesn't work too well on low-oomph boxes like mine.
22:38:43 <danharaj> ugh fallout 3's engine in general is terrible.
22:38:52 <danharaj> at least from what I remember playing it.
22:39:33 <ksf> I don't see why I shouldn't be able to zoom in a few kilometres with my sniper rifle without hitting blurry pixels.
22:40:28 <ksf> ...limiting the movement of the zoomed-in view would be perfectly doable from a game-design POV.
22:40:33 <smop> danharaj: remember climbing all those ladders?
22:40:49 <danharaj> smop: I remember the horrifically rigid animations of everything including the rag dolls.
22:41:12 <ksf> the most abysmal about fallout3/new vegas isn't the graphics though, but bugs in quest scripting.
22:41:51 <ksf> bugs that shouldn't even be possible in a sane engine.
22:41:57 <danharaj> I am curious
22:42:21 <ksf> well, let's say lucas arts, back in the days, statically proved its adventures to be deadend-free.
22:43:31 <ksf> it gets a wee bit more involved in an rpg because you have to factor in the character's strength, but the fallout engine allows scripts to become incompletable even without that.
22:43:51 <ksf> s/scripts/quests/
22:44:08 <danharaj> I would be surprised if they had any sort of static sanity checks.
22:44:25 <ksf> quests seem to be imperatively scripted.
22:44:53 <ksf> It's possible to do that and get a bugfree game, but not on that scale.
22:46:31 <flamingspinach> bethesda has always been like that
22:46:43 <flamingspinach> just wait five years and there will be some fan patch which fixes everything
22:47:14 <ksf> as a player, I can somewhat tolerate glitchy graphics and the odd crash (heck it's windows, after all), but being stuck gameplay-wise because of the odd bug two days ago isn't only an immersion breaker, it's a never-start-the-game-again thing.
22:47:27 <ksf> flamingspinach, yep, exactly.
22:47:46 <ksf> the difference in buggyness between current fo3 and new vegas is astonishing.
22:47:59 <danharaj> I refused to buy another Bethesda game after they forced me to commit suicide in Fallout 3
22:48:02 <flamingspinach> hell, morrowind is almost bug-free by now
22:48:07 <danharaj> (spoilers: they forced me to commit suicide in fallout 3)
22:48:19 <ksf> safegame corruption?
22:48:27 <danharaj> no, the scripted ending.
22:48:51 <ksf> there's free-play with broken steel, though.
22:49:02 <danharaj> That would involve buying another Bethesda game.
22:49:28 <ksf> you've got a point, there.
22:50:02 <danharaj> in unrelated news that I will stop talking about since it's blah material, Amnesia is a brilliant game made by brilliant people with brilliant technology.
22:50:15 <danharaj> and I will be modeling any 3d game engine I make in Haskell on theirs :p
22:50:46 * ksf remembers flo cursing the PC version of sacred for it's abundant bugs. I guess he'd just not have played that game at all if he didn't have had the job of implementing the j2me version.
22:51:55 <ksf> There's been a bug epidemic in all PC games for some odd 15 years or so now.
22:52:06 <danharaj> Only Haskell can stem the tide.
22:52:19 * danharaj apologizes for mixing metaphors
22:57:03 <danharaj> sigh. Last week of classes, then finals. I'll have hardly any time to work on this scene graph library until it ends. :[
22:57:45 <ksf> danharaj, another thing worth to keep in mind might be GUIs
22:58:43 <ksf> ...both the intricacies of blitting a page of chinese text with a gazillion of little glyphs out of an even bigger repertoire, and things like ZUIs.
22:59:16 <danharaj> mm I will
22:59:52 <ksf> eaglemode might be worth a look, it's doing a great job of ressource management
23:00:01 <ksf> dunno if it handles cyclic stuff, though.
23:00:04 <danharaj> I'm doing this as a project Lispy suggested it as a "Something someone should make" project. I'm aware of a general sentiment amongst the #haskell-game guys that a native GUI library and other support for graphics programming are desired.
23:00:15 <danharaj> man I am tired
23:00:20 <danharaj> look at that first sentence.
23:00:22 <danharaj> "sentence"
23:00:50 <ksf> well, add a period before "Lispy" and you're fine.
23:01:01 <danharaj> yes but that sentence is lame :p
23:01:19 <ksf> well, but lame sentence lengths are abundant in english.
23:01:38 <danharaj> I can't type check your sentence.
23:02:33 <ksf> (sentence-length lame) `abundant-in` english
23:03:08 <danharaj> fair enough
23:03:16 <danharaj> I really just want to write games, but I couldn't find an aggregate of libraries that quite suited me tastes, so I asked around about what was there and what was missing and decided to try writing things.
23:03:31 <danharaj> I made a wrapper over OpenGL to manage shader state... it's kind of nifty, at least to me.
23:05:01 * ksf once tried to blit glyphs in gpipe but then realised that it doesn't even come close to supporting the degree of texture management you need there
23:05:55 <danharaj> yeah, gpipe is not what I wanted. Just something that makes managing shader state have less boilerplate.
23:06:08 <ksf> ...you need a shader per texture, or multiple rendering passes, passing a shader a texture index isn't going to work.
23:06:16 <danharaj> that won't do.
23:07:11 <ksf> and I didn't feel like using a dynamic texture atlas on vastly different texture sizes without even having tried to burden the gpu with a gazillion of little textures.
23:07:23 <ksf> s/on/of
23:08:42 <danharaj> I find the way textures work in openGL weird though, that you have to bind a texture to a texture unit, and then *that* to the sampler location.
23:10:19 <ksf> the general idea of a shader edsl is good, though.
23:11:08 <danharaj> it's good, but perhaps it should just be an embedding of GLSL.
23:11:12 <ksf> but then, the future might be just using dph and compling it down to cuda.
23:11:30 <ksf> gpipe is definitely too integrated, yes.
23:11:39 <dankna> danharaj: just to check, you're not asking about graph representations for a scene graph, are you?
23:11:41 <ksf> it's just not flexible enough.
23:11:56 <danharaj> dankna: Maybe I am. Who's asking? >_> <_<
23:12:20 <dankna> heh, well, a scene graph isn't a graph in the mathematical sense - it's a spatial index of objects that are active
23:12:59 <ksf> dankna, unless you specify that spacial index inductively.
23:13:00 <dankna> it supports efficiently querying such things as  "everything inside this clipping frustrum" (a frustrum is a pyramid truncated by a plane at the top) or "everything within distance X of point Y"
23:13:02 <danharaj> two points: You describe some scene graphs. Not all. Also, spatial indexing is frequently done with trees.
23:13:26 <dankna> ksf: I'm not sure how one does spatial queries on, say, an adjacency list, though
23:13:41 <dankna> or indeed what it means for two things to be adjacent in 3-space
23:13:51 <ksf> I think what danharaj is looking for is a thing one can compile into one of danaka-definition scene graphs.
23:13:56 <dankna> feel free to educate me
23:14:00 <dankna> if there is a way to do that
23:14:33 <danharaj> The nodes in the scene graph would not be objects in space, they would be bounding volumes in your case, and the leaves would be bounding volumes containing single objects.
23:14:44 <dankna> yes, it's frequently done with trees of some sort, either spatial partitioning or bounding-volume
23:15:31 <flamingspinach> what's the most common way to make GUIs using haskell? qthaskell looks somewhat inactive
23:15:40 <dankna> let me find you some papers on r-trees.  they're a structure I'm very enamored of as update-and-rebalance is an efficient operation, unlike spatial partitioning trees, which need a compilation pass
23:15:44 <ksf> consider, for example, escher's stairs (as a tunnel so we don't get rendering problems)
23:16:03 <dankna> (I did a 3D model of Escher's stairs for a videogame-design course once :D)
23:16:04 <ksf> flamingspinach, gtk2hs, wxhaskell
23:16:17 <dankna> (didn't have a scene graph in that project though)
23:16:36 <ksf> that is, you need to decouple the actual 3d view from the "real" geometry of the object.
23:17:04 <dankna> I'm not sure what you mean by decoupling it - the stairs do exist in 3-space
23:17:18 <dankna> he does have some paradoxical objects that don't, like the cube
23:17:37 <danharaj> dankna: Your definition of a scene graph is very restricted. All a scene graph does is specify A) What to draw. B) How to draw it.
23:17:42 <ksf> dankna, without relying on POV?
23:17:45 <danharaj> It does not have to be organized spatially.
23:17:45 <dankna> oh, right, sorry, the other stairs
23:17:48 <dankna> the ascending/descending ones
23:17:58 <dankna> I thought you meant the multiple-gravity-vectors ones
23:18:04 <ksf> oh.
23:18:21 <dankna> danharaj: while this is true, there's very little reason to use a complicated structure if it doesn't support spatial queries
23:18:24 <dankna> danharaj: just use a list
23:18:50 <dankna> using a structure that supports spatial queries lets you do culling, and also lets you use the same structure for collision detection
23:18:52 <danharaj> dankna: sure there is. I might want to render a particular chunk of geometry in more than one way, and each way would be a different path from root to leaf in the scene graph.
23:19:01 <dankna> okay, that's fair
23:19:21 <ksf> dankna, think of a zipper conisting of one of your scene graphs into a more powerful description of a scene graph.
23:19:30 <dankna> right, okay
23:20:24 <znutar> spatial queries let you render front to back and make better use of the occlusion tests in hardware and all that too
23:20:26 <dankna> A.?Guttman. R-trees: A dynamic index structure for spatial searching. In INTERNATIONAL CONFERENCE ON MANAGEMENT OF DATA, pages 47?57. ACM, 1984.
23:20:27 <danharaj> dankna: I would actually decouple the data representing the spatial structure of the scene and the render-logic structure. You could apply transformations on one based on the other to get various optimizations.
23:20:29 <dankna> here we go
23:21:45 <dankna> danharaj: I don't know about that - it's not much work to modify any given spatial index to support multiple instances of a node.  do you have other types of render-logic primitive in mind besides that?
23:22:36 <danharaj> dankna: The representation I'm working on now has shaders as nodes in the graph, for example.
23:23:15 <dankna> well, that's neat
23:23:30 <danharaj> and the general idea is that a path in the graph to a leaf is the steps taken to render something.
23:24:28 <danharaj> other nodes would be managing and transforming things like the model-view matrix
23:24:38 <ksf> can't you just compile that down to a DFA?
23:24:55 <ksf> well, not automaton, but transducer, but that's essentially the same.
23:25:14 <danharaj> ksf: Maybe?
23:26:24 <danharaj> The problem might be allowing things like fractals to exist
23:26:42 <dankna> I'm not aware of any game that uses fractals.  stay focused on problems you actually have :)
23:26:56 <danharaj> dankna: Genericity is a goal :p
23:27:00 <dankna> (I /am/ aware of games set in non-orientable manifolds :D)
23:27:02 <ksf> well, you don't need an infinite number of rendering ops to render a piece of a fractal.
23:27:31 <ksf> ...you snatch the commands out of the fractal definition, and then walk the DFA to interpret the thing.
23:27:33 <danharaj> ksf: no, but perhaps the traversal of the graph to render it is complicated. I don't know if it would be possible to do something that can't be expressed in a reasonably sized DFA.
23:28:08 <danharaj> Also, I do want to give you access to the graph so you can do things like culling based on spatial data.
23:28:19 <danharaj> preferably in a way that let's those transformations get fused.
23:28:23 <ksf> well, there's more powerful languages than regular ones way before turing-completeness.
23:30:06 <danharaj> anywho
23:30:22 <danharaj> every project I've ever done has had my initial ideas superceded by quite different refinements
23:30:24 <danharaj> so who knows what'll happen
23:30:32 <danharaj> (spoilers I go to sleep)
