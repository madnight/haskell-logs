00:00:02 <NihilistDandy> Yep. Lemme cabal -v and paste what I get
00:00:04 <dankna> okay, nopaste the full build log
00:00:12 <dankna> use nopaste, don't paste it into the channel
00:00:30 <NihilistDandy> yup
00:00:30 <monqy> Obvioso: "simple game physics" confuses me a bit -- is this just numbers (i.e. the physics), or is there a game too?
00:00:45 <NihilistDandy> dankna: http://nopaste.me/paste/11577819714dc4ef0e97120
00:01:13 <Obvioso> like, I used to program in a game making program called click'n'play
00:01:15 <dankna> looking
00:01:18 <NihilistDandy> Seems to be an issue in SAX
00:01:40 <monqy> Obvioso: I'm afraid that's probably a bit too nontrivial for a first project
00:01:46 <Obvioso> I could program a simple platformer gravity engine
00:01:47 <monqy> Obvioso: or learning the language
00:02:05 <Obvioso> no, not thinking I'm ready to take that on now
00:02:08 <monqy> game programming is a real pain and a bad way to learn the language
00:02:19 <monqy> or any language not specifically designed for it
00:02:43 <NihilistDandy> Obvioso: http://joyridelabs.de/game/
00:02:46 <Obvioso> just wondering once I get a bit further, what kinds of simple things I can make
00:02:52 <NihilistDandy> That's a game written mostly in Haskell
00:03:23 <Obvioso> saw somewhere "Bloxors" was writen in haskell
00:04:16 <NihilistDandy> I love Bloxorz :D
00:04:38 <dankna> NihilistDandy, okay - the xml-types library has changed since I last used it, incompatibly, and its version numbers violate the policy apparently :)
00:04:38 <Obvioso> right
00:04:47 <dankna> NihilistDandy, I'm working on a patch now.  won't take a moment.
00:05:13 <NihilistDandy> dankna: No problemo. Take your time, by all means
00:05:18 <monqy> I did a search for bloxorz and
00:05:24 <monqy> I wasn't aware there was any way to compile haskell to flash
00:05:25 <dankna> if I take my time it'll never happen :)
00:05:31 <dankna> bloxorz was first written in Flash
00:05:35 <NihilistDandy> dankna: Then rush it! :P
00:05:35 <dankna> the Haskell version is a reimplementation
00:05:38 <monqy> ahh
00:05:39 <dankna> haha
00:06:02 <monqy> is it anywhere? I can only find the flash version
00:06:24 <NihilistDandy> monqy: http://hackage.haskell.org/package/bloxorz
00:06:46 <monqy> yeah I just thought to append "haskell" to my search
00:07:28 <NihilistDandy> Oh, as long as I'm thinking of it, has anyone done any work with the scrobbling API in Haskell?
00:07:39 <dankna> @wtf scrobbling
00:07:39 <lambdabot> Maybe you meant: bf ft wn
00:07:43 <dankna> @google scrobbling
00:07:43 <lambdabot> http://en.wikipedia.org/wiki/Last.fm
00:07:43 <lambdabot> Title: Last.fm - Wikipedia, the free encyclopedia
00:07:49 <dankna> oh, scrobbling, right
00:07:51 <dankna> no, I haven't :)
00:08:10 <NihilistDandy> I was planning to write a bot that would provide most of the lambdabot functionality, and a few extras
00:08:15 <NihilistDandy> Scrobbling being one
00:08:33 <NihilistDandy> @hoogle scrobble
00:08:33 <lambdabot> No results found
00:09:00 <monqy> a scrobbling module for lambdabot (and then a lambdabot on which to use it), or am I missing something?
00:09:10 <NihilistDandy> monqy: Basically, yes
00:09:32 <NihilistDandy> It's one of my plans for nontrivial Haskell projects
00:09:43 <NihilistDandy> Also, dankna: http://iphoneideas.tumblr.com/page/3
00:09:46 <NihilistDandy> Kind of a neat site
00:10:47 <NihilistDandy> monqy: The idea is mostly from a bot that exists on the IRC server of a torrent tracker I use.
00:11:22 <NihilistDandy> It gets last.fm user data based on mailing address or username
00:11:42 <NihilistDandy> And I thought it was a cool effect :D
00:12:04 <dankna> NihilistDandy, hm.  the site hasn't been updated in two years and only ever had two posts.  the first post is a bad idea (quicksilver wouldn't work well on an iphone because pointing is faster than typing, the inverse of the desktop scenario) and the second has been done very well indeed already
00:12:16 <dankna> but it's a nice idea for a site I suppose, hehe
00:12:37 <NihilistDandy> Yeah, if it were actually updated, it would be nice
00:12:46 <dankna> (I had the second idea myself, independently, but looked into it and found that it would be hard to compete with Bento)
00:13:01 <NihilistDandy> I only found it because I was trawling the HWiki for Obj-C related things
00:13:04 <dankna> nodnod
00:13:28 <NihilistDandy> And there's an iPhone section on the wiki which pointed at that
00:13:47 <NihilistDandy> dankna: Try "near impossible" to compete with Bento :D
00:14:34 <NihilistDandy> Though I would very much like to implement something closer to Codd and the Third Manifesto, as far as databases go
00:14:37 <NihilistDandy> SQL's a damn mess
00:14:45 <dankna> NihilistDandy, heh indeed
00:14:50 <dankna> I like SQL
00:14:54 <dankna> I find it clean and elegant
00:15:11 <NihilistDandy> I know too much about the relational calculus to like SQL :D
00:15:19 <dankna> the NoSQL approach is, ironically, a giant leap backwards.  (SQL itself was called "a giant leap backwards" when it was invented)
00:15:34 <dankna> it's not like hierarchical databases haven't been tried
00:15:40 <NihilistDandy> dankna: But... but... MongoDB is web scale
00:15:42 <NihilistDandy> :d
00:16:04 <dankna> MongoDB may be okay, as a specific case.  Other hierarchical databases are, in general, crap.
00:16:40 <NihilistDandy> dankna: Joke. http://www.xtranormal.com/watch/6995033/mongo-db-is-web-scale
00:16:42 <dankna> My ex makes his/her living from ldap, heh.
00:17:06 <dankna> I am not a fan.
00:17:07 <NihilistDandy> dankna: I don't have a functional issue with SQL, just a mathematical issue :D
00:17:09 <dankna> looking
00:17:11 <dankna> gotcha, okay :D
00:17:22 <dankna> that seems like a fairer basis for disliking it than "we don't like relations"
00:18:18 <NihilistDandy> I'm very fond of Codd's work, and his adherents', I just think SQL doesn't implement some things correctly for proper "relational" databases
00:18:31 <NihilistDandy> a la Codd
00:18:58 <NihilistDandy> Personally, I love relations, but I also love set theory :D
00:23:18 <dankna> NihilistDandy, hah.  thank you for that interesting way to use 5:35 of my life, haha.
00:23:34 <dankna> now back to fixing the code
00:23:42 <NihilistDandy> dankna: First saw it ages ago in #erlang, and it stuck with me :D
00:33:19 <enoksrd> is there a library function that returns every kth element of a list?
00:33:37 <enoksrd> this is easy to implement, but i'd expect it to be built in
00:34:09 <ddarius> Why do you expect it to be built in?
00:34:26 <Axman6> yeah, I've never seen anyone with a need for that
00:34:29 <Axman6> until now
00:34:32 <dankna> NihilistDandy, okay!  I have gotten everything to a state that at least compiles so you can see what it does.
00:34:54 <enoksrd> ddarius: hmmm, no good reason, just used to having it in python i guess
00:34:57 <dankna> NihilistDandy, do "darcs pull" in both projects' directories, then try again to "cabal install" them.
00:35:21 <ddarius> enoksrd: Python "lists" are arrays where that operation makes a bit more sense.
00:35:28 <NihilistDandy> dankna: Shall do
00:35:34 <enoksrd> axman6: the first time i can remember wanting it is today
00:35:53 <enoksrd> ddarius: i think it makes just as much sense with linked lists
00:36:11 <enoksrd> but no worries, it's easy to implement
00:36:17 <shachaf> > map snd . filter (\(x,_) -> x `mod` 5 == 0) . zip [0..] $ "abcdefghijklmnopqrstuvwxyz"
00:36:18 <lambdabot>   "afkpuz"
00:36:19 <enoksrd> thanks
00:36:54 <ddarius> I still don't think it makes too much sense to be "built-in" even for arrays, but it is a bit more natural and commonplace for them.
00:36:55 <NihilistDandy> dankna: Working much better so far :D
00:37:15 <shachaf> Or you might be able to group the list into n-sized chunks with Data.List.Split and then map head.
00:37:18 <dankna> excellent
00:37:26 <enoksrd> > let every k [] = []; every k (x:xs) = x : every k (drop (k-1)) xs in every 3 [1..10]
00:37:27 <lambdabot>   Couldn't match expected type `[a] -> [a]'
00:37:27 <lambdabot>         against inferred type `[t]'
00:38:26 <enoksrd> > let every k [] = []; every k (x:xs) = x : every k (drop (k-1) xs) in every 3 [1..10]
00:38:26 <lambdabot>   [1,4,7,10]
00:39:01 <shachaf> > [1,4..10]
00:39:02 <lambdabot>   [1,4,7,10]
00:41:17 <cheater15> hi
00:41:24 <ddarius> :t range
00:41:25 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
00:41:29 <cheater15> how does the fact function here work? http://okmij.org/ftp/Haskell/Fix.hs
00:41:39 <ddarius> @where evolution
00:41:39 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
00:41:42 <ddarius> Explains everything
00:41:45 <enoksrd> shachaf: haha, yeah, unfortunately i don't generate the original list :)
00:41:49 <NihilistDandy> dankna: Everything is building swimmingly, so far
00:42:08 <NihilistDandy> And... done
00:42:30 <shachaf> cheater15: It doesn't, on its own.
00:42:41 <cheater15> shachaf, can you explain?
00:42:59 <dankna> note that you may have to add your own report to actually see what it does, haha ^^''
00:43:00 <Kerris> explain yourself </judge dredd>
00:43:12 <shachaf> cheater15: The function fact gets an argument that it uses to recurse.
00:43:22 <cheater15> what is that argument?
00:43:32 <shachaf> This argument is provided by the magical function fix, which gives you a fixed point.
00:43:38 <shachaf> fix f = f (fix f)
00:43:50 <shachaf> That is, fix f = f (f (f (f (f ...
00:44:01 <NihilistDandy> dankna: I'll check out the code tomorrow when I'm a bit less drunk :D
00:44:11 <cheater15> that's ok. but what is the value of that argument?
00:44:12 <dankna> okiedoke!
00:44:17 <NihilistDandy> lol
00:44:32 <shachaf> The rest of the .hs file is various ways to define fix.
00:44:43 <shachaf> cheater15: The value of that argument is (fix f).
00:44:52 <NihilistDandy> Still, anything that bring Cocoa bindings back into possibility is something I support
00:44:58 <NihilistDandy> *brings
00:45:11 <shachaf> In this particular case, the value of that argument is a factorial function :: Integer -> Integer.
00:45:11 <Saizan> fix fact, in this case
00:46:11 <shachaf> cheater15: http://www.ccs.neu.edu/home/matthias/BTLS/sample.ps is an explanation of an implementation of fix in Scheme.
00:46:41 <ddarius> The link I provided covers this case.
00:47:19 <Saizan> http://www.vex.net/~trebla/haskell/fix.xhtml <- also good on fix
00:47:48 <shachaf> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/026.HTM <- also good on fix.
00:48:10 <cheater15> shachaf, that sort of doesn't answer my question
00:48:25 <shachaf> cheater15: It also sort of does. :-)
00:48:39 <cheater15> it's not what i am looking for
00:48:49 <shachaf> > let x = 1 : x in x -- Do you understand this?
00:48:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:49:19 <cheater15> no
00:49:44 <shachaf> OK. Understand that first. :-)
00:51:01 <shachaf> Once you understand that, fix is just an abstraction of that.
00:51:29 <shachaf> > let f = (1:) in let x = f x in x
00:51:29 <cheater15> can't we skip fix and just talk about what the "self" is
00:51:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:51:45 <ddarius> self is just a parameter.
00:51:59 * hackagebot sme 0.1 - A library for Secure Multi-Execution in Haskell  http://hackage.haskell.org/package/sme-0.1 (AlejandroRusso)
00:52:16 <cheater15> what happens when i do self (pred n) ?
00:52:32 <ddarius> It depends on what self is bound to.
00:56:06 <cheater15> ddarius, yeah, but in this case, where self is this "magical parameter provided by fix"
00:56:35 <ddarius> In that case, self is bound to (fix fact).
00:57:18 <shachaf> cheater15: You're not going to gain much by saying "let's skip fix and talk about self for a moment" when self *is* pretty much fix. Although that's oddly appropriate. :-)
00:57:49 <ddarius> Self is just a parameter.  fix is a function.  Self is bound to (fix fact).
00:58:29 <Saizan> fix fact = \n -> case n of 0 -> 1; n -> n * (fix fact) (pred n)
00:59:01 * ddarius would have used a different notation for that.
00:59:16 <Saizan> if?:)
00:59:32 <ddarius> Saizan: No, one that didn't look like a definition of fix.
01:00:15 <ddarius> I probably would have used: fix fact ~> ...
01:00:45 <Jonno_FTW> > floor (3 :: Integer)
01:00:46 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Integer.Type.Integer)
01:00:46 <lambdabot>    arising fro...
01:00:47 <ddarius> (and probably would have shown the intermediate step)
01:01:48 <Saizan> cheater15: anyhow, you can use my equation above to do an inductive proof that fix fact is the factorial function, or just try expanding e.g. "fix fact 5" and see how it looks.
01:02:22 <NihilistDandy> Agda v. Coq... go
01:04:05 <roconnor> it's hard to write proofs in Agda
01:04:12 <roconnor> Coq is probably inconsistent
01:05:39 <ddarius> Unlike Agda which is known to be inconsistent.
01:05:55 <roconnor> Agda is known to be inconsistent?
01:06:23 <Saizan> are there still open bugs that let you prove false?:)
01:07:14 <NihilistDandy> This is a topic of interest
01:09:23 <cheater15> i defined fact recursively, and did u = fix fact, and then did u 1 and it threw up.
01:09:31 <cheater15> how is fix fact the same as fact?
01:09:43 <roconnor> no
01:10:11 <roconnor> typically you define factF non recursively and then defined fact = fix factF
01:10:12 <Saizan> fix fact where fact is the one defined in oleg's code is the same as the factorial function
01:10:21 <Saizan> it's not the same as fact itself
01:10:37 <roconnor> oh oops
01:10:40 <roconnor> I'm missing context
01:10:44 <shachaf> cheater15: fact isn't a function that computes factorials on its own.
01:10:45 * roconnor will keep quiet
01:10:57 <shachaf> roconnor's suggestion would be helpful here. :-)
01:11:28 <shachaf> cheater15: I recommend reading the links that have been posted here. They explain it in quite a lot of detail.
01:11:58 <cheater15> ohhh ok\
01:12:12 <roconnor> cheater15: once you understand this you will reach computer scientist level 4.
01:12:21 <cheater15> that makes more sense, you should've said at the beginning what roconnor just said
01:12:35 <cheater15> it didn't make sense to me at all that you started talking about fix first
01:12:48 <cheater15> roconnor, heh
01:13:02 <NihilistDandy> CS 4 is only spoken of in legend
01:13:13 <shachaf> roconnor: Level 4? How far do they go?
01:13:17 <roconnor> quite far
01:13:22 <dankna> 1 to 5.  it's like biohazard levels.
01:13:26 <cheater15> lol
01:13:31 <roconnor> upto level 99 I think
01:13:33 <roconnor> maybe higher
01:13:40 <roconnor> see oleg
01:13:42 <shachaf> @level oleg
01:13:42 <lambdabot> Maybe you meant: eval leave
01:13:55 <NihilistDandy> CS 99 is reserved for certain self aware AIs wandering the net
01:14:08 <roconnor> cheater15: after this you need to understand tying-the-knot, and then you need to understand mfix.
01:14:53 <ddarius> And once you understand all that you will be ready to do simple imperative programming.
01:15:02 <cheater15> what is it i'm understanding right now?
01:15:03 <cheater15> fix?
01:15:12 <shachaf> Recursion.
01:15:15 <cheater15> ok
01:15:31 <shachaf> cheater15: You don't understand let foo = 1 : foo in foo?
01:15:36 <cheater15> but understanding recursion is simple, you just have to understand recursion.
01:15:47 <cheater15> shachaf, i don't understand the syntax.
01:15:53 <cheater15> i'm fairly new to haskell.
01:15:55 <shachaf> What part?
01:16:01 <cheater15> "x in x"
01:16:07 <mauke> ...
01:16:10 <cheater15> also what "let a: b" means.
01:16:11 <NihilistDandy> Really?
01:16:19 <cheater15> no, i'm just kidding. i'm a kidder.
01:16:21 <mauke> m(
01:16:24 <shachaf> OK, first of all you're understanding Haskell syntax.
01:16:28 <shachaf> > let { foo = 1 : foo } in foo
01:16:28 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:16:44 <cheater15> oh ok
01:16:45 <roconnor> shachaf: I think we need to understand even simpler
01:16:46 <cheater15> that makes more sense
01:16:53 <roconnor> ? 1 : 2 : 3 :[]
01:16:54 <cheater15> yeah that's recursive
01:16:58 <shachaf> OK.
01:16:58 <roconnor> > 1 : 2 : 3 :[]
01:16:59 <lambdabot>   [1,2,3]
01:17:04 <cheater15> i got that
01:17:05 <shachaf> Now, let's abstract (1:).
01:17:12 <shachaf> > (1:) [5,3,2]
01:17:13 <lambdabot>   [1,5,3,2]
01:17:24 <shachaf> > let { f = (1:); x = f x } in x
01:17:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:17:30 <shachaf> Do you understand that?
01:19:51 <cheater15> just a sec, sorry
01:19:58 <cheater15> yeah, sure
01:20:17 <cheater15> (someone was distracting me here but i have successfully gotten rid of them)
01:20:30 <shachaf> cheater15: Well, fix abstracts that.
01:20:39 <shachaf> fix f = let { x = f x } in x
01:20:42 <shachaf> > fix (1:)
01:20:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:21:31 * ddarius hopes cheater15 meant "murdered" by "gotten rid of."
01:21:57 <NihilistDandy> ddarius: Is there another meaning?~
01:22:40 <shachaf> NihilistDandy: There are many approxmations of murder when the real thing is not available.
01:23:00 <cheater15> shachaf, that was fairly easy
01:23:13 <shachaf> cheater15: What was?
01:23:20 <cheater15> what you just explained
01:23:36 <shachaf> So now you understand fix?
01:23:40 <shachaf> Oh, let's add an argument.
01:23:44 <cheater15> i dunno. do i?
01:23:58 <NihilistDandy> :/
01:24:47 <cheater15> i understand what you just told me. i don't know if it's the same as understanding fix.
01:25:16 <cheater15> so in your definition fix f = f(f(f(f(...)       ?
01:25:32 <shachaf> cheater15: Yes, except without the ). :-)
01:25:34 <shachaf> factF foo = \n -> if n == 0 then 1 else n * foo (n - 1)
01:25:35 <cheater15> or rather f f f f f f .... f f f x ?
01:25:40 <ddarius> NihilistDandy: shachaf's mother was only 37.6% pregnant with him during most of the nine months.
01:25:45 <shachaf> No, that would be (f (f (f (f ...
01:26:10 <shachaf> Er.
01:26:12 <cheater15> oh right
01:26:16 <NihilistDandy> ddarius: Fuzzy pregnancy. How very meta.
01:26:17 <shachaf> That would be ((((f f) f) f) ...
01:26:28 <ddarius> Need more leading parentheses.
01:26:33 <shachaf> True.
01:26:37 <shachaf> That would be ((((((((((...
01:26:45 <cheater15> what if i did f $ f $ f $ ... f $x ?
01:26:47 <shachaf> See foldl.com
01:27:24 <shachaf> cheater15: The ... is in the wrong place.
01:27:35 <shachaf> And Haskell doesn't suppose the ... operator, sadly.
01:27:42 * shachaf still thinks that should be added to lambdabot.
01:27:50 <NihilistDandy> New favorite website, foldl.co
01:27:53 <NihilistDandy> *com
01:28:13 <shachaf> NihilistDandy: Better than foldr.com?
01:28:50 <NihilistDandy> shachaf: That's a difficult choice. I'll have to see which one my Facebook friends find more confusing.~
01:29:04 * shachaf is lazy, so he prefers foldr.com
01:29:05 <cheater15> why is the ... in the wrong place?
01:29:25 <cheater15> i'm just talking in general, not in specifically haskell terminology
01:29:33 <shachaf> cheater15: Because you're applying it to an f in the end.
01:29:47 <shachaf> It's like saying 1-0.999... = 0.000...1.
01:30:06 <cheater15> hmm.
01:30:15 <cheater15> ok.
01:31:03 <NihilistDandy> You see the problem with that, yes?
01:32:23 <cheater15> no. isn't 0.000...1 just a very small number?
01:32:35 <shachaf> Not if ... represents an infinite number of 0s.
01:32:37 <cheater15> like couldn't you say 0.000...1=dy?
01:32:41 <shachaf> In that case it doesn't even make sense.
01:32:49 <cheater15> i'm just messing with ya.
01:32:58 * shachaf sighs.
01:32:59 <cheater15> or am i?
01:33:04 <NihilistDandy> 0.000...1 isn't a thing
01:33:41 <NihilistDandy> It suggests an infinite string of 0s that terminates with a one, which is absurd
01:33:42 <cheater15> what if you defined an equation containing 0.000...1 as   the limit over k of an equation containing 0.(repeat k 0)1 ?
01:33:55 <cheater15> wouldn't that stick?
01:33:55 <cheater15> :D
01:34:25 <cheater15> you could make epsilon-delta so much easier to understand with this!
01:35:18 <cheater15> ok so.. hm
01:35:20 <roconnor> you can do calculus with infinitesmials
01:35:41 <cheater15> roconnor, yeah. that's what hyperreals are for, as well some forms of umbral calculus
01:35:41 <roconnor> there are even two different ways to do this
01:36:07 <cheater15> what is the second way?
01:36:24 <roconnor> Bell's way, but you have to give up using excluded middle in your reasoning.
01:36:33 <roconnor> not that anyone uses excluded middle.
01:36:43 <cheater15> got a link?
01:37:14 <cheater15> shachaf, what if i defined fix using something like uh :1?
01:37:27 <shachaf> What's :1?
01:37:28 <koninkje> NihilistDandy: Why is it absurd? it's just a string with length omega+1
01:37:33 <roconnor> http://www.amazon.com/Primer-Infinitesimal-Analysis-John-Bell/dp/0521624010
01:37:33 <koninkje> :)
01:37:39 <cheater15> something that appends 1 to the right end of a list.
01:37:42 <NihilistDandy> koninkje: :P Don't sass me
01:37:52 <cheater15> obviously doesn't work in haskell, but i bet haskell has a way to do that
01:38:04 <shachaf> That would be (++[1]), not :1.
01:38:19 <roconnor> > last (fix (++[1]))
01:38:23 <lambdabot>   mueval-core: Time limit exceeded
01:38:43 <azaq23> @google 0.999... wiki
01:38:43 <lambdabot> http://en.wikipedia.org/wiki/0.999...
01:38:43 <lambdabot> Title: 0.999... - Wikipedia, the free encyclopedia
01:39:10 <shachaf> Wow, that illustration on the Wikipedia page sure is helpful.
01:39:23 <NihilistDandy> lol
01:39:34 <NihilistDandy> Read the discussion archives
01:39:38 <NihilistDandy> People are insane
01:40:10 <cheater15> i love the illustration
01:42:30 <cheater15> ok so let's go back
01:42:49 <cheater15> > let { foo =  foo ++ [1] } in foo
01:42:52 <Eduard_Munteanu> That's a bit like nonstandard analysis what you're proposing.
01:42:53 <lambdabot>   mueval-core: Time limit exceeded
01:43:00 <cheater15> why is the time limit exceeded?
01:43:06 <NihilistDandy> Back in the New York Groove?
01:43:15 <rostayob> cheater15: how can it show an infinite sequence?
01:43:22 <cheater15> isn't this the same thing as let { foo = 1 :  foo } in foo ?
01:43:22 <NihilistDandy> cheater15: It's a safety thing in lambdabot
01:43:34 <cheater15> > let { foo = 1 :  foo } in foo
01:43:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:43:40 <cheater15> rostayob, this way
01:43:40 <shachaf> No, because of the way linked lists work.
01:43:42 <Eduard_Munteanu> No it does it the wrong way around.
01:44:03 <cheater15> shachaf, what in specific makes it not work?
01:44:03 <Eduard_Munteanu> So it can't produce intermediates.
01:44:03 <shachaf> You don't look at a linked list starting from the end. That doesn't make any sense.
01:44:16 <cheater15> aha
01:44:25 <cheater15> hrm
01:44:39 <Eduard_Munteanu> foo = foo ++ [1] = foo ++ foo ++ [1] ...
01:44:41 <rostayob> cheater15: yeah but in that case it can't get the beginning
01:44:47 <rostayob> so it doesn't show anything
01:44:52 <rostayob> try it in ghci
01:45:11 <Eduard_Munteanu> Compare to foo = 1 : foo = 1 : (1 : foo) = ...
01:45:17 <cheater15> what if we skipped the first element! :)
01:45:22 <cheater15> just kidding ..
01:45:40 <cheater15> what if we take the tail. does that even work?
01:46:02 <Eduard_Munteanu> You mean the last element?
01:46:06 <cheater15> yes
01:46:15 <Eduard_Munteanu> No, the last element is an infinite distance away.
01:46:36 <roconnor> > let (_ :> x) = viewr (fix (|> 1)) in x
01:46:36 <lambdabot>   Not in scope: data constructor `:>'Not in scope: `viewr'Not in scope: `|>'
01:46:37 <NihilistDandy> Known but unknowable
01:46:43 <Eduard_Munteanu> You can only start from the beginning, to get to the last one you'd have to skip an infinite number of elements.
01:46:44 <NihilistDandy> How poetic
01:47:21 <cheater15> yeah but isn't that a very imperative way to think about it
01:47:36 <Eduard_Munteanu> :t S.viewr
01:47:36 <cheater15> "ok, to get the last element you 1. need to skip an element 2. skip an element 3. skip an element ..."
01:47:37 <lambdabot> Couldn't find qualified module.
01:47:44 <azaq23> @src (++)
01:47:44 <lambdabot> []     ++ ys = ys
01:47:44 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:47:44 <lambdabot> -- OR
01:47:44 <lambdabot> xs ++ ys = foldr (:) ys xs
01:47:45 <Eduard_Munteanu> :t Data.Sequence.viewr
01:47:45 <lambdabot> forall a. Seq.Seq a -> Seq.ViewR a
01:48:17 <NihilistDandy> cheater15: Consider an infinite list of 1s
01:48:22 <NihilistDandy> Give me the last element
01:48:32 <Eduard_Munteanu> > let (_ Data.Sequence.:> x) = Data.Sequence.viewr (fix (|> 1)) in x
01:48:33 <lambdabot>   Not in scope: data constructor `Data.Sequence.:>'Not in scope: `Data.Sequen...
01:48:34 <cheater15> depends which way it is infinite
01:48:43 <cheater15> the way i define it with ++ it's infinite to the left
01:48:48 <NihilistDandy> cheater15: Aleph null
01:48:53 <cheater15> so it doesn't have a first element, but does have a last element
01:49:00 <cheater15> sort of like p-adic numbers!
01:49:01 <Eduard_Munteanu> > let ((Data.Sequence.:>) _ x) = Data.Sequence.viewr (fix (|> 1)) in x
01:49:02 <lambdabot>   Not in scope: data constructor `Data.Sequence.:>'Not in scope: `Data.Sequen...
01:50:30 <helino> hi, I got a question about data types. Lets say I want to extend the Integer type with a type Bottom. Then I could write "data ExtInteger = Integer Integer | Bottom". But what if I would like to extend Bool as well? Using "data ExtBool = Bool Bool | Bottom" leads to multiple declarations...How do I solve this?
01:51:30 <dabblego> data Option a = Some a | Bottom
01:51:36 <Eduard_Munteanu> helino: unfortunately constructor names must be unique, you could use Either though
01:52:00 <cheater15> Eduard_Munteanu, were your code snippets meant for my viewing?
01:52:01 <shachaf> helino: Also, _|_ is built-in to every type in Haskell. :-)
01:52:06 <rostayob> helino: mabe you want undefined
01:52:14 <Eduard_Munteanu> data Bottom = Bottom;   data ExtInteger = Either Bottom Integer
01:52:21 <Eduard_Munteanu> whoops...
01:52:23 <roconnor> helino: use dabblego's suggestion, make a generic data type
01:52:27 <Eduard_Munteanu> type ExtInteger = Either Bottom Integer
01:52:31 <dankna> hmm
01:52:37 <dankna> quick question about memory usage and laziness
01:52:41 <roconnor> helino: though such a generic data type is already predefined: Maybe
01:52:47 <roconnor> er
01:52:48 <helino> wow, so many suggestions :) thanks everyone!
01:52:49 <dankna> I have a record type which is about two bytes long not counting its contents
01:52:58 <dankna> er, sorry, about sixteen bytes long (two fields)
01:53:02 <azaq23> type T a = Maybe a
01:53:26 <dankna> I am generating 80 megabyte-seconds of this record
01:53:30 <Eduard_Munteanu> Or that, Maybe is best if you that's all you need about your Bottom.
01:53:31 <helino> shachaf: I've never heard or read about _|_, what is that?
01:53:37 <dankna> is the following a possible explanation for why:
01:53:48 <rostayob> :t undefined
01:53:49 <lambdabot> forall a. a
01:53:49 <roconnor> dankna: record fields are generally all pointers to data structures
01:53:50 <shachaf> helino: It's called "bottom". It's probably something different from what you're using the word for.
01:53:51 <dankna> I usually construct it with a record incremental update
01:53:58 <Eduard_Munteanu> helino: undefined
01:54:09 <Eduard_Munteanu> But the problem is you can't check for it.
01:54:14 <helino> ah ok
01:54:28 <rostayob> > undefined :: Integer
01:54:29 <lambdabot>   *Exception: Prelude.undefined
01:54:30 <dankna> and because substantial time passes between when I create it and when I actually inspect its values, I suspect that I am getting a closure instead of an actual value
01:54:50 <dankna> roconnor: yes, hence sixteen bytes (8-byte pointers because 64-bit)
01:55:01 <helino> so in this case, I should go with Maybe?
01:55:03 <dankna> so that each version of it winds up retaining all previous versions
01:55:20 <dankna> if this is correct, then what I need to do is force the evaluation to WHNF, right?
01:55:32 <dankna> so that the old versions can be collected as garbage
01:56:09 <dankna> I've never really paid attention to the interaction of laziness and space usage before, so I just want to check my understanding before I go making changes to things
01:56:11 <roconnor> dankna: maybe.  It depends on what you are doing
01:56:22 <roconnor> dankna: often you can make things laizer too
01:56:23 <dankna> well, what would it depend on?
01:56:26 <dankna> hmm
01:56:36 <Eduard_Munteanu> helino: yeah
01:56:53 <Eduard_Munteanu> Unless you want your Bottom to include more information or stuff like that.
01:56:55 <cheater15> shachaf, that was some pretty good explanation there
01:56:56 <cheater15> thanks
01:57:02 <dankna> it's a microprocessor simulator - it churns through quite a lot of states quite rapidly, with each state depending on the previous one and the previous one being dead (garbage) as soon as the new one is computed
01:57:08 <roconnor> dankna: ie you can push the creation time closer to when you use it
01:57:53 <dankna> I'm not clear how I would make it lazier in this situation - wouldn't that, if successful, just mean that the actual simulation would all be encapsulated in a closure and not have been actually executed yet?  I don't think that's what I want
01:57:54 <roconnor> dankna: but adding strictness annotations might be the easiest fix
01:58:15 <roconnor> dankna: and some !'s to your record field to make them strict
01:58:17 <dankna> I know for a fact that the simulation's result is going to be used, and soon, because that's the purpose of it
01:58:21 <dankna> hmm
01:58:25 <roconnor> dankna: and then carefully litter your code with seqs.
01:58:35 <Eduard_Munteanu> Nah, just profile it
01:58:38 <dankna> I thought !s in the record fields /were/ strictness annotations.  there's something distinct?
01:58:48 <roconnor> dankna: they are
01:58:54 <roconnor> but you will probably want to do both.
01:59:01 <dankna> Eduard_Munteanu, I did profile it with a variety of options; that's how I got the 80 mb*s figure
01:59:04 <Eduard_Munteanu> Sprinkling strictness stuff blindly didn't end up well for me.
01:59:21 <dankna> unfortunately retainer profiling just tells me everything is retained by SYSTEM
01:59:23 <helino> Eduard_Munteanu: ok, thanks for your help!
01:59:24 <roconnor> dankna: I've run simulations before without using any strictness anotations
01:59:51 <dankna> and biography profiling somehow can't see my data at all, it tells me zero bytes allocated, possibly because I'm running as a library called from C
01:59:53 <roconnor> dankna: I had a space leak in my first version but I fixed it by removing an unecessary case analysis.
02:00:03 <dankna> hmm
02:00:27 <dankna> see, I have no idea how I would even know that I have a genuine leak
02:00:48 <dankna> when you're generating data in this volume all you can really tell is that your computer can't handle it :)
02:00:57 <Eduard_Munteanu> What about normal profiling?
02:01:09 <dankna> which type of profiling is "normal"?  by type?
02:01:16 <Eduard_Munteanu> I'd look if any function allocates a suspicious amount of memory.
02:01:34 <dankna> oh, cost-center.  I think that didn't work for me, but let me try it again.
02:01:39 <Eduard_Munteanu> The stuff you get with plain -p
02:02:01 <Eduard_Munteanu> Compile it with -prof -auto-all -caf-all
02:02:05 <Eduard_Munteanu> and run with +RTS -p
02:02:18 <dankna> oh, haha, okay
02:05:28 <Saizan> what's the result of your simulation? a list of states? or just a final one?
02:05:32 <dankna> where does that output go?  <program>.prof?
02:05:34 <dankna> just a final one
02:05:53 <Saizan> ok, then you probably want to make things stricter
02:06:02 <Eduard_Munteanu> dankna: yeah
02:06:29 <dankna> hmm, empty file for some reason
02:06:35 <roconnor> ah right, my simulator was more or less producing a trace of the computation
02:06:48 <dankna> ah, yeah, that's not the case for mine
02:07:30 <Eduard_Munteanu> dankna: hm, did you let it finish?
02:07:36 <dankna> I still wish to understand this profiling stuff so that I can actually measure my changes besides "oh look, now the CPU fan takes three seconds to spin up instead of two..."
02:07:52 <dankna> Eduard_Munteanu, because I'm running as a library and never call hs_exit(), it may not think of itself as done?  hmm, I can probably fix that
02:08:17 <Eduard_Munteanu> How did you pass +RTS -p then?
02:08:27 <Eduard_Munteanu> (Did you?)
02:08:39 <dankna> I did
02:08:42 <dankna> I passed it to hs_init()
02:08:55 <dankna> I know that strategy works because it worked fine for +RTS -hy
02:09:46 <Saizan> -hc should give the same info (more accurate probably) and produce output incrementally
02:09:46 <Eduard_Munteanu> Try fixing hs_exit() then.
02:10:11 <Saizan> it's important to have compiled the lib with -auto-all though
02:11:01 <dankna> I did, yes
02:11:05 <dankna> took forever, so it must have worked :)
02:11:11 <Eduard_Munteanu> AFAIK, GHC will complain and won't compile if you don't have all libs compiled with profiling options
02:11:35 <dankna> that's correct, but the wrinkle is that I'm not using GHC to link, I'm using clang
02:11:37 <Saizan> -prof is one thing, -auto-all another
02:11:45 <dankna> but I already made very sure about using _p.a instead of .a
02:12:10 <dankna> but yes, they do different things
02:13:50 <dankna> there we go, it generated emulator.prof this time.  reading it.
02:14:39 <dankna> the cost centers are exactly the functions I expect them to be (the ones that advance the various chips in the system by a single clock cycle each)
02:14:51 <dankna> actually, not quite
02:15:04 <dankna> cycle                                      Motherboard.NES     35.3   44.8
02:15:04 <dankna> cycle                                      Processor.CPU_6502  25.0   14.5cycle                                      PPU.PPU_NES          7.4   15.1
02:15:27 <dankna> Motherboard.NES.cycle is just a wrapper around the other two, it shouldn't be allocating
02:15:57 <dankna> unless it's getting blamed for the copies of the RAM state, but I don't see why it would be
02:16:05 <dankna> and the copies of the RAM are not where my heap space is going
02:16:16 <Utkarsh> How would I drop every other element from a list? eg. [1, 2, 3, 4, 5] -> [2, 4]
02:16:49 <dankna> if I nopaste it, are y'all willing to take a glance at it and help me look through for leaks in it?
02:17:01 <Eduard_Munteanu> dankna: yeah you'd better paste that
02:17:25 <dankna> http://nopaste.dk/p3265
02:17:32 <Saizan> > (\xs -> [ x | (x,i) <- zip xs [0..], odd i]) [1..5]
02:17:33 <lambdabot>   [2,4]
02:17:50 <Eduard_Munteanu> Wait what about the profile?
02:17:55 <dankna> oh, the profile, sure
02:18:02 <Saizan> dankna: you're using foldl!
02:18:13 <dankna> yes, is that an issue? O_o
02:18:23 <dankna> I'm not folding on the state
02:18:28 <dankna> oh
02:18:29 <dankna> wait, I am
02:18:41 <Saizan> you should use foldl' anyway.
02:19:01 <Utkarsh> Saizan: thanks!
02:19:06 <dankna> http://nopaste.dk/p3266 -- now has the profile output
02:19:11 <Saizan> loops with an accumulator are the first cause of lazyness induced space leaks (among young childrens?)
02:19:17 <dankna> (haha)
02:19:21 <Eduard_Munteanu> Yeah, either foldl' or foldr, plain foldl rarely makes sense
02:19:46 <Saizan> if the accumulator is not forced at each step, and only foldl' will let you do that
02:20:33 <dankna> so the difference between foldl and foldl' is just that the latter is strict
02:20:41 <Saizan> ?src foldl
02:20:41 <lambdabot> foldl f z []     = z
02:20:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:20:44 <Saizan> ?src foldl'
02:20:45 <lambdabot> foldl' f a []     = a
02:20:45 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:21:04 <Saizan> yep, only that single seq
02:21:18 <dankna> okay, cool.  made that change, recompiling.  it'll be a minute.
02:21:34 <Eduard_Munteanu> dankna: though I wonder why you're getting only CAFs and 'cycle' isn't getting any attention in the second part of the profile
02:21:38 <Saizan> which makes it strict on the accumulator, but only up to WHNF
02:22:19 <dankna> well, WHNF should be fine - my understanding of it is that that means the object itself is evaluated but its contents may not be?
02:22:32 <Saizan> yep, the outermost constructor only
02:23:00 <Eduard_Munteanu> I wonder if it's possible to use foldr in all cases where foldl' is usually used, and still get reasonable performance.
02:23:14 <Eduard_Munteanu> For example, AFAIU, this could be the case if integer ops weren't strict.
02:23:29 <dankna> well, I cannot use foldr here without changing the order of the chips-to-cycle list to preserve the semantics
02:23:32 <Eduard_Munteanu> (e.g. you could write sum as a foldr)
02:23:49 <Saizan> it's not uncommon to have problematic thunks hiding beneath that outermost constructor
02:23:58 <Eduard_Munteanu> I think foldr is really desirable in general since it's productive.
02:24:09 <Saizan> (and get a stack overflow instead, for Int)
02:25:30 <Eduard_Munteanu> Saizan: but isn't that because e.g. (+) is adamant about strictness?
02:25:46 <Eduard_Munteanu> As I see it you'd add up as you go if it weren't.
02:26:29 <dankna> la la la this is the waiting-for-compilation song :)
02:26:42 <Saizan> you'd add up as you go with foldl, there's nothing to add up to as you go with foldlr
02:26:49 <Saizan> s/lr/r/
02:27:20 <Saizan> the other argument is the one you get by recursing
02:27:40 <dankna> okay, test done.  the resulting memory usage and profiling report are very similar to before I changed it.
02:28:38 <Saizan> you probably need to propagate the strictness down into state, or maybe you've a similar pattern elsewhere
02:28:55 <Eduard_Munteanu> If you're already using -O or -O2 foldl vs foldl' might not make much of a difference I think.
02:29:00 <dankna> it's still the same function coming up as top consumer
02:29:15 <dankna> so I presume I need to propagate the strictness into State, yeah
02:29:29 <dankna> I do that by adding ! before the type of each field, in the definition of the type?
02:29:44 <dankna> sorry for the beginner question, but I've never had to do this before :)
02:31:04 <Saizan> yep, it'd be useful to see the definitions of the other cycle functions and of the types
02:31:08 <dankna> not actually sure whether I'm using -O or what, I haven't done anything explicit to turn that on.  I think I assumed optimization was happening based on how long it was taking to compile :)
02:31:12 <dankna> sure, I can paste that stuff
02:31:27 <Saizan> cabal only uses -O by default
02:31:31 <dankna> be warned that one of the cycle functions is 300 lines long
02:31:40 <dankna> I see
02:32:45 <dankna> thanks by the way for the assistance
02:33:52 <Eduard_Munteanu> In some cases it might be desirable to move some let bindings to top level to improve sharing.
02:33:58 <dankna> hmm
02:35:34 <dankna> http://nopaste.dk/p3267
02:35:49 <dankna> definitions that you asked for, and latest profiling results, which I haven't looked at myself yet
02:37:03 <dankna> by the way the reason it's nothing but CAFs is presumably because one of you told me to pass -caf-all when compiling, so I did that :)
02:39:10 <Saizan> you should also make the fields of SoftwareState and HardwareState strict, i'd say
02:39:15 * dankna nods
02:39:23 <dankna> well, that's the obvious next step to try; doing it now
02:39:38 <dankna> HardwareState actually doesn't change during this particular use-case
02:39:45 <dankna> that's the distinction between them
02:40:51 <dankna> by the way, I'm well aware that I'm using immutable arrays and that that could be an issue - but again, looking at the heap profile, they're a vanishingly small portion of what I'm allocating
02:40:53 <Saizan> ah, so it shouldn't matter either way
02:41:09 <Saizan> for HardwareState, i mean
02:41:11 <dankna> which makes sense:  this should only be about 10,000 cycles, so worst-case usage should be a few megs, not a few gigs!
02:41:12 <dankna> yeah
02:41:20 <dankna> I'll make it strict because I'm OCD like that :)
02:42:13 <Saizan> (the state monad could have saved you things like statusRegister'''' btw)
02:42:38 <dankna> (not exactly - if you read carefully you'll notice that most of the time, I base things on the old values and not the new ones)
02:43:03 <dankna> (but yes, after the performance I'm definitely interested in discussing ways that Processor.CPU_6502.cycle could be organized better)
02:43:18 <dankna> (I had a number of bugs while writing that file related to putting the wrong number of ''' after variables :( )
02:44:15 <Saizan> mh, are there any inner loops in the other cycle's?
02:45:11 * hackagebot poppler 0.12.2 - Binding to the Poppler.  http://hackage.haskell.org/package/poppler-0.12.2 (AndyStewart)
02:45:29 <dankna> none of the cycle's actually loop - but I assume you mean, are they major cost-centers?
02:46:50 <dankna> if that's the question, you have the same information to answer it as I do - Motherboard.NES.cycle, Processor.CPU_6502.cycle, Emulator.gamestateFrameForward, and PPU.PPU_NES.cycle are, in order, the four biggest cost centers by self-time
02:47:16 <dankna> (gamestateFrameForward is probably there for unimportant reasons, heh)
02:47:20 <Eduard_Munteanu> softwareStateMotherboardClockCount should also be strict
02:47:50 <jessycatz> heya. I'm currently toying around with regexps but encountering some weird issue... "foo foo foo" =~ "foo" :: [String] gives me an error and not an array foos. Any ideas why that is the case? (both with regex-posix and regex-tdfa)
02:47:51 <Saizan> no, the question was specifically about uses of recursion (even indirect)
02:47:51 <dankna> I'm making all the fields of SoftwareState strict in the version that's building right now, actually
02:48:04 <dankna> okay - yeah, no, there's no deliberate recursion in there
02:48:21 <Eduard_Munteanu> I wonder whether the record update results in recreating the whole record.
02:48:38 <dankna> clearly!  given that these records are where all my heap space is going
02:49:22 <Saizan> it certainly creates a new application of the constructor
02:49:35 <Saizan> you share the unmodified contents though
02:49:37 <dankna> well, the amount it allocates is down to about 700M from about 800M
02:49:58 <dankna> yes, that's why it's so mind-boggling that these records, which ought to be tiny, are eating so much space
02:50:32 <dankna> for some reason making those things strict removed gamestateFrameForward as a major cost-center, so I suppose that is indeed progress
02:51:02 * Saizan wonders if ghc can propagate the strictness behind the polymorphism and lets
02:51:15 <dankna> hm
02:51:16 <Eduard_Munteanu> You know what?
02:51:16 <dankna> fair question
02:51:22 <Eduard_Munteanu> You could try inlining that 'cycle'.
02:51:34 <dankna> across module boundaries?  it can do that?
02:51:43 <Eduard_Munteanu> That I'm not sure.
02:51:49 <dankna> which one did you mean btw?
02:51:52 <peldan> i've written a 800 line haskell program that takes chess moves and outputs the final position in ASCII format. when compiled, the executable is 9 MB?! are haskell programs always this big?
02:51:59 <jessycatz> mh, nvm, fixed it somehow.
02:52:00 <Eduard_Munteanu> Motherboard.NES one
02:52:04 <dankna> hmm
02:52:08 <Eduard_Munteanu> That's the major issue there.
02:52:42 <Eduard_Munteanu> I'm not sure how you're using it in other code, but perhaps it could enable further optimizations.
02:52:57 <dankna> I basically just call it in a tight loop
02:52:59 <ManateeLazyCat> Where the file contain hackage username and password?
02:52:59 <Saizan> dankna: wait, are these cycles mostly working on softwareStateCPUState and softwareStatePPUState ?
02:53:10 <dankna> Saizan: oh, let me explain how this works
02:53:26 <dankna> direct your attention to the type signature of Processor.CPU_6502.cycle
02:53:39 <Eduard_Munteanu> peldan: it does static linking by default
02:53:54 <Eduard_Munteanu> peldan: if you supply -dynamic on the GHC cmdline it goes down a lot.
02:54:10 <dankna> as you can see, it takes an outerState (on which it is polymorphic) and some callbacks which, applied to outerState, do operations on it, including extracting the CPU_6502_State from it and putting it back in
02:54:13 * hackagebot webkit 0.12.2 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.2 (AndyStewart)
02:54:26 <Saizan> dankna: yeah, i see that you provide it accessors and modifiers callbacks
02:54:29 <dankna> this is an attractive architecture to me because it means the CPU code doesn't need to know anything about the memory model of the machine
02:54:41 <dankna> nor does it need to know that some memory addresses are actually I/O registers, and so on
02:55:02 <dankna> it performs at most one of fetchByte and storeByte per invocation
02:55:13 * hackagebot proc 0.0.9 - Parse process information for Linux  http://hackage.haskell.org/package/proc-0.0.9 (AndyStewart)
02:55:20 <dankna> and at most one time
02:55:31 <dankna> actually, s/at most/exactly/
02:56:16 <Saizan> but, are you calling Motherboard.NES.cycle in a loop?
02:57:11 <dankna> yes, that loop is Emulator.gamestateFrameForward, which I could paste if you want - it's the function that just went from 15% to 2% of self-time after adding strictness annotations to all the fields of SoftwareState
02:57:16 <dankna> though why it should have done that is a mystery to me
02:57:22 <Eduard_Munteanu> Well that loop itself might benefit from strictness
02:58:08 <dankna> hmm
02:58:25 <Saizan> yeah, paste that too, it's the only thing doing non-constant amount of work, afterall
02:58:32 <dankna> true enough!
02:58:32 <Eduard_Munteanu> Basically you're transforming states within a loop, no reason to have it lazy.
02:58:40 <dankna> indeed
02:59:42 * Saizan things we probably need to add bangs into CPU.CPU_6502_State and PPU.PPU_NES_State too
02:59:45 <Saizan> *thinks
02:59:48 * dankna nods
03:01:05 <dankna> doing that
03:02:49 <dankna> additional source for you to look at while it compiles: http://nopaste.dk/p3269
03:03:19 <Saizan> btw, if you have fields like Maybe Foo, to truly be sure everything is squashed out you should s/Just/Just $!/ when you're building up that field, or switch to a banged version of Maybe, though that might not be necessary
03:03:50 <dankna> hmm okay
03:05:03 <Eduard_Munteanu> Maybe try something like     $ state `seq` NES.cycle state   there
03:05:28 <Eduard_Munteanu> Wait no...
03:05:34 <Eduard_Munteanu> let loop vblankEnded traceLines state = state `seq` do
03:05:50 <Saizan> it shouldn't be needed
03:06:15 <Saizan> the if on shouldEnd should force the state enough, once you've made the fields strict
03:06:16 <dankna> latest profiling output added at the bottom: http://nopaste.dk/p3270
03:06:25 <Eduard_Munteanu> As I see it just because all fields are strict it doesn't mean the constructor is, right?
03:07:09 <Saizan> the constructor is strict, but it might not be demanded, but the if on shouldEnd should demand it
03:07:21 <dankna> this is gradually getting somewhere - it's down to 600M and change allocated now
03:08:41 <dankna> also by the way, this is called with tracePointer == nullPtr, which /I believe/ means NES.disassembleUpcomingInstruction is never evaluated, heh
03:09:17 <dankna> hmm
03:09:57 <ezyang> I think gamestateFrameForward needs to be stricter.
03:10:09 <dankna> okay - how :)
03:10:33 <dankna> going to rerun the heap-by-type profile to check my assumption that the major constructors on the heap are still the same
03:11:37 <ezyang> you never directly force 'state' in loop.
03:11:47 <ezyang> It might get forced, but that's unclear to me.
03:11:59 <dankna> yes, that's what we were just discussing
03:12:00 <Saizan> ezyang: the if on shouldEnd should force it
03:12:12 <Saizan> anyhow a !state won't hurt
03:12:16 * dankna nods
03:12:25 <Saizan> with {-# LANGUAGE BangPatterns #-}
03:12:30 <ezyang> Not necessarily, since && is lazy.
03:13:06 <Saizan> && is strict on the first argument
03:13:10 <Saizan> that's enough
03:13:36 <ezyang> This is shouldEnd, right?
03:13:45 <ezyang> I see the first arg of shouldEnd is ppuEligibleToEnd
03:13:47 <Eduard_Munteanu> BTW, you could later experiment with UNPACK pragmas or -funbox-strict-fields
03:13:59 <Eduard_Munteanu> But figure this one out for now.
03:14:03 <ezyang> and vblankEnded does not refer to state.
03:14:03 <Saizan> oh
03:14:17 <Saizan> i mixed it with cpuEligibleToEnd
03:14:19 * hackagebot manatee-core 0.1.0 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.1.0 (AndyStewart)
03:14:20 <ezyang> Unboxing will /probably/ help in this case.
03:14:40 <ezyang> because you're only repacking once per cycle.
03:14:43 <ezyang> and with all new values.
03:15:21 * hackagebot manatee-browser 0.1.0 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.1.0 (AndyStewart)
03:15:23 * hackagebot manatee-editor 0.1.0 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.1.0 (AndyStewart)
03:15:25 * hackagebot manatee-filemanager 0.1.0 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.1.0 (AndyStewart)
03:16:21 * hackagebot manatee-pdfviewer 0.1.0 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.1.0 (AndyStewart)
03:18:18 <dankna> latest profiling results.  no substantial change that I see from making state strict in loop.
03:18:19 <dankna> http://nopaste.dk/p3271
03:18:50 <dankna> oooh my heap profile has changed dramatically since we started
03:19:22 * hackagebot manatee-mplayer 0.1.0 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.1.0 (AndyStewart)
03:19:39 <ezyang> dankna: Do you have a heap profile, over time?
03:19:42 <dankna> putting that up for perusal, one sec
03:19:43 <dankna> yes I do
03:20:24 * hackagebot manatee-processmanager 0.1.0 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.1.0 (AndyStewart)
03:20:26 * hackagebot manatee-imageviewer 0.1.0 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.1.0 (AndyStewart)
03:20:28 * hackagebot manatee-terminal 0.1.0 - Terminal Emulator extension for Manatee.  http://hackage.haskell.org/package/manatee-terminal-0.1.0 (AndyStewart)
03:20:36 <dankna> http://dankna.com/himitsu/before-help.png -- heap profile over time from before we started discussing this
03:20:40 <Saizan> it's like CSI
03:20:46 <dankna> http://dankna.com/himitsu/after-help.png -- heap profile over time from my latest attempt
03:20:48 <dankna> indeed so
03:21:09 <dankna> as you can see, memory usage no longer grows without bound, although the spikes are still as high
03:21:20 <dankna> actually, I take that back, they're about 80% as high
03:21:20 <ezyang> Is this with the state strictness added?
03:21:23 * hackagebot manatee-template 0.1.0 - Template code to create Manatee application.  http://hackage.haskell.org/package/manatee-template-0.1.0 (AndyStewart)
03:21:25 * hackagebot manatee-ircclient 0.1.0 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.1.0 (AndyStewart)
03:21:29 <ezyang> It shouldn't be triangle'ing like that.
03:21:33 <dankna> yes, after-help.png is from the version the source of which you see on the latest paste
03:21:51 <dankna> it certainly shouldn't, but it is, haha
03:22:41 <ezyang> I forget, are UArrays strict?
03:22:41 <dankna> I believe the triangle represents one pass of the outermost loop - each time that loop finishes, I bundle everything up in a StablePtr and return it to the C main()
03:22:48 <ezyang> Yes.
03:22:53 <Eduard_Munteanu> Zoom in :P
03:23:04 <Jafet> They're unboxed, as the name suggests...
03:23:17 <dankna> they're strict, yes
03:23:23 * hackagebot manatee-reader 0.1.0 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.1.0 (AndyStewart)
03:23:25 * hackagebot manatee-curl 0.1.0 - Download Manager extension for Manatee.  http://hackage.haskell.org/package/manatee-curl-0.1.0 (AndyStewart)
03:23:27 * hackagebot manatee-welcome 0.1.0 - Welcome module to help user play Manatee quickly.  http://hackage.haskell.org/package/manatee-welcome-0.1.0 (AndyStewart)
03:23:29 * hackagebot manatee 0.2.0 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.2.0 (AndyStewart)
03:23:49 <ManateeLazyCat> Enjoy! :)
03:24:02 <ezyang> Note that ![] is only strict in the head element.
03:24:04 <dankna> ManateeLazyCat, grats on your many releases, haha
03:24:10 <ezyang> and not in any of the spine or the values.
03:24:18 <ManateeLazyCat> dankna: Thanks. :)
03:24:25 <dankna> hey yeah - what is that list that's eating so much space, hmm
03:24:33 <ezyang> Also note !(Maybe a) is only strict in the constructor, and not the value inside a
03:24:36 <dankna> the only thing I can think of is the list of microcode instructions
03:24:44 <dankna> so !(Maybe !a) would be strict on both?
03:24:49 <Saizan> no
03:24:54 <ezyang> see http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
03:25:04 <Saizan> you'd need data StrictMaybe a = Nothing | Just !a
03:25:09 <dankna> I see
03:25:21 <ezyang> Data.Strict
03:25:31 <ezyang> But wait up a sec, maybe only one of them is the problem.
03:25:34 <ezyang> I'd put money on the list.
03:26:13 <dankna> the list that I suspect that must be is cpu6502StateMicrocodeInstructionQueue :: ! [MicrocodeInstruction],
03:26:26 * Saizan puts money on the callbacks throwing up the strictness analyzer and all those let's becoming allocations
03:26:39 <dankna> also possible, yes
03:27:01 <ezyang> Saizan: They shouldn't result in triangle heap patterns.
03:27:16 <ezyang> Haskell code can generate a lot of garbage, but it will get garbage collected immediately if it's not leaky.
03:27:33 <Saizan> which could be fixed by sprinkling bangs to the lets, especially to the ones matching on tuples
03:27:35 <ezyang> I think the easiest way forward here is to make those remaining types stricter.
03:28:04 <Saizan> lazy tuple matching is known to be annoying retaining more than necessary
03:28:09 <dankna> I'm perfectly willing to do both :)
03:28:22 <dankna> I will note that tuples are no longer appearing as a major space consumer
03:28:24 <Saizan> *annoyngly
03:28:25 <ezyang> Bangs on the lets might not actually help.
03:28:42 <ezyang> Well, if you do the wrong ones, they won't help ;-)
03:29:26 <ezyang> BTW, this code looks very confusingly written and could probably be refactored.
03:29:46 <ezyang> in particular, cycle does way too much and has too many apostrophes.
03:29:57 <dankna> I agree.
03:30:01 <Eduard_Munteanu> That lot of garbage isn't necessarily fine, it might mean it misses the opportunity to do in-place updates.
03:30:03 <Saizan> dankna: it's not the tuple themselves that keep space, it's the fields, "let (x,y) = e in ..." both x and y in ... will keep e alive until they get forced
03:30:09 <dankna> exyang: That will be tomorrow's topic :D
03:30:17 <dankna> *ezyang
03:30:35 <ezyang> Well, it would be easier to eyeball debug space leaks if the data dependencies are clearer.
03:30:40 <Saizan> the whole of e, so the other too
03:30:46 <dankna> Saizan: okay, hmm.  so you're saying I should change patterns like let (x, y) to let (!x, !y) ?
03:30:49 * ezyang envisions a visual tool that shows you the data deps... 
03:31:17 <Saizan> dankna: yeah
03:31:21 <Eduard_Munteanu> I sure wish the strictness analyzer was a lot smarter.
03:31:58 <ezyang> "Undecidably smart", you might say :-)
03:32:10 <ezyang> I wonder if a useful special case would be to detect loop-style code.
03:32:24 <Saizan> also, "putState outerState $! ppuState''" might help the strictness analyzer wrt the callbacks
03:33:39 <Eduard_Munteanu> Isn't there a fair overlap between strictness analysis and uniqueness typing anyway? In the sense that if one could infer uniqueness it would automatically deal with a lot of strictness analysis.
03:34:08 <Eduard_Munteanu> (and there may be useful theory in the other camp too)
03:35:28 <dankna> did a pass through Processor.CPU_6502.cycle doing what Saizan said
03:35:42 <dankna> oh, just saw your latest, making that change too
03:38:25 <ManateeLazyCat> I believe something wrong in darcs server, i always got error "darcs failed:  Not a repository: AndyStewart@patch-tag.com:/r/AndyStewart/webkit ((scp) failed to fetch: AndyStewart@patch-tag.com:/r/AndyStewart/webkit/_darcs/inventory)", it's don't like ssh problem, it's like i can't push "hashed-format" patch to server.
03:39:32 <dankna> http://nopaste.dk/p3272 -- latest changes and profiling results, stand by for heap profile
03:39:39 <ManateeLazyCat> When i push patch to code.haskell.org/webkit, i got error, i thought maybe it's c.h.o server problem, but i just create new repository 'webkit' at patch-tag.com and push patches, same error, someone know what's wrong?
03:40:01 <dankna> heap profile not substantially changed, so I'm not going to bother to re-upload it
03:40:04 <kuraj> hey can anyone help me with debugging a part of prolog code? i know this might not be the right channel, but #prolog is deady dead
03:40:55 <dankna> ManateeLazyCat, check the version of darcs installed on the server
03:41:03 <ezyang> ok, I suggest datatypes next.
03:41:21 <Saizan> allocation moved from CPU's cycle to MB's cycle though, a bit
03:41:23 <ezyang> heh, prolog might be a little far from this channel's forte. Rewrite it in fundeps then come back?
03:41:44 <dankna> hm so it did
03:41:52 <dankna> more than a bit
03:42:04 <kuraj> uh haha... if i had any idea what fundeps were
03:42:20 <kuraj> i thought this would still be the next best thing to do, rather than asking #programming
03:42:26 <Eduard_Munteanu> kuraj: maybe #haskell-blah ?
03:42:27 * Saizan wonders if we should trust .prof on which function is allocating
03:42:37 <kuraj> #haskell-blah
03:42:39 <kuraj> er
03:42:45 <ezyang> It sounds like you might have managed to eliminate most of Processor.CPU_6502's leak.
03:42:48 <cheater15> maybe #esoteric
03:42:56 <Eduard_Munteanu> Heh.
03:42:56 <cheater15> kuraj^
03:43:04 <kuraj> sure, thanks for your suggestions
03:43:10 <dankna> Saizan: yeah, that's a good question.  given the callbacks and all that.
03:43:59 <Saizan> dankna: are the peaks lower, at least?
03:44:43 <dankna> only slightly this time around
03:44:59 <dankna> they're lower than when we started, but not substantially lower than the immediately previous attempt
03:46:27 <dankna> hm
03:46:55 <dankna> store and fetch, the functions in Motherboard.NES which are the meat of the callbacks, also had the let-tuple issue.  adding !s there.
03:49:08 <roconnor> NES?
03:49:14 <dankna> yes
03:49:20 <roconnor> Nindedo?
03:49:27 <roconnor> Nintendo
03:49:28 <dankna> it was the most popular videogame console of the second half of the 1980s, yes :)
03:49:35 <roconnor> this is your simulator?
03:49:38 <dankna> correct
03:49:46 <roconnor> and you are only interested in the final state?
03:49:49 <dankna> yes
03:50:00 <roconnor> you don't care about all the graphics and stuff that happens in between?
03:50:26 <dankna> there's some cleverness there, but in general I care only about the information that I explicitly save, regarding graphics in between
03:50:37 <roconnor> ok
03:53:50 <Eduard_Munteanu> Motherboard.cycle is still making a lot of garbage I think
03:54:44 * hackagebot manatee 0.2.1 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.2.1 (AndyStewart)
03:54:45 * dankna nods
03:55:14 <ezyang> Garbage != Space leak
03:55:38 <Eduard_Munteanu> Garbage is time :)
03:55:46 <ezyang> Yes.
03:55:53 <ezyang> But fixing space leaks can also result in more gabage.
03:55:56 <ezyang> *garbage.
03:56:15 <Eduard_Munteanu> (curiously that also means garbage is money by transitivity :P)
03:56:26 <Saizan> lots of garbage in a short time is a spike in the heap profile, no?
03:56:38 <ezyang> No.
03:56:50 <ezyang> Lots of *retained* garbage is a spike in the heap profile.
03:57:31 <dankna> http://nopaste.dk/p3273 -- updated profiling after I added more strictness.  I believe I reduced the time used by Motherboard.cycle and therefore made Processor.cycle once again a larger percentage by time.
03:57:48 <dankna> Motherboard.cycle is now 49% of the allocation, with the runner-up being 9%
03:57:50 <dankna> hmm
03:58:09 * ezyang still thinks you should just update the data types. 
03:58:42 <dankna> I'm willing to try it.  Update them how precisely?
03:59:36 <Eduard_Munteanu> I wonder if that foldl' fuses with concat and map
03:59:37 <ezyang> Replace Maybe and [] with strict versions.
03:59:47 <ezyang> Though I'm a little concerned about the fact the list is being used as a queue.
03:59:48 <Eduard_Munteanu> Though it's not that much work there.
04:00:25 <dankna> ezyang: well, I call it a queue, but I don't actually append to it except in the case where it only contains a single item
04:00:37 <dankna> ezyang: it also never contains more than, I think, seven items
04:00:58 <Eduard_Munteanu> (I mean the one in Motherboard.cycle)
04:01:04 <dankna> oh
04:01:14 <Saizan> dankna: are you still using only -O, btw?
04:01:30 <dankna> yes.  for the sake of controlled experiment.  do you think I should bump it up to -O2?
04:01:30 <Eduard_Munteanu> If that list is actually created it's not well.
04:01:47 <Eduard_Munteanu> dankna: yes you could even try -O2 -funbox-strict-fields
04:02:00 <dankna> Eduard_Munteanu, we're talking about chipsToCycle?
04:02:09 <dankna> okay, I'm going to try those compile options and see what we can see
04:02:12 <Eduard_Munteanu> Yeah.
04:02:59 <Eduard_Munteanu> The thing is, if it's a really tight loop, it might matter a lot if that list is being created every time or if it fuses away
04:03:23 <dankna> it is, it's the single most-called function in the program, and 27% of the self-time
04:03:27 <dankna> hmm
04:03:35 <ezyang> Yes. But we're trying to debug the space leak first, no?
04:03:37 <dankna> I had assumed it would fuse
04:03:43 <dankna> yes, space leak is definitely the priority
04:03:49 <Eduard_Munteanu> Do you have a space leak?
04:03:51 <dankna> well
04:03:52 <ezyang> We'll want to use different techniques to debug time leaks...
04:03:54 <dankna> it's not a LEAK
04:03:59 <ezyang> Yes it is...
04:04:05 <dankna> it's down to generating sixty megabyte-seconds of data
04:04:31 <dankna> well, the heap usage goes back down eventually, haha
04:04:40 <dankna> but actually, you're right, GC must be happening more frequently than that
04:04:44 <dankna> so I guess it is a leak
04:04:55 <Eduard_Munteanu> Note "total alloc = 560,737,896 bytes  (excludes profiling overheads)" itself doesn't imply a leak
04:05:06 <Eduard_Munteanu> Use -s and see whether that gets GCed away
04:05:08 <ezyang> yep.
04:05:16 <ManateeLazyCat> Manatee-0.2.1 release, Changelog at https://groups.google.com/forum/#!topic/manatee-user/D4_XQP3Qy6g
04:05:17 <dankna> what's -s?
04:05:25 <ezyang> But the heap profile fairly definitely looked like a leak.
04:05:29 <Eduard_Munteanu> RTS statistics
04:05:35 <Eduard_Munteanu> including GC stats
04:06:12 <dankna> oh
04:06:16 <dankna> sure
04:07:11 <dankna> chew on this: turning on -O2 -funbox-strict-fields made it larger and slower!
04:07:14 <dankna> http://nopaste.dk/p3274
04:07:21 <ezyang> Not too surprising.
04:07:21 <dankna> no change besides the flags
04:07:53 <ezyang> unboxing strict fields is very dicey business
04:08:00 <dankna> I see
04:08:05 <Eduard_Munteanu> Something might rebox it really often
04:08:39 <Saizan> -O2 alone?:P
04:08:54 <dankna> http://dankna.com/himitsu/unboxing-strict-fields.png
04:09:05 <dankna> hm
04:09:07 <Saizan> hah
04:09:20 <dankna> I have a space leak in my heap profile, in that I made this one twice the pixel dimensions of the previous one by accident :D
04:09:57 <dankna> trying -O2 alone now
04:09:58 <Eduard_Munteanu> It's definitely not updating State in-place
04:10:10 <ezyang> Fascinating.
04:10:14 <Eduard_Munteanu> So it probably has to copy a whole lot more now.
04:10:25 <ezyang> My guess is that when you unboxed, state got really big, so it magnified the space leak of state.
04:10:26 <Saizan> does GHC ever update anything in place?
04:10:34 <ezyang> No. Unless you tell it to (ST)
04:10:44 <Eduard_Munteanu> What? That sucks :/
04:11:03 <Eduard_Munteanu> I thought that was the whole point of strictness analysis.
04:11:12 <ezyang> 'twould be an interesting research topic.
04:11:22 <Saizan> no, the point is to not allocate thunks
04:11:42 <Saizan> if you're just going to evaluate them right away
04:12:05 <Eduard_Munteanu> Hm, I thought it'd at least try to avoid copying in some cases.
04:12:27 <ezyang> You'd need to know that the structure is not shared.
04:12:33 <ezyang> And you'd also need to not step on the GC's toes.
04:13:03 <dankna> hm!  I think I found a bug in the profile-report code
04:13:06 <dankna> it segfaulted
04:13:29 <dankna> in strlen(), in reportCCSProfiling()
04:13:59 <ezyang> What version of GHC?
04:14:30 <dankna> HEAD, 7.1.20110504-x86_64 on OS X, built by me a couple days ago.  so it's not exactly unexpected.
04:14:42 <ezyang> I wouldn't be surprised if loads of unboxed fields could trigger a bug like that.
04:14:49 * dankna nods
04:14:53 <ezyang> Ooh, HEAD. You should submit a report then.
04:15:14 <dankna> true, but producing a reduced testcase would be a bitch.  I can give a stack dump.
04:15:51 <ezyang> unreduced test case can also be useful.
04:15:58 <ezyang> as long as it's reproduceable, that's what we care about.
04:16:05 <ezyang> stack dump will probably also help, if the bug is eye-ballable.
04:16:22 <dankna> okay
04:16:56 <dankna> well, the build infrastructure is also a nightmare due to the hybrid Haskell-and-Objective-C nature of the code
04:17:00 <Eduard_Munteanu> But if it did nothing like that, then even foldl' (+) 0 would have to be O(n) in allocations, right?
04:17:18 <dankna> but okay, I'll file a report
04:18:35 <ezyang> hai hai, just a stack dump then ;-)
04:19:46 <Saizan> Eduard_Munteanu: the old sum can get garbage collected as it goes, so it might do O(n) allocations but it won't use O(n) memory at any given time, but for some primitive type like Int it might actually produce a fast in-place loop
04:20:19 <Saizan> where ti keeps everything in registers, even
04:20:33 <Eduard_Munteanu> Yeah, I didn't mean it was a space leak, just a high constant factor due to allocations.
04:24:09 <dankna> http://hackage.haskell.org/trac/ghc/ticket/5177
04:24:17 <dankna> any relevant information I should have provided but didn't?
04:24:39 <ezyang> Can you compile with -debug, hopefully getting line numbers too?
04:24:42 <dankna> sure
04:26:04 <dankna> I only have to compile the program with -debug, not the entire Haskell world, right?  heh
04:26:29 <ezyang> Yep.
04:26:39 <ezyang> Because -debug just means the debugged RTS gets linked in.
04:27:34 <dankna> libHSrts.a		libHSrts_p.a		libHSrts_thr_l.a
04:27:34 <dankna> libHSrts_debug.a	libHSrts_thr.a		libHSrts_thr_p.a
04:27:34 <dankna> libHSrts_l.a		libHSrts_thr_debug.a	libHSrtsmain.a
04:27:39 <dankna> which of these RTSes should i be linking with?
04:27:45 <dankna> I note the unfortunate absence of one that says _debug_p
04:27:50 <Eduard_Munteanu> Definitely main = putStrLn . show $ foldl' (+) 0 ([1..100000000] :: [Int])  is a whole lot slower
04:28:00 <Eduard_Munteanu> even at -O2
04:28:07 <ezyang> Oh, you have a weird build infrastructure, don't you...
04:28:10 <Eduard_Munteanu> * than C
04:28:11 <dankna> (I have to do my own linking - that's one of the annoying things about the .... yeh)
04:28:43 <ezyang> Hmm. I guess debugged and profiled RTS is not something anyone normal would do...
04:29:04 <dankna> apparently not.  I don't really want to take a 2-hour break now to go compile one, haha, although I do still have the tree I built this ghc in.
04:29:24 <Eduard_Munteanu> total alloc = 8,000,042,936 bytes  (excludes profiling overheads)
04:29:39 <Eduard_Munteanu> So I guess it's totally sucky :/
04:31:04 <dankna> if there's agreement that the bug is worth the effort (I will take a single person posting to the trac page with a request as agreement :) ), I'll do that tomorrow I guess.  meanwhile I'd like to continue investigating my space leak, haha
04:31:11 <Eduard_Munteanu> It's slower than gcc with -O0, heh
04:31:44 <Saizan> are you sure the addition is the slow part?
04:32:43 <Eduard_Munteanu> Well it could be the RTS startup time too
04:32:58 <Eduard_Munteanu> but usually that's not that big
04:33:04 <Saizan> or show
04:33:21 <Saizan> or gcc constant folding it
04:33:48 <Eduard_Munteanu> $ time ./perftest    real 0m1.490s
04:34:10 <Eduard_Munteanu> (with -O2, the Haskell variant)
04:34:43 <Eduard_Munteanu> I don't think it does folding at -O0 though
04:35:17 <Eduard_Munteanu> $ time ./perftest_c    real 0m0.364s
04:35:53 <Eduard_Munteanu> Indeed if I use -O2 with gcc it only takes 0m0.001s :)
04:38:23 <Eduard_Munteanu> Lemme try -H64m or something though...
04:39:39 <Eduard_Munteanu> Nah, only 3.1% GC time not worth it
04:40:46 <Eduard_Munteanu> Mind this is GHC 6.12.3
04:42:48 <dankna> http://nopaste.dk/p3275 and http://dankna.com/himitsu/unboxing-strict-fields-o1.png are results with -O -funbox-strict-fields
04:42:55 <dankna> not substantially different from the last ones you saw
04:43:03 <dankna> I just noticed something interesting
04:43:13 <dankna> which is that stateSoftwareState is doing 60% of the allocation
04:43:21 <dankna> that's a record accessor for a strict field
04:43:43 <roconnor> dankna: have you unboxed your strict fields yet?
04:43:46 <ezyang> Remember that strict-ifying a data structure doesn't mean you can't create thunks to it.
04:44:02 <dankna> roconnor: this is with -funbox-strict-fields; I haven't done by-hand unboxing yet
04:44:02 <Eduard_Munteanu> It's probably doing a lot of reboxing
04:44:11 <ezyang> So what could happen is requesting a strict field means that everything else now gets evalauted.
04:44:14 <dankna> hmm
04:45:11 <Saizan> main2 = case $wlgo 0 main3 of _ { __DEFAULT -> shows8 } <- ? it's computing the sum and then discarding it? or is shows8 receiving the Int# in some magical way?
04:47:39 <Saizan> Eduard_Munteanu: it seems it's not fusing the list, anyhow, foldl' is not a "good consumer", maybe
04:49:11 <dolio> Consumer of what?
04:49:41 <Saizan> of [1..1000000::Int]
04:50:05 <dolio> Using the stream fusion package, or just GHC built-in?
04:50:12 <Eduard_Munteanu> Wouldn't that list be way too big anyway not to fuse?
04:50:15 <Saizan> just GHC built-in
04:50:25 <dolio> Then no, it's unfusable.
04:50:42 <Saizan> Eduard_Munteanu: you can produce it lazily without fusing it
04:50:42 <dolio> GHC still uses foldr/build, as far as I'm aware.
04:55:37 <Eduard_Munteanu> Should I try stream-fusion?
04:55:54 <owst> @type return.map
04:55:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m ([a] -> [b])
04:56:02 <owst> @type return.sum
04:56:03 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => [a] -> m a
04:56:07 <owst> @type return.sum [1,2,3]
04:56:08 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Num (f a), Functor f) => f (m a)
04:56:16 <owst> :-/
04:56:50 <owst> Ignoring return.map (typo), wtf with those two?
04:57:52 <Eduard_Munteanu> @type return . sum $ [1,2,3]
04:57:53 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
04:58:13 <owst> Yeah, I used that in the end, but I'm a bit confused why it was necessary :)
04:58:52 <Eduard_Munteanu> The latter applies return . sum to [1,2,3]
04:59:30 <Eduard_Munteanu> The former produces a function composing return with sum [1,2,3], but sum [1,2,3] isn't a function
04:59:35 <Eduard_Munteanu> (sum is)
04:59:44 <owst> Hmm, ok.
04:59:51 <owst> @type (.) return sum [1,2,3]
04:59:52 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => m a
05:00:08 <Eduard_Munteanu> Yeah, it's a precedence thingy
05:00:18 <Eduard_Munteanu> Since function application binds tighter.
05:01:14 <dolio> Eduard_Munteanu: Stream fusion will probably fuse foldl' and [1..whatever].
05:01:20 <dolio> If that's what you're going for.
05:01:29 <owst> Right, ok, thanks. I was just struggling to convince myself it was what was going on.
05:01:35 <dolio> At least, I see no reason why it wouldn't.
05:01:40 <owst> Thanks Eduard_Munteanu
05:03:43 <Eduard_Munteanu> dolio: hrm simply replacing Data.List with Data.List.Stream still doesn't seem to do it.
05:04:05 <Eduard_Munteanu> $ time ./perftest     real 0m1.473s
05:04:07 <dolio> That package can't replace [1..whatever].
05:04:15 <dolio> You need to call enumFromTo from the package.
05:04:20 <Eduard_Munteanu> Oh.
05:07:03 <Eduard_Munteanu> Excellent... main = putStrLn . show $ foldl' (+) 0 (enumFromToInt 1 100000000)
05:07:14 <Eduard_Munteanu> real 0m0.121s
05:07:21 <dolio> Nice.
05:07:57 <Eduard_Munteanu> Now let's profile for heap stuff...
05:09:44 <Eduard_Munteanu> total alloc = 5,600,042,864 bytes  (excludes profiling overheads)
05:10:12 <Eduard_Munteanu> I guess it doesn't do any sort of in-place updates.
05:10:17 <Eduard_Munteanu> (for the accumulator)
05:10:26 <dolio> That's the entire program?
05:10:42 <Eduard_Munteanu> Yes, except two imports.
05:10:55 <Eduard_Munteanu> and main :: IO ()
05:10:57 <dolio> Wait, are you running with -prof?
05:11:24 <Eduard_Munteanu> Previously I wasn't, now I am, I'm getting total time  =        3.76 secs   (188 ticks @ 20 ms)
05:11:47 <dolio> What was the 5 billion number from?
05:11:56 <dolio> +RTS -sstderr?
05:12:15 <Eduard_Munteanu> The .prof file
05:12:24 <Eduard_Munteanu> +RTS -p
05:12:31 <dolio> Oh. profiling can interfere with optimizations.
05:13:19 <dolio> Compile normally like you did for the .121s run, and pass that RTS option I mentioned (I think that's the right one).
05:23:57 <Eduard_Munteanu> Oh, the same thing as -s
05:24:46 <Eduard_Munteanu> Not much alloc, hm.
05:25:08 <Eduard_Munteanu> 63,120 bytes allocated in the heap
05:25:13 <dolio> I wouldn't trust any allocation numbers you got from a profiling build.
05:25:35 <Eduard_Munteanu> So I guess it does some sort of in-place updates after all.
05:25:44 <dolio> It should.
05:27:16 <rostayob> How can I do FFI with some local .c and .h files?
05:28:00 <ion> IIRC, pass the c files to ghc --make, or something like that.
05:28:41 <ion> Or perhaps the object files. I’m not being very helpful. :-)
05:29:40 <rostayob> yeah I guess it's just a matter of linking the object files, but I was wondering if there is a nice way
05:31:21 <Eduard_Munteanu> dankna: you too might want to remove profiling and see if your program improved
05:38:45 <rostayob> ion: if i try to pass the c files to ghc it fails to parse one .h file :P
05:42:17 <rostayob> ah no, it compiles. i'll try that way
05:57:20 <rostayob> what's the best way to alloca for a some struct in some C code?
06:01:46 <ClaudiusMaximus> rostayob: depends..
06:01:52 <ClaudiusMaximus> :t with
06:01:53 <lambdabot> Not in scope: `with'
06:02:06 <ClaudiusMaximus> @hoogle Foreign.Storable.with
06:02:06 <lambdabot> No results found
06:02:14 * ClaudiusMaximus gives up...
06:02:49 <rostayob> ClaudiusMaximus: yeah but I have to create a storable type
06:03:11 <rostayob> found this: http://therning.org/magnus/archives/315
06:03:13 <ClaudiusMaximus> oh, i used hsc2hs for that, bit boring but worked for me
06:03:24 <rostayob> yeah that seems to be the thing
06:03:25 <cch> @hoogle a -> b -> (a, b)
06:03:25 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (a -> e -> (a, e)) -> a -> d -> (a, d)
06:03:25 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
06:03:25 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
06:04:00 <geheimdienst> > (,) 42 37
06:04:01 <lambdabot>   (42,37)
06:04:53 <geheimdienst> how was it again, that ^^ needs some extension or some special instance ...?
06:05:55 <ClaudiusMaximus> > 42 :: (Int,Int,Int) -- this kind of voodoo?
06:05:55 <lambdabot>   (42,42,42)
06:06:33 <opqdonut_> guess there's a Num instance for tuples (componentwise)
06:06:43 <opqdonut_> > (42,41) * (1.3,1.4)
06:06:44 <lambdabot>   (54.6,57.4)
06:07:15 <Jafet> @hackage vector-space
06:07:15 <lambdabot> http://hackage.haskell.org/package/vector-space
06:07:35 <lightstep> is there a library for fast modular arithmetic in haskell?
06:08:15 <lightstep> just found out that a powMod definition i copied from haskellwiki is a bottleneck
06:08:18 <Jafet> You could rebuild ghc with integer-simple and use gmp, or a library based on gmp.
06:09:43 <Jafet> Or try to optimize what you have in plain haskell
06:09:56 <Jafet> (Montgomery redc?)
06:10:31 <lightstep> i can't find the docs for the Integer module
06:10:55 <scree> lightstep: do you mean the one with mulMod, squareMod, powMod, ...? http://www.haskell.org/haskellwiki/Testing_primality
06:11:02 <lightstep> i think extracting the internal gmp data and calling ffi on that would be the simplest. less chance for obscure algorithm bugs
06:11:26 <lightstep> scree, yes, that's the one i use and it's pretty slow
06:11:37 <scree> lightstep: are you using ints or integers?
06:11:41 <Jafet> Intentionally breaking the interface abstraction... simplest... less chance for obscure bugs?
06:13:01 <lightstep> it will probably take less time than optimizing haskell code to a good level of performance
06:13:37 <ClaudiusMaximus> rebuilding ghc takes a while...
06:13:45 <lightstep> also trying to optimize will mean trying all sorts of algorithms, and there are lots of places for small mistakes in number-theory implemntations
06:13:58 <lightstep> does ghc not use gmp for its numbers?
06:14:03 <scree> lightstep: what -- overall -- are you trying to do?
06:14:03 <lightstep> by default?
06:14:15 <Eduard_Munteanu> lightstep: it does, for Integer
06:14:35 <ClaudiusMaximus> yeah, but it's patcehd for garbage collection or something, and trying to use regular gmp with it causes problems (at least that's what i've osmosed from irc/hackage hmpfr/etc)
06:14:43 <Jafet> You can't use gmp normally through the ffi – but you sound like you know this already.
06:14:54 <lightstep> scree, making diagrams based on data on large numbers of primes
06:15:55 <lightstep> Jafet, actually i guessed so, because googling for it didn't show anything
06:16:31 <scree> lightstep: so, your prime really are larger than machine integer size?
06:16:36 <scree> s/prime/primes
06:17:02 <lightstep> i'm on a 32-bit machine, so yes
06:17:23 <Jafet> Uh, how large are they?
06:18:10 <lightstep> they'd fit in 64 bits
06:18:17 <lightstep> around 10^11
06:18:45 <ClaudiusMaximus> @hoogle LargeWord
06:18:45 <lambdabot> No results found
06:19:13 <lightstep> @hoogle Word64
06:19:13 <lambdabot> Data.Word data Word64
06:19:16 <Jafet> ia32 can do some 64-bit arithmetic.
06:19:17 <lightstep> hmmm
06:19:29 <scree> lightstep: so, I can think of one reason that code would be slow
06:20:03 <Eduard_Munteanu> Jafet: it's more like some languages offer support for it
06:20:18 <scree> lightstep: it's insisting the exponent is the same type as the exponand; so you're doing expensive *2, div 2 operations on Integers
06:20:19 <Jafet> Wait, I thought there were native instructions.
06:20:40 <scree> lightstep: unless your exponent is of size 10^11 as well ...
06:20:57 <Jafet> (other than overflow, that is)
06:21:00 <Eduard_Munteanu> I thought it's just add with carry and all that.
06:21:08 <o1iver> hi guys. I am looking at some real-life haskell programs and I was wondering what the general of percentage of IO functions are in real-world programs... what are you experiences?
06:21:17 <Eduard_Munteanu> But that can implement even 128-bit addition.
06:21:24 <scree> lightstep: and even then, it's not clear to me that those operations are correctly optimized to bitshifts
06:22:31 <scree> Jafet: was that first comment at me?
06:22:31 <ClaudiusMaximus> o1iver: it very much depends - in my opengl/gtk stuff there's a lot of IO (not much choice..), in other things it's tiny (eg: using interact or similar)
06:22:50 <Eduard_Munteanu> Maybe MMX or other stuff can do it natively on x86-32.
06:23:00 <Eduard_Munteanu> otherwise you don't get 64-bit regs
06:23:20 <lightstep> why?
06:23:53 <o1iver> ClaudiusMaximus: I am a beginner, so I don't really know that much yet, but I am suprised by the amount of IO functions considering the possibility to use something like liftM
06:25:00 <Jafet> (How would liftM decrease the amount of IO code?)
06:25:51 <Jafet> lightstep: I suggest writing with Word64 and Bits and seeing if that improves speed enough
06:26:16 <lightstep> scree, i use large exponents in miller-rabin
06:26:17 <Eduard_Munteanu> It's probably faster than GMP stuff anyway, I think
06:26:32 <lightstep> and i'm pretty sure quotRem wouldn't have a special case for 2
06:26:48 <o1iver> Jafet: consider this example from the snap framework: http://hpaste.org/46463/snap. Could this not be done without IO?
06:26:50 <Eduard_Munteanu> It's just two inline instructions (excluding the actual loads)
06:27:06 <lightstep> i'm switching to Word64 right now, and it really does help
06:27:37 <o1iver> Jafet: and with lift I mean that instead of reading a file and parsing it in one function you write a string parse function and then lift it when used in the IO parse function (just a wrapped which also gets the string)
06:27:55 <o1iver> *wrapper
06:27:56 <Jafet> oliver: you might like (<$>).
06:28:40 <Jafet> readOptions has to read the command-line arguments, which involves IO
06:28:44 <Eduard_Munteanu> i.e. add %..., %...   adc %..., %...
06:29:16 <Jafet> Hrm
06:29:17 <Eduard_Munteanu> (This stuff is much more common on 8-bit mcus and such)
06:29:18 <Jafet> @hoogle getOpts
06:29:19 <lambdabot> No results found
06:29:22 <Jafet> @hoogle getOpt
06:29:22 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
06:29:22 <lambdabot> module System.Console.GetOpt
06:29:22 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
06:30:28 <Jafet> Okay, I'm not really sure why that one uses IO.
06:31:25 <Jafet> I find it amusing when people try to use number theory on 8-bit mcus and such
06:31:37 <Jafet> Like in cryptographic smart cards
06:32:04 <o1iver> Jafet: I am now confused as to how getOpt can be non IO
06:32:29 <scree> o1iver: so, the only reason that code uses IO is to throw an IO Error
06:32:41 <o1iver> Jafet: actually no it takes the opts as arguments. Well that is exactly my question then...why would that function use IO
06:32:49 <Jafet> What scree said
06:33:11 <o1iver> scree: yeah that makes sense, but that seems kind of wrong doesnt it
06:33:50 <Bynbo7> o1iver: i guess it's like numCapabilities. it's an Int that represents the number of threads available to run sparks/forkIO'd threads. it may change each run of the program, but never within a program
06:34:26 <Jafet> It could use Either String instead of IO, but this function doesn't seem like it would be used anywhere outside main, or even more than once inside main for that matter
06:34:28 <Bynbo7> hmm, or maybe I'm wrong, does getOpt just take in the results you give it from getArgs?
06:34:43 <Jafet> It's just a bunch of code moved outside main for clarity
06:35:02 <o1iver> Bynbo7: yes
06:35:27 <Axman6> ok, ignore what i said then =)
06:35:35 <Jafet> Now if you were talking about reused functions, like getOpt itself, then there are good reasons to not involve IO
06:35:44 <o1iver> Jafet: yes that makes sense, although I think I wouldnt do it this way...
06:36:02 <scree> o1iver: so, it's possible to throw an excetption in pure code and then catch it in the IO monad
06:36:38 <Jafet> The only way I know of is P.error (or having ghc do it for you)
06:37:15 <scree> doesn't Control.Exception do that for you?
06:37:47 <o1iver> I haven't spent much time on exceptions yet, so I will look into it
06:37:52 <Jafet> @hoogle Exception a => a -> b
06:37:52 <lambdabot> Control.Exception throw :: Exception e => e -> a
06:37:52 <lambdabot> Control.OldException throw :: Exception e => e -> a
06:37:52 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
06:38:04 <Jafet> Mm, maybe.
06:38:47 <scree> hm, seems I misunderstood
06:38:55 <scree> o1iver: you probably can't do that
06:39:14 <o1iver> scree: what do you mean?
06:40:07 <o1iver> just to correct: this is not actually from the snap framework...
06:40:12 <o1iver> got confused
06:40:29 <Axman6> :t throw
06:40:29 <lambdabot> Not in scope: `throw'
06:42:34 <o1iver> :t Control.Exception.throw
06:42:35 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
06:43:40 <Axman6> lambdabot :(
06:48:45 <scree> o1iver: so, I thought you could throw an exception from pure code, and then catch it later in the IO monad.  Experementation suggests you can't do this; or maybe I've just been failing to do the right thing
06:49:42 <scree> o1iver: wait, you can
06:49:51 <scree> @hoogle evaluate
06:49:51 <lambdabot> Control.Exception evaluate :: a -> IO a
06:49:51 <lambdabot> Control.OldException evaluate :: a -> IO a
06:49:51 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
06:49:57 <o1iver> scree: it wouldn't make sense to me how you could
06:50:22 <o1iver> scree: actually I take that back
06:50:37 <rly> Only 41 nicks and there are more than #python...
06:52:13 <Jafet> Our PhD density and volume dwarf #python's
06:52:56 <scree> o1iver: though it seems this approach is complicated.  It's obviously fairly significant when a lazy error is "forced"
06:53:01 <rly> Jafet: is that a good thing?
06:53:12 <geheimdienst> jafet: i find it offensive that you call our PhDs dense
06:53:34 <rly> geheimdienst: he didn't.
06:53:55 <geheimdienst> on the point of volume, i agree, most of them do seem to enjoy a few too many donuts these days
06:54:05 <Jafet> How about "thick"?
06:57:58 <rostayob> am I doing something wrong here: http://hpaste.org/46466/ffi ?
06:58:18 <rostayob> it segfaults, apparently it doesn't allocate the char *
06:58:24 <rostayob> while bufputs does allocate it
06:59:19 <Chaze> anyone here participating in google code jam?
06:59:37 <Chaze> just curious how haskell is standing in the contest against other languages :)
07:04:34 <rly> Chaze: why would anyone enter that competition?
07:04:44 <Chaze> rly: for the fun of it?
07:04:53 <rly> Chaze: it is not fun to solve trivial problems.
07:05:03 <ben> rly: Are you for real
07:05:10 <Chaze> rly: i suppose they become more complicated in further rounds
07:05:16 <rly> Chaze: they are trivial in a mathematical sense, because they have already been solved...
07:05:26 <Chaze> oh come on..
07:05:41 <rly> Chaze: you just find the right published mathematical paper and you implement it.
07:05:50 <rly> Chaze: where is the 'challenge' in that?
07:06:31 <Chaze> well, you can still write an elegant implementation
07:06:49 <Chaze> also, there's no 'mathematical papers' for those kind of problems
07:06:58 <Chaze> maybe GoroSort :)
07:07:02 <rly> Chaze: erm, yes, there are.
07:07:13 <Jafet> So Putnams, Olympiads and interview questions are trivial
07:07:23 <rly> Jafet: bingo.
07:07:24 <Jafet> Well, it's your point of view
07:08:16 <rly> Chaze: how do you think they come up with their problems?
07:08:28 <geheimdienst> rly, there is such a thing as programming. it's a creative act in itself to come up with an implementation, to fit it in the constraints of the machine, to get it to run quick enough, and so on
07:08:40 <rly> geheimdienst: programming is _not_ creative.
07:08:51 <geheimdienst> speak for yourself ...
07:08:52 <rly> geheimdienst: figuring out an algorithm might be.
07:09:16 <rly> geheimdienst: but almost no commercial programmer invents new algorithm these days.
07:09:23 <rly> algorithms*
07:09:29 <Chaze> besides, i have no idea how these problemes are called, hence i cannot peek into any papers
07:09:36 <Chaze> and have to think about it myself
07:09:48 <Tomsik> Yeah, coming up with idea of how to do something is fun, but implementation itself
07:09:57 <rly> Tomsik: exactly.
07:11:17 <geheimdienst> one program might be written in a plain way, while the author of another program came up with a more clever way. so there is room for cleverness in programming. that counts as creativity in my book
07:12:53 <rly> If they would actually solve completely new problems, then all you would have is a lottery, since creativity is just luck + experience.
07:12:54 <Jafet> Programming is not all about algorithms, but it's sadly common for certain ignorant people to conceive of them that way
07:13:18 <rly> Because of statistics, someone is bound to solve the problem.
07:13:18 <Jafet> s/them/it/
07:13:42 <rly> Then these contests would still do some good. Now it is just wasting time as a recruitment process.
07:13:55 <rly> But if you find it 'fun', go and compete.
07:14:20 <Jafet> Everything we do in the world is wasting time
07:14:32 <Jafet> Like responding to irc trolls
07:14:35 <rly> Jafet: what else is programming about?
07:14:49 <Jafet> That's a sort of extreme example though
07:14:58 <rly> Jafet: I would say that if it is about anything else, the machine is broken.
07:15:13 <scree> rly: just because a problem has been solved, doesn't mean it's "trivial" or less fun
07:15:29 <rly> scree: that is your opinion. I have a different one.
07:15:35 <scree> rly: unless you're foolish enough to look up the solution instead of trying to solve it yourself
07:16:07 <scree> rly: so, if I give you a problem, and you don't know whether it's been solved or not, is solving it fun or not?
07:16:25 <rly> scree: I first figure out whether it has been solved or not.
07:16:47 <scree> rly: and if you can't?
07:17:01 <scree> rly: you're in a locked room or something
07:17:15 <rly> scree: there are no locked rooms where I am.
07:17:47 <scree> rly: so, you're saying you couldn't tell whether it was a fun problem, because for you, fun is fundamentally extrinsic to the problem?
07:17:47 <rly> scree: but if the problem has not been solved I consult with my client whether he wants me to solve an unsolved mathematical problem.
07:18:51 <ben> So if your client wants you to implement a solved problem, you laugh him off because he's asking you to do something trivial?
07:19:03 <rly> scree: some problems have algorithmic freak objects as a solution. If you don't know the solution, and then become aware of the solution that can be experienced as 'fun'. Solving something like that happens every decade or so for all of humanity.
07:19:26 <rly> ben: no, it is work.
07:20:12 <Jafet> I suspect rly doesn't recognize fun in computer programming. Actually I suspect rly is trolling, but it's politically incorrect to accuse someone of that, so I won't.
07:20:48 <rly> Jafet: where is the fun in doing something where you already know the outcome? (that the program will do exactly as in my head)
07:21:26 <rly> "Modern" programming is even less fun, because you have to build on top of tons of broken code written by others.
07:21:47 <scree> rly: it seems you only care about problems with big real-world applications; otherwise there's no way to justify that statistic.  If so, fair enough, but the rest of us believe problem-solving can be fun for its own sake
07:21:48 <geheimdienst> i find it silly to treat math's limited view of things as if it's somehow superior or the only thing that counts. building a bridge is a challenge, no matter that the math might be "just a few differential equations" that "have been solved before"
07:21:49 <rly> Take Haskell. We don't even have a working implementation of Haskell.
07:22:09 <scree> Jafet: point taken
07:22:09 <rly> We have some approximation of Haskell98.
07:22:14 <Jafet> Okay, I blatantly accuse rly of trolling.
07:22:22 <Jafet> So slap me.
07:22:34 <rly> Jafet: that's ineffective over a computer screen.
07:22:39 <geheimdienst> rly: please make a specific complaint about a haskell implementation, instead of blanket trolling
07:22:52 <Jafet> You could be the first to solve that problem
07:22:53 <rly> geheimdienst: everyone with a clue knows what I am talking about.
07:23:03 <geheimdienst> @where ops
07:23:03 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
07:23:17 <rly> Jafet: what would I gain?
07:24:15 <Jafet> The ability to slap people over irc?
07:24:18 <rly> Perhaps nhc98 is a working Haskell implementation, but nobody uses that.
07:24:24 <Jafet> It has intrinsic value.
07:26:40 <sshc> How is Codensity different from ContT?
07:26:41 <Axman6> rly: what on earth are you on about?
07:26:48 <rly> In general, what is the point of solving a problem by hand, when you can program a computer to solve it for you?
07:27:03 <geheimdienst> Axman6: careful, you're feeding the troll
07:27:18 <rostayob> rly is a troll. when I asked about a data structure here he told me to go to #algorithms, or something like that
07:27:18 <rly> I can see the fun of writing such generic program solvers.
07:27:23 <Axman6> I'm just curious how GHC doesn't implement haskell98
07:27:53 <rly> Axman6: perhaps you want to read the user manual?
07:28:07 <rly> Axman6: are you too lazy to read it?
07:28:19 <geheimdienst> Axman6: he doesn't seem to know. when i asked him, he made blanket insults ("everyone with a clue knows")
07:28:20 <Axman6> that may well be true, because GHC now implements haskell2010
07:28:35 <Jafet> Who uses haskell98 anyways
07:28:38 <Jafet> @quote dreaded
07:28:38 <lambdabot> No quotes match.
07:28:45 <Axman6> which has dropped a lot of haskell98 features that were broken to begin with
07:28:56 <Axman6> @quote 98
07:28:56 <lambdabot> Cale says: Oleg can bend spoons with his mind, in the type system, in Haskell 98.
07:29:06 <rly> Ah, sure, so they come up with a language specification, then decide it is too hard to implement for them and come up with a new standard that matches their implementation. BRILLIANT!
07:29:15 <Axman6> ha
07:29:41 <Axman6> this is indeed a strange way to troll a channel
07:29:41 <rly> Who are the trolls now?
07:30:40 <Axman6> well, obviously you are, because you can't probide a single shred of evidence to support your claims. they may be true, but refusing to back them up is a sure sign of a troll
07:31:16 <sully> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#vs-Haskell-defn
07:31:28 * Zao migrates rly to C++.
07:31:40 <Zao> cf. expot
07:31:41 <Zao> *export
07:32:21 <sully> my favorite list of deviations from a language standard is over in SML-land, where the list of SML/NJ's deviations from the definition is maintained by the largest competing implementation, mlton
07:32:40 <Zao> Hah.
07:32:56 <Zao> Well, ML doesn't really have any useful standards :)
07:33:13 <sully> I mean, it has a standard, certainly
07:33:26 <sully> useful might be a matter of debate
07:33:34 <Phyx-> 16:26:57 < rly> geheimdienst: everyone with a clue knows what I am talking about.
07:33:37 <Phyx-> lol
07:33:41 <Phyx-> I obviously don't have a clue then
07:33:42 <geheimdienst> why, it's right there in the name, "standard ml" :)
07:33:51 <rly> Phyx-: and some indeed have shown to have clue.
07:34:02 <rly> Phyx-: isn't it great that you still have something to learn?
07:34:09 <geheimdienst> rly: you not being among them
07:34:17 <Axman6> what is wrong with not conforming to haskell98 anyway?
07:34:18 <sully> rly: the fact the you are right doesn't mean you aren't an asshole, though.
07:34:26 <rly> geheimdienst: that's still for me to decide.
07:34:26 <lightstep> rly, is your complaint about ghc's parser? or bugs in the rts? or the impossible happening?
07:34:26 <jmcarthur> take it elsewhere if you're just going to argue (everybody, not just rly)
07:35:00 <sshc> How is Codensity different from ContT?
07:35:49 <Saizan> sshc: Codensity f a ~ forall r. ContT r f a
07:36:06 <Axman6> don't C++ compilers have to be able to accept code that cannot terminate while parsing them to meet the standard?
07:36:38 <Saizan> sshc: so you're fairly restricted in how you can use the continuation
07:36:39 <rly> Axman6: if you don't know anything, just don't touch the keyboard.
07:36:43 <Jafet> Now C++, there's an example of them changing the spec because no one wanted to implement it
07:36:45 <Axman6> rly: also, you do understand the of the main developers of GHC was the chair of the haskell98 committee?
07:36:53 <Phyx-> rly: well.. yes it is, because unlike you I don't claim to know everything
07:36:55 --- mode: ChanServ set +o jmcarthur
07:36:57 <rly> Axman6: I know that.
07:36:59 <sully> Axman6: no; the standard specifically allows implementations to impose arbitrary limits on template recursion
07:37:33 <sshc> I see
07:37:53 <rly> It must be comforting for you to have someone -- sully -- to fill in the details.
07:38:28 <rly> I am pretty sure he is wrong in one tiny detail, though.
07:38:36 <Saizan> rly: that confrontational and condescending tone is unacceptable here
07:38:38 <jmcarthur> you guys can disagree without insulting each other
07:38:38 --- mode: ChanServ set +o Saizan
07:38:42 --- mode: Saizan set +b *!*rly@unaffiliated/rly
07:38:54 --- mode: jmcarthur set -o jmcarthur
07:38:57 <Axman6> please enlighten us, we can’t wait to hear more of your words of wisdom
07:39:06 <geheimdienst> thanks saizan
07:39:07 <Saizan> Axman6: same for you
07:39:15 <rothwell> would've liked to have known what detail that was...
07:39:18 <Axman6> eh?
07:39:18 <ksf> woah woah, #haskell is oozing with sarcasm
07:39:22 <Axman6> what did i do?
07:39:33 <Zao> sully: I had quite fun when TA:ing a course in programming languages, where the assignments were in SML.
07:39:47 <ksf> so just shaddup, all you goodfornuthing highbrow academics.
07:39:49 <Zao> sully: "what do you mean, there's no Map in the SML Basis?"
07:40:10 <sully> Zao: I just finished doing that this semester :)
07:40:11 <sshc> Is anybody here aware of any texts describing Codensity?
07:40:14 <sully> yeah, that's bad.
07:40:20 <Saizan> Axman6: you followed him on the same tone.
07:40:20 <AnAdorableNick> \la
07:40:24 <sully> the Basis is pretty bad
07:40:27 <ksf> sshc, no gentle ones, no.
07:40:32 --- mode: Saizan set -o Saizan
07:40:39 <sully> fortunately smlnj-lib fixes up a lot of this and ships with sml/nj and mlton
07:40:46 <Zao> Axman6: There's an appendix in the C++ standard listing recommended quantities that compilers ought to honor, wrt. instantiation depth, number of bases, etc.
07:41:00 <Axman6> ok
07:41:04 <Zao> sully: We use Moscow ML for hysterical raisins.
07:41:06 <sshc> ksf: Any non-gentle ones?  (WHat do you mean by "gentle"?)
07:41:09 <sully> Zao: ah.
07:41:16 <Phyx-> Zao: i bet that was one confusing course
07:41:24 <jmcarthur> even if it's directed at somebody we seem to agree is trolling, a negative attitude isn't really the greatest thing to have around here
07:41:29 <joe6> can C++ be interfaced with haskell FFI? Is it a big deal to do so?
07:41:40 <sully> well, the mlton port of smlnj-lib could probably be made to work in mosml
07:41:40 <Zao> Phyx-: It's quite fun to have to out-implement your students so you can answer their questions.
07:41:55 <sully> we had some good assignments
07:42:00 <Axman6> Saizan: i said one thing, and i get a warning, and he got to go on like that for what, an hour?
07:42:00 <ksf> sshc, http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf
07:42:04 <Zao> joe6: In distant history, there was a foreign import "cplusplus" or so.
07:42:08 <sshc> Thanks
07:42:09 * sshc looks
07:42:11 <Zao> joe6: No-one ever established semantics for it, so "no".
07:42:12 <Phyx-> Zao: when I was TA I only made the first few assignments, then I got lazy, lol
07:42:19 * Jafet slaps Axman6 over the internet
07:42:21 <sully> Zao: I was really quite happy about my polymorphic type inferencee
07:42:23 <Jafet> He's dead Jim.
07:42:25 <ksf> the transformation itself is quite mechanic.
07:42:25 <Phyx-> and just anticipated where problems would be and made those parts
07:42:27 <Zao> joe6: The closest you get is extern "C" free functions and using them.
07:42:37 <Saizan> Axman6: i got here just now
07:42:39 <joe6> Zao: ok, thanks
07:43:06 <sully> *polymorphic type inference assignment
07:43:20 <geheimdienst> to be fair, i think axman6 was much more patient than rly before resorting to sarcasm. for me the line was crossed already 20 mins ago when i asked what rly's issue was with ghc not implementing haskell correctly, and he answered "everyone with a clue knows"
07:43:33 <cch> are there functions that encode/decode bytestring to/from string ?
07:43:42 <Saizan> geheimdienst: i agree
07:43:45 <Axman6> thank you geheimdienst
07:43:45 <joe6> would it be hard to write a haskell FFI for something like this? http://pastebin.com/SiBYRce4
07:43:52 <Jafet> cch: see Data.Text.Encoding
07:44:06 <Saizan> still, it's not helpful to the channel to engage in sarcasm
07:44:14 <ksf> geheimdienst, yeah. as I said. high-brow academics.
07:44:17 <Jafet> (and Text.unpack, if you really really want to convert to and from Strings)
07:44:26 <ksf> I'd just say "well, whatever, I'm fine with being an idiot"
07:44:29 <geheimdienst> saizan, that's true
07:45:00 <cch> Jafet: that seems to be between bytestring and text, not string
07:45:05 <Jafet> Yeah, sarcasm is really dangerous to have over irc
07:45:28 <geheimdienst> joe6: my understanding is that interfacing with c++ is nearly impossible. you'd have to make a c interface first
07:45:48 <Axman6> joe6: what would make it hard?
07:45:57 <Axman6> ah, it's C++?
07:45:59 <ksf> of course it's near impossible. not even c++ manages to interface with c++
07:46:10 <geheimdienst> ksf, that's what i meant :)
07:46:25 <Phyx-> ksf: lol
07:46:52 <Zao> How do you instantiate a template from Haskell? How do you implement an ABC from Haskell, etc.
07:47:11 <ksf> implementing classes is a problem in C too, though.
07:47:11 <Zao> As long as you're dealing with "C with Classes", you have a rather straight-forward mechanical translation.
07:47:26 <ksf> GTK+ isn't particularly useable from haskell because of that.
07:47:28 <Jafet> cch: because Text is usually preferred, for the same reasons that ByteString is preferred over [Word8].
07:47:54 <cch> Jafet: i see, thanks
07:48:07 <ksf> and it really, really doesn't help the state of haskell UI toolkits that we don't have any sane object system (read: first-class heterogenous records) yet.
07:48:51 <ksf> someone hacking some support into ghc so that the HList/records libraries become less of a pain would be great.
07:49:40 <Jafet> Someday, haskell will be more like ocaml, but still as cool!
07:50:00 <ksf> if we had proper records we could do ml-style functors
07:50:41 <Tomsik> But why we don't?
07:50:49 <Tomsik> Is it a type system issue?
07:51:12 <ksf> you need extensions to do it, and stuff gets hairy around the corners.
07:51:38 <ksf> it's not particularily nice syntactically, and the inferred types are less than optimal.
07:51:59 <ksf> it's kinda like passing typeclasses by hand.
07:53:07 <Jafet> I suppose the main problem is that ghc already has so many extensions
07:53:22 <ksf> hmm doesn't the new ghc come with a new kind system?
07:53:25 <ksf> or was it the next one?
07:54:14 <ksf> Jafet, then do it for uhc.
07:54:35 <Cobra> joe6: you can try generating a c wrapper with cgen, http://hackage.haskell.org/package/cgen
08:01:20 <joe6> Cobra, ok. thanks.
08:01:59 <joe6> geheimdienst, ok. thanks.
08:02:19 <geheimdienst> you're welcome
08:05:45 <joe6> i am trying to inteface with gpsim (http://gpsim.sourceforge.net/) from haskell. The socket interface that is provided out-of-the-box is considered experimental and even the packaged examples did not work. I figure I can use an expect script acting as a buffer between the gpsim cli interface and my haskell script.
08:06:30 <joe6> I could easily do something like that, but, then I thought of why I need "expect" there  and if I could bypass that and communicate with the cli interface from haskell directly.
08:07:17 <joe6> Are there any haskell packages that can do what "expect" does? spawn a client, send commands to the client and read the output from the client?
08:07:46 <joe6> and the gpsim cli interface uses (I think) gnu readline.
08:10:05 <cch> doesn't ByteString.readFile accept unicode filepath? see https://gist.github.com/960570
08:10:47 * hackagebot cmdargs 0.6.10 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.6.10 (NeilMitchell)
08:10:59 <ksf> cch, unix filepaths aren't necessarily unicode.
08:11:11 <ksf> strictly speaking, they're sequences of octets.
08:11:22 <Axman6> esxcept on OS X i think
08:11:26 <paolino> hello, is there a nice method to find the highest set bit in a number ?
08:11:35 <ksf> yes.
08:11:35 <cch> ksf: I use utf8 locales
08:11:46 <ksf> cch, locale doesn't matter.
08:11:47 * hackagebot cmdargs 0.7 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.7 (NeilMitchell)
08:11:51 <ksf> not for file encoding.
08:12:28 <ksf> cch, something like that http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightLinear ?
08:12:29 <cch> ksf: so how can I make it read from utf8 filename ?
08:13:41 <ksf> I have no idea, all my files have ascii names.
08:14:04 <ksf> oh. paolino.
08:14:14 <ksf> use that link I send cch instead or "man ffs"
08:14:24 <ksf> (srsly, that's the name of the function, ffs)
08:14:41 <Zao> ksf: It's sad how many applications break when trying to build paths into the home directories of people with funny names.
08:14:52 <Zao> Both spaces and non-latin glyphs in there \o/
08:15:03 <ksf> spaces are ascii.
08:15:33 <ksf> breaking on spaces is inane, but you can't treat any filename in any other way than a string of octets.
08:15:47 <ksf> it may use any encoding, including none.
08:15:57 <Zao> ksf: You're missing Windows.
08:16:28 <Zao> Where NTFS speaks UTF-16, and the API speaks either the current codepage or UTF-16.
08:16:31 <Zao> Great fun.
08:16:37 <geheimdienst> that's how i always understood linux filenames ... bunch'a bytes with \NUL and / forbidden
08:16:47 <ksf> in practice, though, linux usually uses utf-8 for filenames.
08:17:11 <Zao> ksf: Rather, sloppy developers assume that utf-8 is used for filenames, and things break A Lot with "legacy" filenames.
08:17:16 <ksf> I guess readFile just truncates the upper bits of the codepoints, cch, you should try utf8-encoding the string.
08:17:31 * Zao has a decade of latin-1 files all around his $HOME.
08:17:41 <ksf> well, better an informally introduced standard than no standard at all.
08:17:48 <Zao> It's always fun to see the constant spam of "malformed UTF-8" warnings and crashes.
08:18:39 <cch> ksf: but readFile's argument type is FilePath i.e. String, not ByteString
08:19:14 <ksf> cch, that doesn't mean much.
08:19:21 <ksf> if in doubt, have a look at the source.
08:19:34 <paolino> ksf, bits are complicate :)
08:20:15 <cch> ksf: if I suply readFile with ByteString, the compiling would failed
08:21:03 <ManateeLazyCat> All gtk2hs/manatee libraries have push to https://patch-tag.com/r/AndyStewart, if you can't push patches to code.haskell.org like me, you can send your gtk2hs/manatee patches to me, i will synchronous those patches when administrator fix code.haskell.org server.
08:21:53 <monochrom> filename conversion to String was done right in the past and is wrong now, i.e., iso-latin-1
08:22:40 * Saizan wonders how that happened
08:22:53 <ManateeLazyCat> Yes, absolutely, current String-base library for filename is wrong, System.Directory etc....
08:23:03 <monochrom> it happened by ghc sticking to iso-latin-1 in the past
08:23:17 <monochrom> look for ghc 5 for example
08:23:24 <paolino> ksf, it should be log2, I guess
08:23:40 <monochrom> actually as recent as ghc 6.8 or 6.10 too
08:24:40 <Saizan> ah, so it was done right before ghc 5?
08:24:40 <monochrom> the dilemma is that you can't safely assume universal utf-8 adoption either
08:25:02 <monochrom> it was done right because iso-latin-1 was considered right
08:25:04 <cch> then how can I read from a unicode filepath?
08:25:45 <ManateeLazyCat> cch: AFASIK, GIO support unicode filepath, GIO is apart of gtk2hs
08:25:48 <ManateeLazyCat> @hackage gio
08:25:48 <lambdabot> http://hackage.haskell.org/package/gio
08:25:48 <monochrom> do a String->String conversion that does "decode to iso-latin-1"
08:25:52 <Saizan> ah, ok, i misunderstood the first sentence
08:26:22 <monochrom> yeah, program behaviour hasn't changed, our expectation has changed
08:27:06 <ManateeLazyCat> cch: GIO is base on ByteString
08:27:20 <cch> ok, I'll check it
08:28:29 <monochrom> Data.ByteString.Char8 represents the final iso-latin-1 legacy
08:29:02 <plumenator> This is be off topic, but does anyone have Clean running on Mac OS X?
08:32:25 <ManateeLazyCat> cch: I have write many code that base on GIO at here: https://patch-tag.com/r/AndyStewart/manatee-core/snapshot/current/content/pretty/Manatee/Toolkit/Gio/Gio.hs , such as return filename under directory, maybe you interested it.... :)
08:36:42 <ndxtg> parseFile :: FilePath -> IO [Exps] <---- is it possible to catch the [Exps] into a variable when calling that function? smthing like result = parseFile "abc.txt"?
08:37:12 <luite> ndxtg: result <- parseFile "abc.txt"
08:37:58 <luite> ndxtg: at least if you're in a do block of an IO function
08:38:18 <ndxtg> luite: thank you, I have got the idea
08:38:33 <ulfdoz> sry, this is probably offtopic, but anyone able to connect to any server of IRCnet from germany?
08:42:13 <luite> is there a hackage server with reverse deps still online?
08:42:53 <ksf> if you want to fix that situation, I guess lsb is the right address.
08:43:05 <luite> oh found one
08:45:50 <cch> ManateeLazyCat: ok, thank you :)
08:46:07 <ManateeLazyCat> cch: You're welcome! :)
08:46:40 <cch> I find unicode filepath supplied as command line argument are accepted by readFile correctly. see http://hpaste.org/46467/readfile
08:47:22 <ManateeLazyCat> cch: BTW, are you chinese?
08:47:28 <cch> ManateeLazyCat: yes
08:47:37 <ManateeLazyCat> cch: Hehe, me too. :)
08:47:47 <cch> ManateeLazyCat: haha :D
08:48:38 <cch> ManateeLazyCat: you always use GIO to read from a unicode filename ?
08:48:39 <ManateeLazyCat> :t getArgs
08:48:40 <lambdabot> Not in scope: `getArgs'
08:48:49 <ManateeLazyCat> cch: Yes.
08:49:08 <cch> getArgs is in module System.Environment
08:49:28 <ManateeLazyCat> cch: In fact, GIO is part of GTK+ project, and http://hackage.haskell.org/package/gio is haskell binding to GIO library.
08:49:41 <Saizan> cch: yeah, because those are already bytes disguised as Char's
08:50:03 <monochrom> oh yikes, more chinese :)
08:50:27 <monochrom> getArgs is another one of those iso-latin-1 legacy
08:50:49 <monochrom> and again you can't safely assume it's utf-8 either
08:52:03 <cch> monochrom: what iso-latin-1 legacy, can you give me some further reference ?
08:52:17 <ManateeLazyCat> cch: IMO, ByteString always is internal filename format in your program, you just need decode it when you need *show* filename in GUI. :)
08:52:35 <monochrom> generally, in ghc's IO lib, everything is iso-latin-1 except Handle
08:52:42 <Saizan> you can exploit the fact that leaves the bytes unmangled though, which you can use to do your own encoding/decoding
08:53:11 <path[l]> who wrote lambdabot
08:53:13 <monochrom> do you know the iso-latin-1 encoding? aka iso-8859-1
08:53:37 <aristid> where bytes and unicode codepoints coincide
08:53:41 <NihilistDandy> path[l]: gwern, I think
08:53:44 <NihilistDandy> Among other people
08:54:06 <cch> monochrom: yes, i know
08:54:29 <monochrom> alright, so a long time ago ghc assumed universal adoption of iso-latin-1
08:54:56 <path[l]> ah
08:55:01 <cch> oh, that should really longtime ago :)
08:55:17 <path[l]> I have an irc bot Ive been building and Im wondering how to detect pinging out
08:55:34 <cch> for them to assume that
08:56:02 <monochrom> then some time ago, enough dissident voices led to more choices of encoding/decoding for Handle data, you can choose utf-8, you can choose "the current code page" in windows, etc
08:56:24 <monochrom> and "some time ago" is really as recent as 6.8 or 6.10
08:56:32 <Jafet> path[l]: a timeout is merely when you've decided that you failed to receive anything from the other end long enough
08:56:39 <ManateeLazyCat> path[l]: Irc server will send ping message to you, then you can send pong message to server.
08:56:52 <monochrom> however, that's for Handle data only. filenames and environment variables have not changed
08:57:00 <path[l]> Jafet: ah I see. So if I believe it's been a long time, I should force a reconnect?
08:57:03 <ManateeLazyCat> path[l]: If you bot at server side, it's simple.
08:57:17 <Jafet> Well, you can ping the server back, if you want.
08:57:40 <path[l]> ManateeLazyCat: yeah, it is
08:58:36 <path[l]> hmm
09:00:19 <cch> monochrom: ok thanks
09:00:32 <path[l]> let me try that, thanks
09:00:36 <path[l]> Im using the ircjs module
09:01:25 <Saizan> path[l]: one that worked well for me: if you don't get any message in some given time interval, send a ping to yourself, if you don't see that either within another time interval the connection is probably dead
09:01:36 <cch> monochrom: so what's the difference between literal unicode string written in source file and that same unicode string read from cmd line argument ?
09:01:55 <cch> since their type signature are both String
09:02:02 <path[l]> Saizan: thanks
09:02:34 <Saizan> cch: literal unicode strings are a list of codepoints, what you get from getArgs is a list of utf8 octects disguised as a String
09:02:43 <ManateeLazyCat> Ok, time to sleep, good night all. :)
09:02:50 <ndxtg> sorry noob question again, how to deal with IO monad: http://codepad.org/q5lX1nPk I cant extract the [Exps] after IO ?
09:03:01 <monochrom> literal string in source file -> the compiler reads it. string read from cmdline -> some library code reads it. the compiler doesn't have to do the same thing as the library code
09:03:06 <cch> ManateeLazyCat: good night :)
09:03:49 <monochrom> in fact, the compiler does utf-8 decoding properly for source file
09:04:26 <monochrom> library code hasn't been updated
09:05:39 <cch> monochrom: I see, thanks
09:07:41 <Saizan> you can get the bytes back with map (fromIntegral . Data.Char.ord) :: String -> [Word8]
09:09:15 <monochrom> > map (fromIntegral . Data.Char.ord) "λ bot 勁"
09:09:16 <lambdabot>   [955,32,98,111,116,32,21185]
09:09:28 <monochrom> however, you said Word8
09:09:33 <monochrom> > map (fromIntegral . Data.Char.ord) "λ bot 勁" :: [Word8]
09:09:34 <pastorn> monochrom: what's that last char?
09:09:35 <lambdabot>   [187,32,98,111,116,32,193]
09:09:50 <Saizan> monochrom: and i meant only for those String's you get from getArgs
09:09:55 <monochrom> > map Data.Char.chr [187,32,98,111,116,32,193]
09:09:55 <lambdabot>   "\187 bot \193"
09:11:09 <monochrom> oh, that works
09:11:29 <Saizan> i.e. what the old utf8-string code did for System.IO in general
09:11:59 <Saizan> it's still valid for non-Handle things
09:12:34 <monochrom> 勁: http://humanum.arts.cuhk.edu.hk/cgi-bin/agrep-lindict?query=%ab%6c&category=wholerecord
09:21:36 <zomg> Noob question
09:21:59 <zomg> I have a "IO String", where the string contains some JSON I want to run thru Text.JSON decode
09:22:16 <kmc_> an "IO String" doesn't contain a String
09:22:24 <NihilistDandy> And that wasn't a question
09:22:32 <zomg> Yeah cause you didn't let me finish ;)
09:22:43 <zomg> Shouldn't I be able to use fmap or such to use decode on the string?
09:22:49 <zomg> Or am I missing the point here
09:22:50 <NihilistDandy> You didn't let me finish
09:22:50 <kmc_> yes
09:22:54 <NihilistDandy> my sentence
09:23:07 <aristid> zomg: yes. do you have problems with fmap?
09:23:08 <kmc_> your "IO String" is a description of how to perform some IO resulting in a string
09:23:17 <zomg> NihilistDandy: well I'm sorry my irc window isn't as wide as yours =)
09:23:28 <NihilistDandy> zomg: :D
09:23:47 <merijn> @unpl  (sum .) . zipWith (*)
09:23:47 <lambdabot> (\ d g -> sum (zipWith (*) d g))
09:23:55 <merijn> Yay! lambdabot is back :)
09:24:17 <zomg> Well I'm understanding it correctly that fmap basically would allow me to get the string from the IO monad
09:24:18 <NihilistDandy> Which is good news, because the temp crashed mysteriously last night
09:24:25 <NihilistDandy> No idea what happened
09:24:25 <merijn> Also, are there people who would really consider something like " (sum .) . zipWith (*)" good style? >.>
09:24:45 <zomg> similar to how foo <- whatever would make foo the string
09:24:54 <merijn> zomg: No, if you have an "IO a" and a function "a -> b" you will end up with an "IO b"
09:25:01 <merijn> (using fmap, I mean)
09:25:17 <Jafet> merijn: use the .:!
09:25:23 <zomg> merijn: yeah I mean that using decode with fmap should work, like using decode into foo in "foo <- iostring" should work
09:25:36 * Jafet wonders if unicode has a three vertical dot glyph
09:25:47 <kmc_> foo <- fmap decode getStringThing
09:25:48 <merijn> Jafet: What do you mean?
09:26:06 <Jafet> @hoogle (.:)
09:26:06 <lambdabot> No results found
09:26:16 <alexbagel> zomg: something like foo <- decode <$> iostring is common
09:26:30 <kmc_> zomg, there's no way to pull values out of IO; you can only push your functions inside
09:26:33 <Jafet> :t let f .: g = (f .) . g in sum .: zipWith (*)
09:26:34 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
09:26:45 <zomg> kmc_: yeah I'm just trying to figure out why decode is giving an error :)
09:26:46 <Jafet> Okay, I don't use the .:.
09:26:48 <zomg> when used with fmap
09:26:58 <zomg> Error "Unable to read ()"
09:27:05 <kmc_> zomg, put your code on hpaste.org and we can look at it
09:27:11 <kmc_> ok., that doesn't sound like a type error to me
09:27:13 <merijn> Jafet: That doesn't answer my question whether anyone is insane enough to think that is readable :p
09:27:17 <NihilistDandy> Jafet: In Chinese and Japanese, the ellipsis is used that way
09:27:18 <zomg> kmc_: I'm just running it in ghci for experimenting
09:27:34 <Jafet> Only when they're written vertically
09:27:39 <NihilistDandy> Exactly
09:27:43 <kmc_> zomg, note that "fmap f a" is equivalent to "do { x <- a; return (f x) }"
09:27:45 <kmc_> if that helps any
09:28:20 <merijn> :t fmap
09:28:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:28:41 <Jafet> merijn: well, when you know what it means, it's not bad
09:28:49 <zomg> kmc_: that also produces the same error in ghci
09:28:59 <alexbagel> :t (<$>)
09:28:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:29:24 <zomg> if I just do foo <- iostr and then decode foo :: Result JSValue, it works
09:29:37 <merijn> Jafet: How much brain damage does it take (on average) before you reach that point? Because right now I still need manual substitution to figure "any . (==)" out
09:29:39 <pmetzger> btw, been meaning to ask for a while: why does lambdabot describe types using "forall"?
09:30:01 <pmetzger> I know that way of doing things from type theory but it isn't the normal haskell syntax...
09:30:12 <kmc_> because GHC supports some extensions which go beyond Haskell types
09:30:17 <kmc_> and which require explicit ∀
09:30:30 <merijn> pmetzger: It is normal haskell (well, GHC anyway) syntax, they're just usually redundant
09:30:35 <Jafet> And because it's nice logical notation!
09:30:40 <pmetzger> ∀
09:30:40 <pmetzger> 12:34 merijn
09:30:40 <pmetzger> pmetzger: It is normal haske
09:30:48 <NihilistDandy> Is there an ∃, too?
09:30:49 <pmetzger> gah, sorry.
09:30:52 <merijn> NihilistDandy: No
09:30:56 <NihilistDandy> Aww
09:31:05 <Jafet> You can rewrite existentials with foralls
09:31:06 <pmetzger> So even though it isn't required in this case lambdabot always uses it?
09:31:12 <kmc_> NihilistDandy, GHC has existential types but the syntax is different
09:31:13 <merijn> pmetzger: Correct
09:31:19 <kmc_> UHC has explicit "exists"
09:31:20 <Jafet> pmetzger: lambdabot doesn't care; it uses whatever ghc uses
09:31:27 <kmc_> Haskell has neither "forall" nor "exists"
09:31:35 <pmetzger> I didn't notice ghci doing that when I do :t though
09:31:38 <NihilistDandy> kmc_: Aha. That makes sense
09:31:43 <Jafet> :set -Xexplicit-foralls
09:31:51 <pmetzger> ah.
09:31:59 <Jafet> Er, except it isn't called that
09:32:03 <kmc_> GHC's existentials aren't first class :/
09:32:07 <pmetzger> where can I read up on the typing extensions btw?
09:32:11 <kmc_> GHC manual
09:32:18 <pmetzger> reasonable.
09:32:35 <kmc_> it has pretty good descriptions
09:32:43 <kmc_> of course, you can ask questions here if it's confusing :)
09:32:55 <Jafet> -XExplicitForAllAndMakeMyShiftKeyCry
09:34:24 <Zao> -XMyKeyboardGentlyWeeps
09:34:40 <NihilistDandy> :set -fglasgow-exts, yeah?
09:35:00 <Jafet> NoScrewYouThatIsDeprecated
09:35:03 <merijn> -XMyBrainOpenlyWeeps
09:35:21 <NihilistDandy> What's the nondeprecated way? :D
09:35:24 <merijn> -XOhGodIDoNotGetHalfTheseCombinators
09:35:57 <Jafet> You're supposed to recompile your module ten times for ghc to try to guess which extensions you meant to specify
09:36:07 <Jafet> Then add them as language pragmas
09:36:11 <NihilistDandy> Of course
09:36:15 <NihilistDandy> It all makes sense~
09:36:15 <kmc_> no, you're supposed to know what language you've written your code in after you've written it
09:36:24 <kmc_> doesn't seem unreasonable to me
09:36:28 <NihilistDandy> How could I have even thought of another way? How silly of me.
09:37:14 * Jafet carefully puts away the sarcasm and does not employ it again
09:37:27 <NihilistDandy> I disbelieve
09:37:43 <aristid> NihilistDandy: of course you disbelieve. you're a nihilist dandy.
09:42:43 <pmetzger> -XXXplicit
09:43:56 <Jafet> Why don't you have some -XMagicHash
09:44:18 <Zao> Jafet: And have my head explode? No thanks.
09:45:46 <kmc_> GCC doesn't require you to enable extensions individually
09:45:59 <kmc_> but allows you to turn them all off en masse
09:46:02 <kmc_> i wonder which approach is better
09:46:34 <Zao> GCCs lenient approach to extensions leads to people using them without knowing they do.
09:46:37 <Jafet> Well, gcc is universally abused by everyone who expects it to work for their code and not work for anything that does not resemble their code
09:46:45 * Zao eyes the Linux kernel, libstdc++ and other offenders.
09:46:52 <Jafet> Those are... tricky interface design constraints.
09:46:57 <kmc_> the Linux kernel developers know that they're using GCC extensions ;P
09:47:05 <kmc_> there's a few that it's easy to accidentally use
09:47:14 <kmc_> i didn't know until recently that pointer arithmetic on (void*) is an extension
09:47:19 <Zao> kmc_: The barrier to entry is lowered if they're there without having to motivate enabling them.
09:47:32 <ksf> kmc_, arguably, that's dirty anyway.
09:47:37 <Zao> But handy.
09:47:39 <ksf> what's sizeof (void)?
09:47:46 <Jafet> ksf: one!
09:47:49 <Jafet> !!1
09:47:55 <Zao> My favourite implicit extension is VC++ allowing you to bind reference-to-non-const to a temporary.
09:48:11 * kemsah
09:48:12 <kmc_> ksf, over 9000
09:48:20 <pmetzger> kmc_: yah, that's a very natural extension but most people don't really know it is an extension.
09:48:21 <ksf> Jafet, what's wrong with char, then?
09:48:24 <Zao> ksf: The first time I accidentally triggered GCCs   a ? : b;  I got ready to stab someone.
09:48:46 <pmetzger> kmc_: I can't remember if C99 blessed it finally or not. I don't think they did though.
09:49:08 <Jafet> No, it wouldn't have, but it introduced intptr_t
09:49:09 <Zao> And of course, their abuse of ?>, ?<, etc.
09:49:20 <Zao> Never before have typos been so much fun.
09:49:26 <kmc_> digraphs?
09:49:29 <ksf> trigraphs are arguably the worst part of the c standard.
09:49:41 <Zao> kmc_: No, shorthand for min/max.
09:49:43 <merijn> I have to use ICC to cross compile my projects C code atm, never new I accidentally used so many non-standard things :x
09:49:54 <kmc_> ICC tries to be bug-compatible with GCC though
09:49:54 <pmetzger> everyone ignores trigraphs.
09:50:02 <Jafet> On a side note, my favourite line of legitimate C is #define NULL!!!!!11
09:50:02 <Zao> a ?< b   is  __ninja_builtin_min(a, b) or something.
09:50:04 <ksf> merijn, -ansi -pedantic -Werror
09:50:05 <pmetzger> I don't think I've ever seen code that used trigraphs.
09:50:07 <merijn> kmc_: Well, not by default, apparently
09:50:08 <kmc_> at least it has a mode where it tries this
09:50:13 <kmc_> hahaha Jafet
09:50:17 <pmetzger> you can't define NULL to anything but 0
09:50:23 <merijn> ksf: That accepts so much more stuff then ICC/Solaris compiler
09:50:52 <ksf> merijn, you could also write your stuff in lua.
09:50:55 <ksf> lua is pure ansi.
09:50:58 <pmetzger> in fact, comparing a pointer to 0 is special, even if null pointers aren't actually 0 internally to the implementation.
09:51:11 <merijn> ksf: I would totally if I was allowed to :p
09:51:20 <Zao> Reminds me of a C course I worked with once.
09:51:26 <Zao> "Soo, which standard are we teaching now again?"
09:51:29 <merijn> Lua has to be better then C for larger projects
09:51:42 <kmc_> Lua has to be a totally different language than C for larger projects
09:52:06 <merijn> Hence why it'd be better :p
09:52:07 * Zao notes he is not in -blah, and shuts up.
09:52:07 <pmetzger> I don't think I could implement GHC efficiently on top of Lua. :)
09:52:11 <Zao> Sorry about the irrelevance.
09:52:32 <kmc_> merijn, if your large projects are typical applications, you have no business using C in the first place
09:52:39 <falbani> hi
09:52:42 <kmc_> if you're writing a realtime OS kernel, different story
09:52:52 <kmc_> hi falbani
09:52:59 <merijn> kmc_: I fully agree, unfortunately I am not allowed to trash the existing codebase :<
09:53:18 <kmc_> unfortunately a lot of people write apps in C out of ignorance or machismo
09:53:21 <falbani> I have 2 pieces of code that I suspect can be better expressed in Haskell
09:53:30 <kmc_> because the only alternative to C is PHP and PHP isn't for *real* programmers
09:54:03 <kmc_> falbani, what language are they now?
09:54:16 <falbani> kmc_: haskell
09:54:24 <kmc_> ok
09:54:30 <kmc_> you can put them on hpaste.org if you'd like suggestions
09:54:38 <pmetzger> There is another reason to use C. Sometimes I do small apps in C because I've used it for so long that it is just more comfortable.
09:54:44 <NihilistDandy> kmc_: Wait, is that what people think? C or PHP? My head hurts...
09:54:59 <kmc_> NihilistDandy, or "C or Java", or "C or Perl"
09:55:04 <pmetzger> I had a class a couple of years ago where there was an assignment to write a small simulator for a CPU branch predictor.
09:55:14 <pmetzger> I did it in C. The instructor was aghast.
09:55:15 <NihilistDandy> kmc_: That's why I left my old school/major
09:55:41 <pmetzger> But OTOH it took me very little time to do it, and I was going to throw it away afterwards anyway.
09:55:41 <kmc_> if you learn to program through a typical route, the idea of a language other than C with a native-code compiler is entirely foreign
09:55:50 <falbani> http://hpaste.org/46468/merging_infinite_sorted_list
09:56:06 <ksf> kmc_, first language I learned was pascal
09:56:18 <pmetzger> First language I learned was Fortran IV.
09:56:32 <kmc_> falbani, "if then else" is usually a bad way to do things in Haskell
09:56:44 <kmc_> can use guards or "case" instead
09:56:44 <Twey> pmetzger: I think that is a good reason to use something else
09:56:55 <stulli> Is there a way to specify command line arguments in ghci?
09:56:59 <pmetzger> Twey: expand?
09:57:02 <c_wraith> stulli: :set
09:57:06 <kmc_> :set args foo
09:57:15 <iago> hi, is there some package to derive instances of GADTs ? (such as derive-gadts, but being maintained)
09:57:19 <falbani> kmc_: is that an aestetical reason? performance reason? legibility?
09:57:32 <kmc_> aesthetics, legibility, flexibility
09:57:38 <kmc_> "if then else" only works for Bool
09:57:44 <kmc_> "case" is the more general way to analyze data types
09:58:05 <kmc_> "if then else" is a stupid special case which shouldn't be in the language, imo
09:58:13 <c_wraith> falbani: in that particular example, using case would enable a *slight* increase in efficiency when the two elements are equal
09:58:14 <stulli> c_wraith: Thanks, :set args works like expected
09:58:33 <Twey> pmetzger: Precisely that you have already used that language enough to become comfortable with it, so it is a good idea to use another language now for the same reason
09:58:44 <pmetzger> kmc_: pattern matching is a damn nice paradigm compared to if/else. I like it.
09:58:54 <pmetzger> Twey: not if it is 1am and you're tired. :)
09:58:55 <Jafet> LANGUAGE NoIfThenElse?
09:58:59 <Twey> Haha
09:59:06 <c_wraith> I'd use that extension :)
09:59:09 <pmetzger> Twey: but I'm doing a project now in Haskell precisely so I can stretch.
09:59:13 <falbani> kmc_, c_wraith: I agree
09:59:14 <Twey> *nod*
09:59:39 <KirinDave> So I'm almost finished with my first haskell progra
09:59:47 <falbani> I suspect there is a nicer way of manipulating the list for obtaining the same result
09:59:52 <KirinDave> I just need to write the main and add ReadLine support
10:00:08 <kmc_> falbani, you could use @-patterns
10:00:15 <KirinDave> It ended up much more... twisted and convoluted... than I had hoped. I'm hoping people here might be able to give me a hand figuring out how to improve it
10:00:16 <kmc_> for a little efficiency and maybe readabality gain
10:00:27 <falbani> kmc_: yes, also... but that does not change de algorithm
10:00:36 <KirinDave> https://github.com/KirinDave/Rag/blob/master/rag/Main.hs
10:01:42 <KirinDave> Anyone have any advice on a better choice than WriterT [String] Reader, or maybe how to better compound mazeLoop, doCmd and handleOutcome
10:01:50 <kmc_> falbani, why do you think there's a better algorithm?
10:01:51 <falbani> kmc_: in my experience, when I finish an algorithm in haskell, later I find an approach involving higher order functions
10:02:12 <kmc_> ok, that probably doesn't change the underlying algorithm though
10:02:14 <falbani> kmc_: I answer before your question :P
10:02:51 <falbani> kmc_: but I like when all those lines get replace by a map, fold or something similar :P
10:03:01 <kmc_> i don't know of a general higher-order function which captures this pattern of "iterate two lists, taking elements from one or the other"
10:03:13 <kmc_> you could write one yourself
10:03:16 <c_wraith> I don't think there's a standard combinator for that, either.
10:03:56 <falbani> kmc_, c_wraith: so I have hit the top of abstraction...
10:04:15 <kmc_> i'm sure you *could* write this as a fold, but I don't think you'd like the result
10:04:35 <c_wraith> I'd write it with unfoldr....  that'd be truly horrific :)
10:05:53 <falbani> ok... I'm going to hpaste de second piece of code
10:07:21 <Guest5956> all parser combinators are monadic?
10:07:54 <kmc_> does "monadic" mean "someone has written a Monad instance" or "someone could sensibly write a Monad instance"?
10:08:10 <monochrom> no, some parser combinator is not monadic
10:08:11 <Jafet> Depends on how Platonic you feel
10:08:17 <Guest5956> the sencond
10:08:48 <Guest5956> i mean if they are better seen as monads
10:08:51 <monochrom> the uu-parselib suite has parser combinators that cannot possibly be made monadic
10:09:20 <KirinDave> What is the equivalent term for 'monadic' for a process which arrows can model?
10:09:32 <kmc_> nothing, because arrows suck
10:09:40 <KirinDave> Daannnnggg
10:11:07 <pastorn> isn't there a monad instance for kleisli?
10:11:21 <kmc_> wrong kind
10:11:29 <kmc_> i think you have that backwards
10:12:20 <falbani> http://hpaste.org/46469/title_not_coming_to_mind
10:12:28 <kmc_> there's an Arrow instance for (Kleisli M) if there's a Monad instance for M
10:12:46 <KirinDave> Does anyone have a good explanation for what Kleisli means?
10:13:00 <KirinDave> I see the term even in some of the haskell documentation
10:13:07 <kmc_> i can explain
10:13:10 <KirinDave> But I haven't found a working definition.
10:13:15 <kmc_> do you know what a category is?
10:13:33 <KirinDave> Roughly. I've been going through an introductory category book
10:13:42 <KirinDave> I've done exercises regarding isomorphisms in the category of sets.
10:13:43 <kmc_> okay
10:13:47 <NihilistDandy> KirinDave: Ooh, which one?
10:14:11 <kmc_> in Haskell terms we'll just say that a category is a binary type constructor
10:14:14 <kmc_> with some properties
10:14:23 <KirinDave> NihilistDandy: Conceptual Mathmatics, ed2
10:14:25 <kmc_> the infix operator (~>) is a type variable, so we'll use that
10:14:38 <NihilistDandy> KirinDave: Hmm, haven't seen that one. I'll have to give it a look
10:14:50 <kmc_> a category has «id :: a ~> a» and «(.) :: (b ~> c) -> (a ~> b) -> (a ~> c)»
10:15:08 <kmc_> with the laws that (.) is an associative operator, and "id" is a left and right identity for it
10:15:14 <kmc_> that's what a category is
10:15:18 <kmc_> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Control-Category.html
10:16:17 <KirinDave> Okay
10:16:30 <kmc_> for any monad M, you can make a category of functions like (a -> M b)
10:16:37 <kmc_> where id = return, and (.) = (<=<)
10:16:41 <kmc_> :t (<=<)
10:16:42 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
10:16:57 <KirinDave> Oh huh
10:17:02 <KirinDave> hadn't seen <=<
10:17:40 <KirinDave> Okay. I'm with you
10:17:51 <kmc_> in other words: newtype Kleisli m a b = K (a -> m b); instance (Monad m) => Category (Kleisli m) where { id = K . return; K f . K g = K (f <=< g) }
10:18:23 <KirinDave> And then lost me.
10:18:26 <kmc_> (Kleisli M) is "the Kleisli category of the monad M"
10:18:54 <kmc_> the point is that (<=<) is like function composition
10:18:56 <KirinDave> So basically it's defining the composition and id for some monads
10:18:58 <KirinDave> Yeah
10:19:05 <kmc_> and return is like an identity function
10:19:08 <KirinDave> The mapping of that to . was not lost on me.
10:19:18 <kmc_> and categories are things which are like function composition in a particular way
10:19:40 <kmc_> the bit that lost you is just the actual definition of the thing i had previously described informally
10:19:55 <kmc_> the main obstacle is that you have to introduce a new type and a wrapping constructor to make the Haskell type system happy
10:21:09 <KirinDave> Okay
10:21:38 <KirinDave> So some docs mention Kleisli categories as if some monads do not fall into that category?
10:21:42 <KirinDave> or was I misreading them
10:21:59 <kmc_> every monad has an associated kleisli category, by construction
10:22:03 <kmc_> the construction i gave above
10:22:21 <kmc_> it's a different category for each one
10:22:22 <chrisdone> Evening, chaps. Does anyone know how to make a JArray literal in HJScript or HJavaScript? I'm after a function like [t] -> Array t
10:22:32 <KirinDave> Okay
10:22:34 <kmc_> the functions (a -> [b]) form a category, and (a -> Maybe b), and (a -> Either Char b)
10:22:42 <KirinDave> I see
10:22:49 <KirinDave> So this is just a way to manipulate those.
10:22:56 <KirinDave> Why is this observation meaningful?
10:23:06 <KirinDave> When is it useful to talk about things from this perspective?
10:23:09 <falbani> c_wraith: why the use of case would be more efficient in the case of EQ?
10:23:13 <kmc_> it's not that useful
10:23:25 <falbani> c_wraith: I have just to repeat one of the other branches result
10:23:31 <kmc_> most practical Haskell code does not use the Category or Arrow APIs
10:23:47 <kmc_> while a lot of practical Haskell code does use the Monad and Functor APIs
10:24:14 <c_wraith> falbani: no, in the case of EQ, you can go (forgive any spelling errors, I closed the window with your code): a : b : ordener cmp as bs
10:24:25 <chrisdone> I'm considering using JConst, but that's a bit crap.
10:24:32 <KirinDave> kmc_: Interesting. Thanks.
10:24:47 <KirinDave> kmc_: It seems like arrows are only useful in a very small number of cases.
10:25:11 <kmc_> KirinDave, have you seen http://hackage.haskell.org/package/category-extras
10:25:20 <KirinDave> Nope.
10:25:26 <KirinDave> It says it's obsolete?
10:25:36 <kmc_> yeah, it got split up but i don't remember what the pieces are
10:26:14 <falbani> c_wraith: you are right... I over saw that because I was thinking in real numbers and the zero probability of being equal :P
10:26:17 <chegibari>  Hello. Could anybody help me to understand what does exactly "head position" mean in a lambda expression?
10:26:50 <BMeph> KirinDave: They are. Usually, when you have something you can use as an Arrow, you also know, and want to exploit, more (or less) information about it.
10:26:50 <chegibari> btw, I read the wikipedia definition and I still don't understand it
10:27:33 <c_wraith> falbani: another reason you might not do it that way is if the function you are writing is specified to return all equal elements from one list or the other first, as would be the requirement for merge from a stable mergesort
10:27:54 * KirinDave ughs
10:28:04 <KirinDave> All these Python versions of my haskell program are 1/3 the length.
10:28:15 <KirinDave> Mesa gonna be shamed.
10:28:29 <KirinDave> Although I do have a robust error-reporting parser, they have unpredictable behavior
10:28:41 <Peaker> what's the difference between weak head normal form and head normal form?
10:29:09 <dmwit> Whenever I try to make my Haskell program really short, I end up having about 32 imports that are themselves longer than the solution in another language.
10:29:24 <KirinDave> dmwit: Yeah but..
10:29:25 <Peaker> chegibari, it seems "head position" is the outer-most in the lambda, top of the expression tree
10:29:31 <Peaker> (I'm guessing from context, though)
10:29:41 <KirinDave> dmwit: You saw my code
10:29:50 <chegibari> http://en.wikipedia.org/wiki/Beta_normal_form
10:29:52 <KirinDave> dmwit: These are some of the other implementations people are doing: http://pastebin.ca/2054910
10:29:59 <chegibari> I'm reading that, for example
10:30:18 <bos> KirinDave: don't listen to the category fetishists. they're trying to make sure you never write any actual code.
10:30:24 <KirinDave> dmwit: And https://gist.github.com/960396
10:30:30 <chegibari> when I read after "A beta reduction is in head position if it is of the following form:"
10:30:35 <KirinDave> dmwit: Although #2 is nightmare.py
10:30:47 <KirinDave> bos: I understand that acutely.
10:31:49 <chegibari> I don't understand if that expression is a nested abstraction applied to some expressions or a nested abstraction whose body is a nested application
10:32:00 <jonkri> (how) would you shorten the field names of this record: data ClientHandler s = ClientHandler { clientHandlerMessageReceived :: Maybe (s -> Message -> IO (s, Bool)), clientHandlerPresenceReceived :: Maybe (s -> Presence -> IO (s, Bool)), ... } ?
10:32:04 <falbani> c_wraith: if you can, take a look at http://hpaste.org/46469/title_not_coming_to_mind please. Thanks in advance
10:32:09 <KirinDave> dmwit: I still want to find a way to get my maze code shorter.
10:32:29 <chegibari> I'm reading "Abstract computing machines" and this concept is a show stopper. I can't get after chapter 6
10:32:52 <KirinDave> dmwit: I feel like my problem is I'm trying to keep the IO out of my game loop
10:32:57 <dmwit> jonkri: You could stick it in a module named ClientHandler and give them the names "messageReceived" and "presenceReceieved" or so (or leave off "received" if they're all named that way).
10:33:02 <bos> KirinDave: what is it you're trying to wrestle with?
10:33:06 <dmwit> Then use the module system to give them any prefix you like. =)
10:33:18 <KirinDave> bos: https://github.com/KirinDave/Rag/blob/master/rag/Main.hs
10:33:46 <KirinDave> bos: I'm trying to figure out how to make that shorter. And I need to get readline support in there before I call it done
10:35:00 * BMeph prefers Haskelline
10:36:01 <bos> KirinDave: i see plenty of opportunities to trim stuff, but what are you unhappy with?
10:36:24 <jonkri> thanks DMarsden
10:36:24 <KirinDave> bos: doCmd, the monad stack I'm using, and handleOutcome bother me in particular
10:36:28 <jonkri> dmwit, sorry
10:36:58 <bos> KirinDave: yes, handleOutcome's type signature is strange
10:37:15 <KirinDave> bos: I'm not sure what I should do with it. Should I put the gamestate into a State monad?
10:38:19 <KirinDave> bos: And then the signature is Handler ()
10:38:24 <bos> well, what's the game involve? a game state, a piece of input, and something that bangs them together to give a new game state?
10:38:39 <KirinDave> bos: Yeah, the type is in types.hs
10:39:20 <KirinDave> Forgot to add types
10:39:27 * bos forks and clones
10:39:32 <KirinDave> bos: https://github.com/KirinDave/Rag/blob/master/rag/types.hs
10:39:44 <KirinDave> And ignore metaaction, I gotta remove that
10:41:18 <bos> KirinDave: why don't i see types.hs in my local copy of the tree?
10:41:25 <KirinDave> bos: Pull again
10:41:33 <KirinDave> bos: I had accidentally not included it until just a moment ago
10:42:14 <bos> KirinDave: ah
10:42:23 <bos> KirinDave: anyway, i see a few interesting things
10:42:38 <bos> KirinDave: i assume that the world map is an unchanging thing?
10:42:40 <KirinDave> bos: I am a raw newbie at haskell, this is my second program period.
10:42:44 <KirinDave> bos: ... For now. :)
10:43:28 <bos> KirinDave: so if the world map is immutable, normally you'd store that in a Reader, which we use for immutable data ("this is the environment i'm working in").
10:44:46 <bos> KirinDave: looks like a Room is intended to be immutable too
10:45:24 <bos> but i assume that while the map never changes, the actual room you're in might?
10:45:51 <bos> so you can't change anything about a room, but you can change which room you're in?
10:46:27 <KirinDave> bos: Yes.
10:46:34 <KirinDave> bos: Yes.
10:46:44 <KirinDave> bos: It's  avery simple game. That's why i tend to learn new languages with it
10:46:45 * BMeph starts singing: "If you can't be, in the room you love, Honey..."
10:46:51 <bos> ok. so then Room doesn't really belong in a Reader.
10:47:16 <bos> because the assumption with Reader is that you're not going to change anything, i.e. you're in the same Room for all eternity.
10:47:17 <KirinDave> Well it's the gamestae
10:47:25 <bos> which might be a fun game, but presumably not the game you want.
10:47:38 <KirinDave> With my current monad stack you dive into the macro stack then pop back out.
10:47:45 <Jafet> Mm, one room games
10:47:48 <KirinDave> I just used reader as a way to avoid passing the game stack explicitly.
10:48:01 <KirinDave> Pretty sure someone did that one room game. It's called The Room and it was nearly as bad as the movie. :)
10:48:12 <bos> so. you have a Reader for "the unchanging environment of the game", i.e. just the map.
10:48:20 <KirinDave> Okay
10:48:20 <bos> and for the bits that change, you have State.
10:48:32 <KirinDave> So the reason I didn't use StateT over Reader
10:48:42 <dolio> I feel like I'm sitting on an atomic bomb, waiting for it to go off.
10:49:00 <KirinDave> was that I was computing the new room.
10:49:07 <Jafet> (That is, z-machine games.)
10:49:08 <pmetzger> dollo: stand up?
10:49:29 <KirinDave> Jafet: This is quite a bit simpler than z-machine games tho. Thank god, some of those got crazy
10:49:30 <bos> KirinDave: i don't follow.
10:49:52 <KirinDave> bos: I guess what I was trying to do was avoid dragging IO down into my handler code.
10:49:58 <balor> It's not obvious to me what http://haskell.org/hoogle/?hoogle=unGen does, I presume it simply takes the "a" out of a "Gen a"? Why does it take a StdGen?
10:50:02 <KirinDave> bos: Maybe that was a stupid idea, since I use writer to approximate it ayways.
10:50:05 <bos> KirinDave: the purpose of State and StateT is precisely so you can compute new values to replace old ones.
10:50:13 <KirinDave> bos: Right.
10:51:08 <bos> but if this is really simple code, you don't need the monads at all.
10:51:11 <KirinDave> but since I had to leave the monadic computation over and over because I didn't want to drag IO into the handlers.
10:51:18 <KirinDave> bos: Well originally I tried
10:51:27 <KirinDave> but it ended up being more bookkeeping than was fun to write.
10:51:36 <bos> yeah, that doesn't surprise me.
10:52:18 <KirinDave> bos: So you think I should use StateT ReaderT IO?
10:52:34 <bos> KirinDave: not necessarily.
10:52:55 <bos> KirinDave: but i don't understand where IO comes in.
10:53:31 <bos> i presume you don't need to be performing IO willy nilly at any point?
10:53:54 <KirinDave> bos: Nope.
10:53:56 * hvr just realized the "latest" cabal documentation describes cabal 0.8;  shouldn't http://www.haskell.org/cabal/release/cabal-latest/doc point to the 0.10 documentation instead?
10:54:03 <bos> at least in my little lizard brain, i'm thinking "the type here is WorldMap -> Room -> Input -> Outcome"
10:55:01 <KirinDave> Right, and then Outcome -> Room
10:55:31 <KirinDave> Because some outcomes move the player and some just spit text.
10:55:46 <alexbagel> Hello, I have a function that returns a Maybe. If it's (Just x) I want to return the x, if it's Nothing I want to return a default value. Is there a more succinct way than this?: let mx = somefunc in if isJust mx then fromJust mx else myDefault
10:56:19 <KirinDave> alex: fromMaybe
10:56:26 <KirinDave> :t fromMaybe
10:56:27 <lambdabot> forall a. a -> Maybe a -> a
10:56:43 <bos> so each step of the game, in my mind, would be "collect a piece of input, construct a Reader (WorldMap,Room) environment, then run a function of type Input -> Reader (WorldMap,Room) -> Outcome"
10:56:44 <KirinDave> alexbagel: fromMaybe defaultValue computeAMaybeValue
10:56:57 <kaini> By the way, what is that strange forall a. syntax?
10:57:02 <KirinDave> bos: I am doing the reader (WorldMap,Room)
10:57:16 <bos> and i have (WorldMap,Room) glommed together because i'm not considering the possibility of one Input causing multiple Room moves
10:57:30 <bos> KirinDave: yeah, i'm just rederiving the thinking for myself
10:57:34 <KirinDave> Okay.
10:57:52 <KirinDave> Yeah you could move more than once but unless everyroom was described along the path it would be unobservable. :)
10:57:58 <alexbagel> ha, perfect! can't believe i missed it. Thanks :)
10:58:13 <KirinDave> alexbagel: I missed it too. :)
10:59:11 <bos> KirinDave: i don't understand the WriterT stuff you're doing
10:59:21 <KirinDave> bos: It's so the commands can write output.
10:59:26 <KirinDave> bos: Some outcomes just push out text
10:59:32 <KirinDave> and don't move you. See Data.hs.
10:59:40 <bos> why not model that in the Outcome type?
10:59:43 <KirinDave> I did.
11:00:10 <KirinDave> Actions and Edges
11:02:21 <bos> KirinDave: ah, i see part of why i'm confused.
11:02:31 <KirinDave> bos: ?
11:02:52 <bos> so your handleOutcome type is weird because you're forcing it to deal with the result of List.find
11:03:32 <KirinDave> Yeah, I couldn't find a better place to put the failure-to-find-a-command handler
11:03:54 <bos> in the default case of mazeLoop, no?
11:04:00 <KirinDave> Yes.
11:04:27 <KirinDave> That is awkward. )
11:04:29 <bos> if your types make you go "ick, ew, something seems gross", listen to your nose.
11:04:40 <bos> or do whatever the equivalent is for noses.
11:06:37 <KirinDave> bos: I'm not sure how to fix it.
11:09:46 <joe6> any suggestions on spawning an interactive process  from haskell? I know the chapter 20 of RWH, but just curious if any has any good experiences doing that in haskell.
11:10:37 <bos> KirinDave: something like this: http://pastebin.com/CMteLYuW
11:10:39 <Jafet> Does it want you to –ahem– interact with it?
11:11:25 <KirinDave> That's good.
11:11:47 <KirinDave> bos: You're right, that's better.
11:12:04 <bos> eh, MissingH
11:12:39 * bos dislikes MissingH rather a bit
11:14:14 <KirinDave> bos: I don't want to write strip myself.
11:15:22 <dmwit> :t reverse . dropWhile isSpace . reverse . dropWhile isSpace
11:15:22 <lambdabot> [Char] -> [Char]
11:15:55 <dmwit> > filter isSpace [minBound .. maxBound]
11:15:55 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
11:16:10 <dmwit> I wonder why his split only strips " \t\r\n".
11:16:25 <dmwit> That seems like a mistake.
11:16:56 <bos> KirinDave: i use the text package for stuff like that
11:17:14 <KirinDave> dmwit: It's aping perl's text manipulation functions
11:17:32 <dmwit> Perl's text manipulation functions leave some whitespace at beginning and end?
11:18:01 <KirinDave> dmwit: Yes. Or rather their notion of whitespace is restricted to some basic ascii stuff
11:18:10 <KirinDave> whitespace is not "unrenderable"
11:19:44 <bos> KirinDave: also, use Map.findWithDefault instead of your Map.lookup stuff
11:20:47 <KirinDave> bos: Good point as well
11:22:44 <joe6> what am i doing wrong here: http://pastebin.com/dNSMCqSH
11:22:51 <KirinDave> bos: Already looking shorter
11:22:58 <KirinDave> bos: I am gonna try using a statet
11:23:06 <KirinDave> and using execState as opposed to runState
11:23:16 <epdtry> joe6: "in" is a keyword, you can't use it as a variable name
11:23:21 <KirinDave> That way actions just provide a new state.
11:23:25 <joe6> epdtry, oh, gotcha
11:28:19 <Bustakheops> hi ! I need help to count occurence of char in a file, i paste some code here : http://hpaste.org/46472/count_occurence_strict
11:28:42 <Bustakheops> I think the problem is that my functions aren't strict
11:29:01 <Bustakheops> because it's work on small file, but not I habe stackoverflow on big file
11:29:36 <jkff> Bustakheops: + isn't strict
11:29:43 <jkff> I mean, it is, but the compiler doesn't know :)
11:29:59 <jkff> so you get the length in the form 1 + (1 + (1 + (...))) and get a SO when it's evaluated
11:30:48 <Bustakheops> ok so I have to add another parameter with the length isn't?
11:31:03 <jkff> Bustakheops: Try forcing 'y' instead of the 'list'
11:31:41 <jkff> Bustakheops: Also please try using more meaningful / conventional function and parameter names, and try using the standard functions.
11:32:08 <jkff> Bustakheops: Use of explicit recursion in Haskell instead of map/filter/fold/etc is about as bad as explicit GOTO in C instead of loops
11:33:22 <Bustakheops> jkff : yes sorry for the name of parameter, it's just for my own test. I will try again with your tips
11:35:16 <jkff> Bustakheops: Naming is extremely important regardless of whether it's test code or not - if something is hard to name, that usually means that its "real" meaning is fuzzy, and this is always a bad thing :)
11:36:55 <Bustakheops> jkff : ok, I would be careful in the future
11:40:05 <alexbagel> i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
11:40:37 <merijn> alexbagel: :D
11:40:59 <Jafet> @remember alexbagel i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
11:40:59 <lambdabot> Done.
11:41:09 <merijn> People in #haskell appear to be above average in wittiness
11:41:50 <Jafet> As long as he doesn't find it as easy to name his first 26 types.
11:43:27 <alexbagel> =) probably should have said "functions" instead of "variables" in here
11:43:33 <c_wraith> :t x
11:43:33 <lambdabot> Expr
11:46:02 <merijn> Is Vty preferred to hscurses?
11:47:37 <KirinDave> hmm
11:47:42 <c_wraith> @hackage vty
11:47:42 <lambdabot> http://hackage.haskell.org/package/vty
11:53:38 <c_wraith> anyone know, offhand, why GHC can't derive Show for Mu?
11:54:05 <kmc_> it can!
11:54:08 <kmc_> with StandaloneDeriving
11:54:19 <Tomsik_> In this case the answer is: Mu.
11:54:42 <c_wraith> StandaloneDeriving is more powerful?  that's interesting
11:54:48 <kmc_> shows up at the end of http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
11:54:56 <kmc_> c_wraith, yes, because it allows you to specify the context
11:55:06 <kmc_> deriving instance (Show (f (Mu f))) => Show (Mu f)
11:57:25 <KSkrzet> GHC's GC is stop-the-world, right? How can I optimize RTS flags it so the stops are minimal?
11:58:09 <KirinDave> I'm getting an error I don't really understand
11:58:24 <KirinDave> line is: https://github.com/KirinDave/Rag/blob/master/rag/Main.hs#L27 error is: https://gist.github.com/79e7550574189738cf7b
11:58:58 <ddarius> KSkrzet: Decreasing the maximum heap size is the only thing that would provide a hard reduction.
11:59:13 <monochrom> KSkrzet: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc controls GC, but I don't know their consequences
11:59:25 <c_wraith> KirinDave: did you want runState instead of execState?
11:59:34 <danharaj> KirinDave: When you apply execState to a writer monad value of that type, what do you get?
11:59:40 <KirinDave> c_wraith: I don't think I care about the result.
11:59:53 <KirinDave> Except of course for the writerT part
12:00:36 <c_wraith> I suspect you want runState and some manual unpacking and repacking
12:00:52 <KirinDave> Okay
12:01:03 <KSkrzet> monochrom: Thanks, though the thing I'm after is the meaning of all those flags. I'm experimenting right now, but perhaps someone have done it already
12:01:04 <merijn> KSkrzet: Major collections stop the world, yes. Minor collections are concurrent, I think
12:01:22 <KirinDave> c_wraith: So what is my return type?
12:02:59 <kmc_> merijn, i don't think that's true in GHC 7 yet
12:03:17 <kmc_> collections do happen concurrently on multiple CPUs though
12:03:23 <ddarius> KSkrzet: If you can bound the amount of live data you'll have at any time, then you want to set the maximum heap size to a little above that.  This will give you a hard guarantee for the amount of time a major collection can take.
12:03:31 <c_wraith> @unmtl WriterT [String] State GameState a
12:03:31 <lambdabot> GameState -> [String] -> (a, GameState, [String])
12:03:44 <ddarius> This trades throughput for latency.
12:04:10 <c_wraith> oh, oops
12:04:27 <c_wraith> @unmtl WriterT [String] (State GameState) a
12:04:27 <lambdabot> GameState -> (a, [String], GameState)
12:04:30 <ddarius> The other options can make a significant improvement in performance, but don't guarantee any better worst-case latency.
12:04:44 <ddarius> Other than, perhaps, the flag to enable parallel GC.
12:04:52 <KirinDave> So it really makes a 3-wide tuple?
12:04:57 <c_wraith> ...  It shouldn't
12:05:03 <c_wraith> I'm rather confused by that answer
12:05:10 <KirinDave> It should be ((a, [String]), GameState), right?
12:05:16 <c_wraith> yeah
12:05:29 <danharaj> yes, and it is
12:05:52 <KirinDave> And I _must_ runState or I lose the stuff writert collected, right?
12:06:13 <c_wraith> yes
12:06:17 <Will|> is the "hitchhiker's guide to haskell" out of date?
12:06:29 <KirinDave> c_wraith: Ty
12:06:59 <Will|> Following it, I get "`coarbitrary' is not a (visible) method of class `Arbitrary' "
12:07:15 <Will|> and all it says about coarbitrary is to "ignore it, we'll get back to it later"
12:07:47 <c_wraith> Will|: that's a change made in Quickcheck 2.  Just don't provide an implementation for coarbitrary, and you'll be fine
12:07:55 <Will|> thanks
12:07:58 <KSkrzet> ddarius: what about -A option? How does it help? I see it does in my case at least, but I'm not sure of the reasons
12:08:08 <c_wraith> Will|: QuickCheck 2 moved that function to a different class
12:10:38 <ddarius> KSkrzet: Increasing that parameter decreases the number of (major and minor) garbage collections, but makes the minor garbage collections more expensive and makes no difference in the cost of a major garbage collection.
12:11:00 <MatrixFrog> hello #haskell :)
12:11:19 <MatrixFrog> so i'm making my way through Real World Haskell, and i wonder if someone might like to look at my solution to one of the exercises...
12:11:27 <ddarius> However, if you know you allocate in a certain pattern, you could potentially set things up so that minor collections always reap everything you allocate so that you never reach a major collection.
12:11:44 <MatrixFrog> the problem is: Write a program that transposes the text in a file. 	      For instance, it should convert 	      "hello\nworld\n" to 	      "hw\neo\nlr\nll\nod\n"
12:12:06 <KSkrzet> ddarius: that sounds interesting. when is that possible?
12:13:23 <MatrixFrog> http://hpaste.org/46474/real_world_haskell__transpos
12:13:47 <MatrixFrog> it works but i feel like it could be made much more readable. naming is hard too, i don't know of a better way to name the manyTails function...
12:14:43 <ddarius> If you have a bounded amount of long-lived data, and a periodic pattern of allocating a bounded amount of short-lived data, you could set the allocation area or first two generations to be larger than twice the bound on the short-lived data and the max heap size to the bound on the long-lived data plus twice the bound of the short-lived data and you will do at most one major collection.
12:15:48 <KSkrzet> this is neat, thanks
12:15:52 * MatrixFrog looks at the comments and sees a bunch of one-liners
12:15:54 <MatrixFrog> d'oh!
12:15:55 <luite> where does the Expr data type in lambdabot come from?
12:16:02 <MatrixFrog> :i Expr
12:16:09 <MatrixFrog> :info Expr
12:16:12 <KSkrzet> do you know if anyone has written down such how-to's for GHC GC?
12:16:16 * MatrixFrog is doing it wrong probably
12:16:35 <luite> @info Expr
12:16:35 <lambdabot> Expr
12:16:42 <luite> hmm :)
12:16:46 <MatrixFrog> :-/
12:17:27 <merijn> KSkrzet: Maybe the people in #ghc can be of more help?
12:17:44 <luite> code.haskell.org seems to be down, that's where the darcs repository should be...
12:18:18 <KSkrzet> merijn: they are not exactly most active ones
12:18:47 <ddarius> Actually, you'd need a configuration that would 1) GC no more than once per cycle and 2) would require two GCs to promote something into the oldest generation.
12:18:58 <merijn> KSkrzet: I know, but at least it won't scroll offscreen there and maybe when someone gets back/has time they can answer
12:19:14 <merijn> MatrixFrog: If you have trouble with Real World Haskell, there's also a nice (more beginner) introduction to Haskell called "Learn You a Haskell" which is truly excellent
12:19:31 <MatrixFrog> i got most of the way through that, maybe a year ago
12:19:46 <MatrixFrog> i'm not having trouble per se, i came up with a solution... i just think it's ugly
12:20:21 <MatrixFrog> but yeah i really liked learning me a haskell
12:20:30 <merijn> It's not that bad, I think
12:20:33 <ddarius> If the long-lived data is small though, you can just set the maximum heap size and call it a day.
12:20:42 <KSkrzet> merijn: I think they must be very busy, since I was ignored a few times before. anyways a written how-to is always good.
12:20:55 <merijn> MatrixFrog: Except transpose, that could be nicer :p
12:21:28 <MatrixFrog> but that's the most important one! but yeah there were some solutions using zipWith or something...
12:21:43 <MatrixFrog> the problem is there's an ambiguity in the problem -- what if not all the lines are the same length
12:22:00 <MatrixFrog> my solution is to kind of pad them out with spaces
12:22:18 <merijn> MatrixFrog: One useful function to know is $
12:22:20 <MatrixFrog> although actually, i could probably do that more explicitly
12:22:28 <merijn> Lets you remove some spaces in transpose
12:22:35 <merijn> eh
12:22:39 <merijn> Parentheses, I mean
12:22:39 <MatrixFrog> oh yeah i have seen $
12:23:19 <merijn> $ is really simple, the trick is to realize the infix operators always have lower priority then functions
12:23:24 <merijn> @src ($)
12:23:24 <lambdabot> f $ x = f x
12:23:38 <Tomsik_> not only, $ has the lowest priority of all
12:23:49 <MatrixFrog> i always just think that "f $ a whole bunch of stuff over here" means "f (a whole bunch of stuff over here)"
12:24:03 <MatrixFrog> like, think of the $ as a "(" where its matching ")" is ALLLLL the way over on the right
12:24:03 <merijn> Yeah
12:24:10 <Tomsik_> It's more like (f) (a whole bunch) I think
12:24:22 <merijn> So you could do something like "unlines $ map (map safeHead) manyTails $ lines s)"
12:24:27 <merijn> eh
12:24:28 <ion> More generally, (a whole bunch of stuff) (another bunch of stuff) → a whole bunch of stuff $ another bunch of stuff
12:24:33 <merijn> Missed a parens there
12:24:39 <MatrixFrog> mmmk yeah that makes sense
12:24:52 <merijn> This is not Lisp, we hate parentheses ;)
12:24:59 <MatrixFrog> indeed
12:25:24 <lispy> has anyone else seen this on osx? Unixutils-1.36 failed during the configure step.
12:25:38 <adamvh> I apologize in advance for the major n00b question I'm about to drop here
12:25:39 <merijn> Also, I would maybe move part of transpose into a where clause, so its less cluttered
12:25:59 <MatrixFrog> ok cool
12:26:00 <MatrixFrog> thanks!
12:26:03 <adamvh> So, I have a list, and I'd like to do some IO based on each member of the list, and not return anything
12:26:17 <adamvh> so, basically
12:26:19 * hackagebot yesod-examples 0.8.0.1 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.8.0.1 (MichaelSnoyman)
12:26:22 <adamvh> [a] -> IO ()
12:26:26 <merijn> MatrixFrog: Something like: unlines . f . lines; where f = map (map safeHead) manyTail
12:26:32 <KSkrzet> :t mapM_
12:26:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
12:26:43 <MatrixFrog> oh wow that is a lot nicer :)
12:26:47 <adamvh> KSkrzet - I tried mapM_
12:26:55 <adamvh> but ghci seems to just not evaluate it
12:26:56 <MatrixFrog> and it's even pointfree
12:26:58 <MatrixFrog> how fancy
12:27:11 <merijn> MatrixFrog: If it looks ugly, break it into smaller pieces until it doesn't :)
12:27:28 <KSkrzet> > mapM_ print [1..10]
12:27:29 <lambdabot>   <IO ()>
12:27:31 <KSkrzet> ahm
12:27:49 <adamvh> So how do I actually force the side effect?
12:28:00 <KSkrzet> adamvh: just type "mapM_ print [1..10]" in ghci... it works, I assure you
12:28:18 <KSkrzet> don't let-bind it
12:28:21 <KSkrzet> just write it
12:28:46 <adamvh> Yes, it does work...
12:28:57 <adamvh> hmm, but inside my do block it seems not to
12:29:02 * Volatile misses the lists:mapFoldr function from Erlang. Is it in some Haskell lib somewhere?
12:29:08 <KSkrzet> you should run that block
12:29:15 <merijn> Volatile: What's it do?
12:29:24 <Volatile> merijn: it does both a map and a foldr
12:29:38 <c_wraith> :t accumFoldL
12:29:38 <lambdabot> Not in scope: `accumFoldL'
12:29:39 <merijn> So, first map then foldr?
12:29:45 <MatrixFrog> what would its type be if it existed?
12:29:46 <adamvh> KSKrzet: ah, I had written return $ mapM_ ...
12:29:53 <MatrixFrog> try typing that type into hoogle
12:30:20 <adamvh> KSKrzet - was ghc not forcing the argument to return in that situation?
12:30:23 <c_wraith> :t foldAccumL
12:30:23 <lambdabot> Not in scope: `foldAccumL'
12:31:06 <jnhnum1> hi: I'm trying to grok how to get good performance out of the Data.Vector module.  I have a haskell version here: http://hpaste.org/46475/slow_vector_sum and a c version here: http://pastebin.com/Z0cXpxMK ... why is haskell 20 times slower?
12:31:16 <Volatile> merijn: it does both. Say I would like to multiply all numbers in a list by two and sum them together at the same time, ending up with both a sum and a list of doubled numbers
12:31:36 <lispy> oh, I think I have to install openssl
12:31:41 <adamvh> KSkrzet - anyways, thanks, I got it working even if I don't quite understand why
12:31:43 <lispy> that seems to ship crypt
12:32:09 <djahandarie> jnhnum1, the read function is very slow
12:32:23 <djahandarie> Also, try switching to Unboxed vectors
12:32:36 <merijn> > sum &&& foldr (*2) $ [1..10]]
12:32:37 <lambdabot>   <no location info>: parse error on input `]'
12:32:38 <KSkrzet> adamvh: be sure to understand monads. instead of `return $ mapM_ print [1..10]` you actually wanted to write `return =<< mapM_ print [1..10]`
12:32:47 <MatrixFrog> mapFoldr (*2) (+) [1,2,3,4] = ([2,4,6,8], 10)
12:32:48 <merijn> > sum &&& (foldr (*2)) $ [1..10]]
12:32:49 <lambdabot>   <no location info>: parse error on input `]'
12:32:52 <MatrixFrog> like that?
12:32:54 <merijn> Doh
12:33:00 <merijn> > sum &&& foldr (*2) $ [1..10]
12:33:01 <lambdabot>   No instance for (GHC.Num.Num [a])
12:33:01 <lambdabot>    arising from a use of `e_12110' at <in...
12:33:09 <MatrixFrog> @info &&&
12:33:09 <lambdabot> (&&&)
12:33:14 <MatrixFrog> :t &&&
12:33:15 <lambdabot> parse error on input `&&&'
12:33:17 <merijn> Apparently, I'm not awesome enough
12:33:21 <jnhnum1> djhandarie: you mean the read function like parsing the command line arguments? because that's only being done once
12:33:22 <MatrixFrog> what is &&&?
12:33:25 <Volatile> good thy, though
12:33:26 <adamvh> :t return . mapM_
12:33:27 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) b. (Monad m, Monad m1) => (a -> m1 b) -> m ([a] -> m1 ())
12:33:29 <merijn> :t (&&&)
12:33:30 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:33:31 <jnhnum1> also what /how do I use unboxed vectors
12:33:31 <KSkrzet> adamvh: and furthermore: `return =<< action` is equal to just `action`
12:33:35 <ddarius> merijn: You want to map (2*) not foldr it.
12:33:39 <MatrixFrog> oh right i forgot the ()s
12:33:51 <merijn> oh, right
12:33:59 <merijn> I'm an idiot, sum is the fold >.>
12:34:08 <merijn> > sum &&& map (*2) $ [1..10]
12:34:09 <lambdabot>   (55,[2,4,6,8,10,12,14,16,18,20])
12:34:14 <merijn> \o/
12:34:16 <merijn> Success!
12:34:34 <ddarius> (map is also a foldr and sum usually [and in the Report isn't] a foldr.)
12:34:35 <merijn> > foldr 0 (+) &&& map (*2) $ [1..10]
12:34:35 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
12:34:35 <lambdabot>    arising from a use...
12:34:57 <merijn> and I mixed the order of foldr, oh well
12:35:01 <merijn> You get the idea
12:35:01 <adamvh> KSkrzet: in retrospect it should have been obvious to me from the type signature of mapM_ that I just wanted mapM_ by itself
12:35:17 <Volatile> hm
12:35:18 <djahandarie> jnhnum1, try   main = print . V.sum $ V.enumFromTo 1 (1000000 :: Int)    to get rid of all the junk
12:35:21 <KSkrzet> adamvh: I'm glad you got it right :-)
12:35:24 <djahandarie> And do the same in C
12:35:34 <adamvh> KSkrzet: since IO IO () is a pretty ridiculous return type
12:35:54 <merijn> Volatile: Basically &&& takes two functions which take the same input type and returns a tuple of both applied to the input value
12:35:56 <Volatile> I am thinking in terms of how to make Haskell not do two passes over my data to get the result(s) out. Maybe I shouldn't think like that?
12:36:00 <adamvh> which would be the type of applying return to the return value of mapM_
12:36:46 <KSkrzet> :t join
12:36:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:36:47 <ion> > let a :: Maybe (Maybe Integer); a = return (return 42) in join a
12:36:48 <lambdabot>   Just 42
12:36:50 <merijn> Volatile: You probably shouldn't, until you run into a proven (as in measured!) bottleneck
12:36:50 <djahandarie> jnhnum1, oh, enumFromN in this case, sorry
12:36:59 <ddarius> Volatile: There in a transformation called the 'tupling transform' to systematically derive such functions, but, surprisingly perhaps, it often provides no performance benefit.
12:37:03 <KSkrzet> :t join (map print [1..10])
12:37:03 <lambdabot>     Couldn't match expected type `IO (IO ())'
12:37:03 <lambdabot>            against inferred type `[IO ()]'
12:37:03 <lambdabot>     In the first argument of `join', namely `(map print [1 .. 10])'
12:37:12 <KSkrzet> ahgm
12:37:13 <KSkrzet> ahm
12:37:27 <aristid> :t sequence (map print [1..10])
12:37:28 <lambdabot> IO [()]
12:37:43 <aristid> :t join (map show [1..10])
12:37:44 <lambdabot> [Char]
12:37:47 <KSkrzet> :t foldM
12:37:47 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:37:48 <merijn> KSkrzet: map print produces an [IO ()] list, not IO (IO (IO ())))
12:38:10 <KSkrzet> merijn: sure
12:38:16 <KSkrzet> :i sequence_
12:38:18 <ddarius> There is a problem with (foldr c n xs, map f xs) insofar as it will keep xs alive potentially much longer than the combined approach.
12:38:55 <ddarius> Of course, if the result of f or the foldr takes up more memory, it could be beneficial to not process them in lock-step.
12:38:57 <merijn> ddarius: Because forcing one might not force the other?
12:39:02 <djahandarie> jnhnum1, -fllvm tends to be faster with these tight loop type programs, so you should try that as well
12:39:16 <ddarius> merijn: Forcing one definitely won't force the other.
12:39:26 <Volatile> hm
12:39:56 <ddarius> As a side note, for things that can be fused, it is often the case that such combinations get fused into one parallel traversal anyway.
12:40:11 <adamvh> :t return . mapM_
12:40:12 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) b. (Monad m, Monad m1) => (a -> m1 b) -> m ([a] -> m1 ())
12:41:32 <ion> :t let m >>= f = join (f <$> m) in return 42 >>= print
12:41:33 <lambdabot> IO ()
12:41:45 <jnhnum1> djahandarie: what were you saying about unboxed vectors before?
12:41:47 <ion> > let m >>= f = join (f <$> m) in return 42 >>= Just
12:41:47 <lambdabot>   Just 42
12:42:05 <ddarius> Note that you could implement a "mapFoldr" function in terms of tupling map and foldr and a function that forces the elements in lock-step, so other than some dubious potential constant factor benefits, it's still not necessary to have a manually fused "mapFoldr" function.
12:44:00 <djahandarie> jnhnum1, I don't think it should affect much in this case but you can try using Data.Vector.Unboxed instead
12:44:33 <jnhnum1> okay...but I still don't see anything that seems like it could be responsible for a factor of 20 speed difference?
12:44:45 <jnhnum1> how do you profile haskell
12:44:48 <balor> Why is the last statement of this "do" block not an expression?   http://hpaste.org/paste/46476/return_nota_an_expression
12:44:52 <adamvh> @pl (\x y -> g (f x y))
12:44:52 <lambdabot> (g .) . f
12:44:58 <djahandarie> Have you tried my suggestions?
12:45:03 <lispy> hmm...nope installing openssl didn't provide libcrypt
12:45:07 <jnhnum1> yeah they didn't make much of a difference
12:45:21 * hackagebot criterion 0.5.0.9 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.0.9 (BryanOSullivan)
12:45:41 <djahandarie> You can make it dump the ASM and try to optimize it further by providing the proper LLVM flags
12:45:52 <ion> balor: Since you use {}, also add ; (that would be my guess).
12:45:57 <adamvh> :t (g .) . f
12:45:58 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, SimpleReflect.FromExpr (f1 (f a)), Functor f1) => f1 (f b)
12:46:30 <djahandarie> jnhnum1, http://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/
12:46:50 * lispy is confused about why he needs libcrypt on osx to build snap.  Shouldn't it just be here?
12:47:07 <balor> ion, thanks
12:47:21 <sshc> @src ContT (>>=)
12:47:21 <lambdabot> m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
12:47:31 <sshc> Why can't that be "m >>= k  = runContT m (\a -> ContT $ \c -> runContT (k a) c)"?
12:47:40 <sshc> :t \m k -> runContT m (\a -> ContT $ \c -> runContT (k a) c)
12:47:41 <lambdabot> forall a a1 (m :: * -> *) r. ContT a1 (ContT r m) a -> (a -> ContT r m a1) -> ContT r m a1
12:47:48 <ion> balor: The hint was in the error message. It obviously parsed the entire thing as a single expression.
12:49:01 <djahandarie> jnhnum1, I need to run. http://book.realworldhaskell.org/read/profiling-and-optimization.html is a good page for the basics of Haskell profiling, but what you're doing is a microbenchmark which will likely require you to get your hands pretty dirty with ASM.
12:49:16 <jnhnum1> djahandarie: ok thanks for your help
12:52:16 <merijn> lispy: Maybe its in a non-standard include directory?
13:00:55 <Volatile> So, my problem, in more detail: I have a [a] and a [b]. For each b in [b], I run a function f over [a] and b, getting a [a'] and a b'. For each b, I use the [a'] from the previous f [a] b. I collect the b':s in a list. In the end, I would like to have a ([a'],[b']), where the [a'] is from the last run of f.
13:01:54 <Volatile> This can easily be done with mapFoldr, but will be a bit tricky without it, I think.
13:02:22 <alex_r> is there a a you can easily detect whether a binary string is a multiple of 5
13:02:32 <lispy> merijn: I tihnk I fixed the problem by installing gnutls via homebrew
13:02:33 <balor> If anyone is interested in reading about one issue this n00b is having with QuickCheck, see http://blogs.linux.ie/balor/2011/05/07/an-issue-with-quickcheck-2/
13:05:05 <alex_r> or how to generate only binary strings that are multiples of 5
13:05:20 <merijn> huh
13:05:20 <ddarius> Volatile: Since you can write mapFoldr c n f xs = (map f xs, foldr c n xs), I don't see how it becomes much more complicated without mapFoldr.
13:05:29 <merijn> alex_r: What's that supposed to mean?
13:05:41 <sshc> Mm, the result is "m b", not "ContT r m b"
13:05:42 <monochrom> I think no, you really have to slurp the binary string into an Integer and then divide by 5
13:06:25 <alex_r> merijn: ,i'm trying to create a generator on a turing machine that acdepts strings that are binary multiples of 5
13:06:26 <alex_r> somehow
13:06:37 <alex_r> i know alternating sums for odd binary strings but that doesnt work here
13:06:49 <monochrom> oh, in that sense. yes there is a better way
13:06:49 <Cale> balor: Yes, it's absolutely possible to do that. When you write the instance of Arbitrary for Foo, you can say exactly how the elements are randomly generated.
13:07:11 <alex_r> but on a turing machine though
13:08:12 <alex_r> im trying to think of a better way to do it than list out five integers in binary and then just print the 5  binary digit
13:08:20 <alex_r> 5th*
13:11:47 <Volatile> ddarius: Hm. To calculate the next [a] I need from f r [a], I need the output from the previous one (foldrish), and the current r (mapish). To calculate the next r I need from f r [a], I need the previous [a] (foldrish) and the current r (mapish). I don't see how this can be done in parallel, as you seem to suggest. I need both in each step..
13:11:47 <Cale> balor: So you'd write  arbitrary = do x <- arbitrary; y <- randSubset x; return (Foo x y)
13:12:09 <Cale> balor: In the instance of Arbitrary for Foo
13:12:48 <balor> Cale: thanks.
13:13:22 <Volatile> heh, maybe this isn't even how the Erlang function is defined. (My head is kinda fuzzy right now.)
13:13:22 <MatrixFrog> how can i look at the source of foldl and foldl'
13:13:33 <merijn> @src foldl
13:13:33 <lambdabot> foldl f z []     = z
13:13:33 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:13:40 <MatrixFrog> yay
13:13:48 <MatrixFrog> @src foldl'
13:13:48 <lambdabot> foldl' f a []     = a
13:13:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:13:54 <monochrom> alex_r: here is how I would do it in haskell, but you can convert the trans function to your state transition function for your turing machine, there are really only 10 possibilities: http://hpaste.org/46480/div_by_5
13:13:56 <merijn> You can also privmsg lambdabot :)
13:13:59 <MatrixFrog> oh ok so it has to do with seq
13:14:19 <merijn> MatrixFrog: Basically, foldl is lazy, foldl' is not
13:15:52 <Cale> Volatile: You're aware that map itself can be written using foldr? I'm not 100% sure what it is that you're trying to do, it would be nice to see a single higher order function which does it which we could rewrite in terms of foldr and map
13:17:42 <Volatile> Cale: I think that mapfoldr can be as well. I'm just not awake enough (due to insomnia and sickness) to grasp how atm.
13:18:03 <Cale> What's the type of mapfoldr?
13:18:07 <Volatile> hmm
13:18:14 <Cale> (I think I missed part of this conversation)
13:18:29 <Volatile> Well, I was kinda fuzzy about it previously, I think.
13:18:46 <Volatile> I'll do a rough translation from the erlang manpage:
13:19:18 <Cale> foo :: ([a] -> b -> ([a],b)) -> [a] -> [b] -> ([a],[b]) ?
13:20:43 <Volatile> hm, not quite
13:21:16 <Cale> Well, that's what I got from your description...
13:22:15 <Volatile> oh, hm
13:22:18 <Volatile> well
13:22:30 <Volatile> that is what I want in the end. :)
13:22:45 <Volatile> not the description of mapfoldr, but what I want to build with it.
13:22:57 <Volatile> which is kinda what I need in the end. :)
13:24:02 <alex_r> monochrom: , i'm not sure how to translate that into a way to generate all the strings in my language. I want to generate the language where a TM M accepts some string that begins with a 1 and is a binary multiple of 5.
13:24:32 <ddarius> Erlang's mapfoldr has type ((a,c) -> (b,c)) -> c -> [a] -> ([b], c)
13:24:35 <alex_r> i was thinking of just listing out 1,2,3,4,5,6,7,8,9 etc in binary and seperate them by a # mark
13:24:39 <alex_r> and only accept mod 5
13:25:13 <Volatile> ddarius: thanks.:)
13:26:33 <jnhnum1> does anybody know what's slowing down this code? http://hpaste.org/46475/slow_vector_sum
13:26:43 <jnhnum1> it's about 20 times slower than a c equivalent, which is way too much
13:27:03 <jnhnum1> I'm trying it with arguments on the order of 1 billion
13:27:54 <Cale> Volatile: http://hpaste.org/46481/is_this_it  Is this the function you're after?
13:27:56 <aristid> jnhnum1: you asked the same yesterday, no?
13:28:05 <jnhnum1> yeah but it didn't work for 64 bit integers
13:28:11 <alex_r> monochrom: How would that sound: List the integers in binary on the tape seperated by a # mark, and print every 5th integer to the tape
13:28:12 <jnhnum1> so I played around with a little more
13:28:16 <tristes_tigres> Hi
13:28:16 <jnhnum1> and it works but it's slow as hell now
13:28:32 <aristid> jnhnum1: is this some kind of assignment?
13:28:59 <ddarius> Which is to say: mapfoldr f z as = foldr (\a ~(bs, c) -> let (b, c') = f a c in (b:bs, c')) z as
13:29:10 <jnhnum1> no ... but I know it's kind of weird to focus so much on such a trivial computation
13:29:17 <Volatile> Cale: heh. Yes, yes it is. :) Thanks.
13:29:35 <jnhnum1> I was curious so I read more about stream fusion last night and was playing around more today
13:29:38 * Volatile thinks that perhaps he should be going to bed instead of coding.
13:29:52 <tristes_tigres> Can finger trees be generalized to deal with graphs?
13:30:08 <jnhnum1> aristid: sorry for not putting aristid at the front of those other messages
13:30:08 <Cale> Volatile: Well, there's possibly a nicer way to write it
13:30:20 <Cale> Volatile: I'm just trying to understand what it is that you're after first
13:31:03 <Volatile> Cale: well, 4 lines of clear code seems like a pretty nice way to write it to me...
13:31:16 <Nibble> not if it can be done in 1
13:31:21 <aristid> jnhnum1: hmm. if i was a haskell beginner, i wouldn't want to try to understand stream fusion perfectly on the first day ;)
13:31:21 <Cale> Direct recursion is admitting defeat
13:31:25 <Volatile> Cale: But yes, that's pretty much it
13:31:27 <ddarius> I already showed how it could be done in one.
13:31:38 <Volatile> Cale: haha, indeed it is.
13:31:48 <Volatile> Nibble: :)
13:32:02 <ddarius> Except that the use of z, I guess, should be (z, [])
13:32:35 <ddarius> :t let mapfoldr f z as = foldr (\a ~(bs, c) -> let (b, c') = f a c in (b:bs, c')) (z, []) in mapfoldr
13:32:36 <lambdabot> forall a a1 t t1. (a -> [a1] -> (t, [a1])) -> [t] -> t1 -> [a] -> ([t], [a1])
13:33:06 <Nibble> ddarius: that hurts  my eyes
13:33:20 <ddarius> :t let mapfoldr f z as = foldr (\a ~(bs, c) -> let (b, c') = f a c in (b:bs, c')) ([], z) in mapfoldr
13:33:21 <lambdabot> forall a t t1 t2. (a -> t -> (t1, t)) -> t -> t2 -> [a] -> ([t1], t)
13:34:03 <ddarius> :t let mapfoldr f z = foldr (\a ~(bs, c) -> let (b, c') = f a c in (b:bs, c')) ([], z) in mapfoldr
13:34:03 <Saizan> ?type mapAccumR -- ?
13:34:03 <lambdabot> forall a t t1. (a -> t -> (t1, t)) -> t -> [a] -> ([t1], t)
13:34:04 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:34:30 <jnhnum1> aristid: well is it at least possible to profile this code? I get Could not find module `Data.Vector':       Perhaps you haven't installed the profiling libraries for package `vector-0.7.0.1'? when I try to compile with the -prof flag
13:34:56 <aristid> jnhnum1: i don't know, actually.
13:35:23 <Cale> er, oops
13:35:25 <Cale> lol
13:35:32 <ddarius> :t (runState .) . mapM . State
13:35:33 <lambdabot> Not in scope: data constructor `State'
13:35:37 <ddarius> :t (runState .) . mapM . state
13:35:38 <lambdabot>     Couldn't match expected type `a -> StateT s Identity b'
13:35:38 <lambdabot>            against inferred type `StateT s1 Identity a1'
13:35:38 <lambdabot>     Probable cause: `state' is applied to too many arguments
13:35:38 <Cale> It can't be what I wrote, that doesn't even typecheck :P
13:36:09 <ddarius> :t (runState .) . mapM . (state .)
13:36:10 <lambdabot> forall s a b. (a -> s -> (b, s)) -> [a] -> s -> ([b], s)
13:37:01 <ddarius> :t flip . (runState .) . mapM . flip . (state .)
13:37:02 <lambdabot>     Couldn't match expected type `a -> b'
13:37:02 <lambdabot>            against inferred type `State s a1'
13:37:02 <lambdabot>     In the first argument of `(.)', namely `state'
13:37:32 <ddarius> :t flip . (runState .) . mapM . ((state . flip) .)
13:37:32 <lambdabot> forall a a1 b. (a1 -> (b, a -> a)) -> a -> [a1] -> ([b], a)
13:37:39 <ddarius> Curses.
13:37:56 <Saizan> you need the reverse state monad for mapAccumR anyway
13:38:19 <Cale> http://hpaste.org/paste/46481/fix#p46482
13:38:24 <ddarius> I always forget which one of mapAccumR/L mapM for State is.  Either way they are both mapM.
13:38:30 <Cale> ^^ I think this fits your description
13:38:31 <aristid> Saizan: reverse state monad?
13:38:57 <tristes_tigres> If there's a set of objects and a set of properties, one may be interested in all properties for a set of elements, or all elements posessing a set of properties. Perhaps a finger tree can be adapted to such a task?
13:39:17 <Saizan> aristid: the one that propagates state changes in the reverse order
13:39:49 * Volatile already uses the reverse state monad in his project. Not a problem there. ;þ
13:40:28 <Volatile> Cale: nice. I'll try it out.
13:40:41 <Cale> Volatile: Well, there's got to be a nicer way to do that
13:40:55 <Cale> But if that function is what you're really after, then we can figure it out :)
13:41:23 <Cale> (It's just easier to start with something like that than an English description which is a bit hard to follow ;)
13:41:29 <ddarius> Cale: That's exactly what my foldr does (as you can systematically derive from that code) modulo swapping the output tuple order.
13:41:39 <Cale> ddarius: cool
13:42:10 <Cale> Yeah, it's easy to see how to at least turn the pattern matching on the second list into a foldr
13:42:20 <KirinDave> In cabal's config file, what's the format for list arguments like extra-include-dirs?
13:42:26 <KirinDave> Is it just a haskell list?
13:42:49 <Cale> Just a comma separated list, iirc.
13:42:54 <KirinDave> ty
13:50:09 <adamvh> Is anyone around who can give me a bit of help with a Parsec question?
13:51:04 <ion> No need to ask to ask, a.k.a. join (Question (Question "parsec"))
13:51:24 <adamvh> Namely: how would I go about using "natural" from Text.Parsec.Token to grab occurences of integer?
13:51:39 <adamvh> I'm getting a type error that I don't understand
13:52:08 <adamvh> Are the things defined in Text.Parsec.Token not parsers than I can use in the same place I'd use any other parser?
13:52:32 <Saizan> iirc, natural is an accessor for a record type
13:52:54 <ddarius> :t Text.Parsec.natural
13:52:55 <lambdabot> Couldn't find qualified module.
13:53:06 <adamvh> hmmm.  Is there no convenience function in parsec for "parse a natural numer"?
13:53:26 <ion> Alas, it doesn’t seem to be easy to use the parsers in Token directly (without going through something like makeTokenParser haskellDef). I usually just define my own: natural = read <$> many1 digit
13:53:35 <ion> natural :: Parser Integer
13:53:38 <ddarius> adamvh: What do you think natural does instead?
13:54:37 <adamvh> ion: Thanks, I'm sure that'll work.  Didn't want to reinvent the wheel is all
13:54:53 <adamvh> ddarius: it appears to be internal to parsec's lexeme support
13:55:41 <adamvh> :t <$>
13:55:42 <lambdabot> parse error on input `<$>'
13:55:48 <ion> :t (<$>)
13:55:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:55:51 <ion> It’s just fmap.
13:55:55 <adamvh> :t (<$>)
13:55:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:56:03 <adamvh> ah
13:56:06 <adamvh> thanks
13:57:21 <adamvh> @src <$>
13:57:21 <lambdabot> f <$> a = fmap f a
13:57:39 <adamvh> hmm how do I ask lambdabot what module something lives in?
13:57:50 <ion> @hoogle (<$>)
13:57:50 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
13:58:12 <ddarius> adamvh: If it were internal, it would not be exported, nor is that the question I asked.
13:59:13 <adamvh> ddarius: I'm sorry, I don't understand.  I'm not sure what the "natural" from Text.Parsec.Token is.
13:59:44 <adamvh> ddarius: except that it appears not to be a parser that I can use as part of a parsec parser.
14:00:58 <shachaf> @google Text.Parsec.Token
14:00:58 <lambdabot> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Token.html
14:00:58 <lambdabot> Title: Text.Parsec.Token
14:02:08 <tristes_tigres> Is there an efficient functional datatype for trees with branches that can join ? Meaning a node can have more than one parent
14:02:40 <adamvh> tristes_tigres: I believe that is a DAG, not a tree
14:02:57 <adamvh> directed acyclic graph
14:03:26 <tristes_tigres> adamvh: I guess so
14:04:17 <scree> tristes_tigres: adjacency lists and a lookup array from integer id to node ?
14:04:21 <tristes_tigres> what I am looking for is a way to generalize a finger tree to DAGs
14:05:01 <scree> tristes_tigres: i.e. data Node = Node { children :: [Int], ... }; data Graph = { lookupArr :: Array Int Node, ... }
14:05:31 <scree> tristes_tigres: obviously throw some type variables around there if you're looking to store data at your nodes
14:08:03 <tristes_tigres> scree: what about effcient access to nodes of a tree near a distinguished location?
14:10:30 <FUZxxl> Is Don Steward here?
14:10:34 <scree> tristes_tigres: so you can access children efficiently enough in that representation.  if you want parents as well you should store both in- and out-adjacency lists
14:10:45 <scree> tristes_tigres: or I've misunderstood your question
14:11:36 <tristes_tigres> scree: I also want an efficient sorting of children
14:11:45 <byorgey> FUZxxl: do you mean Don Stewart?  He goes by the nick dons
14:11:53 <FUZxxl> Okay.
14:12:15 <scree> tristes_tigres: how do you mean?  you can store them sorted if you like
14:12:19 <FUZxxl> Does anybody knows, how to get the source code for hbc?
14:13:19 <scree> tristes_tigres: also bear in mind this is a static data structure.  If you want a mutable one, you'll have to do something more cunning
14:13:32 <scree> tristes_tigres: one option being to replace "Array" with "IntMap"
14:13:50 <scree> tristes_tigres: more cunning than that I can't help you very much ATM
14:17:46 <tristes_tigres> scree: there's a set of objects with weights and a set of properties. Given a set of properties, I want to retrieve objects having those properties, sorted by the weight of an obect
14:25:15 <lispy> preflex: zdec ZLzmzgZR
14:25:16 <preflex>  (->)
14:25:35 <ion> What does zdec do?
14:25:49 <lispy> ion: decodes from GHC Core naming scheme
14:25:56 <ion> ah
14:25:57 <lispy> ion: so if you're reading core files it's handy
14:25:58 <ion> Thanks
14:52:14 <adamvh> @pl (\(a, b, c) -> (a, [(b,c)])
14:52:14 <lambdabot> (line 1, column 8):
14:52:14 <lambdabot> unexpected ","
14:52:14 <lambdabot> expecting letter or digit, operator or ")"
14:52:14 <lambdabot> ambiguous use of a non associative operator
14:52:29 <adamvh> @pl (\(a, b, c) -> (a, [(b,c)]))
14:52:29 <lambdabot> (line 1, column 8):
14:52:29 <lambdabot> unexpected ","
14:52:29 <lambdabot> expecting letter or digit, operator or ")"
14:52:29 <lambdabot> ambiguous use of a non associative operator
14:53:04 <adamvh> @pl (\x@(a, b, c) -> (a, [(b,c)]))
14:53:04 <lambdabot> (line 1, column 4):
14:53:04 <lambdabot> unexpected "@"
14:53:04 <lambdabot> expecting letter or digit, operator, pattern or "->"
14:53:18 <pastorn> adamvh: consider opening a query with lambdabot
14:53:25 <pastorn> /query lambdabot
14:53:46 <pastorn> to minimize spam
14:53:56 <adamvh> yeah, sorry about that - I'll do that from now on
14:54:08 <pastorn> adamvh: also, you can't do points-free for a triple, only for pairs
14:54:11 <adamvh> also - is it not possible to pattern match on a tuple in a lambda expression?
14:54:26 <Saizan> \ (a,b) -> ..
14:54:38 <pastorn> you have fst/snd, you don't have fst3/snd3/thrd3
14:54:48 <adamvh> ah
14:54:48 <Saizan> > (\ (a,b) -> a) (1,2)
14:54:49 <lambdabot>   1
14:55:00 <Saizan> oh, in @pl
14:55:02 <Saizan> sorry
14:55:16 <pastorn> @pl (\a b c -> (a, [(b,c)]))
14:55:17 <lambdabot> (. flip (flip . ((:) .) . (,)) []) . (.) . (,)
14:55:30 <pastorn> @pl (\((a,b),c) -> (a, [(b,c)]))
14:55:30 <lambdabot> uncurry (uncurry ((. flip (flip . ((:) .) . (,)) []) . (.) . (,)))
14:55:43 <pastorn> @pl (\(a,(b,c)) -> (a, [(b,c)]))
14:55:44 <lambdabot> uncurry ((`ap` snd) . (. fst) . (. flip (flip . ((:) .) . (,)) []) . (.) . (,))
14:55:47 <Saizan> ?ty uncurry3
14:55:48 <lambdabot> Not in scope: `uncurry3'
14:58:08 <adamvh> :t foldl
14:58:08 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:04:39 <osaunders> Can anyone make any suggestions for shortening «chrAsToken» in http://hpaste.org/46483/this_seems_long
15:06:10 <hpc> @src guard
15:06:10 <lambdabot> guard True  =  return ()
15:06:10 <lambdabot> guard False =  mzero
15:06:34 <hpc> returnIf p x = guard p >> return x
15:07:02 <osaunders> Interesting
15:08:04 <osaunders> I was kind of thinking there might be a fundamentally better way
15:08:22 <hpc> ah, i haven't thought about it that hard yet
15:08:52 <hpc> :t fromMaybe
15:08:53 <lambdabot> forall a. a -> Maybe a -> a
15:10:22 <hpc> i think you could rewrite tokenAsChar as [(Token, Char)]
15:10:28 <hpc> :t find
15:10:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:10:34 <hpc> :t lookup
15:10:34 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:10:39 <hpc> and use lookup, perhaps
15:11:00 <osaunders> Hm
15:11:16 <osaunders> OK, well just as long as I’m not being stupid
15:11:16 <aristid> :t break
15:11:17 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:11:28 <osaunders> This just seemed like such as basic thing I couldn’t believe how much code it was
15:11:39 <hpc> er, you would want [(Char, Token)]
15:11:53 <hpc> then fromMaybe (Chr c) (lookup c charMap)
15:12:08 <osaunders> Yeah OK
15:12:18 <osaunders> lookup FTW
15:12:24 <aristid> :t break
15:12:24 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:12:34 <aristid> if you also want the context of a find :)
15:13:00 <hpc> > break (==5) [1..10]
15:13:01 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
15:13:35 <balor> How do you say "apply f to x n times" in such a way that I can take n as a parameter
15:13:44 <hpc> but yeah, the solution to long things is usually "write smaller functions that you probably won't need, then see if something neat pops out"
15:14:18 <hpc> @hoogle Int -> a -> [a]
15:14:18 <lambdabot> Prelude replicate :: Int -> a -> [a]
15:14:18 <lambdabot> Data.List replicate :: Int -> a -> [a]
15:14:18 <lambdabot> Prelude drop :: Int -> [a] -> [a]
15:14:44 <hpc> :t foldr (.) id
15:14:45 <lambdabot> forall b. [b -> b] -> b -> b
15:15:17 <hpc> balor: \f n x -> foldr (.) id (replicate n f) x
15:15:21 <hpc> i think
15:15:42 <osaunders> balor: zipWith f (replicate n x) [0..]
15:15:42 <hpc> :t \f n x -> foldr (.) id (replicate n f) x
15:15:43 <lambdabot> forall b. (b -> b) -> Int -> b -> b
15:16:04 <balor> hpc, osaunders: thanks
15:16:05 <hpc> > let apply = \f n x -> foldr (.) id (replicate n f) x in apply succ 5 10
15:16:06 <lambdabot>   15
15:16:17 <osaunders> :t foldr
15:16:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:16:23 <lispy> preflex: zdec NTCoZCFoozq
15:16:23 <preflex>  NTCo:Foo'
15:16:59 <mauke> balor: iterate f x !! n
15:17:14 <hpc> mauke: that's too easy :D
15:17:37 <osaunders> This channel blows my mind
15:17:53 <Peaker> osaunders, and then you become one of them
15:17:55 <hpc> > iterate (*2) [1..]
15:17:56 <lambdabot>   No instance for (GHC.Num.Num [t])
15:17:56 <lambdabot>    arising from a use of `e_121' at <inte...
15:18:02 <hpc> :t iterate
15:18:03 <lambdabot> forall a. (a -> a) -> a -> [a]
15:18:05 <Peaker> > iterate (*2) 1
15:18:06 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
15:18:11 <hpc> ah
15:18:12 <balor> mauke, clean.  awesome.
15:18:13 <dataangel> I get the syntax error "parse error on input ']'". What am I doing wrong?: runProcessWithInput "/home/prophet/etc/bin/ido-prompt" ["--question", "Desktop?", "--choices", "foo", "bar", "buzz"] ""
15:18:26 <hpc> @hoogle iterate
15:18:26 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
15:18:26 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
15:18:27 <lambdabot> Data.ByteString.Lazy iterate :: (Word8 -> Word8) -> Word8 -> ByteString
15:18:33 <hpc> oh, and it's in prelude even
15:18:49 <mauke> dataangel: need more context
15:18:54 <Peaker> foldr (.) id  should have had a name
15:19:02 <mauke> compose
15:19:09 <Peaker> @hoogle compose
15:19:09 <lambdabot> No results found
15:19:10 <mauke> in analogy to and/or
15:19:22 <Peaker> I mean, in Prelude
15:20:26 <Peaker> > let applications n f x = iterate f x !! n   in   5 `applications` (+1) $ 100
15:20:27 <lambdabot>   105
15:20:29 <hpc> :t appEndo . mconcat . map Endo
15:20:29 <lambdabot> forall a. [a -> a] -> a -> a
15:20:36 <c_wraith> :t ala
15:20:36 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
15:20:47 <hpc> :t ala Endo foldMap
15:20:47 <lambdabot> Not in scope: `foldMap'
15:21:00 <c_wraith> :t ala Endo mconcat
15:21:01 <lambdabot>     Couldn't match expected type `(a -> a) -> Endo a'
15:21:01 <lambdabot>            against inferred type `[a1]'
15:21:01 <lambdabot>     In the second argument of `ala', namely `mconcat'
15:21:21 <c_wraith> ok, I don't understand the second arg of ala
15:21:25 <hpc> me neither
15:23:05 <c_wraith> :t under
15:23:06 <lambdabot> forall o n n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> (n -> n') -> o -> o'
15:23:10 <hpc> :t under Endo
15:23:11 <lambdabot> forall a n' o'. (Newtype n' o') => (Endo a -> n') -> (a -> a) -> o'
15:23:17 <hpc> :t under Endo mconcat
15:23:18 <lambdabot>     Couldn't match expected type `Endo a' against inferred type `[a1]'
15:23:18 <lambdabot>     In the second argument of `under', namely `mconcat'
15:23:18 <lambdabot>     In the expression: under Endo mconcat
15:23:31 <hpc> :t over Endo mconcat
15:23:32 <lambdabot> Not in scope: `over'
15:23:44 <dabblego> :t ala Endo mconcat
15:23:45 <lambdabot>     Couldn't match expected type `(a -> a) -> Endo a'
15:23:45 <lambdabot>            against inferred type `[a1]'
15:23:45 <lambdabot>     In the second argument of `ala', namely `mconcat'
15:23:46 <c_wraith> oh, need underF
15:23:55 <c_wraith> :t underF Endo mconcat
15:23:55 <lambdabot> Not in scope: `underF'
15:24:00 <hpc> wtf?
15:24:04 <c_wraith> ...  which isn't imported. :)
15:24:18 <hpc> oh, it's an old version
15:24:21 <c_wraith> yeah
15:24:27 <mrrk> hi.. i'm chatting with someone about `let fibs = scanl (+) 0 (1:fibs)`, and we're wondering how scanl knows, on the second level of recursion, that the head of fibs is now 1 rather than 0
15:24:47 <mauke> @src scanl
15:24:47 <lambdabot> scanl f q ls = q : case ls of
15:24:47 <lambdabot>     []   -> []
15:24:47 <lambdabot>     x:xs -> scanl f (f q x) xs
15:24:47 <hpc> @src scanl
15:24:47 <lambdabot> scanl f q ls = q : case ls of
15:24:47 <lambdabot>     []   -> []
15:24:49 <lambdabot>     x:xs -> scanl f (f q x) xs
15:25:25 <mrrk> yep, that's what we're looking at to puzzle through it
15:25:40 <mrrk> why doesn't x in x:xs always evaluate to 0?
15:25:44 <hpc> > let fibs = scanl (+) 0 (1:fibs) in fibs
15:25:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:25:48 <c_wraith> because it recurses
15:26:01 <mauke> mrrk: because it's a different ls each time
15:26:01 <c_wraith> and in the new context, x is rebound to the head of the new list
15:26:24 <c_wraith> notice how the recursive calls in scanl pass in only xs, not (x:xs)
15:26:39 <mrrk> but it looks like the new list is always just "fibs"
15:26:46 <mrrk> so the head is always 0
15:26:55 <mauke> mrrk: it can't "always" be something
15:26:57 <c_wraith> ...  you're ignoring the recursion
15:26:59 <mauke> mrrk: it's a different ls each time
15:27:04 <c_wraith> consider a simpler example
15:27:12 <c_wraith> > scanl (+) 0 [1..5]
15:27:12 <lambdabot>   [0,1,3,6,10,15]
15:27:24 <mrrk> well we're definitely not *ignoring* the recursion :-)  -- we're trying to understand why it works
15:27:53 <mrrk> right... in that case x is 1 then 2 then 3...
15:28:09 <c_wraith> "then" is a little misleading.  it's all of those, at different scopes
15:28:44 <mrrk> well ok but scopes occur at different times... nevermind :-)
15:29:36 <hpc> hang on, let's take the example of scanl (+) 0 [1..5]
15:29:51 <mauke> fibs => { scanl (+) 0 (1 : fibs) } => { 0 : case (1 : fibs) of [] -> []; x : xs -> scanl (+) (0 + x) xs }
15:30:01 <mrrk> the first time through, x:xs has x=0 (because that's the first value of f) and xs=fibs
15:30:14 <hpc> so by the definition of scanl, our list is actually 0:(scanl (+) (0+1) [2..5])
15:30:14 <mrrk> the second time through we don't see why x isn't also 0
15:30:29 <mauke> => { 0 : scanl (+) (0 + 1) fibs }
15:30:37 <mauke> mrrk: no, the first time through x is 1
15:31:29 <mrrk> sorry i meant the 2nd time through (the first recursion)
15:31:58 <mauke> => { 0 : 1 : case fibs of [] -> []; x : xs -> scanl (+) (1 + x) xs }
15:32:37 <mauke> => { 0 : 1 : case (0 : 1 : ...) of [] -> []; x : xs -> scanl (+) (1 + x) xs }
15:32:53 <mrrk> ah that might be it
15:33:00 <mauke> => { 0 : 1 : scanl (+) (1 + 0) (1 : ...) }
15:33:10 <mrrk> the "case" part is defined in one pass and evaluated in the next
15:34:02 <mrrk> hmm. still confused :-)
15:34:09 <mauke> => { 0 : 1 : 1 : case (1 : 1 : ...) of [] -> []; x : xs -> scanl (+) (1 + x) xs }
15:34:33 <mauke> => { 0 : 1 : 1 : scanl (+) (1 + 1) (1 : ...) }
15:35:13 <mauke> => { 0: 1 : 1 : 2 : case (1 : 2 : ...) of [] -> []; x : xs -> scanl (+) (2 + x) xs }
15:38:50 <mrrk> ok that seems to be making sense now
15:39:19 <monochrom> I invite you to my http://www.vex.net/~trebla/haskell/scanl.xhtml for more scanl tricks
15:39:48 <mrrk> the expression "(f q x)" says "(add last-time this-time)"
15:40:11 <adamvh> Is there an analogue of "uncurry" for functions of more than 2 arguments?
15:41:34 <Veinor> you'd have to write it yourself
15:41:41 <Veinor> once for each number of arguments
15:45:09 <sshc> ksf: Regarding the Codensity monad: Let's say we have "c :: CodensityT Identity String", which is essentially a wrapper for "(String -> a) -> a" (the Identity wrapper was disregarded.  There's no way to "get to the result" or return a value with 'a' without calling that function (and only the given function), right?
15:46:26 <ndxtg> I'm trying to convert a [String] into a nice single String, does anyone know why I get error here: http://codepad.org/RRMEwQ5X ?
15:46:45 <sshc> > concat ["fo", "", "o"]
15:46:45 <lambdabot>   "foo"
15:47:03 <mauke> ndxtg: list2str m is invalid
15:47:15 <mauke> ndxtg: and so is t ++ " }"
15:47:22 <mauke> ndxtg: m :: String; t :: [String]
15:47:41 <ndxtg> sshc: I need ["fo", "", "o"] to be converted to { fo, , o } so concat is not really right
15:47:58 <ndxtg> mauke: isnt m is the list of string?
15:48:02 <mauke> ndxtg: no
15:48:12 <mauke> > intercalate ", " ["fo", "", "o"]
15:48:12 <lambdabot>   "fo, , o"
15:48:18 <adamvh> *sigh* and upon this day I discovered that I am nowhere near good enough at Haskell to use it for Google Code Jam
15:48:56 <adamvh> probably should have stuck with Common Lisp this year
15:49:28 <Ptival> just finished Google Code Jam using only Haskell!
15:49:40 <adamvh> Ptival: congrats, man
15:49:46 <ndxtg> mauke: ERROR "aexp.hs":214 - Undefined variable "intercalate" <---- ?
15:49:51 <Ptival> functional programming made my life easy :D
15:49:53 <mauke> @index intercalate
15:49:53 <lambdabot> bzzt
15:49:55 <Ptival> I like it
15:49:59 <mauke> @hoogle intercalate
15:49:59 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
15:49:59 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
15:49:59 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
15:50:06 <mauke> ndxtg: import Data.List
15:50:24 <adamvh> Ptival: Functional programming made solving the problems easy for me - it was basic shit like reading the input files that wound up taking too much time
15:50:36 <adamvh> Ptival: I got the first one, and I knew *how* to do the second
15:50:50 <Ptival> I used a boilerplate code found on the Internet that I adapted
15:50:53 <adamvh> Ptival: but I couldn't get familiar with Data.Map fast enough
15:50:56 <Ptival> some Parsec for reading the input
15:51:07 <adamvh> Ptival: yeah, I was Parsec'ing too
15:51:13 <Ptival> I just failed at C large because of non-optimization on my side ^^
15:51:32 <Ptival> anyway, glad I chose Haskell :)
15:51:43 <adamvh> Ptival: never got to C or D, I'm ashamed to admit - too many type errors it took me too long to find
15:51:51 <adamvh> Next year I'll get the motherfucker
15:52:25 <adamvh> Since when I finished my solutions were like 20 lines of Parsec/IO and 8 lines of actual code
15:52:38 <adamvh> I'm feeling like Haskell will be good for this if I get beeter
15:52:40 <adamvh> *better
15:53:44 <ian_mi> oh, did google code jam just start?
15:53:56 <AtnNn> 1 minute left
15:54:00 <ian_mi> ha
15:54:58 <Veinor> the little brother in C has the same first name as me :(
15:55:15 <ndxtg> mauke: thank you, import didn't help (missing library?) but it works now from Hoogle subtitution: "intercalate xs xss is equivalent to (concat (intersperse xs xss))"
15:55:20 <mrrk> monochrom: that link was great, thank you
15:55:27 <monochrom> you're welcome
16:01:54 <sshc> Anybody here who knows about the codensity monad transformer: Suppose there's  "c :: CodensityT Identity String", which is essentially a wrapper for "(String -> a) -> a" (the Identity wrapper was disregarded.  There's no way to "get to the result" or return a value with 'a' without calling that function (and only the given function) with a String (in other words, applying a String to the
16:02:00 <sshc> function), right?
16:02:59 <hpc> i think so, yes, assuming the rest of your preamble is correct
16:03:46 <sshc> I think so too
16:04:27 <sshc> (THere should be a ')' after "disregarded")
16:04:32 <hpc> much in the same way that you can't get an a out of a State s a without applying an initial s
16:05:41 <sshc> If that's the case, I can't see any point in Codensity
16:05:43 <sshc> How can it be used
16:05:44 <sshc> ?
16:06:17 <hpc> sshc: because you can still manipulate "what the a value might be"
16:06:34 <hpc> sshc: in the same way State can manipulate what the intermediate values might end up being
16:07:16 <hpc> (i am using State as a metaphor because Codensity looks like Cont, which i don't fully understand)
16:07:47 <sshc> It's like ContT, except you don't have any control over the "r"
16:08:26 <sshc> newtype CodensityT m a = CodensityT { runCodensityT :: forall b. (a -> m b) -> m b }
16:08:43 <hpc> ah, nifty
16:09:26 <hpc> oh, it's a higher-ranked type
16:09:29 <sshc> My question still stands, if anybody who knows about Codensity can confirm: Suppose there's  "c :: CodensityT Identity String", which is essentially a wrapper for "(String -> a) -> a" (the Identity wrapper was disregarded).  There's no way to "get to the result" or return a value with 'a' without calling that function (and only the given function) with a String (in other words, applying a String
16:09:32 <hpc> i don't fully understand those either
16:09:35 <sshc> to the function), right?
16:09:53 <aristid> :t runContT
16:09:57 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
16:10:44 <aristid> newtype CodensityT m a = CodensityFromContT (forall r. ContT r m a)?
16:11:15 <sshc> aristid: Pretty much, yes; I think so.
16:12:54 <bogner> I'm trying to install the haskell platform on OS X.
16:13:06 <bogner> It says I need to install the "XCode developer tools" first
16:13:15 <bogner> So I installed XCode, but that doesn't seem to do it
16:13:20 <bogner> Where do I find this?
16:25:12 <Saizan> sshc: yeah, you've that guarantee since the thing wrapped inside c must be polymorphic over 'a', so it doesn't have any other way to produce a value of that type
16:25:49 <sshc> Saizan: Ah, thanks; I've been trying to have that answered for a while :)
16:26:00 <sshc> But, if that's the case, I can't see any point in Codensity.  How can it be used?
16:27:22 <Saizan> one of the points of Codensity is to automatically reassociate on the right applications of >>=, which ends up speeding up tree-like monads
16:28:14 <Saizan> another is that instead of Identity you've some other monad you can still funny things like use the continuation twice
16:28:19 <Saizan> (or more)
16:28:29 <Saizan> s/instead/if instead/+
16:29:00 <shachaf> Saizan: +?
16:29:35 <sshc> I don't understand your latter statement
16:29:36 <Saizan> typo.
16:29:54 <sshc> Could you elaborate on what is meant by "reassociate"?
16:30:10 <hpc> Saizan: so Codensity is like the ubermonad version of difference lists?
16:30:13 <Saizan> sshc: http://www.haskell.org/pipermail/haskell-cafe/2010-January/072454.html <- this post explains it better
16:30:38 <djahandarie> hpc, difference list is just a CPS transform of normal lists
16:30:51 <djahandarie> And Codensity captures the idea of CPS transforming code
16:30:54 <Saizan> hpc: it's pretty similar
16:31:05 <hpc> groovy
16:31:34 <Saizan> sshc: free monads are what i called tree-like monads above
16:31:53 <Saizan> and anyhow are those of the form Free F, where F is a Functor
16:34:41 <aristid> djahandarie: oh, so difference lists and church encoded lists have some similar properties?
16:35:52 <Saizan> difference lists don't feel so much like a CPS transform to me
16:36:23 <ddarius> I agree with Saizan, that while not completely unrelated, I don't think taking a CPS transform view is the most natural perspective.
16:36:56 <djahandarie> What would you call that transformation?
16:37:24 <ddarius> The fact that (mappend m) is a monoid homomorphism from M -> Endo M
16:37:26 <aristid> are the time complexities of difference lists and church-encoded lists different?
16:37:35 <aristid> (of their operations)
16:38:31 <ddarius> aristid: "Difference lists" aren't lists and aren't a generic scheme for representing lists.  You have to already have a list type to make functional lists ("difference lists").
16:39:32 <Saizan> the similarity between "difference lists" and Codensity (Free F) is that both take some form of substructure to attach at their end, though Codensity (Free F) cna have many "ends" and they contain labels :)
16:39:35 <ddarius> Sorry mappend is a monoid homomorphism of that kind.
16:39:43 <aristid> ddarius: of course difference lists are a generic scheme to represent lists, even if their encoding involves native lists. they have different properties, and that's why they exist
16:39:58 <Peaker> difference lists are conceptually "lists parameterized by their end" allowing O(1) replacing of the end (aka append) instead of replacing all elements up to the end to replace the end
16:40:28 <Peaker> I like that explanation, because it also points to how to invent things like difference lists systematically:
16:41:00 <Peaker> you have some operation X that is expensive because it copies a lot of stuff to change some little thing[s]? Parameterize it on the little thing[s] as a function, instead
16:41:18 <aristid> i think you cannot implement "tail" on difference lists as efficiently as on normal lists, unless i made a mistake in thinking
16:42:12 <Peaker> aristid, I don't think tail's a problem..  I think the problem is looking at a partially constructed list -- that will convert it to a normal list, and won't be shared with the list when it's appended (recomputation will occur)
16:42:53 <aristid> Peaker: problem? i was just talking about the time complexity of tail
16:43:34 <c_wraith> time complexity of tail is O(1), unless you do what peaker was talking about.
16:43:34 <aristid> because that's something that struck me when trying to implement church-encoded lists: tail is not efficient
16:43:44 <c_wraith> it's just (tail .)
16:44:12 <c_wraith> err, not quite.  but you know what I mean.
16:44:16 <Peaker> aristid, DLists aren't church-encoded lists
16:44:17 <aristid> hmm.
16:44:28 <Peaker> foldr is a church-encoded list
16:44:41 <aristid> Peaker: but they are CPS-transformed lists?
16:45:06 <bogner> Does anyone know how to install the haskell platform on OS X?
16:45:17 <Peaker> I know CPS transform of function/calls, I don't know what's a CPS transform of a data structure
16:45:55 <Peaker> aristid, Best approximation of meaning I can think of is indeed church encoding, so DList wouldn't fit that
16:46:13 <c_wraith> :t (tail .)
16:46:14 <Eduard_Munteanu> DList == doubly-linked list by tying the knot?
16:46:14 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f [a]
16:46:35 <Peaker> Eduard_Munteanu, no, it's a list that supports O(1) append by taking the end as an arg instead of hard-coding it to []
16:46:47 <tg_> Eduard_Munteanu: where did this "tying *the* knot" phrase come from?
16:46:51 <Peaker> (so to append, just change the arg to be a different list)
16:46:59 <Eduard_Munteanu> tg_: I think I've seen it somewhere.
16:47:03 <Peaker> DList a = [a] -> [a]
16:47:04 <Eduard_Munteanu> Peaker: Seq? :)
16:47:10 <tg_> Eduard_Munteanu: I saw it on reddit/haskell first
16:47:13 <tg_> and then a few other places
16:47:15 <Peaker> Eduard_Munteanu, worst-case O(1), not amortized
16:47:20 <geheimdienst> istr it's from that one blog post on recursive data structures ...
16:47:45 <Eduard_Munteanu> The phrase isn't that bad.
16:47:45 <ddarius> tg_: The term is probably thirty or fourty years old.
16:47:56 <Eduard_Munteanu> Oh.
16:48:02 <aristid> Peaker: who said that difference lists are cps-transformed lists? because that seems pretty wrong now
16:48:04 <tg_> I just want to know the reason for using it
16:48:08 <Peaker> aristid, I don't know
16:48:19 <aristid> djahandarie said it
16:48:21 <tg_> as a physicist there's tons of people who use it "knot theory" but I doubt it's related at all
16:48:30 <ddarius> tg_: Because when you "tie the knot" you are making a cycle in the value graph.
16:48:31 <geheimdienst> http://www.haskell.org/haskellwiki/Tying_the_Knot
16:48:47 <Peaker> aristid, maybe if you consider the "end of the list" to be the list's "continuation" that can work :-)
16:49:42 <aristid> :t foldr
16:49:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:49:50 <dolio> Difference lists aren't even [a] -> [a]. But we'll probably never be rid of the name now.
16:49:55 <ddarius> There are relations between "difference lists" and CPS, but the phrase "CPS-transformed lists" doesn't even make sense as Peaker pointed out earlier.
16:50:12 <ddarius> I hate the term "difference lists" for these.
16:50:29 <aristid> ddarius: i think it was used in a monad reader.
16:50:30 <c_wraith> You know, the funny thing is that I rarely use [a] -> [a] because of easy appending to the end.  I generally use it because it's easier to see how to make something lazy via it.
16:50:56 <Peaker> c_wraith, what do you mean?
16:50:58 <aristid> ddarius: and it's just a name... not like it has to have deep meaning
16:51:07 <shachaf> ddarius: What term do you prefer?
16:51:38 <Peaker> AppendableList?
16:51:40 <ddarius> aristid: The name was chosen by analogy to difference lists in logic programming which have a much better claim to the name and almost diametrically opposite properties.
16:52:40 <aristid> i thought the name was chosen because you change the list by adding a difference function with (.)
16:53:05 <aristid> well, whatever.
16:53:23 <c_wraith> Peaker: I seem to find cases where I want a list accumulator, but I want to be able to read from it without generating the whole thing.  [a] -> [a] works for that.  I *think*.
16:53:30 <dolio> "Functional lists" is one I've heard, and is at least more technically accurate.
16:53:51 <danharaj> What's a difference list?
16:54:24 <tg_> ddarius: is "tying the knot" exactly the same thing as a "recusrive closure" or "recusrive suspension"
16:54:32 <Peaker> c_wraith, a normal list works for it too?
16:54:32 <aristid> danharaj: a function that takes a list, and returns a list that ends with the parameter
16:54:46 <mauke> aristid: ...
16:54:55 <aristid> mauke: did i make a mistake again? :(
16:54:57 <alex_r> how do you multiply numbers on a TM?
16:55:23 <mauke> aristid: hard to tell, actually
16:55:28 <alex_r> in general
16:55:34 <mauke> aristid: the question was ambiguous
16:55:37 <Peaker> dolio, but it's not just any [a]->[a], the arg will appear once as the tail of the list
16:55:59 <Peaker> so the "functional" doesn't capture the essence
16:56:06 <Peaker> (and is a way overloaded term)
16:56:12 <shachaf> Peaker: But the word "functional doesn't have enough meanings yet.
16:56:16 <dolio> They're lists represented as functions.
16:56:18 <shachaf> It deserves at least a couple more.
16:56:18 <ddarius> In logic programming, it's a pair of logic variables (Xs, Ys) such that Xs = Zs ++ Ys, i.e. conceptually Zs = Xs - Ys.
16:56:18 <Peaker> :-)
16:56:33 <danharaj> ddarius: ah ok. And what is it that is being discussed right now?
16:56:46 <aristid> shachaf: "difference" doesn't have enough meanings either.
16:56:56 <ddarius> The embedding of [a] into Endo [a] via (++).
16:57:42 <danharaj> would that be (\xs -> (xs ++)) or (\xs -> (++ xs))?
16:58:02 <hpc> the former
16:58:07 <hpc> er
16:58:11 <ddarius> Yes.
16:58:20 <hpc> it would be \ys -> (xs ++ ys)
16:58:23 <hpc> or something like that
16:58:35 <ddarius> hpc: You were right at the beginning.
16:58:36 <hpc> where xs is the "stored" list
16:58:41 <hpc> ah, k
16:58:57 <Eduard_Munteanu> Okay, different people online at the moment, I've been meaning to ask this. Has anybody investigated the possibility of a language where you mainly write types and you're limited wrt what programs you can write? I mean...
16:58:58 <shachaf> @pl \xs -> (xs++)
16:58:58 <lambdabot> (++)
16:59:22 <hpc> Eduard_Munteanu: you mean coq?
16:59:24 <hpc> also
16:59:25 <Eduard_Munteanu> Consider a language where you'd write types and the compiler would infer most of the programs, or do so up to constants / isomorphism.
16:59:26 <hpc> @quote oleg
16:59:26 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
16:59:44 <hpc> hmm, of all the oleg quotes, i get the one that isn't about types
16:59:46 <Eduard_Munteanu> Mm, not really.
16:59:47 <Peaker> well, lifting a normal list into an Endo list is not very interesting.. generating it that way in the first place is what's useful
16:59:57 <ddarius> As I mentioned earlier, there's nothing special about [a].  For any monoid, mappend embeds m into Endo m, and so this representation is useful anytime we want to "reassociated" mappends.
17:00:10 <Eduard_Munteanu> I mean the compiler would accept only programs where it could easily deduce implementations given some types.
17:00:19 <danharaj> shachaf: the functions I listed were the embeddings.
17:00:40 <Peaker> ddarius, cool, the library ought to be generalized then..
17:00:44 <danharaj> I don't understand why they're called difference lists.
17:00:45 <ddarius> Peaker: The way these "difference lists" are usually made is by a composition of such embeddings.  In fact, that's the only way they are made.
17:00:51 <hpc> ddarius: and even further, it works for any category, not just (->)
17:00:52 <danharaj> Why not "append list"?
17:01:03 <zsiec> i got 100 on codejam with Haskell :)
17:01:06 <hpc> ddarius: so it reassociates any endomorphism
17:01:13 <ddarius> hpc: True.
17:01:20 <Eduard_Munteanu> The reason I'm asking is one would have more assurance if his types were refined to such an extent.
17:01:48 <ddarius> Eduard_Munteanu: That's called logic programming, though they don't usually execute those programs...
17:01:49 <Eduard_Munteanu> Sometimes I wonder myself if my program is typed sufficiently.
17:02:07 <Eduard_Munteanu> (or sufficiently dependently typed)
17:03:03 <Eduard_Munteanu> ddarius: do you mean the bit where you specify what the program does, not how?
17:04:01 <ddarius> No, I mean the execution of a logic program can be viewed as a search for a proof term for the statement represented by the predicate.
17:04:31 <Eduard_Munteanu> Oh.
17:04:37 <danharaj> I like Endo List actually.
17:04:46 <Eduard_Munteanu> But surely stuff like Prolog doesn't actually expect that of the programmer.
17:04:55 <ddarius> Expect what?
17:05:27 <Eduard_Munteanu> I mean, I don't know much Prolog, but it doesn't look so different from functional languages.
17:05:39 <djahandarie> When I said "Difference lists are CPS transformed lists" I didn't mean that in any formal manner (especially because it makes no sense formally). I think you can get difference lists with a CPS transform but I'm not exactly sure how to do it.
17:06:01 <Peaker> djahandarie, CPS transform of what?
17:06:01 <Eduard_Munteanu> Firstly I don't think the type system is powerful enough.
17:06:12 <ddarius> Prolog doesn't have a type system.
17:06:51 <aristid> djahandarie: you could church-encode the list
17:07:25 <aristid> djahandarie: but you don't get difference lists that way
17:08:23 <Eduard_Munteanu> ddarius: hrm, so one could say in Prolog you write the spec and refine it until the compiler groks it?
17:08:37 <Eduard_Munteanu> i.e. can generate a proof term for it
17:08:55 <ddarius> No, if by "compiler" you mean the Prolog compiler.
17:09:32 <ddarius> I mean the Prolog -program- is the spec, and the -execution- of the logic program corresponds to finding a functional program that meets the spec.
17:09:48 <Eduard_Munteanu> Oh.
17:10:43 <Eduard_Munteanu> Note I'm asking this in the context of verified software, theorem provers and such, so I'm expecting some level of assurance.
17:12:09 <Eduard_Munteanu> Frankly since I read something here http://lambda-the-ultimate.org/node/3858 I'm a bit uncertain on how useful verified software actually is.
17:13:55 <ddarius> You may want to read the paper referenced here: http://lambda-the-ultimate.org/node/4241
17:15:00 <Eduard_Munteanu> ddarius: thanks. I've been looking for more papers. I've been reading stuff on proof-carrying code but I still find it a bit hazy.
17:15:09 <danharaj> So those difference lists are obtained in the same way you obtain the CPS transformation of a function, right? Because CPS transformation is embedding functions via (\f -> (.f))?
17:16:38 <Eduard_Munteanu> ddarius: also, do you know where I could start on refinement (refining a program from a spec through a high-level language then something like C)?
17:16:50 <Eduard_Munteanu> It seems difficult to machine-check all these steps.
17:17:12 <danharaj> Eduard_Munteanu: It sounds like you want to work with a proof assistant.
17:17:18 <danharaj> Have you tried Coq?
17:17:43 <Eduard_Munteanu> danharaj: I'm doing Agda already
17:18:03 <Eduard_Munteanu> but I suppose Coq does it too.
17:19:46 <Eduard_Munteanu> The main problem is writing code in another language and having it proved by Agda/Coq sounds really tedious/difficult.
17:20:11 <Eduard_Munteanu> (proved == machine checked against changes in the original code)
17:20:13 <danharaj> Don't both of those have program extraction to haskell?
17:21:08 <Eduard_Munteanu> Well that's the thing, for some applications extracting code just isn't practical. For stuff like OS kernels you kinda really need to check pristine, hand-written asm/C code.
17:21:14 <Eduard_Munteanu> (for example)
17:21:34 <monochrom> Z and VDM are suitable for refinement
17:22:29 <Eduard_Munteanu> monochrom: do you know any pointers on getting started with that sort of stuff? Like free tools, available docs/papers?
17:22:40 <Eduard_Munteanu> I tried looking into B-Method.
17:23:09 <monochrom> B is also in that genre. tutorials on their main websites should do
17:23:10 <Eduard_Munteanu> But this stuff seems a bit obscure, or at least not really popular anyway .
17:23:22 <monochrom> definitely unpopular in FP circles
17:23:51 <Eduard_Munteanu> I'd take Coq, Agda or even Isabelle as popular, but this scores even lower :)
17:24:34 <monochrom> essentially Bird is the only one in FP circles doing refinement, and even then not by that name. everyone else in FP rage about equational reasoning, i.e., spec and impl are perfectly equal, not refinement
17:25:48 <monochrom> however, once you enter the imperative programming circle, either it is automatic verification or refinement (B, Z, VDM) or no verification
17:27:08 <ddarius> @google "Running the Manual"
17:27:10 <lambdabot> http://www.cse.unsw.edu.au/~chak/papers/sel4-model.pdf
17:27:10 <lambdabot> Title: Running the Manual: An Approach to High-Assurance Microkernel Development
17:27:15 <Eduard_Munteanu> Necula's PCC seems to focus on automatic proving.
17:28:06 <ddarius> Necula's PCC was about getting safety properties not correspondence to a complete specification.
17:28:42 <ksf> sshc, urm... to be honest, I never cared about grokking codensity past the point of mechanically applying it and seeing that it sped up my code.
17:28:56 <Eduard_Munteanu> ddarius: I've read a bit on seL4, but I'm not convinced or sure whether the translation is actually machine-checked
17:29:39 <ksf> ...as not everything is transformable loosing expressive power for a speed gain doesn't hit my wtf filter, so I didn't care.
17:29:39 <Eduard_Munteanu> And the source code doesn't seem to be publicly available. :(
17:30:18 <ksf> Eduard_Munteanu, there's an automatic prover for haskell
17:30:28 <ksf> (using isabelle for termination checking)
17:30:33 <ksf> google for zeno
17:30:34 <Eduard_Munteanu> ddarius: my intended application is taking existing C code and reasoning about it, while still be able to check it against my proof in case it changes.
17:30:53 <Eduard_Munteanu> ksf: hm, neat, that might prove useful.
17:30:55 <Eduard_Munteanu> Thanks.
17:31:01 <ksf> Eduard_Munteanu, write a C-like EDSL?
17:31:48 <Eduard_Munteanu> ksf: that's one possibility but it seems really tedious and apart from Necula's Deputy, there doesn't seem to be much, especially not in conneciton with dependently-typed provers like Coq or Agda.
17:31:56 <ksf> you probably don't need all the inconsistency the C standard comes with, anyway.
17:32:24 <nuferup> hi
17:32:54 <nuferup> which haskell ide do you prefer? eclipsefp? leksah?
17:33:31 <ksf> otoh, though, you shouldn't be talking with me, I would've problems proving myself out of a wet fibonacci.
17:34:31 <Eduard_Munteanu> I've already fiddled with an asm ESDL in Agda, though it seems quite a bit of work to get basic stuff done, and asm has a decent syntax.
17:34:50 <xemdetia> Is there a cheatsheet for special characters? I am having a bear of the time trying to remember what they are all really supposed to be called.
17:35:04 <dabblego> xemdetia: http://haskell.org/hoogle
17:35:12 <Eduard_Munteanu> Ultimately it means providing a whole machine model and specification to ensure safety properties.
17:35:22 <ksf> yep.
17:35:26 <ksf> use a standard model like llvm?
17:35:43 <xemdetia> thanks dabblego
17:36:38 <Eduard_Munteanu> ksf: hm, I'll look into that too. For the moment I've been fooling around with language-c to generate an Agda module with an embedded AST, but there's lots to do to get ther.
17:38:12 <Eduard_Munteanu> Also, here's one more poll... what's your opinion on ad-hoc / logic-based theorem provers vs stuff based on Curry-Howard, like Coq/Agda? Do you know any paper comparing the benefits of such systems?
17:39:05 <Eduard_Munteanu> (Surely dependently-typed stuff looks a lot nicer theoretically, but I wonder)
17:40:08 <ksf> I'd go for the latter, but lack any founded argument to back up my intuition.
17:41:14 <Eduard_Munteanu> The only thing I can come up with is Curry-Howard actually lets you extract programs, but I have no experience with stuff like Isabelle/HOL or other logic frameworks.
17:41:55 <ksf> I guess it depends on whether you want to extract or prove programs.
17:42:28 <jmcarthur> i like curry-howard, but that's because i like programming
17:42:31 <ksf> that is, bluntly said, whether you want to code on the type or value level.
17:43:51 <Eduard_Munteanu> I see... Well, thanks guys :)
17:44:12 <ddarius> If you want to evolve some C code while maintaining a formal proof that it meets some specification, you have some options.  The bad option is to write a parser of C into Coq or whatever or some AST type; prove the specification on the parsed representation; repeat with any changes to the code or specification.
17:44:27 <gwern> > 3.49 + 1.68 + 2.14 + 2.78
17:44:28 <lambdabot>   10.09
17:45:03 <Eduard_Munteanu> (oh, a disadvantage of CH, I think: it's probably not as barebones as logic frameworks, it does assume a certain logic)
17:45:06 <ddarius> That's the bad way because, very likely, you will have to completely restart with each change.
17:45:07 <shachaf> > 9.08 + 1.12 + 4.15 + 2.60
17:45:07 <lambdabot>   16.95
17:45:45 <Eduard_Munteanu> ddarius: not an AST per se, but some sort of annotated EDSL
17:45:58 <Eduard_Munteanu> ddarius: what was the second option? :)
17:46:12 <ddarius> Eduard_Munteanu: I didn't say there were only two.
17:46:30 <ddarius> There are two other ways that avoid this.  One, have a pretty-printer and have the canonical representation be in the Coq code, i.e. "extract" the C from it.  Now you evolve the "C" in Coq and the proof with it.
17:47:38 <ddarius> The other option is that you have a parser and pretty-printer and you only allow yourself to change the C through correctness-preserving transformations.
17:48:24 <BMeph> "...now you have four problems." ;þ
17:48:54 <ksf> and even if all that is done, you still haven't proven the C compiler to be correct.
17:49:14 <ddarius> ksf: You can use CompCert.
17:50:26 <ksf> also, I dunno what you're doing, maybe it's a bit daring for nuclear plants, but it definitely *is* possible to produce bug-free code without theorem proving.
17:50:31 <Eduard_Munteanu> ddarius: I was actually going for another one: pretty-print C code to a (say) Coq EDSL and check against the proof.
17:50:35 <ddarius> But really that isn't relevant to this aspect (though of course it is relevant to the system).  You are only producing C.  All you are attempting to prove is that you produce C that meets some spec.  That that C gets correctly translated to machine code is someone else's problem.
17:50:38 <Eduard_Munteanu> A bit like the second option.
17:51:23 <Eduard_Munteanu> ksf: I agree, but some formal reasoning is nice to have, even on a higher level. I was going to try it on the Linux kernel or such stuff.
17:51:31 <ksf> (that is, produce bugfree code and then get a huge sheet from some british carrier's QA that contains a lot of "spelling errors". "defense" instead of "defence" and stuff)
17:51:35 <Eduard_Munteanu> Some people there seem to appreciate correctness proofs and such.
17:51:38 <ddarius> Eduard_Munteanu: By "pretty-print C code to" do you mean "parse C code into"?
17:52:31 <Eduard_Munteanu> ddarius: ultimately yeah, but I'm hoping to preserve much of the human-readable look.
17:52:56 <Eduard_Munteanu> Not an AST, that would be a bit sensitive to slight changes.
17:53:18 <ddarius> Eduard_Munteanu: Because what you describe sounds like the first option, unless you intend the Coq EDSL to be the authoritative source from then on, which does correspond to the second option.
17:53:36 <Eduard_Munteanu> ddarius: say 'mov %eax, 0' ~> 'mov eax 0' encoded in Agda datatypes if we're talking asm for example
17:53:57 <Eduard_Munteanu> Ah, no, not the authoritative/main source.
17:54:18 <Eduard_Munteanu> Note I'm just trying to make it an option to check against the spec.
17:54:33 <Eduard_Munteanu> Do you think that's not really doable?
17:55:14 <Eduard_Munteanu> (I wouldn't expect all developers on that project to fiddle with proofs, so if I could just prove basic properties and have them machine-checked at compile-time, that's fine)
17:55:36 <ddarius> Eduard_Munteanu: Unless your spec is really simple, you need a (human written, machine checked) proof to actually validate it.
17:56:07 <ksf> zeno seems to be able to be smarter than that.
17:56:13 <Eduard_Munteanu> ddarius: indeed human written, but I'm hoping it won't be sensitive to minor changes that don't break the "spirit" of the spec.
17:56:14 <ksf> you basically give quickcheck-like properties.
17:56:59 <Eduard_Munteanu> ksf: is it all statically-checked?
17:57:09 <ksf> yep
17:57:15 <ksf> still work in progress, though.
17:57:22 <Eduard_Munteanu> It sounds interesting.
17:57:33 <ksf> ...and thus rough around the corners.
17:57:36 <ddarius> Eduard_Munteanu: Yeah, that hasn't been accomplished yet.  Most machine-checked proofs are fairly sensitive to minor changes, unless you do an excellent job of catching the modes of change and modular structure of the proof.
17:57:45 <ksf> like happily proving reverse . reverse = id
18:00:35 <Eduard_Munteanu> ddarius: I see, thanks, that was my main dillema. Although embedding annotations like dependently typed array bounds checking seems doable, like Deputy. But I'm still unsure how easy that's to parse into Coq / Agda and have it checked.
18:00:44 <ksf> (as a side note, an approach that uses multiple, small, but overlapping specs seems to be superiour to a single large spec from a software design POV IMO)
18:00:46 <Eduard_Munteanu> I'd rather not go with Deputy.
18:01:02 <Eduard_Munteanu> (mainly because it's limited in what it does and secondly it inserts runtime checks)
18:02:00 <ksf> might be related to that penchant philosophers of all schools and ages so far had for providing the "one big proof"
18:02:23 <ddarius> It's much easier to get through a verification if neither the proof nor the code is held inviolable but are rather evolved in tandem, each adjusting to the needs of the other.
18:02:38 <Eduard_Munteanu> ksf: indeed I'm not looking to prove everything, I'm just looking to prove little bits here and there, like locking semantics etc.
18:03:31 <Eduard_Munteanu> I should also probably look into refinement types, I've heard about that stuff and it sounds like something related.
18:03:46 <ksf> "so movement cannot exist, concluded zeno, and subsequently fell asleep as he was failing to reach for his coffee cup"
18:05:15 * ksf decides to prove to his kids that they can't move, exist or anything else once he gets some
18:08:35 <sshc> ksf: I'm reading http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf, but the binary tree defined in the beginning seems rather contrived and impractical, since only leaves can have actual elements; nodes only contain sub-trees, not elements
18:10:21 <ksf> sshc, see e.g. http://hpaste.org/46485/yoctoparsec  for a more real-world example.
18:10:40 <ksf> (warning: work-in progress)
18:10:55 <ddarius> sshc: Adding stuff into the branches doesn't change anything with the argument.  Also, that captures a non-determinism monad.
18:11:58 <ddarius> The paper has "a more realistic example" within it.
18:13:09 <ksf> sshc, you're also going to need RangeMap which I just attached, the rest is in standard packages
18:13:35 <ksf> (and the map type isn't really central to the codensity stuff anyway)
18:25:15 <ksf> ...also, information-free nodes can be practical when you have other means of indexing your stuff.
18:25:22 <ksf> binary heaps come to mind
18:25:38 <ksf> or something hoffman-like.
18:26:17 <ksf> just see the tree as a binary trie containing some bonus information at the end.
18:45:55 <lispy> anyone here know what you have to do to install Unixutils on osx?
18:46:13 <lispy> It tells me the C library crypt is missing
18:46:16 <NihilistDandy> lispy: Brew not working?
18:46:26 <NihilistDandy> lispy: Also, have you installed Xcode?
18:47:26 <NihilistDandy> I thought that said MarxistFrog for a minute
18:48:33 <lispy> NihilistDandy: I installed brew, but what should I install with brew?  Also, brew seems a bit...unprofessional.  Telling me to chown /usr/local??
18:48:42 <lispy> And yeah, I have xcode
18:48:47 <NihilistDandy> Then you have crypt
18:49:08 <NihilistDandy> Also, brew is amazing. What's wrong with chowning /usr/local? It's yours anyway
18:49:13 <NihilistDandy> That's what it's there for
18:49:18 <NihilistDandy> Would you rather install as root?
18:50:07 <lispy> brew looks very sketchy, IMO.  I'm planning to not use it.
18:50:12 <lispy> That's all I'm saying.
18:50:24 <NihilistDandy> What makes you say that?
18:50:36 <NihilistDandy> It's better than ports or fink
18:50:39 <luite> NihilistDandy: with that argument you could just as well do everything as root....
18:51:02 <NihilistDandy> luite: I'd rather not do *anything* as root
18:51:32 <luite> NihilistDandy: chmod -R 777 / and you don't have to do anything as root ;p
18:51:40 <NihilistDandy> :P
18:52:02 <lispy> I have xcode 3.2.6
18:52:16 <lispy> When I ran, find / -name "libcrypt\.*" nothing came up
18:52:28 <NihilistDandy> What happens when you run `man crypt'?
18:53:06 <lispy> I get a man page that is missing information.  It literally has holes in it.  I've never seen such a thing before.
18:53:26 <NihilistDandy> That is very odd
18:53:27 <lispy> oh, just my terimnal settings
18:53:37 <lispy> it's printing some things in black on black
18:53:50 <NihilistDandy> Did you check the "UNIX utilities" or whatever box when you installed Xcode?
18:53:58 * ddarius is going to start using the construction "literally figuratively."
18:54:02 <lispy> I didn't actually install it.
18:54:12 <NihilistDandy> lispy: Well, there's your problem
18:54:54 <lispy> ddarius: they are literal holes but not the kind of hole you find in the ground.  Still a literal gap.
18:55:14 <ddarius> lispy: I wasn't criticizing your usage.
18:55:19 <pmetzger> I would have.
18:55:28 <pmetzger> (I literally would have.)
18:55:41 <pmetzger> (Not figuratively at all!)
18:55:43 <ddarius> (Though I admit I did realize that it would probably come off that way.)
18:56:05 <lispy> ddarius: ah
18:56:13 * lispy wonders how to tell man not to use black
18:57:16 <NihilistDandy> man -dont-paint-it-black
18:58:38 <pmetzger> terminal on the mac is pretty nice.
18:58:46 <pmetzger> easily customized.
18:58:55 <ksf> the use of "literally" to mean "allegorically" is entirely justified.
18:59:09 <NihilistDandy> pmetzger: Agreed. I used iTerm 2 for a while, but it's just kinda meh now that the SL terminal has all of its features
18:59:12 <Hugglesworth> >_< bloody dependency issues
18:59:12 <pmetzger> ksf: you mean "figuratively".
18:59:23 <ksf> just because something is *written* does not mean it has to be *objective-material truth*. on the contrary.
18:59:31 <NihilistDandy> Correct
18:59:43 <pmetzger> I meant "allegorically" vs "figuratively".
18:59:52 <pmetzger> allegorical does not mean "figurative"
18:59:59 <NihilistDandy> I am literally the bastard lovechild of Hawking and Cleopatra
19:00:17 <ksf> wouldn't we all be somewhat scientists, we'd notice that most writings aren't scientific, but prose.
19:01:04 <pmetzger> BTW, Tip of the Day: Raph Levien's "Inconsolata" font is amazingly nice for things like Terminal.app and Emacs.app if you're a programmer.
19:01:06 <ksf> "She is the most beautiful woman ever to have walked on earth" is, albeit being somewhat unfounded in objective-material terms, utterly legit literal truth.
19:01:15 <NihilistDandy> pmetzger: Agreed
19:01:26 <NihilistDandy> I use it for code in all my LaTeX documents
19:01:27 <lispy> okay, man page is back to normal.  So I have xcode and I have the man page for crypt, but you think I need to re-install xcode?
19:01:28 <Hugglesworth> pmetzger: Agreed too
19:01:29 <ksf> for the object of said literature isn't the rest of the world, but the state of mind of said chap.
19:01:30 <ddarius> I like how etymonline explicit counters that: "'taking words in their natural meaning' (originally in reference to Scripture and opposed to mystical or allegorical),"
19:01:45 <pmetzger> ksf: "literal" does not mean "literary"
19:01:48 <NihilistDandy> lispy: If you have the man page, I'm fairly sure it's been installed
19:02:03 <ksf> pmetzger, it doesn't exclude it, either.
19:02:09 <NihilistDandy> Run the installer and make sure Unix Development whatever was installed
19:02:27 <pmetzger> ksf: it did in its original usage. of course, I'm not a grammatical prescriptivist.
19:02:33 <pmetzger> ksf: use defines meaning.
19:02:38 <pmetzger> ksf: so it is possible that by now it does.
19:02:52 <pmetzger> lispy: is your PATH set right?
19:02:56 <ksf> if you want an adomination to fight, take "to beg the question"
19:03:21 <NihilistDandy> ksf: Circular reasoning cannot be fought. If you try to fight it, you cannot win.
19:03:23 <pmetzger> ksf: ah, but again, if one is not a prescriptivist, the distortion of meaning is the new meaning...
19:04:30 <ksf> NihilistDandy, I shall propose that for a pirate party poster.
19:04:40 <lispy> pmetzger: do you know what needs to be in my path in this case?
19:04:51 <geheimdienst> pmetzger: you do use negative words like "distrotion", and earlier you did bully lispy about his use of "literally" ...
19:04:57 <pmetzger> lispy: echo $PATH and cut and paste it here...
19:05:11 <pmetzger> geheimdienst: I was being silly. I'm silly a lot.
19:05:35 <lispy> pmetzger: What should be in my path to find crypt on osx?
19:05:38 <ksf> another rather literal truth would be "in my city, there isn't a place where no tree can be seen"
19:05:52 <NihilistDandy> pmetzger: I don't think $PATH will deal with it
19:05:54 <pmetzger> lispy: wait, crypt is a library function...
19:06:01 <NihilistDandy> Is there a $LIBPATH?
19:06:03 <pmetzger> I thought you meant a command.
19:06:22 <pmetzger> there is the ld library path but no, that's not likely the issue
19:06:22 <ksf> (that must carry over from ages ago, the romans called us "wood-dwellers")
19:06:27 <pmetzger> crypt is in libc
19:06:54 <pmetzger> you just include unistd.h and away you go.
19:07:18 <dagit> pmetzger: well, cabal literally says, "* Missing C library: crypt"
19:07:52 <pmetzger> hrm. nm of /usr/lib/libc.dylib | fgrep crypt shows the symbol.
19:08:05 <pmetzger> 00000000000b2e0e T _crypt
19:08:10 <NihilistDandy> dagit: I had something similar when I was building mueval. I had to pass cabal some ghc-opts
19:08:20 <pmetzger> so it is there, no question.
19:08:33 <pmetzger> why is it trying to install a *library* called crypt?
19:08:36 <pmetzger> there is also libcrypto
19:08:54 <NihilistDandy> pmetzger: It's not trying to install it, it's looking for it
19:09:01 <NihilistDandy> Some FFI thing, probably
19:09:22 <pmetzger> er, sorry, why is it trying to find a library called crypt
19:09:29 <pmetzger> there isn't one on os x to my knowledge
19:09:47 <pmetzger> there is a libcrypto
19:09:47 <dagit> pmetzger: It's trying to install Unixutils-1.36
19:09:56 <dagit> yes there is and i have that
19:10:46 <pmetzger> hang on, let me look at the cabal file.
19:11:09 <dagit> that cabal file is nothing special.  I'm sure it's an issue with my system
19:11:30 <pmetzger> I just looked at it.
19:12:37 <dagit> http://osdir.com/ml/xmonad@haskell.org/2010-10/msg00064.html
19:12:51 <pmetzger> I don't know much about the FFI...
19:13:13 <dagit> Well, when cabal sees the extra library it then looks around in the path
19:13:19 <dagit> But, there is no libcrypt.*
19:13:24 <pmetzger> how does it specify the library in which to find crypt(3)?
19:13:28 <pmetzger> because crypt(3) is in libc.
19:13:42 <dagit> So, then on osx it may not need to specify
19:14:14 <pmetzger> yes, but clearly it is specifying it somehow, and I don't know this system well enough.
19:14:19 <pmetzger> (cabal that is.)
19:14:40 <lispy> Hm...perhaps Unixutils is not ported to the mac
19:14:52 * lispy goes to ask in #snapframework
19:15:17 <pmetzger> it should not be hard to make this work though.
19:15:58 <pmetzger> I'm reading Crypt.hs, it does the right thing...
19:16:29 <pmetzger> I just don't understand how it specifies what libraries to link to.
19:18:53 <lispy> you list them in the cabal file
19:19:19 <NihilistDandy> The main issue seems to be that it asks for a lib that doesn't exist
19:19:25 <NihilistDandy> Yet people have managed to build successfully
19:19:29 <pmetzger> the cabal file doesn't seem to list "libcrypt"...
19:19:37 <lispy> it lists crypt
19:19:44 <pmetzger> oh, it does.
19:19:46 <pmetzger> just remove that
19:19:48 <pmetzger> it will work.
19:19:52 <pmetzger> I suspect.
19:19:57 <pmetzger> should I try it on my mac?
19:20:04 <pmetzger> or you want to try.
19:20:15 <pmetzger> you don't need libcrypt, crypt(3) is in libc, so it should just work.
19:20:43 <pmetzger> I wonder how I could have looked at the cabal file twice without seeing "crypt" in it when that is what I was looking for. I think that means it is bedtime for me.
19:20:44 <lispy> as I said before, I removed it but it still doesn't work because it next fails to find <shadow.h>
19:20:51 <pmetzger> oh, okay.
19:21:02 <pmetzger> so the deal there is the shadow password handling on linux vs. mac.
19:21:12 <NihilistDandy> Aha
19:21:21 <pmetzger> mac goes for the bsd paradigm
19:21:41 <pmetzger> except it is worse since on the mac most stuff isn't in the actual password file any more
19:21:43 <luite> http://jabberwock.xs4all.nl/exp/jquery-console/  <- I was wondering what you guys think is a good way to handle your own definitions in this kind of interface. you can enter for example  f x = 2*x, and it will remember, but the values of the other cells might depend on f
19:21:47 <pmetzger> it is in the database instead.
19:21:50 <NihilistDandy> So it's just not gonna build, then
19:21:59 <luite> should making definitions be separated from the worksheet?
19:22:10 <pmetzger> well, it should be trivial to make it work.
19:22:13 <pmetzger> lets see.
19:22:42 <pmetzger> so, lispy, which parts of the unix utils do you need anyway?
19:22:51 <pmetzger> all of it?
19:23:10 <lispy> I need whatever part snap depends on :)
19:24:30 <pmetzger> yah, this Shadow.hsc file really assumes the linux shadow system
19:24:46 <pmetzger> on the mac, ignoring the database, we have master.passwd
19:24:52 <pmetzger> which is in a different format
19:25:38 <Cale> luite: Yeah, I think that would be sensible. Have two kinds of cells, definition cells and expression evaluation cells.
19:25:49 <Cale> Also, this is rather cool :)
19:26:00 <lispy> pmetzger: I think it's fixed in the git repo version if I use macports to install a bunch of extra stuff
19:26:26 <luite> Cale: in the same worksheet, or a separate window?
19:26:26 <NihilistDandy> lispy: What extra stuff?
19:26:39 <lispy> libgcrypt gnutls
19:26:42 <pmetzger> Unixutils is clearly not going to compiler on a mac.
19:26:53 <pmetzger> the shadow support etc. just won't work.
19:27:00 <pmetzger> no matter what libraries one installs.
19:27:12 <Cale> luite: Either one would work reasonably well, but I think the same worksheet would be best. You could also have text/comment cells.
19:27:23 <NihilistDandy> lispy: Doesn't fix it, as far as I an tell
19:27:24 <NihilistDandy> *can
19:27:32 <NihilistDandy> I already brewed those ages ago, and I still get failures
19:27:40 <pmetzger> netinfo support is needed here
19:27:47 <pmetzger> without netinfo it isn't going to mean much.
19:28:11 <pmetzger> if snap doesn't need password file support, I'd just dike that out of Unixutils and build without it.
19:28:23 <lispy> good thing I'm installing virtual box while I try to debug this
19:28:48 <pmetzger> my guess is it probably doesn't require the password file support.
19:28:54 <pmetzger> I'd just dike it out and it will probably be fine.
19:29:20 <pmetzger> bedtime for me.
19:32:48 <luite> Cale: I'm not sure how to handle errors for definitions, if you change the type of one, and others depend on it, then no expression on the page could be evaluated, it uses a  let { defn1; defn2; defn3; defn4; } in expr internally, de definitions are only stored at the client (javascript)
19:33:30 <Cale> luite: Oh, I don't know how the actual details with javascript interaction are supposed to work.
19:33:36 <luite> if you add a definition, it evaluates let {defn1; defn2; ... ; defnNew } in (), if that typechecks it adds the definition
19:34:35 <Cale> I think the sensible thing to do would be to display an error related to the definition, and then treat it as if it weren't there when other cells get re-evaluated.
19:35:40 <luite> hmm that should be doable
19:35:49 <luite> I could just hold on to the last known good state
19:38:38 <Cale> Has anyone reddited this?
19:39:19 <luite> this site? no, but please don't :)
19:39:39 <Cale> oh, okay
19:39:42 <luite> I have to restart the interpreter manually every 10 minutes ore the images stop working
19:40:40 <Cale> What of this is done on the server side?
19:42:07 <luite> the server only has two types of results, a haskell expression response (json object) and images
19:42:32 <luite> the json object contains the result (Show), and its type
19:43:09 <luite> if the type is one of a few special types (Web.Image, Web.Interactive), the javascript does something special with the contents
19:43:33 <luite> otherwise it just shows the string (and runs MathJax to typeset it)
19:44:03 <luite> Web.Image contains width, height and the url of the image, so rendering the svg's is completely server side
19:44:33 <luite> Web.Interactive just contains a data structure describing the user interface
19:45:31 <luite> sierpinski / logo use diagrams with the cairo backend to make the svg's
19:45:37 <luite> tictactoe uses wumpus
19:46:15 <luite> wumpus can add javascript annotations to svg elements, and these use a callback with a new haskell expression, and the result replaces the original image
19:48:22 <nyingen> Enumeratee question: I'm not quite understanding what's meant by "outer" and "inner"
19:48:41 <nyingen> that section of the Yesod book's appendix on Enumerator was very confusing
19:49:18 <luite> Cale: you can make any expression interactive, for example: interactive "binom" [intSlider "n" 3 1 20]
19:53:09 <Axman6> nyingen: an enumerator is just something that maps the type of the data being eventually fed into an iteratee. so they usually have a type something like Enumerator iIn iOut m a, and that says is that it takes in a stream of iIn from an enumeratee and produces an stream of iOut to be fed to an iteratee
19:53:15 <Axman6> hmm, i may not have those terms correct
19:55:43 <nyingen> Axman6: so it's really more like 'input' and 'output' rather than inner/outer?
19:55:51 <nyingen> the docs consistently use inner/outer
19:55:55 <Axman6> i think so
19:56:11 <Axman6> yeah i never understood that terminology... but make sure what I've said makes sense
19:56:18 <nyingen> ok, I'll give it a shot
19:56:49 <nyingen> I'm trying to write an enumerator/enumeratee/iteratee combo that processes records from a text file
19:57:15 <nyingen> each record consists of a series of lines, beginning with a certain keyword and ending with a certain keyword
20:01:23 <applicative> wow, luite, fancy page!
20:02:52 <luite> applicative: were you able to defeat the mighty tic-tac-toe engine? I've spent ages manually tuning the evaluation funtion, consulting the leading tic-tac-toe experts in the process ;)
20:03:20 * applicative was going to see how it could do against his daughter, but she's asleep
20:03:40 * applicative is trying to find a combinator to make highlight3 go to town
20:04:04 * applicative discovered highlight2, but not by composition...
20:04:50 <applicative> MathJax is really pretty good, a bit slow, not too surprisingly
20:04:53 <luite> it uses wumpus to render highlight and tictactoe, because diagrams cannot add javascript event handlers to images
20:05:07 <luite> and diagrams for logo and sierpinski
20:05:57 <applicative> I remember the sierpinski example in diagrams
20:06:51 <applicative> how is the vacuum business done?  I can't remember what it naturally 'outputs'
20:06:52 <luite> it uses cairo, a native svg backend should fix it, but that would take a bit of work, converting fonts to svg etc
20:07:01 <luite> the vacuum-cairo package
20:07:09 <luite> which uses dot, I think
20:07:19 <luite> unfortunately that doesn't correctly report the image sice
20:07:20 <luite> size
20:07:59 <applicative> yes, I see, dot
20:09:05 <luite> it doesn't work in IE7 and lower
20:09:16 <luite> and IE8 has to use flash (svgweb) to render the svg's
20:09:21 <luite> which is extremely sluggy
20:10:52 <applicative> hm, vacuum, last uploaded to hackage August 2009
20:11:14 <luite> I might've needed to patch it a bit to make it work, don't remember :)
20:11:37 <applicative> Is this what 'mathematica
20:11:43 <applicative> is like? never had to do with it
20:11:52 <Guest3333> Why do i get a type error http://hpaste.org/46489/monadinstance ?
20:12:08 <KirinDave> I'm having a cabal install fail on building.
20:12:17 <KirinDave> Where do I look to diagnose why the build is failing?
20:12:53 <luite> applicative: the interface is somewhat inspired by it, but it's much more limited of course. I started two days ago to experiment with converting the terminal-like interface from tryhaskell to something more worksheet-like
20:13:09 <luite> so instead of only entering new expressions, you can edit and re-evaluate all expressions on the page
20:13:41 <luite> most of the graphics things were already done, but I added callbacks from graphics to the interpreter yesterday, and tictactoe as a demo :)
20:13:50 <c_wraith> Guest3333: on line 10, you're returning [a] where a is expected
20:14:50 <luite> applicative: oh you can add your own definitions by the way, but you can't see or remove them. I'm not sure how to handle that
20:14:57 <luite> especially errors
20:15:08 <luite> since editing one can cause errors all over the page
20:15:13 <Guest3333> but I can't i return [a] ?
20:15:35 <dagit> is there anything on hackage that does zdecoding?
20:15:43 <dagit> as in GHC's Core zencoding
20:16:01 <dagit> preflex: help
20:16:02 <preflex>  try 'help help' or see 'list' for available commands
20:16:05 <dagit> preflex: help help
20:16:05 <preflex>  help COMMAND - show help for a command
20:16:11 <dagit> preflex: version
20:16:12 <preflex>  5.169
20:16:15 <dagit> gah
20:16:16 <c_wraith> Guest3333: that's not what the type syas you're going to return.  It says you're going to return a single value of type a, not a list of them.
20:16:21 <dagit> Who wrote preflex?
20:16:54 <dagit> preflex: help list
20:16:55 <preflex>  list - show available plugins
20:16:59 <dagit> preflex: list
20:16:59 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
20:17:00 <preflex>  ZCode: [zdec, zenc]
20:17:51 <nyingen> zcode? as in z-machine?
20:18:06 <dagit> nyingen: no, it's the encoding that ghc uses for identifiers when it outputs core
20:18:16 <dagit> ZMZN = []
20:19:16 <dagit> preflex: zdec ZMZN
20:19:17 <preflex>  []
20:19:37 <nyingen> hmm
20:20:00 <dagit> ghc Foo.hs -fext-core && less Foo.hcr
20:20:05 <dagit> that's how you can see it
20:20:12 <nyingen> I see
20:21:37 <dagit> nyingen: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames
20:22:08 <nyingen> interesting
20:23:24 <applicative> c_wraith, Guest3333 's return type isn't the usual haskell one.  The problem is that it's returning ([a],String) rather than (a,String) as announced
20:23:24 <nyingen> Back to enumeratee...any idea how I should interpret the following line, from the Data.Enumerator docs?
20:23:35 <nyingen> "In cases where an enumerator acts as both a source and sink, the resulting type is named an Enumeratee. Enumeratees have two input types, “outer a” (aOut) and “inner a” (aIn). "
20:23:43 <nyingen> two input types?
20:24:22 <dagit> hmm
20:24:27 <dagit> that is odd
20:24:39 * applicative sees c_wraith was saying the same.
20:24:58 <nyingen> how can a pipe have two input types...
20:26:02 <applicative> obviously by one being the inner and the other outer....
20:27:30 <KirinDave> has anyone every successfully built the readline package on mac os x?
20:34:36 <applicative> KirinDave: not for a long time.  I see this in the complaint:  "checking for GNUreadline.framework"
20:35:07 <KirinDave> applicative: So I can get configure to run if I pass --with-readline-includes and --with-readline-libs to the ./configure in the package
20:35:53 <KirinDave> applicative: If I can get it past the runhaskell build part, how do I get cabal to install it?
20:36:13 <applicative> oh wait, it just looks for that 'framework' first.
20:36:38 <KirinDave> basically I need to pass configure some special options
20:36:52 <KirinDave> the config file doesn't seem to honor the usual libdir and incdir stuff
20:37:06 <KirinDave> How do I do that?
20:40:14 <applicative> you should be able to do 'runhaskell Setup install', and it will go to the usual place, your ~/.cabal/... if you specified --user
20:41:07 <applicative> KirinDave, which readline are you telling it to use, i feel like i have 20; only libiconv beats it
20:41:26 <KirinDave> applicative: I've got one from homebrew
20:41:35 <KirinDave> Which lives in the odd place /usr/local/Cellar/
20:42:58 <KirinDave> applicative: Thanks. The install step was what I was missing.
20:43:08 <KirinDave> I can't tell if cabal is insane or awesome yet.
20:43:29 <KirinDave> I am... thrice burned nine times shy after my experience with the supposedly "amazing" maven and ivy.
20:43:49 <monochrom> "runhaskell Setup install" doesn't do anything unless you "runhaskell Setup configure" and "runhaskell Setup build" first. and if you want --user you have to "runhaskell Setup configure --user" at the beginning
20:43:55 <KirinDave> Yeah
20:44:05 <KirinDave> What is --user?
20:44:32 <KirinDave> monochrom: I basically couldn't figure out how to get runhaskell Setup confgure to do the right thing. I had to use configure directly.
20:44:37 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for what is --user and --global
20:45:56 <monochrom> ghc keeps two package lists and unions them. one is "global", one is "user"
20:51:40 <applicative> KirinDave, I think connecting with readline is a perennial nightmare on os x; they have their own version. Homebrew sort of hides theirs; it isn't symlinked in /usr/local
20:53:13 <KirinDave> applicative: Indeed. Anyways, i got it all working. I just wish I knew how to get `cabal install` to take arbitrary configuration parameters.
20:59:39 <applicative> man, the configure script is 4000 lines long.
21:03:26 <applicative> KirinDave: I see it hasn't been updated forever.  What do you need readline (hs) for?
21:03:48 <KirinDave> applicative: I'd... like to use readline?
21:04:30 <applicative> I think its position has been taken up by haskeline, maybe
21:06:10 <KirinDave> applicative: is that the case?
21:06:30 * hackagebot zenc 0.1.1 - GHC style name Z-encoding and Z-decoding  http://hackage.haskell.org/package/zenc-0.1.1 (JasonDagit)
21:07:35 <_Ray_> They're in a maze, they don't need no stinkin' command recollection - they need a flashlight!
21:07:54 <dagit> monochrom: do you know who runs preflex?
21:08:07 <applicative> haskeline is still maintained, uploaded recently, etc
21:08:26 <djahandarie> dagit, mauke does
21:08:33 <geheimdienst> dagit: it might be mauke, but i guess he'll not be here now
21:08:38 <geheimdienst> (it's 6am in germany)
21:08:52 <djahandarie> preflex, seen mauke
21:08:52 <preflex>  mauke was last seen on #haskell 4 hours, 13 minutes and 24 seconds ago, saying: aristid: the question was ambiguous
21:09:02 <djahandarie> Especially since he was up at 2am
21:11:11 <applicative> KirinDave, but I think the last time I tried to build haskeline ... libiconv reared its ugly head.
21:11:21 <KirinDave> Dun dun dunn :)
21:15:18 <dagit> ?tell mauke I couldn't find a zenc library on hackage for preflex's z-encode/z-decode feature so I took the source from ghc and put it on hackage/github as a separate package incase you want to use it: http://hackage.haskell.org/package/zenc git://github.com/dagit/zenc.git
21:15:18 <lambdabot> Consider it noted.
21:15:27 <applicative> KirinDave, I just installed it with the homebrew libiconv, cabal install --extra-lib-dirs=/usr/local/Cellar/libiconv/1.13.1/lib --extra-include-dirs=/usr/local/Cellar/libiconv/1.13.1/include
21:15:47 <applicative> I'll see if i can use it without disaster
21:16:31 <KirinDave> The readline package didn't obey those options
21:16:36 <KirinDave> Maybe hackalien actually fixed that
21:17:23 <applicative> forget it: Undefined symbols (maybe you meant: _h_iconv, _hs_iconv_open , _h_iconv_close , _haskelinezm0zi6zi4zi0_SystemziConsoleziHaskelineziBackendziIConv_iconvzuclose_closure
21:17:38 <KirinDave> I just got readline to work.
21:21:40 <applicative> oh, well there you are then.  Haskeline worked when I used this libiconv:  cabal install --extra-include-dirs=/Developer/SDKs/MacOSX10.6.sdk/usr/include --extra-lib-dirs=/Developer/SDKs/MacOSX10.6.sdk/usr/lib
21:22:24 <Axman6> huh, that shouldn’t be needed, everything in those dirs should already be in /usr/include and /usr/lib
21:22:54 <applicative> its libiconv, Axman6, all reasoning goes out the window :)
21:23:01 <Axman6> heh
21:25:43 * ddarius stumbles across the paper he thinks he needs.
21:27:08 <applicative> Axman6, I'm not seeing that, just following around the symlinking.  In any case I was admittedly grasping at straws
21:27:26 <Axman6> heh, fair enough
21:28:24 <KirinDave> I really cannot believe how awesome and helpful everyone in #haskell has been in the face of my constant inane questions.
21:29:21 <Axman6> it's what we're here for
21:33:33 * hackagebot maude 0.1.3 - An interface to the Maude rewriting system.  http://hackage.haskell.org/package/maude-0.1.3 (DavidLazar)
21:38:23 <napping> Is there any way to compute case alternatives?
21:38:54 <napping> I suppose there's TH
21:39:21 <napping> For deserializing some data, I've read a tag code, and then have a case with alternatives like 3 -> tag Con
21:39:48 <napping> where each Con has a type String -> a -> R, with Binary a
21:40:17 <napping> It would be nice if the deserialization code was similarly compact
22:03:43 * hackagebot data-pprint 0.2 - Prettyprint and compare Data values  http://hackage.haskell.org/package/data-pprint-0.2 (PeterDivianszky)
22:05:43 * hackagebot dia-base 0.1 - An EDSL for teaching Haskell with diagrams - data types  http://hackage.haskell.org/package/dia-base-0.1 (PeterDivianszky)
22:06:43 * hackagebot dia-functions 0.1 - An EDSL for teaching Haskell with diagrams - functions  http://hackage.haskell.org/package/dia-functions-0.1 (PeterDivianszky)
22:11:54 <ddarius> This paper is filled with crazy notation.
22:14:59 <ddarius> This just gets crazier.
22:17:50 <KirinDave> Is there a good library for wrapping text?
22:18:41 <nyingen> wrapping in what way?
22:19:16 <KirinDave> Like just taking a bunch of text and breaking it to 80col format
22:20:00 <dagit> KirinDave: the pretty printer library has a render function
22:20:10 <dagit> KirinDave: http://hackage.haskell.org/packages/archive/pretty/1.0.1.0/doc/html/Text-PrettyPrint-HughesPJ.html
22:20:18 <KirinDave> Cool.
22:20:59 <dagit> KirinDave: I really don't know what it would do if you fed it a huge string via text
22:21:09 <KirinDave> THe strings are not huge at all
22:21:10 <dagit> KirinDave: but, maybe it can be told to do the right thing :)
22:21:45 <dmwit> I have written a wrapping function before.
22:22:03 <dmwit> Here we go.
22:22:28 <dmwit> http://hpaste.org/46492/text_wrap
22:23:07 <dmwit> It doesn't preserve multispaces, though.
22:23:23 <dmwit> So (wrap 80 "a    b" = ["a b"])
22:24:46 <KirinDave> clever function
22:45:03 <paolino> @seen rst
22:45:03 <lambdabot> Unknown command, try @list
22:45:03 <preflex>  rst was last seen on ##c++ 1 year, 289 days, 17 hours, 2 minutes and 29 seconds ago, saying: hi
