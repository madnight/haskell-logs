00:05:47 <dmwit> KirinDave: Your question was too fun, I had to try it myself: http://hpaste.org/47253/for_the_horde
00:08:08 <dmwit> whoops
00:08:34 <dmwit> s/Response -> IO ()/Query -> IO ()/ in the type of "respond"
00:12:09 <adnam> pro tip: don't type @arr instead of @hoogle arr
00:12:17 <ddarius> @arr
00:12:18 <lambdabot> Shiver me timbers!
00:12:28 <ddarius> @yarr
00:12:28 <lambdabot> Arr! Me ship be the biggest brig in the port!
00:12:48 <shachaf> @arrow
00:12:48 <lambdabot> Arrr!
00:14:07 <Cale> http://en.wikipedia.org/wiki/File:GG_Allin_Grave.jpg -- this gravestone reads entirely differently to a starcraft player
00:14:33 <adnam> :-DD
00:14:38 <dmwit> gg
00:14:38 <cmccann> ggnore
00:15:08 <adnam> less arrows and more esports please
00:37:25 <spirit> how would i go about replacing all occurrences of "\n" with "\\n" in a string?
00:38:44 <shachaf> s >>= (\x -> case x of '\n' -> "\\n"; c -> [c])
00:39:02 <shachaf> spirit: But that looks like a very suspicious thing to do.
00:39:51 <spirit> i'm writing out a .dot file and i want to allow for \n in node labels
00:40:09 <shachaf> You probably want a more general escaping mechanism, then.
00:40:24 <shachaf> Escaping is always something to be careful about.
00:40:29 <spirit> yes
00:40:55 <spirit> would be nice to escape \t too
00:41:00 <spirit> any ideas?
00:41:04 <ddarius> show
00:41:41 <shachaf> show will escape things Haskell-style, which probably differs a bit from dot-style, but will work as a first approximation.
00:42:15 <spirit> it'll also add \" to beginning and end, won't it?
00:44:56 <spirit> i don't want the \" and \" around the strings really.
00:47:54 <ddarius> It's easy enough to remove those.
00:51:01 <spirit> how?
00:51:19 <ddarius> init . tail
00:51:41 <ivanm> spirit: don't do it by hand!
00:51:57 <ivanm> there are enough damn Graphviz bindings on hackage as it is for you to do it by hand!
00:53:36 <spirit> i produce dot files, i don't have them as input format. i thought it's ok to do that by hand.
00:53:46 <ivanm> hell no!
00:54:13 <ivanm> spirit: do you know how long I spent finding out all the escaping rules for graphviz by _hand_ for the most part?
00:54:23 <paris> Hi look http://lesnanasencavale.forumgratuit.fr/
00:54:24 <ivanm> all the tricky little formatting details, etc.
00:55:01 <spirit> thanks for letting me know!
00:55:56 <spirit> init . tail "\"test\"" doesn't seem to work. what am i doing wrong?
00:56:17 <ivanm> > init . tail $ show "hi"
00:56:19 <lambdabot>   "hi"
00:56:56 <spirit> ah - :-)
00:57:20 <spirit> the link to the french page paris posted i did not get. must have been for someone else. not on haskell i think.
00:57:25 <ivanm> spirit: there is graphviz, dotgen, language-dot, etc.
00:57:46 <spirit> cool! will pull those in by the end of the week
00:57:54 <spirit> have to have something ready for tomorrow though
00:57:57 <ddarius> Holy Christ.
00:58:02 <spirit> so short cut now
00:58:38 <ivanm> ddarius: what?
00:58:42 <paris> Hi look http://lesnanasencavale.forumgratuit.fr/
00:58:58 <shachaf> @context ddarius
00:58:58 <spirit> paris, what's that about?
00:58:58 <lambdabot> Unknown command, try @list
01:02:31 <accel> is there a short hand for :
01:02:35 <accel> y <- blah blah blah
01:02:37 <accel> case y of ....
01:02:43 <ivanm> accel: no
01:02:48 <ivanm> but many of us wish there was
01:02:55 <accel> so I'm not necessairly a crazy fool
01:03:51 <ivanm> > sortBy (compare `on` fst) [(1,'a'), (1, 'a')]
01:03:52 <lambdabot>   [(1,'a'),(1,'a')]
01:03:55 <ivanm> > sortBy (compare `on` fst) [(1,'a'), (1, 'b')]
01:03:56 <lambdabot>   [(1,'a'),(1,'b')]
01:04:45 <ddarius> I believe sortBy is required (perhaps implicitly) to be stable.
01:05:16 <ivanm> yeah, I thought it was, just wanted to double-check
01:05:30 <ivanm> since I rely upon that behaviour
01:05:32 <accel> is there somethign like "system", except I can get the stderr/stdout as a string?
01:05:56 <ivanm> accel: yes: runInteractiveProcess, etc.
01:06:01 <ivanm> @hoogle runInteractiveProcess
01:06:01 <lambdabot> No results found
01:06:04 <ivanm> bah
01:06:08 <ivanm> @hoogle process
01:06:08 <lambdabot> System.Posix.Types type ProcessGroupID = CPid
01:06:08 <lambdabot> System.Posix.Types type ProcessID = CPid
01:06:21 <ivanm> accel: look in System.Process
01:06:25 <spirit> wow -- "\\n" seems to do the same as "\n" in my .dot files -- doesn't do the trick :-/
01:06:25 <accel> ivanm: any more random strings to search for? :-)
01:06:39 <ivanm> spirit: what are you trying to do?
01:06:54 <accel> runProcess
01:06:56 <accel> except it's kinda messy
01:07:04 <accel> runInteractiveCommand
01:07:07 <spirit> i allow \n in my node labels and now it turns out it's not a good idea dot-wise
01:07:07 <ivanm> spirit: that should have the literal string "\n"
01:07:16 <accel> hmm, there's actualy runInteractiveProcess too
01:07:21 <accel> @hoogle runInteractiveCommand
01:07:21 <lambdabot> No results found
01:07:25 <accel> @hoogle runInteractiveProcess
01:07:25 <lambdabot> No results found
01:07:33 * accel hits lambdabot
01:07:37 <ivanm> accel: I know there is; I use it!
01:07:48 <ivanm> I guess that since it's now in process lambdabot's hoogle doesn't have it indexed
01:07:59 <accel> even simpler
01:08:00 <accel> readProcess
01:08:07 <accel> and readProcessWithExitCode
01:08:17 <ivanm> yeah, depends upon what you want
01:08:38 <spirit> i try to escape stuff with init . tail $ show... but i'm also using map twice:
01:08:39 <spirit> map (init . tail $ show) (map mergeNodeLabel nodeList)
01:09:16 <spirit> is there a problem in the line that's stopping haskell from escaping the strings?
01:09:31 <ivanm> spirit: that doesn't get rid of \n ...
01:09:32 <shachaf> Yes -- (init . tail $ show) doesn't make any sense.
01:09:37 <shachaf> Can you see why? :-)
01:09:43 <ivanm> and as shachaf says, it doesn't type-check
01:09:52 <ivanm> also, it won't get rid of \n characters...
01:10:00 <ivanm> > init . tail $ show "\n"
01:10:02 <lambdabot>   "\\n"
01:10:03 <accel> Constructing variants of these functions is quite easy: follow the link to the source code to see how readProcess is implemented.
01:10:07 <ivanm> oh, it does! :o
01:10:08 <shachaf> ivanm: I said it doesn't *sense*-check.
01:10:17 <accel> that is the most friendly RTFM I have seen in a documentation page
01:10:22 <spirit> it doesn't seem to work though
01:10:31 <ivanm> @type init . tail $ show
01:10:32 <lambdabot>     Couldn't match expected type `[a]'
01:10:32 <lambdabot>            against inferred type `a1 -> String'
01:10:32 <lambdabot>     In the second argument of `($)', namely `show'
01:10:43 <ivanm> shachaf: well, yeah, but it also doesn't type-check!
01:10:50 <ivanm> accel: heh
01:11:02 <ivanm> accel: IIRC, the code there is rather good though
01:12:20 <shachaf> > init . tail $ sh–æw
01:12:22 <lambdabot>   "ivanm"
01:13:02 <spirit> o dear -- my leksah has stopped to build on the fly, it doesn't even compile as it stands :-)
01:13:31 <ivanm> @type show
01:13:32 <lambdabot> forall a. (Show a) => a -> String
01:13:46 <ivanm> shachaf: OK, how are you controlling lambdabot?
01:14:00 <shachaf> ivanm: It's the BBC controlling us from London
01:14:09 <ivanm> _riiiiiight_
01:14:12 <shachaf> Grr.
01:14:18 <shachaf> *Actually*, it's the BBC controlling us from London
01:14:21 <ivanm> preflex: slap shachaf
01:14:44 <spirit> map (init . tail ) (map show (...)) seems to do the trick
01:14:51 <shachaf> preflex: slap ivanm
01:14:59 <ivanm> spirit: I'm guessing you don't know much Haskell?
01:15:02 <lambdabot> no, i'll do it!
01:15:12 <ivanm> shachaf: grrrr.....
01:15:20 * lambdabot pokes ivanm right in the feelings
01:15:37 <shachaf> @vixen Aw, that was a little excessive.
01:15:38 <lambdabot> yeah?
01:16:01 <Egbert9e9> gtk2hs using glade throws something like "Expected <glade-interface>. Got <interface>"
01:16:19 <spirit> not much, but is it ok now?
01:16:45 <ivanm> @slap sha—Åhaf
01:16:45 * lambdabot locks up sha—Åhaf in a Monad
01:16:55 <ivanm> spirit: it works, but isn't the best way of doing it...
01:17:01 <ivanm> @type (>)
01:17:02 <lambdabot> forall a. (Ord a) => a -> a -> Bool
01:17:04 <Egbert9e9> anyone has a clue to why this is happening
01:17:04 <ivanm> gah!
01:17:05 <Egbert9e9> ?
01:17:08 <ivanm> @type (.)
01:17:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:17:27 <ivanm> Egbert9e9: is the glade file being loaded properly?
01:17:30 <spirit> what's better then?
01:17:38 * ivanm hasn't really used gtk2hs
01:17:45 <Egbert9e9> hmmm.. maybe? let me see
01:17:48 <ivanm> spirit: map (f . g . h . foo . bar)
01:18:21 <spirit> well, more beauty there than in what i had come up with :-) cheers!!!
01:19:30 <Egbert9e9> i think it is loaded properly
01:22:24 <isomorphic> can anybody recommend a good way of stripping html tags out in haskell?
01:23:15 <dcoutts> isomorphic: tagsoup
01:24:05 <Egbert9e9> oh, saved it as a libglade and not gtkbuilder project
01:24:09 <Egbert9e9> now it works
01:24:18 <Egbert9e9> saved the glade layout file
01:24:28 <ivanm> hey dcoutts
01:24:34 <dcoutts> @arr!
01:24:34 <lambdabot> Ahoy mateys
01:24:59 <Egbert9e9> wow, i wrote, using the gtk2hs glade tutorial, a gui hello world
01:29:30 <Egbert9e9> hmmm
01:29:59 <Egbert9e9> now we're finally reaching the realms of multitasking
01:30:49 <Egbert9e9> my download IO () code is.. how do you call it? blocking?
01:31:03 <cch> which module should I import to make bytestring as an instance of IsString ?
01:31:14 <Egbert9e9> so i can't really use it inside a GUI app, right?
01:31:49 <cch> seems that it doesn't work to just import Data.ByteString
01:33:36 <ivanm> cch: the Char8 version
01:33:54 <cch> oh, thanks
01:34:45 <spirit> apologies for asking about dot, but what characters are allowed in identifiers/labels? just realised '_' seems to be an issue too
01:36:43 * ivanm points spirit to his graphviz package
01:37:31 <spirit> is there a way of escaping loads (as i requested before) but not escaping "?
01:38:05 <ivanm> yes: use a library that does it all for you
01:38:17 <spirit> graphviz?
01:38:21 <ivanm> yup
01:38:23 <ivanm> @hackage graphviz
01:38:24 <lambdabot> http://hackage.haskell.org/package/graphviz
01:39:45 <spirit> so i am looking for a function like parseEscaped ?
01:41:06 <ivanm> no, you're looking at how to actually use that library rather than trying to roll your own
01:41:24 <ivanm> read the source of dotGraph in Data.GraphViz to get an idea
01:41:42 <spirit> i'm incredibly short of time this week, the library seems large
01:41:59 <ivanm> you don't have to use all of it
01:42:31 <spirit> 1_1->2_3 is a valid edge identifier?
01:42:36 <spirit> it parses?
01:42:47 <spirit> i think i might only have trouble with labels
01:43:15 <spirit> i meant 1_1 valid node identifier
01:43:16 <ivanm> ummmm.... don't recall if 1_1 is valid
01:43:30 <ivanm> I have the sneaking suspicion that it might not be as it starts with a numeral
01:43:39 <ivanm> and I think it either has to be a number or start as a non-numeral
01:43:41 <spirit> but 1 is valid
01:43:45 <ivanm> yes
01:43:51 <spirit> o dear
01:43:53 <ivanm> s/as/with/
01:44:08 <spirit> what function for the label cleanup?
01:44:42 <ivanm> spirit: but "1_1" is valid
01:45:11 <ivanm> spirit: the listToDot definition for Char
01:45:58 <spirit> i get a warning, 8_ splits into two names and therefore is ambiguous :-/ so maybe you're right about the identifiers after all
01:46:38 <ivanm> of course I'm right!
01:47:04 <ivanm> spirit: http://graphviz.org/content/dot-language
01:47:13 <spirit> how can it be valid but ambiguous -- i mean it's not good enough then i guess
01:48:16 <Egbert9e9> any advice on how to write non-blocking code?
01:53:02 <ClaudiusMaximus> Egbert9e9: forkIO, postGUISync, postGUIASync
01:53:59 <ClaudiusMaximus> Egbert9e9: http://hackage.haskell.org/packages/archive/gtk/latest/doc/html/Graphics-UI-Gtk-General-General.html#g:1
01:55:55 <Egbert9e9> ClaudiusMaximus: thanks!
02:02:08 <spirit> what is DotCode?
02:03:04 <spirit> i'm only using haskell in an intermedaite step -- an exe i call from c++. i'm not rendering from inside haskell. i rather need a string .dot representation i pass onto c++.
02:06:40 <notyy> hello,anybody use wxHaskell? I am newbie,and trying to create a small timer app,but have a layout problem now.
02:07:27 <notyy> http://hpaste.org/47256/strange_textentry  [clientSize] seems work on button control,but doesn't affact textEntry
02:08:52 <spirit> how to unescape escaped quotes? "\"" >>> """ ?
02:10:21 <Lemmih> spirit: What?
02:10:45 <ivanm> spirit: DotCode is a type alias for Doc
02:11:04 <spirit> and Doc is not a string?
02:11:12 <ivanm> no
02:11:26 <ivanm> spirit: it isn't that hard to use graphviz
02:11:35 <spirit> i only need to unescape espcaped quotes for now
02:11:36 <ivanm> as long as you know which Attributes you want to use
02:12:03 * hackagebot ipprint 0.4.1 - Tiny helper for pretty-printing values in ghci console  http://hackage.haskell.org/package/ipprint-0.4.1 (GlebAlexeyev)
02:12:09 <spirit> i'll use it from the end of this week. today isn't good to change lots of code (lack of time)
02:12:48 <aninhumer> spirit: You want a string containing \" ?
02:13:24 <spirit> i have strings like this: "\"blah\"" and i need to change them to ""blah""
02:14:50 <frerich> spirit: Assuming you escape backslahes using backslashes, too, maybe something like http://hpaste.org/47257/unescape works
02:15:09 <frerich> spirit: Disclaimer: I'm just a Haskell beginner and used this little opporturnity to write a small function :-)
02:15:46 <aninhumer> spirit: So the string would have been constructed with "\\"blah\\""?
02:16:00 <spirit> no
02:16:06 <spirit> "\"blah\""
02:16:14 <spirit> only one backslash
02:16:39 <aninhumer> If you use the string literal "\"blah\"" it will result in ""blah""
02:16:52 <Lemmih> spirit: We need more context.
02:17:36 <spirit> at the moment i want special characters properly escaped, i therefore map show to my list of strings
02:17:55 <spirit> unfortunately show also escapes """ which i want to hang on to
02:18:29 <spirit> great it transforms "\n" to "\\n" but not so great it transforms """ to "\""
02:18:58 <Lemmih> spirit: Write a custom escaping function.
02:19:09 <spirit> you're saying it's "\\"" not "\""?
02:20:23 <spirit> why not use show and then unescape the ones i don't want to have escaped?
02:20:32 <spirit> like frerich did?
02:21:44 <aninhumer> Hmm I had no idea show did that to strings
02:22:06 <Lemmih> spirit: I would consider it bad style. You don't actually want 'show' and patching it so it works is usually a bad idea.
02:22:18 <aninhumer> I assumed show didn't do anything to strings
02:22:35 <Lemmih> spirit: What you want is custom escaping.
02:22:49 <spirit> what about all the cases?
02:22:55 <spirit> i need to consider?
02:23:26 <Lemmih> spirit: There are a bunch of functions in Data.Char that can help.
02:24:03 <ior3k> hey all
02:24:05 <Lemmih> spirit: You can specify which characters should or should not be escaped using 'isPrint', 'isAlphaNum' and the likes.
02:24:34 <spirit> i don't have time to look into it today, but i do need working code :-/
02:24:53 <accel> I want a function like lines, but instead of splitting on "\n", to split on "\\"; after searching on Hoogle, the closest thing looks like splitRegex (since I want String -> [String]). Is there something faster?
02:25:19 <Lemmih> spirit: You could also just say "fuck it" and just drop the first and last character after you call 'show'.
02:25:51 <ior3k> please forgive me for the slight digression: I'm currently learning Haskell, and think it's a brilliant language, but coming from a dynamic language background (ruby, lisp) I worry that I may lose some power when programming in haskell
02:26:00 <Lemmih> accel: There's Data.List.Split
02:26:11 <ior3k> for example, in ruby, calling obj.send("method_name") will call obj.method_name
02:26:20 <spirit> it would be the first and last character of each list element. have used the take/drop work around already i have to admit :-/
02:26:40 <ior3k> anyone here coming from a similar background, who still prefers haskell?
02:27:13 <blackdog> ior3k: i guess i'd qualify there
02:27:23 <blackdog> ruby is my day job, and i'm the author of the ruby-haskell bridge
02:27:59 <Lemmih> ior3k: Static typing, algebraic data types and higher order functions more than make up for that, imo.
02:28:04 <blackdog> if you're worried about theoretical power, i'd read don stewart's PhD thesis - he goes into how you architect systems in haskell for plugin
02:28:07 <blackdog> s
02:28:29 <blackdog> when you really need introspection, packages like HINT are pretty good
02:28:41 <ivanm> spirit: when you print it, the slashes will disappear
02:28:47 <blackdog> but in general, i think runtime metaprogramming in ruby is massively overused
02:28:52 <ivanm> as in: putStrLn "\"hello\""
02:29:26 <blackdog> don't get me wrong, i use activerecord as much as anyone, but if there was a similar package where i could have a static guarantee about methods at the cost of uglier syntax, i'd take it every time.
02:29:56 <spirit> @print "\"blah\""
02:29:56 <lambdabot> Not enough privileges
02:29:59 <ior3k> blackdog: I don't know, in my experience, I find types don't really buy me much
02:30:02 <spirit> o dear :-/
02:30:10 * blackdog feels slightly weird advocating haskell in #haskell. usually i'm trolling ivanm:)
02:30:18 <blackdog> ior3k: what type systems have you used?
02:30:20 <ivanm> heh
02:30:25 <ivanm> spirit: on your machine!
02:30:33 <ivanm> spirit: don't use print; print will re-escape everything again
02:30:36 <ivanm> use putStrLn
02:30:42 <ivanm> (or putStr)
02:30:59 <spirit> wow :-)
02:31:01 <ior3k> blackdog: well, mostly Java, but I find that in ruby I don't have many type related errors. Plus I use TDD so even if I get any problems, they're fixed quickly
02:31:29 <blackdog> ior3k: ok. java's type system is very, very limited.
02:31:39 <blackdog> the point of haskell is to expand what you think of as a type error
02:32:07 <blackdog> for instance, if you've ever passed a block to a function that wasn't expecting one, or vice versa: in haskell, that's a type error.
02:32:22 <frerich> spirit: I played a bit some more, try http://hpaste.org/47259/escape__unescape
02:32:23 <blackdog> ior3k: the ideal is to make invalid states non-representable
02:32:39 <blackdog> and if you've ever used one of the many, many state-machine packages in ruby, you've done the same.
02:32:43 <spirit> using print leaves me with IO -- i need String
02:32:56 <frerich> spirit: The 'spirit' functions at the bottom are examples of using the 'escape/unescape/ functions for your case,  defining an escape character (e.g. \) and a list of special characters to escape (e.g. ")
02:33:05 * hackagebot dtd-types 0.0.0.1 - Basic types for representing XML DTDs  http://hackage.haskell.org/package/dtd-types-0.0.0.1 (YitzGale)
02:34:42 <spirit> cheers, frerich
02:34:47 <ior3k> blackdog: true... I guess types are a big help with documentation, which is important, but I worry that, for example, I'll more often need to code long case statements when a simple send(...) would do the trick
02:35:04 <frerich> spirit: Again, I'm just a HAskell beginner, I won't guarantee anything :-)
02:35:22 <ior3k> or that I'll have to write more boilerplate code because I can't just "generate" that code using metaprogramming
02:35:46 <spirit> yeah, i'd rather use shorter code for now, as i'm short of time
02:36:05 <blackdog> ior3k: i find haskell code tends to be shorter than ruby, not longer.
02:36:25 <ion> blackdog: Indeed.
02:36:30 <ior3k> interesting
02:36:35 <ior3k> why is that?
02:36:55 <blackdog> ior3k: the moral equivalent of 'send' in haskell would be to define a typeclass encapsulating that operation. you can then provide implementations for a range of different types.
02:37:29 <blackdog> generally, it's easier to build up complex combinations out of general pieces, because the compiler will tell you when you've screwed up.
02:37:43 <ior3k> blackdog: let me give you a specific example:
02:37:56 <blackdog> so you abstract further. Monads and applicative functors are both examples of this.
02:38:09 <blackdog> one caveat: simple things may be simpler in ruby than in haskell.
02:38:10 <frerich> Hm, do you people use 'type' a lot. I noticed that I tend to introduce a new type name whenever I feel the urge to comment on the semantic of some argument
02:38:34 <ior3k> blackdog: let's say I want to call a certain callback method based on a method's parameter
02:38:38 <blackdog> frerich: you get more safety from newtype:)
02:39:12 <ior3k> let's say the callbacks are named in a way that I just need to prepend "on_" to the parameter value
02:39:22 <ddarius> Oh god
02:39:23 <ior3k> so that I just call send("on_#{val}")
02:39:30 <aninhumer> blackdog: Wouldn't you have to derive/reimplement a load of stuff potentially then?
02:40:01 <aninhumer> Which if you just want semantic hints, is a bit overkill, but I see your point
02:40:02 <blackdog> aninhumer: if you're going to have to derive/reimplement everything, then it wasn't really a separate type anyway..
02:40:16 * blackdog is getting really opinionated tonight:)
02:40:18 <ion> ior3k: Count into the amount of code the unit tests you need to do for all the ways that can fail in runtime when you don‚Äôt have the static checking Haskell does.
02:41:01 <blackdog> ior3k: you'd probably have a lookup table for that if it was closed, and a typeclass if it wasn't
02:41:09 <ior3k> ion: won't you have to write unit tests for haskell anyhow? I find I don't really write many tests to check for type safety
02:41:22 <blackdog> but you'd need to be more specific about the details of what you're actually trying to accomplish.
02:41:23 <ddarius> blackdog: Why would a lookup table require it to be closed?
02:41:46 <ddarius> blackdog: My first reaction would be to have a map from strings to callbacks.
02:41:51 <aninhumer> blackdog: What about e.g. some kind of Metre/ Feet types, they're both Num, but you want to avoid confusing them
02:41:53 <blackdog> ddarius: was thinking of a lookup table in the code itself. of course, if you were loading it from elsewhere it could be open.
02:42:16 <aninhumer> Or more abstractly, they're both Distance
02:42:53 <ddarius> (Admittedly, objects in Ruby are little more than dictionaries anyway, so this abuse isn't that unreasonable.)
02:43:08 <blackdog> aninhumer: maybe look at dimensional
02:43:18 <aninhumer> blackdog: I know, I was just giving an example
02:43:40 <blackdog> aninhumer: sure. but the point there is that you get a better solution using slightly heavier type machinery.
02:43:41 <ddarius> aninhumer: There are ways of sharing the code while having different types.
02:44:16 <blackdog> ior3k: you do need to write tests for haskell, but not as many, usually. the type system also helps you write better tests - have you seen quickcheck?
02:44:34 <ior3k> blackdog: no I haven't
02:45:17 <ddarius> (Admittedly, as well, I'd question this mapping of strings to "callbacks" also.)
02:45:21 <blackdog> worth checking out. makes it easy to generate random values of a particular type and define properties over them that should always hold
02:45:26 <ion> > check (\xs ys -> reverse xs ++ reverse ys == reverse (xs ++ ys)) --whoops, a bug
02:45:26 <lambdabot>   Not in scope: `check'
02:45:32 <ion> @check (\xs ys -> reverse xs ++ reverse ys == reverse (xs ++ ys)) --whoops, a bug
02:45:33 <lambdabot>   "OK, passed 500 tests."
02:45:58 <ddarius> ion: Try with more typiness.
02:45:58 <ion> @check (\xs ys -> reverse (xs :: [Integer]) ++ reverse ys == reverse (xs ++ ys)) --Whoops, a bug. Really. :-P
02:45:59 <lambdabot>   "Falsifiable, after 0 tests:\n[1,3]\n[2]\n"
02:46:07 <dafis> ion: that defaults to [()]
02:46:09 <ion> @check (\xs ys -> reverse (xs :: [Integer]) ++ reverse ys == reverse (ys ++ xs)) --fixed
02:46:09 <lambdabot>   "OK, passed 500 tests."
02:46:57 <blackdog> ha. so that was comparing [(),(),()...] to [(),(),(),..] ?
02:47:02 <ion> yeah
02:47:10 <dafis> the first one, without type, yes
02:47:23 <ior3k> ddarius: "(Admittedly, as well, I'd question this mapping of strings to "callbacks" also.)"
02:47:26 <ior3k> care to elaborate?
02:47:48 <ion> ior3k: That‚Äôs QuickCheck. ‚Üë
02:47:50 <blackdog> ior3k: you can't statically say that an incoming call is wrong in that case
02:48:55 <ior3k> blackdog: meaning, the dynamic implementation is less "safe", is that it?
02:49:03 <blackdog> ior3k: yes
02:49:22 <blackdog> and unnecessarily so
02:51:20 <ivanm> if I have a class like "class Foo v where type Value v; toList :: v -> [Value v]", how can I create an instant where (Value v) can be any Monoid ?
02:51:43 <ior3k> blackdog: ok, I see your point... maybe trading safety for speed will end up not gaining me much in the long run
02:52:05 <blackdog> ior3k: you mean speed of development?
02:52:10 <ior3k> blackdog: yes
02:52:38 <blackdog> right. well, arguably you wouldn't even trade that once you understand haskell idioms, but it takes a while to get to that point.
02:53:00 <ion> My point was that you need a bunch of unit tests to account for the lack of type checking, potentially losing rather than winning in development time.
02:53:42 <ior3k> it does appear dynamic language people may opt for the apparently "pragmatic" at the expense of the "provably correct"
02:53:48 <ior3k> which may or may not be important
02:54:02 <ior3k> and on the other hand, like ion said, maybe that perception is wrong, really
02:54:40 <ion> Getting much more safety from the code out of the box is quite pragmatic.
02:54:51 <ior3k> ion: yeah, but doesn't feel like it :)
02:55:18 <ior3k> maybe my experience with Java influences that
02:55:22 <ion> That feeling is just a matter of what you have experience with.
02:55:53 <blackdog> ior3k: in pragmatic terms, then: building websites in ruby is going to be easier than in haskell for a while. the whole web ecosystem around ruby is enviable. haskell will get there, but it's not there yet.
02:56:18 <ior3k> we need a heroku for haskell :)
02:57:03 <blackdog> ior3k: yes:) have talked to the yesod guys about it, but it's a bigger project than i'm willing to tackle right now.
02:57:40 <ior3k> well, I'll definitely stick with Haskell some more... there's too much goodness here, and I don't see myself dropping xmonad anytime soon, anyway
02:58:16 <ior3k> crazy as it may seem, I'm trying to write my scripts in Haskell too... always hated shell scripts, anyway
02:58:34 <ior3k> and it's a way to force me to learn the language some more
02:59:13 <ion> Nothing crazy about that.
03:00:39 <blackdog> ior3k: it's an interesting idea. seen hsh?
03:01:00 <ior3k> blackdog: no :) but thanks for the pointer, I'll investigate
03:04:38 <ivanm> what's wrong with this instance declaration that ghci wants flexibleinstances? instance (Monoid n, Monoid e) => PlanarEncoding PlanarCode n e where
03:04:45 <ivanm> is it the monoid constraints?
03:05:13 <dafis> ivanm: no type constructors
03:05:35 <dafis> (applied to n and e)
03:06:16 <ivanm> *sigh* so I can't just have generic variables there?
03:06:36 <dafis> ivanm: not without FlexibleInstances
03:06:48 <ivanm> *sigh*
03:08:05 <dafis> ivanm: what's the problem? portability?
03:08:27 <accel> is it possible to add strictiness to function types?
03:08:33 <accel> i.e. foo :: String -> !String
03:08:44 <rtharper> accel: no, but you can use BangPatterns
03:08:51 <rtharper> although only in arguments
03:09:06 <rtharper> accel: otherwise you can create a strict datatype
03:09:11 <rtharper> or use 'seq'
03:09:31 <accel> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/bang-patterns.html
03:09:34 <accel> I don't see what that achieves
03:09:40 <Jafet> ghc: Warning: -XNewQualifiedOperators is deprecated: The new qualified operator syntax was rejected by Haskell'
03:09:49 * Jafet is sad.
03:09:53 <ivanm> dafis: more that the actual library uses only GeneralizedNewtypeDeriving (and I was going to do away with that anyway), and now just for the serialisation stuff I need MPTCs, FDs and now FlexibleInstances :(
03:10:07 <accel> ah, it's an extension
03:10:08 <ivanm> I thought it was going to be quite elegant not to actually need extensions
03:10:11 <accel> no reason I've never seen it before
03:10:22 <ivanm> Jafet: that's an actual warning?
03:11:18 <Jafet> I tried -Wall again, and that was the first thing I got
03:11:26 <Jafet> I will probably never truly love -Wall.
03:13:36 <ivanm> Jafet: what were you wanting?
03:14:15 <Jafet> I was wanting... NewQualifiedOperators?
03:14:44 <ivanm> yeah, don't think I've seen that extension before
03:14:44 <bustakheops> Hi, I need help to construct a tree with a bit list, someone can help me ?
03:15:27 <ivanm> Jafet: the documentation for 7.0.2 still says it's there :s
03:16:24 <kx> hi, where can I read on passing functions as arguments? i.e. what's the difference between 'map -1' and 'map (-1)'
03:16:48 <ivanm> Jafet: oh, it does Foo.(symbol) instead of (Foo.symbol) ?
03:16:52 <Jafet> map -1 is map minus 1; (-1) is negative 1
03:16:59 <Jafet> (subtract 1) is the function that subtracts one
03:17:03 <Jafet> Also called pred
03:17:09 <Jafet> ivanm: yeah
03:17:57 <ivanm> Jafet: any particular reason for using that? just because it makes sense?
03:18:10 <ivanm> *more sense
03:18:20 <Jafet> Well, the people who proposed it thought so
03:18:35 <Jafet> I couldn't figure out for the life of me how to use it infix, though
03:18:43 <Jafet> So I suppose it's all for the better.
03:19:33 <kx> and I can't use for example: foldr - 0 [1,2,3,4] because of operator precedence? not some special function passing rule? (same with ++)
03:19:40 <ivanm> what's the syntax for multiple FDs? "Foo a b c | a -> b, a -> c" ?
03:20:08 <ivanm> kx: just because "-" is special
03:20:29 <ivanm> kx: subtract = flip (-) if that helps
03:20:41 <ivanm> wait, that should work for you...
03:20:46 <kx> but then ++ is special too, hm?
03:20:46 <ivanm> > foldr (-) 0 [1,2,3,4]
03:20:47 <lambdabot>   -2
03:20:56 <kx> yes, I know that, but I rather want to know the mechanism
03:21:01 <ivanm> kx: you need to wrap operators in parens to use them
03:21:10 <Jafet> @where cheatsheet
03:21:10 <ivanm> *to use them as functions
03:21:10 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
03:21:20 <kx> thanks
03:21:27 <kx> that's what I wanted to know I guess
03:21:38 <kx> and thanks for the link
03:23:49 <ivanm> dafis: it now wants UndecidableInstances as well :s
03:24:01 <dafis> ivanm: oops
03:24:18 <dafis> ivanm: context not smaller than instance head?
03:24:26 <ivanm> doesn't like one of my FDs apparently
03:24:35 <ivanm> some coverage condition problem :s
03:26:22 <frerich> ivanm: That's a pretty nice link, thanks for sharing!
03:27:07 <ivanm> frerich: which link? the cheatsheet was by Jafet...
03:27:23 <frerich> Oh, well, then thanks to Jafet. :-)
03:27:35 <frerich> but thanks to you, too, for pointing out it was by Jafet. ;-)
03:30:15 <frerich> I really enjoy writing little programs in Haskell (my first functional language so far), but one thing which keeps bugging me is that I find it very hard to reason about the efficiency and performance of my programs. For instance, I recently wondered whether using pattern matching to tell whether a string is three letters long is better than calling length. Is there some paper giving some rules of thumb about this?
03:30:30 <frerich> Or, how pattern matching compares, as far as performance is concerned, to guards.
03:31:37 <dafis> frerich: for the first question, length needs to traverse the entire list, so checking the length may be dramatically slower than pattern matching
03:31:57 <Jafet> Haskell does not specify most things, so when people talk about performance, they invariably talk about GHC.
03:32:16 <Jafet> I think it does specify pattern matching to be sequential and strict.
03:33:06 <frerich> dafis: Good point. I just realized, 'length [1..] > 3' doesn't actually terminate.
03:33:30 <dafis> > length [1 :: Int8 .. ] > 3
03:33:31 <lambdabot>   True
03:33:40 <frerich> Oh!
03:33:46 <dafis> frerich: that's because the type defaults to Integer
03:33:51 <Zao> > any ((>3) . length) (inits [1..])
03:33:52 <lambdabot>   True
03:34:07 * Jafet stares at Zao
03:34:16 <Zao> Jafet: Highly efficient :D
03:34:25 <dafis> frerich: with Int, it would just take a while (a loong while on 64 bit systems)
03:34:32 <Jafet> (genericLength xs :: Nat) == 3
03:35:07 <dafis> > not . null $ drop 3 [1 .. ]
03:35:09 <lambdabot>   True
03:35:29 <Zao> With concrete Int32/Int64, it'll also not be able to do the test for large lengths.
03:35:41 <frerich> dafis: Hm I think that is kind of cheating. :-) My assumption was that maybe ghc could "const-fold" (is that what it's caleld?) the expression, realizing that it will not need to count more than 3 characters.
03:35:45 <Zao> > not . null $ drop 3 [1]
03:35:47 <lambdabot>   False
03:36:12 <Zao> For some reason I expected a failure along the lines of head [] there
03:36:24 <dafis> frerich: it doesn't know that much, unfortunately
03:36:54 <Jafet> frerich: nope. The result type of length is Int, which is strict. length must evaluate the entire list to go to WHNF.
03:36:55 <opqdonut> frerich: with lazy naturals that actually works
03:37:09 <opqdonut> I mean "length [1..] > 3"
03:37:10 <Jafet> If you used a non-strict length, you could make it work
03:37:57 <frerich> Ah yes, I see.
03:38:03 <opqdonut> (lazy naturals are "data Nat = Zero |†Succ Nat", with comparison defined as "Succ a > Succ b = a > b; Succ a > Zero = True; Zero > _ = False")
03:38:33 <frerich> Anyway, after getting over the initial excitement with functional programming, I realized that it's quite easy to write rather inefficient code. At least I tended to think "Oh it's alright, the lazyness of Haskell will save the day".
03:39:05 <dafis> frerich: or it may dip you in even deeper
03:40:15 <ivanm> how do you insert a newline using Data.Binary? put '\n' ?
03:40:39 <Jafet> "What's a newline?"
03:40:40 <dafis> putWord8 10 ?
03:41:49 <ivanm> Jafet: OK, I want to start a new line...
03:42:02 <ivanm> > chr 10
03:42:03 <lambdabot>   '\n'
03:50:15 <ddarius> frerich: Do you understand the evaluation model of Haskell?
03:51:29 <ivanm> is there any way of getting a value outside of Put ?
03:56:53 <Egbert9e9> wow, forkIO is insane
03:58:11 <Egbert9e9> Haskell is a series of tubes.
04:00:15 <frerich> ddarius: I'm pretty sure I don't.
04:07:08 <Jafet> How should I trace inside a runSTArray?
04:07:19 <Jafet> Hm, let's try unsafeSTtoIO
04:12:56 <Jafet> Hahahahaha
04:13:04 <Jafet> traceShow (unsafePerformIO . unsafeSTToIO . unsafeFreeze $ arr)
04:13:44 <ivanm> wtf? :o
04:14:18 <ivanm> how can I use get from binary to get a particular String ?
04:14:20 <Egbert9e9> is that pirate talk?
04:14:28 <ivanm> (or any other particular value)
04:15:09 <FUZxxl> @src sum
04:15:09 <lambdabot> sum = foldl (+) 0
04:22:13 <ivanm> @hoogle (Monad m) => m a -> m [a]
04:22:14 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
04:22:14 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
04:22:14 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
04:23:36 <ion> :t liftM (:[])
04:23:37 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m [a]
04:24:13 <ivanm> oh, Get is an instance of Applicative
04:25:28 <ivanm> oh, but not Alternative :@
04:30:43 <ivanm> preflex: seen kolmodin
04:30:44 <preflex>  kolmodin was last seen on #haskell 44 days, 2 hours, 20 minutes and 44 seconds ago, saying: :)
04:31:10 * hackagebot NanoProlog 0.2.1 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.2.1 (JurrienStutterheim)
04:34:18 <spirit> init . tail . show "hiya" -- what's the evaluation order here?
04:35:02 <ivanm> spirit: it doesn't type-check
04:35:04 <ivanm> so none! ;-)
04:35:10 <merijn> :t init
04:35:11 <lambdabot> forall a. [a] -> [a]
04:35:14 <dafis> spirit: none, doesn't parse, you'r missing a ($) or parentheses
04:35:34 <ivanm> spirit: you _really_ shouldn't be trying to use Haskell in an quick`n`dirty solution without knowing it
04:35:51 <spirit> i had map (init . tail . show) ["a","b"] before
04:35:58 <spirit> that did parse i think
04:36:01 <ivanm> spirit: that works
04:36:06 <merijn> spirit: Because that is correct :p
04:36:06 <ivanm> it's not nice, but it works
04:37:01 <merijn> spirit: What is the difference between the arguments in the map and non-map example and why would you say this difference matters?
04:37:48 <spirit> just trying to pull that parse step into another function that works on strings rather than lists of strings
04:37:48 <ion> let t :: Show a => a -> a; t x = trace ("(" ++ show x ++ ")") x in init . tail . show $ (t 'h' : t 'i' : t 'y' : t 'a' : t [])
04:51:08 * ivanm contemplates switching to a proper parsing library rather than using Get ...
05:04:04 <spirit> thanks so much for all your help! will switch to proper libraries at the end of the week -- quick and dirty works until then :-)
05:11:38 <Jafet> Am I writing the type signature wrong? http://hpaste.org/47262/pain_in_the_s
05:13:16 <Lemmih> Jafet: Try 'runSTArray (return a)'.
05:14:03 <Jafet> Same error.
05:15:57 <ivanm> gah! put is putting in too many crap values! :@
05:16:08 <Lemmih> Jafet: Actually, I don't think you can do taht.
05:16:39 <ivanm> maybe I should just directly write to a bytestring...
05:18:12 <Lemmih> Jafet: With that code, it would be possible to access both the STArray and the Array.
05:22:31 <Jafet> You're right, that was a bad example
05:36:12 <mikehadlow> GHCi, version 6.12.3. Unsupported extension: XDeriveDataTypeable. Why can't I use this language extension when loading a file with :l ?
05:36:39 <shachaf> mikehadlow: X isn't part of the extension name.
05:36:49 <shachaf> (If you're using LANGUAGE.)
05:37:26 <mikehadlow> Thanks shachaf !
05:37:49 <Jafet> (Lemmih:) I reduced it to this: http://hpaste.org/47264/pain_in_the_s_annotation
05:38:19 <Jafet> Basically, using two STArrays in one thread
05:40:36 <spirit> how does latex -- translate to leksah char/string?
05:40:54 <spirit> oops - i meant haskell not leksah ;-)
05:43:12 <Jafet> -- translate to haskell char/string?
05:43:20 <Jafet> You mean literate Haskell?
05:43:43 <spirit> when i enter "--" in latex, i get an elongated "-" -- is it called n-rule? forgot
05:43:49 <Botje> en-dash
05:43:54 <spirit> ah :-)
05:43:57 <Botje> and --- is an em dash
05:44:18 <shachaf> ‚Äì
05:44:19 <shachaf> ‚Äî
05:44:26 <shachaf> Hmm. Those look the same in my monospace font. :-(
05:44:44 <rtharper> Botje: is your name meant to mean "little boot"?
05:44:57 <Botje> not boot, bot :)
05:44:59 <nazgjunk> they look different in *my* monospace font :P
05:45:01 <Jafet> Little bot?
05:45:04 <rtharper> ah
05:45:06 <Botje> I used to run an IRC bot
05:45:19 <Botje> shachaf: if you put them next to each other there's a tiny difference
05:45:19 * rtharper didn't know whether to translate just the -je or the whole word ;)
05:45:20 <ion> I personally like ‚Äòword space en-dash space word‚Äô more than ‚Äòword em-dash word‚Äô.
05:45:25 <merijn> It could also mean "little bone" :p
05:45:32 * shachaf used to be an IRC bot.
05:45:38 <shachaf> ion: Disgusting.
05:45:39 <rtharper> then you became a real boy?
05:45:40 <spirit> em dash would be perfect. how to enter it in haskell?
05:45:48 <rtharper> so many Dutch in #haskell
05:45:52 <shachaf> spirit: Same way you enter it in any editor.
05:45:53 <nazgjunk> \o/
05:45:55 <merijn> rtharper: Of course
05:45:57 <rtharper>  /Flemish =)
05:46:01 <shachaf> Compose - - -
05:46:09 <shachaf> (Or whatever it is you like to do.)
05:46:10 <ion> and - - . for en
05:46:18 <Jafet> It seems that you can't just use unsafeFreeze on an STArray s, because it isn't higher-rank
05:46:26 <Jafet> Weird
05:46:37 <merijn> rtharper: Utrecht, Nijmegen and another one I forgot all do quite a bit of Haskell
05:46:40 * shachaf needs a few dozen more keys.
05:46:50 <rtharper> merijn: yeah, I know =)
05:46:56 <rtharper> merijn: Ghent?
05:46:56 <spirit> Compose?
05:47:07 <rtharper> (Not in the Netherlands, but Dutch speaking)
05:47:22 <merijn> rtharper: No, I meant universities in a real country :D
05:47:36 <rtharper> flamebait =p
05:47:42 <Jafet> shachaf: or invest in a pair of these http://www.collectiondx.com/files/gits5.png
05:47:54 <merijn> It's been what? >1 year and still no government :p
05:48:02 <rtharper> yeah they hvae broken iraq's record
05:48:10 <Jafet> Actually, that keyboard does look like it has a lot more keys.
05:48:45 <shachaf> Jafet: Freely and gladly, I say, freely and gladly!
05:48:52 <spirit> how does compose work? trying to get those en / em dashes
05:49:13 <jrick> I was sort of interested in dutch when I was young (my mom can speak it), took spanish in HS, now taking chinese in college
05:49:17 <jrick> chinese is awesome
05:49:25 <ion> and altgr-numpadminus for ‚àí (the minus sign) when using the keypad:oss option.
05:49:51 <shachaf> Numpad? What's that?
05:50:16 <ion> ctrl-shift-U2212
05:50:40 <spirit> that to do with my question?
05:50:40 <shachaf> Anything to avoid using "-".
05:51:12 <spirit> linux doesn't offer those i think
05:51:19 <ion> - is just fine as a hyphen.
05:51:38 <spirit> \\\
05:51:46 <merijn> - is the only acceptable hyphen
05:52:20 <shachaf> @check (\a b -> (not a || b) == (a <= b))
05:52:20 <lambdabot>   "OK, passed 500 tests."
05:52:22 <spirit> i am looking for something visually more prominent
05:52:42 <ion> merijn: ‚Äê is also ok
05:52:43 <merijn> en-dash is for numeric range "1400--1500", "page 312--314", em-dash is for parenthetical sentence fragments
05:52:43 <shachaf> C should have an "implies" operator.
05:53:36 <spirit> and how to enter it without fancy keyboard short cuts?
05:53:49 <merijn> spirit: You don't
05:54:01 <merijn> Unless you have a bizarre unicode keyboard
05:54:28 <Botje> on osx it's option-hyphen
05:54:37 <Cale> > fromEnum 'ó'
05:54:38 <lambdabot>   65533
05:54:39 <spirit> and under linux (ubuntu)?
05:54:48 <Cale> > fromEnum 'ñ'
05:54:49 <lambdabot>   65533
05:54:51 <Botje> i would imagine it's alt-hypthen under ubuntu
05:55:01 <Cale> > toEnum 65533 :: Char
05:55:02 <lambdabot>   '\65533'
05:55:06 <Cale> lol
05:55:16 <Jafet> > text [toEnum 65533]
05:55:17 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
05:55:19 <Cale> > text [toEnum 65533]
05:55:20 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
05:55:22 <Cale> er
05:55:24 <Cale> heh
05:55:27 <Jafet> You should really fix that, whatever it is
05:55:38 <spirit> the short cuts don't work for me.
05:55:39 <Cale> I don't know what it is
05:55:50 <Cale> Have you bound a key to compose?
05:55:54 <Jafet> Oh, it looks like mueval's fault
05:56:03 <Cale> I replaced caps lock with compose
05:56:08 <Jafet> Or at least, the mueval plugin's fault
05:57:12 <Botje> spirit: according to http://ubuntuforums.org/archive/index.php/t-428265.html it's compose + - -
05:57:23 <spirit> what is compose?
05:57:48 <spirit> i have a windows machine, so a windows keyboard, uk
05:57:52 <shachaf> It's the key on your keyboard labeled with a "C" inside a circle.
05:57:56 <shachaf> Everyone has it.
05:58:03 <Botje> on my keyboard it's labeled alt gr
05:58:15 <spirit> \\
05:58:16 <shachaf> Botje: AltGr isn't the same thing as Compose.
05:58:21 <shachaf> Two different keys.
05:58:24 <spirit> that's what i get with alt Gr
05:58:35 <shachaf> Compose is generally an X11-only thing.
05:59:00 <spirit> --
05:59:05 <spirit> nah no luck
05:59:54 <zygoloid> AltGr + , , works here
05:59:57 <zygoloid> ‚îÄ
06:00:25 <spirit> does the + mean you press AltGr and ,, at the same time?
06:00:48 <zygoloid> no. <AltGr>+<+>, <,>, <,>
06:00:48 <shachaf> You people have weird keyboards.
06:01:29 <zygoloid> no. <AltGr>+[ <+>, <,>, <,> ], rather
06:01:47 <spirit> øø
06:01:49 <zygoloid> shachaf: :)
06:01:56 <spirit> ◊◊
06:01:59 <spirit> o dear
06:02:53 <spirit> ƒ¶ƒ¶ƒ¶
06:02:54 <shachaf> zygoloid: AltGr [/] makes ¬´/¬ª! I had no idea.
06:03:57 <saati> shachaf: on what layout?
06:04:25 <shachaf> US International (AltGr dead keys)
06:04:26 <bustakheops> how to know if a file exist or not ?
06:05:23 <Botje> :t doesFileExist
06:05:23 <lambdabot> Not in scope: `doesFileExist'
06:05:43 <spirit> ó
06:05:45 <Botje> hmm
06:05:58 <spirit> ñ
06:06:11 <jrick> shachaf: same on colemak
06:06:13 <bustakheops> Oo don't see this function, thx
06:06:17 <shachaf> bustakheops: doesFileExist, but the usual warnings about race conditions apply.
06:06:18 <merijn> Botje: That doesn't work
06:06:25 <spirit> via system settings i could set alt gr to be compose
06:06:29 <spirit> cheers :-)
06:06:31 <merijn> bustakheops: You don't, you try to open it and deal with it if the file didn't exist
06:06:35 <shachaf> bustakheops: So if you're going to actually open the file, don't use doesFileExist, just open it and check for errors.
06:06:56 <merijn> bustakheops: What are you going to do if someone deletes the file after you run "doesFileExist" to check if it was there, but before you managed to open it?
06:09:05 <bustakheops> I want to compress a file but if the compressed file already exist I don't want to compress it
06:10:56 <Jafet> Of course, some filesystems don't have real locks, so...
06:11:08 * Jafet kicks unix tradition
06:11:30 <shachaf> Jafet: What would you like to replace it with?
06:11:45 <merijn> ZFS!
06:12:35 <sipa> always use the alphabetically last one
06:12:55 <Jafet> ZFS, the emacs of filesystems
06:13:05 <jrick> that's not a good thing
06:14:07 <Axman6> ZFS is great if used in the right situation, but I don't think it's a particularly good desktop FS (though snapshotting and compression are nice features to have there)
06:14:10 <earthy> there's also the little issue of files that you can see exist but that you still can not open
06:14:39 <Axman6> ?
06:14:58 <earthy> axman6: doesFileExist is not an operation at the file level
06:14:59 <merijn> Axman6: Its a bit heavy for the desktop, yeah. But snapshotting, compression, easy dumping and dynamically creating filesystems are nice on a desktop :>
06:15:11 <Axman6> indeed
06:15:32 <Axman6> i just wish you could easily add new disks to a raidz device
06:16:10 <luite> is it so "heavy" that it actually feels slow on recent desktop hardware, or are there other reasons for it not being a great desktop fs?
06:16:30 * hackagebot Clipboard 2.2.0 - System clipboard interface.  http://hackage.haskell.org/package/Clipboard-2.2.0 (DanielDiaz)
06:16:31 <merijn> luite: It is heavy in that it gobbles up RAM
06:16:45 <Axman6> well, it's not really aimed at being a desktop FS is what i really mean i guess
06:16:55 <Axman6> yeah, it uses tonnes of ram
06:17:00 <shachaf> ZFS gobbles up RAM when just used as a simple FS?
06:17:02 <shachaf> Why?
06:17:09 <merijn> shachaf: Because RAM is cheap
06:17:39 <shachaf> So?
06:17:43 <merijn> luite: It is not really runnable with 1GB of RAM I've heard. Some people recommend at least 4GB RAM, my home server seems to run just fine with 2GB but that has only like 6-8 clients
06:20:09 <Axman6> the FreeBSD docs seem to recommend 1GB minimum
06:20:10 <merijn> shachaf: I don't have in-depth understanding of the implementation, so I can't tell you exactly what it's used for, but since it was designed for (file)servers the design assumption was people running it would have at least a couple of GB free RAM to accommodate it
06:20:26 <Axman6> but, what desktop machine doesn't have at least 1GB these days
06:21:05 <merijn> Axman6: Yeah, it also seems to matter whether you run 32bit or 64bit, my 2GB (64bit) machine runs just fine, but I've heard horror stories from people running 32bit machines with 2GB or less RAM
06:21:18 <Axman6> yeah
06:34:55 <parcs> well freebsd has a relatively old version of zfs (15) whereas the latest version of zfs is 30
06:36:20 <parcs> (each version number designates a significant change)
06:40:23 <merijn> parcs: FreeBSD is up to 28 in -CURRENT
06:40:36 <merijn> -STABLE is up to 21 I think
06:42:25 <parcs> yep, but -RELEASE only 15
06:44:09 <luite> how's btrfs coming along? does it already have most of zfs' features?
06:45:07 <Eduard_Munteanu> I think so. I'm not sure if there's much difference anyway.
06:47:22 <Axman6> luite: my understanding of btrfs was that it was a long way from usable
06:47:54 <saati> the btrfs wiki says they won't break the ondisk format anymore
06:47:58 <Eduard_Munteanu> Um? I've been using it for more than a year.
06:48:42 <merijn> There's people using all sorts of unusable software :p
06:48:44 <luite> the last major disk format change was in 2009 righ?
06:48:48 <luite> t
06:50:28 <Eduard_Munteanu> Well some things got fixed recently, like proper out-of-space handling and that stuff.
06:50:51 <Eduard_Munteanu> But it's been pretty stable otherwise.
06:51:19 <luite> did those changes break anything for people trying to boot an older kernel?
06:51:56 <Eduard_Munteanu> Mostly no, IIRC.
06:53:09 <luite> hehe that's quite important for a stable filesystem :) I believe Linus wasn't terribly happy with the breakage in 2009 from the forward rolling format change
06:53:33 * hackagebot dimensional 0.10 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.10 (BjornBuckwalter)
06:54:28 <Eduard_Munteanu> I'm not sure, but they have added options which could break backwards compatiblity.
06:54:40 <Eduard_Munteanu> space_cache maybe?
06:54:49 <gienah> luite: I've heard that btrfs seems to work better with 2.6.39, zfs is has more features like zfs send to send checkpoints to a remote system
06:55:17 * Eduard_Munteanu is thinking of trying LZO compression himself
06:55:35 * gienah has run btrfs since 2.6.34, has just been lucky not to experience problems
06:55:39 <Eduard_Munteanu> I hear it improves throughput usually.
06:56:34 * gienah has not used any sort of compression on btrfs
06:57:09 <luite> were there major issues with compression?
06:57:47 <gienah> luite Eduard_Munteanu: there may have been issues with compression, probably best to use kernel 2.6.39
06:58:17 <luite> hmm
06:58:36 * gienah is going by recommendations of others who know more about btrfs
06:58:49 <luite> I think I only use ext4 and xfs at the moment, but I'll keep that in mind for new installs
07:02:21 <merijn> It's interesting to see that enabling compression on ZFS drastically improves read/write performance :>
07:04:03 <luite> merijn: there are some drives that do compression in hardware with the same result
07:12:03 <gienah> luite Eduard_Munteanu: a btrfs data corrupting bug that was fixed by one of the gentoo haskell devs recently (who advised that 2.6.39 no longer crashes with btrfs): http://git.kernel.org/?p=linux/kernel/git/mason/btrfs-unstable.git;a=commitdiff;h=3387206f26e1b48703e810175b98611a4fd8e8ea
07:12:32 <luite> ah
07:14:06 <luite> does any filesystem offer quick per-user snapshots of single directories by the way? for example, allow a user to do some stuff in /home/user/tmp and have a command to revert that whole dir to a previous state?
07:14:06 <gienah> another fun thing about btrfs is that btrfs.fsck is only a recent sort of add on that is not really integrated with gentoo, not sure if it is in another linux distros
07:15:30 <gienah> luite: of course you already know that both btrfs and zfs do, zfs is really neat as it has zfs send to send the snapshot to a remote system
07:16:21 <merijn> ZFS only supports snapshots on a filesystem level, but on the other hand it can easily handle a couple of hundred (or thousand) filesystems so creating one FS per directory is not unrealistic and you can delegate filesystem creation to non-root users
07:20:56 <luite> gienah: hmm, I thought you needed to be root to create/delete subvolumes with btrfs
07:26:02 <Axman6> i love that you can enable FS compression on a per directory level in ZFS, same for the redundancy factor
07:26:55 <sipa> only per FS, not per directory
07:27:17 <sipa> though nothing prevents you from creating an FS per directory
07:27:43 <luite> regular users can do that too?
07:28:33 <parcs> is there a way to specify the the type of a type variable buried within a stack of monads without having to annotate the entire monad stack?
07:30:17 <parcs> wait never mind
07:31:27 <gienah> luite: I'm not sure, I haven't been game to try creating subvolumes (I don't really trust btrfs, so I try to avoid using features)
07:32:02 <bustakheops> plz I really need help on this : http://hpaste.org/47265/how_to_optimize , my function is too slow
07:33:03 <luite> gienah: hehe I thought that those new features were the point of btrfs, at least I recall reading benchmarks where brtfs didn't really perform better than traditional filesystem
07:33:33 <joe6> is there any better way of capturing this error message: Prelude.read: no parse
07:33:43 <parcs> :t flip $ fmap . asTypeOf
07:33:43 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> b -> f b
07:33:50 <joe6> such as context of when it is happening or something like that..
07:34:02 <joe6> or, on what values it is happening.
07:34:26 <ion> joe6: You should use a parser library such as Parsec if you want decent parse error messages.
07:34:49 <luite> joe6: you can use the safe package for a quick fix
07:34:59 <luite> with readNote, which you can give a better error message
07:35:13 <parcs> it would be nice if it were possible to do something like this, though: do { x :: Int <- fromIntegral y }
07:35:16 <gienah> luite: yes at the time I chose btrfs it was due to the compile benchmark with 2.6.34 showing btrfs having much higher performance than other linux filesystems, since then the benchmarks I have seen are with SSD drives which is not relevant for me
07:35:26 <joe6> luite, cool. thanks, will check it out.
07:35:30 <parcs> err, return (fromIntegral y)
07:35:53 <joe6> this is my code that gives that message: getByte :: String -> Int
07:35:53 <joe6> getByte x = read x
07:36:48 <joe6> > readNote
07:36:48 <ion> byte :: Parser Integer; byte = read <$> many1 digit  -- for natural numbers
07:36:49 <lambdabot>   Not in scope: `readNote'
07:36:56 <luite> gienah: hmm, interesting. though compiles seem mostly cpu limited on the only system with an ssd that I have (my laptop)
07:41:46 <gienah> luite: in benchmarks with later kernels other file systems seem to have higher performance than btrfs (tests these days seem to be on SSD drives and I don't see compile bench so much)
07:52:09 <exeter> I have rewritten a small "do notation" bit of code in an unsugared version ( http://pastebin.com/JC9PFAK0 here ). Is there a way to prettyfy the latter code? Specifically, the let .. in feels kind of awkard,  should I indent it differently?
07:52:12 <mauke> The paste JC9PFAK0 has been copied to http://hpaste.org/47266/httppastebincomjc9pfak0
07:52:58 <ion> mauke: Why?
07:55:57 <gienah> luite: although on the threaded io test here btrfs is much faster than ext4 and xfs: http://www.phoronix.com/scan.php?page=article&item=linux_2639_fs&num=1
07:58:54 <Lemmih> exeter: You could move the 'in' to the line above.
07:59:26 <exeter> thanks Lemmih, I am a bit unsure, what would the scope be then?
07:59:29 <exeter> all the do?
07:59:34 <exeter> (the non do)
08:00:23 <Lemmih> exeter: Yes. The scope wouldn't change.
08:01:09 <exeter> ok, that means I've understood little on how let works, is there an article for dummies on it?
08:02:44 <exeter> I mean, what if I want that let only be available to the "next line"
08:05:13 <Eduard_Munteanu> mauke has a bot moving stuff into hpaste now?
08:09:27 <dylukes> Anyone in here had success installing the haskell LLVM bindings on OS X?
08:09:46 <dylukes> It seems it's not searching my other paths for the libraries
08:09:50 <dylukes> (/usr/local/lib/)
08:10:06 <dylukes> So, if anyone knows how to tell cabal to search other paths, that'd be good too.
08:13:13 <savask> Hello. Is there a way to make ghc "pre-calculate" some functions? For example, I have a function giving Nth element of the Fibonacci sequence, and I do "main = print (fib 1200000)". Is it possible to make compiler calculate this function on the optimization stage?
08:13:53 <luite> snapshot snapshots snappy snapdragon
08:15:28 * mightybyte shoots luite's snapshot through the heart
08:18:19 <joe6> coded myself into a tangle. any thoughts/smart ideas on what I can do: http://pastebin.com/fXnDDVCf
08:18:25 <mauke> The paste fXnDDVCf has been copied to http://hpaste.org/47267/joe
08:18:44 <joe6> i do not want to use Prelude.Read, due to its' lack of proper error messages
08:18:56 <joe6> and parsec seems to be a bit too much for something this simple.
08:19:39 <luite> hmm, parsec is probably not that bad
08:20:30 <KirinDave> joe6: Parsec, mang.
08:20:35 <KirinDave> joe6: it'll be like 2 lines.
08:20:53 <KirinDave> joe6: If you are concerned about speed or representation, attoparsec seems to be the next place to go
08:21:29 <KirinDave> joe6: But haskell programmers have such a good parser generating tool that they seem very comfortable going to the well of a parser way earlier than in most other languages.
08:21:59 <luite> parsec is not a parser generator though
08:23:59 <joe6> parsec pollutes the purity? then i have to change the calling functions to IO ()
08:24:10 <luite> parsec doesn't require IO
08:24:23 <luite> it's monadic, but not necessarily IO
08:24:33 <joe6> how do i get Parser xx -> xx?
08:24:39 <dylukes> Axman6: Hey, did you ever get LLVM working on OS X?
08:24:51 <dylukes> I'm having the same old issue with LLVMModuleCreateWithName not being found.
08:24:54 <joe6> the return type of the parser function, i mean.
08:24:58 <dylukes> I think it might be an autoconf bug that it can't find it.
08:24:59 <Axman6> um... possibly, i can't remember
08:25:20 <dylukes> joe6: ParsecT s u m a is the base type of all parsers
08:25:33 <dylukes> s is the input stream, u is the user state, m is the monad being transformed, and a is the result type
08:26:00 <luite> joe6: parse, or runParsecT if you use a transformer
08:26:04 <dylukes> so, for instance, type Parser s a = ParsecT s () Data.Identity.Identity a
08:26:17 <dylukes> then, Parser String Int is a parser that takes a string and outputs an Int.
08:26:39 <KirinDave> joe6: I have a better idea
08:26:47 <dylukes> ParsecT is by default a transformer luite.
08:26:54 <KirinDave> joe6: http://book.realworldhaskell.org/read/using-parsec.html
08:27:00 <dylukes> KirinDave: No.
08:27:00 <KirinDave> joe6: All you need to know and more
08:27:04 <dylukes> That's horrendously out of date.
08:27:13 <dylukes> I wouldn't even touch it.
08:27:14 <dylukes> >_>
08:27:22 <joe6> i want it to be a pure function.
08:27:23 <KirinDave> dylukes: Examples are better than no examples.
08:27:26 <KirinDave> Even if they're out of date
08:27:29 <dylukes> I've been doing nothing but Parsec code for the last few weeks,
08:27:29 <KirinDave> joe6: That's no problem
08:27:33 <dylukes> if you have any questions joe6 , just ask
08:27:35 <joe6> i am looking for something with case or guards
08:27:39 <dylukes> I can maybe make you a simple example.
08:27:55 <joe6> parsec / monads change the structure of the calling function.
08:28:03 <KirinDave> joe6: The need not.
08:28:05 <dylukes> joe6: they don't have too.
08:28:14 <luite> dylukes: yes but parse only accept the Parsec type, which is specialized to transform Identity, so from the point of view of the user, it doesn't look like a transformer at all
08:28:29 <dylukes> Sure.
08:28:35 <dylukes> It provides the runParsecT function too though.
08:28:40 <joe6> value <- getByteM "0x)0" instead of let value = getBtyeM "0x00"
08:28:44 <dylukes> It's the same as State anyhow
08:28:45 <KirinDave> joe6: You can make a function readByteM -> String -> Num
08:28:47 <luite> I know, that's why I mentioned it :)
08:28:48 <dylukes> State is defined as StateT Identity
08:28:49 <joe6> s/0x)0/0x10
08:29:15 <dylukes> joe6: Could you tell me an example of what you want to do?
08:29:17 <KirinDave> joe6: You just have a pure non-monadic function receive the string you want to check, then it starts up its own set of monadic calls.
08:29:19 <dylukes> I wouldn't mind writing up an example.
08:29:29 <KirinDave> dylukes: Seems like http://pastebin.com/fXnDDVCf is what he's trying
08:29:30 <mauke> The paste fXnDDVCf has been copied to http://hpaste.org/47267/joe
08:30:23 <dylukes> so he wants to rewrite this to use parsec instead?
08:30:40 <joe6> dylukes, any "0x80" or "0x800" or "0x8" or "$008" or "$08" or "$8" -- parse any of these
08:30:55 <dylukes> Oh, this could be a fun little exercise actually.
08:31:01 <joe6> my current type is String -> Int
08:31:11 <dylukes> joe6: Alright, you mind if I try to write this out in parsec?
08:31:15 <dylukes> Shouldn't be too hard ^^
08:31:35 <joe6> i was using read before, but I need something with better error than what Prelude.Read throws out.
08:31:47 <dylukes> Yeah, this should be relatively easy in parsec.
08:32:21 <joe6> dylukes. i have used parsec before. but, i do not get that piece about getting the type to Int instead of Parser Int or IO Int
08:32:33 <dylukes> Okay, so as I said before,
08:32:35 <joe6> return type, I mean.
08:32:43 <dylukes> ParsecT s u m a
08:32:48 <dylukes> is the base type of all parser combinators
08:32:57 <dylukes> s is the stream type (String/ByteString/etc)
08:33:00 <dylukes> u is the "user state"
08:33:02 <joe6> dylukes, that is what I am trying to understand.
08:33:09 <dylukes> that can be () for our purposes
08:33:13 <dylukes> m is the monad being transformed,
08:33:20 <dylukes> we can leave that as Identity
08:33:23 <dylukes> and a is the result type
08:33:26 <dylukes> so,
08:33:36 <dylukes> Parsec s a = ParsecT s () Identity a
08:33:47 <dylukes> and then Parsec s a
08:33:55 <dylukes> is a Parser that takes in s and returns an a
08:34:40 <dylukes> then you can use the parse function,
08:34:45 <dylukes> which looks like
08:35:05 <dylukes> parse p f s
08:35:07 <dylukes> where p is the parser
08:35:17 <dylukes> f is the "name" of the input (w/e string you like, it doesn't matter...)
08:35:28 <dylukes> and s is the actual stream, in this case a string like "0x00005"
08:36:05 <dylukes> and it returns Either ParseError a
08:36:13 <dylukes> where a is the result type of your parser
08:36:14 <joe6> dylukes, i think I understand what you are saying. let me google for some examples on the usage.
08:36:16 <dylukes> so then yo switch over that.
08:36:20 <dylukes> I just said I'm writing one.
08:36:24 <dylukes> Give me a moment ^^
08:36:33 <joe6> dylukes, ok, thanks a lot.
08:40:08 <dylukes> joe6: So the output should be an int?
08:40:29 <joe6> dylukes, yes
08:40:35 <dylukes> alrighty
08:40:46 <joe6> the function type that i have is String -> Int
08:41:17 <joe6> dylukes, please do not spend a lot of time on it. something with the framework shoud be good enough. I can fill in the details.
08:41:24 <dylukes> haha, dont worry
08:41:30 <dylukes> its actually probably like 10 lines at most
08:41:40 <dylukes> just trying to restrict using any fancy tricks and make this as simple as I can ^^
08:44:33 <nikolaibo> www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info www.xxxlivecam.info
08:44:45 <dylukes> ‚Ä¶off topic
08:45:04 <luite> nikolaibo: #haskell-blah for off-topic discussion
08:45:15 <Jafet> @vixen do you have a live cam?
08:45:15 <lambdabot> nope, no cam. sorry
08:46:24 <Eduard_Munteanu> Spam is off-topic?
08:46:47 <luite> unless its on topic of course
08:47:13 <dylukes> joe6: One moment, phone call
08:52:10 <ArnoVanLumig> brb
08:52:50 <dylukes> joe6:
08:52:51 <dylukes> okay here we go
08:52:54 <dylukes> I think this is simple enough
08:53:22 <dylukes> https://gist.github.com/999094
08:53:26 <armence> Hello all. I am using GHCI. Is there a way to save everything I have entered into a file?
08:53:40 <dylukes> strictly speaking, you could remove the skipMany, since haskell's 'read' function will deal with leading zeroes
08:53:53 <dylukes> I just put it there so you have more of an idea of how it works.
08:55:31 <joe6> dylukes, thanks a lot. I am still digesting it.
08:55:45 <dylukes> any questions?
08:56:26 <joe6> dylukes: nope, it appears pretty straightforward.
08:56:31 <joe6> as you said.
08:57:25 <joe6> and I like the way you put it as a separate module. shows your haskell colours.. good job and thanks a lot.
08:57:35 <dylukes> hehe,
08:57:45 <dylukes> I put it in a separate module because it makes the ghci prompt in emacs prettier ^_~
08:58:00 <dylukes> Last night #haskell diagnosed me with borderline OCPD.
08:58:17 <joe6> what is OCPD?
08:58:38 <Twey> Obsessive-Compulsive Pointfree Disorder?
08:58:54 <dylukes> Obsessive Compulse Personality Disorder
08:58:59 <dylukes> Twey: close enough
08:59:08 <Twey> Oh, okay :√æ
08:59:33 <parcs> > do { let x = 5 in let y = x; print y }
08:59:33 <lambdabot>   <no location info>: parse error on input `}'
08:59:46 <Twey> > read "010" :: Int
08:59:47 <lambdabot>   10
08:59:50 <parcs> > do { let x = 5; print x }
08:59:51 <ion> @tell exeter One might build a tree of some kind out of directory contents. Quick and dirty test code using Data.Tree: http://hpaste.org/47268/quick_and_dirty_code_to_build
08:59:51 <lambdabot> Consider it noted.
08:59:51 <lambdabot>   <no location info>: parse error on input `}'
08:59:51 <Twey> > read "0x10" :: Int
08:59:52 <lambdabot>   16
09:00:08 <Twey> Hey, I wonder where the 0x‚Ä¶ notation came from.
09:00:17 <dylukes> > read "$10" :: Int
09:00:18 <lambdabot>   *Exception: Prelude.read: no parse
09:00:21 <dylukes> doesn't work though ^^
09:00:43 <ion> Is there a nice less-pointful pattern for do bool <- f; if bool then g else h?
09:01:46 <Eduard_Munteanu> @unpl dylukes
09:01:46 <lambdabot> dylukes
09:01:48 <ion> Something like bool >>= ifM g h but without having to define ifM myself :-)
09:02:00 <dylukes> Eduard_Munteanu: ?
09:02:01 <ion> f >>= ifM g h that is
09:02:09 <Eduard_Munteanu> There you go, you've got OCD now.
09:02:26 <joe6> Twey, the problem with read is when it fails, all I get is a "Prelude.Read: no parse"
09:02:36 <joe6> i need more details than that.
09:04:35 <joe6> > readHex
09:04:36 <lambdabot>   Overlapping instances for GHC.Show.Show
09:04:37 <lambdabot>                              (GHC.B...
09:04:51 <ion> ghci> let natural :: Parser Integer; natural = read <$> many1 digit in parse (natural <* eof) "" <$> ["42", "42x", "foo"]
09:04:54 <ion> [Right 42, Left (line 1, column 3): unexpected 'x' expecting digit or end of input, Left (line 1, column 1): unexpected "f" expecting digit]
09:05:19 <Twey> joe6: I was just checking ‚Äòread‚Äô didn't use that weird convention that a leading 0 indicates octal.
09:05:28 <Twey> Nothing to do with your question :√æ
09:05:32 <Octal> :(
09:06:19 <Twey> Octal: Haha
09:06:30 <joe6> TWey, ok, thanks.
09:06:38 <Decimal> :)
09:06:51 <ion> joe6: How about that above for nice error messages?
09:06:52 <Octal> I'm teh only one
09:06:59 <Dozenal> I win, obviously.
09:10:06 <dylukes> joe6: Here's the "legible" version.
09:10:06 <joe6> dylukes,the code is awesome. Thanks a lot. the best ideas are when everyone feels why they did not think of it. This was so simple that I am beating myself for not having come up with it.
09:10:09 <dylukes> hexNumberAp = (string "0x" <|> string "$") *> (skipMany (char '0')) *> (read <$> (("0x" ++) <$> many hexDigit))
09:10:19 <dylukes> One line edition.
09:10:21 <dylukes> ^^
09:10:32 <joe6> what *>
09:10:38 <dylukes> :t (*>)
09:10:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
09:10:39 <dylukes> :t (>>)
09:10:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:10:42 <dylukes> :)
09:10:50 <joe6> dylukes: i will skip with the longer version. easier to comprehend.
09:10:56 <parcs> how do you guys prefer to format let statements inside a do-block?
09:10:57 <dylukes> yep, definitely ^^
09:11:10 <mdgeorge> hello
09:11:26 <parcs> er, case expressions inside let statements*
09:11:35 <mdgeorge> I'm trying to use type families to bundle together some related types
09:11:35 <parcs> inside a do block
09:11:45 <mdgeorge> I was wondering if there is a way to constrain them
09:12:29 <mdgeorge> for example, my "bundle" of types is class Kernel k where ....
09:12:48 <mdgeorge> inside I have a type Point2 and a type FieldNumberType
09:12:53 <monochrom> let x = case y of<ret><indent>Nothing -> ...
09:13:14 <mdgeorge> and I want to express a relationship between those
09:13:32 <mdgeorge> or even simpler, I want to express that Point2 must be of class Point2
09:13:35 <lbiplcki> could someone point me to an example of functor that cannot be made applicative? right now, i can't come up with any, what am i missing?
09:16:58 <mdgeorge> lbiplcki: what about vector spaces over a field?  does that work?
09:17:03 <mdgeorge> I'm not sure what pure would be
09:20:01 <ion> ghci> let hex :: Parser Integer; hex = readBase 16 <$> (string "0x" *> many1 hexDigit); readBase :: Num a => a -> String -> a; readBase n = foldl' (\acc a -> acc * n + (fromIntegral . digitToInt) a) 0 in parse (hex <* eof) "" "0xff"
09:20:02 <joe6> dylukes, quick question: how is the parsec version different from: http://pastebin.com/C5s4LqjF
09:20:04 <mauke> The paste C5s4LqjF has been copied to http://hpaste.org/47269/joe
09:20:05 <ion> Right 255
09:20:35 <dylukes> joe6: It's using parsec. s'about it.
09:20:51 <dylukes> That's somewhat more elegant. Parsec is just a more powerful monad/applicative combinator library for doing much more complex stuff.
09:20:54 <joe6> oh, ok. so, i can extend it with more error messages and stuff.
09:20:56 <dylukes> Besides, parsec's arguably more readable.
09:20:58 <dylukes> And error messages.
09:21:01 <dylukes> Yeah.
09:21:13 <dylukes> You can specify custom "what should be expected" messages using <$>
09:21:15 <joe6> dylukes, ok. thanks.
09:21:22 <dylukes> But, generally the automatic ones are pretty good ^^
09:21:28 <dylukes> <?>*
09:22:49 <ion> Error messages: ghci> let hex :: Parser Integer; hex = readBase 16 <$> (string "0x" *> many1 hexDigit); readBase :: Num a => a -> String -> a; readBase n = foldl' (\acc a -> acc * n + (fromIntegral . digitToInt) a) 0 in parse (hex <* eof) "" "0xffg"
09:22:54 <ion> Left (line 1, column 5): unexpected 'g' expecting hexadecimal digit or end of input
09:27:12 <jesse_> hi
09:27:45 <jesse_> There is no consistent way to do this: IO a -> a, right?
09:27:53 <dylukes> :t unsafePerformIO
09:27:53 <parcs> what is the difference between, say, $(mkLabels [..]) and mkLabels [..] at the top level?
09:27:53 <lambdabot> Not in scope: `unsafePerformIO'
09:28:05 <parcs> both seem to work
09:28:07 <dylukes> jesse_: You should probably avoid doing that.
09:28:33 <ion> s/probably //
09:28:37 <jesse_> dylukes: Okay, but then many parts of my programs must use the io monad.
09:28:52 <ion> IO a -> a is even worse.
09:29:17 <jesse_> Is it bad to use io monads in the hole program?
09:29:22 <monochrom> yes
09:29:26 <jesse_> hm :/
09:29:32 <bustakheops> Someone know how to read a file byte per byte and copy it byte per byte please?
09:29:38 <monochrom> unless it is a boring echo server
09:29:39 <dylukes> Generally just purify as much code as possible,
09:29:45 <dylukes> but, IO will be there in some parts,
09:29:47 <dylukes> specifically,
09:29:52 <dylukes> the parts in which you are dealing with IO
09:29:54 <dylukes> :)
09:30:05 <ion> bustakheops: writeFile "bar" =<< readFile "foo"
09:30:05 <parcs> bustakheops: hGet and hPut in Data.ByteString.Char7
09:30:09 <jesse_> yes, i implement a network protocol for an ai contest.
09:30:09 <parcs> Char8*
09:30:24 <parcs> @hoogle copyFile
09:30:24 <lambdabot> System.Directory copyFile :: FilePath -> FilePath -> IO ()
09:30:25 <monochrom> the ai part doesn't need IO
09:30:26 <jesse_> dylukes: I must always deal with IO String
09:30:35 <jesse_> monochrom: Yeah, but the input.
09:30:43 <jesse_> and the hole parser
09:30:48 <dylukes> jesse_: Don't forget, your ENTIRE program need not be under IO.
09:30:49 <monochrom> the parsing part doesn't need IO either
09:31:02 <dylukes> Theres a "run" function for IO, just as there is for State, Parser, and all the others...
09:31:24 <dylukes> you can put stuff into a block of monadic code, and get something out at the end,
09:31:26 <bustakheops> ion & parcs : thank's
09:31:28 <dylukes> provided you handle all the possible cases
09:31:34 <dylukes> and, you can't get anything out in the MIDDLE.
09:31:34 <jesse_> Yeah, I saw that in rwh
09:32:05 <jesse_> thx :)
09:32:08 <dylukes> pure code -> runIO [IO Monad code] -> pure code
09:32:17 <jesse_> Okay, thx.
09:32:28 <dylukes> just remember, you have to handle all possible execution paths once you exit the IO code...
09:32:34 <dylukes> think about it like,
09:32:38 <dylukes> how do you get a value out of a Maybe?
09:32:50 <dylukes> Maybe's a monad too, just a bit simpler.
09:33:04 <dylukes> IO is a monstrous behemoth that eats children and rapes women for fun and amusement.
09:33:21 <monochrom> these days it rapes men, too
09:33:28 <dylukes> Yep.
09:33:35 <dylukes> Oh, would you look at that.
09:33:38 <jesse_> haha
09:33:43 <dylukes> Apparently you can't perform IO apart from the main function
09:33:44 <dylukes> >_>
09:33:54 <jesse_> Yep
09:33:58 <dylukes> aw, sucks.
09:34:01 <jesse_> hehe :P
09:34:14 <dylukes> well, remember you can still use pure code from within monadic code...
09:34:18 <dylukes> just lift it...
09:34:22 <jesse_> I think I am able to finish my OpenGL 4.1 bindings today. :)
09:34:26 <dylukes> :D
09:34:31 <jesse_> ^^yeah, I will do that. :)
09:34:44 <jesse_> OpenGL ES bindings are also in development.
09:34:50 <jesse_> 2.1/3.3 is finished
09:36:32 <jesse_> Then I will rebuild my game engine in haskell.
09:46:04 <ion> Reducing the IO code to a small, manageable island within pure code pretty much requires there to be a clear path (if you will) from main to the boundary (if you will) between IO code and pure code.
09:46:59 <ion> Doing IO a -> a suddenly makes a number of those islands pop up everywhere contaminating everything and we‚Äôd be in the same situation as every impure language out there.
09:47:37 <joe6> any smart way of doing this: http://pastebin.com/PYyshsCt, when the assert fails, I want to go to the ghci command prompt, so that I can check out the state.
09:47:41 <mauke> The paste PYyshsCt has been copied to http://hpaste.org/47270/joe
09:47:58 <joe6> is that possible?
09:49:45 <joe6> or, maybe, an exitImmediately, would doe
09:49:49 <joe6> .s/doe/do/
09:51:46 <joe6> > exitImmediately
09:51:47 <lambdabot>   Not in scope: `exitImmediately'
09:51:57 <joe6> @hoogle exitImmediately
09:51:58 <lambdabot> No results found
09:53:39 <jmcarthur> jesse_: is pastorn aware of your opengl bindings?
09:54:18 <cmccann> I have a quick question of etiquette: If you're hacking on a chunk of code that someone else put up for adoption, how rude is it to refactor a bunch of stuff to match your personal stylistic preferences?
09:54:44 <jmcarthur> jesse_: he's on a SoC project to update the OpenGLRaw and OpenGL packages
09:54:51 <cmccann> the default when working on existing code is usually "stay consistent with existing style" but when it's been abandoned I'm not sure how much that matters
09:55:05 <jmcarthur> cmccann: if it's a fork then i don't think it's rude
09:55:12 <jmcarthur> maybe rude if it was just a contribution
09:56:10 <cmccann> well, it's not exactly a fork, since the original was abandoned
09:56:36 <cmccann> sort of a degenerate case of a fork where the fork is the only live branch :P
09:57:36 <cmccann> I already feel guilty for dumping the code into git instead of leaving it in darcs, but I've never used darcs and github is so convenient
09:59:52 <supercali> hello, need some help not "directly" haskell related. conceptual problem
10:00:11 <supercali> a map function applies a function to a given list
10:00:26 <Zao> @type map
10:00:27 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:00:35 <Zao> Yes?
10:00:36 <Zao> @src map
10:00:37 <lambdabot> map _ []     = []
10:00:37 <lambdabot> map f (x:xs) = f x : map f xs
10:00:49 <supercali> conceptually is there a function that can access the iteration count of the list being traversed
10:01:13 <Zao> supercali: You can fold, keeping track of the number of element in the accumulator.
10:01:27 <Zao> @type foldl
10:01:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:01:54 <Zao> Or of course, zip.
10:01:54 <supercali> oh ok ! that sounds cool :) !
10:01:56 <Zao> @type zip
10:01:57 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
10:02:08 <Zao> > zip [0..] "rofl"
10:02:09 <lambdabot>   [(0,'r'),(1,'o'),(2,'f'),(3,'l')]
10:02:19 <Zao> @type zipWith
10:02:20 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:02:20 <supercali> yeah .. i was thinking of zip as well ..
10:02:28 <supercali> but it seemed very clunky ..
10:02:50 <Zao> If you need to generate the state while iterating, a left-fold is probably conceptually cleaner.
10:03:03 <supercali> ah ok .. a left-fold ..
10:03:07 <Zao> While for just keeping track of indices, zipWith f [0..]  is clean in my eyes.
10:03:16 <supercali> ah .. i see ..
10:03:19 <Zao> @src foldl
10:03:20 <lambdabot> foldl f z []     = z
10:03:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:04:05 <supercali> amazing ! first time on haskell irc , and I'm blown away by the facilities here ..
10:04:12 <supercali> lambdabot ftw :) !!
10:04:24 <supercali> thanks a lot Zao ..
10:04:39 <supercali> have a nice day
10:04:44 <Eduard_Munteanu> @vixen supercali likes you!
10:04:44 <lambdabot> Ok
10:05:34 <Eduard_Munteanu> @vixen You don't seem impressed.
10:05:34 <lambdabot> i enjoy talking to you
10:05:46 <cmccann> supercali, you can run your own lambdabot off-line if you like
10:05:48 <supercali> ha ha ..
10:05:56 <supercali> is it so ?
10:05:58 <cmccann> Though you have to jump through a few hoops to get everything installed and working I think
10:06:05 <supercali> i will check it out .. ha ha ..
10:06:15 <supercali> cheers everyone .. over and out !
10:06:22 <cmccann> I think all the code for lambdabot is on hackage, and there's probably info somewhere on getting it working
10:06:22 <Zao> supercali: And of course, lambdabot listens to private messages.
10:06:36 <Zao> Helps when trying to craft oneliners to look clever with :D
10:06:46 <supercali> :)
10:16:44 <luite> Eelis: you wrote geordi right? I'm trying to do a similar thing for securely evaluating haskell. I've read the source code and know about the fd-leaking issue etc. are there other potential security risks that I should know about?
10:17:32 <Eelis> luite: i know of no security risks beyond those that the code protects against. if i did, i would update the code to protect against them :)
10:17:57 <luite> Eelis: ok, it might be that you had heard of something but hadn't had time to document and/or update the code :)
10:17:59 * hackagebot keys 0.2.7 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.2.7 (EdwardKmett)
10:19:09 <Eelis> luite: one thing i've yet to do is look at the new linux-containers facilities, which appear to be the modern approach to process isolation on linux: http://lxc.sourceforge.net/
10:19:25 <Eelis> luite: but that is more of a general thing to look at, not a concrete security concern
10:19:53 <Eelis> luite: still, if you're writing new code, that's definitely something to look at
10:20:01 <luite> Eelis: ah that was already on my list to look into :)
10:20:04 <Eelis> ok :)
10:20:20 <luite> and of course I'm going to run the untrusted code on a virtual machine
10:20:50 <Eelis> the idea with geordi is that that is not necessary. the geordi instance running on ##c++ and such does not run in a virtual machine
10:20:58 <Eelis> but it can't hurt (except for efficiency)
10:22:04 <luite> I still want to have a vm, just in case, for if there are kernel bugs or something similar :)
10:23:23 <luite> but I want to use it as a backend for a website, so performance is a bit more tricky than for geordi, I need to reuse untrusted processes, and have a parent process with the ghci api and packages pre-linked, that can be forked to create new untrusted processes quickly
10:23:43 <ion> You probably already know about seccomp. A process that PR_SET_SECCOMPs itself gets killed if it tries to run any syscalls other than read, write, _exit or sigreturn.
10:24:05 <luite> Eelis: but the geordi code is very useful, thanks
10:24:11 <luite> ion: yes but that's too limited
10:24:13 <Eelis> luite: all geordi uses is a precompiled header. that makes it fast enough. then again geordi only runs tiny snippets
10:24:26 <luite> ion: the haskell code need to load new source and data files
10:24:49 <Eelis> ion: seccomp was not an option for geordi because geordi must also run the C++ compiler securely, and g++ can't run in seccomp
10:24:59 <ion> Can they be loaded before running the untrusted code?
10:25:24 <luite> ion: nope, I don't know which files are needed in advance
10:25:30 <Eelis> hm, maybe seccomp can work for the clang branch of geordi
10:26:07 <luite> ion: perhaps if I do a lot of restructuring, but I'm afraid that I'd have to touch a lot of ghc internals eventually
10:26:13 <ion> aye
10:27:08 <luite> Eelis: In my case, it needs to be fast enough for a website where the user loads a page with maybe 10 or 20 snippets that need to be evaluated quickly
10:27:33 <Eelis> luite: right, i see
10:28:16 <luite> if you load the code with the ghc api in a process that handles all requests for this user, then it's doable :)
10:29:21 <luite> Eelis: by the way, isn't there a nicer method for ignorig syscalls than replacing them with getpid? :)
10:29:49 <Eelis> luite: it was the least intrusive and simplest thing i could come up with, and it works great. KISS :)
10:30:36 <luite> hehe true, I'll probably use it as well
10:30:36 <keep_learning> hello all
10:30:39 <keep_learning> http://hpaste.org/47272/cube_root
10:30:56 <keep_learning> i am trying to calculate the cube root of number
10:30:58 <luite> I want to allow fork though, because some programs need to execute an external program, for example graphviz
10:31:11 <luite> so trackign a process will get a little bit trickier
10:31:12 <keep_learning> but when i take a big number say 10^50
10:31:24 <keep_learning> it shows the answer in terms of exponent
10:31:41 <keep_learning> like 1.23412424e40
10:32:19 <keep_learning> i am looking for whole digits before decimal
10:32:23 <keep_learning> not rounding
10:32:51 <keep_learning> any one can tell me if i can use Double for this purpose
10:33:00 <rostayob> I've got linking problem with ghc 7.0.2: http://hpaste.org/47273/linking , I remember I had something similar with yesod
10:33:03 <tommd> that is rounding - truncation is a form of rounding (toward zero).
10:33:03 <luite> Eelis: by the way, did you rally notice a lot of difference with the Ptr CInt allocation for the wait call? I did some benchmarks and compared with the posix-waitpid code on hackage (by zygoloid), but there wasn't much difference
10:33:25 <keep_learning> or Double has not infinite precision
10:33:31 <keep_learning> to solve this problem
10:33:41 <monochrom> that's right
10:33:47 <Eelis> luite: i really don't remember, it was long ago, but if i wrote code/comments to that effect, i trust my former self's assessment :)
10:33:53 <luite> hehe
10:34:04 <luite> well perhaps it's just that the ghc optimizer can now handle this case better
10:34:11 <Eelis> quite possible, yeah
10:34:14 <tommd> keep_learning: I'm not clear what you're wanting, but perhaps you want the "Rational" type instead of "Double"?
10:35:11 <Eelis> luite: tracking multiple threads/processes is not "a bit trickier", it's *way* trickier. notoriously tricky. there's a paper about some of the super-subtle pitfalls somewhere
10:35:26 <keep_learning> tommd, let me explain you again
10:35:32 <keep_learning> cbrtNewton ( 10^23) 3
10:35:32 <keep_learning> 4.641588833612779e7
10:35:43 <keep_learning> when i took cube root of 10^23
10:35:54 <luite> Eelis: oh crud ;p would you happen to have a link?
10:35:59 <Eelis> luite: trying to find it now
10:36:05 <keep_learning> it show me the answer in exponent
10:36:45 <keep_learning> now what i want the 46415888.33612779
10:37:00 <tommd> keep_learning: Numeric.showFFloat
10:37:15 <keep_learning> all the digits before decimal not apporixamation
10:37:24 <tommd> > Numeric.showFFloat None 48289298.1839428991 ""
10:37:25 <monochrom> will still not get you more than 20 digits
10:37:25 <lambdabot>   Not in scope: data constructor `None'
10:37:37 <keep_learning> tommd, thank you
10:37:45 <keep_learning> tommd, one more thing
10:37:49 <tommd> right - but it will show you what is in the Double in normal decimal notation.
10:37:52 <Eelis> luite: http://www.watson.org/~robert/2007woot/20070806-woot-concurrency.pdf
10:38:04 <tommd> > Numeric.showFFloat Nothing 48289298.1839428991 ""
10:38:05 <lambdabot>   "48289298.1839429"
10:38:23 <keep_learning> does Double has infinite precision for double calculation ?
10:38:34 <keep_learning> or should i use Data.Ratio
10:38:40 <Eelis> luite: i'm not sure if there's also a full paper somewhere
10:38:53 <tommd> keep_learning: If you can't put up with rounding then use Ratio (the Rational type)
10:39:19 <hpc> keep_learning: it follows the IEEE specification, like every other language
10:39:25 <luite> Eelis: thanks
10:39:28 <hpc> keep_learning: so no :P
10:39:29 <tommd> keep_learning Double is a fixed 64 (or is it 80?) bit floating value.
10:39:48 <keep_learning> tommd , hpc : ok , thank you
10:39:54 <hpc> tommd: it's 64, but it uses 80 for intermediate steps on the cpu
10:40:10 <Eelis> luite: the last slide with conclusions is telling.
10:40:11 <hpc> 80 is an implementation detail :P
10:40:38 * hpc has had to know it for classes way more often than a person should have to
10:41:12 <mdgeorge> hello
10:41:20 <mdgeorge> can someone help me with a question about type families?
10:44:46 <monochrom> on ghc x86 32-bit or 64-bit, Double is just 64-bit
10:44:56 <luite> Eelis: hmm, thanks, some interesting info there
10:45:13 <monochrom> of which only 53 or 54 bits are for significant digits
10:50:32 <dylukes> monochrom: I feel like giving someone of my mental stability the capacity to generate machine code is dangerous.
10:50:39 <dylukes> Then again, I thought about it and,
10:50:54 <dylukes> the only people who originally came up with all that jazz probably had a good bit less mental stability than I do.
10:51:08 <dylukes> ‚Ä¶on a less ranting random note,
10:51:13 <dylukes> what's the story with GHC 64bit?
10:51:15 <c_wraith> mdgeorge: what's the question?
10:51:17 <dylukes> Is it tier 1 now?
10:51:29 <sunil_> hiii
10:51:42 <mdgeorge> c_wraith: is it possible to specify constraints on a type declared inside a class?
10:51:59 <monochrom> ghc 64-bit works fine on linux. dons use it all the time
10:52:10 <monochrom> damn, dons is singular!
10:52:11 <sunil_> i am unable to loa the programm
10:52:24 <mdgeorge> I'd like to have something like class Kernel k where { type Point k :: * }
10:52:36 <monochrom> but the windows story and the mac story are not nice
10:52:40 <mdgeorge> but then specify that Point has certain operations available
10:52:42 <dylukes> monochrom: Any thoughts on what the "most useful" GHC extensions are?
10:52:43 <hpc> monochrom: if there were multiple donseses, we would be the fastest language ever!
10:52:45 <dylukes> Or rather,
10:52:48 <dylukes> which are most worth learning?
10:52:50 <mdgeorge> c_wraith: does that make sense?
10:53:37 <c_wraith> mdgeorge: yes.  You can't do it with the type family mechanism, but you can put the constraint in the context of signatures that use (Point k)
10:53:45 <monochrom> multiple parameter type class (and its friend functional dependency), rank-n types, gadts
10:54:04 <dylukes> what're the actual names?
10:54:08 <mdgeorge> so something like: foo :: (Kernel k, Constraints Point k) => ...
10:54:18 <dylukes> I mean, what's the extension name for multi param type classes?
10:54:22 <dylukes> Fundeps I need to learn.
10:54:28 <dylukes> Rank-N types I still don't get at all..
10:54:29 <c_wraith> mdgeorge: well, syntactically, it'd be Constraints (Point k)
10:54:33 <c_wraith> But yeah
10:54:37 <mdgeorge> I see
10:54:56 <mdgeorge> I had thought of that, but I was hoping I could avoid specifying it everywhere
10:54:58 <monochrom> MultiParamTypeClasses
10:55:01 <mdgeorge> but I guess that makes more sense
10:56:11 <djahandarie> Should also learn TypeFamilies
10:56:30 <djahandarie> The hwiki article on them is unfortunately kind of shitty
10:56:49 <mdgeorge> c_wraith: do you know of a good library that uses these features for generic programming that I can study to get a handle on this stuff?
10:56:57 <mdgeorge> or anyone else for that matter?
10:57:18 <c_wraith> I don't know any offhand.  All the work I've done with type families has been just to learn them for my own sake.
10:57:25 <mdgeorge> I see
10:59:28 <mdgeorge> ok, well thanks again for your help
11:07:56 <luite> Eelis: hmm, maybe writing a linux security module is a better approach for my application than using ptrace. i'd have to do that part in C instead of Haskell, but it's probably doable
11:08:18 <Eelis> luite: could well be. i have no experience with those at all
11:08:22 <sully> are there ptrace bindings for haskell?
11:08:29 <luite> sully: yes, but very incomplete
11:08:39 <luite> sully: linux-ptrace on hackage
11:08:55 <luite> Eelis has more complete code in geordi on github, but that's not a separate package for the bindings
11:09:25 <Eelis> ptrace is being replaced with utrace, too
11:11:19 <luite> hmm, I though utrace was more an api for in the kernel, not a direct replacement
11:11:49 <Eelis> it's a lower level api that generally makes more sense, i think. ptrace can in theory be implemented in terms of it
11:11:58 <Eelis> but ptrace is crufty and horrible
11:13:07 <Eelis> i don't really know what plans (if any) there are for a new userspace api
11:14:02 <luite> anyway lsm seems to be just for this, selectively blocking system calls based on some policy, even if it's not totally uncontroversial
11:14:45 <tehgeekmeister> byorgey: curious if typeclassopedia 2 is happening, and if so about how soon i should look for it?
11:16:13 <kassens> are there Functors that are not "collection-like" (Maybe, List, Trees, ‚Ä¶)?
11:16:32 <cmccann> kassens, that depends on how broadly you define "collection-like"
11:17:42 <cmccann> the definition of Functor tends to mean that any instance can be viewed as a collection if you try hard enough
11:18:58 <cmccann> kassens, but an easy example is ((->) a), i.e. functions from some fixed type.
11:19:15 <Eduard_Munteanu> luite: what exactly do you want to do?
11:19:17 <kassens> cmccann: probably as: "containing n to m elements", but I'd be interested in examples that are less collection like
11:19:52 <Saizan> Cont r, also
11:20:08 <cmccann> kassens, you can have something like data K a b = K a, which is sort of an "always empty container"
11:21:34 <cmccann> kassens, and functions, like I said, which most people wouldn't normally think of as containers
11:21:53 <kassens> yep, thanks for the examples :)
11:22:08 <cmccann> several common Functor instances have functions in their type, notably the State and Cont monads
11:22:32 <cmccann> (and the Reader monad, which is the "function from fixed type" I already mentioned)
11:23:14 <cmccann> kassens, on the other hand a function can be treated as an implicit indexed container, where the argument is a key and it returns a value
11:23:46 <luite> Eduard_Munteanu: allow execution of arbitrary haskell code in a secure way (including code that does unsafe things, like not chekcing for array bounds)
11:23:51 <cmccann> and Cont is basically equivalent to the identity functor
11:24:25 <kassens> cmccann: '.' would be a valid fmap for functions, i think?
11:24:26 <luite> Eduard_Munteanu: i.e. not rely on the type system to provide security, like mueval does
11:25:07 <Eduard_Munteanu> luite: try seccomp?
11:25:12 <luite> Eduard_Munteanu: that's too limited
11:25:16 <Eduard_Munteanu> Why?
11:25:20 <thoughtpolice> the chrome guys evaluated seccomp for the rendering process inside chrome
11:25:33 <thoughtpolice> (for the linux branch of chromium, more specifically)
11:25:33 <cmccann> kassens, "the valid", not "a valid", I think :) but yes.
11:25:35 <Eduard_Munteanu> Would you need to open files on demand or do anything else?
11:25:53 <thoughtpolice> i think they still have the branch up, but they do some crazy shit to ensure trusted communication between seccomp'd threads and ones that are not seccomped
11:26:26 <cmccann> :t fmap fmap fmap
11:26:27 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:26:38 <cmccann> :t fmap . fmap
11:26:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:26:39 <thoughtpolice> like, the disassemble chrome at boot in order to patch binary relocations in the 'untrusted' module, so they can hook all syscalls and redirect them to a trusted thread of execution, which then defers the call to an external process that checks a policy
11:26:45 <thoughtpolice> so, rather heavy weight stuff :(
11:26:52 <luite> Eduard_Munteanu: temporary files are needed, I want to allow some packages that can currently only write to files (FilePath -> IO () ) etc
11:27:32 <thoughtpolice> (like basically everybody on the planet, they want to use seccomp, but they need more syscalls available than, uh, those 4 basic ones, hence the contortions)
11:27:40 <luite> yes...
11:28:12 <luite> Eduard_Munteanu: also the processes need to be able to fork (or clone etc) a few times, but that should be limited in some way
11:29:03 <luite> max 50 forks total, and a way to reset the counter for each process, something like that
11:30:05 <seit> How do I express something like:  myFunc x1:x2:x3:xs = something
11:30:26 <seit> In other words, I'd like to have access to the first N items in the function
11:30:38 <Eduard_Munteanu> luite: SELinux could work, but it tends to be really pissy to setup
11:31:50 <luite> Eduard_Munteanu: I don't think it can do all of this, but I'll look into it some more. it does use the same kernel api that I mentioned before
11:31:52 <parcs> is Control.Monad.Writer.tell O(1) or O(n) for a ByteString of size n ?
11:32:23 <luite> unfortunately these low level things usally arent terribly well documented
11:32:48 <minsa> what does this mean ?  :: (t -> t) -> t -> t ?
11:33:25 <parcs> it means function application
11:33:26 <monochrom> if you see "blah :: (t -> t) -> t -> t", it means the type of blah is (t -> t) -> t -> t
11:33:48 <parcs> ...oh
11:33:57 <minsa> can you break down (t -> t) -> t -> t   ?
11:34:00 <parcs> listen to monochrom instead
11:34:15 <luite> Eduard_Munteanu: I'm still figuring out what options I have to implement this, and what security implications each of them has
11:34:27 <hpc> minsa: "foo :: a -> b" means foo is a function from a to b
11:34:40 <hpc> minsa: in this case, the function takes two parameters
11:34:46 <monochrom> yes. firstly fully parenthesize: (t -> t) -> (t -> t). a function that takes a t->t parameter and gives a t->t answer
11:34:52 <hpc> minsa: the first one is of type (t -> t) and the second one is of type t
11:34:57 <hpc> the final result is of type t
11:38:03 <minsa> thnx all.
11:38:58 <minsa> Actually, I understand that much. However, there must be a deeper meaning.
11:39:10 <minsa> there is something missing here.
11:39:55 <Eduard_Munteanu> On a related note, Ingo's proposal to use ftrace hooks for security purposes doesn't sound bad at all.
11:45:01 <dylukes> ^^
11:45:01 <dylukes> float      = option id (char '-' *> pure negate) <*> PT.float lexer
11:45:10 <dylukes> I think applicative style is becoming much more natural for me.
11:52:26 <sm> how come sending mail to haskell-web@haskell.org gave me smtp; 550 Unrouteable address ?
11:56:12 * hackagebot simple-actors 0.0.1 - A simple implementation of the actor model of concurrency  http://hackage.haskell.org/package/simple-actors-0.0.1 (BrandonSimmons)
11:56:15 <sm> web-devel@haskell.org. That always gets me
11:57:10 <o1iver> hi guys. just starting out and I am trying to understand how to implement a Matrix data type. I am looking at Data.Array, but I can't find what "#" means...(and pretty hard to google chars)
11:57:39 <mauke> where do you see #?
11:58:04 <o1iver> MutableArray#
11:58:12 <mauke> where?
11:58:49 <o1iver> or Array# at the definition of Array
11:59:19 <mauke> oh, that
11:59:30 <o1iver> its for the compiler right?
11:59:36 <byorgey> o1iver: you don't need to use anything involving # (which usually indicates GHC internals) to do stuff with matrices.
11:59:37 <mauke> everything is for the compiler
12:00:01 <byorgey> o1iver: to create a matrix you just create an Array that has an index type like (Int,Int)
12:03:04 <o1iver> byorgey: ok I see
12:03:37 <o1iver> byorgey: and what does the exclamation mark mean?
12:04:02 <o1iver> byorgey: actually dont worry, I will read online
12:04:08 <mauke> strictness annotation
12:04:24 <minsa> (t -> t) -> t -> t .... The first function takes (t->t) and produces  t  which got fed into the next function which produces t ?
12:06:16 <o1iver> byorgey: but I still don't understand the Array data declaration (data Ix i => Array i e = Array !i !i !Int (Array# e)
12:07:01 <o1iver> I mean where are the actual values saved...? I expected a list or something
12:07:04 <mauke> you don't have to
12:07:10 <mauke> those are implementation details
12:08:19 <o1iver> mauke: yes, but I am trying to look at this because I want to implement my own Matrix data type. I am struggling with the fact that I want a data type that has a fixed length list of fixed length lists (although I think my thinking is wrong here)
12:08:28 <c_wraith> minsa:  You've got it all twisted about.  (t -> t) -> (t -> t)
12:08:49 <c_wraith> minsa: that's the equivalent, with all parens explicitly added.
12:09:24 <c_wraith> @djinn (t -> t) -> (t -> t)
12:09:25 <lambdabot> f a = a
12:09:30 <mauke> o1iver: build on Array, don't look underneath
12:09:49 <minsa> @djinn (t -> t) -> t -> t
12:09:50 <lambdabot> f a = a
12:09:54 <mauke> o1iver: why do you want an array of arrays instead of a 2d array?
12:10:33 <minsa> c_wraith: my definition is   App2 f x = f (f x)
12:10:48 <o1iver> o1iver: a 2D array is fine, but I am trying to create my own Matrix data type... It's not for production or anything, I am just playing around (towards my goal of creating a Graph data structure)....
12:11:18 <c_wraith> minsa: Yes, in this particular restricted case (t -> t), that works.
12:11:21 <o1iver> mauke: but I would rather take the time to understand this and implement it myself (albeit obviously not near as good) to learn about this stuff
12:11:35 <milkpost> is ther ea way to do multiple lines in ghci?  to do something like `let x = do ...` ?
12:11:36 <c_wraith> minsa: What it means is "give me a function from t to t, and a value of type t, and I will return a value of type t)
12:11:45 <koninkje> milkpost: try :{ and :}
12:11:49 * BMeph wonders why "someone" cannot make a Matrix as a synonym of a 2D Array.
12:11:55 <Favonia> @djinn (A -> B -> C) -> (A -> B) -> A -> C
12:11:55 <lambdabot> Error: Undefined type A
12:11:57 <c_wraith> milkpost: you can also just use layout mode, using {} and ;
12:11:59 <milkpost> koninkje: thanks
12:12:09 <c_wraith> Favonia: type variables are lowercase
12:12:10 <Favonia> @djinn (a -> b -> c) -> (a -> b) -> a -> c
12:12:10 <lambdabot> f a b c = a c (b c)
12:12:26 <o1iver> BMeph: of course I can, but I am trying to implement this stuff by myself (as part of a learning process)...
12:12:51 <parcs> when working with sophisticated data structures that i eventually want to turn into a list, which would be more efficient: `M.toList $ M.filter f x` or `filter f $ M.toList x`, assuming that  they're both functionally the samE?
12:12:57 <Favonia> c_wraith: right :P I copied it from some paper (?) it is S combinator by the way
12:13:26 <BMeph> oliver: And, what do you plan to learn? Besides how one compiler implements things? :)
12:13:29 <parcs> or does it depend on the data structure
12:13:30 <minsa> c_wraith: could you give me some problem to consider so that I could know more about it ?
12:13:50 <minsa> I will try to work through them first.
12:14:03 <Favonia> c_wraith: djinn is smart enough to figure it out :)
12:15:35 <c_wraith> > let s = <*> in s (+) (*3) 5
12:15:36 <lambdabot>   <no location info>: parse error on input `<*>'
12:15:42 <c_wraith> > let s = (<*>) in s (+) (*3) 5
12:15:42 <lambdabot>   20
12:16:14 <minsa> @djinn :t s
12:16:15 <lambdabot> Invalid command
12:16:31 <byorgey> @. djinn type s
12:16:32 <lambdabot> Error: Undefined type Expr
12:16:46 <minsa> @type s
12:16:47 <lambdabot> Expr
12:16:53 <c_wraith> that's not the same s I used
12:17:03 <byorgey> @. djinn type (<*>)
12:17:04 <chrisdone> @seen BONUS_
12:17:04 <lambdabot> Cannot parse command
12:17:05 <lambdabot> Unknown command, try @list
12:17:05 <preflex>  BONUS_ was last seen on #haskell 1 year, 173 days, 5 hours, 49 minutes and 26 seconds ago, saying: osaunders_: usually i think it's defined as a function that uses only the stuff it takes as parameters and function application
12:17:13 <chrisdone> @seen BONUS
12:17:13 <lambdabot> Unknown command, try @list
12:17:13 <preflex>  BONUS was last seen on #haskell 30 days, 6 minutes and 26 seconds ago, saying: yeah i think that's better as well
12:18:00 <dolio> Linux 2.8?
12:18:25 <o1iver> BMeph: well if its implemented by the compiler then I won't check it... but thanks anyway
12:18:31 <minsa> c_wraith: you are using + as function in (+) .
12:19:00 <c_wraith> minsa: putting an operator in parens turns it into a function, in haskell.
12:19:02 <minsa> also (*3) as function.
12:19:24 <c_wraith> yes, that's an operator section.  Technically, I guess (+) is a section, too
12:19:56 <dmwit> :t ap
12:19:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:20:31 <dmwit> ?. djinn type \f g e -> f e (g e)
12:20:32 <lambdabot> f a b c = a c (b c)
12:20:48 <c_wraith> minsa: sections are a shorthand syntax.  (+) is the same as (\x y -> x + y).  (+ 5) is the same as (\x -> x + 5).  (5 +) is the same as (\x -> 5 + x)
12:20:51 <BMeph> oliver: I just meant that any implementation you do will depend on the implementation details of the particular compiler you use; other compilers (JHC, YHC, UHC) may use other implementation-revealing structures. Why not figure out how it gets used, then work on how to support the internals to get it done. :)
12:21:12 <minsa> ok.
12:21:19 <dmwit> http://themetapicture.com/media/funny-barack-michelle-obama-face.jpg NOT BAD
12:22:48 <minsa> show about (<*>) ?
12:23:03 <dmwit> (\x y -> x <*> y)
12:23:06 <dmwit> same pattern
12:23:25 <o1iver> BMeph: well I don't actually want to use Array... I just want to create a Matrix data type and I thought I would look at some existing libs to see how they implement it, I didn't think they would be compiler level data types
12:23:47 <mauke> why not?
12:23:48 <minsa> what does <*> mean ?
12:24:05 <Favonia> @hoogle <*>
12:24:05 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:24:20 <Favonia> @src <*>
12:24:20 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:24:26 <dmwit> It's a class method.
12:24:30 <minsa> ok.
12:24:32 <dmwit> Different implementation for each instance.
12:24:39 <minsa> type class method ?
12:24:41 <dmwit> But, for example:
12:24:57 <dmwit> > [(+3), (*10)] <*> [7, 16]
12:24:58 <lambdabot>   [10,19,70,160]
12:25:27 <dmwit> Yes, type class method.
12:25:39 <dmwit> There is no other kind of class in Haskell. =)
12:27:25 <BMeph> oliver: What to you think of when you think "implementation"? ;)
12:27:44 <BMeph> oliver: Sorry, "What DO you think"? :)
12:27:51 <milkpost> does parseTime *have* to be used in a monadic way?
12:28:18 <rudyl313> how do I find out exactly what functions I need to implement to make my type an instance of the Num typeclass?
12:28:47 <BMeph> @info Num
12:28:47 <lambdabot> Num
12:28:58 <minsa> dmwit: everything is number ? why do you need to use <*> ?
12:29:15 <dmwit> ?undo Num
12:29:15 <lambdabot> Num
12:29:21 <dmwit> minsa: I don't understand the question.
12:29:40 <dmwit> milkpost: No.
12:29:40 <BMeph> rudyl313: If you're using ghci, typing ":i Num" will give you help. :)
12:29:57 <dmwit> ?src Num
12:29:57 <lambdabot> class  (Eq a, Show a) => Num a  where
12:29:57 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:29:57 <lambdabot>     negate, abs, signum     :: a -> a
12:29:57 <lambdabot>     fromInteger             :: Integer -> a
12:29:58 <rudyl313> BMeph: thanks, I'll try that
12:30:21 <rudyl313> Bmeph: so do I have to implement all of those, or can some of them be implied by the others?
12:30:25 <BMeph> rudyl313: Also, dmwit just used lambdabot's equivalent, above. :)
12:30:49 <dmwit> rudyl313: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num tells about default implementations
12:30:54 <mauke> rudyl313: by reading the documentation
12:31:40 <rudyl313> dmwit: thanks, this line was exactly what I was looking for "Minimal complete definition: all except negate or (-)"
12:32:00 <milkpost> dmwit: something as simple as:  formatTime defaultTimeLocale "%Y.%m.%d" $ readTime defaultTimeLocale "%Y-%m-%d" "2011-03-04" does not work for me and I cannot figure out why
12:33:26 <bayda> hello?
12:33:27 <BMeph> rudyl313: There you go, and now you know where/how to get more of such info. :)
12:33:35 <BMeph> bayda: Hi! :)
12:33:41 <Phyx-> hi
12:33:43 <rudyl313> BMeph: exactly :)
12:34:04 <bayda> hey! i've never used irc before but i'm learning haskell and thought this might be a good place to pick up some tips
12:34:14 <Favonia> minsa: I think the type tells the story: f (a -> b) -> f a -> f b. for example, if f = Maybe, it is Maybe (a->b) -> Maybe a -> Maybe b. It suggests that it will return Nothing if the "function" or the "argument" is actually Nothing. In general f is a functor that can do this kind of application. I found the paper here :P http://www.soi.city.ac.uk/~ross/papers/Applicative.html
12:34:18 <Phyx-> bayda: on occasion
12:34:30 <BMeph> rudyl313: "Give a man a match, and he'll be warm for a night; set a man on fire, and he'll be warm for the rest of his life." ;√æ
12:34:43 <bayda> Phyx: what mainly goes on here then?
12:35:17 <Phyx-> bayda: 60-70% haskell, the rest of the time random math talks
12:35:32 <bayda> haha alright, thats good
12:36:33 <Favonia> o1iver: hmm if you're interested maybe you can try "cabal unpack array" to see how others implement the library :P
12:37:16 <o1iver> Favonia: thanks for the tip.. I will try that
12:38:34 <Favonia> o1iver: as far as I know they do write lots of compiler-dependent codes
12:38:51 <o1iver> Favonia: yeah I fear that :-(
12:38:57 <o1iver> Favonia: but I will have a look
12:39:09 <Favonia> o1iver: good luck!
12:39:23 <minsa> dmwit: in [(+3), (*10), (-20)] <*> [7, 16]
12:39:53 <minsa>   [(+3), (*10), (-20)] <*> [7, 16]
12:39:59 <minsa>  [(+3), (*10), (-20)] <*> [7, 16]
12:40:04 <minsa> > [(+3), (*10), (-20)] <*> [7, 16]
12:40:05 <lambdabot>   [10,19,70,160,-20,-20]
12:40:20 <minsa> > [(+3), (*10), (-20)] <*> [7, 16, 30]
12:40:21 <lambdabot>   [10,19,33,70,160,300,-20,-20,-20]
12:41:14 <minsa> > [(+3), (*10), ((-)20)] <*> [7, 16, 30]
12:41:15 <lambdabot>   [10,19,33,70,160,300,13,4,-10]
12:42:06 <minsa> dmwit what does <*> generalize ?
12:43:11 <Favonia> minsa: http://en.wikibooks.org/wiki/Haskell/Applicative_Functors#Applicative_Functors seems to have a gentler introduction than the paper
12:43:50 <minsa> Favonia: thnx
12:45:02 <Favonia> minsa: I believe for lists [], pure is like a singleton
12:45:20 <Favonia> > pure 1 :: [Int]
12:45:20 <lambdabot>   [1]
12:48:22 <cizra2> Hey guys and gals
12:48:41 <cizra2> I need to get the WordNet library up and running. It uses some kind of old Exception mechanism (Exception is a concrete type, not a class)
12:48:56 <cizra2> What's the easiest way to approach it? import Control.OldException?
12:49:08 <cizra2> Or actually fix the issues there?
12:50:30 <monochrom> perhaps Control.OldException is the least amount of work now
12:50:48 <cizra2> *nod* Trying this already
12:52:25 <cizra2> Great, it compiled. Now to test if it works...
12:59:14 <ozatamanm> Does anyone have a favorite diagram drawing library for things like trees and cluster graps? Diagrams package looks nice but it cant do text yet...
13:00:35 <byorgey> ozatamanm: maybe try http://hackage.haskell.org/package/wumpus-drawing ?
13:00:49 <byorgey> ozatamanm: or come help work on diagrams =)
13:00:53 <dylukes> okay so, I'm finding a pattern where,
13:01:03 <dylukes> say I have a parser expression, that returns a float
13:01:12 <dylukes> and then I want to apply a data constructor to it,
13:01:14 <dylukes> I end up with
13:01:18 <dylukes> Data <$> (‚Ä¶)
13:01:18 <dylukes> or
13:01:23 <dylukes> fmap Data $ ...
13:01:31 <byorgey> dylukes: right
13:01:34 <dylukes> It'd be nice if I could combine <$> with $
13:01:46 <dylukes> is there an existing pattern for this?
13:01:52 <dylukes> Just feels ugly to use fmap or parens.
13:02:04 <ozatamanm> byorgey: :) wish i had more time
13:02:18 <byorgey> dylukes: wait, what was the   Data <$> ...  line?  I just see gobbledygook in the parens
13:02:33 <dylukes> heres an actual example
13:02:34 <dylukes> number     = fmap NumberAST $ option id (char '-' *> pure negate) <*> PT.float lexer
13:02:37 <byorgey> ozatamanm: don't we all =)
13:02:39 <dylukes> it'd be nicer here if I could do like
13:02:44 <dylukes> NumberAST <$$> ...
13:02:51 <dylukes> (where <$$> is fmap . $
13:02:55 <dylukes> kinda)
13:03:06 <dylukes> not sure how to put that together though, or if it already exists.
13:03:58 <ddarius> dylukes: ($) is id.  fmap . ($) is fmap.
13:04:11 <ddarius> Use <$> as you yourself mentioned.
13:04:26 <dylukes> Data <$> ‚Ä¶ doesn't work though
13:04:27 <dylukes> ie
13:04:33 <dylukes> number     = NumberAST <$> option id (char '-' *> pure negate) <*> PT.float lexer
13:04:42 <dylukes> is invalid, since <$> binds too tightly.
13:04:52 <ozatamanm> byorgey: crossing my fingers for diagrams with text, thanks for the wumpus suggestion, ill take a look at that
13:05:27 <dylukes> actually, I just want a right associative variant of <$>
13:06:10 <ddarius> dylukes: Right associativity would only matter if you had more than one (<$>) on the line.
13:06:26 <dylukes> true.
13:06:33 <dylukes> anyways, is there an existing operator or not?
13:06:36 <dylukes> Or do I just need to make it myself.
13:06:51 <ddarius> Also, (<$>) and (<*>) are designed to work nicely with each other.
13:07:16 <dolio> Oh, you are around.
13:07:24 <dylukes> this isn't a question aout whats "designed" to work one way or not
13:07:27 <dylukes> but how it IS working
13:07:32 <dylukes> number     = NumberAST <$> option id (char '-' *> pure negate) <*> PT.float lexer
13:07:33 <dylukes> this
13:07:35 <dylukes> does not work
13:07:36 <dylukes> period.
13:07:38 <dylukes> :|
13:07:47 <dylukes> @src seq
13:07:47 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:07:51 <dylukes> @src ($)
13:07:51 <lambdabot> f $ x = f x
13:08:02 <dylukes> @src (<$>)
13:08:03 <lambdabot> f <$> a = fmap f a
13:08:45 <dylukes> If I where to parenthesize all of the option statement, it'd work
13:09:03 <dylukes> well, actually it wouldnt.
13:09:07 <ddarius> You mean everything to the right of (<$>).  The option expression is already a unit.
13:09:11 <ddarius> dolio: No.
13:09:14 <dylukes> yep
13:09:16 <dolio> Okay.
13:09:23 <dylukes> so, how would you suggest doing what I want?
13:09:44 <dylukes> ‚Ä¶am I the only one disturbed by the incoming underscore zombie army?
13:10:00 <dylukes> er anyways, ddarius
13:10:04 <dylukes> what do you suggest
13:10:27 <dolio> Probably a server died or something.
13:10:45 <monochrom> zombies come and go
13:12:05 <twanvl> dylukes: the result of option will be Parser (Float ->Float), so here NumberAST is applied to two arguments, the first of type (Float -> Float) and the second of type Float
13:12:20 <dylukes> NumberAST only has one parameter.
13:12:33 <dylukes> It should not be applied to them both...
13:12:42 <ddarius> dylukes: The way that pattern of <$> and <*> works is that f a b becomes f <$> a <*> b.  So what you want is f to be (\g x -> NumberAST (g x))
13:12:44 <dylukes> anyways, I need to rewrite it anyways
13:13:08 <dylukes> ddarius: I need to rewrite it to handle floats and/or decimals anyhow
13:13:11 <twanvl> then you need to put a different function there: (\a b -> NumberAST (a b))
13:13:12 <dylukes> once I do that I'll work on cleaning it up
13:13:54 <ddarius> @pl \a b -> NumberAST (a b)
13:13:55 <lambdabot> (NumberAST .)
13:14:07 <ddarius> So (NumberAST .) <$> ... <*> ...
13:14:19 <adimit> Does anybody have a recommendation on whether to prefer the iteratee or enumerator library on hackage for iteratee-style IO?
13:14:50 <monochrom> enumerator may be simpler
13:15:54 <adimit> ‚Ä¶ but it seems that iteratee has more docs available, no? I haven't looked at the APIs yet, looking now.
13:16:19 <waqf> I have two parsec parsers: foo :: Parser String; bar :: Parser a. What is the best way to "compose" these parsers so that bar parses the string returned by foo?
13:18:56 <twanvl> waqf: there is no way to do that, short of calling the parse function with the returned string as input, but you probably shouldn't do that
13:19:09 <ddarius> twanvl: There are ways.
13:19:24 <ddarius> twanvl: That said, it's not clear what behavior waqf wantts.
13:20:01 <ddarius> And doing do s <- foo; case parse bar s of ... isn't unreasonable.
13:20:34 <Peaker> adimit: I saw some tutorials on enumerators, which seemed nice..
13:20:43 <Peaker> I think all the iteratee packages use very bad names :-(
13:21:02 <waqf> twanvl: what's wrong with using the parse function with the returned string (assuming I handle errors properly)?
13:21:12 <waqf> ddarius: what ways?
13:21:40 <twanvl> precisely that handling errors properly is very tricky
13:22:00 <ddarius> waqf: Ways that you probably don't want.  If the way twanvl and I described works, do that.
13:22:20 <Raphaeljavaux> hey
13:22:20 <waqf> ddarius: well now I'm curious :)
13:22:27 <adimit> Peaker: I honestly just want something that is not a lazy bytestring, because resource usage is so unpredictable. I have the feeling, between the article in Monad.Reader, and blogposts online, that iteratee might be easier to understand, because there's just more stuff.
13:22:43 <adimit> Peaker: if you could point me to the enumarator tutorials though, I'd like to read them, too.
13:24:48 <Peaker> adimit: http://www.yesodweb.com/blog/enumerators-tutorial-part-1
13:24:53 <Peaker> adimit: and there are also parts 2,3
13:24:58 <Peaker> (same URL up to last char)
13:25:15 <adimit> Peaker: I thank you; this might prove very useful :-)
13:25:19 <Raphaeljavaux> I'm a bit new with Haskell, and I have a little question about map & mapM when used with actions. Why/How the first evaluate the actions while the second doesn't
13:25:30 <Raphaeljavaux> s/first/second
13:25:48 <Peaker> Raphaeljavaux: do you mean "execute" when you say "evaluate"?
13:25:55 <Raphaeljavaux> yes
13:26:09 <roconnor_> Raphaeljavaux: nether of them execute any actions
13:26:17 <roconnor_> that's the secret :)
13:26:27 <monochrom> you need >>= to compose actions. mapM uses that. map doesn't.
13:26:53 <Peaker> Raphaeljavaux: mapM f xs = sequence (map f xs)
13:27:01 <Peaker> Raphaeljavaux: do you know what sequence is?
13:27:02 <roconnor_> for example, try out: do () <- const (mapM_ print ["hello"]) (return ())
13:27:10 <roconnor_> and see what doesn't happen
13:33:21 <Raphaeljavaux> Peaker: roconnor_ monochrom : thx
13:33:24 <Peaker> Raphaeljavaux: when you use     map print [1,2]   you get a list equivalent to:  [print 1, print 2]      when you use    mapM print [1,2]    you get a single action equivalent to:   do { x <- print 1 ; y <- print 2 ; return [x,y] }
13:35:10 <Raphaeljavaux> and, how did you force strict evaluation for a whole list ?
13:35:32 <roconnor_> there is no need to
13:35:39 <Peaker> Raphaeljavaux: I didn't, why would I do that?
13:37:19 <Raphaeljavaux> I was comparing the speed of two algorithms with a list of random number as input
13:37:34 <roconnor_> it is important to underdstand that a value of type IO foo when evaluated still doesn't do anything.  IO foo is simply a recipie (kinda like a shell script) that will produce a foo value.  It is only later when sequenced into main that the run time system will execute IO.
13:37:59 <Raphaeljavaux> but it takes more time to generate the differents number than execute the algorithm
13:39:32 <Raphaeljavaux> I tried something like this :
13:39:32 <Raphaeljavaux> force xs = force xs
13:39:32 <Raphaeljavaux>     where force [] = xs
13:39:32 <Raphaeljavaux>                force' (x:xs') = x seq force' xs'
13:40:49 <roconnor_> Raphaeljavaux: doing something like "evaluate (sum list)" would be a quick way to force the values of the list.
13:40:55 <roconnor_> though not the most elegant
13:42:31 <Raphaeljavaux> ok
13:49:36 <o1iver> hey could anybody have a look at this short piece of code (http://hpaste.org/paste/47280/tmp0001). for the Show instance I am getting the error "could not deduce (a ~ [Char]) from the context ... "
13:51:00 <monochrom> what is the type of m?
13:51:11 <o1iver> monochrom: data Matrix a = Matrix [[a]]
13:53:43 <monochrom> pad' :: [[Char]] -> [[Char]]
13:54:32 <MHD0> Anybody here know something about the LLVM package?
13:54:50 <dmwit> m :: [[a]] => concat m :: [a] => map length (concat m) is a problem
13:54:57 <dmwit> o1iver: ...in calcLength
13:55:23 <o1iver> o1iver: yes?
13:56:10 <monochrom> concat . pad' :: [[Char]] -> [Char]
13:56:15 <doserj> oliver: your instance declaration only works if the element type is String
13:56:31 <dmwit> Also, you need to show each element before padding them, which you aren't doing.
13:56:33 <o1iver> doserj: because of unlines?
13:56:35 <monochrom> map (concat . pad') :: [[[Char]]] -> [[Char]]
13:56:43 <dmwit> o1iver: No, because of pad'.
13:56:46 <monochrom> but m is not known to be [[[Char]]]
13:57:05 <o1iver> monochrom: ah yeah that makes sense
13:57:05 <dmwit> There are several problems with this function. =P
13:57:06 <o1iver> ok
13:57:30 <o1iver> dmwit: actually I tried it as a normal function, and not as an instance and it worked
13:57:52 <dmwit> It probably works for Matrix String.
13:58:14 <o1iver> dmwit: yes thats the problem. I am going to look over it again (and use show)
13:58:38 <monochrom> the normal function does not have a polymorphic type
13:59:12 <dmwit> o1iver: As a side-note, it's generally recommended that "Show" and "Read" be reserved for producing and consuming strings that are valid Haskell code.
13:59:44 <dmwit> o1iver: If you want human-readable strings, it's generally considered good form to name the function that does that as some variant of "prettyPrint".
14:00:23 <o1iver> dmwit: ok good point
14:00:31 <o1iver> dmwit: I am going to change that then
14:00:36 <dylukes> :t bind
14:00:37 <lambdabot> Not in scope: `bind'
14:00:38 <dylukes> :t bind2
14:00:38 <lambdabot> Not in scope: `bind2'
14:01:02 <dmwit> :t (>>=) -- dylukes, this is often pronounced "bind", is it what you're looking for?
14:01:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:01:08 <dylukes> nope.
14:01:37 <dylukes> @hoogle (Monad m) => (a -> b -> c) -> m a -> m b -> m c
14:01:37 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:01:37 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:01:37 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
14:02:12 <o1iver> thanks guys I now know what the problem is and will look at it again...Thanks!
14:04:36 <dylukes> @hoogle (Monad m) => (a -> b ->  m c) -> m a -> m b -> m c
14:04:37 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:04:37 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
14:04:37 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:04:54 <dylukes> meh, each enough to write it manually
14:04:56 <dylukes> easy*
14:05:33 <hpc> dylukes: liftM2 doesn't do it?
14:05:40 <dylukes> notice the m c
14:05:42 <dylukes> :t (>>=)
14:05:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:05:45 <milkpost> could someone explain how to do a "toLower" mapping but when using overloaded strings?
14:05:45 <hpc> ah
14:05:52 <dmwit> :t (join .) . liftM2
14:05:53 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
14:05:53 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
14:05:53 <lambdabot>     In the second argument of `(.)', namely `liftM2'
14:06:02 <dylukes> Its easy to write
14:06:11 <dmwit> ?pl \f x y -> join (liftM2 f x y)
14:06:11 <lambdabot> ((join .) .) . liftM2
14:06:16 <dylukes> bind2 f m1 m2 = do {x1 <- m1; x2 <- m2; f x1 x2}
14:06:18 <dylukes> :|
14:06:19 <dmwit> Not enough dots, of course.
14:06:31 <dmwit> :t ap
14:06:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:06:41 <milkpost> np, i'm an idiot
14:06:51 * BMeph asks for MOAR DOTS plzkthxbai! ;√æ
14:07:16 <shachaf> @let (.::) = (.) . (.) . (.)
14:07:16 <lambdabot>  Defined.
14:07:21 <shachaf> @ty join .:: liftM2
14:07:21 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:08:13 <dmwit> :t let bind2 f x y = liftM head (zipWithM f [x] [y]) in bind2
14:08:13 <lambdabot> forall a b (m :: * -> *) a1. (Monad m) => (a -> b -> m a1) -> a -> b -> m a1
14:08:46 <shachaf> @src zipWithM
14:08:47 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
14:09:57 <Phyx-> @ty (.::)
14:09:58 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:10:02 <Phyx-> ...
14:10:14 <Phyx-> yeah...
14:10:46 <dmwit> :t let bind2 f x y = liftM head . sequence $ [f x y] in bind2
14:10:47 <lambdabot> forall t t1 (m :: * -> *) a. (Monad m) => (t -> t1 -> m a) -> t -> t1 -> m a
14:10:51 <Phyx-> @ty let (.) = \f g x-> f (g x) in (.)
14:10:51 <dmwit> what
14:10:52 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
14:10:59 <Phyx-> @ty let (.) = \f g x-> f (g x) in (.) . (.) . (.)
14:11:00 <lambdabot> forall t t1 t2 t3 t4. (t2 -> t3) -> (t -> t1 -> t4 -> t2) -> t -> t1 -> t4 -> t3
14:11:01 <dmwit> oh
14:11:13 <dmwit> Oh, yeah, nonsense.
14:11:49 <dmwit> I still like this one best: \f x y -> join (liftM2 f x y)
14:11:52 <Phyx-> :t liftM2 join
14:11:53 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> a2 -> r) -> m a2 -> m r
14:12:10 <Phyx-> @pl \f x y -> join (liftM2 f x y)
14:12:10 <lambdabot> ((join .) .) . liftM2
14:12:14 <Phyx-> lol
14:12:31 <dmwit> Phyx-: You're six minutes too late. =)
14:12:47 <Phyx-> dmwit: i wa watching tv :P
14:13:03 <dmwit> :t fmap (fmap (fmap join)) liftM2
14:13:04 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:13:13 <dmwit> oh hyes
14:13:24 <Phyx-> not surprisng
14:13:30 <Phyx-> since that's the same as above
14:13:36 <Phyx-> (.) = fmap in lambdabot
14:13:39 <Phyx-> always hated that
14:13:42 <dmwit> Yes, I know.
14:13:53 <Phyx-> :)
14:14:05 <Phyx-> I was just stating the obvious
14:14:07 <Phyx-> hhehe
14:14:26 <Phyx-> gawd, my laptop screen makes me want to punch it
14:14:32 <Peaker> Even if it wasn't the same in lambdabot it would be the same, as dmwit's fmap specializes to Prelude's (.) anyway
14:15:25 * ddarius actually finds the Functor version makes the (.) . (.) more clear.
14:15:25 <Phyx-> Peaker: yeah I know
14:15:48 <olsner> ddarius: fmap fmap fmap?
14:16:02 <Phyx-> ddarius: this is a rare exception :)
14:16:23 <dmwit> onResult (onResult join) . liftM2
14:16:29 <hpc> > fix fmap
14:16:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
14:16:37 <Peaker> @type  (result . result) join liftM2
14:16:38 <lambdabot> Not in scope: `result'
14:16:38 <lambdabot> Not in scope: `result'
14:16:57 <Peaker> @let result f g x = f (g x)
14:16:58 <lambdabot>  Defined.
14:17:00 <Peaker> @type  (result . result) join liftM2
14:17:01 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
14:17:01 <lambdabot>     Probable cause: `liftM2' is applied to too many arguments
14:17:01 <lambdabot>     In the second argument of `(result . result)', namely `liftM2'
14:17:05 <dmwit> :t (result . result) join . liftM2
14:17:05 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:17:20 <dmwit> :t join (.) result join . liftM2
14:17:21 <lambdabot>     Occurs check: cannot construct the infinite type: a = t -> a
14:17:21 <lambdabot>     Probable cause: `result' is applied to too few arguments
14:17:21 <lambdabot>     In the second argument of `join', namely `result'
14:17:28 <Peaker> @type  (result . result . result) join liftM2
14:17:28 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:17:32 <dmwit> Oh, right, both "result" arguments would have to have the same type.
14:17:42 <Peaker> @type result
14:17:43 <lambdabot> forall t1 t2 t. (t1 -> t2) -> (t -> t1) -> t -> t2
14:17:52 <Phyx-> really need to call HP...
14:18:07 <Peaker> oh, right, you need 3 level deep into the (->)
14:18:29 <hpc> you need to go deeper
14:18:32 <Peaker> @let infixr 2 ~> ; (f ~> g) x = f >>> x >>> g
14:18:33 <lambdabot>  Defined.
14:18:35 <hpc> R E C U R S I O N
14:18:39 <Phyx-> (->) all the way down
14:18:45 <Peaker> @type (id ~> id ~> id ~> join) liftM2
14:18:46 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:18:58 <Peaker> this is like "pattern-matching" on liftM2's function type :)
14:19:26 <Phyx-> you guys are like doing magic
14:19:28 <shachaf> @ty fmap fmap fmap fmap fmap fmap fmap fmap join liftM2
14:19:28 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:19:37 <ddarius> Phyx-: You have only yourself to blame for getting an HP.
14:19:38 <shachaf> Clearly this version is superior, because it lacks parentheses.
14:19:42 <hpc> Phyx-: oh, this is nothing
14:19:54 <Phyx-> ddarius: no.. I have myself to blame for punching it
14:20:17 <Peaker> This is the kind of function we ought not to have to write at all -- it should be inferred from the type
14:20:23 <Phyx-> ddarius: and besides, I find HP's business line notebooks superior to everything thing else out there
14:20:31 <Peaker> At worst, we should have to select from a few djinn results of our liking
14:20:31 <Phyx-> hpc: my haskell foo is weak
14:20:41 <ddarius> Phyx-: I doubt you've tried everything else out there.
14:20:51 <dmwit> Peaker: But there are countably many ways to write this.
14:21:00 <Phyx-> ddarius: taking it a bit too literally..
14:21:05 <Phyx-> but point taken..
14:21:12 <dmwit> weirdBind2 f x y = x >> x >> y >> y >> y >> x >> realBind2 f x y
14:21:21 <hpc> Phyx-: the place i work swears on thinkpads
14:21:52 <shachaf> Can we have map = fmap in lambdabot?
14:21:52 <Phyx-> hpc: i've never been wronged with an HP Compaq before, had 4 different ones already, all rock solid
14:22:03 <Phyx-> hpc: and their world wide service is top notch
14:22:12 <hpc> :t map -- shachaf
14:22:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:22:15 <Phyx-> hpc: always had 24 hours turnaround for any repairs
14:22:16 <hpc> ...oh
14:22:20 <hpc> Phyx-: nice
14:22:35 <Phyx-> hpc: last time i broke a screen they replaced it the same day
14:23:38 <Phyx-> this laptop is on it's last legs also.. i'm looking into getting a 8560w
14:23:39 <Peaker> dmwit: Sure, djinn is good at finding the "sane" solution first
14:24:27 <Peaker> dmwit: I think we could have builtin support for SECs in our editor where we highlight some term, we get its type shown somewhere, then we can browse in that type, and "apply" functions to that part of the type, automatically forming the correct SEC in the code
14:24:53 <dmwit> I don't know what SEC means, but it sounds a lot like what Agda does.
14:25:01 <dmwit> I think it would be great to have Agda-style holes.
14:28:18 <dankna> Peaker: that's a good feature, yes.  I think I shall implement it in Te.
14:28:24 <dankna> Peaker: what does SEC stand for?
14:31:24 <Peaker> dankna: Semantic Editor Combinator
14:31:29 <Peaker> @where SEC
14:31:29 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
14:31:33 <Peaker> dankna: what's Te?
14:31:42 <dankna> my structure editor that I'm writing
14:31:52 <Peaker> dankna: I didn't know you were.. is it related to our discussions?
14:31:55 <dankna> yes
14:32:06 <Peaker> dankna: ah, cool! what are you planning?
14:32:14 <dankna> specifically, it will incorporate as much code from the treeedit prototype as possible, but I have my own ideas for certain things like the data model
14:32:28 <dankna> well, it'll initially support Mac and terminal front-ends
14:32:58 <dankna> I'll release an 0.9 version when it handles the full Haskell AST
14:33:34 <dankna> right now it has, uh, a splash screen :D
14:33:46 <dankna> but that's because my efforts have gone into getting Cabal to build Mac .app bundles
14:34:13 <dankna> (which I have it doing, albiet only in prototype.  when dcoutts accepts my patches that I've submitted so far, I'll start work on getting that prototype integrated into Cabal's core)
14:34:37 <Peaker> dankna: ah, what about revision control? That was the main thing I was working on.. having branches but no merges is not very useful :-)  I was thinking of reading more about darcs to see if it was worth immitating
14:34:50 <dankna> ah yeah, 0.9 won't handle it but I know how I'll be doing it
14:35:08 <Peaker> dankna: by "it" do you mean merges? How?
14:35:42 <dankna> no, I don't know the details of how merging will work; I know how I'll be storing changes
14:35:47 <MHD0> This is warping my brain
14:36:27 <dankna> the thing to remember is that it's not space-efficient to store every revision of the entire tree
14:36:33 <dankna> you need to store changes only
14:36:40 <dankna> indeed, you need to store them compressed!
14:37:35 <dankna> I plan to read more about git's data model, since git scales better than darcs
14:37:36 <Phyx-> MHD0: what is?
14:37:48 <dylukes> Alright
14:37:51 <dylukes> I've got a fun problem for you guys
14:37:51 <dylukes> https://gist.github.com/999532
14:37:57 <dylukes> a bit wordy...
14:38:03 <dylukes> but maybe just focus on line 56+
14:38:09 <dylukes> the rest works, I've checked ^^
14:38:38 <MHD0> Phyx-: Trying to implement a statically, in-haskell type checked Monadic LLVM code generator Writer monad
14:38:53 <MHD0> Phyx-: Bit harder than I thought.
14:38:57 <dylukes> I'm trying to wrap an arbitrary simple arithmetic expression in a function so I can use it in haskell.
14:39:21 <Phyx-> MHD0: lol, ok. gl!
14:39:51 <MHD0> Phyx-: Think you can help?
14:39:52 <Botje> dylukes: random remark: your bind2 function is Control.Monad.liftM2 :)
14:39:57 <Peaker> dankna: well, darcs has a much simpler semantic model of repositories
14:39:58 <MHD0> Phyx-: :P
14:40:03 <dylukes> Botje: nope.
14:40:06 <dylukes> :t liftM2
14:40:06 <Botje> ah, no, f is monadic there
14:40:06 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:40:08 <Peaker> dankna: a "set of patches" is much nicer than a "snapshot of history"
14:40:09 <dylukes> notice,
14:40:12 <dylukes> 'r' is not 'm r'
14:40:19 <dylukes> there you are.
14:40:21 <dylukes> anyways
14:40:25 <dankna> Peaker: that's certainly true.  and I really like the darcs way of thinking...
14:40:29 <Peaker> dankna: though "patches" are not well defined in the textual realm, they are far better defined when they are actual user-generated directly by making editing diffs
14:41:01 <Peaker> dankna: I think darcs kind of sucks because of its commitment to a particular format of textual diffs...  Git is more flexible because it allows running heuristic diffs after-the-fact
14:41:13 <dylukes> https://gist.github.com/999532
14:41:15 <Peaker> But if you have ideal diffs from the get-go, the darcs approach may be better
14:41:15 <dylukes> TT^TT
14:41:17 <dylukes> please help.
14:41:20 <dylukes> I'm stuck with this haha.
14:41:34 <dylukes> The error only happens when I actually try to 'run'
14:42:06 <aavogt> that doesn't mean the error isn't there without run
14:42:35 <dankna> Peaker: hmm, yes, hmm
14:42:53 <dylukes> If I annotate run :: String -> a specifically,
14:42:57 <dylukes> I get a different error...
14:43:12 <aavogt> but the same idea that instances are missing?
14:43:22 <Peaker> dylukes: maybe you should use -Wall and add the type signatures it suggests? It would ease understanding there
14:43:23 <dylukes> oh crap
14:43:26 <dylukes> I think I see the mistake
14:43:49 <dylukes> maybe...
14:43:49 <dylukes> well
14:43:59 <dylukes> this new error is more informative ^^
14:44:04 <dylukes> So, I think I'm just Missing a parameter.
14:44:42 <Peaker> dankna: I guess maybe something like darcs can be extended to include the notion that sets of patches are equivalent (as functions from content to content), allowing the same flexibility of git's after-the-fact diff, though I am not sure how that would work in practice
14:45:00 <dankna> hmmm
14:48:30 <aavogt> preflex: zdec hinotifyzm0zi3zi1_SystemziINotifyziMasks_All_static_entry
14:48:31 <preflex>  hinotify-0.3.1_System.INotify.Masks_All_static_entry
14:54:30 <cmccann> dylukes, BTW rather than your bind2 what you can do is define f =<* x = f >>= (x >>=)
14:54:37 <cmccann> then you can write it infix, Applicative style
14:54:41 <cmccann> e.g. binOp op <$> compileExpr e1 =<* compileExpr e2
14:54:50 <dylukes> for now, I'm good.
14:54:54 <dylukes> ^^
14:55:03 <dylukes> Just need to work out this goddamn type erorr.
14:55:14 <dylukes> lemme paste it as it is nw
14:55:32 <dylukes> https://gist.github.com/999555
14:56:08 <cmccann> just mentioning, since that sort of "fooN" function for a specific number of arguments tends to be clumsy
14:56:29 <dylukes> ah
14:56:35 <dylukes> I think what it might be...
14:56:56 <dylukes> hm‚Ä¶ nmd...
14:57:32 <dylukes> well, it should be (Ret (Value Double) Double)
14:57:39 <dylukes> I guess it can't infer the r1
15:01:04 <Botje> dylukes: what if you give makeFunction an explicit type?
15:01:15 <dylukes> thats what I'm working on right now.
15:02:25 <dylukes> I'm not sure what the params to CodeGenFunction are supposed to be though
15:02:26 <dylukes> :(
15:02:33 <dylukes> Like, what they're supposed to represent
15:02:54 <dylukes> makes it a bit harder
15:03:45 <dylukes> ugh
15:03:48 <dylukes> this is a type mess >_<
15:05:53 <Peaker> cmccann: you missed out on a big bind2 party
15:06:14 <cmccann> Peaker, oh?
15:06:35 <Peaker> cmccann: many different definitions of it
15:07:27 <cmccann> I was just mentioning the version that I have sitting around in my own libraries :P
15:07:32 <Peaker> I don't like operators that aren't part of the "community jargon".. operators that aren't well known just impede readability
15:07:55 <cmccann> heh
15:08:13 * djahandarie still likes his >>>> and >><< 
15:08:17 <Peaker> It's making people say "Haskell is like Perl"
15:08:30 <Peaker> and makes Python code seem more attractive :P
15:08:44 <aavogt> perl doesn't let you define new infix though, right?
15:08:52 <cmccann> Peaker, I was at least careful to pick a name with mnemonic value via analogy to standard operators
15:09:39 <cmccann> if an operator looks like a mixture of <*> and =<< and is used in a monadic expression it's pretty obvious what it means
15:10:44 <shachaf> =>**><<*
15:10:49 <Peaker> cmccann: I think the existing mnemonics already suck... <$> and <*> do not nicely denote their relationship...
15:10:53 <Peaker> @type (<*)
15:10:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
15:11:05 <Peaker> What is this mnemonic supposed to mean?
15:11:17 <cmccann> Peaker, they don't, but they're in the standard libraries
15:11:45 <aavogt> keep the result which is being pointed at
15:11:46 <Peaker> cmccann: I agree that if the mnemonics are reasonably clear, it can be a good trade-off.. I don't think they can be clear if the base operators in the stdlib have bad mnemonics in the first place
15:11:48 <cmccann> being consistent with silly mnemonics is more comprehensible than inventing all new symbols that are more sensible
15:12:05 <aavogt> @ty (<$)
15:12:05 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
15:12:17 <Peaker> cmccann: but less comprehensible than English names, most of the time
15:12:42 <cmccann> in the case of something like <*> the less I have to interpret it the better
15:12:53 <cmccann> english names like `ap` I tend to read
15:12:55 <Peaker> "bind2" may require looking up a type once, but then I will remember what it is for a long time.. I don't even remember how to spell that operator you invented
15:12:59 <cmccann> it's easier to skim over line noise like <*>
15:13:37 <Peaker> I don't think lifting stuff is "noise"
15:13:54 <BMeph> cmccann: Did you get bored with your usual handle? :)
15:14:04 <cmccann> BMeph, hm?
15:14:34 <cmccann> Peaker, it mostly is, but since we don't have idiom brackets I'll stick with infix line noise
15:14:59 <cmccann> whereas seeing stuff like bind2 or liftM written infix is just messy and hard to read to my eye
15:15:39 <copumpkin> cmccann: just use SHE
15:15:40 <Peaker> I don't think bind2 is supposed to be infix, since it lifts a binary function
15:15:55 <cmccann> most lifting operators are just there to do what should be obvious from context
15:16:03 <cmccann> no, I meant liftM infix, not bind2
15:16:14 <cmccann> both annoy me for different reasons
15:16:20 <cmccann> and seem much less readable
15:16:28 <Peaker> cmccann: mempty = pure mempty ; mappend = liftA2 mappend
15:16:42 <Peaker> is it clear from context if you just write:  mempty = mempty ; mappend = mappend ?
15:17:08 <Peaker> liftM is common eonugh that the stdlib ought to have a symbol, and it does: <$>
15:17:17 <cmccann> yes, that's the one context where I prefer doing it that way :P
15:17:51 <dylukes> Peaker: Perl is inherently unreadable
15:17:56 <dylukes> Haskell is unreadable if you make it unreadable.
15:18:20 <ben> ‡≤†_‡≤†
15:18:22 <Peaker> dylukes: both can be made readable or unreadable. I think Perl encourages unreadability more than Haskell. But having too many operators in Haskell is definitely a factor contributing/encouraging unreadability
15:18:34 <cmccann> but other than things like "foo = liftA2 bar" I really dislike functions like the liftM/liftA family
15:18:35 <dylukes> Agreed.
15:18:44 <dylukes> @let ‡≤†_‡≤† a b = a + b
15:18:45 <lambdabot>   Illegal character ''\3232''
15:18:49 <dylukes> :(
15:18:53 <dylukes> @let  ‡≤† a b = a + b
15:18:54 <lambdabot>   Illegal character ''\3232''
15:18:56 <dylukes> booo
15:19:00 <Martty> @let æ»≥Á = 2
15:19:01 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (65533) is outside of bounds (0,255)
15:19:39 <Peaker> cmccann: I would prefer to have a simpler naming convention:  lift0 = pure = return ;  lift1 = liftA = fmap = liftM = <$> ; lift2 = liftA2 = liftM2 ; ... so we only have liftN even though they are in different type classes
15:19:40 * cmccann doesn't see why operators are inherently more or less readable than words
15:20:04 <Peaker> cmccann: because words have meanings associated with them in a dictionary -- and are tokenized as a single token by our brain
15:20:17 <Peaker> and single tokens are easier to remember
15:20:38 <Peaker> (especially with the dictionary association)
15:20:52 <maurer_> @let (‡≤†_‡≤†) x y = x + y
15:20:53 <lambdabot>   Illegal character ''\3232''
15:20:58 <maurer_> Oh, it works in ghci :/
15:21:26 <cmccann> Peaker, I disagree and I'm not sure what else to say
15:21:38 <cmccann> because I find operators far more readable and easier to parse in many contexts
15:22:01 <shachaf> > let ‡≤†_‡≤† = (+) in ‡≤†_‡≤† 1 2
15:22:02 <lambdabot>   3
15:22:08 <cmccann> maybe your experience is different in which case the best advice I can give you is to not attempt to read my code :)
15:23:31 <Peaker> cmccann: =<* is tokenized as 3 "things", so takes more effort to remember than "bind2" which is just 2 things, with some reasonable "idea" behind why they were chosen, allowing reproducing that decision more easily --> Leading to having to remember less,  but maybe it's because I don't understand the reason you choose =<*
15:24:21 <cmccann> I chose it by analogy to <*> and =<<
15:25:02 <cmccann> because what it does is essentially a mixture of the two
15:25:23 <cmccann> and used in context, can typically be ignored because what it does is the only thing that typechecks
15:25:30 <cmccann> e.g., line noise to skim over
15:25:45 * hackagebot silently 1.1.4 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.1.4 (TrystanSpangler)
15:25:53 <aavogt> there are lots of choices for which order the side effects happen though
15:26:39 <cmccann> aavogt, yes and no
15:27:31 <dylukes> hm
15:27:38 <dylukes> One thing I wonder about a pattern for
15:27:38 <dylukes> is
15:27:40 <cmccann> aavogt, <*> has to choose an ordering, staying consistent with that I don't think there's any other way to do something like =<*
15:27:55 <aavogt> @hoogle <**>
15:27:55 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
15:28:06 <dylukes> foo = do
15:28:06 <dylukes>     x <- someThing
15:28:06 <dylukes>     case x of ...
15:28:09 <dolio> @type \f x -> f >>= (x >>=)
15:28:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> m b) -> m a -> m b
15:28:21 <dylukes> is there anyway to remove the use of the x binding?
15:29:00 <shachaf> There's no direct caseM syntax, if that's what you mean.
15:29:19 <dolio> @type \f x -> join (x <**> f)
15:29:20 <lambdabot> forall (m :: * -> *) a a1. (Applicative m, Monad m) => m (a -> m a1) -> m a -> m a1
15:30:20 <cmccann> dolio, right, it's either <*> or (flip <*>), hence I specified being consistent with <*>
15:30:54 <dolio> It's the opposite of =<<, though, although that has no choice.
15:31:36 <aavogt> dylukes: if the stray x polluting the namespace is the issue, you could rewrite it as    foo = do { resultOfCase <- someThink <**> \x -> case x of ... }
15:32:09 <dylukes> Not sure I udnerstand.
15:32:13 <dylukes> :t (<**>)
15:32:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
15:32:20 <dylukes> hm.
15:32:24 <dylukes> Haven't seen that one before :\
15:32:33 <cmccann> dolio, I wouldn't say it's opposite as such, it's not the same thing
15:33:15 <djahandarie> @type flip (<*>)
15:33:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
15:33:53 <aavogt> dylukes: oops, it should have been >>= not <**>
15:34:00 <dylukes> >_>
15:34:00 <dolio> (<**>) is not actually flip (<*>), either, incidentally.
15:34:03 <aavogt> djahandarie: that's actually a different function
15:34:30 <dylukes> @src (<**>)
15:34:30 <lambdabot> (<**>) = liftA2 (flip ($))
15:34:40 <djahandarie> Oh, right, oops :p
15:34:57 <cmccann> yeah, I'm not sure why I wrote flip (<*>) earlier either
15:35:12 <nihtml> @src (<*>)
15:35:13 <lambdabot> Source not found. Do you think like you type?
15:35:30 <dolio> Anyhow, (=<<) has with it (<<), which is (<*), except in the opposite order.
15:35:36 * cmccann shrugs
15:35:47 <cmccann> anyway, I'm not really out to sell anyone on using my operators :P
15:35:50 <dolio> So there's sort of a right-to-left character of the effects.
15:35:55 <aavogt> > let dj = flip (<*>) in map execWriter [tell [1] `dj` (tell [2] >> return const), tell [1] <**> (tell [2] >> return const)]
15:35:57 <lambdabot>   [[2,1],[1,2]]
15:35:58 <ddarius> :t flip . (<*>) . flip
15:35:59 <lambdabot> forall a b a1. (a1 -> a -> b) -> a -> (a -> a1) -> b
15:36:10 <cmccann> I just don't buy the opposite idea that avoiding operators is necessarily better
15:36:17 <dolio> I don't really care, except =<* looks more like =<< to me than <*>.
15:37:09 <Lajla> :t flip (flip flip) (flip flip)
15:37:09 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:37:16 <cmccann> dolio, I'm open to suggestions on better operators
15:37:27 <dolio> I don't have one.
15:37:48 <dolio> =<*> is getting a little long.
15:37:56 <cmccann> yeah
15:38:15 <copumpkin> ==<<*>>==
15:38:21 <dolio> Yes. There it is.
15:38:23 <djahandarie> THE ONLY SOLUTION IS TO SWITCH TO UNICODE
15:38:26 * copumpkin bows
15:38:58 <cmccann> if I start writing everything in Unicode my Haskell will probably start to look like APL, not perl
15:39:31 <cmccann> then again APL is arguably the more readable of the two
15:39:42 * djahandarie was actually kidding and hates Unicode for those who didn't know
15:39:46 * hackagebot hspec 0.6.0 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.6.0 (TrystanSpangler)
15:39:52 <dolio> Anyhow, I think the most intuitively unreadable code I've ever seen was an array processing language....
15:40:04 <dolio> Similar to J.
15:40:13 <djahandarie> (Unicode for operator symbols in programming, not in general, I mean)
15:40:23 <dolio> Except instead of using all 'operator characters' like J, it used alphabetic characters.
15:40:35 <dolio> And that looks much, much worse than J.
15:40:36 * ddarius switches to code page 850.
15:40:42 <dolio> Even if you think J is scary.
15:41:16 <dolio> It's much better than your program being something like, "abjSkmeSklheRlkbeLkjrD".
15:41:50 <cmccann> dolio, that sounds horrifying
15:42:01 <dolio> Yes.
15:42:26 <cmccann> personally the most unreadable code I've seen is in Java-style languages when someone has gone overboard with "descriptive names"
15:42:33 <Botje> dolio: oooohh. linky?
15:42:36 <cmccann> so I admit that I may be erring in the opposite direction a bit
15:42:38 <cmccann> :)
15:42:45 <dolio> Because your brain tries to read the letters, but it's giberish.
15:43:03 <dolio> As opposed to your brain looking at symbols that it expects to be giberish.
15:43:18 <parcs> djahandarie: why?
15:43:38 <dolio> Botje: It was linked to on the programming reddit probably a couple years back, and I didn't save a link and have been unable to find it when I've subsequently wanted to.
15:43:46 <Botje> aww :(
15:43:58 <dolio> The author was touting it as being much more concise than everything else, though.
15:44:02 <cmccann> hahaha
15:44:05 <cmccann> I'm sure it was
15:44:20 <dolio> Which you can do easily by using every alphabetic character as a different function.
15:44:30 <c_wraith> :t f
15:44:31 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:44:53 <c_wraith> > foldl f 0 [1..10]
15:44:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:44:54 <lambdabot>    `GHC.Num.Num a'
15:44:54 <lambdabot>      ari...
15:44:56 <Botje> did it have dyads as well?
15:44:58 <djahandarie> parcs, when I look at a character I like to know how to enter it. I already knows this for all the symbols on my keyboards. Also, I'm just in general bad at remembering new symbols.
15:44:58 <c_wraith> > foldl f 0 [1..10] :: Expr
15:44:59 <lambdabot>   f (f (f (f (f (f (f (f (f (f 0 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
15:45:24 <Botje> hmm. nice and symmetrical :)
15:45:38 <cmccann> dolio, hm, that gives me an idea for an interesting esoteric language
15:45:47 <cmccann> use all 26 letters as different combinators, including the standard ones
15:45:59 <cmccann> use capitalization to imply something about the expression structure
15:46:02 <djahandarie> > foldr f 0 [1..10] :: Expr
15:46:03 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 0)))))))))
15:46:04 <cmccann> it would be horrible
15:46:41 <dolio> How many does unlambda use?
15:46:47 * hackagebot graph-serialize 0.1 - Serialization of data structures with references.  http://hackage.haskell.org/package/graph-serialize-0.1 (ThomasSchilling)
15:46:58 <ddarius> dolio: Like seven or so.
15:47:08 <dolio> Anyhow, you don't just have 26 letters. You have 52, because upper case is a different function from lowercase.
15:47:25 <cmccann> unlambda is mostly ski with some extras for other things
15:47:28 <KirinDave> Hah, it's clear from my recent code that I've been playing with a lot of haskell
15:47:31 <KirinDave> https://github.com/KirinDave/Clothesline/commit/2665ce441e50baace45c082dfbf002e33a48099d
15:47:47 <cmccann> dolio, right, I was thinking of using capitalization for expression structure somehow
15:47:49 <KirinDave> ("Programming... with FUNCTIONS!")
15:47:59 <djahandarie> KirinDave, that it's gotten more confusing? ;)
15:48:01 <cmccann> instead of unlambda's backtick or parentheses
15:48:26 <KirinDave> djahandarie: Well, actually from the perspective of the model it's less so.
15:49:05 <KirinDave> Nearly all the return values that users interact with now return functions that take a ServerState argument.
15:49:28 <cmccann> dolio, in particular something involving case changes... like s and S would both be the S combinator, but ks and kS would be different expressions somehow
15:49:36 <cmccann> keeping in mind that being confusing is the goal here
15:50:10 <dolio> Probably not quite that.
15:50:27 <dolio> Maybe more like kSx being different than ksx.
15:50:48 <cmccann> dolio, yeah, something like that
15:50:56 <cmccann> I dunno, I have no idea how it would work
15:51:18 <cmccann> just guessing that you'd be able to encode enough information that way to avoid needing parentheses or whatever
15:51:31 <cmccann> and it would make the programs even more incomprehensible
16:24:18 * ezyang wonders if concurrent programming can actually be fun, given good tools. 
16:30:21 <dylukes> crap
16:30:23 <dylukes> what was it called
16:30:29 <dylukes> that technique for analyzing rhythmicity
16:30:38 <dylukes> where you multiply each value by all of the values nearby
16:30:46 <dylukes> er no
16:30:52 <dylukes> sum all of the local values multiplied by the current one
16:31:52 <dylukes> autocorrelation!
16:31:58 <dylukes> whew, thought i'd forgotten for a second
16:32:08 <LordBrain> in music?
16:32:21 <dylukes> No, I just want an autocorrelation function, I remember it now.
16:32:24 <LordBrain> sorry i just walked in
16:34:07 <copumpkin> dylukes: there's a better way to calculate it than the n^2 one
16:34:14 <dylukes> not n^2...
16:34:32 <dylukes> I just need to do a simple one,
16:34:32 <copumpkin> naive autocorrelation is O(n^2)
16:34:38 <dylukes> oh well
16:34:44 <dylukes> I don't really care about efficiency for the moment
16:34:52 <dylukes> and, it's not n^2 here but n * j
16:34:57 <dylukes> where j is the lag
16:35:14 <copumpkin> the range of lags you're interested in?
16:35:25 <dylukes> What I want is
16:35:38 <dylukes> A(n) should be the sum of a_n-j to a_n+j
16:35:41 <dylukes> really simple.
16:35:49 <dylukes> er
16:35:50 <dylukes> my bad
16:35:52 <copumpkin> that isn't autocorrelation
16:35:57 <dylukes> No, I mixed it up
16:36:01 <copumpkin> ok
16:36:05 <dylukes> A(n) should be the sum of a_n-j to a_n+j, times a_n
16:36:06 <dylukes> so
16:36:14 <copumpkin> hmm
16:36:20 <copumpkin> that isn't autocorrelation either
16:36:21 <dylukes> a_n * a_n-j + a_n *a_n-j+1...
16:36:21 <dylukes> etc
16:36:34 <dylukes> what am I getting wrong here?
16:36:58 <copumpkin> autocorrelation can be seen as the dot product of a signal with itself, lagged
16:37:27 <copumpkin> > zipWith (*) `ap` drop 1 $ [1..10]
16:37:28 <lambdabot>   [2,6,12,20,30,42,56,72,90]
16:37:37 <copumpkin> > zipWith (*) `ap` drop 2 $ [1..10]
16:37:38 <lambdabot>   [3,8,15,24,35,48,63,80]
16:37:51 <copumpkin> > sum . (zipWith (*) `ap` drop 2) $ [1..10]
16:37:52 <lambdabot>   276
16:38:05 <copumpkin> you probably want to wrap it or pad the stuff you don't have in some way
16:38:18 <dylukes> Sadly, I can't do this in Haskell actually.
16:38:31 <dylukes> anyways, let me think for a moment
16:40:03 <dylukes> I was certain that you could represent it as
16:40:12 <dylukes> for some finite, discrete signal
16:40:55 <copumpkin> djahandarie: welcome back!
16:41:09 <dylukes> A(n) = A(n-j)*A(n) + A(n-j+1)*A(n) + ‚Ä¶ + A(n) * A(n) + ‚Ä¶ A(n) * A(n+j-1)  + A(n) *A(n+j)
16:41:27 <dylukes> Am I mixing it up with something else?...
16:41:41 <ddarius> Convolution?
16:42:12 <Axman6> sure looks like convolution
16:42:30 <dylukes> I'm not familiar with convolution :\
16:42:49 <dolio> A(n) = ... + A(n)*A(n) + ... ?
16:42:59 <Axman6> http://en.wikipedia.org/wiki/Convolution
16:43:03 <dylukes> alternatively
16:43:27 <dylukes> A(n) = A(n) * A[n-j : n+j]
16:43:32 <dylukes> I don't think that's real syntax though >_>
16:43:43 <Axman6> the disgrams there are probably the best way to understand hwo the colvolution functions work. yay wikipedia
16:44:13 <shapr> durn it, how do I prevent html escaping in hamlet?
16:44:43 <copumpkin> lock it in skolem's dungeon
16:44:54 <monochrom> hahaha
16:44:54 <ddarius> Autocorrelation is convolution of a signal with its reverse.
16:45:30 <danharaj_> so usually when I'm using a variable of some simple type, I use a letter like 'x' or 'y', if it's a list, I use 'xs' or 'ys'. Does anyone do anything for Maybes?
16:45:32 <shapr> hakyll is using hamlet or blaze or something, and that's turning my Google Analytics javascript into document.write(unescape(&quot;%3Cscript src='&quot; + gaJsHost + &quot;google-analytics.com/ga.js'
16:45:50 <dylukes> ddarius: So‚Ä¶ am I right or not?
16:45:52 * shapr digs through the layers
16:46:01 <dylukes> I distinctly remember this being right (or at least, an approximation)
16:46:13 <dylukes> "this" being
16:46:14 <danharaj> I wish you could use `?' as part of identifiers :p
16:46:25 <dylukes> AutoCorrelation(A, n) = A(n-j)*A(n) + A(n-j+1)*A(n) + ‚Ä¶ + A(n) * A(n) + ‚Ä¶ A(n) * A(n+j-1)  + A(n) *A(n+j)
16:46:28 <dylukes> where A is some signal.
16:46:38 <copumpkin> danharaj: just use a "Huh" suffix on functions that you'd usually put a ? on
16:46:44 <dankna> haha
16:46:47 <dankna> nice thought
16:46:58 <dylukes> I just suffix with Amirite
16:47:01 <ddarius> Autocorrelation is the convolution of an entire signal with itself.
16:47:08 <dylukes> ddarius: so what would it look like?
16:47:19 <monochrom> I sometimes use mx or x' for a Maybe value
16:47:37 <monochrom> do { mx <- ....; case mx of Just x -> ... }
16:48:19 <geheimdienst> data Whatever a = Just a | Nothing
16:48:33 <copumpkin> the indifferent type
16:48:52 <copumpkin> fileMeh :: Maybe Filepath
16:48:53 <Eduard_Munteanu> "Perhaps a" :P
16:50:09 <dibblego> data P'raps a = ProllyNot | Prolly a
16:50:12 <monochrom> data Perhaps a where { Actually :: a -> Perhaps a; ActuallyNo :: Perhaps a; InFact :: b -> Perhaps a }
16:50:13 <geheimdienst> re-exported as "Shrug a" and "Handwavy a". the math literature calls it a wellwhatdoiknowoid
16:50:46 <Eduard_Munteanu> :)
16:51:12 <ddarius> dylukes: R(j) = Sum_{n=0}^N A(n)*A(n-j).  I.e. R(0) would be the squared magnitude of A.
16:51:28 <geheimdienst> data Yoda a = Do a | DoNot -- there is no try
16:51:52 <danharaj> heh. writing 'pure Nothing' makes me feel so profound
16:52:03 <dylukes> geheimdienst:
16:52:16 <dylukes> parseYoda = Do <$> try parseDo
16:53:02 <Eduard_Munteanu> Yoneda's the master here, add I might.
16:53:17 <monochrom> parsec's try should really be renamed to do'or'do'not'there'is'no'try
16:54:50 <geheimdienst> @hoogle spoon
16:54:51 <lambdabot> No results found
16:54:56 <geheimdienst> there is no spoon
16:55:26 <geheimdienst> list of things of which there are none: 1. spoon 2. try
16:55:29 <Eduard_Munteanu> The spoon is in the eye of the beholder... wait that's a bit painful.
16:55:57 * Eduard_Munteanu stops raising the entropy of the channel :)
16:55:57 <monochrom> hahaha
16:56:12 * ddarius would, however, find this notation slightly more enlightening: R(j) = Sum_{n-m=j} A(n)A(m)
16:57:20 <adimit> This is a long shot, but could somebody explain to me the difference between icont and liftI in iteratee?
16:57:36 <Eduard_Munteanu> How about R(j) = (A * A)(j)? :)
16:57:46 <ddarius> Eduard_Munteanu: That's incorrect.
16:57:47 <adimit> specifically, I can't understand why icont takes Maybe SomeException‚Ä¶
16:58:04 <copumpkin> Eduard_Munteanu: it's multiplication in the frequency domain, if you convert back later
16:58:10 <Eduard_Munteanu> ddarius: isn't it the convolution with itself?
16:58:15 <ddarius> Eduard_Munteanu: No.
16:58:21 <Eduard_Munteanu> Uh, oops.
16:58:37 <ddarius> Anyway, if you were going to do that, you might as well write, R = A*rev(A)
16:59:13 <Eduard_Munteanu> Ah.
16:59:26 <Eduard_Munteanu> copumpkin: yeah, I know, convolution theorem, goes both ways.
17:00:04 <ddarius> Convolution is more enlighteningly written (A*B)(j) = Sum_{n+m=j} A(n)B(m) which makes it immediately obvious that it is symmetric, and suggests generalizations.
17:00:26 <ddarius> Such as Dirichlet convolution (A*B)(j) = Sum_{nm=j} A(n)B(m)
17:01:16 <ddarius> Or more generally, (A*B)(j) = Sum_{n‚äóm=j} A(n)B(m) for an arbitrary group operation ‚äó.
17:01:20 <Eduard_Munteanu> I wonder how an axiomatic approach for defining convolution goes. Maybe stating the convolution theorem straight and then making up a norm on a particular function space?
17:01:46 <Eduard_Munteanu> Autocovariance looks a bit like a norm.
17:02:39 <Eduard_Munteanu> (you know, like you define the determinant as an alternate multilinear form)
17:03:32 <ddarius> If I were going to define convolution in an axiomatic style, I'd define it pretty much via the convolution theorem.
17:05:12 <Eduard_Munteanu> I suppose a convolution operator could vary with the transform you choose, no?
17:06:38 <Eduard_Munteanu> Dunno, I find the axiomatic style particularly enlightening about various stuff.
17:07:00 <Eduard_Munteanu> Like when asking "why that and not something else".
17:07:51 <Eduard_Munteanu> I think it gives you something akin to UMPs.
17:08:59 * dylukes is committing sacrilege.
17:09:00 <ddarius> Eduard_Munteanu: Yes it would.
17:09:11 <dylukes> numerical analysis in ruby.
17:09:13 <dylukes> ;D
17:09:19 <dylukes> NArray makes it actually relatively feasible.
17:09:22 * dylukes is too cheap for MatLab...
17:09:38 <dylukes> or rather, the university won't give me a license.
17:09:39 <Cale> An interesting definition... let R be any ring, and C be any small category with finitely many factorisations of any arrow, and define R[C] to be the set of functions from the arrows of C to R, with pointwise addition, and multiplication as (a * b)(f) = sum over f = g . h of a(g)b(h)
17:09:57 <ddarius> For example, for the Dirichlet convolution, you'd have the Dirichlet Transform, D{f}(s) = Sum_{n=0}^‚àû f(n)n^-s
17:10:34 <ddarius> The wikipedia page has a definition in terms of bialgebras.
17:11:01 <Cale> Er, R[[C]], I should say :)
17:11:17 <ddarius> Note that D{1}(s) = Œ∂(s)
17:11:49 <Cale> R[C] would be as above, but with an arbitrary small category, and finitely supported functions Arr(C) -> R
17:13:07 <Cale> For C being the preorder category for the natural numbers under their usual ordering, you get R[C] being polynomials and R[[C]] being powerseries
17:14:02 <Cale> For C being a poset in general, you get one of Rota's incidence algebras.
17:14:21 <ddarius> Good ole Gian-Carlo
17:15:26 <Cale> If C is a group or monoid (as a one-object category), you get a group or monoid ring.
17:16:14 <Cale> If C is the indiscrete preorder on n objects, you get the n by n matrix ring.
17:17:18 <Cale> (that is, n objects all uniquely isomorphic to each other)
17:17:38 <Cale> and if C is a discrete category on n objects, you get R^n
17:18:14 <Cale> I think it's cute how practically all the standard constructions on rings are examples of the same couple of things.
17:18:54 <parcs> does it make any sense to have a Writer (DList w) a type or does Writer already do appends efficiently?
17:19:30 <Eduard_Munteanu> I see.
17:19:32 <Cale> parcs: Writer should associate the appends in the right way
17:19:55 <parcs> Cale: thanks
17:22:02 <nkpart> With cabal install, is it possible to force it to create exectuable simlinks, even if it thinks they're not being managed by cabal?
17:22:03 <Cale> I haven't seen too much written about these category rings or category algebras in general though.
17:22:38 <Cale> and I'm not smart/dedicated enough to discover anything nontrivial myself about them :P
17:23:10 <Cale> I have a feeling that it might be possible to generalise some of Rota's work on incidence algebras at least.
17:23:25 <Cale> (with zeta functions and Mˆbius functions)
17:24:15 <monochrom> I don't think you can tell cabal install to create symlinks
17:24:45 <Cale> What I do is to replace the ~/.cabal/bin directory with a symlink to ~/bin
17:24:58 <Cale> and then it'll just install the binaries into my own bin directory
17:25:07 <monochrom> heh that works
17:25:27 <dylukes> NArray with Ruby,
17:25:33 <dylukes> is actually quite a bit nicer than Numpy/Python
17:25:45 <dylukes> Ruby's blocks allow for much nicer code than dealing with python lambdas...
17:25:52 <dylukes> cleaner.
17:26:35 <monochrom> in .cabal/config there are also two "bindir"s you can set
17:27:02 <monochrom> now that I look at it, there is also a "symlink-bindir" you can set, and I don't know what it really means
17:27:46 <esteth> If I want to get, say, bits 8-15 of an Int32, is my best bet to just shift back and forward?
17:28:41 <Eduard_Munteanu> Applying an and-mask then shifting is probably better.
17:28:45 <monochrom> I would mask once and shift once. or the other order.
17:29:08 <esteth> aha, thanks :)
17:29:43 <liyang> shifting and masking seems more intuitive to me.
17:30:13 <Eduard_Munteanu> Actually shifting first is probably safer, just in case you don't consider what comes from the left.
17:42:17 <esteth> is there a function that given a Constructor from an algabraeic datatype that implements Ord, gives me the "next" Constructor? I assume that's not possible, but it'd be nice before I have to resort to pattern matching on each of my constructors
17:44:32 <Eduard_Munteanu> I'm unsure, maybe TH (Template Haskell) can do it, but the idea is you're generating code to do that.
17:45:41 <ivanm> Eduard_Munteanu: well, I think you'll be using TH to basically generate a function that uses pattern-matching
17:45:48 <Eduard_Munteanu> Yeah.
17:45:56 <ivanm> esteth: and that wouldn't require Ord
17:46:07 <monochrom> "deriving Enum" may help
17:46:10 <ivanm> also, note that Ord doesn't cycle by default; you may wish it to do so
17:46:17 <Eduard_Munteanu> Well, Enum can give you the constructors themselves by enumerating, but you can't pattern-match that way.
17:46:22 <ivanm> monochrom: only if the constructors are nullary though, right?
17:46:26 <monochrom> yes
17:47:10 <monochrom> but usually the notion of "the next constructor" is not very useful otherwise
17:47:12 <Eduard_Munteanu> Mrm, crap, my last sentence is still hung up on Agda.
17:47:14 <esteth> Yes. My Constructors are Just R1 | R2 | R3, etc... if they're Enums I can get the next one? :)
17:47:30 <Eduard_Munteanu> Well I suppose there are still cases where you actually need to generate code.
17:47:40 <monochrom> "succ" gives you the next one
17:48:32 <esteth> Ah, I was being dumb in hoogle and doing Enum a -> a -> a instead of Enum a => a -> a
17:48:45 <esteth> thanks
17:49:23 <monochrom> Enum is also the driving force behind the [x .. y] syntax
17:49:24 <Eduard_Munteanu> Yeah, see if you can just use that.
17:49:47 <zmv> so, I was trying some Œª-calculus stuff
17:51:21 <zmv> and I'm stuck here: (e[be := \fx.f (f x)])(b[be := \fx.f (f x)])(\gy.g (g y))
17:51:23 <zmv> :|
17:52:33 <monochrom> without knowing what is e, what is b, there is little you can do
17:52:55 <Eduard_Munteanu> I'm also unsure what conventions you're assuming for ':='
17:53:31 <dylukes> I should really get around to thoroughly learning Erlang :\
17:53:38 <monochrom> except to convert substitutions back to applications
17:53:48 <zmv> hm
17:54:10 <monochrom> i.e., convert blah[v := stuff] back to (\v -> blah)(stuff)
17:54:34 <zmv> yeah
17:55:07 <zmv> I'm trying to get 2^2 with lambda calculus
17:55:51 <zmv> I tried to start with (\be.eb)(\fx.f (f x))(\fx.f (f x))
17:55:52 <monochrom> Russell and Whitehead spent 400 pages to do that without lambda calculus. perhaps with lambda calculus you have better luck
17:56:26 <Eduard_Munteanu> \f \x . f (f (f (f x))) ? :)
17:56:55 <zmv> Eduard_Munteanu: yeah, but I wanted to do the whole process to get there
17:57:19 <Eduard_Munteanu> Ah, you want to implement exponentiation?
17:57:30 <zmv> yeah
17:57:33 <Eduard_Munteanu> Or power?
17:58:01 <zmv> now that's a good question.
17:58:04 <zmv> hm
17:58:48 <Eduard_Munteanu> So either a^x or x^a for constant a and varying x.
17:59:51 <zmv> I think both
18:00:09 <Eduard_Munteanu> Or \x y -> x ^ y? I don't recall if that has a name :D
18:01:39 <zmv> yeah, more like that last one
18:01:46 <Eduard_Munteanu> Uh :)
18:03:10 * hackagebot plot 0.1.3.0 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.3.0 (VivianMcPhail)
18:12:55 <jedahu> snoyman or other yesod guru around?
18:29:14 * hackagebot time-recurrence 0.4.2 - Generate recurring dates.  http://hackage.haskell.org/package/time-recurrence-0.4.2 (ChrisHeller)
18:37:09 <accel> why is "data Foo = { foo :: ![String] }" allowed, but "data Bar = { bar :: ![!String] }" not allowed?
18:37:44 <accel> why is "data Foo1 = { foo1 :: ![String] }\n data Foo2 = { foo2 :: !String }" allowed, but "data Bar = { bar :: ![!String] }" not allowed? [i.e. why can't I "stack" ! ]
18:38:20 <Twey> If I had to guess, it's because bar :: ![String] modifies Bar, but [!String] would be modifying []
18:38:34 <accel> whoa
18:38:36 <accel> that is deep
18:38:51 <aavogt> accel: you're missing constructors for these types
18:38:56 <accel> I always thought of ! as modifying the type, i.e. ! modifying String, but rather than ! modifying Bar
18:39:25 <accel> why is "data Foo1 = Foo1 { foo1 :: ![String] }\n data Foo2 = Foo2 { foo2 :: !String }" allowed, but "data Bar = Bar { bar :: ![!String] }" not allowed? [i.e. why can't I "stack" ! ] [edit: fiex for aavogt]
18:39:26 <aavogt> but presumably    data Bar = Bar { bar :: ![!String] }, should define a Bar which behaves as a function like
18:40:00 <Twey> accel: Think about how you construct the values for your types
18:40:09 <Twey> That's where the forcing occurs
18:40:12 <accel> hmm
18:40:21 <accel> so the problem is I can't construct an object of type [!String] ?
18:40:22 <aavogt>  strictbar x = foldr seq (Bar x) x
18:40:30 <Twey> Bar { bar :: !Foo } will force when you call Bar on the value ‚Äî it modifies Bar to be strict
18:41:03 <accel> data Bar_1 = Bar_2 { bar :: ![!String] }; just to be clare, it modifier Bar_2 right?
18:41:12 <accel> where Bar_2 is just syntax sugar for defining a function?
18:41:16 <Twey> Yes
18:41:20 <Twey> [!String] would have to modify [] to be strict, which isn't allowed
18:41:29 <accel> got it; this amkes sense now
18:41:32 <accel> thanks :-)
18:42:04 <aavogt> Twey: how about the desugaring I suggested?
18:42:10 <Twey> Yeah
18:42:22 <Twey> You could do that
18:42:31 <accel> putStack s = get >>= (\ts -> put $ ts { stack = s } )
18:42:36 <accel> is thre a shorter way to write that?
18:42:36 <Twey> Er, or something similar, at least
18:43:00 <aavogt> I think strictness annotations only apply when you use a constructor as a function (or maybe record update too)
18:43:01 <Twey> accel: Not without fclabels or something
18:43:21 <aavogt> modify $ \ts -> ts { stack = s }
18:43:44 <accel> whoa; nice
18:43:45 <Twey> Oh, well, yeah :√æ
18:43:55 <accel> getStack :: State TreeState [String]
18:43:56 <accel> getStack = get >>= return . stack
18:44:02 <accel> can that be simpflied too? :-)
18:44:09 <Twey> fmap stack get
18:44:14 <aavogt> gets stack
18:44:18 <Twey> gets stack, yeah
18:44:26 <accel> :t gets
18:44:27 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
18:44:28 <aavogt> it's such a funny name
18:44:31 <accel> @src gets
18:44:31 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:44:43 <Twey> gets f = liftM f get
18:46:52 <zmv> how do I use complex numbers in haskell
18:47:05 <ivanm> zmv: import Data.Complex
18:47:14 <zmv> yeah, already did that
18:47:19 <ivanm> > exp((0 :+ 1) * pi)
18:47:20 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
18:47:27 <zmv> hm
18:47:43 <ivanm> @type exp((0 :+ 1) * pi)
18:47:44 <lambdabot> forall t. (RealFloat t) => Complex t
18:47:57 <zmv> > sqrt (-1)
18:47:57 <ivanm> zmv: so you want types of "Complex Double"
18:47:57 <lambdabot>   NaN
18:48:06 <ivanm> > sqrt (-1) :: Complex Double
18:48:07 <lambdabot>   (-0.0) :+ 1.0
18:48:11 <zmv> hm
18:48:36 <zmv> so I have to declare what kind of value I want to be returned?
18:48:43 <ivanm> is there a library like binary or cereal where put doesn't add various tags to denote type? i.e. I want to be able to put a String and have it just put in the characters directly (and use get to do the same in reverse)
18:48:56 <ivanm> zmv: ghci (and thus lambdabot) default to Double
18:49:22 <dolio> binary doesn't write out types.
18:49:42 <zmv> ivanm: I see.
18:49:44 <ivanm> dolio: oh? I had switched to cereal and it was doing so
18:49:56 <dolio> As far as I know.
18:50:12 <dolio> I'm not sure why it would.
18:50:53 <aavogt> zmv: you can write   default(Complex Double)  or drop the parens to get another type as the default
18:51:02 <dolio> I'm pretty sure binary expects the input procedure to be determined by the type it's used at.
18:51:06 <mauke> ivanm: http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Put.html#g:3 ?
18:51:11 <accel> http://hpaste.org/47286/accel <-- should I be rewriting this in some other way? (especialy modifyStack)
18:51:17 <dolio> Which would make writing out the types redundant.
18:51:18 <ivanm> dolio: doing `encode "hi" ' returns (Chung "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\STXhi" Empty)
18:51:58 <ivanm> dolio: whereas `runPut $ mapM_ (put . fromIntegral . ord) "hi" ' returns (Chunk "hi" Empty)
18:52:20 <dolio> > ord '\STX'
18:52:20 <lambdabot>   2
18:52:23 <ivanm> mauke: ooohhh, missed that
18:52:24 <dolio> That's the length.
18:52:42 <ivanm> dolio: oh... well, it's still something I don't want
18:52:45 <dolio> How is it going to read the string back in without knowing how much of the string is actually a string?
18:52:56 <ivanm> or am I misusing binary/cereal? I'm just trying to produce and then read in binary data
18:53:16 <ivanm> _not_ an actual haskell type
18:53:27 <mauke> Data.Binary.Put is fine for that
18:53:29 <ivanm> dolio: so what are all the \NUL's for ?
18:53:47 <dolio> The length is 8 bytes.
18:54:01 <ivanm> OK
18:54:17 <ivanm> mauke: but I'd be better off using a proper parsing library?
18:54:33 <mauke> depends on how complicated your stuff is
18:54:56 * ivanm just found a bug in cereal's Alternative instance, where some and many didn't work properly
18:54:57 <dolio> Anyhow, if you write out "hello" followed by "world" it can't just generate Chunk "helloworld"
18:55:35 <dolio> Because then you have no way of knowing which character was in which string.
18:55:49 <ivanm> mauke: well, my end goal is to say "here are a list of possible parsing methods; read in the name from the beginning and then use the appropriate one"
18:55:53 <zmv> do you use emacs?
18:55:58 <ivanm> zmv: yes
18:56:12 <ivanm> dolio: right, but for my needs I don't care
18:56:39 <ivanm> since I'm not serialising haskell values directly, but trying to create and read in specific existing binary formats
18:56:41 <zmv> ivanm: haskell-mode?
18:56:46 <ivanm> zmv: yes
18:56:56 <zmv> interesting.
18:57:22 <copumpkin> ivanm: then you don't use Binary
18:57:25 <zmv> ivanm: so, why emacs?
18:57:32 <ivanm> zmv: becuase I like emacs
18:57:38 <copumpkin> you use the more basic building blocks of putWord32be and similar
18:57:42 <ivanm> *nod*
18:57:53 <dolio> ivanm: Well, if you don't care, I have a function in bytestring-show that will just dump ascii characters to a Put.
18:58:06 <dolio> And one that will UTF-8 encode them.
18:58:20 <ivanm> copumpkin: is there a more appropriate library rather than Put from binary/cereal?
18:58:27 <gienah> ivanm: I haven't used it yet, but attoparsec looks really neat for handing binary data
18:58:37 <copumpkin> ivanm: not really, although I've considered making one a few times
18:58:42 <copumpkin> it's just rather boring and mechanical
18:59:01 <ivanm> dolio: nah, they're just ASCII, and the putByteString and putLazyByteString functions that mauke pointed out should do me fine
18:59:04 <dolio> Although I don't particularly recommend using bytestring-show, since text is around now.
18:59:07 <copumpkin> well, I was also working on a simultaneous bidirectional serialization library
18:59:12 <copumpkin> but that's complicated
18:59:15 <ivanm> gienah: yeah, though I'm probably going to stick with polyparse since I know it better
18:59:18 <dolio> Oh, if they're already byte strings, then go for it.
18:59:41 <solrize> @pl flip (.)
18:59:41 <lambdabot> flip (.)
18:59:46 <solrize> @pl flip ($)
18:59:46 <lambdabot> flip id
18:59:48 <ivanm> dolio: I'm not, but it's just a simple existing String: something like ">>>planar_code<<<"
19:00:01 <ivanm> no, wait, only two >< pairs, not 3
19:00:16 <solrize> @hoogle (a -> b) -> (b -> c) -> a -> c
19:00:16 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
19:00:16 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
19:00:16 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
19:00:18 <ivanm> and using B.pack should do for that
19:00:38 <ivanm> I did consider using blaze-builder, but it looks too big and complicated for what I need
19:00:51 <ivanm> (if the bytestring-only stuff was split out that'd be a different story)
19:02:00 <dolio> Actually, bytestring-show is all about having a Show class that produces Put/ByteString, if that's what you're doing.
19:02:11 <dolio> I consider it deprecated, though.
19:02:40 <ivanm> most of the time I'm just dealing with numbers
19:02:50 <ivanm> well, bytes
19:02:54 <ivanm> it's just the tags at the start of the file that are textual
19:45:14 <dankna> does GHC have a feature that lets you access the filename and line number of an expression, for runtime error-reporting purposes?
19:47:25 <Jafet> Pattern match failure
19:47:47 <dankna> well what I want is to throw an exception that has the information encapsulated so I can report it to my users
19:47:59 <Jafet> (Someone found a program that did this deliberately, to get the source filename)
19:48:03 <dankna> oh, you mean something like deliberately fail a match and... oh wow
19:48:05 <dankna> interesting!
19:48:15 * dankna looks into it
19:48:35 <Jafet> In GHC, pattern match failure does raise an exception
19:49:00 <ddarius> > do True <- return False; return () :: Either String ()
19:49:01 <lambdabot>   Overlapping instances for GHC.Base.Monad
19:49:01 <lambdabot>                              (Data...
19:49:09 <ddarius> Freakin' Christ.
19:49:25 * hackagebot plot 0.1.3.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.3.1 (VivianMcPhail)
19:50:06 <Jafet> @vixen you like to have many instances at once?
19:50:06 <lambdabot> yeah, i like
19:50:26 <Jafet> > head []
19:50:26 <lambdabot>   *Exception: Prelude.head: empty list
19:50:36 <Jafet> Okay, that wasn't one
19:51:01 <shachaf> {-# LANGUAGE CPP #-}
19:51:21 <Jafet> Yuck
19:51:23 <dankna> okay so I came up with another approach
19:51:43 <dankna> each time I write an assertion I'll generate a random number by hand :)
19:51:55 <dankna> then I can print the random number in my error message and grep the source file for it, haha
19:52:02 <shachaf> dankna: Isn't a CPP macro nicer? :-)
19:52:07 <dankna> shachaf: no :)
19:52:27 <Jafet> Oh hm
19:52:39 <Jafet> Language.Haskell.TH.Loc
19:52:48 <dankna> oh hm!
19:54:28 * stepkut just uses __LINE__
19:54:59 <stepkut> and __FILE__
19:55:30 <Jafet> And __func__... no wait
19:55:39 <dankna> amusement
19:55:49 <stepkut> Jafet: that would be nice
19:59:03 <dmwit> ?src (++)
19:59:03 <lambdabot> []     ++ ys = ys
19:59:03 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:59:03 <lambdabot> -- OR
19:59:03 <lambdabot> xs ++ ys = foldr (:) ys xs
19:59:07 <stepkut> you can put this in a module,
19:59:08 <stepkut> module Loc where
19:59:08 <stepkut> import Language.Haskell.TH
19:59:08 <stepkut> loc = location >>= \(Loc f p m s e) -> stringE (f++":"++p++":"++m++":"++show s++":"++show e)
19:59:20 <stepkut> and then do:
19:59:21 <stepkut> {-# LANGUAGE TemplateHaskell #-}
19:59:21 <stepkut> import Loc
19:59:21 <stepkut> main = print $( loc )
19:59:25 <stepkut>  
20:00:01 <dankna> yes.  that's what I'm doing in fact.
20:00:07 <dankna> well, slightly nicer than that, but more or less.
20:10:06 <Jafet> Is this a correct implementation of seq? {-# LANGUAGE BangPatterns #-} seq !_ a = a
20:10:20 <dolio> Yes.
20:10:31 <dolio> If ! is a primitive notion.
20:10:31 <Jafet> That's cool.
20:10:51 <dolio> It's probably defined in terms of seq.
20:11:17 <dolio> As far as a Haskell specification is concerned.
20:13:02 <Jafet> Oh, ! is standard Haskell.
20:13:07 <ddarius> No.
20:13:13 <ddarius> Well, it is for data types.
20:13:24 <ddarius> (In which case it is explicitly defined in terms of seq.)
20:26:29 <Axman6> would this also be a valid definition of seq? data S a = S !a; seq a b = case S a of S _ -> b
20:26:43 <shachaf> Why is seq (seq undefined) 5 not _|_, when defined Jafet's way?
20:27:26 <Axman6> because you end up with (\b -> seq undefined b) `seq` 5, and the lambda is in WHNF
20:28:10 <accel> troll alert: is Haskell's "polluting" of the namespace via functions automaticaly created by functions a "feature" to strongly-encourage modularization / short *.hs files?
20:28:49 <Axman6> i don't understand the question
20:28:51 <shachaf> Axman6: Huh, seq !_ = \a -> a isn't the same thing as seq !_ = id
20:29:50 <accel> data Foo = Foo { x :: Int, y :: Int, z :: Int} \n data Point = Point { x :: Int, y :: Int} <-- gah, now x & y are conflicting <-- is this meant as a feature to encourage modularization / short *.hs files?
20:30:01 <Axman6> > let seq' !_ = \a -> a in seq' (seq' undefined) 1
20:30:01 <lambdabot>   1
20:30:08 <Axman6> > let seq' !_ = id in seq' (seq' undefined) 1
20:30:09 <lambdabot>   *Exception: Prelude.undefined
20:30:12 <Axman6> o.O
20:30:13 <accel> data Foo = Foo { x :: Int, y :: Int, z :: Int} \n data Point = Point { x :: Int, y :: Int} <-- gah, now x & y are conflicting <-- is this meant as a feature to encourage modularization / short *.hs files? [since the accessors could just as well as be called Foo.x Foo.y Foo.z and Point.x Point.y ]
20:30:13 <Axman6> wut
20:30:14 <shachaf> Magic!
20:30:20 <jmcarthur> it may have that effect, but i doubt the point is to encourage modularization
20:30:44 <jmcarthur> the point is probably just that they thought it was nice for accessors to just be plain functions
20:30:52 <gienah> accel: there is a ghc flag to reduce conflicts on the record labels
20:31:06 <solrize> :t (\\)
20:31:06 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
20:31:12 <Axman6> accel: people are encouraged not to use names like x and y for functions. you'd usually use fooX, fooY, pointX pointY etc
20:31:30 * hackagebot yackage 0.2.1 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.2.1 (MichaelSnoyman)
20:31:31 * ddarius would have no problem using x and y.
20:33:02 <gienah> accel: -XDisambiguateRecordFields
20:33:10 <ddarius> Ugh.
20:33:37 <accel> gienah: thanks
20:39:22 <Jafet> GHC has an extension to do C++-like lookup on record labels
20:39:38 <Jafet> It would be very nice... once we have multi-module source files
20:40:06 <Jafet> Or first class patterns
20:50:00 <ddarius> Axman6: That looks like a bug in GHC.
20:50:11 <Axman6> undeed it does
20:50:13 <shachaf> ddarius: The seq thing?
20:50:24 <Axman6> in*
20:51:49 <dolio> Hmm...
20:53:38 <dolio> Does the report specify that seq undefined = undefined?
20:54:03 <shachaf> dolio: As far as I know seq undefined isn't undefined.
20:54:13 <shachaf> Which I always foudn weird.
20:54:36 <dmwit> really?
20:55:17 <dmwit> I thought the English description of seq a b was that by the time (seq a b) was reduced to WHNF, a was also reduced to WHNF.
20:55:33 * hackagebot repa-io 2.0.1.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-2.0.1.1 (BenLippmeier)
20:55:44 <shachaf> dmwit: Right, but not necessarily (seq a).
20:55:45 <dolio> That doesn't tell you what happens when it's partially applied.
20:55:54 <dmwit> Doing substitution on that sentence would seem to say, then, that
20:55:58 <shachaf> Oh, the Prelude doesn't specify it.
20:56:09 <dmwit> By the time (seq undefined b) is reduced to WHNF, undefined is also reduced to WHNF.
20:56:51 <ddarius> The definition in the report is simply: seq _|_ b = _|_, seq a b = b if a /= _|_ which doesn't really say one thing or another about seq _|_.
20:56:52 <dmwit> Oh, now I understand your question.
20:57:04 <dmwit> For all b, seq undefined b is undefined, but seq undefined itself need not be.
20:57:05 <dmwit> Got it.
20:57:25 <shachaf> At any rate I don't see any reason that foo !_ = \x -> x should be different from foo !_ = id.
20:57:41 <ddarius> However, that vaguely suggests that seq _|_ = \b -> _|_
20:57:43 <dolio> It makes sense if you look at the translation.
20:58:03 <dolio> The seq happens inside the argument list.
20:58:35 <dolio> So foo !_ = \x -> x  gets translated to foo y | y `seq` True = \x -> x
20:58:38 <dolio> Or something like that.
20:58:58 <dolio> While foo !_ x = x turns into foo y x | y `seq` True = x.
20:59:14 <shachaf> dolio: No, those two behave the same way.
20:59:17 <ddarius> foo !_ = \x -> x gets translated to foo = \a -> case a of !a -> \x -> x
20:59:33 <shachaf> foo !_ = id is different from foo !_ = \x -> x, though.
20:59:37 <ddarius> Which then gets translated to \a -> a `seq` case a of a -> \x -> x
21:00:41 <ddarius> > let seq' !_ a = a in seq' (seq' undefined) 1
21:00:42 <lambdabot>   1
21:00:48 <dolio> > let foo !_ = \x -> x in seq (foo undefined) 5
21:00:48 <lambdabot>   *Exception: Prelude.undefined
21:00:52 <dolio> > let foo !_ = id in seq (foo undefined) 5
21:00:52 <lambdabot>   *Exception: Prelude.undefined
21:01:02 <shachaf> Hmm.
21:01:34 <ddarius> > let seq' !_ = \x -> x in seq' undefined 1
21:01:35 <lambdabot>   *Exception: Prelude.undefined
21:02:28 <shachaf> Oh> let foo !_ = \x -> x in foo (foo undefined) 5
21:02:33 <shachaf> > let foo !_ = \x -> x in foo (foo undefined) 5
21:02:34 <lambdabot>   5
21:02:47 <shachaf> > let foo !_ = id in foo (foo undefined) 5
21:02:47 <lambdabot>   *Exception: Prelude.undefined
21:03:04 <ddarius> So, we've established that seq' undefined = undefined, yet seq' (seq' undefined) /= undefined.
21:03:56 <dolio> That's pretty bizarre.
21:04:13 <ddarius> It's likely a bug.  Some kind of unsound lambda lifting or something.
21:04:15 <dolio> Thanks, optimizer.
21:05:01 <dolio> > let foo !_ = id in (foo (foo undefined) 5, foo undefined 5)
21:05:02 <lambdabot>   (*Exception: Prelude.undefined
21:05:13 <dolio> > let foo !_ = id in (foo (foo undefined) 5, 5)
21:05:14 <lambdabot>   (*Exception: Prelude.undefined
21:05:26 <dolio> > let foo !_ = \x -> x in (foo (foo undefined) 5, 5)
21:05:27 <lambdabot>   (5,5)
21:05:36 <dolio> > let foo !_ = \x -> x in (foo (foo undefined) 5, foo undefined 5)
21:05:36 <lambdabot>   (5,*Exception: Prelude.undefined
21:06:23 <dmwit> > ((\!_ -> \x -> x) ((\!_ -> \x -> x) undefined) 5, (\!_ -> \x -> x) undefined 5)
21:06:24 <lambdabot>   <no location info>: parse error on input `->'
21:11:48 <dolio> > (\ !_ -> \x -> x) ((\ !_ -> \x -> x) undefined) 5
21:11:49 <lambdabot>   *Exception: Prelude.undefined
21:12:13 <dolio> > (\ !_ -> \x -> x) ((\ !_ x -> x) undefined) 5
21:12:14 <lambdabot>   5
21:20:37 <Veinor> http://sprunge.us/WOeW
21:25:40 <shachaf> Veinor: Needs EmptyDataDecls.
21:27:08 <Veinor> the person who wrote it compiled it on 7.
21:47:12 <ivanm> @hoogle intersection
21:47:12 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
21:47:12 <lambdabot> Data.IntSet intersection :: IntSet -> IntSet -> IntSet
21:47:12 <lambdabot> Data.Map intersection :: Ord k => Map k a -> Map k b -> Map k a
21:47:15 <ivanm> @hoogle intersect
21:47:16 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
21:47:16 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
21:47:16 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
21:58:02 <Jafet> Can I make haddock print nested comments?
21:58:20 <Jafet> Specifically, it strips a LANGUAGE pragma.
21:58:35 <ivanm> wow
22:01:08 <Jafet> Well, I'll have to change the entire header block to -- comments.
22:33:28 <ville> so no  more C++ just haskell?
22:37:37 <dankna> sigh
22:37:53 <dankna> just spent about half an hour tracking down a segfault that turned out to be me passing a null pointer from C-land
22:38:44 <shachaf> dankna: That does tend to be a common source of segfaults.
22:39:40 <dankna> shachaf: yes.  well, it could hardly have been the fault of Haskell-dom.
22:43:53 <robinhoode> dankna: Half an hour? Heh.. If you're doing nothing but C, that'd be, probably, 2 hours, average..
22:44:01 <dankna> robinhoode: indeed heh.
22:44:21 <robinhoode> dankna: What kind of project are you working on, just out of curiosity?
22:45:50 <dankna> robinhoode: it's to be a structure editor for (initially) Haskell source code
22:46:01 <dankna> robinhoode: front-ends for Mac GUI and terminal
22:46:39 <dankna> robinhoode: I'm doing this in conjunction with extending Cabal to be able to build .app bundles all on its own
22:46:53 <dankna> (I have a working prototype of that functionality which runs using the hooks instead of as part of the core)
22:47:43 <dankna> the program uses the strategy of avoiding the need for a super-parser (although I'd love to write such a beast) by keeping the code in a database until it actually needs to be compiled
22:47:59 <dankna> this has the unfortunate effect of making it difficult to use in conjunction with version control; 2.0 will have integrated VC
22:48:16 <dankna> 1.0 will essentially be a "gather enthusiasm" release, heh
22:49:26 <dankna> structure editor means, you see, that it has detailed knowledge of the syntax and grammar of the language, and uses that knowledge heavily
22:49:33 <robinhoode> dankna: I have never heard the term before, but I've seen similar things pretty often..
22:49:47 <dankna> browse to definition of symbol; safe rename symbol; that sort of thing
22:49:58 * dankna nods
22:50:29 <robinhoode> dankna: Definitely something haskell is suited for.. the kind of abstraction + correctness that few other languages can match..
22:50:38 <dankna> paredit and nxml-mode, both for Emacs, are the only examples of true structure editing that I'm aware of - for Lisp and XML, respectively
22:50:46 <dankna> yes, absolutely
22:57:28 <Guest1644> I am very confused about something
22:57:56 <dankna> what are you confused about?
22:57:57 <Guest1644> Are there cases in which
22:58:37 <Guest1644> hm
22:58:50 <Guest1644> trying to explain my problem correctly
22:59:03 <Guest1644> so I got a parametrically polymorphic function.
22:59:24 <Guest1644> if I don't use it, its type is polymorphic.
22:59:46 <Guest1644> If I use it somewhere, the type variable becomes a specific type
23:00:09 <Guest1644> so I can't use it with two different types
23:00:20 <Guest1644> if I use it with one, the other attempt breaks.
23:00:26 <dankna> uh
23:00:26 <c_wraith> you're describing rank-1 predicative polymorphism, which is what haskell defaults to
23:01:01 <Guest1644> what does that mean
23:01:01 <c_wraith> > let f g = (g 5, g "hello") in f id
23:01:02 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
23:01:02 <lambdabot>    arising from the literal ...
23:01:24 <mauke> Guest1644: can you show me that function?
23:01:28 <Guest1644> so, what's the solution here?
23:01:39 <c_wraith> > let f :: (forall a. a -> a) -> (Int, String) ; f g = (g 5, g "hello") in f id
23:01:40 <lambdabot>   (5,"hello")
23:01:47 <c_wraith> rank-2 types is the common solution
23:01:54 <mauke> c_wraith: are you sure you're solving the right problem?
23:02:13 <c_wraith> I think so.  But I was going to double-check.
23:02:53 <c_wraith> > let f g = (g [], g Nothing) in f id
23:02:54 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
23:02:54 <lambdabot>         against inferred ...
23:03:09 <c_wraith> Guest1644: is that the rough equivalent of what you're seeing?
23:04:29 <Guest1644> c_wraith, I think so.
23:05:05 <c_wraith> basically, is this when using a function passed in to a higher-order function, where you expect the function passed in to be polymorphic?
23:05:18 <Guest1644> uh
23:05:52 <Guest1644> yes
23:06:11 <c_wraith> well, can you hpaste the higher-order function for us?
23:06:58 <c_wraith> hmm, I need a less-bad example of a higher-order function for this.
23:08:29 <Guest1644> actually
23:08:39 <Guest1644> just adding a type signature fixed it
23:08:50 <Guest1644> no need for Rank2Types or RankNTypes.
23:08:53 <c_wraith> in that case, it was probably somehow running into the monomorphism restriction
23:09:08 <c_wraith> was it a binding that lacked formal parameters?
23:09:08 <Guest1644> But I already had NoMonomorphismRestriction enabled.
23:09:31 <Guest1644> formal parameters?
23:09:48 <mauke> so when are you going to stop ignoring me?
23:10:10 <Guest1644> wait what
23:13:28 <Guest1644> http://hpaste.org/47288/no_need_for_rank2types
23:13:37 <Guest1644> Here it is.
23:14:16 <mauke> how does type checking fail?
23:14:26 <Guest1644> well
23:16:35 <Guest1644> http://hpaste.org/paste/47288/no_need_for_rank2types_annota#p47289
23:17:36 <mauke> interesting
23:17:46 <Guest1644> I thought Haskell was supposed to keep its functions as polymorphic as possible
23:18:49 <c_wraith> well, it won't infer higher-rank or impredicative types, but those aren't what you're running into.
23:18:57 <c_wraith> But what version of GHC is it?
23:19:00 <mauke> can you post a complete test case?
23:19:23 <Guest1644> latest GHC
23:19:23 <Guest1644> 7.0.3
23:19:38 <Guest1644> I'll just post the whole file.
23:20:42 <Guest1644> http://hpaste.org/paste/47288/the_whole_thing#p47290
23:20:59 <Guest1644> removing the type signature for case_ will break type checking.
23:21:29 <Guest1644> switch the definitions of expr and stmt to see it losing its polymorphism to different types.
23:22:11 <c_wraith> why'd you redefine $ ?
23:22:15 <mauke> what is NoImplicitPrelude for?
23:22:30 <Guest1644> because I like $ being infixl
23:22:40 <Guest1644> that's completely unrelated to the problem.
23:22:51 <c_wraith> oh, infixl
23:23:10 <ivanm> wait, why would you want $ to be infixl?
23:23:51 <jesse_> hi
23:23:52 <c_wraith> makes it saner for writing certain things
23:24:11 <c_wraith> like...  map $ subtract 5 $ [1..5]
23:24:22 <mauke> as far as I can see you're not using NoImplicitPrelude or TupleSections
23:24:41 <ivanm> c_wraith: oh, right; but he's not doing that anyway AFAICT
23:24:51 * ivanm waves idly in jesse_'s general direction
23:25:03 <c_wraith> ivanm: I was just answering why you might sometimes want it.  *shrug*
23:25:07 <Guest1644> I was using them before.
23:25:12 <ivanm> c_wraith: yeah, fair enough
23:25:17 <Guest1644> Again, not relevant.
23:25:24 <ivanm> though tbh I'd prefer to write it as map (subtract 5) anyway
23:25:43 <mauke> Guest1644: it is relevant because my ghc doesn't support TupleSections so it dies right there
23:25:47 * ivanm has no idea what Guest1644's problem is as he just came in again
23:25:48 <Guest1644> oh
23:26:02 <c_wraith> wait, you're still using pre 6.12?
23:26:08 <ivanm> mauke: you still using 6.10 or something? :o
23:26:14 <ivanm> I thought I was slow for still using 6.12.3 ...
23:26:17 <mauke> ivanm: yes
23:26:27 <mauke> that was the last version with readline support
23:26:38 <ivanm> mauke: why do you want readline support?
23:26:52 <mauke> so ghci doesn't piss me off
23:27:01 <Guest1644> rlwrap?
23:27:10 <ivanm> the advantages of using ghci within emacs :D
23:27:21 <ddarius> mauke: Just don't use GHCi.  That's what I do.
23:27:25 <ivanm> mauke: though I've only seen it being a problem when testing out interactive I/O stuff within ghci
23:27:34 <ivanm> where you can't use backspace or other keys
23:27:54 <mauke> ddarius: do you use a repl?
23:28:06 <ddarius> Not usually.
23:28:20 * ivanm heads off home
23:28:43 <sully> ghci is pretty bad.
23:29:26 <ryanf_> oh haha uh is 6.10 really old?
23:29:29 <ryanf_> that's what macports gave me
23:29:54 <ryanf_> :[
23:29:59 <ddarius> 6.10.4 was released in July 2009.
23:30:21 <ryanf_> I was like "wtf are they talking about, my ghci has readline and I just installed it last week"
23:31:21 <mauke> I bet your ghci doesn't have readline
23:31:31 <ryanf_> if it doesn't, it does a good job of pretending
23:31:41 <ryanf_> it's got reverse-i-search and stuff
23:31:50 <mauke> hmm
23:32:07 <shachaf> ryanf_: It does a mediocre job of pretending.
23:32:11 <ryanf_> haha
23:32:26 <ryanf_> I guess I don't really push the limits of readline in my day-to-day life
23:32:53 <shachaf> I never knew how many readline edge cases I relied on until I used ghci's cheap plastic imitation.
23:33:03 <mauke> I use history-search-backward all the time
23:33:07 <Guest1644> @hoogle forall a. (a -> b, a -> c) -> a -> (b, c)
23:33:08 <lambdabot> No results found
23:33:14 <Guest1644> @hoogle (a -> b, a -> c) -> a -> (b, c)
23:33:15 <lambdabot> No results found
23:33:24 <ryanf_> what's the difference between history-search-backward and reverse-i-search?
23:33:35 <mauke> ryanf_: what do they have in common?
23:33:39 <Guest1644> @hoogle (a -> b, a -> c) -> (b, c)
23:33:39 <lambdabot> No results found
23:33:44 <dankna> they're both backward searches
23:33:49 <ddarius> :t uncurry (&&&)
23:33:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
23:34:18 <ryanf_> oh I see
23:35:02 <sully> @hoogle (a -> b) -> (a -> c) -> a -> (b, c)
23:35:02 <lambdabot> No results found
23:35:18 <sully> it would be nice if hoogle specialized
23:36:04 <dmwit> ?djinn (a -> b) -> (a -> c) -> a -> (b, c)
23:36:04 <lambdabot> f a b c = (a c, b c)
23:36:54 <shachaf> @. pl djinn (a -> b) -> (a -> c) -> a -> (b, c)
23:36:55 <lambdabot> f = liftM2 (,)
23:36:55 <sully> also that.
23:37:21 <sully> :t liftM2 (,)
23:37:21 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
23:37:22 <Jafet> @pl \f g x -> (f x, g x)
23:37:22 <lambdabot> liftM2 (,)
23:37:37 <shachaf> . pl djinn is like super-Hoogle.
23:38:53 <Jafet> :t (\f g x -> (f x, g x)) `asTypeOf` (&&&)
23:38:54 <lambdabot> forall t t1 b. (b -> t) -> (b -> t1) -> b -> (t, t1)
23:39:08 <sully> :t asTypeOf
23:39:09 <lambdabot> forall a. a -> a -> a
23:39:22 <shachaf> @src asTypeOf
23:39:22 <lambdabot> asTypeOf = const
23:39:29 <Jafet> @djinn (a -> b) -> (a -> c) -> a -> (b, c)
23:39:30 <lambdabot> f a b c = (a c, b c)
23:39:31 <sully> :t fmap
23:39:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:39:41 <sully> :t (.)
23:39:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:39:44 <sully> welp.
23:39:52 <Guest1644> @djinn (a -> b, a -> c) -> a -> (b, c)
23:39:52 <lambdabot> f (a, b) c = (a c, b c)
23:40:01 <Guest1644> @. pl djinn (a -> b, a -> c) -> a -> (b, c)
23:40:01 <lambdabot> f = uncurry (liftM2 (,))
23:40:20 <Jafet>       = uncurry (&&&)
23:47:03 <dankna> AH
23:47:17 <dankna> I was building my object files with different Objective-C-garbage-collection settings
23:47:26 <dankna> leading to bizarre behavior
23:48:35 <Guest1644> @pl (\i -> (i, f i))
23:48:36 <lambdabot> ap (,) f
23:49:45 <Guest1644> @pl (\i -> f (g i) (h i))
23:49:45 <lambdabot> liftM2 f g h
23:51:16 <dankna> hah!  and it was arguably Cabal's fault not mine :D time to file another ticket
23:53:56 <Guest1644> :t liftM2
23:53:57 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:55:24 <fragamus> howdy
