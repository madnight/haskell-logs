00:45:05 <Axman6> oh no D: my older evil comercial brother
00:45:10 <Axman6> Adman65 is here!*
00:46:05 <ivanm> Axman6: you have a brother in North America? :o
00:48:25 <rprije> Hmm. I'm trying to make instances of a Sexp typeclass I created. The typeclass has a method toSexp. I want toSexp to behave differently for Strings and Lists. How can I create a specialised instance for Strings without my List instance definition getting in the way?
00:49:06 <mauke> add a listToSexp method to Sexp
00:49:17 <rprije> I was hoping you wouldn't say that :P
00:50:18 <shachaf> @src Show
00:50:18 <lambdabot> class  Show a  where
00:50:18 <lambdabot>     showsPrec :: Int -> a -> ShowS
00:50:20 <lambdabot>     show      :: a   -> String
00:50:22 <lambdabot>     showList  :: [a] -> ShowS
00:50:49 <rprije> Yeah, I know that's how Show does it. I was just hoping there'd be a clean way to do this using some sort of type hackery.
00:51:05 <rprije> Exposing showList feels like an ugly implementation detail I'd prefer to hide.
00:51:12 <ivanm> rprije: RWH covers the options for this
00:51:29 <ivanm> the alternative is to enable some extension... forget which...
00:51:53 <rprije> Yes, extensions are what i was seeking. I shall hunt down this RWH you speak of. Thanks.
00:51:57 <mauke> instance (Dynamic a) => Sexp a
00:52:10 <serpentologist> There are 2 versions of ghc packages for linux: http://www.haskell.org/ghc/download_ghc_6_12_3#x86linux  Which should I use? And what is bindlist?
00:52:33 <mauke> serpentologist: a misspelling of bindist
00:53:02 <serpentologist> anyway what is it?
00:53:10 <mauke> binary distribution
00:53:20 <ivanm> serpentologist: i.e. source or pre-compiled binary
00:53:22 <serpentologist> oops)
00:53:26 <ivanm> which distro do you use?
00:53:27 <mauke> i.e. not source
00:53:31 <ivanm> @where rwh
00:53:31 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:53:34 <ivanm> rprije: ^^
00:54:01 <rprije> Yeah, found it. I'm familiar with the book but wasn't familiar with the initialism. Thanks :)
00:58:42 <rprije> TypeSynonymInstances and OverlappingInstances are the GHC extensions I was looking for. Thanks ivanm :)
00:58:52 <ivanm> np
00:59:03 <ivanm> that's a bit of a hack though
00:59:17 <rprije> Less of a hack than showList IMO ;)
00:59:32 <ivanm> no, showList is valid Haskell code!
00:59:36 <mauke> OverlappingInstances is worse than many other things
00:59:38 <ivanm> I use that kind of trick extensively
01:00:02 <shachaf> rprije: You don't need TypeSynonymInstances, by the way.
01:00:14 <shachaf> That's just so you can say "String" instead of "[Char]".
01:00:22 <shachaf> ivanm: IsChar is also such a nice class, isn't it?
01:01:10 <rprije> shachaf, I do if I want to be able to write readably and declare "String" to be an instance rather than [Char], right?
01:01:17 <ivanm> shachaf: oh? which package defines it?
01:01:28 <ivanm> rprije: right
01:01:36 <shachaf> rprije: Sure, but that doesn't hurt anyone.
01:01:37 <mauke> FSVO "readable"
01:01:55 <shachaf> ivanm: Text.Printf
01:02:07 <shachaf> Huh, for some reason I thought it was related to showList.
01:02:13 <Feuerbach> Does David Mazières (the author of iterIO) hang out here? Can't contact him by email.
01:02:15 <shachaf> But of course it's printf.
01:02:37 <shachaf> (Which needs a String instance for PrintfType.)
01:02:58 <ivanm> wow....
01:03:10 <ivanm> lemme guess, that's another way of doign explicit type dictionaries or something?
01:04:49 <shachaf> ivanm: class IsChar c where toChar :: c -> Char; fromChar :: Char -> c
01:05:03 <mauke> why fromChar?
01:05:14 <shachaf> instance (IsChar c) => PrintfType [c] where ...
01:05:28 <mauke> ah, wait
02:23:19 <roconnor> http://keywordarguments.blogspot.com/2011/05/when-i-start-new-project-in-python-i.html
02:23:35 <roconnor> ^^ did this blogger discover parametric polymorphism and call it dynamic typing?
02:27:40 <paper_cc> does anyone here have a copy of "spreading the joy: making stricterness more relevant"? (the text, not the slides)
02:28:26 <paper_cc> it used to be available from people.cs.uu.nl/stefan, but it isn't now
02:36:37 <ivanm> paper_cc: I don't suppose you have ACM access?
02:37:04 <ivanm> paper_cc: I have it, but in a book :p
02:37:13 <ivanm> maybe try on Juurian Haage's home page?
02:40:31 <balor_> ivanm, There's always http://citeseerx.ist.psu.edu/index.jsp
02:40:42 <ivanm> balor_: *shrug* or citeseer
02:40:46 <ivanm> or arxiv
02:40:57 <ivanm> but googling didn't return either
02:41:48 <paper_cc> ivanm: indeed I don't. Hage's homepage is unavailable (503) right now, but I'll try later
02:42:12 <ivanm> paper_cc: sorry, I don't feel like scanning it in for you :p
02:42:26 <Zao> Holdermans/Hage?
02:42:57 <ivanm> Zao: they co-wrote it
02:43:16 <paper_cc> ivanm: thanks anyway =)
02:43:24 <paper_cc> Zao: yes
02:44:03 <Zao> ivanm: Yeah. I'm not sure how to indicate coauthorship.
03:10:21 <balor_> If I've got "data Foo=Foo Int" in a module and "module Bar (Foo)" exports the type Foo, but how do I export the Foo data constructor?
03:10:58 <Zao> Bar (Foo(..)) -- isn't it?
03:10:59 <mornfall> balor_: Foo(Foo)
03:11:11 <Zao> (.. would export them all, I believe)
03:11:12 <mornfall> Or (..) for all ctors.
03:12:18 <balor_> Zao, mornfall, thanks.
03:12:47 <balor_> What do you mean by "all ctors" though?  I thought a type would only have one ctor?
03:13:19 <mornfall> balor_: Foo Int | Blah Float has 2.
03:13:55 <balor_> mornfall, d'oh, yes.  Thanks.
03:50:14 <burbul> I'm just learning about monads and I'm a bit confused by the nomenclature... am I right in thinking that while something of type List a is a list of as, something of type State s a is not a state but a function which updates a state and also happens to  extract a value of type a?  (Or am I really confused!?)
03:50:37 <roconnor> if I have an injection from type A to type B, is it fair to say that type B is more general than type A?
03:51:35 <burbul> Injection in the mathematical sense?
03:51:39 <wires> Via Oleg (http://okmij.org/ftp/Computation/extra-polymorphism.html), if we defined Leibniz equality like: newtype EQU a b = EQU{subst:: forall c. c a -> c b}
03:52:22 <wires> What is an example of two terms respecting EQU a b; where a is syntactically not equal to b?
03:56:17 <wires> roconnor: if you take more general to be "less specific", then I would say no, B is more specific than A in the sense that if you have a total function on A, I could substitute it's argument for a B; but the converse it not true...
03:57:43 <wires> wait.. does that make sense?
03:59:28 <burbul> If 'injection' is meant in the mathematical sense (as opposed to a Haskell-specific) one... there are injections from Int to String, but I'm not sure it makes sense to say String is more general than Int?
04:00:36 <sipa> injection in that sense simply means more possible values
04:01:10 <sipa> for finitely many possibilities, just count them - for infinite ones, they are all equal
04:01:23 <ivanm> dammit, the first time I like delete's behaviour of stopping after it finds the first equal value.... the type is wrong for what I want :s
04:01:35 <ivanm> I want a version of deleteBy with the same type as filter! :@
04:01:38 <augur> anyone interested in seeing my undoubtedly crap fast-as-hell intro to type theory with the simply typed and dependently typed lambda calculus?
04:01:40 <augur> :X
04:01:56 <ivanm> (I know I can make one with const and undefined.... but it's the principle of the thing!)
04:01:57 <wires> burbul: Well, a function taking a String as an argument, I would consider more general then one taking a Int as the first function can take both String and via the injection and Int.
04:02:21 <wires> burbul: Well, a function taking a String as an argument, I would consider more general then one taking a Int, as the first function can take both String and via the injection and Int.
04:06:50 <burbul> ok
04:18:02 <roconnor> wires: functions taking more general arguments are more specific because of contravariance.
04:18:27 <roconnor> wires: but I find the notion of what is and is not more general kinda confusing.
04:19:42 <roconnor> every cat is a mammal so the type of mammals is more general than the type of cats.
04:19:51 <roconnor> at least that is what I'm thinking.
04:21:47 <cheater897> roconnor, what is contravariance?
04:23:15 <erus`> producing milk
04:23:24 <erus`> warm red blooded
04:34:42 <roconnor> cheater897: it referest to subtype order reversing.
04:34:54 <cheater897> why does this "reversing" happen?
04:35:33 <roconnor> cheater897: so if a' < a, i.e. a' is a subtype of a, then (c -> a') < (c -> a), but (a -> c) < (a' -> c)
04:36:06 <roconnor> so function arguments are contravariant, while function result types are covariant (order preserving)
04:37:30 <cheater897> why would something that consumes a mammal be less general than something that consumes a cat?
04:39:04 <roconnor> because everything that consumes mammals is something that consumes cats.
04:39:44 <scree> cheater897: maybe better to say something that can consume *any* mammal
04:40:28 <luite> does the author of gitit visit this channel?
04:42:53 <cheater897> roconnor, oh
04:57:00 <ivanm> grrrr..... I thought I had successfully re-written tred.c into Haskell code... only to find that it deletes _all_ edges, not just transitive ones :@
05:03:17 <develhevel> how to make not equal (in c++ !=) in haskell?
05:03:24 <wires> a /= b
05:03:54 <wires> http://www.haskell.org/hoogle/?hoogle=%28%2F%3D%29
05:05:53 <parcs> @type not .: (===)
05:05:54 <lambdabot> Not in scope: `==='
05:05:54 <wires> roconnor: ah, alright. I was always confused about that; heard about contravariance before, but didn't know this is what it meant.
05:06:16 <roconnor> it's a confusing topic
05:06:40 <wires> roconnor: specifically because of the contravariance, i suppose?
05:06:50 <roconnor> and even a little contraverisal.
05:06:56 <roconnor> yes
05:07:02 * wires nods
05:07:21 <roconnor> Effile tries to pretend arguments are covarient, but I don't see how they get away with it.
05:07:54 <wires> Effile?
05:08:21 <wires> Eiffel?
05:09:05 <roconnor> Eifel
05:09:08 <roconnor> Eiffel
05:09:09 <roconnor> yes
05:09:11 <roconnor> sorry
05:09:15 <wires> the language.. :)
05:09:18 <roconnor> yes
05:12:18 <adimit> How can I turn a lazy bytestring into a strict bytestring? (changing its type from Lazy.Internal.ByteString to Internal.ByteString?)
05:12:32 <ivanm> @hoogle toChunks
05:12:32 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
05:12:32 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
05:12:36 <ivanm> adimit: ^^
05:12:47 <adimit> ivanm: ah, thank you.
05:12:50 <ivanm> so you want SB.concat . LB.toChunks
05:13:15 <adimit> OK. It's a bit weird, because I don't actually want to do that, but hexpat forces me to :-(
05:13:22 <adimit> maybe that's a bug.
05:14:35 <keep_learning> hello all
05:14:59 <keep_learning> could some one please tell me why this code gives compiler error http://hpaste.org/paste/46910/spoj_the_very_greatest_common
05:15:07 <keep_learning> :t read
05:15:07 <lambdabot> forall a. (Read a) => String -> a
05:15:44 <keep_learning> is there any other function correspoinding to read who takes ByteString and return a ?
05:15:51 <keep_learning> :t ++
05:15:51 <lambdabot> parse error on input `++'
05:15:57 <adimit> :t (++)
05:15:58 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:15:58 <keep_learning> :t (++)
05:15:59 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:16:48 <hpc> @hoogle (Read a) => ByteString -> a
05:16:48 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:16:48 <lambdabot> Prelude id :: a -> a
05:16:48 <lambdabot> Data.Function id :: a -> a
05:16:58 <hpc> :(
05:17:22 <dschoepe> @hoogle (Read a) => a -> ByteString
05:17:22 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
05:17:23 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
05:17:23 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
05:17:34 <parcs> there's bytestring-nums which implements Num a => BS -> a
05:18:10 <hpc> presumably, to read a thing from a bytestring you must first convert to string
05:18:37 <hpc> to get past encoding issues or whatever
05:19:57 <keep_learning> hpc: thank you
05:20:17 <keep_learning> i think i have to study bytestrings in more detail
05:25:38 <adimit> When concating lots of small *strict* ByteStrings into one big *strict* ByteString, the whole big BS has to be kept in memory, right? I can't *write* lazily to disk, i.e. throw away the stuff that's already written and not anymore referenced?
05:26:18 <ben> That sounds right. But a list of strict bytestrings is almost the same thing as a lazy bytestring so just lazily convert it and write it out I guess.
05:26:47 <adimit> ben: you're right, I'll try that.
05:27:00 <adimit> I'll just have to avoid appending to that list, I guess ^^
05:54:57 <develhevel> when i write functions i can write them down in module foo (HERE) where ... but when i declare a new data type, how can i make it accessable?
05:56:35 <hpc> develhevel: say you have data Foo = Bar | Quux
05:56:49 <hpc> develhevel: to export the whole data type, add Foo(..) to the export list
05:57:03 <rovar> what hpc said
05:57:06 <hpc> to export just the type, not the constructors, Foo()
05:57:14 <hpc> to export specific ones, Foo(Bar)
05:57:31 <hpc> iirc
05:57:55 <develhevel> worked :) ty
05:59:23 <Saizan> adimit: you could use something like Data.Binary.Builder
06:00:03 <adimit> Saizan: thanks, I'll look into that.
06:00:33 <adimit> you're talking about the blaze-builder backage, no?
06:01:01 <Saizan> i was talking about binary but blaze-builder might be better these days
06:01:27 <adimit> ok, I'll look into it.
06:02:25 <adimit> though I don't think I'll need blaze builder. It's not really performance sensitive, I just don't want a 4GB xml file to stick around in memory…
06:05:35 <Saizan> adimit: it's mostly to not have to worry about appending
06:08:54 <adimit> Saizan: sounds good. I guess I'll just put a Builder in a state monad, and use wirteFile "".toLazyByteString.snd . runState
06:11:18 <Saizan> Data.Binary.Put is a Builder in a Writer monad :)
06:13:49 <adimit> Looks good, thanks :-)
06:15:58 <develhevel> which xml parser is the easyest to use: hxt, haxml or hxml?
06:16:44 <adimit> that very much depends on what you want to use it for. I like hexpat. hxt is usually overkill.
06:18:15 <develhevel> i just want to parse some xml files and read out its data
06:20:06 <adimit> if you're not afraid of monads and combinators, haxml should be ok. haxml is more performance-oriented.
06:20:54 <develhevel> and when i am afraid of it, what would be best?
06:21:07 <adimit> haxml, since you need to get over your fear.
06:21:27 <adimit> It's not hard to use :-)
06:22:44 <ArnoVanLumig> aha
06:23:22 <hpc> heh
06:28:05 <develhevel> thx
06:30:33 <mekeor> does anybody want to add "λ" to the channel-topic? :)
06:34:37 <Axman6> mekeor: what for?
06:35:03 <mekeor> Axman6: because lambda is the defining symbol/logo of haskell
06:35:20 <poltak> hurr durr
06:35:36 <Axman6> well, of lambda calculus... >λ= seems to be the haskell logo these days though
06:36:57 <mekeor> Axman6: yep, ok, so add ">λ=" to the topic please :D
06:37:10 <Axman6> i'm not an op though
06:38:40 <develhevel> is it not ossible in do notation to write "do x=myfoo" when e.g. myfoo is myfoo :: [String]
06:38:54 <ben> do let x = myfoo
06:40:15 <develhevel> thx
06:45:47 * hackagebot xmlgen 0.4.0.2 - Fast XML generation library  http://hackage.haskell.org/package/xmlgen-0.4.0.2 (StefanWehr)
06:49:47 * hackagebot HTF 0.7.0.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.7.0.1 (StefanWehr)
07:11:40 <ion> A Study in Keith http://vimeo.com/2433947 (Offtopic, really, but great livecoding)
07:18:08 <Axman6> what's keith?
07:19:14 <Zao> ion: So why didn't you link this in -blah?
07:19:27 <Zao> As you knowingly linked something you knew was off topic?
07:22:01 <ion> Let’s implement the same in Haskell! (Fixed it. Happy?)
07:33:41 <roconnor> is it fair to say that (Num a) => [a] is a "subtype" of (Show a) => [a] ?
07:45:21 <Saizan> usually T =< S when you can swap (t : T) for (s : S) in an expression and still get a well-typed term, (in simply typed cases at least), so it's (Show a) => [a] that's a subtype of (Num a) => [a]
07:45:34 <Saizan> which fits with the contravariance of =>
07:45:42 <Saizan> in its first argument
07:48:04 <Saizan> about using "subtype" at all here i'm not sure, maybe make it clear that it's non-standard terminology
07:54:53 <roconnor> Saizan: iff foo :: forall a. (Num a) => [a] and bar :: forall a. (Show a) => [a], then if bar is being used somewhere then I can replace it with foo.
07:55:06 <roconnor> and the program will still type
07:57:46 <Saizan> roconnor: can't derive Num X from Show X in use of foo
07:58:22 <roconnor> ya but if bar is being used in some place, then it is being in used in a context expecting Show
07:58:47 <Saizan> no, it's used in a context providing Show, such that you can pass it to bar
07:58:49 <roconnor> so I can replace bar with foo and since Show is implied by Num it can be used there.
07:59:19 <adorablepuppy> Is it ok to put a link to my Haskell github project here?
07:59:38 <roconnor> adorablepuppy: I think so
07:59:42 <hpc> ^
07:59:59 <Saizan> roconnor: it seems you're thinking of data AnyNum = forall a . Num a => AnyNum a; data AnyShow = forall a. Show a => AnyShow a instead of the types above
08:00:14 <roconnor> ah
08:00:30 <roconnor> Indeed I am ^_^
08:00:42 <Saizan> or maybe even letting a be free
08:00:54 <roconnor> no no you are right
08:01:00 <Saizan> C a *> [a] vs. C a => [a]
08:01:06 <roconnor> yes
08:01:25 <adorablepuppy> I am introducing my fledgling project: CurryDog. A haskell game engine in development that will support 2d and 3d (eventually). https://github.com/adorablepuppy/CurryDog (I'm sorry if the code's not very good)
08:01:55 <adorablepuppy> MIT license.
08:02:11 <roconnor> there is a haskell game channel somewhere ...
08:02:54 <hpc> #haskell-game
08:03:14 <adorablepuppy> Ah. I see.
08:04:00 <hpc> adorablepuppy: you can use records in Data.lhs
08:04:42 <hpc> data Vector = V2 {vx :: Float, vy :: Float} | V3 {vx :: Float, vy :: Float, vz :: Float}
08:04:45 <hpc> i think
08:05:37 <hpc> same for the color type
08:05:48 <adorablepuppy> hpc: I didn't know I could reuse vx or vy like that. .. .
08:05:51 <adorablepuppy> I'll have to do some cleaning up
08:06:50 <hpc> also, i would personally only have RGB and RGBA constructors for color
08:07:16 <hpc> but i don't know the reasoning behind the extra ones, so ignore that bit of rambling :P
08:07:40 <adorablepuppy> I think ABGR and BGR are used on PPC, that's why I included it
08:07:49 <adorablepuppy> I can of course take it out.
08:08:17 <hpc> that's something you can worry about later, i suppose
08:08:39 <roconnor> adorablepuppy: since you aren't using packed records, there isn't much point in having both RGBA and ABGR
08:09:12 <adorablepuppy> roconnor, why's that?
08:09:30 <roconnor> The data types in Haskell are machine independent
08:10:08 <roconnor> the ABGR vs RGBA occurs when you read a colour as a 32-bit word and then cast it to an array of 4 bytes
08:10:24 <roconnor> then endieness issues arries
08:10:27 <roconnor> *arrises
08:10:39 <roconnor> but without type casting the issue doesn't come up
08:11:04 <adorablepuppy> Ah. Well, seems I have a bit of cleaning up to do then.
08:12:57 <roconnor> adorablepuppy: you are also welcome to use my colour library if you want :P
08:15:04 <roconnor> My ICFP paper reviews vary from 1 - reject to 5 - strong accept.
08:15:27 <adorablepuppy> That would be http://hackage.haskell.org/cgi-bin/hackage-scripts/package/colour-0.0.0, correct?
08:15:36 <BMeph> roconnor: Then that means you win! ;)
08:15:51 <roconnor> does it?
08:16:01 <roconnor> adorablepuppy: close http://hackage.haskell.org/package/colour-2.3.1
08:16:31 <adorablepuppy> Ah, I just googled your handle and colour and popped up the first link.
08:16:55 <byorgey> roconnor: haha, crazy =)
08:17:39 <BMeph> roconnor: Depending somewhat on the reasons for the rejection; I say "somewhat" since someone has already given it a "strongly accept". The implication is that you have something worth printing, just issues with how it's been written.
08:17:45 <hpc> have fun googling my nickname :P
08:17:53 <roconnor> BMeph: ya, I think so
08:18:15 <roconnor> The main problem seems to be my paper isn't well motivated, which is a fair critisism
08:20:10 <tromp_> hi, brent
08:20:36 <tromp_> your diagrams looks very impressive
08:20:39 <byorgey> hi tromp_
08:20:42 <byorgey> thanks!
08:20:46 <tromp_> unfortunately i failed to install it
08:20:47 <roconnor> adorablepuppy: let me know if you have any question or comments about my colour package.  It probably needs a better tutorial
08:20:49 <adorablepuppy> hpc: I can imagine having trouble with that.
08:21:00 <tromp_> something about cairo-pdf being required but cannot be found
08:21:01 <roconnor> adorablepuppy: or feel free to ignore it too.
08:21:04 <byorgey> tromp_: what platform are you on? and what was the error?
08:21:05 <roconnor> :)
08:21:08 <adorablepuppy> roconnor, I'm reading the haskellwiki at the moment.
08:21:18 <byorgey> tromp_: let me qguess, MacOS?
08:21:21 <tromp_> this is a ubuntu machine at home
08:21:30 <byorgey> hmm
08:22:19 <byorgey> tromp_: you're probably missing a development package, let me do a little research
08:22:20 <tromp_> i'm at work now, so cannot reproduce the exact error
08:22:45 <tromp_> maybe i can find it again on google, there were 3 hits
08:23:14 <adorablepuppy> roconnor, this actually should be a pretty useful module for my project.
08:23:21 <tromp_> http://hpaste.org/41811/cabal_cairo_install_fail
08:23:21 <byorgey> tromp_: do you have  libcairo2-dev  installed?
08:23:43 <tromp_> i'll check when i get back home:)
08:23:55 <byorgey> ok =)
08:24:01 <tromp_> see the link for the exact error msg i got
08:24:21 <byorgey> yup
08:24:52 <Saizan> tromp_: pkg-config is a tool for C libs, so you won't be able to install them with cabal in general
08:24:52 <byorgey> since it says 'missing pkg-config package' that means it is something you need to install via apt-get rather than from Hackage
08:25:15 <tromp_> right; i did try sudo apt-get install cairo-pdf and failed miserably:(
08:25:40 <byorgey> hehe, right, the pkg-config package 'cairopdf' is probably provided by some other apt package
08:26:02 <byorgey> this is the most annoying part of dependency chasing, figuring out what package provides something the install says is missing
08:26:15 <tromp_> isn't there a way to ask apt-get what packages provide what?
08:26:31 <byorgey> I usually just do 'apt-cache search foo' where foo is some word related to what I need, and randomly install promising looking packages
08:26:38 <byorgey> there is probably a better way
08:26:44 <tromp_> in practice one always googles for the error message:(
08:26:48 <byorgey> right =(
08:27:25 <tromp_> ok, sounds like  libcairo2-dev will fix the problem
08:27:30 <tromp_> i'll try tonight
08:27:36 <tromp_> thx
08:27:36 <byorgey> well, hopefully as people try installing diagrams we can get better information on the website as to how to install it
08:27:40 <byorgey> sure
08:28:11 <byorgey> at some point we will also get a different backend which doesn't depend on cairo
08:28:17 <byorgey> since it's always cairo people have problems installing
08:28:51 <Saizan> debian happens to package haskell-cairo, so you could've looked here http://packages.debian.org/source/sid/haskell-cairo
08:29:04 <Saizan> which is linked from here http://hackage.haskell.org/package/cairo-0.12.0
08:29:21 <tromp_> i'd be happy with just a postscript backend
08:29:24 <Saizan> i guess cabal could automate some of that..
08:30:06 <tromp_> is diagrams like SVG on (haskell) steroids?
08:30:48 <dcoutts> Saizan: automate what? suggesting what distro packages are missing?
08:30:57 <byorgey> tromp_: like SVG on steroids and a hyper-dimensional tim-traveling robot sidekick
08:31:17 <byorgey> tromp_: it's much higher-level than SVG
08:31:43 <tromp_> so SVG could be another backend?!
08:31:51 <byorgey> absolutely
08:32:04 <dcoutts> it is already isn't it? cairo can output svg
08:32:14 <byorgey> in fact, that's precisely what I want to do -- have a native SVG backend which would have no dependencies
08:32:22 <byorgey> dcoutts: yes, it can already output SVG, but not natively
08:32:25 <tromp_> cut out the cairo middle man?
08:32:28 <byorgey> right
08:32:48 <byorgey> eventually I want to have lots and lots of backends
08:33:05 <tromp_> including ascii art :-?
08:33:07 <byorgey> yes!
08:33:13 <byorgey> why not? =)
08:33:16 <tromp_> awesome!
08:33:33 <byorgey> making a new backend just requires making an instance of the Backend type class.  so it's not hard.
08:33:42 <ezyang> What operations do you need to support?
08:33:54 <byorgey> whichever ones you want =)
08:34:18 <byorgey> you just make an instance of Renderable for each primtive your backend can render
08:35:07 <byorgey> and you can selectively look at only the attributes you want to do something with
08:35:27 <byorgey> i.e. an ASCII backend could ignore color
08:58:37 <sm> oh, ascii art would be great
08:58:42 <sm> go byorgey
09:00:14 <Saizan> dcoutts: yeah, or at least list all the non-hackage deps the distro package has
09:00:46 <ezyang> What's the easiest way to convince hp2ps not to truncate the key? -M doesn't seem to work.
09:01:41 <ezyang> Oh, it seems that this is a problem with the heap profile itself.
09:01:57 <c_wraith> there is an RTS option to output more of the name
09:02:04 <c_wraith> I don't remember what it is
09:02:09 <ezyang> -L
09:44:52 <Sagi> I'm currently looking at http://hackage.haskell.org/packages/archive/network-data/0.2.0/doc/html/Data-IP.html Can someone explain to me why the author might have chosen to autoderive a show instance and point to ipv4 as a printing function? I don't get how you can use that to print.
09:46:33 <jmcarthur> Sagi: looks like maybe the author was confused?
09:46:49 <Saizan> ipv4 is to parse
09:46:53 <Sagi> I'm basically looking for f :: IPv4 -> String, which doesn't use the ByteString Show instance
09:47:09 <jmcarthur> Sagi: i see an instance of Pretty, which might be what the author meant
09:47:30 <Sagi> Saizan: thought so, but I wasn't sure if I was missing some magical feature of parsec :)
09:47:53 <Cale> Sagi: I'm not sure I understand the question... The derived instance for Show will print the address like  IPv4 "...." (using the default instance for ByteString to show the bytes of the address, which seems to render it in ASCII)
09:48:05 <ClaudiusMaximus> :t prettyShow
09:48:06 <lambdabot> Not in scope: `prettyShow'
09:48:35 <jmcarthur> Sagi: the reason for autoderiving Show is because Show is intended as kind of a debugging tool, not always for real I/O
09:48:43 <Cale> Yeah, pPrint looks good
09:49:43 <Sagi> hmm, why not print in a more human readable format, as long as it's Read'able it's okay, right?
09:50:19 <Sagi> I'll look at the Pretty instance, thanks
09:51:09 <jmcarthur> Sagi: it's nice for the output of show to be usable as haskell code so that you can do things like paste it into ghci or something
09:51:31 <kaini> Hey, I tried to implement floyds pathing algorithm (http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm) and I am using the Data.Array thing: https://gist.github.com/7f9f487e9f937e466d98 But this way of implementing it is quite slow and soaks up lots of memory if there are lots of nodes.
09:51:56 <kaini> I guess the best would be to use some sort of mutable array/matrix but that is not very "haskell"-stylish, or is it?
09:52:34 <Sagi> So, if I want to some debug printing of IPv4Header (which contains IPv4 as a record), what do you advise? Make it an instance of Pretty aswell? I hate to look at the ByteString Show representation, it's barely readable..
09:52:57 <Sagi> +do
09:53:15 <jmcarthur> Sagi: if you have a syntax tree representation then that's the one i would be printing for debugging
09:54:27 <Cale> kaini: On the wikipedia page, there is a recursive formula for shortestPath which you can probably turn into a pretty nice functional algorithm for computing it.
09:56:02 <Cale> kaini: You should generally try to get away with the smallest number of array update operations you can manage, because they are expensive for immutable arrays.
09:56:49 <Cale> kaini: Luckily, Floyd-Warshall doesn't really need array updates at all -- you can just make a new array for each stage.
09:57:07 <Cale> (it's clever to do it in-place, but that's not really necessary)
09:57:19 <kaini> Cale, the idea using the formula is great
09:57:59 <kaini> Cale, I have not realized I could use that too
09:58:01 <Cale> kaini: You can actually translate that formula into a pretty efficient version just using something like Data.MemoCombinators to memoise the shortestPath results in an array.
09:58:13 <kaini> I guess I do not think functional enough yet :p
09:58:23 <Sagi> What's the most idiomatic way of Using an Either a a with a f :: a -> a? there must be something better than either f f (Either a a), right?
09:58:53 <jmcarthur> :t join either
09:58:54 <lambdabot> forall a c. (a -> c) -> Either a a -> c
10:00:30 <Sagi> ah, cool, thanks
10:00:31 <kaini> Cale, thanks for all that ideas :) I guess I got it now
10:01:11 <Sagi> ezyang: thanks for making those informative blog posts, I really enjoy reading them, learning something new every time!
10:01:41 <Cale> kaini: I'll write up a version which uses Array a bit better
10:11:41 <erus`> whats the game where you have to kill people without the 'sheriff' seeing and he has to find the killer?
10:12:34 <ion> Real life
10:12:48 <tg_> I shot the sherrif!
10:13:11 <erus`> the roleplay game
10:13:18 <erus`> where u just touch someone to kill them
10:13:57 <jmcarthur> mafia?
10:19:34 <erus`> yeah thats it. It would make a crap video game though
10:20:56 <jmcarthur> the deliberation among the townspeople is a very important part of that game
10:27:57 <k0ral> hello guys, I've built the beginning of what will be a minimalistic browser in Haskell, and I'd like to share it with the community, get opinions, pieces of advice, and why not some help
10:28:26 <Cale> k0ral: cool, is it on Hackage?
10:28:48 <k0ral> Cale: you think I should upload it to hackage ?
10:29:17 <k0ral> I put it there for now : http://git.twyk.tk/?p=haskell-browser.git
10:30:01 <Cale> If it's not on Hackage, it doesn't exist ;)
10:30:09 <k0ral> this is the first app I've ever coded in Haskell, so don't expect to see something really sophisticated
10:30:49 <k0ral> Cale: well, I upload it right now
10:31:19 <k0ral> I would really appreciate comments on my code, since I may have coded in a very newbie way
10:32:31 <k0ral> there are not many features yet, but it's usable
10:32:51 <k0ral> which brings me to the fact that I was inspired by uzbl
10:33:14 <k0ral> in the end I'd like to reach the same level of features/configurability as uzbl
10:33:35 <k0ral> but with all the advantages of pure functional programming :)
10:34:38 <k0ral> hmmm, why do I have to ask for a hackage account to ross@soi.city.ac.uk ?
10:35:30 <Cale> Because anyone is allowed to contribute a new version of any package
10:35:40 <Cale> once they have an account
10:35:47 <k0ral> fine
10:36:15 <k0ral> am I supposed to give my real name ?
10:36:39 <beastaugh> yes
10:36:54 <k0ral> fine
10:36:59 <DevHC> no, u don't have to
10:37:16 <k0ral> so ?
10:37:20 <k0ral> yes or no ?
10:37:36 <DevHC> use, for example, "Johnny Blargious"
10:37:47 <beastaugh> he didn't ask if one had to, he asked if one was supposed to
10:38:00 <k0ral> beastaugh: my bad, I meant "had to"
10:38:10 <shachaf> Cale: You know, that's kind of a bad excuse for designing a system a certain way.
10:38:18 <shachaf> Presumably it's going to be changed someday?
10:38:42 <Cale> Well, presumably if there are eventually access control lists, they can open up user registration a bit.
10:38:49 <k0ral> Johnny blargious ?! you just invented it right now ?
10:38:59 <DevHC> ofc
10:39:06 <k0ral> I'm fine with it
10:39:09 <DevHC> :D
10:39:19 <beastaugh> Ross usually responds pretty promptly
10:39:26 <ddarius> I'm pretty sure Hackage 2 already has better security.
10:39:39 <ddarius> shachaf: It wasn't exactly "designed" that way.
10:39:53 <Cale> To be honest though, I really like this way of doing things
10:39:56 <beastaugh> when I registered I had an account within 7 minutes
10:40:48 <DevHC> to wake mr. ross up, register a hackage account.
10:40:55 <k0ral> hmm, I guess I need to give a specific name to my app
10:41:24 <Cale> k0ral: It seems to work well, but it needs an address bar :)
10:41:57 <Yrogirg> Can I somehow install GHC from cabal?
10:42:06 <dcoutts> no
10:42:24 <k0ral> Cale: well, like uzbl, it isn't considered as an important widget
10:42:31 <k0ral> like *in* uzbl
10:42:43 <k0ral> it's a minimalistic browser
10:42:56 * rothwell grinds teeth at "minimalistic"
10:43:01 <k0ral> you could use only the keyboard to control it
10:43:06 <k0ral> so an address bar would be useless
10:43:28 <k0ral> rothwell: isn't that the correct word ? I'm not english-native
10:43:36 <rothwell> you're forgiven
10:43:45 <DevHC> "Uzbl is under heavy development and should be considered alpha."
10:43:52 <rothwell> it's "minimal" or at a stretch "minimalist"
10:44:22 <k0ral> rothwell: damn, I have to change it in git logs, in cabal description...
10:44:27 <rothwell> hehe
10:44:36 <k0ral> rothwell: it will always appear in the old entries of git
10:44:44 <k0ral> rothwell: I'm so ashamed
10:45:08 <beastaugh> that's what rebase is for
10:45:43 <k0ral> beastaugh: didn't know, I will look at it
10:45:55 <beastaugh> I wasn't entirely serious :)
10:46:06 <k0ral> DevHC: so what ?
10:46:06 <beastaugh> but you can use git rebase to rewrite your history
10:46:15 <DevHC> nothing, just trolling :]
10:46:56 <k0ral> I used to follow uzbl development very closely, I even contributed for some very tiny commits
10:47:36 <jmcarthur> i used uzbl for a while, but then an update broke all my configs and i didn't feel like fixing them
10:47:40 <DevHC> who uses git in the following fashion? edit the code for 5 minutes, then commit the changes with the "off to get a coffee" description quickly before leaving for a coffee?
10:48:11 <jmcarthur> i'm known to use darcs that way sometimes
10:48:22 <jmcarthur> but such patches never get pushed of course
10:48:46 <DevHC> i hope so, lol
10:48:57 <nyingen> I do that too, but again, I don't push those commits
10:49:38 <ddarius> What's the point of doing that?
10:50:00 <jmcarthur> it's just an undo point
10:50:08 <nyingen> that, and I often change machines in between
10:51:14 <jmcarthur> usually if i feel like it's a good time to get up and get coffee then my code is in some state that i don't mind coming back to after some time. that usually means it's a good time for a snapshot
10:53:01 <DevHC> yeah but taht's not like "instant commit: brb, gonna take piss !"
10:53:19 <DevHC> do u often juggle dpatches between machines?
10:53:32 <nyingen> DevHC: does he also make dummy commits "ok, back" ?
10:53:48 <DevHC> i dunno :P
10:54:03 <jmcarthur> i do sometimes juggle patches between machines, but currently i only develop on one machine anyway
10:54:07 <k0ral> I've just sent the request for a username to ross, let's see if in 7 minutes I will have been answered :)
10:54:18 <DevHC> nyingen:do u often juggle dpatches between machines?
10:54:19 <k0ral> dealing with the rebase thing now...
10:54:26 <nyingen> DevHC: constantly
10:54:37 <DevHC> mkay...
10:54:57 <DevHC> does anyone find git or darcs any more productive or easier to use?
10:55:16 <k0ral> never used darc
10:55:17 <jmcarthur> i find darcs to be definitely easier to use
10:55:26 <k0ral> is there really a point in switching from git to darcs ?
10:55:39 <jmcarthur> as for productivity, *i* find it a bit more productive, but not everybody will agree
10:55:41 <k0ral> jmcarthur: give arguments
10:55:52 <nyingen> as far as I can tell, people learn a dvcs and stick with it
10:55:53 <jmcarthur> k0ral: i think the simplicity of the interface speaks for itself there
10:56:09 <jmcarthur> k0ral: and productivity is largely subjective
10:56:16 <k0ral> nyingen: I switched from svn to git...
10:56:22 <jmcarthur> svn is not a dvcs
10:56:26 <k0ral> oh
10:56:28 <k0ral> d
10:56:30 <k0ral> right
10:56:38 <jmcarthur> i used darcs for a while, then git for quite a while, and now i'm back to darcs
10:56:38 <nyingen> I don't see too many cases of "conversion", and also I haven't really seen compelling arguments to promote any of the DVCSs over any of the others
10:56:51 <Jonno_FTW> how different is darcs from git?
10:56:53 <nyingen> though I recall hearing that bzr is slower or something
10:56:55 <jmcarthur> very
10:57:00 <jmcarthur> ^^ Jonno_FTW
10:57:06 <cheater897> nyingen, lies
10:57:21 <Jonno_FTW> which should I use?
10:57:23 <jmcarthur> Jonno_FTW: darcs has a completely different model
10:57:26 <cheater897> nyingen, you just need to operate bzr in local commit mode, and then you have the "speed" of git
10:57:35 <Jonno_FTW> (i know a little bit of git)
10:57:38 <cheater897> that you get by never actually syncing with where you've checked out from.
10:57:41 <jmcarthur> it is impossible to say which you "should" use
10:57:43 <DevHC> Jonno_FTW: darcs, if u haven't learned any VCS yet :
10:57:47 <DevHC> - :
10:58:20 <cheater897> git is universally known to be cancer
10:58:25 <jmcarthur> yeah, my recomendation is also darcs, for beginners. i would recommend the same for experienced dvcs users, but i don't have the energy to convince them
10:58:51 <Jonno_FTW> how long would it take to learn darcs?
10:58:54 <jmcarthur> people get opinionated once they have mastered any one option
10:59:15 <jmcarthur> you can be productive with darcs in about five minutes
10:59:26 <jmcarthur> takes a little longer to be a darcs master of course
10:59:29 <DevHC> Jonno_FTW: not long at all, but that's true basically for any other DVCS
10:59:35 <jmcarthur> it is as DevHC says
10:59:53 <jmcarthur> well, being productive with git might take more like 10 minutes
11:00:21 <Jonno_FTW> ok thanks
11:00:23 <ktosiek> I think the main problem is once you know one DVCS learning others doesn't look too rewarding
11:00:24 <jmcarthur> unless you happened across a tutorial that teaches only the combinations of flags that makes it behave like darcs
11:00:34 <jmcarthur> *somewhat like darcs
11:01:10 <jmcarthur> ktosiek: which is sad, because darcs is *actually* different from most other dvcss, but most people assume it is not since most aren't
11:01:29 <DevHC> to me, learning darcs has 2 reasons: 1 <3 haskell, and patch formalization is 1337
11:01:37 <DevHC> i <3*
11:01:43 <cheater897> jmcarthur, what makes darcs better than bzr?
11:01:48 <jmcarthur> the main thing for me is less restricted cherry picking
11:01:52 <cheater897> i'm fine with bzr but i heard darcs has nicer things
11:01:59 <pozic> DevHC: why don't you learn Camp then?
11:02:11 <DevHC> S00N(TM)
11:02:26 <jmcarthur> is camp in a usable state yet? and how does it differ from darcs?
11:02:29 <DevHC> when's that camp&darcs merge?
11:02:31 <cheater897> jmcarthur, how is bzr cherry picking restricted? i have never used that
11:02:33 <geheimdienst> git's tradeoff seems to be saving split-seconds of computer time at the expense of hours of human time for learning and pulling your hair out ...
11:02:41 <geheimdienst> :P
11:03:07 <cheater897> geheimdienst, yeah, it's annoying.
11:04:05 <jmcarthur> cheater897: does bzr allow you to cherry pick in any order you want without changing commit identities and without requiring any sort of reordering?
11:04:36 * ddarius hopes this is a typo in Simon Marlow's parallelism/concurrency tutorial.
11:04:58 <tsuraan> In my .cabal file, how do I specify that a package I depend on must be built with a certain flag?
11:05:01 <jmcarthur> cheater897: if you have new commits A, B, C, D, and E, can i pull whichever ones i want (assuming they don't depend on each other) without having to pull any others? can i then make new commits and push them back to you without needing the others?
11:05:48 <parcs> tsuraan: i don't think you can
11:06:05 <tsuraan> oh, weird
11:06:07 <jmcarthur> tsuraan: i wish that was possible
11:06:48 <cheater897> jmcarthur, no idea. can you?
11:07:24 <jmcarthur> cheater897: aside from patch dependencies (A is required in order for B to be at all valid), yes
11:07:40 <cheater897> jmcarthur, can you do that in bzr too?
11:07:41 <jmcarthur> cheater897: err, in darcs
11:07:45 <jmcarthur> i think i misunderstood that question
11:07:49 <cheater897> yep
11:07:50 <cheater897> :D
11:08:28 <jmcarthur> i've never used bzr. that's why i was asking
11:08:37 <ktosiek> jmcarthur: are those dependencies somehow autogenerated?
11:08:39 <jmcarthur> but i highly doubt the answers to those questions are yes
11:08:40 <cheater897> oh ok
11:08:47 <cheater897> i wouldn't know, i just use bzr for development.
11:08:53 <ddarius> Interesting.  Wizard's Bane seems to be (also) published online by Baen.
11:08:56 <cheater897> not for uhm..
11:09:03 <cheater897> some other weird stuff :D
11:09:23 <jmcarthur> ktosiek: the dependencies are automatically added if they are textual dependencies (A and B both modify the same line), and you can add them yourself if they are other kinds of dependencies
11:10:57 <jmcarthur> ktosiek: in practice, most people just stick with the textual dependencies and ignore any others. the end result is, unfortunately, that you can end up in a state that your code doesn't build or something
11:11:12 <jmcarthur> but that's not actually very common, in my experiences
11:11:14 <ezyang> Structure preserving functions on value lazy data structures should induce lazy spines. Discuss.
11:11:38 <jmcarthur> ezyang: what do you mean by "induce"?
11:12:05 <jmcarthur> ezyang: do you mean that the result should have a lazy spine even if the input had a strict spine?
11:12:36 <jmcarthur> or do you just mean that such operations should only be performed on lazy spines to beging with?
11:12:40 <jmcarthur> *begin
11:13:08 <jmcarthur> i think my response to either is disagreement
11:13:29 <jmcarthur> at least, i disagree as long as fusion is viable
11:15:48 <jmcarthur> but i'm curious about the rationale behind your suggestion. i can kind of see in a hand-wavy sort of way what might be a reason, maybe...
11:16:23 <jmcarthur> lol wordiness
11:18:33 <ddarius> ezyang: Read Okasaki.
11:20:13 <dmwit> So.
11:21:10 <dmwit> I replaced a pure record field with an IORef and replaced every record update of that field to an update that *created a new IORef* pointing to the new version.
11:21:17 <k0ral> coming back to darcs, is there something like gitweb for darcs ?
11:21:19 <dmwit> writeIORef and modifyIORef don't appear in the program text.
11:21:28 <dmwit> And yet it behaves differently (and buggy) now, when it didn't before.
11:21:39 <dmwit> What gives?
11:22:07 <ddarius> dmwit: You made a mistake.
11:22:19 * hackagebot monte-carlo 0.4.1 - A monad and transformer for Monte Carlo calculations.  http://hackage.haskell.org/package/monte-carlo-0.4.1 (PatrickPerry)
11:22:44 <dmwit> =(
11:22:51 <DevHC> i use git for developing a project on my own (not much D from DVCS). atm i have the latest code from another svn repository as a BIG initial commit, and like 140 further development commits. the first few commits r small changes to make the project compile on my system, then come the bugfixes that i intend to submit, then come some private features: first r usability and development (testing, etc.) utilities, and the last ones r the one's i'm currentl
11:22:51 <DevHC> y working on. i often rebase the whole repo to move soon-to-be-included-in-the-svn-repo patches near the first commit (and update the initial commit as the fixes get accepted in the svn repo), fix bugs in my own features (update the commits), move older commits forward if i decide to work on them more (but ofc i take note of the commits' dependencies), etc. so the basic idea is that i group all of my changes in a logical order, and i can list all of m
11:22:52 <DevHC> y changes in the order i like. how do i do such logical groupings in darcs? (i don't know how to reorder patches in ``darcs changes'', and darcs' amend feature clogs up the ordering per amendment.)
11:22:52 <dmwit> I want to blame Cairo for my problems, not me. =(
11:22:53 <ddarius> dmwit: Old references to the record will hold the old IORef and thus the old value.
11:23:13 <dmwit> ddarius: Yes... and they would have done that in the non-mutating version, too, no?
11:23:17 <pozic> jmcarthur: if Cabal doesn't allow you to distribute a package in a working state, do it differently.
11:24:12 <ddarius> dmwit: I was trying to go somewhere with that, but I forget where.  I stick to my original statement.  (Though there is the fact that IORefs compare for equality differently.)
11:24:13 <pozic> jmcarthur: but really, you can do it with Cabal by writing a custom Haskell program, which is executed when you download the package.
11:24:24 <dmwit> oh my
11:24:41 <dmwit> It would indeed be a subtle thing to track down all the changed instances.
11:27:19 <ddarius> dmwit: You either created a record with the old reference instead of the new reference, or with the new reference pointing at the old data, or you rely on type class instances, say, for the field.
11:28:09 <dmwit> Well, it's not instances. I don't have any instances of anything for that record.
11:28:17 <dmwit> So I must have made a mistake.
11:28:49 <jmcarthur> pozic: huh?
11:29:06 <dmwit> DevHC: You can't choose the order of patches in darcs.
11:29:24 <dmwit> DevHC: You could potentially create a new repository, and then pull in patches in the order you wanted.
11:29:31 <DevHC> can i GROUP them in some way?
11:29:33 <dmwit> But that sounds somewhat painful.
11:29:47 <dmwit> DevHC: darcs has tags, as most VCS' do.
11:30:14 <DevHC> which does what?
11:30:53 <jmcarthur> pozic: are you referring to the package flags thing?
11:33:47 <parcs> tags assign a relevant name to a commit, i think
11:35:08 <jmcarthur> tags are basically snapshots of all the patches currently in the repo
11:35:29 <jmcarthur> they are implemented as patches that just depend on every other existing patch
11:35:50 <jmcarthur> well, that might not be literal
11:35:59 <jmcarthur> but it's the same basic idea
11:38:57 <jmcarthur> informal survey: what are some annoyances you have with quickcheck?
11:40:19 <tomh> mm if you need to work with arrays or maps which get updated a lot then a mutable version is better right?
11:40:31 <jmcarthur> not as a rule
11:40:57 <tomh> if you want to modify the content of the an immutable array, it would have to be copied entirely?
11:40:59 <geheimdienst> if you "cabal install quickcheck", is it still the case that you get some ass-old version? there was some setting in the preferred-versions file or whatever ...
11:41:36 <jmcarthur> i think you get the newer one now, but i could be misremembering
11:41:38 <geheimdienst> that might be confusing to newbies (it sure was to me, i waltzed in here and said "well quickcheck hasn't been updated in years and is nearly undocumented, what gives?")
11:42:18 <jmcarthur> i get the new one
11:43:19 <geheimdienst> great, good to hear
11:45:21 <tomh> is an operation like update on an immutable map still considered as O(1) or O(log n) with the binary tree implementation?
11:46:02 <Martty> why would it be O(1)
11:46:02 <jmcarthur> tomh: updating a single element in a tree takes O(log n) time
11:46:13 <ddarius> tomh: If you are modifying most of the cells of the array anyway, then that cost is amortized.
11:46:14 <ktosiek> tomh: Data.Map is binary tree
11:46:27 <jmcarthur> tomh: that is the same even if the tree was mutable, for the record
11:46:35 <ktosiek> Martty: if map was a hashtable IIRC
11:46:35 <tomh> ok, so the performance is the same?
11:46:56 <jmcarthur> Data.Map performance is reasonable
11:47:10 <tomh> I prefer to work with the immutable structures but which one would be the most performant?
11:47:21 <jmcarthur> it depends on what you are doing
11:47:35 <ddarius> and you
11:47:49 <tomh> im implementing a path finding algorithm
11:49:09 <jmcarthur> like A*?
11:49:17 <tomh> it is A* yeah
11:49:31 <jmcarthur> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html :)
11:49:37 <tomh> haha
11:50:05 <tomh> well, I wanted to implement it myself to keep my haskell skills sharp or improve them :)
11:50:36 <jmcarthur> that package still leaves the choice of data structure up to you
11:50:41 <jmcarthur> just not the algorithm
11:50:44 <byorgey> oh yeah, I remember Cale implementing that during the ICFP programming contest 2 years ago =)
11:51:07 <jmcarthur> i actually used it in a contest once, too
11:51:29 <jmcarthur> well i ended up not using it in the long run, but i was using it for a while at least
11:51:34 <ddarius> It reduces the problem to essentially a choice of graph representation.
11:52:28 <tomh> the package seems to use immutable sets and maps
11:52:32 <tomh> I guess I could use that too
11:52:41 <jmcarthur> it does?
11:52:51 <jmcarthur> i see a queue, and that's it
11:52:52 <tomh> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/src/Data-Graph-AStar.html#aStar
11:53:04 <jmcarthur> oh huh it has other stuff too
11:53:18 <tomh> yeah
11:53:27 <jmcarthur> well, there you go
11:53:31 <tomh> it uses the map for exactly the same thing I planned to use it for
11:53:38 <tomh> so I guess its performant enough :)
11:54:06 <jmcarthur> if the performance becomes an issue you can handle it at that time instead of now :)
11:54:30 <tomh> yeah :), but I like fixing performance issues :P
11:54:47 <DevHC> "Darcs can recognize if a patch is as a tag" <-- does speks engrish?
11:55:06 <ddarius> It's nicer to fix performance issues when you have a reference implementation to compare against (both for correctness and baseline performance.)
11:55:08 <tg_> DevHC: no idea, maybe it means "if the entire contents of the patch changes only tags"?
11:55:16 <tg_> just a wild guess, know little about darcs
11:55:33 <tomh> ddarius: well this was more to correctly chose the most performing datastructure
11:55:38 <tomh> I think its valid to do that
11:55:39 <DevHC> suggestion: -as
11:55:40 <tomh> up front
11:55:55 <jmcarthur> tomh: it's still going to greatly depend on how you will use it
11:56:08 <tomh> thats true
11:56:32 <jmcarthur> for what purpose within the algorithm is it being used? what are the keys? what are the access patterns? is it possible to do batch updates in your algorithm? etc.
11:56:45 <tomh> but performance wise, I don't have many knowledge to reason about the performance differences between mutable and immutable data structures
11:57:27 <ddarius> tomh: It is for asymptotic concerns and if you care about the asymptotic case, but between choices that don't vary much and when you care about actual performance, it is much harder to make a correct decision up front.
11:57:29 <tomh> in my mind it sounds more efficiently to update an existing structure rather than copying it and adding the modification
11:57:45 <tomh> ok
11:57:57 <jmcarthur> with a strict data structure, there is at worst a log n slowdown for immutable vs. mutable. for laziness, it's unknown whether it can always be the same as the mutable version, but it is certainly no worse than the immutable one
11:58:07 <ezyang> jmcarthur/ddarius: Sorry, I wandered away from the keyboard.
11:58:33 <byorgey> tomh: note that "copying it and adding the modification" may involve only copying a small part and sharing the rest.
11:58:39 <jmcarthur> tomh: of course, a purely functional data structure doesn't have to be copied in its entirety all the time
11:58:50 <ezyang> jmcarthur: The particular case I'm thinking of is I map over a spine-strict structure which is value lazy, and as a result I generate n thunks where n is the number of elements in the structure, because it's spine strict.
11:58:51 <tomh> byorgey: yeah exactly, I'm not familiar with how that stuff is implemented
11:59:07 <ezyang> If it was spine lazy, there'd be less, e.g. a tree might only produce log n thunks.
11:59:25 <ezyang> ddarius: I'm not sure if Okasaki actually treats this topic. At least, not in his book, though he might discuss it in a more recent paper.
11:59:30 <jmcarthur> ezyang: IMO, this is more of an argument for fusion than for lazy spines
11:59:42 <ezyang> Possibly.
11:59:46 <jmcarthur> although i guess not all access patterns work this way
12:00:04 <ezyang> IIRC, fusion is mostly done for lists and other linear structures, though?
12:00:06 <ddarius> ezyang: The point in his papers is that laziness/eagerness may need to be scheduled for best performance, particularly when you want real-time bounds.
12:00:16 <ezyang> Ah yes, the realtime transformation.
12:00:33 <jmcarthur> ezyang: tree-like structures, generally
12:00:43 <ezyang> Hmm, I've never seen fusion for a tree.
12:01:37 <ddarius> ezyang: Doing it lazily, may produce less thunks in the output, but may produce an output that depends on the entirety of the input structure until it's fully forced, whereas the eager version may be able to discard the input.
12:01:38 <jmcarthur> ezyang: anyway, for something like a map which is meant for the occasional random access, this might not be applicable anyway
12:02:10 <ddarius> ezyang: foldr/build fusion is straight-forward to generalize to any tree-like structure.
12:02:21 <ddarius> (similarly unfoldr/destroy)
12:02:24 <ezyang> ddarius: Since these are value lazy, only the structure of the map can be discarded, not the values.
12:02:29 <ezyang> Ah, OK.
12:02:32 <jmcarthur> it's not that hard to generalize stream fusion for it either
12:02:51 <ezyang> But it doesn't really work if you have random access, no?
12:03:02 <ddarius> ezyang: I know, but the structure may be a significant fraction of the memory usage.
12:03:38 <ezyang> Yes, that's true.
12:03:51 <jmcarthur> ezyang: it could still fuse a bunch of operations that occur without random access in between them
12:03:51 <ezyang> Though, in that case, why are you value lazy :^)
12:03:56 <erus`> @ty return
12:03:57 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:03:59 <ezyang> Ah, sure.
12:04:18 <ddarius> ezyang: Semantics may be one reason.
12:04:43 <ezyang> Is this the "strict map is not a functor anymore" argument?
12:05:08 <ddarius> ezyang: No, it's the "I can't tie a knot through an eager element" argument.
12:05:39 <erus`> @hoogle Monad m -> m
12:05:39 <lambdabot> Warning: Unknown type Monad
12:05:39 <lambdabot> Prelude id :: a -> a
12:05:39 <lambdabot> Data.Function id :: a -> a
12:05:49 <ezyang> Oh, that's a kind of odd thing to map over, but sure.
12:06:06 <erus`> @hoogle m a -> a
12:06:06 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
12:06:06 <lambdabot> Data.Monoid getDual :: Dual a -> a
12:06:06 <lambdabot> Foreign unsafePerformIO :: IO a -> a
12:06:18 <jmcarthur> erus`: don't do it!
12:06:35 <erus`> jmcarthur: its impure right?
12:06:45 <jmcarthur> it's entirely unsafe
12:06:57 <ezyang> What I kind of have visualized is that we have large maps with very small values (for which strictness is good), and medium-sized maps with very large outputs (for which the size of the structure is negligible)
12:07:00 <Saizan> depends on what m is.
12:07:00 <jmcarthur> and yes, impure
12:07:03 <ezyang> But of course there's all sorts of cases.
12:07:10 <jmcarthur> Saizan: i was talking about unsafePerformIO specifically
12:07:26 <ezyang> I need to understand how fusion works :-)
12:07:38 <ezyang> It's like nuclear fusion, always just around the corner...
12:08:09 <jmcarthur> ezyang: the easier to understand is the composition of a catamorphism with an anamorphism to form a hylomorphism
12:08:13 <jmcarthur> *easiest
12:08:31 <jmcarthur> ezyang: maybe read the bananas and lenses paper
12:08:45 <ezyang> Heh.
12:09:03 <jmcarthur> the stream fusion papers are pretty good too, but stream fusion seems to work a little differently from most other kinds of deforestation
12:09:05 <ezyang> I think I have an intuitive sense for the theory. What I'm not so sure is how often it shows up in practice.
12:09:32 <danharaj> ezyang: The repa library was built around fusion. Maybe that would be worth looking at for an in vivo example.
12:09:43 <ddarius> Read Erwig's (?) metamorphic programming.
12:09:46 <ezyang> IIRC, it's something of a black art. I remember SPJ saying in a talk "sometimes everything fuses, and life is good. Other times, the fusion breaks and we have to go out to lunch"
12:10:02 <jmcarthur> repa is a weird one due to force
12:10:06 <ddarius> ezyang: It's trivial to get it to happen explicitly.
12:10:25 <jmcarthur> ezyang: fusion is very simple. it's rewrite rules and inlining that are not trustworthy
12:10:32 <ezyang> Ah, sure.
12:10:47 <danharaj> jmcarthur: I think what repa chose was "Fusion by default, sharing explicitly"
12:11:11 <jmcarthur> danharaj: right. in my opinion, that only further complicates it. it's the main thing i don't like all that much about repa
12:11:13 <ezyang> Well, I wouldn't call it "trivial"; manually fusing your code has high cognitive cost.
12:11:28 <ddarius> ezyang: I didn't say manually.
12:11:33 <jmcarthur> manually is failure
12:11:43 <ddarius> ezyang: If you write foldr ... . build ... it will always fuse.
12:12:07 <ddarius> ezyang: The thing is people want to write code without thinking about fusion and have it Just Work.
12:12:28 <jmcarthur> isn't there hope that it's possible to convert recursion to stream fusion automatically sometimes?
12:13:03 <ezyang> ddarius: Oh, I didn't know that! "Foldr; not /that/ evil"
12:13:26 <ezyang> I guess the problem tends to be the producer is far away from the consumer.
12:13:37 <ezyang> Or it's not at all clear whether or not either is well-behaved.
12:13:40 <jmcarthur> my problem with foldr/build is that you have to compose them in a particular way for it to fuse
12:13:53 <jmcarthur> err
12:13:57 <jmcarthur> i guess that's not really a problem
12:14:13 <jmcarthur> but i tend to feel like i have to think about it a bit more, nonetheless
12:14:45 <ezyang> Haskell's promise of equational reasoning is very seductive. It's very easy to forget about such things as performance...
12:15:20 <ddarius> ezyang: All you need is a cost-semantics such as what Robert Harper is using/advocating.
12:15:25 <jmcarthur> the thing i like about stream fusion is that it's easy to envision how it works imperatively when writing stream fusable functions, and then you don't really have to think too much about it when using those functions except to arrange for sharing when necessary
12:16:10 <ddarius> ezyang: Anyway, equational reasoning also supports refinement from specification and program derivation.
12:16:30 <ddarius> It's also the key behind many of these fusion approaches.
12:16:30 <erus`> does anyone here know about game theory? I invented a little game here: http://tm1rbrt.github.com/ I think that red can win every game if played perfectly. how do i prove it?
12:16:59 <adimit> Suppose I wanted to have a humongous set of strings map to integers; by humongous I mean somewhere upwards of several gigabytes (i.e. it won't fit into memory.) And I want random access to that data. What's the best way to achieve this in Haskell? BerkeleyDB?
12:17:04 <ddarius> erus`: Just generate every outcome and see who wins.
12:17:10 <jmcarthur> erus`: it looks like a pretty simple game. maybe exhaustive search
12:17:35 <erus`> lets say i generate the whole game tree
12:17:45 <erus`> how do i prove that red can't lose?
12:17:57 <ezyang> ddarius: Now if only our compiler could do those calculations for us :-)
12:18:00 <ddarius> Simply check that red is the winner at the end of every path.
12:18:11 <ezyang> erus`: minimax search.
12:18:22 <ddarius> ezyang: The compiler does do those calculations.
12:18:28 <medfly> cale
12:18:32 <erus`> ddarius: blue will win some paths
12:18:47 <ddarius> erus`: Then red can lose apparently.
12:18:58 <erus`> but with perfect play it cant
12:19:02 <ezyang> ddarius: Not all of them, though :-)
12:19:07 <erus`> i think thats the case anyway
12:19:25 <ezyang> What would a cost model for Haskell look like? I still have a hard time imagining it.
12:19:43 <danharaj> You need to find a strategy for red that always works.
12:19:44 <ddarius> ezyang: There already is an inherent one.  Beta reduction.
12:19:52 <jmcarthur> ezyang: not pretty
12:20:06 <ezyang> >.>
12:20:40 <jmcarthur> erus`: if you try minimax then it's easy to see if you can always win with perfect play
12:20:59 <erus`> ok thanks
12:21:36 <ezyang> I also kind of want to know what kinds of programs interfere with optimizations. "Nonequational ones."
12:22:03 <ddarius> ezyang: That's a property of the optimizer.
12:23:24 <danharaj> erus': I think I have found a winning strategy, I will tell you when I have verified or disproved that.
12:23:28 <ezyang> See also "cost semantics". It would have to depend on the optimiser :-(
12:23:49 <ddarius> Cost semantics don't depend on the optimizer.
12:24:09 <ddarius> The optimizer transforms a program with one cost semantics into a program with another.
12:24:36 <ezyang> Huh. I guess I don't know what cost semantics are, then.
12:24:50 <ezyang> If the cost semantics change, I feel like they're not that useful...
12:25:02 <ddarius> If you want to know the costs of the result with respect to the input, then you'd need to either formalize the optimizations or model them in the cost semantics somehow.
12:25:26 <ddarius> ezyang: Cost semantics gives you a basis for even saying than an "optimization" optimizes.
12:25:55 <ddarius> Also, if all of your optimizations are actually optimizations, then the cost semantics of the input will be an upper bound on the cost semantics of the output.
12:26:01 <ddarius> Which is usually more than enough.
12:27:22 <danharaj> erus`: Consider this strategy. Red copies every move Blue makes until he can get closer to Blue's spawn that Blue is to Red's spawn. This will happen because at some point, Red and Blue will oppose each other in the middle of the board. When this happens, Blue must move to the left or right, letting Red cross the middle first, where Red is in a winning position.
12:27:37 <ezyang> Ah, ok.
12:28:54 <erus`> danharaj: also: red move onto win, else move down, else move down diag (never onto left or right edge), else move left or right(never onto edge)
12:29:14 <erus`> i think that wins every game
12:30:21 <erus`> I bet chess is like that just alot more complex :P
12:30:27 <erus`> black will allways win
12:30:37 <danharaj> erus': that strategy does not work. Blue moves left. Red moves down. Blue moves up-left. Red moves to the side. Blue moves up-diagonal. Red moves down. Blue moves up. Red moves down. Blue moves to spawn.
12:31:53 <danharaj> erus`: This game actually feels a lot like King and Pawn vs. King end games. There is a similar jockeying for position between the opposing kings in order to either stop the pawn from advancing or forcing the pawn to advance.
12:32:57 <erus`> "Blue moves left. Red moves down. Blue moves up-left. Red moves to the side." red will move down again?
12:33:27 <danharaj> er I meant blue moves up-right.
12:33:27 <danharaj> Sorry.
12:34:26 <erus`> aw man. it was so simple :( you ruined it
12:34:41 <danharaj> heh. Well the way that strategy fails shows how someone wins.
12:34:55 <danharaj> If you can get into that position, your opponent has to yield to you, so you get to the spawn first.
12:35:34 <danharaj> If you didn't have your rule about crossing your own tracks, it would be a draw I think.
12:35:40 <erus`> yeh if you move into middle +/- 1 and opponent is mirrored verticaly you will allway win
12:36:49 <balor_> given "data Op=B1 x y | B2 xy | U1 x" I can pattern match "f (B1 x y) = ... f (B2 x y) =..." but can you wildcard/don't-care the type constructor i.e. "f (_ x y) =..."?
12:37:23 <danharaj> balor_ : No. You cannot wild card the constructor.
12:37:51 <balor_> danharaj, thanks.  Is there a simple reason as to why?
12:38:00 <erus`> http://www.wired.co.uk/news/archive/2010-09/08/quantum-chess-adds-uncertainty quantum chess :D
12:38:18 <parcs> balor_: potential ambiguity
12:38:31 <parcs> data Op = B1 x y | B2 x y
12:39:22 <danharaj> balor_: It isn't clear to me that you could deduce that it is unambigious in all cases. Type inference might fail, I don't see why it is preserved.
12:39:31 <jmcarthur> anyway, to bring it up again, the reason i asked about quickcheck is because i'm scratching a few itches i have with it and i decided that the most convenient way to fix them is to start from scratch. just figured it would be nice to ask if there were any other itches i should scratch while i'm at it
12:40:00 <danharaj> jmcarthur: Just make sure you don't build half a backscratcher :)
12:40:11 <ezyang> ooh, can you add support for combinatorial species?
12:40:21 <jmcarthur> danharaj: it'll be a whole back scratcher
12:40:26 <jmcarthur> danharaj: built into a massage chair
12:40:45 <jmcarthur> ezyang: i have never used that stuff. is it practical?
12:40:51 <Dr_H> hey
12:40:59 <jmcarthur> ugh i hate it when people bring up practicality ;)
12:41:15 <danharaj> erus`: Quantum tic-tac-toe is better because it is not based on random chance. You get to choose how the superposition is observed.
12:41:27 <jmcarthur> ezyang: in fact, what would "support" for it mean?
12:41:33 <jmcarthur> i know too little about it
12:41:41 <ezyang> dunno! But random generation of recursive data structures would be useful.
12:41:45 <ezyang> *balanced
12:41:57 <jmcarthur> ah, i am attempting to tackle that already
12:42:03 <jmcarthur> but if there is already a research way to do it...
12:42:07 <jmcarthur> *researched
12:42:09 <ddarius> jmcarthur: Clearly it's impractical or you would have used it before.  Your anecdotal experience is incontrivertible proof.
12:42:18 <jmcarthur> ddarius: duh!
12:42:47 <danharaj> Does anyone know if/when haddock is going to get support for type families?
12:42:47 <ezyang> hehe
12:43:34 <jmcarthur> ezyang: so are you suggesting the species or the research around it can help me do this or that such functionality would be required in order to "support" species?
12:43:53 <jmcarthur> *suggesting that
12:44:09 <ezyang> As in, the research around it will help you generate balanced distributions of recursive data structures.
12:44:12 <ddarius> To generalize: anything you haven't used before is useless because if it were so useful you would have used it before.  Quod erat demonstrandum.
12:44:34 <Twey> \o/ I never need to learn anything again!
12:44:41 <ddarius> Twey: Exactly.
12:45:20 <jmcarthur> i already have a dsl for weakly defining tree-like structures that gives it some hints, but i didn't go through the effort (yet) to make it really precise
12:45:27 <erus`> danharaj: bit complicated for me...
12:45:53 <jmcarthur> ezyang: awesome! do you have any links or paper suggestions for me?
12:46:17 <ezyang> Hmm, you should ask byorgey about it.
12:46:45 <ezyang> BTW, stream fusion is /not/ enabled by default yet, right?
12:46:49 <jmcarthur> i had been meaning to give species a serious look anyway
12:46:55 <jmcarthur> ezyang: it's a library level optimization
12:47:11 <jmcarthur> ezyang: and base doesn't have it yet
12:47:31 <jmcarthur> ezyang: i think due to some missing functionality in the optimizer which prevents nested stream fusion from working well
12:47:42 <jmcarthur> like concatMap
12:48:34 <ezyang> Oh yeah, I remember reading that ticket.
12:48:42 <ezyang> but foldr/build fusion is already in base, right?
12:48:46 <jmcarthur> ezyang: vector, bytestring, and text are the main packages that use stream fusion that i know of
12:48:59 <jmcarthur> i actually haven't seen bytestring's fusion stuff. only hearsay
12:49:14 <jmcarthur> derivative packages of course also benefit from it
12:49:27 <ezyang> Hmm. I want to see "things you might do" that interfere with fusion.
12:50:05 <jmcarthur> ezyang: often there are times when you have to choose between fusion and sharing
12:50:24 <ezyang> right. And also strictness makes fusion sad.
12:50:40 <jmcarthur> ezyang: and sometimes one might accidentally make the wrong choice (or maybe the optimizer makes the wrong choice for you)
12:50:50 <jmcarthur> strictness doesn't make fusion sad afaik
12:50:56 <jmcarthur> how would it do that?
12:51:00 <ezyang> oh.
12:51:10 <ezyang> There's was a conversation about this a while back...
12:51:32 <jmcarthur> strict data structures actually benefit from fusion more than lazy ones
12:51:54 <jmcarthur> and ghc's optimizer likes strictness in combination with stream fusion quite a bit
12:52:05 <byorgey> jmcarthur: see Canou and Darasse, "Fast and sound random generation for automated testing and benchmarking in objective Caml"
12:52:12 <jmcarthur> byorgey: thanks!
12:52:22 <byorgey> 2009 ML workshop
12:52:43 <ddarius> jmcarthur: There's Data.List.Stream
12:53:03 <ddarius> ezyang: foldr/build has been in GHC forever.
12:53:19 <jmcarthur> ddarius: ah the stream-fusion package
12:53:22 <jmcarthur> is that used much?
12:53:33 <ezyang> Oh, I'm thinking of problems with other optimizations and strictness.
12:53:39 <ddarius> Probably not as there is little reason to use it.
12:53:52 <jmcarthur> that is what i thought
12:54:05 <djahandarie> You use it if you need stream fusion
12:54:54 <ddarius> The naive stream-fusion rule can change the definedness of a program.
12:55:03 <ddarius> Similarly for foldr/build too.
12:55:39 <ezyang> Hmm. Given a datatype, can you automatically generate fusion rules for it?
12:55:42 <jmcarthur> until the optimizer gets a little more punch i don't think stream fusion is a huge win over foldr/build yet either, right?
12:55:46 <djahandarie> ezyang, yes.
12:55:53 <ezyang> cooool.
12:55:54 <djahandarie> ezyang, as long as it's Mu-recursive
12:56:04 <djahandarie> This doesn't actually exist anywhere though
12:56:16 <ddarius> jmcarthur: It can be.  People just don't usually care enough about list processing code to bother depending on a different library.
12:56:44 <jmcarthur> ezyang: look at the fixpoint package for a *very* simple example of taking a mu-recursive type, defining folds and unfolds over it. then just pretend there is a rewrite rule in that package converting compositions of cata and ana into hylo
12:56:45 <ezyang> Also, do iteratees fuse?
12:56:50 <ddarius> djahandarie: You can write a polytypic foldr, and I'm sure it's been done in several places.
12:57:11 <jmcarthur> ezyang: what intermediate structures do iteratees generate?
12:57:12 <djahandarie> ddarius, sure, but I've never seen actual rewrite rules.
12:57:49 <ezyang> I don't know, but I do know they do stream processing.
12:57:52 <jmcarthur> djahandarie: here are some crappy ones :P https://patch-tag.com/r/jmcarthur/alt-stdlib/snapshot/current/content/pretty/Data/Fixpoint.hs
12:58:21 <ddarius> ezyang: Fusion is about getting rid of intermediate data structures, not stream processing.
12:58:32 <djahandarie> jmcarthur, :)
12:58:52 <jmcarthur> ddarius: useful for some kinds of stream processing though!
12:58:56 <ezyang> Right, but intermediate data structures show up a lot in stream processing.
12:59:06 <jmcarthur> ezyang: not with iteratee, afaik
12:59:13 <ezyang> Hmmmmm.
12:59:21 <djahandarie> jmcarthur, http://goo.gl/Bil1m is koninkje's
12:59:25 <ezyang> I mentioned to Oleg that partial evaluation + iteratees might be a killer feature.
13:00:02 <ezyang> But I think what I actually meant was fusion, not partial evaluation.
13:00:28 <Twey> Stream fusion is just a poor man's supercompilation ☺
13:00:43 <ezyang> It's true :-^)
13:00:53 <djahandarie> I don't think you need supercompilation for generalized stream fusion
13:01:01 <djahandarie> Though I'm not sure how you would generalize stream fusion
13:01:21 <Twey> I that supercompilation *is* generalised (automatic) stream fusion
13:01:28 <jmcarthur> generalize in what way?
13:01:32 <Saizan> don't you get intermediate iteratees if you compose them vertically?
13:01:43 <ezyang> Saizan: right, exactly.
13:01:47 <jmcarthur> ah
13:01:48 <djahandarie> jmcarthur, to Mu-recursive types.
13:01:49 <Twey> Generalised to arbitrary functions and data structures
13:01:57 <Twey> Er, yes, those.  ☺
13:01:58 <jmcarthur> djahandarie: that's easy i suspect
13:02:03 <djahandarie> jmcarthur, it's not.
13:02:09 <djahandarie> Skip gets in the way
13:02:15 <jmcarthur> djahandarie: take the underlying functor, add a Skip constructor, that's Step i think
13:02:51 <jmcarthur> djahandarie: at least, that has always been the case for the various data structures i've practiced stream fusing
13:03:01 <ezyang> I have a dream. A dream that every monolithic imperative stream processing program could be rewritten into a composable steps, whose denotation was clear and whose performance was preserved by fusion.
13:03:14 <ezyang> djahandarie: How does Skip get in the way?
13:03:22 <djahandarie> Right, if you can modify Step (Pre) and add Skip then it's easy, but what if you can't?
13:03:26 <balor_> When quickCheck fails, it provides a seed so that I can run the same set of tests again.  How do I give this seed to quickCheck?
13:03:33 <jmcarthur> djahandarie: just wrap it in Either
13:03:48 <ezyang> If it really is that hard, maybe iteratees are just a local optimum...
13:03:49 <ddarius> The key to the stream fusion is simply to turn a recursive function into a non-recursive one and expose the composition to GHC's optimizer.  Without GHC's optimizer the benefit would be minimal or worse.
13:04:21 <ezyang> ddarius: I like that statement. Nice and concise.
13:06:08 <ddarius> ezyang: Note that it is a statement about the stream fusion libraries that have been created for Haskell (particularly ones like Data.List.Stream), not about some general "stream fusion" approach.
13:06:33 <adimit> So, to access a postgres database from haskell, should I use Takusen, hdbc or haskelldb?
13:06:33 <tg_> ezyang: you said that you were giving a presentation on lenses, and you commented on that other guy's "new favorite example." Did he ever get back to you, and what analogies do you use to describe lenses?
13:06:39 <ezyang> right.
13:07:09 <ezyang> tg_: erm... I'm not giving a presentation on lenses. You mean Edward Kmett?
13:07:34 <tg_> ezyang: :| perhaps
13:07:43 <jmcarthur> byorgey: do you know of a freely available copy of "Fast and sound random generation for automated testing and benchmarking in objective Caml"?
13:07:47 <ezyang> Ooh, here is an example of some code I wrote recently that probably should get fused: 'invalidateUsersOf (CmmLocal r) . add . deleteSinks n $ assign'
13:08:16 <ezyang> with various operations on an IntMap that should all get done at the same time.
13:08:32 <ezyang> jmcarthur: I can beam a copy over.
13:08:52 <jmcarthur> ezyang: that would be great :) do you mind via email?
13:10:10 <ezyang> Oh, another itch: you should output the seeds for random generation so I can be reproduceable.
13:10:33 <ezyang> Also automatic promotion of random test cases into unit tests.
13:10:47 * ezyang suddenly is flooded with memories of using QuickCheck. 
13:11:21 <ezyang> Hmm, but data structure operations tend to be explicitly recursive. No fun! :-(
13:11:40 <ezyang> Making IntMap fused would be an interesting exercise...
13:11:58 <jmcarthur> ezyang: i'm planning to expose a pure subset of operations so you can do whatever you want with seed, test cases, etc.
13:12:34 <doaitse> hallo
13:12:35 <jmcarthur> i'm not sure how much benefit to a fusable IntMap there is. there aren't a ton of "big" operations on it, are there?
13:12:51 <tg_> jmcarthur: division algebras?
13:12:53 <jmcarthur> i guess fmap isn't entirely uncommon
13:12:55 <tg_> explicit ones?
13:13:04 <jmcarthur> hmm
13:13:09 <jmcarthur> yeah quite a few indeed i suppose
13:14:38 <jmcarthur> IntMap might be tough to fuse, but the wins might be big in some cases i guess
13:15:44 <djahandarie> What's a nice way to deal with really branchy input checking and verification in IO?
13:16:00 <ezyang> Anonymous functions?
13:16:28 <tg_> ezyang: do you have a preferred reference on stream fusion?
13:16:53 <ezyang> Nah, I don't know anything about it.
13:17:08 <ddarius> djahandarie: Model checking.
13:17:10 <jmcarthur> heh, this paper looks great. i've actually wanted something similar for genetic programming before, too
13:17:19 <tg_> jmcarthur: link?
13:17:25 <ezyang> tg_: Just a moment.
13:17:29 <jmcarthur> heh
13:18:03 <ezyang> Is it just me, or are proofs in things like model checking really, really mechanical.
13:18:06 <ddarius> djahandarie: I misinterpreted your words.
13:18:16 <ezyang> (unrelated, I suppose)
13:18:53 <ddarius> djahandarie: It depends on what you're going for.
13:20:01 <tg_> ezyang: -> pm
13:20:27 <ddarius> djahandarie: I think a general answer would be constraint programming.
13:21:43 <djahandarie> Constraint programming makes more sense to me. But AFAIK there is no easy way to do constraint programming in Haskell in a non-intrusive way
13:21:55 <roconnor> god, the Haskell Platform comes with Data.Binary instead of Data.Serial.
13:22:18 <roconnor> the HP is so mediocre
13:22:34 <ezyang> Sorry!
13:22:35 <tg_> jmcarthur: join #haskell-math, please
13:22:55 <djahandarie> All I'm really aiming to do is clean up this giant block of IO.
13:23:14 <ezyang> djahandarie: Can you pastie it?
13:23:46 <djahandarie> I don't think it's actually working right now, I was in the middle of refactoring it and being unsatisfied still :p
13:24:03 <ezyang> don't worry, we just want to look at it.
13:24:15 <roconnor> I
13:24:18 <djahandarie> I could probably reduce this down to something nice if I just refactor it a couple times, but it would be nice if there was a framework which just made me think in the right way from the start
13:24:25 <roconnor> *Data.Serialize
13:24:43 <balor> So I have this friend who sometimes writes recursive functions that don't bottom out.  Can he set a maximum heapsize for a ghc compiled application so that he doesn't eat all my^H^Hhis RAM?
13:24:58 <ezyang> Via +RTS, yes.
13:25:05 <ddarius> djahandarie: Write an input verification framework based on constraint handling.
13:26:02 <balor> ezyang, thanks, I can see GHCRTS='-M128m' from your information
13:32:26 <SoleSoul> Hi. I'm new to haskell. I'm trying to write a simple helper function which aplits a string into two strings. something like splitOnFirst 'l' "hello" -> ["he", "llo"]. I know how to get the "he" part but I failed to figure out how to combine the parts to a list of two strings without running over the string twice. Can someone give me a hint? thanks.
13:33:08 <ddarius> SoleSoul: I'm actually not sure how you are doing this incorrectly.
13:34:28 <Saizan> better use a tuple rather than a list if you're always going to return 2 elements btw
13:34:44 <Saizan> > ("he","llo")
13:34:44 <lambdabot>   ("he","llo")
13:34:48 <SoleSoul> why?
13:35:17 <Saizan> because it's a type that more precisely fits what your result is
13:35:41 <SoleSoul> ddarius, I've already deleted it. I'll try to write the idea again and post it here
13:35:43 <saati> there is a tool that checks if a given code is haskell-y, what is it's name?
13:36:00 <Saizan> you mean hlint?
13:36:14 <saati> i think so, thanks
13:36:15 <SoleSoul> the one used by hpaste?
13:36:38 <siracusa> Yes
13:36:43 <pozic> If you need a machine to tell whether something is good or not, you are doing it wrong.
13:37:05 <adimit> pozic: so I suppose you never make spelling mistakes. ever?
13:37:17 <Saizan> otoh, for a beginner it's quite useful, you can't use #haskell all the time :)
13:37:22 <pozic> adimit: in this context.
13:37:34 <saati> how should i know if it's good when it's my first hs program longer than 3 lines?
13:37:38 <adimit> pozic: hlint pretty much corrects haskell spelling mistakes that ghc doesn't catch
13:38:30 <pozic> adimit: isn't the point of hlint more to suggest trivial transformations on your code?
13:38:35 <adimit> redundant brackets/imports, use fmap instead, use ($), etc.…
13:38:49 <pozic> adimit: like map (f.g) == map f . map g, etc.
13:39:01 <adimit> yeah, trivial syntactic variants that don't change semantics. style errors, etc.
13:39:07 <pozic> It is a very opinionated tool.
13:39:20 <pozic> Modeled after what the author believes to be a good idea.
13:39:21 <adimit> such tools always are. doesn't make them useless.
13:39:36 * roconnor wonders if there is a non-empty list package on Hackage.
13:39:43 <ddarius> There is.
13:39:54 <adimit> sometimes one wants a second opinion. if a machine can provide that opinion, you don't have to bug -cafe or #haskell about it.
13:39:58 <ddarius> @hackage NonEmptyList ?
13:39:58 <lambdabot> http://hackage.haskell.org/package/NonEmptyList ?
13:40:11 <pozic> adimit: I think they have negative expected utility for me.
13:40:31 <ddarius> pozic is also a very opinionated tool.
13:40:44 <pozic> ddarius: I concur.
13:40:48 <roconnor> ah foo, it isn't the type I want
13:41:10 <ddarius> roconnor: I believe there are others.
13:41:15 <pozic> Anyone writing something interesting in Haskell?
13:41:30 <ddarius> Nope.  Only C++ is used for writing interesting software.
13:41:32 <pozic> Something that is not abandoned or already done a million times by others?
13:41:46 <roconnor> also, this other package isn't what I want
13:42:25 <roconnor> I guess I should write a third non-empty list package :D
13:42:26 <SoleSoul> ddarius, here is the wrong solution. I didn't test it. Just wrote it to show the idea. http://hpaste.org/46913/wrong_split
13:43:49 <pozic> SoleSoul: there is nothing wrong with that idea, and a good compiler should make it do whatever you want.
13:44:33 <SoleSoul> pozic: but wouldn't it iterate over the list twice?
13:44:43 <pozic> SoleSoul: using a stupid compiler, yes.
13:44:58 <monqy> I made a bit of a different version. Would you like to see it?
13:44:59 <pozic> SoleSoul: but in theory a compiler could optimize it to something sane.
13:45:05 <SoleSoul> pozic: is GHC stupid?
13:45:13 <ezyang> @ask Is GHC stupid?
13:45:13 <lambdabot> Consider it noted.
13:45:16 <pozic> SoleSoul: according to my standards, likely.
13:45:31 <ezyang> @help ask
13:45:31 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
13:45:34 <ezyang> oops.
13:45:49 <pozic> SoleSoul: anyway, just describe how you would do it efficiently in another language.
13:45:55 <Is> e
13:45:55 <lambdabot> Is: You have 1 new message. '/msg lambdabot @messages' to read it.
13:46:15 <pozic> ddarius: are you inflating the user count again?
13:46:44 <ddarius> Guest68570, haha!
13:47:29 <SoleSoul> pozic: I'll find the position of the first occurance of the char, then create a list of two strings one from s[0] to s[#c] and second from s[#c +1] to s[end] and return it
13:47:35 <shing`> Has forkIO been rewritten using epoll instead of select yet?
13:47:56 <pozic> SoleSoul: that is a flawed plan already.
13:48:17 <shing`> http://haskell.org/haskellwiki/Simple_Servers says "The epoll approach will replace GHC's select model soon..." but that page was last updated January 2010
13:48:20 <pozic> SoleSoul: if you find the position (index), then you have to traverse the list again.
13:48:24 <shing`> whats the current status of forkIO?
13:48:36 <ddarius> shing`: It's not forkIO that would be written, but rather the concurrency framework as a whole.  But yes, the newest versions of GHC use a different backend that uses epoll if available.
13:48:44 <ddarius> s/written/rewritten/
13:48:54 <pozic> SoleSoul: or you have to clarify what you mean by position (note, I know what a solution is, there is just no point in me writing it for you)
13:49:41 <Saizan> ?src span
13:49:41 <lambdabot> span _ xs@[]                     =  (xs, xs)
13:49:41 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
13:49:41 <lambdabot>                   | otherwise    =  ([],xs)
13:49:43 <pozic> SoleSoul: a list can be two things, either [] or an element x in front of some elements xs.
13:50:34 <pozic> > break (=='l') "hello"
13:50:35 <lambdabot>   ("he","llo")
13:50:51 <SoleSoul> pozic, I am a bit lost. not sure what you asked.
13:50:59 <SoleSoul> sry :)
13:51:33 <siracusa> > span (=='l') "Hello"
13:51:33 <lambdabot>   ("","Hello")
13:51:43 <siracusa> > span (/='l') "Hello"
13:51:44 <lambdabot>   ("He","llo")
13:52:09 <SoleSoul> pozic: in C++ for example it would be  an array and I would split it after knowing the index to split on. This is one iteration
13:52:09 <pozic> SoleSoul: you should start by reading a few basic books on programming Haskell.
13:53:09 <pozic> SoleSoul: there is no such thing as an index in a list in constant time, so it is pointless to think in those terms in this case.
13:53:38 <SoleSoul> pozic, yeah, it was just becaue you asked how I would have done it in another language
13:53:49 <pozic> SoleSoul: you have a list and you have to decide for every element of the list do I go in the first component of the answer tuple, or the second one.
13:54:00 <pozic> SoleSoul: deciding that is easy, right?
13:54:05 <SoleSoul> right
13:54:08 <pozic> SoleSoul: so, how do you decide that?
13:54:29 <pozic> Let's start with an empty input.
13:54:30 <SoleSoul> pozic: is it the delim or after it.
13:54:39 <pozic> f c [] = <what>?
13:55:00 <pozic> Some people might call it a trick question.
13:55:10 <SoleSoul> one second
13:55:18 <pozic> You made the specification for the function.
13:55:25 <pozic> So, you should know what it should do.
13:55:33 <SoleSoul> f c [] = [[],[]]
13:55:34 <pozic> f being you split function.
13:55:56 <pozic> SoleSoul: we were using tuples.
13:55:59 <SoleSoul> ah
13:56:04 <SoleSoul> didn't know that :)
13:56:09 <pozic> SoleSoul: now, you do.
13:56:16 <roconnor> where is that page that will give me the depenendency closure of hackage packages?
13:56:19 <SoleSoul> f c [] = ([],[])
13:56:30 <pozic> SoleSoul: right
13:56:36 <pozic> Now, we have
13:57:09 <pozic> f my_character (our_current_character: the_rest_of_the_characters) = ?
13:57:24 <pozic> Or f c (x:xs) = ?
13:57:38 <pozic> The former is clearer educationally.
13:57:59 <SoleSoul> *thinking*
13:58:14 <Twey> How?
13:58:24 <Twey> It fails to introduce the student to Haskell naming conventions
13:58:37 <Twey> (in fact, it uses non-Haskell conventions)
13:58:55 <companion_cube> it should be in caml-case, isn't it ?
13:58:55 <pozic> Twey: uhm, my second version used Haskell conventions.
13:58:59 <Twey> And the inconsistent spacing on the : constructor makes it look special
13:59:07 <Twey> ?
13:59:11 <Twey> 220910 < pozic> f my_character (our_current_character: the_rest_of_the_characters) = ?
13:59:13 <pozic> Twey: omg, the spacing.. really?
13:59:16 <Twey> — not Haskell conventions
13:59:32 <Twey> Haskell uses camelCase
13:59:35 <pozic> Twey: go find another person. Go away.
13:59:44 <SoleSoul> pozic: can I use guards?
13:59:52 <SoleSoul> pozic: do I have to?
13:59:53 <pozic> SoleSoul: you can do whatever you want.
14:00:06 <pozic> SoleSoul: if I tell you what to use you stop thinking.
14:00:14 <SoleSoul> pozic: ok
14:00:49 <Twey> That's very unfriendly of you.  I'm aware it's a fairly trivial thing to talk about in most contexts, but you were discussing the relative suitability for education, and considering just such trivialities (naming conventions).
14:01:04 <pozic> camelCase is _not_ universal.
14:01:15 <pozic> You may believe it is, but it is not.
14:01:38 <pozic> I incidentally hate when people discuss how symbols look like, btw.
14:01:47 <pozic> So, go find someone else to talk to.
14:01:59 <phiv5> I apologize for interrupting but is anyone else having trouble installing the Haskell-package in the new Ubuntu 11.04?
14:02:14 <pozic> phiv5: you should be in #ubuntu for that.
14:02:19 <phiv5> ok
14:02:33 <DevHC> rapidly_readable_identifiers ftw
14:02:47 <djahandarie> phiv5, there is apparently an issue with the Haskell Platform package in Ubuntu, if I remember correctly.
14:02:53 <Twey> DevHC: Shh, we're not allowed to discuss this.
14:02:56 <pozic> phiv5: unless Ubuntu did not package it, in which case you should talk to whoever distributed the thing to you.
14:03:19 <phiv5> It's in Ubuntu's package, installing it has errors
14:03:27 <pozic> phiv5: so, talk to Ubuntu people.
14:03:33 <DevHC> Twey: ORLY
14:03:34 <pozic> SoleSoul: what are you doing?
14:03:53 <SoleSoul> pozic: trying to figure it out
14:04:03 <SoleSoul> :)
14:04:35 <saati> if i have a type like data Vec3 a = V3 a a a, how can i restrict a to members of Num?
14:04:41 <tensorpudding> ubuntu's haskell platform package was borked and for some reason they didn't catch that it was uninstallable before it was frozen
14:05:17 <ddarius> saati: Don't worry about it.
14:05:50 <kwos> hello!
14:06:01 <saati> i want to make it an instance of Num, i still don't have to worry about it?
14:06:50 <ddarius> saati: Correct.  To write the instance you'll need to restrict a to Num which you will do in the instance declaration.  That doesn't require every use of the constructor to restricted to Num.
14:06:55 <Twey> tensorpudding: Erk.
14:07:00 <roconnor> saati: generally you don't.  You just put a Num constraint on every function that uses Vec3
14:07:16 <saati> i see, thank you
14:07:24 <ddarius> roconnor: Just have Num constraints where they are needed.  You don't have to add them.
14:07:27 <Twey> tensorpudding: Don't they have any way to fix that sort of thing?
14:07:30 <pozic> tensorpudding: they didn't catch it because they have no QA.
14:07:35 <roconnor> ya, what ddarius said
14:07:46 <pozic> Apparently, nobody cares enough about Haskell on Ubunty.
14:07:49 <pozic> Ubuntu*
14:07:52 <roconnor> sometimes you won't even put a Num contraint on.  It won't hurt
14:08:04 <tensorpudding> pozic: launchpad bugtracker would fill in that role
14:08:46 <tensorpudding> Twey: i assumed so, since they fix bugs; the reason the package is uninstallable is due to one line in the debian/control file afaict
14:08:52 <ddarius> saati: For example, your Vec3 type is a Functor, but it wouldn't be if you restricted the constructor to Num types (or more precisely, you wouldn't be able to implement fmap with the correct type.)
14:09:08 <pozic> tensorpudding: what role?
14:09:25 <tensorpudding> a place for feedback on pre-release
14:09:31 <pozic> tensorpudding: bug trackers are places to collect bugs, not places to fix bugs.
14:09:39 <tensorpudding> well, specifically, to notify maintainers of bugs
14:09:52 <pozic> Which then tactically disregard them.
14:10:20 <tensorpudding> you assume negligence, it could just be an honest mistake
14:11:13 <SoleSoul> pozic: I'm not sure yet but I wrote something
14:11:14 <SoleSoul> splitOnFirst delim s@(x:xs) | x == delim = ([], s)
14:11:24 <pozic> tensorpudding: I think on average they are just too stupid.
14:11:26 <SoleSoul> | otherwise  = (x:fst splitOnFirst xs, snd splitOnFirst xs)
14:11:50 <tensorpudding> actually, hmm
14:11:58 <DevHC> does constructor renaming exist already?
14:12:04 <pozic> tensorpudding: there are bug counts in the 100000s.
14:12:17 <tensorpudding> it's probably one of the packages imported automatically from debian
14:13:30 <Saizan> SoleSoul: "fst splitOnFirst xs" is passing both splitOnFirst and xs as arguments to fst, while you want to pass (splitOnFirst xs) as a single argument to fst
14:13:35 <pozic> SoleSoul: syntactically that is not correct.
14:14:01 <Saizan> SoleSoul: also, the two | have to align vertically
14:14:08 <pozic> SoleSoul:  f g x = (f g) x
14:14:09 <SoleSoul>  otherwise  = (x:fst splitOnFirst delim xs, snd splitOnFirst delim xs)
14:14:23 <tensorpudding> it seems the last time the package was updated was quite a while ago
14:14:31 <SoleSoul> I forgot the delim
14:14:32 <pozic> SoleSoul: applying fst to splitOnFirst is not going to work.
14:14:58 <SoleSoul> otherwise  = (x:fst $ splitOnFirst delim xs, snd $ splitOnFirst delim xs)
14:15:04 <tensorpudding> the branch for oneiric was fixed in april
14:15:19 <SoleSoul> pozic, the idea.. is it in the right direction at all?
14:15:45 <tensorpudding> odd
14:15:53 <pozic> SoleSoul: it is overly complicated in that it doesn't use libraries, but otherwise, yes
14:16:44 <tensorpudding> the fix has been milestoned "natty-updates"
14:17:00 <tensorpudding> which i guess means it will be fixed sometime during the lifespan of the release
14:17:24 <SoleSoul> pozic: good to hear :). It is a bit hard for me to follow the execution of the thing I wrote. What library you would have used in that case?
14:17:39 <pozic> SoleSoul: Prelude.break
14:17:58 <pozic> > break (=='l') "hello"
14:17:59 <lambdabot>   ("he","llo")
14:18:12 <pozic> SoleSoul: doesn't that do what you wanted?
14:18:39 <SoleSoul> lol
14:18:54 <SoleSoul> pozic: I like the way you teach
14:19:08 <pozic> SoleSoul: people pay me to do that.
14:20:18 <pozic> SoleSoul: you are the first one who doesn't want to ban me here ;)
14:20:36 <SoleSoul> it's like this book for c++: http://www.relisoft.com/book/web_preface.html. you build parts of the standard library before you are presented with the already implemented classes.
14:21:03 <pozic> SoleSoul: there is no point in using libraries if you don't know exactly what they do.
14:21:17 <pozic> SoleSoul: otherwise they only suck up time.
14:21:29 <pozic> Especially for third party libraries written by amateurs.
14:21:50 <SoleSoul> pozic: funny thing is, my brain is having hard time looking on what I wrote...
14:22:13 <pozic> SoleSoul: that is because your level of abstraction is too low.
14:22:40 * ddarius finds pozic self-contradictory.
14:22:41 <SoleSoul> pozic: abstraction of the code or the skill to understand abstraction?
14:23:17 <roconnor> @seen edwardk
14:23:18 <lambdabot> Unknown command, try @list
14:23:18 <preflex>  edwardk was last seen on #haskell 3 days, 1 hour, 52 minutes and 50 seconds ago, saying: byorgey: byorgey: byorgey!
14:23:28 <pozic> SoleSoul: well, let me take that back. I don't know that.
14:24:09 <pozic> SoleSoul: a correct way of thinking is "grab a bunch of characters having property X, do something with the rest".
14:24:16 <DevHC> poll: SDL sux?
14:24:36 <DevHC> pozic: vote!
14:25:04 <pozic> SoleSoul: then if you have read the Prelude (which you should before writing a single line code), you would immediately notice these things.
14:25:31 <pozic> DevHC: the Haskell binding?
14:26:02 <pozic> SoleSoul: you can also just ignore all the libraries and write them all from scratch yourself.
14:26:16 <pozic> SoleSoul: then there is no need to ask whether something already exists.
14:26:38 <pozic> SoleSoul: if your code is really good, people will make the trivial replacements anyway.
14:27:38 <DevHC> pozic: no, the library
14:28:09 <SoleSoul> pozic: after using C++ and assembly for most of my self learning programming I wanted to try being more productive. I want to know the libraries. In the beginning I thought that if you didn't right something, it worth less. Now I see you can't ne productive with this kind of thinking
14:28:12 <pozic> DevHC: I never read the code in detail, so other than that it appears to work, I have no good opinion on it.
14:28:36 <pozic> DevHC: the few header files I have seen looked pretty solid.
14:29:26 <pozic> SoleSoul: if you want to be more productive, use tools that work and read books that work.
14:29:42 <pozic> SoleSoul: programming is just discrete mathematics for 95%.
14:29:46 <DevHC> pozic: when have u tested it? like a year ago?
14:30:15 <pozic> DevHC: why do you ask?
14:31:28 <pozic> SoleSoul: I wouldn't say the Haskell tools work, btw. I think they are of low quality in general. GHC is fairly good (but horribly slow).
14:31:58 <byorgey> jmcarthur: hmm, I don't.  I thought I had a copy but I can't find it at the minute.  If I find it I will send it to you.
14:32:12 <SoleSoul> pozic: recommend a language and a book then please?
14:32:27 <pozic> SoleSoul: I think learning Scheme before Haskell is a good idea.
14:32:28 <SoleSoul> pozic: and a linux distro :)
14:32:38 <DevHC> pozic: because there was WAR when ioq3 switched from "native code" to SDL for windowing and input, to offload the "dependency" to a different project... because SDL's input quality sux contaminated goat balls.
14:32:53 <geheimdienst> SoleSoul: "learn you a haskell" is a good book for starting
14:32:56 <geheimdienst> @where lyah
14:32:57 <lambdabot> http://www.learnyouahaskell.com/
14:32:59 <DevHC> on windows, taht is.
14:33:03 <geheimdienst> it's available online for free
14:33:16 <SoleSoul> geheimdienst: Yeah, thanks. I'm using it all the time
14:33:19 <pozic> DevHC: on Windows everything open-source sucks.
14:33:21 <DevHC> now it's mostly fixed, though i still can feel that the non-SDL version of ioq3 was a lot smoother
14:33:32 <pozic> DevHC: because everything that is done is made by companies in a hurry.
14:33:36 <geheimdienst> after that, you might want to check out "real world haskell"
14:33:38 <geheimdienst> @rwh
14:33:38 <lambdabot> Maybe you meant: rc run wn
14:33:42 <geheimdienst> @where rwh
14:33:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:33:49 <geheimdienst> (also available online)
14:34:07 <jmcarthur> byorgey: ezyang already sent me a copy, but thanks anyway
14:34:10 <DevHC> pozic: the "native" code for input on windows was fucking invincible
14:34:27 <SoleSoul> pozic: you say that because you think Scheme's tools are good and the language is good for day to day use or you say that for educational purposes?
14:34:27 <DevHC> made my a BIG company in a not such hurry
14:34:32 <pozic> SoleSoul: The Haskell School of Expression is fairly good, but showing its age.
14:34:53 <pozic> SoleSoul: Real World Haskell and a newbie like you are no match.
14:35:04 <pozic> Building a space ship when you cannot walk is a bad idea.
14:35:11 <pozic> Programming in Haskell is fairly nice.
14:35:24 <byorgey> jmcarthur: oh, ok, great
14:35:38 <SoleSoul> pozic: lyah seems good to me
14:35:57 <pozic> SoleSoul: I wouldn't know in detail. You could try it.
14:36:14 <pozic> SoleSoul: the author has no academic background, AFAIK.
14:36:18 <SoleSoul> pozic: learning Haskell takes very much time. Don't know if for everyone or just me
14:36:35 <pozic> SoleSoul: learning Haskell98 is fairly easy.
14:36:35 <DevHC> pozic: some input, windowing stuff, performance, etc. still sux a bit more with SDL compared to the old, native code, on both platforms windows and unix-like platforms
14:36:39 <applicative> SoleSoul, also see http://blog.johantibell.com/2010/09/slides-from-my-high-performance-haskell.html Which is fairly elementary, but might be well to know earlier rather than later
14:36:47 <pozic> SoleSoul: learning the rest takes quite some time.
14:37:12 <DevHC> btw pozic: if u have seizures from childish pictures, do NOT read lyah
14:37:31 <pozic> DevHC: yes, I know about that.
14:38:05 <pozic> Doing Trivial Thing X ..... in Haskell...
14:38:16 <pozic> No, books about Haskell are not for me anymore.
14:38:22 <applicative> pozic are you attacking lyah?
14:38:24 <djahandarie> Cale, http://flickrhivemind.net/Tags/icosahedron/Interesting
14:38:40 <pozic> applicative: if I were, he would already be dead.
14:38:55 <pozic> applicative: what kind of a question is that?
14:39:06 <pozic> applicative: ask your stupid questions to someone else.
14:39:30 <kwos> I'm looking at this https://github.com/basvandijk/levmar/blob/master/Numeric/LevMar.hs code and I like the way he's using unicode characters for function arrows, etc. What's the best way of typing this on a mac?
14:39:39 <geheimdienst> pozic, would you please stick to a polite tone
14:40:28 <applicative> kwos, wouldn't this depend on your editor?
14:41:01 <pozic> geheimdienst: Saizan might have some authority, but you don't.
14:41:05 <DevHC> does anyone know if "pozic" means something like "fart" in polish?
14:41:35 <pozic> geheimdienst: I can leave if you want, though. There is nothing here for me today, anyway.
14:42:03 <DevHC> pozic, btw, what was ur point again?
14:42:10 --- mode: ChanServ set +o shapr
14:42:17 <DevHC> shapr: NO U
14:42:17 <shapr> DevHC: Dude, be nice.
14:42:29 <shapr> DevHC: seriously, be nice. Or Else.
14:42:45 <DevHC> what did i DO to troll u?
14:43:04 <SoleSoul> fist time I see fights here
14:43:05 <shapr> DevHC: You made an ad hominem attack.
14:43:14 <DevHC> orly
14:43:18 <pozic> DevHC: bad spelling is a deadly sin.
14:43:32 <DevHC> there is nothing BAD(TM) in my spelling
14:43:48 <pozic> Trust me, there is.
14:43:51 <shapr> DevHC: You are not allowed to ask if someone's name means a bodily function in some other language, that sort of comment has no positive effect.
14:44:04 <pozic> shapr: I don't care.
14:44:09 <shapr> pozic: I do.
14:44:21 <pozic> shapr: ok, well, then I can respect that.
14:44:36 <DevHC> my grammar is 99.9999% correct, with respect to the upcoming new english standard
14:44:42 <applicative> kwos, if you are using something like textmate, you can do e.g. a suitable tab completion, or else alter the obcure keys like the ones with alt,  ?
14:44:59 <ozzloy> i must have come in at a bad time
14:45:00 <shapr> I very much prefer to see people being respectful on #haskell. Disagreements can still be respectful.
14:45:05 <SoleSoul> pozic: What OS do you use for good haskell support? last time I asked someone said sourcemage GNU/Linux and I lost about two days trying to install it :)
14:45:06 <shapr> o hai ozzloy! How's code?
14:45:12 <erus`> textmate isnt open source
14:45:33 <DevHC> ...
14:45:35 <applicative> erus` no, top secret alas.
14:45:36 <DevHC> so anyways
14:45:36 <overscore> solarus, i use slackware
14:45:38 <ozzloy> shapr, um.. good?  just reading through a haskell tutorial.  total haskell newb
14:45:49 <erus`> SoleSoul: its in the debain files isnt it?
14:45:52 <shapr> ozzloy: Cool, got any questions?
14:45:52 <DevHC> pozic, why did u come in here today?
14:45:58 <roconnor> selections :: [a] -> [([a],a,[a])]
14:46:04 <roconnor> selections (x:xs) = ([],x,xs):(map (\(l,m,r) -> (x:l,m,r)) (selections xs)
14:46:05 <DevHC> to make a point, right? what was it?
14:46:10 <shapr> DevHC: calm down dude.
14:46:11 <roconnor> anyone write this function before?
14:46:15 <shapr> DevHC: It's all cool.
14:46:23 * shapr breaks out the ice cream to make sure it's all cool.
14:46:39 <erus`> dont feed the troll ice cream :/
14:46:40 <SoleSoul> erus`: It works on many linuces but on some it's better and more up to date
14:46:47 <hpc> @quote troll.*explode
14:46:47 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
14:46:52 <pozic> SoleSoul: Debian or Ubuntu, but when something is not packaged, just compile it yourself.
14:46:58 <shapr> erus`: o hai! How's code for you?
14:47:04 <ddarius> roconnor: Cale often writes a variant for permutations.
14:47:06 <DevHC> shapr: ice cream is tasty, but i can't be any more cool than this
14:47:19 <shapr> DevHC: That sucks, being cool makes life easier to handle.
14:47:32 <roconnor> I wonder if it is in data.split
14:47:35 <erus`> shapr: im on win7 at the moment but on ubuntu it worked nicely
14:47:38 <shapr> DevHC: How's code for you? Written any Haskell lately?
14:47:41 <DevHC> with an appropriate definition of cool
14:47:43 <ddarius> @hoogle selections
14:47:44 <lambdabot> No results found
14:47:49 <shapr> erus`: Oh nice... I'm on ubuntu and I do like writing Haskell code.
14:47:50 <erus`> win7 isnt so good for packages not in the prelude
14:47:52 <DevHC> i have a feeling that u're misreading my coolness
14:47:56 <shapr> erus`: Oh, haven't tried it.
14:47:56 <roconnor> ddarius: I want a better name
14:47:56 <geheimdienst> SoleSoul: i use cabal for installing everything. i don't bother with the haskell packages that my linux distribution provides (arch linux). cabal is available for i guess every kind of linux
14:48:06 <DevHC> shapr: no, not much haskell code lately
14:48:11 <roconnor> @hoogle [a] -> [([a],a,[a])]
14:48:12 <lambdabot> No results found
14:48:14 <roconnor> :/
14:48:17 <geheimdienst> SoleSoul: ... so pick any linux you're comfortable with, would be my advice
14:48:27 <SoleSoul> pozic: I use Arch which has very good support for Haskell so I'd stick with that. I thought there might be an "official" Haskell distro
14:48:49 <SoleSoul> geheimdienst: :) fellow archer. Yi doesn't install with cabal right now
14:48:50 <pozic> SoleSoul: Arch is OK.
14:49:11 <roconnor> @hoogle [a] -> [([a],[a])]
14:49:12 <lambdabot> Network.CGI formDecode :: String -> [(String, String)]
14:49:12 <lambdabot> Network.CGI.Protocol formDecode :: String -> [(String, String)]
14:49:12 <lambdabot> Network.CGI.Cookie readCookies :: String -> [(String, String)]
14:49:15 <pozic> SoleSoul: I don't even know whether it is better than Debian/Ubuntu at the moment.
14:49:17 <shapr> DevHC: aw, that's too bad... I'm in the same boat. I've been writing some Arduino code, but I'm using the Arduino IDE. I'm not awesome enough to use http://hackage.haskell.org/package/atom to generate Arduino code.
14:49:32 <pozic> SoleSoul: the nice thing about Ubuntu is that millions happen to use it and they already had the problems.
14:49:57 <SoleSoul> pozic: yeah, but they don't have a solution
14:49:59 <SoleSoul> :)
14:50:00 <pozic> SoleSoul: when I have an issue, the solution is on the Ubuntu forum (via Google), not on the Arch forum.
14:50:11 <shapr> SoleSoul: I'm using Haskell on Ubuntu 10.10, do you have any questions about that?
14:50:12 <SoleSoul> jk
14:50:26 <pozic> I think the average skills of Arch users is probably higher.
14:50:27 <kwos> applicative: thanks
14:50:28 <overscore> so, why would the solution not work on arch?
14:50:30 <erus`> the only thing wrong with linux is graphics and wifi drivers
14:50:32 <DevHC> shapr: :o
14:50:58 <SoleSoul> yi won't install on arch right now because of a stripping bug in GHC
14:51:07 <ozzloy> shapr, i was about to ask something, but i just got called to go pick up a friend with a blown up car
14:51:11 <SoleSoul> I may even find the bug report
14:51:16 <shapr> ozzloy: aw too bad... come back soon!
14:51:24 <ozzloy> shapr, thanks anyways!  will do
14:51:30 <pozic> SoleSoul: which OS you use doesn't really matter, btw.
14:51:35 <ddarius> Those damn insurgents.
14:51:52 <pozic> SoleSoul: you could even get everything to work on Windows, if you are a skilled developer.
14:51:53 <overscore> the OS does matter... try cabal install sdl on windows :D
14:51:54 <SoleSoul> pozic: version of packaged GHC is important
14:51:59 <shapr> ddarius: I have an insurgent protector on my computer.
14:52:12 <erus`> overscore: are you serious?
14:52:19 <DevHC> ok so now that shapr finished playing a game of acting like a psychiatrist, let's continue trolling
14:52:22 <pozic> overscore: gtk on Windows works, I don't see why sdl would not.
14:52:26 <ddarius> shapr: That doesn't keep them from blowing up your car.
14:52:33 <pozic> DevHC: you suck at trolling.
14:52:39 <DevHC> ORLY
14:52:41 <shapr> DevHC: I have the ban hammer handy.... trolls get removed from #haskell
14:52:42 <overscore> gtk does work yeah
14:52:47 <shapr> pozic: like I said...
14:53:02 <erus`> free speech!
14:53:10 <pozic> Remember, remember.
14:53:18 <DevHC> #democracy is terror for #haskell
14:53:29 <SoleSoul> If we are at it, is it possible to create a portable version of a Haskell application? I mean, no haskell dependencies even though it is written in Haskell.
14:53:42 <shapr> DevHC: Lucky for me, #haskell is not a democracy.
14:53:42 <pozic> SoleSoul: that is called statically linked.
14:53:45 <DevHC> so... is constructor renaming in haskell yet? has it been proposed in a ticket yet?
14:54:08 <erus`> DevHC: start a #haskell-democratic
14:54:15 <DevHC> shapr: if i had a big, heavy, and hard banhammar, i'd...
14:54:15 <erus`> il come once a few people join
14:54:26 <shapr> DevHC: have a really polite irc channel? :-)
14:54:33 <DevHC> erus`: u're in a deadlock
14:54:59 <shapr> So anyway, I tried to follow the Yesod tutorial recently but had problems...
14:55:00 <DevHC> shapr: no, my IRC channels have democracy
14:55:12 <pozic> #haskell-advanced would be more interesting, except it would contain at most 10 people worldwide.
14:55:21 <DevHC> or let's just say free speech
14:55:29 <hpc> pozic: -indepth is populated
14:55:32 <pozic> Cue in 3,2,1.
14:55:40 <pozic> hpc: I knew someone would say that.
14:55:48 <hpc> and i am not even in that channel anymore...
14:55:48 <shapr> pozic: are you trolling?
14:55:50 * hpc fixes that
14:55:56 <pozic> hpc: obviously, I am aware of that.
14:56:05 <pozic> shapr: why would I?
14:56:10 <DevHC> shapr: shhhh, don't tell that it's about time u notice
14:56:22 <erus`> join my channel #wtf-is-a-monad
14:56:22 <shapr> pozic: I don't know, but I encourage people to be nice.
14:56:52 <shapr> I have the ten years of encouragement badge even.
14:56:53 <pozic> shapr: let's discuss that instead,
14:57:01 <pozic> shapr: why do you do that?
14:57:13 <shapr> pozic: Feel free to discuss that on #haskell-blah
14:57:33 <DevHC> so why u do that is not related to haskell?
14:57:50 * shapr hugs DevHC 
14:57:55 <erus`> keep all talk of the different haskell rooms to #haskell-rooms please
14:58:14 <shapr> hah
14:59:10 <DevHC> https://tremulous.oternet.com/pub/info-rules.txt <-- ruleset for playing on Amsterdam Unlimited, a Tremulous game server i run. may special attention to the TROLLING sections!
14:59:44 <ben> Way to give an https link when you don't have a real cert
15:00:07 <DevHC> https with self-signed cert > http
15:00:22 <erus`> haha
15:00:22 <roconnor> clear txi = txi{field1 = (field1 txi){field2 = []}} -- I really need to use lenses.
15:00:39 <ben> Not gonna trust your shitty cert just so I can read your trolling
15:00:42 <byorgey> roconnor: clearly =)
15:00:58 <roconnor> a lens langauge flag can't come too soon
15:00:58 <byorgey> ben, DevHC: please stop.
15:01:20 <DevHC> ben: use a GOOD(TM) browser which allows downloading content without permanently trusting a certificate.
15:02:06 <ddarius> I personally would not be against shapr banning both DevHC and pozic.
15:02:25 <shapr> DevHC, ben: feel free to continue this discussion on #haskell-blah
15:02:48 <DevHC> thx for teh invitation but no thx
15:02:59 <DevHC> lol
15:03:00 <shapr> k
15:09:01 <DevHC> cat /dev/random | ghc -e 'getContents >>= putStr'
15:09:10 <DevHC> <interactive>: <stdin>: hGetContents: invalid argument (Illegal byte sequence)
15:09:15 <DevHC> that is so annoying.
15:11:24 <mnslaww> hi, i'm having trouble understanding enumerators/iteratees
15:11:27 <shapr> So, anybody got a simple working Yesod demo?
15:11:35 <mnslaww> can anyone point to a not-so-dense explanation?
15:11:47 <mnslaww> i want to understand them to a point that I can write some basic stuff on top of warp
15:16:01 <parcs> mnslaww: the yesod book has a good tutorial on them
15:18:26 <DevHC> i'm about to open up a new ticket for "constructor synonyms". any wishes?
15:18:33 <DevHC> u have N seconds to reply
15:19:45 <mnslaww> parcs- are you familiar with the book?
15:20:48 <parcs> somewhat
15:21:12 <mnslaww> i get lost here "Yield b (Stream a)"
15:21:17 <mnslaww> i don't understand what that's supposed to be
15:21:44 <mnslaww> or what "the already calculated constructor" means
15:24:12 <mnslaww> here's a link just in case http://www.yesodweb.com/book/enumerator
15:24:45 <parcs> i'm not sure what "the already calculated constructor" means either
15:24:53 <parcs> but have you read the next two paragraphs?
15:25:05 <parcs> they explain the meaning of the type
15:25:22 <parcs> err, the next paragraph
15:25:55 <tomh> what are the semantics of findMin for a Set?
15:26:17 <mnslaww> parcs- yes, but i still don't get it intuitively
15:26:42 <mnslaww> parcs- something that might help a lot: could you clarify what the "a" "m" and "b" parameters are?
15:27:20 <Phyx-> hpc: http://pastebin.com/MXn25vRT is the code
15:27:21 <Cale> tomh: findMin s is the least element of s
15:27:40 <tomh> the least?
15:27:45 <Cale> yes
15:27:48 <DevHC> http://hackage.haskell.org/trac/hackage/ticket/846
15:27:50 <ddarius> :t Data.Set.insert
15:27:51 <lambdabot> forall a. (Ord a) => a -> S.Set a -> S.Set a
15:27:58 <Phyx-> hpc: FFIType is a class that allows me to convert back and forth between normal types and what can be exported from FFI
15:28:04 <parcs> mnslaww: a is the type of input, m is the monad that it's located in (which is primarily used to define a useful monad instance) and b is the output type
15:28:07 <hpc> heh, i don't know enough ffi to help with actual code :P
15:28:17 <SoleSoul> I need an advice again please. I have to drop chars from a String until an occurance two chars '*' and '/'. It is supposed to find the end of a multiline comment. I know how to dropWhile for one char, but how do I do it with two? Do I have to write it or is there something in the library for that?
15:28:18 <hpc> i just vaguely know the concept
15:28:35 <tomh> cale: if I look at the sourcecode, I don't really see how thats the least, does it get sorted on insertion or?
15:28:43 <mnslaww> could you elaborate on why the monad is a parameter?
15:28:52 <ddarius> SoleSoul: Describe an algorithm for doing it in English.
15:29:08 <mnslaww> i'm mostly confused by their use of m
15:29:18 <Phyx-> hpc: hehehe, It's confusing me because testing the function in ghci works, e.g. "(malloc :: IO (Ptr CInt)) >>= (\x-> let! res = g 0 1 (toFFI [8::Int]) x in peek x >>= \x' -> return (fromList (fromFFI x') res :: [Int]))" produces the correct result
15:29:31 <Phyx-> but calling the function from C gives me a segfault
15:29:32 <Phyx-> :/
15:29:44 <Phyx-> *puts on some coffee*
15:29:49 <Cale> tomh: Every node of the binary tree is already labelled with the least and greatest element occurring in that subtree.
15:29:51 <tomh> ahhh yeah it gets sorted on insertion
15:29:51 <hpc> perhaps the C is segfaulting?
15:30:02 <Cale> of course
15:30:06 <Cale> it's a binary search tree
15:30:15 <SoleSoul> ddarius: foreach char, if it is a '*', check if the next is '/'. if true, drop until after the '/'. else continue checking from the '*' to the end of the string.
15:30:16 <tomh> ok
15:30:30 <tomh> hmm then I need some control on how it is ordered
15:30:37 <tomh> I guess a custom data type
15:30:40 <mnslaww> parcs- i forgot to respond directly. i'm confused as to how/why the monad is used as a parameter
15:30:42 <tomh> with its own Ord instance
15:30:46 <hpc> Phyx-: if you wrote haskell code to run the function and turn the result back into a haskell type and print
15:30:49 <hpc> Phyx-: what would happen?
15:31:09 <Phyx-> hpc: well, the c# version segfaults too. a normal function like foo :: Int -> [Int] works fine, but when exporting a higher-order function with lists something goes wrong. foo :: Int -> (Int -> [Int]) -> [Int]
15:31:22 <parcs> mnslaww: to be able to define a MonadIO instance of Iteratee
15:31:29 <Cale> er, sorry, they're not labelled with the least and greatest element, but they are sorted, yes
15:31:34 <Phyx-> hpc: let me check
15:31:37 <Cale> So it'll take log time to findMin
15:31:51 <DevHC> Phyx-: what's the problems?
15:31:53 <DevHC> -s
15:31:59 <mnslaww> parcs- oh, does this have something to do with MonadTransformers or something?
15:32:11 <Cale> tomh: Set requires an Ord instance with a total ordering on the elements to operate correctly
15:32:19 <Cale> tomh: What are you trying to do?
15:32:27 <parcs> mnslaww: no, not really. the m parameter makes it more convenient to work with Iteratees in IO
15:32:37 <tomh> Im inserting a tuple in the Set
15:32:42 <parcs> (by allowing a MonadIO instance)
15:32:48 <Phyx-> hpc: in haskell it works
15:32:53 <tomh> oh stupid me, I could just swap around the arguments :>
15:33:08 <tomh> a tuple gets sorted on its first element right?
15:33:13 <ddarius> Yes.
15:33:16 <tomh> cool
15:33:18 <Phyx-> DevHC: i'm getting a segfault when calling a higher-order function from C and C#
15:33:18 <ddarius> Lexicographically.
15:33:20 <Cale> lexicographically
15:33:21 <Cale> yeah
15:33:28 <tomh> thats what I need
15:33:30 <Phyx-> DevHC: but the exact exported function works in ghci
15:33:36 <Cale> So if the first parts match, the second parts are compared.
15:33:41 <tomh> just need to swap two arguments
15:33:42 <tomh> yeah
15:34:45 <DevHC> Phyx-: and the function is http://pastebin.com/MXn25vRT ?
15:36:17 <Phyx-> DevHC: no, that's the particular instance that handles the marshalling of lists, my tool converts every function that returns a list [a], into Ptr Int -> Ptr a, where the int* would contain the size of the array
15:36:23 <Phyx-> let me paste the function
15:38:02 <DevHC> [a] to (Ptr Int -> Ptr a)?
15:38:35 <Phyx-> DevHC: http://pastebin.com/MXn25vRT
15:39:40 <Phyx-> DevHC: yes, it expands the type, so if you have foo :: Int -> [Int], the exported function would be CInt -> Ptr CInt -> Ptr CInt, where the first int* contains the length of the second value, which is the returned array
15:40:04 <Phyx-> then it creates conversion instances between the two, because I'm wrapping the existing implementation
15:40:57 <SoleSoul> ddarius: was the english algorithm I wrote so wrong you gave up on me?
15:41:42 <ddarius> SoleSoul: You should be able to directly translate it into Haskell in terms of the functions you know.
15:41:57 <DevHC> Phyx-: that's kind of hard to parse at first :P
15:42:03 <DevHC> Phyx-: stdcall and not ccall?
15:42:33 <Phyx-> DevHC: yes, it makes calling from C# a bit easier, but that shouldn't be an issue I don't believe.
15:42:52 <SoleSoul> ddarius: that's fine. I can write an additional helper funciton and do it with two functions. I just wanted to know I don't invent the wheel. I mean, I'm not missing an obvious prelude function again.
15:43:12 <diabolix> bit of a noob here, if I wan't to use the IO monad to build some data structure from a file, how do I return the result to code that doesn't use the IO monad?
15:43:24 <Phyx-> DevHC: the basic idea is this, you give it a function, a normal Haskell function, and it does what's needed to give you an exportable function
15:43:33 <Saizan> Phyx-: so Int -> (Int -> [Int]) -> [Int] becomes Ptr CInt -> FunPtr (Ptr CInt -> Ptr CInt -> Ptr CInt) -> Ptr CInt -> Ptr CInt ?
15:43:35 <parcs> diabolix: with (>>=)
15:43:37 <parcs> @type (>>=)
15:43:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:43:55 <parcs> or evne
15:43:59 <parcs> @type IO fmap
15:44:00 <lambdabot> Not in scope: data constructor `IO'
15:44:15 <parcs> @type fmap :: (a -> b) -> (IO a -> IO b)
15:44:16 <lambdabot> forall a b. (a -> b) -> IO a -> IO b
15:44:40 <djahandarie> @type (>>=) :: IO a -> (a -> IO b) -> IO b
15:44:41 <lambdabot> forall a b. IO a -> (a -> IO b) -> IO b
15:44:43 <Phyx-> Saizan: no, CInt -> FunPtr (CInt -> Ptr CInt -> Ptr CInt) -> Ptr CInt -> Ptr CInt , since the normal Int arguments aren't pointers
15:45:10 <Saizan> ah, yeah
15:45:40 <Phyx-> and then I provide an instance of my FFIType class to convert between the two
15:46:06 <Phyx-> I had a bug earlier with lazyness, that the Ptr values were being read before the function was actually applied, I solved those by the strict lets
15:46:12 <Phyx-> but I must have one more somewhere
15:47:35 <diabolix> parcs, but the result of >>= is wrapped in a monad? unless I don't understand what I'm seeing.
15:48:09 <Phyx-> I have a couple of test cases, all iterations work, except for the case where the argument function returns a list
15:48:20 <Phyx-> i know that the function is actually called
15:48:25 <parcs> diabolix: once you're in IO you can't go back
15:48:31 <Phyx-> .e.g if i set a breakpoint in c# the function gets called
15:48:41 <Phyx-> so it must be somewhere when reading the results of the function
15:49:23 <diabolix> parcs: so, if I wan't to read in an array, and then do some math on it, there is no way to write a function that, given a filename, returns an array?
15:49:28 <DevHC> can u explain "(Int -> [Int] -> [Int])" and "CInt -> CInt -> (Ptr (CInt)" ? (in plyA and CBF3Ptr)
15:49:49 <gio123> Cale: hi
15:50:36 <parcs> diabolix: it's not possible. your function would have a type of FileName -> IO (Array i x)
15:51:11 <parcs> FilePatH*
15:51:32 <rostayob> @pl \x, y -> x ++ f y
15:51:32 <lambdabot> uncurry ((. f) . (++))
15:51:45 <rostayob> @pl \x y -> x ++ f y
15:51:45 <lambdabot> (. f) . (++)
15:51:46 <parcs> if you want to process the array, you can create a pure function like Array i x -> Int
15:52:08 <Saizan> Phyx-: how does it allocate memory for the pointer?
15:52:19 <parcs> and then compose the two functions like so : do { array <- getArray "blah.txt"; return (processArray array) }
15:52:32 <Saizan> Phyx-: for the elements of the list, i mean
15:54:48 <Phyx-> DevHC: ok, so the original function It's providing a wrapper for had an argument of type Int -> [Int] -> [Int], so this becomes a function pointer (FunPtr). to it tries to convert the original type into a type FFI can export (in the case of Int this, Int is already an FFI type, but I choose to convert it to CInt which is always 32bits i beleive, since ghc is only x86 on windows). So the first iteration is CInt -> Ptr CInt -> Ptr CInt, now 
15:54:55 <Phyx-> Saizan: by another instance, let me paste
15:56:31 <Phyx-> Saizan: http://pastebin.com/1TZNwb5V which just calls newArray
15:58:03 <Phyx-> Saizan: actually, no it depends on the types being converted, the two instances generally used are http://pastebin.com/1TZNwb5V
16:00:45 <Phyx-> DevHC: and CBF3Ptr is just a type alias for that Funtion pointer, (name is autogenerated)
16:01:22 <DevHC> Phyx- lol i was about to ask u to remove redundant parentheses from ur code
16:03:06 <Phyx-> DevHC: yes, the pretty printer goes a bit overboard with it, due to that when there are more types being applies like Maybe ([] String) for instance,  the parenthesis is needed.
16:03:18 <Phyx-> instead of actually checking if the parenthesis is needed, I just always print them
16:03:26 <Phyx-> it's generated code and not supposed to be viewed normally :P
16:03:31 <Saizan> mh, overlapping instances, i'd be worried that on the same pointer one instance is used in one context and a different instance in another context other
16:03:50 <Saizan> s/other//
16:05:01 <Phyx-> Saizan: i think I can safely remove the first instance, not sure it's being used
16:05:12 <Phyx-> since I almost always use the second one
16:05:16 <Phyx-> or intend to anyway
16:06:07 <Saizan> that'd be a way to test, at least
16:06:28 <Phyx-> rebuilding
16:07:04 <Phyx-> ok, seems to be linking, lemme try calling the dll
16:07:41 <Phyx-> the same thing
16:07:50 <Phyx-> weird enough C doesn't give me any errors
16:07:53 <Phyx-> it just exists
16:07:58 <Phyx-> not even the normal segfault crash
16:08:12 <Phyx-> it just says "exit value 127"
16:08:26 <Phyx-> and for *some* reason
16:08:26 <DevHC> r u stdcalling? :P
16:08:41 <Phyx-> when I attach a debugger like WinDbg it does work
16:08:45 <Taslem> How should I go about assigning a large body of text that contains quotation marks to a value?
16:08:48 <Phyx-> and produce the correct values, always
16:09:02 <Phyx-> DevHC: yup, the rest of the calls work too
16:09:06 <Taslem> Just replace all the quotes with their escaped values, or load from a file, or what?
16:09:13 <diabolix> parcs: sorry, someone was at the door, I'm guessing I then have to pass the function to the code that does the IO?
16:10:04 <dcolish> I am having a lot of trouble understanding what the errors in this paste mean: http://paste.pocoo.org/show/6ZN8tDgR61NUiBtCARM3
16:10:21 <Taslem> What does the error say?
16:10:27 <dcolish> its in that paste
16:10:38 <Taslem> Oh, I see.
16:10:43 <parcs> diabolix: eventually, yes
16:10:45 <dcolish> deduction errors
16:10:51 <Taslem> What interpreter are you using?
16:10:52 <dcolish> i'm experitmenting with typeclasses and I think i've gotten very very confused
16:11:20 <dcolish> ghci 7
16:11:32 <Phyx-> DevHC, Saizan the C code is http://pastebin.com/8RP5rq6j
16:13:12 <diabolix> parcs: so, what if I was using a gui monad, and I wanted to display the result there? How do I use the result from the IO monad in the gui monad?
16:13:23 <DevHC> weird enough the comment in the C code not not correspod to the declaration in the Haskell code? :o
16:13:36 <DevHC> (// type CBF3 = ...)
16:14:48 <Saizan> Phyx-: aren't you supposed to assign something to b2?
16:14:53 <Phyx-> DevHC: right, because in that case it's just telling you what Haskell type the function would be expecting, using as much as the original Haskell types as possible.
16:15:09 <Xaratas> hi, can i pattern match to "Set.empty" ?
16:15:23 <Phyx-> Saizan: it's the second argument to the function, I assume it's already got a value, so i'm just returning the same value passed to me
16:15:24 <ben> Maybe with view patterns :>
16:16:00 <ddarius> Xaratas: No, but you can just use a guard.
16:16:04 <Phyx-> Saizan: b2 is the [Int], b1 it's size, and c the size of the list being returned
16:16:24 <Xaratas> hm
16:16:35 <Xaratas> ddarius: ok
16:16:52 <Taslem> What's the syntax for signalling an extension, again?
16:17:08 <Twey> ‘Extension’ meaning a subclass?
16:17:18 <Phyx-> Saizan: since I pass to it an empty list, b1 == 0, and b2 contains a nothing, a random adress, it shouldn't be read.
16:17:21 <Twey> Same as any type: instance Show n => Num n where …
16:17:22 <diabolix> parcs: nevermind, I see that this GUI library uses the IO monad.
16:17:23 <DevHC> Phyx-: plz remove the "c=&b1;" statement which has no side effect
16:17:24 <Taslem> Extensions for GHC.
16:17:27 <Twey> Oh
16:17:31 <Twey> -XExtensionName
16:17:40 <Twey> {-# LANGUAGE ExtensionName #-}
16:17:45 <Twey> :set -XExtensionName
16:17:46 <Taslem> Okay.
16:17:46 <Phyx-> Saizan: maybe the problem is that? that peekArray tries to read it anyway? even though the size is 0?
16:18:46 <Phyx-> DevHC: how so? I'm assigning the size of the array to be read, it that's not there then c will just contain a "random" value when being read in
16:19:30 <Saizan> Phyx-: c points to the address of b1, but b1 is probably in the stack frame of iply, which is no more valid when iply returns?
16:19:56 <Taslem> dcolish: Your code requires an extension for deriving a pretty specific typing case. What exactly is it supposed to do?
16:20:24 <DevHC> c is a formal parameter which is a copy-of-some-pointer, u r writing to it and returning immediately
16:20:34 <DevHC> perhaps u means something like *c = b1;
16:20:58 <dcolish> well i am trying to construct a typeclass for heaps and then instantiate it to a LeftistHeap, but that requires the introduction of Ord for the heaps elements
16:21:18 <Phyx-> DevHC: yeah, that's it :/ can't beleive I missed that for 3 days
16:21:19 <Phyx-> :/
16:21:25 <Phyx-> my C is a bit rusty..
16:21:30 <DevHC> olololololololo
16:21:31 <dcolish> i think the idea of constraining multiple typeclases into one is a tough thing to get right
16:22:29 <dcolish> findMin works just find on the LeftistHeap datatype when not used as part of a Heap instance
16:22:37 <Phyx-> Saizan: right, so it was working in when ran attached to a debugger because the adress was being kept valid by the debugger probably..
16:22:41 <Phyx-> thanks DevHC, Saizan
16:23:00 * Phyx- feels like slapping himself
16:24:36 <DevHC> shapr: what a nice day to troll on #haskell, isn't it?
16:25:49 <applicative> dcolish can the type of findMin in the class definition for Heap really be h -> a
16:26:09 <dcolish> well it really should be h a ->
16:26:28 <dcolish> i had other issues that altering that resolved, hence my confusion
16:26:37 <applicative> oh I see you just mentioned it, I was running the module
16:27:03 <dcolish> oh thanks! i actually had an issue added that back in
16:27:07 <dcolish> *adding
16:27:35 <dcolish> i think this module would be easier to work with if i didnt have so many typeclasses
16:27:50 <dcolish> thats how Okasaki does it but i thought i'd try a different approach
16:27:54 <Phyx-> DevHC: did you mean me? i didn't see shapr speak :P
16:28:40 <diabolix> Is it fair to say that almost any time you need sequential interaction with the outside world, you use the IO monad?
16:28:43 <dafis> ClaudiusMaximus: ping?
16:28:47 <DevHC> Phyx-: <shapr> DevHC: I have the ban hammer handy.... trolls get removed from #haskell
16:28:55 <ClaudiusMaximus> dafis: pong
16:28:58 * hackagebot hplaylist 0.2 - Application for managing playlist files on a music player  http://hackage.haskell.org/package/hplaylist-0.2 (TimChevalier)
16:29:25 <Phyx-> DevHC: lol, was that here?
16:29:26 <ClaudiusMaximus> dafis: just saw the mail, almost certainly will be tomorrow afternoon before i get a chance to look at it (almost 1am here..)
16:29:33 <dafis> ClaudiusMaximus: sent you a candidate for floatshow, comments welcome
16:29:36 <Phyx-> weird.. i didn't see him speak
16:30:05 <tswett> Aw, I hate it when my pure Haskell code segfaults.
16:30:09 <applicative> dcolish, I don't know this stuff but don't you want two parameters, class Insertable a st where ... rather than class Insertable st where meaning you can "insert" an a into a st
16:30:12 <dafis> ClaudiusMaximus: okay, fine with me. Have you already wrestled with libqd's output?
16:30:37 <DevHC> Phyx-: he said that before u joined
16:31:07 <dcolish> applicative:  i think you're on to something, i am trying insert :: Ord a  => a -> h a -> ha
16:31:10 <dcolish> *h a
16:31:24 <tswett> This should be trivial to replicate.  Open up GHCi, load the module Data.Complex, and evaluate "take 20 $ map cis [0, 2*pi/2..]".  Do you get a segmentation fault?
16:31:35 <tswett> (I ask of nobody in particular.)
16:31:58 <ClaudiusMaximus> dafis: not yet, mixture of procrastination and real life stuff..
16:32:19 <dafis> ClaudiusMaximus: so it may still be very useful :)
16:32:34 <ClaudiusMaximus> dafis: maybe :)
16:32:40 <dcolish> applicative: ah i finally got it http://paste.pocoo.org/show/HVlPsEQAzYkQbrZwBB8W
16:32:51 <BMeph> tswett: Nope. :)
16:33:02 <aninhumer> tswett: Nope
16:33:17 <ktosiek> tswett: no, on 6.12.3
16:33:25 <dafis> tswett: nor here
16:33:26 * dcolish rewards self with beer
16:33:35 <tswett> I have 6.10.4.  Maybe I should ugprade and see if it works then.
16:33:41 <aninhumer> 7.0.2 here, apparently
16:33:52 <BMeph> 7.0.3 for me.
16:34:14 <dafis> tswett: 6.10.4 doesn't segfault here either on that
16:34:33 <tswett> Huh.
16:34:54 * tswett installs a different distribution
16:35:20 <tswett> Thank you, by the way.
16:35:58 * hackagebot stringsearch 0.3.6 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.6 (DanielFischer)
16:38:41 <kim_> I'm a very visual kind of person, so I'd like to draw pictures to help me learn. What's a good library to do that with (and is there an associated tutorial?)
16:39:00 * kim_ has been googling for about 30 minutes. I get all kinds of hits, but no canonical answer
16:39:49 <ddarius> I recommend pencil and paper.
16:40:22 <kim_> <grin> always.
16:40:27 <tswett> kim_: is there any reason you're seeking a library, rather than an application, or a set of physical objects?
16:40:48 <tswett> If a pencil and paper won't do it for you, then there must be something you need more specific than simply drawing pictures.
16:41:10 <kim_> well, when learning C, I used SDL to help me learn, with python , pygame was a big help. Java had AWT at the time, BASIC goes from 0 to graphics in about 2 lines...
16:41:34 <tswett> Okay, so you'd like to learn Haskell by learning how to make Haskell draw pictures.
16:41:35 <Twey> FieldTrip is neat
16:41:42 <kim_> tswett, *nod*
16:41:50 <Twey> We do have an SDL library, but you probably won't learn much Haskell from using it.
16:42:07 <tswett> I defer to Twey's superior knowledge.
16:42:26 <kim_> Twey, not directly, I'd imagine, but plotting program output helps a lot.
16:42:35 <kim_> (just like plotting functions helps mathematicians)
16:42:45 <erus`> kim_: good luck if your on windows
16:42:46 <tswett> Well, my expression no longer segfaults.  It must have been some strange fluke.
16:43:03 * kim_ guesses that everyone who is in the channel atm happens to be text-oriented instead
16:43:19 <kim_> erus`, not on windows, fortunately
16:43:49 <kim_> Oh and LOGO (great introduction to functional programming) , goes from 0 to graphics in the space of time it takes to start a REPL :-P
16:43:53 <erus`> make a tic tac toe game with ai
16:44:12 <erus`> LOGO is functional?
16:44:20 <ddarius> kim_: Somethig like gloss or graphics-drawingcombinators or chalkboard may be appropriate.
16:44:29 <kim_> erus`, for instance. I tend to plot color squares, or animated graphics, or make a computer games
16:45:15 <kim_> erus`, indeed it is. It is a langauge designed to expose children to functional prorgamming at an early age. I think it kind of died off, because it was too much of a mindfuck for the teachers ;-)
16:45:22 <kim_> though some people still use it~!
16:45:22 <erus`> yer me too. but haskell on windows is a pain, you can only really use glut which means you have to store state and  stuff because it uses callbacks
16:45:37 <erus`> i used it at school years ago
16:45:52 <erus`> it seemed more like a series of imperative statements
16:46:03 <Lemmih> kim_: Perhaps something like this: http://pnyf.inf.elte.hu/fp/FunctionGraphs_en.xml ?
16:46:11 <kim_> Gloss "Get something cool on the screen in under 10 minutes."
16:46:14 <kim_> sounds like a plan
16:46:48 <kim_> erus`, to  doesn't remind you of   let    ?   it's fully recursive.
16:48:07 <kim_> drawingCombinators looks cool too
16:48:16 <applicative> kim_ what os are you using ?
16:48:29 <applicative> this is all a bit platform dependent
16:48:37 <kim_> applicative, Linux. Either gentoo or ubuntu
16:48:43 <applicative> oh good
16:48:46 <kim_> applicative, ok, platform dependence is not good
16:49:14 <kim_> but if it helps me learn, that's a good start
16:49:36 <aninhumer> Wikipedia states that Logo is functional, but none of the rest of the article convinces me that's the case
16:49:39 <Peaker> Hmm.. people recommended trying ghci's debugger again.. so.. :trace main   seems to skip my breakpoints and jump directly to my pure exception
16:49:42 <applicative> kim_, its just that on the standard ones, it's a pain to get the haskell libraries properly installed and linked etc.
16:49:43 <Peaker> how do I step through my main?
16:50:12 <kim_> applicative, :-/
16:51:16 <erus`> its not purely functional :)
16:51:20 <Peaker> aha, it appears once a name has been evaluated -- ghci will refuse to re-evaluate it, so how can I get it to "forget" the result so I can debug it again?
16:51:37 <erus`> :help
16:51:39 <applicative> kim_, it's not that big a deal, just annoying if you are first learning haskell, but a proper package manager should handle things.
16:52:05 <Peaker> erus`: doesn't seem to have any result regarding this
16:53:18 <kim_> applicative, <3 package managers :-)
16:53:27 <kim_> folks, thanks for the help so far. :-)
16:54:02 <dafis> Peaker: :set +r might help
16:54:32 <Peaker> dafis: thanks
16:55:20 <Peaker> is there any emacs support for ghci's debugger?
16:55:26 <Peaker> Manually using :step is a bit of a pain :)
16:58:47 <Phyx-> gn
17:03:57 <kim_> I like the name of the haskell package manager (cabal)
17:03:59 <kim_> TINC
17:05:56 <ddarius> @where hsu
17:05:56 <lambdabot> I know nothing about hsu.
17:07:25 <shapr> ddarius: The Haskell Secret Underground does not exist.
17:08:28 <dolio> You're still holding the ban hammer.
17:08:49 --- mode: shapr set -o shapr
17:09:01 <Peaker> How do you nicely "test" a hanoi solution represented as a [Move] where data Move = Move { disk :: Int, from :: Int, to :: Int } ?  I have a solution but I wonder if there are nicer ways
17:09:07 <ddarius> Apparently even lambdabot has forgotten about it.
17:10:15 <Peaker> Basically I define:  type Tower = [Int] ; type Towers = [Tower],  and then a function:  nths :: [Int] -> ([a] -> [a]) -> [a] -> [a]      (apply a function on some subset of the indices of the list)... but I don't find it very pretty,  it allows "moving" from the "from" list to the "to" list
17:10:38 <Peaker> (since it is all Int addressing, not sure how to make it prettier)
17:10:46 <mauke> why so complicated?
17:11:14 <Peaker> mauke: I want to actually "apply" the list of moves to real "towers" -- I'd be glad to hear a simpler representation for the towers or how to apply it
17:11:16 <shapr> Peaker: smallcheck? start from the base case and work your way up?
17:11:33 <mauke> why represent them at all?
17:11:36 <Peaker> shapr: I said "test" where I should have said "apply"
17:11:47 <Peaker> mauke: toying around -- I want to present the solution "at work" to beginners
17:12:11 <saiko-chriskun> anyway to get rid of the newline getLine makes?
17:12:21 <mauke> saiko-chriskun: ?
17:12:35 <Peaker> saiko-chriskun: getLine doesn't yield a newline at the end of its result
17:12:40 <saiko-chriskun> hm
17:12:45 <saiko-chriskun> does hFlush stdout?
17:12:57 <mauke> saiko-chriskun: what are you talking about?
17:14:27 <Saizan> well, getLine will wait for input until it gets a newline, so by default that newline will also appear in your terminal
17:14:31 <DevHC> why isn't the default getContents' encoding binary?
17:15:18 <saiko-chriskun> Saizan: oo right :P
17:15:23 <aninhumer> saiko-chriskun: init s returns all but the last element of a list (or string) so it essentially removes the last character
17:15:26 <saiko-chriskun> is there anyway to like backspace or do I just have to deal with it?
17:16:26 <parcs> @hoogle hSetEcho
17:16:26 <lambdabot> System.IO hSetEcho :: Handle -> Bool -> IO ()
17:16:34 <parcs> saiko-chriskun: hSetEcho stdin False
17:16:45 <Peaker> Haskell's builtin IO libraries suck :-(  The String type ought to die, and Haskell's libraries ought to be polymorphic enough that using Text instead does not require changing all the code
17:17:01 <parcs> actually, that is irrelevant in your case :/
17:17:02 <Twey> Truly
17:17:05 <Saizan> but then he won't see any of the text either :)
17:17:43 <parcs> saiko-chriskun: you'll need to use a package like ansi-terminal to manipulate the terminal's contents
17:18:06 <saiko-chriskun> alrighty I'll take a look
17:21:03 * hackagebot applicative-quoters 0.1.0.1 - Quasiquoters for idiom brackets and an applicative do-notation  http://hackage.haskell.org/package/applicative-quoters-0.1.0.1 (BenMillwood)
17:21:49 <shapr> Peaker: submit patches... or fork the libs and upload to Hackage!
17:24:16 <Peaker> shapr: getting rid of the String type would probably be quite a feat!
17:24:52 <shapr> Peaker: You can do it!
17:25:15 <Peaker> I wonder why things weren't polymorphic from the get-go... is it because that kind of polymorphism was less academically interesting when Haskell was still just an academic interest?
17:25:36 <Peaker> ("bah, everyone knows how to solve this kind of polymorphism, let's solve the harder types and ignore the simple cases")
17:26:02 <ddarius> Haskell was never intended to be "just an academic interest."
17:27:00 <Peaker> what was Haskell in its first few months/year?
17:27:13 <ben> (++) should be 'polymorphic' enough to work on monoids, goddamnit!
17:27:54 <aninhumer> What makes that difficult?
17:28:16 <dolio> Nothing.
17:28:18 * BMeph is disappointed that so many people seem not to know, or care, the difference between academic, and intellectual, concerns.
17:29:13 <Peaker> polymorphic higher-kinded stuff? sure!  polymorphic containers? Nah!
17:29:46 <Saizan> polymoprhic containers are probably going to be higher-kinded
17:29:50 <kim_> ./cabal list ghc-prim    .... "  Latest version available: [ Not available from server ] \n Latest version installed: 0.1.0.0
17:29:50 <kim_>  "  What the *bleep*
17:30:42 <SoleSoul> isAlpha returns true for alphabetic chars. Is there a predicate which returns true for alphabetic chars and underscore? ('_')
17:31:08 <mauke> yeah, \c -> isAlpha c || c == '_'
17:31:21 <Saizan> but, tbf, if you take the haskell prelude you've plenty of monads but only a single string type, and the only container is association lists
17:31:22 <SoleSoul> cool :) thanks
17:31:47 <mauke> :t liftA2 (||) isAlpha ('_' ==)
17:31:48 <lambdabot> Char -> Bool
17:32:04 <Saizan> another contributing factor is the size and complexity of typical containers and streams APIs
17:32:09 <ddarius> Saizan: Actually, there are relatively few instances of Monad in the Prelude.
17:32:11 <ben> The prelude kinda looks like it was intended to be some sort of example code collection and accidentally grew into a standard library
17:32:21 <ddarius> Also, Edison was made over a decade ago.
17:32:31 <mauke> :t flip all [isAlpha, ('_' ==)] . flip id
17:32:32 <lambdabot> Char -> Bool
17:33:00 <Saizan> yeah, but why it never got widely used?
17:33:13 <aninhumer> mauke: I think there should be <&&> and <||> predicate combinators personally...
17:33:14 <nihtml> :t id
17:33:15 <lambdabot> forall a. a -> a
17:33:18 <nihtml> :t flip id
17:33:19 <lambdabot> forall a b. a -> (a -> b) -> b
17:33:35 <ddarius> Saizan: Perhaps the reason is this is not the slam dunk that Peaker thinks it is.
17:34:04 <hydo> A question in the form of a past: http://hpaste.org/46918/shortcuts
17:34:23 <Saizan> ddarius: i.e. only a few care?
17:34:36 <Peaker> ddarius: even standardizing on some monstrous thing like ListLike would have probably been better (though modular smaller classes would have of course been much better)
17:34:38 <ddarius> Saizan: No.  I.e. it isn't as easy as it seems.
17:36:27 <Saizan> ddarius: so Edison isn't actually good?
17:37:12 <Peaker> what's the difference in power between a Foldable instance and a toList function?
17:37:31 <ian_mi> nothing
17:37:33 <ddarius> Peaker: None whatsoever.
17:37:52 <dolio> What's the difference in efficiency between a Foldable instance and a toList function?
17:37:52 <Saizan> because if Edison did it 10 years ago i wouldn't consider it hard at this point :)
17:38:01 <Peaker> Is performance the reason?
17:38:12 <ddarius> Saizan: It has several problems and apparently it's not so obviously better that people are flocking to it.  Perhaps it's because Haskell is just an academic interest.
17:38:17 <ian_mi> toList constitutes a complete definition of Foldable
17:38:57 <ddarius> Saizan: ML did full-blown REPLs and much better modules way more than ten years ago, yet Haskell uses a rather simple module system.
17:39:04 <Peaker> What was the reason that Foldable was defined?
17:39:30 <ian_mi> to use one function instead of two I guess
17:39:33 <Peaker> ddarius: full-blown REPLs as in allow everything that files allow, without having to lose declared things when defining data-types/etc?
17:39:41 <dolio> To overload foldr for multiple structures.
17:40:19 <Saizan> ddarius: i wouldn't consider hard to just bolt ML modules on top of haskell though
17:40:21 <Peaker> dolio: why not have a single toList in there, and then define all of the methods in terms of that?
17:40:27 <ddarius> In my opinion, Foldable at best provides a performance benefit and at worst leads to less general functions.
17:40:31 <dolio> Peaker: Why is that better?
17:40:33 <ddarius> Saizan: It isn't hard at all.
17:40:39 <Peaker> dolio: Simplicity?
17:40:46 <Peaker> dolio: Clarity about the meaning of the class
17:40:49 <ddarius> Saizan: Nor would it be hard to add a much more powerful record system.
17:40:52 <dolio> Peaker: In what way is toList simpler than foldr?
17:41:10 <ddarius> Nor does anyone deny that this would be better than the current approaches now.
17:41:18 <saiko-chriskun> is there a way to use getChar without waiting for a newline?
17:41:23 <Peaker> dolio: t a -> [a]  is simpler than:  (a -> b -> b) -> b -> t a -> b
17:41:48 <dolio> How can you tell?
17:42:21 <Cale> saiko-chriskun: Probably stdin is set on LineBuffering
17:42:25 <ddarius> Saizan: The problem is, just blindly attaching these to Haskell creates a lot of redundancy and/or is likely to have weird gaps.  The Haskell community is rather particular about having the "right" approach.
17:42:35 <Cale> hSetBuffering stdin NoBuffering
17:42:41 <Peaker> dolio: the type is smaller/simpler -- the value is also probably simpler, as it is simpler in two example cases (List, Maybe)
17:43:15 <Saizan> ddarius: yep, but converging to Edison would have a much lesser impact overall, and could be done by anyone contributing to hackage
17:43:57 <saiko-chriskun> Cale: thankies :]
17:44:41 <ddarius> Saizan: Yes, but Edison is far from a clear win that e.g. ML-like modules would be.  Anyway, Edison uses extensions, so at least Edison blows away the idea that this problem was just a trivial form of polymorphism that was ignored.
17:44:52 <dolio> Anyhow, I find myself wanting foldr or foldMap on arbitrary structures more than I want toList.
17:45:00 <Cale> saiko-chriskun: You may want to set it back on LineBuffering after though, if you're reading input from the user, since that's what enables line editing.
17:45:07 <saiko-chriskun> yeah
17:45:37 <dolio> So all your approach seems to do is make that go through an intermediate list in the name of simplicity.
17:45:56 <dolio> Meaning the library probably gets a bunch of RULEs in it instead.
17:45:58 <ddarius> dolio: Except that you may want many different ways of flattening a list.
17:46:55 <aninhumer> Whether toList is an approriate way to define folding surely depends on your structure?
17:47:32 <ddarius> aninhumer: Foldalbe is exactly equivalent to having a (distinguished) toList function.  It has nothing to do with folds.
17:48:35 <dolio> foldMap is probably a better reason to have Foldable.
17:48:44 <kim_> hmm, I'm having trouble installing ghc-prim (required for gloss) using cabal in my homedir. Oddly, ghc-prim is listed at http://hackage.haskell.org/packages/archive/   , but does NOT show up  at  tar --list -f ~/.cabal/packages/hackage.haskell.org/00-index.tar | grep ghc-prim/
17:48:47 <hpc> :t foldMap
17:48:48 <lambdabot> Not in scope: `foldMap'
17:49:06 <dolio> I don't really find the foldr method that useful.
17:49:28 <dolio> I'd rather have a fold with the relevant functor structure.
17:49:34 <dolio> But that's a lot messier to pull off.
17:49:39 <Saizan> it's fun that there probably are more HList variants than Edison variants though :)
17:50:04 <ddarius> The only potential benefit of Foldable is performance.  Other than that, it just chooses a "toList" function arbitrarily.
17:50:38 <Saizan> kim_: you can't install ghc-prim via cabal, it should come with your ghc though
17:50:54 <Saizan> kim_: check ghc-pkg list ghc-prim
17:51:03 <kim_> Ok, well, why didn't nothing say so!? :-/
17:51:19 <kim_> /usr/lib64/ghc-6.10.4/./package.conf:
17:51:19 <kim_>     ghc-prim-0.1.0.0
17:51:35 <kim_> I guess I need a newer version of ghc, eh? ;-)
17:52:00 <Saizan> if that ghc-prim doesn't fit..
17:52:10 <kim_> You must acquit?
17:52:14 * kim_ ducks
17:52:16 <ddarius> Why were you trying to upgrade ghc-prim anyway?
17:52:26 <kim_> I wasn't, directly
17:52:59 <kim_> cabal install gloss  fails on ghc-prim
17:53:19 <kim_> so the first thing one tries is     cabal install   ghc-prim
17:53:55 <Saizan> if ghc-prim was upgradeable through cabal it would've done so
17:53:59 <Peaker> dolio: you can have: class ToList t where toList :: t a -> [a]   ; foldMap :: (ToList t, Monoid m) => (a -> m) -> t a -> m ;  it doesn't need to be a method
17:54:00 <kim_> which (given the information I had up to 5 minutes ago) should work
17:54:24 <Saizan> during "cabal install gloss" i mean
17:54:49 <dolio> Peaker: The interesting thing about foldMap is that it doesn't need to be (f x ++ (f y ++ (f z ++ ...
17:55:14 <ddarius> Peaker: You can just have foldMap on lists.  There is no need for a ToList class.
17:55:16 <kim_> Saizan:the errors are:
17:55:18 <kim_> There is no available version of ghc-prim that satisfies ==0.2.*
17:55:20 <dolio> But it does if you define it via toList.
17:55:25 <kim_> and cabal install ghc-prim yields
17:55:32 <kim_> cabal: There is no package named ghc-prim. Perhaps you need to run 'cabal
17:55:32 <kim_> update' first?
17:56:03 <Saizan> i concur that it's not very explicit about what's going on there :)
17:56:17 <kim_> well, so I run cabal-update
17:56:24 <kim_> but that doesn't clear the error
17:56:35 <kim_> hence, stuck, and coming to irc ;-)
17:56:50 <Peaker> ddarius: why have a Show class? You can just call toString or showType on various datatypes?
17:57:00 <ddarius> You just need a newer version of GHC.  Even the earliest versions of gloss require at least 6.12.
17:57:02 <kim_> (so now asking gentoo to install new ghc)
17:57:11 <kim_> ddarius, already doing it
17:57:14 <Peaker> dolio: what interesting alternatives would it have?
17:57:35 <kim_> this will probably break Everything Else Somehow (tm) ... but thems the breaks
17:58:05 <dolio> Peaker: The associativity can follow the structure of your data.
17:58:13 <ddarius> Peaker: For convenience.  And even Show runs into many problems.  There is usually multiple ways you want to "show" a type.  The same problem happens to the Binary class.
17:59:22 <ddarius> kim_: You'll have to rebuild any libraries against the new GHC, which will happen automatically as its package list simply won't have the old libraries, but otherwise everything should continue working fine.
17:59:56 <kim_> ddarius, this is Gentoo ... :-P
18:00:00 <Peaker> ddarius: Probably (almost?) every possible class can usefully have alternative definitions for the same type
18:00:07 <Saizan> @tell roconnor a multi-threaded program could have Dialogue = [(ThreadId,Response)] -> [(ThreadId,Request)] instead
18:00:07 <lambdabot> Consider it noted.
18:00:19 <dolio> So if you do 'foldMap Product t' on a Tree Integer, where Tree a = Leaf a | Branch (Tree a) (Tree a), it is conceivably associating the multiplication to always multiply equally sized numbers.
18:01:11 <dolio> ((w1*w2)*(x1*x2))*((y1*y2)*(z1*z2))
18:02:04 <ddarius> Peaker: I'd say most classes in the standard libraries have one natural instance.  In many cases, they have only one instance.  Also, Show's variability is less crucial since it usually doesn't really matter how show formats its output.  When it does, you don't use Show.  Similarly for Binary.  The Binary class is mostly useless.
18:02:24 <ddarius> Foldable is useful when you don't actually care what list is produced.
18:03:08 <Peaker> ddarius: The Binary class is useful when you don't care what the wire-format is
18:03:15 <ddarius> Peaker: Yes.
18:03:27 <ddarius> That was the analogy I was drawing.  However, usually you care.
18:03:52 <ddarius> Usually you care more about what Foldable's toList produces than you care about what Show produces.
18:06:31 <djahandarie> Grahh, I really want a simple Vec on Hackage
18:06:49 <copumpkin> put one up
18:06:56 <copumpkin> or take that chunk of code I made and put that on hackage
18:07:31 <djahandarie> You do it, I don't want to maintain it :p
18:07:42 <Peaker> @type Data.Traversable.traverse
18:07:42 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:07:48 <ddarius> Just put it up and list Ed as the maintainer.
18:07:55 <djahandarie> Haha
18:07:58 <Peaker> ddarius: Traversable is a useful class -- and built on top of Foldable, apparently
18:08:04 <Saizan> what is there to maintain?
18:08:13 <djahandarie> There's always something to maintain
18:08:41 <djahandarie> I'm also really lazy when I set my .cabal dependencies
18:08:54 <Peaker> @type Data.Traversable.sequenceA
18:08:54 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
18:09:06 <djahandarie> I don't want to actually research what I'm depending on and when it started existing
18:09:10 <Peaker> Does traversable imply Foldable, or is there another reason for that superclass there?
18:09:27 * Saizan remembers to check his only maintained package on hackage still builds
18:11:00 <ddarius> Traversable implies Foldable.  None of the default definitions rely on Foldable.
18:11:09 <Saizan> ?type Data.Traverse.foldMapDefault
18:11:10 <lambdabot> Couldn't find qualified module.
18:12:42 <ddarius> Peaker: Traversable corresponds to having a distinguished order "left to right" which gives rise to a natural Foldable, namely produce the elements of toList in "left to right" order.
18:13:59 <Peaker> ddarius: how do you define toList in terms of sequenceA?
18:14:11 <Peaker> I'm assuming sequenceA has the same power as traverse
18:14:20 <copumpkin> :t sequenceA
18:14:21 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f [a]
18:14:30 <ddarius> foldMapDefault f = getConst . traverse (Const . f), sequenceA = traverse id
18:14:41 <ddarius> From the source.
18:16:17 <Peaker> ddarius: how does using Foldable result in less general code? (Sorry if you explained above and I missed it)
18:16:31 <Peaker> Because you can't give a custom toList?
18:27:20 <saterus> where should i start looking if cabal keeps running out of memory during an installation?
18:29:12 <dolio> Installation of what?
18:30:22 <gio123> dolio: logic?
18:30:41 <saterus> i've tried doing "cabal install mkcabal" and when that failed, i figured it was something wrong with cabal. so i tried installing cabal-install.
18:31:18 <saterus> it seems to be blowing up during the configure step of some libraries. i was able to pull up top before my system became unresponsive last time, and it looks like its spawning tons of processes.
18:35:01 <saterus> the cabal faq has a note about older versions of ghc with cabal, but i'm running ghc 7.02 and all the libraries have installed are built with 7.02.
18:35:51 <augur> dmwit!
19:12:50 <copumpkin> preflex: seen jaspervdj
19:12:51 <preflex>  jaspervdj was last seen on #haskell 2 days, 2 hours, 59 minutes and 41 seconds ago, saying: I'm off to bed, bye
19:19:15 <dmwit> augur!
19:19:39 <augur> dmwit: Hac phi registration
19:19:48 <dmwit> ah
19:19:58 <dmwit> I haven't gotten an email from you!
19:20:07 <augur> who needs email, you're right here!
19:20:08 <dmwit> But you can just tell me the deets here if you like.
19:20:15 <dmwit> The most important bit is the name of your institution.
19:20:35 <augur> Name: Darryl McAdams ; #haskell nick: augur ; Email: psygnisfive@yahoo.com ; Food restrictions: free, voluminous ; Days attending: who knows ; Institution: The Internet
19:21:02 <dmwit> Outstanding.
19:21:09 <dmwit> You're registered, can't wait to see you in July. =D
19:21:11 <augur> \o/
19:21:23 <augur> dmwit: i cant wait to completely forget that i intend to go
19:21:56 <saiko-chriskun> Text.Regex doesn't seem to like | characters
19:21:56 <augur> dmwit: anything interesting lined up for talks?
19:22:05 <saiko-chriskun> anyone know any workarounds?
19:22:15 <mauke> saiko-chriskun: for what problem?
19:22:21 <dmwit> Hmm... I'm not sure that anybody's volunteered to give a talk yet!
19:22:27 <dmwit> We didn't push them as hard this year.
19:22:34 <augur> dmwit: lame
19:22:34 <saiko-chriskun> mauke: using the | character in mkRegex statements doesn't seem to work
19:22:40 <mauke> saiko-chriskun: how does it fail?
19:22:45 <dmwit> augur: You could get us started... ;-)
19:22:47 <augur> i would give a talk if a) i had something to talk about, and b) i wasnt a wuss
19:22:51 <saiko-chriskun> mauke: doesn't match anything?
19:22:58 <mauke> saiko-chriskun: show me
19:23:04 <dmwit> saiko-chriskun: Did you know that | was a special character?
19:23:14 <dmwit> If you want to match a literal | character, you should use \| to match it.
19:23:37 <djahandarie> dmwit, what sort of talks are you looking for? I would be interested in maybe doing like a 10-15min talk but I don't think I have anything interesting enough for a long one.
19:23:56 <dmwit> 10-15 minutes is perfect
19:24:00 <dmwit> That's usually what we ask for anyway.
19:24:07 <saiko-chriskun> dmwit: I tried that, I get "lexical error in string/character literal at character '|'"
19:24:30 <mauke> saiko-chriskun: did you know that \ is a special character in string literals?
19:24:39 <mauke> if you want a literal \ in a string, you should use \\
19:24:45 <saiko-chriskun> ahhhh there we go
19:24:48 <saiko-chriskun> thanks guys
19:28:48 <dmwit> djahandarie: If you decide to prepare a little talk, you could throw your name up on the wiki if you wanted. http://www.haskell.org/haskellwiki/Hac_%CF%86#Talks
19:29:43 <djahandarie> Okay, I'll keep that in mind
19:43:11 <copumpkin> koninkje_away: enough to overflow a Word64? o.O
19:43:16 <copumpkin> I find that hard to believe
20:12:44 <hydo> How do you handle cases where you need to do several io operations, each of which depend on the one before for a parameter?  I get into a pattern, especially with things that result in IO (Maybe a), of nested case statements and it's UGLY.  It works, but that's not enough for me.
20:13:18 <hydo> example: http://hpaste.org/46918/shortcuts
20:14:59 <adnam> @type (>>=) Nothing -- is your friend
20:15:00 <lambdabot> forall a b. (a -> Maybe b) -> Maybe b
20:15:43 <dolio> hydo: MaybeT
20:16:37 <Axman6> hydo: monad transformers of course :)
20:16:37 <parcs> or ErrorT
20:16:48 <hydo> adnam: I'm sure I tried it, or maybe I didn't since it didn't make sense that that woudl work for Maybes wrapped in IO
20:16:59 <hydo> Reading about maybet and errort now.
20:17:39 <adnam> you'd have to use the instances of >>= for both Monad and IO, might get hairy unless you abstract it :-)
20:18:24 <adnam> maybe what dolio and parcs suggested is that abstraction?
20:18:50 <Axman6> @unmtl MaybeT IO a
20:18:50 <lambdabot> IO (Maybe a)
20:19:10 <adnam> ah
20:19:18 <patmanpato> just out of curiosity, what sort of projects are you folks using Haskell for?
20:19:51 <hydo> Axman6: Thank you.  I hadn't needed to learn about monad transformers until now.  Looking forward to levelling :)
20:20:17 <Axman6> hydo: i found StateT the easiest monad transformer to learn to use.
20:20:42 <hydo> I'm working for a company building a... scrapbooking?  I guess you could call it that - scrapbooking site.  I'm writing the backend in haskell with snap.
20:20:48 <hydo> err... re: patmanpato
20:21:02 <hydo> Axman6: ok, cool.  I'll start with that.
20:21:20 <adnam> oh cool, haven't seen snap
20:21:24 <hydo> Thank for the pointers, Axman6, parcs, and dolio!
20:21:26 <Axman6> basically you get to have IO, with some implicit state
20:22:01 <dolio> No prob, Bob.
20:23:40 <patmanpato> sounds interesting hydro
20:24:07 <patmanpato> hydo , dyslexic moi
20:25:55 <hydo> patmanpato: well, interesting or not, it lets me write haskell for a living. Which probably shocks and horrifies some since I was just asking about monad transformers, but oh well.
20:26:33 <blackdog> hydo: it would be great to have the bar for haskell employment to be lower.
20:26:41 <hydo> "Wait, the application is a single executable with the templates?  No runtime? No nothing?"  <-- that sold it.
20:26:57 <blackdog> anyone ever seen an ad for a junior haskell hacker? :)
20:27:53 <hydo> blackdog: I think it's coming, but that's just me.  Not to the extent that you now see Ruby, but I think it's going to grow quite a bit over the next couple of years.
20:28:10 <hydo> Maybe... hopefully.
20:28:12 <dylukes> hydo: Hopefully by the time I get out of college there'll be plenty of such jobs :)
20:28:45 <blackdog> hydo: yeah. first the startups, then the cool little companies, then the fortune 500s...
20:28:54 <djahandarie> Or just be a senior Haskell hacker by the time you get out of college, then you won't need to worry ;)
20:28:57 <blackdog> by that time we'll all be writing websites in Agda, of course.
20:29:22 <djahandarie> No, Agda will already be dead and everyone will be using Epigram
20:29:41 <blackdog> djahandarie: that's sort of the problem, though. lots of people getting good at haskell, but not in a corporate or team setting so much
20:29:45 <Jafet> ...and Haskell will find its success?
20:29:47 <hydo> *if* and it's a huge -if- the work we're doing right takes off at all, we'll probably be looking to hire someone.
20:30:27 <blackdog> think the normal route will be people sneaking haskell into prototypes, like they used to with rails
20:30:44 <hydo> but it's nice to be in a position of the development company.  whether or not their site takes off, we still get paid.  feels good, man.
20:30:45 <blackdog> hydo: nice work :) and you can inculcate them with the #projectaweek meme
20:31:16 <blackdog> i need to put up a scoreboard:)
20:31:50 <hydo> blackdog: oh god, I've failed so hard at #projectaweek so far.  This current project hit with a "omg we have to get it live now now now!" the day after i said "Ok! I'm going to be productive now!"
20:32:03 <blackdog> heh, i set the thing up and i've only managed one so far
20:32:12 <blackdog> i think my new rule is greenfields projects only
20:32:18 <djahandarie> How does dons do it?!?! ;)
20:32:19 <blackdog> getting old crappy code working is too hard
20:32:27 <blackdog> djahandarie: iteration
20:32:40 <hydo> djahandarie: experience and practice.  and being really, really smart helps.
20:33:34 <hydo> ok, enough irc. I need to cram monad transformers in my head and get back to work.  Thank again for the help, everyone.
20:35:10 <poltak> Is today the rapture?!?!
20:35:20 <sina> yesterday was
20:35:29 <blackdog> guess we're all sinners
20:35:36 <ddarius> I'm definitely one.
20:35:41 <poltak> What does that mean to end-users such as myself?
20:35:56 <blackdog> what if they declared a rapture and nobody came?
20:36:12 <sina> guys, while I'm parsing (or trying to parse) polymorphic types, it is also parsing whitespace
20:36:55 <sina> any idea what might be causing it?
20:37:53 <sina> Either a b is supposed to give me (PolyT "a" "b","") but Either itself gives (PolyT "e" "r","")
20:39:31 * sina "wondering if anyone is there"
20:40:50 <ddarius> It looks like your code is fucked up.  Not too much else anyone can say with no details.
20:40:54 * BMeph is wondering if sina killed the channel...naughty, naughty sina! ;þ
20:41:19 <sina> something happened to the channel! no response for 5 minutes
20:41:37 <ddarius> You clearly haven't been here long.
20:42:12 <sina> ddarius what do u mena?
20:42:18 <sina> mean*
20:43:36 <BMeph> Isn't five minutes the standerd minimun response time for here? :)
20:44:13 <sina> well, there are times that no one is here
20:44:31 <sina> but people were chatting about rapture day and then suddently it all stopped :D
20:45:15 <blackdog> sina: we feel embarrassed talking about inconsequential shit when people are actually discussing haskell, perhaps?
20:46:32 <sina> blackdog: perhaps ... :)
20:47:32 <blackdog> after all, it's only the end of the world
20:49:22 <sina> I'm all ready for it! wish it could be actually the end of the world
20:49:33 <sina> if anyone can take a look http://pastebin.com/dk797TLe
20:49:41 <sina> and read the comments
21:03:03 <sina> anyone looked at my code ?
21:04:04 <blackdog> sina: looked at it and utterly failed to understand it. that's my fault not yours, though.
21:04:58 <sina> needs explaining. matchLB is matching a left bracket
21:05:10 <sina> like this matchLB = matchInput '['
21:05:48 <sina> matchType matches a type. can be function, unary, list, tuple, null, function
21:06:01 <mauke> and don't forget function!
21:06:47 <sina> I'm quite tired working on this thing. 5:20am here :(
21:06:57 <mauke> holy nested tuples
21:07:57 <mauke> I'm so glad we have monads now
21:08:28 <sina> I have no idea about monads. :(
21:08:52 <sully> monads and strife
21:09:05 <sina> and it seems to be so hard that everyone refuses to give an explanation of it and I couldn't understand anything about it on few online websites
21:09:19 <mauke> sina: it's the opposite
21:09:29 <mauke> monads are so trivial there's not much to explain
21:09:40 <blackdog> sina: read Learn You A Haskell
21:09:43 <sully> that's not really true either :P
21:09:46 <jdavis_> Is there a way to seek and read from a file in one operation, or do I have to do hSeek followed by hGet?
21:09:47 <blackdog> it's the clearest guide i've seen yet.
21:09:54 <sully> or Real World Haskell
21:10:12 <blackdog> by the time you get to monads, you'll have anticipated them - they seem natural and obvious
21:10:31 <sina> what are they though ? :D
21:10:39 <blackdog> sully: i like RWH, but less for motivation of structures like monads and more for practical examples.
21:10:47 <blackdog> and the benchmarking chapter is solid gol.d
21:11:02 <mauke> sina: do you know "groups" from algebra?
21:11:08 <blackdog> sina: they're a design pattern that can be checked by the type system.
21:11:55 <sina> mauke: groups like ?
21:12:05 <mauke> sina: what
21:12:16 * sully first learned about monads from Bob Harper
21:12:23 <sully> (really just the IO monad, though)
21:13:01 <fragamus> @type iterate
21:13:02 <lambdabot> forall a. (a -> a) -> a -> [a]
21:13:13 <sina> mauke: if you mean something like http://en.wikipedia.org/wiki/Group_algebra then not really
21:13:25 <mauke> hmm, too bad
21:13:53 <mauke> sina: do you know Monoid?
21:13:58 <mauke> @src Monoid
21:13:58 <lambdabot> class Monoid a where
21:13:58 <lambdabot>     mempty  :: a
21:13:58 <lambdabot>     mappend :: a -> a -> a
21:13:58 <lambdabot>     mconcat :: [a] -> a
21:14:38 <sina> mauke nope.
21:14:41 <fragamus> i need to make some association lists that do efficient lookup
21:15:46 <jdavis_> To rephrase my question: I need to process a file, which contains a bunch of pages. I want to process each page fairly efficiently, but it looks like there are a lot of options: Ptr (returned by System.IO.hGetBuf), Data.ByteString, Data.ByteString.Lazy, etc. Can someone point me in the right direction?
21:16:41 <BMeph> jdavis_: Here's a point - try one. If it works, carry on.
21:17:04 <Jafet> Skipping ByteString and moving straight to ByteString.Lazy, of course
21:17:39 <sina> mauke: can this be an explanation of >>=? All you really need to know, is that the >>= operator either returns "Nothing" if it is passed "Nothing" on it's left-hand side; or if it's left-hand side is a "Just ..." it strips off the just, and passes the contents into the function supplied on it's right-hand side. Simple!
21:18:16 <blackdog> sina: that's how it works for Maybe, certainly
21:18:25 <blackdog> the point is that it behaves differently if you run it under different monads
21:18:31 <mauke> sina: that's how Maybe works
21:18:32 <jdavis_> Jafet, I can't find a way to read a random page from the file though. Or perhaps I can with hSeek on the handle, then using hGet :: Handle -> Int -> Data.ByteString.Lazy
21:18:43 <mauke> Monad is a fairly generic interface, though
21:19:11 <sina> I wish there could be few examples
21:19:14 <jdavis_> Jafet: is it less efficient to do the read in two steps like that?
21:19:15 <Jafet> jdavis: uh, what's a page? A fixed-size block?
21:19:23 <jdavis_> Jafet: yeah
21:19:44 <Jafet> Less efficient than what? mmap?
21:19:44 <sina> rather than trying to theoretically understanding them
21:20:14 <blackdog> @lyah
21:20:14 <lambdabot> Unknown command, try @list
21:20:17 <Jafet> sina: any tutorial that covers a few instances of Monad would explain them.
21:20:24 <Jafet> @where lyah
21:20:24 <lambdabot> http://www.learnyouahaskell.com/
21:20:27 <blackdog> damn. sina, really: look up learn you a haskell.
21:20:28 <mauke> sina: fortunately you don't have to understand the theory
21:20:36 <mauke> like, at all
21:20:45 <blackdog> Jafet: thanks :) it goes through it all very naturally.
21:20:48 <sina> looking at this now http://learnyouahaskell.com/a-fistful-of-monads
21:20:50 <mauke> it's perfectly possible to use tons of monads without understanding Monad
21:20:52 <jdavis_> Jafet: it seems like that would be two system calls, one to seek and another to read. If they are combined, like gHetBuf :: Handle -> Ptr a -> Int -> IO Int, perhaps that's more efficient?
21:21:08 <Jafet> jdavis: you're worrying about system calls over disk I/O?
21:21:11 <sully> I mean, it depends what you mean by "understanding Monad"
21:21:27 <sully> like, if you mean "without understand the category theory", then yeah, absolutely
21:21:44 <jdavis_> Jafet: well, not really, but I thought it seemed strange that there wasn't such an interface for the lazy bytesstrings.
21:21:45 <Jafet> In any case, your implementation of hGetBuf might use two system calls on your platform as well.
21:21:59 <mauke> sully: I mean understanding what the various Monad instances have in common
21:22:18 <blackdog> sina: start from the beginning and skip anything you already know
21:22:35 <jdavis_> Jafet: ok, I'll just do it that way then. Thanks.
21:22:37 <blackdog> sina: if you start at the monads, it will be confusing. really, they're built up out of smaller components that make sense on their own.
21:22:46 <Jafet> Because operating system kernels are used to filling a region of memory with bytes, but not to constructing a ByteString and filling it with bytes.
21:23:05 <Jafet> Or even a thunk that would fill itself with bytes.
21:23:20 <sina> thanks all. I need to learn haskell properly I guess
21:23:42 <sina> but I have this assignment due in tomorrow :( which I have to make a parser do few things :|
21:24:00 <blackdog> sina: no worries. sorry if we seem agitated, it's just we tend to get the whole "i don't understand monads, i must understand monads completely before i can write any haskell"
21:24:05 <Jafet> I'd rather use Lazy.ByteString, unless it is somehow slower than something else you've written (and given that dons is partly responsible for it...)
21:25:18 <jdavis_> Jafet: ok, I'll try it. Thanks.
21:25:32 <sina> blackdog, fortunately, the part of the parser code I can use is not based on monads, so I have to do it without monads
21:26:00 <sina> but since everyone is finding haskell differently after understanding monads, it gets interesting to know
21:26:12 <sina> at least based on what I've seen
21:27:33 <blackdog> sina: there's a bit of history there. monads are really just applicative functors plus a coupel of operations, and applicative functors are just functors plus an operation, but monads came first
21:28:01 <blackdog> so they're not specified as Applicative m => Monad m where ..., as might make more sense
21:28:22 <blackdog> eat it a bite at a time and you'll be fine.
21:28:46 <sina> ok ok :)
21:45:23 <_Ray_> Hi :) For a somewhat-beginner in Haskell, interested in playing around with web-based Haskell development, what would you recommend? From what I've seen, the main two contenders are Happstack and Snap.
21:45:52 <blackdog> _Ray_: yesod also
21:47:25 <blackdog> _Ray_: yesod is pretty sweet - takes type safety in web apps a long away.
21:47:31 <blackdog> *way. gah.
21:47:45 * _Ray_ reads about it. Thanks :)
21:53:22 <adnam> ah, hamlet, nice
21:53:45 <adnam> in my experience you really need a propert template language
21:54:02 <adnam> also view partials
21:54:17 <adnam> not sure if it does that?
22:24:29 <dmwit> ?index ($!)
22:24:30 <lambdabot> Prelude
22:30:45 <dmwit> ?index deepSeq
22:30:45 <lambdabot> bzzt
22:33:34 <c_wraith> @hoogle deepSeq
22:33:35 <lambdabot> No results found
22:33:48 <c_wraith> well.  It's in the deepseq package these days anyway :)
22:34:30 <notyy> hello,I am using eclipseFP,when I input eg System.Dir(click word complete),eclipseFP will complete with Directory, but I then input (getTempt ,and click word complete, it won't complete with "getTemporaryDirectory"?
22:36:03 <c_wraith> well, that's not a prefix of getTemporaryDirectory :)
22:36:24 <c_wraith> But, more usefully, I don't know if anyone here actually uses eclipseFP
22:37:51 <notyy> c_wraith: so what editor do you use?
22:37:51 <Jafet> > "getTempt" `isPrefixOf` "getTemporaryDirectory"
22:37:52 <lambdabot>   False
22:38:11 <c_wraith> notyy: most people use emacs or vi(m)
22:41:44 <notyy> Jafet:ok, I miss typed "getTempt " ,but using,"getTemp" which IS a prefix of getTemporaryDirectory, same result..
23:31:57 <bsrkaditya> In c++, we use lower_bound to get the first element that is greater than or equal to a given element.
23:31:58 <lgm> hello!
23:32:11 <bsrkaditya> Is there a logical eqvivalent to that in haskell?
23:32:32 <lgm> i was wondering if there is a reference for modeling a strong monad, i.e. a monad with a tensorial strength
23:32:53 <bsrkaditya> I am looking for a lower bound to sets.
23:34:05 <blackdog> bsrkaditya: List.find (>=3) [1,2,5,8]
23:34:13 <lgm> my real question is where to host the ambient monoidal structure
23:34:16 <blackdog> returns a Maybe because you might not find one
23:34:17 <dmwit> bsrkaditya: "minimum" for lists
23:34:29 <dmwit> findMin for Sets
23:34:37 <bsrkaditya> thanks!
23:35:09 <bsrkaditya> But findMin finds the minimal element of a set
23:35:20 <dmwit> Yes, I misunderstood the question.
23:36:03 <dmwit> You probably want "split", then.
23:36:16 <bsrkaditya> blackdog: I am looking for a logarithmic performance, hence the use of sets
23:36:51 <blackdog> bsrkaditya: what does 'first' mean in the context of sets?
23:36:56 <dmwit> :t S.findMin . snd . S.split
23:36:56 <lambdabot>     Couldn't match expected type `(a1, S.Set a)'
23:36:57 <lambdabot>            against inferred type `S.Set a2 -> (S.Set a2, S.Set a2)'
23:36:57 <lambdabot>     Probable cause: `S.split' is applied to too few arguments
23:37:19 <dmwit> :t \s -> S.findMin . snd . S.split s
23:37:20 <lambdabot> forall a. (Ord a) => a -> S.Set a -> a
23:38:04 <ddarius> lgm: In the context of Haskell?
23:38:25 <lgm> Haskell will do
23:38:36 <lgm> the main point is where to host the tensorial strength
23:38:38 <ddarius> lgm: I doubt that.  All monads are strong in Haskell.
23:38:49 <ddarius> I have no idea what "host the tensorial strength" means.
23:39:06 <ivanm> wait, is someone running steel cables between monads or something? :/
23:39:09 <bsrkaditya> blackdog: Internally, set is a bst. next means the next element in postorder traversal
23:39:18 <lgm> actually, i meant where to host the monoidal structure
23:39:32 <lgm> the tensorial strength will live on the strong monad api
23:39:33 <ddarius> lgm: What does "host" mean?
23:39:47 <dmwit> bsrkaditya: You don't like "split"?
23:39:50 <ddarius> So where you would put it in an API?
23:39:58 <lgm> expose might be a better word
23:40:09 <lgm> the strength will be a map on a type class
23:40:17 <lgm> but the monoidal structure is not clear
23:40:29 <lgm> the type class might be parametric in the monoidal structure
23:40:38 <bsrkaditya> dmwit: yeah split was what I was looking for! thanks!
23:40:54 * hackagebot synthesizer-core 0.4.1 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.4.1 (HenningThielemann)
23:40:55 <ddarius> You have categories and monoidal categories.  So you would be talking about monoidal categories.
23:41:20 <lgm> a strong monad only makes sense in the context of a monoidal category
23:41:47 <lgm> s : A*T[B] -> T[A*B]
23:41:59 <ivanm> @src foldM
23:41:59 <lambdabot> foldM _ a []     = return a
23:41:59 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
23:42:52 <lgm> where * denotes the monoidal operation of the category
23:45:38 <dmwit> hm
23:45:55 <dmwit> I wonder if some notation like "foldM f _ xs" would be a nice shorthand for "\fax -> foldM f fax xs".
23:46:10 <ddarius> No.  It wouldn't.
23:46:16 <ivanm> dmwit: I can see problems with it
23:46:27 <ivanm> I'd be more tempted with "flip (foldM f) xs"
23:46:33 <dmwit> Would you expect "f a (g _) b" to expand to "f a (\x -> g x) b" or "\x -> f a (g x) b"?
23:47:16 <dmwit> ivanm: Eh. That sort of hides the idea of the thing for me.
23:47:40 <ddarius> You know what is a nice notation for these types of situations... lambda.
23:47:57 <ivanm> ddarius: really? care to give us an example?
23:47:58 <dmwit> ivanm: Compare "f a _ b c d" with "flip (flip (flip (f a) b) c) d".
23:48:09 <ivanm> dmwit: right, in that case it's fugly
23:48:51 <ivanm> I have something using mapM_, but then realised that I need to have some kind of values be passed around...
23:49:17 <ivanm> now, the smart thing would be to have those values be part of the State along with the Map that it contains, but that would just make the current modify operations uglier :p
23:49:33 <dmwit> Local StateT. ;-)
23:49:56 <ivanm> dmwit: yeah, StateT on State probably isn't worth it... ;-)
23:50:11 * ivanm grumbles and goes off and makes the state value be a pair
