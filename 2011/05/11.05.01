00:06:31 * edwardk2 looks up
00:07:02 <ddarius> Word of the Day: crepuscular
00:09:00 <edwardk2> ddarius: so, what is the future like?
00:09:57 <ddarius> A lot like the past.
00:15:38 <tolkad> If you are an employee doing software engineering work in the US, and you write code on your own time at home, can the company claim to own it?
00:16:11 <edwardk2> tolkad: depends on the company, and the legal ground is fairly shaky. some companies, like microsoft put it in the hiring agreement
00:16:43 <edwardk2> tolkad: others explicitly limit such to work you do directly in their field, others explicily don't care, etc.
00:17:19 <ddarius> If you are doing stuff unrelated to you employers work and haven't signed something otherwise, you'd be hard pressed to get into trouble.
00:18:19 <edwardk2> i've taken a lot of black ink to one-sided intellectual property agreements over the years.
00:18:25 <tolkad> So people who work at microsoft can't contribute to open source?
00:18:56 <edwardk2> they would have to get special dispensation
00:19:06 <tolkad> That's pretty evil
00:19:10 <edwardk2> but the general microsoft intellectual property agreement is pretty hideous
00:19:13 <dobblego> when I was at IBM I had to jump through hoops to do open source
00:19:41 <dmwit> Is there a way to export the function version of a constructor but not its pattern version, or do I have to make up a new name for the function version and export that?
00:20:02 <ddarius> dmwit: The latter.
00:20:04 <dobblego> dmwit: the latter
00:20:12 <tolkad> reminds me of the war on sharing: http://stallman.org/articles/end-war-on-sharing.html
00:20:21 <edwardk2> dmwit: the latter
00:20:46 <dmwit> Sad, but good to know.
00:20:48 <shachaf> I think that at least in some states, even if you have signed something otherwise your company doesn't own it, as long as it's unrelated and in your spare time.
00:21:13 * shachaf notes that #haskell INAL.
00:21:14 <dmwit> Maybe not that sad, actually.
00:21:16 <edwardk2> yeah but it varies from state to state. i have a good intellectual property lawyer that i keep in touch with to deal with such issues
00:22:13 <tolkad> http://www.gnu.org/philosophy/not-ipr.html
00:22:27 <tolkad> Intellectual property is crimethink
00:25:18 <nyingen> this iteratee stuff is pretty interesting
00:26:35 <tolkad> dobblego: really? I didn't know IBM was against free software
00:26:51 <dobblego> very much so
00:27:53 <tolkad> Huh, I don't think it's ethical to work for companies that attack free software
00:34:18 <edwardk2> My general rule of thumb is to just factor in the opportunity cost. How much is it worth to me to step out of the open source community for a given time period? Then I set my rates accordingly, and if they can't meet them, then we work out something else. I think I've worked for companies that hit pretty much every point possible in the spectrum of how they deal with workers' intellectual property.
00:35:06 <tolkad> The term "intellectual property" is bad: http://www.gnu.org/philosophy/not-ipr.html
00:35:08 <edwardk2> It isn't so much that they are attacking open source as they either don't understand it or have a legal department mired in the 80s.
00:35:43 <edwardk2> sure. i get that, but if i don't use the correct term when negotiating, they have no idea what I'm talking about ;)
00:36:51 <ddarius> Which decade should legal departments be mired in?
00:37:44 <tolkad> Companies should have legal departments that help ensure their behavior is ethical
00:38:33 <dmwit> I've begun to think that maybe the law isn't a good indicator of ethical behavior.
00:38:59 <tolkad> dmwit: Exactly, the best you can hope for is that they will have a defensive rather than offensive legal department
01:03:55 <k0ral> hi, I'm looking for gtk2hs documentation and http://haskell.org/gtk2hs/ is dead; where can I find it ?
01:07:15 <siracusa> @hackage gtk
01:07:16 <lambdabot> http://hackage.haskell.org/package/gtk
01:07:46 <siracusa> k0ral: ^ Library documentation at least
01:08:57 <k0ral> thank you !
01:09:24 <lars9> > print 1
01:09:26 <lambdabot>   <IO ()>
01:09:35 <lars9> >fmap print (Just 1)
01:09:43 <lars9> > fmap print (Just 1)
01:09:44 <lambdabot>   Just <IO ()>
01:10:52 <Nereid> oh, it's just called gtk now
01:10:53 <Nereid> not gtk2hs
01:10:53 <Nereid> D:
01:11:08 <Nereid> that explains a thing or two.
01:11:46 <lars9> > typeOf ('c')
01:11:47 <lambdabot>   Char
01:11:50 <k0ral> haskellwiki has to be updated then
01:15:37 <lars9> > let sameType a b = typeOf a == typeOf b in sameType 1 'c'
01:15:38 <lambdabot>   False
01:15:42 <lars9> > let sameType a b = typeOf a == typeOf b in sameType 1 2
01:15:43 <lambdabot>   True
01:16:26 <lars9> in what situation will Typeable be used?
01:17:00 <shachaf> Presumably situations involving keyboards.
01:17:13 <Nereid> lol
01:17:37 <dmwit> Nereid: Well, the library is still called gtk2hs, but the package is called gtk.
01:17:58 <Nereid> how confusing.
01:18:44 <dmwit> gtk2hs includes several packages: cairo, gconf, gio, glade, glib, gnomevfs, gstreamer, gtk, gtkglext, gtksourceview2, mozembed, pango, soegtk, sourceview, svgcairo, vte, webkit
01:18:55 <dmwit> So... it may be even more confusing than you thought. =)
01:19:52 <Nereid> oh, so the package that was formerly "gtk2hs" got split up into a bunch of these?
01:19:56 <dmwit> Perhaps there ought to be a gtk2hs meta-package that depends on all of them.
01:20:39 <dmwit> Err, I'm not too sure there ever was a "gtk2hs" package.
01:20:43 <dmwit> Was there?
01:21:11 <Nereid> my package manager lists a package called gtk2hs
01:21:24 <dmwit> huh
01:21:30 <dmwit> Well, that settles it, then. =)
01:24:40 <dmwit> Writing code that's obviously total, obviously terminating, and obviously correct is kind of tricky!
01:24:58 <dmwit> Even the first two are hard.
01:29:28 <shachaf> dmwit: Code that also *actually* has all of those properties is even trickier.
01:30:36 <dmwit> :t insertBy
01:30:37 <lambdabot> forall a. (a -> a -> Ordering) -> a -> [a] -> [a]
01:37:33 <Rc43> clear
02:05:35 <lars9> windows :: (WindowSet -> WindowSet) -> X ()
02:06:04 <ndxtg> http://codepad.org/6Kmms0td <---- I'm new to Haskell and I don't understand why it has that error: "Multiple declarations for data constructor Empty"
02:06:36 <ndxtg> anyone help would be appreciated. thanks in advanced :)
02:07:03 <lars9> ndxtg: you have 2 Emptys
02:07:28 <lars9> ndxtg: all data constructors in the same module share the same naming space
02:07:30 <shachaf> ndxtg: Empty etc. is not specific to Example1/Example2.
02:07:55 <ndxtg> ???.....
02:08:03 <Nereid> ndxtg: when you define Example1
02:08:11 <Nereid> it defines some objects
02:08:15 <Nereid> such as Empty :: Example1
02:08:18 <k0ral> @haskage webkit
02:08:18 <lambdabot> http://hackage.haskell.org/package/webkit
02:08:33 <Nereid> Join :: [Int] -> Example1
02:08:33 <Nereid> now, when you go and define Example2
02:08:36 <Nereid> it tries to define Empty :: Example2
02:08:42 <Nereid> but there's already a different Empy
02:08:43 <Nereid> Empty*
02:09:03 <Nereid> you can't give the same name to two different things.
02:09:09 <k0ral> hmmm webkit API isn't documented ?
02:09:33 <Nereid> k0ral: hackage hasn't built the documentation for it, that's all
02:09:49 <shachaf> > let x = 5 in (\x y -> (x,y)) 6 x
02:09:50 <lambdabot>   (6,5)
02:10:08 <Nereid> k0ral: if you like, you can go grab the webkit source, cabal configure, and cabal haddock
02:10:08 <Nereid> then it will build the documentation for you
02:10:13 <Nereid> > let x = 5 in (,) 6 x
02:10:14 <lambdabot>   (6,5)
02:10:36 <ciphergoth> OK, Parsec is a big advert for Haskell all on its own!
02:10:45 <ndxtg> (oh I see... so in Haskell it goes in reversed way... thank you guys)
02:10:55 <Nereid> reversed from what? D:
02:11:12 <shachaf> Nereid: From the reverse of Haskell.
02:11:17 <k0ral> Nereid: fair enough
02:11:43 <Nereid> ndxtg: in other words, the constructors for Example1 and Example2 live in the same namespace.
02:11:56 <Nereid> so you have to give them different names.
02:12:01 <ciphergoth> What do people recommend for text templating?  IE I want to serialize a data structure into a text document (actually code generation), in Python I'd use genshi
02:13:27 <shachaf> ciphergoth: Look on Hackage.
02:13:31 <Nereid> poke around hackage and you'll find things like http://hackage.haskell.org/package/Interpolation
02:13:31 <shachaf> Maybe under "Text".
02:13:53 <Nereid> or
02:13:53 <Nereid> many others
02:25:28 <k0ral> Nereid: it fails to generate the doc
02:25:50 <k0ral> Nereid: posting error in hpaste
02:26:57 <k0ral> http://hpaste.org/46209/webkit_documentation_generatio
02:27:33 <Nereid> perhaps you don't have something needed to build it?
02:27:46 <Nereid> in any case, I'll go ahead and put my copy of the documentation somewhere
02:28:02 <Nereid> (have to install it first...)
02:29:16 <k0ral> well, if I could know what is missing, you wouldn't have to bother
02:30:14 <Nereid> too late ;)
02:30:22 <Nereid> http://ner.mine.nu/~adrian/webkit-0.12.1-doc.tar.gz
02:32:11 <k0ral> too kind :)
02:32:22 <k0ral> thank you very much
02:32:47 <Nereid> except I'm going to bed now, so I won't be able to give you other documentations
02:32:48 <Nereid> oh well
02:33:04 <Nereid> good night
02:33:19 <k0ral> good night, it's midday where I live ;)
02:35:59 <Cale> http://img263.imageshack.us/img263/6985/711b24812ec1513c7af6bda.gif
02:40:39 <Eduard_Munteanu> Cale: wow, what's that? A CD?
02:41:45 <Phyx-> well that's one use for a cd
02:42:16 <Botje> it puts the "fun" back into "data destruction", that's for sure :)
02:42:33 <Phyx-> was the cd spinning? i can't tell
02:42:34 <Cale> yeah
02:42:42 <shachaf> > isInfixOf "fun" "data destruction"
02:42:43 <lambdabot>   False
02:42:49 <shachaf> I suppose that's why you need to put it back.
02:44:00 <Cale> looks like it is
02:44:37 <Cale> http://www.youtube.com/watch?v=Ho8xLhpx99c moar
02:45:05 * Phyx- needs some benchmarks
02:45:42 <Cale> http://www.youtube.com/watch?v=Zi_bMYFmFGg&feature=relmfu -- oh, and the video that the gif was made from, apparently :)
02:46:41 <Phyx-> lol, wtf, caught fire
02:47:11 <Phyx-> microwave is still fastest if cops are knocking on your door
02:48:41 <ivan> forgetting the encryption keys is even faster
02:49:35 <Zao> ivan: I'm sure that that's punishable in some jurisdictions.
02:50:17 <ivan> haha
02:52:12 <Rc43> Guys, what should I do to get ability to use "read string" for parsing my own data type?
02:52:18 <dschoepe> ivan: Unfortunately, that's even true in the UK, where you can get up to five years for not disclosing a password (don't know in which situations that law applies though)
02:52:32 <Rc43> Deriving Read is a little strange.
02:53:40 <ivan> dschoepe: here in the US you can be in jail forever for contempt of court (they think you're lying)
02:53:48 <shachaf> Rc43: If what deriving Read comes up with isn't satisfactory, you can make your own instance of Read.
02:55:27 <Rc43> shachaf, sry, i have talken about instance
02:56:02 <Phyx-> ivan: that's why you need to have a hidden encrypted volume inside your encrypted volume
02:56:21 <Phyx-> encryption all the way down!
02:57:24 <ivan> if you perform network operations with data in your hidden volume, it may be easy to discover that you have more data
02:57:38 <dschoepe> Phyx-: Is there a convenient way to do that under GNU/Linux?
02:58:09 <dschoepe> (where convenient means something at least as unobtrusive as truecrypt's way of doing that for windows)
02:58:15 <Phyx-> dschoepe: truecrypt runs on linux too doesn't it?
02:58:19 <Phyx-> ah
02:58:40 <dschoepe> I think it works for individual volumes
02:58:48 <dschoepe> (that hidden volume thing)
02:58:53 <dschoepe> but not for the entire system
02:58:54 <Rc43> shachaf, it demands implementation of readsPrec, but i havent understood, what it is.
02:59:03 <Rc43> :t readsPrec
02:59:04 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
02:59:47 <dschoepe> So it's a little annoying having to resize volumes all the time and having to decide all the time which data you want in there
02:59:48 <Phyx-> dschoepe: no, truecrypt supports whole drive encryption, including the one containing the os
03:00:06 <Rc43> but in ghci
03:00:08 <Phyx-> it has pre-boot authentication
03:00:10 <dschoepe> Phyx-: Under Linux?
03:00:20 <dschoepe> I thought they only supported that for Windows
03:00:27 <Rc43> readsPrec :: Read a => Int -> ReadS a
03:01:29 <Phyx-> dschoepe: the pre-boot encryption looks to be windows only, but not the whole disc encryption
03:02:01 <Phyx-> they don't seem to have a "features" page
03:02:07 <Rc43> Is readsPrec something like lex?
03:02:43 <shachaf> @google haskell dr seuss
03:02:44 <lambdabot> http://www.willamette.edu/~fruehr/haskell/seuss.html
03:02:44 <lambdabot> Title: Dr. Seuss on Parser Monads
03:04:35 <Rc43> Why " readsPrec num "123casd123" :: [(Int,String)] " always returns [(123,"casd123")] ignoring num?
03:04:38 <Phyx-> dschoepe: i'm not really sure, the documentation reads as if they're just using windows as an example. they don't state anywhere "this is a windows only feature" or something
03:04:54 <Rc43> I mean, it is the same result always.
03:05:22 <dschoepe> Phyx-: Yes, I guess it would at least work to use a hidden volume inside a truecrypt'ed partition for /home
03:05:59 <Zao> Protip - do not lose the password for truecrypt containers.
03:06:08 <Zao> It's very very sad when your master thesis lives inside one.
03:07:02 <Phyx-> :O
03:07:22 <Phyx-> ouch.. that's gotta hurt
03:07:55 <Zao> Well, the thesis itself wasn't that horribly well-endowed, but the assets around it would have been rather useful to have.
03:08:01 <shachaf> Rc43: It would be bad if it *wasn't* the same result always.
03:08:26 <shachaf> Rc43: It parses an Int and gives you the remainder of the string.
03:09:08 <Rc43> shachaf, but whats the first Int argument ?
03:11:55 <Rc43> *Main> quickCheck (\t -> (==) 1 $ length (readsPrec t "123asd" :: [(Int,String)]))
03:11:57 <Rc43> +++ OK, passed 100 tests.
03:12:17 <Rc43> Why everytime size is 1?
03:17:49 <jaj> Rc43: I guess it can return multiple results if the parsing is ambiguous
03:19:33 <Rc43> jaj, how?
03:19:57 <Rc43> jaj, list can contain elements of same type only.
03:20:45 <jaj> I don't know
03:21:12 <Eduard_Munteanu> Is B Method any good? Anywhere else I should start?
03:21:29 <Eduard_Munteanu> I'm interested in refinement.
03:22:45 <jaj> There is a function that is defined in Network.Cgi.Protocol which would be very nice in Text.Read: maybeRead = fmap fst . listToMaybe . reads
03:26:00 <siracusa> > readsPrec 10 "Just 1" :: [(Maybe Int, String)]
03:26:00 <lambdabot>   [(Just 1,"")]
03:26:03 <siracusa> > readsPrec 11 "Just 1" :: [(Maybe Int, String)]
03:26:04 <lambdabot>   []
03:27:00 <jaj> @let maybeRead = fmap fst . listToMaybe . reads
03:27:01 <lambdabot>  <local>:11:0:
03:27:01 <lambdabot>      Multiple declarations of `L.maybeRead'
03:27:01 <lambdabot>      Declared at: ...
03:27:38 <jaj> > (maybeRead "123") :: (Maybe Int)
03:27:40 <lambdabot>   Just 123
03:27:49 <jaj> > (maybeRead "stuff") :: (Maybe Int)
03:27:50 <lambdabot>   Nothing
03:27:52 <Eduard_Munteanu> Hrm, or anyway does this sort of stuff even use Curry-Howard? I'm curious how non-CHI stuff compares.
03:29:19 <Rc43> siracusa, i have seen in sources of prelude magic numbers 10 and 5 (about your 10 and 11). But i cannot understand why it is done so.
03:29:29 <Rc43> Why 10? Why 11? Why 5?
03:30:01 <siracusa> Rc43: 10 is function application precedence, below 10 are for other operators like + or *
03:31:21 <Rc43> siracusa, so why readsPrec 11 returns []?
03:31:49 <ciphergoth> hmm, not sure I want to use Data.String.Interpolation
03:32:31 <Nereid> I didn't really look at it
03:32:37 <ciphergoth> think what I really want to do is something like (this x) ++ " + " ++ (that y) except without the quadratic slowdown
03:32:44 <Rc43> siracusa, and why readsPrec :: Int -> String -> [(a,String)] but not Maybe (a,String)? For saving purity?
03:32:48 <siracusa> Rc43: Because it tries to read in the context of precedence 11 which is stronger than 10. So Just 1 must be enclosed in parentheses to parse successful in that context.
03:32:49 <Nereid> just look at all the various packages in the Text category
03:32:49 <Nereid> that have "template" in the description or something
03:32:53 <Nereid> there might be something better
03:32:57 <siracusa> > readsPrec 11 "(Just 1)" :: [(Maybe Int, String)]
03:32:58 <lambdabot>   [(Just 1,"")]
03:33:15 <Rc43> siracusa, ok, understood, thanks
03:33:25 <ciphergoth> Nereid: I wonder if it's more complexity than I need - I can get the result I want just fine with ++, I just know that ++ is rarely the right way to do things
03:33:59 <siracusa> Rc43: List as result type as the parsing can yield several results, which is very rarely the case, tough.
03:34:21 <jaj> siracusa: can you think of an example where it would be the case?
03:34:34 <Nereid> ciphergoth: ++ isn't quadratic time, I thought
03:34:53 <siracusa> jaj: Actually, no :-)
03:34:59 <Nereid> if you use it on many things
03:38:21 <shachaf> Nereid: "isn't quadratic time" /= "usually the right way to do things"
03:38:49 <Nereid> well he's talking about quadratic slowdown
03:39:01 <Nereid> concatenating a bunch of strings with ++ is linear time
03:39:05 <ciphergoth> Nereid: it's linear time, but if I use it just wrong I can get a quadratic slowdown
03:39:07 <Nereid> in the total string length
03:39:12 <Nereid> well, don't use it wrong
03:39:26 <ciphergoth> Nereid: that's the plan
03:39:44 <Nereid> (++) associates to the right
03:40:02 <Nereid> which is the faster one
03:40:02 <Nereid> if it was left, then it would indeed be quadratic.
03:40:08 <ciphergoth> but I think if I have a bunch of pattern matches that go serializationFoo (Foo a b) = (serializationBar a) ++ " + " ++ (serializationBaz b) it'll be very slow
03:40:31 <Nereid> why?
03:40:47 <Nereid> ah.
03:41:12 <Nereid> I'm not sure how you'd get around that.
03:41:40 <ciphergoth> it's worst case is something like (num chars) * (depth of tree), which is worst case quadratic
03:41:48 <Nereid> right.
03:42:30 <siracusa> Nereid: Use the functions from Text.Show instead
03:42:31 <ciphergoth> well ISTR a technique by which serializationBar takes a suffix as well as a thing to serialize
03:42:55 <ciphergoth> and it appends that suffix to its serialization
03:43:17 <neural> morning.
03:43:29 <ciphergoth> so you build up the string in one motion, without explicit ++ calls
03:44:06 <Nereid> ciphergoth: here's the clever thing.
03:44:20 <shachaf> Data.DList would do that for you, I think.
03:44:24 <Nereid> say we had a worst-case thing.
03:44:25 <Nereid> like
03:44:28 <ciphergoth> aha, yes, Text.Show appears to be what I'm talking about
03:44:35 <Nereid> yes, difference lists do it
03:44:43 <Nereid> > foldl (++) [] (take 100000 $ repeat [()])
03:44:44 <Nereid> very slow
03:44:46 <lambdabot>   mueval-core: Time limit exceeded
03:45:04 <Nereid> but, we do something clever.
03:45:14 <Nereid> > foldl (.) id (take 100000 $ repeat ([()] ++)) $ []
03:45:16 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
03:45:35 <Nereid> magically faster!
03:45:35 <Nereid> that's basically what difference lists do.
03:46:00 <Nereid> ciphergoth: :>
03:46:16 <Nereid> Data.DList gives that a nice interface.
03:47:25 <Nereid> the idea is that function composition is constant time
03:47:40 <Nereid> so if you're composing a bunch of functions together
03:47:40 <Nereid> it only matters how many there are
03:47:40 <Nereid> not what order you compose them in
03:48:15 <Nereid> (I thought this was pretty amazing the first time I saw it.)
03:49:00 <Nereid> I guess another way to see it is
03:49:24 <Nereid> the difference list reorders how the strings are concatenated
03:50:42 <Nereid> or something
03:52:40 <Nereid> ciphergoth: hey 3:
03:52:50 <ciphergoth> thanks
03:52:53 <Nereid> :>
03:53:32 <ciphergoth> sorry my UI has started playing up in a weird way, I can't scroll back!
03:53:36 <Nereid> aww
03:53:48 <ciphergoth> but yeah, looks like either Data.DList or Text.Show is the way to go
03:54:12 <Nereid> http://hpaste.org/46211/irc
03:54:16 <ciphergoth> I can't select other windows either!
03:54:28 <Nereid> is what you may have missed
03:54:31 <Nereid> oh dear!
03:54:48 <Nereid> time to restart that window system
03:55:04 <Nereid> or whatever
03:56:16 <ciphergoth> OK got to log out and back in again AGAIN, see you all!
04:01:09 <Nereid> ciphergoth: here's that text, in case you still wanted it
04:01:10 <Nereid> http://hpaste.org/46211/irc
04:02:49 <ciphergoth> thanks
04:12:13 <vishu> hello everyone
04:13:01 <Phyx-> hello
04:13:52 <vishu> how long would it take to learn haskell if you are new to functiona programming?
04:14:00 <vishu> *functional
04:14:25 <neural> vishu: read: learn yourself a haskell for great good
04:14:28 <Nereid> you never stop learning haskell ;)
04:14:30 <neural> and find out
04:14:34 <Nereid> but yes, start with something like that
04:14:39 <Nereid> @lyah
04:14:39 <lambdabot> Unknown command, try @list
04:14:41 <Nereid> oh.
04:14:58 <Nereid> well what's it
04:15:01 <neural> vishu: or the NLPWP book, if you're into NLP and Haskell ;-)
04:15:28 <rostayob> also, programming in haskell
04:15:34 <Nereid> and RWH
04:15:40 <Nereid> there are tons of resources out there
04:15:47 <neural> I wouldn't start with RWH.
04:15:54 <vishu> :D Thats alot!!!
04:15:54 <neural> I find LYAH more accessible.
04:16:08 <neural> also, the NLPWP book isn't done yet.
04:16:28 <rostayob> yeah probably lyah is the best, programming in haskell is really nice as well
04:16:39 * tyler-iphone has the print edition of LYAH its so cute
04:16:55 <neural> Yeah, it looks good!
04:17:06 <neural> Funny pictures as well!
04:17:21 <tyler-iphone> i was dissapointed they weren't in colour
04:17:46 <neural> that would have tripled the printing costs.
04:18:02 <tyler-iphone> good point
04:18:13 <vishu> guys i v'e got to start a mini project by 30th wondering if i can learn enough to start it
04:18:25 <rostayob> vishu: define mini project
04:18:31 <vishu> 30th june
04:18:35 <tyler-iphone> define 'started' ;)
04:18:51 <vishu> rostayob: i will post that to my HOD
04:19:22 <vishu> they just said you need to submit your mini project proposals by that date:D
04:19:26 <rostayob> vishu: what's a HOD?
04:19:47 <vishu> Head of Department,cse our department
04:19:53 <rostayob> ah, ok ehe
04:20:01 <vishu> ehuehueheu
04:20:13 <tyler-iphone> do you need any code for your proposal?
04:20:32 <vishu> nope an idea is welcome
04:21:02 <rostayob> it depends, i don't you won't be able to use haskell fully in two months -- all the monadic stuff. but if it's a small think maybe you don't need that (:
04:21:08 <tyler-iphone> dangit, upgraded to ubuntu 11.04 and now my adhoc router won't route bit torrent :(
04:21:12 <rostayob> *I don't think you will be able to...
04:21:32 <rostayob> but you should definitely read lyah :D
04:22:06 <vishu> ah did started it once then exams came and i am beginning from stone age again
04:22:18 <isomorphic> Hey - I'm trying to traverse a tree, but I am getting some unexpected output - see http://hpaste.org/46213
04:22:46 <isomorphic> the code gives me [0,0,0,0,0] when run
04:22:57 <isomorphic> what I expect is the length of each prefix
04:23:02 <isomorphic> (pr)
04:23:08 <isomorphic> any ideas?
04:24:42 <koeien> you never call traverse with any value other than 0
04:25:39 <Phyx-> isomorphic: why is it unexpected? pr is never modified so it's length is always 0
04:26:25 <isomorphic> ah - yes, I think I see :P
04:28:04 <isomorphic> traverse pr (Node ((p,t):xs)) = (traverse (prefix p) t) ++ (traverse pr (Node xs))
04:28:26 <isomorphic> thank you koeien + phyx :)
04:40:16 <ndxtg> numberCFG :: Int -> [CFGNode] -> [(Int, CFGNode)] <------ is there a way to change this constructor so that it accepts any input data type and automatically process according to that type instead of only CFGNode ?
04:40:55 <aristid> is there a parser combinator library that is not greedy by default?
04:49:13 <vishu> bye
04:51:59 <Feuerbach> aristid: I thought greediness is a property of particular combinators rather than a library. Can you provide an example of what you want?
04:54:18 <rostayob> is there a library (probably it'll be an interface to bytestring) that lets you handle a vector of bits? so you can consume it by doing "take n vector" where n is the number of bits?
04:55:10 <aristid> Feuerbach: well, the combinators provided by parsec seem to be greedy by default :)
04:56:02 <Feuerbach> aristid: what's an example of non-greedy combinator that you'd like to have?
04:56:41 <aristid> Feuerbach: i know it can be solved with parsec. this is about convenience
04:56:57 <aristid> and no, i don't have a concrete example
04:59:09 <Feuerbach> aristid: I think a library with non-greedy semantics would have much worse performance and error reporting (you would need much more backtracking)
04:59:50 <Feuerbach> I also am not sure if you can implement such semantics using executable combinators
05:00:47 <aristid> Feuerbach: well, parsec has try
05:00:50 <Feuerbach> if I understand you correctly, you'd like e.g. "aafaa" to be parsed using (many anyChar; char 'f'; many anyChar), right?
05:02:46 <aristid> no
05:03:19 <jkff> Hi. I wonder whether there are some "generalizations" (or perhaps "specializations") of monads/arrows that allow for purely symbolic manipulation of stuff, e.g. so that I could write a program in a monadic DSL and have the result be a purely symbolic term, without opaque functions
05:04:03 <jkff> I'd imagine this would have (>>=) :: Reprn a -> Reprn (a -> Reprn b) -> Reprn b or something
05:04:06 <jkff> with Reprn a fancy GADT
05:04:37 <jkff> Or is this what HOAS is for?
05:05:11 * hackagebot zeromq-haskell 0.6.0 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.6.0 (ToralfWittner)
05:06:04 <Feuerbach> jkff: perhaps you're looking for free monads? http://www.haskell.org/haskellwiki/Free_structure#Free_Monads
05:08:38 <jkff> Feuerbach: Looks quite strange, but I'll look into it... Found also this http://comonad.com/reader/2008/monads-for-free/
05:13:35 <ndxtg> is there a function that update a list given an index and input data? something like Int -> a -> [a] -> [a] ?
05:14:36 <Feuerbach> jkff: or do you need to get your hands on the functions that your users use in >>=? than yes, you'd need something like HOAS
05:15:01 <jkff> Feuerbach: Yes, that's what I'd like to do. Do we really need HOAS for that?
05:15:22 <jkff> I mean, why wouldn't we just use something else instead of "->" in the "a -> m b" part?
05:15:38 <jkff> I hoped for arrows, but turned out they require "pure :: (a -> b) -> f a b" :(
05:15:54 <Feuerbach> jkff: but you want to use do-notation, don't you?
05:16:18 <Feuerbach> otherwise your DSL would look a bit creepy :)
05:16:20 <jkff> Feuerbach: I'd like to, but I understand that's probably impossible :) I'm just wondering out of curiosity, whether there are existing formalisms or experiments for that.
05:16:50 <jkff> Like, I'd expect that stuff like the LLVM or various GPU bindings would be built like that, but they aren't...
05:17:07 <Feuerbach> jkff: why do you fear HOAS? We use it in our DSL without much problems
05:17:22 <jkff> Feuerbach: I don't fear, I'm just not well aware enough of its merits
05:17:46 <jkff> Oh I understand: probably it makes sense to define a monad not such that a value of type "m a" *is* a term, but that it *produces* a term.
05:18:02 <jkff> How could I not have thought of it before?
05:18:04 <Feuerbach> hm, it depends on your needs
05:18:23 <Feuerbach> in some sense it's deep vs shallow distinction
05:18:47 <neural> blegh, I hate working in the weekends :|
05:19:04 <neural> just wanted to share that with all of you!
05:20:00 <Feuerbach> also, I wonder, if you're going to replace -> with something else, how are you going to write your functions?
05:20:38 <jkff> Feuerbach: well, I'd be combining them from other primitives of my "language"
05:21:09 <Feuerbach> ah, that's fine
05:21:37 <jkff> I think I should just give that approach a try :) (then one where m a *computes* a term of type a)
05:21:57 <Feuerbach> what kind of monad do you need? (and what for?)
05:24:14 <joe6> just came across this link: http://comonad.com/reader/2009/recursion-schemes/ and i am curious on why these recursion schemes are not used more often. Instead of writing recursive functions, why are these recursive functions not used more often?
05:28:07 <joe6> edwardk, are you the author of http://comonad.com/reader/2009/recursion-schemes/
05:28:40 <Feuerbach> joe6: they are used widely. Their drawback is that they require "unfixing" the recursive datatype, and that becomes ugly once you have mutual type recursion
05:29:03 <Feuerbach> so it's not always worth the effort
05:31:26 <Phelps> Hey guys, I'm looking to learn a new language, for fun, I already know PHP quite well, and I know Perl and some Python, with a dash of C/C++
05:31:39 <Phelps> would you recommend Haskell for someone like me
05:31:59 <neural> Phelps: sure, or Prolog!
05:32:03 <sipa> Phelps: haskell is a very nice language, but it will be very different from what you know
05:32:13 <Phelps> different is good!
05:32:13 <hpc> @quote prolog
05:32:14 <lambdabot> edwardk says: oleg doesn't write haskell. he writes prolog. he just happens to write it at the haskell type level.
05:32:18 <hpc> hehe
05:32:27 <neural> lol
05:32:33 <neural> nice!
05:32:41 <sipa> @where lyah
05:32:42 <lambdabot> http://www.learnyouahaskell.com/
05:32:48 <sipa> Phelps: start by reading that ^
05:33:45 <jkff> Phelps: Your knowledge of Python will be helpful. If you know perl well, you might give a try to the book "Higher-order Perl" concurrently to learning Haskell.
05:34:08 <jkff> In any case, you're not gonna program in the same way as before, after you learn some of Haskell :)
05:34:29 <sipa> if you're familiar with perl things like grep, map, sort, ..., and/or closures, that may help
05:34:30 <parcs> i'm finding it difficult to grasp the significance of rank-2 types: how is (forall s. ST s a) -> a different from just ST s a -> a?
05:34:57 <sipa> parcs: it differs in that the caller of such a function does not know what s is
05:35:19 <parcs> ah, that makes sense
05:35:28 <sipa> that is, when you call such a function, it will have to work for *every* s, not just one known s
05:35:59 <parcs> i see
05:36:10 <jkff> parcs: what sipa says, and also given two values of type "forall s . ST s a", you cannot tell (or convince the compiler) that their "s" type is the same
05:36:11 <parcs> in hindsight, that seems obvious now!
05:36:16 <jkff> That is the key to how the ST monad works
05:36:21 <sipa> indeed
05:36:36 <jkff> That is how this allows to enforce isolation of ST-related effects.
05:37:22 <parcs> thanks
05:37:40 <jkff> Within a single ST computation the type "s" is the same, but a part of it cannot leak out, because it'll have this abstract type and you'll not be able to do anything with it anyways. I'm speaking abstractly, better look at the source or the paper.
05:39:15 <hpc> i think you can unsafeCoerce it
05:39:23 <sipa> you can
05:39:36 <hpc> but there be dragons that way
05:39:41 <sipa> there is no s at all at the value level
05:39:56 <sipa> it's just there in the type level to prevent you from doing dangerous things
05:39:58 <hpc> @src ST
05:39:58 <lambdabot> newtype ST s a = ST (STRep s a)
05:40:07 <hpc> @src STRep
05:40:08 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
05:40:15 <hpc> eek
05:40:18 <sipa> hmmm
05:40:29 * sipa isn't sure anymore
05:41:28 <parcs> @type undefined :: (() -> (forall a. a))
05:41:29 <lambdabot> forall a. () -> a
05:42:31 <hpc> :t undefined :: ((forall a. a) -> ())
05:42:32 <lambdabot> (forall a. a) -> ()
05:42:50 <hpc> heh, so the existential has to be on the "left"
05:43:00 <hpc> :t undefined :: ((forall a. a) -> a)
05:43:01 <lambdabot> forall a. (forall a1. a1) -> a
05:43:13 <hpc> :t undefined :: (a -> (forall a. a))
05:43:14 <lambdabot> forall a a1. a -> a1
05:47:51 <parcs> :t undefined :: (Int, forall a. a) -> Int
05:47:52 <lambdabot>     Illegal polymorphic or qualified type: forall a. a
05:47:52 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
05:47:52 <lambdabot>     In an expression type signature: (Int, forall a. a) -> Int
05:48:04 <parcs> uh oh
05:48:16 * hackagebot http-enumerator 0.6.2 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.2 (MichaelSnoyman)
05:48:19 * hackagebot persistent-template 0.5.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.5.0.1 (MichaelSnoyman)
05:51:14 <roconnor> > compare [[],[],[]] [[[]]]
05:51:15 <lambdabot>   LT
05:52:03 <roconnor> > compare [[[]],[[]],[[]]] [[[],[],[]]]
05:52:04 <lambdabot>   LT
05:53:37 <fosskers> hey guys
05:53:53 <fosskers> im having a type problem
05:54:31 <fosskers> foo n = [1..sqrt n]
05:54:46 <fosskers> but i want that list to all be Ints, not floats
05:55:05 <aristid> :t sqrt
05:55:06 <lambdabot> forall a. (Floating a) => a -> a
05:55:09 <azaq23> sqrt always returns floats
05:55:13 <fosskers> im aware
05:55:17 <aristid> fosskers: do you want to round the sqrt up or down?
05:55:22 <fosskers> up
05:55:26 <aristid> :t ceil
05:55:27 <Jonno_FTW> > [1..sqrt 10]
05:55:27 <lambdabot> Not in scope: `ceil'
05:55:28 <lambdabot>   [1.0,2.0,3.0]
05:55:35 <aristid> @hoogle ceil
05:55:36 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
05:55:49 <fosskers> i want them to be straight Ints, but yeah
05:55:51 <aristid> :t \n -> [1 .. ceiling (sqrt n)]
05:55:51 <fosskers> :t ceil
05:55:52 <lambdabot> forall t a. (Integral t, Floating a, RealFrac a) => a -> [t]
05:55:52 <lambdabot> Not in scope: `ceil'
05:55:54 <Jonno_FTW> > map toInteger [1..sqrt 10]
05:55:55 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:55:55 <lambdabot>    `GHC.Float.Floating a'
05:55:55 <lambdabot>  ...
05:56:08 <fosskers> ceiling returns some funky ass RealFrac business
05:56:15 <aristid> no it doesn't
05:56:18 <aristid> it returns Integral
05:56:19 <fosskers> it doesnt?
05:56:22 <koeien> > [1.. ceil (sqrt 37)]
05:56:23 <lambdabot>   Not in scope: `ceil'
05:56:24 <aristid> Int is an Integral
05:56:28 <fosskers> yeah
05:56:29 <koeien> > [1.. ceiling (sqrt 37)]
05:56:30 <lambdabot>   [1,2,3,4,5,6,7]
05:57:07 <koeien> this might go wrong for large values of n, I'd wager
05:57:13 <fosskers> this doesn't seem to want to work
05:57:14 <fosskers> getDivs n = [x | x <- [1..root], n `mod` x == 0] where root = ceiling (sqrt n)
05:57:31 <fosskers> i was also getting confused about lets and wheres when it comes to list comprehensions
05:57:51 <Jonno_FTW> fosskers: n/x is also a divisor
05:58:58 <parcs> @type let getDivs n = let root = ceiling (sqrt n) in [ x | x <- [1..root], n `mod` x == 0 ] in getDivs
05:58:59 <lambdabot> forall a. (RealFrac a, Floating a, Integral a) => a -> [a]
05:59:11 <isomorphic> I'm definitely starting some sort of support group for the haskell type system
05:59:19 <fosskers> please
05:59:24 <azaq23> fosskers: where is only used in function definitions; a list comprehension is just a normal expression. you may do [ ... p ... | ... p ... , let p = something, ... p ...] though. let ... in ... is also just an expression
05:59:46 <Jonno_FTW> let factors x = [(i,x/i)| i<-[1.. ceiling $ sqrt x], x`mod`i == 0] in factors 100
05:59:49 <fosskers> so the where in the case above does nothing?
05:59:52 <Jonno_FTW> > let factors x = [(i,x/i)| i<-[1.. ceiling $ sqrt x], x`mod`i == 0] in factors 100
05:59:53 <lambdabot>   Ambiguous type variable `t' in the constraints:
05:59:53 <lambdabot>    `GHC.Real.Integral t'
05:59:53 <lambdabot>   ...
05:59:54 <isomorphic> ":t Anonymous"
06:00:57 <koeien> it's better to check for i * i <= x then i <= sqrt x
06:01:40 <azaq23> fosskers: it introduces the name root into the scope of the function, from where you use it in the list comprehension - it just isn't intrisically related to a list comprehension, but instead to the function
06:01:44 <Jonno_FTW>  let n = 100 in[(i,n`div`i)|i<-[1..fromIntegral(round(sqrt(n)))],n`mod`i == 0]
06:01:47 <Jonno_FTW> > let n = 100 in[(i,n`div`i)|i<-[1..fromIntegral(round(sqrt(n)))],n`mod`i == 0]
06:01:48 <lambdabot>   [(1,100),(2,50),(4,25),(5,20),(10,10)]
06:03:04 <rostayob> what's the best way of consuming a bit stream in haskell?
06:03:12 <rostayob> i mean the fastest way
06:03:59 <Jonno_FTW> > let n = 100 in[(i,n`div`i)|i<-takeWhile (\i->i*i<=x) [1..],n`mod`i == 0]
06:04:03 <lambdabot>   mueval-core: Time limit exceeded
06:04:06 <Jonno_FTW> :|
06:04:12 <azaq23> > [ (x, p) | x <- [0 .. 10], let p = 2, x `mod` p == 0]
06:04:13 <lambdabot>   [(0,2),(2,2),(4,2),(6,2),(8,2),(10,2)]
06:04:22 <fosskers> you're getting a little excited there jonno
06:05:22 <Jonno_FTW> > let n = 100 in[(i,n`div`i)|i<-takeWhile (\i->i*i<=n) [1..],n`mod`i == 0] -- confused my x with n there
06:05:23 <lambdabot>   [(1,100),(2,50),(4,25),(5,20),(10,10)]
06:06:28 <Jonno_FTW> then you just need to flatten and remove the last element!
06:06:59 <koeien> rostayob: it depends on your exact situation, but you could look into the binary package. This allows for efficient parsing and generation of data in binary formats
06:08:41 <rostayob> koeien: basically I need to handle a vector and being able to "take" from 8 to 12 bits
06:10:12 <Jonno_FTW> > let factors n = init $concatMap (\(x,y)->[x,y])$tail[(i,n`div`i)|i<-takeWhile (\i->i*i<=n) [1..],n`mod`i == 0] in factors 1000
06:10:13 <lambdabot>   [2,500,4,250,5,200,8,125,10,100,20,50,25]
06:10:21 <koeien> rostayob: binary generally works on the byte level.
06:11:06 <koeien> it's not that difficult to write a wrapper around it that allows you to take bits, but there might already be a package on Hackage that does this (I am not sure whether that's true, and if so, which)
06:11:27 <rostayob> koeien: i don't see why binary is relevant here, I don't need to serialize stuff. I'd just like a ByteString bu instead of just bytes something of variable size :P
06:11:43 <fosskers> thanks Jonno_FTW
06:12:14 <koeien> rostayob: aha. now I get it. you need it to be packed?
06:12:48 <rostayob> koeien: i don't know what packed means here :P
06:13:39 <koeien> rostayob: as efficient as possible. e.g., if you have 2 bits as a structure, then 4 items would take only 8 bits in space.
06:14:08 <fosskers> whats the easiest way to convert from a float to an int in haskell?
06:14:21 <jkff> fosskers: round?
06:14:31 <koeien> fosskers: do you want rounding, truncating, floor or ceiling ?
06:14:32 <parcs> rostayob: bitstream seems to be what you want
06:14:46 <rostayob> koeien: no, not necessarly. I need to be able to convert fast from/to bytestrings
06:14:57 <jkff> @hoogle Double -> Int
06:14:57 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
06:14:57 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
06:14:57 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
06:15:03 <fosskers> okay, actually, i have it figured out
06:15:08 <fosskers> thanks
06:15:15 <jkff> @hoogle (Real a, Integral b) => a -> b
06:15:15 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
06:15:15 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
06:15:15 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
06:15:21 <jkff> so here you are
06:15:36 <rostayob> parcs: bitstream seems quite generic for what I have to do here, but thanks I'll try it out
06:15:38 <parcs> > let int = floor in (int)5.5
06:15:38 <lambdabot>   5
06:15:56 <koeien> err, (int). this syntax is really ugly
06:15:58 <jkff> heh
06:16:13 <fosskers> so when something is an Integral, is it specifically an Int or an Integer?
06:16:19 <jkff> fosskers: no
06:16:25 <fosskers> then what is it?
06:16:36 <fosskers> data-wise
06:16:42 <jkff> fosskers: it is an Integral :) the ceiling/floor functions can convert from any instance of RealFrac to any instance of Integral
06:16:47 <jkff> For example, from Double to Integer
06:16:59 <koeien> fosskers: no, it is an integral. That means that it can be an Int, an Integer, or something else
06:17:05 <koeien> (including your own types)
06:17:07 <jkff> or perhaps from (some fancy arbitrary-precision floating-point type) to Peano integers
06:17:41 <jkff> fosskers: That doesn't mean that these functions are magic, it's just that when you define them, you have to define them in this very generic form.
06:17:54 <jkff> @source ceiling
06:17:54 <lambdabot> ceiling not available
06:17:56 <jkff> hm
06:18:28 <parcs> @src RealFrace
06:18:28 <lambdabot> Source not found. Sorry.
06:18:30 <parcs> @src RealFrac
06:18:30 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
06:18:30 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
06:18:30 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
06:19:30 <fosskers> alright, but what is it being stored as?
06:19:32 <jkff> fosskers: That means that when someone defines a type as instance of RealFrac, he has to implement 'ceiling' so that it can convert to any instance of Integral, not just to Int or to Integer.
06:19:44 <jkff> fosskers: In Java, what is being stored as Object?
06:19:48 <jkff> or as IComparable?
06:20:03 <fosskers> havent touched java ina while
06:20:13 <fosskers> actually, nothing then
06:20:15 <fosskers> if its just Object
06:20:20 <fosskers> or rather
06:20:22 <fosskers> everything?
06:20:24 <parcs> fosskers: for the most part, the compiler chooses a concrete instance of Integral (either Int or Integer)
06:20:26 <fosskers> inheritence?
06:20:32 <jkff> fosskers: Type classes allow you to override a function not only on its argument, but also on its return type
06:20:34 <fosskers> parcs: that's the answer i wanted
06:20:39 <jkff> > ceiling 5.5 :: Int
06:20:40 <lambdabot>   6
06:20:44 <jkff> > ceiling 5.5 :: Integer
06:20:44 <lambdabot>   6
06:20:48 <jkff> @instance Integral
06:20:49 <lambdabot> Maybe you meant: instances instances-importing
06:20:52 <jkff> @instances Integral
06:20:53 <lambdabot> Int, Integer
06:21:07 <hpc> @src Integral
06:21:07 <lambdabot> class  (Real a, Enum a) => Integral a  where
06:21:07 <jkff> Okay, if I also had PeanoInteger, I'd be able to write > ceiling 5.5 :: PeanoInteger
06:21:07 <lambdabot>     quot, rem, div, mod :: a -> a -> a
06:21:07 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
06:21:07 <lambdabot>     toInteger           :: a -> Integer
06:21:10 <parcs> if you turn on -Wall, you'll see warnings such as "defaulitng the followng instance to type 'Integer'"
06:21:18 <fosskers> thanks
06:21:25 <parcs> err, s/instance/constraint/
06:21:33 <fosskers> basically my thought was: "it has to be one or the other"
06:21:42 <fosskers> regardless of its generic branding of 'Integral'
06:22:06 <jkff> fosskers: The ceiling function is overridden on its return type. It can return anything you need, if it belongs to Integral.
06:22:13 <koeien> ah no, you can even make your own types Integral by using instance Integral YourType where ...
06:22:14 <parcs> Integral is special in this case because the compiler automaticaly defaults it to Integer if no type is specified
06:22:36 <fosskers> ah
06:22:57 <jkff> fosskers: If you need an Int, it will return an Int, etc. No magic here, though - the actual implementations use "fromIntegral" and give it an Integer probably.
06:22:58 <parcs> for other constraints, you'll get an ambiguous type error
06:23:00 <jkff> :t fromIntegral
06:23:01 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:23:19 <jkff> fosskers: So when you're writing ceiling for Double, you can do this:
06:23:24 <fosskers> yeah ive been getting type errors all night trying to get this to work
06:23:42 <jkff> fosskers: write a doubleToInteger function in some way, and then say "ceiling = fromIntegral . doubleToInteger"
06:23:59 <jkff> And then the implementation of that Integral type will have to figure out how to convert itself from an Integer, because it has to implement fromIntegral.
06:24:04 <parcs> > 5 .|. 5
06:24:05 <lambdabot>   Ambiguous type variable `a' in the constraint:
06:24:06 <lambdabot>    `Data.Bits.Bits a'
06:24:06 <lambdabot>      a...
06:24:49 <jkff> fosskers: I'll give an example in a moment.
06:25:05 <parcs> > (5 :: Int) .|. 5
06:25:06 <lambdabot>   5
06:27:02 <koeien> > (5 :: Word32) .|. 5
06:27:03 <lambdabot>   5
06:28:29 <koeien> another implementation of .|. is used there
06:29:56 <ndxtg> is there an opposite function of nub? (i.e. take 2 lists and extract the same items in both lists into a new list?)
06:30:28 <HugoDaniel> hey
06:30:35 <koeien> > Data.List.intersection [1,2,3] [1,3,4]
06:30:36 <lambdabot>   Not in scope: `Data.List.intersection'
06:30:42 <koeien> > Data.List.intersect [1,2,3] [1,3,4]
06:30:42 <HugoDaniel> anyone using the curl package ?
06:30:43 <HugoDaniel> i can't compile it :(
06:30:43 <lambdabot>   [1,3]
06:30:45 <jkff> fosskers: Stay online, I'm almost done :)
06:30:50 <fosskers> lol okay
06:30:52 <koeien> HugoDaniel: which platform?
06:30:53 <ndxtg> koeien: thank you
06:31:11 <koeien> ndxtg: pay attention to the following behavior:
06:31:17 <koeien> > Data.List.intersect [1,1,2,3] [1,3,4]
06:31:18 <lambdabot>   [1,1,3]
06:31:32 <ndxtg> aw!
06:31:43 <fosskers> why does
06:31:45 <fosskers> getDivs' n = [x	| x <- [1..root], n `mod` x == 0]
06:31:45 <fosskers>              where
06:31:45 <fosskers>                root = ceiling .	sqrt $ n
06:31:45 <koeien> and if you do not care about multiplicities, Data.Set will be more efficient
06:31:52 <fosskers> have the type
06:31:54 <parcs> HugoDaniel: have you tried older/newer versions of curl?
06:31:54 <HugoDaniel> koeien: arch linux
06:32:00 <fosskers> getDivs' :: (RealFrac t, Integral t, Floating t) => t -> [t]
06:32:02 <HugoDaniel> i did, same error :(
06:32:08 <HugoDaniel> let me paste it
06:32:10 <pastorn> hiding mtl or monads-fd?
06:32:20 <pastorn> i never remember which one i should hide :/
06:32:40 <koeien> fosskers: you use mod, and sqrt.
06:32:41 <koeien> :t sqrt
06:32:42 <lambdabot> forall a. (Floating a) => a -> a
06:32:43 <ndxtg> koeien: no worry, (nub (intersect _ _ )) will may make a quick fix
06:32:44 <koeien> :t mod
06:32:45 <lambdabot> forall a. (Integral a) => a -> a -> a
06:33:05 <koeien> :t ceiling
06:33:06 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:33:29 <koeien> fosskers: so your n should be of a type that instantiates Flotaing, Integral and RealFrac
06:33:55 <fosskers> i just want it to be an int :(
06:34:02 <parcs> @instances Int
06:34:04 <lambdabot> Couldn't find class `Int'. Try @instances-importing
06:34:12 <koeien> fosskers: root = ceiling . sqrt . fromIntegral $ n
06:34:14 <parcs> @src Int
06:34:14 <lambdabot> data Int = I# Int#
06:34:26 <fosskers> oh
06:34:32 <HugoDaniel> http://hpaste.org/46218/curl_error  <- here is the error im getting when i try to cabal install curl
06:34:32 <jkff> fosskers: http://hpaste.org/46219/peano__ceiling
06:34:36 <koeien> alternatively, add a type signature. getDivs' :: Integer -> [Integer]. Then the compiler will tell you where the problem is.
06:34:54 <koeien> (in this case, in the application of sqrt to n)
06:34:56 <jkff> fosskers: I've defined the type of peano numbers, made it an instance of the appropriate typeclasses, and voila, ceiling works for it
06:35:14 <jkff> fosskers: Note that I did NOT define anything related directly to "ceiling", nor did of course Double know anything of the Pint type.
06:35:56 <jkff> fosskers: It's just that "ceilling :: (Integral a) => Double -> a" is defined in terms of the operations that I *did* define and so it also works for Pint.
06:35:58 <fosskers> k this might take me a bit, i dont have a lot of experience reading long haskell code
06:36:02 <parcs> HugoDaniel: curl version?
06:36:29 <jkff> fosskers: Nearly all of it is boilerplate. It's just addition, multiplication, division and conversion to Int/Integer.
06:36:31 <fosskers> or rather... i don't think im far enough to understand much of this
06:36:53 <koeien> fosskers: do you know what a Peano integer is (in mathematics) ?
06:37:13 <fosskers> if i did at one point i dont anymore
06:37:30 <koeien> it's saying that a natural number is either zero, or the successor of another natural number
06:37:54 <koeien> so 2 is Succ (Succ Zero)
06:37:57 <jkff> fosskers: It's like numbers in unary: 0, 10, 110, 1110, 11110 etc
06:38:03 <HugoDaniel> parcs: curl 7.21.6 (x86_64-unknown-linux-gnu) libcurl/7.21.6 OpenSSL/1.0.0d zlib/1.2.5
06:38:05 <jkff> where 0 is the "number terminator"
06:38:57 <koeien> so jkff defines a Pint as being either Zero or Succ a, where a is a Pint. (line 3)
06:39:42 <koeien> deriving (Eq, Show) means that we want the compiler to autogenerate the Eq and Show instances. This means that we can compare peano integers and convert them to strings (so we can actually see them)
06:40:28 <bqf> can anyone give me a pointer on how i'd express a list comprehension like [(x,y) | x <- [1..5], y <- [1..x], x*y `mod` 15 < 10] solely as map and filter calls? (disclaimer: this is course work, but i'm thoroughly stuck on this particular task since i can't seem to find a way to "map" y's dependency on x or create tuples from those values)
06:40:29 <koeien> then, in line 5-17, we define how to add, subtract, multiply (and some other operations) peano integers.
06:40:36 <fosskers> i havent read anything yet about custom typeclasses yet so this is all fairly mind blowing
06:40:42 <parcs> HugoDaniel: hmm, i also can't build curl on arch linux. maybe you should file a bug report
06:41:27 <koeien> bqf: let's simplify. [(x,y) | x <- [1..5], y <- [1..x]] can you do this?
06:41:46 <fosskers> i appreciate your effect jkff but i think that's too much for me at the moment
06:41:56 <jkff> fosskers: In this example I only make my type an instance of some of the standard typeclasses. It is like implementing an interface in any OO language.
06:41:58 <koeien> fosskers: are you reading a book at the moment?
06:42:08 <fosskers> yeah, two
06:42:17 <parcs> HugoDaniel: the problem may be with arch's toolchain
06:42:28 <jkff> fosskers: well, then put it aside and take a look when you're ready :) You'll need just the very basics of typeclasses.
06:42:30 <koeien> fosskers: I think LYAH has a nice chapter on types and type classes
06:42:40 <fosskers> Progaramming in Haskell got weird and irrelevant half-way through so i switched to Learn you a Haskell
06:42:48 <koeien> fosskers: so you will definitely encounter them
06:42:56 <shachaf> fosskers: It didn't get weird and irrelevant when I read it.
06:43:16 <shachaf> fosskers: It's generally a very good introduction, I think; what part are you thinking of?
06:43:30 <fosskers> when it starts talking about parsers and beyond
06:43:42 <bqf> koeien: no, i can't. i guess i'm missing some simple way to transform it. [x | x <- [1..10], SOMEGUARD] is obviously just a basic filter call, but making a second variable depend on a first and putting them in tuples is somehow beyong my comprehension
06:43:47 <shachaf> fosskers: Oh, the parser part is very relevant.
06:44:10 <fosskers> i found it very dry and hard to follow
06:44:13 <parcs> bqf: do you understand the correspondence between list comprehensions and the list monad?
06:44:29 <koeien> bqf: so map (\x -> ... ) [1..10] -- we should start like this.
06:44:39 <koeien> we can use x multiple times in that expression.
06:44:50 <koeien> err, [1..5] rather
06:44:51 <shachaf> fosskers: I recommend that you keep going through it. I often want to recommend that part to people in this channel, except it's not available online.
06:45:10 <koeien> bqf: e.g.
06:45:11 <shachaf> fosskers: It kind of counts as "monad tutorial", for what it's worth.
06:45:19 <koeien> > map (\x -> (x,x + 1)) [1..5]
06:45:20 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6)]
06:46:20 <fosskers> in quite a few places he starts defining things that have the same name but different behavior
06:46:29 <fosskers> i.e. <<= and return
06:46:46 <fosskers> i had seen those in other code before, and i didn't want to get confused so i shut the book
06:47:11 <koeien> fosskers: you mean >>= probably :). But you should understand typeclasses before monads imo
06:47:15 <shachaf> fosskers: Oh. I'm afraid you'll have to get confused at one point. It's part of learning.
06:47:42 <shachaf> fosskers: He goes over type classes before the Parser section, doesn't he?
06:47:50 <fosskers> yeah, but nothing about creating your own
06:47:56 <fosskers> i get the idea of them
06:48:10 <shachaf> Hmm. Just pretend that ">>=" and "return" are just for parsers, for the purposes of that chapter.
06:48:26 <koeien> bqf: are you allowed to use `concat' ?
06:48:29 <shachaf> The general-purpose meaning becomes relevant later on.
06:48:44 <fosskers> i didn't find it relevant for what i wanted to know about haskell at the moment, then
06:48:55 <HugoDaniel> parcs: oh, thanks
06:49:07 <fosskers> it seemed like an extended example in a place i didn't need it
06:49:30 <shachaf> OK. :-) But occasionally detours like that are useful, for the purposes of learning something new. You can't always go depth-first. .:-)
06:49:46 <fosskers> or can't i?
06:49:52 <shachaf> Not practically.
06:49:57 <fosskers> foldl1 (+) [1..]
06:49:59 <fosskers> DEPTH!
06:50:22 <shachaf> fosskers: It wasn't just there to demonstrate type classes, it was there to demonstrate a particular one which is somewhat important in Haskell.
06:50:24 <bqf> koeien: sorry for taking this long to answer, i'm thinking in between. yes, i understand the basic usage, but i'm still not sure how i'd express the x <---> y relation or create all needed pairs. concat: it's not expressively prohibited, nor is it expressively allowed. i'd guess it's allowed though.
06:51:00 <shachaf> fosskers: And also to show how parser are sometimes writen -- he ends up with a neat parser-combinator library at the end.
06:51:13 <koeien> > map (\x -> map (\y -> ... ) ) [1..5] -- this might be a blueprint bqf
06:51:13 <lambdabot>   <no location info>: parse error on input `...'
06:51:23 * hackagebot Chitra 0.2 - A platform independent mechanism to render graphics using vnc.  http://hackage.haskell.org/package/Chitra-0.2 (KashyapChatamballi)
06:51:42 <parcs> > [ (x, y) | y <- [1..5], x <- [1..5] ]
06:51:43 <lambdabot>   [(1,1),(2,1),(3,1),(4,1),(5,1),(1,2),(2,2),(3,2),(4,2),(5,2),(1,3),(2,3),(3...
06:53:08 <fosskers> it just seemed a little bit early for that scale of an example
06:53:09 <parcs> > [1..5] >>= \x -> [1..5] >>= \y -> return (x, y)
06:53:10 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
06:53:16 <parcs> @src [] (>>=)
06:53:17 <lambdabot> xs >>= f     = concatMap f xs
06:53:24 <koeien> > [1..5] >>= (\x -> [1..x] >>= (\y -> return (x,y))) -- magic!
06:53:25 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5...
06:53:39 <koeien> but I think this might be confusing
06:53:57 <fosskers> and for jkff's example, i still haven't seen anything about creating custom types
06:54:18 <fosskers> (while i still like to think i understand what types are about in the first place)
06:55:24 <fosskers> ah, alright
06:55:36 <fosskers> im on section 7 of LUAH
06:55:44 <fosskers> making custom types is section 8
06:55:50 <shachaf> fosskers: You haven't seen "data"?
06:56:01 <fosskers> no sir
06:56:41 <shachaf> Huh. I must be misremembering Hutton's book.
06:56:45 <shachaf> The order, anyway.
06:56:54 <pastorn>     Duplicate instance declarations:
06:56:56 <pastorn>       instance MonadFix (Either e)
06:56:58 <pastorn>         -- Defined at src/Control/Monad/Either.hs:53:10-28
06:57:00 <pastorn>       instance MonadFix (Either e) -- Defined in Control.Monad.Fix
06:57:02 <pastorn> ^^^ how to solve?
06:57:33 <bqf> koeien: indeed, that is a little confusing. i'll try and get through it though, it might take me some time ;)
06:57:55 <Saizan> pastorn: compile an mtl which is compatible with the new base
06:58:11 <pastorn> Saizan: using 6.12.3
06:58:22 <fosskers> well ill get reading
06:58:25 <pastorn> i want to install 'reactive'
06:58:31 <fosskers> then go meditate on a mountain top
06:58:43 <fosskers> and then come back here and see how things go
06:58:56 <Saizan> pastorn: mh, where is Control.Monad.Either from? reactive?
06:59:04 <pastorn> Saizan: no clue :*
06:59:05 <pastorn> :(
06:59:10 <pastorn> Saizan:
06:59:24 <Saizan> pastorn: well, the build log should tell
06:59:36 <Saizan> pastorn: anyhow, you've to remove that instance
07:00:37 <Saizan> (mtl is not relevant here, since that'd be Control.Monad.Error)
07:00:49 <pastorn> Saizan: http://hpaste.org/46221/reactivefail
07:01:13 <Saizan> pastorn: category-extras then
07:01:15 <roconnor> @type \x -> all (zipWith (>=) x (tail x)
07:01:16 <lambdabot> parse error (possibly incorrect indentation)
07:01:19 <roconnor> @type \x -> all (zipWith (>=) x (tail x))
07:01:19 <lambdabot>     Couldn't match expected type `a -> Bool'
07:01:20 <lambdabot>            against inferred type `[Bool]'
07:01:20 <lambdabot>     In the first argument of `all', namely `(zipWith (>=) x (tail x))'
07:01:26 <Saizan> pastorn: you've to patch that
07:01:34 <roconnor> @type \x -> and (zipWith (>=) x (tail x))
07:01:35 <lambdabot> forall a. (Ord a) => [a] -> Bool
07:01:44 <roconnor> @hoogle sorted
07:01:44 <lambdabot> No results found
07:02:04 <pastorn> Saizan: patch what? categories-extras?
07:02:10 <Saizan> pastorn: yep
07:02:14 <pastorn> shit
07:02:42 <pastorn> Saizan: can't i do some clever hiding tricks?
07:02:46 <Saizan> pastorn: cabal unpack category-extras; cd into it; edit src/Control/Monad/Either.hs; then cabal install
07:02:53 <Saizan> pastorn: instances can't be hidden
07:03:11 <pastorn> anonymous instances are rather stupid :(
07:03:37 <izakaya27> Hi, could someone point me to a good description of function type signatures for more complex cases (several input parameters, several output parameters)? The examples I've read so far have been too simple (e.g. someFun :: [String] -> String)
07:04:25 <shachaf> izakaya27: All functions are of exactly one argument.
07:04:27 <koeien> every function only has one input and one output type.
07:04:49 <shachaf> A function that "looks" like it gets two arguments is written like f :: Int -> Char -> Bool
07:05:10 <shachaf> But really it gets "one argument at a time". Most introductions should cover this; are you reading one?
07:06:01 <pastorn>     Could not deduce (Functor m)
07:06:03 <pastorn>       from the context (CFunctor (SRWS.RWST r w s m) Hask Hask, Monad m)
07:06:05 <pastorn>       arising from a use of `fmap'
07:06:07 <pastorn>                    at src/Control/Functor/Categorical.hs:70:72-75
07:06:10 <pastorn> Saizan: gaaaaaawd
07:07:08 <izakaya27> shachaf: yep, reading Real World Haskell, but getting confused. I have: getSumAndLength :: [Float] -> Maybe Float -> Maybe Int -> Float -> Int
07:07:30 <Saizan> pastorn: that i don't know how to fix, anyhow category-extras is no longer maintained, so expect even more :)
07:07:30 <izakaya27> I then have: getMean [a] = case getSumAndLength [a] of
07:07:30 <izakaya27>                       (sum, length) -> sum / (fromIntegral length)
07:07:36 <shachaf> izakaya27: Hmm. If RWH doesn't mention it by that point, you might want to read another introduction first.
07:08:06 <shachaf> izakaya27: No, getSumAndLength needs to be called with 4 arguments.
07:08:25 <shachaf> Also, the list argument shouldn't have brackets unless you're just matching a singleton list.
07:08:33 <shachaf> Yes, you should read another introduction first. :-)
07:08:37 <shachaf> I ehar LYAH is popular.
07:08:40 <shachaf> @where lyah
07:08:40 <pastorn> Saizan: i can't even seem to build old versions of reactive :(
07:08:40 <lambdabot> http://www.learnyouahaskell.com/
07:09:20 <Saizan> pastorn: why do you want to build reactive?
07:09:32 <pastorn> frp experiments :)
07:10:00 <Saizan> try some other frp lib, then?
07:10:24 <pastorn> but i want this one!
07:10:28 * pastorn cries
07:10:33 <Saizan> but it doesn't work :)
07:11:20 <pastorn> surely i must be able to use old versions of the libraries and get it working that way...
07:12:17 <Saizan> i meant that it doesn't even work that well once you got it compiled
07:12:35 <pastorn> Saizan: should i go for banana instead?
07:12:41 <pastorn> also: where are the running functions?
07:12:56 <Saizan> or yampa
07:13:01 <pastorn> LegacyAdapters seems to be just for library building
07:13:08 <pastorn> Saizan: no, not yampa
07:13:25 <pastorn> that library just screams "fuck you mister library user"
07:15:25 * hackagebot Chitra 0.2.1 - A platform independent mechanism to render graphics using vnc.  http://hackage.haskell.org/package/Chitra-0.2.1 (KashyapChatamballi)
07:15:51 <pastorn> pSwitch :: (Functor col) => (forall sf. a -> col sf -> col (b, sf)) -> col (SF b c) -> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)
07:15:58 <pastorn> yeah, real smooth
07:16:42 <roconnor> > intercalate " + " ["1","2","3"]
07:16:43 <lambdabot>   "1 + 2 + 3"
07:18:37 <hpc> @src intercalate
07:18:37 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
07:18:50 <hpc> oh, that's obvious :P
07:18:53 <DrSyzygy> @src intersperse
07:18:53 <lambdabot> intersperse _   []     = []
07:18:53 <lambdabot> intersperse _   [x]    = [x]
07:18:53 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
07:27:22 <taktoa> Hi
07:27:27 <neural> hi
07:27:32 <taktoa> I'm implementing a PID controller in haskell
07:27:42 <taktoa> and I'm running into a little problem with types
07:27:43 <taktoa> http://hpaste.org/46222
07:28:09 <taktoa> Basically, I'm wondering how I can implement Error such that it can represent any type
07:28:37 <taktoa> I'm pretty sure it involves polymorphism, but I'm not sure how I'm supposed to implement it
07:28:57 <taktoa> Thanks in advance
07:29:27 * hackagebot Chitra 0.2.2 - A platform independent mechanism to render graphics using vnc.  http://hackage.haskell.org/package/Chitra-0.2.2 (KashyapChatamballi)
07:32:28 <isomorphic> taktoa:  Your function takes a list of errors as it's first argument, yes?
07:33:27 <isomorphic> Oh, wait, I think I know what you're doing
07:33:36 <isomorphic> You want to be able to take basically any type
07:33:45 <isomorphic> I think you want a different type signature
07:33:53 <isomorphic> say you want it to be things that are numbers
07:33:59 <isomorphic> you want:
07:34:31 <isomorphic> pid :: (Num a) => [a] -> Integer -> PConfig -> [a]
07:35:02 <isomorphic> I'd watch that first line of the definition btw - you pass the parameter err to pid unmodified - is that what you want?
07:35:12 <isomorphic> or would you prefer
07:35:24 <taktoa> hrm
07:35:27 <taktoa> one sec
07:35:31 <taktoa> was in the bathroom
07:35:39 <isomorphic> pid (e:rest) n cfg = f (derivative + integral + proportional) : pid rest (n-1) cfg
07:35:49 <taktoa> well, it can't be Num
07:36:04 <isomorphic> What is it?
07:36:07 <taktoa> because, in my implementation for example
07:36:19 <taktoa> it's going to be a datatype with multiple variables
07:36:30 <isomorphic> that's okay
07:36:36 <isomorphic> the Num isn't a parameter
07:36:52 <isomorphic> see the '=>'  - not a '->'
07:36:56 <taktoa> I know
07:37:08 <isomorphic> oh okay - my bad :/
07:37:16 <taktoa> but you're restricting the input to be only Nums
07:37:28 <taktoa> unless my datatype does fall under the Nums
07:37:31 <isomorphic> okay - perhaps lose the restriction
07:37:57 <isomorphic> pid :: [a] -> Integer -> PConfig -> [a]
07:37:57 <taktoa> so then can I just replace all instances of "Error" with "a"?
07:38:12 <isomorphic> Yes
07:38:33 <taktoa> I just did that
07:38:39 <taktoa> It gives me "
07:38:48 <taktoa> not in scope: type variable 'a'
07:39:10 <taktoa> the errors are all in PConfig's definition
07:39:10 <isomorphic> Did you replace 'err' with 'a'?
07:39:14 <taktoa> no
07:39:39 <taktoa> I defined "function" as Double -> a
07:39:47 <taktoa> and toInput as a -> Double
07:40:01 <taktoa> that's where the errors are
07:40:09 <taktoa> do I need to use forall?
07:40:30 <koeien> no, you need to write PConfig a
07:40:33 <koeien> data PConfig a = ...
07:40:37 <taktoa> I see
07:40:54 <taktoa> now I get
07:41:07 <taktoa> "PConfig is not applied to enough type arguments"
07:41:28 <taktoa> Expected kind '??', but PConfig has king '* -> *'
07:41:36 <taktoa> *kind
07:41:44 <isomorphic> is that on line 12?
07:41:48 <taktoa>  yes
07:41:55 <taktoa> also on 26
07:42:01 <isomorphic> PConfig a?
07:42:08 <taktoa> oh
07:42:14 <taktoa> I see
07:42:26 <taktoa> I had to replace all instances of PConfig with PConfig a
07:42:48 <isomorphic> btw - check line 14
07:43:00 <isomorphic> pid err (n-1) cfg looks suspicious
07:44:13 <taktoa> yay... it compiles
07:44:26 <isomorphic> :)
07:44:30 <isomorphic> well done
07:45:10 <Phyx-> @type ($) ($)
07:45:11 <taktoa> for future reference, here's the final implementation
07:45:11 <lambdabot> forall a b. (a -> b) -> a -> b
07:45:12 <taktoa> http://hpaste.org/46223
07:45:21 <Phyx-> @type ($) flip ($)
07:45:22 <lambdabot> forall a b. a -> (a -> b) -> b
07:45:47 <isomorphic> tak: does it test okay?
07:45:54 <isomorphic> taktoa: does it test okay?
07:46:20 <taktoa> working on that
07:46:21 <Phyx-> @type \_ -> 4
07:46:22 <lambdabot> forall t t1. (Num t1) => t -> t1
07:47:25 <Phyx-> @type \_ -> \x -> x
07:47:26 <lambdabot> forall t t1. t -> t1 -> t1
07:48:06 <Phyx-> > dataTypeOf (undefined :: String -> Int)
07:48:07 <lambdabot>   DataType {tycon = "Prelude.(->)", datarep = NoRep}
07:48:45 <Phyx-> > dataTypeOf (undefined :: (->) String Int)
07:48:45 <lambdabot>   DataType {tycon = "Prelude.(->)", datarep = NoRep}
07:48:52 <Phyx-> hah
07:49:13 <Phyx-> :t undefined :: (->) Int String
07:49:14 <lambdabot> Int -> String
07:49:26 <Phyx-> :t undefined :: (->) (->)
07:49:27 <lambdabot>     `(->)' is not applied to enough type arguments
07:49:27 <lambdabot>     The first argument of `(->)' should have kind `??',
07:49:27 <lambdabot>     but `(->)' has kind `?? -> ? -> *'
07:49:42 <Phyx-> :t undefined :: (->) a a
07:49:43 <lambdabot> forall a. a -> a
07:49:47 <nihtml> :t (=<<)
07:49:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:50:38 <taktoa> well
07:50:43 <taktoa> my only problem
07:50:50 <taktoa> is that I'm not sure what to test it with
07:51:01 <taktoa> what function, that it
07:51:03 <taktoa> *is
07:51:13 <nihtml> is =<< the same as >>=?
07:51:17 <nihtml> uh
07:51:19 <nihtml> flip >>=
07:51:48 <taktoa> isomorphic: any ideas?
07:52:22 <rostayob> @src (=<<)
07:52:23 <lambdabot> f =<< x = x >>= f
07:52:40 <nihtml> oh thx rostayob
07:52:55 <rostayob> np
07:53:04 <rostayob> lambdabot is nice (:
07:53:07 <taktoa> This is the code I'm testing with
07:53:10 <taktoa> http://hpaste.org/46225
07:53:19 <taktoa> output is commented below
07:53:31 <taktoa> as you can see, it's not very useful...
07:55:40 <stepkut> someone should add this function to Data.List: lookups :: (Eq a) => a -> [(a, b)] -> [b]
07:56:17 <dolio> Someone else should use something more efficient than an association list. :)
07:56:36 <taktoa> stepkut: a function I find useful is "neck :: [a] -> a"... second element of a list
07:56:44 <taktoa> also, penult :: [a] -> a
07:56:49 <dolio> Gah.
07:56:49 <taktoa> second to last element
07:56:55 <mauke> :t map snd . filter ((?x ==) . fst)
07:56:56 <lambdabot> forall a b. (?x::a, Eq a) => [(a, b)] -> [b]
07:57:04 <stepkut> dolio: perhaps, but given that they didn't I know need the List version
07:57:19 <mauke> taktoa: when do you need that?
07:57:23 <copumpkin> :t init . init
07:57:24 <lambdabot> forall a. [a] -> [a]
07:57:25 <taktoa> it makes code cleaner
07:57:31 <mauke> taktoa: unlikely
07:57:42 <copumpkin> :t last . init . init
07:57:42 <taktoa> for example, if you want to do the derivative
07:57:43 <lambdabot> forall a. [a] -> a
07:57:48 <taktoa> of a list of Doubles
07:57:54 <stepkut> neck = head . tail ?
07:58:06 <taktoa> you can do "(head a - neck a) / step"
07:58:22 <dolio> I don't think we need more non-total list indexing functions.
07:58:24 <taktoa> rather than "(head a - (a !! 1)) / step
07:58:32 <taktoa> I guess
07:58:37 <stepkut> torso = head . tail . tail?
07:58:38 <taktoa> I just find it nice
07:58:41 <taktoa> heh
07:59:05 <dolio> (a!!0 - a!!1)/step ?
07:59:06 <taktoa> well, in math, the cases are usually: 0, 1, 2, infinity
07:59:20 <taktoa> dolio: magic numbers look arbitrary
07:59:36 <dolio> Lists are 0-indexed, just like C.
07:59:45 <taktoa> I know
08:00:05 <dolio> C is the gold standard, right? :)
08:00:13 <taktoa> kind of
08:00:21 <taktoa> C is a bit gross though
08:00:26 <taktoa> in terms of elegance
08:00:31 <taktoa> and readability
08:00:31 <dolio> The only problem is we don't have square brackets.
08:00:46 <taktoa> what?
08:00:51 <taktoa> [1, 2, 3]
08:00:56 <taktoa> ^ square brackets
08:01:00 <copumpkin> [1,2,3][4]
08:01:00 <dolio> (a[0] - a[1])/step
08:01:06 <taktoa> oh, I see
08:01:12 <taktoa> yeah, that is a bit annoying
08:01:30 <taktoa> but it's sugar for !!
08:01:37 <Saizan> http://www.haskell.org/pipermail/haskell-cafe/2009-March/058872.html
08:01:58 <taktoa> one of my main gripes with Data.Tuple
08:02:13 <taktoa> is that they don't include three-tuple indexing functions
08:02:20 <copumpkin> screw tuples
08:02:20 <taktoa> why the hell don't they?
08:02:37 <taktoa> it adds three lines of code to the module
08:02:38 <Saizan> three-tuples are evil anyway
08:02:41 <taktoa> so?
08:02:49 <taktoa> they're useful sometimes
08:02:56 <Saizan> use a custom datatype
08:02:59 <dolio> I remember a couple years back, there was talk about fst3 snd3, thd3 and (un)curry3.
08:03:09 <dolio> And then it never happened.
08:03:14 <copumpkin> no X that I've said "screw X" about is useful
08:03:25 <dolio> The fst3 things used to exist at some point in Haskell's history.
08:03:26 <taktoa> dolio: there's nothing to talk about
08:03:41 <taktoa> fst3 (a, b, c) = a
08:03:45 <Saizan> taktoa: why not fst4,fst5,fst6,... ?
08:03:50 <taktoa> snd3 (a, b, c) = b
08:03:51 <copumpkin> why not fst3 ~(a, b, c) = a?
08:03:58 <shachaf> No, no, a type class, so you can fst tuples of different lengths with the same function!
08:03:59 <dolio> By "there was talk" I mean, people were saying, "we're going to add it to the next version of base."
08:04:31 <dolio> People who could do that sort of thing.
08:04:35 <dolio> But then they didn't.
08:04:52 <taktoa> I just find it a bit ridiculous that they are all snobby about three lines of code that make some user's lives easier
08:05:08 <taktoa> *users'
08:05:08 <Saizan> it's already silly that there's a zipWith7
08:05:24 <copumpkin> taktoa: http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Select.html ?
08:05:28 <Phyx-> :k Maybe
08:05:29 <lambdabot> * -> *
08:05:30 <taktoa> there is?
08:05:35 <dolio> We should just have base require template haskell.
08:05:37 <shachaf> > zipWith 7 [a,b,c] [x,y,z]
08:05:39 <lambdabot>   [7,7,7]
08:05:44 <dolio> and use $(proj 4 2)
08:07:46 <taktoa> but I guess that's what Data.Tuple.HT is for
08:07:53 <taktoa> utility-ht is awesome
08:08:06 <copumpkin> why not the tuple package I linked to
08:08:24 <taktoa> because utility-ht also has Data.List.HT
08:08:31 <taktoa> and numerous other useful functions
08:08:35 <taktoa> like sortBy
08:08:36 * copumpkin shrugs
08:08:46 <copumpkin> you were just complaining about it not having something you wanted, weren't you?
08:09:19 <taktoa> well, it's not really that I don't have it
08:09:28 <taktoa> I just don't like importing a separate library
08:09:32 <taktoa> for something that basic
08:12:44 <rostayob> > (300 :: Word8)
08:12:45 <lambdabot>   44
08:12:55 <rostayob> can I count on this? is it in the report or something like that?
08:13:29 <Twey> shachaf: Heh fst, snd, trd, fth, fih, sxh, snh, eih, nnh, tnh, elh, twh?
08:13:30 <copumpkin> you can, but it isn't in the report
08:14:05 <arcatan> > 300 - 2^8
08:14:05 <shachaf> Twey: Seems perfectly reasonable to me.
08:14:06 <lambdabot>   44
08:14:35 <rostayob> copumpkin: ok, is there a nice way to split a Word16 in two Word8?
08:14:46 <copumpkin> not a nice way, really
08:14:50 <copumpkin> you can use Data.Bits
08:14:52 <copumpkin> and do the usual stuff
08:14:58 <dolio> preflex: 6st 1 2 3 4 5 6 7 8 9 10
08:14:58 <preflex>  1st 2rd 3th 4th 5th 6st 7rd 8th 9th 10th
08:14:59 <copumpkin> but there are at least two choices on how to split it up
08:15:15 <Twey> 6st?
08:15:29 <Twey>  7rd?  :
08:15:57 <dolio> 2rd
08:15:59 <dolio> 3th
08:16:04 <rostayob> copumpkin: what I would do is to test if it's bigger than (maxBound :: Word8), and then .&. the Word16
08:16:14 <Twey> I am confused as to the utility and purpose of this command
08:16:15 <rostayob> so that then the overflow is the higher Word8
