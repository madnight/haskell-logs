00:06:35 <ivanm> when reading .prof files, entries is the number of times a function is called, right?
00:34:04 <ClaudiusMaximus> hm, is glut Multisampling or WithSamplesPerPixel 16 meant to make my images look better?  i can't tell any difference (diagonal lines look not so hot after i mess with the colours in a shader)
00:37:38 <xAndromeda> hey can anybody explain to me why  not . ( x ) works  but not . $ x does not
00:38:09 <ion> 1 + (2) works, 1 + * 2 doesn’t.
00:38:54 <xAndromeda> not quite sure i understand, i thought the $ was like using a bracket O.o
00:39:28 <ion> ‘$’ is an infix operator just like ‘.’. Putting two infix operators next to each other is not valid Haskell.
00:39:49 <xAndromeda> Oh ok
00:39:52 <xAndromeda> thx ^_^
00:40:05 <ion> @src (.)
00:40:05 <lambdabot> (f . g) x = f (g x)
00:40:05 <lambdabot> NB: In lambdabot,  (.) = fmap
00:40:06 <ion> @src ($)
00:40:06 <lambdabot> f $ x = f x
00:40:07 <adnam> not . ($ x) works, but unnecessary
00:40:38 <ion> That has different semantics, too.
00:40:54 <shachaf> adnam: Do you mean "(not .) x"?
00:41:14 <adnam> bah
00:41:17 <shachaf> Or "(not .) $ x"? You can't eliminate the parentheses, anyway.
00:41:34 <adnam> yeah
00:41:58 <ion> Well, you can eliminate them from his original code: not . x
00:42:02 <adnam> struggling with parsec... i want option x p but i don't want it to fail if p fails, how do i go about that?
00:42:08 <shachaf> ion: Oh, well, yes, there is that.
00:43:40 <ion> option x (try p)
00:43:50 <ion> (i think)
00:44:41 <ion> “option x p tries to apply parser p. If p fails without consuming input, it returns the value x, otherwise the value returned by p.”
00:44:49 <ion> and try makes a parser not consume any input when failing.
00:45:14 <adnam> DOH
00:45:17 <adnam> i totally forgot about try
00:45:21 <adnam> thank you
00:45:51 <znutar> ClaudiusMaximus: doing 16 samples per pixel will generally make the images look smoother for reasonably normal shaders, but it's just running the pixel shader over and over with locations other than the pixel center and blending the results, so things could look weird with some shaders, especially if you get aliasing or some other interaction with the sample pattern
00:45:54 <adnam> i was trying option, optionMaybe, optianal, <|>, and then realized they were all the same in that regard
00:46:25 <znutar> sample patterns are chosen to try and avoid that, with things like solutions to the n-queens problem or whatever
00:46:27 <ion> Yeah, with <|> it would be: try p <|> pure x
00:51:19 <ClaudiusMaximus> znutar: thanks, i fiddled with my graphics driver settings which seems to have helped a fair bit too
01:03:37 <ivanm> what would be a good name for a function that re-numbers the nodes and edges of a graph (i.e. structure and labels left intact)
01:54:36 <splorgie> Is PowerPC still supported? Which GHC build should I use?
01:58:01 <ivanm> splorgie: I think it's supported but not optimised
01:59:00 <xAndromeda> in Data.Char there's a function called toTitle
01:59:03 <ivanm> splorgie: 6.10.1 has a version for OSX
01:59:07 <xAndromeda> what on earth is a title case?
01:59:17 <splorgie> Thanks, I'll try that.
01:59:39 <ivanm> xAndromeda: see the documentation
02:02:19 <xAndromeda> ivanm, how would you do that? i tried searching on hoogle but it's not really saying anything
02:02:41 <ivanm> xAndromeda: click on the link on hoogle...
02:02:46 <ivanm> or do what I did:
02:02:50 <ivanm> @google data.char toTitle
02:02:52 <lambdabot> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Char.html
02:02:52 <lambdabot> Title: Data.Char
02:03:23 <Jafet> > map toTitle "die flipperwaldt"
02:03:24 <lambdabot>   "DIE FLIPPERWALDT"
02:04:14 <xAndromeda> i guess what i meant was, does anybody know the diffrence between uppercase and titlecase or where i can find a table/definiton of it or some sort of example
02:04:17 <xAndromeda> where it's diffrent
02:05:45 <Jafet> "(Title case differs from upper case only for a small number of ligature letters.)"
02:05:52 <Jafet> Seems clear enough
02:06:36 <Jafet> > [(c,u,t) | c <- [minBound..maxBound], let t=toTitle c; u=toUpper c, t/=u]
02:06:39 <lambdabot>   [('\452','\452','\453'),('\453','\452','\453'),('\454','\452','\453'),('\45...
02:07:17 <Jafet> > text $ intercalate " | " [[c,u,t] | c <- [minBound..maxBound], let t=toTitle c; u=toUpper c, t/=u]
02:07:19 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
02:09:08 <xAndromeda> ok thx
02:09:31 <xAndromeda> lol totaly skipped over ligagure when i read taht
02:09:40 <xAndromeda> lol
02:12:41 <Jafet> I want my U+FFFFU LOL MARK (category: Po)
02:15:00 <Jafet> ghci> newListArray (0,10) "Hello world" >>= \x -> readArray x 0 -- No instance for (MArray a0 Char m0) arising from a use of `readArray'
02:15:16 <Jafet> ghci> runST $ newListArray (0,10) "Hello world" >>= \x -> (readArray :: forall s. MArray (STArray s) Char (ST s) => STArray s Int Char -> Int -> ST s Char) x 0 -- 'H'
02:46:41 <Axman6> printf "%x" 1000
02:46:44 <Axman6> > printf "%x" 1000
02:46:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
02:46:45 <lambdabot>    `Text.Printf.PrintfType ...
02:46:53 <Axman6> > printf "%x" (1000 :: Int)
02:46:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
02:46:54 <lambdabot>    `GHC.Show.Show a'
02:46:54 <lambdabot>      a...
02:46:59 <Axman6> > printf "%x" (1000 :: Int) :: String
02:47:00 <lambdabot>   "3e8"
03:31:26 <djh_> this is a long shot but I don't suppose there is a way of 'decompiling' or reverse engineering a .hi or .o file is there?
03:32:09 <djh_> a casual slip of the 'rm -rf' command has seriosuly ruined my day
03:32:13 <djh_> lesson learned etc
03:32:43 <ivanm> not really
03:32:48 <ivanm> djh_: that's what version control is for!
03:33:18 <ivanm> djh_: lemme guess: your Cabal dist folder remained?
03:33:22 <ion> and backups
03:33:30 <djh_> yep, and I'm the dunce to lazy to whack in a quick git init command :(
03:33:46 <djh_> not even that I was just messing about creating a little app
03:33:59 <djh_> no cabal setup or anything, just a few .hs files
03:34:38 <djh_> I hadn't intended on it becoming anything but after a while it developed into something usable
03:34:59 <djh_> now all I have left is a bunch of .hi and .o files because I made a typo
03:36:53 <nCdy> Hello
03:37:11 <nCdy> Does someone uses haskell shell ( alike bash )
03:38:27 <increpare> Really would like to go to the haskell hackathon in cambridge (uk), but I haven't haskelled productively in a while...need to think of something to do at it first...
03:49:06 <ivanm> *sigh* I think I worked out what my bug is... but I'm not sure how to solve it :s
03:50:34 <increpare> What's your bug?
03:51:48 <ivanm> I need to create [(Int, Int)] where sum . map fst == w and sum . map snd == w
03:52:33 <ivanm> and I then use those pairs to create something else
03:52:34 <silver> ivan, I hate that, often once I know what's the problem my motivation to solve the problem goes down ;(
03:52:52 <Jafet> [(w,w)] isn't allowed, I assume
03:53:34 <ivanm> thing is, I need the _permuted_ list... but when I do that the values are all doubled up: e.g. [(w1,b1),(w2,b2)] vs [(w2,b2), (w1,b1)]
03:53:42 <ivanm> Jafet: doesn't really matter
03:54:10 <ivanm> the problem is how do I generate them all in a unique order
03:54:25 <ivanm> oh, and I have a specified length I need the list to be
03:55:06 <increpare> "I need to create [(Int, Int)] where sum . map fst == w and sum . map snd == w" I don't understand what you want it to do
03:55:16 <increpare> by doubled up, you mean you get duplicates, and you don't really care about order?
03:55:33 <Jafet> :t combinations
03:55:34 <lambdabot> Not in scope: `combinations'
03:55:38 <ivanm> increpare: I need unique permutation of the values based upon them
03:55:49 <ivanm> I have a function to do unique permutations of a list...
03:56:00 <sanjoyd> Help: http://hpaste.org/47169/type_error
03:56:02 <increpare> you want unique permutations of....
03:56:18 <ivanm> but when I start with the same list but repeated in reverse, it gives the same permutations
03:56:54 <Jafet> What is unique permutations of?
03:57:24 <ivanm> i.e. what I really want is unique permutations of: map f $ every list of (w',b') of length n s.t. map fst == w and map snd == b
03:58:48 <ivanm> what I really need is some way of creating the (w',b') list in some specified order, but I'm not sure how to do so to guarantee that I a) create all the values I need, and b) don't create duplicates
03:59:09 <increpare> you want to remove duplicates without reordering?
03:59:13 <ivanm> in a way, it's a good thing I've found this: down the track I'll have something similar involving a third value as well
03:59:21 <Jafet> Are we supposed to know what are w,b,f
03:59:33 <ivanm> Jafet: they're fixed values/functions
03:59:33 <sanjoyd> If I have data A = M | N and data B = A | Q; why can't I have an expression of type B whose value is M?
04:00:06 <Jafet> And did you mean to type (\xs -> sum (map fst xs) == w && sum (map snd xs) == b)?
04:00:22 <ivanm> Jafet: yeah
04:00:32 <Jafet> Type slower, man
04:00:51 <ivanm> heh
04:01:04 <ivanm> dammit, reducing this to a minimal example isn't easy ;-)
04:01:27 <Jafet> sanjoyd: because M is a value of type A.
04:02:33 <Jafet> sanjoyd: data B = A | Q declares A as a constructor of B, which is totally unrelated to the type name A
04:02:36 <sanjoyd> Yes, but A is a type constructor of B, right? Is "is a type of" not transitive? Or
04:02:38 <sanjoyd> Oh, okay.
04:02:52 <sanjoyd> So is there a way I can tell Haskell that they are the "same" A?
04:02:57 <Jafet> So you end up with a type named A, a constructor named A (and a function for that constructor named A)
04:03:06 <Jafet> What would that even mean?
04:03:23 <Jafet> If you want B to contain an A, write data B = ContainsA A | Q
04:03:28 <sanjoyd> Right, does not make sense.
04:03:30 <sanjoyd> Got it.
04:03:31 <sanjoyd> Thanks.
04:03:42 <sanjoyd> Yeah, I'll do something like what you said.
04:03:47 <sanjoyd> That'll work nicely.
04:04:16 <Jafet> ivanm: you could write a quickcheck for us
04:05:46 <ivanm> Jafet: my "testing" method is: "I know how many values this should produce for these specified inputs" :p
04:05:54 <ivanm> for the entire overall program
04:06:10 <Jafet> Mmm, mystery math.
04:08:33 <Jafet> Sure it is.
04:08:51 <Jafet> Erm
04:08:54 <ivanm> Jafet: well, the solution comes from the coefficient of a certain power of x from a power series generated from repeated applications of certain rules
04:09:36 <ivanm> I've worked out the first few coefficients for testing purposes, but there's no overall equation (there is for a later bit in terms of factorials though)
04:10:03 * ivanm contemplates just using the slow working version for now and asking his supervisor on Monday
04:10:45 <Jafet> So you want to find all the combinations of something corresponding to a coefficient from a generating function
04:11:24 <ivanm> Jafet: no, my problem is how to generate a sub-part of a graph, the expected number of which is said coefficient
04:11:46 <ivanm> I can put my code up for you if you want to see
04:12:38 <Jafet> If you want.
04:16:53 <Jafet> But I'll be away for a bit now
04:17:54 <ivanm> http://hpaste.org/47170/trying_to_generate_unique_sequ
04:18:01 <ivanm> oh... just as I finished cleaning it up :p
04:18:57 <MrMovl> hi there
04:19:23 * ivanm waves in MrMovl's general direction
04:20:25 <siracusa> I'm using package random-shuffle with a function shuffle, which take the list to shuffle and an extra ``sequence (r1,...r[n-1]) of numbers such that r[i] is an independent sample from a uniform random distribution [0..n-i]''. Can anyone provide an example of such a sequence that doesn't crash the function with a pattern match error?
04:33:23 <siracusa> Aha, I misread `[0..n-i]' as `[0..n-1]', it's clear now.
04:34:43 <shurick> @hoogle (a->b)->(a->c)->(a->(b,c))
04:34:43 <lambdabot> No results found
04:35:09 <siracusa> @djinn (a->b)->(a->c)->(a->(b,c))
04:35:10 <lambdabot> f a b c = (a c, b c)
04:35:28 <siracusa> @@ @pl @djinn (a->b)->(a->c)->(a->(b,c))
04:35:29 <lambdabot>  f = liftM2 (,)
04:35:51 <shurick> I was expecting something like &&& there
04:36:21 <siracusa> I think &&& wants a pair as input
04:36:50 <siracusa> :t (&&&)
04:36:51 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:37:13 <siracusa> no, does not
04:41:23 <ivanm> > map (show &&& succ) [1..5]
04:41:24 <lambdabot>   [("1",2),("2",3),("3",4),("4",5),("5",6)]
04:41:34 <ivanm> siracusa: ^^
04:43:01 <siracusa> Yeah, just was trying to help shurick finding a function
04:46:02 <melker> hej you guys
04:46:31 <melker> Im doing this tutourial http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/First_Steps
04:46:58 <melker> and I got stuck at the read command
04:48:02 <melker> anyone here?
04:48:29 <melker> what I wanna do is convert a string into an int. Can I define an Int then?
04:48:42 <melker> something like
04:48:59 <melker> Int a = read("3")
04:49:22 <siracusa> melker: let a = read "3" :: Int
04:49:41 <melker> ah thanks alot
04:49:57 <melker> whyso the :: Int is the type declaration?
04:50:07 <melker> -why
04:50:16 <siracusa> Yes, to specialize read "3" to Int
04:50:26 <siracusa> :t read "3"
04:50:27 <lambdabot> forall a. (Read a) => a
04:50:52 <melker> ah, so it is connected to read, rather than type declaring?
04:50:54 <siracusa> It doesn't know what type to read otherwise
04:51:03 <siracusa> (or it's clear fromthe context)
04:51:06 <ivanm> melker: it needs to know how to parse the result
04:51:14 <ivanm> should it parse it as an Int, a String, etc.
04:51:15 <melker> I think i get it
04:51:34 <melker> in contrast if I wanna define an int how do I do then?
04:52:30 <melker> let x in 3 ?
04:52:41 <siracusa> > let x = 3 in x
04:52:43 <lambdabot>   3
04:53:05 <melker> and it knows it's of type int?
04:53:36 <siracusa> No, its type is Num a, since number litarals are overloaded
04:53:59 <siracusa> But you can specialize with giving type annotatzions
04:54:00 <melker> hmm dont get the last
04:54:12 <siracusa> :t 3
04:54:13 <lambdabot> forall t. (Num t) => t
04:54:27 <siracusa> So 3 can be any number, Int, Integer, ...
04:54:50 <siracusa> If you want a certain type, give it an annotation
04:55:47 <nlogax> or if you use it in some way that requires it to be an int, it will be inferred
04:56:07 <siracusa> Right, this is usually the case
04:56:54 <melker> ok thank you guys, I'll try to continue now
05:00:06 <saml> hey, regular expression is finite state automata where there's only one terminal state, right?
05:01:00 <saml> never mind
05:13:44 <saml> can two regular expressions be composed?
05:14:19 <saml> regex1  `or`  regex2
05:15:20 <saml> [(RegEx, HttpRequest -> HttpResponse)] -> HttpRequest -> HttpResponse
05:15:49 <saml> that's usually how it works. you match the http request path with each regex until you find the proper handler
05:16:19 <saml> instead of matching one by one.. i was wondering if i can compose all those regexes with one parser
05:16:32 <Bustakheops> hi
05:16:43 <saml> Bustakheops, hi
05:18:33 <Bustakheops> I have a tree and I want to traverse it and take each value in a list, it's better to use a monad isn't?
05:19:07 <saml> i guess
05:19:20 <saml> or  Tree a -> [a]   ?
05:19:36 <ivanm> @type foldM
05:19:37 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
05:19:55 <melker> what is wrong here? anybody know? args <- getArgs 	let a = read args !! 0 :: Int
05:19:58 <ivanm> is there a right monadic fold?
05:20:00 <melker> knows
05:20:10 <ivanm> melker: you need to do read (args !! 0)
05:20:19 <ivanm> because the read applies before the !!
05:20:22 <melker> thanx
05:20:23 <Bustakheops> I think y can with Tree a -> [a] but it's not beautifull to use
05:20:28 <ivanm> and it needs a String
05:21:17 <saml> i don't care for beauty. i get things done and acquire currency
05:21:55 <ivanm> saml: beautiful code is usually easier to maintain though...
05:22:09 <ivanm> which means it's easier to acquire currency later on
05:22:26 <saml> no beautful code is difficult to maintain
05:25:37 <saml> toList (Leaf x) l = a:l   ;  toList (Tree x lb rb) l = x : toList lb l  ++ toList rb []
05:25:48 <saml> Bustakheops, is your tree n-ary?
05:26:00 <saml> i fail to acquire currency
05:27:04 <Bustakheops> my tree is just like that : data Tree = Leaf Integer | Node a (Tree a) (Tree a)
05:27:17 <Bustakheops> oups data Tree a = ...
05:27:28 <saml> do you want depth first?
05:27:34 <ivanm> saml: oh? you prefer ugly, hacky code?
05:27:49 <Bustakheops> yes depth first
05:27:55 <ivanm> Bustakheops: why use a monad? just recurse!
05:28:20 <melker> wee! got it right :D
05:28:24 <melker> fanx ivanm
05:28:27 <ivanm> melker: np
05:28:32 <ivanm> Bustakheops: is this homework?
05:28:48 <saml> ivanm, i interpreted beautiful code as ph.d code
05:28:53 <Bustakheops> training only
05:29:20 <ivanm> saml: ummm.... not always
05:29:29 <ivanm> though I'm doing my best to make sure my code is beautiful
05:29:45 <saml> beauty is subjective anyways
05:30:14 <saml> i like to write code that can be maintained and collaborated with many programmers. not all ph.d. some good .. some bad.
05:30:50 <ivanm> OK: well documented and laid out code
05:30:57 <ivanm> being a PhD student has nothing to do with it
05:30:57 <saml> 4 spaces indentation!
05:31:03 <ivanm> saml: 2 spaces!
05:31:16 <ivanm> with some 4 spaces from before haskell-mode switched over... >_>
05:31:25 * ivanm really should go and fix up the indentation in graphviz at some point
05:31:31 <ivanm> preflex: seen chrisdone
05:31:31 <preflex>  chrisdone was last seen on #haskell 1 day, 14 hours, 29 minutes and 29 seconds ago, saying: rostayob: If you're interested in application development in Haskell we have jobs going. But yeah, you have to move to Italy. We get applications, but they don't want to move. Can't do anything about it, I'm afraid.
05:31:37 <saml> i mean... for Bustakheops 's case.. i would prefer simple function instead of  arrows, monads..
05:31:49 <ivanm> saml: for him, yes; because there's no need for it
05:32:05 <ivanm> but sometimes monadic and arrow functions lead to elegant code
05:32:17 <ivanm> e.g. function instance for Arrow and Monad
05:32:21 <saml> but what's beautiful solution for you for tree to list ?
05:32:24 <ivanm> @instances Arrow
05:32:25 <lambdabot> (->), Kleisli m
05:32:32 <Bustakheops> saml : ok thank's I will try with simple function
05:32:32 <ivanm> saml: direct recursion
05:32:35 <Bustakheops> :)
05:32:36 <saml> i would like to see. just curious
05:32:40 <ivanm> basically what you had
05:32:42 <saml> no.. give me arrow!
05:32:56 <ivanm> though depending upon the traversal order
05:33:01 <ivanm> saml: no need for an arrow in that case
05:33:18 <saml> lenses and frp
05:33:29 <saml> let's traverse parallel and compose one list
05:33:34 <ivanm> hell no
05:33:38 <ivanm> no need for either of those
05:33:45 <ivanm> saml: lenses are only for record datatypeps IIUC
05:34:04 <saml> yah mongodb. i put the tree in to mongodb. and use map reduce to construct the list
05:34:19 <saml> oh i read databases. /end trolling
05:34:20 <NihilistDandy> mongodb is web scale
05:36:21 * ivanm gives up on what he's working on and hits the sack
05:43:40 <jesse_> is there a possibility to convert CInt into CUInt?
05:46:31 <ion> :t fromIntegral
05:46:31 <lambdabot> forall a b. (Integral a, Num b) => a -> b
05:46:32 <luite> jesse_: fromIntegral
05:47:56 <jesse_> thx :)
05:54:56 <Spockz> according to this: http://www.haskell.org/onlinereport/decls.html the following should not work: https://gist.github.com/996852 < but it does.
05:55:40 <NihilistDandy> Why wouldn't it work?
05:56:02 <NihilistDandy> It doesn't match the first pattern, so it falls through to the second.
05:58:53 <Spockz> NihilistDandy: that's what you want yes, but when I first started with Haskell I would get some guard error on this
05:59:56 <NihilistDandy> wait... you define example3 and then call example...
06:00:18 <NihilistDandy> Or is that just incidental?
06:00:22 <Spockz> NihilistDandy: ah no, that should be example3, typo in copying
06:00:31 <NihilistDandy> Ah, okay
06:00:33 <dankna> Spockz: when you first started with Haskell you didn't understand the syntax properly and made some other mistake that you can't reconstruct now because the right way to do things is ingrained in your head :)
06:00:41 <NihilistDandy> :D
06:00:56 <dankna> I know I had things like that, haha
06:01:24 <Spockz> ah
06:01:36 <Spockz> because I really can't recall what I did differently
06:01:47 <dankna> yeah
06:01:53 <Spockz> who has 6.8 installed? :P
06:01:57 <dankna> not me
06:02:10 <NihilistDandy> Nope
06:02:25 <NihilistDandy> Oh, dankna. You'll appreciate this, maybe
06:02:32 <dankna> sure
06:02:43 <NihilistDandy> http://dl.dropbox.com/u/21008274/Hell%20Yes%20Awesome.png
06:03:03 <dankna> that's a pretty nifty desktop
06:03:08 <dankna> yours?
06:03:15 <Spockz> NihilistDandy: that looks like something from a spaceship :p
06:03:19 <dankna> I love the integration of the live information into the graphics
06:03:29 <NihilistDandy> Yeah, mine
06:03:39 <NihilistDandy> Just a bit of geektool and Photoshop
06:03:45 <dankna> nice!
06:03:50 <NihilistDandy> I even got the menubar to fade out when I'm not using it
06:03:51 <dankna> this is Linux?
06:03:57 <NihilistDandy> Nope, OS X
06:03:59 <dankna> ooh
06:04:00 <dankna> hehe
06:04:02 <dankna> nifty!
06:04:49 <dankna> now for bonus points, make it all animated, with invisible tracks that the pulses of energy travel along
06:05:13 <NihilistDandy> Actually, I might be able to pull that off with some gifs
06:05:16 <dankna> hehe
06:06:17 <dankna> I've long resisted putting live information on my desktop, because I feel it would be a distraction when I was trying to work
06:06:20 <dankna> but this is tempting :)
06:06:31 <NihilistDandy> :)
06:06:41 <NihilistDandy> Well, I can put all the files together if you ever get the urge
06:07:02 <dankna> nah half the fun would be doing it myself, but thank you
06:31:51 <Jafet> preflex, seem ivanm
06:31:58 <Jafet> preflex, seen ivanm
06:31:58 <preflex>  ivanm was last seen on #haskell 55 minutes and 38 seconds ago, saying: * ivanm gives up on what he's working on and hits the sack
06:46:02 <merijn> Fellow lambda lovers, I'm a looking for papers on (implementing) type inference and structural subtyping, any recommendations?
06:47:40 <Jafet> Like ocaml?
06:49:23 <merijn> I don't know ocaml that well, but I think they do structural subtyping as I want it, yeah
06:51:34 <Tippenein> preflex, seen bonus
06:51:35 <preflex>  bonus was last seen on #haskell 27 days, 18 hours, 39 minutes and 36 seconds ago, saying: yeah i think that's better as well
06:52:16 <dankna> huzzah, posted to cabal-devel on the support I'm working on for the building of .app bundles for the Mac.
06:52:21 <dankna> that email only took like an hour to write ><
06:52:57 <merijn> dankna: You're a hero if you get that working nicely
06:53:02 <dankna> I hope so :)
06:53:07 <dankna> I have a working prototype that uses hooks
06:53:14 <dankna> but dcoutts expressed enthusiasm for integrating it
06:54:34 <CopperKo> Hi can someone help me with a HaskellDB issue?
06:54:40 <CopperKo> *am
06:54:41 <CopperKo> *an
06:56:19 <CopperKo> Hi can someone help me with an HaskellDB issue?
06:59:06 <Cale> CopperKo: hehe, either a or an is fine depending on your accent :)
06:59:17 <Cale> er, way
06:59:50 <Cale> I see, he left.
07:01:35 <Spockz> not used to IRC I guess :p
07:02:54 <Jafet> > permutations "abc"
07:02:55 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
07:03:31 <Jafet> > map (take 5) $ permutations [1..]
07:03:32 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
07:04:01 <Jafet> Hmm, I wrote the function ivanm wanted, but it's not lazy enough for my taste
07:04:49 <Jafet> (realPermutations :: [(a, Int)] -> [[a]])
07:04:50 <ion> @src permutations
07:04:51 <lambdabot> Source not found. Do you think like you type?
07:06:58 <Jafet> permutations xs0 = xs0 : perms xs0 []; [...]
07:07:10 <Jafet> Laziness at any price.
07:14:05 <sanjoyd> Hi! I'm a haskell newbie, and would like some feedback on this piece of code I wrote: http://hpaste.org/47172/review
07:14:26 <sanjoyd> Okay, hpaste gives a few hints already.
07:16:50 <merijn> sanjoyd: Why did you bother with making lexFull return a Maybe if you only use Just anyway?
07:17:06 <merijn> oh, wait
07:17:12 <sanjoyd> Yeah, I do return a Nothing.
07:17:13 <merijn> My bad, the last case returns Nothing
07:17:28 <sanjoyd> I just discovered unfoldr, so wanted to try it.
07:18:13 <merijn> Looks reasonably readable to me (modulo some changes already suggested by HLint)
07:18:29 <sanjoyd> Yeah, fixed those.
07:18:51 <sanjoyd> I'm trying to build up to a point where I can write a compiler for some toy language.
07:19:47 <merijn> Are you building the lexer/parser for learning purposes? If not you might want to check out (atto)parsec for lexing/parsing
07:20:17 <sanjoyd> Yes, I'm building it for learning purposes.
07:20:26 <sanjoyd> I know about parsec, but I've never used it.
07:20:40 <sanjoyd> I'll get to it as I get more comfortable.
07:29:30 <navaati> hello
07:30:15 <navaati> is there somewhere a type class that is monoid without mappend (a typeclass that provides a default value)
07:30:35 <navaati> i din't found it in category-extra
07:31:51 <aavogt> http://hackage.haskell.org/packages/archive/data-default/0.2.0.1/doc/html/Data-Default.html
07:32:16 <navaati> ah, nice, thank you
07:33:11 <aavogt> there are probably others too
07:40:21 <aavogt> is there an alternative to http://hackage.haskell.org/package/ipprint which works with ghc-7?
07:40:37 <aavogt> oh I guess version 0.3
07:51:52 <adorablepuppy> Hello
07:53:02 <tswett> Ello.
07:56:02 <lukas2> quit
07:56:06 <melker> hey
07:56:20 <aavogt> http://hpaste.org/47174/monadlogic_ugliness
07:56:22 <melker> has anyone heard of modelica here?
07:56:49 <adorablepuppy> I've got a tree structure with n branches at each node. Is there any reasonable way to handle inserts?
07:57:22 <aavogt> you need to make a new node
07:58:01 <melker> it's a physical modelling language, that is equation based. Does anyone have an idea if haskell would suite for compiling modelica code and generate C code (or perhaps haskell code) beeing sent into a simulator engine
07:58:09 <merijn> adorablepuppy: What do you mean by "reasonable way to handle inserts"?
07:58:41 <adorablepuppy> merijn: Well, I'm having trouble wrapping my head about rebuilding the tree.
07:58:42 <merijn> melker: You mean writing the Modelica-to-C compiler in Haskell?
07:59:28 <melker> merijn exactly
07:59:39 <melker> @merijn yes
07:59:39 <lambdabot> Unknown command, try @list
07:59:43 <melker> ;)
07:59:48 <merijn> melker: Haskell is excellent for writing compilers
08:00:27 <aavogt> it still seems challenging
08:00:45 <merijn> melker: Check out parsec/attoparsec for parsing (Real World Haskell has a chapter on using parsec for parsing)
08:00:58 <melker> it needs to be able to do equation sortings and symbolic differentiation and equation solving too. Im not asking for existing packages, but rather if it would be possible (without too much effort) to implement that
08:01:11 <aavogt> @hackage ad
08:01:11 <lambdabot> http://hackage.haskell.org/package/ad
08:01:13 <tommd> preflex: seen hydo
08:01:13 <preflex>  hydo was last seen on #haskell 1 day, 20 hours, 42 minutes and 11 seconds ago, saying: > :t readLn
08:01:39 <merijn> adorablepuppy: You make a copy of the initial node and replace one of its children with "insert newNode childTree", repeat recursively until you reach the place you wanted to insert the new value
08:01:47 <tommd> @tell hydo Shoot your question here or on e-mail, I'm here all week days (and weekends..)
08:01:47 <lambdabot> Consider it noted.
08:02:07 <aavogt> @hackage hmatrix -- has a gsl binding, which could be useful
08:02:07 <lambdabot> http://hackage.haskell.org/package/hmatrix -- has a gsl binding, which could be useful
08:02:18 <dankna> oh cool!  hs_add_root() is now an nop and the relevant work is done automatically!
08:02:23 <dankna> that saves a bunch of trouble
08:02:40 <merijn> melker: I'd say its possible to implement (and probably easier to do in Haskell then other languages)
08:02:46 <Justin-Sane> 4**2.7297158093186486
08:03:03 <melker> merijn: is fast too?
08:03:14 <melker> how do I write your name in red
08:03:15 <vitka> > 4**(exp 1)
08:03:16 <lambdabot>   43.30806042677592
08:03:35 <Justin-Sane> > 4**2.7297158093186486
08:03:36 <lambdabot>   44.0
08:04:14 <aavogt> is there a way to have less possibilities than this 'generalization' of Either (Maybe a) Int: http://hpaste.org/47177/instance_overlap
08:04:14 <tommd> melker: It's just a feature of some IRC clients.  If you're nick name is mentioned some will highlight and beep, or maybe one of the two, or nothing.
08:04:35 <melker> thanks
08:05:37 <merijn> Yeah, mine automatically highlights any lines starting with "merijn:" or "merijn,"
08:05:45 <merijn> (and probably some others too)
08:06:04 <melker> merijn: I'm quite new to modelica and definitely to haskell. so it's a future project
08:06:49 <merijn> melker: Not knowing how much computational work it is to compile what you want I can't say for sure, but I'm 95% certain Haskell will be more then fast enough for compiling
08:11:13 <melker> Im just looking at the possibility, and as for now it seems like a good thing. but what do say about the question I had before? it needs to be able to do equation sortings and symbolic differentiation and equation solving too. Im not asking for existing packages, but rather if it would be possible (without too much effort) to implement that
08:11:54 <merijn> Sure
08:12:26 <melker> awsome :)
08:12:46 <melker> awesome
08:12:51 <melker> ::P
08:13:44 <tommd> What is type "P"?
08:13:45 <melker> so is compiling one of haskells main usages?
08:14:01 <aavogt> melker: did you look at my hackage links?
08:14:36 <melker> no please post the link again
08:14:58 <aavogt> @hackage ad
08:14:58 <lambdabot> http://hackage.haskell.org/package/ad
08:15:04 <aavogt> @hackage hmatrix
08:15:04 <lambdabot> http://hackage.haskell.org/package/hmatrix
08:16:22 <Axman6> melker: there's a good reason why most (all?) haskell compilers are written in haskell, and why the first perl6 implementation, pugs, was written in haskell
08:16:41 <Axman6> it's got all the tools you need to make a compiler wuite "easily"
08:16:45 <aavogt> hugs is in C apparently
08:16:58 <Axman6> really? ouch
08:17:07 <merijn> aavogt: Hugs is just an interpreter though, isn't it?
08:17:28 <aavogt> that may be part of the reason why it hasn't kept up with ghc
08:18:16 <aavogt> merijn: yes
08:18:19 <Axman6> can't imaging it would be that easy to add all the extensions GHC has implemented
08:18:49 <melker> this is great aavogt
08:18:56 <aavogt> well it has quite a few of the useful ones
08:19:30 <merijn> Speaking of all this
08:19:53 <merijn> As I asked earlier, anyone here that can recommend any papers on (implementing) type inference and structural subtyping?
08:21:40 <kelseyhightower> Hello, I am new to Haskell, trying to figure out how to turn the string '110' into an integer 6. Any suggestions, I don't mind RTM, but having a hard time finding it.
08:22:18 <dankna> @hoogle readBase
08:22:18 <lambdabot> No results found
08:22:19 <dankna> @hoogle base
08:22:19 <lambdabot> package base
08:22:20 <lambdabot> Text.Html base :: String -> HtmlAttr
08:22:20 <lambdabot> Text.XHtml.Frameset base :: String -> HtmlAttr
08:22:20 <merijn> kelseyhightower: read
08:22:24 <dankna> @hoogle Base
08:22:24 <lambdabot> module Control.Exception.Base
08:22:24 <lambdabot> module Network.HTTP.Base
08:22:24 <lambdabot> module Test.HUnit.Base
08:22:28 <dankna> no, he wants to read it as binary
08:22:33 <merijn> oh
08:22:35 <merijn> Duh
08:22:42 <dankna> @hoogle readHex
08:22:43 <lambdabot> Numeric readHex :: Num a => ReadS a
08:22:43 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
08:22:43 * merijn shuts up
08:22:54 <kelseyhightower> dankna: yep
08:22:57 <dankna> @hoogle Num a => ReadS a
08:22:57 <lambdabot> Numeric readDec :: Num a => ReadS a
08:22:57 <lambdabot> Numeric readHex :: Num a => ReadS a
08:22:57 <lambdabot> Numeric readOct :: Num a => ReadS a
08:23:05 <dankna> looks like you may have to write it yourself, heh
08:24:26 <aavogt> > let readBin str = sum $ zipWith (\c n -> if c == '1' then n else 0)  (reverse str) (iterate (2*) 1) in [readBin "110", readBin "101"]
08:24:27 <lambdabot>   [6,5]
08:24:27 <merijn> Can't be that hard...
08:24:54 <aavogt> golf time?
08:25:45 <kelseyhightower> dankna: aavogt, that looks like what I want. I will have to study the syntax a bit since I'm a rookie. Thanks
08:25:52 <dankna> np
08:26:21 <Axman6> > foldl (\acc c -> if' (c == '0') (+0) (+1) $ acc) 0 "110"
08:26:22 <lambdabot>   Not in scope: `if''
08:26:29 <Axman6> bah
08:26:38 <Axman6> > foldl (\acc c -> if (c == '0') then (+0) else (+1) $ acc) 0 "110"
08:26:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:26:39 <lambdabot>    arising from a use of `...
08:27:01 <Axman6> > foldl (\acc c -> (if (c == '0') then (+0) else (+1)) acc) 0 "110"
08:27:02 <lambdabot>   2
08:27:05 <Axman6> :\
08:27:21 <Axman6> > foldl (\acc c -> (if (c == '0') then (+0) else (+1)) $ 2*acc) 0 "110"
08:27:22 <lambdabot>   6
08:27:23 <dankna> > '1' - '0'
08:27:24 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:27:24 <lambdabot>    arising from a use of `GHC....
08:27:25 <Axman6> better
08:27:26 <dankna> bah
08:27:30 <Axman6> > foldl (\acc c -> (if (c == '0') then (+0) else (+1)) $ 2*acc) 0 "1100110101"
08:27:31 <lambdabot>   821
08:27:38 <Axman6> > foldl (\acc c -> (if (c == '0') then (+0) else (+1)) $ 2*acc) 0 "101010"
08:27:39 <lambdabot>   42
08:27:40 <ion> > let readBin = foldl' (\acc x -> acc `shiftL` 1 .|. digitToInt x) 0 "110"
08:27:40 <lambdabot>   not an expression: `let readBin = foldl' (\acc x -> acc `shiftL` 1 .|. digi...
08:27:54 <ion> > let readBin = foldl' (\acc x -> acc `shiftL` 1 .|. digitToInt x) 0 in readBin "110"
08:27:55 <lambdabot>   6
08:28:23 <dankna> yes, but ion, the shiftL solution requires a Bits instance, not just a Num instance
08:28:24 <kelseyhightower> to say the least, I am totally impressed by the lambdabot
08:28:41 <dankna> yeah, lambdabot is nice
08:28:42 <dankna> @botsnack
08:28:42 <lambdabot> :)
08:29:10 <cncl> is there a 'variable state' monad transformer on hackage or the like?
08:29:20 <cncl> this is what i'm talking about
08:29:21 <cncl> oops
08:29:24 <cncl> http://okmij.org/ftp/Computation/monads.html#param-monad
08:29:24 <Axman6> also `shiftL` 1 is the same as *2 anyway, in this case
08:29:35 <ion> > let readBin = readBase 2; readBase b = foldl' (\acc x -> acc*b + digitToInt x) 0 in readBin "110"
08:29:36 <lambdabot>   6
08:29:38 <cncl> or this http://blog.sigfpe.com/2009/02/beyond-monads.html
08:30:30 <ion> > let readBin = readBase 2; readBase b = foldl' (\acc x -> acc*b + (fromIntegral . digitToInt) x) 0 in readBin "110" :: Rational
08:30:31 <lambdabot>   6 % 1
08:30:39 <aavogt> maybe you should just use ST?
08:31:09 <aavogt> oh but it's not available as a transformer
08:31:18 <cncl> aavogt: me?
08:33:17 <aavogt> cncl: yes
08:33:26 <cncl> maybe you misunderstood my question
08:33:35 <cncl> i don't need state that is mutable in-place
08:33:49 <cncl> i need something that is like a monad but where the type of the state can be changed
08:33:58 <cncl> a parameterized monad
08:34:04 <dankna> StateT
08:34:08 <sipa> do you know the possible types in advance?
08:34:39 <dankna> StateT, if you mean "can be changed at the time you enter the monad", not "can be changed in the middle of running code in the monad"
08:34:40 <cncl> dankna: StateT is State as a monad transformer, you can't change the type of 's' in StateT s m a
08:34:56 <cncl> yeah it has to be able to change with each bind
08:35:06 <dankna> ah - so you mean the latter.  what are you doing exactly?
08:35:12 <cncl> sipa: i'm not sure what you mean
08:35:17 <aavogt> cncl: I mean you can explicitly pass STRefs around
08:35:26 <cncl> i have a state type that's GADT'd
08:37:34 <cncl> for example, i have a datatype 'Block vars fns ret' describing an abstract block of code with variable declarations, named functions, and a potential return type
08:37:58 <rainsev> help me
08:38:08 <cncl> where 'Block vars fns ret' is the type, not a data construction
08:38:32 <dankna> rainsev: invest in consumer electronics manufacturers
08:38:37 <cncl> then i have a function, for example, which adds a named function to the block of code
08:39:09 <cncl> and this changes its type like so: Block vars fns1 ret -> Block vars fns2 ret
08:39:11 <rainsev> can i use foldr and map for this example : input : try 4 and output will be [1,3,6,10] ?
08:39:40 <dankna> rainsev: I don't understand what the example is doing
08:39:43 <cncl> so if i want to be able to use Block a b c in a state/statet monad-like-thing, i need to be able to change the type of the state
08:40:33 <dankna> cncl: the way I would do it is with an existential datatype, like so
08:40:44 <rainsev> dankna : you enter an integer example 4 and the output will be list of integer that [1,1+2,1+2+3,1+2+3+4]
08:40:54 <dankna> cncl: data AnyBlock = forall a . Block a
08:41:14 <dankna> cncl: this entails some restrictions on what you can do with it though
08:41:21 <rainsev> dankna : can i use prelude function , foldr and map ?
08:41:35 <dankna> rainsev: certainly.  you can use anything you want.
08:42:10 <dankna> cncl: might be wise to name the data constructor SomeBlock instead of just Block, to avoid confusion
08:42:24 <cncl> dankna that wouldn't work in this case
08:42:30 <dankna> cncl: why not?
08:42:32 <cncl> the type information can't be discarded
08:42:34 <rainsev> dankna : so, can you tell me how to use foldr and map for that case? thanks anyway
08:42:39 <cncl> otherwise you can't deconstruct the gadts later on
08:42:45 <dankna> rainsev: are you asking me to write your homework answer for you?
08:42:51 <rainsev> no no
08:42:53 <rainsev> i try
08:42:57 <rainsev> but i can't
08:43:07 <rainsev> there's no homework, i just want to know..
08:43:27 <hiptobecubic> Are any of you professional haskellers, in the literal sense? If so, what are you actually doing at work, if I may ask?
08:43:42 <dankna> cncl: it's not discarding it, it can be retrieved.  it's just you can't do anything to the value inside the existential that depends on which type it is.
08:44:02 <alexbagel> rainsev: scanl might be your friend
08:44:18 <rainsev> dankna : sorry, i spent 1 hours for solve this case, but i coldn't find the right solution..
08:44:27 <cncl> dankna: in this case it won't work, i have to be able to pattern match
08:44:38 <Axman6> hiptobecubic: there are plenty. look at Galois' web site for some idea. they've done lots of crypto work and some high assurance work for small groups like NASA
08:44:42 <Axman6> :P
08:44:51 <cubi> I hate my nick :(
08:44:58 <hiptobecubic> cubi, me too
08:45:00 <Axman6> tough, you're stuck with it
08:45:03 <cubi> hrhr
08:45:46 <dankna> cncl: I'm pretty sure I've done things like this with existentials before.  there are restrictions, but you /can/ pattern match it.  if this scenario is different, I don't yet see how.
08:46:17 <dankna> cncl: the pattern to match on would look like "SomeState (State blah blah blah)"
08:46:25 <rainsev> alexbage1 : what do you mean? if you can't help me, it's okay.
08:46:51 <cncl> dankna how do i pattern match something if its parameterized type is discarded?
08:46:56 <hiptobecubic> Axman6, what is "Galois' website" ?
08:47:17 <Axman6> http://corp.galois.com/
08:47:18 <dankna> cncl: it's not discarded, merely hidden inside the existential.
08:47:30 <dankna> @google haskell existential types
08:47:31 <hiptobecubic> Axman6, thanks
08:47:31 <lambdabot> http://www.haskell.org/haskellwiki/Existential_type
08:47:31 <lambdabot> Title: Existential type - HaskellWiki
08:47:46 <Axman6> some banks are also using haskell
08:47:50 <Saizan> cncl: if you have Foo a where a is existentially quantified you can still pattern match on it because you know the constructors of Foo
08:47:55 <hiptobecubic> Axman6, seriously?
08:47:58 <Axman6> yes
08:47:58 <Saizan> cncl: anyhow http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed-State.html
08:48:05 <hiptobecubic> Axman6, to do what?
08:48:16 <Axman6> http://www.haskell.org/haskellwiki/Haskell_in_industry
08:48:19 <cncl> Saizan: ah awesome thanks
08:48:21 <hiptobecubic> Axman6, thanks
08:48:24 <Axman6> i can't remember exactly
08:48:51 <Axman6> AT&T use it too apparently
08:49:46 <rainsev> so arrogant,
08:50:03 <Axman6> ah that's right, Credit Suisse are the ones i think i was thinking of
08:50:39 <cncl> Axman6: also tsuru :)
08:50:50 <Axman6> hiptobecubic: i get the feeling you're under the impression Haskell is a toy language
08:50:58 <Axman6> cncl: indeed :)
08:51:24 <Axman6> hiptobecubic: i had an internship with Tsuru capital in Tokyo programming haskell
08:51:51 <Axman6> heh, i forgot Google had used some haskell too
08:52:34 <hiptobecubic> Axman6, no it's just talked about like it's only used for formal work in academia. I'd really like to find some way to make money as a computational scientist without selling my soul to the dark secrets of gcc
08:52:38 <Axman6> "Qualcomm uses Haskell to generate Lua bindings to the BREW platform" heh, not sure why that made me laugh
09:04:36 <cncl> Saizan: that package is obsolete, apparently
09:05:42 <cwb> hiptobecubic: I'm using Haskell for contract work so that's one way to get to use it.
09:06:21 <Saizan> cncl: yeah, it got splitted, but i don't know where the indexed monads went
09:06:25 <hiptobecubic> cwb, hmmm, I suppose so. Did they give you freedom to implement it however you wanted or did they ask for haskell?
09:06:58 <cncl> Saizan: http://hackage.haskell.org/package/monad-param ?
09:07:09 <cncl> looks like this will work
09:07:11 <cwb> They gave me the freedom -- or rather, I suggested it as the best approach explaining the advantages/drawbacks.
09:07:38 <cwb> The project actually started using Python.
09:08:11 <cncl> also, i can't use existentials to hide the type, at the very least i will get occurs check/infinite type errors
09:10:47 <cncl> ouch, i lose a lot of type inference with this
09:11:01 <cncl> and monad transformers lose some of the auto-plumbing
09:12:44 <hiptobecubic> Axman6, i want to work here :D
09:13:00 <Axman6> where is hear?
09:35:57 <hiptobecubic> Axman6, galois :)
09:39:20 <kelseyhightower> ion: question, I don't quite understand the '0 in readBin' part. I understand the left fold and the recursion going on. In my function I ended up writing this "stToNum s = foldl (\acc x -> acc*2 + digitToInt x) 0 s". I also understand how your solution makes  this work with more than base 2. But I would really like to know whats going on with '0 in readBin'
09:40:09 <Cale> kelseyhightower: In what code?
09:40:27 <kelseyhightower> Cale
09:40:32 <kelseyhightower> Cale: let readBin = readBase 2; readBase b = foldl' (\acc x -> acc*b + digitToInt x) 0 in readBin "110"
09:40:39 <Cale> okay, so you know about let?
09:40:44 <kelseyhightower> yep
09:40:50 <Cale> let <declarations> in <expression>
09:41:16 <Cale> is an expression form, where the declarations made in the 'let' part are available in the expression after the 'in'
09:42:15 <Cale> So, to add some punctuation, it's   let { readBin = readBase 2; readBase b = foldl' (\acc x -> acc*b + digitToInt x) 0 } in (readBin "110")
09:43:35 <kelseyhightower> and since foldl requires 3 args readBin is a function expecting the final arg, a list in this case
09:44:21 <kelseyhightower> Cale: is that correct ^^
09:44:39 <Cale> yeah
09:45:11 <kelseyhightower> Cale: I get it now!!! Sorry for the silly question, I am a Python guy learning haskell
09:45:22 <Cale> Every function in Haskell really takes only one parameter. Any function appearing to take more is really producing another function to eat the remainder of the parameters.
09:46:03 <Cale> When you write  f x y z  it really means  ((f x) y) z
09:46:21 <kelseyhightower> yeah, I learned that after reading about how lambda calculus works and how Haskell implements function calls
09:46:23 <dolio> Or it's taking a tuple.
09:46:29 <kelseyhightower> This is really cool
09:47:34 <aavogt> do people here actually thing about functions as taking one parameter and returning another function (besides when explaining things)?
09:47:47 <jmcarthur> i almost always do
09:47:57 <kelseyhightower> aavogt: I do now, when using Haskell
09:48:06 <aavogt> instead of 'foldr takes 3 argument (except when the accumulator is a function)'
09:48:12 <Jafet> @tell ivanm http://hpaste.org/47181/successfully_generating_unique
09:48:12 <lambdabot> Consider it noted.
09:48:40 <aavogt> @ty \f g -> foldr f (g `asTypeOf` ($))
09:48:41 <lambdabot> forall a a1 b. (a -> ((a1 -> b) -> a1 -> b) -> (a1 -> b) -> a1 -> b) -> ((a1 -> b) -> a1 -> b) -> [a] -> (a1 -> b) -> a1 -> b
09:48:57 <jmcarthur> i consider it to be more of a point-of-view kind of thing, but my code tends to take the "the result is a function" view a lot
09:49:13 <jmcarthur> i even put redundant parens on some of my type signatures a lot
09:49:21 <Jafet> @tell ivanm There are more efficient ways to implement `multis', but I settled on this one because it's lazy and produces the correct order
09:49:21 <lambdabot> Consider it noted.
09:49:32 <jmcarthur> e.g.   fmap :: (a -> b) -> (f a -> f b)
09:49:34 <aavogt> and to simplify things further, integers are also inductive in your mind?
09:49:40 <jmcarthur> err, with a Functor constraint of course
09:49:55 <jmcarthur> no i wouldn't say that
09:50:12 <jmcarthur> the inductiveness of integers doesn't really affect my code
09:50:22 <jmcarthur> at least not without the ability to pattern match on them
09:50:31 <aavogt> n+k patterns
09:50:47 <jmcarthur> deprecated
09:52:05 <aavogt> perhaps this "every function has one argument" state of mind, is more directly expressed as "type variables may contain ->"
09:52:15 <jmcarthur> n+k would be awesome to bring back if we got lazy nats and lazy integers
09:53:24 <jmcarthur> that is possible
09:55:20 <dolio> Integers aren't inductive in a very useful way usually.
10:16:15 <Eliel> Double doesn't appear to have Integral instance so I can't use mod function with them. Is there a function that does the same but works for Doubles?
10:16:56 <dankna> @hoogle RealFrac a => a -> a -> a
10:16:56 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:16:56 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
10:16:56 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
10:17:04 <dankna> @hoogle RealFrac a, Integral b => a -> a -> b
10:17:04 <lambdabot> Parse error:
10:17:04 <lambdabot>   --count=20 "RealFrac a, Integral b => a -> a -> b"
10:17:04 <lambdabot>                        ^
10:17:19 <dankna> @hoogle Fractional a => a -> a -> a
10:17:19 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
10:17:19 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:17:19 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
10:17:26 <dankna> @hoogle Num a => a -> a -> a
10:17:27 <lambdabot> Prelude (*) :: Num a => a -> a -> a
10:17:27 <lambdabot> Prelude (+) :: Num a => a -> a -> a
10:17:27 <lambdabot> Prelude (-) :: Num a => a -> a -> a
10:17:31 <dankna> @hoogle mod
10:17:31 <lambdabot> Prelude mod :: Integral a => a -> a -> a
10:17:31 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
10:17:31 <lambdabot> Text.PrettyPrint.HughesPJ data Mode
10:17:48 <dankna> @hoogle mod'
10:17:48 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
10:17:48 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
10:17:51 <dankna> huh
10:17:59 <dankna> looks like Data.Fixed has mod' which should work
10:18:13 <Eliel> I'll take a look, thank you :)
10:18:20 <dankna> > Data.Fixed.mod' (99.0 :: Double) (10.0 :: Double)
10:18:20 <lambdabot>   9.0
10:18:22 <dankna> yeah
10:18:26 <dankna> np :)
10:19:21 <Eliel> > Data.Fixed.mod' (99.9 :: Double) (10.0 :: Double)
10:19:22 <lambdabot>   9.900000000000006
10:19:34 <Eliel> ... well, good enough I guess :)
10:19:41 <dankna> heh yeah :)
10:20:02 <dankna> that's simply the usual floating-point issue, which you would have no matter what
10:21:23 <Eliel> although, I have to wonder how come the regular mod doesn't have the typeclass instance for Integral. Doesn't sound at all unusual that people would use those with floats.
10:21:40 <dankna> well, you don't actually want it to be a single function that works on both
10:21:56 <dankna> because integer modulus is exact, whereas floating-point modulus is subject to precision issues
10:22:30 <dankna> you also don't want an instance Integral Double, because that would falsely tell the compiler that doubles are whole-number values!
10:23:23 <Favonia> Eliel: I also wish that fold, map... can be overloaded :P
10:23:40 <Eliel> Favonia: I agree on that :)
10:23:44 <dankna> so you have to have a different name for it depending on whether you want integer modulus or floating-point modulus.  this is a consequence of not having Smalltalk-style (also C++-style) polymorphism.
10:24:21 <Eliel> dankna: do you have a concrete example of what trouble it would create to have Double have an Integral instance?
10:24:30 <dankna> I can come up with one, give me a sec
10:25:44 <Favonia> Eliel: I hope Data.Foldable could be the default :)
10:26:56 <dankna> for example, Data.Ratio has a type for ratios of integers, declared as data Integral a => Ratio a
10:27:15 <jmcarthur> Favonia: map is overloaded by fmap
10:27:38 <dankna> you clearly want it to be impossible to form a ratio of two floating-point values, because it would be meaningless (would not be a ratio in the mathematical sense, and could not be compared for equality with other ratios)
10:27:43 <jmcarthur> Favonia: and fold is overloaded by Foldable, but it's also a bit more generally overloaded in the recursion-schemes package
10:28:11 <Favonia> jmcarthur: ah yes, you're right.
10:28:20 <Favonia> jmcarthur: cool I'll take a look. thanks
10:28:46 <jmcarthur> Favonia: something like the bananas, lenses, and barbed wire paper might be prerequisite material for that package, btw
10:29:11 <dankna> if your hypothetical instance existed, doing (4 :: Int) / (5 :: Int) would have even more possible result types than it does presently (at the moment it can be any type that's an instance of Real, I believe)
10:29:20 <dankna> (both Double and Ratio Int are instances of Real)
10:29:24 <Eliel> Favonia: that looks like a nice package. Only, it's missing map.
10:29:35 <dankna> (and if the typeclass Integral Double existed, Ratio Double would be one too)
10:29:50 <jmcarthur> Eliel: what package?
10:30:01 <dankna> :t (/)
10:30:02 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:30:05 <Eliel> jmcarthur: Data.Foldable
10:30:08 <Favonia> Eliel: I think jmcarthur is making a better argument :P
10:30:11 <jmcarthur> Eliel: ah, that's a module
10:30:14 <dankna> ah, s/Real/Fractional/ in that explanation
10:30:20 <jmcarthur> Eliel: anyway, map is overloaded by fmap (in the Functor class)
10:30:47 <Eliel> does fmap work as map for arrays too?
10:31:20 <parcs> most likely
10:31:32 <jmcarthur> depends on the type of array
10:31:51 <jmcarthur> you can't make a functor instance for storable arrays or unboxed arrays, sadly
10:32:35 <Favonia> Eliel: hmm... Ix i => Functor (Array i)  for 'normal' Arrays
10:32:52 <Eliel> ah, that's a good thing to remember :)
10:34:11 <Eliel> no functor for vectors though
10:34:40 <jmcarthur> yeah that's dumb
10:54:36 * hackagebot waitfree 0.1.4 - A wrapping library for waitfree computation.  http://hackage.haskell.org/package/waitfree-0.1.4 (YoichiHirai)
10:56:27 <aavogt> @hoogle Either a b -> Bool
10:56:27 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
10:56:28 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
10:56:28 <lambdabot> Data.Graph.Inductive.Basic isSimple :: Graph gr => gr a b -> Bool
10:57:06 <aavogt> @djinn f :: Either a b -> Bool
10:57:06 <lambdabot> Cannot parse command
10:57:13 <aavogt> @djinn Either a b -> Bool
10:57:13 <lambdabot> f a =
10:57:13 <lambdabot>     case a of
10:57:13 <lambdabot>     Left _ -> False
10:57:13 <lambdabot>     Right _ -> True
10:57:26 <aavogt> is there such a function somewhere?
10:58:03 <geheimdienst> @hoogle isLeft
10:58:04 <lambdabot> No results found
10:58:07 <geheimdienst> @hoogle isRight
10:58:07 <lambdabot> No results found
10:59:58 <geheimdienst> aavogt: hayoo gives a number of functions, but they don't seem to be in top well-known packages
10:59:59 <geheimdienst> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=isleft#0:Either%20a%20b%20-%3E%20Bool
11:02:17 <aavogt> are any people familiar with hint? I want to automate what happens when you run ghci, then :l file1\n :l file2\n , then say whether the files were acceptable to ghc
11:03:54 <aavogt> the obvious thing   runInterpreter (mapM (\m -> fmap (const True) (loadModule [m]) `catch` \SomeException {} -> return False) files) -- the exception gets caught by runInterpreter somewhere, not my catch
11:04:23 <geheimdienst> "ghc --make file{1,2,3}.hs" is not an option?
11:04:37 <aavogt> I don't want to rely on ghc's output formatting
11:05:02 <hpc> @hoogle runInterpreter
11:05:02 <lambdabot> No results found
11:05:07 <aavogt> @hackage hint
11:05:07 <lambdabot> http://hackage.haskell.org/package/hint
11:05:12 <hpc> ah
11:05:28 <aavogt> anyways, it works to call runInterpreter many times
11:05:38 <aavogt> but this will be too slow I expect
11:05:52 <geheimdienst> i think you'd only have to check if ghc returned exit status 0 or not ...
11:08:22 <aavogt> geheimdienst: I expect many of the files to fail
11:08:44 <aavogt> so the exit code isn't going to be enough to know which files are ok
11:11:03 <chrisdone> Oh.
11:11:56 <chrisdone> I was about to send “How do you make a tuple in template haskell?” Until I searched the docs page again for 'tup' and by change it jumped to `tupE'. ~_~
11:11:56 <tg_> q: when I see a "|" in a class Blargh e a | e -> a where ... line, what is that called?
11:12:03 <dankna> yeah
11:12:06 <tg_> and/or which language extensions are related to it?
11:12:19 <dankna> remember, tupE 0 is (), tupE 1 is (a), tupE2 is the first actual tuple
11:12:37 <chrisdone> That much is clear.
11:12:44 <dankna> tg_: functional dependencies
11:12:53 <tg_> dankna: thx
11:13:12 <dankna> tg_: what the "| e -> a" syntax means is "any choice of a specific type for e implies a choice of a specific type for a"
11:13:46 <tg_> dankna: so if you have something like:
11:13:53 <tg_> class Blargh s t | s -> t, t -> s where
11:14:24 <tg_> first, that is the same as:
11:14:31 <dankna> that means that any s implies a t, and any t also implies an s.  so you could not have instance Blargh Alpha Foo and also instance Blargh Beta Foo.
11:14:32 <tg_> class Blargh s t | t -> s, s -> t where?
11:14:42 <Axman6> then if you have an instance Blarg Int String, then you can’t have Blarg Int Bool
11:14:58 <dankna> yes, that is the same as what you just said, the order in which the constraints are specified doesn't matter
11:15:09 <tg_> ok, that make sense
11:15:23 <tg_> what other jargon surrounds this?
11:15:31 <geheimdienst> what do you mean when you say "any s implies a t"?
11:15:38 <dankna> multi-parameter type classes are when you have class Blargh s t, instead of just class Blargh s
11:15:52 <tg_> geheimdienst: I don't know, I am learning someone else's undocumented code as an exercise, so I don't know what it means yet :o
11:16:29 <geheimdienst> tg_: i intended my question more for other folks in here :)
11:16:34 <tg_> geheimdienst: oh ok
11:16:52 <tg_> so FunDeps and MultiParamTypeClasses go hand-in-hand
11:16:54 <dankna> geheimdienst: what it means is that for the purpose of type inference, if it sees a value of type "(Blargh Alpha a) => a", and there exists an instance Blarg Alpha Foo, then it can infer that the concrete type of "a" is "Foo"
11:17:13 <Axman6> geheimdienst: if you have ... | a -> b, then the choice of b is dertermined by the type of a. there can be many a's that imply a certain b, but each a can only have a certain b
11:17:24 <tg_> dankna: which means it can infer everything about that type, yes? (Blargh Alpha Foo => Foo)?
11:17:32 <dankna> tg_: yes
11:17:47 <tg_> dankna: which is what normally happens if you didn't have MultiParam or FunDeps
11:17:52 <aavogt> it means you can't write as many instances
11:18:02 <dankna> tg_: well, what do you mean "normally happens" - you can't do this at all without muli-param
11:18:15 <tg_> dankna: well I mean, it's a way of recovering type inferrence after introducing multi-param
11:18:22 <tg_> whereas otherwise you would be lost
11:18:33 <dankna> tg_: yes, I thought that's what you were getting at, and it is correct, but I wanted to make you say it explicitly :)
11:18:53 <Axman6> so you could have class Container a b | a -> b where head :: a -> b; and instance Container ByteString Word8. now you can't have another instance Container ByteString Char, becaue the instance for ByteString has already been used, and you've said that ByteStrings contain Word8's
11:19:03 <tg_> so you introduce multi-param to get the wildly powerful type classes, and then you introduce FunDeps to give some information back to the compiler
11:19:19 <dankna> tg_: note that if you have "class JustOneParameter a", and "instance JustOneParameter Foo", and a value of type "(JustOneParameter a) => a", you can /not/ infer that the type of "a" is "Foo"
11:19:28 <dankna> tg_: yes, precisely so
11:19:34 <tg_> dankna: but you can infer that the kind of a is *
11:19:39 <tg_> or something along those lines?
11:19:53 <dankna> tg_: well, the kind of /any/ value is *
11:20:09 <aavogt> but -XFlexibleInstances/-XFlexibleContexts came before MPTCs?
11:20:16 <dankna> aavogt: not sure, I think so?
11:20:23 <geheimdienst> thanks for the explanation so far, guys
11:20:28 <dankna> geheimdienst, np
11:20:37 <dankna> (is gehmehgeh == geheimdienst ?)
11:21:02 <dankna> (I can't believe I have to type four letters of your nick to complete it, haha)
11:21:04 <geheimdienst> i don't know about "gehmehgeh"
11:21:14 <dankna> haha then it's not, don't worry about it
11:21:31 <geheimdienst> for reference i am also /= djahandarie
11:21:41 <dankna> yes, I am /= djahandarie, as well
11:21:46 <geheimdienst> even if shachaf keeps claiming the opposite
11:21:49 <dankna> haha
11:21:50 <dankna> I see
11:22:42 <geheimdienst> i think from these 2 data points we can generalize that everyone /= djahandarie, except for djahandarie
11:22:57 <dankna> well, presumably he has at least one alias, that being his legal name
11:26:08 <k0ral> what's the difference between a Text and a String ?
11:26:34 <dankna> a Text is (maybe) more efficient, but also more opaque
11:26:44 <dankna> a String is just a [Char], which means each character in it takes up something like 8 bytes (!)
11:27:04 <dankna> and of course a String has the linear-access performance issues associated with lists
11:28:00 <k0ral> how can I convert a String to a Text ?
11:28:11 <dankna> @hoogle Text -> String
11:28:11 <lambdabot> Warning: Unknown type Text
11:28:11 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
11:28:11 <lambdabot> Prelude show :: Show a => a -> String
11:28:14 <dankna> hm
11:28:15 <dankna> not sure
11:28:35 <k0ral> it's the inverse direction
11:28:58 <geheimdienst> koral: here you go http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=String+-%3E+Text
11:29:06 <geheimdienst> seems like Data.Text.pack is the solution
11:30:38 <dankna> using my psychic powers, I infer that the inverse operation is called "unpack" :D
11:31:44 <k0ral> dankna: my hero
11:31:51 <dankna> k0ral: haha
12:06:23 <joevandyk> when you guys deploy a haskell application to a server somewhere (say a daemon/service), do you compile it first then copy?  or compile it on the server?
12:06:36 <jdavis> how do I cast a Word32 into an Int32?
12:07:11 <DevHC> toInteger . fromInteger
12:07:20 <DevHC> uhm
12:07:26 <DevHC> something like that
12:08:01 <jdavis> If possible, I'd like it to be fairly efficient -- is there a compile-time cast like that, or will it always be runtime?
12:08:20 <jdavis> joevandyk: I think that the accepted wisdom is to only have what's necessary on the server.
12:08:26 <vitka> > (fromIntegral 3 :: Word32) :: Int32
12:08:27 <lambdabot>   Couldn't match expected type `GHC.Int.Int32'
12:08:27 <lambdabot>         against inferred type ...
12:08:40 <vitka> > (fromIntegral (3 :: Word32)) :: Int32
12:08:40 <lambdabot>   3
12:08:55 <vitka> Just fromIntegral should do.
12:09:07 <ion> > fromBool . toBool $ (3 :: Word32) :: Int32
12:09:08 <lambdabot>   Not in scope: `fromBool'Not in scope: `toBool'
12:09:34 <vitka> > (fromIntegral (4000000000 :: Word32)) :: Int32
12:09:35 <lambdabot>   -294967296
12:09:45 * vitka nods.
12:10:07 <ion> ghci> (fromBool . toBool) (3 :: Word32) :: Int32
12:10:07 <ion> 1
12:10:16 <ion> Seems like a nice alternative to fromIntegral.
12:10:18 <jdavis> joevandyk: the production environment should only be runtime stuff like libraries, unless you are using some framework/environment that does automatic compilation.
12:10:28 <koeien> > unsafeCoerce (3 :: Word32) :: Int32
12:10:28 <lambdabot>   Not in scope: `unsafeCoerce'
12:11:16 <jdavis> vitka: oh, so even with the fromIntegral it looks like a compile-time thing. Perfect.
12:11:52 <ion> One would think it would be perfectly inlineable.
12:11:54 <koeien> jdavis: it could very well be, if the compiler inlines and optimizes it
12:34:04 <jdavis> I'm reading some binary data, and I have a type like "data Foo = Null | Bar Int32". I'm using Data.Binary.Get, and if a flag is set, I want x to be Null, otherwise I want it to be "getWord32host". I'm having a little trouble structuring that conditional, and suggestions?
12:34:13 <jdavis> I am a novice so perhaps the answer is very simple.
12:37:04 <jdavis> So something like: "myfunction = do  flag <- getWord8; x <- if (flag) Null else Bar getWord32host" -- but the types are all wrong there, obviously.
12:38:07 <DevHC> jdavis: use "return $ if (flag) ..."
12:38:30 <DevHC> or use "let x = if (flag) ..."
12:39:00 <adnam> and you also need to get the value of getWord32host before that as well afaict
12:39:23 <jdavis> adnam, well, those bytes aren't there if the flag isn't set though
12:39:35 <adnam> oh oops, just realized
12:39:44 <jdavis> DevHC, what do the two branches of the "if" look like?
12:40:12 <DevHC> is getWord32host an action?
12:40:25 <jdavis> yes, a part of the Data.Binary.Get monad
12:40:30 <mikeg> getWord32Host :: m a, and Null :: a
12:40:39 <adnam> Null is invalid there, since the return value of both branches should be Get Foo
12:40:43 <mikeg> so you want if flag then return Null else getWord32Host
12:41:17 <mikeg> or, Bar `liftM` getWord32Host
12:41:37 <jdavis> mikeg: oh, I haven't used liftM before.
12:41:46 <adnam> and Bar getWord32host is invalid since Bar :: Int32 -> Foo and getWord32host :: Get Int32
12:42:02 <cmccann> liftM is just fmap
12:42:10 <jdavis> adnam, yeah, so I can see the types don't match.
12:43:18 <jdavis> so something like:   if (flag) then Null else Bar `liftM` getWord32host    ?
12:43:29 <adnam> so for Null you need a function Data -> Get Data, which is return, and like mikeg said, for else, liftM
12:43:56 <jdavis> OK, I think I'm getting it.
12:45:28 <adnam> it can be useful to write type signatures everwhere while debugging so that you can verify your thought process with the type checker, and usually you end up needing a function of a specific type
12:46:12 <jdavis> adnam, ok, thanks. I think I am closer now, just trying out the suggestions.
12:46:20 <adnam> cool
12:50:49 <jdavis> I think it's working, thanks everyone!
13:03:17 <mekeor> how can i make my program *wait*, e.g. for 1sec?
13:03:22 <koeien> :t threadDelay
13:03:23 <lambdabot> Not in scope: `threadDelay'
13:03:34 <koeien> @hoogle threadDelay
13:03:34 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
13:03:50 <hpc> threadDelay is more granular than seconds; read the docs
13:03:57 <hpc> i forget the unit
13:04:03 <mekeor> microsec
13:04:04 <koeien> i believe it's usecs
13:04:16 <hpc> ah, cool
13:04:22 <hpc> #haskell > docs
13:04:47 <mekeor> ?
13:07:14 <dylukes> Can most computers even do microsecs?
13:07:18 <dylukes> >_>?
13:08:03 <ddarius> The computer is capable of it.  The system as a whole may not be.
13:08:04 <koeien> a 2 GHz computer should have 2 . 10^9 ticks/s
13:08:36 <shachaf> At any rate they certainly can have more precision than milliseconds.
13:09:19 <Eduard_Munteanu> Yeah, but usually it's the kind of "I'll give it a shot but don't go mad if I end up rescheduling your task after 5ms" kind of microseconds.
13:09:19 <dylukes> Fuck you Haskell.
13:09:27 <dylukes> I can't even read C code now, without seeing monads and applicatives.
13:09:29 <dylukes> .__.
13:09:33 <dylukes> YOU HAVE RUINED MY LIFE.
13:09:40 <dylukes> I CAN'T WRITE C WITHOUT WISHING I WASNT.
13:09:50 <Eduard_Munteanu> I still like writing C.
13:09:53 <hpc> dylukes: try writing C++ sometime
13:09:58 <monqy> incredible
13:09:58 <dylukes> hpc: I AM RIGHT NOW TT_TT
13:10:01 <monqy> :(
13:10:03 <hpc> you'll learn to love C in an instant
13:10:04 * ddarius never liked writing C.
13:10:07 <hpc> oh :(
13:10:08 <dylukes> hpc: I know, it helps so much :D
13:10:10 * ddarius likes C++.
13:10:23 <dylukes> Who's excited for C1X _Generic?
13:10:27 <dylukes> Fundeps in C! Hurrah!
13:10:29 <jdavis> If I encounter an input error, is it good style to just use "throw" right away, or is there some other way that it's normally handled?
13:10:39 <Eduard_Munteanu> It's more about doing clever plumbing and ending up with an usable interface.
13:11:28 <hpc> dylukes: corollary to the lispy trend: as a compiler gets more complex, it tends to contain a mostly broken implementation of ghc
13:11:40 <dylukes> hpc: Yeah, lol...
13:11:44 <dylukes> I'm seeing here an instance in which,
13:11:47 <dylukes> parsing is done from a buffer
13:11:53 <dylukes> so each function call takes an index,
13:11:59 <dylukes> and returns the next index, or -1 for failure
13:12:07 <dylukes> State + Maybe TT_TT
13:12:12 <dylukes> StateT Maybe even.
13:13:20 <Eduard_Munteanu> I also think C teaches you how to avoid shooting oneself in the foot, given the opportunity.
13:13:32 <dylukes> Eduard_Munteanu: Very true.
13:13:42 <dylukes> C++ teaches you how to avoid getting shot by language warts!
13:13:48 <hpc> i wish i knew C before coding perl for work
13:13:55 <hpc> perl only teaches you how many feet you have ;)
13:13:58 <dylukes> >_>
13:13:59 <Eduard_Munteanu> ))
13:14:10 <Eduard_Munteanu> s/^/:/
13:15:23 <monochrom> State + Maybe = StateT Maybe. therefore + = T :)
13:15:41 <monochrom> henceforth we can say "CTT" :)
13:16:20 <Eduard_Munteanu> + :: (* -> *) -> * -> * -> * :P
13:16:54 <ddarius> C++ = Computational Type Theory ?
13:17:20 <monochrom> that may be depressingly true
13:17:50 <jdavis> I am reading some binary data, and I have a function that checks for consistency. I want it to conditionally throw an error, but otherwise I don't need it to return a value. What should the signature be, and how should I call it?
13:18:40 <monochrom> likely Your'Monad ()
13:19:06 <jdavis> I am a novice, so can you be a little more specific?
13:19:15 <monochrom> I can't
13:19:29 <Saizan> Bool ?
13:19:58 <Eduard_Munteanu> Maybe something ?
13:20:15 <Saizan> he doesn't need to return anything
13:20:16 <monqy> Maybe String where Nothing represents success and Just whatever represents error with contents whatever
13:20:21 <jdavis> Saizan, OK, assuming the consistency function returns Bool, how do I call it?
13:20:23 <monqy> substitute String for whatever error type you want
13:21:20 <Saizan> jdavis: yourfunction the'argument
13:21:24 <Eduard_Munteanu> Maybe () will take care of propagating error conditions, I mean.
13:21:41 <monqy> oh right
13:21:42 <Eduard_Munteanu> (if callers use Maybe as well)
13:21:54 <jdavis> I am in the Data.Binary.Get monad, so I have things like "a <- getWord32host ; b <- getWord32host;  CHECK GOES HERE; ..."
13:22:14 <jdavis> and the check is a function of a and b.
13:22:35 <monochrom> that is the information I need to be specific
13:22:49 <Saizan> ?type guard
13:22:49 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:23:00 <monochrom> check :: Word32 -> Word32 -> Get ()
13:23:11 <monochrom> s/CHECK GOES HERE/check a b/
13:23:23 <Saizan> actually, that doesn't work since Get is not a MonadPlus
13:23:39 <monochrom> but does it throw exceptions?
13:24:21 <jdavis> monochrom, oh, ok, that makes sense. So then in the body of "check", I would do something like "if a > 3 and b < 2 then error(...) else return ()"
13:24:25 <Saizan> no, you can use fail, which will call error
13:24:33 <jdavis> oh
13:24:53 <Saizan> i was responding to monochrom
13:25:27 <Saizan> jdavis: anyhow, yes, you could do something like that
13:25:55 <monochrom> Get doesn't support exception (especially catching), so I would recommend against the exception style in this case
13:26:16 <monochrom> (if it supported catching, I would support it too)
13:27:43 <monochrom> then again Get doesn't support any kind of error reporting whatsoever, so every solution sucks equally
13:28:35 <jdavis> Oh. For now a "fail" is good enough, and I'll work on handling it later.
13:28:48 <jdavis> Thanks for the help.
13:28:49 <koeien> fail handles it, though.
13:28:56 <monochrom> perhaps the author thought you could always do your own "my'decoder :: Get (Either My'Error'Type Good'Result)
13:28:58 <koeien> > fail "Unexpected." :: Maybe Integer
13:28:58 <lambdabot>   Nothing
13:29:08 <koeien> fail does not necessarily call error
13:29:51 <jdavis> koeien: ok, that's a little confusing.
13:30:07 <Eduard_Munteanu> @src Maybe fail
13:30:07 <lambdabot> fail _      = Nothing
13:30:07 <Saizan> in the Get monad fail will always call error
13:30:31 <Saizan> for other monads it can do something else
13:38:18 <chrisdone> Use of Template Haskell seems to load *all* packages (72 in total) in use in my project despite the TH code only using base and missingh. Is it possible for that not to happen?
13:40:54 <c_wraith> chrisdone: it will load all the packages used (transitively) by the module being spliced into.  If you move the splice into a module that imports very little, it should help.
13:41:13 <c_wraith> chrisdone: If I'm wrong about that, I'm very annoyed its that bad :)
13:41:22 <mdgeorge> hello
13:41:54 <mdgeorge> I'm trying to use the numeric prelude, and I'm having a small problem
13:42:21 <mdgeorge> the problem is that the package uses a style where each class lives in it's own module, and is simply referred to as module.C
13:42:53 <mdgeorge> when looking at the haddoc docs for it, all of the links are just "C", so it's very difficult to read
13:43:03 <c_wraith> mdgeorge: Thielemann-style, we call it
13:43:12 <mdgeorge> does anyone have a suggestion?  is there a way to run haddock so that it produces something more useful?
13:43:18 <c_wraith> mdgeorge: since he does that with all of his libraries
13:43:21 <mdgeorge> I see
13:43:42 <chrisdone> c_wraith: Sadly I'm using the splice for 148 definitions.
13:43:57 <chrisdone> Not particularly fast at compiling either…
13:44:21 <c_wraith> mdgeorge: sadly, yes, the docs will just be bad.
13:44:29 <mdgeorge> I see.
13:44:49 <mdgeorge> maybe I could try to patch haddock
13:44:59 <c_wraith> chrisdone: are they releated in some way that would allow them to be made into fewer high-level splices?
13:45:20 <mdgeorge> do a lot of people use Thielemann style?  would that be generally worthwhile?
13:45:56 <c_wraith> No, he's the only one.  Don't know if it would be considered worthwhile, though.  Those who use his libs might be grateful even if it doesn't help any other time.
13:46:05 <mdgeorge> I see
13:47:07 <mdgeorge> is there a more typical style for organizing large libraries?  Just putting everything in one big module?
13:48:06 <chrisdone> c_wraith: They're for defining controllers (as in mvc), as an alternative to what I had before which is a big list of name->function mappings, and then a load of functions. Duplication. I could put them all in one big list, but then the nice abstraction achieved by TH is gone.
13:48:10 <c_wraith> That's not used very often, though it is common to have one module that re-exports several more specialized modules, just to make a simple interface
13:49:03 <chrisdone> Loading the module in GHCi takes.. 3 seconds. I think before it took 1 second. I can checkout the previous version and check. If it's roughly the same I won't mind.
13:49:13 <c_wraith> The most common design is to try to break things into as many modules as allows an individual module to contain a well-defined subset of what's going on.
13:49:29 <mdgeorge> I see
13:49:32 <c_wraith> And to give things more descriptive names than C and T. :)
13:49:36 <mdgeorge> right
13:50:19 <mdgeorge> In the case of something like the numeric prelude, then, you would have a similar structure, but the classes would be named, e.g., Algebra.Field.Field instead of Algebra.Field.C?
13:50:53 <chrisdone> FWIW (seems related to the topic I'm talking about), splitting code into modules makes your builds and loads faster. I will be doing that with this module after my TH experiment.
13:51:18 <mdgeorge> unless you always use all of the modules :)
13:51:37 <ehiggs> This is an interesting topic because in languages without as much existential typing it's common to define a type and the operations on that type in a single module and organize the library in this manner. In modules which are much more abstract, it becomes more difficult to see where these boundaries are.
13:53:47 <mdgeorge> I'm not sure I see what existential typing has to do with it
13:56:19 <chrisdone> c_wraith: The old way loads in 2 seconds. And compiles in 7 seconds. The TH version loads in 3 seconds, compiles in 10. Hum. I think I can live with that, I'll just split it up into modules.
13:58:05 <chrisdone> It just seems redundant to load all those packages when the TH code doesn't even look at the values or types in the runtime code.
13:58:18 <dmwit> I guess it's not so much Thielemann style as it is OCaml style.
13:58:36 <dmwit> It's just that Thielemann seems to be the only one using OCaml style in Haskell. =P
13:58:59 <dmwit> Anyway, for now, you can help yourself a little bit by hovering the T's/C's you're interested in -- they'll include the module name in the link.
13:59:34 <dmwit> It's still very distracting.
14:03:59 <chrisdone> Does my use of unsafePerformIO look reasonable here? It works, and from what I've read it's correct, but this is the kind of thing with subtle problems. http://hpaste.org/47182/th_and_iorefs_and_unsafeperfor
14:10:35 <chrisdone> I'll take that silence as cowering fear and derision rather than silent approval.
14:13:16 <cmccann> chrisdone, the basic idea there is a pretty well-known hack, yes
14:13:46 <cmccann> whether it's actually reasonable and whether there's some subtlety that's going to bite you is a more difficult question
14:14:02 <chrisdone> That's the question I was asking, yeah. :p
14:15:11 <cmccann> chrisdone, if it helps, consider that the stm library includes a special function to create a TVar from IO specifically to enable top-level bindings with unsafePerformIO
14:15:46 <cmccann> so I have to conclude that it's "not that bad" in some sense if they're willing to encourage it that way
14:17:12 <chrisdone> Ah, this one:
14:17:13 <chrisdone> newTVarIO :: a -> IO (TVar a)
14:17:13 <chrisdone> IO version of newTVar. This is useful for creating top-level TVars using System.IO.Unsafe.unsafePerformIO, because using atomically inside System.IO.Unsafe.unsafePerformIO isn't possible.
14:17:22 <cmccann> yeah
14:17:56 <cmccann> I think the deal is that it deliberately sabotages any attempt to do STM transactions inside unsafePerformIO because basically there's no way it could ever work properly
14:18:02 <cmccann> or something like that
14:20:00 <cmccann> so the real question is making sure you understand how unsafePerformIO interacts with other things and I can't really help you there
14:38:09 <MHD0> I'm looking a bit at intermediate compilation languages
14:38:43 <MHD0> So far, for my current project, I have the looks for Mono, LLVM and C--
14:39:03 <MHD0> My project is a language akin to Google Go
14:39:11 <MHD0> What do you think I should go for?
14:44:49 <Lemmih> MHD0: Not C--.
14:45:00 <Lemmih> MHD0: I'd pick LLVM.
14:45:08 <MHD0> Yeah, at least not until there's a complete definition
14:45:14 <MHD0> I'm thinking LLVM too
14:45:23 <MHD0> just a shame it's not stack based.
14:45:33 <MHD0> That would have suited my purposes bettter.
14:49:24 <MHD0> LLVM is actually pretty cool
14:49:39 <Kaidelong> Mono would give you the nice perk of being interoperable with .NET
14:49:43 <Kaidelong> and LLVM is cool
14:50:19 <MHD0> Yeah, trouble is that with Mono I would have to restructure immensely
14:50:58 <MHD0> because interfaces, data structures and methods can be defined in completely different modules and still work
14:51:42 <MHD0> I'll probably unclude both Mono and LLVM or something.
14:52:00 <luite> is the mono project still alive, with the budget cuts of Novell's new owner?
14:53:28 <Kaidelong> Mono is very much still kicking
14:53:36 <Kaidelong> Microsoft also pitches in
14:53:50 <Kaidelong> not financially though
14:54:00 <luite> hmm, are there many non-novell developers?
14:54:21 <Kaidelong> not sure
14:54:35 <Kaidelong> I think mono established itself as a part of gnome and that helped
14:54:42 <luite> I thought the original Novell team was being laid off, with some rumors of a relocation
14:56:22 <MHD0> LLVM gives direct acces to C code, right?
15:05:49 <MHD0> macro syntax is difficult...
15:10:22 <dobblego> how do I look at what lambdabot has remembered?
15:10:47 <c_wraith> like the whole database?  it's somewhere in ~/.lambdabot/State
15:10:57 <c_wraith> But it's not in a plaintext format
15:15:31 <dobblego> no, just send it a keyword or something
15:21:12 * hackagebot sndfile-enumerators 0.9.0 - Audio file reading/writing  http://hackage.haskell.org/package/sndfile-enumerators-0.9.0 (JohnLato)
15:22:16 <dobblego> @wibble
15:22:17 <lambdabot> Unknown command, try @list
15:25:50 <dolio> @free (a -> b) -> (b -> c) -> a -> c
15:25:50 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:25:58 <dolio> @free comp :: (a -> b) -> (b -> c) -> a -> c
15:25:58 <lambdabot> g . k = p . f => h . q = f1 . g => h . comp k q = comp p f1 . f
15:35:14 <paf31> @free s :: (a -> b) -> (a -> b -> c) -> (b -> c)
15:35:14 <lambdabot> g . k = p . f => (forall x. h . q x = f1 (f x) . g) => h . s k q = s p f1 . g
15:42:15 * hackagebot quickcheck-properties 0.1 - QuickCheck properties for standard type classes.  http://hackage.haskell.org/package/quickcheck-properties-0.1 (AlexeyKhudyakov)
15:43:08 <jdavis> Well, my binary reader program is mostly a success. It's still about 4x slower than the C code, but I'll look at optimizing it another day.
15:45:57 <jdavis> wait, hold on! after I removed a little of the work, it's actually faster than the C code (with the same work removed)! Just by a hair though.
15:47:09 <jdavis> Pattern matching must have some significant cost.
15:47:24 <ddarius> No, it doesn't.
15:47:25 <cmccann> jdavis, it shouldn't
15:47:42 <ddarius> (It better not as pattern matching is the only way calculation proceeds in Haskell for the most part.)
15:47:55 <jdavis> hmm... I have a program that takes an input data file, produces a bunch of records, and then runs some filters.
15:48:13 <cmccann> ddarius, well you have to admit that a program that never does pattern matching will run very quickly indeed :)
15:48:26 <jdavis> when I removed the filters it's as fast as the c code (which is good, because it's not just a bunch of fixed-length records, the structure is a little more complex)
15:48:58 <lispy> jdavis: Unless it's highly optimized C, then usually you can get same performance or faster with optimized versions in high level languages.  Garbage collectors can do memory management faster than malloc/free.  So that can make a big difference.
15:49:21 <jdavis> lispy there is no malloc/free in this C code path.
15:49:25 <cmccann> jdavis, chances are the slow version is just doing something in a very inefficient way but you don't realize it because optimizing Haskell can be counterintuitive if you're used to something like C
15:49:28 <lispy> I see
15:49:55 <ddarius> Or the fast version is IO bound in both of them.  Or the fast version is not doing something at all due to laziness.
15:49:58 <ddarius> Or ...
15:50:03 <jdavis> Man, I add one filter to the result list, and it slows it down by almost 10x in haskell
15:50:20 <cmccann> yes, or any number of possibilities
15:50:28 <jdavis> Although it's read from a file, there is no actual disk activity in either case.
15:51:45 <jdavis> cmccann, that's probably true. Would be interesting if I could figure out what it was. What is the standard paste-board for this forum?
15:51:58 <cmccann> hpaste is mentioned in the channel topic I think?
15:52:21 <jrick> it'd be cool if the topic was a variable in lambdabot
15:52:23 <jrick> > head topic
15:52:24 <lambdabot>   Not in scope: `topic'
15:52:30 <ddarius> @topic-tell
15:52:31 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
15:52:48 <ddarius> @help topic-tell
15:52:48 <lambdabot>  @topic-tell #chan -- Tell the requesting person of the topic of the channel
15:52:55 <ddarius> @topic-tell #haskell
15:52:56 <lambdabot> ["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language
15:52:56 <lambdabot> http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]
15:53:31 <mauke> @topic-tell ##javascript
15:53:31 <lambdabot> Do not know that channel
15:54:01 <ddarius> @listcommands topic
15:54:01 <lambdabot> Unknown command, try @list
15:54:07 <ddarius> @list topic
15:54:08 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
15:54:19 <ddarius> @help topic-null
15:54:20 <lambdabot>  @topic-null #chan -- Clear out the topic entirely
15:54:34 <jdavis> http://hpaste.org/47183/haskell_v_c
15:55:37 <cmccann> jdavis, which part is the one you removed to make it much faster?
15:55:44 <jdavis> If I just do a "length tuples" in process_bytes, then it takes 1.4 seconds, which I thought was great (because it has to fetch the line pointer first, then find the item). But if I do length of f1, then it's slow.
15:56:29 <jdavis> Please forgive the horrible style, I am a novice at haskell
15:57:13 <jdavis> Adding the extra filters on top doesn't seem to add much time though, strangely.
16:00:06 <cmccann> jdavis, are you sure that just (length tuples) is actually making it do all the work? looks like that might not actually force some of the computation
16:00:22 <jdavis> cmccann: it gives me the right number -- 25000000 in this case.
16:00:37 <cmccann> doesn't mean it's computing everything
16:01:14 <jdavis> cmccann: I don't see how it could know that without at least dereferencing each item pointer (which is designed for variable-length items, so it points somewhere else in the page).
16:01:25 <dankna> hmm
16:01:31 <jdavis> So it's doing some work there, and it's a hair faster than C
16:01:31 <dankna> I don't believe it's evaluating item_get_tuple
16:01:57 <cmccann> jdavis, I don't know, I only glanced at it
16:02:10 <jdavis> Oh, that makes sense.
16:02:12 <dankna> it produces the spine of the list, in other words, but not the contents of it
16:02:22 <cmccann> just that evaluating the length of a list will only calculate enough to figure out how the list was built, not the exact elements in it
16:02:36 <cmccann> whereas filtering is forcing it to decide which of the two cases applies
16:03:01 <cmccann> which is why adding more filters doesn't make much difference
16:03:04 <jdavis> Yeah, so basically all the cost is in unpacking the tuple
16:03:11 <dankna> yeah
16:03:30 <jdavis> Do you see any obvious inefficiency there? Why would it be so much slower than C at reading the tuple?
16:03:47 <dankna> hmm
16:03:54 <jdavis> Should I use a strict bytestring or some kind of struct-unpacking thing instead?
16:04:04 <dankna> lazy bytestring should be fine for this
16:04:24 <cmccann> jdavis, usually a good idea to profile first and see where it's spending time
16:04:27 <dankna> try compiling your program with profiling on
16:04:34 <dankna> and then run with -pa
16:05:06 <dankna> (if you're using cabal to build, it's $ cabal configure --enable-executable-profiling --ghc-options=-rtsopts )
16:05:24 <dankna> (and then when invoking, $ dist/build/jdavis/jdavis +RTS -pa )
16:06:35 <cmccann> "profile first" is the standard advice in any language anyway, some people are sufficiently expert to recognize inefficiencies at a glance but I'm not :(
16:06:42 <dankna> true true
16:06:47 <jdavis> installing some packages to profile it.
16:06:53 * dankna nods
16:07:13 <cmccann> jdavis, you'll have to install profiling versions of any dependencies if you don't have them already
16:07:17 <cmccann> I assume that's what you're doing now
16:07:45 <cmccann> I think I have cabal configured to always install profiling versions of everything preemptively, heh
16:07:57 <dankna> I definitely do
16:08:01 <luite> me too
16:08:27 <dankna> I even have (sigh) a build of the RTS which has both profiling and debugging turned on
16:08:42 <dankna> because of the infelicity (not really a bug) that I found in it, haha
16:08:56 <jdavis> Ok, re-ran it with -pa
16:08:58 <dankna> (it looked like a bug, until I finished the diagnosis)
16:09:09 <dankna> okay, check your output in jdavis.prof in the cwd
16:09:12 <cmccann> dankna, oh that sounds like fun
16:09:18 <dankna> cmccann: you have no idea
16:09:45 <jdavis> I don't see it in the cwd, I am on ubuntu. Any ideas where to look?
16:09:50 <cmccann> dankna, and I'm happier that way I think :)
16:10:00 <dankna> cmccann hehe
16:10:19 <dankna> jdavis: how did you invoke your program?  (note that it's actually programname.prof, jdavis was just my placeholder)
16:10:30 <dankna> it needs to be +RTS -pa, btw, not just -pa
16:10:56 <cmccann> jdavis, if you haven't already, you might want to find a guide on basic profiling in Haskell
16:11:06 <cmccann> There's a chapter on it in Real World Haskell that's pretty straightforward
16:11:42 <cmccann> might be easier than trying to walk through it via IRC
16:12:02 <dankna> also and by the way, if this profile (once we've found it) turns out not to have enough useful information, you might consider $ cabal configure --enable-executable-profiling --ghc-options="-rtsopts -auto-all -auto-caf"
16:12:11 <dankna> noting that I came up with that from memory and may have spelled the option names wrong
16:14:08 <jdavis> hmm... I see the output now, but the only two high percentages I see are "main" and some GC related thing.
16:14:49 <jdavis> I turned on heavy optimization also ( -O100 ) because at the default level it was way too slow
16:14:52 <dankna> okay, definitely do what I said
16:14:57 <dankna> -O2 is actually the maximum
16:15:28 <cmccann> haha, -O100, is that the level where it just emails dons and says "halp plz"
16:16:22 <ben> -O100 not only does not preserve program semantics, it also adds uvector to the list of dependencies
16:16:42 <Zao> My favorite optimization was -O7 on IRIX, which removed main as dead code.
16:16:47 <dankna> hah
16:17:30 <jdavis> much better info.
16:17:48 <jdavis> tupbytes_get_tuple is about 60%
16:18:10 <dankna> unsurprisingly
16:19:09 <dankna> you can also break it down even further with cost-center annotations, assigning names to different parts of the function
16:19:23 <dankna> I will refer you to the GHC user manual for how to do those, though, as I don't remember the syntax
16:19:47 <jdavis> Thoughts on how to make it closer to C speed there? It looks like Data.Binary.Get is just not as fast as structure access and pointer arithmetic.
16:19:58 <jdavis> And it's also doing a crazy amount of allocations.
16:20:02 <jdavis> Or something is.
16:20:13 <dankna> hmm
16:20:27 <jdavis> total alloc 70G
16:20:37 <dankna> ouch
16:20:48 <jdavis> compare to the C code doing 0
16:20:50 <dankna> note that alloc is not necessarily a problem if the data can be discarded immediately, as it often can
16:21:07 <dankna> or it might be a problem; it's hard to know
16:21:59 <jdavis> Yeah, I realize that it's a little different than C allocations. But it must add at least a few instructions where C is just doing struct access.
16:22:08 <dankna> I'm sure, yes
16:22:16 <dankna> one approach is to rewrite things with the ST monad
16:22:35 <dankna> I can't offer guidance in that - it's guidance that was offered to me with a similar problem, which I haven't yet followed up on :)
16:23:06 <jdavis> Looks like getInt32host is also adding a significant chunk I assume that it actually means getWord32host and that getInt32host is inlined.
16:23:27 <dankna> hmm
16:23:42 <jdavis> GC 29%
16:24:06 <dankna> oh ouch
16:25:18 <jdavis> I think, fundamentally, the problem is that Data.Binary.Get is stream-based, when what I really need is to access the memory randomly using structure like things and pointer arithmetic.
16:25:47 <jdavis> Though I'm impressed that it worked so well just for dereferencing the line pointers.
16:28:32 <dankna> yeah, hm
16:29:28 <jdavis> I could try reading into a Ptr, but that seemed like a pain.
16:38:52 <shachaf> <em> I don't think i get variables or non-functional programming.
16:39:23 * hackagebot hatt 1.2.0 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.2.0 (BenedictEastaugh)
16:39:38 <shachaf> Nice to have that, for once.
16:39:44 <dankna> indeed so
16:39:47 <pokoko222> why is functional programming so important for parallel computing?
16:40:24 <pokoko222> I can't believe I just heard a berkley professor say functional programming is not for theoreticians anymore, it is the future together with parallel computing
16:40:42 <dankna> when Berkeley accepts it, it's mainstream? :)
16:42:49 <pokoko222> yes
16:43:48 <monochrom> you get better concurrency and fewer race conditions if you force yourself to not use shared mutable variables wantonly, i.e., functional programming
16:44:12 <hpc> wantonly?
16:44:20 <monochrom> wantonly
16:44:32 <hpc> oh, i see
16:44:37 <hpc> i read that as "want only"
16:44:44 <hpc> totally forgot that it was a word
16:45:52 <pokoko222> yeah he said functional programming since each core will work on one separate function only so nothing will interfere
16:46:19 <dankna> well, that's true as far as it goes
16:46:19 <pokoko222> and a function only depends on stuff "inside" itself
16:46:24 * hackagebot hspec 0.5.0 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.5.0 (TrystanSpangler)
16:46:43 <dankna> of course it's possible to write imperative code in a functional language; it's just discouraged
16:47:11 <k3yb1n> hi everyone i need some information about uuagc and how is the programming in AG?
16:47:59 <monochrom> what is uuagc?
16:48:08 <dankna> a) that wasn't a very polite way to ask; "I need..." is presumptive.  better would be "could you please tell me..."
16:48:10 <dankna> b) what is AG?
16:48:46 <monochrom> I need the definition of "uuagc"
16:48:49 <k3yb1n> i am sorry my inglish is not very well
16:48:50 <monochrom> :)
16:48:57 <hpc> @wn uuagc
16:48:57 <lambdabot> No match for "uuagc".
16:50:04 <k3yb1n> this is a attribute grammar system
16:50:21 <dankna> http://hackage.haskell.org/package/uuagc-0.9.38.1 apparently
16:51:13 <k3yb1n> yes this is
16:51:42 <k3yb1n> you know some simple example about this
16:51:52 <dankna> I've never used it though.  I actually looked at it once now that you mention it, but I didn't get as far as trying to run it.
17:06:51 <Favonia> dankna: Is cabal --enable-library-profiling enough?
17:07:28 <dankna> Favonia: when installing your dependent libraries, you want --enable-library-profiling.  when installing the program you actually want to profile, you want --enable-executable-profiling.
17:08:12 <Favonia> dankna: oh I meant that I am a little worried about my current setting when I see the long argument list you suggested before :P
17:08:28 <Favonia> dankna: I don't want to recompile every library :(
17:08:45 <Favonia> dankna: (when I want to profile something)
17:09:09 <dankna> oh don't worry, it won't recompile every library when you invoke that command; it will simply refuse to build anything for profiling unless all its dependencies have already been built for profiling.
17:09:19 <monochrom> my .cabal/config has library-profiling: True, shared: True, documentation: True
17:09:39 <dankna> I have my ~/.cabal/config set to turn on library-profiling by default, so that my entire Haskell world is built that way and I never have to think about it.
17:10:32 <monochrom> the defaults are really tuned for the like of xmonad users who otherwise don't care about haskell
17:11:04 <Favonia> dankna: me too. oh I see, so ``--ghc-options="-rtsopts -auto-all -auto-caf"'' is just for executables?
17:11:10 <dankna> yup
17:11:12 <monochrom> like which haskell programmers would "documentation: False" in their right minds?
17:11:19 <dankna> monochrom: indeed!
17:11:31 <cmccann> is there any reason not to enable library profiling other than it making "cabal install foo" take a bit longer?
17:11:45 <dankna> that and disk space
17:21:48 <ryanf> just working my way through Real World Haskell, anyone want to take a look at an example solution and tell me how I could clean it up?
17:22:28 <luite> ryanf: just hpaste it and mention the url here
17:22:33 <parcs> cmccann: it doubles the size of your ~/.cabal. if you're running tight on disk space...
17:22:37 <ryanf> https://gist.github.com/7ee99e7209f5d64b0c0e
17:22:38 <ryanf> oh
17:22:44 <luite> oh github is fine as well :)
17:22:45 <ryanf> sorry, didn't check back in here before making the gist
17:22:46 <ryanf> haha
17:23:31 <ryanf> anyway I feel like it should be possible to do it with signficantly less logic, but it's not obvious to me how
17:27:24 <cmccann> ryanf, you don't need the let, do you? just "case span pred lst of ..."
17:28:33 <cmccann> ryanf, also I think the first two cases are doing the same thing
17:28:47 <ryanf> the problem is that if pre is []
17:28:54 <ryanf> it ends up with extra empty []s in the output
17:28:56 <ryanf> without the first case
17:29:06 <cmccann> ryanf, [] ++ xs = xs
17:29:13 <ryanf> yeah but it's [[]]
17:29:23 <ryanf> [[]] ++ xs = [] : xs
17:29:38 <ryanf> I'd love to get it down to one case but I couldn't figure out how
17:29:39 <cmccann> oh, right, misread it
17:29:40 <monochrom> @src words
17:29:41 <lambdabot> words s = case dropWhile isSpace s of
17:29:41 <lambdabot>     "" -> []
17:29:41 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:29:41 <cmccann> sorry
17:34:32 * hackagebot word24 1.0.0 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.0 (JohnLato)
17:34:34 * hackagebot sndfile-enumerators 0.9.0.1 - Audio file reading/writing  http://hackage.haskell.org/package/sndfile-enumerators-0.9.0.1 (JohnLato)
18:01:22 <dmwit> ryanf: still around?
18:10:08 <dankna> dylukes: when I've done it (and I can get halfway through login negotiation with my ssl implementation, heh), I did it coding directly on top of bytestring
18:10:22 <dylukes> Explain?
18:10:27 <dylukes> I mean, what'd you do specifically.
18:10:39 <dylukes> I want to do things like,
18:10:47 <dylukes> read a byte, then use its length to determine how many more to read...
18:10:51 <dylukes> a DSL would be nice.
18:10:56 <dankna> well yeah.  let me find some sample code.
18:11:35 <ryanf> dmwit: yep, I was just reimplementing that words thing on my problem
18:11:43 <ryanf> just finished actualy
18:11:51 <ryanf> uh, not that I was doing it continuously the entire time
18:12:16 <dmwit> =)
18:12:26 <dankna> dylukes: I should have done this code that I'm pasting now in the Maybe monad or something, but I didn't.  anyway, one sec.
18:13:07 <dmwit> ryanf: "let foo = bar in case foo of { ... }" could more simply be just "case bar of { ... }".
18:13:26 <ryanf> oh yeah got that part, thanks
18:13:40 <ryanf> that was confusing me a bit actually because I started without the case and just kept the let
18:13:45 <dmwit> You might also like the "dropWhile" function.
18:13:58 <ryanf> oh haha yeah that's what the words implementation does
18:14:06 <ryanf> I started mine with break but it wasn't doing the job by itself
18:14:22 <ryanf> so I switched to span instead of adding dropWhile, whereas the actual words function uses break and dropWhile together
18:14:50 <dankna> dylukes: http://hpaste.org/47187/example_for_your_enjoyment
18:15:50 <ryanf> just updated with the version based on words: https://gist.github.com/7ee99e7209f5d64b0c0e
18:15:56 <dylukes> lets see
18:16:28 <dylukes> dankna: I think Maybe you should have put that in a monad...
18:16:29 <dylukes> >_>
18:16:38 <dankna> that's what I just said :)
18:16:46 <dylukes> no no, but I said it with a pun.
18:17:01 <dylukes> But yeah, fail-safe parsing routines always end up being StateT Maybe it seems.
18:17:11 <dylukes> (where State carries the parsing location)
18:17:18 <dankna> yes indeed
18:17:18 <dylukes> (unnecessary if theres a Stream instead though)
18:17:19 <dmwit> Looks pretty good.
18:18:29 <dankna> I see that I neglected to include the definition of streamRead, but it ultimately just calls the function that gets a ByteString from the network
18:18:38 <ryanf> is there a nicer way of negating the predicate inline?
18:18:52 <ryanf> like I did the where pred' etc. because I don't know of a way of doing it inline without a lambda
18:18:56 <dmwit> :t  let splitWith pred = filter (pred . head) . group ((==) `on` pred) in splitWith
18:18:58 <lambdabot>     Couldn't match expected type `[[a]]'
18:18:58 <lambdabot>            against inferred type `a -> a -> Bool'
18:18:58 <lambdabot>     In the first argument of `group', namely `((==) `on` pred)'
18:19:02 <dmwit> ryanf: yes
18:19:11 <dmwit> ryanf: case dropWhile (not . pred) lst of ...
18:19:15 <ryanf> ohhh
18:19:18 <ryanf> haven't got to the . yet :)
18:19:23 <dmwit> ?src (.)
18:19:23 <lambdabot> (f . g) x = f (g x)
18:19:23 <lambdabot> NB: In lambdabot,  (.) = fmap
18:19:29 <ryanf> oh duh ok
18:19:29 <dmwit> Now you've gotten to it. =)
18:19:38 <ryanf> figures there would be a composition operator
18:19:49 <ryanf> might have just forgotten it actually, I'm coming back to this book after a while off
18:19:55 <dmwit> :t let splitWith pred = filter (pred . head) . groupBy ((==) `on` pred) in splitWith
18:19:56 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
18:20:03 <cmccann> we have more composition operators than you can shake a stick at
18:20:27 <dankna> I can shake a stick at a lot of composition operators
18:20:27 <dmwit> > let splitWith pred = filter (pred . head) . groupBy ((==) `on` pred) in splitWith isLetter "abc098abc098abc"
18:20:29 <lambdabot>   ["abc","abc","abc"]
18:21:12 <ryanf> it's supposed to split on things where the predicate is false, not true
18:21:29 <dmwit> It is splitting where the predicate is false. =)
18:21:33 <dmwit> > isLetter '0'
18:21:34 <lambdabot>   False
18:21:35 <ryanf> oh hurrrr
18:21:36 <ryanf> yes
18:23:45 <dankna> @hoogle prefix
18:23:45 <lambdabot> Data.Data Prefix :: Fixity
18:23:45 <lambdabot> Text.Parsec.Expr Prefix :: ParsecT s u m (a -> a) -> Operator s u m a
18:23:45 <lambdabot> Text.ParserCombinators.Parsec.Expr Prefix :: GenParser tok st (a -> a) -> Operator tok st a
18:23:55 <dankna> @hoogle isPrefixOf
18:23:55 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
18:23:55 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:23:55 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
18:23:58 <dankna> @hoogle removePrefix
18:23:59 <lambdabot> No results found
18:24:01 <dankna> @hoogle Prefix
18:24:01 <lambdabot> Data.Data Prefix :: Fixity
18:24:01 <lambdabot> Text.Parsec.Expr Prefix :: ParsecT s u m (a -> a) -> Operator s u m a
18:24:01 <lambdabot> Text.ParserCombinators.Parsec.Expr Prefix :: GenParser tok st (a -> a) -> Operator tok st a
18:24:03 <dankna> hm
18:24:31 <ryanf> do I need to load a module to get on and groupBy?
18:24:33 <dankna> ah it's called stripPrefix
18:25:39 <ryanf> got groupBy
18:25:44 <ryanf> googling "on" is tough :)
18:25:45 <cmccann> on is from Data.Function I think
18:25:52 <ryanf> thanks
18:26:05 <dmwit> ?where hoogle
18:26:06 <lambdabot> http://haskell.org/hoogle
18:26:09 <dmwit> ryanf: use that instead =)
18:28:48 <ryanf> on is giving me a headache
18:29:08 <dmwit> ?src on
18:29:08 <lambdabot> (*) `on` f = \x y -> f x * f y
18:29:23 <dmwit> on just applies a function to each of another functions arguments
18:29:25 <ryanf> oh I see
18:29:27 <ryanf> actually
18:29:39 <ryanf> a lot of the problem was I misinterpreted the thing lambdabot just pasted
18:29:42 <dmwit> > ((==) `on` length) "abc" "def"
18:29:43 <lambdabot>   True
18:29:43 <ryanf> and had no idea what * meant
18:29:49 <dmwit> > ((==) `on` length) "abc" "defg"
18:29:50 <lambdabot>   False
18:29:53 <ryanf> cool that makes perfect sense
18:30:09 <ryanf> anyway I was just like "whatever, since I don't know what * means I'll figure it out from the type signature"
18:30:14 <ryanf> which is on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:30:19 <dmwit> Yep!
18:30:29 <dmwit> That type signature could very nearly write the function itself.
18:30:38 <dmwit> ?djinn (b -> b -> c) -> (a -> b) -> (a -> a -> c)
18:30:39 <lambdabot> f a b c _ = a (b c) (b c)
18:30:47 <dmwit> Almost, djinn.
18:32:23 * shachaf is surprised that djinn did that.
18:33:26 <dmwit> Really?
18:33:44 <shachaf> dmwit: I thought it tended to try to use all arguments if it could.
18:33:50 <dmwit> ah
18:33:53 <dmwit> I didn't know that.
18:34:02 <dankna> ahh
18:34:08 <dankna> I see what it did there
18:34:09 <dankna> interesting
18:34:18 <shachaf> @djinn a -> a -> (a,a)
18:34:18 <lambdabot> f a b = (b, a)
18:34:36 <dmwit> haha
18:34:40 <ryanf> it's interesting dmwit that
18:35:00 <ryanf> your approach works for words itself too, but the standard library does the more verbose one
18:35:08 <ryanf> it's not immediately obvious to me which one is more efficient
18:36:12 <dmwit> Well, I guess it's no surprise that the basic library functions are written without using the other basic library functions.
18:36:26 <dmwit> It's one way to make 100% sure there's no cycles in your definitions. =)
18:36:29 <ryanf> > let myWords = filter (not . isSpace . head) . groupBy ((==) `on` isSpace) in myWords "it's not immediately obvious to me which one is more efficient"
18:36:30 <lambdabot>   ["it's","not","immediately","obvious","to","me","which","one","is","more","...
18:36:37 <ryanf> yeah right
18:38:17 <hpc> @src words
18:38:17 <lambdabot> words s = case dropWhile isSpace s of
18:38:17 <lambdabot>     "" -> []
18:38:17 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:40:55 <james4k> hi, lots of people here :o
18:41:06 <dankna> indeed
18:41:21 <Kaidelong> @. unpl djinn a -> a -> (a,a)
18:41:22 <lambdabot> f a b = (b, a)
18:41:28 <Kaidelong> oh right
18:41:30 <Kaidelong> wrong format
18:41:39 <dmwit> Not at all
18:41:41 <Kaidelong> @unpl \a b -> (b, a)
18:41:41 <lambdabot> \ a b -> (b, a)
18:41:43 <dankna> @. elite djinn (a -> b -> c) -> b a
18:41:43 <lambdabot> ERr0R: xInD Err0r: (xaRROw (kVaR 0) (x\/aR 3),xvar 1)
18:41:44 <dmwit> ?unpl f a b = (b, a)
18:41:44 <lambdabot> f a b = (b, a)
18:41:46 <Kaidelong> whoops
18:41:58 <Kaidelong> @. pl djinn a -> a -> (a,a)
18:41:58 <lambdabot> f = flip (,)
18:42:03 <Kaidelong> there we go
18:42:22 <Kaidelong> why does djinn produce flip (,) rather than (,)
18:42:39 <dmwit> Dunno. It's a funny one, huh?
18:42:44 <sully> @. pl djinn (a,b) -> (b,a)
18:42:44 <lambdabot> f = uncurry (flip (,))
18:43:22 <sully> @pl \(x,y) -> (y,x)
18:43:22 <lambdabot> uncurry (flip (,))
18:44:38 <Kaidelong> @. pl djinn a -> b -> (a,b)
18:44:38 <lambdabot> f = (,)
18:45:53 <applicative> hi james4k
18:46:24 <Kaidelong> @. pl djinn (a -> b) -> (c,a) -> (c,b)
18:46:25 <lambdabot> f = (`ap` snd) . (. fst) . flip ((.) . (,))
18:46:42 <james4k> hello applicative
18:46:51 <Kaidelong> > map (^2) ("",2)
18:46:52 <lambdabot>   Couldn't match expected type `[a]'
18:46:52 <lambdabot>         against inferred type `([GHC.Typ...
18:47:08 <Kaidelong> @. pl djinn (a -> b) -> (a,c) -> (b,c)
18:47:08 <lambdabot> f = (`ap` snd) . (. fst) . ((,) .)
18:47:20 <Kaidelong> I thought there was a functor instance for tuples
18:47:47 <ryanf> taking a break, thanks guys
18:47:50 <parcs> :t \f x -> fmap ($x) f
18:47:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
18:48:10 <koninkje> Kaidelong: you can always use `first` and `second`
18:48:14 <megajosh2> For a second that $x made me think of PHP
18:48:20 <Kaidelong> @ty second
18:48:22 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
18:48:41 * koninkje thought there was a Functor instance too though...
18:48:42 <Kaidelong> is pl not smart enough to use second?
18:48:48 <dmwit> (b ~> c) -> ((a, b) ~> (a, c))
18:48:55 <dmwit> Correct, ?pl doesn't use the Arrow stuff.
18:49:15 <shachaf> Kaidelong: Please, "educated enough".
18:49:23 <Kaidelong> ah right
18:52:17 <koninkje> Kaidelong: though beware, the Arrow(->) instance is lazy in the tuples, which may (or may not) be problematic for your uses
19:24:46 <handonson> "You can even implement unboxed arrays yourself for other simple types, including enumerations." http://haskell.org/haskellwiki/Arrays#Unboxed_arrays
19:24:57 <handonson> I wonder how?
19:27:02 <Eduard_Munteanu> You should probably look at the typeclass.
19:27:17 <Cale> That seems incorrect, though in theory it's right.
19:27:26 <Eduard_Munteanu> It's probably something like defining a Storable instance.
19:28:00 <dankna> that capability doesn't appear to actually exist.  it's not a typeclass, just a type.
19:28:02 <dankna> cf. http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Unboxed.html
19:28:27 <Cale> Well, not only that, but the IArray and MArray typeclasses don't expose all of their methods.
19:28:37 <Cale> So you can't write additional instances of them.
19:29:25 <Eduard_Munteanu> Well preserving typesafety would be messy anyway. I can only think of something like unsafeCoerce to get something like that done, unless the compiler does some serialization for you.
19:29:27 <handonson> yes it seemed there was no typeclass i can instantiate
19:29:45 <handonson> could*
19:30:11 <Cale> You can implement your own unboxed array types using the FFI, but you can't make them use the IArray interface without modifying the actual source of that.
19:30:25 <retaehc> what is an unboxed array?
19:30:32 <esteth> I'm browsing the code for an emulator written in haskell, and I've come across this: http://hpaste.org/47190/data__where Could anyone enlighten me as to how a data x y where declaration works? It looks like a mishmash of an instance declaration and a typeclass declaration
19:31:04 <esteth> retaehc: It's where the values themselves live in memory, rather than pointers to computable values
19:31:26 <esteth> retaehc: They're far more space efficient, but only work with certain basic types and I think they are strict
19:31:46 <retaehc> why do they only work with basic types?
19:31:47 <Cale> retaehc: An array whose elements are stored directly in a contiguous block of memory, rather than consisting of boxes, which in GHC are pointers to code which returns the values.
19:32:13 <dolio> You can define new instances if you import Data.Array.Base.
19:32:26 <esteth> retaehc: The size of the elements must be known in advance for the memory allocator to allocate a contiguous chunk of memory, I assume.
19:32:28 <Cale> retaehc: It doesn't make sense for less basic types.
19:32:30 <dolio> If I recall correctly.
19:32:46 <retaehc> Cale, can you give me an example?
19:33:00 <handonson> retaehc: think about an array of lists.
19:33:01 <Cale> Consider an array of IO actions.
19:33:06 <Cale> Or lists, sure
19:33:27 <Cale> The elements are all of different sizes.
19:33:37 <retaehc> wait, what's the difference between lists and arrays?
19:33:45 <handonson> (sigh)
19:34:15 <Cale> A list is either the empty list [], or it is constructed as x:xs from an element x and another list xs
19:34:25 <retaehc> yes sure
19:34:30 <Cale> Lists may be infinite
19:34:51 <retaehc> and an array?
19:34:56 <Cale> An array is a datastructure having fixed bounds, stored as a contiguous chunk of memory, and has "constant time" access to any of its elements.
19:34:57 <esteth> You have to step along the entire list to access an item at the end of it
19:35:15 <retaehc> mhm
19:36:12 <Cale> (I put the quotes there since it's not really physically possible for a datastructure holding an arbitrary number of elements to provide O(1) access to any of them, but it's close enough here.)
19:36:32 <handonson> retaehc: In computer science, array normally means a series of data that occupies a contiguous memory block. List, on the other hand, is usually a series of nodes. A node is a pair - the value, and a pointer that points the next node.
19:37:18 <esteth> nobody can shed some light on the data ... where block, with what appear to be type declarations inside it? http://hpaste.org/47190/data__where
19:37:23 <retaehc> hmmmm.
19:37:35 <mauke> esteth: GADTs
19:37:36 <Cale> esteth: What's your question?
19:37:36 <jmcarthur> that is called a GADT
19:38:01 <esteth> ah, thank you. I'll go look them up :)
19:38:10 <Cale> esteth: The contents of the where clause is a list of type signatures for the data constructors of the type.
19:38:30 <handonson> There are some areas where this is not the case, using list to mean something other than a linked list, like list being a dynamic array in Python
19:38:48 <Cale> esteth: Note that this allows the 'result' type to be specialised by the individual constructors, rather than being necessarily polymorphic in every one of them.
19:38:50 <mauke> or list being multiple values in Perl
19:39:33 <retaehc> or array being some sort of messed up thing in php
19:39:40 <retaehc> is a contiguous memory block just a continuous memory block, or are there any differences
19:40:01 <handonson> But at least in the world of Haskell, list means series of nodes. So they are not necessarily contiguous in memory.
19:40:30 <Cale> retaehc: Well, what is held in that memory can be different. The default boxed arrays store a bunch of pointers to (code for constructing) the actual values.
19:40:37 <mauke> "it's not a big chunk; it's a series of nodes!"
19:41:12 <retaehc> what is the difference between contiguous and continuous memory blocks?
19:41:36 <mauke> what's a continuous memory block?
19:41:44 <handonson> array is contiguous in memory, while list isn't
19:41:48 <shachaf> mauke: It's like a contiguous memory block, but with an n.
19:42:00 <retaehc> a block of memory that starts somewhere and ends somewhere else, without holes
19:42:05 <mauke> thanks, shachaf. thachaf.
19:42:09 <Cale> retaehc: Like all ordinary Haskell values, when that code is executed the first time, the expression for the value is evaluated, and the pointer is updated to point at a shorter piece of code which can return the result immediately for next time the value is needed.
19:42:16 <mauke> retaehc: that's contiguous
19:42:31 <retaehc> ok
19:42:34 <mauke> http://dict.leo.org/ende?search=contiguous
19:42:59 <retaehc> Cale, that's nice
19:43:12 * shachaf wonders what a non-contiguous memory block is.
19:43:16 <Cale> (at least, this is how GHC's implementation works)
19:43:21 <retaehc> so it's like it's memoized
19:43:28 <Cale> Yeah, constant expressions are.
19:43:35 <mauke> "allocate an array, free the middle third"
19:43:56 <Cale> Or, rather, anything which is bound to a variable is, as long as it remains in scope.
19:44:43 <handonson> So my question is ... Say I have { data Directions = East | West | North | South deriving Enum } and ... Can I have an unboxed array with Direction as index, NOT using FFI? If so, how?
19:45:21 <mauke> Direction as an index? I don't see why not
19:45:46 <handonson> *unboxed*
19:46:19 <mauke> boxedness is irrelevant for the indices
19:46:23 <esteth> the index into the array just needs to implement Ix
19:46:34 <esteth> it's the contents that need to be "unboxable"
19:46:43 <handonson> Oh really?
19:46:46 <handonson> Great.
19:50:52 <dankna> um
19:50:57 <dankna> of course, the array will only have four elements
19:51:06 <dankna> I'm not sure why you want that :)
19:52:18 <handonson> yeah, that was a simpler example to explain what I wanted... I'm working on some CJK code
19:52:23 <dankna> oh!  okay
19:53:08 <handonson> my goal is to correctly assemble/disassemble Hangul, the Korean alphabet
19:53:17 <dankna> fascinating
19:53:54 <cmccann> ah, gotta love an alphabet built from modular reusable components
19:54:13 <dankna> well, it's actually as I understand it something like each character actually has three sub-characters...
19:54:26 <dankna> which are the actual "alphabet"
19:54:33 <dankna> (or syllabary, not sure which)
19:54:38 <cmccann> yeah, I'm passingly familiar with it
19:54:59 <cmccann> it's actually very coherent and well-structured if memory serves me
19:55:25 <dankna> do you know when it was designed?
19:55:44 <dankna> I know I was impressed by the Japanese syllabary, until I realized it dated from the 20th century and was designed by people with actual knowledge of linguistic principles :)
19:56:07 <dankna> (that doesn't make it unimpressive by any means, but less impressive at least, in that it implies less forethought)
19:56:51 <cmccann> nah, I don't recall the details
19:56:57 <dankna> ah well
19:56:58 <handonson> Hangul was released in 1446
19:57:12 <dankna> ooh interesting
20:00:06 <dankna> okay so!  http://hpaste.org/47192/comments_please
20:00:15 <dankna> comments are welcome on both code style and behavior choices
20:00:33 <dankna> do you think that last condition should check whether the year is different, instead of being weeksAgo < 52 ?
20:00:56 <shachaf> dankna: That long chain of ifs looks suspicious.
20:01:07 <dankna> shachaf: I agree.  I couldn't think of a better way to word it, heh.
20:01:21 <dankna> wait, yes I can, haha
20:01:43 <tgeeky> byorgey: here?
20:01:48 <shachaf> dankna: You could use something like "foo [(secondsAgo,60,asSecondsAgo),...]"
20:02:13 <dankna> yes, that's what I'm doing
20:02:28 <dankna> specifically I'm doing head $ catMaybes $ (\...) ....
20:02:29 <shachaf> In fact, you don't need secondsAgo, minutesAgo, etc., since those numbers already appear there.
20:02:50 <dankna> how do you mean?
20:03:08 <shachaf> Well, minutesAgo = secondsAgo / 60, and you have a 60 right there.
20:03:26 <dankna> mm, true, but that feels like tersity at the expense of clarity
20:03:35 <shachaf> I think you could express it cleanly.
20:03:55 <dankna> note that the last two formats are heterogenous
20:04:43 <shachaf> Where's asMinutesAgo defined, anyway?
20:04:56 <dankna> it's not, I left it out by accident
20:05:06 <dankna> I just added it in my live copy, which I'm updating the paste with, one sec
20:05:24 <dankna> there, reload and scroll down
20:05:53 <dankna> the code isn't any shorter now, but at least the indentation isn't quite as deep, haha
20:06:59 <dankna> so yeah, do you really think it's okay that I chose to display, for example, "Dec 2nd" without a year all the way .... ummm.... that should at the very least be weeksAgo < 48, not weeksAgo < 52
20:07:52 <dankna> ... all the way into the following year?
20:08:54 <shachaf> @hoogle getTimestamp
20:08:54 <lambdabot> No results found
20:09:07 <dankna> my own function.  getTimestamp = getPOSIXTime >>= return . floor
20:09:10 <shachaf> Oh, it's your own function.
20:09:12 <dankna> yes
20:09:22 <dankna> seconds since Unix
20:09:41 <shachaf> floor <$> getPOSIXTime :-)
20:09:47 <dankna> amusement, noted
20:09:52 <dankna> @hoogle <$>
20:09:52 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
20:10:32 * shachaf can't get your code to compile.
20:10:46 <dankna> you need the packages "time" and "old-locale"
20:11:03 <dankna> also, I haven't compiled it myself yet *^_^* (emoticon denotes blush)
20:11:37 <retaehc> @hoogle $
20:11:38 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
20:11:38 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
20:11:38 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
20:11:43 <dankna> ah yes, s/in/return $/
20:13:31 <dankna> will paste the entire working source file in a sec
20:14:26 <esteth> Is it possible to declare a type like Word26 easily, or am I going to have to lose typesafety and move to Word32?
20:15:21 <dankna> shachaf: okay, if you're still interested in running it, reload the page again
20:16:26 <esteth> from what I can see the sized basic types are FFI'd to Ctypes, so I'm probably screwed, especially if I want them to be unboxable.
20:16:37 <shachaf> dankna: "01st" looks a bit weird.
20:17:19 <dankna> shachaf: good catch
20:17:54 <koninkje> esteth: You're best off defining: newtype Word26 = W26 Word32; and then making smart constructors and instances which work appropriately
20:18:38 <dankna> 42s/string/(show ordinal)/
20:19:07 <esteth> koninkje: That's not a bad idea for enforcing the limit :)
20:19:19 * koninkje things Word26 is a really strange type though
20:19:23 <koninkje> :)
20:19:45 * cmccann wants a Word10AndAHalf
20:20:18 <blackdog> had an interesting point brought up on twitter by @kornys - is there a visual representation for FP programs the way you have UML for OO and flowcharts for imperative?
20:20:36 <cmccann> yes, it's called "source code"
20:20:40 <tgeeky> heh
20:20:43 <tgeeky> I was going to make that comment
20:20:45 <blackdog> my first impulse was to say that it's not necessary, that good FP programs should be well factored enough that you can read each in a line
20:20:53 <cmccann> anyway I'm pretty sure UML isn't a visual representation of anything at all
20:21:21 <tgeeky> cmccann: *scratches head*
20:21:22 <dankna> UML has a purpose
20:21:24 <blackdog> cmccann: maybe not full-fledged UML, but when i'm designing a rails app i'll usually draw a few liens and boxes.
20:21:43 <blackdog> *lines - i don't think a legal action is very helpful :)
20:21:52 <mauke> I'd say flowcharts
20:21:58 <mauke> except it's data flow, not control flow
20:22:01 <koninkje> blackdog: You might want to consider GOI
20:22:25 <cmccann> sketching random lines and boxes and whatnot to help you think is reasonable so I guess might as well make it look like UML
20:22:36 <blackdog> koninkje: cursory googling has failed me - context?
20:22:37 <Kaidelong> blackdog: What about arrow notation?
20:23:04 <blackdog> Kaidelong: not sure what you mean. as in generalised monads?
20:23:28 <cmccann> but in general those sorts of abstract visual representations are supposed to show something about the program structure, in a "see the forest, not the trees" sort of way
20:23:41 <cmccann> which strikes me more as indicating the limitations of the languages they're intended for
20:23:50 <cmccann> not that you can't write horrible messy code in any language
20:23:57 <tgeeky> cmccann: I can! err
20:23:58 <blackdog> cmccann: i guess the problem there is that it seems to make sense to talk about boxes with localised state in them and interactions in the world - less so to think about combinations of the boxes
20:24:00 <tgeeky> wait a minute
20:24:21 <tgeeky> dankna: can I get a little mentoring for a second here?
20:24:29 <blackdog> cmccann: yeah, so coming back to the idea that if you can't read the source clearly then the program is bad.
20:25:11 <tgeeky> dankna: I need some help writing the *very minimal* amount of code to get something out of the mpppc package
20:25:16 <esteth> koninkje: I'd like Word26 for modelling memory addresses in R2000 mips processors :)
20:25:18 <tgeeky> just get anything going
20:25:19 <cmccann> that depends on your definition of "clearly"
20:26:01 <dankna> tgeeky: I can try.  wtf is mpppc?
20:26:06 <dankna> @hackage mpppc
20:26:06 <lambdabot> http://hackage.haskell.org/package/mpppc
20:26:08 <cmccann> blackdog, but all else equal, if I'm going to do something to represent the high-level structure of a program I'd rather have it be part of the program as much as possible
20:26:19 <tgeeky> dankna: it's a pretty printer library
20:26:21 <dankna> (and why me precisely haha)
20:26:29 <tgeeky> dankna: it's modeled after byorgey's "boxes" library
20:26:40 <dankna> okay, but I haven't used that, either, haha
20:26:47 <tgeeky> dankna: because you've been excessively helpful in the past, so I am punishing you for your kindness!
20:26:51 <dankna> amusement!  okay
20:27:02 <blackdog> cmccann: tend to agree. I think, delving into his question, he's really looking for a way to do top-level & prototyping design.
20:27:02 <tgeeky> I just want to print something to the console :|
20:27:09 <tgeeky> dankna: I can give you a package that actually *uses* mpppc
20:27:23 <dankna> nah, the docs are good enough for me.  hpaste whatever you have that doesn't work?
20:27:24 <blackdog> cmccann: the only thing that really comes to mind is type-directed programming
20:27:29 <tgeeky> dankna: there are no docs :O
20:27:32 <tgeeky> dankna: well, no non-API docs
20:27:34 <dankna> what do you call http://hackage.haskell.org/packages/archive/mpppc/0.1.2/doc/html/Text-PrettyPrint-MPPPC-OneDim.html
20:27:35 <blackdog> the first version of my code has a lot of undefineds with type decls:)
20:27:35 <dankna> oh
20:27:42 <monochrom> Jackson Structured Design works for both FP and imperative programming
20:27:47 <tgeeky> dankna: I have tasked myself with writing the docs :O
20:27:49 <dankna> anyway, the API docs make sense to me
20:27:55 <dankna> good ambition, I approve
20:28:00 <cmccann> blackdog, that's a very common approach I think, particularly in Haskell
20:28:05 <tgeeky> dankna: not off to a great start, though
20:28:34 <dankna> well, let me get it installed and see what I can see
20:29:09 <tgeeky> dankna: http://hpaste.org/47197/mpppcexamples
20:29:11 <blackdog> cmccann: yes. it's funny to try to think about - i'm used to doing it, but introspection is hard.
20:29:52 <dankna> not personally a fan of the GPL license :) but anyway
20:30:04 <tgeeky> dankna: autogenerated by leksah
20:30:27 <dankna> gotcha
20:31:40 <tgeeky> dankna: brb, coffee
20:33:28 <shachaf> dankna: Also, your code doesn't handle "23th" etc.
20:33:35 <shachaf> (Which is a bit tricky because "13th" is correct.)
20:33:44 <koninkje> blackdog: http://www.google.com/search?q=goi+lambda
20:34:31 <koninkje> blackdog: in particular, some folks use GOI as their graphical representation of terms (instead of the standard representation used by, say, the STg0
20:34:39 <koninkje> s/STg0/STG)/
20:34:40 <tgeeky> schroedinbug: 23rd?
20:34:49 <tgeeky> shachaf: 23rd?
20:35:24 <koninkje> esteth: ha. I never knew there were 26-bit processors out there :)
20:35:25 <shachaf> tgeeky: Right.
20:35:30 <shachaf> It's actually easy to fix, though.
20:35:47 <tgeeky> shachaf: is there a name for that kind of thing?
20:35:50 <dankna> ah!  okay
20:35:54 <dankna> shachaf: thank you for that catch
20:35:57 <dankna> yes, one-line fix
20:36:05 <dankna> er, several-line, but.
20:37:21 <shachaf> Hah, you could use firstWorkingAlternative.
20:37:57 <dankna> hah, so I could, haha
20:38:05 <dankna> but that said, I just fixed it -- hpaste in a sec
20:38:10 <shachaf> Oh, I fixed it too.
20:38:22 <dankna> I also fixed the problem where it would say "1 minutes ago"
20:38:24 <dankna> did you do that? :)
20:38:36 * shachaf trying to get rid of the redundancy in a clean way.
20:39:35 <shachaf> dankna: appendEnglishOrdinalMarker string = let { ordinal "" = 0; ordinal o  = read o; marker n | n `elem` [1,21,31] = "st" | n `elem` [2,22] = "nd" | n `elem` [3,23] = "rd" | otherwise       = "th" } in string ++ marker (ordinal string)
20:39:36 <dankna> paste annotated
20:40:00 <dankna> shachaf: no no no!  case (mod (div ordinal 10) 10, mod ordinal 10) of ...
20:40:04 <shachaf> Aw, you're being uselessly general about it.
20:40:07 <dankna> teens are the only special case
20:40:08 <dankna> haha
20:40:17 <monochrom> god, an algorithm to add "th" after numbers
20:40:17 <shachaf> dankna: No they're not.
20:40:19 <dankna> in the year 2525, if man is still alive, he will thank me
20:40:44 <shachaf> What does the year 2525 have to do with it?
20:40:48 <dankna> it's a song reference
20:40:52 <tgeeky> hm
20:41:02 <tgeeky> I hereby call these things "ordinal decorators"
20:41:03 <dankna> but also a humorous suggestion that perhaps some new Caesar will mutilate the calendar by then
20:41:21 <monochrom> or some new ISO
20:41:24 <dankna> indeed
20:41:40 <dankna> ordinal decorators, hah
20:42:05 <dankna> anyway, monochrom, Apple has had their own version of this algorithm since forever and it makes people subtly happy :)
20:42:21 <james4k> any of you gone through "learn you a haskell for great good"?
20:42:28 <dankna> I just thought that since what I'm doing is meant to be a cross-platform program, I shouldn't rely on theirs
20:42:36 <dankna> james4k: not I
20:42:39 <tgeeky> james4k: I have
20:42:44 <monochrom> interesting
20:42:47 <dankna> tgeeky: still struggling with getting that thing to produce any output :)
20:42:53 <tgeeky> dankna: :|
20:42:56 <shachaf> dankna: What's their algorithm?
20:43:11 <james4k> what'd you think? good way to learn haskell? :o
20:43:17 <dankna> shachaf: well, it's not open-source (afaik), so I don't know its details.  it's similar in general approach to mine.
20:43:34 <tgeeky> james4k: Hard to tell. I think it's a great introduction.
20:44:10 <monochrom> what is a good way depends on you, too
20:44:22 <monochrom> upload your whole brain for a free complete analysis
20:44:35 <tgeeky> yeah, the "hard to tell" thing is a comment about the next thing I tried, I'm rather failing at it
20:44:42 <sanjoyd> I'm trying to use template haskell, and get a parse error on runQ [| matcherN x = if x == 'a' then 5 else if x == 'b' then 6 else 7 |] >>= print
20:44:51 <dankna> note: monochrom does not promise not to run a million parallel copies of your brain in simulated torture chambers
20:45:00 <monochrom> hahaha
20:45:02 <sanjoyd> "parse error on input `='"
20:45:02 <dankna> :D
20:45:03 <tgeeky> sanjoyd: extra else?
20:45:09 <monochrom> err, bwahahahaha
20:45:34 <sanjoyd> tgeeky: does not look like it.
20:45:38 <tgeeky> sanjoyd: if x == 'a' then 5; if x == 'b' then 6; else 7 |]?
20:45:44 * sanjoyd tries.
20:45:44 <tgeeky> or am I using another language?
20:46:05 <sanjoyd> Nope.
20:46:08 <sanjoyd> Does not help.
20:46:15 <sanjoyd> Plus I get a parse error on '='.
20:46:25 <dankna> is that the proper syntax for quoting a definition?
20:46:28 <jdavis> How can I convert from a lazy ByteString to a strict ByteString?
20:46:31 <dankna> isn't it [d| ... |] ?
20:46:42 <sanjoyd> dankna: oh, oaky.
20:46:45 <sanjoyd> That must be it.
20:46:51 <dankna> jdavis: BS.concat $ BSL.toChunks
20:47:01 <sanjoyd> dankna: yeah, works.
20:47:05 <dankna> excelling
20:47:05 <sanjoyd> Thanks a ton.
20:47:07 <jdavis> dankna: thanks
20:47:07 <dankna> np
20:47:51 <dankna> tgeeky: so you definitely need to import at least Text.Print.MPPPC.OneDim and Data.String
20:48:05 <tgeeky> dankna: yeah, I had that earlier but removed it before I pasted
20:48:05 <dankna> tgeeky: so far I've got > text (fromString "Dan" :: Pretty (Seq String Char) (Tok String Char))
20:48:17 <dankna> but it doesn't find the instance
20:48:23 <dankna> presumably for lack of fundeps?  hm
20:48:25 <tgeeky> try SimplePretty?
20:49:44 <dankna> so uhhhh
20:49:50 <dankna> any clue what the Float parameter to renderPretty is?
20:50:30 <tgeeky> dankna: nope
20:50:40 <tgeeky> renderSeq has a hardcoded 0.4
20:50:40 <tgeeky> in there
20:50:49 <tgeeky> then an 80, presumably the line length
20:51:43 <dankna> > unSeq $ renderSimplePretty $ renderPretty 1.0 80 $ text (fromString "Dan" :: Seq String Char)
20:51:43 <lambdabot>   Not in scope: `unSeq'Not in scope: `renderSimplePretty'Not in scope: `rende...
20:51:53 <dankna> produces some output.
20:52:15 <tgeeky> indeed
20:52:49 <dankna> ooh, putStrLn $ unSeq $ renderSimplePretty $ renderPretty 1.0 80 $ bold $ text (fromString "Dan" :: Seq String Char)
20:52:51 <dankna> does it in bold!
20:53:09 <tgeeky> so how did you figure that out?
20:53:28 <dankna> oh, intuition :)
20:53:39 <dankna> well, I looked at the type signatures of render*
20:53:50 <dankna> and the instances that existed
20:54:30 <dankna> I got as far as knowing that I needed an s matching Printable s _ to be a parameter to text
20:54:45 <dankna> and I looked at the instances of Printable, of which there are only two
20:54:53 <tgeeky> ok
20:54:58 <dankna> and so I knew the parameter to text had to be Seq String Char
20:55:09 <tgeeky> why not use the things in Display
20:55:17 <tgeeky> hPutPretty, putPretty?
20:55:31 <tgeeky> those are for printing to files or?
20:55:33 <dankna> because ... do those exist?
20:55:38 <tgeeky> yes
20:55:41 <dankna> oh hey, so they do
20:55:46 <tgeeky> in OneDim.Display
20:55:46 <dankna> but they were near the middle of the file, so I didn't see them
20:55:55 <dankna> uh we're looking at different versions of the package!
20:56:01 <dankna> I'm looking at 0.1.2
20:56:11 <tgeeky> as am I
20:56:20 <dankna> where do you see a Display module? O_o
20:56:31 <tgeeky> Text.PrettyPrint.MPPPC.Display
20:56:41 <dankna> http://hackage.haskell.org/package/mpppc -- doesn't appear in the list of modules here
20:56:43 <tgeeky> Text.PrettyPrint.MPPPC.OneDim.Display
20:56:46 <tgeeky> yeah, it's not exported
20:56:48 <dankna> oh
20:56:49 <dankna> gotcha
20:57:14 <tgeeky> the type is putPretty :: Printable s t => Pretty st -> IO ()
20:57:15 <dankna> so I would have known it existed how, precisely?  note: you can and should use -- * This is a section, in the export list
20:57:20 <dankna> to split the file into sections
20:57:35 <tgeeky> dankna: yeah, I will try do what's appropriate
20:57:40 <tgeeky> dankna: not my package at all :O
20:57:44 <dankna> okay, so let me see about using putPretty instead of the thing
20:57:46 <dankna> yes I understand
20:57:50 <dankna> I'm just saying, when you get that far
20:58:07 <tgeeky> i've done a bunch of docs, but then I realized I had no idea what some of this stuff does
20:58:14 <tgeeky> because I couldn't get it to *do*
20:58:17 <dankna> ah that's MUCH terser
20:58:17 <dankna> putPretty $ bold $ text (fromString "Dan" :: Seq String Char)
20:58:27 <dankna> indeed so
20:58:38 <dankna> well, does this solve your problem or do you have further questions?
20:58:41 <tgeeky> so if I want to get rid of ::Seq String Char
20:58:50 <dankna> I don't think you can
20:58:52 <tgeeky> i just make my own internal string type?
20:59:17 <tgeeky> dankna: http://hackage.haskell.org/packages/archive/pisigma/0.2/doc/html/src/Language-PiSigma-Pretty.html
20:59:21 <koninkje> let toSeq :: String -> Seq String Char ; toSeq = fromString
20:59:43 <dankna> ah, yeah
20:59:53 <tgeeky> dankna: I was smart enough to look up reverse dependencies and find a package that used it
20:59:54 <koninkje> assuming you're going to be using it a lot
20:59:57 <tgeeky> but not smart enough to understand
21:00:48 <dankna> oh, actually
21:01:25 <dankna> hm, no
21:01:29 <dankna> what koninkje said
21:01:37 <tgeeky> ok, i've got a starting point
21:01:40 <dankna> yepyep
21:01:40 <tgeeky> thanks!
21:01:42 * tgeeky bows
21:01:44 <dankna> np!
21:01:45 <dankna> oh btw
21:01:51 <dankna> if you're taking over as maintainer of the package
21:01:56 <dankna> you might consider adding a functional dependency
21:02:01 <tgeeky> i am gonna put them all over
21:02:09 <blackdog> koninkje: geometry of interaction?
21:02:11 <tgeeky> i plan on bringing all the cabal-listed extensions into each file
21:02:19 <koninkje> blackdog: Yeah
21:02:27 <dankna> because I think the functional dependency could allow you to do it as
21:02:33 <koninkje> blackdog: the encoding of lambda calculus in GOI, more particularly
21:02:38 <dankna> putPretty $ bold $ text $ Seq "Dan"
21:02:56 <dankna> you can't do that right now because it can't infer the instance Seq String Char from Seq String t
21:03:01 <dankna> because no fundep
21:03:19 <tgeeky> dankna: yeah, the 2nd link I sent overrode that
21:03:30 <tgeeky> dankna: by creating a different Pretty and using an "internal" string class
21:03:33 <tgeeky> or something, anyway, to work
21:03:45 <dankna> okay.  hm.
21:03:58 <jdavis> wohoo! my haskell program is now only 2x slower than my C program.
21:03:59 <tgeeky> dankna: http://hackage.haskell.org/packages/archive/pisigma/0.2/doc/html/src/Language-PiSigma-Pretty.html
21:04:03 <tgeeky> that one
21:04:15 <jdavis> (still optimizing, that wasn't a sarcastic remark)
21:04:32 <tgeeky> jdavis: haskell programmers are *never* sarcastic
21:04:35 <Axman6> yay!
21:04:38 <dankna> jdavis: nice
21:04:45 <Axman6> jdavis: what's it do?
21:04:48 <dankna> jdavis: how'd you do it?
21:04:54 <mauke> "segfault"
21:04:55 <dankna> tgeeky: yes I see
21:05:17 <jdavis> Axman6: it's reading the postgresql binary data format
21:05:28 <jdavis> dankna: I am mixing lazy and strict bytestrings
21:05:33 <Axman6> ah, sounds intetresting
21:05:39 <dankna> ah interesting
21:05:48 <jdavis> and I'm applying a bunch of filters to the tuples
21:05:55 <Axman6> thatsl (almost) what i said!
21:05:59 <tgeeky> dankna: btw, the h in hPutPretty is "handle"?
21:06:05 <Axman6> yes
21:06:10 <dankna> tgeeky: yes
21:06:39 <jdavis> one thing about postgres is that adding new filters generally has a surprisingly high cpu cost. I think the per-filter cost is lower in haskell, but it takes more to unpack the tuples.
21:06:41 <shachaf> dankna: How's my annotation?
21:06:56 * shachaf is somewhat less happy with it than he'd hoped.
21:07:21 <dankna> shachaf: looking
21:07:22 <shachaf> Because of the unused arguments and such.
21:07:36 <Axman6> jdavis: will you be releasing this code on hackage?
21:07:48 <dankna> hmm, interesting
21:08:36 <dankna> I wound up doing something similar to suffixShow already, except it checks the quantity too, so that it knows whether the word should be plural
21:09:02 <jdavis> Axman6: well, I don't mind, but it's not terribly useful at the moment. I am going to see if I can beat postgresql's C code at some reasonable set of filters, and then I was going to do a writeup.
21:09:04 <shachaf> Oh, right, there's that too.
21:09:19 <dankna> subtle stuff, haha
21:09:34 <Axman6> jdavis: sounds good. what're you using to decode the binary data?
21:09:45 <shachaf> The main difference is getting rid of some redundancy with divUntilSmaller (which can probably be expressed as a one-line fold in some obvious way).
21:09:50 <dankna> well, this certainly does make it contain less redundant information, yes
21:10:00 <jdavis> Axman6: using strict and lazy bytestrings, and strict and lazy versions of Data.Binary.Get
21:10:09 * shachaf likes how putting the default argument at the end aligns nicely and makes the "]" line less useless.
21:10:19 <dankna> hah
21:10:20 <dankna> yes
21:10:22 <dankna> I see that
21:11:01 <Axman6> jdavis: might be worth trying out cereal as well, just to see if there's any speed difference. i believe the Get and Put monads will work with exactly the same code for both Binary and Cereal
21:11:01 <jdavis> Axman6: right now it's about half strict and about half lazy, but I think that I only want the page reads to be lazy, and the rest of it I think will be faster with the strict version.
21:11:25 <shachaf> Hmm, divUntilSmaller is probably expressible as fromJust . find . mapAccumSomething.
21:11:33 <shachaf> Something of that sort.
21:11:38 <jdavis> Axman6: hmm, OK.
21:12:12 <dankna> well, anyway, thank you for looking at it :)
21:12:15 <shachaf> Or maybe with until?
21:12:29 <shachaf> dankna: I'll take that as "those changes make it too difficult to read". :-)
21:12:33 <dankna> hahaha
21:12:37 <dankna> yeah :)
21:12:42 <Axman6> cereal gives for a bit more flexibility when you're decoding is all
21:13:18 <jdavis> Right now I'm trying to install the profiler support for binary-strict ... how do I do that with cabal?
21:13:53 <Axman6> cabal install -p binary-strict
21:14:42 <dankna> > "Programs should be written " ++ (intercalate ", and only" $ map (\(arily, who, what) -> arily ++ "arily for " ++ who ++ "s to " ++ what) [("prim", "human", "read"), ("second", "computer", "execute")])
21:14:43 <lambdabot>   "Programs should be written primarily for humans to read, and onlysecondari...
21:14:49 <dankna> > "Programs should be written " ++ (intercalate ", and only " $ map (\(arily, who, what) -> arily ++ "arily for " ++ who ++ "s to " ++ what) [("prim", "human", "read"), ("second", "computer", "execute")])
21:14:51 <lambdabot>   "Programs should be written primarily for humans to read, and only secondar...
21:14:57 <dankna> > "Programs should be written " ++ (intercalate ", and only " $ map (\(arily, who, what) -> arily ++ "arily for " ++ who ++ "s to " ++ what) [("prim", "human", "read"), ("second", "computer", "execute")]) ++ "."
21:14:58 <lambdabot>   "Programs should be written primarily for humans to read, and only secondar...
21:15:01 <dankna> there we go
21:15:11 <dankna> (quotebait hehe)
21:15:19 <tgeeky> knuth :o
21:15:26 <dankna> er, no, it's Dijkstra
21:15:31 <tgeeky> damn, 50/50
21:15:33 <dankna> hehe
21:15:41 <jdavis> Axman6, is there a way to get it to resolve the dependencies automatically? I keep getting errors
21:16:04 <Jafet> It does resolve dependencies automatically. That's probably why you're getting errors.
21:16:22 <Axman6> you should turn on profiling for all libraries in your ~/.cabal/config, and then reinstall the libraries you need
21:16:35 <shachaf> dankna: Eliminating redundancy is good for humans, not (just) computers.
21:16:45 <dankna> shachaf: oh I do agree!
21:16:51 <shachaf> Computers probably wouldn't care which version you used.
21:17:10 <dankna> in the general case.  in specific cases there can be exceptions.  I don't yet have a full set of principles for determining which case is which. :)
21:17:19 <cmccann> shachaf, yes, that's why running code through lambdabot's pointless converter makes it both more readable and more efficient
21:17:35 <dankna> @pl "Programs should be written " ++ (intercalate ", and only " $ map (\(arily, who, what) -> arily ++ "arily for " ++ who ++ "s to " ++ what) [("prim", "human", "read"), ("second", "computer", "execute")]) ++ "."
21:17:36 <lambdabot> (line 1, column 80):
21:17:36 <lambdabot> unexpected ","
21:17:36 <lambdabot> expecting letter or digit, operator or ")"
21:17:36 <lambdabot> ambiguous use of a non associative operator
21:17:45 <shachaf> cmccann: @pl doesn't (usually) reduce redundancy.
21:17:57 <shachaf> dankna: Can't handle 3-tuples.
21:18:00 <dankna> oh, drat
21:18:02 <shachaf> Try CPS-tranforming it. :-)
21:18:08 <dankna> haha what's the command for that
21:18:11 <dankna> @cps "Programs should be written " ++ (intercalate ", and only " $ map (\(arily, who, what) -> arily ++ "arily for " ++ who ++ "s to " ++ what) [("prim", "human", "read"), ("second", "computer", "execute")]) ++ "."
21:18:12 <lambdabot> (line 1, column 80):
21:18:12 <lambdabot> unexpected ","
21:18:12 <lambdabot> expecting letter or digit, operator or ")"
21:18:12 <lambdabot> ambiguous use of a non associative operator
21:18:20 <shachaf> No, I mean in order to give it to @pl.
21:18:23 <dankna> oh, hmm
21:18:25 <shachaf> Maybe I didn't mean CPS-transform.
21:18:43 <shachaf> I probably meant something more along the lines of Church-encode.
21:18:51 <dankna> O_o
21:19:08 <shachaf> Representing ... -> (a,b,c) as ... -> (a -> b -> c -> r) -> r
21:19:18 * adorablepuppy just committed his code for the day.
21:19:37 <Jafet> @hoogle uncurry3
21:19:37 <lambdabot> No results found
21:19:45 <dankna> right, I'm familiar with the technique, I've used it recently
21:19:57 <robinhoode|away> I gotta hand it to the Haskell community. You guys are certainly a group of badasses: http://stackoverflow.com/questions/6065951/parsing-haskell-preserving-comments-formatting
21:20:02 <cmccann> shachaf, it avoids creating superfluous identifiers and eliminates redundant code like applying multiple functions to the same argument
21:20:21 <shachaf> cmccann: Sometimes it makes code a lot more redundant, though.
21:20:23 <Jafet> @pl "Programs should be written " ++ (intercalate ", and only " $ map (\(arily, (who, what)) -> arily ++ "arily for " ++ who ++ "s to " ++ what) [("prim", ("human", "read")), ("second", ("computer", "execute"))]) ++ "."
21:20:26 <lambdabot> "Programs should be written " ++ intercalate ", and only " ["prim" ++ "arily for humans to read", "second" ++ "arily for " ++ "computer" ++ "s to " ++ "execute"] ++ "."
21:20:26 <lambdabot> optimization suspended, use @pl-resume to continue.
21:20:26 <shachaf> Maybe redundant isn't quite the right word.
21:20:35 <Jafet> @pl-resume
21:20:36 <shachaf> @pl-resume
21:20:38 <lambdabot> "Programs should be written " ++ intercalate ", and only " ["primarily for humans to read", "secondarily for computers to execute"] ++ "."
21:20:38 <lambdabot> pointless: sorry, nothing to resume.
21:20:42 <cmccann> shachaf, don't worry about it, I'm joking anyway :P
21:21:02 * Jafet drops a CAF on dankna
21:21:32 <cmccann> although the heart of @pl's obfuscatory power comes from something that can actually remove that kind of redundancy
21:21:35 <shachaf> CAF?
21:21:37 <robinhoode|away> Almost every parser generator I've seen strips comments and formatting..
21:22:28 * cmccann just wishes haskell-src-exts could handle infix operators properly
21:23:06 <cmccann> not that I'd want to be the one to implement that, agh
21:23:08 * hackagebot json2 0.8.2 - Library provides support for JSON.  http://hackage.haskell.org/package/json2-0.8.2 (YuriyIskra)
21:25:08 * hackagebot json2 0.8.3 - Library provides support for JSON.  http://hackage.haskell.org/package/json2-0.8.3 (YuriyIskra)
21:25:13 <jdavis> OK, this is strange. I have a very tiny function that looks like it should have no real penalty, but I saw it in the profiler so I removed it, and I did get a little boost.
21:26:57 <jdavis> http://hpaste.org/47200/tiny_function
21:27:10 <jdavis> I guess the fromIntegral is a runtime cast?
21:27:22 <jdavis> All I need is a compile-time cast though.
21:27:56 <jdavis> (in fact, that's the correct thing to do, because the bytes are for a signed integer stored on disk)
21:28:46 <Axman6> isn't there a getInt32Host?
21:28:47 <cmccann> jdavis, it's possible that it is, yes
21:29:28 <Jafet> A little boost?
21:29:36 <shachaf> "Adman6"5?
21:29:44 <shachaf> Axman6: Come on, you're stretching it.
21:29:47 <jdavis> Axman6, I don't see one, that's why I made it.
21:29:57 <cmccann> jdavis, naively that's going to convert to Integer (which is an arbitrary-size integer) and then back
21:30:01 <jdavis> Jafet: it went from about 6.8 seconds to 6.3
21:30:17 <jdavis> cmccann: any way to avoid that?
21:30:32 <Jafet> Is that what really happens?
21:30:51 <Jafet> Look at the GHC core.
21:31:13 <jdavis> Jafet: not sure what you're asking -- can you elaborate a little?
21:31:13 <cmccann> sometimes you'll get compiler magic to optimize away the useless conversion, yes
21:31:26 <cmccann> but I don't know how reliable that is
21:31:44 <Jafet> If that's what's going on, you might find something more direct in Prim
21:32:24 <Axman6> running ghc-core should tell you if there's be an optimisation hit that speeds up that conversion or not
21:33:22 <Jafet> GHC.Prim.word2Int# :: Word# -> Int#
21:33:37 <cmccann> I'm not sure if sending someone new to Haskell to dig through core is helpful :P
21:34:03 <cmccann> at least I think jdavis is fairly new, maybe I'm getting confused here
21:34:29 <Axman6> @src Word32
21:34:30 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:34:31 <Axman6> @src Word
21:34:32 <lambdabot> Source not found. stty: unknown mode: doofus
21:34:35 <Axman6> weak
21:34:40 <Jafet> Why not
21:34:55 <Jafet> If he's interested in performance, he should learn to read core
21:35:17 <jdavis> cmccann: I'm certainly new.
21:35:41 <jdavis> Jafet: ok, well, I'll take a look. Is there a primer somewhere?
21:35:49 <cmccann> I'm not saying he shouldn't necessarily, just that it's kinda "jump in the deep end while learning to swim"
21:35:55 <dankna> yeah, it's worth trying to teach him.  the user guide section on the core contains the highly amusing remark, "'It's just a simple functional language' is a trademark of Peyton-Jones Enterprises, Inc"
21:36:00 <Axman6> anyway, the function you want in that case is probably something like word2int :: Word32 -> Int32; word2int (W32# w) = I32# (word2Int w)
21:36:05 <cmccann> then again maybe it'll help, since it reveals more of the low-level nitty gritty stuff
21:37:13 <Jafet> Whether he's new or not is irrelevant. You want performance: 1) profile 2) read core 3) increase strictness (hm, who am I paraphrasing?)
21:38:01 <cmccann> you forgot 0) understand how this stuff works :P
21:38:54 <jdavis> What is with the # in the definition of word2int? I still haven't figured out how to even call it.
21:39:49 <Jafet> If the core already does the conversion directly, you won't need to.
21:40:09 <cmccann> jdavis, that's the magic hash
21:40:11 <cmccann> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/syntax-extns.html#magic-hash
21:40:34 <dolio> It's a naming convention.
21:41:10 <Axman6> the 'thar be low level, usually not too unfriendly dragons here' hash
21:41:28 <Jafet> Well, the best way to name functions on types that shouldn't exist is to use names that shouldn't exist
21:47:39 <jdavis> What's the easiest way to install ghc7 on ubuntu?
21:47:51 <jdavis> the whole platform, actually
21:48:25 <cmccann> download it and install it? pretty sure that's newer than what's in the distro repository
21:48:44 <cmccann> but I've never had a problem just grabbing the obvious binary package and installing it
21:48:45 <dankna> Haskell Platform binaries, right?
21:48:52 <dankna> if they work on Ubuntu
21:48:57 <jdavis> Ok.
21:49:05 <cmccann> for either the HP or just GHC itself
21:49:09 <jdavis> I'll see if that shows a speed difference.
21:52:13 <jdavis> looks like all the ubuntu packages are old. I'll just build from source I suppose.
21:54:27 <cmccann> make sure you get GHC (not the Ubuntu package, GHC itself) as a binary, it takes forever to build it from scratch :(
21:55:39 <Jafet> Literally forever, if you don't already have a working copy of it
21:55:52 <dankna> heh
21:56:45 <shachaf> But not *literally* literally.
21:56:49 <tgeeky> and he means "forever" in metric, so you know he's serious
21:57:27 <tgeeky> of course, in the US, you'll need to convert from .511 eternities
21:57:43 <Jafet> Metaphors be with you.
22:01:39 <dankna> ><
22:01:41 <dankna> that was horrible
22:07:28 <sanjoyd> In template haskell, can I convert an arbitrary value to a literal expression?
22:07:39 <sanjoyd> I'm looking for something like \, say, CharL, but more generic.
22:20:15 * hackagebot sqlvalue-list 0.2 - Class and instances for conversion to list of SqlValue.  http://hackage.haskell.org/package/sqlvalue-list-0.2 (YuriyIskra)
22:25:43 <rudyl313> I need help defining infix functions.. I was able to define (+++) which appears to act as an infix function when used as +++ .. but I couldn't define (:::) or (mCon) ... what are the rules for defining infix functs?
22:28:44 <nyingen> rudyl313: Sequences of non-alphabetic, non-numeric characters are automatically treated as infix operators, though I can't remember the exact rules
22:29:03 <mauke> rudyl313: : is an uppercase symbol
22:29:06 <nyingen> but that is why (+++) is treated as infix but (mCon) is not
22:29:12 <Axman6> rudyl313: : is reserved for constructors i believe
22:29:18 <nyingen> You can write: a `mCon` b
22:29:23 <nyingen> to treat it as infix
22:30:52 <Axman6> infix functions can only be made from certain characters, like +, - *, & etc. you can only start with : for data constructors, so you can have data Foo = Double :& Int, but you can’t have ((:&) :: A -> B -> C
22:31:10 <Axman6> and you use `foo` to make orginary, 'binary' functions infix
22:33:34 <dmwit> Infix functions may be made with any character for which "isSymbol" is true, except that it must not start with (:).
22:33:53 <dmwit> Infix constructors must start with (:) and continue with characters for which "isSymbol" is true.
22:33:56 <dmwit> > isSymbol ':'
22:33:57 <lambdabot>   False
22:33:59 <dmwit> > isSymbol '+'
22:34:00 <lambdabot>   True
22:34:16 <Zao> > isSymbol 'λ'
22:34:17 <lambdabot>   False
22:34:20 <Zao> \o/
22:34:39 <dmwit> > isLetter 'λ'
22:34:40 <lambdabot>   True
22:34:53 <Axman6> dmwit: thanks for the clarification :)
22:34:55 <mauke> > filter isSymbol [minBound ..]
22:34:56 <lambdabot>   "$+<=>^`|~\162\163\164\165\166\167\168\169\172\174\175\176\177\180\182\184\...
22:35:12 <mauke> > isSymbol '*'
22:35:13 <lambdabot>   False
22:35:19 <mauke> really.
22:35:24 <Axman6> > text $ filter isSymbol [minBound..]
22:35:25 <lambdabot>   $+<=>^`|~
22:35:29 <Axman6> :\
22:35:35 <dmwit> uh...
22:35:41 <Axman6> > length $ filter isSymbol [minBound..]
22:35:42 <lambdabot>   4310
22:35:45 <Axman6> o.O
22:35:57 <Axman6> there's a hell of a lot of scope for infix functions there!
22:36:47 <dmwit> Symbol *or* punctuation, apparently.
22:36:52 <dmwit> > isPunctuation '*'
22:36:53 <lambdabot>   True
22:37:31 <jdavis> http://hpaste.org/47201/slow_bitwise
22:37:42 <jdavis> That function is surprisingly slow.
22:37:56 <cmccann> if only infix precedence could be specified with fractional values instead of an Int
22:38:06 <cmccann> between that and all the symbols in unicode
22:38:16 <cmccann> we could write entire programs with nothing but infix operators
22:38:19 <cmccann> it would be amazing
22:38:25 <jdavis> It happens that ilen is always 32 and iflags is always 1, and if I set those to be constant (ignoring the bitwise computation) then it speeds up the entire execution by 33% !
22:38:25 <dmwit> How are you testing its speed?
22:38:53 <jdavis> (not just the execution time of that function, but the entire program!)
22:38:54 <Axman6> the bitwise functions aren't really known to be all that fast
22:38:56 <dankna> jdavis: consider casing on ilen and iflags, then
22:39:07 <jdavis> dankna: casing?
22:39:14 <dankna> jdavis: I'll show you
22:39:15 <dmwit> jdavis: Oh, I bet you're getting bit by deeply-nested thunks.
22:40:02 <dankna> by the way, you appear to not know that you can put multiple definitions in the same "let" expression :)
22:40:15 <dmwit> uh
22:40:29 <dmwit> Never mind me, I'm just an idiot without a profiler in my head.
22:40:33 <solrize> is there such thing as Word16# ?
22:40:44 <jdavis> dankna, oh, thanks.
22:41:16 <dankna> okay so see my annotation of your case.  this isn't what I was originally going to demonstrate,
22:41:22 <jdavis> I also annotated that paste with the fast version, which just has a couple constants there. I can't believe so much time is spent in the bitwise ops.
22:41:29 <dankna> but if it is deeply-nested thunks, this will fix it
22:41:40 <solrize> have you looked at the core?
22:42:45 <dmwit> (By the way, on a purely syntactic note, the parens around the arguments to (.|.) aren't necessary.)
22:42:46 <jdavis> solrize, I was still trying to figure out how to do that. If you have a primer you can point me to, that would be nice. I think I installed ghc-core
22:44:15 <cmccann> jdavis, http://stackoverflow.com/questions/6121146/reading-ghc-core
22:44:34 <cmccann> that might give you a few places to start
22:45:05 <solrize> jdavis, instructions for that are in RWH optimization chapter
22:45:06 <dankna> you compile with -ddump-simpl to get a look at the core.  pipe it to a file, it's huge.
22:45:10 <jdavis> dankna, thanks! that made it almost as fast as the constants. How did that do it?
22:45:20 <jdavis> cmccann, thanks, I'll look.
22:45:26 <dankna> oh!  it did eh?  then it was a strictness problem
22:45:34 <dankna> it's like this
22:45:54 <solrize> i just tried to annotate your paste to make it compile-able
22:46:05 <dankna> although the cost is correctly attributed to words_to_item, don't be under the misimpression that it's evaluated when words_to_item is first called.  you've had the explanation of what laziness is, I assume?
22:46:09 <solrize> wait what happene?
22:46:17 <solrize> happened?
22:46:32 <jdavis> dankna, yes, I understand basic laziness
22:47:03 <jdavis> solrize: dankna's annotation using `seq` sped it up tremendously.
22:47:04 <dankna> okay.  well, so the evaluation of the fields was being delayed until they were actually demanded, and that turned out not to be the optimal strategy (there's no way to know that in general)
22:47:23 <dankna> presumably the heap was getting filled with many thunks for computing fields
22:47:29 <jdavis> dankna: why not evaluate all of the fields strictly and not just two?
22:47:37 <dankna> you certainly could do that
22:47:53 <dmwit> In fact, you probably want to just make the whole Item data type strict.
22:47:54 <solrize> oh i see the annotation now
22:47:55 <dankna> it's also possible to specify that those fields will always be evaluated strictly, everywhere that record is constructed; you do that in the definition of the record type
22:48:02 <dmwit> Then you can avoid this `seq` nonsense everywhere.
22:48:20 <dankna> by being like offset :: !Word16, instead of just offset :: Word16
22:48:28 <solrize> are they still boxed words?  maybe you can get more speedup with Word16#
22:48:40 <Jafet> Chitty chitty
22:49:08 <Jafet> solrize: rather likely not
22:49:11 <dankna> also-also, the BangPatterns extension is another way to get strictness.  it lets you put ! preceding any part of a pattern to specify that that part of the pattern should be evaluated
22:49:15 <dankna> but for example
22:49:29 <dankna> > let foo = undefined in 42
22:49:29 <lambdabot>   42
22:49:32 <dankna> > let !foo = undefined in 42
22:49:33 <lambdabot>   *Exception: Prelude.undefined
22:49:38 <dankna> foo is evaluated even though it's never used
22:49:40 <Jafet> solrize: you need to box and unbox prim types to use many ordinary functions on them, which has a penalty.
22:49:52 <dankna> so it's not magic speed dust, you need to only use it where the value is definitely going to be needed (as a rule of thumb)
22:50:01 <Jafet> Unless you write most of your code in primops.
22:50:31 <Jafet> It's magic strictness dust, and strictness usually implies speed
22:51:17 <jdavis> ok, I see. Well, it's almost to the speed of the postgres executor, so I think it's come a long way.
22:51:22 <dankna> excellent!
22:51:26 <solrize> hmm ok
22:51:46 <jdavis> If I throw in a few more filters I bet it would be faster.
22:51:47 <solrize> jdavis, have you looked at that rwh chapter?
22:52:05 <Jafet> Heh, only with Haskell will you get people talking seriously and professionally about "magic hash".
22:52:11 <dankna> hah true
22:52:32 <jdavis> I have the book around here, but it's a little much to jump into tonight I think. I'll take a look at ghc core in the next session.
22:52:36 <solrize> @quote Jafet> Heh, only with Haskell will you get people talking seriously and professionally about "magic hash".
22:52:36 <lambdabot> No quotes for this person. Maybe you made a typo?
22:52:49 <solrize> http://book.realworldhaskell.org/read/profiling-and-optimization.html
22:54:38 <cmccann> Jafet, GHC internals have interesting names sometimes
22:55:38 * cmccann used to be amused by GHC having something officially called The Evil Mangler
22:56:10 <Jafet> It still does...
22:57:45 <jdavis> solrize, thanks, I'll check that out. Tonight I'm going to declare a partial victory and sleep.
22:58:12 <solrize> cool :)
22:58:15 <jdavis> FYI, by adding a bunch of redundant filters I was able to beat the postgres executor pretty easily. They cost almost nothing in haskell.
22:58:35 <cmccann> Jafet, nah I think they finally exorcised it
22:58:48 <jdavis> Unless the haskell optimizer is really smart and knows that x > 10 covers x > 3, or something like that.
22:58:54 <cmccann> jdavis, awesome
22:58:57 <solrize> i still like the error message that says "my brain just exploded".  i got that one yesterday
22:59:19 * hackagebot wai-handler-launch 0.0.1 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-0.0.1 (MichaelSnoyman)
22:59:23 <cmccann> yes, that one's always amusing
22:59:25 <dankna> jdavis: that's conceivable actually
22:59:40 <solrize> a rewrite rule could do that
22:59:53 <solrize> well maybe ;)
23:00:14 <jdavis> dankna: I threw in a modulo just to see, and it didn't seem to increase the runtime either.
23:00:19 <dankna> ah good then
23:00:33 <solrize> could that be because the extra filters are't actually being run?
23:00:33 <dankna> well, the filters will fuse, most likely - that's why they aren't expensive
23:00:48 <dankna> consecutive passes over the same list will, in certain situations, turn into a single pass
23:01:00 <dankna> it's up to you to decide whether that's fair play or not
23:02:04 <solrize> anyone want to look at a gadt hack?
23:02:20 <dankna> hm
23:02:22 <dankna> maybe?
23:02:28 <solrize> he
23:02:29 <solrize> heh
23:02:30 <solrize> http://hpaste.org/47203/gadtbased_interpreter
23:02:41 <jdavis> Just to be absolutely sure, I did filters that were `mod` by ascending primes, and it changed the count so I know they are being run.
23:02:49 <solrize> i'd like to know how to write that less clunkily
23:04:30 <jdavis> Now, to be really fair there are a couple things that I would need to do: (1) postgres is doing some extra visibility-checking work, and I need to do that; (2) the filters in postgres are extensible, so I really should be calling functions in separately-compiled object files, just like postgres needs to do.
23:04:31 <dankna> data Cons a b can be written as an infix constructor
23:04:44 <dankna> I think the syntax is any punctuation that starts with :
23:04:52 <dankna> data a :- b
23:05:02 <dankna> I'm not sure that really reduces clunk in your code, but it's something to consider
23:05:17 <solrize> hmm ok, but i was wondering more about stuff like avoiding manually threaing the type witnesses through the test program
23:05:18 <cmccann> symbols starting with : are "uppercase", yes
23:05:33 <dankna> jdavis: yeah.  I'm not sure whether the separate compilation will prevent the list fusion or not.
23:05:39 <solrize> and also if you run the thing, the type witness gets more and more complicated
23:05:42 <cmccann> so they can be used for types, constructors, and type classes
23:05:47 <dankna> jdavis: I will note that Haskell supports cross-module inlining, although you might have to explicitly request it.
23:06:07 <solrize> i.e. Drop (Drop x)) instead of being able to eliminate those outer drops somehow
23:06:19 <cmccann> the occasionally surprising flip side is that type variables are lowercase identifiers, so you can use symbols that don't start with : for those
23:06:27 <solrize> except by pattern matching on the value constructors which would be ugly
23:07:14 <dankna> solrize: hmmmmmmm....  I don't totally follow what your code is doing there
23:07:29 <solrize> look at testProg at the end
23:07:56 <solrize> it's a stack-based interpreter, the stack can have ints and bools in it
23:08:02 <dankna> but isn't it desired behavior that your program keeps track of the stack depth in the type?
23:08:05 <dankna> I mean, why else do it that way?
23:08:13 <solrize> yes, it keeps track of the depth and the types
23:08:19 <solrize> so you can't add an int and a bool
23:08:27 <dankna> right, and you can't add when the stack isn't deep enough, either
23:08:31 <dankna> it's really quite a cute trick
23:08:34 <solrize> but when i "drop", the type should get smaller not bigger
23:08:34 <solrize> right
23:08:50 <dankna> wait, why does it get bigger
23:08:59 <cmccann> because the Drop instruction goes on the stack
23:09:02 <cmccann> as an operation
23:09:15 <cmccann> instead of a drop function that actually strips off constructors
23:09:18 <solrize> yeah
23:09:39 <solrize> so i have parallel type and value stacks
23:09:42 <solrize> which is bogus
23:09:43 <dankna> oh
23:09:44 <cmccann> this would be useful if you want to distinguish between stack X and the result of adding then removing something from it
23:09:45 <dankna> well
23:09:52 <dankna> can't you do
23:10:18 <cmccann> but if you don't care, then get rid of the Drop constructor and just have a function that strips off the top of the stack
23:10:31 <dankna> .... what is this FW monad?  I've never used it
23:10:43 <dankna> but anyway, yeah, get rid of the Drop constructor and write the drop function as
23:10:52 <solrize> FW is just a type alias i made, to have a state monad with the value stack as the state
23:10:59 <solrize> and the type stack is threaded manually
23:11:11 <solrize> because its type keeps changing, i can't make it into a monad parameter
23:11:15 <solrize> unless i'm missing something
23:11:20 <solrize> so i have to do all that >>=
23:11:44 <cmccann> FW actually appears to be a potential Arrow, not a monad
23:11:48 <cmccann> for what it's worth
23:11:51 <solrize> hmm interesting
23:11:55 <dankna> get rid of the Dup constructor too
23:11:56 <solrize> i've never understood arrows
23:12:00 <dankna> and the Swap one
23:12:02 <solrize> maybe now is the time
23:12:20 <solrize> how can i get rid of them and have the types do the right thing?
23:12:29 <solrize> i.e. if I have [Int Bool Int] on the stack
23:12:32 <dankna> well, your dup function for example will have to case on the value on top of the stack
23:12:42 <solrize> I want  swap add  to typecheck    but just  add  shouldn't type check
23:13:21 <dankna> shouldn't the type of LitInt be
23:13:24 <solrize> well,   3 dup add   should make 6
23:13:29 <dankna> Stack a -> Int -> Stack (Cons Int a)
23:13:46 <solrize> no LitInt is just makig a type witness
23:13:50 <solrize> the value stack is separate
23:14:04 <dankna> oh!  the value stack is separate
23:14:08 <solrize> see line 21
23:14:09 <dankna> you said that but I didn't get it
23:14:21 <solrize> yeah, it's a kludge
23:14:26 <dankna> well, make it the same =p
23:14:27 <solrize> i didn't see another way to do it
23:14:30 <dankna> here, let me
23:14:44 <solrize> ok
23:15:08 <solrize> see the swap at line 63
23:15:19 <solrize> if you delete that, the program should fail to typecheck
23:15:38 <solrize> if you're planning to delete the Swap constructor
23:15:40 <dankna> okay
23:15:51 <solrize> i'm wondering how you're going to track the type after the swap
23:16:11 * jmcarthur is tempted to just write this in agda
23:16:26 <dankna> I /think/ it's straightfoward.  it's an interesting problem at the least.
23:16:32 <solrize> yeah, i've wondered if agda is the next thing after this
23:16:47 <jmcarthur> i've done a stack machine in agda before. quite straightfoward.
23:16:55 <jmcarthur> a typed one like this, that is
23:17:04 <solrize> this isn't (so far) trying to be useful, it's just a gadt exercise
23:17:08 <jmcarthur> although this should be pretty simple too though
23:17:32 <solrize> but i'd really like a monadic   runInterp $ do { litInt 3 ; dup ; add }
23:17:42 <solrize> instead of >>= ...
23:18:14 <solrize> jmcarthur, what did you do about stripping off constructors after dup?
23:18:15 <jmcarthur> you would need to use NoImplicitPrelude so you can use do notation with an indexed monad, i suspect
23:18:18 <Eduard_Munteanu> Hrm... I'm going mad making this simple BASIC-like language in Agda.
23:18:34 <jmcarthur> solrize: let me try and find it
23:18:58 <Eduard_Munteanu> Sometimes the types align when the stars do.
23:18:59 <solrize> how do you actually program in agda?  do you have to write type proofs for all the terms?
23:19:30 <Eduard_Munteanu> Well, it's like Haskell.
23:19:43 <Eduard_Munteanu> It just bitches more.
23:20:07 <jmcarthur> actually, i think programming with agda is in some ways more convenient than with haskell
23:20:18 <solrize> indexed monad like   "instance monad m" where m::(*->*->*) ?
23:20:22 <jmcarthur> agda-mode can infer expressions from the type sometimes, for example
23:20:37 <Eduard_Munteanu> Doing type-level magic you do in Haskell is too easy in Agda.
23:20:49 <Eduard_Munteanu> I mean, it's just straightforward.
23:21:03 <solrize> but, i thought there was no type inference
23:21:53 <Eduard_Munteanu> Mostly there isn't.
23:22:07 <Eduard_Munteanu> But one usually writes types anyway in Haskell.
23:22:34 <jmcarthur> type inference is vastly overrated
23:22:40 <Eduard_Munteanu> (well, let bindings are problematic though, you kinda have to write types everywhere where it isn't trivial to infer)
23:23:11 <solrize> http://okmij.org/ftp/Computation/monads.html#param-monad    aha
23:23:25 <solrize> "oleg already did it":)
23:23:40 <Eduard_Munteanu> However, the nice part is you can use '_' to tell Agda to infer both types and code.
23:23:43 <jmcarthur> there's really more than one kind of indexed/parameterized monad
23:23:44 <shachaf> jmcarthur: Compared to value inference?
23:24:09 <shachaf> Eduard_Munteanu: Can it do whole-program inference yet?
23:24:29 <Eduard_Munteanu> Heh, no.
23:25:40 <jmcarthur> solrize: looks like all i did was define an inductive data type for the reduction rules and then wrote an interpreter for it
23:25:47 <dankna> solrize: well let me show you what I have in progress, but it doesn't compile yet
23:25:58 <jmcarthur> but i'm not entirely sure what your problem with swap is right now
23:26:13 <dankna> http://hpaste.org/paste/47203/gadtbased_interpreter_annota#p47208
23:26:47 <jmcarthur> solrize: to be clear, what i did was use the inductive data type to define a stack program rather than the result of that program
23:27:01 <jmcarthur> s/stack//
23:27:21 <solrize> dankna, look at line 47, "add"
23:27:36 <Eduard_Munteanu> Hm, is there a name for using functions as "mutable" maps?
23:27:44 <solrize> after it runs, the value stack has [2*n True n]
23:27:48 <jmcarthur> Eduard_Munteanu: mutable?
23:27:56 <solrize> Eduard_Munteanu, memoization?
23:28:05 <Eduard_Munteanu> jmcarthur: as in you change the value in a point
23:28:17 <dankna> solrize: but I'm getting an error on line 44
23:28:30 <solrize> oh se
23:28:31 <solrize> sec
23:28:54 <jmcarthur> Eduard_Munteanu: as in    insert :: a -> b -> (a -> b) -> (a -> b)   ?
23:28:58 <dankna> oh right, I see
23:29:00 <dankna> I can't use >>=
23:29:04 <jmcarthur> i guess that would be called updated or something instead
23:29:06 <dankna> because I'm no longer using a monad
23:29:06 <dankna> one sec
23:29:11 <jmcarthur> *update
23:29:21 <solrize> dankna, oh i see you're matching on all pairs of value constructors
23:29:34 <Eduard_Munteanu> jmcarthur: yeah
23:29:46 <dankna> solrize: yes I am, it was nasty, but you could probably work around that somehow
23:29:50 <solrize> but that gets explosive if you have more than 2 value types, if you have actions that consume more than 2 stack slots, etc
23:29:55 * hackagebot hakyll 3.1.2.7 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.2.7 (JasperVanDerJeugt)
23:30:10 <dankna> solrize: yes, after I get it working this way I'll try to eliminate that
23:30:15 <solrize> ok
23:30:29 <jmcarthur> Eduard_Munteanu: that is likely to become kind of inefficient after several updates unless you have a specialized representation, isn't it?
23:30:46 <Eduard_Munteanu> insert a b f = \a' -> if (a == a') then b else f a'
23:30:47 <jmcarthur> or are you just trying to give a name to the meaning?
23:30:49 <solrize> your definition of drop is backwards i tihnk
23:31:07 <Eduard_Munteanu> jmcarthur: ah, I was just looking for a name. Saizan keeps suggesting this pattern to me in Agda :)
23:31:23 <solrize> drop (LitInt s n) = n
23:31:36 <solrize> oops    drop (LitInt s n) = s
23:31:43 <solrize> i gues that's what you have
23:31:53 <dankna> okay, http://hpaste.org/paste/47203/gadtbased_interpreter_annota#p47209 works correctly and doesn't typecheck if I comment out the swap
23:32:00 <dankna> now I'll try to get rid of the blowup
23:32:22 <jmcarthur> Eduard_Munteanu: well, Data.Map calls the operation insert. seems good enough to me ;)
23:32:29 <solrize> cool
23:33:01 <Eduard_Munteanu> jmcarthur: well not the operation, but the actual thingy of doing it with functions instead of an actual data structure, I mean. :)
23:33:03 <cmccann> by the way, I take it back, don't think it's going to work as an Arrow
23:33:14 <solrize> that  let s1=... s2... is similar to a state monad
23:33:41 <solrize> maybe i will try to read oleg's thing about indexed monads
23:34:01 <jmcarthur> Eduard_Munteanu: the function is the data structure
23:34:17 <ddarius> Eduard_Munteanu: That representation is like the worst of all worlds.
23:34:47 <solrize> zomg http://okmij.org/ftp/Computation/VarStateM.hs  is insanely ugly
23:34:52 <solrize> maybe the only way is with template haskell
23:35:34 <cmccann> http://hpaste.org/paste/47203/gadtbased_interpreter_annota#p47210 this gives you some idea what I was thinking of with Arrows though :P
23:36:03 <cmccann> obviously not very usable as is though
23:36:11 <solrize> afk for a few minutes
23:36:39 <ddarius> Eduard_Munteanu: Though, it does suggest a set type implemented similarly to APL arrays/repa arrays.
23:37:29 <Eduard_Munteanu> Ah, it's just convenient to use, especially when the stdlib stuff is trickier.
23:38:16 <Eduard_Munteanu> Goddamn Agda AVLs, I have to prove my keys are a strict total order and what not... :)
23:48:07 <solrize> re
23:48:10 <solrize> looking ...
23:49:59 <dankna> hah!
23:50:00 <dankna> I got it!
23:50:17 <dankna> http://hpaste.org/paste/47203/gadtbased_interpreter_annota#p47211
23:50:26 <dankna> mirror mirror on the wall / who deserves a glass of cold apple cider for this one
23:50:27 <dankna> afk :)
23:50:42 <solrize> you have swap (LitInt (LitBool ...)) but not the other combinations
23:51:17 <solrize> i don't understand the arrow/category stuff
23:52:05 <dankna> huh?  no, make sure you're looking at the latest version
23:52:05 <solrize> @hoogle (<=<)
23:52:05 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
23:52:16 <solrize> oh sec
23:52:17 <solrize> sorry
23:52:23 <cmccann> solrize, yeah, I was being lazy so I just wrote one
23:52:28 <cmccann> I assume you meant mine
23:52:45 <dankna> yeah, we're all annotating the same paste at once and causing confusion :)
23:52:49 <cmccann> the approach is obviously unworkable because you'll get a combinatorial explosion if you add more literals :P
23:52:59 <dankna> cmccann, look at my latest version - I avoided that
23:53:12 <solrize> this is looking nice
23:53:15 <dankna> :D
23:53:29 <dankna> the key was realizing that I could put a context on a GADT constructor
23:53:55 <mauke> ah, existentials
23:54:15 <dankna> oh, I'm not actually using existentials, I just left that flag in
23:54:22 <cmccann> on the other hand, that's not really doing anything other than limiting what can go in the stack, right?
23:54:31 <cmccann> I mean, it wouldn't break anything to push other types
23:54:42 <cmccann> all you could do with them is pop them back off
23:55:12 <dankna> cmccann: no.  you need the instance because otherwise you can't prove that push is well-typed
23:55:18 <dankna> cmccann: .... I /think/
23:55:48 <Eduard_Munteanu> dankna: yes you are
23:55:50 <poltak> Favourite feature of Haskell, everyone?
23:55:55 <dankna> Eduard_Munteanu: where?
23:56:04 <Eduard_Munteanu>   Push :: (Stackable literal) => Stack b -> literal -> Stack (Cons literal b)
23:56:13 <Eduard_Munteanu> unless I forgot how GADTs work in Haskell
23:56:14 <dankna> oh, yeah
23:56:15 <dankna> good call
23:56:37 <cmccann> ugh, it's too late for me to be thinking about this stuff
23:56:42 <cmccann> gonna stop trying now and go to bed
23:56:48 <dankna> heh night cmccann
23:56:49 <solrize> very nice
23:56:57 <chreekat> Newbie question: While in ghci, if I have a variable of type IO String, what's the best way to pass the enclosed String to a function?
23:57:13 <ddarius> Eduard_Munteanu: Since b and literal appear in the output type that shouldn't be an existential.
23:57:25 <dankna> solrize: as payment for my nifty solution to your problem, you get to answre chreekat's question :D
23:57:37 <ddarius> chreekat: What enclosed String?
23:57:45 <solrize> chreekat, you have x :: IO String
23:58:04 <Eduard_Munteanu> ddarius: hrm, yeah. I'm not sure how they work anymore in Haskell. Does it mean a == b?
23:58:09 <solrize> in another i/o action you could say    y <- x  ;  print y
23:58:53 <solrize> chreekat, if you're asking how to strip the IO off of an IO string, the basic answer is you can't
23:59:03 <Eduard_Munteanu> Erm a == Cons literal b
23:59:24 <solrize> you instead have to organize your program to extract the string inside another IO action
23:59:32 <solrize> chreekat, do you have some sample code?
23:59:56 <chreekat> ddarius: solrize : I recognize my question shows my rather tenuous grasp on working with monads. I am just wondering if ending up with, as you correctly surmised, a "x :: IO String" while toying with things in ghci is something that happens frequently
