00:00:10 <shachaf> ivanm: You mean import ... hiding (module ModuleName)?
00:00:23 <ivanm> yeah
00:00:34 <shachaf> I guess things that are reexported aren't explicitly marked as being part of the module.
00:00:39 <ivanm> yeah, probably
00:07:47 * hackagebot tls 0.6.4 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.6.4 (VincentHanquez)
00:10:08 <erus`> is there a pure imperative language?
00:10:27 <erus`> like C but can only use local variables and pass by value
00:10:28 <opqdonut_> i'm not sure that makes sense
00:10:32 <opqdonut_> oh
00:10:43 <shachaf> What does that mean?
00:10:49 <opqdonut_> well, one can use the ML languages somewhat like that
00:10:58 <opqdonut_> they're eager and have a good pure subset
00:11:00 <shachaf> What does "pass by value" or "local variables" have to do with "imperative"?
00:11:13 <erus`> pass by value means no side effects
00:11:17 <kfish> gcc with the pure keyword on every function?
00:11:23 <shachaf> Oh, "purely functional"?
00:11:41 <shachaf> erus`: (Also, that's not what it means.)
00:11:47 <erus`> well it doesnt mean no side effects but it causes it
00:12:06 <shachaf> C is call-by-value.
00:12:35 <opqdonut_> so call-by-deep-copy I guess?
00:12:49 <opqdonut_> or call-by-const-value :)
00:13:03 <erus`> and no pointers or references
00:13:23 <erus`> are references only C++? like int hello(int &foo)
00:13:24 <kosmikus> I don't understand this discussion :)
00:13:32 <opqdonut_> well c without pointers (ergo c without arrays) is pretty useless
00:13:53 <shachaf> kosmikus: I'm not sure anybody here does. :-)
00:13:55 <opqdonut_> from a language viewpoint this makes no sense. from a programming paradigm viewpoint it might make sense
00:14:04 <erus`> opqdonut_: yeah they would have to be replaced with safe lists
00:14:09 <opqdonut_> and ML is interesting in the latter case
00:14:22 <kosmikus> can we first define what purity means?
00:14:24 <opqdonut_> and that's all I've to say
00:14:45 <shachaf> "pure imperative" means everything is imperative, with no functions or anything like that.
00:14:48 <shachaf> Clearly.
00:14:54 <kosmikus> aha :)
00:17:09 <erus`> I still cant get my head around how IO is pure in haskell
00:17:35 <kosmikus> so, purity in Haskell is used to mean, roughly, "no untracked side effects"
00:18:06 <maurer_> If you want it to be more correct, instead think of it as "referential transparency"
00:18:16 <kosmikus> which is a bit vague, because arguably memoization due to lazy evaluation and nontermination in Haskell implementation are both untracked side effects
00:18:19 <maurer_> e.g. every time you access a value, you get the same result.
00:18:44 <kosmikus> well, referential transparency (unlike purity) has a clear meaning
00:18:48 <maurer_> This allows for untracked side effects as long as they don't change the result you get back, and more closely models what happens in practice
00:19:07 <maurer_> kosmikus: Yes, and haskell is referentially transparent, but as it stands, not pure.
00:19:30 <shachaf> But is it strongly typed?!
00:19:56 <maurer_> shachaf: unsafeInterleaveIO is needed to implement the prelude
00:19:57 <kosmikus> Haskell as a whole isn't referentially transparent either
00:20:22 <maurer_> kosmikus: Example?
00:20:30 <kosmikus> unsafePerformIO
00:20:37 <shachaf> kosmikus: That's not Haskell.
00:20:41 <kosmikus> it is
00:20:50 <kosmikus> it's part of the FFI addendum, which is part of Haskell
00:21:05 <shachaf> Oh.
00:21:12 <maurer_> kosmikus: That's not automatically imported into every program unless it's turned off though :P
00:21:38 <kosmikus> I know it's not black and white in practice
00:21:48 * hackagebot tls-extra 0.2.3 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.2.3 (VincentHanquez)
00:22:42 <kosmikus> Haskell is reasonably referentially transparent for most purposes
00:24:02 <dmwit> erus`: Here's one way to see how IO could be pure.
00:24:07 <dmwit> erus`: Imagine defining IO like this:
00:25:23 <dmwit> data IO a where { GetLine :: IO String; PutStrLn :: String -> IO (); Bind :: (a -> IO b) -> IO a -> IO b; Return :: a -> IO a }
00:25:48 <dmwit> (Assuming for the moment that the only things you can do in IO are getLine and putStrLn + the Monad interface.)
00:26:26 <dmwit> Now, "getLine" is a function defined by "getLine = GetLine" -- that is, it *always* returns the IO recipe that gets a line.
00:27:08 <dmwit> Naturally, at runtime, the RTS has to interpret this recipe. And the interpretation won't be pure.
00:27:20 <dmwit> But creating the recipe *is* pure.
00:28:32 <dmwit> As another example, (putStrLn "What's your name?" >> getLine >>= \a -> putStrLn ("Hello, " ++ a)) would always evaluate to
00:29:04 <dmwit> Bind (PutStrLn "What's your name?") (\_ -> Bind GetLine (\a -> PutStrLn ("Hello, " ++ a)))
00:29:08 <dmwit> It's always exactly that recipe.
00:29:36 <dmwit> Interpreting may do different things on each interpretation, but the creation always does exactly the same thing.
00:29:39 <dmwit> Does that help?
00:29:55 <Axman6> then something that isn't haskell (the RTS) runs the recipe
00:29:58 <erus`> yeah I can see what you mean
00:33:49 <shachaf> dmwit: Even simpler (and less "ooh, monads are about IO") to define GetLine and PutStrLn directly with CPS. :-)
00:34:47 <dmwit> Hm.
00:34:52 <kosmikus> look at the "iospec" package for seeing something like this actually implemented ...
00:35:07 <dmwit> I think I might worry that CPS is a bit much for a beginner.
00:35:13 <dmwit> Then again, you might make the same claim about GADTs, so maybe not. =P
00:35:47 <shachaf> dmwit: The CPS is there anyway, it's just always in Bind.
00:36:01 <shachaf> If you used it you wouldn't have to use the dummy argument for PutStrLn. :-)
00:36:48 <shachaf> PutStrLn "What's your name?" (GetLine (\answer -> PutStrLn ("Hello, " ++ answer) DoNothing))
00:37:45 <dmwit> Oh, I also mucked up the order of arguments to Bind, didn't I?
00:39:54 <dibblego> no (>>=) mucked up the order of the arguments
00:40:20 <dmwit> Either I mucked up the type or I mucked up the argument order. They don't match, so one is certainly wrong.
00:40:42 <shachaf> dibblego: Why isn't (>>=)'s order reasonable?
00:40:42 <dmwit> I won't choose which, since clearly it's a philosophical choice.
00:41:01 <dmwit> shachaf: It should be (=<<) and (.) or (>>=) and (>>>).
00:41:19 <dmwit> The fact that information flows in different directions when writing (>>=) and (.) is really irksome.
00:41:35 <shachaf> dmwit: (>>=) goes in the same order as do-notation/"execution order".
00:41:45 <dmwit> Yes, but (.) doesn't.
00:42:02 <dmwit> So either you dislike (.) or you dislike (>>=). Nothing else is consistent. =)
00:42:15 <Axman6> why do you have to dislike either?
00:42:26 <Axman6> they both have their reasons for being the way they are
00:42:46 * dmwit shrugs
00:42:53 <shachaf> dmwit: I like both (>>=) and (=<<) (though I think the latter is a bit confusing as it's written).
00:42:53 <dmwit> There's no accounting for taste, I suppose.
00:43:13 <shachaf> dmwit: (.) is in "function application order".
00:43:25 <erus`> ML is impure... is haskell the only pure language?
00:43:32 <dmwit> (.)'s order is more a historical accident than anything else.
00:43:49 <opqdonut_> erus`: e.g. coq and agda are as pure as haskell
00:43:55 <Axman6> erus`: there's probably a lot more to that question than you think there is
00:44:04 <dmwit> What if we wrote (x)f instead of f(x), and ((x)f)g instead of g(f(x))?
00:44:05 <shachaf> /bin/cat is pretty pure.
00:44:10 <shachaf> Also easy to write quines in.
00:44:23 <Axman6> dmwit: then (.) would be backwards
00:44:36 <Axman6> so, it would make sense to reverse the order of its arguments
00:44:52 <shachaf> What if we all used RPN?
00:45:06 <Axman6> also... maybe ((x)f)g makes more sense than g(f(x))
00:46:07 <opqdonut_> maybe we should just draw the computation trees in which ever way we prefer!
00:46:23 <opqdonut_> this accomodates both bottom-up and top-down thinking
00:46:32 <dmwit> When was the last time you preferred drawing a computation tree to typing a bit of plain ASCII?
00:46:35 <opqdonut_> in addition to inside-out, right-to-left and topsy-turvy
00:47:05 <opqdonut_> dmwit: I prefer ascii merely because I have a good tool for writing it
00:47:20 <dmwit> That doesn't seem like such a tiny reason to me.
00:47:34 <opqdonut_> also I was of course joking
00:47:44 <opqdonut_> but yes, tools matter
00:47:47 <dmwit> yeah... I'm getting grumpy
00:47:49 <dmwit> I should sleep.
00:47:53 <dmwit> g'night
00:47:59 <Axman6> o/
00:53:20 <exeter> i have a problem installing a cabal package (curl-1.3.7). I get a cabal: The package has a './configure' script. This requires a Unix compatibility toolchain such as MinGW+MSYS or Cygwin. cabal: Error: some packages failed to install: curl-1.3.7 failed during the configure step. The exception was: ExitFailure 1
00:53:35 <exeter> searching stack overflow I decided to install mingw
00:53:55 <exeter> but that didn't solve it. What should I do now?
01:04:30 <Jafet> exeter: did you also install MSYS, like cabal said...?
01:05:11 <erus`> whats a quick way to repeat an element making a list of n elemens? (like [0] * n    in python)
01:05:18 <luite> msys is probably the only thing you need, since ghc comes with a mingw distribution
01:05:27 <luite> (you do need to add the mingw bin path to your path manually)
01:05:44 <Jafet> :t replicate
01:05:45 <lambdabot> forall a. Int -> a -> [a]
01:06:16 <exeter> Jafet: no I didn't. I will try now.
01:06:42 <nlogax> :t genericReplicate
01:06:43 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
01:10:54 <exeter> Jafet: it still does not work
01:11:39 <luite> exeter: do you get some error message?
01:11:52 <Jafet> That's too bad, Luke.
01:12:05 <exeter> same as before, luite
01:12:17 <zenzike> erus`: take n $ repeat 0
01:12:34 <luite> exeter: hmm, have you restarted your command prompt? what happens if you type bash?
01:12:35 <exeter> cabal: The package has a './configure' script. This requires a Unix compatibility toolchain such as MinGW+MSYS or Cygwin. cabal: Error: some packages failed to install: curl-1.3.7 failed during the configure step. The exception was: ExitFailure 1 hxt-curl-9.1.0 depends on curl-1.3.7 which failed to install.
01:12:41 <erus`> cheer
01:13:19 <exeter> i do have resterted
01:13:36 <luite> 1 sec, I'll try it myself, I've juist compiled curl
01:13:46 <luite> just
01:15:22 <luite> hmm installed fine here
01:16:10 <exeter> grrrr
01:16:18 <exeter> os?
01:16:57 <luite> windows 7
01:17:16 <luite> exeter: if you type bash in your cmd prompt, does it start bash?
01:18:16 <exeter> luite, no, it says unrecognised command
01:18:27 <exeter> (I typed "bash")
01:18:33 <luite> add the msys bin dir to your path first then
01:19:06 <luite> (and restart cmd)
01:23:43 <erus`> what am I doing wrong here: http://hpaste.org/46592/naughts_and_crosses
01:24:32 <Zeiris_> Wow, this is really cool: http://pnyf.inf.elte.hu/fp/FunctionGraphs_en.xml
01:24:56 <Zeiris_> Could Haskell become the new Mathematica?
01:25:43 <luite> Zeiris_: I'm working on something like that (already have similar functionality and worksheet-like interface)
01:25:48 <exeter> ok, now it is "C:\Users\exeter\AppData\Roaming\cabal\bin C:\Program Files (x86)\MSYS\1.0\bin\" should I place commas or semicolons between the two?
01:25:51 <Zeiris_> erus`, pattern match instead of using the case.
01:26:00 <Zeiris_> luite, awesome!
01:26:45 <exeter> ; ok
01:26:50 <luite> Zeiris_: there's still a lot of work to be done (sorry restructuring at the moment, I don't have a working demo), but you should be able to have web-based worksheets that you can share with others, with text cells (markdown), definitions and expressions
01:27:30 <luite> Zeiris_: including interactive graphics (somewhat limited at the moment, but I have a working tictactoe implementation with mouse interaction)
01:28:08 <Jafet> No, one Mathematica in the world is bad enough.
01:28:28 <erus`> never mind
01:29:42 <luite> Jafet: but this one has haskell ;p
01:30:18 <luite> Zeiris_: hmm, I'm trying to get the demo working again but there's some problem
01:30:36 <helino> hi, I'm writing a pretty printer for an AST, and would like a function that indents a string with i spaces. That is, "indent :: Integer -> String -> String", how would you do this?
01:31:04 <helino> by indenting, I mean prepending i spaces to the given string
01:31:22 <wto> helino: you could use concatMap and lines?
01:31:45 <wto> well, and unlines too, obviously
01:31:45 <omie> Hi ! I need some help with gtk
01:32:00 <shachaf> helino: You could try unlines . map (replicate n ' '++) . lines, but that's a bit lossy.
01:32:37 <luite> Zeiris_: very early demo, just expression cells now (don't click insert text cell) http://jabberwock.xs4all.nl/exp/jquery-console/
01:32:54 <luite> I need to rework a lot to make it work nicely with a markdown editor
01:33:01 <omie> my glade generated file : http://hpaste.org/46594/notepadguiglade and  code : http://hpaste.org/46593/notepadgui  it compiles fine but does not show up anything
01:33:33 <helino> wto, shachaf thanks for your help, I will check out your suggestions!
01:33:40 <omie> referencing RWH but not getting clue how to pop that thing up :-(
01:34:30 <wto> helino: i would say shachaf's version is a good one. You could probably do it with a fold and not having to do lines and unlines though.
01:34:54 <erus`> can i use guards for a function instead of case somehow?
01:37:34 <quicksilver> erus`: yes.
01:37:34 <Zeiris_> luite, awesome
01:38:07 <luite> Zeiris_: still lots of work to be done (most of the short-term work is javascript unfortunately) :)
01:38:47 <erus`> whats the idiomatic way todo this; f 1 = "one"; f 2 = "two"
01:39:07 <quicksilver> erus`: that is idiomatic.
01:39:07 <luite> erus`: for how many numbers? :)
01:39:35 <Axman6> :t (>>= (replicate 10 ' ' ++))
01:39:35 <lambdabot> [[Char]] -> [Char]
01:39:42 <Axman6> :t (>>= (replicate 10 ' ' ++)) . lines
01:39:43 <lambdabot> String -> [Char]
01:40:01 <erus`> well i have drawPiece (Just Naught) = "O"; drawPiece (Just Cross) = "X"; drawPiece Nothing = " ";
01:40:19 <Axman6> > let indent n = (>>= (replicate n ' ' ++)) . lines in indent 10 (unlines cake)
01:40:20 <lambdabot>   "          One 18.25 ounce package chocolate cake mix.          One can pre...
01:40:37 <Axman6> bleh
01:40:57 <Axman6> > let indent n = unlines . map (replicate n ' ') . lines in indent 10 (unlines cake)
01:40:58 <lambdabot>   Couldn't match expected type `a -> GHC.Base.String'
01:40:58 <lambdabot>         against inferre...
01:41:05 <luite> Zeiris_: interactive is just something like this: interactive "binom" [intSlider "n" 5 1 25]
01:41:06 <Axman6> > let indent n = unlines . map (replicate n ' ' ++) . lines in indent 10 (unlines cake)
01:41:08 <lambdabot>   "          One 18.25 ounce package chocolate cake mix.\n          One can p...
01:41:18 <Axman6> > let indent n = unlines . map (replicate n ' ' ++) . lines in text $ indent 10 (unlines cake)
01:41:19 <lambdabot>             One 18.25 ounce package chocolate cake mix.
01:41:20 <lambdabot>            One can pr...
01:41:29 <exeter> luite: configure: error: curl libraries not found, so curl package cannot be built See `config.log' for more details. <-- not found? what does that mean?
01:41:34 <Jafet> erus: if it ain't broke
01:41:46 <luite> exeter: how did you install your curl libraries?
01:42:19 <exeter> luite: i didnt (smiles) I thought it was something that cabal would handle.
01:42:29 <Zeiris_> luite, is it re-requested from the server, or re-drawn completely locally when a slider's moved?
01:42:29 <luite> exeter: cabal only does the haskell part
01:42:49 <luite> Zeiris_: all haskell things are requested from the server
01:43:21 <luite> theoretically, interactive things with only a few possible inputs could all be loaded at once
01:43:54 <luite> but for now, it seems more trouble than it's worth
01:44:25 <luite> I've been thinking about compiling some of the haskell code to javascript, but that's going to have a lot of limitations
01:45:46 <luite> (having the server evaluate everything does too, but at least the tools available are much more mature, javascript compilation is experimental at best)
01:47:07 <luite> exeter: download a mingw build of curl, the easiest way to install it is to extract that to the mingw directory of your ghc installation
01:47:19 <luite> otherwise, install somewhere else and edit your cabal configuration
01:47:31 <exeter> in the bin folder, right?
01:47:47 <luite> exeter: no, it has bin, lib, include folders and a few more
01:50:02 <exeter> strange luite, extractiong curl_721_6 i only see curl.exe
01:50:16 <luite> you need another package
01:50:36 <luite> I've built my own, which I could give you, but it's a version without ssl support
01:51:14 <luite> because I just wanted to quickly test whether I could install curl without problems
01:51:28 <exeter> luite, that would be appreciated
01:52:05 <luite> exeter: there's also mingw versions available from the curl site
01:52:10 <luite> but if you don't need ssl
01:52:32 <exeter> oh, let me see if i can download that without bothering you
01:53:42 <luite> exeter: here's mine: http://jabberwock.xs4all.nl/curl-7.21.6-mingw-nossl.zip
01:54:00 <exeter> thanks luite
01:55:19 <luite> exeter: it's easy to build your own, open a command prompt, start bash, unzip the source code tar.gz for curl (from curl site), cd curl-version, ./configure --prefix=/, make, make install DESTDIR=/some/temp/dir
01:55:45 <luite> exeter: that's if you have your msys dir and the ghc mingw bin dir in your %PATH%
01:56:24 <luite> exeter: for other libs you may want to set LDFLAGS=-no-undefined, to enable building shared libs
01:58:22 <exeter> " Missing C library: curl", I suspect my path is wrong, luite . Currently: "C:\Users\exeter\AppData\Roaming\cabal\bin;C:\Program Files (x86)\MSYS\1.0\bin\;C:\Program Files (x86)\MinGW\bin\"
02:01:20 <luite> exeter: where did you extract it?
02:01:58 <exeter> ysstem properties
02:02:05 <exeter> variable name: PATH
02:02:20 <luite> no I mean the curl library
02:02:28 <luite> where's the curl.exe
02:02:56 <exeter> oh, in the mingw folder
02:03:16 <exeter> more specifically
02:03:53 <exeter> in the /bin
02:04:27 <luite> is that the mingw folder that came with your ghc, or the one that you installed separately?
02:07:22 <luite> if it's the latter: edit your cabal\config file and set the extra-lib-dirs and extra-include-dirs appropriately (note that -- at the beginning of a line indicates that the line is a comment, remove the -- if you don't want the line to be ignored)
02:10:54 <Wooga> hello, what type signature allows to use even/odd and (/) at the same time?
02:11:21 <Wooga> (/) requires Fractional, (even/odd) - Integral
02:11:21 <Jafet> (Integral t, Rational t) =>
02:11:28 <Jafet> Er, yeah
02:11:31 <erus`> http://hpaste.org/46596/winner_not_in_scope im getting an error :(
02:11:44 <opqdonut_> Wooga: are you sure you don't want div instead of (/)?
02:11:56 <Wooga> opqdonut_: not, completly not sure
02:12:02 <Wooga> so div is better?
02:12:22 <Wooga> oh yeah, it works!
02:12:34 <Wooga> thanks!
02:13:06 <opqdonut_> happy to help
02:13:37 <Jafet> You'd think that (/) involving Fractional would be saying something...
02:13:41 <Jafet> :t div
02:13:42 <lambdabot> forall a. (Integral a) => a -> a -> a
02:18:33 <lysgaard> Anyone used Simon PJ's Cloud Haskell here? I have a question about it's closures.
02:20:13 <companion_cube> is it already released ?
02:21:46 <lysgaard> companion_cube: Nope, I'm using it from github.
02:21:57 <lysgaard> I know it's a bit nagging to ask about stuff before release but I need to know if it's possible to make a "recursive" closure. Much like a recursive RPC call.
02:26:13 <erus`> can someone explain why the code i posted above will not work please?
02:26:30 <erus`> I get winner not found in scope but it is declared right before the statement
02:27:07 * shachaf winces at erus`'s indentation.
02:27:35 <shachaf> erus`: Read about how "where" works. It's a per-binding binding, not like let.
02:28:03 <erus`> ah ok
02:29:31 <erus`> grrr i dont know how to make this tail recursive
02:29:52 <lysgaard> What does "`Main.relayFndSucc__closure' is not in scope at a reify
02:30:17 <lysgaard> mean. It's coming from a Template Haskell thingy.
02:37:31 <zygoloid> erus`: you can't "return" the result of calling playRound, since it's an IO String, not a String.
02:38:03 <erus`> ah yes
02:38:59 <zygoloid> if you push the 'return' into the three cases which produce strings, you can remove the incorrect use of 'where' too :)
02:50:57 <erus`> Is there an easy way to change a single element of a list?
02:51:14 <erus`> do i have to map over a zip with indices?
02:51:54 <shachaf> erus`: In general indexing into a list is considered pretty rude.
02:53:35 <dmead> erus: there is no mutable state in lists
03:00:10 <luite> erus`: you could use splitAt, but you always rebuild the part of the list before the element that you change
03:01:40 <aleator> erus`: Usually, you don't want to change element at a specified index in a list. What are you doing specifically?
03:02:02 <erus`> my naughts and crosses board
03:02:17 <Eram> As it were me to find the program against Google, which itself opened and closed the sites, in that time when me нету near computer. She worked as DDOS attack, has put(deliver)ed, but itself will go to walk. Remarkable Google on I created wipe after such, but sites miscellaneouses opened on all-round themes with enumeration of the main trends of the themes advisable and regulation amount visit given to directivities.
03:02:21 <Eram> If I have simply program, that all like Google collectors immediately loose in that material, which I interest, not will possible create on me psychological portrait on my taste, habit, interest...
03:02:21 <Eram> Since Google aside from installation cookie beside me on computer else has its extensive statistical database about which is hard cushioned. Our criticality on computer in contrast with their given about us - a triviality so shave off possible only boat, directed on opening and closing site while master нету building or than that occupied. Spreading the program подорвет given about folk and all-out collection to information - better than attack DD
03:02:35 <Eram> In addition there is one more psychological advantage to the whole - advertisment control on its taste - a triviality, but pleasantly. Not whole advertisment I do not like, but here is determined sort can, and was useful at whiles. One more plus in that that managers of the local-area networks too got mixed up in my interest. Here just appropriately add such characteristic in program that she пребывала on open page not strictly fixed amount of time, 
03:02:43 <shachaf> @where ops
03:02:43 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
03:02:45 <Eram>  could easy believe that works the alive person. Length of stay to fasten from amount of the letters on page. Here is such order on given program - some she was much needs and had its demand, particularly for one, particularly values invulnerability.
03:02:57 <erus`> its a [Maybe Piece] where data Piece = Cross | Naught
03:03:07 <Eram> Anon
03:03:08 --- mode: ChanServ set +o mauke
03:03:19 <aleator> erus`: Ah. Then, for first solution, why not use a Data.Map, with Map (Int,Int) Piece instead of the list?
03:03:58 --- mode: mauke set -o mauke
03:04:05 <shachaf> mauke: And you're not even in the ops list! Impressive.
03:04:18 <mauke> passive alert
03:04:32 <shachaf> Passive alert?
03:04:34 --- mode: ChanServ set +o Cale
03:04:44 <Cale> oh
03:04:45 <Cale> lol
03:04:45 <ben> He has a highlight on @where ops?
03:04:48 --- mode: Cale set -o Cale
03:04:51 <Jafet> In russia, google searches you?
03:05:30 <Jafet> erus: using lists doesn't seem horrible for your game
03:05:44 * frerich2 wonders what's the point of such IRC spamming - getting keywords into the IRC logs which Google crawls?
03:06:21 <Jafet> type Board = [Maybe Piece]; addPiece :: Board -> Piece -> (Maybe?) Board
03:06:32 <aep> mauke: hm how did you force the leave ( as opposed to kick ) ?
03:06:42 <shachaf> Jafet: Maybe with a question mark means "Maybe Maybe"?
03:07:17 <Jafet> Maybe.
03:07:48 * shachaf will take that as a yes.
03:08:22 <mauke> aep: REMOVE
03:08:35 <aep> aye thanks]
03:09:51 <erus`> this is the first time i have missed c arrays
03:10:30 <aleator> erus`: Well, instead of lists, use something that is bit more like an array then.
03:18:17 * hackagebot HipmunkPlayground 5.2.0.4 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.0.4 (FelipeLessa)
03:20:58 <Cale> erus`: Maybe try Data.Map :)
03:21:26 <Cale> erus`: Map (Integer, Integer) Bool  makes a nice game board
03:22:15 <shachaf> Cale: Doesn't fit in a 16-bit integer, though. :-)
03:22:31 <Cale> sure
03:23:37 <Cale> An appropriately sized UArray (Integer, Integer) Bool might
03:24:16 <Cale> Well, not quite
03:24:34 <Cale> (the outer box and bounds put it over)
03:24:54 <phr> kkkkkkkk
03:25:07 <Jafet> > (3^9, 2^16)
03:25:08 <lambdabot>   (19683,65536)
03:25:19 <Cale> But UArrays of Bool are packed into bitfields :)
03:25:25 <zygoloid> pfft, a 16-bit integer's going to occupy at least 64 bits on a modern platform anyway :)
03:25:36 <Jafet> I think certain infinite tic-tac-toe games are still unsolved
03:26:41 <shachaf> Cale: By the way, don't you want three states, not just a Bool?
03:26:59 <Cale> shachaf: indeed
03:27:07 <Cale> You'd have to use two arrays
03:27:14 <shachaf> zygoloid: You might be fit several games into one integer, though. :-)
03:27:33 <Cale> (one to indicate pieces present/absent, the other to indicate what type)
03:27:47 <Jafet> Or bitboards.
03:27:51 <Cale> I know that people doing chess AI use representations like that
03:28:06 <Cale> Seems silly to care about for tic-tac-toe
03:28:09 <zygoloid> shachaf: or you can fit 7 bitboards in that space
03:28:12 <Jafet> Not quite. They use one board per type of piece
03:28:59 <shachaf> Cale: That's two bits for only three states, though! What a waste.
03:29:09 <Cale> :)
03:29:14 <Jafet> It cleanly expands to three players
03:29:39 <shachaf> Kids these days don't appreciate the RAM that they get.
03:29:58 <Cale> Arithmetic coding is the answer.
03:30:33 <zygoloid> :)
03:30:44 <zygoloid> make sure you don't have representations of illegal boards, too :)
03:31:00 <int-e> 3^6 = 243 is a pretty good approximation of 2^8, too.
03:31:08 <int-e> 3^5
03:31:09 <int-e> meh.
03:31:19 <erus`> shachaf: the extra effort to code bitboards is not worth saving 1k of ram :)
03:32:09 <ketil> Any way in cabal to reinstall a package and *all* dependencies?  I stupidly forgot -p on initial install, and now I'm reinstalling dependencies one by one as the reinstall of the package keeps failing.
03:33:04 <zygoloid> how many distinct legal tic-tac-toe positions are there anyway?
03:33:31 <quicksilver> twelve.
03:33:32 <Jafet> Heh
03:34:39 <Eliel> I have a value, let's call it b, it's a Float. I want to find the smallest expressable value c for which b < c. How would I calculate it reliably?
03:34:39 <aleator> I thought it was 760 or something..
03:34:41 <int-e> is that well-defiend? reachable from an empty board, you mean? do you fix the starting player?
03:34:52 <int-e> (zygoloid)
03:35:20 <Jafet> Any game reachable from the starting position and where the current player has a legal move
03:35:42 <int-e> and there's the question of how you want to account for symmetries.
03:35:50 <int-e> Jafet: so the winning positions are not legal?
03:35:57 <isomorphic> looks like 765 on wikipedia
03:36:26 <int-e> (or the drawn ones)
03:36:35 <Jafet> I don't think those are considered legal, usually
03:36:36 <isomorphic> https://secure.wikimedia.org/wikipedia/en/wiki/Tic-tac-toe
03:36:53 <aleator> Eliel: With great difficulty and machine epsilon (http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html)
03:36:54 <isomorphic> 255,168 possible games
03:37:23 <Eliel> aleator: thank you
03:37:44 <aleator> Eliel: Dunno if someone has a library for this.
03:37:49 <int-e> Jafet: I don't know. Personally I would call them legal. But that just illustrates the point that we should define the term more rigorously.
03:38:14 <Eliel> aleator: I'm trying to implement Principal Variation Search :)
03:38:37 <zygoloid> int-e: yeah, fixing the starting player, reachable from any empty board. i'm not worried about canceling out symmetries.
03:38:59 <zygoloid> i'd consider won/drawn positions legal fwiw
03:39:20 <zenzike> is there any documentation about the sql syntax that is used in HDBC? ie, the syntax for JOIN, and the allowable SQL datatypes?
03:39:28 <zygoloid> (i'm not thinking about building a lut, just generally curious)
03:40:13 <aleator> Eliel: Hmm.. Can't you just move that to comparison?
03:41:12 <MasseR> I'm trying out acid-state in a 'real' project. I'm wondering though would it be better to  have the main code as pure as possible, with some sort of monad state, keeping track of the state, and at the end of the execution, save the state with acid-state, or have IO monadic acid-state updates running through the execution lifetime
03:44:12 <Eliel> aleator: I'll take a look :)
03:45:32 <Eliel> aleator: that does mean the code flow I just thought up will have to be reworked :)
03:46:49 <Eliel> MasseR: if the end of the execution is the same thing as end of transaction, that sounds sensible to me.
03:47:49 <Eliel> if not, well, the implementation is less robust against crashes then. Also, if there's more than one process accessing the data store at the same time, they'll be out of sync.
03:48:56 <MasseR> hmm... The actions would be simple like "add, delete, list, modify, append" where there isn't for example add followed by delete
03:49:07 <MasseR> So therefore the entire execution could be considered as a transaction
03:49:42 <Eliel> how flexible do you want to make it?
03:50:25 <MasseR> For now, as simple as possible
03:53:44 <quicksilver> keeping as much of your algorithms as simple pure functions as possible is a good guideline in most contexts.
03:53:54 <quicksilver> with acid-state it depends what you're aiming to get from the use of acid-state
03:54:04 <quicksilver> how often do you want 'safe points' you can recover from?
03:54:09 <quicksilver> (if you're using it to be crash-safe)
03:54:39 <MasseR> I'm using it for simple serialization :P (with possibility to more)
03:54:44 <quicksilver> how often do you want other processes to become aware of your changes (if you're using it for transactionally safe communication between threads)
03:55:14 <quicksilver> your first design, update acid-state at end of each transaction, sounds sane enough.
03:57:16 <MasseR> Thanks
04:06:39 <erus`> is anyone else at work
04:06:55 <erus`> I don't even have a programming job but i spend all day at work programming :)
04:07:31 <dmead> i don't even have a job, but i spend all day programming
04:08:11 <erus`> how do you pay for everything?
04:09:05 <dmead> school grants
04:09:06 <dmead> etc
04:09:15 <osaunders> erus`: What is your job then?
04:09:27 <erus`> tech support or something
04:09:33 <erus`> I dont do much
04:09:38 <osaunders> hehe
04:09:43 <osaunders> Sounds cool
04:10:38 <erus`> I'm only an apprentice really. But i get a full salary and a qualification paid for by my employer every year
04:11:03 <osaunders> What country are you in?
04:11:15 <erus`> Old blighty
04:11:23 <osaunders> O rly
04:11:33 <osaunders> I thought apprenticeships gave piss poor pay
04:11:55 <erus`> yer they only have to give like £150 a week
04:12:15 <osaunders> I think they are a bit better in Scotland
04:12:23 <erus`> but i get more than that :) Not loads though
04:12:50 <osaunders> How long are you doing it for?
04:13:11 <erus`> i have 6 months left of a 2 year contract
04:13:19 <erus`> and then they might take me on at higher pay
04:13:41 <Jafet> > let end t@[a,b,c,d,e,f,g,h,i] = let line xs = product xs `elem` [1,8]; ls = [[a,b,c],[d,e,f],[g,h,i]] in not (any (==0) t) || any line ([a,e,i] : [c,e,g] : ls ++ transpose ls); ttt ply t | end t = 1 | True = sum $ map (ttt (3-ply) . (\i -> take i t ++ [ply] ++ drop (i+1) t)) $ elemIndices 0 t in ttt 1 $ replicate 9 0
04:13:46 <lambdabot>   mueval-core: Time limit exceeded
04:15:14 <osaunders> Sounds cool anyways
04:19:13 <erus`> can anyone point me to a simple Data.Map tutorial
04:19:46 * hackagebot AERN-Basics 2011.1.0.1 - foundational type classes for approximating exact real numbers  http://hackage.haskell.org/package/AERN-Basics-2011.1.0.1 (MichalKonecny)
04:21:13 <aleator> erus`: let {e = empty; e' = insert 5 "five" e;} in print (e' ! 5)
04:21:16 <napping> other than the docs?
04:21:42 <napping> I don't think there's anything tricky about it
04:22:24 <aleator> erus`: It is really simple. You get pretty far with just empty, insert, delete and lookup.
04:23:01 <erus`> napping: its not like every other language: myMap[key] = 2;
04:24:14 <Jafet> Why not use every other language, then?
04:24:25 <aleator> erus`: Translates as 'insert key 2 myMap'
04:24:26 <napping> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.4.0.0/Data-Map.html
04:24:43 <napping> things have names rather than special syntax
04:24:49 <napping> insert key 2 myMap
04:26:09 <aleator> If you're wondering about the order, it is because you can do insert key1 val1 . insert key2 val2 . insert key3 val 3 $ mymap
04:26:49 * hackagebot AERN-Real 2011.1.0.1 - arbitrary precision real interval arithmetic  http://hackage.haskell.org/package/AERN-Real-2011.1.0.1 (MichalKonecny)
04:26:51 * hackagebot AERN-Real-Interval 2011.1.0.1 - arbitrary precision real interval arithmetic  http://hackage.haskell.org/package/AERN-Real-Interval-2011.1.0.1 (MichalKonecny)
04:26:53 * hackagebot AERN-Real-Double 2011.1.0.1 - arbitrary precision real interval arithmetic  http://hackage.haskell.org/package/AERN-Real-Double-2011.1.0.1 (MichalKonecny)
04:31:31 <erus`> I dont really need type signatures do i?
04:31:40 <erus`> are they just for guidance?
04:32:09 <quicksilver> they can be useful for documentation
04:32:15 <quicksilver> and they can help produce better error messages sometimes
04:32:22 <Jafet> Sometimes you do, but you won't learn about those for a while
04:32:50 <Jafet> ghc -Wall encodes the usual convention
04:33:08 <shachaf> Jafet: In Haskell 98?
04:33:25 <napping> for polymorphic recursion, yes
04:34:23 <Jafet> Haskell 98? What's that?
04:35:16 <quicksilver> napping: and the DMR
04:36:02 <shachaf> quicksilver: I refuse to believe that that's part of Haskell 98.
04:36:20 <kosmikus> and for ambiguous type variables
04:36:39 <quicksilver> kosmikus: generally those require internal signatures not top-level ones, though, right?
04:36:43 <kosmikus> yes
04:37:11 <quicksilver> shachaf: your beliefs are your property and yours alone ;)
04:37:12 <roconnor> monomorphismrestriction
04:37:20 <napping> Anyway, you probably won't *need* to write them
04:37:46 <qklq> Newbie question... why am I having type problems here? http://pastebin.com/bhbqfJtc
04:38:13 <osaunders> Jafet: The standard for Haskell see the Haskell 98 Report
04:38:24 <shachaf> @ty sqrt -- qklq
04:38:25 <lambdabot> forall a. (Floating a) => a -> a
04:38:45 <shachaf> osaunders: I believe Jafet is aware of this.
04:39:01 <osaunders> Oh OK
04:39:07 <osaunders> Sorry Jafet
04:40:17 <Jafet> No, I feel sorry for you!
04:41:06 <osaunders> Why?
04:41:19 <Jafet> Hm, tic-tac-toe is surprisingly hard to golf.
04:41:32 <Jafet> Maybe I'm using the wrong representation(s)
04:41:53 <luite> are you golfing a perfect player?
04:41:54 <maurer_> Jafet: I assume you're already using a list monad?
04:42:13 <Jafet> Is there more than one list monad?
04:42:19 <maurer_> s/a/the/
04:42:48 * shachaf thesumes things frequently.
04:43:27 <napping> Shouldn't there be at least two?
04:43:29 <Jafet> If indiscriminately replacing concatMap with =<< counts, then yes
04:43:43 <napping> only one Monad [], of course
04:44:43 <erus`> if i insert a pair with a key that allready exists in the map will it overwrite it?
04:45:14 <napping> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.4.0.0/Data-Map.html#g:5
04:45:40 <erus`> perfect
04:46:01 <cheater_> is it possible that one day haskell will get easier indentation, as opposed to having some crazy algorithms that no one can remember?
04:46:19 <Jafet> What's crazy about it?
04:46:22 <shachaf> cheater_: I've never had an issue with Haskell's indentation.
04:46:49 <cheater_> you haven't been paying attention to what we were just talking about :p
04:46:49 <napping> It's easy enough to remembe, once you learn it
04:47:03 <cheater_> if you need to remember it it's a problem :X
04:47:06 <Jafet> I hope GHC's changes to do-notation will be extended, because they make indentation easier
04:47:12 <freiksenet> emacs does the indentation for you %)
04:47:15 <Saizan> i found haskell indentation much more natural than e.g. python's
04:47:17 <cheater_> Jafet: what changes?
04:47:24 <Jafet> However, it would invariably be "crazier"
04:47:26 <cheater_> Saizan: opposite for me
04:47:37 <Saizan> cheater_: you've used python for too long then
04:47:46 <cheater_> Saizan: no, i'm a python nwb
04:47:53 <frerich2> cheater_: I think the indentation of Haskell is kind of ok, but most explanations of how it works are really ugly. Like, the explanation of where the 'where' goes.
04:48:03 <cheater_> yeah
04:48:19 <cheater_> why can't we have nice things?
04:48:30 <erus`> maps are nice
04:48:37 <Jafet> Because they get rejected by people who don't take the time to understand them
04:48:44 <osaunders> BECAUSE YOU’RE TOO UGLY!
04:48:57 <osaunders> Now go to your room
04:49:13 <cheater_> why would i need to understand something that brings no value to my work
04:49:16 <Jafet> I come from my room
04:49:18 <cheater_> it's like having to understand braces
04:49:21 <Saizan> cheater_: write/read some haskell code, it'll get easy pretty soon
04:49:28 <cheater_> imagine C had 50 thousand types of braces
04:49:36 <cheater_> and you'd have to use a different one every time.
04:49:47 <Saizan> it's nowhere that complex
04:49:52 <cheater_> and there was a crazy algorithm associated to choosing the right one, or the world EXPLODES
04:50:00 <Cale> I think Haskell could get away with a technically much less permissive, but much easier-to-state rule about indentation
04:50:00 * Jafet undusts the cluebat
04:50:28 <erus`> and people show use the tab key rather than 2/4/8 spaces
04:50:59 * Saizan uses the tab key to put spaces in it
04:51:00 <Cale> I use my tab key, I just configure my editor to produce spaces when I press it
04:51:11 <Cale> which is the way that everyone should configure their editor
04:51:17 <erus`> its a waste of bytes
04:51:30 <erus`> Cale what are the advantages?
04:51:33 <osaunders> Tabs vs. spaces is pretty off-topic really
04:51:58 <Jafet> Ironically, the people who make this garbage argument don't know how the tab character was originally used.
04:51:59 <Saizan> cheater_: it's all about vertical alignment and putting anything that's conceptually nested at least a space to the right of the parent
04:52:32 * frerich2 thinks Saizan put it pretty nicely
04:53:02 <Jafet> Unfortunately, do-blocks tend to grow rightwards
04:53:10 <cheater_> yea but what if i do too many spaces
04:53:11 <cheater_> etc
04:53:19 <napping> too many?
04:53:36 <ketil> IMO, tab is for separating columns when records are newline-delimited.  I.e. for (the unfortunately named) CSV-format (or more appropriately but less commonly TSV format)
04:53:40 <napping> as long as it's more indented than the current level, it's a continuation
04:53:40 <cheater_> or what if i find that conceptually something is not a sub-element but an equal-level element
04:53:49 <napping> then indent the same
04:53:52 <cheater_> i don't do tabs, i just do spaces (well, smarttabs in vim)
04:53:59 <frerich2> In something like 'foo = x + 2', a 'where' would need to be at least one space further right than 'foo', not than then 'x'. Which, in my view, is the part on which 'where' acts on.
04:54:32 <erus`> pffff
04:54:53 <napping> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
04:55:03 <Saizan> cheater_: the number of spaces is irrelevant, just that things at the same level must align vertically
04:55:14 <ketil> If 'make' had used layout, the world would have been a better place.
04:56:23 <cheater_> fuck make :X
04:56:26 <cheater_> it's terrible :(
04:57:04 <Jafet> make doesn't have nesting
04:57:58 <Saizan> frerich2: heh, but where is not part of the syntax of expressions, it's part of the one for declarations
05:01:13 <ketil> cheater_, what's a better alternative?
05:03:00 * hackagebot heist-aeson 0.5 - Use JSON directly from Heist templates.  http://hackage.haskell.org/package/heist-aeson-0.5 (DavidHimmelstrup)
05:05:18 <aristid> preflex: seen Lemmih
05:05:18 <preflex>  Lemmih was last seen on #haskell 10 hours, 14 minutes and 13 seconds ago, saying: NemesisD: Then hope to God that the bytestring is in latin1.
05:05:29 <Lemmih> aristid: Yo!
05:06:09 <aristid> Lemmih: heist-aeson says you are David Himmelstrup, so i got curious :D
05:07:16 <Lemmih> snap! LOWERCASE? WHAT IS THAT?
05:07:36 <aristid> Lemmih: did you see JsonGrammar tho? i don't know if that's applicable to heist, but it's pretty cool
05:09:02 <Lemmih> aristid: I'm only interested in generated json, not parsing it.
05:09:53 <aristid> Lemmih: if you are writing REST interfaces, it would be cool to generate both the client and server functions with the same code.
05:10:07 * frerich2 read up about David Himmelstrup and suddenly has good memories of nightly visits to 7/11
05:11:27 <Lemmih> aristid: Indeed. But I rarely use Haskell on the client side.
05:11:44 <Lemmih> frerich2: wut?
05:12:49 <aristid> Lemmih: ok. it's just that i don't know what to be more excited about right now: driverless cars, or bidirectional parser/generator combinators :D
05:13:00 <frerich2> Lemmih: I read that you're from .dk which reminded me of my visits in various danish hotels and nightly visits to that awesome 7/11 chain of grocery stores you have (at least in copenhagen!) to satisfy hacker hunger at 3am
05:15:04 <adamvh> They've got 7-11's in Denmark?
05:15:22 <erus`> i want data parallel haskell
05:15:36 <aristid> erus`: hmm, it isn't published yet?
05:15:46 <frerich2> adamvh: At least in Copenhagen, so maybe it came over from Sweden.
05:16:18 <adamvh> frerich2: We've got 'em in the US.  They're everywhere.  Tokyo, too.
05:16:23 <aristid> erus`: haskellwiki says that the development version of GHC includes data parallel haskell
05:16:28 <osaunders> They’re in Canada
05:16:29 <Kerris> Ditto for Hong Kong and Malaysia.
05:16:35 <aristid> adamvh: not in germany tho
05:16:37 <frerich2> Argh, but not in Germany.
05:16:42 <osaunders> Not in the UK
05:17:05 <aristid> frerich2: but it's even worse in austria: there, it seems like all supermarkets close at 19:30
05:17:25 <erus`> yey 24 hour tescos
05:17:30 <matthew-_> in the code do { a; b }, there is no monad law that suggests that a should be evaluated before b, correct?
05:17:46 <matthew-_> it's only a feature of haskell's laziness that that's the case?
05:18:03 <aristid> matthew-_: what do you mean by evaluated?
05:18:17 <matthew-_> forced?
05:18:27 <Jafet> What hacker doesn't have their own food reserve?
05:18:34 <Lemmih> frerich2: You should totally ping me next time you're in Copenhagen.
05:18:50 <quicksilver> matthew-_: it is not a feature of haskell's laziness either
05:19:07 <aristid> matthew-_: do you mean the associativity law? http://www.haskell.org/haskellwiki/Monad_Laws
05:19:08 <kosmikus> matthew-_: no, it really depends on the monad
05:19:17 <erus`> Jafet: the healthy ones
05:19:31 <erus`> snacking is bad
05:20:07 <quicksilver> matthew-_: if it's true (and it isn't always) then it's a property of the definition of >>= in that monad.
05:20:18 <aavogt> you're allowed    do { a <- f; if a then x else y } -- need at least a part of f evaluated before you know what comes after
05:20:19 <matthew-_> aristid: ahh, I suppose that with associativity law plus a >> b === a >> \_ -> b then it does follow
05:20:50 <Jafet> No, no, hackers who eat poison get healthy.
05:21:50 <matthew-_> basically, I'm trying to understand why it's not necessary to transform do { a ; b } into a >> \_ -> b in order to prevent b from being "evaluated" prematurely
05:21:55 <aavogt> matthew-_: how does associativity apply if your question involves only one (>>=)?
05:22:23 <kosmikus> > runIdentity (do { undefined; return () })
05:22:25 <lambdabot>   ()
05:22:37 <kosmikus> matthew-_: ^^
05:22:46 <matthew-_> now the reason that you're likely scratching your heads is because I'm doing this in erlang, not haskell, and thus the args to >> _will_ be evaluated
05:22:50 <matthew-_> before >> is invoked
05:23:07 <matthew-_> because erlang isn't lazy...
05:24:40 <matthew-_> however, if in the parser, I transform >> to >>= \_ -> then I wonder whether that's sufficient
05:25:04 <matthew-_> basically, my current implementation does, I think, behave as I expect, but I don't think it obeys the monad laws
05:25:42 <kosmikus> matthew-_: >> is usually the same as >>= \_ ->, so transforming one into the other should have no effect
05:25:44 <aristid> matthew-_: does a >> (foo >>= bar) behave identically to (a >> foo) >>= bar?
05:25:57 <aristid> (in your old implementation)
05:25:58 <kosmikus> matthew-_: and it really depends what monad you're translating this to
05:26:40 <matthew-_> kosmikus: I have typeclasses for monads
05:26:46 <matthew-_> kosmikus: sort of.
05:27:17 <kosmikus> oh, I think I'm confused. are you translating Erlang code to Haskell, or Haskell code to Erlang?
05:27:35 <matthew-_> kosmikus: https://github.com/rabbitmq/erlando/tree/bug24025
05:27:42 <matthew-_> kosmikus: it's a pure erlang impl
05:28:03 <matthew-_> aristid: I'm still thinking about that one.
05:28:09 <aristid> matthew-_: monads are one of these incredibly general abstractions that in theory can work in any language, but are just much more convenient in haskell :)
05:29:17 <matthew-_> aristid: yes, in my current implementation a >> (foo >>= bar) behave identically to (a >> foo) >>= bar
05:29:41 <aristid> matthew-_: then i think it does satisfy the monad laws
05:29:55 <hpc> do the monad laws imply that (>>) is associative?
05:30:09 <hpc> nvm, i see how they do
05:32:05 <matthew-_> you see, if you look at https://github.com/rabbitmq/erlando/blob/bug24025/src/identity_m.erl then you can see that I've made the rhs of >> a fun
05:32:17 <matthew-_> but I now think that's wrong
05:33:00 <matthew-_> because of law 2: ie m >>= return  ≡  m which I don't have, I don't think
05:35:08 <matthew-_> because if I wrote do { x <- m; fun return/1 } then that'd be transformed to m >>= \x -> fun return/1, which just isn't right.
05:35:39 <ketil> Anybody know if wren ng thornton hangs around here?
05:37:00 <matthew-_> actually, let me ask a simpler question: why does haskell permit >> in Monad? Why not hard code it to >>= \_ -> ?
05:37:13 <wjt> because there might be a more efficient interpretation
05:37:21 <matthew-_> ok, it's really _just_ about efficiency?
05:37:22 <wjt> *implementation
05:37:25 <aristid> matthew-_: for performance reasons, probably. >> is not strictly necessary
05:37:37 <matthew-_> ok
05:37:46 <wjt> yes. x >> y must be observably equivalent to x >>= \_ -> y
05:37:53 <aristid> matthew-_: if you care about a simple set of defining functions, i recommend fmap + pure (aka return) + join
05:39:58 <matthew-_> I think >> only works because of haskell's laziness.
05:40:19 <erus`> I have a really strange bug; sometimes it asks for two moves in a row before drawing the board. and places both your inputed moves in one go!? http://hpaste.org/46597/tictac
05:41:26 <erus`> oh haha
05:41:39 <erus`> i have playerInput in cpu input
05:43:10 <omie> hi! how do I set some text in TextView ? I am not getting how to deal with those buffers. I am doing like
05:43:11 <omie> buf = textViewGetBuffer myTextView
05:43:13 <omie> textBufferSetText buf "NewText"
05:43:15 <omie> textViewSetBuffer buf
05:43:16 <omie> but ended up with errors. most of them were about syntax. could you just tell me how to put these 3 lines in 1 function ? :-S
05:43:57 <frerich2> erus`: A tic tac toe game was one of my first projects as well. I don't want to spoil the fun, but if you get stuck or something - I have the source code online.
05:44:34 <erus`> good to know :)
05:44:41 <erus`> i just have to check for winners now
05:45:16 <erus`> is there a good pattern for a nested if
05:45:21 <aleator> omie: Possibly, add "do" in the beginning of function.
05:45:38 <adamvh> Oh man, memories - I wrote a tic tac toe bot it C that played perfectly when I was first learning programming.
05:45:43 <adamvh> *in C
05:45:46 <erus`> i mean a series of if else if
05:46:04 <adamvh> erus`: case
05:46:10 * hackagebot syntactic 0.2.0.1 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.2.0.1 (EmilAxelsson)
05:46:36 <erus`> adamvh: I cant use a case because  i check different things for every if
05:47:01 <aristid> erus`: you know about guards?
05:47:34 <aristid> case () of _ | c1 -> a | c2 -> b
05:47:46 <erus`> ah perfect
05:47:47 <aristid> admittedly, a bit of a hack
05:48:10 <omie> aleator:  when def is like this textViewGetBuffer :: TextViewClass self => self -> IO TextBuffer what are the arguments I'm supposed to pass ?
05:50:01 <adamvh> omie: That means that "self"
05:50:14 <adamvh> is an instance of TextViewClass
05:50:26 <adamvh> so there's only one argument
05:50:27 <erus`> aristid: how do i do an else at the end, like a catch all?
05:50:42 <aristid> erus`: | otherwise
05:50:47 <aristid> > otherwise
05:50:48 <lambdabot>   True
05:50:48 <adamvh> which is of type TextViewClass
05:51:03 <aristid> erus`: otherwise is the same as True, so | True would work too
05:51:10 <adamvh> and your return value is of type
05:51:15 <adamvh> IO Text Buffer
05:51:23 <aristid> adamvh: wrong kind oO
05:51:43 <adamvh> I thought it would make more sense if I explained it like that
05:52:04 <aristid> :k IO
05:52:06 <lambdabot> * -> *
05:52:19 <aristid> not * -> * -> * :P
05:53:30 <adamvh> Oh yeah, I accidentally put a space in there
05:53:55 <adamvh> derp
06:05:26 <nyingen> @yarr
06:05:26 <lambdabot> Arrr!
06:06:27 <aristid> @yarr
06:06:27 <lambdabot> Har de har har!
06:09:05 <efie> my book says that in "(Lx.x y) (Ly.y)" the bound variables are "x,y" and the free ones are "y". i was told that i have to search for free variables in the second term "(Ly.y)" [in my opinion there are none?] and to search for bound variables in the first term "(Lx. x y)". and searching for bound variables means looking at the functions shaft and searching for "L. .." so in this case they arent any bound variables as well?
06:12:23 <quicksilver> there are no free variables in (Ly.y)
06:12:26 <companion_cube> Lx.x y  contains y as free variable, Ly.y contains no free variable
06:12:32 <quicksilver> but "x" is bound in (Lx . x y)
06:13:47 <kosmikus> efie: so the first sentence of your statement is true. the rest seems wrong.
06:14:49 <efie> ok thx. maybe the rest is true when i want to do a alpha-reduction?
06:15:15 * hackagebot monadiccp 0.7.0 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-0.7.0 (PieterWuille)
06:15:33 <djahandarie> The real issue is that the free variable y seems to be getting shadowed in the second term, assuming they are in the same term
06:16:18 <djahandarie> You could alpha-convert the second term
06:16:52 <Jafet> > (\x -> x y) (\y -> y) z
06:16:53 <lambdabot>   Couldn't match expected type `t -> t1'
06:16:53 <lambdabot>         against inferred type `Simpl...
06:17:00 <quicksilver> I don't think that's an 'issue' - I think efie's book is just testing understanding of concepts with an annoying example.
06:17:17 <djahandarie> Yes, that's what I mean
06:17:28 <quicksilver> definitions of bound and free are often discussed with examples which have shadowing
06:17:29 <djahandarie> The 'issue' in the sense that it is causing the confusion
06:17:35 <Jafet> > (\x -> x y) (\y -> y)
06:17:36 <lambdabot>   y
06:32:17 * hackagebot AERN-Real-Double 2011.1.0.2 - arbitrary precision real interval arithmetic  http://hackage.haskell.org/package/AERN-Real-Double-2011.1.0.2 (MichalKonecny)
06:34:05 <Kaidelong> @pl (\x -> x y) (\y -> y)
06:34:06 <lambdabot> y
06:34:18 * hackagebot hsndfile 0.5.1 - Haskell bindings for libsndfile  http://hackage.haskell.org/package/hsndfile-0.5.1 (StefanKersten)
06:35:12 <Kaidelong> > id (id y)
06:35:13 <lambdabot>   y
06:35:38 <Kaidelong> > (id id) y
06:35:40 <lambdabot>   y
06:36:25 <ksf> "deepseq-1.1.0.2-677f443f43caba0d312ab80199d4a233" doesn't exist (use --force
06:36:48 <ksf> what else can cause that when ghc-pkg check doesn't list any errors?
06:39:04 <HugoDaniel> i have a very huge Data.Text.Lazy
06:39:14 <HugoDaniel> and i want to process it chunk by chunk
06:39:20 <HugoDaniel> except that
06:39:38 <HugoDaniel> when a given time is reached, i want it to stop processing and return the chunks it has done
06:39:45 <ksf> -v says ghc itself does use the exact same deepseq with the exact same hash during compiling...
06:39:56 <HugoDaniel> i was thinking about using foldrChunks
06:40:24 <Jafet> Process each chunk with Timeout?
06:40:26 <ksf> "time" as in clock or as in chunk number?
06:40:37 <HugoDaniel> time as in clock
06:40:48 <ksf> welcome to IO land
06:40:53 <ksf> time is impure
06:41:07 <HugoDaniel> maybe i can use as: foldrChunks :: (Text -> IO a -> IO a) -> IO a -> Text -> IO a
06:41:16 <Jafet> You can still use foldr, but it's probably less ugly to use direct CSP
06:41:31 <Saizan> ksf: maybe you're passing deepseq-1.1.0.2-677f443f43caba0d312ab80199d4a233 to some command which doesn't accept the abi hash form?
06:41:33 <HugoDaniel> the thing that bothers me is how to stop foldr after i have processed some chunks
06:41:54 <Jafet> Perhaps you want scanr instead?
06:41:55 <ksf> well, it's cabal that's doing the passing.
06:42:04 <HugoDaniel> Jafet: scanr can work with chunks ?
06:42:19 <Jafet> I don't know about chunks, I'm just naming control structures.
06:42:48 <Jafet> Isn't there a toChunks, anyway?
06:43:59 <Saizan> HugoDaniel: if you don't use the "IO a" argument you won't process the rest, i believe, like with list's foldr
06:44:45 <HugoDaniel> Saizan: if i use IO a, then im forced to process all of the chunks ?
06:44:52 <Jafet> scanr lets you separate the timeout logic, which is what I assumed you were talking about
06:45:13 <HugoDaniel> yeah, my objective is to use timeout
06:45:23 <HugoDaniel> after timeout i want to return what has been processed
06:45:33 <Jafet> With foldr, you have to merge the timeout code with the chunk processing code
06:45:41 <Jafet> Other than that, there is no difference
06:46:45 <Saizan> HugoDaniel: i assumed you'll do something like foldrChunks (\chunk process_rest -> if someCondition chunk then return finished_result else process_rest >>= \ processed -> ...)
06:47:29 <Saizan> though maybe that doesn't work for you, i didn't read the whole backlog
06:47:51 <ksf> hmm. what exactly does the --package-conf tell ghc-package when it comes to an update?
06:48:05 <HugoDaniel> hmm
06:48:12 <Jafet> More like do x <- someCondition; case x of stop -> chunks; go -> process chunk chunks
06:48:12 <ksf> thing is, the first invocation creates package.inplace.conf, the second one fails.
06:48:31 <ksf> and the nixos wrapper is passing a gazillion of those flags itself.
06:48:35 <Jafet> Wait, that looks like it would only work with foldl.
06:50:37 <ksf> oh. might it be thinking that deepseq is a user package because it's passed via --package-conf , but then gets confused when it doesn't find it in the user database it's writing to?
06:53:20 <ksf> it's *neiter* global nor user.
06:53:38 <ksf> I guess the nix wrapper really is to blame.
06:57:45 <ksf> hint: iteratees are foldls
06:58:02 <ksf> ...and oleg has some pretty good argument why foldl is the best way to do it.
07:03:41 <ksf> in any case, nix and cabal could use some tighter integration.
07:04:34 <wtw>  /quit
07:06:50 <aristid> :t In
07:06:51 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
07:06:56 <aristid> :k Mu
07:06:57 <lambdabot> (* -> *) -> *
07:07:38 <companion_cube> is it type level fixpoint operator ?
07:07:43 <aristid> companion_cube: yeah
07:07:47 <erus`> whats this forall i keep seeing? generics stuff?
07:07:47 <aristid> i feel tempted to actually use it
07:07:50 <companion_cube> nice
07:08:33 <aristid> erus`: no, it's the same as if it wasn't there. it just explicitly signifies that these type variables are open
07:08:48 <aristid> and also shows the kind, if it's not *
07:08:51 <companion_cube> it also narrows the kind of f
07:09:06 <ksf> erus`: google "universial quantification"
07:09:41 <erus`> ksf: what are the odds of me getting past the second sentense and stuff understanding?
07:09:49 <erus`> sentence*
07:10:09 <ksf> it gets easier after that.
07:10:38 <ksf> it's a typical over-zealous wikipedia thingie.
07:11:19 <erus`> ah
07:11:24 <erus`> i get it :)
07:11:48 <ksf> then compare existential quantification and you're set.
07:12:09 <ksf> (and got two cool terms to mull about if you want to get rid of your inquisitive boss)
07:34:21 <jonkri> is it possible to do something like this (first argument to assertion): CEB.assert (stateConnectionState state == ConnectedPreFeatures _ _ _ _) (return ())
07:34:59 <quicksilver> well that's wrong on several levels :)
07:35:13 <quicksilver> you can't even do "x == F _ _"
07:35:44 <quicksilver> set up a simple boolean function for it.
07:36:37 <jonkri> quicksilver: thanks :)
07:37:47 <aristid> this might work: CEB.assert (case stateConnectionState state of ConnectedPreFeatures _ _ _ _ -> True; _ -> False)
07:40:45 <Axman6> quicksilver: lots of my students want to be able to do that. it's interesting because it's pretty clear they haven’t got that (==) is just a function yet
08:18:20 <Saizan> "don't mention equality"?
08:27:23 <byorgey> Saizan: shh!!! you just mentioned it!!
08:29:53 <ksf> there's only equality up to squinting, anyway.
08:30:02 <roconnor> @src sequence
08:30:02 <lambdabot> sequence []     = return []
08:30:03 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:30:03 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
08:30:27 <quicksilver> it's important to squint whilst programming
08:30:32 <quicksilver> makes it look like you're working hard
08:39:03 <Baughn> So as it turns out there are a number of people here who'd like to learn haskell, but I'm not sure how best to teach it.
08:39:40 <Baughn> If anyone has pointers, I'd love to hear from you. Though I should probably post this to haskell-cafe, shouldn't I? ^^;
08:40:19 <quicksilver> Baughn: buy them all burritos and then.....
08:40:29 <ksf> It also turns out there's a lot of people here who want to give nixos a spin, I just don't know how to convince them.
08:41:04 <Baughn> quicksilver: ..watch them not eat because they were already full
08:41:32 <rostayob> Baughn: learn you a haskell
08:41:47 <hpc> ^
08:41:47 <ksf> Baughn: make sexually dubious jokes at a conference, at least that's going to get you publicity.
08:41:58 <hpc> lyah is really all you need
08:42:15 <hpc> just go through the chapters until they all click
08:42:18 <Baughn> rostayob: Right. I was specifically shooting for ways to teach in-person. The interactivity means I'd probably be able to muddle through regardless, but..
08:43:12 <Jafet> "Interactivity" is just begging you to use fibs
08:43:19 <hpc> Baughn: i would teach the abstract stuff in person, and say "the language itself is homework"
08:43:54 <rostayob> Baughn: that would be my primary source of inspiration if I had to teach something (:
08:43:55 <hpc> i am probably not a very good teacher though
08:44:05 <Baughn> rostayob: I'll have another look. :)
08:44:33 <Baughn> hpc: I think I'm fine with the abstract stuff, or low-level details. It's the 'assigning homework' bit that's a problem. :P
08:44:36 <rostayob> for example, its explanation of the whole type system (when it introduces functors expecially) is incredibly clear
08:45:04 <Baughn> ..right. Definitely taking another look.
08:45:21 <hpc> i like how it explains lack of mutation
08:45:35 <hpc> "x = 5" - now x is 5
08:45:52 <hpc> "x = 6" - but you just said x is 5, liar!
08:48:43 <Silvah> > let x = y, y = x in x
08:48:44 <lambdabot>   <no location info>: parse error on input `,'
08:48:56 <Silvah> ?
08:48:56 <aristid> ; instead of ,
08:49:03 <Silvah> > let x = y; y = x in x
08:49:07 <lambdabot>   mueval-core: Time limit exceeded
08:49:18 <quicksilver> > let 1 = 2; 2 = 3 in 7
08:49:18 <aristid> see, now it's just bottom, as it should be:)
08:49:19 <lambdabot>   7
08:49:32 <aristid> > let 1 = 2 in 1
08:49:32 <lambdabot>   1
08:49:45 <aristid> quicksilver: why does that work again?
08:49:47 <rostayob> wait a second
08:49:50 <rostayob> > 2 = 3
08:49:51 <lambdabot>   <no location info>: parse error on input `='
08:49:54 <quicksilver> because numbers are valid patterns
08:50:06 <aristid> hmm
08:50:08 <Silvah> Now I can start telling imperative programmers that the syntax to swap two variables in Haskell is the above :D
08:50:14 <byorgey> the pattern 1 doesn't match the value 2, but it doesn't matter since the pattern 1 doesn't bind any variables
08:50:20 <aristid> quicksilver: numbers behave as if they were constructors, there?
08:50:27 <Jafet> Can you somehow evaluate those patterns
08:50:28 <quicksilver> sort of
08:50:41 <quicksilver> it's actually working with ==
08:50:55 <quicksilver> so it's comparing 1==2 and then concluding that the pattern doens't match
08:51:07 <quicksilver> btu as byorgey points out it doesn't matter because no variables are bound
08:51:12 <Starfire> > let 2 + 2 = 5 in 2 + 2
08:51:13 <lambdabot>   5
08:51:20 <Jafet> As in, make ghc throw an exception with them
08:51:36 <quicksilver> > let !1 = 2 in "hi"
08:51:37 <lambdabot>   "*Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
08:51:52 <Jafet> Nice
08:52:39 <aristid> > let !1 = 1 in "hi"
08:52:40 <lambdabot>   "hi"
08:53:00 <aristid> hmm. so you can make assertions that way :D
08:53:25 <quicksilver> yes, like
08:53:25 <Jafet> Assert that 1 == 1?
08:53:42 <byorgey> > let x = 3 in let !4 = x + 1 in "hi"
08:53:43 <lambdabot>   "hi"
08:53:47 <byorgey> > let x = 3 in let !5 = x + 1 in "hi"
08:53:48 <lambdabot>   "*Exception: <interactive>:3:17-26: Non-exhaustive patterns in pattern bind...
08:53:49 <quicksilver> case assertion of True -> program ; False -> error "assertion failed"
08:57:07 <Jafet> Of course, it is strangely more helpful to just leave out the False pattern with ghc
08:58:55 <libajto> Hi
08:59:00 <libajto> anyone here?
08:59:04 <Twey> assert True = id
08:59:15 <Twey> libajto: No, nobody.  Channel full of ghosts.
08:59:22 <c_wraith> only 770 people.  that's not very many
08:59:31 <libajto> seemingly , you the gatekeeper?
09:00:25 <libajto> heh , well, honestly going to cut to the chase. I would like to start with haskell as my first language..
09:00:58 <libajto> any tips I should consider before plunging into haskell?
09:01:25 <libajto> aside that , how is everyone? (that is active in some way)
09:01:38 <Jafet> Bring a rappel line; the rabbit hole goes deep
09:01:55 <libajto> hah yea that's why i'm asking first =D
09:01:58 <c_wraith> @where lyah
09:01:59 <lambdabot> http://www.learnyouahaskell.com/
09:02:14 <c_wraith> I guess that tutorial makes some reference to other programming languages
09:02:23 <sm> libajto: remember to take time off to digest
09:02:36 <djahandarie> Learn You a Haskell is the best chance you have for a good tutorial.
09:02:48 <c_wraith> but it should be possible to get by without understanding them.  learning haskell first is probably a good way to not get caught up in "this is how I'd do it in any other language"
09:02:51 <libajto> I checked the website but seemingly it is better for people who already know some C or C++ or any sortalike language
09:03:17 <libajto> heh
09:03:44 <djahandarie> There is no really good tutorial for "Learning how to Program, using Haskell" though, imo
09:04:11 <djahandarie> It will require a lot of initiative and not being afraid to just poke around randomly
09:04:16 <libajto> c_wraith that was what i was thinking , aside the idea I would rather do the hard bits first
09:04:40 <libajto> oh that's what I always do with my PC as I already tend to crash it time to time
09:04:44 <djahandarie> Mainly to get a feel for a lot of concepts which you are expected to know going into tutorials like LYAH, which explain Haskell very nicely but not exactly programming as a whole.
09:05:00 <libajto> okay then
09:05:10 <Jafet> Well, being a programmer is much easier than programming
09:05:26 <libajto> so it is also mentally a different vieuw from other , more used/older languages?
09:05:42 <c_wraith> I still think LYAH is probably a decent place to start...  You just might have to do a lot of experimentation with some things to figure them out, rather than knowing already what the concepts are
09:05:46 <djahandarie> libajto, Haskell is fairly different. But not entirely.
09:05:51 * djahandarie agrees with c_wraith
09:06:03 <DevHC> c_wraith: not if u have seizures from childish images
09:06:05 <libajto> hmmm ok then I will do that then
09:06:41 <libajto> I was just a bit cautious for dissappointment because It was meant more for people with C alike language expierence.
09:06:53 <libajto> hah
09:07:29 <libajto> okay then i'll start with lyah then , is there a channel where I can ask for help if i'm stuck on something?
09:07:41 <Silvah> libajto: yup
09:07:58 <Silvah> #haskell
09:08:07 <Silvah> Seems like you're there already :>
09:08:36 <libajto> ah okay then ^^ good to hear ,   yes well you never know if it isin't
09:08:50 <DevHC> it's not a matter of wether u can ask
09:08:55 <DevHC> rule#1: don't ask to ask
09:09:01 <DevHC> it's a matter of wether u'll get an answer
09:09:07 <DevHC> here, u WILL get an answer :]
09:09:12 <Silvah> DevHC: Can I have a question?
09:09:17 <DevHC> NO.
09:09:21 <Silvah> :P
09:09:40 <Clex> Silvah: you should ask if you can ask for this first.
09:09:42 <libajto> thanks ^^ well the first time I will always ask first to get my information as it is now the best weapon you can get in this era
09:10:16 <Jafet> Or a Barrett.
09:10:55 <libajto> anyway thanks alot for the info ^^ I'll try not to be dependant, unless i'm screwing up my pc..
09:11:29 <Silvah> Clex: oh. I'm really sorry. ;D
09:12:01 <libajto> anyway other then that   how are you guys/girls?
09:14:01 <Silvah> mueval-core: Time limit exceeded
09:18:47 <Silvah> > repeat 0
09:18:48 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:18:53 <Silvah> er
09:19:21 <Silvah> > let x = x in x
09:19:25 <lambdabot>   mueval-core: Time limit exceeded
09:19:33 <mueval-core> lambdabot: stfu
09:20:52 <djahandarie> @remember mueval-core <lambdabot>   mueval-core: Time limit exceeded  <mueval-core> lambdabot: stfu
09:20:53 <lambdabot> I will remember.
09:21:15 <Silvah> :D
09:21:15 <mueval-core> i have a feeling that i'm being quoted
09:34:01 <lgm> hello haskell!
09:36:20 <lgm> i've a question for those who are more experienced,
09:36:24 <lgm> functionally
09:36:29 <pe> Hi. I'm tired of this weird concept of SQL : why don't the people communicate sending and receiving typed binary data representing commands ? I'm sure there is a database server that has been written with this concept
09:36:52 <lgm> how many people are familiar with the idea that moving from container to parametrically polymorphic container is one of the strategies to get from Monoid to Monad?
09:37:01 <lgm> So, Monoid can be viewed as a kind of container
09:37:11 <lgm> The parametrically polymorphic version of that is actually Monad
09:37:27 <pe> you lose time verifying the data, produce a query in an obsolete language from the 60s, that has to be parsed, and in turn verified. In 2011 !
09:37:29 <lgm> To be really, really concrete, every Monoid is representable in terms of operations on S-expressions + some equations
09:38:01 <lgm> If we expand to S-expressions that contain atoms -- from some type, A -- this is the corresponding Monad
09:38:17 <lgm> i'm asking because this is actually a generic strategy (pun intended!) to categorify lots of structures
09:38:19 <Jafet> pe: interoperability!!!
09:38:31 <Jafet> All the way to the 60s
09:38:35 <lgm> For example, the move from ZF Set Theory to Fraenkl-Mostowski Set Theory can be cast in a similar light
09:38:40 <pe> Jafet : maybe it could be time for efficient programs too...
09:38:45 <mueval-core> SQL does suck goatballs
09:39:00 <lgm> And, the same strategy can be employed to solve for various data structuresAnd, the same strategy can be employed to solve for various data structures
09:39:11 <lgm> For example, Monoid : Monad :: Conway Game : X. Solve for X.
09:39:34 <Jafet> If a program is n times inefficient, wait log_{3/2} n years.
09:43:12 <Jafet> Er, wait log_{log_2 3} n years.
09:43:18 <libajto> hmmm question popped into my mind , is haskell good for games ?
09:43:40 <Kafka> libajto, not as much as some other languages, but a few have been written in it
09:44:17 <Jafet> Golf is one of the most thrilling games you can play in Haskell.
09:44:22 <libajto> lol
09:44:48 <libajto> hmmmm but it is not like it shouldent be done?
09:45:02 <libajto> more like it is possible but uncommon
09:45:45 <alexbagel> do it for fun, not for profit
09:46:34 <libajto> yes is what I would do to give me some expierence into coding in haskell
09:47:13 <Jafet> Well, the ratio of games to operating systems that are written in Haskell is greater than the ratio for C++. (Clearly Haskell is for games and C++ is more suited to systems programming.)
09:47:49 <libajto> hmmm that's interesting
09:48:02 <libajto> didint know that
09:48:06 * hackagebot attoparsec 0.8.6.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.6.0 (BryanOSullivan)
09:48:10 <jmcarthur> libajto: if you want to talk more about games in haskell you could try #haskell-game
09:48:14 <alexbagel> when i'm at work, I code in c++. when i'm at home, I code in haskell. not sure if that says anything.
09:49:12 <jmcarthur> libajto: i don't think Jafet was quite serious when he said "Haskell is for games"
09:49:14 <libajto> jmcarthur: thanks good to know, alexbagel: somehow it does to me
09:50:22 <libajto> well i'm new to it all so :p and I only know there is a bigger platform for c++ and c# because of the xna platform   anyway
09:50:34 <jmcarthur> C++ is used a lot for games because it has a pretty simple cost model, access to low level details, and some facilities to make disciplined resource management convenient and predictable
09:50:43 <libajto> anyway XD i'll leave that for -game
09:50:51 <jmcarthur> all of which are a little tougher to get with haskell
09:51:02 <fenmanm> can someone help me i try to install something with mingw and cabal install and i always get clang library not found, but i downloaded the libClang from llvm page and copied it to mingw
09:51:05 <libajto> hmmmm ah ok then
09:51:12 <djahandarie> But Haskell is good for games because it doesn't suck. ;)
09:51:17 <djahandarie> (Unlike C++ ;))
09:51:19 <jmcarthur> :)
09:51:20 <libajto> haha
09:51:51 <libajto> okay then =D well so it is possible to give me some practice goals (minigames)
09:52:21 <jmcarthur> pong, tetris, asteroids. always good games to start out with
09:52:28 <libajto> yep ^^
09:52:39 <djahandarie> I'd say leave games for later. But probably some simple stuff like console tic-tac-toe or something like that could be done soon in your learning process (first few months)
09:52:59 <djahandarie> If you try to do something too complicated at first it'll probably just be frustrating
09:53:50 <libajto> ah okay, well i'll start with the basics anyway , but I always lack idea's to do stuff and just recreating other programs to get the hang of it is nice but can be eventually quite boring..
09:54:02 <jmcarthur> yeah games are always a little harder than they sound, especially in a new language, and double especially in a mind-bending new language
09:54:06 <libajto> yea that I know from expierence x.x
09:54:30 <jmcarthur> and triple especially when the game-related libraries aren't entirely idiomatic with that language
09:54:37 <djahandarie> Yeah
09:54:56 <djahandarie> If the game-related libraries were nicer in Haskell I'd say that it wouldn't be as big of a challenge as it is right now
09:55:01 <djahandarie> The road is still being paved :)
09:55:07 <alexbagel> maybe try to solve some google code jam problems - they are great fun and many are game-related
09:55:10 <libajto> okay then   then I shall keep it for later on
09:55:25 <libajto> it's still being expanded? nice to hear =D
09:55:43 <jmcarthur> part of the reason for #haskell-game existing is to try and improve the situation
09:55:45 <libajto> google code jam problems? o_O
09:56:06 <libajto> oh great , guess i'll be there alot later on in my learning stage
09:56:18 <zasimov> Hello :)
09:56:24 <libajto> hi ^^
09:56:43 <libajto> anyway brb
09:57:50 <zasimov> Does anybody know how to get  mime type of a file by content or a file name?
09:58:20 <hpc> zasimov: look at the extension and look it up in a huge map?
09:59:13 <dcoutts> I think there's a binding to one of these file format detection libs
09:59:17 <dcoutts> magic or something
09:59:27 <zasimov> Where should I get this huge map? Is there a standard Haskell module?
09:59:58 <Jafet> Your system's mime type registry
10:00:24 <alexbagel> i dont think there's a standard one. people define and use what suits them.
10:00:38 <alexbagel> dig up some apache config files or something
10:01:00 <tg_> is there any chance that the Haskell Platform executables could be digitally signed?
10:01:08 <zasimov> So I should get my hands dirty...
10:01:43 <erus`> my IO isnt working the same when compiled vs running in ghci
10:01:54 <erus`> i think its something todo with buffers not being flushed
10:02:00 <erus`> can i flush stdout manualy?
10:02:01 <Jafet> Or you can just invoke a shell and ask `mimetype'.
10:02:26 <alexbagel> erus`: are you calling hClose on your filehandle(s)?
10:02:39 <erus`> im only writing to console
10:02:49 <erus`> with putStr(Ln)
10:02:53 <erus`> and getLine
10:02:59 <byorgey> erus`: you can flush with 'flush'
10:03:21 <zasimov> Jafet: I'd rather use a platform-independent solution
10:03:26 <byorgey> or maybe you have to write  'hFlush stdout', actually
10:04:50 <Jafet> There isn't one, short of rolling out your own database
10:05:01 <Jafet> Or rolling out someone else's...
10:05:26 <roconnor> Just a warning to everyone.  James Iry's recent blog post is half-wrong.
10:05:47 <tg_> roconnor: is it at least half-right?
10:06:02 <c_wraith> the wrong part is that lazy languages have product types?
10:06:04 <medfly> roconnor: is that some sort of deceptive advertising?
10:06:07 <roconnor> I think so.
10:06:30 <zasimov> Jafet: Thanks.
10:06:33 <c_wraith> also, it's ok.  James Iry is best-known for google-bombing himself with the phrase "mostly wrong" :)
10:06:34 <erus`> @hoogle hFlush
10:06:34 <lambdabot> System.IO hFlush :: Handle -> IO ()
10:06:53 <roconnor> c_wraith: the wrong part is the law he uses to claim that Haskell doesn't sum types.
10:07:07 <Jafet> One factually incorrect blog post is a tragedy; one million of them is a representative population sample
10:07:34 <k0ral> what is the equivalent of a makefile for haskell ?
10:07:35 <erus`> byorgey: its getting the IO in the wrong order i think :(
10:07:39 <luite> erus`: in haskell (or at least the ghc rts) I think stdin and stdout are not tied
10:07:44 <c_wraith> k0ral: a .cabal file.
10:07:52 <k0ral> c_wraith: thank you
10:07:56 <roconnor> c_wraith: it is a law that Haskell doesn't satify, but it isn't the law defining coproducts
10:08:16 <tg_> roconnor: there is some follow up in the comments
10:08:26 <c_wraith> roconnor: well, as I said, it's ok.  If you type "mostly wrong" into google, his blog is the first result :)
10:08:38 <yitz> k0ral: type 'cabal init' in the directory of a haskell project to create an initial version of a .cabal file. Then edit it.
10:09:07 <c_wraith> k0ral: yitz's advice depends on having the cabal-install package installed.  if you don't, get it from hackage
10:09:16 <c_wraith> @hackage cabal-install -- k0ral
10:09:16 <lambdabot> http://hackage.haskell.org/package/cabal-install -- k0ral
10:09:54 <k0ral> thank you guys, very nice channel
10:10:02 <yitz> @google mostly wrong
10:10:03 <lambdabot> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
10:13:27 <yitz> c_wraith, k0ral: true. i would assume though that nowadays most people will have the haskell platform, which includes cabal-install. those who don't probably know what they are doing.
10:14:28 <k0ral> yitz: you assume well
10:15:58 <Jafet> c_wraith just optimistically evaluated the "cabal: command not found" branch of the conversation
10:16:08 <yitz> c_wraith: getting cabal-install from haskell isn't as simple as getting anything else if you don't already have it. you need to run the bootstrap script, and i'm not sure how often you have to modify that in a "typical" non-HP environment, if there is such a thing.
10:16:23 <c_wraith> I've never had to modify the bootstrap script
10:16:45 <yitz> c_wraith: that's encouraging
10:17:16 <yitz> i remember having trouble with it once, but that was a long time ago.
10:18:31 <erus`> luite: how can i work around that?
10:18:41 <jonkri> what is the easiest way of running "runStateT :: StateT s m a -> s -> m (a, s)", where m is MonadIO, in the IO monad?
10:18:54 <luite> erus`: flushing, like byorgey said :)
10:19:16 <fenmanm> fenmanm: : hi
10:19:50 <byorgey> jonkri: I don't understand what you're asking.
10:19:53 <aristid> jonkri: you cannot in general convert a MonadIO m => m to IO
10:20:19 <byorgey> do you want a function  runStateT' :: MonadIO m => StateT s m a -> s -> IO (a,s) ?
10:20:32 <byorgey> if so, as aristid says, you can't write that generically, it depends on what m is.
10:23:11 <Saizan> lgm: do you have a reference for this monoid -> monad construction? i guess it's related to the free monad?
10:28:52 <phr> bbb
10:28:54 <phr> oops
10:31:07 <Arnar> hi all
10:31:59 <Arnar> anyone here know how much the current ghc relates to the original STG machine?
10:32:10 <hpc> @quote stg
10:32:10 <lambdabot> SamB says: they put the spine back into STG. / recently, the tags are back. / and I also hear that it bears little resemblence to the G machine...
10:32:33 <aristid> what is STG?
10:32:41 <hpc> spineless tagless g machine
10:32:49 <ezyang> How accurate would it be to say that finding the closure of a relation is similar to finding a greatest fixed point?
10:32:49 <aristid> what does that mean?
10:33:01 <Arnar> I'm wondering if the uniform representation of thunks and values is still there
10:33:13 <ezyang> Arnar: No, we cheat slightly now.
10:33:17 <c_wraith> transitive closures are certainly a fixed point
10:33:18 <ezyang> using pointer tagging.
10:33:28 <jmcarthur> @where stg
10:33:28 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
10:33:32 <jmcarthur> aristid: ^^
10:33:33 <ezyang> c_wraith: And, ostensibly, it's the greatest fixed point.
10:33:33 <k0ral> hmmm, I've built my newbie application and the executable is 1.1M heavy
10:33:38 <ezyang> because you union all of them.
10:33:40 <k0ral> how comes so much ?
10:34:00 <ksf> k0ral: unstripped + statically linked.
10:34:03 <c_wraith> ezyang: the algorithm used to calculate a transitive closure is more of a least-fixed-point approach, though
10:34:17 <Arnar> ezyang: but only pointer tagging, ?   so no dereference is needed to check
10:34:27 <Arnar> if I have a thunk or a whnf value
10:34:29 <aristid> jmcarthur: is it worth going into the university VPN to get through that?
10:34:30 <k0ral> ksf: how do you fix it ?
10:34:47 <ksf> strip the binary, that should shave stuff off.
10:35:01 <c_wraith> ezyang: in that it starts with some initial set, and constantly expands it.  rather than starting with the universe, and constantly contracting it
10:35:08 <ksf> dynamic linking is more involved
10:35:28 <jmcarthur> aristid: it's a good, although a bit outdated, paper explaining some of the ideas behind ghc's runtime. up to you whether that's worth it
10:35:43 <ezyang> Mmm, yes.
10:35:44 <aristid> jmcarthur: bah, VPN does not help.
10:35:50 <aristid> jmcarthur: can't access that
10:35:52 <Arnar> aristid: the paper is well worth reading anyways..
10:36:15 <aristid> first tell me how to get it
10:36:26 <aristid> i always get a login page
10:36:36 <Arnar> aristid: http://www.google.com/search?q=spineless+tagless+g+machine
10:36:49 <Arnar> follow the first link to the PS file hosted at research.microsoft.com
10:36:51 <Jafet> @google Peyton Jones Spineless Tagless G-machine 1992 filetype:pdf
10:36:53 <lambdabot> http://dalila.sip.ucm.es/~ricardo/jfp09.pdf
10:36:53 <lambdabot> Title: From Natural Semantics to C: A Formal Derivation of two STG Machines
10:36:59 <k0ral> ksf the documentation says stripping is enabled by default
10:37:00 <Arnar> not that one
10:37:07 <Jafet> Bah, foiled.
10:37:33 <aristid> Arnar: thanks, that works
10:38:09 <ksf> they must've introduced that quite recently, then.
10:38:11 <aristid> Arnar: woah, 85 pages
10:38:18 <aristid> that's one LONG paper
10:38:28 <jmcarthur> k0ral: stripping makes a difference for me
10:38:41 <Arnar> aristid: being an SPJ paper, it reads very easily
10:38:57 <c_wraith> aristid: it starts with an intro to the basic idea, and builds up an implementation of that.  then it scraps that implementation, and redoes the entire thing efficiently
10:39:00 <aristid> Arnar: but my stapler is too weak for so many pages :D
10:39:01 <ksf> k0ral: anyway, if you compare the size of the binary with a c program *and* the size of libc, haskell isn't that big anymore.
10:39:05 <jmcarthur> k0ral: dynamically linked and stripped, hello world on my machine is 9.8k
10:39:17 <k0ral> jmcarthur: you use the --enable-executable-stripping flag, right ?
10:39:28 <jmcarthur> i just ran strip after the fact
10:39:44 <k0ral> that's not a hello world actually, that's a minimalistic browser
10:39:52 <k0ral> so it involves more libraries
10:39:53 <k0ral> but still
10:39:56 <jmcarthur> that flag gives me an error, k0ral
10:40:01 <k0ral> 1.1M for a crappy browser
10:40:06 <jmcarthur> k0ral: what is the browser?
10:40:07 <jonkri> byorgey: yeah, that's what i wanted
10:40:20 <k0ral> jmcarthur: something I hacked
10:40:32 <jonkri> i have to think over my monad architecture
10:40:36 <jmcarthur> if it links to webkit or something i'm not surprised at that size, really
10:40:44 <k0ral> oh so you just did "strip path/to/executable" ?
10:40:50 <jmcarthur> yeah
10:40:57 <Arnar> @google peyton jones pointer tagging
10:40:58 <lambdabot> http://research.microsoft.com/pubs/67969/ptr-tagging.pdf
10:40:58 <lambdabot> Title: Faster Laziness Using Dynamic Pointer Tagging
10:40:59 <k0ral> jmcarthur: yes webkit, via gtk
10:41:10 <byorgey> jonkri: you can always lift IO a  actions into  MonadIO m => m a  actions, but you can't go the other way
10:41:18 <jmcarthur> ah, might also be statically linking some gtk stuff
10:41:20 <Arnar> ezyang: ^ is that one still "current" ??
10:41:23 <jmcarthur> not sure ho the gtk bindings work
10:41:25 <jmcarthur> *how
10:41:31 <Arnar> (sorry, extra ? by accident)
10:42:32 <jmcarthur> k0ral: to give you an idea of the difference between static+unstripped and dynamic+stripped, for hello world thats 917K vs. 9.8K
10:42:33 <k0ral> strip doesn't change executable's size
10:42:43 <k0ral> I guess it's really enabled by default
10:42:45 <jmcarthur> odd, it does for me
10:43:20 <k0ral> investigating the statically thing
10:43:37 <jmcarthur> for my system i can just pass a -dynamic flag to ghc
10:43:53 <jmcarthur> the problem with dynamic linking of course is that the libs still have to be around on the system running the executable
10:44:19 <maurer_> jmcarthur: Which is esp. awkward for haskell, as many user systems won't have that.
10:44:30 <jmcarthur> yeah
10:44:32 <k0ral> jmcarthur: well, that's the purpose of installing libraries on a computer
10:45:08 <jmcarthur> k0ral: sure, in the hopes that somebody will be in the unlikely scenario of running two haskell programs that share the same versions of haskell libraries built with the same version of ghc
10:45:42 <jmcarthur> (suffice to say, i'm not of the opinion that dynamic linking is really worth it)
10:45:54 <ezyang> c_wraith: Hmm, but that procedure coincides with Tarski's theorem for maximum fixed points.
10:45:57 <k0ral> :D
10:46:36 <jmcarthur> statically linked, stripped, and xzed, hello world on my machine is 155k
10:46:45 <k0ral> jmcarthur: well, that doesn't sound so odd to me; after all, that's the same situation for C libraries
10:47:00 <jmcarthur> i think gcc isn't so tight on compiler versions though
10:47:17 <k0ral> how often is ghc changing ?
10:47:26 <ezyang> GHC is fairly actively developed.
10:47:37 <jmcarthur> major version change once a year, minor much more frequently
10:47:45 <jmcarthur> *major change
10:47:52 <Jafet> So... my current / will fit over two hundred thousand copies of hello world
10:48:12 * Jafet decides not to worry too much about it
10:48:14 <jmcarthur> most of those are not backward compatible for libraries, even the minor version bumps
10:48:40 <k0ral> fine then
10:48:52 <k0ral> keeping statically linking
10:49:01 <jmcarthur> dynamic linking is nice if you are a haskell developer at least
10:49:07 <jmcarthur> if you are tight on hd space
10:49:12 <jmcarthur> that's the only benefit i know of
10:49:28 <jmcarthur> you have to be *really* tight on hd space, too
10:49:32 <k0ral> well, it's just that I'm willing to develop a suckless minimalistic KISS browser in haskell
10:49:47 <k0ral> if I tell people it is 500M heavy
10:49:53 <k0ral> I would loose all credit
10:49:54 <jmcarthur> lol, it won't be that heavy
10:50:03 <jmcarthur> i doubt it will get much heavier than it already is
10:50:17 <Jafet> Use runhaskell, then!
10:50:31 <k0ral> already using it
10:50:38 <k0ral> oh
10:50:44 <k0ral> you mean not for compilation ?
10:50:47 <Jafet> perl hackers don't ever include the size of the perl executable; why should you?
10:51:00 <ezyang> c_wraith: Well, on powersets. I think the confusing thing here is that unions and intersections flip depending on the context.
10:51:02 <jmcarthur> unstripped hello world is close to a meg as it is. with your extra libs and stuff it only went up a little.
10:51:26 <jmcarthur> i disagree with using runhaskell. that's a great way to go slow
10:51:43 <k0ral> agreed
10:51:50 <Jafet> If you link something like the qt bindings, it reportedly goes up another few dozen megabytes
10:51:50 <ksf> not if we had a runhaskell that could cache compilation results.
10:52:05 <ksf> or, even better, a proper jit compiler.
10:52:07 <k0ral> Jafet: can't you just link part of qt ?
10:52:27 <Jafet> I don't know.
10:52:32 <brbr> I believe i have parsec installed... but ghci still tells me Could not find module `Text.ParserCombinators.Parsec':
10:52:35 <brbr> help?
10:52:49 <ksf> wrong parsec version.
10:52:59 <ksf> the names of the modules changed.
10:53:08 <byorgey> brbr: what version of parsec do you have installed?  Check the output of 'ghc-pkg list parsec'
10:53:17 <k0ral> runhaskell Setup.hs build is quite long to type
10:53:25 <k0ral> I would have expected something like "make"
10:53:35 <ksf> k0ral: what about "cabal build"+
10:53:38 <ksf> ?
10:53:53 <k0ral> ksf: that's not what documentation teaches us :)
10:53:57 <brbr> byorgey: parsec-3.1.1
10:54:24 <Jafet> Can't do the Kessel run on that
10:54:25 <ksf> yep, the cabal and cabal-install docs should probably be merged.
10:54:27 <brbr> ksf: how can i figure out the correct module name?
10:54:28 <byorgey> brbr: is it installed in the global or user package DB?
10:54:39 <ksf> brbr: try hackage.
10:54:48 <byorgey> ksf: 3.1.1 still includes Text.ParserCombinators.Parsec as a compatibility layer
10:54:49 <ksf> it's got docs for all the versions.
10:54:55 <flosit> hi guys, I am rather new to haskell, so i hope my question wont be too stupid:   i try to build a vector data type with arbitrary length and figured something like this:
10:54:59 <flosit> data Vector [a] = Vector [a] Integer
10:55:08 <ezyang> Uff. I wish I understood why these symbols flipped.
10:55:12 <k0ral> cabal install puts the executable in .cabal/bin instead of /usr/local/bin
10:55:20 <flosit> the Integer should hold the length of the vector
10:55:26 <k0ral> so there's a difference between cabal install and runhaskell Setup.hs install
10:55:26 <byorgey> flosit: you want  data Vector a = ...  instead of  data Vector [a] = ...
10:55:40 <ksf> k0ral: the former defaults to --user
10:56:02 <byorgey> k0ral: also, cabal install will fetch and install dependencies
10:56:09 <brbr> byorgey: ksf: looks like Text.ParserCombinators.Parsec is valid in hackage..
10:56:18 <flosit> byorgey: so a only denotes the type?
10:56:42 <byorgey> brbr: yes, it should be.  is parsec installed in the global or user package DB?  in the output of ghc-pkg list parsec?
10:56:48 <k0ral> hmmm and how can I uninstall something installed by runhaskell Setup.hs install ?
10:57:09 <k0ral> there's no uninstall tag
10:57:09 <byorgey> k0ral: rm.
10:57:09 * ksf would write that newtype Vector n a = Vector [a]
10:57:16 <k0ral> is the binary the only file to be installed ?
10:57:31 <byorgey> ksf: don't confuse the newbies please =)
10:57:32 <ksf> no need to track the length on the type level.
10:57:39 <ksf> err, value level.
10:58:00 <byorgey> flosit: data Vector a = ... defines a type Vector with one type parameter a
10:58:10 <ksf> k0ral: you can ghc-pkg unregister
10:58:12 <byorgey> so later you can have  Vector Int or Vector Bool or... etc.
10:58:15 <flosit> ok, but what i actually want is not to define the length and get an empty vector,  but give it a list of numbers and store this combined with its length
10:58:23 <ksf> or, less extreme, ghc-pkg hide
10:58:33 <byorgey> flosit: ok, then write a function  mkVector :: [a] -> Vector a
10:58:43 <byorgey> flosit: which stores the list and its length in the vector
10:59:24 <k0ral> ksf: my project isn't listed by ghc-pkg
10:59:24 <flosit> ah, ok, thanks. i thought stuff like that would be done via some 'constructor-magic'
10:59:35 <k0ral> but that's ok if I only need to rm the executable
10:59:43 <byorgey> flosit: right, there's no constructor magic in Haskell
10:59:45 <ksf> k0ral: cabal and ghc don't track executables.
10:59:45 <flosit> (i come from the oop world)
11:00:25 <byorgey> flosit: usually what we would do instead is write a 'smart constructor' like  mkVector and then export mkVector but NOT the Vector constructor
11:00:37 <byorgey> flosit: that way users can only construct Vectors using the mkVector function
11:00:48 <ksf> constructors aren't special, apart from the fact that you can use the same upper-case name as a destructor in pattern matching.
11:01:19 <ksf> :t Just
11:01:20 <lambdabot> forall a. a -> Maybe a
11:01:25 <ksf> see, just a function.
11:05:09 <k0ral> isn't there a command that does both build and install ?
11:05:28 <byorgey> k0ral: 'cabal install' actually does  configure + build + install
11:05:54 <byorgey> AND it tracks down dependencies recursively
11:06:04 <k0ral> byorgey: :) wonderful
11:06:22 <webchat77_> k0ral: cabal configure && cabal build :)
11:07:26 <tg_> to clear up some things about right-associativity of type declerations...
11:07:45 <tg_> the concept is that I can put parentheses around any open chain of arrows
11:07:46 <ksf> cabal install --only-dependencies is also nice.
11:08:18 <ksf> no need to install what you're working on, usually.
11:09:02 <tg_> but if I introduce some parens around an expression in an open chain, then I'm introducing another right-anchor?
11:09:05 <tg_> like flip...
11:09:07 <tg_> :t flip
11:09:07 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:09:36 <tg_> starting from no parens:
11:09:44 <tg_> a -> b -> c -> b -> a -> c
11:09:53 <tg_> to make the first three a functor, I do:
11:10:00 <tg_> (a -> b -> c) -> b -> a -> c
11:10:41 <Blamu2> Is there anyone here who works in php? I will pay for small work
11:10:43 <tg_> and then I can introduce an anchor on the right, and pair it anywhere I want?
11:11:02 <tg_> (a -> b -> c) -> (b -> ( a -> c ))
11:11:02 <doserj> a -> b -> c -> b -> a -> c == a -> (b -> (c -> (b -> (a -> c))))
11:11:04 <tg_> like that?
11:11:08 <Peaker> Blamu2, this isn't an appropriate topic here
11:11:44 <tg_> doserj: is there a thing which lets me put type signatures in, and get functions which exhibit it out?
11:12:04 <doserj> @djinn a -> a
11:12:05 <lambdabot> f a = a
11:12:21 <tg_> @djinn (a -> b -> c) -> b -> a -> c
11:12:21 <lambdabot> f a b c = a c b
11:12:22 <Blamu2> then where is it appropriate?
11:12:36 <tg_> Blamu2: workforhire sites?
11:12:50 <tg_> @djinn (a -> b -> c) -> (b -> a -> c)
11:12:50 <lambdabot> f a b c = a c b
11:14:45 <doserj> @pl f a b c = a c b
11:14:46 <lambdabot> f = flip
11:14:53 <tg_> there you go
11:15:07 <tg_> djinn -> pl will do it huh
11:15:12 <tg_> @pl f a = f a
11:15:12 <lambdabot> f = fix id
11:15:23 <tg_> @pl f a a a = a a a
11:15:24 <lambdabot> f = const (const (join (join id)))
11:15:27 <tg_> neat
11:15:30 <tg_> doserj: thanks
11:15:50 <tg_> pl means pointless?
11:15:56 <doserj> yes
11:16:00 <tg_> ok, thanks
11:17:15 <Peaker> @pl f x y = f x + f y
11:17:15 <lambdabot> f = fix (flip =<< (((.) . (+)) .))
11:17:25 <Peaker> It's not always very good :-)
11:17:38 <Peaker> @pl f g x y = g x + g y
11:17:39 <lambdabot> f = flip =<< (((.) . (+)) .)
11:17:44 <tg_> :t =<<
11:17:44 <lambdabot> parse error on input `=<<'
11:17:48 <tg_> :t (=<<)
11:17:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:18:07 <adamvh> tg_: its just like >>= backwards
11:18:18 <tg_> adamvh: I don't know about >>= yet :o
11:18:21 <Peaker> @type ((+) `on`)
11:18:22 <lambdabot> forall b a. (Num b) => (a -> b) -> a -> a -> b
11:18:34 <adamvh> tg_: Oh, sorry, it's one of the monad laws
11:18:42 <Peaker> @type (\g x y -> g x + g y)
11:18:43 <lambdabot> forall t a. (Num a) => (t -> a) -> t -> t -> a
11:18:44 <adamvh> tg_: it's an infix version of "join"
11:18:51 <tg_> adamvh: yeah, I mean, I know that it's related to the monad laws, but I don't know about them yet in detail.
11:19:07 <tg_> adamvh: and since it's infix, there's two directions it can be joined?
11:19:09 <kputnam> @pl f a b = a
11:19:09 <lambdabot> f = const
11:19:36 <tg_> @pl f (/a) (/b) = a (/b)
11:19:36 <lambdabot> (line 1, column 13):
11:19:36 <lambdabot> unexpected "="
11:19:38 <lambdabot> expecting variable, "(", operator or end of input
11:19:42 <adamvh> tg_: It just means that a >>= b
11:19:46 <Peaker> so:    flip =<< (((.) . (+)) .)     ==    ((+) `on`)
11:19:54 <adamvh> actually ...
11:19:58 <adamvh> @src join
11:19:58 <lambdabot> join x =  x >>= id
11:20:07 <tg_> adamvh: it's literally true
11:20:16 <byorgey> @. pl djinn (a -> b -> c) -> (b -> a -> c)
11:20:17 <lambdabot> f = flip
11:20:17 <tg_> @pl x (>>=) id
11:20:18 <lambdabot> x (>>=) id
11:20:22 <tg_> err
11:20:36 <tg_> byorgey: one-upper! :o
11:20:38 <Peaker> >>= is join after fmap.   join is >>= into id. (the id cancels the fmap part)
11:20:47 <byorgey> tg_: lambdabot has plugin-level composition =D
11:20:49 <adamvh> tg_: Basically what join does is flatten nested monad constructors
11:21:00 <adamvh> So if you have something like
11:21:03 <adamvh> IO IO String
11:21:11 <byorgey> kind error
11:21:17 <adamvh> which you would get if you did IO twice
11:21:26 <adamvh> It collapses down to IO String
11:21:30 <tg_> ok...
11:21:55 <Peaker> IO (IO String)
11:21:57 <adamvh> tg_: This is necessary when you do some IO that depends on the result of other IO
11:22:09 <tg_> adamvh: ok, I'll get to it soon
11:22:31 <adamvh> tg_: I just struggled through all this stuff a couple days ago, heh
11:22:47 <tg_> adamvh: hehe. I'm doing LYAH right now
11:22:58 <adamvh> Peaker: Yeah, sorry, I screwed that up
11:23:13 <adamvh> Peaker: I have the Lisper's pernicious blindness to operator precedence
11:23:54 <Jafet> > ((/) ((+) x y) z)
11:23:54 <lambdabot>   (x + y) / z
11:24:10 <mauke> adamvh: even in lisp (a b c) is not (a (b c))
11:25:53 <acidjnk> hello
11:26:27 <byorgey> hi acidjnk
11:26:40 <acidjnk> Can anyone commend for or against "The Haskell Road to Logic, Maths and Programming", or is the author, van Jan Eijck, known?
11:26:56 <tg_> acidjnk: I tried to read it, I found it difficult
11:27:35 <acidjnk> I have very deep practical knowledge in analysis, differential equations, vector spaces etc., but only basic knowledge in other math areas.
11:28:09 <tg_> acidjnk: like logic, proof systems, category theory, type theory?
11:28:16 <adamvh> acidjnk: A fellow applied mathematician!  Well met!
11:28:29 <acidjnk> Yes, those are the areas I'm not good at, tg_
11:29:57 <acidjnk> Will I be able to understand the book then?
11:31:15 <tg_> can someone explain if Dan Doel's comments in the James Iry post (
11:31:20 <tg_> http://james-iry.blogspot.com/2011/05/why-eager-languages-dont-have-products.html
11:31:33 <tg_> ) mean that haskell is not a good place to deal with infinite products?
11:32:11 <Peaker> I liked: http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf   never noticed that in Lisp, incremental evaluation of terms yields things that are not themselves terms that can be evaluated
11:33:12 <byorgey> tg_: what do you mean by infinite products?
11:33:31 <tg_> byorgey: I mean infinite product expressions that will converge
11:33:38 <tg_> expansions*
11:33:53 <byorgey> tg_: oh, that's a different sort of "product" being talked about in that post
11:34:00 <byorgey> it is talking about product types, i.e. pairs
11:34:44 <byorgey> tg_: Haskell is a perfectly fine language for doing iterative computations that converge to some value
11:35:14 <byorgey> tg_: you may be interested in reading "Why Functional Programming Matters" which as I recall has some fun examples doing root-finding
11:35:20 <byorgey> not exactly infinite products but a similar idea
11:35:48 <tg_> byorgey: I figured I was going to read that right after LYAH and implement everything in it
11:36:07 <byorgey> tg_: ok =)
11:36:24 <tg_> byorgey: I have read it before, but I got the impression that I did not fully understand it.
11:36:27 <djahandarie> It's really unfortunate how product and sum are so overloaded
11:37:12 <brbr> byorgey: /Library/Frameworks/GHC.framework/Versions/7.0.3-i386/usr/lib/ghc-7.0.3/package.conf.d: parsec-3.1.1
11:37:25 <tg_> byorgey: I still don't understand what's being discussed in that post at all... if "product types" are "pair types" or "type tuples"
11:37:32 <tg_> then in what sense is Haskell unable to cope with them?
11:37:47 <brbr> byorgey: why can't ghc find that?
11:37:58 <djahandarie> tg_, it's really specific argument relating to undefined values.
11:38:13 <Peaker> tg_, Haskell is a non-strict language (he wrote "lazy" and "eager" but the correct terms here are strict/non-strict) -- so it DOES have products. It allegedly does not have sums
11:38:14 <alpounet> well tg_ let's rather say haskell doesn't strictly satisfy all the rules given in the categorical definitions
11:38:34 <byorgey> brbr: hmm, it should be able to
11:38:51 <tg_> alpounet: but that just means you can't expect haskell to do automatic theorem proving or something - not that you can't actually implement examples of categorical product types?
11:38:52 <Peaker> why-eager-languages-dont-have-products <-- Haskell is not eager
11:38:54 <djahandarie> tg_, the concept of products and coproducts (also known as sums) are specific definitions, and Haskell fails to meet the definitions for certain values (in this case, undefined values).
11:39:19 <djahandarie> Peaker, btw, dolio argued that Haskell doesn't have products OR sums.
11:39:35 <byorgey> brbr: check the spelling carefully?
11:39:39 <tg_> djahandarie: yeah...
11:39:40 <alpounet> tg_, the problems happen with "_|_"
11:39:41 <alpounet> called bottom
11:39:57 <tg_> alpounet: yes, which is "the same thing" as Falsity in a theorem?
11:39:58 <Peaker> djahandarie, because its products are lifted?
11:40:05 <brbr> byorgey:   Could not find module `Text.ParserCombinators.Parsec':
11:40:12 <djahandarie> Peaker, yeah
11:40:17 <byorgey> brbr: hmm
11:40:26 <djahandarie> Peaker, it doesn't satisfy the other rule, (fst p, snd p) = p
11:40:36 <Peaker> djahandarie, I personally hate that decision
11:40:49 <Peaker> djahandarie, I think it would be better to have unlifted products
11:41:08 <Peaker> (and unlifted sums too, but that's harder.. totality would be awesome)
11:41:25 <Philippa_> they're cheap enough to have if you want them
11:41:41 <adamvh> Any repa users here right now?
11:41:57 <Peaker> Philippa_, if all product pattern matches are irrefutable, you mean?
11:42:11 <adamvh> I'm considering tacking some extensions onto it, and I want someone to bounce ideas off of
11:43:27 <tg_> whatever this "limitation" is in Haskell, is there some language out there that actually operates at the abstract category theory level?
11:43:53 <jmcarthur> charity?
11:44:19 <byorgey> brbr: sorry, I am out of ideas
11:44:37 <djahandarie> tg_, you can talk about various mathematical theories including category theory in theorem provers / total dependently-typed languages like Agda and Coq
11:45:00 <djahandarie> And you can somewhat talk about them in Haskell. Just not very well.
11:45:16 <tg_> djahandarie: more importantly to me, everything I learn in Haskell will prepare me to use those languages (Agda and Coq)
11:45:25 <tg_> yes?
11:45:38 <brbr> byorgey: I can compile just fine with ghc... just can't load parsec in ghci...
11:45:46 <djahandarie> It will help more with Agda probably, but yes, it will help.
11:45:50 <tg_> that is, if I gain intuition with these concepts in Haskell, I should be able to jump over..
11:45:53 <tg_> ok
11:45:56 <hpc> tg_: what you learn in haskell won't be applicable necessarily, but the concepts yes
11:45:59 <Philippa_> Peaker: I meant it's easy enough to declare data Pair a b = Pair !a !b
11:46:31 <djahandarie> The bridge from Haskell to Agda is actually a fairly small one to cross imo
11:46:41 <djahandarie> Though I feel like I haven't seen any learning material for it that I really like
11:46:58 <tg_> djahandarie: I thought it might be, considering how often it comes up and how the guy who has been posting on r/haskell is doing tutorials in both at the same time
11:47:01 <adamvh> Out of curiosity, what's the use case for Agda?
11:47:02 <jmcarthur> the problem with agda is that nobody knows what to do with it
11:47:07 <jmcarthur> haha timing
11:47:17 <tg_> jmcarthur: lol
11:47:19 <jmcarthur> IMO, agda is a great language for dsls
11:47:35 <adamvh> Yeah, I want to do numerical calculus
11:47:39 <jmcarthur> and for hard stuff
11:47:39 <djahandarie> I feel like Agda can be for anything Haskell is for. It just isn't all the way there yet.
11:47:52 <adamvh> so, a better Fortran basically, and Haskell seems a promising candidate
11:47:56 <jmcarthur> i find myself often prototyping in agda and then translating to haskell
11:48:07 <tg_> I will eventually (soon) need to be writing proofs that I can't do in my head
11:48:25 <jmcarthur> yeah and then there's the obvious appeal of safer programming like that
11:48:57 <djahandarie> jmcarthur, funny, it's usually "prototyping in Haskell and translating to X" :p
11:49:04 <Peaker> Philippa_, that will just make the product follow less laws, iiuc
11:49:05 <tg_> the goal was to use haskell + [something else, be it agda or coq or whatever] to do numerical and (set, number, and group/ring theory) proofs
11:49:12 <adamvh> How much advantage would one gain from writing a "does lots of floating point arithmetic" type program in Agda?
11:49:16 <tg_> and then use visualization to introduce geometric proofs
11:49:30 <jmcarthur> adamvh: probably not much unless you don't use floating point :P
11:49:37 <tg_> jmcarthur: that's me :O
11:49:51 <jmcarthur> adamvh: what kind of program is this?
11:50:00 <djahandarie> tg_, Haskell isn't very good with proofs. It can only prove a small subset of logic, and that's when you entirely ignore the fact that you have undefined.
11:50:13 <adamvh> Well, I write a lot of one-off's to solve various calculus problems
11:50:29 <jmcarthur> ah calculus
11:50:41 <adamvh> I've been a matlab + C for serious business guy
11:50:44 <jmcarthur> this reminds me i need to get around to implementing the Floating class for fixed-point somehow
11:50:46 <hpc> you can write proofs yourself about the behavior of haskell programs
11:50:52 <hpc> but that's not really the same
11:50:52 <dmead> i think theres a google tech talk about dijnn someplace?
11:51:05 <djahandarie> There's a google tech talk about dijnn?!
11:51:12 <ion> There's a google tech talk about dijnn?!
11:51:16 <hpc> djinn isn't that impressive
11:51:17 <jmcarthur> isn't it called djinn?!
11:51:18 <djahandarie> Djinn*
11:51:20 <djahandarie> Haha
11:51:23 <hpc> free is more impressive
11:51:28 <djahandarie> Free is pretty neat
11:52:01 <hpc> djinn is just "give an implementation, any will do"
11:52:30 <mauke>  any = undefined
11:52:31 <ion> That’s what we do, too. :-P
11:52:37 <jmcarthur> "constructively prove this property"
11:52:45 <c_wraith> @djinn a -> a -> a -> a
11:52:45 <lambdabot> f _ _ a = a
11:53:00 <hpc> @djinn a
11:53:00 <lambdabot> -- f cannot be realized.
11:53:07 <tg_> wasn't there another prover that was recently posted on r/haskell? s...something?
11:53:13 <jmcarthur> @djinn (a -> b) -> Not b -> Not a
11:53:13 <lambdabot> f a b c = b (a c)
11:53:32 <tg_> zeno?
11:53:37 <ion> dmead: If you find it, please share a link, kthx.
11:54:07 <tg_> zeno [haskell -> [isabelle]] prover?
11:54:15 <tg_> how does this fit in with agda, coq?
11:54:35 <sully> @djinn a -> b
11:54:36 <lambdabot> -- f cannot be realized.
11:54:50 <hpc> @djinn Bool
11:54:50 <lambdabot> f = False
11:54:58 <sully> heh
11:55:00 <ion> @djinn Integer
11:55:01 <lambdabot> Error: Undefined type Integer
11:55:01 <sully> @djinn Int
11:55:01 <lambdabot> Error: Undefined type Int
11:55:04 <sully> aw.
11:55:07 <hpc> heh
11:55:09 <ion> @djinn Not Bool
11:55:10 <lambdabot> -- f cannot be realized.
11:55:11 <sully> @djinn a
11:55:12 <lambdabot> -- f cannot be realized.
11:55:15 <tg_> LOL @ the message at the bottom of TryZeno
11:55:20 <tg_> http://www.doc.ic.ac.uk/~ws506/tryzeno/
11:55:24 <wto> @djinn (a -> b) -> [a] <
11:55:25 <lambdabot> Cannot parse command
11:55:28 <wto> GAH
11:55:32 <wto> @djinn (a -> b) -> [a] -> [b]
11:55:33 <lambdabot> Error: Undefined type []
11:55:36 <wto> =(
11:56:06 <wto> @djinn (a -> f b) -> f a -> f b
11:56:06 <lambdabot> -- f cannot be realized.
12:00:30 <djahandarie> It can't do anything involving inductive data types
12:01:03 <tg_> djahandarie: Zeno?
12:01:16 <djahandarie> Djinn.
12:01:50 <hpc> either, i think
12:02:08 <djahandarie> Zeno can.
12:02:29 <dmead> ion, it's on wadlers blog
12:02:33 <dmead> but the link is dead
12:02:41 <dmead> http://wadler.blogspot.com/2007/04/google-tech-talk-parametric.html
12:04:05 <balor> hoogle tells me that evaluate :: a -> IO a.  Is this the way, when given an "Int" to return an "IO Int"?  or a "Nothing" to an "IO (Maybe Int)"
12:04:35 <c_wraith> balor: the general way to do it is with return
12:04:46 <c_wraith> balor: evaluate does that, but...  it does more
12:05:05 <c_wraith> > return 5 :: IO Int
12:05:06 <lambdabot>   <IO Int>
12:05:18 <balor> oh, that actuall makes sense to me :)
12:05:20 <tg_> man, ExtJS is a *very* attractive library
12:06:41 <k0ral> I'm trying to understand the state monad
12:06:54 <k0ral> (yes, again)
12:07:04 <tg_> for reference: http://www.sencha.com/products/extjs/examples/
12:07:12 <k0ral> something is odd
12:07:42 <k0ral> so it's just encapsulating the fact that we always pass a state argument to all functions
12:07:48 <k0ral> right ?
12:08:09 <k0ral> (well, not all functions but all stateful ones)
12:09:07 <c_wraith> the thing that's interesting about State is that values of type State a are actually functions
12:10:24 <ezyang> Suppose I was a newbie, and wanted to learn about the vagaries of pattern matching. What should I read?
12:10:24 <k0ral> can't see why, it's such a mess in my mind
12:10:29 <balor> tg_, my web friends tell me that JQuery is the new kool
12:10:43 <tg_> balor: this seems verymuch better to me
12:10:45 <tg_> but maybe it's just me
12:11:19 <c_wraith> @unmtl State Foo Bar
12:11:19 <lambdabot> Foo -> (Bar, Foo)
12:11:32 <c_wraith> State is just a wrapper around a function
12:11:40 <c_wraith> @unmtl State s a
12:11:40 <lambdabot> s -> (a, s)
12:11:58 <k0ral> well, my way of learning is: learn how to use it, then learn how it works
12:12:03 <c_wraith> ok, then.
12:12:39 <faust45> hi guy's
12:12:52 <tg_> balor: check out those demos
12:13:02 <k0ral> but still I have a question about the underlying work of the State monad
12:13:02 <tg_> balor: very, very slick, and the code to generate them is very simple
12:13:13 <c_wraith> > runState (do { modify (+1); replicateM (modify (*2)) 4; return 17 }) 5
12:13:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:13:14 <lambdabot>         against inferred type ...
12:13:22 <faust45> is it any Rack lib like in Ruby for Web?
12:13:24 * hackagebot attoparsec 0.8.6.1 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.6.1 (BryanOSullivan)
12:13:28 <c_wraith> > runState (do { modify (+1); replicateM 4 (modify (*2)); return 17 }) 5
12:13:29 <lambdabot>   (17,96)
12:13:50 <faust45> is it any Rack lib like in Ruby for Web?
12:13:54 <balor> tg_, wow.  That, and happstack, would be fun
12:13:58 <c_wraith> k0ral:  play with that example for a while
12:14:07 <tg_> balor: yeah, I was thinking this + snap
12:14:15 <k0ral> c_wraith: O_O
12:15:18 <balor> Is it possible for the person who wrote learnyouahaskell.com to be nominated as a saint?
12:15:35 <Botje> BONUS: is right here
12:15:39 <Botje> no sainthood just yet
12:16:03 <Botje> although I hear 1% of the book sales go towards the sainthood ceremony
12:16:25 <tg_> Botje: you are he who wrote it?
12:16:33 <Botje> no, BONUS wrote it
12:16:38 <tg_> oh, ok
12:16:55 <tg_> yeah, I think I should order him a high-classed hooker
12:16:58 <Botje> me, I bought the book for the drawings alone.
12:18:01 <scooty-puff> anyone had any trouble using recursive do, rebindable syntax, and parameterized monads together?
12:18:47 <scooty-puff> it seems to be tightening more than the type system should allow
12:19:07 <scooty-puff> (i can give more background and pastes if any interest)
12:19:38 <scooty-puff> i know that the code otherwise is fine because replace "rec" with mfix $ \... -> do
12:19:44 <scooty-puff> fixes it
12:19:47 <scooty-puff> (or nearly that direct of a replacE)
12:21:23 <NemesisD> anyone have any experience using Network.Curl?
12:22:13 <NemesisD> i've got a question going on haskell beginners but i figured i might get lucky and someone in here might know http://www.haskell.org/pipermail/beginners/2011-May/006957.html
12:24:41 <Botje> NemesisD: you're trying to do a POST with curlGetString?
12:25:19 <NemesisD> Botje: yeah. it isn't as crazy as you may think, the method is a curl opt. the name i think indicates that it gets the response body as a string
12:25:40 <NemesisD> Botje: but i also tried curlPost and curlMultiPost to no effect
12:25:51 <NemesisD> it actually does post, it just not send along the post body
12:27:01 <Botje> NemesisD: I don't think you want curlPostFields
12:27:09 <Botje> you just want to send a chunk of json as body
12:27:33 <NemesisD> Botje: yes, just a json payload is all i need
12:28:48 <NemesisD> Botje: i also tried sending CurlHttpPost [post] where post is an HttpPost
12:28:56 <Botje> ah. i was about to suggest that :)
12:28:58 <NemesisD> http://hackage.haskell.org/packages/archive/curl/1.3.7/doc/html/Network-Curl-Post.html#t:HttpPost
12:29:10 <Botje> (i'm just looking over the docs, i haven't played with Network.Curl)
12:29:17 <NemesisD> that didn't really work but i could have been using it wrong. i have no idea what the postName and showName fields are supposed to mean
12:32:50 <ion> Last night i dreamed walking along a path. I saw the text “class Burn a where burn :: a → a”. Then i saw the text “instance Burn Human” and people in various stages of dying (with a grotesque horror movie -style appearance) were walking on the path. Everyone of them was smoldering and coughing black smoke.
12:33:06 <kputnam> haha
12:33:11 <Botje> NemesisD: hmm. I see one code snippet where they set up the opts as follows:
12:33:18 <Botje> opts = (CurlPostFields [body]) : method_POST
12:33:27 <Botje> where body is a chunk of JSON
12:35:10 <NemesisD> Botje: yeah, in my code sample, CurlPostFields [T.unpack encPay], encPay is JSON encoded as Text
12:35:21 <NemesisD> and then of course unpack transforms it to a string
12:35:37 * FUZxxl asks http://stackoverflow.com/q/5969616/417501
12:35:50 <NemesisD> oh and method_POST is in there too in my code sample
12:36:09 <Botje> weird
12:36:17 <NemesisD> i'd hope order didn't matter...
12:36:26 <Botje> guess we'll have to wait for someone who does know what it's about :)
12:36:47 <NemesisD> darn
12:40:21 <argiopeweb> @src tell
12:40:22 <lambdabot> Source not found. Are you on drugs?
12:40:32 <argiopeweb> :*(
12:40:54 <cheater666> haha l0z3r
12:41:15 <cheater666> j/k. i think you might need to dig deeper for the source of that, though.
12:41:17 <argiopeweb> @src Control.Monad.Writer.tell
12:41:17 <lambdabot> Source not found. :(
12:41:26 * argiopeweb goes to hackage
12:42:51 <FUZxxl> @foo
12:42:52 <lambdabot> Maybe you meant: do faq ft todo yow
12:42:57 <FUZxxl> @faq
12:42:58 <lambdabot> The answer is: Yes! Haskell can do that.
12:43:00 <FUZxxl> @faq
12:43:01 <lambdabot> The answer is: Yes! Haskell can do that.
12:43:06 <FUZxxl> @faq Hello, World!
12:43:07 <lambdabot> The answer is: Yes! Haskell can do that.
12:43:11 <FUZxxl> @help faq
12:43:12 <lambdabot> faq. Answer frequently asked questions about Haskell
12:43:19 <FUZxxl> rofl
12:43:34 <FUZxxl> lambdabot has some quite nice plugins.
12:43:36 <argiopeweb> Seems broad
12:48:47 <mauke> @faq can haskell solve the halting problem?
12:48:47 <lambdabot> The answer is: Yes! Haskell can do that.
12:49:16 <argiopeweb> mauke: That which has been said can not be unsaid.
12:49:20 <argiopeweb> Go: Prove.
12:49:41 <mauke> @faq can haskell take back what I said?
12:49:41 <lambdabot> The answer is: Yes! Haskell can do that.
12:49:51 <argiopeweb> Well played.
12:51:35 <Peaker> argiopeweb, tell is only exported from mtl as a class method -- the instance implementation source is in an internal module
12:51:59 <argiopeweb> Peaker: I noticed. :\ How did it end up being internal?
12:52:12 <Peaker> argiopeweb, to encourage you to use the polymorphic tell
12:52:30 <Peaker> argiopeweb, which will work with the different monads that support MonadWriter
12:52:46 <argiopeweb> Peaker: Ah, I see.
12:53:07 <Peaker> The simple writer monad is represented as:   Monoid w => (w, a)        then:    tell :: w -> (w, ())      tell w = (w, ())
12:53:26 <Peaker> argiopeweb, fmap f (w, x) = (w, f x)
12:53:45 <Peaker> join (w1, (w2, x)) = (w1 `mappend` w2, x)
12:54:01 <Peaker> return x = (mempty, x)
12:54:20 <Peaker> argiopeweb, that's the entire writer monad implementation except for the newtype wrapper stuff
12:54:36 <Peaker> well, and except listen/pass
12:54:56 <argiopeweb> They're less important at the moment.
12:54:57 <argiopeweb> Thanks.
12:56:06 <Peaker> listen :: (w, a) -> (w, (a, w))    I guess that's:  listen (w, x) = (w, (x, w)) ?  I am not sure if these are the semantics of listen, but apparently there is no other choice
12:56:34 <parcs> awesome, freebsd ports now has ghc 7
12:56:57 <argiopeweb> \o/
12:57:03 <Peaker> pass :: (w, (a, w -> w)) -> (w, a)    pass (w, (x, f)) = (f w, x)   I presume
13:00:24 <yitz> @vixen do you have some nice plugins?
13:00:25 <lambdabot> i'd rather be naughty than nice :)
13:01:19 <djahandarie> Haha
13:01:51 <boegel> has anyone here every generated a Hoogle definition file, and try and create a Hoogle DB from it?
13:02:07 <boegel> I'm getting some weird errors, i.e. " TemplateHaskell is not enabled"
13:02:18 <shapr> boegel: -XTemplateHaskell ?
13:02:21 <argiopeweb> boegel: -XTemplateHaskell?
13:02:30 <argiopeweb> shapr: Oi!
13:02:41 <shapr> oi argiopeweb, como vai? falu portugues?
13:03:04 <shapr> eller, talar du svenska?
13:03:12 <argiopeweb> Heh, wrong continent. ;)
13:03:31 <boegel> shapr: tried that, doesn't help
13:03:37 <shapr> weirdness
13:03:58 <yitz> boegel: which one, portugese or swedish?
13:04:18 <boegel> shapr, argiopeweb: but the error message could be misleading, see http://trac.haskell.org/haskell-src-exts/ticket/212 ( think Hoogle uses haskell-src-exts)
13:04:24 <boegel> yitz: uh, whut?
13:04:38 <argiopeweb> lol...
13:10:09 <Kaidelong> why do monads not compose, in general?
13:10:28 <Kaidelong> I mean, they do but
13:10:37 <Kaidelong> the thing you get out of it is an applicative functor, not another monad
13:11:25 <c_wraith> too powerful, probably
13:11:31 <Kaidelong> I'm guessing it relates to not being able to do (m o n(m o n(x)) -> (m o n(x))
13:12:15 <Kaidelong> oh that is probably exactly it, the whole purple behind monad transformers must be allowing you to put something in the form 1010 into the form 1100
13:12:21 <yitz> Kaidelong: right. so it won't compose unless the functors commute with each other.
13:12:34 <Kaidelong> purpose
13:14:33 <boegel> shapr: nvm, stupid mistake by me
13:15:15 <shapr> boegel: We all make those at different times. How's the family dealing with your Haskell addiction? :-)
13:16:33 * hackagebot http-enumerator 0.6.4.3 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.4.3 (MichaelSnoyman)
13:18:55 <argiopeweb> So, if infinite loops == bottom, this implies 'last [1..]' == bottom, right?
13:19:29 <Peaker> argiopeweb, least-defined-element == bottom.   ones = 1:ones   could be said to be an "infinite loop" but it is not bottom
13:19:34 <Peaker> argiopeweb, but last [1..] is indeed bottom
13:19:50 <argiopeweb> Which would imply that strictly evaluating any infinite loop -> bottom.
13:20:07 <djahandarie> Haskell has no loops so I'd avoid using that term
13:20:13 <argiopeweb> Infinite list*
13:20:16 <Peaker> Kaidelong, because you can't build:  join :: m (m (n (n a))) -> m (n a)  from: m (m a) -> m a  and n (n a) -> n a
13:20:17 <boegel> shapr: my wife is... well.. coping :)
13:20:26 <shapr> boegel: Glad to hear that :-)
13:20:31 <mwc> shapr is back?!
13:20:34 <shapr> mwc: shhh!
13:20:35 <boegel> shapr: I'm trying to win the Heritage Health Prize using Haskell :)
13:20:44 <shapr> mwc: wassup?
13:20:48 <shapr> boegel: wow, cool!
13:20:57 <Tyr42> I'm thinking of making kinect bindings in Haskell
13:20:59 <Kaidelong> Peaker: Yeah, realized now, thanks!
13:21:00 <argiopeweb> djahandarie: Totally meant to say list and then mistyped...
13:21:06 <mwc> shapr: smuggling haskell into my PhD in scientific computing
13:21:14 <djahandarie> argiopeweb, fully evaluating an infinite list would result in non-termination, which can be denotationally represented as bottom, yes. :)
13:21:19 <shapr> mwc: awesome!
13:21:38 <argiopeweb> djahandarie: Works for me. Now I just have to find use for this information. :P
13:21:45 <Kaidelong> what I don't understand is why people in that field use things like perl and python
13:22:06 <Kaidelong> the only reason I can envision is that they call foreign implementations that do the numerical stuff efficiently
13:22:24 <Tyr42> NumPy
13:22:36 <Kaidelong> and it's easier to get a physicist or biologist to specify the problem in Perl or Python
13:22:42 <Zao> Kaidelong: It's hard enough to get a scientist to program anything, let alone write C or C++.
13:22:43 <mwc> Kaidelong: that's more or less what I do, except I'm using Haskell to call into OpenCL and MPI
13:22:44 <kputnam> yeah, i think that's it
13:22:45 <Kaidelong> than to make them do it in C
13:22:47 <Peaker> Kaidelong, oops!  I should have written:  m (n (m (n a))) -> m (n a)  there and not what I wrote. What I wrote IS implementable:
13:22:50 <Peaker> @type fmap join . join
13:22:50 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f, Monad f) => f (f (m (m a))) -> f (m a)
13:22:57 <Peaker> @type liftM join . join
13:22:57 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => m1 (m1 (m (m a))) -> m1 (m a)
13:23:11 <Kaidelong> Peaker: I got the spirit of what you said
13:23:24 <argiopeweb> mwc: They're using Fortran and C around here. :\
13:23:35 <mwc> argiopeweb: taht's pretty standard. What Uni?
13:23:48 <argiopeweb> mwc: Embry-Riddle Aeronautical
13:23:55 <mwc> Ah, private
13:24:01 <Kaidelong> argiopeweb: That actually makes sense if you think about it
13:24:14 <argiopeweb> Kaidelong: Oh, I'm aware it makes sense...
13:24:25 <Peaker> Kaidelong, note it's not just a limitation on what you can do in general -- it's a limitation of the actual monad instances. For example:  State s a = s -> (s, a)   is truly not composable with other monads in any way.. It forms Functors/Applicatives but not Monads.   StateT s a = s -> m (s, a)    does compose -- requiring a change inside the structure of the specific instance
13:24:25 <argiopeweb> But Fortran is so evil...
13:24:29 <Zao> I've heard many fine tales of the code that runs on our clusters.
13:25:02 <mwc> argiopeweb: well, it's awesome in that its crappiness for programmers makes it amenable to compiler optimization
13:25:08 <Kaidelong> Peaker: Yeah, hence why you need monad transformers, right?
13:25:14 <Peaker> Kaidelong, Yeah
13:25:18 <argiopeweb> Zao: Probably more than I have. Every time I find somebody who knows about the cluster (which is run by the Engineering Physics dept, I believe), they're talking about how under-utilized it is.
13:25:18 <Kaidelong> being able to transform the 1010 pattern into a 1100 pattern
13:25:19 <mwc> C99 with the restrict keyword should remove most of the remaining Fortran advantages
13:25:28 <Peaker> Kaidelong, Yeah
13:25:35 <argiopeweb> mwc: This is true.
13:25:42 <mwc> I've got my own cluster here, a FirePro V9800
13:25:45 <Kaidelong> wouldn't you be able to make a monad transformer for IO?
13:25:55 <mwc> Kaidelong: like an IOT?
13:25:58 <Kaidelong> yeah
13:26:24 <mwc> runIOT :: IOT m a -> m a doesn't look like a very safe type to me
13:26:25 <argiopeweb> mwc: lol... That brings to mind, I need to learn OpenCL.
13:26:36 <shapr> mwc: So, how would I best use my eight QS20 blades from Haskell?
13:27:24 <mwc> DPH if you're pure or OpenCL if you're pragmatic. A buddy with IBM's Markham compiler group told me that they have OpenCL for POWER/Cell
13:27:30 <aristid> mwc: IOT is not safely possible
13:27:48 <Zao> argiopeweb: A good thing to know is that if your CL compute kernel takes more than five seconds, Windows will reset your GPU driver.
13:27:56 <shapr> mwc: oooh, do want!
13:27:56 <Kaidelong> ah that's true
13:27:58 <mwc> aristid: that was my point :)
13:28:00 <mwc> shapr: http://www.alphaworks.ibm.com/tech/opencl
13:28:00 <Zao> (disablable on development machines, and only happens if you have an attached monitor)
13:28:05 <Kaidelong> I was thinking in terms of unsafeperformio
13:28:06 <Kaidelong> although
13:28:21 <mwc> Zao: seriously?
13:28:25 <argiopeweb> Zao: Funny. Good thing I won't touch Windows. :P
13:28:43 <Peaker> IOT would require a time machine
13:28:45 <Zao> mwc: It only applies if you have a monitor, and it's a Good Thing in my eyes.
13:28:47 <Kaidelong> you could have a safe one that works only with instances of MonadIO, but that would also make such an IOT useless, and I don't think haskell allows you to constrain instances that way anyway
13:29:03 <mwc> it's probably a kernel driver issue where the kernel DRM or whatever windows NT has can't communicate with the card and assumes its locked up
13:29:06 <Zao> mwc: Hard to kill things when your desktop is completely frozen :)
13:29:24 <mwc> Zao: real computers have SSH
13:29:37 <Peaker> IOT Maybe a, for example, should be something like  Maybe (IO a)  -- it should allow performing IO actions before eventually resulting in a Nothing -- but Nothing has no IO actions in it
13:29:39 <Zao> In any way, it doesn't affect headless cards, and it can be overridden via the registry on your dev boxen.
13:29:46 <aristid> Kaidelong: you mean IdentityT? :D
13:29:49 <mwc> Zao: tbh, I'm considering trying to drop my nvidia card into the box and see if Ic an use the V9800 for compute exclusively
13:29:57 <Kaidelong> aristid: I did say it was useless!
13:30:01 <yitz> mwc: even fake computers have vnc server
13:30:03 <aristid> Kaidelong: :)
13:30:17 <argiopeweb> mwc: I'd be interesting in hearing how you're approaching MPI. A decent MPI implementation and convincing the EP dept. to support Haskell is all that's between me and running on 256 processors.
13:30:45 <Kaidelong> I've had good experiences with haskell-mpi so far
13:30:50 <Peaker> mwc, runIOT would have type IOT m a -> m (IO a)   and not   m a   but that too is unsafe
13:31:04 <Kaidelong> just build your haskell program like a C program and use mpiexec like normal
13:31:04 <Peaker> (It takes the "m" out of IO, which can be based on IO results)
13:31:27 <mwc> argiopeweb: that's generally enough, you can wrap the existing MPI functions with ffi
13:31:38 <mwc> then move up a step and use RegionT and the like to manage resources on top of that layer
13:31:42 <mwc> that's what I do with OpeNCL
13:31:54 <Kaidelong> only problem with haskell-mpi seems to be the docs right now are in the source code and not prettily published
13:32:14 <Kaidelong> so I've been having to browse the git to learn it
13:32:34 <argiopeweb> Kaidelong: Meh, I'm pretty much used to that...
13:32:38 <mwc> I havent' written in MPI in a while as I've been on GPU work for the last few months
13:32:53 * Kaidelong hasn't gotten accelerate to work on windows
13:32:58 <mwc> one of these days I'll get somethign that runs on all the GPU machines ni a multi-layer cluster
13:33:17 <mwc> that's why I really want Haskell for the host program, managing that kind of complexity in C++ is awful
13:34:19 <argiopeweb> One of these days I need to figure out how to run CUDA through Haskell to play with the Quadro cards at work...
13:34:24 <argiopeweb> Ah, all the things I could do....
13:34:45 <mwc> argiopeweb: CUDA is terrible, at least the interface that's implemented as a C compiler frontend
13:35:10 <mwc> the underlying asynch api is fairly similar to OpenCL, it'd be the difference between DX and OpenGL
13:35:36 <mwc> at that point it's almost worth using the OpenCL implementation of Nvidia's for the sake of having a consistent and portable C api
13:36:20 <Kaidelong> argiopeweb: accelerate has a CUDA backend
13:36:29 <Kaidelong> I just can't get that backend working on windows
13:37:05 <argiopeweb> mwc: Be that as it may, my superiors who write the orders insist on purchasing dell workstations with 4gb ram (because 32 bit OSs don't support more than that!), and Xeons + Quadro cards (Because they're high performance enterprise hardware!) which then end up being used for real-time display type things 1% of the time and sitting idle 99% of the time.
13:37:31 <argiopeweb> And yeah, the NVIDIA OpenCL may be worth looking into
13:37:39 <argiopeweb> Kaidelong: I know not this accelerate of which you speak.
13:37:47 <Kaidelong> http://hackage.haskell.org/package/accelerate
13:37:58 <Kaidelong> for argiopeweb
13:37:59 <Kaidelong> enjoy!
13:40:22 <argiopeweb> Kaidelong: So, you write Haskell and it writes CUDA. Clever. I'm guessing it's competitive with the other interfaces speed wise?
13:40:41 <Kaidelong> no idea. I think SPJ approved of it
13:40:47 <Kaidelong> so it might be performant
13:40:49 <brbr> does anyone know of a lambda calculus implementation written in haskell?
13:41:16 <sipa> haskell?
13:41:16 <mauke> sounds boring
13:41:34 <argiopeweb> brbr: Haskell can be reduced to a typed lambda calculus and is written in Haskell.
13:41:37 <argiopeweb> :P
13:41:48 <brbr> i mean type checker
13:42:07 <argiopeweb> brbr: GHC has one of those too. :D
13:42:07 <mauke> newtype T = T{ call :: T -> T }
13:42:20 <Kaidelong> which lambda calculus and what for
13:43:27 <argiopeweb> brbr: What Kaidelong said ++ you should be able to implement a simple DSL using mauke's newtype and/or data type declarations (for typedness) which will then type check at compile time.
13:43:53 <brbr> simply typed... i want to try to implement region and capability types for a small, small lang
13:44:57 <brbr> i can represent expressions and types via the 'data' keyword... and then have functions that eval and type check
13:45:13 <brbr> but what are some ways to make use of more advanced haskell features?
13:45:33 <brbr> when implementing a type checker / interp
13:45:43 <argiopeweb> Kaidelong, mwc: Is there a common metric for the point at which it becomes cost-efficient to offload to the GPU, or is it a intuition + guessing thing like 'par'?
13:46:01 <argiopeweb> where guessing + intuition included exhaustive testing.
13:46:43 <sully> brbr: well, you might need to generate fresh variables if you are using explicitly named variables
13:47:11 <sully> brbr: which probably requires putting eval in State
13:47:48 <ccasin> brbr: one really fancy use of haskell's type system is to use a GADT so that you only represent the well-typed terms, instead of writing a separate type checker
13:48:04 <Tyr42> There are a few packages for lambda calc already
13:48:08 <ccasin> brbr: adding region and capability types to such an implementation would be hard, but maybe fun
13:48:09 <Tyr42> let me see if I can find one...
13:48:38 <Tyr42> http://okmij.org/ftp/Computation/lambda-calc.html#lambda-calculator-haskell
13:48:41 <Tyr42> Will that do?
13:49:40 <brbr> Tyr42: probably... im just interested in reading implementations
13:50:20 <Tyr42> brbr:  It's a good one for that.
13:50:48 <Tyr42> brbr:  It's literate Haskell, and it's meant to be read
13:59:30 <jonkri> mm_freak: how do you like acid state so far_
13:59:32 <fenmanm> test
13:59:38 <jonkri> fenmanm: it works :)
14:00:30 <mm_freak> jonkri: i like it, but i haven't done a real project with it yet
14:00:39 <mm_freak> i'm planning to have a first test project
14:00:46 <jonkri> cool
14:01:11 <jonkri> i'm planning to evaluate it in the pontarius media server project :)
14:01:49 <jonkri> just need to finish the next iteration of pontarius xmpp first... but i can't wait :)
14:14:44 <jonkri> i have a "m ()" function in which i need to call a "StateT s m ()" and catch any exceptions. however, try requires the function that catches the exception to be an IO function, and i don't know how to wrap a "StateT s m ()" function into "IO ()". is it possible? i was recommended to do something in terms of "catchST s h = liftIO $ do {state <- catch (runStateT s); ..." the other day but i didn't quite understand it
14:20:26 <Peaker_> jonkri, StateT doesn't have exception catching capabilities (unless you restrict the "m", at least)
14:23:07 <jonkri> that is very unfortunate for me... i've build my hole app main state loop as a StateT function, and i really need that capability
14:23:15 <jonkri> how do people usually deal with that restriction?
14:24:49 <dylukes> inb4 monad transformers
14:25:05 <olsner> jonkri: by adding another monad transformer that adds failure, backtracking, continuations or some other thing that you can do exception-like stuff with
14:26:01 <jonkri> aha :)
14:26:07 <mwc> jonkri: check out monad-catch on hackage, it lets you do catches in your existing StateT s IO
14:27:23 <tomh> hey guys, concept wise, whats better to learn f# or erlang?
14:27:58 <olsner> if you're in #haskell already, I dunno what good F# will do you :P
14:28:12 <olsner> erlang seems to be different enough to be worthwhile
14:28:40 <tomh> I dunno about f# thats why I ask :)
14:28:54 <tomh> maybe there will be many jobs in the future if you have some experience in that
14:29:07 <gwern> > 9 * (2070-2011)
14:29:08 <lambdabot>   531
14:29:21 <monqy> but that's not concept-wise, is it?
14:29:39 <jonkri> tomh: there seems to be an incredible erlang hype these days... i see quite a lot of companies hiring erlang developers
14:29:40 <tomh> monqy: that argument is not concept-wise, thats right
14:30:00 <tomh> yeah, my company has an erlang team as well
14:30:12 <jonkri> personally, i never understood why
14:30:35 <tomh> apperently they used erlang, because someone shouted erlang  ;p
14:31:47 <Kaidelong> olsner: F# sneaks in some haskell languages on you
14:32:00 <tomh> so right now the only thing erlang has build in is hot code swapping right, that haskell doesn't have?
14:32:04 <jonkri> my personal theory is that because ericsson (the swedish telecom company that invented it) used it, it gave the language very good recognition in the industry
14:32:36 <jonkri> tomh: yes, that's my (limited) understanding
14:32:42 <Kaidelong> also F# has OCaml style structural typing, to a degree, an important degree, and that's a noticable thing Haskell records don't do
14:32:56 <tomh> structural typing?
14:33:05 <Kaidelong> static + duck
14:33:13 <dschoepe> Aren't Erlang's concurrency mechanism more mature and sophisticated than Haskell's?
14:33:15 <tomh> ok
14:33:17 <dylukes> tomh: I don't think it's a matter of "built in"
14:33:18 <jonkri> you will spend ages locating type errors :P
14:33:22 <hpc> static+duck = everything is a typeclass?
14:33:25 <dylukes> as much a matter of 'focus'
14:33:36 * djanatyn has been messing around with the haskell mode in emacs
14:33:41 <dylukes> Haskell is more general-purpose than erlang imo
14:33:46 <jonkri> dylukes: most def
14:33:55 <tomh> yeah I think haskell is more general-purpose too
14:33:56 <Kaidelong> hpc: well yeah but implicit typeclasses from record selectors is still useful
14:34:09 <jonkri> erlang seems like a high-concurrency-high-availability only language to me
14:34:14 <tomh> and it has equally good (or better) concurrency features as erlang
14:34:21 <jonkri> it was made for telephone switches, so i guess that's not a surprise
14:34:33 <Kaidelong> erlang by design wasn't meant to be "general purpose"
14:34:43 <Kaidelong> but the same is true of say java, or python, to a large degree
14:34:52 <Kaidelong> so it's sort of irrelevant
14:34:58 <jonkri> Kaidelong: java is not general purpose?
14:35:29 <jonkri> i mean, was not meant to be
14:35:40 <Peaker> Java was meant to bring GC to the masses of medicore programmers. it was not allowed to have anything more interesting than that that is useful for general purpose programming
14:35:41 <Kaidelong> jonkri: It was meant to allow you to write portable applications that can communicate with each other even on wildly different implementations
14:36:09 <DasIch_> Kaidelong: how is python not general purpose?
14:36:45 <Kaidelong> DasIch_, I meant it as a counterexample to looking at some particular design choice and saying "it's not general purpose"
14:36:48 <jonkri> i went from erlang to haskell, and i very much doubt that i will ever use it again
14:37:01 <jonkri> even if i implemented phone switch software, i would try to build it with haskell first :P
14:37:06 <tomh> hehe
14:37:19 <danharaj> "general purpose" is not a useful term anyway.
14:37:20 <Kaidelong> jonkri: Well they started with prolog didn't they? and built erlang off of it
14:37:27 <jonkri> but then again, i'm much of a newbie in both languages, so what do i know? :)
14:37:31 <tomh> I wonder what it would take to bring the fault tolerence in haskell on par with that of erlang
14:37:49 <tomh> but I think its a specific feature of a erlang lib or something
14:37:57 <tomh> but im erlang noob :)
14:38:00 <tomh> so I dont know
14:38:04 <Kaidelong> tomh: []? Maybe? Erlang as a haskell data type?
14:38:28 <dylukes> Erlang DSL in Haskell
14:38:29 <dylukes> haha
14:38:31 <dylukes> that'd be amusing
14:38:36 <dylukes> Maybe quasi quoting with TH
14:38:40 * Kaidelong pretty sure this has been done
14:38:47 <Kaidelong> not with TH/quasiquotes
14:38:52 <tomh> Kaidelong: well maybe works but.. I mean the hot code swapping and dieing process stuff
14:38:56 <dylukes> sure enough
14:38:56 <dylukes> http://hackage.haskell.org/trac/ghc/wiki/ErlangInHaskell
14:40:14 <ksf> urm.
14:40:48 <ksf> there I was, being happy that someone already made a list of haskell issues on nixos, only to later find the date of the message, which is three years ago
14:42:13 <flinstone> Hi anybody
14:42:16 <Will|> I seem to get lots of linker errors when trying to compile pretty simple stuff on my OSX box, `ld: warning: text reloc in _…"
14:42:20 <Will|> any ideas what's going on?
14:42:44 <flinstone> Who use haskell in their business?
14:42:50 <Will|> ah, nevermind, seems to be #5128 - http://hackage.haskell.org/trac/ghc/ticket/5128
14:43:23 <flinstone> or who know any computer science area(where is recommended to use haskell)
14:44:26 <jonkri> flinstone, tomh: you know each other? ;)
14:44:30 <Evious> flinstone, Galois uses primarily Haskell
14:44:32 <tomh> no
14:44:36 <jonkri> ok nvm :)
14:44:37 <tomh> eh maybe
14:44:43 <flinstone> Evious, yes i know about Galois
14:44:45 <medfly> http://www.haskell.org/haskellwiki/Haskell_in_industry
14:44:51 <tomh> no I dont know him
14:44:59 <tomh> that page is super outdated btw :P
14:45:13 <dsouza> howdy, hello everyone!
14:45:16 <flinstone> medfly, i saw this link, looks like machine learning not popular between haskell developers
14:45:21 <Evious> I use it for hard utilities (source code analysis, quickcheck-based testing) but not production :)
14:45:47 <medfly> flinstone: I doubt you can conclude whether something is popular among haskell develoeprs from this link
14:45:58 <dsouza> this week I saw this: http://static.cpantesters.org/, and was wondering if hackage has something similar. Does it?
14:46:17 <flinstone> medfly, yes ofcourse
14:46:33 <flinstone> what about artifical intelligence with haskell?
14:46:36 <dsouza> for those who don't want to visit the site for whenever reason, it takes a package from cpan and test it in different plataforms, reporting the status of the tests on each plataform.
14:46:49 <flinstone> hakell libraries for it are not mature
14:46:59 <dsouza> I found it great, and was wondering if we have something similar
14:47:17 <tomh> you can easily do artificial intelligence in haskell
14:47:44 <flinstone> tomh, ok which library can y recommend?
14:47:56 <dsouza> flinstone: as far as I know other problem is the fact that cabal doesn't make it easier to include unit testing along with the code, or at least it didn't when I used it
14:48:00 <tomh> well you could write it yourself, what do you need?
14:48:25 <flinstone> tomh, time and money :-)
14:48:29 <tomh> lol
14:49:45 <jonkri> the xmpp library that i'm developing "owns" the main thread and interacts with the xmpp client through callbacks. spontaneously, which option do you think is preferable: to allow the xmpp client callbacks to use their own monad, or force the client xmpp code to run in IO to enable it to catch errors from the xmpp library?
14:49:46 <Evious> There are some okay bindings to linear algebra and math libs. That + Haskell == AI code, no?
14:50:18 <jonkri> there will soon be a super nice xmpp library available :)
14:50:20 <tomh> AI is a big area
14:50:39 <tomh> from neural networks to path finding algorithms
14:50:52 <tomh> basically you can call all computer programs AI
14:51:13 <dsouza> flinstone: regarding maturity, at least the haskell plataform libraries should be mature enough, shouldn't they?
14:51:18 <flinstone> tomh, what is thenextbigthning in AI? svm?
14:51:26 <dsouza> well, anyways, I just found it a good idea :-)
14:51:36 <tomh> flinstone: I would call that machine learning
14:51:47 <flinstone> dsouza, we tlak about AI, machine learning libraries
14:52:01 <dsouza> oh, sorry about that :-)
14:52:51 <flinstone> tomh, so you think that machine learning is the next big thinq?
14:53:01 <tomh> next?
14:53:04 <tomh> no its already big
14:53:17 <flinstone> tomh, do y know weka?
14:53:49 <flinstone> i ask because haskell do not have binding to it,but it is famouse ml library
14:54:16 <bos> hey kids: http://www.serpentine.com.nyud.net/blog/2011/05/11/exciting-teaching-news/
14:54:21 <tomh> I know weka yeah
14:54:47 <flinstone> and also there are no machine laerning partision in hackage
14:55:17 <flinstone> what do y use for machine learning?
14:57:10 * hackagebot pandoc-types 1.8.0.2 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.8.0.2 (JohnMacFarlane)
15:04:31 <fragamus> I am trying to write the a line of code that implements this type signature:
15:04:32 <fragamus> type Situation = (Int,Int)
15:04:32 <fragamus> type MyMonad  = ListT (State Situation)
15:04:34 <fragamus> schmeal :: MyMonad Int
15:04:56 <mauke> ListT? isn't that the broken one?
15:05:10 <fragamus> i need an example of a correctly written schmeal
15:05:11 <Peaker> fragamus, where are you taking ListT from?
15:05:11 <hpc> i believe so
15:05:19 <mauke> schmeal = return 0
15:05:20 <fragamus> The non-broken
15:05:20 <Peaker> There's the List package which has a proper ListT
15:05:30 <fragamus> i know
15:05:35 <Peaker> @hackage List
15:05:35 <lambdabot> http://hackage.haskell.org/package/List
15:05:36 <fragamus> i have it
15:07:26 <fragamus> i need my schmeal function to take a state and turn it into a list of states
15:07:40 <mauke> why?
15:07:53 <fragamus> combinatoric application
15:08:31 <Peaker> is there anything like:  class CategoryFunctor cat f where cfmap :: cat b c -> f b -> f c   in any library?
15:08:50 <Peaker> (and if so, does it generalize over fmap/(.) nicely?)
15:09:03 <scree> fragamus: so, fst <$> get is a less trivial example
15:09:14 <Peaker> @type fst <$> get
15:09:15 <lambdabot> forall a b (f :: * -> *). (MonadState (a, b) f, Functor f) => f a
15:09:18 <Peaker> @type gets fst
15:09:18 <scree> fragamus: but still not quite sure what you have in mind
15:09:18 <lambdabot> forall a b (m :: * -> *). (MonadState (a, b) m) => m a
15:09:25 <stepkut> does the GHC rts provide any secret uptime value ?
15:09:37 <fragamus> ok.. let me explain further
15:09:42 <Peaker> given the ease of  (f<$>get) I wonder why gets exists
15:10:47 <hpc> Peaker: order perhaps
15:10:57 <Peaker> what order?
15:11:05 <hpc> instead of saying (\x -> biglongthingthatgoesandgoes) <$> get
15:11:16 <hpc> gets $ \x -> biglongthingthatgoesandgoes
15:12:03 <stepkut> Peaker: gets is a lot older than <$>
15:12:11 <Peaker> stepkut, older than fmap?
15:12:19 <stepkut> Peaker: no
15:12:20 <Peaker> f `fmap` ...
15:12:33 <hpc> i wouldn't ever encourage backtick notation
15:12:38 <fragamus> I have an application that is generating combinations based on some complex rules.  Each State in my list of states splits into multiple other states
15:12:39 <Peaker> gets = (`fmap` get)  -- worth the saving?
15:12:42 <hpc> i assume they agree
15:12:56 <hpc> @src gets
15:12:57 <lambdabot> Source not found. Are you on drugs?
15:12:59 <fragamus> Here's the thingy again
15:13:00 <fragamus> type Situation = (Int, [Int])
15:13:00 <fragamus> type MyMonad  = ListT (State Situation)
15:13:00 <fragamus> schmeal :: MyMonad Int
15:13:12 <Saizan> gets also shows off a pretty common idiom
15:13:12 <stepkut> Peaker: right. so you have, 'gets f' vs 'fmap f get'. Someone thought it was worthwhile.. but I have never actually used it myself
15:13:36 <stepkut> Peaker: especially now that we do have <$>
15:13:38 <Peaker> Saizan, what idiom?
15:13:51 <stepkut> Peaker: I suspect gets may never have existed if <$> came first
15:13:55 <hpc> i personally think puts is more useful than gets
15:14:07 <hpc> in terms of how the idiom gets used
15:14:08 <Saizan> Peaker: of having accessors for subparts of your state type
15:14:38 <fragamus> i need to write schmeal so that it takes Situation, and splits it into many more situations
15:14:59 <fragamus> each time it will add an integer on the end of the list in the tuple
15:15:27 <fragamus> so the split results in many variations on the original state
15:15:56 <fragamus> each with a different number added on the end of the list in the tuple
15:18:44 <fragamus> say for example i wanted schmeal to generate ten combinations by producing ten copies of the State each with a different value from 0-9 appended to the list in the tuple
15:18:53 <mm_freak> jonkri: i think i have found the best solution for me
15:19:05 <jonkri> ok? :)
15:19:10 <mm_freak> 'acid-state' for complicated data, which doesn't change often
15:19:16 <mm_freak> 'persistent' for everything else
15:19:42 <jonkri> why?
15:20:04 <mm_freak> because acid-state can handle complicated data much better, while persistent is fast with table-like data
15:20:22 <jonkri> aha ok :)
15:20:32 <jonkri> thanks for letting me know
15:21:03 <jonkri> hmm... the (extendable) data for pontarius media server is very complicated. using table-like structures would be impossible
15:21:32 <mm_freak> it's always possible, but not always easy and performant
15:21:54 <mm_freak> unfortunately acid-state doesn't fit into yesod's persistence class, so i will have to do some hand-crafting, but it's not much
15:22:10 <Peaker> fragamus, why not first write it purely, and see how it turns out? What types of functions do you get?
15:22:25 <Peaker> fragamus, do you have lots of  Situation -> [Situation]  functions?
15:22:27 <jonkri> i need to store xml structures and stuff like that
15:22:37 <jonkri> aha ok
15:23:04 <mm_freak> jonkri: that's well possible with a relational model, but might get complicated
15:23:07 <stepkut> mm_freak: maybe acid-state just needs a better table type to use with it ?
15:23:17 <mm_freak> stepkut: table type?
15:23:21 <fragamus> yes peaker i do
15:23:26 <mm_freak> stepkut: acid-state is not relational
15:23:47 <Lemmih> mm_freak: It could be with the right data type.
15:23:49 <fragamus> i need monads real bad peaker
15:24:15 <stepkut> mm_freak: right. But it could be if you put some relational types in your acid-state
15:24:23 <fragamus> help me peaker  youre my only hope
15:24:25 <mm_freak> Lemmih: you're the author, right?
15:24:34 <Lemmih> mm_freak: Yep.
15:25:27 <mm_freak> Lemmih: i really like the idea of acid-state, but likely i'd need to change it for me to be really useful
15:25:39 <Lemmih> mm_freak: Change it how?
15:26:02 <mm_freak> Lemmih: for example get rid of the MTL dependency
15:26:30 <fragamus> if I just had a single example of how to write a Situation -> [Situation] using ListT State I could do it all
15:27:00 <Peaker> fragamus, ListT is still slightly confusing to me :-)  IIRC it's conceptually a flat list with effects around each cons.  Does this structure match your use case?  ListT (State Situation)   is a list where computing the next element may modify the Situation state..
15:27:42 <fragamus> oh i see
15:27:42 <Saizan> fragamus: are you sure you want ListT (State s) and not StateT s [] ?
15:27:42 <Peaker> fragamus, I am not sure   ListT (State Situation)   does not seem appropriate for a tree of state splits, but I am not entirely sure
15:27:44 <Lemmih> mm_freak: Oh? What's wrong with mtl?
15:27:55 <mm_freak> Lemmih: i'd rather write own versions of the Update and Query monads with instances for 'transformers'
15:28:09 <jmcarthur> mm_freak: mtl uses transformers now
15:28:36 <fragamus> yes i have a tree of state splits
15:28:51 <Peaker> Yes, I think Saizan is right and it's StateT s [] that you're after
15:28:53 <mm_freak> Lemmih: i don't know exactly why, but if you run "forever (return ())" in MTL's Reader or State, you get a memory leak
15:28:57 <mm_freak> or at least i do
15:29:00 <jmcarthur> or maybe i misunderstand what mm_freak wants
15:29:20 <mm_freak> i noticed that when i tried to run a really long Update computation
15:29:25 <fragamus> I do not need to modify the old state, only make new ones based on the old
15:29:48 <mm_freak> Lemmih: also with a custom Update monad you can easily implement rollback
15:29:56 <mm_freak> just use a CPS-transformed State monad
15:30:22 <fragamus> how can i do that paste thingy
15:30:42 <Peaker> fragamus, the State monad always expresses that...  StateT s []  a   will give you:  s -> [(s, a)]  which seems *exactly* what you need
15:30:44 <fragamus> I wrote my own monad that does what I want
15:30:50 <Lemmih> mm_freak: There's no such thing as a rollback in acid-state.
15:30:55 <aristid> mm_freak: transformers and mtl use the exact same transformers, as mtl just reexport transformers' code, and adds its classes and instances
15:31:01 <Peaker> fragamus, http://hpaste.org/
15:31:19 <mm_freak> Lemmih: why not?
15:32:14 <Lemmih> mm_freak: It doesn't fit in with the transaction model.
15:32:50 <fragamus> http://hpaste.org/46615/fragamus_monad
15:33:00 <mm_freak> Lemmih: i don't understand…  as long as you're in the Update computation it's just a pure State computation, isn't it?
15:33:08 <fragamus> how do i scroll back up
15:33:52 <Lemmih> mm_freak: Yes. I probably don't understand what you mean by rollback.
15:34:09 <fragamus> irc key to scroll back
15:34:12 <eikke> in quickcheck, is there a better way than using prop_X (NonEmpty l) (Positive o) = o < length l ==> ...?
15:34:14 <fragamus> im a newb
15:34:27 <mm_freak> Lemmih: have a thread of state transformations, which can be rolled back easily
15:34:28 <Lemmih> fragamus: It is page up for me.
15:34:39 <eikke> quickcheck gives up after a couple of runs (becuase of the o limitation i guess which cant be met)
15:34:43 <jmcarthur> fragamus: it depends on your client
15:34:53 <Peaker> fragamus, SituationList s a = SL (s -> [(s,a)])    that is   StateT s [] a    and not   ListT (State s) a
15:34:54 <fragamus> command line
15:35:02 <jmcarthur> that is not a client
15:35:09 <jmcarthur> irssi? weechat?
15:35:14 <fragamus> thanks peaker
15:35:24 <fragamus> irssi
15:35:27 <jmcarthur> probably pageup
15:35:38 <Lemmih> mm_freak: I still don't understand. Isn't rollback as simple as using get and put?
15:35:51 <ddarius> jmcarthur: Perhaps he cats a tun device file.
15:36:12 <jmcarthur> then he's more hardcore than i am
15:36:49 <Lemmih> mm_freak: Also, updates block other updates so I hadn't expected them to be long-running.
15:37:50 <stepkut> Lemmih: would it be easy to implement an 'abort' function that aborts the current update event and returns the state to whatever it was at the beginning of the event? (Based on my knowledge of acid-state, I think it should be)
15:38:10 <Lemmih> stepkut: Sure, just throw an exception.
15:38:29 <Peaker> fragamus, so you get the monad instance for free.. if you "put", you will get a new state in the current branch.  the StateT constructor is exposed so you can take your  s -> [(a, s)] values and put them in it
15:39:25 <Peaker> fragamus, you can use:   x <- lift [1,2,3]   to branch on values without branching on state   or   x <- StateT situationToSituationsAndValues   to branch on new states and values
15:39:28 <stepkut> Lemmih: right
15:39:41 <ddarius> eikke: You can make a smarter generator.
15:39:58 <stepkut> Lemmih: maybe we should have a simple rollback / abort function ? Just to make it obvious?
15:40:20 <ddarius> mzero?
15:40:22 <Peaker> fragamus, I must admit I've played with it a bit in the past and I *still* find the list/listT monads slightly confusing when composed with other monads
15:41:06 <eikke> ddarius: agree. kinda odd it doesnt exist though, looks like a rather normal requirement to me?
15:41:10 <mm_freak> Lemmih: when i add a few hundred thousand entries to a database in one transaction per entry, then it takes forever
15:41:34 <lpsmith> stepkut: did you ever get very far implementing KD trees for happstack-state?
15:41:36 <jmcarthur> ListT in mtl isn't even always a monad :(
15:41:38 <Lemmih> mm_freak: Oh, it really shouldn't. Could you send me a test case?
15:41:43 <stepkut> Lemmih: in SQL you do, 'begin transaction' to start a transaction, and then 'commit' at the end to make the effects actually happen. But if you change your mind halfway through, you can call, 'rollback'. In acid-state, begin-transaction and commit are implicit. But make 'rollback' explicit might be  nice
15:42:26 <mm_freak> Lemmih: just have a Map and add entries to it
15:42:37 <stepkut> lpsmith: there is a partial implementation, with ideas on how to progress. Hoping to make more progress on it soon.
15:42:43 <mm_freak> Lemmih: also i totally understand that it has to be slow, because it's the same with sqlite, unless you use a transaction
15:42:48 <Peaker> hmm.. if acid-state lets you treat the Update type as a MonadState instance,  and you do something like the HelloDatabase example:   modify (newItem:)  -- does this not result in a large serialization of a new big list?
15:43:04 <lpsmith> stepkut: KD trees would be awesome :)
15:43:17 <stepkut> lpsmith: indeed :)
15:43:19 <Lemmih> mm_freak: Oh, right. Yes. You're probably waiting for each transaction to finish before starting the next.
15:43:21 <jmcarthur> is acid-state formerly happstack-state?
15:43:25 <Peaker> how does acid-state serialize stuff?
15:43:31 <stepkut> lpsmith: for some things anyway :)
15:43:32 <mm_freak> Lemmih: yes
15:44:03 <jmcarthur> Peaker: if acid-state works the way happstack-state did then it stores... essentially a thunk
15:44:08 <lpsmith> of course,  but it would greatly increase the applicability of happstack-state,  or acid state....
15:44:27 <Lemmih> mm_freak: Yes, you don't want that. Adding them in parallel should be hundreds of thousands of times faster.
15:44:52 <stepkut> Peaker: only the name of the update event and the arguments to that event are serialized. The modifications to the state itself are not serialized.
15:45:05 <jmcarthur> well, not until you force it to be
15:45:28 * hackagebot yesod-goodies 0.0.4.1 - A collection of various small helpers useful in any yesod application.  http://hackage.haskell.org/package/yesod-goodies-0.0.4.1 (PatrickBrisbin)
15:47:00 <Lemmih> stepkut: I'm not 100% sure how the abort thingy should behave. Should it be catchable in the transaction? Should it be ignored by the caller or should the exception be propagated?
15:47:08 <Peaker> stepkut, but in the HelloDatabase example, the argument is a new list, potentially huge
15:47:52 <jmcarthur> Peaker: that isn't how you would ideally define the event
15:48:05 <Peaker> so the HelloDatabase example is actually inefficient?
15:48:06 <jmcarthur> Peaker: you would define a "add item" event, which would only have the new item as an argument
15:48:10 <stepkut> Peaker: the argument to AddMessage ?
15:48:42 <Lemmih> Peaker: A partially applied function cannot be serialized.
15:48:42 <Peaker> stepkut, Oh.. I see
15:49:12 <Peaker> and when you checkpoint -- it would apply all the messages to a real state and then serialize that?
15:49:13 <Lemmih> Peaker: You'd use, as stepkut said, AddMessage and not (newItem:).
15:49:17 <jmcarthur> yes
15:49:24 <Peaker> ah, interesting
15:49:57 <Peaker> does a checkpoint discard pre-checkpoint logs?
15:50:06 <Peaker> or is it in effect fully versioned?
15:50:31 <Lemmih> mm_freak: 'forever (return ()' doesn't leak on my box. I'd be very interested in a test case.
15:50:32 * jmcarthur doesn't remember
15:50:33 <stepkut> Peaker: when you do a checkpoint, the entire state will be serialized to disk.
15:50:48 <Peaker> how well does it perform/scale?
15:51:10 <jmcarthur> Peaker: actually, checkpoint doesn't have to reapply everything. the fully applied state is already in memory
15:51:16 <stepkut> Peaker: but it does not wait until you call 'checkpoint' to actually modify the in-memory state
15:51:20 <Peaker> can multiple frontend "nodes" share a single acid state?
15:52:00 <Lemmih> Peaker: Not yet but that functionality is coming. Acid-state was designed to support exactly that.
15:52:52 <mm_freak> Lemmih: i will prepare a test case for you, but not right now
15:52:54 <Peaker> Hmm.. does the serialization used here allow lazy loading of the state via a mechanism like mmap?  or does starting up a node require loading the entire state into RAM?
15:53:31 <int80_h> does someone have a link to the code examples referenced in the PDF version of All About Monads?
15:53:35 <mm_freak> Lemmih: btw, once i create a checkpoint, can i delete the history before that?  i notice that the transaction logs are kept
15:53:36 <Peaker> it seems nice in exposing the cost model
15:53:49 <Lemmih> Peaker: The entire state is kept in memory.
15:53:52 <stepkut> Peaker: historically speaking, happstack-state has had experimental support for sharing across nodes implemented two different ways.
15:54:10 <Lemmih> Peaker: Both replication and partitioning was implemented as proof-of-concepts in happs-state.
15:54:38 <Lemmih> Peaker: It was never robust enough for general use, though. Acid-state will change that.
15:55:22 <Lemmih> mm_freak: Yes, you can. There will soon be a tool for doing that safely.
15:56:00 <Peaker> "A simple data store that holds an integer which is incremented by an update event was able to achieve 13,300 updates per second." <-- this is because every change to the integer is guaranteed to have happened, right?  Mongodb can deliver more performance by not giving acknowledges by default
15:56:11 <Lemmih> mm_freak: You can do it by hand as long as you don't delete journal files younger than the latest checkpoint.
15:56:44 <Peaker> imagining an int in an mmaped file, updating it in there would be far faster than 13K/sec
15:57:23 <Lemmih> Peaker: No, that's just because cereal is /very/ slow. Replaying transactions from the log runs at ~200K/s.
15:58:13 <Peaker> Lemmih, why not avoid durability when you can go without, as in Mongodb? Only guarantee serialization of messages by the time a special waiter action is called, perhaps
15:58:14 <Lemmih> Peaker: Once the performance bug has been fixed in cereal, that particular example should run at about 100K/s to 200K/s.
15:58:39 <Peaker> ah, cool
15:58:44 <Lemmih> Peaker: That is exactly how it works.
15:58:57 <Lemmih> Peaker: Or almost exactly.
16:00:03 <Lemmih> Internally it is how it works. But exposing that could cause temporary inconsistencies.
16:00:44 <Peaker> btw: If instead of forcing the entire value to be in memory, btw, you just put it in mmap'd memory, and then "checkpoint" would be a sync on that mmap, and switching to work on another mmap'd memory.. the advantages would be: allow larger than ram values with potentially reasonable performance,  allow starting up without actually deserializing anything (though it would place a constraint on the state type that it can sit safely in an mm
16:00:44 <Peaker> ap)
16:02:03 <Lemmih> Peaker: You can already use structures backed by mmap with acid-state.
16:02:22 <Peaker> Lemmih, exactly for the cases where you want something larger than RAM?
16:03:30 <parcs> silly question: why don't any of the examples of acid-state use newtypes?
16:03:37 <Lemmih> Peaker: Pretty much. Given GHC's memory model, you don't need a lot of data before you exceed reasonable memory limits.
16:03:56 <Peaker> Lemmih, how does Yesod's persistent compare with acid-state? Are they even solving a similar problem?
16:04:11 <Essial> Heya guys.. I'm on day 1 of learning haskell and I've got a lot of stuff figured out already, but one thing I simply cannot figure out is how to output the current date as a string to a text file
16:04:39 <Peaker> Essial, did you learn how to execute actions in your 'main' action?
16:04:44 <stepcut> Essial: writeFile "thedata.txt" =<< show <$> getCurrentTime, perhaps ?
16:04:59 <hpc> stepcut: spoilers!
16:05:01 <Lemmih> parcs: I pretty much just copy&pasted those examples from a base case. Using newtypes is 100% supported.
16:05:04 <stepcut> hpc: :)
16:05:04 <Essial> well i don't really want to know how to do it, more about what i'm doing wrong :)
16:05:16 <Essial> logIt (s) = appendFile "log.txt" (concat [" - ", s, "\n"])
16:05:38 <Essial> is what I came up with, but I want the time before the " - "... and yes I created a function to 'serialize' a data structure to a pretty string
16:05:48 <Essial> and that works, i was proud of myself as i didn't copy a tut to do it :D
16:06:20 <Essial> but I'm having issues with Char and [char] or io () type casting I guess, so I'm missing something fundamental, I spent 3 hours trying to figure it out
16:06:39 <hpc> Essial: there is no such thing as type casting in haskell
16:06:48 <Essial> yeah hence my severe confusion
16:06:53 <hpc> (just to nitpick a bit and push you towards the right terminology)
16:06:54 <Lemmih> Peaker: The problems they solve are only somewhat similar. Acid-state tries hard to make things convenient and safe by keeping data in Haskell land.
16:07:07 <hpc> Essial: do you understand do notation?
16:07:09 <int80_h> anyone have a link to the html version of All About Monads?
16:07:25 <Essial> I believe so, do kinda makes it more like a set of actions (a functional block) instead of a single line
16:07:42 <hpc> close enough for day 1 ;)
16:07:47 <hpc> so, what you want is
16:07:52 <mm_freak> hpc: unsafeCoerce =)
16:07:55 <Essial> literally day one, I downloaded the compiler 6 hours ago :p
16:07:56 <Lemmih> Peaker: Once you use an SQL backend, you pretty much give up all type-safety. (And in most SQL databases, you also give up acid guarantees.)
16:08:09 <hpc> logit s = do time <- something; appendFile "log.txt" (concat [time, " - ", s, "\n"])
16:08:37 <Essial> why do I have to assign time to the time object?
16:08:38 <hpc> Essial: getCurrentTime will give you the time as a UTCTime, but it's inside IO
16:08:49 <Essial> i'm using getzonedTime
16:08:50 <hpc> :t getCurrentTime
16:08:51 <lambdabot> Not in scope: `getCurrentTime'
16:08:52 <Peaker> Lemmih, ah, persistent went the SQL way?
16:08:56 <Essial> yeah that's the problem
16:09:04 <hpc> what's the type of getZonedTime?
16:09:13 <mm_freak> Essial: variable, not object…  there is no OOP in haskell…  and you don't have to, but it's more convenient in this case
16:09:13 <Essial> I know it complains about an IO() type
16:09:49 <Lemmih> Peaker: Yeah, except for the mongoDB backend which is even more unsafe (:
16:09:52 <Essial> I want to know what i'm missing because I totally don't understand why i can't just add getZonedTime to the list by itself (the IO makes it not work)
16:09:55 <mm_freak> Essial: do you want to just get the time into the log, or do you also want a specific formatting?
16:09:56 <Peaker> Lemmih, I wrote a little front-end on top of BerkeleyDB that gives Binary-class based serialization so instead of ByteString -> ByteString   it looks like  Binary a => ByteString -> a,  and a Transaction monad that can get/set values by their ByteString key
16:10:11 <Essial> Well the technical challenge is to convert a datetime to a string
16:10:19 <Essial> or a character array in hakell terms iirc
16:10:27 <Peaker> Essial, What's the type of getZonedTime?
16:10:36 <hpc> Essial: well first off, let's explain why it isn't working
16:10:38 <mm_freak> Essial: because haskell is referentially transparent, which means that getZonedTime cannot be normal function/value
16:10:54 <hpc> Essial: to do things to the real world in haskell, you have to use IO
16:11:03 <hpc> Essial: to get a line of input is getLine :: IO String
16:11:07 <Essial> I ~kinda~ understand that
16:11:10 <mm_freak> Essial: converting a time, which you already have, to a string is not a challenge
16:11:14 <mm_freak> you can use the 'show' function
16:11:14 <hpc> Essial: to get the current time, you need to ask the real world what the time is
16:11:16 <Essial> it's like a data port too and from the 'program'
16:11:24 <Essial> I tried show, and fmap
16:11:28 <mm_freak> Essial: the challenge is to get the time in the first place =)
16:11:47 <hpc> Essial: so before you can do anything with the time, you need to play by the rules of IO
16:11:54 <Essial> so basically getzonedTime is not the droids I'm looking for
16:12:01 <mm_freak> yes, it is
16:12:11 <hpc> Essial: http://haskell.org/hoogle/?hoogle=getzonedtime
16:12:13 <Essial> well I'm looking at it as a function or a property
16:12:16 <hpc> er, that wasn't a ping at you
16:12:17 <mm_freak> but don't confuse ZonedTime with IO ZonedTime
16:12:20 <mm_freak> the former is a time value
16:12:22 <Lemmih> Peaker: Right. I really like BerkeleyDB but it is hard to get good performance out of it when you can't do destructive updates. I discovered that when I wrote the 'berkeleydb' package.
16:12:29 <mm_freak> the latter is a real world computation to get it
16:12:46 <mm_freak> now you want a ZonedTime (which you can, for example, pass to 'show')
16:12:49 <mm_freak> but you have an IO ZonedTime
16:12:58 <mm_freak> now look at the (>>=) combinator
16:12:58 <Essial> so it's kinda like a handle of sorts?
16:13:12 <Peaker> Lemmih, why can't you do destructive updates? Atomic transactions?
16:13:27 <mm_freak> you can understand IO Something is a computation, which computes a value of type Something, notably a real-world computation
16:13:29 <Essial> I don't understand taht symbol yet
16:13:32 <mm_freak> i.e. it can have side effects
16:13:39 <Essial> Ah, so it must be assigned then, yes?
16:13:44 <hpc> Essial: the most accurate metaphor is "IO Foo is the type of computations that produce a Foo value"
16:13:50 <mm_freak> it must be combined in a certain way
16:13:54 <mm_freak> :t (>>=)
16:13:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:13:59 <mm_freak> in this case m = IO
16:13:59 <hpc> so getZonedTime doesn't represent the current time, but a computation that gets it for you
16:14:08 <mm_freak> IO ZonedTime -> (ZonedTime -> IO b) -> IO b
16:14:28 <Essial> yeah, i'm still having problems seeing how that's different from a 'reference' to a function
16:14:33 <Essial> like myfunc = otherfunc
16:14:38 <mm_freak> as you see (>>=) takes to parameters:  the first (left) parameter is your getZonedTime
16:14:54 <mm_freak> the right parameter is a function, which takes the result of the computation, which is the left parameter
16:14:57 <Lemmih> Peaker: Checkpoints may not block transactions. This works fine as long as you don't do destructive updates on the state.
16:15:02 <mm_freak> and is itself an IO computation
16:15:08 <Essial> what is >>= specifically for
16:15:13 <Essial> or link me :p
16:15:19 <mm_freak> i won't tell you that
16:15:24 <Lemmih> Peaker: I found that implementing Data.Map on top of an mmap allocated slob was faster than using BerkeleyDB.
16:15:25 <danharaj> :t print
16:15:26 <lambdabot> forall a. (Show a) => a -> IO ()
16:15:27 <Peaker> Essial, IO a   is basically a "procedure" that specifies what things to execute in order to yield a value of type "a".  You can't take the "a" outside of the procedure without executing it, and you can't execute procedures (only the magical runtime can, and it executes "main"). What you can do is take your function (a -> b) or (a -> IO b) and "lift" it inside IO
16:15:46 <mm_freak> but in you specific case it's the combinator, which enables you to "extract" the ZonedTime
16:15:57 <danharaj> In the context of the IO monad, >>= let's an IO action that depends on a parameter to depend on the result of a previously executed IO action.
16:16:14 <mm_freak> example:
16:16:19 <mm_freak> getZonedTime >>= print
16:16:22 <Peaker> Lemmih, wow -- consistency wise it sounds dangerous.. mmap gives no order guarantees or anything
16:16:31 <danharaj> >>= is just sequencing
16:16:35 <danharaj> (in the IO monad)
16:16:49 <danharaj> in general it is some sort of dependency in your computation.
16:16:56 <Peaker> it is better to think of >>= as taking a function inside the IO than to think of it as taking the value "outside" to the function..
16:16:59 <mm_freak> danharaj: don't do that
16:17:03 <Lemmih> Peaker: mmap isn't used for correctness.
16:17:07 <mm_freak> let him focus on IO for now
16:17:23 <Essial> yeah too much text :p
16:17:27 <hpc> man, there's so many people trying to help that even /i/ am confused
16:17:27 <Essial> let me try a few things hold on
16:17:46 <danharaj> Essial: try getting a string as input and then printing it out again
16:17:48 <Essial> I know 26 programming languages, not a damn one functional so I'm walking on cruches here :)
16:17:53 <Peaker> Lemmih, for the correctness case, you can rebuild the entire Map from the log?  And for the common case, you can guarantee the mmap syncs successfully?
16:17:55 <Essial> i did that a while back :p
16:17:58 <danharaj> That's essentially what >>= let's you do.
16:18:20 <Peaker> Essial, Do you know callbacks?
16:18:30 <Essial> not yet
16:18:33 <mm_freak> Essial: don't worry, i approached haskell with about the same background =)
16:18:40 <hpc> (can we just give him the answer and work back to an explanation from there? this is getting a bit long)
16:18:53 <Essial> nah I don't need an answer
16:18:58 <Essial> that doesn't really help me
16:19:16 <danharaj> mm_freak: tbh, I think IO is a terrible way to get used to monads. It's 'monady' part is opaque.
16:19:21 <Essial> let me play around with it for a few moment
16:19:22 <danharaj> its*
16:19:39 <Lemmih> Peaker: No, you can't use mmap to sync the state. Acid-state is designed from the ground-up to support replication and partitioning. Exactly when and where the state is forced to disk is an implementation detail.
16:19:45 <mm_freak> Essial: if you really want to learn it, don't ever use 'do', until you can write full programs without it
16:19:48 <dolio> IO isn't too bad.
16:19:51 <mm_freak> after that you can start using 'do'
16:20:04 <mm_freak> Essial: the most important thing is to understand (>>=) and 'return'
16:20:13 <mm_freak> if you understand them, you understand monads
16:20:16 <dolio> IO a is an expression tree describing IO, with things of type a at the leaves.
16:20:16 <Essial> how would I dump to the log file without do though
16:20:23 <mm_freak> and you can understand them by merely looking at their types
16:20:28 <dolio> That's what all monads are in a way.
16:20:38 <Essial> what i've done so far is learn basic stuff like 'functions' and data types, and stuff like that
16:20:52 <dolio> Expression trees, that is. Not ones that describe IO.
16:21:23 <Peaker> Lemmih, I'm not sure I understand what you use the mmap for then - if you cannot trust it to sync properly
16:22:12 <mm_freak> Essial: and whenever you look at monadic values, for now just replace the 'm' by 'IO' in your head
16:22:28 <Lemmih> Peaker: It would purely be to more precisely control what data is kept in memory.
16:22:42 <dolio> (>>=) takes the 'variables' of type a and substitutes in expression trees with bs at the leaves for them, using the function.
16:23:02 <mm_freak> dolio: i suggest letting him look at the types
16:23:02 <Essial> I think I simply need to keep dealing with the basics.. I was just trying to learn with real-world exercizes
16:23:06 <Peaker> Lemmih, I see, you don't trust the swap/virtual memory mechanism
16:23:13 <Lemmih> Peaker: You could force it to a temporary swap file or just tell the operating system to page it out.
16:23:15 <mm_freak> Essial: nothing wrong with that
16:23:29 <mm_freak> real world stuff is part of the basics =)
16:23:29 <Lemmih> Peaker: Right.
16:23:29 <dolio> I think danharaj already knows the types.
16:23:31 <Essial> here's an example of the last thign I've done so you see where I stand:
16:23:38 <Essial> prettyText (Person {firstName = f, lastName = l}) = Prelude.concat["Hello ", f, " ", l, "!"]
16:23:39 <Peaker> Lemmih, and for good reasons :-)
16:23:45 <Essial> defiend as prettyText :: Person -> String
16:23:51 <hpc> Essial: it took me a month to get stuff working in IO
16:24:05 <Essial> which works
16:24:10 <mm_freak> hpc: don't scare him =)
16:24:22 <Essial> I know x86 ans 6502 assembler, TRY to scare me :p
16:24:33 <mm_freak> Essial: do you know unlambda?
16:24:35 <danharaj> you fucking masochist
16:24:43 <danharaj> :p
16:24:43 <Essial> I don't know any functional languages though
16:24:50 <Essial> and thus, I am here
16:24:58 * ddarius has written a 6502 emulator in x86 assembly.
16:25:00 <Essial> i'm drawn to its awesome-ness
16:25:05 <mm_freak> Essial: unlambda is to functional languages what brainfuck is to imperative languages
16:25:09 <Essial> me too, did you emulate the bugs as well?
16:25:16 <Essial> Because some programs use the bugs
16:25:34 <Essial> like that page boundary error where the page number wraps wrong or something
16:25:36 <Essial> been a while :)
16:25:39 <hpc> if that was the case, they wouldn't be bugs ;)
16:25:46 <Essial> oh trust me they're bugs
16:25:56 <hpc> (the culture here is "follow the spec")
16:26:04 <Essial> but they were bugs in every single chip, the exact same bug -- i'm talking like the page number wraps instead of increments and stuff like that
16:26:09 <hpc> or fix the spec :P
16:26:11 <dolio> ddarius: Have you seen edwardk's x86 JIT compiler?
16:26:19 <Essial> ANYWAY
16:26:24 <Essial> i'm going to go back to reading this stuff
16:26:30 <Essial> i'm a bit lost on this whole >>- stuff atm
16:26:36 <hpc> oh, out of curiosity, what tutorial are you using?
16:26:39 <mm_freak> >>=
16:26:53 <mm_freak> Essial: open GHCi and experiment
16:26:58 <danharaj> ghci is the win
16:27:06 <mm_freak> it's the fastest way to get into (>>=)
16:27:08 <Essial> I can't say getZonedTime >>= time as time is not defined
16:27:19 <mm_freak> Essial: try:  getZonedTime >>= print
16:27:25 <Essial> well ya
16:27:29 <mm_freak> then look at the type of getZonedTime
16:27:33 <mm_freak> then at the type of print
16:27:39 <danharaj> Essial: Are you trying to name it as 'time'?
16:27:41 <mm_freak> then again at the type of (>>=) and how all that fits together
16:27:44 <hpc> oh, (>>-) would be an interesting function to have in a monad-related typeclass
16:27:47 <mm_freak> that should give you quite some insight
16:27:57 <hpc> it works like (>>=) but doesn't thread the "side-effects"
16:28:18 <mm_freak> hpc: what does that mean?
16:28:32 <hpc> so for a Writer, for example
16:29:17 <Essial> OH it's more like
16:29:20 <hpc> act >>- f = let (x, w) = runWriter act; (y, _) = runWriter (f x) in (y, w)
16:29:22 <hpc> instead of
16:29:26 <Essial> getzonedTime >>= myWriteFunc
16:29:30 <Peaker> Essial, you've got a procedure getDate that yields a Date, you want to build a procedure that prints that Date using the "print" function:  getDate >>= print       >>= just builds a new procedure by composing 2 procedures..   so getDate is a procedure.  print is a procedure (technically it is a function that returns a procedure).  So  getDate >>= print   is also a procedure, simply one that executes the two procedures it was built from
16:29:33 <hpc> act >>= f = let (x, w) = runWriter act; (y, w') = runWriter (f x) in (y, w++w')
16:29:36 <mm_freak> Essial: ah, big step forward =)
16:29:45 <mm_freak> Essial: you can have a lambda there, of course
16:29:54 <mm_freak> getZonedTime >>= \currentTime -> …
16:30:08 <hpc> mm_freak: "do this action, then that action, but ignore the log of f"
16:30:36 <mm_freak> hpc: and how would (>>-) look like for ContT?
16:30:41 <Peaker> hpc, sounds like you want:  m a -> a... CoMonad?
16:31:07 <Peaker> hpc, you can decompose >>-  into (m a -> a)  and fmap
16:31:09 <mm_freak> i don't think (>>-) as you define it is a monadic function
16:31:30 <ddarius> dolio: I haven't seen it.  I've talked with him about it many moons ago.
16:31:34 <mm_freak> it's a writer function
16:31:41 <mm_freak> or a state function, or a whatever function
16:31:51 <Peaker> hpc, If you can "drop" the effects of "m a" while still retaining the "a" you're going to be left with the Monads which are also CoMonads (I may be wrong, not super familiar with CoMonads) or at least those that support "extraction" of the value
16:31:56 <hpc> Peaker: oh cool lol
16:32:19 <dolio> ddarius: I found it pretty amusing, once I realized the point.
16:32:24 <hpc> mm_freak: it would have been Monad m, SomethingElse m => ...
16:32:30 <Peaker> hpc, You can drop a Writer's log, but you can't drop the possibility of Nothing from a Maybe,  or drop IO effects from an IO a, etc
16:32:32 <hpc> mm_freak: it seems SomethingElse = CoMonad :P
16:32:50 <hpc> Peaker: yeah, hence the carefully chosen example
16:33:00 <dolio> It sounds like a waste of time to interpret assembly, until you realize you can use it to optimize the output of arbitrary compilers, more or less.
16:33:03 <hpc> Peaker: i would have gone with maybe or similar if i knew it would work :P
16:34:01 <mm_freak> hpc: probably, because for monads in general it doesn't make sense
16:34:08 <mm_freak> i don't know how to cancel a Nothing =)
16:34:35 <Essial> you divide by zero
16:34:39 <hpc> hehe
16:34:40 <dolio> Peaker: You can undo in State, which is not a comonad (for arbitrary s), but still.
16:34:44 <mm_freak> Essial: type error
16:34:47 <mm_freak> > Nothing / 0
16:34:48 <lambdabot>   No instance for (GHC.Real.Fractional (Data.Maybe.Maybe a))
16:34:48 <lambdabot>    arising from ...
16:35:14 <hpc> i just thought it would be an interesting behavior to be able to use combinatorially
16:35:39 <Peaker> dolio, yeah, I guess the ability to undo is not the same as the ability to extract
16:35:46 <Peaker> so my analysis was broken :)
16:35:48 <mm_freak> hpc: how to use it?  it really just sounds like nested running
16:36:14 <mm_freak> and i don't see why you would want a binding combinator for that
16:36:22 <mm_freak> i'd have:  ignore :: m a -> m a
16:36:35 <hpc> mm_freak: ah, that would make sense
16:37:09 <Essial> ok so monads have to do with ensuring execution/processing ordering
16:37:13 <Essial> generally
16:37:16 <mm_freak> Essial: no
16:37:16 <hpc> (this is why it takes me so long to get an idea put into code :P)
16:37:24 <mm_freak> Essial: that's one of their usages
16:37:47 <Peaker> Essial, it's a very common use of them
16:38:01 <mm_freak> Essial: do yourself a favor and don't try to understand the concept of "monads" in general…  try to understand specific monads and start with IO
16:38:30 <Essial> i just have to ekep reading on this, i'm missing too many fundamentals right now
16:38:32 <hpc> @instances Monad
16:38:33 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
16:38:40 <Essial> I'll get back with you guys when I raise a bit more
16:39:04 <mm_freak> because monads are abstract things…  you can only assign interpretations…  problem:  interpretations stop working at a certain point
16:39:38 <hpc> some interpretations are better than others, but they all suck :P
16:39:43 <Peaker> Essial, follow mm_freak's advice.. Monads are a very advanced topic.. After you learn to use the IO type, and the Maybe type, and the list type, and to use functions that manipulate these types that take functions as arguments, and understand the repetitions that occur in all of these cases -- then you are ready to understand Monads
16:40:04 <hpc> s/understand/use/
16:40:12 <mm_freak> nobody understands monads
16:40:13 <hpc> you can't really understand them until you can use them effectively
16:40:21 <hpc> also that
16:40:23 <Essial> I understand the general aspects of it, I just don't know enough to know what i'm missing so I'm just digging deeper
16:40:25 <Peaker> mm_freak, the word "understand" isn't well defined :-)
16:40:34 <mm_freak> hehe
16:40:34 <Peaker> mm_freak, you could say nobody understands basic arithmetic :)
16:40:45 <monochrom> no one understands understanding
16:40:50 <mm_freak> Essial: if you understand (>>=) and 'return', then you understand monads
16:40:57 <mm_freak> it's as simple as that
16:41:54 <fragamus> I think monads are easier to understand when you are talking about a non-trivial example.  The degenerate cases like Maybe didn't make sense to me until I wrote my SituationList monad for doing combinatorics.
16:42:24 <mm_freak> i think getting the current time and formatting it to a log entry is non-trivial enough
16:42:27 <Peaker> Why is Maybe a degenerate case?
16:42:39 <Peaker> It's a pretty useful Monad instance
16:42:47 <fragamus> Because it does not bring out the power of the idea
16:43:10 <Peaker> fragamus, no specific instance of Monad brings out the power.. the power is in the generalization
16:43:27 <mm_freak> Peaker: honestly i never found Maybe alone to be useful as a monad…  the advantages of monadic Maybe become apparent in MaybeT
16:43:43 <aristid> mm_freak: i did find Maybe alone useful.
16:43:44 <Peaker> fragamus, Your SituationList monad could have had its own bind combinator and that would work -- the power you get from Monads is the existing libraries that work on it, and those work just as usefully on Maybe types
16:44:12 <mm_freak> aristid: Maybe yes
16:44:13 <fragamus> Well for me an example involving computation allowed me to grasp the idea better.
16:44:24 <aristid> mm_freak: haha.
16:44:26 <Peaker> mm_freak, I occasionally use (>>=) and other monadic combinators on Maybe. More frequently I use Applicative combinators on it, and even more frequently I use fmap on it
16:44:27 <fragamus> Maybe just didn't have enough going on
16:44:54 <Peaker> fragamus, What about the ability to use the same functions with   Maybe and List and IO ?
16:44:59 <Peaker> fragamus, that was enough for me :-)
16:45:25 <fragamus> peaker i am the grasshopper
16:46:06 <mm_freak> Peaker: mostly i use a self-invented combinator on MaybeT, which i call liftF
16:46:06 <Peaker> I love showing people how filterM is useful both for user-input-based filtering of lists and for powersets
16:46:09 <fragamus> the monadic laws have almost no meaning for me with the Maybe example
16:46:14 <aristid> @src filterM
16:46:15 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:46:23 <hpc> filterM = magic
16:46:23 <aristid> :t filterM
16:46:24 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:46:42 <aristid> :t \f -> sequence . filter f
16:46:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> Bool) -> [m a] -> m [a]
16:47:08 <mm_freak> aristid: filterM doesn't fit into the pattern of 'filter'
16:47:18 <mm_freak> > filterM (const [True, False]) "abc"
16:47:19 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
16:47:22 <Peaker> filterM f [] = return [] ;  filterM f (act:acts) = do { x <- act ; xs <- filterM f acts ; if f x then x : xs else xs }
16:47:30 <aristid> @src filter
16:47:30 <lambdabot> filter _ []     = []
16:47:30 <lambdabot> filter p (x:xs)
16:47:30 <lambdabot>     | p x       = x : filter p xs
16:47:30 <lambdabot>     | otherwise = filter p xs
16:48:20 <aristid> looks like filter is a special case of filterM tho
16:48:41 <hpc> filter is the Identity case
16:48:42 <dolio> foo is always a special case of fooM.
16:48:50 <aristid> :t filterM . fmap Identity
16:48:51 <lambdabot> forall a. (a -> Bool) -> [a] -> Identity [a]
16:49:06 <aristid> dolio: always? hmm
16:49:07 <dolio> That's the naming convention.
16:49:20 <Peaker> I wonder if filter needs Monad or could do with Applicative?  I think since the effects are always the same -- it could be done with Applicative
16:49:40 <mm_freak> Peaker: it needs Monad, i think
16:49:42 <dibblego> filterM needs Monad last I checked
16:49:53 <mm_freak> because the result depends on the outcome of individual computations along the way
16:49:54 <Peaker> dibblego, well, so does "ap" but it shouldn't :)
16:49:56 <aristid> :t \f xs -> runIdentity $ filterM (Identity . f) xs
16:49:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:50:06 <hpc> @src ap
16:50:06 <lambdabot> ap = liftM2 id
16:50:12 <hpc> @src liftM2
16:50:12 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:50:19 <Peaker> mm_freak, Applicative allows the individual computations to affect the result, just not to affect which *effects* happen
16:50:28 <Peaker> and in filterM it is always the same effects
16:50:39 <dibblego> Peaker: yeah but there is a general rule of thumb to work it out, by determining if subsequent computations require values coming off previous, and the answer is yes, so Monad is required
16:50:52 <fragamus> peaker,   type MyMonad  = StateT Situation [] a    ghc complains type variable a is not in scope
16:50:53 <Peaker> dibblego, let me challenge that assertion for a few minutes :)
16:50:53 <dolio> Peaker: I think it's clear from your definition above that Applicative suffices.
16:50:54 <Peaker> brb
16:51:01 <dibblego> Peaker: love to see it shown wrong :)
16:51:23 <dolio> Oh wait, you were doing something else.
16:51:46 <hpc> fragamus: type MyMonad _a_ = ...
16:51:59 <fragamus> thanks
16:52:39 <dibblego> @djinn (f (a -> b) -> f a -> f b) -> (a -> f a) -> (x -> f Bool) -> [x] -> f [x]
16:52:39 <lambdabot> Error: Undefined type []
16:53:00 <fragamus> omg it looks good
16:53:22 <fragamus> ghc is happy with it
16:53:39 <hpc> that's about 80% of getting code to work :P
16:53:48 <dolio> @type let fA p [] = pure [] ; fA p (x:xs) = c <$> p x <*> fA p xs ; c True = flip const ; c False = (:) in fA
16:53:49 <lambdabot>     Couldn't match expected type `[a]'
16:53:49 <lambdabot>            against inferred type `[[a]] -> [[a]]'
16:53:49 <lambdabot>       Expected type: f [a]
16:54:14 <mm_freak> indeed, you can write filterA
16:54:27 <mm_freak> :t let filterA p [] = pure []; filterA p (x:xs) = liftA2 (\b ys -> if b then x:ys else ys) (p x) (filterA p xs) in filterA
16:54:28 <lambdabot> forall a (f :: * -> *). (Applicative f) => (a -> f Bool) -> [a] -> f [a]
16:54:39 <aristid> and it behaves identically?
16:54:39 <hpc> oh, nice
16:54:42 <mm_freak> yes
16:54:45 <hpc> @hoogle filterA
16:54:45 <lambdabot> No results found
16:55:10 <hpc> the hysterical raisins strike again
16:55:13 <dolio> @type let fA p [] = pure [] ; fA p (x:xs) = c x <$> p x <*> fA p xs ; c x b xs = if b then xs else x:xs in fA
16:55:14 <lambdabot> forall a (f :: * -> *). (Applicative f) => (a -> f Bool) -> [a] -> f [a]
16:55:20 <mm_freak> @let filterA p [] = pure []; filterA p (x:xs) = liftA2 (\b ys -> if b then x:ys else ys) (p x) (filterA p xs)
16:55:21 <lambdabot>  Defined.
16:55:28 <mm_freak> > filterM (const [True, False]) "abc"
16:55:29 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
16:55:31 <mm_freak> > filterA (const [True, False]) "abc"
16:55:32 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
16:55:43 <ddarius> :t filterM
16:55:44 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:55:44 <Peaker> damn, he got it first
16:55:45 <Peaker> :-)
16:55:58 <hpc> > filterM (const [True, False]) [1..]
16:55:59 <lambdabot>   *Exception: stack overflow
16:56:02 <hpc> > filterA (const [True, False]) [1..]
16:56:04 <lambdabot>   *Exception: stack overflow
16:56:08 <mm_freak> hehe
16:56:16 <mm_freak> i eat monads for breakfast =P
16:56:25 <hpc> oh!
16:56:32 <hpc> > filterM (const [False, True]) [1..]
16:56:33 <lambdabot>   *Exception: stack overflow
16:56:34 <Peaker> I think that in the general case -- if a function's result order & choice of effects does not depend on any effect-based output -- it is Applicative and not Monad
16:56:36 <hpc> damn
16:57:06 <mm_freak> we have a lot of applicative things, which we force to be monadic
16:57:12 <mm_freak> it's a historical problem
16:57:20 <hpc> would that make Writer an applicative?
16:57:32 <mm_freak> hpc: Writer is a monad
16:57:34 <Peaker> and it is quite fortunate because (liftA2 . liftA2 ..) is so fun
16:57:38 <dolio> Every monad is Applicative.
16:57:40 <hpc> i mean, by Peaker's notion
16:57:55 <mm_freak> hpc: his notion is not related to the question
16:57:56 <hpc> is the monad instance irrelevant?
16:57:59 <Peaker> hpc, Writer is a type, not a function.. if it is a Monad, it is of course also Applicative
16:58:25 <hpc> because it doesn't have functions that depend on the effects
16:58:33 <hpc> the effects just kind of hide
16:58:50 <mm_freak> hpc: ask the same question with Identity
16:58:57 <dolio> @type listen
16:58:57 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
16:58:58 <Peaker> hpc, the Writer functions are not for all monads anyway, they are specific to Writer
16:59:16 <hpc> dolio: oh, nifty
16:59:22 <fragamus> peaker i think this thing is going to work
16:59:37 * hackagebot porter 0.1 - Implementation of the Porter stemming algorithm  http://hackage.haskell.org/package/porter-0.1 (MarkWotton)
16:59:42 <hpc> ill shut up now; i seem to be getting dumber as the night progresses
16:59:52 * ddarius needs to learn ancient K'iche'.
17:00:13 <aristid> .oO(reminds me of "Küche")
17:00:23 <geheimdienst> quiche
17:00:27 <blackdog>  real men don't learn k'iche'
17:00:28 <mm_freak> .oO(makes me hungry)
17:01:21 <wagle> how do i make a small mod to an existing cabal package and install the results?  i've done "cabal config" and "cabal build", but then what?
17:01:22 <hpc> i could go for some Küche right now
17:01:34 <blackdog> wagle: cabal install
17:02:00 <Peaker> I wish foldr's arguments were reversed
17:02:05 <geheimdienst> wagle: ... you run that in the directory where you have the sources
17:02:06 <blackdog> i more often want the opposite - get all the deps, make sure it's installable etc
17:02:17 <dibblego> Peaker: foldr [] (:) = id ?
17:02:24 <Peaker> dibblego, yeah
17:02:40 <wagle> i shoulda tried that..  thanks...
17:02:46 <Peaker> dibblego, because the base case is so much shorter/simpler usually, and then I could:  foldr (pure []) $ \x -> ... long multi-line here
17:03:04 <dibblego> yeah I guess
17:03:32 <mm_freak> Peaker: that's a general problem of many library functions
17:03:38 <mm_freak> runWhateverT
17:04:12 <Peaker> @type let filterA p = foldr (\x -> liftA2 (\b ys -> if b then x:ys else ys) (p x)) in filterA
17:04:13 <lambdabot> forall a (f :: * -> *). (Applicative f) => (a -> f Bool) -> f [a] -> [a] -> f [a]
17:04:17 <ddarius> Don't write long multi-line arguments.
17:04:48 <Peaker> well, a "step" function for foldr is usually thrown into a where clause with the name "step"
17:04:57 <mm_freak> yeah, write long single-line arguments
17:04:59 <Peaker> I think it would be nicer to have it as a $ \... in foldr
17:05:36 <Peaker> surely there must be some nicer way to express  (\b ys -> if b then x:ys else ys)
17:06:23 <mm_freak> (if b then (x:) else id) ys
17:07:24 <Peaker> "else id" has shown itself in the past
17:08:26 <shachaf> @pl \b f -> if b then f else id
17:08:26 <lambdabot> flip flip id . if'
17:08:54 <Peaker> there's   when :: Bool -> m a -> m ()    I think it may make sense to have a pure counterpart:  whence :: Bool -> (a -> a) -> a -> a
17:09:10 <Peaker> b `whence` (x:) $ ys
17:09:10 <shachaf> Peaker: ..."whence"?
17:09:19 <Peaker> well, when is taken! :)
17:09:34 <ddarius> :t until . const . not
17:09:35 <lambdabot> forall a. Bool -> (a -> a) -> a -> a
17:09:50 <Peaker> @type until
17:09:50 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:09:51 <ddarius> Too bad that's bottom.
17:09:58 <ddarius> (for True)
17:10:21 <ddarius> If the functional argument is strict.
17:10:43 <Peaker> @let whence True = id ; whence False = const id
17:10:43 <lambdabot>  Defined.
17:11:01 <hpc> Peaker: magnificent
17:11:10 <shachaf> Peaker: "whence" in English generally means "where from".
17:11:17 <hpc> > until True ("foo"++) "baz"
17:11:17 <aristid> @hoogle magnificient
17:11:17 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
17:11:18 <lambdabot>         against inferred ...
17:11:18 <lambdabot> No results found
17:11:25 <Peaker> shachaf, this is #haskell not #english :-)
17:11:27 <hpc> > until (const True) ("foo"++) "baz"
17:11:29 <lambdabot>   "baz"
17:11:29 <mm_freak> :t \b ys -> maybe id (:ys) $ guard b >> Just 'x'
17:11:30 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `[a1]'
17:11:31 <lambdabot>     In the second argument of `maybe', namely `(: ys)'
17:11:31 <lambdabot>     In the first argument of `($)', namely `maybe id (: ys)'
17:11:37 <hpc> > until (const False) ("foo"++) "baz"
17:11:41 <lambdabot>   mueval-core: Time limit exceeded
17:11:45 <hpc> > until (const False) (++"foo") "baz"
17:11:49 <lambdabot>   mueval-core: Time limit exceeded
17:11:51 <hpc> damn
17:11:58 <mm_freak> :t \b ys -> maybe ys (:ys) $ guard b >> Just 'x'
17:12:02 <lambdabot> Bool -> [Char] -> [Char]
17:12:03 <Luke1> is it possible to do applicative parsing with with any monadic parser?
17:12:09 <Essial> ok question...   if I say like....   myfunc  (getzonedTime >>= return)
17:12:13 <Essial> what exactly is going on
17:12:24 <Peaker> @type let filterA p = foldr (\x -> liftA2 (\b ys -> whence b (x:) ys) (p x)) in filterA
17:12:25 <lambdabot> forall a (f :: * -> *). (Applicative f) => (a -> f Bool) -> f [a] -> [a] -> f [a]
17:12:26 <shachaf> Luke1: Any Monad can be made an instance of Applicative.
17:12:28 <mm_freak> Luke1: any monadic parser, which is complete enough to provide an applicative instance
17:12:33 <shachaf> Essial: foo >>= return === foo
17:12:35 <hpc> :t \action -> action >>= return
17:12:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
17:12:41 <Luke1> thanks
17:12:58 <mm_freak> Lemmih: btw, that reminds me, your instances for Update and Query are VERY incomplete
17:13:00 <Peaker> Essial, that's the same as   myfunc getzonedTime
17:13:03 <monochrom> Luke1: yes. example: (+) <$> parse'num <*> parse'num
17:13:15 <mm_freak> Lemmih: incomplete to a degree, where it gets annoying
17:14:43 <Luke1> I'm assuming Data.Binary provides an applicative instance?
17:14:51 <Essial> yeah figured
17:14:52 <Luke1> i don't see it in the :i output of ghci
17:14:56 <mm_freak> Essial: by the monad laws (>>= return) = id
17:15:11 <mm_freak> i.e. getZonedTime >>= return = getZonedTime
17:15:11 <Essial> yeah i'm just not even grasping the basics of monads yet
17:15:13 * Essial keeps reading
17:15:27 <mm_freak> keep trying
17:15:33 <mm_freak> don't read too much
17:15:39 <Peaker> Essial, grasp IO, not Monads
17:15:45 <Essial> I don't even know how to tackle it yet :)
17:15:48 <mm_freak> and yes, listen to Peaker =)
17:16:15 <monochrom> Get and Put are Applicative
17:16:28 <Peaker> Essial, you want to give the result of getZonedTime to myfunc, you want to do something like:   getZonedTime >>= myfunc
17:16:36 <shachaf> Essial: IO is easily possible in Haskell without the word or type class "Monad".
17:16:38 <Peaker> Essial, does myfunc do IO or is it pure?
17:16:43 <monochrom> or rather, Get and PutM are Applicative
17:17:13 <Essial> pure
17:17:19 <Essial> no side effects
17:17:27 <Peaker> monochrom, it would be nice if parsers had variants that were NOT monads and used that to offer interesting optimizations
17:17:36 <mm_freak> Essial: the question is rather:  does it have a monadic type?
17:17:42 <Peaker> Essial, then you have another useful tool at your disposal called "fmap"
17:17:46 <monochrom> uu-parselib does
17:17:47 <mm_freak> for example:  Something -> IO SomethingElse
17:17:50 <Essial> I tried that already :p
17:17:53 <shachaf> mm_freak: All functions have monadic types. :-)
17:17:58 <Essial> I'll keep playing with it
17:18:01 <djanatyn> ooh, is fmap like map?
17:18:02 <Essial> i'm looking for a good link that explains IO
17:18:20 <mm_freak> shachaf: no, only if you import Control.Monad.Instances =P
17:18:27 <Peaker> Essial,   fmap :: (a -> b) -> IO a -> IO b       you can use:   fmap myfunc getZonedTime     and that will apply myfunc not to getZonedTime, but to its result
17:18:31 <mm_freak> Essial: what's your background?
17:18:31 <shachaf> mm_freak: It's monadic whether or not you define the instance. :-)
17:18:34 <monochrom> http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming explains IO
17:18:55 <shachaf> If you're talking about IO in particular, why bring up "monadic types" in general?
17:18:57 <mm_freak> Essial: or what was your favorite language, before you fell in love with haskell? =P
17:19:02 <shachaf> djanatyn: A lot like map.
17:19:06 <Essial> pascal
17:19:09 <mm_freak> shachaf: sorry
17:19:14 <fragamus> Peaker, with my old SituationList, I had this function to unwrap the state:     strip_off_SL (SL p) = p      Now I'm using StateT Situation []    I need to know how to unwrap it
17:19:21 <shachaf> mm_freak: ?
17:19:41 <mm_freak> hmm
17:19:44 <Essial> But I've done lots of os devving in C and C++, and lots of C#, javascript, etc
17:19:46 <Essial> i've been around
17:19:55 <Peaker> BONUS removed the free version of LYAH?
17:19:56 <Essial> my personal favorite has been pascal though
17:19:57 <mm_freak> C# is a good start
17:20:06 <hpc> Peaker: that would be evil lol
17:20:06 <Essial> C# is bulky as hell
17:20:07 <Luke1> Since Binary has Get and Put does that mean it automatically provides Applicative
17:20:17 <mm_freak> because its type system matches haskell's closest from the languages you mentioned
17:20:24 <djahandarie> Peaker... what?
17:20:32 <Essial> you're talking about reflection or the "Type" type
17:20:33 <hpc> it's still there
17:20:35 <djanatyn> I'm with djahandarie here
17:20:36 <applicative> Peaker, no there is a front page
17:20:43 <djanatyn> Why would BONUS remove it?
17:20:47 <hpc> BONUS isn't taking the free version down
17:21:01 <monochrom> I just read LYAH yesterday online
17:21:02 <Peaker> Oops, I was looking in the wrong place :)
17:21:13 <Peaker> Forget my silly question
17:21:15 <djanatyn> I thought BONUS specifically said he would keep the free version up because he wanted to make learning haskell accessible to everyone
17:21:19 <djahandarie> learnyouahaskellforlotsofmoney.com is the wrong site
17:21:25 <djanatyn> BURN THE HEATHEN
17:21:37 <shachaf> djanatyn: Yes, you certainly are, at least as far as tab completion goes.
17:21:40 * djanatyn just finished installing xmonad. :)
17:21:48 <aristid> @where lyah
17:21:48 <lambdabot> http://www.learnyouahaskell.com/
17:21:50 <mm_freak> Essial: neither…  imagine a generic class in C#, which contains exactly one value of the generic type
17:21:56 <shachaf> @ty map
17:21:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:22:00 <shachaf> Cale should fix that.
17:22:03 <Essial> speaking of which, before I waste my time.. there's full support for OpenGL right?
17:22:05 <Peaker> Essial, http://learnyouahaskell.com/input-and-output
17:22:11 <aristid> lyah is still online and works fine
17:22:30 <mm_freak> Essial: this class gives you no access to the value other than a method, which takes a function, which returns another object of that class
17:22:31 <applicative> shachaf: what's wrong with the type of map?
17:22:41 <geheimdienst> 1. look in wrong place 2. ask innocent question in #haskell 3. public rage 4. discover mistake 5. nyan cat posted to pacify everyone
17:22:45 <Peaker> Essial, Yeah, OpenGL has bindings that seem pretty comprehensive
17:22:46 <shachaf> applicative: Should be fmap.
17:22:50 <mm_freak> that method would be (>>=)
17:22:55 <applicative> @ty fmap
17:22:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:22:57 <Essial> what about UI?
17:23:06 <applicative> @ty (.)
17:23:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:23:13 <hpc> geheimdienst: 1. 0/0 2. NaN cat
17:23:19 <Essial> I have aspergers and this imperitive programming seems to suite me MUCH better
17:23:22 <applicative> > even . [1,2,3]
17:23:23 <lambdabot>   [False,True,False]
17:23:34 <Essial> er functional...
17:23:36 <fragamus> Peaker, with my old SituationList, I had this function to unwrap the state:     strip_off_SL (SL p) = p      Now I'm using StateT Situation []    I need to know how to unwrap it
17:23:59 <geheimdienst> hpc, http://www.youtube.com/watch?v=QH2-TGUlwu4
17:24:04 <Axfan> alright guys im getting a strange error when compiling
17:24:19 <luite> Essial: yes there's opengl support, also gtk2 bindings for the rest of your user interfaces
17:24:24 <Peaker> fragamus, runStateT, evalStateT or execStateT
17:24:32 <Essial> perfect, and I already know it supports sockets and threads
17:24:33 <Peaker> fragamus, depends if you want the resulting state, the resulting value, or both
17:24:37 <Essial> so I have no reason not to learn it
17:24:43 <Axfan> its saying ambigious module name control.monad.reader from multiple packages and lists two
17:24:51 <mm_freak> Essial: you will love concurrent programming in haskell
17:24:51 <Essial> i'm assuming its pretty fast at doing heavy math :D
17:24:52 <fragamus> oh right doh
17:25:08 <mm_freak> "pretty fast" yes, but it won't match the speed of C or assembly
17:25:09 <Essial> like quaternions
17:25:15 <Peaker> Essial, Haskell can range from very slow to very fast.. it is pretty easy to avoid the things that make it very slow so it is mostly very fast
17:25:41 <luite> Essial: but admittedly there's no really finished library for doing user interfaces in a functional way. there are some research projects, but gtk2hs (the gtk 2 bindings) have a low-level imperative feel
17:25:45 <Peaker> Essial, for uni-processor C and C++ (and in many cases even Java in server mode) will beat Haskell. For multi-core Haskell is already beginning to win bigtime
17:25:47 <Essial> well assuming its coded as optimally as possible
17:25:48 <mm_freak> on the other hand, it's much easier to write scalable concurrent servers in haskell
17:26:30 <Essial> well I'm researching languages for my game, and I have a new AI system that's VERY complex, i wrote it in C# and hated how I had to do things
17:26:40 <Essial> I looked at haskell and started smiling :p
17:26:41 <Peaker> Essial, you can write code that looks kind of like C and performs kind of like C in Haskell.. It's nice that you don't have to drop to a lower language as you can go low-level in Haskell
17:27:20 <Peaker> (but that code is very ugly, fortunately you don't have to write it very often, and there are libraries optimized in this way for common tasks)
17:27:43 <mm_freak> Peaker: i don't think it's ugly…  it's still prettier than in C
17:27:53 <mm_freak> it's just, well, not functional =)
17:27:59 <Peaker> mm_freak, not sure about that.. code with mallocBytes, peek and poke is ugly
17:28:04 <mm_freak> and even that is only true to some extent
17:28:22 <mm_freak> it's not, because you have all the monadic combinators at your disposal, and you can still use functional tools
17:28:34 <mm_freak> there are alloca and sisters
17:29:55 <amedx> hello
17:30:13 <amedx> i need some help for drawing binary trees
17:30:13 <mm_freak> only problem with direct memory access is that you may get segfaults…  a problem, which high level haskell has solved long ago
17:31:10 <Axfan> how do ig et mtl and monads-tf to stop giving me errors
17:31:28 <amedx> somebody tell me a good link for drawing binary trees?
17:31:35 <Augusto> Hello friends, once again I need some help. I need to create a program that does a search for a list and return me the sum of the notes that she has.
17:31:46 <shachaf> amedx: I suggest the left and right links from each node.
17:32:06 <monochrom> shachaf++
17:32:19 <Essial> ok so where it says myFunc :: String -> IO ()   for returns of meaningless value
17:32:28 <Essial> can I also say... myFunc :: String -> IO (String)
17:32:41 <Essial> or something
17:32:48 <sipa> yes
17:33:07 <sipa> that would be a function that takes a string, and computes a new string by doing IO
17:33:07 <Peaker> Essial, myFunc :: String -> IO (String)   is valid and same as: myFunc :: String -> IO String
17:33:12 <Peaker> Essial, what does myFunc do?
17:33:16 <mm_freak> Essial: IO (String) = IO String, btw…  note that () is a specific type just like Int or Bool
17:33:17 <Essial> just as an example
17:33:47 <Essial> i'm starting to get it.. just gotta keep reading
17:34:14 <Augusto> Hello friends, once again I need some help. I need to create a program that does a search for a list and return me the sum of the notes that she has.
17:34:24 <Peaker> Augusto, please don't repeat..
17:34:40 <Peaker> Augusto, your question is unclear
17:34:46 <Augusto> ok, sorry Peaker
17:35:05 <Essial> is this a haskell question or a 'do it for me' question :)
17:35:17 <mm_freak> Peaker: Augusto didn't ask a question
17:35:44 <mm_freak> i think it's just a twitter-style status update =)
17:35:52 <Essial> anyway so IO types of course have to be 'ran' and their outputs or inputs processed, hence why you say myvar <- someIOThing
17:36:14 <mm_freak> Essial: <- is just syntactic sugar for (>>=)
17:36:30 <Essial> I VASTLY prefer <- over >>=
17:36:40 <Essial> >>= is just confusing :)
17:36:41 <mm_freak> you shouldn't (right now)
17:36:46 <Augusto> I have a list with names and numbers (which are test scores, numerical values​​), I need to create a program in haskell that I go through this list and return the sum of these numeric values​​.
17:37:02 <Peaker> Essial, when you say:  do { x <- action ; some other stuff here }   it is just convenient notation for:    action >>= \x -> some other stuff here
17:37:28 <Essial> yeah <- seems way more sane then
17:37:30 <mm_freak> Essial: (>>=) shouldn't be any more confusing that <-
17:37:33 <Peaker> Essial, basically doing IO is chaining IO actions to one another using (>>=) and do {} is syntax sugar around (>>=) chains
17:37:35 * shachaf still wonders whether explicit CPS is clearer than >>= at first.
17:37:40 <Essial> what exactly is \x
17:37:48 <mm_freak> Essial: it's a lambda expression
17:37:48 <Peaker> Essial, If do wasn't nicer than >>= it wouldn't exist
17:37:59 <mm_freak> > (\x -> 2+x^2) 5
17:38:00 <lambdabot>   27
17:38:03 <Peaker> Essial, but >>= is still nicer than do in some cases
17:38:23 <Peaker> Essial, and when learning, it is best to use >>= and not "do" because there are less layers that add confusion
17:38:27 <mm_freak> Essial: in most other languages you would call that an anonymous function
17:38:38 <mm_freak> and 'x' is its parameter
17:38:53 <zomg> Oh
17:38:59 <zomg> You can use lambdas like that too? Nice :P
17:39:12 <Essial> well with do the process seems obvious
17:39:16 <mm_freak> Augusto: do you know how to program in haskell?
17:39:17 <Essial> without it i have no idea (yet)
17:39:32 <monochrom> getLine >>= \x -> putStrLn (x ++ x)
17:39:55 <Essial> String -> String -> IO ()   ?
17:40:03 <mm_freak> IO ()
17:40:21 <Peaker> Essial, "do" gives you something that other languages give you too. Other languages give it as magic. do gives it as sugar on top of (>>=).  This means there's more to learn in Haskell than other languages, simply because the primitives of other languages are libraries in Haskell so you can learn how these libraries are implemented and even implement different libraries that are not possible in other languages
17:40:37 <Augusto> <mm_freak> I'm learning
17:40:56 <mm_freak> Augusto: ok, do you have a question about your task?
17:40:56 <Essial> woop
17:41:01 <Essial> well i'm slowly eating away at it
17:41:04 <Essial> as you were
17:41:21 <Augusto> yes
17:41:25 <mm_freak> Essial: read monochrom's example…  again look at the types
17:41:33 <mm_freak> getLine :: IO String
17:41:43 <mm_freak> (\x -> putStrLn (x ++ x)) :: String -> IO ()
17:41:52 <mm_freak> (>>=) :: IO String -> (String -> IO ()) -> IO ()
17:42:13 <mkscrg> I'm looking for a library to read and perhaps write BMP or PNG files in Haskell. Ideas?
17:42:18 <Augusto> as I do that search and it returns me only the sum of these numeric values​​?
17:42:22 <Peaker> Essial, Note that >>=   takes an  IO a, and an (a -> IO b)   and returns an  IO b   so applying >>= the way monochrom did must result in an (IO something) and not in something like (String -> String -> ..)
17:42:40 <mm_freak> Augusto: i don't understand the question, sorry
17:42:55 <Peaker> Essial, did you cover currying?  do you understand the notation:  a -> (b -> c) -> d ?
17:43:16 <Augusto> It is like recursion.
17:43:44 <mm_freak> :t sum . map snd
17:43:45 <dmwit> mkscrg: Did you look on Hackage?
17:43:45 <lambdabot> forall a b. (Num b) => [(a, b)] -> b
17:45:12 <mkscrg> dmwit: Just found Codec.BMP. Thanks
17:47:30 <dmwit> There's also (at least) bindings to gd and imagemagick.
17:47:39 <dmwit> I wouldn't be surprised if there was a pure-Haskell PNG decoder, either.
17:49:41 <Augusto> soma :: [Int] -> Int
17:49:44 <Augusto> soma [] = 0
17:49:51 <Augusto> soma (h:t) = h + (soma t)
17:50:16 <dmwit> h + soma t -- should work fine, too
17:50:26 <Augusto> I got it, but does not return what I need.
17:50:38 <dmwit> Also, the standard library comes with "sum = foldr (+) 0", in case you don't want to build it yourself every time you need it. =)
17:50:49 <dmwit> What do you need?
17:51:03 <shachaf> @src sum
17:51:03 <lambdabot> sum = foldl (+) 0
17:51:14 <dmwit> > let soma :: [Int] -> Int; soma [] = 0; soma (h:t) = h + soma t in soma [5,17,32]
17:51:15 <lambdabot>   54
17:51:28 <dmwit> shachaf: Oh, whoops.
17:51:32 <Augusto> tenho uma lista de nomes e números (do tipo float).
17:51:36 <Augusto> ops
17:51:38 <Augusto> sorry
17:51:47 <Augusto> I have a list of names and numbers (type float).
17:52:23 <dmwit> Augusto: You can give your function a more general type that also works for Float. =)
17:52:31 <dmwit> soma :: Num a => [a] -> a
17:52:49 <dmwit> > let soma :: Num a => [a] -> a; soma [] = 0; soma (h:t) = h + soma t in soma [5,17,32.5]
17:52:50 <lambdabot>   54.5
17:53:12 <Augusto> I need to do a search on the list and as a result the program returns me the sum of the numbers.
17:53:56 <fragamus> 1+1
17:54:28 <fragamus> >1+1
17:54:40 <fragamus> > 1+1
17:54:41 <lambdabot>   2
17:54:52 <Essial> > 1 / 0
17:54:53 <lambdabot>   Infinity
17:54:56 <fragamus> lambdabot you are amazing
17:54:56 <Essial> yay!
17:55:03 <Essial> that's exactly what i always say
17:55:17 <Essial> > import System.IO
17:55:18 <lambdabot>   <no location info>: parse error on input `import'
17:55:25 <mm_freak> Augusto: perhaps give us an example of what the input to your program looks like
17:55:25 <Essial> :-/
17:55:33 <fragamus> I think you know a lot about haskell
17:56:37 <siracusa> Augusto: What's the type your list has?
17:56:56 <mkscrg> When you install a package with cabal, does it come with the haddock docs?
17:57:09 <mkscrg> I thought it was supposed to...
17:57:31 <monochrom> it is an option
17:57:50 <monochrom> unfortunately the default setting says "no"
17:57:51 <siracusa> mkscrg: cabal haddock creates the docs
17:58:15 <aavogt> read your ~/.cabal/config
17:58:27 <Augusto> [("Robert", 3.5), ("Paul", 2.5), ("Peter", 7.9)]
17:59:01 <aavogt> Augusto: a search to look for which elements?
17:59:20 <djahandarie> > sum . map snd $ [("Robert", 3.5), ("Paul", 2.5), ("Peter", 7.9)]
17:59:22 <lambdabot>   13.9
18:00:08 <Augusto> Yes, it busta these numerical values​​, adds them and returns me the result of that sum.
18:00:30 <Augusto> Sim, ela busca esses valores numéricos, soma eles e me retorna o resultado desta soma.
18:00:34 <Augusto> sorry
18:00:41 <Augusto> Yes, she searches these numeric values​​, adds them and returns me the result of that sum.
18:00:45 <djanatyn> -_-
18:00:46 <mkscrg> Ah thanks. I was reading the global doc tree but had installed locally.
18:00:49 * djanatyn just wants to use gridSelect.
18:00:51 <djanatyn> I suck at xmonad.
18:01:12 <monochrom> "that's what she said"
18:01:52 <djanatyn> oh no you didn't
18:03:01 <shlevy> I want to write a program that executes another linux executable but modifies all calls to external programs and libraries so that the program/library location is found in PATH/LD_LIBRARY_PATH, rather than whatever the binary hard-coded. I know how I would do this in C (ptrace, grab relevant syscalls like execve, modify the arguments), but I want to get more Haskell experience. Is this a reasonable task for Haskell?
18:03:56 <dmead> shlevy, thats pretty reasonable. but you're more likley to just use FFI calls to the c library
18:03:57 <mm_freak> shlevy: unlikely
18:04:57 <Taslem> Generally, should types derive Show?
18:05:07 <shachaf> Taslem: Generally, maybe.
18:05:09 <monochrom> yes
18:05:10 <shlevy> dmead: Ok, that's what I was worried about
18:05:13 <mm_freak> Taslem: as long as possible, yes
18:05:49 <dmwit> Taslem: "go with your heart"
18:07:14 <Essial> can you use <- in
18:07:20 <Essial> let   statements
18:07:24 <mm_freak> Taslem: let's say, there is no disadvantage to deriving Show, but it gets most useful, if read . show = id
18:07:24 <monochrom> no
18:07:29 <Essial> k
18:08:13 <mm_freak> Taslem: if you can't provide that invariant, then Show is at least good for debugging
18:08:29 <Taslem> I see.
18:08:51 <Taslem> How do you make an instance to the Read typeclass without deriving it?
18:09:19 <mm_freak> provide the readsPrec function
18:09:20 <dmwit> Implement "reads".
18:09:21 <parcs> Essial: you can use <- within list comprehensions and do notation, both of which can be inside a let expression
18:09:26 <dmwit> ...readsPrec, yes
18:09:32 <dmwit> ?src Read
18:09:32 <lambdabot> class Read a where
18:09:33 <lambdabot>   readsPrec    :: Int -> ReadS a
18:09:33 <lambdabot>   readList     :: ReadS [a]
18:09:33 <lambdabot>   readPrec     :: ReadPrec a
18:09:33 <lambdabot>   readListPrec :: ReadPrec [a]
18:09:53 <Taslem> How exactly does that work?
18:10:06 <monochrom> reads is not one of the methods
18:10:09 <mm_freak> it takes a precision and a string and produces an 'a'
18:10:17 <monochrom> not precision. precedence
18:10:22 <mm_freak> oh
18:10:28 <dmwit> ?src ReadS
18:10:28 <lambdabot> Source not found. You untyped fool!
18:10:35 <Essial> oh and what exactly is $
18:10:38 <dmwit> I don't think it produces an 'a', either.
18:10:46 <Draconx> it produces [(a, String)]
18:10:55 <Taslem> Know of a working example?
18:10:59 <dmwit> type ReadS a = String -> [(a, String)]
18:11:28 <mm_freak> Taslem: to be honest, you usually don't want to have a non-derived Read instance
18:11:33 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Read.html#Read has several instances of Read.
18:11:46 <dmwit> Taslem: grep for "instance Read Char" and start from there.
18:12:04 <mm_freak> deriving Read and Show should give you a parser and writer for configuration files for free
18:12:29 <dmwit> ...but not error messages =P
18:12:48 <mm_freak> Show also gives you the ability to write values for debugging to stderr or something of that sort
18:12:54 <mm_freak> i wouldn't use them for anything else
18:13:11 <mm_freak> Essial: f $ x = f x
18:13:27 <mm_freak> but ($) has the lowest priority, while function application has the highest
18:13:33 <mm_freak> f $ sin x = f (sin x)
18:13:39 <shachaf> mm_freak: Almost. :-)
18:14:02 <mm_freak> shachaf: i don't consider record updates/record pattern matching operators =P
18:14:40 <mm_freak> and yes, = has a lower priority, but that's not an operator either (at least to me)
18:14:57 <Taslem> Do you ever use map ($ a)?
18:15:09 <dmwit> yes
18:15:27 <mm_freak> rarely, but yes
18:15:33 <dmwit> :t \a -> map ($a)
18:15:34 <lambdabot> forall a b. a -> [a -> b] -> [b]
18:15:49 <dmwit> :t sequence :: [a -> b] -> a -> [b]
18:15:50 <lambdabot> forall a b. [a -> b] -> a -> [b]
18:16:45 <Taslem> Is (a $) always equal to a, assuming a is of the type x -> y?
18:16:50 <dmwit> > read "['f','o','o']" :: String
18:16:51 <lambdabot>   "foo"
18:16:55 <dmwit> gnarly
18:17:13 <dmwit> Yes, ($) = id.
18:17:13 <mm_freak> Taslem: how can (a $) be equal to 'a'?
18:17:26 <dmwit> mm_freak: easy
18:17:29 <dmwit> mm_freak: It just is.
18:17:55 <Taslem> Is there ever a case where that isn't entirely redundant?
18:18:07 <dmwit> Yes, if you'd like to restrict the type of a.
18:18:08 <mm_freak> > let a = undefined :: x -> a in a == (a $)
18:18:09 <lambdabot>   *Exception: (==): No overloading for function
18:18:17 <mm_freak> hmm, indeed
18:18:40 <shachaf> Taslem: sequence is similar.
18:20:34 <mm_freak> :t (undefined $)
18:20:35 <lambdabot> forall a b. a -> b
18:20:59 <Taslem> What exactly is the point of defining undefine's type?
18:21:14 <mm_freak> Taslem: sometimes only the type is important
18:21:20 <mm_freak> the value is not used
18:21:37 <mm_freak> in my case i just wanted to see, if it typechecks
18:21:50 <mm_freak> i got a runtime error, so it typechecked
18:21:56 <dmwit> :t (return True $)
18:21:57 <lambdabot> forall a. a -> Bool
18:22:06 * Essial sighs
18:22:26 <Essial> it's kinda discouraging a bit that it's taking over 4 hours to do the C# equiv of Now.ToString()  :p
18:22:41 <dmwit> Four hours?
18:22:44 <Essial> I know why
18:22:50 <Essial> but stil
18:22:59 <Essial> and counting dmwit :p
18:23:56 <dmwit> Essial: fmap show getCurrentTime
18:24:16 <dmwit> That took no more than 120s, based on the minute-accurate IRC timestamps.
18:24:18 <mm_freak> Essial: the type system of haskell is a magic weapon…  it's difficult to master, but once you master it, it will work to your advantage =)
18:24:20 <danharaj> :t fmap show
18:24:21 <lambdabot> forall a (f :: * -> *). (Show a, Functor f) => f a -> f String
18:24:28 <Essial> not working
18:24:40 <dmwit> WFM
18:24:40 <mm_freak> Essial: what dmwit posted works
18:24:49 <mm_freak> what does not work is:  main = fmap show getCurrentTime
18:24:50 <mm_freak> =)
18:24:54 <Essial> couldn't match expected type IO a0 with actual type Int->int->Data.Fixed.Pico -> TiemOfDay
18:25:07 <mm_freak> it would work with main :: IO String, but it would not do what you want
18:25:27 <Essial> it's in a do block
18:25:36 <Essial> make returns IO (), but that is not the last line
18:25:47 <Essial> the last line returns a value the descriptor is happy with
18:25:49 <dmwit> Essial: Here is my complete file (named test.hs): import Data.Time;main = getCurrentTime >>= print
18:25:50 <danharaj> Essial: could you paste your code?
18:26:19 <Essial> THAT works dmwit
18:26:24 <Essial> getcurrentTime >>= print
18:26:37 <dmwit> Essial: I also tested "fmap show getCurrentTime" at the ghci prompt.
18:26:43 <dmwit> So don't give me this "it doesn't work" nonsense.
18:26:52 <shachaf> dmwit: It only works with the correct import. :-)
18:26:54 <Essial> I'm not saying it doesn't work in principal
18:27:03 <Essial> i'm saying it didn't work given what I coded :p
18:27:08 <Essial> but your second example works great
18:27:13 <shachaf> dmwit: In particular, try :m + Data.Time.Clock
18:27:18 <dmwit> The first example works great, too.
18:27:22 <shachaf> Which has a different function by the same name.
18:27:23 <mm_freak> Essial: i give you that example an hour ago
18:27:34 <Essial> i know, i'm trying to understand it though
18:27:39 <Essial> otherwise i'd have just kept going
18:27:46 <MatrixFrog1> Essial++
18:27:49 <mm_freak> Essial: write a very simple program
18:27:51 <mm_freak> main :: IO ()
18:27:52 <dmwit> shachaf: I don't see a different function with the same name.
18:27:58 <mm_freak> main = getCurrentTime >>= print
18:28:02 <mm_freak> look at the types
18:28:11 <Essial> I have, that line works, and I somewhat understand the basics of it
18:28:18 <Essial> I'm just trying to get deeper into using it in expressions and such
18:28:28 <mm_freak> obviously whatever "getCurrentTime >>= print" is, it has to be of type IO (), because it's equal to main, which is of type IO ()
18:28:30 <shachaf> dmwit: Oh, maybe I just didn't get the Show instance.
18:28:33 <shachaf> Never mind.
18:28:45 <shachaf> mm_freak: main is actually of type IO a, isn't it?
18:28:53 <mm_freak> shachaf: not in my example
18:28:58 <Essial> so main itself is messing me up then?
18:28:59 <mm_freak> i gave a type signature
18:29:18 <mm_freak> Essial: i don't know what it does in your code, but in my code it doesn't mess anything up =)
18:29:40 <dmwit> getCurrentTime :: IO UTCTime; show :: UTCTime -> String; fmap show :: IO UTCTime -> IO String
18:30:08 <Essial> http://pastie.org/1891376
18:30:20 <Essial> only on line 23 i'm trying to instead put it in the logIt function
18:30:32 <Essial> obviously I had a few examples earlier but i'mt rying to learn how to do it myself
18:30:38 <dmwit> s <- fmap show getCurrentTime
18:30:42 <mm_freak> first of all, indent your } on line 21
18:30:44 <dmwit> logIt s
18:31:00 <danharaj> or
18:31:02 <monochrom> @remember geheimdienst * geheimdienst will from now on use a function carpeTiem aliased to getCurrentTime
18:31:03 <lambdabot> Okay.
18:31:06 <danharaj> fmap show getCurrentTime >>= logIt
18:31:12 <dmwit> Yes, or
18:31:15 <monochrom> perhaps it can still make it to HWN
18:31:19 <dmwit> getCurrentTime >>= logIt . show
18:31:24 <dmwit> There's a million ways to do it.
18:31:27 <danharaj> yes
18:31:40 <dmwit> If you really want to get confused, you can even do
18:31:45 <dmwit> getCurrentTime >>= fmap logIt show
18:32:08 <danharaj> and being able to reshape your code into equivalent forms is one of the best ways to understand Haskell
18:32:18 <danharaj> it's also immensely useful in practic.
18:32:21 <Essial> that would read in the value from GetcurrentTime with Show ( a string IO), and fmap turns it into a char array passing it as a param to logIt right?
18:32:41 <dmwit> Close.
18:32:46 <Essial> yay ::D
18:33:16 <dmwit> fmap turns the pure "show" function, which is the equivalent of Your Language's "toString" method, into an IO-aware function with the same behavior.
18:33:35 <Essial> this has something to do with lazy binding right?
18:33:39 <dmwit> No.
18:33:46 * Essial hrms
18:33:57 <danharaj> :t fmap
18:33:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:33:59 <mm_freak> again (and for the last time) look at the types
18:34:08 <danharaj> :t map
18:34:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:34:15 <mm_freak> really, learn to look at the types, for god's sake…  haskell is all about types!
18:34:25 <danharaj> Type directed programming.
18:34:39 <Essial> i've been coding functional code for a total of about 8 hours my entire life
18:34:44 <Essial> sorry I'm not instantly getting it ;p
18:34:47 <danharaj> Essial: you're learning quickly
18:34:52 <mm_freak> show takes (in your instance) a UTCTime and produces a String
18:34:59 <mm_freak> but getCurrentTime is NOT of type UTCTime
18:35:01 <Essial> stil IO though
18:35:03 <mm_freak> it's IO UTCTime
18:35:13 <mm_freak> fmap brings show and getCurrentTime together
18:35:14 <monochrom> who's afraid of IO?
18:35:33 <mm_freak> fmap :: (UTCTime -> String) -> IO UTCTime -> IO String
18:35:51 <mm_freak> it maps the pure function (first argument) over the IO computation (second argument)
18:36:13 <Essial> pure being the function that isn't IO bound
18:36:31 <dmwit> Yes.
18:36:39 <Augusto> hi again
18:36:40 <Essial> ok give me a few to dig a little deeper
18:36:42 <Essial> thanks guys :d
18:36:58 <mm_freak> techincally "pure" has no meaning…  i refer to being "pure", when the result is not some IO a
18:37:00 <Essial> this is the best help i've gotten from anything ever so
18:37:17 <Augusto> What would that SND?
18:37:22 <danharaj> I like to think of it as plain and decorated functions.
18:37:27 <danharaj> and plain and decorated types.
18:37:34 <danharaj> Where you decorate types with type constructors to get new types.
18:37:57 <danharaj> fmap tells you that there's a generic way to transform functions from working on plain types to decorated types.
18:38:19 <danharaj> fmap is to f as map is to []
18:38:44 <dmwit> Augusto: I don't understand the question.
18:38:49 <mm_freak> yeah, for example when you decorate Int as MonadPeelIO m => Handle -> Iteratee ByteString (StateT Config (ContT r m)) Int
18:38:53 <mm_freak> =P
18:39:05 <Augusto>  sum . map snd $ [("Robert", 3.5), ("Paul", 2.5), ("Peter", 7.9)]
18:39:09 <geheimdienst> mm_freak: thanks for clearing that up
18:39:19 <dmwit> ?src snd
18:39:19 <lambdabot> snd (_,y) =  y
18:39:38 <mm_freak> > map snd [("test1", 1), ("test2", 2)]
18:39:39 <lambdabot>   [1,2]
18:39:41 <dmwit> It's short for "second". There's also "fst", which is short for "first".
18:39:45 <dmwit> ?src fst
18:39:45 <lambdabot> fst (x,_) =  x
18:40:28 <danharaj> I kind of wish the standard had pi1, pi2, pi3, etc. for projections :p
18:40:59 <Augusto> That is, if I have a list and what I need is the second so I use sum. SND $ map [('Robert', 3.5), (​​"Paul", 2.5), ('Peter', 7.9)]
18:41:09 <dmwit> danharaj: http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Select.html
18:42:00 <danharaj> dmwit: indeed. Wish the standard had something like that :p
18:44:23 <Essial> YAY ok i got it working with a do block
18:44:27 <Essial> just gotta 'un-do' it, heh
18:44:39 <Augusto> Thank you for the help.
18:44:58 <danharaj> Essial: you are going to need to understand lazy evaluation to do loops :p
18:45:27 <danharaj> tbh it should be called something more euphemistic
18:45:32 <danharaj> like Parsimonious Evaluation
18:45:45 <Essial> http://pastie.org/1891408 is the magic sauce right now
18:45:51 <monochrom> orthodox evaluation
18:46:28 <danharaj> "the better kind of" evaluation
18:46:52 <seafood> Anyone know much about System.Mem.StableName? Is there a good reason why there is no Ord instance for it?
18:48:07 <Essial> man that's still awesome though
18:48:15 <Essial> I think i'm going to like haskell once i get into it
18:48:35 <Essial> it feels more -- programming-ey than procedural
18:49:46 <danharaj> That's because programming is about data and transformation
18:50:03 <danharaj> not about pulling levers on a machine
18:50:05 * BMeph votes, in opposition to "premature evaluation", to hereby refer to "lazy" as "mature evaluation"! >;)
18:50:33 <danharaj> of course you can do procedural programming in haskell too
18:50:48 <danharaj> except your procedural programs are data themselves. You can transform them like any other sort of data.
18:51:33 <shachaf> danharaj: Not *really*.
18:51:39 * dmwit attempts to reverse the procedure that ends produces bills
18:51:41 <shachaf> IO is pretty opaque.
18:51:55 * shachaf attempts to parse dmwit's last sentence.
18:51:58 <danharaj> shachaf: if you represent your program as a tree of IO expressions like dolio mentioned earlier, you can.
18:52:01 <dmwit> I think I've succeeded. Only one problem: it also reversed the procedure that produced paychecks.
18:52:12 <danharaj> shachaf: we can consider flattening that tree with >>= like compiling the program :p
18:52:17 <dmwit> shachaf: s/ends//
18:56:49 <danharaj> I want to use do-notation to build values of a certain data structure. Would that be the free monad?
18:57:06 <danharaj> (my data structure is a functor)
18:59:11 <danharaj> nevermind that question made no sense
19:00:25 <Martty> the answer is chuck norris
19:00:59 <Essial> or 42
19:05:48 <Essial> So is there a non painfull way to install HDBC in windows for postgreSQL connectivity?
19:06:38 <danharaj> Essial: Did you install the haskell platform?
19:06:42 <Essial> yes
19:06:49 <Essial> well the full installer with all the doodads
19:06:51 <danharaj> command line: cabal install hdbc
19:07:12 <Essial> neat :D
19:07:13 <danharaj> and then
19:07:23 <danharaj> cabal install hdbc-postgresql
19:07:44 <Essial> that's pretty awesome
19:07:48 <danharaj> I haven't used it so you'll have to figure out how to work it
19:07:49 <danharaj> :p
19:07:56 <Essial> i'll manage :)
19:08:08 <danharaj> are you aware of hackage?
19:08:16 <Essial> aware of it, but that's it
19:08:23 <Essial> this is my first day even knowing haskell existed
19:08:23 <danharaj> hayoo is the best way to find libraries
19:08:39 <danharaj> and when you find a package you can do 'cabal install <package>' to get it off hackage.
19:08:47 <dmwit> I still believe in Ctrl-F.
19:08:50 <Essial> yay pgconfig required but not found :)
19:09:07 <Essial> DUH
19:09:09 <Essial> :p
19:09:15 * Essial updates his path
19:09:44 <danharaj> you might have trouble on windows because people are careless about how they support their packages on it
19:09:46 * danharaj fumes
19:09:58 <Essial> I'm on windows 7 on an imac
19:10:03 <Essial> I offend many
19:10:08 <dmwit> We Linux hippies can't afford a copy of Windows to test with.
19:10:20 <Essial> I also run linux mint on my laptop :p
19:10:47 <Hugglesworth> retarded question here
19:10:50 <ozataman> hey all. I keep getting "can't load .so/.DLL for: ..." errors when using TH with FFI-enabled libraries.. any ideas on how to solve this?
19:11:07 <Hugglesworth> I'm trying to either a `Either (MatchOffset, String) Regex` and I can't seem to get the left function
19:11:20 <Essial> anyway it's time for epic rap battles of history: stephen hawking vs albert einstein  http://www.youtube.com/watch?v=zn7-fVtT16k
19:11:30 <shachaf> @ty either
19:11:31 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:11:34 <Hugglesworth> there's no empty Regex think in the library
19:11:36 <Hugglesworth> thing*
19:11:52 <Hugglesworth> shachaf: yeah, I know that
19:12:16 <shachaf> @hoogle Regex
19:12:16 <lambdabot> module Text.Regex
19:12:16 <lambdabot> Text.Regex.Posix.ByteString data Regex
19:12:16 <lambdabot> Text.Regex.Posix.Sequence data Regex
19:12:21 <Hugglesworth> I want Regex out, but I can't figure out how to output an empty regex
19:12:27 <Hugglesworth> `either (\_ -> Regex) (\x -> x) reg`
19:12:38 <Hugglesworth> <interactive>:1:15: Not in scope: data constructor `Regex'
19:13:26 <shachaf> Hugglesworth: Huh?
19:13:36 <shachaf> Oh.
19:13:45 <shachaf> Regex isn't a data constructor, is it?
19:13:47 <Hugglesworth> so how do I get the default something from a data?
19:13:50 <Hugglesworth> yeah
19:13:59 <Hugglesworth> not sure
19:14:15 <shachaf> Default something?
19:14:23 <Hugglesworth> data Regex = Regex (ForeignPtr PCRE) CompOption ExecOption
19:16:07 <Hugglesworth> again, I'm probably just being retarded
19:16:13 <fryguybob> Hugglesworth:  mkRegex ""  ?
19:16:29 <Hugglesworth> haha
19:16:37 <Hugglesworth> type's right
19:16:39 <Hugglesworth> thanks
19:17:24 <Hugglesworth> Couldn't match expected type `Text.Regex.Regex' with actual type `Text.Regex.PCRE.String.Regex' >_<
19:20:21 <fryguybob> Hugglesworth:   makeRegex ""  perhaps?
19:21:16 <Hugglesworth> seems to work
19:21:32 <Hugglesworth> thanks
19:21:42 <Hugglesworth> apparently my hoogle foo is crap
19:22:01 <shachaf> @hoogle foo
19:22:01 <lambdabot> Text.XHtml.Frameset tfoot :: Html -> Html
19:22:01 <lambdabot> Text.XHtml.Strict tfoot :: Html -> Html
19:22:01 <lambdabot> Text.XHtml.Transitional tfoot :: Html -> Html
19:22:55 <Hugglesworth> :p
19:23:17 <lpsmith> So should a foreign call to something that traverses a linked list be "safe" or "unsafe"?   Part of the problem is that the C code isn't mine,  and I'm not sure how big the linked list typically is or how many cache misses it might entail.  (I would suspect that it should be pretty good with regard to the cache.)
19:32:36 <lpsmith> is there a way to get gitit to bind to the localhost address only?
19:38:04 <wagle> lpsmith: i use my firewall
19:38:16 <lpsmith> wagle :-/
19:38:20 <wagle> should be a better way
19:38:24 <lpsmith> I suppose that works,  but yeah
19:38:31 <lpsmith> there should be a better way
19:47:27 <wagle> how do you tell which import imported a symbol?
19:47:36 <mrrk> @source foldl'
19:47:36 <lambdabot> foldl' not available
19:48:03 <mrrk> does anyone know the best place to go to read the source of a module such as Data.List?
19:48:15 <shachaf> @google Data List hs
19:48:16 <lambdabot> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/Data-List.html
19:48:16 <lambdabot> Title: Data/List.hs
19:48:26 <shachaf> 6.10.2 -- might be a bit outdated.
19:48:34 <shachaf> @source Data.List
19:48:34 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
19:49:25 <mrrk> thanks!
19:51:35 <applicative> mrrk depending how you installed it, you may have html documentation of the libraries that come with the ghc
19:53:49 <applicative> mrrk if you're lucky you can find it with e.g.  locate ghc/html/libraries/doc-index.html
19:55:48 <MatrixFrog> wagle, keep removing them one by one until you get a "xxx is not defined" error?
19:56:29 <wagle> lpsmith: from what I can tell, the binding address is hardwired to iNADDR_ANY
19:57:19 <lpsmith> thanks wagle
19:57:22 <argiopeweb> Possibly the coolest mug of all time.  Do want.  http://imgur.com/a/ZypC3#7XHfH
19:57:43 <wagle> so a source mod is still possible, but you'd have to change happstack (http://www.happstack.com/docs/6.0.0/happstack-server/src/Happstack-Server-Internal-Listen.html)
19:57:44 <lpsmith> wagle, to answer your question,  there is --ddump-minimal-imports
19:58:05 <lpsmith> interesting :)
19:58:29 <wagle> change listen
19:58:47 <wagle> conf only has a port selector
19:59:10 <lpsmith> or rather,  -ddump-minimal-imports
19:59:15 <wagle> (i found the module by guessing)
19:59:34 <lpsmith> that'll let you find out what it was imported from.  Another alternative is Hayoo or Hoogle.
19:59:48 <lpsmith> Unfortunately,  Haskellers don't have the best tools in many respects :-/
20:00:23 <lpsmith> Snap allows you to bind to a specific address
20:00:57 <lpsmith> wagle,  you should also be able to load the file in ghci and then use :info
20:01:06 <lpsmith> that should do it as well
20:01:48 <wagle> this is gitit..  it gets made with all sorts of command line options
20:02:20 <wagle> was trying to find the simpleHTTP it was using..  found it in happstack
20:02:53 <wagle> oh wait, it was the plugins that were mysterious..
20:04:39 <lpsmith> happstack should be able to let you bind a specific port though
20:04:50 <lpsmith> err, happs
20:05:17 <lpsmith> without modifying happs
20:07:06 <lpsmith> err, happstack,  I need to go to becd
20:08:18 <wagle> lets you bind to port, but not addr
20:08:43 <wagle> listenon on that url i gave
20:09:10 <wagle> listenOn
20:10:13 <lpsmith> well, you could bind to a specific address using simpleHTTPWithSocket
20:10:22 <lpsmith> a little ugly, but doable
20:13:32 <wagle> all i know is http://hackage.haskell.org/packages/archive/happstack-server/0.3.3/doc/html/Happstack-Server-SimpleHTTP.html
20:20:17 <poltak> hello
20:22:11 <poltak> Very new to Haskell here. My Algorithms teacher spent a good hour talking to me about it, so I thought I might check it out.
20:22:27 <poltak> What kind of things is Haskell used for?
20:22:42 <Rotaerk> writing software
20:22:46 <knkumar> anything mate
20:22:46 <c_wraith> poltak: it's a fun language.  general-purpose, though libraries in some areas (like graphics/sound/games) are kind of meager
20:23:11 <knkumar> haskell is a functional programming language
20:23:19 <Jafet> Or writing software that writes software
20:23:37 <danharaj> Haskell is general purpose and compiled.
20:23:38 <knkumar> and based on the turing machine model.....it can do wat every other language does
20:23:58 <danharaj> So you can see it anywhere from systems programming to data processing to development tools... etc.
20:23:59 <Rotaerk> it's not based on the turing machine model...
20:24:20 <Rotaerk> it's turing complete, sure...
20:24:32 <poltak> So why do you guys like Haskell over more popular/non-functional languages?
20:24:57 <knkumar> dude its simple/easy as hell to program stuff
20:24:57 <mauke> danharaj: haskell is not compiled
20:25:28 <Rotaerk> isn't that what the GHC does? compile haskell?
20:25:28 <danharaj> mauke: Sorry. The only way anyone actually uses Haskell is compiled.
20:25:30 <mauke> poltak: it's often fun to use
20:25:38 <mauke> danharaj: except for hugs
20:25:49 <danharaj> mauke: People still use hugs? Interesting.
20:26:14 <mauke> preflex: seen ndm
20:26:14 <preflex>  ndm was last seen on #haskell 143 days, 8 hours, 17 minutes and 11 seconds ago, saying: if you don't, then there was a parse error
20:27:06 <mafs> poltak: There are lots of reasons/links to reasons in here: http://www.reddit.com/r/haskell/comments/h6r6t/ask_raskell_succinctly_why_haskell_for_a_project/
20:27:37 <poltak> Well I'm very new to programming (maybe 7 months experience) and I've been taught Java at university. Is giving Haskell a go advised for a newbie like me? Note: I find programming extremely fun and do like challenges
20:27:41 <mgsloan> http://www.youtube.com/watch?v=gn_ZZiXVlNY
20:27:56 <poltak> or should I get more experience with basics of imperitive languages?
20:27:59 <mgsloan> (A little haskell tool I've been working on lately ^)
20:28:00 <poltak> first
20:28:02 <danharaj> poltak: The less ingrained imperative programming is in your psche, the easier learning Haskell will be.
20:28:12 <mauke> poltak: your exposure to java may make things harder :-)
20:28:31 <danharaj> It's also worth noting that you can write in an imperative style in Haskell, in fact it's easier than writing in less expressive languages because of the extra power you have.
20:28:44 <poltak> Haha, I've seen a few similar responses from Googling around a bit this morning :P
20:29:29 <danharaj> poltak: the only things you need are patience and practice to learn Haskell.
20:30:21 <poltak> But yeah, from the way more experienced people have been talking up functional programming, it seems like a good use of my time to learn this
20:30:39 <shachaf> I don't know if knowing imperative languages really makes learning Haskell harder.
20:31:10 <poltak> anyway, what are some good resources for learning haskell (apart from the main website)
20:31:19 <mgsloan> http://www.youtube.com/watch?v=gn_ZZiXVlNY <- a little bit like yaxu's Text, except written in haskell and intended for general purpose
20:31:24 <Rotaerk> poltak, "learn you a haskell for great good"
20:32:52 <dibblego> my 10 year old is currently writing a review for the publisher of LYAH
20:32:57 <Jafet> shachaf: knowing one imperative language probably does.
20:33:25 <poltak> so, any good resources for learning haskell?
20:33:30 <jmcarthur> dibblego: you have an awesome 10 year old
20:33:34 <Rotaerk> dibblego, .. lol.
20:33:38 <danharaj> @where lyah
20:33:38 <lambdabot> http://www.learnyouahaskell.com/
20:33:43 <danharaj> @where rwh
20:33:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:33:52 <Rotaerk> poltak, did you think I was joking?
20:34:07 <Rotaerk> dibblego, so your 10 yo has learned haskell?
20:34:16 <poltak> sorry :P i didn't quite understand, Rotaerk
20:34:20 <poltak> I get you now
20:34:24 <poltak> Thanks a lot guys
20:34:27 <shachaf> dibblego: Wait, is that the same person as your 6 year old a few years ago?
20:34:29 <danharaj> no problem
20:34:37 <dibblego> prolly
20:34:43 <poltak> will do a lot of reading up over the next days. Looks like fun
20:34:45 <dibblego> I have two boys, 8 and 10
20:34:46 <danharaj> poltak: don't be afraid to paste your code and ask questions about it in here if you have problems.
20:34:47 <Rotaerk> I'm not a big fan of Real World Haskell, because it seems overly polluted with ... real-world examples
20:34:57 <danharaj> Rotaerk: heh.
20:34:58 <shachaf> dibblego: That's ridiculous.
20:35:06 <danharaj> Personally I learned through YAHT
20:35:17 <dibblego> they like being 8 and 10, take it up with them
20:35:18 <Rotaerk> what's that
20:35:26 <danharaj> @where yaht
20:35:26 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
20:35:31 <poltak> alright well I'll hopefully be back here soon :) gotta go now anyway, so thanks a lot for your help and patience with my newbie questions.
20:35:33 <poltak> much appreciated
20:35:40 <shachaf> YAHT. :-(
20:35:52 <danharaj> why so sad
20:36:19 <Rotaerk> first link goes nowhere
20:36:53 <stepcut> lpsmith: yeah, you have to use, simpleHTTPWithSocket, which is the catch-all for handling things like IPv6, binding to a specific address, or binding to a port as root and the dropping priveledges
20:37:54 <stepcut> lpsmith: the network library leaves a bit to be desired when it comes to consistency across platforms and compilation with and without ipv6
20:38:04 <Rotaerk> examples are fine, but you shouldn't introduce new concepts in them, and you should try to keep the examples simple and unobtrusive
20:39:49 <wagle> poltak: the only way you lose while trying to learn haskell is to learn the wrong lesson if you have trouble (that being that haskell should be avoided)..  haskell is very different from java, and will expand your thinking about programs
20:40:20 <lpsmith> stepcut: I remember one hangup I ran across with the Network library is that you really shouldn't use the nice high-level interface with Network.Socket, even though the types are the same
20:40:20 <wagle> hmm..  i was in scrollback..  oh well
20:40:28 <lpsmith> I was a bit annoyed by that :)
20:40:32 <dibblego> I teach haskell to java guys several times per week, about to start in 1h13m
20:41:10 <medfly> you are a teacher?
20:41:58 <dibblego> I work for a product company and I teach part-time for a university and voluntarily, but also teach where I work at this product company
20:42:11 <medfly> you are a teacher
20:42:33 <dibblego> we all are to some extent, I often hope
20:42:33 <medfly> ... just not the extremely poorly paid kind
20:42:56 <m3ga> dibblego: how many haskell guys are you pushing into the world?
20:43:12 <dibblego> I have a company of them now
20:43:20 <dmwit> oh hi dibblego
20:43:26 <m3ga> wow, thats great
20:43:33 <dibblego> my children are self-motivated, I don't do much, he just picked up the book and I told him I had to write a review (it was sent for free)
20:43:42 <dibblego> hello dmwit
20:45:37 <dmwit> oh no
20:45:52 <dolio> He's writing a book, too.
20:45:54 <dmwit> Internet stalking shows you're in a whole different continent. =(
20:46:09 <dmwit> Now I can't guilt you into coming to Hac Phi. =P
20:46:14 <dolio> Not on Haskell, though.
20:46:17 <dibblego> yes, the voluntary teaching I do is with Brisbane Functional Programming Group (bfpg.org)
20:46:21 <dibblego> ha
20:46:42 <shachaf> dmwit: What if he guilts you into coming to AusHac?
20:46:48 <dolio> Oh right, Hac Phi....
20:47:12 <dmwit> shachaf: Worse things could happen!
20:47:15 <lpsmith> ok,  just how much overhead is associated with safe calls versus unsafe calls?   I don't have a very good feel for how much work a C function should do before it should be declared unsafe.
20:47:49 <jmcarthur> lol, i just noticed the monad comprehension in the haskell reddit logo. i bet that's been there for a while
20:48:17 <dmwit> Since shortly after the announcement, yep. =)
20:48:22 <gwern> lpsmith: I know I'e seen numbers on -cafe
20:48:27 <shachaf> dmwit: If you successfully guilt me into going to Hac Phi, I'll go to Hac Phi.
20:48:32 <dmwit> dolio: Boston is close!
20:48:36 <dmwit> Maybe I can guilt you into coming.
20:48:44 <dmwit> shachaf: ooooo
20:48:49 <dolio> Maybe.
20:49:11 <dmwit> shachaf: Wow, Italy?
20:49:21 <lpsmith> gwern: yeah, I eventually need to do some benchmarking,  but at the moment I'm reading C source and getting the obvious ones right
20:49:28 <shachaf> dmwit: Italy? No, California.
20:49:39 <dmwit> oh, huh
20:49:55 * shachaf wonders where Italy came from.
20:50:04 <dmwit> /whois
20:50:10 <Axfan> ok can someone please explain how to use booleans
20:50:13 <Axfan> this is madness
20:50:16 <Axfan> haha
20:50:20 <jmcarthur> > True
20:50:20 <lambdabot>   True
20:50:22 <danharaj> Axfan: case ... of
20:50:25 <shachaf> dmwit: Oh. That's just the IRC server I'm connected to.
20:50:28 <dmwit> Oh, your server is in Italy.
20:50:30 <dmwit> Yeah, that was dumb.
20:50:46 <shachaf> My IRC client is in VA, it seems.
20:50:50 <Axfan> hmm
20:50:52 <lpsmith> but of course, the problem with that is that GHC changes,  and so a well-developed intuition for one version can be totally faulty the next
20:50:53 <Axfan> i treid usng true
20:50:57 <dmwit> Well, heck, if you made it all the way to California from Italy, you might as well take a puddle-jumper over to Philadelphia!!
20:50:58 <Rotaerk> as Robert Harper would have it, you shouldn't use booleans
20:50:59 <jmcarthur> > if True then 5 else 6
20:51:00 <lambdabot>   5
20:51:04 <shachaf> Axfan: Church-encode them.
20:51:05 <jmcarthur> > if False then 5 else 6
20:51:06 <lambdabot>   6
20:51:19 <shachaf> @let true x y = x; false x y = y
20:51:19 <Axfan> what i tried to do
20:51:20 <lambdabot>  Defined.
20:51:31 <jmcarthur> > true 5 6
20:51:33 <lambdabot>   5
20:51:34 <jmcarthur> > false 5 6
20:51:36 <Axfan> was declare the variable was false
20:51:36 <lambdabot>   6
20:51:39 <danharaj> > case True of True -> "NO"; False -> "YES";
20:51:40 <lambdabot>   "NO"
20:51:41 <Axfan> but when i changed it like this
20:51:46 <Axfan> True <- isRunning
20:51:58 <danharaj> That's not what you think it is!!
20:51:59 <jmcarthur> you can't change a variable in haskell
20:52:03 <Axfan> nooooooo
20:52:08 <shachaf> Ban the arrow!
20:52:23 <danharaj> Axfan: post your code
20:52:24 <ddarius> Rotaerk: You shouldn't use booleans.
20:52:25 <danharaj> hpaste.org
20:52:30 <Axfan> ok its not that complicated
20:52:35 <Axfan> i just want to set a varible from false to true
20:52:39 <Axfan> variable*
20:52:46 <jmcarthur> also, all you're doing there is pattern matching on the result of isRunning (assuming isRunning has type   Monad m => m Bool   or perhaps a specific monad like   IO Bool)
20:52:51 <dmwit> Variables don't vary.
20:52:55 <dmwit> So want something else.
20:52:56 <shachaf> "set a variable"? What does that even mean?
20:53:00 <jmcarthur> variables do vary, they just don't change
20:53:05 <Axfan> ahh
20:53:27 <danharaj> Axfan: the solution depends on the context of what you are doing.
20:53:35 <Axfan> im just trying to set a boolean
20:53:39 <Axfan> and change it to true or false
20:53:40 <jmcarthur> Axfan: bind a new identifier instead
20:53:54 <jmcarthur> you can't change it
20:54:03 <jmcarthur> it's whatever you set it to for all time
20:54:06 <dmwit> shachaf: You have an awful lot of empty profiles on social networking sites. =D
20:54:19 <Axfan> ok so how do i make loops then?
20:54:23 <jmcarthur> recursion
20:54:41 <shachaf> dmwit: I do?
20:54:41 <ddarius> The one true way.
20:54:44 <Axfan> ok
20:54:50 <Axfan> like calling a function inside itself?
20:54:59 <danharaj> pretty much.
20:55:08 <Axfan> sweet i did that in c alot
20:55:12 <Axfan> but how do i make it quit doing that
20:55:16 <Axfan> like if they close the window
20:55:18 <jmcarthur> base case
20:55:20 <Axfan> i was just going to set the bool to false
20:55:36 <jmcarthur> > let fac 0 = 1; fac n = n * fac (n-1) in fac 5
20:55:36 <ddarius> Great googly moogly.
20:55:36 <Axfan> ok
20:55:36 <lambdabot>   120
20:55:49 <danharaj> ddarius: aren't you too old to know about that show :[
20:56:04 <Axfan> ill just read up about recrusion
20:56:05 <jmcarthur> Axfan: notice how in one case i'm just returning a result instead of performing a recursive call
20:56:22 <Axfan> yes
20:56:40 <Axfan> ok i think i have it now
20:56:45 <Axfan> thank you all
20:56:50 <jmcarthur> that's how you get out of recursion. you just have a case (typically called a "base case") where you don't recurse
20:56:58 <shachaf> dmwit: Hmm, I suppose I do have a few.
20:57:02 <Axfan> like default in a switch statement
20:57:07 <jmcarthur> not really
20:57:13 <Axfan> LIES AND SLANDER BAIL
20:57:22 <danharaj> I think whbt
20:57:22 <jmcarthur> alrighty then...
20:57:23 <MatrixFrog>  wtf
20:57:36 <lpsmith> gwern: I don't suppose you happen to know what to google to find said numbers?
20:58:16 <ddarius> danharaj: I have no idea what you're talking about.  That expression goes back to before I was born.
20:58:54 <danharaj> ddarius: then it has an older etymology than I knew
20:59:00 <dmwit> Aren't you a little too old to be underage drinkers?
21:00:07 <ddarius> danharaj: Most words do.  It's actually scary that certain nowadays "just normal" words were actually slang not too long ago, and a lot of slang is really old.
21:00:33 <shachaf> ddarius: Can you give some examples?
21:00:49 <danharaj> ddarius: I think it's scarier that people do not recognize the creation of new words as a valid cultural process
21:00:52 <danharaj> (some people)
21:00:56 * shachaf has never heard "great googly moogly" except coming from ddarius.
21:02:16 <ddarius> shachaf: It's pretty easy to find slang that has rather old roots.  The former case though is tricky because you don't even know to look.  I've run across a few examples of the former, but I, unfortunately, don't remember them off hand.
21:03:41 <ddarius> An example not in diction, though, is the notion of unconscious thought.
21:06:42 <ddarius> A not very compelling example is "alright."
21:11:44 <dmwit> So, Axfan, think you'll come to the hackathon this summer?
21:14:08 <ddarius> dmwit: Get 'em while they're young.
21:14:25 <dmwit> ;-)
21:19:37 <BMeph> "OK"
21:28:54 <RWayne> is xmonad written purely on haskell??? :-o
21:29:53 <Zao> RWayne: cabal unpack xmonad  and see yourself :D
21:30:49 <Zao> RWayne: Sure looks that way.
21:31:10 <Zao> Of course, some of the libraries it depends on might be using a decent bit of FFI and might have some native bits, like X11, etc.
21:33:14 <robinhoode> Is there  a list of all the impure functions in the standard library somewhere?
21:33:55 <shachaf> @hoogle IO
21:33:55 <lambdabot> module Data.Array.IO
21:33:55 <lambdabot> module System.IO
21:33:55 <lambdabot> Prelude data IO a
21:34:37 <shachaf> robinhoode: Why do you want such a list?
21:34:40 <dmwit> No.
21:34:57 <shachaf> Does id count as "impure"?
21:35:12 <MatrixFrog> why would it
21:35:54 <shachaf> id :: IO String -> IO String
21:36:10 <MatrixFrog> i guess...
21:36:20 <MatrixFrog> it doesn't have side effects though
21:36:29 <MatrixFrog> it's just the thing it's taking as input has side effects
21:36:31 <shachaf> No function has side effects.
21:36:53 <MatrixFrog> and id is a function
21:37:05 <MatrixFrog> so i would definitely think of id as pure
21:37:11 <MatrixFrog> but then i'm a newbie
21:37:13 <robinhoode> Sorry, poor choice of words.. I guess I should ask for the list of impure methods or impure procedures.. whatever you want to call them
21:37:34 <MatrixFrog> things of type "IO a" for some a?
21:37:51 <MatrixFrog> you may also want things of type (a -> IO b) for some a and b
21:37:54 <shachaf> robinhoode: Why do you want that list?
21:38:03 <MatrixFrog> even though they are themselves pure
21:38:14 <shachaf> MatrixFrog: a = IO String, b = String. id is impure!
21:38:32 <robinhoode> I'm pretty sure you can do side effects outside the IO monad. I think it has to be in some kind of monad, though
21:38:46 <robinhoode> impurity is more than just type signature
21:38:47 <shachaf> Oh, here we go again.
21:38:55 * shachaf grumbles.
21:39:06 <dolio> What are these side effects?
21:39:37 <robinhoode> Maybe there is a better way to put this. Since side-effects are not as well defined...
21:39:40 <KirinDave> So i found this squirreled away on the haskell wiki: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
21:39:50 <KirinDave> Has anyone rewritten this with iteratees?
21:39:57 <MatrixFrog> shachaf ok but you know what he means
21:40:11 <MatrixFrog> you wouldn't write the type of id as IO String -> IO String
21:40:17 <MatrixFrog> you would write it as a -> a
21:40:20 <MatrixFrog> good point though
21:40:25 <robinhoode> f . (g . h) == (f . g) . h    <== works only when f,g, and h are pure functions
21:41:03 <dolio> It does?
21:41:06 <robinhoode> Yes
21:41:11 <jmcarthur> (id :: IO String -> IO String) . ((id :: IO String -> IO String) . (id :: IO String -> IO String)) == ((id :: IO String -> IO String) . (id :: IO String -> IO String)) . (id :: IO String -> IO String)
21:41:25 <ddarius> robinhoode: All functions are pure in Haskell.
21:41:50 <robinhoode> Even things like unsafePerformIO?
21:41:51 <dmwit> All except the ones whose name starts with "unsafe", of course.
21:42:02 <jmcarthur> unsafePerformIO is *cough* not a function
21:42:09 <shachaf> ALl functions are also monadic in Haskell, by the way.
21:42:22 <shachaf> s/L/l/ #
21:42:30 <robinhoode> jmcarthur,  Okay, that's probably my shitty terminology again
21:42:32 <jmcarthur> shachaf: in that you can implicitly stick an Identity wrapper around the result?
21:42:44 <robinhoode> jmcarthur, What do they call the things that are not associative, anyways?
21:42:57 <jmcarthur> umm... "not associative"?
21:43:23 <dolio> What things?
21:43:32 <robinhoode> What I mean is, what does one actually "call" unsafePerformIO? Is it a method? A procedure?
21:43:39 <ddarius> robinhoode: Binary operations are what are or are not associative, i.e. (.).  In the above you wouldn't say "f,g,h are not associative."
21:43:44 <jmcarthur> you mean not referentially transparent? not pure?
21:43:48 <robinhoode> ... within the standard Haskell literature..
21:44:03 <jmcarthur> robinhoode: (people typically call unsafePerformIO, it's just that it's incorrect to do so)
21:44:09 <jmcarthur> *call it a function
21:44:28 <shachaf> jmcarthur: As in, instance Monad (r ->).
21:44:35 <jmcarthur> shachaf: ah!
21:45:01 <jmcarthur> a different from the norm use of the word "monadic"
21:45:14 <robinhoode> I love how mathematically rigorous everyone is..!!  Just had a simple question, though..
21:45:15 <jmcarthur> (no less arbitrary at least)
21:45:23 <shachaf> jmcarthur: More reasonable than <robinhoode> I'm pretty sure you can do side effects outside the IO monad. I think it has to be in some kind of monad, though
21:47:05 <Jafet> So we eggheads are disconnected from the RealWorld#?
21:47:14 <jmcarthur> robinhoode: a side effect is basically anything that violates referential transparency, btw, so side-effect isn't *completely* undefined. the word "side effect" is also something overloaded to talk about the context-dependent things that monads might abstract, but this isn't the same thing as violating referential transparency
21:47:23 <MatrixFrog> #RealWorld? I'm not familiar with that irc channel
21:47:48 <Luke1> does Data.Binary provide an Applicative instance?
21:48:16 <Luke1> sorry I mean Alternative instance
21:48:58 <jmcarthur> you could check the docs http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html
21:49:10 <jmcarthur> looks like the answer is no
21:50:20 <jmcarthur> robinhoode: it's often simpler in the long run to answer with rigor because it might prempt future questions
21:50:26 <Luke1> the docs don't say it provides Applicative and it does
21:50:32 <jmcarthur> they do say so
21:50:37 <robinhoode> jmcarthur, No, I am aware of that definition, I just wanted to avoid "that way" of thinking about it. I think it's actually a more interesting question to ask exactly when morphisms in the category Hask violate the operation "\circ" on homsets.
21:50:38 <jmcarthur> under "instances"
21:50:55 <KirinDave> Whoah.
21:50:57 <robinhoode> jmcarthur, Is that better?
21:51:05 <Luke1> oh I see, Get does. thanks
21:51:27 <robinhoode> *violate associativity of "\circ", sorry
21:51:31 <jmcarthur> Luke1: if you click on PutM it also says so there
21:51:43 <dolio> Associativity of composition is never violated in Hask, to my knowledge.
21:51:56 <Axman6> binary is designed for parsing from front to back without backtracking. if you need back tracking, check out attoparsec
21:51:57 <Luke1> jmcarthur: thanks - I think Applicative provides Alternative as well
21:52:00 <jmcarthur> (again, aside from unsafe*)
21:52:00 <Luke1> so that works
21:52:05 <jmcarthur> Luke1: no, it doesn't
21:52:08 <robinhoode> But clearly unsafePerformIO can't live in Hask..
21:52:10 <dolio> unsafePerformIO doesn't exist.
21:52:25 <jmcarthur> Luke1: Alternative requires Applicative, but not the other way around
21:52:26 <Luke1> Axman6: thanks
21:52:34 <Luke1> ah gotcha
21:52:38 <Luke1> thanks guys
21:53:16 <dolio> Of course, it can't be violated in Hask, if by Hask you mean some category approximating Haskell.
21:53:18 <robinhoode> dolio, Okay, so it doesn't exist in Hask. What other "Haskell"  "functions" don't exist in Hask?
21:53:20 <dolio> By definition.
21:53:35 <dolio> unsafeCoerce
21:53:59 <jmcarthur> spoon :P
21:54:09 <dolio> That isn't even in any language definition, though.
21:54:22 <jmcarthur> yeah
21:54:24 <robinhoode> Well, right, I've actually been curious if there are any generalizations of categories that allow morphisms to not always satisify associativity of "\circ"..
21:54:47 <dolio> Of course there can be.
21:55:05 <robinhoode> So you see my motivation, I suppose.. I just wanted to know where the theoretical rubber met the applied road
21:55:25 <dmwit> A category without associative composition?
21:55:32 <dmwit> Why, that would just be... abstract NONSENSE!
21:55:47 <dmwit> complete anarchy!
21:55:50 <dolio> You could call it a magmoid if it didn't have identities either.
21:56:12 <robinhoode> dmwit, lol.. didn't see that one coming
21:56:27 <ddarius> Because closure of the binary operation was just -too- much structure.
21:56:38 <dolio> Clearly.
21:57:47 <dolio> I'm sure edwardk will have a package out for them by Saturday.
22:36:29 <Guest54543> @hoogle m (m a) -> m a
22:36:30 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
22:36:30 <lambdabot> Prelude concat :: [[a]] -> [a]
22:36:30 <lambdabot> Data.List concat :: [[a]] -> [a]
22:41:26 <applicative> > join (==) 5
22:41:27 <lambdabot>   True
22:44:19 <ddarius> > join (==) (0/0)
22:44:20 <lambdabot>   False
22:45:03 <jmcarthur> join (==) /= const True    :(
22:45:58 <applicative> that would be too much to hope
22:46:04 <RayNbow`TU> > join (==) undefined
22:46:05 <lambdabot>   *Exception: Prelude.undefined
22:46:06 <applicative> > join (==) even
22:46:07 <lambdabot>   *Exception: (==): No overloading for function
22:46:57 <nodename> > join (==) [1 1]
22:46:58 <lambdabot>   True
22:47:13 <Guest54543> :t join (==)
22:47:15 <lambdabot> forall a. (Eq a) => a -> Bool
22:47:16 <nodename> join (==) [1 2]
22:47:31 <nodename> > join (==) [1 2]
22:47:32 <lambdabot>   True
22:47:38 <nodename> uh oh
22:48:17 <nodename> > join (==) (0 0)
22:48:18 <lambdabot>   True
22:48:32 <c_wraith> > 0 0
22:48:32 <nodename> > join (==) (1 2)
22:48:33 <lambdabot>   0
22:48:34 <lambdabot>   True
22:48:49 <c_wraith> > 1 2
22:48:50 <lambdabot>   1
22:49:28 <applicative> > join 1 2
22:49:29 <lambdabot>   1
22:49:43 <nodename> :t join
22:49:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:51:19 <Axman6> :t join 1
22:51:19 <lambdabot> forall (m :: * -> *) a. (Num (m (m a)), Monad m) => m a
22:53:58 <applicative> who would have expected a monad with a Num instance two stories up?
22:54:11 <ax_> SLANDER AND LIES
22:54:59 <applicative> someday the type system will be so advanced we'll have instance Monad Char
22:55:15 <Axfan> by the way
22:55:18 <Axfan> i love haskell
22:55:59 <jmcarthur> haskell loves you
22:56:02 <Axfan> im going to write a haskell rap
22:56:07 <Axfan> and my rap name will be..
22:56:08 <Axfan> the vim repear
22:56:14 <MatrixFrog> a rapskell?
22:56:23 <Axfan> yep
22:56:26 <Axfan> and the lyrics
22:56:33 <Axfan> idk
22:56:34 <Axfan> yet
22:56:36 <Axfan> its just gonna be awesome
22:57:41 <blackdog> i see someone's dosing the lambdas with lsd again
22:58:30 <Axfan> how should it start..
22:58:41 <Axfan> functional is the way i roll
22:58:57 <Axfan> type declerations are in the past
22:59:01 <Axfan> but that dosnt mean it dosnt run fast
22:59:31 <MatrixFrog> probably hard to rhyme things with haskell
22:59:38 <MatrixFrog> but less hard to rhyme with "haskell curry"
23:00:28 <Axfan> alright this is going to take awhile
23:01:12 <Axfan> how many haskell users run a linux distro?
23:01:16 <Axfan> like percentage wise
23:01:20 <Axfan> seems like alot
23:01:29 <Axman6> lots%
23:01:37 <MatrixFrog> or just windows users are too ashamed to ever mention it
23:01:57 <Axfan> im guessing like
23:01:58 <Axfan> 90%
23:02:00 <Axfan> almost
23:02:01 <Axfan> +
23:02:02 <Axman6> plenty of mac users too
23:02:50 <Axfan> well
23:02:55 <Axfan> goodnight #haskell
23:09:09 <roconnor> I still don't get type class morphisms
23:09:18 <roconnor> isn't it "obvious"?
23:10:01 <roconnor> that type class instances of abstract data types should be the same as the type class instances of the types that they are abstracting?
23:16:09 <finnomenon> how can I rsync "until remote filesystem is full" ?
23:16:37 <finnomenon> I am trying to copy the content of one dir onto a usb drive which is smaller than the content of the directory
23:17:17 <shachaf> finnomenon: There's probably some channel better suited to that question than this one.
23:17:39 <finnomenon> oh, didn't even want to ask in here
23:17:40 <finnomenon> sorry
23:17:42 <Zao> finnomenon: See man page, otherwise try and fail?
23:17:57 <jmcarthur> roconnor: if it seems obvious to you then you have already internalized it and you shouldn't think to hard about it
23:18:02 <jmcarthur> *too hard
23:18:09 <roconnor> or I'm missing something important :D
23:18:26 <jmcarthur> i doubt you are. it really is simple, i think
23:19:06 <jmcarthur> i think the key part of understanding it is that it's a design principle, not just mathematical fluff
23:19:20 <jmcarthur> not everybody designs with this sort of thing in mind all the time
23:19:33 <roconnor> I'm reminded of Dijkstra's(?) paper on structured programming.  He got two reviews: One said it should be rejected because it is obvious and everyone programs that way already, and the other said it should be rejected because it is a retarded way of programming and no one woul ever write programs that way.
23:19:44 <jmcarthur> exactly!
23:21:52 <ddarius> roconnor: The choice of which instances for the type that's being "abstracted" is not canonical.  The key is really making a choice not just of the target semantic domain, but also the particular algebriac structure you want on it.
23:22:49 <roconnor> ya, that is what I meant.  Though I didn't state myself clearly.
23:23:00 <ddarius> It's certainly the case that if we impose some algebraic structure on the syntax, compositionality will induce -an- algebraic homomorphism, but not necessarily the one you want.
23:24:48 <ddarius> roconnor: Well Conal's papers are somewhat misleading in this regard in that the use of the type class system partially hides the arbitrariness of the choice of algebraic structure, though some cracks are evident by Conal's use of newtypes like First.
23:25:43 <ddarius> Basically what it comes down to is not to just choose a semantic domain, but to choose an entire semantic algebra and verify that your semantics is a homomorphism to -that- algebra.
23:26:12 <roconnor> ddarius: clearly this is what everyone does when programming ... right?
23:26:57 <roconnor> they have some abstact notion of their data that they want to model and operations on it.
23:27:05 <roconnor> then you implement it using an abstract data type.
23:27:11 <ddarius> roconnor: Few people even consider what the semantic domain would be in any coherent way, let alone what algebraic structure it should support.
23:27:19 <roconnor> Ya ... :(
23:27:42 <roconnor> To be fair I don't do it in any coherent way either.
23:28:14 <roconnor> This also explains why some people don't get why mergeing in DVCSs ought to be associative.
23:30:00 <jmcarthur> heck, this explains why some people don't understand patch theory at all and others don't even see what the big deal is
23:30:21 <jmcarthur> (the latter group understanding it, that is)
23:36:49 <roconnor> Grr the subject irks me so.  People say the prefer git's merging because it is "predicable" when it fuzzy merging is the algorithm that is unpredicable by it's nature, and there is nothing fuzzy about history away merging.  It always finds the right line to patch, or finds a conflict.
23:37:03 <roconnor> *history aware
23:37:31 <dolio> roconnor: By the way, people at work have been in a big huff about merging between branches and cherry picking and ordering of patches and whatnot lately.
23:37:51 <dolio> I don't know if they're actually concerned about 3-way merge problems, but they might be.
23:38:27 <dolio> I thought that was an amusing potential counter-example to people who say that git behaves fine.
23:38:53 <dolio> Since these aren't people prone to complaining about purely academic issues, as far as I know.
23:38:55 <jmcarthur> i just wrote another blog post that addresses another monad for that same event model. funny that that kind of thing is what was just discussed above (multiple choices)
23:39:19 <dolio> (Of course, it's mercurial, not git, but same problem.)
23:40:44 <Eduard_Munteanu> I think darcs people come from the perspective history is less important if you wind up with the same content, while Git people say "oh, it's fine, after all you've got different history".
23:41:09 <MatrixFrog> i guess i'm a "git person"
23:41:21 <MatrixFrog> i would say the git philosophy is that the history is the most important thing
23:41:31 <MatrixFrog> so you have to start with that. then everything else is secondary
23:41:31 <Eduard_Munteanu> I kinda am too, though the patch theory bits are interesting.
23:41:53 <dolio> Yes, that's why there's a command to arbitrarily rewrite the history, right? :)
23:42:05 <MatrixFrog> that's why you're not supposed to use that command
23:42:07 <Eduard_Munteanu> Heh.
23:42:24 <jmcarthur> i'm in the patch camp. i like the idea that a patch can be applied to fairly different repositories without losing identity
23:42:32 <MatrixFrog> and yet i'm working with git-svn so i use it every day :(
23:43:57 <dolio> It seems pretty popular for a command you're never supposed to use.
23:45:03 <MatrixFrog> probably because people are still scared of merging
23:45:21 <MatrixFrog> due to having worked with subversion
23:45:28 <MatrixFrog> or just due to the fact that it's scary
23:45:30 <MatrixFrog> or something
23:45:51 <Eduard_Munteanu> Dunno, I don't think it's that popular for rewriting history per se, but there are some corner cases where it can be useful.
23:46:05 <MatrixFrog> i assume we're talking about git rebase?
23:46:06 <Eduard_Munteanu> Like if you've got some repo hosting huge binaries.
23:46:10 <Eduard_Munteanu> No.
23:46:17 <Eduard_Munteanu> Or are you?
23:46:21 <dolio> That's what I'm talking about.
23:46:24 <Eduard_Munteanu> git rebase is absolutely fine.
23:46:33 <MatrixFrog> well it rewrites history
23:46:42 <jmcarthur> well, there's also a reason that darcs is getting a rebase command soon, too
23:46:45 <MatrixFrog> so it could potentially create bugs
23:46:55 <MatrixFrog> in theory anyway. not that i've ever seen it happen
23:46:57 <Eduard_Munteanu> Rebase is fine as long as you don't go prior to origin/master ;)
23:47:20 <MatrixFrog> anyway, what were you talking about
23:47:23 <Eduard_Munteanu> I thought you guys were talking about git filter-branch or that sort of evil stuff
23:48:05 <MatrixFrog> oh ok
23:48:28 <Eduard_Munteanu> Anyway that could be useful, as I said, when you have a repo hosting huge binaries and you want to prune older blobs away from time to time.
23:49:05 <Eduard_Munteanu> (which is kind of a workaround rather than a fix)
23:50:36 <Eduard_Munteanu> If OTOH if you think of rebase as a "my patches"-editing tool, like Quilt or whatever there was before Git, then it's alright.
23:52:47 <roconnor> associative mergeing has very little to do with darcs vs git other than the fact that darcs is assocative while git is not.
23:53:09 <roconnor> git could do history aware merging if it wanted to
23:53:33 <jmcarthur> but then it would be slow and people would flock to darcs, right? :P
23:53:36 <roconnor> And you'd think a model that emphasises history so much would want to have history-aware merging
23:53:58 <MatrixFrog> mmmk good to know. learning about darcs is something i definitely want to do... after i learn haskell i guess
23:54:30 <roconnor> jmcarthur: I don't know if it is slower.  I guess it needs more data, which might mean more data needs to be transmitted over the network which would be slow
23:54:47 <roconnor> but if the branches are all local, I wouldn't be shocked if history aware merging was faster
23:54:55 <MatrixFrog> ...? git never transmits data over the network in order to do a merge
23:55:08 <roconnor> there we go
23:55:36 <roconnor> History aware merging doesn't have to search through the file to find where to apply a patch
23:55:39 <MatrixFrog> there are things like git pull which is shorthand for fetch-and-merge but that's hardly fair to say that it uses the network for the merge
23:55:49 <roconnor> it computes the place to patch.
23:56:25 <roconnor> so which is slower, fuzzy merging or computing the exact place to patch?  I don't know.  It probably depends on the circumstances.
23:57:01 <roconnor> and the meta-data cached at each node in the history
