00:00:36 * frerich has the theory that the less known a language is, the more opinionated its users speakers
00:00:39 <frerich> are
00:01:13 <NihilistDandy> Truth
00:01:13 <NihilistDandy> Except for C
00:01:13 <NihilistDandy> And Java
00:01:20 <NihilistDandy> Those guys are loud
00:01:55 <Twey> And Ruby
00:02:18 <Twey> And when was the last time you encountered a militant Factor programmer?
00:02:29 <Twey> And C++
00:02:30 <roconnor> frerich: as a group or cult diminishes in members, usually the more moderate people leave first.  The remaing members are usually the members holding the most extreme views.
00:03:48 <NihilistDandy> roconnor: And of course all new members are extreme
00:04:56 <roconnor> NihilistDandy: no.  What I said only applies to groups diminishing in size AFAIK
00:05:20 <NihilistDandy> roconnor: Never known anyone who's joined a cult, eh?
00:05:21 <roconnor> so it is either only a partial answer to frerich theory, or a refined version.
00:06:04 <roconnor> NihilistDandy: no.  I didn't said that new members are never extreme.
00:06:42 <NihilistDandy> I dispute your use of usually. :/
00:06:52 <NihilistDandy> It is logically meaningless
00:07:04 <danharaj> it is not meaningless
00:07:06 <danharaj> it is vague
00:07:08 <danharaj> difference.
00:07:41 <roconnor> NihilistDandy: in this case take usually to mean "more often than not"
00:07:54 <NihilistDandy> roconnor: What's your sample size?
00:07:55 <NihilistDandy> :D
00:08:05 <NihilistDandy> I'm sorry I'm just being purposely obtuse
00:10:40 <frerich> roconnor: Is this effect with groups diminishing in size just a personal observation, or does it have a name? One explanation which came to my mind was that in those cases where people voluntarily decide to use a lesser known language, they do so because they actually care a lot about languages (which kind of implies having a strong opinion on any other languages [and their flaws because of which the lesser known language was chosen]).
00:11:13 <frerich> Is just noticed something like that with operating systems and programming languages, maybe there is a general pattern.
00:16:27 <earthy> frerich: your observation could be made more general yes
00:17:39 <NihilistDandy> Though that suggests that Haskell users are becoming less opinionated
00:18:57 <roconnor> frerich: I can't find it now, but I read it a while ago when some cult's prediction didn't come true, and then afterwards the cult became even more radical.
00:19:50 <roconnor> frerich: this strange fact was explained in the article by the specualting? that the moderate members left.
00:20:01 <roconnor> maybe they had some hard facts, I don't remember.
00:31:36 <Skola> What do some of you think of node.js / underscore.js?
00:39:05 <unfo-> i like node.js. it tastes like bananas.
00:41:05 <Skola> it's just for javascript monkeys?
00:42:34 <unfo-> i was not aiming for that reference, but lol :D
00:42:45 <nlogax> node projects seem to quickly devolve into callback spaghetti, from what i've seen
00:42:55 <Skola> yeah nlogax I was worried about that
00:43:55 <nlogax> though i haven't seen much, so take that with lots of salt :)
00:44:33 <Skola> I have some solo projects coming up, and I'm still figuring out whether to go with python, Haskell or node :[]
00:44:49 <Skola> they are pretty simple webapps/cms
00:45:16 <Skola> and I've got a lot of time on my hands to learn
00:46:06 <Skola> am familiar with js/python/haskell, enough to be able to get going with web apps on either one
00:46:29 <Skola> but I want to make sure I go with the right stack :[]
00:47:34 <Skola> my criteria are fun and elegant
00:48:00 <Skola> that would mean no JS, were it not that underscore.coffee and coffeescript go a long way in fixing it :D
00:48:59 <Skola> I enjoy Haskell, but am I going to enjoy it for web (with Yewod, Snaps or Happstack)
00:49:59 <nlogax> i saw some coffeescript-like language that compiles to js, with special syntax for making all those callbacks less soupy, looked a bit like `do` syntax
00:50:38 <Skola> yes, and combined with underscore, you can do proper lambda's etc
00:50:52 <Skola> underscore has map/filter/zip/zipWith etc
00:51:30 <Skola> so that's why I was considering node.js, JS isn't that bad anymore, and having it sit on both sides is pretty neat
00:53:57 <Skola> but still, JS is like a ho with herpes compared to Haskell
00:54:09 <Skola> decisions, decisions :[
00:55:11 * hackagebot roundtrip 0.2.0.0 - Bidirectional (de-)serialization  http://hackage.haskell.org/package/roundtrip-0.2.0.0 (StefanWehr)
01:01:11 * hackagebot roundtrip 0.2.0.1 - Bidirectional (de-)serialization  http://hackage.haskell.org/package/roundtrip-0.2.0.1 (StefanWehr)
01:04:12 * hackagebot cryptocipher 0.2.9 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.9 (VincentHanquez)
01:05:17 * hackagebot roundtrip-string 0.1.0.0 - Bidirectional (de-)serialization  http://hackage.haskell.org/package/roundtrip-string-0.1.0.0 (StefanWehr)
01:08:17 * hackagebot roundtrip-xml 0.2.0.0 - Bidirectional (de-)serialization for XML.  http://hackage.haskell.org/package/roundtrip-xml-0.2.0.0 (StefanWehr)
01:12:05 <balor_> Is there any way to get offline haskell documentation, say like "perldoc".  I'd really like to be able to say "haddoc --like-man QuickCheck" or similar for a man page output
01:12:16 <tiglionabbit> hi
01:13:15 <tiglionabbit> so I was reading through BONUS' guide, and I found myself very disappointed by "records".  They generate a bunch of functions, but those functions are only usable with one specific argument pattern, and can't collige
01:13:19 <tiglionabbit> *collide
01:13:49 <tiglionabbit> I would expect that if I created two different record types that both had a "name" field in them, it would create a function that would pattern match each record automatically
01:14:05 <tiglionabbit> instead of raising a compile time exception that I had defined the function "name" twice
01:15:24 <Kaide> Haskell records are a bit...
01:15:35 <kosmikus> tiglionabbit: that's how it is. if you put the different datatypes in different modules and import them qualified, you can still use the same field names.
01:15:40 <Kaide> well they aren't the greatest thing since sliced bread
01:15:58 <Kaide> I think there was an extension that gives you nicer records
01:16:55 <tiglionabbit> I mean, why don't they work like type classes do?
01:17:12 <Kaidelong> they're unrelated
01:17:16 <kosmikus> huh?
01:17:30 <Kaidelong> records are a way to structure data
01:17:31 <tiglionabbit> type classes seem capable of constructing a function that matches patterns that are not defined nearby
01:17:50 <Kaidelong> typeclasses allow you to "overload" functions to work with different data structures
01:17:55 <tiglionabbit> exactly
01:17:58 <tiglionabbit> what if records did that too?
01:18:10 <Kaidelong> OCaml does that
01:18:12 <tiglionabbit> that's exactly what I'd expect records to do anyway
01:18:16 <Kaidelong> not sure why Haskell doesn't
01:18:24 <Kaidelong> probably historical
01:18:36 <Kaidelong> although OTOH
01:18:38 <Kaidelong> how would you type it?
01:18:48 <kosmikus> I don't get it. Why not just use type classes then?
01:19:02 <Kaidelong> you have to have SOMETHING under the type class
01:19:04 <tiglionabbit> kosmikus: because records are handy
01:19:07 <Kaidelong> like say, a record
01:19:13 <Skola> xinput list
01:19:16 <Skola> lol oops
01:19:25 <Kaidelong> (records and typeclasses are orthogonal)
01:19:31 <tiglionabbit> Kaidelong, it could just generate another pattern for the function to match, just like typeclasses do
01:19:41 <Kaidelong> wait wait
01:19:58 <Kaidelong> what do typeclasses have to do with pattern matching? Other than Num and the overloaded strings extension
01:20:25 <kosmikus> neither records nor type classes have anything to do with pattern matching
01:20:26 * osfameron writes the trivial monad
01:20:37 * osfameron had more trouble with the Applicative instance than anything else...
01:20:54 <Kaidelong> which is kind of a wart in the case of rectords perhaps
01:20:56 <tiglionabbit> I don't know why you consider these different things
01:20:57 <xale> if something is an instance of a class, it means it behaves it a way defined by the class. if two records have fields with identical names, that does not mean that their values have the same meanings.
01:21:32 <Kaidelong> tiglionabbit: Type classes do not actually exist as tangible things. They're completely abstract concepts.
01:21:44 <Kaidelong> Data structures like record are what actually get manipulated
01:22:03 <kosmikus> two records having fields of the same name corresponds to two type classes having methods of the same name
01:22:18 <Kaidelong> what you are thinking of is a kind of structural typing
01:22:28 <tiglionabbit> all I'm saying is, when you use a function like "show", it chooses an implementation based on the type of argument you pass it.  Why can't the functions generated by records do that too?
01:22:46 <Kaidelong> oh oops
01:22:55 <Kaidelong> sorry kosmikus
01:23:32 <kosmikus> tiglionabbit: because there's a concept for that in the language already, namely type classes. you can combine a type class with a record type to do what you want.
01:23:55 <quicksilver> tiglionabbit: because that would be useless anyway.
01:23:56 <tiglionabbit> I don't like that I have to give every field in every record type a unique name
01:24:04 <quicksilver> the selector function is only half of what a record label is
01:24:07 <quicksilver> (and it's the boring half)
01:24:18 <tiglionabbit> can I make it not make the selector function?
01:24:26 <tiglionabbit> the fact that they collide is what bothers me
01:24:34 <quicksilver> record labels are also for pattern matching and updating
01:24:38 <Kaidelong> personally I do not generally use record types
01:24:44 <quicksilver> and those parts are not solved by a trivial typeclass.
01:24:54 <quicksilver> they're probably best solved by fclabels or data.accessor
01:24:57 <quicksilver> (pacakges on hackage)
01:24:58 <kosmikus> tiglionabbit: just put them in different modules, then they don't collide
01:25:04 <quicksilver> and you can combine *them* with typeclasses
01:25:11 <Kaidelong> ah accessor was what I was thinking of
01:25:13 <quicksilver> if you actualy have different fields which mean the same thing, in a sense.
01:25:22 <tiglionabbit> what do you guys usually use instead?
01:25:31 <kosmikus> yes, and what quicksilver says. listen to quicksilver. he's usually right :)
01:26:12 <Kaidelong> the most complicated data structure I remember actually using were GADTs
01:26:17 <tiglionabbit> oh, I guess if you put every record type in its own module...
01:26:31 <Kaidelong> usually I guess I'd just use a tuple?
01:26:41 <tiglionabbit> and write the accessors yourself?
01:26:42 <Kaidelong> a type synonym makes it able to explain itself
01:27:06 <Kaidelong> or a newtype if you want type errors or different instances
01:28:10 <tiglionabbit> can you give me an example of how you'd work with a data type that had a lot of fields in it?
01:28:17 <Kaidelong> I figure records would be more useful for things in which you thread complicated states like games. I just haven't used them very often.
01:30:28 <Kaidelong> Err I can't
01:32:01 <kosmikus> Yes, I use record type for situations where I have single-constructor datatypes grouping lots of different fields. I usually have one per module, and I never run into problems with colliding field names, because I never want complicated relationships between different record types anyway.
01:32:38 <Kaidelong> the first big-ish (+1000 line) bit of Haskell I wrote almost entirely consisted of polymorphic stuff and I believe the actual data structure I ended up working with were homogenous matrices, not records
01:33:04 <Kaidelong> Actually I think this might be something to point out
01:33:29 <tiglionabbit> I'm used to duck typing, so having to name the same concept differently in every type would drive me nuts :P
01:33:29 <Kaidelong> you might end up programming with typeclasses anyway, and confine your record-related logic to what it takes to make the instances you need
01:33:52 <tiglionabbit> specifically, "name"
01:34:01 <tiglionabbit> lots of things could use a name
01:34:13 <kosmikus> tiglionabbit: that's a thing you'd do with a type class :)
01:34:20 <Kaidelong> duck typing is a type of structural typing and it can have unpleasant results (like needing ==, ===, ==!== and other things in increasing ridiculousness)
01:34:26 <kosmikus> class HasName a where name :: a -> Name
01:34:30 <tiglionabbit> kosmikus, how would you do that with a type class?
01:34:48 <Kaidelong> you'd make instances for all your records
01:35:08 <tiglionabbit> Kaidelong, yes but how does it know what the name is?  Hopefully there would be a field in the type for it
01:35:15 <Kaidelong> basically the proof obligation is on you that it quacks like a duck. Typeclasses arehow you satisfy the obligation
01:35:24 <Kaidelong> tiglionabbit: Using the "instance" declaration
01:35:30 <Kaidelong> did you cover typeclasses yet?
01:35:41 <tiglionabbit> yes
01:35:47 <tiglionabbit> but like
01:35:50 <Kaidelong> ohay well then in brief
01:36:02 <Kaidelong> a typeclass provides methods that work for every instance of the typeclass
01:36:05 <tiglionabbit> typeclasses don't introduce new data into your type
01:36:09 <Kaidelong> what the method ACTUALLY does depends on the instance
01:36:28 <tiglionabbit> I wouldn't want "name" to just make up a name out of nowhere :P
01:36:30 <Kaidelong> so it will know what the name is when you make an instance and define the relevant method
01:36:56 <tiglionabbit> so just use tuples with a bunch of arbitrarily ordered stuff in there?
01:37:05 <Kaidelong> If you want
01:37:12 <Kaidelong> I'm not against records
01:37:19 <Kaidelong> it may well be reasonable for what you are doing
01:37:29 <tiglionabbit> I don't know what I'm doing :P
01:37:30 <Kaidelong> I just *personally* never have really had much of a need for them
01:37:41 <tiglionabbit> well
01:38:14 <tiglionabbit> lets say I have a database with a bunch of data in it, and I decided to make records that look like the schema or something
01:38:27 <tiglionabbit> that'd probably be best solved a different way, but
01:38:40 <Kaidelong> you wantto make a distinct type for each schema?
01:38:42 <tiglionabbit> in database tables it's common to have columns with the same name in different tables
01:38:59 <tiglionabbit> sure
01:39:06 <Kaidelong> Right, record syntax is just a wee bit broken
01:39:31 <tiglionabbit> oh yeah, I had another question.  Can you curry type constructors in a different order?  Like, can you flip their arguments?
01:39:40 <Kaidelong> @ty flip
01:39:41 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:39:41 <tiglionabbit> like Either a b
01:39:42 <Kaidelong> oh
01:39:46 <Kaidelong> type constructors
01:39:48 <Kaidelong> unfortunately not
01:39:52 <Kaidelong> well
01:39:54 <Kaidelong> I forget
01:39:54 <tiglionabbit> you can'd do Either b ?
01:40:00 <Kaidelong> you may be able to with some extensions
01:40:12 <tiglionabbit> er, (flip Either) a
01:40:23 <Kaidelong> not to type an actual value no
01:40:38 <Kaidelong> hmm I wonder
01:41:01 <tiglionabbit> like what if you wanted to make a functor that mapped over the first field in Either instead of the second one?  Maybe you'd accomplish that in a different way?
01:42:03 <tiglionabbit> hm, wouldn't it be nice if records generated their helper functions as if they were already inside a module?
01:42:12 <Kaidelong> oh
01:42:23 <tiglionabbit> I didn't read the module section yet, but is it possible to make multiple modules in one file?
01:42:26 * hackagebot bindings-K8055 0.1 - Bindings to Velleman K8055 dll  http://hackage.haskell.org/package/bindings-K8055-0.1 (JorisPutcuyps)
01:42:30 <Kaidelong> looks like you can in fact do it
01:42:56 <Kaidelong> are you there conal?
01:44:04 <Kaidelong> wait that's specific for particular types
01:44:17 <Kaidelong> I can't find any evidence that there is a general "Flip" for types
01:44:32 <Kaidelong> :k (`Either` b)
01:44:33 <lambdabot> parse error on input ``'
01:45:11 <quicksilver> well, you can write newtype Flip g a b = Flip (g b a)
01:45:22 <quicksilver> and you wouldn't be the first to have written it if you did :)
01:45:46 <tiglionabbit> =]
01:45:57 <quicksilver> and then you can write the functor instance for Flip Either a (say)
01:46:10 <quicksilver> but it has to be a newtyp
01:46:11 <Kaidelong> oh,that makes sense
01:46:41 <Kaidelong> anyway
01:46:41 <Kaidelong> types cannot be partially applied
01:46:42 <tiglionabbit> do you guys ever consider if this language would be more intuitive if it didn't have currying at all?
01:46:50 <Kaidelong> No
01:46:58 <Kaidelong> currying is ridiculously useful on the value level
01:47:07 <shachaf> tiglionabbit: You mean if it got rid of the function "curry"?
01:47:31 <tiglionabbit> shachaf, not a specific function.  I mean the feature
01:47:45 <quicksilver> tiglionabbit: I don't even understand what you mean by getting rid of currying
01:47:51 <shachaf> I'd say that it's not exactly a feature of the language.
01:47:56 <quicksilver> do you mean functions would be forbidden from returning functions?
01:48:01 <quicksilver> that's the only way I can see to do it.
01:48:04 <kosmikus> no, it's hard to imagine how you could get rid of it
01:48:06 <tiglionabbit> it seems to me like it is only syntactic sugar.  You could accomplish all the same things without currying, just by being explicit and always listing your arguments
01:48:24 <quicksilver> I think you're probably talking about partial application
01:48:26 <tiglionabbit> you can still have functions that return functions
01:48:27 <quicksilver> not currying.
01:48:31 <tiglionabbit> yes partial application
01:48:38 <tiglionabbit> that's not the same thing as currying?
01:48:43 <shachaf> It is not.
01:48:44 <quicksilver> no, it's not.
01:48:48 <shachaf> Do you mean establishing a convention that functions get all their arguments in a tuple?
01:48:56 <Kaidelong> ML does that
01:48:58 <quicksilver> but how do you separate functions that return functions from partial application?
01:48:59 <Kaidelong> I don't like it
01:49:10 <Kaidelong> well, some MLs
01:49:14 <quicksilver> functions that return functions gives you partial application
01:49:25 <quicksilver> it's an automatic consequence
01:49:30 <tiglionabbit> huh?
01:49:36 <shachaf> quicksilver: Well, only if they close over their arguments. :-)
01:49:46 <Kaidelong> anyway you can make a general transformation back and forth between 'a * 'b -> c and a -> (b -> c)
01:49:52 <quicksilver> well 'add' is the function which takes one argument (Int, say) and returns a function (Int -> Int)
01:49:54 <Kaidelong> oh whoops
01:49:56 <Kaidelong> I need sleep
01:50:04 <tiglionabbit> I mean if you define a function as foo a b c = a + b + c, if you wish to use it, you must say foo 1 2 3, not (foo 1 2) 3
01:50:08 <Kaidelong> (a,b) -> c and a -> (b -> c)
01:50:13 <quicksilver> if you permit that version of add - a function which returns a function
01:50:25 <quicksilver> then you immediately have partial applicaiton.
01:50:28 <tiglionabbit> if you wanted the latter, you could say \x = foo 1 2 x
01:50:32 <Kaidelong> tiglionabbit: They're exactly the same thing
01:50:40 <quicksilver> since "add 1" is obviously the partial application of (add 1) 2
01:51:04 <Kaidelong> it wouldn't make sense for function application to be right associative, if that is what you are implying
01:51:11 <kosmikus> tiglionabbit: yes, it's possible to create that (in my eyes, artificial) distinction, and some languages do that, but I don't see any advantage in it
01:51:42 <tiglionabbit> kosmikus, idk.  I find that more often than not while I am playing with this, I partially apply things accidentally and end up with a function type when I wanted a value type
01:51:47 <kosmikus> Clean, for example, distinguishes between the type "Int Int -> Int" and "Int -> Int -> Int"
01:51:58 <tiglionabbit> if I were more explicit, it would be easier to follow
01:52:15 <kosmikus> tiglionabbit: well, the type system complains
01:52:27 <kosmikus> tiglionabbit: which is the same you'd otherwise get -- an error
01:52:28 <Kaidelong> tiglionabbit: The MLs give more useful errors for that. But try putting a manifest type there, and the type error will point it out
01:52:31 <Kaidelong> well
01:52:46 <Kaidelong> the MLs also give a type error but some of them suggest you may not have fully applied your function
01:52:56 <tiglionabbit> kosmikus, yes but due to type inference I might get that error in a place far removed from where the mistake actually occurred :P
01:53:04 <Kaidelong> which is why I said
01:53:08 <Kaidelong> use a manifest type
01:53:14 <Kaidelong> it is a good habit anyway
01:53:21 <tiglionabbit> manifest?
01:53:23 <kosmikus> tiglionabbit: only if you don't give type signatures for your functions
01:53:36 <Kaidelong> err
01:53:37 <tiglionabbit> kosmikus, yep, I usually don't :P
01:53:42 <Kaidelong> explicit type? type signature
01:53:44 <Kaidelong> right
01:53:48 <kosmikus> tiglionabbit: see, that's a bad habit :)
01:53:52 <Kaidelong> in Haskell, that's not generally a healthy habit
01:54:08 <tiglionabbit> but part of the joy of haskell is that it figures that stuff out for me :P
01:54:20 <kosmikus> tiglionabbit: I usually write the type signature long before I write the function.
01:54:29 <Kaidelong> right but the reason why it is so useful is because it causes the inferred types to conflict with your expectations
01:54:40 <Kaidelong> and what kosmikus said
01:55:07 <Kaidelong> you would generally design a module by writing the types, first, and the classes
01:55:14 <Kaidelong> then put in implementations and instances later
01:55:48 <kosmikus> and type inference is still extremely useful, even if you give signatures for top-level functions
01:56:06 <kosmikus> you don't have to annotate anonymous functions, or local let-bound or where-bound things
01:56:14 <kosmikus> and you can ask ghci for help whenever you're in doubt :)
01:56:24 <Kaidelong> you should keep your top level bindings short anyway
01:57:20 <Kaidelong> if you are writing a lot of small and elegant little things with types that have as few concrete types in them as possible
01:57:24 <Kaidelong> you are doing it right
01:57:32 <Kaidelong> at least as far as I'm concerned
01:57:50 <Kaidelong> (returning concrete types is a good thing though
01:58:28 <Kaidelong> which leads me to a question I've been meaning to ask
01:58:38 <Kaidelong> how does SPECIALIZE interact with RULES?
01:59:18 <Kaidelong> do the RULES get applied first or does the SPECIALIZE based replacement happen before any rewrite rules fire?
02:00:05 <quicksilver> the answer might be both, there are several phases
02:00:07 <quicksilver> but I don't know.
02:00:15 <quicksilver> question for #ghc I feel
02:00:22 <Kaidelong> oh
02:00:22 <Kaidelong> good point
02:00:28 <Kaidelong> I should probably be in that channel
02:01:19 <Kaidelong> well I will flaunt that for a second and ask if the point of NOINLINE is to enforce sharing of values
02:01:33 * hackagebot lhs2TeX-hl 0.1.3.2 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.3.2 (AlessandroVermeulen)
02:01:44 <Kaidelong> well
02:01:50 <Kaidelong> GHC docs seem to say "no"
02:03:11 <kosmikus> Kaidelong: what do the docs say, btw?
02:03:30 <Kaidelong> The NOINLINE pragma does exactly what you'd expect: it stops the named function from being inlined by the compiler. You shouldn't ever need to do this, unless you're very cautious about code size.
02:06:27 <kosmikus> Kaidelong: right, but I still think that preventing loss of sharing can be one of the possible motivations to use it
02:06:44 <Kaidelong> hmm can it?
02:06:52 <Kaidelong> it seems only to be relevant to functions
02:06:55 <Kaidelong> not to values
02:07:06 <Kaidelong> err, values that aren't functions
02:07:35 <kosmikus> wasn't there just a blog post by bos where he used it to that effect?
02:07:59 <Kaidelong> hmm, his blog had that difficult gaelic name didn't it?
02:09:23 <kosmikus> Kaidelong: http://www.serpentine.com/blog/2011/03/18/a-little-care-and-feeding-can-go-a-long-way/
02:10:58 <Kaidelong> hmm
02:11:04 <Kaidelong> how is the ziggarut generated?
02:11:46 <Kaidelong> oh wow looks like it is pure and everything
02:11:56 <Kaidelong> looks like NOINLINE is useful in exactly the way I was thinking then
02:21:41 <pjpj> hello, i'm a haskell newbie.  I'm looking for someone to help me understand the how monads work.
02:22:01 <Kaidelong> which monad?
02:23:22 <Kaidelong> IO? List? Maybe? State?
02:23:33 <Kaidelong> @instances-importing Monad
02:23:34 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
02:24:19 <pjpj> the general concept:  from what I understand the monad typeclass has the >>= function
02:24:47 <Kaidelong> right, but the general concept honestly isn't that useful. It's also very simple, so there is no reason not to explain it here
02:25:16 <Kaidelong> basically, a monad allows you to take something (an a) and put it in a context (a 'm'), "a -> m a"
02:25:20 <tiglionabbit> pjpj, try reading this book http://learnyouahaskell.com
02:25:23 <kosmikus> actually, it's far easier to start by understanding a few concrete examples, and then understanding why there's a general concept
02:25:39 <tiglionabbit> I'm almost at the monoids part
02:25:43 <tiglionabbit> it's exciting :P
02:25:48 <kosmikus> yes, I was going to suggest LYAH or one of the other many tutorials as well
02:25:56 <tiglionabbit> learning what fmap does to functions was exciting
02:26:18 <pjpj> yep: that book is exactly what i'm reading:  chapter 12.
02:26:26 <Kaidelong> and it allows you to take a value in a context, a "m a", and a function that goes from the type inside that context and returns another thing in the same context, and you get the result of that thing back
02:26:34 <Kaidelong> "m a -> (a -> m b) -> m b"
02:27:08 <pjpj> yep: I understand that about ma->(a->mb)->mb
02:27:15 <Kaidelong> > [3,5,7] >>= (map (*) [1,10,100])
02:27:16 <lambdabot>   Couldn't match expected type `t -> [b]'
02:27:16 <lambdabot>         against inferred type `[a -...
02:27:46 <Kaidelong> > [3,5,7] >>= (flip map [1,10,100]) . (*)
02:27:48 <lambdabot>   [3,30,300,5,50,500,7,70,700]
02:27:51 <pjpj> but what I don't get is why does the "do" notion force everything to be calculated in sequence.
02:27:56 <Kaidelong> it doesn't
02:28:25 <Kaidelong> (but it does for some monads, like IO)
02:28:35 <pjpj> oh.
02:29:06 <Kaidelong> do is just syntactic sugar over binds and lambdas
02:29:28 <Kaidelong> anyway a new monad tutorial showed up on Haskell-Cafe today and I think it was decent
02:29:38 <kosmikus> yet another? :)
02:29:46 <Kaidelong> http://vimeo.com/20717301
02:29:52 <Kaidelong> this one is kind of nice
02:30:15 <Kaidelong> although the type system (or the lack of it) kind of makes it different from Haskell
02:30:31 <Kaidelong> but the analogy between (>>=) and let he points out is nice
02:31:24 <tiglionabbit> the word "functor" in java means something completely different from the functor in haskell, right?
02:31:56 <Kaidelong> Probably
02:32:15 <Kaidelong> well pretty much certainly
02:32:15 <kosmikus> I don't know what functor means in Java, actually.
02:32:31 <tiglionabbit> I wonder where Java people got the idea to call their things functors :P
02:32:41 <tiglionabbit> where did haskell get that name anyway?
02:32:46 <Kaidelong> category theory
02:32:56 <Kaidelong> but "Functor" is used to mean many different things
02:33:34 <quicksilver> C++ uses functor to mean 'thing which behaves like a function'
02:33:36 <quicksilver> I think
02:33:37 <kosmikus> ah, just a function-like object
02:33:43 <quicksilver> that is, thing which has an operator() method
02:33:51 <quicksilver> ...including real functions as an example.
02:33:51 <Kaidelong> wasn't there some other name for that?
02:33:55 <Kaidelong> "Strategy" or something
02:33:56 <quicksilver> duck-type-function
02:34:07 <quicksilver> I suspect, but don't know, that java means something similar
02:34:17 <quicksilver> although in Java you can't overload () so you probably use .run() or something?
02:34:27 <tiglionabbit> yeah
02:34:51 <shachaf> quicksilver: Clearly the solution, in order to make this a proper abstraction, is to make every function in Java only callable with .run().
02:34:57 <quicksilver> shachaf: :)
02:35:25 <tiglionabbit> or write a variation of the language that runs in the JVM but where those things are syntactically equivalent
02:35:28 <quicksilver> shachaf: more javalike would be .runWithTheFollowingFourArguments(a,b,c,d) surely?
02:35:42 <quicksilver> tiglionabbit: well, see groovy and scala
02:35:46 <tiglionabbit> exactly
02:35:55 <opqdonut_> and clojure
02:37:46 <Kaidelong> pjpj, just reposting http://vimeo.com/20717301 for your benefit
02:38:00 <Kaidelong> in case it got lost in there before you could find it
02:41:54 <Naiqvist> Hi
02:42:04 <Naiqvist> anyone here?
02:42:24 <Kaidelong> I am
02:42:30 <Kaidelong> and a bunch of other people
02:42:36 <Kaidelong> easier just to ask really!
02:42:44 <Naiqvist> I assume you use haskell?
02:43:07 <merijn> Hell no, its a crappy language. I do all my programming in PHP :)
02:43:19 <Naiqvist> it is?
02:43:28 <Naiqvist> is that a general consensus
02:43:36 <Naiqvist> I heard PHP sucks nuts
02:43:38 <sipa> Naiqvist: no, it's irony :)
02:43:46 <zomg> Haskell is horrible
02:43:50 <sipa> it's something like goldy or bronzy, only it's made of iron
02:43:56 <Naiqvist> haha
02:43:57 <zomg> I program it to remind me that there are better languages
02:43:58 <merijn> sipa: That's sarcasm, not irony >.>
02:43:59 <zomg> Like PHP
02:44:11 <zomg> Being completely serious though
02:44:18 <zomg> I'm somewhat of a noob in Haskell, but I do like it a lot
02:44:26 <zomg> It's refreshing since I haven't done much functional programming
02:44:34 <sipa> merijn: using PHP to do all your programming? i'd say it's masochism :D
02:44:36 <Naiqvist> Its pretty archaic to people who are used to C right?
02:44:37 <zomg> I mainly do PHP and JavaScript
02:44:50 <Kaidelong> Archaic? No
02:44:50 <merijn> Naiqvist: What? Haskell?
02:44:54 <zomg> but I try to learn Haskell.. I just wish I had some more time =)
02:44:54 <Kaidelong> Errrm
02:44:58 <Naiqvist> I don't know much about it at all
02:44:58 <Naiqvist> haha
02:44:59 <Kaidelong> what word were you wanting to use?
02:45:09 <Naiqvist> well archaic but I guess I'm wrong
02:45:11 <Kaidelong> or perhaps you confused Haskell with Pascal
02:45:15 <Kaidelong> wouldn't be the first time
02:45:16 <Naiqvist> I guess I did
02:45:25 <Naiqvist> I don't know what the hell haskell even is honestly
02:45:29 <Naiqvist> I came here to be sold on it
02:45:51 <zomg> If you want to become a better programmer
02:45:52 <zomg> Learn it
02:45:58 * merijn agrees
02:46:00 <Naiqvist> its purely functional and thats it right?
02:46:10 <Kaidelong> well it also has typeclasses
02:46:19 <merijn> Naiqvist: Not just that, it is also a lazy languages and the sexiest type system in existence
02:46:25 <opqdonut_> purely functional, lazy, impressive type system (especially with extensions)
02:46:30 <Kaidelong> but "pure" is a big thing
02:46:30 <zomg> It has all sorts of neat things you'd wish other languages had, but it's pretty weird and hard at first
02:46:32 <merijn> (Well, in a practical language anyway)
02:46:35 <Kaidelong> it isn't a minor note
02:46:39 <opqdonut_> great community, great tools, good set of libraries
02:46:45 <Nereid> merijn: it would be more sexy with dependent types ;o
02:46:47 <Kaidelong> haskell's purity is by far its most important feature
02:46:48 <sipa> @where lyah
02:46:48 <lambdabot> http://www.learnyouahaskell.com/
02:46:48 <Naiqvist> what is it good for
02:46:54 <merijn> Nereid: That's what I meant :p
02:46:58 <sipa> Naiqvist: start reading that, if you're interested
02:47:06 <Kaidelong> Naiqvist: Everything you'd use C for
02:47:10 <Naiqvist> I will
02:47:12 <Kaidelong> or <insert programming language here>
02:47:32 <merijn> Kaidelong: That's not entirely true, I wouldn't use it for OS programming just yet ;p
02:47:41 <Nereid> didn't someone try that?
02:47:43 <Kaidelong> merijn: But some people have.
02:47:45 <Naiqvist> well I'm doing dsp stuff right now
02:47:49 <sipa> merijn: technically, there is an OS in haskell :)
02:47:51 <Naiqvist> would that be hell
02:47:54 <Naiqvist> in haskell?
02:47:55 <Kaidelong> hmm
02:47:55 <merijn> Kaidelong: I know, House. And people are working on Habit
02:48:07 <Kaidelong> well someone did do Yampa based DSP and wrote a paper on it
02:48:09 <merijn> But the entire reason for Habit is that Haskell itself isn't suitable :p
02:48:12 <Kaidelong> I remember it was interesting
02:48:21 <sipa> Naiqvist: i believe there was a DSL for doing DSP in haskell, called feldspar
02:48:31 <Naiqvist> feldspare
02:48:35 <Naiqvist> *feldspar
02:48:36 <jeffz> HaLVM too.
02:48:40 <Naiqvist> Ill write those down
02:48:43 <jeffz> http://halvm.org/wiki/
02:48:47 <merijn> Naiqvist: No, I actually saw a presentation about a bunch of people using Haskell for DSP with quite some success
02:48:53 <sipa> Naiqvist: but first familiarize yourself with the basics
02:48:58 <Naiqvist> so its efficient with memory?
02:49:00 <merijn> Lemme see if I can find the details
02:49:03 <sipa> Naiqvist: it will be *very* different from what you're used to
02:49:16 <Naiqvist> but it is all logic
02:49:28 <Kaidelong> Naiqvist: Yes, when it is, and notwhen it isn't. Same with any other programming language.
02:49:48 <Kaidelong> Haskell exposes relatively low level things if you are used to stuff like Java or .NET
02:49:52 <Naiqvist> is the syntax a whole buncha bo shit
02:50:13 <Kaidelong> Haskell's syntax is probably the biggest factor behind its "success"
02:50:18 <Naiqvist> oh
02:50:20 <Kaidelong> (relatively speaking)
02:50:32 <Kaidelong> Haskell's syntax is regular but it isn't LISP
02:50:37 <Kaidelong> and it is lightweight like python
02:50:48 <Naiqvist> I just got recommended to learn LISP
02:50:55 <zomg> I tried to learn lisp but the syntax puts me off :D
02:51:05 <Nereid> lisp is quite a different language
02:51:12 <Nereid> (or rather, collection of languages)
02:51:33 <Kaidelong> LISP doesn't let me think as clearly as haskell does
02:51:36 <Kaidelong> I think it is the type system
02:51:38 <merijn> Naiqvist: Lisp is also fascinating, but entirely different from Haskell. Personally I think learning Haskell will expose you to more stuff
02:51:49 <Kaidelong> also Common Lisp's libraries are huge and arcane
02:51:58 <Kaidelong> and not at all beginner friendly
02:52:00 <nlogax> i started reading "Land of Lisp", then it asked me if i wanted power, beauty, or both, in my language. i wanted both, of course. it then told me to check out haskell instead
02:52:02 <Naiqvist> For some reason I thought haskell was like lisp
02:52:09 <Nereid> nlogax: haha
02:52:19 <Kaidelong> it is in a lot of ways yet it is fundamentally different from lisp
02:52:20 <merijn> Ah, I found the DSP presentation I was talking about. But looking at it again I'm afraid actually linking it might scare you away because of the advanced stuff they use ;)
02:52:21 <Nereid> Naiqvist: not at all.
02:52:27 <Nereid> ok, they're both "functional"
02:52:29 <Nereid> whatever that means
02:52:34 <Nereid> but that's about it
02:52:38 <Kaidelong> well that's arguable for lisp
02:52:40 <quicksilver> it's more like lisp than either of them is like microsoft word
02:52:44 <quicksilver> it's all a question of degree :)
02:52:49 <Naiqvist> How portable is it
02:52:51 <quicksilver> they certainly have some interesting things in common.
02:52:54 <Naiqvist> what systems can it run on?
02:53:05 <Kaidelong> depends which "Haskell" you are talking about
02:53:12 <quicksilver> GHC is actively supported on linux, OSX, and windows
02:53:15 <Kaidelong> GHC is pretty portable though
02:53:21 <Naiqvist> is GHC nice?
02:53:22 <Kaidelong> quicksilver: Solaris too
02:53:25 <Naiqvist> I assume thats a compiler
02:53:28 <Kaidelong> or whatever Solaris is called now
02:53:30 <merijn> Naiqvist: Well it (GHC) runs on any normal system (amd64/x86, windows, OSX, linux and the BSDs)
02:53:32 <quicksilver> it's fiddly but not impossible to port it to other unixes.
02:53:35 <sipa> GHC is a compiler indeed
02:53:43 <sipa> and i think it's the most commonly used haskell system
02:53:44 <quicksilver> Kaidelong: I don't think it's actively supported on solaris; it does work though.
02:53:44 <merijn> Yeah, GHC is the de facto standard compiler
02:53:49 <Kaidelong> Oh
02:53:58 <Kaidelong> hmm, I thought the gentoo people at least tested it there
02:54:00 <Naiqvist> I'm pretty interested actually
02:54:02 <Nereid> ghc gets all the fun language extensions first :>
02:54:04 <Nereid> I think
02:54:04 <Kaidelong> but perhaps that is their perogative
02:54:10 <quicksilver> Kaidelong: if it's gentoo then it's not solaris
02:54:14 <Naiqvist> Even if I might not get jobs programming haskell
02:54:16 <quicksilver> Kaidelong: perhaps you mean gentoo/sparc?
02:54:20 <Naiqvist> itll teach me stuff
02:54:25 <Naiqvist> right?
02:54:25 <quicksilver> solaris is an operating system, sparc is a chip family...
02:54:28 <Kaidelong> quicksilver: Oops. Yes, you are right
02:54:43 <Kaidelong> I really should get some sleep
02:54:49 <Nereid> me too
02:54:50 <Nereid> @localtime Kaidelong
02:54:52 <lambdabot> Local time for Kaidelong is Thu May 05 02:58:04
02:54:53 <quicksilver> the answer is similar, anyhow. sparc is not one of the platforms that GHC HQ works to support, but it does work.
02:54:59 <Nereid> ah, 1 hour ahead here.
02:55:00 <Nereid> lol
02:55:18 <merijn> Naiqvist: Well, as someone mentioned earlier "Learn You a Haskell" is a really good introduction to Haskell gives you a solid foundation in the basics
02:55:18 <Kaidelong> out of curiousity
02:55:23 <Kaidelong> what IS solaris called now
02:55:27 <Naiqvist> I'm going to read that now
02:55:29 <Kaidelong> I heard Oracle drove a stake through Solaris
02:55:32 <Nereid> @where lyah
02:55:32 <lambdabot> http://www.learnyouahaskell.com/
02:55:49 <Nereid> @where do people learn all these commands
02:55:49 <lambdabot> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
02:55:53 <Nereid> oops
02:56:02 <merijn> Nereid: here
02:56:04 <merijn> @help
02:56:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:56:04 <Kaidelong> Nereid: @list
02:56:14 <Nereid> yeah, but it's not very descriptive
02:56:18 <Naiqvist> are there people around here for a while?
02:56:24 <Naiqvist> or does this place get idle
02:56:48 <Kaidelong> not too much
02:56:51 <merijn> Naiqvist: Thre's usually 600+ people here so even when its quiet people are around to answer stuff :p
02:56:51 <Kaidelong> if there is one thing that stands out about haskell it is how active the community for it is
02:57:07 <Naiqvist> OK
02:57:10 <merijn> Nereid: Experimenting in privmsg with @lambdabot is a good way to figure out the commands
02:57:11 <Kaidelong> Haskell-Cafe, stackoverflow, lambda-the-ultimate, reddit, FreeNode-IRC, many other places
02:57:29 <Nereid> merijn: indeed
02:57:33 <Naiqvist> the one thing I want to ask
02:57:33 <Kaidelong> Haskell is the most popular ML-like language although it is not itself in the ML family of languages
02:57:37 <Nereid> hmm
02:57:42 <Naiqvist> is if I should really learn this or C first
02:57:43 <Nereid> #haskell is in the top 10 largest channels on freenode :o
02:57:50 <Naiqvist> I already know a bit of C
02:57:55 <Nereid> Naiqvist: C is worth learning just because of how ubiquitous it is.
02:58:02 <Kaidelong> Naiqvist: There is not much of "C" to learn, unless you mean how to program in it
02:58:09 <Nereid> but yeah
02:58:12 <Naiqvist> yes, but it seems this might help me understand C more
02:58:13 <Nereid> there isn't much to it
02:58:13 <Kaidelong> in which case there is no single C to learn
02:58:15 <Naiqvist> in a way
02:58:22 <Naiqvist> or how to program C
02:58:24 <Kaidelong> umm, hmm
02:58:26 <Nereid> mmm
02:58:34 <Naiqvist> or just programming in general
02:58:35 <Naiqvist> maybe
02:58:38 <Kaidelong> well if you get Haskell, C would seem like sadomasochism
02:58:42 <Naiqvist> haah
02:58:44 <Nereid> lol
02:58:50 <Naiqvist> does that mean its easy
02:58:51 <merijn> It does :(
02:58:59 <Nereid> I still write C from time to time
02:59:09 <Naiqvist> or is it just concise
02:59:15 <Kaidelong> but
02:59:18 <Kaidelong> from what I understand
02:59:20 <merijn> My master's project is 100k+ lines of C, sometimes it makes me want to cry or rewrite everything in Haskell >.>
02:59:25 <Kaidelong> if you are only learning to program to begin with
02:59:34 <Kaidelong> learning functional programming is good for you
02:59:39 <merijn> ^^
02:59:41 <Nereid> maybe!
02:59:48 <Kaidelong> (my first serious language I used was SML/NJ so I can vouch for this)
02:59:55 <Nereid> cool
03:00:12 * Nereid learned a variety of imperative languages before coming to haskell, so...
03:00:15 <Kaidelong> although I invented my own little assembler like languages when I was little
03:00:24 <Naiqvist> OK
03:00:30 <Naiqvist> I think I'm sold then
03:00:32 <Nereid> however
03:00:36 <Naiqvist> however...
03:00:49 <Nereid> these days I don't want to write in anything but haskell
03:00:49 <Nereid> D:
03:00:51 * hackagebot bindings-K8055 0.1.1 - Bindings to Velleman K8055 dll  http://hackage.haskell.org/package/bindings-K8055-0.1.1 (JorisPutcuyps)
03:00:56 <Naiqvist> thats fine
03:00:59 <Kaidelong> programming in general requires you to re-wire your brain in a pretty fundamental way
03:01:03 <Naiqvist> but do you look back at the good old days
03:01:19 <Nereid> not really
03:01:25 <Naiqvist> haha oh
03:01:29 <Kaidelong> Naiqvist: When I look back at what I used to do I see Java ugliness
03:01:33 <Nereid> python used to be my favourite language
03:01:34 <Naiqvist> haha
03:01:37 <merijn> I go into Haskell via Python's list comprehensions. Python is a good primer for going from imperative to functional, imo. Because it doesn't insist on everything being in a class, supports first class functions and list comprehensions
03:01:39 <Nereid> but now
03:01:41 <Nereid> I'm all like
03:01:49 <Nereid> how do you even do things with it
03:01:57 <Naiqvist> haskell is a lot like python right?
03:01:57 <Nereid> catch bugs, etc
03:01:58 <Kaidelong> Python might be one of the best things that ever happened to Haskell
03:02:02 <Nereid> Naiqvist: not one bit
03:02:07 <merijn> Nereid: I was going to wrote a statically typed (ala Haskell) python. Then I realized it'd just be the IO monad >.>
03:02:10 <Naiqvist> oh
03:02:15 <Naiqvist> I've never used python
03:02:15 <Nereid> well, they both share some features
03:02:16 <Nereid> like
03:02:19 <merijn> s/wrote/write
03:02:19 <Nereid> nice syntax
03:02:22 <Nereid> nice community
03:02:23 <Nereid> or something
03:02:28 <Naiqvist> they're both clear
03:02:30 * jeffz has never used python and wouldn't want to.
03:02:30 <Naiqvist> is what I heard
03:02:41 <Naiqvist> and fairly new
03:02:46 <Nereid> but in some ways they're completely opposite
03:02:49 <merijn> Define new :p
03:02:56 <Kaidelong> Python's strength is its syntax and the clarity by which algorithms can be expressed in it, IMO
03:02:58 <merijn> Python and Haskell are both older then Java :D
03:03:08 <Naiqvist> they haven't been around since the 70s
03:03:09 <Nereid> python? really?
03:03:10 <Naiqvist> haha
03:03:30 <Nereid> wow, it's true D:
03:03:34 <Nereid> python 1991, java 1995
03:03:40 <Naiqvist> my friend girlfriend works at google
03:03:43 <Kaidelong> it's a half truth
03:03:46 <merijn> Haskell is 1990
03:03:51 <Naiqvist> she complained about learning python
03:03:59 <Nereid> lol
03:03:59 <Kaidelong> Java is older than Java
03:04:00 <Naiqvist> said it was the exact opposite of how programming should be
03:04:04 <Naiqvist> idk what that means
03:04:16 <nazgjunk> ... that doesn't mean anything
03:04:21 <Kaidelong> and Python (or Haskell) before 1995 is not the same as they are now
03:04:24 <merijn> Naiqvist: What, fun and easy instead of complicated and hard? :D
03:04:29 <zomg> lolwut...
03:04:29 <Nereid> sure
03:04:36 <zomg> Anyone who doesn't like Python is wrong in the head
03:04:36 <zomg> :D
03:04:42 <Naiqvist> ive never used it before
03:04:44 <zomg> I'm guessing it wasn't hard enough
03:04:45 <zomg> =)
03:04:58 <Naiqvist> she's old though
03:05:01 <Kaidelong> zomg: it is too hard for me to tell when things in python have persistant mutable stateand when they don't
03:05:07 <merijn> Naiqvist: Meh, after learning Haskell you can learn python in like 1 or 2 afternoon
03:05:09 <Naiqvist> she's been programming since the 80s or something
03:05:09 <Nereid> python is a very nice dynamically typed imperative language.
03:05:16 <Nereid> too bad it's dynamically typed and imperative ;o
03:05:26 <Naiqvist> OK
03:05:26 <Kaidelong> I have been surprised by iterators choosing one or the other way to be in seemingly arbitrary ways
03:05:39 <zomg> Naiqvist: yeah I'm guessing it was too straightforward to do things in it vs. C or whatever she likes :D
03:05:42 <Naiqvist> so python is like haskells alter ego
03:05:54 <merijn> Python is Haskells gateway drug :>
03:05:58 <Nereid> lol
03:06:01 <merijn> And/or alter-ego, yes
03:06:07 <Naiqvist> but ive never used python
03:06:11 <Naiqvist> sooo
03:06:26 <Kaidelong> Eeeh, well, python is rewarding in that you can get nice things working easily
03:06:35 <Naiqvist> but its super high level
03:06:45 <Naiqvist> is haskell super high level?
03:06:47 <Kaidelong> but get frustrated when I spend time testing my code instead of understanding how it works
03:06:48 <Kaidelong> yes
03:06:50 <merijn> Whereas Haskell is rewarding in the fact that working things stay working
03:06:58 <Nereid> haskell is so high level
03:07:00 <Nereid> way up there
03:07:07 <Nereid> I can barely see python from here
03:07:07 <Nereid> D:
03:07:13 <merijn> Kaidelong: Yeah, compiler-checked constraints are awesome :>
03:07:31 <Naiqvist> does haskell cooperate with other languages
03:07:33 <Nereid> (whatever this means)
03:07:52 <Kaidelong> Naiqvist: Depends a bit. It plays nice with things that play nice with C.
03:07:56 <merijn> Naiqvist: There is a Foreign Function Interface for calling C code, so you can call anything that can interface with C
03:07:58 <Kaidelong> which is most everything
03:08:16 <Kaidelong> but there can be some areas where it gets complicated, like linking against .NET
03:08:33 <Kaidelong> (in which case you may as well use F#, which has a lot in common with haskell)
03:08:42 <Naiqvist> I don't think I'm going to use .net for a while tho
03:08:49 <Naiqvist> so it seems cool
03:08:55 <scree> compile-time safety is a dangerous addiction
03:08:57 <Naiqvist> so basically
03:09:07 <Nereid> scree: lol
03:09:07 <Naiqvist> you just really directly manage data
03:09:27 <Nereid> Naiqvist: I think the best thing to do would just be to try it out
03:09:33 <Naiqvist> haha ok
03:09:44 <Kaidelong> scree: I think the thing that will happen is that the dynamic languages will start forcing proof obligations on code to get the same effects
03:09:44 <Naiqvist> ill do that
03:10:02 <Kaidelong> so perhaps it is not so bad
03:10:05 <Naiqvist> ill be back after I give this thing a shot
03:10:07 <merijn> Kaidelong: You mean "unit tests"? :p
03:10:47 <Naiqvist> if you're good at calculus would haskell make sense?
03:10:50 <Kaidelong> merijn: Unit tests are the "numerical approximation" of it
03:11:07 <Kaidelong> Naiqvist: Errrm. Insofar as higher order functions maybe?
03:11:25 <Kaidelong> seems a bit orthogonal to programming software for discrete machines
03:11:30 <scree> Kaidelong: so, my point was, the first few type-safe programs you write are really fun.  after that you can't stop and try to make everything you write type-safe, even though the result is hideously more complicated and bug-prone than not doing so
03:11:48 <Kaidelong> scree: I haven't really experienced that personally
03:12:10 <merijn> scree: Sufficiently smart typesystem conjecture takes care of that :p
03:12:17 <Kaidelong> I write less C# now than I did before learning haskell and also spend less time having to debugit
03:12:18 <Naiqvist> I get it I get it
03:12:25 <merijn> (It's the friend of the sufficiently smart compiler conjecture)
03:12:28 <Naiqvist> less as in
03:12:31 <Naiqvist> more concise
03:12:31 <scree> Kaidelong: i mainly had this realization when i tried to explain to non-haskellers about type-safe matrix dimension checking and watched the expression on their faces
03:12:33 <Naiqvist> or less often
03:12:55 <Kaidelong> scree: Oh. Well I don't do stuff like that. Maybe you just went in hardcore above what you can really do with Haskell.
03:13:05 <scree> merijn: sure, I think everyone -- haskell & dynamic typers -- are looking for a way to make my above statement false
03:13:30 <scree> Kaidelong: sure.  i don't do stuff like that any more :)
03:13:38 <Nereid> Naiqvist: I wouldn't say calculus really helps you with haskell...
03:13:41 <Nereid> or any language really
03:13:47 <merijn> Algebra might
03:13:54 <Kaidelong> algebra definitely does
03:14:08 <Kaidelong> it feels the same as thinking about haskell, prolog, and the like
03:14:09 <merijn> Or vice versa, learning haskell helps you understand algebra :p
03:14:27 <Kaidelong> which means that I'm probably using the same brainage I developed for doing algebra
03:14:28 <merijn> I was reading about Monoid and lists and suddenly Algebra made sense
03:14:49 <Kaidelong> Haskell was my gateway drug to abstract algebra
03:14:55 <Naiqvist> OK guys
03:14:59 <Kaidelong> although cryptography forced me to look into number theory
03:15:00 <Naiqvist> should I download just GHC
03:15:04 <Kaidelong> which forced me to make the final push
03:15:06 <Naiqvist> or the haskell platform
03:15:11 <Kaidelong> Naiqvist: Nooo! Get the haskell platform
03:15:11 <Kaidelong> yeah
03:15:13 <merijn> Naiqvist: Haskell Platform
03:15:28 <merijn> Kaidelong: Yeah, I'm reading type theory now and planning to read up on category theory after that >.>
03:15:51 <merijn> Anyone here ever programmed in Epigram or are the people here just Agda fans?
03:15:52 <Naiqvist> how much reading up is there on type theory
03:16:23 <Kaidelong> merijn: Epigram was my first attempt at a total language and the syntax absolutely horrified me and made it very difficult to figure out what was going on in the papers
03:16:38 <Kaidelong> so far the total language I've made the most progress in is Coq
03:16:51 <merijn> Naiqvist: For learning haskell? None, just read LYAH. But once you want to learn more advanced stuff there is tons of stuff to learn about how it actually works
03:17:12 <Kaidelong> although ACL2 seems more promising than either Coq or Agda to me
03:17:12 <Kaidelong> I guess I'll learn them each concurrently until one really snags me
03:17:14 <merijn> You can use Haskell's type system just fine with only a very basic understanding of what it does
03:17:25 <Naiqvist> someone was talking about a dsp library or something
03:17:52 <merijn> Kaidelong: I already struggled through half of Conor's thesis about Oleg (the type theory Epigram is based on) and things are finally starting to click and make sense
03:18:14 <Naiqvist> does the haskell platform have a built in text editor?
03:18:16 <merijn> Kaidelong: So I already have a feeling of what is happening, so far I didn't get around to playing with it, though
03:18:25 <Kaidelong> I might take another look at Epigram and Twelf later
03:18:33 <Kaidelong> they scared me off though, very quickly
03:18:40 <Kaidelong> Agda, Coq, and ACL2 are more familiar
03:18:49 <merijn> Naiqvist: No, most people use whatever they like (vim/emacs are very popular), Notepad++ seems popular on windows
03:19:33 <Kaidelong> I actually don't know if Twelf is a total language
03:19:42 <merijn> Kaidelong: Yeah, the papers can be a little...dense >.>
03:19:43 <Kaidelong> since it is dependently typed I suspect it should be
03:19:50 <Naiqvist> I'm on OSX right now
03:20:02 <Naiqvist> does xcode work well?
03:20:31 <merijn> Naiqvist: I personally use vim on OSX, I know a lot of GUI oriented people seem to like things like TextMate
03:20:43 <Naiqvist> im a bit sick of xcode actually
03:20:44 <Kaidelong> no idea if there are any ways to make xcode play nice with haskell, assuming that xcode is an IDE
03:20:45 <Nereid> apparently there's a haskell plugin for xcode
03:20:49 <Nereid> but
03:20:51 <Kaidelong> I generally just use Notepad++ or vim
03:20:52 <merijn> Personally I don't really like XCode, but if you do I guess it should work?
03:20:53 <Nereid> if you don't want to use it, don't :P
03:21:08 * Nereid uses vim
03:21:38 <Naiqvist> ill do what nereid says
03:22:00 <Nereid> also
03:22:09 <Nereid> there's a text editor written in haskell, called yi
03:22:12 <Nereid> never tried it, though
03:22:17 <Naiqvist> haha
03:22:20 <Kaidelong> I had trouble getting it to build
03:22:21 <Naiqvist> hmm
03:22:33 <mpiechotka> @pl \x y z -> x ++ y ++ z
03:22:33 <lambdabot> (. (++)) . (.) . (++)
03:22:37 <Kaidelong> I also heard that some versions of it had performanc problems
03:22:53 <Naiqvist> do the object files port easily?
03:23:13 <Naiqvist> i mean executables
03:23:14 <Kaidelong> ...?
03:23:23 <Nereid> ..?
03:23:28 <Naiqvist> wot
03:23:28 <Kaidelong> Why should they?
03:23:38 <Naiqvist> sorry
03:23:40 <Naiqvist> I meant to say
03:23:45 <Naiqvist> does the source code have to change much
03:23:46 <Kaidelong> you don't expect "ls" to work on Windows
03:23:49 <Kaidelong> oh
03:23:53 <Kaidelong> source ports easily, yes
03:23:55 <Naiqvist> OK
03:24:01 <Kaidelong> just don't depend on Win32 or unix
03:24:05 <Kaidelong> (the libraries)
03:24:11 <merijn> Naiqvist: Well, as long as you don't use OS specific stuff (like posix on unix), it is
03:24:28 <merijn> If you do use posix it'll still be easy to port as long as you don't care about windows :p
03:24:31 <Naiqvist> I've never written a serious program on windows before
03:24:39 <Naiqvist> scares the shit out of me
03:24:49 <merijn> My advice, don't try to ;)
03:24:49 <Kaidelong> merijn: Which most people do. Since most people use it
03:24:49 <Naiqvist> programming on macs makes me feel safe
03:24:59 <Kaidelong> in a strange change of pace, I'm actually on a windows machine right now
03:25:32 <merijn> I tried it a bit on Windows and programming on Windows sucks. OSX is my current "no hassle GUI OS but I can still program it as a unix machine" choice :p
03:25:44 <Kaidelong> Naiqvist: Windows' developer tools are pretty much second to none
03:25:54 <Kaidelong> and I attribute that as being a big part of why it succeeded
03:26:03 <Nereid> pah, osx
03:26:08 <Naiqvist> I know I know
03:26:14 <Naiqvist> OSX isn't the best thing ever
03:26:19 <Naiqvist> but its reliable IMO
03:26:23 <quicksilver> Kaidelong: my memory is that windows succeeded whilst its tools were mediocre/lousy
03:26:24 <Nereid> (I'm being a bit unfair, since I've never used it)
03:26:45 <Naiqvist> Its really user friendly
03:26:46 <quicksilver> Kaidelong: so I'm not sure the tools were the reason for the initial growth. They might be responsible for some of the recent success.
03:26:48 <Nereid> I try to do all my coding on linux though :o
03:26:52 <Kaidelong> quicksilver: Even with stuff like Visual Basic, C++, Object Pascal, and Java?
03:26:59 <Naiqvist> and it doesn't ever give you stupid nonsensical error messages
03:27:02 <merijn> Nereid: I bought a MacBook because the prospect of setting up linux/BSD on a laptop didn't struck me as fun. I am very pleased with it
03:27:09 <quicksilver> Kaidelong: windows succeeded before visual C++ existed.
03:27:13 <Naiqvist> it just slows down and makes you stare at a spinning wheel
03:27:18 <Naiqvist> or it use too
03:27:20 <Nereid> lol
03:27:26 <Naiqvist> *to
03:27:28 <Kaidelong> hmm that's true but Pascal and Basic already has a DOS heritage
03:27:39 <Nereid> mmm, installing yi dependencies...
03:27:45 <merijn> Nereid: I do basically 90% of my stuff in the Terminal using the commandline and that works out that just great :p
03:27:47 <quicksilver> Kaidelong: visual basic was very neat but its early versions were not used for many commercial applications.
03:27:58 <Kaidelong> from what I remember even early on Borland, Microsoft and others were developing good tools for windows
03:27:58 <quicksilver> Kaidelong: delphi had the market then - and that's not an MS product
03:28:11 <Kaidelong> or DOS
03:28:55 <Naiqvist> what about guis
03:29:03 <Naiqvist> is haskell a pal for that at all
03:29:03 <Kaidelong> TurboPascal comes to mind
03:29:37 <Nereid> there are bindings for a bunch of gui libraries for haskell
03:29:42 <Nereid> like gtk and wxwidgets
03:29:48 <Kaidelong> Naiqvist: Haskell needs a GUI application development system up to its high standards. What it has does the job but it I haven't found any one that pleases me very much
03:30:03 <Kaidelong> it is still better than say, doing GTK stuff in C
03:30:08 <Nereid> I've never tried writing a gui program in it though.
03:30:25 <Naiqvist> hmm
03:30:36 <Naiqvist> does it just take a bit of extra work? or is that not its job
03:31:14 <Naiqvist> I've never been too successful with guis really though
03:31:19 <Kerris> Kaidelong: you mean, something like Swing?
03:31:36 <Kaidelong> Kerris: Ideally, something like GuiTV
03:31:37 <Kerris> er, I mean, WinForms.
03:31:42 <Kerris> oh
03:31:55 <Kaidelong> WinForms isn't really something that I'd consider up to Haskell's high standards
03:31:58 <Kaidelong> Swing is closer
03:32:08 <Kaidelong> Windows Presentation Foundation perhaps even closer
03:32:17 <Kaidelong> but it'd have to be something quite different
03:32:46 <luite2> hmm apparently borland still exists
03:32:55 <Kaidelong> that's surprising?
03:32:56 <Nereid> wxwidgets does a decent job at making a native-looking win32 gui
03:33:05 <Naiqvist> so whoever told me to use vim
03:33:13 <Kaidelong> "vimtutor"
03:33:16 <Kaidelong> that'll get you started
03:33:20 <luite2> Kaidelong: hadn't heard of anyone using their products for a long time
03:33:28 <Naiqvist> its ported for mac
03:33:31 <Naiqvist> but it uses carbon
03:33:38 <Naiqvist> and there's another one that's using cocoa
03:33:55 <Naiqvist> whatever it'll work nevermind
03:34:06 <Naiqvist> oooh this looks nice
03:34:17 <Naiqvist> tabs
03:34:31 <merijn> Naiqvist: There's also a commandline version installed by default. But if you haven't used vim before, it can be intimidating
03:34:37 <Nereid> vim takes a little while to get used to
03:34:49 <Kaidelong> hmm does seem like Borland no longer has their earlier glory
03:34:51 <Naiqvist> do you use the commandline version
03:34:53 <earthy> that's a bit of an understatement ;)
03:35:07 <Nereid> personally, I use gvim
03:35:26 <Naiqvist> I assume gvim is with a gui?
03:35:27 <Kaidelong> Scintilla-TE/SciTE is just fine
03:35:27 <Nereid> not that I use the extra features much
03:35:32 <Nereid> yeah
03:35:40 <Nereid> I dunno what they have on mac though
03:35:45 <Kaidelong> actually to someone who is totally new
03:35:47 <merijn> I use the commandline version of MacVim (which means I can copy/paste to and from the OSX clipboard using the commandline version)
03:35:52 <Kaidelong> SciTE is probably a good recommendation
03:35:52 <earthy> MacVim works perfectly
03:35:56 <earthy> even in gui mode
03:36:01 <luite2> oh hmm, they make (or bought) Together, that tool that I had to use in undergrad java courses to make uml diagrams before writing the programs (which in practice means writing the program first and then use the reverse engineer functionality of together)
03:36:06 <Naiqvist> OK
03:36:06 <earthy> plus, it comes with 'edit in vim' contextual menu
03:36:08 <Kaidelong> http://www.scintilla.org/
03:36:13 <Kaidelong> SciTE is here
03:36:14 <Kerris> default vim on OS X is 7.2.108
03:36:18 <Kaidelong> try this if you don't want to use vim
03:36:27 <Naiqvist> I'll try vim
03:36:27 <luite2> oh wait I thought this was -blah :p
03:36:32 <Naiqvist> I'm coming from using xcode
03:36:33 <merijn> luite2: That's the only way to create UML diagrams, no?
03:36:36 <Naiqvist> which is super organized
03:36:48 <Naiqvist> but its also an annoying tyrant in a way
03:36:59 <Nereid> well use whatever
03:37:09 <Kaidelong> don't know anything about xcode
03:37:12 <luite2> merijn: I think it is, I've never seen anyone use another method :p
03:37:21 <Nereid> maybe it's not the best idea to learn a programming language *and* a text editor at the same time
03:37:23 <merijn> Nereid: You realize we're not only getting him to learn Haskell but also vim at the same time? Poor guy ;)
03:37:28 <Nereid> lol
03:37:34 <prljavi_hari> I tried to start a few applications from haskell org but without success. I'm trying "haskell ls" now, I try to load main.hs into winghci and I get error:    "Could not find module `BSD', Use -v to see a list of the files searched for". Where do I find module 'bsd' ? Where do I write this "-v" to get all the needed modules ?
03:37:35 <Kerris> True. :|
03:37:40 <merijn> Especially when said language is Haskell and said editor is vim :p
03:37:42 <Kaidelong> Nereid: which is why I pointed to SciTE
03:37:42 <Nereid> :P
03:37:46 <Naiqvist> Kaidelong: the Cocoa interface builder is pretty cool
03:37:49 <Kaidelong> you don't reallyneed to learn SciTE
03:37:51 <earthy> naiqvist: textmate will also suffice ;P
03:37:57 <Kerris> Look at the the number of people who enjoy learning Lisp + Emacs at the same time.
03:38:04 <Nereid> lol
03:38:09 <merijn> Yeah, but emacs is written in Lisp
03:38:12 <Naiqvist> I don't know why I'm talking so much about text editors
03:38:20 <Nereid> yeah, just use whatever
03:38:20 <Naiqvist> I'm just waiting for haskell to finish downloading
03:38:25 <earthy> I couldn't imagine learning emacs *without* learning lisp...
03:38:27 <Kerris> merijn: does that make it worse or better :V
03:38:42 <merijn> And emacs doesn't have the command/insert/visual mode distinction which seems to be really hard for people
03:38:45 <Saizan> earthy: using it?
03:38:45 <Nereid> sometimes I feel like I should learn emacs
03:38:47 <Kaidelong> Kerris: In emacs' case specifically?
03:38:53 <Nereid> and then I decide it's not worth the effort
03:38:58 <earthy> saizan: I don't use emacs, no
03:39:05 <Nereid> I've already spent the time to learn one text editor
03:39:12 <Kerris> Kaidelong: yes?
03:39:17 <Kaidelong> as far as I'm aware, elisp is an abomination
03:39:18 <Naiqvist> does learn you haskell go over compilation much?
03:39:21 <Kerris> haha
03:39:23 <Kaidelong> doesn't even have lexical scope
03:39:26 <Naiqvist> *learn you a haskell
03:39:41 <Kerris> Kaidelong: I think that's been fixed recently, but I could be wrong.
03:39:47 <Kaidelong> that said, I haven't programmed in it
03:39:49 <merijn> Naiqvist: A little bit, I think. But it mostly uses ghci I think
03:39:53 <Kaidelong> nor say, MUMPS
03:40:04 <Nereid> @where rwh
03:40:04 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:40:09 <earthy> naiqvist: once you're through LYAH, you might consider RWH
03:40:15 <Nereid> which I just linked
03:40:16 <Nereid> lol
03:40:17 <merijn> Naiqvist: ghci is an interactive command line where you can basically type haskell expressions and then it will run the expression and print its output
03:40:31 <merijn> Nereid: I usually feel like I want emacs, but with vim's modal editing :p
03:40:32 <earthy> (if printable)
03:40:36 <b52> is t here a ** for Integral ?
03:40:41 <Naiqvist> should I start using that now?
03:40:46 <Nereid> b52: what do you mean by **
03:40:47 <Naiqvist> seems handy
03:40:53 <Kerris> Emacs reminds me of Yi. :(
03:41:04 <Naiqvist> I mean, should I use ghci first
03:41:05 <b52> x ** 3 = x^3
03:41:14 <Naiqvist> or just compile it from a text editor
03:41:18 <merijn> Naiqvist: It's almost impossible to learn Haskell without using ghci. When you get used to it languages without an interpreter will make you cry :)
03:41:23 <Kaidelong> Kerris: It probablyshould
03:41:23 <luite2> b52: for integral exponent? then (^^)
03:41:26 <Nereid> b52: use ^
03:41:26 <earthy> merijn: that's where viper comes into being
03:41:34 <Naiqvist> does ghci come with the haskell platform?
03:41:34 <merijn> earthy: viper is not good enough
03:41:35 <Kaidelong> as far as I can tell the point of yi was to be a saner emacs
03:41:36 <ClaudiusMaximus> prljavi_hari: i've not used windows recently, but you probably need the Haskell Platform with cabal-install to get more libraries, but `BSD' might not be available for windows (i'm out of my depth, maybe someone else has more ideas)
03:41:41 <Nereid> eh well
03:41:43 <Nereid> :t (^)
03:41:43 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
03:41:44 <merijn> Naiqvist: Yes, it's installed together with ghc
03:41:45 <Nereid> :t (^^)
03:41:45 <Kaidelong> and a more extensible and lighter weight one
03:41:45 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
03:41:46 <Kerris> Naiqvist: use ghci and ::load the *.hs files
03:41:55 <Naiqvist> OK
03:42:01 <luite2> oh right
03:42:05 <Kerris> oops, should be :load
03:42:19 <Kerris> pretty sure I deleted one of the colons before hitting enter, my mistake
03:42:30 <merijn> Naiqvist: It does the similar things to lambdabot, like
03:42:32 <ClaudiusMaximus> prljavi_hari: in ghci you can ":set -v" to enable more verbosity, but i don't think it will be informative in this case
03:42:45 <earthy> merijn: vimpulse? :P
03:42:47 <merijn> > (2 * 5 + 10) / 5
03:42:48 <lambdabot>   4.0
03:42:54 <cheater_> i have a question
03:42:56 <luite2> > (2 :: Double) ^ (-1)
03:42:56 <lambdabot>   *Exception: Negative exponent
03:42:58 <luite2> :)
03:43:11 <Naiqvist> thats cool
03:43:14 <Nereid> > (2 :: Double) ^^ (-1)
03:43:15 <lambdabot>   0.5
03:43:21 <Nereid> > (2 :: Double) ** (-1)
03:43:22 <lambdabot>   0.5
03:43:34 <Nereid> I'm pretty sure this is the first time I heard of (^^).
03:43:44 <cheater_> how much older is the idea of (von neumann notation + turing machines + imperative languages) in comparison to (functional, declarative languages and lambda calculus)?
03:43:52 <earthy> not
03:44:01 <cheater_> it's not older?
03:44:05 <earthy> lambda calculus and turing machines were devised concurrently
03:44:15 <cheater_> yes, but one of them must have been first.
03:44:16 <Naiqvist> (2 * 2 + 2) / 2
03:44:21 <Nereid> cheater_: they were pretty close
03:44:23 <Naiqvist> darn didn't work
03:44:26 <Nereid> both were in the 1930s, I think
03:44:28 <cheater_> and which one was first?
03:44:33 <merijn> Naiqvist: You need to prefix it with "> "
03:44:35 <Naiqvist> oh
03:44:37 <Kaidelong> cheater_: the lambda calculus had precedents anyway
03:44:39 <cheater_> or were they finished within one planck constant of eachother
03:44:45 <Naiqvist> > (2 * 2 + 2) / 2
03:44:46 <lambdabot>   3.0
03:44:50 <Naiqvist> huzzah
03:44:53 <Nereid> turing machines: 1936
03:44:55 <earthy> cheater_: 1936 for the consistent simply typed lambda calculus
03:44:55 <Nereid> lambda calculus: 1936
03:45:06 <Nereid> earthy: I thought it was the untyped one?
03:45:21 <earthy> oh, right, my bad
03:45:23 <Nereid> wikipedia agrees
03:45:24 <cheater_> nice
03:45:27 <cheater_> what months?
03:45:27 <Nereid> simply typed was 1940
03:45:39 <Nereid> cheater_: I don't think it matters at this level :P
03:45:44 <cheater_> does too
03:45:45 <cheater_> i wanna know
03:46:05 <Kaidelong> if I remember correctly
03:46:06 <merijn> Naiqvist: You can also run use functions etc. for example if you have the list [1,2,3,4,5,6,7,8,9,10] and wanted only the odd numbers
03:46:10 <merijn> > filter even [1,2,3,4,5,6,7,8,9,10]
03:46:11 <lambdabot>   [2,4,6,8,10]
03:46:13 <Nereid> church's paper on lambda calculus was published in april 1936
03:46:17 <merijn> Eh
03:46:18 <Kaidelong> the lambda calculus wasn't even invented for anything to do with computers
03:46:19 <merijn> My bade
03:46:20 <Nereid> turing's was published early 1937, apparently
03:46:23 <merijn> > filter odd [1,2,3,4,5,6,7,8,9,10]
03:46:24 <lambdabot>   [1,3,5,7,9]
03:46:28 <Nereid> but publication dates are not invention dates
03:46:30 <Kaidelong> was just a way to think about existing logics that are equivalent to it
03:46:38 <Nereid> (or discovery dates, depending on your point of view toward mathematics)
03:46:51 <Kaidelong> then someone showed (think it was turing) that turing machines can be seen as lambda calculusand vice versa
03:47:06 <Naiqvist> does it only worked with unsigned integers?
03:47:12 <earthy> on computable numbers was received in may 1936
03:47:14 <Nereid> Naiqvist: huh?
03:47:23 <Naiqvist> lambda bot
03:47:28 <Kaidelong> no?
03:47:28 <earthy> so, lambda calculus is just slightly older.
03:47:31 <Nereid> lambdabot understands full haskell
03:47:32 <Nereid> :P
03:47:39 <Kaidelong> > minBound :: Int
03:47:39 <Naiqvist> do something complicated
03:47:40 <lambdabot>   -9223372036854775808
03:47:45 <Naiqvist> ah
03:47:47 <Naiqvist> nice
03:47:48 <merijn> > filter odd [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1]
03:47:49 <lambdabot>   [-9,-7,-5,-3,-1]
03:47:50 <earthy> ofcourse, this all discounts babbage's difference engine and Ada Lovelace's work on software
03:48:02 <Nereid> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
03:48:03 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:48:19 <merijn> Nereid: Way to show non-intimidating examples ;)
03:48:20 <Naiqvist> how big is the standard haskell lib?
03:48:21 <Nereid> lol
03:48:26 <merijn> Naiqvist: BIG
03:48:35 <earthy> um. not that big
03:48:36 <Nereid> merijn: I forgot the scanl version
03:48:40 <Naiqvist> compared to C
03:48:43 <Naiqvist> its BIG
03:48:47 <earthy> nope
03:48:50 <Naiqvist> oh
03:48:53 <erus`> whats the function for is x in xs?
03:48:57 <earthy> compared to C it's about similar in size
03:49:00 <Nereid> erus`: elem
03:49:01 <kosmikus> standard is only what the librry report defines
03:49:07 <Nereid> > 5 `elem` [2..6]
03:49:07 <kosmikus> base is much bigger
03:49:08 <lambdabot>   True
03:49:11 <Kaidelong> > let fibs = 0 : 1 : scanl (+) 1 (tail fibs)
03:49:12 <lambdabot>   not an expression: `let fibs = 0 : 1 : scanl (+) 1 (tail fibs)'
03:49:17 <Kaidelong> > let fibs = 0 : 1 : scanl (+) 1 (tail fibs) in fibs
03:49:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:49:21 <Naiqvist> im still a bit confused about how to get ghci working on the command line
03:49:21 <merijn> Ah, yeah. I was talking about base, not standard library
03:49:33 <Nereid> > let fibs = 0 : scanl (+) 1 (tail fibs) in fibs
03:49:34 <lambdabot>   [0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
03:49:36 <Nereid> oops
03:49:43 <Kaidelong> > let fibs = 1 : scanl (+) 1 fibs in fibs --without 0
03:49:44 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
03:49:47 <Nereid> heh
03:49:52 <earthy> yeah, Haskell Platform is a *lot* bigger even
03:49:57 <merijn> Naiqvist: Is haskell plaftorm installed now? Then you just run "ghci" and it'll show some stuff and end with a prompt like "Prelude> "
03:49:59 <earthy> still not that big when compared to java
03:50:06 <Naiqvist> OK
03:50:21 <merijn> Naiqvist: Then you can just type and hit enter (without the "> ", that's just for lambdabot)
03:50:28 <Kaidelong> I was surprised at how small the haskell platform is
03:50:37 <Kaidelong> rather than at how big it was
03:50:38 <Nereid> > let fibs = 0 : scanl (+) 1 fibs in fibs
03:50:39 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:50:53 <Nereid> with the 0, like it should be ;)
03:50:58 <Kaidelong> oh my
03:51:04 <Kaidelong> oh of course
03:51:18 <Nereid> one day I'll look up the definition of scanl
03:51:19 <Naiqvist> OK its working
03:51:40 <Kaidelong> scanl _ [] = []
03:51:48 <erus`> > vowels "Hello" when let vowels xs = filter (`elem` ['a','e','i','o','u']) xs
03:51:49 <lambdabot>   <no location info>: parse error on input `let'
03:51:53 <merijn> @src scanl
03:51:53 <lambdabot> scanl f q ls = q : case ls of
03:51:53 <lambdabot>     []   -> []
03:51:54 <lambdabot>     x:xs -> scanl f (f q x) xs
03:52:28 <Kaidelong> oh it yields the accumulator even in the case of an empty list?
03:52:31 <Kaidelong> oops then
03:52:58 <Naiqvist> do I save all my .hs files in the same folder as ghci?
03:53:04 <Kaidelong> I guess that gives tail . scanl x y the interesting property of never, ever failing
03:53:18 <Kaidelong> due to tail getting an empty list
03:53:19 <Nereid> Naiqvist: nooooooooo D:
03:53:24 <Naiqvist> noooooooo?
03:53:26 <merijn> Naiqvist: You can save the .hs files anywhere you want
03:53:28 <Nereid> ^
03:53:34 <Naiqvist> OK
03:53:43 <luite2> Naiqvist: not the folder where ghci is installed. you typically cd to some directory where you stored your haskell files, and then start ghci there
03:53:45 <Nereid> but if you want convenient access to the from ghci, run ghci from the directory your .hs files are in
03:53:49 <Kaidelong> probably some place like ~/haskell/ProjectName/
03:53:51 <Nereid> to them*
03:54:10 <merijn> Naiqvist: You can also type ":load <filename>" to load your .hs file into ghci and use ghci's commands on the code you wrote
03:54:28 <Naiqvist> OK I know where that is
03:54:54 <erus`> let vowels xs = filter (`elem` ['a','e','i','o','u']) xs in vowels "Hello"
03:54:58 <Naiqvist> I'm just not sure what to expect with this language
03:55:01 <erus`> >let vowels xs = filter (`elem` ['a','e','i','o','u']) xs in vowels "Hello"
03:55:09 <Naiqvist> I'm use to C which is pretty simple to compile
03:55:21 <Naiqvist> but I'm getting it now
03:56:10 <Kaidelong> erus`: almost there, you need a space after the >
03:56:27 <Kaidelong> C is simple to compile?
03:56:45 <merijn> You can also use "ghc -o mybinary something.hs" like you would with C, but the first few things you write in Haskell probably won't be that interesting to compile and much easier to play with using ghci
03:56:47 <Kaidelong> my whole life is a lie
03:56:58 <Nereid> merijn: --make
03:57:19 <luite2> not necessary if you use ghc 7
03:57:21 <erus`> > let vowels xs = filter (`elem` ['a','e','i','o','u']) xs in vowels "Hello"
03:57:22 <lambdabot>   "eo"
03:57:29 <erus`> yey
03:58:39 <Naiqvist> what's the first language you all learned
03:58:45 <b52> asm
03:58:54 <Naiqvist> really?
03:58:59 <b52> yes
03:59:00 <companion_cube> scheme, then python
03:59:06 <Naiqvist> how long have you been programming?
03:59:10 <Naiqvist> b52
03:59:11 <b52> asm -> c -> python -> haskell
03:59:44 <merijn> Python -> Java -> C -> relearn Python properly -> assembler -> OCaml (except really suckily) -> Prolog -> Haskell
03:59:44 <b52> dunno, i would say about 8 years
04:00:09 <b52> started with age of 13/14
04:00:26 <Naiqvist> I'm 16 now.
04:00:35 <Naiqvist> this is pretty fun stuff
04:00:37 <Kaidelong> (*Nebulous*) -> SML/NJ -> Java -> Visual Basic -> C# -> (*Nebulous*) -> F# -> Haskell -> ???
04:00:50 <Kaidelong> -> Profit
04:00:50 <Naiqvist> what is F#
04:00:59 <b52> Kaidelong: :D
04:01:00 <Naiqvist> don't give me a link
04:01:04 <Kaidelong> it's a language in the ML family
04:01:07 <Naiqvist> I want to know opinions
04:01:15 <Naiqvist> is it a whole bunch a bull shit
04:01:17 <Kaidelong> it's very similar to Haskell
04:01:19 <Naiqvist> oh
04:01:30 <b52> i think its a ms product isnt it?
04:01:39 <merijn> .NET language based on stuff like Haskell/ML
04:01:46 <Naiqvist> I looked it up
04:01:49 <Naiqvist> yeah its microsoft
04:01:53 <merijn> Well, you could argue GHC is partially an MS project too :p
04:02:01 <Kuraj> can anyone help me with grasping the concept between operator types?
04:02:01 <Kaidelong> Yeah, Don Syme's group. Some of the same people who worked on Haskell I think
04:02:04 <b52> merijn: how come?
04:02:12 <Kaidelong> Erik Meijir was probably involved some way or another
04:02:43 <Kaidelong> Kuraj: Operator types? You mean like [] and ->?
04:02:58 <Kaidelong> they're just type constructors
04:03:04 <Kaidelong> with a funny syntax
04:03:08 <Kuraj> :t (.) equals (b->c) -> (a->b) -> (a -> c), how come :t (.)(.) is (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c?
04:03:08 <lambdabot> parse error on input `->'
04:03:12 <merijn> b52: SPJ and Simon Marlow work at MS Research
04:03:18 <Kuraj> ^ i just dont get what is happening up there
04:03:41 <b52> merijn: yeah, i recently viewed a speech from spj
04:03:55 <Kaidelong> because (.) is a function (b->c)->((a->b)->(a->c))
04:04:07 <merijn> Kuraj: Grab a piece of paper and start doing substitution by hand, that's the easiest way to figure that sorta thing out
04:04:28 <Naiqvist> does the order of operations in haskell work pretty normally?
04:04:44 <Naiqvist> compared to C
04:04:48 <luite2> Naiqvist: no
04:05:05 <Kaidelong> if you feed it an argument in the form ((b->c)->((a->b)->(a->c))), it gives you something in the form (((a->b)->(a->c))->d)->((b->c)->d)
04:05:16 <Naiqvist> luite2: in a good way or a hard way?
04:05:16 <merijn> Naiqvist: The math operations work as you'd expect. But things like functions do not (specifically functions that require parenthesis and have the high priority)
04:05:35 <Naiqvist> OK
04:05:39 <Kuraj> my head just blew
04:05:50 <merijn> Naiqvist: So if f is a function then "f a + b" would be the same as "f(a) + b"
04:05:57 <Kaidelong> > fmap fmap fmap
04:05:58 <lambdabot>   Overlapping instances for GHC.Show.Show
04:05:58 <lambdabot>                              ((a ->...
04:06:05 <Kaidelong> @ty fmap fmap fmap
04:06:06 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:06:13 <luite2> Naiqvist: well, depends on what exactly you mean. associativity and precedence are usually the same, so the answer is usually the same, but the order in which the expressions are evaluated will be quite different
04:07:06 <merijn> Naiqvist: Yeah, laziness can let you do weird things. Like having infinite data structures or other impossible things without running into errors
04:07:33 <merijn> > if 2 == 2 then 10/2 else 10/0
04:07:34 <lambdabot>   5.0
04:07:41 <merijn> See, no division by 0 error
04:07:47 <luite2> merijn: lol
04:08:08 <luite2> I'd have chosen an example that would've errored in C :p
04:08:12 <Nereid> lol
04:08:15 <merijn> Which of course would work in any short circuiting language in this case, but I couldn't think of a better simple example :p
04:08:33 <Nereid> > fst (5, 10/0)
04:08:33 <lambdabot>   5
04:08:41 <parcs> > 10/0
04:08:42 <lambdabot>   Infinity
04:08:46 <Nereid> mm
04:08:49 <Nereid> > fst (5, undefined)
04:08:49 <lambdabot>   5
04:08:52 <Nereid> > undefined
04:08:53 <lambdabot>   *Exception: Prelude.undefined
04:08:57 <merijn> Lambdabot is lying scum again
04:09:01 <imladris> I have been playing with repa, trying to figure out how it works. I would be happy if anyone could have a look at a small example code I wrote, and hopefully give me some good ideas on how to improve it. :-)
04:09:20 <merijn> > sqrt (-1)
04:09:21 <lambdabot>   NaN
04:09:47 <Kaidelong> @ty sqrt
04:09:48 <lambdabot> forall a. (Floating a) => a -> a
04:09:52 <Claudius1aximus> > sqrt (-1) :: Complex Double
04:09:53 <lambdabot>   (-0.0) :+ 1.0
04:09:57 <Kaidelong> @instances-importing floating
04:09:58 <lambdabot> Couldn't find class `floating'. Try @instances-importing
04:10:02 <Naiqvist> how long did it take to become haskell fluent
04:10:04 <Kaidelong> @instances-importing Floating
04:10:04 <lambdabot> Double, Float
04:10:19 <tomh> Naiqvist: a lifetime :D
04:10:27 <Naiqvist> tomh
04:10:35 <Kaidelong> Naiqvist: Haskell is actually not that hard to learn despite its reputation. Fluency comes with use, and I dunno if you are ever really fluent in a programming language
04:10:58 <tomh> I think its pretty hard
04:10:58 <twende> http://hpaste.org/46382/some_repa_code
04:10:58 <tomh> \
04:11:07 <tomh> definitely the hardest language I know
04:11:11 <Naiqvist> really?
04:11:19 <merijn> Naiqvist: I think it took me a few months to get the basics, but back then there was no Learn You a Haskell yet
04:11:23 <tomh> yeah, but I can only speak for myself
04:11:34 <Naiqvist> tomh: what other languages do you know?
04:11:41 <merijn> Naiqvist: I disagree. I think it's not that hard, it's just very different from other languages
04:11:47 <tomh> c#/java/js/python
04:11:50 <tomh> ruby
04:12:00 <tomh> and some others but not that intensive experience
04:12:32 <aristid> tomh: obviously Kaidelong was comparing against J and Forth :)
04:12:43 <tomh> hehe
04:12:50 <Kaidelong> J is ugly and hard to think in
04:13:04 <Naiqvist> I mean
04:13:07 <Naiqvist> its a bit weird
04:13:14 <Naiqvist> but its not illogical or confusing really
04:13:19 <aristid> haskell is a pretty small language
04:13:27 <Naiqvist> its actually pretty straightforward so far
04:13:33 <Kuraj> well they have us to learn haskell at the university
04:13:36 <Naiqvist> > succ 8
04:13:37 <lambdabot>   9
04:13:41 <Naiqvist> mmm
04:13:50 <b52> Kuraj: nais! :D
04:13:50 <tomh> the language itself might be ok to get comfortable with, but not with the code other people have written in it :D
04:13:50 <Kuraj> last week we had some sort of introductory lecture, i began studying learn you a haskell
04:13:52 <merijn> Naiqvist: The core of Haskell is pretty easy. The more advanced features can be a little hard, but that's just because other languages don't even *have* those features
04:14:12 <Naiqvist> merijn: briefly, what kind of features are those?
04:14:31 <tomh> rank-2 types
04:14:33 <aristid> i think scala for example has a lot more complexity than haskell
04:14:48 <tomh> scala is more limited than haskell
04:14:48 <b52> Kuraj: i highly recommend "Programming in Haskell" by  graham hutton
04:14:50 <Kuraj> b52: because this is the first list of tasks: https://kno.ii.uni.wroc.pl/ii/file.php/125/lista9.pdf (tasks 3-7)
04:15:08 <Nereid> Kuraj: needs a login ;(
04:15:12 <Kuraj> oh
04:15:14 <Kuraj> one sec will rehost
04:15:33 <merijn> The typeclass system is (ab)used to implement incredibly abstract interfaces which allow very short code, but can be hard to understand. Also as tomh mentions, rank-2 types, GADTs and a lot of other complicated words I barely understand enough to explain ;)
04:15:35 <Kuraj> or screengrab
04:16:08 <aristid> tomh: those statements are not incompatible though
04:16:22 <tomh> aristid: I think scala is easier :)
04:16:24 <tomh> than haskell
04:16:42 <aristid> tomh: because you can initially ignore its complexity and pretend it's java with a different syntax
04:17:06 <tomh> I tried implementing SYB in scala
04:17:13 <tomh> so ive seen the limits of the language
04:17:14 <Naiqvist> >92 'div' 10
04:17:23 <tomh> typesystem wise
04:17:23 <Naiqvist> hmmm didnt work
04:17:27 <merijn> Naiqvist: Wrong quotes :)
04:17:33 <b52> >92 `div` 10
04:17:34 <Naiqvist> I see
04:17:38 <b52> > 92 `div` 10
04:17:39 <merijn> You need backticks (`), not '
04:17:39 <lambdabot>   9
04:17:50 <merijn> Naiqvist: You will see that if you hang around here in #haskell for a while people will do all sorts of complex looking nonsense which makes no sense. But just because those things exist doesn't mean you have to use them. You can just use the simple basics until you are ready to move on
04:18:14 <merijn> On a US keyboard the backtick will be on the same key as ~, left of the 1 key
04:18:15 <Naiqvist> >92`div`10
04:18:31 <merijn> (forgot a space after > :)
04:18:35 <Naiqvist> oh
04:18:58 <Naiqvist> > 92`div` 10
04:18:59 <lambdabot>   9
04:19:11 <Kuraj> b52: there: http://i.imgur.com/wCS4s.jpg
04:19:14 <Kuraj> see
04:19:23 <liyang> I've been reading some ghc-core, and I'm seeing a large number of *## 0.0 xyz in my code. I don't really care about what IEEE-754 has to say about Infinity and NaN, and was wondering if I could get ghc to rewrite those multiplications as just 0.0 instead?
04:19:36 <Kuraj> i dont think this kind of tasks is really appropiate for someone who just began taking babysteps in haskell :(
04:20:27 <Kuraj> well ok - we already know prolog, so simple exercises like working with lists wouldnt be helping either
04:20:38 <Kuraj> but argh, come on.
04:20:54 <merijn> Kuraj: They're somewhat doable if you carefully do substitution by hand. Most of them aren't as hard as they look
04:20:54 <Kuraj> i barely get whats going on
04:20:58 <tomh> those excercises don't really look practical :)
04:21:19 <merijn> Kuraj: Which part(s) don't you get?
04:21:52 <Kuraj> merijn: it's not exactly that I don't get stuff. if I dont get something, i'll just read up on it
04:22:05 <Kaidelong> those seem like easy exercises tome
04:22:12 <Nereid> indeed
04:22:13 <Kaidelong> mostly just mechanical
04:22:17 <Kuraj> it just seems like a lot of stuff to handle at once
04:22:25 <Kuraj> well
04:22:29 <Nereid> like for problem 3
04:22:33 <Kuraj> i'll be off trying to solve these for now
04:22:34 <Nereid> look at what type swap must have
04:22:35 <Claudius1aximus> liyang: maybe compiling via C and telling gcc to -O3 -ffast-math  will make that disappear at the next stage?
04:22:38 <tomh> I personally don't think those excersises are useful
04:22:40 <merijn> Well, I can see substituting "flip flip flip"by hand will get old quick ;)
04:22:46 <tomh> they are more mathematical
04:23:04 <Nereid> I wouldn't want to find the type of flip flip flip by hand
04:23:09 <Kuraj> tomh: a lot of stuff we study here is actually something a mathematician would study
04:23:12 <Kuraj> rather than a computer scientist
04:23:15 <Nereid> I'd use ghci and no one can stop me D:::
04:23:17 <Naiqvist> what do you use variables like foo and bar for
04:23:24 <Kaidelong> problem 3 is harder looking but it just so happens, for that case, proving that they have the same type is enough to prove that hey arethe same
04:23:29 <Nereid> Naiqvist: ???
04:23:31 <merijn> The more CS I learn, the more I realized I should have majored in Math to be any good in CS
04:23:31 <tomh> Kuraj: here is?
04:23:42 <Nereid> merijn: double major ;)
04:23:45 <Naiqvist> Nereid: I'm just wondering what it means when people name functions foo
04:23:52 <liyang> Claudius1aximus: that seems rather awkward. D: I've tried a RULE of forall n. 0 * n = 0 , but that did bugger all, as suspected.
04:23:54 <Nereid> Naiqvist: it's just a name
04:23:58 <Nereid> that doesn't mean anything and is arbitrary
04:23:58 <merijn> Nereid: Nearly done and they're hiking up the price fo doing a second master :p
04:23:58 <Naiqvist> Nereid: OK
04:24:01 <Nereid> http://en.wikipedia.org/wiki/Foo
04:24:03 <tomh> to be good in haskell a degree in math seems more useful than a degree in CS :P
04:24:03 <Kuraj> the institute of computer science, university of wroclaw, poland
04:24:11 <tomh> ok
04:24:27 <Kuraj> tomh: i think i'll agree
04:24:29 <merijn> Naiqvist: foo and bar are just traditional programming names for "this needs a name, but I can't be arsed to come up with one" (they're used in almost any language I know)
04:24:30 <Kuraj> haha
04:24:39 <Naiqvist> Nereid: OK I get it.
04:24:53 <Naiqvist> Nereid: thanks
04:25:01 <Kuraj> ok, let's see..
04:25:12 <Nereid> oh crap
04:25:15 <Nereid> @localtime Nereid
04:25:16 <lambdabot> Local time for Nereid is Thu May 5 05:29:18 2011
04:25:17 <Nereid> I better go!
04:25:18 <Nereid> bye
04:25:44 <b52> your going to sleep now?
04:25:47 <Nereid> yeah.
04:25:50 <b52> dude ..
04:25:52 <Nereid> lol
04:26:03 <Nereid> I know, I'm terrible :(
04:26:09 <Naiqvist> merijn: is that an acceptable coding practice?
04:26:40 <Naiqvist> I guess if you comment it doesn't matter
04:26:45 <merijn> Naiqvist: In actual programs it is bad, but when giving people examples are writing a quick test it is very common
04:26:56 <Naiqvist> merijn: Oh I get it
04:27:01 <tomh> Kuraj: if you want to see some nice advanced excersises look here: http://www.cs.uu.nl/wiki/bin/view/Afp/Assignments :)
04:27:10 <Kuraj> thanks!
04:27:12 <merijn> Naiqvist: If it is code you will use for a long while you should write a proper name, but sometimes you just want to test something quickly and not think hard about names
04:28:11 <merijn> Like I want to show you a function definition but not come up with a name
04:28:22 <merijn> > let foo x = x / 10 in foo 5
04:28:23 <lambdabot>   0.5
04:28:49 <Kuraj> oh wow
04:29:01 <Kuraj> the bot automatically executes expressions that you write here?
04:29:08 <aristid> it does.
04:29:11 <aristid> :t 4
04:29:12 <merijn> Kuraj: If you prefix them with "> ", yes
04:29:12 <lambdabot> forall t. (Num t) => t
04:29:19 <aristid> it can also give you the type of expressions
04:29:24 <aristid> @pl foo x = x / 10
04:29:24 <lambdabot> foo = (/ 10)
04:29:32 <Kuraj> what if i use cycle or repeat? :P
04:29:33 <aristid> and it can modify expressions in some ways
04:29:36 <merijn> You can also let use it to check the type of expressions, simplify programs, search libraries, etc
04:29:40 <aristid> > cycle "Kuraj! "
04:29:41 <lambdabot>   "Kuraj! Kuraj! Kuraj! Kuraj! Kuraj! Kuraj! Kuraj! Kuraj! Kuraj! Kuraj! Kura...
04:29:45 <Kuraj> oh
04:29:47 <Kuraj> clever
04:29:52 <Nereid> @djinn (b -> c) -> (a -> b) -> a -> c
04:29:52 <lambdabot> f a b c = a (b c)
04:29:54 <merijn> Kuraj: Most exploits (even non-trivial) one have been tried :p
04:30:18 <Nereid> @. pl djinn (b -> c) -> (a -> b) -> a -> c
04:30:18 <lambdabot> f = (.)
04:30:21 <merijn> Forgot a function name?
04:30:38 <merijn> @hoogle (a -> Bool) -> [a] -> [a]
04:30:38 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
04:30:38 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
04:30:38 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
04:30:45 <Naiqvist> anyone here on osx?
04:30:51 <merijn> Naiqvist: I am
04:31:15 <Kaidelong> @. pl djinn ((b->c)->((a->b)->(a->c)))->(((a->b)->(a->c))->d)->((b->c)->d)
04:31:16 <lambdabot> f = const (. (.))
04:31:28 <Naiqvist> merijn: Where do you save all of your .hs files?
04:31:32 <Kuraj> so is haskell similar to other functional languages (i dunno, OCaml)?
04:31:39 <Kaidelong> Yes
04:31:41 <Kaidelong> and no
04:31:41 <Kuraj> i had an opportunity to study the later before, but decided to postpone it
04:31:53 <Kuraj> latter *
04:31:55 <merijn> Naiqvist: I just use Documents/projects/haskell in my home directory
04:31:55 <Naiqvist> merijn: I believe there was a folder in the haskell platform but I can't finder it
04:31:59 <maus> does some analog of List.zip exist for Data.Map?
04:32:00 <Naiqvist> OK
04:32:03 <Kaidelong> most significant thing that makes Haskell different is that it is pure
04:32:11 <Kaidelong> and this is profoundly important
04:32:13 <Naiqvist> merijn: and you just run terminal from there?
04:32:14 <merijn> Kaidelong: And type classes, I would say
04:32:18 <merijn> Naiqvist: Yes
04:32:21 <Naiqvist> OK
04:32:41 <Kuraj> oh?
04:32:42 <Kaidelong> scala has those too though and some of the MLs and lisps do not gain much from typeclasses
04:33:17 <Kaidelong> since they have other ways to get ad hoc polymorphism, sometimes more general
04:33:17 <merijn> Kuraj: There is some similarity with OCaml, but they are not the same. Enough that once you learn Haskell learning OCaml should be easy, though
04:33:24 <opqdonut_> maus: mergeWith
04:33:31 <Kuraj> oh i get what you mean with "pure" now
04:33:32 <opqdonut_> :t Data.Map.mergeWith
04:33:33 <lambdabot> Not in scope: `Data.Map.mergeWith'
04:33:36 <opqdonut_> gah
04:33:55 <Kuraj> i see
04:34:07 <Kaidelong> purity implies const <*> id == id
04:34:17 <opqdonut_> er, sorry
04:34:26 <opqdonut_> :t Data.Map.unionWith -- maus
04:34:27 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
04:34:30 <merijn> Kuraj: For example, OCaml allows functions with side effects, which Haskell does not. Which obviously has some significant implications
04:34:47 <Kuraj> like that a variable once assigned cannot be redefined?
04:34:49 <merijn> Kuraj: i.e. does "prompt :: String -> String" do IO or not?
04:34:59 <Kaidelong> well then it's not really a variable
04:35:01 <Kaidelong> call it a binding
04:35:04 <Kaidelong> OCaml does that too
04:35:05 <opqdonut_> maus: if you want only the keys that are in both you can also use intersectionWith
04:35:07 <merijn> You can't redefine variables in OCaml either
04:35:17 <Kaidelong> merijn: but you can shadow them
04:35:21 <Kuraj> prolog does that too and i learned it the hard way :D
04:35:25 <Kaidelong> which makesme a bit sad
04:35:28 <merijn> But in OCaml the function I just gave can do IO, in Haskell it cannot
04:35:37 <Kaidelong> Prolog is an awesome thing to learn to get into Haskell
04:35:54 <merijn> I learned Prolog at some point, but forgot almost all of it. I should relearn it
04:35:58 <companion_cube> merijn, sometimes it can be useful, e.g. for hashconsing
04:36:02 <Kuraj> i must agree it made it much easier to read through the beginner tutorials
04:36:07 <Kaidelong> Haskell is done in a very prolog-like style
04:36:27 <Kuraj> im already pretty fluent with stuff like lists or recursive functions on those
04:36:29 <Kaidelong> usually things are in the form of "name (pattern) = rewritten-term"
04:36:31 <Kuraj> i guess
04:36:42 <Kaidelong> and you can have multiple of them
04:36:42 <Kaidelong> for different patterns
04:36:42 <merijn> companion_cube: I'm not saying it can't be useful. I'm just saying its an important fundamental difference between Haskell and OCaml :)
04:36:44 <Kaidelong> just like Prolog
04:37:29 <Kaidelong> so a name(pattern1), name(pattern2), etc
04:37:41 <Kuraj> well i always thought prolog and haskell were kinda similar when i first learned about the latter; even though they go by different paradigms
04:37:58 <Kuraj> hey, brb.
04:38:03 <Kaidelong> and the way prolog short circuits on evaluating conjunctions and disjunctions will make non-strict evaluation less surprising, too
04:38:23 <Kaidelong> well
04:38:45 <Kaidelong> in prolog you can still traverse the whole tree if you want to, of course
04:38:51 <Kaidelong> unless you explicitly cut
04:39:09 <Kaidelong> either way I think if you know prolog haskell will be much less surprising
04:39:19 <Kaidelong> perhaps even than if you knew OCaml
04:39:44 <merijn> Hmm, I should really get back to the "paper writing mobile"! It's already 2 and I haven't written a word yet >.>
04:40:07 <quicksilver> merijn: haskell is primarily a device to procrastinate when you are supposed to be writing papers.
04:40:34 <aristid> quicksilver: it's funny how everything about a computer seems to be made for just this purpose.
04:40:48 <merijn> I know, but the abstract is due tomorrow and I promised my supervisor I'd have a draft finished today :p
04:40:48 <quicksilver> :)
04:41:11 <merijn> Everything I learned about type theory I learned by procrastinating papers :p
04:41:25 * Kaidelong goes to lay down and probably not sleep
04:41:35 <merijn> "I procrastinated while writing a paper and all I got was this lousy understanding of type theory!"
04:41:46 <merijn> Hmm, I should make  t-shirt with that...
04:42:26 <aristid> merijn: if everybody is like you (a simplifying assumption), this will be a huge commercial success
04:42:26 <Naiqvist> its saying my function isn't in the scope
04:42:46 <aristid> Naiqvist: http://hpaste.org
04:43:09 * hackagebot Noise 1.0.0 - A Haskell coherent noise generator  http://hackage.haskell.org/package/Noise-1.0.0 (HugoGomes)
04:44:06 <HugoDaniel> yay
04:44:08 <merijn> I still wish someone with more of a gift in graphic design would make a shirt which has "x.x" decorated to look like a church with the line "In Church we trust" underneath it. (This one will be an even bigger commercial success ;)
04:44:11 <HugoDaniel> lets all have a big party
04:44:16 <HugoDaniel> get drunk and all
04:44:23 <HugoDaniel> because today i uploaded my second package to hackage
04:44:28 <HugoDaniel> http://hackage.haskell.org/package/Noise-1.0.0  <- winning
04:44:43 <HugoDaniel> sheeezz the documentation is all messed up
04:44:48 <HugoDaniel> ill look into that l8er
04:46:26 <Kuraj> its weird.
04:46:46 <Kuraj> i just looked onto the upcoming list of tasks (the next one after the one i just pasted) and it seems much easier and practical
04:47:33 <maus> opqdonut_, I want to zip two maps with elements of different types
04:48:35 <Naiqvist> What kind of applications have you programmed with haskell?
04:51:01 <Naiqvist> is learning two languages at once a bad idea
04:51:04 <merijn> Not any of my applications, but: The most famous one is probably XMonad (which is a window manager for X11), there are also multiple webservers, financial applications, Google has written (part of) a cluster management tool in Haskell
04:51:47 <parcs> there's also ghc itself
04:51:48 <merijn> Naiqvist: Depends on the person, I've learned multiple languages at once, but other people seem to get confused. And in the case of haskell it might require more of your focus. But in general there's no reason why it wouldn't work
04:52:34 <merijn> Oh, an HaLVM (virtual machine for running haskell applications "bare metal" on Xen virtualization)
04:52:35 <Naiqvist> merijn: I really like the way haskell makes me look at and organize my code
04:52:49 <merijn> Naiqvist: That is one of the nicest things about it, yes
04:53:51 <Naiqvist> it seems fast too
04:54:36 <Naiqvist> my biggest problem with learning languages is just deciding what to program
04:54:57 <Naiqvist> its kind of uninspiring working out of books all the time
04:55:03 <merijn> Try simple games?
04:55:09 <merijn> Tic-tac-toe, for example?
04:55:16 <Naiqvist> thats a good idea
04:55:20 <merijn> Or maybe blackjack
04:55:27 <mm_freak_> Naiqvist: i'm programming web applications and server programs
04:55:44 <mm_freak_> Naiqvist: nothing on hackage though except of the libraries i have written for them
04:55:49 <merijn> (Although blackjack could be a little tricky, shuffling cards is surprisingly difficult)
04:55:58 <Naiqvist> I still mostly want to DSP
04:56:10 <Naiqvist> and it seems like haskell would be good for that
04:56:26 <Naiqvist> for some parts
04:56:28 <merijn> Naiqvist: The only way to learn hard things is to simply try ;)
04:56:36 <mm_freak_> merijn: i think the most famous but least considered application in haskell is GHC
04:56:46 <mm_freak_> then comes darcs and then perhaps xmonad
04:57:00 <Egbert9e9> guys i have an idea for an app in smartphones and i want to write it in haskell
04:57:03 <merijn> mm_freak_: Obviously, but I tend to assume people mean programs which are big outside the Haskell ecosystem
04:57:29 <mm_freak_> darcs is
04:57:41 <mm_freak_> it has nothing to do with haskell specifically except that it was written in it
04:58:08 <mm_freak_> Naiqvist: if you mean DSP, haskell is great for it
04:58:19 <mm_freak_> but if you mean high performance DSP, you'll likely prefer C oder assembly
04:58:27 <mm_freak_> or a haskell binding to such a library
04:59:22 <Naiqvist> mm_freak_: do you  have any experience with dsp?
05:01:02 <Kerris> is there a selfhosting Haskell compiler :V
05:01:21 <merijn> Kerris: GHC is selfhosting...
05:01:27 <osfameron> is it entirely so now?
05:01:30 <merijn> Yes
05:01:37 <osfameron> hurrah!
05:01:39 <Kerris> Wow, I'm outdated.
05:01:45 <merijn> Has been a while, afaik
05:01:58 <merijn> -via-C hasn't been the default in a while
05:02:21 <osfameron> it was very early versions that had an Evil Mangler written in Perl, wasn't it?
05:04:00 <Naiqvist> what do most computer programmers these days program professionally? web apps?
05:04:10 <Philippa> the Mangler was still there in 6.x, I thought
05:04:32 <merijn> Naiqvist: Well, that is probably most. But you should do what you enjoy instead of what most people do :p
05:04:36 <mm_freak_> Naiqvist: just a few experiments for fun, but nothing serious
05:04:53 <merijn> I like to do OS/compiler/systems programming stuff
05:05:02 <mm_freak_> Naiqvist: i don't know what most programmers write, but i earn my money with networking applications
05:05:11 <Naiqvist> mm_freak_: how far into dsp did you delve?
05:05:18 <mm_freak_> not very far
05:05:41 <mm_freak_> i think the best i did was an implementation of FFT
05:05:53 <mm_freak_> and i couldn't reproduce it today without reading wikipedia again
05:06:16 <Naiqvist> mm_freak_: what language did you use?
05:06:24 <mm_freak_> haskell
05:06:47 <Naiqvist> mm_freak_: did you use the cooley-tukey algorithm?
05:07:17 <Kaidelong> Hugs and Gofer weren't written in Haskell?
05:07:33 <synonymous> Naiqvist: does your nick name come from niquist?
05:07:37 <SoleSoul> Hello :). I have a problem with a ghc error I don't understand. it says    Could not deduce (Read a) arising from a use of `read'    . I have pasted the function and the full error message here: http://hpaste.org/46384/read_problem   Please help me understand it's meaning
05:07:45 <Naiqvist> synonymous: yup
05:07:46 <mm_freak_> but unlike most other haskell programmers i'm not attached so much to the view that haskell is particularly good for numeric stuff  haskell shows its strengths, when you create concurrent applications
05:08:00 <Naiqvist> Naiqvist: I was initially searching for dsp help
05:08:09 <Kaidelong> SoleSoul: You need "(Read a, Num a)"
05:08:12 <mm_freak_> Naiqvist: i don't remember  i think i just turned some equation into code
05:08:17 <synonymous> i've been doing dsp before i got into PL research and Haskell
05:08:39 <synonymous> good to see other dsp'ers here)
05:08:47 <SoleSoul> Kaidelong: But I never do "read" on "n" which is the argument represented by a
05:09:05 <Kaidelong> but
05:09:13 <Kaidelong> you add the result of reading a string to it
05:09:30 <aristid> :t (+)
05:09:31 <lambdabot> forall a. (Num a) => a -> a -> a
05:09:45 <Kaidelong> :t (+) . read
05:09:46 <lambdabot> forall a. (Num a, Read a) => String -> a -> a
05:09:47 <Naiqvist> synonymous: what language or methods do you recommend for dsp?
05:09:59 <SoleSoul> I thought that reading a string produces a Num if there is a number there
05:10:19 <mm_freak_> SoleSoul: you cannot produce a Num
05:10:20 <synonymous> Naiqvist: i only used matlab, mathematica and java for dsp
05:10:21 <Kaidelong> well it produces something that has an instance for Read
05:10:22 <SoleSoul> and I can use it as a regular number
05:10:33 <mm_freak_> SoleSoul: from a string, that is
05:10:37 <Kaidelong> in your case, you want both an instance for Read and an instance for Num
05:10:43 <Kaidelong> so you simply say that in the context
05:10:49 <Kaidelong> (Read a, Num a)
05:10:59 <Kaidelong> and that'll fix it
05:11:03 <aavogt> or leave off the signature completly
05:11:15 <Kaidelong> yeah but encouraging that sounds unwise
05:11:16 <synonymous> Naiqvist: matlab has probably got the most power, and it's fast. but i hate it for its procedural feel
05:11:34 <SoleSoul> Thanks Kaidelong for the fix. I'm still trying to understand though.
05:11:35 <Kaidelong> matlab is fast?
05:11:38 <aristid> Kaidelong: leaving off the type signature, doing :t and adding the output of that is something i actually sometimes do
05:11:46 <Kaidelong> oh sure
05:11:52 <synonymous> Naiqvist: fast for vectorised stuff. i think
05:11:53 <Kaidelong> but I mean, in general
05:11:56 <SoleSoul>  :t read
05:12:03 <SoleSoul> > :t read
05:12:04 <lambdabot>   <no location info>: parse error on input `:'
05:12:07 <Kaidelong> :t read
05:12:08 <lambdabot> forall a. (Read a) => String -> a
05:12:14 <SoleSoul> :t read
05:12:15 <lambdabot> forall a. (Read a) => String -> a
05:12:27 <SoleSoul> :t read "12"
05:12:27 <lambdabot> forall a. (Read a) => a
05:12:47 <Kaidelong> :t 5 + read "12"
05:12:48 <lambdabot> forall t. (Num t, Read t) => t
05:13:07 <SoleSoul> then there is a typeclass "read"
05:13:12 <Kaidelong> exactly
05:13:23 <Kaidelong> well, Read
05:13:27 <Kaidelong> mind the case
05:13:32 <SoleSoul> ok
05:14:01 <SoleSoul> and it's possible to add a "Read" and an integer?
05:14:11 <Kaidelong> No
05:14:19 <Kaidelong> it is possible to add an Integer and an Integer
05:14:32 <aristid> SoleSoul: Integer has an instance of Read.
05:14:33 <Kaidelong> but Integer happens to satisfy the Read typeclass
05:14:36 <Kaidelong> or instantiatiate it
05:14:41 <Kaidelong> or some other weird verb
05:14:50 <SoleSoul> :)
05:14:57 <Naiqvist> synonymous: Did you convert an analog signal into discrete values?
05:14:57 <Kaidelong> Integer also satisfies the Num typeclass
05:15:05 <Kaidelong> I think I will use satisfy
05:15:07 <SoleSoul> now I understand!
05:15:11 <quicksilver> Kaidelong: "is a member of" ?
05:15:18 <mauke> "does"
05:15:22 <Egbert9e9> i don't have a clue how to use glade. is there a guide for gtk2hs that doesn' use glade?
05:15:23 <Naiqvist> this is a pretty great chatroom I have to say
05:15:36 <mauke> but it's a channel!
05:15:41 <Naiqvist> sorry, channel
05:15:48 <mauke> :-)
05:16:14 <SoleSoul> I'm sending a number which is translated as an integer which satisfies both Num and Read. I have to write Read so other types which don't satisfy read but satisfy Num won't be accepted
05:16:18 <Kaidelong> perhaps "proves Read" and "proves Num"
05:16:28 <Kaidelong> hmm no
05:16:33 <Naiqvist> its good to see an active community programmers
05:16:35 <Kaidelong> definitely not
05:16:46 <Naiqvist> at 5:00 in the morning
05:16:56 <Kaidelong> Oh my
05:17:06 <Kaidelong> I was supposed to be resting too
05:17:12 <ezyang> Oleg updates!
05:17:14 <ezyang> "We have seen that yield turns any traversal to a generator. We confirm this result, literally. Any abstract data type that implements the Data.Traversable interface -- at the very least, provides something like mapM -- also implements the generator interface."
05:17:15 <SoleSoul> it's 15:20 here
05:18:06 <SoleSoul> Kaidelong: did you say "definitely not" to me?
05:18:11 <Kaidelong> no
05:18:13 <Kaidelong> to myself
05:18:15 <SoleSoul> ah ok
05:18:27 <SoleSoul> thank you very much!
05:18:36 * Kaidelong decides on "satisfies"
05:19:47 <SoleSoul> supplying functions signatures teaches you alot
05:19:57 <SoleSoul> and prevents bugs
05:20:39 <mauke> also improves error messages if you do something wrong :-)
05:21:29 <Kaidelong> sometimes it is useful to load the module without providing a type, then inspect it, though
05:21:59 <Kaidelong> usually I've only run into these sorts of problems when working with things like mutable vectors
05:22:15 <Kaidelong> where the type became pretty complicated and I had to ask the compiler for help
05:22:47 <aavogt> type inference encourages laziness
05:23:20 <Naiqvist> PHP or Java?
05:23:43 <Naiqvist> or other language in that category
05:24:07 <synonymous> Naiqvist: sorry missed your msg. no my thesis was on aligning two versions of the same musical piece, all in digital domain. and i never got a formal teaching in dsp (courses and such), so i only did what i had to do for my thesis
05:24:52 <dankna> HAH
05:25:05 <Kaidelong> synonymous: you macintosh user!
05:25:06 <dankna> I figured out how to build a polyglot project incorporating a Haskell library from XCode
05:25:17 <dankna> with the possibility to optionally build a profiling version
05:26:11 <dankna> the trick is to add a user variable HASKELL_LIBRARY_WAYS, specialize that on the configuration (null string for normal), then instead of adding the Haskell portions of the project as regular files, enumerate each and every one of them in the OTHER_LDFLAGS variable
05:26:21 <synonymous> Kaidelong: yep, my uni got me one
05:26:23 <dankna> mentioned here in case it's useful to anyone else, and in the hope that someone will share my pain
05:26:25 <Kaidelong> I think the only time I actually had to work with PPC macs was doing music and recording related things
05:27:11 <Kaidelong> synonymous: you studied music, didn't you?!
05:27:29 <Kaidelong> perhaps even at a prestiguous place in Chicago
05:27:31 <Kaidelong> although
05:27:45 <Kaidelong> I suppose a lot of other places also would buy their music students macintoshes
05:27:47 <synonymous> Kaidelong: never studied, but i do play in a band, and was always into the technical side of it too
05:28:07 <Kaidelong> anyway wrong channel, sorry
05:28:24 <synonymous> indeed)
05:29:04 * Kaidelong set up a recording studio
05:29:11 <Kaidelong> and operated it
05:29:16 <Kaidelong> for a while
05:29:31 <Naiqvist> synonymous: Thats cool! How exactly did you pull that off?
05:29:47 <synonymous> Naiqvist: what exactly?
05:30:01 <Naiqvist> synonymous: Aligning the two pieces?
05:30:49 <Naiqvist> synonymous: did you describe the analysis of audio in the time domain? thats what I'm trynna do
05:31:02 <Naiqvist> but with respect to the other music piece
05:31:08 <Peaker> what's the "generator interface"?
05:31:11 <synonymous> Kaidelong: it's awesome to do recording professionally, respect. but i never had enough creativity to make good mixes out of what's been recorded
05:31:25 <Kaidelong> wasn't really professionally
05:31:33 <Kaidelong> wasn't amateur either
05:32:05 <Kaidelong> I sort of got to do it because I helped set up the rig and they couldn't man it all the time without resorting to me
05:32:11 <Naiqvist> I'm trying to make to make audio processors for music
05:32:12 <synonymous> Naiqvist: search for Dynamic Time Warping algo
05:32:34 <synonymous> Naiqvist: like fx?
05:32:50 <Naiqvist> synonymous: Yeah and synthesis
05:33:28 <Naiqvist> synonymous: anything like that interests me
05:33:46 <synonymous> Naiqvist: in forms of plugins? Make bindings for vst and ladspa for haskell!
05:34:04 <jaj> what's the official homepage of gtk2hs now? http://haskell.org/gtk2hs/ doesn't exist anymore
05:34:08 <Naiqvist> synonymous: I could see Haskell binding great with a VST
05:34:21 <joe6> does anyone know if the llvm-ht package is part of the llvm? I got "darcs get http://code.haskell.org/llvm/", but am not sure if it includes the llvm-ht package.
05:34:49 * Egbert9e9 does the dynamic time warp again
05:35:11 <Naiqvist> synonymous: Dynamic time warp is a great algorithm
05:36:01 <synonymous> i don't know how much it's used these daysit's all about HMM's right now in speech recognition and such
05:38:57 <Naiqvist> I'm interested in percussion synthesis
05:39:08 <Naiqvist> but highly realistic percussion synthesis
05:39:36 <Naiqvist> with realistic harmonics
05:41:37 <synonymous> Naiqvist: i was never into synthesis, as I'm mainly listening to real instruments music, butwhy synth "realistic" percussion if you can use samples in that case?
05:42:39 <merijn> Because you might want to synth realistic sounding but unobtainable instruments?
05:42:51 <synonymous> Naiqvist: also, where does haskell fit in all that? are you "in the market" for a language to do dsp?
05:42:56 <merijn> Like the animusic things
05:42:58 <Naiqvist> synonymous: Drum machines and synthetic percussion have always interested me. Not necessarily sounding like a real drum, but having the same complex harmonic character as one.
05:43:08 <merijn> synonymous: He wanted to do DSP in haskell, yeah
05:43:18 <Naiqvist> synonymous: Yeah I'm trying to see if I can do that
05:43:30 <synonymous> merijn: good point
05:43:59 <merijn> Some of the animusic stuff created that way is really cool
05:44:32 <Naiqvist> Have any of you heard of the software Melodyne?
05:44:34 <synonymous> animusic is really great
05:44:42 <synonymous> yeh
05:45:23 <synonymous> i used it once to fix some singer
05:45:27 <Naiqvist> Yeah
05:45:39 <Naiqvist> but you can change the individual notes in a chord
05:45:48 <Naiqvist> thats what interested me a lot
05:48:03 <Naiqvist> it seems simple with a fourier transform
05:48:44 <Naiqvist> but getting nice sounds after shifting the frequency of digital audio is hard
05:48:53 <Naiqvist> usually sounds like crap
05:50:39 <synonymous> yeh..i gave it a thought once. problem is, in a chord you've got overlapping harmonics, coming from different notes, and you don't exactly know how much belongs to the note being shifted
05:51:23 <synonymous> so the timbre changes a lot i guess. i never tried using that newest technology in melodyne though
05:53:28 <MasseR> I got to say, Haskell has excellent tools for our disposal. GHC, ghci, hpc, etc.
05:53:54 <MasseR> I don't need much. A usable readline like interface, and debugging
05:54:06 <MasseR> That's all I need >.< (uhm yeah, java + jdb)
05:54:31 <erus`> I can't make anything big in haskell
05:54:41 <merijn> Don't forget QuickCheck
05:54:43 <erus`> :(
05:55:00 <merijn> Solution, split big things into multiple smaller things. Repeat until you can finish all of them :)
05:55:26 <MasseR> merijn: Lots of tools. I'd spend the next ten minutes listing all of the '<3' stuff in haskell :)
05:55:27 <erus`> actually i mean i can't make a typical game loop
05:55:32 <erus`> or anything liek that
05:55:38 <Naiqvist> why not
05:55:53 <erus`> because its not a standard function
05:55:58 <erus`> its a sequence
05:56:09 <Naiqvist> break it down as simple as possible
05:56:19 <merijn> erus`: A game loop is just a recursive function
05:56:42 <merijn> "loop :: GameWorld -> InputEvent -> GameWorld"
05:57:22 <Naiqvist> only take use of the cpu when you need to though
05:57:56 <merijn> Actually, you want "updateWorld :: GameWorld -> InputEvent -> GameWorld" and "loop :: IO ()"
05:58:30 <Peaker> probably better to flip the order of updateWorld
05:58:31 <erus`> its just a massive brainfuck without mutable states
05:58:35 <aristid> @unmtl State GameWorld ()
05:58:35 <lambdabot> GameWorld -> ((), GameWorld)
05:58:38 <Peaker> so you can do:  updateWorld arg . updateWorld arg . ...
05:59:38 <aristid> with State, you can do updateWorld arg >> updateWorld arg
06:00:01 <aristid> decodeFloat is a funny function
06:00:12 <aep> hey, can i export C functions from a haskell module? http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/ffi-ghc.html seems kindof deprecated
06:05:23 <ClaudiusMaximus> aep: yes., that page seems to document more the ghc-specific stuff, better read the report and/or ffi addendum for more details on the ffi
06:05:34 <aep> from http://haskell.org/haskellwiki/Using_Haskell_in_an_Xcode_Cocoa_project :
06:05:36 <aep> foreign export ccall fibonacci_hs :: CInt -> CInt
06:05:47 <aep> i get: Ccv.hs:12:0: Invalid type signature
06:06:17 <aep> ClaudiusMaximus: thats quite theoretical and doesn't deal with the details of how to actually do something
06:06:33 <aep> ie it lacks the details what actually works with which ghc version
06:07:29 <erus`> recursive functions should stack overflow
06:07:40 <erus`> this is unnatural
06:08:34 <ClaudiusMaximus> aep: hm, i think there's a wiki page somewhere with more practical examples
06:09:58 <aep> ah found it. ghc wants -XForeignFunctionInterface . the pragma doesnt actually works
06:11:04 <ClaudiusMaximus> pragma works for me, maybe you made a typo (the language pragmas all have such long names...)
06:11:25 <synonymous> erus`: under what circumstances does it stack ovf?
06:11:29 <aep> hm possible
06:12:17 <erus`> synonymous: when it loops forever
06:13:35 <synonymous> heh quite reasonable unless the function is tail rec
06:15:37 <aristid> > let f x = x : f (x+1) in f 1
06:15:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:15:42 <aristid> not tail recursive.
06:15:43 <meric> Having trouble installing a package... any one got idea? http://hpaste.org/46386/packaging
06:16:08 <meric> says I am missing a dependency but I have it installed
06:19:00 <dschoepe> meric: Is mtl installed locally for your user perhaps and not globally?
06:19:31 <dschoepe> in that case you need to pass --user to Setup.lhs
06:20:25 <meric> neat! thanks!
06:21:45 <dschoepe> meric: btw, you can use cabal configure, cabal build, etc. instead of running Setup.hs yourself
06:22:01 <meric> hmm what if the package isn't "on cabal" yet
06:22:21 <meric> the latest version on cabal is not as updated as the git repository i was trying to use
06:22:27 <dschoepe> If it has a .cabal file, you can use those cabal commands in the same directory
06:22:35 <meric> ahhh okay
06:22:39 <meric> thats cool
06:22:44 <dcoutts> meric: btw, cabal is the tool, hackage is the online repository of packages
06:23:01 <erus`> haskell to javascript compiler would be handy
06:23:06 <meric> ohhhh
06:23:06 <synonymous> aristid: will that stack overflow? i would've thought it would run out of heap memory, but not the call stack
06:23:48 <aristid> synonymous: it will not stack overflow.
06:23:59 <aristid> synonymous: as you have seen lambdabot prints results happily
06:24:18 <aristid> try this in ghci. it will go on and on and on
06:24:40 <meric> Once I've loaded a package on ghci, can i print out its version?
06:25:05 <synonymous> yes, i tried. i just though you gave an example of a function that is tailrec but will stack overflow
06:25:13 <erus`> :show modules ?
06:25:59 <aristid> synonymous: no, my function is NOT tail recursive.
06:26:31 <erus`> are any of you at the stage where you can honestly write programs as quickly and as easily as in C, in haskell?
06:27:02 <companion_cube> as quickly as C shouldn't be difficult...
06:27:34 <meric> thanks
06:27:58 <dschoepe> erus`: I think many people here cannot write programs as easily and as quickly in C as they can in Haskell
06:28:55 <pastorn> erus`: i hardly know C at all...
06:30:01 <erus`> i should have learnt functional programming while i was still learning to program
06:30:23 <aristid> erus`: huh? nothing is stopping you from continuing your learning.
06:30:46 <pastorn> erus`: in sweden we have a phrase "the life long learning"
06:32:35 <Lemmih> pastorn: How does that phrase go?
06:33:09 <Lemmih> Et livs lang lring?
06:34:27 <pastorn> "det livslnga lrandet"
06:35:46 * hackagebot Noise 1.0.1 - A Haskell coherent noise generator  http://hackage.haskell.org/package/Noise-1.0.1 (HugoGomes)
06:36:30 <ClaudiusMaximus> aep: just had a thought - maybe you can't foreign export pure functions?  try putting in a return and  :: CInt -> IO CInt
06:37:41 <aep> for some reason, either works
06:37:49 <aep> thats just scary
06:38:12 <Lemmih> Why is it scary?
06:38:22 <aep> it doesnt get exported as actualy C function though. you have to use some stub thingy
06:38:38 <aep> Lemmih: because that means it's completey unclear if this function is pure or not
06:38:58 <mauke> that means you could call pure functions from impure code!!
06:39:22 <aep> oh
06:39:29 <Lemmih> aep: Is that distinction ever made in C?
06:39:42 <aep> no, not at all
06:40:00 <aep> i guess i'm just scared it breaks haskell internals
06:40:12 <aep> the black witchery inside the box :)
06:40:20 <sipa> you can write pure functions in gcc, but the compiler doesn't verify it, only uses it as optimization
06:44:00 <joe6> does anyone know the difference between the llvm-ht package and the llvm package. I got the llvm package from the darcs repo
06:44:25 <joe6> does the llvm repository include the llvm-ht package too?
06:57:18 <HugoDaniel> in haddock
06:58:00 <HugoDaniel> i want to write a code example that has the character {, e.g. > myData { rsyntax = 123 }
06:58:07 <HugoDaniel> but i breaks :/
06:59:44 <Lemmih> > Nothing{} -- simplest example I could think of.
06:59:45 <lambdabot>   Nothing
07:00:35 <Lemmih> Oh, in haddock.
07:00:42 <Lemmih> HugoDaniel: \{ perhaps.
07:02:42 <HugoDaniel> i tried that, doesn't show up either
07:02:57 <azaq23> tbat
07:03:15 <azaq23> that works for non record datatypes if they don't have any fields? weird
07:03:17 <azaq23> > Just {}
07:03:18 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
07:03:27 <azaq23> there's no field to fill though
07:04:25 <Lemmih> > isJust Just{}
07:04:26 <lambdabot>   True
07:05:41 <erus`> > filter (`mod` 2 == 0) [1..10]
07:05:42 <lambdabot>   The operator `GHC.Real.mod' [infixl 7] of a section
07:05:42 <lambdabot>      must have lower pr...
07:05:52 <erus`> whats wrong with that?
07:06:17 <Peaker> erus`, what are you comparing there?
07:06:20 <HugoDaniel> ill look at the haddock from a package that has it
07:06:34 <Peaker> erus`, (`mod` 2) is a section. x `mod` 2 is an application,  what's (`mod` 2 == 0) ?
07:06:56 <Peaker> erus`, you might want:  \x -> x `mod` 2 == 0,    or ((== 0) . (`mod` 2))
07:07:06 <erus`> i thought it would curry
07:07:06 <Peaker> @type even
07:07:07 <lambdabot> forall a. (Integral a) => a -> Bool
07:07:10 <Zao> Peaker: I know, let's compare a function to a Num.
07:07:27 <applicative> joe6, that is a little confusing, it looks like the packages fused?
07:07:28 <mauke> erus`: which part
07:07:46 <mauke> erus`: did you mean (`mod` (2 == 0)) or ((`mod` 2) == 0)?
07:08:03 <erus`> b
07:08:23 <mauke> erus`: (`mod` 2) is a function. 0 is a number.
07:08:29 <mauke> you can't just compare 0 to (`mod` 2)
07:09:31 <erus`> > map (`mod` 2) [1..10]
07:09:32 <lambdabot>   [1,0,1,0,1,0,1,0,1,0]
07:09:32 <hpc> :t mod
07:09:33 <lambdabot> forall a. (Integral a) => a -> a -> a
07:09:48 <HugoDaniel> http://hpaste.org/46388/haddock_bugz_in_cabal_descript  <- here is my stress
07:09:52 <HugoDaniel> can someone help me plz
07:09:57 <joe6> applicative, yes, and that is why I am trying to figure out which one to use or what the advantages of the -ht package are, when compared with the default llvm package.
07:10:12 <kosmikus> > filter even [1..10]
07:10:12 <lambdabot>   [2,4,6,8,10]
07:10:42 <Peaker> mauke, I guess maybe he means something like: (_ `mod` 2 == 0)  which could be an interesting syntax to define anonymous functions
07:11:19 <Peaker> I think that's how Boost lambda looks like
07:11:31 <ion> Especially if extended to multiple parameters: (! `mod` ! == 0) 5 3
07:11:36 <applicative> yes, that's what erus` wanted. Would it be incoherent.
07:11:42 <applicative> ?
07:12:08 <azaq23> scala has something like this, (_ + _) is a valid function
07:12:30 <mauke> my problem is, where does the function stop?
07:12:31 <applicative> azaq23: with two arguments? or are they identified>
07:12:33 <jmcarthur> but that's just the way you use it in prefix notation isn't it?
07:12:56 <jmcarthur> would (_ + _ * _) be a function of three arguments?
07:13:31 <jmcarthur> mauke: good point
07:13:32 <ion> OTOH, the semantics get a bit difficult. (! == (! / 2)) 5 10 would be problematic.
07:13:41 <Peaker> you could have certain braces around it, maybe
07:13:58 <kosmikus> you need some way to delimit the scope of the construct
07:14:05 <applicative> ion, you mean, because we don't know what order to take them in?
07:14:13 <jmcarthur> just go with de bruijn indices or something :P
07:14:20 <hpc> applicative: no, because (! / 2) is a function
07:14:22 <ion> The order would be obvious: left to right.
07:14:39 <applicative> Oh i see, it's embedding the same structure.
07:14:47 <azaq23> applicative: http://paste.pocoo.org/show/383404/ . I suppose they are not identified in any way.
07:15:45 <applicative> azaq23: I see, no, if they were identified it wouldn't typecheck
07:15:58 <kosmikus> (((-) _) 0) 1 would evaluate to what, 1 or -1?
07:16:30 <applicative> yes, the embedding seems hopeless.
07:16:50 <hpc> obviously it's unary minus, so it evaluates to (((-) 0) 1
07:16:53 <hpc> > (-0) 1
07:16:54 <lambdabot>   0
07:16:55 <hpc> :D
07:16:56 * hackagebot Noise 1.0.2 - A Haskell coherent noise generator based on libnoise  http://hackage.haskell.org/package/Noise-1.0.2 (HugoGomes)
07:16:58 * hackagebot Noise 1.0.3 - A Haskell coherent noise generator based on libnoise  http://hackage.haskell.org/package/Noise-1.0.3 (HugoGomes)
07:17:08 <ion> [blah| ! == (! / 2)] 5 10
07:17:23 <Peaker> why the blah?
07:17:28 <applicative> in Scala, they don't have the same unrelenting currying do they? If not maybe it wouldn't be ambiguous
07:18:02 <Chewie[]> where is wxHaskell currently hosted? it is no longer on code.haskell.org.
07:18:56 <HugoDaniel> :(
07:19:03 <HugoDaniel> i can't make it work with the { in haddock
07:20:27 <Lemmih> HugoDaniel: It may be the ticks.
07:20:39 <Kerris> vicious ticks
07:20:46 <ion> |] even
07:23:06 <applicative> Chewie[]: well, hm, theres this http://sourceforge.net/mailarchive/message.php?msg_id=27175195
07:24:35 <HugoDaniel> ah
07:27:00 <azaq23> applicative: Scala doesn't have currying by default. One can define curried functions like this: f(a: A)(b: B)(c: C) = ... and so on. Some things are done in this way, but most aren't. foldLeft, for example, is defined in this way, that's why I did foldleft(0)(_ + _).
07:27:22 <Peaker> azaq23, lack of uniformity :-(
07:30:39 <Chewie[]> applicative: good call, thanks.. makes me sad. =/
07:31:08 <dabblego> applicative: + is a method not a function. You turn it into a function with (_ + _)
07:31:23 <aristid> is (_ + _) a curried function?
07:31:26 <dabblego> no
07:31:37 <dabblego> (_ + _).curry is
07:31:49 <dabblego> a => b => a + b // this too
07:32:04 <hpc> that seems tremendously silly
07:32:26 <aristid> i suppose there's a reason for that
07:32:50 <dabblego> the reasons overwhelmingly complicated, to the extent that discussing their merits makes me sleepy
07:32:59 <dabblego> good night
07:34:56 <aristid> @localtime dabblego
07:34:58 <lambdabot> Local time for dabblego is Fri May  6 00:38:43
07:35:04 <quicksilver>   
07:35:42 <applicative> Chewie[]: I don't think its permanent. On the other hand, I was just trying to push my copy to patch tag and then to darcsden but they both seem to be down.
07:37:46 <Chewie[]> what makes me sad is the state of wxHaskell in general. =P
07:42:19 <Berengal> Is there a term for a directed graph with a start and an end node?
07:42:54 <kakos> Like a single start and a single end?
07:42:58 <quicksilver> sounds like a path?
07:43:03 <Berengal> kakos: Yes
07:43:15 <companion_cube> flow graph ?
07:43:24 <Berengal> And all nodes are reachable from start, and the end is reachable from all nodes
07:46:55 <Chewie[]> Berengal: a "rooted tree" with a single final node?
07:47:13 <Berengal> Chewie[]: It's not neccessarily acyclic
07:48:37 <Berengal> Also, is there a named algorithm for finding such a graph?
07:49:33 <merijn> Berengal: Within a larger graph you mean?
07:49:41 <Berengal> Yes, given a start and an end node
07:50:03 <applicative> Chewie[]: here is the repository as it last stood http://patch-tag.com/r/schoenfinkel/wxHaskell-replica/snapshot/current/content/pretty
07:50:19 <Berengal> It's a trivial algorithm, but all graph algorithms I know have names
07:50:36 <shapr> Berengal: Are you trying to optimize your college course the same way I am? :-)
07:50:48 <applicative> Chewie[]: I had to convert it to the format patch-tag accepts; maybe you should convert it to git an put in on github
07:51:06 * hackagebot Noise 1.0.4 - A Haskell coherent noise generator based on libnoise  http://hackage.haskell.org/package/Noise-1.0.4 (HugoGomes)
07:51:27 <Saizan> a lattice?:)
07:51:30 <applicative> Chewie[]: I think the previous maintainer did much excellent work, but there was a suggestion on the list that he is overburdened...  But I don't know.
07:51:34 <Berengal> shapr: No, I was asked for help on this today, and the fact that I don't know the terms annoys me
07:51:58 <kakos> Huh
07:52:01 <kakos> I can't think of one
07:52:11 <Berengal> Also, it just happens to be the heaviest algorithmic lifting I've had to do at work ever... A shame it only lasted 10 seconds
07:52:19 <Axman6> Berengal: well you only need to check three things: a) there's only one node with no vertices pointing to it, b) there's only one node with no vertices from it, and that all nodes are reachable from the first node (BFS would work well here)
07:52:31 <kakos> I'm like 90% sure there probably is a name for that considering it is a pretty simple case of digraphs.
07:52:53 <Berengal> Axman6: The start and end nodes are given
07:53:14 <Chewie[]> applicative: i'd toss it on github but i am not learned enough to do any good with it. maybe in the future... thanks for the upload.
07:53:18 <Berengal> Axman6: Also, you need to check that all nodes are reachable from the end node in the reversed graph
07:53:24 <Axman6> then just use BFS to make sure all nodes are accessable from the first?
07:53:33 <Chewie[]> i mostly want to learn it from a user perspective at this point.
07:53:48 <Berengal> Given that the end node might not be the only one with no outgoing edges
07:54:05 <Berengal> (Indeed, the end node could have outgoing edges)
07:54:22 <Axman6> well, that can be done with BFS too, if you have a structure that you cvan do reverse lookups (either an adjacency matrix or you cvan create an adjacency list from the original adjacency list)
07:54:27 <applicative> Chewie[]: there's a very pleasing tutorial, http://hackage.haskell.org/package/wxhnotepad
07:54:56 <Chewie[]> Berengal: if i had to make a suggestion, this sounds like it would come up in flight planning.
07:55:30 <Berengal> Chewie[]: I'm afraid it's something much more mundane ...
07:55:44 <applicative> Berengal, a boolean algebra?
07:55:57 <Chewie[]> Berengal: if you can find a thesis or something with a background section, it may drop more terms to help you locate the proper name...
07:56:29 <Berengal> applicative: "Validation" of a workflow
07:58:02 <Berengal> Hmm, if there's no restriction on the edges to and from the start and end nodes, it kinda starts to sound like a connected directed graph
07:58:41 <hpc> based on your description, it seems like it would be enough to just remove all edges pointing into the start and out of the end
07:59:02 <applicative> Berengal: I was wondering whether, with your constraints it was really something more tractable than a graph-in-general
07:59:36 <Berengal> hpc: Not really, a graph [AB, BC] with start node A and end node B would still be [A, B, C]
07:59:45 * ClaudiusMaximus thinks of tred (1) - transitive reduction filter for directed graphs  -- but i'm not sure actually what the problem really is
08:01:39 <Berengal> applicative: It depends on if you're looking at the graph or the algorithm to find it. If you constrain the start and end node to be initial/terminal, the algorithm produces such a graph, but it'll still work given any two arbitrary nodes
08:06:28 * applicative grants he hasn't quite grasped the problem.
08:20:24 * hackagebot http-enumerator 0.6.4.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.4.1 (MichaelSnoyman)
08:20:26 * hackagebot xml-enumerator 0.3.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.3.1 (MichaelSnoyman)
08:22:24 * hackagebot yesod 0.8.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.8.1 (MichaelSnoyman)
08:22:26 * hackagebot yesod-auth 0.5.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.5.0 (MichaelSnoyman)
08:22:28 * hackagebot yesod-core 0.8.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.8.1 (MichaelSnoyman)
08:22:30 * hackagebot hamlet 0.8.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.8.1 (MichaelSnoyman)
08:24:17 <hpc> what does yesod mean by RESTful?
08:25:25 <hpc> oh, nvm; http://en.wikipedia.org/wiki/Representational_State_Transfer
08:26:49 <vicvicvic> is there any guarantee that System.Directory.getDirectoryContents will always give "." and ".." first?
08:27:24 <hpc> > sort ["abc","1234",".","..","foof"]
08:27:24 <lambdabot>   [".","..","1234","abc","foof"]
08:27:43 <hpc> vicvicvic: i think you can guarantee that they will come first in the sorted results
08:27:56 <vicvicvic> fair enough
08:28:01 <rata_> hi
08:28:03 <hpc> vicvicvic: if getDirectoryContents already returns sorted results, then you are set
08:28:24 <rata_> how should I interpret (uncurry (++) .)?
08:28:35 <vicvicvic> it seems to just call POSIX readdir :\
08:28:38 <hpc> :t (uncurry (++) .)
08:28:39 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f) => f (a, a) -> f a
08:29:03 <hpc> :t (uncurry (Prelude.++) Prelude..)
08:29:04 <lambdabot> forall a a1. (a1 -> ([a], [a])) -> a1 -> [a]
08:29:36 <rata_> why a1 instead of b?
08:30:00 <hpc> rata_: you give it a function and a parameter; it applies the parameter to the function, then concatenates the two lists that the function returns
08:30:00 <sully> hpc: that's not necessarily true
08:30:19 <sully> if you have a filename starting with +, for example, it will appear before . when you sort
08:30:54 <hpc> ew, that does work
08:32:36 <vicvicvic> well, what i really care about is /not/ visiting "..", so i guess i can just filter it...
08:34:25 <applicative> ah, sully has anticipated me.
08:34:51 <applicative> bash shows *.text as first.  but getDirectoryContents  shows ".","..","*.txt",".bash_history",".bazaar",".bzr.log"...
08:35:15 <applicative> when I make a text called "*.txt"
08:35:22 <vicvicvic> and uh yeah, i was thinking about laziness and stuff, but i guess since it's an IO action it doesn't matter (i'd have to "pull" the list in anyway)
08:35:56 <vicvicvic> the thing is, the order of readdir/opendir seems to be implementation specific
09:01:08 <Volvic> hi
09:01:25 <ianmathwiz7> Hey
09:02:57 <gwern> so, rewrite rules. they go '{-# RULES' right?
09:03:14 <jmcarthur> yes...
09:03:34 <jmcarthur> the syntax after that is very picky though
09:03:46 <jmcarthur> each rule must not be indented, but the #-} must be
09:03:49 <jmcarthur> kind of annoying
09:04:09 <gwern> well, I'm just interested in grepping my 100k haskell files for rule usage
09:04:18 <jmcarthur> aha
09:04:41 <shapr> howdy!
09:04:46 <jmcarthur> hiyo
09:04:51 <gwern> booya
09:04:53 <ziman> hello!
09:06:02 <aristid> gwern: not only do you monopolise the market for information theoretic anime analysis, you're also dominating the market for statistical haskell source code analysis
09:06:25 <gwern> aristid: yep. and if I ever learn generics, my accuracy will increase exponentially!
09:07:07 <aristid> gwern: do you write the analysis scripts in perl, or in haskell, or something else? :)
09:07:55 <gwern> aristid: right now, my analysis scripts are named 'find' and 'grep'. if niklas ever fixes haskell-src-exts throwing an exception on infix syntax, it'll be renamed 'searcher.hs'
09:08:47 <aristid> gwern: i see.
09:12:50 <shapr> howdy edwardk
09:12:57 <edwardk> heya
09:12:57 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
09:13:51 <edwardk> @tell djahandarie http://hackage.haskell.org/packages/archive/adjunctions/0.5.2.1/doc/html/Control-Monad-Trans-Codensity.html
09:13:51 <lambdabot> Consider it noted.
09:25:47 <roconnor> I was doodling ordinal notations on the train hoping to get a sequence to Gamma_0, but I'm starting to get concerned that I'm stuck below Veblen_omega(0). :(
09:26:01 <roconnor> Gamma_0 seems kinda big.
09:27:57 <crystal-cola> I wish I could play that game
09:28:34 <crystal-cola> dont' really know how the ordinals work
09:30:06 <roconnor> crystal-cola: I'm pretty content with ordinals below epsilion_0, they are nicely represented by heritarily sorted lists.
09:30:19 <roconnor> I want to get as comfortable with ordinals below Gamma_0
09:30:37 <crystal-cola> epsilon_0 to me means peano arithmetic
09:30:58 <roconnor> specifially epsilon_0 is the proof theoretic ordinal for peano arithmetic.
09:31:05 <crystal-cola> that's probbly not a good way tot hink about these things though
09:31:10 <crystal-cola> I dont really know
09:31:57 <roconnor> basically every proof in peano arithmetic can be translated into a cut-free proof tree in omega logic whose height is less than epsilon_0.
09:32:48 <crystal-cola> what's the next step up? not Veblen_omega(0) I guess there's thing before that?
09:33:14 <roconnor> Veblen_1(0) = epsilon_0
09:33:30 <roconnor> and in general Veblen_1(n) = epsilon_n
09:33:46 <roconnor> Veblin_0(n) = omega^n
09:34:02 <roconnor> *Veblen
09:36:06 <roconnor> epsilon_1 = lim of {w^(epslon_0 + 1), w^(epslon_0 + 1), w^w^(epslon_0 + 1) , w^w^w^(epslon_0 + 1)}
09:36:22 <roconnor> er
09:36:32 <roconnor> nix that first w^
09:36:38 <roconnor> (not that it affects the limit :D)
09:37:15 <crystal-cola> is that the general thing for epsilon_(n+1) = {that with 0 replaced with n} ?
09:37:46 <roconnor> yes.
09:37:47 <crystal-cola> so then you can take epsilon_w ?
09:37:52 <roconnor> yes
09:37:53 <crystal-cola> and that's Veblen_omega(0)?
09:37:56 <roconnor> no
09:38:17 <roconnor> epsilon_w = Veblin_1(w)
09:38:51 <roconnor> Veblin_2(0) = epsilon_(epslion_(epslion_ ...)))
09:39:00 <crystal-cola> aha! that's weird
09:39:59 <crystal-cola> actually I can't see what Veblin_3(0) is
09:40:24 <crystal-cola> Veblin_2(0)^Veblin_2(0)^...
09:40:36 <roconnor> Veblin_3(0) = Veblin_2(Veblin_2(Veblin_2( ...)))
09:40:58 <roconnor> ah
09:41:10 <roconnor> now you know what Veblin_omega(0) is :D
09:41:18 <roconnor> still a long way from Gamma_0
09:42:58 <roconnor> Gamma_0 = lim {Veblin_0(0), Veblin_(Veblin_0(0))(0), Veblin_(Veblin_(Veblin_0(0))(0))(0), ...}
09:43:28 <crystal-cola> but is there a problem with it?
09:43:35 <roconnor> Gamm_0 is the proof theoretic ordinal of Martin-Lof type theory.
09:44:21 <roconnor> which presumably means that any proof of an arithmetic statement in ML-type theory can be translated into a cut free proof tree in omega logic of hieght less than Gamma_0
09:44:53 <roconnor> (and this bound is optimal)
09:45:08 <gio123> roconnor: do you know how to prove confluence of lambda calculus (martin-lof techincue)
09:45:26 <roconnor> nope
09:45:33 <gio123> ok
09:45:42 <gwern> there are more uses of RULES that I would have guessed
09:56:02 <Volvic> in which way do I have to write this? filter (>10 && <100) elements
09:56:36 <monochrom> I recommend the simple-minded filter (\x -> x>10 && x<100)
09:56:46 <gwern> @pl \x -> x>10 && x<100
09:56:47 <lambdabot> liftM2 (&&) (> 10) (< 100)
09:57:03 <Volvic> thx
09:57:19 <crystal-cola> filter (\x -> x > 10 && x < 100)
10:02:28 <gwern> a lot more hits in .lhs files than I expected too
10:02:30 <rostayob> How do I "convert" C structs, when writing bindings?
10:05:36 <andras> hello haskellers
10:05:41 <crystal-cola> hi
10:05:42 <Saizan> rostayob: often you don't, you just keep pointers to them
10:05:52 <andras> once again, i have a question that's been bugging me for a while...
10:06:15 <andras> i'm trying to parse a list of numbers contained in a file into a data structure
10:06:22 <Saizan> rostayob: i think one of both of c2hs and hsc2hs can help writing Storable instances if you want, though
10:07:31 <EvanR> is there a simple file-based database library, dont want to use a RDBMS for this project, but i need a persistent database
10:07:46 <zomg> SQLite?
10:07:53 <rostayob> Saizan: so the best thing is to write some C to convert basic haskell types to those structs?
10:08:12 <andras> i use hGetContents to get the file's contents, then read use words to separate it into strings, then listArray to convert this into an array. all is well...
10:08:17 * EvanR checks sqlite
10:08:55 <andras> ...until the string in the file gets too long, which results in the program using up all memory available and gets killed by the kernel
10:09:08 <andras> using Data.Array.Unboxed does exactly the same
10:09:17 <EvanR> andras: you need to use ByteString not String when dealing with large files
10:09:31 <andras> EvanR: what's the difference?
10:09:44 <EvanR> one will take up way less memory when youre crunching it
10:09:52 <EvanR> and be faster
10:10:13 <EvanR> you can always convert import chunks of bytes into String when appropriate
10:10:22 <EvanR> by decoding
10:10:29 <andras> EvanR: but the problem appears to be that Data.Array isn't strict enough, isn't it?
10:10:32 <EvanR> important*
10:10:45 <EvanR> Data.Array?
10:11:00 <EvanR> Array of what?
10:11:12 <andras> EvanR: yes, it appears that the strings is kept around while building the array with listArray
10:11:31 <andras> 2D Array of Doubles
10:11:43 <EvanR> if you are thinking of reading the file into a Array of bytes, ... then you want ByteString
10:12:01 <EvanR> reading the file into a String then operating on it *is* the problem
10:12:20 <EvanR> you want to read it into a ByteString then create your array of doubles from that
10:12:20 <andras> EvanR: I have whitespace-separated values in the file
10:12:42 <andras> EvanR: can I make hGetContents output ByteString instead of String simply with a type signature?
10:13:00 <EvanR> no, you need to import a different module first
10:13:12 <andras> EvanR: ok, but then I can do it?
10:13:16 <EvanR> yes
10:13:35 <EvanR> id use readFile
10:13:43 <EvanR> unless its not a file
10:13:57 <andras> EvanR: so you're saying that the problem isn't Data.Array, so I wouldn't be better off with Data.Vector?
10:14:17 <EvanR> i dont know about that, but the memory problem is coming from String
10:14:26 <Saizan> rostayob: ah well, if your api makes the user build such structs directly then maybe it's best to have a record type in haskell and a Storable instance that converts it into the C struct
10:15:02 <andras> EvanR: but if the processing of the string were more strict, then that would also solve my problem, wouldn't it?
10:15:11 <EvanR> probably not
10:15:14 <Saizan> rostayob: i've not used the FFI much though
10:15:23 <EvanR> processing a giant String is hell on your memory
10:15:41 <EvanR> everything you do creates a copy of it
10:16:03 <andras> EvanR: yes, but you can process it Char-by-Char so that only the current segment will have to stay in memory, right?
10:16:39 <EvanR> if Char by Char means using list of chars at some point, and the list does not include the entire suffix, then a new list needs to be created
10:17:33 <EvanR> in particular, lines and words is likely doing that
10:18:14 <andras> EvanR: sure, but only a copy of the list of Chars you're working on... and since lines and words are lazy, they should discard the list once they move on to the next...
10:18:25 <EvanR> yep
10:18:31 <EvanR> then you run out of memory
10:18:39 <KirinDave> EvanR: A giant string's memory overhead even if you don't DO anything with it is painful enough.
10:18:55 <KirinDave> EvanR: See also Erlang on 64-bit machines being crushed by 4mb string copies.
10:18:58 <EvanR> basically, use ByteString and watch the error go away plz
10:19:07 <EvanR> KirinDave: interesting
10:19:21 <EvanR> erlang strings are like haskell [Char] ?
10:19:23 <KirinDave> EvanR: How big is a native pointer on a 64-bit machine? :)
10:19:24 <KirinDave> Yes.
10:19:29 <EvanR> nice
10:19:34 <andras> EvanR: ok, will do, that's very helpful
10:19:43 <andras> EvanR: thanks a lot
10:19:45 <KirinDave> I imagine Haskell has the same problem?
10:19:50 <EvanR> yes
10:19:55 <KirinDave> for every character in the string you incur a massive, massive overhead.
10:20:35 <EvanR> if you process a large String you get a kick in the nuts from the runtime which sees your memory going out of control
10:20:43 <KirinDave> And if the head is retained
10:20:51 <KirinDave> Your runtime shrugs and goes to drink Chai.
10:20:55 <KirinDave> "Not my problem."
10:21:27 <EvanR> it gives you the helpful message to show you how to increase your memory limit
10:21:32 <EvanR> stack size
10:21:40 <EvanR> but its not the right solution
10:22:00 <KirinDave> Ha.
10:22:21 <EvanR> sucks that of all the high tech shit in haskell, you still get these 'memory leaks' :(
10:22:37 <EvanR> the turing tape is still the main physical barrier ;)
10:22:39 <KirinDave> EvanR: But that's why chunked bytestring and friends exist?
10:22:49 <EvanR> ByteString is amazing
10:22:58 <KirinDave> It's a problem for every representation of strings that isn't at heart a flat array.
10:23:13 <pmetzger> they're not memory leaks, they are failures of the real machine to live up to the turing machine model. we should just blame reality for not living up to our ideals.
10:23:45 <pmetzger> KirinDave: ropes are kind of nice, and they're not arrays...
10:24:01 <KirinDave> pmetzger: Link please? Not familiar with
10:24:13 <KirinDave> I suspect they are just ways to reduce the # of objects in the representation :)
10:24:16 <EvanR> semantically String and ByteString are easy to understand and provide everything you need to deal with performance
10:25:09 <pmetzger> KirinDave: they were invented by Bohm. http://onlinelibrary.wiley.com/doi/10.1002/spe.4380251203/abstract
10:25:25 <pmetzger> er, Boehm.
10:25:41 <pmetzger> originally part of Cedar i think.
10:25:50 <EvanR> zomg: hmmm. anything like sqlite, but not SQL?
10:25:51 <pmetzger> or one of the other PARC OSes.
10:26:16 <zomg> EvanR: no idea
10:26:26 <EvanR> *grumble*
10:26:46 <pmetzger> ah, this abstract says Cedar, yes.
10:27:07 <pmetzger> Ropes are neat, but pretty much only practical on a language with automatic memory management. Then again, so much is only practical then.
10:27:33 <pmetzger> they allow very nice time constant operations like inserts and appends, they're great for editors etc.
10:28:21 <pmetzger> it is rare that arrays are really the optimal data structure for things that involve inserts and appends and such the way strings do. it is just that there are even worse things than arrays.
10:30:04 <gwern> 11k .lhs files. that's really not a popular file format
10:30:20 <pmetzger> KirinDave: PDF! http://www.google.com/url?sa=t&source=web&cd=4&ved=0CC0QFjAD&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Bjsessionid%3D181EEF66EB411F4277C009A1D492CF75%3Fdoi%3D10.1.1.14.9450%26rep%3Drep1%26type%3Dpdf&rct=j&q=ropes%20strings%20boehm&ei=O9_CTZLUHpKRgQeEwIWIAg&usg=AFQjCNGKQzuEnLSr7TsBIyBTDz2SkVBvPg&cad=rja
10:30:25 <NihilistDandy> I like LHS :)
10:30:27 <pmetzger> er, let me try that again...
10:31:06 <pmetzger> eh, I'm having trouble getting google to give me the real URL. it should work
10:31:54 <gwern> so, a total of 744 uses of RULES
10:32:05 <gwern> out of 111k files.
10:32:12 <gwern> not the most popular extension ever...
10:33:25 <KirinDave> Twas just googling it. :)
10:33:39 <KirinDave> Effing paywalls
10:34:26 <KirinDave> I wish someone had told me about The Monad Reader before recently
10:34:52 <pmetzger> This also gives a pretty good explanation. http://en.wikipedia.org/wiki/Rope_(computer_science)
10:35:20 <pmetzger> KirinDave: I have the pdf from citeseer if you want it and can't convince it to give it to you.
10:35:30 <KirinDave> Your previous link worked fine?
10:35:43 <pmetzger> for me, yah, but the cut and paste may very well have damaged it.
10:35:53 <KirinDave> No it was fine
10:36:17 <gwern> ropes are old hat, finger trees are the new hotness
10:36:19 <pmetzger> I also have the article itself on paper, Hans Boehm sent it to me years ago when I couldn't get a copy from my university library.
10:36:22 <KirinDave> It is already in papers, and papers is already synch-ing and ready for my train time
10:36:27 <djahandarie> edwardk, but that is gone now, isn't it?
10:36:27 <lambdabot> djahandarie: You have 1 new message. '/msg lambdabot @messages' to read it.
10:36:29 <pmetzger> gwern: what is a finger tree?
10:36:34 <pmetzger> gwern: haven't heard of them.
10:36:39 <gwern> pmetzger: you'll have to find out!
10:36:49 <pmetzger> gwern: sigh. okay, I'll google.
10:37:35 <pmetzger> the wikipedia explanation is less than detailed. :|
10:37:47 <KirinDave> pmetzger: It's one of those Okasaki gigs from purely functional data structures. They're cool.
10:37:59 <pmetzger> gwern: who's paper is canonical on the finger tree topic?
10:38:04 <pmetzger> gwern: I can search for that.
10:38:12 <gwern> pmetzger: how dare you insult my wikipedia article! :)
10:38:22 * gwern will have you splined in log n pieces for that
10:38:25 <pmetzger> gwern: add more detail damn it. I write better ones. :)
10:38:31 <edwardk> djahandarie: ?
10:38:34 <pmetzger> gwern: though most of mine are on chemistry and such.
10:38:49 <edwardk> djahandarie: oh its in another package
10:39:01 <edwardk> http://hackage.haskell.org/package/kan-extensions
10:39:01 <gwern> pmetzger: pfft, chemistry. such a boring stamp-collecting field the bots can write the articles for you
10:39:04 <djahandarie> Ah
10:39:08 <djahandarie> Ah that makes sense
10:39:26 <pmetzger> gwern: I'm interested in molecular machines, and unfortunately, the behavior of atoms comes into play in that area.
10:39:40 <pmetzger> gwern: so quantum chemistry is vital even if it is not in itself that fascinating.
10:39:53 <pmetzger> gwern: but I'd agree, lots of it is stamp collecting. :(
10:40:17 <gwern> mad statistics: http://www.haskell.org/pipermail/haskell-cafe/2011-May/091660.html
10:40:19 <edwardk> gwern: the real question is how degree of continuity you will you ensure between his pieces?
10:40:30 <gwern> edwardk: huh?
10:40:38 <edwardk> splined into log n pieces
10:41:15 <gwern> edwardk: it's an execution for lse gwernest, so there need be no continuity at all
10:41:41 <pmetzger> I'm not continuous right now anyway.
10:41:58 * gwern wonders if there are any interesting papers to be written looking statistics on 111k haskell files
10:42:03 <gwern> *looking at
10:42:06 <edwardk> be rational! (if non-uniform) that way you can project him into different spaces and not invalidate your wonderful spline
10:42:20 <jmcarthur> gwern: i would be curious about the usage of each ghc extension, for one
10:42:45 <KSkrzet> I'm profiling my program with -hd and things like "textmining-zajecia0708-0.1:Wikilinki.sat_s59y" show up. what are they? how can I pin that down to single expression in my program?
10:42:53 <gwern> jmcarthur: that wouldn't be hard at all, actually. I already know how to use haskll-src-exts to get the list of extensions each file uses
10:43:41 <jmcarthur> gwern: also correlations between uses of extensions
10:44:05 <aristid> a Rational + an Integer for an exponent of some power (say, 2). this seems to make a pretty universal number format. is there something i missed there? any numbers that cannot be represented this way, but can be represented with other common types? (other than +/-Infinity)
10:44:09 <jmcarthur> gwern: e.g. are fundeps and type families used together as rarely as i suspect?
10:44:28 <edwardk> pmetzger: fingertrees were introduced by tarjan and kaplan, the modern fingertrees are based on hinze and patterson's work
10:44:37 <jmcarthur> e.g. generalized newtype deriving + standalone deriving
10:44:52 <gwern> edwardk: I remember reading the tarjan paper and having no idea what was going on, compared to hinze & co's papers
10:44:54 <pmetzger> edwardk: Would you suggest starting with tarjan and kaplan or with the later authors?
10:45:05 <edwardk> i would skip to hinze and patterson
10:45:11 <edwardk> i have slides on the topic as well
10:45:11 <pmetzger> edwardk: They're not discussed in my copy of CSLR which I find odd but not that odd.
10:45:12 <edwardk> one sec
10:45:33 <pmetzger> BTW, my copy of Knuth v4a arrived yesterday. My first new Knuth volume in nearly 30 years.
10:45:34 <edwardk> http://comonad.com/reader/wp-content/uploads/2010/04/Finger-Trees.pdf
10:45:54 <pmetzger> and what is the haskell-cafe mailing list?
10:45:56 <edwardk> however there is a ! annotation in my slides that doesn't belong
10:46:31 <pmetzger> I think that if Knuth dies, a group of CS people should make it their business to finish his books for him. :)
10:46:37 <edwardk> pmetzger: CSLR = http://www.google.com/products/catalog?q=introduction+to+algorithms&um=1&ie=UTF-8&cid=9685492292254720343&sa=X&ei=LePCTb2NOsXXgQeW6dHoAQ&ved=0CDkQ8wIwAw# ?
10:46:41 <pmetzger> they can pretend to be him, in the manner of Nicolas Bourbaki
10:46:50 <gwern> they will fight even over his corpse for the right to fasicles
10:47:07 <pmetzger> edwardk: yes, that book. why?
10:47:20 <edwardk> pmetzger: yeah it omits fingertrees
10:47:36 <edwardk> and a lot of later functional data structures
10:47:41 <pmetzger> of course, if CSLR really included everything it would be even more impossible to lift.
10:47:50 <edwardk> e.g. it doesn't include brodal/okasaki heaps
10:48:01 <pmetzger> I already had to get two copies (one for home, one for my office at the university) because I can't carry it back and forth.
10:48:07 <edwardk> or many of the functional data structures that okasaki defines
10:48:13 <edwardk> hah
10:48:16 <Volvic> why is this wrong? filter (not isPrime) numbers
10:48:45 <mauke> Volvic: because isPrime is not a Bool
10:49:00 <gwern> Volvic: not . isPrime == (\x -> not (isPrime x))
10:49:00 <jmcarthur> Volvic: filter (not . isPrime) numbers    -- seeing this, do you understand why yours is incorrect?
10:49:05 <pmetzger> I really wish all such books were available electronically, but I find scanning my own copies is too much of a pain even with my insanely fast sheet feed scanner.
10:49:45 <Volvic> yes I understand
10:49:46 <Volvic> thank you
10:49:49 <edwardk> pmetzger: have you picked up http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504 ?
10:50:17 <gwern> pmetzger: I would point out that CSLR and Okasaki are both available electronically...
10:50:19 <pmetzger> yes. I haven't had time to read it after almost a year though. "the lyfe so shorte, the craft so longe to learne"
10:50:48 <pmetzger> gwern: CSLR is available electronically? it wasn't a year ago! that's a good development.
10:50:50 <gwern> looks like 3 editions of CSLR, 1, 2, and 3rd
10:50:55 <pmetzger> where?
10:51:05 <pmetzger> last I checked even the pirate sites only had second ed.
10:51:21 <pmetzger> then again, I bought 3rd ed. for a class about a month after it was published.
10:51:22 <gwern> sorry, linking it is a crime in my country - contributory infringement, I believe the doctrine is
10:51:37 <pmetzger> oh, so it isn't a legal electronic version.
10:51:40 <jmcarthur> what is CSLR?
10:51:44 <gwern> don't be silly
10:51:46 <jmcarthur> oh nevermind
10:51:59 <gwern> of course it's not a legal copy. when has copyright ever *helped* people like you and me?
10:52:05 <pmetzger> jmcarthur: it is pretty much the canonical graduate algorithms intro text right now.
10:52:13 <jmcarthur> yeah
10:52:18 <pmetzger> gwern: never, really. that said, when I scan a book I need, I generally do it legally.
10:52:19 <jmcarthur> except for where i went to school
10:52:23 <jmcarthur> (it was around then too)
10:52:31 <gwern> pmetzger: legal... for now
10:52:38 <pmetzger> gwern: that is, I buy a used copy, cut the spine, and scan it myself. that is totally legal in the US and will remain so for a while.
10:52:39 <jmcarthur> gwern: :(
10:53:26 <pmetzger> I really want a program that will take my scans and re-typeset the book from them, but thats another thing for my copious spare time that will never come.
10:53:52 <pmetzger> (For out of copyright 19th century materials the original setting is often very beautiful and it is a shame to look at only crappy 1 bit deep images)
10:54:04 <NihilistDandy> What's CSLR stand for?
10:54:35 <pmetzger> by re-typeset, I mean that it would figure out how to generate typeset copy that closely approximates everything about the scan, including font and kerning.
10:54:35 <edwardk> NihilistDandy: initials of the authors last names
10:54:50 <gwern> the R is the same as in RSA, iirc
10:54:59 <pmetzger> Cormen, L. is someone else, Rivest, Stein.
10:55:05 <c_wraith> Liersen, I think
10:55:11 <pmetzger> yes. I should have googled.
10:55:21 <c_wraith> And yes, the same R as in RSA
10:55:28 <pmetzger> really we all need google attached directly to our brains via fiber links.
10:55:41 <gwern> surprisingly, wikipedia doesn't seem to cover it
10:55:41 <pmetzger> then when they censor stuff we can truly forget it! :)
10:55:49 <gwern> guess it's not as famous as SICP or TAoCP yet
10:56:15 <edwardk> it is a pretty good overall resource for imperative algorithms
10:56:23 <pmetzger> I'm surprised. That and one other book are pretty much 100% of the market for intro grad classes right now.
10:56:44 <pmetzger> supplanted the old Aho & Ullman books.
10:56:57 <NihilistDandy> Found the book. Not sure on the edition, yet
10:57:20 <pmetzger> 3rd is greatly expanded, it isn't just a "we wanted to make more money" edition.
10:57:34 <pmetzger> though they kind of screwed up the description of max flow/min cut problems.
10:57:52 <pmetzger> the formalism was a bit better in the previous edition.
10:58:10 <NihilistDandy> I'll just grab both, then :D
10:58:37 <pmetzger> nah, the max flow stuff in 3rd is good enough.
10:58:54 <pmetzger> it just isn't quite as nice.
10:59:10 <pmetzger> and that's clearly a matter of taste since they prefer the new presentation.
10:59:19 <pmetzger> so you might disagree entirely.
10:59:35 <NihilistDandy> True :D
11:01:15 <Volvic> is there a function which returns the ascii value?
11:01:24 <edwardk> > fromEnum 'e'
11:01:25 <lambdabot>   101
11:01:32 <Zao> > ord ''
11:01:33 <lambdabot>   223
11:01:34 <Volvic> ok
11:01:35 <Volvic> thx
11:01:38 <edwardk> > toEnum 100 :: Char
11:01:39 <lambdabot>   'd'
11:01:48 <Zao> Note that it's unicode codepoint.
11:01:50 <kmc> anyone know of a Haskell library for computing Voronoi regions or similar?
11:02:09 <Zao> Out of which the low 128 coincide with "low ascii" and the low 256 coincide with latin-1.
11:02:12 <kmc> i'm failing to find one on Hackage
11:02:25 <kmc> > ord ''
11:02:26 <lambdabot>   9773
11:02:32 <NihilistDandy> Nice
11:02:38 <edwardk> kmc: i have some code that does constrained delaunay triangulation somewhere, you could dualize it -- if I can find it -- I suppose
11:02:50 <kmc> could be interesting
11:02:56 <Zao> Implementing a robust CDT is a right pain in the patootie.
11:03:03 <kmc> i found this binary "qvoronoi" which will do it
11:03:09 <edwardk> Zao: sadly =/
11:03:17 <kmc> its command line syntax and input / output formats are crusty as hell
11:03:19 <kmc> but basically workable
11:03:24 <Zao> Especially as all the papers on it are either assuming perfect math or just omit robustness completely.
11:03:37 <edwardk> Zao: i used to use constrained delaunay tetrahedralization in an old portal-based 3d engine
11:03:39 <kmc> the documentation suggests that it is technically possible to use this code as a C library but advises against it in no uncertain terms
11:03:58 <edwardk> computing the steiner points needed when you go to 3d drove me insane
11:04:00 <kmc> so i'll probably just wrap the command
11:04:17 <Zao> GTS can probably be FFI'd, but it's LGPL and has a horrible interface.
11:04:45 <edwardk> i really want to 3d print the solid that first convinced me of the need for steiner points =)
11:04:56 <edwardk> hrmm that wouldn't be that expensive these days
11:05:04 <kmc> you should do it!
11:05:13 <NihilistDandy> edwardk: What was the solid?
11:05:16 <kmc> ponoko will do it
11:05:20 <kmc> or this might be a good excuse to buy a MakerBot
11:05:30 <edwardk> NihilistDandy: it is a bit tricky to describe in irc form, but here goes. =)
11:05:33 <kmc> in other news i seem to have purchased a laser cutter
11:05:43 <kmc> edwardk, ascii art plz
11:05:48 <jmcarthur> MakerBots seem a bit... unreliable
11:05:48 <NihilistDandy> Hehe
11:06:12 <jmcarthur> at least all the ones at my local hackerspace seem to be
11:06:13 <kmc> jmcarthur, no kidding
11:06:22 <gio123> lambda calculus experts are here?
11:06:44 <jmcarthur> gio123: you ask that same question every time you are here
11:06:51 <kmc> jmcarthur, my friend has his working pretty well, but he spent probably 100 hours and $500+ improving and tweaking it beyond the original design
11:06:51 <edwardk> NihilistDandy: take a cube, now, cut it into an I-beam by removing a rectangular solid just under a third of the width of the cube.
11:06:59 <NihilistDandy> Okay
11:07:30 <gio123> jmcarthur: i just checked something
11:07:31 <edwardk> NihilistDandy: you can repeat this on each face of the cube, yielding a cube with these ruts in it such that each face looks like: ][ <-- ascii art!
11:07:45 <edwardk> so far so good?
11:07:49 <NihilistDandy> Yup yup
11:08:43 <kmc> edwardk, have you seen OpenSCAD?
11:08:47 <edwardk> now look at each corner. there is a tetrahedron formed by the corner of the cube, and the corners where the gullies emerge from the cube. cut those off
11:09:02 <kmc> functional declarative DSL for CSG
11:09:11 <kmc> maybe you could model this thing and render it ;)
11:09:33 <NihilistDandy> I'm with you
11:09:34 <edwardk> now there is no constrained delaunay tetrahedralization of that solid that doesn't require the construction of a steiner point. looking at the structure of one of the corners should convince you. and the solid was formed by simple csg operations
11:09:48 <edwardk> there is no way to tetrahedralize the inside of that corner
11:09:48 <NihilistDandy> :)
11:10:03 <edwardk> and it is a pretty neat looking solid =)
11:10:16 <NihilistDandy> Indeed
11:10:19 <edwardk> kmc: not off hand
11:11:01 <kmc> yeah, i bet you could model this in OpenSCAD easily
11:11:06 <kmc> since you just described it with simple CSG
11:11:58 <edwardk> yeah. it was a solid i came up with mostly to shut up the rather rabid csg portals-for-everything crowd that was everywhere around 96-98 ;)
11:12:10 <kmc> i love counterexamples :)
11:12:23 <kmc> there's that book "counterexamples in analysis"
11:12:24 <edwardk> there are simpler ones, I am sure
11:12:27 <kmc> and "counterexamples in topology"
11:12:52 <NihilistDandy> kmc: I'm gonna have to get those books :D
11:12:57 <Zao> I didn't manage to grok it :(
11:13:01 <edwardk> kmc: it was a good cheap book =)
11:13:29 <NihilistDandy> Looks like I already have the topology one :D
11:13:39 <kmc> i think if i wrote a book about my friends it could be called "counterexamples in psychology"
11:14:23 <NihilistDandy> Mine would be "Counterexamples in Neurochemistry"
11:14:47 <edwardk> "Counterexamples in Productivity" here ;)
11:14:56 <pmetzger> what, you're actually productive?
11:15:43 <NihilistDandy> Productivity is for ants :P
11:16:25 <enthymeme> Counterexamples in Haskell might be an interesting teaching tool.  A la the Ruby Koans, I mean, where you have to fix broken code or proove why code that looks right doesn't work.
11:16:25 <NihilistDandy> On a related note, I wish employers agreed with the "specialization is for insects" philosophy
11:17:35 <kmc> GTS looks like a .... large library
11:17:41 <kmc> not something I'll FFI bind in an afternoon
11:18:01 <NihilistDandy> @hoogle GTS
11:18:01 <lambdabot> No results found
11:18:05 <Zao> kmc: I failed at doing FFI against it from C++, heh.
11:18:09 <kmc> haha
11:18:12 <pmetzger> NihilistDandy: Many employers do agree with it. Just not a majority.
11:18:27 <pmetzger> NihilistDandy: it depends a lot on the company and what you were hired for...
11:18:28 <Zao> As it's written by MS-haters, it only barely builds with mingw.
11:18:36 <NihilistDandy> pmetzger: Fair point. I guess I just with I knew them :D
11:18:57 <Zao> As I was in VC++ at the time, lots of hilarity ensued.
11:18:58 <pmetzger> NihilistDandy: generally one finds a good job by being deliberate about it rather than leaving it to chance.
11:19:39 <cizra2> Hi. data StackVal = Int | Bool deriving (Show, Eq)
11:19:39 <cizra2> data Command = Push StackVal
11:19:47 <cizra2> -- what's the correct syntax to create new Commands now?
11:20:02 <NihilistDandy> pmetzger: Well, hopefully a math degree will make me look more deliberate :D
11:20:02 <kmc> your first line is bogus
11:20:06 <cizra2> Push 42 doesn't work -- no instance of (Num StackVal)
11:20:21 <kmc> you didn't define data constructors for Stack
11:20:32 <kmc> well technically you did -- they're named "Int" and "Bool" and have nothing to do with the types of the same name
11:20:44 <kmc> you probably meant: data StackVal = SI Int | SB Bool
11:20:46 <pmetzger> NihilistDandy: looking deliberate isn't the point. you have to figure out what kind of company you want to work for ("good" is not a kind), figure out how to break in to that industry, build contacts...
11:20:50 <kmc> in which case you can say Push (SI 42)
11:20:56 <cizra2> kmc: Ahhh. Hmm.
11:21:14 <pmetzger> NihilistDandy: most people just send out their resume like it was confetti and take what comes, so they get what comes.
11:21:20 <pmetzger> NihilistDandy: which is usually pure chance.
11:21:32 <NihilistDandy> pmetzger: I'm actually working on that. I'm just at home right now rather than school, and it's a rather sadly dead area unless you're a Java or PHP programmer
11:21:45 <NihilistDandy> pmetzger: I'm very selective with where I send my resume, don't worry
11:22:06 <jmcarthur> i'm not selective about where i send my resume. i'm selective about which job i accept ;)
11:22:10 <kmc> i've never applied to more than about two jobs "at once"
11:22:15 <pmetzger> NihilistDandy: I doubt that it is really that dead out there. I know people who kill for good programmers (but on the other hand, many of those jobs are really unpleasant in their own way.)
11:22:38 <pmetzger> NihilistDandy: (like wall street stuff. they make you use your brain hard but they also demand everything out of you and the work is not inherently fascinating.)
11:22:57 <kmc> knowing Haskell helps a lot in getting a job.  unfortunately it may be a job writing Java where the hiring manager heard that Haskell people are smart
11:23:13 <cizra2> kmc: Thank you!
11:23:22 <kmc> cizra2, :)
11:23:29 <NihilistDandy> pmetzger: No previous job experience in the field, no degree for a year or two. I'm working on some libraries so I'll at least have some kind of portfolio
11:23:31 <pmetzger> Generally, good jobs come through contacts or headhunters rather than random applications...
11:23:40 * shachaf read" may be a job" as "is my job", and was surprised.
11:23:46 <pmetzger> NihilistDandy: what is the nature of your degree?
11:23:52 <NihilistDandy> And I'm getting to be friends with a headhunter, so :D
11:23:59 <NihilistDandy> pmetzger: Going for pure math/CS
11:24:07 <kmc> beware that many headhunters / recruiters are absolute scum
11:24:09 <kmc> not all
11:24:10 <NihilistDandy> Planning on a Master's (and hopefully a PhD
11:24:10 <pmetzger> NihilistDandy: no, I mean, area of specialization, type of degree.
11:24:12 <NihilistDandy> )
11:24:15 <pmetzger> kmc: ditto on that.
11:24:36 <pmetzger> PhD in what kind of math? Analysis? Topology? etc.
11:24:44 <NihilistDandy> Oh, BS, probably specializing in theory of computation or number theory
11:25:00 <NihilistDandy> Though category theory is enticing
11:25:56 <NihilistDandy> It's hard to pick a specialty because I enjoy so many fields :D
11:26:05 <Younder> NihilistDandy, From my point of view Category theory has more going for it. There is more left to do there..
11:26:11 <pmetzger> If you don't mind hard work if it requires lots of brainpower, there are more and more finance places using functional programming. However, I'll repeat, it is often not the most interesting end goal to which your hard thinking is applied.
11:26:23 <pmetzger> But you have a few years to worry about this anyway.
11:26:40 <kmc> there's also the part where most finance work boils down to zero-sum games
11:26:40 <NihilistDandy> Younder: Agreed. That's part of what I like about it
11:26:54 <kmc> you're not helping the world very much, even if you're not hurting it either
11:27:03 <kmc> you're helping even less than the typical for-profit company that makes a useful product and sells it
11:27:11 <NihilistDandy> Maybe the NSA will be interested :D
11:27:12 <pmetzger> kmc: actually, finance is usually positive sum.
11:27:24 <pmetzger> kmc: generally, more efficient pricing helps the market clear.
11:27:44 <kmc> yes, there's a slight benefit -- and of course "finance" is a huge industry with many people doing totally different things
11:27:45 <pmetzger> kmc: and most things for which brainy people are used like high frequency trading are all about eliminating pricing inefficiencies.
11:28:03 <kmc> my time in high-frequency trading convinced me that this particular sub-niche is almost zero-sum, though
11:28:17 <pmetzger> kmc: arguably, looked at only internally, a derivative is a zero sum game. however, you have to look at the effect on the whole market.
11:28:27 <kmc> the amount of effort wasted in competition is much higher than the benefit to other areas of the market
11:28:50 <pmetzger> kmc: perhaps. But without the competition there would be no motivation to eliminate the price discrepencies.
11:29:18 <jmcarthur> surely even a monopoly would work pretty hard to make all the money it can
11:30:01 <pmetzger> jmcarthur: monopolies generally are attempting to sit on the place on the supply/demand curve where the area under the curve is maximized.
11:30:10 <jmcarthur> ah true
11:30:18 <jmcarthur> i guess it would be an effort vs. payoff issue
11:30:58 <jmcarthur> but doesn't the presence of all this competition demonstrate that the payoff:effort ratio is still pretty huge?
11:31:02 <pmetzger> jmcarthur: monopolies often work quite hard, if only to maintain their monopoly so they can retain price control. there is an incentive for new entrants into the market...
11:31:05 <Blkt> good evening everyone
11:31:31 <NihilistDandy> hiya
11:31:33 <pmetzger> jmcarthur: in high frequency trading, it apparently is, but then again, I know very smart people who do high frequency trading and seem to do well at it.
11:31:49 <pmetzger> jmcarthur: I've never been at such a firm, but I did do stat arb for a while.
11:32:08 <jmcarthur> i have a standing job offer in HFT that i haven't accepted yet. i am on the verge of it, but i still have lingering doubts about enjoying it
11:33:02 <pmetzger> jmcarthur: that is always a concern. in the short term, working with smart people and making money are fun.
11:33:09 * kmc worked in HFT and is happy to answer questions
11:33:19 <kmc> pmetzger, heh, "statistical arbitrage" is such a wonderful oxymoron
11:33:25 <pmetzger> jmcarthur: in the long term, one can get to the point where one stops enjoying it because the underlying effects are so uninteresting.
11:33:32 <pmetzger> kmc: yes, it is. :)
11:33:35 <jmcarthur> i believe i know kmc's opinion on how enjoyable it is ;)
11:33:38 * sully interviewed with two HFT firms; I'm not really sure why
11:33:38 <pmetzger> kmc: I worked for the people that invented it. :)
11:33:46 <kmc> heh, cool
11:33:48 <sully> oh, one of them gave ipads to people who got on sites
11:34:07 <pmetzger> kmc: "Black Box" group at Morgan Stanley. The local poison was Sharp APL btw.
11:34:19 <pmetzger> kmc: long time ago.
11:34:45 <jmcarthur> kmc: what industry did you move to?
11:34:49 <jmcarthur> *from* hft
11:34:49 <pmetzger> kmc: David Shaw left and started a new company, and was much more successful...
11:35:37 <jmcarthur> should this be in -blah?
11:36:19 <pmetzger> Weirdly, now Shaw is interested in molecules and so am I...
11:36:37 <pmetzger> "The Circle of Life!"
11:38:32 <kmc> going to -blah
11:38:54 <kmc> yeah, Shaw folds his zero-sum finance gains into biomedical research
11:38:54 <pmetzger> -blah?
11:38:58 <kmc> #haskell-blah
11:39:12 <pmetzger> didn't know it existed. random non-haskell talk by haskellers?
11:39:28 <kmc> yeah
12:14:24 <kmc> any suggestions for quickly parsing a text file full of (text representations of) Doubles?
12:14:43 <kmc> istr someone writing a super fast float parser?
12:16:13 <pastorn> kmc: attoparsec?
12:16:25 <aristid> pastorn: does attoparsec have a ready-made parser for them?
12:16:50 <kmc> i could use attoparsec but i only need to split on ' ' and '\n'
12:16:57 <kmc> but then i have to parse those Doubles
12:18:03 <fryguybob> @hackage bytestring-lexing ?
12:18:03 <lambdabot> http://hackage.haskell.org/package/bytestring-lexing ?
12:18:16 <Phyx-> what's attoparsec?
12:18:35 <shapr> Phyx-: parser combinators for binary parsing.
12:18:53 <shapr> Phyx-: Ever wanted to use parsec to parse file formats?
12:19:29 <Phyx-> ah
12:19:35 <Phyx-> shapr: i've never used parsec at all
12:19:51 <shapr> Phyx-: parsec was the first killer app for Haskell, imo
12:19:57 <Phyx-> i've been raised and bred on uu-parsers and uulib
12:20:05 <aristid> Phyx-: srsly?
12:20:11 <shapr> ooh, you're a doaitse guy?
12:20:21 <aristid> Phyx-: does that mean you know how to use them? despite the lack of documentation?
12:20:38 <aristid> it's not like parsec was exactly well-documented, but the situation in uu-parsinglib is even more dire
12:20:38 <Phyx-> aristid: hahaha, well we got courses on em
12:20:41 <Phyx-> shapr: yup
12:20:48 <aristid> Phyx-: you in utrecht?
12:20:56 <Phyx-> aristid: yup
12:21:25 <aristid> Phyx-: tell doaitse to document the parser. with haddock. :P
12:22:15 <Phyx-> lol, well there is an example parser, :P
12:23:01 <Phyx-> but he did mention once he was going to do documentation
12:23:08 <Phyx-> course that was somewhere last year
12:23:13 <monochrom> haha
12:26:44 <Phyx-> aristid: uulib does have an accompanying pdf that *does* explain almost everything you'd need to know
12:26:46 <aristid> Phyx-: until then, if you want the uu parsing, better enroll in utrecht? ;)
12:26:57 <aristid> Phyx-: i thought uulib is obsoleted by uu-parsinglib
12:27:00 <Zao> Never managed to understand uu-parsinglib.
12:27:09 <Zao> Way underdocumented and ununderstandable :D
12:27:19 <Phyx-> aristid: i could never keep the names straight... i meant uu-parsinglib
12:27:22 <shapr> Same here, and I spent a bunch of hours trying to make it work.
12:27:48 <Phyx-> I think you're all just missing that "aha" moment
12:27:55 <aristid> is uu-parsinglib flexible enough to work with iteratees?
12:28:11 <HugoDaniel> hi
12:28:58 <Phyx-> aristid: i'm never used iteratees, but i'm guessing it is.
12:29:03 <Phyx-> btw he did write a tutorial http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
12:33:26 <Phyx-> oh and hi HugoDaniel
12:34:46 <Phyx-> Zao, shapr it's really not that hard. Last year first years got to use it
12:34:55 <Phyx-> to parse simple spreadsheet formats
12:35:03 <Phyx-> thought they got a simplified interface
12:35:15 <shapr> Phyx-: You gotta try parsec... it's a doaitse from a much earlier time.
12:35:17 <Zao> Of course, I don't quite grok parsec either :)
12:35:21 <shapr> Daan is a cool guy :-)
12:35:54 <Phyx-> lol, I mailed daan once, a paper of his had a mistake in it, and something not defined, he never answered
12:35:58 <Phyx-> lol
12:38:47 <Phyx-> Zao, shapr http://pastebin.com/7dS0sSuj last parser i wrote using uu-parsinglib, to parse a simple test interface i made
12:41:09 <Zao> Once I thought I understood the subtleties of <*, <$> and friends, I get incomprehensible type clashes.
12:41:39 <Phyx-> you have to watch out for the priorities of the operators
12:41:42 <helino> hi everyone, I got a question about the following mini interpreter, http://hpaste.org/46394/mini_interpreter. It currently works with Integers and Bools, but how could I change it so that it works with any user defined type, ie "MyInteger" and "MyBool"?
12:41:43 * roconnor didn't know that Galois was a co-op
12:41:50 <roconnor> er
12:41:57 <roconnor> I guess co-op isn't the right word
12:42:48 * roconnor wonders if formalizing Galois theory in type theory counts as relevent experience for working for galois
12:44:02 <mauke> what is `micro` 1?
12:44:17 <roconnor> @hoogle micro
12:44:18 <lambdabot> Data.Fixed type Micro = Fixed E6
12:44:37 <Phyx-> mauke: adds an extra cost to that particular parser, makes it more expensive to do
12:45:04 <mauke> huh
12:45:22 <mauke> pSym has a funky type
12:45:25 <Phyx-> helino: I don't quite get what you want todo. you want to be able to the same set of command (CODE) for arbitrary StackElements?
12:46:05 <helino> Phyx-: yes, exactly!
12:46:13 <mauke> Phyx-: digit2Int already exists; also read <$> pList1 pDigit
12:46:23 <roconnor> > tails []
12:46:24 <lambdabot>   [[]]
12:47:35 <Will|> curiosity has got the best of me and I've decided to have a look at Haskell, aside learnyouahaskell and the RWH book; any there any other important/good resources?
12:47:37 <Phyx-> mauke: yeah, I was in a hurry to write those, So I didn't pay much attention
12:47:43 <Will|> oh, and hhgth
12:49:29 <helino> Phyx-: one would have to supply the functions fromInteger and fromBool for the "user defined" types as well, since CODE uses Integers and Bools
12:49:32 <shapr> Will|: The #haskell channel is also an important resource :-)
12:50:02 * roconnor is quickly becoming a big fan of jermey gibbons
12:50:04 <shapr> Will|: I'd also suggest you check out the HaskellWiki on http://www.haskell.org/, that has links to many awesome resources.
12:50:09 <kosmikus> Phyx-: I agree: uu-parsinglib is quite underappreciated, sadly :)
12:50:19 <Phyx-> mauke: as an addendum, micro ads a cost to a sequence to disambuguate and switch from the greedy parsing method
12:50:19 <Will|> well I am here now :)
12:50:23 <shapr> Will|: Do you have any specific questions?
12:50:25 <Will|> cool, thanks shapr
12:50:27 <Phyx-> kosmikus: indeed, I quite like it :)
12:50:30 <roconnor> shapr!
12:50:33 <shapr> roconnor!
12:50:34 <Will|> not really, I literally know *nothing* about haskell
12:50:37 <shapr> roconnor: Wassup?
12:50:38 <Will|> well, very little
12:50:43 <Phyx-> helino: you could use a typeclass for that
12:50:53 <roconnor> shapr: I've been studying the first few ordinals
12:50:53 <mauke> Phyx-: how is this better than a monadic parser?
12:50:58 <kosmikus> oh, shapr is here :)
12:50:59 <Will|> it's been on my radar for a while, coming from an Erlang background
12:51:02 <shapr> Will|: If you want an instant taste of Haskell, check out http://tryhaskell.org/
12:51:07 <shapr> hoi kosmikus! gutentag!
12:52:51 <kosmikus> Phyx-: I'm actually secretly working on my own copy of uu-parsinglib that is documented so that I understand it.
12:52:57 <shapr> oooh
12:53:02 <shapr> kosmikus: Can you break the secrecy?
12:53:09 <shapr> Will|: If you have any specific questions, feel free to ask here!
12:53:10 <kosmikus> no :)
12:53:13 <shapr> oh, ok
12:53:20 * shapr sends flying saucers to steal kosmikus' source code
12:53:22 <kosmikus> I don't want to offend Doaitse.
12:53:25 <shapr> oh right
12:53:30 <Will|> cheers shapr :)
12:53:37 <kosmikus> I'll show it to him though when it's done.
12:53:47 <kosmikus> and if he's ok with it, I'll publish it then.
12:53:54 <helino> Phyx-: I've tried that, but the thing that I'm not able to solve is the CMP code part. It requires two "Integer" like types, and should return a "Bool" like type
12:54:01 <KirinDave> Will|: Tryhaskell and learnyouahaskell online, these are your go-to resources for starting out.
12:54:21 <c_wraith> he seemed very happy when I reported a bug and said "I worked through the code to understand how to implement this, and came up with this:".  But he never did integrate my changes.
12:54:21 <KirinDave> will|: Avoid real world haskell until you've at least gone over the functors chapter in LYAH
12:54:46 <kosmikus> Phyx-: who are you btw? do I know you?
12:54:50 <shapr> c_wraith: Who? Daan or Doaitse?
12:54:58 <c_wraith> Doaitse
12:55:05 <Phyx-> kosmikus: yes you do, Tamar :P
12:55:18 <kosmikus> ah great.
12:55:25 <shapr> Having hung out with both of them, I have come to the conclusion that Daan drinks more beer than Doaitse.
12:55:29 <Will|> cheers guys, will go do some reading and come bug you later/tomorrow with questions :D
12:55:34 <merijn> Will|: I second the recommendations of Learn You a Haskell (although the first few chapters might be a bit to easy if you're coming from another functional language like Erlang)
12:55:38 <c_wraith> shapr: that's an amazingly profound conclusion!
12:55:40 <shapr> Will|: Yes, please do! cause we're fun!
12:55:43 <kosmikus> Phyx-: you defended your master thesis recently, right? congratulations!
12:55:45 <Phyx-> helino: CMP just compares the the values doens't it? just require that the values have an Ord instance and call ==
12:56:00 <kosmikus> shapr: :)
12:56:08 <Phyx-> kosmikus: yes i did :) thanks :) thanks for the help with lhs2tex, I'm a convert now, heheh
12:56:11 * shapr hugs kosmikus 
12:56:32 <kosmikus> Phyx-: finally fully brainwashed? :)
12:58:00 <Phyx-> kosmikus: yes, I tried resisting but It didn't work, I even use spaces now instead of tabs :P
12:58:13 <helino> Yes, but the typeclass Eq has == that is of the type a -> a -> Bool. I would like a -> a -> "UserDefinedKindOfBool" :)
12:58:30 <Athas> sjanssen: ping
12:58:59 <kosmikus> Phyx-: hah :)
12:59:09 <Phyx-> mauke: whoops, forgot you what you asked before, well, there is a monad interface aswel to uu-parsinglib, if you would like to know more about it and the difficulties you could look at section 4.7 http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
12:59:26 <merijn> I'm sorely disappointed in you all that facebook doesn't auto-complete "lambda calculus" in the religion field >.>
12:59:43 <kmc> fuck facebook
13:00:17 <Phyx-> helino: you can create your own type classes, class MyEq a of { (===) :: a -> a -> MyBool }
13:00:20 <Phyx-> for instance
13:00:33 <pastorn> merijn: no, it's "lambda calcultism"
13:00:44 <pastorn> merijn: practiced in the "Church of Alonzo"
13:00:57 <andras> why is there a difference in memory usage between this:
13:01:02 <andras> putStr $ intercalate "\n" $ map show $ take n $ (randoms g :: [Double])
13:01:03 <merijn> pastorn: "In Church we trust" :)
13:01:05 <andras> and this:
13:01:10 <andras> sequence_ $ map (putStrLn . show) $ take n $ (randoms g :: [Double])
13:01:24 <andras> with n being a large number and g being the return of getStdGen?
13:02:05 <andras> for n=10^7, the first gets killed by the OS, the second completes just fine
13:02:24 <helino> Phyx-: but then MyBool would have to be a conrete type, right?
13:02:39 <merijn> andras: I think the first walks the list twice (first for map, second for intercalate) forcing it to keep the list in memory
13:02:52 <Will|> oh momma, whitespace sensitive
13:02:52 <Will|> :D
13:03:15 <merijn> andras: The second only traverses the list once with map and throws the result away immediately so it can be garbage collected. (Warning: Wild ass-guess)
13:03:27 <pastorn> Will|: you're free to use {, } and ; if you like to
13:03:28 <andras> merijn: why so? i thought that map doesn't "walk" the list, just computes the value that's needed
13:03:37 <pastorn> Will|: do { like; this; }
13:04:01 <merijn> andras: It takes one list and creates a new one, how do you do this without traversing the list?
13:04:08 <Will|> no no, I also do Python
13:04:21 <merijn> andras: In the second case the result is no longer used, so the compiler toss out the result list
13:04:22 <Will|> I love the forced-neatness of it
13:04:32 <Will|> goes well with my OCD :)
13:04:35 <Phyx-> helino: yes, but that's not a problem right? if it is you can just make a multiparameter type class, class MyEq a b where { (===) :: a -> a -> b }
13:04:49 <merijn> Will|: If you like python, we also have list comprehensions (actually python stole them from Haskell) :)
13:04:57 <Will|> cool
13:05:01 <andras> merijn: map creates a lazy list, so it doesn't need to traverse it (which would fail for an infinite list anyway)
13:05:04 <helino> Phyx-: can you have multiparameter type classes, I get an error when I do that?
13:05:17 <kmc> it's a GHC extension
13:05:33 <kmc> (well, it's also an extension in some other implementations)
13:05:36 <pastorn> Will|: but you'll notice that peopel tend to avoid typeclasses if they can
13:05:42 <merijn> andras: Maybe one triggers fusion and the other doesn't? I'm not smart enough for this question
13:05:49 <pastorn> Will|: instead use map/filter directly
13:05:58 <merijn> pastorn: Huh, what?
13:05:59 <kmc> Will|, unlike Python though, Haskell's syntax always has an alternate whitespace-independent form
13:06:06 <kmc> which is a really useful property
13:06:18 <merijn> > [1,3..]
13:06:19 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
13:06:49 <pastorn> merijn: wait, you actually use list comprehensions?
13:07:10 <merijn> pastorn: Oh, you meant list comprehensions
13:07:15 <merijn> You typed typeclasses...
13:07:33 <Phyx-> kosmikus: btw, I hear you're somewhere in munchen now? How is it there?
13:07:38 <merijn> I was like "No one uses typeclasses?! Since when, they're the best thing since sliced bread..."
13:07:52 <pastorn> merijn: damn... i shoshouldn't be reading while writing :/
13:07:54 * hackagebot iterIO 0.1 - Iteratee-based IO with pipe operators  http://hackage.haskell.org/package/iterIO-0.1 (DavidMazieres)
13:08:04 <kosmikus> Phyx-: In Regensburg, not Munich (but it isn't all that far for .de standards)
13:08:08 <merijn> > [x | x <- [1..10], even] -- but map/filter are better, like this:
13:08:09 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:08:09 <lambdabot>         against inferred type ...
13:08:14 <merijn> doh
13:08:18 <merijn> > [x | x <- [1..10], even x] -- but map/filter are better, like this:
13:08:18 <lambdabot>   [2,4,6,8,10]
13:08:27 <kosmikus> Phyx-: it's nice here :) not many Haskellers though. that's sad.
13:08:27 <merijn> > filter even [1..10]
13:08:28 <lambdabot>   [2,4,6,8,10]
13:08:30 <Phyx-> does MultiParameter typeclaseses still require a language extension in  Haskell2010?
13:08:50 <kosmikus> Phyx-: what are you going to do now that you're finished?
13:09:03 <merijn> pastorn: I (and I assume others) use trivial comprehensions, a lot, though (i.e. [1..10])
13:09:24 <andras> merijn: so map makes a lazy list less lazy? if that's so, that would, sort of, defeat its purpose
13:09:32 <Phyx-> kosmikus: Work most likely, but I'm going on vacation for ~2 months in july after graduations, and then I'll see what I
13:09:37 <pastorn> well, fromThenTo is a bit more unreadable :(
13:09:39 <Phyx-> I'll do
13:09:43 <kmc> Phyx-, yes
13:09:57 <merijn> andras: No it doesn't. But the interaction in your code might. I'm not experienced enough to say for sure, though
13:10:05 <Phyx-> kmc: thought it was part of the "standard"
13:10:24 <Phyx-> helino: when you do make it, ghc will suggest the language extension to enable
13:10:55 <Will|> any useful vim plugins for haskell dev?
13:11:22 <kmc> MPTC is not in the Haskell 2010 standard
13:11:38 <kmc> Haskell 2010 is a conservative incremental change to Haskell 98
13:11:42 <kmc> MPTC are too controversial
13:11:43 <andras> merijn: even this code seems to work fine: sequence_ $ map putStrLn $ map show $ take n $ (randoms g :: [Double])
13:11:55 <andras> merijn: so i don't think map is to blame
13:11:59 <andras> merijn: maybe putStrLn?
13:12:18 <Phyx-> kosmikus: as you know I'm rather Microsoft oriented, so I'll probably get a job somewhere that's more focuses on windows development. but who know, you never know :)
13:12:52 <Phyx-> kmc: lol, how are they controversial? are Typesynonym instances in there atleast?
13:13:36 <kosmikus> Phyx-: good luck :)
13:13:43 <pastorn> Will|: there's a vim plugin, but as long as you use Visual Block a lot editing haskell is a treat :)
13:14:19 <pastorn> Will|: i only use the haddock syntax highlighting plugin (and i'm actually developing haskell professionally!)
13:14:59 <Phyx-> kosmikus: thanks :)
13:17:22 <pastorn> Will|: your only real problem is probably refactoring, but you want to use "hare" for that
13:17:51 <pastorn> (it's a program you can get from hackage)
13:18:32 <Will|> cheers pastorn :)
13:18:32 <Will|> hackage is that 'cabal' thing, yes?
13:18:48 <dcoutts> Will|: to a first approximation, yes.
13:18:58 <Will|> :)
13:19:33 <dcoutts> Will|: to a second approximation, cabal is the packaging format and tools, hackage is the online archive of cabal packages
13:20:33 <pastorn> Will|: I use this: http://snapframework.com/docs/style-guide
13:20:47 <dcoutts> you use the 'cabal' command line tool to install Cabal packages from Hackage
13:20:59 <pastorn> but i use a 71 character width (i want the right-most column empty in my 72-char vim window)
13:21:42 <pastorn> Will|: not that cabal is an installation system/dependency resolver, not a package manager
13:21:44 <pastorn> *note
13:22:05 * dcoutts hopes to make it more of a package manager in future however
13:24:23 <Will|> thanks
13:24:46 <Will|> sorry for my crappy responses by the way guys, I'm on a train with the worst wifi in existance
13:26:29 <NihilistDandy> Don't talk about your wife that way~
13:27:35 <dcoutts> boom boom
13:27:37 <pastorn> Will|: i'm on a bus :D
13:28:01 <monochrom> linux has poor wife drivers XD
13:28:04 * hackagebot atto-lisp 0.1 - Efficient parsing and serialisation of S-Expressions.  http://hackage.haskell.org/package/atto-lisp-0.1 (ThomasSchilling)
13:28:36 <Will|> lol
13:28:44 <Will|> pastorn: wifi on a bus?!
13:28:48 <Will|> or just good 3G?
13:29:23 <monochrom> "a wife in embrace is better than two wifi's on the bus"
13:29:31 <dcoutts> NihilistDandy: see, I'd always thought wifi was pronounced whiffy
13:29:56 <NihilistDandy> haha
13:29:57 <gwern> jmcarthur: still interested in fundep and type family stats?
13:31:09 <monochrom> obTopic: dcoutts: I have updated my http://www.vex.net/~trebla/haskell/sicp.xhtml on how to achieve "ghc-6.12.3 wants array==0.3.0.1 but ghc-6.12.3 also wants array==0.3.0.2". the section is "pigeon drop con"
13:32:56 <gwern> jmcarthur: so, to be clear, you only care about FunctionalDependencies || TypeFamilies
13:33:00 <dcoutts> monochrom: ah ok, the Cabal FAQ deals with that too, if you want to contribute something to that, feel free
13:33:14 <dcoutts> monochrom: the cabal website lives in the Cabal darcs repo
13:33:31 <monochrom> that is really inverted
13:33:35 <dcoutts> erm, no, sorry
13:33:46 <dcoutts> the cabal website itself is a darcs repo
13:33:50 * dcoutts got it backwards
13:34:12 <monochrom> if google's website lived in google's version control repo, no one would use it
13:34:21 <dcoutts> ie darcs get http://haskell.org/cabal/
13:34:29 <dcoutts> monochrom: :-)
13:34:49 <monochrom> "the darcs repo doesn't carry the website. the darcs repo is the website" - dcoutts mcluhan :)
13:35:49 <dcoutts> The medium is the message
13:35:58 <balor> Is it possible to only load function "bar" from "foo.hs" in ghci?  i.e. I need to play with bar, but don't want to pull in everything else
13:36:30 <dcoutts> balor: no, ghci loads whole modules
13:36:40 <Phyx-> boy.. I seem to have a special skill for breaking ghc
13:36:43 <dcoutts> so if any part does not compile, the whole module does not compile
13:36:55 <gwern> dcoutts: didn't ghci get extended so you could do qualified imports, enumerated imports etc?
13:37:19 <dcoutts> balor: but, if a module does compile, you can still refer to things from it without importing the whole module, just use a fully qualified name
13:37:40 <dcoutts> gwern: yes, so it depends on just what balor means
13:37:40 <ryant5000> has anyone else had problems with installing recent ghcs?
13:37:42 <pastorn> Will|: good wifi (sort of)
13:38:11 <ryant5000> several times lately, i've installed a fresh ghc, then run cabal install cabal-install, and then a bunch of stuff is broken (Cabal, ghc, etc.)
13:38:14 <monochrom> dcoutts: http://haskell.org/cabal/FAQ.html covers it for the pre-ABI-hash era, "The solution we've been discussing for the next major ghc release is to track package ABIs..." But I'm talking about post-ABI-hash era now, the problem still persists, cabal-install still unsafely upgrade and re-build
13:38:16 <ryant5000> am i doing something wrong?
13:38:45 <monochrom> well, "unsafely" IMO anyway
13:38:54 <Phyx-> ryant5000: what platform?
13:39:13 <Phyx-> ryant5000: have you made sure the correct ghc-pkg is on your path?
13:39:14 <ryant5000> Phyx-: just now, 64-bit linux; but also 32-bit windwos
13:39:29 <monochrom> although the solution stays the problem. yank more packages.
13:39:32 <monochrom> err
13:39:38 <monochrom> although the solution stays the same. yank more packages.
13:39:42 <gwern> 'let exts = [ x | x@FunctionalDependencies <- exts, x@TypeFamilies <- exts]' <-- this isn't right, is it?
13:39:46 <Phyx-> I've never had that ryant5000, what I do get is packages seemling rotting over time
13:39:56 <gwern> er, let exts' =
13:40:00 <ryant5000> Phyx-: yeah
13:40:07 <dcoutts> monochrom: so previously the problem really existed, now with abi hashes the problem does not "really" exist, but cabal-install still thinks it exists because its solver does not grock multiple instances of the same package
13:40:48 <djh__> would anyone recommend using the 64 bit version of GHC/haskell platform on OSX?
13:40:53 <djh__> the website says it's experimental
13:41:27 <bos> Works For Me (TM)
13:41:32 <monochrom> well, multiple instances is or is not a real problem depending on circumstances. it is not always safe, that's for sure
13:42:16 <djh__> so just stick with the 32 bit to be safe not sorry?
13:42:37 <gwern> ok, so what's the list comp version of 'filter (\x -> x == FunctionalDependencies || x == TypeFamilies) exts'?
13:43:05 <merijn> djh__: Depends, will people die if you need to troubleshoot for an hour or install 32bit GHC when it breaks? If not you should be perfectly safe with 64bit
13:43:15 <balor> Is it possible to write "pickRandom :: [a] -> a"?  The closest I can come is "pickRandom :: [a] -> IO a" as methods in System.Random return an "IO b"
13:43:16 <Phyx-> seemling? wtf am I on..
13:43:34 <rata_> I was trying to find info about partial evaluation in haskell, but everything is somewhat old... does any haskell compiler do partial evaluation?
13:43:47 <ryant5000> balor: you won't be able to write pickRandom :: [a] -> a, unless you don't mind it returning the same thing every time
13:43:50 <gwern> rata_: there was Supero, but not really
13:44:01 <merijn> balor: Not really, because it breaks referential transparency
13:44:13 * hackagebot unordered-containers 0.1.3.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.3.0 (JohanTibell)
13:44:21 <monochrom> I feel that people will eventually move towards cabal-dev sandboxing and just cease running into it in the future
13:44:23 <aristid> balor: it is possible to do pickRandom :: [a] -> RVar a
13:44:33 <aristid> where RVar indicates a random variable
13:44:37 <c_wraith> balor: you could also write pickRandom :: RandomGen g => [a] -> g -> (a, g)
13:44:47 <c_wraith> balor: and using a RandomGen explicitly is the most idiomatic
13:45:23 <balor> c_wraith, I think that's what I want, but it's currently above my monad-foo.  I'll read more.
13:45:31 <c_wraith> balor: fortunately, it involves zero monads :)
13:47:01 <ryant5000> monochrom: cabal-dev-style stuff is definitely the way to go; unfortunately, cabal-dev itself is a bit tricky to use
13:49:14 <gwern> jmcarthur: ok, I've got something working
13:51:23 <gwern> jmcarthur: kicked off a run on the full corpus. it'll finish in another 15 or 20 minutes. the output looks like 'Cachou/RWH/chap15/MonadHandleIO.hs:FunctionalDependencies' so once you have the output, you can use grep to ask how many files use fundeps, how many families, how many both
13:51:47 <prljavi_hari> How to start applications (games) from haskell.org ? Do I have to download dependancies manually or is there some utility ?
13:52:06 <gwern> jmcarthur: source: http://hpaste.org/46395/language_statistics
13:52:40 <merijn> prljavi_hari: You mean like the libraries at http://hackage.haskell.org/packages/hackage.html ?
13:55:02 <prljavi_hari> whatever, just to see some haskell software in action
13:55:18 <NihilistDandy> Anyone done any work with the scrobbling API?
13:55:54 <NihilistDandy> prljavi_hari: Just use cabal
13:56:11 <fryguybob> prljavi_hari: haskell in action: http://joyridelabs.de/game/ ?
13:56:17 <prljavi_hari> ok
13:58:35 <dmwit> Argh. Is there any reason "getBounds :: MArray a e m => a i e -> m (i, i)" rather than "getBounds :: MArray a e m => a i e -> (i, i)"?
13:58:38 <dmwit> i.e. why isn't it pure?
14:00:08 <ryant5000> dmwit: perhaps in case someone wanted a dynamically resizble array? i've run into annoyance from that one before, too
14:00:41 <jmcarthur> gwern: awesome
14:00:46 <prljavi_hari> I downloaded that Nikki before. I click on Nikki.exe and program crashes
14:01:00 <dmwit> ryant5000: Yeah. Seems like premature abstraction.
14:01:20 <dmwit> A design flaw almost in dangerous in Haskell as premature optimization.
14:01:27 <gwern> jmcarthur: I could've written it to maintain a running total of deps, familie, and dep+family, but I was all eh good enough
14:01:29 <ryant5000> dmwit: perhaps; but it's a ratchet effect
14:01:30 <ion> Premature abstraction can be cured.
14:01:50 <jmcarthur> gwern: i think i would have just included all the extensions in the output
14:01:51 <ryant5000> dmwit: the interface could someday be changed to include a pure version, given what it is now
14:02:01 <ryant5000> dmwit: that would only break implementations of the interface
14:02:33 <ryant5000> dmwit: whereas, if it were pure today, it couldn't ever be made monadic
14:02:36 <jmcarthur> gwern: i'm not any more curious about that specific case as i am about all combinations
14:02:42 <gwern> jmcarthur: easy enough but now I have to start the run over
14:02:49 <jmcarthur> heh, sorry :)
14:02:55 <dmwit> I know, I know.
14:03:02 <dmwit> I just want to be grumpy for a bit. =P
14:03:10 <ryant5000> haha :)
14:03:23 <ryant5000> you could wrap it :)
14:03:37 <dmwit> Yep, that's what I'm doing now.
14:10:59 <ryant5000> ok, so i think i tracked down the problem: cabal install cabal-install seems to overwrite process-1.0.1.5 with one that has a different hash
14:11:16 <ryant5000> despite the fact that process-1.0.1.5 is already installed
14:12:11 <ryant5000> ah, ok, seems to be this bug http://hackage.haskell.org/trac/hackage/ticket/831
14:13:31 <djahandarie> Hm, has anyone worked with making attoparsec keep track of line numbers similar to Parsec?
14:13:53 <djahandarie> There doesn't seem to be any 'easy' way to do it that wouldn't leak into my existing parsing
14:23:33 <pmetzger> attoparsec is the lexer version of parsec right? I can't rememeber.
14:23:46 <dmwit> djahandarie: Yeah, I think it's not that easy. Gotta do something like use a StateT and modify the state manually when you notice a line break.
14:23:58 <dmwit> djahandarie: I think attoparsec is really made for binary data, not text data.
14:25:47 <pmetzger> hrm. googling for attoparsec produces uninformative info.
14:26:16 <pmetzger> attoparsec is a smaller parsec?
14:26:27 <djahandarie> Yes, smaller, fewer features, but fast as hell.
14:26:48 <pmetzger> A fast parser combinator library, aimed particularly at dealing efficiently with network protocols and complicated text/binary file formats.
14:26:53 <pmetzger> found it.
14:26:53 <jmcarthur> fast as hell so long as you use a limited subset of combinators
14:26:57 <epsilonhalbe> hey is there a way to install lambdabot on ghc 6.12  or ghc7 - i'm trying it for a while now (on a debian)
14:27:12 <NihilistDandy> epsilonhalbe: Yeah
14:27:30 <pmetzger> I've been playing with hand rolled parsers so far in my haskell wanderings. they're really easy to write in a functional language anyway with minimal effort.
14:27:33 <epsilonhalbe> i always get stuck on something with plugin.common.pl
14:27:44 <dmwit> ?hackage attoparsec -- pmetzger, this is the easy way to find it
14:27:44 <lambdabot> http://hackage.haskell.org/package/attoparsec -- pmetzger, this is the easy way to find it
14:27:46 <c1de0x> does anyone know if there is some library which implements darcs like patch-theory for arbitrary data versioning?
14:27:54 <pmetzger> (in fact, most of what I've been doing to learn haskell so far is hand hacking parsing code...)
14:27:58 <gwern> jmcarthur: the run has finished
14:28:24 <dmwit> c1de0x: I don't think there is. There wasn't last time I looked.
14:28:49 <c1de0x> dmwit why not? isn't that a useful thing to have?
14:28:52 <c1de0x> :D
14:29:06 <gwern> jmcarthur: preliminary results: 3597 matching files; 2685 users of TypeFamilies, 1030 users of FunctionalDependencies, 118 users of TypeFamilies+FunctionalDependencies
14:29:19 <dmwit> c1de0x: Well, at least two people want it. =P
14:29:27 <pmetzger> hrm. code by bos, hosted on bitbucket. I wonder why google didn't find that more easily.
14:29:32 <jmcarthur> woah, more than twice as many users of TF as FD
14:29:36 <jmcarthur> i'm surprised
14:29:45 <pmetzger> I wonder if reading this will teach me new things or confuse me. :)
14:29:56 <c1de0x> dmwit yeah. i'm too much of a noob to try implementing it though :(
14:30:07 <gwern> jmcarthur: may be due to GHC and its duplicates; 947 lines match the string 'ghc'
14:30:28 <shapr> gwern: stats for hackage?
14:30:30 <gwern> 721 lines match 'ghc' and 'TypeFamilies'
14:30:33 <pmetzger> wow, this is not very large at all. most of it is comments...
14:30:59 <gwern> shapr: well, I have a fair bit of hackage, but not all of it. never finished my script to parse hackage and download all source repos
14:31:17 <gwern> shapr: what I'm search is patchtag+github+c.h.o+misc
14:31:21 <shapr> ah
14:31:34 <gwern> jmcarthur: you want the full file?
14:32:53 <pmetzger> ooh, and it uses continuations...
14:33:01 <KSkrzet> does using Data.Vector (from vector package) is universally more memory efficient than using lists [] ?
14:33:12 <jmcarthur> gwern: sure. concat ["Jake", ".", "McArthur", "@", "gmail", ".", "com"]
14:33:24 <dmwit> KSkrzet: There's probably some break-even point around like... 2 or 3 elements.
14:33:28 <gwern> jmcarthur: what is this gibberish speak in english
14:33:33 <c_wraith> KSkrzet: except in the cases where the list doesn't all have to be in memory at once
14:33:52 <dmwit> KSkrzet: It will be hard to find a value of any type that takes less memory than [].
14:34:10 <epsilonhalbe> here is the error code the shell provides me with when i try to cabal install lambdabot http://hpaste.org/46397/lambdabot_install_failure
14:34:21 <dmwit> ...oh, c_wraith's answer is much better.
14:34:22 <KSkrzet> dmwit: phantom types?
14:34:26 <jmcarthur> gwern: btw:    for PACKAGE in `cabal list | grep '^\* ' | awk '{print $2}'`; do; cabal unpack $PACKAGE; done
14:34:35 <dmwit> KSkrzet: hm?
14:34:45 <gwern> jmcarthur: yeah, but they're not the source repos
14:34:51 <jmcarthur> oh the repos
14:34:52 <KSkrzet> dmwit: well, they don't have values at all
14:35:09 <gwern> hm, do you think -cafe would be interested?
14:35:10 <jmcarthur> gwern: why the repos? why not just the package sources?
14:35:14 <c_wraith> KSkrzet: the list in "mapM print [1..10000000]" takes a lot less memory than Vector would in that same use
14:35:18 <gwern> jmcarthur: archival purposes
14:35:34 <jmcarthur> gwern: how large is the file?
14:35:39 <gwern> about 500K
14:35:43 <gwern> gzipped it down to 50k
14:35:59 <KSkrzet> Currently I have `Data.HashMap.Strict.HashMap ByteString (Vector ByteString)`
14:36:03 <jmcarthur> 50k is probably alright for -cafe
14:36:04 <gwern> epsilonhalbe: as the lambdabot maintainer, I can honestly say I have no idea what that error is. it looks like ghc is fundamentally borked
14:36:11 <KSkrzet> And I have memory issues
14:36:50 <jmcarthur> i bet -cafe would find it interesting, gwern
14:38:14 <KSkrzet> now, that's interesting...
14:38:17 <KSkrzet> 11300 MB total memory in use (4438 MB lost due to fragmentation)
14:38:21 <epsilonhalbe> so should i try to reinstall all haskell related things or - give up and surrender ??
14:39:28 <roconnor> @free concat
14:39:29 <lambdabot> $map f . concat = concat . $map ($map f)
14:39:33 <EvanR> can a handle be read and written from two threads simultaneously?
14:39:39 <Saizan> epsilonhalbe: there's been a few people getting those errors, maybe there's a related bug in ghc's trac, or you could ask the ghc-users mailing list
14:40:03 <Lemmih> EvanR: Yes, but it may act counter intuitively.
14:40:48 <EvanR> hmm
14:40:53 <gwern> @hoogle when
14:40:54 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
14:41:12 <epsilonhalbe> i will try to ask there. which version of ghc should i try to use 6.12 or 7
14:42:55 <monochrom> try 7 first
14:43:14 <KSkrzet> epsilonhalbe: unless you have a specific reason not to (like library not working etc) I would go with 7
14:43:47 <monochrom> EvanR: if the Handle is a network connection, and you just have 1 thread read, 1 thread write, I don't think there is any problem
14:43:47 <epsilonhalbe> so i will uninstall the 6.12 on debian and hopefully get happy with ghc7
14:44:02 <EvanR> ok
14:44:11 <monochrom> if the Handle is a file, of course it is more funny
14:44:46 <monochrom> but you should say earlier what is hiding behind the Handle
14:45:03 <EvanR> network
14:45:06 <monochrom> it is not like your privacy would be violated
14:45:13 <EvanR> in fact it is
14:45:21 <EvanR> this is offensive
14:45:21 <monochrom> well then too bad
14:45:51 <roconnor> oh tails ought to return a non-empty list type!
14:45:58 <roconnor> gibbons is brillant!
14:46:09 <gwern> :t tails
14:46:10 <lambdabot> forall a. [a] -> [[a]]
14:46:15 <jmcarthur> > tails []
14:46:16 <lambdabot>   [[]]
14:46:19 <EvanR> non empty lists are amazing
14:46:25 <gwern> I guess you would need a non-empty list to begin with
14:46:31 <roconnor> gwern: no
14:46:34 <gwern> *list type
14:46:53 <roconnor> @check not . null . tails
14:46:54 <lambdabot>   "OK, passed 500 tests."
14:46:56 <gwern> or does [[]] not count as non-empty because we can distinguish it from []?
14:46:58 <jmcarthur> tails :: [a] -> (a, [a])
14:47:07 <EvanR> [[]] is non empty
14:47:08 <jmcarthur> tails [] = ([], [])
14:47:36 <roconnor> jmcarthur: yes, but the proper data structure for non-empty lists is data NElist a = NENil a | NECons a (NElist a)
14:48:06 <jmcarthur> well, that's an ADT version of it, but i wouldn't necessarily say it's any more "proper" than (a,[a])
14:48:11 <jmcarthur> just cleaner
14:48:25 <roconnor> the types are isomorphic
14:48:40 <roconnor> but the induction principle seems better with the NElist
14:48:48 <EvanR> sometimes the discussion here sounds like a mad hatters tea party
14:48:57 <pastorn> I need some help
14:48:57 <roconnor> I wonder if there is some objective criterion for which I can say that NElist is better by.
14:49:06 <pastorn> I want to create a chess clock using "reactive"
14:49:15 <pastorn> i'm thinking sometihng like
14:49:27 <pastorn> chessClock :: Time -> Time -> Event () -> Behavior (Time, Time, Time)
14:49:34 <pastorn> chessClock totalTime addition playerSwitchEv = ...
14:49:49 <pastorn> am i on the right track here?
14:49:58 <Saizan> roconnor: sadly they both suck because you've to handle the presence of the element twice
14:50:18 <roconnor> I've used NElist once with moderate success
14:50:33 <pastorn> the return would be (total_passed, time_left_p1, time_left_p2)
14:50:42 <monochrom> NElist enjoys meaningful names, if you accept that as an objective criterion
14:50:57 <roconnor> meaningful names?
14:51:31 <monochrom> yeah, there is a reason someone chose the names NElist, NENil, NECons
14:52:10 <roconnor> monochrom: I model them after the names for the constructors in List.
14:52:10 <aavogt> because qualified names don't seem to work
14:54:11 <gwern> jmcarthur: email sent
14:54:33 <jmcarthur> thanks!
14:56:11 <gwern> http://www.haskell.org/pipermail/haskell-cafe/2011-May/091663.html
14:56:23 <gwern> oh good -cafe does preserve attachments at least on the web interface
14:58:27 <jmcarthur> gwern: i don't see any without either fundeps or type families. are you sure you removed that filter line?
14:58:46 <gwern> I didn't remove the filter line. why would I do that?
14:58:54 <gwern> you wanted fundeps vs type families vs both
14:59:14 <jmcarthur> no, i was curious about *all* extensions
14:59:23 <jmcarthur> all combinations of all extensions, that is
14:59:35 <jmcarthur> i was thinking i would see which ones tended to coincide and stuff
15:00:10 <gwern> that'd be an awful big file. you want me to generate it?
15:01:54 <jmcarthur> well i'm not really going to make demanding requests, but i was thinking a nice format would be a correlation matrix or something. all the data points would be cool too though, e.g. to see if some combination extensions is a good predictor of some other extensions or something
15:02:07 <jmcarthur> *combination of
15:02:28 <gwern> jmcarthur: matrixes are way beyond me. if I give you the output can you parse it and manipulate it on your own?
15:02:43 <jmcarthur> anyway, i was really just suggesting some things i think would be neat, not trying to make you do a ton of work
15:02:54 <Entroacceptor> how do I debug something like user error (Pattern match failure in do expression at libraries/base/System/Event/Thread.hs:83:3-10)
15:03:07 <jmcarthur> how large do you predict the output would be?
15:03:12 <gwern> the script isn't a big deal, it just takes a long time to parse a dozen or two gigs
15:03:57 <jmcarthur> i'd be able to do the analysis myself, but i'm not sure i'd feel like doing it today
15:03:58 <gwern> jmcarthur: well, 4k files generated 500k, and I'd guess half of the 111k+ files have extensions, so 50k files generate ...?
15:04:16 <gwern> 5-10M is my guess
15:04:38 <jmcarthur> > (4 % 500) * 50
15:04:39 <lambdabot>   2 % 5
15:04:48 <jmcarthur> doh
15:04:51 <gwern> well played lambdabot
15:04:56 <jmcarthur> well i did it wrong
15:06:13 <jmcarthur> > 500 * 50 / 4
15:06:14 <lambdabot>   6250.0
15:07:21 <Hugglesworth> what's that tool that isolates a cabal instance for a project?
15:07:40 <gwern> jmcarthur: I would be more surprised if much less than half had extensions than if much more than half did, so 6.2M would be conservative
15:07:51 <monochrom> cabal-dev
15:08:10 <Hugglesworth> monochrom: thanks
15:15:51 <KSkrzet> Data.HashTable from base have hardcoded Int32 as return type from hash function
15:16:05 <KSkrzet> anyone know if this restriction can be lifted?
15:16:33 <aavogt> use Data.Map
15:17:00 <aavogt> oh, to reuse the hash, you'll have to find another hash function
15:17:25 <KSkrzet> Data.Map is bit too slow, unfortunately
15:17:42 <shachaf> KSkrzet: I understand that Data.HashTable tends to be slower than Data.Map.
15:17:46 <KSkrzet> I have a few hash functions around
15:17:46 <gwern> jmcarthur: 6.4M
15:17:57 <KSkrzet> slower? that's a pity
15:18:01 <aavogt> what about Data.IntMap?
15:18:29 <aavogt> (that one is also hardcoded in the same way as the hash table)
15:18:38 <KSkrzet> I need ByteString -> Int mapping
15:19:04 <KSkrzet> Data.HashTable looked natural fit
15:19:19 <dons> bytestring-trie perhaps
15:19:22 <dons> or Data.Map
15:19:31 <gwern> jmcarthur: sent
15:19:42 <dons> i'd be somewhat surprised if Data.Map was slower
15:20:01 <gwern> anyone else want the file? all extension users, 116k of them
15:20:06 <bos> use Data.HashMap
15:20:14 <aavogt> gwern: that many users?
15:20:15 <KSkrzet> dons: why should anyone bother using Data.HashTable then?
15:20:24 <gwern> aavogt: so it would seem
15:20:31 <shachaf> Users of what?
15:20:42 <aavogt> can one person be multiple users?
15:20:50 <gwern> shachaf: extensions. any file that uses LANGUAGE pragmas
15:21:09 <aavogt> what about the cabal files which specify -X....
15:21:23 <aavogt> or whatever that section is   extensions: maybe?
15:21:31 <shachaf> Those deserve whatever they get.
15:21:31 <gwern> aavogt: no. handling cabal files is hard
15:21:40 <gwern> so, I didn't bother.
15:21:49 <dons> KSkrzet: sometimes they specifically need hashing, or they have a specific use case that happens to be faster in the hashtable, in IO, than any of the other options
15:21:53 <aavogt> users left behind
15:21:56 <dons> but they're fairly rare in haskell code
15:21:59 <gwern> heck, just finding whatever .cabal governs a file is nontrivial
15:22:03 <dons> esp. with hashmaps these days
15:25:16 <KSkrzet> dons: I was hoping for some data structure with lower memory needs. 500mb when read explodes into more than my 8 gb of ram... which is sad
15:26:39 <dons> KSkrzet: chat to tibbe, he's been looking at this recently
15:26:43 <dons> tibbe: ^^
15:27:10 <bos> hashmap's memory use is not bad
15:27:15 <KSkrzet> dons: I'm already using newest version
15:27:23 <dons> KSkrzet: the experience report from the twitter folks loading 64G maps in was interesting, and had useful hints
15:27:24 <KSkrzet> dons: but thanks for the tip anyway
15:27:33 <balor> So I've created an instance of Arbitrary and defined a property for a function, but how do I now run quickcheck?  Should it be done from main?
15:27:51 <KSkrzet> dons: I dont follow twitter, can you point me to the specific tweet?
15:27:52 <KirinDave> KSkrzet: It explodes?
15:28:04 <KirinDave> KSkrzet: I've only seen that happen when I accidentally wasn't using ByteString.
15:28:09 <KSkrzet> KirinDave: well, it should fit into ~1.5 gb
15:28:43 <jmcarthur> gwern: thanks
15:28:44 <KSkrzet> KirinDave: yeah, I had that experience too. These days it's butestrings, attoparsec and stuff
15:28:55 <KSkrzet> bytestrings*
15:29:29 <kmc> buttstrings
15:29:35 <KirinDave> KSkrzet: But you're saying that when you eagerly get bytestrings into a map, they end up being >8gb for 500mb of source data?
15:29:52 <Cale> balor: It could be, if you want. You could define a custom main action for that. You could also just run it from ghci
15:29:54 * hackagebot hstzaar 0.6 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.6 (PedroVasconcelos)
15:30:05 <Cale> balor: which is what I usually do
15:30:09 <KSkrzet> KirinDave: no, that's after I parse them, transform a little and put into a map
15:30:15 <balor> Cale, thanks
15:30:28 <KirinDave> KSkrzet: Are you sure you've forced them before they go in the map?
15:30:32 <KSkrzet> KirinDave: basically it's HashMap ByteString [ByteString]
15:30:40 <Cale> balor: if you name your properties prop_foo, there is a script which will go through and quickCheck them all... not sure where to get it, it might even be in the quickCheck package.
15:31:05 <Cale> http://hackage.haskell.org/package/quickcheck-script -- ah, here it is :)
15:31:09 <KirinDave> KSkrzet: Could it be you've got a thunk for every key as opposed to the final result? :)
15:31:17 <KirinDave> KSkrzet: (would that it were that simple)
15:31:34 <KSkrzet> KirinDave: I do, but somehow if I force them the memory usage goes up
15:31:55 <KirinDave> Huh.
15:32:20 <monochrom> could you estimate how many entries are in the hashmap?
15:32:40 <monochrom> perhaps how many keys
15:32:51 <KSkrzet> around 1150000
15:33:00 <KSkrzet> but no more than 1200000
15:33:09 <KSkrzet> keys that is
15:33:27 <KSkrzet> I don't think internals are exposed so I don't know how to check for collisions etc
15:33:48 <monochrom> number of keys suffices
15:34:55 <bos> i've dealt with hashmaps containing maybe 500,000 elements
15:36:45 <monochrom> 8G/500M = 16. every byte is accompanied by 15 more bytes, or call it 16
15:37:08 <monochrom> this may happen with [Char]
15:37:48 <KSkrzet> when I run with +RTS -hT, the graph looked funny
15:38:20 <monochrom> interesting, hashmap = intmap . hash
15:39:40 <monochrom> are you using 32-bit ghc or 64-bit ghc?
15:40:20 <KSkrzet> 64 bit
15:40:24 <KSkrzet> 7.0.2
15:40:32 <KSkrzet> I have HEAD as well, but I didn't try it
15:41:13 <KSkrzet> see here for -hT: http://dl.dropbox.com/u/1479187/textmining-zajecia07_08-zad2.pdf
15:41:38 <KSkrzet> Tip and Bin account for a quite lot of memory
15:42:37 <monochrom> each hashmap node (approx intmap node) may be 4-5 Int's. 64-bit, that's 32-40 bytes. 1M keys, that's up to 40MB for the tree data structure
15:43:40 <monochrom> Tip is leaf node, Bin is branch node, in the binary tree
15:44:53 <monochrom> but growing beyond 100MB is wrong. as said, 1M keys should be just 40MB of Bins and Tips
15:45:09 <monochrom> (if there are collisions, even fewer)
15:45:37 <monochrom> theory A: you don't force the hashmap enough when you insert
15:46:06 <KSkrzet> how?
15:46:12 <monochrom> theory B: you have lingering references to old versions of hashmap when you insert
15:46:14 <KSkrzet> I mean, I seq it
15:47:08 <KSkrzet> http://hpaste.org/46399/read_graph
15:47:49 <KSkrzet> here is the central function
15:48:35 <KSkrzet> m2 (which is the most recent version of hashmap) is first band-pattern-matched, and then passed away. no other map is passed.
15:48:39 <KSkrzet> hashmap*
15:52:44 <monochrom> I looked at the wrong hashmap
15:53:57 <monochrom> do you use Data.HashMap.Strict or Data.HashMap.Lazy?
15:54:02 <KSkrzet> Strict
15:54:43 <KSkrzet> but AFAIK they only differ in value strictness, key are strict in both versions
15:55:17 <monochrom> I want to make sure addArticle, addArticles, fun are not goofing up
15:56:12 <KSkrzet> http://hpaste.org/paste/46399/read_graph_annotation#p46400
15:57:25 <KSkrzet> I pasted them there
15:57:44 <KSkrzet> the whole file is a mess right now so I cant paste it right away
15:57:55 <monochrom> then again insertWith doesn't leave room for goofing up. it bangs the thing that needs banged
15:58:20 <monochrom> the paste is sufficient, don't worry
15:58:47 <KSkrzet> I'm curious why does hashmap takes so much space itself
16:05:55 <monochrom> I don't know what's wrong yet
16:06:44 <monochrom> I have some weak doubts about addArticles's foldr, but it cannot account for all of the 8GB
16:08:16 <KSkrzet> I'm trying to rewrite parts of the program to see if I can make a change
16:24:17 <Entroacceptor> help :/ (Pattern match failure in do expression at libraries/base/System/Event/Thread.hs:83:3-10)
16:24:33 <Entroacceptor> this is compiled with ghc 7.0.2, runs fine on one system
16:24:54 <Entroacceptor> then I copied the binary, and get that errors
16:27:18 <BMeph> "UR DOIN IT RONG"
16:27:47 <Entroacceptor> mebby
16:27:54 <Entroacceptor> but it worked great so far
16:27:55 <monochrom> Entroacceptor: it will take a lot of work to debug this kind of errors. all I am willing to say is: identify which function that line of code belongs to, then annotate all call sites (repeat: call sites) of that function, then go from what you discover, which has too many possibilities to enumerate
16:28:05 <parcs> is newTMVarIO supposed to be used within the IO monad or only within the ST monad?
16:28:18 <monochrom> "annotate" means use the like of Control.Exception.assert to check for preconditions
16:29:11 <parcs> http://hackage.haskell.org/packages/archive/stm/2.1.1.2/doc/html/Control-Concurrent-STM-TMVar.html#v:newTMVarIO
16:29:15 <monochrom> also http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging scroll down to "-xc" may or may not help. this is the much sought-after so called "stack trace"
16:29:34 <parcs> err, forget the part about the ST monad..
16:30:15 <monochrom> newTMVarIO can be used in IO. you can even unsafePerformIO it for global variables
16:30:21 <Entroacceptor> monochrom: as the same  binary works on another computer, I was thinking that might be some library incompatibility
16:30:59 <Entroacceptor> and it looks suspiciously like http://hackage.haskell.org/trac/ghc/ticket/4927
16:32:33 <Entroacceptor> can cabal compile a static binary?
16:32:36 <monochrom> well then test ghc 7.0.2 or 7.0.3 and network 2.3.0.2
16:33:31 <Nereid> Entroacceptor: ghc statically links haskell libraries by default
16:33:37 <Nereid> (it still dynamically links to libc and whatnot...)
16:34:16 <monochrom> static haskell libs without effort. static c libs with unknown amount of effort (no one seems to have succeeded)
16:34:28 <parcs> monochrom: but it seems to be specialized for use within an unsafePerformIO
16:34:48 <Nereid> monochrom: maybe you could do the awful thing and use statifier or something?
16:34:52 <monochrom> using it in normal IO is no problem
16:35:06 <parcs> okay
16:35:35 <Entroacceptor> *sigh*
16:39:00 <monochrom> I have just verified that bug #4927 does not happen on 32-bit ghc 7.0.3, network 2.3.0.2
16:39:57 <monochrom> linux, ubuntu 10.10
16:42:06 <Entroacceptor> ok, thanks..
16:43:46 <KSkrzet> monochrom: after rewrite it turns out that mere mapping (Token -> Int) contributes to tree-fold increase in space usage
16:44:03 <KSkrzet> monochrom: I'll try bytestring-trie now
16:44:22 <sully> if I load some files in ghci and run them, how does that compare performance-wise to actually compiling it with ghc and getting an executable?
16:47:03 <KSkrzet> sully: compiled version will always win. the question is by what margin.
16:47:07 <monochrom> KSkrzet: so you mean computing a hash value takes a lot of memory? that's even stranger. the plot thickens... :)
16:48:01 <KSkrzet> well, see here: http://dl.dropbox.com/u/1479187/textmining-zajecia07_08-zad2_v2.pdf
16:48:04 <sully> KSkrzet: so, I am from SML-land, and with SML/NJ, the compiled version /isn't/ any faster, because the repl does a full compile
16:48:36 <KSkrzet> sully: I was talking about GHC compiled version, since you asked about it
16:49:11 <sully> yeah, I know, I was just explaining why I was asking
16:49:22 <monochrom> yeah sml compiles every line unconditionally. ghci interprets
16:49:39 <monochrom> so it's like 10x? 20x? I forgot
16:50:00 <sully> ok, so a bunch
16:50:01 <KSkrzet> I think in I/O heavy code it's more like 2x
16:50:21 <KSkrzet> since you are mostly waiting anyway
16:50:28 <sully> enough for it to be worthwhile for me to spend the 5 minutes to build a command line interface to my ICFP 2006 theorem prover
16:50:39 <sully> instead of just calling it from the repl
16:51:46 <KSkrzet> btw it's great how porting is made easy with Haskell
16:51:59 <KSkrzet> or rather switching libraries
16:52:17 <monochrom> here is what you could do. you are working on modules X,Y,Z. actually you are working on X recently, Y,Z won't change for a while. compile Y,Z. (ghc -c -O Y.hs Z.hs) load X into ghci interpreted
16:53:03 <monochrom> see also http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-compiled.html
16:53:59 <monochrom> so Y,Z are fast, while you can still test internal unexported functions of X (absolutely need X interpreted for this)
16:54:22 <sully> awesome! thanks
17:01:21 * hackagebot AERN-Basics 2011.1 - foundational type classes for approximating exact real numbers  http://hackage.haskell.org/package/AERN-Basics-2011.1 (MichalKonecny)
17:03:19 <KSkrzet> so... the bytestring-trie is 2 times slower as uses a little bit more memory as well
17:03:28 <KSkrzet> *sigh*
17:06:34 <Peaker> 2 times slower than?
17:06:52 <KSkrzet> Data.HashMap.Strict
17:06:59 <KSkrzet> at least for my purposes
17:07:19 <KSkrzet> with different load it might be different
17:07:36 <KSkrzet> (see package unordered-containers)
17:12:24 * hackagebot AERN-Real 2011.1 - arbitrary precision real interval arithmetic  http://hackage.haskell.org/package/AERN-Real-2011.1 (MichalKonecny)
17:24:25 * hackagebot AERN-Real-Interval 2011.1 - arbitrary precision real interval arithmetic  http://hackage.haskell.org/package/AERN-Real-Interval-2011.1 (MichalKonecny)
17:33:26 * hackagebot AERN-Real-Double 2011.1 - arbitrary precision real interval arithmetic  http://hackage.haskell.org/package/AERN-Real-Double-2011.1 (MichalKonecny)
17:34:19 <KSkrzet> now that is quite a surprise
17:34:45 <KSkrzet> I didn't know the difference between 32 and 64 bit would be that big: 1 gb memory on 32 bits, 8 gb+ on 64
17:36:23 <monochrom> that is really strange
17:37:18 <hpc> i can sort of see how it might happen for IntMap
17:37:34 <monochrom> pray tell
17:38:05 <KSkrzet> well, I'll just compile on 32 bits and run on 64 anyway
17:38:48 <monochrom> tree data structures of intmap and unordered-container:hashmap are similar. your guess may apply to both
17:40:13 * ddarius suspects that the guess applies equally well to both...
17:40:25 <monochrom> yeah
17:40:30 <hpc> actually, it seems hashmap is implemented in terms of intmap
17:40:40 <hpc> i don't know enough to properly describe my guess atm
17:41:44 <hpc> ah, here we go
17:41:45 <hpc>               | Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask !(IntMap a) !(IntMap a)
17:42:02 <hpc> Prefix and Mask are both Int
17:42:20 <hpc> so that at least accounts for some of the size increase
17:42:54 <ddarius> Of course it does.  But if we assume everything is an Int and thus gets twice as big, that is only 1 to 2.
17:43:16 <monochrom> there are two hashmaps. package hashmap uses intmap. package unordered-containers uses its own data structure but similar
17:43:28 <hpc> ah
17:44:28 <hpc> the unordered-containers hashmap is virtually identical to intmap
17:45:12 <hpc> hmm, i have no idea
17:45:37 <KSkrzet> i solved it
17:45:39 <KSkrzet> see
17:46:03 <KSkrzet> i have large pc, 64 bits, and a laptop, 32 bits
17:46:10 <KSkrzet> the code is shared by git repo
17:46:32 <KSkrzet> and I compiled old code on laptop, while the uncommited changes where on 64 bits
17:46:35 <KSkrzet> ...
17:47:00 <hpc> so you were comparing different programs? lol
17:47:21 <hpc> ive made that mistake before
17:47:22 <KSkrzet> yeah, I probably should get some rest
17:48:11 <KSkrzet> thats what happens now: textmining-zajecia07_08-zad2: out of memory (requested 1048576 bytes)
17:49:51 <sevenfive> hello
17:50:22 <sevenfive> i tried to make an integer type with a sucessor constructor and a predecessor constructor
17:50:28 <sevenfive> for negative numbers
17:50:35 <sevenfive> i know its stupid :P
17:51:04 <sevenfive> so the type is Integ x and there's Integ Pos and Integ Neg
17:51:40 <sevenfive> and there's S :: Integ Pos -> Integ Pos and P :: Integ Neg -> Integ Neg and Z :: Integ x
17:51:43 <sevenfive> can this work?
17:51:56 <ddarius> Sure.
17:52:02 <sevenfive> i tried writing an addition function and it didn't work when i got to
17:52:07 <sevenfive> add Z x = x
17:52:15 <sevenfive> and add x Z = x
17:52:36 <sevenfive> the type i gave it was Integ x -> Integ y -> Integ z
17:52:49 <monochrom> you will find difficulty in adding a,b if a :: Integ Pos, b :: Integ Neg
17:52:53 <sevenfive> and it didn't like how x went from Integ x/y to z
17:53:25 <monochrom> in fact I wonder why you set yourself up to have two to infinitely many different types of Integ blah.
17:53:27 <sevenfive> couldn't match expected type Integ z against inferred x
17:53:36 <hpc> sevenfive: you could try writing S :: I -> I, P :: I -> I, Z :: I
17:53:37 <sevenfive> infinitely many?
17:53:41 <hpc> sevenfive: then not export the constructors
17:54:09 <hpc> sevenfive: then succ (S x) = S (S x); succ Z = S Z; succ (P x) = x
17:54:14 <hpc> same for pred
17:54:22 <sevenfive> yeah i know
17:54:30 <sevenfive> thats boring though
17:54:34 <hpc> haha, fair
17:54:36 <monochrom> yes infinitely many. since you have polymorphic type "Integ blah", nothing stops me from Integ Bool, Integ (), Integ (Bool->Bool), Integ (Bool->Bool->Bool)... how do you add those?
17:54:51 <sevenfive> yeah...
17:55:07 <monochrom> I think you generalize too much
17:55:37 <sevenfive> is there any way to make sure it only uses the POs and Neg types i set up for it?
17:55:42 <ddarius> monochrom: Clearly he does.
17:56:01 <sevenfive> like a type class or something
17:56:03 <ddarius> sevenfive: Just change the type of Z.
17:56:10 <sevenfive> to what?
17:57:01 <monochrom> data Integ = P Integ | Z | S Integ. you need no type variable
17:57:11 <ddarius> Integ () say.  Then the only total values would have type Integ Pos, Integ Neg, Integ ().
17:57:19 <ddarius> monochrom: That doesn't work until you quotient.
17:57:41 <monochrom> I intend to quotient and normalize, yes
17:57:48 <sevenfive> But then wouldn't P and S reject it?
17:59:26 <ddarius> I guess you would have to add one and negative one.
17:59:35 <sevenfive> the thing that confuses me is why it won't let me use the x::Integ y in add Z x into x :: Integ z
18:00:18 <sevenfive> i want P and S to reject each other , but not Z
18:00:55 <ddarius> Your type is equivalent to forall x y. Integ x -> Integ y -> forall z. Integ z
18:01:27 <ddarius> The case of adding Integ Pos and Integ Neg should make clear that that type won't work.
18:01:40 <sevenfive> why not?
18:01:43 <sevenfive> oh
18:01:57 <sevenfive> cause the only thing with type forall z Integ z is zero
18:03:01 <sevenfive> even if it's foral x y z
18:03:06 <ddarius> To get a type like that, you'd either need dependent types so you could calculate Pos or Neg, or you need to forget the signedness for addition.
18:03:16 <sevenfive> it allows Pos -> Pos -? neg so i guess thats wrong
18:04:06 <ddarius> You are trying to recreate Integer which isn't a parameterized type.  So do something with the parameter you've got now.
18:05:09 <sevenfive> can i use type families
18:05:40 <ddarius> No, because you can't statically calculate whether an Integ Pos `add` Integ Neg will be Pos Neg or other.
18:05:51 <ddarius> You are being too static.
18:06:24 <sevenfive> o i c
18:06:27 <monochrom> the road to c++ is paved with type-level good intentions
18:06:37 * ddarius huggles C++.
18:07:02 <sevenfive> i was thinking of something like add Integ Pos Integ Neg = forall z. Integ z but that also means zero
18:08:01 <ddarius> The point is that you don't want the type Integ Pos because that's the type of positive integers.  It's fine for your representation, but it isn't what you are trying to implement.  You just want Integer.  So how can you forget that signedness parameter?
18:08:18 <sevenfive> while still preventing P and S from mixing?
18:08:23 <sevenfive> i dunno
18:09:01 <monochrom> existential type is a kind of forgetting
18:09:02 <ddarius> You don't need to change your type constructor, how do you make a Integer out of your type constructor?
18:10:44 <sevenfive> ? i dont follow
18:30:54 <colinhect> Does anyone know how far along Hackage 2.0 is and roughly when it might be done?
18:31:00 <MarcWeber> Is there any example showing how to use custom tokens with Parsec in particular how to set Position? I want to use Alex returning (pos, token) tokens.
18:31:48 <stepkut> are there any good logging libraries (something besides hslogger)
18:32:19 <MarcWeber> stepkut: Whats wrong about hslogger?
18:32:39 <stepkut> MarcWeber: (1) it is slow (2) it is LGPL not BSD3 :)
18:33:01 <ddarius> stepkut begins to define "good"
18:33:06 <MarcWeber> All I know is that I tried making it faster once - but all I tried made things worse.
18:33:30 <stepkut> I know snap has a fast logging library, but it is not split into a separate library yet
18:35:46 <MarcWeber> stepkut: What's wrong with LGPL? Does'nt this mean you can link it with arbitrary code?
18:36:16 <stepkut> MarcWeber: not if you are doing static linking, which is what GHC generally does
18:37:20 <shachaf> What an annoying distinction.
18:37:26 <stepkut> yep
18:38:30 * ddarius huggles symplectic integration.
18:38:56 * Hugglesworth huggles ddarius
18:39:21 * shachaf huggles worth.
18:42:44 * ddarius has nothing to drink except for tap water and alcohol.
18:43:09 <shachaf> How's the tap water in Boston?
18:43:24 <dolio> Tastes fine to me.
18:43:25 <ddarius> Much better than in San Angelo, Texas.
18:43:44 <geheimdienst> if huggling is transitive, Hugglesworth just huggled symplectic integration
18:44:10 <shachaf> Why would huggling be transitive?
18:44:44 <shachaf> Next you'll say it's an equivalence relation.
18:45:08 <dolio> pumpkin has a bottle of J&B on top if his fridge.
18:45:20 <dolio> Every time I see it it reminds me of Patrick Bateman.
18:45:46 <ddarius> Have you made bread yet?
18:45:54 <dolio> No, sorry.
18:46:44 <dolio> I can come shovel gravel as penance.
18:47:06 <ddarius> Works for me.
18:47:37 <dolio> Which bread were you talking about, by the way?
18:49:57 <ddarius> dolio: The pain l'ancienne.
19:00:45 * hackagebot gsl-random 0.4.2 - Bindings the the GSL random number generation facilities.  http://hackage.haskell.org/package/gsl-random-0.4.2 (PatrickPerry)
19:15:22 <KSkrzet> funny
19:15:35 <KSkrzet> I have managed to produce a program that simply sits and does nothing
19:15:44 <KSkrzet> by manipulating data streams
19:16:11 <monochrom> the best kind of programs :)
19:16:27 <KSkrzet> there is no deadlock reported by rts
19:16:34 <KSkrzet> no cpu, no disk
19:16:36 <KSkrzet> just nothing
19:28:52 <Peaker> Does the RTS detect all possible deadlocks?
19:29:11 <kmc> you mean, once they've occurred?
19:29:39 <Peaker> yeah
19:35:13 <dmwit> That sounds halting problematic.
19:35:19 <dmwit> So I'm going to go with no.
19:35:35 <kmc> i thought so too, but it depends how you define deadlock vs livelock
19:36:16 <dmwit> KSkrzet: Hm. I bet my program that does nothing is simpler than your program that does nothing.
19:36:30 <dmwit> main = forever (threadDelay maxBound)
19:37:55 <KSkrzet> in ghci works even simpler one
19:38:03 <KSkrzet> let main = main
19:38:04 <KSkrzet> main
19:38:24 <kmc> if you draw a graph of processes, where each process waiting on a lock has an edge to the process which holds that lock
19:38:31 <kmc> then you have deadlock iff that graph has a cycle
19:38:32 <kmc> i think
19:38:47 <KSkrzet> well, it turned out I had a bug in my program
19:39:10 <kmc> and it should be easy to build that graph from RTS state
19:39:12 <KSkrzet> it quit parsing after consuming no input and went into "wait for query" state
19:39:15 <kmc> (speaking theoretically, not about GHC in particular)
19:39:20 <KSkrzet> in which it waited for user input
19:39:21 <kmc> so i don't think deadlock detection is uncomputable
19:39:41 <kmc> there are other forms of non-progress besides deadlock, some of which we'd call livelock
19:40:06 <dmwit> KSkrzet: But "main = main" uses CPU, which you claimed your do-nothing program didn't.
19:40:23 <kmc> if you build with ghc -threaded, then "main = main" will not use CPU and will not terminate
19:40:26 <kmc> iirc
19:40:34 <dmwit> Wow, really?
19:40:36 * dmwit tries
19:40:41 <kmc> anyway, a thread can take a lock and then sleep forever, or busy-loop, or run turing machine T which happens to never halt
19:40:44 <monochrom> main=main should just blackhole
19:40:44 <kmc> but none of those are deadlock per se
19:40:54 <kmc> with the concurrent RTS, you have whiteholes instead of blackholes
19:41:13 <monochrom> or whatever-hole
19:41:20 <kmc> with only one haskell evaluating thread, you know a double thunk entry is an infinite loop
19:41:29 <monochrom> nice, now we can fight over hole colours too
19:41:33 <dmwit> main = main blackholes
19:41:33 <kmc> but if you have two threads entering thunks, one might try to enter a thunk that the other guy is currently working on
19:41:45 <dmwit> i.e. it does terminate
19:42:10 <kmc> so a blackhole kills the program if entered, but a whitehole merely causes the current Haskell thread to sleep until it's update
19:42:14 <kmc> updated*
19:42:18 <kmc> dmwit, ah
19:43:28 * KSkrzet sucessfully implemented on-line compression data structure in single page of Haskell and goes to sleep
19:44:18 <KSkrzet> http://hpaste.org/46411/online_compression_int_multise
19:45:32 <dmwit> Is there a way to get GHC to play with a file that has a non-standard extension?
19:45:40 <kmc> symlink :)
19:45:55 <kmc> ghc -x
19:46:08 * dmwit looks up -x in the manual
19:46:11 <kmc> ghc -x hs foo.not-hs
19:46:41 <dmwit> "ghc: no input files"
19:48:14 <dmwit> Oh, I typo'd.
19:48:35 <dmwit> When I do it right, I get "/proc/self/fd/11: hFileSize: inappropriate type (not a regular file)", so this is probably not going to work. =P
19:48:49 <kmc> haha
19:49:33 <kmc> are you using <(...) redirection or such?
19:49:40 <dmwit> ghc --make -threaded -o test -x hs <(echo main = main)
19:49:43 <dmwit> So, yes. =)
19:50:14 <cch> why is this base64 encoding so slow (24 seconds)? https://gist.github.com/958366
19:50:14 <kmc> i love <(...) redirection
19:50:37 <kmc> on what input?
19:50:57 <kmc> it's probably the L.unpack >>= print
19:51:03 <kmc> try ByteString IO
19:51:13 <cch> input file size is 40k
19:51:44 <cch> you mean strict bytestring IO rather Lazy version ?
19:51:50 <kmc> no, but i misunderstood
19:51:57 <kmc> you're using a String -> String base64 function
19:52:01 <kmc> http://hackage.haskell.org/packages/archive/base64-string/0.2/doc/html/Codec-Binary-Base64-String.html
19:52:01 <kmc> yes?
19:52:16 <kmc> so you're not gaining much from bytestring
19:52:17 <cch> I use import Codec.Binary.Base64
19:52:35 <kmc> well you can tell by the type you use it at
19:52:52 <kmc> you're calling L.unpack and passing the result to 'encode'
19:52:57 <kmc> anyway try the base64-bytestring package instead
19:53:02 <kmc> module Data.ByteString.Base64
19:53:12 <cch> Codec.Binary.Base64.encode :: [GHC.Word.Word8] -> String
19:53:12 <cch>  
19:53:20 <kmc> hmm, ok
19:53:27 <kmc> that's not the one i pasted, but it's not ByteString based either
19:53:35 <kmc> [Word8] is roughly as inefficient as [Char]
19:53:41 <kmc> (they represent different things, though)
19:53:58 <cch> ok
19:54:10 <cch> let me try Data.ByteString.Base64, thanks
19:54:18 <kmc> no problem :)
20:06:56 * hackagebot gsl-random 0.4.3 - Bindings the the GSL random number generation facilities.  http://hackage.haskell.org/package/gsl-random-0.4.3 (PatrickPerry)
20:16:58 * hackagebot monte-carlo 0.4 - A monad and transformer for Monte Carlo calculations.  http://hackage.haskell.org/package/monte-carlo-0.4 (PatrickPerry)
20:19:10 <dmwit> data-default is so good
20:27:48 <Kerris> ahaha
20:27:51 <Kerris> oops
20:28:56 <shash> please help me
20:29:09 <shash> how to make login in haskel :O
20:29:21 <djahandarie> "Login"?
20:29:31 <shash> i want to take user input
20:29:36 <shash> like a login page
20:29:52 <djahandarie> On a browser or in your terminal? And, what's your experience with Haskell so far?
20:30:01 <shash> terminal
20:30:06 <shash> i am new to haskell
20:30:25 <djahandarie> Okay. You probably want the action "getLine"
20:31:41 <djahandarie> :t getLine
20:31:42 <lambdabot> IO String
20:32:12 <shash> putStrLn "enter your name"
20:32:33 <shash> how to get in string
20:33:09 <djahandarie> putStrLn "enter you name"   is an IO action.    getLine is another IO action.    You can put them together with >> to get new IO action that includes them both.
20:34:19 <monochrom> complete working example at http://hpaste.org/46412/login
20:36:22 <shash> thankz
20:36:35 <shash> but i want to check like login
20:36:50 <shash> for example if some login names are saved in array
20:36:58 <shash> and if user name matches that
20:37:08 <shash> it should say login success
20:37:15 <monochrom> learn more haskell. read more tutorials and books
20:37:57 <monochrom> play with tryhaskell.org. start from the basics.
20:39:09 <shash> ok\
20:42:40 <shash> is their any gui version of haskelll
20:44:19 <monochrom> I guess checking login names against a known list isn't that advanced. http://hpaste.org/paste/46412/login_and_check#p46413
20:45:19 <monochrom> if you use windows, the windows version of ghc comes with some simplistic gui called "winghci"
21:05:29 <scutigera> anybody have any experience using the accelerate package ?
21:07:27 <scutigera> tap, tap, tap. is this thing on ?
21:07:45 <djahandarie> Yes, but I have no experience using the accelerate package.
21:09:57 <scutigera> my original plan was to develop a dsl to optimize some array based calculations.
21:10:22 <scutigera> accelerate looks good except there's no llvm backend and I don't have a graphics card that supports cuda.
21:12:37 <djahandarie> Sounds interesting. Data-Parallel Haskell is also something to look into.
21:16:13 <djahandarie> For some reason I feel like learning >> and >>= before do notation is easier.
21:16:52 <djahandarie> Do notation reeks too much of magic.
21:17:13 <kmc> i agree, to a point
21:17:43 <djahandarie> I think I would immediately introduce it right afterwards though.
21:17:47 <scutigera> djahandarie: looks very interesting.  I wonder what happens when it compiles to a scalar processor ?
21:19:16 <djahandarie> Not sure. You could also look at repa.
21:21:15 <scutigera> djahandarie: that looks very promising. thanks.
21:21:54 <djahandarie> Welcome. It still doesn't match your domain exactly but should probably get you part of the way or give you ideas. :)
21:24:27 <scutigera> djahandarie: yes indeed.  It still may be worth it for me to write my own optimizer since the task is very specialized - but very good ideas will be found in that source code :-)
21:25:21 <scutigera> djahandarie: in fact one of the repa examples is very similar to what I am trying to do...
21:33:45 <NemesisD> is it possible to declare Text as a literal? i've been doing pack "my string" but that seems wrong
21:34:06 <c_wraith> NemesisD: if you enabled the OverloadedStrings extension, yes
21:41:29 <dmwit> Ho yes. 23 lines of text to print out a graph on four points.
21:41:38 <dmwit> I am definitely doing something right.
21:41:53 <Axman6> o.O
21:45:20 <Axman6> dmwit: I'm curious to see what that output looks like
21:46:33 <dmwit> Axman6: http://hpaste.org/46417/fmap_graph_randomgrid_2_2
21:47:01 <Axman6> you lied, that's just one long line! :P
21:47:07 <dmwit> =)
21:56:06 <djahandarie> http://www.haskell.org/pipermail/haskell-cafe/2011-May/091666.html looks pretty cool, for anyone who doesn't read -cafe and isn't on the twittersphere
21:58:05 <Axman6> heh, indeed, just read that after dons tweeted it
22:26:56 <KirinDave> Huh
22:27:41 <KirinDave> So i'm asking myself, "What this code needs to do is both mutate some state and also produce some output lines to be written."
22:27:48 <KirinDave> Is this the time when I should use Writer?
22:27:50 <KirinDave> Probably!
22:28:19 <kmc> "fuck it, use IO"
22:28:20 <dibblego> WriterT and State prolly
22:28:35 <KirinDave> dibblego: The state is just a tuple where I update the first part.
22:28:40 <dibblego> that's Writer
22:28:44 <KirinDave> I almost should use readerT and writer
22:29:50 <dibblego> @unmtl ReaderT t (Writer w) a
22:29:50 <lambdabot> t -> (a, w)
22:34:21 <Yvemath> I am going to write my first haskell program' wee!
22:34:42 <dibblego> be sure to ask here if you get stuck
22:35:40 <Yvemath> :)
22:36:07 <Axman6> we're here to help!
22:36:25 <Yvemath> dibblego: One thing i couldnt get is the diff between Int and Num.
22:36:51 <Rotaerk> is 5.3 a number? is it an integer?
22:36:55 <dibblego> Int is a data type while Num is a type-class. Many data types are instances of the Num type-class, including Int.
22:37:00 <kmc> Int is a type, Num is a sort of generic interface implemented by lots of different types (including Int)
22:37:23 <kmc> this is how you can use (+) to add two Ints but also to add two Doubles
22:37:37 <Axman6> Yvemath: have you ever programmed in any other languages?
22:38:39 <Yvemath> Axman6: C,C++,Java,VB.Net a couple years ago (>4) These days i have been working in/around Php,jQuery,HTML5 and CSS. But yes, i have an idea.
22:38:54 <Yvemath> However someone earlier told me i'd have to undo whatever i have learnt.
22:39:00 <Axman6> well, Num is like an interface in Java
22:39:06 <dibblego> eek
22:39:21 * Dashkal twitches
22:39:23 <kmc> cue 10 minute argument about Java
22:39:27 <Axman6> well, a typeclass is like an interface in java
22:39:39 <kmc> kind of like, kind of not like
22:39:47 <Axman6> yeah
22:39:49 <kmc> it's not a bad starting point
22:39:52 <dibblego> it's not so much about Java as much as a) this explanation is incorrect b) this explanation hinders learning progress
22:40:02 <djahandarie> I don't know why people cringe about that analogy. It isn't that bad.
22:40:14 <Yvemath> Hrmm. I understand typeclass. :-) It is a bit confusing sometimes (just that) I guess after i write some programs, it will be dealt with. :-)
22:40:17 <Axman6> nethertheless it's a good place to start so people can get an idea what a typeclass is in haskell
22:40:20 <Dashkal> I learned them that way.  Then unlearned that mistake and really learned them...
22:40:31 <ulfdoz> Anfnger, wa?
22:40:37 <ulfdoz> ewin, sorry.
22:40:42 <kmc> i think for experienced programmers it suffices to say "like an interface" and the "in Java" part is probably harmful
22:40:49 <Axman6> i haven't used java interfaces enough to know how they're different =)
22:41:02 <dibblego> kmc: yes, I have found this to be universally true in my experiences
22:41:22 <Dashkal> That would be why you don't understand why I cringe :P
22:41:52 <dibblego> there is nothing like type-classes in Java, except perhaps a couple of brave attempts to save an analogy, though nothing that assists in teaching
22:42:05 <ulfdoz> I think the term "like fully virtual abstract class" in C++ is probably overkill.
22:42:06 <dibblego> Num is like nothing you have so far seen
22:42:28 <Axman6> all i remember is that they specify methods that java classes need to implement to conform to that interface. I'm sure there's more to it
22:42:42 <ulfdoz> Axman6: Not really.
22:43:12 <dibblego> type-classes are also nothing like C++ abstract classes
22:43:19 <Rotaerk> type-classes are like interfaces, but not equivalent to them
22:43:38 <dibblego> no, really, they are nothing like interfaces
22:43:48 <kmc> sigh
22:43:49 <djahandarie> Maybe the most 'wrong' part about the typeclass : interface analogy is that in Java you sometimes treat interfaces as types.
22:43:50 <arcatan> why they aren't?
22:43:58 <Dashkal> It's really better to ignore the (kinda) similarities and start from scratch.  It avoids stumbling blocks.
22:44:04 <mauke> oh, the implicit existentials thing
22:44:04 <Rotaerk> yes they are: they define an abstract signature that must be implemented
22:44:30 <Axman6> Yvemath: AAANNNYYWWAAAYYY... Int is a spocific type, it is usually represented by a machine integer (so they're fast), buu they have bounded size. Num is a class which types can implement to be able to use (+), (*), negate, etc.
22:44:35 <dibblego> I'm not prepared to have this discussion *again*, rather, the non-similarity that is alleged to exist, at least has no use in teaching
22:44:38 <ulfdoz> What you can't do in an interface is defining an implementation.
22:44:48 <djahandarie> dibblego, write a blog post next time. :)
22:44:53 <dibblego> I did, years ago
22:44:58 <Rotaerk> another thing that's like interfaces is a record of functions
22:45:09 <Rotaerk> but also not equivalent
22:45:14 <kmc> there's also the part where type classes are about polymorphism (and can have kind other than *) while Java's interfaces predate the introduction of polymorphism in Java, and are mostly orthogonal to the polymorphism that was introduced
22:45:14 <mauke> typeclasses are like records of functions
22:45:18 <Yvemath> Axman6: :)
22:45:29 <kmc> that's why you have the repetition in "class Foo implements Comparable<Foo>"
22:45:31 <djahandarie> mauke, no, dictionaries are like records of functions.
22:45:34 <Rotaerk> mauke, but also not equivalent
22:45:44 <dibblego> or similar
22:45:45 <mauke> djahandarie: typeclasses are like dictionaries
22:45:58 <kmc> type classes are like the types of dictionaries
22:45:59 <djahandarie> Like isn't transitive!
22:46:15 <mauke> 15 interfaces like this
22:46:17 <Dashkal> wow, I think we may have lost our student arguing about what it is and is not similar too...
22:46:21 <dibblego> Java interfaces correspond to data types. Nothing in Java corresponds to type-classes.
22:46:28 <Rotaerk> dibblego, how are they not similar? to say that something is "like" something else or "similar" to something else isn't the same as saying it's isomorphic to it
22:46:30 <dibblego> Dashkal: sadly, we lost him when we said "like type-classes"
22:46:34 <kmc> i love how the simplest beginner question will set off a ton of philosophical soul-searching
22:46:40 <Rotaerk> apples are like oranges, in that they're both fruit
22:46:46 <Rotaerk> but they're not exactly the same
22:46:55 <dibblego> Rotaerk: they are not in any way similar
22:47:18 <Yvemath> Typeclass is like "lithosphere".
22:47:20 <dibblego> and the straws that you grasp at to try to demonstrate otherwise is not conducive to teaching
22:47:22 <Rotaerk> I just gave a statement that is true of both of them, which serves as a way for them to be similar
22:47:30 <mauke> Haskell is like the C preprocessor in that they're both referentially transparent
22:47:33 <Axman6> dibblego: do you teach people?
22:47:36 <dibblego> yes
22:47:50 <dibblego> "type-classes are like interfaces" is almost a guaranteed catastrophe
22:47:52 <Dashkal> That reminds me.  I spent a good deal of time trying to somehow come up with a "fruit" class.  I failed: I couldn't find meaninful properties common to what we call fruit that wern't common to other things.
22:48:08 <dibblego> it's both untrue and unhelpful
22:48:11 <djahandarie> dibblego, I think you actually need to provide an argument if you want to convince anyone right now.
22:48:17 <kmc> if you restrict Haskell typeclasses to only let you use the typeclass-bound variable as the first argument of its methods, but not in subsequent args or return type or containers or any nested thing, then it's more like Java interfaces
22:48:25 <Axman6> dibblego: then rather than complaining, do a better job
22:48:36 <dibblego> djahandarie: I did that in this channel just the other day and a few weeks ago again. I cannot be expected to do this every time a beginner asks a question, surely.
22:48:41 <mauke> Axman6: ... didn't he do that?
22:48:50 <dibblego> Axman6: I just did, by not accepting "type-classes are like interfaceS"
22:49:02 <dibblego> destroying unhelpful myths is not complaining
22:49:10 <Rotaerk> dibblego, that statement alone is harmful, but if you qualify it with an explanation for HOW they are alike, and then draw the line of distinction and explain how they are different, I don't see any problem with that
22:49:13 <Axman6> complaining is infinitely less helpful than something that is somewhat incorrect
22:49:19 <djahandarie> dibblego, sure. But imo it's best to not try and pick up a disucssion if you are going to get burned out by it.
22:49:25 <mauke> Axman6: I disagree
22:49:38 <kmc> "But I have a Ph.D. in Mathematics, and I'm sure a Circle is a kind of an Ellipse! Does this mean Marshall Cline is stupid? Or that C++ is stupid? Or that OO is stupid?"
22:49:40 <dibblego> djahandarie: I just feel sorry for the beginner
22:49:49 <Rotaerk> dibblego, your claim that they are utterly dissimilar is simply incorrect
22:49:56 <dibblego> I might at least register objection to the statement and leave it there
22:50:18 <djahandarie> dibblego, yeah, but it seems like you are really trying to convince people rather than just leave a passing remark.
22:50:29 <djahandarie> But trying to convince people without actually doing anything to convince them. :p
22:50:30 <dibblego> interface CharSequence { int length(); char charAt(int index); }
22:50:43 <dibblego> data CharSequence { length :: Int, charAt :: Int -> Char }
22:50:48 <dibblego> now try to write the type-class
22:51:00 <dibblego> djahandarie: like I said, twice in this channel already
22:51:16 <mauke> class CharSequence a where { length :: a -> Int; charAt :: a -> Int -> Char }
22:51:19 <dibblego> class CharSequence a { length :: a -> Int; ...
22:51:21 <kmc> yeah, the more natural (and more powerful!) way to do OOP in Haskell involves no classes at all
22:51:48 <dibblego> there is nothing like this inJava, because you cannot implicitly pass class CharSequence, which is the essential defining property of type-classes
22:52:04 <dibblego> you use Eq a -> not Eq a => in Java
22:52:08 <mauke> this is where I need convincing
22:52:21 <Axman6> wouldn't the tpyeclass for that interface be something like class CharSequence a where length :: a -> Int, charAt :: a -> Int -> Char? like i said, my understanding of interfaces in java is several years old, and I've never been into much deth with them
22:52:23 <mauke> I don't see this as the essential defining property of type-classes
22:52:40 <dibblego> mauke: what is the difference between data CharSequence and class CharSequence?
22:52:54 <Rotaerk> dibblego, to point out things you can't do with one that you can do with another says nothing of whether they're similar.  it only points out a distinction
22:53:06 <Rotaerk> proof of the existence of a distinction is not proof of the absence of similarity
22:53:08 <dibblego> Rotaerk: they are not similar
22:53:16 <dibblego> Java interfaces correspond to Haskell data types
22:53:33 <dibblego> if this is not true, write a Eq => function in Java, do not use Eq ->
22:53:52 <mauke> dibblego: length is a constant in the data type
22:53:57 <Rotaerk> they don't directly correspond to haskell data types; there are distinctions there too
22:54:09 <Rotaerk> they are simply similar to them, just as they as similar (but in different ways) to type classes
22:54:14 <Axman6> Heh hem! I was apparently wrong, we have established this. further argument is wasted energy and fodder for scaring away more newbies.
22:54:41 <djahandarie> Perhaps here is the break in reasoning: "Java interfaces serve the same function in Java as type classes do in Haskell: restraining types." vs "Java interfaces can be fully implemented with data types in Haskell."
22:54:59 <dibblego> this is all aside from the lack of utility in teaching
22:55:02 <djahandarie> s/break in reasoning/reason for disagreement/
22:55:51 <dibblego> Scala's modelling of type-classes makes the distinction clearer
22:55:56 <mauke> heh. perhaps this is one of haskell's teaching antipatterns
22:56:07 <Rotaerk> my reasoning is "interfaces and type classes are conceptually related, in that they both describe abstractions for which implementations can be provided"
22:56:08 <djahandarie> I'd say both of the statements I just wrote are true. I guess an interesting point of discussion is what makes for a good teaching analogy.
22:56:11 <mauke> like "monads are for state"
22:56:23 <kmc> what a wankfest
22:56:26 <dibblego> djahandarie: "Num is like nothing you have seen before"
22:56:30 <Dashkal> I am so glad I dodged that one.  Monads were hard enough to grasp.
22:56:30 <Axman6> Rotaerk: that was exactly my point
22:56:51 <Axman6> Rotaerk: and if that is what interfaces are used for in java, then what i said was completely correct
22:56:59 <djahandarie> kmc, you saw this coming, why are you still here? ;)
22:57:12 * shaleh is looking for guidance on a JSON library. I hear AESON is nice but I could use a decent example
22:57:19 <dibblego> I'll stop, carry on with that one
22:57:27 <Rotaerk> it doesn't mean they are equivalent, because there is a lot more to them, but that is one, abstract, role that they both serve
22:57:35 <mauke> perl version: "perl automatically flattens nested lists"; C version: "the name of an array is a pointer to its first element" or perhaps "an array decays to a pointer when passed to a function"
22:58:47 <mauke> and that's it for this week's "teaching obstacles"
22:59:51 * djahandarie turns off the TV and goes to bed
22:59:57 <Rotaerk> of course, I never said it was wise to bring up the similarity when teaching someone :P
23:02:11 <Yvemath> How to quit from ">" prompt in GHCI, after getting an error @ "Prelude>" prompt. target 'filename' is not a modulename or source file.
23:02:37 <Axman6> Yvemath: :quit
23:02:47 <mauke> end-of-file is a good thing to know in many situations
23:02:57 <mauke> ^D on unix, ^Z <enter> on windows
23:03:16 <Nereid> or :quit or :q
23:03:21 <Nereid> ;u
23:04:01 <Yvemath> mauke: Didnt knew it required EOF -there :-) Thought i had to switch prompts.
23:04:10 <Yvemath> thanks, though.
23:04:49 <mauke> oh, I didn't even notice the different prompts
23:04:56 <mauke> mine is fixed at "*> "
23:06:31 <jre2> thoughts on a cool name relating to morphisms?
23:06:45 <mauke> POWER RANGERS
23:07:20 <jre2> mauke: hmm, they /do/ morph...
23:08:44 <Dashkal> That reminds me.  Given a data type Person = Person { name: String, age:  Int }, what would you expect a function withAge :: Person -> Int -> Person to do?  (Checking if this possible convention is intuitive).
23:09:26 <shachaf> Dashkal: Given the name and type, it's kind of obvious.
23:09:26 <mauke> withAge p i = p{ age = i }
23:09:42 <jre2> Dashkal: I'd assume 'withAge' would set age or filter by age. so given the type it's clear
23:09:55 <Dashkal> Good, it's as obvious as I'd hoped then.
23:10:39 <Dashkal> The actual context is I'm writing in scala some wrappers for some mutable java classes.  The greater goal being to provide an honest and pure api over this monstrisity.
23:10:49 <Dashkal> And I'd like to reduce all the IO everywhere.
23:10:59 <dibblego> Dashkal: scalaz.Lens
23:11:28 <Dashkal> dibblego: mmm, I should look into that.  I've been seeing discussion of it lately, but I haven't been able to follow.
23:11:58 <Dashkal> But for that matter, I have no idea how to use IORef, so I have a ways to go yet.
23:12:11 <dibblego> like Scala var but with type-checking
23:12:28 <dibblego> scalaz.effects.IORef by the way
23:12:43 <Dashkal> at least on the version I had, I could find no way to create one.
23:13:10 <Dashkal> where's my a -> IO (IORef a)?
23:14:10 <dibblego> newIORef(7): IORef[Int]
23:14:36 <Dashkal> where is newIORef?
23:14:43 <dibblego> package scalaz.effects
23:14:56 <Dashkal> There it is!
23:15:03 <Dashkal> BLoddy package objects.  Must look into those.  Danke
23:15:50 <dibblego> newIORef(7).[IO]: IO[IORef[Int]}
23:15:52 <dibblego> newIORef(7).[IO]: IO[IORef[Int]]
23:16:09 <Axman6> what's the z for in scalaz...
23:16:18 <dibblego> because I can't think up names
23:16:21 <Axman6> heh
23:16:25 <mauke> zygohistomorphic prepromorphism
23:16:33 <Dashkal> Scalaz documentation is annoying to search.  I got pampered by hoogle.
23:16:34 <dibblego> what mauke said
23:16:58 <Dashkal> On that note, ""?
23:17:03 <dibblego> @type pure
23:17:04 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
23:17:09 <dibblego> =pure
23:17:23 <mauke>  is Monad return
23:17:36 <Dashkal> How do I say that symbol?
23:17:57 <dibblego> "lift zero" :)
23:18:08 <mauke> U+03B7 (ce b7): GREEK SMALL LETTER ETA []
23:18:46 <Dashkal> lower case eta, ok.  I have trouble associating symbols to concepts.
23:19:14 <Dashkal> My memory isn't very good.  Frustrating.
23:19:37 <dibblego> use .pure if you like, it's alaised
23:20:16 * mauke pronounces it the french way
23:20:33 <Dashkal> Actually, I can't follow why it's there.  newIORef (a: => A) : IO[IORef[A]].  To my eyes, newIORef(7).pure[IO] would give me an IO[IO[IORef[Int]]]
23:21:09 <dibblego> you're right sorry, take it back
23:21:18 <Dashkal> oh ok, not insane then.  all good.
23:21:23 <mauke> :t return (newIORef 7)
23:21:24 <lambdabot> Not in scope: `newIORef'
23:21:29 <mauke> pfft
23:21:43 <Dashkal> It's frustratingly difficult sometimes to see where I'm confused about the scala cruft and where I'm not grasping the concept.
23:21:53 <dibblego> that's why I don't use scala for teaching scala
23:21:56 <Dashkal> There's a reason I tend to do my design in Haskell :P
23:22:06 <dibblego> so do we all
23:22:10 * KirinDave grumbles
23:22:21 <KirinDave> I should stop trying to avoid State in my effort to keep this simple
23:22:32 <KirinDave> I am actually making this more complex by avoiding a transformer.
23:22:52 <dibblego> KirinDave: the point of transformers is to make it easier/simpler, instead of unwrap/unwrap/apply/wrap/wrap
23:23:19 <KirinDave> dibblego: This is my first haskell program that is not outrageously simple
23:23:29 <Dashkal> dibblego: For scalaz 7 have you improved the syntax for transformers any?
23:23:36 <dibblego> yes, a lot
23:23:45 <dibblego> I am working on iteratees at this moment
23:23:50 <Dashkal> Oh good.  I was sad when I had to cave and just build FB by hand.
23:23:54 <dibblego> maybe we should go to #scala
23:24:04 <Dashkal> Heh, and start a holy war there?
23:24:11 <dibblego> don't worry about them, ignore them
23:24:17 <dibblego> #haskell is for haskell
23:24:33 <mauke> I've written a parser monad and now I'm confused what a parser monad transformer would even look like
23:24:37 <Dashkal> I find it unfortuante that #haskell is often better for scala design than #scala.
23:24:54 <dibblego> it's just the way it rolls mate
23:25:03 <mauke> there's always #haskell-blah
23:26:03 <Dashkal> I usually just phrase my questions in haskell syntax and ask here anyway.  Works well.  Then I don't get told to use inheritence (actually, that's rare, but still).
23:27:15 <KirinDave> Please forgive me for askign such amateur questions but RWH isn't illuminating this for me right now.
23:27:42 <dibblego> KirinDave: maybe put together a small code sample that demonstrates your intention
23:27:43 <KirinDave> It's pretty tedious to type WriterT [String] State MyState ___
23:27:54 <KirinDave> But for each function the ___ is different.
23:27:54 <Dashkal> I promise not to bite.  Might give you something to google, but no biting :P
23:28:01 <kmc> type Foo a = WriterT [String] State MyState a
23:28:14 <KirinDave> Ahh rad, I shoulda realized type could take a parameter too
23:28:19 <KirinDave> I just never saw it used.
23:29:25 <kmc> it's not obvious that it can
23:29:46 <kmc> it makes sense, and there's no good reason not to allow it, but since when has that stopped people from putting restrictions in type systems?
23:29:55 <kmc> (plenty of examples of that in Haskell too)
23:30:27 <Dashkal> KirinDave: RWH will later go on to demonstrate how to accomplish it with a newtype as well.  The syntax is a little heavier when you do it that way, but it has the advantage of hiding the details.
23:41:15 <KirinDave> kmc: So I get an error I don't understand when i try to do that
23:41:59 <Dashkal> Please pastey the code and error.  That alone doesn't give us enough to help.
23:42:51 <Axman6> you probably want type Foo a = WriterT [String] (State MyState) a
23:42:56 <KirinDave> Oh
23:43:01 <KirinDave> Does the a go outside of the parens?
23:43:02 <KirinDave> http://hpaste.org/paste/46418/hummhs_annotation#p46420
23:43:16 <Axman6> State MyState is the monad you're wrapping
23:43:21 <KirinDave> No even that doesn't work.
23:43:25 <Axman6> KirinDave: yes
23:43:50 <Axman6> :t WriterT
23:43:51 <lambdabot> forall (m :: * -> *) a w. m (a, w) -> WriterT w m a
23:44:05 <KirinDave> Ahh there we go
23:44:07 <KirinDave> ty
23:44:14 <Dashkal> :k []
23:44:15 <lambdabot> * -> *
23:44:19 <Axman6> w is the [String], (State MyState) is the m there, and a is the return type
23:44:25 <Axman6> :t State
23:44:25 <lambdabot> Not in scope: data constructor `State'
23:44:27 <Axman6> bah
23:44:58 <KirinDave> Ha
23:45:01 <KirinDave> Okay I got it.
23:45:07 <Axman6> :t runState
23:45:07 <lambdabot> forall s a. State s a -> s -> (a, s)
23:45:22 <Axman6> there you can see that State s is the monad you're wrapping
23:46:12 <shachaf> (Except that it's a type synonym.)
23:46:15 <KirinDave> So if I put a WriterT on top of a State, how do I actually tell that to go?
23:46:35 * hackagebot web-mongrel2 0.0.3 - Bindings for the Mongrel2 web server.  http://hackage.haskell.org/package/web-mongrel2-0.0.3 (ClintMoore)
23:46:55 <KirinDave> runWriterT . runState seemed like the obvious choice?
23:48:08 <shachaf> Wouldn't it be the other way around?
23:49:16 <Dashkal> @unmtl WriterT [String] (StateT Int) a
23:49:16 <lambdabot> err: `StateT Int (a, [String])' is not applied to enough arguments.
23:49:53 <dibblego> @unmtl WriterT [String] (State Int) a
23:49:53 <lambdabot> Int -> (a, [String], Int)
23:50:17 <Dashkal> Yeah, realized a moment later I would have needed Identity to do it that way
23:51:12 <Dashkal> I seem to recall asking this a year ago but I can't remember the answer: Is there a way to compose monad transformers?  As in compose two transformers to make another transformer?
23:51:19 * Dashkal blinks
23:51:20 <Dashkal> Arrows
23:51:34 <dibblego> if I understand you correctly no, for Applicative, yes
23:51:41 <Dashkal> hmm
23:51:42 <dibblego> I have this demonstrated in Scala
23:51:51 <dibblego> http://blog.tmorris.net/monads-do-not-compose/
23:52:25 <hydo> ... and a hush falls over the channel...
23:52:28 <Dashkal> Not composing monads, composing monad transformers.  The idea is the end result would still have to be applied over a monad (like IO or Identity depending on what's being done) before use.
23:53:12 <dibblego> you mean (Monad m, Monad n) => m (n a) -> n (m a) ? no you need Traversable
23:54:01 <Dashkal> I want to take StateT s (ReaderT c) and get AppT s c
23:54:09 <Dashkal> I'm missing ms in there
23:54:35 <Dashkal> I want to take StateT s (ReaderT c m) and get AppT s c m
23:54:36 <dibblego> sure, for two specific monads
23:54:54 <Dashkal> So there's no "monad transformer" concept I can just compose.
23:55:11 <dibblego> there is MonadTrans with lift :: m a -> t m a
23:55:16 <dibblego> not sure if that helps you though
23:55:19 <Dashkal> :k StateT Int
23:55:20 <lambdabot> (* -> *) -> * -> *
23:55:29 <Dashkal> I want to compose things of that kind.
23:56:46 <Dashkal> The pattern that is layering transformers over the central monad seems like it should be abstractable somehow.
23:57:35 <aleator> Anyone know if I can use uniplate to unify or compare two structures?
23:57:53 <Yvemath> Okay. I dont understand the meaning of lazy :(. I have a feeling that it has to do with something like stopping an infinite loop/recursion or something.
23:58:21 <Dashkal> Yvemath: It means only that an expression will not be evaluated until it has to be.
23:59:03 <Dashkal> There's no special magic here.
23:59:12 <Yvemath> Dashkal: Hos is that lazy? Isnt that "optimal" ? We dont need to waste processing power until, we need something ?
23:59:43 <Yvemath> Dashkal: Sorry, if i am making this too far, i just want to be clear. :-)
23:59:49 <Yvemath> taking*
23:59:49 <Dashkal> Everything else comes from that simple concept.
23:59:56 <dibblego> Yvemath: consider a function call in Java, such as f(g(x), h(y))
