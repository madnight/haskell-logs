00:58:41 <develhevel> who can help me, cant install libClang with cabal, i bet the message: "cabal: cannot configure LibClang-0.0.9. It requires ffi -any" but i have installed libffi5 and libffi-dev
00:59:27 <Axman6> is that the haskell ffi?
00:59:49 <mauke> you didn't install ffi
01:00:22 <develhevel> what is the name if the haskell ffi? is it supportet with ghc6 (haskell plattform 2010.0.0.1)
01:00:35 <c_wraith> see, this is why debian's GHC support is awful
01:00:52 <poltak> Can you see the premade functions in Haskell's library? is it open?
01:01:19 <mauke> develhevel: looks like it's "ffi"
01:01:48 <Axman6> poltak: yes, it's all open source
01:01:59 <poltak> where do i find the source?
01:02:00 <Axman6> also, i think you probably mean GHC's library
01:02:09 <Axman6> @where ghc
01:02:10 <lambdabot> http://haskell.org/ghc
01:02:11 <poltak> yes, that's probably what I mean :P
01:02:33 <poltak> thank you very very much Axman6
01:02:35 <Axman6> you can see the default implementations for the standard prelude in the haskell 98 report i believe
01:04:26 <elliott> What's an appropriate package for immutable vectors of fixed but arbitrary length?
01:04:40 <elliott> That is, you cannot append to a vector or whatever, but there's one type for all sizes.
01:04:50 <napping> vector
01:04:54 <elliott> (The use-case is coordinate pairs of arbitrary dimensions.)
01:05:30 <elliott> napping: OK, thanks. Is a length-two vector approximately as efficient as a tuple, or is there some overhead?
01:05:30 <napping> just don't use the mutable ones
01:06:13 <napping> there's almost certainly a length, at least
01:06:22 <elliott> well, yes :)
01:06:28 <elliott> I meant time-wise more than space-wise.
01:06:44 <elliott> Oh, and I'm using these as Data.Map keys, so...
01:06:59 <elliott> (For large maps (thousands to millions of elements potentially).)
01:07:17 <napping> I expect it would be slower
01:07:51 <elliott> Well, certainly I'm not expecting total equivalence, but a large overhead would suck.
01:11:12 <napping> I haven't measured it
01:11:46 <napping> I'd expect an indirection and a bounds check worse than data Vec2 = Vec2 !Double !Double with unpacking
01:12:13 <napping> I think there's another cabal package with classes for small fixed-length vectors
01:12:19 <napping> not all in the same type, though
01:17:21 <elliott> napping: unfortunately I need them in the same type
01:17:24 <luite> elliott: is it based on vector?
01:17:29 <elliott> the dimensions used are determined at runtime
01:17:42 <elliott> luite: ?
01:18:04 <luite> I meant the vector package in hackage
01:19:36 <mm_freak> does anyone else have the problem that utf8-light compilation fails?
01:19:51 <luite> there's already a fixed-length vector package based on vector, vector-static, and another is the Vec package
01:19:59 <luite> both use type-level naturals to encode the length
01:21:07 <elliott> luigy: is what based on vector?
01:22:00 <luite> Vec isn't, but it has its own packed vectors for up to 4 dimensions
01:22:39 <elliott> sorry, luite
01:22:43 <elliott> is /what/ based on vector?
01:22:45 <elliott> are you asking the wrong person?
01:24:52 <luite> elliott: oh sorry I meant the package you were talking about initially. I was wondering why you made your own
01:25:30 <elliott> luite: Whaa? When did I say I made my own??
01:26:12 <luite> oooh
01:26:35 <luite> I thought you were asking how to name your own package, but instead you were asking which one to use?
01:27:05 <elliott> Yes :)
01:27:25 <luite> rigth, then Vec probably, since vector-static isn't really in usable state at the moment :)
01:27:46 <luite> you can add more unpacked instances for Vec if you need better performance in higher dimensions than 4
01:27:51 <elliott> And if -static is any indication I can't use it anyway (implying it has different types?)
01:28:00 <elliott> And performance in >four dimensions isn't important; two is the most important.
01:28:29 <napping> why can't you use different types?
01:29:00 <luite> well in both Vec and vector-static, a 4-dimensional and a 2-dimensional vector have different types
01:29:03 <elliott> napping: because the dimensions are determined at runtime.
01:29:49 <napping> You can make types at runtime
01:30:36 <tibbe> argh, why can't standard haskell arrays be zero indexed
01:30:43 <tibbe> instead of this horrible Ix class
01:30:59 <ezyang> They can be zero indexed...
01:31:04 <elliott> napping: What do you mean by that?
01:31:08 <napping> You'd just have to make the part that depends on vector length parameterized over a typeclass of all the operations you need
01:31:09 <ezyang> array (0, n) ...
01:31:22 <elliott> napping: Um, there is no way to make a program use a different type depending on some user input.
01:31:28 <elliott> That is the very definition of dependent typing right there.
01:31:56 <mauke> but you can
01:31:57 <luite> elliott: they use a special type-level naturals type to convert a value to a type
01:32:02 <napping> if userInput then (myPolymorphicLib (0 :: Int) else (myPolymorphicLib (0 :: Word32)
01:32:12 <elliott> napping: I am to enumerate every single natural number?
01:32:16 <Nereid> napping: what type would that be
01:32:20 <napping> No, use polymorphic recursion
01:32:27 <Nereid> =/
01:32:30 <elliott> Would that actually work here?
01:32:50 <napping> given data Z, data S a, class TypeNat t, instance TypeNat Z, instance TypeNat a => TypeNat (S a)
01:32:52 <tibbe> ezyang, as in zero indexed and easy to use
01:32:59 <elliott> napping: Yes, yes, I've done type-level nats before.
01:33:12 <napping> buildNat :: Integer -> (TypeNat t => t -> r) -> r
01:34:07 <napping> buildNat 0 f = f (undefined :: Z); buildNat n f = buildNat (n-1) (f . (undefined :: forall a . a -> S a))
01:34:21 <luite> in vector-static, you'd find such a type in the fromList function for example
01:34:22 <elliott> Hmm.
01:34:59 <napping> You'd probably want to hardcode the first few dimenions, so you could {-# SPECIALIZE #-} them, but you could get the tail with something like that
01:35:38 <napping> Probably easiest to use Vector if it's small and fast enough
01:35:54 <napping> but you certainly can assemble types to order at runtime
01:36:11 <ksf> if in doubt, use overkill amounts of TH
01:36:17 <luite> vector-static does use a more complicated natural type
01:36:32 <luite> for more efficient arithmetic
01:36:48 <luite> with some unsafeCoerce added to the mix ;p
01:37:01 <MasseR> \o/ cabal-dev support for vim <3
01:37:18 <Nereid> \o/ * support for vim
01:37:21 <MasseR> :make works with correct -package-conf
01:37:48 <elliott> luite: Type-level binary? :)
01:38:28 <luite> an extension of that yes
01:41:16 <luite> oh hmm, looks like the vector-static package on hackage doesn't have binary
01:41:45 <luite> I might have confused it with some experimental version or another package altogether
01:41:51 <ketil> unsafeAt :: (IArray a e, Ix i) => a i e -> Int -> e  -- <- why isn't it ... => a i e -> i -> e?
01:43:06 <ketil> I'm using Word8 to index a small array, but presumably it will be faster to use Int?  Now I can use 'unsafeAt' but it requires an extra 'fromIntegral' in there.
01:43:11 * ketil is puzzled.
01:43:26 <ketil> Maybe just use Int to index.
01:44:30 <ksf> depends on your cpu, I'd say.
01:44:59 <ksf> x86's take 32 or 64 bit offsets for their addressing ops.
01:45:47 <ksf> so, yes, use Int, that's utterly likely to be the machine-size integer in any half-way performant implementation.
01:47:43 <develhevel> how can i get ghc ffi? i'm runing haskell platform 2011.2.0.0 on fedora core but ffi is missing
01:47:56 <ksf> -XFFI
01:48:13 <develhevel> ksf, what is that?
01:48:23 <ksf> a switch to the compiler to enable the ffi
01:48:45 <cpa> Hi there! I'm having a problem with happy and associativity
01:48:58 <ksf> or, wait, isn't ghc 7 supposed to use haskell2010 by default?
01:49:13 <cpa> I'd like to parse the expression x y z as (x y) z but I have no clue how to do that
01:49:26 <develhevel> ksf, im not using the compiler, i use cabal to install libClang and i get "cabal: cannot configure LibClang-0.0.9. It requires ffi -any"
01:49:35 <ksf> anyway, if your fedora ships the platform without the ffi libs, fedora isn't shipping the platform but something else.
01:50:33 <develhevel> do you know a platform which shipps it? and have the newest haskell plattform available
01:50:52 <ksf> well, it means that your ghc install is incomplete, or broken.
01:50:57 <aleator> develhevel: What happens if you say ghc-pkg check?
01:51:05 <quicksilver> I find it unlikely that the fedora haskell platform does not contain ffi
01:51:15 <quicksilver> I find it more likely that there is some package database confusion going on.
01:51:34 <develhevel> quicksilver, which linux distro have it?
01:51:58 <develhevel> aleator, it happens nothing, no output
01:52:05 <ksf> hmm. I need to enable --global to see the ffi lib
01:52:21 <ksf> ...but that's due to nixos using ghc-pkg in a broken way.
01:53:02 <quicksilver> I suspect develhevel has a related problem to that, ksf
01:53:14 <quicksilver> locally installed pacakges with version conflicts with global ones, or something
01:53:50 <ksf> then let me elaborate: nixos calls ghc-pkg through a wrapper that passes a gazillion of --package-conf= flags
01:54:16 <aleator> develhevel: how about doing cabal install libclang -v3 ?
01:55:23 <ksf> nixos' haskell support really needs a rewrite, and it doesn't help that an existing sensible implementation needs a branched version of nix
01:55:39 <develhevel> can anybody say me a linux distro where haskell works perfekt from the packages without compiling it by hand? WITH ffi
01:55:43 <develhevel> aleator, same problem
01:55:45 <ksf> (which I failed to locate anywhere. I did find a gitweb interface to it, but not the repo itself...)
01:56:04 <ksf> erm... gentoo *ducks*
01:56:19 <quicksilver> this might not be a fedora problem.
01:56:22 <ksf> develhevel: if in doubt, just download the platform and use it from your $HOME
01:56:27 <quicksilver> it might be a problem with your locally installed packages
01:56:39 <quicksilver> pasting the output of ghc-pkg list might be helpful
01:56:47 <quicksilver> to hpaste.org or similar.
01:58:44 <develhevel> here it is: http://hpaste.org/46642/develhevel
02:00:09 <develhevel> ksf, you mean download ghc and the platform and then make it?
02:00:21 <quicksilver> no, he just means download a platform binary
02:00:24 <quicksilver> I imagine.
02:00:35 <ksf> as quicksilver said
02:00:50 <ksf> it comes with ghc
02:01:20 <develhevel> where i get a platform binary? only find ghc7 binary for linux on the haskell side
02:01:21 <develhevel> site
02:01:40 <ksf> http://hackage.haskell.org/platform/
02:03:18 <ksf> oh, wait, there are no non-distro platform binaries.
02:03:40 <ksf> building the libraries is quite fast, though.
02:04:02 <ksf> you can just get ghc and cabal-install and work from there.
02:04:12 <develhevel> ksf, this is what i mean :) just downloading it
02:11:35 <inetic> hi, what is the name of the form expressions like (foo + bar) are in? Im guessing it's not WHNF because it can be reduced to just single number, but it can't be reduced straight a way because values of foo and bar are not yet known. also this seems like a case when strict evaluation order has to take place (first eval foo and bar, then (foo + bar)?
02:11:55 <Nereid> (+) is strict, yes
02:11:58 <Nereid> for numbers
02:12:05 <Nereid> well
02:12:11 <Nereid> depends on the type
02:12:18 <pastorn> Nereid: not for the standard types
02:12:27 <Nereid> Int?
02:12:32 <pastorn> Nereid: with some -XMagicHash it's strict
02:12:38 <pastorn> but not for Int, Float, Double ...
02:12:47 <Nereid> :/
02:13:02 <pastorn> Nereid: try making a tail recursive verison of 'sum' and run it on [1.100000]
02:13:16 <Saizan> (+) is strict for Int, Float, Double, ..
02:13:33 <pastorn> Saizan: then why does my tail recursive function break?
02:13:41 <Axman6> it shouldn't...
02:14:03 <Guest49047> hi! why seq (print "hi ") (print "there") prints only there?
02:14:16 <Saizan> pastorn: if you don't demand the result of a function there's still no need to evaluate the argument, even if the function is strict
02:14:26 <Lemmih> inetic: Closure? Thunk? Unevaluated sniplet?
02:14:34 <Guest49047> doesn't it eval the first arg?
02:14:42 <Axman6> > let s xs = f xs 0 where f [] a = a; f (x:xs) a = f xs (x+a) in show (s [1..100000])
02:14:43 <lambdabot>   "5000050000"
02:14:44 <Saizan> Guest49047: because evaluation of IO () values doesn't imply the execution of their side-effects
02:14:47 <Axman6> > let s xs = f xs 0 where f [] a = a; f (x:xs) a = f xs (x+a) in show (s [1..10000000])
02:14:53 <lambdabot>   "*Exception: mueval-core: signal: 15
02:14:55 <inetic> Lemmih, thanks
02:15:16 <ion> guest49047: print doesn‚Äôt print anything, it just results in a promise to do a side effect which you may choose to assign to main in order to have that executed.
02:15:18 <inetic> pastorn, Nereid so what is the rule that says when to use strict and when lazy evaluation that haskell uses? or is it hard coded per function?
02:15:30 <Saizan> Guest49047: printh "hi " >> print "there" will print both, but i suspect you want putStr rather than print
02:16:15 <Axman6> Guest49047: there is a difference between evaluation and execution, seq evaluates things, it does not execute IO.
02:16:17 <Nereid> inetic: "lazy" and "non-strict" are different things
02:16:26 <ectospasm> I cant seem to figure out how to append a value to a list.  I want the list [1,2,3,4,5,67,8,9,0], but everything I try like concat [1 .. 9] [0] won't give it to me.
02:16:38 <ectospasm> s/67/6,7/
02:16:39 <ion> ++
02:16:56 <Saizan> > [1..9] ++ [0]
02:17:03 <ectospasm> Ah, OK
02:17:03 <lambdabot>   mueval: ExitFailure 1
02:17:04 <lambdabot>  mueval-core: Time limit exceeded
02:17:05 <ectospasm> Thanks
02:17:14 <Guest49047> ok. Thanks guys.
02:17:18 <ectospasm> ion, Saizan ^^
02:17:27 <pastorn> why does sum' [1..10000000] consume massive amounts of memory?
02:17:28 <Saizan> np
02:17:44 <ion> :t concat
02:17:44 <Saizan> pastorn: what is sum' here?
02:17:46 <lambdabot> forall a. [[a]] -> [a]
02:17:53 <ion> > concat [[1..9],[0]]
02:17:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,0]
02:18:12 <ion> Always look at the type.
02:18:16 <pastorn> sum' xs = sum'' xs 0
02:18:18 <pastorn>   where sum'' [] acc = acc; sum'' (x:xs) acc = sum'' xs (acc+x)
02:18:22 <Nereid> inetic: haskell functions are lazy by default. but things like addition of integers
02:18:29 <Nereid> have to be strict
02:18:31 <ectospasm> ion: thanks again
02:18:42 <Nereid> strict means: passing in undefined returns undefined
02:18:48 <ion> :t (++) -- for the record
02:18:49 <lambdabot> forall m. (Monoid m) => m -> m -> m
02:18:58 <ion> :t (Prelude.++)
02:18:59 <lambdabot> forall a. [a] -> [a] -> [a]
02:19:02 <inetic> Nereid, aha, well, what I'm really looking for is a pseudo algorithm that says how Haskell evaluates stuff. I think I understand how term rewriting works, and how strict evaluation works, but it seems sometimes they need to be intermixed (like in the case of +)
02:19:08 <Nereid> so a + b can't be evaluated without a and b is evaluated.
02:19:13 <Axman6> > let s xs = f xs 0 where f [] a = a; f (x:xs) !a = f xs (x+a) in show (s [1..10000000])
02:19:16 <lambdabot>   mueval-core: Time limit exceeded
02:19:18 <Saizan> pastorn: because you're accumulating a big thunk in 'acc' as you recurse, the fact that (+) is strict doesn't automatically mean any applycation of it gets evaluated eagerly
02:19:23 <Nereid> if a and b are Ints.
02:19:26 <Nereid> because Int is flat.
02:19:34 <pastorn> Saizan: say what?
02:19:34 <Nereid> you can't have a partially defined integer
02:19:59 <Nereid> an Int value is either undefined or totally defined
02:20:10 <Saizan> pastorn: f is strict if and only if f _|_ = _|_
02:20:28 <Nereid> that's the definition of strict, yes
02:20:36 <pastorn> Saizan: how does it know?
02:20:49 <Saizan> pastorn: how does it know what?
02:20:52 <pastorn> Saizan: maybe my calling to _|_ could be done runtime
02:21:07 <Nereid> pastorn: if you don't want the heap to blow up, strategically apply seq
02:21:15 <Nereid> see http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
02:21:18 <pastorn> Nereid: after each call?
02:21:20 <Nereid> in particular, foldl vs foldl'
02:21:36 <erus`> whats _|_?
02:21:42 <Axman6> bottom
02:21:43 <Nereid> _|_ is bottom
02:21:47 <Nereid> it represents an undefined value.
02:21:54 <erus`> it looks like a bottom
02:22:01 <Axman6> undefined ~= _|_
02:22:06 <pastorn> erus`: if you're sloppe you could equate it to undefined/error
02:22:08 <pastorn> *sloppy
02:22:18 <erus`> > let f _ = _ in f 3
02:22:19 <lambdabot>   Pattern syntax in expression context: _
02:22:24 <Nereid> undefined means "it could be anything"
02:22:33 <Nereid> > let f x = x in f 3
02:22:34 <lambdabot>   3
02:22:40 <pastorn> erus`: but if you want to be mathematically correct you shouldn't
02:22:42 <Saizan> it doesn't mean it could be anything.
02:22:53 <Nereid> Saizan: it does, for some definition of "could be"
02:22:58 <erus`> i cant see the use for it
02:23:00 <Saizan> ah well.
02:23:06 <erus`> but i havnt used haskell for long
02:23:15 <pastorn> erus`: you haven't used 'error'?
02:23:22 <quicksilver> Nereid: no, it doesn't.
02:23:27 <pastorn> > error "sorry dave, i can't let you do that"
02:23:27 <lambdabot>   *Exception: sorry dave, i can't let you do that
02:23:28 <quicksilver> Nereid: it means it definitely isn't anything.
02:23:34 <ion> ‚ä• is bottom, _|_ is an ugly bottom.
02:23:35 <Nereid> as I said,
02:23:39 <Axman6> f x = f x is also = _|_
02:23:40 <Nereid> depends on the definition of "could be"
02:23:43 <Saizan> erus`: it's not an haskell construct, it's just a notation used for non-terminating computations or exceptions when talking about haskell's semantics
02:24:10 <pastorn> Axman6: i remember the good old days when using that code actually meant the CPU getting hot
02:24:14 <quicksilver> Nereid: sure. Define "could be" as "definitely isn't" ;)
02:24:26 <Nereid> or "is less defined than"
02:24:55 <Axman6> > let f x = f x in f 1
02:24:59 <lambdabot>   mueval-core: Time limit exceeded
02:25:02 <Axman6> :t let f x = f x in f
02:25:03 <lambdabot> forall t t1. t -> t1
02:25:32 <quicksilver> Nereid: right. But "less defined than" isn't much like "could be"
02:26:05 <Axman6> :t let f x = f x in f 1
02:26:06 <lambdabot> forall t. t
02:26:39 <Nereid> quicksilver: when I say it could be anything, I mean it doesn't contain any semantic information.
02:26:41 <Nereid> :/
02:27:00 <erus`> > fromJust $ Just $ fromJust $ Just $ fromJust $ Just "Hello"
02:27:00 <pastorn> > fix error
02:27:01 <lambdabot>   "Hello"
02:27:01 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
02:29:59 <Axman6> :t fromJust . Just
02:30:00 <lambdabot> forall a. a -> a
02:30:20 <ion> > fromJust . Just . fromJust . pure . fromJust . return $ "Hello"
02:30:23 <lambdabot>   "Hello"
02:31:34 <Nereid> :t point
02:31:35 <lambdabot> Not in scope: `point'
02:31:38 <Nereid> heh
02:31:53 <ion> @hoogle a -> m a
02:31:54 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> a -> m a
02:31:54 <lambdabot> Prelude return :: Monad m => a -> m a
02:31:54 <lambdabot> Control.Monad return :: Monad m => a -> m a
02:31:55 <erus`> @hoogle pure
02:31:56 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
02:32:01 <shachaf> > fr–æmJust . Just $ "Hello"
02:32:02 <lambdabot>   "Hi!"
02:32:49 <erus`> has anyone written a song about monads?
02:32:57 <Nereid> probably
02:33:06 <ion> It rhymes with gonads
02:34:10 <Axman6> :t fro
02:34:11 <lambdabot> Not in scope: `fro'
02:36:01 <shachaf> > "fro"
02:36:01 <lambdabot>   "fro"
02:36:06 <develhevel> had a disconnect trying to install hakslepp plattform now with the ghc 7.0.3 binary
02:36:36 <ion> hakslepp?
02:36:44 <develhevel> haskell
02:37:17 <Axman6> close enough
02:44:26 <develhevel> when i try to install haskell plattform i get "The OpenGL C library is required" do somebody know how the package is called in debian or something?
02:46:14 <Ke> mesa perhaps
02:46:33 <osfameron> develhevel: googling "site:packages.debian.org opengl" suggests libqt4-opengl and a handful of others
02:46:51 <fizruk> libgl1-mesa-dev is what i have installed
02:47:04 <Ke> that sounds about right
02:47:15 <osfameron> ah yes, the Qt package depends on various mesa ones
02:50:21 <develhevel> hm, dont find a fedora core equevalent
02:51:53 <develhevel> mesa-libGL-devel perhaps?
02:53:31 <develhevel> no
02:56:04 <luite> mesa-common-dev has the /usr/include/GL/gl.h file
02:57:14 <pastorn> develhevel: you should get your opengl dependencies when you install your video driver
03:01:43 <frerich2> Ooh, LibClang package... finally an opporturnity for me to combine the pleasant (writing Haskell tools which work on a tree) with the useful (analyzing C++ code I have to write in my day job for errors)
03:02:43 <erus`> I wish i learned haskell at college. They tried to teach me vb6! I allready knew C++ quite well and they were teaching me how to make a bllody single function calculator...
03:09:39 <Wooga> @src reads
03:09:39 <lambdabot> reads = readsPrec minPrec
03:09:48 <Wooga> hmm
03:10:06 <Wooga> is there cases when reads returns list with more then one element?
03:10:23 <merijn> :t reads
03:10:23 <lambdabot> forall a. (Read a) => String -> [(a, String)]
03:10:36 <quicksilver> Wooga: no, not with any of the built-in instances
03:10:47 <quicksilver> the notional idea is that it's for ambiguous parses
03:10:50 <Wooga> quicksilver: then why it uses list instead of maybe?
03:10:55 <quicksilver> but it's unused.
03:11:04 <Wooga> eh?
03:11:27 <Wooga> ah
03:11:54 <Wooga> thanks now i got it
03:19:23 <frerich2> To the more experienced Haskell guys here: how do you structure your Haskell source files? Do the toplevel functions (e.g. what a module exports) come first and then the "plumbing"? Or is it the other way round? I just noticed that I always do it as I do in languages where you first have to define a function before you can use it (e.g. plumbing first) but maybe doing it the other way round would actually be nicer. Or at least more common for Haskell.
03:20:28 <frerich2> I just know that I find it a bit annoying if people have funny orders when declaring methods of a C++ class (e.g. protected stuff first, then private, then public). So I guess the order of method definitions can have an influence on how comprehensible the program is if you read it from top to bottom.
03:26:02 <Saizan> i think what matters most is to have datatype declarations at the top
03:27:11 <quicksilver> I tend to start with building blocks and build up.
03:27:24 <quicksilver> So, datatype first, then "simple" functions with work diretly on those types
03:27:38 <quicksilver> and the more complex "algorithmic" or "problem-solving" functiosn which use the simple ones.
03:27:45 <quicksilver> I don't know if that's the best way or not :)
03:29:29 <Saizan> there are some helper functions that aren't simple nor interestingly algorithmic, i'd probably put them just after the function you're defining them for
03:29:55 <quicksilver> I do that sometimes too
03:30:15 <quicksilver> the idea is that "indepenetly interesting" functions go first
03:30:18 <quicksilver> (they are building blogs)
03:30:28 <quicksilver> but "boring helper" functions go afterwards
03:30:40 <quicksilver> they have no general relevance, they're just helpers for a particular function.
03:30:49 <quicksilver> I don't think that's entirely consistent but it seems to make sense to me.
03:34:46 <zygoloid> some projects seem to move the more complex stuff to a separate module. that can be quite readable.
03:35:10 <quicksilver> yes, at some point that makes sensee
03:36:06 <zygoloid> it also lets you prove your complex stuff can't break invariants, if you're careful what you export :)
04:10:02 <kstt> Hello. Question to HDBC-postgresql users : we are designing an HTTP server that uses Postgresql, through HDBC driver, as the main storage backend. At the moment, whenever the TCP connection is broken, at subsequent queries will fail with runtime exception. What I would like is to perform a "reconnect" operation, so that the connection object works again.
04:10:48 <roconnor> > asin (1/3) :: CReal
04:10:49 <lambdabot>   0.3398369094541219370963925133917640663882
04:10:57 <roconnor> > acos (1/3) :: CReal
04:10:58 <lambdabot>   1.2309594173407746821349291782479873757103
04:11:31 <kstt> Without such a "reconnect" operation, I'm doomed to wrap the connection into an MVar, so that I can replace it with a new one in case of failure. That would work, but would be inconvenient.
04:11:54 <`0660> sounds like you would need some sort of connection pool
04:20:36 <kstt> `0660: hi, I should not need pooling as the driver is thread-safe
04:21:00 <kstt> What I really want is a way to re-establish my connection in place.
04:21:44 <kstt> without creating a new connection. For HDBC, that boils down to performing a connection with its current settings.
04:25:58 <`0660> kstt, I don't know enough to help you with that :/
04:27:41 <develhevel> do someone know, when a cabal package need LLVM-config, when i install the clang binarys from llvm page, that it will fix this?
04:53:19 <develhevel> when i run runhaskell foo.hs and want to set te path of a used library, how can i make it? runhaskell foo.hs -L/my/lib/path ?
05:08:10 <dankna> when I -ddump-simpl-stats, where does the output go?  I see none :/
05:16:15 <fryguybob> dankna: stdout
05:16:21 <dankna> huh
05:16:36 <dankna> oh
05:16:45 <dankna> apparently one of the other flags I had isn't compatible with that
05:16:49 <dankna> I took them all out and got output
05:16:50 <dankna> thanks
05:21:02 <blackmirroxx> hello
05:24:10 <tibbe> @src unlines
05:24:10 <lambdabot> unlines = concatMap (++ "\n")
05:24:20 <ion> @src lines
05:24:20 <lambdabot> Source not found. My brain just exploded
05:24:24 <dankna> ohhhh it wasn't incompatible, it was just that adding the debug option didn't force a recompilation haha
05:26:17 <develhevel> when i run runhaskell foo.hs and want to set te path of a used library, how can i make it? runhaskell foo.hs -L/my/lib/path ?
05:26:43 <dankna> not familiar with runhaskell, sorry, I always compile my code
05:27:05 <ben> me either, at a guess, put the -L before the file name
05:37:33 <notyy> hello,I have spent hours on haskellwiki, but can't find a simple library to play mp3 or wav file...
05:37:52 <notyy> how can I play sound in my app
05:39:05 <ion> I‚Äôd probably use GStreamer. Dunno about how nice the Haskell library is or whether it‚Äôs feasible at all on e.g. Windows‚Ñ¢.
05:39:30 <Martty> i bet there's a lib just called 'hmp3'
05:41:03 <notyy> there is  'hmp3',but it's an app
05:41:18 <Martty> can't you grab the mp3 lib off it?
05:42:04 <notyy> alright,I no other choice, I will study it's source code
05:42:38 <MasseR> http://users.utu.fi/machra//posts/2011-05-13-environment.html comments?
05:44:37 <notyy> and thanks to ion,GStreamer seems to be an option too
06:04:15 <m4XXX> hello.
06:04:54 <mekeor> m4XXX: hello
06:05:42 <m4XXX> i want something that creates "(a -> b) -> [b]" but i get only  "a -> b -> [b]"
06:06:34 <m4XXX> is it possible to make a function like that ?
06:06:35 <bxc> you want a function with that signature?
06:06:40 <m4XXX> yes
06:07:07 <m4XXX> ive made that: Prelude> let f = (\a (b) -> [b])
06:07:07 <m4XXX> Prelude> :t f
06:07:07 <m4XXX> f :: t -> t1 -> [t1]
06:07:11 <bxc> i give you a function a->b and you give me a list?
06:07:16 <flux> m4xxx, I don't see how you would possibly have such a function..
06:07:35 <m4XXX> isnt it possible to make a function like that ?
06:07:42 <bxc> well you need to get an A from somwhere
06:07:45 <bxc> a value of a
06:07:56 <flux> let's say I give you a function that converts strings to integers.
06:07:56 <bxc> and as A is free, you can't just magic one up
06:08:01 <flux> now give me back a list of integers.
06:08:03 <flux> how does that work?
06:08:09 <opqdonut_> (also "const []" can have that type)
06:08:21 <flux> right, forgot the empty list :)
06:08:21 <bxc> flux: except also in your definition you aren't allowed to use the fact that its a string...
06:08:21 <opqdonut_> (sorry)
06:08:36 <flux> bxc, well, I was about to add that then do it again, but for any types
06:08:36 <bxc> flux: so even harder
06:08:41 <bxc> flux: ok
06:08:50 <m4XXX> hmm
06:09:22 <bxc> m4XXX: you could make  (a->b) -> a -> [b]
06:09:34 <m4XXX> ok
06:09:43 <m4XXX> is that the same (at the end) ?
06:09:48 <bxc> eg q f a = map f (repeat a)
06:09:52 <bxc> or something like that
06:09:58 <opqdonut_> m4XXX: you can of course have a function of type "[a] -> (a -> b) -> [b]", which when given a list of type [X] returns a function of type "(X->b) -> [b]"
06:10:03 <opqdonut_> but now X is a concrete type
06:10:11 <opqdonut_> :t flip map
06:10:11 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
06:10:14 <djahandarie> m4XXX, the same as what? You haven't given us anything but a type signature.
06:10:20 <develhevel> have a problem when i add something to PATH end then close terminal and reopen it, it is lost, how can i save it?
06:10:48 <bxc> develhevel: make a script that you run whenever you open your terminals
06:11:00 <bxc> develhevel: if you're under unix, put it in .bashrc
06:11:04 <bxc> or .bash_profile
06:11:20 <develhevel> bxc: sry i thought that i'm in #linux
06:11:26 <develhevel> bxc: but thx
06:11:37 <bxc> develhevel: prolly get similar answer there?
06:11:38 <bxc> ;)
06:11:40 <m4XXX> opqdonut: ive ment the output but its ok now^^
06:12:28 <bxc> :t \f a -> map f (repeat a)
06:12:29 <lambdabot> forall a b. (a -> b) -> a -> [b]
06:13:04 <bxc> m4XXX: various options, btu you need at least one 'a' value.
06:13:45 <m4XXX> ok so (a ->b) --> [b] wont work like that^^
06:14:01 <bxc> well you need to return a list of b values
06:14:06 <bxc> how are you going to make one of those?
06:14:25 <bxc> [] is the only choice
06:14:30 <m4XXX> yea..
06:15:05 <bxc> but that's just const, specialised, I think.
06:15:23 <erus`> > [..1]
06:15:23 <lambdabot>   <no location info>: parse error on input `..'
06:15:28 <m4XXX> ty guys ^^
06:16:55 <develhevel> someone here who has libClang working? always get in [13 of 13] the error: "implicit declaration of function ëclang_toggleCrashRecoveryí" and then i try to compile some Clang prog i get: "/home/foo/.cabal/lib/LibClang-0.0.9/ghc-7.0.3/libHSLibClang-0.0.9.a(FFI_stub_ffi.o): In function `prim_toggleCrashRecovery'"
06:17:08 <Jonno_FTW> > [False..True]
06:17:09 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
06:17:29 <djahandarie> Huh?
06:17:55 <djahandarie> Ah, lack of space I think
06:34:23 <flinstone> hi, howto use haskell with android?
06:34:47 <hpc> flinstone: with great difficulty
06:35:04 <hpc> flinstone: there's a project going to get GHC on the iphone; not sure if that's done yet
06:35:05 <flinstone> hpc, i agree with y
06:35:16 <hpc> there's no android version that i know of
06:35:23 <flinstone> (
06:35:56 <flinstone> what about dsl, which write for android api,sdk?
06:36:10 <flinstone> dsl or codegeneration
06:36:13 <hpc> that would work
06:36:38 <hpc> it's perhaps more likely for that lib to already exist than a full android ghc
06:38:37 <flinstone> hpc, do y know good haskell ide?
06:38:43 <flinstone> i use leksah
06:39:34 <hpc> i just use a text editor
06:41:39 <mjrosenb> @hoogle Bool -> a -> Maybe a
06:41:39 <lambdabot> Control.Exception assert :: Bool -> a -> a
06:41:39 <lambdabot> Control.OldException assert :: Bool -> a -> a
06:41:39 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
06:42:04 <mjrosenb> err, none of those can be unified with my search...
06:42:11 <argiopeweb> flinstone: Emacs
06:45:12 <ski> @type \b a -> guard b >> return a
06:45:12 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
06:45:48 <mjrosenb> ski: yeah, i just started using that
06:45:53 <mjrosenb> well, minus the return
06:46:33 <ski> @type \b a -> [a | b]  -- i was first thinking of this, but you wanted `Maybe' ..
06:46:34 <lambdabot> forall t. Bool -> t -> [t]
06:46:39 <mjrosenb> i realize that this does not have the type that i asked for, but it seems to be working
06:46:56 <ski> well, it's a generalization
06:47:01 <ski> @type \b a -> guard b >> Just a
06:47:02 <lambdabot> forall b. Bool -> b -> Maybe b
06:47:18 <mjrosenb> woah, that is a neat trick.
06:48:04 <ski> (here monad comprehensions oculd be a win)
06:48:28 <ski> (.. or is that "monadic comprehensions" ?)
06:48:49 <ski> @undo [a | b]
06:48:49 <lambdabot> if b then [a] else []
06:49:02 <ski> @undo [a | ]
06:49:02 <lambdabot>  Parse error at "]" (column 6)
06:49:05 <ski> :/
06:50:03 <dankna> okay so in the correct channel this time
06:50:35 <argiopeweb> dankna: I bet that other channel had no clue what monads were.
06:50:54 <dankna> lol
06:50:55 <geheimdienst> so my coworker buddy is now testing an 80-core system, mysteriously acquired. any estimates how haskell would fare with that?
06:50:58 <dankna> it waws #haskell-blah
06:51:07 <dankna> geheimdienst, oooh, nifty
06:51:15 <argiopeweb> geheimdienst: Well?Poorly? Depends on the code? :P
06:51:18 <dankna> http://hpaste.org/46653/optimization_one_hopes -- this is a simple reduction that someone here helped me prepare of my more complicated simulator
06:51:27 <argiopeweb> I do want to know what type of system it is though.
06:51:31 <dankna> I can't do a heap profile on the reduction, it comes up with no datapoints for some reason
06:51:38 <Jafet> geheimdienst: isn't GC still stop-go?
06:51:57 <dankna> but a heap profile on the original program shows "triangles" - it allocates about 40M every half-second, then, presumably in response to the C front-end asking for the final result, it GCs most of it
06:52:11 <argiopeweb> Jafet: Yes, but it's parallelized now so it shouldn't be too bad.
06:52:15 <dankna> I'm spending most of my time in GC and therefore I have to fix the space leak to get acceptable performance
06:52:28 <argiopeweb> dankna: What are you compiling with?
06:52:37 <dankna> the full command line is
06:53:09 <geheimdienst> he was saying that in windows you can spawn hundreds of threads, but there's some limitation that you can only wait on 64 of them, making things complicateder than you'd like. linux has some limit at 64 because of numa issues. something about processes not starting to run ...
06:53:13 <dankna> ghc -ddump-simpl-stats -rtsopts=all -auto-all -caf-all -prof -O2 -o BarA BarA.hs
06:53:34 <Jafet> Perhaps he could ask the intel engineers
06:54:04 <dankna> the only one of those that should affect performance is -O2.  someone suggested that -prof could be reducing performance; because it runs for only a few seconds before exhausting my physical memory, it's hard to get data confirming that.
06:54:04 <argiopeweb> geheimdienst: Don't run Windows on high-performance machines?
06:54:07 <Jafet> 80-core cluster on MPI, I'm assuming
06:54:36 <argiopeweb> dankna: Exhausting your physical memory? That's impressive.
06:54:45 <dankna> isn't it
06:55:05 <argiopeweb> Still, the problem is in the caf in main.
06:55:16 <dankna> howso?
06:55:28 <argiopeweb> It says so in the profiling report.
06:55:34 <argiopeweb> I recommend a core dump.
06:55:38 <dankna> hmm
06:56:12 <argiopeweb> It looks like it's allocating 4gb and (presumably) not destructing it.
06:57:06 <argiopeweb> Oh, you have your UArray declared strict.
06:57:22 <argiopeweb> That's not going to be especially good.
06:57:36 <dankna> yes, but the UArray is never getting modified, and the allocation figures are essentially the same if I make it non-strict
06:57:57 <argiopeweb> Allocation figures may not change, but at least it won't eat your memory. >.>
06:58:08 <argiopeweb> Work on allocation when you can survive a full run.
06:58:44 <dankna> um
06:58:46 <dankna> one sec
07:00:04 <dankna> I take it back :( the reduction doesn't exhibit the memory exhaustion issue
07:00:07 <dankna> only the real program does
07:00:21 <argiopeweb> Ah, that's a different issue.
07:01:43 <argiopeweb> Should have guessed. Nothing there looked inherently high-mem usage (15-element unboxed array, strict or not, does not use memory like that)
07:01:44 <Lemmih> dankna: You're using StablePtr's, right?
07:01:56 <dankna> Lemmih: yes, why?
07:02:14 <Lemmih> dankna: Are you remembering to free them?
07:02:27 <dankna> yes.  the heap profile over time graph shows no long-term leaks... just these triangles.
07:02:43 <dankna> well, it does show a much slower one, but I can't really dig into that with it obscured by the fast one.
07:03:15 <dankna> also I'm not generating a StablePtr to the results of each iteration
07:03:22 <dankna> I only do that roughly every 66,000 iterations
07:04:06 <argiopeweb> Posting the full profile log could be helpful (since I assume you don't want to make the source available)
07:05:46 <dankna> I have no problem making the source available, I just assume you don't want to look through it
07:05:48 <dankna> sure, one sec
07:06:20 <dankna> Saizan in -blah suggested an approach that I may go with, by the way
07:06:25 <quicksilver> dankna: that arrSeq is pointless and very expensive
07:06:32 <quicksilver> dankna: are you sure it's a good thing?
07:06:39 <quicksilver> (it's hard to understand what you're doing)
07:06:40 <geheimdienst> @unpl arrSeq
07:06:40 <lambdabot> arrSeq
07:06:43 <dankna> quicksilver: this is a reduction
07:06:51 * geheimdienst tries to make the arrSeq not pointless
07:06:58 <dankna> quicksilver: the purpose is to be the simplest possible program I can think of that exhibits similar behavior
07:07:03 <argiopeweb> dankna: You're right, but it would be useful to run it and see what you were talking about. :P
07:07:07 <dankna> quicksilver: I'm not sure that it's an accurate reduction though :)
07:07:29 <quicksilver> dankna: yes, but unecessarily iterating through an array each time through a main loop
07:07:30 <dankna> argiopeweb: I'm preparing profiling output for you now (I don't actually have old copies in place)
07:07:37 <quicksilver> in order to compute a value you throw away
07:07:42 <quicksilver> is, clearly, going to take a lot of time...
07:07:49 <dankna> quicksilver: yes, but oddly, it's a space problem that I'm having
07:07:53 <argiopeweb> dankna: Rog
07:08:11 <dankna> argiopeweb: the build system is also complicated and Mac-specific, so you wouldn't be able to run it if I were to give you the code
07:08:20 <argiopeweb> lol...
07:08:24 <argiopeweb> Oh yeah, FFI stuff.
07:08:27 <dankna> yeah
07:08:38 <argiopeweb> Meh, just a minor issue. :P
07:08:41 <quicksilver> dankna: yes, I agree the space usage is odd
07:09:00 * argiopeweb spins up the mac VM
07:09:40 * argiopeweb remembers the mac VM is on the already-packed desktop... So much for that.
07:10:35 <dankna> http://dankna.com/himitsu/four-major-iterations.png
07:10:48 <dankna> http://dankna.com/himitsu/emulator.prof.txt
07:11:04 <mjk> how to convert a oct number to hex? for example, 16->10, 255->FF
07:11:07 <argiopeweb> That's an incredibly awesome graph.
07:11:16 <dankna> isn't it, I'm very pleased with the heap profiler
07:11:40 <Lemmih> dankna: Are you sure it should take less than 100megs?
07:12:02 <dankna> Lemmih: in a sense total allocation is not the problem; maximum residency is
07:12:18 <dankna> which I could swear I was seeing a figure for somewhere but the .prof doesn't seem to have it now
07:12:39 <Lemmih> dankna: Right, and the maximum residency looks to be about 100megs.
07:13:54 <dankna> hmm
07:14:13 <dankna> I could swear this used to exhaust my physical memory >< apparently with the various strictness annotations I've added over the past week or so, it no longer does
07:14:32 <dankna> honestly, the state of the simulated machine is like 16k
07:14:48 <dankna> what's 16k times 66,000 iterations?
07:14:56 <dankna> about 1G, heh
07:15:45 <mjrosenb> i know i've asked this before, is there anything similar to 'words', but lets me specify the value to split on?
07:15:56 <dankna> rjrosenb: not really, no
07:15:59 <argiopeweb> dankna: Maybe put in manual profiling statements in those few functions that are having issues to cut down some of the message spam?
07:16:09 <mauke> mjrosenb: Data.List.Split
07:16:17 <argiopeweb> mauke: Beat me to it.
07:16:18 <Lemmih> mjrosenb: Data.Text.splitOn
07:16:22 <dankna> oh, go figure
07:16:31 <dankna> argiopeweb, I'm not having trouble reading the profiling output, heh, it's neatly sorted :)
07:16:56 <argiopeweb> dankna: True, but you can get some finer-grained readings with the manual statements.
07:16:59 <mjrosenb>     Could not find module `Data.List.Split':
07:17:05 <geheimdienst> mjrosenb: you could use the package MissingH (or the package split). or roll your own thing using Prelude.break
07:17:08 <argiopeweb> mjk: cabal install
07:17:09 <Lemmih> dankna: Do each of those spikes represent 66,000 iterations?
07:17:14 <argiopeweb> mjrosenb: *
07:17:31 <dankna> Lemmih: yes.
07:17:59 <mjk> argiopeweb: cabal install?
07:18:27 <dmedvinsky> mjk: http://stackoverflow.com/questions/1959715/how-to-print-integer-literals-in-binary-or-hex-in-haskell
07:18:40 <dmedvinsky> that's to your dec->hex converting question
07:19:00 <Jafet> :t showIntAtBase
07:19:01 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
07:19:02 <argiopeweb> mjk: My bad, auto-complete failure.
07:19:06 <dmedvinsky> cabal install was addressed to mjrosenb
07:19:25 <mauke> > ""++ printf "%x" 123
07:19:27 <lambdabot>   "7b"
07:20:10 <mjk> argiopeweb: mauke: lambdabot: thanks
07:20:22 <Jafet> Heh, ""++ typical perlism
07:20:28 <Lemmih> dankna: Each iteration must be holding on to a reference to the previous state, then.
07:20:41 <mauke> mjk: why not Jafet?
07:21:01 <dankna> Lemmih: yeah - my original thinking was that the reference was in a closure that wasn't being evaluated yet, or something
07:21:05 <mjk> heh, thanks Jafet:
07:21:21 <mauke> > showIntAtBase 16 intToDigit 123 ""
07:21:22 <lambdabot>   "7b"
07:22:00 <ion> > showIntAtBase 36 intToDigit 123 ""
07:22:01 <lambdabot>   "3f"
07:22:04 <ion> > showIntAtBase 36 intToDigit 124 ""
07:22:08 <lambdabot>   "*Exception: Char.intToDigit: not a digit 16
07:22:08 <dankna> Lemmih: pursuant to that, I have made most of the fields strict (I did try all of them, but being more selective got better numbers) in an effort to avoid such a reference
07:22:28 <ion> intToDigit‚Äôs boundary at ‚Äòf‚Äô is quite arbitrary.
07:22:34 <dankna> Lemmih: and that did improve things; my maximum residency as reported in the .prof (which I have no idea why it's no longer reporting that) went down from 800M to 400M after some work
07:22:48 <dankna> (I also have no idea why the .prof and the heap profile disagree)
07:23:02 <Lemmih> dankna: Try deepseq'ing the state.
07:24:05 <Lemmih> dankna: That should tell you for sure whether the problem is an unwanted reference or if it is something else.
07:24:12 <dankna> hmmm okay
07:24:23 <dankna> I thought I was already doing something equivalent to that
07:24:53 <argiopeweb> There's another type of heap profile that shows different info...
07:24:56 * argiopeweb looks up
07:25:18 <Lemmih> dankna: You're not. You're only forcing some of the state.
07:25:53 <Jafet> ion, ("‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ0123456789‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ‚ì™‚ë†‚ë°‚ë¢‚ë£‚ë§"!!)?
07:26:01 <dankna> okay, writing code to try the deepseq now
07:26:20 <Lemmih> dankna: If deepseq doesn't squash the space leak then the problem is most likely in your loop.
07:26:48 <argiopeweb> dankna: Mind doing a -hy next profiling run just for the hell of it?
07:26:58 <dankna> I just do like fieldA record `seq` fieldB record `seq` ... `seq` result, right?
07:27:08 <dankna> but recursing into other records contained therein
07:27:11 <dankna> argiopeweb, sure
07:27:25 <Lemmih> dankna: Use the deepseq package.
07:27:36 <ski> @type \s -> case readOct s of [(n,"")] -> showHex n ""
07:27:36 <argiopeweb> Thanks. Isn't there a deepseq in one of the libraries?
07:27:36 <lambdabot> String -> String
07:27:43 <argiopeweb> Lemmih: Yeah, that one.
07:27:53 <ski> (bah, mjk left)
07:28:04 <dankna> oh cool
07:28:52 <ski> @hoogle readIntAtBase
07:28:52 <lambdabot> No results found
07:29:20 <mauke> :t readInt
07:29:20 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
07:29:32 <erus`> @hoogle Num -> String -> Num
07:29:33 <lambdabot> Warning: Unknown type Num
07:29:33 <lambdabot> Debug.Trace trace :: String -> a -> a
07:29:33 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
07:29:41 <Lemmih> > [undefined] `seq` ()
07:29:42 <lambdabot>   ()
07:30:32 <Lemmih> dankna: Deepseq would make the above code throw an exception.
07:30:40 <dankna> http://dankna.com/himitsu/by-type.png
07:30:59 <dankna> yes, I see
07:31:25 <argiopeweb> Pretty graphs... That's one extreme GC though.
07:31:31 <dankna> isn't it
07:31:53 <Jafet> You'll need NFData instances for everything to use deepseq
07:32:13 <dankna> yeah, I see that
07:32:16 <Jafet> class NFData a where rnf :: a -> ()
07:32:26 <Jafet> (And writing rnf is basically... writing deepseq)
07:32:31 <dankna> right, heh
07:32:54 <dankna> what is this going to tell me, again?
07:33:16 <argiopeweb> If you have excessive laziness?
07:33:30 * argiopeweb isn't 100% certain either...
07:34:14 <Lemmih> dankna: It will tell you whether or not you carry around any unwanted references in the state.
07:34:22 <dankna> hmm okay
07:34:39 <dankna> so if memory usage still exhibits this pattern after the deepseq, the state is somehow explicitly storing a reference to the previous state
07:36:31 <Lemmih> dankna: No.
07:37:13 <erus`> :t Maybe
07:37:13 <lambdabot> Not in scope: data constructor `Maybe'
07:37:21 <erus`> :import Data.Maybe
07:37:25 <ion> :t Just
07:37:26 <lambdabot> forall a. a -> Maybe a
07:37:32 <ion> :t Nothing
07:37:33 <lambdabot> forall a. Maybe a
07:37:41 <erus`> is Maybe a function?
07:37:49 <ion> No, it‚Äôs a type constructor.
07:37:56 <Lemmih> dankna: If the problem persist after deepseq then something else is holding on to old states.
07:37:58 <erus`> ah ok
07:38:11 <geheimdienst> (Maybe is not to be confused with maybe. maybe is a function, Maybe is a type constructor)
07:38:30 <Lemmih> dankna: Do you completely discard the state after 66,000 iterations, btw?
07:38:35 <argiopeweb> erus`: Only data constructors start with capital letters
07:38:39 <dankna> Lemmih: no, I don't!  that's the weird thing!
07:38:54 <ion> Just is a function.
07:39:08 <ion> Nothing is just a value.
07:39:10 <Lemmih> dankna: Hm, then the problem is most likely in your iterator.
07:39:17 <dankna> hm
07:39:29 <argiopeweb> ion: I'd argue it's an ADT, though I'll give you it's a constructor function.
07:39:42 <erus`> Just is a function starting with a capitol>
07:39:44 <erus`> ?
07:39:51 <quicksilver> Just is a constructor as well as a function.
07:40:06 <quicksilver> (Nothing is a constructor, but it's not a function, as ion said)
07:40:31 <argiopeweb> erus`: Allow me to restate: Only functions associated with abstract data types can have capital names.
07:40:44 <erus`> constructors are functions?
07:40:56 <quicksilver> erus`: constructors which take arguments are functions.
07:40:57 <ski> > let [(n,"")] = readInt 16 isHexDigit intToDigit "64" in n
07:40:57 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:40:58 <lambdabot>         against inferred type...
07:41:00 <argiopeweb> Further, some constructors aren't functions (Nothing, as pointed out by quicksilver)
07:41:06 <ski> > let [(n,"")] = readInt 16 isHexDigit digitToInt "64" in n
07:41:07 <lambdabot>   100
07:41:14 <quicksilver> if you want ot be really precise "constructors which take arguments have a function associated with them, which shares the same name"
07:41:31 <quicksilver> if you are being ultra-pedantic, the constructor 'Just' and the function 'Just' are different, but related, entities.
07:41:45 <Jafet> You can't really separate them, though
07:41:50 <Jafet> So that is being pedantic
07:41:51 <argiopeweb> quicksilver: Which is how I think of them.
07:41:55 <quicksilver> Jafet: you can.
07:42:00 <quicksilver> by passing them to another function.
07:42:00 <argiopeweb> Hence my earlier comment.
07:42:09 <ski> ion : `Maybe' is a function on the type-level .. a type-function
07:42:22 <ion> true
07:42:23 <quicksilver> if you pass just to a function, as in "f Just" then the function f does not get a constructor as its argument.
07:42:28 <quicksilver> it merely gets a function.
07:42:41 <Jafet> Yeah, patterns aren't values
07:42:43 <quicksilver> "constructors are not first-class"
07:42:50 <ion> > let f Just = Just 42 in f (1+)
07:42:51 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
07:42:51 <ski> erus` : er, see what i mistakenly directed to ion above ^
07:42:57 <Lemmih> dankna: Do you do anything with the state in between the 66,000 iterations?
07:42:58 <Jafet> You can't export one without the other, though
07:43:06 <quicksilver> it's hard to tell if this pedantry is helpful to erus or not :)
07:43:19 <quicksilver> because I don't know what his actual confusion / quesiton in need of clarification is.
07:43:20 <Jafet> Oh, we're supposed to be helpful? Sorry
07:43:31 * argiopeweb stands by his original statement if we're being helpful
07:44:53 <ion> data Maybe a = Just a | Nothing  ‚Üê you get to use Maybe as a function on the type level, Just as a usual function, Nothing as a usual non-function value, Just x as a pattern and Nothing as a pattern.
07:45:07 <ski> erus` : some (data) constructors are functions, like `Just',`Left',`Right',`(:)'; some other are not functions, like `Nothing',`False',`True',`[]'
07:45:12 <dankna> Lemmih: I return it to C in a StablePtr, and then I do in fact inspect it to generate a frame of video
07:45:21 <dankna> (I don't inspect it from the C, I pass the StablePtr back)
07:45:45 <frerich2> erus`: In case you know templates in C++: I think type constructors in Haskell are like the names of template classes (e.g. 'pair' in 'pair<T,U>'). data constructors in Haskell are like constructors of C++ classes. If a Haskell data constructor takes at least one argument, it's also a function (it takes the argument and returns an instance of the type)
07:45:48 <frerich2> I hope I got that right.
07:45:58 <Saizan> to stress the fact that a constructor is not a function we could require them to be eta-expanded when passed to HOFs, then we'll be ML (O'Caml?)
07:46:04 <Jafet> No, C++ always belongs in Left
07:46:38 <argiopeweb> Badum-dum
07:46:38 <Jafet> C++ does not have pattern matching, anyway.
07:46:44 <quicksilver> Saizan: I think that's an abitrarary half-way stress if it
07:46:46 <boegel> I see to recall a function that type-checks a Haskell expression (or somesuch), but I can't seem to find it or the module it belongs to... anyone know what I'm looking for?
07:46:53 <quicksilver> Saizan: if you *really* want ot stress it you should change the application syntax.
07:47:05 <quicksilver> Saizan: "Just @ x" or something; to stress this is not plain function application.
07:47:14 <dankna> still writing my NFData instances, btw.  there are a lot of them.
07:47:18 <quicksilver> Saizan: (I am not actually proposing this is a good thing :)
07:47:25 <Saizan> quicksilver: :)
07:47:29 <quicksilver> dankna: there are tools to do that for you. DrIFT. Derive.
07:47:39 <ski> Saizan : O'Caml, yes; SML, no
07:47:48 <dankna> quicksilver, s'okay, it's mostly done
07:47:51 <quicksilver> :)
07:47:56 <argiopeweb> Derive is my savior.
07:48:08 * argiopeweb had 300+ Binary instances to write
07:48:22 <Saizan> boegel: maybe hint? or the ghc-api directly?
07:51:36 <luite> yeah hint has a typecheck function
07:51:39 <ion> > (:[]) "I am a robot"
07:51:41 <lambdabot>   ["I am a robot"]
07:52:11 <dankna> > "Stop repeating everything I say!"
07:52:12 <lambdabot>   "Stop repeating everything I say!"
07:52:16 <dankna> > "I'm telling Mom!"
07:52:17 <lambdabot>   "I'm telling Mom!"
07:52:25 <ion> hah
07:52:46 <Tomsik> :t repeat
07:52:46 <lambdabot> forall a. a -> [a]
07:53:03 <Tomsik> :t repeat "I will never poop in the drawer again. "
07:53:04 <lambdabot> [[Char]]
07:53:13 <ion> tomsik: cycle
07:53:33 <Tomsik> Yeah, but it doesn't seem like natural language then
07:55:31 <argiopeweb> > repeat "Tomsik, go clean your room!"
07:55:32 <lambdabot>   ["Tomsik, go clean your room!","Tomsik, go clean your room!","Tomsik, go cl...
07:57:02 <erus`> :t [[]] -> []
07:57:02 <lambdabot> parse error on input `->'
07:57:18 <erus`> @hoogle [[]] -> []
07:57:18 <lambdabot> Did you mean: [[a]] -> [a] /count=20
07:57:18 <lambdabot> Prelude head :: [a] -> a
07:57:18 <lambdabot> Prelude last :: [a] -> a
07:57:30 <argiopeweb> :t [[a]] -> []
07:57:30 <lambdabot> parse error on input `->'
07:57:41 <argiopeweb> heh
07:57:59 <argiopeweb> erus`: Regardless, that's concat.
07:58:08 <argiopeweb> :t concat
07:58:08 <lambdabot> forall a. [[a]] -> [a]
07:58:23 <erus`> concat $ repeat "Tomsik, go clean your room! "
07:58:27 <erus`> > ]concat $ repeat "Tomsik, go clean your room! "
07:58:27 <lambdabot>   <no location info>: parse error on input `]'
07:58:31 <erus`> > concat $ repeat "Tomsik, go clean your room! "
07:58:32 <lambdabot>   "Tomsik, go clean your room! Tomsik, go clean your room! Tomsik, go clean y...
07:58:32 <Nightwolf> is there a way to see how given haskell function are implemented (e.g. nub)?
07:58:36 <ion> > cycle "No. "
07:58:36 <lambdabot>   "No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No...
07:58:41 <ski> > concat [[0,1,2,3],[4,5,6],[7,8],[9],[]]
07:58:42 <Silvah> @src nub
07:58:42 <lambdabot> nub = nubBy (==)
07:58:42 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
07:58:58 <Silvah> @src nubBy
07:58:58 <lambdabot> nubBy eq []             =  []
07:58:58 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
07:59:09 <erus`> every little function i write is allways allready implemented in the library
07:59:14 <erus`> its really funny
07:59:23 <argiopeweb> erus`: It's great. :P
07:59:23 <Nightwolf> Silvah: and except asking the bot every time? ;-)
07:59:36 <argiopeweb> Nightwolf: Hoogle + Hackage
07:59:43 <argiopeweb> Click the "Source" link next to names.
07:59:50 <merijn> Nightwolf: By downloading the source of said function? :p
07:59:51 <Nightwolf> argiopeweb: shows only the signature
07:59:58 <boegel> Saizan: hint might be it, thx
08:00:05 <merijn> You can also just privmsg lambdabot
08:00:15 <argiopeweb> Nightwolf: Some things are implemented internally.
08:00:15 <Nightwolf> a there is a source link on the right
08:00:17 <Nightwolf> :D
08:00:23 <argiopeweb> Yep.
08:00:54 <erus`> > concat [ [ [ 1, 2 ] ] ]
08:00:54 <lambdabot>   [[1,2]]
08:01:10 <erus`> is there a recursive concat?
08:01:23 <Jafet> > map last $ sort $ zipWith (++) <$> tails <*> init.inits $ "I will never poop in the drawer again."
08:01:25 <lambdabot>   "replrnIn. gr hwvnatw aliii poo eed ea "
08:01:27 <argiopeweb> map . concat
08:01:31 <mauke> erus`: type?
08:01:33 <argiopeweb> :P
08:01:48 <argiopeweb> Oh, bring everything to the top level?
08:01:52 * argiopeweb knows there is one...
08:02:17 <erus`> > concat [ [ [ 1, 2 ] ] ,[[3, 4]]]
08:02:17 <lambdabot>   [[1,2],[3,4]]
08:02:32 <Jafet> How do you write its type?
08:02:39 <erus`> like vector flatten
08:02:49 <mauke> erus`: what
08:02:53 <erus`> a -> [] ?
08:02:55 <ion> > concat.concat $ [[[1,2]],[[3,4]]]
08:02:57 <lambdabot>   [1,2,3,4]
08:03:02 <mauke> [] is not a type
08:03:02 <tromp_> @pl  x-> map (f x) [1,2]
08:03:02 <lambdabot> (line 1, column 2):
08:03:02 <lambdabot> unexpected ">" or "-"
08:03:02 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
08:03:09 <tromp_> @pl  \x-> map (f x) [1,2]
08:03:09 <lambdabot> flip map [1, 2] . f
08:03:49 <byorgey> preflex: seen tg_
08:03:49 <preflex>  tg_ was last seen on #haskell 11 hours, 57 minutes and 9 seconds ago, saying: applicative: hehe. That will have been good enough. I would have eventually checked it (i mean, it's called vector-space...) but knowing it's written by conal means I'll go through it now.
08:04:50 <boegel> Saizan: jep, Hint was it, I've found my old experiments back, thanks :)
08:10:55 <argiopeweb> erus`: The libraries have flatten for Data.Trees, and Oleg has stuff to say about list flattening.
08:11:19 <kstt> can I stick the following function type "(Eq a) => a -> a -> Bool" into a "type" or a "newtype" declaration. IOW, can I define class constraints in types or newtypes ?
08:12:07 <argiopeweb> Yes.
08:12:25 <argiopeweb> For newtypes*
08:12:34 <ski> kstt : do you want a polymorphic component, or do you want to require `Eq a' of a type argument of the type constructor ?
08:12:44 <ski> argiopeweb : and for `data'
08:12:46 <argiopeweb> You can define class constraints based on types as well, though I don't know that you can use type class constraints
08:13:42 <argiopeweb> ski: type String = [Char]; data D = D String; newtype A = A String; is all valid.
08:14:34 <ski> argiopeweb : er .. yes ? how's that related to class constraints ?
08:14:46 <Jafet> People usually have more polymorphic types, and slightly less polymorphic functions
08:14:57 <Jafet> :t M.fromList
08:14:58 * argiopeweb misread the question
08:14:58 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
08:15:05 <argiopeweb> I'm going back to bed...
08:15:17 <ski> @type M.toAscList
08:15:18 <lambdabot> forall k a. M.Map k a -> [(k, a)]
08:15:35 <Jafet> Map itself does not have class constraints
08:15:43 * ski wonders whether that ought to include `Ord k => '
08:15:46 <kstt> I don't think I understand. As a first approach, let's say I have dozens of functions with the signature above ( the (==) one ). I want to factor this signature into a "Comparison" type. Can I do that ?
08:16:25 <Jafet> Well, toAscList is already there for the people who aren't fond of the default invariants
08:16:25 <ski> kstt : do you want `data Comparision = ...' or `data Comparision a = ...' ?
08:16:58 <kstt> data Comparison = ...
08:17:26 <kstt> type Comparison = (Eq a) => a -> a -> Bool
08:17:30 <ski> ok, so `data Comparision = Foo (forall a. Eq a => a -> a -> Bool)' will have a polymorphic component
08:17:57 <kstt> ok, thanks. what about "type" declaration ?
08:18:24 <ski> you'll need to add `{-# LANGUAGE PolymorphicComponents #-}' to the top of your file to enable that extension
08:18:45 <kstt> ah, that's not H98.
08:18:57 <ski> hm, i think in GHC you can do `type Comparison = forall a. Eq a => a -> a -> Bool' as well
08:19:31 <Jafet> {-# LANGUAGE ExplicitForAll #-}
08:19:53 <ski> (it's the `forall a. ' part that makes this be a *polymorphic* component, as opposed to just a monomorphic instance, e.g. inside a parameterized type)
08:20:01 <Jafet> (isn't "in GHC" a bit meaningless when referring to extensions?)
08:20:37 <ski> (Hugs e.g. supports some of these extensions as well .. i'm not as familiar with nhc and lhc)
08:22:08 <conal> would someone please remind me where ghc search path customization goes, e.g., --extra-include-dirs and --extra-lib-dirs ?
08:22:10 <kstt> My use case is just to stack a HDBC database handler along with the Snap monad (web server). All my functions will have the type "MySnap a", where "type MySnap = forall db. (IConnection a) => ReaderT db Snap"
08:22:21 <ski> (hm, probably it's `LiberalTypeSynonyms' to allow `forall' in `type' ?)
08:23:00 <kstt> oups, sorry for the wrongly pasted type. It should of course read : type MySnap = forall db. (IConnection db) => ReaderT db Snap
08:23:36 <ski> kstt : `MySnap :: *', so `MySnap a' is nonsense
08:24:18 <Silvah> ski: 'RankNTypes' makes that forall in type work for me.
08:24:19 <zenzike> kstt: I get the feeling we're duplicating work here
08:24:46 <ski> (Silvah : some of the extensions imply others, so that's quite possible)
08:25:06 <zenzike> kstt: I've been working on exactly what you're implementing, how far through are you with this
08:25:09 <Jafet> That does look like a rank-2
08:26:50 <kstt> zenzike: I have a ReaderT working with an (MVar Integer) for the state. Now I'm trying to define the same for a database Connection, but the typeclass oriented nature of HDBC makes it trickier for me to get right.
08:27:21 <zenzike> kstt: :-) that's exactly what has slowed me down too
08:27:41 <kstt> ski: "Snap :: * -> *"
08:28:53 <develhevel> how can i handel exception in haskell, e.g. when someone insert a wrong path to setCurrentDirectory
08:28:57 <erus`> if i take a 20% chance twice
08:29:09 <erus`> what are the chances of me scoring
08:29:26 <Jafet> develhevel: that produces an IOError, which you can handle with Prelude.catch
08:29:36 <Jafet> Or just use Control.Exception
08:29:41 <ski> kstt : yes, but still `MySnap :: *'
08:29:51 <kstt> zenzike: there is the trick with ConnWrapper if you need a fast track. For me, I take this opportunity to understand better how 'type' polymorphism works
08:30:11 <webchat77> kstt: as a side note, check out the mstate package. it provides a concurrent State monad that your ReaderT (MVar Integer) seems to be simulating
08:30:48 <ski> erus` : if the two trials are independent, multiply the probabilities
08:31:06 <develhevel> Jafet: thx this is i'm looking for
08:31:29 <kstt> webchat77: thanks for this tip. The MVar Integer was just a canonical state handler for me to play with the concept of ReaderT, so I won't go further with it. But mstate is good to know.
08:31:55 <applicative> conal, (if you're still here) there is a field for this in .cabal/config  ;  but do you mean something not cabal related
08:32:10 <ski> (kstt : you said "All my functions will have the type \"MySnap a\", where \"type MySnap = forall db. ...\"", which doesn't make sense. presumably you have made a typo/thinko in there ..)
08:36:54 <kstt> I don't think so, or I don't understand. { type Foo = IO ; main :: Foo () ; main = putStrLn "hello" } is valid and works without warning in GHC.
08:38:00 <kstt> or does that relate to the "forall db" part ?
08:38:16 <Jafet> You just declared MySnap :: *, and then used it as `MySnap a'.
08:39:27 <Silvah> kstt: type Foo = IO is the same as type Foo a = IO a, IIRC.
08:39:58 <kstt> Jafet: what does define that MySnap has kind * ?
08:39:58 <ski> kstt : you can't "shorten" `type Foo a = forall b. Bar (..b..) a' to `type Foo = forall b. Bar (..b..)'
08:40:29 <kstt> ah ! ok
08:40:45 <ski> Silvah : semantically, yes; but in terms of what programs are accepted, no
08:41:16 <dankna> Lemmih, still around?
08:41:18 <ski> Silvah : if you have `type Foo a = ..a..', then every use of `Foo' must be in an application with one argument
08:41:34 <dankna> I'm working on my NFData instance for UArray Int Word8 now
08:41:40 <dankna> do I need to visit each Word8 of the array?  heh
08:41:48 <ski> Silvah : so `Maybe (Foo Int)' is ok, but `MaybeT Foo Int' is not, e.g.
08:42:06 <kstt> sorry, I'm really lost with this types considerations. All I really wanted to was to alias "(IConnection db) => ReaderT db Snap" so that I don't have to type it in every functions :)
08:42:19 <ski> @kind ReaderT
08:42:20 <lambdabot> * -> (* -> *) -> * -> *
08:42:59 <ski> kstt : you can say `type MySnap a = forall db. IConnection db => ReaderT db Snap a' no problem
08:43:29 <ski> (as long as you always apply `MySnap' to an argument, everyplace you use it)
08:43:45 <kstt> ski: is that related to the use of forall, or does that hold without forall ?
08:45:03 <ski> if the `forall db.' and `IConnection db => ' parts were not there, then you could shorten `type FooSnap a = ReaderT Foo Snap a' into `type FooSnap = ReaderT Foo Snap' (and then you could use `FooSnap' without needing to apply it to an argument)
08:45:12 <kstt> ok
08:45:45 <ski> but in both cases can you say `MySnap String'/`FooSnap String' inside types
08:46:09 <kstt> thank you very much for these deep calrifications. I'm trying to learn Haskell 98 so if I can't alias my function types, I'll don't alias them.
08:46:09 <webchat77> aren't you able to partially apply type aliases with a particular language extension
08:46:29 <ski> (though, in the `MySnap' case, if you use it in argument types, then you'll probably need `Rank2Types' or `RankNTypes' extension)
08:47:02 <ski> @wn calcrification
08:47:04 <lambdabot> No match for "calcrification".
08:47:18 <webchat77> clarification, maybe?
08:47:43 <mauke> ski: calrification, not calcrification
08:47:50 <kstt> thanks ;)
08:48:01 <ski> webchat77 : iirc, no. in general this would make the type checker not always terminate
08:48:12 <ski> .. oh
08:48:19 <ski> @wn calrification
08:48:20 <lambdabot> No match for "calrification".
08:48:35 <Silvah> @wn clarification
08:48:35 <lambdabot> *** "clarification" wn "WordNet (r) 2.0"
08:48:36 <lambdabot> clarification
08:48:36 <lambdabot>      n 1: an interpretation that removes obstacles to understanding;
08:48:36 <lambdabot>           "the professor's clarification helped her to understand
08:48:36 <lambdabot>           the textbook" [syn: {elucidation}, {illumination}]
08:48:38 <lambdabot>      2: the act of removing solid particles from a liquid [syn: {clearing}]
08:50:04 <webchat77> ah, yep: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/data-type-extensions.html#type-synonyms
08:50:05 * ski thought `calrification' was supposed to be a fancy obscure english word, useful for scaring people
08:50:12 <dankna> @wn calcification
08:50:13 <lambdabot> *** "calcification" wn "WordNet (r) 2.0"
08:50:13 <lambdabot> calcification
08:50:13 <lambdabot>      n 1: a process that impregnates something with calcium (or
08:50:13 <lambdabot>           calcium salts)
08:50:13 <lambdabot>      2: tissue hardened by deposition of lime salts
08:50:15 <lambdabot>      3: an inflexible and unchanging state; "the calcification of
08:50:16 <lambdabot>         negotiations"
08:56:19 <ArnoVanLumig> hey zr40!
08:56:21 <ArnoVanLumig> how are you today? :)
09:08:09 <Perlkonig> Hello, all. I'm new to Haskell and am really trying to wrap my head around the type system. I'm creating an hpaste with my error. I would really appreciate any help. (Hpaste #46656)
09:08:27 <Perlkonig> I'm not sure why Int isn't matching against Integral
09:09:41 <Perlkonig> Is it preferred to paste to the channel itself? I'm new to the channel, but I saw the hpaste link up top and assumed that's the preferred method.
09:10:34 <quicksilver> the preferred method is hpaste as you guessed
09:10:41 <ski> for longer pieces of code, putting on a paste-site (or other hosting) is preferred
09:10:43 <quicksilver> but giving us the link rather than just the number
09:10:45 <Jafet> http://hpaste.org/46656 if you give people something to click on, many of them can't resist
09:10:46 <Perlkonig> I'm particularly confused because I've used the (Integral a) => a -> a type definition in other functions without issue.
09:10:49 <quicksilver> makes it easier for lazy people to click :)
09:10:56 <Perlkonig> ahh, will do :) Thank you.
09:11:04 <quicksilver> Perlkonig: your problem is the function 'length'
09:11:10 <ski> Perlkonig : try replacing `length' with `genericLength'
09:11:11 <Jafet> The problem is that you're trying to match Integral to Int
09:11:13 <quicksilver> Perlkonig: length is defined to return Int and only Int
09:11:14 <ski> @index genericLength
09:11:14 <lambdabot> Data.List
09:11:18 <ski> @type length
09:11:18 <lambdabot> forall a. [a] -> Int
09:11:22 <ski> @type genericLength
09:11:22 <lambdabot> forall b i. (Num i) => [b] -> i
09:11:46 <Perlkonig> I assumed that (Integral a) would match any integral type, including Int and Integer
09:12:35 <ski> Perlkonig : saying `Integral a' will allow the caller to choose any type in that class, such as `Integer', but `length' gives an `Int', which doesn't work if the caller wanted an `Integer'
09:13:04 <ski> Perlkonig : by calling instead `genericLength', you tell that to give an answer of the same type as the caller of `totient' wanted to get
09:13:22 <Perlkonig> I see. Thank you!
09:13:38 <Jafet> Or just use a better implementation of totient!
09:13:49 <Perlkonig> *looks up the docs for the generic version*
09:13:52 <quicksilver> Perlkonig: you're right that it matches any type, but you were wrong about who gets to choose :)
09:13:55 <quicksilver> in a sense.
09:14:01 <ski> Perlkonig : btw, you have a bug, `totient 1' should be `1', not `0'
09:14:31 <Perlkonig> Aye :) I'm sure there are better implementations. I'm just trying to wrap my head around it all this. I'm doing Project Euler problems to learn.
09:14:36 <Perlkonig> Thanks, ski. I'll fix it.
09:16:05 <ski> (i'm not sure whether `totient 0' are commonly defined, and with what value (`2' ? `1' ?))
09:17:08 <sshc> I'm reading through "Asymptotic Improvement of Computations over Free Monads".  I'm reading the "a generic setting" section.  Is "Free" intended to be a more generic version of "Tree"?
09:17:24 <Perlkonig> PE says the totient of 2 is 1 and doesn't say anything about smaller values. I have never encountered totient functions before, so I don't know wha tthe correct assessment should be for values less than 2
09:18:10 <ski> sshc : it's probably meant in the same sense as `free grop',`free ring',`free vector space',&c.
09:18:33 <ski> Perlkonig : definitely `totient 1 = 1'
09:20:20 <ski> sshc : in category theory, a functor is called `free' if it is the left adjoint of a functor that we think of as "underlying" (like "the underlying/carrier set of a vector space")
09:20:57 <monochrom> totient n = among 1..n, how many are relatively prime to n?
09:21:25 <Jafet> > length [1..0]
09:21:26 <lambdabot>   0
09:21:47 <Jafet> "No no, define it using this lattice"
09:21:50 <monochrom> example. among 1..10, these are relatively prime to 10: 1,3,7,9. totient 10 = 4
09:21:50 <ski> sshc : in this case, the underlying functor is the functor that maps from the category of monads over `C' to the category of endofunctors over `C'
09:23:05 <ski> `totient n = card (|Z / n * |Z)' is one possible definition
09:24:20 <ski> (.. but maybe we're only interested in number of elements, up to associated elements ?)
09:24:26 <rajjer> Hi all. I was experimenting with ghci when I found that I can't bind arbitrary function name with let. Please, could someone explain my situation? http://hpaste.org/46657/ghci_let_binding_problem
09:25:19 <monochrom> totient satisfies this helpful law: if m,n are relatively prime, totient (m*n) = totient m * totient n. the proof involves the chinese remainder theorem
09:25:35 <endojelly> ok, stupid question maybe, but can you reduce every undecidable problem to the halting problem?
09:25:56 <ski> rajjer : give a type signature, or eta-expand, or use `-XNoMonomorphismRestriction'
09:26:04 <monochrom> so for example, totient 100 = totient (2^2 * 5^2) = totient (2^2) * totient (5^2)
09:26:27 <Perlkonig> So I have a function that takes 2 Integrals. It then returns a tuple containing the first Integral and a Floating number representing the quotient of the two numbers. The / operator is only available (apparently) to Fractionals? How would I typeclass a function like this?
09:27:10 <rajjer> thanks a lot
09:27:26 <Jafet> :t fromIntegral
09:27:27 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:27:37 <endojelly> as in "if you could solve this, you could solve the halting problem. therefore it's undecidable."
09:27:51 <ski> (monochrom : i've wondered if one could make a generalization, showing `totient (m * n)' to be something possibly involving `totient m',`totient n',`totient (m / gcd m n)',`totient (n / gcd m n)',`totient (gcd m n)' ..)
09:28:24 <endojelly> (or rather to solve this, you'd need to solve the halting problem?)
09:28:53 <Perlkonig> So I have to use fromIntegral on the Integral arguments to access the / operator and return a Floating number. I'll give that a shot. Thank you for your help.
09:29:40 <Tomsik> endojelly: If something is r.e. then it's no harder then halting problem.
09:30:30 <endojelly> Tomsik, r.e.?
09:31:05 <ski> endojelly : "recursively enumerable" aka "computably enumerable" ("c.e.")
09:31:31 <endojelly> ski, ah. seems that I have to read some more.
09:32:00 <Jafet> Due to the existence of UTM.
09:32:09 <Tomsik> and also aka "semi-decidable"
09:32:48 <endojelly> semi-dicidable was when it always answers "yes" if yes, but may not always terminate when the answer is no?
09:32:56 <Tomsik> yes
09:33:07 <bxc> that was "answerable" in the CS course I took.
09:33:08 <bxc> i think
09:34:02 <monochrom> if there are 10 authors, there will be 20 names assigned to the same thing
09:34:19 <monochrom> moreover every name refers to 15 different things
09:34:23 <endojelly> because (without knowing too much about anything about that) I was wondering how you show that something is undecidable.
09:34:48 <endojelly> and "look, you would solve the halting problem!" seemed intuitive
09:35:10 <monochrom> yes that's the popular way to prove undecidability
09:36:19 <drhodes> Are there things called type operators? Does this functionality exist in haskell?  foo :: A <op> B -> C
09:36:48 <monochrom> as for whether it is called (\x -> reduce x to the halting problem) or (\x -> reduce the halting problem to x), I can never remember
09:37:08 <endojelly> monochrom, both seem... viable
09:37:23 <ski> drhodes : yes
09:37:40 <endojelly> monochrom, I mean, whether you need to solve the halting problem to solve something (so you can't) or whether something would solve the halting problem (which it doesn't)...
09:37:40 <Tomsik> monochrom: depends on what you want to prove :p
09:37:51 <ski> drhodes : `(->)' is a built-in one, also you can have `data a :<+> b = ..a..b..'
09:38:04 <Jafet> data a :- b = a :- b
09:38:07 <monochrom> but in symbols it's easy. the halting problem ‚â§ x. x is at least as hard.
09:38:10 <mcdondan> Say I want to define an infinite sequence of Friday the 13ths. The straightforward way
09:38:12 <mcdondan> is to filter an infinite sequence of all days with a predicate that checks for
09:38:14 <drhodes> ski: ok thanks, I'll check it out.
09:38:14 <mcdondan> day_of_week==Friday and day_of_month==13. But it feels much more efficient to do the
09:38:16 <mcdondan> intersection of two infinite sequences, all the Fridays and all the 13ths of the month. How
09:38:18 <mcdondan> can I do this w/ Haskell?
09:38:47 <Tomsik> isn't it the same mcdondan?
09:39:02 <monochrom> yet another reason to screw wordy descriptions
09:39:05 <Jafet> mcdondan: it's most efficient to use a little arithmetic to determine all the friday-the-thirteenths modulo 400 years
09:39:19 <endojelly> mcdondan, hmm. generate a list of all Fridays, generate a list of all 13ths, get intersection? I know I basically just reformulated your problem slightly differently but it sounds trivial
09:39:19 <Jafet> Then cycle it
09:39:22 * ski thinks mcdondan wants intersection of two ordered sequences
09:39:33 <mcdondan> ski: yes
09:39:45 <endojelly> mcdondan, unless you're talking about how to specifically generate one or both of these lists?
09:39:53 <ski> > intersect [0 ..] [0,2 ..]
09:39:57 <lambdabot>   mueval-core: Time limit exceeded
09:39:58 <mcdondan> No, I can generate the Fridays and 13ths
09:39:59 <ski> > intersect [0,2 ..] [0 ..]
09:40:01 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
09:40:10 <ski> > intersect [0,2 ..] [0,3 ..]
09:40:13 <lambdabot>   mueval-core: Time limit exceeded
09:40:14 <Perlkonig> Sorry, another n00b type question. I don't know why I'm struggling so much with it. Here's the paste. I'm trying to take two integers and return a float, essentially. http://hpaste.org/46658/fromintegral_problem
09:40:16 <endojelly> mcdondan, then just intersect them. the function is really called "intersect".
09:40:39 <mcdondan> Oh, wow that's what I need, intersect thanks
09:41:00 <ski> endojelly : it doesn't (necessarily) work if both are infinite .. though if one of them is included in the other, it appears to work with the right argument order
09:41:06 <endojelly> mcdondan, if it wasn't you'd trivially define it yourself, I bet 8)
09:41:16 <Jafet> :t intersect
09:41:18 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
09:41:21 <ivan> Perlkonig: you're missing some parentheses
09:41:23 <Jafet> Not very efficient, is it...
09:41:30 <mcdondan> endojelly: I knew there had to be a standard function to do this
09:41:46 <monochrom> fromIntegral (fst n) / fromIntegral (snd n)
09:41:48 <Tomsik> @src intersect
09:41:48 <lambdabot> intersect = intersectBy (==)
09:41:50 <endojelly> ski, ah, yeah, but it should always work if both are ordered under the same order relation, right?
09:41:51 <ski> mcdondan : i think you'll probably have to define your own 'intersectOrdered' (maybe it's in some library somewhere)
09:41:55 <Tomsik> @src intersectBy
09:41:56 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
09:42:07 <ski> > intersect [0,2 ..] [0,3 ..]  -- endojelly
09:42:18 <endojelly> ski, oh. I see the problem now.
09:42:21 <merijn> Perlkonig: It's doing "(fromIntegral fst) n", not "fromIntegral (fst n)"
09:42:23 <lambdabot>   thread killed
09:42:51 <Perlkonig> *sighs* Sorry. Thank you for your help.
09:43:06 <merijn> Perlkonig: Still trips me up as well sometimes :p
09:43:14 <Tomsik> it'll die whenever it finds an x that eq x y is not satisfied for any y
09:43:25 <mauke> :t map (\(a, b) -> (a, fromIntegral a / fromIntegral b))
09:43:44 <lambdabot> forall t t1 b. (Integral t, Fractional b, Integral t1) => [(t, t1)] -> [(t, b)]
09:43:52 <Tomsik> i.e. if both lists are infinite it'll work only if A intersect B = A
09:44:02 <ski> Tomsik : because `elem' on an infinite list is only semi-decidable ;)
09:45:19 <monochrom> the halting problem ‚â§ elem on infinite lists
09:45:28 <hpc> :t elem
09:45:29 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:45:46 <endojelly> monochrom, how's that order defined?
09:45:59 <monochrom> easier problem ‚â§ harder problem
09:46:21 <endojelly> yeah but what is "easier"?
09:46:42 <monochrom> if you know how to solve the harder one, you also know how to solve the easier one
09:46:46 <Tomsik> "not harder" is in sense of computable reductions
09:47:10 * merijn surprised that didn't spark an impromptu complexity theory lecture :>
09:47:19 <merijn> s/surprised/is surprised/
09:47:24 <Jafet> Pee and pee
09:47:29 <endojelly> merijn, oooh. yeah, it does, thanks 8(
09:47:33 <endojelly> i mean 8)
09:51:26 <dankna> oh hey
09:51:30 <dankna> hmm
09:51:50 <dankna> I think I found my space leak
09:52:03 <dankna> not clear how I can fix it though, hmmm
09:52:13 <dankna> need to think a bit to even test it while keeping the program runnable
09:54:14 <dankna> I found it by trying to implement NFData so I could deepseq on my state
09:54:22 <dankna> I had forgotten that there's a closure buried deep in there
09:54:33 <dankna> (of course I can't deepseq on a closure)
09:54:50 <dankna> it shouldn't be retaining this much data though, hmm
09:57:15 <Athas> Has the Haskell Xlib binding been abandoned?  It hasn't been changed in over a year, and I see various small projects that try to add the missing bits.
10:05:17 * hackagebot hakyll 3.1.2.1 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.2.1 (JasperVanDerJeugt)
10:08:25 <soloma> hi! Advise me book to start!)
10:08:36 <notyy> hello,  I am trying to cabal install wxHaskell (http://hackage.haskell.org/package/wx-0.12.1.6), after downloaded packages,it complains wx-config:does not exist and then Exit failure 1
10:08:37 <Twey> @where book
10:08:38 <lambdabot> I know nothing about book.
10:08:40 <Twey> :<
10:08:43 <djahandarie> @where layh
10:08:43 <lambdabot> I know nothing about layh.
10:08:49 <djahandarie> Double fail
10:08:51 <djahandarie> @where lyah
10:08:51 <lambdabot> http://www.learnyouahaskell.com/
10:08:52 <Twey> soloma: http://book.realworldhaskell.org/ http://www.learnyouahaskell.com/
10:09:10 <soloma> Oh, thanks
10:09:16 <dcoutts> notyy: you need the wx C libs installed
10:09:25 <djahandarie> soloma, start with Learn You a Haskell first
10:09:26 <notyy> ah....
10:09:46 <notyy> you mean wxWidget must be installed first?
10:09:46 <dcoutts> notyy: wx-config is the program that comes with the wx C libs that tells other systems how to compile and link against wx
10:09:47 <djahandarie> soloma, feel free to take a look at Real World Haskell shortly afterwards though. Different teaching styles / aims.
10:09:53 <dcoutts> notyy: yep
10:10:03 <notyy> thank you very much
10:10:41 <luite> notyy: which operating system do you use?
10:10:47 <notyy> win 7
10:11:24 <soloma> djahandarie, thanks for way (is it sounds awkward? =) )
10:11:43 <soloma> *does -s
10:12:02 <luite> notyy: ah in that case you probably want to download the windows installer from their site :)
10:12:06 * lispy tries to think how he would say it.  "thanks for the advice" ?
10:12:08 <djahandarie> Yes, so awkward that I can't tell what you're saying. :p But you're welcome either way!
10:12:32 <djahandarie> 'Thank you for providing some direction' 'Thank you for the guidance' etc.
10:13:06 <lispy> notyy: are you pretty new to haskell?
10:13:20 <lispy> notyy: Do you know some other programming languages?
10:13:44 <luite> notyy: note that wxwidgets and gtk are relatively easy to install for windows, but other packages are more difficult. if you already have a dual boot system with linux, and you're familiar with linux and installing packages, then it's probably easier to use that
10:14:06 <notyy> I used to programming in java
10:14:12 <notyy> new to haskell
10:14:44 <lispy> notyy: What tools/editors did you use with java?
10:15:06 <notyy> lispy:eclipse
10:15:34 <lispy> notyy: You might find this useful: http://eclipsefp.sourceforge.net/
10:15:38 <djahandarie> Oh by the way, I avoided the dynamic executable by compiling with -threaded -optl-static
10:15:45 <lispy> notyy: I haven't tried it myself so I can't say how well it works.
10:16:00 <soloma> what tools is convenient for programming with Haskell? (my system is linux)
10:16:10 <luite> soloma: emacs
10:16:12 <luite> :)
10:16:19 <soloma> heh
10:16:29 <argiopeweb> luite++
10:16:30 <lispy> soloma: I use vim/emacs, bash, ack, find, and cabal-dev.
10:16:34 <notyy> lispy:I just installed leksah,and build ah hello,world,haha
10:16:40 <Silvah> luite--
10:16:43 <luite> hehe
10:16:49 <luite> flamewar++
10:16:49 <lispy> notyy: oh cool!  More leksah users :)
10:16:53 <argiopeweb> Silvah: :(
10:17:20 <Silvah> argiopeweb: he mentioned emacs.
10:17:22 <soloma> mmm, it was wrong request)) I think i will continue vi-using
10:17:24 <argiopeweb> lispy: ++ to you as well. Grep also tends to be useful.
10:17:27 <lispy> soloma: There is a hask-tags command/mode in emacs that can help you find symbols
10:17:35 <argiopeweb> Silvah: The best editor?
10:17:35 <soloma> but which compiler/interpreter Is modern?
10:17:51 <luite> soloma: ghc is pretty much the only one
10:17:54 <lispy> argiopeweb: Yeah, grep can be nice but I use ack whenever I can as it has more smarts baked in
10:18:01 <luite> unless you're doing language research
10:18:05 <lispy> soloma: GHC
10:18:17 <Silvah> argiopeweb: only if you have twenty hands.
10:18:26 <jfmiller28> @pl \o -> runObject o >>= return . Reference
10:18:26 <lambdabot> (Reference `fmap`) . runObject
10:18:40 <soloma> ok, now gonna "smoke mans")
10:18:43 <argiopeweb> Silvah: Now you're discriminating against me because I have 20 hands...  The nerve.
10:18:46 <argiopeweb> :P
10:19:16 * jmcarthur likes emacs
10:19:19 <jmcarthur> do i lose karma too!
10:19:20 <notyy> lispy:I am trying to learn some client side programming,and leksah+ghci works fine
10:19:22 <jmcarthur> *?
10:19:36 <luite> soloma: which distribution do you have?
10:19:38 <argiopeweb> Really though, you only need large hands with 6 fingers on each.
10:20:05 <lispy> notyy: Cool.  Do you blog about it?
10:20:06 * jmcarthur tries to think of a keyboard shortcut in emacs that requires more than two fingers
10:20:07 <dankna> you also need Intel's new high-speed interconnect that gives you tighter coordination between the nerve centers in your left and right elbows =p
10:20:12 <jmcarthur> i can think of only one right now
10:20:13 <shash> i want help
10:20:19 <argiopeweb> jmcarthur: There isn't one.
10:20:27 <argiopeweb> In the standard set*
10:20:27 <dankna> I hate key chords :(
10:20:30 <dankna> hate them hate them hate them
10:20:34 <notyy> not yet...
10:20:35 <jmcarthur> M-%
10:20:38 <shash> import IO import Prelude   -- Start of the application	  main ::IO () main = showTitle  -- Shows the Main Display  showTitle::IO() showTitle = do  putStrLn "**********************************************************************************************************" putStrLn "                              KUALA LUMPUR HOSPITAL MANAGEMENT SYSTEM" putStrLn "*********************************************************************************
10:20:39 <dankna> ummmmmm, C-M-anything
10:20:42 <argiopeweb> I stand corrected.
10:20:51 <argiopeweb> Xmonad messes that one up for me, so I don't just it much anymore.
10:20:55 <jmcarthur> dankna: i can't think of any C-M- shortcuts
10:21:11 <dankna> yes, well, neither can I, but I recall the tutorial pointing them out to me, moons ago
10:21:17 <argiopeweb> dankna: Meh, modifiers on the bottom row don't count...
10:21:17 <dankna> I can't /remember/ any C-M- shortcuts
10:21:19 <jmcarthur> argiopeweb: i have my xmonad mod key set to my otherwise useless windows key
10:21:26 <argiopeweb> C-M- == 1 modifier.
10:21:27 <lispy> shash: we're happy to help but when you want to paste something to us, please use hpaste.org and then give us the url.  Otherwise the channel fills up too fast :)
10:21:30 <shash> can any help me in this
10:21:32 <dankna> I have enough trouble remembering which is a C- shortcut and which is an M-shortcut
10:21:36 <shash> KUALA LUMPUR HOSPITAL SYSTEM.hs:24:18: parse error on input `=' [1 of 1] Compiling Main             ( KUALA LUMPUR HOSPITAL SYSTEM.hs, interpreted ) Failed, modules loaded: none.
10:21:40 <shash> what is this error
10:21:46 <dankna> you can't put spaces in filenames
10:22:06 <Silvah> Whatever...
10:22:08 <Silvah> luite++
10:22:17 <luite> whoah
10:22:20 <argiopeweb> jmcarthur: I shoult probably do that...
10:22:30 <luite> but I deserved the -- for mentioning emacs!
10:22:39 <shash> KUALA LUMPUR HOSPITAL SYSTEM.hs:24:18: parse error on input `=' [1 of 1] Compiling Main             ( KUALA LUMPUR HOSPITAL SYSTEM.hs, interpreted ) Failed, modules loaded: none.
10:22:42 <argiopeweb> luite: Be not ashamed of your editor.
10:22:45 <shash> spacing ..still
10:22:48 <argiopeweb> shash: Stop doing that...
10:22:58 <lispy> shash: We can't see line 24 of your program.  Please use hpaste.org
10:23:02 <shash> can any1 help me with tat error
10:23:04 <argiopeweb> shash: If you have a question, post errors + code on hpaste.org
10:23:38 <Silvah> dankna: putting spaces in filenames works for me actually.
10:24:05 <dankna> argiopeweb, it might be one logical key, but C-M-whatever takes three fingers (isn't the "scroll other window backwards" key C-M-something?)
10:24:07 <jmcarthur> i don't know what you would name a non-Main module in a filename with spaces though
10:24:27 <shash> http://hpaste.org/46660/shashnk
10:24:43 <luite> lol
10:24:45 <dankna> pretending it's one key is essentially an accounting trick and does nothing to make it possible for a normal person to type
10:24:55 <luite> shash: paste the rest of the code
10:25:02 <jmcarthur> dankna: also remember that you can just use the escape key instead of M-
10:25:06 <luite> shash: use "annotate paste" to add it
10:25:15 <dankna> jmcarthur: Escape is hard to type and Emacs doesn't let me use C-[ instead
10:25:23 <dankna> (an old vi trick)
10:25:28 <argiopeweb> dankna: C-M == thumb + pinky, and you still have 3 fingers free for the left side of the keyboard and 5 for the right.
10:25:34 <dankna> thumb?
10:25:35 <dankna> thumb?
10:25:36 <shash> http://hpaste.org/46661/shashnk__annotation
10:25:41 <argiopeweb> Though I have a small keyboard (laptop), so your mileage may vary.
10:25:48 <dankna> I should mention that I'm left-handed
10:26:04 <argiopeweb> danharaj: You use the right C-M?
10:26:06 <dankna> C-M = move entire left hand to use middle and index finger
10:26:16 <dankna> (my pinky isn't strong enough to depress them)
10:26:22 <jmcarthur> oh i just move my thumb off the space bar
10:26:22 <shash> wats d error ?
10:26:26 <argiopeweb> Get a lower profile keyboard?
10:26:28 <lispy> shash: It's failing to parse because the indentation is wrong
10:26:29 <dankna> I have a laptop
10:26:32 <dankna> I can't change keyboards
10:26:34 <luite> shash: you need to indent the putStrLn lines, and also the showSecializeDoctor call
10:26:54 <lispy> shash: http://learnyouahaskell.com/chapters
10:26:55 <jmcarthur> if you have a weak pinky you shouldn't be using emacs :P
10:27:01 <argiopeweb> jmcarthur: ...
10:27:12 <argiopeweb> I think that's the point of this conversation. XD
10:27:17 <Perlkonig> OK, so I'm trying to write a more efficient Totient function. I'm using the method explained on wikipedia. I decided to use Ratio so I don't lose precision. But I'm getting an "infinite type" error. http://hpaste.org/46662
10:27:18 <dankna> that was my point, yes
10:27:47 <dankna> Emacs requires both a better memory than mine (and I tested with a digit span of 14 not that many years ago, mind you!)
10:27:48 <shash> <lispy> how
10:27:51 <dankna> and more manual dexterity
10:27:56 <argiopeweb> That being said, why is your dominant pinkie too weak to push down a key?
10:27:58 <dankna> despite hating it, I used it exclusively for about five years
10:28:03 <jmcarthur> Perlkonig: your return type is not really 'a'
10:28:14 <dankna> argiopeweb: I dunno, I don't get a lot of exercise ^^'
10:28:23 <jmcarthur> oh wait
10:28:26 <dankna> it's not that it can't push the key, it's that it's slower and I tend to fumble
10:28:27 <argiopeweb> dankna: Use emacs. It's good pinkie exercise. :D
10:28:30 <jmcarthur> Perlkonig: nevermind, i misread. i'll reread
10:28:30 <dankna> haha
10:28:36 <Perlkonig> thanks, jmcarthur
10:28:40 <dankna> as I just said, I did use Emacs for a long time because it had killer features for me
10:28:44 <lispy> shash: This article explains the indentation: http://en.wikibooks.org/wiki/Haskell/Indentation
10:28:44 <argiopeweb> But yes, I can see how that'd be an issue.
10:28:47 <dankna> but I managed to wean myself off them
10:29:05 <dankna> I really want a modal editor with live key help
10:29:25 <jmcarthur> Perlkonig: compare the type of n with the type of acc
10:30:13 <Perlkonig> jmcarthur: How do I do that if GHCI won't load the code?
10:30:19 <jmcarthur> in your head
10:30:26 <Perlkonig> hehe
10:30:56 <Perlkonig> from GHCI I seem to be able to multiply an int with a ratio
10:30:58 <jmcarthur> when writing code you should always be mindful of the intended types of all your variables
10:30:58 <Perlkonig> it just returns a ratio
10:31:06 <jmcarthur> that isn't just an int
10:31:13 <jmcarthur> > 5 :: Ratio Integer
10:31:15 <lambdabot>   5 % 1
10:31:40 <jmcarthur> > (5 :: Ratio Integer) * (5 :: Integer) --fail
10:31:40 <lambdabot>   Couldn't match expected type `GHC.Real.Ratio
10:31:40 <lambdabot>                               ...
10:31:48 <Perlkonig> so instead of passing n as the accumulator, I have to pass (n % 1)
10:32:10 <jmcarthur> you could say fromIntegral, but yeah that's the idea
10:32:26 <jmcarthur> *fromIntegral n
10:32:54 <jmcarthur> > fromIntegral 5 :: Ratio Integer
10:32:55 <lambdabot>   5 % 1
10:33:16 <jmcarthur> > fromIntegral (5 :: Integer) :: Ratio Integer
10:33:16 <Perlkonig> I *will* get this eventually :) I haven't had to worry about types when programming for a very long time. This has been a frustrating but rewarding experience learning Haskell.
10:33:16 <lambdabot>   5 % 1
10:33:39 <dankna> yeah - Haskell detects very subtle mistakes in its typesystem
10:33:41 <jmcarthur> oh you worried about types before as well, you just didn't call the idea "types" ;)
10:33:47 <KirinDave> Does anyone have a nice tutorial, preferably even a nice friendly folksy blog post, about lenses?
10:33:53 <jmcarthur> and you may have relied on some implicit conversions
10:34:00 <Perlkonig> I did...often :)
10:34:02 <KirinDave> This seems like an important deal
10:34:06 <Perlkonig> Thanks again for the help.
10:34:06 <dons> KirinDave: hmm. there was one recently. byorgey perhaps?
10:34:07 <Athas> dons: are you still the maintainer of the Xlib binding?
10:34:12 <dons> KirinDave: check the haskell reddit logs
10:34:23 <dons> Athas: sjanssen i thiiink
10:34:25 <dons> sjanssen: ^^
10:35:14 <dons> ah, cdsmith it was
10:35:24 <dons> http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/  ;
10:35:31 <dons> not so beginner, http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
10:35:33 <byorgey> KirinDave: wasn't me, but you might want to check out http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation
10:35:34 <dons> :)
10:35:40 <dons> also that
10:35:58 <KirinDave> Awesome, thanks!
10:36:16 <Perlkonig> Well that totient function is blazing fast compared to the "length of a list" solutin
10:36:21 <dons> seems like something byorgey would write...
10:36:35 <byorgey> dons: hehe, thanks =)
10:36:49 <byorgey> KirinDave: there's also a very nice introduction here: http://twanvl.nl/blog/haskell/overloading-functional-references
10:36:57 <byorgey> I would actually start with that one
10:37:04 <KirinDave> On it. Ty!
10:37:21 <byorgey> he calls them "functional references" instead of "lenses" but it's the same thing
10:38:15 <shash> http://hpaste.org/46663/shashnk__annotation
10:38:21 <KirinDave> Potato, pohtahtoe
10:39:14 <shash> http://hpaste.org/46663/shashnk__annotation
10:39:21 <lispy> shash: looks much better except, you really shouldn't use tabs.  It will lead to subtle issues with layout.
10:39:21 * hackagebot xmlhtml 0.1.4 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.4 (DougBeardsley)
10:39:49 <shash> <lipsy> wats the solution ..should i nt use tabs ?
10:40:11 <lispy> shash: You need to use regular spaces instead of tabs.  How to do that depends on your editor.
10:40:25 <shash> i use notepad++
10:40:35 <shash> can any help me with better editer ?
10:40:35 <lispy> I'm unfamiliar with it :(
10:40:45 <quicksilver> byorgey: lol @ "However, its choice of internal representation makes me throw up in my mouth a little bit"
10:40:45 <lispy> shash: Try leksah?
10:41:00 <byorgey> quicksilver: hehe, yeah =)
10:41:25 <shash> <lipsy> thankz
10:41:40 <byorgey> @where leksah
10:41:40 <lambdabot> http://www.leksah.org/
10:42:11 <monochrom> notepad++ is good enough
10:42:15 <lispy> shash: you're welcome.  I hope you enjoy learning haskell!
10:42:43 <lispy> monochrom: I hope so, but shash's question was how to configure it for Haskell.  I don't know how.
10:42:45 <quicksilver> @remember edwardk [on data-accessor] However, its choice of internal representation makes me throw up in my mouth a little bit
10:42:45 <lambdabot> Okay.
10:45:46 <shash> which compiler is good --WINGHCI ??? OR GLASGOW ??
10:46:02 <monochrom> same thing
10:46:24 <monochrom> the "g" in "winghci" is indeed "glasgow"
10:49:53 <shash> THIS CHAT APPLICATION IS MADE IN HASKELL LANGAUGE ???
10:50:02 <luite> shash: no
10:50:04 <argiopeweb> Dude... Caps.
10:50:27 <luite> shash: it's standard irc chat, you can use any irc client, just point it to irc.freenode.net and #haskell
10:51:17 <shash> how can we make gui haskell programs like button
10:52:19 <shash> how can we make gui haskell programs like buttons ?
10:52:22 <luite> shash: by using a gui toolkit, like gtk or wxwidgets, but I'd suggest making non-gui programs for a while before you try your hand at hat
10:53:05 <shash> this gui toolkit is nt in winghci ???
10:53:24 <luite> shash: no, you have to install it separately
10:53:53 <aristid> shash: relax, man. no need to use so many question marks or big letter text
10:54:04 <luite> hehe
10:54:21 <shash> ok
10:55:16 <luite> shash: install the haskell platform first, and read learn you a haskell for great good
10:55:36 <mwc> What's the story with all the Iteratee-IO libraries? Have we develped a new cottage industry to go along with writing monad tutorials?
10:57:16 <dons> lots of prototypes to try to find a good apii
10:57:39 <mwc> The new IterIO pipe-based one matches how I tried to use the API previously
10:58:06 <Luke> anyone having problems with cabal on ubuntu 11.04? "cabal: Codec.Compression.Zlib: premature end of compressed stream"
10:59:35 <argiopeweb> Luke: Wait, serious users actually use Ubuntu? :P
10:59:54 <dankna> Luke: sounds like versioning problem on the C zlib
10:59:57 <dankna> +a
10:59:57 <Luke> I wouldn't call myself a serious user
11:00:22 <dcoutts> Luke: most likely just a http download failure
11:00:25 <argiopeweb> Luke: If you're developing on Linux, you're serious enough.
11:00:43 <dcoutts> Luke: e.g. the file got truncated on download
11:01:01 <dankna> I've also seen "premature end of compressed stream" with a versioning issue
11:01:08 <dcoutts> Luke, dankna: a zlib version issue would have a different error message
11:01:14 <Luke> hmm
11:01:20 <Luke> any ideas how to work around?
11:01:22 <dankna> would it?  I swear I've seen that message
11:01:26 <dankna> could be misremembering
11:01:43 <dcoutts> Luke: just try downloading it again, you can use -v3 to see the http messages
11:01:45 <glguy> Does anyone have a reference as to why Generalized Newtype Deriving is unsafe?
11:02:05 <merijn> If there's an md5 sum you could verify whether the file was indeed corrupted during download
11:02:09 <MasseR> What does ($!) do?
11:02:10 <dcoutts> dankna: zlib has a specific error code for that and it happens as soon as you create the decompressor zstream
11:02:18 <merijn> :t ($!)
11:02:19 <lambdabot> forall a b. (a -> b) -> a -> b
11:02:30 <glguy> ?src $!
11:02:30 <lambdabot> f $! x = x `seq` f x
11:02:41 <dankna> dcoutts: it's just that I remember getting a misleading zlib message when trying to build a darcs version of darcs some months ago
11:02:42 <MasseR> ?src $
11:02:42 <lambdabot> f $ x = f x
11:02:47 <merijn> MasseR: Strict function application, apparently :)
11:02:58 <dankna> dcoutts: I'm sure the C-level library has a specific error code, but that doesn't mean the Haskell binding checks it
11:02:59 <MasseR> Apparently yeah :P
11:03:03 <dcoutts> dankna: it's not totally impossible, but I'd be very surprised and want to know how it happend
11:03:13 <dankna> dcoutts: that's fair.
11:03:21 <dcoutts> dankna: oh but the Haskell binding does check it, I wrote that bit of code ;-)
11:03:32 * dcoutts also tested it with a wrong version of zlib
11:03:34 <dankna> oh haha :D
11:03:36 <dankna> okay then
11:03:46 <dankna> if you wrote it, I retract my speculation
11:03:53 * dcoutts grins
11:05:09 <Luke> apparently there's a bug in the http library that cabal is using and can't go through my proxy
11:05:20 <Luke> i have to upgrade all this crap from source
11:05:31 <dankna> ohhhhhh that's where I saw it!  ManateeLazyCat had that problem
11:05:36 <dankna> I confused his error message with my error message
11:06:00 <dankna> nobody seemed very interested in helping him diagnose it, can't imagine why
11:07:24 * hackagebot monadIO 0.10.1.1 - Overloading of concurrency variables  http://hackage.haskell.org/package/monadIO-0.10.1.1 (TrevorElliott)
11:07:50 <dankna> hmmmm
11:07:59 <dankna> so I try to deepseq my data structure and CPU goes to 100% ><
11:08:20 <dankna> I guess the most likely explanation is that I inadvertently used deepseq instead of seq somewhere in one of my NFData instances
11:08:24 * hackagebot orc 1.2.1.1 - Orchestration-style co-ordination EDSL  http://hackage.haskell.org/package/orc-1.2.1.1 (TrevorElliott)
11:09:19 <dankna> http://hpaste.org/46664/is_this_the_correct_way_to_wri -- is this the correct way to write a deepseq instance for a record type?
11:09:37 <dankna> as I see it, I need to first force evaluation of the actual record, so I call seq on that (not deepseq to prevent unbounded recursion),
11:09:48 <dankna> then I need to recurse into each field so I call deepseq on those in turn
11:10:09 <dankna> not sure if the initial seq actually does anything, but it doesn't seem like it would hurt
11:10:11 <k0ral> is there any kind of official dedicated forums to ask questions about haskell ?
11:11:56 <glguy> dankna: I think that if you have exactly one field in your type you should write: rnf x = rnf (accessor1 x)
11:12:19 <dankna> glguy: hmm
11:12:39 <glguy> If you'd like to see why, check out the instances for tuples in http://hackage.haskell.org/packages/archive/deepseq/1.1.0.0/doc/html/src/Control-DeepSeq.html#rnf
11:12:41 <dankna> so you think the initial reference to x is spurious
11:12:47 <dankna> looking
11:13:09 <glguy> rnf (Just x) = rnf x
11:13:28 <dankna> oh weird - it actually does provide an instance for (NFData a) => Maybe a
11:13:32 <dankna> why did I have to write my own then
11:13:51 <dankna> maybe I didn't have to and should take it out, haha
11:13:56 <glguy> instance NFData a => NFData (Maybe a)
11:14:02 <glguy> perhaps you didn't have an instance for 'a'
11:14:09 <dankna> yes, I mis-typed that, but I figured you knew what I meant
11:14:39 <dankna> yes, very likely that's what it was trying to tell me and I provided the Maybe instance first, then later on got the same message again but understood it correctly but didn't make the conneciton
11:14:51 <glguy> Ah, this would have been a better example for a type with accessors: rnf x = rnf (numerator x, denominator x)
11:14:51 <dankna> oh hmmm
11:14:56 <dankna> okay, so I see the example now
11:15:16 <dankna> rnf field1 record `seq` rnf field2 record
11:15:23 <dankna> that reads better than my way anyhow
11:16:15 <dankna> thanks!
11:22:29 <ozataman> can ghci load static C libraries? (.a files)
11:23:34 <dankna> no, nor can any other program
11:23:51 <dankna> I don't grasp quite why this is, but it is my understanding that static libraries do not contain the information necessary to link them at runtime
11:23:56 <dankna> despite the fact that you can link them statically
11:24:31 <Jafet> I assume it's more like, you can't jump into them
11:30:27 * hackagebot scyther-proof 0.3.0 - Automatic generation of Isabelle/HOL correctness proofs for security protocols.  http://hackage.haskell.org/package/scyther-proof-0.3.0 (SimonMeier)
11:31:51 <ozataman> dankna: right.. but I was wondering if there'd be a way to get ghci to use them somehow when I issue the ":l SomeFile.hs" command, for example
11:32:14 <dankna> it's my understanding that it's not possible due to the way dynamic linking works (in all languages, not just in Haskell)
11:32:23 <dankna> I would not be amazed to find that I'm misinformed and it's just not implemented
11:32:33 <dankna> since it does /seem/ like it should be possible
11:33:09 <dankna> note that depending on what you're doing, your needs may be served by passing -lfoo to ghci from the shell
11:34:08 <ozataman> dankna: tried that.. I'm trying to use bos' new mysql-simple package.. it works fine when compiling with ghc, but complains about not being able to find the libmygcc.dylib at runtim with ghci. on OS X, there is no libmygcc.dylib, only a libmygcc.a
11:34:43 <dankna> oh, in that case
11:35:15 <dankna> append the full path of libmygcc.a to the ghci command line
11:35:33 <dankna> effectively making ghci treat the archive as an object file to link against
11:41:30 <ski> jmcarthur,argiopeweb,dankna : `C-M-q',`C-M-f',`C-M-b',`C-M-u',`C-M-d',`C-M-SPC',`C-M-k' ..
11:41:33 <ski> lispy : what is `ack' ?
11:42:05 <ski> (KirinDave : (re "Potato, pohtahtoe") is that perchance from SLAY Radio ?)
11:42:09 <djahandarie> ACK?
11:42:22 <dankna> ski: thank you
11:42:25 <dankna> I knew there were many
11:42:41 <dankna> I just can't remember them, for the obvious reason that they're hard to remember!
11:42:59 <mauke> ski: http://betterthangrep.com/
11:46:28 <ski> dankna : the only one i had to look up was `C-M-SPC' (i didn't recall how to write `SPC') ..
11:46:48 <dankna> haha
11:46:51 <dankna> I see
11:47:20 <ski> `C-M-f',`C-M-b',`C-M-u',`C-M-d' are more or less obvious
11:47:33 <ski> `C-M-k' and `C-M-SPC' are sensible
11:47:40 <ski> `C-M-q' you have to just learn
11:48:05 <ski> (also, you could try paredit)
11:48:10 <dankna> I love paredit
11:48:24 <ski> @where paredit
11:48:24 <lambdabot> I know nothing about paredit.
11:48:25 <dankna> I'm trying to help someone else around here whose name I forget but I have it written down
11:48:37 <dankna> with his project to do the same but for any language
11:48:48 <dankna> that's been a long-term project of mine, but I always assumed it involved a parser
11:49:06 <dankna> he's taking a generative approach - don't store the files as plaintext, store them as a database, exporting to plaintext only when they need to be compiled
11:50:10 <Jafet> Isn't paredit a mode to make lisp look more like haskell?
11:50:27 <ski> @where+ paredit Minor Emacs mode for editing parentheses at <http://mumble.net/~campbell/emacs/paredit.html>,<http://mumble.net/~campbell/emacs/paredit.el> by Taylor R. Campbell (Riastradh)
11:50:28 <lambdabot> I will never forget.
11:50:29 <dankna> no, it's a structure editor for Lisp
11:50:41 <dankna> it does nothing to reorganize the code or change its presentation
11:50:55 <dankna> "structure editor" means two things:
11:50:57 <merijn> dankna: You mean the treeedit thing? I have been studying it a bit as well, but haven't had enough time to really dive in and grok everything yet
11:51:02 <dankna> the movement primitives work in lexical units instead of characters
11:51:04 <dankna> merijn: yes that
11:51:28 <dankna> and the code is always in a syntactically-valid state (possible with Lisp syntax; for other languages you have to introduce the concept of "holes")
11:51:33 <ski> s/Lisp/Sexps/
11:51:37 <dankna> yes
11:51:43 <aristid> that's a big benefit of the mostly regular syntactic structure of lisp, i guess
11:51:44 <ski> and XML (more or less) as well, iirc
11:51:58 <dankna> it is.  that and no wars over indentation.
11:52:02 <merijn> I showed a few people at university the python prototype and everyone's reaction is "omg, I need that so bad!" ;)
11:52:04 <dankna> yes, nxml-mode is the same thing for XML
11:52:09 <dankna> merijn: cool :D
11:54:48 <ski> (merijn : python prototype of what ? paredit ? where ?)
11:56:06 <dankna> the system I just described that keeps the code in a database - it's called treeedit
11:56:13 <dankna> (it needs a renaming, as it has three "e"s in a row)
11:57:23 <merijn> ski: Of treeedit (the editor dankna was talking about)
12:03:18 <ski> merijn : ok
12:04:14 <ski> (heh, maybe `tree-edit', then ?)
12:06:08 <dankna> ski: I suggested tredit, but tree-edit is okay too
12:06:18 <dankna> or even te, to be easier to type
12:06:33 <dankna> anyway, the first task is to write it; we can name it later!
12:07:21 <Jafet> > map last . sort $ zipWith (++) . tails <*> init.inits $ "treeedit"
12:07:26 <lambdabot>   mueval: ExitFailure 1
12:07:26 <lambdabot>  mueval-core: Time limit exceeded
12:07:55 <dankna> what was that meant to do? O_o
12:07:56 <Jafet> @slap lambdabot
12:07:56 * lambdabot locks up lambdabot in a Monad
12:07:56 <ski> @let init1 = init . inits
12:07:58 <lambdabot>  Defined.
12:08:13 <ski> hum, i suppose that ought to have been `inits1'
12:08:15 <Jafet> > map last . sort $ zipWith (++) . tails <*> init.inits $ "treeedit"
12:08:15 <ski> @define
12:08:18 <lambdabot>   "eeerdtti"
12:08:22 <dankna> haha
12:08:24 <ski> @let inits1 = init . inits
12:08:25 <lambdabot>  Defined.
12:08:26 <Jafet> Okay, not helpful.
12:08:40 <Jafet> > map last . sort $ zipWith (++) . tails <*> init.inits $ "tree-edit\n"
12:08:42 <lambdabot>   "teee-rdti\n"
12:08:43 <dankna> you were hoping that sorting the letters alphabetically would somehow ...
12:08:57 <dankna> suggest a better name?
12:09:12 <ski> > inits1 "abcd"
12:09:13 <lambdabot>   ["","a","ab","abc"]
12:09:43 <ski> hum
12:10:00 <Jafet> @let bwt = map last . sort . (zipWith (++) <$> tails <*> inits1)
12:10:01 <lambdabot>  Defined.
12:10:06 <ski> @define
12:10:21 <ski> @let inits1 = tail . inits; tails1 = init . tails
12:10:21 <lambdabot>  Defined.
12:10:42 <m4XXX> wow a labdabot.. nice
12:10:44 <ski> > bwt "abcd"
12:10:45 <lambdabot>   "abcd"
12:11:06 <dankna> @let btw = "Did I ever tell you about my cousin Meg?"
12:11:07 <lambdabot>  Defined.
12:14:01 <luite> > bwt btw
12:14:02 <lambdabot>   Not in scope: `btw'
12:18:01 <stepkut> is there a type class like this around already, class GenInteger m where nextInteger :: m Integer
12:18:07 <ski> > (map fst . filter (uncurry (/=)) . (zip `ap` (uncurry (++) . (tail &&& ((: []) . head))))) "treeedit"
12:18:09 <lambdabot>   "tredi"
12:18:26 <ski> hum .. not quite right
12:18:31 <Jafet> stepkut: class Random a
12:18:43 <ski> @src Random
12:18:43 <lambdabot> class Random a where
12:18:43 <lambdabot>   random    :: RandomGen g => g -> (a, g)
12:18:43 <lambdabot>   randoms   :: RandomGen g => g -> [a]
12:18:43 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
12:18:43 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
12:18:45 <lambdabot>   randomRIO :: (a,a) -> IO a
12:18:47 <lambdabot>   randomIO  :: IO a
12:18:54 <ski> @src RandomGen
12:18:54 <lambdabot> class RandomGen g where
12:18:54 <lambdabot>    next     :: g -> (Int, g)
12:18:54 <lambdabot>    split    :: g -> (g, g)
12:18:55 <lambdabot>    genRange :: g -> (Int,Int)
12:19:07 <stepkut> Jafet: i am looking for something that supplies unique integers, not random ones
12:19:10 <Jafet> Or that
12:19:21 <ski> Jafet : .. btw, what was `bwt' supposed to do ?
12:19:32 <Jafet> Well, ghc has one, but m is always IO.
12:19:47 <stepkut> Jafet: Data.Unique?
12:19:55 <dankna> @where unique
12:19:56 <lambdabot> I know nothing about unique.
12:19:59 <ski> hm, isn't there something like `UniqueSupply' ?
12:20:01 <dankna> @hackage unique
12:20:01 <lambdabot> http://hackage.haskell.org/package/unique
12:20:03 <Jafet> Probably that
12:20:08 <dankna> not found, hmm
12:20:32 <dankna> @hackage value-supply
12:20:32 <lambdabot> http://hackage.haskell.org/package/value-supply
12:20:39 <dankna> there we go
12:22:12 <Jafet> ski: scramble letters around
12:24:27 <stepkut> hmm. value-supply looks nice. not sure it will work for me though
12:26:24 <stepkut> I am trying to create an instance like, (GenInteger m) => EmbedAsChild m JStat. value-supply could be used by a particular 'm' as a way of generating the unique integers
12:26:26 <AardMark> hey hey hey
12:26:56 <stepkut> but I don't want to force 'm' to be MonadIO m
12:27:00 <ski> @let twoMap :: (forall a. [a] -> [a]) -> ([[a]] -> [[a]]); twoMap f = f . map f
12:27:00 <lambdabot>   TypeOperators is not enabled
12:27:24 <ski> @slap lambdabot for not enabling `Rank2Types' at least
12:27:24 <lambdabot> I don't perform such side effects on command!
12:27:34 <AardMark> hehe
12:27:45 <stepkut> I can just create my own UniqueInteger class, but I wanted to make sure I wasn't missing something that already did the same thing :)
12:27:55 <Peaker> ski, how does that work? f and map f apply to the same type of input?
12:28:04 <Peaker> oh, the rank2, nm
12:28:15 <aristid> stepkut: Monad m => m a -- if you take that as a parameter, don't you already have got a supply?
12:28:49 <stepkut> aristid: how does 'Monad m' provide me a supply?
12:29:24 <aristid> stepkut: f supply = do a <- supply; myComputation a
12:30:17 <ski> Peaker : i would prefer `forall f. (forall a. [a] -> f a) -> ([[a]] -> f (f a))', but that wouldn't be as flexible as i'd like
12:30:31 <Peaker> hey, interesting to see you guys talking about treeedit :)
12:30:33 <aristid> stepkut: the Monad typeclass allows you to invoke supply when and as often as you like
12:31:17 <Peaker> dankna, the eventual name might be lotext.. my nickname around here is lotex (my last name lotem, pun about linus/linux), and in Hebrew "lo" is no, so "not text", or "non-textual editor"
12:31:30 <dankna> Peaker: oh cool, that's neat.
12:31:31 <stepkut> aristid: well, I have to work within the constraints of the exist class definition, class (Monad m) => EmbedAsChild m c where asChild :: c -> m [XML]
12:32:08 <stepkut> so, the only thing I can really do with my instance declaration is instance that 'm' have some way of providing me with a unique integer
12:32:24 <stepkut> instance (UniqueInteger m) => EmbedAsChild m JStat where ...
12:32:28 <ski> (Peaker : "around here" being in the treeedit dev/discussion ?)
12:32:37 <aristid> asChild :: EmbedAsChild m c => m TypeOfWhatYouNeedToBeSupplied -> c -> m [XML]?
12:32:49 <Peaker> ski, in my current/previous workplace
12:33:03 <ski> mhm
12:33:13 <stepkut> aristid: nope. can't change the type of 'asChild'
12:38:29 <balor> Can I get my app to tell me the source line number that's throwing an error :: [Char] -> a
12:39:02 <ski> stepkut : "but I don't want to force 'm' to be MonadIO m" .. would you need that, in the instance definition you can think of ?
12:40:58 <ski> balor : maybe <http://www.haskell.org/ghc/docs/latest/html/users_guide/assertions.html> is helpful ?
12:41:28 <balor> ski, thanks
12:43:34 <ski> (balor : also, make sure to only use the extra string argument for debugging and/or in I/O, not to compute supposedly pure results)
12:45:34 <aristid> @unmtl ReaderT s m a
12:45:34 <lambdabot> s -> m a
12:46:11 <aristid> is this a known/valid monad transformer? newtype XT s m a = XT (m s -> m a)
12:47:39 <pastorn> @unmtl ContT r m a
12:47:39 <lambdabot> (a -> m r) -> m r
12:48:15 <pastorn> @src ContT return
12:48:15 <lambdabot> return a = ContT ($ a)
12:48:32 <pastorn> ow... my head
12:49:08 <aristid> pastorn: so ContT is a more general version of that. hmm
12:49:16 <aristid> or wait, no
12:49:19 <doserj_> aristid: type XT s m a = ReaderT (m s) m a ?
12:49:38 <aristid> :t get
12:49:40 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
12:49:43 <aristid> :t ask
12:49:44 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
12:49:51 <aristid> :t join . ask
12:49:53 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, MonadReader (m (m a)) f, Functor f) => f (m a)
12:49:54 <pastorn> @src Cont return
12:49:54 <lambdabot> return a = Cont ($ a)
12:50:07 <pastorn> @unmtl Cont r a
12:50:08 <lambdabot> (a -> r) -> r
12:50:12 <aristid> :t join
12:50:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:50:21 <aristid> :t join ask
12:50:22 <lambdabot> forall (m :: * -> *) a. (MonadReader (m a) m) => m a
12:50:33 <pastorn> @src Cont callCC
12:50:33 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
12:50:34 * hackagebot lat 0.6 - Tool to track security alerts on LWN  http://hackage.haskell.org/package/lat-0.6 (MagnusTherning)
12:50:37 <aristid> doserj_: yeah, with join ask instead of normal ask
12:50:38 <pastorn> ouch!
12:51:08 <pastorn> @src Cont (>>=)
12:51:09 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
12:51:42 <pastorn> there! that's enough head ache material for one night...
12:51:57 <ski> aristid : i think it is a valid transformer .. i haven't seen it before
12:52:52 <pastorn> @type callCC
12:52:53 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
12:53:08 <ski> @unmtl ReaderT (m s) m a
12:53:08 <lambdabot> m s -> m a
12:53:26 <pastorn> wait... wtf is that b doing in there?
12:53:36 <ski> pastorn : .. what are you using `ContT' for ?
12:53:47 <pastorn> ski: i stopped with the T
12:53:53 <pastorn> it's difficult enough as it is
12:55:05 <ski> pastorn : a better typing for `callCC' is `forall m a. MonadCont m => ((forall b. a -> m b) -> m a) -> m a' (that's rank-3) .. see <http://www.haskell.org/ghc/docs/latest/html/users_guide/assertions.html> (by monochrom)
12:56:18 <ski> this version lets you decide the type `b' at each call of `k' in `callCC $ \k -> do ..k..', instead of having to have the same return type for all the uses of `k'
12:56:22 <pastorn> ski: what does assertion has to do with continuations?
12:56:37 <jmcarthur> early abort?
12:56:59 <ski> an alternative is `forall m a. MonadCont m => ((a -> m (forall b. b)) -> m a) -> m a' or `forall m a. MonadCont m => ((a -> m Void) -> m a) -> m a' .. i'm not sure whether this is more powerful, or incomparable
12:57:27 <ski> (in theory, it ought to be more powerful, but i'm not sure whether is with the current type system rules)
12:58:09 <ski> pastorn : no idea, pastorn started to talk about `Cont[T]'
13:02:06 <monochrom> the correct url is http://www.vex.net/~trebla/haskell/cont-monad.xhtml :)
13:03:06 <pastorn> monochrom: thanks, awesome :)
13:03:09 <sm> am I wrong, or has hakyll fallen prey to second system syndrome ?
13:03:17 <monochrom> otoh I learned it from a haskell wiki page... http://www.haskell.org/haskellwiki/MonadCont_done_right
13:03:26 <sm> the current version sounds more complicated and way more buggy than the olld
13:03:58 <ski> monochrom : oops, sorry, wrong paste buffer :/
13:04:09 * ski didn't even notice it ..
13:04:09 <monochrom> :)
13:04:32 <ski> pastorn : ^
13:26:34 <Luke> how do Control.Monad.Par , Control.Parallel, and Control.Concurrent all relate?
13:27:33 <thoughtpolice> Control.Concurrent is for executing IO actions concurrently - for example, forkIO'ing some computation.
13:27:53 <thoughtpolice> OTOH, monad-par (Control.Monad.Par) and Control.Parallel are pure, and expose primitives for parallelism
13:28:38 <thoughtpolice> Control.Parallel is the substrate monad-par is built on; monad-par basically adds more deterministic and dataflow-based model for parallel computation (the Par monad)
13:29:39 <thoughtpolice> control.parallel only exposes the 'par' and 'pseq' combinators - these are sufficient for building parallel programs, by annotating pure code, but the annotations can be a little hard to understand and get working correctly (mostly people are confused by pseq/seq distinction)
13:30:30 <thoughtpolice> there's also control.parallel.strategies, which is built on top of control.parallel, just like monad-par, but it doesn't expose a monadic interface, it exposes a different 'strategy' based interface (as you'd guess from the name) - it's just another model for writing parallel code
13:33:18 <Perlkonig> OK. So I have a list of 1 million tuples (Int, Float). I'm folding the list to find out which tuple has the largest second part. I'm confused as to why it's taking so long (I've waited 30 minutes with no joy). Creating the list takes no time. I'm using a strict fold. I wonder if I'm missing something that's killing the performance (I'm a n00b). http://hpaste.org/46669
13:34:33 <mauke> maximumBy (comparing snd)
13:35:30 <mauke> Perlkonig: how did you create the list?
13:35:41 <gwern> ah, mauke pulls it off - the infamous #haskell one liner
13:36:40 <Perlkonig> Sorry, reading up on maximumBy...I created the list with 2 small map functions
13:36:48 <Jafet> That was a straightforward one liner
13:36:56 <gwern> map? map doesn't create a list, it transforms a list
13:37:06 <gwern> map is not an unfold
13:37:10 <Luke> thoughtpolice: thanks a lot
13:37:29 <thoughtpolice> Luke: np
13:37:51 <Perlkonig> aye, I start with the list [1..1000000] and run 2 different maps to get the tuples I want. It's all but instant. It's the foldl1' that's taking forever.
13:38:19 <mauke> ...
13:38:19 <Luke> thoughtpolice: how do I get parallel arrays in GHC 7?
13:38:23 <Luke> DPH
13:38:24 <thoughtpolice> > maximumBy (comparing snd) $ zip ([1..1000000] :: [Int]) ([1000001..2000000] :: [Int])
13:38:25 <lambdabot>   *Exception: stack overflow
13:38:27 <gwern> @quote lazier
13:38:27 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
13:38:28 <thoughtpolice> :(
13:38:30 <thoughtpolice> works in my ghci
13:38:52 <thoughtpolice> Luke: DPH isn't "ready yet", but you can use repa, which works with GHC 7 pretty well now.
13:39:01 <Luke> awesome - thanks
13:39:10 <thoughtpolice> Luke: the whole DPH story is kind of confusing, but packages like repa, and vector, which are currently workable, are something of the basis for 'real' DPH in GHC
13:39:30 <thoughtpolice> which will have nice syntactic sugar, e.g. [:1..10:] for parallel arrays, etc
13:39:35 <mauke> Perlkonig: how do you know the list is created?
13:39:57 <Luke> right - thaks
13:40:00 <Luke> thanks
13:40:03 <thoughtpolice> Luke: i think the plans are that GHC 7.2 will be the first 'prime time' release of the DPH packages with GHC, i.e. "you can use it", although technically you've been able to use the DPH packages forever
13:40:07 <thoughtpolice> they're just hidden
13:40:12 <Luke> yeah nice
13:40:30 <thoughtpolice> i don't think the syntax sugar is there still, though
13:41:05 <thoughtpolice> so you'll have to rely on dph-par-prim etc to expose the 'primitive' parallel interface, which is still automatic, just a little more clunky
13:41:12 <Perlkonig> Sorry for the delay. I'm still learning how this all works, so I had to import a buch of stuff. I know the list is being generated  because I tested that part first. I can print the list out if I want.
13:41:16 <thoughtpolice> repa will do automatic parallelisation for you though, providing you just write the code
13:41:21 <thoughtpolice> (and it does it fantastically well too)
13:41:44 <Perlkonig> the maximumBy code is running now. We'll see if it's any faster. I'm not sure why a strict fold was taking so long to go over the elements of the list.
13:41:52 <thoughtpolice> actually, repa is built on dph-par-prim IIRC
13:41:58 <gwern> thoughtpolice: every technique works well on the problems the author publishes on...
13:42:05 <KirinDave> What is dph?
13:42:17 <fryguybob> Data Parallel Haskell?
13:42:19 <KirinDave> ah
13:42:21 <thoughtpolice> gwern: oh of course, i just used it for some tiny little examples of my own that I wrote and i thought it worked pretty well
13:42:23 <KirinDave> ty
13:42:30 <Botje> Perlkonig: are you running it in ghci or ghc?
13:42:35 <Perlkonig> ghci
13:42:47 <thoughtpolice> i also liked ben's beholder demo, it was neat seeing a haskell-backed obj-c app that did the stenciling/blurring etc
13:42:54 <Botje> ghc will be a lot faster :)
13:43:19 <gwern> thoughtpolice: I half expect that's what dph wll amount to - academic welfare as they publish more papers and discover that it only works well on rare problems and has bad corner cases etc
13:43:27 <Perlkonig> So if I just compile it and run it? So the command that I type in at the ghci command prompt, I simply add that to the .hs file as "main = "?
13:43:39 <ski> @type \f -> unfoldr (\xs -> case xs of [] -> Nothing; x:xs -> Just (f x,xs))  -- `map' is an `unfoldr', gwern
13:43:39 <lambdabot> forall t a. (t -> a) -> [t] -> [a]
13:43:47 <Botje> Perlkonig: with a print in front
13:43:48 <thoughtpolice> gwern: quite possible, it's a very ambitious project no doubt
13:43:55 <Botje> main = print $ foldl1' ...
13:44:01 <gwern> ski: noooo
13:44:06 <Botje> and then compile with ghc -O2 --make
13:44:06 <Perlkonig> thank you. Trying now.
13:46:15 <Perlkonig> wow, that executed almost instantly
13:46:25 <thoughtpolice> gwern: at the very least nice packages like vector have fallen out of all the work, and GHC has recieved a healthy bit of work itself to help keep DPH moving forward (like the big new inliner, etc.)
13:46:47 <Perlkonig> Thank you, all. So I can use ghci for all my testing and building up of the problem, but when it comes time to actually run the process, compile it. Lesson learned :)
13:47:58 <thoughtpolice> oh, and all of the nice SMP performance increases we see simon push out too :)
13:48:24 <ski> gwern : ?
13:48:51 <ski> maybe it has different strictness behaviour ?
13:51:58 <Botje> Perlkonig: pretty much. you'd be surprised what you can do in ghci before you have to compile, though
13:52:12 <osfameron> Perlkonig: heh, nice nick
13:52:55 <ddarius> You can also compile code and load the compiled code into GHCi and have mixed interpreted and compiled stuff.
13:53:55 <Perlkonig> osfameron: Thanks :)
13:54:30 <Perlkonig> Botje: I'm surprised by just about everything Haskell can do. My first foray into functional languages was Scheme. Haskell's burning my brain, but it's a good burn :)
13:54:44 <Perlkonig> ddarius: I'll have to read the docs and see how to do that. That sounds great.
13:55:32 <Botje> Perlkonig: glad you like it
13:55:33 <merijn> Perlkonig: It's quite possible that when you compiled with -O2 GHC managed to pull off some aggressive optimization which ghci could not or something to that effect
13:55:33 <ddarius> Perlkonig: If there are compiled object files, it will just use those.  You don't really need to do much.
13:55:52 <ddarius> Perlkonig: But I do recommend at least skimming the user's manual.
13:57:03 <Perlkonig> ddarius: Will do. I've only been playing for a few days, so there's *lots* more I need to read.
13:58:33 <notyy> hello,question about wxHaskell again,my browser says 404 error when visiting http://code.haskell.org/wxhaskell/  ,is this my network problem?or the site is down?
13:59:52 <dankna> neither - the package appears to not be hosted there under that name
14:00:14 <dankna> perhaps you wanted http://code.haskell.org/WxGeneric/ ?
14:00:21 <dankna> hmm, no
14:00:52 <Lemmih> dankna: How did it go?
14:00:53 <dankna> I've never used wxhaskell, but its homepage appears to be http://haskell.org/haskellwiki/WxHaskell (as listed on Hackage)
14:01:19 <notyy> yes, I read in its homepage: http://haskell.org/haskellwiki/WxHaskell/Building#Source_Release
14:01:26 <dankna> Lemmih: oh hi!  so it enters an infinite loop when it tries to deepseq, although the act of writing NFData instances reminded me that I actually have a closure deep in the data structure
14:01:43 <dankna> notyy: why are you trying to visit http://code.haskell.org/wxhaskell/, what do you expect to find there?
14:02:15 <dankna> Lemmih: I'm currently reducing the problem to confirm my suspicion that the infinite loop is caused by my instance on UArray Int Word8
14:02:16 <notyy> dankna:sample/HelloWorld.hs  ...
14:02:35 <dankna> notyy: if you just want the source, get it by doing "cabal unpack wxhaskell"
14:03:07 <Lemmih> dankna: You shouldn't need to deepseq an UArray.
14:03:16 <dankna> Lemmih: hmm
14:03:18 <notyy> let me try,thanks
14:04:07 <dankna> Lemmih: trying with the null instance on the UArray, then
14:04:37 <dankna> I figured I probably didn't need to, but it seemed harmless, heh
14:04:41 <dankna> but apparently it's not :)
14:06:09 <dankna> okay, yes, that was it, now I can finally try the deepseq test and see what happens
14:07:01 <notyy> dankna:graphic lib is unpacked successfully,but no sample there
14:07:44 <gwern> hm, may've forgotten to specify the example's inclusion in the .cabal
14:08:41 <Taslem> Should _ represent "undefined" in expressions?
14:08:49 <ddarius> No.
14:08:57 <Taslem> Why not?
14:09:14 <gwern> because undefined is 'undefined', not the wildcard '_'
14:09:14 <Jafet> If anything, undefined should be longer, and contain some uppercase.
14:09:25 <Taslem> Why, exactly?
14:10:10 <Jafet> Why don't you answer that for us?
14:10:16 <gwern> well, that's how the haskell 98 standard defines it. 'undefined' is how you spell undefined, rather than '_'
14:10:42 <Nereid> _ is a pattern
14:10:48 <parcs> undefined should be ‚ä• if anything
14:10:59 <Nereid> indeed
14:11:04 <Nereid> and you could probably make it that, too.
14:11:10 <Jafet> Flipping the bird at totality.
14:11:43 <parcs> i think it is in the base-unicode-symbols package
14:11:54 <Jafet> > ‚ä•
14:11:55 <lambdabot>   <no location info>: parse error on input `
14:12:03 <dankna> hmm, this test is reliably triggering the profiler bug I found :(
14:12:43 <Jafet> Not sure how it would work, because ‚ä• is punctuation.
14:12:53 <dankna> > `?`
14:12:54 <lambdabot>   <no location info>: parse error on input ``'
14:12:58 <dankna> > (?)
14:13:00 <lambdabot>   Not in scope: `?'
14:13:08 <dankna> > let (?) = undefined
14:13:09 <lambdabot>   not an expression: `let (?) = undefined'
14:13:12 <dankna> @let (?) = undefined
14:13:14 <lambdabot>  Defined.
14:13:16 <dankna> > (?)
14:13:18 <lambdabot>   *Exception: Prelude.undefined
14:13:23 <dankna> there you go
14:13:35 <Taslem> That works.
14:13:35 <dankna> it's puncuation, so you have to use operator syntax for it
14:13:39 <Jafet> Oh, now I remember. (‚ä•) is bottom.
14:13:51 <Taslem> Hm. Maybe you should be able to tell the compiler how to treat it.
14:13:56 <Jafet> Taslem: why do you want _ to stand for undefined?
14:13:58 <dankna> Unicode symbols are a little weird that way - for example, I sometimes want to name a variable starting with a capital delta, but I can't
14:14:27 <dankna> (because capital delta, despite its meaning in mathematic of "the change in ...", is also a capital letter, so it has to start a type or constructor, not a variable)
14:14:34 <Taslem> Well, undefined is given now value. In pattern matching, _ ignores the value. And since you never see _ in expressions, it doesn't produce ambiguity when defining it.
14:14:43 <Taslem> *no, not now
14:15:16 <merijn> What problem would this solve?
14:15:29 <dankna> the problem of us having to answer questions about it :)
14:15:41 <dankna> however, that's a very minor problem, probably limited to just this instance
14:16:55 <parcs> > let Œîx = 5 in Œîx
14:16:56 <lambdabot>   Not in scope: data constructor `
14:17:17 <parcs> shame‚Ä¶ that would be awesome
14:17:34 <dankna> Lemmih: Okay!  The deepseq does change the performance characteristics of the program: it makes the slowness happen earlier.  It does not eliminate the triangle heap-usage pattern, though.
14:17:44 <osfameron> ok, it can't be a coincidence that every time Smullyan says "This is quite simple" or similar, I feel the urge to go postal, can it?
14:17:56 <dankna> Lemmih: HOWEVER, I did the simple thing of not trying to recurse into the closure
14:18:15 <dankna> Lemmih: which kinda invalidates the whole thing... so now my next task is to kludge up a way for the program to run at all without that closure there
14:18:20 <dankna> osfameron, haha, yeah, indeed
14:18:20 <byorgey> osfameron: no. "This is quite simple" is always code for "I don't feel like explaining this"
14:18:34 <dankna> Smullyan's books are fun, but they make my head hurt
14:19:01 <osfameron> either I've misunderstood the pedagogy, or he's midjudged it
14:19:01 <ski> Jafet : hm, maybe it would be nice if `unamb _ x' was the same as `x' ..
14:19:14 <osfameron> the early puzzles are completely impossible
14:19:28 <osfameron> (though I'm now complaining about a later puzzle, so hey)
14:19:38 <Jafet> Now, don't you start
14:21:09 <ski> (.. and maybe it could be nice if `unamb' could be spelled infix as `@')
14:22:37 <ski> osfameron : heh, which puzzle are you pondering ?
14:23:13 <osfameron> ski: how to derive the bird C*.  Though I realise now that I misunderstood what he meant by "skip over X"
14:23:55 * ski was wondering whether it was any of the "coercive logic" puzzles
14:24:06 <osfameron> coercive logic?
14:25:29 <ski> given a specific proposition `P', device a question `Q' such that truthfully answering the question `Q' will simultaneously promise to ensure `P'
14:25:56 <ski> so if you get someone to promise to answer the next question truthfully, then you can coerce them into doing anything you want
14:26:18 <osfameron> heh. nice
14:26:31 <ski> (well, s/doing/promising to do/, of course)
14:26:36 <osfameron> I haven't gone over the logic problems at the beginning of the book this time
14:27:03 <ski> (i don't recall whether this was in the Mockingbird or the Sheherazadeh book)
14:27:05 <osfameron> I restarted it from the mockingbird chapters.  Perhaps I needed a warmup though (I don't remember if they included that kind of coercive logic)
14:27:05 <neaera> what book is this about?
14:27:26 <osfameron> neaera: well, I'm working through Mockingbird
14:27:28 <ski> neaera : one of Raymond Smullyans (popular logic) books
14:27:46 <osfameron> I'm beginning to find the metaphor a bit annoying, actually
14:28:14 <neaera> hm, nice, long time since i went through logics.. i want to take a fresh look at it one day
14:29:02 <osfameron> I find it really hard to do the "mathematical exploration" thing now (was much easier as a kid :-(
14:30:57 <dankna> Lemmih, and any interested parties: okay, I got the closure out.  it's still got the same allocation pattern.  so that means...  something else is holding onto an old state reference?
14:33:19 <ski> neaera : Raymond Merril Smullyan, "To mock a mockingbird : and other logic puzzles including an amazing adventure in combinatory logic","The riddle of Scheherazade and other amazing puzzles, ancient & modern"
14:34:10 <neaera> ski, nice, ill write this down.. thx
14:34:30 <ski> there also appears to be an "What is the name of this book : The riddle of dracula and other logical puzzles", which i haven't seen
14:34:52 * ski also found "Gˆdel's incompleteness theorems" interesting (but that isn't a "popular logic" book)
14:34:57 <Lemmih> dankna: Yeah.
14:35:35 <Perlkonig> Is there an idiomatic way to remove elements from the start of a list until you find a certain value?
14:35:38 <dankna> Lemmih: hmm.  obviously I can't expect you to solve all my problems for me, but I'm disappointed :)
14:36:09 <dolio> > dropWhile (/= 30) [1..40]
14:36:10 <lambdabot>   [30,31,32,33,34,35,36,37,38,39,40]
14:36:14 <Twey> Perlkonig: dropWhile . (/=)
14:36:16 <Perlkonig> Well, "remove" isn't the write word in a functional language. is there a way I can get what's left of a list after I've found a certain value.
14:36:20 <Perlkonig> Thank you!
14:36:42 <Twey> > let f = dropWhile . (/=) in f 3 [1, 2, 3, 4, 5]
14:36:43 <lambdabot>   [3,4,5]
14:37:10 <Twey> > let f = fmap (drop 1) . dropWhile . (/=) in f 3 [1, 2, 3, 4, 5]
14:37:12 <lambdabot>   [4,5]
14:37:43 <ski> neaera : also see "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" at <http://dkeenan.com/Lambda/> by David C Keenan
14:37:52 <ski> @where mockingbird
14:37:52 <lambdabot> I know nothing about mockingbird.
14:39:08 <ski> @where+ mockingbird "To mock a mockingbird : and other logic puzzles including an amazing adventure in combinatory logic" by R. M. Smullyan, "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" at <http://dkeenan.com/Lambda/> by David C. Keenan. Also see `smullyan'
14:39:08 <lambdabot> I will never forget.
14:39:28 <Lemmih> dankna: I would totally solve your problem if I could run your code.
14:39:36 <ski> @where+ smullyan Raymond Merril Smullyan, "To mock a mockingbird : and other logic puzzles including an amazing adventure in combinatory logic","The riddle of Scheherazade and other amazing puzzles, ancient & modern","What is the name of this book : The riddle of dracula and other logical puzzles"
14:39:37 <lambdabot> It is stored.
14:40:23 <dankna> Lemmih: heh... I actually may have just gotten it, by wildly flailing about
14:41:11 <dankna> http://hpaste.org/46671/hmm -- see the commented-out code?
14:41:23 <monochrom> ‚ô• smullyan
14:41:26 <augur> any dutch people in here?
14:41:28 <dankna> that was the culprit
14:41:31 <neaera> ski, ill check this out later today, thx again
14:41:37 <tromp_> ja
14:41:39 <lispy> > sort [0,-1,0/0,-5,-6,-3,0/0,-2]
14:41:40 <lambdabot>   [-6.0,-5.0,-3.0,-2.0,NaN,NaN,-1.0,0.0]
14:41:50 <augur> tromp_: does that mean you're dutch?
14:41:51 <dankna> I had thought that it wasn't even being evaluated (since I'm passing NULL for tracePointer)
14:41:57 <tromp_> it does
14:41:58 <Lemmih> dankna: Oh, yes. That does indeed seem to keep a reference to the previous state.
14:42:30 <dankna> yeah - I see how it has to, now, although it wouldn't if it were strict, right?
14:43:11 <Lemmih> dankna: Right.
14:43:25 <dankna> I don't understand why it was being evaluated at all, though :/
14:43:33 <dankna> oh hmm
14:43:34 <dankna> right
14:43:35 <dankna> I see now
14:43:49 <Lemmih> dankna: It wasn't. But you kept a reference to it.
14:44:08 <dankna> right.  okay.  I'm sure if I play with that a little I can find a way to achieve the same goal without the blowup.
14:44:19 <dankna> phew!  this has been a problem for like a week and a half!
14:44:41 <dankna> my heap-over-time now looks nice and flat
14:44:47 <dankna> at roughly 1.5 megs, haha
14:44:57 <Lemmih> dankna: You could deepseq tracelines.
14:45:16 <Lemmih> Altough that's not very pretty.
14:45:26 <dankna> yeah, hmm
14:45:39 <dankna> actually I just tested and I still have a time-performance problem
14:45:43 <dankna> so "research continues"
14:46:09 <dankna> maximum residency is now quite small and manageable, but that doesn't seem to have gotten rid of the GC expense :/
14:46:21 <Lemmih> dankna: Nearly all the changes you made to kill the space leak hurt performance.
14:46:39 <Lemmih> dankna: That is to be expected.
14:46:40 <dankna> Lemmih: the added strictness?  hmmmmmm - I can try taking that back out
14:47:00 <Lemmih> dankna: You allocate a /huge/ amount of temporary data.
14:47:07 <dankna> well, yes, I do
14:47:38 <dankna> the annoying thing is that I only ever need two copies of it at once
14:47:44 <dankna> (usually)
14:47:58 <dankna> (at least, with any higher-level control that I've implemented so far, that's all I need)
14:48:37 <Lemmih> dankna: +RTS -A10M -RTS should help. (:
14:48:37 <argiopeweb> dankna: What ended up dropping your usage?
14:49:03 <dankna> argiopeweb, see http://hpaste.org/46671/hmm -- the commented-out code
14:49:09 <dankna> hmmmm
14:49:39 <Lemmih> argiopeweb: He (essentially) kept a list of each previous state in the iterator. It hadn't anything to do with strictness in the state.
14:49:41 <argiopeweb> dankna: If you say so. :P
14:49:55 <argiopeweb> Lemmih: So, pretty much what you expected
14:51:01 <dankna> yes - indeed it was what he expected, and it makes sense in a lot of ways, but it took me forever to see what was right in front of my face :)
14:51:16 <Saizan> ah, so you were also creating a trace
14:51:24 <argiopeweb> dankna: Well, I still can't see it, so you're doing better than me. :P
14:51:48 <dankna> argiopeweb, although I pass NULL for tracePointer, traceLines' is still computed because it's passed to the next iteration;
14:52:00 <dankna> but its value is never demanded, so it stays on the heap as a closure;
14:52:15 <dankna> and it is based on the previous state of itself, so all prior states of it also stay on the heap
14:52:23 <dankna> if it were strict, the problem wouldn't occur.
14:52:24 <argiopeweb> Ugh
14:52:27 <dankna> yeah
14:52:41 <dankna> I had been looking for something like that, but I never thought it was in my trace code!
14:52:48 <argiopeweb> No wonder it took awhile to find. That sounds hopelessly convoluted
14:52:58 <Saizan> we focused on making one accumulator strict, but there was another
14:53:17 <argiopeweb> Ah well, what can you do...
14:54:04 <Saizan> so all those [] in the heap were the trace
14:54:07 <dankna> yeah
14:54:12 <jonkri> if i have a stack of the following monads: m (MonadIO), StateT, ErrorT, how can i perform an IO operation? i've tried lifting and liftIO'ing but nothing seems to work :)
14:54:12 <dylukes> It occurs to me brainfuck could be comonadic.
14:54:17 <dylukes> infinite lazy brainfuck :D
14:54:39 <argiopeweb> dylukes: Its name describes it perfectly.
14:54:45 <monochrom> liftIO works if you do the rest right
14:54:47 <dankna> http://dankna.com/himitsu/emulator.prof.txt -- okay, new question!  the space leak is gone so why am I still slow, haha
14:54:54 <c_wraith> jonkri: StateT and ErrorT *should* have MonadIO instances
14:55:20 <monochrom> time leak
14:55:23 <dankna> it doesn't appear to be GC time
14:55:43 <c_wraith> time leak - the universe is coming apart!
14:55:52 <dankna> oh dear :)
14:56:01 * Saizan calls the doctah
14:56:24 <Lemmih> dankna: What does +RTS -s say?
14:56:25 * dankna hmms and peruses RTS GC options
14:57:18 <dankna> Lemmih: hmmmm I had that hooked up to show me the output at one point, but it now appears to produce an empty file... let me fix that
14:57:24 <argiopeweb> c_wraith: Don't they also have MonadTrans instances?
14:57:43 <c_wraith> argiopeweb: yes, they do, but if they have MonadIO, liftIO is all you need
14:57:44 <dankna> oh, because argc was off by one, ha
15:00:12 <argiopeweb> dankna: Why /himitsu/?
15:00:53 <Lemmih> dankna: You're allocating 100megs of temporary data for each frame.
15:00:56 <dankna> argiopeweb, it's a non-listable directory for stuff I want to share with some people but not the whole world
15:00:58 <dylukes> gahhhh
15:01:00 <dylukes> fucking IO
15:01:03 <dylukes> screws up the prettiness
15:01:05 <dankna> Lemmih: oh I know
15:01:05 <dylukes> >_<
15:01:07 <argiopeweb> (just saying, seems like something you wouldn't be sharing)
15:01:24 <argiopeweb> dankna: Ah, that works.
15:01:32 <dankna> http://dankna.com/himitsu/profile.txt
15:01:34 <dylukes> And I'm not sure how to do []
15:01:36 <dylukes> *sigh*
15:01:37 <b0fh_ua> Hello! I am interested what is the optimal solution of finding does the value of list [Int] appears in intervals [(Int,Int)] efficiently for [Int] containing millions of items and [(Int,Int)] containing thousands of items? Simple brute-force solution with two iterations seems not be sufficient...
15:02:20 <dylukes> The presence of bofh in your name leads me to question your intentions.
15:02:23 <dylukes> That said, I don't know.
15:02:45 <argiopeweb> b0fh_ua: So you have a list a containing values and a list b containing tuples which represent ranges?
15:03:18 <Lemmih> dankna: Just allocating that much data is expensive even if collecting it is (nearly) free.
15:03:29 <dankna> Lemmih: yeah, I see that :/
15:03:37 <dankna> is there any solution within Haskell?
15:03:53 <Lemmih> dankna: Yes, the solution is to allocate less temporary data. (:
15:03:57 <dankna> haha
15:04:01 <argiopeweb> lol
15:04:14 <dankna> well, I mean, I can get a small constant factor by using fewer intermediate steps in each inner iteration
15:04:29 <dankna> but that would make my code harder to maintain, and would in the end only be ... a small constant factor :)
15:05:22 <b0fh_ua> argiopeweb: yup
15:05:42 <dankna> I'm not sure what else I could do while preserving the functionality of the program
15:05:44 <argiopeweb> dankna: Keep in the hardware you're emulating and how comparatively primitive it was. :P
15:05:45 <Lemmih> dankna: You essentially have to avoid making lots of small changes to records.
15:05:55 <dankna> hmm
15:06:12 <dankna> might be time for Saizan's suggestion, which was to make a custom monad to avoid having to pass and return records on the stack
15:06:48 <dankna> I didn't want to do that work while I still had the space leak, unless it was going to solve it, but it's appropriate now
15:06:50 <Lemmih> dankna: How exactly to go about that is more of an art than a science.
15:07:00 <dankna> yes, okay
15:08:08 <Lemmih> A state monad containing a big record wouldn't be any better.
15:08:18 <dankna> hmm
15:08:35 <dankna> true, yes
15:08:40 <argiopeweb> b0fh_ua: And you've sorted your loop and set it up to short-circuit appropriately and all the silly little optimizations that you do before you look for a better algorithm?
15:08:55 <dankna> well - it's a small record.  all records are small.  the only large heap objects that I'm aware of are arrays.
15:08:57 <dankna> there's just many of it.
15:09:18 <Saizan> Lemmih: i was suggesting something like forall r. (a -> Field1 -> .. -> Fieldn -> r) -> Field1 -> .. -> Fieldn -> r
15:09:19 <argiopeweb> I mean, with 2 operations (< and >) and ~5000 tuples, with 5mil integers, that only 20trillion ops.
15:09:20 <argiopeweb> :P
15:09:35 <Lemmih> Saizan: Oh, that would work very well.
15:09:53 <Saizan> Lemmih: just quite tedious to implement
15:10:18 <dankna> but that would violate the abstraction I'm trying to preserve that the modules which implement each chip (CPU, graphics processor, and so on) don't need to know of each others' existence, and indeed treat the system's overall state as an opaque type.
15:10:26 <b0fh_ua> argiopeweb: well, I think that there could be something better
15:10:31 <argiopeweb> b0fh_ua: In all seriousness though, #1, problems like this parallellize very well, and #2, you may want to look into image processing. Pretty sure they solve this problem in a moderately novel way.
15:10:48 <b0fh_ua> rather than brute-force, so probably map/reduce will work well
15:10:57 <b0fh_ua> or even simple divide/conquer
15:11:09 <argiopeweb> map-reduce is just creative brut-force
15:11:13 <argiopeweb> +e
15:11:17 <b0fh_ua> i know )
15:11:31 * Jafet throws buzzwords around too
15:12:18 <argiopeweb> But yeah, map-fold + massive parallel + optimizing by sorting your array in some manner and short-circuiting should speed you up.
15:12:41 <argiopeweb> jafet will give you extra points if you do it in the cloud.
15:12:45 <ddarius> Just throw 100,000 computers at it.  That should speed things up.
15:12:57 <Jafet> The cloud is webscale.
15:13:33 <KirinDave> What could go wrong?
15:13:35 <argiopeweb> Jafet: Can you use NoSQL with the cloud?
15:13:38 <dankna> just to confirm my understanding, using tuples instead of records would be beside the point, yes?  the only reason that Saizan's solution works is that it puts everything on the stack...
15:13:48 <KirinDave> argiopeweb: Only if it is couchdb
15:13:53 <Jafet> No, you must use SQL.
15:14:12 <KirinDave> I've heard mongodb is so fast.
15:14:16 <argiopeweb> Jafet: But NoSQL is today's big thing!
15:14:53 <argiopeweb> KirinDave: It says "Map/Reduce" on their front page. It must be fast.
15:14:53 <Jafet> Big things don't float on clouds! Small things float on clouds.
15:15:08 <Jafet> If it floats, your startup floats. Never forget that.
15:15:24 <KirinDave> So I tried some simple googling and couldn't find out
15:15:41 <KirinDave> In RWH it talks about how the ghc at the time of release didn't have a parallel generational collector
15:15:46 <KirinDave> Is that not the case anymore?
15:16:00 <argiopeweb> There's a parallel generational collector now.
15:16:05 <KirinDave> Cool
15:16:13 <argiopeweb> I'm not sure how good it is, and it only runs if you compile with -threaded, but still.
15:16:33 <Lemmih> dankna: Yes, tuples won't help. Saizan's solution works because the contents of the state would be passed around directly as function parameters instead of in a State structure.
15:16:40 <djahandarie> It's pretty good
15:17:01 <djahandarie> Mainly because the young generations can be collected without stopping threads
15:17:16 <argiopeweb> djahandarie: Only need to stop the world for major?
15:17:28 <Saizan> unboxed tuples would work in principle, but we can't know since you can't use them as arguments.
15:17:29 <djahandarie> Yes, for the old generation / global heap.
15:17:59 <argiopeweb> djahandarie: How about if you set it up with 3 generations? Still only the oldest gets stopped?
15:18:40 <Jafet> More seriously, bofh could use an interval tree.
15:19:08 <argiopeweb> Jafet: I didn't think of that. Shame on me.
15:19:28 <Jafet> Actually, you don't even need an interval tree in one dimension.
15:20:05 <dylukes> alright.
15:20:08 <argiopeweb> Though I did point him to image processing, and scene rendering is a part of image processing that uses interval trees, so I kind of did. :P
15:20:09 <Jafet> Sort the points, and the endpoints of the intervals, and walk through them cleverly.
15:20:23 <dylukes> So I tried (in the last five minutes), to throw together a pure version of brainfuck for fun.
15:20:24 <dylukes> http://hpaste.org/46673/brainfuck
15:20:32 <dankna> Lemmih: right, okay.  hmm.  it's a shame - just thinking out loud here - that I can't somehow specify something like :: (opaque -> Word8, opaque -> Word8 -> opaque, ...) -> opaque -> opaque
15:20:34 <dylukes> however, I'm not sure how to do the commented bits nicely
15:20:37 <argiopeweb> Jafet: Yeah, that's what I ended up recommending.
15:20:40 <dylukes> that is, how to do an "iteration until a condition"
15:20:47 <dylukes> I mean, I could write functions to do it, but
15:20:54 <dylukes> is there an existing prelude function I could use
15:20:57 <dankna> but I can't, because there's no type for opaque, heh
15:21:06 <b0fh_ua> Jafet: http://en.wikipedia.org/wiki/Interval_tree
15:21:09 <argiopeweb> dylukes: until? :P
15:21:10 <b0fh_ua> nice, thanks
15:21:13 <Jafet> No, you didn't seem to recommend that...
15:21:19 <dylukes> that works argiopeweb :P
15:21:36 * argiopeweb honestly has no clue if that does what you want, but it sounded good
15:21:45 <argiopeweb> @src until
15:21:45 <lambdabot> until p f x | p x       = x
15:21:45 <lambdabot>             | otherwise = until p f (f x)
15:21:53 <djahandarie> argiopeweb, I actually don't have the slightest clue what happens with more than 2 generations.
15:22:02 <djahandarie> Could possibly read the source or the paper
15:22:22 <argiopeweb> djahandarie: I'll have to play with it next time I actually write something that does a major GC...
15:22:23 <Saizan> dankna: :: (m Word8, Word8 -> m (), ..) -> m () works though
15:22:29 <argiopeweb> Other than that 1, of course.
15:22:32 <KirinDave> But in practice, Haskell has something sorta like Erlang's collector
15:22:40 <KirinDave> where short lived objects in thread don't block the world.
15:22:45 <KirinDave> and long-lived or shared objects can.
15:22:59 <KirinDave> Cuz that's a good property to have. :)
15:23:10 <b0fh_ua> Jafet: and in fact I don't see what sorting of points and intervals will give me
15:23:16 <Saizan> dankna: :: Monad m => (m Word8, Word8 -> m (), ..) -> m () -- more like
15:23:29 <dankna> Saizan: how?  I mean, what is the concrete type of m that makes it work?  I don't see how I can store my state in the monad without using some manner of record or aggregate type.
15:23:35 <ian_mi> @src unsafePerformIO
15:23:36 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:23:40 <ian_mi> :(
15:23:43 <argiopeweb> b0fh_ua: The ability to not check if it's impossible to be in an interval.
15:24:02 <argiopeweb> I.E. your number is smaller than the smallest or larger than the largest.
15:24:15 <argiopeweb> At some point you become larger than the largest and can skip the remainder.
15:24:23 <b0fh_ua> true
15:24:27 <b0fh_ua> thanks
15:25:03 <Saizan> dankna: the concrete type is newtype CustomState a = CS (forall r. (a -> Word8 -> .. -> Fieldn -> r) -> Word8 -> .. -> Fieldn -> r)
15:25:12 <b0fh_ua> so get maximum and minimum of intervals and filter out numbers that are outside the ranges
15:25:15 <dankna> hmm
15:25:17 * dankna digests that
15:25:24 <b0fh_ua> and then build that interval tree and process with it
15:25:39 * argiopeweb has hacked many O(n^2) algorithms into usable shape this way...
15:25:48 <dankna> oh wow, that's a cute trick, if I understand correctly
15:26:02 <dankna> you're using a closure as the state
15:26:05 <dankna> yes?
15:26:40 <Saizan> it's a CPS transform of the normal State monad, plus currying of the state record
15:26:43 <argiopeweb> b0fh_ua: That's an additional thing you could do.
15:27:53 <Saizan> State Record a = Record -> (a,Record); now, instead of returning (a,Record) we take a continuation (a -> Record -> r) instead, and return an 'r' ourselves
15:27:56 <argiopeweb> Which would, in fact, be more efficient than simply stepping through.
15:28:06 <Saizan> Record -> (a -> Record -> r) -> r
15:28:24 <Jafet> argiopeweb: stop... giving useless advice.
15:28:26 <dankna> hold on a sec, digesting that
15:28:54 <dankna> I mean I know what CPS is in principle, but I've never seen a case where I actually needed it before :)
15:29:16 <Saizan> i guess i've skipped a step
15:29:54 <dankna> don't we need to call the continuation that we receive, heh
15:29:59 <Saizan> Record -> (a,Record) becomes Record -> ((a,Record) -> r) -> r and then you curry the argument to the continuation:  Record -> (a -> Record -> r) -> r
15:30:04 <KirinDave> Hum
15:30:17 <aristid> :t join get
15:30:19 <lambdabot> forall (m :: * -> *) a. (MonadState (m a) m) => m a
15:30:25 <dankna> yeah, that step wasn't what was confusing me
15:30:27 <ski> hm, where (which host) does lambdabot currently live ?
15:30:33 <KirinDave> So... is haskell for programming or to "advanc[e] applied type theory"?
15:30:42 <aristid> KirinDave: both!
15:30:59 <KirinDave> Sometimes my lisp-loving colleagues shame me.
15:31:06 <monochrom> lambdabot lives at li85-105.members.linode.com , a linode virtual machine
15:31:11 <ski> (or more specifically/appropriately, i'm wanting to look at the currently running source)
15:31:27 <monochrom> oh, I don't know, nevermind
15:31:44 <dankna> so wait, what's r
15:31:56 <dankna> oh I see!
15:32:00 <dankna> r is the return type of our caller
15:32:06 <dankna> we have only one way of obtaining a value of this type
15:32:07 <Saizan> yep
15:32:10 <dankna> which is to call the continuation we were given
15:32:36 <dankna> okay.  and the reason we're using CPS is that it lets us use a closure instead of an aggregate type.
15:32:40 <ski> `r' is the ("final") result/answer type
15:32:41 <Saizan> right, especially if you put back the forall r. i've left implicit lately
15:32:51 <dankna> right, okay, I was wondering what the forall was about
15:33:21 <Saizan> i'm hoping we need no closures here actually
15:33:27 <dankna> oh, hm
15:33:43 <dankna> isn't the continuation a closure, even if it is (in the happy case) part of the static area?
15:33:54 <ski> (hm, there should be a `data UnboxedState s a = US (s -> (# s , a #))' somewhere, no ?)
15:33:58 <Saizan> well, it's a function
15:34:08 <dankna> oh, yeah, sorry.  sloppy wording.  I guess that is distinct
15:34:30 <dankna> ski: someone said a couple pages back that unboxed tuples can't be passed or returned
15:34:38 <Saizan> but it's not where the data is stored while the computation runs, it's where you'll end up returining it
15:34:38 <dankna> ski: if that's true, it would prevent what you're saying
15:34:50 <ski> dankna : they can be returned, but (sadly, imo) not passed as argument
15:34:53 <dankna> so this actually avoids even making a second copy of my data at all?
15:35:07 <dankna> nice
15:35:24 <ski> @kind Int -> (# Int , GHC.Exts.Int# #)
15:35:25 <lambdabot> *
15:35:32 <ski> @kind (# Int , GHC.Exts.Int# #) -> Int
15:35:33 <lambdabot>     Kind mis-match
15:35:33 <lambdabot>     Expected kind `??', but `(# Int, GHC.Prim.Int# #)' has kind `(#)'
15:35:33 <lambdabot>     In the type `(# Int, GHC.Prim.Int# #) -> Int'
15:35:42 <ski> @kind (# Int , GHC.Exts.Int# #)
15:35:43 <lambdabot> (#)
15:35:48 <ski> @kind (# , #)
15:35:49 <lambdabot> ? -> ? -> (#)
15:35:51 <dankna> heh, that's a weird quirk
15:35:52 <ski> @kind (->)
15:35:53 <lambdabot> ?? -> ? -> *
15:36:04 <ski> @kind GHC.Exts.Int#
15:36:04 <lambdabot> #
15:36:23 <Saizan> dankna: the big win here is that "forall r. (a -> Record -> r) -> Record -> r" let us curry Record away into its fields
15:36:30 <dankna> indeed, okay
15:36:36 <Saizan> dankna: otherwise we wouldn't have gained much
15:36:39 <ski> `??' is the lub of `*' and `#', and `?' is the lub of `??' and `(#)'
15:36:41 <dankna> it's regrettable that I have to do that, but if I have to I have to :)
15:36:55 <ski> (also, istr there being a `!' kind .. and maybe something more)
15:37:54 <Saizan> funningly enough return will still look the same no matter the currying: return x = \k -> k x
15:37:57 <dankna> okay, so I understand the CPS transformation and the currying
15:38:03 <dankna> ah good, that's exactly what I was about to ask
15:38:13 <ski> dankna : with `(a -> r) -> r', you can have control effects (by relying on what concrete type `r' is), but with `forall r. (a -> r) -> r', you can't
15:38:24 <dankna> ski: right, I see!
15:38:52 <ski> but using CPS can improve efficiency anyway
15:39:10 <dankna> Saizan: okay, yeah, I believe I get how that definition of return works.
15:39:25 <ski> dankna : using `forall r. (a -> m r) -> m r' you can have control effects depending on what `m' is, but no more
15:39:38 <dankna> gothca.
15:39:47 <ski> @unmtl ContT (Reader Record) r a
15:39:47 <lambdabot> (a -> r (Reader Record)) -> r (Reader Record)
15:40:00 <ski> @unmtl ContT r (Reader Record) a
15:40:00 <lambdabot> (a -> Record -> r) -> Record -> r
15:40:00 <Saizan> wrong order :)
15:40:04 <ski> (:
15:40:19 <Saizan> and indeed the Monad implementation is the same as ContT
15:40:32 <Saizan> http://hackage.haskell.org/packages/archive/mmtl/0.1/doc/html/src/Control-Monad-Codensity.html <- or Codensity, more specifically
15:41:02 <Saizan> it doesn't care what f is
15:41:28 <Saizan> but you'd need newtyping to use Codensity directly with the curried Record
15:41:31 <dankna> okay.  I think I get this well enough to implement it.  I'll go ahead and make a start on it and ask questions if I get stuck.  thanks!
15:41:55 <ski> ContT o (ReaderT rs m) a  ~=  (a -> rs -> m o) -> rs -> m o  ~=  rs -> ((a,rs) -> m o) -> m o  ~=  StateT rs (ContT o m) a
15:42:10 <Saizan> np
15:42:25 <dankna> I'd rather not add a library dependency anyway, especially when the code I need from the library is so short, heh
15:42:35 * ski wonders what exact control effects is possible with `forall o. ContT o (Reader rs) a' ..
15:45:44 <ski> hm, given a continuation `a -> rs -> o' for abstract `o', as well as an `rs', you can modify with an `rs -> rs', before passing to the continuation
15:46:29 <ski> in terms of `forall o. StateT rs (Cont o) a', i suppose that only does a `modify'
15:48:41 <parcs> @untl ContT o m a
15:48:41 <lambdabot> Maybe you meant: unmtl unpl
15:48:48 <parcs> @unmtl ContT o m a
15:48:48 <lambdabot> (a -> m o) -> m o
16:01:40 <ficoos> any fedora14 users in here?
16:02:49 <Zao> Occasionally.
16:03:02 * Zao has 14 and rawhide installed currently, but not booted.
16:04:09 <ficoos> Zao, have you had any conflicts trying to install haskell-platform using yum?
16:04:30 <Zao> Unsure whether I run GHC/HP from reposes or not.
16:07:25 <ficoos> Zao, thanks anyway, I have some issues an I'm trying to see if anyone else has overcome this.
16:07:56 <Zao> ficoos: So what's ailing you?
16:09:43 <ficoos> Zao, There seems to be some package conflict when I try to install haskell. http://pastebin.com/M9zrriXk
16:10:27 <argiopeweb> ficoos: I'm also on 14. No issues.
16:10:35 <Zao> Any third party reposes?
16:10:41 <Zao> rpmfusion, livna, whatnot.
16:10:49 * argiopeweb checks
16:11:10 <ficoos> Zao, rpmfusion
16:11:59 <argiopeweb> I've got rpmfusion free and nonfree. GHC & platform install from yum with no issues.
16:12:39 <ficoos> argiopeweb, are you fully updated?
16:12:51 <argiopeweb> ficoos: Yes
16:13:15 <ficoos> argiopeweb, what is the version of haskell-platform?
16:13:30 <argiopeweb> 2010.2
16:15:22 <ficoos> argiopeweb, rev 1.fc14?
16:15:46 <argiopeweb> ficoos: Yep
16:16:25 <ficoos> argiopeweb, grrr
16:17:02 <siracusa> I vaguely recall a package for transforming Haskell string functions into shell commands, but I'm not able to find it on Hackage. Anyone knows the name?
16:17:26 <ficoos> argiopeweb, 32\64 bit?
16:17:31 <argiopeweb> 64
16:17:50 <Zao> I seem to have 2010.2.0.0-1.fc14 installed here, with GHC 6.12.3
16:18:12 <Zao> The machine hasn't been updated in months though.
16:18:38 <argiopeweb> siracusa: That's rawSystem from System.Cmd
16:18:55 <argiopeweb> siracusa: Or maybe I misunderstood your question.
16:19:01 <parcs> @src Cont (>>=)
16:19:02 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
16:19:09 <Zao> No GHC/HP updates in the pipe though.
16:19:51 <digicyc> Process?
16:20:11 <digicyc> siracusa: ^
16:21:28 <siracusa> argiopeweb, digicyc: No, I don't want to execute shell command from Haskell, but create new executables like "nub" would filter all double lines from the input.
16:21:56 <argiopeweb> siracusa: That's what I thought after I read it again. Never heard of something to do that.
16:22:21 <argiopeweb> Other than the obvious interact $ nub args ;)
16:24:35 <Nereid> well, interact $ unlines . nub . lines
16:25:41 <Nereid> > unlines . nub . lines $ "foo\nfoo\nbar\nfoo\nbaz\n"
16:25:43 <lambdabot>   "foo\nbar\nbaz\n"
16:28:44 <ski> hm .. which are the descendents of JHC ?
16:28:50 <ficoos> argiopeweb, Zao: thanks for the help, found the bug in bugzilla (https://bugzilla.redhat.com/show_bug.cgi?id=702934) should be fixed in a few days according to the comments
16:28:55 <geheimdienst> except nub, what functions could be used at the command line ...?
16:29:18 <ski> i know there's LHC, is there any more ?
16:30:11 <Lemmih> ski: It's even debatable to say that LHC is a descendent of JHC.
16:31:40 <ski> Lemmih : well, it came from JHC, even if it has been completely rewritten
16:31:48 <ski> (that's enough, for this purpose)
16:32:49 <Lemmih> It doesn't share JHC's ideology, though.
16:33:45 <siracusa> Found it, it's call h4sh and it's not on Hackage at all :-S
16:56:10 <geheimdienst> siracusa: nice find. it's an interesting idea
16:56:27 <geheimdienst> (i'm referring to http://www.cse.unsw.edu.au/~dons/h4sh.txt )
17:10:32 <jfmiller28> @pl \o -> runObject >>= \(q, pid)-> return Reference q pid
17:10:32 <lambdabot> const (uncurry (return Reference) =<< runObject)
17:11:20 <jfmiller28> @pl \o -> runObject >>= \(q, pid)-> return Reference(q pid)
17:11:20 <lambdabot> const (uncurry (return Reference .) =<< runObject)
17:12:02 <jfmiller28> @pl \o -> runObject >>= \(q, pid)-> return $ Reference q pid
17:12:03 <lambdabot> const (uncurry ((return .) . Reference) =<< runObject)
17:46:51 <Luke1> I'm trying to compile ghc7 from source but it's failing because it can't find ghc-pkg. Anyone know why that would be?
17:47:27 <Jafet> Is there a ghc-pkg?
17:48:16 <Luke> not int he location it's looking for it for
17:49:03 <Luke> i'm trying to use checkinstall to install this. perhaps it's not liking that
17:51:47 <Luke> doesn't ghc-pkg come with the ghc i'm trying to install?
17:52:16 <ski> @where GF
17:52:17 <lambdabot> Grammatical Framework, dependently typed FPL, categorial grammar formalism, supporting multilingual grammar applications for e.g. natural language processing, at <http://www.grammaticalframework.org/
17:52:17 <lambdabot> >. (An old `Alfa' interface is at <http://web.archive.org/web/*/http://www.cs.chalmers.se/~hallgren/Alfa/Tutorial/GFplugin.html>)
17:52:33 <ski> does that sound sensible ?
18:04:06 <erus_> when is the google app engine haskell version coming out?
18:04:36 <KSkrzet> gtk2hs home page http://haskell.org/gtk2hs still returns 404; anyone know when it'll be up?
18:13:27 <geheimdienst> KSkrzet: try this: http://www.haskell.org/haskellwiki/Gtk2Hs
18:17:00 <wahz> hi
18:17:06 <wahz> is it okay to ask xmonad questions here?
18:17:14 <erus_> yes
18:17:42 <wahz> I am running xmonad on ubuntu 11.04 with gnome
18:17:50 <wahz> mod-p is unresponsive until I do a mod-q
18:18:06 <wahz> using gnomeConfig in the config file
18:18:12 <wahz> why might that be?
18:18:20 <erus_> have you defibulated the reverse psion drivers?
18:18:48 <wahz> I do that first thing in the morning
18:18:59 <erus_> make it so
18:19:02 <erus_> warp speed
18:19:53 <wahz> lets assume that the reverse psion drivers where adequately defibulated
18:20:33 <gwern> I always swap the polarity in the morning. keeps the tribbles away
18:20:53 <Eduard_Munteanu> wahz: note there's also #xmonad
18:20:58 <erus_> wahz: sorry, i have only ever seen screen shots of xmonad
18:22:51 <wahz> yes, I am on #xmonad too actually
18:23:54 <wahz> while I'm here, I might also ask, what is a good tutorial on haskell these days?
18:24:02 <wahz> I haven't programmed haskell since uni
18:24:08 <Eduard_Munteanu> @where lyah
18:24:08 <lambdabot> http://www.learnyouahaskell.com/
18:24:12 <wahz> I rem...
18:24:19 <Eduard_Munteanu> :)
18:24:20 <wahz> I was about to say that
18:24:44 <aristid> wahz: and install the haskell platform, so you can actually play with it RIGHT NOW :)
18:24:46 <Eduard_Munteanu> Are you looking for something else then?
18:24:46 <geheimdienst> not bad, props to your uni for teaching you haskell :)
18:24:57 <geheimdienst> @where tryhaskell
18:24:58 <lambdabot> http://tryhaskell.org/
18:25:10 <geheimdienst> ^^ with this you can play haskell even more right now
18:27:38 <wahz> not that I was looking for something else, I had seen it linked on reddit a while back, and I was going to ask if it was still a good source
18:31:18 <Kaidelong> http://hackage.haskell.org/packages/archive/random-fu/0.1.3/logs/failure/ghc-7.0
18:32:21 <Kaidelong> looks like the problem is prompt depending on base<=4 rather than base<=4.*
18:33:04 <Eduard_Munteanu> wahz: dunno, but everybody seems to be recommending it, the author even released it in dead tree form
18:33:48 <Eduard_Munteanu> There's also RWH and the Wikibooks stuff if you want to look at more advanced topics.
18:33:53 <Eduard_Munteanu> @where rwh
18:33:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:34:51 <KSkrzet> geheimdienst: thanks, but that is unlike the previous page
18:35:02 <Eduard_Munteanu> Though I wonder why the Wikibooks stuff isn't recommended more often in here, I think there is useful material in there.
18:36:39 <shachaf> Eduard_Munteanu: The Wikibook used to have one of those completely-unhelpful monad metaphors. I don't know if it still does.
18:37:41 <geheimdienst> dunno about monads, but i quite impressed with the wikibooks explanation of things like typeclasses and existentials
18:37:51 <geheimdienst> s/i quite/i was quite
18:38:14 <argiopeweb> Eduard_Munteanu: I find the wikibooks are good for the higher level topics, but they either present poorly or in too little detail the entry/lower level topics.
18:44:32 <wahz> thanks for the links
18:45:46 <wahz> I remember when I was doing some haskell, I did not like some of the names of things (some were obscure and used too many underscores or whatever)
18:46:15 <wahz> I thought that most of haskell was "pretty" and that these parts made it look a little uglier
18:46:30 <wahz> perhaps I will get used to it after using it for a while
18:46:38 <wahz> like the __init__ etc stuff in python
18:46:38 <shachaf> Too many underscores?
18:46:56 <shachaf> Are you thinking of things like sequence_ and mapM_?
18:47:19 <geheimdienst> i can think of only one place where underscores show up, which is not a prominent thing (mapM_)
18:47:34 <wahz> I saw some (maybe advanced) haskell code that used a lot of those types of things on the one line
18:47:35 <geheimdienst> about obscure names, yes we do that a lot :-/
18:48:01 <geheimdienst> oh you mean \_ _ -> 42. that just means "ignore the argument"
18:48:29 <geheimdienst> or for that matter "f _ _ = 42"
18:49:57 <wahz> no the ignore the argument thing, I got that pretty easily, more the mapM_ seq_ etc_ stuff
18:50:16 <wahz> why is there an underscore for these?
18:50:21 <wahz> is it just a naming thing
18:50:29 <ben> Yes
18:50:35 <wahz> i.e. there is already a mapM
18:50:37 <wahz> ?
18:50:38 <ben> the idea is that mapM_ does not return anything, it just does side-effects
18:50:53 <ben> or monadic stuff, anyway
18:50:58 <wahz> oh okay
18:51:05 <geheimdienst> it's pretty simple, mapM is like the function map for monadic stuff. if you don't care about the returned list, you can use mapM_. it maps over the list and then throws away the returned list
18:51:41 <wahz> makes sense
18:51:44 <geheimdienst> the underscore makes some sense at that point. it means "don't need this", just like in the other case
18:51:55 <wahz> gotcha
18:51:56 <shachaf> wahz is probably thinking of __stginit_blah
18:51:59 <ben> Oh. So that is why they didn't go with mapM', etc
18:52:19 <shachaf> Lots of underscores.
18:52:31 <Eduard_Munteanu> Yeah, some stuff on denotational semantics, zippers etc. was nice on Wikibooks.
18:52:47 <Eduard_Munteanu> They at least present a theoretical approach too.
18:52:47 <geheimdienst> ben, it was just occurring to me as i was typing :) you only really understand stuff when you explain it
18:52:48 <wahz> yes shachaf, stuff like that
18:52:57 <geheimdienst> shachaf: what is that?
18:53:13 <shachaf> When I first saw mapM_, I thought "they have so many mapping functions in Haskell that they go up to M, and then they need an underscore on top of that?".
18:53:36 <shachaf> geheimdienst: A GHC thing. I doubt wahz was actually thinking of it.
18:53:40 <dolio> Did you see mapA first?
18:54:05 <shachaf> Nope. But I did see map.
18:54:24 <geheimdienst> mapL is the variant that throws away every third result, randomly runs the mapped function twice, occasionally does a little dance
18:55:23 <dolio> Does it get down tonight?
18:55:45 <ski> @where books
18:55:45 <lambdabot> I know nothing about books.
18:56:00 <ski> @where books See `LYAH',`RWH'
18:56:00 <lambdabot> I know nothing about books.
18:56:03 <ski> @where+ books See `LYAH',`RWH'
18:56:03 <lambdabot> Done.
18:56:13 <Eduard_Munteanu> @where Haskell
18:56:13 <lambdabot> http://haskell.org
18:56:16 <Eduard_Munteanu> Dang.
18:56:30 <shachaf> ?where ?where
18:56:30 <lambdabot> ?where ?where
18:56:31 <Eduard_Munteanu> @where Haskell or that monad crap
18:56:31 <lambdabot> http://haskell.org
18:56:37 <geheimdienst> @where lyah rwh
18:56:38 <lambdabot> http://www.learnyouahaskell.com/
18:56:42 <geheimdienst> @where rwh
18:56:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:57:04 <Eduard_Munteanu> @where currying
18:57:04 <lambdabot> I know nothing about currying.
18:57:10 <geheimdienst> @where+ books http://www.learnyouahaskell.com/ http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:57:11 <lambdabot> It is forever etched in my memory.
18:57:15 <geheimdienst> @where books
18:57:16 <lambdabot> http://www.learnyouahaskell.com/ http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:16:28 <joe6> to export a data from a module we do DataItem(..) , what do I to export a Type definition?
19:16:45 <aristid> TypeItem
19:17:04 <joe6> aristid, thanks
19:35:00 <Veinor> Someone told me this joke. I don't know who they are.
19:35:02 <Veinor> "you're so dumb you think that the io monad is some guy wandering around on a moon
19:35:51 <Jafet> unsafePerformEVA
19:36:06 <Veinor> haha
19:37:03 <gwern> yo momma's so fat she overflows her Ints
19:37:17 <shachaf> Veinor: How did they tell it to you?
19:37:35 <Veinor> anonymous ask message on tumblr.
19:37:47 <Veinor> Hence why I don't know what they are.
19:46:16 * geheimdienst finds that requires quite some knowledgez ... io, the moon of jupiter
19:50:16 <parcs> @hoogle Monad m => m a -> (a -> m b) -> m a
19:50:17 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
19:50:17 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
19:50:17 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
19:50:42 <Veinor> parcs: const?
19:52:38 <parcs> can be
19:53:55 <parcs> @type \m f -> m >>= \x -> f x >> return x
19:53:56 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> m a1) -> m a
19:54:05 <Veinor> yeah, there's also that
19:54:06 <parcs> @pl \m f -> m >>= \x -> f x >> return x
19:54:06 <lambdabot> (. flip (liftM2 (>>)) return) . (>>=)
19:54:29 <Veinor> wait
19:54:45 <Veinor> :t \m f -> m >>= (\x -> f x >> return x)
19:54:46 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> m a1) -> m a
19:54:52 <Veinor> :t \m f -> m >>= (\x -> f x) >> return x
19:54:52 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> m a1) -> m Expr
19:55:02 <Veinor> oh right, x is ubound in that case
19:55:54 <ski> @type (. liftM2 liftM const) . (>>=)
19:55:55 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => m a -> (a -> m a1) -> m a
19:56:11 <parcs> @type \m f -> m >>= f >> m
19:56:11 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> m a1) -> m a
19:56:21 <parcs> that would be sneaky
19:56:26 <djahandarie> @pl (\f g -> (. f) . g)
19:56:27 <lambdabot> (.) . flip (.)
19:56:43 <djahandarie> It'd be nice if there was a function for that
19:59:09 <Veinor> call it >>=>>!
19:59:39 <parcs> @let f >_> g = (. f) . g
19:59:40 <lambdabot>   Parse error in pattern:
19:59:46 <parcs> damn
20:00:41 <ski> @type fix . ((=<<) .) . flip (.)  -- cf.
20:00:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> m a -> m b
20:01:05 <Jafet> :t (>=>)
20:01:06 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
20:01:13 <Veinor> @let f >-> g = (. f) . g
20:01:14 <lambdabot>  Defined.
20:01:27 <ski> @type (>->)
20:01:27 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) b. (Functor f, Functor f1) => f a -> f1 (a -> b) -> f1 (f b)
20:01:51 <ski> @type let (.) = (Prelude..); f >-> g = (. f) . g in (>->)
20:01:51 <lambdabot> forall a b a1 c. (a -> b) -> (a1 -> b -> c) -> a1 -> a -> c
20:08:11 * hackagebot gitit 0.8 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.8 (JohnMacFarlane)
20:15:11 <djahandarie> I think I'd call <<<< = (<<<).(<<<) and >><< = (>>>) . (<<<) or something
20:15:28 <djahandarie> Those are the most common two I see but I guess >>>> and <<>> might be useful sometimes also
20:23:45 <dmwit> Those operators make me think that somehow there's a generalization waiting to be made that ought to be.
20:24:56 <djahandarie> What sort of generalization?
20:25:37 <djahandarie> :t (<<<).(<<<) -- is fairly general in terms of type signature
20:25:38 <lambdabot> forall a (cat :: * -> * -> *) b c a1. (Control.Category.Category cat) => cat b c -> (a -> cat a1 b) -> a -> cat a1 c
20:32:15 <ski> @type (<<<) . arr . (<<<)
20:32:16 <lambdabot> forall (cat :: * -> * -> *) a (cat1 :: * -> * -> *) b c a1. (Arrow cat, Control.Category.Category cat1) => cat1 b c -> cat a (cat1 a1 b) -> cat a (cat1 a1 c)
20:32:40 <djahandarie> I really don't like arr
20:32:58 <ski> *nod*
20:35:09 <danharaj> Sigh, equality on GADT's is a pain.
20:35:57 <ski> danharaj : hm, what are you trying to define equality on ?
20:36:07 <ski> existentials, or other GADTs ?
20:36:25 <djahandarie> danharaj, you mean Refl, or some sort of other equality?
20:37:17 <danharaj> ski: well in my case, I have a GADT which is basically a set of enumerated values, but the values can have different types attached to them. So I can test equality on arbitrary values of the GADT even if the types don't match, but this is different from regular Eq.
20:37:22 <danharaj> So I have to be ugly about it.
20:37:33 <djahandarie> Oh, that sort of equality
20:38:26 <ski> danharaj : that sounds like you might have a use for my `Eq1' idea ?
20:38:36 <danharaj> what is your `Eq1' idea?
20:39:39 <ski>   class Eq1 f
20:39:41 <ski>     where
20:40:03 <dmwit> Now that is a short class. But I can get behind it.
20:40:04 <ski>     eq1 :: f i -> f j -> Maybe (Equal i j)
20:40:04 * dmwit signs up
20:40:27 <danharaj> that's pretty much what I'm going to have
20:40:39 <ski> ok
20:40:47 <danharaj> except it'll be f i -> f j -> (Bool, Maybe (Equal i q)) so I have type level and value level equality
20:41:09 <ski> you can use `isJust' to convert from `Maybe ...' to `Bool'
20:41:33 <danharaj> ski: but I need the actual witness elsewhere.
20:41:54 <ski> i don't understand ..
20:42:23 <ski> if you need both `Maybe (Equal i j)' and `Bool', then just bind the result to a variable and use `isJust' in the places where you need to ?
20:42:41 <danharaj> I am going to be implementing (f i, g i) -> (f j, g j) -> Bool, and I can't do the same trick on g.
20:43:08 <danharaj> No, the Bool is there because I might have two values that are distinct of (f i)
20:43:27 <danharaj> So their types might be equal but they might not be equal as values.
20:43:28 <ski> are you going to compare the `g i' and `g j', in case `i' equals `j' ?
20:44:00 <danharaj> in case Equal i j, and the values are actually equal as values.
20:44:41 <danharaj> hmm
20:44:45 <danharaj> Is Equal defined in a package?
20:45:08 <ski> my `eq1' is supposed to satisfy `forall fi fj. eq1 fi fj = Just Refl => fi = fj' and `forall fi fj. eq1 fi fj = Nothing => fi =/= fj'
20:45:27 <ski> (only `=>'s because `eq1 fi fj' might not terminate)
20:46:49 <ski> so i'm really comparing mainly values, the type equality is just a by-product
20:46:53 <jrick> hey all, I'm getting started with http://haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell, but I'm having trouble compiling the first example using the parser: http://hpaste.org/46675/error
20:47:28 <danharaj> ski: Ah I see.
20:48:07 <ski> @hackage type-equality  -- there is apparently this, at least
20:48:07 <lambdabot> http://hackage.haskell.org/package/type-equality  -- there is apparently this, at least
20:48:52 <ski> danharaj : why are you comparing those pairs ? are you making a key-dependent finite map type ? something else ?
20:49:03 <dmwit> jrick: ah, that tutorial was probably written for Parsec 2
20:49:22 <dmwit> gotta run, hope you get helped
20:49:33 <jrick> dmwit: ah ok
20:49:35 <danharaj> ski: related. I have a tree whose nodes are labelled with key, value pairs.
20:50:53 <ski> or are you just making more or less `instance (Eq1 f,forall i. Eq i => Eq (g i)) => Eq1 (LiftM2 (,) f g) where ..' ?
20:51:14 <ski> danharaj : and is that representing a finite map .. or something else ?
20:51:24 <danharaj> ski: a scene graph :p
20:51:34 <danharaj> I am going to be traversing it and I need to test equality on nodes
20:52:40 <jrick> so, anyone know what can be done to fix this issue?
20:54:02 <Axman6> jrick: I‚Äôd recommend using a more up to date tutorial, like LYAH...
20:54:04 <Axman6> @where lyah
20:54:04 <lambdabot> http://www.learnyouahaskell.com/
20:54:39 <jrick> yeah, I started with that tutorial a few years ago and didn't care for it
20:55:07 <jrick> with this one I was actually starting to wrap my head around some of the IO things I never understood earlier
20:55:09 <Axman6> i'm not even sure it's a few years old...
20:55:29 <Axman6> maybe 18 months
20:55:41 <jrick> yeah, around then
20:56:53 <ski> (danharaj : .. ok, so that sounds like what i meant by `Eq1 (LiftM2 (,) f g)', there)
21:03:39 <ski> hm .. i want `newIdent :: M (exists i. Ident i)' with `instance Eq1 Ident' ..
21:04:51 * ski wonders
21:07:13 <ski> hm, no it probably is `newIdent :: forall i. M (Ident i)' i want
21:09:17 <applicative> jrick, use the pragma {-#LANGUAGE NoMonomorphismRestriction#-}
21:09:19 * hackagebot bash 0.1.1 - Bash generation library.  http://hackage.haskell.org/package/bash-0.1.1 (JasonDusek)
21:09:21 <ManateeLazyCat> Sorry all, Manatee release spam come again. :)
21:10:19 * hackagebot manatee-core 0.1.1 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.1.1 (AndyStewart)
21:10:40 <jrick> applicative: ok, I'm new. how do I go about using that?
21:10:50 <ManateeLazyCat> @tell juhp Look manatee-all, now you just need type "cabal install manatee-all" to install *all* Manatee packages, simple enough now. :)
21:10:50 <lambdabot> Consider it noted.
21:11:01 <luite> jrick: add it to the top of your .hs file
21:11:05 <jrick> k
21:11:08 <applicative> jrick, the first line
21:11:10 <ManateeLazyCat> @tell juhp At http://hackage.haskell.org/package/manatee-all
21:11:10 <lambdabot> Consider it noted.
21:11:19 * hackagebot manatee-browser 0.1.1 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.1.1 (AndyStewart)
21:11:47 <jrick> cool, that worked
21:11:49 <jrick> thanks
21:11:53 <applicative> jrick, I think this arises especially in this sort of case because the underlying types in the new parsec are more abstract or general
21:12:17 <applicative> or whatever the right word is.
21:12:21 * hackagebot manatee-editor 0.1.1 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.1.1 (AndyStewart)
21:12:23 * hackagebot manatee-filemanager 0.1.1 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.1.1 (AndyStewart)
21:12:25 * hackagebot manatee-pdfviewer 0.1.1 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.1.1 (AndyStewart)
21:13:06 <jrick> applicative: ok, so what would be the correct way of using the new parsec?
21:13:33 <dolio> Give us the cuttlefish!
21:14:08 <applicative> jrick, I think it should work, there are the 'compatibility' modules, which you are importing, but they refer behind the scenes to more general types.
21:14:47 <applicative> jrick, the new parsec for example supports bytestring parsing, anything that can be a "Stream".
21:15:19 * hackagebot manatee-mplayer 0.1.1 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.1.1 (AndyStewart)
21:15:22 * hackagebot manatee-processmanager 0.1.1 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.1.1 (AndyStewart)
21:17:20 * hackagebot manatee-imageviewer 0.1.1 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.1.1 (AndyStewart)
21:17:22 * hackagebot manatee-terminal 0.1.1 - Terminal Emulator extension for Manatee.  http://hackage.haskell.org/package/manatee-terminal-0.1.1 (AndyStewart)
21:17:24 * hackagebot manatee-template 0.1.1 - Template code to create Manatee application.  http://hackage.haskell.org/package/manatee-template-0.1.1 (AndyStewart)
21:17:26 * hackagebot manatee-ircclient 0.1.1 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.1.1 (AndyStewart)
21:17:28 * hackagebot manatee-reader 0.1.1 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.1.1 (AndyStewart)
21:18:30 * hackagebot manatee-curl 0.1.1 - Download Manager extension for Manatee.  http://hackage.haskell.org/package/manatee-curl-0.1.1 (AndyStewart)
21:18:32 * hackagebot manatee-welcome 0.1.1 - Welcome module to help user play Manatee quickly.  http://hackage.haskell.org/package/manatee-welcome-0.1.1 (AndyStewart)
21:18:34 * hackagebot manatee 0.2.2 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.2.2 (AndyStewart)
21:18:36 * hackagebot manatee-all 0.2.2 - Virtual package to install all Manatee packages.  http://hackage.haskell.org/package/manatee-all-0.2.2 (AndyStewart)
21:22:12 <applicative> jrick, you can resolve the ambiguity with a type signature; so if, as here, you are parsing strings, i.e. [Char], you can use the type synonym "Parser".
21:22:24 <applicative> jrick: so you'd write e.g. parseInput :: Parser [Dir]
21:24:13 <jrick> applicative: oh cool, I think I get it
21:24:15 <applicative> as it stands, the inference is only that the definition of parseInput has the type "Text.Parsec.Prim.ParsecT s u m [Dir]" (with a certain class condition)
21:25:20 <jrick> I guess it was sort of odd that this tutorial hasn't defined any type signatures yet
21:25:24 <applicative> but for you s is [Char], u is (), and m is the "Identity" monad, i.e. a fancy name for the ordinary place where we program
21:26:32 <applicative> in the module Text.Parsec.String, we get: type Parser = Parsec String ()
21:28:07 <applicative> elsewhere the Parsec s u a turns out to be short for ParserT s u Identity a , which is a bit much
21:28:34 <applicative> yes in Text.Parsec.Prim
21:30:21 <applicative> but if you keep telling the compiler, damn it I'm just parsing Ints or Dirs or whatever, out of Strings -- with a type signature Parser Int or Parser Dir -- it will quiet down.
21:31:04 <jrick> ok
21:31:07 <applicative> or just write {-#LANGUAGE NoMonomorphismRestriction#-}
21:31:09 <applicative> :)
21:35:24 <mjk> how to get the fraction? for example: 1.2345 -> 1.23, round only get integral
21:36:53 <applicative> @type round (1.2345 * 100)
21:36:54 <lambdabot> forall b. (Integral b) => b
21:37:04 <applicative> > round (1.2345 * 100)
21:37:05 <lambdabot>   123
21:37:38 <ManateeLazyCat> > "%.2" 1.2345
21:37:39 <lambdabot>   Couldn't match expected type `t1 -> t'
21:37:39 <lambdabot>         against inferred type `[GHC....
21:37:42 <danharaj> http://www.smbc-comics.com/
21:37:43 <danharaj> <3
21:37:44 <mjk> thanks
21:38:12 <ManateeLazyCat> > printf "%.2" 1.2345
21:38:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:38:20 <lambdabot>    `Text.Printf.PrintfType ...
21:38:39 <ManateeLazyCat> > printf "%.2" 1.2345 :: String
21:38:39 <lambdabot>   "*Exception: Printf.printf: formatting string ended prematurely
21:38:50 <mjk> ManateeLazyCat: which module?
21:38:52 <ddarius> @hoogle showFloat
21:38:52 <lambdabot> Numeric showFloat :: RealFloat a => a -> ShowS
21:39:00 <ddarius> @hoogle showFFloat
21:39:01 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
21:39:05 <mjk> where is printf?
21:39:13 <ManateeLazyCat> @hoogle printf
21:39:14 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
21:39:14 <lambdabot> module Text.Printf
21:39:14 <lambdabot> Text.Printf class PrintfArg a
21:39:24 <ManateeLazyCat> > Text.Printf.printf "%.2" 1.2345 :: String
21:39:25 <lambdabot>   "*Exception: Printf.printf: formatting string ended prematurely
21:39:58 <Veinor> > Text.printf.printf "%f.2" 1.2345 :: String
21:39:58 <applicative> mjk  http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Text-Printf.html
21:39:59 <lambdabot>   Not in scope: `Text.printf'
21:40:05 <alexbagel> dont you need to put an f in there
21:40:08 <Veinor> > Text.Printf.printf "%.2f" 1.2345 :: String
21:40:09 <lambdabot>   "1.23"
21:40:15 <Veinor> there we go!
21:40:16 <ddarius> danharaj: That was good.
21:40:17 <applicative> hurrah
21:40:51 <ManateeLazyCat> > Text.Printf.printf "%.2f" 1.2345 :: String
21:40:51 <lambdabot>   "1.23"
21:40:55 <mjk> yes, Text.Printf.printf "%.2f" 1.2345 :: String is work fine
21:41:04 <ManateeLazyCat> Ooops, i miss f after %.2
21:41:26 <mjk> thanks all
21:41:55 * ManateeLazyCat pasted "An exmaple to use printf" at http://paste2.org/get/1414714
21:41:57 <ManateeLazyCat> mjk: ^^^^^
21:41:58 <ManateeLazyCat> :)
21:44:33 <latrene> hello all
21:45:02 <ManateeLazyCat> latrene: Hi. :)
21:45:43 <latrene> so...I made a function that does the sum of a list in parallel
21:45:48 <latrene> anyone wanna see it?
21:45:51 <latrene> http://nopaste.me/paste/3951207974dce09fde68a0
21:45:58 <latrene> i'm a Haskell beginner
21:47:33 <latrene> ^disclaimer
21:48:30 <dmwit> What's up with the vertical alignment of stuff on that page?
21:49:07 <ddarius> latrene: Don't use (\\) and definitely don't use length.  Also, you can generalize the function significantly.
21:49:32 <ddarius> Also there is a better way of splitting the list in "half" if you assume commutativity.
21:49:46 <latrene> which I would
21:50:06 <latrene> commutativity is true over all numbers
21:50:17 <ddarius> Your code currently only relies on associativity.
21:50:41 <ddarius> Operations are commutative, not numbers.
21:50:42 <latrene> how do I take advantage of commutativity?
21:51:20 <ddarius> latrene: How else might you produce two lists of (approximately) half the size of the input list?
21:51:50 <latrene> I could......guess?
21:52:10 <dmwit> Here's a hint, from a paste last night:
21:52:14 <dmwit> http://hpaste.org/46640/foldb
21:52:22 <ddarius> Incidentally, if you just replace 0 with mempty and (+) with mappend, you immediately generalize to any monoid.  Alternatively, you could just abstract out the 0 and plus and get an even more general function.
21:53:48 <latrene> hmmm
21:53:59 <latrene> well, I'm afraid I haven't learned about monoids yet
21:54:06 <latrene> other than hearing that I should learn about monoids
21:54:27 <dmwit> Monoids are sets with an associative operation and an identity.
21:54:31 <Axman6> monoids are extremely simple
21:54:34 <dmwit> So congratulations, you just learned monoids.
21:54:38 <latrene> lol
21:54:41 <latrene> So....
21:54:45 <latrene> similar to a fold
21:54:52 <Axman6> numbers are monoids in two ways, with (+) and 0 and (*) and 1
21:54:56 <applicative> + and 0; * and 1 ,
21:55:00 <Axman6> lists are monoids with (++) and []
21:55:14 <applicative> Axman6 types too fast.
21:55:19 <latrene> lol
21:55:37 <latrene> I'm happy I took Abstract Algebra after all
21:55:40 <Axman6> Maybe is a monoid with.. mplus and Nothing )i think)
21:55:42 <dmwit> ...and Maybe a can be a monoid in about 37 different ways. =)
21:55:42 <Axman6> (*
21:55:51 <Axman6> heh
21:55:52 <dmwit> No, mappend is not the same as mplus.
21:56:00 <Axman6> > Nothing `mplus` Just 1
21:56:00 <lambdabot>   Just 1
21:56:09 <dmwit> > mappend (Just [3, 4]) (Just [5, 6])
21:56:10 <lambdabot>   Just [3,4,5,6]
21:56:11 <Axman6> ah right, i never remember which is from which class
21:56:17 <dmwit> > mplus (Just [3, 4]) (Just [5, 6])
21:56:18 <lambdabot>   Just [3,4]
21:57:04 <latrene> ddarius, I want to get back to your question
21:57:30 <dmwit> Well, mplus is a more different mappend, I guess.
21:57:40 <dmwit> It's mappend for the First monoid.
21:57:43 <Axman6> :t mplus
21:57:43 <applicative> latrene, you could try to write a parallel version of length, it would be very similar up to a point: parLength [] = 0, parlength [x] = 1 ...
21:57:43 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
21:57:50 <Axman6> :m mappend
21:57:54 <Axman6> :t mappend
21:57:55 <lambdabot> forall a. (Monoid a) => a -> a -> a
21:58:06 <Axman6> :t mappend Nothing
21:58:07 <lambdabot> forall a. (Monoid a) => Maybe a -> Maybe a
21:58:19 <dmwit> :t mappend (First Nothing)
21:58:20 <lambdabot> forall a. First a -> First a
21:58:32 <dmwit> :t ala First mappend Nothing
21:58:33 <lambdabot>     Couldn't match expected type `Maybe a -> First a'
21:58:33 <lambdabot>            against inferred type `Maybe a1'
21:58:33 <lambdabot>     In the third argument of `ala', namely `Nothing'
21:58:52 <dmwit> :t ala First mappend
21:58:53 <lambdabot> forall a o'. (Newtype (Maybe a -> First a) o') => (Maybe a -> First a) -> o'
21:59:24 <dmwit> :t ala First (mappend Nothing)
21:59:24 <lambdabot>     Couldn't match expected type `Maybe a -> First a'
21:59:25 <lambdabot>            against inferred type `Maybe a1'
21:59:25 <lambdabot>     In the first argument of `mappend', namely `Nothing'
21:59:25 <applicative> @instances Monoid
21:59:26 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:59:28 <dmwit> I give up.
21:59:46 <djahandarie> I guess I should just provide an under2
22:00:57 <applicative> djahandarie: class Newtype is in lambdabot?!
22:01:13 <djahandarie> Yes, don't underestimate my bugging-Cale skills
22:01:44 <applicative> good work
22:02:40 <djahandarie> dmwit, fyi, you use foldMap with ala, not mappend
22:02:53 <dmwit> I DO WHAT I WANT
22:03:04 <djahandarie> (And one can think of foldMap as mappend over a list instead of mappend over two arguments)
22:03:12 <djahandarie> :t ala First foldMap
22:03:13 <lambdabot> Not in scope: `foldMap'
22:03:18 <djahandarie> :t ala First Data.Foldable.foldMap
22:03:19 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (Maybe a) -> Maybe a
22:03:28 <djahandarie> :t ala First Data.Foldable.foldMap [Nothing, Just 2, Nothing, Just 5]
22:03:29 <lambdabot> forall a. (Num a) => Maybe a
22:04:00 <dmwit> :t ala First mconcat
22:04:00 <lambdabot>     Couldn't match expected type `Maybe a -> First a'
22:04:00 <lambdabot>            against inferred type `[a1]'
22:04:00 <lambdabot>     In the second argument of `ala', namely `mconcat'
22:04:13 <djahandarie> dmwit, right idea, it's just you need to somehow get First into the list
22:04:26 <djahandarie> So you the map component as well
22:04:32 <djahandarie> If there was an mconcatMap it would do the job
22:05:55 <djahandarie> And oops, I meant to run that, not get the type
22:05:59 <djahandarie> > ala First Data.Foldable.foldMap [Nothing, Just 2, Nothing, Just 5]
22:05:59 <lambdabot>   Just 2
22:06:09 <infanticide> i just installed ubuntu and im a bit confused about how to install haskell
22:06:14 <infanticide> is this right:
22:06:26 <infanticide> ~shit never mind
22:06:35 <dmwit> nope
22:06:37 <djahandarie> I can confirm that is the incorrect command
22:06:37 <dolio> > ala (undefined :: Maybe a -> First a) Data.Foldable.folMap [Nothing, Just 2, Nothing, Just 5]
22:06:37 <jmcarthur> definitely wrong
22:06:38 <lambdabot>   Not in scope: `Data.Foldable.folMap'
22:06:45 <dolio> > ala (undefined :: Maybe a -> First a) Data.Foldable.foldMap [Nothing, Just 2, Nothing, Just 5]
22:06:46 <lambdabot>   Just 2
22:07:38 <dmwit> :t ala (undefined :: Maybe a -> [First a]) mconcat
22:07:39 <lambdabot>     Couldn't match expected type `Maybe a -> [First a]'
22:07:39 <lambdabot>            against inferred type `[a1]'
22:07:39 <lambdabot>     In the second argument of `ala', namely `mconcat'
22:07:49 <dmwit> blood and ashes
22:08:03 <dolio> [First a] isn't a newtype wrapper around Maybe a.
22:08:48 <djahandarie> dmwit, foldMap is literally just mconcat with the ability to map over the list beforehand
22:09:30 <djahandarie> :t ala First (mconcat .: map) [Nothing, Just 2, Nothing, Just 5]
22:09:31 <lambdabot> forall a. (Num a) => Maybe a
22:09:35 <djahandarie> > ala First (mconcat .: map) [Nothing, Just 2, Nothing, Just 5]
22:09:37 <lambdabot>   Just 2
22:11:24 <djahandarie> > mconcat [First Nothing, First (Just 2), First Nothing, First (Just 5)] -- is what that command turns into after a few steps of evaluation
22:11:25 <lambdabot>   First {getFirst = Just 2}
22:11:32 <djahandarie> Oops, with get unpack outside of it
22:11:38 <djahandarie> > getFirst . mconcat [First Nothing, First (Just 2), First Nothing, First (Just 5)] -- is what that command turns into after a few steps of evaluation
22:11:39 <lambdabot>   No instance for (GHC.Base.Functor Data.Monoid.First)
22:11:39 <lambdabot>    arising from a use ...
22:11:41 <djahandarie> Bah
22:11:45 <djahandarie> > getFirst $ mconcat [First Nothing, First (Just 2), First Nothing, First (Just 5)] -- is what that command turns into after a few steps of evaluation
22:11:45 <lambdabot>   Just 2
22:21:04 <djahandarie> ala First (mconcat .: map) [Nothing]      == {definition of ala}      (getFirst . (mconcat .: map) First) [Nothing]      == {definition of .: & some reduction}      (getFirst . (mconcat . map First)) [Nothing]      == {defintion of .}      getFirst ((mconcat . map First) [Nothing])      == {defintion of .}      getFirst (mconcat (map First [Nothing]))      == {definition of map}      getFirst (mconcat ([First Nothing]))      == {Monoid instan
22:21:13 <djahandarie> Hmm. This would sure look better in a pastebin
22:24:27 <djahandarie> dmwit, http://hpaste.org/46677/ala
22:25:43 <djahandarie> You can see where that First would end up if there was no map there
22:25:57 <djahandarie> (Somewhere that it'd make no sense at all)
22:50:27 <alexbagel> why is "Bool" not a single-constructor data type?
22:50:53 <alexbagel> actually, not "why" but rather "in what way"?
22:51:02 <shachaf> What?
22:51:16 <alexbagel> wait, i just realised that was a dumb question
22:51:22 <shachaf> Bool has two constructors: True and False. It wouldn't be much of a boolean otherwise.
22:51:33 <shachaf> (There's also _|_, but that's not a constructor.)
22:52:15 <alexbagel> sorry, was reading "Performace/Data_Types" on the wiki and it said "This only happens when the function argument is a single-constructor type. Note that basic types like Int and Char count as single-constructor types, but not Integer and Bool."
22:52:57 <alexbagel> struck me as odd that bool didnt behave like an int but yeah, i forgot thats its just True | False. sorry!
22:56:49 <djahandarie> The thing that should be striking you as odd is that Int is treated as a single-constructor type in GHC
22:58:27 <Axman6> the one that's more odd to me is Integer not being one, but it makes sense when you see GHC's definition
22:58:30 <Axman6> @src Integer
22:58:30 <lambdabot> data Integer = S# Int#
22:58:30 <lambdabot>              | J# Int# ByteArray#
22:58:49 <alexbagel> @src Bool
22:58:49 <lambdabot> data Bool = False | True deriving (Eq, Ord)
23:00:21 <djahandarie> (Fyi, data Int = I# Int#)
23:00:41 <djahandarie> @src Int
23:00:41 <lambdabot> data Int = I# Int#
23:00:51 <djahandarie> lambdabot is so smart ;)
23:02:01 * djahandarie runs to bed
23:53:24 <Axman6> hmmm, i need an efficient data structure that lets me look up values in a sort of CFD map. so i need to find the first value whose (cumulative) frequency is larger than the requested one
23:54:31 <mauke> what's a frequency?
23:55:02 <Axman6> it's for the fasta benchmark in the shootout
23:55:31 <Axman6> manages to make it a bit faster, but it seems this could be faster. it's currently using a linear search, and i feel this could be better
23:56:14 <Axman6> though the number of values being examined isn't large (max of 15)
23:57:47 <dmwit> finger trees sound reasonable here
