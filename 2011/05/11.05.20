00:00:25 <mm_freak> http-enumerator is not good for proxying anyway
00:00:39 <mm_freak> ihttp can do proxying
00:07:48 <KirinDave> ihttp seems much more promising, mm_freak.
00:07:49 <KirinDave> Ty.
00:08:05 <KirinDave> For one, its headers structure is not agonizing to work with when you have dynamic headers.
00:11:43 <jeffz> mm_freak: why do you say it's not good for proxying?
00:11:56 * hackagebot text-format 0.1.0.0 - Text formatting  http://hackage.haskell.org/package/text-format-0.1.0.0 (BryanOSullivan)
00:12:20 <jeffz> mm_freak: I saw a demo done with Wai, Warp and http-enumerator yesterday that did proxying of large files at hundreds of megabytes per second in constant memory.
00:15:57 * hackagebot uu-parsinglib 2.7.1.1 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.1.1 (DoaitseSwierstra)
00:16:43 <KirinDave> jeffz: That sounds like a cool demo
00:17:04 <jeffz> it'll be up on youtube sometime soon i think.  it was at fp-syd.
00:17:17 <jeffz> m3ga gave the demo
00:23:20 <m3ga> hey jeffz
00:23:50 <jeffz> 'lo
00:41:08 <kmc> @ghc
00:41:09 <lambdabot> ghc says: Use -fcontext-stack20 to increase stack size to (e.g.) 20
00:43:19 <exeter> good morning haskelia!
00:44:03 <Schalken> exeter: good morning
00:44:08 <shachaf> @ghc
00:44:09 <lambdabot> ghc says: falls under the monomorphism restriction
00:44:31 <exeter> I've got a naive question: is there anything like php in haskell? I mean, I've got to write some simple stuff in php (simple as in: a function that show what's inside a folder). Since I'm learning Haskell and would like to stick to functional for a bit I wondered if I could do that with H too.
00:45:01 <exeter> Is it feasible or too complicated (remember that I am a newbie)
00:46:16 <Schalken> exeter: There are some web frameworks for Haskell, like Snap and Yesod. You could also write a CGI program if you like. ;)
00:46:17 <augur> aristid: i wrote another paper
00:46:43 <augur> aristid: well, two more papers, assuming i didnt show you the pointer logic one
00:47:54 <exeter> Schalken: would that be complex? I just would like to fetch some data like the left menu in this page ( http://uoou.info/ ). If it's easier with php I'd stick to that. What do you think?
00:50:11 <Schalken> exeter: I don't know because I haven't used Haskell for web development. But getting something simple mostly working quickly is what PHP is good at. In fact, that's all PHP is good at.
00:51:04 <exeter> it's settled then, thanks for the tip!
00:51:52 <balor> exeter, snap framwork and happstack are nice http://snapframework.com/ and http://happstack.com/index.html
01:01:46 <mm_freak> jeffz: i tried to get http-enumerator to make a CONNECT and failed
01:01:53 <mm_freak> that's actually the reason why i wrote ihttp
01:02:52 <mm_freak> it's good for this sort of thing, but right now not very convenient for normal HTTP 1.1 requests (mainly because it doesn't support the chunked encoding yet)
01:04:16 <m3ga> mm_freak: i added HTTP proxying to http-enumerator just recently (still in git, not released). working on HTTPS proxying
01:04:54 <mm_freak> m3ga: including CONNECT?
01:05:15 <m3ga> afaik thats the only way to mahe HTTPS over a proxy work
01:06:07 <mm_freak> m3ga: what i need is an iteratee-based approach, which gives me full control over the session
01:06:34 <mm_freak> so i can do something like this:  sendConnectRequest h >> client
01:07:11 <mm_freak> or rather:  sendConnectRequest h >> (decodeResponse =$ client)
01:07:20 <mm_freak> something like that
01:07:28 <mm_freak> this is what i couldn't find in http-enumerator
01:07:50 <m3ga> well apart from not doing HTTPS via a proxy http-enum works for me.
01:08:10 <m3ga> if you have other needs you should ask on the web-devel@h.o mailing list
01:08:19 <hyuma> hello
01:08:35 <mm_freak> m3ga: normally i would do that, but i was under time pressure
01:09:16 <mm_freak> couldn't wait until someone volunteers to change/fork http-enumerator, so i decided to write my own library with the same interface style as ismtp
01:09:42 <mm_freak> that way i can combine those two libraries easily, which is exactly my application
01:09:52 <mm_freak> proxy SMTP through HTTP
01:10:36 <m3ga> won't most proxies reject that? the default Squid config only accepted CONNECTs bound for port 443
01:10:52 <mm_freak> yes, it's for internal purposes
01:10:59 <mm_freak> so the proxy is under my administration
01:11:50 <mm_freak> i even thought about writing an own SMTP-aware proxy protocol, which could optimize things for me, but refrained from doing that
01:12:34 <develhevel> who know if i can set in leksak things like x<-getArgs how to set the args here to test it?
01:17:06 <cheater79> hi
01:25:47 <absence> what's the difference between getBytes and getByteString in Data.Binary.Get?
01:26:54 <ectospasm> in the beetle book and the "Learn you a..." book, I'm about three chapters into each.  Other places, I keep seeing this notation:  intersperce sep = foldl1 $ (++) . (++ sep)
01:27:18 <ectospasm> what does the "func $ ..." syntax mean?
01:27:32 <shachaf> ectospasm: It's probably explained in the book somewhere.
01:27:34 <ectospasm> What does the $ mean in that context
01:27:41 <nlogax> @src ($)
01:27:41 <lambdabot> f $ x = f x
01:27:44 <shachaf> a $ b c means approximately a (b c)
01:27:47 <ectospasm> shachaf: yeah, but it's a little hard to just search for '$"
01:27:54 <shachaf> It's mainly used to get rid of parentheses.
01:28:01 <shachaf> ectospasm: You could read the book in order. :-)
01:28:41 <ectospasm> yeah, but when folks in the comments of the beetle book use that notation, it confuses the reader
01:28:58 <ectospasm> ...and sequentially reading is what I'm trying to do, going at a snails pace.
01:29:26 <ectospasm> I feel like the "Learn you a Haskell" book gives me more "Ah HA!" moments.
01:31:12 <hyuma> i've a doubt how to do this:
01:31:14 <hyuma> http://hpaste.org/46888/aldini
01:31:20 <frerich> ectospasm: I think the '$' function is only used to reduce the "noise" on lines, since 'a $ b $ c $ d' is nicer than 'a(b(c(d)))'
01:31:44 <hyuma> my problem is to value statements, anyone could help me please?
01:35:15 <Cale> hyuma: So, it should look similar to each of the previous evaluation functions you wrote, in that it'll do something different to the state for each of the statement constructors.
01:35:32 <nlogax> > map ($ "lol") [map toUpper, drop 2, (++ "omg")] -- it has many uses, frerich :)
01:35:33 <lambdabot>   ["LOL","l","lolomg"]
01:35:57 <Cale> hyuma: btw, tabs are not a good thing to have in Haskell source files, it would be best if you configured your editor to convert them to spaces automatically
01:36:56 <shachaf> frerich: a . b . c $ d is even nicer.
01:37:07 <flux> nlogax, right, the other uses being mainly code obfuscation?-)
01:37:16 <absence> how does leksah determine which packages are available? it automatically downloaded packages like zlib and bytestring, but says convertible is a missing dependency, even though it's on hackage
01:37:17 <Cale> hyuma: So, you should have something like  evalS (AssI var expr) s = ...; evalS (Comp stmt1 stmt2) s = ...; evalS Skip s = ... and so on
01:37:37 <burbul> I'm having trouble installing EclipseFP... the archive net.sf.eclipsefp.haskell_2.0.4.zip (downloaded from two different mirrors) doesn't seem to valid .zip file. Does anyone have any ideas?
01:37:40 <Cale> hyuma: and then for each of those constructors, we need to determine what effect we want the statement to have on our state
01:37:59 <burbul> *to be a valid zip file
01:41:50 <Cale> burbul: Hmm, I'm seeing that too.
01:42:15 <Cale> burbul: Perhaps it's never come up because nobody really uses Eclipse for haskell ;)
01:42:35 <Cale> burbul: But more seriously, I'll give the other install method a shot and see if I can get it to work.
01:43:41 <burbul> Thanks!
01:44:11 <Cale> https://github.com/JPMoresmau/eclipsefp -- there's this I just found as well.
01:47:54 <Cale> burbul: The installation from inside Eclipse seems to have worked.
01:51:49 <Cale> lol, I opened a Haskell source file, and every time I move the cursor, I get a NullPointerException
01:52:48 * Cale uninstalls Eclipse :P
01:53:27 <mm_freak> what kind of emacs user does even consider trying eclipse?
01:54:03 <Cale> Even emacs is usually too bloaty for me :)
01:54:23 <Cale> I've used emacs a bunch in the past, but somehow I still prefer vim.
01:55:00 <burbul> Cale: thanks! Can I check what location you installed it from? I tried http://eclipsefp.sf.net/ before (and the one you gave now) and Eclipse can't find anything there
01:55:10 <burbul> mm_freak: a non-emacs user
01:55:30 <Cale> I added  http://eclipsefp.sf.net/updates  to the "Install New Software..." thingy under the Help menu.
01:55:38 <burbul> For languages I know, I use a much more lightweight editor
01:55:54 <burbul> (I'm just learning Haskell pretty much from scratch)
01:56:03 <mamalujo> mm_freak: trying, why not - trying for longer than X min, that's different :)
01:56:08 <burbul> I was just playing around in GHCi, but I found I couldn't do various things ---
01:56:12 <Cale> burbul: Any text editor should really do about as well.
01:56:14 <shachaf> burbul: You're using Eclipse because you're learning Haskell?
01:56:14 <burbul> For example I can't define a new datatype
01:56:28 <Cale> burbul: The standard thing to do is to open up your text editor alongside ghci (in a separate window)
01:56:31 <burbul> shachaf: yes,  I had it recommended to me yesterday
01:56:39 <shachaf> burbul: I've never heard of anyone doing that. It's not really the kind of language where you need deep IDE integration or anything.
01:56:40 <Cale> burbul: Every time you save your file, :r in ghci will reload it.
01:56:43 <burbul> And keep saving and reloading?
01:56:44 <burbul> ok
01:56:46 <burbul> Thanks
01:56:50 <shachaf> Well, maybe it is. But you don't get deep IDE integration as far as I know. :-)
01:57:06 <Cale> So you put definitions in your file, and then test them out in ghci with various expressions.
01:57:09 <mamalujo> Cale: or just split the Screen in your terminal :)
01:57:15 <Cale> sure
01:57:18 <roconnor> @seen copumpkin
01:57:18 <lambdabot> Unknown command, try @list
01:57:18 <preflex>  copumpkin was last seen on #haskell 4 hours, 16 minutes and 55 seconds ago, saying: sure
01:57:20 <burbul> :r makes life a lot easier...
01:57:25 <burbul> I'll give it a go.
01:57:30 * Cale only uses screen via ssh.
01:59:34 <mamalujo> hm! I'm currently very happy w connecting all terminal sessions into one screen session
02:04:16 <mm_freak> mamalujo: perhaps i'm judging as someone, who used (or rather tried to use) eclipse productively before =)
02:04:42 <mm_freak> Cale: i don't care, if my editor needs two seconds to start…  i tried vim, but it's really not my world
02:05:18 <mm_freak> i admit, it has some very nice editing features, but i found that all the rest is missing
02:06:58 <mm_freak> burbul: with haskell i've come to the point where i completely separate writing program code from using/testing it, so i always have emacs and a separate terminal open, where i usually just run the compiled program
02:07:04 <Cale> I don't really care a whole lot about the features that my text editor has. If it can convert tabs to spaces, and do a little bit of syntax colouring, I can get along with it.
02:07:30 <mm_freak> although i like the way it's handled in the emacs mode for agda
02:07:57 <mm_freak> i'd love to have such a powerful more for haskell
02:08:08 <mm_freak> more → mode
02:08:40 <mm_freak> Cale: that's probably fine, if you have small projects, but my projects get fairly large
02:09:04 <mm_freak> emacs is very good with multiple buffers and handling switching between them
02:09:46 <burbul> mm_freak: while I'm messing around it's very convenient not to have to compile
02:09:56 <mm_freak> it also has a few editing features, which vim lacks…  i prefer to let my thoughts flow into the editor without having to think too much about how to get the layout right
02:10:00 <Cale> I'm not using anything complicated for BloodKnight :P
02:10:26 <Cale> I guess we're using Haddock and Hoogle though :)
02:10:34 <mm_freak> burbul: i often write pages of code before issuing a single compilation
02:10:41 <mm_freak> it's possible in haskell
02:11:26 <Cale> I'm the opposite. I tend to want to compile quite often.
02:11:27 <burbul> I can believe it -- but as I said, I'm just learning the language!
02:11:32 <mm_freak> usually i get one or two type errors and once fixed i can test…  and usually, when my types are correct, i experience this: http://www.haskell.org/haskellwiki/Why_Haskell_just_works
02:12:16 <mm_freak> Cale: often along the way i change my types a lot, so first i come to a concrete concept and then i compile
02:12:51 <mm_freak> i try different ideas in my editor without compiling and see, if they are useful
02:21:06 <rostayob> is there a way to get the endiannes of the machine in haskell?
02:25:55 <roconnor> rostayob: interesting question ...
02:26:22 <rostayob> one way would be to poke a Word16 and then peek the two bytes I guess
02:26:36 <rostayob> i mean like
02:26:41 <rostayob> with pokeArray maybe
02:27:50 <rostayob> but that would be hacky
02:28:30 <mauke> why do you need to know?
02:29:18 <rostayob> mauke: I'm reading a dump and I want the file and the host machine so be of the same endiannes of the file
02:30:09 <rostayob> stripe the "of the file" at the end :P
02:30:39 <rostayob> *strip. I'm tireeed
02:33:19 <mamalujo> mm_freak: re 2 sec to start - emacsclient starts practically instantly
02:38:26 <MasseR> Should enumerators allow strict reading from a handle without the remote end disconnecting?
02:38:29 <MasseR> http://hpaste.org/46890/enumerators_oo
02:38:47 <MasseR> The parseirc function currently just prints the line received
02:38:57 <MasseR> An nothing is received until I ^D nc
02:39:00 <MasseR> *And
02:39:07 <develhevel> how to check if a String is empty or size = 0?
02:39:38 <MasseR> develhevel: If String; null x
02:40:07 <MasseR> *Shouldn't
02:41:22 * hackagebot yesod-auth 0.4.0.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.4.0.2 (MichaelSnoyman)
02:42:40 <Axman6> :t null
02:42:41 <lambdabot> forall a. [a] -> Bool
02:53:22 <develhevel> i have a main module and a second module and i call functions from second in main. now i want to quit the whole programm when someting went wrong in second, how could i do this?
02:58:10 <mm_freak> mamalujo: i have a lot of scripts installed
02:58:12 <develhevel> is there a function to terminate the whole programm?
02:58:18 <mm_freak> my emacs needs well 2 or 3 seconds to start
02:58:25 <mauke> :t exitWith
02:58:26 <lambdabot> Not in scope: `exitWith'
02:58:47 <mm_freak> sometimes even longer
02:58:52 <poltak> :t exitWith
02:58:52 <lambdabot> Not in scope: `exitWith'
02:58:53 <mm_freak> mainly because of things like cedet and ECB
02:58:53 <mamalujo> but, doesn't it do that once and just deamonize?
02:59:02 <mm_freak> oh
02:59:09 <mm_freak> i don't know, i don't daemonize
02:59:12 <mamalujo> ah
02:59:17 <mm_freak> i wouldn't even know that emacs can do that
02:59:29 <mamalujo> fairly recent, I think
03:00:10 <mamalujo> http://www.emacswiki.org/emacs/EmacsAsDaemon
03:00:18 <mamalujo> emacs 23.
03:01:56 <mamalujo> relevant: http://xkcd.com/378/ ; apparently M-x butterfly is implemented in 23 as an easter egg :)
03:04:47 <develhevel> when i see a signature like: "throw :: Exception e => e -> a" i know that e is a typeclass (Exception) but what kind of type is the a?
03:05:28 <Jafet> throw e never has a value, so you don't have to worry about it
03:05:31 <mauke> any
03:07:40 <develhevel> nm, so the signature could be: throw :: Exception e => e, or i dont understand it
03:09:35 <mauke> develhevel: that would be a constant
03:09:53 <develhevel> mauke: AHH you are right, thx, now i understand
03:23:03 <mm_freak> mamalujo: good to know, thanks for that
03:25:12 <mamalujo> np. I use such setup as my nano replacement in terminal, though I must admit I can't manage to give emacs sufficient time to memorize various commands , so its not much more than nano w great undo to me :) (but I'm way OT, sry)
03:28:50 <develhevel> how to get the file ending when i get a FilePath
03:29:42 <mm_freak> develhevel: what is the "file ending"?  the basename?  the extension?
03:29:50 <develhevel> extension
03:29:56 <poltak> mm_freak: .sh
03:30:22 <ClaudiusMaximus> @hoogle extension
03:30:23 <lambdabot> System.FilePath.Posix addExtension :: FilePath -> String -> FilePath
03:30:23 <lambdabot> System.FilePath.Windows addExtension :: FilePath -> String -> FilePath
03:30:23 <lambdabot> System.FilePath.Posix dropExtension :: FilePath -> FilePath
03:30:30 <mm_freak> develhevel: see System.FilePath
03:30:41 <mm_freak> splitExtension, takeExtension, replaceExtension, etc.
03:30:49 <develhevel> thx
03:34:46 <hpc> shouldn't those be in IO? how would they handle init.d?
03:35:29 <mauke> ("init", "d")
03:36:12 <hpc> but directories don't have extensions
03:36:34 <jeffz> and extensions are just characters in a string
03:36:41 <jeffz> pretty arbitrary stuff.
03:37:06 <rothwell> hm... what's the correct way to write an Arbitrary instance (quickcheck) for 'data User_Name = User_Name String'?
03:37:10 <mauke> hpc: why not?
03:37:10 <hpc> fair point
03:37:11 <hpc> nvm
03:37:19 <rothwell> there are no restrictions on the content... really just want a random string
03:37:34 <mauke> rothwell: you could make it a newtype and derive the instance
03:37:43 <hpc> ^
03:37:51 <rothwell> mauke: oh... wasn't aware that was possible!
03:37:59 <rothwell> GeneralizedNewtypeDeriving?
03:38:00 <hpc> or look at the String instance and duplicate that
03:40:54 <kosmikus> why would you duplicate it rather than using "deriving" or just wrapping it?
03:41:05 <develhevel> does i understand it right, when i write "-> IO ()" i make only sone print etc. and when i write "-> IO String" i make some print etc and then return a String
03:41:36 <mauke> develhevel: basically, yes; for IO () you return a ()
03:41:43 <mauke> @src ()
03:41:44 <lambdabot> data () = ()
03:42:13 <develhevel> okay
03:42:27 <erus`> @t data
03:42:27 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:42:49 <erus`> @ty data
03:42:50 <lambdabot> parse error on input `data'
03:43:06 <develhevel> mauke: at the end when i e.g. want to implement a "-> IO String" i just make "return "foo""?
03:43:19 <mauke> that would work
03:43:35 <mauke> :t putStr "hello\n" >> return "foo"
03:43:36 <lambdabot> IO [Char]
03:44:15 <erus`> @hoogle IO a -> a
03:44:15 <lambdabot> Foreign unsafePerformIO :: IO a -> a
03:44:15 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
03:44:15 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
03:56:18 <ski> rothwell : `arbitrary = liftM User_Name arbitrary' would work ..
03:56:50 <ski>   arbitrary = do
03:56:52 <ski>     s <- arbitrary
03:56:59 <ski>     return (User_Name s)
03:57:00 <ski> as well
03:57:20 <rothwell> i actually ended up with: fmap User_Name QC.arbitrary
03:57:35 <ski> yeah, `fmap' is the same as `liftM', in monads
03:57:36 <rothwell> seems happy with that
03:57:39 <hpc> :t arbitrary
03:57:40 <lambdabot> forall a. (Arbitrary a) => Gen a
03:57:45 <hpc> @src Gen
03:57:45 <lambdabot> Source not found. My pet ferret can type better than you!
03:58:00 <ski> @src liftM
03:58:01 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:58:34 <wto> isn't that a weird way to do liftM?
03:58:43 <ski> why ?
03:58:51 <wto> liftM f m1 = m1 >>= return . f would look neater imo
03:59:05 <hpc> @src join
03:59:05 <lambdabot> join x =  x >>= id
03:59:13 <wto> ski: but of course, it's nothing wrong with that way of doing it either
03:59:26 <ski> @undo liftM f m1 = do { x1 <- m1; return (f x1) }
03:59:26 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1)
04:02:06 <mm_freak> hpc: in a sane system (i.e. not windows) there is no such thing as a filename "extension"
04:02:22 <mm_freak> as jeffz says they are just substrings
04:10:15 <erus`> > not . true
04:10:16 <lambdabot>   Not in scope: `true'
04:10:20 <erus`> > not . True
04:10:21 <lambdabot>   Couldn't match expected type `f GHC.Bool.Bool'
04:10:21 <lambdabot>         against inferred typ...
04:11:15 <ski> > not True
04:11:16 <lambdabot>   False
04:13:02 <erus`> i saw some code that had if (not.endOfDialog) blah blah
04:13:23 <hpc> erus`: endofDialog :: Something -> Bool?
04:14:45 <erus`> ah
04:15:10 <hpc> :t not . ?f
04:15:11 <lambdabot> forall (f :: * -> *). (?f::f Bool, Functor f) => f Bool
04:32:10 <o-_-o> * Missing (or bad) header file: HsOpenGL.h compiling haskell-platform on linux
04:32:15 <o-_-o> anyone else seen this error
04:32:19 <o-_-o> the file exists
04:32:41 <o-_-o> config.status: creating include/HsOpenGL.h
04:32:45 <o-_-o> config.status: include/HsOpenGL.h is unchanged
04:33:10 <quicksilver> I'm guess it's bad not missing
04:33:18 <quicksilver> and I"m guessing the 'bad' is it can't find the header files *it* includes.
04:33:23 <quicksilver> this is 100% guesswork :)
04:33:35 <quicksilver> but, continuing my guesswork, I'm guessing you need to install mesag-dev
04:33:46 <o-_-o> the config.log does not have *any* errors
04:33:47 <quicksilver> or whatever your dist. calls the opengl dev package
04:34:03 <quicksilver> do you have /usr/include/GL.h?
04:34:31 <o-_-o> I have installed the dev files, the top level configure does not go through if it is not installed, it passed all the opengl tests
04:34:49 <o-_-o> the top level configure, I mean, but building the OpenGL package is failing
04:35:12 <o-_-o> there are also some threads in mailing lists, but I can't make out anything from them
04:35:27 <o-_-o> quicksilver: yes, I have gl.h, glu.h and glut.h
04:35:38 <quicksilver> OK I'm out of guesses, sorry :(
04:35:54 <o-_-o> :-(
04:39:56 <jeffz> o-_-o: try running cabal with -v3
04:40:33 <o-_-o> this machine does not have anything installed, installing haskell for first time, so compiling haskell-platform from scratch
04:41:58 <jeffz> compiling haskell-platform? it's usually better (read easier) to opt for a binary distribution
04:42:35 <o-_-o> jeffz: in this case I can't, I am on a large shared set of nodes and I just have an account
04:43:03 <o-_-o> so if I need anything that everybody does not use regularly, I need to install it myself and I don't have root access :-(
04:53:58 <hyuma> i'm trying to write set function, here's my code anyone could help me? http://hpaste.org/paste/46888/aldini_annotation#p46892
04:59:07 <ski> either define `set' separatedly from `evalS' (i.e. not inbetween the clauses of `evalS'), or put `set' in a `where' attaching to that `evalS' clause
04:59:08 <Zao> hyuma: "set" as in variable assignment?
04:59:27 <ski> hyuma : do you understand ?
04:59:28 <Zao> Oh, didn't see that comment.
05:00:43 <hyuma> Zao: ?
05:00:56 * Zao defers to ski 
05:01:16 * ski defers to Zao
05:01:18 <hyuma> :D
05:01:37 <Zao> Lazy a instance detected.
05:03:10 * ski assumes `Meno' is italian for `Minus'
05:03:27 <hyuma> yep
05:03:32 <ski> is `Min' italian for `LesserThan' ?
05:03:40 <hyuma> yes
05:03:59 <ski> in english, `Min' would mean *the* least of two numbers, not whether one is lesser that the other
05:04:08 <ski> > min 3 5
05:04:09 <lambdabot>   3
05:04:11 <ski> > min 5 3
05:04:11 <lambdabot>   3
05:04:34 <mauke> let minp = (<)
05:05:14 <ski> hyuma : anything else you're wondering about, in that piece of code ?
05:06:41 <hpc> :t min
05:06:41 <lambdabot> forall a. (Ord a) => a -> a -> a
05:06:57 <hyuma> :t Maybe
05:06:58 <lambdabot> Not in scope: data constructor `Maybe'
05:07:13 <hyuma> :t Nothing
05:07:14 <lambdabot> forall a. Maybe a
05:08:42 <ski> @type fromMaybe
05:08:43 <lambdabot> forall a. a -> Maybe a -> a
05:09:15 <hyuma> ski: I'm thinking about set :: String -> Int -> State -> State
05:09:18 <ski> > fromMaybe "lose !" (Just "hey")
05:09:18 <lambdabot>   "hey"
05:09:22 <ski> > fromMaybe "lose !" Nothing
05:09:23 <lambdabot>   "lose !"
05:09:32 <hpc> :t maybe
05:09:33 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:09:35 <hyuma> > 4 + 4
05:09:36 <lambdabot>   8
05:09:52 <ski> hyuma : sounds reasonable, in your case, yes
05:10:03 <hpc> fromMaybe = flip maybe id
05:10:11 <hpc> :t flip maybe id
05:10:12 <lambdabot> forall a. a -> Maybe a -> a
05:10:15 <hpc> :D
05:10:25 <ski>   (`maybe` id)
05:11:22 * ski suspects hyuma is going with the "separate `set' from `evalS' clauses" route ..
05:12:06 <hyuma> ski: yes im writing set separate funciotn
05:13:11 <ski> hyuma : btw, if you write it without type signature, then you could load it into your interactor, and ask for what type has been inferred (by `:t set')
05:13:26 <ski> hyuma : in this case, it would probably infer `String -> Int -> State -> State' for you
05:14:07 <ski> (maybe writing that as `[Char] -> Int -> [([Char],Int)] -> [([Char],Int)]' though, expanding the type signatures)
05:14:54 <hyuma> ski: set :: (Eq a) => a -> b -> [(a,b)] -> [(a,b)]
05:16:19 <ski> oh, right
05:16:35 <ski> (because you didn't use a new type for `State' .. i forgot that)
05:16:55 <ski> either type signature works, of course
05:17:14 <ski> probably the more restricted one is more sensible (unconfusing) in your case, though
05:17:25 <ski> (since you're not going to use the generality anyway)
05:17:49 <hyuma> then: set (str val) s = (str, val) s
05:18:50 <absence> how can i read floats and doubles from a binary file?
05:19:13 <mauke> absence: what format?
05:19:30 <ski> hyuma : you need a `:' as well (as in the original code)
05:19:54 <absence> mauke: regular ones, stored in big endian byte order
05:20:13 <mauke> absence: there is no "regular format"
05:20:40 <absence> ieee is the only floats i've ever seen, so i consider them pretty regular :)
05:29:12 <absence> aha, Data.Binary.IEEE754 to the rescue
05:30:39 <Melvar> Are there standard names or symbols for flip (.) and flip ($) ?
05:31:04 <sipa> @pl flip (.)
05:31:04 <lambdabot> flip (.)
05:31:07 <ClaudiusMaximus> :t (>>>)
05:31:08 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
05:35:02 <Melvar> I just got how writing foldl in terms of foldr works, and those two operators played a critical part.
05:37:12 <ski> Melvar : i sometimes define `(>.>) = flip (.)' and `($>) = flip ($)'
05:37:59 <ski> hyuma : getting it to work as you want to ?
05:39:24 <hyuma> ski: I don't know how explain
05:39:51 <ski> try ?
05:40:01 <Melvar> So far, I’ve used ‘(|>) = flip (.)’ (read “before”) and ‘(>|) = flip ($)’ (read “gozinta”).
05:40:31 <ski> Melvar : also note there's `(>>>)'
05:40:34 <ski> @type (>>>)
05:40:35 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
05:40:59 <ski> > ((2 *) >>> (2 ^)) 3
05:40:59 <lambdabot>   64
05:42:07 <Chewie[]> i am using a parsec parser (pandoc) and i need to dump the state after a runParser invocation.
05:42:18 <Melvar> … looks a teensy bit advanced for me to understand yet.
05:46:28 <scree> Melvar: for "cat a b", read "a -> b".  You can think of a "cat a b" as something that looks a bit like a function, but might have more structure
05:51:02 <luite>  /last wolfgang
05:51:04 <luite> oop
05:51:05 <luite> s
05:51:10 <mekeor> lol
05:51:11 <mekeor> :)
05:52:05 <absence> http://pastebin.com/dwKGL5DR <- could anyone please explain why this program doesn't print anything before it crashes? i assume i'm doing something wrong regarding laziness
05:54:26 <roconnor> absence: could be line buffering, could be it crashes on trying to open the file.  I don't know how strict Z.decompress is.
05:54:37 <Gracenotes> very intriguing email on haskell-cafe
05:54:45 <Gracenotes> I can't tell what it's about though
05:55:03 <roconnor> Gracenotes: fireman119?
05:55:33 <Gracenotes> yes. seems to be some... message. perhaps left by his cat.
05:56:13 <absence> roconnor: Z.decompress is supposed to be lazy. it crashes where it "should", i.e. "too few bytes", not a problem with opening the file
05:57:36 * ski wonders whether `466' might be a file permission ..
05:58:17 <Gracenotes> a bit of a silly one
05:59:12 <ski> maybe the user is afraid of accidentally overwriting their file
05:59:56 <Gracenotes> maybe they have an aversion to 666
06:10:48 <erus`> ping
06:12:59 <bsrkaditya> I have a function that takes an Int and returns a Int
06:12:59 <bsrkaditya> and it is a strictly increasing function.
06:13:00 <bsrkaditya> I have to find the minimum value it takes to get atleast
06:13:00 <bsrkaditya> some value (like lower_bound in c++)
06:13:00 <bsrkaditya> I need to do it in logarthmic time.
06:13:00 <bsrkaditya> How should I do it(in haskell)?
06:15:54 <Chewie[]> bsrkaditya: is the domain finite, is there a maximum input value?
06:16:12 <bsrkaditya> yes
06:16:19 <bsrkaditya> max inp 8e6
06:16:23 <bsrkaditya> min 1
06:18:39 <djahandarie> Spawn 2^(8e6) universes and pick a random number in your range. Inspect each universe and see if it is your number. If it isn't, destroy the universe.
06:19:33 <Chewie[]> well you can get log_2 by always dividing in half and testing the two center values.
06:20:19 <bsrkaditya> yeah, but my ques is there a lower_bound equivalent in haskell?
06:20:33 <bsrkaditya> do I have to code a lower bound myself?
06:21:25 <Chewie[]> unsure, wait for more input. sry.
06:23:12 <djahandarie> bsrkaditya, it's not a standard library function, but you could write it
06:24:55 <bsrkaditya> thanks
06:34:39 <zenzike> I have a library that uses a "deriving Show" for one of the datatypes: I'd like to provide my own Show instance for the type instead. Is this possible, or do I have to modify the library so it doesn't derive Show?
06:35:43 <Lemmih> zenzike: How about using some other type-class than Show?
06:36:27 <zenzike> Lemmih: yep, that's a good idea, so I could use class (Show a ) => Show' a ...
06:36:55 <Lemmih> zenzike: Do you want to pretty-print the data type?
06:37:17 <Lemmih> zenzike: The Show type-class isn't used for pretty-printing. There are other type-classes for that.
06:37:40 <zenzike> Lemmih: well, it's for rendering to meaningful URLs
06:37:58 <zenzike> Lemmih: so you're absolutely right, I should create a new class
06:38:10 <Lemmih> zenzike: Generally speaking, 'show' should produce valid Haskell code.
06:38:49 <balor> If something is of type "Gen a" is there a quick way to show a?  I just want to see an intermediate value in ghci
06:39:09 <zenzike> Lemmih: cool, thanks very much.
06:40:43 <Lemmih> balor: 'sample'.
06:54:01 <develhevel> i can make some comands with system "..." but is it possdible to read the response from the console?
06:55:23 <balor> Lemmih, thanks
06:56:57 <Lemmih> develhevel: Yes, see System.Process
06:58:55 <develhevel> Lemmih: and which function makes it easyest/best?
07:00:17 <develhevel> Lemmih: got it :) thx
07:28:49 <Lemmih> ?ask Cale You play sc2? Do you have an EU account?
07:28:50 <lambdabot> Consider it noted.
07:50:07 <tg_> .
07:52:49 <balor> Should "{-# LANGUAGE TypeSynonymInstances #-}" in a .lhs file enable TypeSynonymInstances?  Or do I have to pass --ghc-option -X... into cabla?
07:53:28 <Saizan> you need "> {-# LANGUAGE TypeSynonymInstances #-}" at the top
07:53:44 <balor> ah
07:53:46 <balor> thaks
07:53:48 <balor> thanks
07:53:52 <balor> I was missing the >
08:06:27 <FUZxxl> @src forM
08:06:27 <lambdabot> forM = flip mapM
08:06:31 <FUZxxl> @src untilM
08:06:32 <lambdabot> Source not found. It can only be attributed to human error.
08:06:36 <FUZxxl> @srcmapM
08:06:37 <lambdabot> Unknown command, try @list
08:06:40 <FUZxxl> @src mapM
08:06:40 <lambdabot> mapM f as = sequence (map f as)
08:06:48 <FUZxxl> @src sequence
08:06:49 <lambdabot> sequence []     = return []
08:06:49 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:06:49 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
08:17:52 <Cale> Lemmih: nope, US
08:17:52 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
08:18:13 <Cale> Er, I should say NA, I live in Canada even :P
08:18:35 * pumpkin sends the elite kidnapping squad out to Canada to kidnap Cale
08:19:01 <Elbar> that's a typical cia job...
08:20:45 * Cale orders his sentries to forcefield the ramp while stalkers pick off the would-be kidnappers.
08:21:21 <pumpkin> the kidnapping squad is too elite for that
08:21:29 <pumpkin> it easily evades your sentries and stalkers
08:22:19 <Elbar> medivacs! ;)
08:22:29 <Cale> lol
08:38:00 <rovar> I need some help reconsiling monads
08:38:02 <rovar> http://hpaste.org/46897/monad_fun
08:38:15 <rovar> https://github.com/rrichardson/persistent/blob/master/backends/mongoDB/Database/Persist/MongoDB.hs
08:38:17 <c1de0x> perhaps you mean reconciling?
08:38:27 <rovar> c1de0x: you are correct
08:38:47 <rovar> i apparently need some help reconciling spelling of words as well.
08:38:55 <rovar> but we'll deal with that later
08:39:30 <c1de0x> well my work here is done. i'm off
08:40:18 <rovar> in the second link, line 37  is a function which runs in the Network.Abstract.IO monad.  I need it to run in the Control.Monad.IO.Control monad
08:43:46 <rothwell> bleh... still no quickcheck outside of IO
08:47:35 <Cale> rovar: It says that it works in any monad(?) which is an instance of the NetworkIO class.
08:51:42 <Cale> rovar: At least according to the Haddock, IO is an instance of that class, and there's a more general instance that looks like it might apply to some other monads.
08:52:09 <shapr> rothwell: Have you gotten QuickCheckM to work?
08:52:23 <Cale> rovar: still here?
08:52:32 <rovar> Cale.. yea.. sorry..on the phone with Verizon :/
08:52:58 <rothwell> shapr: not heard of it
08:53:26 <rothwell> shapr: mainly just want to get the results and do it outside of IO, as opposed to having them printed on stdout
08:54:01 <mercury^> rovar: did you have to explain that 0.03 cents is not the same as 0.03 dollars?
08:54:18 <rovar> mercury^: if only it were that easy..
08:54:31 <mercury^> That's not easy with verizon.
08:54:32 <Cale> rothwell: You can get the results in a Haskell value, but I think you still need to run an IO action to do it, for the random generation.
08:55:53 <mercury^> http://verizonmath.blogspot.com/2007/08/original-recording-of-verizon-customer.html
08:56:07 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.1.1/doc/html/Test-QuickCheck-Test.html#t:Result
08:57:07 * rothwell eyes
08:57:42 <rothwell> Cale: it still seems to insist on printing to stdout, according to the docs
08:57:56 <Cale> quickCheckWith (stdArgs { chatty = False })
08:58:15 <rothwell> Cale: ah! missed that
09:54:05 <parcs> is it possible to export a qualified module under a different name?
09:54:40 <mauke> you can't export modules, only identifiers
09:54:44 <parcs> `module X (module T) where import qualified Data.Text as T (pack)` causes ghc to complain that the module T exports nothing
09:55:44 <parcs> or rather, "the export item `module T` exports nothing"
09:55:52 <parcs> mauke: i don't follow. what's the difference?
09:55:59 <siracusa> parcs: module T (..) perhaps?
09:56:18 <parcs> siracusa: parse error ;)
09:57:31 <acowley> parcs: do you want to export qualified identifiers or just refer to a module that you imported qualified?
09:57:34 <erus`> any gcc whizz in here?
09:58:46 <parcs> acowley: i'd like to export a qualified identifier
10:00:41 <acowley> parcs: I don't think you can export an identifier with a qualifier you picked prepended to the name
10:02:21 <acowley> parcs: you want something like Racket's (provide (prefix-out ...))
10:02:25 <parcs> okay, i can live without that
10:03:35 <parcs> that's quite a strange warning that ghc outputs, though
10:04:00 <parcs> sounds almost like a bug
10:04:46 <acowley> parcs: it's as if you had "import Data.Text ()"
10:05:00 <acowley> and you exported it, "module Foo (module Data.Text) where"
10:06:11 <acowley> I think the issue is that module T doesn't export any unqualified identifiers, and it is only the unqualified identifiers that the module export will pass through
10:06:30 <parcs> i see..
10:32:11 <empity> /
10:41:33 <absence> is a >>= b the same as b =<< a?
10:41:39 <monochrom> yes
10:41:40 <tromp_> yep
10:42:37 <absence> thanks
10:54:13 <adorablepuppy> Is it possible to pass a function as an argument, but not have the parameters filled in? I want to inject a function into another, but have it use variables from the scope of the function it's being injected into.
10:54:31 <adorablepuppy> arguments*
10:54:48 <ski> Haskell uses lexical scope
10:55:09 <ski> if you want dynamic scope, try using implicit parameters
10:56:42 <adorablepuppy> a point free function?
10:57:14 <acowley> or a monad!
10:58:03 <ski> GHC User's Guide - 7.8.3 Implicit parameters <http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters>
10:58:06 <ski> adorablepuppy ^
11:01:05 <ski> (your function would have type something like `((?catchMe :: Foo) => Bar) -> Baz')
11:22:33 <saiko-chriskun> is there a way to rewrite: do value <- stuff; return MyType value -- with <<=?
11:22:41 <saiko-chriskun> er =<<
11:23:10 <parcs> return . MyType =<< stuff
11:23:11 <ski> @undo do value <- stuff; return (MyType value)
11:23:11 <lambdabot> stuff >>= \ value -> return (MyType value)
11:23:15 <ski> @. pl undo do value <- stuff; return (MyType value)
11:23:16 <lambdabot> MyType `fmap` stuff
11:23:19 <ski> also
11:23:25 <ski>   MyType `liftM` stuff
11:23:56 <acowley> But using <$> is snazzier
11:23:57 <parcs> also liftA and <$> and (.)
11:24:36 * ski thinks `<$>' is ugly
11:26:18 * byorgey thinks `fmap` is uglier
11:26:54 <ski> `fmap' is not pretending to be pretty
11:27:21 <saiko-chriskun> hm stuff >>= return . MyType works but return . MyType =<< stuff errors out. aren't they equivalent?
11:27:28 <byorgey> hehe, touche =)
11:27:57 <ski> @type \foo bar -> return . foo =<< bar
11:27:58 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> m a1 -> m a
11:28:08 <byorgey> saiko-chriskun: they are.
11:28:27 <ski> saiko-chriskun : does your `stuff' use any operators (apart from inside brackets) ?
11:28:57 <saiko-chriskun> oh there's a $
11:28:59 <saiko-chriskun> hahah
11:29:01 <saiko-chriskun> that would mess it up
11:29:05 <ski> indeed
11:29:09 <saiko-chriskun> thankies :P
11:30:00 <ski> saiko-chriskun : anyway, i would probably use `liftM' or `fmap' instead of `(=<<)' (or `(>>=)'), there
11:30:35 <ski>   liftM MyType . blah $ \x -> do ...
11:30:44 <ski> or whatever you're doing
11:31:26 <saiko-chriskun> what's the advantage? sorry I'm pretty new to haskell :P. haven't really seen fmap or liftM before
11:32:05 <kmc> fmap is more general than liftM or (>>=)
11:32:11 <acowley> ski: `fmap` is just a touch too long. <$>'s aesthetic appeal comes from the relationship with $.
11:32:12 <kmc> it works on a wider variety of "container" types
11:32:21 <ski> `return . f =<< ...' screams of being simplified using `liftM' or `fmap' (or `(<$>)' or `(.)', if you're that kind of person)
11:32:50 <ski> acowley : i wouldn't mind `(<$)' or `($<)' or something like that
11:32:53 <kmc> :t (>>= return . f)
11:32:54 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Show a, SimpleReflect.FromExpr a1) => m a -> m a1
11:33:01 <kmc> :t (>>= return . ?f)
11:33:02 <lambdabot> forall (m :: * -> *) a a1. (Monad m, ?f::a -> a1) => m a -> m a1
11:33:11 <parcs> fmap should be renamed to .
11:33:22 <ski> kmc : as long as `Functor' is not a superclass of `Monad', i prefer to use `liftM' to `fmap' in polymorphic code
11:34:09 <ski> saiko-chriskun : maybe you could show us what your expression actually looks like, and we could look to see if there's any nicer way to write it ?
11:36:12 <saiko-chriskun> return . JObject =<< between (char '{') (char '}') (sepBy jPair (char ',' >> spaces))
11:36:14 <ski> (acowley : to clarify : to me, the use of `<' and `>' at the ends suggest a greater symmetry than the operation supports, which makes it misleading/confusing (to me))
11:37:44 <ski>   liftM JObject . between (char '{') (char '}') . sepBy jPair $ char ',' >> spaces
11:37:48 <ski> might be one way
11:37:49 <ion> return . foo =<< bar   →   foo <$> bar
11:38:45 <ion> In Parsec, i rarely use the Monad instance. The Functor and Applicative instances fit it very well.
11:39:02 <acowley> ski: I view it as a decorated $.
11:39:17 <absence> is it possible to write "function <$> action parameter" as "(black magic here) parameter"? i.e. composition of a pure function and an action (i think)
11:39:24 <saiko-chriskun> what do I have to import for <$>? google can't search symbols :P
11:39:31 <ion> Control.Applicative
11:39:33 <acowley> ski: the visual symmetry of $ about the vertical line is reading too much into the symbol
11:40:12 <ski> acowley : i'm only talking about the symmetry of `<' vs. `>'
11:40:46 <ion> All of <$>, <*>, <*, *>, <$ tend to be very useful with Parsec.
11:40:50 <ski> (i wouldn't object as much if `(<$>)' has the type `Applicative i => i (a -> b) -> (i a -> i b)')
11:41:26 <acowley> ski: that's <*>
11:41:37 <ski> i know. i dislike that symbol more :)
11:42:05 <ski> (*because* `*' is symmetric along a vertical line .. unlike `$')
11:42:31 <ion> A is symmetric along a vertical line.
11:42:50 <ski> absence : `action parameter :: m a' and `function :: a -> b' ?
11:43:12 * ski nods vaguely
11:43:43 <ion> (fmap f . action) parameter
11:44:28 <ion> @pl \x -> f <$> action x
11:44:29 <lambdabot> (f <$>) . action
11:44:56 <ion> @pl \x -> f `fmap` action x
11:44:56 <lambdabot> (f `fmap`) . action
11:45:28 <ski>   f .: action
11:45:37 <absence> i've tried that, but it says it can't match expected type a with actual type M a
11:46:00 <ski> what is the exact code you get that error for ?
11:46:03 <FUZxxl> :t let (.:) = fmap fmap fmap in f .: action
11:46:04 <lambdabot> Not in scope: `action'
11:46:06 <absence> that is, i tried (function <$> action), but that's about the same i guess
11:46:22 <FUZxxl> absence: nope.
11:46:37 <FUZxxl> :t <$>
11:46:37 <lambdabot> parse error on input `<$>'
11:46:42 <FUZxxl> :t fmap
11:46:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:46:49 <ski> @type Just .: System.IO.openFile
11:46:50 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> Maybe (IO GHC.IO.Handle.Types.Handle)
11:46:52 <FUZxxl> :t fmap fmap fmap -- equal to .:
11:46:53 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:47:08 <absence> FUZxxl: ah true, the error was only similar, not the same
11:47:15 <absence> i'll see if i can boil this down to a testcase
11:47:27 <FUZxxl> absence:
11:47:45 <FUZxxl> :t fmap
11:47:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:47:46 <FUZxxl> :t .
11:47:47 <lambdabot> parse error on input `.'
11:47:49 <ski> absence : try instead `(f <$>) . action' or `(f `fmap`) . action' as ion (via lambdabot) suggested
11:47:49 <FUZxxl> :i .
11:47:54 <FUZxxl> :t (.)
11:47:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:48:06 <ski> @type (.:)
11:48:07 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
11:48:11 <ion> Or fmap f . action as i (not via lambdabot) suggested :-)
11:48:55 * ski tries some cold milk
11:50:23 <absence> :t (reverse <$>) . getLine
11:50:23 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Char'
11:50:24 <lambdabot>       Expected type: IO [[a]]
11:50:24 <lambdabot>       Inferred type: IO String
11:50:41 <absence> that's sort of similar i guess, except getline doesn't take a parameter :P
11:51:16 <ski> @type (reverse <$>) . System.IO.openFile
11:51:16 <lambdabot>     Couldn't match expected type `[a]'
11:51:17 <lambdabot>            against inferred type `IO GHC.IO.Handle.Types.Handle'
11:51:17 <lambdabot>       Expected type: FilePath -> GHC.IO.IOMode.IOMode -> [a]
11:52:37 <ski> ah
11:53:01 <FUZxxl> ski: attention! In lambdabot, (.) == fmap
11:53:22 <ski> yes. i do know that
11:53:26 <ski> @type (reverse <$>) . readFile
11:53:26 <lambdabot> FilePath -> IO [Char]
11:53:42 * ski forgot that `openFile' was taking another `IOMode' argument ..
11:54:15 <ski> (FUZxxl : also, s/==/=/, `(==)' is not defined on functions)
11:55:53 <FUZxxl> ski: That was meant symbollicaly as intepreter is lambdabot -> forall a b. a . b == fmap a b
11:56:17 * ski still thinks it ought to have used `='
11:59:04 <kmc> how about ≡
11:59:09 * FUZxxl thinks, that a single = is meaning defined as
11:59:14 <FUZxxl> kmc: Good idea.
11:59:43 <ski> "defined as" is not a property of the equality sign used
12:00:00 <absence> hm.. i have ListTag :: [TagPayload] -> TagPayload and getListPayload :: Word8 -> Int32 -> D.Get [TagPayload]. if i try :t (ListTag <$>) . getListPayload, i get Couldn't match expected type `[TagPayload]' with actual type `D.Get [TagPayload]'
12:00:18 <FUZxxl> > let a ≡ b = all (map [1..] (\x -> a x = b x))
12:00:19 <lambdabot>   <no location info>: parse error on input `='
12:00:24 <acowley> ski is here to chew bubblegum and bikeshed symbols :)
12:00:26 <FUZxxl> >a ≡ b = all (map [1..] (\x -> a x = b x))
12:00:33 <FUZxxl> > let a ≡ b = all (map [1..] (\x -> a x = b x))
12:00:34 <lambdabot>   <no location info>: parse error on input `='
12:00:35 <ski> a definition of `x' is a logical formulae `Phi' with `x' as free variable such that `exists unique x. Phi' holds
12:00:47 <FUZxxl> okay...
12:00:48 <ski> `Phi' may or may not contain an equals sign
12:00:56 <ski> acowley : indeed :)
12:01:38 <mamalujo> ski: so, == should be =, and ≡, 'defined as' sounds closer to what is now = ?
12:02:02 <ski> `==' should be `==' and `=' should be `='
12:02:06 <absence> ski: why does the reverse readfile case work, but not what i'm attempting?
12:02:31 <mamalujo> hmh, ok :)
12:02:36 <ski> absence : `getListPayload' takes two arguments
12:02:56 <ski> absence : try `((ListTag <$>) .) . getListPayload'
12:03:24 <acowley> Embrace the darkside: ≅ ≡ ∼ ≃ ≈ ≍ ≐ ∝
12:03:25 <ski> or `(ListTag <$>) .: getListPayload' or `ListTag .::' if you're wanting to be more obscure
12:03:40 <ski> er, `ListTag .:: getListPayload', that should be
12:03:46 * acowley tastes the rainbow of equality
12:05:37 <absence> ski: the verbose one works, but those strange operators aren't in scope
12:05:51 <absence> they're kinda cute, where can i find them?
12:06:12 <jkr> I was playing around with a long-running process (genetic algo) that segfaults at seemingly random times with no further information given. Sometimes it's after 400-some-odd iterations, sometimes 800, sometimes more.
12:06:20 <ski> imo, considering that haskell equational clauses uses `=' to define operation, those definitions are obviously true as proposition -- so taking e.g. `not False = True', i can derive `True = not False' as well as `not (not False) = False' (and later `forall b. not (not b) = b')
12:06:22 <jkr> Any way I can get it to give me more info when it does that?
12:06:38 <jkr> (It uses cairo bindings, which might be the culprit.)
12:06:52 <ski> i don't really see that we are in need of a different symbol than `=' to talk about semantic equalities between (the values of) expressions
12:06:52 <jkr> on 7.0.3, but same thing happened on 6.12.x
12:07:29 <ski> absence : define `(.:) = (.) . (.)', and `(.::) = (.) . (.) . (.)',&c.
12:07:58 <ski> absence : for the last version `ListTag .:: getListPayload' you first need to hide the usual `(.)' and define `(.) = fmap', though
12:08:28 * Saizan doesn't know what to google for tries corresponding to functions with a coinductive domain
12:08:53 <acowley> Saizan: monadic search strategies perhaps
12:08:54 * ski is immediately reminded of bar induction
12:09:15 <acowley> Saizan: there's a nice paper on the relationship of various tree search strategies
12:09:23 <acowley> and sigfpe did an incremental search thing
12:09:31 <ski> Saizan : you want things like `(Nat -> A) -> B' e.g., yes ?
12:09:33 <absence> ski: hm, can't i just define (.:) = fmap . (.) instead of redefining (.)?
12:09:43 <ski> @type (.:)
12:09:43 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
12:10:01 <ski> @type let (.) = (Prelude..) in fmap . (.)
12:10:02 <lambdabot> forall (f :: * -> *) b c a. (Functor f) => (b -> c) -> f (a -> b) -> f (a -> c)
12:10:04 <Saizan> ski: yeah, Nu F -> B
12:10:06 <ski> @type let (.) = (Prelude..) in fmap . fmap
12:10:06 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:10:37 <ski> absence : so you need `(.:) = fmap . fmap' for the more general version then (maybe the simpler is enough in your case)
12:11:24 <Saizan> acowley: i don't see the relation with tree search strategies
12:11:29 <ski> Saizan : so, presumably the function/map should be constant for large enough inputs ?
12:11:45 <Saizan> ski: yeah
12:12:04 <acowley> Saizan: well there the idea is to only partially cover an infinite domain, which is what I imagine you would need for a trie over such a domain
12:12:08 <Saizan> ski: well, depends on what kind of type B is
12:12:24 <Saizan> ski: if B is coinductive as well it's more complicated
12:12:35 <ski> yeah, constant wrt each "single part" of `B'
12:13:37 <Saizan> acowley: ah, escardo's stuff
12:13:40 <ski> Saizan : i think reading on fans and bar induction could be relevant somehow, here ..
12:13:46 <ski> and escardo's stuff, yes
12:13:51 <ski> @where impossible
12:13:51 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
12:14:25 <ski> so, s/constant/continuous/
12:14:44 * ski tries to recall if it was also uniformly continuous, or just continuous
12:16:13 * ski learned recently that the connected-components functor is left adjoint to the discreteness functor
12:17:03 <rostayob> is there a way to nicely fail a Get monad?
12:17:54 <Saizan> ski: a reference for fans and bar induction you'd recommend?
12:19:05 <jmcarthur> do we have anything like Alternative but without empty?
12:19:05 <ski> hm, the only one i've read (and understood) much in is Anne Sjerp Troelstra's and Dirk van Dalen's "Constructivism in Mathematics - An Introduction - Volume I"
12:21:31 <ski> there's also a book called "Choice Sequences : A Chapter of Intuitionistic Mathematics" by Troelstra and a shorter work "Principles of intuitionism : Lectures presented at the summer conference on intuitionism and proof theory", which i've only skimmed a little
12:22:08 * Saizan will try the first
12:22:26 <Saizan> weird that it's "induction" though :)
12:22:39 <ski> Saizan : anyway, the things i think are relevant are the chapter/section in "Constructivism in Mathematics" about bar induction and continuity principles
12:23:22 <Saizan> yeah, this trie would be a way to reify the continuity of such functions, i'd think
12:23:55 <rostayob> @pl bla inp = parseFile inp bla
12:23:55 <lambdabot> bla = fix (flip parseFile)
12:26:19 <ski>      ((xs : Nat -> A) -> (n : Nat) -> P (take n xs) == True)
12:26:23 <ski>   -> ((xs : List A) -> P xs == True -> Q xs)
12:26:30 <ski>   -> ((xs : List A) -> ((x : A) -> Q (xs ++ Cons x Nil)) -> Q xs)
12:26:30 <ski>   -> Q Nil
12:26:37 <ski> Saizan : bar induction ^
12:26:40 <acowley> It's seems rather like the common usage of bisimulation to demonstrate finite equalities of any length you choose
12:27:25 <adorablepuppy> Thanks for the help earlier, anyone who responded
12:27:49 <eikke> is there any way to access runtime data (e.g. GC stats) in a GHC app?
12:28:09 <acowley> eikke: effectively no
12:28:54 <jmcarthur> in real time?
12:29:02 <jmcarthur> you can get it after the fact, of course
12:29:03 <acowley> eikke: I've read mention of how it could/should be implemented, but the necessary hooks into the runtime aren't there today
12:29:20 <eikke> jmcarthur: real time indeed
12:29:29 <jmcarthur> you can also print some stats to stderr for each gc
12:29:36 <jmcarthur> but you can't actually handle it yourself, afaik
12:29:38 <eikke> I'd love to have some (basic) functionality like what Java gives with JMX for long-running apps
12:29:55 <jmcarthur> that latter thing i mean in real time
12:30:11 <eikke> too bad :-)
12:30:13 <jmcarthur> +RTS -S
12:30:18 <jmcarthur> best we got :\
12:30:54 <jmcarthur> you could do something hacky like write that to a pipe and read it from within the program
12:30:54 <ski> Saizan : yeah, it's not really like induction, since the consequence is `Q Nil', for the empty list .. however if `Q xs' is defined as `(ys : Nat -> A) -> R (prepend xs ys)', then it can be used to prove something holds for all streams
12:31:08 <kmc> can't you just foreign import the relevant C global variables from the RTS?
12:31:12 * hackagebot jmacro 0.5 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.5 (GershomBazerman)
12:31:12 <eikke> jmcarthur: i figure, thanks for the hint
12:31:21 <acowley> kmc: I believe so, yes
12:32:08 <kmc> hack-o-rama
12:32:23 <eikke> interesting approach
12:32:31 <acowley> kmc: hence my original "effectively no" response :)
12:32:34 <kmc> ;)
12:34:42 <kakos> Is there any way to prevent a parameter to a method from being null and checked at compile time rather than runtime?
12:34:57 <kakos> Er
12:34:58 <kakos> Wrong channel!
12:35:03 <kakos> Ignore my question, Haskellers!
12:35:11 <c_wraith> kakos: yes, use haskell :)
12:35:18 <acowley> Right channel!
12:35:22 <kakos> c_wraith: Would if I could.  :(
12:35:24 <dylukes> kakos: What language?
12:35:30 <kakos> dylukes: Scala
12:35:33 <dylukes> Ah I see.
12:35:38 * dylukes supports Eiffel contracts.
12:36:02 <dylukes> Still runtime though...
12:36:19 <dylukes> I don't think in a non-pure setting you could really decidedly check that a parameter is never null.
12:36:45 * ski idly wonders whether there's an Eiffel system which supports higher-order code, and which assigns blame correctly
12:37:13 <ski> dylukes : why not ?
12:37:33 <dylukes> ski: Say you're reading from a socket,
12:37:38 <dylukes> and turning the number from the socket into a memory address
12:37:42 <kakos> It'd be awesome if there was a language that separated pure code from non-pure code so that your pure code could take advantage of the many benefits that comes from being pure.
12:37:43 <kakos> ;)
12:37:51 <dylukes> kakos: there are a few… I forget the names
12:38:04 <dylukes> theres no way to know for sure if you'll ever get 0x00 or not from that socket
12:38:06 <kakos> dylukes: No one probably uses them anyway.
12:38:09 <ski> dylukes : "non-pure" is not the same as "weakly typed"
12:38:46 <ski> .. oh, you meant like that
12:39:01 <jrk_> hi
12:39:01 <dylukes> Basically what I'm saying is,
12:39:10 <dylukes> you can only know/not know if a parameter will ever be/not be null,
12:39:18 <dylukes> if all possible cases are *within* the program
12:39:22 <jrk_> is the xscreensaver extension somewhere available as ffi?
12:39:25 <ski> you could still dynamically check that the address is not `0x00', and the in the appropriate branch, the type system would know that it wasn't null
12:39:27 <dylukes> the second you're dealing with randomness or external input,
12:39:29 <dylukes> you can't know.
12:39:49 <ski> you can know, if you validate input (once)
12:39:53 <dylukes> ski: That's true.
12:40:02 <acowley> dylukes: McBride's indexed monads deal just with this issue, too
12:40:15 <dylukes> ?
12:41:10 * ski idly wonders what "the xscreensaver extension" is
12:41:21 <ski> acowley : elaborate ?
12:41:24 <acowley> the issue that you must deal with what the outside world gives you, but within your own world you can rest on your types after satisfying the demands of arbitrary IO
12:42:04 <Zao> ski: The X11 protocol extension "XSCREENSAVER".
12:42:15 <Zao> ski: Assumedly some kind of binding exposing whatever fancypants constants there are.
12:42:23 <dylukes> acowley: Does it provide a way to not have to be in IO, but still be able to use IO?
12:42:30 <dylukes> via sufficient… uh, validation?
12:42:36 <acowley> Can I let Conor elaborate? http://personal.cis.strath.ac.uk/~conor/Kleisli.pdf
12:42:43 * ski suspects jrk_ wants to jump into the FFI documentation, making a binding to whatever library is appropriate
12:42:46 <jrk_> ski: http://linux.die.net/man/3/xscreensaverqueryinfo
12:42:50 <acowley> dylukes: I wouldn't think so
12:42:51 <jrk_> that stuff :)
12:43:01 <dylukes> brb
12:43:41 <jrk_> na, dontwannadothatffistuffmyself
12:44:55 <ski> mhm .. Hoare logic
12:46:08 <acowley> It's a nice mixture of static properties of dynamic state
12:47:08 <dylukes> It would be nice if it were possible to "mix" pure and non-pure code, via barrier of validation
12:47:31 <dylukes> that is, by imposing that all inputs are restricted/filtered into a finite set of types/values.
12:47:45 <acowley> we do mix pure and non-pure code all the time
12:47:52 <acowley> fmap and relatives
12:47:54 <dylukes> ?
12:48:36 <acowley> even IO heavy programs are (usually) mostly pure code that interacts with IO at the boundaries
12:48:47 <dylukes> mm.
12:49:33 <acowley> but there's always an uneasy part where you have something with a type like IO a and there are no restrictions
12:49:45 <ski> dylukes : i'm not sure what you mean by "all inputs are restricted/filtered into a finite set of types/values"
12:49:48 <acowley> so you try to pull out the type you want, and figure out what do if you end up sideways
12:49:56 <dylukes> Forget it...
12:49:59 <dylukes> (ski)
12:50:10 <acowley> it's the right idea though, dylukes
12:50:19 <dylukes> what's the right idea?
12:50:32 <acowley> you're establishing a finite domain for a dynamic process
12:50:40 <dylukes> Right.
12:50:50 <dylukes> What comes to mind is, for instance
12:50:50 <dylukes> ,
12:50:55 * ski can't see what finite domains have to do with anything, here
12:50:56 <dylukes> the OEIS library.
12:51:07 <dylukes> While it actually does IO, its "pure"
12:51:26 <dylukes> since the lookup function is bijective I suppose.
12:51:30 <dylukes> Theres a finite domain.
12:52:12 <dylukes> It's referentially transparent despite using IO.
12:52:13 <dylukes> Fun~
12:52:14 <acowley> ski: in the McBride paper, he has the simple model that a handle is either Open or Closed
12:53:23 <ski> acowley : .. and ?
12:53:28 <acowley> which is arguably preferable to something that just might throw an exception
12:54:37 <ski> it seems to be that an impure program could easily manipulate finite domains; and correspondingly a pure program could easily manipulate infinite domains
12:54:43 <ski> s/to be/to me/
12:55:17 <ski> in short : i'm failing to see what ensuring things are finite has to do with ensuring purity
12:55:45 <ahnfelt> I was wondering, is there a version of mergeIO that takes a list of IO a instead of a list of a?
12:56:02 <ahnfelt> mergeIO' :: [IO a] -> IO [a]
12:56:02 <acowley> I don't know that it has anything to do with purity, and don't think I said it did. The point is to reify dynamic state as data.
12:56:05 <elliott> Is there any way to say "specialise /any/ function involving this type class in these two ways"? :-)
12:56:10 <elliott> ahnfelt: sequence?
12:56:11 <jmcarthur> ahnfelt: sequence
12:56:14 <ahnfelt> Actually, it's more like sequence
12:56:14 <elliott> :t sequence
12:56:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:56:26 <acowley> and in that way, provide a kind of exhaustiveness
12:56:42 <ahnfelt> thanks, but I haven't gotten to the point yet, sorry :)
12:56:55 <ahnfelt> that runs in parallel?
12:57:20 <ahnfelt> sequence, but that forkIO's and waits for all the threads to finish
12:57:24 <ski> ahnfelt : try composing with `mapM unsafeInterleaveIO' ?
12:57:37 <jmcarthur> that won't be enough
12:57:39 <elliott> ski: eek
12:58:13 <ski> elliott : `unsafeInterleaveIO' isn't really unsafe, in the sense of `unsafePerformIO', nor in the sense of `unsafeCoerce'
12:58:14 <ahnfelt> ski: I'd rather not use unsafe*
12:58:17 <dylukes> Is there a version of sequence that returns futures?
12:58:20 <jmcarthur> ahnfelt: i like some of the concurrent dsls for stuff like this. orc, for example, but there are others too. i don't know them very well
12:58:38 <rostayob> @pl  diffTime t1 t2 = fi ((fst . unTime) t1 - (fst . unTime) t2)
12:58:39 <lambdabot> diffTime = (fi .) . (. (fst . unTime)) . (-) . fst . unTime
12:58:40 <ski> elliott : `unsafeInterleaveIO' can be seen as comparable to the other concurrency operations (`fork', &c.)
12:58:42 <rostayob> i love pl
12:58:51 <elliott> skaar: but scarier :)
12:58:57 <ahnfelt> ski: I'm looking it up
12:59:05 <elliott> It's still freaky in that you can implement getContents with it
12:59:10 <ski> dylukes : see what i told ahnfelt,elliott above
12:59:33 <jmcarthur> it's not going to give you task parallelism though
13:00:05 <ski> @type mapM System.IO.Unsafe.unsafeInterleaveIO
13:00:06 <lambdabot> forall b. [IO b] -> IO [b]
13:00:16 <jmcarthur> just lazy IO (each action is not evaluated until you force its result)
13:00:53 <jmcarthur> it is a kind of concurrency though
13:01:29 <ahnfelt> Specifically, what I am trying to do is to run a bunch of STM monads concurrently. They all return ().
13:01:39 <ahnfelt> So I guess it's more like sequence'
13:01:56 <jmcarthur> oh, so you don't need the results
13:01:59 <jmcarthur> this is much easier then
13:02:04 <ahnfelt> oh
13:02:12 <jmcarthur> mapM_ (forkIO . atomically)  -- something like this
13:02:27 <jmcarthur> assuming each element is an STM thingy
13:02:47 <ski> @type foldM (\() -> id) ()
13:02:48 <lambdabot> forall (m :: * -> *). (Monad m) => [m ()] -> m ()
13:02:50 <jmcarthur> :t mapM_
13:02:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:03:21 <hpc> :t forM_
13:03:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
13:03:26 <ahnfelt> Thanks, but in addition (last alteration, promise) I need to wait for them all
13:03:32 <jmcarthur> forM_--
13:03:34 <ahnfelt> (to finish)
13:04:07 <ski> @type foldM (\() -> System.IO.Unsafe.unsafeInterleaveIO) ()
13:04:08 <lambdabot> [IO ()] -> IO ()
13:04:17 <ski> hum
13:04:35 <c_wraith> is there waitForTID?
13:04:41 <c_wraith> @hoogle waitForTID
13:04:42 <lambdabot> No results found
13:04:47 <ahnfelt> That is the type I'm looking for :) but not the semantics I'm afraid (it's a noop)
13:05:02 <ahnfelt> no waitForTID
13:05:14 <ahnfelt> I could use MVars or something
13:05:28 <ski> hm, if you want to spawn these concurrently, then you want `fork' or something like that, not `unsafeInterleaveIO'
13:05:55 <ahnfelt> but actually I was mostly wondering if somebody had solved my problem and released a package that I could depend on :)
13:06:52 <jmcarthur> ahnfelt: i would look at some of the concurrency dsls as i mentioned earlier
13:06:54 <elliottcable> God damnit.
13:06:57 <jmcarthur> orc, chp, others...
13:07:05 <c_wraith> well, MVar isn't what you'd want, QSemN is
13:08:13 <ahnfelt> jmcarthur: looking at orc as we speak
13:08:26 <ahnfelt> c_wraith: thanks, I'll look into that
13:08:58 <ahnfelt> chp is overkill for my problem - it's the only piece of concurrency I need
13:09:09 <jmcarthur> rolling this yourself wouldn't be too hard though i think
13:09:24 <acowley> :t \xs -> do {items <- zip <$> replicateM 10 (newQSem 0) <*> xs; mapM_ (forkIO . snd) items; mapM_ (waitQSem . fst) items}
13:09:25 <lambdabot> Not in scope: `newQSem'
13:09:25 <lambdabot> Not in scope: `forkIO'
13:09:25 <lambdabot> Not in scope: `waitQSem'
13:09:28 <ahnfelt> jmcarthur: true, I think I'll do that
13:09:28 <acowley> bleh
13:09:36 <acowley> something like that
13:09:48 <acowley> but the sem needs signalling
13:09:49 <jmcarthur> intialize a TVar with the number of transactions you intend to run, have each thread decrement that TVar's value before exiting, block on it until it reach zero
13:09:58 <acowley> rather than just the forkIO
13:10:08 <jmcarthur> i'm never actually used QSem
13:10:11 <ahnfelt> Just wanted to be sure I wasn't building a wheel I could just get from the shelves :)
13:10:11 <jmcarthur> *i've
13:10:14 <elliott> re-asking since no response: Is there any way to say "specialise /any/ function involving this type class in these two ways"? :-) (I doubt it...)
13:10:18 <elliott> even if it was just "in this module"
13:10:22 <c_wraith> QSem and QSemN are just MVar-structures.
13:10:29 <c_wraith> They just happen to be built for you already
13:10:29 <jmcarthur> elliott: what type?
13:10:39 <jmcarthur> *type class
13:10:45 <jmcarthur> err
13:10:49 <elliott> jmcarthur: (MyTypeClass m) => ... -> m a
13:10:53 <elliott> including (MyTypeClass m) => m a
13:10:54 <jmcarthur> i just don't understand the question at all i think
13:10:57 <acowley> ahnfelt: a variation of what I pasted should do what you need, so it's not a lot of code
13:11:05 <elliott> jmcarthur: Basically, I have a module with a bunch of functions with a typeclass
13:11:15 <elliott> jmcarthur: And I want to specialise every single one of them on two instances of that typeclass
13:11:22 <elliott> Which would be an awful lot of clutter
13:11:26 <ahnfelt> acowley: thank you
13:11:33 <elliott> I'm wondering if there's some way to avoid a pragma for every single one
13:11:35 <elliott> well, two pragmas
13:12:07 <jmcarthur> maybe you could specialize the type class and then build the module with -fexpose-all-unfoldings so that everything gets inlined?
13:12:21 <jmcarthur> *the instances
13:12:22 <elliott> you can specialise a type class? what does that mean?
13:12:34 <jmcarthur> {-# SPECIALIZE instance Foo Int #-}
13:12:40 <pumpkin> spit out code that doesn't refer to function pointers from a typeclass dictionary
13:12:56 <elliott> jmcarthur: hmm
13:13:04 <elliott> jmcarthur: I note that the typeclass includes no member values though
13:13:07 <elliott> It's just a package of a few constraints
13:13:16 <elliott> class (Functor m, Applicative m, MonadState FungeState m, MonadIO m) => MonadShiro m
13:13:18 <jmcarthur> ah then you would need to specialize the constraints
13:13:28 <elliott> hmm
13:13:42 <jmcarthur> actually, i think i misunderstood your question earlier. if you do this that would be enough i think
13:13:47 <elliott> won't need to specialise for functor and applicative, I think
13:13:50 <elliott> just monadstate and monadio
13:13:56 <jmcarthur> specialize pragma all the constraint instances, i mean
13:14:06 <elliott> So can that instance specialisation be in another module to the one with all my functions?
13:14:17 <throoze> hi
13:14:21 <jmcarthur> the pragma must be a part of the instance, i think
13:14:26 <elliott> mm
13:14:30 <elliott> instance MonadShiro blah where
13:14:34 <elliott>   ...pragmas...
13:14:34 <elliott> ?
13:14:39 <jmcarthur> yes
13:14:43 <jmcarthur> well
13:14:44 <jmcarthur> no
13:14:45 <elliott> OK, I'll give that a try; thanks
13:14:59 <elliott> jmcarthur: hmm?
13:15:02 <jmcarthur> it would be instance MonadState blah where; ...pragmas
13:15:06 <jmcarthur> and the same for MonadIO
13:15:18 <jmcarthur> since those are the ones you need specialized
13:15:25 <throoze> just starting with haskell... was trying the irc channel... Good to know where to come when get stucked =)
13:15:28 <throoze> bye
13:15:29 <elliott> jmcarthur: except that in both cases, they are not my own instances
13:15:33 <elliott> StateT has its own MonadState instance :)
13:15:45 <elliott> it's (StateT FungeState IO) and (MaybeT (StateT FungeState IO))
13:15:55 <jmcarthur> elliott: well... i dunno, maybe it would be enough to just do the MonadShiro instance. i don't know
13:16:02 <elliott> OK, I'll give it a try
13:16:32 <jmcarthur> in any case, heavy inlining might work if all else fails
13:16:54 <elliott> jmcarthur: already tried that :)
13:17:07 <jmcarthur> the SPECIALIZE pragma is quite magical though, in my experience :)
13:17:09 <elliott> yeah, no, the specialising of the empty instances doesn't seem to help at all, even with that flag :(
13:17:26 <jmcarthur> yeah don't worry about the unfoldings stuff
13:17:32 <jmcarthur> hmm
13:17:40 <elliott> I'll try specialising the instances I didn't write, just in case that works :P
13:17:57 <jmcarthur> maybe you could make a newtype wrapper so you can define your own MonadState and MonadIO instances and then specialize on that?
13:18:05 <elliott> yeah, I'm considering it
13:18:48 <elliott> hmm, a lot of those
13:18:49 <elliott> SpecConstr
13:18:50 <elliott>     Function `$w$j{v sqQl} [lid]'
13:18:50 <elliott>       has two call patterns, but the limit is 1
13:18:50 <elliott> things
13:18:54 <elliott> I guess I should increase the limit
13:18:55 <jmcarthur> those aren't a problem
13:18:59 <elliott> well, OK
13:19:04 <elliott> adding these declarations seems to have multiplied them though
13:19:08 <jmcarthur> yeah
13:20:03 <acowley> ahnfelt: here's a simpler version: \xs -> do {q <- newQSemN 0; mapM_ (forkIO . (>> signalQSemN q 1)) xs; waitQSemN q (length xs)}
13:20:15 <elliott> jmcarthur: doesn't seem to be helping :(
13:20:28 <elliott> I used to not have this typeclass, and all the functions were just directly on my main monad
13:20:43 <elliott> but then I added it so I could use (MaybeT Shiro) without a bunch of lifting to solve some heavily right-leaning indentation problems
13:20:50 <elliott> and it's almost doubled my runtime :(
13:21:09 <jmcarthur> yeah, transformer stacks can do that
13:21:11 <acowley> I thought you could only specialize a function defined in another module if it was inline/inlinable so it's body is in the interface file?
13:21:19 <jmcarthur> acowley: right
13:21:23 <elliott> jmcarthur: I don't even use the MaybeT version that much, though
13:21:38 <elliott> I think it's just the fact that everything is parameterised on the typeclass now
13:23:37 <ahnfelt> acowley: thank you. I'm using a slightly different version, but pointing out QSemN was very helpful
13:24:46 <ahnfelt> (well, mine is specialized to my use case)
13:44:58 <mrsolo> so i am starting to look into haskell web framework
13:45:08 <mrsolo> which one though?
13:45:16 <tommd> dons: I'm here now.
13:45:50 <pumpkin> mrsolo: most of the noise these days is about snap or yesod
13:46:10 <jmcarthur> happstack is still kicking too though
13:46:14 <mrsolo> snap or yesod
13:46:16 <mrsolo> hmm
13:46:21 <mrsolo> no winner yet eh?
13:46:32 * hackagebot diagrams 0.3 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-0.3 (BrentYorgey)
13:46:35 <jmcarthur> i haven't been convinced of the yesod way yet
13:46:58 <mrsolo> damn i hate to pick camp
13:47:00 <jmcarthur> it's very DSLy (in the syntax sugar way)
13:47:01 <mrsolo> i always pick wrong
13:47:28 <byorgey> even when you take into account the fact that you always pick wrong?
13:47:55 <mrsolo> ya have to make a call
13:48:07 <elliott> Time to ask an oxymoronic question: What's a safe type to unsafeCoerce things into?
13:48:10 <mrsolo> people are happy with the result but the pain! the pain!
13:48:13 <elliott> I don't want to depend on Any since it's GHC-only.
13:48:24 <jmcarthur> elliott: newtype wrappers?
13:48:37 <jmcarthur> :P
13:48:40 <elliott> jmcarthur: right, but of what? I need to store "anything" in it (think Data.Dynamic)
13:49:00 <mrsolo> okay so yespod, snap and happstack...
13:49:04 * mrsolo starts reading
13:49:15 <c_wraith> elliott: Any is the only type guaranteed to allow that.
13:49:23 <elliott> c_wraith: bah :)
13:49:49 <pumpkin> elliott: just use dynamic?
13:50:07 <elliott> pumpkin: I might, but I'd prefer to avoid the runtime baggage
13:50:23 <jmcarthur> hmm... maybe you could do   data Any = forall a. Any a, and then instead of unsafeCoercing to Any you just wrap it in the constructor. then when you want the value back you unwrap it and use unsafeCoerce
13:50:33 <jmcarthur> err
13:50:36 <jmcarthur> that might not be allowed
13:51:02 <elliott> yeah no
13:51:27 <jmcarthur> i think the type checker would want a concerte type for it even though it's just getting passed to unsafeCoerce
13:51:31 <jmcarthur> *concrete
13:51:53 <c_wraith> That's ok.  Tell it the type is ()
13:51:55 <c_wraith> doesn't matter
13:52:00 <jmcarthur> c_wraith: that wouldn't work
13:52:09 <jmcarthur> the type annotation itself would be an error
13:52:19 <c_wraith> oh, rigid type variable
13:52:25 <jmcarthur> actually, it might be allowed as long as you don't use a type annotation
13:52:41 <jmcarthur> maybe i should just test it, since i'm curious now anyway
13:54:12 <jmcarthur> ah yeah, this appears to be allowed by the type checker
13:54:14 <absence> is there something similar to liftM2 that doesn't lift, so that the first parameter can be an action instead of a pure function?
13:54:40 <jmcarthur> :t ap
13:54:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:54:43 <pumpkin> just use join after it
13:54:44 <jmcarthur> :t (<*>)
13:54:45 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:54:48 <c_wraith> absence: ap a couple times
13:54:52 <pumpkin> (a -> b -> m c) -> m a -> m b -> mc ?
13:54:59 <pumpkin> that's what I got out of his question
13:55:10 <jmcarthur> i read "first parameter can be an action" as literal
13:55:21 <pumpkin> maybe
13:55:23 <jmcarthur> s/as literal/literally/
13:55:25 <c_wraith> Oh, jmcarthur and I just read it as m (a -> b -> c) -> m a -> m b -> m c
13:55:35 <byorgey> absence: what type would you like? =)
13:55:52 <jmcarthur> elliott: what i suggested above seems to work and i think should be safe to do
13:56:21 <absence> well, liftM2 function monad1 monad2 is the regular one. i'd like liftM2' monad3 monad1 monad2
13:56:31 <pumpkin> give a type for it
13:56:37 <jmcarthur> what is the type of monad3?
13:56:41 <byorgey> so the type that c_wraith said?
13:56:49 <byorgey> m (a -> b -> c) -> m a -> m b -> m c  ?
13:56:50 <c_wraith> jmcarthur: though that depends on existential types, which is probably as non-portable as just using Any
13:56:54 <absence> i'm not too comfy with the type syntax yet, gimme a sec
13:57:09 <jmcarthur> c_wraith: i don't think ghc is the only one that supports it
13:58:01 <byorgey> absence: if that's what you want you can do  monad3 `ap` monad1 `ap` monad2
13:58:16 <byorgey> `ap` does function application "in a monadic context"
13:58:37 <absence> ok, regular liftM2 is (a1 -> a2 -> r) -> m a1 -> m a2 -> m r. i THINK i want (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
13:58:46 <pumpkin> then what I said
13:58:53 <pumpkin> just use join afterwards
13:58:54 <pumpkin> :t join
13:58:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:59:11 <absence> ap is the same as <*>?
13:59:14 <pumpkin> yeah
13:59:26 <byorgey> absence: yes, for types which are instances of both Monad and Applicative
13:59:28 <ion> Does base contain a type like MonadPlus or Alternative that doesn’t require one to define the equivalent of mzero or empty? I have a list of (Either a b)s and i want to pick the first successful one. I currently have foldl1 fallback list where { Left _ `fallback` e = e; e@(Right _) `fallback` _ = e }. Can i substitute fallback with something in base?
13:59:54 <c_wraith> ion: not in base.  there's semigroup stuff in edwardk's packages, of course.
13:59:57 <absence> so.. join $ monad3 <*> monad1 <*> monad2
14:00:02 <jmcarthur> ion: ha i was just asking about that earlier
14:00:04 <ion> c_wraith: Thanks, i’ll take a look.
14:00:10 <jmcarthur> c_wraith: semigroup doesn't have anything for that
14:00:19 <c_wraith> absence: actually, join $ liftM2 monad3 monad1 monad2
14:00:31 <jmcarthur> what absence is asking about... i wish was in bsae
14:00:33 <jmcarthur> *base
14:00:39 <jmcarthur> bind2, bind3, bind4, etc.
14:00:54 <c_wraith> jmcarthur: oh, I thought it was semigroup.  bah.
14:01:06 <jmcarthur> c_wraith: nah Semigroup is like Monoid
14:01:12 <jmcarthur> so wrong kind
14:01:17 <c_wraith> Oh, yeah, kind error
14:01:27 <byorgey> jmcarthur: yes it does
14:01:29 <c_wraith> semi-alternative! :)
14:01:34 <byorgey> ion: see http://hackage.haskell.org/packages/archive/semigroupoids/1.2.2/doc/html/Data-Functor-Alt.html
14:01:45 <ion> Thanks!
14:01:46 <jmcarthur> ah semigroup*oids*
14:01:55 <c_wraith> yeah, I was looking in the wrong place :)
14:02:23 <byorgey> yeah, the "semigroups" package is just the tip of a very large iceberg =)
14:03:28 <absence> yay, joi$ liftM2 works
14:03:29 <absence> thanks!
14:03:35 <absence> er
14:03:45 <absence> join $ liftM2
14:04:20 <c_wraith> absence: just to get a better feel of it, work through the types of that whole mess.  It's going to take a few tries, but if you do it, you'll learn a lot.
14:05:50 <absence> c_wraith: yep, i understood when i saw the type of join, as i've been ending up with m (m a) rather than m a, and didn't know what to make of it until now :)
14:06:13 <c_wraith> absence: ah.  Should have just asked us about that, then.  Or even hoogle.
14:06:22 <c_wraith> @hoogle m (m a) -> m a
14:06:22 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
14:06:22 <lambdabot> Prelude concat :: [[a]] -> [a]
14:06:22 <lambdabot> Data.List concat :: [[a]] -> [a]
14:06:50 <c_wraith> and yes, concat is just join specialized to lists :)
14:07:41 <absence> c_wraith: true, but i didn't think the solution was another function :) thought i had gone wrong and had to start over
14:08:51 <c_wraith> by the way, if you hadn't thought about it before, nesting type constructors can be interesting in other cases.  IO (IO Int) is a a useful type that's very distinct from IO Int
14:09:32 <osfameron> evening
14:09:42 <osfameron> are there Regex implementations that work on streams?
14:10:47 <absence> now that my expression compiles and works though, it looks horrible :D an interesting learning experience, but i guess it's back to "do" syntax for this one
14:11:48 <jmcarthur> hpaste it
14:11:54 <jmcarthur> let's see what #haskell thinks
14:12:17 <absence> join $ (((ListTag <$>) .) . getListPayload) <$> D.getWord8 <*> (fromIntegral <$> D.getWord32be)
14:13:27 <jmcarthur> hmm
14:13:36 <fragamus> how do i ask lambdabot what the type signature is for runStateT
14:13:40 <c_wraith> name a couple of those subexpressions, and a gets a lot nicer.
14:13:42 <jmcarthur> yeah that'd be a little nicer with bind2
14:13:48 <byorgey> @type runStateT
14:13:49 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:14:12 <absence> c_wraith: good idea
14:14:20 <jmcarthur> bind2 k a b = join $ liftM2 k a b  -- i think
14:14:26 <absence> jmcarthur: does bind2 exist, or was it something you wished for?
14:14:27 <fragamus> i love you lambdabot
14:14:30 <jmcarthur> it's a wish
14:15:21 <jmcarthur> bind2 ((fmap . fmap . fmap) ListTag getListPayload) D.getWord8 (fromIntegral <$> D.getWord32be)
14:16:07 <kms`> What is the recommended way to intsall haskell-platform-2011.2.0.1 on Ubuntu 11.04?
14:16:34 <absence> c_wraith: using "do" syntax parts of the expression get named "automatically". did you mean to use "where" instead? is there a generally preferred way?
14:17:26 <c_wraith> absence: yeah, I meant with a where clause.  Or even top-level bindings if you'll use them elsewhere.
14:18:07 <fragamus> @type runStateT
14:18:08 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:18:13 <acowley> One other very minor note is that fmap can be preferrable to <$> when partially applied
14:18:22 <fragamus> what does it mean ^^
14:18:26 <acowley> it usually saves you a pair of parens
14:19:17 <absence> jmcarthur: i liked the fmap stuff you did there. looks less like lisp ;)
14:19:26 <pumpkin> partially applied flip fmap ;)
14:19:30 <pumpkin> :t flip fmap [1]
14:19:31 <lambdabot> forall a b. (Num a) => (a -> b) -> [b]
14:19:53 <pumpkin> :t flip fmap [True]
14:19:54 <lambdabot> forall b. (Bool -> b) -> [b]
14:19:59 <pumpkin> zomg!
14:20:09 <c_wraith> it'd be cleaner using .:
14:20:13 <jmcarthur> fmap ListTag . bind2 getListPayload D.getWord8 $ fromIntegral <$> D.getWord32be      -- i think this is also equivalent
14:20:15 <byorgey> fragamus: first look at the part after the .
14:20:44 <byorgey> fragamus: it means you give it a (StateT s m a) computation and an initial state (s), and it "runs" it, producing an  m (a, s) computation
14:21:12 <byorgey> fragamus: the "forall s (m :: * -> *) a."  means it is polymorphic in s (the state type), m (the underlying monad), and a (the result type)
14:21:26 <byorgey> fragamus: the * -> * means that m is a type constructor which takes another type as an argument
14:22:41 <kms`> I have installed a ghc-7.0.3 binary, then configured (successfully) haskell-platform-2011.2.0.1. When I try to make it, I get told that "Cabal-1.10.1.0-1fb2094e19492373b1a39284193e7984 is unusable due to missing or recursive dependencies:
14:22:41 <kms`>       process-1.0.1.5-55dfaccf3a91c4cb8f6284a0bafef198". Any advice ?
14:22:47 <byorgey> fragamus: is that sufficient to answer your question? or is there still something you don't understand?
14:23:43 <scooty-puff> i'm having some trouble reasoning about laziness and recursion - specifically mfix - the question is a little involved, so won't post unless someone is interested
14:23:54 <absence> c_wraith: i'll toy with .: now that i understand a bit more of what's going on :)
14:23:57 <kms`> @type mfix
14:23:58 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:24:40 <rostayob> is there a way to nicely fail when using binary's Get instead of the default fail, which calls error?
14:24:44 <scooty-puff> basically making a dsl/assembler for java bytecode and an doing forward jumps via mfix
14:25:12 <acowley> rostayob: give your parser a Get (Maybe Foo) type?
14:25:38 <rostayob> acowley: the problem is that i do getBytes a lot of times, I'd have to test each time
14:25:56 <scooty-puff> (the forward jumps work just fine - for just about everything)
14:26:09 <c_wraith> > mfix $ \foo -> do { a <- "bar" ; return $ a : foo }
14:26:10 <lambdabot>   ["bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb...
14:26:26 <c_wraith> > length mfix $ \foo -> do { a <- "bar" ; return $ a : foo }
14:26:27 <lambdabot>   Couldn't match expected type `[a]'
14:26:27 <lambdabot>         against inferred type `(a1 -> m ...
14:26:32 <c_wraith> > length . mfix $ \foo -> do { a <- "bar" ; return $ a : foo }
14:26:34 <lambdabot>   3
14:26:53 <c_wraith> > map head . mfix $ \foo -> do { a <- "bar" ; return $ a : foo }
14:26:55 <lambdabot>   "bar"
14:27:08 <c_wraith> world's dummest id function for lists!
14:27:22 <scooty-puff> c_wraith, my usage is mfix (\end -> do ifeq end; ... end <- nop; return end)
14:27:24 <acowley> rostayob: if any step in the Get monad can fail, then there's not much you can do about that
14:27:40 <kms`> @info Get
14:27:40 <lambdabot> Get
14:27:41 <c_wraith> @type \x -> map head . mfix $ \foo -> do { a <- x ; return $ a : foo }
14:27:42 <lambdabot> forall a. [a] -> [a]
14:28:30 <parcs> holy crap, ghc's binaries are tiny when dynamically linked
14:28:57 <rostayob> acowley: ok, this sucks
14:29:07 <acowley> rostayob: got some code for us to look at?
14:29:14 <rostayob> i mean I could use catch, but that slows down things quite a bit
14:29:17 <acowley> rostayob: are you worried about performance or syntactic weight?
14:29:46 <rostayob> acowley: performance
14:30:59 <acowley> I think one can hope that using Maybe won't kill performance, but it really does depend on the details
14:31:15 <rostayob> acowley: http://hpaste.org/46901/binary
14:31:17 <b44> Is it possible to run Haskell-code with by WWW ?
14:31:41 <erus`> shud matrix multiplication a * b give different result than b * a?
14:31:48 <pumpkin> yes
14:31:53 <pumpkin> in most cases
14:31:58 <c_wraith> erus`: yes, matrix multiplication is non-commutative
14:32:08 <erus`> thank god
14:32:10 <b44> Is it possible to run Haskell-code with by www ?
14:32:14 <erus`> thought i was going mad
14:32:52 <c_wraith> unless one of the matrices is its own transpose, I believe.  Though it's been a while since I did linear algebra worth mentioning
14:33:19 <acowley> rostayob: is getTime the only part that can fail?
14:33:23 <kms`> b44: http://tryhaskell.org
14:33:30 <rostayob> acowley: well, all the getBytes can fail as well
14:33:34 <rostayob> and the skips
14:34:08 <mekeor> b44: yes it is possible. you can write (fast)cgi-programs.
14:34:47 <acowley> rostayob: what I would do is one check that you're getting enough bytes, then all the other parsing code gets lifted into Maybe that is driven by getTime
14:35:22 <acowley> rostayob: but I see that getBytes calls fail
14:35:57 <fragamus> is there any haskell training
14:36:27 <rostayob> acowley: if I check the length of the bytestring, i lose lazyness
14:36:33 <rostayob> of the bytestring
14:36:43 <rostayob> which is essential when working with huge files or streams
14:36:43 <acowley> rostayob: yeah
14:36:50 <rostayob> which is what i'm doing :P
14:37:08 <rostayob> cereal supports nice exceptions, but it's strict
14:37:08 <absence> jmcarthur: i can't figure out that last one that starts with fmap. could you add some parenthesis to show what are two parameters to fmap?
14:39:20 <rostayob> acowley: so there is no way :P?
14:39:24 <acowley> rostayob: what about using getLazyByteString, then checking its length?
14:39:25 <rostayob> it's quite sad
14:39:31 <rostayob> acowley: ?
14:39:33 <acowley> that way you'd just be forcing what you need if it's available
14:39:35 <rostayob> to check the length
14:39:39 <rostayob> you traverse the whole bytestring
14:40:23 <rostayob> or am i missing something
14:40:39 <acowley> so if I did: do { bs <- getLazyByteString 4; if BL.length bs < 4 return Nothing else Just (foo bs)}
14:40:44 <acowley> would that not be lazy enough?
14:41:03 <rostayob> oh, right.
14:41:33 <rostayob> so it wouldn't actually check the whole bytestring but just what is needed?
14:42:00 <rostayob> I mean would it stop once it knows that is >= 4?
14:42:22 <mauke> no
14:43:02 <rostayob> @src Data.ByteString.Lazy.length
14:43:02 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:43:11 <acowley> rostayob: That's the hope
14:43:32 <rostayob> acowley: mauke disagrees :(
14:44:32 <acowley> well splitAtST looks like it won't go beyond the chunk in which your desired buffer ends
14:44:37 * hackagebot timeplot 0.3.4 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.4 (EugeneKirpichov)
14:44:47 <acowley> I'm not sure exactly what mauke was disagreeing with
14:44:51 <rostayob> acowley: that would be enough i guess
14:44:59 <rostayob> length cs = foldlChunks (\n c -> n + fromIntegral (S.length c)) 0 cs
14:45:05 <rostayob> yeah I guess that would work
14:45:51 <acowley> I'm blanking on a small way to test this
14:46:18 <acowley> I guess we could build a lazy bytestring with an undefined chunk
14:46:20 <acowley> and see if we hit it
14:46:26 <rostayob> it says O(n/c),
14:46:35 <rostayob> if i knew what n and c are
14:46:39 <rostayob> but it's definitely not n
14:46:57 <rostayob> ehe
14:47:08 <rostayob> oh, c is the number of chunks
14:47:26 <rostayob> makes sense
14:49:03 <acowley> I'm writing a quick test
14:49:30 <rostayob> acowley: thanks a lot
14:49:48 <rostayob> i'm using a 5MB file now and I can't notice a difference, but I guess it's not enough
14:50:13 <acowley> I think it works
14:50:29 <acowley> ooh
14:50:31 <acowley> interestingly
14:50:39 <acowley> it goes one beyond what you ask for
14:50:43 <acowley> one byte that is
14:50:51 <acowley> I'll paste my little test so you can see
14:50:55 <rostayob> acowley: may i see the test code?
14:50:57 <rostayob> yeah (:
14:51:23 <acowley> http://hpaste.org/46902/lazy_bytes
14:51:32 <wabash> A question about "thunks": Are thunks a characteristic entity of lazy evaluation? Or do they exist in non-lazy languages?
14:51:32 <acowley> if you change the 4 to a 5 it blows up
14:51:43 <acowley> wabash: they exist everywhere
14:51:51 <acowley> it's just in Haskell they are more implicit
14:52:05 <wabash> What would an example of a thunk be in Java?
14:52:07 <acowley> in other languages you explicitly create functions with type () -> a
14:52:22 <wabash> ok
14:52:23 <acowley> int thunk() {return 3;}
14:52:26 <acowley> void args
14:52:30 <wabash> ok
14:52:54 <rostayob> acowley: thanks a lot
14:53:41 <acowley> rostayob: no problem! I'm sure I've done just this before so I was a bit surprised that I didn't have the answer ready when you first asked :P
14:53:45 <wabash> acowley: So, I can understand pretty well through analogy/ equivalent in other lang... Do you know Java?
14:53:45 <wabash> Wolud a thunk in Java be, for example, an anon inner class? Or is it more specific, like a functor object?
14:54:53 <acowley> wabash: If you wanted to have an anonymous function acting as a thunk, then you'd use an anon inner class
14:55:00 <rostayob> acowley: wait a sec. I'm not sure how your test tests the lazyness
14:55:18 <acowley> rostayob: if the whole input bytestring was forced, we'd hit undefined
14:55:33 <acowley> rostayob: load it in GHCi and try BL.length myData
14:55:40 <rostayob> acowley: oh oh, right, sorry
14:55:44 <rostayob> didn't see the undefined
14:55:46 <wabash> acowley: Ah, I see. Is there some idea of "caching values", i.e., once you evaluate a thunk, you don't have to re-evaluate it, the answer is stored (since it is stateless, for example)
14:55:53 <rostayob> thanks again
14:56:19 <acowley> wabash: in Haskell, yes. In other languages, you would typically use explicit mutation to memoize the result
14:56:34 <wabash> acowley: Right, Haskell specific. So the memoization is implicit?
14:57:30 <acowley> wabash: you might want to take a look at ezyang's recent blog posts
14:57:40 <rostayob> oh yes, those are really nice
14:57:46 <wabash> ok, sure.
14:57:48 <wabash> link?
14:57:52 <acowley> wabash: they take a rather unorthodox approach to explaining things, but maybe it will help
14:58:02 <wabash> oh, rigth.
14:58:06 <wabash> That's what got me started.
14:58:32 <wabash> But, acowley, your explanations are exactly what I'm looking for. A nice concept, concisely explained.
14:58:40 <acowley> I'm hesitant to offer glib answers because memoization in Haskell is rife with confusion
14:58:58 <acowley> it's not as though every application is forever tucked away somewhere
14:59:52 <wabash> acowley: No, I understand. I just need a nice starting point. Just like AIC in Java is full of ramafications, it's hard to encapsulate definitively what it's about. But the basic concept is simple, and a very good place to start.
14:59:52 <acowley> I find the graph reduction view most intuitive, as I'm happy to visualize a program as a tree whose nodes are expressions
15:00:09 <acowley> and those nodes are reduced when needed
15:00:47 <wabash> acowley: Thank you for your help
15:00:50 <acowley> well, one of these days you can tell me what AIC in Java is :)
15:01:00 <wabash> "Anonymous Inner Classes"
15:01:11 <acowley> ah
15:01:13 <wabash> You probably understand them easily, coming from strongly typed functional language.
15:01:29 <wabash> But try explaining to a nice corporate Java-trained type what they *really* are.
15:01:36 <ezyang> Except they don't really work the way you'd expect closures to.
15:01:39 <wabash> "Uh,.. magic bracket thingy for listeners???"
15:01:50 <wabash> ezyang: Not 100%, but fairly well.
15:02:00 <acowley> trying to get at what things *really* are is a dangerous hobby
15:02:07 <wabash> ezyang: Are you refering to the "final" requirement of referenced variables.
15:02:28 <ezyang> I really want to write a series talking about how to apply FP reasoning to architecture astronaut style stuff in Javaland.
15:02:39 <ezyang> wabash: Partially.
15:02:55 <wabash> ezyang: What's the other aspects you refer to?
15:03:02 <ezyang> but also, what happens when you exit certain scopes.
15:03:26 <t3nsor> lambdabot prints "Terminated" for me whenever I try to evaluate anything, does anyone know how to fix this?
15:03:32 <wabash> ezyang: Yes, of course.
15:04:15 <acowley> t3nsor: are you setting up a skynet joke?
15:04:45 <acowley> ezyang: is it worth it, though? (FP descriptions of Java techniques)
15:04:52 <wabash> ezyang Alls I'm saying is, coming to AIC/quasi-closures in Java *from* a Java point of view is almost impossible (because of blub principle, etc). Coming to them from a, say... Scheme point of view is very nice and trivial.
15:05:07 <ezyang> Yes. I think it can really clarify things.
15:05:16 <wabash> acowley: ezyang: I'd say yes and no. ..   Yes, because then you can make Java much better.
15:05:17 <acowley> wabash: maybe you could sneak some clojure in?
15:05:27 <ezyang> I've done this to some success with MVC, in my experience.
15:05:31 <wabash> No because the vast majority of Java's user base won't get it.
15:05:41 <wabash> Yes, because the 10% who do get it can use it quite well....
15:06:04 <acowley> ezyang: I just think it runs the risk of preaching to the choir
15:06:22 <ezyang> "I'll try doing it without telling anyone what I'm doing."
15:06:32 <acowley> ezyang: not to mention, an FPer writing Java (or whatever) can be a pretty awkward site, too
15:06:41 <t3nsor> acowley: actually it prints ["-E","-XBangPatterns","-XNoMonomorphismRestriction","-XViewPatterns","--no-imports","-l","/home/brianbi/.lambdabot/State/L.hs","--expression=1","+RTS","-N2","-RTS"] and then Terminated
15:06:43 <ezyang> Really, I need to find some software that actually reimplements some FP paradigm and doesn't realize it.
15:06:47 <acowley> I know I sometimes get too locked into an FP mindset then write terrible C
15:07:05 <wabash> Thanks, acowley, ezyang
15:07:13 <wabash> few words, great value to me.
15:07:22 <ezyang> Writing Perl in Java is also a pretty terrifying sight.
15:08:03 <wabash> Writing perl in anything but Ruby is terrifying!!
15:08:06 <acowley> I think there is genuine wisdom in language-specific lore, and folks casting stones often undervalue it so one must aim carefully
15:08:57 <acowley> like how we joke about perl, but then you see a perl hacker vomit up a log file parser in 7 characters
15:09:52 <ezyang> > 1 + 1
15:09:53 <lambdabot>   2
15:10:02 <ezyang> hmm, what happened to hackagebot.
15:10:24 <mreh> there's an embargo on all your libraries
15:10:45 <ezyang> No no, I saw hackage post to twitter, but I didn't see it in here...
15:11:41 * hackagebot timeplot 0.3.5 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.5 (EugeneKirpichov)
15:13:06 <mreh> must be a blockage, how strange
15:13:28 <mreh> gawd, parsec is a whole world on its own
15:13:38 <mreh> i feel overwhelmed
15:14:02 <c_wraith> most of parsec is helpers to make certain "common" cases easy
15:14:09 <c_wraith> The core of parsec is actually pretty small
15:14:22 <mreh> ive never seen it say unexpected XYZ *or* ABC
15:15:11 <mreh> c_wraith, yeah, i've looked inside alot of the comibators, because if you don't understand how sepBy works, it's useless more or less
15:15:17 <mreh> like I assumed it was predictive
15:15:20 <mreh> doh
15:15:44 <mreh> i mean backtracking
15:15:47 <mreh> tired
15:16:03 <c_wraith> still not a fan of parsec.  I prefer uu-parsinglib for, well..  backtracking.  I think it makes it easier to write simpler parsers.
15:16:27 <c_wraith> It also makes it easier to write really slow parsers, but that doesn't matter for most of my parsing needs.
15:17:27 <mreh> you mean, poor performance as the input grows slow, or just slow
15:18:02 <c_wraith> I mean it's easy to write an ambiguous parser with O(2^n) runtime, for some n
15:18:19 <c_wraith> It's also easy to avoid that.
15:18:54 <acowley> that's a lot of easy
15:19:05 <c_wraith> depends on what you're paying attention to.
15:19:14 <mreh> its obvious Parsec is aiming for performance
15:19:33 <c_wraith> I don't mind writing a grammar that's ambiguous and results in O(2^n) scaling when I don't expect n to exceed 5
15:19:46 <c_wraith> I also don't mind making it unambiguous when I expect n would be 100
15:20:28 <mreh> but uu-parsinglib isn't snazzy enough
15:20:38 <mreh> where's the glamour?
15:20:57 <c_wraith> here's something fun.  uu-parsinglib has error-correction built in.
15:21:09 <c_wraith> error-correction is pretty awesome.
15:21:15 <mreh> wow
15:21:21 <c_wraith> "What you entered didn't make sense.  I'll pretend you entered something that did"
15:21:22 <mreh> like darcs?
15:22:09 <mreh> darcs only works on the principle that it knows enough to guess what you meant without it being something else
15:22:11 <acowley> error correction is really impressive, but whenever I'm faced with a parsing need, I don't actually want error correction
15:22:52 <c_wraith> acowley: I imagine error correction would be really nice when writing some sort of interactive system
15:22:59 <acowley> I need to drink more kool aid
15:23:12 <acowley> c_wraith: yeah, that sounds plausible
15:23:37 <c_wraith> "what you provided wasn't right.  did you mean <X>?"
15:23:40 <mreh> or in a legacy environment, where programs were written poorly because the parsers were awful
15:23:42 * hackagebot bindings-DSL 1.0.11 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.11 (MauricioAntunes)
15:23:50 <acowley> c_wraith: I'm sure there are actually many times when it makes sense, but the idea of allowing bad input bothers the engineer in me
15:24:09 <ezyang> I mean, what's even worse is when they don't even manage to parse well-formed input correctly.
15:24:30 <c_wraith> acowley: it really depends on whether you're parsing your own internal data files, or input from users.  users like error messages like "did you mean ...?"
15:24:36 <acowley> I like my programs to SEGFAULT, or perhaps even lock the machine on bad input
15:24:39 <acowley> it's the only way to learn
15:24:48 <dmwit_> Have you tried roulette linux?
15:24:51 <c_wraith> If it's your own data files, then you don't want to tolerate errors.
15:25:06 <dmwit_> It's got the shells patched so that any error causes "rm -rf /" to run.
15:25:09 <acowley> I've heard of it, and it really scared me
15:25:31 <mauke> fortunately 'rm -rf /' doesn't do anything
15:25:38 <mreh> heh
15:25:39 <rostayob> wasn't it suicide linux?
15:25:42 <acowley> c_wraith: I'm sure it's a useful debugging feature even for your own files
15:26:09 <mreh> error correction? It'll just encourage them!
15:26:19 <acowley> maybe a variant where it ssh's into someone else's box and deletes all their files when you make a mistake
15:26:20 <jmcarthur> absence: it should be the same as   fmap ListTag (bind2 getListPayload D.getWord8 (fromIntegral <$> D.getWord32be))
15:26:24 <acowley> mreh: exactly!
15:26:45 <c_wraith> mreh: well, you can still reject input with errors in it, just using the error correction to point out where the error was, and suggest a fix.
15:27:00 <mreh> c_wraith: fair enough
15:27:04 <mreh> my shell does that :)
15:27:05 <c_wraith> It's *not* blind error correction.  it gives you a list of all the fixups it made
15:27:24 <mreh> so it carries on with the parse, that's nice
15:27:32 <mreh> it should still reject
15:27:33 <acowley> in all seriousness, I haven't had a parsing issue that wasn't quickly resolved just from having the parser show me the input it choked on
15:29:16 <c_wraith> well, as the user of the library, you're free to reject input that leads to a non-empty error list
15:29:44 <dankna> parsing with error correction is also useful if you want to parse noisy input
15:29:56 <dankna> for example, if you're writing a structure editor for a file that's /almost/ valid in some language
15:31:01 <acowley> that sounds like a dire situation from the outset
15:31:16 <dankna> well, if it's what you're doing, you kinda need it
15:37:33 <pumpkin> is there a fancy efficient way of multiplying matrices X * Y * X^T (where ^T is transpose)
15:37:34 <pumpkin> ?
15:38:48 <c_wraith> I'm sure I've seen that pattern
15:38:53 <c_wraith> It's quite possible there are some tricks
15:39:07 <pumpkin> I have too, and was hoping someone might know the tricks :)
15:40:01 <roconnor> @tell conal here you go: http://r6.ca/blog/20110520T220201Z.html
15:40:01 <lambdabot> Consider it noted.
15:42:25 <pumpkin> is there a page of matrix tips and tricks?
15:42:35 <pumpkin> like the thing saying that inverting a matrix is never necessary
15:54:48 <t3nsor> figured it out
16:01:41 <Eduard_Munteanu> pumpkin: well not specifically for that, but maybe you can diagonalize?
16:02:13 <pumpkin> ?
16:03:07 <Eduard_Munteanu> Make your matrices into diagonal form. (Not always possible.)
16:04:05 <Eduard_Munteanu> say http://en.wikipedia.org/wiki/Diagonalizable_matrix
16:05:06 <Eduard_Munteanu> Basically A * D where D is diagonal results in multiplying each whole column in A by the corresponding element in D.
16:08:36 <ezyang> It's very gratifying to discover that the state monad is actually the reader monad plus the product comonad.
16:09:35 <ezyang> And currying is adjunctions. Oh man!
16:10:18 <pumpkin> composition of adjoint functors!
16:10:42 <Eduard_Munteanu> Well you can kinda see currying earlier on in exponentials.
16:10:52 <Eduard_Munteanu> Though not really related I guess.
16:13:06 <aristid> ezyang: is there a systematic way to add comonad (transformers?) to monads?
16:13:15 <ezyang> I haven't investigated fully.
16:13:27 <ezyang> But I believe that monads would have to be decomposed.
16:13:38 <ezyang> None of this "opaque state monad data constructor" stuff.
16:13:41 <pumpkin> aristid: "add" ?
16:14:11 <aristid> pumpkin: if i knew the precise meaning, i wouldn't have asked that question.
16:14:21 <ezyang> Clearly someone should write the "adjunctions" library, which is like the "transformers" library but uses adjoints instead.
16:14:41 <pumpkin> my agda CT library will give you a monad out of an adjunction
16:14:58 <aristid> pumpkin: now in haskell please :P
16:15:04 <pumpkin> with the added benefit that it carries proofs that it satisfies the monad laws
16:15:09 <Eduard_Munteanu> BTW have you guys seen any classical matrix / linear algebra algorithms reinvented from a FP point of view?
16:15:41 <aristid> Eduard_Munteanu: no, but alternating sums can be expressed with foldr (-)!
16:15:55 <Eduard_Munteanu> (It's probably not terribly useful / fast considering how BLAS and that stuff is written)
16:15:55 <ezyang> Should be able to do an image processing library based on comonadic pixel arrays.
16:16:26 <Eduard_Munteanu> Yeah, image convolution is easy with comonads.
16:19:30 <Saizan> roconnor: what if we added a "| Fork Dialogue" constructor to Request? and so a constructor "| ForkIO (IO ()) (() -> IO a)" to IO?
16:19:46 <roconnor> Saizan: seems vaguely reasonable
16:20:10 <roconnor> Saizan: you need syncronization though too
16:20:28 <jmcarthur> pumpkin: so are you able to build your CT library within your resource constraints? :P
16:20:38 <pumpkin> sure
16:21:23 <Saizan> i guess ThreadId -> IO a would be more useful
16:21:24 <jmcarthur> trolling is no fun when you get a straight answer
16:21:31 <acowley> I guess this is a dumb question, but how is convolution particularly easy to express with a comonadic array?
16:22:10 <jmcarthur> acowley: each output value is easy to express as a function of the "nearby" input values
16:22:30 <jmcarthur> err... i don't know about convolution specifically actually
16:23:09 <roconnor> Saizan: I feel the free aproach is missing some structure, but I'm not sure what that is, or if my feeling is right.
16:30:42 <Saizan> roconnor: not sure what you're referring to, it's surely not modelling any of the consequences of earlier actions for later ones
16:31:42 <roconnor> Saizan: I think that when you send messages to other threads then the response in the other thread should depend on the message.
16:33:31 <Saizan> roconnor: i.e. that it should be apparent that if you putMVar m x in one thread takeMVar m should give you back x in the other?
16:33:32 <roconnor> but if you just and forked trees, then this coordination isn't captured in the type
16:33:39 <roconnor> yes
16:33:55 <Saizan> heh
16:34:08 <Saizan> even sequentially, how do you do that for IORef's ?
16:34:34 <roconnor> I'm hoping you can put something like a State transformer on top of this.
16:36:15 <Saizan> that probably doesn't work
16:36:28 <roconnor> really?
16:38:08 <Axman6> @hoogle Tree
16:38:08 <lambdabot> module Data.Graph.Inductive.Tree
16:38:08 <lambdabot> module Data.Tree
16:38:08 <lambdabot> Data.Tree data Tree a
16:38:14 <Axman6> @src Tree
16:38:14 <lambdabot> Source not found. Wrong!  You cheating scum!
16:38:32 <roconnor> Saizan: I was thinking of putting as HList in each node of the Dialogue2
16:38:39 <Saizan> not with something as simple as StateT Heap IO, last time we concluded forever (print x) == _|_ for IO = State World, so i'm guess we'd have similar problems
16:38:52 <Saizan> *guessing
16:39:18 <roconnor> Saizan: I think it might be okay in that the writer part of StateT Writer is still lazy ... I think
16:39:57 <roconnor> I should really work out some concrete semantics
16:40:05 <roconnor> fortunately I don't see IORefs in Haskell 1.2 :D
16:40:12 <Saizan> ah, true
16:42:59 <dolio> forever (lift $ print x) shouldn't be bottom for StateT s IO.
16:43:09 <dolio> Or else we're doing something wrong.
16:43:27 <Saizan> i guess so
16:44:14 <dolio> The IO in 's -> IO (s, a)' gives you the opportunity to be more interesting.
16:45:33 <Saizan> though i really like the idea of IO being just an AST, with no semantics attached :)
16:46:24 <dolio> forever (lift $ print x) = \s -> <infinite syntax tree>
16:46:54 <Saizan> yeah, but the state part is messing with the picture
16:48:20 <roconnor> main passes the empty heap in
16:48:32 <roconnor> or rather the RTS passes the empty heap into main
16:49:44 <roconnor> actually, by parametricy I bet the RTS could pass any heap into main and the results would be the same modulo (fmap const ())
16:49:50 <roconnor> (fmap (const ()))
16:50:12 <Saizan> yeah, should be
16:51:31 <Saizan> it's indeed easier than concurrency
16:51:46 <pumpkin> I'm taking bets
16:51:50 <roconnor> It would do me good to work it out though
16:51:55 <roconnor> IORefs
16:52:00 <pumpkin> is inverse ackermann of graham's number less than or greater than 50?
16:52:39 <roconnor> pumpkin: I'll say less than 50.
16:52:58 <Saizan> but the hardest part is not even communication between threads, it's access to resources shared with the environment, like the filesystem
16:53:02 <pumpkin> roconnor: noted
16:53:06 <pumpkin> not sure how I'll verify :)
16:53:40 <Saizan> pumpkin: make Agsy compute a proof?
16:53:44 <pumpkin> lol
16:53:49 <pumpkin> I'll get right on that
16:53:51 <roconnor> pumpkin: I'll just type it into Haskell..
16:54:53 * roconnor looks up graham's number
16:54:58 <dolio> http://hpaste.org/46903/statet_s_io
16:56:19 <roconnor> wow, the lowe bound is now 13
16:56:32 <roconnor> when I went to univeristy we all though the number was going to actually be 6
16:58:50 <geheimdienst> roconnor: the lower bound for graham's number is 13? amazing
16:59:11 <roconnor> the lower bound for the number tha graham's number is ment as an upper bound for
17:00:54 <roconnor> pumpkin: so apparently garahams number is g64 which is approximately equal to ackermann(g63)
17:01:00 <roconnor> pumpkin: and g63 is much larger than 50
17:01:01 <dolio> So the problem in question has really been narrowed down.
17:01:06 <pumpkin> roconnor: YOU LOSE
17:01:08 <roconnor> http://mathoverflow.net/questions/11934/magnitude-of-grahams-number
17:01:21 <pumpkin> roconnor: which means you owe me $g13
17:01:32 <roconnor> g64 is around A64(4)
17:01:39 <roconnor> g64 is around (A^64)(4)
17:02:00 <dolio> roconnor: Except none of these numbers are even real, right?
17:02:26 <pumpkin> wildberger wouldn't believe in them
17:02:29 <roconnor> dolio: I'm not sure
17:02:42 <ddarius> pumpkin: Sure he would.
17:02:44 <roconnor> dolio: certainly there are lots of numbers around these numbers that don't exist
17:02:51 <ddarius> What roconnor said.
17:02:56 <roconnor> ... not that that sentence makes any sense.
17:03:08 <pumpkin> ddarius: fair enough :)
17:03:23 <saiko-chriskun> can you change the search path for .hi files?
17:03:34 <dolio> It seems like if you don't believe in exponentiation, Graham's number would be hard to swallow.
17:06:26 <ddarius> dolio: Why wouldn't you believe in exponentiation?
17:06:49 <dolio> Because you're some ultrafinitist whose book roconnor is reading.
17:07:52 <roconnor> ddarius: you want to work in a language where the only provably total functions are poly-time
17:08:12 <roconnor> thus all your "programs" you "write" are necessarily "efficent"
17:08:29 <dolio> Hahaha.
17:09:07 <dons> yo
17:09:35 <shachaf> @yarr
17:09:35 <lambdabot> Where d' all t' pirates come from?
17:09:35 <lambdabot> Great Yarrmouth!
17:09:37 <blackdog> ya
17:09:43 <geheimdienst> coyo
17:10:16 <ddarius> roconnor: Write in multiplicative linear logic.
17:10:56 * blackdog just registered lambdamechanic.com
17:11:04 <blackdog> now i need to figure out something cool to do with it:)
17:11:11 <ddarius> Fix dysfunctional lambdas.
17:11:35 <dolio> Sell it to edwardk so he can add it to his domain squatting collection
17:11:48 <djahandarie> Haha he has one?
17:11:51 <shachaf> edwardk is a domain squatter?
17:11:53 <shachaf> It figures.
17:11:56 <djahandarie> Interesting investment
17:12:15 <dolio> He apparently lost quite a few years back. So it's more modest now.
17:13:02 <dolio> I can't really remember what he had, other than hi.fi
17:13:13 <dolio> Which is now disallowed by the country's rules.
17:14:44 <roconnor> ddarius: however you want to do you if you can prove exponetial total, then your provably total functions are not all polytime.
17:14:53 <roconnor> *to do it
17:15:53 <geheimdienst> edwar.dk seems to be available ...
17:16:21 <shachaf> geheimdienst: Squat it!
17:16:23 <acowley> isn't that cutting off huge swathes of mathematics?
17:16:27 <geheimdienst> :D
17:16:49 <ddarius> Huge swathes of mathematics are bollocks anyway.
17:16:58 <acowley> he'll just register coedwar.dk and be happy
17:17:21 <acowley> perhaps so, but exponentials loom particularly huge for me given my narrow world view!
17:19:19 <dolio> It's cutting off quite a few programs that people use, too.
17:19:27 <dolio> Like Hindley-Milner type inference.
17:20:10 <saiko-chriskun> would anyone have any insights as to how to include the parsec library in my own repo? (I just want it to be self-contained.) I can't figure out how to change the search path of .hi files, and when I try to import the .hs version of parsec there are lots of errors.
17:21:04 <Cale> saiko-chriskun: You shouldn't have to do that, it's a package on hackage, so it's only ever a cabal-install away...
17:21:18 <saiko-chriskun> yeah I know
17:21:20 <acowley> saiko-chriskun: just clone the source into a subdirectory that has the parsec.cabal file in it, bump the version every so slightly, and cabal install it from there to use your personal version
17:21:21 <saiko-chriskun> just wonderin'
17:21:30 <Cale> saiko-chriskun: But .hi files are meaningless without the corresponding .o files
17:21:38 <Cale> (they're temporary files)
17:21:48 <saiko-chriskun> ah
17:21:51 <Cale> You shouldn't have to save .hi files ever
17:22:58 <Cale> What's wrong using the source files?
17:23:22 <Cale> If they're in appropriate paths relative to your project, it should be fine, I'd expect
17:24:03 <saiko-chriskun> the first two errors I got were related to an #ifdef statement and something about the incorrect usage of (.) I think
17:24:11 <Cale> hmmm
17:24:42 <saiko-chriskun> Text/Parsec/Pos.hs:25:2: lexical error at character 'i'
17:24:44 <Cale> It could be that the .cabal file turns on language options (like the C preprocessor) which aren't specified in the source files.
17:25:03 <alvarobsp> can anyone give me some help with this piece of code: http://pastebin.com/PSTB7Vym ?
17:25:04 <saiko-chriskun> right
17:25:25 <Cale> Perhaps try adding {-# LANGUAGE CPP #-} to the top of the file (or adding CPP to the list of extensions if there's already such a pragma)
17:25:49 <alvarobsp> it works well without the "if n <= 0 ... exitFailure" part, but otherwise I get an error and can't figure out what to do
17:26:04 <alvarobsp> btw, I have "import System" on the top of the file
17:26:10 <Cale> alvarobsp: First of all, don't use tab characters. Configure your text editor to turn them to spaces automatically.
17:26:49 <Cale> Secondly, every 'if' expression must have both a 'then' and an 'else'
17:27:10 <Cale> If you don't want both, you can use the 'when' function from Control.Monad
17:27:23 <Cale> when (n <= 0) $ do ...
17:27:57 <Cale> Third, if/then/else should be indented like this:
17:27:59 <Cale> if foo
17:28:01 <Cale>    then bar
17:28:03 <Cale>    else quux
17:28:33 <Cale> ^^ the 'then' and 'else' should line up whenever they're on separate lines, and they should start in a deeper column than the 'if' which they are a part of
17:28:34 <saiko-chriskun> Cale: that fixed the first error, here's the second: http://paste.pocoo.org/show/392519/
17:29:08 <Cale> saiko-chriskun: {-# LANGUAGE CPP, DeriveDataTypeable #-}
17:29:31 <saiko-chriskun> http://paste.pocoo.org/show/392521/
17:29:42 <saiko-chriskun> add XRankNTypes too? :P
17:29:47 <Cale> yeah, without the X
17:29:59 <Cale> -X<language feature name> is the commandline option
17:30:05 <ddarius> Parsec should only need rank 2 types.
17:30:06 <saiko-chriskun> ah righto
17:30:34 <alvarobsp> I'll have to reindent 174 lines :(
17:30:46 <alvarobsp> Cale: I'm gonna try it, thanks for the advice
17:31:50 <Cale> alvarobsp: mainly it's the second part of that which is important -- that the 'then' and 'else' start in a deeper column than the 'if' -- particularly when inside of a 'do'
17:32:14 <Cale> This is because another line starting at the same column will be treated as a separate statement of the do block
17:32:31 <Cale> But for good style, it's best to always indent it like that
17:32:48 <saiko-chriskun> Cale: thanks for the help :]
17:34:35 <ddarius> For good style, don't use if-then-else.
17:34:40 <hpc> ^
17:35:42 <dolio> I don't know. if-then-else is better than case b of True -> ... ; False -> ...
17:35:53 <ddarius> For good style, don't use case.
17:35:55 <dolio> If you're using booleans.
17:36:02 <blackdog> hanging is better than hanging, drawing and quartering
17:36:26 <alvarobsp> Cale: just used the 'when' and it worked well, thanks a lot!
17:38:13 <hpc> ideal style is to use guards, if your function permits that style without becoming verbose
17:42:15 <acowley> is there anything approaching an idiomatic name for a proper eliminator for Bool?
17:42:22 <acowley> I usually write if'
17:42:40 <dolio> bool
17:42:52 <acowley> oy vey
17:42:57 <acowley> that's much better
17:43:22 <acowley> but it's not defined in any common place, is it?
17:51:36 <acowley> I think the best part about Haskell is starting a frighteningly massive refactoring like swapping out a critical type, seeing a million type check failures cry out together, rapidly silencing them, and seeing "OK, modules loaded" 5 minutes later in GHCi.
17:56:04 <saiko-chriskun> yup
17:56:09 <saiko-chriskun> ;D
18:09:31 <saiko-chriskun> so, I'm on archlinux. they have a haskell-parsec package which installs into /usr/lib, not ~/.cabal, and import Text.Parsec doesn't seem to find it. running with -v only shows search paths for ~/.cabal
18:10:01 <Saizan> saiko-chriskun: ghc-pkg list parsec ?
18:10:31 <saiko-chriskun> /usr/lib/ghc-7.0.2/package.conf.d
18:10:38 <saiko-chriskun> yeah it's listed
18:10:47 <Saizan> which version?
18:10:53 <saiko-chriskun> 3.1.1
18:11:14 <Saizan> have you restarted ghci after the installation?
18:11:22 <saiko-chriskun> I was testing with runghc
18:13:15 <saiko-chriskun> oh it says there are files missing in the parsec-3.1.1 package
18:13:18 <saiko-chriskun> -_-
18:13:34 <Saizan> weird
18:13:36 <parcs> don't use repo packages for libraries unless they're required to install an executable
18:13:57 <parcs> (in my opinion) :)
18:28:54 <alvarobsp> When I interpret this code on WinHugs, it works nice.. but when I compile it on GHC, the executable that it generates is all buggy, (for exemple.. there's an putStrLn asking for a number and then it gets an input from the user, but the .exe waits for the input first and then shows the "putStrLn") http://pastebin.com/TsLcEqdk
18:29:05 <alvarobsp> can anyone give me a hint about what is going on?
18:30:05 <Saizan> you need to flush stdout
18:30:32 <alvarobsp> how do I do this?
18:30:48 <Saizan> with hFlush stdout
18:31:00 <Saizan> after each putStr
18:31:22 <Saizan> or you could hSetBuffering stdout NoBuffering at the start of your program
18:36:55 <alvarobsp> Saizan: I've tried both, both of them worked well, thanks a lot :)
18:37:10 <Saizan> np
18:38:33 <alvarobsp> is there anything in haskell equivalent to C++'s system("pause")?
18:39:03 <parcs> what does that do?
18:39:45 <ion> Why would you use an external, platform-specific command for that?
18:39:57 <alvarobsp> pauses the program until a key is pressed and gives an "press any key to continue"
18:40:10 <liyang> Where's the any key?
18:40:12 <shachaf> alvarobsp: You know that's not C++, right? You can use (system "pause") in Haskell to run the same program, but don't do that.
18:40:34 <alvarobsp> didn't know that
18:40:37 <alvarobsp> shachaf:  why not?
18:40:59 <parcs> alvarobsp: putStrLn "Press any key to continue" >> getChar
18:41:05 <shachaf> Because it's platform-specific, as ion said, and running an external executable is silly.
18:41:21 <parcs> you might have to turn off buffering
18:41:23 <shachaf> What parcs said would probably work. You might need to hSetBuffering stdin NoBuffering.
18:43:17 <alvarobsp> dind't know it was an external executable :(
18:43:18 <alvarobsp> thanks
18:43:36 <parcs> hehe
18:45:38 <parcs> there's probably a package on hackage that provides such a function though
18:45:45 <ion> What did you think system does?
18:46:24 <parcs> magic
18:51:30 <mekeor> is there actually a haskell-CGI channel, too, on freenode?
18:53:20 <parcs> there's haskell-web
18:53:32 <mekeor> wow! cool, thx parcs!
19:16:19 <mekeor> good night :)
19:40:10 <jaredj> @pl \x y -> (not x) && y
19:40:10 <lambdabot> (&&) . not
19:43:22 <jaredj> awesome! connecting to the irc server and joining the channel has imbued me with enough clue that i don't have to ask the question i came to ask
19:45:00 <jeffz> welcome anyhow :)
19:45:34 <shachaf> jaredj: (\x y -> not x && y) === (<)
19:45:54 <jaredj> also true. i ended up with (/=)
19:46:15 <shachaf> That's xor, which is a different function. :-)
19:46:21 <jaredj> yes
19:46:25 <jaredj> i have an array of bools
19:46:34 <jaredj> i thought i wanted to find where we go from false to true
19:46:41 <jaredj> i settled for either transition
19:49:32 <jaredj> i haven't touched haskell for a few months and suddenly it's like wading through molasses
19:50:39 <jaredj> Excellent!
19:52:11 <jaredj> uh -
19:52:58 <jaredj> bah who does that
19:53:33 <jaredj> fun haskell application of the week.
19:53:47 <jaredj> 1. scavenge vacuum fluorescent display from old calculator.
19:54:14 <jaredj> 2. need to make holes in a (new) printed circuit board to reuse VFD.
19:54:38 <jaredj> 3. scan pins at 600dpi. increase contrast, threshold, save as Plain PBM.
19:55:04 <jaredj> 4. parse plain pbm with haskell; reduce to list of Bools
19:55:36 <jaredj> 5. find period in pixels of dark/light transitions to determine pitch of VFD pins.
19:56:30 <jaredj> 6. pitch is 1/8". normal chips, breadboards, etc. have 1/10" pitch
19:56:53 <jaredj> thanks for the cluon flux, #haskell! :)
19:57:11 <jaredj> (and shachaf!)
19:57:33 <povman> jaredj: good to see haskell can implement a ruler!
19:58:25 <jaredj> i tell you, it's quite flexible
20:01:36 <sm> ezyang: did hackagebot miss an upload ?
20:05:33 <sm> hey there jaredj.. how's your ofx lib ? :)
20:06:09 <saiko-chriskun> anyone familiar with Network.Browser? I'm trying to pattern match against the 'request' function to get the Response but not sure how
20:06:28 <saiko-chriskun> *only the Response
20:06:38 <saiko-chriskun> request looks like: request :: HStream ty => Request ty -> BrowserAction (HandleStream ty) (URI, Response ty)
20:34:54 <jose> hello haskell community
20:36:46 <saiko-chriskun> jose: hiya o/
20:37:44 <jose> can anyone explain the diffrence between ruby and haskell, while working on the tutorial they look very similar
20:37:53 <saiko-chriskun> hah
20:38:09 <saiko-chriskun> they're worlds apart :P
20:38:19 <parcs> jose: keep working on the tutorial ;)
20:39:02 <saiko-chriskun> jose: haskell is a purely functional language
20:39:06 <saiko-chriskun> jose: http://www.haskell.org/haskellwiki/Introduction#What_is_functional_programming.3F
20:39:19 <jose> thanks
20:56:04 <blackdog> so, anyone do the codejam in haskell?
20:56:21 <blackdog> first time i did it all in haskell and i think i got through :)
20:57:46 * ddarius doesn't think code would make a flavorful jam.
22:20:40 <manju_> luite, Have you released the source for the wolfgang lambda ?
22:43:25 <Axman6> logBase 2 80000000
22:43:35 <Axman6> > logBase 2 80000000
22:43:36 <lambdabot>   26.253496664211536
22:43:41 <Axman6> > 2^26
22:43:42 <lambdabot>   67108864
22:43:55 <Axman6> > 2^27
22:43:56 <lambdabot>   134217728
23:47:01 <Axman6> > 2^20
23:47:02 <lambdabot>   1048576
23:47:19 <Axman6> > 2^22
23:47:20 <lambdabot>   4194304
23:53:46 <Jonno_FTW> @src (^)
23:53:46 <lambdabot> x ^ 0            =  1
23:53:46 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:53:46 <lambdabot>   where f _ 0 y = y
23:53:46 <lambdabot>         f x n y = g x n
23:53:46 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
23:53:48 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:53:50 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:55:20 <saiko-chriskun> if anyone could shed some light on this it'd be awesome :]
23:55:22 <saiko-chriskun> http://stackoverflow.com/questions/6080200/creating-cookies-with-network-browser
