00:21:28 <flosit> hi guys
00:22:45 <Eduard_Munteanu> flosit: hi
00:24:00 <flosit> is it possible to 'combine' typeclasses? i.e. i want a Matrix-Implementation to be  instance of Num and to be instance of an own typeclass called 'Matrix'
00:24:15 <flosit> but Num and Matrix will share certain attributes
00:24:24 <flosit> like having (*)
00:24:38 <flosit> is there something like a typeclass-inheritance?
00:24:44 <rostayob> flosit: well of course you can instantiate a data type with multiple type classes
00:24:59 <rostayob> ah
00:25:01 <rostayob> mhm
00:25:29 <rostayob> you can have instance Foo a => Class a where... I think, with some extension
00:26:11 <Eduard_Munteanu> Mm, I don't think you need an extension for that.
00:26:55 <Eduard_Munteanu> Oh, and you probably mean   class (Foo a) => Class a where ...
00:27:05 <rostayob> Eduard_Munteanu: that's the same :P
00:27:07 <rostayob> yes
00:27:16 <rostayob> ah no]
00:27:27 <rostayob> I mean instiating a polymorphic type
00:27:37 <frerich> rostayob : http://en.wikibooks.org/wiki/Haskell/Class_declarations#Class_Inheritance <-- looks like there's indeed inheritance.
00:28:06 <rostayob> frerich: oh that's what you meant? yes
00:28:22 <rostayob> the "share some attributes" confused me
00:28:23 <frerich> rostayob: So maybe you have one Matrix class for types which also instantiate Num
00:28:30 <rostayob> but yes of course you can do that
00:28:48 <flosit> frerich: thanks, i will have a look at that
00:29:04 <rostayob> ah frerich /= flosit
00:29:06 <rostayob> eheh
00:29:11 <frerich> rostayob: Oh, you knew that already, sorry. I didn't :-) and I mixed you up with flosit.
00:29:41 <rostayob> :)
00:30:16 <rostayob> but I wouldn't call that inheritance
00:30:21 <rostayob> mh well...
00:30:27 <rostayob> yeah
00:30:48 <frerich> Maybe you cannot really have the same (*) function, just like you have e.g. '(/)' and 'div'
00:31:09 <frerich> So maybe Matrix instances get a <*> function or so
00:31:22 <rostayob> frerich: that's simply a problem with function names, if you really want you can import Prelude hiding (Num) etc
00:31:26 <rostayob> but yes
00:31:29 <rostayob> it wouldn't be a good idea
00:32:33 <Eduard_Munteanu> Mm, you could make Matrix an instance of Num
00:32:47 <Eduard_Munteanu> where Matrix is your actual matrix type.
00:32:49 <frerich> Actually. How about the matrix type just instantiates Num and reimplements (*) and so on
00:32:59 <rostayob> yeah that's the best idea (:
00:33:01 <frerich> Or is there something in Num which doesn't make sense for matrices?
00:33:07 <frerich> 'fromInteger' maybe.
00:33:44 <rostayob> :info Num
00:33:50 <rostayob> oh you can't do that here :P
00:33:55 <Eduard_Munteanu> @instances Num
00:33:56 <lambdabot> Double, Float, Int, Integer
00:34:37 <Eduard_Munteanu> Though that's not accurate I think...
00:34:42 <rostayob> maybe signum doesn't make too much sense either
00:35:14 <flosit> if i reimplement (*), do i to reimplement it for every type then? (e.g. Double * Matrix, Float * Matrix, etc)
00:35:16 <luite> the size of the matrices is going to be tricky, unless you only allow square matrices
00:35:36 <flosit> s/to/have to/
00:35:57 <rostayob> flosit: you could declare matrix to be data Num a => Matrix a... where a is the type the matrix contains
00:35:57 <Eduard_Munteanu> flosit: no
00:36:12 <Eduard_Munteanu> You'd call (*) on the underlying types at some point
00:36:18 <flosit> ah, sure
00:36:36 <luite> flosit: you can't implement (*) that can multiply a matrix by a scalar
00:36:44 <Eduard_Munteanu> Also for number * matrix multiplication you'd probably use fromInteger
00:36:45 <luite> unless you hide Num from the Prelude
00:37:02 <Eduard_Munteanu> :t fromIntegral    -- even
00:37:03 <lambdabot> forall a b. (Integral a, Num b) => a -> b
00:37:20 <rostayob> this discussion reminds me of this page: http://www.haskell.org/haskellwiki/Functional_dependencies
00:37:39 <Eduard_Munteanu> Wait no, that'd only work as a Hadamard product or what's that called :)
00:40:03 <erus`> > map sin [0,45..360]
00:40:04 <lambdabot>   [0.0,0.8509035245341184,0.8939966636005579,8.836868610400143e-2,-0.80115263...
00:40:12 <Eduard_Munteanu> I think it'd work if you make your number into the identity matrix multiplied by a constant, but then it won't be commutative.
00:41:11 <erus`> how does one sin radians?
00:41:15 <erus`> i mean degrees
00:41:40 <Eduard_Munteanu> > sin pi
00:41:41 <lambdabot>   1.2246467991473532e-16
00:42:22 <Eduard_Munteanu> > sin 180
00:42:23 <lambdabot>   -0.8011526357338304
00:42:42 <Eduard_Munteanu> You'd convert to degrees beforehand I suppose.
00:42:47 <Eduard_Munteanu> *to radians
00:42:59 <erus`> outrageous
00:43:03 <Eduard_Munteanu> :)
00:43:21 <erus`> who uses radians anyway; they're shit
00:43:44 <flux> indeed, radians are the shit!
00:43:46 <Eduard_Munteanu> Who uses degrees?
00:43:46 <Cale> radians are the one true angle measure
00:43:54 <Eduard_Munteanu> I mean, besides laymen :)
00:44:04 <erus`> the angle measure that binds them...
00:44:08 <ddarius> Cale: Stereoscopic projection all the way.
00:44:23 <erus`> Eduard_Munteanu: Opengl for a start
00:44:44 <Cale> If you have an angle theta, and a circle of radius r, then the arc length along the circle through that angle is r * theta, but only if theta is in radians.
00:45:05 <Eduard_Munteanu> > let sin' x = sin (x / 180 * pi) in sin' 30
00:45:06 <lambdabot>   0.49999999999999994
00:46:40 <Eduard_Munteanu> > sin (pi / 6)
00:46:41 <lambdabot>   0.49999999999999994
00:46:48 <erus`> I have created a rock paper scissors game and a tic tac toe game, whats next?
00:46:50 <Eduard_Munteanu> Hrm.
00:47:28 <luite> have you made a perfect ai player for both? :p
00:48:17 <Eduard_Munteanu> Does it have a GUI?
00:48:23 <rostayob> i agree on the ai
00:48:33 <erus`> luite: perfect rock paper scissors game is random or one that learns from the player?
00:48:40 <rostayob> but ai for rock paper scissor is hard
00:48:41 <rostayob> yeah :P
00:48:50 <rostayob> and for tic tac toe is too easy
00:48:56 <rostayob> do a tetris ai or something like that
00:49:08 <rostayob> i mean something that's not the usual minimax
00:49:21 <erus`> i havnt done any gui stuff yet, apart from GLUT hello triangle
00:49:51 <luite> erus`: hehe it's probably possible to do a slightly better than random against the average player, without learning
00:49:59 <rostayob> gui is boooooring
00:50:14 <erus`> luite: how?
00:50:28 <erus`> (i have made a learning bot in C)
00:50:31 <Eduard_Munteanu> Yeah, but it might be instructive in other Haskell concepts.
00:50:38 <Eduard_Munteanu> Depends on the goal.
00:50:46 <rostayob> yeah
00:50:52 <rostayob> but i learn more during fun stuff (:
00:51:00 <luite> erus`: because humans don't want to be predictable, and that could make them actually be more predictable
00:51:02 <rostayob> *doing. I just woke up eheh
00:52:05 <Eduard_Munteanu> Well, the bot would just do something along the lines of time series prediction.
00:52:09 <luite> erus`: i'd expect slighty fewer repetitions of the same move (especially three times in a row) compared to a completely random strategy
00:52:43 <erus`> oh i see
00:53:11 <luite> but of course, any player that knows that you know this, could easily adapt
00:53:51 <rostayob> or you could add a roundkick move to the ai, wins against rock paper and scissor
00:53:54 <rostayob> that's a perfect ai
00:54:18 <luite> that's only allowed in the chuck norris variant of the game
00:54:45 <rostayob> yeah
00:54:52 <erus`> i would like a game like rock paper scissors but with a simple state
00:55:01 <rostayob> erus`: connect four
00:55:12 <luite> or reversi
00:55:35 <rostayob> or the classic game of life, but that's not exactly a game.
00:55:49 <erus`> like after rock beats scissors -> the winner can choose 'smash head in'  or 'crush legs' and the loser can choose 'duck' or 'roll' or something
00:56:00 <rostayob> i mean not an adversarial game
00:57:42 <rostayob> another game that's nice to program an ai for it's oware
00:57:48 <rostayob> it's the right amount of complexity
00:58:03 <rostayob> and you can solve it both with logic or with brute force
00:58:12 <rostayob> and it's easy to program
00:58:20 <erus`> i had that on my old nokia
00:58:28 <rostayob> erus`: yeah, good ol bantumi
01:01:44 <frerich> FWIW, a simple game for which writing an AI is quite interesting is http://en.wikipedia.org/wiki/Dots_and_Boxes
01:02:28 <erus`> massive search tree though
01:02:39 <rostayob> frerich: oh right, we used to play that. I nice thing about that is that the grid size is not fixed
01:02:41 <erus`> i wish sdl would work on windows
01:02:46 <erus`> with haskell
01:02:47 <rostayob> erus`: it doesn't?
01:02:50 <erus`> with cabal
01:03:08 <Ke> I'd wish sdl would work propersly on any platform
01:03:10 <erus`> no it needs all this linux compatabilty stuff to build it
01:03:18 <Ke> -s
01:03:22 <flosit> a nice game i wrote an ai in C once:  http://en.wikipedia.org/wiki/Duell_(chess)
01:04:58 <frerich> erus`: There's nothing interesting about a computer player which can make use of a huge search tree IMHO. :-) The trick is to make it a good opponent by teaching it about good heuristics which require no more than a few recursion steps.
01:05:59 <Eduard_Munteanu> The fun is in optimizing the search ;)
01:06:11 <rostayob> or simply use logic to get the best strategy
01:06:31 <rostayob> with almost no search tree
01:06:43 <rostayob> that's more interesting to code imho
01:06:47 <frerich> For instance, you might assign a number to each edge which describes its "danger" (the highest value would allow your opponent to close a box). This would be a rather passive strategy.
01:07:12 <frerich> Or a strategy which prefers working in one corner in attempt to distract a human from the really interesting areas ;-)
01:07:13 <Eduard_Munteanu> Well if you want to experiment making less searchy AIs you probably want to look at something like Go, where the game space is really huge.
01:07:35 <Eduard_Munteanu> You'd still use a tree search but you do need to have good heuristics.
01:07:47 <rostayob> another interesting thing to do if you can't reach the end of the tree (which is true in most cases) is to have an evolutionary evaluation function
01:08:05 <rostayob> so you play little tournaments with groups of ais with different weightings
01:08:21 <flosit> Eduard_Munteanu: that would be most interesting as there currently is no AI which could beat a grand master ;)
01:08:31 <frerich> Yeah that's fun. Usually, as soon as I have *some* AI working, I love writing anothre in an attempt to beat the former :-)
01:08:40 <flosit> (in comparison to chess)
01:08:42 <Eduard_Munteanu> Yeah, I hear computer Go players can be quite stupid.
01:08:45 <rostayob> Eduard_Munteanu: yeah go is a bitch :P
01:09:22 <rostayob> but the sad thing is that it's just a matter of time, and at some point raw power will be capable of beating it i guess
01:09:56 <frerich> I don't think that's any more "sad" than a computer being able to multiply numbers much faster than a human.
01:10:04 <Eduard_Munteanu> AFAIK, Go is still quite intractable to computation. IDK if you can ever achieve performances similar to Chess.
01:10:33 <luite> rostayob: hmm, I'm not sure if that's used in practice (probably for statically tuning the evaluation function, possibly different ones for different parts of the game), but along those lines, and probably relatively easy to implement, are the monte-carlo methods used in computer go
01:10:48 <Eduard_Munteanu> (using only searches I mean)
01:10:58 <rostayob> frerich: yeah but the fact that a human can still be a lot better in a purely "mathematical" game like go is great
01:11:14 <rostayob> mathematical is not the correct term, but you get the point :P
01:11:25 <flosit> well, compared to chess go has an exploding search tree.  i guess the first go engine which will beat a grand master will be something on basis of a neurol network or similar
01:11:45 <flosit> s/neurol/neural/
01:12:30 <rostayob> luite: well with some games is relatively easy to have "states", like beginning mid game etc, and have a computer identify them and change strategy
01:14:05 <Eduard_Munteanu> I suppose we could all go play the halting problem; you don't even know who won :P
01:14:33 <rostayob> but prolog is still the best tool to do that
01:14:37 <rostayob> Eduard_Munteanu: ehe
01:28:19 <erus`> glut has these draw and keyboard input callbacks but i cant keep track of the state of my game that way
01:28:25 <erus`> how do i get around this
01:34:29 <Zao> erus`: Curry some state parameters into them.
01:34:46 <Zao> Err, not curry, but partially apply.
01:35:07 <Zao> keyFunc $= (myKeyHandler awesomeState)
01:35:24 <Zao> With   myKeyHandler :: AwesomeState -> Key -> Depressed -> IO ()
01:35:32 <Zao> Or however they look, with a bonus parameter.
01:36:00 <Zao> AwesomeState would probably hold an IORef, STM TChan, or something other suitable.
01:38:33 <erus`> thanks Zao
01:43:08 <erus`> whats the best data type for a fixed size array of items
01:43:25 <erus`> that i want to change individual items like in a map
01:43:47 <mm_freak> erus`: mutable?
01:44:03 <shachaf> erus`: When you say "array" do you mean "array"?
01:57:32 <erus`> how do i use the lambda calculus interpreter on lambdabot ?
01:58:29 <shachaf> erus`: > blah blah blah
01:58:47 <erus`> isnt that the haskell interpreter?
01:58:53 <shachaf> Yep.
01:59:01 <erus`> sneaky
02:14:28 <erus`> has anyone played with f# yet?
02:19:54 <osfameron> erus`: ooo!  that's yet another of the things I have queued up for my Copious Free Time!
02:20:04 * osfameron downloads Mono for OSX for starters
02:20:29 <erus`> I'm trying to use Data.Array in ghci
02:20:31 <zomg> erus`: F# seemed pretty nice since the .NET library is pretty strong
02:20:47 <zomg> but I'm mostly a noob in FP myself so can't really say much about it otherwise =)
02:21:04 <erus`> so I "import Data.Array (Array)"
02:21:16 <erus`> but Array still not in scope
02:22:03 <Peaker> erus`, That import imports the *type* Array, not the data constructor Array. Did you try using Array in the value namespace (as a value)?
02:22:31 <erus`> yes i did
02:24:23 <erus`> aha thanks Peaker
02:32:50 <osfameron> zomg: I wonder if there's any work on letting haskell call .Net libraries?
02:32:53 <rostayob> erus`: F# is ocaml for the CLR
02:33:09 <osfameron> aha, http://www.cin.ufpe.br/~haskell/haskelldotnet/
02:33:12 <rostayob> since I don't use windows I'd rather use ocaml directly
02:33:21 <osfameron> looks quite abandoned
02:33:36 <rostayob> but yeah f# has a lot of libraries since it runs on that platform, and it has microsoft to support it
02:33:53 <zomg> osfameron: no idea, I recall seeing some .net interop library while randomly browsing though
02:33:56 <erus`> I'm not sure whether I like impure functional languages now I have started learning haskell
02:34:28 <rostayob> well i like standard ml, never used ocaml
02:34:38 <osfameron> you saw the thing about 85% purity recently? http://www.johndcook.com/blog/2010/04/15/85-functional-language-purity/
02:35:44 <osfameron> I do like aspects of the extra 15% in Haskell, but as you really do get so *much* benefit with just the first 85%...
02:35:58 <rostayob> I disagree, pure languages do work
02:36:01 <osfameron> (says the Perl programmer, working on a maybe 30% pure application at the moment ;-)
02:36:07 <osfameron> rostayob: oh, I'm sure they do
02:36:26 <rostayob> clojure works
02:36:29 <osfameron> but it may be easier (for the average programmer) to get to 85% pure than to make the extra push to 100%
02:36:44 <rostayob> that's something different then saying that pure languages don't work
02:36:55 <rostayob> also, 90% pure doesn't make much sense to me
02:36:58 <rostayob> what does that mean?
02:36:59 <osfameron> someone's talking about Clojure at our FP night on 31st, I'm looking forward to it (I know pretty much nothing about it)
02:37:01 <erus`> as im using 'do' it might aswel be imperative though...
02:37:21 <osfameron> rostayob: oh, I didn't say that 100% doesn't (I know the article I linked to does - I think it's overstating its case)
02:37:50 <Nereid> erus`: do notation is not imperative programming
02:37:55 <rostayob> I mean i would totally define haskell pure, but
02:38:02 <rostayob> :t unsafePerformIO
02:38:03 <lambdabot> Not in scope: `unsafePerformIO'
02:38:19 <rostayob> oh, whatever
02:38:27 <rostayob> so is haskell 95% pure or something like that?
02:38:42 <aleator> It seems that lambdabot is more pure than rest of haskell ;)
02:39:02 <rostayob> well
02:39:12 <rostayob> :t error
02:39:13 <lambdabot> forall a. [Char] -> a
02:39:44 <rostayob> but that's not side effecting it just raises an exception i guess
02:39:48 <rostayob> mhm
02:40:00 * liyang is scared
02:40:10 <mauke> error x = error x  -- a pure definition
02:40:39 <liyang> exceptions are side-effects…
02:41:07 <rostayob> right
02:41:10 <Nereid> no
02:41:18 <Nereid> error is just a thing that produces bottom.
02:41:28 <rostayob> "a function or expression is said to have a side effect if, in addition to producing a value, it also modifies some state or has an observable interaction with calling functions or the outside world."
02:41:36 * hackagebot protocol-buffers 2.0.2 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.2 (ChrisKuklewicz)
02:41:38 * hackagebot protocol-buffers-descriptor 2.0.2 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.2 (ChrisKuklewicz)
02:41:40 <aleator> We've got one senior lecturer who is really trying to push F# instead of haskell. On accounts that I have to teach the thing, I'd really like find some convincing arguments besides "I don't know F#"
02:42:00 <zygoloid> rostayob: by that definition exceptions are certainly not side-effects
02:42:12 <rostayob> zygoloid: well that kind of io exception (error) is
02:42:15 <zygoloid> firstly, exceptions are not "in addition to producing a value"
02:42:26 <rostayob> oh yeah, true
02:42:29 <zygoloid> secondly, exceptions can be modeled as values
02:43:24 <rostayob> I'm not talking about exceptions in general, i'm talking about error and undefined
02:43:36 <erus`> can i give a type an alias? like typedefs in C
02:43:44 <rostayob> erus`: type Foo = Bar
02:44:01 <erus`> thats easy :)
02:44:06 <Nereid> depending on what you want to use it for, you might want to use newtype instead
02:44:37 * hackagebot hprotoc 2.0.2 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.2 (ChrisKuklewicz)
02:44:47 <rostayob> yeah if you want extra type safety use newtype. i don't mind type synonyms anyway
02:45:02 <erus`> whats the difference?
02:45:09 <Nereid> newtype actually makes a new type.
02:45:25 <Nereid> ...
02:45:45 <erus`> type makes a new type?
02:45:47 <Nereid> no
02:45:55 <Nereid> type just gives a different name to an existing type
02:46:06 <Nereid> so if I did
02:46:08 <Nereid> type Foo = Int
02:46:16 <rostayob> newtype Foo = Foo Int
02:46:29 <Nereid> if type Foo = Int, then anywhere I can use an Int, I can use a Foo instead, and vice versa.
02:46:42 <Nereid> the type checker considers them to be the same.
02:46:46 <Nereid> however, if Foo is a newtype
02:46:50 <Nereid> then I can't do that.
02:46:59 <Nereid> I'd have to explicitly convert between them.
02:47:22 <Nereid> "newtype Foo = Foo Int" is almost the same as "data Foo = Foo Int".
02:47:38 <rostayob> but better, because the compiler will know that the only thing inside a Foo is an Int
02:47:57 <Nereid> well it's also different because the constructor of a newtype is strict
02:48:03 <Nereid> speaking of which
02:48:07 <rostayob> yeah
02:48:11 <Nereid> I have a feeling I asked this once before, but
02:48:18 <shachaf> Nereid: newtype Foo = Foo Int =/= data Foo = Foo !Int
02:48:28 <Nereid> yeah, I was about to ask that
02:48:31 <Nereid> is there any semantic difference
02:48:43 <mauke> Nereid: case undefined of Foo _ -> ()
02:48:53 <Nereid> mm
02:48:57 <Nereid> right.
02:49:13 <rostayob> the wiki page about newtype has all that iirc
02:49:18 <Nereid> well yeah
02:49:30 <osfameron> 'The answer to "When will Haskell finally go mainstream?" is "most of it already has."' # http://prog21.dadgum.com/31.html
02:49:33 <rostayob> http://www.haskell.org/haskellwiki/Newtype#Examples
02:56:35 <jonkri> are there some standard/approved "linking exception" clauses out there to modify the lgpl license so that it works better (doesn't force proprietary programs to publish their code) with haskell programs in regards to ghc's way of linking?
02:58:10 <Wooga> hello, am i doing write a FP-pure lol-evalutor, printing "Do some output" on each 'a' character in input source here: http://paste.pocoo.org/show/387418/ ?
02:58:25 <Wooga> i am confused a bit by 'where evalutor' thing
02:59:36 <ddarius> osfameron: "Purity has some advantages, but it's so convenient and useful to directly modify a dictionary in Python." shows that most of it has not.
02:59:52 <Peaker> zygoloid, so the Maybe monad does not yield an "exception effect", because it never is in addition to a value?
03:00:18 <Wooga> s/write/right/
03:01:04 <osfameron> ddarius: I suppose the question is whether that final bit of purity is the *most* important thing (compared to 1st-class-functions, memory-management, prelude/core functions that operate functionally on lists/etc.)
03:01:25 <osfameron> ddarius: actually, I'd quite like a functional dictionary library for Perl... I guess I should write one...
03:01:30 <Peaker> I think pure data manipulation is more powerful than in-place data manipulation (e.g: you get transactionality for free, far better type-checking, etc) -- but it takes a long learning period to go from productive-using-inplace-mutations to productive-using-compositions-of-pure-manipulations
03:01:50 <sanjoyd> osfameron: Whether functional programming has gone mainstream or not is different question from whether Haskell has gone mainstream.
03:02:15 <mauke> osfameron: I can give you a functional priority queue for perl :-/
03:02:22 <Peaker> People often say: "I would use a functional language, but this thing is all about state"... if it's all about state, that's all the more reason to go functional
03:02:32 <osfameron> mauke: ooo, is it on CPAN?
03:02:41 <mauke> http://search.cpan.org/~mauke/Data-PrioQ-SkewBinomial-0.03/lib/Data/PrioQ/SkewBinomial.pm
03:03:01 <flux> I've sometimes had bugs (not in haskell, though) where I've accidentally mixed the previous and current state. perhaps monads would have helped there..
03:03:21 <Peaker> flux, or combinators (e.g: (.))
03:03:28 <osfameron> mauke: shiny, thanks
03:03:36 <Peaker> manipulateState3 . manipulateState2 . manipulateState1
03:03:43 <Peaker> Can't accidentally use old state
03:04:08 * ddarius doesn't consider higher order functions, garbage collection, and certainly not "list functions" particularly FP.
03:04:10 * osfameron did write Okasaki's red/black tree algorithm in Perl/Moose at some point
03:04:46 <Wooga> guys?
03:04:48 <shachaf> ddarius: Is there anything other than purity that you'd consider particularly FP?
03:05:28 <zygoloid> Peaker: it does not yield an exception side-effect. it does yield an exception effect.
03:05:30 <jeffz> anyone know a package otoh which has a .cabal that calls configure and make for depending on a bundled c library?
03:05:52 <Wooga> am i doing all right here: http://paste.pocoo.org/show/387427/ when inventing helper where-function when trying to make if-'a-character-met-in-input-source-print-"Do some output"-evalutor?
03:05:53 <Peaker> zygoloid, well, "error" yields an exception without having it in the type
03:06:04 <Peaker> zygoloid, so isn't it a side-effect?
03:06:10 <mauke> what else could 'a' be?
03:06:26 <ddarius> shachaf: Not really.  To some extent algebraic data types and pattern matching have a slight bent toward FP, but only a slight one.
03:06:45 <Wooga> mauke: any other character, but (in this version) they are just ignored
03:06:58 <Peaker> "in addition to producing a value" is not a good definition for side effects.. the effect often includes NOT producing a value (empty list, Nothing, Left, ..)
03:07:12 <Wooga> mauke: i am planing to write BF-evalutorm but i am only in the begining of this path
03:07:36 <Wooga> mauke: and i want to know if i am facing right direction
03:09:18 <erus`> @hoogle foldl (++) ""
03:09:19 <lambdabot> Parse error:
03:09:19 <lambdabot>   --count=20 "foldl (++) """
03:09:19 <lambdabot>                         ^
03:09:45 <erus`> is there a function for that allready?
03:09:51 <erus`> like stringJoin or something
03:09:52 <rostayob> erus`: what are you trying to do?
03:09:55 <rostayob> :t concat
03:09:56 <lambdabot> forall a. [[a]] -> [a]
03:10:00 <shachaf> erus`: Try hoogling the type, not the value.
03:10:19 <ion> @hoogle " | echo foo "
03:10:19 <lambdabot> Parse error:
03:10:19 <lambdabot>   --count=20 "" | echo foo ""
03:10:20 <lambdabot>              ^
03:14:05 <RafBlutaxt> Hey, anyone here tried installing the hprotoc package with cabal in the newest version 2.0.0? I always get an error that two other packages protocol-buffers 1.11.1 and protocol-buffers-descriptor 1.11.2 are not available, but I have them installed in the current version (also 2.0.0). Am I doing something wrong?
03:14:38 <rostayob> RafBlutaxt: so ghc-pkg list lists protocol-buffers-descriptor?
03:15:55 <erus`> hmm has anyone got an example of how to map over an Array?
03:16:52 <ddarius> Use the vector package...
03:16:58 <mauke> :t amap
03:17:00 <lambdabot> Not in scope: `amap'
03:17:32 <mauke> ok, fmap then
03:22:08 <zygoloid> Peaker: without the "in addition to" clause, it's not a side-effect, it's just an effect, since there's nothing for it to be on the side of!
03:24:47 <RafBlutaxt> yesanyone else know something about that hprotoc package?
03:43:13 <cch> @hg a -> []
03:43:14 <lambdabot> Maybe you meant: . ? @ bf bug do ft ghc id msg pl rc thx v wn
03:43:23 <jonkri> are there any problems with lgpl besides the cross-module optimization stuff and ghc's static linking?
03:43:38 <cch> @hg a -> [a]
03:43:38 <lambdabot> Maybe you meant: . ? @ bf bug do ft ghc id msg pl rc thx v wn
03:43:58 <ezyang> @djinn a -> [a]
03:43:59 <lambdabot> Error: Undefined type []
03:44:04 <ezyang> :-P
03:44:35 <cch> I just want to find the List constructor
03:44:35 <shachaf> Fortunately [] is the same as Maybe as far as @djinn is concerned.
03:44:41 <shachaf> @src []
03:44:42 <lambdabot> data [] a = [] | a : [a]
03:44:58 <shachaf> a@hoogle a -> [a] -> [a]
03:44:59 <poltak> big Haskell newbie here: just wondering, why is the haskell-platform 66MB??? I thought it just included a compiler and the GHCi mode. what's in this package?
03:45:01 <shachaf> @hoogle a -> [a] -> [a]
03:45:01 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
03:45:01 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
03:45:01 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
03:45:03 <cch> ok
03:45:17 <cch> I just want (:[])
03:45:24 <cch> --!
03:45:28 <shachaf> @ty return
03:45:29 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
03:45:37 <shachaf> > return 5 :: [Int]
03:45:38 <lambdabot>   [5]
03:46:05 <cch> yes, return also works
03:46:10 <cch> thank you all
03:46:20 <stianhj> Does lambdabot have a "seen anyone" command? Or "seen anyone except me" command. It's been pretty lonely in #haskell.no for a while.. just me and lambdabot :P
03:46:28 <parcs> poltak: it includes much more than that: http://hackage.haskell.org/platform/contents.html
03:47:33 <shachaf> stianhj: Not really.
03:48:24 <poltak> @parcs thanks, explains why it's so big :p
03:48:25 <lambdabot> Not enough privileges
03:51:32 * osfameron punches Smullyan in the face
03:51:57 <shachaf> osfameron: Why Smullyan?
03:52:21 <osfameron> shachaf: in the solutions, he writes things like "This is quite simple."
03:52:34 <shachaf> He's probably right.
03:52:58 <osfameron> I'm probably far more stupid than most of his target audience :-(
03:53:15 <shachaf> Hmm, he's turning 92 this month.
03:53:21 <osfameron> the learning curve on the Mockingbird chapter is insane.  It starts off with some impossible questions, and gets easy in the middle.
03:53:32 <osfameron> (and then hard again, on this "simple" solution)
03:53:44 <shachaf> "simple" /= "easy"
03:54:10 <osfameron> I understand all the derivations when he explains them
03:54:26 <osfameron> but I can go back to a problem for the 2nd or 3rd time and have *absolutely no idea* as to how to solve it again :-(
03:54:50 <osfameron> shachaf: that's a consolation, thanks ;-)
03:57:56 <jeffz> I set my build-type to configure in my .cabal, it runs the configure script when i 'cabal configure', is there a way to make it execute `make` too?
03:59:46 <dcoutts> jeffz: there are 4 build types: simple, configure, make and custom. The make build type calls ./configure and make. The configure build type is really just an extension of the simple build type where it uses a ./configure script to generate some extra pkgname.buildinfo files that the simple build system uses.
04:00:14 * hackagebot hashable 1.1.2.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.1.2.0 (JohanTibell)
04:00:53 <dcoutts> jeffz: that said, the make build type is not used much so is not tested much. On the plus side, it's pretty trivial so you can just copy the Cabal Distribution/Make.hs and customise it how you like.
04:01:29 <dcoutts> jeffz: since all it's doing is invoking make with various parameters
04:02:24 <zygoloid> am i being dumb, or does the HP 'batteries included' page not list the packages in the platform?
04:02:30 <jeffz> dcoutts: ah right, thanks
04:02:35 <erus`> how can i make / return an Int
04:02:50 <poltak> any of you used "learn you a haskell" before? What about for learning Haskell? opinions?
04:03:05 <poltak> read*
04:03:09 <erus`> poltak its nice and easy to get into
04:03:12 <shachaf> poltak: I used it, but just for keeping my door open and my house warm. Not for learning Haskell.
04:03:35 <jeffz> poltak: the section on applicative is well worth reading
04:04:11 <poltak> shachaf: so I'm assuming that you don't think highly of it (for learning, anyway). Can I ask why?
04:04:26 <dcoutts> zygoloid: it gives the documentation for all the libraries, but yes it doesn't explicitly list the package names.
04:05:27 <shachaf> poltak: Hmm? I haven't read it.
04:05:59 <shachaf> poltak: You asked "any of you used [this book] before? What about for learning Haskell?"
04:06:11 <ddarius> "It's readily apparent does not mean that it is readily apparent without pencil and paper."
04:07:49 <poltak> shachaf: eh? sorry, a bit too late for me. was just wondering about people's opinions on this book for learning
04:08:07 <shachaf> poltak: I found it amusing to consider what other uses the book might have than learning Haskell.
04:08:16 <jeffz> poltak: it's a good introduction, work through it and if you have problems ask questions here.
04:09:46 <poltak> shachaf: heheh I getcha now. I wasn't being too clear
04:15:12 <Peaker_> The HWN says "give leksah" some feedback, who do I give the feedback to?  It did not seem to work very well here
04:16:56 <jeffz> perhaps http://code.google.com/p/leksah/issues/list
04:18:21 <erus`> give me gedit and im happy
04:25:50 <parcs> Peaker_: leksah made my system unresponsive. did that happen to you too?
04:29:41 <fosskers> hey guys
04:29:44 <fosskers> i wrote a module
04:29:51 <fosskers> and i want it to be visible across my entire computer
04:29:56 <fosskers> so that a single import statement, say
04:30:02 <fosskers> import SexyMathLib
04:30:12 <fosskers> will work, no matter where the actual file is
04:30:25 <fosskers> where should the module file go, or what tinkering needs to be done, for this to work?
04:30:40 <jeffz> package it with cabal, configure, build and install the package.
04:30:57 <fosskers> ah, but then i can't edit it on the fly, can i?
04:31:18 <jeffz> nope, generally you make a stable version that doesn't need editing
04:31:25 <erus`> @hoogle (Fractional Int) -> Int
04:31:26 <lambdabot> Warning: Unknown type Fractional
04:31:26 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
04:31:26 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
04:31:47 <fosskers> hm
04:31:49 <jeffz> @type div
04:31:50 <lambdabot> forall a. (Integral a) => a -> a -> a
04:31:51 <fosskers> so no other way to do it eh
04:32:28 <erus`> `div` works
04:33:11 <fosskers> thanks jeffz
04:38:59 <MasseR> I've understood that type classes are meant to hide implementation details and provide ad-hoc polymorphism. Is using type classes to have for example two persistent implementations the right way? For example class Persist a where\n getShop :: IO Shop" with implementations to HDBC and acid-state.
04:40:12 <quicksilver> no, not really.
04:40:14 <sipa> a should somehow appear in the type of getShop
04:40:17 <quicksilver> why not just have
04:40:23 <quicksilver> getHDBCShop :: IO Shop
04:40:30 <quicksilver> getASShop :: IO Shop
04:40:37 <quicksilver> what has the typeclass gained you?
04:40:50 <quicksilver> (quite apart from the type-appearing-in-type issue which sipa correctly points out)
04:42:25 <RafBlutaxt> I get this error, using ProtocolBuffers:
04:42:25 <RafBlutaxt> ambiguous type variable `msg0' in the constraints:
04:42:25 <RafBlutaxt> (Text.ProtocolBuffers.WireMessage.Wire msg0) arising from a use of "messageGet" at...
04:42:25 <RafBlutaxt> (Text.ProtocolBuffers.Reflections.ReflectDescriptor msg0) arising from a use of "messageGet" at...
04:42:25 <RafBlutaxt> Probable fix: add a type signature that fixes these type variables in the expression "messageGet bs"
04:42:26 <RafBlutaxt> in an equation for `IT':  "IT = messageGet bs"
04:42:26 <RafBlutaxt> I'm trying to call messageGet from the prompt in ghc. What exactly am I doing wrong? And how can I fix this?
04:43:43 <MasseR> quicksilver: Well the real issue is this. The assignment is to create x with databases. Altough we might do something with the software later, and would like to use acid-state. So we'd like to switch to acid-state later with minimal rewrite
04:44:22 <quicksilver> MasseR: of course. it's a oneline change to chance 'getHDBCSHop' to 'getASShop'
04:44:28 <quicksilver> the key point is the common type 'Shop'
04:44:45 <quicksilver> it's having a common type which hides implementation details, not typeclasses.
04:44:47 <MasseR> True
04:44:52 <MasseR> Thanks
04:44:52 <quicksilver> typeclasses ARE NOT FOR hiding implementation details :)
04:45:10 <hpc> typeclasses are for EXPOSING implementation details ;)
04:46:46 <Wooga> is it a good idea to write own 'interact' function, which will work with tuples, containing outputs for file and for terminal?
04:47:38 <Wooga> not only for terminal, as regular 'interact' does
04:48:26 <shachaf> Not really. interact is kind of evil.
04:49:03 <Wooga> but how do i make my main logic of file/file contents manipulation program with interactive CLI-interface pure then?
04:49:48 <shachaf> If you figure out something that's useful for your own purpose, then write it, sure. I don't know where tuples come into it.
04:50:06 <Wooga> well, i think about (String,String)
04:50:41 <Wooga> or even (String,(String,String)), where it is (Output for termimal,(File name, Output for file))
04:51:41 <Wooga> ir just (File name, File contents), where name can be '-' - standart output
04:52:03 <Wooga> or*
04:52:05 <mux> Wooga: I'm not sure I get what you want, but do you know about hInteract ?
04:52:06 <shachaf> It's probably best not to have a function that handles all those weird things.
04:52:08 <shachaf> But never mind.
04:52:12 * shachaf >>= undefined
04:52:57 <Wooga> mux: can it have more then one output?
04:53:10 * ion <* shachaf
04:53:12 * osfameron finishes the Mockingbird chapter (for 3rd time, still had to get hints for some answers).  Not sure if I should go to next chapter, or try *again* to see if I've remembered all of this one first.
04:53:15 <Wooga> mux: i want to write out both for stadout and file from the same logic-function
04:53:36 <osfameron> Wooga: ah, like unix 'tee' ?
04:53:45 <mux> Wooga: ah, hInteract won't be enough then
04:53:53 <mux> you need a 'tee' like thing indeed
04:53:55 <Wooga> osfameron: yes, but with different outputs  for file and for stdout
04:54:08 <Wooga> i want CLI interface like that:
04:54:15 <Wooga> > :a string to write
04:54:16 <lambdabot>   <no location info>: parse error on input `:'
04:54:23 <Wooga> ("string to write" writes to file)
04:54:30 <Wooga> < String successfult writed
04:54:48 <Wooga> something like that interface
04:54:54 <Wooga> maybe it can be called 'shell'
04:55:02 <Wooga> yes, apparently it is shell
04:56:04 <udoprog> Wooga: "i want to write out both for stadout and file from the same logic-function" - at the same time?
04:56:44 <Wooga> udoprog: yes, i want to produce output for file and for user from the same function at the same time
04:57:35 <Wooga> cmd like ':a<text to write>' needs both writing to file and notifying user that write was complete successfuly, or not
04:57:38 <udoprog> Wooga: then pass in handles, and guard any error prone code?
04:58:23 <Wooga> udoprog: but i want ot stay pure, not knowing anything about handles inside my logic function
04:58:44 <Wooga> or is it bad idea?
04:59:04 <hpc> "not using handles" != pure
04:59:21 <Wooga> but "using handles" == impure
04:59:40 <Wooga> ?
05:00:11 <hpc> even if you can somehow manage to avoid using handles, you are still doing IO
05:00:16 <fosskers> is there any advantage of using function composition (.) over function application ($) ?
05:00:22 <hpc> and handles have no bearing on the purity of the function
05:00:42 <hpc> :t hPutStrLn
05:00:43 <lambdabot> Not in scope: `hPutStrLn'
05:00:47 <udoprog> Wooga: if you mean functional purity, then no
05:00:53 <hpc> bah
05:01:05 <Wooga> hpc: i can do IO in same way interacted functions doing
05:01:12 <hpc> fosskers: the two functions serve different purposes
05:01:16 <Wooga> getting string in input, producign tuples on output
05:01:18 <osfameron> fosskers: it's often quite elegant to build up a chain like:  foo . bar . baz $ parameter
05:01:32 <fosskers> but so far ive been able to do the same thing with $
05:01:35 <hpc> Wooga: that's not a special case
05:01:40 <fosskers> and it actually ends up being a few chars shorter
05:01:59 <hpc> fosskers: let f = foo . bar . baz in f x
05:02:02 <Wooga> hpc: what do you mean?
05:02:02 <fosskers> in this case:
05:02:06 <osfameron> fosskers: try it and see.  As hpc says, they do different things.  You may find that the composition version is more elegant or flexible.
05:02:07 <hpc> fosskers: stuff like that is the advantage
05:02:11 <fosskers> foo $ bar $ baz parameter
05:02:31 <hpc> Wooga: interact :: (String -> String) -> IO ()
05:02:37 <hpc> Wooga: interact f :: IO ()
05:02:38 <fosskers> im aware they do technically different things, but so far ive found the practical applications to be the same
05:02:50 <hpc> Wooga: hInteract :: Handle -> (String -> String) -> IO ()
05:02:57 <osfameron> fosskers: let qux = foo.bar.baz  -- you've now got rid of parameter
05:03:00 <hpc> hInteract handle :: (String -> String) -> IO ()
05:03:03 <Wooga> hpc: but (String -> String) is pure isn't it?
05:03:08 <mauke> map (f . g) xs
05:03:12 <hpc> Wooga: and look, we have "pure" handley code!
05:03:12 <mauke> map ($ x) fs
05:03:17 <fosskers> osfameron: true. would that not work with $?
05:03:46 <Wooga> hpc: i want to make different interact, taking (String -> (String,String))
05:03:49 <Peaker_> quicksilver, you could say the Monad type-class hides implementation details behind how bind/return work.. and that that's part of its purpose, why not?
05:04:12 <hpc> Wooga: where one string is the file name, the other the output?
05:04:19 <Wooga> hpc: yes
05:04:19 <osfameron> fosskers: I can remember asking the same question.  I recommend trying both, getting a feel for them.  I certainly came round to the idea that the composition style is more elegant in many situations.
05:04:45 <hpc> perhaps something like:
05:04:57 <fosskers> osfameron: okay, ill do my best to try out both
05:05:21 <fosskers> but so far: foo $ bar $ baz param     seems to take less room that: foo . bar . baz $ param
05:05:30 <hpc> hInteract f = do {in <- getLine; let (file, out) = f in; putStrLn out; appendFile file out}
05:05:34 <Peaker_> foo . bar $ baz param
05:05:51 <ion> “Less room” isn’t really the most important measure of code quality.
05:05:53 <mux> (foo . bar . baz) param
05:05:58 <Wooga> hpc: yes, i am thinked about exactly such thing
05:06:09 <Peaker_> fosskers, foo . bar . baz $ param   has the advantage of eta reduce as you said (ridding of the param) but also that you can cut&paste any subset of it to an external function, so it's easier to refactor
05:06:13 <fosskers> ion: hence my question. is there an advantage of one over the other?
05:06:19 <Wooga> hpc: thank you!
05:06:46 <fosskers> Peaker_: okay, i see how that could be useful
05:06:53 <hpc> in general, if you can only make an X while you are in IO, but you need to make it purely, you instead generate something pure that tells the IO which X to make
05:07:05 <hpc> or something like that
05:07:10 <Peaker_> fosskers, any sub-expression of foo . bar . baz $ param  is valid:  (bar . baz $ param)  or (foo . bar), etc.  this makes refactoring take less mental effort
05:08:17 <ion> fosskers: Yes, when you write ‘foo . bar . baz’ you’re thinking in terms of composing functions, and that results in a function that can be passed around. When you write ‘foo $ bar $ baz x’ you’re thinking in terms of shuffling values around and you can’t just take the x out and use that as a composed function.
05:08:44 <fosskers> ion: okay, yeah
05:08:48 <matthew-_> where is it defined that in do notation, if a bind fails, fail will be called?
05:09:07 <matthew-_> > (do { True <- return False; return True }) :: Maybe Bool
05:09:08 <lambdabot>   Nothing
05:09:22 <ion> In the Report i’d guess.
05:09:30 <hpc> @where report
05:09:30 <lambdabot> http://www.haskell.org/onlinereport/
05:10:26 <fosskers> thanks guys
05:13:52 <fosskers> i was really hoping haskell had something like python's pythonpath, where i could just stick my modules' source files and import them willy-nilly
05:14:46 <udoprog> fosskers: try ghci : ), would only recommend it for debugging/experimenting tho
05:15:18 <Zao> fosskers: When building with ghc, you can provide additional search paths with -i
05:15:21 <Zao> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/separate-compilation.html#search-path
05:16:19 <Peaker_> fosskers, Just cabalize them and "cabal install"
05:16:36 <fosskers> ive actually been doing all my work in ghci
05:16:47 <matthew-_> ion: not that I can find...
05:16:50 <fosskers> don't really know how to make a proper haskell program yet haha
05:16:54 <Zao> Peaker_: Sounds a bit overkill to pollute the system unless you have that crazy Galois private environment.
05:17:01 <udoprog> fosskers: then cabal ftw
05:17:03 <Zao> cabal-dev?
05:17:10 <Zao> Horrible with names.
05:17:16 <ezyang> "It's not crazy, it's meek and mild mannered"
05:17:21 <Peaker_> Zao, everyone rm -rf's their ~/.cabal once in a while anyway, don't they?
05:17:29 * dcoutts doesn't
05:17:38 * ezyang does 
05:17:43 * udoprog does
05:17:47 <dcoutts> sigh
05:17:49 * fryguybob doesn't
05:18:01 <Zao> dcoutts' .cabal is probably like my fridge. Lots of old and interesting stuff nesting in the corners.
05:18:10 <fosskers> oh, Zao, this is totally it
05:18:15 <dcoutts> I'm not saying you're doing it wrong, I just wish you didn't have to
05:18:15 <Peaker_> Lots of overly conservative version constraints get lots of redundant package versions installed forming a big mess
05:18:17 <fosskers> just gotta change the search path
05:18:19 <osfameron> what's in ~/.cabal ?
05:18:32 <hpc> osfameron: the universe
05:18:39 * parcs doesn't
05:18:42 * osfameron usually assumes .dirs created by installers are an implementation detail
05:18:48 * parcs consequently has a 3GB-large ~/.cabal
05:18:51 <osfameron> i.e. you shouldn't really have to be messing with them, ideally
05:18:55 <fosskers> but i want my stuff to be edittable on the fly, and doesn't caballing stop that?
05:18:59 <fosskers> or rather, id have to recabal
05:19:00 <Peaker_> I wish we had some false positives (read: GHC errors) sometimes, those are fixable easily (add a constraint) -- false negatives make a permanent mess
05:19:14 <hpc> osfameron: the dot-dirs are usually the ones you DO mess with
05:19:19 <Peaker_> dcoutts, messing up the ~/.cabal is another reason to prefer false positives to false negatives
05:19:20 <hpc> they hold config files and stuff
05:19:45 <osfameron> hpc: sure, for the basic config files.  But not for cache directories that you have to clear out cos they're full of cruft
05:20:02 <udoprog> yeah, but ghc and cabal has an interesting way of overlaying them on top of your system
05:20:03 <dcoutts> Peaker_: the solution is persistent package management, so you can't break things by installing new things, nix style.
05:20:37 <Peaker_> dcoutts, that would still form a mess -- having many copies of a package compiled against older/buggier versions, when just one would do
05:21:00 <udoprog> usually you fiddle with unregistering stuff one by one when something goes wrong, but it's very picky work; rm -rf ~/.ghc; rm -rf ~/.cabal; cabal install is faster
05:21:19 <dcoutts> Peaker_: well, you might call it messy, but it would mean you never break packages by installing new ones.
05:22:23 <Peaker_> dcoutts, choosing the false positives route would almost always mean that too (though it's orthogonal and probably a good idea anyway)
05:23:02 <dcoutts> Peaker_: right, I think they're pretty much orthogonal issues
05:23:09 <dcoutts> we want persistent package management anyway
05:23:47 <dcoutts> and then the issue about getting "good" solutions is a solver & feedback issue
05:23:55 <Peaker_> as long as we can't link in the same package multiple times in same version + diff version deps, or same package different versions, all in the same linkage -- false positives ought to be preferred
05:24:33 <dcoutts> if you want a policy of "use latest version of everything", then you want the solver to explain which package is pulling in an older version of something that you didn't want, so you can decide if you want to fix/hack that package, or override its constraints
05:25:13 <dcoutts> Peaker_: you can link multiple versions of a package, just not multiple instances of the same version
05:25:21 <Peaker_> not necessarily latest -- for example, I might want parsec 2 and not 3, but within that major version, I would want the latest minor
05:25:33 <dcoutts> Peaker_: right, but whatever policy it is you want
05:25:52 <dcoutts> which can be expressed with constraints/preferences
05:26:05 <Peaker_> having the strong(known) constraints as well as weak(conservative) constraints and then the ability to ignore the latter is our conclusion from last time, right?
05:29:27 <dcoutts> Peaker_: it's certainly an option, but it needs more info to specify known/conservative upper bounds
05:29:55 <dcoutts> Peaker_: it might be difficult to get package authors to specify that extra info
05:30:28 <Peaker_> maybe if the developer just gives the known version constraints, the weak ones can be gathered from the PVP?
05:34:15 <fosskers> guys, i need a hand
05:34:15 <Peaker_> actually weak/strong is not enough, need weak/positive/negative:   dep >= 1.2.1 && <= 1.3 (meaning: package was TESTED to work with dep in this version range),  dep <=! 3 (dep was tested NOT to work with version 3). and the weak constraint could be derived automatically from the former two and the PVP
05:34:33 <fosskers> someone hit me with the dumb stick and i can't figure out what this is trying to tell me
05:34:44 <fosskers> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/separate-compilation.html#search-path
05:34:59 <fosskers> particularly the part about -idirs
05:35:31 <hpc> Peaker_: "install the latest in the first range if you don't have it, but if you do have it, don't worry about it if it is in the second range"?
05:36:31 <hpc> (related, i would like to see cabal do away with having multiple versions of packages, and just say PARADOX when you try to install something that clashes)
05:37:11 <poltak> what are your opinions on best introductory/first-time language?
05:37:15 <dcoutts> hpc: :-)
05:39:10 <hpc> seriously though, how many bugs have come out of being able to have multiple package versions installed at a time?
05:40:40 <aristid> hpc: more than one
05:42:13 <hpc> :P
05:42:22 <poltak> why more than one?
05:43:20 <aristid> poltak: empirical.
05:46:38 <poltak> why?
06:07:55 <erus`> is there a build in func to get an elements position in a list?
06:08:09 <erus`> find_first_of type thing
06:09:54 <osfameron> aha!  A Lark is simply a bird that composes the Mockinbird with its input!
06:09:55 * osfameron 's brain dribbles out of his ears
06:10:01 <jeffz> erus`: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:11:44 <poltak> is there an IDE for haskell?
06:12:15 <osfameron> poltak: http://leksah.org/ ?
06:12:23 * osfameron hasn't used it
06:12:27 <jeffz> poltak: emacs, vim, eclipse, gedit... <insert your favorite editor>
06:12:34 <absentia> what would the IDE provide?
06:12:50 <scree> > listToMaybe . fmap fst . filter ((==2) . snd) . zip [0..] $ [8,37,2,45,89,2]
06:12:52 <lambdabot>   Just 2
06:12:59 <scree> erus`: ^^^
06:13:00 <osfameron> function stubbing?  interactive function compilation?
06:13:09 * osfameron imagines haskell-mode in emacs does some of these things
06:13:11 <absentia> oh. ok
06:13:13 <osfameron> but /me just uses vim
06:13:19 * absentia uses emacs.
06:13:32 <osfameron> absentia: ah cool - what does haskell-mode provide?
06:14:01 <scree> erus`: or elemIndex
06:14:17 <erus`> i used elemIndex in the end :)
06:14:36 * osfameron just uses 2 windows - vim in one, ghci in the other, of course
06:15:12 * scree recently discovered ConqueTerm in Vim and is very happy to have done so
06:15:22 * osfameron googles
06:15:33 <osfameron> eeek!
06:15:44 <erus`> @hoogle (Maybe a) -> a
06:15:44 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
06:15:44 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
06:15:44 <lambdabot> Data.Monoid First :: Maybe a -> First a
06:15:49 * osfameron hugs scree
06:16:09 <osfameron> that's since 2009!  I thought vim didn't support interactive terminal sessions
06:16:33 <scree> don't know -- there are others, but the other ones I tried didn't work
06:16:42 <scree> or at least not very well
06:16:49 <osfameron> heh
06:16:59 <osfameron> I'm occasionally jealous of the SLIME-like things emacs has
06:17:03 <scree> it does take a moment to get used to the fact that your terminal has vim key bindings
06:17:20 <osfameron> but then I realise I'd have to learn emacs keybindings and program eLisp, and the urge to switch fades
06:17:24 <scree> and remember not to type "vim" in your nested terminal, as that gets *very* confusing
06:17:40 <mauke> shell in vim in tmux in urxvt
06:17:48 <mauke> zomg hackable
06:18:02 <erus`> @hoogle Integer -> Int
06:18:02 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
06:18:02 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
06:18:02 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
06:18:07 <osfameron> tmux?
06:18:10 <osfameron> oh, screen-a-like?
06:22:21 <derdon> omg. I just wondered "To remove parens on the right side, one can use $. But what can I use to remove parens on the *left* side?"
06:22:25 <erus`> @hoogle Int -> Integer
06:22:26 <lambdabot> Prelude toEnum :: Enum a => Int -> a
06:22:26 <lambdabot> Data.Bits bit :: Bits a => Int -> a
06:22:26 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
06:22:28 <derdon> quite embarassing, yes
06:22:51 <ion> :t fromIntegral
06:22:52 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:23:35 <sipa> derdon: (a b c $ d e) == (a b c) (d e)
06:23:52 <derdon> sipa: I know.
06:23:57 <sipa> == a b c (d e)
06:24:03 <derdon> sipa: I know.
06:24:10 <sipa> so there is no need to remove parens on the left side
06:24:13 <derdon> sipa: I know.
06:24:16 <sipa> ok :D
06:24:17 <ion> :-D
06:24:50 <derdon> sometimes there are short moments where have stupid thoughts. that's it
06:25:45 <derdon> +you
06:34:40 <scree> derdon: so, there's a valid question regarding a (b c) (d e)
06:34:54 <scree> derdon: which you can't currently de-bracket
06:35:07 <derdon> only a bit
06:35:21 <derdon> a (b c) $ d e
06:35:38 <derdon> well, parens are not evil :)
06:35:42 <scree> derdon: there's a view that $ should be left associative, so you could write a $ b c $ d e to mean that, and use a . b c $ do for a  (b c (d e))
06:35:53 <scree> s/do/d e
06:35:54 <c_wraith> you can de-bracket anything with a let or where. :)
06:36:02 <sipa> http://xkcd.com/297/
06:36:13 <c_wraith> let x = b c ; y = d e in a x y
06:36:25 <derdon> c_wraith: but I want to write clean, readable code
06:36:46 <c_wraith> well, if those expressions were more complicated, and you had a good name for those values, sometimes that is more readable
06:37:01 <osfameron> scree: you could define another operator like $ but with the correct associativity to do that, presuambly?
06:37:07 <c_wraith> though I find where clauses to be more readable than let expressions, in general
06:37:23 <derdon> c_wraith: yeah, me too
06:37:25 <scree> osfameron: sure, or modify the Prelude yourself to avoid symbol clutter
06:37:43 <osfameron> scree: heh, wouldn't that cause some ambiguity somewhere?
06:37:59 * osfameron finds judicious parens more readable than $ in many cases anyway
06:38:00 <scree> osfameron: potentially if other people read your code
06:38:40 <osfameron> scree: oh, I guess you'd import Prelude hiding ($) and redefine it in another module?  So it wouldn't affect any existing code
06:39:10 <scree> osfameron: right, I sometimes use a MyPrelude anyway
06:40:16 <scree> osfameron: making this change in the prelude would obviously break a lot of code; though not *good* code as good code uses a . b c $ d e currently :P
06:40:55 <osfameron> hehe
06:44:05 <erus`> we love haskell!
06:47:40 <kartik> hi
06:47:47 <kartik> wht ru doing thr?
06:48:14 <derdon> learning how to spell and type
06:48:34 <mauke> s hrd
06:48:54 <osaunders> & i r stoopid
06:49:05 <erus`> im gonna upload all my messy 100 LOC games to the interwebs
06:49:06 <Wooga> how do i make my function non-lazy, 'strict' ?
06:49:15 <erus`> use seq
06:49:16 <kartik> I have a question ..in which language does haskell natively compiles to?
06:49:19 <Wooga> erus`: thanks
06:49:19 <ion> spiclly f ur kbrd dosnt hve al th kyz
06:49:46 <erus`> kartik x86 instructionset
06:49:47 <kartik> I have a question ..in which language does haskell natively compiles to?
06:49:51 <kartik> ok
06:49:53 <kartik> thanks !
06:49:54 <ion> Does it echo in here?
06:50:11 <kartik> so is Haskell machine dependent?
06:50:27 <ion> You can interpret it with pen and paper, too.
06:50:32 <mauke> haskell doesn't natively compile
06:50:37 <mauke> that's an implementation detail
06:50:44 <erus`> it uses LLVM so adding additional targets should not be impossible
06:51:32 <kartik> so hw haskell compiler knows which machine instruction to be placed for which Haskell instruction..
06:51:38 <kartik> could u give some idea
06:51:41 <c_wraith> Wooga: seq isn't the only way to make a function strict.  pattern-matching an argument makes the function strict in that argument.  also, depending on the level of strictness desired, seq/pattern matching might be insufficient
06:51:50 <mauke> kartik: what do you mean by "haskell instruction"?
06:51:58 <mauke> also, which haskell compiler?
06:52:13 <c_wraith> kartik: haskell isn't like C.  there isn't a simple mapping from language primitive to assembly
06:52:17 <kartik> like sort (10,23,34)
06:52:21 <kartik> ok
06:52:27 <kartik> then how does it work?
06:52:28 <mauke> that's not an instruction
06:52:42 <scree> kartik: so, ghc haskell compiles through a *lot* of intermediate languages, before eventually targeting something like C--, C or LLVM
06:52:44 <mauke> c_wraith: the best way to make a function strict is to replace its body by 'undefined'
06:53:04 <kartik> ok
06:53:07 <kartik> Thanks !
06:53:08 <c_wraith> mauke: that sometimes fails to maintain operational semantics
06:53:19 <osaunders> kartik: Haskell is just a language spec BTW. A lot of the answers you are getting from people about what “Haskell” compiles to are actually referring to what GHC does
06:53:36 <osaunders> But that’s not Haskell in the wider sense
06:54:15 <scree> kartik: though obviously those low-level targets still implement some kind of runtime, including a garbage collecter and so on
06:54:35 * scree talks to the air
06:55:27 <osaunders> Oh you said GHC, scree. I didn’t see that
06:56:24 <poltak> what are your opinions on best introductory/first-time language?
06:57:48 <osaunders> poltak: I like Pascal for that
06:58:43 <scree> C
06:58:50 <flosit> poltak: i like python as it is easy to step in and powerful enough to learn a lot of different methods and being useful for 'real world' applications
06:59:25 <erus`> i learned in BASIC
06:59:56 <osaunders> I don’t think C is a very good introductory language. There’s lot of things that can go wrong subtly
06:59:59 <flosit>  erus`: me too, that's why i would suggest python ;)
07:00:30 <aristid> you could do worse than choose python as a first language. obviously haskell is cool, too ;)
07:00:32 <osaunders> Also Python is far too useful. The nice thing about a language like Pascal is you can learn the basics with it and then you throw it away for something more serious
07:01:37 <flosit> osaunders: yes, but why not learning a language you do not have to throw away?
07:01:39 <sanjoyd> Scheme looks like a good introductory language; though I personally started with Java.
07:01:40 <magicman> Sadly, there's the people who learn the basics in a language, and then *don't* throw it away.
07:02:00 <magicman> (guilty as charged, I stuck with BASIC for *years*)
07:02:02 <companion_cube> scheme is nice
07:02:25 <sanjoyd> LOGO
07:02:30 <osaunders> There’s a significant advantage to learning how languages differ. Learning a relatively un-real-world-useful language like Pascal forces you to learn something different and makes you bilingual very quickly
07:02:34 <sanjoyd> (If you can call it a language).
07:02:40 <erus`> i learned BASIC with a package called 'DIV games studio' which treated every function like a new thread so i was really disappointed when I started using stuff like C and there was no concurrency
07:03:02 <osfameron> erus`: that sounds quite advanced for a basic
07:03:10 * osfameron still isn't *comfortable* with concurrency, really
07:03:44 <scree> So, I think one should learn at some point a language that approximates reasonably well what's going on on the hardware, so that when you use a high-level language you at least understand what the performance issues are all about
07:03:45 <osaunders> flosit: I suppose you could teach different styles inside Python or something but it wouldn’t be as affective as being forced to learn something completely new
07:03:50 * osfameron still quite likes VB (or at least VBScript, which actually has some more amusing language features) ;-)
07:04:16 <osaunders> scree: Assembly?
07:04:36 <scree> right, so I prefer C for this job as it's a real-world language in some sense
07:05:10 <flosit> yes, but i think it depends on who should learn the language. a student in university will learn a language for the language's sake (language design, implementation methods, etc); somebody else just might want to get things done
07:05:12 <scree> also, it has few enough features that it's relatively easy  for a beginner to grok
07:06:17 <scree> flosit: if someone's learning python to do something for which performance will never be an issue, then fair enough.  and that's not so uncommon these days.  but otherwise, I'd advise them to learn C first
07:06:38 <osfameron> C first?!
07:06:45 <scree> sure
07:06:50 <quicksilver> I think C is a terrible learning language because it (almost) fails to have data types.
07:07:02 <quicksilver> C structs are clumsy to use and as a result lots of C programmers barely use them.
07:07:09 <osfameron> I love C for the mental challenge, but it seems like a terrible first learning language
07:07:09 <poltak> is there much point in learning C if you already know Java?
07:07:18 <quicksilver> And higher data structures - although libraries exist - are hardly used.
07:07:28 <quicksilver> choosing the right data types and data structures is part of good programming.
07:07:34 <osfameron> if you're talking about adults, then a scripting language or an FP language would make much more sense
07:07:53 <osfameron> and to kids, Squeak or Logo, or Toontalk might make more sense than even those
07:08:17 <flosit> well, for somebody who wants to write good programs, with performance in mind, perhaps using different frameworks, etc I do not think, that the first language is that important after all.  in the end, the best programmer is the one, who has seen several different (kinds of) programming languages...
07:08:25 <osfameron> (though, personally, I found toontalk quite confusing ;-)
07:08:27 <osaunders> I learned C++ very early on and then returned to C having programming in scripting languages for years since. I can honesty say that I missed /absolutely masses/ of even quite fundamental things about C back when I was doing C++. From this experience I posit that C is much better language for a more mature programmer
07:08:31 <alexbagel> i thing learning C early is good because then when using higher-level language you are conscious that all these fancy features don't come for free
07:08:33 <frerich> poltak: One reason why it can make sense to learn C in addition to Java is that the team you (will) work in knows C but no Java.
07:08:55 <scree> quicksilver: I agree with those criticisms of C, and I wouldn't advise someone *only* to learn C, but I don't see those as good reasons not to use it as a beginner language
07:09:03 <osfameron> alexbagel: why is that necessarily important?
07:09:07 <poltak> frerich: but other than that?
07:09:10 <osfameron> I mean, you can learn benchmarking with any language
07:09:24 * osfameron does benchmarking in Perl when he needs to.  No need to know a low-level language.
07:09:53 <scree> osfameron: benchmarking is fairly useless unless you have some working knowledge of what under the hood looks like
07:09:56 <osaunders> Maybe there isn’t one perfect answer to this question
07:10:01 <frerich> poltak: Other than that, there is not much to learn if you know Assembly. C is really close to assembly, so it can be an eye opener if you know Java but no assembly. It can help with debugging odd stuff in 3rd party libraries you access via JNI or with JVM crashes.
07:10:08 <quicksilver> scree: well I think it's important for beginners to start learning about data types and structures early :)
07:10:25 <frerich> poltak: Other than that, there is not much to learn if you know Assembly. C is really close to assembly, so it can be an eye opener if you know Java but no assembly. It can help with debugging odd stuff in 3rd party libraries you access via JNI or with JVM crashes.
07:11:02 <osfameron> scree: is that really true?  You get more mileage out of caching, or reworking the algorithm, than out of bit-twiddling optimizations, in most cases.
07:11:06 <alexbagel> osfameron: not sure, but at least with C you learn how a computer thinks
07:11:22 <osfameron> and algorithm design can be taught (more easily, I think) in languages other than C
07:11:47 <scree> quicksilver: if they're eventually going to be working in a language with some feature -- such as good datatype support -- you want to understand that feature well.  But there are a lot of languages with a lot of features, whereas the machine doesn't change very much
07:11:51 * osfameron is possibly a bit defensive about C, having only really worked through about a 1/3 of K&R, and never used it in anger ;-)
07:12:03 <erus`> do any hot babes code in haskell?
07:12:23 <c_wraith> probably.  But you'll never meet one.
07:12:25 <osaunders> erus`: Only at night, on their own, in secret
07:12:25 <Axman6> I've taught my girlfriend a bit of haskell, so yes :P
07:12:27 <poltak> frerich: hmm interesting :) my only language is java (not counting sql, javascript etc), and i recently picked up a copy of "the C Programming Language" for free so I was wondering if it was worth it after Java or not
07:12:31 <ziman> my gf does :)
07:12:40 <ziman> a bit. :)
07:12:41 * Axman6 high fives ziman 
07:12:42 <alexbagel> erus`: i tried to teach haskell to my girlfriend but it didn't really take :(
07:12:49 <byorgey> alexbagel: in my opinion, knowing how the computer works is about as important to programming as knowing how a car works is to driving.
07:12:49 * ziman high fives Axman6 
07:13:06 * Axman6 also high fives alexbagel 
07:13:07 <erus`> alexbagel: can she use any other languages?
07:13:08 <byorgey> alexbagel: that is, it is only important if you want to be really really good at it in specialized circumstances.
07:13:16 <osfameron> byorgey: yeah.  THAT!
07:13:43 <frerich> poltak: I think C can give some useful insights about how your system works on a very low level, which can be very beneficial when debugging. So learning a bit of C if you know Java probably makes you a better programmer.
07:13:58 <alexbagel> byorgey: if you know a bit about how a car works you can get better mileage out of it
07:14:00 <scree> osfameron: I agree algorithms are important.  But, as an example, how long does it take Ruby beginners to wonder how their magic list type is actually implemented?
07:14:23 <byorgey> alexbagel: I agree.  But the point is that when learning how to drive you don't *start* by learning about engines.
07:14:29 <osfameron> scree: I have next to no idea how the Perl array/list or hash are implemente.
07:14:32 <alexbagel> scree: yeah, thats my point
07:14:36 <osfameron> scree: I have also nearly next to no interest
07:14:46 <poltak> frerich: well I might as well give the book a bit of a read after exams, as it does interest me quite a bit. Especially the os dev side of the language
07:14:51 <flosit> i would say it is not really about the language, but methods and design:   imperative (C, Pascal, even BASIC), functional (Scheme, Haskell), OOP (C++, Java, Python), low-level (C again, Assemble?), databases (SQL). i think a beginner doesnt have to know these languages by heart, but should have a fair overview over them
07:14:53 <osfameron> learning how they work might make me able to make patches to Perl core.  Wouldn't make me a better perl programmer
07:14:57 <scree> alexbagel: sorry, didn't read your point :)
07:15:26 <sordina> Is there a way to close a Control.Concurrent.Chan channel?
07:15:28 <scree> osfameron: but if you don't know even the performance guarantees -- even the algorithmic complexity -- how are you going to write efficient code?
07:15:44 <scree> osfameron: sorry, not suggesting *you* don't know those things.  just beginners :)
07:16:29 <osfameron> scree: hmmm.  I think with well-optimized mutable languages, we don't really have those problems.  Most operations are O(1).  Beginners don't need to worry about it.
07:16:35 <fryguybob> @quote telescopes
07:16:36 <lambdabot> Dijkstra says: Computer science is no more about computers than astronomy is about telescopes.
07:17:14 <osfameron> scree: for the builtin arrays and hashes, I mean.  You're very rarely going to find using one of those data-structures is the bottleneck.
07:17:20 <poltak> lambdabot: why not?
07:17:46 <flosit> lambdabot: dijkstra is still looking for the right way...
07:17:49 <alexbagel> scree: i'm not sure I had one :P just that it's important appreciating that all these magical language features don't come for free.
07:17:52 <scree> fryguybob: we're not talking about computer science.  We're taliking about programming :P
07:18:01 <fryguybob> :D
07:18:07 <djahandarie> flosit, in his grave?
07:18:15 <flosit> maybe
07:19:01 <fryguybob> scree: I would say that computer science is more important than programming.
07:19:34 <flosit> i would say computer science without programming is like astronomy without looking at the stars
07:20:11 <scree> osfameron: right, most of the time it's never an issue.  It's more the way of thinking I'm getting at.  If you're thinking, "there is some underlying data structure, I don't know how it works", then that's fine.  But beginners think, "a list is a magic thing built into the language, what would an implementation actually mean?", which is what I find bad
07:20:53 <osfameron> scree: and I think that's a perfectly valid attitude to take...
07:21:10 <osfameron> certainly for a first language.
07:21:13 <hpc> flosit: well, astronomy - stars = physics ;)
07:21:33 <hpc> CS - programming = math?
07:21:38 <flosit> not really, physicist look at the world all the time
07:22:11 <osfameron> a first programming language should allow the programmer to get cool stuff done, not be fighting with random syntax errors and limitations
07:22:19 <scree> osfameron: well, then it's a question of what order some long sequence of languages takes; if you can guarantee your learner will come back to C, fine.
07:22:29 <osfameron> nor indeed to be prematurely worrying about optimizing stuff
07:22:35 <poltak> hpc: but programming indirectly = maths, no?
07:22:51 <augur> aristid: you on?
07:23:05 <aristid> augur: yup
07:23:37 <scree> osfameron: I think it's easier to tell someone, you've been living in this hard restricted world for a while, now have some fun; than to say, you've been having fun for a while, now imprison yourself in C
07:24:05 <scree> osfameron: but that's a minor point
07:25:08 <flosit> scree: what about 'you had some fun, now make even greater apps with this high-performance approach...'
07:26:12 <augur> aristid: /msg!
07:26:49 <aristid> augur: i was talking about important topics in another chat! very important topics! :P
07:26:50 <c_wraith> the fact is, execution speed doesn't matter most of the time.  there are reasons why Ruby and Python are very popular and widely-used.
07:26:57 <augur> aristid: o ok
07:28:23 <scree> flosit: like I said, if you can persuade your programmer to learn C second, I'm not too concerned.  Some just may be hard to persuade, because C will seem horrible to them
07:30:03 <flosit> scree: yes, but as long as they do not need the performance, why bother? i think the first rule a programmer should learn is to pick the right tool for your problem. then he/she can decide on his language himself...
07:31:30 <scree> flosit: my point isn't just about raw speed.  it's about living in a world where you understand pretty much exactly what's going on, and are able to even reason about speed
07:32:46 <scree> flosit: and at some point in their life, a programmer who can't / doesn't think about efficiency is going to have to appeal to one who does / can
07:34:10 <scree> flosit: but ultimately I agree it depends on what the learner wants.  If they just want to be able to do loads of scripting in two weeks from now, don't teach them C
07:34:17 <flosit> scree: you are right. but will this programmer become a better programmer, if he is 'forced' to? if he doesn't want to have a look at C for himself - out of curiosity - he will gladly flee the course after it is finished and fall back to his own environment...
07:35:26 <osfameron> the kind of programmer that wants to become a good programmer will read stuff, discover that "You should know at least one of a) OO, b) functional c) low-level, d) logic, e) concurrent" and take the time to learn all of them
07:35:37 <scree> flosit: well, that depends how much control you have over their curriculum.  I'm saying, if you give me a child at a young enough age and I teach them C, they'll have the right outlook for life.  The same might not hold for someone who has prior experience
07:35:42 <osfameron> hmmm, I appear not to want to be a good programmer, by that metric ;-)
07:38:09 <scree> osfameron: you're right, there are lots of orders of doing things which all get you to the same place.  This is just my preferred one
07:38:10 <flosit> scree: yes. i guess, it - as always - is a matter of who you are talking about...  i learned a bit of C at the age of 14, and it got me interested in more...
07:39:31 <scree> flosit: agreed -- I did the same.  you're probably best to give someone a[D[D[D[D[D[D[D[D[D[D choice of options; but many pople would omit C from the list, which I think is wrong
07:40:06 <scree> oops -- s/{\[D}*//
07:40:50 <erus`> ah man some little cunt found the administrator account for all our servers. was fucking about with user accounts in active director
07:41:08 <DRMacIver> If only someone had created a site in which to compare what different languages were good for. :)
07:41:13 <poltak> erus`: WHO?
07:41:23 <poltak> this isn't like the sony thing is it?!
07:42:18 <osfameron> DRMacIver: which site?
07:42:44 <DRMacIver> osfameron: Sorry, that was a blatant and shameless plug for hammer principle. :) (http://therighttool.hammerprinciple.com/)
07:43:04 <osfameron> yay!
07:43:10 <osfameron> I remember seeing that link a while back
07:43:20 <osfameron> it asked a lot of questions, and I suspect I never got to the end of it
07:43:22 <osfameron> iirc
07:43:29 <DRMacIver> Yes, most people don't. That's by design
07:43:58 <DRMacIver> (the question order is randomised so that it works fine and all the questions get about the same number of answers)
07:45:27 <osfameron> heh, people really don't think Perl is good for beginners ;-)
07:45:59 <hpc> perl isn't good for experts lol
07:46:15 <DRMacIver> osfameron: Well there are an entire 5 languages ranked under it!
07:46:23 <DRMacIver> Admittedly those are assembler, cobol, C++, fortran and Elisp...
07:46:32 <osfameron> heh, indeed
07:46:46 <osfameron> it's funny, as I found it an *excellent* language as a mostly-beginner programmer
07:46:53 <osfameron> and it's very similar to Python...
07:46:54 <osfameron> but hey ho
07:47:08 <DRMacIver> I suspect perl suffers from a lot of people claiming to be familiar with it but really only being very passingly so
07:47:15 <osfameron> yeah
07:47:16 <DRMacIver> And most of those people dislike it a lot
07:47:19 <DRMacIver> So rank it badly
07:47:25 <frerich> DRMacIver: Your shameless plug worked, I didn't know that site but find it very entertaining :-)
07:47:27 <osfameron> yeah
07:47:35 <osfameron> oddly, http://therighttool.hammerprinciple.com/statements/libraries-in-this-language-tend-to-be-well-documen ranks Haskell above Perl
07:47:38 <osfameron> which is just wrong
07:47:45 <DRMacIver> Basically everything on hammer principle should be assumed to be biased and wrong :)
07:47:53 <DRMacIver> But it's surprisingly interesting despite that
07:47:57 <osfameron> DRMacIver: hehe, yes.  it's still an interesting experiment, thanks!
07:49:47 <DRMacIver> frerich: Alas shameless and blatant plugs usually do. that's why they continue. ;)
07:49:55 <DRMacIver> But thanks, glad you liked it.
07:55:20 <dreixel> how do I go from Int# back to Int?...
07:55:29 <quicksilver> wrap it in an I#
07:55:35 <dreixel> where is it defined?
07:55:37 <quicksilver> but if you have to ask that you probably shouldn't be using them :)
07:55:52 <quicksilver> I don't know.
07:55:57 <mauke> dreixel: where did you get the Int#?
07:56:02 <hpc> @src Int
07:56:02 <lambdabot> data Int = I# Int#
07:56:12 <dreixel> it doesn't seem to be exported from GHC.Prim
07:56:28 <dreixel> which is odd. I remember doing this before.
07:56:46 <erus`> some kid knew the password
07:56:49 <erus`> i have no idea how
07:57:03 <erus`> now we have to reset the local passwords on 100 pc's :'(
07:57:19 <dreixel> mauke: created it myself, it's a number-intensive part of the program, but I don't want to change the rest
07:58:33 <kosmikus> dreixel: GHC.Base, I think
07:59:03 <dreixel> kosmikus: ah, yes, thanks!
08:07:19 <balor> Is it possible to get hlint to output the source file with all it's suggested changes made?
08:07:25 <shapr> Anyone going to OSCON?
08:07:44 <shapr> I'm thinking of disorganizing a sekrit Haskell track for OSCON if I can get enough people.
08:08:38 <dixie> hmm. If I understand correctly part of the problem with dependencies and cabal is about wrong cabal files content written by author of package. Is there any guide how to do versioning & dependencies rights?
08:08:41 <dixie> rights=right
08:09:06 <dcoutts> dixie: there's the Package Versioning Policy which is a helpeful policy to follow
08:09:46 <dixie> dcoutts: great! I was looking for such a thing but I didn't know what term search for
08:19:18 <flosit> why is '[1,0] : [0,1] : [] == [[1,0],[0,1]]'   and not '[[1,0],[0,1],[]]' ?
08:19:33 <hpc> :t (:)
08:19:34 <lambdabot> forall a. a -> [a] -> [a]
08:20:17 <hpc> flosit: in x:y, x :: a, y :: [a]
08:20:33 <hpc> flosit: so in your example, [0,1] :: [Int], and [] :: [[Int]]
08:20:47 <hpc> > [1,0] : [0,1] : [] : []
08:20:48 <ekipan> >[1,0] : [0,1] : [] : []
08:20:48 <lambdabot>   [[1,0],[0,1],[]]
08:20:59 <flosit> ah, thanks
08:21:04 <hpc> in this example, the first [] :: [Int], and the second one :: [[Int]]
08:25:57 <erus`> > "T" : "om"
08:25:58 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:25:58 <lambdabot>         against inferred ty...
08:26:04 <erus`> > 'T' : "om"
08:26:04 <lambdabot>   "Tom"
08:26:27 <hpc> > let x = 1:x in x
08:26:28 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:26:31 <hpc> :D
08:26:34 <Wooga> which way to drop Nth element from list is best? like reverse-(!!), not extracting Nth element from list, but returning list without Nth elemnt
08:26:50 <Wooga> i think stright-forward will be usage of drop and take
08:26:57 <Wooga> but isn't there better way?
08:27:01 <c_wraith> @hoogle [a] -> Int -> [a]
08:27:02 <lambdabot> Prelude drop :: Int -> [a] -> [a]
08:27:02 <lambdabot> Prelude take :: Int -> [a] -> [a]
08:27:02 <lambdabot> Data.List drop :: Int -> [a] -> [a]
08:27:14 <c_wraith> heh.  too many functions with that signature
08:27:26 <c_wraith> :t delete
08:27:27 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
08:27:31 <c_wraith> :t deleteAt
08:27:32 <lambdabot> Not in scope: `deleteAt'
08:27:45 <c_wraith> guess there doesn't appear to be such a function.
08:27:55 <c_wraith> in the standard libs, anyway
08:28:03 <erus`> > deleteAt 1 "Tom"
08:28:04 <lambdabot>   Not in scope: `deleteAt'
08:28:09 <Wooga> okay, so take && drop the only way. thanks!
08:32:49 <ion> > uncurry (++) . second tail . splitAt 3 $ [0..9]
08:32:50 <lambdabot>   [0,1,2,4,5,6,7,8,9]
08:33:48 <ekipan> > uncurry (++) . second (drop 1) . splitAt 12 $ [0..9] -- if you'd prefer out of range to just do nothing
08:33:49 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
08:34:44 <aristid> > second (drop 1) . splitAt 12 $ [0..9]
08:34:45 <lambdabot>   ([0,1,2,3,4,5,6,7,8,9],[])
08:34:56 <Wooga> :t second
08:34:57 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
08:35:01 <Wooga> oh
08:35:04 <Wooga> something special
08:35:05 <shapr> hej beherit, god morgon!
08:35:19 <ion> > second (+1) (4,4)
08:35:20 <lambdabot>   (4,5)
08:35:21 <ekipan> a in this case is (->), functions
08:35:41 <ekipan> erm
08:35:51 <ekipan> right?
08:35:53 <ekipan> I confused myself
08:36:00 <ion> Yeah, that’s right.
08:36:06 <shapr> hyvää huomenta kaiki!
08:36:24 * shapr goes back to speaking Haskell
08:37:30 <aristid> shapr: is that finnish?
08:37:35 <ion> It is.
08:37:50 <aristid> today i learned that finnish is not a indo-european language
08:37:51 <shapr> aristid: Yah, that's about as much Finnish as I can speak.
08:38:05 <shapr> Yup, Finnish is in fact descended from total confusion!
08:38:13 <aristid> like hungarian.
08:38:40 <shapr> I wonder if Aarne Ranta ever put any Finnish translations into Haskell's Grammatical Framework?
08:39:11 <osaunders> Can anyone recommend a good XML combinator library?
08:39:20 <aristid> osaunders: maybe xml-enumerator?
08:39:21 <ion> s/kaiki/kaikki/ btw.
08:40:16 * osaunders looks
08:41:09 <osaunders> Sorry, I want to use combinator to generate XML not to parse it
08:41:13 <osaunders> *combinators
08:41:20 <shapr> ion: Thanks, I lived in Tornio for two years, but that wasn't enough to learn Finnish.
08:43:35 <aristid> osaunders: i think it has generator combinators too
08:44:14 <osaunders> aristid: Couldn’t see any in http://hackage.haskell.org/package/xml-enumerator
08:44:34 <aristid> osaunders: http://hackage.haskell.org/packages/archive/xml-enumerator/0.3.1/doc/html/Text-XML-Enumerator-Render.html
08:44:42 <aristid> literally one click :P
08:45:36 <osaunders> Nah that’s not what I want
08:47:26 <aristid> osaunders: well, xml-enumerator is very low-level
08:47:37 <osaunders> So that seem to use events and I want to construct trees
08:47:56 <osaunders> aristid: Yeah for high performance presumably
08:48:10 <aristid> osaunders: is this type good enough for you? http://hackage.haskell.org/packages/archive/xml-types/0.3/doc/html/Data-XML-Types.html#t:Document
08:48:46 <osaunders> I’m actually just looking at that now
08:48:50 <osaunders> Seems quite good
08:48:57 <hpc> aristid: xmlgen looks like something i would use
08:49:02 <aristid> osaunders: actually xml-enumerator does support that type
08:49:58 <osaunders> aristid: OK, so?
08:50:31 <aristid> osaunders: xml-types itself does not support converting types into an actual xml document (as bytes)
08:50:59 <osaunders> Ah
08:53:27 <osaunders> OK, thanks for the help aristid
09:02:27 <tg_> :t (..)
09:02:27 <dainanaki> Hey everyone, what would be the best way to efficiently store text that has frequent insertions and deletions at arbitrary points in the file. Oh, and it must for for UTF-8
09:02:27 <lambdabot> parse error on input `..'
09:02:39 <dainanaki> I meant to say, must work for UTF-8
09:02:40 <tg_> is the "range" expander a function? or a primitive?
09:02:45 <ekipan> primitive
09:03:03 <ekipan> builtin syntax, short for something in Enum I think
09:03:08 <byorgey> tg_: primitive, it desugars to calls to enumFrom, enumFromTo, or enumFromThenTo
09:03:11 <hpc> not even really a primitive; it's syntax sugar
09:03:19 <hpc> [x..y] = enumFromTo x y
09:03:24 <hpc> [x..] = enumFrom
09:03:24 <tg_> byorgey: thanks very much
09:03:27 <tg_> and hpc
09:03:30 <tg_> and ekipan ...
09:03:34 <ekipan> :t enumFromTo
09:03:34 * tg_ loves this channel
09:03:35 <lambdabot> forall a. (Enum a) => a -> a -> [a]
09:03:35 <hpc> [x,y..z] = enumFromThenTo x y z
09:03:37 <hpc> etc etc
09:03:51 <tg_> why doesn't it pick up the sugar from :t (..)?
09:04:07 <hpc> because :t only does functions
09:04:12 <hpc> :t (,) -- function
09:04:13 <lambdabot> forall a b. a -> b -> (a, b)
09:04:15 <tg_> expressions, you mean?
09:04:16 <hpc> :t do -- not function
09:04:17 <lambdabot> Empty 'do' construct
09:04:21 <ekipan> it's a syntax error
09:04:22 <hpc> er, yeah expression
09:04:48 <tg_> ok, makes sense, back to work
09:04:51 <byorgey> dainanaki: http://hackage.haskell.org/package/rope , perhaps?
09:05:04 <ekipan> is it always Prelude.enumFromTo btw, or the local enumFromTo?
09:05:49 <ekipan> > let enumFromTo x y = "blargh" in [1..3]
09:05:50 <lambdabot>   [1,2,3]
09:06:13 <byorgey> ekipan: good question.  I think it's always Prelude, but there's a new flag that may influence it
09:06:16 <dainanaki> byorgey, thanks.
09:06:37 <byorgey> RebindableSyntax or something like that
09:06:43 <hpc> byorgey: the same flag that works for do notation, i think
09:06:50 <alexbagel> is there a function that creates a list from a single element? like \x -> [x]
09:06:57 <ekipan> (:[])
09:07:02 <hpc> alexbagel: return or pure, too
09:07:06 <ekipan> it's the monkeyface function
09:07:08 <hpc> > pure 1 :: [Int]
09:07:09 <lambdabot>   [1]
09:07:12 <alexbagel> oh, neato
09:07:39 <tg_> ekipan: I take it that you didn't get [blargh] means the Prelude version won out?
09:07:55 <ekipan> would assume so
09:07:59 <ekipan> unless I missed something
09:08:20 <byorgey> ekipan, tg_: indeed.
09:08:51 <tg_> byorgey: by the way, is it completely impossible to add-in some syntactic sugar that allows you to work with strings without their quotes, like: [testing]
09:09:37 <HugoDaniel> does the "init" function run in O(1) ?
09:09:52 <byorgey> tg_: yes, that sounds impossible.
09:10:02 <ekipan> @src init
09:10:03 <lambdabot> init [x]    = []
09:10:03 <lambdabot> init (x:xs) = x : init xs
09:10:03 <lambdabot> init []     = undefined
09:10:04 <zygoloid> HugoDaniel: in what sense?
09:10:13 <HugoDaniel> ah k
09:10:14 <byorgey> HugoDaniel: no, fully evaluating its result takes O(n).
09:10:32 <zygoloid> fully evaluating any list is O(n), though, whether you apply init first or not :)
09:11:09 <c_wraith> init is different from tail, though.  tail adds on O(1) operation.  init adds an O(n) operation.
09:11:19 <tg_> byorgey: I guess I could do it ouside the language entirely, ie, setup a parser that takes [charcharchar] and always produces ['c','h',...] before feeding it to haskell
09:11:40 * zygoloid has never seen a convincing definition of what big-O notation means for a lazy language
09:11:46 <c_wraith> tg_: if you want it that much, write a quasiquoter?  I can't imagine that'll be better than just using quotes...
09:11:50 <byorgey> zygoloid: I guess what I mean is that if you have a list which is already fully evaluated, and then apply init, fully evaluating it will take an additional O(n).
09:12:17 <byorgey> zygoloid: but I agree re: difficulty of defining big O notation for a lazy language.
09:12:20 <HugoDaniel> yeah, ammortized time should be de default
09:12:50 <tg_> c_wraith: well, there is some motivation for doing this - I will be working with strings that use letters to numbers of a fixed (but large) base... so all lists [abcdefg] will be chunkable, but the chunking will depend on the contents of the string
09:13:01 <tg_> c_wraith: but thanks for the ref re: quasiquoter
09:15:31 <zygoloid> byorgey: :) my big take-away from okasaki's book was 'laziness plus asymptotics is a complex beast'
09:15:49 <zygoloid> (also 'this guy is a genuis' and 'these data structures are cool')
09:16:18 <byorgey> zygoloid: yes, I got those takeaways too =)
09:16:18 <tg_> byorgey: what are you studying these days?
09:16:20 <dainanaki> I'm looking at the rope package on hackage and it has a module called Data.Rope.Annotated. What exactly does it mean by annotation, and why would it be useful?
09:16:36 <luite> hmm, I guess that the definition of big-O isn't really the problem, but more that you usually want additional detail
09:17:12 <byorgey> tg_: dependent types, generic programming, embedded domain-specific languages, miscellaneous other stuff
09:17:41 <luite> are you still doing stuffs with species?
09:18:15 <byorgey> luite: I haven't been doing much with them recently, but hope to get back to it at some point
09:18:59 <byorgey> dainanaki: I think by "annotation" it means arbitrary monoidal value attached to elements.  It's useful because the combination of all the annotations can be efficiently cached.
09:19:16 <byorgey> dainanaki: for example if you wanted to give each element a "cost" and then have the total cost automatically cached
09:19:43 <byorgey> dainanaki: but if you want to know for sure you should ask edwardk
09:19:44 <HugoDaniel> hey
09:19:57 <luite> byorgey: I did read your introduction some time ago, very readable :) but I haven't been able to find a use for species so far in my own work
09:21:03 <dainanaki> Are GHC's Chars UTF-8 or just one-byte chars?
09:21:13 <tg_> byorgey: do you know about Ken Ono's work on the partition function?
09:21:39 <aristid> dainanaki: neither.
09:21:45 <aristid> dainanaki: they are Unicode code points
09:21:55 <byorgey> tg_: no, I don't, tell me more.
09:22:20 <tg_> byorgey: oh, he discovered a closed form for the partition formula
09:22:22 <dainanaki> aristid, I'm not super familiar with text formatting. What's the difference between being UTF-8 and being a Unicode code point?
09:22:45 <tg_> byorgey: and hence proved that all congruences on the integers are of the form l^2/24 or l/12
09:23:03 <ekipan> @google bare minimum unicode
09:23:04 <lambdabot> http://www.joelonsoftware.com/articles/Unicode.html
09:23:04 <lambdabot> Title: The Absolute Minimum Every Software Developer Absolutely, Positively Must Know A ...
09:23:11 <byorgey> tg_: cool, I'll have to look that up
09:23:29 <tg_> byorgey: I'm interested in taking the result further, and relating it to exponential structures
09:23:37 <aristid> dainanaki: the unicode code point is just a number.
09:23:46 <tg_> and infinite product structures, and division algebras
09:23:46 <aristid> dainanaki: utf-8 is when it's encoded as bytes
09:23:53 <aristid> dainanaki: but Char is _not_ a byte
09:23:54 <byorgey> tg_: neat
09:24:11 <tg_> byorgey: ed #haskell
09:24:16 <tg_> grr
09:24:22 <tg_> byorgey: http://www.mathcs.emory.edu/~ono/publications-cv/selected-publications.shtml
09:25:11 <tg_> byorgey: there's also a nice 3-page version
09:25:11 <tg_> lol
09:25:48 <byorgey> tg_: cool, thanks for the link
09:26:40 <tg_> byorgey: anyway, the partitions of the integers (as he shows in the paper I'm trying to find) are realted to the Eisenstein numbers e^2pi/3
09:27:27 <tg_> byorgey: here's the shortest paper http://www.aimath.org/news/partition/brunier-ono
09:27:32 <byorgey> tg_: oh! someone else linked me to this paper a while ago, I hadn't read it yet
09:27:44 <tg_> byorgey: read the short one first
09:27:50 <byorgey> ok, I will, thanks
09:28:01 <luite> hmm, I must have the long one somewhere, where's the short one?
09:28:09 <tg_> luite: just pisted it
09:28:14 <tg_> http://www.aimath.org/news/partition/brunier-ono
09:28:18 <lispy> hello
09:28:50 <tg_> byorgey: anyway, I think a slightly more interesting result gotten when you shift the values of the partition function by some number...
09:29:12 <luite> tg_: ah right
09:29:40 <tg_> byorgey: that is, when you say that (0,1,2,or 3) have more partitions then they normally have
09:31:29 <tg_> byorgey: anyway, I had never heard of 'species' before, and it seemed related because of your introduction post
09:31:34 <tg_> since the partition function was the 'interesting' case
09:31:57 <osaunders> Any idea how I go about fixing this build dependency problem: http://hpaste.org/46624/multiple_versions_of_the_same ?
09:34:35 <dainanaki> Wow, Unicode is weird.
09:35:13 <osaunders> Why is Unicode weird?
09:36:13 <luite> ǝƃɐnƃuɐן spɹıǝʍ ǝpoɔıun
09:36:30 <dainanaki> Just all the business with big endian/little endian, UTF-8, UCS-2, UTF-16, UTF-7, UCS-4
09:36:54 <lispy> dainanaki: technically those ane encodings not unicode itself
09:37:32 <dainanaki> Agreed, but they go hand in hand for anyone trying to write code that's internationalizable.
09:38:09 <lispy> yeah...unicode discussions always come up on the darcs list
09:38:41 <lispy> I encourage people to use utf-8 whenever possible
09:39:59 <aristid> utf-8 is the sanest encoding IMHO
09:40:04 <osfameron> yeah.  if we've lost the ascii-is-the-one-true-encoding war, then at least please let us have utf-8 ;-)
09:40:30 <aristid> UTF-16 was a nice idea back when 16 bits were enough for all codepoints
09:40:32 <osaunders> osfameron: Who’s we?
09:40:47 <dafis> aristid:  UTF-32 is pretty sane too
09:41:01 <osfameron> osaunders: oh, ascii holdouts
09:41:28 <aristid> dafis: for some purposes
09:41:53 <aristid> dafis: but because utf-8 always uses 4 bytes or less, it always requires more space. and there's the endianness problem
09:42:02 <dafis> aristid:  I'd say it's sane for all purposes, it's just not the best choice for many
09:42:11 <ekipan> 6 bytes*, isn't it?
09:42:32 <aristid> ekipan: i thought the 21 million or so unicode codepoints fit in 4 bytes?
09:42:37 <dafis> ekipan:  no, four's max for utf-8
09:43:16 <dafis> aristid:  so far, there are just 1.something million code points
09:43:24 <dafis> > maxBound :: Char
09:43:25 <lambdabot>   '\1114111'
09:43:41 <lispy> > ord (maxBound :: Char)
09:43:42 <lambdabot>   1114111
09:43:46 <aristid> dafis: isn't the theoretical limit 21 million tho?
09:43:55 <aristid> > ord maxBound
09:43:56 <lambdabot>   1114111
09:44:10 <aristid> lispy: may the type inference be with you
09:44:21 <lispy> true
09:44:24 <dafis> aristid:  theoretical limit for utf-8? dunno
09:44:34 <aristid> dafis: no, for unicode
09:44:43 <ekipan> a code point encoded in utf-8 can take up to 6 bytes
09:45:40 <dafis> aristid:  Why would there even be a limit for unicode? One could make arbitrarily many codepoints, couldn't one? (just needs more bits for encoding)
09:46:09 <ekipan> I think unicode is defined a ranging over U+0 to U+10FFFF
09:46:19 <ekipan> > '\x10ffff'
09:46:20 <lambdabot>   '\1114111'
09:46:32 <ekipan> defined as*
09:46:49 <monochrom> it is useful to set a limit. every version can set a different limit.
09:47:01 <dainanaki> is there some way to clear the values told to a writer monad?
09:47:10 <aristid> ekipan: '\1114111' needs less than 6 bytes, doesn't it?
09:47:12 <dainanaki> or would that just be state monad + mappend
09:47:25 <ekipan> not when encoded as utf-8
09:47:54 <ekipan> or wait
09:47:57 <ekipan> perhaps I am wrong
09:48:11 <dafis> ekipan:  21 bits, four bytes suffice
09:48:26 <ekipan> I was looking at the Joel article
09:48:31 * hackagebot gamma 0.7.0.1 - Gamma function and related functions.  http://hackage.haskell.org/package/gamma-0.7.0.1 (JamesCook)
09:49:13 <ekipan> pardon me then
09:54:22 <ekipan> @keal
09:54:23 <lambdabot> tomorrow i share next mathematical secrety
09:54:37 * lispy gasps at lambdabot 
09:57:04 <djahandarie> Weird
09:57:15 <djahandarie> Has anyone had issues with libgmp.so.10 not existing in any distro package?
09:57:36 <lispy> djahandarie: nope.  What distro are you using?
09:57:37 <djahandarie> Trying to run a static GHC-built binary and it insists on that, which seems to only be found in GHC itself
09:57:42 <lispy> ah
09:57:48 <lispy> static can be tricky
09:58:05 <lispy> djahandarie: The last time I wanted to build something statically I had to pass some options to ld
09:58:06 <djahandarie> That seems to be the only missing library
09:58:50 <djahandarie> Some people online trying to run xmonad apparently solved it by symlinking to another version of libgmp, but that sounds really damn ugly
09:59:03 <djahandarie> Should GHC really be linking to something that is impossible to get without GHC?
10:00:54 <lispy> djahandarie: libgmp is LGPL
10:01:12 <lispy> so there is a non-technical reason behind this
10:01:19 <djahandarie> Yeah. But the .10 version seems to be custom to GHC.
10:01:27 <djahandarie> All distros I find seem to be .3
10:01:34 <dafis> djahandarie:  I had that when I had ghc built with openSuSE 11.4, then wiped that from my disk (wouldn't boot after a couple of days) and reinstalled openSuSe 11.3
10:02:31 <dainanaki> Wasn't there an effort to remove/provide an alternative to libgmp for GHC?
10:03:21 <dafis> dainanaki:  yes, and there's integer-simple if you don't want gmp, just if you want something performant, there's no alternative yet
10:03:42 <djahandarie> It depends on libgmp whether you use Integer or not
10:04:19 <dafis> djahandarie:  not if you build ghc with INTEGER_LIBRARY=integer-simple, afaik
10:04:24 <djahandarie> Ah
10:04:45 <dons> ?bug
10:04:45 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:04:52 <djahandarie> Well, just symlinking to .3 seems to fix the problem. It'd be nice if there was some other solution
10:04:58 <djahandarie> dons, I should file a bug report?
10:05:26 <dainanaki> Does xmonad actually use Integers much?
10:05:44 <dainanaki> Or is it simply a runtime dependency?
10:06:17 <djahandarie> The RTS itself doesn't have the libgmp dependency afaik
10:06:33 <djahandarie> But it seems to get pulled in whenever you actually compile something (anything at all, even main = return ())
10:10:20 <dons> since base depends on Integer
10:10:20 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
10:12:20 <djahandarie> Ah. I think it'd be just fine and dandy if it wasn't for this libgmp.so.10 version. All Google results for that just point to people having problems with GHC-built static binaries
10:14:58 <dafis> djahandarie:  maybe everything else just asks for libgmp.so and is happy with whatever that links to, but ghc bakes in the version it used
10:16:11 <djahandarie> Yeah, GHC seems to ask for specific versions for all the libraries. I dunno how important it is or if it is configurable or not though
10:17:27 <osaunders> Is this article well known in the community? http://cdsmith.wordpress.com/2011/01/16/haskells-own-dll-hell/
10:17:52 <dafis> osaunders:  reasonably well known
10:18:07 <djahandarie> Yeah, I've read it
10:19:13 <osaunders> Do people agree with it?
10:19:19 <osaunders> This seems like a really serious problem
10:20:28 <dafis> osaunders:  yes, it seems so, however, I've not yet run into that problem
10:20:53 <dainanaki> osaunders, cabal-dev helps mitigate the issue in many cases
10:21:32 <osaunders> Ah
10:21:35 <osaunders> This sounds cool
10:22:13 <osfameron> ah, that's like mk_environment (Python) or local::lib (Perl) ?
10:23:37 <dainanaki> similar, yes. it doesn't solve all dependency problems, but it can help.
10:23:48 <osfameron> hmm, it's not called mk_environment, something like that anyway
10:35:57 <Wooga> what message 'source: <<loop>>' for executable named 'source' mean ?
10:36:56 <dafis> Wooga:  that ghc detected nontermination
10:37:12 <c_wraith> Wooga: you wrote one of the cases of infinite loop GHC is able to detect.
10:37:17 <dafis> something like foo = foo
10:37:24 <Wooga> hmm
10:38:21 <Wooga> it comes here: http://paste.pocoo.org/show/387657/ at line 35; where i am trying to use 'contents' variable. why?
10:42:10 <dafis> Wooga:  I suspect line 23, let (isExit,contents,message) = parser contents (truncateLine cmd)
10:42:54 <Wooga> dafis: you're right. thank you!
10:43:00 <Peaker> Are you using -Wall?
10:43:04 <Peaker> you should be warned of shadowing there
10:43:56 <dafis> Peaker:  some people explicitly turn off warning about shadowing
10:44:07 <Wooga> Peaker: tried to add -Wall to ghc --make source.hs commandline, and i've  no special output :P
10:44:29 <dafis> Wooga:  did it recompile at all?
10:44:47 <Peaker> dafis, yeah.. I think there should be some way to mark recursive bindings, like "let rec" in OCaml.. especially if shadowing is allowed
10:44:47 <dafis> ghc -fforce-recomp -Wall source
10:45:03 <Peaker> dafis, Wooga: Though in this case, even if shadowing is allowed, you should get a warning about the arg being unused
10:45:10 <Wooga> oh really, after deleting *.hi and *.o filesm, it gave plently of output
10:45:12 <Wooga> thanks!
10:45:18 <dafis> Peaker:  we mark recursive bindings simply by 'let' :)
10:45:25 <Peaker> dafis, yeah, that sucks :-)
10:45:44 <dafis> Peaker:  I like it
10:46:06 <ccasin> Peaker: since all top-level bindings in the file are mutually recursive, the problem is a little harder
10:47:17 <ccasin> though of course there is plenty of room to complain about this choice itself, if one wants to
10:48:12 <Peaker> dafis, Haskell's position on the convenience-safety tradeoff is definitely leaning on safety, and so I think it should be consistent in that choice or it somewhat defeats the purpose
10:48:44 <Peaker> dafis, Haskell has rid my programs of almost all bugs I was used to accidentally making -- and one of the most frequent bugs I had left -- was accidentally creating recursions such as the one Wooga had
10:49:32 <Peaker> dafis, general recursion is a side-effect, should be marked as such
10:49:43 <Peaker> preferrably in the type, but if not possible at least in the binding/value
10:49:48 <dafis> Peaker:  never happened to me, but then I avoid name-shadowing
10:49:52 <hpc> Peaker: has it rid you of the habit of making the bugs in other languages?
10:49:55 <Tomsik> Don't you have an occurs check built-in in that brain of yours? :p
10:50:03 <hpc> it has yet to work for me :P
10:50:05 <Peaker> dafis, It wasn't actually due to shadowing, just had name and name'
10:50:25 <dafis> Peaker:  and typo'ed?
10:50:26 <Tomsik> I _never_ had a bug like this, I wonder if I'm the only one
10:50:29 <Peaker> dafis, yeah
10:50:48 <dafis> Tomsik:  no, you're not the only one
10:50:50 <Peaker> Tomsik, no typo between var and var' causing infinite loops?
10:50:55 <Tomsik> nope
10:51:10 <Tomsik> I don't use ticks a lot in names though
10:51:12 <dafis> Peaker:  that's something I don't either
10:51:14 <Peaker> hell it can even be a larger typo given completions
10:51:17 <hpc> typo causing compile error?
10:51:35 <Peaker> Anyway, in Haskell land, why prefer convenience over safety?
10:51:38 <Tomsik> oh, I don't use completions, maybe that's why
10:51:45 <hpc> i get that every time i use '
10:52:18 <Tomsik> Peaker: I would imagine that it might be difficult to check what is recursive and what is not given non-strict evaluation
10:52:33 <hpc> > x = let x = 5 in x
10:52:34 <lambdabot>   <no location info>: parse error on input `='
10:52:38 <Tomsik> With for example tying the knot
10:52:50 <hpc> > let x = let x = 5 in x
10:52:51 <lambdabot>   not an expression: `let x = let x = 5 in x'
10:52:55 <hpc> > let x = let x = 5 in x in x
10:52:55 <lambdabot>   5
10:53:05 <ccasin> Peaker: most functional languages make lots of choices to promote convenience over safety (for example, allowing general recursion at all, allowing failing pattern matches, including unsafePerformIO), so the argument has to be a little more subtle than that
10:53:15 <Peaker> Tomsik, I'm not referring to detecting recursion in general (e.g: in combinators we use) but to detecting recursive bindings -- which is a syntactic thing and easily detectable
10:53:38 <hpc> ccasin: perhaps consistency?
10:53:40 <Peaker> ccasin, I don't think those are convenience over safety, those are power over safety
10:53:58 <hpc> those features dont muck with other features much
10:54:02 <Peaker> ccasin, except "failing pattern matches", which indeed I think is a bad thing to allow
10:54:19 <Peaker> (Require _ -> error "..."  at the very least)
10:54:35 <Peaker> ccasin, without unsafePerformIO there are just things you will not be able to do
10:54:41 <Peaker> (purely)
10:54:50 <hpc> i would like error :: String -> IO a too
10:54:59 <hpc> instead of just a
10:55:01 <Peaker> hpc, fail has that type
10:55:08 <Peaker> (well, for any monad, unfortunately)
10:55:08 <Tomsik> :t let blah = (let x = blah in x)
10:55:09 <lambdabot> <no location info>:
10:55:09 <lambdabot>     not an expression: `let blah = (let x = blah in x)'
10:55:13 <Tomsik> :t let blah = (let x = blah in x) in blah
10:55:14 <lambdabot> forall t. t
10:55:28 <hpc> Peaker: i mean to stop pure exceptions from being so common
10:55:28 <Tomsik> Which let should be recursive here?
10:56:11 <scree> hpc: I think that's also restrictive
10:56:11 <monochrom> oh god you love knots so much you tie a knot in a knot
10:56:15 <Peaker> @type fail
10:56:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
10:56:30 <scree> hpc: there are legitimate times in pure code where a branch cannot possibly happen
10:56:58 <hpc> scree: then they can take the effort to unsafeperform the error
10:57:08 <hpc> or make total functions
10:57:20 <Peaker> Tomsik, in a corecursion, possibly any of the lets is good, all lets sounds like it might break modularity
10:57:57 <Peaker> you can often restructure code such that the partial case disappears
10:58:23 <scree> hpc: I don't see why unsafePerformIO (error "Foo") is any better than error "Foo".  You can replace "error" with "unsafeError" if you want; it still should be scary enough
10:58:57 <scree> Peaker: sure, and I agree that error is overused when total functions are preferable; but it's still a legitimate thing to want to do on some occasions
10:59:01 <dafis> cannotHappenUnlessCoderScrewedUpBadlyError "Foo"
10:59:10 <hpc> scree: clearly it isn't scary enough yet
10:59:25 <scree> hpc: agreed, but that's a cultural thing.
10:59:40 <hpc> and error shadows line numbers, so you cannot see where it comes from
11:00:09 <scree> hpc: if so many standard libraries didn't contain partial functions, other coders would use them a lot less I think
11:00:18 <Peaker> scree, Ideally we could strengthen the type system to make that case less common. I wonder what the DT camp in Agda/Coq do
11:00:40 <monochrom> Coq makes you prove termination and totality
11:00:41 <jmcarthur> agda has a flag that allows you to turn off the termination checker for a file
11:01:16 <monochrom> but of course, it has enough tools to help you prove "head ('x':"yz")" total
11:01:22 <Peaker> scree, btw: when it can happen, I would like it if instead of error and fromJust and partial functions all over the std libs, everything in the stdlibs returned Maybe, and there was an unsafeUnjust "Explanation of why I am sure this is not a Nothing" value
11:01:27 <Saizan> in Coq/Agda you can enforce arbitrary preconditions
11:01:42 <Peaker> monochrom, what if you cannot find a way to prove it to the compiler, but you are certain of it?
11:01:54 <Peaker> is there an escape hatch like error/fromJust?
11:02:06 <monochrom> Coq is Gödel-complete. if you are certain, there is a proof
11:02:10 <scree> Peaker: i would like that too.  Then at least you think before discarding corner cases
11:02:28 <Peaker> monochrom, ideally.. maybe the proof is deferred to later, because it's big, and you're in a hurry :-)
11:02:44 <monochrom> then I don't know of one
11:02:47 <scree> so, i've wondered: does the converse hold?  i.e. if I can prove f :: a -> Maybe b never returns Nothing, can I define an f' :: a -> b ?
11:02:52 <scree> (in Coq, this is)
11:02:57 <Saizan> Axiom/postulate :)
11:03:20 <monochrom> I know a meta-escape hatch. consult an expert
11:03:26 <Saizan> scree: yes
11:03:32 <scree> and by prove, I mean write a Coq proof
11:04:13 <scree> actually, I've phrased that badly.  what I meant was, given an explicit Coq proof and an explicit Coq function, can I do the above explicitly in Coq?
11:04:22 <Saizan> yes
11:04:35 <ccasin> scree: exercise: do it :)
11:04:38 <ccasin> it's not so hard
11:05:10 <scree> heh. :)  what this is really demonstrating is, I don't know Coq that well
11:05:18 <scree> but good to know
11:05:55 <ccasin> more fun to do in agda anyway
11:06:04 <ccasin> in coq you'd probably have to muck about with the ugly pattern matching
11:06:41 * hackagebot aeson 0.3.2.6 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.3.2.6 (BryanOSullivan)
11:23:12 <Wooga> Hello, while reading LYAH's I/O chapter I've got an idea of writing own implementation of TODO-list managing program, not as real application, but just as another excercise. Here it is: http://paste.pocoo.org/show/387683/ . May i ask you to criticize it, tell me what can be improved and what was a bad idea to use?
11:23:53 <Wooga> i've tried to keep it pure as much as possible, but not sure if i did everything well
11:24:29 <mrsolo> Wooga, omg, super function! :-)
11:24:47 <Wooga> mrsolo: better to split it into pieces?
11:24:58 <Axman6> yes, write much smaller functions if you can
11:25:01 <dafis> Wooga:  you should learn about mapM_
11:25:08 <dafis> :t mapM_
11:25:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
11:25:27 <mrsolo> Wooga, yes spirit of functional programming  smaller funtions that does simple things
11:25:37 <dafis> Wooga:  your destMap is `mapM_ something'
11:26:35 <dafis> where something ("-",out) = putStr out >> hFlush stdout; something (file,stuff) = writeFile file stuff
11:26:38 <Axman6> mapM_ f xs where f ("-",out) = putStrLn out; f (file, out) = writeFile file out
11:26:55 <Wooga> oh, thank you!
11:27:13 <Axman6> Wooga: I'd use putStrLn, it avoids the need for the hFlush
11:27:43 <Axman6> changes behaviour, but it shouldn't be a huge problem...
11:27:45 <Wooga> Axman6: i was thinked about using PS2-such things, like '> input your line: '
11:28:01 <Axman6> ah
11:28:25 <Axman6> well in that case, you could change the buffering on stdout to NoBuffering and also avoid the need for hFlush
11:28:55 <Wooga> hmmm, if it is better, then why hFlush exists?
11:29:23 <djahandarie> Usually when you don't want to flush automatically at all
11:29:28 <dafis> Wooga:  it's not better per se
11:29:34 <Axman6> because sometimes there's an appropriate time to use hFlush
11:29:39 <Axman6> this isn't one of them
11:29:51 <Wooga> ah, okay, thanks for pointing
11:30:46 <mkscrg> ok
11:30:50 <mkscrg> I feel really silly
11:31:03 <mkscrg> But maybe someone can tell why this won't compile: http://hpaste.org/46626/bytestring_sillyness
11:31:41 <dschoepe> mkscrg: because your bytestring is named b
11:31:47 <dschoepe> as well as the b bound by let
11:32:01 <dschoepe> so it assumes the b on the right-hand side is the one on the left-hand side
11:32:10 <mkscrg> Goddamnit.
11:32:28 <mkscrg> That silly feeling was justified...
11:38:44 <buntfalke> Hi
11:39:01 <buntfalke> Does the Haskell report define Haskell has to be lazy?
11:39:14 <monochrom> no, just non-strict outside IO
11:39:19 <roconnor> not to my knowledge
11:39:35 <roconnor> monochrom: isn't IO non-strict too?
11:40:54 <buntfalke> How about implicitly defining it to be such, by asking that, for instance, a function computing all binomial coefficients must return, if just one coefficient is selected from the list with !!?
11:41:05 <dafis> roconnor:  yes
11:41:07 <monochrom> since we don't have a denotational story for IO or I/O anyway, the haskell report goes ahead to talk about order of actions in IO
11:41:32 <zenzike> I think I've just configured irssi + screen to alert xmobar when someone says one of my hilight words. I'd like to test that. could someone, er, say may name please?
11:41:43 <Peaker> IO return/bind seems to be non-strict on the result of the IO computation
11:42:10 <monochrom> "Actions, however, must be ordered in a well-defined manner for program execution – and I/O in particular – to be meaningful. Haskell’s I/O monad provides the user with a way to specify the sequential chaining of actions, and an implementation is obliged to preserve this order."
11:42:18 <albel727> zenzike:
11:42:35 <Peaker> except for interleaveIO -- bah
11:42:37 <monochrom> it goes operational-semantics so you can't say "strict" or "non-strict"
11:42:54 <zenzike> albel727: thanks :-)
11:43:03 <albel727> did it work? )
11:43:04 <Peaker> return undefined >>= const (putStrLn "hi")   -- outputs hi
11:43:20 <zenzike> albel727: nope :-(
11:43:27 <albel727> pity (
11:43:31 <zenzike> or if it did, I didn't notice!
11:43:38 <Peaker> the IO part of (IO a) is used strictly by bind, the "a" part is only used as strictly as the bound function uses it
11:43:45 <albel727> zenzike: we can try again
11:43:53 <dafis> zenzike:  now?
11:44:08 <zenzike> nope. thanks for trying though!
11:45:07 <joe6> is there a haskell function similar to unwords, but uses ", " instead of just spaces?
11:45:35 <monochrom> intercalate
11:45:49 <joe6> > intercalate
11:45:50 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [[a]] -> [a])
11:45:50 <lambdabot>    arising fr...
11:46:03 <Peaker> > intercalate ", " ["hello", "world!"]
11:46:04 <lambdabot>   "hello, world!"
11:46:09 <dafis> > intercalate ", " ["some","words"]
11:46:10 <lambdabot>   "some, words"
11:46:37 <joe6> monochrom, perfect. thanks.
11:46:39 <monochrom> > intercalate "coma" ["####$", "&^%#$"]
11:46:40 <lambdabot>   "####$coma&^%#$"
11:47:11 <joe6> Peaker: dafis: thanks.
11:48:13 <djahandarie> joe6, you should flip through the Prelude sometime, it's good to have all the functions in there memorized
11:49:09 <napping> monochrom: I think that just says the IO effects have to be performed in order
11:50:01 <napping> There was a paper or two on "lenient evaluation" for Haskell
11:52:23 <monochrom> intercalate is not in the Prelude
11:53:39 <djahandarie> Oh, good point, that's in Data.List
11:53:47 <djahandarie> Should be in the Prelude :p
11:54:36 <safiire> I am getting link errors with ghc 7.0.3 and xcode4 on osx snow leopard...
11:54:37 <safiire> ld: warning: could not create compact unwind for .LFB3: non-standard register 5 being saved in prolog
11:55:00 <safiire> I just got the newer haskell platform to try to fix the older xcode4 bug, and I have this error now.
11:55:17 <safiire> Does anyone know how to get around this one, my web search has not been fruitfull.
11:55:50 <napping> Do you read haskell-cafe? There was something about OS X build problems, but I didn't read it because I don't run it.
11:55:57 <safiire> Yes i did.
11:56:43 <safiire> There is an older xcode4 bug, and now this is a new one that I have not seen before.  I have not been able to compile anything on osx in a while.
11:56:44 <napping> Then I guess there need to be more messages on haskell-cafe about build failures with xcode :)
11:56:53 <safiire> Yeah.
11:57:00 <Axman6> safiire: those aren’t errors
11:57:09 <Axman6> they're just warnings
11:57:12 <safiire> Well it is a linker warning?
11:57:18 <Axman6> yes
11:57:25 <safiire> oh it actually has compiled.
11:57:29 <safiire> Silly me.
11:58:08 <safiire> Thank you for pointing that out.
11:58:18 <napping> Does it run?
11:58:27 <safiire> Yes.
12:01:03 <napping> Great. Might be worth asking about the warning on glasgow-haskell-users or something
12:12:17 <Wooga> hello again, i have splitted my TODO-list managing program into many functions: http://paste.pocoo.org/show/387714/
12:12:31 <Wooga> and used mapM_ as well
12:12:43 <Wooga> any other ways to improve it?
12:14:38 <pacak> nummarize = zipWith (\i x -> show i ++ ": " ++ x) [1..]
12:14:54 <Wooga> thanks!
12:15:10 <ekipan> I'd give the lambda a simple name
12:15:13 <ekipan> like numberLine
12:15:27 <ekipan> nummarize = zipWith numberLine [1..]
12:19:55 * hackagebot HDBC-mysql 0.6.4.1 - MySQL driver for HDBC  http://hackage.haskell.org/package/HDBC-mysql-0.6.4.1 (BryanOSullivan)
12:21:27 <ekipan> any reason you're passing usage down from main to parse to usage instead of just putting it there?
12:21:45 <ekipan> doesn't look like it varies
12:25:17 <scooty-puff> is there a naming convention for type synonyms in type families?
12:25:17 <ekipan> deleteAt i xs = a ++ drop 1 b where (a, b) = splitAt i xs
12:25:35 <ekipan> ... is what I'd like to say, but it looks like your deleteAt is 1-based instead of 0-based
12:26:51 <scooty-puff> i.e. for class LDC s m where type LDCValue s; ldc :: LDCValue s -> m xs (Cons s xs) (Label m)
12:27:15 <pacak> Wooga: And it will probably be good idea to use Data.Map instead of list. At least for large TODO lists.
12:28:10 <ion> > curry (++) . second (drop 1) . splitAt 0 $ "blah"
12:28:11 <lambdabot>   Overlapping instances for GHC.Show.Show
12:28:11 <lambdabot>                              (b
12:28:11 <lambdabot>    ...
12:28:28 <ion> > uncurry (++) . second (drop 1) . splitAt 0 $ "blah"
12:28:30 <lambdabot>   "lah"
12:28:46 <ion> That’s 0-based at least.
12:31:11 <ekipan> instead of using pairs with a sentinal "-" for messages, I'd use my own datatype
12:31:55 <ekipan> data Action = Message String | Write FilePath String
12:32:23 <Mononofu> as a functional language, why doesn't haskell automatically cache the return value of a function for given arguments?
12:32:46 <Mononofu> or is there some way to enable this? (aside from manual implementation)
12:32:59 <monochrom> because there may be too many to cache
12:33:11 <ekipan> because RAM is finite?
12:33:16 <napping> :(
12:33:17 <ekipan> at least at the moment
12:33:30 <Mononofu> yeah, but it could flush it if it runs out
12:33:43 <Mononofu> or just add some keyword to the function
12:33:50 <monochrom> when you finally have 1000 cores, perhaps you may prefer re-computing to memoizing.
12:33:52 <Mononofu> so I take that as a no?
12:34:05 <monochrom> right
12:34:05 <Twey> Mononofu: Because in practice it tends to result in poorer performance
12:34:09 <napping> There are some libraries. Haskell doesn't by default
12:34:18 <Mononofu> ok, thank you
12:34:19 <Twey> You can use libraries to explictly cache, yeah.
12:34:57 <napping> data-memocombinators
12:35:11 <napping> MemoTrie, uglymemo on hackage
12:35:23 <monochrom> http://groups.google.com/group/comp.lang.haskell/msg/2b3bc2d6bed0c808
12:35:25 <Mononofu> ok, thank you very much :)
12:35:30 <napping> If you are looking for languages that automatically memoize, you could try XSB prolog
12:36:27 <Mononofu> nah, I like haskell, it's just that I wrongly assumed it would memoize. must have confused it with some other language
12:36:55 <Mononofu> I have to say though that this is one of the most helpful IRC channels I've been to recently :)
12:37:02 <maurer_> Mononofu: While it would be legal for an implementation of haskell to memoize, nothing in the language requires it, and it might not be a great idea :P
12:37:27 <ekipan> I still don't fully understand it, Wooga, but is the Bool just used as a sentinal to signal quitting?  In that case you could add Quit as another value of the Action type
12:38:47 <ion> Also, values bound to variables aren’t recomputed as long as the name is in scope AFAIU.
12:39:10 <maurer_> ion: They aren't, but I don't think that's a required thing, just a thing which happens to happen?
12:39:31 <Peaker> monochrom, even if recomputing is cheap throughput-wise, you still pay with latency
12:40:00 <Peaker> Also, memo table may be smaller than original closure reachables
12:40:20 <monochrom> memory also has latency
12:40:47 <Peaker> monochrom, usually the computation will need access to memory too
12:40:59 <Peaker> (instead of accessing the memo table, you access the original input)
12:43:27 <Mononofu> still, data-memocombinators was exactly what I was looking for. Thanks again :)
12:44:22 <vince> leave #clojure
12:44:29 <ion> ok
12:44:34 <vince> leave #haskel
12:44:44 <monochrom> here is an example. the fibonacci sequence and the prime number table are already memoized all over the web to a large extent. but you would still re-compute them locally rather than fetching from the cloud
12:45:40 <Mononofu> yes, but memoizing greatly speeds up the naive implementation of the fibonacci sequence
12:46:22 <byorgey> tg_: this paper is way over my head =P
12:46:29 <Twey> It's a closely-guarded secret we don't usually let newbies in on, but the naïve implementation of the Fibonacci sequence is not actually all that representative of programming ;)
12:46:50 <Mononofu> haha, I wasn't claiming that it was
12:47:36 <Mononofu> it's just that I like to write code similar to the mathematical definition - easy to understand and beautiful ;)
12:48:23 <Twey> Yeah, well… some day we will have a language that lets you do that and have it be efficient, too
12:48:31 <Twey> But not yet, sadly :)
12:49:41 <monochrom> "memoizing greatly speeds up" is based on the fragile assumption that memory is fast enough. that is my point. your own ram chip is of course fast enough. for now.
12:49:42 <Peaker> monochrom, Large primes? I'd rather fetch them from the web.. that's how I solved some of google's riddles way back when..
12:50:24 <Peaker> monochrom, RAM is part of both memoization and computations, for many types of both
12:50:25 <monochrom> but you prefer to re-compute small primes yourself
12:50:51 <Twey> That said, it would be nice to have a memoising construct built in.
12:51:25 <djahandarie> Not sure what you're talking about here, but in Haskell memoizing is pretty damn easy with packages like MemoTrie :)
12:51:31 <Peaker> yeah, memoization isn't the solution to the world's problems :)
12:51:44 <Peaker> djahandarie, it's very far from optimal though
12:51:52 <Peaker> (in operational terms)
12:52:08 <djahandarie> Yeah, that wouldn't surprise me
12:52:19 <djahandarie> I really like the elegance of it though
12:52:20 <napping> You could try uglymemo
12:52:26 <Peaker> augustuss wrote a blog post about ugly memoization+unsafePerformIO doing better than the nice memos
12:52:36 <napping> and then released the uglymemo package
12:53:34 <djahandarie> I wonder if anyone has actually tried to optimize MemoTrie
12:54:12 <Peaker> uglymemo could be implemented in terms of mutable hash tables for better results, probably.. there's no reason for that structure to be persistent
12:54:55 <Peaker> Haskell shuns away hash tables, but they are actually quite useful
12:55:06 <Peaker> when you don't need persistency (which is often)
12:56:02 * hackagebot certificate 0.9.0.1 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.9.0.1 (VincentHanquez)
12:56:23 <monochrom> and when your key doesn't have an easy Ord but has an easy Hash
12:56:38 <Peaker> Hash and Eq, yeah
12:57:56 <Peaker> I think often you want to build a big lookup table once, and then perform many lookups -- and then it is better to build a hash table than a Map or such -- because lookup complexity trumps insertion/deletion/etc.  Yet you see Haskell code using Map even then.. it would even be nice to use Kukoo hashing for that
12:58:05 <monochrom> for the most part I believe that calculating a hash value is slower than doing several <='s, but still.
12:58:52 <djahandarie> I think a really great package for Haskell that is extremely underutilized is judy
12:58:53 <Peaker> why? A hash value can generally just take the LSBs of whatever data you have, and be good enough, and then you have a single (==) compare, instead of multiple (<=) looking at full values
12:59:12 <Peaker> djahandarie, I tried looking at once, it seemed to require typeclasses instead of simple hash functions?
12:59:18 <Peaker> I remember being puzzled about how to use it
12:59:51 <monochrom> Most <='s just look at the LSB and that already settles them.
12:59:53 <monochrom> err
12:59:58 <monochrom> Most <='s just look at the MSBs and that already settles them.
13:00:25 <djahandarie> Peaker, does it? I haven't done anything complicated with it, just some of the basic stuff like the example it has in the docs
13:00:33 <Peaker> Typeclasses are over used for the wrong purposes in Haskell (magical APIs that guess what you mean), and underused for the right purposes (e.g: length, ByteString, etc)
13:00:35 <monochrom> extreme example: keys are strings or bytestrings, 2000 characters or bytes each.
13:02:13 <dafis> if they have a 1950 character/byte common prefix, hash probably wins
13:02:41 <dafis> but of course they won't unless you specifically arrange it so
13:03:02 <monochrom> current hashtable implementation is slow, it's just poor implementation and somewhat unknown cause, this is why many people have refuged to Map, that's all
13:03:47 <Peaker> monochrom, maybe an expanding hash can be used -- small hash always computed, larger hashes computed upon collisions.. not sure if such a scheme would work
13:04:09 <Peaker> monochrom, though the Map case will pay O(string length) too to (==) on the key eventually, like the hash computation
13:04:21 <djahandarie> Peaker, how is ad-hoc polymorphism a bad use for typeclasses? It's what they are! :)
13:04:42 <Peaker> djahandarie, see the regexp API
13:04:55 <Peaker> djahandarie, or Judy :-)
13:06:08 <djahandarie> I guess I don't know what you mean by "magical APIs that guess what you mean". Isn't a major benifit of programming with types is that you can make the compiler 'guess' what you mean?
13:06:36 <dainanaki> Hey folks, how can I detect 'meta' keystrokes such as ctrl, alt, etc. with code that runs on the command line?
13:07:11 <Peaker> djahandarie, magical API is a derogatory term for an API that does something simple in a non-straightforward way
13:07:29 <djahandarie> Ah
13:07:39 <Peaker> djahandarie, instead of a simple:  Regexp.search :: RegExp -> String -> [Matches],  you have a myriad of typeclasses
13:07:47 <Peaker> s/Matches/Match
13:21:58 <dschoepe> Peaker: Would you rather have a myriad of different functions for the individual results you might want from a regexp-search result? (Or having to decompose the most detailed result by hand all the time)
13:24:28 <Peaker> dschoepe, I would want a simple Regexp.Match list
13:24:36 <sm> in the case of regexps, I think there should be an obvious Text.Regex.Simple , something like regexpr
13:24:37 <Peaker> dschoepe, what individual results do you mean?
13:25:38 <dschoepe> Peaker: I meant the possible result types that are currently offered via type classes
13:26:39 <Peaker> dschoepe, I'd just have functions like: groups :: Match -> [String]
13:26:51 <Peaker> dschoepe, see the Python regexp library as an example, the Haskell one could be like it and it'd be great
13:28:38 <dschoepe> hmm, I guess I might be overestimating the convenience offered by those "magical APIs"
13:29:48 <napping> You might get pretty far in efficiency with rewrite rules turning things like null . match r into more specialized functions
13:33:34 <coderaskel> hello?
13:34:22 <napping> Hello
13:34:44 <coderaskel> how do you like haskell?
13:34:49 <coderaskel> first time messing with it for me
13:34:51 <napping> It's pretty nice
13:35:23 <coderaskel> favorite feature?
13:36:41 <sm> speedy executables
13:36:41 <c_wraith> the way you can get performance *and* high abstraction at the same time.  definitely.
13:36:52 <DevHC> lol
13:36:55 <coderaskel> speedy executables?
13:37:01 <coderaskel> compared to what?
13:37:04 <c_wraith> ...  Though you do need to know a bit about the execution model to get high performance. :)
13:37:13 <coderaskel> c or ruby
13:37:16 <sm> other languages that are pleasant to program in
13:37:29 <sm> what c_wraith said
13:37:43 <dafis> sm: C can be speedy too
13:37:59 <c_wraith> C can be very fast.  You just often pay for it in programmer time :)
13:38:09 <coderaskel> true
13:38:11 <monochrom> though you need to know a bit about the execution model to get high performance. for c.
13:38:13 <Peaker> c_wraith, and some pain
13:38:53 <coderaskel> im walking through the try haskell right now
13:39:00 <coderaskel> cool stuff
13:39:48 <napping> Much faster than things like Python or Ruby. Usually within small constants of C with some effort on microbenchmarks
13:40:25 <fenmanm> hi
13:40:31 <dafis> ho
13:40:37 <fenmanm> do libClang work with ghc 6?
13:40:42 <fenmanm> or only ghc 7
13:42:15 * sm likes that ghc executables not only run fast, but start up fast
13:45:39 <gwern> @wn continence
13:45:40 <lambdabot> *** "continence" wn "WordNet (r) 2.0"
13:45:40 <lambdabot> continence
13:45:40 <lambdabot>      n 1: the exercise of self constraint in sexual matters [syn: {continency}]
13:45:40 <lambdabot>      2: voluntary control over urinary and fecal discharge
13:45:51 <shachaf> @wn confluence
13:45:52 <lambdabot> *** "confluence" wn "WordNet (r) 2.0"
13:45:52 <lambdabot> confluence
13:45:52 <lambdabot>      n 1: a place where things merge or flow together (especially
13:45:52 <lambdabot>           rivers); "Pittsburgh is located at the confluence of the
13:45:52 <lambdabot>           Allegheny and Monongahela rivers" [syn: {meeting}]
13:45:54 <lambdabot>      2: a flowing together [syn: {conflux}, {merging}]
13:45:56 <lambdabot>      3: a coming together of people [syn: {concourse}]
13:52:11 <Wooga> x+
14:06:50 <wkh>  /join #c
14:31:33 <fizruk> hi all! can someone help me to solve one problem with llvm package?
14:39:13 <danharaj> Does anyone have a favorite way of building trees?
14:39:23 <danharaj> I'm looking for various pleasing ways of making the syntax.
14:41:16 <Twey> Data.Tree?
14:42:34 <osaunders> OK, back to basics: how does a compiler work?
14:42:59 <osaunders> (Back to basics for me that is, this isn’t in reference to any previous or current conversation.)
14:43:26 <osaunders> A compiler parsers the source code and then what
14:43:33 <osaunders> *parses
14:44:22 <danharaj> a simplification is that it parses some code in whatever language into an expression tree, and then unparses that code into the target language.
14:44:27 <shachaf> osaunders: Then it generates output.
14:44:39 <danharaj> A compiler is a translator.
14:44:42 <shachaf> Is asking #haskell really the best way to find out about this sort of thing? :-)
14:45:01 <danharaj> of course it is
14:45:05 <osaunders> Well I’m asking in reference to Haskell
14:45:08 <danharaj> building compilers in Haskell is easy and fun
14:45:20 <osaunders> I feel like I want to understand what GHC actually does better
14:45:24 <shachaf> danharaj: Sure. Which is why people have written a bunch of things about it.
14:45:56 <osaunders> So source code is parsed into an expression tree
14:46:16 <danharaj> @where
14:46:16 <lambdabot>  @where <key>, return element associated with key
14:46:22 <danharaj> I wonder what the key for this is
14:46:31 <danharaj> http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
14:46:48 <danharaj> @where tapl
14:46:48 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
14:46:57 <ekipan> @list where
14:46:57 <lambdabot> where provides: where url what where+
14:47:02 <ekipan> @help where+
14:47:02 <lambdabot> where+ <key> <elem>. Define an association
14:47:19 <flosit> hi, i defined a datatype 'SimpleMatrix', which i want to be an instance of Num, like this:
14:47:19 <flosit> instance Num a => Num (SimpleMatrix a) where
14:47:19 <flosit>       (*) = matrixProduct
14:47:19 <flosit>       ...
14:47:20 <osaunders> OK, more specific question: how is a binary constructed?
14:47:21 <danharaj> My recommendation: do the scheme in 48 tutorial to get an idea of how it works for yourself
14:47:35 <danharaj> then acquire TAPL and read it to learn about the language Haskell is based on
14:47:46 <flosit> but, i want to define the product depending on scalar * matrix or matrix * matrix
14:47:48 <danharaj> If you can do the exercises and code projects in TAPL, you pretty much know how GHC works.
14:47:56 <osaunders> danharaj: I think I already understand most of what will be in that scheme thingy
14:48:04 <danharaj> osaunders: fair enough.
14:48:14 <flosit> can i define it in two ways, depending on the types of the variables?
14:48:51 <danharaj> flosit: You can't define (*) that way because it's already defined.
14:48:53 <danharaj> :t (*)
14:48:54 <lambdabot> forall a. (Num a) => a -> a -> a
14:49:10 <flosit> strange, it worked for me...
14:49:12 <danharaj> You should define a new operator for scalar multiplication. I use *^ but people might hate me.
14:49:24 <shachaf> danharaj: Why can't you define (*) that way?
14:49:25 <ion> flosit: The type of (*) doesn’t allow the parameters to be of different types. But you might be able to make number literals behave as matrices by defining fromIntegral, fromRational for SimpleMatrix.
14:49:36 <danharaj> shachaf: Because it would conflict with (*) in the prelude.
14:49:39 <shachaf> Oh, for different types. Yes.
14:49:53 <shachaf> danharaj: I thought that was part of the definition of a Num instance?
14:50:26 <danharaj> shachaf: You have to give a definition for (*) in an instance, but (*) is defined as "look at the instance and use that function"
14:51:36 <shachaf> danharaj: I missed the fact that it was for different types.
14:51:54 <danharaj> shachaf: ah ok.
14:53:10 <ozataman> is there a way to get ghci to load shared libraries without .dylibs? Ex: on OS X there is a libmygcc.a but no libmygcc.dylib
14:56:53 <danharaj> "Supporting pattern matching across different data instances would require a form of extensible case construct." - GHC on a limitation of top-level data families.
14:57:03 <danharaj> We totally should get an extensible case construct.
15:03:32 <jmcarthur> danharaj: what's the use case?
15:04:43 <jmcarthur> danharaj: if there is a known set of instances to pattern match on then you could just use a ADT or GADT, of course
15:05:39 <danharaj> jmcarthur: scene graphs. I want to make building them as easy as possible.
15:09:33 <jmcarthur> danharaj: heh, that doesn't help me figure out what you're doing at all :P
15:11:13 <jmcarthur> does anybody know of a model for lists? streams are just N->a, but lists are not just N -> Maybe a
15:11:59 <danharaj> jmcarthur: Each node in the tree is either a leaf, which is an ElementArrayBuffer to be drawn, or a node that contains a command to set some shader state, like the VertexBuffer to get vertices from, or setting a sampler to some texture.
15:12:37 <danharaj> (and a list of child nodes)
15:13:05 <danharaj> It is intended that identical children node get shared so it's a DAG.
15:13:20 <jmcarthur> sounds nice so far, yes
15:13:46 <danharaj> jmcarthur: So I want to make a really nice EDSL of some sort for actually building these graphs easily.
15:14:37 <jmcarthur> where does pattern matching on data instances come in?
15:14:44 <danharaj> hm?
15:15:21 <jmcarthur> lol, maybe we're talking past each other
15:15:31 <danharaj> let me hpaste some code
15:17:51 <danharaj> http://hpaste.org/46629/blahblahblah
15:18:18 <danharaj> I can't really get concrete because I'm still in preliminary "figure out what the damn types are" phase, but I hope this is enough context to my thoughts.
15:18:39 <danharaj> ach, I made a mistake
15:18:50 <jmcarthur> just something to note, your Leaf constructor is redundant
15:19:04 <danharaj> yeah
15:19:45 <jmcarthur> you could use Data.Tree instead
15:19:59 <danharaj> Yeah I know.
15:20:06 <jmcarthur> just making sure
15:20:26 <danharaj> But building the tree, I don't think it should be done by filling in the constructors by hand.
15:21:36 <jmcarthur> is your intent just to make this process more convenient while still exposing how the implementation works, or is it to offer a high level interface with a precise semantics?
15:22:00 <danharaj> jmcarthur: high level interface, so I can mangle the fuck out of the actual representation if I want to.
15:22:50 <jmcarthur> do you have any idea yet what kind of semantics you want?
15:22:56 <danharaj> what do you mean?
15:23:29 <pastorn> danharaj: that's the spirit!
15:23:31 <jmcarthur> say somebody writes some code using your library. how would you describe what their code means (distinct from how it works)?
15:23:59 <pastorn> jmcarthur: what if there is no real meaning?
15:24:14 <pastorn> what if it only has side effects?
15:24:16 <danharaj> jmcarthur: Their code generates a tree representing what is to be rendered that frame. I have a render function that traverses depth first, left to right, pushing and popping state, drawing leaves.
15:24:20 <jmcarthur> pastorn: that's why i asked what kind of interface he wanted earlier
15:25:08 <jmcarthur> danharaj: okay, then that sounds like you are wanting to expose the "tree"ness in the interface then?
15:25:22 <danharaj> yes.
15:25:51 <jmcarthur> okay, that can be the start of the semantic model then. we have a tree of somethings.
15:26:07 <danharaj> I gave you the somethings.
15:26:14 <jmcarthur> danharaj: what is the meaning of those somethings?
15:26:20 <aristid> this might be a bit of a stupid question... functions are always boxed, right?
15:26:37 <jmcarthur> aristid: i'm not really sure how to even interpret whether a function is boxed or not :)
15:26:54 <aristid> jmcarthur: functions are values too. how are they represented? :)
15:27:09 <jmcarthur> code + closure?
15:27:12 <danharaj> jmcarthur: For example: (AttributeNode PositionA someData) means "Set the attribute variable PositionA to the buffer someData".
15:27:18 <jmcarthur> i presume the closures are probably boxed
15:27:20 <lispy> aristid: thunks!
15:27:47 <aristid> f x = if x then id else (+1). how is f False represented? :)
15:27:51 <danharaj> I missed some nodes. There is a mode corresponding to "Set the program to this program".
15:27:57 <jmcarthur> danharaj: ah, then there is some notion of state in your model
15:28:18 <jmcarthur> danharaj: so how would you describe the state's meaning?
15:28:43 <danharaj> Also, the example SState I gave you should have at least one "SState ShaderProgram ()" and one "SState Elements ()" constructor.
15:28:43 <danharaj> jmcarthur: The tree represents a call graph to OpenGL, pretty much.
15:29:23 <danharaj> Except for transformation nodes. Those correspond to things like multiplying matrices to get the proper ModelView matrix.
15:29:29 <jmcarthur> it sounds as though your interface is implementation driven, but that doesn't mean we can't be precise about what it means anyway. if we manage to do so then the interface will probably just fall right out
15:30:07 <jmcarthur> danharaj: if you were going to model these nodes in the tree as state functions (s -> s), now we just need to explain what s is
15:30:58 <danharaj> nodes in the tree are IO ().
15:30:58 <danharaj> The state is OpenGL.
15:30:58 <jmcarthur> eek, IO doesn't have a very well defined model
15:30:59 <jmcarthur> opengl might be a little easier though
15:31:22 <flosit> hi, i try to define a new typeclass like this:
15:31:22 <flosit> class (Num a) => Matrix a where
15:31:22 <flosit>         inverse :: a -> a
15:31:22 <flosit> instantiating via
15:31:22 <flosit> instance Num a => Matrix (SimpleMatrix a) where
15:31:22 <flosit>         (+) = matrixSum
15:31:22 <flosit> tells me: No member "+" in class "Matrix".   shouldnt it be inherited from Num via the syntax above?
15:31:36 <jmcarthur> flosit: please use hpaste.org if you have more than a couple lines, in the future
15:31:42 <flosit> oh, sorry
15:31:46 <jmcarthur> np
15:31:53 <danharaj> flosit: you mean instance Num (SimpleMatrix a)?
15:32:03 <danharaj> and you got it backwards :p
15:32:18 <danharaj> The left hand side of => is the instances you already have.
15:32:23 <danharaj> the right hand side is the instance you are defining.
15:32:54 <jmcarthur> danharaj: well, let's just pretend opengl state is abstract for now, although giving it a well-defined model might be helpful
15:33:09 <jmcarthur> you have something like Tree (OpenGL -> OpenGL) then
15:33:42 <danharaj> Are you still alive?
15:33:45 <jmcarthur> yes
15:33:53 <jmcarthur> freaking netsplits
15:34:16 <jmcarthur> okay, so here's what this makes me think of
15:35:05 <jmcarthur> Trees are basically ways to describe compositions of monoids, and OpenGL -> OpenGL is a monoid formed by id and (.), therefore this whole thing is probably pretty convenient as a monoid
15:36:26 <jmcarthur> rose trees don't reflect that quite as perfectly as binary trees, but maybe the same principle could apply. lists are free monoids, after all
15:37:06 <danharaj> I have an idea
15:37:09 <jmcarthur> in fact, the Tree part of this model probably can just disappear
15:37:16 <jmcarthur> the model could just be OpenGL->OpenGL
15:37:46 <danharaj> The tree part is essential
15:37:51 <jmcarthur> to the implementation
15:37:53 <danharaj> It tells you which state changes are shared by which render paths.
15:38:05 <danharaj> You want to be able to run transformations on the tree.
15:38:10 <jmcarthur> ah so then you need to expose that sharing in the interface? that's tougher
15:38:35 <danharaj> I was hoping on relying on implicit sharing and not having to worry about observable sharing.
15:38:53 <jmcarthur> what are the nature of these tree transformations?
15:38:55 <flosit> danharaj: well 'a' should be a numeral. i thought   Num a => would define a kind of precondition?
15:39:13 <danharaj> flosit: you are correct, so you want Num a on the left side.
15:39:27 <danharaj> flosit: and you want Num (SimpleMatrix a) on the right hand side
15:39:32 <danharaj> Because that's the instance you want to define right?
15:40:10 <danharaj> jmcarthur: Pruning the tree and reordering the leaves to take into account blending, for example.
15:40:32 <jmcarthur> manually? or is this an optimization in the library?
15:40:34 <flosit> danharaj: i want (SimpleMatrix a) to be an instance of Matrix, which is a typeclass inheriting from Num
15:40:36 <tolkad> What's it called when code in a programming language is readable by other code?
15:41:01 <shachaf> tolkad: Code that's readable by other code?
15:41:40 <tolkad> Like, code in a language is also data in that language
15:41:56 <tolkad> There's a name for it, I just can't remember it
15:42:01 <danharaj> flosit: Ok, so your instance is for Matrix. (+) is not a member of Matrix. It's a member of Num. Why are you trying to define (+)?
15:42:08 <jmcarthur> "code is data"?
15:42:20 <danharaj> It's called lisp :p
15:42:33 <danharaj> seriously though, homoiconic
15:42:54 <tolkad> Thank you. No wonder I couldn't remember it
15:43:20 <danharaj> jmcarthur: Probably both. Being able to define your own transformations.
15:43:37 <danharaj> Anywho, the name of the game I think, is merging trees in a controlled manner.
15:43:49 <jmcarthur> okay, then the data representation is very important i guess
15:44:00 <danharaj> For example, let's say I have two objects I want to render. If they were the only objects I wanted to render then they have their own simple scene graphs.
15:44:12 <danharaj> What I want to do is be able to take these graphs and merge them together.
15:44:21 <flosit> danharaj: because i want my matrices to behave like numbers (addition, multiplication, etc).  i thought it would be the most elegant way to instantiate a Matrix-class which inherits from Num than to instantiate a smaller Matrix-class and Num independently
15:44:51 <danharaj> flosit: Could you hpaste your stuff?
15:45:05 <flosit> danharaj: ok, just a moment
15:45:10 <jmcarthur> so you're basically looking for some sugar for constructing the tree then, not really something higher level than the tree, since you want to expose that representation anyway
15:45:21 <danharaj> jmcarthur: Essentially yes.
15:46:08 <danharaj> for example, let's say I had a bunch of chairs I want to render in various positions, but their characteristics like their shapes and textures are the same. The only thing different amongst them is differing position.
15:46:52 <danharaj> I want to be able to construct this scene graph and have them share as many nodes as possible.
15:47:21 <jmcarthur> that scenario doesn't necessarily require that you know it's a tree
15:47:40 <danharaj> jmcarthur: It's really a dag because nodes can be shared, but there's no cycles.
15:47:41 <flosit> danharaj: here you are: http://hpaste.org/46632/matrixclass
15:48:00 <jmcarthur> if you have something called "chair" then you could just say  foldMap ($chair) [transformA, transformB, transformC]
15:48:00 <parcs> i'm using yesod, the hamletFile TH interpolation, and ghci for debugging/testing. the problem is that whenever i alter the file that hamletFile references, ghci doesn't reload the corresponding haskell source file. what's the best workaround for this issue?
15:48:13 <jmcarthur> danharaj: ^^ and that still fits with the monoid model
15:48:22 <danharaj> flosit: ok, I see what your misunderstanding is. You don't 'inherit' one type class from the other. You can require a type class instance to already have an instance of another class.
15:48:31 <jmcarthur> danharaj: that could also still preserve sharing
15:48:42 <danharaj> flosit: so what your code says is that "In order for a to be a Matrix, it must also be a Num"
15:49:14 <flosit> danharaj: ok, so i have to instantiate Num and Matrix indepently?
15:49:32 <danharaj> flosit: yes. However, if you assume Matrix a in a type signature, you don't have to independently assume Num a.
15:50:48 <danharaj> jmcarthur: ok, the nodes are shared, that's good, but I want transformA, etc. to be inserted into the new graph efficiently, to minimize state changes while rendering.
15:50:51 <danharaj> but you are right, it's a monoid.
15:50:54 <flosit> danharaj: i am sorry, what do you mean by 'assume Matrix a in a type signature'?  (this is my first haskell-experience, by the way...)
15:51:12 <jmcarthur> danharaj: in what way is it "inserted"? how does it know where to go?
15:51:24 <danharaj> flosit: for example, look at your type signature for 'equalLength', you assume Num a.
15:51:30 <int80_h> http://hpaste.org/46631/question_about_example1hs_fro
15:51:41 <napping> flosit: If that's the case, maybe you could avoid making class for now - just define some operators directly on your Matrix class.
15:51:48 <napping> er, Matrix type
15:51:52 <danharaj> jmcarthur: That's an algorithmic problem for me to figure out. You gave me the right abstraction though. I need to define a monoid of trees :p
15:52:02 <danharaj> (dags really)
15:52:29 <Taslem> When a function is of the type a -> a -> x, and the order of its first two arguments doesn't matter, is it proper to do:  f x y = (etc); f x y = f y x  ?
15:52:37 <flosit> ah, ok. thanks guys
15:52:43 <jmcarthur> IMO, the tree representation still doesn't sound important to the interface, but i don't know all your plans
15:52:54 <Taslem> (Assuming some form of pattern matching is used, so not redundant)
15:53:26 <danharaj> Tasiem: f x y is exactly the same as f y x, you are just relabeling the variables.
15:53:58 <jmcarthur> danharaj: with the pattern matching qualification that doesn't apply
15:53:59 <Taslem> No, I mean, to shorten code.
15:54:17 <Taslem> Yes, pattern matching. I'm assuming it can fall through the first.
15:54:27 <danharaj> Taslem: Can you give an example?
15:54:29 <danharaj> (hpaste)
15:54:31 <jmcarthur> Taslem: i'd say it's fine so long as you know it won't recurse infinitely
15:54:53 <int80_h> anyone want to take a look at my problem? It's about "All About Monads".
15:54:57 <int80_h> http://hpaste.org/46631/question_about_example1hs_fro
15:55:19 <Taslem> http://hpaste.org/46633/t
15:55:50 <danharaj> int80_h: do you know how to rewrite the infix notation to regular application?
15:55:59 <danharaj> That will help you understand it.
15:56:10 <jmcarthur> int80_h: alright, let's ignore the "`comb` father" part and just look at "Just s `comb` mother" first
15:56:10 <Taslem> Is it more proper to shorten like that, or to repeat it with swapped variables?
15:56:47 <jmcarthur> int80_h: the type of Just s is pretty obviously Maybe Sheep, i hope?
15:57:12 <int80_h> jmacarthur: yeah that's obvious
15:57:25 <jmcarthur> int80_h: alright. do you understand what the type of mother is?
15:57:37 <int80_h> jmcarthur: yeah that's obvious. Now about rewriting it, let me give it a try
15:57:43 <jmcarthur> alright
15:57:50 <danharaj> Taslem: that is completely fine.
15:58:05 <danharaj> Taslem: Make sure your cases cover all possibilities though.
15:58:10 <Taslem> Yeah, I am.
15:58:27 <int80_h> jmcarthur: okay this is where I get confused but let me put something out there.
15:58:40 <jmcarthur> int80_h: ignore the father part as i suggested above
15:58:47 <jmcarthur> we'll add that as a second step
15:58:51 <Taslem> When GHC compiles, does it perform any optimizations?
15:58:58 <jmcarthur> Taslem: if you use -O
15:58:58 <ezyang> Yes.
15:59:06 <jmcarthur> maybe even if you don't?
15:59:08 <ezyang> (And even some optimizations when you do -O0)
15:59:09 <danharaj> Taslem: GHC does hella optimizations.
15:59:12 <jmcarthur> i suppose compilation itself is an optimization
15:59:28 <danharaj> GHC can do things that would make your compiler blush with envy.
15:59:44 <int80_h> maternalGrandfather s = comb (Just s) mother
15:59:50 <jmcarthur> yep
16:00:06 <jmcarthur> now add the father part back
16:00:24 <jmcarthur> `comb` is left associative by the way, in case you weren't aware
16:01:12 <danharaj> ((left) associative)
16:01:15 * danharaj tee hee
16:01:23 <jmcarthur> *sigh*
16:01:48 <int80_h> jmcarthur: this is where I get confused. Is this an example of partial application?
16:02:19 <jmcarthur> nope, both uses of comb are completely applied
16:02:31 <jmcarthur> here's another way to look at it:
16:02:37 <int80_h> jmcarthur: by itself, I would say "comb mother father", but using two combs together?
16:02:52 <jmcarthur> maternalGrandfather s = ((Just s) `comb` mother) `comb` father
16:03:13 <jmcarthur> int80_h: try prefixing the second comb, treating the parens as a single unit of code
16:03:15 <int80_h> oooh! I thought about using $ but then second guessed myself
16:03:47 <jmcarthur> int80_h: and since you already know how to transform the code inside the parens, if you can do this step then you're done
16:04:30 <int80_h> maternalGrandfather s = comb father $ comb (Just s) mother
16:04:40 <jmcarthur> nope
16:04:46 <jmcarthur> you switched the arguments to one of those combs
16:04:56 <jmcarthur> don't try anything fancy with ($), just use parens
16:06:28 <int80_h> maternalGrandfather s = comb (comb (Just s) mother) father
16:06:33 <jmcarthur> yeah!
16:06:47 <jmcarthur> and i think that shows why the infix notation can be pretty nice
16:06:53 <int80_h> whew
16:07:17 <int80_h> jmcarthur: okay thanks :). Now I can get on with playing with the code, now that I know what I'mplaying with.
16:13:00 <Taslem> Hm. I had a very unorthodox idea for a programming language. I think it would fit Haskell neatly, but it's odd.
16:13:08 <Taslem> I think I've found a way to make it type-safe.
16:13:17 <danharaj> Taslem: shoot.
16:13:28 <Taslem> I want to call it "Wrappers."
16:13:45 <danharaj> how does it work?
16:14:17 <Taslem> The syntax needs work, but here's the principal: http://hpaste.org/46634/wrappers
16:14:45 <Taslem> Basically, the idea is that you define a data type as a Wrapper, where it can convert itself to another type on demand.
16:14:54 <Taslem> Based on matching against certain function calls.
16:15:34 <Taslem> When used in a context that they're not expected, you can make them default to just unwrap or convert themselves.
16:15:58 <Taslem> It's like reverse typeclasses, defining a type for a function instead of a function for a type.
16:16:11 <nkpart> Sounds a bit like implicit conversions, ala scala
16:16:46 <Taslem> One thing about it is that the idea is to create non-normal behavior.
16:17:00 <jmcarthur> it looks like a rewrite system
16:17:07 <Taslem> I guess it kinda is.
16:17:56 <Taslem> For instance, Wrapper (End a) where (End a) : z = z ++ [a]
16:18:12 <Taslem> So you can invent new behaviors by temporarily rewriting functions.
16:18:30 <Taslem> So a typical, puire function can be given back data that is type-safe, but describes how it needs to be modified.
16:18:36 <Taslem> Without including extra baggage.
16:18:50 <lispy> sounds like it overlaps with monads
16:19:00 <lispy> Monads give you a controlled way to wrap functions
16:19:27 <Taslem> This allows you to change function behavior, not just wrap functions.
16:22:06 <Taslem> For instance, if you have a recursive function that requires complex case analysis to recombine two pieces of data returned by functions it calls.
16:22:34 <Taslem> If those functions instead return wrappers, then you can use it like a normal value or use one or two quick functions that they've got redefinitions for.
16:23:36 <Kaidelong> why not whack out some nice explanation with latex?
16:23:51 <Taslem> And so long as you didn't pattern match for them, they could also be made anonymous without much difficulty.
16:29:44 <pastorn> int80_h: having fun with All About Monads?
16:35:40 * hackagebot cautious-file 1.0 - Ways to write a file cautiously, to reduce the chances of problems such as data loss due to crashes or power failures  http://hackage.haskell.org/package/cautious-file-1.0 (RobinGreen)
16:52:38 <cccrazy> > tail [1,2,3,4,5]
16:52:38 <lambdabot>   [2,3,4,5]
16:52:44 <cccrazy> > last [1,2,3,4,5]
16:52:45 <lambdabot>   5
16:52:52 <cccrazy> > last [1,2,bootom,4,5]
16:52:53 <lambdabot>   Not in scope: `bootom'
16:53:04 <cccrazy> > last [1,2,bottom,4,5]
16:53:05 <lambdabot>   Not in scope: `bottom'
16:53:22 <cccrazy> err, how to write bottom symbol?
16:53:23 <sully> > last [1,2,undefined,4,5]
16:53:24 <lambdabot>   5
16:53:41 <cccrazy> > last [1,2,3.undefined]
16:53:42 <lambdabot>   No instance for (GHC.Num.Num (f b))
16:53:42 <lambdabot>    arising from a use of `e_1123' at <i...
16:53:50 <cccrazy> > last [1,2,3.undefined, 4]
16:53:51 <lambdabot>   No instance for (GHC.Num.Num (f b))
16:53:51 <lambdabot>    arising from a use of `e_11234' at <...
16:53:56 <cccrazy> > last [1,2,3,undefined]
16:53:57 <lambdabot>   *Exception: Prelude.undefined
16:54:12 <cccrazy> > tail [1,2,3,undefined,4,5]
16:54:12 <lambdabot>   [2,3,*Exception: Prelude.undefined
16:54:26 <cccrazy> ok, got a question, what is partial list?
16:54:45 <cccrazy> only x:bottom, x:bottom:y, bottom:x ?
16:55:26 <tg_> byorgey: did you get a chance to read Ono's paper?
16:56:35 <cccrazy> > length [undefined, undefined, undefind]
16:56:36 <lambdabot>   Not in scope: `undefind'
16:56:45 <cccrazy> > length [undefined, undefined]
16:56:45 <lambdabot>   2
16:57:07 <tg_> cccrazy: you can also molest lambdabot in private chat
16:57:32 <cccrazy> tg_, oh, I did't know about it, thanks ;]
16:57:34 <cccrazy> and sorry ;]
16:57:47 <tg_> cccrazy: no worries
16:57:49 <cccrazy> btw, d oYou have any definition for partal list?
16:57:56 <tg_> cccrazy: partial how?
16:58:08 <cccrazy> what do You mean by "how"?
16:58:15 <tg_> cccrazy: in what sense is the list partial?
16:58:23 <tg_> cccrazy: [] is a partial list
16:58:28 <tg_> in some sense
16:58:31 <cccrazy> in our lessons we have example that x:bottom is partial
16:58:35 <cccrazy> something in that way
16:59:18 <dibblego> http://paste.pocoo.org/show/387844/ does anyone happen to know what this is about?
16:59:31 <tg_> cccrazy: don't know, I'm still a beginner, but I would guess something about lists of [Maybe a] elements
17:00:01 <cccrazy> Or maybe: for every partial xs: xs ++ ys = xs
17:01:04 <Kaidelong> cccrazy: ??? that doesn't make sense
17:01:17 <Kaidelong> xs can be a partial value and xs ++ ys can still be different
17:01:29 <cccrazy> err, what do You mean?
17:01:53 <cccrazy> > [1,2,3,undefined] ++ [4,5,6]
17:01:54 <lambdabot>   [1,2,3,*Exception: Prelude.undefined
17:01:56 <cccrazy> it works
17:02:00 <cccrazy> generates xs
17:02:03 <Kaidelong> > drop 3 $ [4,5,undefined,6]++[7,8,9,10]
17:02:05 <lambdabot>   [6,7,8,9,10]
17:02:30 <cccrazy> > [4,5,undefined,6]++[7,8,9,10]
17:02:32 <lambdabot>   [4,5,*Exception: Prelude.undefined
17:02:47 <Kaidelong> but that's not simply the first argument to ++
17:03:24 <cccrazy> Kaidelong, haskell is lazy, so he drops first
17:03:44 <Kaidelong> haskell isn't lazy
17:03:53 <Kaidelong> glasgow haskell is lazy
17:04:04 <ddarius> That's not true either.
17:04:27 <argiopeweb> Proof: House packing is a map-reduceable problem. Now if only I could parallelize it... http://hpaste.org/46636/house_packing
17:04:58 <ddarius> argiopeweb: Spawn children.
17:05:14 <Kaidelong> ddarius: hmm, what do you mean?
17:05:30 <dmwit> cccrazy: "partial" is usually used to describe functions.
17:05:43 * argiopeweb goes back to single-threaded packing
17:05:45 <dmwit> cccrazy: If you want people to know what you mean when talking about values that are not functions, you'll have to define it for us.
17:06:07 <argiopeweb> ddarius: Exception: Not enough resources.
17:06:50 <argiopeweb> Besides, don't try and tell me I wouldn't have to pack for them too. :P
17:07:21 <ddarius> argiopeweb: Just don't give them anything.
17:07:27 <AardMark> hey
17:07:45 <AardMark> how is everyone?
17:07:50 <argiopeweb> ddarius: Harsh
17:08:16 <shachaf> argiopeweb: Well, you'll terminate them when they're done packing anyway, right?
17:09:13 <argiopeweb> shachaf: That'd be optimal, but I'm not sure what the kernel would have to say about it...
17:09:46 <argiopeweb> She might terminate me and let them live on as zombies. <.<
17:09:54 * argiopeweb thinks this is getting out of hand.
17:10:03 <AardMark> hey kit
17:10:09 <cccrazy> dmwit, thx
17:21:04 <JoeyA> When the "forall" keyword is used for existential types, does it actually mean "there exists"?
17:21:09 <JoeyA> data Obj = forall a. (Show a) => Obj a
17:21:48 <JoeyA> I suppose it actually does mean "forall", but the type is eaten by the data constructor.
17:22:33 <shachaf> Cale: lambdabot seems to have died, by the way.
17:22:41 <JoeyA> And thus, a value inside of an Obj has the following type (logically speaking): ∃a. a
17:22:49 <JoeyA> Am I right?
17:30:19 <dolio> JoeyA: The idea is that forall a, there's a constructor Obj a.
17:30:46 <dolio> Which is supposed to work out to Obj :: forall a. Show a => a -> Obj.
17:30:55 <dolio> Which is the right type for an existential.
17:31:02 <JoeyA> Makes sense.
17:31:30 <dolio> It's unfortunately confusing, though.
17:31:57 <danharaj> dolio: What do you think of adding 'exists' to the language? So you can have 'naked' existentials in signatures?
17:32:13 <dolio> When you try to apply the thinking to 'type' declarations, and remove the constructor, it breaks down.
17:32:41 <dolio> danharaj: I'm totally behind it.
17:32:48 <shachaf> JoeyA: It's probably clearer if you use GADT syntax. :-)
17:32:49 <JoeyA> (5 :: Int) :: ∃a. Num a => a
17:33:28 <JoeyA> ^ If Haskell had a ∃ ("exists") keyword, would that work?
17:34:03 <dolio> danharaj: Unfortunately I think it's complicated for GHC to add.
17:34:06 <Zao> forall is more like "for all types you try to do this with, it must work"
17:34:21 <danharaj> dolio: I see. I think it was UHC that had exists from the start?
17:34:29 <danharaj> It's a shame there's no competitor to GHC :p
17:34:33 <dmwit> I thought it was fairly easy, but they wanted to avoid keyword creep as much as possible.
17:34:45 <dolio> Yes, UHC has them, but they don't support type classes for existential bound variables.
17:34:50 <shachaf> dmwit: They're not adding exists because of *keyword creep*?
17:35:05 <JoeyA> If I understand correctly, ∃ could be used to partially declare the type of something.  Am I correct?
17:35:14 * JoeyA digs up an STArray example
17:35:35 <dmwit> shachaf: Well, it wouldn't be any new features compared to what we have now. Just that some places you would write "exists" instead of "forall".
17:35:35 <Axfan> how do I make an SDL Event
17:35:40 <Axfan> im out of ideas
17:36:02 <danharaj> Axfan: what do you mean?
17:36:14 <Axfan> im trying to declare an sdl event
17:36:39 <dmwit> Looks like Graphics.UI.SDL.Events exports all of Event's constructors.
17:36:45 <dmwit> So that should be no problem.
17:37:05 <Axfan> so i should have just used it in the pollevent
17:37:05 <dmwit> Just write (e.g.) NoEvent or GotFocus [] or MouseMotion 0 0 0 0 or whatever.
17:37:08 <dolio> dmwit: We're not just talking about a new keyword. It's making exists as first class as forall currently is.
17:37:19 <dmwit> Ah, okay.
17:37:19 <dolio> Currently it's tied to data.
17:37:42 <dibblego> FYI scala has a forSome keyword for ∃ types
17:37:51 <danharaj> gross
17:38:00 <dolio> But you have to answer certain questions, I guess.
17:38:16 <JoeyA> length [1,2,3] :: ∃a. Num a => a -- length returns some type in Num; I don't feel like typing it at the moment.
17:38:21 <JoeyA> :t length [1,2,3]
17:38:28 <JoeyA> @type length [1,2,3]
17:38:33 <dolio> Like, 'exists a. a' can be represented by just the underlying term.
17:38:34 <dmwit> :t genericLength
17:38:38 * JoeyA prods lambdabot with a battering ram.
17:38:45 <dmwit> JoeyA: But that type looks really frustrating.
17:38:55 <dolio> But 'exists a. C a *> a', where C is a  type class, is a tuple of sorts.
17:38:57 <dmwit> JoeyA: It means you can *only* do Num operations on the result of calling length.
17:39:04 <danharaj> yeah that's not the right type
17:39:06 <dolio> If you do dictionary passing, it has to bundle the dictionary.
17:39:15 <danharaj> it actually is forall because you can substitute any num type
17:39:17 <JoeyA> dmwit: Hmm, interesting.
17:39:38 <shachaf> dmwit: I thought you emant something that would let you omit the data type declaration.
17:39:42 <JoeyA> Let me see if I understand this correctly.  If we have f :: Num a => a -> a; f x = ...
17:39:58 <JoeyA> is the type of x this?  ∃a. (Num a) => a
17:40:20 <JoeyA> to clarify: f :: forall a. Num a => a -> a
17:40:21 <dmwit> shachaf: Okay, sorry. Yeah, that's not being prevented merely by keyword creep.
17:40:22 <danharaj> no
17:40:24 <dolio> => is a poor notation for type classes with existentially bound variables.
17:40:44 <shachaf> dmwit: [1,True,'q'] :: [exists a. Show a => a] would be neat.
17:40:51 <danharaj> JoeyA: If I substitute any Num type for a, I get a function on that type.
17:40:56 <shachaf> (Though of course [String] works just as well for that particular example.)
17:40:58 <dmwit> JoeyA: No. Each invocation of f nails down a concrete instance of Num, so x is monomorphic.
17:40:58 <danharaj> Polymorphism is about substituting types.
17:41:19 <JoeyA> dmwit: Right, hence the ∃ (there exists)
17:41:54 <danharaj> JoeyA: no, you get to substitute the num you want.
17:42:02 <danharaj> Hence forall a. Num a => etc.
17:42:06 <JoeyA> Ah
17:42:10 <dmwit> JoeyA: No, it's still not an existential. It's a concrete, monomorphic type.
17:42:18 <JoeyA> okay
17:42:28 <yafer> what are you talking about?
17:42:52 <JoeyA> Wait a second, no I can't substitute the Num I want for an argument.
17:43:11 <JoeyA> f :: forall a. Num a => a -> a; f x = ... something with x ...
17:43:19 <JoeyA> I can't choose to treat x like an Int
17:43:20 <danharaj> why not...?
17:43:28 <danharaj> No you can't. Not in the function.
17:43:32 <dmwit> JoeyA: Here's a little brainteaser that might help: (exists a. Int) and (Int) are not the same type. Why not?
17:43:35 <danharaj> But you can apply the function to an Int.
17:43:47 <danharaj> and you know that the type you get back is an Int.
17:43:49 <JoeyA> Right
17:43:54 <JoeyA> I'm talking about inside the function.
17:43:58 <JoeyA> Sorry, my question wasn't specific enough.
17:44:13 <JoeyA> My question is: *within the function*, is the type of x exists a. Num a => a
17:44:44 <danharaj> It acts like it.
17:44:59 <danharaj> You want to read about "Parametricity"
17:45:09 <dmwit> Really?
17:45:10 <danharaj> this describes how polymorphic functions can be defined.
17:45:12 <dylukes> I come bearing news of the end of the world!
17:45:17 <dmwit> This doesn't seem like it has anything to do with parametricity to me.
17:45:24 <dylukes> I just thought about language choice for a small thing,
17:45:27 <dylukes> and Haskell came to mind first.
17:45:30 <dylukes> As a
17:45:32 <dylukes> PRACTICAL
17:45:32 <dylukes> USE
17:45:33 <dylukes> CASE.
17:45:39 <dylukes> We're all screwed.
17:45:41 <JoeyA> The sky is falling!
17:45:43 <danharaj> @ops
17:45:50 <dylukes> danharaj: shush...
17:45:53 <JoeyA> forall a. Die a => a
17:46:03 <JoeyA> Blah, that didn't make sense
17:46:10 <JoeyA> forall a. Die a HOLDS
17:46:18 <dolio> dmwit: exists a. Int is isomorphic to Int.
17:46:33 <dmwit> dolio: Oh, for sure.
17:46:44 <JoeyA> I'm trying to figure out the difference between (exists a. Int) and (Int) now
17:46:48 <dmwit> Integer is also isomorphic to [()]
17:46:53 <JoeyA> I'm quite sure (forall a. Int) and (Int) are the same.
17:47:15 <dolio> dmwit: In something like GHC, they'd probably be interchangeable.
17:47:18 <JoeyA> Can I print an exists a. Int ?
17:47:24 <JoeyA> Is (exists a. Int) behind the green glass doors?
17:47:30 <dmwit> JoeyA: Well, actually, usually the bare language theory would distinguish between forall a. Int and Int.
17:47:32 <dolio> Add or drop extra quantifiers at will.
17:47:55 <JoeyA> dmwit: But, from a logic perspective, they're exactly the same, right?
17:48:09 <dmwit> No, the logic and the bare language theory are the same thing.
17:48:47 <JoeyA> dmwit is confusing me for all cats.
17:48:54 <dmwit> Something classified by (forall a. Int) is a function that, when given a type, produces an Int.
17:49:08 <dmwit> Haskell muddies the water a bit, since it does type erasure.
17:49:20 <danharaj> ...
17:49:22 <dmwit> So those lambdas and type applications get erased.
17:49:27 <dolio> Yeah, with erasure exists a. Int and Int are the same, too.
17:49:33 <dolio> You erase the type component.
17:49:37 <dmwit> Right.
17:49:48 <dmwit> errr... wait, really?
17:49:52 <dolio> Yes.
17:49:59 <dmwit> Oh, I suppose you erase the unpacking of the existential, as well?
17:50:02 <dmwit> Yeah, that makes sense.
17:50:44 <JoeyA> There exists a cat such that bowling is fun.
17:51:10 <JoeyA> For all cats, bowling is fun.
17:51:24 <JoeyA> (the domain of discourse is cats, as is standard practice in logic)
17:51:39 * dmwit opens his book on cat. theory
17:51:45 <JoeyA> lol
17:55:09 <JoeyA> Thanks for the help, however confusing it may have been to all involved.
17:55:24 <danharaj> @where TAPL
17:55:29 <danharaj> WHERE IS LAMBDA BOT
17:55:31 <danharaj> ;_;
17:55:46 <JoeyA> What's worse than robots taking over the world?
17:55:51 <JoeyA> When they take over the world, and then just leave.
18:01:14 <_greenland> hello #haskell. I'm trying to figure out record syntax. It seems as if all of the custom types in my module share their field namespace. It wont let me declare "name" as a field in two different types. Is this correct? Whats the way to handle that?
18:01:26 <brbr> what's the easiest way to generate a key that already isn't in your Map ?
18:01:44 <mm_freak> _greenland: that's correct
18:01:53 <mm_freak> _greenland: there are different ways to handle it
18:02:00 <_greenland> brbr: any arbitrary value? confused.
18:02:26 <mm_freak> the simplest way is to give a unique prefix:  data Person = Person { personName :: Text }
18:02:27 <sm> shoot..
18:02:33 <_greenland> mm_freak: what is the preferred method? python-style namespace mutilation or, am i just doing it wrong to begin with?
18:02:46 <mm_freak> two methods are preferred…  sometimes in combination
18:02:47 <brbr> _greenland: sure, say I have a Map that takes Int's for keys... how do I generate a new, unique key?
18:02:48 <mm_freak> either use modules
18:02:55 <mm_freak> or use prefices
18:03:14 <mm_freak> brbr: find the maximum of the map
18:03:21 <mm_freak> should be an O(log n) problem
18:03:29 <mm_freak> brbr: you can also use Data.Unique
18:04:07 <mm_freak> or keep track of the most recently used key
18:04:53 <_greenland> mm_freak: putting the type in a different module (which i should do anyway), solves the issue? if I did a qualified import of both would it break again?
18:05:32 <mm_freak> _greenland: qualified import of both does not break it
18:05:53 <aavogt> _greenland: a third is to use a typeclass to be able to use the same name twice. It's probably better to do those things indirectly like with the hackage pkg fclabels or data-accessor
18:05:54 <mm_freak> import qualified MyApp.Person as Person; import qualified MyApp.City as City
18:06:16 <mm_freak> you can also write an additional import line like this:  import MyApp.Person (Person)
18:06:28 <mm_freak> so you don't have to refer to 'Person' by qualified name
18:06:36 <aavogt> there are a whole bunch of approaches besides those two packages
18:06:37 <mm_freak> Person { Person.name = "whatever" }
18:07:18 <mm_freak> this is how you usually import things like Data.ByteString and Data.Text
18:07:51 <_greenland> mm_freak: you may be the most useful person in the universe
18:08:02 <mm_freak> by far not =)
18:08:22 <mm_freak> aavogt has also given you a useful alternative, though personally i like to use the standard approach
18:08:22 <aavogt> mm_freak: there are extensions to make the second Person there unnecessary
18:08:42 <mm_freak> aavogt: true
18:10:55 <aavogt> hmm, there doesn't seem to be a wiki page directly comparing say HList vs fclabels
18:11:10 <aavogt> http://haskell.org/haskellwiki/Extensible_record
18:13:36 <brbr> how do I turn an IO Int into an Int ?
18:13:53 <Ptival> :)
18:14:31 <Ptival> http://stackoverflow.com/questions/5090779/haskell-problem-io-string-int
18:14:41 <mmancuso> t
18:14:44 <Ptival> brbr: link for you
18:15:00 <Zao> @type do { x <- return 3; return (x*9) }
18:15:08 <Zao> So, who ate lamdabot this time?
18:15:44 <blackdog>  /quit
18:17:01 <mm_freak> brbr: you don't
18:18:08 <mm_freak> brbr: you'll want to learn how monadic IO works
18:22:27 <brbr> why is it so hard to get a random Int ?
18:23:06 <mm_freak> it's not hard at all
18:23:34 <mm_freak> it's just different in haskell compared to most other languages
18:24:30 <brbr> I want to do something like: let n = do u <- Unique.newUnique, return $ Unique.hashUnique e
18:24:45 <brbr> so n will be my unique int
18:24:59 <mm_freak> probably it's better not to use Data.Unique
18:25:24 <brbr> what is the simplest way to get a random Int then?
18:25:34 <mm_freak> random or unique?
18:25:50 <mm_freak> because random and unique contradict each other
18:26:08 <brbr> whichever is easier
18:26:15 <mm_freak> unique is easier
18:26:33 <mm_freak> one way is this: data MyDatabase = MyDatabase { dbLastKey :: Int, dbEntries :: Map Int Whatever }
18:26:50 <mm_freak> other way:  genDatabase :: State Int (Map Int Whatever)
18:26:56 <mm_freak> there are many different ways
18:27:40 <brbr> actually, how do you get a random Int.. it's okay if the key already exists
18:28:01 <mm_freak> you can use System.Random funtionality
18:29:54 <brbr> mm_freak: how?
18:30:37 <mm_freak> depends…  there are mainly two ways: monadic and pure
18:31:05 <mm_freak> the pure way requires you to pass around the PRNG state somehow
18:31:21 <mm_freak> the (IO-) monadic way will make you depend on IO
18:32:03 <aavogt> @hackage MonadRandom
18:32:26 <aavogt> http://hackage.haskell.org/package/MonadRandom
18:33:49 <dafis> which is the pure way, it just takes care of passing the PRNG around for you
18:35:22 <rhapsodyv> is there any fromIO, like fromJust?
18:35:42 <mm_freak> we should employ an auto-responder for that question
18:35:55 <mm_freak> it's probably the most frequently asked question here =)
18:35:57 <rhapsodyv> :-)
18:35:59 <mm_freak> rhapsodyv: no
18:36:34 <rhapsodyv> it's annoying
18:36:41 <mm_freak> no, it's not
18:36:47 <mm_freak> it's just not C =)
18:37:02 <mm_freak> there is no fromIO, nor can there be such a function…  there is a function with the type you want, but its name contains the word "unsafe" for a very good reason
18:37:06 <mm_freak> and i won't name it for you
18:37:12 <blackdog> hrm. where do you get Debug.trace if you're using haskell2010?
18:37:14 <shachaf> rhapsodyv: No. Also, fromJust is evil. Don't use it.
18:37:29 <rhapsodyv> when all my data is already evaluated, i want to just turn it pure :-(
18:37:30 <dafis> unsafeRustyBallpointTracheotomy
18:37:32 <shachaf> (fromMaybe is OK, though.)
18:37:38 <applicative> rhapsodyv, what would you do with such a function if you had it.
18:37:44 <mm_freak> rhapsodyv: what you really want is to learn how to do monadic IO
18:37:49 <shachaf> applicative: Perform IO. Unsafely.
18:37:56 <shachaf> mm_freak: s/monadic/Haskell/
18:38:02 <rhapsodyv> hum
18:38:06 <mm_freak> shachaf: or that
18:38:08 <applicative> rhapsodyv, what are you going to do do with the 'pure' numbers or whatever, once you have them?
18:38:28 <applicative> rhapsodyv: no one wants the Integers for their own sake
18:38:37 * dafis does
18:38:38 * applicative does, sort of
18:38:43 <mm_freak> rhapsodyv: haskell is always pure…  what you really want to do is to make it impure
18:38:46 <mm_freak> and that's the wrong way
18:39:06 <applicative> no, rhapsodyv want to map a function over an action
18:39:09 <Rotaerk> haskell's not always pure...
18:39:10 <applicative> wants
18:39:18 <mm_freak> Rotaerk: where is it not?
18:39:22 <shachaf> foo :: IO Int doesn't "contain" an Int in the same way (Just 5) does.
18:39:25 <Rotaerk> the unsafe functions
18:39:27 <mm_freak> (not counting the unsafe* stuff)
18:39:39 <mm_freak> those functions are not haskell
18:39:44 <mm_freak> you need extensions to write them
18:40:12 <aavogt> the ffi is an official part of the standard
18:40:19 <blackdog> no-one using haskell2010 needs trace?
18:40:42 <mm_freak> blackdog: more generally nobody needs trace
18:40:43 <shachaf> blackdog: Was Debug.Trace ever part of the standard?
18:40:54 <rhapsodyv> ok, i got it
18:41:05 <blackdog> shachaf: wel,l it was in base.
18:41:09 <blackdog> maybe not in the standard.
18:41:13 <mm_freak> rhapsodyv: anyway, look at the type of (>>=)
18:41:17 * applicative wonders what rhapsodyv got
18:41:18 <blackdog> any way to get it back, at least in the interim?
18:41:21 <mm_freak> and replace 'm' by 'IO' in your head
18:41:30 <mm_freak> :t (>>=)
18:41:32 <applicative> @type (>>=)
18:41:36 <applicative> hah
18:41:36 <blackdog> got about 2000 lines of past-blackdog haskell i'm trying to gradually untangle
18:41:40 <mm_freak> oh, lambdabot is not here
18:41:41 <djahandarie> @botsnack
18:41:42 <rhapsodyv> like: getLine… it's IO String, but it not contain a string, it can change on every call
18:41:50 <dafis> Monad m => m a -> (a -> m b) -> m b
18:42:01 <mm_freak> rhapsodyv: an IO String is an action to compute a String
18:42:02 <applicative>   @type fmap
18:42:06 <mm_freak> it's not the string itself
18:42:07 <shachaf> blackdog: Well, you can reimplement Debug.Trace yourself if it's really gone...
18:42:17 <mm_freak> rhapsodyv: and you can combine IO actions using (>>=)
18:42:19 <shachaf> I'd be surprised if it is, though.
18:42:23 <mm_freak> (or the equivalent do-notation)
18:42:28 <dafis> Functor f => (a -> b) -> f a -> f b
18:42:31 <aavogt> mm_freak: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html
18:42:34 <applicative>  fmap :: Functor f => (a -> b) -> (f a -> f b)
18:42:47 <mm_freak> aavogt: i know
18:42:57 <aavogt> you'll notice that the ffi is part of the language
18:43:09 <applicative> dafis, we need one more for rhapsodyv
18:43:18 <mm_freak> on the other hand, you shouldn't cheat when using the FFI
18:43:20 <applicative>  @type (<*>)
18:43:27 <mm_freak> also it doesn't give you an IO a -> a for free
18:43:53 <applicative>  (<*>) :: Applicative f => f (a -> b) -> f a -> f b
18:43:54 <aavogt> mm_freak: what do you mean, there's an unsafePerformIO :: IO a -> a in Foreign
18:44:03 <blackdog> shachaf: i suppose so.
18:44:04 <rhapsodyv> mm_freak: I know, I often have cases that a load some data e it won't change anymore, so it would be good if I can just pull it out of IO
18:44:06 <aavogt> that's as free as you'll get that type
18:44:14 <mm_freak> aavogt: is it part of the standard, too?
18:44:30 <applicative> rhapsodyv, it doesn't make any sense.
18:44:31 <mm_freak> rhapsodyv: if it has a name, then sharing is used
18:44:32 <aavogt> mm_freak: yes
18:44:38 <mm_freak> rhapsodyv: this is not related to IO at all
18:44:47 <mm_freak> myData <- getMyData
18:44:51 <mm_freak> now it has a name "myData"
18:44:56 <aavogt> there's even a stamp http://www.cse.unsw.edu.au/~chak/haskell/ffi/h98-ffi.gif
18:45:13 <mm_freak> aavogt: ok, didn't know that
18:45:14 <applicative>  print (f myData)
18:45:26 <rhapsodyv> HAHAHHAHAAH I din't know that I can use <- in ghci!!!!!!
18:45:31 <rhapsodyv> thanks a lot!!!
18:45:46 * shachaf is unnerved at rhapsodyv's evil laugh.
18:45:53 <mm_freak> hehe
18:46:04 <shachaf> "I can perform IO! I'm rich! I'm rich! I can buy out anybody! HAHAHHAHAAH"
18:46:07 <applicative> rhapsodyv: yes, it even gives you the type you want
18:46:11 <mm_freak> rhapsodyv: you can do a lot in GHCi…  the only thing i'm missing is a way to write data types
18:47:03 * applicative doesn't want it; what next, defining type classes? or just instances
18:47:24 <rhapsodyv> it's very very better now!
18:47:29 <poltak> what are some good examples of functional programming use in the real world (big companies/famous software etc)?
18:48:02 <poltak> i've heard google's search is thanks to functional algorithms, no?
18:48:07 <applicative> rhapsodyv: practice doing   file <- readFile "blah"  and then let foo = f file  etc.
18:48:17 <applicative> rhapsodyv: then you're writing 'do notation'
18:48:29 <monochrom> I can do IO. I'm now confused.
18:48:39 <ddarius> applicative: You should be able to cat a file into the interpreter and it should work.
18:48:51 <siracusa> blackdog: What GHC version are you using?
18:49:07 <blackdog> siracusa: 7.0.3
18:49:15 <blackdog> i don't seem to have unsafePerformIO, either
18:49:20 <applicative> ddarius does it work ghci? i'm puzzled
18:49:21 <siracusa> And you have no Debug.Trace?
18:49:22 <blackdog> all my favourite toys are being taken away from me *sob*
18:49:31 <blackdog> not when i build in cabal
18:49:37 <mm_freak> poltak: i'm using haskell productively
18:49:39 <ddarius> applicative: No, but it should.
18:49:44 <blackdog> swapped over from base to haskell2010
18:49:48 <mm_freak> i'm doing web-application and server development mainly
18:50:07 <rhapsodyv> thanks a lot… my problem was just in ghci… I don't know why never tried <- in ghci! :-p
18:50:35 <mm_freak> blomqvist: you have it, but it's better, if you don't find it ;)
18:50:36 <ddarius> rhapsodyv: Because it doesn't make sense to.  You could, however, read the documentation.
18:50:41 <mm_freak> oops
18:50:54 <mm_freak> -blomqvist +blackdog
18:51:00 <applicative> ddarius, you mean if I do readFile, I see the name of the string, not the string
18:51:35 <ddarius> applicative: Now I have no idea what you are talking about.
18:52:01 * applicative is just trying to see how he can't do the equivalent of cat in the ghci
18:52:27 <ddarius> applicative: I was saying 'ghci < some.hs' should work.
18:52:32 <applicative> oh
18:52:35 <applicative> indeed
18:53:08 <applicative> why doesn't it permit that?
18:53:25 <ddarius> Because it isn't implemented.
18:53:35 <dafis> applicative:  data types, for example
18:53:35 * applicative has frequently wanted to pipe modules to ghci from e.g. hpaste
18:55:35 <mm_freak> applicative: that somehow contradicts your earlier statement
18:55:44 <mm_freak> 513 035418  * applicative doesn't want it; what next, defining type classes? or just instances
18:58:09 <applicative> now i'm really confused.
18:58:17 <shachaf> @botsneak
18:58:23 <lambdabot> :)
18:59:08 <applicative> somehow, :l blah.hs doesn't seem like "let class Idea a = Good a | Bad String
19:00:02 <applicative> .. etc.  and then, I guess, let instance Idea Num where ... etc
19:00:27 * applicative thinks, inside ghci that would freak me out
19:00:50 <applicative> instance Idea Integer rather
19:01:06 <ddarius> You should be able to type exactly what you type into source files into the interpreter.
19:01:20 <applicative> hmm, ddarius lispy
19:01:30 <applicative> actually I think I really do oppose that
19:01:46 <ddarius> applicative: There's nothing "lispy" about it.  The MLs have -always- been that way.
19:01:47 <applicative> that's why the sml interpreter freaks me out.  I dont mind it with lisp interpreters
19:01:54 <applicative> funny you say that
19:02:00 <applicative> I hate it
19:02:16 <applicative> that's exactly why ML's are bad and Haskell is good.
19:02:29 <monochrom> in fact, the sml interpreter is probably an on-the-fly compiler
19:02:39 <applicative> the interpreter hangs if you give it certain definitions.
19:02:55 <applicative> of course the ghci probably does in suitable cases too
19:03:14 <ddarius> You're making less and less sense.
19:03:24 <applicative> the ghci takes my module for granted, it then interprets what i'm saying in the light of that
19:03:54 <dolio> That's a 'problem' with definitions in ML, not with a REPL allowing you to write all definitions available in the language.
19:03:54 <applicative> I'm not making sense yet, I just have to practice.
19:04:34 <applicative> the experience of using the interpreters with ML is quite different, but it seems like it's bound up with everything else that's different
19:05:23 <applicative> they violate what I loved about Haskell from the first minute I used it.  I don't feel like I'm defining terms in a module, but issuing commands
19:05:44 <applicative> same as inside the 'interpreter' or whatever we should call it.
19:06:30 <applicative> when the ghci loads your module, it hasn't yet done anything, it's just understood your terms
19:06:45 <monochrom> an sml repl supports entering a whole bloody module by hand at the prompt, yes, but you don't have to use this feature if it freaks you out. just use an editor
19:06:47 <applicative> i guess this is an effect of laziness, that this is the natural approach
19:07:17 <ddarius> It has nothing to do with laziness.
19:07:24 <applicative> monochrom, I do use an editor
19:07:38 <applicative> but it's no different from being inside the interpeter
19:07:50 <dolio> It has a little to do with laziness.
19:08:36 <applicative> dolio, are you sure?  could they make an ml interpreter that didn't hang when I wrote the obvious circular definition?
19:08:39 <monochrom> when ghci returns from ":load blah", it has already finished translating the file into bytecode
19:09:09 <applicative> monochrom, but it hasn't calculated the infinite list i defined on line 6 for example
19:09:15 <dolio> applicative: No. But they could make a Haskell interpreter that let you write data/module declarations at the prompt.
19:09:16 <applicative> but the ml interpreters have
19:09:27 <applicative> dolio, my question was the opposite
19:09:28 <monochrom> in fact, if you started ghci with "ghci -fobject-code", it will have already finished compiling the code to machine code and written it into blah.o
19:09:33 <dolio> In fact, I think they already wrote one, called hbi.
19:09:47 <applicative> hm, sounds good.
19:10:10 <ddarius> dolio: Not only did it exist, but it was the first one.
19:10:40 <applicative> monochrom: you're not thinking about defining a = b + 1 ;b = a + 1 or whatever
19:11:23 <applicative> the interpreter can't take it
19:11:52 <applicative> but ghci and hugs can.
19:12:11 <ddarius> No they can't.
19:12:23 <applicative> that example? maybe it's bad
19:13:15 <applicative> it compiles to bytecode just fiine
19:13:47 <dafis> ddarius:  let a = b+1; b = a+1 in a < (10 :: Peano)
19:13:53 <dolio> The evaluation strategy in ML makes non-termination an effect.
19:13:59 <ddarius> dafis: That's not what applicative wrote.
19:14:00 <dafis> would work in ghci or hugs
19:14:09 <dolio> So when you try to define non-terminating values, the effect occurs.
19:14:25 <dolio> Same as when you define a value that's equal to reading a file or something.
19:14:39 <dolio> Due to its lack of side effect management.
19:14:51 <applicative> http://hpaste.org/46638/a__b__1__b__a__1
19:15:10 <sublimepua> im a newbie, and looking at functional programming. why should i choose haskell over lisp?
19:15:10 <dolio> But that's a problem with effects, not with allowing definitions somewhere.
19:15:30 <applicative> dolio, right, it makes non termination an effect, this is why it makes me slightly ill
19:15:33 <monochrom> haskell has better community
19:15:37 * applicative will get used to it
19:15:41 <dafis> ddarius:  sublimepua much nicer syntax, types, types, types
19:15:57 <sublimepua> lol whats wrong with parenthesis
19:15:58 <ddarius> applicative: I was talking about what you can write at the REPL.  If the equivalent to that loops in SML when loaded from a module, then how is that relevant?
19:16:01 <applicative> sublimepua: haskell has beatiful types.  lisp is awesome.  learn them both.
19:16:06 <dafis> ddarius:  sorry
19:16:19 <monochrom> lisp has better repl
19:16:32 <dafis> sublimepua:  they need to kill trees for parentheses
19:16:48 <sublimepua> lol im not printing out my programs and handing them around
19:16:54 <applicative> ddarius, i don't know if i am really disagreeing with you about anything.  I just want to understand the difference, which is very striking. sml is more like a lisp
19:17:00 <applicative> with types
19:17:09 <sublimepua> which is more concise? i like elegant code
19:17:24 <applicative> haskell wins hands down sublimepua
19:17:25 <ddarius> Then shouldn't you be asking which is more elegant?
19:17:32 <applicative> but lisp itself is elegant
19:17:39 <monochrom> haskell is more concise with pattern-matching
19:17:42 <ddarius> sublimepua: Just learn them both and make your own decision.
19:17:43 <applicative> sublimepua: write a lisp  repl in haskell
19:17:44 <Axfan> whats the haskell alternative to &&
19:17:49 <ddarius> (&&)
19:18:00 <applicative> @type (&&)
19:18:00 <lambdabot> Bool -> Bool -> Bool
19:18:15 <tg_> question from http://learnyouahaskell.com/making-our-own-types-and-typeclasses
19:18:27 <sublimepua> wait, how would you write a lisp repl in haskell?
19:18:36 <Axfan> didnt work
19:18:40 <tg_> re strong convention to "never add typeclass constraints in data declerations"
19:18:43 <ddarius> sublimepua: You just write it.
19:18:45 <Axfan> im trying to run two functions on the same line
19:18:52 <applicative> sublimepua: you just write it
19:19:00 <applicative> like ddarius said
19:19:07 <sublimepua> is lisp really that simple?
19:19:24 <ddarius> sublimepua: It's not super-Turing, so yes.
19:19:27 <dafis> Axfan:  && as in compile && ./run?
19:19:32 <Axfan> no
19:19:34 <Axfan> i meant like
19:19:35 <shachaf> sublimepua: "you just write it" is the answer no matter how complicated LISP is.
19:19:42 <Axfan> i have an sdl event and id like it to run two functions
19:19:50 <Axfan> oh wait
19:19:56 <chomp> another acceptable answer may be "with a keyboard"
19:19:57 <Axfan> maybe i could use a do
19:20:21 <Axfan> wow
19:20:22 <Axfan> nevermind
19:20:24 <Axfan> i just needed to use do
19:20:25 <applicative> sublimepua: here's one of many https://github.com/justinethier/husk-scheme/blob/master/hs-src/shell.hs
19:20:36 <dafis> :t (>>)
19:20:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:20:37 <Axfan> thanks for tryingguys
19:20:39 <Axfan> XD
19:20:40 <dolio> tg_: The ability to even do that is probably a historical hold-over.
19:20:42 <sublimepua> i feel like i wanna make this my project now. writing a lisp repl in haskell
19:20:48 <dolio> It used to have a purpose, but no longer does.
19:20:53 <Axfan> finnaly i have key events working
19:20:55 <Axfan> haha
19:20:57 <sublimepua> oh wow thats short
19:21:03 <Axfan> see you net time i screw up super bad
19:21:09 <tg_> dolio: well I'm thinking about a particular concept...
19:21:32 <sublimepua> i see what you did there with the "import scheme interpreter".
19:21:36 <tg_> hastie?
19:21:39 <tg_> what's the pastie site for here?
19:21:50 <dafis> @where paste
19:21:50 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
19:21:58 <shachaf> @paste
19:21:58 <lambdabot> Haskell pastebin: http://hpaste.org/
19:22:37 <applicative> sublimepua: there is a familiar tutorial, i don't know if it's good
19:23:01 <sublimepua> ill give it a try. whats it called?
19:23:17 <dafis> write yourself a scheme in 48 hours
19:23:25 <applicative> http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
19:24:21 <applicative> it is also an introduction to the parsec parser library.  the 'learn you a haskell' site is the happening tutorial these days it seems.
19:24:25 <applicative> @where lyah
19:24:25 <lambdabot> http://www.learnyouahaskell.com/
19:25:04 <applicative> sublimepua: our friends here can help you, of course :)
19:25:08 <sublimepua> ive looked at that. and hmm this is interesting.
19:31:51 <applicative> dolio: HBI and HBC, Chalmers' Haskell Interpreter and Compiler
19:32:28 <dolio> All I know is that augustss was involved, but that sounds plausible.
19:32:34 <ddarius> That's it.
19:32:41 <ddarius> Augustsson wrote HBC.
19:32:44 <applicative> it was implemented in Lazy ML
19:33:03 <ddarius> Indeed.  Augustsson wrote LML too.
19:33:42 <sublimepua> how hard is it to throw together a program in haskell after you get the language. like productivity wise,
19:33:54 <ddarius> It depends on the program.
19:35:32 <sublimepua> like say i wanna throw together an rss reader, a barebones version would most likely take some pretty serious time with say C or Java. haskell?
19:35:49 <applicative> somehow I think even Lazy ML isn't adequate to clear thought, if this is the hello world program http://www.csse.monash.edu.au/~lloyd/tildeFP/LML/Examples/hello.m
19:35:55 <blackdog> sublimepua: as a wild-ass guess: more time than Ruby/Perl, less than C/Java
19:36:02 <ddarius> sublimepua: A barebones RSS reader shouldn't take very long with any language.
19:36:04 <blackdog> but that's more to do with the availability of libraries
19:36:05 <dons> sublimepua: use the `feed` library. game over.
19:36:34 <ddarius> blackdog: It'd probably take me more time in Ruby/Python than in Haskell, but then I've written almost no Ruby/Python.
19:36:44 <dons> http://hackage.haskell.org/package/feed
19:36:57 <ddarius> I could probably write an RSS feed reader in brainfuck in less than a week.
19:37:00 <tg_> ok, 3 questions here for experts: http://hpaste.org/46639/redundancy
19:37:03 <sublimepua> haha i feel kinda sold
19:37:13 <shachaf> ddarius: Would you do that directly or by writing a compiler?
19:37:53 <sublimepua> partly because i look at haskell and see some serious programs being written in it. i cant think of a major lisp program
19:38:03 <blackdog> ddarius: yeah, you'd have to assume equal competency in each. I recently wrote something in haskell and ended up reimplementing in ruby basically for library reasons
19:38:21 <tg_> sublimepua: you will find some amount of hedging as to what can be done easily and how in Haskell...
19:38:29 <blackdog> and the libs are doable in haskell too, we just have a smaller community.
19:38:48 <blackdog> i'd love to see something like Thor in Haskell, or an easy web interaction library
19:38:48 <ddarius> blackdog: More that we have different emphasis, though we do have a smaller community.
19:39:08 <blackdog> ddarius: yes, there's that too. i look at the dudes writing parsers in ruby and die a little inside
19:39:17 <tg_> I think a statement many programmers can agree with, is that the best (and possibly only) way of convincing yourself to try a new programming language is to sit down and learn/use it, and see if *that* process represnts utility to you as a programmer.
19:40:01 <shachaf> tg_: The best way of convincing yourself to try a new programming language is to try that programming language?
19:40:02 * ddarius references http://alistair.cockburn.us/Characterizing+people+as+non-linear,+first-order+components+in+software+development yet again.
19:40:11 <dafis> tg_:  I can answer your first question: No.
19:40:22 <tg_> dafis: hooray. thanks.
19:40:37 <dafis> tg_:  for the rest, I don't really understand what you try to achieve
19:40:50 <tg_> dafis: duplication of data in memory
19:40:52 <tg_> for purposes of analysis
19:41:07 <tg_> i want to do the same operation when I use a Vector
19:41:21 <dafis> tg_:  what does "duplication of data in memory" mean?
19:42:05 <tg_> dafis: I want to do mathematics over a Vector, but I want that vector to store 3 copies of every ijk:
19:42:23 <tg_> [Integer, Int, Real], [Integer, Int, Real], [Integer, Int, Real]
19:43:23 <sublimepua> whats the learning curve to haskell
19:43:34 <monochrom> a logistic curve
19:43:40 <blackdog> sublimepua: gentle but unending:)
19:43:50 <tg_> and whenever I use a function on these things, just apply the function (over Num a), but do it seperately using 3 different inhabitants of Num
19:44:18 <tg_> so if I add two vectors, it will look like:
19:44:22 * ddarius doesn't understand these questions.  All of the answers are near meaningless.
19:44:39 <sublimepua> lol oh oh oh i use xmonad. does anyone know how long that took? lol
19:45:07 <dafis> tg_:  you could use (Vector Integer, Vector Int, Vector Double), would that be adequate?
19:45:20 <tg_> dfeuer_: a triple?
19:45:35 <tg_> dfeuer_: it would be adequate, but I would rather deal with these things in Lists
19:45:47 <tg_> and since they all have Num a relations
19:46:09 <applicative> tg_ if you write vsum (Vector i j k) (Vector i' j' k') = Vector (i+i' ) ... then the ensuing definitions would be indifferent to Int, Integer, Double, Float
19:46:22 <tg_> applicative: right, and I want to run all three at the same time
19:46:27 <dafis> tg_:  lists are homogeneous, so you can't have vectors of different types in one list
19:46:32 <tg_> dafis: right
19:46:42 <tg_> dafis: instead of me choosing one Num a type to do work in
19:46:45 <tg_> I want to choose them all
19:47:02 <tg_> and do N copies, where N is the number of inhabitants of Num a
19:47:14 <tg_> and store all of them in memory, and do computation sperately on each part
19:47:24 <applicative> so you want Vector = Vector (Int, Integer, Double) (Int, Integer,Double) (Int, Integer, Double)
19:47:32 <dafis> tg_:  N is potentially infinite
19:47:41 <tg_> dfeuer_: it's strictly non-infinite here
19:47:48 <monochrom> learning xmonad without learning haskell is harder than learning xmonad with learning haskell
19:48:24 <tg_> I won't be actually using those types of Numb, and I suppose I would want the ability to just choose which duplications I want
19:48:28 <dafis> tg_:  but what applicative said
19:48:29 <tg_> s/Numb/
19:48:33 <monochrom> the "I don't want to know" attitude makes learning harder, not easier
19:50:13 <monochrom> until you are a robot and free of human psychology, less information does not translate to less time to absorb
19:50:22 <tg_> applicative: in which case I could use functions which mask each other out in the constructors using _?
19:50:33 <applicative> tg_ take a look at http://hackage.haskell.org/package/vector-space , maybe
19:50:42 <tg_> applicative: or how would I procede in order to reduce the syntax down back to something like Vecot = Vector a a a
19:51:00 <tg_> of course this i written by conal
19:51:02 * tg_ sighs
19:51:24 <applicative> tg_ written by conal means good, no?
19:51:28 <tg_> applicative: of course
19:52:28 <applicative> I notice he defines a Num instance for pairs and triples, instance Num a, Num b, Num c => Num (a,b,c) which isn't what you want.
19:52:41 <ddarius> monochrom: That last statement doesn't make any sense.
19:53:05 <applicative> ddarius, it would probably just need a little unpacking.
19:54:26 <monochrom> Feymann has examples during his days in the Manhatten project
19:56:02 <applicative> tg_ your problems are multiplied by wanting 3-D *and* whatever this many-number-types-at-once idea is.
19:56:43 <tg_> applicative: I know. This many-number-types-at-once has a geometric and physical motivation, so it's a serious idea
19:56:46 <tg_> even if it's not expressed clearly
19:56:59 <applicative> tg_ I mean, at the same time.  Why not  just try to define data TG = ....  where you think of TGs as carrying several around, they'd have a Num instance, I guess
19:58:01 <tg_> applicative: yeah, I think part of this is not giving credit to haskell in being able to handle what I want, and assuming I'm going to have to fit in some other framework's shoes (like *exactly* the vector-space package)
19:58:14 <tg_> or *exactly* the basic definition of a 3-vector
20:00:00 <applicative> tg_ I just mentioned vector-space as being in the same neighborhood.  The fancy extension he uses is TypeFamilies I see
20:00:18 * applicative is ignoring UndecidableInstances which is over his head anyway
20:00:19 <tg_> applicative: what kind of fancy difficulties does TypeFamilies bring to the table?
20:00:48 <tg_> applicative: I can be certain (yes, certain) that the infinite data structures I'm working with can terminate.
20:00:55 <tg_> applicative: s/can terminate/*do* terminate
20:01:16 <tg_> so that is a restriction not normally afforded by any inhabitant of Num or even Integral, from what I understand
20:02:15 <applicative> so far there doesn't seem to be anything particularly 'infinite' in the values you are contemplating.
20:02:49 <tg_> applicative: yes, I haven't discussed the structure of what I'm actually going to use, yet... but it may as well be something along the lines of [Integer, Integer, Integer, Double]
20:02:54 <tg_> for every single Num
20:03:18 <tg_> I don't expect an answer, I'm just looking for a direction
20:04:00 <SonicTheHedgehog> wow
20:04:17 * hackagebot http-enumerator 0.6.5 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.5 (MichaelSnoyman)
20:04:18 <SonicTheHedgehog> It's amazing how many people you can find on mIRC!
20:04:33 <SonicTheHedgehog> All hiding in different places!
20:04:33 <tg_> SonicTheHedgehog: IRC, mIRC is a client. And yes, it is.
20:05:03 <SonicTheHedgehog> =)
20:05:34 <dmwit> Is there a strict(er) version of modifyIORef?
20:05:34 <applicative> tg_ well, my dubious wisdom is exhausted with a link to the vector-space package....
20:06:31 <dmwit> e.g. is "modifyIORef' f ref = readIORef ref >>= \x -> let y = f x in y `seq` writeIORef ref y" in a library somewhere?
20:06:55 <tg_> applicative: hehe. That will have been good enough. I would have eventually checked it (i mean, it's called vector-space...) but knowing it's written by conal means I'll go through it now.
20:07:37 <SonicTheHedgehog> This must be the smart people room!
20:08:15 <shachaf> dmwit: I think that came up a few days ago and was answered with "no".
20:08:22 * shachaf may not be remembering correctly, though.
20:09:02 <dmwit> thanks
20:09:29 <dmwit> I don't mind inventing square wheels, so long as nobody else invented them yet. =)
20:14:17 <SonicTheHedgehog> Okay, so this room is just for a specific language.
20:14:34 <SonicTheHedgehog> Got it
20:14:53 <argiopeweb> SonicTheHedgehog: And math. You can talk about math.
20:14:54 <shachaf> SonicTheHedgehog: Yep. No confluence discussions in here.
20:15:02 <SonicTheHedgehog> I just pasted something from google to get here.
20:15:16 <SonicTheHedgehog> I should try to remember what math is.
20:15:21 <argiopeweb> That would be good.
20:15:22 * dmwit sighs
20:15:26 <SonicTheHedgehog> Been a year almost since I've seen any.
20:15:28 <JoeyA> > 2+2
20:15:29 <lambdabot>   4
20:15:33 <dmwit> I put my data behind one IORef, and now everything is broken.
20:15:46 <argiopeweb> dmwit: *dramatic chord*
20:16:16 <shachaf> SonicTheHedgehog: Pasted something from Google?
20:17:18 <SonicTheHedgehog> I googled programming chat and found the server and room name.
20:17:51 <shachaf> Uh-oh.
20:17:55 <shachaf> The Google has betrayed us.
20:17:59 <SonicTheHedgehog> lol
20:18:00 <argiopeweb> SonicTheHedgehog: What programming language are you into?
20:18:44 <SonicTheHedgehog> I'm a nib at programming.  Was just considering taking on a small personal project and was going to get advice on what language.
20:19:12 <argiopeweb> We're all going to say Haskell.
20:19:13 <SonicTheHedgehog> Not even sure if it will be a web app or console app.
20:19:15 <argiopeweb> :P
20:19:17 <SonicTheHedgehog> XD
20:19:30 <essial> heya guys.. quick question.. I'm trying to write a function to play with tuples
20:19:31 <SonicTheHedgehog> This is a nice sized room.
20:19:38 <JoeyA> If it's a web app, use PHP, because Everybody Uses PHP for Web Apps.  Everyone.
20:19:44 <SonicTheHedgehog> Considering I have never heard of haskell before.
20:19:54 <essial> The input is [("Bob", "Dole"), ("John", "Smith")] and i wrote a function to try to return the last names, but it doesn't work:
20:19:56 <SonicTheHedgehog> I can do php.
20:20:02 <essial> getLastNames x = [ n ++ "\n" | n <- (snd x) ]
20:20:09 <SonicTheHedgehog> More than any other language at least.
20:20:12 <essial> anyone wanna give me a hint at what i'm not understanding :)
20:20:16 <SonicTheHedgehog> Stupid question though.
20:20:18 <argiopeweb> > map snd [("Bob", "Dole"), ("John", "Smith")]
20:20:19 <lambdabot>   ["Dole","Smith"]
20:20:23 <dafis> essial:  (_, n) <- x
20:20:26 <SonicTheHedgehog> Is it possible to code a web app without paying?
20:20:35 <JoeyA> Of course.
20:20:38 <JoeyA> Paying whom?
20:20:44 <SonicTheHedgehog> I know I could when I was in college but we had a server there.
20:20:44 <AardMark> lol
20:20:47 <essial> AHAH dafis
20:20:49 * essial hugs
20:20:55 <essial> I actually understand that line and it scares me :p
20:21:01 <essial> (the fact I understand it)
20:21:20 <JoeyA> There are plenty of web server programs for various operating systems.
20:21:31 <dafis> essial:  but for stuff like this, map snd is IMO better than a list comprehension
20:21:32 <JoeyA> Do expect to pay someone if you want to host your web app publicly.
20:21:40 <essial> I'm just learning and reading lyah
20:21:56 <SonicTheHedgehog> I wasn't sure if you had to pay to run php files.
20:21:58 <SonicTheHedgehog> lol
20:21:58 <essial> YES :D
20:22:04 <JoeyA> pay me
20:22:05 * essial is starting to get it
20:22:15 <dafis> essial:  that's nice
20:22:19 <JoeyA> I didn't write PHP, but I need money for a car.
20:22:23 <essial> (_, n) <- x    is pure sweetness
20:22:41 <SonicTheHedgehog> Program the car in php =/
20:22:47 <essial> my imperitive programming mind didn't even think about that
20:22:49 <JoeyA> SonicTheHedgehog: If you're looking for a good way to kill time this summer, I highly recommend learning Haskell :-)
20:23:23 <argiopeweb> essial: hlint is going to tell you to use snd. :P
20:23:24 <JoeyA> > [1..5]
20:23:24 <lambdabot>   [1,2,3,4,5]
20:23:31 <JoeyA> > map (*2) [1..5]
20:23:32 <lambdabot>   [2,4,6,8,10]
20:23:53 <JoeyA> map (\x -> x^x) [0..10]
20:24:04 <JoeyA> crash!
20:24:07 <essial> lulz
20:24:08 <dafis> > map (join (*)) [1 .. 5]
20:24:08 <lambdabot>   [1,4,9,16,25]
20:24:09 <JoeyA> err
20:24:17 <SonicTheHedgehog> What kinds of projects use it well, and/or what sorts of companies use it?
20:24:24 <essial> [1,3..]
20:24:27 <essial> lulz :)
20:24:28 <JoeyA> The latter is a very good question.
20:24:44 <dafis> > map (join (^)) [1 .. 5]
20:24:44 <lambdabot>   [1,4,27,256,3125]
20:25:03 <JoeyA> Although "Jane Street" uses Haskell, I think the most convincing reason to learn Haskell is to make you a better programmer overall.
20:25:24 <argiopeweb> As does Galois.
20:25:32 <argiopeweb> (or however the hell you spell their name)
20:25:33 <dmwit> > map (\x -> x^x) [1..10] -- 10 isn't nearly big enough to make this crash
20:25:33 <lambdabot>   [1,4,27,256,3125,46656,823543,16777216,387420489,10000000000]
20:25:40 <shachaf> Since when does Jane Street use Haskell?
20:25:46 <dmwit> > 0^0
20:25:47 <lambdabot>   1
20:25:56 <essial> nice job
20:25:59 <shachaf> lambdabot: Liar!
20:26:06 <essial> that's not a liar..
20:26:11 <essial> anything to the power of 0 is 1
20:26:12 <essial> even 0 :p
20:26:13 <dafis> shachaf:  huh?
20:26:21 <shachaf> 0 to the power of anything is 0.
20:26:27 * essial facepalms
20:26:30 <dmwit> shachaf: There's one function between the empty set and the empty set.
20:26:33 <JoeyA> :t (/0^0) -- the glasses combinator
20:26:34 <lambdabot> forall a. (Fractional a) => a -> a
20:26:37 <dafis> shachaf:  no, anything to the power of 0 is 1
20:26:45 <shachaf> Isn't 0^0 generally taken to be undefined?
20:26:46 <essial> :t 1^0
20:26:46 <lambdabot> forall t. (Num t) => t
20:26:50 <essial> 1^0
20:26:58 <essial> gah how do you use the friggen bot :p
20:27:04 <essial> > 1^0
20:27:04 <lambdabot>   1
20:27:04 <dmwit> > 1^0
20:27:05 <lambdabot>   1
20:27:10 <essial> [1..3]^0
20:27:16 <argiopeweb> > bottom^0
20:27:17 <lambdabot>   Not in scope: `bottom'
20:27:23 <argiopeweb> dum-dum-dum
20:27:25 <SonicTheHedgehog> 0^X = 0 IFF X != 0
20:27:37 <SonicTheHedgehog> 0^X = 1 IFF X = 0
20:27:45 <JoeyA> > map (0^) [-5..5]
20:27:46 <lambdabot>   [*Exception: Negative exponent
20:27:53 <essial> if you don't know that anything to the power of 0 is 1, you fail at very basic math
20:27:53 <JoeyA> aw shaddup
20:27:57 <JoeyA> > map (0**) [-5..5]
20:27:58 <lambdabot>   [Infinity,Infinity,Infinity,Infinity,Infinity,1.0,0.0,0.0,0.0,0.0,0.0]
20:28:08 <dafis> SonicTheHedgehog:  0^x = 0 iff (real part) x > 0
20:28:31 <shachaf> essial: Glad to hear that.
20:28:55 <shachaf> Is there any reasoning for this other than "we defined ^ this way"?
20:28:57 <argiopeweb> > (0**(-1))^0
20:28:57 <lambdabot>   1.0
20:29:05 <argiopeweb> Infinity ^ 0 == 1
20:29:06 <essial> because it works in math
20:29:15 <dmwit> shachaf: Yes. a^b is the number of functions from a set of size b to a set of size a
20:29:23 <dafis> shachaf:  it's the practical definition
20:29:27 <SonicTheHedgehog> right
20:29:29 <dmwit> shachaf: Hence my comment above about empty sets and functions between them.
20:29:36 <JoeyA> > (-5) `mod` 7 -- thank you for getting this right, Haskell!
20:29:36 <lambdabot>   2
20:29:56 <JoeyA> Many languages are lame and implement modulus like this:
20:30:00 <JoeyA> > (-5) `rem` 7
20:30:00 <lambdabot>   -5
20:30:06 <JoeyA> Haskell has both :-)(
20:30:20 <dafis> > 5 `rem` (-7)
20:30:20 <lambdabot>   5
20:30:25 <dafis> > 5 `mod` (-7)
20:30:26 <lambdabot>   -2
20:30:30 <shachaf> dmwit: It's kind of nice for it to be a continuous function, though.
20:30:41 <essial> so now I have  getLastNames x = [ n | (_, n) <- x ]      , would that be an 'acceptable' way to do it?
20:30:42 <dmwit> shachaf: ...uh, I think I got that backwards, actually. The functions go the other way.
20:30:46 <dafis> shachaf:  for what?
20:30:56 <argiopeweb> essial: map snd
20:31:00 <dmwit> shachaf: Anyway, there's no hope of it being continuous in both arguments near (0,0), so why bother complaining?
20:31:14 <shachaf> I suppose that's true.
20:31:30 <argiopeweb> essial: Then you can get rid of the comprehension and use currying
20:31:48 * shachaf thought that in cases like this it was standard to take it as undefined.
20:31:55 <essial> i see
20:31:58 <essial> makes sense
20:32:16 <argiopeweb> In general, list comprehensions aren't the most elegant way to do things.
20:32:57 <dmwit> shachaf: Some people may take it as undefined.
20:33:00 <essial> > [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1] ]
20:33:01 <lambdabot>   [(1,1,1),(1,2,1),(1,3,1),(1,4,1),(1,5,1),(1,6,1),(1,7,1),(1,8,1),(1,9,1),(1...
20:33:02 <dafis> they are fine if you combine a couple of generators and filters though
20:33:05 <essial> neat
20:33:08 <Nereid> getLastNames = map snd
20:33:17 <essial> yeah i understand it
20:33:20 <shachaf> http://www.wolframalpha.com/input/?i=0^0
20:33:21 <Nereid> k
20:33:46 <dmwit> > [(1,b,c) | c <- [1..10], b <- [1..10]] -- why bother iterating a?
20:33:46 <lambdabot>   [(1,1,1),(1,2,1),(1,3,1),(1,4,1),(1,5,1),(1,6,1),(1,7,1),(1,8,1),(1,9,1),(1...
20:34:15 <essial> so does haskell do vector math natively, like dot, cross, and such
20:34:16 * argiopeweb doesn't remember how to do that with the list monad... :\
20:34:33 <essial> dmwit: I modded it so i wouldn't bombard the channel (just incase)
20:34:35 <dmwit> > do { c <- [1..10]; b <- [1..10]; return (1,b,c) }
20:34:36 <lambdabot>   [(1,1,1),(1,2,1),(1,3,1),(1,4,1),(1,5,1),(1,6,1),(1,7,1),(1,8,1),(1,9,1),(1...
20:34:44 <essial> it was [1..10]
20:34:52 <argiopeweb> dmwit: Ah, yes.  Thanks.
20:35:04 <dmwit> essial: Ah, thanks. =)
20:35:51 <Nereid> [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1,undefined] ]
20:35:54 <dafis> essial:  but the bot cuts off her responses
20:35:55 <Nereid> > [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1,undefined] ]
20:35:56 <lambdabot>   [(1,1,1),(*Exception: Prelude.undefined
20:36:01 <Nereid> oh
20:36:09 <Nereid> > [ (a,b,c) | c <- [1,undefined], b <- [1..10], a <- [1..10] ]
20:36:10 <lambdabot>   [(1,1,1),(2,1,1),(3,1,1),(4,1,1),(5,1,1),(6,1,1),(7,1,1),(8,1,1),(9,1,1),(1...
20:36:17 <Nereid> bored
20:36:22 <dmwit> > [a | a <- [1..10], [1, 2]]
20:36:22 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:36:22 <lambdabot>         against inferred type ...
20:36:38 <Nereid> > [a | a <- [1..10], _ <- [1, 2]]
20:36:39 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
20:37:05 <Nereid> I guess it thought [1,2] was supposed to be a guard
20:37:33 <dmwit> Yep. I was wondering whether it would try to do type inference to decide whether it was a guard or a mote.
20:37:38 <gaiusp> Considering learning haskell. read about the lazy aspect of the language, that it leads to unexpect result for long running operation. Want to understand more. Is there any good article that explain the pros and cons of this laziness to beginner?
20:37:42 <dmwit> Thank goodness it doesn't.
20:37:59 <essial> so if I say.. doAdd x y z = x + y + z....  it really is doing    return (add x, (add y, z))   right?
20:38:01 <essial> in theory
20:38:08 <dmwit> No.
20:38:31 <essial> then why would it be defined as Int -> Int -> Int -> Int :p
20:38:47 <dmwit> Why would it call return?
20:38:50 <dmwit> And what is "add"?
20:38:52 <Nereid> and why would it make tuples
20:38:56 <essial> that's not real code.....
20:39:02 <Nereid> if add = (+), then it's add x (add y z)
20:39:02 <dmwit> ...and what's with the tuples, exactly.
20:39:04 <argiopeweb> essial: And that's not how we use return. :P
20:39:08 <Nereid> or does it associate the other way
20:39:08 <essial> I know..
20:39:26 <argiopeweb> gaiusp: Can you cite the source of said claim? I've never heard laziness being blamed for long-running code problems.
20:39:29 <dmwit> Maybe you should rephrase your question.
20:39:32 <essial> that's what i meant nereid
20:39:40 <Nereid> > a + b + c
20:39:40 <essial> I just want to make sure I understand what's going on there
20:39:41 <lambdabot>   a + b + c
20:39:42 <Nereid> oh
20:39:46 <Nereid> > a + (b + c)
20:39:47 <lambdabot>   a + (b + c)
20:39:52 <Nereid> > (a + b) + c
20:39:53 <lambdabot>   a + b + c
20:39:54 <Nereid> right.
20:40:01 <essial> yeah, remember I'm trying to fully understand wtf is going on ;)
20:40:03 <argiopeweb> Left associative.
20:40:03 <essial> thanks guys :D
20:40:07 <Nereid> add (add x y) z
20:40:08 <Nereid> :c
20:40:09 <essial> rgr
20:40:10 <dmwit> In ghci, ":i +" will tell you "infixl 6 +".
20:40:15 <argiopeweb> Proof by exhaustive search.
20:40:16 <dmwit> In case you care to ask this about other operators.
20:40:17 <Nereid> too lazy to open ghci ;p
20:40:57 <gaiusp> arglopeweb: think its stackoverflow, will post it if I find it again.
20:41:22 <dafis> argiopeweb:  laziness makes reasoning about space behaviour less trivial than it is for strict languages, that's a difficulty that could grow with long-running apps
20:41:46 <Nereid> > foldl (+) 0 [1..1000000]
20:41:47 <lambdabot>   *Exception: stack overflow
20:41:48 <Nereid> > foldl' (+) 0 [1..1000000]
20:41:49 <lambdabot>   500000500000
20:42:00 <Nereid> problem being foldl is too lazy
20:42:11 <argiopeweb> gaiusp: Nobody will deny that laziness can cause performance issues (specifically with memory usage), but it's easily manageable if you pay attention.
20:42:28 <argiopeweb> dafis: I can see that being true.
20:42:35 <essial> > factorial 50
20:42:36 <lambdabot>   Not in scope: `factorial'
20:42:41 <Nereid> > product [1..50]
20:42:42 <lambdabot>   30414093201713378043612608166064768844377641568960512000000000000
20:42:48 <essial> wow
20:42:53 <JoeyA> > product [1..0]
20:42:53 <lambdabot>   1
20:42:54 <Nereid> @src product
20:42:55 <lambdabot> product = foldl (*) 1
20:42:56 * essial claps
20:43:04 <Nereid> eh, it's not foldl'
20:43:14 <argiopeweb> >product [50,49..1]
20:43:19 <Nereid> space
20:43:21 <argiopeweb> > product [50,49..1]
20:43:22 <lambdabot>   30414093201713378043612608166064768844377641568960512000000000000
20:43:25 <argiopeweb> Yep...
20:43:40 <essial> friggen win, unbounded numbers
20:43:42 * argiopeweb really wanted that to be something different...
20:43:53 <c_wraith> I wonder if lambdabot has the right version of ghc for this to work...
20:44:07 <c_wraith> > let (!) n = product [1..n] in (50!)
20:44:07 <lambdabot>   30414093201713378043612608166064768844377641568960512000000000000
20:44:16 <dafis> > foldl' (^) 1 [2 .. 1000]
20:44:16 <lambdabot>   1
20:44:17 <argiopeweb> Apparently.
20:44:28 <c_wraith> heh.  By the language spec, that really should work :)
20:44:34 <gaiusp> argiopeweb: dafis: guess i'm too new to Haskell to understand what you are talking about :-)
20:44:35 <c_wraith> err, *shouldn't
20:44:35 <JoeyA> c_wraith: Is that a section whose type isn't forced to be a function?
20:44:44 <c_wraith> JoeyA: yes
20:44:50 <JoeyA> Cool.
20:44:51 <argiopeweb> gaiusp: Long story short: don't worry about performance until it becomes an issue.
20:44:56 <c_wraith> JoeyA: well, at least not a two-arg function
20:45:03 <Nereid> gaiusp: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
20:45:14 <Nereid> observe the difference between foldl and foldl'
20:45:17 <argiopeweb> gaiusp: If you aren't well-equipped to handle it by that point, #haskell will still be here. :P
20:45:37 <JoeyA> I used that trick in a little interpreter I wrote that supports Haskell-style infix.
20:45:49 <JoeyA> But I used it to implement ranges
20:46:01 <JoeyA> let (..) a b = [a..b]
20:46:03 <JoeyA> > let (..) a b = [a..b]
20:46:03 <lambdabot>   <no location info>: parse error on input `..'
20:46:20 <JoeyA> > let (...) a = [a..]
20:46:21 <lambdabot>   not an expression: `let (...) a = [a..]'
20:46:22 <gaiusp> :P
20:46:26 <c_wraith> .. is syntax in haskell, despite . and ... not being syntax :)
20:46:29 <JoeyA> > let (...) a = [a..] in (0...)
20:46:30 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:46:32 <argiopeweb> > let (..) a b = [a..b] in 1 .. 5
20:46:33 <lambdabot>   <no location info>: parse error on input `..'
20:48:38 <dmwit> > product [1..100000]
20:48:41 <lambdabot>   mueval-core: Time limit exceeded
20:48:44 <dmwit> > foldb (*) 1 [1..100000]
20:48:45 <lambdabot>   282422940796034787429342157802453551847749492609122485057891808654297795090...
20:48:53 <Nereid> @src foldb
20:48:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:48:55 <JoeyA> @type foldb
20:48:55 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
20:48:57 <Nereid> what is that
20:49:20 <dmwit> http://hpaste.org/46640/foldb
20:49:20 <Nereid> b = binary?
20:49:44 <dmwit> b = both, haha
20:50:20 <dmwit> It requires its operation to be associative.
20:50:23 <dafis> b = better
20:50:35 <dmwit> > foldb (*) z [a,b,c,d,e,f,g]
20:50:36 <lambdabot>   z * a * (b * c) * (d * e * (f * g))
20:50:55 <dmwit> That representation loses some of the symmetry.
20:51:05 <dmwit> ((z * a) * (b * c)) * ((d * e) * (f * g))
20:51:08 <JoeyA> What is it for?
20:51:23 <argiopeweb> Are unboxed, unlifted types inherently strict?
20:51:25 <dafis> JoeyA:  *much* faster product for long lists
20:51:30 <JoeyA> Ah, I see
20:51:33 <dmwit> It turns out that some operations work better when the two arguments to the operation are "about the same size".
20:51:50 <dmwit> (*) is one of these operations.
20:52:06 <dmwit> If you fold (*) along a list, pretty quickly one of the values is very large, and the list elements are much smaller in comparison.
20:52:14 <argiopeweb> dmwit: So why isn't product implemented with foldb?
20:52:22 <pikhq_> argiopeweb: Hysterical raisins.
20:52:28 <argiopeweb> As usual...
20:52:29 <dmwit> If, instead, you multiply each neighbor, then iterate that process until only one element is left, all the list elements stay "about the same size" all the time.
20:52:32 <c_wraith> those raisins, again
20:52:48 <argiopeweb> pikhq_: Still, the underlying implementation shouldn't change functionality.
20:53:05 <dmwit> argiopeweb: foldb has different strictness properties =(
20:53:05 * argiopeweb wonders about a newer, more moder Prelude...
20:53:14 <argiopeweb> Ah, of course.
20:53:31 <JoeyA> > product [0..]
20:53:40 <dafis> argiopeweb:  and it requires an associative multiplication
20:53:48 <lambdabot>   thread killed
20:53:59 <dmwit> I think if you write a Num instance with a non-associative multiplication you are Doing It Wrong.
20:54:02 <JoeyA> As far as I can tell, product is strict in its entire input list.
20:54:03 <argiopeweb> dafis: You know a non-associative multiplication?
20:54:12 <JoeyA> :t product
20:54:15 <dafis> argiopeweb:  Cayley's octaves
20:54:18 <lambdabot> forall a. (Num a) => [a] -> a
20:54:27 <Nereid> octonions*
20:54:45 <pikhq_> argiopeweb: Floating point numbers (which are, annoyingly, an instance of Num) don't have associative multiplication.
20:54:56 <argiopeweb> dafis: Ah, indeed.
20:54:57 <dafis> Nereid:  they were called Oktaven when I was at uni
20:54:59 <JoeyA> If product is strict in its entire input list, then why should it matter if foldb is being used?
20:55:07 <argiopeweb> pikhq_: That's an issue with the standard though, correct?
20:55:26 <argiopeweb> dafis: I know them as octonions as well.
20:55:30 <JoeyA> Sounds like an issue with floating-point multiplication, if you ask me :-)
20:55:37 <Nereid> dafis: in English they're called octonions.
20:55:49 <argiopeweb> 8-sided bulbs.
20:55:59 <JoeyA> If I say "octonions" to someone, they will ask me to "speak English"
20:56:00 <dafis> argiopeweb:  yes, it seems that's the new name, but old habits die hard
20:56:03 <pikhq_> argiopeweb: Well, Float being an instance of Num is an issue with the standard, I'd argue.
20:56:27 <pikhq_> But non-associative multiplication on the floats is a problem inherent in floating-point numbers.
20:56:54 <argiopeweb> pikhq_: I would tend to agree. I don't think we should forego IEEE, but an IEEE float and an arbitrary precision float would be nice.
20:57:06 <argiopeweb> Either way, they wouldn't go in Num.
20:57:10 <dafis> > pi :: CReal
20:57:12 <lambdabot>   3.1415926535897932384626433832795028841972
20:57:33 <dafis> > show (pi :: CReal) !! 1000
20:57:34 <lambdabot>   *Exception: Prelude.(!!): index too large
20:57:36 <Nereid> > exp (0 :+ pi) :: Complex CReal
20:57:37 <lambdabot>   (-1.0) :+ 0.0
20:57:40 <dafis> booh
20:57:50 <argiopeweb> dafis: My ghci doesn't know about CReal.
20:57:59 <JoeyA> :t Complex
20:58:00 <lambdabot> Not in scope: data constructor `Complex'
20:58:06 <JoeyA> @i Complex
20:58:06 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
20:58:16 <dafis> argiopeweb:  it's not in the standard libraries
20:58:16 <JoeyA> :i Complex
20:58:28 <argiopeweb> dafis: Where would i find it?
20:58:32 <JoeyA> data RealFloat a => Complex a
20:58:32 <argiopeweb> s/i/I/
20:58:49 <Nereid> the numbers package
20:58:52 <Nereid> Data.Number.CReal
20:58:57 <dafis> argiopeweb:  dunno, I just know the bot has it
20:59:02 <argiopeweb> dafis: hehe...
20:59:06 <argiopeweb> Nereid: Thanks.
20:59:38 <Nereid> > let minusone = exp (0 :+ pi) :: Complex CReal in minusone == -1
20:59:39 <lambdabot>   True
20:59:46 <Nereid> :c
20:59:52 <Nereid> > let minusone = exp (0 :+ pi) :: Complex Double in minusone == -1
20:59:53 <lambdabot>   False
21:00:07 <Nereid> > exp (0 :+ pi) :: Complex Double
21:00:08 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
21:00:10 <Nereid> heh.
21:00:19 <dafis> > exp (0 :+ pi) :: Complex Double
21:00:20 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
21:00:42 <pikhq_> Nereid: Remember, floating point does not do what you expect.
21:00:47 <Nereid> I know.
21:00:53 <Draconx|Laptop> floating point does exactly what one expects.
21:00:54 <argiopeweb> Ever.
21:00:58 <Nereid> well
21:00:59 <Nereid> rather
21:01:02 <Nereid> it does what I expect
21:01:04 <Nereid> but I don't expect much of it
21:01:05 <dafis> pikhq_:  unless you know what to expect :)
21:01:09 <pikhq_> dafis: Well, yes.
21:01:14 <argiopeweb> Draconx: Only if one expects the Spanish Inquisition on a regular basis.
21:01:53 <pikhq_> dafis: "Association and distribution do not hold." kinda breaks most people's expectations real quick.
21:02:37 <Draconx|Laptop> pikhq_, so?  They don't hold for Int (with undefined results on overflow), either.
21:02:38 <dafis> pikhq_:  yes, you have to unlearn stuff if you want to work with floating point successfully
21:03:30 <dafis> Draconx|Laptop:  but usually int-overflow wraps
21:03:46 <dafis> so you have arithmetic moduo 2^n
21:03:57 <Draconx|Laptop> sometimes.  The Haskell report does not specify that behaviour.
21:03:57 <dafis> modu*l*o
21:04:08 <pikhq_> Draconx|Laptop: I consider such behavior not all that relavent to intuition of how the type works ordinarily.
21:04:22 <pikhq_> Draconx|Laptop: Just like I'm not discussing IEEE float's NaN.
21:04:24 <dafis> Draconx|Laptop:  right, but it's what most ALUs do
21:04:32 <Draconx|Laptop> pikhq_, nevertheless, it means that addition of ints is not associative.
21:04:45 <Draconx|Laptop> pikhq_, and that rearranging parentheses may affect the meaning of your program.
21:04:50 <pikhq_> Yes, but on a technicality, rather than on a practical, common basis.
21:05:00 <dafis> Draconx|Laptop:  is not *necessarily* associative
21:05:10 <dmwit> What?
21:05:14 <dmwit> Addition of ints is associative.
21:05:20 <dmwit> ...at least in Haskell.
21:05:29 <Draconx|Laptop> dmwit, no, because the behaviour on overflow is not defined.
21:05:39 <dmwit> That's not true.
21:05:58 <dafis> dmwit:  I think the standard doesn't define the behaviour
21:06:40 <dafis> I'd be happy if it specified strict modulo 2^n, though
21:06:42 <Draconx|Laptop> in fact, it explicitly says that it's undefined.
21:07:08 <dmwit> Well, I'll be damned.
21:07:17 <dafis> Draconx|Laptop:  do you happen to know the place in the report?
21:07:49 <Draconx|Laptop> 6.4: Numbers in haskell 2010.
21:07:51 <dmwit> Table 6.1, and the paragraph above.
21:08:18 <dafis> thx
21:08:35 <Nereid> just use Integer and you're safe
21:12:23 <essial> ok what was the command again to run a .hs without having to compile first?
21:13:08 <dafis> essial:  runhaskell
21:13:12 <dafis> or runghc
21:13:16 <dafis> or runhugs
21:16:01 <essial> thx :)
21:18:24 * hackagebot newt 0.0.3.0 - A trivially simple app to create things from simple templates.  http://hackage.haskell.org/package/newt-0.0.3.0 (RoganCreswick)
21:18:44 <argiopeweb> Are there possible down-sides to using unbox-strict-fields?
21:20:28 <jmcarthur> argiopeweb: yes. you have to be wary of needless reboxing in various functions or other data structures
21:20:53 <argiopeweb> jmcarthur: Hmm, good point.
21:21:24 <dons> argiopeweb: in practice, i've never seen it make things worse
21:21:39 <dons> so i'd say no. just use it. should be on by default, imo.
21:21:44 <jmcarthur> well, i've never *noticed* it make things worse
21:21:52 <dons> heh :)
21:22:00 <argiopeweb> But it could in theory. Good thing practice never follows theory. :P
21:22:05 <dons> theoretically, the reboxing is in the noise.
21:22:48 <argiopeweb> Besides, if it doesn't work out right, I can just say "dons said it doesn't make things worse" and someone will fix GHC to make it true.
21:22:53 <argiopeweb> XD
21:22:56 <jmcarthur> lol
21:23:05 <dafis> jmcarthur:  I'm sure, if he tried, dons could write something where unbox-strict-fields hurts
21:23:51 <jmcarthur> it would be pretty easy by forcing certain optimizations not to happen, i think
21:24:02 <danharaj> I'm sure if you asked Oleg he could guarantee it never hurts at the type level.
21:24:03 <jmcarthur> but those are not things you would do in real life
21:24:13 <dafis> jmcarthur:  I meant without cheating
21:27:07 * argiopeweb is reading RWH's chapter on profiling and optimization... stream fusion == epic win
21:27:15 <jmcarthur> yeah stream fusion rocks
21:27:41 <jmcarthur> kind of annoying to write stream fusable libraries though. seems like such a mechanical transformation that the compiler really should be doing it
21:27:44 <argiopeweb> Now I have to go learn how the ghc rewrite rule system works. :\
21:28:20 <issactrotts> Trying out ghci as my shell. echo /usr/bin/ghci >> /etc/shells && chsh -s /usr/bin/ghci
21:28:25 <issactrotts> wish me luck
21:28:35 <jmcarthur> good luck
21:28:36 <argiopeweb> issactrotts: Good luck.
21:28:39 <issactrotts> thanks!
21:29:04 <argiopeweb> Let us know how it works out. I've been thinking about writing a haskell shell, but there's no point if it works with ghci. ;)
21:29:57 <issactrotts> Well, I'll probably have to write a bunch of things to make it comfortable. I'll wear the hair shirt for a while and see if it gets less hairy.
21:30:39 <argiopeweb> Best metaphor ever.
21:31:21 <jmcarthur> Haskell: It puts hair on your chest.
21:31:52 * jmcarthur is lame tonight
21:32:05 <jmcarthur> i'll stick to code
21:32:21 <argiopeweb> jmcarthur: Well, if you're going to be lame, I'll be blind. We just need deaf and mute and we've got an act.
21:32:37 <jmcarthur> i feel a little better now
21:33:27 <argiopeweb> Good good.  Now, back to the code with ya'. :P
21:36:48 <argiopeweb> unboxed -> strict, right?
21:42:29 <ddarius> Yes.
21:42:30 <dafis> argiopeweb:  well, strictly, strictness is a property of functions, so it's something different, unboxed means stuff is evaluated (and can't be _|_)
21:42:45 <ddarius> "unlifted"
21:43:16 <dafis> I think unboxed => unlifted, doesn't it?
21:43:23 <ddarius> Yes.
21:46:10 <argiopeweb> But not the other way around.
21:47:10 <argiopeweb> Though apparently you have to dig in the runtime to find an example
21:49:54 <issactrotts> oh crap. i need to be able to define an action called vi that takes no args, but i also need a function called vi that takes any number of args for filenames. my haskell mojo is too weak for this.
21:50:32 <argiopeweb> issactrotts: vi :: [Maybe]?
21:50:43 <argiopeweb> Or even Maybe []
21:50:59 <argiopeweb> (insert type of your choice, obviously)
21:51:04 <jmcarthur> vi :: [String] -> IO () ?
21:51:14 <argiopeweb> jmcarthur: Aww, you're making this too easy. :(
21:51:26 <issactrotts> I wanted to be able to write just "vi" without quotes. Will have to just say vi [] instead. Meh.
21:51:31 <argiopeweb> Life's no fun if you just go for the easy answers.
21:51:47 <jmcarthur> maybe some sort of type class hackery could do it
21:52:35 <argiopeweb> issactrotts: You can do vi and vim. :P
21:52:47 <dafis> issactrotts:  :!vi ?
21:53:07 <ddarius> Unlifted is a semantic notion.  Unboxed is an implementation concept.
21:53:22 <issactrotts> The more I think about it, the more I like the straightforwardness of vi [].
21:53:32 <issactrotts> However, I have failed to even make that work.
21:53:39 * dafis prefers kwrite
21:53:45 <jmcarthur> class Vi a where vi :: a; instance Vi (IO ()) where ...   instance Vi b => Vi (String -> b) where ...     -- although i think you might have problems with type inference
21:53:48 <argiopeweb> Emacs, infidels.
21:53:49 <issactrotts> My attempt with let vi args = rawSystem "vi" args  does not work.
21:54:41 <argiopeweb> issactrotts: vi "func.txt" isn't doable?
21:54:54 <argiopeweb> I.E. have all the args as a single string
21:54:59 <ulfdoz> &aw
21:55:19 <ulfdoz> sorry, and good morning.
21:55:24 <issactrotts> That's worth a try.
21:57:20 <argiopeweb> issactrotts: The way I would probably end up doing it is having a function runNative :: String -> Maybe a -> IO () called by a parseCommands which would format properly based on the command line into a command name and an args list in Maybe.
21:57:21 <issactrotts> Oh, never mind, I moved the standard vi out of the way so I could use /opt/local/bin/vi without rearranging my path. So I have to define it like this  let vi args = rawSystem "/opt/local/bin/vi" args.
21:57:41 <argiopeweb> Ah, that works.
21:59:54 <issactrotts> dafis: thanks, I didn't know about that. :-)
22:06:30 * hackagebot newt 0.0.3.1 - A trivially simple app to create things from simple templates.  http://hackage.haskell.org/package/newt-0.0.3.1 (RoganCreswick)
22:13:53 <blackdog> hlint is not good for the ego
22:15:15 <dafis> blackdog:  why?
22:26:30 <issactrotts> :cd is a killer. It destroys all your bindings.
22:27:02 <shachaf> issactrotts: Pretty impressive undocumented behavior.
22:27:11 <argiopeweb> <.<
22:27:30 <issactrotts> It's documented: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/ghci-commands.html
22:28:15 <issactrotts> That alone makes ghci a pretty questionable choice for a shell.
22:28:37 <shachaf> Was ghci-as-a-shell ever a question?
22:30:26 <shachaf> issactrotts: Anyway, it doesn't destroy :def bindings.
22:30:31 <issactrotts> I'm trying it.
22:30:47 <issactrotts> Cold comfort I'm afraid.
22:37:18 <quicksilver> if you were using a haskell shell written in ghci, you wouldn't use :cd to cd. You'd have a specific command for that and you'd track CWD yourself.
22:37:52 <miguel-hs> Is a data type unlifted if all of its constructors are strcit?
22:38:01 <shachaf> quicksilver: You mean you wouldn't use the process's CWD?
22:38:03 <shachaf> miguel-hs: No.
22:38:06 <shachaf> @wiki Newtype
22:38:07 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
22:39:33 <miguel-hs> shachaf: Ok, so the only unlifted types are the primitive ones?
22:39:56 <shachaf> miguel-hs: No.
22:39:58 <shachaf> @wiki Newtype
22:39:58 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
22:40:16 <issactrotts> quicksilver: wouldn't that make a lot of commands not work as expected?
22:40:54 <shachaf> issactrotts: I guess you'd handle that in the process-launching code?
22:42:08 <issactrotts> I guess, but I would guess that still breaks Haskell functions like readFile.
22:43:07 <shachaf> You could do it for every IO action. :-)
22:43:15 <shachaf> I don't know, seems like an odd suggestion.
22:45:33 <issactrotts> I think you have to abandon cd to make this work. Kinda painful.
22:46:55 <issactrotts> ttyl
23:03:10 <jmcarthur> @tell issactrotts what about System.Directory.setCurrentDirectory ?
23:03:11 <lambdabot> Consider it noted.
23:05:55 <argiopeweb> So, how is GHCI actually implemented? It seems like it would either have to be a DSL mimicking Haskell and capable of running interactively, or a tightly-coupled interface to the runtime.
23:08:15 <Twey> argiopeweb: The latter
23:09:33 <shachaf> argiopeweb: It's domain-specific where the domain is being Haskell.
23:09:40 <shachaf> (What does "DSL" mean in this context, exactly?)
23:11:39 <argiopeweb> shachaf: Haskell interpreter in haskell but not directly interfacing with the RTI.
23:11:53 <napping> It's hooked into the runtime
23:11:58 <shachaf> What makes that domain-specific?
23:12:00 <napping> but a bytecode interpreter
23:12:17 <Guest37335> @hoogle (a, a) -> (a -> b) -> (b, b)
23:12:18 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
23:12:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
23:12:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
23:12:56 <argiopeweb> shachaf: In that it would be incapable of implementing the entire language due to interpretation limitations, thereby leading to a reduced/limited Haskell.
23:13:08 <argiopeweb> Thus specific to the domain of interpreted REPL haskell.
23:13:23 <Guest37335> @hoogle (a -> b, a -> c) -> a -> (b, c)
23:13:23 <lambdabot> No results found
23:13:32 <Guest37335> hurm
23:13:33 <argiopeweb> Though it's possible that it's just 2AM and I'm spewing BS. ;)
23:14:17 <shachaf> @ty uncurry (&&&)
23:14:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
23:14:30 <shachaf> @ty uncurry (&&&) :: (a -> b, a -> c) -> a -> (b, c)
23:14:31 <lambdabot> forall a b c. (a -> b, a -> c) -> a -> (b, c)
23:17:57 <kamatsu> random CS question:
23:18:16 <kamatsu> how to compute if the sum of two binary numbers is a palindrome in logarithmic space?
23:18:45 <kamatsu> (keeping in mind that if you just compute the sum, that's not log space anymore..)
23:19:22 <kamatsu> ah, nevermind, got it
23:19:29 <Guest37335> @hoogle &&&
23:19:29 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
23:19:51 <Guest37335> I heard Control.Category and Control.Applicative subsume arrows.
23:20:04 <Guest37335> What is the non-arrow version of this function?
23:20:25 <shachaf> Guest37335: It's just (&&&). Why do you care if it comes from Control.Arrow?
23:20:25 <companion_cube> kamatsu, what is the solution ?
23:20:48 <Guest37335> because I try to import as few modules as possible
23:21:00 <shachaf> Oh.
23:21:11 <shachaf> @djinn (a->b,a->c)->a->(b,c)
23:21:11 <lambdabot> f (a, b) c = (a c, b c)
23:21:15 <shachaf> @. pl djinn (a->b,a->c)->a->(b,c)
23:21:16 <lambdabot> f = uncurry (liftM2 (,))
23:21:35 <shachaf> There you go. liftM2 (,)
23:21:45 <shachaf> Or liftA2 if you like it Applicative.
23:21:52 <shachaf> (This has nothing to do with Applicative "subsuming" Control.Arrow.)
23:33:15 <argiopeweb> @src product
23:33:15 <lambdabot> product = foldl (*) 1
23:34:18 <mm_freak> i wonder why it's defined that way
23:34:32 <argiopeweb> We've had this discussion once today.
23:34:36 <argiopeweb> What do you see wrong with it?
23:35:23 <mm_freak> well, except in some corner cases (like lazy numbers) one would prefer foldl' over foldl
23:36:07 <napping> except in other corner cases, the strictness analyzer will sort that out
23:36:29 <kamatsu> companion_cube: you can compute the n'th digit of a binary sum with logarithmic space, right?
23:36:38 <mm_freak> napping: in my experience that doesn't work so well
23:36:45 <kamatsu> companion_cube: just discard results and remember the carry
23:36:54 <napping> Do you leave it generic?
23:37:07 <companion_cube> oh, with quadratic time, so ?
23:37:14 <mm_freak> napping: usually no
23:37:20 <mm_freak> napping: it works for compiled code
23:37:20 <napping> If the type is known (and you compile with -O), it should work out
23:37:25 <kamatsu> companion_cube: then, just figure out how many digits are in the sum (this can be done by computing the max(n,m) + 1th digit. If zero, it's max(n,m), otherwise max(n,m) + 1)
23:37:44 <mm_freak> napping: but i also like to use GHCi als a calculator sometimes
23:38:23 <kamatsu> companion_cube: then, compare length and start digits, then length - 1 and start +1, all of this never requires more space
23:39:05 <mm_freak> though usually i prefer PARI over GHCi
23:39:07 <kamatsu> companion_cube: the time complexity doesn't matter, just space.
23:39:13 <companion_cube> then i see
