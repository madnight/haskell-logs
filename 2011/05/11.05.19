00:00:21 <kmc> vLK, i didn't make the claim which is contradicted by that
00:00:47 <kmc> probably more people use Java out of ignorance than use C out of ignorance
00:00:51 <kmc> that's not my point
00:00:54 <argiopeweb> But yes, I can attest to pretty much all of that. Entry level here is Matlab (AE dept. insisted, we're working on switching it back to C), core CS/SE is Java, and C and Fortran are offered for the benefit of the Engineering Physics types,
00:01:11 <argiopeweb> They touch Scheme in programming language theory, but that's about it.
00:01:30 <vLK> I still don't agree, C is unfortunately growing more and more unpopular in favor of heavily abstracted languages like Python (and even C++)
00:01:50 <kmc> comparing C and Python is like comparing assembly and Python
00:01:56 <vLK> I didn't compare them
00:02:02 <kmc> assembly is becoming more unpopular in favor of Python! oh no!
00:02:09 <kmc> maybe... they're for different purposes
00:02:12 <vLK> Assembly was never very popular for user-end
00:02:23 <vLK> And is superflouus in that cas
00:02:36 <argiopeweb> Define user-end.
00:02:39 <kmc> false, for many years 100% of users programmed in assembly
00:02:46 <FUZxxl> Does someone know, when where type classes developed?
00:02:48 <kmc> actually that's false too, because some of them wrote machine code directly ;P
00:02:49 <vLK> argiopeweb, no, figure it out yourself
00:02:59 <kmc> FUZxxl, "type classes: exploring the design space" may have the references you seek
00:03:09 <argiopeweb> kmc: Don't put down my Fortran punch cards. <.<
00:03:13 <vLK> kmc, in i686-Windows-GNOME2 times.
00:03:20 <kmc> they were present in some Haskell-ancestor languages
00:03:23 <vLK> Or even eariler
00:04:25 <vLK> The only thing I ever used machine code for was learning, and it was definitely worthwhile.
00:06:44 <c_wraith> FUZxxl: the history of haskell suggests they were invented while haskell was in design, and they were added to the language without much debate.
00:06:59 <c_wraith> uh, the paper on the history of haskell, that is
00:08:47 <c_wraith> then, when the idea of using the monad pattern to structure IO came about, they added higher-kinded type classes.
00:20:54 <FUZxxl> c_wraith, kmc: Thanks.
00:20:58 <FUZxxl> I guess it's 1988
00:21:22 <FUZxxl> That's when this paper was publiushed: http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps
00:27:06 <hyungrok> @type id
00:27:06 <lambdabot> forall a. a -> a
00:27:53 <hyungrok> pl flip any [isUpper, isLower] . flip ($)
00:27:59 <hyungrok> @pl flip any [isAsciiUpper, isAsciiLower] . flip ($)
00:27:59 <lambdabot> flip any [isAsciiUpper, isAsciiLower] . flip id
00:28:50 <jmcarthur> "Hard work often pays off after time, but laziness always pays off now."
00:31:56 <exeter> I am developing a small application and I've got into error handling. I'm basically iterating through a tree and I would like to pass a LEFT STRING value in case of error and a RIGHT (otherstuff) when everything is ok. I've read on the book "real world haskell " that this approach (control.monad.error) kills laziness, right? Is there a better way, maybe using arrows?
00:32:14 <exeter> It's not tremendously important, but since I am learning I'd like to do it in the best possible way
00:32:46 <kmc> how does it kill laziness?
00:32:50 <kmc> and why do you think arrows will help?
00:33:51 <JuanDaugherty> exeter, so that's a nugatory from kmc with respect to the query about RWH
00:34:19 <kmc> nougat?
00:34:56 <Axman6> exeter: you could just use the Either monad couldn't you?
00:35:06 <kmc> i think that's what exeter is doing
00:35:10 <Axman6> > Left "Dang" >> Right True
00:35:10 <kmc> i was just asking what you meant by the laziness comment
00:35:11 <lambdabot>   Overlapping instances for GHC.Base.Monad
00:35:11 <lambdabot>                              (Data...
00:35:13 <exeter> JuanDaugherty: I fear I've understood little of what you've said :S
00:35:17 <Axman6> -_-
00:35:24 <exeter> thanks kmc , that's right Axman6
00:35:35 <kmc> when you check whether a value is Left foo or Right bar, it will force evaluation far enough to get that outermost constructor
00:35:41 <kmc> by necessity
00:36:01 <kmc> the check done by (>>=) has this property
00:36:13 <Axman6> @src Either (>>=)
00:36:13 <lambdabot> Left  l >>= _ = Left l
00:36:14 <lambdabot> Right r >>= k = k r
00:36:14 <kmc> but it doesn't force any further
00:36:23 <kmc> if i say «Right (2+2)» it doesn't need to force that 2+2 to 4
00:36:35 <exeter> kmc: brilliant!
00:36:54 <exeter> that's just what I was searching, it does not seem like a big burden this way
00:37:03 <Axman6> exeter: monads aren't really special. the only really special ones are IO, ST and STM
00:37:11 <Axman6> everything else is just functions
00:37:17 <exeter> should I use control.monad.error or control.monad.either ?
00:37:21 <Axman6> that you could easily define yourself
00:37:43 <exeter> Axman6: STM = State monad _?
00:37:55 <Axman6> Software Transactional Memory
00:38:06 * exeter hides in fear 
00:38:10 <Axman6> one of the coolest featurwes GHC has
00:38:23 <Axman6> makes writing safe concurrent code a hell of a lot easier than basically anything
00:38:27 <kmc> right, "Monad" is the name of a generic API.  that API is implemented differently for different types and can be something mundane or magical
00:38:53 <Axman6> like the reverse state monad...
00:38:58 <kmc> for lists, «x >>= f» is the same as «concatMap f x», very straightforward
00:39:10 <kmc> for STM, (>>=) is some deep compiler-dependent RTS-dependent trickery
00:39:49 <exeter> very good very good
00:40:10 <JuanDaugherty> which is why I considered a casual ghc port hubristic
00:40:10 <kmc> "Beautiful Concurrency" is a paper by SPJ that's supposed to explain STM without assuming lots of other Haskell knowledge
00:40:30 <exeter> so problem solved. As a last tip, should I use .either or .error ? "ncompatible with Control.Monad.Error, but removes the Error restriction that prevents a natural encoding of Apomorphisms. "
00:40:43 <exeter> ^-- quote from cont.monad.either
00:40:47 <kmc> probably Either
00:40:55 <kmc> Either is a standard Haskell type that's in the Prelude
00:41:03 <exeter> very good very good
00:41:13 <kmc> well i'm not sure if that argues for or against using it to represent errors
00:41:23 <kmc> Either is more popular in this role, anyway
00:41:59 <neurocyte> does anyone know some emacs magic to automatically create an import declaration for the symbol under the cursor?
00:42:02 * neurocyte is missing vim :(
00:42:44 <empity> neurocyte: you can write your function/macro for that
00:43:56 <frerich2> neurocyte: How did you do that in vim? :-)
00:44:04 <neurocyte> empity, sure, but I was hoping there was already a haskell-mode feature for it that I just couldn’t find
00:44:37 <neurocyte> vim’s haskell-mode plugin will search for modules in haddock that define a symbol and then create an import statement for it
00:45:15 <neurocyte> iirc, it’s mapped to '_i' in vim
00:46:18 <neurocyte> frerich2, ^^^
00:46:23 <frerich2> Coolness
00:48:22 <neurocyte> I’m a bit tired of typing :wq in web pages so I’m trying to learn emacs :) but vim’s haskell support seems a lot more useful so far.. :(
00:49:09 <empity> do you have an updated haskell mode http://projects.haskell.org/haskellmode-emacs/?
00:49:12 <empity> the darcs version?
00:49:28 <neurocyte> empity, yes
00:49:34 <empity> I think is quite nice as a mode, even if surely not the best programming mode
00:51:41 <neurocyte> empity, it is really nice to have real ghci integration
00:51:49 <neurocyte> vim just can’t do that at all
00:52:15 <neurocyte> but I’m missing vim’s cool haddoc search features
00:52:57 <neurocyte> vim can also insert type signatures, which is also something I haven’t found yet in emacs' haskell-mode
00:53:32 <empity> neurocyte: well that would not be ahrd
00:53:33 <empity> hard
00:53:50 <empity> since also haskell-mode tells you the type, you can just paste that on top
00:53:52 <empity> with a simp
00:54:29 <neurocyte> empity, no, I’m sure it’s not, but my emacs-fu is not up to speed yet
01:04:53 <erus`> when i close a glut window, it doesnt stop the glutmainloop
01:05:03 <erus`> is there a call back for window close or something?
01:07:15 <mm_freak> how do i log to the syslog in haskell?
01:07:29 <quicksilver> erus`: yes.
01:08:45 <erus`> shud be in the tutorial on the wiki imho
01:08:52 <quicksilver> although I have a feeling it's only supported in freeglut
01:08:58 <quicksilver> I think official glut may not do the close callback
01:09:29 <quicksilver> yeah, that's right.
01:09:36 <quicksilver> official glut just kills the program when the window closes.
01:11:51 <erus`> not on windows
01:14:35 <quicksilver> odd
01:14:49 <quicksilver> anyway when you get to the point of caring what happens when windows close, you've outgrown glut :)
01:14:58 <quicksilver> glut is handy for learning and quick cross-platform hacks.
01:15:54 <erus`> i would use glfw like i do in C++
01:16:09 <erus`> but getting cabal packages to build on windows....
01:17:26 <quicksilver> "GLFW doesn't work well with GHC threads, forkIO or threadDelay. So avoid them if you can"
01:17:30 <quicksilver> I wonder why that is.
01:17:33 <quicksilver> but that would put me right off it...
01:21:53 <kmc> even if you compile with -threaded and use bound threads?
01:24:12 <quicksilver> kmc: I don't know. I'm curious. Although not curioius enough to try ;)
01:24:24 <quicksilver> kmc: it seems like it *might* just be advice from someone who doesn't understand how to use bound threads.
01:24:28 <quicksilver> I hope so.
01:24:37 <quicksilver> if it's more serious than that it would be a really bad thing.
01:35:12 <blackdog> talk on WAI happening now if anyone's keen
01:35:12 <blackdog>   http://tims-video.appspot.com/fpsyd
01:38:57 * hackagebot concrete-typerep 0.1 - Binary and Hashable instances for TypeRep  http://hackage.haskell.org/package/concrete-typerep-0.1 (ReinerPope)
01:38:59 * hackagebot hxt-http 9.1.2 - Interface to native Haskell HTTP package HTTP  http://hackage.haskell.org/package/hxt-http-9.1.2 (UweSchmidt)
01:39:57 * hackagebot hxt 9.1.2 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.1.2 (UweSchmidt)
01:52:08 <snoobino> hello !
01:54:08 <snoobino> so I have this idea. It's an independent opengl window you run when you'r using ghci
01:54:34 <snoobino> so it can display directly whatever primitives you ask him on the prompt
01:55:37 <snoobino> do you think that'd be interseting ?
01:55:53 <snoobino> interesting sry
01:56:25 <MasseR> How do I use autoincrement fields with haskelldb? increment columns were mentioned in the haskelldb.pdf to be used with _default, but I don't quite understand how :/
01:57:01 <flux> snoobino, I think that is a too low-level goal. combine that with an engine and a thread running it during ghci, and you've got something flashy ;).
01:57:13 <flux> snoobino, (compare to interactive f# opengl demoes)
01:57:25 <flux> (uh, obviously directdraw or something, not opengl ;))
01:58:24 <snoobino> flux, what do you mean an engine ,
01:58:26 <snoobino> ?
02:00:09 <flux> snoobino, something that lets to add objects into it, change viewing point after that, etc
02:00:46 <snoobino> Yeah that would be nice
02:06:15 <erus`> how do i communicate state from a glut timer callback to a glut render function?
02:07:18 <quicksilver> erus`: with an IORef.
02:07:21 <quicksilver> (or MVar)
02:07:43 <erus`> seems like an ugly way todo it
02:07:54 <erus`> is there a sane opengl windowing lib?
02:09:01 * hackagebot maude 0.1.4 - An interface to the Maude rewriting system.  http://hackage.haskell.org/package/maude-0.1.4 (DavidLazar)
02:12:43 <quicksilver> erus`: why does that seem ugly? IO callbacks are IO callbacks - you have to use IO's state mechanisms.
02:13:02 <quicksilver> erus`: you can abstract the IORef reading/writing into something which threads it back into a monad
02:13:12 <quicksilver> which is what I do for programs larger than very simple ones.
02:14:01 * hackagebot hakyll 3.1.2.3 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.2.3 (JasperVanDerJeugt)
02:47:00 <mm_freak> erus`: there are SDL bindings
02:47:20 <erus`> mm_freak: i havnt got them to work on windows yet
02:47:26 <mm_freak> oh, windows
02:47:52 <mm_freak> getting bindings to work on windows is always hell =)
02:53:18 <chegibari> Hello.
02:53:49 <chegibari> I'm trying to install all haskell related packages on a debian 6 unstable machine. I'm getting these messages: http://pastebin.com/KA42A3MA
02:54:22 <chegibari> Can anybody give me a little hint on how to work around that mess?
02:54:57 <burbul> I'm very new to Haskell and I'm having trouble making ghc work under Cygwin... is this the right place to ask for help?
02:57:48 <zenzike> Is there a way to get ghci to load using the packages and source directories specified in a cabal file?
02:58:12 <rostayob> @pl \(x, y) -> (f x, y)
02:58:12 <lambdabot> first f
02:58:30 <zenzike> burbul: yep, you can ask for help here :-) what's not working?
03:01:28 <burbul> thanks!
03:01:54 <burbul> ghc  hello_world.hs reports
03:02:04 <burbul> Linking hello_world.exe ...
03:02:04 <burbul> realgcc.exe: ons\Micros♠: No such file or directory
03:02:04 <burbul> C:\Program Files\_Coding\ghc-7.0.3\lib\..\mingw\bin\windres: "C:\Program Files\_
03:02:04 <burbul> Coding\ghc-7.0.3\lib\..\mingw\bin\gcc exited with status 1
03:02:49 <burbul> It works fine under a Windows command prompt, but I'm just starting to learn cygwin, and I'd like to use that instead...
03:03:04 <siracusa> zenzike: I don't know of a direct way to do this, you could use .ghci files to load the source files. GHCi will load the necessary packages automatically.
03:05:32 <zenzike> siracusa: the issue is that I'm trying to debug a package which has specific module imports, and ghci is pulling in the wrong versions. I'm not sure how .ghci files would help here ...
03:06:22 <zenzike> burbul: hmm. how strange. Maybe it doesn't like the underscore in your path, have you tried changing that?
03:06:50 <burbul> I can try uninstalling and reinstalling in a different place...
03:06:53 <burbul> Thanks for the suggestion
03:07:02 <balor> I'd like to create two recursive types, a tree that contains SLeaf and Leaf leaf nodes, and the same tree that contains only Leaf leaf nodes.  Like http://hpaste.org/46826/similar_recursive_data_types Is this possible?  Or am I not thinking functionally?
03:07:51 <zenzike> burbul: With cygwin I used to keep everything under C:/cygwin .. I've been stung by things like whitespace in path names, so it was easier to keep thing in C:/cygwin/home/
03:08:39 <siracusa> zenzike: Try `ghci -hide-all-packages' and `:set -package foo' for each package mentioned in the cabal file. Not sure if this works.
03:09:11 <balor> burbul, Again, this doesn't solve your problem.  But maybe instead of cygwin, try a Linux (Ubuntu or Fedora for example) in a VirtualBox VM.
03:09:53 <burbul> well, cygwin is my way of dipping my toes into linux for the first time!
03:10:07 <siracusa> zenzike: Or `cabal configure/build --verbose' and copy the executed commands to a shell script.
03:10:10 <burbul> I've only been using it for a few days
03:11:54 <zenzike> burbul: ah, if you're trying to learn linux, I think you should be using VirtualBox to give it a spin: I've found mingw and cygwin to be a slight pain to set up.
03:11:58 <balor> burbul, Cygwin has some gotcha's here and there.  VirtualBox is open-source and cost-free and most Linux distros are cost-free.  I'd strongly advise just playing with them.
03:13:00 <zenzike> siracusa: thanks, I'll give that a shot.
03:13:15 * balor is a Uni lecturer on Linux'y things, so it's one of the few things I know about.
03:14:06 <burbul> Being able to use commandline DOS executables under cygwin is very useful... I don't want to switch C++ compiler just yet. The nice thing about cygwin is that it lets me mix-and-match.
03:14:28 <burbul> Unfortunately the _ trick didn't work; I'm getting a similar error but with
03:14:36 <burbul> realgcc.exe: le: No such file or directory
03:16:37 <zenzike> burbul: :-/
03:16:52 <burbul> Is there any way to see what ghc is trying to call? I have no idea where the 'realgcc.exe' is coming from, because it's not in the Haskell bin directory...
03:18:13 <zenzike> burbul: out of curiosity, what's wrong with using tha Haskell Platform for getting ghc up and running?
03:18:20 <burbul> I did
03:19:05 <burbul> I only found out about it after my first install, but when I reinstalled just now I uninstalled ghc and installed the haskell platform instead. (In its default directory.)
03:19:39 * osfameron fears cygwin
03:19:48 <luite> burbul: ghc -v file.hs shows what it does to compile the file
03:20:08 <burbul> I *just spotted the v5 option!
03:20:15 <burbul> This seems to be the problem...
03:20:32 <burbul> Linking hello_world.exe ...
03:20:32 <burbul> *** Windres:
03:20:32 <burbul> C:\Program Files\Haskell Platform\2011.2.0.1\lib\..\mingw\bin\windres --preproce
03:20:32 <burbul> ssor="C:\Program Files\Haskell Platform\2011.2.0.1\lib\..\mingw\bin\gcc" "-E" "-
03:20:32 <burbul> xc" "-DRC_INVOKED" --use-temp-file --input=C:\Documents and Settings\Mohan\ghc43
03:20:33 <burbul> 08_0\ghc4308_0.rc --output=C:\Documents and Settings\Mohan\ghc4308_0\ghc4308_0.o
03:20:33 <burbul>  --output-format=coff
03:20:33 <burbul> realgcc.exe: le: No such file or directory
03:20:34 <burbul> C:\Program Files\Haskell Platform\2011.2.0.1\lib\..\mingw\bin\windres: "C:\Progr
03:20:35 <burbul> am Files\Haskell Platform\2011.2.0.1\lib\..\mingw\bin\gcc exited with status 1
03:20:43 <luite> yes I'm pretty sure you didn't need v5 for that :)
03:21:06 <burbul> I'm new to this :)
03:21:06 <balor> burbul, looks like realgcc.exe is not in your $PATH
03:21:45 <burbul> Ah, I see... the idea being that the haskell platform installer didn't add all the necessary directories to the path?
03:22:22 <balor> burbul, no idea, I gave up on Windows in the last century.  But it looks as if bash can't find realgcc.exe
03:22:28 <burbul> thanks!
03:23:00 <luite> have you moved the installation directory or something?
03:23:46 <burbul> Only to follow up the 'remove the _' suggestion above... but I was getting the error before that.
03:23:46 <luite> realgcc.exe is in mingw\bin of your ghc installation, but I don't think that is required to be in your path
03:24:58 <Athas> sjanssen: ping
03:25:40 <burbul> So I'm confused... is  "realgcc.exe: le: No such file or directory" an error from realgcc.exe or an error about realgcc.exe being unfindable?
03:25:51 <shachaf> burbul: The latter.
03:26:33 <luite> hmm, really?
03:26:48 <luite> what is the "le: " part?
03:26:55 <burbul> In that case I may as well try adding the relevant directory to the path...
03:28:19 <burbul> Actually, this is rather messed up: the installer seems to have added 'C:\Program Files\Haskell\bin;' to my path even though that directory doesn't exist ...
03:28:28 <balor> burbul, what happens if you call "realgcc hello.c" where hello.c contains "main(){printf("Hello");}"
03:30:22 <burbul> Adding it to the path fixed things! Thanks for all the help, everyone!
03:32:20 <dcoutts> zenzike: btw, we're implementing "cabal ghci" for a GSoC project this summer, I'm supervising. :-)
03:34:09 <dcoutts> zenzike: the short term hack is to run cabal build -v, copy the ghc command line, swap --make for --interactive. That usually works, or gives a starting point at least.
03:34:47 <zenzike> dcoutts: thanks :-)
03:35:03 <zenzike> dcoutts: I'm glad I'm not the only one in the world that would find ghci and cabal integration useful
03:58:13 <kuraj> im at the university and im not even sure what version of haskell is installed here, but i cant use "unfoldr"
03:58:28 <kuraj> was it introduced in a new release, or do I have to state an include of some sort in the code?
03:58:34 <dschoepe> kuraj: Did you import Data.List?
03:58:37 <kuraj> right
03:58:42 <kuraj> how do I do that?
03:59:00 <dschoepe> "import Data.List" at the top of your file
03:59:02 <hpc> in ghci, just type it in on a line
03:59:16 <kuraj> great, thanks.
03:59:17 <hpc> or put it at the top of a file (below 'module blah where')
03:59:30 <kuraj> yeah the latter is more preferrable
04:03:11 <kuraj> can someone please explain to me in depth, how unfoldr actually works?
04:03:20 <kuraj> i don't see the concept behing Maybe(a, b)
04:03:49 <ClaudiusMaximus> :t unfoldr
04:03:49 <kuraj> i mean.. i know WHAT it does, i need to know HOW it works
04:03:49 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:03:57 <kuraj> thats what I just did.
04:04:16 <roconnor> kuraj: [a] is isomorphic to Mu x. Maybe (a, x)
04:04:29 <roconnor> if that helps
04:04:35 <osfameron> Mu?
04:04:38 <kuraj> im a beginner to haskell, the type definitions are still giving me a hard time to "parse"
04:04:48 <opqdonut_> ClaudiusMaximus: the function of type "b -> Maybe (a, b)" takes the current state and returns an element (to put in the final list) and a new state
04:04:53 <Botje> kuraj: as long as your function returns Just (value, seed), unfoldr keeps working with the new seed
04:04:53 <opqdonut_> sorry, kuraj:
04:04:58 <roconnor> kuraj: ah, nevermind me then
04:04:58 <Botje> if you return Nothing, you end the loop
04:05:05 <ClaudiusMaximus> > unfoldr (\x -> if x == 5 then Nothing else Just (x, x + 1)) 0
04:05:05 <lambdabot>   [0,1,2,3,4]
04:05:52 <Botje> > unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10)) 12345
04:05:52 <lambdabot>   [5,4,3,2,1]
04:06:11 <kuraj> botje thats actually what i used in a function i had to write :)
04:06:19 <kuraj> hold on a second.
04:07:28 <kuraj> http://pastie.org/1926253
04:07:33 <kuraj> here
04:08:01 <kuraj> without taking advantage of the fact that Integer belongs to Show, write a function that converts integer to string""
04:08:18 <Botje> wow.
04:08:22 <kuraj> i only used unfoldr because i knew what it did and that it would work
04:08:31 <Botje> attaching the $ to the functions really fucks with my perl mind :)
04:08:35 <kuraj> but i am afraid that my supervisior will ask me what unfoldr actually does
04:08:41 <kuraj> and ill be like, uhhhhhhhhh....
04:08:55 <kuraj> haha
04:09:07 <kuraj> sorry i dont speak perl so i cant appreciate the joke :)
04:09:08 <Botje> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/base-4.3.1.0/src/Data-List.html # here's the source of unfoldr
04:09:17 <Botje> (in perl, most variables look like $foo)
04:09:19 <roconnor> @src unfoldr
04:09:19 <lambdabot> unfoldr f b  = case f b of
04:09:20 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:09:20 <lambdabot>    Nothing        -> []
04:09:23 <Botje> or that.
04:09:39 <Botje> i didn't want to spam the channel :)
04:09:45 <ClaudiusMaximus> i'd write that as:   map intToDigit . reverse . unfoldr f . fromEnum . abs $ n  -- generally (.) is preferred to ($) because in   (f . g . h $ x)  the  (f . g . h)  is a valid subexpression
04:10:25 <siracusa> roconnor: I know what that mu notation means, but, by accident, do you know of a paper for reference of that notation?
04:10:58 <roconnor> not really.  It is well established notation that I just picked up.
04:11:24 <ClaudiusMaximus> kuraj: have you tried your function on very large Integer arguments?
04:11:37 <aristid> :t \f -> map intToDigit . reverse . unfoldr f . fromEnum . abs
04:11:38 <lambdabot> forall a. (Enum a, Num a) => (Int -> Maybe (Int, Int)) -> a -> [Char]
04:11:42 <kuraj> ClaudiusMaximus: define "very large"
04:11:51 <roconnor> larger than 2^64
04:11:57 <kuraj> oh damn.
04:11:58 <kuraj> it fucks up
04:12:01 <ClaudiusMaximus> > fromIntegral (maxBound :: Int) + 1
04:12:02 <lambdabot>   9223372036854775808
04:12:37 <kuraj> isnt that because at some point i have to convert integer to itn?
04:12:38 <kuraj> int*
04:12:44 <ClaudiusMaximus> :t fromEnum
04:12:45 <lambdabot> forall a. (Enum a) => a -> Int
04:12:47 <regularf1y> Hi all... is http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot supposed to be current? 'Cos the first example hangs for me at the last line on ghc 6.12.1
04:12:50 <roconnor> > 2^64
04:12:51 <lambdabot>   18446744073709551616
04:12:55 <roconnor> > 2^63
04:12:56 <lambdabot>   9223372036854775808
04:13:16 <osfameron> @where mu
04:13:17 <lambdabot> http://www.catb.org/jargon/html/M/mu.html
04:13:29 <osfameron> hmmm, that doesn't sound like the same thing
04:13:32 <roconnor> osfameron: wrong mu
04:13:54 <kuraj> *Main> integerToString 12303213213
04:13:59 <kuraj> it doesn't work at this point
04:14:09 <osfameron> roconnor: heh, tell lambdabot ;-)
04:14:12 <kuraj> (GHC)
04:15:30 * osfameron reads http://blog.plover.com/prog/springschool95-2.html on Mu
04:15:37 <ClaudiusMaximus> :t [mod,div]
04:15:37 <lambdabot> forall a. (Integral a) => [a -> a -> a]
04:16:04 <kuraj> remember when i said a minute ago, that it stopped working correctly?
04:16:16 <kuraj> well i forgot to interrupt the task and just a second ago it almost crashed my entire system
04:16:18 <kuraj> >_>
04:16:27 <Botje> ouch :P
04:16:31 <kuraj> well
04:16:41 <kuraj> im trying to understand what maybe(a, b) does in my case
04:16:56 <Botje> look at the definition of unfoldr
04:17:05 <Botje> it pattern matches on the value your function returns
04:17:19 <Botje> if your function returns [], unfoldr returns [] and thus stops the recursion
04:17:21 <Botje> do you see that?
04:17:31 <ClaudiusMaximus> > fromEnum . abs . (+1) . toInteger $ (maxBound :: Int)
04:17:31 <kuraj> i get that it takes the integer, takes the result of modulus and puts it in a list
04:17:32 <lambdabot>   -9223372036854775808
04:17:38 <kuraj> then repeats the above on the integer divided by 10
04:18:02 <kuraj> until it sees 0, at which point it does Nothing
04:18:21 <Botje> okay
04:18:28 <Botje> so look at the pattern match in unfoldr
04:18:44 * osfameron fails to underestand the Mu article
04:18:57 <Botje> your function either produces Nothing, or Just (a, new_b)
04:19:12 <Botje> in the Nothing case, you just return [], and that stops the recursion
04:19:55 <kuraj> i see
04:20:03 <kuraj> I SEE! :D
04:20:07 <kuraj> that was simplier than i thought
04:20:26 <kuraj> btw ^ the best thing about programming
04:20:29 <Botje> indeed
04:20:47 <roconnor> kuraj: what happens when you run your code on 0
04:21:01 <Botje> in general, if you're examining haskell code, it helps to see what it does to the data constructors of your type
04:21:08 <kuraj> its supposed to return "0" (look beginning of the code)
04:21:17 <roconnor> ok
04:21:23 <kuraj> but now that you asked
04:21:44 <kuraj> yep.
04:22:09 <kuraj> its a shame it doesnt work correctly on long ints but i dont think i can work it around
04:22:18 <kuraj> in a reasonable manner
04:22:43 <ClaudiusMaximus> @faq can it work correctly on long ints?
04:22:44 <lambdabot> The answer is: Yes! Haskell can do that.
04:23:17 <alexbagel> lol
04:23:27 <kuraj> @faq but can it run crysis?
04:23:28 <lambdabot> The answer is: Yes! Haskell can do that.
04:23:35 <kuraj> okay...
04:23:48 <ClaudiusMaximus> mod and div work on Integer too
04:24:32 <kuraj> yes but doesnt the conversion from integer to int (intToDigit) occur after that?
04:24:40 <kuraj> erwait
04:24:42 <kuraj> wait wait wait.
04:24:54 <kuraj> its because of fromEnum.
04:25:34 <mamalujo> is there a way to get arbitrarely - precision decimal number? Ie can Rational be displayed w decimal point etc?
04:26:27 <Jafet> > showCReal 100 pi
04:26:28 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
04:26:31 <kuraj> ha, I fixed it :)
04:26:40 <kuraj>     where x = map intToDigit $reverse $unfoldr f $abs n
04:26:47 <kuraj> f n = Just (fromEnum $ mod n 10, div n 10)
04:28:58 <mamalujo> nice, Jafet , thx!
04:29:03 <ClaudiusMaximus> mamalujo: if you find some nice    RealFrac f => f -> String   it i'd like to know, because all i've seen so far requires   RealFloat f => f -> String  and RealFloat is a total pain
04:29:20 <mamalujo> hmm
04:29:48 <Jafet> You can go via Integer and 10^k.
04:30:09 <Twey> @src pi
04:30:09 <lambdabot> Source not found. Maybe you made a typo?
04:30:10 <Jafet> I did that for one of my programs, and it works fine.
04:30:28 <Twey> :<
04:31:28 <ClaudiusMaximus> Twey: it's a class method of Floating
04:32:38 <Jafet> Most people don't think of Rational with "arbitrarely [sic] - precision decimal", by the way, but something like Fixed.
04:33:21 <poltak> Jafet: hehe
04:33:59 <Twey> ClaudiusMaximus: Oh right
04:34:02 <Twey> Weird
04:34:12 <Twey> Is e?
04:34:15 <Twey> Oh, I guess exp is
04:34:23 <Twey> @src Rational pi
04:34:24 <lambdabot> Source not found. Just try something else.
04:34:30 <Twey> @src Ratio pi
04:34:30 <lambdabot> Source not found.
04:34:33 <Twey> Bah.
04:34:37 <cheater_> i thought Rational was a pair of the form x/y.
04:35:10 <Jafet> @src Double pi
04:35:10 <lambdabot> Source not found. Take a stress pill and think things over.
04:35:11 <kuraj> i often read haskell expressions and misread parts of it as natural language...
04:35:18 <kuraj> like data Maybe a = Nothing
04:35:23 <kuraj> | Just a deriving (...)
04:35:48 <kuraj> or when i had this if (...) else statement and it was like, if (...) nothing else just (...)
04:35:58 <Jafet> @quote Jafet succ
04:35:58 <lambdabot> Jafet says: > (.)(.) id const succ 5$ 0xb00b135
04:36:00 <ClaudiusMaximus> > let f x = let (n, r) = properFraction x in n : f (r * 10) in f (22 % 7)
04:36:00 <lambdabot>   [3,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,...
04:36:04 <kuraj> and for a long while i really couldnt notice it was actually an if/else statement because it was written in a single line
04:36:52 <hpc> > (.)(.) id const succ 5$ 0xb00b135
04:36:53 <lambdabot>   6
04:37:10 <hpc> well that was boring
04:39:41 <ClaudiusMaximus> > let g (x:xs) = show x ++ "." ++ concatMap show xs ; f x = let (n, r) = properFraction x in n : f (r * 10) in g (f (355 % 113))
04:39:42 <lambdabot>   "3.141592920353982300884955752212389380530973451327433628318584070796460176...
04:41:37 <parcs> > 0xb00b135
04:41:38 <lambdabot>   184594741
04:54:36 <aristid> > showCReal 100 (355 / 113)
04:54:37 <lambdabot>   "3.141592920353982300884955752212389380530973451327433628318584070796460176...
04:55:15 <ClaudiusMaximus> :t let g (x:xs) = show x ++ "." ++ concatMap show xs ; f x = let (n, r) = properFraction x in n : f (r * 10) in g . f
04:55:15 <lambdabot> forall t. (RealFrac t) => t -> String
05:03:47 <georgw> Hello #haskell, greetings from Zurich. Question: Can I have fields in a record depend on each other? I.e. a record with an integer field and other fields that use this integer. Or is there another proper way of handling this?
05:06:15 <kosmikus> > let x = 2; y = x + x in (x, y)
05:06:16 <lambdabot>   (2,4)
05:06:33 <kosmikus> georgw: records are nothing but tuples with named components, so yes.
05:06:45 <kosmikus> georgw: but I'm not sure if that's what you really want.
05:07:17 <liyang> I think he means for y to be automagically updated if you just update x.
05:07:28 <georgw> Ah, let me clarify.
05:08:56 <mamalujo> I think you can use open recursion for that. Yi editor had a blogpost about this a while back, for their Prototype implementation.
05:09:09 <georgw> I am programming a simulator that has some parameters, one of them is the order of the system, another is an initial state. Obviously the system order and the size of the vector should be the same; now I am not sure how to reflect this best in the datatype.
05:10:13 <kosmikus> georgw: ah, you want to have a pair of an integer, and then a vector of that length?
05:11:24 <kosmikus> georgw: in Haskell, that's only possible by using type-level numbers. in a dependently-typed language (such as Agda, Idris, Coq, Epigram), you can do it more directly.
05:11:25 <liyang> Do you want the vector length to be statically enforced by the type system? *points at #agda*
05:12:10 <georgw> I don't think I need enforcement, just wonder how to do this cleanly without replicating the same information.
05:13:01 <liyang> I'd drop the field giving the order of the system, and just have it implicit in the length of the vector.
05:13:24 <liyang> But that's not a general answer.
05:13:29 <djahandarie> Hey you can have Vecs in Haskell just fine!
05:13:48 <georgw> Right now I might write someting like: mysimulator = Simulator {order=4, initVal=replicate 4 0}
05:14:01 <kosmikus> djahandarie: I know. but it's always a question of whether it's worth it.
05:14:17 <djahandarie> Sure it is!
05:14:23 <mamalujo> :)
05:14:29 <georgw> Implicit might be a way though, hmm...
05:14:31 <liyang> georgw: I'd write mysimulator = Simulator {..} where order = 4; initVal = replicate order 0
05:15:04 <liyang> Remember to put {-# LANGUAGE RecordWildCards #-} at the top of your source.
05:15:09 <georgw> Can I write this literally? Including the dots?
05:15:11 <georgw> Ahh, ok.
05:15:36 <georgw> But this is not possible without language extensions then, right?
05:15:49 <poltak> georgw: one word~ Alan Turing
05:16:02 <georgw> Or could I access order mysimulator when defining initVal?
05:16:04 <liyang> the {..} is just a convenience. You don't have to use it.
05:16:33 <liyang> georgw: you could...
05:17:16 <mamalujo> how come many ppl are so shy about ghc-specific extensions, given how completely dominant this compiler is?
05:17:35 <georgw> Hehe, I think some tutorials warn about that. ;-)
05:19:03 * liyang hasn't stuck to Haskell '98 since… '98. Probably.
05:19:26 <georgw> Well thanks for the answers, have to go play with ghci now...
05:19:27 <georgw> :-)
05:23:41 <georgw> By the way, is there something like "this" for making the following prettier mysimulator = Simulator {order = 4, initialstate = replicate (order mysimulator) 0}
05:24:08 <georgw> to avoid writing mysimulator twice?
05:24:37 <zygoloid> use a shorter identifier? :)
05:24:55 <georgw> hehehe =)
05:25:17 <hpc> > replicate 5 0
05:25:17 <lambdabot>   [0,0,0,0,0]
05:25:41 * hackagebot X11-rm 0.1 - A binding to the resource management functions missing from X11.  http://hackage.haskell.org/package/X11-rm-0.1 (TroelsHenriksen)
05:25:44 <zygoloid> georgw: mysimulator = Simulator { order = order, initialstate = replicate order 0 } where order = 4
05:26:14 <georgw> ah, interesting.
05:26:27 <quicksilver> I don't really like order occurring twice at different 'types' (or 'parts of speech' perhaps)
05:26:40 <georgw> Right.
05:27:02 <quicksilver> Simulator { order = onum, initialstate = replicate onum 0 } where onum = 4
05:27:10 <quicksilver> but that's a fairly minor point :)
05:27:16 <zygoloid> quicksilver: then you'll hate my next suggestion: mysimulator = Simulator { .. } where order = 4; initialstate = replicate order  [some extensiosn required]
05:27:29 <zygoloid> s/  / 0  /
05:28:51 <georgw> Ok, I see. Or I could do away with having this information twice by putting it in the length of the vector and writing a function order :: Simulator -> Int that gets it from the vector length I guess.
05:29:54 <quicksilver> zygoloid: yes, I do indeed hate that one :)
05:30:01 <quicksilver> zygoloid: recordpuns, I think?
05:30:21 <zygoloid> recordwildcards?
05:30:25 <quicksilver> I mostly hate it on pedagogical grounds.
05:30:43 <quicksilver> one of the major confusions with records is that the field names don't refer to the values of the fields, but to their selector functions.
05:30:55 <quicksilver> this extension perpetuates that confusion by making it work - sometimes.
05:31:22 <zygoloid> georgw: i think i'd write a 'emptySimulator :: Int -> Simulator', then 'mysimulator = emptySimulator 4'
05:31:51 <saterus> @src flip
05:31:52 <lambdabot> flip f x y = f y x
05:32:18 <alexbagel> flip . flip
05:32:46 <zygoloid> quicksilver: it's also pretty nasty that a binding which is defined but never mentioned again can still be removed (and deleting it from your code won't break the build)
05:32:54 <georgw> zygoloid: ok, I see, interesting, thanks!
05:32:54 <zygoloid> s/removed/used/
05:33:02 <FUZxxl> @source nub
05:33:02 <lambdabot> nub not available
05:33:07 <FUZxxl> @src nub
05:33:08 <lambdabot> nub = nubBy (==)
05:33:13 <FUZxxl> @src nubBy
05:33:14 <lambdabot> nubBy eq []             =  []
05:33:14 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:33:49 <parcs> @src not
05:33:49 <lambdabot> not True   =  False
05:33:49 <lambdabot> not False  =  True
05:33:54 <parcs> genius!
05:34:04 <alexbagel> @src id
05:34:04 <lambdabot> id x = x
05:36:38 <parcs> i wonder if it would be more efficient to do not True = False; not _ = True
05:36:58 <quicksilver> zygoloid: Yes. As a guideline the meaning of any identifier should be establishable by the reader from as "local" information as possible.
05:37:20 <quicksilver> zygoloid: of course, haskells lazy import sequence "import Foo" already violates this, since it brings names in scope willy-nilly.
05:38:45 * hackagebot graph-rewriting-gl 0.6.5 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.6.5 (JanRochel)
05:39:45 * hackagebot graph-rewriting-lambdascope 0.4.8 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.4.8 (JanRochel)
05:41:39 <Botje> parcs: a quick core-check suggests it's not
05:41:46 <Botje> of course, i don't know about bigger datatypes and input
05:45:57 <roconnor> what comes after iota?
05:47:39 <Botje> kappa?
05:48:09 <georgw> Thanks for the help, appreciate it. :-)
05:49:42 <ezyang> What does "denotation failure" mean?
06:07:06 <elmix> hi every body!!
06:07:22 <elmix> here is somebody?
06:07:31 <ClaudiusMaximus> hi
06:07:52 <elmix> what kind of stuff can  do with haskell??
06:08:12 <ClaudiusMaximus> pretty much anything - it's a general purpose programming language
06:08:47 <elmix> give some examples, console aplications?, which platform?
06:08:56 <ClaudiusMaximus> http://hackage.haskell.org/packages/pkg-list.html
06:09:29 <elmix> oh!! thanks! that was what i mean!!
06:19:31 <CrazyThinker> Is there any IDE for haskell which supports code assist, refactoring and source control?
06:19:51 <ivanm> CrazyThinker: hmmm..... emacs + haskell-mode + hare? :p
06:20:06 <ivanm> CrazyThinker: refactoring for haskell is rather manual
06:20:38 <ivanm> hare works only on haskell98 code, as there isn't a parser available that it can use that supports extensions (not enough semantic information provided IIRC)
06:22:44 <CrazyThinker> ivanm, Are you using this setup?
06:22:56 <ivanm> I don't use hare
06:23:09 <ivanm> but I do use emacs with haskell-mode and darcsum for use with darcs
06:23:26 <osfameron> @where hare
06:23:26 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
06:23:32 <ivanm> it's on hackage now I believe
06:26:15 <cheater_> hi
06:26:31 <djahandarie> ivanm, do you know if it breaks entirely on non-Haskell98 or just some stuff doesn't work?
06:26:35 <cheater_> does haskell have any automatic generalization tools
06:26:58 <ivanm> djahandarie: completely
06:27:00 <cheater_> say i write a function for lists... is there something that can generalize it to any MonadPlus for example?
06:27:02 <djahandarie> :(
06:27:05 <ivanm> as in, the parser it uses only parses haskell98
06:27:10 <ivanm> doesn't accept any extensions
06:27:14 <Twey> cheater_: No
06:27:21 <cheater_> Twey: why?
06:27:27 <Twey> Often there is more than one way to generalise something
06:27:28 <ivanm> because that would be _cheating_
06:27:28 <ivanm> :p
06:27:31 <Twey> Haha
06:27:33 <cheater_> Twey: sounds like a good thing to be able to do
06:27:46 <Twey> Could be useful, sure
06:27:48 <cheater_> Twey: yes, but at least one is better than no way
06:27:51 <Twey> Write it ☺
06:27:56 <cheater_> no u :)
06:28:03 * cheater_ wouldn't know how to begin..
06:28:06 <ivanm> *patches accepted*
06:28:07 <ivanm> :p
06:28:08 <Twey> I'm not the one who asked for it :þ
06:28:09 <Twey> Haha
06:28:17 <cheater_> that's why you're the one who will deliver it :q
06:28:25 <cheater_> woops
06:28:27 <cheater_> wrong button
06:28:27 <Twey> Haha
06:28:37 <Twey> I thought you'd left, ultimatum delivered
06:29:05 <Twey> Wanting to generalise a list to MonadPlus is odd, for example
06:29:29 <Twey> More usually it would be Monoid, Functor, or possibly Monad
06:30:35 <djahandarie> I wonder how far you could get with a tool that automatically flips around your recursive type to a mu-recursive type and tries to generalize useful instances from there
06:31:00 <djahandarie> s/generalize/generate/
06:34:49 <FUZxxl> Is there a name for Haskell's type system?
06:36:07 <balor> FUZxxl, typed lambda calculus AFAIK
06:37:00 <djahandarie> FUZxxl, Haskell is based on System F_c
06:37:45 <djahandarie> (Which is an altered System F, the polymorphic lambda calculus)
06:38:52 <djahandarie> You need to restrict System F if you want to have a decidable Hindley-Milner though
06:39:57 <FUZxxl> thanks.
06:40:14 <burbul> Can I ask for some help with stdin inside GHCi?
06:40:25 <burbul> I'm hitting the "After using getContents, I can't use stdin again " issue...
06:40:36 <burbul> (As mentioned in the FAQ)
06:41:02 <Jafet> You have an issue with correct, sensible behaviour?
06:41:04 <burbul> Except :set +r, :load and :reload  don't seem to make any difference,
06:41:08 <burbul> nono
06:41:27 <burbul> I completely accept that it's the sensible thing to do in a pure functional language
06:41:53 <burbul> But for practical reasons I would like to be able to switch it off
06:42:38 <burbul> And the methods described in the FAQ don't seem to work
06:42:45 <burbul> I just get
06:42:46 <burbul> *** Exception: <stdin>: hGetContents: invalid argument (Bad file descriptor)
06:43:52 <Jafet> Uh, FAQ where?
06:44:25 <burbul> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/ghci-faq.html
06:46:23 <Jafet> 7.0.2 worksforme.
06:46:29 <ktosiek> I'm new to haskell, but haven't you "binded" everything that might show at stdin to something already by using getContents?
06:46:35 <burbul> yes
06:46:48 <Jafet> Though I can't seem to input an EOF, so it's pretty useless.
06:47:00 <burbul> Ctrl+Z?
06:47:59 <burbul> ktosiek: yes I have. but the point is that I want to be able to test lots of short programs that interact with stdin inside GHCi, and I'd rather not have to restart GHCi every time!
06:48:08 <Jafet> It seems to put the terminal in cbreak mode and emulate stdin.
06:48:15 <burbul> Jafet: I'm using 7.0.3. It works first time and then dies second time.
06:48:56 <burbul> (I'm just testing it with 'getContents >>= putStr')
06:49:04 <Jafet> The last time I checked, GHCi was far more fun to use in the Windows console than it ever was in a VT.
06:49:42 <burbul> Same problem happens in a Windows console.
06:49:48 <FUZxxl> Why does (==) forces the values in case of ()?
06:49:56 <FUZxxl> > undefined == ()
06:49:57 <lambdabot>   *Exception: Prelude.undefined
06:50:02 <FUZxxl> > () == undefined
06:50:03 <lambdabot>   *Exception: Prelude.undefined
06:50:05 <Jafet> Perhaps you should separate the programs into pure and IO sections, and invoke the pure sections in GHCi.
06:50:08 <FUZxxl> > () == ()
06:50:09 <lambdabot>   True
06:50:13 <FUZxxl> > () /= ()
06:50:14 <lambdabot>   False
06:50:41 <Jafet> FUZxxl: why shouldn't it? This makes it strict in its arguments.
06:50:50 <burbul> I'm not really writing programs yet... I'm trying to mess with the IO Monad to see how it works. But I will give up trying to use stdin directly if it's a bad idea.
06:50:54 <Jafet> @src () (==)
06:50:54 <lambdabot> () == () = True
06:53:38 <nihtml> @src map
06:53:38 <lambdabot> map _ []     = []
06:53:38 <lambdabot> map f (x:xs) = f x : map f xs
06:54:11 <nihtml> lambdabot is really awesome.
06:54:56 <Jafet> @botsnack
06:54:56 <lambdabot> :)
06:55:44 <FUZxxl> Jafet: Why should it be strict in it's arguments?
06:56:21 <ktosiek> FUZxxl: so you don't try to compare apples and oranges?
06:57:43 <Jafet> Why not? It's an arbitrary choice.
06:57:52 <FUZxxl> ktosiek: No. But it is known statically, that all values of the type () eventually become equal to ()
06:58:11 <Jafet> All values of type () are already equal to ().
06:58:18 <FUZxxl> So there is no point in pattern matching on ()...
06:58:30 <Jafet> But not all denotations of type () evaluate to ().
06:58:38 <FUZxxl> They could as well write _ == _ = True
06:58:44 <FUZxxl> Ah!
06:58:49 <FUZxxl> That's the point.
06:58:59 <Jafet> undefined is a pretty obvious denotation.
06:59:05 <FUZxxl> So undefined :: () /= ()!
06:59:11 <ion> @djinn ()
06:59:11 <lambdabot> f = ()
06:59:55 <Jafet> FUZxxl: it is neither equal nor inequal.
07:00:11 <Jafet> Which raises an interesting question, by the way... if _ == _ = True, then how do you define (/=)?
07:00:13 <FUZxxl> it evaluates to _|_
07:00:23 <FUZxxl> _ /= _ = False
07:00:38 <Cale> burbul: If you're just trying things out at the ghci prompt, you might find getLine nicer than getContents
07:00:39 <lambdabot> Cale: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:00:42 <Jafet> Hm, an arbitrary choice all the same.
07:00:49 <ion> a /= b = not (a == b)
07:03:34 <roconnor> is there a magic library for serializing and deserialing data structure with internal references kept intact?
07:05:45 <Saizan> you have IORef's or similar or do you mean preserving sharing?
07:05:55 <Jafet> Sounds tricky
07:06:03 <roconnor> perseving sharing
07:06:13 <roconnor> no IO involved
07:06:18 <Saizan> then yes, iirc
07:06:22 <roconnor> ^_^
07:07:01 <Saizan> andy gill made one but i don't remember the name, or at least made one library to observe sharing
07:07:40 <Jafet> @hackage RefSerialize
07:07:41 <lambdabot> http://hackage.haskell.org/package/RefSerialize
07:07:44 <Jafet> @hackage data-reify
07:07:45 <lambdabot> http://hackage.haskell.org/package/data-reify
07:09:45 <roconnor> RefSerialize sounds good
07:10:24 <Jafet> Assuming you're going to use it with an ancient ghc.
07:10:35 <roconnor> :/
07:10:51 <Jafet> It looks like Saizan was talking about `reify'.
07:10:56 <roconnor> maybe I'll just never turn off my computer
07:11:43 <Saizan> i was talking about data-reify
07:11:54 <Saizan> but i thought someone made a serialization package with it
07:12:05 <roconnor> data-reify gives the basics of what I need, but I still have to serialize and reflect myself
07:12:23 <roconnor> and reflecting seems really hard
07:12:30 <Jafet> Hm, how would you search for that?
07:12:42 <ClaudiusMaximus> @hackage acid-state
07:12:43 <lambdabot> http://hackage.haskell.org/package/acid-state
07:12:48 <ClaudiusMaximus> might be related?
07:12:52 <Jafet> Searching package dependencies
07:13:23 <Saizan> http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/data-reify-0.6#direct
07:13:50 <Saizan> no idea if it's up to date though
07:14:31 <roconnor> Acid-state does not write your data types to disk every time you change it. It instead keeps a history of all the functions (along with their arguments) that have modified the state.
07:16:34 <ClaudiusMaximus> roconnor: ah
07:17:45 <dafis> ClaudiusMaximus: ping
07:17:48 <ClaudiusMaximus> roconnor: maybe run in a virtual machine and suspend/snapshot/resume periodically? - i don't know what you're doing
07:17:51 <ClaudiusMaximus> dafis: hey!
07:18:16 <dafis> hey, have you already looked at what the ffi call would produce?
07:18:18 <ClaudiusMaximus> dafis: i got side tracked, didn't have a chance to look at the things i mentioned yet...
07:18:32 <dafis> no problem, was just curious
07:19:06 <ClaudiusMaximus> dafis: but from memory it gives lots of digits with scientific notation like e+01 when it would be nicer just to move the decimal point
07:20:43 <dafis> ClaudiusMaximus: wouldn't be too hard to move the decimal point, though, just annoying that you'd have to get to the end to see how far and in which direction
07:23:04 <ClaudiusMaximus> yeah, i think i actually started to implement this once before, i'll see if i can find it...
07:26:41 <erus`> anyone know where i can host a static html & javascript page for free?
07:26:58 <parcs> github
07:27:53 <ClaudiusMaximus> you could embed it all in a really long data: url perhaps?
07:28:44 <parcs> i think the limit on the length of a url is 2^16
07:28:52 <erus`> thats huge
07:29:09 <erus`> parcs how do i make a homepage on github
07:29:15 <erus`> does it have to be for a project?
07:29:21 <parcs> i think so
07:39:02 <erus`> http://tm1rbrt.github.com/
07:42:33 <burbul> Cale: thanks for the suggestion... but I'm trying to take a algorithm that operates on strings and automagically convert it to operating on streams using Haskell. So I think I do need get Contents.
07:46:59 <Botje> BONUS: I GOT YOUR BOOK TODAY. IT IS SHINY!
07:47:10 <Botje> I promptly gave it to a colleague for re-education
07:48:27 <Jafet> Re-education sounds like something that happens in soviet russia
07:51:30 <tg_> erus`: cute
07:51:49 <tg_> it's like anti-checkers
07:52:20 <erus`> i need to write a computer player
07:54:55 <bapuche> I would like to enumerate ordered partitions of the integers. For example, [[a,b,c,d]|a<-[0..3],b<-[a..3],c<-[b..3],d<-[c..3]] generates a list of all ways to add up to 4 using integers less than that. But what if I wanted to get partitions of 93?
07:55:34 <bapuche> oops, I need a guard in that:  a+b+c+d==4
07:56:02 <Jafet> By using a more efficient method, probably
07:56:09 <bapuche> That is, [[a,b,c,d]|a<-[0..3],b<-[a..3],c<-[b..3],d<-[c..3],a+b+c+d==4]
07:56:16 <tromp_> @let pents=zip(cycle [1,1,-1,-1])$scanl(+)1$do k<-[1..];[k,2*k+1]
07:56:17 <lambdabot>  Defined.
07:56:42 <tromp_> @let p=Memo.integral q where q 0=1;q n=sum.map(\(s,k)->s*p(n-k))$takeWhile((<=n).snd)pents
07:56:42 <lambdabot>  <local>:6:52:
07:56:42 <lambdabot>      Ambiguous occurrence `p'
07:56:42 <lambdabot>      It could refer to either `L...
07:56:54 <scooty-puff> i am having trouble with this splice: [d| instance $ctx => ParameterDesc $typ where |])
07:56:56 <bapuche> jafet: Good point.
07:56:56 <tromp_> @let parts=Memo.integral q where q 0=1;q n=sum.map(\(s,k)->s*parts(n-k))$takeWhile((<=n).snd)pents
07:56:57 <lambdabot>  Defined.
07:57:10 <scooty-puff> is it impossible to splice constraints?
07:57:22 <tromp_> > parts!!93
07:57:22 <lambdabot>   Couldn't match expected type `[a]'
07:57:23 <lambdabot>         against inferred type `a11 -> a1'
07:57:34 <Saizan> > parts 93
07:57:36 <lambdabot>   82010177
07:58:52 <tromp_> number of partitions
07:59:15 <bapuche> tromp_: Whoa! Are you talking to me? That went way over my head.
07:59:54 <tromp_> i wrote this functions to compute number of partitions a while ago
08:00:26 <tromp_> maybe you can change it to compute list of partitions...
08:00:59 <bapuche> 82 million partitions is too many to actually list, though computing things with it is of course possible.
08:01:23 <Botje> partitions = filterM (const [True, False])
08:01:40 <Botje> well, almost.
08:01:49 <Botje> it will tell you one side of the partitions.
08:02:11 <Jafet> Nice try
08:02:24 <spirit> using split, how can i split on tabs, i.e. \t? oneOf "\t" doesn't seem to work
08:02:27 <mux> project euler strikes again
08:05:10 <bapuche> tromp_: I just gave this partitioning problem as an example of one that at least in a naive way you could look at as an increasing sequence of nested loops. What I'd like to understand is your algorithm.
08:08:21 <tromp_> i'd like that too. unfortunately i forgot to comment my code:(
08:09:10 <bapuche> Is pents a list of pentagonal numbers?
08:09:54 <tromp_> yes
08:10:01 <tromp_> > pents
08:10:03 <lambdabot>   [(1,1),(1,2),(-1,5),(-1,7),(1,12),(1,15),(-1,22),(-1,26),(1,35),(1,40),(-1,...
08:10:05 <scooty-puff> does anyone have any advice for how to clean this up: http://pastebin.com/vX2XWAUm
08:10:10 <Jafet> I'm sure a search engine will help you to figure out that code.
08:10:35 <dafis> bapuche: google for Euler recursion formula partitions
08:11:55 <scooty-puff> Jafet, was that to me?  i wrote that, had a cleaner version, but then found i could not insert class constraints into a quotation
08:12:03 <bapuche> dafis: Thanks. I take it then that when you see a way to do it using nested loops, there's a more succinct and faster way using recursion.
08:12:07 <tromp_> http://en.wikipedia.org/wiki/Pentagonal_number_theorem
08:12:16 <Jafet> No, it wasn't.
08:12:22 <scooty-puff> ok
08:13:45 <dafis> bapuche: recursion need not be faster (if you're talking execution time, coding time tends to be lower for recursion)
08:22:02 <HugoDaniel> is there a tool that reads a xsd and produces haskell modules ?
08:23:09 <HugoDaniel> ah
08:23:12 <HugoDaniel> Version 1.21 (forthcoming) adds better support for XML namespaces, and introduces the new XsdToHaskell tool.
08:23:15 <HugoDaniel> in haxml
08:24:35 <tromp_> @let partitions n = p n 1 where p 0 _ = [[]]; p n m = if m>n then [] else map (m:) (p (n-m) m) ++ p n (m+1)
08:24:36 <lambdabot>  Defined.
08:33:28 <cheater__> could a hypothetical version of haskell with eager eval have monads?
08:33:48 <roconnor> yes
08:34:08 <roconnor> monads have nothing to do with laziness
08:34:49 <sipa> F# has an IO-like monad
08:35:03 <sipa> or Monad-like IO, better
08:35:16 <ezyang> Though I will note that some frequent idioms that are done with monads have to be done with a little more care in a strict language.
08:35:25 <roconnor> the biggest problem with eager langauges is that they sometimes don't support combinators (such as the monad combinators) very well.
08:35:34 <mercury^> ezyang: such as?
08:35:36 <quicksilver> value restriction ftl!
08:35:48 <quicksilver> although, isn't the value restriction more about ML's impurity than ML's eagerness?
08:35:54 <roconnor> I mean the support them, just very very slowly
08:36:14 <roconnor> or eagerly if you will. :D
08:36:22 <ezyang> For example, if I write doThis = putStrLn "foo"; doThat = putStrLn "bar", I don't expect either of these to get executed unless they're placed in a proper monadic context.
08:36:46 <quicksilver> ezyang: that's not about strictness per se, that's about purity, surely.
08:37:05 <ezyang> Or if you pass them around as values?
08:37:19 <ezyang> The point is, that you need to pass around what are effectively closures.
08:37:28 <ezyang> so it's not as effortless.
08:38:38 <mercury^> ezyang: in your example it certainly is.
08:38:50 <mercury^> The IO () value can be fully evaluated.
08:39:12 <alexbagel> makes things like Debug.Trace fun to use
08:39:30 <jmcarthur> quicksilver: yes. with unsafePerformIO you can get something very like the value restriction in haskell
08:40:57 <quicksilver> Debug.Trace is just a constant reminder that we don't yet have something better.
08:41:02 <quicksilver> it's a problem, not a solution :)
08:41:28 <Jafet> Thus spake our ecologist
08:42:01 * quicksilver cheers happily
08:42:11 <quicksilver> I can hardly think of a more flattering title :)
08:46:30 <HugoDaniel> is it possible to code iphone apps in haskell ?
08:47:00 <quicksilver> not easily.
08:47:07 <quicksilver> there is a ghc-iphone effort
08:47:17 <quicksilver> and there is a company writing an iphone game (partly) in haskell
08:47:26 <quicksilver> blackh and cale work there.
08:48:26 <HugoDaniel> oh, ok, thanks
08:50:50 <dafis> quicksilver: Simon h.c. would be a more flattering title :)
08:53:14 <MarcWeber> HugoDaniel: Read the mailinglist posts (haskell-cafe) AFAIK its possible - but its questionable whether you're allowed to do so ..
08:53:45 <MarcWeber> Its because Apple wants to control apps or the languages being used. Eg Flash is not allowed either.
08:54:43 <parcs> what is the policy on fixing unmaintained packages in hackage?
08:55:08 <parcs> specifically, the utf8-light packages, which fails to build for me unless i edit the source code
08:55:26 <c_wraith> MarcWeber: they changed the license agreement after enough people got upset with it.  You're now allowed to use any origin language you like, so long as your application doesn't download code.
08:55:53 <MarcWeber> c_wraith :) cool
08:56:29 <c_wraith> parcs: new code should be using text instead of that - I assume this is a dependency for something else?
08:57:09 <c_wraith> oh, mmorrow.  Yeah, he's vanished. :(
08:57:20 <parcs> c_wraith: yes
08:57:29 <parcs> it's an indirect dependency of yesod
08:58:01 <parcs> the package is two years old now, and due to its use of -fvia-c, it fails to build for me
09:00:05 <c_wraith> I think the general policy is "If you're willing to maintain it, go ahead and upload a new version with fixes and setting the maintainer entry to point to you"
09:00:52 <parcs> i don't really want to maintain it, and it's just a two-line fix..
09:02:55 <c_wraith> the other option is kill it as a dependency, at some higher level along the dependency chain
09:03:53 <parcs> is it really possible to upload a new version of a package that you did not originally create?
09:04:09 <Saizan> technically yes
09:06:56 <HugoDaniel> thanks MarcWeber
09:09:26 <develhevel> howto acces on commands which the user give in the programm? e.g. then he calls ./myprog foo how to access there foo?
09:09:50 <Eelis> develhevel: argc/argv. look it up
09:10:04 <Eelis> oh wait, this is #haskell
09:10:04 <quicksilver> Eelis: wrong channel?
09:10:06 <quicksilver> :)
09:10:12 <quicksilver> develhevel: getArgs
09:10:40 <quicksilver> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Environment.html#v%3AgetArgs
09:11:04 <develhevel> thx :)
09:18:04 <mm_freak> why does cabal keep asking me for my hackage username/password?
09:18:19 <mm_freak> i'm having that problem for a while now
09:18:53 <dcoutts> mm_freak: a bug, my fault, since fixed.
09:19:14 * hackagebot contstuff 1.2.6 - Fast, easy to use CPS-based monad transformers  http://hackage.haskell.org/package/contstuff-1.2.6 (ErtugrulSoeylemez)
09:19:16 * hackagebot utf8-light 0.4.0.1 - Unicode  http://hackage.haskell.org/package/utf8-light-0.4.0.1 (PatrickPalka)
09:19:24 <mm_freak> dcoutts: which cabal-install version do i need?
09:21:02 <develhevel> simple question, when i got a IO String, how to make a String of it? and when i have a String howto make a IO String of it?
09:21:36 <dcoutts> mm_freak: apparently you need the darcs version of the cabal-install-0.10 branch
09:21:48 <mauke> develhevel: that makes no sense
09:22:04 <Axman6> develhevel: in a do block, if you have do { x <- (foo :: IO String); ...} then x has type String
09:22:25 <mauke> develhevel: when you get an [Int], how do you make a Bool of it? and when you have a Bool, how do you make an [Int] of it?
09:23:22 <develhevel> mauke: i mean it like Axman6 sayd
09:23:33 <copumpkin> develhevel: the basic answer is that it's trivial to put something into IO, not to to take things out of it. So instead of taking the string out, you put the function that wants the string into IO
09:23:40 <mauke> develhevel: but that doesn't turn an IO String into a String
09:24:16 <Axman6> develhevel: you may find this tutorial useful: http://random.axman6.com/blog/?page_id=70
09:27:00 <Perlkonig> Question: Is there some sort of "foldUntil" idiom? Or am I just going to have to find another way? I essentially have an infinite list that I want to process until the accumulator reaches a certain value.
09:27:09 <develhevel> thx for the tutorial, i will work it throw
09:27:18 <mauke> Perlkonig: takeWhile/iterate, maybe
09:27:31 <Perlkonig> *looks up iterate*
09:28:50 <Perlkonig> mauke: Hrm, but what I need to examine is the ratio of one value to another in the list to a certain point. I can't process each element in isolation. Once the accumulator reaches a certain ratio, I want the function to tell me where.
09:30:44 <kstt> what package would you recommand for mapping over the nodes of an HTML tree ? I want to produce an updated tree, for example change all <em> nodes into <strong> nodes, and get the resulting HTML output ?
09:34:09 <shapr> kstt: HaXml or that german lib perhaps?
09:34:11 * shapr tries to remember
09:34:24 <shapr> HXmlToolkit
09:34:26 <shapr> that's the other one
09:34:43 <shapr> kstt: But the best choice might be to check the HaskellWiki for recently updated examples that do what you want.
09:36:50 <kstt> shapr: I just checked haskellwiki, but did not find much.
09:37:00 <kstt> do you have some pointer to share ?
09:37:49 <shapr> kstt: search for the word "transforming" in this page: http://www.haskell.org/haskellwiki/Web/Libraries/XML_and_HTML
09:38:56 <kstt> I missed HXT it because I thought it was for XML documents only. Thank
09:40:53 <shapr> kstt: If you have any problems feel free to ask questions here.
09:41:03 <kstt> thank you
09:41:25 <shapr> kstt: I haven't written any HXT recently, but I made a bunch of money transforming microsoft word documents into XML via OpenOffice and HXT :-)
09:44:03 <kstt> Yeah, we all do Haskell because it is the most direct way to big dollars, women and success !
09:44:37 <shapr> kstt: Worked for me :-)
09:44:42 <copumpkin> yeah, same here
09:44:42 <kstt> ;)
09:44:47 <shapr> kstt: I had a Haskell job for almost two years, paid pretty well.
09:44:53 <copumpkin> I get all the $ I want
09:45:06 <luite> meh I must be doing something wrong ;p
09:45:14 <shapr> copumpkin: That's cuz you have awesome skillz in many areas.
09:45:24 <luite> even my hobby haskell projects turn out to be mostly javascript
09:45:29 <copumpkin> oh, I was just talking about the ($) operator :(
09:45:35 <shapr> oh, right
09:47:19 <xarch> hi
09:47:35 <xarch> I've got a problem, http://paste.awesom.eu/xarch/6oV&hl=haskell doesn't typecheck
09:48:14 <xarch> do you know what I should correct?
09:49:16 <kstt> copumpkin: same here, and quiet often I hear complaint from newcomers, like « Oh no, there is really too much dollars in Haskell, how can you manage with that ? »
09:49:16 <kstt>  
09:52:58 <jmcarthur> i consider more $s in my code to be too expensive
09:53:10 <jmcarthur> i prefer to use as few $s as possible
09:53:15 <earthy> so no perl for you? :)
09:53:31 <jmcarthur> i don't have enough $ for perl
09:53:50 <magicman> `id` all the way!
09:53:56 <jmcarthur> lol
09:55:16 <Perlkonig> In GHCI, is there a way to time how long a function runs? Or compare the speed of two functions?
09:55:40 <jmcarthur> Perlkonig: :set +s
09:55:51 <jmcarthur> but i wouldn't use ghci for benchmarking
09:55:57 <earthy> perlkonig: there's criterion
09:56:08 <earthy> if you want to really do benchmarking
09:56:19 <jmcarthur> ++
09:56:41 <Perlkonig> Thanks! I'll look up criterion for serious benchmarking.
09:56:45 <earthy> plus, you need to realise that with inlining and optimisations that may be possible after inlining, just comparing two functions may not tell you a whole lot
09:56:55 <magicman> Yeah. There's this thing where GHCi keeps evaluated expressions in memory.
09:57:14 <jmcarthur> what does that have to do with it?
09:57:34 <drhodes> does criterion require the profiling libs?
09:57:36 <jmcarthur> the main reason not to use ghci for benchmarking is because it doesn't at all reflect what you would see in a compiled program
09:57:40 <jmcarthur> no
09:57:58 <earthy> oh, and one other 'interesting' effect: if one of the functions is in a compiled module whereas the other is interpreted by ghci, you will *never* get valid results ;)
09:57:58 <magicman> And how, when comparing "f1 x" with "f2 x", f1 may show up to be slower, because of whatever it needs to do with x.
09:58:11 <Perlkonig> Criterion looks perfect. Thanks, all.
09:58:15 <earthy> (because ghci will default to not interpreting if a compiled module is available)
09:58:20 <magicman> So. Yes. Criterion ;)
09:58:28 * earthy nods
09:58:42 <jmcarthur> the profiling is so you can track down bottlenecks, space leaks, etc., not really for benchmarking
09:59:59 <Perlkonig> I'm trying to find the fastest way to count the number of instances of a particular element in a large list. I have my own recursive function, and then there's "group $ sort". For this particular application, I'm trying to determine which is faster.
10:02:44 <c_wraith> group . sort is always going to do more work than a special-purpose function looking for only a single element.  But are you looking for all element counts?
10:03:05 <c_wraith> In that case, map (head &&& length) . group . sort is probably the fastest
10:03:06 <copumpkin> length . filter (x ==)
10:04:29 <Perlkonig> c_wraith: I'm looking for one specific element. I'll try length . filter too. Thanks!
10:04:45 <djahandarie> It'd be nice if there were a version of &&& that put stuff into lists instead of tuples
10:05:04 <c_wraith> yeah, if you're just looking for one element, it's going to be pretty hard to beat length . filter
10:12:42 <mm_freak> haddock has problems with cabal 1.8:
10:12:43 <mm_freak> cabal: Can't find transitive deps for haddock
10:12:48 <mm_freak> is there a way to solve this?
10:13:11 <Perlkonig> Where is some good documentation on how to use Criterion? One thing about the packages in Hackage is that they don't contain the extensive usage documentation you find at CPAN, for example. I'm looking at an older blog post by the criterion author, but GHC is telling me "bench" is out of scope.
10:14:02 <dcoutts> mm_freak: no, actually it's still not fixed in cabal head, sorry.
10:14:03 <parcs> Perlkonig: the Criterion.Main module has sufficient documentation IMP
10:14:05 <parcs> IMO*
10:14:20 <dafis> Perlkonig: what parcs said
10:14:20 <dcoutts> mm_freak: the only workaround at the moment is not running haddock, or not using intra-package deps
10:17:14 <Perlkonig> parcs: Thank you. I found it.
10:44:35 <pngl> Is it possible for a function to return sometimes a (Just String), sometimes a (Just Int)?
10:44:53 <mm_freak> dcoutts: ok, thanks
10:45:11 <dafis> pngl: no
10:45:14 <c_wraith> pngl: No.  You could return an Either String Int
10:45:31 <dafis> or a Maybe (Either String Int)
10:45:34 <mm_freak> pngl: if you give String and Int a common class instance for a class X, you can write:  X a => Maybe a
10:45:47 <pngl> I see
10:45:52 <byorgey> mm_freak: that's not the same thing.
10:46:01 <mm_freak> byorgey: it's more general
10:46:04 <c_wraith> yeah, mm_freak interpreted the question differently
10:46:08 <c_wraith> it's not more general
10:46:11 <c_wraith> it's just different
10:46:14 <byorgey> mm_freak: no, X a => Maybe a  must be able to return whatever the *caller* wants
10:46:18 <c_wraith> it allows the caller to determine the return type
10:46:30 <c_wraith> Where the Either allows the function to determine the return type
10:46:32 <mm_freak> indeed
10:46:41 <c_wraith> Those are just plain different
10:46:41 <mm_freak> sorry, i misinterpreted the question
10:47:13 <pngl> I want the caller to determine the return type
10:47:29 <pngl> is there a generic class I could use?
10:47:31 <c_wraith> Ah, then a type class does do what you want
10:47:37 <c_wraith> There's no generic class there.
10:47:52 <c_wraith> You need a class that actually is meaningful in your case
10:47:56 <pngl> ok
10:49:55 <monochrom> since both String and Int are instances of Ord, you may like to consider (Ord a) => Maybe a
10:50:59 <\yrlnry> Turns out you report git bugs by emailing git@vger.kernel.org
10:52:13 <dafis> \yrlnry: what kind of bug was it?
10:53:20 <\yrlnry> sorry, wrong channel.
10:53:57 <\yrlnry> Anyway, I put the report at http://plover.com:8080/~mjd/misc/git-bug if you really care.
11:08:55 <pngl> I was asking this because I am reading RWH. I have decided to stop 1/3 through Chapter 10 and see if I can build implicit state myself. That's what I have so far: http://pastie.org/1927905. It doesn't work because of the problem I mentioned earlier.
11:10:01 <pngl> My approach is probably very misguided, but I would be grateful if someone could explain to me why and how to make it work (without changing the whole approach, that answer is already in the book)
11:11:28 <dafis> pngl: applyToMaybe is (>>=) from the Prelude (specialised to Maybe)
11:11:34 * hackagebot llvm 0.9.1.2 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-0.9.1.2 (BryanOSullivan)
11:13:07 <byorgey> pngl: your type for updateCurrent does not make sense
11:13:35 * hackagebot hsx-jmacro 6.0.0 - hsx+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-6.0.0 (JeremyShaw)
11:13:46 <byorgey> pngl: it should probably be  ParseState a -> Maybe a -> ParseState a
11:13:48 <pngl> byorgey: I want to update the cur field of my ParserState, and the cur field can hold different types of values
11:13:55 <dafis> yes, all the type variables there must be the same
11:14:16 <byorgey> pngl: yes, but updateCurrent cannot change the type
11:14:31 <dafis> pngl: then, b and c must still be the same
11:14:43 <byorgey> but it will work no matter what type of thing is stored in the ParseState
11:15:19 <dafis> pngl: but you can construct a new state of different type by breaking the state down with pattern matching and reassembling the new state
11:15:35 * hackagebot happstack-jmacro 6.0.0 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-6.0.0 (JeremyShaw)
11:16:21 <byorgey> dafis: pngl is already doing that with  state { cur = c }
11:16:21 <dafis> pngl: oh, no, the Nothing case forces all threee to be the same type
11:16:53 <byorgey> if you have nothing to update with, the state must remain the same, hence it will remain the same type
11:17:01 <byorgey> if you update it with something of type b, it will now be of type b
11:17:01 <dafis> byorgey: without the Nothing case, the result type could be different
11:17:12 <byorgey> yes, but it would still have to be the same as the second argument
11:17:14 <dafis> I forgot that
11:17:24 <pngl> I don't understand. If I do updateCurrent state{cur=2} Nothing, I'll get state{cur=2}. If I do updateCurrent state{cur=2} (Just "yay!"), I'll get state{cur="yay!"}. So the return type can be the initial type (ParseState a), or a modified type (ParseState b), no?
11:17:47 <keep_learning> hello all
11:17:54 <tg_> pngl: if I answer no, does that mean yes?
11:17:57 <dafis> pngl: and that's impossible, that would not be well-typed
11:18:08 <keep_learning> i am trying to use ByteString first time
11:18:09 <keep_learning> http://hpaste.org/paste/46845/spoj_problem__setnja
11:18:19 <keep_learning> but i am getting compiler error
11:18:35 <keep_learning> could some one please tell me what is wrong with code
11:18:49 <pngl> dafis: ok. I suspected I was trying to break things.
11:18:49 <dafis> keep_learning: ByteString isn't a list
11:19:04 <pngl> tg_: maybe
11:19:30 <keep_learning> dafis, so should i use BS.head for first element and BS.tail for rest of element
11:19:31 <keep_learning> ?
11:19:36 * hackagebot swish 0.3.1.2 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.3.1.2 (DouglasBurke)
11:19:38 * hackagebot happstack-server 6.1.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.1.2 (JeremyShaw)
11:19:54 <pngl> But then what can I do?
11:19:55 <byorgey> pngl: note, the type  ParseState a -> Maybe b -> ParseState c   means that updateCurrent must be able to return *whatever type of ParseState the caller wants*.
11:20:06 <byorgey> pngl: obviously that is impossible.  It can only return things of the types it is given.
11:20:27 <dafis> keep_learning: you'd have to use something like solverHelp bs p | BS.null bs = p | BS.head bs == 'L' = solverHelp (BS.tail bs) (2*p) ...
11:20:30 <mamalujo> I guess like many begginers I was always interested in OO-like stuff in hs. OOHaskell looks like an overkill, but some encodings in that paper look usable. The 'natural' typeclass encoding, w existential wrappers like used in extensible exceptions is not yet practical enough, since one cannot do default superclass instances in GHC yet (I hope soon..). But that fixpoint approach w open recursion looks fairly nice; read a paper on 'mixins' with it too. ...
11:20:33 <pngl> byorgey: yes. I wanted to express : "udpateCurrent can either return things of type ParseState a or ParseState b"
11:20:36 <mamalujo> ... So was considering writing my (hypothetical) future code like that, if nothing else, then for practice (actually I did try it a bit for some quick script for minmaxing my fallout3 character;) . BUT, is there a significant performance penaly? if so, any hope it can be avoided
11:21:16 <byorgey> pngl: you could certainly write  updateCurrent :: ParseState a -> Maybe b -> ParseState (Either a b), but I doubt that is actually what you want to do.
11:21:24 <keep_learning> dafis, thank you
11:21:27 <dafis> pngl: updateCurrent :: ParseState a -> Maybe b -> Either (ParseState a) (ParseState b)
11:21:35 <pngl> byorgey: it isn't
11:21:49 <pngl> dafis: ahhh that would make the rest even more complex
11:22:03 <byorgey> pngl: why does updateCurrent take a Maybe?
11:22:11 <dafis> keep_learning: however, if you want it fast (and for spoj, you probably will), take a look at Data.byteString.Unsafe
11:22:33 <byorgey> pngl: I suspect there is something subtly wrong with your design, and the type of updateCurrent is just a symptom
11:23:08 <byorgey> i.e. why can't you use   updateCurrent :: ParseState a -> b -> ParseState b
11:23:51 <pngl> byorgey: because updateCurrent can be called by the more general function updateParseState, which might only required to update the string and not the current value... ok. That's were I have a flaw. I can just directly call updateCurrent.
11:24:12 <byorgey> pngl: it looks like the only places where updateParseState is called, it is explicitly passed a Just value
11:24:15 <pngl> byorgey: yes. Thank you, it should fix my problem.
11:24:22 <byorgey> great =)
11:28:47 <pngl> byorgey: yes it works! thanks again!
11:29:26 <byorgey> =D  you're welcome!
11:35:01 <tjgillies> if i have foo :: String -> IO() is that function considered to be referentially transparent?
11:35:20 <mauke> yes, it will always return the same IO () for the same String
11:35:39 <tjgillies> that IO() being what? unit?
11:35:57 <earthy> IO ()
11:36:01 <mauke> depends on whatever the function does
11:36:03 <copumpkin> just an action that does something
11:36:13 <copumpkin> you haven't given us any more information
11:36:16 <earthy> that is an IO action associated with the existence of a value
11:38:31 <roconnor> tjgillies: think of IO a as a big (possibly infinite tree) where leaves hold data of type a, and the internal nodes hold data for system calls and there is a subtree of a node for each possible response to a system call.
11:39:05 <roconnor> tjgillies: thus the IO a is a data type that holds a recipe for handling every possible IO scenario
11:39:11 <mauke> if you have no idea what he just said, think of IO a as a shell script
11:39:26 <roconnor> heh
11:39:38 <roconnor> that's not a bad way to start thinking about IO
11:41:19 <ben> I thought IO was a taco or something
11:41:40 <conal> i don't know if we even have a basis for asking whether expressions involving IO (eg foo "bar") are referentially transparent, since we don't know what equality means on IO.
11:41:41 <mauke> no, it's much simpler
11:42:15 * roconnor knows equality in IO when he sees it :P
11:43:01 <roconnor> certainlly my explaintion doesn't support multi-threading, something I'd like to have fixed.
11:43:12 <conal> dang. closed the wrong irc window.
11:44:38 <conal> roconnor: :p
11:45:35 <tjgillies> ok for example simpleHTTP is simpleHTTP:: (HStream ty) = >Request ty -> IO (Network.Stream.Result (Response ty))  but if i call simpleHTTP(foo) one minute and then call it 5 minutes later it could be different
11:46:33 <mauke> tjgillies: no
11:46:38 <mauke> it will return the same IO action
11:46:47 <mauke> simpler example: putChar
11:46:51 <mauke> :t putChar
11:46:52 <lambdabot> Char -> IO ()
11:46:56 <roconnor> tjgillies: ya it returns the same "shell script"
11:47:43 <conal> i wonder what "same IO action" means.
11:47:46 <roconnor> tjgillies: it's very important to understand that these functions ending in IO don't actually execute any IO acctions.
11:48:17 <roconnor> conal: something like the operations semantics of the IO Tree are equivalent.
11:48:27 <roconnor> *operational
11:48:40 <zaero> i'm new to haskell, but i like to think of functions that return IO as them returning an instruction
11:48:45 <roconnor> tjgillies: IO actions are only executed by the runtime system.
11:48:56 <conal> roconnor: which isn't really defined.
11:49:11 <conal> let alone denotational
11:49:20 <zaero> and that instruction is only evaluated in the runtime which calls into main
11:49:49 <mauke> zaero: that's what I do
11:50:22 <zaero> the script analogy is good.  its like your functions build up a script, which the runtime executes
11:50:33 <roconnor> conal: well at the very least equal objects are equivalent :)
11:50:58 <conal> roconnor: "equal"? "equivalent"?
11:51:22 <roconnor> conal: take the free monad generated by all the primitive operations.
11:51:28 <roconnor> conal: write a big list of laws you want to hold
11:51:30 <roconnor> mod out
11:51:34 <roconnor> voila, semantics.
11:52:47 <roconnor> If you forget a law, well everything you've proved equal will still be equal when you add a new law.
11:53:46 <conal> ah. maybe the key point here is that RT is closely related to that free structure. even monad is beside the point.
11:54:07 <robinhoode> I'm actually curious what FreeIO looks like, to be honest. Since IO has to be generated by it and some Forget functor as well
11:54:17 <luite> dons: is it slow?
11:55:15 <roconnor> forgot a primitive, ... I *think* you can add it in and the semantics of programs that didn't use ares still the same.
11:55:26 <roconnor> *didn't use it
11:55:44 <conal> roconnor: "free monad generated ..."
11:55:47 <conal> which reminds me: is IO really a monad?
11:56:09 <aristid> conal: what makes you doubt?
11:56:10 <roconnor> conal: sequential IO is a monad.
11:56:14 <conal> have the required laws been proved for IO? and if so, for which IO?
11:56:21 <conal> aristid: ^^
11:56:47 <conal> roconnor: do you mean the IO = State World fiction?
11:56:53 <roconnor> very much not
11:56:56 <roconnor> :)
11:57:16 <conal> roconnor: .. by "sequential IO"?
11:57:42 <roconnor> conal: no non-determinism, ie no threads, and probably no lazy IO.
11:57:59 <conal> aristid: i doubt IO's monadness because i've never seen a proof.
11:58:18 <conal> roconnor: and no program/world interaction ?
11:58:34 <roconnor> conal: I'd define monadness as part of the spec of IO.  So if you don't satify the law, your implementation is broken.
11:58:34 <Jafet> If it isn't a monad, what would it mean?
11:58:49 <roconnor> conal: yes program/world interaction.
11:59:08 <roconnor> conal: we have good models of teletype IO
11:59:15 <roconnor> if I recall well
12:00:00 <conal> roconnor: so maybe shift the question. has anyone implemented IO according to the monad-ness part of the spec?
12:00:25 <tjgillies> in ghci i do, let foo = 5 then let foo = foo +1 then i enter foo and it just hangs
12:00:25 <roconnor> I don't know.
12:00:51 <roconnor> tjgillies: the third foo is a reference to the second foo, not the first foo.
12:01:00 <conal> Jafet: if we don't know whether IO is a monad, it'd we better quit talking about "the IO monad" for one thing.
12:01:16 <zaero> "let foo = foo + 1" defines a recursive function
12:01:17 <Jafet> I bet even a broken implementation can be spun as a monad, just not over the right category.
12:01:21 <conal> Jafet: and quit applying monad laws during compilation (if indeed they're applied).
12:01:27 <roconnor> conal: I suspect threaded IO is still a monad, but I'm not as sure.
12:01:52 <Jafet> Also, the report specifically mentions nondeterministic IO for getContents and readFile, so I would presume that they just didn't consider it important.
12:02:19 <roconnor> I haven't seen any models yet
12:02:38 <conal> roconnor: i suspect it is, too, given a good choice of equality on IO. however, normally we have a higher standard than suspicion for the properties we claim.
12:02:56 <conal> since monad-ness is a mathematical statement.
12:02:58 <roconnor> properties?
12:03:07 <conal> the laws
12:03:22 <roconnor> conal: so what does Moggi have to say about IO?
12:03:34 <conal> roconnor: no idea.
12:03:49 <conal> roconnor: maybe nothing at all.
12:04:08 <roconnor> maybe
12:04:49 <conal> i wonder whether the first claim of "IO is a monad" is in the research literature.
12:05:12 <conal> maybe in "Imperative functional programming"
12:05:40 <roconnor> conal: I'm sure the IO monad can easily be modeled using the previous [Request] -> [Response] craziness that haskell had before.
12:05:58 <c_wraith> wasn't it the other way around?
12:06:03 <roconnor> so in that sense the IO monad is as satifactory as the previous use of IO in haskell.
12:06:24 <conal> roconnor: i wonder. you might be a bit eager to be sure already.
12:06:55 <roconnor> c_wraith: I'm expecting somethings can be written with [Request] -> [Response] that cannot be written with IO
12:07:15 * conal scans through "Imperative functional programming"
12:09:06 <balor> Say you've got a union data type "data Tree = Branch Tree Tree | Leaf".  And you want a similar tree that only contains Quack at the leaves.  Would you create another type "data qTree = qBranch qTree qTree | Quack"?
12:09:47 <conal> offhand, i don't see a demonstration in "Imperative functional programming" that IO is a monad.
12:09:57 <tjgillies> whats the point of forcing you to use 'let' when you're in main?
12:10:35 <conal> tjgillies: what forces you to 'let' in main?
12:10:50 <Jafet> Maybe someone has him at gunpoint.
12:11:04 <tjgillies> conal: haskell?
12:11:14 <zaero> if you mean ghci, its because you're basically typing into a do block
12:11:27 <conal> tjgillies: what leads you to believe you have to use 'let' in main in haskell?
12:11:42 <tjgillies> conal: because you have to in ghci, hrm
12:11:49 <tjgillies> i guess im wrong
12:12:00 <conal> tjgillies: ah. different story.
12:12:14 <conal> tjgillies: ghci adds an enclosing "do"
12:12:34 <tjgillies> so why do you have to use let in a do block i guess is my real question
12:12:52 <ion> What would you suggest instead?
12:13:09 <tjgillies> foo = "bar"
12:13:23 <tjgillies> or does that breaking the chaining
12:13:52 <mauke> it makes the syntax ambiguous
12:14:32 <conal> roconnor: moggi used monads for structuring denotational semantics, so he almost certainly didn't apply it to IO (which lacks a den sem).
12:14:55 <roconnor> conal: I'm not so surprised
12:28:25 <luite> dons: the server seems to cope with the load, but it uses al my upstream capacity at times, since it's on my home adsl connection
12:28:50 <tg_> conal: wait, after all this nobody has ever proved (demonstrated?) that IO is even a monad?
12:29:15 <conal> tg_: afaict.
12:29:25 <tg_> conal: that makes me giggle a bit
12:29:58 <roconnor> tg_: when you don't know what IO is it is hard to prove stuff about it
12:30:15 <tg_> roconnor: I get it, but I do think it's funny...
12:30:48 <tg_> conal: can I divert your attention to a private chat for ~ 15 minutes?
12:31:02 <conal> tg_: i wonder if talk of IO being RT and a monad gives people some sort of misguided comfort about using IO. as if it's somehow principled.
12:31:09 <conal> tg_: yep
12:32:38 <shachaf> conal: I doubt it.
12:33:03 <conal> shachaf: which part? the comfort? or the misguided? or ??
12:33:46 <conal> (or *parts*)
12:33:47 <shachaf> I doubt that people care about being principled that much when using IO, or that using the word "monad" makes them feel like they are.
12:34:43 <shachaf> It's pretty much like your average imperative programming language (well, not really).
12:34:53 * shachaf enjoys how strongly conal feels about the issue.
12:36:20 <conal> i worry that IO led FP away into a dark age, away from the denotative nature that is/was the beauty & power.
12:37:47 <conal> ... and what is now widely accepted as FP has the same essential flaws that led Backus & others to promote FP as a replacement for imperative programming. that's why i agitate.
12:38:48 * hackagebot campfire 0.0.1 - Haskell implementation of the Campfire API  http://hackage.haskell.org/package/campfire-0.0.1 (MichaelXavier)
12:38:55 <djahandarie> Even though we have IO, it is pretty much standard practice to avoid it as much as possible and do everything in a denotative manner until the very top of your program where you smash it all together in IO.
12:39:28 <djahandarie> I think this is only possible with what is now called FP, and was not in the imperative programming ages.
12:39:29 <mauke> not in my code
12:39:32 <Jafet> You mean standard wishful thinking
12:39:35 <mauke> preflex is almost completely IO
12:39:38 <conal> which, sadly, requires that there is a top, ie an end to composability.
12:39:51 <conal> djahandarie: ^^
12:39:56 <Jafet> My code is littered with IOUArrays right now
12:40:10 <Jafet> I feel like I'm indebted to something there
12:40:12 <roconnor> conal: hpaste isn't working for me :/
12:40:15 <conal> djahandarie: plus, i see a shitload of IO code in haskell libraries. not just in main.
12:40:20 <conal> roconnor: :(
12:40:34 <djahandarie> conal, then they're doing it wrong. ;)
12:40:37 <shachaf> mauke: Isn't rpeflex written in Perl?
12:40:53 <mauke> shachaf: no, haskell
12:41:00 <shachaf> Oh.
12:41:25 <roconnor> literate haskell syntax highlighting seems borked
12:41:32 <roconnor> conal: http://hpaste.org/46854/io___dialogue
12:41:39 <roconnor> interp :: IO () -> Dialogue
12:42:20 <conal> djahandarie: structural support like type systems and proof systems get people to do things "right" (rigorously and hopefully elegantly). lacking for the basic problems of IO (outlined by in Backus's Turing Award lecture).
12:51:39 <roconnor> conal: oh oops.  I ended up not using TailList at all
12:52:04 <roconnor> conal: I was going to write interp IO a -> [Response] -> TailList a Request
12:52:21 <roconnor> but in the end I decided IO () -> Dialogue was good enough.
12:53:10 <conal> roconnor: assuming you show that *this* IO type (not Haskell's/GHC's) is a monad, then what?
12:53:53 <roconnor> conal: then in Haskell 1.3, the IO monad is just as well defined as Haskell 1.2's IO mechanism
12:54:31 <conal> roconnor: your io dialogue type is from haskell 1.2?
12:54:42 <conal> and what connection are you making to 1.3?
12:55:02 <roconnor> IO a is a type in Haskell 1.3
12:55:08 <roconnor> Dialogue is a type in Haskell 1.2
12:55:32 <roconnor> I've written an interpetation form Haskell 1.3's IO to Haskell 1.2's dialogue
12:56:06 <roconnor> I think I can prove it is injective.
12:56:30 <conal> roconnor: injective w.r.t. what equality?
12:56:43 <roconnor> Dialogue in Haskell 1.2 is a well defined abstract data type
12:56:45 * roconnor double checks
12:57:03 <conal> roconnor: does the interpretation preserve monad properties?
12:57:25 <roconnor> I'm not convents the target type has a nice monad structure.
12:57:27 <roconnor> *convinced
12:58:22 <roconnor> first of all it isn't even a type constructor :D
12:58:58 <conal> roconnor: i'm not clear where you're trying to get here. but it sure sounds like something worth working out to see where it goes and writing it up as a blog post if nothing else. if you do, please let me know!
12:59:05 <roconnor> but even if we considered a "Dialogue a = [Response] -> TailList a Request", I don't think it would work out.
12:59:29 <roconnor> conal: let's see. Haskell 1.2 has a concrete data type.
12:59:46 <roconnor> oops above I should have written
12:59:55 <roconnor> Dialogue in Haskell 1.2 is a well defined *algebraic* data type
13:00:09 <roconnor> so it has relatively clear semantics
13:00:33 <roconnor> there is a subset of this algebraic data type which is isomorphic to the image of IO () under my interp
13:00:41 <roconnor> my IO type is a monad.
13:01:24 <roconnor> I guess it is worth noting that in Haskell 1.2 and even the current haskell, the IO mechism interprets IO (), not IO
13:01:42 <roconnor> so the "IO monad" is a generaliation of an IO data type, which is IO.
13:02:02 <roconnor> I've done this sort of generalization myself in the past
13:02:10 <roconnor> I have some datatype foo I'm interested in.
13:02:47 <roconnor> and there is a nice monad bar that I can use to construct foo in that there is some a such that bar a = foo.
13:03:06 * roconnor did this in his AssemblyCode monad.
13:03:13 <conal> roconnor: oh -- is your plan ultimately to take our current IO and map it into the dialog type? in a way that preserves the truth or falsity of the monad laws?
13:03:26 <roconnor> conal: not quite
13:03:27 <conal> roconnor: note: *current*
13:03:41 <roconnor> I'm only maping IO () to Dialogue
13:03:46 <roconnor> and IO is a monad.
13:03:55 <Jafet> Hm, which current IO?
13:04:19 <roconnor> since the interp isn't a functor from IO to anything, we can't even talk about preserving the monad laws.
13:04:21 <conal> roconnor: i've got to go in a few minutes. i don't know whether you're onto something or not. but just in case you are, i do encourage you to write it up so people (including me) can read & consider it carefully.
13:04:28 <roconnor> ok
13:04:37 <roconnor> actually I think I've learned something here.
13:05:13 <roconnor> IO () is really the Input/Output type in Haskell. and IO a is some random more general type that is useful for building IO ().
13:05:15 <aristid> is there a package that can automatically convert ADTs to trees?
13:05:22 <aristid> ASCII trees, that is
13:05:43 <elliottt> aristid: ppsh
13:05:57 <jmcarthur> i am not convinced that establishing the semantics of IO is likely to be a worthwhile pursuit. i suspect that even if we find something that is not a mere approximation, it is likely to be too complicated to make reasoning about IO any easier
13:06:01 <elliottt> aristid: sorry, pretty-show
13:06:09 <aristid> @hackage pretty-show
13:06:09 <lambdabot> http://hackage.haskell.org/package/pretty-show
13:08:00 <aluink> I've been looking at this for a while now and can't seem to figure out why this isn't a category.  The hint suggests assosiativity, http://en.wikibooks.org/wiki/File:Not-a-cat.png
13:08:23 <aluink> oye! associativity*
13:09:20 <aristid> elliottt: neat.
13:09:38 <elliottt> :)
13:10:09 <conal> jmcarthur: i think so also. for me a big value in making semantics precise (especially denotational) is that it gives clear design feedback. if the formalization is complex, then correct reasoning is impractical.
13:11:05 <conal> jmcarthur: an example being concurrent imperative programming. the denotational models i know are *much* more complicated than toy sequential languages or frp.
13:11:52 <djahandarie> roconnor, interesting insight
13:11:54 <conal> but when people stay at the handwaving stage, then the complexity and consequent impracticality remains hidden.
13:12:20 <roconnor> djahandarie: ya, the monad part of IO is irrelevent for IOing
13:12:29 <roconnor> only the type IO () does IOing
13:13:17 <elliottt> aluink: f o g : A -> A
13:14:16 <conal> this irrelevance of monad-ness to IO is one of several reasons i wish people would quit talking about "the IO monad", and just say "IO" instead.
13:14:35 <aluink> elliottt: I hope that's a hint and not the answer...cause I don't get it :)
13:14:35 <roconnor> well there is a data type in Haskell called IO and it is a monad.
13:14:40 <mauke> conal: full ack
13:15:17 <parcs> @hoogle Monad m => Maybe a -> (a -> m ()) -> m ()
13:15:17 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:15:17 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:15:17 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:15:18 <conal> roconnor: it *might* be a monad. and it also is (might be) a functor, applicative, num, monoid, ...
13:15:20 * mauke will start talking about "the function functor" to confuse C++ programmers
13:15:25 <copumpkin> "the X monad" in general is annoying
13:15:30 <djahandarie> conal, I agree with that entirely. Also just so people stop being so dumbfounded at the word 'Monad'. :)
13:15:36 <copumpkin> unless you're actually using the monadic behavior
13:15:44 <elliottt> aluink: hint :)
13:15:54 <conal> roconnor: so for consistency, we ought to tack on all those other attributes
13:16:03 <conal> roconnor: or drop "monad"
13:16:10 <copumpkin> teh IO
13:16:13 <parcs> :t flip (maybe (return ()))
13:16:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> (a -> m ()) -> m ()
13:16:14 <roconnor> conal: those are ar all more or less implied by having a monad instance
13:16:39 * aluink pegs his CPU at 100%
13:17:20 <roconnor> conal: at work I talk about the group of automorphisms, even though it is a semigroup, monoid, loop, linear transformation, etc.
13:17:29 <djahandarie> I really wish the IO return and IO (>>=) were exposed as their own functions, seperate from the Monad instance. (Some GHC modules do this, but that is fairly useless for teaching purposes...)
13:17:32 <shachaf> "IO" is slightly ambiguous used on its own, unfortunately.
13:17:37 <conal> roconnor: ah, okay.
13:17:40 <roconnor> *group of field automorpisms
13:17:46 <djahandarie> shachaf, I tend to say "the IO type".
13:17:47 <conal> gotta run now.
13:17:53 <roconnor> later
13:17:57 <djahandarie> Cya conal.
13:18:01 <shachaf> djahandarie: Do you tend to say "the Maybe type"?
13:18:02 <conal> roconnor: write that blog post (or series)!
13:18:08 <conal> djahandarie: later. :)
13:18:16 <shachaf> (Also, it's a type constructor.)
13:18:32 <djahandarie> shachaf, depends if "Maybe" is ambiguous in the context or not.
13:18:43 <djahandarie> shachaf, and I like to think of type constructors as types in the same sense that functions are values.
13:19:07 <djahandarie> I *think* the report agrees with me there but I forget
13:19:28 <shachaf> djahandarie: Isn't a type something that a value can be ::?
13:19:30 <aluink> elliottt: ok...i think need more :(
13:19:38 <roconnor> In my assembly code article I had two type definitions:
13:19:47 <roconnor> newtype AssemblyCodeMonad a = ...
13:19:55 <roconnor> type AssemblyCode = AssemblyCodeMonad ()
13:20:10 <elliottt> aluink: can you give me the context for the image?
13:20:18 <roconnor> perhaps communication would be clearer if we had two such names in Haskell
13:20:27 <roconnor> data IOMonad a = ...
13:20:33 <roconnor> type IO = IOMonad ()
13:20:36 <roconnor> main :: IO
13:20:47 <aluink> elliottt: sure, http://tinyurl.com/ybbp7ez
13:21:11 <shachaf> roconnor: I don't think that really responds to any of the objections to calling it "the IO monad".
13:21:14 <keep_learning> foldr
13:21:31 <keep_learning> :t foldr
13:21:32 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:21:38 <shachaf> http://foldr.com/
13:21:39 <roconnor> shachaf: I think it responds to some of the objections.
13:21:42 <keep_learning> :t forall
13:21:43 <lambdabot> Not in scope: `forall'
13:22:02 <keep_learning> :t ap
13:22:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:22:08 <djahandarie> shachaf, I suppose in literature the word 'type' usually means something with kind *. But it is also used in the term 'type level', which would be wrong, since things on the type level can have other kinds.
13:23:06 <dafis> djahandarie: that's how I use the word type, for * -> * etc, I use 'type expression'
13:23:14 <dons> 800 woot woot
13:23:18 <dafis> which isn't optimal
13:23:29 <dafis> dons: 800?
13:23:35 <dafis> ah!
13:23:44 <dafis> j'ai compris
13:24:26 <djahandarie> dafis, yeah. Not sure. System F_omega and lambda_omega both only call type expressions with kind *, 'types'.
13:24:26 <tg_> ne parle pas francias
13:24:28 <tg_> get what?
13:24:57 <shachaf> dons: 800?
13:25:05 <dafis> tg_: population in #haskell >= 800
13:25:14 <jmcarthur> woo!
13:25:34 <tg_> dafis: ah, my client doesn't list that
13:25:51 <shachaf> Aha.
13:25:53 <jmcarthur> it was 806 for a second there
13:25:53 <mauke> tg_: /n -count
13:26:00 <tg_> does this mean if (#haskell >= 800) could be the trigger for our soon apocalypse?
13:26:04 <shachaf> Didn't lambdabot use to measure this?
13:26:10 <jmcarthur> ?users
13:26:10 <lambdabot> Unknown command, try @list
13:26:18 <jmcarthur> think so. not anymore
13:26:20 <shachaf> I guess it went away with @seen.
13:26:21 <dafis> tg_: apocalypse needs 1000
13:26:25 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
13:26:25 <djahandarie> I don't like the inconsistency between 'value level'/'values' and 'type level'/'type expressions' (rather than just 'types').
13:26:30 <shachaf> Why was @seen removed, anyway?
13:26:31 <tg_> dafis: we don't have much time for it to happen on Saturday, then
13:26:46 <tg_> shachaf: requires lambdabot to have a large head?
13:26:53 <cydergoth> Hi all - anyone got any insight into this error compling BLAS with 7.0.3? http://hpaste.org/46859/blas_error_703
13:26:54 <dafis> tg_: there's more than one saturday :)
13:27:05 <shachaf> djahandarie: True, I suppose. Do you have a word for "type of kind *"?
13:27:13 <jmcarthur> nice omegix
13:27:37 <tg_> dafis: Damn it, you're right. Plus, all us computer scientists know that the end of the world will be misjudged by a calendar conversion off-by-1 error
13:27:50 <djahandarie> shachaf, I just checked the Haskell report. It uses "nullary type constructor" for *, and "type" for the general case.
13:28:24 <djahandarie> So I'll continue to say what I was saying. ;)
13:28:25 <jmcarthur> omegix: you currently hold the title of making #haskell beat its record :P
13:28:35 <elliottt> aluink: i thought i understood it, i do not. :)
13:28:41 <djahandarie> jmcarthur, going to say that to everyone who enters the room? ;)
13:28:43 <tg_> elliottt: welcoem to my life
13:28:48 <elliottt> hehe
13:28:51 <jmcarthur> djahandarie: i know omegix ;)
13:28:59 <aluink> elliottt: ok ;)
13:29:16 <elliottt> i'll ask around.  there are some guys that know category theory here
13:29:19 <tg_> djahandarie: so star-type = * = "nullary type constructor", anything else is a type?
13:29:39 * tg_ peers towards copumpkin
13:29:53 <copumpkin> ?
13:29:53 <erus`> chrome.angrybirds.com
13:29:55 <erus`> wow
13:29:56 <dafis> :t zipWithM_
13:29:58 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
13:30:02 <erus`> html5 is getting serious
13:30:04 <aluink> anyone else care to help explain why http://tinyurl.com/5uuv6am isn't a category (context: http://tinyurl.com/ybbp7ez)
13:30:17 <tg_> copumpkin: with a name like that, you've got to be a cateogory theorist?
13:30:22 <copumpkin> aluink: ah, that one
13:30:23 <djahandarie> tg_, huh? A type can have any kind. A type with kind * is called a "nullary type constructor". A type with kind * -> * is called a "unary type constructor". etc.
13:30:52 <copumpkin> aluink: we have a ##categorytheory too, by the way :)
13:31:00 <elliottt> aluink: the only thing that i can think of is that if you compose f . g . h, you get something that has two equivalent morphisms.  might violate closure, or something
13:31:16 <elliottt> h = f . g . h, f = f . g . h
13:31:18 <aluink> i don't see how having f isn't a problem, but then just adding another that does the same breaks it, namely h
13:32:20 <aluink> yeah, i thought of that, but take sin and cos for example and those do teh same thing no?
13:32:23 <luite> does pandoc have a syntax for comments?
13:32:34 <tg_> if you add a g' from a to b
13:32:37 <tg_> does that make it a category?
13:32:59 <aluink> tg_: i'm wondering that myself
13:33:14 <copumpkin> well, that would depend on what makes it not a category to begin with :)
13:33:23 <tg_> aluink: I'm thinking that one of those two is acting like an absorber
13:33:33 <tg_> or a forgetful ... functor... or whatever it's called
13:33:45 <copumpkin> nope
13:34:02 <tg_> are the idA and idB things automatically valid?
13:34:32 <elliottt> tg_: yes
13:34:37 <Peaker> I wish the blahM_ functions took   m ()   rather than   m throwAway
13:34:43 <Philonous> djahandarie: I always thought types where properties of values, as in "(3+2) has type Int", and even though there are empty types they could at least conceptually be inhabited by some value (and in haskell this is always the case), but it doesn't even make sense to ask which values are a member of "Maybe"
13:35:03 <aluink> every object in a category requires an identity, by definition
13:35:22 <tg_> aluink: yeah, reading that now
13:35:37 <aluink> copumpkin: ##categorytheory is pretty quiet
13:36:07 <Peaker> #haskell was larger than #python at one point.. now it is smaller again :-(
13:36:16 <tg_> Peaker: still smarter
13:36:24 <Peaker> (919 vs 811)
13:36:26 <tg_> and more helpful... maybe (I've never been in #python)
13:36:32 <cydergoth> Repeat: anyone got any insight into this error compling BLAS with 7.0.3? http://hpaste.org/46859/blas_error_703 blas compiles fine with 6.12 but fails with what looks like a sensible error
13:36:40 <aristid> Peaker: 811? wow, #haskell is big
13:36:44 <Peaker> tg_: Python is somewhat helpful, but no place is as helpful as #haskell :-)
13:36:50 <jmcarthur> was 812 a minute ago
13:36:58 <ion> peaker: What’s the benefit? Just making the intention of the code explicit by potentially requiring something like () <$ foo?
13:37:04 <dons> cydergoth: afaik it doesn't compile with ghc 7, due to some annoying type bug
13:37:09 <aristid> last time i looked (before now), it was 760 or so
13:37:17 <tg_> aluink: does associativity hold?
13:37:21 <Peaker> ion: yeah, avoiding accidental ignoring of results, too
13:37:22 <\yrlnry> djahandarie:  I'm pretty sure the jargon in the Haskell report follows the convention that type constructors can have any kind, but only type constructors of kind * are called 'types'.
13:37:35 <Peaker> ion: Sometimes people return various error types that aren't IO exceptions
13:37:35 <cydergoth> dons: thanks, is the type bug in 7 or BLAS do you know?
13:37:39 <dafis> aluink: I think the diagram is meant to indicate all 'morphisms' in the 'category (which isn't)', then you'd have g . f = idA = h . f, hence g = idA . g = (h . f) . g = h . (f . g) = h . idB = h
13:37:40 <djahandarie> \yrlnry, I just doubled checked, it doesn't.
13:37:41 <develhevel> want to use leksah, but when i use System.Directory i get "Perhaps you need to add `directory' to the build-depends in your .cabal file." but i added directory and it still dont run, any idea?
13:37:47 <djahandarie> \yrlnry, http://www.haskell.org/onlinereport/decls.html#sect4.1.1
13:37:52 <ion> peaker: Ah, true.
13:37:58 <jmcarthur> is there a word for "things at the type level" like types and type constructors?
13:38:02 <dons> cydergoth: don't know. you need to report it to the maintainer
13:38:20 <Peaker> type-level values? :-)
13:38:22 <djahandarie> jmcarthur, according to the Haskell report, thing at the type level are "types". * is "nullary type constructor".
13:38:37 <\yrlnry> djahandarie:  you're right.
13:38:38 <cydergoth> dons: Looking at the error I've got that looks like the compiler complaint is correct
13:38:40 <tg_> dafis: is that right? g . f = idA = h . f?
13:39:06 <djahandarie> But dafis proposed another hierarchy (which doesn't matched the Haskell Report): things at the type level are "type expressions". * is a "type", all other kinded type expressions are "type constructors".
13:39:16 <djahandarie> Man I can't type. Heh. No pun intended.
13:39:27 <tg_> djahandarie: sure sure, mister funny man
13:39:29 <cydergoth> dons: In that the only guarantee in the type signature is that both e and f are Elem
13:39:48 <djahandarie> I prefer the Haskell Report's terms.
13:40:01 <cydergoth> dons: so you can't deduce an equivalence - is my reading of the error message correct?
13:40:15 <dafis> tg_: I don't know how the diagram is meant, I took it all 'morphisms' were shown, so Mor(A,A) has only one element, idA, so there's no choice
13:40:44 <aluink> dafis: how is h . f even possible?
13:40:52 <tg_> dafis: yeah it looks backwards
13:41:13 <jmcarthur> i tend to maintain the type and type-constructor distinction, but then there is no firm name for "type-level values"
13:41:23 <dafis> djahandarie: I didn't propose it, I read it somewhere and found it useful to distinguish between type eypressions of kind * and type expressions of arbitrary kind
13:41:54 <dafis> aluink, tg_: I may have gotten the letters wrong
13:42:19 <dafis> wasn't it f :: A -> B, g,h :: B -> A?
13:42:22 <aluink> dafis: oye, sorta hard to follow the logic that way :)
13:42:25 <jmcarthur> at the value level, functions are values. at the type level, type constructors are not types (assuming types are intended to have relationships with values)
13:42:35 <jmcarthur> i find that assymmetry annoying though
13:42:44 <tg_> dafis: g :: A -> B; f,h :: B -> A
13:42:49 <aluink> dafis: g : A -> B, f,h : B -> A
13:42:52 <aluink> :)
13:43:05 <dafis> okay, then exchange g and f above
13:43:17 <djahandarie> jmcarthur, yes, which is why I like the Haskell Report's terms better.
13:43:22 <djahandarie> Types on the type level, values on the value level, etc.
13:43:28 <tg_> aluink: first, can you have a cateogory with only 2 objects?
13:43:48 <jmcarthur> djahandarie: but i also find the idea that i can have a "type" which doesn't relate to the value level in any way
13:43:52 <jmcarthur> annoying*
13:43:59 <copumpkin> tg_: sure
13:44:04 <tg_> if you can, then one of them has to play the role in the associativity twice
13:44:05 <aluink> I dont see why not, consider A with idA
13:44:10 <djahandarie> jmcarthur, right. I think I find it less annoying though.
13:44:24 <aluink> and B with idB
13:44:26 <djahandarie> I've been searching in my head for a bit to find out why.
13:44:27 <copumpkin> anyway, the problem is associativity
13:44:33 <copumpkin> http://hpaste.org/46861/associativity_violation
13:44:45 <aluink> copumpkin: yeah, that's been the hint...but can't seem to figure out why
13:44:54 <copumpkin> aluink: I wrote an explanation in there :P
13:44:59 <tg_> aluink: well he spells it out in there
13:45:03 <tg_> i can't believe i got it right :O
13:45:35 <parcs> can anyone show me how unsafePerformIO can create the coerce function a -> b?
13:45:36 <scooty-puff> is there a way to force the evaluation of a type function?  i am keeping some type synonyms unexported, but unevaluated type functions lets them leak out
13:45:54 <djahandarie> scooty-puff, GHC 6?
13:45:57 <scooty-puff> parcs: using pointers
13:46:04 <scooty-puff> castPtr
13:46:08 <scooty-puff> :t castPtr
13:46:08 <djahandarie> scooty-puff, I think I hit a weird bug like that in GHC 6 which was fixed in 7.
13:46:09 <mauke> parcs: create a global IORef a
13:46:09 <lambdabot> Not in scope: `castPtr'
13:46:12 <c_wraith> scooty-puff: are you the jr. or sr. model? :)
13:46:15 <jmcarthur> parcs: by making a polymorphic reference, writing to it as one type, then reading from it as another
13:46:29 <scooty-puff> Senior - the Doombringer!
13:46:44 <tg_> Our fellow Niblonians would be proud.
13:46:47 <parcs> how would one create an IORef a?
13:46:58 <scooty-puff> :t newIORef
13:46:58 <lambdabot> Not in scope: `newIORef'
13:47:03 <parcs> @hoogle newIORef
13:47:03 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
13:47:04 <jmcarthur> parcs: unsafePerformIO $ newIORef undefined :: IORef a
13:47:13 <parcs> ah, so it required undefined as well
13:47:17 <parcs> didn't know that
13:47:27 <aluink> w00t, that makes sense now
13:47:47 <aluink> oh look, 5pm...off for a bike ride
13:47:56 <aluink> thanks all!
13:47:56 <scooty-puff> djahandarie, 7 i believe, is this just laziness at the type system level as well?
13:47:58 <djahandarie> jmcarthur, I think it feels weird in Haskell since this statement becomes true: "There are types that are not inhabited by undefined".
13:48:01 <parcs> such a function a -> b in this case will always error, right?
13:48:10 <djahandarie> scooty-puff, definitely double check the version. It shouldn't happen.
13:48:16 <parcs> oh wait
13:48:18 <parcs> nevermind
13:48:20 <djahandarie> (Assuming I'm understanding your problem correctly.)
13:48:57 <jmcarthur> djahandarie: well, i'm more weirded out by the implication that there might be a relationship between Maybe and values (even if there are no values of Maybe, there is at least an implied relationship if Maybe is a "type")
13:48:58 <scooty-puff> hurray for ubuntu battery monitor bug..
13:49:40 <scooty-puff> cabal build --ghc-options=--version
13:49:43 <scooty-puff> gives:
13:49:47 <jmcarthur> the type checker doesn't allow  foo :: Maybe, but the "type" terminology seems to say that that should be valid in some way
13:50:02 <scooty-puff> The Glorious Glasgow Haskell Compilation System, version 7.0.3
13:50:17 <scooty-puff> its not failing to where it should, i just prefer it would even when not strictly required
13:50:27 <djahandarie> scooty-puff, weird. Could you drop something in hpaste.org?
13:50:30 <scooty-puff> to avoid names leaking out of the module
13:50:31 <scooty-puff> ok
13:50:48 <scooty-puff> the file is rather large, let me pair it down some
13:50:53 <scooty-puff> *pare?
13:53:05 * hackagebot hsx-jmacro 6.0.1 - hsx+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-6.0.1 (JeremyShaw)
13:53:38 <djahandarie> jmcarthur, hmm. I think it's bad that we are being weirded out by this. It should feel inuitive that certain types are not in the correct form to be inhabited at all. I think the terms would get even more crazy if you added another level of sorts.
13:53:51 <Peaker> jmcarthur: Why does  unsafePerformIO (newIORef undefined)  result in: forall a. IORef a    but  newIORef undefined >>= \(x :: forall a. IORef a) -> ...     not result in x being that type? (the latter does not type check)
13:54:13 <c_wraith> Peaker: >>= doesn't allow polymorphic arguments
13:54:15 <scooty-puff> djahandarie, so, would undecidable instances make it not reduce if it can't infer that it is decidable?
13:54:42 <Peaker> c_wraith: if it did, then we could have unsafeCoerce in IO without unsafePerformIO?
13:54:48 <c_wraith> Peaker: yep
13:55:14 <scooty-puff> www.hpaste.org just gives a blank screen..
13:55:29 <scooty-puff> hmm, nm
13:55:31 <Peaker> m a -> (a -> ..) -> ..     it sounds like the "a" being impredicative should allow it to be "forall b. IORef b"
13:55:34 <scooty-puff> hpaste.org works
13:55:52 <djahandarie> scooty-puff, I don't think undecidable instances would do that
13:55:55 <scooty-puff> http://hpaste.org/46862/type_functions
13:56:02 <c_wraith> Peaker: yes, but it's not impredicative.
13:56:23 <scooty-puff> the idea is Take One () should not reduce (i would prefer some sort of compile time error - one will eventually show up)
13:56:35 <scooty-puff> Take One (Int, ()) will - to Int
13:56:38 <scooty-puff> etc.
13:56:48 <Peaker> c_wraith: but with impredicative types enabled, IORef a  should allow the "a" to be that, shouldn't it?  Though I guess IORef (forall a. a) is not the type we want, so that wouldn't help anyway
13:57:16 <scooty-puff> more code may be require - this paste was maybe overly minimal
13:57:53 <scooty-puff> hmm, i misspoke
13:58:01 <scooty-puff> Take One () = (), etc.
14:00:45 <roconnor> forall a. a is isomorphic to Void
14:02:13 <djahandarie> scooty-puff, Take One (Int, ()) = (Int, Take (Subtract One (Category Int)) ()) = (Int, Take (Subtract One One) ()) = (Int, Take (Subtract Zero Zero) ()) = (Int, Take Zero ()) = (Int, ())     -- right?
14:02:16 <Peaker> yeah, I know
14:02:36 <scooty-puff> djahandarie, right
14:02:48 <Peaker> roconnor: Impredicative types extensions helps create the type IORef (forall a. a) (or IORef Void), but not:  (forall a. IORef a)   as an argument to a function
14:02:49 <djahandarie> scooty-puff, and this doesn't happen?
14:02:58 <Peaker> extensions->extension
14:03:00 <scooty-puff> it doesn't until its required too, i.e.:
14:04:18 <scooty-puff> hmm.., i think the behavior is expected - in the particular case, it can't reduce because there are type variables in the function
14:04:39 <djahandarie> It should reduce in any case that it has enough information to.
14:04:52 <scooty-puff> o!
14:04:53 <scooty-puff> found it
14:05:00 <scooty-puff> its actually just plain type synonyms
14:05:03 <djahandarie> What you are seeing as "lazy" behavior may just be something unifying the type variable to something it can work with
14:05:26 <scooty-puff> ok - let me paste this new case now
14:07:03 <Peaker> > let f (x :: forall a. Show a => a -> String) = (x 1, x 'a')    in    f show
14:07:03 <lambdabot>   ("1","'a'")
14:08:46 <scooty-puff> http://hpaste.org/46863/type_synonyms
14:09:10 <scooty-puff> djahandarie, the Instruction synonym doesn't get reduced before being refered to outside the module
14:09:26 <Peaker> it seems that (IORef a)  should ban the "a" from being polymorphic (even in unsafePerformIO..), whereas other type variables have no problem being polymorphic.   Impredicative types allows polymorphism everywhere which seems problematic w.r.t co/contra-variance
14:09:39 <Peaker> Maybe Scala's variance specifications are justified?
14:10:00 <djahandarie> scooty-puff, what do you run specifically?
14:10:10 <scooty-puff> load that in ghci, then :t aaload
14:11:05 <Peaker> I am not sure I fully understand why the "a" in (>>=) :: m a -> (a -> ...     cannot be polymorphic, whereas the "a" in   unsafePerformIO :: IO a -> a    can be polymorphic.. It seems it is because of the location of the "forall", and almost an accident that unsafePerformIO is not possible
14:11:07 <scooty-puff> i assume it would show MonadCode m => m (Int, (Reference, xs)) (Reference xs) (Label m (Int, (Reference, xs)))
14:11:38 <scooty-puff> instead:
14:11:47 <scooty-puff> aaload :: MonadCode m =>  Instruction m (Int, (Reference, xs)) (Reference, xs)
14:11:55 <Peaker> I guess for full impredicative types in conjunction with mutatable types -- you really need to be able to specify limits on variance
14:12:38 <djahandarie> scooty-puff, that's just ghci.
14:12:44 <scooty-puff> ok
14:12:55 <djahandarie> It doesn't reduce type synonyms
14:13:14 <djahandarie> Not sure in what cases it does but it usually doesn't.
14:13:28 <scooty-puff> ok, thank you
14:13:46 <djahandarie> i.e.,    type X = Int;  foobar :: X; foobar = 3;         :t foobar  -- X
14:13:49 <djahandarie> Yep, no problem
14:15:06 * djahandarie runs home
14:15:17 <develhevel> is it possible in leksah to set e.g. "x <- getArgs" the x to some value?
14:19:51 <elliottt> scooty-puff: do you have a son?
14:19:57 <elliottt> (scooty-puff-jr :)
14:20:20 <scooty-puff> nah, he was sucked into a worm hole
14:20:23 <elliottt> hehe
14:21:28 <cydergoth> sometimes I feel that is what trying to use the Haskell compiler is like - being sucked into a wormhole
14:21:53 <elliottt> you get used to it
14:23:35 <cydergoth> Is there an easy way to say to the compiler 'look, I have these two types from two different packages but they are really the same set of 3 packed doubles so just regard them as interchangeable?'
14:23:48 <dankna> no
14:23:51 <elliottt> well, unsafeCoerce
14:23:56 <elliottt> but you really don't want that
14:24:08 <dankna> unsafeCoerce isn't actually safe if the constructors are different, is it?
14:24:11 <cydergoth> no, you're perfectly correct, I don't want that
14:24:39 <dankna> I'm guessing these are vectors in three-space?  heh
14:24:44 <cydergoth> I'm just drowning in different math packages, all of which have a different type for a basic 3 vector
14:24:59 <elliottt> hehe
14:25:07 <cydergoth> dankna: yeah, polysurfaces in cad/cam
14:25:09 <dankna> yeah, happens.  you could always pick one and fork the math packages to all use it
14:25:39 <parcs> @type fmap
14:25:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:25:47 <parcs> @type fmap fmap fmap
14:25:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:25:49 <cydergoth> doesn't that kinda defeat the objective of having standard libraries ?
14:25:53 <parcs> @type fmap fmap fmap fmap fmap fmap fmap
14:25:54 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
14:25:54 <aristid> @type (.:)
14:25:55 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
14:26:00 <aristid> @type (.:) .: (.)
14:26:01 <lambdabot> forall a b (f :: * -> *) (g :: * -> *) a1. (Functor f, Functor g) => (a1 -> b) -> (a -> a1) -> f (g a) -> f (g b)
14:26:09 <aristid> @type (.:) .: (.:)
14:26:10 <lambdabot> forall a (f :: * -> *) (g :: * -> *) a1 b (g1 :: * -> *). (Functor f, Functor g, Functor g1) => (a1 -> b) -> (a -> g1 a1) -> f (g a) -> f (g (g1 b))
14:26:25 <parcs> how many fmaps are required to compose a function with 4 arguments
14:26:45 <elliottt> one, with applicatives
14:26:56 <elliottt> you can just use ap as well
14:27:52 <parcs> what i should actually ask is how many fmaps are required for the type (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
14:28:20 <elliottt> oh, i see
14:28:24 <elliottt> four
14:28:34 <elliottt> fmap (fmap (fmap (fmap f)))
14:28:50 <parcs> @type \f -> fmap (fmap (fmap (fmap f)))
14:28:51 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f3 (f2 (f1 (f a))) -> f3 (f2 (f1 (f b)))
14:28:59 <parcs> point-freely?
14:29:03 <elliottt> can't help you :)
14:29:09 <elliottt> try @pl
14:30:16 <parcs> @pl \f -> fmap (fmap (fmap (fmap f)))
14:30:16 <lambdabot> fmap . fmap . fmap . fmap
14:32:12 <parcs> i meant without (.) too; just fmaps
14:32:56 <parcs> the reason i'm asking is because it seems impossible
14:33:12 <parcs> the highest nesting level seems to be 3 functors
14:33:19 <parcs> i only tried up to 20 fmaps with lambdabot
14:33:37 <cydergoth> elliot, do you think it would work if I created a type class and made all my various vector types members of that type class, then mapped the common set of operations to the type class?
14:34:35 <copumpkin> @ty fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
14:34:36 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
14:34:50 <ktosiek> cydergoth: isn't that what classes are for? (I'm learning, so I want to be sure I understand things correctly)
14:35:18 <cydergoth> well, kinda yes, but I think this would be an abuse of them
14:35:50 <parcs> copumpkin: how many is that? i'm sort of dyslexic
14:35:56 <parcs> i counted 21
14:36:06 <copumpkin> > length . words $ "fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap"
14:36:07 <lambdabot>   21
14:36:47 <parcs> @oeis 1 3 7 21
14:36:48 <lambdabot>  Triangle read by rows in which row n list the divisors of n.
14:36:49 <lambdabot>  [1,1,2,1,3,1,2,4,1,5,1,2,3,6,1,7,1,2,4,8,1,3,9,1,2,5,10,1,11,1,2,3,4,6,12,1,...
14:39:59 <ion> :t fmap `fmap` fmap `fmap` fmap `fmap` fmap
14:39:59 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
14:40:27 <parcs> that's also cheating :P
14:40:50 <c_wraith> :t fmap`fmap`fmap`fmap`fmap
14:40:51 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:41:02 <ktosiek> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap
14:41:03 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
14:41:50 <parcs> i wonder how many 5 take...
14:42:11 <ion> :t fmap fmap (fmap fmap (fmap fmap fmap))
14:42:12 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
14:43:04 <parcs> the problem is that too many fmaps and ghci swaps
14:43:43 <hpc> didn't it take a supercomputer and a custom type-checker to do 32 fmaps?
14:45:24 <parcs> well 51 fmaps takes at least 2GB of ram
14:46:11 <ezyang> I don't understand why people think fixing leaks Haskell code is hard. It's really really really easy. Just turn on profiling.
14:46:31 <ezyang> The answers just fall into your lap!
14:46:48 <c_wraith> ezyang: sometimes the profile doesn't tell you anything useful.  "the memory is all in TSOs.  great.  somehow threads aren't dying."
14:47:19 <c_wraith> ezyang: turned out threads weren't dying due to STM retries creating a thread backlog.
14:47:31 <ezyang> Oh, that's a really interesting example!
14:47:36 <int80_h> hey I'm trying to get a git repository. git fetch git://github.com/snoyberg/haskellers.git yields "fatal: not a git repositoyr". What's the right way?
14:47:55 <ezyang> In that case, Threadscope ought to be your friend...
14:47:57 <MarcWeber> int80_h:  try clone instead of fetch?
14:48:09 <c_wraith> ezyang: threadscope requires getting GTK working. :P
14:48:18 <ezyang> hehe
14:48:26 <int80_h> MarcWeber: Huh I would never have guessed that. Thanks. :)
14:48:40 <parcs> how does lambdabot avoid printing all those type class constraints that ghci prints when computing the type of, say, fmap fmap fmap fmap fmap fmap fmap?
14:48:43 <int80_h> I tried pull, and some other things
14:48:46 <ezyang> But really, I imagine most people who complain about space leaks don't have it coming from threads.
14:49:47 <shachaf> parcs: What do you mean?
14:49:49 <shachaf> @ty fmap fmap fmap fmap fmap fmap
14:49:50 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
14:50:03 <parcs> shachaf: try that with ghci
14:50:11 <jmcarthur> ezyang: i agree. it's greatly overblown
14:50:42 <c_wraith> ezyang: I don't disagree that the profiler tells you what you need most of the time.  But sometimes, things get strange. :)
14:50:49 <jmcarthur> heck, after you've used it for a while, it's pretty easy to avoid even introducing space leaks in the first time
14:50:56 <jmcarthur> *first place
14:51:08 <jmcarthur> how do i mix up time and place? good grief
14:51:18 <Lemmih> jmcarthur: Time leak. It happens.
14:51:18 <c_wraith> uncertainty principle
14:51:19 <ezyang> "time and space are the same thing"
14:51:39 <jmcarthur> i predicted all your answers
14:52:30 <Saizan> parcs: by having more instances in scope
14:52:40 <Peaker> int80_h: "fetch" brings all of the new pointed commits from some defined git "remote"... if you have a remote called "origin" pointing to github://..., when you "fetch origin", it will update all of the   origin/X  ptrs to their current location, and of course these pointers will be valid, meaning it also brings all the commits (in)directly pointed by them
14:53:05 <int80_h> Peaker: cool thanks :)
14:54:14 <Peaker> int80_h: "pull" is just a convenience command equivalent to "fetch" and then "merge".  "merge" makes a new commit that is parented by the current commit and some specific location. If unspecified it comes from the "default"/"tracking" location.  When you clone, your local branch/ptr "master" is set to merge from "origin/master" by default
14:54:27 <parcs> Saizan: that's a lot of instances of have in scope…
14:54:47 <Peaker> int80_h: git has a very simple model, wrapped with a very complex CLI
14:54:54 <ezyang> (note, #git is a very friendly chan!)
14:56:57 <shachaf> parcs: Hah, ghci uses different type variable names for "fmap (fmap fmap fmap)" and "(fmap) (fmap fmap fmap)"
14:57:55 <parcs> hmm, not for me
14:58:16 <hvr> neither for me...
14:59:19 <shachaf> Really? What version of ghci?
14:59:36 <hvr> 7.0.3
14:59:37 <aristid> i see the same effect as shachaf
14:59:40 <aristid> 6.12
15:00:19 <ezyang> :-( None of the distro packaged Haskell packages have dynamic libraries.
15:01:02 <saiko-chriskun> arch?
15:01:14 <hpc> ubuntu just has -dev, -prof, and -doc
15:01:24 <shachaf> aristid: 6.12 here too.
15:01:40 <saiko-chriskun> ezyang: arch has tons of packaged haskell libraries
15:01:49 <ezyang> No, it's Ubuntu.
15:02:25 <saiko-chriskun> you said no distros have packaged libraries :P. I was just saying arch does.
15:02:58 <ezyang> Fair.
15:04:03 <parcs> arch only has 28 binary haskell packages, most of them from the HP... the ones in the AUR don't qualify as packages because you have to build them through cabal as one would normally do
15:04:52 <Saizan> parcs: nah, just one, instance Functor ((->) r) where fmap = (.)
15:06:33 <shachaf> Saizan: Even with that instance ghci prints a different type.
15:06:54 <parcs> heh, i assumed that instance was defined in base
15:06:56 <parcs> damn lambdabot
15:07:03 <shachaf> @ty fmap fmap fmap fmap fmap fmap fmap
15:07:04 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
15:07:11 <shachaf> Wait, no it doesn't.
15:09:01 <hydo> Am i missing something or is there no way to append a Value to a Value in aeson?
15:09:15 <hydo> surely I'm missing something critical.
15:10:11 <hydo> I guess I should have said 'combine two Values'
15:10:27 <shachaf> hydo: Combine them how?
15:11:53 <ezyang> Mooo. Graphics/UI/Gtk/Signals.chs:104:46:     Module `System.Glib.UTFString' does not export `maybePeekUTFString'
15:12:12 <hpc> i assume any function :: Value -> Value -> Value would work; i don't see any that match that type in the package
15:12:28 <Peaker> hpc: maybe it is a Monoid?
15:12:34 <parcs> okay well 39 consecutive fmaps in ghci is a bad idea no matter how much ram you have
15:13:09 <hydo> shachaf: trying make an example, but if you have two values a and b and what you want is a ++ ["bees" .= b]
15:13:15 <hydo> or something like that.
15:13:30 <hydo> yea, I seached on hayoo as well but didn't find much.
15:13:36 <hpc> parcs: i like how :t outputs lazily :D
15:13:41 <Peaker> parcs: I don't have any problem with that here (:t fmap . fmap ... 39 times)
15:14:03 <hydo> I'll just generate it by hand for now I guess.
15:14:05 <hpc> Peaker: not fmap . fmap, fmap fmap fmap
15:14:24 <shachaf> hydo: I'm not sure what .= means.
15:14:28 <hpc> (which i suppose are the same lol)
15:14:33 <parcs> hpc: yeah, it's quite weird
15:14:46 <hydo> shachaf: ah, this is for aeson, the json parser.
15:14:48 <parcs> the "chunks" end in quite arbitrary places
15:14:49 <shachaf> hydo: But Value corresponds to some JSON value, right? How do you want to combine two of them?
15:14:53 <Peaker> hpc: hmm.. it takes ghci much more work to figure out "fmap" in place of "."
15:15:16 <Peaker> sounds like a bug because it can instantiate the Functor to (->) immediately?
15:15:42 <hpc> :t fmap
15:15:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:15:53 <hpc> :t fmap (Prelude..) fmap
15:15:54 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> f a1) -> a -> f b
15:15:56 <hpc> :t fmap fmap fmap
15:15:57 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:16:07 <hpc> nope, there's an actual difference :D
15:16:15 <hydo> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
15:16:15 <lambdabot> forall a b (f :: * -> *) a1 (f1 :: * -> *). (Functor f1, Functor f) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
15:16:17 <ion> :t fmap Prelude.. fmap
15:16:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:16:23 * hpc retracts earlier wrongness
15:17:16 <ion> Qualified infix operators aren’t the most obvious thing out there. :-)
15:17:27 <parcs> is the function instance of functor defined anywhere in base?
15:17:40 <hpc> Control.Functor.Instances perhaps?
15:17:47 <parcs> no such module
15:17:52 <hpc> er, applicative?
15:17:59 <hpc> @hoogle Applicative Instances
15:18:00 <lambdabot> Did you mean: :: Applicative Instances /count=20
15:18:00 <lambdabot> No results found
15:18:04 <hpc> bah
15:18:09 <ion> Control.Monad.Instances, but i usually just import Applicative which imports that.
15:18:10 <parcs> ...no such module
15:18:33 <parcs> ah
15:18:38 <ion> (Control.Applicative)
15:19:13 <parcs> anyway, does one have any idea how many consecutive fmaps it requires to make a function that lifts a function 5 functor levels?
15:19:29 <parcs> it takes 1, 3, 7, 21 for 1..4 respectively
15:20:38 <flazz> in a Repa.Array, how can i update an individual element?
15:23:18 <c_wraith> flazz: write a transform that leaves every other element unchanged
15:25:10 <hydo> Ah, "Couldn't match expected type 'ByteString' with expected type 'ByteString'".  The most ironic of the recurring errors.
15:25:55 <dons> lazy vs strict, probably
15:26:03 <dons> look at the module/package names in the error
15:26:04 <Saizan> surely
15:27:02 <hydo> yea, definitely.  It just makes me feel a little weird inside to have to wedge in something to convert them in an otherwise (well, at least to me) beautiful piece of code.
15:27:24 <Peaker> Yeah, lack of polymorphism across string types (at the very least lazy/strict) is annoying
15:28:22 <hydo> Is that the price we pay for our strictness or is that one of those problems that no one has gotten around to solving yet?  I suspect the first.
15:29:11 <hpc> the price of mixing strict and lazy, i would think
15:29:23 <hpc> you wouldn't have to convert between the two otherwise
15:30:28 <ezyang> OOC, why are you mixing lazy and strict?
15:30:54 <c_wraith> the most common reason is that you're using multiple different APIs, that produce/expect unlike things
15:31:04 <hydo> I'm not... i'm trying to use aeson with snap... aeson = lazy bs, snap = not
15:31:51 <hydo> I wouldn't subject myself to that by choice, I assure you.
15:33:13 <jaspervdj> hydo: Just use writeLBS from Snap.Types?
15:33:59 <c_wraith> that only works if the only interaction is writing Aeson results as the response body.
15:34:39 <hydo> jaspervdj: holy hell, I didn't know that was there.  Again, skimming the docs bites me in the ass.
15:34:46 <jaspervdj> In case you want to go LBS -> BS, you want something like:
15:34:47 <hydo> jaspervdj: thank you!
15:34:52 <jaspervdj> fromChunks . return
15:34:58 <jaspervdj> It's O(1)
15:35:01 <jaspervdj> hydo: No problem
15:35:17 <c_wraith> oh.  you mean you really did just want writeLBS?  I guess I should have mentioned it :)
15:40:04 <Saizan> fromChunks . return is BS -> LBS, there's no O(1) LBS -> BS in fact
15:43:06 <los> How do I convert from a ByteString to a regular String?
15:44:15 <ivan> http://haskell.org/hoogle/?hoogle=ByteString+-%3E+String
15:44:20 <mauke> well, what encoding is the string in?
15:44:31 <shachaf> los: Once something is in a Byte, you can't escape the Byte. You can only >>= it to bigger Byte computations.
15:44:48 <mauke> pfft
15:45:11 * mauke proceeds to define Byte Char, Byte Int, and Byte (a -> b)
15:45:22 <los> It's a UTF8
15:45:37 <shachaf> los: Why are you using ByteString for UTF8?
15:45:46 <mauke> because UTF-8 is bytes
15:46:10 <los> That's what the Snap getParam call returns, shachaf
15:46:38 <mauke> Data.Encoding can do this
15:46:39 <ivan> Data.ByteString.Lazy.UTF8.toString?
15:46:44 <mauke> or maybe that
15:47:17 <shachaf> @slap String
15:47:17 * lambdabot clobbers String with an untyped language
15:47:22 <shachaf> Hmph.
15:47:39 <Peaker> Does Text still use utf16?  utf16 probably ought to be abolished
15:47:53 <aristid> shachaf: heh, that @slap text was somehow fitting
15:48:07 <copumpkin> Peaker: it won't after this summer of code
15:48:32 * shachaf snap
15:48:42 * shachaf snaps fingers.
15:48:48 <shachaf> @slap etabot
15:48:48 * lambdabot karate-chops etabot into two equally sized halves
15:48:54 <Peaker> copumpkin: so it will essentially boil down to a newtype around Lazy ByteString of UTF8?
15:49:06 <Peaker> copumpkin: so there would hopefully be no reason to use ByteString for text ever again?
15:49:06 <copumpkin> why lazy?
15:49:19 <los> Looks like Data.Text.Encoding what was I wanted
15:49:33 <Peaker> copumpkin: There are probably good use cases for both lazy and strict
15:49:41 <copumpkin> it already has both
15:50:17 <Peaker> copumpkin: so there will be no performance reason to prefer BS for text anymore?
15:51:33 <jaspervdj> Peaker: I'm porting text to UTF-8
15:52:15 <jaspervdj> Text will have some additional overhead over LBS if we still validate the received UTF-8
15:53:08 <Peaker> jaspervdj: why pre-validate unless asked to?
15:53:27 <jaspervdj> Also, Text uses a ByteArray# internally where ByteString uses a ForeignPtr, we don't know 100% sure what the best options is though
15:53:56 <jaspervdj> Peaker: You don't really need validation on construction, but you will need validation when you, e.g., map over the Char's
15:55:04 <jaspervdj> Using the ForeignPtr would make text-icu a lot faster though, it's a hard call
15:56:00 <waern> I'm trying to use cabal test --test-options to pass multiple options without success
15:56:26 <waern> I'm doing something like > cabal test --test-options='x y z'
15:59:27 <Peaker> hmm.. when using enumerators with sockets -- it seems to want to know the chunk size ahead of time -- but what if I know how much to read only after reading some?
16:00:22 <Peaker> ideally, it could just yield the chunks as those arrive from below, in whatever size
16:14:14 <jaspervdj> Peaker: Yes, that's probably a good idea. You want the chunks to be "big enough", though.
16:14:18 <jaspervdj> I'm off to bed, bye
16:16:00 <Peaker> if it actually requires the chunks to be that size -- it may cause a deadlock
16:22:47 <mreh> sepBy isn't great if your separator can be used in many contexts
16:25:05 <hpc> lex is usually a good place to start from
16:25:44 <Peaker> IterIO seems to group way too many kinds of iterators/enumerators in the same module (Data.IterIO.ListLike??)
16:26:35 <Peaker> I'm getting funny missing instance errors for its ListLikeIO class.. perhaps because of a value too polymorphic, but I specified the full type. let's see if the network-enumerator package fares nicer
16:30:24 <mreh> command line arguments are not an easy grammar to parse
16:30:47 <noses> Peaker: you specified types that have an instance?
16:31:04 <Peaker> noses: strict bytestring and IO
16:32:46 <noses> ListLikeIO ByteString Word8?
16:32:49 <noses> ===>
16:34:44 <noses> well you don't need to specify the Word8 thanks to the fundep
16:37:34 <Peaker> noses: I'm using (enumFile "/etc/passwd" |$ lineI) :: IO String  similarly to the example on http://hackage.haskell.org/packages/archive/iterIO/0.1/doc/html/Data-IterIO.html
16:37:54 <Peaker> noses: the headFile example
16:38:36 <Peaker> noses: in fact, copying that example verbatim into ghci does not type check
16:41:04 <dons> tommd: around?
16:45:47 <Peaker> how do I hook up an Enumerator to an Iteratee in the enumerators package?
16:46:10 <Peaker> The http://www.yesodweb.com/blog/enumerators-tutorial-part-2  has their own whipped up applyEnumerator function.. this seems like it should be in Data.Enumerator?
16:46:46 <Peaker> Exposing the Step .. -> Iteratee .. structure for all use purposes seems awfully low-level
16:47:24 <Peaker> oh, it's $$
16:47:34 <Peaker> (sometimes they go by the type synonym, sometimes by the (Step .. -> ..) function
16:52:13 <ddarius> Liam Neeson in a kilt!
17:04:21 <Peaker> I wish the various iteratee stuff used names that made it clear what the data flow is
17:09:20 <Peaker> http://hpaste.org/paste/46864/echo_server_with_enumerator_pa#p46865 <-- imports take half the space!
17:09:43 <Peaker> Control.Applicative and Control.Monad probably belong in Prelude
17:13:19 <tg_> really?
17:14:04 <tg_> I would think that they shouldn't, since they have nontrivial laws that need satisfying
17:14:20 <tg_> whereas Functors only one...
17:14:21 <ddarius> tg_: Monad is in the Prelude.
17:14:22 <tg_> functor is in prelude, right?
17:14:33 <ddarius> Control.Monad is not just the Monad class.
17:14:35 <tg_> doesn't control.monad contain all kinds of stuff
17:14:44 <tg_> yeah, things which need to satisfy the monad laws
17:14:51 <hpc> tg_: you still get some of the lifts i think
17:15:09 * hpc is actually not sure because he imports those things on reflex
17:15:14 <tg_> hehe
17:15:27 <tg_> every time I type the letter m, Control.Monad is imported, just in case
17:15:50 <ddarius> I don't see how the laws that need satisfying come into play at all as to where library functions should be.
17:16:00 <hpc> huh, not even join
17:16:01 <tg_> everyone does seem to have an opinion about what should (and shouldn't) be in the Prelude
17:16:15 <tg_> ddarius: because if you want to use them, you should know what you're doing?
17:16:17 <ddarius> Just get rid of the Prelude.  Problem solved.
17:16:22 <tg_> ddarius: ding!
17:16:32 <tg_> then the prompt could be Civic>
17:16:38 <tg_> or Focus>
17:16:55 <ddarius> tg_: Monads are much simpler than most of the stuff in a standard library.
17:17:10 <tg_> ddarius: in terms of human understanding or compiler simplicity?
17:17:15 <hpc> ddarius: not if the tutorials are to be believed
17:17:30 <ddarius> tg_: Both.
17:18:21 <Peaker> ddarius: It is annoying to have to have a pageful of imports in 2 pages of code :)
17:18:31 <tg_> Peaker: I was just thinking that
17:18:39 <tg_> Peaker: looking at Preulde->Synopsis
17:18:52 <hpc> the fix i took for my website was 'import Lib.All'
17:18:58 <ddarius> Peaker: Just inline those modules.  Problem solved.
17:19:08 <tg_> ddarius: *which* problem solved
17:19:28 <ddarius> tg_: The proportion of lines of imports to lines of code.
17:19:31 <hpc> tg_: all of them!
17:19:36 <hpc> tg_: you don't even need a linker
17:19:57 <tg_> ok, so in Prelude, the most complicated stuff is...
17:20:05 <tg_> everything in Functor
17:20:09 <hpc> tg_: the documentation :P
17:20:21 <tg_> and the functions in RealFrac / RealFloat / Floating
17:20:43 <noses> readFile is quite complicated
17:20:53 <tg_> and people in haskell are just *obsessed* with Maybe
17:21:00 <saiko-chriskun> can anyone help with parsec? I'm pretty new with it and can't get past unexpected end of input :P
17:21:21 <Peaker> tg_: Just, not just
17:21:22 <shachaf> saiko-chriskun: That's kind of what "end of input" means.
17:21:28 <tg_> Peaker: cute
17:21:29 <shachaf> You can't get past it.
17:21:33 <saiko-chriskun> shachaf: >_>
17:21:35 <saiko-chriskun> I know that
17:21:41 <Peaker> tg_: Maybe is pretty damn useful :-)
17:22:02 <tg_> Peaker: yeah, but one day you'll have to get a divorce and the kids... it'll be a mess
17:22:22 <saiko-chriskun> I mean it errors out with 'unexpected end of input'. I need to tell it to finish or w/e
17:22:28 <tg_> yeah, the most complicated stuff in Prelude are the IO functions
17:22:46 <tg_> which are implemented using monads, but evidently nobody is sure if IO is even a Monad
17:22:59 <hpc> um, yes they are?
17:23:03 <hpc> it follows the laws
17:23:06 <shachaf> saiko-chriskun: I recommend w/e-ing.
17:23:10 <jmcarthur> hpc: prove it :P
17:23:15 <tg_> hpc: it was discussed earlier today
17:23:15 <saiko-chriskun> shachaf: huh?
17:23:20 <tg_> hpc: evidently that fact cannot be proven
17:23:26 <tg_> s/cannot/has not/
17:23:26 <jmcarthur> well
17:23:30 <jmcarthur> yes that
17:23:54 <tg_> but if you drop out IO from the Prelude, then you wouldn't need Monads at all
17:24:14 <tg_> so it seems
17:24:15 <noses> @src IO
17:24:15 <lambdabot> Source not found. There are some things that I just don't know.
17:24:25 <Saizan> saiko-chriskun: we can't help you if you don't give more details about your parser and the inputs you want to handle
17:24:26 <tg_> :t IO
17:24:27 <lambdabot> Not in scope: data constructor `IO'
17:24:32 <tg_> :t FilePath
17:24:33 <lambdabot> Not in scope: data constructor `FilePath'
17:24:37 <tg_> screw you lambdabot
17:24:52 <tg_> there are a *lot* of things under Functor, though
17:24:54 <saiko-chriskun> Saizan: it's a JSON parser- http://sprunge.us/HYDD
17:25:12 <hpc> IO = State RealWorld#
17:25:14 <tg_> it's like someone really thought this prelude thing through
17:25:15 <noses> tg_: you don't accept a proof that GHCs haskell definition of IO follows the laws (since it's just State RealWorld)?
17:25:41 <tg_> noses: I don't know anything about it, but I trust conal and jmcarthur and applicative
17:25:53 <tg_> who say it hasn't been proven
17:26:03 <tg_> and no, I don't accept documentation as proof
17:26:05 <jmcarthur> i never claimed that
17:26:07 <conal> it's a popular myth that IO = State RealWorld
17:26:10 <Saizan> saiko-chriskun: input giving the error?
17:26:22 <conal> a popular fiction.
17:26:25 <tg_> jmcarthur: s/jmcarthur//
17:26:28 <jmcarthur> heh
17:26:32 <hpc> the RealWorld# is unboxed, is what complicates things?
17:26:36 * ddarius would just say "a fiction."
17:26:49 <hpc> or is the tuple unboxed too?
17:26:53 <ddarius> hpc: It being unlifted probably simplifies things actually.
17:26:56 <jmcarthur> i've not seen any proof, but i wouldn't say that nobody has at least attempted to sketch one
17:27:04 <ddarius> (From a semantic view point.)
17:27:07 <tg_> jmcarthur: I don't even understand how one could prove it
17:27:13 <jmcarthur> tg_: exactly!
17:27:15 <tg_> but I don't understand monads
17:27:20 <noses> http://hackage.haskell.org/packages/archive/base/3.0.3.1/doc/html/GHC-IOBase.html#t%3AIO <-- isn't that definition a state monad?
17:27:22 <jmcarthur> i don't understand IO
17:27:26 <saiko-chriskun> Saizan: when you run it it says 'unexpected end of input. expecting "\""'
17:27:28 <tg_> I would think that you could prove it for purely numeric data
17:27:39 <tg_> like if you restrited data to square matrices
17:27:40 <tg_> or something
17:27:43 <jmcarthur> noses: that's an implementation hack
17:27:47 <conal> jmcarthur: no one understands IO
17:27:58 <jmcarthur> conal: i was implying that
17:28:01 <ddarius> tg_: What does that have to do with anything?
17:28:03 <jmcarthur> *hinting at it
17:28:04 <Saizan> saiko-chriskun: with every input? i don't have this "api" file
17:28:05 <tg_> conal: not even Lord SPJ?
17:28:30 <conal> tg_: not even SPJ.
17:28:31 <ddarius> saiko-chriskun: You have to explicitly match the end of input.
17:28:34 <tg_> ddarius: Not sure. I was guessing that you might have a shot at proving IO if you set up rules about homogeniety of what could be done with IO
17:28:43 <saiko-chriskun> ddarius: yeah, I know it's simple
17:28:48 <saiko-chriskun> just not sure how to do that lol
17:28:59 <saiko-chriskun> I'm pretty new to haskell/parsec
17:28:59 <conal> tg_: if you read SPJ's "the awkward squad", you'll see that he makes a bit of an attempt to give a denotation for IO and then gives up.
17:29:07 <tg_> conal: noted
17:29:19 <saiko-chriskun> ddarius: most of that file was mashing different things on the web together
17:29:22 <ddarius> saiko-chriskun: I recommend perusing the documentation.  The answer will reveal itself.
17:29:36 <tg_> conal: how deep does this rabbit hole go? Does this problem start all the way down at Turing machines?
17:29:52 <shachaf> ddarius: Courageous and innovative.
17:30:07 <conal> i've explained why i think there will never be a denotation for IO at http://conal.net/blog/posts/notions-of-purity-in-haskell/#comment-22829
17:30:19 <conal> IO as toxic avenger
17:30:21 <tg_> conal: it always takes cojones to use the word 'never'
17:31:06 <conal> tg_: and i very rarely use that word. in this case, IO by design is not understood.
17:31:32 <conal> SPJ said something like "whenever we don't understand something, we toss it into IO".
17:31:41 <tg_> conal: the structure of your blog is flawed. There is *way* too much content in the comments, which ought to be elevated to normal-font-sizes
17:31:48 <tg_> conal: not that it's a big deal, but...
17:32:05 <tg_> conal: yeah, I see that.
17:32:39 <conal> tg_: i could up the font sizes in the comment section. hadn't thought to. thx.
17:33:26 <hpc> yeah, the font is intolerably small, especially with my manually shrunk default font size
17:34:06 <jmcarthur> i usually control plus a couple times on conal's blog anyway
17:34:07 <conal> that post got a lot more comments than most of mine. i guess it struck a nerve or two.
17:34:25 <tg_> conal: I had the desire to ask you a question the other day... does your advocacy of denotational semantics apply to stricter semantics (algebraic, axiomatic, and action semantics)?
17:34:27 * conal control-pluses on just about everything on the web.
17:34:28 <ddarius> Perhaps it struck a chord of nerves.
17:34:44 <conal> ddarius: :)
17:34:54 <tg_> rather, do you think those things have as widespread applicability or one should consider using those systems when possible?
17:35:08 <tg_> I didn't even know they existed until I went through some U of Iowa slides about them
17:35:43 <tg_> it does seem like denotational semantics are the only ones that are really related to linguistic thought
17:36:08 <conal> tg_: i gather that preferences of semantics styles are pretty personal. for instance, operational semantics always leave me unsatisfied. while many others pick operational first.
17:36:23 <tg_> conal: purity is a word laden with extra meaning
17:36:52 <hpc> conal: also, it is worth considering the question "is IO RT if we ignore concurrency"
17:36:54 <tg_> conal: Intuitively, I feel like operational semantics are akin to saying - the machine does it this way, so I have to think of it that way
17:37:08 <tg_> which is totally absurd
17:37:12 <hpc> seeing as how your comment appears to have become hung up on that point
17:37:26 <tg_> hpc: RT = real-time?
17:37:34 <hpc> referentially transparent
17:37:37 <tg_> hpc:  ok
17:37:49 <conal> tg_: yeah. people who think in terms of mechanics may prefer operational semantics. i'm less interested in how machines do things (even abstract machines) than what things *are*.
17:37:57 <ddarius> tg_: Operational semantics are almost never given in terms of anything resembling real machines.  Rewriting via beta reduction is an operational semantics.
17:38:01 <Saizan> btw, you don't need a denotation for IO to use RT effectively with IO typed expressions, just use intensional equality
17:38:09 <conal> once i know what something *is*, only then am i interested in how to implement it.
17:38:32 <tg_> ddarius: well, I mean to say that it reminds me carefully, mechanically following how a machine goes from one instruction to another
17:38:46 <tg_> ddarius: like I picture the debuggers of the Bomba machines in WWII
17:38:56 <conal> hpc: i don't know how important non-concurrent imperative programming is any more.
17:39:21 <tg_> ddarius: that picture couldn't seem more unlike the way the human brain works, to me - and certainly not how mine works
17:39:41 <conal> hpc: and the fiction of IO = State World fails even without concurrency, if one allows interaction with "the world" (users, file systems etc)
17:40:13 <tg_> conal: wrap everything in fourier transforms, problem amplified.
17:40:21 <tg_> ok, be back later. thanks all.
17:40:22 <jmcarthur> o_O
17:40:51 <tg_> jmcarthur: at least you'll know that all changes to the world are local, to somewhere, at some time
17:40:57 <tg_> even if you can't figure out where, and when
17:41:05 <Saizan> i.e. if there's an expression which both evaluate to then you're free to substitute one for the other
17:43:33 <jmcarthur> conal: so i've been thinking about improving values over the last couple days, which naturally led me to unobservable mutation since improving values can get a sort of efficiency boost by using mutation to update the current approximation etc. it occurred to me that improving values are kind of like generalized thunks. thunks are either done or not done, but improving values can have intermediate
17:43:35 <jmcarthur> states. just thought that was an interesting viewpoint
17:44:40 <conal> jmcarthur: yes. that's how i think about them as well. thunk -> value (as in conventional lazy eval) is just one special case of a more general notion.
17:44:53 <jmcarthur> yeah exactly as i was thinking
17:45:12 <conal> jmcarthur: of "semantically benign mutation" or "unobservable mutation"
17:45:43 <conal> jmcarthur: and i bet there many more useful examples waiting to be discovered.
17:45:58 <jmcarthur> i see unobservable mutation as an even more general notion
17:46:17 <jmcarthur> err you just said that
17:46:55 <jmcarthur> what i found interesting about my lightbulb moment wasn't that thunks and improving values are both special cases of unobservable mutation but that improving values are kind of a special case of thunks
17:47:00 <jmcarthur> err
17:47:13 <jmcarthur> thunk are a special case of improving values*
17:47:56 <conal> jmcarthur: another related example is natural numbers.
17:48:18 <jmcarthur> i see lazy naturals as a special case of improving values
17:48:23 <conal> jmcarthur: as in "what about the natural numbers?" by colin runciman
17:48:27 <ddarius> conal: Oz's dataflow variables.
17:48:47 <jmcarthur> each Succ constructor increases the lower bound
17:48:57 <jmcarthur> they could be summarized in a mutable variable
17:49:06 <noses> Peaker: the iterIO library examples work if you have a    deriving instance ChunkData CharStringLazy
17:49:09 <conal> jmcarthur: yeah. nice connection.
17:49:11 <jmcarthur> which is updated as each Succ is encountered
17:49:22 <conal> ddarius: are they like prolog's logical variables?
17:49:41 <ddarius> Yes albeit more restricted.
17:49:49 <conal> ah
17:49:55 <ddarius> (And with a more explicit concurrency semantics.)
17:50:00 <ddarius> @google "declarative concurrency"
17:50:02 <lambdabot> http://c2.com/cgi/wiki?DeclarativeConcurrency
17:50:02 <lambdabot> Title: Declarative Concurrency
17:50:12 * ddarius didn't know what that would produce.
17:51:22 <dylukes> It occurred to me,
17:51:28 <dylukes> you could use coroutines to do parallel parsing
17:51:30 <dylukes> that might be fun
17:51:52 <dylukes> the other thing I thought of is partitioning the file, and creating partial parses,
17:52:04 <dylukes> which could be monoidal :)
17:53:17 <ddarius> dylukes: Keep this up and you'll be edwardk someday.
17:53:26 <dylukes> Oh god that sounds terrible.
17:53:37 <Saizan> poor edwardk
17:53:48 <dylukes> ddarius: What exactly do you mean by that.
17:54:21 <Saizan> http://comonad.com/reader/2009/iteratees-take-2/ <- dylukes
17:54:28 <dylukes> .__.
17:54:43 <dylukes> Dunno about that but, my idea is that, if you say, broke an XML file into a few chunks, then parsed each one...
17:54:46 <dylukes> like, say 8 chunks
17:55:01 <dylukes> each "partial" would be a vector of tokens
17:55:17 <dylukes> then for each one, you can recursively check if both "ends" of a tag exist,
17:55:22 <dylukes> and if they do you can built it into a tree
17:55:35 <dylukes> then once a partial has been  "reduced" as much as possible,
17:55:46 <dylukes> mappend it to its neighbor partial and do it again
17:56:11 <dylukes> Any obvious flaws there? Seems like it'd work to me ._.
17:57:04 <dylukes> I think I'll try this. For JSON maybe.
17:57:21 <dylukes> Since the parsing diagrams are readily available :3.
17:57:49 <dylukes> Alright. First I need to stop distracting myself and *write this essay*
17:58:05 <dylukes> Then I'll obsess romantically for 15 minutes over how head-over-heels in love I am,
17:58:10 <dylukes> and then its Haskell/Agda time till 2AM!
17:58:49 <parcs> @oeis 1 3 8 16
17:58:51 <lambdabot>  Binomial(n+p,n) mod n where p=10.
17:58:51 <lambdabot>  [0,0,1,1,3,4,2,6,2,6,1,2,1,10,5,7,1,12,1,15,18,12,1,12,21,14,4,12,1,28,1,29,...
18:06:19 <rostayob> @pl \f -> f x
18:06:19 <lambdabot> ($ x)
18:07:27 <shachaf> @pl flip id x
18:07:27 <lambdabot> ($ x)
18:08:01 <ion> @pl (`id` x)
18:08:01 <lambdabot> ($ x)
18:08:47 <rostayob> cool
18:13:07 <elliotstern> I was working on some code on a windows machine, earlier, and I had a strange problem:  I was running an .exe in a terminal and my calls to hGetChar and hGetLine never returned, even after I typed a line of text and hit enter.  I tried it with the buffering mode for stdin set to both NoBuffering and LineBuffering, and in both cases, the buffer didn't flush until I hit ctrl-c
18:13:15 <elliotstern> Is this a known bug?
18:14:55 <ion> Dunno, but if you’re using the standard Windows™ terminal i’d suggest trying a better one such as mintty. http://code.google.com/p/mintty/
18:18:07 <elliotstern> Well, when I give the exe to someone else, I'd like for them to be able to just run it without having to install a half dozen utilities
18:18:48 <elliotstern> And yeah, it's a standard windows terminal, but if possible I'd not like to rely on a special terminal.
18:19:04 <ddarius> Why are you writing interactive terminal apps on Windows?
18:19:54 <dolio> Maybe he gets paid, like I do.
18:20:08 <ddarius> dolio: To write interactive terminal apps on Windows?
18:20:10 <shachaf> dolio: You get paid for writing interactive terminal apps on Windows?
18:20:12 <elliotstern> It's not really very interactive.  Basically, it starts up a few services, and waits for the user to type "quit".  I wanted to do it in a compiled language so distribution was easier
18:20:14 <dolio> ddarius: Yes.
18:20:45 <dolio> ddarius: Our language has a REPL, and we run Windows.
18:20:56 <elliotstern> And it's easier to do that sort of scripty thing in haskell than C# or c++
18:21:59 <elliotstern> And that way, you don't have to get someone to jump through extra hoops like installing python or powershell (since it isn't installed by default on win XP), they just run the exe.
18:23:18 * ddarius wishes xmonad worked on Windows (outside of X.)
18:32:21 <ivan> something that starts up services should be a bat file, no?
18:33:52 <jeffz_> ivan: your haskell program can start services without a bat file
18:34:23 <dmwit> preflex: seen aavogt
18:34:24 <preflex>  aavogt was last seen on #haskell-blah 2 days, 1 hour, 2 minutes and 27 seconds ago, saying: noun-verbal communication
18:34:37 <jeffz_> ivan: if you mean windows services, typically a program would install itself as a service and set it to start automatically if that's desired, otherwise it can start it using win32, or hackishly issue a shell command `net start foo`
18:35:18 <dmwit> ?ask aavogt Have you tried building XMonad.Config.Alt with GHC7? I got a little ways in (increasing the context stack to 81 seemed to clear up the functional dependency errors), but don't know HList well enough to understand the errors it's giving me.
18:35:19 <lambdabot> Consider it noted.
18:35:38 <noses> dmwit: ok
18:35:51 <dmwit> noses: eh?
18:36:03 <dmwit> oh hi!
18:36:15 <dmwit> haha
18:36:18 <ivan> jeffz_: I mean re: elliotstern, sorry for the confusion
18:36:39 <jeffz_> oh, I missed that.
18:36:39 <ivan> maybe I should go back to having parts/joins on
18:40:05 <elliott> Does anyone use the MaybeT package on Hackage or should I just lift the code from the wiki?
18:42:01 <mkserra> well then
18:42:02 <davidL> iki?
18:42:02 <davidL> 01:53 <mkserra> well then
18:42:09 <davidL> oops, mistake
18:42:27 <mkserra> anybody ever have problems with the sdl bindings?
18:42:51 <mkserra> i'm seeing this odd behavior
18:43:00 <mkserra> even with the lazyfoo tutorials
18:43:35 <mkserra> For example tutorial 20, the animation test, will run fine briefly but then the window stops updating
18:44:14 <mkserra> refresh the window (by for example moving it), and it will update to the current state. you can see the program had continued to run
18:44:50 <mkserra> after thus refreshing, the window will again update normally for a while before the problem repeats
18:45:06 <mkserra> and it's pretty arbitrary when it might occur
18:45:33 <mkserra> anyone seen this behavior before?
18:45:41 <dolio> ddarius: Do you remember the name of the Haskell interpreter that incorporated a lot of visual stuff, and was similar to an interactive worksheet.
18:45:44 <dolio> ?
18:46:19 <dolio> It would display a picture of a lazy list if you asked it to evaluate it, and would evaluate more of it as you moved to the right.
18:47:35 <objorn> imple x y z = x * (y+z)
18:47:36 <objorn> imple x y z = x * (y+z)
18:47:41 <objorn> Whoops, sorry.
18:49:11 <objorn> In the ghci interpreter, I input simple x y z = x * (y+z) and then I'm told <interactive>:1:13: parse error on input `='
18:49:22 <objorn> What is wrong?
18:49:34 <dibblego> let x y z = x * (y+z)
18:49:39 <dibblego> put the let keyword before it
18:50:19 <objorn> Thank you dibblego
18:50:38 <dibblego> alternatively put it in a source file and :load thatfile.hs
18:50:42 <dibblego> (without the let keyword)
18:51:23 <aavogt> dmwit: it's quite an odd bug: ex1 and ex2 by themselves seem to work fine
18:51:23 <lambdabot> aavogt: You have 1 new message. '/msg lambdabot @messages' to read it.
18:52:13 <elliott> I have a problem (lots of nested "case" blocks in some monadic code that always either result in one failure mode, or have the rest of the block in one of the cases) that is solved excellently with MaybeT. Unfortunately, there's one snag: I need an awful lot of "lift"s to use my regular monadic actions in the block, and it's kind of ugly. Other than parameterising all of my monad actions on a typeclass, does anyone have any suggestions?
18:53:17 <dolio> elliott: I think you ruled out the answer. :)
18:54:05 <dmwit> aavogt: huh, weird
18:54:31 <elliott> dolio: I know it's probably for the best... but, ugh, it's just so ugly :)
18:54:51 <elliott> dolio: I mean, I literally only ever use the monad (stack) directly, or in MaybeT.
18:55:01 <elliott> So it seems like major overkill just to kill some right-leaning indentation.
18:55:03 <elliott> But I dunno...
18:55:47 <aavogt> elliott: sometimes you can save some lift by writing something like    lift $ do { sequence; of original; monad }
18:56:06 <kamatsu> :t concat
18:56:07 <lambdabot> forall a. [[a]] -> [a]
18:56:28 <elliott> aavogt: Unfortunately, in this case it's pretty much constant switching between "action in my monad" and "a possibly-failing computation".
18:57:46 <elliotstern> What precisely does fmap do for the IO monad?  I mean, yes, obviously, it turns A -> B into  IO A -> IO B, but does it have any additional side effects?
18:58:08 <aavogt> there might still be some improvements if you could paste a bit of it
18:58:32 <shachaf> elliotstern: It satisfies the Functor laws.
18:58:54 <elliott> aavogt: As far as I can tell, the problem is solved perfectly by parameterising everything on a typeclass... I'm just lazy :)
19:03:07 <int80_h> http://hpaste.org/46869/question_about_yesodexamples
19:03:29 <ddarius> dolio: Vital (and there was another one as well.)
19:03:51 <dolio> Yeah, that's the one I'm thinking of.
19:04:35 <ddarius> elliotstern: No, if it had (other) side-effects it wouldn't satisfy the functor laws.
19:05:04 <ion> The ?blahblah looks like something based on the file’s timestamp to force clients to reload it on changes.
19:06:09 <elliott> I wonder why that is used (as opposed to ETags or similar which is what they are designed for).
19:06:29 <tg_> conal: in case it wasn't obvious from my earlier comments, you probably have to use the P-V numbers the coefficients for polynomials in a division algebra-type construction
19:07:05 <conal> tg_: ah
19:07:30 <ion> Perhaps as a workaround for broken clients/proxies.
19:07:37 <ion> I’m just speculating.
19:07:50 <tg_> so you can use them to divide out some very large (but not exactly infinite) area, and make guarantees about how far away one cell is from another
19:08:14 <int80_h> SyntaxNinja: Do you use Yesod?
19:08:27 <tg_> and if you are addressing the area with regular integers, then you are always within +/- 9 of a divisior of a P-V number, no matter how large the integer is
19:09:08 <ion> Oh, i know. ETags mean the clients still need to do a HTTP request for each file. With the ?blah style you can say “cache these forever” for the static files and they’re only reloaded when the HTML says they’ve changed by changing the query parameter.
19:09:46 <aavogt> dolio: would you have an idea why ex1 and ex2 cannot both be uncommented in http://code.haskell.org/xmonad-extras/XMonad/Config/Alt/Sample.hs ?
19:10:03 <aavogt> dolio: it used to work with ghc-6.12.4
19:10:31 <tg_> conal: and by "in case it wasn't obvious" I mean "I failed to mention, and of course it's not obvious"
19:10:39 <tg_> ;|
19:12:07 <dolio> aavogt: I've never used xmonad.
19:13:28 <dolio> What does it mean that they can't both be uncommented?
19:13:35 <copumpkin> preflex: seen jfredett
19:13:35 <preflex>  jfredett was last seen on #haskell-blah 1 year, 71 days, 17 hours, 59 minutes and 50 seconds ago, saying: and with that, I bid Adeiu to you, fair Haskellians, I go now to sleep.
19:13:49 <dolio> xmonad complains, or there is some kind of compile error?
19:14:09 <aavogt> dolio: it's a compile error
19:15:07 <tg_> conal: also, by the way, in your garbage-collecting-semantics-of-frp post... it's (surprisingly) not true in terms of physics that responding to future input is a violation of causality
19:15:56 <tg_> tg_: it *is* true that arbitrary access to future information violates causality, but it's not true in the weaker sense
19:16:21 <aavogt> http://hpaste.org/46871/compile_error
19:16:36 <amsl> What is the difference between a type constructor and a data constructor?
19:16:50 <danharaj> amsl: What is the difference between a type and data?
19:17:01 <dolio> Wow.
19:17:05 <rostayob> ok, very strange thing
19:17:06 <amsl> Type describes the data.
19:17:10 <rostayob> if I use applicative in my parser
19:17:12 <rostayob> it's slower.
19:17:14 <rostayob> like
19:17:43 <rostayob> do {foo <- takeBytes 4; takeBytes 4} is faster then takeBytes 4 <* takeBytes 4
19:17:45 <dolio> I wonder if someone is doing something evil with fundeps.
19:17:45 <danharaj> amsl: and what is data?
19:17:53 <elliott> Hmm, there is no way to make a "typeclass alias" that is just a combination of two constraints, right?
19:17:54 <dolio> Something that shouldn't have worked, but did.
19:18:12 <dolio> You used to be able to have a 'class C a b | a -> b' ...
19:18:12 <elliott> It turns out that my MonadBlah class would be completely identical to just a combination of (MonadState BlahState m) and (MonadIO m).
19:18:12 <amsl> danharaj: Recorded information.
19:18:13 <tg_> conal: another way to look at it, intuitively, is that an event has to travel up the slope of an inverse gaussian function to access arbitrary far away events in the [past, future]
19:18:30 <dolio> And if you wrote 'instance C Int a' it wouldn't complain.
19:18:30 <tg_> conal: if that's intuitive
19:18:38 <dolio> I don't remember how long ago that was, though.
19:18:41 <aavogt> dolio: that's on the right track I think
19:18:57 <aavogt> at least that some type-level things are involved
19:19:01 <Eduard_Munteanu> amsl: data Maybe a = Nothing | Just a
19:19:01 <tg_> conal: though I don't have any clue as to what that kind of thing would look like in haskell type language...
19:19:02 <danharaj> amsl: ok. So a type constructor takes some types and gives you a new type, something that describes a different type of data. A data constructor takes some data and gives you some recorded information that is a different form than what the inputs are.
19:19:07 <Eduard_Munteanu> amsl: can you see which is which?
19:19:11 <conal> tg_: i avoided causality, as a lot of people talk about it w.r.t frp, and i don't think of the past as any more accessible than the future
19:19:21 <conal> tg_: so i was hoping to shift the discussion
19:19:29 <rostayob> is it possible that some optimizations are only triggered on monad constructs and not in applicative?
19:19:30 <amsl> Eduard_Munteanu: It is thatt defn. that brought me to that question.
19:19:38 <elliott> conal: "Prediction is very difficult, especially about the future."
19:19:58 <conal> elliott: "memory is a creative act"
19:19:58 <Eduard_Munteanu> amsl: well, ask yourself when you get a type and when you get a value (i.e. data).
19:20:16 <elliott> conal: Oh no, it's a quote war :-)
19:20:22 <dolio> aavogt: So, in that case, it should be an error, because you're declaring multiple instances for C Int t, even though Int determines t.
19:20:23 <aavogt> dolio: but thing is all that hackery works when there's only a single copy of it
19:20:30 <tg_> conal: well, the key idea is that events in the spacetime neighborhood of other events can communicate cheaply, but when you leave the neighborhood, the cost to arbitrary information in the [past, future] is the same: expoentially high
19:20:39 <aavogt> being used I mean
19:20:42 <dolio> aavogt: However, it may be that it only complains when you try to actually use two different such instances.
19:20:53 <conal> elliott: meant to add, not contradict.
19:21:01 <dolio> And perhaps previously it just worked whenever.
19:21:11 <elliott> conal: t'was a joke :)
19:21:43 <Eduard_Munteanu> :t Just
19:21:44 <lambdabot> forall a. a -> Maybe a
19:21:54 <jmcarthur> in my current endeavors into FRP i'm just running with the T->a model and allowing its full expressivity. causality is enforced only by the fact that it won't work when it runs if you violate it :)
19:21:58 <conal> elliott: i like that joke :)
19:22:06 <danharaj> amsl: you have two pieces of data. Nothing, and Just a. Nothing takes no parameters, so it itself is a value. What is the type of Nothing? You can have a 'Nothing' of any type. The data definition says that the type of Nothing is Maybe a.
19:22:08 <elliott> conal: It's the best... uhh... joke.
19:22:13 <jmcarthur> *when you run it
19:22:19 <dolio> aavogt: There's another possibility.
19:22:21 <elliott> The best [001C]joke.
19:22:24 <danharaj> Nothing is the data and (Maybe a) is the type that describes it.
19:22:32 <amsl> danharaj: Thanks, I think I got it now.
19:22:42 <Eduard_Munteanu> :t Nothing
19:22:43 <lambdabot> forall a. Maybe a
19:22:59 <dolio> That big expression contains Tall. Maybe it's expected to actually compute to Tall.
19:23:02 <parcs> @hoogle Int -> Text
19:23:02 <lambdabot> Warning: Unknown type Text
19:23:03 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:23:03 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:23:15 <dolio> aavogt: GHC 7 changed a lot of the machinery.
19:23:15 <tg_> elliott: truthfully, though - when I think about it, I see the act of "reading history" as exactly as difficult as predicting the future - one cannot take for granted the truth of the available information, so you must approach it in the same way you predict the future
19:23:37 <dolio> aavogt: I guess that doesn't make a lot of sense with regard to it working if either one is enabled, but not both.
19:23:42 <conal> elliott: also, hi! how's life?
19:23:55 <elliott> conal: Good. But I think you may be mistaking me for one with another t on the end. :)
19:24:06 <elliott> tg_: Sure. But generally -- at least for recent times -- there are more reliable historical sources than there are prophets :)
19:24:21 <jmcarthur> so many elliot(t(t))s
19:24:43 <jmcarthur> elliott: only memories of the past though, not arbitrary access to the past
19:24:44 <Eduard_Munteanu> Should we put conal and elliott in the same category as djahandarie and geheimdienst? :P
19:24:48 <elliott> elliotttt
19:24:56 <conal> elliott: you're the elliott who interned at tsuru, aren't you?
19:25:02 <elliott> conal: Nope.
19:25:11 <aavogt> dolio: splitting ex1, ex2 into their own modules and importing them together seems to work
19:25:16 <conal> elliott: oops! sry. hi, anyway.
19:25:18 <elliott> Wow, there are three people whose nick starts with "elliott" in this channel.
19:25:24 <tg_> elliott: yes, but from the perspective of a newly born person, that person must do exactly the same due dillgence to construct up the accuracy of the historical record using available information for her/himself - which is exactly what one would do to make a prediction
19:25:25 <elliott> Impressive.
19:25:31 <dolio> aavogt: I'm just making wild guesses, really.
19:25:33 <elliott> tg_: Indeed.
19:25:33 <aavogt> this sort of reminds me how inline TH splices are all type checked as a group
19:25:56 <conal> i'm off. later, all.
19:26:34 <aavogt> where type inference gets held up by some types being tied together which normally would have nothing to do with eachother
19:26:51 <aavogt> in that case you could get around it by moving those definitions into separate modules
19:27:02 <int80_h> http://hpaste.org/46869/question_about_yesodexamples
19:27:24 <tg_> elliott: I am a physicist, so I often do thought experiments where I disappear you from the Universe, and re-insert you randomly subject to homogeniety and isotropy, and then ask what you can deduce :O
19:27:37 <elliott> tg_: Ah... Please don't do that.
19:27:42 <tg_> elliott: usually it turns our poorly for the "you" in that thought experiment
19:27:51 <elliott> Yes I do not think I would like that much.
19:27:54 <tg_> elliott: either *very* lonely, or *very* hot
19:28:08 <elliott> [Insert cheap joke about already being both.]
19:28:23 <tg_> awh. yay! awh.
19:33:32 <scooty-puff> when it comes to abstracting types, is there any difference (even very minor) between an associate type synonym vs. an associate data type?
19:33:51 <scooty-puff> it seems the associated data type just saves you from coming up with a name for it
19:34:26 <scooty-puff> i.e. uncertain if should do type ... = Int or newtype ... = MkI Int
19:36:28 <aavogt> scooty-puff: values with types named by the second option can't be used interchangably with Int (without adding or removing a MkI)
19:46:36 <mkserra> you know what i think is going on
19:46:48 <mkserra> the garbage collector runs
19:46:58 <mkserra> and the window manager removes focus from the SDL window
19:47:26 <mkserra> if I run in true full-screen mode there is no problem at all
19:47:38 <mkserra> nobody else ever had this problem?
19:47:47 <mkserra> is it just fluxbox's fault?
19:48:09 <dmwit> > showIntAtBase 2 ("01"!!) 76163908
19:48:10 <lambdabot>   Overlapping instances for GHC.Show.Show
19:48:10 <lambdabot>                              (GHC.B...
19:48:14 <dmwit> :t showIntAtBase
19:48:14 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
19:48:18 <elliott> mkserra: i don't see why the gc would do that.
19:48:22 <dmwit> > showIntAtBase 2 ("01"!!) 76163908 ""
19:48:23 <lambdabot>   "100100010100010101101000100"
19:48:45 <mkserra> you mean, why the window would lose focus?
19:49:37 <elliott> yeah
19:49:45 <mkserra> my going observation is that there are momentary pauses apparent in full-screen mode at occasional intervals
19:49:59 <elliott> but the gc is computation just like anything else :)
19:50:11 <elliott> does forcing a long computation in the middle of your program have the same effect?
19:50:16 <mkserra> it looks as though they occur about as frequently as the window-losing focus problem in windowed mode
19:50:29 <mkserra> hmm
19:51:40 <mkserra> what going on behind the scenes, other than gc, can behave so unpredictably?
19:51:44 <kmc> ThreadScope will show when GC's occur
19:51:58 <kmc> maybe your entire process is being scheduled out by the OS?
19:55:32 <kamatsu> :t isPrefixOf
19:55:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
20:01:27 <kamatsu> :t dropWhile
20:01:28 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
20:01:34 <dylukes> Random question, someone in here must know,
20:01:35 <int80_h> I'm looking at the haskell wikibook and have the following question
20:01:38 <int80_h> Use map to build functions that, given a list l of Ints, return:
20:01:41 <dylukes> how can you cancel a chord in the middle of it, in emacs?
20:01:50 <int80_h> Use map to build functions that, given a list l of Ints, return:
20:01:54 <dylukes> Say I've already typed C-x, and then decide I don't actually want to do anything.
20:02:00 <kmc> press ESC many times in a row?
20:02:02 <int80_h> A list that is the element-wise negation of l.
20:02:14 <int80_h> what does the "element-wise negation" mean?
20:02:31 <dylukes> kmc: I'm sure theres some better way >_>
20:02:40 <hgolden> x=1 negation=-1?
20:02:49 <kmc> int80_h, it means each element is the negation of an element from the input list
20:02:51 <kmc> in the same order
20:02:52 <dmwit> dylukes: Based on my sup experience, try Ctrl-G.
20:03:04 <dylukes> dmwit: that doesn't cancel it it seems though
20:03:07 <dylukes> It just say
20:03:13 <dylukes> C-c C-g isn't a vaid chord >_>
20:03:19 <dylukes> C-g cancels out, say, Find
20:03:58 <kmc> int80_h, using maths terminology becomes so natural that the author probably didn't notice this is confusing :/
20:04:06 <ths234> hey int80_h from n00b to n00b, im playing @ tryhaskell.org right now, dunno if you knew about but its way fun (at least the first 32 chaps) :P
20:04:30 <kmc> there are 32 chapters now? sweeeeeet
20:04:42 <monochrom> naw. 32 levels!
20:04:44 <ths234> plus has this handy irc window in-page
20:04:51 <monochrom> "new levels every month!"
20:04:55 <ths234> err
20:04:57 <ths234> "steps"
20:05:11 <ths234> im @ lesson6 :P
20:05:23 <monochrom> when it acquires 100 levels, we will call it Lode Runner!
20:05:30 <ths234> lol
20:05:40 <int80_h> kmc: thanks :)
20:06:05 <kmc> int80_h, in other words, "element-wise" is "what map does" ;)
20:06:07 <int80_h> kmc: so given input of [1,2,3] I would return [-1,-2,-3]?
20:06:09 <kmc> yes
20:06:24 <int80_h> easy enough
20:06:36 <monochrom> Try Haskell Lode Runner: grab all the validly typed treasures and avoid all the invalidly typed foes!
20:06:38 <int80_h> I'm stuck on my project so I'd thought I would do some exercises
20:06:38 <hgolden> ? map (* -1) [1,2,3,4,5]
20:06:49 <int80_h> kmc: unless...do you use yesod?
20:06:56 <kmc> no
20:07:00 <int80_h> durn
20:07:19 <dmwit> hgolden: negate is better
20:07:22 <dmwit> > negate 32
20:07:22 <lambdabot>   -32
20:07:38 <int80_h> > map negate [1,2,3]
20:07:39 <lambdabot>   [-1,-2,-3]
20:13:24 <elliott> maybeT :: Maybe a -> MaybeT m a -- does anyone have a better name for this?
20:14:34 <shachaf> @ty state -- does it mean the same thing as this?
20:14:35 <lambdabot> forall s a. (s -> (a, s)) -> State s a
20:14:46 <elliott> Alas, no.
20:14:50 <elliott> Thus the dislike of the name.
20:15:14 <elliott> This is it:
20:15:16 <elliott> maybeT :: (Monad m) => Maybe a -> MaybeT m a
20:15:16 <elliott> maybeT Nothing = MaybeT (return Nothing)
20:15:16 <elliott> maybeT (Just a) = MaybeT (return (Just a))
20:15:24 <elliott> Hmm, that can trivially be pointlessified.
20:15:25 <kmc> :t maybe mzero return
20:15:26 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
20:15:29 <elliott> But the name is the real problem.
20:15:43 <elliott> It's (MaybeT . return), basically.
20:16:12 <kmc> why did lambdabot not answer my query
20:16:14 <kmc> @type maybe mzero return
20:16:15 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
20:16:41 <kmc> sadly i have no name for "maybe mzero return" either, but i think it generalizes your maybeT
20:16:43 <elliott> kmc: it did.
20:16:46 <elliott> <kmc> :t maybe mzero return
20:16:46 <elliott> <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
20:16:51 <kmc> oh
20:16:56 <parcs> liftMaybe
20:17:17 <elliott> > runMaybeT (maybe mzero return (Just 9) :: MaybeT IO Integer)
20:17:17 <elliott> Just 9
20:17:18 <lambdabot>   Not in scope: `runMaybeT'Not in scope: type constructor or class `MaybeT'
20:17:20 <elliott> indeed it does seem to.
20:17:37 <elliott> parcs: possibly, but I'm not sure the analogy to the lift functions is perfect... and it's quite long for a common operation in my code
20:19:54 <mrbones118> :i MonadTrans
20:19:57 <mrbones118> pfft
20:20:13 <mrbones118> what's lambdabot's equivalent of ghci's ':i' ?
20:20:19 <parcs> there isn
20:20:21 <kmc> i don't think it has that :/
20:20:21 <parcs> t
20:20:25 <mrbones118> :(
20:20:44 <mrbones118> anyway, how isn't it a lift?
20:20:47 <mrbones118> from ghci
20:20:51 <kmc> :t lift
20:20:51 <mrbones118> http://62.204.68.45:80/dl/28096461aa8ba45e1c876b6b19f2c4e7/4dd5c787/38821.flv
20:20:52 <lambdabot>     Ambiguous occurrence `lift'
20:20:52 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
20:20:52 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
20:20:53 <mrbones118> lool
20:21:32 <parcs> what
20:22:02 <kmc> :t Control.Monad.Error.lift
20:22:03 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
20:22:19 <kmc> so it's not lift
20:22:31 <kmc> lift :: M a -> MaybeT M a
20:22:38 <kmc> foo :: Maybe a -> MaybeT m a
20:23:40 <ian_mi> @pl (flip (const id) .) . flip (:)
20:23:40 <lambdabot> (flip (const id) .) . flip (:)
20:24:28 <kmc> :t (flip (const id) .) . flip (:)
20:24:29 <lambdabot> forall b a. [a] -> a -> b -> [a]
20:24:36 <dmwit> ?unmtl MaybeT m a
20:24:36 <lambdabot> m (Maybe a)
20:25:59 <kmc> > fix error
20:26:01 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
20:26:08 <dylukes> kmc: XD
20:26:17 <parcs> it's not lift, but it's similar to the notion of a lift
20:26:28 <tg_> ok, ok... that line looks like he's going to blow up
20:26:31 <elliott> yeah but calling it "liftMaybe" feels wrong
20:26:41 <ion> maybeToMonad
20:26:45 <dylukes> > fix liftM id
20:26:46 <lambdabot>   Occurs check: cannot construct the infinite type: a1 = m a1
20:26:53 <dylukes> fuck you haskell.
20:26:57 <elliott> I'm starting to think that maybeT is the best name :-)
20:27:09 <parcs> possibly
20:27:12 <ion> maybeM
20:27:15 <parcs> or transformMaybe
20:27:18 <kmc> :t maybe
20:27:19 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:27:44 <kmc> anyway the thing to find a name for is «maybe mzero return»
20:27:55 <elliott> well, maybe. :)
20:28:13 <kmc> which might be called "maybeMp" but that's a little ugly
20:28:32 <parcs> maybePlus
20:28:37 <kmc> naming things is hard; that's how we end up with zygohistomorphic prepromorphisms
20:28:55 <kmc> alternatively try http://www.classnamer.com/
20:28:56 <ion> maybeMorph
20:29:09 <dylukes> ExecutableLolcatDialog
20:29:10 <dylukes> I shudder.
20:29:51 <elliott> i'll just call it mt or something like that >:)
20:30:04 <kmc> @let (♥) = maybe mzero mplus
20:30:05 <lambdabot>  Defined.
20:30:07 <elliott> kmc: lol "ScriptableKeystrokePreference"
20:30:26 <elliott> "ErrorCorrectingButtonBundle" wat
20:30:29 <kmc> elliott, needs more factories
20:30:37 <ion> maybeFactory
20:30:38 <elliott> i want a bundle of buttons that corrects errors now
20:30:42 <elliott> ion: mactory
20:31:03 <kmc> is that like a factory but costs 2x as much and comes in brushed aluminum?
20:31:08 <kmc> zing!
20:31:13 <parcs> @type fix .: maybe
20:31:13 <lambdabot> forall a. Maybe a -> (a -> Maybe a) -> Maybe a
20:31:28 <ion> funMactory (Haskell needs more Hungarian notation.)
20:31:40 <kmc> Hungarian notation is the opposite of Haskell
20:31:41 <elliott> the funnest mactory in all the land
20:31:46 <kmc> "let's write our types but not check them"
20:31:50 <elliott> yeah i'm seriously just going to go with maybeT at this point
20:31:56 <elliott> even though it's ugly
20:32:14 <kmc> the Factory Pattern is a tempting way to structure software, until the workers in your factory unionize
20:32:28 <ion> maybeT sounds like something closely related to MaybeT
20:32:39 <danharaj> I hate the Factory pattern.
20:32:40 <parcs> @let _______ = MaybeT . return
20:32:41 <elliott> ion: i'm specialising it to (Monad m) => Maybe a -> MaybeT m a
20:32:41 <lambdabot>  <local>:4:10: Not in scope: data constructor `MaybeT'
20:32:45 <elliott> so yah, it is closely related here
20:33:00 <kmc> i would expect maybeT to have type «m b -> (a -> m b) -> MaybeT m a -> m b»
20:33:04 <kmc> but whatever
20:33:12 <kmc> i think the bikeshed should be purple
20:33:20 <elliott> kmc: well, me too.
20:33:24 <elliott> but all the alternative names suck :)
20:33:27 <ion> maybePurpleBikeshed
20:33:30 <kmc> i'm glad we agree on what color the bikeshed should be
20:33:40 <elliott> yeah
20:33:45 <elliott> purple is the best bikeshed colour
20:34:15 <ts00000> I have a very newbie question
20:34:30 <acowley> I have a less newbie question, we can trade
20:34:32 <acowley> what's up?
20:34:34 <elliott> :-D
20:34:35 <ts00000> i'm trying to do some sort of Redis hello world
20:34:46 <ts00000> so i'm importing Database.Redis.Redis, and I can connect to the redis server, and set a value
20:35:03 <ts00000> but when i'm trying to get a value, I can't seem to get it to return anything, it gives me an ambiguous type variable error
20:35:14 <ts00000> even when I do something like get server ("key" :: String)
20:35:16 <ts00000> what am I missing?
20:35:18 <kmc> can you put the code and error on hpaste.org?
20:35:23 <ts00000> sure
20:35:25 <acowley> you're using redis-simple?
20:36:15 <ts00000> no, just the redis driver from cabal
20:37:05 <ts00000> http://hpaste.org/46875/redis
20:37:47 <acowley> The value type is ambiguous
20:37:53 <acowley> s2 in get's type
20:37:55 <kmc> you put those last 3 lines in "main = do ..." or something?
20:38:06 <ts00000> well, actually I was using ghci directly
20:38:09 <kmc> oh
20:38:48 <acowley> so you would want something like, get server "user:15000" :: IO String
20:39:12 <kmc> or:  x <- get server "user:15000"; putStrLn x
20:39:16 <acowley> or, the more common thing, pass the result along to something that nails down the type
20:39:20 <kmc> using putStrLn fixes the type
20:39:22 <acowley> exactly what kmc did
20:39:24 <kmc> yep
20:39:27 <ts00000> I think the issue is that it looks like a reply
20:39:27 <ts00000> e.g.
20:39:33 <kmc> type information flows backwards in time :)
20:39:34 <acowley> he answers and I explain in parallel!
20:39:34 <ts00000> inferred type reply s2
20:39:38 <ts00000> ?
20:39:40 <kmc> acowley, we're a good team :)
20:40:01 <kmc> yeah i guess you have to do something to turn (Reply String) into String
20:40:11 <kmc> so what i said is not correct
20:40:26 <acowley> It's got a show instance
20:41:12 <acowley> ts00000 you can show the Reply, or you can pattern match on it
20:41:26 <acowley> ts00000: I presume you'll get an RInline variant in this case, though I've never used redis
20:44:02 <acowley> Ok, here's my question for anyone still playing
20:44:24 <acowley> I have some code that I wrote a while ago that I've never tested to my satisfaction, and an SO question today rekindled the dream
20:44:26 <acowley> http://hpaste.org/46876/clone_wars
20:44:37 <kmc> redis is written in C :(
20:44:39 <acowley> here's the SO question: http://stackoverflow.com/questions/6059505/better-interface-for-composing-destructive-operators
20:44:51 <kmc> memcached had a remote code execution vulnerability because they wrote "int" instead of "unsigned int"
20:44:57 <acowley> my question is what people think of the approach I took
20:45:46 <acowley> If only Haskell had a Nat type that was used in 90% of the places we use Int :(
20:46:27 <tromp> and what would 0-1::Nat be?
20:46:36 <kmc> acowley, agreed, but the fact remains that erroneously using Int instead of Nat in Haskell (or Java or C# or Python or Perl or PHP or Ruby or Scala or Clojure or Erlang) will not usually lead to remote code execution
20:46:55 <kmc> tromp, 0
20:47:00 <kmc> the way it's usually defined in number theory
20:47:32 <tromp> so you give up associativity
20:47:33 <acowley> tromp: In Haskell, 0. In Coq, 0-1>0
20:47:46 <copumpkin> tromp: - isn't associative
20:48:11 <acowley> but he's right that you give up nice regrouping of terms one can do with typical arithmetic
20:48:20 <acowley> as you lose the group structure
20:48:25 <tromp> i mean a+b-c != a+(b-c)
20:48:37 <elliott> i'd just have (0-1 :: Nat) be _|_ :/
20:48:44 <acowley> tromp: I think it's worth giving that up
20:48:44 <elliott> not like we're getting away from _|_ any time soon
20:48:47 <kmc> ;P
20:48:58 <copumpkin> elliott: can't do that in coq
20:49:05 <elliott> copumpkin: talking about haskell ofc
20:49:30 <acowley> copumpkin: 0 - 1 > 0. Admitted.
20:49:32 <elliott> still haven't thought of a better name than maybeT :(
20:49:35 <acowley> err
20:49:39 <acowley> something like that :P
20:49:53 <elliott> Theorem yep : False.
20:49:56 <elliott> Admitted.
20:50:13 <elliott> I love how it's not even "admit", just "admitted" -- you WILL admit this, it's a fact not an order
20:50:22 <acowley> Coq is powerful.
20:50:41 <Perlkonig> Question: The type system is still tripping me up at the most unexpected times. The function attempts to add the first 100 decimal digits of an irrational square root. Can somebody help me understand why my type declaration is broken? http://hpaste.org/46877
20:50:51 <kmc> Beweis: Klar. □
20:50:58 <ion> Coq is phalliq
20:51:04 <acowley> anyone had a chance to look at my hpaste? Any slings and arrows for me?
20:51:21 <elliott> oh i know
20:51:26 <elliott> maybeValueToMaybeTValue
20:51:27 <elliott> perfect
20:51:57 <acowley> elliot: this is an opportunity for confusion, I nominate: possibly
20:52:12 <kmc> lpstrMaybeValueToMaybeTValueExA
20:52:24 <bos> preflex: seen hydo
20:52:24 <preflex>  hydo was last seen on #haskell 5 hours, 17 minutes and 44 seconds ago, saying: jaspervdj: thank you!
20:53:46 <acowley> Perlkonig: you get a list of Ints from num2list, then sum that list and return a value of type a
20:53:51 <elliott> acowley: that was my first idea :-D
20:53:53 <elliott> re possibly
20:54:26 <acowley> elliott: I just want to see compositions of possibly and maybe
20:54:40 <elliott> acowley: heh :)
20:54:41 <acowley> hemhaw = (possibly .) . maybe
20:54:47 <Perlkonig> acowley: Type a is "Integral." Does that not encompass Ints?
20:55:38 <acowley> Perlkonig: the constraint means that an Int would satisify the constraint, not that an Int is every type satisfying the constraint
20:57:14 <Perlkonig> acowley: Thank you for your reply. I'm afraid I'm still not understanding why the compiler is complaining. How does an inferred "Int" not match "Integral"?
20:57:14 <acowley> Perlkonig: I worded that perhaps as confusingly as possible, sorry.
20:57:38 <acowley> Perlkonig: The point is that if I have a type Foo that has an Integral instance, I can give it to sumdigits, and get a Foo back
20:58:04 <acowley> Perlkonig: but num2list always returns a list of Ints, and you sum that list, which gives you an Int
20:58:10 <acowley> so you are forcing a = Int
20:58:19 <acowley> but I gave sumdigits a Foo
20:58:22 <acowley> which is not an Int
20:59:57 <Perlkonig> acowley: OK. So in a more general case, if I can't be sure that the sum won't overflow, how do I define the type so that it works?
21:00:21 <acowley> Perlkonig: chage num2list to return [Integer]
21:00:39 <acowley> map (toInteger . digitToInt)
21:01:00 <ts00000> sigh, i'm still so lost
21:01:21 <acowley> Then you can use fromInteger on the result of sumdigits and get back an a
21:01:52 <acowley> ts00000: did showing the Reply not work? Did you try pattern matching on it to see what you got?
21:02:15 <ts00000> no, hello world is just beyond me at this phase, i'll spend the weekend reading LYAHFGG
21:02:33 <acowley> You've picked quite an exotic variant of hello world
21:02:45 <ts00000> apparently
21:03:35 <Perlkonig> acowley: But the num2list always returns single digits, so they will always be Int. If I declare sumdigits as "Integer -> Integer", and change the definition to "toInteger $ sum list", I get a new error "Ambiguous type variable `b' in the constraints"
21:04:06 <acowley> The digits are Ints, but there sum could overflow
21:04:24 <acowley> so we want addition over Integers, which we get by converting the Ints to Integers
21:04:36 <acowley> s/there/their
21:04:36 <ts00000> acowley:     No instance for (Show (IO (Reply s2)))
21:05:07 <kmc> you did «print (get ...)» ?
21:05:14 <kmc> try «do x <- get ...; print x»
21:05:20 <acowley> ts00000: get server "user" >>= print
21:05:25 <bos> preflex: seen dafis
21:05:25 <preflex>  dafis was last seen on #haskell 7 hours, 22 minutes and 30 seconds ago, saying: okay, then exchange g and f above
21:05:27 <kmc> you can't print an IO action, because it represents some IO that hasn't happened yet
21:05:30 <acowley> but it will still probably be a problem
21:05:33 <kmc> but you can run the IO action and then print the result
21:05:36 <acowley> as it doesn't know s2 is a String
21:06:03 <Perlkonig> acowley: Since Integers are apparently less efficient than Ints, doesn't it make sense to offload the overflow check to the summing function instead of the num2list which could  be used by other routines? Does "toInteger $ sum list" catch an overflow?
21:06:12 <elliott> acowley: i just need potentially too
21:06:27 <acowley> elliott: itcouldbethat x = 2
21:06:31 <elliott> possibly . (. (potentially . (. maybe))
21:06:38 <elliott> ?unpl possibly . (. (potentially . (. maybe))
21:06:38 <lambdabot> Unbalanced parentheses
21:06:40 <elliott> ?unpl possibly . (. (potentially . (. maybe)))
21:06:40 <lambdabot> (\ e -> possibly (\ k -> e (potentially (\ n -> k (maybe n)))))
21:06:41 <acowley> Perlkonig: no
21:06:43 <elliott> nice.
21:06:46 <elliott> ?. pl unpl possibly . (. (potentially . (. maybe)))
21:06:46 <lambdabot> possibly . (. (potentially . (. maybe)))
21:07:09 <acowley> Perlkonig: the overflow could occur on any of the additions, so each must be checked
21:07:31 <ts00000> acowley: you have it right, it's still clueless about s2
21:07:52 <acowley> ts00000: do what kmc suggested
21:07:56 <tromp> i'm having a hard time with cabal install cairo
21:08:07 <acowley> ts00000: x <- get server "blah" :: IO (Reply String)
21:08:28 <acowley> ts00000: then "print x" on the next line of the do block
21:08:35 <tromp> It says: setup: The pkg-config package cairo-pdf is required but it could not be found.
21:08:48 <acowley> ts00000: in the future this will be easier as you'll be doing something with the result
21:09:52 <acowley> return type polymorphism gives the caller great power, and the thing that comes with that
21:10:22 <Perlkonig> acowley: OK. So I changed that and still changed sumdigits to "Integer -> Integer". But the compiler says there's an "Ambiguous type variable `b' in the constraints".
21:11:06 <Perlkonig> acowley: Thank you again for your time, btw. I don't know why the type system is giving me such grief.
21:11:31 <acowley> Perlkonig: that's probably coming from fromIntegral
21:11:54 <acowley> Perlkonig: note that you're using sqrt, whose type is (surprise!) polymorphic
21:12:08 <acowley> so give whole or root a type signature
21:12:17 <acowley> e.g., whole :: Double
21:12:34 <Perlkonig> acowley: Oh, I didn't even know I could do that. So "whole :: Double = blah"?
21:12:42 <ts00000> thanks, it was just digging into the Reply String that I was missing
21:12:49 <acowley> Perlkonig: no, put the "whole :: Double" on a line above the defintion of whole
21:12:50 <ts00000> I didn't understand I can just overload that for as many times as I want
21:13:15 <Perlkonig> acowley: But doesn't truncate turn "whole" into an Integer anyway?
21:13:17 <acowley> Perlkonig: you could also put the ":: Double" to the right of the definition
21:13:31 <acowley> d'oh, no it doesn't
21:13:35 <acowley> but you're back to Integral
21:13:47 <acowley> err, but that should be fine
21:13:54 <Perlkonig> *'s brain explodes*
21:14:06 <acowley> Perlkonig: You're right, you need the type annotation just on the sqrt part
21:14:17 <kmc> @ghc
21:14:18 <lambdabot> ghc says: ld64: INFO    171: Multigot invoked. Gp relative region broken up into 2 separate regions.
21:14:26 <kmc> @ghc
21:14:26 <lambdabot> ghc says: No parameters for class
21:14:30 <kmc> @ghc
21:14:30 <lambdabot> ghc says: Unexpected strictness annotation
21:15:05 <ts00000> acowley: is it relatively easy to put, say, the reply type in one place, and the string in the other?
21:15:40 <acowley> Perlkonig: you can write "fromIntegral n :: Double"
21:15:57 <acowley> ts00000: I don't really understand that question
21:16:25 <acowley> Perlkonig: what I wrote was for your definition of whole
21:16:45 <ts00000> like instead of  x <- get server "user:15000" :: IO (Reply String), have one variable for the reply, and one for the string
21:17:11 <ts00000> binding multiple variables in one statement
21:17:37 <acowley> ts00000: the problem is that Reply has several constructors
21:18:48 <acowley> ts00000: if you wanted to make a mistake, you could write RInline x <- get server "blah" :: IO (Reply String)
21:18:55 <acowley> that way your program would crash later
21:19:03 <acowley> due to a pattern match failure
21:19:21 <acowley> what you want is something that takes a Reply and deals with all its variants
21:19:32 * JuanDaugherty notes that the leksah dmg does at least work unproblematically.
21:19:45 <ts00000> alright, good enough for now
21:19:56 <ts00000> i'll dig into LYAH tomorrow and see if I get closer
21:20:17 <acowley> ts00000: I recommend putStrLn "Hello World"
21:20:22 <acowley> ts00000: :P
21:20:34 <Alan> is there a parsing library that's more recommended than parsec?
21:21:10 <ts00000> acowley: that's easy, writing something useful as a hello world exercise is harder :-)
21:22:45 <acowley> ts00000: mapM_ (putStr . show) "Hello World"
21:23:17 <Perlkonig> acowley: That still doesn't stop the "ambiguous type" error. This is so frustrating! I updated the hpaste. http://hpaste.org/paste/46877
21:23:46 <acowley> oh, you said "useful".... working through the types could be a useful exercise
21:25:37 <Perlkonig> ts00000: I've found LYAH very helpful.
21:26:15 <kmc> Alan, I recommend parsec for general use
21:26:29 <kmc> you can also look at uu-parsinglib and see if you like that better
21:26:55 <kmc> if you need efficiency in parsing binary protocols, see attoparsec
21:27:04 <acowley> Perlkonig: whole = truncate $ sqrt (fromInteger n::Double)
21:27:12 <acowley> Perlkonig: root = truncate $ (sqrt (fromInteger (n - whole))) * 10^100
21:28:06 <acowley> kmc: did you get a chance to look at my hpase?
21:28:09 <acowley> hpaste
21:28:21 <Perlkonig> acowley: "No instance for (Integral Double)"
21:28:35 <kmc> no, sorry
21:29:46 <Alan> kmc: actually i'm trying to decide if it's really worth reviewing others in the lit review for this project...
21:29:52 <acowley> Perlkonig: I annotated your paste
21:29:58 <acowley> Perlkonig: that code compiled for me
21:30:03 <Alan> seeming as i'm not doing a specific "parsing in haskell" lit review...
21:30:18 <ddarius> Alan: What are you doing the "lit review" on?
21:31:02 <Alan> ddarius: things directly related to or used in my project, which among other things involves a small compiler written in haskell
21:31:38 <ddarius> For a compiler, Parsec is probably one of the best options.
21:35:54 <acowley> Alan: If Parsec gives you trouble (e.g. performance, error handling, etc.) then you can put more time into exploring options.
21:37:46 <Perlkonig> acowley: It's still not compiling for me. Your updated code slightly altered what the code did. I updated the hpaste (http://hpaste.org/paste/46877). I think I better get to bed. Fatigue is not helping me understand. Thank you very much for your time!
21:38:19 <ivanm> Alan: I like polyparse, but I'm in the minority ;)
21:38:31 <ivanm> preflex: seen malcolmw
21:38:32 <preflex>  malcolmw was last seen on #haskell 93 days, 7 hours, 31 minutes and 11 seconds ago, saying: There is an Xtract-lazy tool in HaXml
21:38:49 * ivanm needs to ping malcolmw to release the new version with support for parsing Text values
21:39:28 <acowley> Perlkonig: sorry about that. How about this: root = (truncate (sqrt (fromInteger n)) - whole) * 10^100
21:39:57 <Perlkonig> acowley: Why n::Double the first time but not the second?
21:40:07 <KirinDave> If you have a lazy bytestring and you want to turn it into an eager bytestring, is that possible?
21:40:29 <copumpkin> sure
21:40:51 <Perlkonig> acowley: That compiled! And I *still* don't understand why! *sighs*
21:40:55 <KirinDave> How?
21:41:13 <kmc> Strict.concat . Lazy.toChunks
21:41:13 <ivanm> @hoogle toChunks
21:41:14 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
21:41:14 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
21:41:35 <kmc> bonus points for using "eager" as the opposite of "lazy", rather than "strict"
21:41:46 <ivanm> kmc: wait, you're giving points out now? :o
21:41:56 <kmc> of course
21:42:03 <KirinDave> It's not ByteString.concat, kmc?
21:42:08 <KirinDave> Ahh, I got it.
21:49:05 <jmcarthur> ugh, i hate this type:   insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
21:49:23 <jmcarthur> i wish it was insertWith :: Ord k => (a -> b -> a) -> k -> b -> Map k a -> Map k a
21:49:58 <jmcarthur> or whatever argument order the function should have
21:50:32 <jmcarthur> i guess there's adjust
21:54:48 <ivanm> jmcarthur: I think it's `a' for when k isn't in the Map yet
21:54:53 <ivanm> so it just inserts (k,a)
22:04:05 <dolio> Yeah, what would the b version do in that case?
22:05:52 <jmcarthur> ah yeah
22:06:07 <jmcarthur> i retract my complaint
22:06:49 <dolio> Is there actually a function with the latter type?
22:07:09 <dolio> Seems like it could also be Ord k => (a -> a) -> k -> Map k a -> Map k a.
22:07:17 <jmcarthur> adjust is the latter
22:07:22 <jmcarthur> err
22:07:25 <jmcarthur> the one you just gave
22:07:29 <jmcarthur> good enough
22:08:10 <dolio> They're equivalent, of course.
22:09:18 <dolio> @type M.adjust
22:09:19 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
22:10:08 <dolio> @type let g f k v = M.adjust (flip f v) k in g
22:10:08 <lambdabot> forall a a1 k. (Ord k) => (a -> a1 -> a) -> k -> a1 -> M.Map k a -> M.Map k a
22:11:05 <dolio> @type let g f k v = M.adjust (flip f v) k in \e k -> g (flip id) k e
22:11:05 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
22:11:24 <jmcarthur> heh
22:17:24 <ivanm> wow, didn't know about 3.8.5 here: http://www.haskell.org/haddock/doc/html/ch03s08.html
22:18:33 <ddarius> Docs: Don't write them because people won't find them, if they find them, they won't read them, if they read them, they won't understand them, and if they understand them, they are out of date.
22:20:15 <ivanm> ddarius: you mean all this time I've been spending writing documentation - including ASCII-art diagrams!!! - has been a _waste_? :o
22:20:28 <ddarius> ivanm: Yes.  That's -exactly- what I mean.
22:21:21 <ivanm> :(
22:21:32 <ulfdoz> I can't confirm that.
22:21:41 <ivanm> ulfdoz: can you deny it though?
22:21:51 <ulfdoz> Its just, that those who read and understand the documentation, simply don't show up on the radar.
22:22:15 <ivanm> ddarius: so, does that mean that the recent discussion on -cafe about having a different tool other than haddock for generating documentation was pointless?
22:22:21 <ulfdoz> ivanm: Not completely, however, non-readers are a welcome victim for my mood.
22:22:27 <ivanm> heh
22:22:33 <ivanm> which packages in particular?
22:23:02 <ivanm> look, see: ASCII-art!!!! http://code.haskell.org/~ivanm/planar-graph-haddock/Data-Graph-Planar.html
22:23:55 <sangi_> whee are one
22:25:48 <acowley> being able to embed SVG or the like in haddock would be neat
22:25:54 <acowley> or dot
22:26:10 <ivanm> hmmmm.....
22:26:23 <jmcarthur> ++
22:26:30 <ivanm> well, I have plans on how to write dot-like code in Haskell
22:26:44 <ivanm> taking dotgen but adding much more functionality
22:26:55 <ivanm> it's on my TODO list for graphviz
22:27:22 <ivanm> actually, didn't someone add haddock support for images a couple of years ago?  Just that Cabal doesn't support it or something?
22:27:46 <acowley> something the browser can render is ideal, though, as it doesn't carry any extra dependencies or issues with binary resources
22:28:06 <dolio> Just write all your documentation on Wolfgang|lambda worksheets.
22:28:15 <dolio> And your programs.
22:28:17 <ivanm> yeah, <<url>> apparently, as of 2.4.0
22:28:45 <ivanm> acowley: well, I'm also planning on writing a graphviz -> JIT converter at AusHac in July... :p
22:29:17 <acowley> which JIT?
22:29:25 <ivanm> javascript infovis toolkit
22:29:54 <ivanm> i.e. the idea here: http://ivanmiljenovic.wordpress.com/2011/01/25/a-crazy-idea-about-graph-visualisation/
22:29:59 <acowley> I'd never heard of that
22:30:10 <acowley> looks cool, but a terrible choice of initialism!
22:30:42 <ivanm> yeah
22:31:18 <acowley> that does look really neat
23:45:50 * hackagebot text 0.11.0.8 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.0.8 (BryanOSullivan)
23:55:39 <fragamus> hello
23:56:01 <fragamus> is anyone on
23:57:10 <KirinDave> What's a good library for making http requests?
23:57:22 <KirinDave> Network.HTTP's interface is a little painful, esp if you deal with headers.
23:58:46 <mm_freak> KirinDave: what do you need?  just get some resource or do you need something more flexible?
23:59:03 <jeffz> KirinDave: have you looked at http-enumerator?
23:59:19 <KirinDave> jeffz: I haven't, but I am not going to leverage any of the power of iteratees here.
23:59:30 <KirinDave> I am writing something that does proxying
