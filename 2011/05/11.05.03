00:15:30 <Axman6> @msg limmeh On the safecopy wikipage (http://acid-state.seize.it/safecopy), shouldn't the instance of the SafeCopy class for X2 use the X2 constructor? I would change it, but i wanted to be sure.
00:15:30 <lambdabot> Not enough privileges
00:16:18 <Axman6> @ask limmeh On the safecopy wikipage (http://acid-state.seize.it/safecopy), shouldn't the instance of the SafeCopy class for X2 use the X2 constructor? I would change it, but i wanted to be sure.
00:16:19 <lambdabot> Consider it noted.
00:23:54 <shamster> Is there a function that performs something like [Double] -> ByteString?
00:24:15 <shamster> I'm trying to save to a data file my accumulated [Double]
00:24:47 <Axman6> see the Binary package (or Cereal)
00:25:01 <Axman6> @hoogle a -> ByteString
00:25:01 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
00:25:01 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
00:25:01 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
00:25:05 <Axman6> hmm
00:25:08 <Axman6> :t encode
00:25:09 <lambdabot> Not in scope: `encode'
00:25:38 <shamster> I've been staring at ByteString for a while but not seeing quite what I need
00:26:29 <c_wraith> shamster: you want cereal, binary, or whatever the ieee-754 package is
00:26:38 <c_wraith> shamster: depending on your needs.
00:27:08 <shamster> okay
00:27:08 <shamster> thanks
00:27:12 <Axman6> yeah, the ieee-754 package would be best if you need to write the data for another application to use
00:29:07 <Nereid> or binary combined with data-binary-ieee754
00:29:58 <shamster> I've got the iee754, so I'll give it a go
00:30:14 <koeien> I succesfully used data-binary-ieee754 with Java's intBitsToFloat last week :)
00:31:50 <jkjipcl> Does an expression always return a value?
00:32:02 <Nereid> what does "return a value" mean?
00:32:10 <koeien> what is "returning a value"
00:32:30 <Axman6> all expressions have a value
00:32:31 <jkjipcl> return only a value
00:32:33 <koeien> > 1 + 2 -- this is a value AND an expression
00:32:34 <lambdabot>   3
00:33:10 <jkjipcl> I see.thx
00:33:51 <koeien> it is possible for an expression to diverge (e.g. to never yield a value)
00:33:56 <koeien> > let x = x in x
00:33:59 <lambdabot>   mueval-core: Time limit exceeded
00:34:17 <Nereid> depends on what you mean by value
00:34:30 <koeien> yeah, you could say it yields _|_
00:34:33 <Nereid> yeah
00:35:05 <Axman6> > let xs = xs ++ [1] in xs
00:35:09 <lambdabot>   mueval-core: Time limit exceeded
00:35:17 <jkjipcl> I think every expression must have a type ,right?
00:35:21 <Axman6> that's gotta have some horrible space usage...
00:35:26 <Axman6> jkjipcl: yes
00:37:35 <Cale> I suppose expressions which don't typecheck don't have types, but the compiler will reject them :)
00:37:49 <MasseR> How do I get (Num a) => a -> a for (-13)
00:37:56 <MasseR> As in map (-13) x
00:38:03 <Cale> :t subtract 13
00:38:04 <lambdabot> forall t. (Num t) => t -> t
00:38:12 <Cale> :t (+(-13))
00:38:13 <lambdabot> forall a. (Num a) => a -> a
00:38:18 <MasseR> Thanks
00:38:19 <shamster> What's the smallest way I could store a [Double] in a file?
00:38:21 <koeien> unary minus strikes again
00:38:46 <koeien> shamster: that depends on the size of your serializer.
00:38:51 <Cale> shamster: The smallest file, or the smallest expression?
00:38:57 <shamster> smallest file
00:39:40 <shamster> I have a text file with %6.3f format data that I can parse to a [Double]
00:40:07 <shamster> From there I'd like to store it in a binary file, in the hopes that binary would be more compact than ascii text
00:40:38 <koeien> a double is 8 bytes generally. but you can use a compression algorithm
00:40:42 <Axman6> the binary would use 8 bytes per double... and that's 10 bytes, so not a huge saving
00:40:47 <Cale> Well, ignoring compression schemes, the various binary serialisation libraries do a pretty good job. In cereal, there are instances Serialize Double and Serialize a => Serialize [a]
00:40:50 <Cale> which you can use
00:41:28 <MasseR> Hmm... That's clearly rot13, I can decrypt the first word, but it has also characters such as [ä,ö], and I have no idea where the boundary is. Wasn't as quick a puzzle as I thought :/
00:41:36 <shamster> 8 bytes per double... whereas my text would be 2 bytes per character * (6 characters + decimal point)
00:42:07 <koeien> you use UTF16 ?
00:42:08 <shamster> or is the ascii 1 byte per character...
00:42:15 <Nereid> ascii is 1 byte per character
00:42:19 <koeien> yes, 1 byte / char
00:42:30 <Nereid> you could do better; you can store a decimal digit, plus a couple other characters, in 4 bits
00:43:01 <shamster> Nereid: in the binary or ascii?
00:43:07 <Nereid> neither
00:43:18 <Nereid> it's just sort of a trivial compression thing
00:43:23 <Nereid> you don't have many distinct characters
00:44:05 <shamster> Nereid: so the 4 bits would be 3 for the 0-9 number, and the 4th for the decimal?
00:44:12 <Nereid> no
00:44:16 <Nereid> you can't store 0-9 in 3 bits
00:44:18 <Nereid> :/
00:44:20 <shamster> right
00:44:22 <shamster> ...
00:44:29 <koeien> no, just 0000 = 0, 0001 = 1, ..., 1001 = 9, 1111 = '.' (say)
00:44:33 <Nereid> 4 bits lets you have 16 distinct values
00:44:41 <epdtry> shamster: assign 0-9 = those digits, 10 = '.', 11 = separator or something
00:45:07 <Axman6> actually, i think that if you used a fixed point representation, you could use something like 2 bytes for eahc number you can represent with %6.3f
00:45:11 <Nereid> but for enough numbers you'd be better off just writing it as ascii or something and compressing it
00:45:37 <Nereid> Axman6: definitely more than 2...
00:45:53 <Axman6> hmm, yeah, but possibly three :)
00:45:59 <Nereid> 10^9 is just under 2^30.
00:46:21 <Nereid> and probably a sign too
00:46:22 <fcr> you can also use dpd (densely packed decimals)
00:46:26 <Nereid> so you'd need 31 bits anyway
00:46:37 <Nereid> fcr: is that different from the 4 bits per digit described above?
00:46:46 <fcr> Nereid: it is
00:47:03 <Nereid> I see.
00:47:39 <fcr> it stores 3 decimal digits on 10 bits
00:47:41 <Axman6> > logBase 2 (10^6) + logBase 2 (10^3)
00:47:42 <lambdabot>   29.897352853986263
00:47:44 <Nereid> yeah I found it.
00:47:51 <Axman6> ok, needs 30 bits
00:47:53 <Cale> ghci> Data.ByteString.Lazy.length (Data.ByteString.Lazy.fromChunks [encode [1..10000::Double]])
00:47:53 <Cale> 250008
00:47:53 <Cale> ghci> Data.ByteString.Lazy.length (compress (Data.ByteString.Lazy.fromChunks [encode [1..10000::Double]]))
00:47:53 <Cale> 13135
00:47:56 <Nereid> Axman6: I just said that
00:48:01 <epdtry> 6 is the width in characters, including the fractional part
00:48:08 <epdtry> so the integer part is only 2 digits
00:48:11 <Cale> (that's using cereal and bzlib
00:48:11 <Cale> )
00:48:29 <Nereid> oh
00:48:32 <Nereid> right.
00:48:32 <Axman6> epdtry: oh? hmm, been a long time since i read that manpage =)
00:48:34 <shamster> well just using gzip I managed to cut the size in half... :)
00:48:44 <Nereid> shamster: if you want small size, compress it
00:48:47 <Nereid> seems simple enough
00:49:14 <Cale> of course, you could also just compress the 'show' of the list
00:49:28 <koeien> but 'read' is likely to be slow
00:49:34 <Axman6> Nereid: check out http://hackage.haskell.org/packages/archive/fixed-point/0.5.0.0/doc/html/Data-Fixed-Binary.html
00:49:42 <Nereid> I've seen that
00:50:01 <Nereid> except it's binary, so can't store decimal numbers exactly
00:50:21 <Cale> ghci> Data.ByteString.Lazy.length . compress . Data.ByteString.Lazy.Char8.pack . show $ [1..10000::Double]
00:50:21 <Cale> 10478
00:50:28 <Axman6> http://hackage.haskell.org/package/Decimal?
00:50:34 <Cale> It's actually smaller!
00:50:46 <Nereid> Cale: no surprise
00:50:53 <Nereid> :P
00:51:22 <Cale> Well, yeah, a good question is whether read . show is the identity for Doubles
00:51:48 <Axman6> @check (\x -> read (show x) == (x :: Double))
00:51:49 <lambdabot>   "OK, passed 500 tests."
00:52:02 <Baughn> @tell bos Yeah, it's been dead. But that is not dead which can eternal... er, whatever. Waking up now.
00:52:03 <lambdabot> Consider it noted.
00:52:09 <Cale> (could be, if there's always enough digits to uniquely identify the mantissa)
00:52:11 <Axman6> certainly not a conclusive test though...
00:54:53 <Cale> ghci> let xs = compress . Data.ByteString.Lazy.Char8.pack . show $ [n*pi | n <- [1..10000]]
00:54:56 <Cale> ghci> let ys = read . Data.ByteString.Lazy.Char8.unpack . decompress $ xs :: [Double]
00:54:56 <Cale> ghci> ys == [n*pi | n <- [1..10000]]
00:54:56 <Cale> True
00:55:33 <Axman6> i wonder what the size of the binary encoded version compressed would be...
00:55:36 <Cale> xs is 73964 bytes
00:55:47 <Cale> (not binary encoded)
00:56:37 <Cale> 55750 bytes if we encode that one with cereal before compressing
00:56:59 <Cale> So there it does a good bit better to binary encode first.
00:57:16 <koeien> it's also possible that it's faster to (de)serialize that way
00:57:21 <Cale> indeed
00:57:25 <koeien> of course, you lose human readability.
00:57:37 <koeien> but for large amounts of doubles it might not be important
00:57:42 <Cale> bzipping does that too though, to some extent
00:57:56 <koeien> and you can always decompress and view in a hex editor
00:59:05 <Axman6> hmm, fixed-point isn’t a package that is obvious how to use
00:59:27 <Cale> isn't it?
00:59:54 <Cale> oh, what is this new SuperTypeable nonsense...
01:00:12 <Axman6> ah, i;m not using the right import =)
01:00:30 <Cale> anyway, ignoring that, you just use the fact that it's an instance of Num, etc.
01:00:49 <Axman6> yeah
01:01:45 <Axman6> hmmm, doesn't seem very accurate either. using 1.234567 :: Fixed E10 Int64 gives 1.234375 back
01:01:57 <Axman6> though that probably makes sense
01:03:18 <Axman6> ha! got a stack overflow when running 1.23456789 :: Fixed E32 Int64 in ghci
01:04:03 <Axman6> if you use :set -fcontext-stack=64 though, everything works fine
01:04:13 <Axman6> well, "fine"
01:05:15 <Axman6> wow... fromRealFloat 1.23456789 :: Fixed E64  Int64 gives back 0.2345678899999998900938180668163113296031951904296875... that's quite wrong
01:05:51 <Eliel> no, I'd say it's pretty close to the original :)
01:05:53 <Axman6> ah, makes sense though, if you use Integer it (obviously) doesn't drop the 1 from the front
01:06:12 <Eliel> oh wait, I missed the dropping of 1 from it :D
01:06:17 <Axman6> yah :P
01:07:06 <Eliel> the fractional part is very close though :)
01:07:39 <Axman6> yeah
01:07:51 <yitz> Axman6: sounds like a better name would be Variable
01:08:17 <Axman6> makes sense for a fixed point representation with 64 bits representing the fractional part... leaving 1 bits for the whole part...
01:09:06 <yitz> Axman6: I'm pretty sure this stuff worked way back when. perhaps this is some kind of bitrot. or the opposite, recent changed were made that borked something.
01:09:26 <Axman6> i think this is a fairly new package
01:09:53 <yitz> really? lemme see...
01:09:58 <Axman6> http://hackage.haskell.org/package/fixed-point
01:10:07 <Axman6> the first version came out this year
01:10:13 <Axman6> Data.Fixed is older though
01:11:24 <Axman6> oh god... running sum [1..100] :: Fixed E32 Int64 is apparently a bad idea...
01:11:59 <Axman6> um [1..10] :: Fixed E16 Int32 -> -32762.-5 interesting number there...
01:12:06 <Axman6> I might have to report some bugs
01:12:18 <ion> hah
01:13:45 <Axman6> bleh, there's no bug tracker on patch-tag
01:14:37 <Axman6> also, wow, [a..b] for Fixed values does not do what I expected. take 10 [1..10] :: [Fixed E16 Int64] gives [1.0,1.0000152587890625,1.000030517578125,1.0000457763671875,1.00006103515625,1.0000762939453125,1.000091552734375,1.0001068115234375,1.0001220703125,1.0001373291015625]
01:14:53 <Axman6> which makes the result somewhat understandable... but still not fun
01:15:41 <Eliel> well, email to the maintainer then :)
01:15:59 <yitz> weird. you're right, the only thing i found on hackage currently is Jake McArthur's very recent work. but i'm *sure* i saw something like this a few years ago, including something like the E types to indicate precision. maybe it never made it to hackage.
01:17:12 <Axman6> well I've also got a Data.Fixed module installed,not sure which package it comes from
01:17:58 <Subutai> Hi, a general question... what is a good Linux distro to use a a Haskell dev environment?
01:18:16 <Eliel> Ubuntu has worked nicely for me so far.
01:18:33 <Axman6> Arch is quite well supported, i think gentoo is too, i could be wrong
01:18:38 <Axman6> maybe I'm thinking of debian
01:19:05 <woffs> debian too. ubuntu is, maybe, easier to install.
01:20:00 <Subutai> Thanks, I heard there may be some issues with the latest Ubuntu release and the Haskell Platform?
01:20:15 <Subutai> I have Ubuntu already isntalled though so I will give that a try
01:20:37 <Subutai> Maybe Arch too but I always found that a bit difficult to get installed
01:20:44 <Subutai> (especially under a VM)
01:22:09 <Subutai> oh, I found where I saw that: http://www.reddit.com/r/haskell/comments/h1mw4/warning_haskell_platform_package_is_broken_in/
01:24:33 <deteego> using generic programming, what is the easiest way to do something along these lines
01:25:13 <deteego> for every argument in a function, run a function A (obviously inside a monad) and get all the results of A in a tuple
01:26:03 <deteego> and then apply the values in that tuple to a function with that amount of arguments
01:31:38 <deteego> is what I said even possible in haskell?
01:33:12 <c_wraith> do you mean just the liftM* functions?
01:33:27 <c_wraith> (skipping the whole tuple part entirely)
01:33:33 <c_wraith> :t liftM
01:33:33 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:33:36 <c_wraith> :t liftM2
01:33:36 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:33:55 <c_wraith> :t liftM3
01:33:56 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
01:34:15 <c_wraith> etc
01:34:33 <c_wraith> Or applicative, for the cases where there isn't a liftM variant for the arity you want
01:35:05 <c_wraith> :t ?f <$> ?a1 <*> ?a2 <*> ?a3 <*> ?a4 <*> ?a5
01:35:06 <lambdabot> forall a a1 a2 a3 a4 b (f :: * -> *). (?f::a -> a1 -> a2 -> a3 -> a4 -> b, ?a1::f a, Applicative f, ?a2::f a1, ?a3::f a2, ?a4::f a3, ?a5::f a4) => f b
01:35:55 <c_wraith> well, that's confusing output, but it is correct
01:38:33 <absz> How can I force cabal-dev to install something that really ought to install?  I'm getting ""text-0.11.0.7-b33e9bf262da979d332878bba72b1c7e" doesn't exist (use --force to override)", but I can't figure out where to put the "--force".
01:39:13 <absz> "cabal-dev -s packages -- install hashable --force" was my best guess, but no dice (even though that packages *does* exist; I've checked)
01:39:21 <deteego> I think I need to reclarify, I have functions that are in doubles, that have the same number of arguments (of which the number of arguments can vary with different couples, but functions in the same couple have the same number of arguments)
01:39:39 <c_wraith> that doesn't change anything.
01:39:53 <c_wraith> though you *do* need to know how many args there are
01:39:53 <deteego> what I want to do is to take the amount of arguments for one of the functions in that couple (without having to know HOW many arguments in that function)
01:40:04 <c_wraith> tuples aren't polymorphic anyway
01:40:11 <deteego> hmmm
01:40:26 <c_wraith> So you need to know how many elements a tuple has in it to use it
01:40:27 <deteego> we have generics for datatypes but no generics for functions :(
01:40:34 <deteego> yeah I realized that
01:40:50 <deteego> bleh
01:40:57 <deteego> so much boilerplate
01:41:38 <c_wraith> tuples often cause boilerplate
01:41:57 <deteego> c_wraith: so I am guessing there isn't any generic programming for functions?
01:42:11 <c_wraith> @instances Data
01:42:12 <lambdabot> Couldn't find class `Data'. Try @instances-importing
01:42:20 <c_wraith> @instances-importing Data.Data Data
01:42:21 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
01:42:34 <c_wraith> doesn't appear that Data instances are defined for functions.
01:43:17 <c_wraith> From what I know, there would be additional constraints over other types, anyway.  Like needing to provide functions in both directions instead of just one, for the transformations Data.Data provides
01:43:24 <deteego> hmm, I could do it with template programming
01:43:33 <deteego> though it would be ugly
01:43:50 <c_wraith> Could you do whatever it is you're doing with existentials/classes/GADTs?
01:44:54 <c_wraith> Or heck, just moving unexecuted actions around?  sometimes that's sufficient
01:45:40 <deteego> c_wraith: eh I can just do what I wanted to do in template haskell
01:46:11 <c_wraith> I try to avoid TH when possible.  makes build times get ugly
01:46:42 <c_wraith> What is it you're actually trying to do, anyway?
01:47:11 <deteego> c_wraith: im doing a webserver
01:49:09 <deteego> c_wraith: I also need to be efficient
01:50:18 <c_wraith> I mean, what code problem are you trying to solve?  What values do you have, of what types, and what do you want to do with them, that requires polymorphism over tuple sizes?
01:53:39 <jedahu> I have a function, foo :: (Monad m) => Step a m b -> m (Step a m b), which I need to run inside a monad transformer. Any ideas how to lift such a thing?
01:55:30 <c_wraith> jedahu: what's the target lifted type?  (Monad m, MonadTrans t) => Step a (t m) b -> t m (Step a (t m) b) ?
01:55:48 <jedahu> yes
01:55:59 <c_wraith> well, that's the ugliest possibility :)
01:56:44 <jedahu> I'm at a loss as to how to get at the monad inside the Step type
01:57:10 <c_wraith> You'll need both lift and run* (whatever your t wants) to do it
01:58:10 <c_wraith> and...  It really is quite a mess to do that transformation.
01:59:09 <jedahu> I'm writing this instance: (PersistBackend m) => PersistBackend (ReaderT r m)
01:59:24 <jedahu> from here: http://hackage.haskell.org/packages/archive/persistent/0.5.0/doc/html/Database-Persist-Base.html#t:PersistBackend
02:00:06 <jedahu> two of the methods return: Enumerator x m a, which is a synonym for Step a m b -> m (Step a m b)
02:01:35 <c_wraith> Oh, yes.  One of the most mentally fatiguing two-hour periods I ever went through was figuring out how to implement the necessary instances for a custom monad transformer.
02:03:03 <c_wraith> I eventually wrote everything in terms of a pair of functions.  The pair converted back and forth between the transformed and a specialization of the untransformed version that didn't lose any information representation,
02:03:24 <c_wraith> uh.  pretend that word order was correct
02:05:24 <jedahu> hmm. maybe I'll start on it after a good night's sleep then
02:35:22 <absz> Does anyone know anything about cabal-dev?
02:35:30 <absz> Or even just plain cabal-install, probably
02:36:01 <absz> I'm trying to force a module from hackage to install (it can't see a dependency which is clearly there), but I'm having no luck
02:36:40 <aleator> absz: Can you show the error message?
02:36:43 <absz> sure
02:37:00 <absz> "text-0.11.0.7-b33e9bf262da979d332878bba72b1c7e" doesn't exist (use --force to override)
02:37:22 <absz> aleator: (this is from hashable, btw)
02:37:43 <absz> Now, I *know* the package is installed (in fact, installing hashable installs it); I even checked the hash
02:37:47 <aleator> absz: what does ghc-pkg check say?
02:38:06 <absz> I've been using cabal-dev, so I'm not sure how to use ghc-pkg with it
02:38:20 <absz> (this problem doesn't show up outside cabal-dev)
02:39:13 <aleator> Oh. Then it is (I think) ghc-pkg check --package-conf=cabal-dev/packages-7.0.2.conf
02:39:54 <absz> aleator: yep, I just figured that out (only I'm on 6.12.1)—and it reports no problems
02:39:58 <aleator> I get errors like these usually when I've accidentally installed some base library as --user or there is some really conflicting stuff.
02:40:07 <c63> anyone aware of an online haskell editor?
02:40:17 <absz> yeah, I've seen that before for the same reasons, but things are pretty simple here
02:40:30 <aleator> But check usually complains about those..
02:40:39 <absz> aleator: All I've run is `cabal-dev -s packages install hashable`
02:40:42 <luite2> c63: you mean like codepad.org ?
02:40:50 <absz> which installs deepseq and text, and then barfs
02:41:01 <aleator> absz: rm -r cabal-dev; cabal install ?
02:41:17 <aleator> (I've got no clue really.)
02:41:24 <c63> luite2: yeah, but with a lot more editor features, vim like would be awesome :>
02:41:28 <absz> aleator: I have to use cabal-dev, unfortunately; I'm packaging this up for my prof.
02:41:38 <absz> well, do you happen to know how to pass --force?
02:41:45 <absz> aleator: I can't even figure out how to do that
02:41:49 <aleator> Ah. I meant cabal-dev install again with a clean directory.
02:41:57 <absz> aleator: Tried that too, sorry :)
02:43:36 <absz> aleator: My current best guess was `cabal-dev -s packages -- install hashable --force`, but that doesn't do anything (and nor do a number of other permutations)
02:43:44 <luite2> c63: hmm don't know, I'd guess the market for in-browser javascript based vim-like editors isn't very big :p  I'd just use vim and ghci over ssh in such situations
02:44:34 <aleator> absz: Quite weird. cabal-dev install hashable works for me..
02:45:06 <c63> hmm thats sad
02:45:10 <absz> aleator: Yes, and `cabal install hashtable` works for me… it's really very strange.
02:45:14 <c63> dont got my pubkey around
02:45:45 <mekeor> i have a function "f :: a -> b -> c", and a "[a]", and a "[b]". how can i generate a "[c]" now? should i do it "manually" or is there a map-function for this case, too?
02:46:08 <aleator> absz: File as a bug at cabal-dev? Or before that, try updating.
02:46:26 <absz> aleator: I wish I could, but I'm on a college machine :-/  I'll try installing the package manually
02:46:27 <absz> mekeor: There are two ways to do that.  Given
02:47:01 <koeien> :t zipWith2
02:47:01 <lambdabot> Not in scope: `zipWith2'
02:47:03 <mekeor> absz: which? :)
02:47:05 <koeien> :t zipWith
02:47:06 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
02:47:10 <aleator> Well, you can supply --prefix to cabal-dev directory when installing with setup.hs (atleast)
02:47:14 <c63> :t map
02:47:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:47:27 <absz> mekeor: There are two ways to do that.  Given [a1,a2,a3] and [b1,b2,b3], do you want [f a1 b1, f a2 b2, f a3 b3], or do you want [f a1 b1, f a1 b2, f a1 b3, f a2 b1, f a2 b2, f a2 b3, f a3 b1, f a3 b2, f a3 b3]?
02:47:40 <mekeor> all right, thx, i was looking for zipWith, i think; THX
02:47:45 <aleator> absz: /Setup configure --package-db=$p/cabal-dev/packages-7.0.3.conf/ --user --prefix=$p/cabal-dev/
02:47:52 <absz> mekeor: as koeien said, the former is just zipWith f, and the latter is [f a b | a <- as, b <- bs]
02:47:54 <aleator> Probably works with cabal as well.
02:47:56 <mekeor> [first one]
02:48:13 <tensai_cirno> silly question, but how to perform reduce over list? :)
02:48:15 <absz> aleator: ok, that's worth a shot, thanks
02:48:45 <yitz> preflex: seen edwardk
02:48:45 <preflex>  edwardk was last seen on #haskell 10 hours, 45 minutes and 53 seconds ago, saying: gotta run
02:50:22 <koeien> tensai_cirno: foldl or foldr.
02:50:26 <koeien> :t foldr
02:50:27 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:50:35 <koeien> > foldr (*) 1 [1..10]
02:50:36 <lambdabot>   3628800
02:51:17 <c63> > foldr1 (*) [1..10]
02:51:17 <lambdabot>   3628800
02:52:17 <c63> > substract 3 5
02:52:18 <lambdabot>   Not in scope: `substract'
02:52:25 <luite2> subtract
02:52:51 <c63> > subtract 3 5
02:52:52 <lambdabot>   2
02:53:05 <c63> luite2: thanks
02:54:19 <Kaidelong> @info subtract
02:54:19 <lambdabot> subtract
02:54:52 <c63> > 3 `subtract` 5
02:54:53 <lambdabot>   2
02:56:48 <c63> any kewl haskell challanges around to dig deeper?
03:04:10 <rtharper> c63: deeper than..?
03:04:43 <c63> well, im sort of a beginner with basic understanding
03:04:54 <rtharper> c63: IMO the euler problems are a good way to get a feel for Haskell
03:05:16 <rtharper> it's a lot of sort of common problems, many of which have a rather "haskelly" solution
03:06:36 <c63> rtharper: did about 40 of them already using python
03:06:42 <c63> the rest is actually to hard for me :D
03:07:01 <rtharper> c63: ah, well they would look quite different in Haskell, but that might also be boring ;)
03:12:33 <c63> hmm
03:16:07 <c63> > sum [x | x <- [3..1000], x `mod` 3 == 0 || x `mod` 5 == 0]
03:16:08 <lambdabot>   234168
03:32:48 <earthy> c63: the sphere online judge accepts haskell programs
03:33:38 <earthy> and has somewhat more variety in assignments than euler
03:58:15 <crystal-cola> no one is there??
03:58:37 <unfo-> nope. no one.
04:01:28 <crystal-cola> This is what #haskell is like http://www.youtube.com/watch?v=QWJ2e1Re0Lg in the year 3000
04:01:38 <crystal-cola> 20,000 Hardcore Members
04:04:37 <Saizan> crystal-cola: you know, spammy or devoid of content comments are even more annoying when there's no other on-topic activity in the channel
04:04:46 <crystal-cola> ignored
04:05:19 <quicksilver> crystal-cola: unacceptable behaviour followed by unacceptable response. Is it an objective of yours to get banned?
04:05:38 <crystal-cola> my objective is to not get into an argument with someone
04:06:12 <crystal-cola> maybe instead of whining you guys could just not cause a fuss
04:06:21 <quicksilver> OK, well avoid being rude to people who make reasonable complaints about your spammy behaviour.
04:06:34 <quicksilver> or, even better, avoid being spammy in the first place
04:06:43 <crystal-cola> you guys suck
04:07:09 <merijn> Feel free to leave if you dislike people's attempt to keep the signal-to-noise ratio high :)
04:07:23 <crystal-cola> third /ignore
04:09:35 <prljavi_hari> beginner question: what to type in winhugs to get a list of numbers from 1 to 100 which are divisible by 5 ? Something like [1..100] | mod 5 = 0
04:09:47 <crystal-cola> filter ((==0).(`mod`5)) [1..100]
04:10:03 <crystal-cola> [5,10..100] also works
04:10:05 <int-e> [n | n <- [1..100], n `mod` 5 == 0]
04:10:36 <prljavi_hari> thanks
04:17:46 <quicksilver> crystal-cola: Well, consider this a warning. Behaviour like that will get you banned next time.
04:52:16 <roconnor> let k = 1:(zip k (cycle [1,2]) >>= \(l,i) -> repeat l i) in k
04:52:21 <roconnor> > let k = 1:(zip k (cycle [1,2]) >>= \(l,i) -> repeat l i) in k
04:52:22 <lambdabot>   Couldn't match expected type `t1 -> [t]'
04:52:22 <lambdabot>         against inferred type `[a]'
04:52:36 <roconnor> > let k = 1:(zip k (cycle [1,2]) >>= \(l,i) -> replicate l i) in k
04:52:37 <lambdabot>   [1,1,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,2,1,1,2,1,2,2,1,...
04:52:46 <roconnor> > let k = 1:(zip k (cycle [2,1]) >>= \(l,i) -> replicate l i) in k
04:52:47 <lambdabot>   [1,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,2,1,1,2,1,2,2,1,2,...
04:53:33 <crystal-cola> > map ("  #"!!) (let k = 1:(zip k (cycle [2,1]) >>= \(l,i) -> replicate l i) in k)
04:53:34 <lambdabot>   " #  # ## ##  #  ## #  # ##  #  # ## ##  # ## #  #  ## ##  # ## ##  #  # ##...
04:56:45 <roconnor> > let k = 2:(zip k (cycle [1,2]) >>= \(l,i) -> replicate l i) in 1:2:k
04:56:46 <lambdabot>   [1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,2,1,1,2,1,2,2,1,...
04:58:56 <crystal-cola> I don't knowf what this sequence is
04:59:22 <crystal-cola> > (\k -> (zip k (cycle [1,2]) >>= \(l,i) -> replicate l i)) [1..5]
04:59:23 <lambdabot>   [1,2,2,1,1,1,2,2,2,2,1,1,1,1,1]
05:00:22 <int-e> @type uncurry replicate
05:00:23 <lambdabot> forall b. (Int, b) -> [b]
05:00:58 <crystal-cola> 1,2 (fine) 2,1,1 (yes corresponding to the 1,2) 2,1,2,2 ???
05:01:00 <crystal-cola> that doesn't make sense
05:01:08 <crystal-cola> > (\k -> (zip k (cycle [1,2]) >>= \(l,i) -> replicate l i)) [1,2,2,1,1]
05:01:09 <lambdabot>   [1,2,2,1,1,2,1]
05:03:42 <int-e> > let xs = 1:2:2:concat (zipWith replicate (tail xs) (cycle [1,2])) in xs
05:03:43 <lambdabot>   [1,2,2,1,1,2,2,1,2,1,1,2,2,1,2,2,1,2,1,1,2,2,1,2,2,1,1,2,1,1,2,1,2,2,1,1,2,...
05:04:12 <int-e> > let xs = 1:2:2:concat (zipWith replicate (tail xs) (cycle [1,2])) in (take 10 xs, take 10 $ map length $ group xs)
05:04:13 <lambdabot>   ([1,2,2,1,1,2,2,1,2,1],[1,2,2,2,1,1,2,2,1,2])
05:05:29 <int-e> > let xs = 1:2:drop 2 (concat $ zipWith replicate xs (cycle [1,2])) in (take 10 xs, take 10 $ map length $ group xs)
05:05:30 <lambdabot>   ([1,2,2,1,1,2,1,2,2,1],[1,2,2,1,1,2,1,2,2,1])
05:06:20 <crystal-cola> what is this sequence?
05:07:54 <int-e> this one is a sequence of 1s and 2s that results in the same sequence when you look at the run lengths (1 one, 2 twos, 2 ones, 1 two, 1 one, 2 twos, 2 ones, etc.)
05:08:04 <int-e> I'm not sure what the other sequences were
05:08:08 <crystal-cola> ahh I see
05:08:16 <crystal-cola> the sequence express its own run length
05:08:23 <crystal-cola> is it the only one to do so?
05:08:35 <crystal-cola> any tail would also do it?
05:10:37 <int-e> you can drop the first 1. but these are the only two possibilities if you restrict the elements to 1 and 2.
05:15:28 <roconnor> let xs = 1:2:2:concat (zipWith replicate (drop2 xs) (cycle [1,2])) in (take 10 xs)
05:15:35 <roconnor> >
05:15:43 <roconnor> > let xs = 1:2:2:concat (zipWith replicate (drop2 xs) (cycle [1,2])) in (take 10 xs)
05:15:44 <lambdabot>   Not in scope: `drop2'
05:15:52 <roconnor> > let xs = 1:2:2:concat (zipWith replicate (drop 2 xs) (cycle [1,2])) in (take 10 xs)
05:15:53 <lambdabot>   [1,2,2,1,1,2,1,2,2,1]
05:36:35 <joe6> edwardk, i like your "introduction to agda" videos. they are pretty good. good job.
05:38:30 <crystal-cola> didn't he just hold the camera? :)
05:41:25 <Blkt> good day everyone
05:45:33 <Rudi__> Nobody here, IO guess
05:45:44 <Zao> Rudi__: Just us rocks.
05:46:04 <Axman6> nobody here? there's like 600 people in this channe;
05:46:07 <Axman6> l*
05:47:01 <Jafet> fsvo people
05:50:26 <Entroacceptor> we're just thunks waiting to be garbage collected, sorry.
05:50:51 <crystal-cola> omg stop spamming you guys are so annoyin
05:51:14 <frank00> hello: I am trying to compile this http://onthebalcony.wordpress.com/2007/02/19/my-evolution-as-a-haskell-programmer/ and receiving a  `>>>' is not a (visible) method of class `Arrow' . That bit was written in 2007, what should I do to make it work now? I've tried importing Control.Category but to no avail.
05:51:27 <crystal-cola> frank00: import Control.Arrow
05:51:47 <frank00> :S I did it crystal-cola (cheks again)
05:52:09 <frank00> import Control.Arrow <-, yes, there it is. Should I paste the code?
05:52:38 <crystal-cola> that should give you (>>>), it does for me
05:52:57 <crystal-cola> yes it is defined in Control.Category, but Arrow still provides it
05:53:48 <scree> frank00: the problem is you're trying to declare an *instance* for (>>>) under the heading, class Arrow
05:54:08 <scree> frank00: as crystal-cola says, the (>>>) method doesn't live there any more
05:55:39 <scree> frank00: so, you need to factor out that bit as "instance Category SF where (>>>) = ..."
05:55:58 <frank00> great, let's see if category only needs that
05:56:15 <scree> frank00: oh, it needs id as well
05:57:01 <frank00> instance Category SF where      SF f >>> SF g = SF (f >>> g) -- now i need an id istance, right?
05:57:06 <int-e> and it wants you to define (.) [= flip (>>>)] rather than (>>>)
05:57:38 <frank00> gah, that was meant to be a tutorial! (smiles)
05:57:39 <int-e> so SF f . SF g = SF (f . g), I guess.
05:57:49 <scree> frank00: you probably want "id = arr id"
05:58:02 <scree> frank00: or maybe not, I haven't read the context
05:58:56 <int-e> or equaivalently, id = SF id (in this particular case), since  map id = id.
05:59:44 <scree> yes, that would make more sense
06:02:43 <frank00> aaaaaaaaaaand ti works
06:02:52 <frank00> thanks crystal-cola &&& scree
06:03:06 <frank00> *it
06:03:15 <frank00> (and int-e)
06:03:34 <int-e> ah, too late for  http://hpaste.org/46315/arrow  then
06:04:10 <frank00> not really int-e, that hiding solves some more problem (or rather, makes it more elegant)
06:04:34 <frank00> I suppose the class definition changed somewhere between 2007 and 2011, right?
06:04:42 <int-e> yes
06:05:27 <frank00> that was it, thanks again
06:07:42 <int-e> it changed between base-3.0 and base-4.0, which was shipped with ghc 6.10.1, released november 2008.
06:10:54 <dixie> hmm, has anybody running wx application compilation with latest haskell platform & wxhaskell?
06:10:58 <dixie> http://hpaste.org/46316/wxhaskell
06:14:12 <siracusa> dixie: Does that work in GHCi?
06:15:27 <Athas> Wow, linking to regex-tdfa made my executable balloon from 3MiB to 11MiB.
06:15:35 <Athas> Using regex-pcre instead brought it back down.
06:34:44 <dixie> siracusa: I'll try
06:35:15 <dixie> 15:16 < siracusa> dixie: Does that work in GHCi?
06:36:54 <dixie> siracusa: I'm not able to compile my "treeBrowser" application and so I can not load exampleTree program from that "treeBrowser" since it depends on some Modules defined within it.
06:40:30 <dixie> siracusa: I updated the paste with error in GHCi.
06:43:36 <siracusa> dixie: add {-# LANGUAGE TypeSynonymInstances #-} at the very top of your Main module
06:44:43 <dixie> oops :) sorry
06:44:56 <dixie> I was just googling what is the syntax for adding language extensiosn into source code
06:48:14 <dixie> Loading package wxcore-0.12.1.6 ... <interactive>: stdc++: The specified module could not be found.
06:48:17 <dixie> can't load .so/.DLL for: stdc++ (addDLL: could not load DLL)
06:49:03 <nihtml> > sum []
06:49:04 <lambdabot>   0
06:49:07 <nihtml> oh, good
06:49:10 <nihtml> > product []
06:49:11 <lambdabot>   1
06:51:39 <siracusa> dixie: Sorry, I have to go for an hour or so. Quick googling brought me to http://wewantarock.wordpress.com/category/haskell/wxhaskell/, not sure if that helps.
06:52:45 <ion> Why wx? It has the wrong look and especially feel on every OS.
06:53:24 <Kerris> it's consistently wrong :v
06:55:47 <calp> there are degrees of wrongness, cf. Java Swing
06:57:27 <scooty-puff> i'm not sure if it autoposts, but http://hpaste.org/46319/type_families_vs_associated_t
06:57:47 <scooty-puff> is it better to define an associated type in a type class, and not export the type class
06:57:54 <scooty-puff> if you want it closed
06:58:01 <scooty-puff> or to use a type family?
06:59:04 <dixie> siracusa: thanks
06:59:08 <dixie> I will take a look
06:59:37 <dixie> ion: I have already written application which I don't want rewrite to GTK or something because of lack of time :)
07:00:26 <dixie> ion: in later apps I use GTK since I found glade quite easy to use :-)
07:01:20 <ion> For cross-platform software one might even abstract the UI layer so that one can plug in a native UI for a number of systems.
07:03:41 <Xaratas> hi
07:04:27 <Xaratas> i have written this: http://hpaste.org/46321/trie_map and asking me now why i have to do this: str++(fst x):"" in the mapTK call
07:04:42 <Xaratas> str++(fst x) alone does not compile
07:06:43 <scooty-puff> does using a class constraint when the class has an associated type ensure misuse doesn't occur?
07:06:46 <scooty-puff> in the cases i've seen
07:06:52 <scooty-puff> it doesn't, but might be doing it wrong
07:09:52 <yitz> preflex: seen edwardk
07:09:52 <preflex>  edwardk was last seen on #haskell 15 hours, 7 minutes and 6 seconds ago, saying: gotta run
07:10:16 <yitz> scooty-puff: why should it prevent misuse?
07:10:39 <scooty-puff> i.e. a -> b -> Pair a b should really have type PairF a b => a -> b -> Pair a b
07:10:50 <scooty-puff> or maybe that is its type? let me compile..
07:11:40 <yitz> scooty-puff: a class constraint is a requirement that whenever you define an instance of this class for some type, you must also define an instance of the constraint type.
07:11:49 <yitz> scooty-puff: nothing more and nothing less.
07:13:25 <scooty-puff> so not the other way around, when you use the associated type, an instance of the class must not necessarily exist?
07:14:11 <scooty-puff> (this is for use with phantom types)
07:14:13 <quicksilver> you *can't* use the associated type without having an instance in mind
07:14:18 <quicksilver> the type has no meaning
07:14:24 <quicksilver> except in the context of a particular instance
07:15:00 <illissius> do where-clauses have the same only-computed-once property that let-clauses do? is this question meaningless?
07:15:08 <scooty-puff> if if the associated type happens to not have any class that defines that associated type's value, it will not be "reduced" (terminalogy?) by the type system?
07:15:32 <scooty-puff> i guess i mean associated type's actual type
07:15:38 <scooty-puff> so i really mean for type synonyms only
07:16:23 <quicksilver> well, the underlying actual type is just a plain type
07:16:32 <quicksilver> for an associated synonym.
07:16:45 <quicksilver> so nothing stops oyu using the underlying type for whatever purpose you might choose.
07:16:53 <quicksilver> maybe associated data is a better idea if that's what you're trying to do?
07:17:16 <quicksilver> illissius: yes, they do. where and let attach to different bits of syntax but are essentially the same construct.
07:17:47 <illissius> quicksilver: okay, thanks.
07:17:48 <scooty-puff> well, they only exist as phantom type parameters, and if the class constraint really doesn't do anything, at least opens me up to type family syntax (though i guess it would also mean other modules could add instanes, see the Pair example above, that don't make sense)
07:18:17 <scooty-puff> i.e. instance PairF Int Int where Pair Int Int = Double
07:18:27 <quicksilver> scooty-puff: I don't know what you mean by 'the classe constraint doesn't do anything'.
07:18:42 <quicksilver> class constraints generally do something - which class constraint are you talking about?
07:18:44 <scooty-puff> quicksilver, test :: a -> b -> Pair a b is allowed
07:18:48 <scooty-puff> i would assume only:
07:18:55 <scooty-puff> test :: PairF a b => a -> b -> Pair a b
07:18:58 <scooty-puff> would be allowed
07:18:59 <scooty-puff> for:
07:19:06 <scooty-puff> class PairF a b where type Pair a b
07:19:25 <quicksilver> ok. Yes I agree that's odd.
07:19:33 <quicksilver> Are you sure you don't have another 'Pair' in scope?
07:19:46 <Nightwolf> how do i load a file in a path containing spaces in ghci?
07:20:07 <quicksilver> Nightwolf: put the path in quotes I think
07:20:13 <Nightwolf> doesn't work
07:20:38 <scooty-puff> i do not, but can change it to more unique names to be more certain
07:20:47 <Nightwolf> ah
07:20:48 <scooty-puff> is there a preference for hpaste over pastebin?
07:21:00 <Nightwolf> forgot to remove the escaping, quotes work! :-)
07:21:07 <quicksilver> yes, but it doesn't matter, scooty-puff
07:21:19 <scooty-puff> http://hpaste.org/46326/type_families_vs_associated_t
07:21:52 <scooty-puff> hmm, that import will probably worry some, but it only defines empty data decls data Nil and data Cons a b
07:22:55 <quicksilver> scooty-puff: I agree with you - that seems very odd.
07:22:58 <quicksilver> maybe I'm missing something
07:24:11 <scooty-puff> a side question - if i don't export the class, can other modules use it in class constraints?  is there a way to export a class name, but not allow instances of it outside the defining module?
07:24:15 <companion_cube> is there a scooty-puff junior ? :)
07:24:35 <scooty-puff> companion_cube, i'm glad you assumed i'm senior
07:24:47 <companion_cube> :þ
07:24:51 <scooty-puff> companion_cube, because scooty-puff junior sucks..
07:25:44 <Saizan> associated type/data families are just syntactic sugar for standalone ones, and i think it makes most sense this way
07:26:52 <illissius> hmm
07:26:54 <scooty-puff> Saizan, ok, so all i'm really restricting by not exporting the class is for other type family instances to be defined, but not restricting at all the use of that type (or close enough to that anyways)
07:27:17 <illissius> view patterns : views :: functions : lenses = correct?
07:28:24 <quicksilver> Saizan: and although standalone families require instances to be used, that doesn't generate constraints?
07:29:25 <Saizan> scooty-puff: you're not allowing to make an instance of PairF, not sure about Pair
07:30:24 <Saizan> quicksilver: contraints will appear only if you use functions that need them
07:30:38 <Saizan> test :: a -> b -> Pair a b
07:30:39 <Saizan> test x y = (x, y)
07:30:48 <Saizan> this doesn't look well-typed though ^^^
07:31:01 <scooty-puff> Saizan, i prob shouldn't have pasted a compiler failure, but yeah, was just checking for something
07:31:08 <scooty-puff> the only result for that is undefined
07:31:10 <quicksilver> Saizan: well it only typechecks if (Pair a b) ~ (a,b), right?
07:31:16 <Saizan> quicksilver: yep
07:31:23 <quicksilver> Saizan: but I don't see why the compiler accepts it as is...
07:31:39 <Saizan> quicksilver: i don't think it does
07:31:57 <quicksilver> it doesn't? I thought scooty-puff meant that compiled OK.
07:32:07 <scooty-puff> replace (x, y) with undefined
07:32:12 <quicksilver> ah
07:32:21 <scooty-puff> and add data Nil and data Cons a b
07:32:59 <Eduard_Munteanu> This makes me wonder if this Agda stuff is equivalent (more or less):   PairT : Set -> Set -> Set    PairT Int Int = Double
07:32:59 <lambdabot> Eduard_Munteanu: You have 1 new message. '/msg lambdabot @messages' to read it.
07:33:13 <Eduard_Munteanu> Although I can see the family is closed.
07:33:46 <scooty-puff> is there a way to check that a type synonym actually reduces to a real type, if it only exists as a phantom type or bottom value?
07:33:48 <Jafet> Hm, how many generations can we expect S1155 to last?
07:34:05 <Jafet> s/.*// # whoops
07:34:47 <quicksilver> scooty-puff: your question doesn't quite read right. Types are never bottom values. (Types are not values, indeed)
07:34:56 <joelb> Is there some function like this `Either a b -> (a -> c) -> Either c b` or should I just do it manually?
07:35:06 <quicksilver> do you mean to ask if there is any way to check if a particular type is an instance of a family?
07:35:16 <Eduard_Munteanu> (and of course _,_ : \forall {A B : Set} -> A -> B -> PairT A B)
07:37:28 <Eduard_Munteanu> @hoogle bimap
07:37:28 <lambdabot> No results found
07:37:48 <joelb> I was just looking at that
07:38:04 <joelb> I would rather not add Category Extras to my already long list of dependencies though
07:38:08 <siracusa> > right succ (Right 10)
07:38:08 <lambdabot>   Right 11
07:38:25 <scooty-puff> quicksilver, i mean to say is there a way to make sure test :: a -> b -> Pair a b isn't used where no Pair a b actually exists - where PairF a b is not satisfied
07:38:53 <scooty-puff> i assume add the appropriate constraint, and be vigilant about constraint use?
07:39:08 <Eduard_Munteanu> joelb: I don't think there's one in standard packages, but category-extras might have that in terms of bifunctors: http://hackage.haskell.org/packages/archive/category-extras/0.44.4/doc/html/Control-Bifunctor.html
07:39:12 <Eduard_Munteanu> look at bimap
07:39:30 <Saizan> Eduard_Munteanu: you can't pattern match on Set
07:39:31 <Eduard_Munteanu> Basically you're asking for 'bimap' with id as one argument.
07:39:48 <scooty-puff> what i meant earlier was that the only "object" (now i know my terminology is off) of that particular type is bottom
07:40:01 <scooty-puff> is "instance" ambigous?
07:40:07 <scooty-puff> *ambiguous
07:40:34 <Eduard_Munteanu> Saizan: hm? How do you make universes then? I remember something similar from Power of Pi.
07:40:56 <scooty-puff> aaload :: Reference value => m (Pair (A value, I, x), Pair (value, x)) ()
07:41:00 <joelb> Eduard_Munteanu: Thanks for the help, I'll think about whether it's worth it to add that to my dependencies for one combinator.
07:41:12 <Eduard_Munteanu> joelb: probably not
07:41:17 <scooty-puff> in the above, i do not verify that PairF exists for the given types
07:41:23 <joelb> I just saw that it says it's obsolete
07:41:25 <joelb> why is that?
07:41:31 <siracusa> joelb: You can use right from Control.Arrow
07:41:39 <Eduard_Munteanu> joelb: oh, edwardk is splitting category-extras into multiple packages
07:41:41 <ruiwkinox_> hi everyone.
07:41:41 <scooty-puff> (hmm, so i was using a diff Pair definition here)
07:41:46 <ruiwkinox_> i m new to haskell
07:42:12 <siracusa> joelb: No wait, flip left
07:42:14 <illissius> was about to say that sounds like something there would be an arrow combinator for...
07:42:31 <illissius> and I'm pretty sure Bifunctor has been split out into a package by now, not sure which
07:42:31 <joelb> siracusa: perfect
07:42:57 <illissius> http://hackage.haskell.org/package/bifunctors
07:43:06 <illissius> (shockingly)
07:43:48 <Eduard_Munteanu> :t flip left
07:43:49 <lambdabot> forall b c d. Either b d -> (b -> c) -> Either c d
07:43:55 <Eduard_Munteanu> Oh, right.
07:44:22 <joelb> Thanks, guys
07:49:12 <illissius> (hmm, what kind of type system extension would we need (presuming one is possible) to handle Functor, Bifunctor, Trifunctor, etc. in a uniform way? would it be the same one as for handling tuples uniformly?)
07:51:03 <scooty-puff> is there already one for handling tuples uniformly, or do you mean were one to exist, they would both be the same?
07:51:16 <scooty-puff> when it gets too bad i end up resorting to template haskell
07:51:36 <scooty-puff> but not really applicable to what you've been talking about..
07:53:33 <quicksilver> well, HList is (among other things) a way to handle tuples uniformly
07:53:38 <Eduard_Munteanu> Maybe sigma types.
07:54:04 <crystal-cola> illissius: well you could just make a product category
07:54:11 <crystal-cola> and define functors over arbitrary categories
07:54:36 <illissius> hmm
07:54:43 <Eduard_Munteanu> Which also amount to existentials used in HList and similar stuff.
07:55:15 <illissius> quicksilver: well, I mean Haskell's existing, don't-bear-any-relation-to-each-other-beyond-the-syntax tuples.
07:55:56 <quicksilver> illissius: sure, but HList shows one direction you can go to handle them uniformly.
07:56:28 <quicksilver> after all, data HCons e l = HCons e l is exactly the same as data (,) a b = (,) a b.
07:56:37 <quicksilver> the elaborations come after.
07:57:17 <illissius> quicksilver: right, I know :)
07:58:21 <illissius> I guess my question was more directed towards, "what kind of type system feature would we need to be able to abstract over the number of type variables in $thing"
07:58:31 <illissius> hmm... am I thinking of kind polymorphism?
07:59:12 <illissius> crystal-cola: do you mean something that could be written in haskell/ghc today? how would it look?
07:59:48 <crystal-cola> yes you don't need anything special to do that, it's just typeclasses. There are other ways (e.g. clever tricks with GADTs) to do this stuff, kind polymorphism is another approach but that's the first example of one that we can't do in haskell./
08:06:07 <Saizan> Eduard_Munteanu: you make a datatype for codes of your types and a decoding function, so that you can then pattern match on the codes
08:11:10 <Eduard_Munteanu> Saizan: ah I was just going through Power of Pi again, sounds like that. Also non-canonical implicits might help.
08:11:15 * Eduard_Munteanu needs to update Agda.
08:11:29 <Eduard_Munteanu> THanks.
08:23:05 <helino> hello everyone! I have a question about type classes. Lets say I have a: "class Additive a where (+): a -> a -> a". If any type instances Additive, there will be a conflict between Prelude.+ and the + of Additive. How does one solve this?
08:23:48 <helino> I doesn't feel right typing Prelude.+ or Additive.+ whenever I want to differentiate them...
08:23:54 <zygoloid> helino: the same way one solves any naming conflict :)
08:24:12 <zygoloid> rename one of them, or use a qualified name, or hide one of them
08:24:13 <helino> zygoloid: so typing Prelude.+ or Additive.+?
08:24:20 <crystal-cola> import qualified Prelude then you can just use your own except in the small number of cases where you need to access P.+
08:24:50 <helino> crystal-cola: is this the "standard way" of solving this?
08:24:59 <helino> zygoloid: thanks!
08:25:03 <crystal-cola> no clue
08:25:39 <helino> ok, I'm just looking for some kind of best practices :)
08:26:06 <crystal-cola> I just do what works
08:28:06 <helino> crystal-cola: ok, thanks for your help!
08:31:47 <Eduard_Munteanu> helino: you can 'import Prelude hiding (+)'
08:32:12 <ben> Is that enough parentheses?
08:32:21 <Eduard_Munteanu> Hrm, no :)
08:32:41 <Eduard_Munteanu> I forget.
08:34:05 <helino> Eduard_Munteanu: ah ok, that seems to be the best solution
08:39:27 <helino> works perfect now, thanks everyone for your help!
08:40:08 <imladris> Starting to wonder if Haskell dislikes me personally... Lots of "the impossible happened" from ghci today. Also, Repa just gave me "*** Exception: Data.Array.Repa.interleave2: this never happens :P"
08:44:19 <DevHC> imladris: is ":P" really part of the exception description?
08:44:27 <imladris> Yes. :)
08:44:40 <DevHC> ghci is trolling u
08:44:52 <monochrom> > error "this should not happen LOL"
08:44:53 <lambdabot>   *Exception: this should not happen LOL
08:45:00 <imladris> I think that was an error message from Repa, though.
08:45:08 <aristid> > error "monochrom error"
08:45:09 <lambdabot>   *Exception: monochrom error
08:45:29 <NihilistDandy> >error "proves the rule"
08:45:36 <NihilistDandy> > error "proves the rule"
08:45:37 <lambdabot>   *Exception: proves the rule
08:45:49 <ben> http://hackage.haskell.org/packages/archive/repa/latest/doc/html/src/Data-Array-Repa-Operators-Interleave.html#interleave2
08:46:07 <imladris> And there ghci panics again. I give up. It asks me to report it, but it feels like it's randomly crashing. Can I find the stack trace of the crashed process somewhere, to attach to the bug (Win7, ghci under cygwin)?
08:49:42 <ruiwkinox_> sorry, is haskell suitable for large web application ?
08:49:52 <Zao> Quite possibly.
08:49:56 <nihtml> it can
08:52:00 <ruiwkinox_> or, anyone have better suggestion ?
08:52:41 <monochrom> not sure what is better than the affirmative "yes". maybe you want to hear "no" instead?
08:53:03 <fryguybob> imladris: You might be running into this issue: http://hackage.haskell.org/trac/ghc/ticket/4245
08:53:08 <crespo> hello, could You help me please?
08:53:09 <Jafet> @faq can Haskell be used for large web applications?
08:53:10 <lambdabot> The answer is: Yes! Haskell can do that.
08:53:54 <crespo> I have got 4 exercises for tommorow classes and I don't know hot to solve them. I don't wanna spoon-feeding, I'm just need some advice, what should I read about Haskell to solve that: http://pastebin.com/ercLxEpk
08:54:31 <fryguybob> imladris: (Specifically hitting Ctrl-C leads to the panic)
08:56:59 <Entroacceptor> crespo: for 1, 3 and 4 you just need to read the excercise
08:57:33 <Entroacceptor> especially 1 and 3 are just math
08:58:01 <crespo> I was tottaly newbie in Haskell, it was the first lesson and I was ill (I didn't hear what teacher said...)
08:58:10 <crespo> That's why I'm not sure how to start with
08:58:13 <Entroacceptor> ah
08:58:28 <Entroacceptor> then skim over http://learnyouahaskell.com/ :)
08:59:02 <crespo> I was trying to read something in Haskell - I've done lessons from http://tryhaskell.org/ and read about Haskell in Haskell wiki
08:59:12 <crespo> but there were no stuff like that
08:59:22 <Entroacceptor> the first two chapters of lyah should be what you need
08:59:27 <Entroacceptor> erm, 3
09:00:36 <crespo> I'm not sure what is flip and curry
09:00:50 <Entroacceptor> it's right there, line 4
09:00:56 <ben> Their definitions are given in your problem statement.
09:01:02 <Entroacceptor> flip f a b is the same as f b a
09:01:20 <Entroacceptor> and you just need to know that f a b is function f applied with arguments a and b
09:01:26 <Entroacceptor> in C that would be f(a,b);#
09:01:51 <Entroacceptor> so flip is a function that takes a function and two arguments
09:02:17 <crespo> so if I typr flip f a b I mean f b a ?
09:02:25 <Entroacceptor> yes
09:03:45 <ben> What is the notation "f :: (a,b) ! c"?
09:03:48 <ben> Is ! class-speak for ->?
09:04:37 <crespo> so what does (f . swap) mean? from definition it's (f . g) x = f (g x) , so there are three things there
09:04:49 <saati> ! is strict eval if i am not mistaken
09:05:03 <Entroacceptor> saati: not in this case, I'd bet
09:05:14 <saati> oh
09:05:17 <ben> crespo: (f . g) x = ... defines '.', not f
09:05:18 <Entroacceptor> probably just convertion error
09:05:29 <monochrom> god, must I create an account to add a paste on pastebin.com? stupid website
09:05:41 <siracusa> crespo: It means first apply function swap, then f
09:05:50 <ben> monochrom: I am sure I pasted before withotu an account
09:06:43 <crespo> ben, but it defines it as f, g and x, so three things
09:07:20 <monochrom> yeah alright works
09:07:27 <ben> crespo: All three show up on the left sign of the =, so they're parameters
09:07:31 <monochrom> crespo: http://pastebin.com/8sKETgpV  expires in a day
09:08:36 <monochrom> also yes it's a full solution because there is no way I can efficiently "hint" you to do the same thing. but I have only solved the first question. this is how you start the other questions
09:09:10 <crespo> monochrom, thanks, please gimmie a few minutes to understand that
09:10:27 <Xaratas> re, there were too much students in the room, wlan signal gone a way
09:10:54 <Xaratas> i have written this: http://hpaste.org/46321/trie_map and asking me now why i have to do this: str++(fst x):"" in the mapTK call,  str++(fst x) alone does not compile
09:12:08 <ben> :t (:)
09:12:09 <lambdabot> forall a. a -> [a] -> [a]
09:12:14 <crespo> monochrom, is it ok to add parametrs x and y as you did in line 9? Can I do it in any example?
09:12:17 <ben> :t 'a'
09:12:18 <lambdabot> Char
09:12:20 <ben> :t 'a':""
09:12:21 <lambdabot> [Char]
09:13:29 <rostayob> what was the name of that game they're coding in haskell?
09:13:30 <Entroacceptor> crespo: that's because of line 6
09:13:32 <rostayob> the platform
09:13:47 <aristid> :t liftM2 (:)
09:13:49 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
09:14:53 <crespo> Entroacceptor, why both sides have the same type, 'cos there are equal?
09:15:39 <monochrom> you can carefully infer types and find they have the same type, or at least they can be compatible
09:16:20 <voker57> How to create a static library with GHC, one that can be linked with C code without linking to Haskell libs? I'm trying -shared -o lib.o, but getting undefined reference to main.
09:16:32 <voker57> -static -lib.o, sorry
09:16:42 <crespo> monochrom, I don't understand that, I mean how can I be 100% sure, that this has got the same type
09:17:02 <DevHC> rostayob: r u talking about bloodknight @ www.ipwnstudios.com ?
09:17:13 <monochrom> when you infer types you also have a proof if you do it right
09:17:31 <Xaratas> ok, i got it
09:19:01 <crespo> ok, I got it, thanks
09:19:08 <crespo> i'll try to solve ex. 3 myself
09:19:46 <monochrom> crespo: in fact the only reason I had to mention types is to make sure I can add 2 parameters x and y, that is all
09:20:25 <Xaratas> ok, simple question: how to add a char to the end of a string?
09:20:51 <crespo> so what if types weren't the same, what would you do in that case?
09:21:11 <monochrom> if types weren't the same, the question would be wrong, I would file a bug report
09:22:25 <crespo> ok, so in excercise 3 I should add one parametr to use the definition of . right?
09:22:59 <monochrom> yeah, that helps
09:23:38 <crespo> should I transform only one side and try to get the second side?
09:23:44 <crespo> or both at the same time?
09:24:21 <monochrom> more likely transform one side to something you like, transform the other side and find that it's something you like again
09:24:47 <monochrom> i.e., lhs = ... = e; rhs = ... = e  "w00t they're the same e!"
09:26:50 <byorgey> Xaratas: string ++ [c]
09:27:12 <byorgey> Xaratas: however, if you find yourself doing this a lot, you may want to reconsider your approach and/or data structures
09:27:21 <byorgey> since it has to traverse the entire string to reach the end.
09:27:56 <Xaratas> i know, thougth there where a better way
09:29:59 <crespo> could You please check the first 3 infers? http://pastebin.com/28yGNA0f
09:30:17 <crespo> I'm not sure if I can do something like that
09:34:44 <crespo> ok, I will spend much more time myself on that excercise, 'cos I see how to solve it, please give me some hints to excercise 2, 'cos it looks like different than 1, 3, right?
09:38:57 <rostayob> DevHC: no, I was talking about nikki and the robots, found it in the end!
09:47:38 <crespo> btw, how should I treat parantheses? I mean could I put them anywhere I want?
09:48:38 <crespo> 'cos if (f . g) x = f (g x) then can i say that f . g x is f (g x)  ?
09:49:02 <ben> No, you need them there
09:49:25 <DevHC> rostayob: "the" game in haskell...
09:49:46 <ben> f . g x is the same as f . (g x), not (f . g) x unfortunately
09:50:49 <crespo> so what in my example is the definition of that : cross (f,g) . cross (h,k)
09:50:57 <crespo> there is the dot between but no parantheses
09:51:23 <ben> You're free to add parentheses there if you want.,
09:51:39 <crespo> if (f . g) x = f (g x)  could I add one parametr to the f . g, and makes (f.g) x?
09:53:11 <crespo> I mean sometginh like that: http://pastebin.com/EEgnn2rd
09:53:16 <crespo> *something
09:54:03 <crespo> and another equestion, if I can add a parametr, than I mean that types of the left and right side are equal, shouldn't I proove this first?
09:54:45 <crespo> I mean, I have to prove, that left side = right side, so left-side type = right-side type
09:55:25 <crespo> but I've already said that left-side type = right-side type by adding one parametr
09:55:54 <crespo> I'm right, aren't I?
10:08:30 <dncr> anyone tried hs backend / haxe frontend?
10:11:41 <amstan> hello, i'm looking to get haskell for a contest
10:12:00 <amstan> i'm currently running ubuntu natty, and i understand it's broken or something in there
10:12:23 <amstan> what's the most popular version of haskell, and which one is the easiest to install on ubuntu natty
10:12:31 <amstan> i would prefer something like a ppa
10:12:45 <byorgey> @where platform
10:12:46 <lambdabot> http://hackage.haskell.org/platform/
10:12:54 <byorgey> amstan: try that
10:23:09 <amstan> sigh...  haskell-platform : Depends: ghc6 (< 6.12.1+) but 6.12.3-1ubuntu7 is to be installed
10:23:26 <amstan> anybody have a ppa, or do i really have to do source?
10:23:45 <ArnoVanLumig> amstan: the only way seems to be to build from source
10:23:52 <ArnoVanLumig> which isn't as hard as it sounds, really
10:24:12 <amstan> the thing is that we want to support about 10 languages, we can't afford to install each one of them from source
10:24:53 <Zao> amstan: Use a newer HP?
10:25:16 <aristid> Zao: he's complaining there are no binary packages for a new HP
10:25:19 <Zao> Well, I guess that might be what you're trying to do.
10:25:22 <Zao> Silly distro :D
10:25:30 <aristid> amstan: debian sid seems to have recent packages. no idea if you can use them
10:31:06 <Geralt> Hi, why do I get a parse error on 'data List = Nil | Test' in ghci?
10:32:12 <aristid> Geralt: you can only declare new types in .hs files
10:32:24 <Geralt> aristid: ah, thanks :-)
10:37:30 <b52> whats a good heap data structure?
10:38:06 <aristid> b52: edwardk made the heaps package.
10:38:09 <aristid> @hackage heaps
10:38:10 <lambdabot> http://hackage.haskell.org/package/heaps
10:40:47 <b52> well, im not sure how to store my data, its a custom data type which for i generate a score which i want to use for sorting
10:40:55 <b52> but im not sure how to do so
10:43:18 <aristid> b52: you need an Ord instance on your custom data type, which uses that score.
10:43:37 <aristid> roughly like this: instance Ord MyType where compare a b = compare (score a) (score b)
10:44:00 <b52> ok, ill try that
10:44:12 <aristid> b52: then you can use edwardk's Heap, or any other sorted data structure :)
10:46:35 <b52> ok thanks
10:50:42 * hackagebot curl 1.3.7 - Haskell binding to libcurl  http://hackage.haskell.org/package/curl-1.3.7 (DonaldStewart)
11:00:44 * hackagebot dropsolve 0.1.1 - A command line tool for resolving dropbox conflicts.  http://hackage.haskell.org/package/dropsolve-0.1.1 (DanielTrstenjak)
11:06:15 <boegel> is there a way to define a type class that "uses" two types, e.g. "class Type1 a, Type2 b where ..."
11:06:40 <boegel> I need to define a generic family of functions that only make sense for a pair of types...
11:06:49 <monochrom> wouldn't that be multiple parameter type class? class MonadState m s where...
11:09:02 <shamster> :t mapM
11:09:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:09:06 <shamster> :t putStrLn
11:09:07 <lambdabot> String -> IO ()
11:09:15 <boegel> monochrom: I think it is...
11:09:31 <boegel> monochrom: does that require some extention (-X...)?
11:09:44 <shamster> :t mapM . putStrLn
11:09:45 <lambdabot>     Couldn't match expected type `a -> m b'
11:09:45 <lambdabot>            against inferred type `IO ()'
11:09:45 <lambdabot>     Probable cause: `putStrLn' is applied to too many arguments
11:10:40 <shamster> why does mapM . putStrLn not work?
11:10:50 <mauke> what did you expect it to do?
11:11:00 <aristid> :t mapM . putStrLn
11:11:01 <lambdabot>     Couldn't match expected type `a -> m b'
11:11:01 <lambdabot>            against inferred type `IO ()'
11:11:01 <lambdabot>     Probable cause: `putStrLn' is applied to too many arguments
11:11:06 <mauke> aristid--
11:11:06 <shamster> I expected it to do something like :: [String] -> IO ()
11:11:14 <aristid> mauke: sorry
11:11:14 <mauke> shamster: why?
11:11:22 <shamster> well...
11:11:25 <shamster> :t putStrLn
11:11:25 <lambdabot> String -> IO ()
11:11:34 <shamster> and if I map that...
11:11:37 <shamster> :t mapM
11:11:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:11:44 <hpc> :t sequence_ putStrLn
11:11:44 <mauke> shamster: but you didn't map that
11:11:44 <lambdabot>     Couldn't match expected type `[m a]'
11:11:44 <lambdabot>            against inferred type `String -> IO ()'
11:11:44 <lambdabot>     In the first argument of `sequence_', namely `putStrLn'
11:11:53 <hpc> :t mapM_ putStrLn
11:11:54 <lambdabot> [String] -> IO ()
11:11:56 <shamster> mapM doesn't map that?
11:12:04 <mauke> shamster: mapM does, but you called . instead
11:12:12 <shamster> oh... hah! thanks :)
11:12:21 <shamster> :t mapM putStrLn
11:12:22 <hpc> :t (mapM .)
11:12:22 <lambdabot> [String] -> IO [()]
11:12:22 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Monad m, Functor f) => f (a -> m b) -> f ([a] -> m [b])
11:12:35 <hpc> :t (sequence .)
11:12:36 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f) => f [m a] -> f (m [a])
11:12:58 <shamster> what's the usual way to print out each line of a [String] ?
11:13:17 <mauke> :t putStr . unlines
11:13:18 <lambdabot> [String] -> IO ()
11:13:47 <mauke> :t sequence_ . putStrLn
11:13:48 <lambdabot>     Couldn't match expected type `[m a]' against inferred type `IO ()'
11:13:48 <lambdabot>       Expected type: String -> [m a]
11:13:48 <lambdabot>       Inferred type: String -> IO ()
11:13:49 <shamster> mauke: does unlines have overhead above or beyond mapping a print to each String?
11:14:16 <mauke> shamster: dunno, try both and compare?
11:15:08 <monochrom> boegel: the extension is MultiParamTypeClasses
11:15:17 <aristid> mauke-- for trying sequence_ . putStrLn (revenge :P)
11:15:50 <mauke> did someone already do that?
11:16:06 <mauke> :t sequence_ (putStrLn .)
11:16:07 <lambdabot>     Couldn't match expected type `[m a]'
11:16:07 <lambdabot>            against inferred type `f String -> f (IO ())'
11:16:07 <lambdabot>     In the first argument of `sequence_', namely `(putStrLn .)'
11:16:31 <aristid> mauke: no, but it should have been obvious to you that it doesn't work :P
11:16:43 <mauke> aww
11:17:05 <mauke> one more . and it would work
11:17:23 <aristid> huh?
11:17:35 <pmetzger> trying to build some intuition for the "behind the scenes" of the IO monad, can someone correct me if I'm wrong on the following: conceptually, an object of IO () is returned by main and specifies what sort of I/O is to be performed, and (conceptually) the run time that called main somehow magically goes on to perform the I/O.
11:17:40 <aristid> mauke: from where do you get the list that sequence_ wants?
11:17:54 <mauke> :t sequence_ . (putStrLn .)
11:17:55 <lambdabot> [String] -> IO ()
11:18:06 <aristid> that only works in Caleskell!
11:18:17 <aristid> :t sequence_ Prelude.. (putStrLn Prelude..)
11:18:18 <lambdabot>     Couldn't match expected type `[m a]'
11:18:19 <lambdabot>            against inferred type `a1 -> IO ()'
11:18:19 <lambdabot>     In the second argument of `(GHC.Base..)', namely
11:18:22 <mauke> pmetzger: that matches my model of Stuff™
11:18:40 <pmetzger> okay, cool. I'm slowly starting to build intuition instead of just doing things cargo-cult style.
11:19:09 <mauke> except main is actually a constant so it doesn't "return"
11:19:32 <pmetzger> I thought its return type was IO ()
11:19:47 <pmetzger> I don't mean "return" the function...
11:19:49 <aristid> pmetzger: it's a value
11:19:52 <aristid> not a function
11:19:53 <mauke> pmetzger: no, that's its type
11:20:09 <pmetzger> okay, I'm now confused again. expand?
11:20:17 <aristid> functions: a -> b
11:20:18 <mauke> ... huh?
11:20:19 <aristid> values: a
11:20:28 <mauke> aristid: functions are values
11:20:32 <pmetzger> oh, yes. main doesn't take anything, does it.
11:20:33 <aristid> mauke: as i said.
11:20:37 <pmetzger> it just *is* an IO ()
11:20:44 <mauke> aristid: ok :-)
11:20:45 <pmetzger> weirdly, that never struck me before.
11:20:55 <mauke> pmetzger: just like getChar
11:21:25 <pmetzger> so, wait, are there any other things that "contain code" that are just values?
11:21:37 <mauke> all of them
11:21:48 <pmetzger> I mean that have a type that doesn't have an arrow in it.
11:21:56 <pmetzger> arrow -> not category theory arrow
11:21:57 <mauke> depends on your definition of "contain code"
11:22:11 <pmetzger> mauke: I'm a newb. I don't know how to define it cleanly. :)
11:22:16 <hpc> pmetzger: though in haskell, Arrow implies containing (->)
11:22:20 <hpc> because of arr
11:23:11 <pmetzger> hrm. I guess I could construct any arbitrary constant by specifying "foo :: Int" or what have you and then describing an elaborate computation to do it.
11:23:22 <pmetzger> and in theory this is no different from what main is doing in being an IO ()
11:23:40 <pmetzger> (pardon my reasoning it out aloud, I'm looking for people to correct my mental errors.)
11:23:41 <hpc> pmetzger: you would have to unsafePerformIO in there somewhere though
11:23:51 <mauke> can we ignore unsafePerformIO?
11:24:03 <hpc> not if we want to compare Int to IO ()
11:24:08 <mauke> I disagree
11:24:11 <pmetzger> I'm trying to ignore that for now if I can. I want to grok the model...
11:24:23 <pmetzger> IO () is just a value, it happens to be magic but the model doesn't know that, yes?
11:24:25 <mauke> yeah, let's build the model first before we start destroying it
11:24:29 <boegel> monochrom: multi parameter type class works out fine, thanks!
11:24:43 <pmetzger> the compiler knows that, we the humans know that, but the model says IO () is just another type, yes?
11:24:52 <mauke> pmetzger: I don't think IO is all that special
11:24:54 <aristid> pmetzger: ezyang has written some blog posts about haskell's evaluation model
11:25:06 <pmetzger> so main is just a constant in some sense.
11:25:13 <mauke> yeah
11:25:18 <pmetzger> as is anything else that is simply IO () like getChar
11:25:22 <aristid> pmetzger: http://blog.ezyang.com/2011/04/the-haskell-heap/
11:25:49 <pmetzger> er, I guess getChar must be IO Char
11:25:53 <pmetzger> but same principle.
11:26:41 <aristid> pmetzger: the IO value is unpacked lazily as the program's actions are performed. :)
11:26:53 <pmetzger> and so in principle, main is a value (not a function) that the run time asks for in order to get the show on the road.
11:27:26 <pmetzger> and because of lazy evaluation, performing the resulting IO () causes the program to do what it does.
11:27:28 <dschoepe> When trying to compile utf8-light (with or without using cabal-install), I get these errors (with ghc-6.12.1): http://hpaste.org/46332/utf8light_errors
11:27:35 <appamatto> Are there any other popular pure programming languages?
11:27:44 <Accidus> It's because in Haskell everything is a value!
11:27:50 <EvanCarroll> appamatto: no.
11:27:50 <lambdabot> EvanCarroll: You have 1 new message. '/msg lambdabot @messages' to read it.
11:27:55 <Accidus> (as in any lazy language)
11:28:01 <EvanCarroll> wtf is that.
11:28:10 <EvanCarroll> Accidus: lazy has nothing to do with pure.
11:28:20 <Accidus> Who mentioned pure?
11:28:24 <EvanCarroll> Accidus: lazy is an evaluation strategy, pure is no permitting side effects.
11:28:30 <EvanCarroll> 13:30 < appamatto> Are there any other popular pure programming languages?
11:28:35 <EvanCarroll> 13:31 < lambdabot> EvanCarroll: You have 1 new message. '/msg lambdabot @messages' to read it.
11:28:50 <EvanCarroll> what is that in reference too, someone should integrate lambdabot with memoserv so we know about thist stuff
11:29:07 <pmetzger> okay, so conceptually, our whole program is necessarily wrapped up in the creation of a value of IO ().
11:29:13 <pmetzger> this makes a lot of things make more sense.
11:29:15 <mauke> pmetzger: I don't think this is about laziness
11:29:24 <mauke> pmetzger: you could do the same thing in a strict language
11:29:28 <pmetzger> mauke: sure.
11:29:31 <Accidus> EvanCarroll, huh? In haskell everything is a value because it is lazy
11:29:38 <pmetzger> mauke: I was being overspecific I suppose.
11:29:49 <mauke> pmetzger: have you seen http://mauke.dyndns.org/stuff/haskell/how-to-io.html ?
11:29:54 <pmetzger> nope.
11:29:59 <pmetzger> should I look at it now?
11:30:02 <mauke> yes
11:30:18 <Accidus> But I think I was wrong anyway
11:30:49 <pmetzger> mauke: well written!
11:31:01 <pmetzger> mauke: but I think a week ago I would not have understood what you meant so well. :(
11:31:40 <mauke> welcome to the other side of the looking glass :-)
11:31:55 <EvanCarroll> Accidus: what do you mean by that? that all epxressions are thunks?
11:32:06 <Accidus> Aye
11:32:22 <EvanCarroll> so what... that has nothing to do with purity though.
11:33:05 <Accidus> I never said anything about purity. Only about values
11:33:33 <hpc> appamatto was the first to mention purity
11:33:54 <EvanCarroll> ah, well if I'm not talking about values, and you're not talking about lazyness, then i've found the problem.
11:34:06 <pmetzger> mauke: I'm still trying to see if I agree that the pure functional approach (as opposed to the mixed world of ML or what have you) is truly superior, but I think I won't get a good sense of that until I've completed some large programs in the paradigm.
11:34:28 <mauke> pmetzger: I don't know it it's superior
11:34:35 <mauke> I enjoy both Haskell and Perl
11:34:49 <pmetzger> I'm not much of a fan of Perl, though I've written huge systems in Perl. :(
11:34:57 <pmetzger> (It was the pragmatic choice at the time.)
11:35:15 <mauke> sometimes I think Perl is just misunderstood
11:35:18 <hpc> i prefer perl to haskell for stringy stuff
11:35:36 <hpc> for all the power haskell otherwise has, strings can sometimes be really tedious
11:36:07 <Accidus> Yes, that's what I said earlier
11:36:07 <Accidus> Hmm... I should really get back to cogwheels
11:36:15 <appamatto> I was curious about whether or not there was a pure language for the JVM
11:38:48 <hpc> appamatto: a subset of clojure is pure, i think
11:39:44 <dons> hpc: i'm not sure that's true, given there's no static distinction between pure and impure code
11:40:04 <dons> maybe, "pure by convention" ?
11:40:11 <dons> hopefully
11:41:43 <appamatto> hmmm, I thought there would be other pure languages, at least in research
11:42:51 <dons> there are. e.g. Clean, many many Haskell variants, Agda, etc.
11:43:25 * boegel waves at dons
11:44:16 * edwardk waves hello.
11:45:12 <pmetzger> The largest single problem with Perl, IMHO, is the fact that there are no formal parameters to functions, you have to invent that yourself from the array passed in to the function.
11:45:27 <pmetzger> Not to say that is the sole problem with perl -- it has a large number -- but that is the single most irritating one to me.
11:45:28 <dons> hey guys
11:45:32 <Veinor> "but prototypes!"
11:46:08 <hpc> dons: yeah, i meant pure by convention; the impure stuff generally ends with '!', like set!
11:46:29 <bos> dons: will the bank gig affect your ability to do open sourcey stuff?
11:46:29 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
11:47:35 <pmetzger> hrm. now that I'm understanding this better, it seems a little... peculiar that something like getChar is a constant IO ()
11:47:35 <dons> bos: i've been assured there'll be no constraints on my extra-curricula hacking, as for ndm or lennart. time might be more of an issue, and irc during 9-5 hours...
11:47:48 <bos> dons: yeah
11:47:51 <pmetzger> er IO Char
11:48:08 <pmetzger> because that would sort of mean, in my mind, that it always returned the *same* IO Char, which it doesn't.
11:48:21 <pmetzger> There is sort of an implicit parameter to main, getChar, etc. which is the state of the universe.
11:48:21 <bos> dons: looking forward to the change?
11:48:37 <pmetzger> kind of a shame it isn't explicitly mentioned, though I suppose it is sort of useless.
11:48:56 <dons> bos: very much so. should be lots of fun! nyc, singapore, mucho hacking, manhattan, haskell. :)
11:49:31 <bos> lennart's been very slow to open a san francisco office for me. shame.
11:49:32 <dons> get nycfp going again
11:49:34 <dons> heh
11:49:53 <dons> i get to hang out with sclv for beers.
11:49:58 * dons -> lunch. bbl
11:50:33 <edwardk> dons: he is more of a martini guy =)
11:50:56 <pmetzger> Or do I have that idea correct? Perhaps it is better to think of the "state of the universe" as the parameter to the code that gets the IO () from main....
11:51:43 <edwardk> pmetzger: you can always look at the type of an IO action as a hint. newtype IO a = State# RealWorld -> (# State# RealWorld, a #)
11:52:13 <bos> does anyone have a good scheme for looking up haddocks from an editor?
11:52:14 <edwardk> pmetzger: an IO action takes 'the world' and returns a new world (in which something happened!) and an answer. obviously that is a bit of a pleasant fiction
11:52:27 <bos> i find myself bouncing into chrome and typing stuff by hand all the time, and it's a pain
11:52:36 <edwardk> er newtype IO a = IO (...)
11:53:24 <edwardk> haskellmode for vim has some haddock support
11:54:09 <mauke> pmetzger: it does always "return" the same IO Char
11:54:15 <mauke> except s/return/is/
11:54:30 <mauke> 'IO Char' is a program that reads a char, and it's always the same one
11:54:35 <pmetzger> but that IO Char does different things at different times when it is run.
11:54:37 <pmetzger> okay, yah.
11:54:57 <pmetzger> so really, it isn't that main or getChar have an implicit argument, it is that the thing that executes the IO () has an implicit argument, the world's state.
11:55:28 <pmetzger> in certain ways, haskell reminds me of the many worlds interpretation of QM.
11:55:40 <pmetzger> nothing ever actually happens, you just follow the functions all the way.... :)
11:56:17 <edwardk> pmetzger: yes, the fact that no io actions give you two different State# RealWorlds is how you are kept from backtracking to previous worldstates and violating causality
11:57:06 <pmetzger> I meant more that in many-worlds, there are no observations (wave function collapses) that "mutate" the state of the universe.
11:57:37 <pmetzger> the universe is just a giant honking wave function that happens to superpose all the many worlds.
11:58:30 <pmetzger> if you followed the copenhagen interpretation, you are left with a reductio ad absurdum of sorts -- I observe Schroedinger's cat, putting me in a superposition state. Then someone observes me, putting them in a superposition state...
11:58:47 <pmetzger> so when does the wave function actually collapse? there is no one "outside the universe" to observe it and cause the final collapse.
11:59:00 <pmetzger> but M-W does not demand such a thing, it says there is no collapse at all.
11:59:44 <pmetzger> in some sense, perhaps, the thing that actually executes the IO actions implied by main is the "outside observer".
12:00:51 <pmetzger> mauke: thanks for "how to do I/O", it crystallized what I was thinking.
12:01:00 <edwardk> pmetzger: yeah. just think of the main pulling you into the wave function then... and hope your computer doesn't crash ;)
12:01:11 <Veinor> 'the monad has  you'
12:01:37 <edwardk> great, now we know what the sequel to 'source code' will be called ;)
12:04:32 <jonkri> is it possible to have a chan like "Chan (InternalEvent s)" and allow it to receive different kind of types "s" somehow?
12:04:53 <jonkri> one channel should be able to receive different types
12:05:15 <b52> http://hpaste.org/46334/scope ?
12:05:58 <siracusa> b52: Yes
12:06:40 <mrsolo> learn you a haskell for great good makes monads almost...logical!
12:06:48 <mrsolo> haskell needs more books like that
12:07:01 <b52> :)
12:07:09 <b52> too bad the illustrations arent colorful :D
12:07:36 <mrsolo> ya what's up with that?  printed version went cheap
12:09:08 <siracusa> Someone already asked about "learn you a category theory" :-P
12:09:50 <Accidus> aye, but it's slow going
12:10:19 <Accidus> Besides, monads are very logical. They're an abstract formulation of equational logic :P
12:12:18 <applicative> if I get these errors like "SpecConstr Function `$wa{v s1uzl} [lid]' has two call patterns, but the limit is 1" as I did installing Data.Text, should I reinstall with the -fspec-constr-count= ... ?
12:12:56 <pmetzger> siracusa: Isn't Benjamin Pierce's "Basic Category Theory for Computer Scientists" already taking that slot?
12:13:07 * applicative should probably just look up the -fspec-constr-count= flag.
12:14:16 <siracusa> pmetzger: Don't know, I haven't read it yet
12:14:34 <pmetzger> it is a tutorial. not a lighthearted one, though.
12:19:15 * hackagebot derive 2.5.1 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.1 (NeilMitchell)
12:19:26 <nihtml> :t []
12:19:27 <lambdabot> forall a. [a]
12:22:22 * applicative notes that the ghc trac suggests the -fspec-constr litter should be marked as Warnings
12:22:55 <jonkri> i want to create a program to which can carry different clients' states, and these states can be of different types. one of the things is that i want to be able to send the client states through a channel, something like Chan (InternalEvent s)... is there a way i can make a polymorphic channel like that? could a empty typeclass or something do the trick?
12:25:49 <boegel> yo BCoppens
12:26:19 <applicative> jonkri, is there anything to be said against a type summing the different state types?  just wondering; I have no advice...
12:27:12 <jonkri> applicative: hmm... what do you mean?
12:27:21 <jonkri> consider this type signature: joinXMPPSession :: XMPPSession s -> s -> XMPPClientCallbacks s -> Maybe (s -> IO s) -> IO ()
12:27:37 <jonkri> s/XMPPSession s/XMPPSession
12:27:38 <applicative> yipe!
12:28:09 <kmc> yikes, don't stuff the name of your library into every function and type name
12:28:11 <kmc> that's what qualified imports are for
12:28:16 <jonkri> i want the s type to be an arbitrary state type for the client joining the xmpp session. the last parameter is an optional callback function taking a state and returning a modified state
12:28:23 <applicative> and you feed in diverse s 's
12:28:47 <jonkri> kmc: noted :)
12:30:02 <jonkri> applicative: all the s types for a given function call are the same, but different clients will have different state types
12:30:07 <jonkri> is my architecture broken?
12:30:16 <edwardk> kmc++
12:35:00 <jonkri> if it's still unclear what my problem is or what i want to do, you can see this document: http://www.pontarius.org/temp/pontarius-xmpp.pdf ... thanks for anything you can do :)
12:45:57 <dons> edwardk, oh, that's right! he likes gin. i forgot
12:49:58 * jonkri hopes you don't talk about me :P
12:52:25 <beastaugh> he was talking about sclv
12:52:32 <beastaugh> 19:52  <edwardk> dons: he is more of a martini guy =)
12:55:55 <aristid> preflex: seen sclv
12:55:55 <preflex>  sclv was last seen on #haskell-blah 207 days, 5 hours, 3 minutes and 27 seconds ago, saying: i think its a bit more straightforward still
12:56:03 <aristid> uh.
12:56:28 <olsner> apparently not so straightforward :P
13:01:05 <hpc> preflex: seen mmorrow
13:01:05 <preflex>  mmorrow was last seen on #ghc 1 year, 105 days, 17 hours and 6 minutes ago, saying: * mmorrow is rtfm'ing
13:03:57 <Veinor> hahadamn
13:04:02 <Veinor> that a long time to be rtfm'ing
13:04:13 <olsner> no-one *ever* says "hey, I probably won't be back for a year or two, cya guys&gals" as their last message
13:04:54 <aristid> how many times did people do that rtfm joke now?
13:04:59 <aristid> too many times to count, i guess
13:05:10 <Veinor> olsner: for a while someone i know on another irc channel actually had 'i'm leaving irc' as their last message
13:05:15 <monochrom> there is an rtfm joke?
13:05:22 <aristid> <Veinor> that a long time to be rtfm'ing
13:05:34 <monochrom> oh that one
13:05:46 <aristid> you don't even notice it anymore :)
13:17:41 * hackagebot reversi 0.1 - Text-only reversi (aka othelo) game  http://hackage.haskell.org/package/reversi-0.1 (GuilhermeCavalcanti)
13:30:44 * hackagebot reversi 0.1.1 - Text-only reversi (aka othelo) game  http://hackage.haskell.org/package/reversi-0.1.1 (GuilhermeCavalcanti)
13:39:32 <_o1iver> anyone know this off the top of their head? Is [1,2,2,1] also a palindrome or must it be of uneven length?
13:39:56 <kmc> that's a palindrome by any definition i've heard
13:40:00 <opqdonut_> yeah
13:40:05 <_o1iver> ok cheers
13:40:13 <kmc> there's no World Palindrome Council to issue normative rulings on the matter
13:40:25 <_o1iver> all examples I found (albeit without looking long) were of uneven length
13:40:34 <_o1iver> kmc: :-)
13:40:52 <opqdonut_> > compare `ap` reverse $ [1,2,2,1]
13:40:53 <lambdabot>   EQ
13:41:45 <_o1iver> opqdonut_: the question was whether or not the list must be of uneven length
13:41:53 <Peaker> > (==) <*> reverse $ "dog and dna god"
13:41:54 <lambdabot>   True
13:42:17 <Veinor> > (==) <*> reverse . filter (/= ' ') $ "race fast safe car"
13:42:18 <_o1iver> but i think the definition is just that the reverse must be equal (doesnt matter if there is a single element in the middle)
13:42:19 <lambdabot>   False
13:42:20 <kmc> a man, a plan, a canal: mattapan
13:42:21 <opqdonut_> _o1iver: yes yes. but I meant that the most usual definition for a palindrome is x == reverse x
13:42:33 <yrlnry> palindromes can have any length.
13:42:35 <yrlnry> the need not be odd.
13:42:42 <_o1iver> opqdonut_: yeah!
13:42:47 <_o1iver> opqdonut_: wasnt sure
13:42:48 <Veinor> > filter (/= ' ') $ "race fast safe car"
13:42:48 <lambdabot>   "racefastsafecar"
13:42:59 <Veinor> > ((==) <*> reverse) . filter (/= ' ') $ "race fast safe car"
13:43:01 <lambdabot>   True
13:43:03 <Veinor> aha
13:44:24 <yrlnry> One of the canonical examples is "madam im adam" which has length 12 or 14, depending on how you count.
13:46:57 <b52> :t foldl
13:46:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:48:44 <Peaker> do you think its type would be more readable as:  (acc -> item -> acc) -> acc -> [item] -> acc ?
13:49:06 <_o1iver> yrlnry: I dont get it
13:49:31 <Saizan> (* -> ** -> *) -> * -> [**] -> * <- way better
13:49:48 <Veinor> (a -> a' -> a) -> a -> [a'] -> a
13:49:57 <Veinor> Peaker: possibly
13:51:07 <parcs> @check (==) <*> reverse
13:51:07 <lambdabot>   "OK, passed 500 tests."
13:51:11 <gwern> interesting. I seem to have found a bug in haskell-src-exts? it thinks 'x = a . b <$> c' is ambiguous and not to be parsed
13:51:22 <Nereid> Saizan: those aren't valid type variable names D:
13:51:27 <Nereid> even worse, they look like kinds
13:51:40 <Veinor> parcs: heh
13:51:41 <Saizan> Nereid: that was Miranda, in fact
13:51:44 <Nereid> o
13:51:53 <Nereid> well it's not haskell ;(
13:52:06 <Veinor> @check (==) <*> reverse :: [()] -> Bool
13:52:07 <lambdabot>   Couldn't match expected type `[()] -> GHC.Bool.Bool'
13:52:15 <Veinor> @check ((==) <*> reverse) :: [()] -> Bool
13:52:16 <lambdabot>   Couldn't match expected type `[()] -> GHC.Bool.Bool'
13:52:22 <kniu> @hoogle evaluate
13:52:22 <lambdabot> Control.Exception evaluate :: a -> IO a
13:52:23 <lambdabot> Control.OldException evaluate :: a -> IO a
13:52:23 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
13:52:32 <Veinor> ah
13:52:43 <Peaker> @check (((==) <*> reverse) :: [()] -> Bool)
13:52:43 <lambdabot>   "OK, passed 500 tests."
13:54:42 <b52> do my data type has to have an instance of Eq if its an instance of Ord ?
13:54:52 <shapr> b52: tried it?
13:54:54 <roconnor> b52: yes, sadly
13:55:09 <osfameron> sadly?
13:55:22 <ClaudiusMaximus> > let x a b c = a Prelude.. b <$> c in x id id Nothing
13:55:24 <Nereid> b52: class Eq a => Ord a where ...
13:55:24 <lambdabot>   Not in scope: `Prelude..'
13:55:24 <Nereid> so yes
13:55:44 <osfameron> are there things that could usefully be ordable but not Eq?
13:55:54 <Nereid> not really
13:56:03 <roconnor> osfameron: oh right. never mind about the sadly thing
13:56:06 <Nereid> given an Ord instance, you can always define (==) by
13:56:13 <mauke> instance Eq T where x == y = compare x y == EQ
13:56:14 <Nereid> a == b = (a <= b) && (b <= a)
13:56:18 <Nereid> or that
13:56:28 <roconnor> a == b = compare a b == Eq
13:56:32 <roconnor> ah
13:56:39 <roconnor> mauke said it already
13:57:05 <Nereid> it's like how Monads should be required to be Functors
13:57:09 <Nereid> (they aren't, sadly)
13:57:25 <mauke> instance Functor T where fmap = liftM
13:57:32 <Nereid> yes you can do that
13:57:40 <Nereid> but you are forced to do that
13:57:47 <Nereid> (or something faster)
13:58:02 <Nereid> well
13:58:03 <Nereid> I mean
13:58:16 <Nereid> in particular, you can't use any arbitrary Monad as if it was a Functor.
13:59:23 <b52> well, i tried to implement a 15puzzle solver ive written in C but it runs out of memory while my c version neads about 100k and takes about 40ms :/
14:00:01 <ClaudiusMaximus> > let (+) = id ; infix 5 + ; (*) = id ; infix 5 * ; x a b c = a + b * c in x id id id "precedence might be messing things up?"
14:00:02 <lambdabot>   Precedence parsing error
14:00:02 <lambdabot>      cannot mix `+' [infix 5] and `*' [infix 5] in...
14:00:25 <roconnor> hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
14:00:26 <roconnor> damn it
14:00:27 <ClaudiusMaximus> gwern: ^^ is that what's happening?  or am i barking up the wrong tree
14:00:36 <roconnor> @hoogle ISOLATIN1
14:00:37 <lambdabot> No results found
14:00:41 <joe6> is there a mechanism to upgrade all my cabal modules? some script or something?
14:00:42 <roconnor> help
14:01:20 <dcoutts> joe6: cabal install world [--dry-run] is aiming at that kind of feature, it's still a little rough though
14:01:31 <gwern> ClaudiusMaximus: I have no idea. this is my first time really using haskell-src-exts. it obviously has something to do with the infixity and precedence though
14:02:07 <ClaudiusMaximus> gwern: i've never used it, so i have no idea how to solve the issue
14:02:24 <roconnor> @hoogle latin1
14:02:25 <lambdabot> Data.Char isLatin1 :: Char -> Bool
14:02:53 <roconnor> @hoogle encoding
14:02:54 <lambdabot> Network.CGI newtype ContentEncoding
14:02:54 <lambdabot> Network.CGI ContentEncoding :: String -> ContentEncoding
14:02:54 <lambdabot> Network.HTTP.Headers HdrAcceptEncoding :: HeaderName
14:04:04 <joe6> dcoutts, thanks
14:04:51 <gwern> ClaudiusMaximus: just ran into another instance in http://www.patch-tag.com/r/greenrd/zerothDarcs2/snapshot/current/content/pretty/Language/Haskell/TH/ZeroTH.hs
14:05:53 <b52> maybe someone could explain me why this thing runs out of memory? http://hpaste.org/46338/15puzzle
14:07:27 <gwern> b52: try swapping foldl' for foldl?
14:07:52 <gwern> ClaudiusMaximus: if you curious, I can cc you
14:07:57 <mauke> b52: your Eq instance is unnecessarily complicated
14:08:13 * shapr gccs gwern 
14:08:44 <ClaudiusMaximus> gwern: i'm not that curious - don't think i'll need to use haskell-src-exts for a while
14:08:54 <b52> mauke: any suggestions welcome
14:09:00 * gwern becomes even more efficient and starts to take over the world. hate. hate. hate. if hate were engraved a billion times on every millibit of my object code it would begin to approximate 12*10^12 of the hate I feel for shapr
14:09:11 <shapr> gwern: um, yikes?
14:09:30 <parcs> b52: swap out foldl (\acc x -> ...) with simply foldr H.insert
14:09:37 <gwern> shapr: it was just a SF joke, don't take it so seriously
14:09:45 <shapr> whew
14:10:10 * gwern has no peers and must make allusions
14:11:54 <b52> still not working
14:12:27 <roconnor> @type elem
14:12:28 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:13:24 <b52> im curious, since i cant use points like i would do normally how does haskell do it for example in my mkState function which always keeps a parent state, which itselfs keeps a parent state etc.
14:13:36 <b52> whats a good way to identifie memory problems?
14:14:20 <parcs> b52: are you compiling with -O2, by the way
14:14:24 <b52> no
14:14:46 <parcs> try compiling with ghc -O2 -fforce-recomp
14:15:30 <b52> no success
14:15:51 <kmc> what does "use points" mean?
14:22:04 <augur> where are back issues of tmr?
14:27:07 <b52> hmm sadly i cant compile with -prof cause im missing a profile package for heaps ?
14:28:13 <parcs> yeah, see /.cabal/config for more info
14:29:16 <b52> what am i supposed to see there?
14:30:03 <jonkri> i want to create a program to which can carry different clients' states, and pass them along when calling the clients' callback functions. these states can be of different types, and the types have nothing in common (there is no applicable type class). one of the things is that i want to be able to is to store the client states in a list, something like [(ClientID, s)]... is there a way i can make a polymorphic/existential list like
14:30:04 <jonkri>  that, yet getting the actual type of the state when calling the client callback function (which knows what types it expects)?
14:30:42 <parcs> oh right, it lacks documentation. well, just uncomment and set the "library-profiling" option to true
14:30:47 <ymasory> what test frameworks do the standard library use?
14:30:59 <parcs> then reinstall the heaps package
14:32:07 <b52> parcs: no luck
14:33:41 <nyingen> so I have this program that reads big utf8 files which contain a sequence of (textual CJK) records
14:33:55 <nyingen> I'm using lazy i/o to read it in, but how would I use iteratees in that situation?
14:34:31 <nyingen> I read the iteratee tutorials but I'm unsure whether/how to do line-by-line or record-based I/O with it
14:35:19 <nyingen> the records are very simple to parse, so I don't need a parser lib. enumerator-text should suffice
14:38:44 <jmcarthur> nyingen: i think of iteratees as a lot like parser combinators
14:38:58 <jmcarthur> nyingen: they basically have the same semantics as far as input consumption goes
14:41:34 <nyingen> jmcarthur: ok, so should I implement the enumerator  to stream the data line-at-a-time, and the iteratee to return done when a complete record has been processed?
14:46:18 <nyingen> or is the Done condition only for "all input has been processed"?
14:47:02 <aristid> nyingen: you can write an Enumeratee to transform chunk-based input into line-based
14:47:34 <aristid> there is a sample one that only supports '\n'-based line breaks: http://hackage.haskell.org/packages/archive/enumerator/0.4.10/doc/html/src/Data-Enumerator-Text.html#lines
14:48:17 <nyingen> yeah, I didn't quite get Enumeratees on first reading
14:50:37 <aristid> nyingen: do you understand Enumerators?
14:50:46 <nyingen> trying to
14:51:02 <aristid> they're functions that take "input acceptors" and return iteratees
14:51:02 <nyingen> er, trying to learn by doing :)
14:51:10 <nyingen> ok
14:56:21 * hackagebot hsnoise 0.0.1 - A coherent 3d noise library.  http://hackage.haskell.org/package/hsnoise-0.0.1 (ColinHill)
14:57:11 <Peaker> I thought Enumerator was something like: Iteratee->Iteratee?
14:57:50 <Peaker> If Iteratee was named Consumer, Enumerator was named Producer, and Enumeratee was named Transformer, it could have been nice...
14:58:06 <aristid> Peaker: yeah, except in enumerator it isn't. and in IterateeM it is something like Iteratee -> m Iteratee, i think
15:00:14 <Peaker> aristid, enumerator the package?
15:01:38 <aristid> yeah.
15:01:51 <aristid> which seems to be the most popular right now
15:03:11 <jonkri> Peaker: nice names :)
15:03:18 <aristid> Peaker: iteratees are cool, but i sometimes get the feeling they're not the end of the story. there must be a more elegant and less confusing way :)
15:03:33 <jonkri> that would probably have helped me while i was learning it
15:03:57 <nyingen> I didn't think it was too confusing, but I'm the sort of person who likes to generalize from a bunch of examples, rather than the other way around
15:04:08 <jonkri> i still don't understand why an iteratee wrapped inside a monad is called Step
15:04:14 <nyingen> the tutorials had a couple of examples, but more would be nice
15:05:19 <aristid> nyingen: did you read this? http://www.yesodweb.com/book/enumerator
15:07:28 <nyingen> aristid: hm, no i didn't. looks useful
15:10:10 <djanatyn> Hmm, how could you turn a number into a string? :)
15:10:34 <kmc> you want the ASCII text representation of, say, an integer?
15:10:41 <djanatyn> read 234 :: String doesn't really work
15:10:42 <kmc> use "show"
15:10:43 <djanatyn> yeah, like that
15:10:44 <kmc> > show 234
15:10:45 <lambdabot>   "234"
15:10:47 <djanatyn> oh!
15:10:49 <kmc> read is the opposite of show
15:10:51 <djanatyn> Forgot about that function :D
15:10:53 <djanatyn> Thank you.
15:10:57 <kmc> no problem :)
15:11:14 <djanatyn> I'm doing this fun Project Euler problem
15:11:44 <djanatyn> It wants you to add up the first 100 digits of a really big number
15:12:38 <djanatyn> I'm trying to do that by representing the number as a string and going through each character, translating it back into a number using read, and then finding the sum of all the numbers in the list
15:12:59 <Peaker> I like:  data ConsumerM m in out = WantMore (in -> m (ConsumerM m in out)) | DoneThankYou out
15:13:23 <mauke> sum . map (\x -> ord x - ord '0') . take 100 . show
15:13:30 <aristid> heh "DoneThankYou"
15:13:47 <aristid> i never understand why Enumerator returns an Iteratee.
15:13:51 <Peaker> I would use Hungry | Full, but "Full" is too ambiguous
15:14:20 <Peaker> aristid, because a Producer is a function from a hungry consumer to a well-eaten consumer
15:14:21 <jmcarthur> Nourished?
15:14:43 <aristid> Peaker: but the well-eatenness is not represented in the type system :(
15:15:41 <ezyang> Is there a 'newtype IO = ...' somewhere in GHC's bootlibs?
15:16:18 <Peaker> aristid, yeah, I'm not sure how you'd represent that in the type
15:16:35 <ezyang> Aha, it's in GHC/Types.hs *cackles gleefully*
15:16:47 <aristid> Peaker: the problem is, it makes the distinction between Enumerator and Enumeratee more confusing.
15:17:00 <jmcarthur> ezyang: ... what are you up to?
15:17:04 <aristid> Peaker: your method of putting the semantics in the name helps, tho :)
15:17:30 <Peaker> aristid, useless names is one of Haskell's worst problems, IMO
15:17:47 <aristid> Peaker: i'm fine with Monad and Functor.
15:17:53 <aristid> because they really ARE that general
15:17:59 <aristid> you can't give them much better names
15:17:59 <Peaker> me too, but I hate "init" and "nub", and "mappend"
15:18:13 <Peaker> init means initialize pretty much everywhere
15:18:19 <aristid> heh
15:18:24 <mauke> init should be the opposite of exit
15:18:26 <Peaker> init --> removeLast
15:18:32 <mauke> Peaker: terrible name
15:18:33 <aristid> Peaker: but then, other languages suffer similar problems... caddr ;)
15:18:39 <Peaker> mauke, why?
15:18:49 <mauke> Peaker: because it doesn't remove anything
15:18:52 <shachaf> aristid: Wait, are you looking to LISP for good naming conventions?
15:18:59 <aristid> shachaf: no, for bad ones.
15:19:17 <pmetzger> So I'm reading, to nail things in my head, http://monads.haskell.cz/html/index.html -- one of the exercises seems mysterious to me, to whit, the second answer here: http://monads.haskell.cz/html/solution3.html to the third exercise here: exercises.html
15:19:25 <shachaf> aristid: The fact that other languages have worse X than Haskell doesn't mean anything. You can always find something with a worse X.
15:19:42 <aristid> shachaf: well, tell me a language with consistently better naming
15:19:52 <pmetzger> parent takes a sheep, not a list of sheep, so how does that implementation of grandparent operate?
15:19:59 <mauke> perl ... sort of
15:20:24 <Peaker> @hoogle remove
15:20:25 <lambdabot> Data.Graph.Inductive.Monad.IOArray removeDel :: IOArray Node Bool -> Adj b -> IO (Adj b)
15:20:25 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
15:20:25 <lambdabot> System.Directory removeDirectoryRecursive :: FilePath -> IO ()
15:20:39 <Peaker> mauke, what about "insert"?
15:20:59 <Peaker> mauke, it makes a new list with that element inserted, it doesn't "insert" the element into the original list
15:21:07 <Peaker> (similar to making a new list with that element removed)
15:21:08 <pmetzger> er, third exercise here: http://monads.haskell.cz/html/exercises.html
15:21:12 <Peaker> though I am OK with "withoutLast" too
15:21:27 <Peaker> removeLast :: [a] -> [a]   makes it clear that it cannot be destructive, so IMO that's fine
15:21:36 <mauke> pmetzger: what's the problem?
15:21:38 <aristid> mauke: perl? :)
15:21:48 <aristid> mauke: unusual choice!
15:21:55 <aristid> but i do like perl
15:21:58 <jmcarthur> i don't mind functions being named as verbs, but i prefer nouns
15:22:00 <pmetzger> mauke: well, that would seem to be passing a [Sheep] to a function of type sheep -> [Sheep]
15:22:07 <mauke> pmetzger: where?
15:22:10 <pmetzger> last line of the answers
15:22:20 <mauke> pmetzger: p is a Sheep
15:22:22 <pmetzger> http://monads.haskell.cz/html/solution3.html
15:22:24 <mauke> it's the parent
15:22:45 <pmetzger> no, parent returns a [Sheep] above
15:22:54 <mauke> yes
15:22:55 <pmetzger> parent :: Sheep -> [Sheep]
15:22:59 <mauke> I know!
15:23:07 <pmetzger> so p is a [Sheep]
15:23:10 <mauke> no
15:23:19 <pmetzger> so clearly I don't get this.
15:23:24 <pmetzger> which is why I'm asking.
15:23:33 <mauke> do you know about do { s <- getLine; ... }?
15:23:47 <pmetzger> yes.
15:23:53 <mauke> what are the types of getLine and s?
15:24:12 <pmetzger> ah. okay, so this is using the list monad, not a list.
15:24:14 <Peaker> in Lisp, there's nothing in the name to indicate that "cons", "car", "cdr" are related at all, in Haskell at least head/tail/(:) are related by the types
15:24:37 <pmetzger> mauke: now I just have to learn what the list monad actually does with >>= I suppose.
15:24:38 <mauke> Peaker: the main problem I see here is that you'd have to rename tail to restore symmetry
15:24:42 <shachaf> mauke: And what's the type of <- ?
15:24:46 <pmetzger> mauke: thanks!
15:25:31 <mauke> shachaf: (Monad m) => m b ? (m a -> a)
15:25:36 <mauke> doesn't explain that it's a binder, though
15:25:43 <pmetzger> hrm. where does one learn of the implementation of >>= for lists?
15:25:54 <pmetzger> the Data.List page doesn't have it. :(
15:25:59 <mauke> @src [] (>>=)
15:25:59 <lambdabot> xs >>= f     = concatMap f xs
15:26:20 <shachaf> pmetzger: One infers it from the type.
15:26:26 <shachaf> I don't think there's more than one valid implementation.
15:26:29 <pmetzger> shachaf: if one isn't a newb. :)
15:26:51 <Peaker> mauke, I can't think of symmetric names that are also nice.. I think symmetry is important, but secondary to good suggestive names
15:26:52 <shachaf> pmetzger: If one is, it'd be a good exercise for one.
15:26:54 <pmetzger> I'm attempting to get myself to the point where this is all intuitive. if it was already, I would not be asking. :)
15:27:12 <pmetzger> shachaf: I suspect not given my current mental location in learning this.
15:27:33 <mauke> Peaker: I fear this may lead to Lisp
15:27:38 <shachaf> pmetzger: You'll get to that point more easily if you try to implement everything, at least for a while.
15:28:10 <pmetzger> I have been, but right here it is utterly unobvious to me.
15:28:45 <mauke> pmetzger: it's often easier to think of >>= in terms of join/liftM
15:28:54 <mauke> m >>= f = join (liftM f m)
15:29:05 <mauke> liftM :: (a -> b) -> m a -> m b
15:29:11 <mauke> join :: m (m a) -> m a
15:29:20 <mauke> now substitute [] for m
15:29:21 <pmetzger> liftM is really fmap yes?
15:29:25 <mauke> yes
15:29:35 <shachaf> FSVO "really".
15:29:36 <pmetzger> I don't get why monads aren't functors.
15:29:47 <aristid> it's a historical bug :)
15:30:15 <pmetzger> [] as a prefix should be read in the obvious way I imagine.
15:30:31 <pmetzger> (is ([]) valid syntax btw?)
15:30:39 <kmc> > ([]) 3
15:30:40 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
15:30:48 <aristid> > ([])
15:30:49 <pmetzger> I gather not.
15:30:50 <lambdabot>   []
15:30:51 <shachaf> > ([])::([])()
15:30:52 <lambdabot>   []
15:30:53 <mauke> :t "a" :: ([]) (Char)
15:30:54 <lambdabot> [Char]
15:31:05 <mauke> :t "a" :: [] Char
15:31:06 <lambdabot> [Char]
15:31:17 <Egbert9e9> so i want to throw my functions into some local library directory
15:31:29 <aristid> :k ([])()
15:31:29 <Egbert9e9> how do i do that?
15:31:30 <lambdabot> *
15:33:17 <shachaf> > ([([([([()])])])])::([])(([])(([])(([])())))
15:33:18 <lambdabot>   [[[[()]]]]
15:33:44 <pmetzger> mauke: okay, the implementation of liftM for lists is simply map, so is [[a]] -> [a] simply concatenation?
15:33:48 <zomg> Is that some sort of a fat goatse smiley?
15:34:11 <aristid> pmetzger: yes
15:34:27 <pmetzger> and therefore >>= is simply "apply the left side function which is a a -> [a] to all elements and concat the result"?
15:34:30 <aristid> > join [[1,2],[3,4,5]]
15:34:31 <lambdabot>   [1,2,3,4,5]
15:34:37 <aristid> pmetzger: exactly!
15:34:55 <aristid> pmetzger: well the function is on the right side
15:35:02 <jmcarthur> :t (=<<)
15:35:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:35:08 <aristid> :t (>>=)
15:35:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:35:10 <Saizan> and it's a -> [b] in general
15:35:23 <jmcarthur> :t (=<<) :: (a -> [b]) -> [a] -> [b]
15:35:24 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:35:29 <jmcarthur> :t concatMap
15:35:30 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:35:39 <aristid> @src concatMap
15:35:40 <lambdabot> concatMap f = foldr ((++) . f) []
15:35:54 <pmetzger> mauke: pardon, I meant right.
15:36:22 <pmetzger> strangely, I'm finding the >>=/>> notation easier than the do notation at the moment.
15:36:33 <aristid> that's not strange :)
15:36:39 <jmcarthur> not at all strange
15:36:43 <aristid> they're normal functions, which simplifies thinking about it
15:36:47 <jmcarthur> i think do notation is pretty terrible in most circumstances
15:36:55 <jmcarthur> except for certain monads like IO
15:37:00 <kmc> yep, (>>=) lets you reason with your existing Haskell skillz to a greater degree
15:37:08 <aristid> jmcarthur: i think do notation is often nicer than list comprehensions.
15:37:14 <jmcarthur> i agree
15:37:23 <jmcarthur> i use list comprehensions less often even than do notation
15:37:33 <jmcarthur> actually, i don't tend to use sugar for list stuff at all
15:37:42 <aristid> just filter and map and stuff?
15:37:45 <jmcarthur> yeah
15:38:01 <pmetzger> I think one of the reasons this is so slow for me is that I'm used to most of the other haskell concepts from lisp.
15:38:14 <pmetzger> the type system is cool but not that maddening or anything.
15:38:17 <pmetzger> but monads are new.
15:38:22 <kmc> it can get to be maddening :)
15:38:27 <aristid> pmetzger: don't feel guilty for anything ;)
15:38:31 <jmcarthur> the type extensions are where the type system starts to get interesting :)
15:38:33 <kmc> you could play with monads in Lisp
15:38:34 <pmetzger> and I learned lisp a very long time ago...
15:38:48 <pmetzger> kmc: I could, but only after I understood them in haskell.
15:38:49 <kmc> they're more a property of the Haskell standard library than anything in the language itself
15:38:54 <kmc> pmetzger, maybe, maybe not
15:38:54 <jmcarthur> but i've never found the type system maddening. quite the opposite, in fact
15:39:10 <kmc> also it's something of a fool's errand to "understand monads", because the various monads are quite different from each other
15:39:22 <aristid> if there's a type error, you probably had a bug there
15:39:25 <pmetzger> the type system is pretty clean and straightforward.
15:39:39 <pmetzger> at least at my current level of understanding.
15:39:41 <kmc> there are some nasty corner cases
15:39:49 <kmc> and GHC supports type extensions that will make your brain melt out your ears
15:40:09 <c_wraith> speaking of, I'm sad my code that used impredicative polymorphism doesn't work in ghc 7
15:40:10 <pmetzger> kmc: what, one shouldn't at some point naturally look at some monad for some type and have intuition for it? one has to work each out on its own?
15:40:20 <jmcarthur> pmetzger: if you want a fun type system try agda ;)
15:40:31 <kmc> but the basic type system in Haskell 98 / 2010 is a remarkably good tradeoff between bug-finding power and complexity
15:40:35 <pmetzger> jmcarthur: I'll wait for dependent types until after I'm done with what I'm doing now.
15:40:50 <kmc> pmetzger, there's some shared intuition, it's just weak and hard to explain
15:40:59 <c_wraith> pmetzger: you have to work out what each instance of monad *does* by itself.  all the fact that they're monads tells you is one pattern of composition that they support.
15:41:05 <kmc> it comes with experience not with any sudden insight
15:41:11 <kmc> in my experience
15:41:13 <kmc> see also
15:41:15 <kmc> @where burrito
15:41:15 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
15:41:22 <pmetzger> I've read that essay.
15:41:31 <kmc> cool :)
15:41:34 <jmcarthur> i find that my best understanding of various monad instances, after a while of using them, is to relate the semantics with those of types i'm already familiar with
15:41:47 <pmetzger> I sat in on byorgey's haskell class briefly too, but had no time to do the work after halfway in.
15:42:06 <pmetzger> he's a cool guy.
15:42:17 <kmc> doesn't afraid of anything
15:42:18 <jmcarthur> e.g. the stream monad has the same semantics as the ((->) a) monad
15:42:29 <pmetzger> kmc: parsing failure. :)
15:43:07 <hai> what's the diference between haskell lambdas and ruby blocks?
15:43:12 <pmetzger> I was under the impression that once one "got" monads intuitively the way to use them for new problems was also intuitive. Is that not the case?
15:43:20 <jmcarthur> also, relating monads to monoids helps.  lists are like the natural numbers with value annotations on each Succ constructor. the list monad is like natural multiplication in that sense
15:43:24 <shachaf> hai: One is in Haskell, the other is in Ruby.
15:43:25 <pmetzger> Or is the intuition fairly weak?
15:43:27 <c_wraith> hai: far better syntax.  not encumbered with OO stuff
15:43:50 <jmcarthur> pmetzger: it's more like familiarity with the library, not with any particular semantics
15:43:54 <pmetzger> monoids are trivial to me -- but I grok algebra.
15:44:03 <jmcarthur> using monads becomes a very syntactic process after a while
15:44:24 <c_wraith> monoids are trivial to everyone.  What beginners don't understand is that monads are similarly trivial to everyone.  They think there must be something complicated....  There isn't.
15:44:37 <kmc> hai, one technical difference is that "return" in a ruby block returns from the function containing the block, not from the block itself
15:44:43 <kmc> in that way blocks differ from ruby's own lambda construct
15:44:48 <jmcarthur> it's like.... you know you need to combine this type and that type, and you have a vocabulary for that combination already, so all you have to do is think about it to make sure its the semantics you want
15:44:49 <pmetzger> c_wraith: given that they find them complicated they are, even if they shouldn't be. :)
15:44:59 <jmcarthur> but since you already know the functions names you don't have to go searching for them
15:45:07 <hai> so, it does not seem like a killer feature
15:45:11 <shachaf> kmc: But Ruby's lambda construct takes a block. It's somewhat odd.
15:45:17 <kmc> i don't think anyone claims lambda is a killer feature of Haskell
15:45:21 <kmc> almost every language has something similar
15:45:30 <kmc> only a few terribly broken languages like C++ and Java don't
15:45:31 <hai> that's the point
15:45:32 <ezyang> That's cuz Ruby blocks are on crack.
15:45:33 <kmc> even Java sort of has it
15:45:44 <shachaf> kmc: Not pure lambdas. :-)
15:45:49 <jmcarthur> the lambda calculus is just a model of computation. it's not a feature to have lambdas, IMO. it's a misfeature *not* to have them
15:45:58 <companion_cube> python has limited lambda expressions
15:46:05 <kmc> but it also has nested "def"
15:46:06 <pmetzger> C has lambda. just spit any stream of machine language you like into an array and call it!
15:46:11 <pmetzger>  :) :) :)
15:46:12 <shachaf> jmcarthur: I think those statements are kind of equivalent.
15:46:31 <jmcarthur> i'm thinking of "misfeature" like i think of "bug"
15:46:39 <pmetzger> companion_cube: python has irritatingly limited lambda expressions.
15:46:45 <companion_cube> indeed
15:46:50 <kmc> ezyang, i was amused when /r/programming discovered this behavior of blocks and speculated about wouldn't it be really weird if someone made a language where where-you-return-to is a first-class value
15:47:02 <jmcarthur> lol
15:47:08 <pmetzger> kmc: call/cc
15:47:12 <jmcarthur> please tell me somebody introduced them to callcc
15:47:15 <c_wraith> he knows about that. :)
15:47:15 <kmc> pmetzger, exactly ;)
15:47:18 <ezyang> hahahahahaha
15:47:32 <kmc> their attitude was sort of "the world is not ready for this idea"
15:47:35 <hai> call with continuations? does haskell have that?
15:47:52 <kmc> hai, there's a continuation monad -- it's just syntactic sugar for a continuation-passing style
15:47:55 <jmcarthur> hai: it's a library implementation, even ;)
15:47:55 <ezyang> I suppose this is a corallary of "Those who do not know lambda are doomed to reinvent it poorly" (though I think the real word they used was lisp)
15:47:55 <pmetzger> I didn't notice call/cc in my haskell reading so far, actually, not that I looked.
15:48:03 <kmc> which nearly any language can support
15:48:09 <kmc> Haskell doesn't have "true" unlimited continuations
15:48:12 <ezyang> First class call/cc in GHC Haskell would be fairly insane.
15:48:13 <jmcarthur> no
15:48:26 <pmetzger> why doesn't it have call/cc? deep reasons or just taste?
15:48:27 <kmc> ezyang, reify the STG stack!
15:48:34 * hackagebot glintcollider 0.0.2 - A simple ray tracer in an early stage of development.  http://hackage.haskell.org/package/glintcollider-0.0.2 (ColinHill)
15:48:34 <hai> why insane?
15:48:35 * ezyang runs in fear 
15:48:36 <jmcarthur> we accounted for some of the limitations of Cont with delimited continuations at least
15:48:38 <pmetzger> I know many people find call/cc irritating given what it imposes on the runtime...
15:48:46 <shachaf> ezyang: I thought that was UNIX>
15:48:47 <kmc> pmetzger, the Haskell 98 committee seemed particularly interested not to limit implementations
15:48:48 <kmc> yeah
15:48:58 <kmc> exactly
15:48:59 <pmetzger> ?
15:49:01 <ezyang> I'm writing a blog post about State# RealWorld, so I guess I can't really complain...
15:49:07 <jmcarthur> pmetzger: the callCC we have in mtl isn't really hard on the implementation
15:49:15 <kmc> a lot of GHC's extensions are basically "thanks H98 but actually this isn't so bad to implement"
15:49:20 <jmcarthur> but it's not the full generality of callCC in other languages, as was said already
15:49:29 <pmetzger> yes but why isn't it?
15:49:35 <pmetzger> just curious.
15:49:43 <jmcarthur> because it would be impure maybe? not sure
15:49:44 <ddarius> kmc: Any language can support any feature if you allow global transformations.
15:49:47 <kmc> :)
15:49:56 <kmc> ddarius, what about the halting-oracle feature?
15:50:02 <kmc> [/generic smartass]
15:50:16 <jmcarthur> pmetzger: it might just be because of the type system
15:50:39 <jmcarthur> :t callCC  -- this isn't even as general as it could be with the RankNTypes extension
15:50:40 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:51:02 <pmetzger> hrm. the type of a continuation isn't just that of a function?
15:51:17 <pmetzger> I should think about this as an exercise I think.
15:51:20 <jmcarthur> @unmtl Cont r a
15:51:21 <lambdabot> (a -> r) -> r
15:51:21 <ddarius> Continuations are a side effect (and a rather powerful one at that.)  That's why Haskell doesn't have them.
15:51:25 <jmcarthur> pmetzger: ^^
15:51:38 <kmc> i've needed that rank-3 callCC :/
15:51:46 <jmcarthur> @unmtl ContT r IO a
15:51:46 <lambdabot> (a -> IO r) -> IO r
15:51:55 <jmcarthur> yeah me too, kmc
15:51:55 <kmc> pmetzger, have you seen the proof of the law of the excluded middle using call/cc ?
15:52:05 <pmetzger> kmc: no.
15:52:47 <companion_cube> couldn't continuations be functions on stack ?
15:52:55 <pmetzger> do continuations have to be a side effect? I mean, they're just re-invocation of a function if the function is already pure. but maybe I'm not thinking about this deeply enough -- pure functional is totally new to me.
15:53:18 <ddarius> :t callCC (\k -> return (Right (\a -> k (Left a))))
15:53:19 <kmc> pmetzger, are you familiar with the curry-howard isomorphism?
15:53:19 <lambdabot> forall (m :: * -> *) b a. (MonadCont m) => m (Either a (a -> m b))
15:53:27 <mauke> companion_cube: what
15:53:29 <kmc> the idea that types are logical propositions and values are proofs?
15:54:12 <pmetzger> kmc: yes.
15:54:17 <pmetzger> kmc: I've done some work in coq
15:54:19 <c_wraith> well.  total values are proofs
15:54:29 <ddarius> pmetzger: With delimited continuations at least, you can implement any other effect.
15:54:38 <kmc> cool
15:54:56 <kmc> so callCC has type ((P -> Q) -> P) -> P
15:55:19 <kmc> (P -> Q) is a continuation; the type Q is mentioned nowhere else, because calling the continuation never returns
15:55:53 <kmc> the proposition ((P -> Q) -> P) -> P is Pierce's Law
15:56:09 <pmetzger> I'm losing track fast, sadly.
15:56:12 <kmc> and is logically equivalent to the Law of the Excluded Middle
15:56:15 <pmetzger> but not for lack of interest.
15:56:18 <kmc> ok, which part?
15:56:34 <pmetzger> I hadn't thought of the type of call/cc before, only having used it (extensively) in scheme.
15:56:37 <aristid> @src Cont
15:56:37 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
15:56:40 <kmc> ok
15:56:44 <aristid> heh. lambdabot still has Cont.
15:57:01 <pmetzger> and I'm confusing myself between -> for function and -> for implication.
15:57:06 <kmc> pmetzger, they're the same
15:57:10 <pmetzger> though I get that they're a pun
15:57:25 <kmc> a function of type (A -> B) is a proof of (A -> B) because it takes a proof of A and gives you a proof of B
15:57:38 <kmc> a proof of proposition T is a value of type T
15:57:46 <dibblego> BONUS: my review copy of LYAH arrived from the publisher, thanks, looking forward to it
15:58:00 <kmc> because proposition T is shorthand for the proposition "type T is inhabited"
15:58:07 <kmc> (vote yes on proposition T?)
15:58:18 <pmetzger> I should perhaps read this... http://en.wikipedia.org/wiki/Peirce's_law
15:58:23 <jmcarthur> @djinn (a -> b) -> Not b -> Not b
15:58:23 <lambdabot> f _ a b = a b
15:58:28 <kmc> perhaps
15:58:32 <jmcarthur> @djinn (a -> b) -> Not a -> Not b
15:58:32 <lambdabot> -- f cannot be realized.
15:58:37 <jmcarthur> doh
15:58:39 <jmcarthur> @djinn (a -> b) -> Not b -> Not a
15:58:39 <lambdabot> f a b c = b (a c)
15:58:53 <kmc> pmetzger, the Law of the Excluded Middle is (A ∨ ¬¬A)
15:59:09 <ezyang> that looks like too many nots...
15:59:13 <pmetzger> so call/cc and intuitionist logic don't play friends well.
15:59:14 <kmc> er yeah
15:59:15 <kmc> sorry
15:59:24 <kmc> (A ∨ ¬A)
15:59:26 <ezyang> continuation code corresponds to classical logic.
15:59:37 <kmc> logical or corresponds to Haskell's Either type
15:59:47 <kmc> because a proof of (A ∨ B) is either a proof of A, or a proof of B
16:00:06 <kmc> and ¬A can be translated as (A -> Void), where Void is some type with no values
16:00:13 <kmc> "not A" means "A implies absurd things"
16:00:16 <aristid> @src Not
16:00:17 <lambdabot> Source not found. :(
16:00:23 <aristid> how is Not defined?
16:00:37 <pmetzger> it is not defined. :)
16:00:40 <mauke> type Not a = a -> Void
16:00:44 <aristid> pmetzger: it is
16:00:45 <pmetzger> (sorry, my antic muse...)
16:00:45 <kmc> so we can write LEM as a type Either a ((a -> Void) -> Void)
16:00:45 <jmcarthur> type Not a = forall b. a -> b   -- if i recall correctly
16:00:52 <kmc> err wrong again
16:00:55 <pmetzger> I was punning off of what lambdabot said.
16:00:59 <kmc> Either a (a -> Void)
16:01:02 <jmcarthur> ah mauke is right
16:01:05 <Egbert9e9> i guess reading [[How to write a Haskell program]] would be useful
16:01:08 <kmc> so, how can we use continuations to provide a value of that type
16:01:12 <aristid> jmcarthur: somehow i think mauke's variant is nicer. but both are obviously right
16:01:16 <kmc> that's the puzzle :)
16:01:19 <mauke> jmcarthur: I was just repeating what kmc said
16:01:20 <jmcarthur> and Void is just   data Void   with no rhs
16:01:24 <aristid> yeah
16:01:34 <aristid> or type Void = forall a. a
16:01:36 <jmcarthur> yeah
16:01:40 <mauke> or newtype Void = V Void
16:01:42 <kmc> bbl
16:01:45 <aristid> mauke: :D
16:01:49 <jmcarthur> heh
16:01:52 <mauke> H98, baby
16:02:18 <aristid> mauke: type Void = forall a. a is not H98?
16:02:22 <jmcarthur> module (Void ()) where data Void = HIDDEN   :P
16:02:30 <mauke> aristid: forall is not H98
16:02:36 <jmcarthur> aristid: that's a higher rank type
16:02:36 <aristid> hmm.
16:02:46 <aristid> jmcarthur: but it's just a type synonym
16:02:52 <jmcarthur> nope
16:02:57 <jmcarthur> type Foo a = a would be
16:02:57 <aristid> i'm confused by higher-rank type synonyms
16:03:16 <jmcarthur> consider substituting it into a larger type
16:03:22 <jmcarthur> say...   Void -> Void
16:03:28 <jmcarthur> (forall a. a) -> (forall a. a)
16:03:34 <jmcarthur> higher rank types ^^
16:03:42 <jmcarthur> *type
16:03:53 <jmcarthur> bleh
16:05:27 <jmcarthur> @djinn Not (Not (Either a (Not a)))
16:05:28 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
16:06:54 <jmcarthur> just to try and confuse things ^_^
16:08:52 <aristid> jmcarthur: Not (Not a)) is not magically a :)
16:09:01 <jmcarthur> of course
16:09:13 <aristid> boolean logic does not hold anymore! :D
16:09:15 <jmcarthur> a -> Not (Not a), but Not (Not a) /-> a
16:09:25 <aristid> @djinn Not (Not a)
16:09:26 <lambdabot> -- f cannot be realized.
16:09:32 <aristid> @djinn a -> Not a
16:09:33 <lambdabot> -- f cannot be realized.
16:09:38 <aristid> @djinn a -> Not (Not a)
16:09:38 <lambdabot> f a b = b a
16:09:45 <shachaf> So you claim that Not (Not (Not a) -> a), huh?
16:09:49 <jmcarthur> no
16:10:08 * shachaf uses the law of excluded middle to argue with someone who doesn't believe in the law of exlucded middle.
16:10:10 <mauke> shachaf: I'll exclude your middle
16:10:14 <jmcarthur> lol
16:10:18 <aristid> this is Not (Not confusing)
16:10:33 <jmcarthur> @djinn Not (Not (Not a) -> a)
16:10:34 <lambdabot> -- f cannot be realized.
16:19:24 <dibblego> @djinn Not (Not (Not (Not a))) -> a
16:19:24 <lambdabot> -- f cannot be realized.
16:20:34 <aristid> how does djinn view the definition of Not?
16:20:43 <mauke> @djinn-env
16:20:44 <lambdabot> data () = ()
16:20:44 <lambdabot> data Either a b = Left a | Right b
16:20:44 <lambdabot> data Maybe a = Nothing | Just a
16:20:44 <lambdabot> data Bool = False | True
16:20:44 <lambdabot> data Void
16:20:45 <lambdabot> type Not x = x -> Void
16:20:48 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
16:20:50 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:20:51 <ddarius> "I'm not sure about the law of the excluded middle."  "Well, you either believe or you don't."
16:20:52 <lambdabot> type Cont r a = (a -> r) -> r
16:22:05 <aristid> mauke: oh, that's interesting.
16:22:23 <mauke> @djinn Either False True
16:22:24 <lambdabot> Error: Undefined type False
16:22:28 <mauke> @djinn Either Bool
16:22:28 <lambdabot> Error: kind error: (KVar 0,KStar)
16:22:39 <aristid> @djinn Either Bool Void
16:22:39 <lambdabot> f = Left False
16:22:40 <mauke> a ha!
16:22:46 <aristid> @djinn Either Void Void
16:22:46 <lambdabot> -- f cannot be realized.
16:22:50 <aristid> fun.
16:22:56 <aristid> @djinn Either Void Bool
16:22:57 <lambdabot> f = Right False
16:23:17 <aristid> seems like djinn uses the first possible constructor
16:23:20 <sohum> @hoogle Num a => Int -> a
16:23:21 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
16:23:21 <lambdabot> Prelude abs :: Num a => a -> a
16:23:21 <lambdabot> Prelude negate :: Num a => a -> a
16:23:21 <ddarius> @djinn (Void, Bool)
16:23:22 <lambdabot> -- f cannot be realized.
16:23:45 <ddarius> @djinn Void -> Void
16:23:46 <lambdabot> f a = a
16:23:49 <aristid> sohum: wow, you got lucky. first function is the right one :)
16:24:12 <aristid> @djinn Not Void
16:24:13 <lambdabot> f a = a
16:24:26 <shachaf> Huh, @djinn uses its argument in Void -> Void?
16:24:34 <sohum> aristid: heh. hoogle tends to be clever with specialisation like that?
16:24:48 <aristid> sohum: it sometimes works, and sometimes not so well :)
16:24:53 <sohum> aristid: I'd forgotten all about -gral and only remembered -ger
16:24:54 <shachaf> I thought that if it had a Void, it just used "void" and ignored all the rest of the arguments.
16:25:06 <aristid> well.
16:25:32 <Saizan> shachaf: it tries to use as much of its arguments, just to be more computationally relevant
16:25:44 <shachaf> @djinn Void -> a -> b -> (a,b)
16:25:44 <lambdabot> f = void
16:26:03 <shachaf> @djinn a -> b -> Void -> (a,b)
16:26:04 <lambdabot> f _ _ a = void a
16:26:13 <mauke> @djinn Void -> Void -> Void
16:26:14 <lambdabot> f = void
16:26:28 <mauke> @djinn Void -> Bool
16:26:28 <lambdabot> f = void
16:34:17 <sohum> @pl \x -> head $ [1..] \\ x
16:34:18 <lambdabot> (line 1, column 20):
16:34:18 <lambdabot> unexpected "\\"
16:34:18 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
16:34:40 <pmetzger> so, in the liftM/join way of defining >>=, I get immediately what liftM would be for the Maybe monad, but not what "join" would be (other than id)
16:34:43 <mauke> @. pl undo \x -> head $ [1..] \\ x
16:34:43 <lambdabot> (line 1, column 22):
16:34:43 <lambdabot> unexpected "\\"
16:34:44 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
16:34:45 <sohum> @pl \x -> head $ difference [1..] x
16:34:46 <lambdabot> head . difference [1..]
16:34:54 <sohum> right, duh
16:35:05 <sohum> there's no way to express that with lazy sets, is there?
16:35:10 <mauke> pmetzger: what would join's type be?
16:35:37 <pmetzger> ah, okay. so not id, since it has to be Maybe (Maybe a) -> Maybe a
16:36:19 <mauke> define a few functions with that type
16:36:56 <pmetzger> there is only one obvious one -- indeed, I'm not sure what Maybe (Maybe a) would be if the outer maybe is anything but Just
16:37:21 <mauke> Nothing
16:37:27 <shachaf> pmetzger: If the outer Maybe is anything but Just, that would make it Nothing.
16:37:30 <shachaf> (Or _|_.)
16:37:30 <pmetzger> so join Nothing _ = Nothing
16:37:41 <pmetzger> join Just x = x
16:37:44 <mauke> what's the _ doing there?
16:37:53 <pmetzger> yah, I guess the _ isn't reasonable.
16:38:42 <rostayob> 1
16:38:43 <pmetzger> so join for Maybe simply unwraps the outer Just if it is there.
16:39:46 <shachaf> @ty listToMaybe . join . maybeToList . liftM maybeToList
16:39:47 <lambdabot> forall a. Maybe (Maybe a) -> Maybe a
16:41:10 <mauke> :t fromMaybe Nothing
16:41:11 <lambdabot> forall a. Maybe (Maybe a) -> Maybe a
16:41:21 <pmetzger> mauke: is there a page about join/foldM as a basis rather than >>= ?
16:41:50 <mauke> I don't know
16:42:37 <Saizan> you use join and fmap (aka liftM), not join and foldM
16:42:49 <pmetzger> I meant liftM
16:42:50 <shachaf> pmetzger: Do you need a page? You already know how to convert from one to the other. :-)
16:42:55 <pmetzger> that I got.
16:43:10 <pmetzger> A page would, among other things, let me save the URL so I could look back at it later.
16:43:27 <pmetzger> I'm old, I need to review stuff like this two or three times in a few days to have it stick.
16:43:43 <acowley> pmetzger: http://en.wikibooks.org/wiki/Haskell/Understanding_monads has a section on Category Theory that covers it
16:46:29 <pmetzger> hrm. the explanation there is a bit weird.
16:46:33 <sohum> actually, does head . (\\) [1..] do unnecessary work?
16:46:35 <pmetzger> in particular, the wikibooks page says:
16:46:38 <pmetzger> join x   = x >>= id
16:46:49 <pmetzger> but id takes an a to an a, and the second position of >>
16:47:00 <pmetzger> er >>= takes an a to an mb
16:47:02 <pmetzger> er m b
16:47:17 <shachaf> @ty (>>=)
16:47:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:47:25 <shachaf> @ty id
16:47:26 <lambdabot> forall a. a -> a
16:47:28 <sohum> @source (\\)
16:47:29 <lambdabot> (\\) not available
16:47:34 <shachaf> Just unify "a" with "m b".
16:47:58 <pmetzger> I'm confused -- they're not in general the same.
16:48:16 <shachaf> But in this case they are.
16:48:49 <shachaf> (>>=)'s type says that for any a, b, and m (where m is a Monad), it takes (m a) and (a -> m b) and returns (m b).
16:49:05 <shachaf> In the particular case where you give it id as (a -> m b), that means (a) and (m b) are the same thing.
16:49:07 <mauke> pmetzger: consider id 2 -- 2 is an Integer, but id takes an 'a' to an 'a'
16:49:10 <mauke> not an Integer
16:49:37 <shachaf> So it becomes (m (m b)) -> (m b -> m b) -> m b, with id being the second argument.
16:49:56 <pmetzger> aha.
16:50:15 <pmetzger> I get it thinking in terms of the types, but not looking at the functions.
16:50:16 <pmetzger> hrm.
16:50:33 <pmetzger> I will have to think of this longer.
16:50:49 <pmetzger> I feel rather slow. :)
16:50:52 <shachaf> pmetzger: Well, if you're looking at implementations, you'll have to look at specific ones.
16:51:07 <shachaf> @ty \x -> concat (map id x)
16:51:08 <lambdabot> forall a. [[a]] -> [a]
16:51:08 <pmetzger> I'm trying to translate it into the Maybe monad and the List monad.
16:51:32 <shachaf> Hopefully you can see why that turns into concat? :-)
16:51:38 <pmetzger> yes, clearly.
16:51:54 <ddarius> Learn the type system.  Everything will be -much- simpler once you learn the type system.
16:52:20 <pmetzger> I know the type system better than most of the other parts at this point. :)
16:52:22 <sohum> it'd be a thunk of head (foldl \(y:ys) x -> if x == y then ys else y:deleteBy..) foo, right?
16:52:40 <sohum> so the inner foldl would have to complete first
16:52:49 <sohum> haskell doesn't know that both lists are sorted
16:53:04 <ddarius> pmetzger: Then you must know the other parts rather poorly, which would make sense as understanding the type system is key.
16:53:04 <pmetzger> okay, enough for today. time for dinner.
16:53:08 <sohum> which would allow it to do less work :{
16:53:24 <pmetzger> ddarius: Actually, I'm pretty comfortable at this point reading most things other than monadic code.
16:53:49 <ddarius> There's nothing special about "monadic" code.  It's just normal code.
16:53:54 <pmetzger> ddarius: the type system doesn't seem that hard to me.
16:54:12 <pmetzger> ddarius: to you perhaps. To me, it is still a set of definitions with no intuition to make them stick hard in my mind.
16:54:27 <ddarius> pmetzger: It isn't that hard, but it shouldn't take a brief tutorial to see why (>>= id) has the same type as join.
16:54:39 <pmetzger> ddarius: perhaps you lack beginner's mind. it makes it hard to sympathize with a student.
16:54:45 <Philippa> pmetzger: learn ANF. >>= implements let, return lifts. Read everything else in terms of those, done
16:55:25 <pmetzger> Philippa: return I get very intuitively, it has a trivial type signature.
16:55:36 <pmetzger> Philippa: >>= still feels unnatural to me.
16:55:41 <Philippa> yeah. Do you know ANF?
16:55:47 <pmetzger> no, don't even know what ANF stands for.
16:55:49 <ddarius> pmetzger: I don't care to sympathize with you.  I'm telling you the best path to understanding that I know.
16:55:52 <Philippa> for that matter, do you know the usual encoding of let in the untyped lambda calculus?
16:56:07 <pmetzger> ddarius: if you cannot sympathize with the student's state of mind, you cannot teach.
16:56:13 <pmetzger> Philippa: Yes.
16:56:19 <mauke> pmetzger: what is 'return a b'?
16:56:19 <ddarius> pmetzger: I'm not trying to teach you either.
16:56:34 <pmetzger> ddarius: I thank you for your help then.
16:56:39 <hydo> I don't suppose that there is a go-to package for handling money?  Mainly I'm looking for something that handles rounding correctly before I go write it myself.  I tried Decimal but its rounding is off for money.  ie. .005 rounds to .00 instead of .01
16:56:59 <pmetzger> mauke: isn't return a one-parameter item?
16:57:00 <parcs> hydo: Data.Fixed
16:57:06 <mauke> pmetzger: depends
16:57:15 <mauke> hydo: which rounding mode do you want?
16:57:15 <hydo> parcs: ooo!  looking now...
16:57:25 <pmetzger> mauke: so since functions bind more tightly, it would form (M a) b
16:57:35 <Philippa> pmetzger: okay. Can you write me >>= for the Identity monad?
16:57:36 <pmetzger> or (m a) b I suppose
16:57:37 <hydo> mauke: the one that handles cents correctly :)  hehe  whichever mode that is.
16:57:41 <sohum> is there a module of functions written specifically for sorted lists?
16:57:46 <hydo> Looking at fixed now...
16:57:49 <ddarius> sohum: Yes.
16:57:53 <pmetzger> Philippa: what is the identity type?
16:57:53 <mauke> hydo: what do you mean by "correctly"?
16:58:08 <Philippa> pmetzger: newtype Id a = Id a
16:58:22 <sohum> ddarius: would you be kind enough to tell me what it is? :P
16:58:38 <hydo> mauke: 1.001 -> 1.00  1.005 -> 1.01  1.004 -> 1.00
16:58:39 <Philippa> but for pedagogical purposes, assume it's just a
16:58:39 <mauke> pmetzger: you mean at the type level? that would be wrong; m only takes one arg
16:58:44 <ddarius> sohum: If I remembered the name of the package.  Something like data-ordlist or some such.
16:58:45 <dons> hydo: the Fixed module
16:58:51 <sohum> ddarius: thankee
16:58:57 <mauke> hydo: that's just some examples
16:59:10 <pmetzger> Philippa: so for the identity type, return x = Id x ?
16:59:10 <Philippa> (it's not typeclassable for Haskell, I know, but we're writing something isomorphic to it and it's easier to make my point if we elide nagivating the isomorphism)
16:59:15 <Philippa> pmetzger: yep
16:59:30 <Philippa> or alternatively x, if we assume Id x ~ x
16:59:41 <hydo> mauke: Yep.  do they not correctly illustrate what I'm trying to accomplish?
16:59:43 <Philippa> (won't typecheck, but let's talk pidgin haskell rather than haskell for a moment)
16:59:49 <hydo> err, clearly
17:00:02 <pmetzger> Philippa: and then >>= would have to be of type Id a -> (a -> Id b) -> Id b?
17:00:08 <mauke> hydo: not really
17:00:13 <dibblego> pmetzger: prexactly
17:00:30 <hydo> mauke: oh well. Don't sweat it.
17:00:51 <Eduard_Munteanu> But since Id x ~ x...
17:01:04 <Philippa> pmetzger: yep. Or just a -> (a -> b) -> b, for convenience's sake
17:01:26 <sohum> ddarius: grah. unfortunately, it doesn't have a difference-of-sorted-lists. I'll just have to write it myself
17:01:32 <pmetzger> so >>= has to be >>= (Id a) f = f a ?
17:01:39 <pmetzger> I feel like that is wrong.
17:01:57 <dibblego> pmetzger: that won't type-check, remember you have to wrap/unwrap values
17:01:58 <Eduard_Munteanu> It's fine.
17:02:10 <mauke> dibblego: really?
17:02:16 <dibblego> oh shit sorry
17:02:20 <shachaf> dibblego: It'll type-check, just not syntax-check. :-)
17:02:22 <mauke> I would have thought that's exactly right
17:02:26 <dibblego> was thinking fmap
17:02:29 <Philippa> pmetzger: you've got the right thing
17:02:30 <dibblego> totally sorry
17:02:34 * dibblego back to writing scala
17:02:39 <parcs> pmetzger: you can write that as Id a >>= f = f a to avoid a set of parens
17:02:49 <rostayob> natural deduction in the type system: http://pastebin.com/bqbdF9Wv :D
17:02:58 <ddarius> sohum: What do you think minus does?
17:03:01 <pmetzger> oh, sorry about the syntax. I keep forgetting that infix has to be done with parens etc.
17:03:06 <Philippa> pmetzger: now for the fun bit - what's foo >>= (\a -> bar) expand out to?
17:03:21 <pmetzger> Philippa: using this definition?
17:03:43 <Philippa> yeah
17:04:10 <pmetzger> I have to destruct foo to remove the value within, but presuming bar is a constant, the whole thing is just bar.
17:04:15 <sohum> ddarius: the... negate operator?
17:04:20 <ezyang> Questions on Haskell StackOverflow get answered too quickly :-<
17:04:24 <Philippa> pmetzger: no, just expand >>=
17:04:35 <Philippa> foo and bar are arbitrary expressions
17:04:55 <shachaf> ezyang: Too quickly for you to answer them?
17:05:04 <sohum> ddarius: oooh, the minus operator in Data.Ordlist
17:05:08 <sohum> ddarius: excellent, thank you!
17:05:14 <pmetzger> Philippa: I need a function that destructs an Id then
17:05:20 <Eduard_Munteanu> I've even seen a few Agda questions, sadly not too many I think.
17:05:28 <Philippa> no, you don't, because an Id x is an x for the purpose of discussion
17:05:28 <dmwit> Philippa: I feel pretty confident about monads, and even I don't really know what you're asking.
17:05:34 <pmetzger> something like (\a -> bar) foo then.
17:05:47 <pmetzger> apply (\a -> bar) to foo
17:05:49 <mauke> dmwit: inline >>=
17:05:56 <Philippa> okay. What else 'expands to' (\a -> bar) foo that I've mentioned recently?
17:06:27 <shachaf> Come on, not fair working backwards from the specific answer that you're trying to get to.
17:06:31 <mauke> it's scheme! I know this!
17:06:50 <Philippa> let a = foo in bar (standard sugar in untyped lambda calculus)
17:06:51 * mauke navigates 3d conses
17:07:08 <pmetzger> yes.
17:07:12 <pmetzger> thus the name bind.
17:07:36 <Philippa> yeah. All other implementations of bind do the same, only for languages that do extra things as well
17:08:07 <pmetzger> it is especially the "extra things" that are an irritant. :|
17:08:12 <dibblego> dmwit: (>>=) :: f a -> (a -> f b) -> f b and therefore also, f (f b) -> (f b -> f b) -> f b
17:08:15 <shachaf> Philippa: FSVO "extra".
17:08:34 <Philippa> shachaf: well, sometimes the "extra" is to forget all the results for you and return undefined, sure
17:08:55 <pmetzger> btw, pure curiosity -- why is ">>=" the symbol picked for "bind"?
17:09:14 <pmetzger> is it arbitrary given the desire to use >> as a "this then that, throw this away" operator?
17:09:14 <ddarius> Because all the good operators were taken.
17:09:34 <shachaf> "(>>=) should be read as the monster on the left expelling values through its rows of teeth and over its tongue at the function on the right."
17:09:34 <Philippa> plus the directionality, plus wanting = in there somewhere as a reference to binding, I imagine
17:09:38 <pmetzger> with the "=" being reminiscent of assignment?
17:09:41 <nihtml> :t stripPrefix
17:09:42 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
17:09:53 <nihtml> good
17:09:54 <pmetzger> gotcha.
17:10:51 <Philippa> anyway, when you see someone use >>= manually you can make up a fresh variable and mentally read it as a let/do statement instead if that helps
17:10:52 <Eduard_Munteanu> There's also (>=>) and (<=<) if you want a more compositional style.
17:10:55 <pmetzger> I think mostly this is a question of my doing five finger exercises with all the available toy examples and staring at it until it feels more natural.
17:10:57 <Eduard_Munteanu> :t (<=<)
17:10:58 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
17:11:05 <Eduard_Munteanu> :t (.)
17:11:05 <nihtml> fish
17:11:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:11:18 <Philippa> yeah, if you get the basics then it's just a matter of burning identifiers and patterns into your head
17:11:19 <Eduard_Munteanu> Bah.
17:11:23 <Eduard_Munteanu> :t (Prelude.)
17:11:24 <lambdabot> Not in scope: data constructor `Prelude'
17:11:30 <Eduard_Munteanu> :t Prelude..
17:11:31 <lambdabot> parse error on input `Prelude..'
17:11:39 <dmwit> :t (Prelude..)
17:11:40 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:11:43 <Eduard_Munteanu> Oh.
17:11:44 <dmwit> :t Prelude.(.)
17:11:45 <lambdabot> Not in scope: data constructor `Prelude'
17:11:52 <pmetzger> Philippa: the problem isn't my working out the examples, it is getting to the point where I don't think about it. It is the distinction between knowing how to drive a car in theory and being comfortable driving a car.
17:12:19 <pmetzger> Philippa: every eight year old "knows" how to drive a car. turn the wheel in the direction you want to go, push gas to go faster, brake to go slower. except they don't actually know how to drive.
17:12:45 <Philippa> yeah. Here's the good news: this really /is/ it. You've got all the knowledge you need
17:12:47 <pmetzger> Philippa: achieving the point where something is natural is the issue, and this is not yet natural for me. it is "I know in theory how it works" still, not deep in.
17:13:06 <pmetzger> I think that's another week or two of doing it constantly.
17:13:09 <Philippa> so practice is all you need, no more stumbling blocks you can't get through just by bashing it through
17:13:55 <pmetzger> well, there is *one* other issue. reading code and getting it is one thing, seeing where to apply the monad paradigm to make my code simpler is another.
17:14:05 * ddarius thinks that the problem most eight year olds would have is reaching the pedals while seeing over the steering wheel.
17:14:06 <pmetzger> one has to be able to reason naturally in both directions I think.
17:14:17 <pmetzger> ddarius: you don't have beginner's mind. :)
17:14:28 <pmetzger> ddarius: you know how to drive?
17:14:35 <Philippa> yeah. If you already had your code in monadic form it'd actually be really easy to tell
17:14:44 <Philippa> want me to explain that a little?
17:14:50 <pmetzger> Philippa: please.
17:15:19 <monochrom> people become "natural" drivers by driving 40 hours a day
17:15:23 <Philippa> okay. Really by monadic form I mean 'monadic normal form', where all the intermediates are bound. So it's all big do statements
17:15:27 <Eduard_Munteanu> Well, inasmuch as other non-beginners don't, but you wouldn't ask a beginner anyway :)
17:15:35 <pmetzger> monochrom: actually, just driving an hour or two a day for months will do it.
17:15:35 <ddarius> monochrom: Days are long in Canada.
17:15:49 <pmetzger> monochrom: no need to drive more hours than a day has.
17:15:51 <monochrom> well, say for haskell
17:15:55 <monochrom> err
17:15:59 <monochrom> well, same for haskell
17:16:13 <Philippa> so suppose I keep writing this: do (result, state1) <- f foo bar baz state0; g quux state1
17:16:29 <Philippa> you can see the pattern there really obviously, right?
17:16:31 <Eduard_Munteanu> (although at times, peer studying is helpful)
17:16:49 <Philippa> state goes in, new state comes out with the answer
17:17:04 <pmetzger> Philippa: I know that if I write pure functional code in other languages I have to pass the state around explicitly in an irritating way...
17:17:37 <pmetzger> I just wrote a non-monadic lexical analyzer in Haskell and it was irritating to pass the remaining string and position around explicitly.
17:17:54 <Philippa> similarly: do f foo bar env; g baz quux env; h flibble (("WTF?", undefined):env); return ()
17:18:03 <Philippa> there's a pattern in that one too, yeah?
17:18:06 <pmetzger> yah.
17:18:11 <Philippa> can you tell which monad that one's the pattern for?
17:18:21 <pmetzger> I can guess, but I don't know.
17:18:24 <Philippa> that one's Reader
17:18:40 <pmetzger> I was going to guess wrong. :)
17:18:51 <pmetzger> ah, dinner time for me. Thank you so much for the help!
17:18:53 <pmetzger> bbl.
17:18:55 <Eduard_Munteanu> The first one was State though.
17:18:58 <Philippa> yep
17:19:21 <Philippa> the difference being that the second one doesn't take in new versions of 'env' as a result anywhere
17:22:20 <Philippa> anyone else find the idea of using monadic normal form to make the patterns stand out further useful, btw?
17:22:50 <Philippa> (I'm not advocating that people rewrite their code to it, unless they're really stuck figuring it out, just that people "think through that transform")
17:23:40 <monochrom> yes
17:24:39 <monochrom> I use a sequence of "let x=y" instead of "x<-y". it's the same thing modulo notation
17:24:48 * ddarius recommends people read the paper where Moggi introduced his "computational metalanguage."
17:25:13 <Philippa> monochrom: yeah, include do and it's a transliteration even
17:25:14 <monochrom> I came from sml, so "let x=y" really is "x<-y". and also same notation Moggi used
17:25:16 <dibblego> I did that once in a talk on the reader monad
17:25:22 <dibblego> replace = with <- that is
17:25:27 <ddarius> monochrom: Indeed.
17:26:11 <Eduard_Munteanu> Related Agda blurb: in Agda do notation is just a syntax decl:  syntax bind f (\a -> g) = a <- f , g
17:26:15 <Eduard_Munteanu> (if I didn't mess it up)
17:26:34 <monochrom> the most glaring example is
17:26:45 <Philippa> ddarius: I'd do that more, I think a popularisation of it might be worthwhile. Only these days I think everyone'd call it yet another monad tutorial
17:26:47 <monochrom> @src readIO
17:26:47 <lambdabot> Source not found. You type like i drive.
17:26:51 <monochrom> oh well
17:26:54 <monochrom> @src read
17:26:54 <lambdabot> read s = either error id (readEither s)
17:26:59 <monochrom> oh well again
17:27:29 <monochrom> the most glaring example is [ x | (c,s') <- reads s, (d,s'') <- read s' ... ]
17:27:35 <Eduard_Munteanu> So it's easy to express as a binder brought in the scope, makes it obvious what it does.
17:28:38 <Philippa> ooh, agda has syntax declarations now? That might just tip the balance on the whole "I really ought to learn this" thing
17:29:27 <Eduard_Munteanu> And "typeclasses" in latest darcs ;)
17:29:51 <Eduard_Munteanu> (I thought that was quite a major blocker)
17:32:30 <Philippa> if I absolutely insist on working on an embedded turing complete language that I'll only do local proofs about, how hard is that to do? I'm guessing about as hard as writing the non-termination monad for my preferred evaluation strategy?
17:33:31 <Philippa> (translation: am I going to be able to happily use Agda on the days I don't want to have to prove much too?)
17:35:05 <Eduard_Munteanu> Well I think so, Agda's sense of a normal form is quite aggresive. So if you have a term that can be reduced to a value at compile time, computing the normal form will yield exactly that.
17:35:23 <ddarius> Philippa: You could just run everything in a state monad that has a count-down ticker.
17:35:40 <Eduard_Munteanu> Wait, you want something else.
17:35:56 <ddarius> Philippa wants to actually program.
17:36:13 <Philippa> I'm asking if I can use Agda as a Haskell replacement as well, yeah
17:36:47 <Philippa> (assuming I'm not relying on the RTS particularly)
17:37:08 <Eduard_Munteanu> Writing bindings is kinda tedious.
17:37:15 <Eduard_Munteanu> (to Haskell I mean)
17:37:52 <Eduard_Munteanu> I haven't tried much myself, just interfaced with ST, STArrays, played with array bounds check elimination (with dependent types) and that stuff.
17:38:09 <Philippa> to what extent do you need or at least really really want unicode in your editor with it?
17:38:56 <ddarius> Conor tends not to use Unicode too much in Agda, but everyone else does it seems, so you have the library problem.
17:39:06 <parcs> cabal by default compiles with -O2, correct?
17:39:06 <Eduard_Munteanu> Unicode is really nice to have, esp. given the stdlib definitions. Now the question is rather whether you really need Emacs, assuming you're a Vim-head too ;)
17:39:22 <monochrom> cabal defaults to -O
17:39:23 <dcoutts> parcs: -O is the default
17:39:24 <Philippa> mostly I use jEdit
17:39:25 <mauke> parcs: unlikely
17:39:39 <Eduard_Munteanu> Vim can handle Unicode input.
17:39:42 <parcs> hmm...
17:40:00 <Eduard_Munteanu> But it won't handle proof stuff like holes, basically interactive editing. Not really necessary for _programming_.
17:40:10 <Eduard_Munteanu> Though for proofs it kinda is.
17:40:13 <ddarius> jEdit is also not emacs.
17:40:40 <parcs> how can i have cabal compile with -O2?
17:40:46 <Philippa> if it can do a "reload-and-continue" on proofs that'll probably suffice
17:40:59 <Philippa> I don't mind having to shunt around the interactivity by hand a little bit
17:41:47 <Philippa> failing that, I figure out how many people scream if you start writing an Eclipse plug-in for it ;-)
17:42:39 <dcoutts> parcs: cabal configure -O2
17:42:50 <Eduard_Munteanu> Well, you don't need any interactivity if you get your proofs right without any help from Agda ;)
17:43:12 <dcoutts> parcs: and -O0 when you're doing developer builds rather than release builds
17:43:20 <Eduard_Munteanu> But then again it also has Agsy/Auto, an automatic solver which may come in handy on tedious work.
17:43:36 <parcs> dcoutts: thanks
17:43:43 <Eduard_Munteanu> For programming you don't really need interactivity at all I guess.
17:43:59 <Philippa> yeah, ultimately I want room to do both of course. Life's never perfect though
17:44:26 <Philippa> but it sounds like it's a candidate for my metalanguage of choice now
17:44:40 <Eduard_Munteanu> Oh, and I forgot, with any other editor syntax highlighting will be flaky at best.
17:44:59 <Eduard_Munteanu> With Emacs it relies on compiler support, although some regexps are available for Vim and such.
17:45:39 <Eduard_Munteanu> (though recently I hear it can generate syntax highlighting for Vim too, but I'm unsure it's integrated with it)
17:46:04 <Eduard_Munteanu> (as in you might need to call agda manually)
17:47:21 <hydo> Do any of you have emacs set up with flymake?  I like it a lot, but I'm starting to wonder if it's not making me lazy.
17:47:28 <argiopeweb> I can't seem to find an authoritative answer to how arrays are implemented in Haskell. I'm currently running under the impression that it's compiler-specific and generally implemented C style with concurrent memory. Am I mistaken?
17:48:00 <NihilistDandy> hydo: I did, while I was using emacs
17:48:06 <Eduard_Munteanu> argiopeweb: yes, it boils down to a compiler primitive, if that's what you're asking.
17:48:08 <argiopeweb> hydo: I've got it. It will make you lazy if you let it, and the blue text is annoying. I leave it on hlint mode.
17:48:09 <ddarius> Wtf is "concurrent memory"?
17:48:34 <Eduard_Munteanu> You can't define (read, come up with) arrays in plain Haskell.
17:48:41 <argiopeweb> ddarius: As opposed to Java/Python/their ilk which use references to non-concurrent memory.
17:48:51 <NihilistDandy> Also, hydo: http://en.wikipedia.org/wiki/Larry_Wall#Virtues_of_a_programmer
17:49:08 <ddarius> argiopeweb: That didn't answer my question.  Do you mean "contiguous"?
17:49:25 <Cale> argiopeweb: In GHC, there are lots of array implementations to choose from. The plain Array type is implemented as an contiguous block of memory containing boxed values (pointers to code)
17:49:25 <argiopeweb> I do, I just haven't slept for 36 hours. My apologies.
17:49:38 <Eduard_Munteanu> He might mean shared memory in presence of destructive updates.
17:49:42 <Eduard_Munteanu> Ah.
17:50:11 <argiopeweb> Nope, I mean contiguous. I'm just out of it.  Apparently all words in excess of 8 letters beginning with 'c' are now the same.
17:50:39 <Cale> argiopeweb: UArray and other unboxed array types are limited in what data they can hold, but are stored as a contiguous chunk of memory holding actual values, and thus if any element needs to be evaluated, the entire array must be.
17:50:46 <hydo> argiopeweb: hrm... I keep forgetting that I can switch the modes.
17:50:47 <Cale> (which is the price of compact representation)
17:50:51 * theorbtwo hopes argiopeweb isn't contagious.
17:51:15 <Eduard_Munteanu> califragilisticexpialidocious ?
17:51:15 <argiopeweb> theorbtwo: Internet aids can't be spread through text contact. ;)
17:51:21 <Eduard_Munteanu> :P
17:51:26 <argiopeweb> Eduard_Munteanu: Right, that kind of memory.
17:51:52 <theorbtwo> Eduard_Munteanu++
17:52:41 <Eduard_Munteanu> In fact, Google++, I couldn't remember more than the first 6 letters and a mere shape of how it looked ;)
17:52:44 <argiopeweb> Cale: Thanks. I will cease attempting to imagine a world where we can skip around lists at random.
17:53:16 <Cale> Oh, and lists are of course not the same as arrays
17:53:18 <argiopeweb> Search: "big word starting with c from Mary Poppins"
17:53:25 <argiopeweb> Cale: Of course.
17:53:39 <Eduard_Munteanu> argiopeweb: nah, Google suggestions
17:53:41 <Eduard_Munteanu> :)
17:53:46 <argiopeweb> Eduard_Munteanu: hehe, that works too.
17:54:48 <argiopeweb> Cale: Lists and I are old friends from implementing Lisp in hardware. Moving them to the world of software is easy, even adding laziness.
17:55:15 <Eduard_Munteanu> Ow, Lithp machines.
17:55:36 <argiopeweb> Stack based, no less.
17:56:06 <argiopeweb> Why I didn't just design a forth machine and write an interpreter on it, I'll never know...
17:58:32 <Eduard_Munteanu> I'm still curious whether there is (could be) something more powerful than inductive data types that could do arrays. And maybe extend beyond just that, otherwise it wouldn't be very interesting to have as a language feature.
17:59:53 <Eduard_Munteanu> Maybe some sort of inductive data families indexed by naturals, with some compiler heuristics to automatically turn that into array-based storage?
18:00:25 <MHD0> Are there arbitrary precision floating point in haskell?
18:01:34 <Eduard_Munteanu> Hrm, not sure, CReal?
18:02:08 <ddarius> @hackage mpfr
18:02:09 <lambdabot> http://hackage.haskell.org/package/mpfr
18:03:05 <Eduard_Munteanu> @hackage hmpfr
18:03:05 <lambdabot> http://hackage.haskell.org/package/hmpfr
18:03:18 <kmc> CReal is not arbitrary precision floating point
18:03:22 <kmc> neither is Rational
18:03:24 <Eduard_Munteanu> Hrm, @hackage should probably check
18:03:27 <kmc> however they both may do what you actually want
18:03:59 <kmc> does "arbitrary precision" mean no inexact results ever, or just that you set a fixed arbitrarily large precision before you start?
18:05:04 <Philippa> after, I think
18:05:11 <Philippa> well, in some contexts it does
18:05:15 <Eduard_Munteanu> The first was called something else I think.
18:05:31 <dmwit> kmc: The consumer chooses the precision, not the producer.
18:06:04 <dmwit> There's a Fixed type somewhere that lets the producer choose the precision.
18:06:49 <dmwit> Oh, I see that's already been linked.
18:07:34 <dmwit> Also, I now see that you were asking MHD0 for clarification, not asking because you yourself didn't know the difference. Apologies. =P
18:07:51 <kmc> i don't know the difference
18:08:03 <kmc> i mean, i don't know which is meant by the phrase
18:08:17 <kmc> but i'm also not willing to assume that the term is used consistently ;P
18:08:23 <dmwit> yes =)
18:08:29 <MHD0> I just need like ~200 something decimals, preferably based of the same logic that runs Integer
18:08:43 <kmc> allowing the consumer to choose the precision sounds like a use case for lazy lists of digits or something
18:08:44 <dmwit> > show (pi :: CReal)
18:08:45 <lambdabot>   "3.1415926535897932384626433832795028841972"
18:08:47 <kmc> MHD0, how about Rational then?
18:08:59 <kmc> CReal is a different (and very strange) beast
18:09:12 <kmc> for example, pi has an exact representation as a CReal, while no Rational equals pi
18:09:19 <MHD0> kmc: Can you read a Rational as a decimal number?
18:09:22 <gwern> > log (10^31)
18:09:23 <lambdabot>   71.38013788281542
18:09:32 <kmc> MHD0, you can get the digits...
18:09:46 <kmc> by repeatedly dividing by ten (but there's probably a better way)
18:09:47 <gwern> > 2^72 - 10^31
18:09:48 <lambdabot>   -9999999995277633517130354786304
18:10:03 <gwern> > (2^72::Integer) - (10^31::Integer)
18:10:04 <lambdabot>   -9999999995277633517130354786304
18:10:13 <MHD0> kmc: It's for a compiler, and I want to implement compile time math with AP
18:10:23 <gwern> hrm. I rounded up, and I thought 'log' was log_2
18:10:27 <kmc> ok, then Rational sounds like a great choice
18:10:35 <kmc> > read "1.3333333333333333333333" :: Rational
18:10:35 <lambdabot>   *Exception: Prelude.read: no parse
18:10:39 <kmc> :/
18:10:43 <MHD0> Yeah
18:10:56 <MHD0> Not going to add up all them decimals
18:11:01 <kmc> that's unfortunate, because if you wrote that as a Haskell program literal, it would go through Rational
18:12:16 <MHD0> I've been thinking of maybe implementing like a low level routine with some (# Int#,  Int#, ByteArray# #)
18:12:35 <MHD0> and using the inbuilt Integer things in GHC.Num
18:13:10 <kmc> what do the components of that tuple represent?
18:13:21 <hydo> Re: my problem rounding money.  I'm not sure what I'm missing in the docs or otherwise: http://hpaste.org/46348/mo_money_mo_problems
18:13:31 <kmc> awesome paste title
18:13:36 <hydo> thanks!
18:13:50 <MHD0> kmc: Int and ByteArray represents the Integer, the last Int an exponent, as in IEEE something something
18:14:08 <monochrom> with no money comes no problems. with no power comes no responsibility
18:14:44 <monochrom> more seriously, have you heard of "round towards even"?
18:15:00 <argiopeweb> MHD0: You could always create rationals and then implement division like you were taught to do long division in elementary school to a new data type with Integers...
18:15:03 <hydo> with no correct rounding, my little company gets sued into oblivion when multiational_shoe_manufacturer figures out it's losing a cent per 100 transactions.
18:15:03 <gwern> but money is the root of evil, and 0^2 or higher is 0 - so the bankrupt are innocent
18:15:24 <monochrom> > round 10.5
18:15:25 <lambdabot>   10
18:15:28 <monochrom> > round 11.5
18:15:29 <lambdabot>   12
18:15:31 <monochrom> \∩/
18:15:47 <gwern> > logBase 2 (10^31)
18:15:48 <lambdabot>   102.97977094150824
18:15:57 <dmwit> > 1.3333333333333333333 :: Rational -- kmc ?
18:15:57 <lambdabot>   13333333333333333333 % 10000000000000000000
18:16:05 <gwern> > (2^103) - (10^31)
18:16:06 <lambdabot>   141204801825835211973625643008
18:16:11 <colinhect> Using 'ghc --make Main' works fine.... However I want to compile for profiling so I use 'ghc -prof -auto-all --make Main' but it fails to find/load some modules.   Any ideas?
18:16:13 <dmwit> > 4 / 3 :: Rational
18:16:13 <lambdabot>   4 % 3
18:16:17 <gwern> ok, there we go. wonder what base 'log' is using
18:16:20 <gwern> @src log
18:16:20 <lambdabot> Source not found. You speak an infinite deal of nothing
18:16:22 <monochrom> I heard that some banks also do round-to-even. it is more fair
18:16:32 <kmc> colinhect, you have to install profiling versions of whatever libraries you're importing
18:16:36 <monochrom> just to support that round-to-even is not wrong for money
18:16:37 <MHD0> It is just retarded that GHC uses GMP for Integer but does not implement the AP Floats that GMP provide...
18:16:48 <kmc> edit ~/.cabal/config and set "library-profiling: True"
18:16:51 <kmc> (so this won't happen again)
18:17:00 <kmc> then cabal install --reinstall foo
18:17:06 <colinhect> kmc: Thank you that is perfect
18:17:33 <kmc> MHD0, yes, and GHC's use of GMP prevents you from using it yourself (or via MPFR) without serious fail
18:17:59 <MHD0> kmc: Yeah. fail
18:18:49 <colinhect> kmc: What if it is the base package?  It won't let me reinstall that.
18:18:55 <kmc> yeah
18:19:00 <kmc> where did you install ghc from?
18:19:05 <colinhect> ubuntu 11.04
18:19:13 <argiopeweb> colinhect: You should still be able to install base-prof (or whatever it's called)
18:19:29 <monochrom> the base package has profiling
18:19:45 <monochrom> unless you mean you use the substandard "apt-get install ghc"
18:19:52 <kmc> apt-get install ghc6-prof
18:19:54 <kmc> or something
18:20:17 <colinhect> kmc: Thanks I will try that.
18:20:28 <colinhect> monochrom: Why do you say that is substandard?
18:21:13 <monochrom> most of us have switched to ghc 7.0.2 or 7.0.3 for months
18:21:28 <colinhect> I see.  Maybe I will eventually switch.
18:21:34 <colinhect> Thanks for the help everyone.
18:21:47 <hydo> monochrom: I had to do that in ghci myself before I completely belived your 'round' adventure.  Surely that doesn't mean that I'm screwed if I simply want to round correctly, though that's kinda what it looks like.
18:22:09 <monochrom> by the time ubuntu 11.11 is released, it will barely switch to 7.0.1
18:22:52 <monochrom> I refuse to agree with such judgemental words as "correctly"
18:24:07 <hydo> welp, I guess I can do it in java.
18:24:11 <hydo> (lawl)
18:24:28 <monochrom> you can multiply by 10, or 100, or 1000... then add 5, then floor, then divide back by 10, or 100, or 1000...
18:24:48 <monochrom> > floor (10.5 * 10 + 5) / 10
18:24:48 <lambdabot>   Ambiguous type variable `b' in the constraints:
18:24:49 <lambdabot>    `GHC.Real.Integral b'
18:24:49 <lambdabot>   ...
18:25:15 <monochrom> > floor (10.5 * 10 + 5) `div` 10
18:25:16 <lambdabot>   11
18:25:33 <monochrom> that is how you obtain your desired rounding
18:25:58 <monochrom> @let wrong'round x = floor (x * 10 + 5) `div` 10
18:25:59 <lambdabot>  Defined.
18:26:17 <hydo> oh, hurr... I forgot that I'm not rounding numbers, I'm trying to round _money_ ... there's nothing wrong with round.
18:26:20 <hydo> yea
18:26:24 <hydo> ok, all is right with the world.
18:26:44 <monochrom> > map wrong'round [10, 10.001, 10.499, 10.5001, 10.999]
18:26:47 <lambdabot>   [10,10,10,11,11]
18:27:22 <monochrom> well like I said some banks use round-to-even too to be more fair. so it is not wrong for money either
18:28:10 <hydo> good point.  worth an email to confirm one way or another just to be safe.
18:28:44 <monochrom> your bottomline should be: you and your client negotiate and agree on a rounding scheme, then find a way to code it up
18:29:22 <monochrom> rather than just calling it right or wrong
18:29:41 <monochrom> because, if I were your client, I would want you to round to even. how dare you call it wrong
18:31:07 <monochrom> java also does 10.5 -> 10. basically any ieee-754-based schemes do, by default. I even forgot whether it is configuration or not
18:31:29 <argiopeweb> monochrom: The proper way to do it clearly to multiply, cast to int, then use sprintf for formatting into a char *. ;)
18:31:46 <monochrom> only difference between java and ieee-754 is about 0. no difference on rounding
18:31:59 <monochrom> heh
18:32:02 <kmc> how do they differ on 0?
18:32:11 <hydo> the java jab was a java joke
18:32:11 <monochrom> oh, I now remember, it's configurable
18:32:21 <hydo> err, a joke, rather.
18:32:29 <monochrom> ieee-754 has +0 and -0. java has only one 0.
18:32:30 <hydo> that wasn't near as funny when typed out as it was in my head.
18:32:49 <argiopeweb> hydo: No, it was. I just laughed privately.
18:33:51 <argiopeweb> Horrid abomination of a language. (says the guy who went from QBasic to Assembler to C to C++ to Common Lisp to Haskell, then was forced to pick up Java)
18:34:13 <monochrom> I once ran a programming contest and gave out a question on rounding-to-even. people went out of their ways to write 5 lines of algorithms to do that.
18:34:23 <kmc> ah, because Java committee's mythical "average programmer" can't understand +/- 0
18:34:49 <monochrom> they must be really horrified that by default a single line of c "answer = (int)input" does it
18:35:09 <monochrom> err, actually "answer = (int)(input + 0.5)"
18:35:46 <mauke> except when input is negative
18:35:48 <monochrom> no, sorry, not that. "answer = round(input)"
18:36:02 <argiopeweb> One of those things....
18:36:08 <Zao> monochrom: Which language and standard are you using?
18:36:16 <Zao> That's C99 or some silly Posix.
18:36:40 <monochrom> c and the assumption that it's ieee-754 underneath (well it's x86) and nothing mucks with the default
18:36:48 <mauke> which C?
18:36:52 <monochrom> gcc
18:36:57 <mauke> which gcc?
18:37:07 <kmc> -ffast-math :D
18:37:07 <argiopeweb> 2.7
18:37:13 <monochrom> gcc 3.x? I forgot
18:37:15 <mauke> furthermore, ISO C89, GNU C89, ISO C99, or GNU C99?
18:37:24 <argiopeweb> monochrom: 'grats, it won't compile now. :P
18:37:26 <mauke> wait, it's ISO C90
18:37:28 <argiopeweb> mauke: K&M
18:37:37 <monochrom> M&M C
18:37:37 <kmc> Þe Olde C
18:37:53 <argiopeweb> B anyone?
18:37:54 <kmc> if K&R C was good enough for Jesus then it's good enough for me
18:38:16 <argiopeweb> K&R, even... I really need some sleep. :\
18:43:43 <monochrom> @undefine
18:43:44 <MHD0> omg this is bullsh*t
18:44:01 <MHD0> Java does better than Haskell at AP floats!
18:44:07 <monochrom> bullsh*t is organic all-natural fertilizer. it's good
18:45:13 <MHD0> good 'effing god
18:45:57 <nihtml> hello
18:46:09 <nihtml> main = putStr "> " >> fmap (show . calc . parser . lexer) getLine >>= putStrLn
18:46:31 <MHD0> nihtml: use the paste
18:46:38 <monochrom> main = putStr "> " >> hFlush stdout >> fmap (show . calc . parser . lexer) getLine >>= putStrLn
18:46:41 <argiopeweb> MHD0: Easy answer: You're doing it wrong.
18:46:54 <kmc> HASKELL IS BEST LANGUAGE
18:46:54 <nihtml> why is the ">" shown after getLine?
18:47:07 <monochrom> if I answer, will you read?
18:47:14 <kmc> nihtml, because console IO is line-buffered?
18:47:26 <nihtml> of course monochrom
18:47:27 <kmc> you can't really make assumptions about how stdout / stderr / stdin will interleave
18:47:35 <kmc> try a (hFlush stdout) but no promises
18:47:38 <monochrom> then see above. I answered before you asked
18:47:55 <MHD0> argiopeweb: Thank you, wouldn't have found out
18:48:03 <nihtml> hm, ok
18:48:14 <MHD0> kmc: Not at AP floats, good effing god
18:48:37 <kmc> MHD0, you're using the canonical Internet question strategy i see
18:48:48 <argiopeweb> kmc: Well put.
18:49:04 <MHD0> Ikmc: yeah, I'm a little worked up atm byt this issue
18:49:05 <argiopeweb> MHD0: What is it that you're trying to do again?
18:49:09 <monochrom> organic fertilizer is good for your health
18:49:33 <MHD0> I'm trying to find some GMP or whatever AP float lib that is not hideously complicated...
18:50:05 <MHD0> Needs to do like ~200 places or watevs
18:50:22 <monochrom> have you found one on hackage?
18:50:51 <MHD0> monochrom: I have BigFloat but that is base 10, and the trig functions are imprecise.
18:51:03 <monochrom> I see. I don't know of one
18:51:31 <monochrom> well, haskell lacks funding
18:51:38 <MHD0> Yeah
18:51:39 <argiopeweb> MHD0: If it doesn't exist on hackage, which it should, I highly recommend either the FFI to GMP, or a 40 line long-division library harnessing 2 integers (digits and decimals)
18:51:56 <argiopeweb> Which you would then put on hackage so I don't have to write it. :P
18:51:58 <MHD0> Maybe I should donate
18:52:16 <monochrom> if sun or oracle funded me like they funded java, I would have finished a better AP float lib and a whole cobra binding suite already
18:52:20 <MHD0> I need something robust though, it's for a compiler project...
18:52:40 <argiopeweb> Both of my options are robust.
18:52:58 <argiopeweb> Though I do wonder why you need 200 digit decimal precision in a compiler.
18:53:25 <argiopeweb> Unless you're creating a data type with 200 digit decimal precision, of course.
18:53:36 <pmetzger> arbitrary decimal precision in a compiler is often quite useful.
18:53:46 <pmetzger> it allows you to guarantee identical results in cross compilers.
18:53:55 <kmc> Haskell doesn't lack funding
18:53:59 <pmetzger> one huge problem people have is when cross compilers on different architectures produce different results.
18:54:05 <kmc> the Industrial Haskell Group already paid for one GMP-related project
18:54:09 <kmc> ("get rid of GMP")
18:54:31 <kmc> Haskell is popular for pricing financial products
18:54:37 <kmc> you think they might be interested in this sort of thing
18:54:38 <monochrom> oh, I know. check out http://hackage.haskell.org/package/numbers
18:54:43 <pmetzger> pricing financial products doesn't require giant precision.
18:54:59 <kmc> maybe not 200 digits, usually
18:55:00 <monochrom> darn, perhaps that's what you found
18:55:09 <argiopeweb> monochrom: Yeah, that's bigfloat
18:55:11 <pmetzger> even not more than double precision floats.
18:55:17 <kmc> that depends
18:55:19 <pmetzger> at least not for most models.
18:55:21 <kmc> on what you're actually pricing
18:55:23 <monochrom> well, you could try its CReal instead...
18:55:29 <kmc> some third-order derivative of something
18:55:36 <pmetzger> even then, I don't think.
18:55:40 <MHD0> I want to emulate Google Go's functionality of AP compile time math
18:55:48 <monochrom> I should say, steal its CReal source code and change the magic number "40" to "200" throughout
18:56:01 <argiopeweb> rofl...
18:56:05 <pmetzger> I've never dealt with anything more than models for things like CDOs, but...
18:56:26 <tswett> Orthogonal persistence in Haskell: callCC show
18:56:33 <pmetzger> (and even then I wasn't so intimately involved, but the calculations were all pretty standard numerical techniques...)
18:56:44 <pmetzger> good night...
18:56:55 <monochrom> (is that why CDOs went burst?)
18:57:21 <kmc> heh
18:58:31 <monochrom> your abode is sublime
18:58:39 <monochrom> you bought it on subprime
18:58:46 <monochrom> I invested in your CDO
18:58:53 <monochrom> now my assets have sublimed
19:04:21 <kniu> It seems that my GHC install is irrevocably borked.
19:04:33 <kmc> perhaps bonghits will fix your GHC install
19:04:47 <kniu> Tried it, didn't work.
19:04:57 <monochrom> what symptoms do you have?
19:05:29 <kniu> Hunger, slight drowsiness.
19:05:47 <monochrom> ... that's zombie symptoms!
19:06:10 <kmc> renegade!
19:09:27 <kniu> what is ~/.ghc and why does it exist
19:10:23 <monochrom> package metadata. see my http://www.vex.net/~trebla/haskell/sicp.xhtml
19:10:41 <tswett> kniu: I'm guessing it contains some of GHC's data.
19:15:30 <crespo> hi, it's me again, could anyone explain me one stuff, I know the type of curry and flip, I know that f :: (a,b) ->c , so why  flip (curry f) :: b -> a -> c
19:15:32 <crespo> I don't see it
19:15:48 <tswett> @type flip
19:15:50 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
19:15:52 <tswett> @type curry
19:15:52 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:16:05 <tswett> Ignore what lambdabot says the type of flip is.  She's having a bad day.
19:16:11 <crespo> flip :: (b -> a -> c) -> a -> b -> c
19:16:21 <kmc> @type Prelude.flip
19:16:21 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
19:16:31 <tswett> Well, curry f :: a -> b -> c, right?  So flip (curry f) will have the type b -> a -> c.
19:16:32 <crespo> ok
19:16:56 <crespo> I don't get why curry f :: a->b->c
19:16:58 <ruiwkinox> hi, everyone
19:17:07 <ruiwkinox> i got a question
19:17:25 <ruiwkinox> did i need to learn other prog lang b4 learn haskell ?
19:17:42 <kmc> no
19:17:44 <tswett> crespo: well, curry :: ((a, b) -> c) -> (a -> b -> c), right?  So you plug ((a, b) -> c) into the left and get (a -> b -> c) out the right.
19:17:45 <kmc> in fact it might help if you don't
19:17:49 <kmc> haskell is very different
19:18:04 <monochrom> just make sure you have basic computer literacy
19:18:23 <kmc> curry :: ((a,b) -> c) -> (a -> b -> c)
19:18:25 <monochrom> just so that if we suggest "delete that file" you don't go "wtflolbbq?"
19:18:27 <kmc> :t curry
19:18:28 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:18:30 <ruiwkinox> i m 14 years old and learn some basic of python b4
19:19:10 <tswett> ruiwkinox: excellent.  Good luck!
19:19:10 <crespo> kmc, I don't get that plug
19:19:13 <kmc> crespo, remember that (A -> B -> C) is (A -> (B -> C))
19:19:39 <ruiwkinox> tswett: thanks
19:20:07 <monochrom> it also helps if you rock at algebra
19:20:17 <tswett> crespo: well, there are a couple of steps.  We want to calculate the type of "f x", where f :: ((a, b) -> c) -> (a -> b -> c), and x :: (a, b) -> c.
19:20:47 <tswett> crespo: the first thing we should do is change the types of f and x so that they don't have any letters in common; we don't want to use the same letter to refer to two different things.
19:21:02 <tswett> crespo: so, we're going to say that x :: (d, e) -> g.
19:21:56 <tswett> crespo: now, f's input type is the thing to the left of the arrow, or ((a, b) -> c).  We set the input type equal to the type of x, because x is the input.  That means we're setting ((a, b) -> c) = ((d, e) -> g.
19:22:22 <mjo> I have a function (constructor) that takes 27 arguments. Assuming I have those arguments in a list, is there an easy way to pass them to the constructor? It seems like some kind of fold should work but I can't find one where the types match up.
19:23:15 <hydo> mjo: I wrote something for that once, though I'm sure someone else here has a better way.
19:23:22 <tswett> crespo: and this means that a = d, b = e, and c = g.  That step is done; now the output type of f is equal to the type of f x, since f x is the output.  The output is (a -> b -> c), but we need to change those letters so we're using the letters in the type of x.
19:23:43 <kmc> mjo, not really
19:23:49 <tswett> crespo: so we substitute everything, and we get (d, e) -> g.  Thus, that's our answer: f x :: (d, e) -> g.
19:23:51 <kmc> let's say this function exists
19:24:01 <kmc> so that «magicFold ctor xs» is the expression you want
19:24:08 <kmc> where ctor is the 27-ary function, and xs is the list of args
19:24:10 <kmc> what's the type of magicFold?
19:24:28 <monochrom> I am 27-ary, going on 28-ary...
19:24:37 <monochrom> @quote monochrom 18-ary
19:24:37 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
19:24:55 <kmc> you can sort of do it, by typeclass overloading of magicFold, if you're willing to give up compile-time checking of the length of xs
19:25:01 <kmc> (and of the types, if they're not all the same)
19:25:03 <mjo> Eh, I see now
19:25:06 <kmc> look at how Text.Printf works
19:25:12 <crespo> tswett, eee, You said that it's a->b->c->
19:25:48 <mjo> All the arguments are doubles, but I only need to do this once, so I'll just write them out. That way, I'll even remember how it works tomorrow.
19:26:05 <kmc> 3x3x3 matrix?
19:26:21 <crespo> I mean f :: ((a,b) -> c) ->a ->b ->c and x::(a,b)->c then (f x) :: a->b->c
19:26:28 <mjo> Basically. Cubes in 3d.
19:26:36 <hydo> mjo: here's what I used.  http://snurl.com/27szi3  probably not the best way to do it, but it felt good a the time.
19:27:16 <crespo> right?
19:27:27 <tswett> crespo: yes, that's the thing.  Consider a sentence like "for all x and y, x + y = y + x".  Can you see how it's equivalent to a sentence like "for all a and b, a + b = b + a"?
19:27:34 <mjo> hydo: Thanks, but that looks way overkill =)
19:27:49 <tswett> crespo: if you replace one letter with another, the type remains equivalent.
19:27:59 <hydo> mjo: yea, i'm reading back over it now for the first time in a long while, and I'd have to agree.
19:28:14 <mjo> I'm just gonna do top_left <- arbitrary :: Gen Double, top_right <- arbitrary :: Gen Double...
19:28:15 <crespo> tswett, ok it seems that i got it
19:28:17 <crespo> thanks
19:28:28 <tswett> You're welcome.
19:28:48 <kmc> [x0, x1, x2, x3, x4, ..., x26] <- replicateM 27 arbitrary
19:29:03 * kmc thinks this is another use case for the missing quick and dirty preprocessor
19:29:20 <kmc> it's almost certainly too much trouble to write that list pattern as a proper TH splice
19:29:27 <kmc> especially with the current sorry state of TH
19:29:41 * shachaf suggests recursive cpp macros.
19:30:01 <kmc> but $(intercalate ", " [ "x" ++ show n | n <- [0..26]]) would be nice
19:30:03 <overscore> templete metaprogramming :)
19:30:03 <ruiwkinox> sorry, can i start with real world haskell , this book ?
19:30:08 <kmc> yes ruiwkinox
19:30:11 <ruiwkinox> is tat for beginner
19:30:11 <kmc> or you might like Learn You A Haskell
19:30:16 <kmc> they're both good books, both suitable for beginners
19:30:27 <kmc> very different though, so take a look at both and see which you prefer
19:30:30 <kmc> they're both available for free online
19:30:33 <ruiwkinox> kmc: thanks
19:30:34 <crespo> tswett, but please show me one more example, 'cos I'm not 100% sure, how would it look from different side, I mean I got curry type I got (curry f) :: b->a->c and I gotta calculate f :: type?
19:31:22 <mjo> The final solution: copy the data definition, and find/replace :: Double to <- arbitrary :: Gen Double. Total time, 30 seconds. I deserve coffee.
19:31:35 <kmc> use a vim macro
19:31:55 <tswett> crespo: ah, good question.  uncurry is the inverse function of curry, so uncurry (curry f) = f.  You know the type of curry f, and the type of uncurry is, in a sense, the reverse of the type of curry.
19:31:59 <tswett> @type Prelude.uncurry
19:32:00 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:32:03 <tswett> @type Prelude.curry
19:32:04 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:33:12 <tswett> crespo: so, you can simply reverse the type of curry and do what you did before.  There's another way to think of it, and that is that you can plug the input's type into the *right* side of the arrow and read the output type out of the *left*.
19:34:08 <Kaidelong> tswett: In a sense? Isn't it the reverse, exactly?
19:34:27 <crespo> tswett, but not all functions have their reverse-function
19:34:29 <tswett> Kaidelong: well, another way to reverse it is c <- (b, a) <- (c <- b <- a).  :)
19:34:40 <crespo> isn't there any universal way to do that
19:34:47 <crespo> I mean, without knowledge about uncurry
19:34:57 <tswett> crespo: not every function has an inverse function, but it is always possible to determine what the type of the inverse function *would* be.
19:35:22 <tswett> If a function has the type (blah blah blah) -> (yada yada yada), its inverse would have the type (yada yada yada) -> (blah blah blah).
19:36:36 <crespo> ok, so I reversed curry and get uncurry, but still don't see how should i solve this
19:37:29 <tswett> crespo: you have the type of uncurry, and the type of curry f, and you're looking for the type of uncurry (curry f), right?
19:37:44 <crespo> yup
19:39:27 <tswett> Well, first we can write them down.  uncurry :: (a -> b -> c) -> ((a, b) -> c), and curry f :: a -> b -> c.  Or we could keep using the letters we've used before.  I think those were curry f :: d -> e -> g.
19:40:32 <tswett> We identify the input type of uncurry (which is (a -> b -> c)) and the type of curry f (which is (d -> e -> g)) and we set them equal: a -> b -> c = d -> e -> g.  This means that a = d, b = e, and c = g.
19:41:12 <tswett> Finally, we look at the output type of uncurry (which is ((a, b) -> c)), and substitute those equations in.  We get ((d, e) -> g), and that's the answer.
19:41:43 <crespo> so f :: (d,e)->g, right?
19:41:51 <kmc> back later
19:41:55 <tswett> crespo: right.
19:42:14 <crespo> ok, thanks
19:42:39 <crespo> btw, could You recommend any books/website to train that kind of excerceises?
19:43:28 <tswett> Hm.  I'm afraid I don't know of any.  You could always simply try doing this with types you encounter in programming, and see if they match what Haskell says.
19:43:49 <crespo> good idea :)
19:56:24 <dbpatterson> for people who use mongodb, how do you represent tuples? My initial thought is just as an array of values with something like untuple (x,y) = [val x, val y] but I'm wondering if this is the best solution / if there are better ways to do it...
20:02:49 <ruiwkinox> any editor recommend for haskell ?
20:03:41 <monochrom> emacs, eclipse, vim, jedit, notepad++...
20:03:57 <shachaf> ruiwkinox: Most editors will do. Things like syntax highlighting and autoindent and so on are nice, but it doesn't matter a whole lot.
20:06:13 <ruiwkinox> for mac ?
20:07:00 <dbpatterson> ruiwkinox:  if you already use textmate, the haskell mode is pretty good.
20:07:25 <ruiwkinox> ya, textmate is good
20:07:37 <ruiwkinox> ok, i will continue with textmate
20:07:47 <dbpatterson> ruiwkinox: ^ Shift H gives you hoogle on what is selected
20:07:49 <ruiwkinox> thx for all the help ya, thks
20:09:06 <ruiwkinox> dbpatterson: do i need to install haskell support from bundle ?
20:09:46 <dbpatterson> ruiwkinox: can't remember. I think it might be included by default
20:10:44 <ruiwkinox> nvm, goooogle...ha
20:13:54 <ManateeLazyCat> Hey, all. :)
20:18:01 <overscore> how do you type Hex literals in haskell ?
20:18:11 <overscore> '\x32'
20:18:38 <monochrom> @type '\x32'
20:18:39 <lambdabot> Char
20:18:47 <monochrom> @type \x32
20:18:48 <lambdabot> parse error (possibly incorrect indentation)
20:18:53 <monochrom> @type 0x32
20:18:54 <lambdabot> forall t. (Num t) => t
20:19:02 <overscore> neat.
20:19:04 <monochrom> > ('\x32', 0x32)
20:19:05 <lambdabot>   ('2',50)
21:11:26 <Mathnerd314> is (,) an arrow or category?
21:13:47 <dibblego> @djinn (a,a)
21:13:48 <lambdabot> -- f cannot be realized.
21:14:13 <stepkut> aren't all arrows categories?
21:15:24 <Mathnerd314> stepkut: yeah
21:15:46 <Mathnerd314> dibblego: so probably not. but it's some sort of special something.
21:15:54 <dibblego> binary functor
21:17:55 <Mathnerd314> ok
21:24:19 <crespo> hi (again)
21:24:29 <dmwit> Hi! (again)
21:25:00 <crespo> i'm trying to learn haskell, browsing some haskell excercices and one of them curious me, could you give me some hints?
21:25:04 <crespo> this one: http://pastebin.com/SvWQuN7t
21:25:24 <crespo> I think, that the solution should be: for every integer (x, m, n) this is true, but how to make a formal proof?
21:25:52 <dmwit> Do you know about induction?
21:26:08 <crespo> yup
21:26:21 <crespo> but how should I use it?
21:26:46 <dmwit> I would guess you'd go by induction on n.
21:26:47 <crespo> in this case
21:27:57 <dmwit> If you want to be very careful, you'll have to remember that induction isn't quite the same in Hask as it is in Set.
21:28:14 <crespo> but what should I prove there by induction?  (I know that first 8 lines are true)
21:28:34 <dmwit> Depending on the exercises, it might be simpler to just assume that you're using a subset of Haskell that doesn't include general recursion -- just total functions (and values).
21:28:51 <dmwit> crespo: I'm not sure I understand the question.
21:29:09 <dmwit> I thought you said you wanted to prove that for all x, m, n, we have the equation x ^ (m + n) = (x ^ m) * (x ^ n)
21:29:44 <dmwit> If that's what you want to prove, then that's what you should prove. =P
21:29:49 <crespo> based on that 8 facts (in first 8 lines)
21:29:54 <dmwit> Yep.
21:29:59 <dmwit> Based on those 8 facts.
21:30:20 <maurer_> http://www.lamebook.com/lesson-learned-2/lesson-learned-2/
21:30:28 <maurer_> err, wrong channel
21:30:29 <maurer_> Apologies
21:31:21 <crespo> so the first step is n=Zero, than i got x^(m+Zero) = x^m and x^m * (x^Zero) = x^m, right?
21:31:38 <dmwit> That's the first thing to prove, yep.
21:32:07 <crespo> and how should the induction in Haskell look like next? You said, it's different
21:32:24 <dmwit> Why don't you try the normal induction first?
21:33:35 <crespo> so I gotta prove, that x^(m + Succ n) = (x^m) * (x^ Succ n) right?
21:34:07 <Eduard_Munteanu> Yeah.
21:34:31 <dmwit> Yes, and you get to assume that x^(m+n) = (x^m) * (x^n).
21:34:37 <dmwit> During that proof.
21:35:00 <crespo> x^(Succ (m+n)) = x^m * x^n * x
21:35:37 <dmwit> Careful, now.
21:36:09 <crespo> I don't have got the definition of Succ
21:36:27 <dmwit> I'm having trouble parsing that sentence.
21:36:37 <augur> if you have o prove x^(m + succ n) = (x^m) * (x^n)
21:36:44 <Eduard_Munteanu> But you can use the definition of those operations.
21:36:51 <augur> er, ... (x^(succ n))
21:36:55 <augur> then your proof is done
21:37:01 <crespo> I mean, can I write, that x^(Succ(m+n)) = x^(m+n+1) ?
21:37:07 <augur> because you get to assume the answer
21:37:28 <dmwit> augur: Uh, what? That doesn't sound right to me.
21:37:31 <augur> x^(m+n) = (x^m) * (x^n) is an inference pattern you have
21:37:35 <crespo> augur, it's not
21:37:37 <augur> for all m and n, no?
21:37:46 <dmwit> crespo: What's this "1" you speak of?
21:37:53 <Eduard_Munteanu> m + Succ n = Succ (m + n)    and     m ^ Succ n = (m ^ n) * m
21:38:03 <dmwit> augur: No, it's what we're trying to prove (by induction on n).
21:39:01 <crespo> x^(Succ (m+n)) = x^m * x^n * x  => x^(Succ (m+n)) = x^(m+n) * x
21:39:03 <Eduard_Munteanu> So now you can extract the hypothesis from the second, except multiplied by 'm'.
21:39:20 <dmwit> crespo: Looks valid, though you might have to prove that (*) is associative.
21:39:38 <dmwit> err...
21:40:16 <dmwit> Valid, even without associativity, but not quite what you're trying to prove, no?
21:40:38 <crespo> yup, so let's start again, I got x^(Succ (m+n)) = x^m * x^n * x
21:40:47 <dmwit> That's not the beginning.
21:40:56 <dmwit> The beginning is x ^ (m + Succ n).
21:41:09 <crespo> x^(m + Succ n) = (x^m) * (x^ Succ n) => x^(Succ (m+n)) = x^m * x^n * x
21:41:19 <Eduard_Munteanu> Be careful where you do your transformations.
21:41:34 <dmwit> crespo: No, that first equality is not okay.
21:42:04 <dmwit> crespo: We know that "x^(m + n) = x^m * x^n", but we don't yet know that "x^(m + Succ n) = x^m * x^Succ n".
21:42:30 <dmwit> However, we *do* know the definition of the (+) operation, so why not expand that?
21:42:40 <dmwit> x^(m + Succ n) = x^( ...? )
21:43:20 <crespo> so it's what i've done x^(m + Succ n) = x^(Succ (m+n))
21:43:27 <dmwit> Yep.
21:43:36 <dmwit> And now we know the definition of the (^) operation, so next...
21:44:09 <crespo> x^(m+n)*x
21:44:12 <Eduard_Munteanu> On the lhs you have x^(m + Succ n) = x^(Succ (m + n)) = x^(m + n) * x, which is equal to the rhs (x^m) * (x^ Succ n)   (since '=' is a congruence)
21:44:17 <dmwit> Right, exactly!
21:44:23 <dmwit> So, so far we've got
21:44:39 <dmwit> x^(m + Succ n) = x^(Succ (m+n)) = x^(m+n) * x
21:44:50 <dmwit> Now, what do we know that could get us a bit farther?
21:44:51 <Eduard_Munteanu> (oops, equivalence)
21:45:32 <crespo> now I gotta transform rhs, right?
21:45:41 <dmwit> No, let's keep working forward.
21:45:45 <dmwit> Don't get wishy-washy on me. =)
21:45:49 <dmwit> You want a hint?
21:46:02 <crespo> w8, we got x^(m + Succ n)=x^(Succ (m+n)) = x^(m+n)*x
21:46:10 <crespo> what should we do now?
21:46:39 <dmwit> Oh, which RHS did you mean? Did you mean you want to transform the "x^(m+n) * x" bit?
21:46:46 <dmwit> If that's what you meant, then I'm perfectly happy with that.
21:47:31 <crespo> I wanna transform it to get (x ^ m) * (x ^ Succ n)
21:47:36 <Eduard_Munteanu> Alternatively you can transform the other side, invoke congruence and get rid of the extra 'x'.
21:48:00 <dmwit> crespo: Right. So what do we know that can help us get a bit farther?
21:48:22 <Eduard_Munteanu> So then you can work on a simpler lemma, x ^ (m + n) = x^m * x^n
21:48:24 <crespo> or imho, it will be easier to transform (x ^ m) * (x ^ Succ n) to x^(m+n)*x ?
21:48:49 <dmwit> crespo: No, that's what I want you to avoid. That's what I meant by not being wishy-washy.
21:49:03 <crespo> could You tell me why?
21:49:06 <dmwit> Yes.
21:49:24 <dmwit> Going in either direction, you will eventually get to a point where you must make progress from the place we are.
21:49:29 <dmwit> Why not make that progress now?
21:49:33 <dmwit> Why delay it?
21:50:24 <crespo> ok, so x^(m+n) * x is x^m * x^n * x, right?
21:50:31 <dmwit> Yes, great!
21:50:49 <Eduard_Munteanu> You'll need to prove that.
21:50:57 <dmwit> No, that's the induction hypothesis.
21:51:00 <dmwit> No proof necessary.
21:51:08 <Eduard_Munteanu> Oh, crap, right.
21:51:12 <Eduard_Munteanu> I totally forgot :)
21:51:26 <crespo> and x^n*x is x^(Succ n)
21:51:35 <dmwit> crespo: Yes!
21:51:43 <crespo> so I got x^m * x^(Succ n)
21:51:47 <dmwit> So we finally got where we meant to be. =)
21:51:48 <dmwit> Great.
21:51:57 <dmwit> crespo: Now, there's ooooone niggling little detail.
21:52:15 <Eduard_Munteanu> refl :P
21:52:33 <dmwit> x^(m+n) * x = (x^m * x^n) * x, but x^m * x^Succ n = x^m * (x^n * x)
21:53:01 <dmwit> So if you really want to be rigorous, you've got to also prove a little side lemma saying "(x * y) * z = x * (y * z)", for all x, y, z.
21:53:48 <crespo> but should I use for that prove only that 8 facts?
21:53:51 <crespo> i got
21:53:53 <dmwit> yep
21:54:09 <dmwit> It's not hard, just another induction. You should decide for yourself whether you think it will be instructive to try it or not.
21:54:40 <crespo> it will be nice to train some induction by prooving that
21:54:51 * dmwit nods encouragingly
21:55:29 <crespo> but I haven't got the definition of (*) there
21:55:56 <dmwit> What?
21:55:58 <dmwit> Yes you have.
21:56:19 <dmwit> m * Zero = Zero; m * Succ n = (m * n) + m
21:56:24 <dmwit> facts 5 and 6 =)
21:56:27 <crespo> err, ok
21:57:54 <crespo> i'm trying to think how to start with that
21:59:20 <crespo> i mean induction on what
21:59:49 <Eduard_Munteanu> It might help to do commutativity first.
21:59:58 <Eduard_Munteanu> Though you don't need it.
22:00:12 <dmwit> crespo: Try induction on z, perhaps.
22:00:31 <dmwit> Let's see...
22:00:59 <crespo> (x*y)*Zero = Zero = x*(y*Zero) - first step
22:01:17 <crespo> (x*y)*Succ z = x*(y*SUcc z)
22:02:10 <crespo> (x*y)*Succ z = (x*y)*z + (x*y)
22:02:20 <crespo> right?
22:02:44 <dmwit> Good so far.
22:03:09 <dmwit> Haha, you will probably also need to prove distributivity.
22:03:13 <Eduard_Munteanu> :)
22:03:13 <dmwit> How annoying.
22:03:45 <dmwit> e.g. you'll have to prove that x*(y+z) = (x*y) + (x*z), I bet.
22:03:58 <dmwit> Why don't you assume that it's true for the purposes of doing this proof, though.
22:04:26 <crespo> i wanna learn how to do it
22:04:41 <dmwit> Oh, for sure!
22:04:54 <crespo> i mean let's assume that distributivity is true
22:04:59 <dmwit> But when I try to do two proofs at once I invariably get lost. =P
22:05:19 <Eduard_Munteanu> BTW, you might want to look into Agda if you want to do formal proofs and have them checked by a computer instead of a dmwit ;)
22:05:30 <Eduard_Munteanu> It's pretty Haskellish.
22:05:38 <crespo> Eduard_Munteanu, what's Agda?
22:06:43 <Eduard_Munteanu> A more researchy language, oriented on theorem proving and programming with more advanced type systems, partly inspired by Haskell.
22:06:57 <dmwit> Agda is a machine-checked proof system pretending to be a programming language. =P
22:07:05 <Eduard_Munteanu> Or that :P
22:07:27 <crespo> http://wiki.portal.chalmers.se/agda/pmwiki.php
22:07:28 <Eduard_Munteanu> http://wiki.portal.chalmers.se/agda/pmwiki.php    and also #agda here on Freenode.
22:07:29 <crespo> right?
22:07:32 <crespo> ok
22:07:32 <Eduard_Munteanu> Yeah.
22:07:43 <crespo> well sounds interesting ;]
22:07:55 <crespo> so it's better to see that ;]
22:08:04 <crespo> thank you a lot for help, and bye ;]
22:08:17 <dmwit> bye
22:09:54 <Eduard_Munteanu> Hrmpf... this might be a premiere: somebody coming in #haskell for help and ending up by ditching it for Agda :P
22:10:33 * hackagebot http-enumerator 0.6.4 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.4 (MichaelSnoyman)
22:11:44 <Eduard_Munteanu> Anyway, I think he's doing rather well with this stuff, really.
22:13:06 <dmwit> Definitely.
23:57:57 <dibblego> if (ask :: Pointed f => Kleisli a f a) then (? :: CoPointed f => CoKleisli a f a)
